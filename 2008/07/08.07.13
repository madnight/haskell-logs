00:00:19 <wuxia>  i'm awesome
00:00:25 <wuxia> i have alt hjkl mapped properly too
00:00:30 <wuxia> througn using urxvt-unicode
00:00:46 <wuxia> so i can use alt-h,l to switch gbetween tabs of urxvt terminals (the termiiinal supports tabs in itself)
00:00:58 <wuxia> and alt-jk to move down/up windows inside of xmonad
00:01:01 <wuxia> it's pretty sweet
00:02:50 <mmorrow> hehe
00:12:35 <proqesi> @src ExitSuccess
00:12:35 <lambdabot> Source not found. :(
00:12:55 <proqesi> @src ExitException
00:12:55 <lambdabot> Source not found. Wrong!  You cheating scum!
00:13:01 <proqesi> :(
00:14:17 <mmorrow> heh, list permute function from yhc one-liner-ized
00:14:25 <mmorrow> > let shuffle g xs = go g (length xs-1) xs ; go _ _ [] = [] ; go g n xs = let (i,g') = randomR (0,n) g ; (x,y:ys) = splitAt i xs in y : go g' (n-1) (x++ys) in shuffle (mkStdGen 42) [0..9]
00:14:40 <lambdabot>  thread killed
00:14:45 <mmorrow> um
00:14:53 <mmorrow> > 1
00:14:54 <lambdabot>  1
00:15:06 <mmorrow> > mkStdGen 42
00:15:07 <lambdabot>  43 1
00:15:49 <mmorrow> > let { shuffle g xs = go g (length xs-1) xs ; go _ _ [] = [] ; go g n xs = let (i,g') = randomR (0,n) g ; (x,y:ys) = splitAt i xs in y : go g' (n-1) (x++ys) } in shuffle (mkStdGen 42) [0..9]
00:15:50 <lambdabot>  [1,4,7,6,3,2,8,9,0,5]
00:21:03 <mofmog> "Failed to load interface for 'Eval'"
00:21:09 <mofmog> it works in GHCi
00:21:11 <mofmog> but not ghc
00:23:11 <jpcooper> http://hpaste.org/8902
00:23:21 <jpcooper> which would be a correct type definition for magnitude?
00:25:41 <vixey> there is no valid type for that function
00:25:57 <vixey> if you comment out the annotation then ghc will tell you this
00:26:11 <vixey> you can fix it ((^2) . fromIntegral)
00:26:31 <jpcooper> aah, thank you
00:27:20 <jpcooper> hmm, doesn't for me
00:27:55 <jpcooper> it works though. Thanks
00:29:19 <jpcooper> vixey, is it possible to make Vector an instance of Ord just by it having the magnitude function?
00:29:49 <vixey> @src Ord
00:29:50 <lambdabot> class  (Eq a) => Ord a  where
00:29:50 <lambdabot>     compare      :: a -> a -> Ordering
00:29:50 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
00:29:50 <lambdabot>     max, min         :: a -> a -> a
00:30:02 <vixey> instance Ord Vector where
00:30:10 <vixey>   compare = comparing magnitude
00:30:13 <vixey> or something like that
00:30:33 <vixey> :t comparing fst
00:30:34 <lambdabot> forall a b. (Ord a) => (a, b) -> (a, b) -> Ordering
00:31:18 <jpcooper> :t comparing
00:31:19 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
00:31:23 <jpcooper> aah, thanks
00:34:03 <jpcooper> vixey, how come I only needed to implement compare?
00:35:22 <jpcooper> aah, says there's a minimal complete definition
00:35:27 <jpcooper> I guess the rest are for efficiency?
00:45:10 <jpcooper> vixey,
00:45:11 <jpcooper> data Shape =
00:45:11 <jpcooper>            Sphere {centre :: Vector,
00:45:11 <jpcooper>                    radius :: (Num a) => a}
00:45:17 <jpcooper> why is that not possible?
00:46:20 <vixey> you can't have Num a there like that
00:46:22 <paczesiowa> use data (Num a) => Shape a ...
00:47:19 <jpcooper> right
00:47:22 <jpcooper> thanks
01:32:59 <vixey> When is it safe to unsafeCoerce?
01:34:04 <Deewiant> http://www.haskell.org/ghc/docs/latest/html/libraries/base/GHC-Prim.html#v%3AunsafeCoerce%23
01:34:05 <vixey> http://www.haskell.org/pipermail/libraries/2006-November/006361.html
01:34:06 <lambdabot> Title: GHC.Prim, http://tinyurl.com/298ag5
01:34:07 <lambdabot> Title: proposal: add 'unsafeCoerce', http://tinyurl.com/5dazhj
01:34:53 <vixey> yeah
01:34:56 <vixey> "It is generally used when you want to write a program that you know is well-typed, but where Haskell's type system is not expressive enough to prove that it is well typed" is kind is ...
01:35:05 <vixey> it's like an oxymoron
01:37:32 <vixey> What I want to figure out is if eval . unquote [] is valid
01:37:37 <ski> i'd rather say "It is generally used when you want to write a program that you know will not \"go wrong\", but where ..."
01:37:40 <vixey> which is in this paste http://hpaste.org/8696
01:38:15 <vixey> well.... If you put terms that would be well typed into it that is
01:39:04 <vixey> oh I haven't tried it with typeclasses
01:39:25 <vixey> I don't think it works in general though
01:42:20 <ski> lambdabot: ty
01:46:27 <vixey> well if I have some code which would type as a valid haskell term,
01:46:46 <vixey> may I use unsafeCoerce to construct the actual haskell term (from a representation of it)
01:47:01 <vixey> and that terms evaluation will be as it should?
01:47:18 <vixey> I should certainly think it's the case but it's hard to know..
01:47:36 <vixey> and I mean my code (which does this) works
01:47:43 <vixey> which is at least some kind of positive evidence
01:56:14 <vixey> maybe I am doing it the wrong way...
01:58:05 <jsnx> vixey: we can has codez?
02:03:05 <vixey> does anyone know of some examples of HOAS in Haskell?
02:03:50 <vixey> the type preserving compiler says it uses HOAS but I couldn't find the source code
02:04:09 <lament> high-order abstraction stuff?
02:04:28 <vixey> higher order abstact syntax
02:04:45 <kosmikus> vixey: which type-preserving compiler?
02:09:11 <vixey> kosmikus, http://www.iro.umontreal.ca/~monnier/tpch.pdf
02:09:13 <lambdabot> Title: A Type-Preserving Compiler in Haskell
02:16:53 <kosmikus> vixey: thanks
02:17:25 <mofmog> so i compiled a program that uses readline and i sent it to my friend. He can't run it because apparently "error while loading shared libraries: libreadline.so.5: cannot open shared object file: No such file or directory"
02:17:40 <mofmog> which is strange because he's running ubuntu too and readline should be installed
02:17:53 <mofmog> does haskell use some super special version?
02:19:31 <lament> mofmog: ldd the executabel
02:19:34 <lament> executable
02:20:55 <mofmog> ldd?
02:23:37 <Cale> mofmog: tells you what it's linking with
02:24:36 <mofmog> he ldd'd and it matches with mine mostly except
02:24:45 <mofmog>  libreadline.so.5 => /lib/libreadline.so.5 (0xb7ecf000)
02:24:48 <mofmog> is not found
02:25:50 <Cale> Hmm... I suppose the only thing for it is to check that libreadline5 really is installed.
02:26:18 <mofmog> he did sudo apt-get install libreadline5 and apparently he has the latest version
02:26:39 <mofmog> i used ghc --make -O2 Main.hs -o RPNEval
02:26:46 <mofmog> could either --make or -O2 be the problem?
02:27:24 <mofmog> i'd hesitate to make him dl ghc and then compile the code from source lol
02:29:06 <astrolabe> mofmog: Do you have the latest libreadline?
02:31:04 <mofmog> yup
02:39:14 <plutonas> schme: now i am...
02:53:48 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/TimePiece-0.0.1 is fun
02:53:50 <lambdabot> Title: HackageDB: TimePiece-0.0.1, http://tinyurl.com/66kzam
03:09:09 <hackage> Uploaded to hackage: TimePiece 0.0.1
03:42:53 <jpcooper> dot :: Num a => Vector a -> Vector a -> a
03:42:53 <jpcooper> dot v w = sum $ (on (zipWith (*)) components) v w
03:43:04 <jpcooper> is there any way to omit the argument names?
03:43:35 <quicksilver> @pl \v w ->  sum $ (on (zipWith (*)) components) v w
03:43:35 <lambdabot> (sum .) . on (zipWith (*)) components
03:43:36 <mauke> @pl dot v w = sum $ (on (zipWith (*)) components) v w
03:43:36 <lambdabot> dot = (sum .) . on (zipWith (*)) components
03:43:41 <paczesiowa> dot = sum . on (zipWith (*)) components
03:43:43 * quicksilver wins race.
03:43:55 <ski> paczesiowa : no
03:43:57 <jpcooper> cheers :)
03:44:06 <jpcooper> I didn't think that . could work that way
03:44:11 <jpcooper> as sum needs a list
03:44:19 <jpcooper> oh but I get it, never mind
03:44:38 <ski> you can also use `on' infix
03:44:41 <jpcooper> I'm still trying to see the difference between $ and .
03:44:48 <vixey> f $ x = f x
03:44:55 <vixey> (f . g) x = f (g x)
03:45:08 <vixey> f $ g $ h $ x = f . g . h $ x
03:45:28 <Baughn> map (map words . lines) "foo bar\nbaz"
03:45:31 <Baughn> > map (map words . lines) "foo bar\nbaz"
03:45:32 <lambdabot>  Couldn't match expected type `String' against inferred type `Char'
03:45:33 <jpcooper> dot :: Num a => Vector a -> Vector a -> a
03:45:33 <jpcooper> dot = sum . (zipWith (*) `on` components)
03:45:35 <jpcooper> doesn't want to work
03:45:37 <ski> f $ (g $ (h $ x)) = (f . g . h) $ x
03:45:47 <jpcooper> aah I get it now
03:45:50 <jpcooper> (sum . on)
03:46:03 <ski> (sum .) . blah
03:46:05 <ski> or
03:46:08 <ski> sum .: blah
03:46:28 <vixey> ((.).(.)) sum blah
03:46:45 <jpcooper> so how do I write my function with infix on?
03:46:47 <ski> sum `(.).(.)` blah   -- :/
03:46:54 <jpcooper> I know that I can do it with `on`
03:47:06 <vixey> jpcooper: it was already shown
03:47:19 <jpcooper> I can't see it
03:47:58 <ski> you yourself used `on' infix
03:48:05 <Baughn> jpcooper: It depends on the function name. Symbolic names default to infix; alphabetic ones default to prefix
03:48:17 <Baughn> In either case, you can reverse that by using parantheses or `foo`
03:48:20 <jpcooper> yes
03:48:31 <jpcooper> ski, I'm wondering how to make it work, though
03:48:33 <ski> (however, you didn't compose it correctly with `sum', in that case)
03:48:49 <vixey> jpcooper: look at the @pl examples
03:49:28 <jpcooper> dot = sum . on (zipWith (*)) components definitely isn't working
03:49:39 <Baughn> > `negate` 2
03:49:40 <lambdabot>   parse error on input ``'
03:49:55 <mauke> jpcooper: so why do you keep repeating it?
03:50:03 <ski> jpcooper : please read more closely what lambdabot told you above
03:50:15 <vixey> for example
03:50:19 <vixey> > 1 + 2
03:50:21 <lambdabot>  3
03:50:27 <vixey> > sqrt (1 + 2)
03:50:28 <lambdabot>  1.7320508075688772
03:50:34 <vixey> > sqrt . (+) $ 1 2
03:50:36 <lambdabot>        add an instance declaration for (Num (t -> a), Floating (a -> a))
03:50:52 <vixey> > ((sqrt .) . (+)) 1 2
03:50:54 <lambdabot>  1.7320508075688772
03:51:16 <vixey> > (((.).(.)) sqrt (+)) 1 2
03:51:18 <lambdabot>  1.7320508075688772
03:51:45 <vixey> > let u (.:) b = \x y -> u (b x y) in (sqrt .: (+)) 1 2
03:51:46 <lambdabot>   Not in scope: `.:'
03:51:53 <vixey> > let u .: b = \x y -> u (b x y) in (sqrt .: (+)) 1 2
03:51:54 <lambdabot>  1.7320508075688772
03:53:35 <vixey> > let u .: b = \x y -> u (b x y) in sqrt .: ((+)`on`(join (*)) 3 4
03:53:35 <lambdabot> Unbalanced parentheses
03:53:41 <vixey> > let u .: b = \x y -> u (b x y) in sqrt .: ((+)`on`(join (*))) 3 4
03:53:43 <lambdabot>   add an instance declaration for (Num (t -> t1 -> t2))
03:53:48 <vixey> > let u .: b = \x y -> u (b x y) in (sqrt .: ((+)`on`(join (*)))) 3 4
03:53:50 <lambdabot>  5.0
03:54:07 <vixey> @pl \x y -> u (b x y)
03:54:08 <lambdabot> (u .) . b
03:55:05 <ski> @pl \u b x y -> u (b x y)
03:55:05 <lambdabot> (.) . (.)
04:04:05 <plutonas> chapter 6 of realworldhaskell is a total mess
04:06:37 <jpcooper> say I have the function magnitude which gives the magnitude of a vector
04:06:37 <plutonas> are the next chapters also like that?
04:06:48 <jpcooper> what's the nicest way to implement <= on vectors?
04:07:09 <vixey> (<=) = (<=)`on`magnitude
04:07:28 <jpcooper> of course
04:07:31 <jpcooper> thanks
04:08:31 <Baughn> @type on
04:08:33 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
04:09:11 <hackage> Uploaded to hackage: CPBrainfuck 1.0
04:10:11 <jpcooper> is there any condition where Floating a might not be Ord a?
04:10:26 <Baughn> > (*) `on` (+1) 3 4
04:10:27 <lambdabot>   add an instance declaration for (Num (t -> a -> b))
04:10:44 <Baughn> @instances Ord
04:10:44 <lambdabot> (), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
04:10:55 <Baughn> @instances Floating
04:10:55 <lambdabot> Double, Float
04:11:06 <jpcooper> :info Floating
04:11:08 <Baughn> jpcooper: Well, if you instance a new Floating, I guess
04:11:11 <jpcooper> @info Floating
04:11:12 <lambdabot> Floating
04:11:21 <jpcooper> right
04:12:29 <Baughn> @type (*)
04:12:29 <lambdabot> forall a. (Num a) => a -> a -> a
04:12:35 <Baughn> @type (*) `on` (+1)
04:12:36 <lambdabot> forall a. (Num a) => a -> a -> a
04:12:42 <Baughn> @type (*) `on` (+1) 3
04:12:43 <lambdabot> forall b a. (Num (a -> b), Num b) => a -> a -> b
04:12:51 <Baughn> @type (*) `on` (+1) $ 3
04:12:51 <lambdabot>     precedence parsing error
04:12:51 <lambdabot>         cannot mix `on' [infixl 0] and `($)' [infixr 0] in the same infix expression
04:13:08 <Baughn> @type ((*) `on` (+1)) 3
04:13:09 <lambdabot> forall a. (Num a) => a -> a
04:13:15 <Baughn> > ((*) `on` (+1)) 3 4
04:13:16 <lambdabot>  20
04:14:52 <Baughn> Is there a list of fixity levels somewhere?
04:15:10 <Baughn> ..precedences, I mean
04:15:54 <vixey> :t ?f `on` ?g `on` ?h
04:15:55 <lambdabot> forall b c b1 a. (?h::a -> b1, ?g::b1 -> b, ?f::b -> b -> c) => a -> a -> c
04:16:07 <vixey> :t ?f `on` ?g `on` ?h `on` ?i
04:16:08 <lambdabot> forall b c b1 b2 a. (?i::a -> b2, ?h::b2 -> b1, ?g::b1 -> b, ?f::b -> b -> c) => a -> a -> c
04:16:27 <vixey> excellent
04:16:45 * Baughn hands vixey a white cat and a henchman
04:19:08 <kryptiskt> Baughn: there a precedence table in the Haskell98 report
04:19:25 <ski> @instances-importing Complex Floating
04:19:26 <lambdabot> Complex a, Double, Float
04:19:29 <ski> @instances-importing Complex Ord
04:19:30 <lambdabot> (), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
04:19:43 <ski> jpcooper : ^
04:19:45 <Baughn> kryptiskt: I was hoping for something more complete. Maybe I'll make one, then.
04:19:59 <mauke> > (0 :+ 1) ** 2 < 1
04:20:00 <lambdabot>   add an instance declaration for (Ord (Complex t))
04:20:00 <lambdabot>     In the expression: (0...
04:20:27 <jpcooper> yes, thanks ski
04:20:37 <Baughn> @where on
04:20:38 <lambdabot> I know nothing about on.
04:20:48 <Baughn> @hoogle on
04:20:48 <lambdabot> Data.Function.on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
04:20:48 <lambdabot> Test.QuickCheck.oneof :: [Gen a] -> Gen a
04:20:48 <lambdabot> Language.Haskell.Pretty.onsideIndent :: PPHsMode -> Indent
04:23:08 <vixey> @src on
04:23:09 <lambdabot> (*) `on` f = \x y -> f x * f y
04:33:21 <roconnor> who is AKIIIN-ist ?
04:33:53 <sqweek> checking for path to top of build tree... configure: error: cannot determine current directory
04:34:23 <sqweek> ^^ wtf? from ./configure in the ghc-6.8.3 binary package under linux
04:34:41 <Igloo> sqweek: What does running utils/pwd/pwd say?
04:34:53 <sqweek> zsh: floating point exception  utils/pwd/pwd
04:34:56 <sqweek> lol
04:35:06 <Igloo> Your system (libc?) is too old
04:35:17 <sqweek> because /bin/pwd isn't good enough *roll*
04:35:22 <sqweek> thanks though
04:35:30 <vixey> AKIIIN-ist: Who are you?
04:35:43 <Igloo> It's not if you want to work portably, no
04:35:50 * sqweek bets on spammer/bot
04:36:32 <mauke> a beautiful butterfly
04:36:37 <roconnor> What's the paper that discusses delimited continuations applied to web servers?
04:36:41 <Baughn> A philosopher
04:39:27 <Baughn> roconnor: http://okmij.org/ftp/Computation/Continuations.html <-- A couple in here
04:39:28 <lambdabot> Title: Continuations and delimited control
04:39:47 <roconnor> Persistent delimited continuations for CGI programming with nested transactions ?
04:40:04 <Baughn> I don't know if it's the one you were looking for. Should still be interesting, though
04:41:14 <roconnor> hmm
04:41:17 <sqweek> Igloo: right, because pwd varies so much between linux distros, and the current approach is obviously so very portable
04:41:21 <roconnor> it appears to be only slides
04:41:24 <roconnor> but it is a start
04:41:53 <Igloo> sqweek: Not between Linux distros, but butween Linux, Windows/cygwin, Windows/mingw
04:41:54 <ski> .. apparently turk-related
04:42:02 <Igloo> sqweek: And running the ghc binary will give you the same FPE
04:42:12 <Baughn> roconnor: Make sure you read both the PDFs
04:42:49 <vixey> why were they klined?
04:42:51 <sqweek> Igloo: right, but i downloaded the linux package
04:43:16 <sqweek> Igloo: i realise the fpe will be more widespread than pwd, and it's glibc's fault not ghc's
04:45:08 <sqweek> which is a fantastic achievement i have to admit, it must have taken a lot of work to break binary compatibility within the same fucking OS
04:45:28 <sqweek> anyway, thanks for pointing me in the right direction, won't disturb you further
04:47:13 <roconnor> Baughn: I'm reading the notes version
04:47:20 <roconnor> It seems to contain the slides as well
04:48:33 <__pao__> quick question (from a newbie): is that reasonable to have a non monadic io
04:48:52 <__pao__> ... for "readonly" programs?
04:48:57 <Baughn> __pao__: Define "non-monadic IO"
04:49:09 <ski> "readonly" ?
04:49:13 <Baughn> __pao__: There are several more or less reasonable ways. Lazy I/O, stream-based, etc..
04:49:28 <vixey> __pao__: It is possible to have non monadic IO in a predictable way
04:49:30 <osfameron> most programming langauges other than haskell have non-monadic IO...
04:49:46 <vixey> __pao__: I have tried it in terms of WHNFs producing side effects
04:49:48 <Baughn> No, most programming languages other than haskell have /only/ monadic IO, and nothing else
04:50:04 <__pao__> let me try to explain
04:50:37 <__pao__> I've a big, constant data structure that I load in memory at startup
04:50:43 <osfameron> Baughn: really?
04:51:01 <__pao__> I'd like to lazyly load it
04:51:16 <Baughn> osfameron: I'd like to think so. Code in languages like, say, Java looks a lot more like an IO do-block than anything else
04:51:25 <__pao__> and cache partial results
04:51:36 <Baughn> __pao__: That'd be lazy I/O, then
04:52:02 <vixey> __poa__: Monadic doesn't mean strict
04:52:25 <roconnor> readFile does things like this
04:52:42 <Baughn> __pao__: There are a couple problems with it - first, that the contents of your source file might change while you're reading it (you said yours won't); second, that any exceptions that happen while parsing/reading it will end up being thrown in the pure code that uses it, where they can't be caught
04:52:44 <__pao__> vixey: I would like to avoid changing the signature of my datastructure (a -> IO a)
04:52:48 <roconnor> although you need to be careful not to accidently write to the file while you are lazily reading it.
04:53:23 <__pao__> Baughn: are you talking about Lazy iO?
04:53:25 <Baughn> __pao__: Well, not a problem. Just read the file lazily - hGetContents, or lazy bytestring - and then parse it with ordinary, pure code
04:53:31 <Baughn> __pao__: Yes
04:53:31 <ski> __pao__ : your data signature is `a -> IO a' ?
04:54:01 <__pao__> Baughn: that seems my solution, thanks
04:54:32 <__pao__> ski: sorry... my data is now "a"
04:54:50 <rwbarton> if you're going to use unsafeInterleaveIO (under the hood) any reason not to use unsafePerformIO instead?
04:54:59 <__pao__> ski: if I'd use "standard monadic IO" and load it lazily it would become "IO a"
04:55:07 <osfameron> Baughn: that's disingenous!  The IO/do block is syntactic sugar *designed* to make monadic programming look like a Java/etc/block, not the other way around
04:55:21 <ski> `unsafeInterleaveIO' is not unsafe
04:55:25 <Baughn> osfameron: I don't mean the /syntax/. I mean the programming style
04:55:35 <Baughn> rwbarton: If you're going to hunt bears, any reason not to do it with a rusty knife?
04:56:09 <Baughn> rwbarton: That is to say, unsafeInterleaveIO is.. well, unsafe.. but it's a lot easier to get right than unsafePerformIO
04:56:26 <ski> Baughn : how is it unsafe ?
04:56:27 <Baughn> So if the former is fine, there's no reason to risk using the latter
04:56:53 <Baughn> ski: You don't know when or if the I/O it suggests will be done; you don't know where any exceptions it incurs will occur.
04:57:05 <Baughn> It's a rather limited sort of unsafety, but it /does/ bite newbies a lot
04:57:05 <rwbarton> Baughn: But unsafeInterleaveIO forces you to sequence all your references to the global data, no?
04:57:21 <ski> `unsafe' to me connotes breaking the declarative semantics
04:57:23 <osfameron> Baughn: ah right, cos both are sequential?
04:57:31 <rwbarton> Baughn: That seems like it could be a heavy price to pay compared to "if I used it in some other way, I could make my program crash"
04:58:06 <Baughn> osfameron: Sequential, often with mutable variables, etc. etc.
04:58:15 <__pao__> hmmm....
04:58:26 <Baughn> rwbarton: No, the /point/ of unsafeInterleaveIO is that it's done lazily - not in order
04:58:51 <roconnor> I don't get how they serialize continuations in Ocaml
04:58:57 <roconnor> that seems like it ought to be impossible.
04:58:59 <Baughn> rwbarton: The semantics are still simpler than unsafePerformIO, though
04:59:00 <rwbarton> Baughn: But you still have the 'IO' signature on all your types
04:59:34 <rwbarton> Baughn: So you have to write liftM2 (+) anywhere you'd have added the results of two computations using the data structure
04:59:49 <Baughn> rwbarton: Only temporarily. You then pass it to bind, pass the non-IO-wrapped data to a pure function, and haskell proceeds to do the IO at need
05:00:05 <__pao__> Baughn: others... loading the file lazily would me that I cannot access data randomly ...
05:00:22 <__pao__> *would not allow
05:00:25 <Baughn> __pao__: Only if you use hGetContents or some such
05:00:37 <Baughn> __pao__: If you use unsafeInterleaveIO directly, you can jump around all you like
05:01:29 <bla123> i'm curious, why i can't pattern match on function names like this: nameOfOp (+) = "+"; nameOfOp (-) = "-" ...
05:02:04 <ski> bla123 : function equality is not decidable
05:02:51 <bla123> but i wonder, why ghc just warns on overlapped matches
05:02:52 <__pao__> thanks all
05:03:07 <bla123> it is as if it decided, that (+) and (-) were equal
05:03:23 <rwbarton> bla123: No, they're just both names.
05:03:25 <bla123> (and behaves like that, the first match always succeeds)
05:03:29 <DRMacIver> Because you're introducing variables there, not creating a match.
05:03:30 <ski> yes, `(+)' there is just a new local variable
05:03:41 <bla123> aah, ok, now i get it, thx
05:07:36 <rwbarton> FWIW, the Awkward Squad paper suggests using unsafePerformIO for "performing once-per-run input/output"
05:08:15 <Peaker> if we get the entire computing environment to be one big Haskell platform, we wouldn't need such ugliness :-)
05:10:30 <__pao__> Baughn: you wrote; "Only temporarily. You then pass it to bind, pass the non-IO-wrapped data to a pure function, and haskell proceeds to do the IO at need" ... can you show me a small snippet to show what you mean?
05:11:29 <Baughn> __pao__: do foo <- unsafeInteleaveIO foo'; bar foo
05:11:30 <__pao__> Baughn: are you suggesting to live within the IO monad anyway?
05:12:08 <Abraxas691> has anyone ever heard of irc.freenode.net not working for someone?
05:12:16 <Abraxas691> i can't join it on mirc
05:12:18 <ski> s/bar foo/baz (bar foo)/
05:12:23 <Baughn> __pao__: bar can be a pure function, and the IO required by foo will only be done once bar dethunks foo once (that is to say, demands any data whatsoever about foo)
05:12:24 <__pao__> Baughn: clear... so, you are indeed suggesting to live inside the IO monad...
05:12:40 <Baughn> __pao__: No. Er, ski's right
05:12:47 <Baughn> s/bar foo/return (bar foo)/
05:12:53 <Abraxas691> i don't like this webchat very much...
05:12:56 <mauke> Abraxas691: isn't it chat.freenode.net ?
05:12:58 <Baughn> __pao__: bar :: a -> b
05:13:11 <__pao__> yep
05:13:13 <Baughn> ..where b is /not/ IO
05:13:35 <Abraxas691> webchat tells me it's irc.*
05:13:38 <Baughn> Of course the outermost layer is IO. That's always the case.
05:13:47 <Abraxas691> and the search engine i found this on, as well
05:13:55 <Abraxas691> hold on i try that
05:14:04 <mauke> http://freenode.net/irc_servers.shtml
05:14:05 <lambdabot> Title: 691 About freenode: IRC Servers
05:14:22 <__pao__> ... moreover if you like to support both constant (lazily) preloaded and explicitly unsafly customly loaded versions it seems to me you _have_ to use unsafeIO
05:14:45 <Baughn> __pao__: Point of interest: Once any part of foo is demanded, /all/ the IO is done, unless you have further calls to unsafeInterleaveIO in there
05:14:48 <Baughn> @src hGetContents
05:14:49 <lambdabot> Source not found. Just try something else.
05:15:37 <whaat> looks like irc.freenode.net works, at least with netcat
05:15:39 <Baughn> __pao__: Well, it's something like hGetContents h = do c <- hGetChar h; cs <- unsafeInterleaveIO $ hGetContents h; return c:cs
05:15:46 <Baughn> Only with more end-of-file handling
05:16:20 <Baughn> (And the first char is lazy too, nost just all the other ones)
05:17:03 <__pao__> Baughn: but that force sequential lazy loading... isn't it?
05:17:18 <__pao__> ok
05:17:23 <__pao__> I think I got it now
05:17:31 <Baughn> __pao__: Sure, /that/ does, because a list is sequential
05:17:36 <Baughn> __pao__: Nothing's forcing you to use a list
05:18:26 <whaat> hi, Abraxas
05:18:31 <Abraxas914> mauke: not working
05:18:42 <Abraxas914> hey
05:18:51 <whaat> dude, I'm using it right now
05:19:06 <ski> <mauke> http://freenode.net/irc_servers.shtml
05:19:07 <lambdabot> Title: 691 About freenode: IRC Servers
05:19:21 <Abraxas914> irc.freenode.net and port 6667, i have no clue
05:19:55 <whaat> IRCing with netcat makes me feel like a hardcore hax0r
05:20:35 <Abraxas914> hmm, different servers, why...ok, i try
05:21:33 <mauke> I'm not sure how to do a CTCP VERSION reply by hand
05:22:35 <sqweek> privmsg foo :^AVERSION bla^A
05:22:36 <therp> mauke: NOTICE <nick> \001VERSION foobarversion
05:22:37 <__pao__> Baughn: so... now I have two version of the costant data structure (a and IO a)... is there a elegant way to adapt al the functions with signature a -> b in order to work for IO a? I mean without writing too much code ;-)
05:22:40 <Abraxas980> not working
05:22:54 <Abraxas980> never had this kind of problem with any other irc
05:23:08 <__pao__> Baughn: I'd like to support both versions...
05:23:17 <Baughn> __pao__: Why would you have two versions?
05:23:34 <Baughn> __pao__: Although, yes; liftM. Or fmap. Or <$>, though probably not that last one.
05:24:16 <Baughn> __pao__: There's no reason for the /structure/ to contain IO actions; even less so with unsafeInterleaveIO involved
05:25:12 <__pao__> Baughn: why?
05:25:32 <__pao__> Baughn: my structure
05:27:13 <__pao__> ... is basically a huge map, I'd prefer not to load it lazily, sequentially...
05:27:56 * Baughn vanishes in a storm of herring
05:30:14 <__pao__> thanks everyone
05:30:56 <Abraxas123> ok, it's working on chatzilla, whatever
05:32:26 <roconnor> oh, ``OCaml already supports marshaling values including closures
05:32:28 <roconnor> wow
05:32:37 <roconnor> how do they do that?
05:32:51 <vixey> is ``OCaml like ... Haskell'  .. '
05:32:56 <vixey> ?
05:33:06 <vixey> or is that quoted text...
05:33:22 <mauke> `òcaml closureś´
05:33:36 <DRMacIver> It's not actually that hard to do. It just needs magic runtime support.
05:33:37 <gwern> roconnor: maybe the same way clean does it
05:33:40 <ski> roconnor : magic, i think
05:33:41 <schme> roconnor: http://caml.inria.fr/pub/docs/manual-ocaml/libref/Marshal.html   like so.
05:33:45 <vixey> lol
05:33:56 <gwern> (darn it, I want to be able to serialize my programs to disk!)
05:34:50 <DRMacIver> I mean, fundamentally everything is just bits and thus comes with a serialization format built in. :) (Ok, it's a little more complicated than that...)
05:34:54 <roconnor> gwern: how does clean do it?
05:35:03 <mauke> oh yeah, the stupid MD5 check
05:35:11 <mauke> makes it really hard to execute machine code from OCaml
05:35:13 * ski wants to serialize the disk
05:35:21 <roconnor> Does Data.Binary support function serialization?
05:35:27 <DRMacIver> Nope.
05:35:31 <DRMacIver> Because Data.Binary isn't magic.
05:36:01 <Baughn> I was working on closure serialization a while back, but.. I lack sufficient magic
05:36:11 <gwern> roconnor: I am not sure. something about graphs and lambda lifting in the clean runtime (and then some magic happens)
05:36:23 <DRMacIver> It needs either compiler hooks or some sort of introspection API.
05:36:33 <Baughn> (With any luck, 6.10's support for shared libraries will help)
05:36:36 <roconnor> so I cannot make a fastCGI delimited continuation based web site in Haskell.
05:37:22 <DRMacIver> No, probably not. 'though you might be able to hack something comparable together with manual defunctionalisation.
05:37:48 <DRMacIver> Probably too much of a burden on the users of the library though
05:38:32 <ski> roconnor : mayhaps with an `Arrow'-like interface, you can ..
05:38:37 <roconnor> defunctionalisation sounds familiar, was there a blog post about that recently?
05:38:50 <DRMacIver> Not sure. There might have been.
05:39:20 <mauke> http://blog.plover.com/prog/defunctionalization.html
05:39:21 <lambdabot> Title: The Universe of Discourse : Defunctionalization and Java
05:39:38 <DRMacIver> Essentially (ok, there are other ways to do it, but this is the only one I remember offhand. :) ) you take all the functions you want to use and replace them with a single algebraic data type and pattern matching on that data type.
05:40:17 <DRMacIver> But at the very least, doing it this way will prevent your library from being nicely monadic, so it's probably doomed.
05:40:30 <bringert> @seen dcoutts
05:40:31 <lambdabot> dcoutts is in #gentoo-haskell, #haskell, #ghc, #haskell-overflow and #haskell-soc. I last heard dcoutts speak 1d 4h 2m 57s ago.
06:07:41 <jpcooper> say I have
06:07:42 <jpcooper> data (Num a) => Vector a
06:07:42 <jpcooper>     = Vector a a a
06:07:51 <jpcooper> how would I define Vector as an instance of Functor?
06:08:09 <vixey> instance Functor Vector where
06:08:12 <vixey>  fmap = ...
06:08:12 <kpreid> instance Functor Vector where fmap (Vector x y z) = Vector ...
06:08:26 <vixey> :t fmap
06:08:28 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:08:39 <vixey> fmap :: (a -> b) -> Vector a -> Vector b
06:08:48 <kpreid> DRMacIver: I'd say that the way in which it's not just that everything is just bits, is that the particular bits are relative to the rest of the system -- involved in invariants. So there must be translation between these bits and those bits.
06:09:06 <vixey> (this annotation is not meant to be written down in code but a suggestion for how to write the function)
06:09:16 <hackage> Uploaded to hackage: haskell-src-exts 0.3.5
06:09:28 <jpcooper> vixey, yes, I'm getting errors
06:09:34 <jpcooper> could you tell me how you'd do it?
06:09:42 <vixey> why don't you hpaste your code
06:09:56 <Saizan> jpcooper: the only way is to remove the (Num a) => bit
06:10:04 <jpcooper> bugger
06:10:45 <kpreid> jpcooper: type restrictions in data aren't all that useful, actually
06:10:52 <Abraxas123> if i have a curried function and i partially apply it, the definition of the partial application has to contain the remaining parameters as constants, right?
06:11:07 <schme_> Is real world haskell working for anyone of you?
06:11:19 <Abraxas123> i refer to this: http://www.haskell.org/haskellwiki/Partial_application
06:11:20 <lambdabot> Title: Partial application - HaskellWiki
06:11:22 <jpcooper> kpreid, as in declaring the instance of the parameters from which the type is made from?
06:11:25 * schme_ cannot connect.
06:11:36 <kpreid> jpcooper: yes
06:11:51 <jpcooper> okay, thanks
06:11:55 <Beelsebob> Abraxas123: sorry, why would the remaining ones be constant?
06:12:01 <jpcooper> so it should be
06:12:02 <jpcooper> data Vector a
06:12:02 <jpcooper>     = Vector a a a
06:12:43 <Abraxas123> how would i get variables in there if the pattern does not contain any?
06:13:18 <Beelsebob> Abraxas123: you can apply a partial application in the same way as you apply any other function
06:13:25 <Beelsebob> > (+ 1) 2
06:13:27 <lambdabot>  3
06:14:11 <Abraxas123> i mean, like this: addOne = add 1
06:14:20 <Beelsebob> yep
06:14:27 <Beelsebob> so you can call addOne with another argument
06:14:28 <Abraxas123> it defeats the pupose if addOne comes with parameters?
06:14:37 <Beelsebob> > let add1 = (+1) in add1 5
06:14:38 <lambdabot>  6
06:14:43 <kpreid> Abraxas123: no
06:14:48 <Abraxas123> but the right side of the definition can't have any, either
06:14:58 <kpreid> Abraxas123: for example, addByTen n = add (n * 10)
06:15:48 <kpreid> Abraxas123: also even in the parameter-less-definition case, consider that you could write that definition in a let or where, where it could depend on something outside
06:15:56 <Beelsebob> which can of course actually be expressed in point free style if you want to... addByTen = add . (*10)
06:16:13 <kpreid> partial application is just the expression .. whether it's in a definition is irrelevant
06:16:21 <kpreid> > map (* 10) [1,2,3]
06:16:22 <lambdabot>  [10,20,30]
06:16:26 <Abraxas123> mmh, alright
06:16:31 <vixey> :t add
06:16:32 <lambdabot> Not in scope: `add'
06:16:44 <kpreid> partially applying (*). well, actually, that's a section, never mind :)
06:16:45 <Beelsebob> map ((+) . (*10)) [1,2,3]
06:16:50 <Beelsebob> > map ((+) . (*10)) [1,2,3]
06:16:51 <lambdabot>  [<Integer -> Integer>,<Integer -> Integer>,<Integer -> Integer>]
06:17:20 <chrisdone> :t map ((+) . (*10)) [1,2,3]
06:17:21 <lambdabot> forall a. (Num a) => [a -> a]
06:17:41 <chrisdone> :t (+) . (*10)
06:17:43 <lambdabot> forall a. (Num a) => a -> a -> a
06:18:08 <vixey> > (sum . ((* 10) .)) [1,2,3]
06:18:09 <lambdabot>  60
06:18:16 <Beelsebob> chrisdone: (+) takes two arguments -- it only supplies one (n*10)
06:19:58 <Abraxas123> is it possible to use curried functions in order to solve 1+x=2 ?
06:20:08 <vixey> yes
06:20:20 <Peaker> @unpl (sum . ((* 10) .)) [1,2,3]
06:20:20 <lambdabot> (sum (\ h -> ([1, 2, 3] h) * 10))
06:20:29 <Abraxas123> that would sort of resemble prolog
06:20:47 <chrisdone> beelsebob: I know, just elabourating
06:20:53 <Saizan> yes?
06:20:56 <vixey> > [ x | x <- [0..50] , 1 + x == 2 ]
06:20:58 <lambdabot>  [1]
06:21:11 <vixey> > [ x | x <- [0..50] , x * x == 9 ]
06:21:12 <lambdabot>  [3]
06:21:19 <Peaker> sum wants a list, not a function, so how come sum can take that function above?
06:21:20 <Abraxas123> uhm , not really
06:21:41 <DRMacIver> I think that's an instance of Caleskell.
06:21:44 <DRMacIver> :t (.)
06:21:45 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:21:59 <Abraxas123> i guess the answer is no, then
06:23:01 <ski> @unpl sum id
06:23:02 <lambdabot> sum (\ a -> a)
06:23:08 <ski> afaik `pl' is not typed
06:23:32 <vixey> @unpl const
06:23:33 <lambdabot> (\ a _ -> a)
06:23:37 <vixey> @unpl const id
06:23:38 <lambdabot> (\ _ b -> b)
06:24:19 <vixey> @unpl e `on` f `on` g `on` h
06:24:20 <lambdabot> (on (on (on e f) g) h)
06:24:26 <vixey> :(
06:24:44 <ski> @unpl () id
06:24:44 <lambdabot> () (\ a -> a)
06:24:49 <Peaker> This seems broken:
06:24:49 <Peaker> @unpl (sum . ((* 10) .)) [1,2,3]
06:24:49 <lambdabot> (sum (\ h -> ([1, 2, 3] h) * 10))
06:24:55 <Peaker> The first works, the latter doesn't
06:25:00 <vixey> @pl () id () id () id ()
06:25:01 <lambdabot> (line 1, column 3):
06:25:01 <lambdabot> unexpected " "
06:25:01 <lambdabot> expecting variable, "(", operator or end of input
06:25:16 <vixey> @unpl () id () id () id ()
06:25:17 <lambdabot> () (\ a -> a) () (\ b -> b) () (\ c -> c) ()
06:25:19 <Saizan> Peaker: it's broken because the second (.) is fmap and @pl doesn't know it :)
06:25:31 <Peaker> Saizan: oh :)
06:25:42 <vixey> @unpl (\x -> (x,x,x,x,x,x,x,x)) (() id () id () id ())
06:25:43 <lambdabot> (\ x -> (x, x, x, x, x, x, x, x)) (() (\ a -> a) () (\ b -> b) () (\ c -> c) ())
06:25:44 <ski> @type (sum P.. ((* 10) P..)) [1,2,3]
06:25:45 <lambdabot>     Couldn't match expected type `[a]' against inferred type `a1 -> b'
06:25:45 <lambdabot>     Probable cause: `P..' is applied to too few arguments
06:25:45 <lambdabot>     In the second argument of `(P..)', namely `((* 10) P..)'
06:25:54 <Peaker> Saizan: Why was (.) generalized instead of using <$> or `fmap` ?
06:26:14 <ski> Peaker : ask Cale :)
06:26:25 <Saizan> (.) is nicer to type :)
06:26:34 <vixey> > Just "foo" ++ Just "bar"
06:26:36 <lambdabot>  Just "foobar"
06:26:41 <chrisdone> hehehe
06:26:47 <vixey> > Just . [1,2,3]
06:26:49 <chrisdone> :t (++)
06:26:49 <lambdabot>  [Just 1,Just 2,Just 3]
06:26:50 <lambdabot> forall m. (Monoid m) => m -> m -> m
06:28:09 <chrisdone> in order to do that in standard haskell I'd just import Prelude hiding (++) and then redefine (++)?
06:28:23 <Saizan> yes
06:28:24 <Baughn> Yep, though you'd confuse anyone reading it
06:28:29 <chrisdone> aw
06:28:42 <Baughn> ..kinda wish that would make its way into haskell', though
06:29:00 <chrisdone> :t mplus
06:29:02 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
06:29:06 <vixey> Baughn: Hardly
06:29:11 <vixey> mappend
06:29:23 <Peaker> I don't see why code often uses map instead of fmap, though.  Why expose the map function at all?
06:29:27 <chrisdone> yes, I know (++) = mappend
06:29:28 <vixey> If anyone gets confused by redefinition of two operators, they won't have a chance of understanding an entire program
06:29:33 <Abraxas123> if i have sth like between x y z, which is true if y is between  x and z...i can define right_of x y = between x y...but can i also define left_of?
06:29:43 <chrisdone> @src (+)
06:29:44 <lambdabot> Source not found. You speak an infinite deal of nothing
06:30:08 <chrisdone> would it be silly to define (+) = mplus and mplus instances for Num?
06:30:33 <vixey> is Num a Monoid?
06:30:40 <Abraxas123> i guess i can't, because the function is "right-sided"
06:30:48 <chrisdone> dunno
06:31:32 <vixey> Num can be several Monoids
06:31:38 <vixey> that's why it's not one
06:31:54 <kig> @src negate
06:31:54 <lambdabot> negate x = 0 - x
06:32:00 <kig> @src (-)
06:32:00 <lambdabot> x - y = x + negate y
06:32:21 <Peaker> I think maybe we should be using type-classes instead of types directly whenever we can - to make code more general.. Try to not even expose the direct functions, and only expose the instances, perhaps
06:32:51 <vixey> Why is making things more general a good idea?
06:32:55 <Abraxas123> i would have to reverse the between to do that, right?
06:33:18 <Peaker> vixey: because then they can be used for new purposes
06:33:31 <vixey> Abraxas123: What is the definition of between?
06:33:34 <Peaker> vixey: for the same reason type-classes are useful in general?
06:34:01 <Peaker> I guess, fmap blah [1,2,3] is just as specific as map, but even for the sake of exposing just fmap and not both fmap/map it could be nice
06:34:24 <jpcooper> unit :: (Floating a) => Vector a -> Vector a
06:34:24 <jpcooper> unit v = scalard (magnitude v) v
06:34:28 <jpcooper> is there a nicer definition for this?
06:34:29 <Abraxas123> between x y z | (x <= y) && (y <= z) 	= True  | otherwise = False
06:35:07 <vixey> Abraxas123: oh you know you don't have to use the guards
06:35:16 <vixey> between x y z = (x <= y) && (y <= z) -- just this is enough
06:35:19 <Abraxas123> i don't
06:35:35 <vixey> between x y z = x <= y && y <= z -- also, <= binds tighter than &&
06:35:53 <Abraxas123> but i can't read that :p
06:36:00 <vixey> why not?
06:36:09 <vixey> does it look like
06:36:13 <Abraxas123> doing haskell for less than a week
06:36:16 <vixey> between x y z = x <= (y && y) <= z
06:36:20 <vixey> to you?
06:36:34 <Abraxas123> not really, ok
06:36:46 <Abraxas123> it was given in class that way, though
06:37:07 <Abraxas123> because it's for newbies, well
06:38:01 <vixey> Anyway I don't understand what left or right of mean
06:38:02 <Abraxas123> but of course the otherwise is nonsense
06:38:25 <vixey> I don't know why less and greater aren't used
06:38:34 <Abraxas123> right_of x y = between x y		
06:38:49 <chrisdone> @hoogle a -> (a -> a -> b) -> b
06:38:51 <lambdabot> Prelude.flip :: (a -> b -> c) -> b -> a -> c
06:38:51 <lambdabot> Data.Function.flip :: (a -> b -> c) -> b -> a -> c
06:38:51 <lambdabot> Data.Function.on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
06:39:00 <Abraxas123> i was wondeirng if there is a way to flip it to get a left_of
06:39:00 <vixey> you know this is equivalent to,
06:39:06 <vixey> right_of x y z = between x y z
06:39:10 <vixey> :t flip join
06:39:12 <lambdabot> forall a b. b -> (b -> b -> a) -> a
06:39:27 <vixey> left_of x y z = between z y x -- or whatever
06:39:44 <vixey> You know about currying ?
06:39:58 <Abraxas123> i do now
06:40:02 <chrisdone> ahhh shit
06:40:07 <chrisdone> I keep forgetting about join
06:40:22 <vixey> this is the -> instance of join
06:40:44 <Abraxas123> right_of isn't really curried?
06:40:54 <vixey> everything is curried!
06:40:57 <Abraxas123> i mean, i did it wrong?
06:41:01 <Abraxas123> makes no sense
06:41:03 <Abraxas123> ?
06:41:15 <vixey> that's why types are a -> b -> c -> d -> z instead of (a,b,c,d) -> z
06:41:17 <rwbarton> Peaker: the disadvantage of having very general types is it makes it less likely that the compiler will catch your mistakes.  For example,
06:41:21 <rwbarton> > length . words "foo bar baz" -- how many words?
06:41:23 <lambdabot>  [3,3,3]
06:41:25 <Abraxas123> yes, everything is curried...i mean, i didn't make good use of it
06:42:36 <vixey> rwbarton: not really
06:42:49 <Abraxas123> and the left_of was that simple, yes :p
06:42:53 <vixey> rwbarton: as soon as you see the result you know it's wrong because you got a list instead of a single number
06:43:00 <rwbarton> Well, probably in this case I'll get a type error when I try to use the result.  But the quality of the error message will suffer
06:43:03 <Abraxas123> trying to get as much as i can into my brain in little time, sorry
06:43:07 <Peaker> rwbarton: I see.. I think maybe when using lists as a monad, we ought to have used some newtype around list? Perhaps a differing list literal (we have syntax for using the list monad anyhow)
06:43:15 <vixey> rwbarton: as soon as you write code that uses that code, you know it's wrong because the typechecker sees a list instead of a single number
06:43:16 <Abraxas123> i might miss the obvious...a lot
06:43:33 <Peaker> rwbarton: If you map useful operations to every conceivable operation on any conceivable type that's a problem I agree :)
06:43:37 <vixey> you get the same error message ni this case
06:43:52 <rwbarton> > 1 + (length . words "foo bar baz") -- how many words?
06:43:54 <lambdabot>   add an instance declaration for (Num [Int])
06:43:59 <rwbarton> > 1 + (length P.. words "foo bar baz") -- how many words?
06:44:00 <lambdabot>  Couldn't match expected type `a -> [a1]'
06:44:05 <Peaker> rwbarton: When using a function or a list as a monad, perhaps it would make sense to be explicit about it, for example
06:44:34 <ski> (s/monad/monad action/)
06:45:00 <Peaker> rwbarton: Using fmap for function composition is confusing indeed. I'd keep a separate composition operator. But fmap/map seem less-so. Maybe its arbitrary
06:45:24 <vixey> Peaker: What about it is confusing you?
06:45:28 <Abraxas123> anyway, right_of only is in style if i have it like this: right_of = between 1 2...it's what i was getting at earlier, that variables in the new function defeat the purpose if i use them just like i would in the old function
06:45:41 <rwbarton> Peaker: I completely agree (assuming you mean using (.) for fmap)
06:45:48 * ski str 1.4 had `class Functor f where map :: (a -> b) -> (f a -> f b)'
06:45:50 <vixey> Abraxas123: no not at all
06:45:55 <Peaker> vixey: it seems to be more abstract than called for
06:46:04 <vixey> Abraxas123: Giving names to things is important
06:46:06 <Peaker> vixey: Maybe I'm just not used to it though
06:46:41 <rwbarton> Oh I think I see what you meant
06:48:19 <Abraxas123> all is well, then :)
06:48:35 <Peaker> rwbarton: I think fmap instead of map on lists is not overly-abstract/confusing and it actually generalizes the code for any container, not just lists.  However, fmap instead of (.) generalizes the code in a way that is less meaningful. How often would code that does function composition be useful with a more-generic fmap instead?
06:49:32 <vixey> Peaker: If . is used in a function as composition, generalizing to fmap will never change it since it's been instantiated as ->
06:50:08 <ski> @type \a b c -> a . b . c
06:50:09 <lambdabot> forall a b a1 (f :: * -> *). (Functor f) => (a -> b) -> (a1 -> a) -> f a1 -> f b
06:50:47 <ski> (the last `.' is the one that's generalized, there)
06:50:48 <Peaker> vixey: I know - I'm not saying it will change - I am just saying that there's a tradeoff in using methods instead of functions.  If you un-expose functions that you already have as methods, you simplify things. However, that means that type errors are more likely to accidentally find applicable methods
06:51:35 <Peaker> vixey: and that this tradeoff is not the same for different functions. In some functions there is more usefulness in the generic-version of the functions, and some generalizations will make masking type errors more likely than others
06:52:00 <plutonas> schme_: ?
06:54:48 <Abraxas123> vixey: just one more thing...what you said about right_of x y z being equal to right_of x y...i see that now because i just tried, so this is a special case in which adding it in the definition is optional?
06:55:50 <rwbarton> Peaker: Yes.  I think you should choose the types of functions you write to be as general as possible, but implement using the most specific of fmap, map, P.. that you can
06:55:54 <Abraxas123> but i guess adding it is better, because it might confuse someone reading the code and not catching the partial application
06:56:01 <vixey> Abraxas123,
06:56:16 <vixey> say, f = (+)
06:56:23 <vixey> f x = (x +)
06:56:26 <vixey> f x y = x + y
06:56:29 <vixey> are all the same
06:56:51 <vixey> also things like,  rail = f . g . h . i
06:56:59 <vixey> is the same as, rail x = f . g . h . i $ x
06:57:02 <Peaker> rwbarton: Should you take a list and use map, or a Functor and use fmap?
06:57:18 <vixey> but it could be.. sometimes might not be the same as, rail x y = (f . g . h . i $ x) $ y
06:57:28 <vixey> in that case it depends on if rail x is a functiona
06:57:43 <rwbarton> Peaker: If you can write a function to take a Functor, maybe you should.  But a lot of time you're building lists inside a complicated function, and then it makes no sense to use fmap when map is available
06:58:11 <Abraxas123> you know we didn't talk about that dot operator at all, hehe
06:58:19 <vixey> Abraxas123,
06:58:23 <vixey> (f . g) x = f (g x)
06:58:30 <vixey> it's called composition
06:58:35 <lumi> Hi, I'm having some trouble building Cabal. While compiling it goes "Illegal instruction" and dies
06:58:41 <vixey> > head . reverse $ [1,2,3]
06:58:42 <lambdabot>  3
06:58:45 <vixey> > reverse $ [1,2,3]
06:58:47 <lambdabot>  [3,2,1]
06:58:49 <vixey> > [1,2,3]
06:58:51 <lambdabot>  [1,2,3]
06:59:58 <Abraxas123> alright, i think i prefer writing f x y in code, just to not confuse someone, especially myself, lol
07:00:24 <vixey> you prefer f x y to what?
07:00:40 <Abraxas123> to f=(+)
07:00:52 <Beelsebob> Abraxas123: it can be clearer sometimes -- for example, mapOverWords f = unwords . map f . words is a lot clearer than mapOverWords f x = unwords (map f (words x))
07:00:57 <Abraxas123> i might not catch it's partial application
07:00:59 <vixey> oh there are times you will want one, times you want the other
07:01:15 <vixey> but it's most important to know that they mean similar things
07:01:35 <Abraxas123> yes, i see it is something you get used to
07:01:41 <Peaker> Abraxas123: Using composition and other "tricks" to avoid creating lots of lambda's is called "pointless" style (where point represents a "value"). Pointless is indeed considered obfuscation, however simple PL things like composition are easy to learn how to read
07:01:51 <vixey> It's called point free
07:01:53 <chrisdone> > let foo = id; bar = const; in join (foo . bar) 1 == (uncurry foo . (bar &&& id)) 1
07:01:55 <lambdabot>  True
07:02:01 <Peaker> points-free, sorry :)
07:02:01 <vixey> composition is not a trick
07:02:08 <Peaker> I put "trick" in quotes :)
07:02:11 <vixey> Peaker: actually it's also called pointless
07:02:14 <Peaker> vixey: to a newcomer it may seem like one :)
07:02:44 <Abraxas123> btw, in case you are wondering what my background is...it's a lecture about concepts of descriptive programming with haskell and prolog being the practical part
07:02:49 <Beelsebob> Peaker: point free style is not necessarily obfuscation
07:02:55 <Beelsebob> it is in a lot of cases
07:03:26 <Abraxas123> i have a lot of theory and some basics in haskell and prolog
07:03:38 <pejo> (They teach function composition in math to freshmen)
07:03:44 <vixey> usually pointfree style is helpful for program transformations and thinking about correctness proofs
07:03:45 <Abraxas123> hardly more than a crash course :p
07:03:46 <vixey> to me .. at least
07:03:56 <Peaker> Abraxas123: the cute thing is that you can convert things to PL style automatically, with @pl :-)  For example:
07:04:00 <Peaker> @pl \f -> 5+3*f
07:04:00 <lambdabot> (5 +) . (3 *)
07:04:28 <Peaker> Abraxas123: (multiply by 3, then add 5  to input)
07:05:20 <Abraxas123> ah thx, i don't even recognize the pl style
07:07:27 <Peaker> Abraxas123: . is somewhat reminding of unix pipes
07:07:36 <Baughn> Abraxas123: Mind you, sometimes the result is troublesome
07:07:44 <ski> Abraxas123 : "descriptive programming" ? .. are you sure you don't mean "declarative programming" ?
07:08:05 <Baughn> @pl fib n = let fibs = 0:1:zipWith (+) fibs (tail fibs) in fibs !! n
07:08:05 <lambdabot> fib = (fix ((0 :) . (1 :) . ap (zipWith (+)) tail) !!)
07:08:54 <Abraxas123> ski: i figured it does not exist in english ;)
07:09:02 <Abraxas123> yes, that's the one
07:09:05 <Baughn> Abraxas123: Literal programming?
07:09:17 <Baughn> *Literate
07:09:58 <Abraxas123> yeah, that's the implication, isn't it
07:11:14 <Abraxas123> but literally translated "declarative" was right
07:11:30 <Abraxas123> \me had to look up literal programming
07:11:44 <ski> literate
07:11:52 <Abraxas123> lol
07:11:53 <Abraxas123> yes
07:12:04 <vixey> :t (\o -> o)
07:12:05 <lambdabot> forall t. t -> t
07:12:11 <Peaker> Baughn: one of the best examples of extreme obfuscation :)
07:12:45 <Abraxas123> hehe
07:13:01 <Abraxas123> searched for the right term, though
07:13:06 <vixey> :t \x y z w -> (\($) -> x$y$z$w)
07:13:07 <lambdabot> forall t t1. t1 -> t -> t -> t -> (t1 -> t -> t1) -> t1
07:17:15 <chrisdone> any λb admins? I'd like it to @join a channel if that's okay
07:19:34 <Abraxas123> i'm just reading, "every expression got exactly one specific type which can be determined prior to running time"...that's not true, is it? for example, the result of last depends on the parameter?
07:20:02 <bremner> [repeating myself] can anyone help with a type error with fgl  <http://pastebin.ca/1070604> fgl seems a bit broken with ghc 6.8.2
07:20:14 <Baughn> Abraxas123: No, it's true
07:20:31 <rwbarton> Abraxas123: The type of the result of last does depend on the type of the parameter, but the type of that parameter can also be determined prior to running time
07:21:06 <Baughn> Abraxas123: Every /particular/ expression. Different expressions involving last can have different types; the expression consisting only of "last" is incomplete and won't execute on its own (partially because the type is incomplete)
07:22:37 <Abraxas123> that means the type is [a]->a and that is specific enough in context?
07:23:48 <Peaker> The type [a]->a seems dangerous :)
07:24:08 <vixey> yeah it's a partial functino
07:24:19 <kpreid> the type of last is [a] -> a. the type of "a" is [Char]. if you apply last to "a", (last "a"), then the [a] is unified with [Char], binding a to Char, thus the type of (last "a") is Char
07:24:22 <vixey> they are odd
07:25:55 <Baughn> Abraxas123: [a] -> a is /not/ specific enough. The context may make it specific, but only by supplying a type for a
07:25:58 <cnwdup> http://haskell.pastebin.com/d4a4c3639 Why is ghc giving me this error in line 8? sigQueue is of type Queue Signal. Queue is like a MVar. (And don't mind line 9. ^-^)
07:26:51 <Baughn> Abraxas123: The typechecker works as a logic programming language.. if you're not familiar with prolog, or that paradigm, just imagine that it tries all options; it's somewhat smarter in practice.
07:27:46 <Saizan> cnwdup: you've to define that in an instance SignalClass Signal where .. it seems
07:28:37 <Abraxas123> hm, i didn't see how this could work with polymorphism
07:28:46 <cnwdup> saizan: Ah, thanks.
07:28:53 <vixey> What can't work?
07:29:08 <Abraxas123> that the type is determined prior to runtime
07:29:26 <vixey> It can figure it out
07:29:31 <kpreid> depends on the sort of polymorphism you're thinking of
07:29:32 <vixey> simple example, f = True
07:29:42 <vixey> it's easy to figure out that f is Bool right?
07:29:53 <vixey> :t (&&)
07:29:54 <lambdabot> Bool -> Bool -> Bool
07:29:59 <vixey> say && has that type,
07:30:04 <vixey> g x = True && x
07:30:25 <Peaker> Abraxas123: the type-checker sometimes uses "type variables" at compile-time that are not known. At least I think it does with existential types. Not sure about other cases
07:30:31 <vixey> from the use of && here it's clear that x has type bool, and looking at g it's a function from typeOf x -> typeOf (True && x)
07:30:35 <vixey> so g :: Bool -> Bool
07:30:56 <vixey> that's the sort of reasoning a haskell compiler will do over all your code
07:32:45 <Abraxas123> but if a function uses lists of some undetermined type and the result is based on the parameter...sth like that?
07:33:07 <Baughn> Abraxas123: Well, the list type will be determined based on what you pass to it
07:33:08 <vixey> Do you have an example
07:33:21 <Abraxas123> no, i don't have one
07:33:25 <Peaker> Abraxas123: the result TYPE cannot be based on a parameter (except in the case of existential types, but then it will be the same type in terms of type-variables)
07:33:29 <vixey> what is it you are confused about then?
07:33:53 <Peaker> Abraxas123: case and if expressions have to result in the same type in all cases
07:33:54 <Abraxas123> baughn: but passing is not pre runtime
07:34:17 <vixey> :t last :: [Bool] -> Bool
07:34:18 <lambdabot> [Bool] -> Bool
07:34:22 <Baughn> Abraxas123: Not the value itself, the /type/ of the value you pass to it
07:34:23 <vixey> :t last :: [Integer] -> Integer
07:34:25 <lambdabot> [Integer] -> Integer
07:34:29 <vixey> :t last :: [[()]] -> [()]
07:34:30 <lambdabot> [[()]] -> [()]
07:34:33 <Baughn> Abraxas123: And that type can be determined at compile time, so..
07:34:37 <vixey> does this help?
07:35:01 <Baughn> Abraxas123: For example, 'last "foo"' <- The compiler knows at compile-time that you'll be passing a [Char] to last, even if it isn't actually passed before runtime
07:35:33 <kpreid> Abraxas123: one way to look at it is that *types* are exactly that information which *is* available at compile time
07:36:38 <Abraxas123> ok, actually the statement was more like "type can be determined immediately after writing the program" which sounded like it's even prior to compile time
07:37:08 <Baughn> Abraxas123: The compiler is what determines the type, but the statement is technically correct
07:37:10 <vixey> it happens in the compiler, it's part of compiling
07:37:19 <Baughn> After all, you could determine the type by hand as well
07:37:22 <vixey> You can do it yourself without a compiler
07:38:23 <Abraxas123> thanks, it was a misunderstanding, i guess
07:39:29 <thetallguy> Abraxas123: it is also important to note that it is completely done during compilation (unless you explicitly use dynamic types) so that you are guaranteed no run-time type errors.
07:39:53 <cnwdup> saizan: http://haskell.pastebin.com/d4cfb0cc3 Still no luck. Do you have any clue?
07:41:15 <Abraxas123> oh vixey, i was wrong, just found the part about the dot operator
07:41:26 <vixey> oh what about it ?
07:41:47 <vixey> (.) :: (z <- m) -> (m <- a) -> (z <- a)
07:42:01 <vixey> I wish you could actually write that ...
07:42:12 <Abraxas123> we discussed it, i forgot, lecture is just 3rd priority actually :p
07:42:20 <vixey> oh ok
07:42:25 <rwbarton> cnwdup: maybe move line 5 to after line 7?
07:42:28 <thetallguy> vixey: that sig makes my eyes cross ;-)
07:42:31 <Saizan> cnwdup: i meant something like this http://haskell.pastebin.com/m3eb71786
07:42:48 <vixey> thetallguy, z from m, to, m from a, to, z from a
07:42:57 <Abraxas123> but i wish it was first priority, because i'm interested in this the most right now, i must say
07:43:15 <cnwdup> saizan: That's working. Thank you. (-:
07:43:33 <thetallguy> vixey:  yeah, I understand completely why you did it, it's just that lexically, it's new and visually challenging
07:43:42 <Abraxas123> prolog more than haskell, though, don't kick me...
07:43:42 * vixey nods
07:43:54 <thetallguy> vixey: on the other hand...
07:43:59 <thetallguy> @type (.)
07:44:01 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:44:14 <vixey> yeah I wouldn't flip around the arrows in there
07:44:27 <thetallguy> That's not the traditional sig.
07:49:29 <ddmnshs> \join #lisp
07:52:37 <vixey> pisl# nioj/
07:55:13 <chrisdone> flip $ (join `lisp`)
08:04:46 <Abraxas123> if i have this:
08:04:48 <Abraxas123> square n = n^n
08:04:49 <Abraxas123> cube n = n * (square n)
08:04:51 <Abraxas123> power 1 = id
08:04:52 <Abraxas123> power 2 = square
08:04:54 <Abraxas123> power 3 = cube
08:04:55 <Abraxas123> power 4 = square.square
08:05:04 <Peaker> Abraxas123: use hpaste for large pastes
08:05:12 <Peaker> Abraxas123: n^n is not "square"
08:05:16 <Abraxas123> sorry
08:05:26 <Abraxas123> lol, right
08:05:52 <Abraxas123> hugs says: power :: (Num a, Integral b) => a -> b -> b
08:06:15 <Abraxas123> how does it get the tuple
08:06:29 <Igloo> It's not a tuple, it's a set of constraints
08:06:45 <Igloo> power :: a -> b -> b, for any types a and b where Num a and Integral b hold
08:07:51 <carl> how do you use randoms to generate a list i can do "a <- (getStdRandom $ random)
08:08:11 <carl> to generate a single random number
08:08:12 <BONUS> just use randoms
08:08:20 <BONUS> wait
08:08:22 <BONUS> what
08:08:37 <BONUS> you want a list of random numbers, right?
08:08:47 <carl> yes
08:08:50 <Abraxas123> i don't get why hugs does not infer integer for a
08:08:52 <BONUS> > take 10 (randoms (mkStdGen 10))
08:08:54 <lambdabot>  [-1258130923,-870666468,433432625,-1228884604,793723731,1488653119,609706456...
08:09:03 <carl> thx
08:09:07 <BONUS> np
08:10:14 <carl> what interpreter is the lambdabot is it hugs or ghci?
08:10:31 <chrisdone> ghci
08:10:52 <rwbarton> That's a pure computation, and will always return the same value.  If you want to get a list of 10 new random numbers in the IO monad, use...
08:10:55 <rwbarton> :t replicateM
08:10:57 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
08:12:55 <Peaker> @hoogle replicateM_
08:12:55 <lambdabot> Control.Monad.replicateM_ :: Monad m => Int -> m a -> m ()
08:13:24 <Baughn> carl: LB is using ghc, but /not/ an interpreter; it's compiled
08:13:39 <Baughn> > replicateM 2 [1..3]
08:13:40 <lambdabot>  [[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]
08:13:56 <Peaker> Baughn: cute :)
08:14:52 <carl> lol
08:16:28 <chrisdone> :t arr
08:16:28 <lambdabot> Not in scope: `arr'
08:16:30 <chrisdone> ????
08:16:37 <chrisdone> :t A.arr
08:16:38 <lambdabot> Couldn't find qualified module.
08:16:44 <chrisdone> :t Control.Arrow.arr
08:16:45 <lambdabot> forall b c (a :: * -> * -> *). (Control.Arrow.Arrow a) => (b -> c) -> a b c
08:16:50 <chrisdone> oh. great
08:17:36 <chrisdone> how do I show the type of (***) in lambdabot?
08:17:54 <ski> @type (Control.Arrow.***)
08:17:54 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Control.Arrow.Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
08:18:00 <chrisdone> ah, thanks
08:21:17 <ski> @type 1
08:21:18 <lambdabot> forall t. (Num t) => t
08:21:24 <ski> Abraxas123 : ^
08:21:41 <Baughn> @src 1
08:21:41 <lambdabot> Source not found. stty: unknown mode: doofus
08:22:02 <Baughn> ^- should be fromInteger 1. Oh well.
08:23:44 <Abraxas123> ski: are you trying to tell me about the typo in squares? i know, thanks
08:29:38 <ski> Abraxas123 : no, i'm trying to tell you why the first parameter of `power' are inferred to be in `Num'
08:30:35 <Abraxas123> i changed the typo, still says Num
08:31:45 <Abraxas123> but 'Num b' now instead of 'Integral b'
08:32:11 <ski> sure
08:32:26 <Abraxas123> which i don't get at all, but no time to dwell on it
08:32:58 <ski> @type (^)
08:32:58 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
08:32:59 <ski> @type (*)
08:33:00 <lambdabot> forall a. (Num a) => a -> a -> a
08:33:19 <ski> @type let foo 0 = () in foo
08:33:20 <lambdabot> forall t. (Num t) => t -> ()
08:33:49 <ski> matching on integral literals will give you a type in `Num'
08:34:31 <Abraxas123> see, i thought it would be Integral
08:34:31 <ski> `(*)' and `(^ 2)' both accept and give values of a type in `Num'
08:35:11 <ski> your definition works just as well for, e.g., `Double'
08:35:11 <Abraxas123> because i have power 1, power 2, ... i thought hugs infers Integral
08:35:38 <ski> > let power 1 = id in power 12.5
08:35:39 <lambdabot>  Add a type signature
08:35:57 <ski> > let power 1 = id in power 1 12.5   -- er :)
08:35:58 <lambdabot>  12.5
08:36:28 <ski> > let power 1 = id; power 2 = (^ 2) in power 2 2.5
08:36:28 <lambdabot>  6.25
08:37:21 <Baughn> @let power 1 = id; power n = n+1
08:37:21 <lambdabot> Defined.
08:37:50 <Baughn> ..that shouldn't have compiled, I think
08:37:54 <Baughn> > power 1 42
08:37:55 <lambdabot>   add an instance declaration for (Num (a -> a))
08:38:48 * ski grins
08:39:21 <Baughn> > 1+1
08:39:22 <lambdabot>  2
08:39:23 <Abraxas123> funny, if i just type power, hugs says: ERROR - Cannot find "show" function for:   *** Expression : power   *** Of type    : Integer -> Integer -> Integer
08:39:41 <Baughn> > power
08:39:42 <lambdabot>   add an instance declaration for (Num (a -> a))
08:39:45 <Abraxas123> i thought it would say the same as with :info power
08:39:50 <ski> Abraxas123 : that's defaulting for you
08:40:25 <mattam> @type (+)
08:40:25 <lambdabot> forall a. (Num a) => a -> a -> a
08:40:34 <Abraxas123> i see, same happens with sum
08:40:58 <mattam> @type 1
08:40:59 <lambdabot> forall t. (Num t) => t
08:41:33 <Abraxas123> sum --> [Integer] -> Integer    :info sum --> sum :: Num a => [a] -> a
08:41:53 <Baughn> > sum
08:41:54 <lambdabot>  <[Integer] -> Integer>
08:42:45 <Baughn> It makes sense, I suppose. It has to complete type-checking before it can get passed to show, as a standard haskell expression
08:44:26 <Abraxas123> ah ok, i should not worry too much about the interpreter doing things
08:44:47 <Abraxas123> it's different from the theory
08:47:53 <gwern> Abraxas123: no. you're asking it to evaluate a function and then find a textual view of it; the second can't be done
08:47:56 <gwern> or it could be done, maybe, but it would be incomplete and buggy and morally wrong
08:49:09 <Peaker> I think Show is used for 2 purposes, instead of 1 -- along with read - as an actual reversible serialization format, and for UI/debug outputs.  I think these 2 purposes ought to be separated. Functions should have a DebugShow instance
08:49:30 <Peaker> (though not a show/read serialization format)
08:50:23 <Beelsebob> Show is used for one thing and one thing only -- quickly and dirtily showing the value
08:50:36 <Beelsebob> if people are using it for serialisation, they're "doin it rong"
08:50:39 <Lemmih> andyjgill: The issue with line pragmas in hpc is that there's no deterministic way of recovering the original line data, no?
08:51:07 <DRMacIver> I think xmonad for example uses it for serialisation (specifically for passing the current state to the next instance when doing a recompile)
08:51:10 <Peaker> Beelsebob: for that purpose, functions should probably be showable, its more useful than not
08:51:33 <Beelsebob> Peaker: it's useful -- but impossible
08:51:46 <Peaker> Beelsebob: just show partial information about the function
08:51:50 <DRMacIver> It's not impossible. It just requires magic in the implementation.
08:52:06 <Beelsebob> DRMacIver: it's "impossible" if you assume that Haskell is a pure language
08:52:16 <DRMacIver> (And may not be compatible with how ghc handles things)
08:52:20 <Beelsebob> i.e. functions have to be referentially transparent
08:52:30 <andyjgill> Yes. I believe so.
08:52:30 <lambdabot> andyjgill: You have 1 new message. '/msg lambdabot @messages' to read it.
08:52:40 <DRMacIver> Not really.
08:53:21 <DRMacIver> show on functions would be referentially transparent: Every time you passed the same function to it you'd get the same answer. Because there's no Eq instance for functions, "the same" is a very restrictive condition.
08:53:25 <Lemmih> andyjgill: Would you accept a patch that worked in the common case?
08:53:57 <Beelsebob> DRMacIver: not necessarily -- I can think of no Show function that would give the same result for equal input functions in all cases, that doesn't solve Eq for functions
08:54:13 <Beelsebob> e.g. (\x -> x + 2) and (+2) should give the same output
08:54:19 <Beelsebob> because they're the same function
08:54:22 <DRMacIver> Why?
08:54:28 <Beelsebob> they're the same function
08:54:32 <Beelsebob> they are semantically identical
08:54:52 <Beelsebob> remember -- we're not talking about representations of functions, we're talking about functions
08:54:53 <DRMacIver> And if show distinguishes between them, they're no longer semantically identical. :)
08:55:08 <Beelsebob> no, if show distinguishes between them, show is not referentially transparent
08:55:18 <Beelsebob> because you can give it the same input twice and get two different answers
08:56:07 <Beelsebob> Peaker is right that you could give partial information (e.g. you could give part of the map that the function forms), but that would violate the read . show == id condition
08:56:57 <_zenon_StarTrek> Functions are equal if the same input give the same output for all input.
08:57:07 <Peaker> Beelsebob: that's why a debugShow may be due?
08:57:09 <Beelsebob> exactly -- but that's not computable
08:57:33 <Beelsebob> Peaker: oh, I see, so you would say that read . debugShow does not necessarily equal id
08:57:43 <_zenon_> Wooa, that was one long episode :) Episode 15-16 in season 5
08:57:43 <Peaker> Beelsebob: Yeah
08:57:46 <kig> ghci could do :t for showing functions (instead of an error message)
08:57:48 <Beelsebob> yep, that makes sense
08:57:53 <DRMacIver> Given that there's no decidable way of determining if two functions are "the same" in the sense that they are substitutable. Therefore "have the same definition" is a perfectly respectable definition for referential transparency of functions on functions. The fact that you can't get read . show == id to work correctly is more of an issue though, yes.
08:57:57 <chr1s> you can probably only check for equality if you have a finite domain..
08:58:11 <Beelsebob> Peaker: why not create the class, and some sensible instances, and stick it on hackage
08:58:32 <_zenon_> chr1s, or use proofs by induction ?
08:58:34 <DRMacIver> Anyway, I really don't have the energy to argue this right now, so assume I've conceded the point.
08:58:41 <Peaker> Beelsebob: It would require some magic to work nicely (e.g debugShow (*2) == "(*2)") no?
08:58:55 <chr1s> _zenon_: yes.
08:58:57 <Beelsebob> Peaker: oh, good point, you'd need to do some compiler magic
08:59:19 <Beelsebob> Peaker: what you certainly can do is display function maps
08:59:22 <chr1s> that would also work. so you have to prove it by induction for your complete domain.
08:59:35 <Peaker> Beelsebob: what are function maps?
08:59:48 <chr1s> but if you have a finite domain, you can programmatically check equality.
08:59:49 <Abraxas123> zenon: what show are you talking about? not the one in haskell, i hope
09:00:01 <Beelsebob> Peaker: well, each function can be represented as an (in)finite map from domain to range -- display some of the map's contents
09:00:02 <chrisdone> _zenon_: http://img155.imageshack.us/img155/6853/stmwordcloudhb0.png :)
09:00:05 <Abraxas123> only line of chat i can understand here right now, haha
09:00:14 <Beelsebob> so for not it would display {True -> False; False -> True}
09:00:21 <Peaker> Beelsebob: that sucks :)
09:00:32 <Beelsebob> and for (+2) it would display {1 -> 3, 4 -> 6, 8 -> 10}
09:00:40 <Beelsebob> Peaker: it's better than nothing
09:00:41 <Peaker> Beelsebob: f x = if (x==10000) then 0 else (x*2)
09:00:42 <chrisdone> _zenon_: http://chrisdone.com/wordfreq.html and http://chrisdone.com/wordfreq.cgi
09:00:43 <lambdabot> Title: Haskell Code by HsColour
09:00:43 <_zenon_> chrisdone: Nice layout :)
09:00:59 <Beelsebob> Peaker: then you've got an interesting research paper in finding the interesting elements in the domain
09:01:23 <Peaker> Beelsebob: why not just show the algorithm/primitives from which the function was composed?
09:01:30 <chrisdone> _zenon_: thanks :)
09:01:48 <Beelsebob> Peaker: well, that would certainly be a good approach, but would involve inspecting the heap to find out what the function really is constructed from
09:01:54 <Peaker> I guess its tricky - knowing to expand (*2) but not to expand (*) itself
09:02:54 <Abraxas123> is it convention to use <function>' for helper functions/definitions?
09:02:54 <Beelsebob> Hat can do both of these, but only after the event has happened, by inspecting the trace file
09:08:11 <Saizan> i guess the most reasonable approach is to use some interpreter and serialize via bytecodes
09:10:45 <Lemmih> andyjgill: Is darcs.haskell.org/hpc the most current hpc repository?
09:23:43 <chrisdone> on sophistical refutations: http://img297.imageshack.us/img297/3664/onsophisticalrefutationix1.png
09:23:44 <lambdabot> http://tinyurl.com/6z9728
09:24:15 <andyjgill> No. The code inside ghc is the latest.
09:26:04 <andyjgill> darcs.haskell.org/hpc is old (now).
09:30:46 <nisse_hult> can i use list pattern matching with lazy bytestrings?
09:30:53 <nisse_hult> e.g.
09:31:12 <nisse_hult> f (0x50:0x5A:rest) = ...
09:31:49 <Baughn> Nope. They aren't lists.
09:32:28 <nisse_hult> @hoogle FilePath -> IO [Word8]
09:32:29 <lambdabot> No matches, try a more general search
09:33:22 <Baughn> nisse_hult: unpack <$> ByteString.readFile,  perhaps?
09:33:51 <Deewiant> ?ty (Data.ByteString.Lazy.unpack .) <$> Data.ByteString.Lazy.readFile
09:33:51 <lambdabot> FilePath -> IO [Word8]
09:34:53 <nisse_hult> thanks :D
09:35:11 <rwbarton> @ty let f bs | 0x50:0x5A:rest <- Data.ByteString.Lazy.unpack bs = undefined in f  -- will get you some of the way
09:35:12 <lambdabot> forall a. BSLC.ByteString -> a
09:35:17 <nisse_hult> ?type <$>
09:35:18 <lambdabot> parse error on input `<$>'
09:35:39 <Baughn> @src (<$>)
09:35:40 <lambdabot> f <$> a = fmap f a
09:35:42 <rwbarton> But then it's expensive to do anything with 'rest', so that's not so great
09:35:44 <nisse_hult> is that just ($) or is that a magical version of it
09:36:00 <Baughn> nisse_hult: In a monad, it's really just infic liftM
09:36:02 <Baughn> *infix
09:36:32 <nisse_hult> rwbarton: i'm making a simple DOS -> Unix file util
09:36:54 <Baughn> nisse_hult: flip? recode?
09:36:57 <nisse_hult> i know there already are tools, but those aren't made by me
09:37:02 <Baughn> ..quite.
09:37:02 <nisse_hult> recode
09:40:01 <mwolak> If I'm debugging a multithreaded program, is there a way to figure out why a forkIO'd process is sleeping?
09:40:53 <nisse_hult> Baughn: why not just Lazy.readFile >>= return . unpack
09:40:59 <Baughn> mwolak: You're compiling with -threaded, right?
09:41:13 <Baughn> nisse_hult: Mine's shorter, and easier on the eyes
09:41:24 <nisse_hult> Baughn: no, it's not :p
09:41:44 <mwolak> Baughn: ack, no I'm not :(
09:42:35 <Baughn> mwolak: It doesn't directly affect deadlocks. It /does/ make haskell do a couple extra deadlock-detecting checks, and lets it use more than one CPU (if you pass the appropriate arguments to it at runtime).
09:42:55 <Baughn> So with luck, just adding that will get you an error. :P
09:43:09 <nisse_hult> Baughn: how is "(unpack .) <$> readFile" easier on the eyes than "readFile >>= return . unpack"?
09:43:49 <Baughn> nisse_hult: Mine was "unpack <$> readFile". Deewiant is just being pointless
09:43:54 <nisse_hult> ?hoogle IO String
09:43:54 <lambdabot> Prelude.getLine :: IO String
09:43:54 <lambdabot> Prelude.getContents :: IO String
09:43:54 <lambdabot> System.IO.getLine :: IO String
09:44:04 <Deewiant> ?ty Data.ByteString.Lazy.unpack <$> Data.ByteString.Lazy.readFile
09:44:04 <lambdabot>     Couldn't match expected type `BSLC.ByteString'
09:44:05 <lambdabot>            against inferred type `IO BSLC.ByteString'
09:44:05 <lambdabot>       Expected type: FilePath -> BSLC.ByteString
09:44:07 <Deewiant> it's not pointless
09:44:08 <mwolak> ﻿Baughn: ah... OK... still getting more sleeps than I think are right with it
09:44:38 <Baughn> Deewiant: As in, points-free
09:44:55 <Deewiant> but yours doesn't work regardless :-P
09:45:02 <Deewiant> ?ty \f -> Data.ByteString.Lazy.unpack <$> Data.ByteString.Lazy.readFile f
09:45:03 <lambdabot> FilePath -> IO [Word8]
09:45:03 <Baughn> It does if you supply the filename. -_-
09:45:30 <Deewiant> Ð_Ð
09:46:11 <Baughn> Yes, okay. I was assuming it'd get used with a filename, without specifically saying so.
09:46:15 <Baughn> My bad.
09:50:30 <Baughn> ?ty (<*>)
09:50:30 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
09:50:48 <Baughn> ?ty (<$>)
09:50:49 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:52:38 <chrisdone> why are you writing ?ty and not :t?
09:52:49 <chrisdone> ?ty fmap
09:52:50 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:52:50 <chrisdone> :t fmap
09:52:50 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:52:54 <chrisdone> @_@
09:53:20 <Deewiant> because ?ty works in query, :t doesn't
09:54:56 <mwolak> yay, found the holdup... is there any reason why Control.Concurrent.Chan.isEmptyChan should block?
09:55:47 <chrisdone> I'd expect it needs a lock to do the check?
09:58:10 <mwolak> so if I've got another thread waiting on a readChan, would that block it?
09:58:22 <mwolak> <-- new to this multithreading thing
09:59:26 <mib_hz2gsm> question about memoization.  Can it be done in haskell?
10:00:02 <_zenon_> @pl foldr (\x y -> x ++ " " ++ y) "" (words x)
10:00:03 <lambdabot> foldr ((. (' ' :)) . (++)) [] (words x)
10:00:23 <_zenon_> I really should download the pointfree package
10:00:36 <smg> _zenon_: why?
10:00:48 <smg> mib_hz2gsm: it can
10:01:06 <_zenon_> It's nice
10:01:14 <_zenon_> smg: Really neat
10:01:23 <schme_> mib_hz2gsm: http://www.haskell.org/haskellwiki/Memoization
10:01:24 <lambdabot> Title: Memoization - HaskellWiki
10:01:40 <mib_hz2gsm> I have the ffg heavily recursive function to compute the no. of partitions of a number.
10:01:45 <smg> _zenon_: it makes code unreadable imho :)
10:02:13 <mib_hz2gsm> It runs orders og magnitude slower than a memoized python version.
10:02:35 <_zenon_> smg: it's 1337 |-|@xX0r |_|/-\zz|<Ell
10:02:42 <mib_hz2gsm> p = ((map p' [0 ..]) !!)
10:02:49 <_zenon_> smg: hehe, yeah, but it's nice to excercise the brain a bit
10:03:02 <mib_hz2gsm> where   p' 0 = 1   p' 1 = 1   p' n = sum [(((-1) ^ (k+1)) * ( p'(n-((k*(3*k-1)) `div` 2)) +  p'(n-((k*(3*k+1)) `div` 2)) )) | k <- [1 .. n]]
10:03:02 <smg> hehe
10:04:02 <Saizan> mwolak: yes, if a thread is waiting in a readChan, isEmptyChan will block too
10:05:01 <lumi> Can anyone help me with Cabal build problems?
10:05:41 <Saizan> lumi: what's the problem?
10:05:59 <mwolak> Saizan: thanks... been chasing that bug for a couple hours
10:06:47 <Saizan> mwolak: it has surprised be a bit too, i had to look at the source to see it
10:07:14 <lumi> Saizan: I'm trying to build Cabal, and when it's compiling Distribution.Text it dies, with "Illegal instruction"
10:07:46 <lumi> Saizan: I'm on a G4 Mac, I installed GHC 6.8.3 from the binary distribution
10:09:00 <Saizan> lumi: does compiling other programs work fine?
10:10:17 <lumi> Saizan: As far as I can tell
10:13:40 <Saizan> lumi: i've no clue then, that module is quite simple
10:15:38 <Abraxas123_> let divby4 n = n `mod` 4 == 0 in filter divby4 [1..20]
10:16:06 <Abraxas123_> filter (`mod` 4 == 0) [1..20]
10:16:17 <Abraxas123_> the second can't work, right
10:16:37 <lumi> Saizan: I doesn't see anything special about it, yeah. Thanks
10:16:41 <Deewiant> > filter ((== 0).(`mod` 4)) [1..20]
10:16:42 <Abraxas123_> not working without the let, i mean
10:16:43 <lambdabot>  [4,8,12,16,20]
10:16:50 <Abraxas123_> ah, ok
10:17:03 <Deewiant> @pl divby4 n = n `mod` 4 == 0
10:17:03 <lambdabot> divby4 = (0 ==) . (`mod` 4)
10:17:16 <Abraxas123_> why does lambdabot not work with mine
10:17:38 <_zenon_> '>' first
10:18:02 <Abraxas123_> d'oh
10:20:55 <Peaker> I prefer the direction of >>> to that of (.)
10:21:03 <Peaker> (and that of unix pipes)
10:24:01 <Abraxas123_> > filter ((== filter ((== 0).(`mod` 4))).(+1)) [1..20]
10:24:01 <lambdabot>        add an instance declaration for
10:24:02 <lambdabot>       (Enum ([a] -> [a]), Num ([a] -> ...
10:24:54 <funktio> > filter ((== 0) . (`mod` 4) . (+ 1)) [1..20]
10:24:57 <lambdabot>  [3,7,11,15,19]
10:25:02 <funktio> > filter ((== 1) . (`mod` 4)) [1..20]
10:25:03 <lambdabot>  [1,5,9,13,17]
10:25:10 <Abraxas123_> cool, thx
10:25:21 <funktio> > filter ((== 3) . (`mod` 4)) [1..20]
10:25:22 <lambdabot>  [3,7,11,15,19]
10:25:56 <Peaker> @unpl (== 0) . (`mod` 4) . (+ 1)
10:25:57 <lambdabot> (\ f -> (mod (f + 1) 4) == 0)
10:26:01 <smg> > [x+1 | x <- [1..20], (x `mox`4) == 0]
10:26:02 <lambdabot>   Not in scope: `mox'
10:26:09 <smg> > [x+1 | x <- [1..20], (x `mod` 4) == 0]
10:26:10 <lambdabot>  [5,9,13,17,21]
10:26:23 <smg> > [x+1 | x <- [0..20], (x `mod` 4) == 0]
10:26:25 <lambdabot>  [1,5,9,13,17,21]
10:26:42 <Abraxas123_> that's how i would have done until 10 minutes ago :D
10:27:20 <mofmog> Is there any reason a haskell binary compiled on ubuntu won't work on another ubuntu system even if both are up to date?
10:27:30 <Peaker> Abraxas123_: and how you should do it in the future too :-)
10:27:44 <Abraxas123_> huh, filter isn't nicer
10:30:05 <paczesiowa> mofmog: did you try ldd?
10:30:18 <peppe> hello
10:30:24 <mofmog> yes
10:30:33 <mofmog> he apparently doesn't have libreadline5
10:30:45 <paczesiowa> "apparently" ?
10:30:50 <mofmog> so he tried sudo apt-get install libreadline5 etc and apparently he already has the latest version
10:31:02 <mofmog> he being the guy i sent the binary to
10:32:13 <Peaker> Abraxas123_: IMO a list-comp is nicer
10:32:22 <Peaker> Abraxas123_: less fancy, easier to read
10:32:52 <mofmog> I used ghc --make -O2 Main.hs -o RPNEval if it helps
10:33:02 <paczesiowa> mofmog: try sending him your libreadline binary and tell him to LD_PRELOAD it
10:33:31 <paczesiowa> or the other way - try it with his readline lib
10:33:55 <gwern> @pl foo a = replicate (length a) '_'
10:33:56 <lambdabot> foo = flip replicate '_' . length
10:34:55 <paczesiowa> mofmog: do you use any advanced readline features? maybe just use getLine and use a wrapper like rlfe/rlwrap that would work even on systems without readline
10:34:57 <mofmog> LD_PRELOAD?
10:35:18 <mofmog> i only use readline so that input isn't stupid
10:35:24 <mofmog> no history or anything like that
10:35:38 <Abraxas123_> peaker: yeah with more than one filter it's ugly
10:36:07 <paczesiowa> you can use getLine but fire your app like "rlwrap ./RPNEval" that magically turns readline magic on every getLine call
10:36:49 <kpreid> rlwrap Is Good
10:36:59 <mofmog> yeah but rlwrap is something ill have to get him to dl too
10:37:02 <pejo> mofmog, could you paste the output from ldd on his system and your system?
10:37:04 <mofmog> i guess
10:37:11 <mofmog> um sure
10:37:21 <mofmog> i should probably hpastet his
10:37:45 <paczesiowa> mofmog: there is also rlfe (alternative to rlwrap) which is distributed together with readline so chances are that he already has it
10:38:11 <paczesiowa> at least if ubuntu doesn't mess up readline package
10:38:20 <mofmog> nope that's not something included in ubuntu
10:38:25 <mofmog> you have to install it separately
10:39:02 <paczesiowa> anyway, it is one command to install it, easier than waiting for someone who can fix it
10:39:12 <peppe> I declared a class X and a data Y. now I wish to say that "instance X [Y]". why isn't this possible? hugs says Syntax error in instance head
10:39:28 <mofmog> http://codepad.org/pkKtDnnh
10:39:52 <mofmog> well eventually i want to distribute the binary to more people
10:40:37 <paczesiowa> mofmog: tell him to "find /lib/ -name *readline*"
10:42:38 <paczesiowa> mofmog: as soon as you want to send it to windows ppl, you'll have this problem again.
10:44:08 <mofmog> yeah hm
10:44:08 <paczesiowa> mofmog: you can post your app to hackage, and tell your friends to get cabal-install and cabal install yourApp. maybe the will even have some fun with ghc:>
10:44:18 <mofmog> hahah yeah right
10:44:37 <mofmog> i wish there was some way to get it into java bytecode or something
10:47:02 <paczesiowa> if ghc was as widespread as jvm there would be no problem, you would just open .hs files with runghc
10:47:38 <paczesiowa> maybe try this: http://www.haskell.org/ghc/docs/latest/html/libraries/readline/System-Console-SimpleLineEditor.html looks cross-platform and doesn't need readline
10:47:38 <lambdabot> Title: System.Console.SimpleLineEditor, http://tinyurl.com/5z4bdv
10:49:15 <paczesiowa> you have that find output from your friend yet?
10:59:45 * gwern finishes a hilariously ugly text mangling script
11:00:35 <chrisdone> why isn't lambdabot's foldr = Data.Foldable.foldr?
11:00:42 <mofmog> ok, now for the last thing bothering me: I have a 35 line function definition that's all essentially pattern matching
11:00:48 <mofmog> how do i un-uglify this
11:00:51 <chrisdone> this is not the caleskell I dreamed about v_v
11:00:53 <gwern> chrisdone: blame Cale, probably
11:01:11 <Cale> heh
11:01:17 <chrisdone> me `blame` cale
11:01:39 <gwern> It turns Edward Fitzgerald's Rubaiyat into 300 questions for the menosyne memorization software <https://secure.wikimedia.org/wikipedia/en/wiki/Mnemosyne_(software)>
11:01:40 <lambdabot> https://secure.wikimedia.org/wikipedia/en/wiki/Mnemosyne_(software)>
11:01:54 <gwern> I'd put it on hpaste for everyone to mock, but hpaste seems to be done
11:02:05 <chrisdone> http://paste.lisp.org/
11:02:09 <paczesiowa> mofmog: why is it ugly? unless that pattern-matching overlaps somehow, you still have to do it somewhere
11:02:19 <uzytkownik> Hello. I'm started learning bit of Haskell. I have a question could lambda \x -> mod (x+2) 7 be written shorter. I know that (+2) <=> \x => x + 2 but (mod 7) <=>\x => mod 7 x so I cannot write (mod 7) . (+2).
11:02:23 <gwern> (heck of a job you're doing there, browny)
11:02:44 <mofmog> hmm is hpaste down?
11:02:53 <chrisdone> yeah
11:02:58 <mauke> @pl \x -> mod (x+2) 7
11:02:59 <lambdabot> flip mod 7 . (2 +)
11:03:04 <funktio> (`mod` 7)
11:03:05 <rwbarton> Hi uzytkownik, you can either write (`mod` 7) . (+2) or (flip mod 7) . (+2)
11:03:21 <gwern> @pl \x -> mod (x+2) 7
11:03:22 <lambdabot> flip mod 7 . (2 +)
11:03:23 <gwern> dang it mauke
11:03:30 <mofmog> BEHOLD! http://codepad.org/dZm3sbFY
11:03:41 <mofmog> you begin thinking, "eh, not that bad"
11:03:43 <mofmog> then you get to eval
11:03:44 <gwern> http://paste.lisp.org/display/63633 <-- marvel at the crapitude of the 'fun' definition
11:04:49 <Axman6> mofmog: yuck :|
11:05:12 <paczesiowa> mofmog: (Operator "take"):[] c'mon! [Operator "take"]
11:05:27 <mofmog> oh... right
11:05:27 <gwern> mofmog: if first a man resorts to murder, than he shall come to arson and larceny, and descend from there to petty theft and assault, and at long last he shall become incivil (if I may paraphrase de quincey(
11:05:38 <mofmog> i wrote it at 2 am
11:05:44 <uzytkownik> rwbarton & others: Thanks
11:05:53 <funktio> ((Bool x):(Bool y):ys) <=> (Bool x : Bool y : ys)
11:06:24 <geezusfreeek> at least there is plenty of repetition to factor out
11:06:36 <mofmog> yeah exactly i need to factor it all out ahahaha
11:06:51 <paczesiowa> mofmog: you have plenty of eval lines where you pattern match on first stack but you don't touch others, you can just use eval st1 st2 st3 = case st1 of...
11:06:54 <geezusfreeek> i just mean at least it is fairly obvious
11:07:07 <mofmog> right right
11:07:14 <mofmog> i'll still need multiple evals right?
11:08:12 <paczesiowa> yeah, but you could group them for matching done on specific stack
11:08:36 <kpreid> gwern: I'd extract the ++ful part so that I could write [format a b' c d', format a' b c' d, ...]
11:09:01 <ddarius> mofmog: Use a lookup table.
11:09:28 <gwern> kpreid: yeah, it could be cleaned up. I just wanted to get it done, and was amused at how nasty the final definition is
11:09:29 <mofmog> DATA DIRECTED PROGRAMMING?!@
11:09:40 <mofmog> geez, id know how to do it scheme
11:09:44 <mofmog> but not in haskell
11:10:09 <gwern> data directed programming? In *my* haskell? unpossible!
11:10:22 <Axman6> mofmog: ask my COMP lecturer then, we've been doing it in haskell for the last 4 months or so
11:10:48 <mofmog> yeah, we learn all this stuff in scheme. which means we use...
11:10:51 <mofmog> *whispers* state
11:11:21 <Axman6>                            silence...
11:11:26 <kpreid> mofmog: smalll tip: I notice you writing eval ... (Number x) ... = ... (Number x) ... -- you can write that as ... n@(Number _) ... = ... n ...
11:11:54 <ddarius> gwern: flip replicate '_' . length === map (const '_')
11:12:16 <kpreid> mofmog: also you could write eval (x:xs) ... | isLiteral x = ... instead of three lines for Number Bool and Quote
11:12:44 <gwern> ddarius: man, I don't even see how that'd work
11:12:48 <gwern> where's the map coming from?
11:13:07 <Axman6> kpreid: what does "n@(Number _) ... = ... n" do? i've never seen that before
11:13:30 <kpreid> Axman6: the value is bound to the left side and also matched against the right side
11:13:44 <Axman6> of the @?
11:13:44 <ddarius> @check \xs -> (flip replicate '_' . length $ xs) == map (const '_') (xs :: Int)
11:13:45 <lambdabot>  Couldn't match expected type `Int' against inferred type `[a]'
11:13:51 <ddarius> @check \xs -> (flip replicate '_' . length $ xs) == map (const '_') (xs :: [Int])
11:13:52 <lambdabot>  OK, passed 500 tests.
11:13:58 <gwern> Axman6: n is the name of the entire list
11:14:03 <kpreid> Axman6: yes
11:14:06 <gwern> Axman6: it's kind of sugar
11:14:14 <kpreid> > let a@b = 1 in (a, b)
11:14:15 <Axman6> ok
11:14:15 <lambdabot>  (1,1)
11:14:33 <kpreid> > let xs@(x:_) = "abc" in (x, xs)
11:14:35 <lambdabot>  ('a',"abc")
11:14:36 <ddarius> gwern: Your replicate length thing is just making a list of the same length as the input with all characters replaced with '_'
11:14:46 <Axman6> so, that would set both sides of the @ to the same thing?
11:14:56 <zachk> > 2^100
11:14:57 <lambdabot>  1267650600228229401496703205376
11:14:59 <kpreid> Axman6: yes
11:15:24 <Axman6> rwar, that confuses me at 4am >_<
11:16:23 <gwern> ddarius: yes
11:17:50 <tusho> Say, if I'm writing a lang->C compiler, could Language.H be useful?
11:17:56 <tusho> er
11:17:57 <tusho> .C
11:18:17 <FunctorSalad_> what's the proper data structure for an ordered collection with fast random access?
11:18:28 <FunctorSalad_> (in the haskell lib I mean)
11:21:06 <gwern> data.sequence maybe
11:21:15 <gwern> index: O(log(min(i,n-i))). The element at the specified position
11:21:16 <tusho> ?
11:21:29 <gwern> if the arrays aren't appropriate
11:22:24 <zachk> is there a way for me to do take with bignums? or do i need to roll my own
11:22:30 <zachk> > :t take
11:22:31 <lambdabot>   parse error on input `:'
11:22:37 <zachk> blargh
11:22:42 <rwbarton> :t genericTake
11:22:44 <lambdabot> forall i a. (Integral i) => i -> [a] -> [a]
11:23:10 <rwbarton> Most of the functions in List that use the Int type have generic versions like that
11:24:13 <FunctorSalad_> gwern: oh, didn't realize there were arrays in haskell at all ;)
11:24:23 <FunctorSalad_> but I should probably design this differently anyway
11:24:41 <gwern> FunctorSalad_: we have plenty of arrays... possibly too many
11:24:57 <zachk> rwbarton: what do import for genericTake ,  Data.List?
11:25:05 <ddarius> Haskell quite possibly has more arrays than any other language.
11:25:24 <ddarius> tusho: Presumably there is a pretty printer for their AST data type.
11:25:29 <FunctorSalad_> ddarius: heh. add that to the "why learn haskell" list on the wiki? ;)
11:25:29 <rwbarton> zachk: I think so
11:25:41 <tusho> ddarius: Yes. Just asking if constructing the AST is friendly enough
11:27:10 <ddarius> tusho: Does it matter?  It's almost certainly still better to build something nicer on top of it (if necessary) than to rewrite it.
11:27:28 <tusho> Well, the previous version just mashed strings together, the C generated is trivial
11:27:29 <tusho> :p
11:29:34 <zachk> mm  last $ genericTake (1+2^100) fibs is taking a bit
11:32:21 <ddarius> zachk: It may well be in your interest to inline the definition of fibs in that example if fibs is currently a top-level value.
11:33:37 <ddarius> Also you'd probably want to force the elements as you go along.
11:35:51 <zachk> ok i was using fibs=0:1:zipWith (+) fibs (tail fibs)
11:35:58 <zachk> so how do i inline that
11:36:04 <zachk> and force the elements as i go along
11:37:46 <ddarius> zachk: You can inline that by just replacing the use fibs with a let binding, and the simplest way of forcing the elements as you go along is to write a variant of last that does this.
11:38:26 <ddarius> Either way, it's still going to take a while.
11:38:54 <zachk> i killed my initial run, was grinding my harddrive and locking up my messenger program
11:40:14 <ddarius> The changes I'm suggesting are mainly to reduce memory usage.  It should get it down to constant memory usage ignoring the size of the integers which will not be trivial.
11:42:02 <zachk> ddarius: so a let binding for fibs, (thats faster then a top level? why?) and write my own last function to use $! to force evaluation?
11:42:45 <ddarius> zachk: To give you an idea of how long this will take.  I once wrote a tight loop in assembly that just incremented a register until it overflowed.  While this was on a fairly archaic machine (Pentium II 200 I think), it still took a few minutes(?) to execute (admittedly while using my computer to do other stuff as well).  That was just to overflow a 32-bit counter.
11:43:12 <ddarius> zachk: Again, it's not about speed so much as memory.  The top-level binding can't forget any values that you generate.
11:43:33 <DRMacIver> 2^100 is um. on the largish side. :) I don't think you're going to get that terminating in a reasonable amount of time regardless of what you do.
11:44:07 <zachk> im trying to interest a highschooler who is a bit of a math whiz , that is interest him in haskell
11:44:16 <zachk> intially he wanted 2^1000
11:44:21 <FunctorSalad_> DRMacIver: ah, quitter ;)
11:44:26 <zachk> and im like thats quite large
11:44:29 <ddarius> zachk: Then you need to use a better algorithm.
11:44:40 <FunctorSalad_> (kidding)
11:44:42 <Abraxas123_> the foldr explanation here as completely wrong, isn't it: http://www.cse.unsw.edu.au/~en1000/haskell/hof.html
11:44:43 <lambdabot> Title: Higher Order Functions - map fold and filter
11:44:48 <Abraxas123_> *is
11:45:22 <DRMacIver> Hm. And testing something related to this gave me a ghc internal error.
11:45:59 <DRMacIver> http://pastebin.com/m57dee1f (hpaste seems to be down)
11:46:11 <Abraxas123_> if i'd follow this foldr (-) 0  [1,2,3] would be 0-3-2-1
11:46:55 <ddarius> DRMacIver: That number would be bigger than your memory.
11:47:04 <DRMacIver> Well, yes.
11:47:37 <DRMacIver> But it's of the approximate ballpark size as the 1 + 2^100'th fibonacci number.
11:47:57 <zachk> is running things from ghci slower then running them compiled with ghc?
11:48:02 <DRMacIver> And it probably still shouldn't give that particular error. :)
11:48:13 <tusho> Say, can I do an 'assertation parser' in Parsec?
11:48:14 <tusho> Like
11:48:16 <ddarius> Yeah.  That's another problem.  Even if you use a better algorithm and calculate the number.  It will take "forever" just to display it.
11:48:18 <FunctorSalad_> that *is* a lot considering that they are asymptotically 1.6something^n
11:48:19 <tusho> pleaseNot ")"
11:48:21 <tusho> if given a )
11:48:25 <tusho> would error "unexpected ')'"
11:48:31 <tusho> but would just succeed consuming nothing otherwise
11:48:43 <mauke> tusho: notFollowedBy
11:48:48 <mauke> zachk: yes
11:48:53 <Beelsebob> Abraxas123_: you can interpretet foldr as being "replace all the : symbols in a list with the function, and [] with the zero element", so foldr (-) 0 (1:2:3:[]) becomes 1 - 2 - 3 - 0
11:49:21 <zachk> i actually want the 2^100th fibonacci number
11:49:33 <tusho> mauke: not what I asked
11:49:33 <tusho> :(
11:49:44 <mauke> tusho: how so?
11:49:56 <tusho> mauke: it .. just isn't what I asked for?
11:50:12 <Abraxas123_> right, the guy on that page i linked out the initial value the wrong way
11:50:19 <Abraxas123_> *put
11:50:22 <FunctorSalad_> can GADTs be defined "mutually"?
11:50:32 <mauke> tusho: it is exactly what you asked for
11:50:34 <ddarius> FunctorSalad_: I don't see why not.
11:51:07 <tusho> mauke: I put (notFollowedBy $ char ')') as the second-last element in a 'choice'  call, and when given the input ")", it just passes through.
11:51:07 <FunctorSalad_> ddarius: hmm, I thought things can only be used after they are defined in a file
11:51:10 <tusho> I want it to error out.
11:51:12 <ddarius> zachk: What DRMacIver is saying is the result of that won't fit in memory.
11:51:19 <ddarius> FunctorSalad_: This isn't C.
11:51:31 <mauke> tusho: did one of the other choices succeed?
11:51:37 <tusho> mauke: Not any earlier one, no.
11:51:38 <ddarius> How would we define any mutually recursive anythings then?
11:51:40 <Beelsebob> @hoogle [a] -> Integer -> a
11:51:41 <lambdabot> No matches, try a more general search
11:51:43 <chrisdone> http://paste.lisp.org/display/63635 -- can someone explain how to get around this rigid type variables problem?
11:51:43 <zachk> oh ok
11:51:47 <mauke> tusho: doesn't matter if it's earlier
11:51:53 <Beelsebob> hmm, there isn't a (!!) that works on Integers?
11:52:03 <tusho> mauke: Well duh, the later one succeeds with it, that's why I'm putting this before it - to stop it
11:52:05 <mauke> Beelsebob: genericIndex?
11:52:06 <ddarius> :t genericIndex
11:52:07 <lambdabot> forall b a. (Integral a) => [b] -> a -> b
11:52:12 <Beelsebob> bad hoogle!
11:52:16 <Abraxas123_> his page was linked by haskell.org, thogh
11:52:21 <Abraxas123_> *though
11:52:22 <chrisdone> b
11:52:24 <mauke> tusho: but choice catches parse errors and tries the other parsers
11:52:25 <chrisdone> whoops
11:52:27 <mauke> tusho: that's its job
11:52:31 <Abraxas123_> what's up withy my typing lol
11:52:36 <Beelsebob> @index genericIndex
11:52:36 <lambdabot> Data.List
11:52:38 <tusho> mauke: Right. So what should I do?
11:52:53 <ddarius> zachk: You could use a different representations of numbers possibly, but even if you do that, outputting the result in the normal manner would take a long time and be extremely large.
11:53:14 <mauke> choice [a, b, c] <|> (notFollowedBy (char ')') >> choice [x, y, z]
11:53:31 <mauke> )
11:53:47 <paczesiowa> chrisdone: I think that mu has to work forall a, not just the a that is inside Bar/Zot
11:54:46 <chrisdone> paczesiowa: hmm with “forall a. a -> ...” I get “cannot construct infinite type”. is that what you meant? or should it be forall a. Num a ?
11:54:48 <tusho> mauke: Still just passes through silently.
11:55:06 <mauke> :-(
11:56:00 <tusho> Perhaps I should paste my code ;)
11:56:02 <mauke> well, it works in my regex
11:57:16 <chrisdone> paczesiowa: any ideas?
11:57:23 * Beelsebob ponders why let fibs n m = n : fibs m (n + m) in length $ show ((fibs 1 1) `genericIndex` (2 ^ 100)) -- causes a space leak
11:57:30 <Beelsebob> I mean, I can understand a time leak
11:57:40 <Beelsebob> but it's tail recursive -- where's the RAM going?
11:57:50 <Beelsebob> unless genericIndex is being shit
11:57:57 <DRMacIver> Does it cause a space leak? Or does it just eat RAM with the large size of the numbers?
11:57:59 <ddarius> Beelsebob: Into the thunsk and into the list.
11:58:02 <paczesiowa> chrisdone: (I may be wrong) in the declaration of mu you say that it has to work forall (forall is implicit) Num a. but later when you define instance for Bar (zot a), you actually only define mu for the type that is inside Bar and Zot
11:58:13 <tusho> HPASTE IS DOWN
11:58:14 <tusho> WHY
11:58:27 <Beelsebob> DRMacIver: hmm, 1GB numbers?
11:58:36 <Beelsebob> ddarius: I don't see what you're saying there
11:58:47 <DRMacIver> Beelsebob: Don't see why not. Give them enough digits...
11:59:12 <tusho> :(
11:59:19 <Beelsebob> DRMacIver: yeh, I'm not imagining numbers *that* big come out of the 2^100th fib
11:59:26 <Beelsebob> I mean, big, but not that big
11:59:28 <paczesiowa> chrisdone: how about you tell us what is it you want to achieve
11:59:50 <DRMacIver> Beelsebob: I don't know. It should be about 1.6 ^ 2 ^ 100. That's pretty damn big. :)
12:00:02 <ddarius> Beelsebob: fibs may or may not be collectible and the elements of fibs are things like [0,1,0+1,(0+1)+1, ... etc
12:00:36 <tusho> hpaste down for anyone else?
12:00:41 <DRMacIver> Yes
12:00:43 <Beelsebob> ddarius: ah, good point -- so strictifying fib generation should sort it
12:01:02 <Beelsebob> (and reduce it to a time leak)
12:01:07 <Valodim_> some day, haskell will be able to solve the ackermann function with both arguments graham's number
12:01:12 <ddarius> That would get rid of one problem, but not the other two.
12:01:16 <chrisdone> paczesiowa: this code suffers from the same problem at the commented out region: http://paste.lisp.org/display/63632#2
12:01:38 <tusho> What is the officially sanctioned hpaste temp replacement? Lisppaste? :P
12:01:40 <Beelsebob> ddarius: what are you seeing as the other two?
12:02:23 <ddarius> Actually, scratch one of them, but DRMacIver is right about the size of the Integers.
12:03:31 <paczesiowa> chrisdone: where exactly is the error?
12:03:54 <paczesiowa> chrisdone: commented out code?
12:04:12 <jpcooper> say I have a type Vector a constructed with Vector a b c, what is the nicest way to add two vectors together so that the resulting vector is made of the sum of respective components?
12:04:19 <jpcooper> sums*
12:04:49 <ddarius> jpcooper: The obvious way.
12:05:04 <jpcooper> with pattern matching, I guess
12:05:08 <jpcooper> I was wondering if there was a nicer one
12:05:16 <chrisdone> paczesiowa: Raytrace.hs:38:35: Couldn't match expected type `a' against inferred type `a1' `a' is a rigid type variable bound by the type signature for `intersect' at Raytrace.hs:22:21, `a1' is a rigid type variable bound by the instance declaration
12:05:44 <Abraxas123_> uh, Beelsebob, wasn't right what you said about foldr
12:06:04 <Abraxas123_> > foldr (-) 0 [1,2,3] == 1-2-3-0
12:06:05 <lambdabot>  False
12:06:44 <ddarius> Abraxas123_: He wasn't respecting (-)'s associativity.
12:06:44 <Beelsebob> > foldr (-) 0 [1,2,3] == 1-(2-(3-0))
12:06:46 <lambdabot>  True
12:06:55 <Beelsebob> it uses (:)'s associativity
12:07:26 <Abraxas123_> yup, that's it
12:08:27 <paczesiowa> chrisdone: http://paste.lisp.org/display/63632#3
12:09:28 <jpcooper> paczesiowa,
12:09:28 <jpcooper> instance (Ord a, Fractional a) => Drawable (Sphere a) a
12:09:31 <jpcooper> what's the last a for?
12:09:37 <paczesiowa> chrisdone: it compiles, but you have to try if it works as you want it to
12:10:02 <paczesiowa> jpcooper: do you know what are mptc?
12:10:22 <jpcooper> no
12:10:41 <chrisdone> jpcooper: Drawable is `class Num a => Drawable d a where'
12:11:12 <jpcooper> aah yes
12:11:40 <paczesiowa> jpcooper: http://en.wikibooks.org/wiki/Haskell/Advanced_type_classes#Multi-parameter_type_classes
12:11:42 <lambdabot> http://tinyurl.com/6qsfng
12:11:56 <jpcooper> thanks
12:12:17 <chrisdone> paczesiowa: thanks, we are both confused about this problem
12:13:11 <dons> http://www.reddit.com/info/6rkme/comments/
12:13:12 <lambdabot> Title: reddit.com: OpenGL programming in Haskell: a tutorial
12:13:21 <dons> http://www.reddit.com/r/programming/info/6rkm2/comments/
12:13:22 <lambdabot> Title: programming: The Curry-Howard isomorphism and the duality of → and ×
12:14:52 <ddarius> dons: The OpenGL tutorial that refers to has been around for some time.
12:15:16 <dons> i think it's just been moved to the wiki?
12:15:30 <dons> yeah, 22:05, 7 July 2008 Povman (Initial)
12:15:46 <ddarius> Yes.  The wiki page is new.
12:17:14 <paczesiowa> chrisdone: the problem was that it was supposed to work with all Num types, but when you fix your Drawable type you already know the numeric type inside and you only want to work with that type. you will probably hae to use function dependancy to specify that " | d -> a" that type of that drawable uniquely determines the numeric type (just like in collection example on haskellwiki)
12:17:31 <azz_> hello everyone
12:19:26 <azz_> i was wondering something... suppose you were porting some classes from an OO language to a haskell program
12:19:58 <azz_> if your OO program had an abstract class which implemented methods
12:20:16 <azz_> (as well as its concrete subclasses)
12:20:23 <Baughn> azz_: Is this something you're likely to do?
12:20:49 <Beelsebob> azz_: don't try to port your code directly -- instead try to look at what it does, and write a functional version to replace it
12:20:57 <Beelsebob> just writing imperative code in Haskell gets you almost no benefit
12:21:11 <azz_> it's just an idea
12:21:26 <Baughn> That's true. A direct port from an imperative language has you getting annoyed with haskell and writing bad code
12:21:39 <azz_> the thing is
12:21:50 <Baughn> Also, haskell has relatively poor support for OO, and much of what it does have depends on non-standard type tricks in ghc
12:22:03 <Baughn> This does not mean you can't write the same programs. Just not the same way.
12:22:32 <azz_> i'm studying the possibility of converting alloy analyzer specs
12:23:00 <paczesiowa> chrisdone: if intersect would have to work with all Num types, it would have to intersect e.g. Ray of complex numbers with drawable thing consisting of doubles. when it has to work with all Num types you can only use functions from Num class, and there isn't anything useful for working with other types (signum looks the most useful:)
12:23:19 <azz_> into haskell programs
12:23:54 <azz_> these programs would include the corresponding data type definitions and quickcheck properties and value generators
12:24:06 <chrisdone> paczesiowa: I think I see
12:24:59 <Philippa> Beelsebob: While that's true, I think it's noteworthy that writing /good/ imperative code in Haskell (which is to say, easy on the side-effects in a number of ways) and getting v.picky with the monadic typing does give you some significant advantage. Of course, you already have to be able to think functionally to do that
12:25:29 <Philippa> azz_: sounds like the issue's emulating OO-style polymorphism, yeah?
12:25:35 <azz_> exactly
12:25:52 <azz_> what i and my supervisor thought about doing was
12:25:53 <Philippa> azz_: functions are first class values, does that help any?
12:26:10 <azz_> Philippa: not quite sure :)
12:26:12 <Baughn> azz_: Under the assumption that you already know haskell'98 well, have you looked at existential qualification?
12:26:20 <paczesiowa> OOHaskell looks great if you can handle cryptic type errors (but it is probably very slow)
12:26:23 <Deewiant> quantification*
12:26:28 <Baughn> (That's the "non-standard extension" I referred to earlier)
12:26:32 <Baughn> *quantification, yes
12:26:40 <azz_> my haskell is a bit rusty TBH :)
12:26:43 <Philippa> Baughn: it's about as standard as an extension gets...
12:26:43 <cjs> azz: With any luck, you might do well with this.
12:26:55 <azz_> yes, cjs?
12:27:20 <cjs> Haskell is different. The polymorphism you're used to is not there, but on the other hand, the data declarations can sometimes be amazingly easy.
12:27:25 <Philippa> azz_: you can use first-class functions to put the methods 'in' the individual objects. The existential approach is a more smartarsed way of encoding it
12:27:40 <cjs> (I speak as a 10-year-or-so OO guy who just switched to Haskell.)
12:27:54 <Philippa> data MyObj = MyObj {field1 :: ..., field2 :: ..., method1 :: ...}
12:28:20 <azz_> yes, that's what i'm doing and it is effective
12:28:35 <azz_> except when there are abstract classes involved
12:28:38 <cjs> I find that the main thing is to get over the, what should I call it, "namespace pain," as it were.
12:28:48 <mauke> ash used OOHaskell! it's super effective!
12:29:03 <Philippa> azz_: abstract classes just don't have a concrete representation. The closest match'd be a typeclass, I guess
12:29:06 <cjs> azz_: Are you familiar with type classes and all of that?
12:29:07 <Beelsebob> azz_: why can't the "methods" be method1 = error "not implemented"
12:29:26 <azz_> the solution i thought about was to: all methods in the abstract class or interface get into a type class
12:29:29 <chrisdone> A wild O'Caml appeared
12:29:39 <azz_> yes, yes
12:29:41 <Philippa> Beelsebob: now type that. Universal types suck.
12:29:49 <Philippa> azz_: yep, that's pretty much the way to do it
12:30:04 <Philippa> in fact, interfaces're pretty much a special case of type classes
12:30:10 <azz_> yes
12:30:11 <Beelsebob> Philippa: agreed -- I never said it would be pretty -- on the other hand I don't see directly porting OO code as pretty either
12:30:25 <Philippa> Beelsebob: preserving type info is better than ditching it
12:30:30 <cjs> Actually, if you're an OO guy, look at it this way: type classes are type-checked duck typing.
12:30:32 <azz_> except that doesn't work when the methods are implemented at the abstract level
12:30:47 <Beelsebob> Philippa: writing a functional program is better than trying to do OO in a functional language
12:31:08 <Philippa> Beelsebob: not if you have an OO-flavoured problem. azz_ does.
12:31:19 <azz_> so i'm stuck when writing the instance code for each type
12:31:21 <Baughn> azz_: Which type-class instance to use is, of course, statically determined at compile time
12:31:22 <Philippa> azz_: as in a one-off? Or just a default implementation?
12:31:30 <cjs> But OO can work ok in a functional language, if you don't take it too far. I've found myself several times using closures exporting functions to do OO-type stuff.
12:31:45 <cjs> Though, curiously, not lately. Maybe I'm becoming more functional. :-)
12:31:45 <Baughn> If that doesn't do - existential quantification lets you bundle a dictionary with the object, instead of passing it in from the function using it
12:32:01 <Philippa> cjs: OO style design works *wonderfully* in a functional language where it's appropriate. There's a reason OO evolved significantly in functional and pseudo-functional settings
12:32:18 <azz_> in my understanding when a method is implemented in the abs. class it is a "default implementation"
12:32:30 <Philippa> azz_: you can do that with typeclasses too
12:32:32 <EvilTerran> kinda
12:32:48 <azz_> my problem is that typeclasses do not seem to provide a way to do "default implementations"
12:32:50 <Philippa> if it's not overrideable, it doesn't go in the class at all - it's just an ordinary function
12:33:03 <azz_> good point
12:33:03 <cjs> Philippa: yes, I think I'd agree with that, with perhaps not quite so much emphasis.
12:33:05 <erikc> What is the standard way of binding to COM? Marshalling structs?
12:33:24 <cjs> EvilTerran: kinda ja nai. Better!
12:33:58 <Philippa> cjs: wandering off into message-passing concurrency territory using mostly OO-style design works pretty damn well too, and IME makes a good model for IO-based stuff
12:34:20 <cjs> E.g., the ability to provide default implementations for everything, and let the, err..."subclass" decide which one to impement, and then just all the others work, that's really cool.
12:34:28 <pejo> erikc, Calling hell from heaven and heaven from hell deals with that, but things might have changed since the paper was written.
12:34:40 <azz_> Philippa: but that would mean that the function can't be declared as part of the class
12:35:00 <azz_> s/class/typeclass
12:35:06 <cjs> Philippa: Sure. But keep in mind, Smalltalk has a lot of FP ideas in the background, there.
12:35:18 <pejo> Philippa, "IME"?
12:35:38 <cjs> Philippa: so you're not getting so far from FP after all, when you head that way. (Not that a lot of OO languages do.)
12:35:45 <tusho> mauke:
12:35:45 <tusho> http://paste.lisp.org/display/63636
12:35:46 <tusho> the parser
12:37:05 <Euler_> how can I determine if a list contains a particular constructor?
12:37:07 <azz_> Philippa: so your suggestion is to not include the abstract "method" as part of the type class
12:37:17 <azz_> ?
12:37:20 <mauke> tusho: (notFollowedBy (char ')') has no effect
12:37:28 <mauke> tusho: 'comment' doesn't accept ) anyway
12:37:36 <tusho> mauke: No, it doesn't.
12:37:38 <pejo> cjs, how often was automatic implementation inheritance useful in your 10 years of OO?
12:37:42 <tusho> But parse "" ")" returns Right []
12:37:50 <tusho> And parse "" "aa)aa" returns Right [Enclose,Enclose]
12:37:52 <mauke> yes
12:37:53 <tusho> And I have no idea why (TM).
12:38:13 <mauke> because the input contained a valid 'underload', followed by garbage
12:38:22 <Philippa> azz_: it sounds like what you want is just a default, as cjs discussed
12:38:27 <mauke> parsec ignores trailing garbage
12:38:30 <Philippa> cjs: yeah, that's kinda my point :-)
12:38:43 <cjs> pejo: Not much. But I'd say it was more language issues than anything else. It works great in type classes.
12:38:44 <tusho> mauke: OK, and what should I do?
12:38:47 <EvilTerran> you have to specify "end of input" explicitly
12:38:48 <Philippa> mauke: yeah, eof-on-end if you don't want that
12:38:55 <mauke> tusho: underload = many command <* eof
12:39:01 <tusho> Aha. Thanks.
12:39:07 * tusho shall remember that
12:39:30 <tusho> <* isn't in scope though, is that one of dem fancy arrow thingies?
12:39:41 <EvilTerran> that's in Control.Applicative
12:39:57 <EvilTerran> but i don't think there's an Applicative instance for GenParser, so it all gets a bit annoying
12:40:03 <Euler_> > elem (B)  [A "a", B "b", C "c"] where data Foo = A String | B String | C String
12:40:04 <lambdabot>  Parse error at "where" (column 33)
12:40:09 <Deewiant> ?ty (<*)
12:40:10 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
12:40:17 <mauke> not too hard to write an instance, though
12:40:18 <EvilTerran> for monads, x <* y = do res <- x; y; return x
12:40:29 <EvilTerran> *return res
12:40:34 <azz_> btw, is it possible to define a class without member functions?
12:40:36 <cjs> Philippa: Certainly. Oddly enough (or perhaps not), it took doing a bunch of FP for me to really understand some of the beautiful things about Smalltalk.
12:40:42 <paczesiowa> azz_: yes
12:40:42 <mauke> azz_: yes
12:40:54 <azz_> hehe, thanks :)
12:41:29 <lisaAa> Hi guys, I'm at the end of beta test for my website and looking for feedback from internet savvy people. mind if I post url please?
12:41:50 <mauke> spam
12:41:59 <quicksilver> if it's about haskell or functional programming I'm sure we'll be fascinated.
12:42:02 <cjs> Anyway, I have solid proof that this stuff works. More or less by fiat, I made my ICFPC team this year use Haskell, and they're all loving it.
12:42:10 <paczesiowa> or at least written using happs
12:42:16 <quicksilver> cjs++ # enforcer
12:42:22 <ddarius> EvilTerran: There is one for parsec3, but it is easy enough to add an instance.
12:42:33 <cjs> quicksilver: Does that give me karma? :-)
12:42:40 <mauke> preflex: karma cjs
12:42:40 <preflex>  karma for cjs: 1
12:42:52 <Philippa> lisaAa: if it's not written in haskell or haskell-related then yeah, I think we do
12:43:08 <tusho> Philippa: actually, I'd like to see it
12:43:11 <tusho> because it's probably rubbish
12:43:27 <cjs> Bryan and several others were not so keen on Parsec, at first, but a day later, they were raving about it. :-)
12:43:49 * cjs lives for combinators now, as do all my friends.
12:44:17 <cjs> Anybody else doing the contest, BTW?
12:44:42 <ddarius> tusho: Then you can ask to have the URL privmsged to yourself (in privmsg)
12:44:52 <tusho> true
12:45:16 <quicksilver> tusho: I don't imagine it's rubbish. I imagine someone makes money merely by you visiting it.
12:45:22 <quicksilver> that's what most IRC-spam is about these deays.
12:45:23 <tusho> hehe
12:45:41 <quicksilver> either real money or status in some bizarre online PHP game.
12:45:52 <cjs> quicksilver: Spam? About making money? Say it isn't so!
12:46:44 <cjs> BTW, is anybody about to do some haddock for Parsec? It needs it.
12:47:46 <cjs> I suppose I could, if nobody else will step up. Though I only use it for "academic" stuff. Now once it uses ByteString....
12:48:03 <tusho> <quicksilver> either real money or status in some bizarre online PHP game.
12:48:07 <tusho> PHP? a bit too classy
12:48:11 <tusho> asp, probably
12:48:17 <ddarius> cjs: It's already there.
12:48:20 <ddarius> @hackage parsec
12:48:21 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/parsec
12:48:45 <cjs> Ah, ok. I'm just behind. I was using the ghc haddock.
12:49:38 <cjs> ddarius: Oh, that's nice.
12:49:53 <ddarius> The documentation is for parsec3, but much of it is the same (and in fact, much of it is copied from Daan's original reference page).
12:50:19 <cjs> Oh, hey, I was thinking, though: can we add something to Haddock to say that the documentation for the function is the source code?
12:50:52 <ddarius> cjs: Nowadays, you can have haddock generate links to the source.
12:51:05 <cjs> It's suprising (well, not to me, any more, but...) how often the source is an incredibly concise, clear and accurate description of what the function does.
12:51:37 <tusho> Gahahahaha. Who wants the link to that site that lisaAa was advertising?
12:51:38 <tusho> It's bad.
12:51:42 <tusho> (Privmsg.)
12:51:43 <cjs> Yeah, I'm not talking links, though; I'm saying have a "-- |" kinda thing that says, "just put the source right in the docs", so I don't have to click.
12:52:31 <Philippa> cjs: that, and where it isn't often it's because it's been refactored from a simple version that can be left in a comment. Which is always nifty
12:53:32 <cjs> Philippa: Hmm. I've seen that just today. I found myself removing "extract function" refactorings because they actually made the source harder to understand.
12:54:26 <cjs> I mean, I see what you're saying, but it's interesting to see attempts to be more clear ending up being both less clear and having more code. Like, sheesh.
12:56:10 <lisaAa> Thanks for the help guys anyways. Have a nice one :]
12:56:17 <cjs> Gah. I'm too tired to make sense.
12:57:31 <Philippa> cjs: yeah, sometimes things backfire. Really the refactorings I have in mind're partly for efficiency purposes
12:57:54 <Philippa> so the big, ugly version of the code has a number of significant differences - it's denotationally equivalent but by no means operationally
12:58:34 <azz_> FYI
12:59:15 <azz_> regarding my question a while ago
12:59:56 <azz_> typeclasses are not responding to my need
12:59:57 <azz_> s
13:00:09 <cjs> azz_: So tell me more.
13:00:21 <azz_> the thing is
13:00:22 <cjs> BTW, what language are you coming from?
13:00:48 <azz_> heh, haskell was the first programming language i formally learned
13:00:50 <azz_> :)
13:01:13 * cjs bricks azz_
13:01:26 <azz_> currently i'm a standard OO guy which is working on his msc project :)
13:01:31 <cjs> Oh, wait, "formally."
13:01:41 <azz_> heh
13:01:43 <plutonas> what is the difference between = and <- ???
13:01:49 <cjs> So you have years of PHP experience, then. :-)
13:01:50 <Zao> Quite a lot.
13:02:03 <azz_> Me?
13:02:03 <cjs> plutonas: Good question.
13:02:30 <azz_> ironically enough i've been developing in PHP for the past six months
13:02:43 <cjs> azz_: I'm sorry.
13:03:01 <Heffalump> plutonas: with =, the thing on the left gets the same type (or a more restricted one) as the thing on the right
13:03:03 <azz_> you kinda learn to enjoy it after a while
13:03:28 <Heffalump> with <- , the thing on the right has type m a where m is some Monad, and the thing on the left has type a (or something more restricted)
13:03:39 <azz_> (disclaimer: i'm talking about php 5.2 and use a web framework - i never ever touched raw PHP)
13:04:10 <plutonas> Heffalump: if i don't know about monads yet, should i leave understanding this for later?
13:04:17 <azz_> (i mean, PHP application coding from 0)
13:04:23 <plutonas> (for when i know monads i mean)
13:04:37 <cjs> plutonas: I'm not sure how to explain it, because it depends on your background, but the essential idea, for an imperative programmer, can be casually summed up as, "let x =" in a do block means, it can be run "whenever"; "a <- " in a do block means it has to happen before the stuff after it. (This is a *very* casual explanation.)
13:04:46 <Heffalump> plutonas: yes, I suggest you do
13:04:56 <Baughn> plutonas: Well, you need to at least understand the idea that "a monad is a box; <- picks values out of the box and lets you do things to them"
13:04:58 <azz_> fwiw i believe the wikibook on haskell has a nice chapter on monads
13:05:18 <Baughn> plutonas: With =, the thing on the left will be the /same/ thing as the one on the right
13:05:32 <Baughn> Modulo types, that is
13:05:53 <azz_> <- is assignment, = is definition
13:05:58 <Baughn> So they'Re not the same at all. <- removes something from a box; = does nothing whatsoever
13:06:24 <azz_> cjs: anyway, what we were talking about
13:06:27 <plutonas> hm, i see ok
13:06:49 <plutonas> i tihnk i get the main idea
13:07:00 <azz_> the effect i was trying to achieve with the typeclass was similar to inheritance
13:07:27 <Baughn> plutonas: Although, in reality (for IO, at least) you can'T remove anything from the box at all. What's actually happening is that you put functions /into/ the box, and the box has a button you can push to make it take a function, apply it to the contents, and get a new box. ;)
13:07:55 <azz_> but in haskell that would mean i would need some way to calculate the result from a value of that class
13:08:00 <plutonas> Baughn: now this last one completely confused me
13:08:16 <ddarius> plutonas: Take Heffalump's advice.
13:08:16 <cjs> azz_: Right. So, are you familiar with "duck typing" in Ruby?
13:08:20 <Baughn> plutonas: Ignore it, then. It's not important yet; read a monad tutorial or two later.
13:08:28 <tusho> AGH
13:08:31 <tusho> I HATE INTEGER VS INT
13:08:35 <tusho> I HATE IT WITH MY ENGER
13:08:37 <smg> warum?
13:08:38 <azz_> i do _not_ want to calculate the result, i basically want that to be a part of the value
13:08:48 <tusho> @hoogle genericLength
13:08:48 <lambdabot> Data.List.genericLength :: Num i => [b] -> i
13:08:52 <plutonas> ddarius: ?
13:08:53 <chrisdone> plutonas: and then write a monad tutorial
13:08:55 <azz_> as in... data X = X { v1 :: V1 ... }
13:09:07 <azz_> v2, v3, etc would come from the typeclass
13:09:14 <azz_> which seems impossible to do
13:09:19 <azz_> regarding duck typing
13:09:26 <plutonas> Baughn: ok, i'm still at the beginning of realworldhaskell, but i think i'll skip the rest and read some finished book
13:09:35 <azz_> i've heard of that but i do not know what it is
13:09:48 <plutonas> chapter 6 was way too messy
13:10:20 <Baughn> azz_: Duck typing? THat's just typing based on what methods you do implement, instead of an abstract type. "If it quacks like a duck.."
13:10:25 <Baughn> azz_: Haskell doesn't support it.
13:10:30 <azz_> heh :p
13:10:57 <cjs> Baughn: Really? My impression was that Haskell supports it perfectly, with static type checking.
13:11:28 <Baughn> cjs: No; you have to explicitly state that you're instancing a class, for your object to be considered a member of said class
13:11:35 <Baughn> cjs: With duck typing, you wouldn't need to do that
13:11:37 <cjs> I.e.: instance Duck Foo where quack = ...
13:12:03 <azz_> something like... if an object has a particular set of methods defined, it automatically becomes an instance of a class?
13:12:05 <cjs> Well, I suppose it depends on your definition of "duck typing."
13:12:08 <erikc> sure it does, make a typeclass that implements a 'dispatch' function, and your data comes with a map to map the string method argument to a function
13:12:11 <azz_> s/class/given class
13:12:19 <erikc> now you have a duck typing layer
13:12:20 <Baughn> azz_: Well, duck typing doesn't necessarily /have/ classes
13:12:28 <Baughn> erikc: ...
13:12:28 <azz_> i see
13:12:55 <Baughn> azz_: It's typing by comparing properties, instead of comparing names, if that helps
13:13:09 <azz_> yeah
13:13:22 <azz_> as you said "if it quacks it's a duck"
13:13:26 <cjs> Not in the sense of "inherit," no. What duck typing means, is that, if it implements a certain set of methods with certain semantics, you don't care what it is otherwise. Which is exacly what a Haskell type class is.
13:14:00 <Baughn> It might be a bit too hard to tell the difference in haskell. Let me try something else:
13:14:15 <Dr_Zooix> Hi all :)
13:14:19 <Baughn> In Python, you might have a class that implements a method "foo"
13:14:24 <cjs> (BTW, keep in mind I'm a long-time Ruby guy.)
13:14:44 <Baughn> Now, you have a subclass baz that obviously also implements foo; you also have a class bar that implements foo but /doesn't/ subclass the original class
13:14:47 <olsner> currying is hard in python
13:15:00 <Baughn> Under duck typing, both of them would be considered to be subclasses of the original class. Otherwise, not.
13:15:22 <Baughn> In haskell it's impossible to have two classes use the same method name, so it doesn't work here. ;)
13:15:57 <azz_> the language "believes" it's a subclass just by the name of the method?
13:16:05 <Baughn> Yes
13:16:10 <cjs> Baughn: I think I might disagree with that. I would tend to say that, under duck typing, both are things that respond to "foo" with the same semantics.
13:16:15 <Baughn> Although, "subclass" might not be the right word there
13:16:30 <Baughn> cjs: Yeah, thanks
13:16:35 <azz_> "implementation" perhaps?
13:16:42 <cjs> From the duck typing point of view, you don't care what subclasses what; that's irrelevant.
13:16:58 <Baughn> I just realized that. Can you tell I haven't worked with duck typing much? ;)
13:17:20 <cjs> No. But I'll take your word for it. :-)
13:17:21 <azz_> TBH that doesn't seem very useful :P
13:17:24 <plutonas> schme: ping
13:17:43 <Baughn> Anyway, in haskell the only way for a class to respond to a "message" from another class is if it explicitly subclasses it
13:18:07 <Baughn> Otherwise you aren't allowed to do so.. on a whole-class basis, at least.. so... well, I'm not sure the distinction makes sense anymore
13:18:15 <cjs> So, basically, the Haskell type class mechanism just formalizes this. "If you are an instance of Eq, you respond to (==) and (/=) with these specific semantics."
13:18:36 <cjs> Baughn: No. There is no "subclassing."
13:18:45 <azz_> haskell doesn't force any semantics afaict
13:18:51 <Baughn> azz_: Duck typing is popular in interpreted languages like haskell, primarily because they lack the type machinery to do anything /else/ easily
13:19:00 <azz_> (apart from the method signatures)
13:19:05 <Baughn> Er. like javascript.
13:19:27 <Baughn> Use duck typing, and an object becomes just a Map
13:19:44 <cjs> azz_: No, it doesn't force it. If you think about it, how can you? But an "instance Duck Bingo where quack =" is is declaration by the programmer that a Bingo quacks like a Duck.
13:20:55 <azz_> exactly, nothing stops you from implementing (==) as False or True for any given inputs
13:21:54 <azz_> but cjs
13:22:21 <Baughn> instance Eq a where a == b = False
13:22:22 <azz_> have you read what i said at 9:08
13:22:26 <cjs> So, in the end, being somewhat acquainted with Haskell, and knowing rather a fair amount about Ruby and its culture, I would say that type classes are just a way of "stating duck typing to the compiler" so it can (type)check it.
13:22:41 <dons> heh
13:22:56 <cjs> azz_: You need to give me a time zone. My current timestamp is 05:22. This being Tokyo and all.
13:22:58 <Baughn> Can you still call it duck typing if it's checked? -_-
13:23:03 <azz_> !
13:23:10 <cjs> Baughn: Interesting question.
13:23:17 <Baughn> And anyway, I can't see any useful way to distinguish duck and non-duck typing in haskell at all
13:23:18 <ddarius> "duck typing" doesn't require any correlation in the behavior of the methods
13:23:23 <Baughn> So it's a moot point, isn't it?
13:23:27 <azz_> sorry, i wasn't expecting that. :) i'm @ GMT
13:23:53 <ddarius> azz_: You should be expecting people to be in different timezones.
13:24:05 <cjs> azz_: Just think of me as living nine hours into your future. :-)
13:24:08 <Baughn> @localtime cjs
13:24:09 <lambdabot> Local time for cjs is Mon Jul 14 05:24:08
13:24:48 <ddarius> That said, presumably one would assume the most recent :08 time.
13:24:53 <azz_> hehe
13:26:30 <azz_> i'll rephrase what i said anyhow
13:26:50 <cjs> Well, it probably helps to pull back a bit, and look at this from a higher level. I did years of Java before abandoning it for Ruby. And then abandoned Ruby (more or less, perhaps somewhat less) for Haskell. So the static vs. dynamic thing has a few layers here.
13:27:52 <schme> plutonas: !!
13:27:55 <azz_> suppose two data types defined as records: data X = X { f1 :: t1, f2 :: t2 ... fn :: tn } and data Y = Y { g1 :: t1, g2 :: t2 ... gn :: tn }
13:28:05 <plutonas> schme: finally
13:28:06 <plutonas> :D
13:28:19 <plutonas> did you find the groupBy?
13:28:29 <azz_> and that half those functions are the exact same thing
13:28:53 <azz_> is there any way to avoid writing all those fields twice?
13:29:01 <cjs> azz_: Unn hmm?
13:29:18 <azz_> sorry?
13:29:28 <Baughn> azz_: data Z = {...}; data X = X { more :: Z}?
13:29:28 <schme> plutonas: Oh hey hey. It's on my laptop the source, so I can't really get it on the online. My wireless thingie is broken.   But the basic thing is that I use the accumulator for collecting up the list of lists.
13:29:45 <cjs> Well, did you consider that the X and Y value constructors should be two value constructors for a single type?
13:29:45 <schme> plutonas: and a stepper function that either appended to the last list, or started a new list.
13:29:48 <plutonas> schme: is it long?
13:29:51 <schme> plutonas: If that makes any sense what so ever.
13:29:57 <schme> plutonas: Not really . a couple of lines.
13:29:58 <plutonas> if it's 3-4 lines perhaps you can write it?
13:30:13 <azz_> cjs: actually it's what i'm leaning to
13:30:23 <azz_> s/it's/that's
13:30:35 <schme> plutonas: Hey good idea. I'll do that. Right now I needs to go make food though :)
13:30:45 <plutonas> schme: by the way i went back to stumpwm, at least until i'll have the time to test xmonad better
13:30:53 <plutonas> schme: no problem will be here for some more hours
13:31:05 <cjs> azz_: Oh, good, you seem to understand that. I'd like to paste an example, but hpaste.org seems down....
13:31:05 <plutonas> how do you say good apetite in swedish?
13:31:29 <Baughn> azz_: Also, remember that to alter a data structure, you have to copy the whole thing except the one field you change
13:31:34 <Baughn> This may or may not matter at all
13:31:53 <schme> plutonas: No idea. I don't think I've ever said that :) thanks though!
13:31:54 <azz_> cjs: the thing is.. i'm kind of stuck to the need of "emulating" an OO approach
13:32:27 <cjs> azz_: Can you give an example that's a bit more specific, with more details about what you want to do?
13:32:33 <dons> plutonas: you need to test xmonad?
13:32:36 <azz_> sure
13:32:45 <plutonas> dons: i did for 4 days
13:32:46 <azz_> i'll type it in a pastebin, just a sec
13:32:49 <dons> you mean experiement with it?
13:32:52 <cjs> I understand the feeling. There might be a solution for this. But there might not. I run into this regularly.
13:32:54 <Baughn> azz_: data Foo = Foo1 {...} | Foo2 {...} | Foo3 {...} <-- Get quite far with OO just with this, you do
13:32:58 <plutonas> but didn't have time to play with all the addons etc
13:33:09 <plutonas> and some things were not optimal, so i turned back for now
13:33:16 <plutonas> experiment yes
13:33:28 <dons> you should let us know what things you didn't like, on the mailing list.
13:33:35 <dons> since perhaps the defaults can be improved.
13:33:38 <dons> constant feedback helps
13:33:51 <plutonas> dons: well the most important thing is where to place the mod key
13:34:06 <dons> ok. so you want to rebind it to some other key?
13:34:13 <plutonas> because i like having ctrl where caps lock is, tab and shift are good there
13:34:17 <plutonas> alt is used for emacs
13:34:19 <dibblego> dons, my suggestion; create a vmware image that I can download and use xmonad right away to determine if I'd like to install and configure it for real
13:34:27 <dons> dibblego: that's a neat idea.
13:34:32 <plutonas> so there's only left the original ctrl position, and this is where i bound it
13:34:43 <plutonas> but it's very uncomfortable to use that key all the time
13:34:51 <dons> you can pick whatever key you want :)
13:35:05 <plutonas> dons: there are no other keys on my keyboard i can think of
13:35:10 <plutonas> dons: do you use emacs?
13:35:19 <dons> i use Alt, fwiw. with vim.
13:35:40 <plutonas> well i think that's the problem :)
13:35:51 <dons> there are emacs-like bindings though, and lots of emacs users.
13:35:55 <plutonas> as i need ctrl on a good position for emacs, and don't want to use alt for something else
13:36:01 <dons> so you could ask specifically on the list for what emacs people like
13:36:06 <cjs> Baughn: :-)
13:36:11 <plutonas> so there's only that option i can think of
13:36:11 <Saizan> plutonas: no "windows" or "menu" key on your keyboad? placed between alt and ctrl
13:36:19 <plutonas> Saizan: nope
13:36:32 <plutonas> but even if there was a key there it would still be uncomfortable
13:36:43 <plutonas> as the little left finger needs to go so far down
13:36:58 <Baughn> plutonas: You know you can get custom keyboards?
13:36:59 <plutonas> dons: will do when i get some times, probably the day after tomorrow i'll do it
13:37:00 <azz_> cjs: here's an example of what i'm trying to simulate with haskell
13:37:02 <azz_> http://pastebin.org/51072
13:37:21 <plutonas> optimum would be between ctrl and tab, but there is no key there :)
13:37:49 <dons> data Person = Person Gender DOB
13:37:57 <dons> data Gender = Male  | Female
13:38:18 <azz_> dons: that would require an oracle :)
13:38:39 <Saizan> man dob = Person Male dob\n woman dob = Person Female dob
13:38:42 <plutonas> dons: how many years and how much did you and sjanssen work with haskell before starting xmonad?
13:38:48 <dons> you could certainly implement a Person typeclass, of which the types Man, Woman are members
13:38:54 <cjs> azz_: Hm. That's an interesting one! A change from cars, anyway.
13:39:10 <dons> plutonas: sjanssen i think had about 1.5 years experience, i had about 7 years.
13:39:11 <azz_> i'm actually performing automatic conversion between what would be the language in the example and haskell programs
13:39:16 <Baughn> azz_: Hold it. What about polygamism? Or lesbian marriages?
13:39:21 <cjs> dons: what about the wife, husband thing?
13:39:28 <azz_> so i really need to stick to what's written
13:39:29 <azz_> hehe
13:39:35 <dons> i'm not sure what he wants to do with husband and wife.
13:39:39 <dons> how does he want to use them?
13:39:45 <dons> are they just data that derive Person ?
13:39:49 <azz_> maybe i'll link the Alloy model that that comes from
13:39:57 <Baughn> azz_: Also, why would you just make it spouses :: [Person]?
13:40:01 <Baughn> *wouldn't
13:40:02 <azz_> :D
13:40:03 <dons> heh
13:40:09 <azz_> big love
13:40:23 <cjs> This is parallel to my work in fact, where I keep going back and forth between an Option being a generic Instrument (as a Future) is, or not. Because an Option has a strike price....
13:40:26 <dons> ([Mistress], [Spouse])
13:40:37 <azz_> http://alloy.mit.edu/alloy4/tutorial/grandpa.als
13:41:01 <azz_> it's a rather different language from the usual
13:41:12 <azz_> as it is a specification language
13:41:40 <cjs> dons: 7 years! Does that stretch as far back as pre-monadic I/O?
13:41:47 <azz_> but you can consider that sigs are classes
13:41:53 <dons> cjs, no way. since 1999.
13:42:16 <azz_> and facts constrain possible values of those sigs (iow, they're invariants)
13:42:25 <cjs> dons: Well, still way more than me. :-)
13:42:29 <dons> haskell's always had monads as far as I'm concerned.
13:42:49 <Philippa> azz_: sigs're probably closely related to signatures in MLish module systems? You might be interested reading up on the relationship between those and type classes
13:43:09 <azz_> "lone Man" means that a Man may or may not be related to a value of the set of Persons
13:43:12 <dons> http://www.reddit.com/info/6rkvh/comments/
13:43:13 <lambdabot> Title: reddit.com: Implementing the State monad in JavaScript
13:43:45 <dons> in practice, wouldn't we just use data for these different values, and maybe a Person class to help overload common operations?
13:43:54 <cjs> But often in this type of OO stuff, especially in Ruby, but even in Java or whatever with typecasting, you pull "Persons" out of a list of whatever, figure out if it's a male or a female, and then make sure you only call "husband" or "wife" if it's right. (And if you don't, you explode.) Haskell does this the same way.
13:44:11 <azz_> Philippa: I don't know, but i'll check that out
13:44:35 <cjs> dons: I did pick up some older Haskell book (probably about '93 or so), and the IO examples were very interesting.
13:44:58 <Philippa> cjs: except Haskell has ways of doing so typesafely :-)
13:45:18 <cjs> Philippa: not really, no.
13:45:32 <cjs> I mean, yeah, you can, but it becomes pretty painful.
13:45:34 <azz_> in alloy all values come from a "class" (in the set-theoretical sense) of all atoms, then you define sigs which are subsets of that class
13:45:54 <cjs> Like, you can't keep a set of Instruments; you have to have separate sets of Options and Futures.
13:46:07 <azz_> each field of each sig is a relation (again, as in set theory)
13:46:18 <Baughn> cjs: What I don't see is why you need to have a distinct "wife" or "husband" accessor, instead of just "spouse"
13:46:20 <azz_> to other sigs, relations, set, whatever
13:46:34 <Baughn> You /already know/ whether your person is male or female, so what does it matter?
13:46:45 <noteventime> I'm having some trouble with Cabal, I can't use it since it complains about some unknown symbol (The name is mangled, but contains _TextziPrettyPrintziHughesPJ_TextBeside_con_info). According to ghc-pkg pretty-1.0.0.0 is installed
13:46:50 <azz_> Baughn: you'll have to ask that to the author of the specification
13:46:54 <azz_> :)
13:47:03 <Baughn> Not to mention the possibility that someone will change the laws on you later, allowing homosexual marriage. That just happened here in norway and, yep, there have been some software issues. :P
13:47:14 <dons> noteventime: could you recompile it against pretty? or perhaps it's installed as user, and can't be found?
13:47:19 <dcoutts> noteventime: and you've only got that package installed the once? not a global and a per-user version?
13:47:35 <cjs> Baughn: Right. It's not such a good example for that. But think of an Instrument, which has a name and whatever, and you can get quotes on the price at time t. Well, both an Option and a Future have an expiry date. But only an option has a strike price.
13:47:49 <dons> gwern: seen http://www.ninebynine.org/RDFNotes/Swish/Intro.html
13:47:50 <lambdabot> Title: Swish: Semantic Web Inference Scripting in Haskell
13:47:56 <noteventime> dcoutts + dons: It seems to be installed by default (from the Ubuntu package), so I guess it should be global
13:48:04 <dons> gwern: also http://www.yar.nu/macke/hspark/
13:48:06 <lambdabot> Title: HSpark
13:48:13 <Baughn> cjs: And then only one has it. I was objecting to two objects having different names for what is essentially the same field.
13:48:18 <tibbe> can I delete one line of text written to stdout somehow (so I can update a line in place)?
13:48:44 <dons> tibbe: emitting ^h is sometimes used for this
13:48:44 <Baughn> tibbe: If you haven't printed newline, you can print \b a lot. Or was it \d? Or \h? Well, something..
13:48:50 <cjs> Baughn: Sure, and a fair objection. But there are situations, and not unusual ones, where the same problem comes back.
13:48:56 <dons> gwern: actually, this looks really nice, http://www.yar.nu/macke/hspark/
13:48:57 <lambdabot> Title: HSpark
13:49:05 <Baughn> tibbe: For more complex stuff, look at ncurses/hscurses
13:49:06 <dons> "a particle system compiler. It is intended as a tool to encourage reusability of code and formulas between different particle systems and at the same time provide aggressive space/time optimization"
13:49:51 <tibbe> dons: without outputting the newline?
13:50:05 <cjs> tibbe: Or better yet, you can print \r.
13:50:25 <tibbe> cjs: and overwrite? what if the new text is shorter?
13:50:41 <Baughn> tibbe: Spaces
13:50:49 <tibbe> Baughn: ah
13:50:58 <cjs> tibbe: Damn, you're bringing up all the classic problems from about 1982. :-) Personally, I just print extra spaces.
13:51:13 <cjs> If you want to be really clever, you can keep track of how many chars you wrote.....
13:51:15 <tibbe> cjs: haha, yes, I don't do this very often
13:51:21 <Baughn> tibbe: You should, of course, check the COLUMNS environment variable
13:51:31 <Baughn> tibbe: But really, for anything at all complex, grab curses
13:51:40 <cjs> Actually, stty will give you more accurate info....
13:51:54 <Baughn> That's assuming you /have/ stty
13:52:05 <tibbe> Baughn: yeah, it's for ICFP so I don't want any extra libs
13:52:13 <cjs> Or whatever it is stty uses to get that info. I forget.
13:52:28 <cjs> No doubt it's some weird BSD shit that doesn't exist in SysV....
13:52:59 <cjs> Damn, this is  such a blast from the past I almost wish I had an emulator for an Ann Arbor Ambassador.
13:53:28 <schme> plutonas: Where do you want it pasted?
13:53:51 <plutonas> schme: don't care, hpaste would do i guess
13:55:03 <plutonas> or you could paste it to a pm
13:55:32 <schme> plutonas: http://hpaste.org/8903
13:56:07 <plutonas> schme: tack sa mycket
13:56:09 <noteventime> Hmm, .hi files aren't also object files, are they?
13:56:15 <schme> plutonas: Så lite så :)
13:56:15 * EvilTerran detects use of "last"
13:56:40 <schme> EvilTerran: So?
13:56:47 <EvilTerran> also appending to the end of lists
13:56:51 <cjs> So, _The Haskell Road to Logic, Maths and Programming_ just arrived in the mail the other day, and I note from a reference the bibliography that haskell.org is actually run by some group (cabal? :-)) known as "The Haskell Team."
13:56:52 <schme> EvilTerran: So?
13:56:57 <EvilTerran> these are both very bad for your algorithm complexity
13:56:57 <plutonas> hm, what does the $ sign do?
13:57:12 <schme> EvilTerran: It does make it easier to understand what is going on though, now doesn't it?
13:57:12 <EvilTerran> both O(n) on the length of the list
13:57:27 <schme> EvilTerran: performance is not an issue.
13:57:55 <EvilTerran> fine
13:58:16 <EvilTerran> i just think it's worth mentioning
13:58:23 <EvilTerran> we don't want any newbies getting into bad habits
13:58:28 <dcoutts> cjs: there is no Haskell Cabal. That's the first rule of the Haskell Cabal.
13:58:36 <schme> It's just an exercise from real world haskell, which it seems the channel here agreed on it was impossible to solve.
13:58:46 <schme> EvilTerran: Heh. No one would write real code like that :)
13:58:48 <cjs> alt.rec.haskell. :-)
13:59:02 <EvilTerran> schme, ah, do you have a link to the exercise?
13:59:15 <schme> EvilTerran: Or reimplement groupBy anyway ;)
13:59:26 <Saizan> schme: actually we gave you hint to solve it with foldr :)
13:59:45 <EvilTerran> ... is it just groupBy? i can't work out what it's meant to be doing
13:59:51 <schme> Saizan: Uh no. You did not.
13:59:57 <schme> Saizan: You must be thinking of someone else.
14:00:07 <ddarius> @where hsu
14:00:07 <lambdabot> I know nothing about hsu.
14:00:09 <schme> EvilTerran: just groupBy, using fold. That's the quiz.
14:00:17 <Quadrescence> Could someone explain how to deal with variables/data that changes in Haskell (e.g., a variable, in the traditional sense, that says how much money I have)? I am just beginning to learn. :|
14:00:21 <plutonas> i'd never think of that
14:00:35 <TadazaneImagawa> Jikanomori tanba
14:00:36 <schme> plutonas: It's the same one would do in lisp really. abusing the accumulator :)
14:00:36 <cjs> But I was kinda thinking, the ICFPC is a bit easy this year (not that this is a bad thing--it's a very *good* thing as far as my team is concerned), but I had an idea for a good contest, and I'm wondering if haskell.org might be an "organization" capable of stepping up to run it one year.
14:00:38 <EvilTerran> ?src groupBy
14:00:39 <lambdabot> groupBy _  []       =  []
14:00:39 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
14:00:39 <lambdabot>     where (ys,zs) = span (eq x) xs
14:00:42 <EvilTerran> hm
14:00:55 <TadazaneImagawa> SHIKA
14:00:56 <plutonas> schme: i was just trying to use foldr
14:01:02 <schme> plutonas: ok.
14:01:10 <plutonas> anyway
14:01:24 <NaotadaNabeshima> TadazaneImagawa: What the hell are you talking about?
14:01:33 <TadazaneImagawa> dunno
14:01:51 <NaotadaNabeshima> *Sigh*
14:02:00 <schme> plutonas: Well as I said I wrote this maybe a month ago. If people here suggest foldr maybe it is much better. :)
14:02:15 <NaotadaNabeshima> i Kingo odani
14:02:16 <EvilTerran> schme, i think you can do away with all of the fiddling with the ends of lists with foldr
14:02:57 <TadazaneImagawa> Oh ok so you know exactly the what samurai charged the tokugawa camp in the osaka campaign NaotadaNabeshima?
14:03:02 <schme> EvilTerran: Could be :)
14:03:24 <EvilTerran> TadazaneImagawa, i must say, that's mighty off-topic
14:03:29 <schme> EvilTerran: folding backwards is very backwards to my head though (:
14:03:35 <cjs> Quadrescence: you make a new copy, and pass that into wherever it's going.
14:03:50 <NaotadaNabeshima> TadazaneImagawa: you're off topic and yes i do, it was Sanada Yukimura, Now get back on topic.
14:03:57 <Quadrescence> Hummm.
14:04:31 <Saizan> > let step eq x [] = [[x]]; step eq x (xs:rest) | x `eq` head xs = (x:xs):rest | otherwise = [x]:xs:rest in foldr (step (==)) [] [1,2,3,3,5,5,5,6,7]
14:04:33 <lambdabot>  [[1],[2],[3,3],[5,5,5],[6],[7]]
14:04:54 <EvilTerran> groupBy eq = foldr f [] where f x [] = [[x]]; f x (g:gs) | x `eq` head g = (x:g):gs | otherwise = [[x]]:g:gs
14:05:01 <cjs> Quadrescence: the classic example is keeping state. You start with an initial state, read, say, a mesasge from the network. You then make a new state which is different from the existing state in some way, and then call yourself ("you" being the message processing routine) with the new state. I can give you a code example if you like.
14:05:05 <TadazaneImagawa> I suck on pussy hairs even evilTerrains moms(wich taste like Vodka)
14:05:08 <EvilTerran> er, that last [[x]] should be [x]
14:05:11 <EvilTerran> !where ops
14:05:17 <EvilTerran> ?where ops
14:05:18 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
14:05:18 <NaotadaNabeshima> What the hell
14:05:19 <EvilTerran> even
14:05:22 --- mode: ChanServ set +o Saizan
14:05:25 <schme> Saizan: right. that is much better. I wish someone would have suggested me to use that back when I was doing it ;)
14:05:26 <EvilTerran> goodbye :)
14:05:29 <cjs> What's with the long names? Sheesh.
14:05:31 --- mode: Saizan set +b *!*=tadazane@76.226.217.*
14:05:31 --- kick: TadazaneImagawa was kicked by Saizan (Saizan)
14:05:42 <EvilTerran> Saizan++
14:05:46 <dcoutts> @arr!
14:05:46 <lambdabot> Aye Aye Cap'n
14:05:49 <azz_> heh
14:05:52 --- mode: Saizan set -o Saizan
14:05:55 <NaotadaNabeshima> EvilTerran:you just saw what he just typed about yo'ure mom?
14:06:03 <NaotadaNabeshima> *you're
14:06:15 <azz_> OT trolls are scary
14:06:16 <EvilTerran> NaotadaNabeshima, yes, i did. hence the op call.
14:06:41 <Quadrescence> cjs: A code example would be appreciated. The switch from procedural to functional is proving not so easy. :]
14:06:45 <EvilTerran> don't worry, i'm very hard to offend, especially in a channel where offensive behaviour isn't tolerated :)_
14:06:48 <NaotadaNabeshima> What the hell was that guys problem(perverted)
14:06:55 <cjs> Urusai mono ga irunndaro.
14:07:08 <EvilTerran> NaotadaNabeshima, but anyway, that's also off-topic. let's get back to talking about Haskell in #haskell, shall we? :P
14:07:09 <cjs> Quadrescence: I understand completely. Hang on.
14:07:36 <NaotadaNabeshima> K
14:07:41 <EvilTerran> schme, I don't think of foldr as folding backwards
14:07:49 <schme> EvilTerran: :(
14:07:55 <schme> EvilTerran: But I think of you folding backwards ;)
14:08:09 <noteventime> dcoutts + dons: I managed to fix it. I realised I was trying to use a darcs version of cabal
14:08:34 <Peaker> NaotadaNabeshima: funny you should fix yo'ure mom to you're mom
14:08:36 <EvilTerran> schme, it's just an expression of a common recursion pattern, as i see it
14:08:50 <schme> EvilTerran: That's cool :)
14:08:57 <NaotadaNabeshima> Peaker:how exactly is that funny?
14:09:00 <plutonas> schme: by the way did you go through the whole book?
14:09:03 <schme> EvilTerran: I haven't hacked enough haskell for that.
14:09:06 <schme> plutonas: Not yet.
14:09:12 <Peaker> NaotadaNabeshima: you're is short-hand for "you are"
14:09:16 <plutonas> schme: i have done until chapt 6
14:09:20 <plutonas> but i think it's enough
14:09:23 <plutonas> 6 was very bad
14:09:31 <schme> plutonas: One gets insanly bugged out by it every other chapter. 'cause it's disorganised, and one has no idea what file to put the stuff in :)
14:09:41 <NaotadaNabeshima> I know that i just wanted to shorten it out.
14:09:46 <zenhacker_rouan> hi everyone
14:10:13 <dcoutts> noteventime: that would not be it, it doesn't do anything different
14:10:16 <zenhacker_rouan> can someone help a new haskeler with somw simple code
14:10:40 <zenhacker_rouan> its pasted at http://hpaste.org/8904#a0
14:10:48 <noteventime> dcoutts: Well, getting the latest stable tarbal fixed it
14:11:15 <zenhacker_rouan> it just wont compile, and i can't figure out why
14:11:16 <EvilTerran> schme, i guess i think about it as, if you have a function "foo [] = {whatever}; foo (x:xs) = {expression featuring x and (foo xs)}", you can re-write that to "foo = foldr (\x y -> {expression featuring x and y}) {whatever}"
14:11:17 <zenhacker_rouan> :)
14:11:33 <Peaker> NaotadaNabeshima: "you are mom" doesn't make much sense
14:11:34 <BONUS> im explaining to someone about the state monad. do you guys think its correct to say that the state monad is "a way to combine stateful computations"
14:11:39 <schme> EvilTerran: That's cool. I'll make a note of that.
14:11:51 <EvilTerran> just replacing (foo xs) with (y) in the combining function
14:11:56 <plutonas> schme: i agree... i think i'll try the other wiki-tutorial thing you posted
14:12:02 <azz_> peaker: unless of course he is reminding his mother of that
14:12:02 <EvilTerran> that's what i mean by "it expresses a common recursion pattern"
14:12:15 <Peaker> azz_: even then it lacks an "a' :)
14:12:19 <dons> here's a sketch of an idea for a new haskell logo, http://galois.com/~dons/images/haskell-strong.png
14:12:20 <BONUS> yeah basically any function that goes over a list one by one and then produces something out of that can be represented as a fold
14:12:23 <Peaker> BONUS: I think that's not a complete - its a way to describe stateful computations functionally
14:12:38 <BONUS> hmm
14:12:42 <Peaker> BONUS: "bind" can be considered the combiner, but then what is "return"?
14:12:45 <Peaker> BONUS: get, and put?
14:12:51 <schme> EvilTerran: Now you're in my howm notes :)
14:12:56 <BONUS> ah yeah
14:12:57 <EvilTerran> yay
14:13:03 <schme> plutonas: Or just grab that there craft book.. :)
14:13:04 <jpcooper> dons, which mythical being has a lighting bolt in his hand?
14:13:08 <BONUS> you could say that bind, put and return all make statful computations
14:13:16 <azz_> i didn't read what he wrote :p
14:13:17 <BONUS> dons: is haskell getting a new logo?
14:13:30 <plutonas> schme: thats already ordered, but will take 3 more weeks to arrive
14:13:43 <dons> jpcooper: thor, i'd imagine? or one of the swedish gods.
14:13:45 <schme> plutonas: (it's free on the piratebay)
14:13:47 <jpcooper> I thought of thor
14:13:50 <jpcooper> but thor has a hammer
14:13:57 <lucca> zoos
14:14:01 <plutonas> schme: do they send me the book in paper form from piratebay?
14:14:02 <EvilTerran> zeus is often depicted as being able to throw lightning
14:14:06 <cjs> Quadrescence: Ok. http://hpaste.org/8905 is a rather simplified example of a typical (at least for me) processing loop.
14:14:09 <plutonas> would be good
14:14:11 <EvilTerran> and, in cartoons, as holding a lightning bolt
14:14:13 <schme> plutonas: No but a bad quality pdf :)
14:14:19 <jpcooper> Odin has a spear
14:14:27 <plutonas> would be a start while waiting though
14:14:30 <cjs> Note it doesn't check for eof or anything, but I'm guessing you can figure out how to add that.
14:14:37 <jpcooper> yes Zeus :)
14:14:40 <dons> yeah, odin. that's a good idea.
14:14:45 <cjs> The key is the building of the new state, and the tail recursion.
14:14:54 <dons> i like the idea of referencing some scandinavian mythology here.
14:15:57 <HideyoriToyotomi> whats the topic for haskell this time?
14:16:19 <tusho> HideyoriToyotomi: you're one of those trolls
14:16:20 <tusho> aren't you
14:16:29 <tusho> similar name
14:16:36 <HideyoriToyotomi> no im NaotadaNabeshima
14:16:44 <dons> tusho: oh you think a bot?
14:16:50 <HideyoriToyotomi> i was the guy in here a few minutes ago
14:17:07 <tusho> okay
14:17:09 <tusho> dons: dunno
14:17:22 <tusho> dons: though we've got that one that goes
14:17:24 <dons> don't we have an @turing test in lambdabot for htis?
14:17:27 <tusho> I have a question, what is it, I HAVE A QUESTION
14:17:35 <HideyoriToyotomi> tusho: fuck evilterran im going after ur moms pussy this time.
14:17:36 <tusho> , yes what is the question, I HAVE A QUESITON DAMN YOU ASDHUIARWUHIUWARHIAUWRHIU!HIU!IHU!HIOU!OHIU2h178123612783162378123681273687we678qwibeioenoneone
14:17:38 <tusho> etc
14:17:43 <tusho> that's WP-Gast
14:17:48 <HideyoriToyotomi> Tusho:you see that
14:17:50 <ddarius> What's with the penchant for putting random pieces of non-syntax into Haskell logos?
14:17:54 <tusho> WP=wikipedia, it seems to be designed for #wikipedia
14:18:02 <tusho> <HideyoriToyotomi> tusho: fuck evilterran im going after ur moms pussy this time.
14:18:05 <tusho> thanks?
14:18:09 <HideyoriToyotomi> tusho:that troll is back
14:18:10 <dons> ddarius: polymorphic, typed, funcitonal, monadic.
14:18:23 <tusho> HideyoriToyotomi: nobody's said that line
14:18:24 <tusho> but you
14:19:12 <DoYouHaveAnyJi> WOW
14:19:24 --- mode: ChanServ set +o Saizan
14:19:31 <DoYouHaveAnyJi> what on earth was that for
14:19:36 <tusho> Saizan: kickban HideyoriToyotomi
14:19:38 <tusho> for great justice
14:19:46 --- mode: Saizan set +b *!*@76.226.217.251
14:20:02 <tusho> that won't work Saizan
14:20:07 <tusho> 76.226.217.251 is the realname
14:20:11 <tusho> that's how mibbit passes on the real name
14:20:12 <tusho> err
14:20:13 <tusho> the ip
14:20:44 <Saizan> well i perfected the ban i've done before
14:21:15 --- mode: Saizan set -o Saizan
14:22:09 <ddarius> "When you design user interfaces, it's a good idea to keep two principles in mind:
14:22:09 <ddarius>    1. Users don't have the manual, and if they did, they wouldn't read it.
14:22:09 <ddarius>    2. In fact, users can't read anything, and if they could, they wouldn't want to."
14:22:24 <tusho> ddarius: "3. Also, you have no users."
14:23:12 <dons> that's exactly what we followed for xmonad. actually, just step 3.
14:23:19 <ddarius> tusho: I wish.
14:24:04 <jeffwheeler> Is there any interest in getting other languages to work in Yi?
14:24:31 <jeffwheeler> It seems like an incredible editor to me, and it does already support LaTeX and C; I think adding new languages would be fun, if possible.
14:24:57 <tusho> i don't think yi is being rapidly developed
14:25:01 <tusho> someone correct me if i'm wrong
14:25:02 <mofmog> wow, my RPNEvaluator can now load files and words
14:25:18 <jeffwheeler> tusho: I get emails pretty regularly regarding new commits
14:26:28 <jeffwheeler> They seem to be actively developing it, but their mailing list (http://groups.google.com/group/yi-devel) seems mostly composed of code changes, not discussion.
14:26:30 <lambdabot> Title: yi.devel | Google Groups
14:27:36 <schme> Hoh. Yi has an emacs frontend? That's cool. Is it complete so I can just run all my elisp apps in it?
14:27:40 <dons> yeah, jyp is very active on this, i think.
14:28:05 <jeffwheeler> schme: no it doesn't. It has a GTK and VTY front-end, although it can emulate emacs behavior.
14:28:09 <dons> i should get back into yi dev
14:28:28 <schme> jeffwheeler: there exist vi, vim, emacs, mg, nano, joe and ee frontends to Yi     <-- from the website.
14:28:46 <ddarius> dons: Yes!  Bring back the vi!
14:28:57 <jeffwheeler> Yi seems extremely clean; it's small enough for me (a Haskell beginner) to read through much of the code, and still very well designed already.
14:29:07 <Zao> The vim frontend could use some work :)
14:29:13 <schme> jeffwheeler: But right. The emacs behaviour emulation, does it emulate all of elisp or what?
14:29:18 <dons> ddarius: did you ever use the original release? when it was a vim ? :)
14:29:27 <jeffwheeler> schme: read the about section
14:29:47 <jeffwheeler> schme: I don't see what you're reading.
14:29:54 <jeffwheeler> (http://www.haskell.org/haskellwiki/Yi)
14:29:55 <lambdabot> Title: Yi - HaskellWiki
14:29:58 <ddarius> dons: No, because I ran Windows at the time and the plugin system didn't work (easily?) with it.
14:30:02 <schme> jeffwheeler: http://www.cse.unsw.edu.au/~dons/yi.html
14:30:03 <lambdabot> Title: yi text editor
14:30:08 <dons> ah right
14:30:11 <schme> jeffwheeler: That's what I'm reading.
14:30:42 <jeffwheeler> schme: ah, that was from 0.1.0, a long time back. The Haskell Wiki page is the up-to-date one, as far as I know.
14:30:55 <schme> jeffwheeler: Ok.
14:31:06 <ddarius> dons: That said, unless I can use it as an almost drop in replacement for vim (which isn't too hard, as I don't really use much of vim's features), I'm not too interested in using it.
14:31:37 <dons> agreed.
14:31:40 <schme> jeffwheeler: Right. ok. So the emacs emulation in it, does it let me run all my elisp apps?
14:31:54 <schme> I'll just grab it and check.
14:32:03 <jeffwheeler> schme: as far as I know, no. It just lets you have Emacs-like behavior (in other words, keybindings and such).
14:32:25 <schme> jeffwheeler: Oh.
14:32:27 <schme> :(
14:32:33 <schme> That's too bad.
14:32:54 <jeffwheeler> schme: I'm glad to get rid of Elisp. :)
14:33:14 <schme> elisp is not the greatest lisp in the world, no.
14:33:26 <schme> But with ffi it is turning out quite useful for a lot of things, for me anyway :)
14:33:28 <jeffwheeler> But there is tons of stuff written for it, you're right.
14:33:43 <schme> Yes. Most of 'em suck. Only elisp apps worth using are my own ;)
14:33:46 <jeffwheeler> Which is why I think Yi deserves more attention than it's getting.
14:33:52 <jeffwheeler> :D
14:33:58 * cjs must switch to Yi sooner rather than later.
14:34:27 <jeffwheeler> I still haven't figured out how to use most of its features (especially for Haskell), but just browsing the code has kept me busy for a while.
14:34:30 <schme> working on a nice thing to manage my mp3 player from emacs now. So nice it will be to not use gnomad2!  and an rtorrent emacs UI. It will also be very much nice.
14:34:59 <jeffwheeler> schme: please, never try to port an MP3 player to Yi. :)
14:35:16 <jeffwheeler> Let's keep it a code-editor.
14:35:19 <schme> jeffwheeler: Well obviously no, if it's just a text editor :)
14:35:46 <schme> I'll still grab it and see if I can run it here in an emacs buffer ;)
14:36:34 <pgavin> @hoogle a -> String
14:36:36 <lambdabot> Prelude.show :: Show a => a -> String
14:36:36 <lambdabot> Text.Show.show :: Show a => a -> String
14:36:36 <lambdabot> Data.Generics.Text.gshow :: Data a => a -> String
14:36:55 <pgavin> @hoogle a -> IO ()
14:36:56 <lambdabot> Prelude.print :: Show a => a -> IO ()
14:36:56 <lambdabot> System.IO.print :: Show a => a -> IO ()
14:36:56 <lambdabot> Data.HashTable.delete :: HashTable key val -> key -> IO ()
14:37:37 <dons> so i'm thinking of using something like this as a logo on my blog, when it's moved http://galois.com/~dons/images/fist-logo.png
14:38:00 <Philippa> jeffwheeler: it's not such a big problem. I mean, we half-expect people to end up wanting to bolt on things like debugging tools
14:38:34 <chr1s> dons: lol
14:38:55 <ddarius> dons: Take out the "tattoos" add back in the arrows (but black) and call it a day.
14:39:05 <dons> it's like the opposite of all the wussy lambda logos out there.
14:39:08 <dons> ddarius: interesting.
14:39:24 <dons> a fist holding some function arrows.
14:39:46 <jeffwheeler> Philippa: I thought that was the point of http://www.haskell.org/haskellwiki/HIDE, although that now appears orphaned. (It wasn't when I last looked.)
14:39:48 <lambdabot> Title: HIDE - HaskellWiki
14:39:54 <Peaker> that logo is like a violent gang's logo, planning a military coup
14:40:06 <dons> Peaker: exactly.
14:40:33 <chr1s> dons: something completely different, but what would you recommend:
14:40:45 <chr1s> we wrote a binding to the Sphinx full text search library.
14:40:55 <chr1s> it's still very unfinished, but usable though.
14:41:09 <dons> cool!
14:41:26 <chr1s> what would be the best thing to do: release it on hackage, unfinished, or polish it up and release it once it's done.
14:41:34 <jeffwheeler> Hmm, I can't seem to get the Yi darcs to update any more; I don't use Darcs often (only when I first installed this, and a few other times), but it seems to be failing to download the URI: darcs get --partial http://code.haskell.org/yi/
14:41:35 <lambdabot> Title: Index of /yi
14:41:42 <dons> you could start by releasing 0.0 on hackage, and getting some feedback
14:41:47 <chr1s> it's pretty cool, as it is extremely fast full text searching.
14:41:52 <dons> likely people will help with .cabal files and haddocks
14:41:55 <chr1s> sure. we'll try to do that.
14:41:57 <dons> then you can put the full version out once its done
14:42:59 <chr1s> ok. I was a bit worried about releasing "unfinished" stuff, but on the other hand: if other people find it interesting and can contribute, why not.
14:44:00 <chr1s> but anyway, good work with the fist logo ;)
14:44:05 <chr1s> resistance is futile.
14:44:37 <FunctorSalad_> aren't Sphinxes those scary cats :o
14:44:40 <chr1s> all your lambdas are belong to us.
14:44:57 <dogbite> chr1s: lolcats
14:45:00 <chr1s> @google sphinx full text
14:45:02 <lambdabot> http://www.sphinxsearch.com/
14:45:02 <lambdabot> Title: Sphinx - Free open-source SQL full-text search engine
14:45:20 <chr1s> we wrote a binding to the xml indexer (it also does xml, not only sql)
14:45:42 <chr1s> or, to be honest, our binding is independent of the type used.
14:45:58 <chr1s> but our plan is to generate the xml from our HAppS state.
14:46:32 <chr1s> anyhow, I'm off now, thanks for the advice.
14:49:29 <Eelis> isn't it a bit weird that with -XFlexibleContexts, ghc accepts "f :: Functor m => Int -> Monad m => m Int" but not "g :: Functor m => Monad m => Int" ? (yes, i know "g :: (Functor m, Monad m) => m Int" works, but that's beside the point :-) )
14:49:50 <BONUS> shit
14:49:51 <dogmaT> dons: What is the license of those images? I was thinking of using it in some future presentation as a shock at the begining.
14:49:52 <BONUS> why cant you do
14:50:10 <BONUS> let (_, x) = f where f = ((), 100)
14:50:16 <BONUS> i mean
14:50:30 <BONUS> let (_, x) = f in x where f = ((), 100)
14:52:03 <EvilTerran> BONUS, because you can't use "where" except at the end of a binding or case/of
14:52:33 <EvilTerran> the stuff before the "in" is bindings, the let/in as a whole isn't a binding
14:53:20 <BONUS> i didnt mean that just generally
14:53:24 <BONUS> pattern matching agains (_, blah)
14:53:34 <Peaker> I wish let/where were united somehow
14:53:48 <BONUS> > let (_, x) = ((), 5) in x
14:53:50 <lambdabot>  5
14:53:56 <BONUS> wait hmm
14:54:24 <dons> dogmaT: oh, these are not for distribution yet. they're just drafts based on images of unknown copyright from the web.
14:54:31 <dons> i'll do a public domain version
14:54:42 <BONUS> oh nvm i was making a stupid mistake
14:55:18 <dons> dogmaT: but a great idea. i'm giving a talk on tuesday, and i think it might use this as a shock opening slide :)
14:56:12 <ddarius> dons: Your Galois talk?
14:56:18 <dons> yeah
14:56:27 <pejo> dons, what's the talk about?
14:56:43 <dons> ?google galois tech talks
14:56:45 <lambdabot> http://www.nabble.com/Galois-Tech-Talks:-Stream-Fusion-for-Haskell-Arrays-td18413502.html
14:56:45 <lambdabot> Title: Nabble - Haskell - Haskell-Cafe - Galois Tech Talks: Stream Fusion for Haskell A ...
14:56:51 <dons> google++
14:57:03 <ddarius> dons: Will it be all that "shocking" to that audience?
14:57:23 <dons> no, but sets a nice tone.
14:59:30 <dogmaT> dons: Interesting talk, but out of hand for me:-). Will there be some record of it?
14:59:48 <dons> slides will go up, yep.
15:00:08 <dogmaT> dons: Have to do, thanks.
15:07:10 <chessguy> @src on
15:07:11 <lambdabot> (*) `on` f = \x y -> f x * f y
15:07:37 <chessguy> @type sortBy (comparing `on` snd)
15:07:38 <lambdabot>     Occurs check: cannot construct the infinite type: b = b -> a
15:07:38 <lambdabot>     Probable cause: `comparing' is applied to too few arguments
15:07:38 <lambdabot>     In the first argument of `on', namely `comparing'
15:07:58 <vixey> :t sortBy (comparing snd)
15:07:59 <lambdabot> forall a b. (Ord b) => [(a, b)] -> [(a, b)]
15:08:01 <vixey> :t sortBy (compare `on` snd)
15:08:03 <lambdabot> forall a b. (Ord b) => [(a, b)] -> [(a, b)]
15:08:09 <chessguy> heh
15:08:24 <vixey> I just noticed yesterday,
15:08:42 <vixey> f `on` (p . q . r) = f `on` p `on` q `on` r
15:10:33 <ddarius> vixey: And f `on` id = f
15:17:32 <audreyt> @pl \x -> x - s
15:17:32 <lambdabot> subtract s
15:18:27 <gwern> dons: correct me if I'm wrong, but isn't there no source available for hspark?
15:18:28 <lambdabot> gwern: You have 1 new message. '/msg lambdabot @messages' to read it.
15:18:35 <gwern> I don't see anything, just a dead cvs link
15:19:24 <catalyst> Not sure if this is the right place to ask this, but I'm attempting to use Network.Socket with a stream connection (on GHC 6.8.3) and recv() appears to be a blocking call - is there a way to set it to non-blocking, or some function I can use to determine when there's data waiting?
15:19:45 <gwern> @messages
15:19:46 <lambdabot> twifkak said 2h 28m 43s ago: i wrote you a (multi-line) answer; /lastlog it
15:23:37 <ddarius> vixey: So we have:  (`on` id) = id and (`on` (f . g)) = (`on` g) . (`on` f)
15:23:52 <vixey> oh true
15:24:04 <vixey> wait must it flip
15:24:27 <vixey> ok I see
15:26:27 <dons> heya audreyt
15:27:44 <dobblego> dons, if you make such a vmware image, I'll be sure to try it; I am too pushed for time to fiddle around with installing xmonad to decide if I'd like to use it
15:28:00 <dobblego> dons, I may even make it myself if time becomes available
15:28:14 <ddarius> A VMWare image seems like more of a hassle than installing xmonad...
15:28:29 <dobblego> ddarius, how? pressing 'Run' is pretty easy
15:28:37 <Zao> Aren't applicances rather standalone?
15:29:20 <dons> dobblego: cabal install xmonad -- it's not too hard :)
15:29:54 <Zao> dons: That'd require you to have a working Haskell environment, including cabal-install and whatnot.
15:29:55 <dobblego> dons, plus dependencies
15:35:20 <gwern> dons: well, I've emailed the hspark guy. will see what he says
15:39:16 <dons> if you don't have a working cabal-install, what are you doing in here? :)
15:39:38 <dobblego> getting around to it :)
15:39:43 <dobblego> I shift machines a lot
15:40:51 <tusho> http://hpaste.org/8906
15:40:55 <tusho> can anyone help? :)
15:42:46 <tusho> :)
15:45:27 <tusho> :)
15:48:05 <dons> audreyt: fwiw, i have to comment out the dependency on 'sdlmain' on arch linux    to get timepiece working.
15:48:08 <tusho> i'm sure it's pretty simple
15:50:16 <ddarius> newtype O f g a = O { unO :: f (g a) }; class ContraFunctor f where cofmap :: (a -> b) -> f b -> f a; instance (ContraFunctor f, Functor g) => ContraFunctor (O f g) where cofmap f = O . cofmap (fmap f) . unO; newtype Flip b a = Flip { unFlip :: a -> b }; instance ContraFunctor (Flip b) where cofmap f = Flip . (. f) . unFlip; newtype Pair a = Pair { unPair :: (a,a) }; instance Functor Pair where fmap f = Pair . f***f . unPair; on = flip on' where on' f = un
15:50:16 <ddarius> curry . (. Pair) . unFlip . unO . cofmap f
15:51:22 <vixey> o_o ...
15:51:37 <ddarius> s/uncurry/curry
15:52:06 <vixey> Oh!
15:52:07 <ddarius> Ideally one would like to say, on = flip cofmap
15:53:22 <ddarius> One could add an Iso class and get something almost that simple possibly
15:56:12 <audreyt> dons: you mean
15:56:14 <audreyt> Extra-Libraries:    SDLmain
15:56:15 <audreyt> ?
15:56:27 <audreyt> strange, OSX/Freebsd/Win32 has no such problem.
15:57:53 <dons> yeah, SDLmain
15:58:05 <vixey> I figured out my HOAS problem
15:58:06 <dons> doesn't exist as a C lib on my system.
15:58:11 <vixey> I wasn't seeing the forest for the trees
15:58:29 <int0x0c> Is there a good matrix library for haskell?
15:59:01 <dons> int0x0c: hmatrix is one, blas is another.
15:59:14 <dons> go to hackage.haskell.org and poke around the numerics/data structures librraies
15:59:56 <int0x0c> dons, thanks
16:07:22 <vixey> oh this sucks
16:07:32 <vixey> I think I have to add IO to my monad
16:07:58 <ddarius> Why?
16:08:22 <vixey> well I want to use IO
16:08:23 <EvilTerran> vixey, couldn't you wrap it and only expose the functionality you need?
16:09:23 <hackage> Uploaded to hackage: TimePiece 0.0.2
16:17:21 <vixey> How do you use ST and IO together?
16:17:54 <mauke> @hoogle ST a -> IO a
16:17:54 <lambdabot> No matches, try a more general search
16:18:00 <vixey> :T stToIO
16:18:15 <Cale> vixey: mostly just with runST
16:18:34 <Cale> vixey: Use runST to get a pure computation, then use that pure computation inside IO
16:18:42 <Cale> But yeah, there are other ways to go.
16:18:59 <tusho> anyone want to help with http://hpaste.org/8906? :)
16:20:38 <tusho> i'd give you eternal love and gratitude
16:20:58 <vixey> oh I see how it works
16:25:37 <dons> BONUS_: was this you?
16:25:39 <dons>  http://forums.somethingawful.com/showthread.php?threadid=2841145&pagenumber=6#post346173552
16:25:40 <lambdabot> Title: Want to Learn Haskell? - The Something Awful Forums, http://tinyurl.com/5ns5lx
16:25:42 <dons> nice work if so.
16:25:45 <roconnor> I wonder if I should start the ICFP contest
16:25:46 <vixey> actually I don't understand it at all
16:25:54 <vixey> Why would you ever use stToIO?
16:26:04 <tusho> roconnor: too late.
16:26:07 <tusho> i'd say
16:26:23 <roconnor> tusho: hmm
16:26:30 <dons> interesting thread in general http://forums.somethingawful.com/showthread.php?threadid=2841145&userid=0&perpage=40&pagenumber=1
16:26:31 <lambdabot> Title: Want to Learn Haskell? - The Something Awful Forums, http://tinyurl.com/686q4w
16:26:33 <tusho> roconnor: ais523 has been working on it since the contest began
16:26:36 <tusho> and he's still hammering away
16:26:46 <tusho> also, he's doing it in C, and has had to do heavy compiler magick for optimization
16:26:51 <tusho> to get it working acceptably
16:26:52 <mauke> heh
16:26:59 <tusho> i don't really think haskell would be suited
16:27:03 <mauke> hahaha
16:27:06 <tusho> !unsafeHaskell#, maybe
16:27:07 <roconnor> oh, I'm sure GHC will give me free magic
16:27:43 <roconnor> Is it like last year where people switched to C and things didn't get any faster for them?
16:27:59 <mauke> tusho: do you know what the F in ICFP stands for?
16:27:59 <tusho> i don't think so
16:28:03 <tusho> mauke: yes
16:28:08 <tusho> and they seem to be totally ignoring it
16:28:17 <tusho> people have picked them out for it in #icfp-contest
16:29:03 <mauke> ah
16:29:52 <vixey> I think I need ioSTtoIO
16:30:03 <roconnor> @type ioSTtoIO
16:30:04 <lambdabot> Not in scope: `ioSTtoIO'
16:30:19 <tusho> vixey: what type
16:31:16 <roconnor> this contest reminds me of that racing contest from a few years ago
16:32:02 <audreyt> dons: check 0.0.3?
16:32:26 <BONUS_> dons
16:32:27 <BONUS_> hehe
16:32:40 <BONUS_> who linked you to that thread
16:32:56 <BONUS_> yeah thats me btw
16:33:23 <chrisdone> dons: interesting thread
16:33:33 <chrisdone> BONUS_: you are OP?
16:33:44 <BONUS_> no, i did the last post
16:33:46 <BONUS_> about the state monad
16:33:51 <BONUS_> on page 6
16:34:10 <chrisdone> ah, ok
16:35:17 <TomMD> BONUS_: I call that a blog entry more than a forum post.
16:35:38 <BONUS_> yeah well its a thread where we post stuff like that so other people learn
16:36:00 <BONUS_> gotta design myself a blog though one of these days
16:36:24 <tusho> TomMD: Well that's a shame 'cause uh it's a forum post?
16:37:43 <TomMD> tusho: I think you miss my meaning.  Its length and quality deserves to be somewhere lasting, such as a blog (which typically is more timeless than a forum).
16:37:45 <chrisdone> “This new-fangled functional programming thing has been coming up more and more”, heh. I've been into functional languages for ages so it's fascinating to see that it's this new weird idea to experienced programmers
16:38:14 <tusho> TomMD: *shrug*
16:38:40 <lament> ah, this modern age, when blogs are lasting!
16:38:44 <BONUS_> TomMD yeah thats why i intend on publishing it on a proper site soon :)
16:38:50 <TomMD> :-)
16:39:05 <BONUS_> or maybe i'll typeset it in LaTeX and print it out hehe
16:39:06 <lament> forums come and go, but blogs persist... for years!
16:39:11 <QtPlatypus> chrisdone: An overnight success normally takes years.
16:39:44 <dobblego> how does an overnight success take years?
16:39:47 <vixey> Maybe I have to use IORefs instead of STRefs
16:40:23 <tusho> But yeah: web logs? Ah yes, where you put a list of links you've found on the web on your front page, most recent first.
16:40:24 <QtPlatypus> dobblego: Normally the overnight success comes after years of perperation.
16:40:31 <tusho> A good overview of things as they are at the time!
16:40:39 <tusho> Archives? Why would you want to see archives of a log of current links?!
16:40:41 <vixey> I can freeze and thaw things in and out of ST, but I was trying to avoid that
16:40:42 <TomMD> Perhaps all my Haskell programs are just too primitive, but I've been able to avoid the need for IORefs for anything production.
16:40:56 <TomMD> Of coarse, things are modulated to heck.
16:40:59 <chrisdone> hi cale
16:41:04 <Cale> hi
16:42:40 <vixey> I will just thaw things.. it will stop IO seeping out into every part of my program
16:43:03 <vixey> oh it actually will be more effecient as well
16:43:54 <dons> good use cases for IORefs are pretty hard to come by
16:44:08 <dons> TomMD: if anything, i'd have thought low level stuff would be more likely to reveal IORefs
16:44:22 <BONUS> dons: just curious, where did you get the link to that forum post of mine?
16:44:37 <dons> BONUS: it's on reddit.
16:44:42 <dons> someone posted it.
16:44:43 <BONUS> ah
16:44:45 <BONUS> kewl
16:44:49 <dons> you should get a blog :)
16:45:02 <TomMD> lol, I think he'll be hearing that a lot.
16:45:11 <dons> Cale: what do you reckon of http://galois.com/~dons/images/fist-logo.png
16:45:18 <dons> it
16:45:19 <BONUS> hehe yeah been putting it off hehe, gotta get busy on a visual design
16:45:26 <dons> 's a sketch of a logo i want to use on my blog
16:45:33 <tusho> BONUS: heh i have a visual design for my blog
16:45:37 <tusho> but procrastinating implementing it
16:45:37 <mar77a-> hm
16:45:40 <BONUS> hehe
16:45:41 <mar77a-> looks like an inverted A and Y
16:45:42 <mar77a-> tbh
16:45:54 <mar77a-> you should work on those "for all" and lambda
16:45:56 <BONUS> oh man if someone got those as tattoos
16:45:57 <mar77a-> imo
16:45:58 <tusho> http://hpaste.org/8906 anyone wanna help? :)
16:45:58 <vixey> that's a lambda
16:46:05 <mar77a-> yeah i got it after 5 seconds
16:46:06 <dons> mar77a-: cheers.
16:46:18 <mar77a-> but i first i thought it looked like it was vertically flipped
16:46:21 <mar77a-> cheers as in..?
16:46:23 <Pseudonym> Haskell: The programming language of choice for discriminating fascists.
16:46:24 <dons> polymorphic, typed, functional, monadic.
16:46:26 <tusho> dons: it portrays haskell as an aggressive force and counters our "warm fuzzy things" movement
16:46:29 <tusho> make it a warm fuzzy thing.
16:46:44 <dons> all the logos for the past 20 years have been too warm and fuzzy
16:46:49 <Cale> heh
16:46:50 <dons> i blame the lisp alien
16:46:53 <Cale> or nondescript
16:46:55 <tusho> dons: because it SELLS, my friend
16:46:58 <tusho> don't you want MONEYS?
16:46:59 <dons> or entirely nondescript
16:47:04 <tusho> _Plural_
16:47:04 <Pseudonym> We need an animal logo.
16:47:05 <Cale> Let's put another lambda inside a circle!
16:47:11 <Cale> We'll colour this one blue!
16:47:11 <Pseudonym> Actually... Prometheus.
16:47:14 <Pseudonym> Stealing fire fromt he gods.
16:47:17 <dons> good thinking, Cale!
16:47:20 <Pseudonym> That's a good metaphor.
16:47:23 <mauke> suave lisp space toad
16:47:37 <tusho> Haskell's logo should be a little fuzzball.
16:47:53 <tusho> With '>>=' on his tummy. It will win the hearts of 4-year-old programmers everywhere.
16:47:56 <dons> Pseudonym: so my general tone is "getting things done, now, in haskell". also encouraging revolution.
16:48:03 <BONUS> that logo on haskell.org is a bit too busy imho
16:48:06 <dons> so in that context, i think a more aggressive, earthy logo is appropriate
16:48:16 <lament> haskell.org logo is pretty much the worst ever
16:48:23 <Pseudonym> So perhaps something industrial-revolution and art deco.
16:48:33 <dons> ddarius suggested something based on Odin's spear or Thor's hammer and lightning
16:48:40 <BONUS> how about like a metal plate with >>= pressed in
16:48:46 <dons> Pseudonym: right. or 1930s communist propaganda :)
16:48:50 <Pseudonym> :-)
16:48:56 <BONUS> i really love the new mercurial logo
16:49:00 <tusho> I like fuzzy logos, maybe it's just me
16:49:01 <Cale> BONUS: and the indentation filled with steak!
16:49:06 <BONUS> haha
16:49:06 <dons> there's a new mercurial logo?
16:49:10 <mauke> monads. haskell nomads.
16:49:12 <BONUS> yeah its awesome
16:49:17 <BONUS> http://www.selenic.com/hg-logo/logo-droplets-200.png
16:49:20 <dons> oh huh.
16:49:22 <tusho> aww
16:49:24 <tusho> it looks like :P
16:49:25 <Pseudonym> Actually, I like the image of Daedalus.  He helped create the Minotaur, then helped create a labyrinth to keep it in.  He was the problem _and_ the solution.
16:49:26 <dons> i liked the old one
16:49:35 <tusho> dons: what, 'Hg' in a crap font?
16:49:35 <BONUS> haha i havent noticed the :P
16:49:43 <dons> tusho: hmm, no.
16:49:49 <dons> ah sorry. mercury.. :)
16:50:04 <dons> i never use mercurial , i'd forgotten what it was :)
16:50:12 <BONUS> this is the old mercurial logo http://pvergain.files.wordpress.com/2007/07/mercurial-logo1.png
16:50:14 <dons> http://www.cs.mu.oz.au/research/mercury/
16:50:16 <BONUS> it made me puke
16:50:17 <lambdabot> Title: The Mercury Project: Introduction
16:50:26 <BONUS> i rly like mercurial :]
16:50:38 <lament> BONUS: it's not as bad as the haskell logo :(
16:50:40 * Pseudonym likes mercurial too
16:50:44 * tusho liek git
16:50:47 <BONUS> yeah lol
16:50:51 <tusho> i liek it with my wub.
16:50:52 <Pseudonym> It's git without the condescension.
16:51:01 <dons> maybe haskell.org could run a logo contest
16:51:03 <tusho> *git* is *condescending*?
16:51:09 <dons> $100 bucks to the winner, from the SoC fund.
16:51:11 <BONUS> dons that would be awesome
16:51:26 <Pseudonym> tusho: Anything linus does is condescending.
16:51:29 <lament> BONUS: on the other hand, it's not as good as the darcs logo :)
16:51:29 <dons> get some proper designers
16:51:40 <BONUS> the mercurial logo contest had no monetary prize or anything
16:51:43 <tusho> Pseudonym: Thin skin much?
16:51:46 <BONUS> and it still got a ton of submissions
16:51:54 <lament> the problem with logo contests is that you get a bunch of wonderful entries and then some idiot picks the worst
16:51:58 <Pseudonym> tusho: Who, me?
16:51:59 <BONUS> who's in charge of the haskell logo and stuff anyway
16:52:01 <lament> which is pretty much what happened to wikipedia
16:52:06 <dons> BONUS: no one.
16:52:08 <Pseudonym> Hardly.
16:52:12 <TomMD> BONUS: You, now. ;-)
16:52:16 <BONUS> lol
16:52:34 <lament> wikipedia and the london olympics
16:52:36 <Pseudonym> See, I think that Prometheus bringing a firey lambda from the gods is a good image.
16:52:39 <lament> show that contests don't work
16:52:48 <BONUS> did you guys know that "git status" is not a read only operation
16:53:08 <TomMD> I figured it would report your system specs to Microsoft.
16:53:10 <BONUS> thats pretty much a very big "what the crap"
16:53:15 <dobblego> those gits never did control their side-effects
16:53:18 <tusho> 'git status' EATS YOUR SOUL AND BRAINS
16:55:17 <mauke> “For Haskell Nomads, see Monad (functional programming).”
16:55:22 <mauke> http://en.wikipedia.org/wiki/Nomad_(disambiguation)
16:55:24 <BONUS> haha
16:55:50 <chrisdone> expert programmers
16:56:12 <mar77a-> reminds me of pythong
16:56:26 <roconnor> I wonder how I can get netcat to work without buffering
16:56:26 <tusho> pythong?
16:57:11 <Baughn> roconnor: "Without buffering"?
16:57:36 <roconnor> when using netcat someone is doing line buffering
16:57:40 <roconnor> maybe netcate
16:57:44 <roconnor> maybe my shell
16:58:01 <tusho> roconnor: Your terminal.
16:58:01 <Baughn> Your shell does do that
16:58:02 <roconnor> I want to play directly with the ICFP sample server
16:58:08 <tusho> Baughn: No, his terminal does.
16:58:08 <Baughn> Or possibly the terminal. I was never very clear on that
16:58:14 <roconnor> oh
16:58:17 <roconnor> my terminal!
16:58:17 <tusho> roconnor: It's an "stty" thing.
16:58:20 <tusho> Anyway, roconnor
16:58:23 <tusho> just sed \n to ;
16:58:25 <tusho> or whatever
16:58:57 <tusho> no?
16:59:17 <catalyst> Is Network.Socket supposed to be blocking on recv?
16:59:50 <catalyst> (on windows, GHC version 6.8.3)
16:59:51 <roconnor> that sed command is too advanced for me to know. :)
17:00:24 <mauke> perl -pe 'y/\n/;/'
17:02:07 <tusho> mauke++
17:02:58 <roconnor> hmm
17:03:02 <roconnor> why doesn't this work
17:03:17 <roconnor> perl -pe 'y/\n/;/' | nc localhost 8888 > /dev/null
17:03:22 <mauke> buffering
17:03:31 * roconnor grumbles
17:03:44 <mauke> perl -pe 'BEGIN{$|=1}y/\n/;/'
17:04:24 <roconnor> whoa
17:04:39 <roconnor> oh
17:04:42 <roconnor> my rover bounces
17:05:09 <roconnor> mauke++
17:05:10 <tusho> bump
17:05:15 <vixey> tr '\n' ;      # ?
17:05:20 <tusho> roconnor: and me for coming up with the idea :<
17:05:22 <vixey> tr '\n' ';'      # oops
17:05:22 <roconnor> that seems like it was harder than it ought to have been
17:05:27 <tusho> vixey: pretty much, yes
17:05:29 <tusho> except
17:05:30 <tusho> "\n"
17:05:37 <tusho> and
17:05:39 <tusho> that's buffered.
17:05:41 <mauke> "\n" is "n"
17:05:45 <roconnor> tusho++
17:05:52 <tusho> yaey
17:05:54 <tusho> @karma tusho
17:05:54 <vixey> what is the BEGIN{$|=1} ?
17:05:54 <lambdabot> You have a karma of 1
17:05:56 <tusho> @karma ehird
17:05:56 <lambdabot> ehird has a karma of 0
17:06:00 <tusho> shucks
17:06:05 <tusho> ehird++ ehird++ ehird++ ehird++ ehird++ ehird++ ehird++ ehird++ ehird++ ehird++ ehird++ ehird++ ehird++ ehird++ ehird++ ehird++ ehird++ ehird++ ehird++ ehird++ ehird++ ehird++ ehird++ ehird++ ehird++ ehird++ ehird++ ehird++ ehird++ ehird++ ehird++ ehird++ ehird++ ehird++ ehird++ ehird++ ehird++ ehird++ ehird++ ehird++ ehird++
17:06:08 <tusho> @karma ehird
17:06:08 <lambdabot> ehird has a karma of 41
17:06:11 <tusho> better,.
17:08:00 <EvilTerran> blimmeh
17:08:57 <roconnor> weeee
17:09:06 <roconnor> nasa should drive the rovers by hand
17:09:12 <tusho> roconnor: hahaha
17:09:24 <hackage> Uploaded to hackage: TimePiece 0.0.3
17:12:11 <vixey> subtract these get that = foldr delete (get that) these
17:12:11 <vixey>  where delete x list = filter (/= x) list
17:12:16 <vixey> doesn't already exist does it ?
17:12:32 <mauke> :t (\\)
17:12:48 <lambdabot> thread killed
17:12:51 <BONUS> delete also exists
17:12:52 <BONUS> imho
17:12:53 <vixey> problem with \\ is it doesn't remove duplicates
17:12:57 <roconnor> > sequence [["","a","b"],["","l","r"]]
17:13:10 <lambdabot>  [["",""],["","l"],["","r"],["a",""],["a","l"],["a","r"],["b",""],["b","l"],[...
17:13:16 <BONUS> how about you just do nub and then \\
17:13:34 <vixey> BONUS: I've already written a working bit of code that does what I want
17:13:35 <roconnor> > map concat $ sequence [["","a","b"],["","l","r"]]
17:13:36 <lambdabot>  ["","l","r","a","al","ar","b","bl","br"]
17:13:51 <roconnor> > sort $ map concat $ sequence [["","a","b"],["","l","r"]]
17:13:53 <lambdabot>  ["","a","al","ar","b","bl","br","l","r"]
17:14:25 <roconnor> > sortBy (`on` length) $ map concat $ sequence [["","a","b"],["","l","r"]]
17:14:26 <lambdabot>  Couldn't match expected type `b -> b -> c'
17:14:45 <roconnor> > sortBy (compare `on` length) $ map concat $ sequence [["","a","b"],["","l","r"]]
17:14:46 <lambdabot>  ["","l","r","a","b","al","ar","bl","br"]
17:16:19 <dobblego> map concat? join?
17:17:30 <roconnor> > sortBy (compare `on` length) $ join $ sequence [["","a","b"],["","l","r"]]
17:17:32 <lambdabot>  ["","","","","","","l","r","a","a","l","a","r","b","b","l","b","r"]
17:17:48 <roconnor> > sortBy (compare `on` length) $ map join $ sequence [["","a","b"],["","l","r"]]
17:17:50 <lambdabot>  ["","l","r","a","b","al","ar","bl","br"]
17:18:21 <dobblego> actually, I was thinking of bind
17:19:41 <tusho> http://hpaste.org/8906 plleeeease someone help?
17:20:47 <roconnor> > (=<<) $ sequence [["","a","b"],["","l","r"]]
17:20:48 <lambdabot>  Couldn't match expected type `a -> a1' against inferred type `[a2]'
17:20:56 <tusho> :(
17:25:31 <roconnor> I don't really see a performance issue with this contest by reading the task.
17:25:41 <TSC> Thank you to whoever fixed cvs.haskell.org over the weekend (:
17:25:49 <roconnor> I don't see why Haskell would be particularly slow.
17:26:17 <roconnor> espcially if you use STM and concurrency to read the telemetry in one thread.
17:26:38 <tusho> roconnor: *g* You shoulda seen the problems ais523 is having
17:27:03 <roconnor> tusho: how can I find out what his problems are?
17:27:10 <roconnor> I don't doubt it
17:27:20 <tusho> roconnor: He'll be online tomorrow. Ask him. :p
17:28:11 <roconnor> tusho: how do you know ais523 is having troubles?
17:28:29 <tusho> roconnor: because he's talked about it in #esoteric
17:28:39 <tusho> and asked me & others quite a few questions
17:28:41 <tusho> along the way
17:28:48 <roconnor> ok
17:29:11 <roconnor> ... switching to C would make STM programming more difficult.
17:29:16 <roconnor> :)
17:29:23 <tusho> *g
17:29:34 <roconnor> I guess locking might not be too hard in this case
17:31:37 <Korollary> I don't think it ever was the case that in ICFP any particular language was severly handicapped.
17:32:14 <tusho> Korollary: Yep, well, it's different now apparently :|
17:33:23 <roconnor> tusho: you are basing this on one report from one person?
17:33:49 <lilachaze> roconnor: STM is overkill for this. i'm just using a couple of Chans and it's no problem...
17:33:54 <tusho> roconnor: no, i've seen a lot of talk in #icfp-contest
17:34:07 <roconnor> oh okay
17:34:12 <ddarius> roconnor: Statistically significant samples are for losers.
17:34:33 <roconnor> lilachaze: you are using Haskell?
17:34:36 <lilachaze> yep
17:34:39 <roconnor> lilachaze: any preformance problems?
17:34:45 <lilachaze> not so far
17:34:49 <roconnor> :D
17:34:51 <roconnor> sold
17:34:56 <lilachaze> though turning off TCP_NODELAY was a pain
17:35:05 <lilachaze> Network.Socket does not make that easy.
17:35:08 <roconnor> I can imagine that
17:35:17 <Korollary> I wondered why they didn't use UDP like real multiplayer games
17:35:38 <lilachaze> I wonder why they didn't use stdin/stdout like real local programs
17:35:41 <mauke> setSocketOption sock NoDelay 1
17:35:42 <roconnor> The Haskell socket interface badly need to be rewritten
17:35:44 <mauke> ?
17:36:09 <roconnor> lilachaze: that seems like a good question.
17:36:27 <Korollary> it's not a local program
17:36:44 <mauke> Korollary: so?
17:37:01 <Korollary> eh?
17:37:19 <lilachaze> mauke: that's fine if you've got a socket. which Network.connectTo does not give you.
17:37:27 <lilachaze> mauke: the upshot is you need to reimplement Network.connectTo.
17:37:31 <mauke> lilachaze: oh, ouch
17:37:50 <lilachaze> good old view-source-copy-paste did the trick :)
17:38:19 <lilachaze> Korollary: i'm reasonably confident that the only hostname parameter my rover will be given is 'localhost' :)
17:38:30 <ddarius> Korollary can't counteract that logic.
17:38:58 <vixey> > let f x True = True ; f x False = False in f undefined True
17:38:59 <lambdabot>  True
17:39:43 <roconnor> lilachaze: you are not using the Network.Socket interface?
17:39:44 <mauke> :t [flip const, const id]
17:39:45 <lambdabot> forall b a. [b -> a -> a]
17:39:46 <lilachaze> > undefined && False
17:39:48 <lambdabot>  Exception: Prelude.undefined
17:39:58 <lilachaze> > False && undefined
17:40:00 <lambdabot>  False
17:40:06 <vixey> > let f x True = True ; f = const in f undefined True
17:40:08 <lambdabot>  1:22-30
17:40:08 <lambdabot>     In the expression:
17:40:08 <lambdabot>         let
17:40:08 <lambdabot>           f x True = True
17:40:08 <lambdabot>        ...
17:40:15 <vixey>     Equations for `f' have different numbers of arguments
17:40:23 <vixey> why don't it just add them ?
17:40:35 <lilachaze> roconnor: yes, i'm using Network.Socket
17:40:37 <vixey> f = const  --> f g1 g2 = const g1 g2
17:41:46 <lilachaze> vixey: i've often wondered that myself. probably something to do with lifting of various things.
17:41:57 <vixey> what is lifting?
17:42:05 <roconnor> lilachaze: okay, then it shouldn't be too hard to set NoDelay.
17:42:06 <macron_> lilachaze: does setting TCP_NODELAY really make a difference? Using ocaml here and gonna have to setsockopt in C so would rather not if i don't have to!
17:42:41 <lilachaze> roconnor: well, just connecting to a given hostname and port with Network.Socket is a non-trivial affair
17:42:41 <T-Cell> > group [Nothing,Nothing,Just 1.4,Just 3.2,Just 4.2] --how can group by a data constructor? that is, to yield [[Nothing,Nothing],[Just 1.4,Just 3.2,Just 4.2]]
17:42:43 <lambdabot>  [[Nothing,Nothing],[Just 1.4],[Just 3.2],[Just 4.2]]
17:42:43 <roconnor> unlike trying to set a the timeout. *grumbles about the impossibility of doing that in haskell*
17:43:04 <roconnor> lilachaze: :) Fair enough.  It probably takes 4 or 5 commands. :P
17:43:08 <vixey> > groupBy (maybe True (const False)) [Nothing,Nothing,Just 1.4,Just 3.2,Just 4.2]
17:43:09 <lambdabot>  Couldn't match expected type `Maybe a -> Bool'
17:43:11 <lilachaze> macron_: well, it ought to reduce latency, but i've not tested
17:43:20 <vixey> > groupBy (\x -> case x of Nothing -> True ; _ -> False) [Nothing,Nothing,Just 1.4,Just 3.2,Just 4.2]
17:43:21 <lambdabot>  Couldn't match expected type `Maybe t -> Bool'
17:44:04 <lilachaze> roconnor: yeah, that's not too bad, but they're 5 functions i've not heard of before, and i don't think i'd have worked it out had i not read the source of Network.connectTo.
17:44:05 <roconnor> <lilachaze> roconnor: STM is overkill for this. i'm just using a couple of Chans and it's no problem...
17:44:15 <vixey> > groupBy ((==)`on`(maybe True (const False))) [Nothing,Nothing,Just 1.4,Just 3.2,Just 4.2]
17:44:16 <lambdabot>  [[Nothing,Nothing],[Just 1.4,Just 3.2,Just 4.2]]
17:44:27 <roconnor> lilachaze: I was thinking STM to atomically update the state of the rover based on telemetry.
17:44:36 <vixey> > partition (maybe True (const False)) [Nothing,Nothing,Just 1.4,Just 3.2,Just 4.2]
17:44:38 <lambdabot>  ([Nothing,Nothing],[Just 1.4,Just 3.2,Just 4.2])
17:45:42 <lilachaze> roconnor: still seems a bit overkill :)
17:45:46 <roconnor> :)
17:45:50 <roconnor> could be
17:48:11 <mattr__> does anyone have a good 'naming/coding' convention for little adts they write in haskell>
17:48:11 <mattr__> ?
17:48:30 <dons> hmm. how little?
17:48:36 <mattr__> I often write a new data type, a few constructor functions and a few other functions over the type
17:48:43 <EvilTerran> if I've only got one constructor, i tend to give it the same name as the type
17:48:54 <mattr__> 2 constructors, 5 functions
17:48:56 <mattr__> that sort of size
17:49:04 <EvilTerran> and, if a constructor has only one argument, i tend to make the accessor for it be the same name with a lowercase initial
17:49:05 <mattr__> not worth another module usually, but sometomes
17:49:07 <vixey> you just name them depending on what they are
17:49:12 <EvilTerran> so, for a newtype:
17:49:13 <dons> sometimes I write: newtype T a = T { unT :: a } -- for example
17:49:20 <dons> which is an extension of EvilTerran's rule
17:49:25 <EvilTerran> newtype Foo a = Foo { foo :: a } -- or whatever
17:49:53 <mattr__> nice
17:50:05 <mattr__> T and unT I like
17:50:22 <mattr__> for example, I have a nameSupply ADT
17:50:23 <T-Cell> I guess I must have chosen a bad example, groupBy ((==) `on` (maybe True (const False))) works fine for grouping by the type Maybe, but not an arbitrary data constructor.
17:50:29 * vixey looks for a fun way to implement pattern matching
17:50:57 <mattr__> http://hpaste.org/8908
17:51:15 <mattr__> and this was my best attempt, but it is ungainly
17:51:18 <vixey> class IndexedConstructors where constructorIndex :: a -> Integer
17:51:19 <vixey> oops
17:51:21 <vixey> class IndexedConstructors a where constructorIndex :: a -> Integer
17:51:40 <mattr__> and doesn't match what the libraries tend to do
17:51:52 <vixey> instance IndexedConstructors (Maybe a) where constructorIndex Nothing = 0 ; constructorIndex (Just _) = 1
17:52:08 <mattr__> should I just use qualified imports to do this?
17:52:09 <vixey> T-Cell: Yuo can do stuff like that and I think Data.Generic automates this
17:52:30 <vixey> or at least gives you the tool to automate it
17:52:49 <dafra> dons: just saw the video of your presentation on Xmonad. Great stuff! What do you use to run  continuous integration ?
17:52:56 <T-Cell> I'll look into it, thanks vixey
17:53:33 <dafra> or maybe everyone builds on his own box ...
18:03:28 <chrisdone> man this is so fun: http://img514.imageshack.us/img514/9206/algosxh9.png
18:03:48 <dons> dafra: " continuous integration" ?
18:04:01 <vixey> chrisdone: Why don't you feed the programs source code into the program?
18:04:04 <dafra> the tool that actually runs the build
18:04:10 <dafra> in a centralized server
18:04:20 <vixey> I would like to see that
18:04:46 <vixey> (also some bias for longer words rather than common words would be nice)
18:05:19 <dafra> who runs the tests when a patch is submitted ?
18:06:17 <chrisdone> vixey: http://img525.imageshack.us/img525/9571/cloudsba1.png
18:06:59 <vixey> that's pretty cool but did you filter out operators ?
18:07:10 <vixey> I want >>= huge it the center :p
18:07:15 <chrisdone> hahaha
18:07:30 <chrisdone> yeah it filters for only letters. sec I'll try it without
18:07:41 <vixey> How are you laying out these tiles?
18:07:53 <vixey> It's more advanced that just rectangels
18:08:12 <vixey> or is it ?
18:08:17 <chrisdone> it's actually just rectangles indeed
18:09:40 <chrisdone> it places words largest first, and when placing a word tries to put it around the largest one. if it can't do that it tries the smaller one that came after it, etc
18:09:57 <chrisdone> algo2 just prefers putting it around a word closer to the centre :)
18:12:17 <chrisdone> oh dear, haha: http://img504.imageshack.us/img504/9844/operatorsgg1.png
18:12:34 <vixey> that's pretty cool actually
18:13:35 <chrisdone> you can see it in action if you put in "foo foo foo bar bar mu" in here: http://chrisdone.com/wordfreq.cgi (?algo=strict for the circular one)
18:14:22 <kpreid> chrisdone: that operators one looks like it doesn't compensate for the length of the words in choosing sizes
18:14:26 <dobblego> Haskell's map is to Perl's map as Haskell's concatMap is to Perl's ?
18:15:30 <kpreid> dobblego: I just tried, perl's map functions as concatMap
18:15:47 <kpreid> eg map { $_ + 1, $_ + 10 } (1,2,3)
18:15:52 <dobblego> kpreid, great thanks
18:15:57 <chrisdone> kpreid: well the idea is that frequency is proportional to size. those words are all the same size because they're vastly less frequent than the 5 other orange ones
18:16:06 <EvilTerran> dobblego, haskell's map is to perl's concatMap what haskell's filter is to perl's grep
18:16:09 <kpreid> chrisdone: oh
18:16:15 <EvilTerran> er, haskell's concatMap, perl's map
18:16:19 <kpreid> chrisdone: switch to a logarithmic scale :-)
18:16:25 * dobblego boggles
18:17:06 <mauke> @source Network.Socket
18:17:06 <lambdabot> http://darcs.haskell.org/packages/network/Network/Socket.hs
18:17:16 <chrisdone> kpreid: I considered it but it might misrepresent just how vastly inproportionate words are. eh, why not :) I'll try it
18:17:45 <EvilTerran> dobblego, perl -e "print scalar map { $_, $_+1 } (10, 20, 30)" prints 6
18:19:04 <EvilTerran> filter P = map {P ? $_ : ()}, roughly
18:28:22 <mauke> http://rafb.net/p/8BDHso19.html
18:28:24 <lambdabot> Title: Nopaste - No description
18:28:48 <mauke> this program opens a socket connection, maps it to stdin/stdout, then starts a specified program
18:28:56 <mauke> (completely untested)
18:29:44 <kpreid> that seems like it ought to already exist.
18:30:19 <kpreid> netcat almost does it; if you had something else that would pipe both stdin and stdout that would do the trick.
18:32:55 <vixey> so like netcat + maukes program ?
18:32:56 <vixey> :p
18:33:15 <vixey> oh ok
18:35:27 <mauke> <lilachaze> I wonder why they didn't use stdin/stdout like real local programs  <macron_>  Using ocaml here and gonna have to setsockopt in C so would rather not if i don't have to!
18:35:33 <mauke> ^ I blame them for the idea
18:37:30 <vixey> hmm
18:37:56 <vixey> I think this is a nice you can take advantage of in an interpreter but not a compiler
18:38:17 <vixey> which is code duplication (for example in case splitting), doesn't matter .. since it's shared
18:38:39 <lilachaze> mauke: cool :)
18:42:54 <Giblaz> haskell is a pretty cool guy
18:43:49 <mauke> eh rides with nomads and doesnt afraid of anything?
18:44:23 <Giblaz> ahahah yes
18:46:11 <jfredett> you silly kids.
18:46:45 <mauke> np: Knorkator - Ich verachte Jugendliche
18:47:25 <Giblaz> :P
18:47:42 <mauke> (that translates to "I despise teenagers")
18:48:37 <mar77a> > length "e420000000000-10\n"
18:48:51 <mar77a> _o
18:48:51 <chrisdone> pacman
18:48:53 <jfredett> Ich veracth Jugendliche, gotcha.
18:48:53 <lambdabot>  thread killed
18:48:58 <mar77a> what's up with that
18:49:13 <chrisdone> > length "e©42©0©0©0©0©0©0©0©0©0©0©-1©0\n"
18:49:28 <lambdabot>  thread killed
18:49:36 <chrisdone> > length "λ_λ"
18:49:44 <jfredett> > 2 + 2
18:49:51 <lambdabot>  thread killed
18:49:52 <jfredett> are any of the threads getting through?
18:49:56 <mauke> @bot
18:49:56 <lambdabot>  4
18:49:56 <lambdabot> :)
18:49:56 <vixey> @undef
18:49:58 <vixey> > 1+1
18:49:59 <lambdabot> Undefined.
18:50:00 <lambdabot>  2
18:50:03 <mauke> > €
18:50:03 <lambdabot>  Illegal character ''\8364''
18:50:03 <lambdabot>  at "" (column 1)
18:50:07 <jfredett> apparently so
18:50:09 <mauke> > length "€"
18:50:11 <lambdabot>  1
18:50:12 <mar77a> > length "e420000000000-10\n"
18:50:12 <chrisdone> someone must just be using λb hardcore in /pm
18:50:13 <lambdabot>      lexical error in string/character literal (UTF-8 decoding error)
18:50:22 <mar77a> > length "e420000000000-10\n"
18:50:23 <lambdabot>      lexical error in string/character literal (UTF-8 decoding error)
18:50:28 <mauke> > length "e©42©0©0©0©0©0©0©0©0©0©0©-1©0\n"
18:50:28 <vixey> @activity
18:50:29 <lambdabot>  30
18:50:29 <lambdabot> 13*total 12*#haskell 1*#ghc
18:50:58 <chrisdone> which was the activity one that showed percentages and other nice things like that?
18:51:24 <mar77a> > ord [22:50] <mar77a> > length "e420000000000-10\n"
18:51:24 <mar77a> [22:50] <lambdabot>      lexical error in string/character literal (UTF-8 decoding error)
18:51:25 <lambdabot>  Parse error at ">" (column 22)
18:51:26 <mar77a> er
18:51:31 <mar77a> [22:50] <mar77a> > length "e420000000000-10\n"
18:51:31 <mar77a> [22:50] <lambdabot>      lexical error in string/character literal (UTF-8 decoding error)
18:51:33 <mar77a> aHSahsshhsds
18:51:34 <mar77a> sorry
18:51:45 <mar77a> > ord ""
18:51:52 <mar77a> > ord ''
18:52:01 <lambdabot>  thread killed
18:52:08 <lambdabot>  thread killed
18:52:12 <mar77a> ah well
18:52:33 <chrisdone> ©······
18:53:14 <mauke> > ord '©'
18:53:15 <lambdabot>  169
18:54:45 <chrisdone> I accidentally tried to reverse an infinite list. it's great when you don't realise until your mouse stops moving
18:57:57 <dobblego> there have been proposals to make that a type error
18:58:13 <kpreid> codata?
18:58:15 <vixey> huh ?!
18:58:24 <dobblego> a FiniteList data type
18:58:59 <jsnx> dobblego: or FiniteFoldable type class?
18:59:19 <dobblego> jsnx, I don't remember the details; it went passed Haskell-cafe once
19:14:51 <ddarius> If you make a type of tail strict lists then reverse (on that type) doesn't have to worry about infinite lists.
19:15:58 <vixey> type encode the length, since types are inductive
19:28:28 <dons> gwern: http://www.joachim-breitner.de/blog/archives/292-FrakView-An-Haskell-Renderer-for-Iterated-Function-Systems.html
19:28:30 <lambdabot> Title: FrakView: An Haskell Renderer for Iterated Function Systems - nomeata’s mind s ..., http://tinyurl.com/6dtoww
19:28:50 <dons> http://www.reddit.com/info/6rlun/comments/ also
19:28:53 <lambdabot> Title: reddit.com: FrakView: An Haskell Renderer for Iterated Function Systems
19:29:44 <dons> gwern: some serious archaeology http://www.cs.chalmers.se/~rjmh/PECourse/Exercises/PE.html
19:29:45 <lambdabot> Title: The Mini-Haskell Partial Evaluator
19:31:59 <jfredett> dons: I just realized "reverse "shit tae"" is not "eat shit", it's "eat this"...
19:32:17 <jfredett> dons: which makes your reddit comment fairly nicer than I originally thought
19:32:31 <mauke> eat tihs
19:32:49 <jfredett> mauke: typo on my part, not his
19:33:00 <jfredett> "siht tae" was what he wrote.
19:33:16 <dons> jfredett: ah i see.
19:33:27 <dons> jfredett: yes, i assumed on a second reading that you'd misread.
19:33:27 <ddarius> dons: The web demo still works.
19:33:54 <dons> huh
19:34:06 <dons> 1997 .
19:34:21 <dons> that's ridiculous.
19:35:04 <dons> i guess it's just cgi
19:35:18 <dons> so nothing to go wrong, and they've got some pretty old hardware at chalmers too
19:36:52 <ddarius> So presumably there's an hbc compiled executable from 1997 running it.
19:37:10 <dons> that'd be my guess.
19:37:20 <dons> <wow>
19:43:58 <Giblaz> <owo>
19:45:03 <dogbite> i'm parsing a CSV file that contains roughly 160k lines
19:45:06 <dogbite> using code like this
19:45:08 <dogbite> http://hpaste.org/8912
19:45:14 <dons> looking...
19:45:18 <dogbite> it's taking a long time
19:45:22 <dons> using Strings ?
19:45:38 <dons> is parseCSVFromFile a library function?
19:45:41 <dogbite> i'm not sure what you mean -- but it's a text file yes
19:45:48 <dogbite> yes i htink it's in Text.CSV
19:45:52 <dons> so you're just using readFile, not ByteString ?
19:45:54 <dons> ah ok.
19:46:12 <dons> it might just be that the Text.CSV parser is inefficient. i don't know much about it.
19:46:26 <dons> you could probably roll a much more efficient version using bytestring IO.
19:46:28 <dogbite> okay, for this i think i could just use readFile.  for my purposes
19:46:28 <lucca> setSocketOption takes a SocketOption and an Int... but SO_LINGER is expecting a pointer to struct linger... am I missing something?
19:46:40 <dons> dogbite: try Data.ByteString.readFile
19:46:48 <dons> it'll use 160k to load the 160k file.
19:46:53 <dons> and you can use split to break up each line.
19:46:54 <dogbite> dons: okay i'll look into it thanks a lot
19:47:58 <dons> dogbite: like this, http://shootout.alioth.debian.org/gp4/benchmark.php?test=sumcol&lang=ghc&id=6
19:47:59 <lambdabot> Title: sum-file Haskell GHC #6 program | Gentoo : Intel Pentium 4 Computer Language B ..., http://tinyurl.com/ys3ony
19:48:15 <lucca> http://www.haskell.org/ghc/docs/latest/html/libraries/network/src/Network-Socket.html#setSocketOption seems to blindly pass in a pointer to the int, which seems wrong for SO_LINGER
19:48:17 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/57qahh
19:48:31 <Korollary> It's
20:01:07 <mmorrow> omg
20:01:30 <vixey> huh?
20:01:31 <mmorrow> chrisdone: that wordcloud image generating cgi program is *sweet*
20:01:49 <mmorrow> i was just scrolling back though the channel
20:02:07 <mmorrow> heh
20:02:20 <dogbite> quick advice on how to create a Word8?
20:02:27 <dolio> You must be really busy.
20:02:40 <dolio> > 5 :: Word8
20:02:41 <lambdabot>  5
20:03:16 <dogbite> dolio: oh i nee dto import Data.Word
20:03:29 <dogbite> dolio: thanks though... wasn't understanding my error message
20:03:32 <dolio> Yeah, that's a good idea, too.
20:04:04 <dogbite> dolio: but what if i want to do '\n'::Word8
20:04:24 <dolio> :t ord
20:04:25 <lambdabot> Char -> Int
20:04:36 <dolio> > fromIntegral (ord '\n') :: Word8
20:04:38 <lambdabot>  10
20:04:44 <dogbite> c2w
20:04:54 <dolio> Yeah, or that.
20:05:12 <dmwit> :t Data.Bytestring.Char8.pack
20:05:13 <lambdabot> Couldn't find qualified module.
20:05:42 <dmwit> dogbite: It sounds like you might actually want ByteString stuff...
20:05:51 <dolio> @type BSC.pack
20:05:52 <lambdabot> String -> BSC.ByteString
20:05:58 <dogbite> dwit: yeah dons pointed me that way
20:06:31 <kpreid> > let c :: Char -> Word7; c = fromIntegral . ord in c '\n'
20:06:32 <lambdabot>   Not in scope: type constructor or class `Word7'
20:06:33 <dmwit> (i.e. if you're dealing with Word8's directly, you may be Doing It Wrong.  But then, you might not be, too.)
20:06:38 <kpreid> > let c :: Char -> Word8; c = fromIntegral . ord in c '\n'
20:06:39 <lambdabot>  10
20:06:47 <kpreid> @let c :: Char -> Word8; c = fromIntegral . ord
20:06:49 <lambdabot> Defined.
20:06:50 <dogbite> dmwit: i'd wager i'm doing it wrong
20:06:59 <kpreid> > c'7' - c'0'
20:07:01 <lambdabot>   Not in scope: `c'0''
20:07:04 <dogbite> i started off looking at this
20:07:05 <dogbite> http://hackage.haskell.org/packages/archive/bytestring/0.9.1.0/doc/html/Data-ByteString.html#v%3Asplit
20:07:07 <kpreid> dang
20:07:07 <lambdabot> Title: Data.ByteString, http://tinyurl.com/5uw43o
20:07:12 <kpreid> > c '7' - c '0'
20:07:14 <lambdabot> Terminated
20:07:19 <kpreid> > c '7' - c '0'
20:07:20 <lambdabot> Terminated
20:07:22 <dolio> Foiled by primes.
20:07:55 <dmwit> dogbite: ah, you want split?
20:08:13 <mmorrow> dogbite: i have a fast String csv parser i can paste. It can do 205271 lines in 4.550 seconds
20:08:14 <dmwit> I mean, you want a Word8 to send to split.
20:08:22 <mmorrow> whereas i kill the parsec one after 1 minute
20:08:24 <dogbite> dmwit: yup
20:08:33 <mmorrow> hold on
20:08:39 <dmwit> dogbite: There's BSC.split :: Char -> BS -> [BS]
20:09:11 <dmwit> dogbite: There's a whole slew of analog functions in Data.BytString.Char8 that take Char instead of Word8.
20:09:12 <dogbite> mmorrow: using ByteString i just split 157563 lines in ... the blink of an eyee
20:09:36 <mmorrow> heh, i would imagine
20:09:44 <dmwit> dogbite: You just have to be careful to only use ASCII. ;-)
20:10:00 <dmwit> (or, just be careful about your encoding in general)
20:10:11 <mmorrow> but doing split ',' if a far cry from actually *parsing* the csv, so if that works for your data then sweet
20:10:12 <dogbite> dmwit: i'm in the US so we haven't advanced to either the metric system or other characters
20:10:52 <dmwit> Well, make sure not to make your program future-proof, you'd be out of a job. ;-)
20:11:07 <mmorrow> i got burned too many times splitting on commas or doing some sed charvomit spell
20:11:29 <mmorrow> had to sit down and actually spend the time to write a decent csv parser
20:11:42 <dogbite> dmwit: i'm in quick-and-dirty hack mode so i'll do single chars for now .
20:11:46 <dmwit> yeah
20:11:57 <dogbite> Text.CSV is no good though, it seems
20:12:13 <dogbite> mmorrow: maybe post it up to hackage so we all can enjoy your labors
20:12:22 <mmorrow> love the quick-and-dirty
20:12:43 <dogbite> mmorrow: for me quick-and-dirty and haskell are a bit like oil and water but
20:13:04 <mmorrow> dogbit: sure. i've been meaning to put it and a bunch of other csv-utils on hackage for over a month now (as "csv-utils")...
20:13:11 <dogbite> a program doesn't feel too solid anymore without haskell, heh
20:13:20 <dmwit> Quick-and-dirty doesn't imply short-lived nearly as often as I would like.
20:13:25 <mmorrow> heh
20:13:29 <arika-chan> I'm beginning to get that feeling too, dogbite
20:14:07 <dogbite> dmwit: couldn't agree more
20:14:25 <mmorrow> dogbite: yeah, Text.CSV is unusable past 10,000-ish lines
20:15:01 <mmorrow> and even then, you have to wait til it's done, because it gives you all or nothing...at the end
20:15:18 <dmwit> Jeebus, 10K lines of CSV?
20:15:45 <arika-chan> that's not an excessive amount...
20:15:54 <dogbite> dmwit: don't you know that CSV is the future, and the future is now?
20:15:57 <dmwit> I would write a 10-minute (2-hour) parser once to drop that in a real DB, let it run overnight, and forget about it.
20:16:14 <dons> mmorrow: ok. good to know. i wonder if i can do a fork using bytestrings cheaply
20:16:29 <dons> since parsing simple data very efficiently is a bit of a bytestring strong point..
20:17:17 <dons> hmm, doesn't look too hard.
20:18:01 <mmorrow> dons: that would the *ideal*. I woulda used bytestrings...but Strings being lists wooed me into taking the easy route
20:18:44 <mmorrow> ok..getting csv code to paste
20:19:16 <dmwit> CSV is actually kind of a hard format to get right.
20:19:43 <dons> ok, this doesn't look too hard.
20:31:13 <dobblego> ?type \p -> filter (not . p) -- is this in the standard library?
20:31:15 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
20:31:48 <ddarius> dobblego: No
20:32:00 <ddarius> The inlining would be more readable
20:34:08 <wuxia> what networks, besides freenode, has a large #haskell channel?
20:34:20 <dobblego> none I imagine
20:34:23 <vixey> wuxia: why?
20:34:31 <wuxia> just curious
20:35:35 <mmorrow> whoa, i just got motivated and cleaned the pkg up somewhat at put it here: http://code.haskell.org/~morrow/code/haskell/csv-utils/
20:35:35 <lambdabot> Title: Index of /~morrow/code/haskell/csv-utils
20:36:40 <mmorrow> it has TH functions to include a csv at compile-time, and it (somewhat sloppily) infers the most specific type for csv columns, then generate an sql create-table statement for the csv on stdin
20:37:26 <mmorrow> (but that part relies on HaskellDB's SQL prettyprinting functions, and i commented all mention of haskelldb out in this repo so as to avoid the dep)
20:38:00 <mmorrow> but if one had HaskellDB built and installed, they just have to uncomment
20:38:37 <dmwit> Is it cabalized?
20:38:42 <mmorrow> (looking at the code, one will notice that this was written "oh crap really fast")
20:38:44 <mmorrow> yeah
20:38:45 <dmwit> If so, you should really make that a cabal flag.
20:38:56 <mmorrow> dmwit: i should
20:39:00 <dmwit> But otherwise... neat!  Congrats!
20:39:07 <mmorrow> :)
20:39:13 <mmorrow> i'll have to read the cabal manual
20:39:25 <wuxia> anyonle have a good tutorial for writing fast numeric code in haskell, expeciall matrix related?
20:39:26 <mmorrow> oh, and one more thing..
20:39:50 <mmorrow> it uses -fspec-constr-count=n, but that flag only appears in 6.9
20:40:00 <mmorrow> but there *is* a 6.8 equiv..
20:41:06 <enoksrd> @pl (\f x0 xs -> foldl (flip f) x0 (reverse xs))
20:41:06 <lambdabot> flip flip reverse . ((.) .) . foldl . flip
20:41:45 <mmorrow> wuxia: check out hmatrix
20:42:00 <dogbite> wuxia: and check out blas
20:42:06 <mmorrow> get the darcs repo, build it, then run the tests/examples in that dir
20:42:14 <mmorrow> a bunch of cool plots
20:42:14 <carl_> if i have a function f :: bigData -> bigData; f bd = bd ghc reallocate bigdata or is it smarter than that?
20:42:21 <mmorrow> ''ll pop up and you'll be hooked
20:43:02 <mmorrow> dogbite: ooh yeah, i've barely messed with that at all yet
20:43:27 <ddarius> carl_: Can you think of one reason why the data would be reallocated and copied?
20:43:29 <wuxia> mmorrow , dogbite : hmm, so it looks like the best way to use matrices in haskell ... is to use ffi of an external library, not anythikng written in haskell?
20:45:27 <carl_> no but if it was f bd = bd + 1 it would have to be reallocated right?
20:46:01 <ddarius> It depends on what +1 means.
20:46:09 <dogbite> wuxia: so in full disclosure i've actually never done matrixes in haskell
20:46:19 <dogbite> *but* i did look into it fairly deeply once
20:46:22 <dogbite> before blas came out
20:46:28 <wuxia> go on
20:46:34 <wuxia> please enlighten me
20:46:39 <dogbite> and i don't think what you're saying is true -- blas seemed good.  i was very excited when it cmae out
20:46:45 <dogbite> but i'm no expert
20:46:51 <mmorrow> wuxia: you should look at some of the lovely tight C loops in the hmatrix cbits
20:47:10 <wuxia> right right ... so the bes5t way to use matrices in haskell is via ffi ?
20:47:19 <wuxia> i was just wondering if the ghc could pull some magic
20:47:23 <mmorrow> the Vector type, Matrix type are defined on the *haskell* side
20:47:40 <wuxia> right, but all the calculations are dcone in C/assembly land
20:47:54 <mmorrow> but then the ptr's passed to some C to do some stuff + interact with bits of gsl, etc
20:48:24 <mmorrow> wuxia: but plenty of it's done on the haskell side. check the code out and judge for yourself
20:48:59 <mmorrow> if you don't like it, write a sweet + fast pure haskell lib and tell me about it ;)
20:49:06 <wuxia> got it; i had a badly phrased question
20:49:13 <wuxia> what's the best purely haskell matrix library out there?
20:49:33 <mmorrow> hmm, i guess it depends on what you want to use it for
20:49:35 <wuxia> trying to see if there's a 'functional' way to do numerical matrix calculations
20:49:49 <wuxia> hmm; i'll test it's limits
20:49:58 <wuxia> and decide how big matices i can stuff into it
20:50:07 <mmorrow> performance? use it to accomplish something else? play with the pure math aspect?
20:50:19 <wuxia> data analysis
20:50:26 <wuxia> something like, say , R
20:50:29 <mmorrow> heh
20:50:33 <mmorrow> use hmatrix :)
20:50:45 <dons> wuxia: you could use one of the array libraries, like uvector, but they're not yet very good at N-dimensional things.
20:50:55 <dons> so i'd suggest using hmatrix, which is half haskell, half c.
20:51:49 <mmorrow> it just recently got mutable vectors in the ST monad
20:52:00 <mmorrow> pure haskell!
20:52:32 <vixey> ST is super cool
20:52:48 <dogbite> wuxia: defer to dons and mmorrow -- i'm just a hack
20:53:04 <mmorrow> the great thing is, if you want to do something not in the interface, you can always just write 20 lines of C to arbitrarily manipulate a vec/mat however you want
20:54:35 <mmorrow> no struct anywhere to be found, just ptrs to (arrays of) double
20:54:50 <ellisk> Hi, I'm trying to statically link against the Network and Parsec libraries. Right now I'm doing: ghc --make -static parsec-3.0.0 -static network-2.2.0.0 Main.hs, but GHC says: gcc: parsec-3.0.0: No such file or directory, and gcc: network-2.2.0.0: No such file or directory. Does anyone know what is wrong?
20:57:35 <dons> ghc --make should find the right code
20:57:49 <dons> it doesn't make any sense to pass the libraries on the command line like that.
20:57:57 <dons> and ghc does --static by default
20:58:06 <dons> you'd only use it explicitly to statically link C libraries
20:58:13 <ellisk> It links then statically by default?
20:58:54 <dons> yeah, try `ldd Foo` on your binary, and you'll see all the haskell libs are statically linked by default.
20:58:57 <dons> makes cgi apps really easy :)
20:59:37 <ellisk> dons: So, I could compile my program that uses Parsec on my machine, and run it on a machine that doesn't have parsec installed?
20:59:39 <bd_> Or rather, it'd be pretty hard to do dynamic linking when the ABI of a haskell lib can change based on the optimizer's decisions, right?
20:59:58 <bd_> Not to mention inlining and rewrite rules being inherited from the library to its users
21:04:03 <vixey> HOAS is mind bending like call-with-current-continuation
21:04:23 <ellisk> Wow, look at this: find /usr -name *parsec*   Not a single .so file to be found. Only .a.....
21:05:16 <ellisk> Thanks dons and bd!
21:05:16 <dmwit> You might also like: "locate parsec"
21:05:51 <ellisk> ?? It's not installed. I'm running Debian. What does locate do?
21:05:52 <lambdabot> Plugin `compose' failed with: Unknown command: ""
21:05:58 <mmorrow> vixey: totally
21:06:18 <dmwit> ellisk: "locate" is "find / -name *$@*", but faster, because it keeps a database.
21:06:34 <ellisk> ok, cool.
21:07:35 <dmwit> ~% time locate parsec | wc
21:07:35 <dmwit>     120     167    8081
21:07:35 <dmwit> locate parsec  0.36s user 0.01s system 81% cpu 0.458 total
21:07:58 <mmorrow> wuxia: i just noticed this comment of yours in particular:
21:07:59 <mmorrow> <wuxia> trying to see if there's a 'functional' way to do numerical matrix calculations
21:08:10 <mmorrow> you can totally do that with hmatrix
21:08:23 <mmorrow> independent of whether it's 1/2 in haskell or all in haskell
21:08:32 <wuxia> no no, i meant functinoal way to do things like gaussian implementati9no
21:08:35 <mmorrow> because you're manipulating it always in haskell
21:08:41 <mmorrow> wuxia: heh.
21:08:43 <wuxia> the fastest algorithms i know deconstructively modify it in the process for stufff like inverting
21:09:09 <wuxia> they make the matrix triangular, then write results in the upper half of the triangle as they calculate in the lower half o rosmething
21:10:22 <ddarius> The LU decomposition is usually more valuable than the inversion
21:10:55 <wuxia> i thihnk the right thing here ... ikks taht i implemnet it ikn pure haskell
21:11:04 <wuxia> then it'll give the ghc implementor ppl something to play with :-)
21:11:06 <dmwit> What's up with your 'k' key?
21:11:24 <wuxia> i'm still getting used to my kinesis ergo
21:11:32 <dmwit> Oh, yeah, that took me a week, too.
21:11:44 <mmorrow> the hmatrix author, alberto, actually just recently wrote a new tutorial/intro it seems
21:11:45 <mmorrow> http://perception.inf.um.es/%7Earuiz/darcs/hmatrix/hmatrix.pdf
21:11:47 <wuxia> apparently on standard qwerty, i was using the wrong finger lots of times
21:11:48 <lambdabot> Title: A simple scientific library for Haskell
21:11:55 <dmwit> I discovered that I was using the "wrong" fingers for a lot of keys.
21:11:58 <dmwit> ...yeah
21:12:21 <ddarius> wuxia: I'm sure there are already several implementations of Gaussian elimination in Haskell.
21:12:40 <mmorrow> wuxia: this'll solve alllll your problems http://perception.inf.um.es/%7Earuiz/darcs/hmatrix/doc/html/Numeric-LinearAlgebra-Algorithms.html  :)
21:12:41 <lambdabot> Title: Numeric.LinearAlgebra.Algorithms, http://tinyurl.com/6f2bzu
21:12:55 <wuxia> the oncool; thanks
21:14:45 <mmorrow> most of them are backed by lapack functions, which are super fast and usually very finely tuned to the particular machine they're built on
21:15:21 <mmorrow> (fortran!!)
21:15:49 <dons> yeah, Haskell + C + Fortran FTW!
21:15:56 <mmorrow> heh
21:16:00 <mmorrow> FTW!@
21:16:13 <ellisk> Haskell + C + Fortran FTW :: Win
21:16:28 <vixey> I guess hpaste is dead, I pasted this code http://hpaste.org/8914
21:17:01 <vixey> writing that was like learning recursion again...
21:17:44 <vixey> except harder :p
21:19:31 <vixey> oh I wanted to ask about this http://research.microsoft.com/~simonpj/Papers/slpj-book-1987/PAGES/096.HTM
21:19:34 <lambdabot> Title: The Implementation of Functional Programming Languages, http://tinyurl.com/5jgwzo
21:19:41 <wuxia> man; trying to understand the fundamental theorm of algebra with only a real analysis background is so b*tchy
21:20:03 <vixey> this definition 'unwieldy', it is possible to write that in haskell?
21:20:33 <ddarius> wuxia: Understanding it is trivial.  Understanding a proof is presumably what you mean.
21:21:03 <wuxia> yeah
21:21:07 <wuxia> the pudding's in the proof
21:21:08 <vixey> I don't think there's anything like 'fail' in haskell, is there?
21:21:26 <dolio> error?
21:21:38 <ddarius> wuxia: It only takes a little bit of homotopy theory to do it.
21:21:55 <vixey> it seems like the case expressions in this book are executed in the same manner as Prolog code
21:22:32 <wuxia> ddarius: can I pm  you? i'm trying to read: http://en.wikipedia.org/wiki/Fundamental_theorem_of_algebra ... but all of these seem to jump into a recursion of complex analysis terms that i don't understamnd
21:22:32 <lambdabot> Title: Fundamental theorem of algebra - Wikipedia, the free encyclopedia
21:23:02 <ddarius> wuxia: Go to the topological proof
21:23:47 <wuxia> It follows that if a is a kth root of −p(z0)/ck and if t is positive and sufficiently small, then |p(z0 + ta)| < |p(z0)|, which is impossible, since |p(z0)| is the minimum of |p| on D.
21:24:01 <wuxia> but ... tht's a value, not a fomrular, how do we get a root of it?
21:24:13 <wuxia> oh wait, kth root as in kth root
21:25:07 <wuxia> omg
21:25:10 <wuxia> i think ik understand it
21:25:13 <wuxia> the trick is to find t so small
21:25:25 <wuxia> so that the c_k term can drawf out the c_i terms for i >= n
21:25:29 <dolio> vixey: Looks like Maybe to me.
21:25:31 <wuxia> hmm, this is clarly OT, i'll stfu
21:25:43 <mmorrow> wuxia: yuk, bounding regions of the complex plane is so 19th century
21:26:02 <dolio> Implicity Maybe.
21:26:07 <dolio> Minus a y.
21:26:19 <wuxia> life was good until this linear algebra book decided "hey, i'm going to state a theorem that requjires the fundamental theorme of algebra to provbe"
21:26:19 <dmwit> Implicity Mabe
21:26:28 <dolio> Right. :)
21:27:02 <dmwit> Dang, now I have to change my password.
21:30:21 <vixey> oh also does anyone know which text it is they say "It is also possible to derive the pattern-matching compiler from its specification using program transformation techniques; see Barrett and Walder [1986]"
21:32:49 <wuxia> if after working through haskell soe ... i go back and code in scheme; will you guys forgive me?
21:33:13 <ddarius> wuxia: We won't care one way or another.
21:34:41 <dobblego> we care about as much as the giant turtle in The Neverending Story
21:47:48 <mmorrow> will you ever forgive yourself!
21:54:52 <wuxia> how do i print a float/
21:54:57 <dmwit> :t print
21:54:57 <vixey> print
21:54:59 <lambdabot> forall a. (Show a) => a -> IO ()
21:55:29 <vixey> When I have a 60 line comment... that means this algorithm wont be easy to write :|
21:55:49 <wuxia> what algorityhm are you trying to implement?
21:56:19 <vixey> transforming simple pattern matching into eliminator calls
21:56:21 <electronx> anyone here tried mercury?
21:56:39 <dons> electronx: there's some of the original mercury implementors in the channel :)
21:56:51 <electronx> hmm
21:57:04 <Pseudonym> Only one at the moment.
21:57:05 <dmwit> electronx: We use mercury exclusively at work.
21:57:07 <electronx> i wander if zoltan is in this channel
21:57:08 <Trinithis> anyone know what the last 2 params of gtk2hs's drawPixbuf do?
21:57:17 <dmwit> (Just transferred from subversion, thank goodness.)
21:57:27 <Pseudonym> electronx: No.
21:57:29 <dons> electronx: i don't think so.
21:57:32 <Pseudonym> He doesn't use IRC.
21:57:37 <dons> old school.
21:57:38 <Pseudonym> And if he did, he wouldn't hang out here.
21:57:38 <vixey> wuxia: so stuff like like  f Nothing = A ; f (Maybe [x]) = B ; f _ = C  ~~>  f = maybeElim A (listElim C (\x _ -> listElim B (\_ _ -> C)))
21:57:46 <dolio> dmwit: Mercury, not Mercurial.
21:57:47 <electronx> Pseudonym: how do you know that?
21:57:54 <dmwit> oh
21:57:58 * Pseudonym spent five long years working for him
21:58:03 <electronx> wow
21:58:09 <Pseudonym> On Mercury.
21:58:12 <electronx> i see him on the train sometimes
21:58:20 <Pseudonym> Kinda hard to miss.
21:58:25 <electronx> rofl yep
21:58:58 <electronx> i thinking of doing logic programming this semester with him
21:59:02 <electronx> i'm*
21:59:11 <Pseudonym> Which year level is this?
21:59:16 <electronx> 4th
21:59:21 <Pseudonym> Honours?
21:59:33 <electronx> its honours subject
21:59:36 * Pseudonym nods
21:59:41 <electronx> but i'm not doing honours
22:00:04 <Pseudonym> Well, here's the thing.  First off, he's a good lecturer.
22:00:11 <electronx> just wandering whether it will be an easy ride through
22:00:23 <Pseudonym> Not knowing what he's going to cover, I have no idea.
22:00:23 <vixey> electronx: wondering
22:00:31 <Pseudonym> Honours subjects tend not to be easy rides.
22:00:40 <wuxia> what has mercury over git?
22:00:40 <Pseudonym> However, there is one detail you should know.
22:00:41 <electronx> vixey: yes thanks for correction
22:00:50 <Pseudonym> He standardises his classes.
22:00:52 <vixey> wuxia: one's a programming language ....
22:00:55 <dmwit> wuxia: mercury is apparently a programming language unrelated to mercurial
22:01:00 <Pseudonym> Even if there are only eight peope in the class, the exam is standardised.
22:01:05 <electronx> Pseudonym: standardises>
22:01:07 <electronx> ?
22:01:08 <dmwit> wuxia: (I made the same mistake. =)
22:01:17 <electronx> oh
22:01:27 <Pseudonym> Yeah.
22:01:37 <electronx> so if ya pass the exam you may still fail
22:01:42 <Pseudonym> It kinda pissed our honours class off.
22:01:45 <Pseudonym> No, you won't fail.
22:01:58 <Pseudonym> If you pass, you'll pass.
22:01:59 <Pseudonym> But.
22:02:01 <electronx> but you'll get adjusted down
22:02:07 <Pseudonym> Possibly, yes.
22:02:11 <electronx> that sucks
22:02:15 <Pseudonym> The average score will be 80%.
22:02:19 <ddarius> Just be better than everyone else.
22:02:22 <Pseudonym> Regardless of how everyone does.
22:02:26 <electronx> hahaha
22:02:38 <dmwit> Just be equal to everyone else.
22:02:41 <Pseudonym> OK, the average of all who _pass_ will be 80%.
22:02:42 <Trinithis> college or high school
22:02:47 <ddarius> Pseudonym: If everyone does equally well, does everyone get an 80%?
22:02:52 <Pseudonym> Probably.
22:03:01 <dmwit> ddarius: No, everybody is ten standard deviations above the mean!
22:03:11 <electronx> Pseudonym: are you still working at melb uni?
22:03:14 <dmwit> 180% for everybody!
22:03:33 <Pseudonym> Nope.
22:03:35 <Pseudonym> RMIT now.
22:03:56 <electronx> ah
22:04:13 <electronx> i don't like the selection of cs subjects at melb uni
22:04:23 <Pseudonym> It's changed a lot since the dot-com crash.
22:04:34 <Pseudonym> Fewer people want to do CS as a subject.
22:04:37 <electronx> most are just theory
22:04:39 <dons> i think they've changed a lot everywhere.
22:04:44 <Pseudonym> Yeah, I think so too.
22:04:55 <dons> unsw was trying to chase recruits, with lots of bioinf subjects, for example.
22:04:55 <Pseudonym> But yes, unimelb has a very heavy theoretical bent.
22:05:06 <electronx> i don't like that
22:05:12 <dons> turning more into something like the math faculty, providing services to other depts.
22:05:26 <electronx> i look at monash list of subjects and theys eem better and more practical
22:05:38 <electronx> seem*
22:05:48 <ddarius> Then go to Monash
22:05:53 <dons> i don't think we know any haskell programmers there, so that rules Monash out :)
22:05:54 <electronx> i just have to slug through one more year
22:06:38 <Pseudonym> Monash has some good people in related fields, though.
22:06:46 <electronx> yeah
22:07:05 <Pseudonym> Hal is a Monash project, for example.
22:07:45 <electronx> i wish melb uni had a subject on haskell
22:07:53 <electronx> i would take it
22:08:13 <Pseudonym> You go to FPU?
22:08:27 <electronx> thats not on anymore
22:08:30 <Pseudonym> Hasn't happened in the last few weeks, no.
22:09:29 <electronx> they used to have and honours subject FUnctional programming but they don't anymore
22:09:35 <electronx> an*
22:09:50 <Cale> electronx: However, theory is the stuff which won't be out of date in 20 years...
22:10:10 <vixey> by the way is HAL source code available?
22:10:12 <electronx> Cale: thats true
22:10:17 <Cale> (so you should probably look on the bright side :)
22:10:41 <electronx> Cale: doesn't mean i like it though :)
22:12:20 <electronx> i just have to stick out one last year
22:14:12 <vixey> electronx: And what happens after that?
22:16:02 <electronx> vixey: i graduate
22:16:30 <vixey> electronx: but what happens after that?
22:16:44 <wuxia> startup or corporate or grad school?
22:16:45 <electronx> i'll work on my business
22:16:47 <vixey> I mean why do something you don't want to do for an entire year?
22:17:06 <mae> what is the easiest way to convert a string into a bytestring
22:17:20 <dmwit> pack
22:17:23 <electronx> vixey: just in case my business plans fail and i will have to go look for a job
22:17:41 <wuxia> electronx: good plan
22:17:50 <electronx> having a degree is like a backup
22:17:53 <mae> pack deals with Word8
22:18:09 <dmwit> mae: Data.ByteString.Char8 has Char-based functions
22:18:12 <electronx> wuxia: i thought so too :)
22:18:13 <wuxia> electronx: what's ur business plan?
22:18:18 <mae> tx
22:18:23 <dmwit> mae: Dunno how well they deal with Chars outside the Word8 range, though, so be warned.
22:18:23 <electronx> running a website
22:18:33 <wuxia> electronx: (I also recently graduated, had same thoughts on getting a degree vs dropping outY
22:19:02 <electronx> wuxia: stick it out
22:19:20 <electronx> only a very small percentage of your overall life
22:20:20 <Pseudonym> Those who drop out and fail quickly outnumber those who drop out and succeed quickly.
22:20:33 <roconnor> w00t, I've got a driving rover!
22:20:42 <mae> hmm, i'm wondering if just converting the string into word8 would not be a better solution
22:20:48 <mae> what is the default for string literals in haskell?
22:20:49 <TSC> There are people at Monash who do some Haskelly work
22:21:03 <TSC> Lloyd Allison has published some stuff on lazy functional programming, IIRC
22:21:07 <vixey> mae: default what?
22:21:25 <mmorrow> mae: Data.ByteString.Internal has c2w :: Char -> Word8   and w2c :: Word8 -> Char
22:21:50 <mmorrow> so,  let myPack = pack . fmap c2w :: String -> ByteString
22:21:52 <thoughtpolice> mae: default type? [Char], but with -XOverloadedStrings you can do "hi mom" :: ByteString if that's what you're asking
22:21:54 <electronx> Pseudonym: i was very close to dropping out but my parents gave me a big lecture about how important it is to finish university
22:22:34 <mmorrow> mae: yeah, you can also do {-# Language XOverloadedStrings #-}
22:22:46 <mae> yeah that seems clean
22:22:51 <mae> i just try to avoid extensions if possible
22:22:55 <dmwit> mae: If you're asking about the default encoding, there is no default encoding.
22:23:03 <Apocalisp> What's the cofunctor equivalent to fmap?
22:23:11 <mae> so Char8 is synonymous to the traditional ascii and word8 is utf-8?
22:23:11 <dmwit> coughmap
22:23:22 <Apocalisp> ?type comap
22:23:23 <lambdabot> Not in scope: `comap'
22:23:26 <dmwit> mae: No.
22:23:43 <electronx> just wandering how many here have a degree of some sort?
22:23:44 <thoughtpolice> mae: no, if you want utf8 layering for strings/bytestrings you need the utf8-string package
22:23:45 <mae> ok what is the difference between word8 and char then
22:23:53 <dmwit> mae: Char is a Unicode code-point (i.e. abstract, not encoded).  Word8 is an 8-bit word (no encoding specified).
22:23:59 <mmorrow> mae: Word8 is and unsigned char in C, and Char is a char
22:24:01 <mae> i mean it seems counter intuitive to me, a word i thought was 16
22:24:09 <mae> ah ok
22:24:13 <Apocalisp> ?hoogle (a -> b) -> m b -> m a
22:24:14 <dmwit> Word16 has 16 bits
22:24:14 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
22:24:14 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
22:24:14 <lambdabot> Data.Function.($) :: (a -> b) -> a -> b
22:24:15 <mmorrow> Word8, Word16, Word32
22:24:23 <mmorrow> Word ==> unsigned
22:24:24 <dmwit> mae: There's also Int8, Int16, Int32 for signed values.
22:24:35 <mae> ok
22:24:41 <mae> so in the interests of portability
22:24:52 <mae> how is bytestring defined?
22:25:03 <dmwit> It's a pointer to a chunk of memory, probably.
22:25:05 <mae> i mean if i convert from a string constant
22:25:08 <mmorrow> there are Word8 and Char8 variants
22:25:23 <mae> it becomes platform-x's native encoding
22:25:24 <mmorrow> Data.ByteString  has pack :: [Word8] -> ByteString
22:25:24 <mae> ?
22:25:44 <dmwit> No, you have to specify an encoding explicitly if you want it encoded.
22:25:44 <mmorrow> Data.ByteString.Char8  has pack :: [Char] -> ByteString     which  is the same as String -> ByteString
22:25:53 <dmwit> mae: i.e. you have to use a library off of hackage.
22:26:00 <mmorrow> yeah, the type says nothing about the encoding
22:26:01 <mae> ok for instance
22:26:07 <mae> Network.Socket recv/send
22:26:11 <mae> this is purely based on that platform?
22:26:16 <mae> because it ties into glibc
22:26:19 <dmwit> What?
22:26:32 <dmwit> :t recv
22:26:33 <lambdabot> Not in scope: `recv'
22:26:35 <mmorrow> you should use the ntoa etc functions to ensure you've got the right byte order
22:26:41 <mae> http://hackage.haskell.org/packages/archive/network/2.2.0.0/doc/html/Network-Socket.html
22:26:43 <lambdabot> Title: Network.Socket, http://tinyurl.com/6sy4vc
22:27:23 <dmwit> mae: Ah, yeah, that's...
22:27:25 <mmorrow> (whatever those functions might be called in this case)
22:28:00 <mae> ok so essentially word8 is an unsigned byte and Char is unspecified (portable) right?
22:28:02 <dmwit> GHC probably uses UTF-8 for output.  But don't quote me on that.
22:28:02 <roconnor> @pl (\x -> print x >> cmd h x)
22:28:03 <lambdabot> liftM2 (>>) print (cmd h)
22:28:03 <audreyt> @seen dons
22:28:05 <lambdabot> dons is in #arch-haskell, #xmonad, #ghc and #haskell. I last heard dons speak 22m 12s ago.
22:28:41 <dmwit> mae: right
22:29:13 <dmwit> > show 'h'
22:29:15 <lambdabot>  "'h'"
22:29:18 <dmwit> > show '\322'
22:29:20 <lambdabot>  "'\\322'"
22:29:39 <mmorrow> yeah....but when you convert c2w or w2c nothing *actually* happens to the underlying rep. just the type is changed from the point of view of the type syste,
22:29:57 <mae> something happens when i use this:
22:29:58 <mae> http://hackage.haskell.org/packages/archive/network-bytestring/0.1.1.2/doc/html/Network-Socket-ByteString.html
22:30:00 <lambdabot> Title: Network.Socket.ByteString, http://tinyurl.com/5r58kh
22:30:04 <mae> i'm curious what encoding gets written to the socket
22:30:16 <dmwit> mae: If you're worried about transmitting it in a portable way, "show" is designed to be Haskell readable and is usually ASCII-safe.
22:30:54 <dmwit> mae: ByteString's definitely are not encoded before being sent.
22:31:04 <dmwit> mae: So the encoding just depends on how you built the ByteString.
22:31:12 <mae> yes but when i use 'send' what is handed to the libc send function
22:31:19 <ddarius> mae: The standard IO libraries do no encoding or decoding.
22:31:22 <mmorrow> mae: whatever encoding you write to it :). there must be some "to network byte order" function somewhere (if that's what you want)
22:31:39 <dmwit> mae: A ByteString is a chunk of memory.  So libc gets handed a pointer to a chunk of memory.
22:31:48 <mae> ok
22:31:57 <dmwit> mae: Hell, look at its name.  "ByteString".  It's just a bunch of bytes!
22:32:07 <mae> so at what point does the signed-ness or unsigned-ness get determined
22:32:10 <mae> if i want to go from a Char
22:32:15 <dmwit> ...
22:32:17 <mae> is that platform-dependent?
22:32:30 <mmorrow> it only exists in your interpretation of the same value
22:33:22 <mmorrow> 11 == 3 unsigned          11 = -1 signed
22:35:40 <mae> mmorrow: i know this difference, I am just wondering what type of encoding is handed to the socket if i am writing a string literal like "Hello, World!".
22:36:16 <ddarius> mae: It depends on what function you use.
22:36:24 <mae> standard ISO-8859-1/ASCII?
22:36:29 <mmorrow> > map ord "Hello, World!"
22:36:30 <lambdabot>  [72,101,108,108,111,44,32,87,111,114,108,100,33]
22:36:35 <mae> how about
22:36:38 <ddarius> mae: It depends on what function you use.
22:36:43 <mae> send mysocket "Hello, World!"
22:37:27 <scook0> > ord "香"
22:37:28 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
22:37:35 <scook0> > map ord "香"
22:37:37 <lambdabot>  [39321]
22:38:29 <mmorrow> ok, i think i see what you're saying. suppose you say      x = "Hello, World!"       then say     y = toWord8s x. if you then write  x  to one socket and y to another and compare them on the other side, they;ll be the exact same value
22:38:50 <dmwit> toWord8s?
22:39:01 <mmorrow> map c2w
22:39:09 <mmorrow> :)
22:39:12 <dmwit> :t c2w
22:39:13 <lambdabot> Not in scope: `c2w'
22:39:19 <ddarius> mae: It internally use withCString which is supposed to be locale-dependent but currently is not.
22:39:51 <dmwit> mmorrow: But those are only the same by coincidence.
22:40:08 <mmorrow> and that's our reality
22:40:18 <mmorrow> (assuming
22:40:28 <mmorrow> the other side compares them at the bit level
22:40:34 <mmorrow> )
22:40:51 <dmwit> Anyway, yes.  If you restrict yourself to Char's that are in the ASCII range anyway, then probably every conversion is going to be a no-op.
22:41:10 <mmorrow> yeah, i'm assuming 0..255
22:41:49 <mmorrow> which since we're talking Word8s i thought to be valid
22:42:47 <mmorrow> if that's not the basic unit of character, then it's a whole 'nother story
22:43:10 <mae> right
22:43:22 <mae> what do you mean by a "noop"
22:43:48 <mmorrow> meaning the conversion function Char -> Word8 compiles as nothing
22:43:54 <mae> so yeah basically you are saying that in the end the network stuff is still rocking and rolling in good old fashioned ascii.
22:43:56 <dmwit> I mean, you're just changing the type of the data without munging the bits in any interesting way.
22:43:59 <sjanssen> mmorrow: it doesn't
22:44:10 <mmorrow> what doesn't?
22:44:19 <sjanssen> Char -> Word8 /= id
22:44:28 <mae> and haskell depends on libc for network things
22:44:29 <mmorrow> ooh. do tell
22:44:31 <mae> right?
22:44:35 <sjanssen> it compiles to a modulus/bitmask
22:44:36 <dmwit> mae: No.  We're saying that, if you assume your chars are *already* in the ASCII range, then nothing happens to them.
22:44:42 <ddarius> mae: The network doesn't care.  The issue is the conversion of Haskell Strings to C strings.
22:44:49 <sjanssen> mmorrow: Haskell Char covers the entire Unicode range
22:45:06 <dmwit> sjanssen: We're assuming the characters are already in the ASCII range, I think.
22:45:10 <mmorrow> sjanssen: ah. i was assuming they where 0..255
22:45:23 <mae> ddarius: right
22:45:28 <mae> Ok here is an example
22:45:31 <sjanssen> they might be in some particular application, but not in general
22:45:41 <mae> lets say i write a webserver and HTTP 1.1 says i need to send a character encoding
22:45:59 <mmorrow> ok, then in that case i misunderstood the assumptions of our discussion
22:46:02 <dmwit> mae: We've said it several times.  If you want a specific encoding, use a library from hackage.
22:46:02 <mae> at the network level with bytestrings i am just sending bytes, so any encoding other than basic ascii would be up to me to do
22:46:20 <sjanssen> mae: yes, this is true
22:46:37 <mmorrow> yeah, that's what i was going by
22:46:41 <mmorrow> bytes
22:46:42 <mae> sjanssen: but if i set my encoding to ISO-8859-1 and say screw the rest
22:46:44 <mae> i need not worry
22:46:46 <mae> :)
22:47:35 <ddarius> mae: With the standard IO functions, there is no encoding to set.
22:48:18 <mmorrow> sjanssen: what the "modulus" part of "modulus/bitmask"
22:48:25 <mmorrow> what *is* the ...
22:48:35 <sjanssen> `mod` 256
22:48:41 <mmorrow> ahhh
22:48:53 <sjanssen> either of those, I don't know what actually happens
22:48:56 <dmwit> mmorrow: You can understand it either as a modulus or a bitmask; it's not necessary to use both, of course. =)
22:49:08 <mmorrow> ha. oh, now i get it
22:49:13 <sjanssen> or perhaps on x86 one will just grab the lowest byte of a register (you can do that, right?)
22:49:22 <ddarius> sjanssen: Yes.
22:49:24 <mmorrow> (i though it was a pair of one of each and i was confused)
22:49:28 <mae> ddarius: yeah i get it
22:50:01 <sjanssen> but it may as well be a bitmask, since Word8s are actually Words in GHC
22:50:10 <mmorrow> oh yeah, true
22:50:17 <mmorrow> Word#
22:50:23 <mmorrow> err
22:50:26 <mmorrow> W#
22:50:36 <sjanssen> @src Word8
22:50:37 <lambdabot> Source not found. My mind is going. I can feel it.
22:50:50 <sjanssen> data Word8 = GHC.Word.W8# GHC.Prim.Word# -- Defined in GHC.Word
22:51:57 <mmorrow> ha, beat me to it
22:51:58 <mmorrow> -- |A 'Word' is an unsigned integral type, with the same size as 'Int'.
22:51:58 <mmorrow> data Word = W# Word# deriving (Eq, Ord)
22:52:08 <mmorrow> ooh, ghci ftw
22:52:51 <wuxia> uppose I have [(x, y) | x <- [1, 2..] , y <- [1, 2..]]; is there a way I can read (2, 1) out of the list?
22:53:08 <ddarius> No.
22:53:13 <dmwit> wuxia: You have to use a different ordering.
22:53:20 <dmwit> wuxia: Ever heard of diagonalization?
22:53:34 <wuxia> cool; just checking to see if i can read off an infinite subsetion of an infinite list :-)
22:53:42 <wuxia> yeah; it's used in the real > rational proof
22:53:51 <wuxia> as well as turing undecidable proof :-Y
22:54:17 <dmwit> > [(x, sum - x) | sum <- [2..], x <- [1..sum - 1]]
22:54:17 <sjanssen> > (2, 1) `elem` [(x, y) | x <- [1, 2..] , y <- [1, 2..]]
22:54:19 <lambdabot>  [(1,1),(1,2),(2,1),(1,3),(2,2),(3,1),(1,4),(2,3),(3,2),(4,1),(1,5),(2,4),(3,...
22:54:21 <lambdabot>  Tried to use too much memory
22:55:28 <_zenon_> @pl  [(x, sum - x) | sum <- [2..], x <- [1..sum - 1]]
22:55:28 <lambdabot> [(x, sum - x) | sum <- [2..], x <- [1..sum - 1]]
22:55:53 <_zenon_> Is there no stronger rewriting tool for lambdabot? I was hoping it would rewrite that
22:56:02 <dmwit> _zenon_: There was no lambda there, and ?pl doesn't do list comprehensions.
22:56:07 <dmwit> One more strike and you're out. ;-)
22:56:09 <vixey> @undo [(x, sum - x) | sum <- [2..], x <- [1..sum - 1]]
22:56:10 <lambdabot> concatMap (\ sum -> concatMap (\ x -> [(x, sum - x)]) [1 .. sum - 1]) [2 ..]
22:56:14 <vixey> @pl concatMap (\ sum -> concatMap (\ x -> [(x, sum - x)]) [1 .. sum - 1]) [2 ..]
22:56:15 <lambdabot> ap ((=<<) . flip flip [] . ((:) .) . ap (,) . (-)) (enumFromTo 1 . subtract 1) =<< [2..]
22:56:52 <_zenon_> Ahh.. undo
22:56:54 <dmwit> ?. pl undo [(x, sum - x) | sum <- [2..], x <- [1..sum - 1]]
22:56:55 <lambdabot> ap ((=<<) . flip flip [] . ((:) .) . ap (,) . (-)) (enumFromTo 1 . subtract 1) =<< [2..]
22:56:57 <_zenon_> That's something nice
22:57:00 <dmwit> cute
22:57:04 <dmwit> vixey++
22:57:10 <ddarius> @pl concatMap
22:57:10 <lambdabot> (=<<)
22:57:21 <_zenon_> although the expression became "slightly" problematic to read
22:57:36 <vixey> liftI2 (,) [1..] [1..]
22:57:42 <ddarius> You get what you pay for.
22:57:53 <sjanssen> @. pl undo [(x, sum - x) | sum <- [2..], x <- [1..sum - 1]]
22:57:54 <lambdabot> ap ((=<<) . flip flip [] . ((:) .) . ap (,) . (-)) (enumFromTo 1 . subtract 1) =<< [2..]
22:58:15 <wuxia> how can i pay pal lambda bot?
22:58:16 <dolio> Most people don't claim that writing everything point free is a good idea.
22:58:36 <dons> except of the Squiggol Sect, and they're weirdos
22:58:41 <dmwit> ?. pl undo [[(x, sum - x) | x <- [1..sum - 1]] | sum <- [2..]]
22:58:41 <lambdabot> ap ((=<<) . flip flip [] . ((:) .) . ap (,) . (-)) (enumFromTo 1 . subtract 1) `fmap` [2..]
22:58:51 <dolio> Well, there's also the concatenative nuts. :)
22:58:54 <dmwit> Pretty similar, actually.
22:58:56 <ddarius> dons: They don't write everything in a point-free form either.
22:59:07 <ddarius> dolio: Concatenative folk usually do.
22:59:33 <mmorrow> what is this "concatenative" you speak of
22:59:44 <mmorrow> ?
22:59:47 <vixey> so terrible
22:59:55 <sjanssen> @pl getZipList $ liftA2 (,) (ZipList [1..]) (ZipList [1..])
22:59:56 <lambdabot> getZipList (liftA2 (,) (ZipList [1..]) (ZipList [1..]))
22:59:57 <vixey> oh actually I saw a nice thing about it
23:00:06 <dolio> Although some of them occasionally use named parameters. But maybe they aren't nuts. :)
23:00:17 <vixey> http://home.pipeline.com/~hbaker1/ForthStack.html
23:00:18 <lambdabot> Title: ACM Sigarch Comp. Arch. News 22, 1 (Mar 1994), 34-43.
23:00:31 <mmorrow> THE "FORTRAN FALLACY"
23:00:37 <mmorrow> (hehe)
23:00:39 <vixey> :))
23:00:44 <vixey> this is a really paper
23:02:08 <vixey> why do I keep missing out words ..
23:02:20 <dolio> ddarius: Do you know of any information on squiggol on the internet? Someone was asking the other day, and the Bananas... paper is the only thing I've ever seen that goes into any kind of detail on it.
23:02:49 <vixey> It's a shame algebra of programming isn't online
23:02:50 <dolio> Not that it's a bad listing of all the notation.
23:04:05 <wuxia> http://hpaste.org/8915 <- please help
23:04:14 <erikc> doh, just as i get template haskell automatically deriving Storable for simple structs, i discover hsc2hs
23:04:31 <dmwit> wuxia: If it's in a do-block, indent "in" more than "let".
23:04:41 <dmwit> wuxia: ...or just drop the "in" part. =)
23:04:51 <mmorrow> lol ^lol
23:04:54 <mmorrow> Fortran has been quite naive about the nature of mathematical expressions,
23:04:57 <sjanssen> wuxia: I think we need to see the context
23:05:00 <mmorrow> nd Fortran novitiates learn to "put that mathematical metaphor up on the shelf next to the Easter Bunny"
23:05:11 <wuxia> http://hpaste.org/8916 ... still doedsn't work
23:05:24 <dmwit> Yep, context please.
23:05:46 <wuxia> http://hpaste.org/8917
23:05:50 <mmorrow> the use of the word "novitiates" in the same sentence as "the Easter Bunny" take the cake
23:06:10 <mmorrow> takes
23:06:25 <dmwit> wuxia: "let" can't exist at the top level.
23:07:28 <mmorrow> "...ike Fortran, Ada, and C are the bastard progeny .."
23:08:06 <wuxia> got it; thanks
23:08:36 <dmwit> wuxia: As a side note: those parentheses near `Union` `Union` probably aren't necessary.
23:09:01 <dons> "novitiates", instead of "novices" ?
23:09:38 <_zenon_> Look at this:
23:09:38 <_zenon_> http://www.informatik.uni-bonn.de/~ralf/WG2.8/24/slides/peter.pdf
23:09:40 <lambdabot> Title: Towards Interface Types for Haskell - Work in Progress
23:09:49 <_zenon_> Peter Thiemann, Towards Interface Files for Haskell. (Tue 2007-07-17, 15:00)
23:10:05 <dons> Files?
23:10:06 <ddarius> dolio: http://hopl.murdoch.edu.au/showlanguage2.prx?exp=2527
23:10:14 <_zenon_> "Haskell's type classes provide a closely related facility for stating an interface separately from its implementation. However, there is no simple mechanism to hide the identity of the implementation type of an interface as is often desired for constructing libraries. This work provides such a mechanism through the integration of lightweight existential datatypes into Haskell. A simple source-to-source transformation enables the use of interface types w
23:10:14 <_zenon_> ith subtyping in Haskell. "
23:10:22 <_zenon_> Sound interesting
23:10:33 <dons> right, that's how existentials are sued.
23:10:34 <dons> used.
23:12:36 <_zenon_> Well, might be a good introduction.
23:13:50 <dolio> ddarius: Do you know what the links are supposed to go to? They seem broken here.
23:14:01 <dolio> Is it the full text of the article or anything like that?
23:16:29 <_zenon_> Are there better texts for learning to use existential types?
23:16:35 <ddarius> dolio: Just google the article names.
23:16:57 <ddarius> dolio: E.g. "Maximum Subsegment Sum Derivation" is available on CiteSeer.
23:17:23 <vixey> why do you want to use existential types?
23:18:06 <dolio> Because existential types are awesome?
23:18:08 <_zenon_> http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types
23:18:09 <lambdabot> Title: Haskell/Existentially quantified types - Wikibooks, collection of open-content t ..., http://tinyurl.com/f9umb
23:18:14 <_zenon_> This didn't do the job on me
23:18:33 <ddarius> _zenon_: I'd recommend not worrying about them until you have a need for them.
23:19:03 <_zenon_> Is the threshold too high?
23:19:04 <vixey> oh I assumed there was some particular thing you wanted to do with them
23:19:16 <ddarius> _zenon_: No.  You just don't usually need them.
23:19:20 <_zenon_> vixey: No, just stretching the brain a bit.
23:19:33 <ddarius> _zenon_: I recommend not worrying about any extension unless you need it.
23:19:45 <_zenon_> ddarius: Well, doesn't hurt to know about elephants even though you might never see /touch them, :)
23:19:51 <vixey> _zenon_: look at my hpaste if you want something to be puzzled about :P
23:20:07 <_zenon_> vixey: Will it help me understanding it?
23:20:18 <vixey> (It's completely unrelated to existential types)
23:20:34 <dmwit> ddarius: It's hard to know when you need something until you know what it does.
23:21:01 <ddarius> dmwit: It's easy to know when you are not having any problems doing what you want.
23:21:30 <dmwit> ddarius: It's also easy to think you are not having problems because it didn't occur to you there might be a better way.
23:21:41 * dmwit used C++ happily for several years in a row
23:22:21 <Korollary> so many things are easy.
23:22:28 * _zenon_ sense a debate on knowledge and knowledge about knowledge heading this way
23:22:45 <dmwit> My knowledge is more meta than yours is.
23:22:51 <mmorrow> i was messing with this earlier http://hpaste.org/8918
23:23:01 <mmorrow> (re: forall/exists)
23:23:08 <dmwit> "I accept the assumption of positive introspection."
23:23:15 <Mr_Awesome> my knowledge is infinitely meta
23:24:03 <_zenon_> fix meta
23:24:10 <vixey> what do you do with it mmorrow?
23:24:19 <Mr_Awesome> heh
23:24:46 <mmorrow> i dunno, i wrote it because i wanted to look at the duality between them
23:24:52 <mmorrow> (with my eyes)
23:25:43 <mmorrow> i just realized that was the case about a week ago talking with ski and quicksilver
23:27:55 <mmorrow> one you have to unsafeCoerce on the way in...
23:28:06 <mmorrow> ..one you have to unsafeCoerce on the way out
23:28:42 <mmorrow> s/../..;/
23:28:44 <mmorrow> ahh
23:29:03 * mmorrow cuts his losses re punctuation
23:29:41 <vixey> I'm glad I got rid of all my uses of unsafe coerce
23:30:06 <vixey> I was mixing up two different concepts which is why I thought I had to coerce
23:31:04 <mmorrow> i was playing with you untyped lambda calc syntax/eval/unquote earlier and i came to a similar realization that i think you have
23:31:13 <mmorrow> *you're*
23:31:17 <mmorrow> geez
23:31:20 <mmorrow> your
23:31:25 <vixey> :))
23:31:28 <mmorrow> heh
23:31:29 * vixey laughs
23:31:34 <mmorrow> me too
23:32:51 <vixey> oh
23:32:52 <mmorrow> i've been trying to pin down exactly the situation(s) and circumstances that unsafeCoerce is needed/notnoncorrect/possible-to-use-for-gain/whatever
23:33:13 <vixey> mmorrow: I only really know of one example (that isn't part of GHC)
23:33:22 <vixey> which is the prompt implementation in LogicT
23:33:29 <mmorrow> because i think if you understand that that, then you understand everything
23:33:37 <mmorrow> hmm
23:33:47 <vixey> I want thoughts.. about what I could generate
23:33:59 <mmorrow> i haven't looked at the code of LogicT
23:34:10 <vixey> I am just getting an interpreter now but I was thinking about printing out java bytecode or something
23:35:04 <mmorrow> that reminds me, whoa, that hjs javascript interpreter. well, it actually an *interpreter*
23:35:10 <mmorrow> as in an executable
23:35:25 <mmorrow> i tried it today and was like "whoa"
23:35:27 * vixey has a look at it
23:35:37 <mmorrow> it's kinda messy though
23:35:56 <dolio> unsafeCoerce isn't needed for LogicT, per-se. It's needed for the implementation of delimited continuations that particular implementation of LogicT uses.
23:36:02 <mmorrow> (wrt not type sigs anywhere ==> no haddock docs of a bunch of function, etc)
23:36:27 <mmorrow> dolio: is that the same as the on in Control.Monad.CC.Prompt?
23:36:33 <dolio> Yeah.
23:36:33 <mmorrow> s/on/one/
23:36:42 <mmorrow> cool
23:37:18 <mmorrow> that was the first place i saw it used in a useful way (that and Pugs implem of the same)
23:37:24 <dolio> You use unsafeCoerce there because you have information in the values that tells you the types are correct, but you can't move that information to the type system, or something like that.
23:37:36 <vixey> omg http://lxr.mozilla.org/mozilla/source/js/narcissus/jsexec.js#238
23:37:36 <dolio> Same thing with ST.
23:37:37 <lambdabot> Title: mozilla/js/narcissus/jsexec.js
23:37:56 <dolio> But I'm not really clear on what sort of type system you'd need to eliminate the need for it.
23:38:18 <mmorrow> dolio: totally. that seems to be the (a?) general theme, but i can't precisely phrase it yet
23:39:06 <mmorrow> vixey: yeah, that's a good one. http://code.haskell.org/~morrow/code/js/narcissus/ ;)
23:39:06 <lambdabot> Title: Index of /~morrow/code/js/narcissus
23:39:08 <dolio> Yeah. Same with Typeable/Dynamic, really, although the representation is different.
23:39:24 <mmorrow> dolio: totally, i was actually just looking through that today
23:39:38 <dolio> And you can make a type-safe Dynamic if you make your TypeRep a GADT.
23:39:41 <dolio> But then it's not extensible.
23:40:07 <mmorrow> i want to exchange the tyCon or whatver Dynamic uses to the template-haskell Type type and do essesntially the same thing
23:40:21 <dolio> But, for instance, JHC sort of has an automatically built TypeRep which might work.
23:40:34 <dolio> So maybe you need type case or something.
23:40:43 <mmorrow> hmm, how do you mean?
23:40:53 <mmorrow> like having the type info around at runtime?
23:41:08 <mmorrow> ohh, yeah
23:41:11 <mmorrow> i remember
23:41:15 <dolio> Well, for instance, you can't do case analysis on types in Agda.
23:41:33 <dolio> But JHC uses it to implement type classes.
23:42:07 <mmorrow> there was that one comment in jhc that explained the situation with it's type and the possibility to manipulate them in non-forseen ways
23:42:17 <mmorrow> (either at compile-time *or* runtime(
23:42:35 <dolio> Yeah. He remarks that he could make a type-safe Dynamic with it.
23:42:43 <dolio> (I didn't think of that myself. :))
23:43:03 <mmorrow> i don't know how i'd completely forgotten about that
23:43:18 <mmorrow> dolio: totally, that was in a haskell-cafe post i think
23:43:41 <dolio> Yeah, I didn't come up with the GADT Dynamic, either.
23:44:13 <dolio> I did try using type families to build a type-safe Dynamic, but they're too static to get the job done.
23:45:04 <mmorrow> it seems to me that using a GADT for something like that and using eg   A = forall a. A a     or  A = A (forall a.a)     and unsafeCoerce   are equivalent
23:45:53 <mmorrow> equiv in that that's what really is happening with the GADT under the covers
23:46:25 <dolio> Well, yeah.
23:46:39 <mmorrow> dolio: yeah, i remember you posting about that
23:46:41 <dolio> The GADT lets values inform the type system.
23:47:02 <mmorrow> you had something like (or exactly) that equality GADT
23:47:02 <kosmikus> no. in the GADT, you actually compare tags at runtime. this gives you safety.
23:47:03 <dolio> You can do it manually, using your own values and unsafeCoerce.
23:47:31 <vixey> kosmikus: I thought the GADT would totally erase tags since safety is checked at compile time
23:47:43 <dolio> But there's always the chance that you'll screw up and unsafeCoerce when you shouldn't.
23:47:51 <mmorrow> kosmikus: hmm
23:48:01 <kosmikus> vixey: that'd be an optimisation, but I don't think it's performed.
23:48:03 <dolio> Whereas you only have to make sure your implementation of GADTs is kosher once.
23:48:19 <mmorrow> dolio: yeah, i'm assuming the unsafeCoercer is "infallible"
23:49:10 <mmorrow> ie is equiv to GHC doing it behind the GADT scenes
23:49:41 <mmorrow> "infallible"
23:49:56 <mmorrow> oh, i didn't realize i'd already quoted it
23:49:57 <mmorrow> heh
23:50:10 <mmorrow> segfault
23:50:26 <wuxia> you know; working through soe; i'm starting to actually wonder if lisp's obsession with prefix is actually right
23:50:43 <wuxia> somethings were just meant to be written in  infix, wo ()'s all over the place
23:50:44 <vixey> wuxia: Absolutely not
23:50:58 <vixey> wuxia: there is no 'right'
23:51:12 <dolio> Obviously postfix is right. :)
23:51:21 <TSC> And prefix is left
23:51:41 <dolio> Well played.
23:51:57 <mmorrow> yeah, i couldn't think of anything to add
