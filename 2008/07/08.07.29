00:00:17 <Trinithis> It's a restricted version of data.
00:00:31 <Trinithis> data always works. newtype is for efficeiency
00:00:33 <Pseudonym> Or, alternatively, a more powerful typedef.
00:00:57 <humasect> sometimes it feels like i know nothing at all, yet things still seem to happen and work perfectly. so for example .. <hpasting>
00:03:25 <humasect> http://hpaste.org/9221
00:04:12 <Trinithis> newtype Type2 = Type2 deriving (Show,Read)?
00:04:16 <humasect> it is difficult to search for haskell syntax information with google; perhaps i do lack formal vocabulary
00:04:35 <Trinithis> in english, what is Type2?
00:05:01 <cjs> Looks to me that there are two different Type2s, in different modules.
00:05:22 <humasect> sorry, that second one with newtype should be Type2B. Trinithis: i don't know the syntax for using newtype. the goal here is to add Read instance for the first type
00:05:23 <sjanssen> Trinithis: Type2 means two different things, depending on context.
00:05:46 <sjanssen> Trinithis: in one context Type2 is a type, in another context Type2 is a data constructor
00:06:34 <Trinithis> sry, I was asking humasect sophically(?)
00:06:37 <humasect> hm i see .. so the type itself (class syntax) may have nothing to do with the problem itself
00:06:46 <sjanssen> humasect: sorry, you can't do that in Haskell
00:07:21 <humasect> hmm is that so
00:07:48 <sjanssen> there is a proposed extension called "standalone deriving", but I don't know if it made it into GHC
00:08:05 <humasect> ah i see
00:08:29 <sjanssen> hey, it is in GHC!  http://www.haskell.org/ghc/dist/current/docs/users_guide/type-extensions.html#stand-alone-deriving
00:08:30 <lambdabot> Title: 7.4. Type system extensions, http://tinyurl.com/25mnwa
00:08:44 <humasect> oh, wow =) =)
00:08:49 <humasect> this looks really good.
00:10:08 <codacola> hello all
00:10:32 <hml> what's the parser error in the following?
00:10:33 <hml> data Boundary a = Boundary a a
00:10:33 <hml> intersect :: Boundary a -> Boundary a -> Boundary a
00:10:33 <hml> intersect (lower1 upper1) (lower2 upper2) = Boundary (max lower1 lower2, min upper1 upper2)
00:11:03 <sjanssen> hml: you need to pattern match on the constructor, (Boundary lower1 upper1)
00:11:20 <hml> sjanssen: ah; thanks
00:11:31 <vixey> Boundary (max lower1 lower2, min upper1 upper2) should be Boundary (max lower1 lower2) (min upper1 upper2) as well
00:11:34 <vixey> that's not a parse error thouh
00:12:10 <humasect> sjanssen: do you know, if these are all -fglasgow-exts, but what version of docs are these? current = what version?
00:12:53 <adu> is there any -X option for mdo? or do you have to use -fglasgow-exts?
00:13:09 <hml> s
00:13:23 <sjanssen> hml: and on the RHS of =, Boundary is a function of two arguments, not a tuple
00:13:23 <sjanssen> humasect: 6.8, I think?
00:13:23 <sjanssen> humasect: old manuals are still online, so you can track down when they were added
00:13:26 <sjanssen> adu: RecursiveDo?
00:14:32 <humasect> sjanssen: thanks, so far it is parse error
00:14:59 <adu> sjanssen: o ic
00:16:13 <vixey> what's going on
00:17:36 <chrisdone> what's goi- * chrisdone has quit []
00:17:51 <humasect> sjanssen: a little update, it is different here : http://www.haskell.org/ghc/dist/current/docs/users_guide/deriving.html
00:17:52 <lambdabot> Title: 8.5. Extensions to the "deriving" mechanism, http://tinyurl.com/5gscp4
00:22:26 <vixey> hi conal
00:22:48 <sjanssen> @remember augustss Haskell is about making sense, not just providing an operation because it's possible. We leave that to other languages.
00:22:48 <lambdabot> Okay.
00:22:54 <vixey> you wrote a lot of papers I liked :p
00:23:12 <vixey> I just read semi-functional implementation of higher order logic programming yesterday
00:23:30 <vixey> it's very cool stuff
00:23:49 <humasect> thanks, sjanssen =)
00:25:07 <hml> is there a way that I can force a "(Ord a)" into: data Boundary a = Boundary a a /?
00:25:17 <sjanssen> @quote augustss
00:25:17 <lambdabot> augustss says: Haskell boggles my mind too. :)
00:25:21 <sjanssen> @quote augustss
00:25:22 <lambdabot> augustss says: Given that strength of the Haskell type system it wouldn't be that hard to write a compiler from some language into a Haskell type.
00:25:22 <vixey> hml: there's no need to
00:25:37 <vixey> hml: haskell will just infer the Ord in any use of boundry which requires it
00:25:57 <chrisdone> b
00:26:07 <chrisdone> uh, thought I was in emacs
00:28:01 <hml> vixey: hmm, it forces me to say (Ord a) => in all functions that use Boundary a
00:28:06 <hml> which seems like lots of needless repetition
00:28:12 <vixey> hml: yes I agree
00:28:19 <vixey> hml: don't write them
00:28:33 <vixey> when you write
00:28:36 <vixey> f :: a -> b
00:28:38 <vixey> f x = y
00:28:40 <vixey> instead,
00:28:43 <vixey> just write:
00:28:44 <vixey> f x = y
00:28:52 <BeelsebobWork> argh
00:28:55 <vixey> and haskell will figure out f :: a -> b, you don't have to put it down
00:28:57 <BeelsebobWork> worst... advice... ever
00:29:13 <BeelsebobWork> "don't document your code"
00:29:18 <hml> vixey: I like to state type specs for functions
00:29:27 <hml> BeelsebobWork: I agre with you
00:29:42 <vixey> hml: k... no clue why you are complaining about having to write them then
00:29:49 <sjanssen> hml: you can also use an editor macro to insert the type automatically
00:29:58 <hml> i just wsant want to be foreced to repeat (Ord a) =>
00:30:07 <BeelsebobWork> I agree with vixey on that one -- don't complain about writing accurate docs if you want to write docs
00:30:08 <osfameron> BeelsebobWork: I don't think people seriously offer that as advice.  I've read "don't overdocument your code to minute detail, but clarify the *purpose* when not clear from the code" and similar
00:30:39 <osfameron> my favourite documentation is API docs where I can just say "here's an example call, and here's an example of the data structure it returns"
00:30:46 <BeelsebobWork> osfameron: yeh, in general the type signature is the most lightweight and most informative bit of documentation on any bit of Haskell code though
00:30:58 <osfameron> if I'm named the calls correctly then that's usually enough
00:31:32 <osfameron> BeelsebobWork: really?  Actually I find the haskell type sig less useful than many languages', because the types aren't named.  That's a *big* piece of metadata that you're missing
00:31:39 <sjanssen> bleh, examples are 0-order documentation, proper English descriptions are higher order :)
00:31:51 <BeelsebobWork> osfameron: you're doin it rong if you're not using type synonyms to name your types
00:31:59 <osfameron> BeelsebobWork: ah, true
00:32:04 <BeelsebobWork> sjanssen: agreed
00:32:08 <BeelsebobWork> examples are easily misinterpretted
00:32:10 <BeelsebobWork> types aren't
00:32:35 <codacola> why is the named "higher order" given that functions that take functions as arguements?
00:32:44 <|Steve|> Except for stupid names like ShowS.
00:33:08 <|Steve|> s/names/types/
00:33:34 <BeelsebobWork> codacola: because it's not 0-order -- a 0 order function is a function with no functions in its types... a 1-order function is a function with 1 level of functions in it's types, higher order functions are functions that are anywhere above 1-order
00:33:34 <humasect> Mrs. -XStandaloneDeriving has solved many things tonight.
00:33:42 <vixey> BeelsebobWork, it's haskell not java
00:33:55 <codacola> beelsebob, ah, so . is a 2nd order function?
00:33:59 <BeelsebobWork> vixey: and you don't have to document Haskell?
00:34:08 <BeelsebobWork> codacola: no, still first order
00:34:26 <BeelsebobWork> a second order function would be one that took (.) as an argument or returned (.)
00:34:27 <conal> vixey: hi
00:35:42 <osfameron> BeelsebobWork: examples + useful return data structure is fairly clear
00:36:10 <chrisdone> http://hpaste.org/9222 <-- a derive HTML would be cool
00:36:12 <conal> vixey: thanks!  oh, lamba-prolog.  that was fun stuff!
00:36:14 <BeelsebobWork> osfameron: I've spent the past 3 weeks trying to parse a file format that's documented entirely by examples, rather than an accurate description of it's structure
00:36:18 <BeelsebobWork> it's *not* good documentation
00:36:19 <osfameron> I'm not arguing that proper description is useless, just that you get an awful lot of value out of a very trivial copy/paste of an example
00:36:23 <sjanssen> osfameron: f 1 1 -> 2 -- please explain what f does
00:36:38 <BeelsebobWork> it's some of the worst documentation I've come across
00:36:48 <osfameron> sjanssen: tricky.  But if I saw:  add 1 1 -> 2   I would have a very good idea
00:37:14 <johnnowak> BeelsebobWork: i've never heard of composition as being a first order function before
00:37:43 <BeelsebobWork> johnnowak: it takes zero-order functions and returns zero-order functions
00:37:46 <BeelsebobWork> sounds first order to me
00:38:41 <BeelsebobWork> if you take into account currying it becomes two-order I guess
00:38:59 <johnnowak> well iv'e also never heard of a zero order function before
00:39:27 <osfameron> BeelsebobWork: ok, maybe it isn't enough.  But I find it sufficiently useful that I usually add it as the first step while documenting legacy or new code.
00:39:30 <conal> BeelsebobWork: where did you get that notion of order?  i think of base types as 0-th order and functions on base types as first order.  (etc.)
00:39:43 <johnnowak> conal: aye
00:39:45 <BeelsebobWork> conal: actually, that makes a lot more sense
00:39:54 <BeelsebobWork> in terms of treating values and functions as equal
00:40:05 <johnnowak> BeelsebobWork: so you were just making this up then?
00:40:35 <BeelsebobWork> johnnowak: no, I'm just getting a fence-post error caused by first thing in the morning
00:40:53 <johnnowak> codacola: well there you go then. composition is second order.
00:41:12 <johnnowak> i'm not trying to be a pedant, just trying to avoid confusion
00:42:02 <codacola> johnnowak: heh here i was thinking i didnt understand :P thanks
00:42:12 <codacola> just been bugging me "why such a silly name"
00:42:16 <BeelsebobWork> sorry 'bout that codacola
00:42:36 <codacola> stallman is coming to nz :D
00:42:41 <johnnowak> i'm sorry
00:42:43 <chrisdone> programmers, talking about higher order functions‽ dijkstra wouldn't have liked this
00:43:06 <codacola> who the hell is dijkstra?
00:43:14 <johnnowak> codacola: some blogger
00:43:21 <codacola> a weird one?
00:43:26 <johnnowak> horribly.
00:43:38 <chrisdone> “web 2.0 considered harmful”
00:43:46 * johnnowak chortles
00:44:20 <vixey> codacola: You should treat yourself to the book A Dicipline of Programming
00:44:31 <johnnowak> codacola: http://en.wikipedia.org/wiki/Edsger_Dijkstra
00:44:32 <lambdabot> Title: Edsger W. Dijkstra - Wikipedia, the free encyclopedia
00:44:32 <codacola> why?
00:46:05 <codacola> vixey: is it related to functional porogramming? :P
00:47:01 <johnnowak> codacola: you know, the original "FP" language purposely avoided first class functions.
00:47:35 <chrisdone> what was the original “FP” language?
00:47:39 <johnnowak> FP.
00:47:56 <earthy> was it?
00:48:09 <johnnowak> i suppose it's a question of definition
00:48:13 <cjs> Is it possible to have a class value within a data structure? E.g., data Foo = Foo { v :: (Eq a) => a }
00:48:26 <earthy> I'd say lisp predates it...
00:48:34 <vixey> cjs: there's no point in doing that
00:48:41 <codacola> my head hurts
00:48:43 <cjs> Why's that?
00:48:45 <earthy> as dus ml
00:48:47 <codacola> too much haskell last night
00:48:50 <earthy> s/dus/does/
00:48:51 <codacola> not enough sleep
00:48:55 <vixey> cjs: haskell can just infer it
00:49:18 <cjs> From where?
00:49:34 <vixey> cjs: any uses of Foo that requires Eq on a, it will be inferred
00:49:48 <johnnowak> earthy: that's true, but if lisp is functional is debatable. obviously mccarthy's original formulation is, but not any of the early implementations as far as I know. FP was actually implemented and talked about as being "functional".
00:49:57 <cjs> If I do { val :: a }, I get "Not in scope: type variable `a'".
00:50:06 <vixey> you must write
00:50:11 <vixey> data Foo a = Foo { val :: a }
00:50:16 <vixey> the type parameter comes from there
00:50:22 <cjs> Ah!
00:50:25 <johnnowak> of course everyone took backus's work and added all these silly variables to it.
00:51:03 <chrisdone> variables? formal parameters?
00:51:08 <catface> is it possible to have a higher-order function that does different things depending on the arity of what it's applied to?
00:51:24 <johnnowak> catface: give an example of "different"
00:51:41 <cjs> vixey: But then I can't have a list of Foo a with different as, can I?
00:51:54 <vixey> cjs: No you cannot do that
00:52:28 <cjs> Basically, I've got what would normally be called an "opaque data type"; a function generates it, and it only ever gets passed back to that function or one other, and I'd like to handle these generically.
00:52:39 <cjs> But I guess that breaks the type system, doesn't it?
00:52:56 <vixey> it's possible to break the typesystem
00:53:11 <cjs> Unless I use a class, maybe....
00:53:11 <trinisoftinc> anyone home?
00:53:13 <vixey> wanting to do so is an indication that something else is wrong though
00:53:23 <cjs> Right. I don't want to break the type system.
00:53:47 <glguy> cjs: Does the Foo typeclass have multiple functions in it?
00:54:49 <cjs> Actually, what I have a couple of specific "send feed data to your thing in your format" functions, and a generic feed system that calls these.
00:55:15 <cjs> However, my issue is that I don't want to be resending the the message if it's the same as the last one.
00:56:01 <bos> @hoogle digitToInt
00:56:02 <lambdabot> Data.Char.digitToInt :: Char -> Int
00:56:47 <cjs> But I'm starting to think I should just do a few things to make this stuff a little less generic in one direction, so I can get the "generic" framework to do more message-specific work, and then go back again when I have other message types a week down the road.
01:04:18 <acer_> Hi, which library do I need to load when getting 'Undefined variable "ord"' using hugs?
01:04:26 <vixey> Data.Char
01:05:18 <acer_> thx but  there is an error
01:05:20 <hml> @src foldr
01:05:20 <acer_> ERROR - Unable to open file "Data.char"
01:05:20 <lambdabot> foldr f z []     = z
01:05:20 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
01:05:41 <hml> @src foldl
01:05:42 <lambdabot> foldl f z []     = z
01:05:42 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
01:05:47 <chrisdone> acer_: are you using :m or :l?
01:05:49 <acer_> i do not know the trace
01:05:52 <acer_> :l
01:05:53 <hml> which is more efficiednt, foldr or foldl?
01:05:54 <acer_> ahh k
01:05:54 <chrisdone> acer_: it's Data.Char, btw
01:05:59 <ziman> capital C
01:06:05 <acer_> ohh sry
01:06:14 <vixey> hml: doesn't make sense to ask that
01:06:32 <acer_> ERROR - Cannot find module "Data.Char"
01:06:41 <johnnowak> vixey: why not?
01:06:45 <acer_> :(
01:06:48 <hml> if I want to implement sum
01:06:52 <hml> is foldr or foldl faster
01:07:04 <hml> @src sum
01:07:05 <lambdabot> sum = foldl (+) 0
01:07:08 <vixey> :t (foldr,foldl)
01:07:10 <lambdabot> forall a b a1 b1. ((a -> b -> b) -> b -> [a] -> b, (a1 -> b1 -> a1) -> a1 -> [b1] -> a1)
01:07:50 <hml> one of these should be able to consume the list along the way
01:08:43 <hml> 8it's fo9ldl
01:08:50 <hml> foldl can use tail call recursion, foldr .. can not
01:09:57 <earthy> hm. foldl leaks memory due to having to keep the list of + thunks active in memory until it hits the end of the list
01:10:21 <earthy> foldl' (the strict version) does have the advantage you're thinking of.
01:10:22 <johnnowak> hml: it's not so simple in a lazy language
01:10:33 <johnnowak> of course vixey can explain to you why all this makes no sense to ask
01:10:40 <johnnowak> any minute now
01:10:49 <vixey> johnnowak: I already did
01:10:50 <vixey> :t (foldr,foldl)
01:10:51 <lambdabot> forall a b a1 b1. ((a -> b -> b) -> b -> [a] -> b, (a1 -> b1 -> a1) -> a1 -> [b1] -> a1)
01:10:56 <vixey> johnnowak: pay some attention
01:10:58 <johnnowak> no you didn't.
01:11:28 <johnnowak> what's that have to do with folding over (+)?
01:11:49 <vixey> johnnowak: Nothing, nobody mentioned (+) I was not talking about sum
01:12:14 <johnnowak> so then it *might make sense* then, eh? assuming you can use either, one may be more efficient.
01:12:29 <vixey> johnnowak: No, You've mixed up the chain of events
01:12:36 <johnnowak> and he said he wanted to implement sum *before* you gave the types of the two.
01:14:05 <acer_> vixey
01:14:23 <hml> @src foldl
01:14:23 <lambdabot> foldl f z []     = z
01:14:23 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
01:14:52 <acer_> u know t eplace were the Data.Char is located by Using Linux`
01:14:53 <acer_> ?
01:17:18 <Saizan> acer_: maybe in your version is called Char
01:26:58 <mjrosenb> ghc-6.8.3: panic! (the 'impossible' happened)
01:27:00 <mjrosenb> sexy
01:29:22 <olsner> yeah, compilers are so sexy when they fail
01:29:38 <olsner> nah, strike that, they're *always* sexy
01:29:44 <olsner> compilers <3
01:35:48 <benpicco> Hi, I wonder if that's the right channel, but how to I get hugs to load certain things at startup? (linux)
01:36:38 <ayianus> You mean things like libraries?
01:36:46 <benpicco> yes
01:37:10 <ayianus> load <libname>.hs ?
01:39:02 <benpicco> erm, yes, but directly in the intergreter, also some settings would be nice (so I don't have to type :s -Enano over and over again ;-)
01:39:23 <mjrosenb> benpicco: .ghci
01:39:58 <cjs> This is my first use of a monad transformer. Can anybody explain this error to me? http://hpaste.org/9224
01:40:22 <benpicco> mjrosenb, and hugs?
01:40:36 <cjs> I thought that an ErrorT String IO a was supposed to operate just as an Either String a except that I could use liftIO to do IO operations as well.
01:40:38 <mjrosenb> benpicco: erm... .hugsrc?
01:41:18 <benpicco> mjrosenb, there is no such thing in ~
01:41:23 <benpicco> neither in /etc
01:43:09 <cjs> Or now everything I use <- on has to be an ErrorT String IO a as well?
01:43:55 <agentzh> hi, can i define my own read function for my own types belonging to the typeclass Read?
01:44:10 <mjrosenb> well you can't change the type of monad you're in within a single do block
01:44:27 <agentzh> i'm getting the error "read is not a visible function"
01:44:30 <MyCatVerbs> agentzh: you can define a new data type, and then give a Read instance for it.
01:44:32 <rwbarton> cjs: That's right.  There's not enough IO on that line
01:44:34 <cjs> so maybeError needs to be ErrorT String IO a as well, then.
01:45:09 <agentzh> MyCatVerbs: like "instance Read MyType where read _ = MyTypeVariant" ?
01:45:41 <cjs> Can I use a lift or something to fix it?
01:45:53 <agentzh> MyCatVerbs: i'm getting "    `read' is not a (visible) method of class `Read'"
01:46:04 <MyCatVerbs> agentzh: huh, that's odd.
01:46:14 <agentzh> ...
01:46:43 <mjrosenb> MyCatVerbs: i don't think that's an error message
01:47:07 <agentzh> mjrosenb: why?
01:47:19 <agentzh> mjrosenb: ghc aborted :(
01:47:29 <lomeo> agentzh: define readsPrec
01:48:13 <mjrosenb> ok, evidently i missed the error message in there
01:48:24 <mjrosenb> i'm going to go to sleep now
01:49:05 <agentzh> lomeo: thanks, i've got a bit further :)
01:49:16 <agentzh> lomeo: tackling another type error :)
01:49:28 <lomeo> agentzh: what kind of?
01:50:56 <agentzh> lomeo: caused by some other places...it's a big file... :P
01:51:23 <agentzh>     Couldn't match expected type `String -> [(DataFormat, String)]'
01:51:24 <agentzh>            against inferred type `DataFormat'
01:51:40 <agentzh> seems i'm not defining readsPrec the right way :)
01:53:12 <lomeo> agentzh: ok :) so, good luck!
01:55:19 <agentzh> lomeo: thanks :) i'm reading about ReadS :)
01:57:59 <lomeo> agentzh: it's just a synonym for String -> [(a, String)]. The list is for parsed alternatives and second element of tuple is the rest of input string. `a` is a type of parsed value.
01:58:25 <agentzh> lomeo: *nod*
02:03:16 <agentzh> lomeo: it seems defining a custom read method is more difficult than i though :( i'd use lookup instead...
02:03:22 <agentzh> *thought
02:08:11 <lomeo> agentzh: take a look at lex
02:08:18 <lomeo> :t lex
02:08:20 <lambdabot> String -> [(String, String)]
02:08:41 <lomeo> may be it'll be helpful.
02:09:28 <agentzh> lomeo: okay :)
02:10:31 <agentzh> instance Read () where
02:10:31 <agentzh>     readsPrec _ r = [((),t) | ("(",s) <- lex r,
02:10:31 <agentzh>                               (")",t) <- lex s ])
02:10:38 <agentzh> found a little example :)
02:10:41 <agentzh> read for () :)
02:14:39 <mmorrow> agentzh: http://hpaste.org/9225
02:14:47 <mmorrow> agentzh: derive it!
02:15:44 * agentzh 's eyes glaze over...
02:15:56 <mmorrow> derive -dRead MyType.hs
02:15:59 <mmorrow> done
02:16:25 <mmorrow> :)
02:16:42 <agentzh> mmorrow: got it
02:17:57 <mmorrow> agentzh: derive is pretty awesome, it also does Show,Binary,Arbitrary,Typeable,Data,...
02:18:15 <DRMacIver> Are updates to IntMap known to be particularly slow? (They seem to be in my implementation of the same data structure in another language and I was wondering if this was typical)
02:18:23 <agentzh> mmorrow: hmm...but i'm wondering how it solves my problem :P what i want is merely something like instance Read Foo where read "foo" = FooVal
02:19:11 <agentzh> mmorrow: thanks for the info on the derive stuff. indeed cool, though i'm not sure it solves the problem offhand :P
02:19:18 <mmorrow> oh, i just switched over and my excitement about derive go t the better of me when i saw Read and derive in the same sentence
02:19:48 <mmorrow> agentzh: so you want to derive an instance of Read for Foo then?
02:20:09 <agentzh> paczesiowa: everything you said was indeed true :)
02:20:23 <agentzh> mmorrow: exactly :)
02:20:55 <mmorrow> agentzh: can you hpaste the definition of your datatype?
02:21:45 <paczesiowa> agentzh: about what? I just got up
02:22:27 <agentzh> paczesiowa: about those HXL stuffs
02:22:48 <agentzh> mmorrow: a sec
02:23:00 <agentzh> i'll use the hpaste thingy
02:23:20 <mmorrow> cool
02:23:28 <mmorrow> @src Read
02:23:28 <lambdabot> class Read a where
02:23:28 <lambdabot>   readsPrec    :: Int -> ReadS a
02:23:28 <lambdabot>   readList     :: ReadS [a]
02:23:28 <lambdabot>   readPrec     :: ReadPrec a
02:23:28 <lambdabot>   readListPrec :: ReadPrec [a]
02:23:40 <mmorrow> (also, read isn't in Read)
02:23:42 <paczesiowa> agentzh: so have you managed to do it? because I think I said a lot of things, most of them opposite ideas
02:25:35 <agentzh> mmorrow: http://hpaste.org/9226
02:25:36 <mmorrow> @src read
02:25:36 <lambdabot> read s = either error id (readEither s)
02:26:33 <agentzh> paczesiowa: nope, eventually ran out of tuits :P
02:27:32 <agentzh> paczesiowa: the last solution i could think of was to attach an extra attr to each xml node
02:27:51 <agentzh> paczesiowa: but it was already getting inelegant
02:28:13 <mmorrow> agentzh: http://hpaste.org/9226#a1
02:29:33 <paczesiowa> agentzh: I can't remember if I told you that, but creating your own Tree type (wit ancestors list) would work, but you'd have to rewrite 1 or 2 modules of hxt (changing types mostly plus some praying that it doesn't create subtrees in way that forget their heritage that you'd have to fix like regular code monkey)
02:29:47 <agentzh> mmorrow: so read "yaml" won't yield DFYaml ?
02:30:32 <agentzh> paczesiowa: yup...that's too much work for a scheduled 2-hours playing...
02:30:39 <paczesiowa> agentzh: I wanted it to try myself, but it was boring and it would probably be very slow
02:30:47 <agentzh> paczesiowa: indeed
02:31:03 <agentzh> paczesiowa: might be slower than my original perl and javascript implementations :)
02:31:17 <chrisdone> ahhh-tusho
02:31:20 <agentzh> paczesiowa: but speed is my main motivation to try haskell
02:31:25 <tusho> chrisdone: oh no
02:31:31 <agentzh> paczesiowa: and...yeah, elegance as well
02:31:45 <paczesiowa> agentzh: but I figured better way, just email hxt's author - if you're lucky you'll have new module in next release of hxt:>
02:31:56 <BONUS> eh, speed really isnt important in this day and age
02:31:59 <agentzh> paczesiowa: indeed! :)
02:32:27 <chrisdone> BONUS: in my day we were patient
02:32:33 <agentzh> BONUS: if and only if you run it again and again on a production environment ;)
02:32:37 <paczesiowa> just like the best haskell optimizer is getting dons interested in fixing it
02:32:39 <BONUS> haha
02:32:39 <agentzh> *you don't
02:35:09 <augustss_> yo!
02:35:59 <chrisdone> hey augustss_
02:36:35 <augustss_> I wonder if I'm the only Haskeller in Mongolia. :)
02:36:56 <cjs> One hopes so! :-)
02:37:31 <cjs> Or did you have some particular people in mind you wanted to send there?
02:37:40 <chrisdone> I'm on the moon
02:37:46 <chrisdone> getting Internet up here is a nightmare
02:38:56 <augustss_> Nothing wrong here.  Sun is shining, pleasent weather.  But very dreary Soviet architecture.
02:44:28 <|Steve|> You people are good at tearing down walls right? Tear down the soviet architecture and build new things.
03:01:18 <hml> how do i pattern match inside of a list comprehehsngion?
03:01:27 <hml> [ some_array ! i | i <- some_list ]
03:01:36 <hml> some_array ! i ... returns me an object of type Blah foo bar
03:01:43 <hml> except, foo / bar aren't named records
03:01:56 <hml> how can I do something like Blah a b -> a ? on the "some_array !i"
03:02:03 <hml> i.le. the long way to write this would be
03:02:13 <hml> some_func (Blah a b) -> a
03:02:24 <hml> [some_func (some_array ! i) | i <- some_list]
03:02:38 <hml> but is there a way i can get htis in on one line?
03:04:07 <agentzh> is there a func to turn a bytestring to lowercase only?
03:05:00 <Toxaris> hml: use case
03:05:23 <Toxaris> hml: [case some_array ! i  of Bla a b -> a | i <- some_list]
03:05:49 <hml> Toxaris: cool; thanks
03:09:00 <solrize> @seen dcoutts
03:09:00 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-soc, #haskell-overflow, #ghc and #haskell. I last heard dcoutts speak 9h 53m 59s ago.
03:09:08 <dcoutts> hia solrize
03:18:53 <hackage> Uploaded to hackage: yi 0.4.3
03:22:48 <chrisdone> cabal: ghc-pkg describe * failed. If you are using ghc-6.9 and have an empty
03:22:48 <chrisdone> user package database then this is probably due to ghc bug #2201. The
03:22:49 <chrisdone> workaround is to register at least one package in the user package db.
03:22:59 <chrisdone> how do I register a package when this keeps popping up?
03:25:29 <dcoutts> chrisdone: either help us implement the ghc-pkg dump feature in Cabal, or use the workaround of registering at least one package first.
03:25:52 <dcoutts> ghc-pkg register
03:26:41 <chrisdone> I'm not sure how to register a package, I'm used to doing “run haskell configure/build/install”; but the configure gives me that message -- is there another way?
03:26:51 <dcoutts> using ghc-pkg register
03:27:13 <chrisdone> ghc-pkg register {filename
03:27:16 <chrisdone> what is the contents of the file?
03:27:58 <dcoutts> the output of cabal register --gen-pkg-config or the output of ghc-pkg describe foo
03:28:41 <chrisdone> ah, thanks
03:29:54 <chrisdone> mmmkay. I used “--force” because it couldn't find “base” among 20 others
03:31:31 <chrisdone> I don't see why it can't find base
03:31:43 <chrisdone> isn't that supposed to come with ghc?
03:33:04 <dcoutts> it does, yes
03:33:09 <chrisdone> mmorrow: how did you get around this?
03:34:42 <chrisdone> well, I can see base in my filesystem
03:41:05 <hml> is there a good webmail implementation in haskell? or a way to connect to a running mail server
03:43:08 <mmorrow> chrisdone: i don't remember how or if i had to...
03:43:17 <mmorrow> The Glorious Glasgow Haskell Compilation System, version 6.9.20080504
03:43:43 <dozer> mm, I'm getting Overlapping instances problems
03:43:59 <dozer> @paste
03:43:59 <lambdabot> Haskell pastebin: http://hpaste.org/new
03:44:23 <ayianus> Erm. Is there some sort of not-so-gentle introduction to Haskell? One that's perhaps rather mathematical? I am not very satisfied with those "go through tons of examples"-types of tutorials.
03:45:03 <paczesiowa> you can read ghc sources
03:45:35 <ayianus> Say, I stumble upon something I can't identify, paczesiowa, where can I look up what it means?
03:45:50 <ayianus> Or what's it's good for.
03:45:52 <Zao> The wiki, perhaps?
03:45:54 <chrisdone> mmorrow: hmm, seems mine is a newer version than yours (6.9.20080719)
03:46:09 <Zao> You could perhaps dig into how the STG machine works?
03:46:12 <dozer> http://hpaste.org/9229
03:46:59 <Zao> Heck, the Haskell Report may offer insight.
03:47:01 <mmorrow> chrisdone: the YYYMMDD gets incremented quite often
03:47:33 <mmorrow> s/YYY/YYYY/
03:47:42 <paczesiowa> dozer: you can fix that with -fOleg and IsFunction trick
03:48:19 <dozer> paczesiowa: oh? URL for this trick?
03:48:37 <paczesiowa> http://okmij.org/ftp/Haskell/isFunction.lhs
03:48:59 <Deewiant> -fOleg :-D
03:49:12 <mmorrow> agentzh: ah, i forgot to link this: http://hpaste.org/9226#a2
03:49:20 <chrisdone> mmorrow: well, I guess I'll try fixing it later. I already need sleep but I can stay up if I'm working on code, but being presented with a weird error makes me notice my tiredness
03:49:33 <mmorrow> agentzh: i haven't tested it, but i *think* it'll work
03:49:35 <paczesiowa> dozer: here are more examples: http://okmij.org/ftp/Haskell/typecast.html
03:49:36 <lambdabot> Title: Type improvement constraint
03:50:02 <paczesiowa> dozer: that looks scary, but you don't have to understand, just copy the code and adjust to your problem and voila
03:50:04 <mmorrow> chrisdone: oh, i thought you got it straightened out
03:50:06 <dozer> thanks paczesiowa - I will read and try to understand.
03:50:34 <mmorrow> chrisdone: sleep is a nice thing
03:51:10 <agentzh> mmorrow: looking, thanks!
03:51:27 * agentzh is busy coding haskell for his fastcgi app.
03:51:33 <mmorrow> chrisdone: (but overrated ;))
03:51:40 <mmorrow> agentzh: cool
03:52:21 <agentzh> it's kinda sad that bytestring does not offer a dropUtil function :((
03:52:22 <paczesiowa> dozer: what do you know, you can fix that with -fallow-overlapping-instances :>
03:52:41 <agentzh> have to use tail . dropWhile :((
03:53:32 <dozer> paczesiowa: ah, awesom
03:53:58 <dozer> my last attempt at this code failed with -fallow-overlapping-instances
03:54:34 <paczesiowa> dozer: I thought you already use it (since you have undecidable instances alrady)
03:56:40 <dozer> seems i've improved something along the line
04:02:02 <paczesiowa> dozer: and sorry for scaring you with that typecast tricks, I've used it too much (it's needed with mptc and fundeps) that I forgot how to solve problems with old sptc
04:02:31 <dozer> paczesiowa: no problem - I've been away from haskell for 6 months now, so am a bit rusty
04:16:24 <chrisdone> mmorrow: well I feel better after a bowl of cereal
04:17:30 <benpicco> Hi, what do the ` to? (e.g. 6 `mod` 4 -> mod 6 4), do they only work for functions with two parameters?
04:17:49 <EvilTerran> it lets you use an alphanumeric name infix
04:17:56 <EvilTerran> it doesn't have to be two parameters
04:18:22 <EvilTerran> > foldr f e [x,y,z] :: Expr
04:18:23 <lambdabot>  f x (f y (f z e))
04:18:33 <EvilTerran> > (f `foldr` e) [x,y,z] :: Expr
04:18:34 <lambdabot>  f x (f y (f z e))
04:18:40 <EvilTerran> (contrived example, i know)
04:18:48 <benpicco> thank you
04:18:50 <EvilTerran> > negate 7
04:18:51 <lambdabot>  -7
04:18:56 <EvilTerran> > (7 `negate`)
04:18:57 <lambdabot>  -7
04:19:10 <EvilTerran> :)
04:19:16 <benpicco> cool bot
04:19:29 <EvilTerran> ?bot
04:19:30 <lambdabot> :)
04:21:26 <EvilTerran> writing map (or fmap) infix with ``s is quite popular
04:22:25 <EvilTerran> > (f `either` g) `map` [Left x, Right y, Left z] :: [Expr] -- i also like writing `either` infix, even though it's not two-parameter
04:22:26 <lambdabot>  [f x,g y,f z]
04:23:00 <EvilTerran> ?src either
04:23:00 <lambdabot> either f _ (Left x)     =  f x
04:23:00 <lambdabot> either _ g (Right y)    =  g y
04:23:34 <EvilTerran> its first two parameters are associated with "left" and "right" respectively, so it kinda makes sesne
04:30:43 <Toxaris> > succ `id` 3 -- you can even use functions of 1 parameter infix :)
04:30:45 <lambdabot>  4
04:34:34 <Dzlk> > succ `map` [1..5]
04:34:36 <lambdabot>  [2,3,4,5,6]
04:36:21 <Dzlk> :t max `foldl` 0
04:36:22 <lambdabot> forall a. (Num a, Ord a) => [a] -> a
04:39:12 <AJ_> :t either
04:39:13 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
04:43:42 <kpreid> We've got either, what about both?
04:44:22 <Cale> both is called uncurry
04:44:27 <chrisdone> ghc-pkg: dependency base-3.0.2.0 doesn't exist (use --force to override)
04:44:31 <Cale> :t uncurry
04:44:31 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
04:44:50 <chrisdone> how do I register the base package? I can see the directory which it is in
04:45:16 <kpreid> Cale: huh, so it is. I was thinking of Control.Arrow.***, but uncurry is a better fit
04:45:59 <Cale> chrisdone: whoa, how'd you lose your base package? Er... 3.0.2.0?
04:46:13 <Cale> Oh, right, I still have 6.8.2 on this machine :)
04:46:36 <codacola> hello one and all
04:46:43 <chrisdone> Cale: hehe. yep, ghc 6.9.20080719 here
04:46:55 <Cale> 6.8.3 has 3.0.2.0 as well
04:47:13 <chrisdone> Cale: have you installed 6.9 before? suddenly the packages are completely empty
04:47:15 <Cale> ghc-pkg register filename
04:47:24 <chrisdone> Cale: yeah, the files are there but it's not registered
04:47:33 <chrisdone> I've got a directory, I don't see a .conf file
04:47:40 <Cale> odd
04:47:57 <chrisdone> where might the .conf be?
04:48:49 <Cale> well,  lib/ghc-*/package.conf and ~/.ghc/*/package.conf  are where the big conf files are usually
04:48:58 <Cale> But I don't know about for individual packages
04:49:09 <Cale> Especially base...
04:49:23 <Saizan> is base cabalized?
04:49:25 <chrisdone> hehe, mmmkay
04:49:44 <Saizan> if so you can run Setup register from the source directory
04:52:11 <jacobian> Does ghc provide access to its intermediate representation?
04:52:14 <chrisdone> it seems like a chicken and the egg problem. using `register' says I need to run `configure', but in order to run configure it says “cabal: ghc-pkg describe * failed. If you are using ghc-6.9 and have an empty user package database...workaround is to register at least one package in the user package db”, but I don't see how registering a package is possible
04:52:23 <jacobian> In order to put programs in the optimisation pipeline?
04:53:07 <chrisdone> oh
04:53:16 <chrisdone> cabal configure --global works
04:53:32 <chrisdone> so I have to use --global from now on or something?
04:54:03 * chrisdone does a Napoleon Dynamite sigh
04:54:38 <hml> 2
04:55:39 * codacola ponders if tid be too obsessive to paint the haskell logo on a car
04:55:41 <dcoutts> chrisdone: what I'd do is to use ghc-pkg describe on an existing package and then register than in the user package. Then install the thing by cabal and unregister the one you hacked into the user db.
04:55:56 <chrisdone> dcoutts: good idea, I'll try that
04:56:53 <dcoutts> chrisdone: or help us implement the correct solution :-)
04:57:42 <chrisdone> oh, I think --global exhibits a similar error, it just doesn't display a nice description “cabal configure --global cabal: At least the following dependencies are missing:base -any”
04:57:47 <chrisdone> dcoutts: what do you need to do?
04:58:20 <dcoutts> chrisdone: http://hackage.haskell.org/trac/hackage/ticket/311
04:58:21 <lambdabot> Title: #311 (support ghc-pkg dump) - Hackage - Trac
04:58:39 <conal> dcoutts: thanks for the "checkers" project workspace
04:58:49 <dcoutts> conal: np
05:06:34 <BeelsebobWork> can one control whether or not an instance definition gets exported by a module?
05:08:22 <chrisdone> dcoutts: hm, ghc-pkg dump and ghc-pkg describe '*' both print the same thing. what's all that about?
05:09:40 <chrisdone> this is all foreign to me. I just sudo cabal install, I haven't considered the workings of the package system and how cabal interacts with ghc
05:09:59 <dcoutts> chrisdone: it's pretty similar
05:09:59 <Saizan> BeelsebobWork: no, they are always exported
05:10:20 <dcoutts> chrisdone: dump uses --- as separators I think, right?
05:10:57 <dcoutts> chrisdone: and the difference is that ghc-pkg describe '*' is a query, it returns a failure exit code when the query result set is empty
05:10:59 <chrisdone> dcoutts: I can't tell because I only have one (falsly) installed package :P
05:11:13 <dcoutts> chrisdone: heh, right :-_
05:11:41 <dcoutts> chrisdone: so go ahead and install the other package you wanted and then compare again
05:15:30 <chrisdone> dcoutts: ah, yeah. splits with “---”
05:15:46 <chrisdone> dcoutts: (I registered the fastcgi library)
05:16:02 <chrisdone> dcoutts: okay, so... just to identify what my problem actually is, neverminding the solution, I have NO registered packages in --global OR --user. why is this?
05:16:33 <dcoutts> chrisdone: you mean cabal thinks this, or ghc-pkg list thinks that?
05:16:35 <chrisdone> well, I have cgi and fastcgi, but only because I --force'd them, they're not actually installed
05:16:48 <chrisdone> dcoutts: both
05:16:52 <dcoutts> chrisdone: do both dump and describe * use --- then?
05:17:22 <chrisdone> dcoutts: sorry?
05:17:36 <chrisdone> dcoutts: oh
05:17:48 <dcoutts> chrisdone: wait, ghc-pkg list can't think both global and user are empty, otherwise you'd not see the two packages
05:17:55 <chrisdone> dcoutts: yes, they both use “---”
05:18:52 <mmorrow> chrisdone: cereal ftw
05:18:56 <chrisdone> dcoutts: well it did think --global and --user are empty before I fake-registered cgi and fastcgi, but it is still essentially a problem of *no standard modules*
05:19:23 <dcoutts> chrisdone: so ghc-pkg list --global says there are no packages registered ?
05:19:37 <chrisdone> dcoutts: I'll just show the output
05:19:44 <chrisdone> chris@chrisdesktop:~/fastcgi-3001.0.2$ ghc-pkg list
05:19:44 <chrisdone> /usr/local/share/ghc-6.9.20080719/ghc-pkg-6.9/package.conf: {cgi-3001.1.6.0}, {fastcgi-3001.0.2}
05:19:48 <chrisdone> that's all
05:20:02 <chrisdone> chris@chrisdesktop:~/fastcgi-3001.0.2$ ghc-pkg list --user
05:20:02 <chrisdone> /home/chris/.ghc/i386-linux-6.9.20080719/package.conf:
05:20:15 <dcoutts> chrisdone: ok, that's completely broken
05:20:22 <chrisdone> dcoutts: haha, yes :/
05:20:50 <chrisdone> I must've installed it wrongly
05:21:00 <dcoutts> chrisdone: you'll need to reinstall ghc, then check that ghc-pkg list shows the basic core packages
05:21:30 <dcoutts> chrisdone: you'll get the same issue as before with --user packages until we update Cabal to use ghc-pkg dump
05:21:54 <dcoutts> chrisdone: would you mind using hpaste and showing the output of ghc-pkg dump ?
05:21:55 <dcoutts> @hpaste
05:21:56 <lambdabot> Haskell pastebin: http://hpaste.org/new
05:22:01 <chrisdone> dcoutts: sure
05:22:15 <dcoutts> chrisdone: I'm not using 6.9 atm, so it's a bit hard for me to test the ghc-pkg dump feature
05:22:27 <conal> is there a general name of properties like 'x && x == x', 'x || x == x', 'x `max` x == x', etc?
05:22:37 <chrisdone> dcoutts: http://hpaste.org/9230
05:22:48 <dcoutts> conal: isn't that idempotent?
05:23:19 <conal> dcoutts: i think idempotent is f x == f (f x).
05:23:24 <conal> dcoutts: i'll look it up, though.
05:23:44 <lilachaze> yes, idempotent means f^2 == f
05:23:57 <dcoutts> conal:  wikipedia says: A binary operation ★ on a set S is called idempotent if, for all x in S,
05:23:57 <dcoutts>     x★x = x.
05:24:10 <conal> dcoutts: yep. "idempotence" has both meanings, according to wikipedia.
05:24:21 <conal> thx!
05:24:52 * lilachaze wonders if that's just punning, or if there's some deeper reason
05:25:00 * conal too
05:25:14 <chrisdone> a pun on id?
05:25:26 <conal> oh, yet another meaning is such an element x, for a given binary operator.
05:26:05 <Cale> f . f = f
05:26:11 <dcoutts> chrisdone: thanks
05:26:39 <chrisdone> dcoutts: what are you looking for in it?
05:27:04 <dcoutts> chrisdone: to be able to parse it
05:27:04 <Cale> So it's like f is an idempotent point for (.)
05:27:29 <dcoutts> chrisdone: since I've not got 6.9 installed myself I don't have sample output of ghc-pkg dump
05:27:35 <Cale> So they're not entirely unrelated :)
05:27:35 <chrisdone> dcoutts: ahh
05:28:31 <conal> Cale: nice connection!
05:29:17 <mmorrow> i dunno the relevance to anything, but this made me think of nilpotent: there an n>0 such that f^n = 0
05:29:49 <mmorrow> so, i guess       foldr (.) id (replicate n f) == (const ())     for some n>0
05:30:00 <mmorrow> or something
05:31:03 <mmorrow> uh, better would be "f^n==0 for some n>0"
05:32:17 <mmorrow> 0 being the zero in a ring, so i dunno how (.) would fit into that
05:32:49 <Cale> and of course, a nilpotent element of a ring is one such that x^n = 0 for some n, where the exponentiation indicates repeated multiplication
05:35:34 <Cale> mmorrow: Well, it's the same thing when you have a ring of functions, where multiplication is composition and addition is elementwise.
05:35:47 <mmorrow> yeah, i was nonrigorously trying to map (.) to the mult somehow
05:35:59 <mmorrow> perfect
05:36:15 <mmorrow> that's the ring i was referring to then :_
05:36:23 <mmorrow> s/:_/:)/
05:37:10 <mmorrow> Cale: what about the 0 in this ring
05:37:26 <Cale> that would be the constant 0 function
05:37:45 <mmorrow> ok that's what i thought, but then started to second-guess myself
05:37:49 <mmorrow> so, const ()
05:38:01 <mmorrow> or s/()/whatever==0/
05:38:22 <Cale> Well, it has to be functions whose codomain is a ring
05:38:39 <mmorrow> i dunno though, since:
05:38:46 <mmorrow> >  (+1) . (+1) . (const 0) $ 2
05:38:49 <lambdabot>  2
05:38:57 <mmorrow> >  (const 0) $ 2
05:39:00 <lambdabot>  0
05:39:13 <mmorrow> > 1*1*0
05:39:16 <lambdabot>  0
05:39:16 <mmorrow> > 0
05:39:19 <lambdabot>  0
05:39:38 <Cale> oh, heh, right, of course
05:40:14 <gwern> 'The Koan of Lazy Evaluation: Michel Mauny was giving a guest lecture to new computer science students. After the students were seated, Michel pronounced “Today’s lecture will be about Lazy Evaluation”, he paused for a moment then concluded with, “Are there any questions?”'
05:40:14 <Cale> They need to be ring homomorphisms :)
05:40:29 <BeelsebobWork> what is an "orphan instance"?
05:40:30 <mmorrow> ah yes, that's it
05:40:32 <Cale> Not just any functions :)
05:41:11 <gwern> @remember DougBagley The Koan of Lazy Evaluation: Michel Mauny was giving a guest lecture to new computer science students. After the students were seated, Michel pronounced “Today’s lecture will be about Lazy Evaluation”, he paused for a moment then concluded with, “Are there any questions?”
05:41:11 <lambdabot> Nice!
05:41:14 <gwern> @quote hackage
05:41:14 <lambdabot> dcoutts says: remember, if it's not on hackage it doesn't exist!
05:41:17 <gwern> @quote koan
05:41:17 <lambdabot> DougBagley says: The Koan of Lazy Evaluation: Michel Mauny was giving a guest lecture to new computer science students. After the students were seated, Michel pronounced “Today’s lecture will be
05:41:17 <lambdabot> about Lazy Evaluation”, he paused for a moment then concluded with, “Are there any questions?”
05:41:18 <ski> gwern : yes, that's funny each time :)
05:42:08 <gwern> ski: I've never seen it before. they're not much worse than the AI Koans
05:42:22 * gwern reads http://web.archive.org/web/20041012103936/http%3a//www.bagley.org/~doug/ocaml/Notes/okoans.shtml
05:42:24 <lambdabot> Title: Functional Programming Koans, in OCaml, http://tinyurl.com/5aeag3
05:42:34 <ski> gwern : *nod*
05:42:48 <paczesiowa> BeelsebobWork: http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#orphan-modules
05:42:49 <lambdabot> Title: 5.6. Filenames and separate compilation, http://tinyurl.com/yyunf2
05:42:56 <gwern> @remember DougBagley A disciple of another sect invited Markus Mottl to the beach. As he is driving his car along, he tells Markus: "Dynamic Typing makes me more productive! I can write my program faster if I do not have to worry about the compiler complaining about types". Since it is a long trip, the disciple of Dynamic Typing decides to make a stop for petrol. He enters the station to pay for the fuel and purchase a slurpee, while Markus attends to the r
05:42:56 <lambdabot> It is stored.
05:43:05 <gwern> @quote petrol
05:43:05 <lambdabot> DougBagley says: A disciple of another sect invited Markus Mottl to the beach. As he is driving his car along, he tells Markus: "Dynamic Typing makes me more productive! I can write my program
05:43:05 <lambdabot> faster if I do not have to worry about the compiler complaining about types". Since it is a long trip, the disciple of Dynamic Typing decides to make a stop for petrol. He enters the station to pay
05:43:05 <lambdabot> for the fuel and purchase a slurpee, while Markus attends to the r
05:43:30 <gwern> I wonder what the size limits for quotes are...
05:43:58 <chrisdone> probably 512 thanks to the IRC protocol
05:44:02 <paczesiowa> > cycle ['a'..] >>= @remember
05:44:02 <lambdabot>  Parse error at "@reme..." (column 19)
05:44:10 <yitz> gwern: looks like the irc message itself got truncated
05:44:29 <gwern> yep. darn
05:44:56 <mmorrow> > (foldr (.) (id) . fmap mkRingHom $ replicate 10 (+1)) . (const $ Left ()) $ 2
05:44:58 <lambdabot>   Not in scope: `mkRingHom'
05:45:13 <yitz> gwern: never mind the bot. would you finish the koan already?
05:45:15 <mmorrow> > let mkRingHom f = either Left (Right . f) in (foldr (.) (id) . fmap mkRingHom $ replicate 10 (+1)) . (const $ Left ()) $ 2
05:45:18 <lambdabot>  Left ()
05:45:50 <gwern> yitz: read the ln
05:46:07 <mmorrow> > let mkRingHom f = either Left (Right . f) in (foldr (.) (id) . fmap mkRingHom $ replicate 10 (+1)) . (const $ Left ()) $ Right 2 -- i meant Right 2
05:46:10 <lambdabot>  Left ()
05:46:24 <mmorrow> or something
05:46:27 <yitz> gwern: i knew you would say that. see previous koan about "lazy evaluation".
05:46:46 <ivanm> is there an integer-based xor function? i.e take the exclusive or of two integers and return another integer
05:46:56 <chrisdone> .|.
05:47:01 <chrisdone> > 1 .|. 1
05:47:03 <EvilTerran> ?index .|.
05:47:03 <lambdabot> Data.Bits, Foreign
05:47:03 <lambdabot>  Add a type signature
05:47:12 <chrisdone> > 1 .|. 1 :: Int
05:47:14 <lambdabot>  1
05:47:19 <chrisdone> > 1 .|. 0 :: Int
05:47:19 <EvilTerran> that's inclusive or
05:47:21 <lambdabot>  1
05:47:24 <chrisdone> oh yeah
05:47:29 <ivanm> heh
05:47:33 <Stinger_> I don't get the HOF koan
05:47:54 <EvilTerran> > [(x, y, x .^. y) | x <- [0,1], y <- [0,1]]
05:47:56 <chrisdone> > 1 `xor` 0 :: Int
05:47:57 <lambdabot>   Not in scope: `.^.'
05:47:59 <lambdabot>  1
05:48:02 <chrisdone> > 1 `xor` 1 :: Int
05:48:04 <lambdabot>  0
05:48:06 <paczesiowa> Stinger_: there are answers at the bottem (linked)
05:48:07 <chrisdone> :)
05:48:12 <EvilTerran> > [(x, y, x `Data.bits.xor` y) | x <- [0,1], y <- [0,1]]
05:48:12 <lambdabot>  Parse error at ".xor`" (column 21)
05:48:13 <paczesiowa> *bottom
05:48:19 <EvilTerran> > [(x, y, x `Data.Bits.xor` y) | x <- [0,1], y <- [0,1]] -- grr
05:48:21 <lambdabot>  Add a type signature
05:48:26 <ivanm> @hoogle xor
05:48:26 <lambdabot> Data.Bits.xor :: Bits a => a -> a -> a
05:48:34 <EvilTerran> > [(x :: Integer, y, x `Data.Bits.xor` y) | x <- [0,1], y <- [0,1]] -- GRR
05:48:35 <ivanm> oh, I didn't realise Int was an instance of Bits
05:48:36 <chrisdone> good stuff in Data.Bits
05:48:37 <lambdabot>  [(0,0,0),(0,1,1),(1,0,1),(1,1,0)]
05:48:48 <Stinger_> heh 404
05:48:49 <chrisdone> ivanm: I think all the number types are
05:48:56 <chrisdone> ivanm: or a lot of them
05:49:14 <ivanm> *nod*
05:49:17 <EvilTerran> only the integer types, i think
05:49:21 <chrisdone> right
05:49:21 <ivanm> thanks chrisdone, EvilTerran
05:49:23 <paczesiowa> Stinger_: http://web.archive.org/web/20030330175834/www.bagley.org/~doug/ocaml/Notes/okoans_answered.shtml
05:49:24 <lambdabot> Title: Answers to FP Koans, in OCaml, http://tinyurl.com/58ukj8
05:49:25 <chrisdone> np
05:49:25 <EvilTerran> Integer, Int, Int*, and Word*
05:49:31 <ivanm> EvilTerran: well, that's all I want it for anyway
05:50:10 <chrisdone> so I'm listening to some 80's Blondie - Heart of Glass, while ghc is compiling
05:50:14 <EvilTerran> paczesiowa, where are the koans themselves?
05:50:31 <EvilTerran> nm, found 'em in the scrollback
05:50:48 <paczesiowa> EvilTerran: http://web.archive.org/web/20030330201259/http://www.bagley.org/~doug/ocaml/Notes/okoans.shtml
05:50:49 <lambdabot> Title: Functional Programming Koans, in OCaml, http://tinyurl.com/6zeu2k
05:51:01 <ivanm> I have to implement a fibonacci-based prng (forget the name of it) and one of the functions I'm meant to test it with is xor...
05:51:15 <FordCortina> am i getting these instance-improvement rule right? http://hpaste.org/9231
05:51:20 <ivanm> I _knew_ there had to be a way to do it in Haskell, after all you can do it in lesser languages like matlab :p
05:51:54 <FordCortina> (im trying to get my head around this http://research.microsoft.com/~simonpj/papers/fd-chr/ - the first paper on there)
05:51:54 <lambdabot> Title: Simon Peyton Jones: papers
05:51:59 <chrisdone> heh, I was solving a problem with a friend, he was doing it in lisp using lists of integers
05:52:06 <chrisdone> I'm like, Data.Bits, xor, kthx
05:52:43 <kpreid> chrisdone: he was using (1 1 0 1 ...)?
05:52:45 <EvilTerran> hah
05:52:54 <EvilTerran> i like: Michel Mauny was giving a guest lecture to new computer science students. After the students were seated, Michel pronounced "Today's lecture will be about Lazy Evaluation", he paused for a moment then concluded with, "Are there any questions?"
05:52:57 <chrisdone> kpreid: yeah
05:53:14 <kpreid> chrisdone: sheesh.
05:53:17 <chrisdone> kpreid: I don't doubt there's some CL library to work on bits somewhere out there...
05:53:22 <kpreid> chrisdone: library?!
05:53:31 <kpreid> check out LOGXOR and BIT-XOR in the standard
05:53:45 <kpreid> if he used a bit-vector it would even be a sequence!
05:53:49 * kpreid shuts up now
05:54:10 <ski> chrisdone : or BOOLE
05:54:48 <yitz> wait a minute, weren't we talking about xor in matlab?
05:54:50 <chrisdone> thanks I'll remember that next time I'm writing some CL code?
05:55:06 <kpreid> uh, yeah :)
05:57:05 <chrisdone> :)
05:57:25 <newComer> hello
05:57:33 <chrisdone> are you new?
05:57:37 <yitz> hi newComer
05:57:42 <newComer> Yes.
05:57:48 <codacola> that just sounds bad
05:58:11 * chrisdone doing voice of Tubbs from The League of Gentlemen
05:58:32 <codacola> wonderful movie
05:58:36 <codacola> all it lacked was functions
05:59:06 <chrisdone> newComer: welcome
05:59:38 <newComer> Thanks.
05:59:46 <newComer> Could I ask a simple question here?
05:59:52 <yitz> yes
05:59:59 <codacola> maybe
06:00:09 <Cale> newComer: Questions about Haskell are always welcome here :)
06:00:26 <chrisdone> Cale: what about questions about questions about Haskell?
06:00:43 <paczesiowa> chrisdone: #metahaskell
06:00:44 <newComer> Thanks. I cannot find Queue implementation in GHC's hierarchical libraries.
06:00:47 <chrisdone> paczesiowa: hehe
06:00:53 <codacola> Cale: he never said it was a haskell question
06:00:58 <yitz> chrisdone: yes, that is a question of type * -> *
06:01:04 <yitz> s/type/kind/
06:01:30 <Cale> newComer: PSQueue is pretty cool
06:01:34 <ivanm> codacola: Cale never said if non-Haskell questions were allowed...
06:01:38 <ivanm> ;-)
06:01:44 <newComer> Actually, I know that the queue can be implemented by two list or a Monad.
06:02:00 * codacola goes back to car shopping
06:02:05 <newComer> PSQueue? you mean in the hackage?
06:02:06 <Cale> Yeah, there are various queue implementations you can find in Edison.
06:02:08 <Cale> newComer: yeah
06:02:51 <newComer> I just wonder why GHC does not include a Queue implementation in its library.
06:02:52 <paczesiowa> newComer: relax, lay down on the sofa. tell us about your childhood why do you need queue?
06:03:00 <Cale> oh, there's a queue in the GHC libraries
06:03:02 <newComer> Does it mean the queue is not so commonly used?
06:03:44 <Cale> Er, or there was...
06:03:58 <yitz> Cale: there is? hmm, maybe my haddocks are out of date
06:04:04 <newComer> :) Yes. I am programming a network program, and keep a list of packets to be retransmitted.
06:04:08 <codacola> newComer: implement your own :D
06:04:21 <newComer> Packets should be sent as a FIFO order, so queue is needed. :)
06:04:26 <yitz> you can use a Data.Sequence as a queue, but it's not the absolute fastest.
06:04:28 <Cale> yitz: I had a bookmark for it, but the link is broken now.
06:05:15 <Cale> very strange...
06:05:34 <paczesiowa> maybe webarchive thingie?
06:05:57 <yitz> in a realtime sensitive area like networking, perhaps Data.Sequence is better, because you could get stuck pouring one list into another at the wrong moment wit a traditional functional queue.
06:06:07 <chrisdone> Cale: know anything about game theory?
06:06:16 <Cale> chrisdone: a little, not much
06:06:45 <newComer> Ok. Thanks a lot. yitz. I will try to use the Data.Sequence. You are all very nice. :)
06:06:47 <Cale> strange, where the heck did Data.Queue go?
06:07:03 <Cale> But yeah, you can use Data.Sequence, since it's O(1) access at both ends.
06:07:19 <chrisdone> Data.Graph.Inductive.Internal.Queue?
06:07:27 <newComer> Next time, I will come with a more formal name. I need to think out one first.
06:07:41 <Cale> Oh, Data.Queue ended up being deprecated because Data.Sequence was faster.
06:07:57 <chrisdone> newComer: if your real name contains only ascii characters, consider using that
06:07:57 <newComer> Yes, there is only one queue which happens to be 'Internal' :(
06:08:01 <Cale> http://cvs.haskell.org/Hugs/pages/libraries/base/Data-Queue.html
06:08:02 <newComer> Thanks.
06:08:03 <lambdabot> Title: Data.Queue
06:08:08 <Cale> was the old one, but it's gone
06:08:15 <newComer> See you next time. Thanks a lot.
06:08:25 <yitz> newComer: well, next time you could use returnVisitor.
06:08:27 <Cale> No problem, hang around if you like :)
06:08:52 <newComer> Yes. Good point.:)
06:09:00 <chrisdone> but what /is/ a monad?
06:09:13 <dcoutts_> it's a warm fuzzy thing
06:09:20 <Cale> chrisdone: a monad is a type constructor with certain operations
06:09:34 <Cale> (that satisfy certain laws)
06:10:35 <chrisdone> a functor with some law satisfying operations?
06:10:45 <Cale> yeah.
06:11:03 <ivanm> hmmm.... is the hpaste bot dead?
06:11:04 <chrisdone> so is a functor the type constructor by itself?
06:11:05 <Cale> Oh, if you already understand functors, then you're most of the way there :)
06:11:12 <ivanm> can someone have a look at this please? http://hpaste.org/9232
06:11:32 <chrisdone> cale: well, I think I understand monads, but everytime a monad discussion comes up I learn a new way of thinking about it
06:11:33 <Cale> A functor is a type constructor F for which you can define an fmap :: (a -> b) -> F a -> F b
06:11:52 <Cale> such that  fmap id = id
06:12:00 <Cale> and fmap (f . g) = fmap f . fmap g
06:12:29 <chrisdone> is that associativity?
06:12:41 <dozer> chrisdone: I tend to think of monads like interpreters - they insulate the code from the actual execution environment, and if you write monad-aware code it can diddle this interpreter, otherwise it gets run however the interpreter sees fit
06:13:02 <Cale> chrisdone: Actually, in a funny way, it is, but it's not normally called that
06:13:15 <chrisdone> cale: what's it normally called?
06:13:28 * codacola has been too scared to read about monads
06:13:40 <Cale> codacola: they're really pretty simple
06:14:18 <RayNbow> codacola, "Don't fear the Monads" http://channel9.msdn.com/ShowPost.aspx?PostID=358968 ;)
06:14:19 <lambdabot> Title: Brian Beckman: Don't fear the Monads | Going Deep | Channel 9
06:14:22 <codacola> still too scared, ill learn more abotu other things first :P
06:14:25 <__pao___> codacola: Cale's wiki articles are pretty enlighting ;-)
06:14:38 <Cale> RayNbow: that has to be one of the most confusing videos on monads ever
06:14:38 <yitz> ivanm: you're sorting them, of course it won't be lazy
06:14:49 <RayNbow> Cale: it is?
06:14:50 <ivanm> yitz: damn, didn't think about that :(
06:14:59 <Cale> Well, it confused me, and I know what monads are :)
06:15:01 <RayNbow> it's been a while since I watched that vid
06:15:22 <ivanm> problem is, the only other way of doing the calculations is to check how many other values produced are less than the current value...
06:15:29 <ivanm> which would be even _less_ efficient :s
06:15:45 <Cale> codacola: If you know about types and typeclasses, it should be okay
06:16:00 <ivanm> and I can't use a generator function because it needs to be either sorted or checking the entire list! :@
06:16:07 <Cale> chrisdone: hmm, I'm not sure it's normally given a name apart from 'one of the functor laws'
06:16:09 * ivanm doesn't get how it could work in other languages then :s
06:16:25 <chrisdone> cale: ahh okay :)
06:16:31 <__pao___> Cale: can I elict you my personal guru? :-) could you please provide an ordered by importance list of non standard haskell features (ghc) that I must be aware of?
06:16:32 <Cale> chrisdone: However, it's sort of saying that the functor preserves the structure of the category
06:17:13 <yitz> ivanm: yeah, if you've got to sort 10^8 things, most languages I know are going to have a problem with that.
06:17:34 <yitz> maybe a quantum computer would do it
06:17:47 <ivanm> lol
06:17:53 <Cale> __pao___: Well, it depends on what sorts of programs you're most interested in...
06:18:03 <ivanm> dammit, I can't see any other way it could be done though :s
06:18:26 <__pao___> Cale: argh... "general porpouse programming" is a good fit?
06:18:28 <__pao___> ;-)
06:18:48 <Cale> __pao___: I really like the STM paper, so it's worth reading that. :)  You can't get around the MTL without knowing a bit about multiparameter typeclasses and fundeps, but that's not so hard.
06:18:48 <chrisdone> We shall discuss
06:18:48 <chrisdone> monads much more fully in the next section, but for now, suce to say that a monad
06:18:52 <chrisdone> is a kind of standardised interface to an abstract data type of ‘program fragments’. The
06:18:55 <chrisdone> monad interface has been found to be suitable for many combinator libraries, and is
06:18:58 <chrisdone> damn, sorry, pasting from PDF
06:19:09 <chrisdone> I thought it was a nice summary of monads, in the Arrows paper
06:19:25 <__pao___> mutiparameter typeclasses and fundeps
06:19:27 <__pao___> got it
06:19:43 <yitz> __pao___: bang patterns are handy
06:20:01 <Cale> __pao___: and newtype deriving
06:20:06 <Cale> (which is trivial as well)
06:20:30 <dmead> hey
06:20:33 <dmead> someone remind me
06:20:34 <chrisdone> hi
06:20:47 <Cale> If you want something fun, try STM... Simon Peyton Jones' paper on it is really good
06:20:48 <dmead> i have file a
06:20:56 <dmead> file a imports stuff from file b
06:21:05 <dmead> i have them both in the same directory
06:21:12 <chrisdone> cale: yeah, me and jpcooper were discussing STM on Skype :)
06:21:16 <dmead> and ghci can't find anything from file b
06:21:20 <dmead> when loading file a
06:21:26 <chrisdone> dmead: is this from emacs?
06:21:30 <dmead> yes
06:21:46 <Cale> dmead: Is file b named the same as the module name?
06:21:47 <chrisdone> dmead: does it say “:cd ~/.cabal” when loading?
06:22:01 <dmead> Cale, yep
06:22:16 <dmead> i have Text.csv in CSV.hs
06:22:24 <dmead> and file a imports Text.csv
06:22:29 <dmead> Text.CSV
06:22:47 <yitz> aha
06:23:02 <dmead> chrisdone, no cable
06:23:09 <__pao___> Cale: gatd, phantom types... are useful features?
06:23:10 <yitz> you want Text/CSV.hs (i.e. in a subdirectory)
06:23:14 <chrisdone> dmead: sorry?
06:23:17 <dmead> ah
06:23:23 <dmead> cabal, sorry
06:23:58 <Cale> __pao___: GADTs are cool, especially as a nicer syntax for existentials, but I haven't seen too many provocative cases where the full power of GADTs was really useful.
06:24:15 <Cale> __pao___: But definitely check them out.
06:25:04 <Cale> They basically let you hijack the Haskell type system and apply it to your own DSLs.
06:25:16 <tusho> wow, there's both foldl.com and foldr.com
06:26:23 <chrisdone> there should be fix.com which redirects to fix.com
06:26:29 <augustss_> Yes.  And who is Oliver Steele?
06:26:34 <tusho> chrisdone: no
06:26:56 <tusho> fix.com/ should show a box with [ http:// ] [ Go ]
06:27:01 <tusho> so
06:27:13 <tusho> fix.com/    http:// [               ]           [ Go ]
06:27:24 <tusho> and putting in google -> fix.com/google.com -> fix.com/fix.com/google.com
06:27:24 <tusho> etc
06:28:24 <tusho> hmm
06:28:34 <tusho> what would map.com be
06:28:56 <ivanm> fix.com is a motion graphic design site
06:28:57 <__pao___> Cale: do you have any paper/articole on designing DSL with GADT?
06:29:01 <codacola> maps itd seem
06:29:15 <__pao___> Cale: I'm trying to googling without success
06:29:29 <codacola> ok
06:29:34 <codacola> foldr.com is just scary
06:29:40 <ivanm> how would foldl'.com differ from foldl.com? :p
06:30:19 <yitz> fix.com should contain: <html><head><meta http-equiv='REFRESH' content='0;url=http://fix.com'></head></html>
06:30:57 <mauke> I want flickl.com
06:31:23 <Cale> __pao___: It's not much, but there's http://www.haskell.org/haskellwiki/GADT
06:31:25 <lambdabot> Title: Generalised algebraic datatype - HaskellWiki
06:31:51 <mmorrow> mauke: mirror flickr, but invert the colors of all the images and reverse all words etc
06:32:06 <dozer> is the new typefamily stuff slated for inclusion in an upcomming GHC?
06:32:08 <yitz> mauke: flickl.com is a parked domain, registered in china.
06:32:15 <Cale> __pao___: there's also the GHC user's guide, which documents all of the language extensions to some extent
06:32:22 <Cale> dozer: yes, the next
06:32:28 <__pao___> Cale: thanks
06:32:42 <Cale> dozer: You'll find bits of it in 6.8, but it's mostly broken
06:32:53 <dozer> Cale: ah great - I have the feeling much of my spageti classes will be tidied up then
06:33:07 <mauke> heh
06:33:16 <Cale> __pao___: http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#gadt
06:33:17 <lambdabot> Title: 8.4. Extensions to data types and type synonyms, http://tinyurl.com/2cmgjm
06:33:27 <chrisdone> man compiling ghc takes like an hour. why is it so big
06:33:40 <mauke> do the japanese have problems distinguishing foldl/foldr?
06:33:42 <Cale> chrisdone: Don't compile it yourself unless you're hacking on it.
06:33:52 <yitz> foldl.com and foldr.com are cool. i wonder who paid for them.
06:34:35 <Cale> chrisdone: there are nice binaries availble :)
06:34:35 <chrisdone> cale: I've got the patched 6.8.3 audry tang made for quasiquotation :)
06:34:41 <Cale> ah
06:36:15 <pgavin> @seen duncan
06:36:15 <lambdabot> I haven't seen duncan.
06:36:22 <pgavin> @seen dcoutts
06:36:23 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-soc, #haskell-overflow, #ghc and #haskell. I last heard dcoutts speak 1h 8m 54s ago.
06:36:25 <dcoutts_> yo pgavin
06:36:29 <pgavin> hi
06:36:38 <pgavin> are you running that opensparc project?
06:36:53 <chrisdone> yay it's done
06:39:57 <augustss_> yitz: Oliver Steele
06:40:20 <yitz> hmm?
06:40:35 <augustss_> You wondered who payed.
06:40:53 <yitz> ah, ok.
06:41:08 <augustss_> According to the whois command.
06:42:01 <pgavin> dcoutts_: I've got root access on the same kind of machine you guys got from sun, I was woundering if I should apply for that project
06:42:14 <dcoutts_> pgavin: oh, right, cool
06:42:24 <dcoutts_> pgavin: yes, I'm project coordinator
06:43:00 <dcoutts_> pgavin: if you think you've got the skills then certainly you should apply
06:43:30 <pgavin> dcoutts_: yeah, I think I'm going to... I'll run it by my advisor and see what he thinks
06:43:53 <dcoutts_> pgavin: perhaps we should move to a side channel and discuss it
06:44:19 <yitz> http://osteele.com/
06:44:20 <lambdabot> Title: Oliver Steele | Languages of the real and artificial
06:51:01 <yakov> hey
06:51:34 <yakov> how to tell cabal to echo each command before execution?
06:52:04 <dcoutts_> yakov: -v[n] where n `elem` [0..3]
06:52:33 <jacobian> is there a way to insert oneself into the ghc pipeline so that you can alter the code in ghc -ddump-ds
06:52:39 <dcoutts_> yakov: so just -v on it's own should work for what you want
06:52:48 <yakov> hm.. runhaskell ./Setup.lhs -v3 build does not echo ..
06:52:57 <yakov> complains about unknown option
06:53:00 <yakov> -v
06:53:09 <yakov> im using cabal to build my stuff
06:53:51 <dcoutts_> yakov: -v is an option to the build sub-command
06:54:11 <dcoutts_> yakov: ie, use $ runhaskell ./Setup.lhs build -v
06:54:51 <dcoutts_> the top level command doesn't take many options, mostly just --help or the names of the sub-commands
06:55:48 <yakov> thx
06:55:52 <yakov> helped
06:59:04 <gwern> runhaskell ./Setup.lhs actually works? o.0
06:59:19 <gwern> hm. I guess the shell would interpret away the ./ tho
06:59:44 <gwern> yakov: a tip, just say 'runhaskell Setup'; shorter, and you need never worry about what the actual extension is
06:59:54 <dcoutts_> yes, good advice
07:00:00 <yakov> thx!
07:01:15 <BeelsebobWork> tbh, I just go with runhaskell Set<tab>
07:01:27 <dcoutts_> or just use cabal-install!
07:01:33 <BeelsebobWork> nope, that doesn't work
07:01:33 <dcoutts_> and bash shell completion
07:01:41 <dcoutts_> BeelsebobWork: what?
07:01:50 <BeelsebobWork> cabal install has never worked correctly for m
07:01:52 <BeelsebobWork> me*
07:02:10 <BeelsebobWork> it's also somewhat worthless given that it's list of dependancies is one of the longer lists
07:02:11 <dcoutts_> BeelsebobWork: the latest release? what bugs do you hit?
07:02:18 <dcoutts_> that's not really true
07:02:28 <BeelsebobWork> dcoutts_: it would claim to have installed and not actually installed anything
07:02:29 <dcoutts_> it's got two deps that are not distributed as standard
07:02:38 <BeelsebobWork> also, if it hits a build failure, it doesn't tell you
07:02:59 <dcoutts_> BeelsebobWork: is that because it was putting putting binaries somewhere that was not on your path?
07:03:08 <dcoutts_> BeelsebobWork: it does now report all build failures
07:03:37 <BeelsebobWork> also, process, zlib, HTTP and the version of Cabal required are not included in ghc by default
07:03:47 <BeelsebobWork> or at least not on OS X
07:04:12 <BeelsebobWork> dcoutts_: v0.5.1 or the version in darcs?
07:04:20 <BeelsebobWork> because I'm still getting it failing to report build-failures with 0.5.1
07:04:34 <dcoutts_> BeelsebobWork: yes, the cabal-install and Cabal on hackage.
07:04:49 <BeelsebobWork> then it still has some cases where it doesn't report a failure
07:04:58 <dcoutts_> BeelsebobWork: can you give any more detail
07:05:04 <BeelsebobWork> e.g. lambdabot fails to build in plugins, but it fails silently
07:05:28 <dcoutts_> BeelsebobWork: when you do cabal install lambdabot, or cabal build in a local dir ?
07:05:32 <BeelsebobWork> (note, I know lambdabot on hackage is broken, but it should still tell me it failed)
07:05:39 <BeelsebobWork> cabal install lambdabot
07:06:26 <dcoutts_> BeelsebobWork: can you provide a build log please and details of how to reproduce? that'd really help. It is supposed to give a summary at the end of all packages that failed to build.
07:06:35 <dcoutts_> BeelsebobWork: in the hackage trac I guess
07:06:36 <BeelsebobWork> I can do
07:07:21 <dcoutts_> BeelsebobWork: and if it's failing silently, running with -v3 might give more of a clue.
07:07:49 <BeelsebobWork> dcoutts_: by "silently" I mean "noisily, but so long ago that it's 6 miles off the top of the terminal window"
07:08:08 <dcoutts_> BeelsebobWork: ahh, so it does give a summary at the end?
07:08:14 <BeelsebobWork> nope
07:08:18 <dcoutts_> like saying what package name and version failed?
07:08:24 <BeelsebobWork> it gives an error as it tries to build plugins
07:08:29 <BeelsebobWork> and then does a load of other stuff
07:08:35 <BeelsebobWork> and then doesn't tell me at the end that plugins failed
07:08:39 <dcoutts_> and that it dies due to exception ExitFailure 0
07:08:43 <dcoutts_> hmm
07:09:11 <BeelsebobWork> as for the dependancies issue -- it has sufficiently many deps that it's usually more hastle for me to go and get cabal install (due to 4 deps) than it is to just get the module I want (given that it's pretty rare that a package has more than 1 dep)
07:09:44 <dcoutts_> BeelsebobWork: sure, bootstrapping is an issue. It'll be in the platform which will solve it.
07:09:51 <BeelsebobWork> ah, shiny
07:09:58 <BeelsebobWork> incidentally... put OpenGL in it already!
07:10:05 <BeelsebobWork> :P
07:10:11 <dcoutts_> BeelsebobWork: get someone to do the work :-)
07:10:21 <dcoutts_> BeelsebobWork: and this bad behaviour is definitely with the released versions from hackage right?
07:10:31 <BeelsebobWork> yeh, I also disagree with the sentiment that seems to be going round that OpenGL is a good package
07:10:41 <dcoutts_> I've no opinion on that
07:10:47 <BeelsebobWork> dcoutts_: I'm just re-grabbing it to be 100% certain
07:10:56 <gwern> opengl is not cabalized?
07:11:02 <dcoutts_> gwern: it is
07:11:06 <gwern> dcoutts_: well, opengl seems to work well in the games area
07:11:08 <BeelsebobWork> dcoutts_: by that I mean it's suffering bit-rot -- there are large parts of "modern" OpenGL that HOpenGL doesn't cover at all
07:11:15 <dcoutts_> but if it's easy to get it into the platform then we'll do it, or ask someone with more time to do the work
07:11:15 <gwern> monadius shu-thing, roguestar - opengl users
07:11:35 <dcoutts_> BeelsebobWork: that's quite different from no longer working on various platforms
07:11:54 <dcoutts_> not gaining new features is a problem but not as much as regressing
07:12:01 <gwern> BeelsebobWork: is that so? I had heard differently from the thread on't
07:12:17 <BeelsebobWork> dcoutts_: it's regressing in that the parts of OpenGL it supports are getting slower and slower on modern graphics cards
07:12:30 <BeelsebobWork> with no shader support it'll always get slower
07:13:13 <dcoutts_> BeelsebobWork: ok sure, but it's not like "aarg! it doesn't work with ghc-6.x!!!?!"
07:13:23 <BeelsebobWork> true
07:13:50 <gwern> 6.x goes pretty far back :)
07:14:16 <dcoutts_> gwern: my quote was parametrised by the ghc version :-)
07:14:37 <BeelsebobWork> just to add to the fun dcoutts_ -- the current cabal-install fails to build on my system
07:14:37 <dcoutts_> BeelsebobWork: platform maintainers are certainly not going to be adding features, at most applying build system tweaks or fixing uses of deprecated functions
07:15:00 <dcoutts_> BeelsebobWork: :-) you seem to get all the bad luck with it
07:15:02 <ToRA> i thought hopengl had shader support...at least i've used shaders with hopengl...?
07:15:06 <BeelsebobWork> dcoutts_: I do
07:15:12 <dcoutts_> BeelsebobWork: could you hpaste that?
07:15:24 <BeelsebobWork> way ahead of you... http://hpaste.org/9233
07:15:26 <dcoutts_> BeelsebobWork: clearly we need more OSX testers
07:16:16 <gwern> osx is getting to be as bad as windows
07:16:17 <dcoutts_> BeelsebobWork: you've got two versions of bytestring, with the exact same version
07:16:23 <dcoutts_> BeelsebobWork: that should be impossible.
07:16:29 <dcoutts_> oh, wait
07:16:30 <dcoutts_> I can't read
07:16:43 <BeelsebobWork> oh, so I do, but not
07:16:51 * BeelsebobWork ponders when that happened
07:17:32 <dcoutts_> BeelsebobWork: different versions is fine, but we have to compile the deps against a consistent version
07:17:42 <dcoutts_> BeelsebobWork: this is one of the problems that cabal-install solves ;-)
07:18:01 <dcoutts_> it makes install plans with consistent deps, rebuilding things as necessary
07:18:14 * BeelsebobWork ponders which dep it is
07:18:31 <dcoutts_> BeelsebobWork: it'll be zlib
07:18:53 <hackage> Uploaded to hackage: hsndfile 0.2.0
07:18:56 <dcoutts_> BeelsebobWork: you'll be building cabal-install against bytestring-0.9.1.0
07:19:09 <dcoutts_> BeelsebobWork: but zlib will be built against bytestring-0.9.0.1
07:19:21 <BeelsebobWork> wasn't zlib -- just rebuilt it
07:19:52 <dcoutts_> BeelsebobWork: if you use Cabal-1.4, then it will tell you when you configure
07:20:04 <dcoutts_> it says if there are inconsistent deps and which deps are involved
07:20:21 <BeelsebobWork> dcoutts_: no it won't ;)
07:20:21 <gwern> I dunno what people have against OpenGL. it's on hackage, it compiles & installs fine, even profiled with docs
07:20:24 * gwern shrugs
07:20:48 <BeelsebobWork> dcoutts_: http://hpaste.org/9235
07:20:50 <dcoutts_> BeelsebobWork: btw, you probably rebuilt zlib as a user package, you've got two versions of zlib-0.4.0.4 installed, one global, one user
07:21:11 <dcoutts_> BeelsebobWork: and you were configuring cabal-install using only the global package db
07:22:08 <dcoutts_> BeelsebobWork: ah, in that case it's a problem we have with ghc. We decide to use just global packages, but then ghc uses user ones anyway. This would be the case with your two versions of zlib-0.4.0.4
07:22:30 <BeelsebobWork> dcoutts_: how do I go about solving it? hide the user zlib?
07:22:51 <dcoutts_> BeelsebobWork: unregister it, or do a --user install of cabal-install
07:23:12 <BeelsebobWork> how do I go about unregistering specifically the user one?
07:23:28 <andyjgill> I've been hacking with HOpenGL, and every problem I had was in my code, not the HOpenGL implementation.
07:23:33 <ketil> I've a problem with static linking (-optl-static), I get messages about pthread stuff missing.  I think there was a quick fix, anybody know?
07:23:42 <andyjgill> I was delighted with how well it worked.
07:24:08 <gwern> ketil: missing a -dev library?
07:25:40 <ketil> gwern, possibly.  Which one?
07:25:59 <ketil> I can't find anything plausible (using apt-cache search).
07:26:21 <gwern> a libc sounds like
07:26:25 <gwern> pthreads is provided by it, no?
07:27:40 <ketil> ii  libc6-dev        2.7-10ubuntu3    GNU C Library: Development Libraries and Header
07:27:45 <ketil> (dpkg -l)
07:27:57 <ketil> i.e. it's there, as far as I can tell.
07:29:14 <ketil> Hah: ghc -optl-pthread
07:29:32 <ketil> That worked (found at http://groups.google.ca/group/fa.haskell/browse_thread/thread/f75a831b64fe2b53/b8b1b3402bd4ed9e?lnk=raot)
07:29:33 <lambdabot> Title: static linking - fa.haskell | Google Groups, http://tinyurl.com/6z58ab
07:33:22 <BeelsebobWork> dcoutts_: out of interest -- does the HP contain some sort of testing setup? i.e. QC/SC
07:33:39 <dcoutts_> BeelsebobWork: not yet
07:34:14 <dcoutts_> BeelsebobWork: but the long term plan is increasing quality by automated methods, and that'd include running package testsuites and gathering coverage etc
07:34:36 <BeelsebobWork> cool cool
07:34:51 <BeelsebobWork> just pondering whether to put eggs in a smallcheck or a quickcheck-2 shaped basket
07:36:32 <Asgaroth> If I have a function that takes no arguments and returns an infinite list and I take some elements in several places in my program, will the elements be computed just once and 'cached' or recomputed every time?(using ghc 6.8.2)
07:37:03 <mauke> if it takes no arguments, it's not a function
07:37:14 <BeelsebobWork> Asgaroth: it's not a function, it's a CAF
07:37:18 <BeelsebobWork> (constant application form)
07:37:28 <BeelsebobWork> and it'll only be evaluate once -- within certain constraints
07:37:35 <BeelsebobWork> specifically -- the monomorphism-restriction
07:38:04 <Asgaroth> Ok, thanks. And what about a function which is called several times with the same arguments?
07:38:23 <BeelsebobWork> that will not necessarily be cached
07:38:31 <BeelsebobWork> although the compiler may be clever enough to optimise it
07:38:46 <BeelsebobWork> if you think you're cleverer than the compiler, you may want to wrap said function-call in a CAF
07:39:55 <Cale> That will basically never be cached.
07:40:03 <mauke> that's a form of CSE
07:40:39 <sebaseba> which means?
07:40:49 <Cale> Common subexpression elimination
07:41:07 <Cale> GHC doesn't do anything except a very simple form of CSE which hardly ever applies.
07:41:45 <BeelsebobWork> so what Cale says should be qualified as "if you use a current version of ghc, it'll almost never be cached"
07:41:48 <Cale> Nor will it ever automatically decide to create a memo table to store results of your function calls.
07:41:54 <BeelsebobWork> which isn't to say a future clever compiler won't sort that out
07:42:20 <Cale> It's very difficult to determine that would be a good idea, and it usually isn't.
07:42:27 <BeelsebobWork> yep, /agree
07:42:43 <BeelsebobWork> but there are cases where it is a good idea, and someone may come up with a static analysis for determining that
07:46:54 <dozer> mm, I'm having no fun working unit arithmetic into the type system
07:46:54 <Asgaroth> Perhaps it would be a good idea to make it possible for the programmer to specify functions(maybe as a special comment) for which results should be stored
07:47:38 <Shiruka> you can write a function which does that
07:48:13 <Shiruka> memoizing, that is
07:48:56 <matthew-_> does anyone know what the license is on the small wiki logo - http://www.haskell.org/haskellwiki_logo_small.png ?
07:49:36 <sebaseba> Shiruka: can you do that generically (i.e., a single memoizing function used to memoize different functions)?
07:50:05 <akamaus> Hi. I use hPutStr on a handle obtained by 'accept' from TCP socket. When remote end is closed, my program silently crashes with exit code 141 (SIGPIPE). I tried wrapping hPutStr in 'catch' with no effect. Is this expected behavior? What can be done? Should I install a signal handler?
07:50:14 <BeelsebobWork> Asgaroth: also, as I said, you can just wrap it in a CAF
07:50:23 <Cale> sebaseba: yes, although there are a number of ways to do so.
07:50:29 <Shiruka> yes, but you need some type constraints
07:50:31 <BeelsebobWork> x = f 5 6 7 -- now x will get computed once
07:50:42 <Shiruka> e.g. Ord if you use a Map, Eq if you use a (short) list as the memo table
07:50:44 <Asgaroth> BeelsebobWork: yes, I know, but this should get tedious when you have to do that for several different calls
07:51:01 <Asgaroth> like f 13 in 3 occassion, then f 12 and f 11 in some others
07:51:05 <Shiruka> so you can implement function memo and then just do f = memo f'
07:51:11 <BeelsebobWork> Asgaroth: if you're doing it for several different calls, you're probably kidding yourself about gaining something by storing the result
07:51:14 <Asgaroth> ah thanks
07:51:22 <Cale> There are a bunch of different possible things you might want -- do you want to store the values of the function for some range of small parameters? All parameters? The last n calls? What kind of table should be used?
07:52:25 <Shiruka> the "different possible things you might want" is IIRC the reason why there's no common implementation of it..
07:52:31 <Cale> It's possible to use the lower-level functions made available in GHC to write generic memoising functions (and there's a paper on how to do this), but there isn't really a one-size-fits-all solution
07:52:40 <ddarius> akamaus: Presumably the same license as everything else on the wiki
07:52:52 <Cale> However, there could be a library of common cases, and I have no idea why it's not on hackage yet.
07:53:00 <Cale> ;)
07:53:08 <mauke> akamaus: you should ignore SIGPIPE
07:53:23 <ddarius> matthew-_:
07:53:52 <sebaseba> Cale: yes, a library for common cases of memoization sounds like a good idea
07:55:46 <akamaus> mauke, will I lose portability if I import System.Posix.Signals?
07:56:16 <matthew-_> ddarius: that's what I hoped
07:56:26 <mauke> akamaus: I don't know
08:01:44 <Shiruka> I wrote a simple implementation quickly a long time ago as I happened to need one, but my grasp of unsafePerformIO is shaky even now :-/
08:01:55 <Shiruka> anyway, FWIW that's what I ended up with: http://hpaste.org/9236
08:02:59 <dmead> if i have IO (Either a b)
08:03:12 <dmead> how do you return from IO without having a monadic function?
08:03:21 <dmead> i just want Either a b
08:03:26 <dmead> is it return?
08:03:37 <dmead> > :t return (Either a b
08:03:37 <lambdabot> Unbalanced parentheses
08:03:40 <dmead> > :t return (Either a b)
08:03:43 <lambdabot>   parse error on input `:'
08:03:44 <dmead> > return (Either a b)
08:03:45 <conal> does anyone have a trick for QuickCheck and errors?  i'd like to know what test data was being used when 'error' was invoked.
08:03:46 <lambdabot>   Not in scope: data constructor `Either'
08:04:01 <Saizan> dmead: Either a b is a type, not a value
08:04:13 <dmead> welll i have a function of type either a b
08:05:23 <dmead> so i get back
08:05:24 <dmead> Couldn't match expected type `IO (Either ParseError CSV)'
08:05:24 <dmead>            against inferred type `Either a b'
08:05:54 <dmead> can't you just call return on an IO expression to get a value?
08:06:17 <Saizan> no
08:06:21 <conal> btw, i have a copy of the old ghc Memo module based on weak pointers and stable names.
08:06:23 <Saizan> return is the opposite
08:06:30 <Saizan> return :: a -> IO a
08:06:41 <conal> as described in http://citeseer.ist.psu.edu/peytonjones99stretching.html
08:06:42 <lambdabot> Title: Stretching the storage manager: weak pointers and stable names in Haskell - Jone ...
08:06:49 <akamaus> mauke, your proposal works fine, thanks. Still i guess i'll have troubles with 'installHandler' under windows now
08:06:51 <dmead> oh
08:06:55 <dmead> gotcha
08:06:56 <dmead> and nevermind
08:07:00 <dmead> i was returning a function
08:12:35 <dmead> whats the opposite of return?
08:12:49 <dmead> IO a -> a i suppose
08:14:36 <BeelsebobWork> unsafePerformIO
08:14:48 <BeelsebobWork> but as you might guess, it's not a great idea to use it in a lot of cases
08:15:04 <BeelsebobWork> you should read the documentation about why it's unsafe before you even consider using it
08:15:23 <ddarius> I'm certain it is unnecessary here.
08:17:31 <dmead> well i'm using this package
08:17:33 <dmead> http://hackage.haskell.org/packages/archive/csv/0.1.0/doc/html/Text-CSV.html
08:17:34 <lambdabot> Title: Text.CSV, http://tinyurl.com/6h3v5s
08:18:16 <dmead> parseCSVFromFie has the type FilePath -> IO(Either ParseError CSV)
08:18:20 <dmead> csv is a list of list of strings
08:18:42 <dmead> i'm not clear how to get to the strings once a file is parsed
08:18:53 <hackage> Uploaded to hackage: dephd 0.1
08:19:01 <thoughtpolice> unsafePerformIO surely isn't the way
08:19:10 <dmead> yea
08:19:10 <ddarius> dmead: That's because you don't know how to properly use the IO monad or monads in general.
08:19:17 <dmead> indeed
08:19:26 <BeelsebobWork> dmead: do {x <- parseCSVFromFile "jam.csv"; return $ doSomePureStuff x}
08:19:38 <BeelsebobWork> note -- you probably want to push that as far to the outside of your program as you can
08:19:48 <dmead> yea
08:19:51 <BeelsebobWork> you don't want the IO monad to infect everything
08:20:15 <thoughtpolice> if you look at the docs, CSV == [Record], Record == [Field], Field == String, CSV == [[String]
08:20:23 <thoughtpolice> ]
08:20:34 <dmead> i did
08:20:44 <dmead> i was trying to use IO not at the top level
08:20:50 <dmead> which for me isn't easy
08:20:58 <dmead> ty BeelsebobWork
08:21:03 <BeelsebobWork> well, is your file only being read once dmead?
08:21:08 <dmead> yep
08:21:24 <BeelsebobWork> then unsafePerformIO is actually a possible valid solution
08:21:43 <dmead> right, but isn't it considered bad in general?
08:22:00 <dmead> i thought there would be a more type-safe way to do this
08:22:05 <dmead> no at the top level
08:22:09 <dmead> *not
08:22:13 <thoughtpolice> yes, unsafePerformIO is typically bad.
08:22:15 <Baughn> dmead: What's wrong with readFile?
08:22:29 <Baughn> Yes, you have to pass your String in, but that's easy if your design is good
08:22:43 <dmead> the csv package provides a parser for the csv format
08:22:53 <dmead> which i would have to reproduce if i didn't use it
08:23:37 <Baughn> Okay..?
08:25:14 <dmead> ... if i just used readfile..
08:25:19 <BeelsebobWork> dmead: well, unsafePerformIO doesn't mean you should never use it -- it merely means that the compiler can't check it for you
08:25:28 <BeelsebobWork> so you need to check it very very carefully yourself
08:25:29 <dmead> ah
08:25:55 <Cale> dmead: It should basically never be strictly necessary to do IO anywhere but at the top level of your program though.
08:26:11 <Baughn> dmead: Using unsafePerformIO is almost certainly a mistake unless you're writing FFI code, and the "IO" is not, in fact, actually IO
08:26:15 <BeelsebobWork> Cale: conal would argue that it's not strictly necessary to do IO at the top level either
08:26:24 <Cale> dmead: Haskell sort of enforces a good program design where you separate the user interface of your program from the model.
08:26:45 <dmead> Cale, sure, but what if you want to write UI code ?
08:26:51 <dmead> doesn't that force you to have IO everywhere?
08:26:55 <Cale> No.
08:26:58 <BeelsebobWork> Baughn: nah -- one of my programs for example identifies the position of a bug in some code all in pure code... it then needs to display where that is, so it uses unsafePerformIO to grab your source, and display the apropriate code
08:26:59 <dmead> oh
08:27:07 <Cale> It only forces you to have IO at the top level.
08:27:23 <BeelsebobWork> again, conal would disagree
08:27:28 <Cale> (the code which is really doing the input and output)
08:27:42 <dmead> hmm
08:27:42 <Cale> BeelsebobWork: I'm not sure that he would.
08:27:59 <BeelsebobWork> Cale: I can check -- but we've been having a good few discussions about this recently
08:28:01 <dmead> i could certaintly see that being a disadvantage
08:28:06 <thoughtpolice> dmead: xmonad is a running example
08:28:08 <dmead> what if you wanted threaded IO
08:28:10 <BeelsebobWork> conal really doesn't like the fact that main is IO
08:28:11 <Cale> BeelsebobWork: He would disagree perhaps that a monadic library is the best sort of IO library to use.
08:28:13 <dmead> or some such thing
08:28:15 <thoughtpolice> very thin X11 interface over a pure state machine
08:28:29 <BMeph> Especially considering that conal tends not to disagree, unless it's absolutely necessary... :)
08:28:32 <Cale> dmead: Threads are easy.
08:28:44 <BeelsebobWork> Cale: I'm pretty sure he doesn't see any reason for there to be any interface with an imperative world -- but you'd have to pick his brains yourself
08:29:23 <ayianus> Hm, I have a question, and hope it's not too dumb.
08:29:49 <BeelsebobWork> ayianus: questions are never too dumb
08:29:51 <thoughtpolice> ayianus: no question is dumb.
08:29:52 <Cale> dmead: forkIO, when applied to an IO action turns it into an IO action which will run in a new thread when executed.
08:29:53 <BeelsebobWork> unless you don't ask them
08:30:03 <dmead> Cale so thats a new top level?
08:30:14 <Cale> dmead: if you want to think of it that way...
08:30:23 <BeelsebobWork> Cale: better yet -- just use `par`
08:30:25 <dmead> Cale, i do =)
08:30:29 <Cale> dmead: If all you want is parallelism and not concurrency, then you'd use par.
08:30:42 <BeelsebobWork> dmead: `par` takes two arguments -- they get executed in parallel
08:30:43 <Cale> Or, in the near future, parallel arrays.
08:30:43 <ayianus> Say, you have an operator like the append function for lists defined as:  (++) :: [a] -> [a] -> [a]  -- It's basically a function of two list arguments which yields a new list, the concatenation of the arguments. What I don't understand here is the notation. It basically maps a list to as list which then is mapped to another list.
08:30:49 <Cale> BeelsebobWork: evaluated.
08:30:50 <dmead> kewl
08:30:56 <BeelsebobWork> Cale: idd
08:31:01 <ayianus> Why isn't it written like (++) :: [a, a] -> [a] ?
08:31:03 <dmead> did STM threads go anywhere?
08:31:10 <dmead> i remmeber that being on haskell-cafe for a while
08:31:10 <catface> ayianus: currying
08:31:12 <Cale> ayianus: ah, okay
08:31:20 <BeelsebobWork> ayianus: okay, that's a fun one -- for a start, it would be ([a],[a]) -> [a]
08:31:20 <Cale> ayianus: -> is right associative
08:31:29 <BeelsebobWork> and you can indeed write it like that
08:31:38 <Cale> So  [a] -> [a] -> [a]  really means  [a] -> ([a] -> [a])
08:31:41 <BeelsebobWork> you then have to write the definition so that it accepts a tupple instead of two inputs
08:31:47 <BeelsebobWork> but that has downsides
08:31:53 <BeelsebobWork> you loose the ability to partially apply (++)
08:31:59 <leadnose> doesn't uncurry/curry handle those conversions?
08:32:00 <thoughtpolice> ayianus: the way types are specified is in the form 'n1 -> n2 -> n3 -> ... -> nX' where 'n1...
08:32:06 <Cale> So what this function is actually doing is taking a list, and producing a function which takes a second list, and concatenates the two.
08:32:09 <thoughtpolice> ' etc are the parameters, and nX is your return type
08:32:19 <Cale> heh, maybe too many people answering :)
08:32:22 <BeelsebobWork> i.e. ([5,6,7]++) is a function, which takes a single argument, and sticks [5,6,7] on the front
08:32:30 <thoughtpolice> seems so, i'll let Cale handle it.
08:32:33 <thoughtpolice> :)
08:32:47 <BeelsebobWork> I'm done -- Cale can carry on again
08:32:54 <Cale> > let f = (++) [1,2,3] in f [4,5,6]
08:32:57 <lambdabot>  [1,2,3,4,5,6]
08:33:29 <Cale> Here, the (++) function is first applied to [1,2,3], which gives a function f, which is applied to [4,5,6] to yield the concatenated list.
08:33:38 <BeelsebobWork> > map ([1,2,3]++) [[4,5,6],[7,8,9]]
08:33:41 <lambdabot>  [[1,2,3,4,5,6],[1,2,3,7,8,9]]
08:33:43 <Cale> This is actually how Haskell handles functions of multiple parameters all the time.
08:34:08 <Cale> When you write  f x y  what you're really writing is  (f x) y
08:34:29 <Cale> That is, apply the function f to x to get another function, which is then applied to y
08:34:34 <dmead> > :t par
08:34:36 <lambdabot>   parse error on input `:'
08:34:36 <Cale> Does that make sense?
08:34:41 <dmead> :t par
08:34:43 <lambdabot> forall a b. a -> b -> b
08:34:59 <dmead> > :par (print "hello") (print "world")
08:35:01 <lambdabot>   parse error on input `:'
08:35:02 <dmead> > par (print "hello") (print "world")
08:35:03 <Botje> hah!
08:35:05 <lambdabot>  <IO ()>
08:35:11 <leadnose> I didn't quite understand currying for some time, but I finally got it, you can just substitute the parameters you already have and "wait" for the rest of the paremeters (or at least that's how I think it is :))
08:35:13 <Botje> at least my compiler did an currying transformation :)
08:35:13 <dmead> what.
08:35:14 <Cale> dmead: evaluating  (par x y)  will cause x to be put on a queue of things to be evaluated on a free processor if there's time, before resulting in y
08:35:50 <dmead> Cale can you think of something trivial to do with lambdabot ?
08:35:50 <BeelsebobWork> dmead: if you then compile with --threaded, par will do the two in parallel
08:36:04 <Cale> well, we could do something like...
08:37:19 <Baughn> dmead: s/threaded/threaded and run with +RTS -N2 or higher/
08:37:28 <thoughtpolice> it will still do the two things in parallel because it will fork off a lightweight thread, with --threaded you can just put it on another core.
08:37:34 <thoughtpolice> yeah
08:37:45 <BeelsebobWork> > let fib 0 = 1; fib 1 = 1; fib x = let f1 = fib (x-1); f2 = fib (x-2) in f1 `par` f2 `par` f1+f2 in fib 5
08:37:47 <lambdabot>  8
08:37:52 <BeelsebobWork> still not an efficient algorithm
08:37:57 <BeelsebobWork> but does run in parallel
08:38:02 <ayianus> That is, Cale, (++) in fact creates a function that will append its single argument to the list it was given to by (++) ?
08:38:02 <ayianus> Aye.
08:38:06 <Cale> > let fib 0 = 0; fib 1 = 1; fib n = if n > 10 then let {x = fib (n-1); y = fib (n-2)} in x `par` y `pseq` (x + y) else fib (n-1) + fib (n-2) in fib 30
08:38:08 <ayianus> Cale, indeed, it does. :) Thanks - to all who answered. Lovely channel.
08:38:09 <lambdabot>  832040
08:38:21 <BeelsebobWork> hehe beat you Cale
08:38:26 <Cale> BeelsebobWork: hehe
08:38:38 <dmead> neat
08:38:58 <Cale> You probably don't want to *always* spark the evaluation of fib (n-1) and fib (n-2) because of scheduling costs.
08:39:01 * BeelsebobWork ponders if that's become the standard parallelism example
08:39:01 <dmead> but isn't the fib numbers a  sequential list?
08:39:07 <BeelsebobWork> Cale: indeed
08:39:18 <BeelsebobWork> dmead: indeed... there are more efficient implementations...
08:39:18 <dmead> so won't it not work really in paralell?
08:39:20 <Cale> dmead: Well, this is the doubly recursive algorithm, so it's normally very slow.
08:39:24 <BeelsebobWork> no, that will work in parallel
08:39:34 <Cale> dmead: But it's easy to parallelise :)
08:39:35 <BeelsebobWork> because it's parallelising the inneficiency in the algorithm
08:39:36 <dmead> but the numbers have to be generated in order
08:39:37 <thoughtpolice> dmead: it's recursive, and on each iteration new things are forked off to be executed
08:39:44 <BeelsebobWork> this would be less easy to parallelise...
08:39:46 <dmead> ah
08:39:51 <thoughtpolice> right, so they'll be computed in seperate threads
08:39:57 <Cale> dmead: of course, unless you have a ridiculous number of processors, the sequential version here will work faster.
08:40:00 <BeelsebobWork> > let fibs n m = n : fibs m (n+m) in fibs 1 1 !! 5
08:40:03 <lambdabot>  8
08:40:13 <Cale> dmead: But it's just an example :)
08:40:17 <dmead> so it's only faster because function calls are paralellized?
08:40:32 <thoughtpolice> Cale: i'm not even sure if you have a ridiculous number of cores it will go faster; haven't there been reports of things even slowing down with --threaded and +RTS -Nx ?
08:40:34 <Cale> dmead: well, you parallelise the computation of fib (n-1) and fib (n-2)
08:40:38 <BeelsebobWork> it's faster because it's evaluating more than one fibonacci number at once
08:40:45 <dmead> Cale, ah i see
08:40:49 <Cale> thoughtpolice: for low numbers of cores
08:40:52 <BeelsebobWork> the fact that you don't need to compute them multiple times is by the by
08:41:32 <Cale> thoughtpolice: because scheduling is more complicated for parallelising things, so unless you're getting a lot of parallelism, your program might run slower in the threaded runtime
08:41:43 <thoughtpolice> yeah, those were my initial thoughts
08:41:54 <thoughtpolice> the threaded RTS has to jump through more hoops to scale everything across the processors
08:41:58 <dmead> yea, once you pass your number of cores, doesn't it become slower?
08:42:07 <BeelsebobWork> dmead: that depends
08:42:11 <BeelsebobWork> sometimes, sometimes not
08:42:22 <BeelsebobWork> but there certainly will be a point at which it becomes a lot slower
08:42:24 <dmead> well, in ideal conditions i guess
08:42:27 <Cale> dmead: of course, in this case, the sequential version will eventually win out.
08:42:42 <dmead> Cale, right, because you'd be overwhelmbed by the number of threads
08:42:44 <thoughtpolice> so if you don't have a workload that's 'worth it' then the threaded rts will hamper you, and using multiple cores will hamper it as well
08:42:45 <Cale> well...
08:43:08 <Cale> actually, that might not be entirely true, because the sequential version might only use a tiny fraction of your processing power as well.
08:43:28 <Cale> So probably a combined variant would beat both :)
08:43:42 <BeelsebobWork> dmead: in theory it would be possible for haskell to stick a par in every function call, to evaluate the argument in parallel with the function -- but in practice, this introduces more overhead that necessary
08:43:51 <BeelsebobWork> or rather, more overhead that makes it useful
08:43:58 <dmead> ah
08:44:06 <BeelsebobWork> so the reason for `par` existing is to anotate where you want to add paralelism
08:44:06 <Cale> It will be interesting to see how this ends up performing with nested data parallelism :)
08:44:36 <dmead> Cale, what do you mean by nested data parallelism?
08:44:37 <BeelsebobWork> essentially you're telling the compiler "there's enough work here to make it worth the overhead of spawning a new thread"
08:44:53 <Cale> dmead: It's another approach to parallelism which will be available in some form in the next GHC.
08:45:04 <dmead> ah
08:45:06 <Cale> dmead: Essentially, you have a new data structure, called the parallel array
08:45:27 <dmead> any function called on an element is automatically called with par?
08:45:29 <Cale> Computations on parallel arrays are parallelised, and the work is automatically split in a smart way across processors.
08:45:37 <dmead> ah
08:45:37 <Cale> No, it's more clever than that.
08:45:40 <dmead> ah
08:45:40 <dmead> neat
08:46:06 <dmead> theres something intelligent enough to decide where to put the new thread?
08:46:11 <dmead> or even if it's worth making a new thread?
08:46:15 <Cale> It'll do sequential computation on each processor once it's split up the problem enough.
08:46:35 <Cale> So you'll have a nice tight loop running on each of your processors.
08:46:38 <dmead> cool
08:46:45 <Cale> Not a bunch of wasted scheduling :)
08:46:51 <dmead> =]
08:48:06 <dmead> yea i've been away from haskell for a while
08:48:18 <dmead> a friend of mine wants to collaborate on a simple CAS
08:48:28 <dmead> and for some reason wants to write it in javascript
08:48:29 <Cale> http://www.londonhug.net/2007/09/25/nested-data-parallelism-video-returns/
08:48:31 <lambdabot> Title: λondon HUG  Blog Archive  Nested Data Parallelism Video Returns!, http://tinyurl.com/2pw275
08:48:36 <dmead> the thought of which gives me the dry heaves
08:49:18 <Cale> Well, at least javascript has proper functions. I agree though that it's a strange choice in which to write a CAS.
08:49:28 <dmead> yea
08:49:38 <dmead> someone write an ADT library for it
08:49:49 <dmead> but it still lacks static type checking and good error reporting
08:50:07 <dmead> js is kinda like lisp minus anything good
08:50:29 <Cale> heh
08:54:32 <dmead> ?src foldr
08:54:32 <lambdabot> foldr f z []     = z
08:54:32 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
08:55:22 <Arthurium> Are there any haskell jobs out there?
08:55:42 <bjrn> Arthurium: Credit Suisse I think. Not sure.
08:56:06 <Arthurium> so, if there are it is very limited?
08:57:52 <Saizan> Arthurium: http://www.haskell.org/haskellwiki/Haskell_in_industry
08:57:54 <lambdabot> Title: Haskell in industry - HaskellWiki
08:58:23 <dmead> @hoogle atof
08:58:24 <lambdabot> No matches found
08:58:29 <dmead> @hoogle string to float
08:58:30 <lambdabot> Did you mean: String To Float
08:58:30 <lambdabot> Prelude.undefined :: a
08:58:30 <lambdabot> Test.QuickCheck.Batch.bottom :: a
08:58:38 <dmead> @hoogle string to double
08:58:40 <lambdabot> Did you mean: String To Double
08:58:40 <lambdabot> Prelude.undefined :: a
08:58:40 <lambdabot> Test.QuickCheck.Batch.bottom :: a
08:58:45 <dmead> rawr
08:58:59 <Saizan> dmead: read
08:59:07 <Arthurium> thanks
08:59:11 <Saizan> > read "2.0" :: Double
08:59:14 <lambdabot>  2.0
08:59:18 <dmead> ah thanks
08:59:33 <Saizan> > read "foo" :: Double
08:59:37 <lambdabot>  Exception: Prelude.read: no parse
09:00:42 <dmead> ?src filter
09:00:42 <lambdabot> filter _ []     = []
09:00:42 <lambdabot> filter p (x:xs)
09:00:42 <lambdabot>     | p x       = x : filter p xs
09:00:42 <lambdabot>     | otherwise = filter p xs
09:01:32 <bd_> @hoogle unsafeCoerce
09:01:33 <lambdabot> Unsafe.Coerce.unsafeCoerce :: a -> b
09:08:56 <trinisoftinc> any1 home?
09:09:36 <conal> Cale: i do see main's IO type as both unfortunate and unnecessary.  unfortunate because it mostly breaks composability.
09:10:25 <conal> Cale: for the usual reasons that imperative programming is not very composable.  As Backus (for instance) described.
09:11:04 <Cale> conal: But that's more about the fact that the IO type is imperative than the fact that you can't do IO from any part of the program.
09:12:22 <conal> Cale: it's precisely due to making IO be imperative and and inseparable part of the program.
09:12:43 <conal> (and an)
09:12:53 <dmead> :t >>=
09:13:04 <ddarius> conal: Incidentally, I made a simple IRC bot using the Reactive library a while ago.
09:13:13 <conal> ddarius: yeah?!
09:14:06 <ddarius> http://hpaste.org/8723
09:14:46 * Cale hates hpaste's draconian text limit.
09:15:00 <ddarius> Cale: Just write more concise code.
09:15:21 <Cale> oh, that isn't cut off :)
09:15:49 <Cale> I missed the fact that the last line actually parses :)
09:16:11 <conal> ddarius: nice.  i wonder if you can eliminate all of the explicit IO from the app.
09:17:19 <ddarius> conal: It would require some reactive primitives to perform IO.
09:18:03 <conal> ddarius: hm.  i don't know how such primitives could fit the semantic model.
09:19:03 <ddarius> Just provided event sources for the input stream
09:19:44 <conal> genuinely functional programming is a work in progress.  i'm hopeful that one day we'll leave the intractable semantics (the IO type) behind.
09:20:05 <ddarius> The only places IO is used besides setup is in makeLineEvent and the mapM_ (sendCommand h) in reactiveIrcDriver
09:20:16 <conal> ddarius: that's the bit i was looking at.
09:20:45 <ddarius> reactiveMain is what I conceptually view as the entry point for the actual code.
09:21:09 <conal> ddarius: thx for the focus.  looking ...
09:21:58 <conal> ddarius: now i get it.  looks more functional to me in that light.
09:23:12 <conal> ddarius: yes, Reactive needs to be augmented with a collection of adapters for legacy (i.e., imperative) libraries.
09:23:30 <conal> e.g., HOpenGL
09:25:31 * ddarius needs to return to work.
09:25:47 * conal is going home for dinner
09:27:06 <Cale> Yeah, I sort of wonder what an FFI would look like for Reactive.
09:31:05 <Saizan> am i right that that Event is like the [] Monad, while Reactive is like the Stream/ZipList one?
09:31:52 <conal> Saizan: a fairly close match.  though not too literally.
09:33:15 <conal> Saizan: semantically, Reactive is the ((->) t) applicative
09:33:26 <Saizan> right, because of the times
09:33:45 <conal> Saizan: yeah.  so it's like *continuous* lists, rather than discrete ones.
09:34:41 <conal> off to home for me.  catch you guys later.
09:58:51 <dmead> @hoogle timestamp
09:58:53 <lambdabot> No matches found
09:58:58 <dmead> @hoogle date
09:58:58 <lambdabot> System.Locale.dateTimeFmt :: TimeLocale -> String
09:58:58 <lambdabot> System.Locale.dateFmt :: TimeLocale -> String
09:58:58 <lambdabot> Data.Time.Calendar.OrdinalDate :: module
10:04:51 <dcoutts_> isaacd: http://hackage.haskell.org/trac/hackage/ticket/297#comment:3
10:04:52 <lambdabot> Title: #297 (cabal fetch command don't fetch packages those have already been installed ...
10:06:03 <camio> @run map (+1) [1..]
10:06:08 <lambdabot>  [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
10:06:28 <camio> @run print "hello"
10:06:30 <lambdabot>  <IO ()>
10:06:58 <camio> @run unsafePerformIO $ print "hello"
10:07:01 <lambdabot>   Not in scope: `unsafePerformIO'
10:07:45 <hexpuem> anyone around that has used Data.Reactive?
10:08:07 <camio> hexpuem: Yes
10:08:33 <dons> hey cool, the 4G max memory bug got fixed in ghc.
10:08:39 <dons> go allocate yourself some petabytes!
10:09:00 <hexpuem> i dont understand how to use ReactiveB for continuous behavior
10:09:50 <camio> Yeah, it is a bit confusing.
10:10:04 <camio> A reactive is like a stepper function.
10:10:25 <camio> So for a given chunk of time, it is aone value, for the next chunk it is another, etc.
10:10:52 <camio> So ReactiveB is a reactive in that for each chunk it is a value.
10:10:59 <dcoutts_> dons: yay, that'll help lambdabot ;-)
10:11:02 <camio> What that value is what is important.
10:11:21 <camio> For ReactiveB, the value is a function of time (time->b).
10:11:51 <dons> dcoutts_: :)
10:12:57 <hexpuem> hmm haha
10:14:37 <conal> hexpuem: btw, we're hard at work improving Reactive.  That ReactiveB was just a placeholder.
10:14:58 <hexpuem> cool
10:15:14 <camio> hexpuem: What are you using reactive for?
10:15:18 <cnwdup> @src uncurry
10:15:18 <lambdabot> uncurry f p = f (fst p) (snd p)
10:15:35 <hexpuem> was gonna try to use it to test out animation in opengl
10:15:41 <hexpuem> but havent got that far yet
10:15:57 <lispy> One of the differences I recall between Ocaml and Haskell is that of pattern matching.  In Ocmal, foo (a:as) (b:bs) = ..., would not be allowed.  You can only pattern match on one parameter per equation.  so you'd have to do something like, foo ((a:as),(b:bs)) = ....  Is there a technical reason for this?
10:16:16 <conal> hexpuem: Reactive is designed for use with functional libraries, so opengl may not be a good fit.
10:16:31 <conal> hexpuem: unless you mean a functional library that's implemented via opengl
10:17:09 <camio> hexpuem: Cool. I plan on making a tutorial that does something like that. We've got to work out some bugs in reactive first though.
10:17:13 <hexpuem> nah havent looked at any functional wrappers though
10:17:17 <hexpuem> i just assumed there werent any
10:17:32 <hexpuem> nice
10:17:37 <conal> hexpuem: some of us are working on one called "FieldTrip"
10:17:57 <conal> hexpuem: which is functional and will play nicely with Reactive.
10:18:20 <lispy> I was wondering if Haskell's purity alows for eta-expansion/reduction for free and that might be why Haskell allows what Ocaml does not?
10:18:37 <conal> hexpuem: an functional imaging synthesis/manipulation library as well, which may look something like Pan (http://conal.net/Pan)
10:18:38 <lambdabot> Title: The Pan Home Page
10:18:52 <lispy> But, then I don't really know that pattern matching and eta expansion are related?
10:18:53 <hexpuem> you have a site set up for fieldtrip yet?
10:19:06 <conal> hexpuem: not yet.
10:19:25 <conal> hexpuem: will also be in good shape by the end of the summer
10:20:04 <hexpuem> should be interesting
10:20:42 <conal> hexpuem: one of FieldTrip's nice features is that it handles genuinely curved surfaces, rather than finite approximations.
10:21:14 <conal> hexpuem: and computes normals exactly, using the differentiation ideas mentioned in my blog.
10:21:42 <hexpuem> yea i was looking at your blog earlier
10:23:52 <conal> hexpuem: feel free to leave a comment.  i like comments.
10:24:36 <hexpuem> ok cool haha
10:25:55 <Cale> conal: I wonder what possible issues there would be in having  Event (IO a) -> Event a
10:27:21 <olsner> like, safePerformIO = fromIOEvent . return?
10:27:56 <conal> Cale: probably about the same as [IO a] -> [a]
10:28:14 <conal> Cale: i mean about the same issues as with [IO a] -> [a]
10:29:43 <Cale> Well, we don't have Event a -> a, do we?
10:30:36 <conal> Cale: why that question?
10:31:05 <Cale> Well, I'm wondering about the typesafety.
10:31:26 <Cale> We don't want to allow the user to construct unsafePerformIO using it.
10:31:52 <__pao___> http://hpaste.org/9241
10:32:02 <__pao___> I'd like to memoize that function
10:32:28 <__pao___> ... just a haskell learning exercise...
10:32:29 <conal> Cale: Event has simple, functional (no IO) semantics and implementation.
10:32:40 <__pao___> is it StateT of any use?
10:32:56 <conal> Cale: in the new Reactive, which is described in my "simply" paper
10:33:24 <__pao___> the idea to use a memoizing map as the state to modify
10:33:37 <dino-> When I do ghc -e '' things, is there a way I can import things?
10:33:44 <Cale> __pao___: well, what domain do you want to memoise it on?
10:33:59 <dino-> Not that important, just curious.
10:34:13 <Cale> __pao___: the easiest way to memoise is usually just to define a constant which remains in scope and holds the values
10:34:47 <__pao___> Cale: if you mean what signature the map has.... Map (String,Op) [Integer]
10:35:11 <__pao___> Cale: thanks for the suggestion
10:35:14 <__pao___> I'll try
10:36:01 <Cale> __pao___: mm... however...
10:36:03 * andyjgill working on quickcheck properties for reactive; hopefully helping push towards release.
10:36:24 <__pao___> Cale: I really can't help :-)
10:36:36 <Cale> __pao___: I suppose that doesn't work out so well here, because you'd need to know exactly which (Op,String) pairs to memoise for to begin with
10:36:40 <conal> andyjgill: i'm doing the same.  actively QC'ing reactive.
10:36:40 <__pao___> Cale: have I given a look to the paste?
10:36:48 <Cale> conal: hmm, right.
10:39:09 <conal> andyjgill: i'm working on a new library, "checkers", that has a bunch of useful QuickCheck properties and Arbitrary instances.  The properties are mainly ones associated with type classes and the corresponding morphisms (as in my "simply" paper).
10:39:24 <andyjgill> conal: I want a way of having a value that starts evaluating after a specific period of time, to test the Unamb stuff. Pulling the arbitrary might pause!
10:39:30 <conal> andyjgill: the class laws & morphisms cover most of Reactive.
10:39:37 <andyjgill> Using Double as the time?
10:39:58 <sal23>  if function f calls g with a list, say (f (g l)), is g passed a copy of l, or l itself?
10:40:33 <conal> andyjgill: i'm testing Unamb & Improving separately from the main Reactive types.  so yes, using a simple type for time.
10:40:35 <andyjgill> sal23: it is impossible in Haskell to tell the difference. l is always a value
10:41:09 <lispy> how is foo (a:as) (b:bs) = ..., desugared?
10:41:15 <andyjgill> conal: Great!
10:41:19 <lispy> Into a case expression, right?
10:41:24 <Cale> lispy: yes
10:41:31 <Cale> lispy: nested case expressions
10:41:40 <lispy> Nested, okay
10:41:44 <mar77a> is there a way to see desguared code
10:41:51 <mar77a> pre compile to C code stage
10:41:53 <sal23> andyjgill: I asked because of this writeup which mentioned that treemap takes a copy...http://tinyurl.com/2fyynu
10:41:54 <lambdabot> Title: Map fusion: Making Haskell 225% faster
10:42:43 <Cale> mar77a: The default is to compile to native code these days, btw. You can -ddump-simpl if I'm remembering the flag correctly
10:42:59 <lispy> foo x y = case (a:as) of { case (b:bs) of { ... } }, and what happens if those cases fail?  Oh, so we take all the equations that define the function and desugar them together into set of nested cases?
10:43:05 <Cale> mar77a: which dumps the core Haskell code after desugaring and lots of manipulation
10:43:07 <thoughtpolice> there's -ddump-simpl to dump core, as well as -ddump-stg to dump the STG
10:43:08 <mar77a> doesn't it go through the C code when compiling to native too?
10:43:16 <Cale> mar77a: no.
10:43:23 <thoughtpolice> mar77a: no, it's either the native code gen or the C backend
10:43:34 <thoughtpolice> after C-- is generated the compiler takes one of the two paths
10:43:36 <mar77a> mm
10:44:05 <Cale> lispy: right
10:44:11 <thoughtpolice> mar77a: there're a *lot* of flags to see the intermediate output, everything from C-- to simplifier output (core) to stg to bytecode output if using ghci/runghc
10:44:14 <thoughtpolice> check the manual
10:44:42 <lispy> Cale: thanks
10:44:43 <Cale> and that's getting even more rich with the compiler plugin architecture going in :)
10:44:57 <thoughtpolice> mar77a: specifically here - http://haskell.org/ghc/docs/6.8.3/html/users_guide/options-debugging.html
10:44:58 <lambdabot> Title: 5.16. Debugging the compiler, http://tinyurl.com/6r82wf
10:45:09 <thoughtpolice> that's just about every flag you can possibly pass to see intermediate output
10:45:41 <thoughtpolice> Cale: indeed. hopefully it can be put to good use quickly enough :)
10:45:58 <Cale> sal23: not a copy, just a new tree.
10:47:10 <Cale> sal23: treeMap f t  will construct a new tree whose nodes are similar to t's nodes, except that for each value x held on the nodes, there is f x instead.
10:48:09 <Cale> sal23: So the complaint is that this will involve lots of allocation, producing lots of short-lived garbage. GHC is pretty good at collecting such garbage, but it still takes time :)
10:48:48 <sal23> cale: I got that part....what I was trying to figure out was how to spot if intermediate objects are created...
10:48:58 <sal23> hence, the question...
10:49:24 <Cale> sal23: Well, you see the constructors on the right hand side of the equations for treeMap
10:49:42 <sal23> yep....that would make sense
10:51:32 <Cale> To look at your original question more directly, what actually happens when you have f (g l) is that the first step is that f is called with the expression (g l) as a parameter.
10:52:08 <dmead> how do you delist something?
10:52:22 <sal23> right...that shouldn't create any intermediate objects because the result of (g l) should be directly passed back to f
10:52:24 <dmead> [1] blah blah returns 1?
10:52:31 <Cale> dmead: head ?
10:52:35 <camio> dmead: foldr
10:52:43 <Cale> dmead: be careful about the empty list case though
10:52:44 <dmead> isn't that for tuples?
10:52:51 <Cale> fst and snd are for pairs
10:52:55 <dmead> ah
10:53:01 <Cale> > head [1,2,3]
10:53:04 <lambdabot>  1
10:53:07 <Cale> > head []
10:53:10 <lambdabot>  Exception: Prelude.head: empty list
10:53:56 <camio> >foldr (:) [] [1,2,3,4]
10:54:05 <camio> > foldr (:) [] [1,2,3,4]
10:54:09 <lambdabot>  [1,2,3,4]
10:54:16 <Cale> sal23: so if we have... treeSum (treeIncr (Node Empty 0 Empty)), say
10:54:18 <camio> > foldr (+) 0 [1,2,3,4]
10:54:20 <lambdabot>  10
10:54:29 <Cale> treeSum (treeIncr (Node Empty 0 Empty))
10:54:42 <Cale> --> treeFold (\l x r -> l+x+r) 0 (treeIncr (Node Empty 0 Empty))
10:55:10 <Cale> --> treeFold (\l x r -> l+x+r) 0 (treeMap (+1) (Node Empty 0 Empty))
10:55:49 <Deewiant> @pl \l x r -> l+x+r
10:55:50 <lambdabot> ((+) .) . (+)
10:56:01 <Cale> --> treeFold (\l x r -> l+x+r) 0 (Node (treeMap (+1) Empty) ((+1) 0) (treeMap (+1) Empty))
10:57:07 <Cale> --> (\l x r -> l+x+r) (treeFold (\l x r -> l+x+r) 0 (Node (treeMap (+1) Empty)) ((+1) 0) (treeFold (\l x r -> l+x+r) 0 (treeMap (+1) Empty)))
10:57:24 <Cale> --> (treeFold (\l x r -> l+x+r) 0 (Node (treeMap (+1) Empty)) + ((+1) 0) + (treeFold (\l x r -> l+x+r) 0 (treeMap (+1) Empty)))
10:58:01 <Cale> er, oops... forgot to delete that "Node" there ;)
10:58:25 <Cale> But you get some idea of how it goes :)
10:58:42 <sal23> yeah, thanks :)
10:59:58 <Cale> Of course, what's actually going on at the CPU level is a bit different, and you can never be 100% sure about how the code might be transformed without looking at the core, but as a first approximation, just doing reductions symbolically by hand is a good way to understand performance.
11:00:16 <Cale> Space can be estimated using the size of the expressions you need to write :)
11:01:04 <dmead> > map head [[1],[2],[3]]
11:01:07 <lambdabot>  [1,2,3]
11:01:14 <Cale> > concat [[1],[2],[3]]
11:01:17 <lambdabot>  [1,2,3]
11:01:25 <Cale> > map head [[1],[],[3]]
11:01:30 <lambdabot>  [1,Exception: Prelude.head: empty list
11:01:35 <Cale> > concat [[1],[],[3]]
11:01:38 <lambdabot>  [1,3]
11:02:00 <Cale> > map head [[1],[2,5],[3]]
11:02:02 <lambdabot>  [1,2,3]
11:02:07 <Cale> > concat [[1],[2,5],[3]]
11:02:11 <lambdabot>  [1,2,5,3]
11:02:45 <camio> > foldr ((:).head)) [[1], [2], [3,4]]
11:02:45 <lambdabot> Unbalanced parentheses
11:02:52 <camio> > foldr ((:).head) [[1], [2], [3,4]]
11:02:55 <lambdabot>  <[[[Integer]]] -> [[Integer]]>
11:03:04 <camio> > foldr ((:).head) [] [[1], [2], [3,4]]
11:03:07 <lambdabot>  [1,2,3]
11:03:47 <Cale> > take 1 =<< [[1],[],[2],[3,4]]
11:03:50 <lambdabot>  [1,2,3]
11:04:39 <camio> nice
11:09:11 <camio> > pure 3 :: [Int]
11:09:13 <lambdabot>  [3]
11:09:26 <baaba> @src pure
11:09:27 <lambdabot> Source not found. Take a stress pill and think things over.
11:10:13 <tromp> :t pure
11:10:15 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
11:11:01 <ziman> > (+) <*> [1, 2, 3] <$> [4, 5, 6]
11:11:03 <lambdabot>  Couldn't match expected type `a -> a' against inferred type `[a1]'
11:11:10 <tromp> > pure 3 :: Maybe Int
11:11:12 <lambdabot>  Just 3
11:11:15 <camio> > liftA (+1) (pure 3) :: [Int]
11:11:18 <lambdabot>  [4]
11:11:25 <camio> > liftA (+1) (pure 3) :: Maybe Int
11:11:28 <lambdabot>  Just 4
11:13:15 <camio> (liftA.liftA) (+1) ((pure.pure) 3) :: [[Int]]
11:13:18 <camio> > (liftA.liftA) (+1) ((pure.pure) 3) :: [[Int]]
11:13:20 <lambdabot>  [[4]]
11:13:29 <camio> > (liftA.liftA) (+1) ((pure.pure) 3) :: [Maybe Int]
11:13:31 <lambdabot>  [Just 4]
11:13:40 <camio> > (liftA.liftA) (+1) ((pure.pure) 3) :: Maybe [Int]
11:13:42 <lambdabot>  Just [4]
11:14:55 <ziman> > let wrap 0 x = x; wrap n x = wrap (n-1) [x] in wrap 10 4
11:14:57 <lambdabot>      Occurs check: cannot construct the infinite type: t = [t]
11:14:57 <lambdabot>       Expected...
11:15:25 <Deewiant> > let wrap 0 x = x; wrap n x = wrap (n-1) [x] in wrap 10 [4]
11:15:26 <lambdabot>      Occurs check: cannot construct the infinite type: t = [t]
11:15:26 <lambdabot>       Expected...
11:15:41 <Deewiant> oh, oops
11:16:07 <Deewiant> x = [x] can't work
11:16:11 <ziman> yes..
11:16:32 <Deewiant> so what are you looking for? :-)
11:16:35 <ziman> i think the wrap level must be known at compile time
11:16:37 <sal23> Cale: where can I report a compilation error for lambdabot (downloaded through cabal) on Mac 10.5 ?
11:16:40 <ziman> just playing :)
11:16:48 <Cale> sal23: to me
11:16:54 <Deewiant> ah yes, you wanted to apply [] 10 times
11:17:06 <Cale> sal23: However, I don't have a Mac to try to get it to compile on... what is the issue?
11:17:07 <Deewiant> and no, that can't work, since the type must be statically known
11:17:14 <Cale> oh wait
11:17:19 <Cale> sal23: through cabal?
11:17:28 <Cale> sal23: The lambdabot on hackage is unsupported.
11:17:43 <sal23> well, I don't have mac here right now...but the 9th script in compilation order is failing because of error in executing ghc-asm on ghc 6.8.4
11:17:56 <dcoutts_> Cale: it would be nice if there were a supported release, is the darcs version supported?
11:17:58 <sal23> I tried both cabal version, and the version downloaded from lambdabot page
11:18:02 <Cale> dcoutts_: yes
11:18:08 <sal23> same error
11:18:23 <dcoutts_> Cale: but there's some reason you can't make a release?
11:18:38 <Cale> dcoutts_: I suppose I could.
11:18:55 <dcoutts_> Cale: it'd stop all the people complaining that it doesn't work :-)
11:18:57 <hackage> Uploaded to hackage: RandomDotOrg 0.2.1
11:18:57 <hackage> Uploaded to hackage: RandomDotOrg 0.2
11:18:59 <Cale> Someone else put up that lambdabot on hackage.
11:19:11 <dcoutts_> Cale: ah, they need spanking
11:19:25 <sal23> yeah, I second that
11:19:26 * dcoutts_ notes that we're implementing per-package auth
11:19:36 <dcoutts_> and there's a new upload policy
11:19:58 <Cale> sal23: Did you say 6.8.4?
11:20:02 <Cale> http://code.haskell.org/lambdabot/
11:20:02 <lambdabot> Title: Index of /lambdabot
11:20:05 <sal23> yep....
11:20:10 <Cale> that's the version which ought to work
11:20:20 <dcoutts_> Cale: that, or ask for the hackage version to be taken down.
11:20:23 <Cale> But I don't know -- does hs-plugins work on mac?
11:20:44 <sal23> well, I can check and get back to you
11:20:45 <dmead> >head [[1],[2],[3]]
11:20:51 <dmead> > head [[1],[2],[3]]
11:20:53 <lambdabot>  [1]
11:20:59 <Cale> sal23: It would help if I knew what the compilation error was :)
11:21:03 <dmead> > head [[12],[2],[3]]
11:21:05 <lambdabot>  [12]
11:21:10 <dmead> > head [[[12],[2],[3]]]
11:21:12 <lambdabot>  [[12],[2],[3]]
11:21:32 <dmead> > [[12],[2],[3]] =>>
11:21:34 <lambdabot>   parse error on input `}'
11:21:40 <sal23> absolutely....will send it after I get to run the compilation script again, this evening
11:21:40 <dmead> > [[12],[2],[3]] >>=
11:21:42 <lambdabot>   parse error on input `}'
11:21:50 <dmead> > [[12],[2],[3]] >>= x
11:21:51 <lambdabot>  Couldn't match expected type `[t] -> [b]'
11:22:07 <Cale> > [[12],[2],[3]] >>= head
11:22:08 <lambdabot>   add an instance declaration for (Num [b])
11:22:24 <dmead> i'm getting strange results
11:22:29 <Cale> > [[12],[2],[3]] >>= id
11:22:30 <lambdabot>  [12,2,3]
11:22:35 <dmead> oh
11:22:46 <dmead> thats what i was looking for
11:22:52 <Cale> > concat [[12],[2],[3]]
11:22:54 <lambdabot>  [12,2,3]
11:23:08 <Cale> is the same thing, but less obfuscated :)
11:23:10 <dmead> ?src concast
11:23:10 <lambdabot> Source not found. It can only be attributed to human error.
11:23:11 <dmead> right
11:23:19 <Cale> @src concat
11:23:19 <lambdabot> concat = foldr (++) []
11:24:27 <ndm> @seen dcoutts
11:24:27 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-soc, #haskell-overflow, #ghc and #haskell. I last heard dcoutts speak 5h 56m 58s ago.
11:24:38 <dcoutts_> hia ndm
11:24:54 <ndm> dcoutts_: bug report for Cabal, passing --verbose to runhaskell Setup haddock does not pass the --verbose flag to haddock
11:25:51 <DuClare> Humm, is there something that could give me a report of functions & types and stuff that never gets used?  It's surprisingly easy to forget some deprecated code in when you change design… :o
11:26:24 <dcoutts_> ndm: yes it does. Use -v3
11:26:48 <ndm> dcoutts_: i'd have thought --verbose to cabal gave --verbose to haddock
11:26:52 <dcoutts_> ndm: -v == -v2 == higher verbosity, echo commands
11:27:11 <dcoutts_> ndm: -v3 == deafening verbosity, echo commands (in greater detail) and pass -v to tools
11:27:44 <dcoutts_> ndm: passing -v to ghc all the time would drive everyone insane :-)
11:28:20 <lilachaze> ziman: http://hpaste.org/9242
11:28:36 <ndm> dcoutts_: ok, fair enough - just surprisingly that --verbose in one does not imply in the other - but i understand why
11:30:01 <dcoutts_> ndm: yeah, we have to have levels of detail or it's just silly. The more common case is to want to just see how it's invoking things so that's why -v == -v2 and not -v3
11:30:21 <Deewiant> {-# GHC_OPTIONS -v3 #-}
11:30:31 <dcoutts_> with -v1 being default and -v0 being silent
11:30:32 <lilachaze> Deewiant: isn't it OPTIONS_GHC ?
11:30:48 <Deewiant> lilachaze: sounds right, yeah.
11:31:03 <geezusfreeek> DuClare: well, you could make sure you are only exporting what you plan to use from each module and compile with -Wall
11:31:19 <geezusfreeek> anything that isn't exported or used by something that's exported will trigger a warning
11:31:34 <pozic> How can I see what version of cabal I am using?
11:31:55 <dcoutts_> pozic: cabal --version, or if you mean the Cabal lib then use ghc-pkg list Cabal
11:32:10 <pozic> dcoutts_: must be an old version then.
11:32:15 <pozic> dcoutts_: it has no such option.
11:32:25 <dcoutts_> pozic: that must be a very old version
11:33:04 <pozic> dcoutts_: and I am moving one application between two applications. Is there a way to install lots of libraries with one go when they are on separate lines in a textfile?
11:33:08 <dcoutts_> pozic: there have been massive improvements to cabal-install since the era when it had no --version flag
11:33:23 <pozic> dcoutts_: just a simple shell script, or is there some better solution?
11:33:35 <dcoutts_> pozic: cabal install pkg1 pkg2 pkg3
11:33:38 <ayianus> Mhh. I am trying to get into Haskell, practically since yesterday, and the more time I spend exposing myself to the actual paradigm, the clearer it becomes that all those types of UML diagrams used in OO programming are essentially inapplicable here.
11:33:51 <dcoutts_> pozic: or if they're all deps of one or two packages, just list those, it finds the deps automatically
11:34:00 <ayianus> But suppose you'd be facing a pretty profound programming project that definitely needs some preparations in form of plans as to how to exactly proceed - how would you go about it?
11:34:03 <ndm> ayianus: they are inapplicable in most places :)
11:34:34 <dcoutts_> pozic: as for extracting them from a text file, I guess you could do some shell script foo
11:34:36 <ndm> ayianus: you can do the same diagrams, but think about the data, instead of the objects - think what data flows round the system, what its type is
11:34:58 <ndm> ayianus: its the same style as bottom-up, but even more so than OO stuff
11:35:00 <pozic> dcoutts_: it seems I need to install cabal again on a different machine with the same laborious method.
11:35:11 <dcoutts_> pozic: if it's names in a file, one line each then this should work: cabal install --dry-run $(cat foo.txt)
11:35:16 <lament> ayianus: package diagrams are still useful, for one
11:35:43 <lament> as are use case diagrams
11:36:19 <ayianus> Well, that is one could go about it using data flow diagrams to represent the "expression", that is the data flow in the actual Haskell program, and use package diagrams to do that type of "namespacing" what modules are there for, for example?
11:38:20 <lament> ayianus: sure
11:39:16 <dcoutts_> pozic: you mean installing cabal-install is a pain because it has some deps? yeah that's a problem until we have it in a platform release.
11:39:52 <pozic> dcoutts_: yes, but I have a script to install cabal packages, and I got the sources form the LAN already.
11:40:00 <pozic> dcoutts_: it should me a matter of 3 commands now.
11:40:23 <twobitwork> ?pl (\n -> product [1..n])
11:40:23 <lambdabot> product . enumFromTo 1
11:40:25 <dcoutts_> pozic: does your script do anything that cabal-install does not do?
11:40:44 <ayianus> lament, aye.
11:40:47 <dcoutts_> pozic: if so what, we want cabal-install to cover this kind of thing
11:40:52 <pozic> dcoutts_: this is the runhaskell configure; build etc. stuff.
11:41:00 <pozic> dcoutts_: which is only needed until cabal-install is there.
11:41:04 <nominolo> @users
11:41:04 <lambdabot> Maximum users seen in #haskell: 492, currently: 492 (100.0%), active: 25 (5.1%)
11:41:10 <pozic> dcoutts_: that was the first thign I did.
11:41:14 <pozic> thing*
11:41:16 <dcoutts_> pozic: right, so cabal-install does that.
11:41:34 <ayianus> One additional, perhaps premature, question: Can Haskell be used as a hardware description language?
11:41:37 <dcoutts_> pozic: or you mean this is a script to install cabal-install on machines where it's not already installed?
11:41:50 <dcoutts_> ayianus: yep, see lava
11:41:55 <nominolo> ayianus: people do so
11:41:57 <dmead> how do you switch window panes in emacs?
11:42:10 <ayianus> dcoutts_, a package for Haskell?
11:42:17 <dcoutts_> ayianus: yes
11:42:20 <dons> wow.
11:42:23 <dons> 492.
11:42:33 <nominolo> dmead: C-h f frame-next
11:42:37 <vixey> @userss
11:42:37 <lambdabot> Maximum users seen in #haskell: 492, currently: 491 (99.8%), active: 26 (5.3%)
11:42:42 <dons> nominolo: where'd everyone come from?
11:42:45 <dcoutts_> ayianus: a hardware description language embedded in Haskell
11:42:50 <dons> did something happen we weren't told about?
11:42:53 <vixey> @users
11:42:54 <lambdabot> Maximum users seen in #haskell: 492, currently: 492 (100.0%), active: 26 (5.3%)
11:42:57 <vixey> 100% !!
11:43:18 <dcoutts_> why does my client say there are 489 then?
11:43:41 <vixey> dcoutts_: mine says that too..
11:43:47 <nominolo> dmead: sorry, it's next-frame.  which it says is C-x 4 C-o RET -- Easy!! :)
11:43:47 <Deewiant> as does mine
11:44:00 <dmead> :P
11:44:00 <dmead> ty
11:44:13 <vixey> we just need 8 more..
11:44:22 <dmead> hmm
11:44:24 <dmead> doesnt' work for me
11:44:27 <nominolo> dmead: i mapped it to A-` al
11:44:49 <ayianus> dcoutts_, hah. That's pretty cool. Thanks.
11:45:27 <nominolo> dons: if something happened, i don't know about it either
11:46:00 <dmead> i can't run next-frame on the minibuffer
11:46:14 <dmead> you should be able to right?
11:49:56 <nominolo> dmead: no, it seems it's not an interactive function
11:50:07 <dmead> oh
11:51:07 <nominolo> dmead: ah it's "other-frame", so C-x 5 o
11:51:12 <nominolo> or A-`
11:52:17 <dmead> hmm
11:52:23 <dmead> thats return for me
11:52:53 <nominolo> well, A is apple-key on my machine
11:52:57 <dmead> ah
11:52:58 <dmead> :P
11:53:00 <dmead> i'm on gentoo
11:53:21 <dmead> > last [1..10]
11:53:22 <lambdabot>  10
11:54:05 <nominolo> just type "C-k C-x 5 o" or C-h f other-frame" and it will probably show you all other aliases
11:54:22 <nominolo> it could be that A-` is from the mac emulation mode
11:54:52 <nominolo> oh, sorry, not C-k but C-h k
11:56:14 <lament> "just"
11:56:45 <EvilTerran> lament, i was thinking the very same thing
11:57:07 <tusho_> http://rant.blackapache.net/2008/07/28/a-better-nub/ lol
11:57:08 <lambdabot> Title: A Better nub " OJs rants
11:57:17 <tusho_> Because, of course, every Haskell implementation uses the stock Prelude.
11:57:33 <lament> @src nub
11:57:34 <lambdabot> nub = nubBy (==)
11:57:47 <tusho_> lament: @src != ghc
11:57:58 <lament> so ghc lies? :(
11:58:05 <Saizan> tusho_: nub is O(n) because of its type
11:58:10 <Saizan> err
11:58:14 <Saizan> O(n^2)
11:58:18 <lament> you import prelude, but its definitions aren't actually used?
11:59:00 <tusho_> lament: GHC has its own Prelude.
11:59:02 <tusho_> Nothing magical.
11:59:09 <tusho_> It just doesn't use the Haskell Report's.
11:59:32 <Deewiant> I'm sure the Haskell Report specifies that nub require only Eq, though.
12:00:02 <dolio> GHC's Prelude should be pretty close to the report's prelude.
12:00:08 <Saizan> btw, nub is in Data.List
12:00:18 <dolio> It might import things from GHC modules for implementation, though.
12:01:40 <dolio> Considering Prelude is a H98 module, not a hierarchical module, it should be the same (semantically), really.
12:02:02 <vixey> Prelude sux :p
12:02:16 <vixey> it's so annoying you can't replace Monad []
12:02:19 <dolio> Yeah.
12:02:37 <vixey> and can't name variables type or in ... but that's not preludes fault
12:05:59 <Beelsebob> @src foldr
12:05:59 <lambdabot> foldr f z []     = z
12:05:59 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
12:06:19 <Beelsebob> gah, I wanted the efficient version
12:07:36 <Deewiant> foldr k z xs = go xs where go [] = z; go (y:ys) = k y (go ys)
12:08:04 <Beelsebob> cheers :)
12:09:58 <Saizan> does that still make a difference?
12:10:42 <Beelsebob> dunno -- I just wanted a small example of some Haskell using a 'go' function
12:15:52 <pozic> Beelsebob: go = go --very tight loop
12:16:01 <Beelsebob> heh
12:16:03 <Beelsebob> thank you
12:16:45 <Deewiant> > let go = go in go
12:17:00 <lambdabot>  thread killed
12:17:03 <Deewiant> meh, I was hoping for <<loop>>
12:18:22 <kaol> > fix id
12:18:37 <lambdabot>  thread killed
12:18:49 <tac-tics> you shouldn't try to fix what isn't broken
12:18:54 <hackage> Uploaded to hackage: cedict 0.2.4
12:19:26 <Deewiant> > fix (1:)
12:19:27 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
12:19:34 <FordCortina> :t fix id
12:19:34 <lambdabot> forall a. a
12:20:00 <tac-tics> :t undefined
12:20:01 <lambdabot> forall a. a
12:20:08 <Deewiant> :t error ""
12:20:09 <lambdabot> forall a. a
12:20:31 <tac-tics> :t error (undefined (fix id) )
12:20:32 <lambdabot> forall a. a
12:20:46 <FordCortina> hehe
12:20:54 <kaol> @pl let go = go in go
12:20:54 <lambdabot> fix id
12:20:57 <Deewiant> ?ty head . fix $ (++)
12:20:58 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
12:21:01 <Deewiant> O_o
12:21:33 <dcoutts_> ndm: actually it wasn't working -v3 didn't pass --verbose to haddock
12:21:41 <dcoutts_> ndm: did you discover that too?
12:22:09 <dcoutts_> ndm: the code was checking if verbosity > deafening then ["--verbose"] else []
12:22:25 <ndm> dcoutts_: i managed to solve my issue without it
12:22:25 <dcoutts_> ndm: which is of course bogus since deafening is the maximum verbosity
12:22:43 <ndm> dcoutts_: ["--verbose" | verbosity == deafening]
12:22:45 <dcoutts_> ndm: --haddock-option=--verbose would also work
12:22:54 <ndm> dcoutts_: bow to the power of the list comps :)
12:23:03 <dcoutts_> ndm: I know, I use that in places
12:23:07 <ndm> i ended up adding a Debug.Trace into the Haddock source and recompiling
12:23:12 <dcoutts_> ndm: though some people think it's cryptic
12:23:29 <ndm> dcoutts_: some people think lazy evaluation is a bad idea ;)
12:23:56 <dcoutts_> ndm: heh, but these are otherwise right thinking haskell hackers
12:24:11 <dcoutts_> I used that trick and they balked
12:24:25 <ndm> we need reeducation camps
12:24:43 <tac-tics> What about graph reduction camps?
12:25:24 <solrize> hey dcoutts
12:25:32 <dcoutts_> hia solrize
12:25:45 <solrize> i had a gzip lib request
12:25:49 <solrize> zlib i mean
12:26:33 <dcoutts_> solrize: yeah?
12:26:50 <solrize> it would be nice to be able to get at the InflateSetDictionary and DeflateSetDictionary entries from the C lib
12:27:08 <solrize> i have a bazillion or so small (50-100 char) strings that i want to store in a random access database
12:27:42 <solrize> and it would be good to be able to compress them with a fixed dictionary (e.g. if they are xml strings the dictionary would be initialized from some big xml doc, similarly for english strings etc)
12:27:49 <solrize> what i really want is something like
12:28:12 <solrize> zmap :: Corpus -> (String -> CompressedString, CompressedString -> String)
12:28:27 <solrize> where corpus is some big document that zmap gets statistics from
12:28:51 <solrize> and gives back a pair of functions so that   compress "george washington"  comes back as a shorter string (maybe 10 chars)
12:29:45 <solrize> and i think i can do that with the *flateSetDictionary functions
12:29:53 <Peaker> "Today's lecture will be about Lazy Evaluation.  Any questions?"
12:29:57 <solrize> peaker :)
12:30:10 <Peaker> that's a nice reddit :)
12:32:01 <tac-tics> I wonder if any professor has ever made that joke in class
12:32:16 <ziman> :D
12:32:23 <solrize> tac-tics i was thinking of scott aaronson
12:32:23 <lament> too bad the guy provided -explanations- for all his koans
12:32:43 <EvilTerran> lament, by popular request, i believe it said
12:32:47 <Gnezdo> Hello, any Parsec experts around?
12:32:52 <Gnezdo> http://hpaste.org/9245
12:32:52 <lament> EvilTerran: doesn't matter!
12:33:02 <calvins_> Does anybody know how to get color console output from a haskell script? I'm outputting the correct escape code (echo -e of the same output shows color), but the output just shows the escape code. I realize I could call from haskell, but it seems like there should be a better way. Any ideas?
12:33:32 <calvins_> i meant "could call *echo* from haskell"
12:33:34 <dcoutts_> solrize: hmm, I see
12:33:38 <Gnezdo> for some reason manyTill doesn't like me...
12:33:42 <Trinithis> @pl scanr (const (0 :)) [1] $ genericReplicate (dim - 1) ()
12:33:42 <lambdabot> scanr (const (0 :)) [1] (genericReplicate (dim - 1) ())
12:33:51 <solrize> scott aaronson used to say he was better at answering questions than predicting ahead of time what the audience needed to hear.  so his ideal lecture just started "any quesitons?"
12:34:38 <tac-tics> The problem with that strategy is second order ignorance. What if the students don't even know what they don't know?
12:34:39 <Trinithis> Is there a better way of creating the lists [[1], [0,1], [0,0,1]...] than scanr (const (0 :)) [1] $ genericReplicate (dim - 1) ()?
12:34:50 <calvins_> wow, #haskell is almost at 500 users. i haven't been around much for a while, but it's really grown.
12:34:54 <nominolo> > toChar 27
12:34:55 <lambdabot>   Not in scope: `toChar'
12:35:04 <nominolo> @hoogle Int -> Char
12:35:05 <lambdabot> Data.Char.intToDigit :: Int -> Char
12:35:05 <lambdabot> Data.Char.chr :: Int -> Char
12:35:05 <lambdabot> Data.PackedString.indexPS :: PackedString -> Int -> Char
12:35:11 <nominolo> > chr 27
12:35:12 <lambdabot>  '\ESC'
12:35:13 <dcoutts_> solrize: for the api, why not just have the dict as an extra parameter to inflate / deflate ?
12:35:21 <ziman> Trinithis, reverse (1:replicate (n-1) 0)
12:35:36 <Trinithis> > reverse (1:replicate (3-1) 0)
12:35:37 <lambdabot>  [0,0,1]
12:35:43 <nominolo> calvins_: ^[[ is really just \ESC
12:35:44 <EvilTerran> > iterate (0:) [1]
12:35:45 <lambdabot>  [[1],[0,1],[0,0,1],[0,0,0,1],[0,0,0,0,1],[0,0,0,0,0,1],[0,0,0,0,0,0,1],[0,0,...
12:35:55 <EvilTerran> :D
12:35:56 <Trinithis> EvilTerran : perfect!
12:35:57 <solrize> dcoutts_ i'm concerned that initializing the dictionary is a slow operation, basically equal to a gzip compress on the corpus which would typically be 32kb if i understand how zlib works
12:36:05 <ziman> yeah ;)
12:36:12 <calvins_> nominolo: thanks, that makes sense.
12:36:22 <solrize> but i haven't done any benchmarks yet
12:36:24 <rwbarton> Gnezdo: Well, manyTill has to build up a list of ()'s, but it doesn't know until it reaches the 'z' that it can return them rather than report failure
12:36:29 <dcoutts_> solrize: right, but I don't think there's any pre-compiled version of a dictionary
12:36:29 <solrize> i will see if i can do that tonight
12:36:31 <xerox> > unfoldr (\xs -> Just (xs [1], (0:) . xs)) (0:)
12:36:33 <lambdabot>  [[0,1],[0,0,1],[0,0,0,1],[0,0,0,0,1],[0,0,0,0,0,1],[0,0,0,0,0,0,1],[0,0,0,0,...
12:36:39 <nominolo> calvins_: i don't know the details, but the \033 is octal for 27
12:36:48 <xerox> ah, right, (0:) :)
12:36:55 <dcoutts_> solrize: one has to set deflateSetDictionary / inflateSetDictionary separately, so the thing gets recomputed anyway
12:36:58 <solrize> dcoutts_ you can initialize the dictionary with deflateSetDictionary then get a snapshot of it with some other function, copyDictionary or something like that
12:37:01 <EvilTerran> xerox, that'll build way more list cells than hte iterate one, i thkn
12:37:11 <EvilTerran> ... i can't type today, i has the dumb
12:37:12 <xerox> EvilTerran: agreed
12:37:13 <solrize> dcoutts hmm i better look at the docs again
12:37:19 <rwbarton> Gnezdo: so I would expect that to take O(2000000) space
12:37:24 <dcoutts_> solrize: oh, do you mean deflateCopy ?
12:37:54 <Gnezdo> rwbarton: and it is consuming that much.
12:37:57 <solrize> dcoutts_ yeah maybe that's it.  so to decompress a string you'd use deflateCopy to get the initialized dictionary
12:38:00 <nominolo> O(2000000) = O(1)
12:38:20 <solrize> i sort of wish zlib was written in haskell so it would use a functional data structure for the dictionary instead of having to copy it around
12:38:25 <solrize> :)
12:38:36 <dcoutts_> solrize: mm, right. That means binding more stuff. Currently there is no way to get at the stream state. I'll have to think about the api again.
12:38:37 <EvilTerran> solrize, well, if you want to re-implement it...
12:38:44 <Gnezdo> rwbarton: can you think of an alternative to manyTill when I need to apply a 'choice' of parsers until some delimeter?
12:38:51 <Gnezdo> delimiter
12:39:16 <rwbarton> Gnezdo: there was a recent thread on haskell-cafe about returning large data structures from parsec
12:39:18 <calvins_> nominolo: works great, thanks
12:39:39 <solrize> evilterran i wanted to discuss it with dcoutts first but yeah, i'm happy to help with this if i can
12:40:07 <Gnezdo> rwbarton: the one I sent you?
12:40:07 <Trinithis> @ty take
12:40:08 <lambdabot> forall a. Int -> [a] -> [a]
12:40:14 <Trinithis> @ty genericTake
12:40:15 <lambdabot> forall i a. (Integral i) => i -> [a] -> [a]
12:40:23 <dcoutts_> solrize: tibbe also wants some new features from the zlib binding, a more incremental interface that he can use in a web server.
12:40:26 <solrize> i'm probably better equipped to figure out the API and hack the C code than to deal with hairy haskell stuff
12:40:41 <EvilTerran> solrize, just you wait, we'll get a 100%-haskell full POSIX operating system eventually :D
12:40:59 <EvilTerran> and at least it won't be slower than HURD :P
12:41:15 <rwbarton> Gnezdo: here's the start of the thread: http://www.haskell.org/pipermail/haskell-cafe/2008-July/044941.html
12:41:15 <solrize> dcoutts_ hmm, i'm not sure what a web server would want?
12:41:15 <lambdabot> Title: [Haskell-cafe] parsec manyTill stack overflow, http://tinyurl.com/6rzv8x
12:41:29 <tac-tics> Wouldn't you want functional APIs instead of the POSIX apis?
12:41:35 <dcoutts_> solrize: well currently we only provide a stream style interface, using lazy bytestrings
12:41:45 <Gnezdo> rwbarton: thanks!
12:41:52 <dcoutts_> solrize: a web server might want a block level interface, and be able to do things like flush
12:42:20 <Peaker> how do people generally represent graphs in Haskell? Just integer identities?
12:42:41 <dcoutts_> Peaker: Data.Graph is a good place to start
12:42:52 <MyCatVerbs> Peaker: look into fgl (Data.Graph) if you want to do anything serious.
12:42:56 <solrize> dcoutts_ hmm yeah that makes sense, maybe streams aren't the right thing for socket i/o in general.  i didn't realize web servers needed to flush
12:43:03 <solrize> but it would be good to have the flush operations available too
12:43:34 <MyCatVerbs> Peaker: graph algorithms in pure FP are pretty difficult (without losing all the nice low complexities that imperative solutions can get you).
12:43:55 <solrize> i made a bunch of corrupt .tgz files because there was an unreadable block in one of the input files and then gzip lost its mind.  it would be good if programs like tar would let out a flush once in a while so that the decompressor could resync
12:44:45 <Peaker> MyCatVerbs: I just want to store a description of a functional program -- and I am considering using a graph (kind of equivalent to references by name in an .hs file) or a hierarchy (value tree) -- which seems to force a points-free representation
12:44:58 <dcoutts_> solrize: flush also reduces compression ratios of course
12:45:06 <solrize> true
12:45:13 <dcoutts_> which is why tar doesn't use it
12:45:22 <solrize> but i think the effect is not very significant when the output is large
12:45:28 <solrize> i.e. flush every few megabytes
12:45:34 <vixey> But you can  have mutation and mutable variables in haskell!
12:45:41 <solrize> as i understand it zlib only uses 32kb of context
12:45:51 <dcoutts_> solrize: it's variable I think
12:46:10 <solrize> ic, 512 byte minimum 32k maximum
12:46:17 <MyCatVerbs> solrize: I'd say it's more important for things like gzip to (ideally provably) not have data corruption bugs than for them to try to be resistant to bugs.
12:46:18 <Peaker> MyCatVerbs: I think a Data.Map of some identity type (e.g Int) to a value, could work as a graph representation with reasonable complexities? Is that what Data.Graph does?
12:46:27 <MyCatVerbs> Peaker: yes and no.
12:46:37 <dcoutts_> solrize: that sounds right, window bits from 8-15
12:47:01 <MyCatVerbs> Peaker: respectively, I mean. Data.Graph does some fairly complicated things, using Data.Map for representations in a lot of places.
12:47:02 <solrize> i haven't tried to read the zlib code other than to notice there is a lot of it
12:47:17 <Peaker> MyCatVerbs: when does its complexity sucks?
12:47:42 <Peaker> MyCatVerbs: if its O(1) -> O(log N), I think that's acceptable
12:48:07 <solrize> brb
12:48:23 <MyCatVerbs> Peaker: there are a lot of places where you go O(f(N)) to O(f(N)*log(f(N)))
12:49:23 <Peaker> MyCatVerbs: I see. What about the constants?
12:49:39 <rwbarton> Gnezdo: Actually, I was thinking of another thread, but both might be relevant: http://www.haskell.org/pipermail/haskell-cafe/2008-July/045371.html
12:49:40 <lambdabot> Title: [Haskell-cafe] ansi2html - one program, several issues, http://tinyurl.com/5f65m5
12:49:51 <MyCatVerbs> Peaker: there are some places where a naive approach *really* sucks, and you end up going from O(1) to O(N) or worse. Think of methods of deleting a node from a graph.
12:50:11 <Gnezdo> rwbarton: reading through both now, much appreciate your help!
12:50:16 <MyCatVerbs> Peaker: hence why Data.Graph is so cool. :)
12:50:28 <rwbarton> (just to prove that my sense of time isn't that far off :)
12:50:38 <MyCatVerbs> Peaker: I don't know about what the constants are around Data.Graph's implementation, sorry.
12:50:59 <solrize> mycatverbs my corrupt tgz files were not caused by software bugs, they were caused by bad blocks on the hard drive
12:51:25 <Peaker> MyCatVerbs: but a naive Data.Map will have O(logN) deletion, not O(N) deletion?
12:51:49 <Peaker> MyCatVerbs: except having to delete the edges, I guess?
12:52:08 <Peaker> MyCatVerbs: you can leave them there and find the dead ones later to amortize it :)
12:53:14 <solrize> dcoutts_ anyway thanks, i just wanted to know if the change i described sounded basically reasonable.  i will try messing around with the zlib C code when i get a chance
12:53:31 <pozic> Peaker: is this for a real application?
12:53:52 <ayianus> In category theory one speaks of morphisms, or sometimes arrows - In Haskell arrows carry some denotation, too. I suspect the concepts aren't entirely the same, are they? What are Haskell's arrows in comparison to morphisms like?
12:54:03 <MyCatVerbs> solrize: ahhh, right yes.
12:54:14 <pozic> Peaker: N only matters when N>1000, so I heard when using Data.Graph.FGL.
12:54:18 <dcoutts_> solrize: sure, perfectly reasonable. The api will take some thought though.
12:54:21 <Peaker> pozic: I want (for educational purposes) to represent a simple functional language as a graph data structure (where the names are used to form links), and then perhaps write a naive compiler/gc even, if I can
12:54:32 <dcoutts_> solrize: the C bits are relatively easy
12:54:39 <MyCatVerbs> Peaker: yes, but with mutable objects you can get much closer to O(1).
12:54:53 <pozic> Peaker: then what are you asking about complexity?
12:55:02 <solrize> dcoutts_ i defer to you about the api
12:55:03 <Peaker> pozic: also for eductional purposes :)
12:55:09 <pozic> Peaker: your biggest program won't be that large probably.
12:55:21 <MyCatVerbs> Peaker: Data.Graph does precisely what you just said - leaves them there, but ignored.
12:55:28 <dcoutts_> solrize: yeah, that might take some time :-)
12:56:01 <seliopou> does anybody recall seeing an article about fast number parsing in haskell?
12:57:02 <earthy> http://www.haskell.org/pipermail/haskell-cafe/2007-June/026654.html ?
12:57:03 <lambdabot> Title: [Haskell-cafe] Fast number parsing with strict bytestrings [Was: Re: Seemingly s ..., http://tinyurl.com/33g4r9
12:58:25 <solrize> dcoutts_ :)
12:58:37 <dons> seliopou: just use the readInt, readInteger and readDouble functions on bytestrings
12:59:30 <seliopou> nnngh, byebye parsec
13:00:56 <Peaker> hey is Hayoo new?
13:00:57 <sebaseba> does parsec 3 with bytestring use those?
13:01:56 <MyCatVerbs> Peaker: yes.
13:02:16 <MyCatVerbs> Peaker: well. Newer than the universe, older than most of the photons hitting you at the moment.
13:02:52 <Peaker> yumm.... photons
13:03:09 <pozic> @photontorpedo
13:03:09 <lambdabot> what is a good way to handle the ftp transfer and reading of files to mysql?
13:03:27 <Peaker> Data.Graph is a large package, not a simple module, it seems.  Is there a tutorial?
13:03:48 <dmhouse> ?help photontorpedo
13:03:48 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:03:55 <MyCatVerbs> Peaker: yyy... there's an outdated tutorial, and a paper. >>
13:04:23 <pozic> MyCatVerbs: there is no paper for Data.Graph.
13:04:33 <pozic> MyCatVerbs: There is for Data.Graph.FGL.
13:04:39 <Peaker> Curiosity speaking: is there an imperative/monadic graph library for the cases where one wants the imperative complexities?
13:04:39 <MyCatVerbs> Peaker: web.engr.oregonstate.edu/~erwig/fgl/haskell/
13:05:36 <MyCatVerbs> Peaker: don't know. Most algorithms shouldn't be too painful to implement in the ST monad though, usually.
13:06:48 <EvilTerran> data Node a = Node (STRef (a, [Node a])) -- something like this?
13:07:11 <MyCatVerbs> pozic: oh right, of course. But Data.Graph isn't nearly so powerful as FGL, so it's the latter that most people will usually have more interest in.
13:07:30 <MyCatVerbs> EvilTerran: yeah, or even a newtype (wheee, premature optimization!)
13:07:44 <EvilTerran> indeed, i saw that
13:07:52 <EvilTerran> but figured it'd distract from my intended point :P
13:08:01 <Cale> I usually prefer  Map Vertex (Set Vertex)  these days as a graph representation.
13:08:32 <Peaker> Cale: what do you use for "Vertex"?
13:08:35 <sebaseba> @users
13:08:36 <lambdabot> Maximum users seen in #haskell: 500, currently: 499 (99.8%), active: 22 (4.4%)
13:08:46 <Cale> Peaker: Whatever's appropriate in context.
13:08:54 <MyCatVerbs> Cale: it's certainly a Hell of a lot more principled. Pity about the extra log(S) factor (where S is the number of steps the algorithm would usually take).
13:09:16 <Cale> MyCatVerbs: Except I've come to the conclusion that it's not really extra :)
13:09:19 <Peaker> Cale: If my only purpose is to be able to create links in the graph, and I don't care about the actual type, what's appropriate?
13:09:40 <EvilTerran> Peaker, Integer?
13:09:43 <vixey> woo!
13:09:47 <vixey> @users
13:09:47 <lambdabot> Maximum users seen in #haskell: 501, currently: 501 (100.0%), active: 21 (4.2%)
13:09:49 <Cale> MyCatVerbs: It's just that we're being disingenuous about the cost of array access.
13:09:56 <dons> woo!
13:09:58 <EvilTerran> vixey, woo!
13:10:03 <Peaker> EvilTerran: ah, was just wondering if there was a better idea..
13:10:08 <dons> i don't know what is happening, but that's awesome.
13:10:32 <EvilTerran> @users
13:10:32 <lambdabot> Maximum users seen in #haskell: 502, currently: 502 (100.0%), active: 20 (4.0%)
13:10:33 <MyCatVerbs> Cale: no more so than we're being disingenuous about the cost of tree accesses.
13:10:38 <Cale> MyCatVerbs: (since if an array is very large, indexing into it takes at least log(n)/log(2) steps anyway)
13:10:58 <jpcooper> @hoogle (a -> a) -> Int -> a
13:10:58 <lambdabot> No matches, try a more general search
13:11:03 <Cale> (you can't read the entire array index in any less than that)
13:11:06 <jpcooper> how do I get a function to call itself n times?
13:11:17 <Cale> jpcooper: iterate f x !! n
13:11:23 <jpcooper> @hoogle Int -> Int -> (a -> a) -> a
13:11:24 <lambdabot> No matches, try a more general search
13:11:29 <jpcooper> @type iterate
13:11:30 <lambdabot> forall a. (a -> a) -> a -> [a]
13:11:37 <jpcooper> thanks Cale
13:11:39 <MyCatVerbs> Cale: after all, following one of the pointers in a tree requires O(address bus width) work anyway.
13:11:40 <dmhouse> jpcooper: pass a parameter which you decrement on each call, and add a case for 0, would be the most simplistic solution.
13:11:41 <vixey> > iterate f x
13:11:43 <lambdabot>  [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (f...
13:12:57 <Cale> jpcooper: actually, you should be a little careful about that if n is very large
13:13:01 <dons> we reached 400 users for the first time 1 year aog
13:13:03 <jpcooper> no, it won't be
13:13:23 <jpcooper> @source iterate
13:13:23 <lambdabot> iterate not available
13:13:26 <Cale> 2 more users and we'll be at 500 :)
13:13:31 <dons> ?users
13:13:32 <lambdabot> Maximum users seen in #haskell: 502, currently: 501 (99.8%), active: 22 (4.4%)
13:13:32 <MyCatVerbs> Cale: Hell. We're being dishonest by neglecting to mention the fact that you can only fit O(n^3) cells of memory within n time-at-lightspeed units of distance.
13:13:37 <dons> so we've 4 bots?
13:13:38 <EvilTerran> @src iterate
13:13:38 <lambdabot> iterate f x =  x : iterate f (f x)
13:13:39 <vixey> iterate f x = x : iterate f (f x)
13:13:40 <Cale> ah
13:13:41 <dons> close enough.
13:13:52 <medfly> hi folks!
13:13:58 <Cale> MyCatVerbs: sure
13:14:01 <canadaduane> hello
13:14:06 <vixey> medfly, record breaker
13:14:08 <vixey> @users
13:14:08 <lambdabot> Maximum users seen in #haskell: 502, currently: 502 (100.0%), active: 24 (4.8%)
13:14:12 <medfly> Cale, is this some disturbing attempt at getting #haskell huge?
13:14:14 <MyCatVerbs> Cale: doesn't seem to stop anyone except the distributed folks from neglecting to take that into account, though.
13:14:28 <mauke> HUEG
13:14:30 <vixey> medfly: who told you to come here?
13:14:36 <Cale> hehe, me
13:14:39 <medfly> :)
13:14:41 <dons> i wonder why we've seen 40 new people arrive todya
13:14:45 <dmhouse> No cheating!
13:14:53 <dmhouse> medfly: quick, as a Haskell question!
13:14:55 <medfly> aww, but i do haskell
13:14:55 <Cale> (but it's appropriate, since I'm teaching medfly Haskell anyway)
13:15:02 <medfly> yes :)
13:15:41 <jpcooper> dons, maybe some post on reddit?
13:16:08 <medfly> ##c being about as big as #haskell gives a wrong impression :)
13:16:22 <dmhouse> Yeah, that C's as good as Haskell is.
13:16:53 <lament> why is #haskell so big?
13:17:04 <medfly> taking that user count thing to other things, like windows/linux/etc, would suggest windows is significantly better than linux.
13:17:08 <lament> just a more centralized community?
13:17:40 * Cale notes that ##windows has ~300 users and ##linux has ~800
13:17:48 <Shiruka> languages like C don't gather similar communities
13:17:51 <ziman> because of the friendly community and clever & fun guys ;)
13:17:58 <Shiruka> where's cabal for C? ;-)
13:18:04 <dmhouse> There's a ##windows?
13:18:07 <medfly> and the /msg friend can you join #haskell for a moment?
13:18:09 <medfly> yes, there is
13:18:13 <r3m0t> Cale: ##windows on Freenode? ha ha, the room of shame
13:18:15 <Peaker> I learn lots of new things in #haskell, but rarely did I learn anything new in ##c
13:18:39 <laz0r> how can i 'reify' a function Name with template haskell? TyConI (FunD name clauses) <- reify f gives me a pattern match error
13:18:40 <vixey> I learned a great deal from ##C
13:19:00 <glguy_> the capitalized version?
13:19:01 <glguy_> ;)
13:19:02 <medfly> vixey, i learned that channels can have misleading names
13:19:09 <laz0r> i am trying to find out how mayn arguments a function that i give to my template has
13:19:25 <conal> Peaker on imperative functional graph programming: see http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-Graph.html
13:19:27 <lambdabot> Title: Data.Graph, http://tinyurl.com/2j6x3y
13:19:55 <laz0r> and i thought i could just look at the number of [Pat] things in any os the Clauses
13:19:59 <conal> Peaker: and http://citeseer.ist.psu.edu/king94lazy.html
13:20:00 <lambdabot> Title: Lazy Depth-First Search and Linear Graph Algorithms in Haskell - King, Launchbur ...
13:21:06 <Peaker> conal: thanks!
13:21:12 <dmhouse> Sorry, Emacs hung. Didn't mean to damage the user count.
13:21:50 <Cale> MyCatVerbs: However, it seems that if you're going to ignore the log factor for array access because memory is finite, it's only fair that you do it with trees as well.
13:24:41 <vixey> @users
13:24:41 <lambdabot> Maximum users seen in #haskell: 502, currently: 501 (99.8%), active: 30 (6.0%)
13:24:49 <vixey> > 100%
13:24:49 <lambdabot>   parse error on input `}'
13:25:01 <glguy_> lambdabot is confused, only 498 right now
13:25:02 <jpcooper> where in the docs is Maybe's Monad istance declaration?
13:25:05 <dons> http://www.reddit.com/comments/6u0pj/haskell_reaches_500_users/ :)
13:25:06 <lambdabot> Title: #haskell reaches 500 users! : reddit.com
13:25:19 <glguy_> and since lambdabot is off by three
13:25:22 <jpcooper> dons, LIES
13:25:22 <glguy_> that means we haven't it 500
13:25:34 * jpcooper votes up anyway
13:25:40 <dmhouse> But it's on teh internets! It must be true!
13:25:44 <dons> ?users
13:25:45 <lambdabot> Maximum users seen in #haskell: 502, currently: 500 (99.6%), active: 30 (6.0%)
13:25:49 <dons> close enough
13:25:51 <dmhouse> Quick, someone add it to Wikipedia!
13:25:56 <moonlite> can i get gtk2hs through cabal install?
13:26:09 <glguy_> round to the nearest 1000?
13:26:17 <moonlite> (which is the nuts btw.)
13:26:28 <moonlite> cabal list gtk reveals soegt and yi-gtk
13:26:36 <jpcooper> anyone?
13:27:22 <bitrot> dons: what's scary is #php has as many users as it does...
13:27:25 <MyCatVerbs> Cale: yes, but trees have that log factor for indexing on top of their n*log(n) behavoir.
13:27:51 <glguy_> dons: it powers the *Internet*
13:27:56 <dons> so i want to know why there's been a 50 person spike in the last 2 days
13:28:08 <dons> glguy_:  you're addressing me?
13:28:18 <glguy_> oops
13:28:21 <glguy_> :)
13:28:21 <vixey> what's so good about php
13:28:26 <vixey> ?
13:28:29 <dmhouse> > 2^40 > 10^9
13:28:31 <lambdabot>  True
13:28:33 <dmhouse> vixey: hah, absolutely nothing.
13:28:44 <mauke> glguy_: do you run the hackage bot?
13:28:46 <MyCatVerbs> Cale: indexing to an element within a tree takes n*log(n) memory accesses. If you assume that memory access is, say, O(n^(1/3)), then trees get hit just as badly as arrays do.
13:28:47 <r3m0t> vixey: it is consistently bad
13:28:48 <glguy_> mauke: no
13:28:49 <jpcooper> vixey, could you tell me where I can see Maybe's Monad instance declaration?
13:28:51 <matt_estes> vixey: deployment.
13:29:00 <dons> why does everyone think glguy runs the hackage bot?
13:29:01 <dmhouse> ?users
13:29:02 <lambdabot> Maximum users seen in #haskell: 502, currently: 502 (100.0%), active: 32 (6.4%)
13:29:20 <mauke> dons: I could tell you but it wouldn't help
13:29:26 <dons> ?users
13:29:27 <lambdabot> Maximum users seen in #haskell: 503, currently: 503 (100.0%), active: 31 (6.2%)
13:29:27 <mauke> I don't trust my brain
13:29:31 <dons> woot woot
13:29:35 <glguy_> dons: you should ask for: unaffiliated/dons/bot/hackage
13:29:36 <vixey> dons, well who does run it?
13:29:45 <vixey> oh don't answer that
13:29:48 <vixey> nobody runs it :p
13:29:50 <dolio> Indexing in a tree takes log n accessess, not n*log n
13:30:12 <dolio> (If it's balanced, that is.)
13:30:17 <dons> ?users
13:30:18 <lambdabot> Maximum users seen in #haskell: 504, currently: 504 (100.0%), active: 31 (6.2%)
13:30:20 <dons> happy now glguy_ ?
13:30:28 <MyCatVerbs> dons: oh sorry, brainfart.
13:30:31 <dons> WELCOME EVERYONE! :D
13:30:34 <MyCatVerbs> Er, dolio, not dons.
13:30:40 <glguy_> dons: yup, honesty is the best policy!
13:30:50 <MyCatVerbs> dolio: yeah, my bad. I must've been thinking "insert n nodes" or something stupid like that.
13:31:03 <dolio> Yeah. That'd be n*log n.
13:31:13 <vixey> instance Monad Maybe where
13:31:16 <vixey>   return = Just
13:31:21 <vixey>   Nothing >>= _ = Nothing
13:31:25 <vixey>   Just x >>= f = f x
13:31:35 <MyCatVerbs> C-C-C-damn, too slow.
13:31:45 <vixey> jpcooper,
13:31:56 <jpcooper> thanks
13:32:03 <ptolomy2> Ooh. Was I the 504th caller?
13:32:20 <mauke> 501st, actually
13:32:32 <ptolomy2> Awww.
13:32:36 <mauke> hmm, or maybe it's me
13:32:43 <mauke> my irssi is half desync'd
13:32:51 <jpcooper> is there an iterate that uses >>= ?
13:32:54 <r3m0t> says 501 users on my screen
13:33:12 <ziman> 501 here, too
13:33:21 <dmhouse> ?hoogle iterateM
13:33:21 <lambdabot> No matches found
13:33:30 <vixey> jpcooper: What type would it have?
13:33:40 <vixey> :t iterate
13:33:41 <lambdabot> forall a. (a -> a) -> a -> [a]
13:33:45 <medfly> maybe lambdabot has some issues.
13:33:57 <dons> ?users
13:33:57 <lambdabot> Maximum users seen in #haskell: 505, currently: 504 (99.8%), active: 31 (6.2%)
13:34:11 <dons> QUICK, everyone write a library and upload it to hackage!
13:34:14 <jpcooper> what I want to do is chain a bunch of calls of a function to itself and return nothing on the first nothing
13:34:20 <vixey> what type though?
13:34:22 <MyCatVerbs> dons: that would be a Hell of a trick.
13:34:32 <alech> Hi ... I have a String which contains some random bytes (output from openssl rand), how can I convert that into an Integer or some kind of Bits type? Coming from Perl, I'd do somethink along the lines of unpack('H*', ...) there, can I do something similar in Haskell?
13:34:33 <jpcooper> I don't know
13:34:37 <r3m0t> ?hoogle (Monad m) => m a -> (a -> m a) -> [m a]
13:34:38 <lambdabot> Prelude.iterate :: (a -> a) -> a -> [a]
13:34:38 <lambdabot> Data.List.iterate :: (a -> a) -> a -> [a]
13:34:42 <vixey> that's the first thing to thin k about
13:35:01 <dons> alech: read, or use bit shifts to fill an integer?
13:35:16 <dons> alech: also, you could use Data.Binary
13:35:19 <mauke> :t foldl' (\z x -> z * 256 + ord x) 0
13:35:20 <lambdabot> [Char] -> Int
13:35:23 <alech> not exactly read
13:35:29 <dons> roll :: [Word8] -> Integer
13:35:29 <dons> roll   = foldr unstep 0
13:35:29 <dons>   where
13:35:29 <dons>     unstep b a = a `shiftL` 8 .|. fromIntegral b
13:35:36 <mauke> > foldl' (\z x -> z * 256 + ord x) 0 "hufflepuff"
13:35:37 <lambdabot>  1886742118
13:35:45 <alech> dons: those are the raw bytes in the string
13:36:13 <dons> right, he just wants to fill an Integer using the string's bytes?
13:36:24 <dons> so map ord, get a [Word], then fold it up into an Integer
13:36:31 <ziman> > foldl' (\z x -> z * 256 + ord x) 0 "anticonstitutionellement"
13:36:32 <lambdabot>  1835363956
13:36:47 <ziman> > foldl' (\z x -> z * 256 + ord x) 0 "anticonstitutionellement" :: Integer
13:36:48 <alech> dons: that was too fast for me, sorry, I'm pretty new to Haskell
13:36:48 <lambdabot>  Couldn't match expected type `Integer' against inferred type `Int'
13:37:00 <mauke> > foldl' (\z x -> z * 256 + fromIntegral (ord x)) 0 "hufflepuff"
13:37:01 <lambdabot>  493291761979289547138662
13:37:01 <dons> > map ord "haskell"
13:37:02 <lambdabot>  [104,97,115,107,101,108,108]
13:37:06 <alech> ok
13:37:20 <dons> > foldr (\b a -> a `shiftL` 8 .|. fromIntegral b) 0 (map ord "haskell")
13:37:21 <lambdabot>  Add a type signature
13:37:24 <dons> > foldr (\b a -> a `shiftL` 8 .|. fromIntegral b) 0 (map ord "haskell") :: Integer
13:37:25 <lambdabot>  30518480334971240
13:37:42 <mauke> > foldl' (\z x -> z * 256 + fromIntegral (ord x)) 0 "haskell"
13:37:43 <lambdabot>  29380545928850540
13:37:57 <dons> or manually fuse the map ord and the loop
13:38:08 <mauke> oh, you're using foldr
13:38:13 <alech> which of the posted two is the correct one?
13:38:20 <mauke> both
13:38:27 <alech> but they have different output?
13:38:37 <mauke> > foldl' (\z x -> z * 256 + fromIntegral (ord x)) 0 (reverse "haskell")
13:38:38 <lambdabot>  30518480334971240
13:38:40 <dons> one pulls bytes from the left, one from the right.
13:38:53 <alech> ah, ok.
13:39:08 <alech> luckily that's irrelevant for the random bytes :)
13:39:10 <alech> thanks
13:39:12 <dons> :)
13:39:34 <seliopou> bytestrings are fast
13:41:48 <Jose_Balado> > 1 + 1
13:41:49 <lambdabot>  2
13:41:54 <vixey> > 2 + 2
13:41:55 <lambdabot>  4
13:41:59 <jeffwheeler> > 4 + 4
13:42:00 <lambdabot>  8
13:42:01 <pozic> ghc-pkg list shows zlib-0.4.0.1, zlib-0.4.0.4. How do I delete the former?
13:42:01 <r3m0t> @users
13:42:01 <lambdabot> Maximum users seen in #haskell: 507, currently: 507 (100.0%), active: 34 (6.7%)
13:42:28 <pozic> unregister says there is no such package.
13:42:58 <dmhouse> > iterate (*2) 1
13:42:59 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
13:43:03 * dmhouse wins
13:43:10 <jeffwheeler> :(
13:43:32 <medfly> lambdabot can see dead people...
13:44:08 <mauke> pozic: may need --user
13:44:13 <pozic> ghc-pkg unregister zlib-0.4.0.1 should be equal to ghc-pkg unregister zlib-0.4.0.1 --user
13:44:21 <pozic> mauke: yes, I already figured it out.
13:44:29 <pozic> mauke: thanks, anyway.
13:44:40 <bjrn> dmhouse: Heh. I'm (re)learning Haskell at the moment and I have worked on a problem for a while. Now I know how to solve it (with iterate). Cheers. :)
13:45:28 <dmhouse> Yay for random powers-of-two fights :)
13:45:47 <mauke> > iterate (join (+)) 1
13:45:48 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
13:45:52 <mauke> needs more monads
13:46:25 <pozic> parallel-1.0.0.1 failed while unpacking the package. The exception was:
13:46:26 <pozic> user error (Codec.Compression.Zlib: incompatible version)
13:46:26 <ziman> > readHex "dead people"
13:46:28 <lambdabot>  [(57005," people")]
13:46:28 <pozic> What about that?
13:47:41 <Cale> > map length . groupBy (<) $ fix show
13:47:44 <lambdabot>  [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262...
13:48:06 <mauke> haha
13:48:09 <jeffwheeler> Cale: I don't thing that counts; you left off "1" ;)
13:48:33 <dmhouse> > head (fix show)
13:48:34 <lambdabot>  '"'
13:48:40 <pozic> Cale: written like a true mathematician.
13:48:50 <r3m0t> > take 5 . groupBy (<) $ fix show
13:48:51 <lambdabot>  ["\"\\","\"\\\\\\","\"\\\\\\\\\\\\\\","\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\","\"...
13:49:05 <dmhouse> Oh, right, because show (x :: String) produces a " character unconditionally.
13:49:25 <r3m0t> this place is crazy
13:49:30 <mauke> > map length . groupBy (>) $ fix show
13:49:30 <Cale> > (1:) . map length . groupBy (<) $ fix show
13:49:32 <lambdabot>  [1,2,1,1,2,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1...
13:49:35 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
13:50:01 <mauke> > map length . groupBy (>=) $ fix show
13:50:04 <lambdabot>  [1,
13:50:05 <dmhouse> > '\' < '"'
13:50:05 <lambdabot>  Improperly terminated character constant at "'\'" (column 1)
13:50:05 <Peaker> Cale: when working with:  Map Vertex (Set Vertex) -- do yo generate new vertex values in a monad? If not, do you keep track of the plumbing manually, if you use a "make new vertex" function?
13:50:10 <dmhouse> > '\\' < '"'
13:50:11 <lambdabot>  False
13:50:42 <lowki> what is that whats it ... function on one line things ( x /- head $ words x)
13:50:45 <Cale> Peaker: to insert a new vertex with no edges connected to anything, just insert an empty set into the map
13:51:01 <Peaker> Cale: but I need a new vertex value as a key
13:51:16 <mauke> lowki: \param -> body
13:51:18 <lowki> or is it -/ or -> ? the lambda indicator
13:51:18 <jeffwheeler> lowki: lambda functions? function application?
13:51:30 <lowki> o okay yea
13:51:31 <jeffwheeler> lowki: ->
13:51:33 <vixey> lowki: \
13:51:37 <Peaker> Cale: if Vertex is Integer, for example, I need to keep track of the highest vertex key generated so far, and keep track of it as I geenrate new keys
13:51:45 <vixey> lowki: \x -> x   is   lambda x. x
13:51:53 <Cale> Peaker: a Map can give you that in log(n) time anyway.
13:52:07 <lowki> o
13:52:10 <Cale> Peaker: but it's unlikely that you don't have a name for your vertex
13:52:10 <Peaker> Cale: ah, didn't think of that
13:52:21 <Cale> Peaker: Usually graphs are meaningful.
13:52:28 <lowki> alright i think it worked thanks :)
13:52:33 <Cale> Like, the vertices mean something to you :)
13:53:06 <lowki> mauke: had the most useful advice
13:53:27 <mauke> also, head . words
13:53:33 <Peaker> Cale: My graph is a functional program -- Normally string-names are used, but I don't want to use string names to create the links
13:54:00 <Cale> Peaker: what's wrong with Map String (Set String)?
13:54:30 <Cale> Comparison time?
13:54:44 <Peaker> Cale: well, I want the names to be comments, not unique identifiers - and I want each entity in the program (a value, or function) to potentially have multiple names or rich metadata in general (e.g: Its name in various human languages)
13:55:27 <Cale> Why not use the entity itself as a vertex?
13:55:40 <Cale> Too large?
13:56:21 <Cale> > fix ((1:) . map (*2))
13:56:22 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
13:56:26 <dons> dcoutts_: did you know the ruby guys supposedly went line by line through the python std lib ensuring the ruby lib had the same   features
13:56:55 <dolio> > fix $ scanl (*2) 1
13:56:56 <lambdabot>      Occurs check: cannot construct the infinite type: a = b -> a
13:56:56 <lambdabot>     Probabl...
13:57:41 <dolio> > fix $ scanl (+) 1
13:57:42 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
13:57:48 <dolio> There we are.
13:57:55 <Heffalump> that's pretty cool
13:58:32 <vixey> @check  ((1:) . map (*2)) === scanl (*2) 1
13:58:33 <lambdabot>   Not in scope: `==='
13:58:59 <vixey> @check  let (===) = liftM2 (==) in ((1:) . map (*2)) === scanl (*2) 1
13:58:59 <lambdabot>      Occurs check: cannot construct the infinite type: a = b -> a     Probabl...
13:59:37 <Cale> I wonder how many famous sequences are constructible in the form  fix (f . scanl g x)
14:00:09 <dolio> All of them. f = const (famous sequence) :)
14:00:14 <Heffalump> all stateless ones, surely?
14:00:17 <Heffalump> with f = id
14:00:29 <Heffalump> and in fact all stateful ones too, with f = project-out-result
14:01:34 <dino-> I'm working on some time manipulations, I see that System.Time is in a lib called old-time. Does that old- imply that I should avoid this?
14:01:37 <Cale> > fix (f . scanl g x)
14:01:38 <lambdabot>        add an instance declaration for (SimpleReflect.FromExpr [b])
14:01:43 <Cale> > fix (f . scanl g x) :: [Expr]
14:01:44 <lambdabot>        add an instance declaration for (SimpleReflect.FromExpr [Expr])
14:02:09 <vixey> :t fix (?f . scanl ?g ?x)
14:02:10 <lambdabot> forall a b. (?x::a, ?g::a -> b -> a, ?f::[a] -> [b]) => [b]
14:02:12 <paczesiowa> it'd be funny if it only worked with dates from 1900s
14:02:46 <vixey> > fix ((f :: [Expr] -> [Expr]) . scanl (g :: Expr -> Expr -> Expr) x) :: [Expr]
14:02:47 <lambdabot>        add an instance declaration for (SimpleReflect.FromExpr [Expr])
14:03:06 <Cale> Seems there are some limitations to the Expr mechanism...
14:03:09 <mauke> > f x y
14:03:10 <lambdabot>  Add a type signature
14:03:14 <bjrn> What's "fix"? Difficult to google.
14:03:15 <Heffalump> it needs to embed lists
14:03:18 <mauke> > f x y :: Expr
14:03:19 <lambdabot>  f x y
14:03:22 <dmhouse> bjrn: fix f = f (fix f)
14:03:27 <Heffalump> which presumably it doesn't yet otherwise there'd be an instance declaration
14:03:28 <mauke> @src fix
14:03:29 <lambdabot> fix f = let x = f x in x
14:03:31 <bjrn> Ah cheers.
14:03:35 <dmhouse> bjrn: i.e. fix f = f (f (f (f (...
14:04:24 * vixey > fix ((f :: [Expr] -> Expr) . scanl (g :: Expr -> Expr -> Expr) x) :: [Expr]
14:04:27 <vixey> oops
14:05:00 <dolio> @type f
14:05:00 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
14:05:04 <Trinithis> > getStdRandom (randomR (0, maxBound :: Int)
14:05:05 <lambdabot> Unbalanced parentheses
14:05:09 <Trinithis> > getStdRandom (randomR (0, maxBound :: Int))
14:05:09 <dmhouse> bjrn: useful for encoding recursion mostly.
14:05:10 <lambdabot>  <IO Int>
14:05:36 <Cale> > fix (1:)
14:05:37 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
14:05:53 <Cale> > fix (\f n -> if n == 0 then 1 else n * f (n-1)) 10
14:05:54 <lambdabot>  3628800
14:06:03 <Cale> > map (fix (\f n -> if n == 0 then 1 else n * f (n-1))) [0..10]
14:06:04 <lambdabot>  [1,1,2,6,24,120,720,5040,40320,362880,3628800]
14:06:05 <Trinithis> > fix ([x]++)
14:06:06 <lambdabot>  [x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x...
14:06:12 <Trinithis> > fix ([x])
14:06:12 <lambdabot>  Couldn't match expected type `a -> a' against inferred type `[a1]'
14:06:15 <Trinithis> > fix (++[x])
14:06:18 <vixey> lazyness is too cool :)
14:06:30 <lambdabot>  thread killed
14:06:39 <Cale> > map (fix (\f n -> if n < 2 then n else f (n-1) + f (n-2))) [0..10]
14:06:41 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55]
14:06:45 <dmhouse> It also finds fixed points of a function in that if y = fix f, then f y = f (fix f) = fix f (using the equation for fix backwards) = y.
14:07:02 <Cale> It finds the least-defined fixed point of a function.
14:07:37 <Trinithis> fix is the y combinator right?
14:07:42 <mauke> yes
14:07:42 <dmhouse> Well, not always. cos has a fixed point, but fix cos diverges.
14:07:53 <mauke> dmhouse: cos undefined == undefined
14:07:57 <Cale> Trinithis: roughly, yeah, in that they're both fixed point combinators
14:08:01 <mauke> undefined is least defined
14:08:04 <dmhouse> Oh, err, yeah. :)
14:08:10 * dmhouse realised that as soon as he wrote that
14:08:14 <Trinithis> is fix more general than y?
14:08:16 <andyjgill> > map fst [ let x = System.Random.mkStdGen n in  System.Random.randomR (0,3) x  | n <- [0..100]]
14:08:18 <lambdabot>  [1,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1...
14:08:18 <Peaker> Cale: I'm sorry, I missed your question -- for some reason that solution escaped me :)
14:08:26 <mauke> that is, every strict function has a fixed point in ⊥
14:08:28 <andyjgill> Not very random...
14:08:29 <Peaker> Cale: that sounds like it might be the simplest one
14:08:34 <dmhouse> mauke: by definition.
14:09:02 <Trinithis> @src fix
14:09:02 <lambdabot> fix f = let x = f x in x
14:09:46 <Cale> andyjgill: You're expected to use the state given to you after the first one :)
14:10:03 <dmhouse> It would be fix f = f (fix f), but I believe that makes stupid CSE optimisers diverge.
14:10:22 <dmhouse> > let fix' f = f (fix' f) in fix' (1:)
14:10:23 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
14:10:30 <Peaker> would: fix f = f (fix f) also work, except be less efficient?
14:10:44 <mauke> Peaker: yes
14:10:51 <dmhouse> Peaker: ^^ what I just wrote
14:11:06 <Peaker> dmhouse: ah.
14:11:47 <Trinithis> are there any cool tutorials on how to use fix and get comfortable with it?
14:12:03 <Cale> > unfoldr (Just . randomR (0,3)) (mkStdGen 0)
14:12:04 <lambdabot>  [1,3,1,0,2,1,3,3,3,0,3,0,2,2,0,3,0,1,3,2,0,2,0,3,0,3,0,1,3,2,1,2,3,2,2,2,0,0...
14:12:18 <Peaker> I find the keep-value VS recompute-value hinting via  let VS func-call   kind of ugly. I think it should be more explicit, preferrably in a way that is easily separatable from the program (like ! seems to be), so one can focus on the denotational semantics with ease
14:12:20 <dmhouse> Trinithis: in general, you don't need to use it.
14:12:26 <Trinithis> :D
14:12:59 <Cale> Trinithis: main thing which will help you get comfortable is that fix (\f x -> ...)  produces a function which is the same as if you'd written  f x = ...
14:13:18 <Cale> (where ... is the same in each case, and may refer to f)
14:13:20 <andyjgill> Thank Cale
14:13:23 <Trinithis> I'm comfortable with y-combinator and that seems like it
14:13:30 <Cale> andyjgill: or randomRs :)
14:13:45 <Cale> Trinithis: fix and the y combinator do the same thing
14:13:46 <andyjgill> I though the starter seed would do better than this, though.
14:13:52 <dmhouse> > let fact rec 0 = 1; fact rec n = n * rec (n-1) in fix fact 5
14:13:53 <lambdabot>  120
14:14:25 <Trinithis> Cale: But what about fix (1:) ?
14:14:26 <dmhouse> Because fix fact 5 = fact (fix fact) 5 = 5 * fix fact 4 = ...
14:14:39 <Cale> Trinithis: well, fix (1:) = 1 : fix (1:)
14:15:01 <Cale> Trinithis: so you can imagine right from there what list you'll get :)
14:15:09 <Trinithis> I suppose if I made it pointful, I could grasp it better in tha tcase
14:15:18 <Cale> fix (\x -> 1:x)
14:15:25 <Cale> x = 1 : x
14:15:41 <Trinithis> k
14:15:59 <Cale> > fix ((1:) . map (+1))
14:16:00 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
14:16:15 <dmhouse> Also notice that 1 : [1,1,1,...] = [1,1,1,...], i.e. repeat 1 is a fixed point of (1:).
14:16:19 <Cale> > fix ((x:) . map f)
14:16:20 <lambdabot>  [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (f...
14:16:25 <Cale> > iterate f x
14:16:26 <lambdabot>  [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (f...
14:16:29 <olsner> > fix ((1:) . map (*2))
14:16:30 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
14:16:59 <Trinithis> so curry fix (f x) == iterate f x
14:17:02 <int-e> > let fib rec 0 = 0; fib rec 1 = 1; fib rec n = rec (n-1) + rec (n-2); memoize f f' = (map (f f') [0..] !!) in fix (memoize fib) 100
14:17:03 <lambdabot>  354224848179261915075
14:17:18 <Cale> Trinithis: not quite...
14:17:19 <Trinithis> not curry...
14:17:25 <Cale> Trinithis: note that I had a map in there...
14:17:29 <Cale> (and the (:))
14:18:04 <Cale> @pl \f x -> (x:) . map f
14:18:05 <lambdabot> flip ((.) . (:)) . map
14:18:17 <Cale> heh
14:18:30 <olsner> > fix((1:)<$>((*2)<$>)) -- :D
14:18:31 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
14:18:38 <Trinithis> @unpl (x:) . map f
14:18:38 <lambdabot> (\ d -> x : (map f d))
14:18:42 <olsner> yummy
14:19:08 <Cale> @pl \f x -> fix ((x:) . map f)
14:19:08 <lambdabot> (fix .) . flip ((.) . (:)) . map
14:19:25 <Cale> ((fix .) . flip ((.) . (:)) . map) f x
14:19:27 <Cale> > ((fix .) . flip ((.) . (:)) . map) f x
14:19:28 <lambdabot>  [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (f...
14:19:44 <Cale> pretty unreadable :)
14:19:51 <Trinithis> lol
14:19:55 <chrisdone> is that some church numerals?
14:20:15 <olsner> for some values of f, yes :P
14:20:17 <Cale> sort of, yeah
14:20:53 <int-e> > fix f :: Expr
14:20:54 <lambdabot>  f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f...
14:21:06 <dmhouse> > fix f
14:21:07 <lambdabot>  Add a type signature
14:21:16 <mauke> > fix error
14:21:21 <olsner> or, yeah, conceptually that list could be something like [0..] churched
14:21:29 <Trinithis> > fix $ const 0
14:21:30 <lambdabot>  0
14:21:32 <lambdabot>  thread killed
14:21:33 <vixey> > fix unsafeCoerce
14:21:34 <lambdabot>   Not in scope: `unsafeCoerce'
14:21:36 <mauke> > fix fail
14:21:37 <lambdabot>  ""
14:21:38 <Trinithis> > fix $ const abc
14:21:39 <lambdabot>   Not in scope: `abc'
14:21:57 <Trinithis> > fix $ const 43534534
14:21:58 <lambdabot>  43534534
14:22:03 <Trinithis> > fix $ const []
14:22:04 <lambdabot>  []
14:22:11 <mauke> > fmap fix return x
14:22:13 <lambdabot>  x
14:22:26 <vixey> @hoogle unsafePerformIO
14:22:27 <lambdabot> Foreign.unsafePerformIO :: IO a -> a
14:22:27 <lambdabot> System.IO.Unsafe.unsafePerformIO :: IO a -> a
14:23:03 <Trinithis> > fmap fix Just x
14:23:03 <lambdabot>  Couldn't match expected type `a -> a'
14:23:28 <r3m0t> > fmap fix Just
14:23:28 <lambdabot>  Couldn't match expected type `a -> a'
14:23:42 <Trinithis> > fmap fix return x
14:23:44 <lambdabot>  x
14:23:46 <vixey> > Just . Just . Just . Just $ Nothing
14:23:47 <lambdabot>  Just (Just (Just (Just Nothing)))
14:23:49 <Trinithis> > fmap fix Just x
14:23:49 <lambdabot>  Couldn't match expected type `a -> a'
14:24:01 <Cale> > fmap fix const x
14:24:02 <lambdabot>  x
14:24:06 <Cale> (same thing)
14:24:14 <Trinithis> Why does "fmap fix Just x" not work when the return version does
14:24:22 <Cale> > (fix . const) x
14:24:23 <lambdabot>  x
14:24:27 <Cale> (same thing again)
14:24:28 <r3m0t> :t return
14:24:28 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
14:24:33 <r3m0t> :t Just
14:24:33 <lambdabot> forall a. a -> Maybe a
14:24:35 <Cale> It's the return in the ((->) a) monad
14:24:40 <Trinithis> oh
14:24:41 <vixey> return = Just
14:24:52 <Cale> :t fmap fix
14:24:52 <lambdabot> forall a (f :: * -> *). (Functor f) => f (a -> a) -> f a
14:24:59 <Cale> :t return
14:25:00 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
14:25:14 <Cale> f = (a ->), m = (a ->)
14:25:42 <Cale> and thus,  f (a -> a)  unifies with  a -> m a  ;)
14:26:39 <Cale> fmap in this context is function composition
14:26:49 <Cale> > (fix . return) x
14:26:50 <lambdabot>  x
14:26:54 <Cale> and return is const
14:26:57 <Cale> > (fix . const) x
14:26:58 <lambdabot>  x
14:27:13 <Cale> of course, that's basically the same as what you were writing above :)
14:27:29 <Trinithis> haskell's system is the same as c's right?
14:27:39 <vixey> what
14:27:41 <Cale> system of what?
14:27:48 <medfly> its a programming language too
14:27:50 <Trinithis> System.Command.system*
14:27:55 <Cale> oh
14:28:01 <Cale> :t System.Command.system
14:28:17 <Trinithis> :t System.Cmd.system
14:28:18 <lambdabot> String -> IO GHC.IOBase.ExitCode
14:28:29 <Cale> ah, right
14:28:39 <Cale> I suspect it's at least similar.
14:28:47 <Trinithis> alright
14:29:02 <Cale> The permissible values for ExitCode are of course a little different from the C version ;)
14:29:28 <Quylui> f(x) = my brain, f(x +this IRC) = head 'asplode
14:29:48 <Trinithis> ?
14:29:52 <medfly> thats about right. freenode is weird.
14:30:23 <mauke> http://haskell.org/haskellwiki/Real_World
14:30:24 <lambdabot> Title: Real World - HaskellWiki
14:30:48 <Cale> Trinithis: ExitCode is an algebraic datatype, with values ExitSuccess, and ExitFailure Int
14:30:54 <Trinithis> k
14:31:21 <thoughtpolice> okay this has always confused the hell out of me, but what exactly is (->) ?
14:31:35 <thoughtpolice> i ask now because i have gotten fed up with its mention and my lack of understanding.
14:31:41 <paczesiowa> :k (->)
14:31:42 <lambdabot> ?? -> ? -> *
14:31:55 <paczesiowa> :k (Int->)
14:32:13 <paczesiowa> :k (->) Int
14:32:13 <lambdabot> ? -> *
14:32:45 <paczesiowa> :t (undefined :: (->) Int String ) Int
14:32:49 <Trinithis> What's with the ?'s in :k ?
14:32:57 <mauke> thoughtpolice: (->) is the function type constructor
14:33:07 <mauke> thoughtpolice: (->) X Y is the type of functions from X to Y
14:34:06 <thoughtpolice> then what did cale mean by saying 'it's the return in the ((->) e) monad' ?
14:34:25 <paczesiowa> (->) e is a monad
14:34:37 <mauke> paczesiowa: heh. I was about to say exactly the same thing
14:35:04 <vixey> > return () ()
14:35:05 <lambdabot>  ()
14:35:38 <Trinithis> return == const for (->) e
14:35:39 <erikc> is that a builtin monad or defined in libraries?
14:35:57 <paczesiowa> library one
14:36:01 <vixey> Control.Monad.Reader
14:36:10 <dmhouse> It's essentially Reader, modulo newtypes.
14:36:17 <mauke> no monad is built in
14:36:22 <dmhouse> Well, IO.
14:36:31 <mauke> IO is still a library thing
14:36:35 <tristes_tigres> Good evening
14:36:38 <dmhouse> It's highly magical.
14:36:44 <vixey> hi tigres
14:36:59 <chrisdone> Cale: hey any chance of getting λb to join #webhaskell, pretty please?
14:37:23 <mauke> so is <stdio.h> in C
14:37:45 <Trinithis> source for (->) e monad :http://haskell.org/ghc/docs/latest/html/libraries/base/src/Control-Monad-Instances.html
14:37:46 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/5g7w8m
14:37:59 <paczesiowa> > ((return 2 :: (->) Int Int) >>= return . (+1)) undefined
14:38:00 <lambdabot>  3
14:38:53 <dcoutts> dons: wow, I did not know that. That's a lot of work.
14:40:14 <tristes_tigres> this doesn't work: instance Show (RoTree) where show = showRoTree
14:40:14 <tristes_tigres> this does:              instance Show (RoTree) where showsPrec _   = showsRoTree
14:40:14 <tristes_tigres> why ??
14:40:28 <EvilTerran> ?type show
14:40:28 <lambdabot> forall a. (Show a) => a -> String
14:40:30 <EvilTerran> ?type showsPrec
14:40:31 <lambdabot> forall a. (Show a) => Int -> a -> String -> String
14:40:34 <mauke> how does it not work?
14:40:46 <EvilTerran> showsRoTree :: RoTree -> String -> String, I presume?
14:40:53 <EvilTerran> not RoTree -> String
14:40:54 <tristes_tigres> EvilT yes
14:41:16 <chrisdone> haha
14:41:17 <chrisdone> @pl \f f' (a,b) (c,d) -> (f a c,f' b d)
14:41:17 <tristes_tigres> showsRoTree :: RoTree -> ShowS
14:41:18 <lambdabot> flip flip snd . (ap .) . flip flip fst . ((.) .) . flip flip snd . ((flip . ((flip . (ap .)) .)) .) . flip flip fst . ((flip . ((flip . ((.) .)) .)) .) . flip . (((.) . flip . (((.) . (,)) .)) .)
14:41:38 <tristes_tigres> showRoTree :: RoTree -> String
14:42:09 <EvilTerran> oh, i see
14:42:12 <chrisdone> go go gadget @pl
14:42:21 <EvilTerran> how does it fail?
14:42:29 <Quylui> ot: where can i learn how to haskell like you guys
14:42:42 <chrisdone> real world haskell + this channel
14:42:46 <vixey> Quylui: #haskell
14:42:53 <mauke> Quylui: start at http://www.haskell.org/
14:42:54 <lambdabot> Title: Haskell - HaskellWiki
14:42:56 <EvilTerran> ?type (***)
14:42:57 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
14:43:02 <Quylui> wow, thanks mates
14:43:14 <EvilTerran> > (f *** g) (x,y)
14:43:14 <lambdabot>  Add a type signature
14:43:20 <EvilTerran> > (f *** g) (x,y) :: (Expr,Expr)
14:43:21 <lambdabot>  (f x,g y)
14:43:42 <tristes_tigres> EvilT:
14:43:44 <tristes_tigres> [1 of 1] Compiling Main             ( BinaryTree.hs, interpreted )
14:43:44 <tristes_tigres> BinaryTree.hs:85:64:
14:43:44 <tristes_tigres>     Ambiguous occurrence `show'
14:43:44 <tristes_tigres>     It could refer to either `Main.show', defined at BinaryTree.hs:187:0
14:43:44 <tristes_tigres>                           or `Prelude.show', imported from Prelude
14:43:45 <tristes_tigres> Failed, modules loaded: none.
14:43:54 <chrisdone> @type join (&&&)
14:43:55 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a b (c, c)
14:43:56 <nominolo_> @users
14:43:56 <lambdabot> Maximum users seen in #haskell: 507, currently: 494 (97.4%), active: 21 (4.3%)
14:43:58 <mauke> tristes_tigres: so you've redefined show
14:44:00 <EvilTerran> > uncurry (***) ((f *** g) (x,y)) (a,b) :: (Expr,Expr)
14:44:01 <lambdabot>  (f x a,g y b)
14:44:14 <EvilTerran> ?pl uncurry (***) ((f *** g) (x,y)) (a,b)
14:44:14 <lambdabot> uncurry (***) ((f *** g) (x, y)) (a, b)
14:44:14 <nominolo_> 500+!! \o/
14:44:25 <tristes_tigres> mauke : why it does work with shoPrec &
14:44:26 <EvilTerran> ?pl \x y a b -> uncurry (***) ((f *** g) (x,y)) (a,b)
14:44:26 <lambdabot> flip flip (,) . (((.) . (.) . uncurry (***) . (f *** g)) .) . (,)
14:44:28 <EvilTerran> eew
14:44:41 <paczesiowa> tristes_tigres: check your indentation level
14:44:48 <chrisdone> yeah, the arrows version is actually longer in code than with formal parameters
14:45:09 <mauke> tristes_tigres: because as long as you're not using 'show', haskell doesn't care that it's ambiguous
14:45:15 <tristes_tigres> pcziesiowa : Bingo !!!
14:45:55 <tristes_tigres> mauke: it's instance declaration
14:46:46 <paczesiowa> tristes_tigres: with bad indentation it wasn't instance declaration:>
14:46:50 <mauke> tristes_tigres: what is? line 85 or line 187?
14:47:24 <tristes_tigres> mauke: line 187
14:47:36 <mauke> oh
14:47:41 <tristes_tigres> mauke: it works now, problem was indentation
14:47:44 <paczesiowa> what? I guessed indentation problem (lucky) but you guessed his source code?
14:48:08 <EvilTerran> > (\f g -> uncurry (***) . (f *** g)) f g (a,b) (c,d) :: (Expr,Expr) -- chrisdone
14:48:10 <lambdabot>  (f a c,g b d)
14:48:15 <EvilTerran> yay pointlessness
14:48:17 <tristes_tigres> pacziesowa: import Control.ReadThoughts
14:48:22 <EvilTerran> at least i didn't write that as
14:48:51 <EvilTerran> > (((uncurry (***) .) .) . (***)) f g (a,b) (c,d) :: (Expr,Expr)
14:48:52 <lambdabot>  (f a c,g b d)
14:49:05 <paczesiowa> tristes_tigres: import Control.ReadThoughts hiding (what?)
14:49:56 <ziman> all those flip (((.) . (.) . snd . (.) `ap`) ... expressions have quite low entropy; they're just (syntactical) trees having few possible values in nodes (often only (.)); i wonder what an efficient encoding for them would look like
14:50:23 <paczesiowa> you can gzip them
14:50:52 <tristes_tigres> still don't understand why showsPrec worked with incorrect indentation
14:51:06 <chessguy> @pl \x y -> z
14:51:06 <lambdabot> const (const z)
14:51:41 <DuClare> Is there any reason to believe that . as an operator will get removed?  (It's in removal candidates for next standard)
14:51:53 <Quylui> can anyone briefly help me get acquainted with haskell (in pm)? i'm working through the tutorials but i'm new to programming :\
14:52:03 <dmhouse> DuClare: that's a massively stupid proposal.
14:52:04 <paczesiowa> tristes_tigres: maybe other code called show in your module like mauke suggested
14:52:07 <dmhouse> ?where yaht
14:52:08 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
14:52:10 <dmhouse> Quylui: ^^
14:52:18 <Trinithis> How can I get the current year, month, day, hour, minute, second?
14:52:19 <tristes_tigres> pacziesowa: it did
14:52:42 <paczesiowa> tristes_tigres: but showsPrec wasn't called, mystery solved
14:52:56 <paczesiowa> Quylui: just ask here
14:52:57 <tristes_tigres> ?where is my luck and happiness
14:52:57 <lambdabot> I know nothing about is.
14:53:22 <tristes_tigres> lambdabot does nt know what the meaning of "is" is
14:53:45 <tristes_tigres> ?where girls
14:53:45 <lambdabot> I know nothing about girls.
14:53:51 <tristes_tigres> it figures
14:55:28 <tristes_tigres> Trinithis: System.Time
14:55:33 <Trinithis> k
14:56:12 <DuClare> dmhouse, I think so too (unless . will be much more useful in something else, and another operator will come take .'s place)
14:56:33 <DuClare> It's just scary to see all kinds of proposals concerning something you care about. :o
14:57:21 <Cale> DuClare: yeah... I don't think there's any real chance of (.)'s meaning being changed.
14:57:30 <Cale> DuClare: It's far too important an operator.
14:57:41 <nominolo_> DuClare: there's a record proposal from 1999 that suggests using . for record access and have # be compose
14:57:53 * glguy_ proposes # for record access!
14:57:53 <tristes_tigres> Hmm, almost 500 users yet so little traffic
14:57:54 <glguy_> solved
14:58:00 <chrisdone> any chance of Data.Foldable replacing prelude's foldr and foldl?
14:58:02 <Cale> I would see the module path separator changed before (.) changed to anything other than composition.
14:58:10 <nominolo_> yeah, that's what i thought when reading that
14:58:11 <Cale> (or a generalisation thereof)
14:58:11 <paczesiowa> wouldn't you prefer some nice o-like character from plane far far away?
14:58:38 <nominolo_> Cale: records are modules
14:58:41 <mauke> f∘g
14:58:56 <ddarius> @users
14:58:56 <lambdabot> Maximum users seen in #haskell: 507, currently: 493 (97.2%), active: 22 (4.5%)
14:59:00 <ddarius> Holy crap.
14:59:01 <nominolo_> or, you can pretty much emulate modules using records
14:59:12 <Cale> mauke: would be great, but keyboards don't universally have a key for ∘
14:59:27 <Cale> mauke: and usually that takes a few keystrokes to produce, even where it is available
14:59:42 <paczesiowa> you can map it anyway to some multimedia key
14:59:49 <mauke> record»field
14:59:50 <tristes_tigres> Cale: what we need is a haskell keyboard
14:59:50 <vixey> I would rather use  ∘ as compositino
14:59:57 <vixey> it's annoying to use .
15:00:02 <BONUS> why
15:00:06 <Cale> vixey: how so?
15:00:06 <vixey> or o
15:00:09 <tristes_tigres> with a big lambda key
15:00:10 <vixey> as an infix
15:00:14 <Cale> . is easy to type
15:00:17 <nominolo> > (1+) `o` (*2) $ 1
15:00:18 <BONUS> . rocks
15:00:18 <lambdabot>  Couldn't match expected type `(t -> t) -> (a1 -> a1) -> a -> b'
15:00:22 <paczesiowa> tristes_tigres: ... instead of enter
15:00:27 <vixey> I am just used to a circle for composition, it looks better
15:00:28 <Cale> and composition is basically the most common operator
15:00:50 <vixey> nominolo: without the ``'s though
15:00:51 <Cale> So it makes sense to give it something which is both visually subtle and easy to type
15:00:51 <tristes_tigres> paczesiowa: exactly
15:01:04 <paczesiowa> space!
15:01:05 <nominolo> vixey: that'd be very disrupting
15:01:15 <nominolo> vixey: you'd have to change the parser
15:01:17 <dmhouse> I'd like the option of circle for composition.
15:01:20 <vixey> I don't mind
15:01:26 <vixey> I'd love to change the parser
15:01:36 <dmhouse> And the option of a real lambda for lambda, and a real arrow for ->, and so on.
15:02:00 <dmhouse> If for no other reason that literate Haskell blog posts suddenly become a lot prettier.
15:02:09 <vixey> dmhouse well you can already use ∘ as composition
15:02:19 <dolio> I think it already accepts a real arrow.
15:02:20 <dmhouse> Oh, really?
15:02:27 <dmhouse> This is good. :)
15:02:29 <vixey> sure (∘) = (.)
15:02:31 <dolio> Lambda it doesn't because that's a letter.
15:02:45 <dmhouse> > id ∘ id $ 4
15:02:45 <lambdabot>  Illegal character ''\8728''
15:02:45 <lambdabot>  at "" (column 4)
15:02:51 <dmhouse> Ah, lambdabot fails.
15:03:02 <chrisdone> works in ghci
15:03:19 <vixey> @let (∘) = (.)
15:03:19 <lambdabot>  Illegal character ''\136''
15:03:26 <vixey> hm
15:03:32 <vixey> that is pretty rubbish
15:03:34 <dmhouse> Huh, "Not in scope: ^X". Perhaps a too-old GHC?
15:06:48 <dolio> → works in both types and the relevant expressions.
15:07:06 <EvilTerran> the "illegal character" complaint will be coming from Language.Haskell.Syntax or whatever it's called
15:07:06 <erikc> i remember reading somewhere the support for unicode characters was there
15:07:14 <dolio> \x → x, case x of y → z
15:07:23 <erikc> bunch of people also just fix it in emacs :)
15:07:28 <dmhouse> > map (\x → x) [1..4]
15:07:29 <lambdabot>  Illegal character ''\8594''
15:07:29 <lambdabot>  at "" (column 9)
15:07:45 <dolio> -XUnicodeSyntax
15:07:53 <chrisdone> that's real?
15:08:02 <dolio> Yes.
15:08:02 <chrisdone> :set -XUnicodeSyntax
15:08:25 <dolio> It doesn't seem to do too well displaying the expressions, though.
15:08:28 <dmhouse> Ah, it works with {-# LANGUAGE UnicodeSyntax #-}.
15:08:33 <chrisdone> hey it works in ghci
15:08:36 <EvilTerran> dolio, ITYM (λx → x) :P
15:08:46 <chrisdone> EvilTerran: ITYM?
15:08:52 <EvilTerran> "I think you mean"
15:08:54 <dolio> EvilTerran: No, λ is a letter.
15:08:57 <dmhouse> Err, actually, ∘ still doesn't work even with that flag.
15:08:57 * vixey uses λx, x in her language
15:08:58 <EvilTerran> as i said, it'll be Language.Haskell.Syntax that can't cope with the unicode
15:09:00 <dolio> So you can write:
15:09:04 <EvilTerran> dolio, ah
15:09:07 <dolio> \λ -> λ
15:09:38 <EvilTerran> dmhouse, getting the encodings and things right is a bit fiddly, too
15:09:40 <dancor> there's no easy way to kill all my runInteractiveCommands when my process is kill-ed, is there?
15:09:56 <chrisdone> λx y.x÷y
15:10:12 <dmhouse> Eww, a real division sign. Who uses that?
15:10:13 <dolio> What is that? Division?
15:10:16 <chrisdone> haha
15:10:19 <chrisdone> yes
15:10:21 <erikc> heh
15:10:22 <dmhouse> Obliques ftw.
15:10:24 <vixey> dmhouse: You must define (∘) = (.) though
15:10:35 <dolio> That's not very nicely rendered in my font.
15:10:38 <vixey> dmhouse: at least it worked in 6.8.3 ghci for me
15:10:39 <chrisdone> k · y ÷ l
15:10:43 <chrisdone> dolio: :(
15:10:43 <vixey> so maybe it's terminal issues?
15:10:47 <Trinithis> Is there a way to find OS environment variables?
15:10:50 <dmhouse> vixey: ah, got it.
15:10:50 <mauke> haha, what the ell
15:10:59 <mauke> U+2215 (e2 88 95): DIVISION SLASH [∕]
15:11:00 <dmhouse> vixey: that should be built-in.
15:11:10 <vixey> dmhouse: agreed :)
15:11:23 <vixey> dmhouse: although I actually use . in haskell...
15:11:30 <chrisdone> /∕ <-- haha, wow, they are different ·—·
15:11:30 <ddarius> No one is keeping you from putting Prelude.Unicode on Hackage.
15:11:36 <dancor> Trinithis: getEnv
15:11:40 <Trinithis> thx
15:11:48 <vixey> not having a hackage account :/
15:11:57 <ddarius> vixey: Is very easy to fix
15:12:02 <chrisdone> yeah, I need a hackage account :<
15:12:03 <dmhouse> vixey, Well, yes, in day-to-day programming, but it'd be nice to have ∘ there for, e.g., literate haskell blog posts.
15:12:13 <mauke> µμµμµμµμµμµμµμ
15:12:29 <MyCatVerbs> mauke: no µ.
15:12:42 <dancor> the hackage captcha is aggressive email interrogation
15:12:50 <vixey> yes lol
15:12:51 <EvilTerran> dolio, what about U+1D6CC MATHEMATICAL BOLD SMALL LAMDA?
15:12:57 <mauke> U+002F (2f): SOLIDUS [/]; U+2044 (e2 81 84): FRACTION SLASH [⁄]; U+2215 (e2 88 95): DIVISION SLASH [∕]
15:13:09 <dmhouse> Υαυ φορ τηε γρεεκ αλπηαβετ!
15:13:11 <chrisdone> MyCatVerbs: ∘ rly‽
15:13:34 <dmhouse> And of course for C-x RET C-\.
15:13:41 <mauke> αλφαβετ, please
15:13:44 <chrisdone> mauke: thank god, just what I've needed
15:14:06 <Spark> i just hold down capslock and type αλπηαβετ
15:14:28 <dmhouse> mauke: I just typed the English keys and that's what Emacs gave me.
15:14:54 <mauke> except η is eta, not h
15:15:08 <dmhouse> Well, yes, what I wrote clearly doesn't make any sense ;)
15:15:25 <chrisdone> dmhouse: with caps lock? hmm caps lock sounds like a great keyboard layout change. who uses caps lock anyway apart from PEOPLE WHO LOVE TO SHOUT?
15:15:33 <Spark> ιφ ι ψοθλδ αψτθαλλυ σπεακ γρεεκ τηεν ιτ ςοθλδ βε α διφφερεντ ματτερ
15:15:48 <dmhouse> Spark: <chrisdone> dmhouse: with caps lock? hmm caps lock sounds like a great keyboard layout change. who uses caps lock anyway apart from PEOPLE WHO LOVE TO SHOUT?
15:15:54 <Spark> yeah it rocks
15:16:07 <Spark> except when you hit it by accident and get αccident instead of accident
15:16:57 <chrisdone> § <- python
15:17:07 <dmhouse> I need a nice greek font.
15:18:28 * matthew-_ has green lambdas: http://wellquite.org/non-blog/green_lambdas.jpg
15:18:47 <mauke> needs more lens flare
15:18:53 <ddarius> They don't look very fuzzy to me.
15:19:02 <matthew-_> I don't have felt. I'm sorry
15:19:20 <matthew-_> I have cardboard and green filing cabinet dividers
15:19:35 <dolio> EvilTerran: Don't know, but that apparently revealed a problem in my UTF-8 encoding of characters in bytestring-show.
15:19:50 * matthew-_ wonders if there's a gimp "fuzzy" filter
15:20:02 <EvilTerran> dolio, er, what, that unicode symbol?
15:20:15 <dolio> EvilTerran: And on the web page for it at fileformat.info, it looks like a character in some Asian language.
15:20:23 <EvilTerran> weird
15:20:25 <dolio> Mathematical bold small lamda.
15:20:33 <EvilTerran> i got that straight out of unicode.org
15:21:45 <dolio> How do you find a character at unicode.org?
15:22:21 <EvilTerran> http://www.unicode.org/charts/
15:22:22 <lambdabot> Title: Code Charts - Scripts
15:23:55 <ddarius> Positional notation for numbers is too hierarchical.  I think we should go to a distributed scheme, perhaps tag-based.
15:24:04 <Spark> use gucharmap
15:24:14 <Spark> to find unicode codepoints
15:26:02 <dolio> Apparently utf8-string doesn't print it right, either.
15:28:22 <dolio> Unless it's my terminal.
15:29:39 <dolio> Maybe that's it. xterm shows a single unknown character.
15:29:49 <Spark> this channel is logged, right?
15:30:07 <dolio> Yes.
15:30:09 <Spark> searching for "log" gets me the mathematical function
15:30:21 <vixey> topic
15:30:42 <Spark> ah yes the topic was broken before that
15:31:53 <dancor> Main.hs starts a subprocess.  if i do 'setsid ./Main' and then kill the ./Main process, the subprocess lives on.  i thought it wouldn't since ./Main would be the head of the process group
15:32:04 <dancor> what am i missing
15:34:04 <bd_> dancor: kill only sends a signal to one PID. To send it to the process group, invoke the kill() syscall with a negative pgid
15:34:28 <bd_> eg, kill -TERM -pgid
15:39:28 <dancor> bd_: ah, nice.  then i don't even need setsid looks like
15:40:33 <jeffwheeler> Will there eventually be a better way to install cabal-install instead of downloading and running the Setup.hs's of each dependency?
15:41:01 <jeffwheeler> After cabal-install is installed, it's awesome. Doing that though is a pain.
15:41:16 <dancor> cabal-metainstall
15:41:24 <erikc> cabal install cabal-install
15:41:51 <jeffwheeler> Err . . . I can't tell whether either of you is kidding.
15:41:55 <erikc> haha
15:41:56 <dancor> jeffwheeler: both
15:42:02 <jeffwheeler> Good. :D
15:42:15 <zachk> cabal install ghc
15:42:26 <dancor> someone should just set up a simple script to do it
15:42:39 <jeffwheeler> Maybe the trick will be to distribute cabal-install as a package on most systems.
15:42:48 <mauke> jeffwheeler: I use http://mauke.ath.cx/stuff/haskell/Makefile
15:42:49 <jeffwheeler> Like, a Debian/Ubuntu/RHEL package.
15:42:50 <erikc> although if/when the haskell platform pans out, that wont be so farfetched
15:42:52 <erikc> yea
15:42:54 <erikc> thats the plan
15:42:56 <zachk> then you will have a bunch of people who dont know haskell whining about haskell
15:43:10 <dancor> i already do that
15:43:23 <mauke> usage: set PREFIX in your environment and put a link to that makefile in each source directory
15:43:48 <mauke> you'll still have to download and unpack the packages manually, but installation is just a 'make install' away
15:43:50 <jeffwheeler> That looks handy. It's mostly only useful the first time, though.
15:43:55 <erikc> i still have yet to build ghc successfully on mingw though, windows development is depressing
15:44:14 <mauke> it's also useful for hacking on stuff when you need to rebuild all the time :-)
15:44:31 <jeffwheeler> mauke: yeah, that makes sense; Yi comes with a Hacker setup, but I haven't used it
15:44:52 <jeffwheeler> (as in, to hack Yi, it can build a special binary that's not the main one)
15:45:14 <jeffwheeler> (sorry, I said that very poorly)
15:46:21 <sal23> Cale: I have uploaded lambdabot compilation error on mac to hpaste: http://www.hpaste.org/9249
15:48:06 <Cale> huh
15:48:15 <Cale> What a strange error
15:48:59 <Cale> I would suspect a problem with your ghc installation, or a bug in ghc
15:49:25 <sal23> how to isolate it then?
15:50:36 <Cale> well, I suppose go look and see what's in that directory
15:51:00 <Cale> It's saying that your ghc-asm binary is missing
15:51:10 <sal23> how about compiling that file by itself, and see how it goes...I don't know though what ghc options are being executed by the build script
15:52:13 <sal23> the binary is there and executable....that was the obvious check that I did when I saw the error
15:53:57 <dons> erikc: can't you just use the ghc/windows binary on haskell.org/ghc ?
15:54:14 <erikc> yup, thats what i do
15:54:49 <sal23> I think I know what the problem is....it is a perl wrapper which has the perl path hardcoded to /opt/local/bin/perl
15:54:57 <dons> jeffwheeler: a few distros have binary packages of cabal install
15:55:06 <sal23> changed it to correct path....ghc bug in setting perl path
15:55:09 <dons> we'll start naming and shaming distros that arne't supporting cabal soon
15:55:29 <jeffwheeler> dons: good; cabal-install is a really great product
15:55:46 <chrisdone> dons: good idea :P
15:55:47 <jeffwheeler> dons: it makes Python's distutils seem even worse then they already did
15:55:53 <Cale> I think that cabal-install should simply come with ghc
15:56:01 <chrisdone> agreed there
15:56:05 <erikc> ive just been messing with ghc on linux toying with the idea of simd primitives and wanted to get the environment up on linux
15:56:17 <erikc> err, up on windows
15:56:28 <dons> erikc: a library wrapper to simd intrs would be useful
15:56:45 <chrisdone> cale: you have to manually install like 5 packages just to get cabal-install. friends have complained to me about that when I encouraged them to try haskell
15:56:58 <dons> chrisdone: should just be HTTP and zlib
15:57:08 <chrisdone> dons: but those two have depenancies
15:57:19 <dons> on base things
15:57:27 <dons> what distro?
15:57:36 <dons> its substandard distro packaging that's the problem.
15:57:51 <chrisdone> Network and Parsec, each of which have their own deps.
15:57:56 <jeffwheeler> I had to install about five different things just now.
15:57:59 <dons> yeah, HTTP depends on network and parsec, whcih are in the extralibs set.
15:57:59 <chrisdone> I had to install cabal install recently, so I remember this..
15:58:09 <dons> if  *that's* not supported , the distro is way behind
15:58:15 <chrisdone> hmm
15:58:21 <dons> we need a public graph of what distros support what.
15:58:23 <chrisdone> let me see
15:58:27 <chrisdone> right!
15:58:37 <dons> kick some  butt.
15:59:25 <chrisdone> from face value, I don't think Ubuntu does; `apt-cache search haskell | grep extra' and `... | grep libs' outputs nothing
15:59:27 <dolio> I think Ubuntu (and that probably means Debian, too) has both HTTP and Network packages.
15:59:33 <chrisdone> I'll check on the actual package list to be sure
15:59:34 <chrisdone> oh?
15:59:36 <dolio> So they should be able to have a cabal-install package.
16:00:18 <chrisdone> ahh, libghc6-network-dev and libghc6-http-dev, right
16:00:28 <dolio> Yeah.
16:01:02 <chrisdone> that's great
16:01:09 <dons> if debian doesn't have a cabal-install package, we need to talk to someone.
16:01:18 <dolio> I assume Ubuntu just pulls their haskell stuff from what Debian has.
16:01:28 <dons> Arch's got 500 packages native, fwiw. So distros can do a *lot* better.
16:01:42 <chrisdone> Cabal is there, but not Cabal install
16:07:08 <Trinithis> @pl \x y -> x ++ "=" ++ y
16:07:08 <lambdabot> (. ('=' :)) . (++)
16:08:01 <Trinithis> @src intercalate
16:08:01 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
16:08:10 <Cale> dons: another problem is that GHC releases seem to always come a month after Ubuntu releases (less?) making the packages that come with Ubuntu almost always out of date.
16:08:44 <Cale> dons: I don't even bother with Ubuntu's Haskell packages anyway, preferring to install the generic linux tarball.
16:08:55 <dolio> Yeah, and they don't have some dedicated guy to make unofficial repositories.
16:09:07 <jeffz> someone could always volunteer to package ghc and configure a repo on haskell.org
16:09:37 <vixey> ?hackage ghc
16:09:37 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/ghc
16:13:19 <dons> Cale, right, so that's a benefit of the HP, async updates, independant of the GHC cycle
16:13:46 <Cale> dons: But if your GHC is out of date...
16:14:15 <dons> well, they'll have a GHC that supports the HP.
16:14:19 <dons> even if both are out of date.
16:14:29 <dons> they'll just be behind. Thanks Debian!
16:16:09 <sjanssen> Cale: on the upside, GHC packages in Ubuntu will only be 6 months out of date at the most
16:16:29 <seliopou> stack overflow help, anybody?
16:16:38 <Cale> sjanssen: that's true
16:17:05 <Cale> sjanssen: It's just that the timing seems to ensure that it's always as close to 6 months as possible :)
16:17:15 <Cale> seliopou: sure
16:17:18 <dons> seliopou: don't use foldl, and compile with ghc -O
16:17:20 <sjanssen> what is the ETA for 6.10?
16:17:55 <sjanssen> Cale: Release candidate: Friday 19th September 2008. :(
16:18:07 <dons> 30th Sep. or so.
16:18:21 <dons> ubuntu tries to ensure it is as far behind haskell head as possible
16:18:43 <seliopou> dons: already doing that :(
16:18:52 <sjanssen> http://hackage.haskell.org/trac/ghc/wiki/Status/Releases is exciting
16:18:54 <lambdabot> Title: Status/Releases - GHC - Trac
16:19:24 <Cale> I wonder... Ibex is coming out in October.
16:19:30 <erikc> heh
16:20:08 <sjanssen> Cale: I bet it's too late
16:20:26 <sjanssen> I would imagine they freeze packages at least a month before the release
16:20:48 <seliopou> here's the code (alpha renamed, might have messed something up, but you can get the gist)
16:20:55 <seliopou> http://hpaste.org/9251
16:21:52 <Cale> seliopou: what is BuyData?
16:21:59 <seliopou> Just a record with three fields
16:22:14 <seliopou> two are ints and the other is a list of ints
16:22:31 <Cale> Try adding strictness annotations to the Int fields so that large expressions won't build up in them.
16:22:45 <seliopou> I think I already tried that, but I'll give it another go
16:22:52 <Cale> er, actually though, you're only modifying the list field
16:23:05 <Igloo> The problem is probably that modify isn't strictly updating the state
16:23:19 <Cale> mm.. yeah
16:23:21 <seliopou> think so?
16:23:22 <seliopou> Hmmm
16:23:23 <seliopou> ok
16:23:27 <Igloo> So you're creating   alterFn (alterFn (alterFn ...   in the state
16:23:31 <Igloo> Is there a modify' or something?
16:23:46 <Cale> Or perhaps just try the strict state monad?
16:23:53 <EvilTerran> that's what i was gonna suggest
16:23:56 <seliopou> Cale: that's what I'm using
16:25:12 <seliopou> HOT BANG
16:25:13 <seliopou> sweet
16:25:17 <seliopou> you guys were right
16:25:23 <seliopou> it was modify
16:25:23 <seliopou> I made a strict version and all's well
16:33:36 <dons> http://www.reddit.com/comments/6u1jy/view_patterns_added_to_ghc_functions_to_modify/  get ur view pattern docs.
16:33:38 <lambdabot> Title: View Patterns added to GHC. Functions to modify how data is viewed and matched : ..., http://tinyurl.com/5s9754
16:33:48 <dons> we should really play with this some more...
16:33:54 <erikc> dons, when you say a wrapper library for simd intrs, do you mean as a demonstration? i dont see how it could be useful for production, ideally what i'd like to be able to write is stuff like a foldl :: (a -> Word8 -> a) -> (a -> Word128 -> a) -> a -> ByteString -> a
16:34:21 <dons> erikc: why wouldn't it be useful? expose useful sets of instructions as FFI calls
16:34:23 <erikc> that would automatically process leading and trailing unaligned data with the scalar one
16:34:31 <dons> then you can write tight loops with simd stuff in the middle
16:35:31 <erikc> you dont mean an ffi call for a single simd though right
16:36:03 <dons> no, for useful chunks of work.
16:36:06 <erikc> right
16:36:10 <dons> like over vecotrs
16:36:33 <erikc> ah, right
16:39:51 <vixey> view can bind variables!
16:40:31 <dons> in ghc, patterns view you!
16:40:47 <chessguy> that's a little creepy
16:40:51 <Twey> Hahahaha
16:40:55 <Quylui> yeah i'm naked right now
16:41:00 <vixey> this is great
16:41:05 <medfly> hahahahaha
16:41:10 <vixey> is this in 6.9 or what?
16:41:21 <dons> yeah 6.9/10
16:42:36 <dons>  $ pwd
16:42:36 <dons> /var/log
16:42:36 <dons> $ du -hs .
16:42:36 <dons> du: cannot read directory `./httpd/fcgidsock': Permission denied
16:42:38 <dons> 2.8G
16:42:40 <dons> hmm.
16:42:56 <dons> $ echo "oh man" > /tmp/x
16:42:57 <dons> echo: write error: no space left on device
16:43:24 <dons> $ du -hs kernel.log
16:43:25 <dons> 1.4G	kernel.log
16:43:36 <vixey> I want to try stuff with views now
16:43:47 <Igloo> Where's this, dons?
16:44:10 <dons> my laptop, sorry. wrong chan.
16:44:26 <Igloo> heh, OK
16:45:32 <vixey> you could do stuff like foo ([$rx|http://.*/(.*).(.*)|] -> page suffix) = ... ?
16:45:59 <chessguy> wha...
16:46:04 <lispy> yeah, wtf mate?
16:46:10 <EvilTerran> -> [page, suffix], surely?
16:46:13 <vixey> http://hackage.haskell.org/trac/ghc/wiki/ViewPatterns
16:46:15 <lambdabot> Title: ViewPatterns - GHC - Trac
16:46:18 <vixey> dons just linked it ....
16:46:23 <EvilTerran> or (page, suffix), parhaps
16:46:32 <vixey> I'm talking about the view patterns
16:46:34 <EvilTerran> chessguy, lispy - it's using quasiquoting as well
16:46:44 <vixey> "it" lol
16:46:47 <lispy> EvilTerran: I picked up on that, but not much else
16:46:49 <vixey> hi edwardk
16:46:58 <edwardk> how goes?
16:47:05 <EvilTerran> lispy, presumably [$rx| introduces a regex
16:47:14 <vixey> it's all completely hypothetical
16:47:21 <lispy> Hmm
16:47:24 <vixey> edwardk: I confused everyone ..
16:47:38 <edwardk> in a good way or a bad way?
16:47:42 <EvilTerran> and is expanded at compile-time to a function that matches that regex against its parameter and returns the ()ed expressions
16:47:44 <vixey> bad :(
16:47:52 <EvilTerran> you didn't confuse me!
16:50:59 <vixey> @users
16:50:59 <lambdabot> Maximum users seen in #haskell: 507, currently: 468 (92.3%), active: 16 (3.4%)
16:51:00 <lispy> View patterns make me go "hmmm"
16:51:07 <chessguy> EvilTerran:  that should probably concern you
16:51:56 <chessguy> view patters are basically just heavy sugar, right?
16:52:02 <chessguy> +n
16:52:09 * edwardk is sitting here fiddling with static contract checking/esc notation and trying to figure out if an idea is well founded.
16:52:19 <vixey> yes
16:52:30 <edwardk> i'm trying to figure out if there is a way you could write 'point-free' contracts that wouldn't suck.
16:52:58 <vixey> what is a contract?
16:53:27 <edwardk> sort :: Ord a => [a] -> {xs :: [a] | sorted xs }
16:53:40 <vixey> oh o
16:53:56 <edwardk> predicate subtyping
16:54:06 <vixey> -> {sorted [a]}
16:54:12 <edwardk> subtyping an argument is a contract to the caller, subtyping the result is a set of guarantees.
16:54:28 <edwardk> sorted :: Ord a => [a] -> Bool -- is just a predicate in the language
16:54:34 <chessguy> err, can't predicates like that be potentially undecidable?
16:54:38 <edwardk> dana xu had a nice paper on the idea a couple of years back
16:54:38 <edwardk> sure
16:54:43 <edwardk> you can't decide it in general
16:55:14 <edwardk> but the nice thing is in practice if you just follow the reduction rules of the language and only unroll a few times you can often find a counter example or proof. if you can't, then just emit a warning and move on
16:55:21 <edwardk> its not a full fledged dependent type system
16:55:31 <edwardk> just sort of a baby step into undecidability
16:55:52 <chessguy> seems dangerous
16:55:56 <edwardk> _|_ still inhabits the types, so you get a proof of partial correctness at best.
16:56:03 <vixey> sounds cool!
16:56:23 <edwardk> and you get a nice counter example with stack trace if you can prove a violated contract
16:56:32 <edwardk> and a stack trace of what you can't prove as well, at compile time
16:57:24 <edwardk> i've been using it off and on. its been reinvented a few times in different flavors. i invented a kinda cheesy version, dana xu invented a better version, mattieu sozeau invented a really rigorous form that you could theorem prove with, etc.
16:58:05 <chessguy> that does indeed sound cool
16:58:05 <edwardk> anyways what i'm currently playing with and trying to figure out if is well formed (i mean currently as in the last 15 minutes, not much longer)
16:58:30 <vixey> what do you mean well formed?
16:58:32 <edwardk> is if you can write those contracts in a slightly different style
16:58:47 <edwardk> er well-founded
16:58:58 <edwardk> i don't know if it works in all cases, or is even a sound idea
16:58:59 <r3m0t> @hoogle (Monad m) => ([a] -> b) -> ([m a] -> m b)
16:59:00 <lambdabot> No matches, try a more general search
16:59:06 <r3m0t> how do I do this ^^
16:59:07 <edwardk> is to do something slightly differently
16:59:42 <dons> you will obey ! http://img149.imageshack.us/img149/9918/hypnotoadtj9.gif
17:00:34 <edwardk> the idea is to associate a contract method with a term that we try to reduce at compile time, which has one extra argument, the return value. and then to write contracts as just boolean valued functions directly.
17:00:40 <edwardk> then instead of
17:00:46 <dcoutts> dons: hmm, so biggest challenge now is to get useful build reporting in hackage-server. That's my take from this GL discussion and HP planning.
17:00:54 <chessguy> is it not legal to do newtype x = String; newtype y = String
17:00:55 <edwardk> sort :: Ord a => a -> { xs : [a] | sorted xs }
17:00:59 <edwardk> you might say
17:01:02 <dons> and to make metapackages work, dcoutts ?
17:01:18 <edwardk> @contract = const sorted
17:01:18 <lambdabot> Unknown command, try @list
17:01:19 <chessguy> err, X and Y, that is
17:01:20 <dons> dcoutts: is build reporting working for cabal-install already?
17:01:29 <dons> dcoutts: but yeah, people want to get email
17:02:12 <edwardk> which throws away the first argument and then returns true if the second is sorted. and it "gets one more argument than the thing with which it is associated"
17:02:38 <edwardk> @hpaste
17:02:38 <lambdabot> Haskell pastebin: http://hpaste.org/new
17:02:50 <chessguy> @hoogle join
17:02:50 <lambdabot> Control.Monad.join :: Monad m => m (m a) -> m a
17:02:50 <lambdabot> Data.PackedString.joinPS :: PackedString -> [PackedString] -> PackedString
17:02:50 <lambdabot> System.FilePath.Windows.joinDrive :: FilePath -> FilePath -> FilePath
17:03:25 <edwardk> http://hpaste.org/9254 being the general idea
17:03:45 <edwardk> i like the fact that the contract lines are way shorter
17:03:58 <dcoutts> dons: btw, the current prototype hackage-server works. You can import the current index and log file. No tarballs yet, but they should be easy and just make testing heavier at the moment.
17:04:23 <edwardk> er typo on the insert example
17:04:24 <vixey> sort :: Ord a => a -> [a] -- @contract sorted & permutation (#1)
17:04:28 <vixey> :D
17:04:34 <dcoutts> dons: file a ticket with the details about the meta-package. I seem to recall it's a simple fix.
17:04:35 <vixey> oh wait
17:04:37 <edwardk> yeah you can make the contract a lot stronger
17:04:39 <vixey> [a] -> [a]
17:04:40 <adu> is there a good comparison of haskell webapp frameworks out there?
17:05:04 <dcoutts> dons: yes, cabal-install generates simple anonymous build logs, but we also want more detailed built-bot style ones
17:05:13 <edwardk> vixey: yeah i actually have a couple of versions of this that work. i just spewed that off the top of my head =)
17:06:06 <edwardk> anyways its just kind of a toy so i can see what is horribly wrong with it
17:06:25 <edwardk> i think the main issue is the type of the contract doesn't tell you when to stop feeding the contract arguments
17:06:34 <dcoutts> dons: we'll need the more detailed ones for HP testing. I could do with a bit of help with the design for that.
17:06:52 <edwardk> so i'm probably pretty much dead in the water
17:07:09 <vixey> how come? I don't see that anything would be wrong with it
17:07:13 <edwardk> but i thought it was a fun variation to play with, because i really hate the fact that i have to write contracts in a 'pointful' style
17:07:58 <edwardk> well, how many arguments do i feed to the contract before i run the function and then try to feed it the output?
17:08:34 <edwardk> that varies by the type of the contract i supplied
17:08:34 <adu> is haskell.org slow or dead?
17:08:57 <dons> slow...
17:09:00 <dons> Igloo:
17:09:36 <chessguy> @unpl join . flip (attackedBy . map snd . pieceLocations)
17:09:36 <lambdabot> (\ f -> (\ c -> attackedBy (map snd (pieceLocations c)) f) >>= \ g -> g)
17:12:27 <edwardk> with the {}'d version I get a clear model of { xs | pre xs } -> { ys | post xs ys } which extends to higher order cases and which i can work through one lambda at a time even after i change to a core rep.
17:13:25 <edwardk> i guess with the @contract stuff i can't point a finger and say who broke the contract, the caller or the function.
17:25:58 <chessguy> @pl \b -> a (f b) b
17:25:58 <lambdabot> a =<< f
17:28:43 <matthew-_> hey Lennart. Are you not able to come along to Anglo Haskell this year?
17:29:15 <dolio> edwardk: I found an Uustalu and Vene paper where they use coextend. Take that!
17:29:34 <edwardk> dolio: heh
17:29:47 <dolio> Unfortunately, they then go on to call it 'cobind' in their haskell class. :)
17:29:53 <yebyen> anyone want to explain the reason function types are written how they are?  with the -> arrows
17:29:55 * yebyen is a newbie
17:29:58 <edwardk> =)
17:30:24 <Twey> yebyen: Functions only take one argument
17:30:37 <Cale> yebyen: and -> associates to the right
17:30:37 <allbery_b> currying and partial application.  a function of 2 arguments can be thought of as a function of one argument returning a function of one argument
17:30:54 <Cale> A -> B -> C means A -> (B -> C)
17:31:01 <Twey> foo :: a -> b -> a means foo :: a -> (b -> a); i.e. a function that takes one a and returns a function that takes one b and returns an a
17:31:08 <vixey> yebyen: it's matching the notation we use in maths when you say  f : RxR -> R
17:31:09 <Cale> and  f x y  means (f x) y
17:31:21 <yebyen> sweet
17:32:05 <yebyen> i know about currying from a ruby book
17:32:11 <yebyen> that makes sense
17:32:13 <Cale> > map (+1) [1..10]
17:32:14 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
17:32:20 <yebyen> no it was probably grails
17:32:26 <Cale> > let f = map (+1) in f [1..10]
17:32:27 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
17:33:40 <slava> does ghc compile 'map (+1)' into a tight loop in registers?
17:34:04 <lispy> slava: Well, what is the type of (+1)?
17:34:26 <lispy> :t (+1)
17:34:26 <lambdabot> forall a. (Num a) => a -> a
17:34:56 <lispy> slava: I think the generality of that type would prevent a tight loop in registers, but then I'm not an expert here.
17:35:00 <Cale> You'd have to check, I suppose.
17:35:01 <matthew-_> lispy: yeah, but if it knows that it's actually on [Int] in this particular case, then would it?
17:35:39 <lispy> I bet you'd need Int# or some other magic internal type
17:35:40 <dolio> It'd be highly dependent on where the list comes from and where it goes, too.
17:35:45 <matthew-_> aren't there {-# SPECIALIZE #-} pragmas for this sort of stuff - or is that more general?
17:37:42 <dolio> I probably wouldn't bet on it unless you're using Data.List.Stream.
17:38:19 <Cale> actually, it does appear to eliminate the map here...
17:39:29 <dolio> map (+1) [1..10] is foldr/build fusible.
17:39:39 <Cale> right
17:39:53 <Cale> So it'll compile it directly into some kind of loop
17:40:07 <humasect> Cale: how do you see what ghc is doing with it ?
17:40:16 <Cale> humasect: -ddump-simpl
17:40:21 <Cale> and friends
17:40:23 <humasect> ah interesting, thanks~
17:40:30 <dolio> ghc-core is a pretty nice little tool.
17:40:34 <Cale> -ddump-asm will dump the assembly
17:40:43 <Cale> But I suck too much at reading that.
17:41:11 <humasect> hm=)
17:41:19 <Cale> maybe I should try the C--
17:41:25 <Cale> -ddump-cmm
17:41:37 <dolio> Man, Xah Lee is really posting a lot lately.
17:41:53 <Cale> dolio: Is he as much of a troll as ever?
17:42:05 <dolio> Yeah, I'd say so.
17:42:17 <dolio> Apparently he recently found out emacs lisp sucks.
17:42:22 <dolio> From the looks of it.
17:42:42 <dolio> And he's informing all the lisp people of that fact.
17:43:07 <dolio> And the c.l.functional people, for good measure.
17:43:40 <matthew-_> how helpful
17:43:51 <dolio> @quote xahlee
17:43:52 <lambdabot> xahlee says: note to readers: i'm not just interested in functional programing, i'm the world's top expert
17:44:09 <chrisdone> legend
17:44:13 <lament> haha
17:44:22 <lament> @quote xahlee
17:44:22 <lambdabot> xahlee says: The Haskell Logo is the perfection of logos
17:44:34 <lament> indeed.
17:44:46 <chrisdone> coming from an expert in logos
17:45:29 <vixey> don't say that about emacs lisp!
17:45:30 <vixey> :(
17:45:49 <vixey> the finest of lisps..
17:45:58 <lament> @quote xahlee
17:45:58 <lambdabot> xahlee says: note to readers: i'm not just interested in functional programing, i'm the world's top expert
17:46:42 <erikc> bold
17:46:57 <Cale> vixey: ew, dynamic scope
17:47:09 <Shiruka> haha, it's not too long ago when I first read that one :-)
17:47:55 <Shiruka> went quick from "hmmh? sounds semi-interesting, what does this guy have to say?" to "who does this bozo think he is?" :-P
17:49:02 <chrisdone> bo zo is lojban for "pink hair"
17:49:18 <Twey> Hahahaha
17:49:22 <Cale> I like Xah Lee when he's talking about geometry, but not so much when he's talking about most other things.
17:50:42 <dolio> He thinks he's the guy that was trolling comp.lang.lisp when Jon Harrop was still writting OCaml for Scientists. :)
17:55:04 <Cale> JDH isn't nearly as bad as JSH at least :)
17:55:19 <dolio> @remember xahlee I must say, sometimes i lookup to your courage in frequent cross posting
17:55:20 <lambdabot> Done.
17:56:01 <dolio> JSH?
17:56:38 <Cale> A troll on the math newsgroups who for all I know might still be trolling. He kept at it for at least 4 years.
17:56:53 <dolio> Oh. Well, the math newsgroups are a mess.
17:57:20 <matthew-_> s/the math //
17:57:31 <dolio> I think there's more "set theory is a religion!" traffic than actual content.
17:58:27 <Shiruka> JDH?
17:58:46 <Shiruka> harrop maybe? (no idea of his middle name)
17:58:51 <Cale> Shiruka: Yes.
17:59:21 <Shiruka> I was recently looking at c.l.lisp archives
17:59:34 <Shiruka> was fun to read some of the threads where harrop posted
17:59:37 <Cale> Shiruka: He seems intent on promoting functional languages, but it's like he's trying to alienate the functional programming community as much as possible.
18:00:11 <Cale> (at the same time)
18:00:28 <Shiruka> to me it seems like he thinks ocaml is the best thing since sliced bread and evangelizes it accordingly
18:00:54 <dolio> Not anymore. F# is the new savior of manking.
18:01:06 <Shiruka> oh, lol
18:01:10 <dolio> Mankind, even.
18:01:11 <Shiruka> ocaml I could see, but F#? :-)
18:01:56 <dolio> F# has concurrent garbage collection, without which you're screwed or something.
18:02:01 <gwern> well, I thought jdh had said that he thinks the best way to promote hisself/business and o'caml/f# is by attacking other FP langs
18:02:03 <Shiruka> I seem to recall someone saying that the F# developers were lamenting that the .NET platform devs wouldn't understand their needs for GC
18:02:04 <dolio> And rich people working on it.
18:02:17 <gwern> Shiruka: I've heard that F# is just ocam'l on .net
18:02:34 <gwern> also, F# gets you cuddly with the borg. the evil empire is good to its friends
18:02:43 <vixey> F# looks horrible compared to ocaml
18:03:00 <Shiruka> something like "F# devs: hey! we need to allocate lots of small objects, and it's too slow! .NET devs: if you allocate too many small objects, it's a bug in your code, because we only cater to common allocation patterns in C#"
18:03:01 <dolio> F# does have first class patterns or something like them, which is nice.
18:06:10 <erikc> F#'s biggest selling point is clean .net interoperation
18:07:27 <Shiruka> but mono isn't exactly a speed demon, and that's what you have to use if you want any portability..
18:09:03 <Shiruka> ocaml isn't too bad though
18:09:29 <vixey> damn
18:09:35 <vixey> I don't understand the GHC build process
18:09:50 <vixey> do you just read the makefiles?
18:10:00 <erikc> yea, but if you work in a microsoft shop doing web/database stuff, f# is a godsend, so much more terse than c#
18:10:23 <vixey> I wouldn't call it a godsend, is it really so hard to write your own language?
18:10:48 <Shiruka> getting the permission to do that would be the hard part..
18:10:59 <erikc> its not hard, but your boss doesnt like it much
18:11:10 <erikc> especially if he is not a language guy
18:11:14 <gwern> hm. this is an interesting problem., how does one get access to Data.Array.IO.Internals?
18:12:35 <bjrn> gwern: hehe that sounds like a "famous last word"
18:12:49 <dolio> Is it not exposed or something?
18:13:14 <Twey> Hahaha
18:13:19 <gwern> bjrn: it does, doesn't it? 'hm, this is an interesting device. How does one get access to the core?'
18:14:11 <gwern> is haskell.org down?
18:14:15 <Twey> *bzzzzzrrrrrrt*
18:16:03 <vixey> what does this mean? Package contains no library to register
18:16:38 <erikc> from installing a cabal package?
18:16:50 <vixey> trying to build ghc
18:16:55 <erikc> oh...no idea
18:17:16 <erikc> linux or windows?
18:18:01 * vixey discovers http://hackage.haskell.org/trac/ghc/wiki/Building
18:18:02 <lambdabot> Title: Building - GHC - Trac
18:18:25 <O_4> Hmm, how do I get a Ptr to arbitrary indices of a Data.Array?
18:19:59 <Steve|laptop> Is http://wwwhaskell.org down?
18:20:06 <Twey> haskell.org is down, yes
18:20:16 <Steve|laptop> Weak.
18:20:30 <Twey> Why is it down so much, folks?
18:21:04 <gwern> Twey: because you touch yourself at night
18:21:56 <Twey> No
18:22:01 <Twey> The kittens already suffered for tha
18:22:01 <Twey> t
18:22:09 <Steve|laptop> That would keep me from being "up."
18:22:20 <gwern> 'Most likely to be ambiguously or basely accused of patent violations: WINE' <-- lol
18:22:28 <Twey> Hahaha
18:22:41 <gwern> well, it's hard to keep it up
18:22:50 <gwern> you finish, and then it goes right back down
18:23:10 <gwern> it would take a real man to keep the servers up for a long time even when doing nothing
18:23:40 <adekoba> is there any mirror of the main GHC library documentation?
18:23:49 <adekoba> (damn you, haskell.org)
18:24:00 <dancor> how do i figure out what package has Graphics.Rendering.Cairo
18:24:05 <sioraiocht> what's wrong with haskell.org?
18:24:06 <sioraiocht> =(
18:24:39 <gwern> adekoba: I always install the distro package for docs just in case I am offline. or it is
18:24:44 <jeffz> sioraiocht: too popular?
18:24:54 <sioraiocht> :(
18:25:30 <chrisdone> haskell.org “blarg i am ded”
18:26:48 <chrisdone> there's always that zvon.org
18:27:08 <chrisdone> with pretty poor documentation, but it's often the first result on google :\
18:27:25 <adekoba> gwern: doesn't look like there is one for archlinux.
18:27:40 <chrisdone> http://www.google.com/search?hl=en&q=haskell+maybe&btnG=Google+Search
18:27:41 <lambdabot> Title: haskell maybe - Google Search, http://tinyurl.com/5v4dra
18:28:26 <erikc> is there a standard base (or hackage) library with a type for Win32 GUIDs
18:28:26 <vixey> if you just comment out everything that is a problem does that count as fixing it?
18:29:29 <chrisdone> erikc: there is one on hackage, I believe
18:29:52 <adekoba> vixey: if it's good enough for debian, it's good enough for me
18:30:56 <gwern> adekoba: arch is src based, so I guess there'd be some option to enable/disable?
18:31:51 <TSC> http://www.cmears.id.au/haskell-doc/libraries/
18:31:52 <lambdabot> Title: Haskell Hierarchical Libraries
18:32:09 <adekoba> thank you!
18:32:15 * adekoba  smooches TSC
18:32:27 <TSC> You're welcome
18:33:52 <vixey> what's this /utils/installPackage/install-inplace thing?
18:35:31 <chrisdone> "chris, you have to fix these{- "   "problem solved."
18:36:11 <chrisdone> yay haskell.org is back up
18:36:28 <chrisdone> oh, no. it's not anymore. mmk
18:37:00 <Twey> Overloaded?
18:38:43 <chrisdone> must be apache
18:39:21 <chrisdone> mohws would never do this
18:40:32 <Twey> Heh
18:40:45 <Twey> Does haskell.org even use Apache?
18:41:33 <chrisdone> I'd expect so for some reason. lighttpd would be too awesome
18:42:16 <chrisdone> yeah, my web cache shows
18:42:17 <chrisdone> Apache/2.2.3 (Debian) mod_python/3.2.10 Python/2.4.4 mod_perl/2.0.2 Perl/v5.8.8 Server at code.haskell.org Port 80
18:47:58 <vixey> -- This module isn't called \"Simple\" because it's simple.  Far from -- it.  It's called \"Simple\" because it does complicated things to -- simple software.
18:48:16 * Twey laughs.
18:48:17 <Twey> What
18:48:31 <Twey> What 'complicated things' does it do to 'simple software'?
18:48:38 <Twey> chrisdone: Huh
18:48:38 <Saizan> compiles.
18:48:50 * Twey laughs.
18:49:41 <chrisdone> Twey: HUH!?!!?‽‽؟
18:50:08 <Saizan> all of Distribution/Simple is what implements runhaskell Setup ...
18:51:43 <Shiruka> and I suppose evil mangler isn't called the evil mangler because it is evil, but because perl which it is written in is :-)
18:52:04 <O_4> Could someone see if they know why I'm having this problem? http://hpaste.org/9256
18:52:09 <chrisdone> and I suppose Perl isn't called evil because it's evil, but because Larry Wall is
18:52:37 <Botje> @quote wall
18:52:38 <lambdabot> dons says: The "I'm swallowing TaPL smiley" :[]
18:52:38 <Shiruka> and I suppose Larry Wall isn't called evil because he's evil, but because mankind is
18:52:49 <vixey> haha
18:52:59 <Botje> @quote larry
18:53:00 <lambdabot> newsham says: do'nt confuse larry wall's drug induced vision of computing with the state of reality
18:53:03 <Botje> grrr :(
18:53:09 <Botje> \bot has some quotes from larry wall
18:53:14 * Botje smacks lambdabot 
18:53:17 <Botje> cooperate!
18:53:57 <chrisdone> Botje: pretty sure Cale is working on a telepathy plugin for it atm
18:54:14 <Botje> excellent.
18:54:22 <chessguy> jedi mind fix?
18:54:32 <Botje> how is development on LaserT (Shark a) going ?
18:54:56 <chrisdone> you mean I have frickin sharks with frickin lasers on their heads‽
18:55:03 <Botje> when it's done :)
18:55:14 <Botje> and then we can start working on LaserT (Cat a)
18:55:20 <Botje> and THEN we shall RULE THE WORLD!
18:55:26 <bd_> data MetaLaser = LaserT MetaLaser deriving (Fish)
18:55:33 <bd_> er
18:55:36 <bd_> + constructor
18:55:39 <chrisdone> LongT (Cat a)
18:56:16 <bd_> @check \cat -> long (cat :: LongT (Cat ()))
18:56:18 <lambdabot>   Not in scope: type constructor or class `Cat'
18:56:24 <Botje> :p
18:56:53 <chrisdone> @cthulhu
18:56:53 <lambdabot> Unknown command, try @list
18:56:58 <chrisdone> @quote cthulhu
18:56:59 <lambdabot> No quotes match. Just what do you think you're doing Dave?
18:57:09 <chrisdone> what's this nonsense. no cthulhu quotes?
18:57:23 <Botje> oh
18:57:29 <Botje> we renamed cthulhu to unsafePerformIO
18:57:38 <chrisdone> hehe
18:57:41 <Botje> since they do approximately the same thing
18:58:14 <chrisdone> peyton `simon` jones may have done it to the web server :/?
18:59:23 <chrisdone> does @let work for anyone?
19:00:14 <humasect> dons: ghc-asm is dying with binary-0.4.2
19:00:42 <Saizan> O_4: you're another victim of the monomorphism restriction, add a type signature to vertexArray
19:00:59 <chrisdone> @let peyton _ _ = "awesome"
19:00:59 <lambdabot> Defined.
19:01:07 <chrisdone> > "simon" `peyton` "jones"
19:01:09 <lambdabot>  "awesome"
19:01:13 <chrisdone> oh, so now it works
19:01:16 <Botje> :)
19:01:20 <chrisdone> last night it just kept Terminate'ing
19:02:23 <chrisdone> mmkay so I seem to have an utter dependancy on haskell.org to be productive
19:02:51 <Shiruka> whoa @ random reddit comment
19:03:04 <chrisdone> ‽
19:03:09 <Shiruka> "searching or sorting data is about the slowest thing a computer can do"
19:03:25 <Cale> uh...
19:03:26 <Cale> heh
19:03:26 <Shiruka> I think someone has a _very_ limited vision of what computers can do..
19:03:47 <O_4> Saizan: what type should it be though?  I would have guessed "MArray a Int Float", but that isn't right.
19:03:48 <Cale> O(n log n) is it, man
19:03:54 <Cale> Nothing is more complex than that.
19:04:01 <Shiruka> :->
19:04:04 <chrisdone> “BASIC course in the 70s considered harmful”
19:04:53 <Shiruka> this was about web search engines, but still.. couldn't help laughing
19:05:29 <mrd> Cale: well clearly he not only possesses a poly-time algorithm for NP-hard problems, but also for undecidable
19:05:30 <Saizan> O_4: the m is the Monad, not the element type
19:06:02 <Saizan> O_4: so it's something like Marray a Float m => m (a Int Float)
19:06:37 <vixey> :/
19:06:44 <vixey> you know that reddit site is BS
19:06:44 <vixey> http://www.nihilogic.dk/labs/20_lines_javascript/july08_super_mario/20linesofmario.js
19:06:46 <lambdabot> http://tinyurl.com/5b35fj
19:06:53 <vixey> the people on it can't count ...
19:07:07 <Saizan> O_4: you can also use the NoMonomorphismRestriction language extension and then ghci will infer the type for you
19:07:25 <Shiruka> vixey: but you have to get your entertainment somewhere
19:07:59 <Cale> It would be so funny if P = NP, but the best time you could get for most things was something like O(n^e^e^e^e^e)
19:08:02 <chrisdone> hacker news has some polite discussion sometimes
19:09:35 <O_4> Saizan: I get "Non type-variable argument in the constraint: MArray a Float m" now.  Isn't it MArray (a i e) though?
19:09:38 <chrisdone> reddit = trolls + “short and sweet” comments in the hope of upmodding + pun threads
19:10:01 <O_4> I really don't understand the type of this thing :-/
19:10:01 <Cale> chrisdone obviously hasn't seen my reddit posts ;)
19:10:14 <Shiruka> Cale: it'll be proved after 500 years that P != NP.. and then after next 500 someone will come up with a O(n^2) algorithm for NP-complete problems and the resulting bug-hunt of the formally verified proof results in ZFC being proved contradictory. </shirukadamus>
19:10:23 <Saizan> O_4: no, MArray is a MultiParameter typeclass, and it takes 3 arguments
19:10:23 <dolio> You're vastly outnumbered, though. :)
19:10:45 <vixey> ZFC being proved contradictory?
19:10:51 <vixey> I thought ZFC was consistent
19:11:03 <Shiruka> ... you can't prove anything of that complexity consistent
19:11:05 <Saizan> O_4: and yes, that type signature requires an extension too
19:11:11 <O_4> Bloody hell
19:11:16 <Shiruka> ref. gödel
19:11:22 <O_4> I don't get these type signatures at all :-/
19:11:41 <Shiruka> but IIRC ZFC has been proven consistent given that ZF is
19:11:45 <vixey> I don't understand
19:11:57 * humasect shoudl have downloaded the html or pdf
19:12:00 <Cale> Shiruka: yeah
19:12:03 <vixey> I've never tried to read through a ZFC consistency proof
19:12:24 <O_4> Saizan: but yeah, passing the required flag gets rid of the warning.
19:12:27 <Cale> O_4: which type signature?
19:12:30 <chrisdone> vixey: 20 lines of javascript, in 200 columns
19:12:49 <O_4> Cale: this: "MArray a Float m => m (a Int Float)"
19:13:11 <O_4> I just don't understand how these MArrays work.
19:13:16 <Cale> okay
19:13:41 <erikc> sigh, relational algebra is so awesome, <3
19:13:58 <O_4> So, on http://cvs.haskell.org/Hugs/pages/libraries/base/Data-Array-MArray.html#1
19:13:59 <lambdabot> Title: Data.Array.MArray, http://tinyurl.com/6pj6fj
19:14:42 <Cale> The constraint  MArray a e m means that  a  is a type of mutable array capable of holding elements of type e, whose operations are in the monad m.
19:14:48 <O_4> The "a Float m" is the array type constructor?
19:15:00 <O_4> Hmm.
19:15:00 <Saizan> no
19:15:05 <bjrn> Is there an international or softcover version of TAPL?
19:15:27 <Cale> O_4: MArray is being applied to those 3 types/type variables
19:15:39 <Saizan> MArray is a 3-ary relation
19:15:57 <erikc> wrote a relational algebra in ruby today to analyze malloc/free logs, and it can give answers that the 'ram visualizer' a guy spent a month on in c# cant
19:16:18 <erikc> unfortunately, my feedback was 'its not very pretty'
19:16:25 <Cale> MArray a Float m => m (a Int Float) -- this is a computation in some monad m producing an array from Int to Float of some array type a
19:16:44 <O_4> Crikey
19:16:45 <vixey> erikc: lol
19:16:48 <Cale> For example, maybe m is IO
19:16:53 <Cale> and a is IOUArray
19:17:10 <Cale> In which case it would be  IO (IOUArray Int Float)
19:18:08 <dons> so, here's a challenge.
19:18:12 <dons> you guys know haskell, right?
19:18:25 <dons> what percent of lines of code are devoted to type declarations, in a typical project.
19:18:27 <O_4> Hopefully this will begin to make more sense as I get a bit more comfortable with Monads and Haskell in general.
19:18:31 <dons> quick. without looking.
19:18:35 <Shiruka> vixey: ZFC can be proven consistent given ZFC+something (where something was an inaccessible cardinal or some such), but that doesn't make it impossible for ZFC to be inconsistent :-)
19:18:41 <vixey> 2%
19:18:48 <Saizan> O_4: in MArray a e m, a is not a complete type, but a type constructor that in fact is applied to 'i' and 'e' in the types of the class methods
19:18:49 * bd_ guesses... 10-20%?
19:19:03 <jeffz> 40%
19:19:05 <vixey> infact 1/2%
19:19:13 <Shiruka> 10%?
19:19:15 <bd_> wait, does this include type signatures and/or data declarations?
19:19:15 <dons> so my initial survey of "commercial" haskell, came up with 6% and 8%.
19:19:20 <dons> data and types.
19:19:25 <dons> anything with a ::
19:19:31 <dons> i'm doing a bigger survey now...
19:19:32 <bd_> data .... = ... doesn't have a ::
19:19:35 <humasect> in a typical project .. are they using types enough ?
19:19:38 <dons> i suspect open source will have a lower percent.
19:19:38 <bd_> unless it's a GADT
19:19:46 <dons> humasect: that's in serious haskell, using lots of types.
19:20:05 <vixey> jeffz: 40% ???
19:20:08 <humasect> dons: ah, i see. i look at my code here and there are types almost each line. maybe 50%
19:20:16 <vixey> wtf are you doing
19:20:16 <dons> intereresting.
19:20:23 <chrisdone> writing short functions?
19:20:24 <dons> vixey: one line hylomorphisms?
19:20:27 <ddarius> dons: I would actually suspect it to be higher or comparable.
19:20:34 <humasect> there is not so much "::" use
19:20:35 <dons> sessions-types is probably 70-90% types...
19:20:57 <Shiruka> would be nicer to count # of characters devoted to types
19:21:04 <dons> so over all the source on my box, i've 132,466 lines of types.
19:21:11 <jeffz> vixey: I thought about the worst case scenario, though, looking at my largest project, I only have about 3%
19:21:17 <dons> and 1641532 lines of code.
19:21:17 <chrisdone> dons: of how many lines?
19:21:25 <dons> > 132466 / 1641532 * 100
19:21:27 <lambdabot>  8.069656881498503
19:21:30 <dons> so huh.
19:21:35 <dons> spot on with the small projects.
19:21:43 <sjanssen> dons: what do you define as a "type" line?
19:21:48 <Cale> I think that's about right.
19:22:04 <bwr> haskell.org sooooo slow. is there a backup of the library ref somewhere?
19:22:16 <dons> sjanssen: has a ::
19:22:27 <humasect> what is the quote, most other languages can be made by just using type system of haskell /
19:22:49 <sjanssen> @quote augustss
19:22:49 <lambdabot> augustss says: Haskell is about making sense, not just providing an operation because it's possible. We leave that to other languages.
19:22:52 <sjanssen> @quote augustss
19:22:53 <lambdabot> augustss says: Given that strength of the Haskell type system it wouldn't be that hard to write a compiler from some language into a Haskell type.
19:22:59 <vixey> humasect: what do you mean?
19:23:03 <sjanssen> humasect: that one?
19:23:25 <dons> it's cool that there's 1.6M lines of haskell just sitting in open repos on my laptop :)
19:23:50 <humasect> sjanssen: yes it is just like that=)
19:24:35 * vixey does a huge long recompile just to get more error messages.........
19:25:23 <dons> so, i'll wager, type declarations make up 8% of an average haskell system.
19:25:29 <bwr> so is there an alternative copy of the haskell library reference somewhere?
19:25:33 <sjanssen> dons: a more interesting measurement would be how many of those type declarations are required
19:25:43 <dons> very very few, i'd think.
19:25:53 <sjanssen> dons: also, are you stripping comments in your grand total?
19:25:55 <dons> they're just documentation. except for some careful rank-N and friends.
19:25:56 <ddarius> I agree with dons.  Probably close to 0.
19:26:13 <sjanssen> dons, ddarius: don't forget the MR
19:26:14 * vixey only puts in required ones, or ones that are really instructive
19:26:22 <vixey> which is why I have lowel than usual
19:26:32 <sjanssen> but yes, I'd assume it is a small fraction
19:26:34 <Shiruka> I don't see why it would be terribly interesting to count what's required
19:26:45 <jeffz> bwr, it's part of the source distribution or the ghc6-doc package on Ubuntu
19:26:49 <Shiruka> after all, what matters in the real world is actual code
19:26:51 <ddarius> sjanssen: I virtually never think of the MR when adding types.
19:26:53 <dons> MR, phantom types
19:26:57 <bwr> jeffz: thanks
19:27:01 <ddarius> Also, I'm more likely to turn off the MR rather than add more than a few "extra" types to deal with it.
19:27:02 <dons> lots of type dispatch stuff. storables
19:27:07 <dons> get :: Get Word8
19:27:10 <dons> get :: Get Word16
19:27:13 <sjanssen> Shiruka: a type signature that isn't required is more like documentation than code
19:27:13 <bwr> jeffz: assuming i had that installed, do you know where i would find it?
19:27:23 <jeffz> bwr, /usr/share/doc/ghc6-doc/html/
19:27:26 <bwr> thanks
19:27:36 <chrisdone> I put in type decs for haddock
19:27:49 <Shiruka> sjanssen: but they all double as documentation :-)
19:28:03 <Shiruka> maybe I miss the purpose of counting them..
19:28:15 <dons> right. *optional* type declarations really are just documentation.
19:28:22 <dons> they're not required, but its a good idea to provide them.
19:28:31 <sjanssen> dons: yes, were you making a point about counting the signatures?
19:28:33 <dons> so perhaps we should point that out next time.
19:28:44 <dons> sjanssen: no, just "::" in general
19:28:45 <ddarius> You could get an idea for how much phantom types are used by finding out how many types are specializations of their inferred types.
19:28:56 <ddarius> Albeit numeric types will muddy this.
19:29:11 <dons> i wonder if there's a paper in just analysing all the haskell source out there, and drawing some conclusions.
19:29:13 <chrisdone> also... types make searching code very nice...
19:29:20 <dons> how many types, how many modules. et c.
19:29:32 <dons> sjanssen: seen this http://galois.com/~dons/tmp/xmonad.svg ?
19:29:33 <chrisdone> like, navigating a document based on the type of things, is nice
19:29:49 <dons> sjanssen: auto-extracted module graph from graphmod
19:30:14 <chrisdone> nice
19:30:42 <blbrown> dons!!!
19:30:55 <dons> blbrown: hey!
19:31:29 <blbrown> dons: I don't want to bother you, just saying hello from reddit :)
19:31:36 <dons> :)
19:31:38 <dons> i guessed.
19:32:05 <vixey> do you run reddit?
19:32:20 <dons> with an army of zombie lambdabots, sure.
19:32:43 <dons> hmm, dot is struggling on the ghc graph.
19:33:06 <chrisdone> http://haacked.com/archive/2007/08/21/i-knew-how-to-validate-an-email-address-until-i.aspx <-- heh
19:33:28 <dons> ?users
19:33:39 <dons> Cale, oh, lambdabot's awol?
19:33:51 <newsham> haskell.org down?
19:34:06 <dons> hmm, second time today. something's up.
19:34:22 <Cale> heh, lambdabot thought it was still connected
19:34:33 <dons> that, and we had 507 people in #haskell today. curious..
19:34:52 <vixey> woo!
19:35:13 <vixey> I wonder how many people in the world know some haskell
19:35:30 <dancor> less than know some esperanto
19:35:38 <dons> so, unsw turned out 500 haskelers a year from 1997 to 2005. it was less for a few years either side.
19:35:43 <Cale> Can someone explain to me how my lambdabot process which was running in a screen has somehow become ejected from screen?
19:35:57 <dons> so unsw alone must have trained 5k people in some haskell.
19:36:15 <vixey> cool
19:36:18 <chrisdone> cale: detached from screen? is the process still alive?
19:36:20 <dancor> @users
19:36:22 <Cale> chrisdone: yes
19:36:27 <Cale> chrisdone: but screen isn't.
19:37:05 <sjanssen> perhaps the OOM killer ate it?
19:37:06 <chrisdone> cale: oh dear. sounds like unstable screen
19:38:04 <chrisdone> screen has crashed on me before when using emacs with big buffers, fwiw...
19:38:08 <Cale> Random junk happens to my processes on code.h.o that I just don't understand. Somehow lambdabot creates a lot of runplugs zombies as well.
19:38:57 <Shiruka> hopefully this haskell.org instability isn't going to become a habit..
19:39:09 * chessguy wonders idly if figuring out how many haskellers there are in the world is like figuring out how many piano tuners are in the world
19:39:13 <Shiruka> where will all the aspiring newbies go?
19:39:20 <dons> i imagine somethiing funny is happening. i.e. DoS or similar
19:40:30 <Shiruka> maybe chessguy released a worm that tries to count the # of haskell programmers in the world and it found too much haskell content in haskell.org and went wild there
19:40:41 <jeffz> dons, could be... there was a botnet in here yesterday
19:40:42 <dons> heh
19:40:44 <dons> hmm
19:40:47 <dons> not good, jeffz
19:41:05 <chessguy> who, little old me?
19:41:10 * chessguy looks around wide-eyed
19:41:12 <dobblego> which type-class, for which there is a Maybe instance, has a binary function that tests the first Maybe argument and if it is Just, returns it, otherwise returns the second argument?
19:41:35 <Shiruka> chessguy: case closed
19:41:37 <dons> anyone else notice SPJs photo shows up on cuil when you search for haskell?
19:41:46 <dons> http://www.cuil.com/search?q=haskell&sl=long
19:41:48 <lambdabot> Title: haskell - Cuil
19:41:52 <chessguy> @type case closed
19:41:53 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
19:41:53 <dons> made me laugh.
19:41:56 <Cale> dobblego: Monad?
19:42:08 <Cale> dobblego: Or MonadPlus, rather
19:42:17 <dobblego> Cale, I think that's the one, cheers
19:42:18 <Cale> > Nothing `mplus` Just 5
19:42:19 <lambdabot>  Just 5
19:42:23 <Cale> > Just 6 `mplus` Just 5
19:42:24 <lambdabot>  Just 6
19:42:29 <Cale> > Just 6 `mplus` Nothing
19:42:30 <lambdabot>  Just 6
19:42:34 <Cale> > Nothing `mplus` Nothing
19:42:35 <lambdabot>  Nothing
19:42:41 <dobblego> yep, thanks
19:42:48 <Nafai> dons: What I find funny is that a credit card logo shows up next to "A Gentle Introduction..."
19:43:08 <Cale> Nafai: wha?
19:43:30 <Cale> oh, on cuil?
19:43:33 <Nafai> Cale: On the cuil search page
19:43:37 <Cale> Yeah, what the heck?
19:43:42 <Nafai> Sorry, should have been more explicit
19:43:52 <dons> Nafai: heh.
19:44:07 <Shiruka> the "functional languages" category that pops up with the search doesn't show haskell :-/
19:44:27 <Cale> cuil is silly anyway
19:44:34 <Shiruka> but does show "XSL Transformations"
19:44:35 <dons> and a picture of this guy, http://www.cuilimg.com/imgsrv?i=020604:1295777140368404 shows up next to my web page.
19:44:36 <SamB_XP_> Nafai: I don't remember it talking about the credit-card transform!
19:44:38 <Shiruka> I think this is an insult
19:44:38 <dons> who is that?
19:44:50 <dons> and why does cuil think he is me??
19:44:57 <Cale> hahaha
19:45:23 <dons> and imposter
19:45:39 <ddarius> XSLT: the language of discriminating hackers
19:45:56 <Twey> Shiruka: Hahaha what
19:46:04 <Cale> at least cuil has decided that a black textbox with black text maybe isn't such a good idea after all
19:46:14 * Twey snorts.
19:46:23 <Twey> Cuil... needs work.
19:46:25 <chessguy> dons:  he could certainly be another don stewart
19:46:47 <Cale> dons: He's your long-lost brother!
19:47:04 <dons> he's come for my oil!
19:47:08 <cjs> haskell.org is down?
19:47:16 <chrisdone> cjs: seems so
19:47:27 <Steve|Office> I suppose that when I asked that an hour ago, I was hardly the first.
19:47:49 <cjs> Hm. So who here can we blame? :-)
19:48:20 <Steve|Office> I blame Cale.
19:48:40 <Cale> http://www.cuilimg.com/imgsrv?i=02090e:915343437192173 is the image it gives for the Monomorphism Restriction page on the haskellwiki
19:49:02 <Cale> Not quite sure what's going on there, but it sure looks sinister.
19:49:12 <chessguy> seems somehow appropriate :)
19:49:12 <cjs> Is this cuil?
19:49:22 <Cale> yeah
19:49:26 <cjs> I like the way it gives a visa/mastercard logo for the haskell spec.
19:49:41 <dons> i noticed next to someone else called 'don stewart' it has the cabal logo...
19:49:47 <dons> poor fellow.
19:49:47 <Cale> http://www.cuilimg.com/imgsrv?i=020c02:1556909884222574  is the one for "Re: The dreaded monomorphism restriction"
19:50:00 <dons> heh
19:50:06 <cjs> Oh dear!
19:50:42 <Trinithis> is cuil some new (and cool) seach engine?
19:51:11 <chessguy> new, yes. cool...remains to be seen
19:51:14 <cjs> It's a new and very humorous search engine.
19:51:37 <cjs> One reviewer said he'd never laughed out loud at search results, before.
19:51:50 <Shiruka> dons, but is it really that bad? you could get this image instead: http://tinyurl.com/5e9zsw
19:51:53 <Cale> http://www.cuilimg.com/imgsrv?i=020710:1448609736542696 is the picture next to the wikipedia page for Haskell.
19:51:53 <dons> that's a good thing , i suppose.
19:51:58 <cjs> Anyway, I think they've just made their reputation.
19:52:01 <dons> heh
19:52:07 <chrisdone> Shiruka: that would be awesome
19:52:16 <dons> cjs, yes, it seems like a very dangerous time.
19:52:36 <Shiruka> :-)
19:52:46 <Cale> http://www.cuilimg.com/imgsrv?i=02060f:1123154807693020 -- heh, a different search for "Wikipedia Haskell" gives this image.
19:52:47 <dons> though i have to admit, compared to some new search engines launched, i did go back on a second day for fun.
19:52:53 <Cale> (for the same page)
19:53:00 <dons> boo!
19:53:15 <Trinithis> haah "cuil" doesn't bring up itself
19:53:40 <dons> well, it does, kinda, if you use its suggestions.
19:53:43 <dons> all very strange.
19:54:26 <dons> its just so much effort to compete with google.
19:54:26 <Shiruka> http://www.cuil.com/search?q=best%20programming%20language&sl=long
19:54:27 <lambdabot> Title: best programming language - Cuil, http://tinyurl.com/6sb59v
19:54:30 <Trinithis> Who here does NOT use google (and its ilk) as their main search engine?
19:54:31 <Shiruka> first result: Logo...
19:54:33 <dons> 1000s of employees , 10 years ahead.
19:54:42 <SamB> if ilk, which ilk?
19:54:59 <Trinithis> like... gizoogle and stuff like that
19:55:03 <Cale> Heh, does anyone remember HotΒot?
19:55:13 * Twey raises a hand.
19:55:14 <SamB> Cale: sounds vaguely familiar
19:55:19 <Twey> Is that still around?
19:55:21 <dmwit> I use one of Google's lab-things.
19:55:23 <SamB> along with Lycos ... whatever that was
19:55:30 <Cale> I think it died.
19:55:37 <SamB> dmwit: what? they are making their own replacement?
19:55:47 <ddarius> I liked HotBot quite a bit.
19:55:57 <Cale> Oh, it seems to exist now.
19:56:05 <bwr> is this may be crazy but when you are doing pattern matching in a function definition, can you do say f a a b = and f a b a = where the first pattern would say that the frist two args are the same and the second pattern would say the first and the third arg are the same?
19:56:05 <dmwit> SamB: Same back-end, (mildly) new front-end.
19:56:07 <Cale> Maybe someone saw fit to bring it back.
19:56:19 <Cale> http://www.hotbot.com/
19:56:20 <lambdabot> Title: Homepage HotBot Web Search
19:56:20 <Shiruka> ... cuil doesn't find any results for functional programming :-O
19:56:23 <dmwit> Just a bit of AJAX on top of their usual search, really.
19:56:25 <SamB> Cale: yes but what search engine does it use?
19:56:47 <Cale> SamB: ah, Lycos, I remember something about it being absorbed by Lycos.
19:57:03 <Trinithis> bwr: can you paste your code?
19:57:06 <Trinithis> in hpaste
19:57:25 <SamB> I remember those names from my larval stage of internet usage
19:57:47 <bwr> Trinithis: it was more a speculative question, but i can paste my code.. it is a very big mess currently though
19:57:47 <ddarius> bwr: No.
19:57:52 <dons> bwr, can't do that, unfortunately.
19:57:58 <bwr> thanks
19:58:02 <dons> no unification in haskell.
19:58:29 <Trinithis> Is unifications logic programming stuff? (like prolog?)
19:58:31 <ddarius> It went downhill when it was acquired by Lycos.
19:58:58 <ddarius> dons: Doing that wouldn't require unification.  I even think Miranda did that.
19:59:36 <cjs> So, any news on what's up with haskell.org? Dons, I though you guys were hosting it.
19:59:49 <Shiruka> lycos.. I think I heard that name once, when the dinosaurs roamed the interwebs
19:59:49 <dons> cjs, no. yale hosts haskell.org
19:59:53 <dons> galois hosts hackage.
19:59:54 <cjs> We really need to get some mirroring going on it one day.
19:59:57 <cjs> Ah.
20:00:20 <dons> ddarius: doesn't erlang do something like that too, actually?
20:00:24 <cjs> A mirror should be pretty easy if we make the wiki non-editable.
20:00:35 <dons> f a a b -> f a1 a2 a3 | a1 == a2 = ...
20:00:47 <cjs> Anyway, it's now 11 p.m. over at Yale, so it might be out for me all day.
20:00:56 <SamB> maybe we should get MSR to host something ;-)
20:01:31 <erikc> is the curry variant of haskell dead at this point?
20:01:40 <erikc> (the functional logic language)
20:01:47 <ddarius> Curry isn't a variant of Haskell.
20:01:50 <vixey> what does it mean to be dead?
20:01:59 <erikc> no momentum
20:02:03 <erikc> no further work
20:02:47 <Quylui> no more having to live in this indecent, insensitive world
20:03:53 <Shiruka> dead = stable
20:04:12 <Steve|Office> Quylui: Sounds like Floyd lyrics.
20:05:53 <chrisdone> Steve|Office: good idea, I was wondering what music to listen to
20:06:14 <Steve|Office> It is usually a good choice.
20:06:28 <cjs> So what other haskell.org stuff is there? Haskell.org is basically just a big wiki, right? Hackage is the packages. Is all the trac stuff on haskell.org as well? Who's hosting the mailing lists?
20:07:04 <Quylui> chrisdone, Beck.
20:07:43 <Quylui> cjs, you're blowing my mind, dude
20:07:55 <cjs> Hmm?
20:08:27 <Quylui> so many questions in one space
20:08:58 <dons> cjs, so, the servers: code.haskell.org, darcs.haskell.org, www.haskell.org
20:09:23 <dons> code hosts source, darcs hosts hackage, trac, ghc wiki. www hosts the main wiki and mailing list.
20:09:28 <chrisdone> lambdabot is from nun.haskell.org, apparently :P
20:09:57 <Shiruka> quy, the reason is, of course, that haskell programmers are used to write information-dense text
20:10:16 <Shiruka> *writing, even
20:10:28 <Quylui> you guys = awesome
20:11:10 <ddarius> Do questions count as information?
20:11:37 <Quylui> i would love to learn to be as proficient as the people here at programming/coding, but being 18 and a physics major doesn't necessarily help my cause.
20:11:43 <Shiruka> if you want, add a negative sign to the information
20:11:44 <vixey> ugh
20:11:45 <cjs> A question is just a request to evaluate a definition. It's still code. :-)
20:11:52 <vixey> this GHC build system is ridiculously complex
20:11:54 <Quylui> so i'm lurking and listening o_o
20:11:58 <vixey> can't they just use --make ?
20:12:14 <Shiruka> every time you get asked something, your knowledge diminishes.. that's why many old-timers are so grumpy when newbies ask questions
20:12:39 <chrisdone> answering questions helps my understanding, I find
20:12:56 <chrisdone> how can your knowledge diminish that way?
20:13:16 <Quylui> question-induced neurodegenesis, i presume
20:13:17 <ddarius> Being 18 is a benefit not a problem.
20:13:25 <Shiruka> don't wreck my perfect mathematical model! :-O
20:13:35 <Shiruka> it has beautiful symmetry and all
20:14:06 <Shiruka> but yeah, teaching does tend to clarify you things.. that's why there are so many monad tutorials ;-)
20:14:31 <Quylui> dude, i'm still trying to figure out the basics
20:14:31 <cjs> Heh. Even I wrote a monad tutorial. :-)
20:14:49 <Quylui> the math is easy, but the orientation and organization is trippin me out
20:17:12 <Quylui> how old are you guys
20:17:51 <Quylui> just... to satisfy my curiosity
20:18:02 <Quylui> you can submit your answers in haskell-format
20:18:05 <Quylui> >.>
20:18:08 <chrisdone> n-n-n-n-nineteen
20:18:25 <erikc> 28
20:18:28 * shepheb turned 21 a few weeks ago
20:18:45 <Saizan> i think it would be much easier to understand monads if tutorial started with explaining the type system, especially typeclasses, instead most of them introduce IO before you can make sense of type signatures..
20:18:58 <vixey> fus
20:19:00 <vixey> yes*
20:19:08 * ddarius is about to turn 24...
20:19:14 <vixey> basically a haskell tutorial
20:19:19 <vixey> not a monad tutorial
20:19:22 <roconnor> 30
20:19:23 <bwr> sum [x+1|x<-[1..8],x`mod`2==0]
20:19:46 * Quylui 's head 'asplodes
20:20:00 * chrisdone ass-plodes
20:20:14 <Quylui> word
20:20:28 * Shiruka is a contemporary of Charles Babbage
20:20:49 <dons> ddarius: i don't think that is true, is it...
20:21:52 <ddarius> dons: That I'm about to turn 24?
20:21:58 <Shiruka> these young people have it too easy, when I was young all we had was the Difference Engine, and we liked it!
20:22:04 <dons> scanl (+) 0 [1..] !! 7
20:22:15 <Quylui> haha Shiruka
20:22:19 <kfish> Saizan, totally agree
20:22:34 <ddarius> The Difference Engine is cool!
20:22:40 <chrisdone> think I should have a String kind of class that does the appropriate string operations, for String and ByteString and ByteString.Lazy?
20:22:44 <roconnor> Is the DE turning complete?
20:22:45 <chrisdone> or seperate package extensions?
20:22:51 <dons> chrisdone: what would the class look like?
20:23:02 <roconnor> Turing
20:23:25 <ddarius> So Quylui... Haskell is older than you...
20:23:40 <chrisdone> instance String a where read :: Read b => a -> b, and maybe some others
20:23:54 <dons> hmm a parsable class eh?
20:23:55 <chrisdone> I suppose ByteString has a read instance, but there may be other operations
20:24:03 <pejo> ddarius, I second dons!
20:24:47 <chrisdone> dons: I guess
20:25:30 <chrisdone> dons: see how I have this “int” function which converts from String to Int; http://chrisdone.com/validate/dist/doc/html/validate/Data-Validate.html#v%3Aint
20:25:31 <lambdabot> Title: Data.Validate, http://tinyurl.com/6cs6kz
20:25:46 <chrisdone> dons: I was thinking it would be much better to convert from a to Int where a is any kind of string
20:25:58 <chrisdone> am I forgetting a class that expresses this?
20:26:20 <cjs> Actually, wouldn't a String class just need a fromString function?
20:26:22 <roconnor> any kind of string?
20:26:38 <roconnor> Showable?
20:26:48 <chessguy> hey chrisdone  what's the point of your validate returning Maybe [Err] instead of simply [Err]?
20:26:48 <cjs> That would deal with the issue where I'm always doing (pack "foo") all over the place.
20:26:48 <chrisdone> cjs: I guess toString and fromString, but then you're kind of losing the point of them aren't you??
20:26:53 <dons> ddarius: are you in portland?
20:27:12 <cjs> The main point for me would be to be able to type "foo" instead of pack "foo" all over the place.
20:27:24 <cjs> toString I don't see a need for; what's it going to convert?
20:27:26 <chrisdone> chessguy: maybe monad stuff, I suppose. it may change to [] later on, depending on how it's used
20:27:31 <dons> cjs, oh, but thta's already done.
20:27:34 <dolio> Parsec (3) can parse from arbitrary stream types.
20:27:36 <dons> cjs: the Strinable class.
20:27:40 <dons> Stringable.
20:27:49 <dons> use -XOverloadedStrings
20:27:49 <chrisdone> there's a Stringable class!?
20:27:57 <chrisdone> @src Stringable
20:27:57 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
20:28:00 <cjs> Oh, is it? I thought I read some noises about that at one point, maybe in the GHC docs or something.
20:28:01 <chessguy> @hoogle Stringable
20:28:02 <lambdabot> No matches found
20:28:04 <dons> and it will work out if you mean String, ByteString or Lazy.ByteString based on context
20:28:13 <cjs> Is it a ghc extension?
20:28:16 <dons> google for OverloadedString
20:28:17 <dons> yeah.
20:28:28 <cjs> Ah. In 6.8?
20:28:36 <vixey> would [$do|...|] be useful?
20:28:41 <dons> yep
20:28:47 <cjs> If so, that will make all sorts of things a bit easier for me, particularly testing. I should turn it on.
20:29:11 <Trinithis> @pl genericReplicate' n = genericReplicate (max 0 n)
20:29:11 <lambdabot> genericReplicate' = genericReplicate . max 0
20:29:18 <chessguy> looks like if haskell.org were up, you could hit http://www.google.com/url?sa=t&ct=res&cd=1&url=http%3A%2F%2Fwww.haskell.org%2Fghc%2Fdocs%2Flatest%2Fhtml%2Fusers_guide%2Ftype-class-extensions.html&ei=6t-PSJSQBajeev-SzaEH&usg=AFQjCNElllcLHzerfk9dJ54u5G2aTddsAg&sig2=9pt-1Q2j-T6m0CapJp27jA
20:29:23 <chrisdone> > B.pack "test" -- does λb have bytestring?
20:29:26 <lambdabot>   Not in scope: `B.pack'
20:29:29 <chrisdone> > L.pack "test" -- does λb have bytestring?
20:29:29 <lambdabot>   Not in scope: `L.pack'
20:29:32 <chrisdone> mmk
20:29:32 <chessguy> @tiny http://www.google.com/url?sa=t&ct=res&cd=1&url=http%3A%2F%2Fwww.haskell.org%2Fghc%2Fdocs%2Flatest%2Fhtml%2Fusers_guide%2Ftype-class-extensions.html&ei=6t-PSJSQBajeev-SzaEH&usg=AFQjCNElllcLHzerfk9dJ54u5G2aTddsAg&sig2=9pt-1Q2j-T6m0CapJp27jA
20:29:33 <lambdabot> http://tinyurl.com/5ntp44
20:30:00 <dolio> > BSC.pack "test"
20:30:06 <chrisdone> chessguy: is there a cache?
20:30:10 <dolio> > BSLC.pack "test"
20:30:15 <lambdabot>  thread killed
20:30:17 <lambdabot>  Chunk "test" Empty
20:30:30 <chessguy> http://tinyurl.com/6yo6d8
20:30:30 <lambdabot> Title: 8.6. Class and instances declarations
20:30:40 <chrisdone> cheers
20:30:49 <lispy> h.o is supposed to be up
20:30:58 <chessguy> chrisdone:  look for section 8.6.4
20:30:59 <ddarius> dons: No. Texas.
20:31:01 <lispy> I saw Igloo bounce apache about 4 hours ago
20:31:11 <chessguy> lispy:  still not working for me
20:31:20 <dons> ddarius: ok. so i was about to be surprised that the was a 24 yo derek elkins in portland, or.
20:31:30 <dons> since there's on on linkedin , who doesn't sound like you :)
20:31:34 <lispy> chessguy: yeah, hmm...i'll be an uncle's monkey
20:31:39 <chessguy> lispy: and Benjamin Russel sent that message to -cafe a lot less than 4 hours ago
20:32:45 <lispy> chessguy: maybe I just can't do math
20:32:46 <lispy> 17:27 <Igloo> dons: I've restarted apache. Seems to have fixed it.
20:32:50 <lispy> ?localtime lispy
20:32:53 <lambdabot> Local time for lispy is Tue Jul 29 20:32:23 2008
20:33:03 <chessguy> so 3 hours
20:33:06 <chessguy> close enough
20:33:23 <chessguy> that email was just about half an hour ago
20:33:32 <lispy> Oh, I see what you meant
20:33:42 <lispy> Yeah, and h.o is not responding for me
20:33:58 <Shiruka> strange, apache should be pretty reliable :-|
20:33:59 <lispy> network timeout, and I'm beaverton....I can't be very far from the physical location of the server
20:34:26 <lispy> I could walk there with a USB drive and do the HTTP GET myself in less time ;)
20:35:24 <ddarius> Hmm.  I suspect the previous owner of derekelkins.com sold his domain...
20:35:46 <vixey> I can't find anything in ghc source code :/
20:35:49 <vixey> it doesn't make sense
20:38:03 <Trinithis> is there a lib function that behaves like: iterate f x `genericIndex`n
20:39:08 <dons> lispy?
20:39:17 <dons> h.o is at yale.
20:39:18 <Trinithis> @hoogle (a -> a) -> a -> Integer -> a
20:39:19 <lambdabot> No matches, try a more general search
20:39:26 <dons> lispy, you're in beaverton?
20:40:13 <chessguy> Trinithis:  sounds like (!!n) . iterate
20:40:17 <lispy> dons: ya
20:40:33 <lispy> dons: Oh, i figured h.o was in beaverton near the Galois guys
20:40:33 <dons> lispy, how long's that been the case?
20:40:33 <chessguy> @type (!!3) . iterate
20:40:34 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
20:40:40 <Trinithis> I know. Just was wondering if it was built into Data.List
20:40:43 <Trinithis> or soething
20:40:43 <lispy> dons: Approx 3 months
20:40:44 <dons> lispy, we're in downtown portland now.
20:40:49 <lispy> dons: oh!
20:40:56 <dons> you should drop by, sometime.
20:40:58 <jehk> rats, the haskell.org is still down
20:40:58 <chessguy> ...
20:41:00 <chrisdone> so sometimes I'm not sure whether I should make ALL strings, in my libraries, of one kind, like ByteString.Lazy or ByteString.Strict, or simple things like error "bad email", can just be a String, or what?
20:41:02 <dons> come play some fussbal.
20:41:03 <chessguy> what's up with LB?
20:41:13 <lispy> dons: I would like to, I'm grinding away on my masters so I can apply there ASAP :)
20:41:26 <Trinithis> grr! hoogle's down for me
20:41:27 <lispy> dons: cool
20:41:44 <lispy> dons: what part of downtown?
20:41:49 <dons> lispy, you could give a talk about darcs internals or something.
20:41:51 <chessguy> @pl \n -> (!! n) . iterate
20:41:51 <lambdabot> (. iterate) . flip (!!)
20:42:01 <chessguy> heh
20:42:18 <chessguy> @type (. iterate) . flip (!!)
20:42:19 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
20:42:27 <chessguy> @type 3
20:42:28 <lambdabot> forall t. (Num t) => t
20:42:36 <chessguy> ...
20:42:47 <lispy> dons: I could certainly give a talk about what I've learned while hacking on darcs
20:42:55 <dons> lispy: http://maps.google.com/maps?f=q&hl=en&geocode=&q=421+SW+6th+Ave.+Suite+300+Portland,+OR+97204++&sll=45.520902,-122.677588&sspn=0.008224,0.014784&ie=UTF8&ll=45.517414,-122.672825&spn=0.263176,0.473785&t=p&z=11
20:42:56 <lambdabot> Title: Google Maps, http://tinyurl.com/6fvpol
20:42:58 <lispy> dons: but, talking about the internals of darcs might still be over my head :)
20:43:27 <dons> you on the pdxfunc mailing list?
20:43:55 <lispy> dons: know, unaware of it
20:43:58 <lispy> er no
20:44:27 <dons> http://groups.google.com/group/pdxfunc
20:44:28 <lambdabot> Title: pdxfunc | Google Groups
20:45:43 <vixey> where is ghci?
20:46:24 <chessguy> vixey:  you mean where is it hosted?
20:46:51 <vixey> when you run make to compile everything, where ghci is put?
20:46:57 <chessguy> oh
20:47:11 <ddarius> She means "Where is the source code in the GHC source tree?" I suspect.
20:47:30 <vixey> I founh the GHCI Monad but I mean I want to run the ghci program without installing
20:48:08 <vixey> ./driver/ghci/ghci-inplace doesn't work
20:48:24 <allbery_b> ghc-inplace --interactive ?
20:48:45 <allbery_b> (I think ghci-inplace is magic)
20:49:13 <vixey> that didn't work, so I tried,
20:49:13 <vixey> ./ghc/dist-stage1/build/ghc/ghc -Bdriver --interactive
20:49:14 <vixey> <command line>: not built for interactive use
20:49:36 <ddarius> Don't you need a stage2 build?
20:49:55 <vixey> oh I'll wait and see then
20:50:59 * vixey is trying to get 6.9 working without much luck today or yesterday
21:00:30 <chrisdone> dons: Network.CGI has an outputFPS function which takes a lazy ByteString and outputs it. is converting a PNG image in a strict ByteString to a lazy one in order to output it going to have overhead in that context, do you think?
21:00:46 <mmorrow> <vixey> would [$do|...|] be useful?
21:00:56 <mmorrow> vixey: how do you mean?
21:01:16 * mmorrow becomes intrigued
21:01:19 <vixey> [$do| x <- xs ; guard foo ; return x |]
21:01:34 <mmorrow> and what would the translation be?
21:01:44 <vixey> xs >>= \x -> guard foo >> return x
21:01:50 <Twey> do { x <- xs ; guard foo ; return x }
21:01:56 <vixey> but say you wanted, you could replace with
21:01:59 <vixey> ~>>= and ~>>
21:02:04 <vixey> and so on..
21:02:07 <bd_> chrisdone: converting a strict bytestring to a lazy one basically just means making a [strictBS]
21:02:18 <vixey> I read a couple times people wanting to overload do notation
21:02:25 <mmorrow> vixey: whoa, what are ->>= and ->> ?
21:02:26 <chrisdone> bd_: but is there any cost?
21:02:29 <Saizan> 6.10 is supposed to generalize do-notation i think, but i'm not sure how much
21:02:32 <vixey> mmorrow: oh just a random example
21:02:37 <mmorrow> vixey: ah
21:02:41 <bd_> chrisdone: probably /some/, but of the O(1) sort
21:02:47 <mmorrow> vixey: ohhh, i see the point
21:02:51 <chrisdone> bd_: oh, good
21:02:58 <bd_> chrisdone: you're not going to copy it or anything, that's for sure :)
21:03:05 <vixey> (I took that from http://www.wellquite.org/non-blog/sessions.pdf )
21:03:06 <lambdabot> Title: Session Types in Haskell
21:03:17 <mmorrow> vixey: syntax hijack nijitsu
21:03:21 <vixey> hehe
21:03:39 <vixey> mmorrow: oh by the way it turns out views -can- bind variables
21:03:55 <bd_> @src Data.ByteString.Lazy.fromChunks
21:03:55 <lambdabot> Source not found. Maybe you made a typo?
21:04:02 <vixey> so, foo ([$rx|...] -> this that) = .. should be able to work
21:04:06 <dolio> mmorrow: Did you get 6.9 built?
21:04:10 <bd_> chrisdone: well, anyway, toLBS sbs = fromChunks [sbs]
21:04:43 <mmorrow> dolio: no, but i think the reason was different than your problem (although maybe not)
21:04:48 <dolio> Ah.
21:04:55 <vixey> I can't build 6.9 either :/
21:05:06 <mmorrow> dolio: i've been constantly pulling and updating base packages since i build my ghc
21:05:06 <vixey> I have done in the past but I am trying to build the latest one
21:05:32 <mmorrow> dolio: i got a linker error having to do with Text.PrettyPrint.HughesPJ
21:06:34 <dolio> Huh.
21:08:16 <mmorrow> dolio: yeah, i was like wtf!? i think that was a case of me messing up because i was flipping my $PATH between diff ghc's to do something before i tried to build head
21:08:23 <Shiruka> "System-level languages include features intended to help programmers make fewer errors, such as [...] and verbosity." :-O
21:08:30 <Shiruka> verbosity is a feature now?
21:08:52 <chrisdone> bd_: thanks for explaining :]
21:09:09 <mmorrow> <vixey> so, foo ([$rx|...] -> this that) = .. should be able to work
21:09:17 <dolio> C includes features intended to help programmers make fewer errors?
21:09:38 <mmorrow> vixey: so what exactly is that view pattern syntax mean
21:09:59 <mmorrow> vixey: i've never used them, only have a vague idea of the functionality via analogies
21:10:07 <vixey> mmorrow: foo string = let (this,that) = <regex expansion> string in ..
21:10:16 <Twey> dolio: Um, it has types.
21:10:18 <Twey> Kind of.
21:10:22 <dolio> Hahaha.
21:10:33 <dolio> Yeah.
21:10:38 <Shiruka> one could argue that it adds redundancy and that lowers error probability, but most javaesque verbosity doesn't really do that (public static void main is error checking?) and the redundancy would need to be independently produced to gain much anyway.. :-\ </randomthoughts>
21:10:58 <vixey> mmorrow: oh well not quite like that actually, since it's still part of pattern matching
21:11:03 <Twey> Shiruka: public static void main() isn't verbosity
21:11:20 <Twey> They're all keywords that actually do something (except for the name 'main')
21:11:39 <vixey> mmorrow: anyway that's the idea I got from the docs .. but I haven't been able to try anything yet :[
21:11:51 <Twey> public: publically accessible, static: not an instance method, void: no return type (I guess this could be omitted)
21:11:52 <dobblego> Twey, they are redundancy and unnecessary (aside from the language mandate)
21:12:00 <lispy> gwern: ping
21:12:04 <Shiruka> Twey, compare to "main = print "Hello World""
21:12:13 <dobblego> void means "return type is unit"
21:12:43 <adu> void = ()
21:12:46 <Twey> Shiruka: Yes, but Haskell and Java are incomparable *for a classical OO language*
21:12:49 <Twey> Errr
21:12:55 <Twey> I mixed up two arguments there
21:12:59 <adu> not really
21:13:00 <mmorrow> vixey: hmm, but the problem is when you defined a (String -> PatQ) part of a QuasiQuoter, you only have template-haskell syntax with which to create the AST-to-be-spliced
21:13:03 <lispy> dobblego: void means () until void *
21:13:03 <Twey> Haskell and Java are incomparable
21:13:08 <dolio> "public static" means "I shouldn't be inside a class." :)
21:13:11 <mmorrow> vixey: s/defined/define/
21:13:22 <dobblego> Twey, why not?
21:13:25 <vixey> mmorrow: oh I guess this isn't a PatQ, actually
21:13:26 <adu> theres just lots of distinctions in one that are not distinctions in the other
21:13:28 <Twey> Shiruka: Those keywords are necessary *for a classical OO language*
21:13:42 <jganetsk_> hey, stack overflows in haskell really suck ass
21:13:52 <jganetsk_> does anyone else have trouble with them?
21:14:03 <vixey> mmorrow: [$rx| .. |] (that I'm thinking of) would be a ExpQ and expand into a function that's used as a view
21:14:10 <adu> Twey: like traditional Java "Objects" are distinguished into Haskell "Module" and "Record" concepts
21:14:11 <lispy> jganetsk_: Usually, for me at least, that means I have a faulty recursion.  Usually lacking a base case
21:14:14 <vixey> regexes as a view of strings
21:14:14 <dobblego> Twey, no they aren't; I use Java all day long (I write in bytecode using a fancy text editor); here is main: def main = ...
21:14:22 <Twey> jganetsk_: Erm, tail-recurse if you have to, chances you're doing something more basic wrongly, though
21:14:22 <mmorrow> vixey: hehe, i love how your brain squishes inside out repeatedly when thinking about (...-meta-...-haskell)
21:14:29 <vixey> :p
21:14:51 <jganetsk_> Twey, lispy: so, it wasn't me, it was a more experienced developer, and i was looking over his sohulder
21:14:55 <Shiruka> Java is hardly old enough to be considered "classical"..
21:15:03 <Twey> dobblego: But that doesn't say it's a public class method
21:15:04 <jganetsk_> Twey, lispy: he ended up coming here to ask
21:15:05 <Shiruka> does Smalltalk have "public static void main"?
21:15:10 <dobblego> Twey, yes it does
21:15:19 <jganetsk_> Twey, lispy: but it was wrapped up in State monad and hard to find
21:15:27 <Twey> jganetsk_: It's generally an infinite loop
21:15:30 <lispy> jganetsk_: interesting
21:15:35 <Twey> dobblego: How so?
21:15:56 <mmorrow> vixey: i think the point at which the up-hill battle ends is when there's a haskell quasiquoter that can parse+? quasiquote syntax
21:15:59 <dobblego> Twey, simply by my asserting; you're making the claim that all the redundancy is necessary; I have produced a counter-claim
21:16:35 <adu> Twey: and another thing, I just noticed that we've been throwing around the terms "classical" and "traditional" in entirely the wrong way
21:16:40 <dobblego> Twey, do you need more evidence that it is a public static unit method?
21:16:41 <Twey> Yes... but... the counter-claim doesn't hold half the information the original does
21:16:44 <mmorrow> vixey: so it can parse a representation of itself, and recurse through stages of compilation/metaness or something
21:16:50 <lispy> vixey: I have to wonder if you're dealing in the corners of TH where you realize lisp has Haskell beat for now
21:16:56 <Twey> adu: I was using 'classical OO' to contrast mostly with 'prototypical OO'
21:17:13 <adu> Twey: FP is much older than OOP by 30 years at least, so we should really be calling FP the traditional view of objects (as functions)...
21:17:22 <mmorrow> lispy: heh
21:17:25 <dobblego> Twey, your assertion that the redundancy is anything but noisy redundancy is the false assertion
21:17:38 <Twey> dobblego: ...
21:17:41 <Twey> What?
21:17:41 <humasect> there really is no mirror for ghc docs? one can generate them?
21:17:51 <dobblego> Java, the language, requires it, because Java, the language, requires redundancy
21:17:55 <Twey> Yes
21:18:04 <Twey> Well, no
21:18:07 <Twey> Not the *language*
21:18:10 <Twey> The *paradigm*
21:18:11 <Shiruka> "public static void main" doesn't contain lots of information usually
21:18:12 <dobblego> yes, the language
21:18:16 <dobblego> no, not the paradigm
21:18:17 <Shiruka> because you could infer much of it
21:18:29 <dobblego> Shiruka, prexactly what my smart editor does
21:18:33 <Shiruka> at least if you made some nicer assumptions
21:18:38 <dobblego> my smart editor is better known as "Scala" by the way
21:18:41 <Shiruka> and if you can infer something, it's not information
21:18:58 <hackage> Uploaded to hackage: cedict 0.2.5
21:19:09 <Twey> dobblego: Then write me a Java class with both class and instance methods in some other language and I'll believe you
21:19:41 <dobblego> Twey, I'm not sure why you think it is not possible, so I'm hesitant that if I did, I wouldn't meet your requirement
21:19:58 <Shiruka> well, for instance Boo is much less verbose than C#, and yet has (as far as I understand - I don't actually use it) the same features as C#
21:20:03 <humasect> dobblego: how is scala for you, do you like it ?
21:20:04 <Shiruka> and C# is pretty much the same as Java
21:20:05 <vixey> was it an error like this?
21:20:08 <vixey> Linking dist-stage2/build/ghc/ghc ...
21:20:08 <vixey> ld: atom sorting error for _ghczm6zi9_LibFFI_Czuffizucif_closure_tbl and _ghczm6zi9_LibFFI_Czuffizutype_closure_tbl
21:20:11 <vixey> when compiling GHC
21:20:16 <dobblego> humasect, it's annoying me today (refuses to infer higher-kinds)
21:20:24 <dobblego> Twey,
21:20:25 <dobblego> scala> class T { def t = 7 }; object T { def u = 8 }
21:20:25 <dobblego> defined class T
21:20:25 <dobblego> defined module T
21:21:01 <Twey> dobblego: I'm trying to imagine the context in which def foo = ... could possibly convey the information 'a class method named foo with public access' (type inference makes the 'void' pretty easy to omit, admittedly)
21:21:07 <humasect> dobblego: i see. it looks interesting for those who need java compatibility especially
21:21:13 <pejo> Does the Haskell FFI handle calling variadic C functions gracefully?
21:21:40 <Twey> dobblego: Is 'object T' an instance of 'class T'?
21:21:48 <dobblego> Twey, public is implied (since access modifiers are only especially important in an uncontrolled side-effecting environment)
21:22:06 <dobblego> no, it may be considered the collection of static methods on T
21:22:16 <ddarius> pejo: It doesn't handle it at all.
21:22:23 <Twey> Oh, so 'u' is static and 't' isn't?
21:22:31 <dobblego> correct
21:22:37 <Twey> But that requires redundancy of the class name
21:23:01 <Twey> Although I do see that it could be marginally more efficient
21:23:42 <dobblego> it also requires redundancy of the space character
21:23:43 <Twey> And having public as the default goes against the Java philosophy
21:23:50 <dobblego> that's because Java is retarded
21:23:59 <Twey> OK, so assuming public is the default
21:24:18 <dobblego> which is reasonable, since purity is not so difficult in Scala (as it is in Java)
21:24:25 <Twey> I would favour syntax like: class T { static { u = 8; } t = 7; }
21:24:42 <dobblego> and you'd prolly be the only one :)
21:24:47 <ddarius> Twey: Presumably you can declare object T in a totally different file.
21:25:21 <dobblego> non-static members simply have elevated the status of one of the arguments of what would be a static method; it is important that they are distinct
21:25:25 <lispy> dobblego: But is purity as efficient in Scala as it is in, say GHC Haskell?
21:25:28 <Twey> ddarius: IIRC, Java has mechanisms to allow parts of a class to be included in separate files
21:25:32 <dobblego> lispy, definitely not
21:25:41 <vixey> Twey: really ? how
21:25:46 <dobblego> Twey, you don't remember correctly
21:25:51 <ddarius> Twey: C# does.  If Java does it's news to me.
21:25:58 <Shiruka> ... I can't believe it's really necessary to justify the claim that Java is verbose (-.-;
21:26:09 <dobblego> Shiruka, :)
21:26:13 <Twey> Oh no
21:26:16 <vixey> java can be verbose
21:26:17 <Shiruka> most people usually consider it obvious
21:26:19 <Twey> I'm thinking of C#'s partial classes
21:26:29 <codacola> java is evil. only functional languages should be used
21:26:31 <lispy> dobblego: One thing I struggled with when using Scala was that my brain was wired to code with lists using Haskell idiomatic functions.  I was at a loss os to how to properly define them in Scala.  It didn't seem right to add them by subclassing List, but what else should I have done?
21:26:48 <Shiruka> well, dunno about evil :-)
21:26:53 <codacola> it is
21:26:55 <dobblego> lispy, how to define what exactly?
21:27:00 <codacola> anything that reduces the usage of functional languages is evil
21:27:06 <codacola> which includes java
21:27:07 <Twey> Heh
21:27:12 <Twey> VB6 is evil
21:27:13 <vixey> haskell is functional, imperative, declarative .. probably other stuff too
21:27:31 <codacola> yeah, im slowly hating how huge haskell is :P
21:27:34 <vixey> ranlib: file: dist-stage1/build/libHSghc-6.9.a(unicode.o) has no symbols ---- grrrr
21:27:38 <vixey> why not
21:27:43 <codacola> just as i learn 1 thing, im finding theres still so much to learn
21:27:54 <dobblego> scala> val x = List(1, 2, 3).map(_ + 1) // lispy, like this?
21:27:54 <dobblego> x: List[Int] = List(2, 3, 4)
21:28:06 <Shiruka> hmh
21:28:07 <Twey> codacola: To be fair, it's generally all build on other things.
21:28:11 <Twey> built**
21:28:12 <lispy> dobblego: No, I'm trying to remember what I needed.
21:28:18 <Twey> You're learning theory more than Haskell.
21:28:27 <codacola> my lecturer gave me a paper on why functional langauges are good. and then i stapled it to another assignment that i handed in :|
21:28:27 <lispy> dobblego: It was something from Data.List I think
21:28:28 <Shiruka> from a haskeller's viewpoint, is scala a reasonable functional programming language?
21:28:34 <Shiruka> (I've never used scala)
21:28:49 <vixey> Shiruka: Scala looks like haskell to me
21:28:59 <dobblego> Shiruka, it's annoyingly verbose compared to Haskell (though, much better than Java), weaker type inferencer is annoying when you want to do clever things
21:29:05 <vixey> Shiruka: well like java more
21:29:21 <vixey> Shiruka: but I don't nkow it seems like they just want to be writing haskell
21:29:37 <dobblego> Shiruka, the most clever thing I have got Scala to do is implement the Applicative/Traversable type-class
21:29:43 <lispy> Shiruka: Scala has a nice advanced type system, but I wouldn't say the FP + OO fusion is ideal.  I have had some rather annoying semantic issues with it in the past, but they were apparantly bugs that got fixed.  so yeah, scala is a nice alterative to java that is compatible with java
21:29:44 <vixey> btw I don't actually know the language at all, I just read 1 tutorial
21:30:19 <vixey> why not just make haskell compile to jvm though, that's what I don't get..
21:30:31 <lispy> vixey: it's a hard problem to do right
21:30:42 <dobblego> vixey, Scala allows transparent use of existing Java libraries; that's not so easy in Haskell
21:30:57 <lispy> vixey: It would likely be PhD research to make Haskell compile to JVM or CLR and to do it right
21:31:11 <Shiruka> thanks, good to know that there's an acceptable programming language for JVM just in case I have to use it at some point :-)
21:31:24 <lispy> vixey: I think it was SPJ that suggested it as a PhD topic
21:31:37 <vixey> Shiruka: I'd prefer java over scala ...
21:31:39 <lispy> and .NET has F# these days
21:31:52 <dobblego> I would strongly recommend against Java, at all times
21:31:55 <Shiruka> vixey: why?-)
21:32:07 <dobblego> there is no rational reason
21:32:24 <vixey> lispy, oh http://www.cs.rit.edu/~bja8464/lambdavm/
21:32:26 <lambdabot> Title: LambdaVM - The Haskell to Java Translator
21:32:30 <vixey> lispy, looks like somebody got there before me
21:32:30 <dobblego> forall X. if Java can achieve X, Scala can achieve X with equal or better outcome
21:32:43 <lispy> Shiruka: Well, as much as I love FP, you can't discount and overlook the mainstream aspect.  It turns out to matter for lots of little reasons, and for some major non-technical ones.
21:32:53 <vixey> Shiruka: it's a simpler language than scala, I know that much
21:33:01 <lispy> vixey: cool, but that miht be a different approach
21:33:02 <dobblego> no, it's significantly less simpler
21:33:15 <dobblego> that's a common myth
21:33:19 <Shiruka> lispy: but it uses JVM, so shouldn't it be compatible?
21:33:22 <vixey> yeah 6.9 is just not going to compile for me
21:33:28 <cjs> Java is very expensive to program in.
21:33:43 <dobblego> Java is very expensive to implement (do you *really* know the language?)
21:33:49 <lispy> Shiruka: think about assembling a team of scala devs vs a team of java devs
21:33:52 <vixey> cjs: all the tools you need to write java can be got for free ...
21:33:57 <cjs> I did years of Java.
21:34:05 <dobblego> I spent 4 years on the JVM
21:34:24 <lispy> dobblego: but does scala have a unit test suite to rival java's (which is actually pretty big and good)
21:34:28 <dobblego> Java is a much more complex language than Scala
21:34:29 <cjs> I'm not saying for all situations, of course, but in many cases you can get whatever job you need done a lot faster in another language.
21:34:33 <dobblego> lispy, yes, I wrote it
21:34:41 <dobblego> lispy, and Java's are crap
21:34:59 <chrisdone> “I wrote it, therefore it is good”
21:35:09 <dobblego> I wrote QuickCheck for Java and Scala
21:35:21 <Shiruka> lispy: sure, but in that kind of situation java is usually mandated from the above anyway. I was thinking of situations where it just needs to be compatible
21:35:44 <dobblego> QuickCheck is better than JUnit-style crap, therefore, it is good
21:35:55 <lispy> Shiruka: ultimately, good developers will apply approriate techniques and get good results from whatever tools you throw at them.  What I'm saying is, it's very important to assemble the right team and I would say, more important than using the best tools.
21:36:25 <cjs> That's true. And if you've got a good team, let them pick the tools.
21:36:44 <cjs> (Contrawise, if you pick the tools, you might not get a good team.)
21:37:06 <Shiruka> (given the ideal amount of choice, I wouldn't deal with any developers who have trouble learning programming languages anyway, there's a certain doubt as to their level of competence in the field)
21:37:14 <vixey> yay
21:37:15 * bitrot is waiting for a "contrapunctally..."
21:37:20 * vixey gets view patterns working
21:37:31 <dobblego> having suits force Java down my throat is the primary reason I wrote QC for Java (I can't bring myself to use that other junk)
21:37:34 <lispy> Shiruka: my experience is that, learning a plethora of tools and techniques makes you a better individual so that hopefully you can get on a good team :)
21:38:20 <cjs> It probably makes you a better developer; I'm not so sure about a better individual human being...
21:38:31 <vixey> cjs lol
21:38:33 <lispy> cjs: there is a difference now? ;)
21:38:50 <cjs> I know who I'd rather have an exchange on a mailing list with. :-)
21:39:05 <lispy> I heard St. Peter was asking CS questions these days
21:39:07 <cjs> While we're on the topic, is there any Haskell in Google. Or any FP at all, for that matter?
21:39:27 <lispy> Probably
21:39:46 <Trinithis> FP? Who needs FP?
21:39:48 <lispy> Well, they like js and python and both of those have facilities for it
21:40:14 <chrisdone> class Show a => ShowByteString a where showBS :: a -> ByteString ; showBS = pack . show
21:40:18 <chrisdone> is there something like this?
21:40:28 <lispy> ?pl pack . show
21:40:28 <lambdabot> pack . show
21:40:32 <cjs> I'm talking about a language where the standard style is FP, not where you can just "do" FP.
21:40:52 <lispy> ?hoogle Show a => a -> ByteString
21:40:52 <vixey> cjs, what's doest it matter
21:40:52 <lambdabot> Data.ByteString.unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
21:40:52 <lambdabot> Data.ByteString.Char8.unfoldr :: (a -> Maybe (Char, a)) -> a -> ByteString
21:40:52 <lambdabot> Data.ByteString.Lazy.unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
21:40:53 <chrisdone> @hoogle a -> ByteString
21:40:53 <lambdabot> Data.ByteString.unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
21:40:53 <lambdabot> Data.ByteString.Char8.unfoldr :: (a -> Maybe (Char, a)) -> a -> ByteString
21:40:54 <lambdabot> Data.ByteString.Lazy.unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
21:41:02 <cjs> Last I heard, if you went to your boss there and said you wanted to do even an experimental project in Haskell he'd whack you on the head with a newspaper and tell you to go use Java.
21:41:26 <Shiruka> lispy: I would kind of lose self-respect if I weren't able to adapt to some tool that has to be used :-)
21:41:42 <lispy> Shiruka: sure
21:41:54 <Shiruka> where "adapting" doesn't imply liking it, though
21:42:07 <cjs> Kinda sounds like they might not be so all-mighty and powerful when it comes to programming, if you ask me.
21:42:09 <chrisdone> Shiruka: your mom adapted
21:42:10 <chrisdone> sorry
21:42:18 <lispy> I like the cross polination of ideas, like seeing phantom types in haskell and then using generics in C# to have phantom types there too :)
21:42:49 <b7j0c> is haskell.org dead?
21:42:55 <chrisdone> yeah
21:43:09 --- mode: ChanServ set +o dobblego
21:43:14 <Shiruka> lispy: I like to see programming languages get better :-P
21:43:17 --- topic: set to '["Haskell: precision engineering for programmers", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org ", "Logs: http://tunes.org/~nef/logs/haskell/", "haskell.org is dead atm"]' by dobblego
21:43:23 --- mode: dobblego set -o dobblego
21:43:30 <b7j0c> errr! just as i sat down to try to build a yahoo searvchmonkey module for it....
21:43:37 <lispy> Shiruka: but, I also try to make some tools off limits to my managers.  Recently we could use either perl or Java for a project but no one knew perl and we had 4 java knowing devs...so I did have to put my foot down there.  But it was for sanity sake.
21:43:54 <cjs> That's sane.
21:44:18 <Shiruka> I hope you mean that you chose java..
21:44:23 <lispy> Yeah
21:44:43 <lispy> It's silly to learn perl for a one off project when you have people that know java already
21:45:13 <b7j0c> i've always wondered how much crap i would get in for deploying clojure on our java boxes....
21:45:13 <Shiruka> indeed
21:45:24 <lispy> I have no idea why my managers fixated on Perl for that project, but it actually took some arguing and persuading
21:45:41 <b7j0c> fixating on perl can be a good idea
21:45:42 <cjs> Hm. Does anybody out there have a sample of a parser that as well as returning parsed stuff and errors, can return warnings about things that are dodgy bit it chose to relax and allow?
21:46:07 <chrisdone> there is a Read instance for ByteString, surely there should be a way to convert a -> ByteString? ShowBS? it could be a subclass of Show and derive from that until proper ShowBS instances have been made for that type..
21:46:19 <ddarius> It's silly to learn perl.
21:46:33 <b7j0c> why ddarius??
21:46:38 <lispy> cjs: I haven't seen that, but I could see using a WriterT to build up the list of warnings/errors
21:46:46 <cjs> chrisdone: convert a bytestring to what?
21:47:09 <cjs> lispy: I can see how to do it, too, I was just hoping to steal ideas from someone more clever than I am.
21:47:16 <chrisdone> cjs: to convert something to a bytestring, as in Show a => a -> String, there could be ShowBS => a -> ByteString
21:47:49 <cjs> What would "something" be? If it's a sequence of octets, you just read it in.
21:48:00 <chrisdone> cjs: ehh I guess it's not beneficial... just means I have to write pack . show in all my bytestring code ~_~
21:48:03 <cjs> If it's something else, now you're parsing.
21:48:05 <lispy> cjs: fair enough, although newtype deriving plus a writer would allow you to make it really slick and under the hood
21:48:36 <chrisdone> cjs: no, you're not following me. it's not “Read”, it's “Show”
21:48:52 <mmorrow> cjs, chrisdone: dolio just put a bytestring-show package on hackage
21:48:53 <novas0x2a> ey.
21:49:01 <cjs> chrisdone: Ah, you're talking about merely converting back and forth between ByteStrings and Strings? (I'm presuming you really want to convert a ByteString to its equivalant String,r ather than use the output that show :: ByteString -> String gives you.)
21:49:05 <chrisdone> mmorrow: wow, really?
21:49:16 <cjs> lispy: See, that's the kinda stuff I need!
21:49:18 <dolio> Yeah, let me know if you find any bugs.
21:49:18 <mmorrow> cjs, chrisdone: at first glance, it seems related to Data.Binary
21:49:23 <chrisdone> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/bytestring-show
21:49:25 <lambdabot> Title: HackageDB: bytestring-show-0.1.1, http://tinyurl.com/6o3xru
21:49:45 <chrisdone> awwwwsome
21:49:51 <mmorrow> dolio: it's on my "to-get-and-try" short list
21:49:58 <chrisdone> mmorrow: I can just import this now :))
21:50:09 <lispy> cjs: Well, have you seen the newtype deriving custom monads via monad transformer examples?
21:50:15 <dolio> Note that unfortunately, it's not faster than printing with String in my experience.
21:50:20 <lispy> cjs: it's pretty slick once you've been shown how to do it
21:50:20 <cjs> Ah, that's just to show things but with the result as a  ByteString, not a String.
21:50:27 <cjs> lispy: No. I'd love to see it.
21:50:28 <dolio> Although it's better than String -> ByteString -> print.
21:50:31 <mmorrow> dolio: heh
21:50:36 <mmorrow> dolio: ah
21:50:39 <lispy> cjs: K, let me see if I can find a canonical example
21:50:47 <chrisdone> dolio: yeah, more convenient than pack . show
21:50:49 <vixey> ugh
21:50:55 <vixey> I just don't know what to do now
21:50:59 <chrisdone> dolio: funny that I just started asking for that and there it is!
21:51:05 <dolio> But the overhead of the Put seems to be more than lazily generating Strings.
21:51:08 <mmorrow> i recently discovered derive's (as in Data.Derive) ability to derive Binary
21:51:20 <lispy> cjs: here is one page to get started: http://hackage.haskell.org/trac/haskell-prime/wiki/NewtypeDeriving
21:51:21 <lambdabot> Title: NewtypeDeriving - Haskell Prime - Trac, http://tinyurl.com/5lpnrl
21:51:29 <lispy> oh crap
21:51:34 <lispy> That's haskell prime, my bad
21:51:37 <hml> anyone here code haskell in yi ?
21:53:19 <dancor> hml: i try every once in a while but then find i'm not good enough to add all the things i want
21:53:30 <chrisdone> hm, I have Yi installed it seems
21:53:34 <chrisdone> must've compiled it ages ago
21:53:46 <chrisdone> error: Keymap not defined, 'q' to quit, 'h' for help.
21:53:46 <chrisdone> hehe
21:53:57 <dancor> might want to cabal install anew
21:54:02 <lispy> cjs: read this: http://www.cs.virginia.edu/~wh5a/personal/Transformers.pdf
21:54:03 <lambdabot> Title: Monad Transformers Step by Step
21:54:19 <chrisdone> I don't actually use it. emacs supports ghci and that's what I need
21:54:25 <lispy> cjs: it doesn't discuss the newtype deriving, but once you understand that material, I have examples that do the deriving
21:55:14 <cjs> Cool, this is stuff that I need. I used a monad transformer for the first time yesterday, actually.
21:55:18 <hml> so yi isnt' really ready for production  use:
21:55:31 <lispy> cjs: example of using the newtype deriving in a code generator I wrote: http://projects.codersbase.com/repos/helisp/src/CodeGen.hs
21:55:49 <Saizan> cjs: these also look very relevant wrt your original question http://www.cs.uu.nl/wiki/bin/view/Center/UtrechtParserCombinators
21:56:48 <lispy> cjs: In the codegen I do something quite similar to your goal.  I emit instructions as I go based on the code I'm compiling
21:57:10 <cjs> lispy: Right. That looks worth study, I think a bunch of it would apply to me.
21:57:38 <lispy> cjs: good luck, you're right at the point where the time you've invested in learning Haskell really pays off
21:57:54 <cjs> It's already paying off; I'm getting paid to learn it. :-)
21:58:04 <cjs> But yeah, it's starting to come together.
21:58:09 <hml> is it just me or is haskell.org down?
21:58:15 <cjs> hml: It's just you.
21:58:19 <chrisdone> see topic
21:58:22 <lispy> hml: it's down, check the /topic :)
21:58:27 * cjs is so mean.
21:58:34 <lispy> heh
21:58:46 <cjs> Saizan: Hey, that looks really good. Thanks for the link!
21:59:10 <_zenon_> Mornong
21:59:41 <hml> any vim users here? or is  emacs the editor to use for haskell
21:59:48 <cjs> I use vim.
22:00:14 <MyCatVerbs> hml: I use vim.
22:00:15 <hml> what do you use for identing?
22:00:16 <lispy> I really should finish my helisp compiler...iirc I mostly just needed to add GC and tail call optimization and it would be pretty much usable
22:00:16 <chrisdone> @hoogle ByteString -> a
22:00:17 <lambdabot> Data.ByteString.foldl :: (a -> Word8 -> a) -> a -> ByteString -> a
22:00:17 <lambdabot> Data.ByteString.foldl' :: (a -> Word8 -> a) -> a -> ByteString -> a
22:00:17 <lambdabot> Data.ByteString.foldr :: (Word8 -> a -> a) -> a -> ByteString -> a
22:00:18 <hml> manually?
22:00:28 <cjs> I don't particularly recommend it, unless you really are addicted to vi-style editing (I am), but it works. I can send you some .vimrc stuff if you like.
22:00:31 <vixey> what's helisp?
22:00:50 <hml> cjs: that'd be great; i've been a vim user for a decade now; but haskell/lisp is really temppting me to use emacs
22:00:56 <hml> can you hpaste it?
22:01:02 <MyCatVerbs> hml: expandtab, tabstop=4, shiftwidth=4. And I just use vim's defaults for indenting (which suck, come to think of it).
22:01:04 <lispy> vixey: I had a dream once to make yi compatible with emacs lisp so that I could transition to yi
22:01:04 <cjs> Yup.
22:01:16 <cjs> I use expandtab.
22:01:32 <lispy> vixey: so i started writing a scheme-ish compiler in Haskell that I intended to use as a plugin to yi
22:01:42 <dolio> Did you wake up screaming?
22:01:48 <lispy> Why didn't I make an interpreter?  I have no idea, it probably would have been easier
22:01:49 <vixey> oh cool
22:01:52 <MyCatVerbs> hml: the only upside is that Haskell's terse enough that I don't much mind indenting it manually, since there are so few lines. ;)
22:01:55 <vixey> compiling it to what though?
22:02:15 <lispy> vixey: currently x86_64 and someone ported it to do x86_32
22:02:17 <Shiruka> emacsitor is the only editor :-)
22:02:20 <vixey> wow
22:02:30 <cjs> http://hpaste.org/9258
22:02:41 <dolio> vim has decent haskell indentation last I checked.
22:02:50 <MyCatVerbs> lispy: please use the terms "amd64" and "i386", because both annoy Intel's marketing people. :)
22:02:52 <Trinithis> Can haskell ask for what character is used for path separators?
22:03:02 <MyCatVerbs> dolio: I find it a huge pain in the posterior.
22:03:03 <lispy> MyCatVerbs: haha
22:03:04 <dolio> Or, at least, I got some script that made it decent.
22:03:24 <cjs> I've tweaked the indent algorithm to be slightly better about comments than the version of haskell.vim I downloaded. And as you can see, I kill tabs completely, because I'm using a variable indent scheme for Haskell. (I don't use that for any other language.)
22:03:47 <MyCatVerbs> dolio: usually it's fine, but then it'll spontaneously get some stupid idea wedged into its head and send everything halfway up the blasted page. The failures are annoying enough to outweigh the automation.
22:03:58 <lispy> vixey: I used a clever reverse engineering technique for figuring out all the low level details...write some C or some ASM and then have the approriate tool generate the next level down and steal what they did :)
22:04:03 <dolio> Heh.
22:04:14 <vixey> yikes
22:04:20 <cjs> Trinithis: the OS's path sep. char.
22:04:22 <vixey> I've had to do stuff like that once
22:04:34 <MyCatVerbs> lispy: do try to avoid copying other peoples' bugs. :)
22:04:38 <vixey> such hard work
22:04:46 <Trinithis> cjs ?
22:04:53 <MyCatVerbs> dolio: incidentally, how's yi at this?
22:05:00 <lispy> I only did it for simple pieces though, like figuring out haw x86-64 would handle the function call stack (I was initally using the wrong register!)
22:05:04 <dolio> MyCatVerbs: I've never gotten yi to work.
22:05:06 <MyCatVerbs> I keep meaning to install it and have a go at hacking on it, but I'm just -so- lazy.
22:05:17 <Trinithis> cjs: oh.  yesp
22:05:20 <dolio> I should try now that the new version is out.
22:05:21 <cjs> Trinithis: sorry, misread your question. (Doh!) Anyway, yes, there's a FilePath library or something like that.
22:05:24 * MyCatVerbs perks an eyebrow at dolio.
22:05:55 <MyCatVerbs> dolio: cabal-install works now, comrade. And Hell, I managed to get it running last year going through the dependencies by hand. :)
22:06:12 <dolio> Well, I should say, I got it compiled.
22:06:18 <dolio> I never got it working as an editor.
22:06:22 <Trinithis> cjs: thx. btw, your with your haskell.vim, what is GetHaskellIndent()
22:06:22 <Trinithis>  for?
22:06:36 <MyCatVerbs> dolio: did you remember to install either yi-gtk or yi-vty as well as just yi?
22:06:52 <dolio> Yeah. I don't remember what wasn't working.
22:06:52 <lispy> vixey: helisp was a fun projet for me and I would love to resurrect it and finish it, but life keeps getting in the way
22:07:00 <hml> can i still pull packages from cabal while haskell.org is down?
22:07:14 <cjs> Trinithis: GetHaskellIndent figures out where to put your cursor on the next line when you hit Enter, I believe.
22:07:21 <lispy> vixey: and now some RL friends want to make a game with me for the iphone, so I expect any spare dev time I have for helisp will go to that :)
22:07:27 <dons> hml: yeah.
22:07:37 <hml> dons: okay, how do i install cabal?
22:07:38 <dons> hml: hackage is in a different city
22:07:48 <cjs> E.g., You type "case foo of" and Enter, and your cursor ends up below the 'f' in "foo".
22:07:52 <dons> visit hackage.haskell.org, look for cabal-install
22:07:58 <hml> ah, i can load up hackag.ehaskell.org
22:07:59 <hml> cool; thanks
22:08:00 <Trinithis> is it just me, or is hoogle down?
22:08:06 <dons> or, if you're on a good distro, check if cabal-install is already in your distro.
22:08:10 <dons> Trinithis: it run on h.o
22:08:20 <MyCatVerbs> Huh. The Yi on Hackage is really damn picky about Bytestring's exact version number.
22:08:26 <Trinithis> h.o ?
22:08:44 <lispy> Trinithis: common abbreviation here for haskell.org
22:08:51 <Trinithis> ah
22:09:01 <MyCatVerbs> Trinithis: try Hayoo as an alternative? http://holumbus.fh-wedel.de/hayoo/hayoo.html
22:09:02 <lambdabot> Title: Hayoo!
22:09:15 <mmorrow> Trinithis: h.o. as in crack
22:09:16 <Trinithis> funny title
22:10:18 <lispy> so is hayoo competing with hoogle for inovative haskell searching?
22:10:30 <lispy> or do they collaborate?
22:11:02 <lispy> oh, I see: Hayoo! is an example application of the Holumbus framework and was heavily inspired by Hoogle.
22:12:15 <lispy> That's very well designed actually
22:12:30 <hml> ls
22:12:37 <Trinithis> does Hayoo have a FF search bar download anywhere?
22:12:37 <dons> very very nice, yeah.
22:12:49 <dons> great idea, Trinithis
22:12:59 <lispy> drwxrwxr-x 5 hml hml      51 2006-04-10 09:12 code/
22:12:59 <dons> you should ask the devs.
22:13:25 <Trinithis> mm
22:14:10 <MyCatVerbs> Whether or not it's trivial depends on whether the devs wrote it so that you can submit requests without using javascript.
22:14:24 <mmorrow> these luck bastards:
22:14:25 <mmorrow> http://www.omfg.org/
22:14:26 <lambdabot> Title: OMFG - Ohio Milling & Farming Group
22:14:50 <Trinithis> omfg!!!!
22:15:11 <Twey> Hahahaha
22:15:26 <hml> hmm, is it a good idea to have lambdabot hit up arbitrary urls?
22:15:48 <Twey> Why not?
22:15:52 <dolio> No. It's a great idea.
22:15:53 <lispy> hml: hmm...she's done it for a long time, what are you concerned about?
22:15:54 <Twey> She doesn't do it too much.
22:16:11 <hml> dunno; seems like a poteitnail security problem
22:16:26 <codacola> http://www.foldr.com
22:16:26 <Korollary> wow
22:16:27 <lambdabot> Title: 9 foldr.com 20
22:16:34 <lispy> What does lambdabot us for a user-agent string?
22:16:34 <codacola> http://www.foldl.com
22:16:36 <lambdabot> Title: foldl.com
22:17:15 <Trinithis> http://www.foldM.com
22:17:35 <Trinithis> doesnt exist1!!!!
22:17:42 <mmorrow> <quote>
22:17:44 <dmwit> Buy it now!
22:17:44 <mmorrow>  	STFU drops ASS
22:17:44 <mmorrow> 	
22:17:44 <mmorrow> Southern Tenessee Farmer's Union (STFU) has become part of the growing OMFG family. STFU extends our reach towards the East and grants us a foothold in a region largely dominated by the ASS group (Appalachian Seed Sowers).
22:17:47 <codacola> http://www.omg.org
22:17:48 <lambdabot> Title: Object Management Group
22:17:57 <mmorrow> </quote>
22:18:00 <codacola> http://www.omg.com
22:18:01 <lambdabot> Title: Object Management Group
22:18:10 <lispy> mmorrow: that's awesome
22:18:20 <hml> http://www.haskell.org
22:18:44 <mmorrow> totally
22:18:48 <mmorrow> (http://www.omfg.org)
22:18:49 <lambdabot> Title: OMFG - Ohio Milling & Farming Group
22:20:09 <hml> i've just done sudo cabal install yi
22:20:15 <hml> where is yi installed?
22:20:17 <mmorrow> wow,    omfg.ath.cx     just crashed my firefox
22:20:27 <mmorrow> *and* i have noscript
22:20:34 <mmorrow> must've been a fluke
22:20:47 <Trinithis> mmorrow: swfs?
22:21:11 <lispy> Probably a good time to take the omg*.com stuff to #haskell-overflow or #haskell-blah (might be getting OT)
22:21:29 <mmorrow> Trinithis: um, if you mean sfw yes, just a blank screen
22:21:57 <mmorrow> lispy: true
22:22:51 <Twey> mmorrow: SWFs
22:22:57 <Twey> ShockWave Flash
22:23:31 <mmorrow> ohh...i dunno what you mean
22:23:54 <Trinithis> I've had flash embeds crash FF before... their ext is swf
22:24:41 <hml> cabal installs eerything in ~/.cabal ?
22:24:42 <mmorrow> oh, really. it really sucks when you have about 25 tabs open and haven't bookmarked them yet
22:25:15 <mmorrow> i'll get over it
22:25:34 <Trinithis> Can you sort FF history by time?
22:25:43 <felzix> mmorrow: doesn't FF save state so opened tabs aren't lost?
22:26:00 <mmorrow> i always wipe everything clean as often as possible on all my digital devices
22:26:03 <mmorrow> :)
22:26:22 <dmwit> felzix: Yeah, that's saved me a lot of times.
22:26:42 <mmorrow> felzix: oh, you're right...
22:27:24 <mmorrow> dang, i doing it where all the tabs open, but never load
22:27:39 <chrisdone> I've got about 5 months of firefox history, heh
22:27:51 <chrisdone> like a time machine!
22:30:33 <dons> i've contacted yale about h.o being down.
22:31:27 <dons> ?bot
22:31:28 <lambdabot> :)
22:31:30 <dons> ?users
22:31:30 <lambdabot> Maximum users seen in #haskell: 453, currently: 447 (98.7%), active: 17 (3.8%)
22:31:36 <humasect> pages sometimes come up
22:32:21 <mmorrow> um, were'nt there 500+ earlier??
22:32:35 <dons> lots of new haskellers, i guess :)
22:32:44 <dons> 50 new ones in here during the day, 50M on haskell.org
22:33:01 <mmorrow> but lb says "Maximum users seen in #haskell: 453,"
22:33:08 <dons> yeah, lb died, it seems
22:33:24 <mmorrow> ahh
22:33:28 <thetallguy> maybe 500 is her limit
22:34:19 <Elly> whoo, haskellers
22:34:30 <Elly> almost as fun to say as schemers :)
22:35:39 <thetallguy> for a while I referred to programming as 'skelling
22:36:04 <humasect> 'skellers~
22:36:18 <humasect> ah, right, thetallguy =)
22:36:44 <chrisdone> hey Trinithis, I whipped up a firefox engine, try this out: http://chrisdone.com/hayoo.html
22:36:45 <lambdabot> Title: Hayoo Firefox search engine
22:36:53 <hml> s
22:36:59 <Elly> t
22:37:02 <dons> nice
22:37:05 <hml> s
22:37:10 <Elly> no, t!
22:37:21 <thetallguy> If only I lived in Cambridge.  I could skull all morning, then 'skell all afternoon
22:37:32 <mmorrow> chrisdone: cool, what does that do exactly?
22:37:33 <Trinithis> chrisdone: will try. I'll tell you what happens in a few mins
22:38:05 <chrisdone> mmorrow: it's just a search engine for firefox, like hoogle's, but for hayoo
22:38:10 <mmorrow> ooh, the base94url
22:38:40 <mmorrow> HSparklines has that via dataenc
22:38:49 <mmorrow> pretty handy
22:39:08 <mmorrow> s/94/64/
22:39:26 <chrisdone> ahh. yeah
22:40:16 <chrisdone> I think IE supports these open engines, but who uses IE?
22:40:18 <Trinithis> chrisdone: perfecto!
22:40:43 <Trinithis> chrisdone: the majority of internet users?
22:40:46 <mmorrow> chrisdone: hopefully only your enemies
22:41:09 <mmorrow> ok, to sleep
22:41:53 <Trinithis> With an extension, is it possible to overload a polymorphic function with a concrete type function that has the same name?
22:42:16 <Trinithis> Without resorting to quantifiers
22:42:31 <Trinithis> qualifiers*
22:43:04 <dons> nope.
22:43:14 <dons> you mean, foo = M.foo
22:43:16 <dons> or so on?
22:43:27 <Trinithis> For example:...
22:44:07 <Trinithis> length :: [MySpecialType] -> Int -- where length's definition for getting length is different
22:44:41 <dons> well, length isn't a typeclass function. but you could use a rewrite rule to rewrite length.
22:44:57 <dons> RULES length = mylength :: [MySpecialType] -> Int
22:45:04 <dons> so maybe there is an extension :)
22:45:14 <Trinithis> Ah, that looks like what I want
22:45:37 <adu> why would that require an extension?
22:45:39 <dons> you just want the compiler to use a more efficient version of length, if the type is MySpecialType ?
22:45:42 <dmwit> Associated type families might do what you want.
22:46:08 <Trinithis> Actually, I have a Stack a with pop, and for Stack Integer, I want pop on an empty stack to default to 0
22:46:23 <Trinithis> instead of error
22:46:42 <adu> that reminds me, this seems like how I want data MyData ... deriving (Show) but at the same time implement (Show [MyData]) differently
22:47:22 <Trinithis> anyone got a link on rules rewriting?
22:47:30 <dons> hmm, the ghc user's guide.
22:47:34 <dons> and the wiki, which is down.
22:47:42 <dmwit> ?src Show
22:47:43 <lambdabot> class  Show a  where
22:47:43 <lambdabot>     showsPrec :: Int -> a -> ShowS
22:47:43 <lambdabot>     show      :: a   -> String
22:47:43 <lambdabot>     showList  :: [a] -> ShowS
22:47:50 <dmwit> adu: No problem, implement showList!
22:47:51 <dons> basically, you have a rule for pop Empty = 0 :: Stack Integer
22:48:00 <dmwit> adu: ...errr, oh, deriving
22:48:04 <adu> dmwit: oh, thats it? nice!
22:48:09 <Trinithis> dons: exactly
22:48:23 <adu> wait
22:48:38 <adu> dmwit: how do I implement showList and do "deriving (Show)" at the same time?
22:48:45 <dmwit> Yeah, never mind.
22:49:09 <humasect> -XStandaloneDeriving ?
22:49:15 <sjanssen> adu: you can't
22:49:18 <adu> o
22:49:53 <sjanssen> so pretend you're a Haskell compiler and write it yourself :)
22:50:10 <Trinithis> lol
22:50:15 <adu> sjanssen: lol, i suppose i could
22:50:52 <adu> wait
22:50:55 <sjanssen> adu: why do you want [MyData] to be shown differently than the standard list output?
22:51:09 <adu> I just want '\n' after each comma
22:51:25 <adu> I suppose I could just insert it after it turns into a string
22:51:26 <dmwit> adu: Write a pretty-printer instead.
22:51:42 <adu> dmwit: whats a pretty printer?
22:51:48 <dmwit> Show is "supposed" to be Haskell-readable.
22:52:13 <adu> i thought haskell can read '\n' after ','
22:52:17 <dmwit> adu: Pretty-printers make human-readable output. =)
22:52:17 <Trinithis> victory over h.o with google's cache
22:53:00 <Korollary> lispy: how's job search?
22:53:06 <Korollary> err wrong channel
22:53:18 <Korollary> lispy is not looking for a job. Move on.
22:53:22 * Twey laughs.
22:53:28 <Twey> Right boys, swamp 'im
22:53:45 <Trinithis> sadist!
22:53:48 <Twey> Actually I'd love to work for an employer who's hanging around #haskell...
22:53:59 <Twey> Trinithis: Oh, don't you know it.  :-P
22:54:16 <Korollary> Twey: augustss and Heffalump could be such employers
22:54:17 <adu> does pretty-print depend on template-haskell?
22:54:41 <Trinithis> The masochist said to the sadist, "Hit me! Hit me!" And the sadist said, "No"
22:55:09 <adu> lol
22:56:31 <Twey> Hahaha, Trinithis
22:57:24 <Trinithis> Twey: Those who laugh last did not get the joke...
22:58:04 <Twey> Eh, someone else laugh just to satisfy him :-P
22:58:17 * Twey has *other conversations* :-P
23:00:05 <mmorrow> adu: no
23:00:42 <vixey> I really need something to do
23:00:48 <mmorrow> Trinithis: that's a good "my brain is laughing but i'm not literally" one
23:00:58 * Twey chuckles.
23:00:58 <vixey> I keep finishing what I was programming
23:01:01 <adu> vixey: you can teach me about template-haskell
23:01:04 <adu> :)
23:01:08 <Trinithis> I was just prodding at Twey.
23:01:09 <mmorrow> vixey: the horror
23:01:10 <chrisdone> Twey: hey my family are going away next week, maybe you could come up and stay for a few days, code some haskell, talk some lojban, etc.
23:01:30 <Twey> chrisdone: Where d'you live again?
23:01:45 <adu> vixey: because I obviously can't learn from h.o
23:01:51 <chrisdone> Twey: wigan, north-west, near manchester
23:02:02 <vixey> adu: I don't know anything about template haskell
23:02:03 <Twey> chrisdone: Oh that's cool
23:02:08 <vixey> adu: What do you want to do with it?
23:02:12 <Twey> Anglo-Haskell is some time near then too
23:02:22 <chrisdone> Twey: yeah, it starts on my birthday, the 8th
23:02:37 <mmorrow> vixey: well then, you have your work cut out for you then :)
23:02:45 <Twey> Could be interesting
23:02:50 <adu> vixey: well, 2 things, HOC uses TH and i want to fix it, and I also have another project that could possibly use it...
23:03:01 <mmorrow> chrisdone: how old?
23:03:09 <vixey> I'm pretty sure HOC is not worth touching
23:03:32 <mmorrow> (i'm 25)
23:03:48 <chrisdone> Twey: my mother said to me, “don't have any wild parties while we're gone!!" and I said “ho, ho, I'll try”, like we both know I'm just going to sit hacking haskell all week without leaving the house
23:03:58 * Twey laughs.
23:03:58 <Twey> Aye
23:04:00 <chrisdone> mmorrow: I'll be 20
23:04:05 <mmorrow> heh
23:04:31 <Trinithis> 20
23:04:41 <adu> i'm 26
23:04:42 <dons> chrisdone: awesome. if you want help, advice, just lean on the channel.
23:04:46 <Twey> 18 here
23:04:54 <Trinithis> Twey: really?
23:04:54 <dons> productivity ftw!
23:04:59 <chrisdone> dons :)
23:05:06 <Twey> Trinithis: Yeah
23:05:24 <Trinithis> and to think I thought 30's
23:05:32 <ddarius> Trinithis: Why?
23:05:39 <Trinithis> Just a hunch
23:05:47 <Twey> Trinithis: Don't worry, you're not alone
23:05:57 <Twey> It's disturbing
23:06:40 <Trinithis> Did I mention, Twey, that several months ago, you were in a dream of mine, and your head was your DD avatar?
23:06:49 * Twey grins.
23:06:54 <adu> lol
23:07:00 <Twey> Well that's one way of doing it, I guess
23:07:15 <Twey> Trinithis: Me: http://80.4.194.222/uploads/after-haircut.jpeg
23:07:16 <chrisdone> Twey: like when you're eating something and there's a bit of food on your shirt so you scoop it up and eat it, only to find it doesn't taste like /your/ food. maybe it wasn't food at all
23:07:23 <nottha_k> is it possible for a pair of modules to import each other?
23:07:31 <Twey> chrisdone: *blink*
23:07:32 * mmorrow remember when he was 20, trying to implement essentially haskell in C, but little did he know..haskell exists!
23:07:49 * Twey scrolls up looking for some sentence for which that isn't a non-sequitur
23:07:55 * Twey fails
23:08:02 <mmorrow> Nothing
23:08:03 <chrisdone> Twey: yeah, that just happened to me ~_~
23:08:10 <Twey> Hahaha, I see
23:08:17 * bitrot admires lions for their cunning hunting patterns
23:08:43 <felzix> bitrot: sounds like a dwarf fortress quote
23:09:31 <chrisdone> nottha_k: mutually recursive modules or somesuch?
23:09:31 <adu> my favorite quote:
23:09:33 <adu> D41D8CD98F00B204E9800998ECF8427E
23:09:35 <bitrot> felzix: nah, just flipped back to my no-sand-kicking XMonad workspace and saw something about non-sequitars...
23:09:40 <nottha_k> i tried to "ghc -c" both modules but depending on which one I specify first I get a missing interface for the other
23:09:57 <nottha_k> chrisdone: yeah
23:10:12 <Twey> chrisdone: I'd have you explain monads to me, you know :-P
23:10:37 <chrisdone> Twey: and then you explain monads to me :P
23:10:45 <chrisdone> wow, alignment
23:10:50 <dmwit> nottha_k: Look up .hs-boot files, maybe?
23:11:07 <Twey> chrisdone: Haha, damn
23:11:12 <dmwit> nottha_k: Does each import the other?
23:11:25 <chrisdone> Twey: when #haskell is a little quiet, I like to say “but what /are/ monads?” to spark conversation
23:11:38 * Twey chuckles.
23:11:46 <adu> ya i've seen the .hs-boot thing used for recursive modules
23:12:02 <nottha_k> dmwit: yep. chrisdone's "mutually recursive modules" gave me enough google juice to find something useful :)
23:12:13 * chrisdone beams
23:12:18 <bitrot> chrisdone: there are longer possible "sparks", if you think about it...
23:12:38 * mmorrow wonders what google juice looks like, then promptly stops
23:12:48 <chrisdone> mmorrow: maybe that's what I ate
23:12:53 <chrisdone> bitrot: what do you mean?
23:13:05 <mmorrow> chrisdone: contact a poison control center immediately!
23:13:21 <bitrot> chrisdone: an exercise left to the (log n) reader
23:13:52 <adu> chrisdone: Monads are a religion where they believe all of creation can be described by functions of the form a -> m b
23:14:10 <Twey> Hahaha
23:14:34 <chrisdone> adu: is that a subset of the Arrows cult?
23:14:48 <|Steve|> chrisdone: Don't have a good grounding in category theory then?
23:14:56 <chrisdone> |Steve|: no
23:15:16 <bitrot> chrisdone: and if you tire of blabbering about real stuff, you could ask "Hey, what Neal Stephenson novel is teh best?"
23:15:22 <adu> chrisdone: o no, the Monads believe the Arrows are going to hell, but the Arrows graciously accept the Monads as a subcult that hasn't yet realized their full potential
23:15:24 <bitrot> (or maybe not)
23:15:58 <mmorrow> adu: does that mean the "satan" of that religion is a (m a -> b) ?
23:16:28 <chrisdone> bitrot: ok
23:16:29 <adu> yes, unsafePerformIO is satan
23:16:46 <Saizan> or comonads..
23:17:05 <chrisdone> @hoogle isString
23:17:05 <lambdabot> Data.String.IsString :: class IsString a
23:17:05 <lambdabot> GHC.Exts.IsString :: class IsString a
23:17:06 <mmorrow> hehe, satan is so misunerstood
23:17:06 <agentzh> hi, it seems that i can throwDyn in a CGI monad, but i can't catchDyn in the CGI monad? any hints about it?
23:17:51 <mmorrow> agentzh: the monad shouldn't have any effect on that
23:18:03 <Saizan> ?type catchDyn
23:18:05 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
23:18:08 <agentzh> by using catchCGI, i can catch the exception, but it's of type Exception, not the exception type of my own
23:18:44 <chrisdone> @instances isString
23:18:45 <lambdabot> Couldn't find class `isString'. Try @instances-importing
23:18:49 <chrisdone> @instances IsString
23:18:49 <lambdabot> Couldn't find class `IsString'. Try @instances-importing
23:18:57 <mmorrow> agentzh: the type of the exception catchDyn catches has to be the same type as that which throwDyn throws
23:18:57 <agentzh> mmorrow: catchDyn expects its argument to be an IO monad...but the argument is actually of type CGI CGIResult :(
23:19:00 <Saizan> agentzh: you need the internals of CGI to lift catchDyn in it
23:19:23 <Saizan> mmorrow: the problem is that catchDyn takes a callback
23:19:46 <Saizan> ?hoogle catchDyn
23:19:46 <lambdabot> Control.Exception.catchDyn :: Typeable exception => IO a -> (exception -> IO a) -> IO a
23:20:04 <agentzh> yup, IO monad only there...
23:20:38 <agentzh> Saizan: you mean patching the cgi library myself?
23:20:54 <mmorrow> Saizan_: ah, this sounds at first blush to me like what Saul_ was saying about the type of the callback in the HSQL inTransaction function
23:21:13 <mmorrow> he wanted a MonadIO, but
23:21:15 <mmorrow> ghci> :i inTransaction
23:21:15 <mmorrow> inTransaction ::
23:21:15 <mmorrow>   forall a. Connection -> (Connection -> IO a) -> IO a
23:21:15 <mmorrow>         -- Defined in Database.HSQL
23:21:18 <Saizan> mmorrow: yes, it's an ubiquitous problem in MonadIO
23:21:32 <Saizan> agentzh: i'm afraid so
23:21:38 <agentzh> ahh
23:22:32 <Saizan> mmorrow: the InterleavableIO package is aimed at extending MonadIO to cover this issue
23:23:05 <mmorrow> Saizan: interesting, i actually just got that package today, but haven't looked at it yet...
23:25:01 <Saizan> this would be solved if catch* were defined over MonadIO from the start, but i'm not sure if it's reasonable to implement
23:25:16 <adu> like (+) and Monoid...
23:32:31 <agentzh> Saizan: i now do a pattern match (DynException Dynamic) against the Exception value caught by catchCGI, and then use Data.Dynamic.fromDynamic to convert the Dynamic type to my own exception type :)
23:32:44 <agentzh> Saizan: and it works perfectly :)
23:33:46 * agentzh has found patching others' code makes him nervous :P
23:34:03 <O_4> Uh, does anyone know how to check for a GL error in HOpenGL?  I can't see it in the docs anywhere.
23:35:32 <adu> O_4: catch?
23:38:06 <O_4> Hmm, possibly.
23:38:47 <Saizan> agentzh: oh, that's surely better, i wasn't sure if you could implement catchDyn with catch
23:39:04 <agentzh> :)
23:40:07 <agentzh> Data.Dynamic is indeed fantastic :)
23:40:32 <humasect> O_4: if you have GLUT bindings there is a reportError function
23:40:52 <humasect> GLU may have something similar as well
23:43:33 <Beelsebob> O_4: get errors >>= print
23:44:32 <O_4> Oh, plural.
23:45:11 <Beelsebob> yep, returns a list of them
23:54:57 <cjs> Anybody know where I can find haddock for the ghc libs, other than haskell.org?
23:55:04 <cjs> Ideally, a copy I can download for local use?
