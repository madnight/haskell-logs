00:00:10 <mmorrow> c
00:00:24 <mmorrow> cjs: if you buildt from src, you can do it manually
00:00:40 <Saizan> cjs: your distro may have a ghc-doc package
00:01:58 <cjs> I'm NetBSD, and it doesn't. But I have the sources whence I built this package kicking around. How would one go about building the docs?
00:02:30 <TSC> http://www.cmears.id.au/haskell-doc/libraries/ in the mean time
00:02:31 <lambdabot> Title: Haskell Hierarchical Libraries
00:02:35 <Saizan> cjs: runghc Setup haddock
00:02:47 <Saizan> cjs: hackage also has docs
00:02:53 <mmorrow> runhaskell Setup.lhs configure && runhaskell Setup.lhs haddock && firefox dist/doc/html/<name-of-pkg>/index.html
00:03:26 <chrisdone> mmorrow: now I have a generic string interface: http://hpaste.org/9259#a1
00:04:11 <mmorrow> chrisdone: ooh, nice
00:04:40 <chrisdone> mmorrow: I'll probably add more stuff like map, all, etc. basically as I need them really
00:04:59 <mmorrow> chrisdone: a lazy strategy then ;)
00:05:01 <chrisdone> mmorrow: actually an instance of Foldable might do better
00:05:20 <mmorrow> chrisdone: go nuts.
00:05:39 <Saizan> you can't make an instance of Foldable for bytestrings
00:05:39 <chrisdone> mmorrow: once you have fold you've got map, all, etc. so no need to add those manually :d
00:06:05 * mmorrow accepts inevitable sleep
00:06:10 <chylli> I can't access www.haskell.org now :(
00:06:15 <chrisdone> Saizan: maybe just define a foldStr procedure then
00:06:21 <chrisdone> Saizan: in the Str class :)
00:07:29 <Twey> It's down, chylli
00:07:40 <rwbarton> Saizan: why not?
00:07:44 <Trinithis> Twey: What??
00:07:59 <dolio> @type Data.Foldable.foldr
00:08:00 <lambdabot> forall a b (t :: * -> *). (Data.Foldable.Foldable t) => (a -> b -> b) -> b -> t a -> b
00:08:02 <rwbarton> Saizan: oh because they're not generic in their contents
00:08:10 <Trinithis> Twey: nvm
00:08:51 <Saizan> rwbarton: exactly
00:09:08 <chylli> is there something like perldoc or man about haskell lib doc ?
00:09:45 <chrisdone> foldr :: (Word8 -> a -> a) -> a -> ByteString -> a
00:09:52 <chrisdone> that matches the foldable foldr
00:09:54 <chrisdone> I don't follow?
00:10:00 <dolio> No it doesn't.
00:10:13 <jeffz> chylli: if you're using ubuntu or debian I guess, you should have a ghc6-doc package browse to /usr/share/doc/ghc6-doc/html
00:10:34 <Saizan> chylli: there's also http://www.cmears.id.au/haskell-doc/libraries/
00:10:35 <lambdabot> Title: Haskell Hierarchical Libraries
00:10:40 <chylli> jeffz: I'm using archlinux. let me lookit.
00:10:48 <chylli> Saizan: thanks
00:11:19 <dolio> ByteString is not of the form 't a'.
00:11:41 <dolio> And Word8 is not a variable.
00:15:27 --- mode: ChanServ set +o Saizan
00:15:37 --- topic: set to '["Haskell: precision engineering for programmers", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org ", "Logs: http://tunes.org/~nef/logs/haskell/", "haskell.org is dead atm", " http://tinyurl.com/haskdocs "]' by Saizan
00:15:53 --- mode: Saizan set -o Saizan
00:16:09 <Saizan> if someone reads the topic..
00:16:56 <TSC> No one is going to see it that far into the topic (:
00:19:56 <Saizan> the problem of having long slogans..
00:20:35 <dolio> Nobody seems to read any of the topic, really.
00:36:35 <cjs> Sorry, had to go away for a sec. Anyway, I have haddock installed; what I want to figure out is how I generate the docs for all of the GHC libraries, so I can start with that one top page with everything, the way the API reference on the web site has it.
00:43:12 * dcoutts blocks an ip sucking up all the connections on haskell.org http server
00:43:47 <nyingen> It was one ip?
00:44:36 <ayianus> Hrm.
00:45:26 <nyingen> Are there any issues using Haskell's string functions and Parsec to process multilingual data? I'm getting weird results passing around Chinese characters
00:46:08 <MyCatVerbs> nyingen: Char represents unicode points, so that's fine.
00:46:58 <nyingen> Well, the parsec parser I wrote to process some characters works fine when I give it the data directly, but chokes on the first Chinese character if I use parseFromFile
00:47:06 <MyCatVerbs> nyingen: the problem is that the vanilla IO libraries don't grok character encodings - they instead treat everything as naive vendor-SCII-like-ASCII.
00:47:12 <nyingen> Ah
00:47:30 <MyCatVerbs> nyingen: fortunately, there is System.IO.UTF8. ^_^
00:47:35 <nyingen> Gotcha
00:47:41 <nyingen> I suspected as much
00:47:54 <MyCatVerbs> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/utf8-string
00:47:55 <lambdabot> Title: HackageDB: utf8-string-0.3.1.1, http://tinyurl.com/3cjhwj
00:48:07 <MyCatVerbs> That --^
00:48:57 <pejo> dcoutts, was it running IE?
00:49:52 <dcoutts> pejo: dunno, but it was downloading a ghc installer .exe dozens of times simultaneously
00:50:12 <dcoutts> nyingen: yes, one ip
00:51:00 <Twey> One IP brought down haskell.org?
00:51:23 <nyingen> MyCatVerbs: Thanks for the tip
00:51:43 <Twey> How?  Why is it so fragile?
00:52:05 <MyCatVerbs> Twey: long-lived TCP connections can do that to e.g. Apache.
00:52:30 <Twey> :-\  Hmn
00:52:54 <MyCatVerbs> Twey: and other systems that have a) one (blocking) thread or process per open connection and b) a fixed upper bound on the number of threads or processes.
00:53:06 <MyCatVerbs> nyingen: no worries. Pretty common issue, I think.
00:53:13 <BeelsebobWork> what is the normal way of dumping a short string into a ByteString?
00:53:16 <dcoutts> right, and how does everyone fix that?
00:53:35 <dcoutts> it's stipid that I can make 51 connections to haskell.org, sit on them all and effectively DoS it
00:53:43 <BeelsebobWork> @hoogle Char -> Word8
00:53:44 <lambdabot> Data.ByteString.Internal.c2w :: Char -> Word8
00:53:53 <MyCatVerbs> dcoutts: use epoll, kqueue, completion ports, etc.
00:53:56 <BeelsebobWork> something in internal doesn't sound likely
00:54:03 <dcoutts> MyCatVerbs: that's not the problem it's apache
00:54:05 <BeelsebobWork> @hoogle String -> ByteString
00:54:05 <lambdabot> Data.ByteString.Char8.pack :: String -> ByteString
00:54:07 <dcoutts> not just sockets
00:54:25 <pejo> dcoutts, most places don't fix it, they just set the number of connections very high. (With today's botnets I don't think it's that hard to get k unique ip's doing the same kind of dos).
00:54:39 <MyCatVerbs> nyingen: by the way, utf8-string is only one of about three (or was it four?) different libraries for dealing with character sets. It happens to be the easiest to use, most portable and also the least powerful. :)
00:55:14 <dcoutts> pejo: we used to have the max servers at 150, but that actually made it worse for us to get in and restart httpd, without obviously making it much harder for the attacker
00:55:22 <dcoutts> pejo: we now have it at 50
00:55:24 <pejo> dcoutts, telling the difference between a FreeBSD release and that kind of DoS is hard unless you have a lot more context.
00:55:27 <MyCatVerbs> dcoutts: oh and I should've mentioned libevent too, because it's nicer to have a portable wrapper over O(1) poll(2)/select(2) equivalents than to reimplement things multiple times on multiple OSes. ;P
00:55:46 <dcoutts> pejo: every time I've seen it, it's been a single ip, that's pretty clear
00:55:57 <MyCatVerbs> dcoutts: but you already identified the top-level issue here - using Apache. Apache is emphatically _not_ a high-performance webserver.
00:56:08 <dcoutts> performance is not the problem
00:56:10 <pejo> dcoutts, that's a bit odd. Think it's someone doing it on purpose?
00:56:24 <lament>  what's a high-performance webserver?
00:56:30 <dcoutts> pejo: yes, or it's stupidly configured client
00:56:37 <MyCatVerbs> dcoutts: it's also not a high-concurrency webserver. ;P
00:56:49 <pejo> dcoutts, hm. Could be those cannibalizing "download accelerators".
00:57:19 <dcoutts> the problem is apache letting a single client hold all the connections without that client actually downloading any data very quickly
00:57:20 <MyCatVerbs> dcoutts: most people I know trying to solve these issues on Unix-alikes seem to opt for lighttpd or nginx.
00:57:40 <dcoutts> MyCatVerbs: but people do use apache so there must be a solution to this trivial dos attack
00:57:50 <MyCatVerbs> dcoutts: there is. Don't use Apache.
00:57:54 <pejo> MyCatVerbs, and how do these servers prevent dos attacks from happening?
00:57:59 <dcoutts> MyCatVerbs: that does not help
00:58:34 <dcoutts> yes, so lighthttp etc would handle it better because they don't have a limit on connections
00:58:43 <dcoutts> a client trickling a download would not be a problem
00:58:51 <TSC> dcoutts: Maybe there's some way to limit the number of connections per host
00:58:55 <dcoutts> where as for apache's pre-fork system it is a problem
00:59:05 <dcoutts> TSC: right, that's probably what we want
00:59:05 <MyCatVerbs> pejo: this particular kind of DOS attack is rendered irrelevant by the fact that they don't use a thread/process-per-client model. Instead they use epoll/kqueue/libevent/etc to multiplex between pretty much arbitrary numbers of file descriptors.
00:59:23 <dcoutts> TSC: though it seems it needs mod_throttle which isn't loaded on haskell.org's apache
00:59:26 <smtms> dcoutts, I think people use firewalls in front of web servers
00:59:31 <Trinithis> With Stack a = Stack !Integer [a], will the Integer slot NEVER be a thunk?
00:59:43 <pejo> MyCatVerbs, they still run out of resources eventually, it's like apache with a very high limit.
00:59:44 <smtms> dcoutts, something like PF with connection tracking
00:59:48 <MyCatVerbs> pejo: epoll/kqueue etc are seriously cheap. Contrast with forking models, which are gosh-darned expensive.
01:00:01 <dcoutts> smtms: and automatically ban ips that make too many requests?
01:00:14 <smtms> dcoutts, I think PF can do that too
01:01:19 <pejo> dcoutts, http://dominia.org/djao/limitipconn.html
01:01:20 <lambdabot> Title: mod_limitipconn.c
01:01:26 <MyCatVerbs> pejo: in theory, yes. But then you can implement policies like booting off any client which has been connected for an unreasonably long period at an unreasonably low rate. But in practice, you don't, because the issue doesn't come up. epoll/etc burn exceedingly little memory and CPU time, even as you add hundreds and thousands of file descriptors.
01:01:48 <rwbarton> Trinithis: The strictness annotation means that "Stack x y" is like "x `seq` Stack x y", so yes.
01:02:03 <Trinithis> rwbarton: thanks
01:02:11 <Trinithis> well, night
01:02:24 <sjanssen> clearly the solution is to rewrite Apache in Haskell
01:02:36 <smtms> MyCatVerbs, you risk running out of file descriptors though
01:02:36 <TSC> Yeah, that will fix all the resource problems (:
01:03:15 <vixey> > 1 + 1
01:03:19 <lambdabot>  2
01:03:22 <pejo> dcoutts, remember the big corporations that use a proxy though.
01:03:38 <MyCatVerbs> pejo: what happened to Hackage at the moment is capable of happening by accident. The only way you could do that by mistake to a nicely-tuned lighttpd setup would be to, say, wield the entirity of one or two of Google's datacentres and accidentally aim the whole lot at the poor abused little peon of a webserver. :)
01:03:45 <smtms> sjanssen, write a packet filter with advanced functionality in Haskell that is no slower than C implementations
01:04:24 <sjanssen> smtms: why?
01:04:27 <MyCatVerbs> smtms: not particularly relevant. On current Linux, for example, the default limits are set around ~360k file descriptors.
01:04:35 <sjanssen> I just want a web server, not a packet filter
01:04:48 <MyCatVerbs> smtms: and you could quite happily expand that.
01:04:51 <smtms> asfasdfasdf
01:04:54 <smtms> oops
01:04:55 <pejo> MyCatVerbs, you are not solving the problem, just postponing it.
01:05:09 <cjs> Ha! Got my friend to download the Ubuntu GHC docs package and stole it.
01:05:18 <MyCatVerbs> pejo: that suffices. Encryption also merely postpones the issue.
01:05:38 <MyCatVerbs> pejo: nobody cares about issues, after all, that won't come up until long after they're dead.
01:05:49 <idnar> MyCatVerbs: per-user limits default to 1024, generally
01:06:04 <idnar> so you might need to adjust rlimits before you can actually use those 360k descriptors :P
01:06:09 <MyCatVerbs> idnar: precisely what limits.conf is for. :)
01:06:53 <idnar> I thought I ran out of file descriptors the other day, but I actually ran out of ports :/
01:07:17 <MyCatVerbs> smtms: packet filters (usually) wind up in kernel space, rather than userland. Not a place where Haskell programs are commonly seen. ;P
01:07:21 <idnar> (making outgoing connections)
01:07:28 <MyCatVerbs> idnar: hang on.
01:07:40 <MyCatVerbs> idnar: I've tried that on my own for various bad reasons.
01:07:52 <MyCatVerbs> idnar: why did you need to open 28k network connections? :)
01:08:19 <idnar> MyCatVerbs: there was a bug in my system, where it opened up new persistent connections even when the old ones were still active
01:09:01 <MyCatVerbs> idnar: sacré bleu! Long running app, or opening new connections *very* often?
01:09:07 <slava> are there any persistent union-finds which have similar algorithmic complexity as the one using hash tables?
01:09:10 <idnar> long-running
01:09:36 <idnar> all the involved hosts were plugged into the same switch and controlled by me, so it wasn't me DoSing haskell.org ;)
01:09:44 <MyCatVerbs> idnar: heh. Was thinking there - wouldn't the rate usually be limited by 3x the RTT, for new TCP connections to be established? :)
01:10:23 <idnar> heh
01:10:28 <idnar> yeah
01:11:10 <idnar> it was on a test deployment that isn't used all that frequently; I actually noticed the bug in the code first
01:11:21 <idnar> then went to see if I had run out of file descriptors yet, only to discover I ran out of ports first :/
01:11:34 <idnar> which, in hindsight, is obvious, but I hadn't even thought about that particular case
01:12:12 <Twey> http://haskell.org/haskellwiki/Meet_Bob_The_Monadic_Lover -- *blink*
01:12:13 <lambdabot> Title: Meet Bob The Monadic Lover - HaskellWiki
01:12:55 <chrisdone> so now the strings in my library are generic http://chrisdone.com/validate/dist/doc/html/validate/Data-Validate.html
01:12:57 <lambdabot> Title: Data.Validate, http://tinyurl.com/6cs6kz
01:13:16 <pejo> slava, isn't union find (with path compression and stuff) usually implemented as trees?
01:13:26 <chrisdone> I think it's pretty cool
01:13:39 <glguy> slava: The algorithm we discussed earlier might as well be constant time
01:13:58 <glguy> (the implementation might have a large constant, I don't know)
01:14:34 <slava> glguy: i'm using your union-find in my compiler but there's one part where i have to clone it to simulate backtracking and i'm thinking a persistent structure would be nice here
01:14:56 <glguy> OH
01:15:00 <slava> pejo: not sure
01:15:03 <BeelsebobWork> is there any way using Binary to read until a certain character is met?
01:15:04 <glguy> I missed the persistent requirement
01:15:19 <dolio> Someone was talking about persistent union find the other day...
01:15:50 <sjanssen> BeelsebobWork: yes, but you have to write your own loop
01:16:00 <BeelsebobWork> sjanssen: ah, lame
01:16:12 <sjanssen> BeelsebobWork: this is really Control.Monad's fault, not Binary's
01:16:18 * BeelsebobWork ponders just getLazyByteStringNuling the file, and writing decode instead
01:16:34 <glguy> slava: did you already consider "A Presistent Union-Find Data Structure" <http://www.lri.fr/~filliatr/ftp/publis/puf-wml07.ps>
01:16:46 <slava> no i didn't see that
01:16:47 <slava> thaks
01:18:07 <chrisdone> glguy: do you know where hpaste is? I'm curious..
01:18:22 <slava> glguy: on quick inspection this looks like exactly what i need
01:18:25 <glguy> chrisdone: The bot?
01:18:49 <chrisdone> glguy: yep!
01:19:00 <glguy> It runs on shapr's machine
01:19:02 <glguy> or used to
01:19:03 <glguy> I don't know
01:19:39 <slava> glguy: i'm working on a new compiler, hence the union-find usage :)
01:19:43 <chrisdone> glguy: ah, is it part of the happs hpaste program, or a separate program that talks to it somehow every so often?
01:19:53 <slava> its going to compile tight loops in registers and beat ghc in the shootout :)
01:19:53 <slava> maybe
01:20:11 <ivanm> chrisdone: latter I think
01:20:35 <chrisdone> ivanm: then perhaps I can host it
01:20:41 <glguy> chrisdone: it is the same program
01:20:44 <glguy> different thread
01:20:45 <chrisdone> glguy: oh, I see
01:20:46 <slava> unfortunately the only way to find out if persistent structures are a win is to implement them and test
01:21:14 <slava> the constant factor with hashtables is really damn good and cloning a hashtable is fast too
01:21:33 <ivanm> glguy: who hosts the actual hpaste site?
01:21:35 <glguy> slava: From that abstract: "However,the imperative nature of this data structure may be a drawbackwhen it is used in a backtracking algorithm."
01:21:39 <glguy> ivanm: shapr
01:22:13 <ivanm> *nod*
01:22:46 <chrisdone> glguy: well, I think one (i.e. me) could write a program to ask the happs apache server for the main page every so often, using the Last-Modified header, so that it doesn't actually pull the page, it just pulls the date, and then parses the page when a change has taken place
01:22:54 <slava> glguy: "this data structure" refers to the imperitive union-find, not their persistent implemetnation though
01:22:59 <slava> glguy: or do you mean that my suspicions might be justified?
01:23:04 <chrisdone> glguy: or we could just be patient >_>
01:23:13 <glguy> slava: I just meant that the paper seems like it was written for you :)
01:23:18 <slava> glguy: yes :)
01:23:29 <slava> glguy: in any case i'm still at the "get it working" stage, and not "optimize it" stage
01:23:42 <slava> but i like to sort things out ahead of time to avoid crisis later
01:23:46 <glguy> chrisdone: It doesn't matter to me either way if you want to write the bot
01:24:06 <chrisdone> glguy: er k
01:24:32 <glguy> it'd probably entertaining to write on its own
01:24:36 <glguy> even if hpaste was about to be restarted
01:24:57 <chrisdone> hehe
01:26:21 <chrisdone> glguy: you wouldn't know of any trick on the site to view some raw data that could be useful, would you? :)
01:26:30 <Saizan> if we could recompile hpaste we should add auto-reconnect-when-dropped
01:26:40 <chrisdone> yeah
01:28:12 * glguy is set for the commute tomorrow... two scrubs episodes, that paper, bunch of interesting podcasts...
01:28:42 <glguy> but now it is bed time
01:28:44 <glguy> good night!
01:29:02 <chrisdone> haskell.org seems to be back
01:29:17 <chrisdone> night glguy
02:06:23 <BeelsebobWork> why might "BSwords :: (String -> a) -> BS.ByteString -> [a]" be an 'invalid type signature'
02:06:33 <BeelsebobWork> (given that I've imported ByteString qualified as BS)
02:08:21 <rwbarton> BSwords begins with a capital letter?
02:08:38 <BeelsebobWork> oh, duh
02:08:39 <BeelsebobWork> >.<
02:08:45 <rwbarton> :)
02:09:03 <MyCatVerbs> BeelsebobWork: other easy way to get that error is "foo a b :: Bar -> Baz -> Bleep", which I've done a couple times. :)
02:09:18 <BeelsebobWork> hehe
02:10:33 <agentzh> a newbie question: how to pop the last elem from a list?
02:10:43 <agentzh> pop = reverse . tail .reverse ?
02:10:48 <agentzh> any better solution?
02:11:33 <vixey> pop = tail
02:11:56 <osfameron> no it's not
02:12:00 <Saizan> agentzh: init
02:12:06 <Saizan> > init [1..5]
02:12:09 <lambdabot>  [1,2,3,4]
02:12:16 <vixey> > tail [5,4,3,2,1]
02:12:17 <lambdabot>  [4,3,2,1]
02:12:34 <BeelsebobWork> agentzh: the possibly more useful answer is that if you're doing stuff with the end of a list, you're doin it rong ;)
02:12:41 <BeelsebobWork> lists are efficient to play with their heads
02:12:45 <BeelsebobWork> not to play with their tails
02:12:50 <agentzh> Saizan: thanks
02:13:02 <BeelsebobWork> so, either consider using the list the other way round
02:13:07 <BeelsebobWork> or using a different data structure
02:13:09 <agentzh> BeelsebobWork: ahh...yes...but i'm doing some string processing stuff in haskell :P
02:13:25 <BeelsebobWork> agentzh: so possibly you want to use Data.ByteString
02:13:45 <Twey> Unicode?
02:13:51 <agentzh> BeelsebobWork: already using :)
02:13:56 <BONUS> if you have a list as a stack its best to use the head of the list as the top of the stack
02:14:16 <BONUS> so i'd say: pop = head &&& tail
02:14:16 <agentzh> BeelsebobWork: first B.split a bytestring, obtaining a list of bytestrings, and get the last to check for something
02:14:41 <agentzh> BeelsebobWork: essentially splitting '/foo/bar.yml' and trying to recognize the suffix .yml
02:15:13 <BeelsebobWork> fair enough
02:15:14 <agentzh> BONUS: hmm, it makes sense :)
02:16:08 * agentzh is still thinking in perl's way :P
02:16:32 * vixey was obviously being far too subtle to get any information across
02:16:43 <agentzh> not sure if it'll be faster to use a pcre binding.
02:17:13 <agentzh> merely got the impression doing regexes could be slow :)
02:17:27 <Axman6> @src init
02:17:27 <lambdabot> init [x]    = []
02:17:27 <lambdabot> init (x:xs) = x : init xs
02:17:27 <lambdabot> init []     = undefined
02:18:35 <BeelsebobWork> is it possible to get easily from a LazyByteString to a ByteString?
02:20:41 <Saizan> BeelsebobWork: B.concat . L.toChunks
02:20:58 <BeelsebobWork> ah, cheers -- it turned out I could work entirely in LBS anyway, but that's useful
02:21:08 <Saizan> but it's not cheap
02:26:25 * Shiruka muses that pcres don't have enough functionality yet
02:26:38 <Shiruka> nocut operator, it's still not quite prolog
02:27:04 <Svrog> is there a way to cleanly remove a cabal package that doesn't involve manually deleting all directories and files belonging to that package?
02:28:39 <Saizan> Svrog: no, and remember to unregister it
02:29:02 <Svrog> yeah i've already unregistered it but that always leaves all the files
02:30:40 <vixey> Shiruka: you should the perl 6 regexs
02:30:49 <vixey> it's something else
02:31:49 <Shiruka> weren't they supposed to be real parsers?
02:44:59 <ttt--> hi, are there any guides online for writing a simple type checker?
02:45:16 <ttt--> or things i can read about that explain it a bit
02:45:23 <pejo> ttt, "Typing Haskell in Haskell".
02:46:48 <vixey> ttt--: Also, http://rascal-haskell.googlecode.com/svn/trunk/Typecheck.hs
02:48:19 <ttt--> thanks
02:48:27 <pejo> ttt, there's a longer version of the article on Mark Jones's homepage, with updated code for multiparameter typeclasses too.
02:52:42 <ttt--> http://web.cecs.pdx.edu/~mpj/thih/ this one?
02:52:43 <lambdabot> Title: Mark P Jones: Typing Haskell in Haskell
02:57:00 <ayianus> =/
02:58:21 <pejo> ttt, yes.
03:06:49 <Mitar> is it possible to (mis)use list comprehensions notation for a builid of a set? or set represented by a list? (so that if an already existing element is generated again an error is raised?)
03:07:46 <MyCatVerbs> Mitar: you can quite happily use Data.Set's fromList.
03:08:10 <MyCatVerbs> Mitar: if you want to use list comprehensions to build a set that can be efficiently manipulated, I mean.
03:08:57 <Mitar> in fact I would only need to detect duplicates
03:09:00 <MyCatVerbs> Mitar: you *can* use lists as sets, directly (there're various functions in Data.List that support this kind of use) but many operations on sets defined thus are very inefficient.
03:09:23 <MyCatVerbs> Mitar: do you care if elements might come out in a different order to the one you put them in? If not, use Data.Set.
03:09:29 <Mitar> but probably this detecting is best done with an implementation of a set ... then traversing the list over and over again
03:10:55 <MyCatVerbs> Mitar: trust me, use Data.Set. For one thing, it's a lot easier, since you don't have to keep the requisite invariants straight in your head.
03:11:10 <Mitar> true ...
03:13:09 <MyCatVerbs> Especially importantly, the operations you'll want to perform have sensible names and implementations, rather than relying on incidental properties of the list structure. That alone is worth a Hell of a lot. :)
03:14:59 <MyCatVerbs> (e.g. compare (any (==e) list) to (member e set), for checking for a particular element -- the latter is both clearer and more efficient (O(log(n)) rather than O(n)).
03:15:13 <MyCatVerbs> Oops, unbalenced parens.)
03:15:53 <oldsalt> @seen chrisdone
03:15:53 <lambdabot> chrisdone is in #haskell. I last heard chrisdone speak 1h 46m 37s ago.
03:16:54 <chrisdone> hey
03:17:18 <oldsalt> hi, does your opensearch thing work with internet exploder?
03:18:33 <chrisdone> well, let me see
03:19:55 <chrisdone> oldsalt: it may do, I don't have IE so I can't test it. if you have time and test it, I'd be grateful if you told me
03:26:06 <RayNbow> @seen dons
03:26:07 <lambdabot> dons is in #arch-haskell, #xmonad, #ghc and #haskell. I last heard dons speak 4h 21m 12s ago.
03:26:46 <BeelsebobWork> Why would a program running using +RTS -p generate a .prof file with nothing in it?
03:29:21 <oldsalt> chrisdone, ok, i will try it later. if it works fine, may we publish it on the hayoo page? we have our own opensearch plugin but it seems to have a major bug
03:29:23 <camaiocco> BeelsebobWork: because it was not remade completely with profiling ?
03:29:40 <BeelsebobWork> ghc --make -prof -auto-all Test
03:29:51 <BeelsebobWork> and it didn't complain about any libraries not having profiling code
03:29:53 <camaiocco> rm *.o
03:30:27 <camaiocco> or ghc --force something
03:30:31 <BeelsebobWork> same result
03:30:57 <chrisdone> oldsalt: sure! I just whipped it up from the opensearch guide on mozilla's site, no guarentees :P
03:31:19 <chrisdone> er, guarantee*
03:32:21 <camaiocco> touch *.hs
03:33:00 <camaiocco> don't know really, just guessing :-/
03:33:24 <oldsalt> ok, thanx. it might not be worse than ours that sends the user into a non-terminating javascript loop ;)
03:40:00 <BeelsebobWork> so no one has any ideas why this is happening? http://hpaste.org/9262
03:44:59 <Baughn> BeelsebobWork: What ghc version?
03:45:06 <BeelsebobWork> 6.9
03:45:26 <BeelsebobWork> specifically... The Glorious Glasgow Haskell Compilation System, version 6.9.20080615
03:45:38 --- mode: ChanServ set +o dibblego
03:45:38 <Baughn> Ah. Er, I can't help but think "Try 6.8.3 first"
03:45:45 <BeelsebobWork> yeh, can't do that
03:45:50 --- topic: set to '["Haskell: precision engineering for programmers", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org ", "Logs: http://tunes.org/~nef/logs/haskell/"]' by dibblego
03:45:54 <BeelsebobWork> using one of conal's libraries that needs 6.9 to compile
03:45:56 --- mode: dibblego set -o dibblego
03:46:36 <Baughn> BeelsebobWork: Okay. Does the profiler work with /any/ programs?
03:46:43 <BeelsebobWork> good question
03:48:01 <BeelsebobWork> yes
03:48:16 <chrisdone> wow, server-start in emacs is awesome for "collaborative" coding
03:48:19 <BeelsebobWork> I got a profile for main = print $ reverse $ take 100000 [1..]
03:48:22 <chrisdone> oldsalt: hehe
03:48:36 <Baughn> Right, right.. what sort of library are you using, that only works with 6.9?
03:48:55 <BeelsebobWork> vector-space
03:49:01 <chrisdone> hey Baughn, what happened to monkey boy?
03:49:04 <BeelsebobWork> and Field Trip
03:49:19 <Baughn> BeelsebobWork: Oh, and note that some sorts of abnormal exits (like calling _exit() (*shakes fist at LB)) will usually prevent the profile from being written
03:49:45 <BeelsebobWork> ah, *ponders if selecting quit from a Mac OS GUI counts as an abnormal exit*
03:49:51 <Baughn> chrisdone: It got moved, and I haven't had the opportunity to get to my university and fix it
03:49:56 * BeelsebobWork ponders how to exit it in a different way
03:50:01 <chrisdone> Baughn: ah, oki
03:50:08 <Baughn> chrisdone: Needs a complete OS re-install too. LVM is badly broken.
03:50:23 <chrisdone> Baughn: what's LVM?
03:50:34 <Baughn> chrisdone: Logical volume management.. a linux thing
03:50:42 <chrisdone> Baughn: ok
03:51:08 <Baughn> I'm not entirely sure what happened there, to be honest. *Something* is stopping it from mounting any partitions.
03:51:48 <Baughn> BeelsebobWork: Selecting exit from a mac os GUI invokes exit(), iirc, unless you've got a handler set up
03:52:09 <Baughn> BeelsebobWork: I doubt ghc does. The question is, has it used atexit() appropriately?
03:52:22 <BeelsebobWork> lame -- any idea how to get it to exit in a way that the RTS likes Baughn?
03:53:19 <Baughn> BeelsebobWork: Sure. Override cocoa's exit function, have it invoke some IO function that does whatever needs doing to exit cleanly.
03:54:07 <BeelsebobWork> well, first up, it's a GLUT app, which I guess means cocoa in the end -- but no cocoa code anywhere atm... and I'm not sure what "whatever needs doing" is
03:54:44 <Baughn> BeelsebobWork: Well, /that/ depends on your app. If you have a main loop of some sort, sending a signal (of some sort) to it to have it exit would be the thing..
03:54:54 <BeelsebobWork> ah, k
03:54:57 <Baughn> Anyhow, something that makes your main=.. thread exit
03:55:03 <Baughn> That is to say, return
03:55:05 <BeelsebobWork> ah, I see
03:55:17 <BeelsebobWork> so find the glut function for killing the mainLoop
03:55:23 <Baughn> BeelsebobWork: Oh, and you'll probably want to use the objective-C C api
03:55:41 <Baughn> BeelsebobWork: Actually, do a sanity check first
03:55:48 <BeelsebobWork> hmm?
03:55:59 <Baughn> BeelsebobWork: Insert a print after the call to mainLoop. Then quit your app. See if the print gets executed.
03:56:07 <Baughn> If it does, then glut's /already/ handling it
03:57:15 <BeelsebobWork> yeh, it doesn't get printed :/
03:58:07 <BeelsebobWork> glutMainLoop enters the GLUT event processing loop. This routine should be called at most once in a GLUT program. Once called, this routine will never return. It will call as necessary any callbacks that have been registered.
03:58:08 <BeelsebobWork> >.<
03:58:30 <Baughn> Well, that's interesting..
03:58:43 <Baughn> BeelsebobWork: OKay. Solution: forkIO glutMainLoop
03:59:06 <BeelsebobWork> that's not gonna work -- it needs to do the rendering on the main thread
03:59:10 <Baughn> Then you just have to prevent main from returning until you want it to. Have it takeMVar quitSignal or something
03:59:15 <BeelsebobWork> (OpenGL on non-main-thread == death)
03:59:41 <Baughn> Haskell threads, or OS threads?
03:59:45 <EvilTerran> it works in a bound thread as well, doesn't it?
03:59:47 <BeelsebobWork> oh, good point
04:00:09 <Baughn> I don't think there's any guarantee that your main=.. thread is actually a bound thread
04:00:21 <Baughn> And I imagine /that's/ the critical point here; that all opengl calls must be from the same OS thread
04:00:38 <Baughn> So you'll want to forkOS before doing /anything/ opengl related, or else compile without -threaded
04:01:11 <MyCatVerbs> Baughn: or use runInBoundThread everywhere and watch your performance drop like a stone. :)
04:01:11 <BeelsebobWork> hmm, that's not quite working -- it now runs the print statement
04:01:15 <BeelsebobWork> but it also doesn't exit
04:01:18 <BeelsebobWork> or write the profile
04:02:16 <Baughn> Hold it. Is there anything /but/ the print after your forkOS?
04:02:32 <Baughn> Actually, please paste your main code
04:03:54 <Baughn> BeelsebobWork: You know?
04:04:01 <Baughn> BeelsebobWork: I think the solution to this is to not use glut
04:04:40 <Baughn> Cocoa has its own, relatively simple way to grab an opengl context. You could use that instead, and I don't think you can control the way glut exits.
04:07:14 <Baughn> BeelsebobWork: http://developer.apple.com/documentation/Cocoa/Reference/ObjCRuntimeRef/Reference/reference.html <-- Ah. That's what I was trying to find
04:07:15 <lambdabot> Title: Objective-C 2.0 Runtime Reference, http://tinyurl.com/6h3chj
04:07:36 <Baughn> That's what you need to use cocoa via the haskell ffi functions
04:08:50 <MyCatVerbs> Baughn: hang on, the FFI doesn't include ObjC message sending, does it?
04:08:58 <Baughn> MyCatVerbs: Nope
04:09:21 <Baughn> Though implementing it might be useful.. but objc_msgSend is a /C/ function. ;)
04:09:32 <MyCatVerbs> Baughn: ahhhh.
04:10:03 <MyCatVerbs> Baughn: huh. I thought it was considered sinful (exposing implementation details, natch) to do that directly.
04:10:03 <Baughn> "This reference is useful primarily for developing bridge layers between Objective-C and other languages, or for low-level debugging. You typically do not need to use the Objective-C runtime library directly when programming in Objective-C." <-- From the overview section of that link
04:10:19 <Baughn> MyCatVerbs: Not if you're foresighted enough to realize people will be writing FFIs
04:11:47 <MyCatVerbs> Baughn: sane. I was expecting you'd have to write a pile of callable-as-C stubs to fire the invocations off for you.
04:12:21 <chrisdone> that's cool
04:12:41 <Baughn> MyCatVerbs: Obj-c's rather more dynamic than that. And it has sufficient reflection that you don't need to, but..
04:12:54 <Baughn> I suspect using this api /may/ be slower than writing the aforementioned stubs
04:13:22 <Baughn> "When it encounters a method call, the compiler generates a call to one of the functions objc_msgSend, objc_msgSend_stret, objc_msgSendSuper, or objc_msgSendSuper_stret. " <-- Uh, I guess not.
04:13:23 <MyCatVerbs> Baughn: depends, I guess, how much work those stubs are doing.
04:14:15 <MyCatVerbs> Baughn: I mean, if you're invoking a stub for each and every single message send, then you lose, because you have FFI call + stub's frame buildup+teardown + message send.
04:14:19 <Baughn> MyCatVerbs: This thing is complete enough that writing a good haskell-objc ffi should be fairly easy
04:14:27 <MyCatVerbs> Baughn: versus FFI call directly into message send.
04:14:31 <Baughn> MyCatVerbs: Right, and the stub would go on to call objc_msgSend /anyway/
04:14:53 * Baughn ogles class_addMethod
04:15:45 <vixey> which thing?
04:16:03 <vixey> The biggest problem with writing an obj-c bridge is that c2hs -doesn't work-
04:16:15 <MyCatVerbs> Baughn: whereas if you're writing longer stubs that do more (like plausibly you might have operations involving say a couple dozen message sends which aren't useful to expose seperately to the Haskell side) then you amortize both the FFI invocation and stack frame cost over a number of objc_msgSend calls, saving CPU time.
04:16:32 <Baughn> vixey: ;_;
04:17:27 <Baughn> MyCatVerbs: That's assuming the ffi invocation costs more than a function call in C would
04:18:10 <MyCatVerbs> Baughn: IIRC FFI invocations are somewhat expensive for some reason.
04:19:03 <hackage> Uploaded to hackage: applicative-extras 0.1
04:19:29 <Baughn> MyCatVerbs: Doesn't surprise me
04:19:40 <Baughn> vixey: But, c2hs doesn't work? When did that get broken?
04:21:32 <vixey> Baughn: I don't really know, I had to hack the parser to get it to strip out c99 comments and even after that it wouldn't handle #defines
04:21:54 <vixey> maybe I was using it completely wrong, but  I don't think so
04:22:02 <Baughn> Run it through cpp first?
04:22:20 <vixey> yeah I tried that but it still chocked
04:29:19 <Baughn> vixey: You were using 0.15.1?
04:29:32 <Baughn> vixey: That version claims explicitly to support all of C99, so this sounds odd
04:30:05 <vixey> the one I tried definitely didn't support // comments, this was a while ago though
04:30:24 <Baughn> How long ago? 0.15.1 is dated november 2007
04:55:43 <BONUS> ghc moving to hg or git
04:55:43 <BONUS> w00t!
04:55:59 <chrisdone> from darcs?
04:56:02 <Saizan> really?
04:56:22 <BONUS> yeah
04:56:30 <BONUS> http://hackage.haskell.org/trac/ghc/wiki/DarcsEvaluation
04:56:34 <lambdabot> Title: DarcsEvaluation - GHC - Trac
04:56:38 <BONUS> i hope they move to hg
04:56:48 <chrisdone> BONUS: for what reason?
04:57:02 <BONUS> no special reason other than i think its superior to git
04:57:10 <Zao> Of course all issues can be fixed by changing tools, instead of policy.
04:57:22 <Baughn> vixey: Do you happen to be on a mac?
04:57:26 <vixey> yes
04:57:37 <chrisdone> zao: issues like speed can
04:57:45 <Baughn> ..because I can't help but notice that the apple-supplied cpp does not, in fact, preprocess correctly
04:57:46 <_zenon_> Anyone knows a good library for http traffic involving GET, POST, and other such methods ?
04:57:55 <Baughn> It leaves comments, ifdefs and whatnot in the output
04:58:00 <chrisdone> _zenon_: there are one or two on Hackage
04:58:09 <vixey> Baughn: oh that sucks, I guess that is the problem then
04:58:15 <chrisdone> _zenon_: Network.HTTP, Curl, uh..
04:58:19 <Baughn> vixey: I'm going to try installing fink's
04:58:20 <pjdelport> chrisdone: are you familiar with git or hg?
04:58:21 <_zenon_> chrisdone, thanks, I'll look em up
04:58:32 <Baughn> vixey: If that works.. well, guess that makes it time to look for a standalone
04:58:34 <chrisdone> pjdelport: I've used git
04:58:42 <chrisdone> pjdelport: why?
04:58:43 <vixey> Baughn: ok, I am interested in if that fixes it
04:58:44 <BeelsebobWork> Baughn: Svrog just came up with a really neat solution... http://hpaste.org/9264
04:58:50 <vixey> so do tell me what happens
04:59:00 <vixey> I was probably a bit quick to blame c2h
04:59:02 <vixey> s
04:59:15 <Baughn> BeelsebobWork: It's a bit of a hack, but yes, that should work
04:59:36 <Baughn> BeelsebobWork: The problem is that if it terminates normally, you may end up calling hsExit /twice/
04:59:49 <pjdelport> chrisdone: ok; comparing the two, hg is generally cleaner and simpler than git
04:59:50 <BeelsebobWork> true
05:00:15 <Zao> I would expect git failing rather hard on any non-gnuy unix.
05:00:45 <BONUS> its implementation uses a lot of unix only stuff
05:00:52 <BONUS> like inodes and stuff
05:01:33 <pjdelport> Zao: git works fine on BSD and other unixes
05:01:59 <Zao> pjdelport: AIX?
05:02:02 <pjdelport> not quite as well on Windows and such, though
05:02:15 <Zao> Non-gcc compilers?
05:02:42 <pjdelport> Zao: no idea
05:03:01 <chrisdone> pjdelport: I generally looked at them both and tried out git because of github
05:03:03 <Zao> Since AIX is one of the GHC platforms, that's a rather important issue, I'd say.
05:03:18 <chrisdone> pjdelport: it's great to have a free place to share code
05:03:29 <chrisdone> pjdelport: and I like the forking mentality
05:03:44 <pjdelport> chrisdone: define "forking mentality"?
05:04:01 <BONUS> forking is really really easy with both hg and git
05:04:10 <BONUS> you just pull a repo and then push to your local repo
05:05:44 <_zenon_> chrisdone, thanks :)
05:05:55 <_zenon_> chrisdone, seems like just the thing I was looking for
05:06:23 <chrisdone> _zenon_: cool
05:07:11 <chrisdone> pjdelport: users can make projects, and “fork”, that is, branch someone else' repository as their own and start working on it, and request people pull from them, etc.
05:07:26 <Baughn> vixey: No need for fink, actually
05:07:28 <Baughn> vixey: c2hs -C "-x c" -c cpp-4.2 works; you may or may not have been supplied with cpp-4.2 by apple yet, but it's the one you need. Go upgrade xcode (or your OS?) if you haven't, I guess..
05:07:53 <pjdelport> chrisdone: that's true of any distributed RCS, though
05:08:29 <chrisdone> pjdelport: yes. I was referring to the web site itself
05:08:47 <pjdelport> ah, ok
05:08:59 <Saizan> BONUS: isn't that just like darcs?
05:09:10 <BONUS> well yeah they're all distributed
05:09:28 <BONUS> the ghc team says they're moving from it because its slow and buggy
05:11:37 <chrisdone> I split up The Complete Lojban Language into about 200 files and changed them all, then recorded the change with git, then applied it on a copy repo. took like a second. pretty fast
05:12:13 <chrisdone> (big book is big: http://jbotcan.org/cllc/)
05:12:14 <lambdabot> Title: The Lojban Reference Grammar
05:13:03 <Axman6> @pl (fac n) `div` ((fac r) * fac (n-r))
05:13:03 <lambdabot> fac n `div` (fac r * fac (n - r))
05:13:08 <Axman6> lame
05:13:18 <EvilTerran> @pl \n r -> (fac n) `div` ((fac r) * fac (n-r))
05:13:19 <lambdabot> ap ((.) . div . fac) (liftM2 (*) fac . (fac .) . (-))
05:13:24 <EvilTerran> don't do that
05:13:28 <Axman6> heh
05:13:37 <EvilTerran> ?type \n r -> (fac n) `div` ((fac r) * fac (n-r))
05:13:50 <EvilTerran> wait, fac won't be in scope. nvm.
05:13:52 <lambdabot> thread killed
05:14:33 <Axman6> ah yes
05:14:51 <Axman6> let fac n = fac' n 1 where fac' n t | n < 2 = t | otherwise = fac' (n-1) (n*t)
05:14:55 <Axman6> > let fac n = fac' n 1 where fac' n t | n < 2 = t | otherwise = fac' (n-1) (n*t)
05:14:55 <lambdabot>  Parse error at end of input
05:15:05 <Axman6> you're a parse error
05:15:22 <chrisdone> "yeah well your face!"
05:15:33 <Axman6> ...james?
05:15:49 <EvilTerran> curry (uncurry div . (fst &&& (uncurry (*) . (fac . snd &&& fac . uncurry (-)))))
05:15:59 <EvilTerran> @let fac n = product [1..n]
05:16:00 <lambdabot> Defined.
05:16:04 <EvilTerran> ?type \n r -> (fac n) `div` ((fac r) * fac (n-r))
05:16:05 <lambdabot> forall t. (Integral t) => t -> t -> t
05:16:08 <EvilTerran> ?type curry (uncurry div . (fst &&& (uncurry (*) . (fac . snd &&& fac . uncurry (-)))))
05:16:09 * Botje hrmpfs
05:16:09 <lambdabot> forall a. (Integral a) => a -> a -> a
05:16:13 <EvilTerran> :D
05:16:17 <Botje> 3500 haskell-cafe mails.
05:16:26 <Botje> one hour to read them . :)
05:16:49 <SamB_XP_> Botje: clearly, you can't read them all
05:18:01 <Botje> indeed
05:18:04 <Botje> OR CAN I.
05:18:13 <chrisdone> Axman6: my name is chris
05:18:23 <_zenon_> I mostly grab the ones which contain words like {category theory, monads, yi}
05:18:30 <_zenon_> How do you select the ones?
05:18:40 <Axman6> that was the exact response my friend james would've made to me saying that
05:19:03 <Axman6> and then something about how ugly my ears are (my argument being that ears aren't part of the face)
05:19:03 <hackage> Uploaded to hackage: formlets 0.1
05:19:30 <chrisdone> dats grate
05:20:06 <chrisdone> Botje: heh, I have loads of haskell-cafe mounting up in my gmail inbox
05:20:24 <SamB_XP_> I've unsubscribed ;-)
05:21:15 <chrisdone> well, not my inbox. I setup a gmail filter so it gets tagged "haskell cafe" and gets marked as read, skip inbox :)
05:21:36 <Zao> BONUS: Ho-ho. The git scripts assumes that the ld understands -R
05:21:37 <chrisdone> no, not marked as read. just skip inbox. ja
05:21:41 <Baughn> "cabal configure --c2hs-options='cpp-4.2 -c -xc -C'" <-- Okay, why exactly do I need to put c2hs's arguments /in reverse order/?
05:21:42 <Zao> Err, makefiles.
05:22:22 <Botje> fuck it
05:22:23 <dcoutts> Baughn: hmm, looks like a bug
05:22:23 <pjdelport> platform agnosticism is definitely something strongly in hg's favor
05:22:24 * Botje mark all read
05:22:50 <dcoutts> Baughn: please report it with all details to reproduce, including cabal --version  output
05:23:05 <dcoutts> Baughn: http://hackage.haskell.org/trac/hackage/
05:23:07 <lambdabot> Title: Hackage - Trac
05:23:27 <dcoutts> @ask dons did you report the Cabal problem with meta-packages? http://hackage.haskell.org/trac/hackage/
05:23:27 <lambdabot> Consider it noted.
05:24:21 <Axman6> wow... J is messed up
05:24:30 <vixey> I like J
05:24:38 <SamB_XP_> Axman6: not messed up -- just crazy ;-)
05:24:43 <Baughn> dcoutts: Meh. It doesn't seem to want to let me report anything - no TICKET_CREATE privileges for guest users, I guess
05:24:47 <Axman6> +/1e6<,!/~>:i.100 <-- calculates the number of nCr numbers greater than 1,000,000
05:24:55 <SamB_XP_> Baughn: log in
05:25:04 <Baughn> SamB_XP_: Clicking on "login" does nothing
05:25:14 <dcoutts> Baughn: log in with the guest account, or create your own. The instructions are on the front page.
05:25:21 <SamB_XP_> okay, that's a problem!
05:25:48 <Baughn> ..correction. Trac (at least that error page) does not return a no-cache header
05:26:04 <Baughn> I'll see if it's fixed in head first, though
05:29:35 <SamB_XP_> http://arcanux.org/lambdacats_3.html#entry5
05:29:36 <lambdabot> Title: Lambdacats
05:29:45 <SamB_XP_> these guys need permalinks ...
05:30:21 <ddarius> Take the link of the image itself?
05:30:30 <gwern> @seen lispy
05:30:31 <lambdabot> lispy is in ##logic, #haskell-blah, #darcs, #ghc and #haskell. I last heard lispy speak 6h 52m 3s ago.
05:30:38 <SamB_XP_> ddarius: misses out on the text above it!
05:33:01 <sal23> aren't GHC's rewrite rules equivalent of Lisp programmatic macros?
05:33:10 <vixey> sa123: no
05:33:29 <SamB_XP_> heck no
05:33:49 <sal23> vixey: why not? aren't they manipulating the code programmatically?
05:33:56 <gwern> goodness no. they are nowhere near as powerful, and they only work function->function, not lisp's anything->anything
05:34:01 <vixey> sa123: they are but it's nothing like lisp
05:34:14 <gwern> sal23: have you read the rules paper?
05:34:26 <sal23> well, I didn't mean the complete one-to-one mapping.....what I meant was subset
05:34:38 <sal23> gwern: which rules paper are you talking about?
05:34:42 <gwern> sal23: rewrite rules were specifically designed to be weak and simple; spj &etc. discuss what they can't do
05:34:48 <vixey> sa123: thinking about it in terms of lisp is not a good mental model
05:35:08 <mez_> hey peoples.. I'm trying to have an application automatically open an application in a chosen Desktop like Desktop 2 instead of normal Desktop 1...can anyone direct me to the right area ?
05:35:25 <SamB_XP_> on the other hand, lisp's macros don't make a good replacement for GHC's rewrite rules either
05:35:44 <gwern> sal23: well, 'Playing By The Rules: Rewriting as a Practical Optimization technique in GHC' is the one I am thinking of
05:35:52 <gwern> since I just read it a few days ago
05:36:02 <cnwdup> fs :: [Object -> Parser Object], o :: Object. How can I apply o to every element of fs resulting in a new list fs' of type [Parser Object]?
05:36:08 <SamB_XP_> mez_: uh ... see your window manager documentation?
05:36:10 <sal23> thanks, gwern....I will read it today
05:36:24 <wjt> cnwdup: map ($ o) fs
05:36:27 <sal23> SamB_XP_: can you explain more....
05:36:31 <wjt> cnwdup: equivalently, map (\f -> f o) fs
05:36:32 <ddarius> Rewrite rules can depend on types
05:36:34 <gwern> mez_: didn't I cover that question in #xmonad? or was that someone else...
05:36:44 <mez_> SamB: yeah been looking and reviewing.. just wondering if that sort of functionality is commonly possible
05:36:48 <cnwdup> wjt: Thanks. (-:
05:37:01 <mez_> gwern: not for me.. i tried to join that channel but couldnt
05:37:09 <SamB_XP_> mez_: can't see why not
05:37:17 <gwern> mez_: short answer, if it's xmonad, look into the managehooks which can match on class or title and move to a specific workspace
05:37:26 <SamB_XP_> mez_: try registering with nickserv?
05:37:29 <gwern> mez_: you can find many examples in xmonad.hss on the wiki
05:37:39 <mez_> ok thanks
05:38:03 <gwern> mez_: any other wm, I dunno, although the external program xtoolwait can sometimes be hacked together with wm functionality to approximate the same functionality from 'outside' the wm
05:38:42 <ddarius> cnwdup: Also sequence
05:44:13 <gwern> GHC has decided to stop using darcs?
05:44:52 <gwern> shoot. that may be the nail in the coffin for darcs, if it kicks off a feedback cycle
05:44:53 <chrisdone> gwern: that seems to be the conensus
05:45:40 <gwern> http://hackage.haskell.org/trac/ghc/wiki/DarcsEvaluation
05:45:41 <lambdabot> Title: DarcsEvaluation - GHC - Trac
05:45:42 <chrisdone> gwern: you mean if people follow their lead start using other SCMs in their haskell projects?
05:45:42 <Zao> BONUS: Oh well, with a little laying on hands on the build system, git builds on AIX with vacpp. Good enough for me.
05:45:50 <ivanm> what are they going to use instead then?
05:46:04 <chrisdone> ivanm: looks like gh or git
05:46:13 <chrisdone> ivanm: er, hg
05:46:20 <ivanm> heh, about to say...
05:46:22 <chrisdone> sudo gem install technomancy-conspire --source=http://gems.github.com
05:46:22 <lambdabot> Title: GitHub RubyGems
05:46:37 <chrisdone> er, okay, ignore that. somehow cleaning my mouse pasted my clipboard
05:46:44 <SamB_XP_> pretty decent choices, at least I hear hg is decent
05:46:46 <chrisdone> ·_.
05:47:09 <SamB_XP_> maybe the darcs-git thing will be revived?
05:47:18 <chrisdone> what's that?
05:47:32 <SamB_XP_> the one where darcs can use git repositories ?
05:48:08 <SamB_XP_> not quite sure what it could do with them, but...
05:48:11 <ivanm> though I wonder how hg can really compare to git, etc. in terms of speed if it's written in python...
05:48:31 <SamB_XP_> ivanm: I really don't think that's an issue
05:48:39 <ivanm> *nod*
05:49:04 <SamB_XP_> git speed, afaik, has little to do with the use of C (other than as opposed to shell)
05:49:32 <ivanm> though from my admittedly limited reading of hg and git, gits way of recording changes seems closer to darcs' patch system (i.e. record changes everywhere, not just per file)
05:49:49 <SamB_XP_> actually git does not record changes at all
05:50:20 <ivanm> oh?
05:50:23 <SamB_XP_> it is, as they put it, a stupid content tracker
05:51:00 <ivanm> as in it stupidly tracks content, or tracks stupid content? :p
05:51:13 <SamB_XP_> stupidly tracks content
05:51:40 <ivanm> *nod*
05:51:59 <SamB_XP_> this radically simplifies the repository model
05:52:21 <ivanm> I've never really understood this... what makes darcs so unweildy that people like ghc are leaving it?
05:52:43 <ivanm> the actual implementation, or the entire theory of patches not working properly?
05:52:55 <SamB_XP_> the theory of patches seems to be slow
05:52:57 <gwern> ivanm: the patch theory is kind of abstruse, and the code quality is horrible
05:53:02 <idnar> ivanm: it's a combination of both, I think
05:53:03 <pejo> ivanm, the homepage gwern linked to has a bunch of reasons.
05:53:06 <gwern> between the two, that's enough
05:53:07 <ivanm> *nod*
05:53:12 <ivanm> the DarcsEvaluation one?
05:53:12 <idnar> patch theory is great when it does the right thing, but it makes it harder to do the wrong thing
05:53:16 <ivanm> lol
05:53:20 <idnar> of course, in an ideal world, you wouldn't ever do the wrong thing
05:53:42 <idnar> but in the real world, it's sometimes easier to just quickly do the wrong thing and make it work, rather than jumping through a million hoops
05:54:07 <Axman6> :type nubBy
05:54:09 <idnar> and of course, sometimes the "right" thing is actually the wrong thing, because darcs's patch theory is still based on textual merges
05:54:13 <Axman6> @type nubBy
05:54:13 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
05:54:18 <Axman6> @src nubBy
05:54:18 <lambdabot> nubBy eq []             =  []
05:54:18 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
05:54:36 <Shiruka> from a totally user POV (which I'm sure doesn't weigh more than a huge balloon filled with helium here :-), it's somewhat nicer not to have to do --partial checkouts
05:54:49 <idnar> but the actual implementation suffers from some performance and usability issues, and also the problem that there aren't that many darcs developers
05:55:04 <SamB_XP_> I think something like darcs would be nice layered on top of git ... for dealing with changes that haven't hit the branch yet
05:55:20 <idnar> having said all of that, darcs is an integral part of my workflow for many projects, and I'm highly unlikely to abandon it any time soon
05:55:29 <gwern> I don't think the wrong thing is really the issue. the problem is that darcs is hit from above and below by problems: it's hit from above because as the page says not many people understand patch theory, so you get inefficiencies and problems from that direction; and then you get problems from below, implementation problems, caused by the code, minimal use of libraries, & roundy's idiosyncrasies and preferences
05:55:36 <SamB_XP_> Shiruka: darcs 2's "hashed" format also has that advantage
05:55:46 <idnar> but darcs certainly isn't for everyone at the moment
05:55:53 <SamB_XP_> Shiruka: and is a lot less buggy
05:55:59 <gwern> I mean, the code to download patches from URLs is some of the worst haskell production code I've seen
05:56:00 <SamB_XP_> (than --partial)
05:56:25 <gwern> it drives me nuts to look at
05:56:49 <SamB_XP_> worse than the first working version of @google ?
05:56:51 <gwern> and IMO roundy has wasted a lot of time on autotools, backwards compability, the darcs manual, and experiments like type witnesses
05:57:11 <ivanm> there's a manual? :o
05:57:23 <gwern> SamB_XP_: I've never seen any @googles, so who knos
05:57:27 <SamB_XP_> I don't think it's fair to call the witness types a "waste of time"
05:57:31 <SamB_XP_> @google gwern
05:57:32 <lambdabot> No Result Found.
05:57:32 <ivanm> "Merging, when it works, is done right in darcs. " <-- heh
05:57:36 <idnar> ivanm: http://darcs.net/manual
05:57:37 <lambdabot> Title: Darcs 2.0.2 (+ 8 patches) Darcs
05:57:40 <SamB_XP_> gwern: oh noes
05:57:43 <SamB_XP_> it can't find you
05:57:48 <idnar> uh.
05:57:55 <ivanm> gwern: sorry, but it looks like you don't exist...
05:58:18 <gwern> ivanm: I do exist! I thought I did...
05:58:25 <SamB_XP_> ivanm: uh, you're getting yourself mixed up with that library lady from star wars
05:58:37 <SamB_XP_> ivanm: who is, to put it mildly, insane
05:59:09 <gwern> SamB_XP_: the who?
05:59:48 <gwern> jocasta nu? I don't remember her as being insane
05:59:51 <SamB_XP_> gwern: attack of the clones, wasn't it, when the library lady said that since some planet wasn't in the archives it clearly did not exist?
06:00:15 <SamB_XP_> that kind of thinking is a sign of insanity in librarians
06:00:50 <gwern> oh, her. hm; but there is a point at which someone is moer likely to be wrong or mistaken than the database to be incomplete
06:01:08 <ivanm> SamB_XP_: ummmm, what?
06:01:14 <ivanm> oh, wait, _that_ one
06:02:00 <SamB_XP_> she should have said "probably"!
06:07:47 <ddarius> If you can't find it, it doesn't exist; reality notwithstanding.
06:08:22 <SamB_XP_> ddarius: so, that includes my homework ?
06:08:28 <ddarius> Yes.
06:08:39 <SamB_XP_> if I can't find an assigment, I don't need to do it, because it doesn't exist?
06:09:02 <SamB_XP_> ... does that work even if I could get another copy online?
06:09:03 <gwern> ignorance of the law is a defense?
06:09:07 <ddarius> No, if you can't find your teacher can find your homework you get an F regardless of whether it exists.
06:09:10 <sjanssen> gwern: other than GHC, who else uses darcs?
06:09:30 <ivanm> sjanssen: xmonad does, doesn't it? :p
06:09:32 <ddarius> s/you can't find//
06:09:37 <ddarius> +'t
06:09:38 <gwern> sjanssen: most haskellers
06:09:59 <Shiruka> SamB_XP_: the reason you can't find an assignment is that hanging out on #haskell makes assignments disappear for you
06:10:08 <wjt> sjanssen: most of the Telepathy stack has used darcs so far, but that'll probably come to an end soon, as it seems that migrating to darcs2 is no easier than migrating to a mainstream VCS
06:10:36 <gwern> although goerzen has migrated, monnier uses cvs, and the sessions guy uses mercurial
06:10:48 <ddarius> cvs?!
06:11:00 <gwern> wjt: what's hard about migrating to darcs2?
06:11:26 <pjdelport> ivanm: hg (and other VCSes) are overwhelmingly IO-bound
06:11:28 <gwern> ddarius: yes. that's why I always use distro emacs-mode, even though cvs emacs-mode fixes lots of problems
06:11:28 <Svrog> wjt: isn't it just a matter of running darcs convert to convert a repository to darcs2 format?
06:11:41 <wjt> Svrog, gwern: we have lots of branches from each project's trunk
06:11:46 <ivanm> pjdelport: true
06:12:19 <wjt> it seems to be non-trivial to migrate a whole group of related branches
06:12:25 <ddarius> "cvs: command not found"
06:12:51 <pjdelport> ivanm: the performance comes primarily from the design of the repository format, to minimize seeks and other I/O
06:13:08 <gwern> wjt: so use darcs-2 binaries but keep the darcs-1 branches. that's what backwards compatbility is for
06:13:37 <Svrog> i would have thought running darcs convert on those branches would still be a lot less work than migrating to a different system
06:13:39 <wjt> gwern: but then we don't avoid the merge bug!
06:13:52 <wjt> (which people hit *all the time*)
06:13:54 <pjdelport> ivanm: so the low-level binary diffing and such of hg is implemented in C, but very little else is worth moving from Python, for any performance increase
06:14:01 <gwern> well, I can't argue that
06:14:05 <ivanm> pjdelport: *nod*
06:14:22 <pjdelport> ivanm: if you're interested in more details, check http://hgbook.red-bean.com/hgbookch4.html
06:14:24 <lambdabot> Title: 4 Behind the scenes
06:14:38 <ivanm> pjdelport: nah, not really :P
06:14:41 <ivanm> thanks anyway though
06:16:57 <pjdelport> ivanm: re. storing changes, hg and git are broadly similar
06:17:19 <pjdelport> (relative to darcs, they're essentially the same)
06:17:32 <ivanm> heh
06:18:00 <pjdelport> the main difference is that hg's on-disk format is append-only
06:18:32 <jeffz> sjanssen: mupdf
06:19:37 <gwern> @quote 6
06:19:37 <lambdabot> lambdabot says: ghc-6.5: panic! (the `impossible' happened, GHC version 6.5):        checkPr...
06:19:51 <ayianus> I've seen two different ways of defining lambda expressions in Haskell.  "\x -> something" and "\x. something". Is it possible that only the former works in ghci?
06:19:59 <gwern> @quote 6 dark
06:20:00 <lambdabot> No quotes for this person. My brain just exploded
06:20:17 <Saizan> ayianus: the second is not real syntax
06:20:26 <gwern> @quote dark
06:20:27 <lambdabot> dark says: <shapr> for example: "head (filter (\x -> x > 5) [1..])" <shapr> in a strict language, you can't easily play with infinite lists <dark> In a strict language, you would write that as "6" :)
06:20:43 <gwern> good
06:22:02 <ayianus> Saizan, mh. Right. That explains is.
06:22:03 <ayianus> <it>
06:22:25 <idnar> so uhm, ghc are definitely ditching darcs then?
06:23:09 <idnar> Svrog: if you have two branches of the same repo, and you run darcs convert independently on them, the result is two completely divergent repos
06:23:14 <osfameron> good quote
06:23:20 <gwern> simon has, in his emails to darcs-users, reported numerous problems and seemed pretty annoyed
06:23:21 <idnar> Svrog: (at least if you're going to darcs-2 format)
06:23:51 <gwern> idnar: if they don't switch from ghc, it'll only be because they can't decide what to switch to, not because they like darcs
06:24:16 <idnar> s/ghc/darcs/ I assume
06:26:29 <pjdelport> hg starts with an h
06:27:05 <maciek`> Hi! I write a game, and want to read game board from *.svg file. It's simply xml. On hackage db I saw 10 packages for parsing xml. Which one should I use? I need only read good-formatted (from Inkscape) xml with <rect coords=".."/> .
06:27:11 <idnar> haskellg
06:27:12 <Shiruka> customize it to be cabal-aware and call it chg
06:28:42 <gwern> maciek`: why not take the lazy way out and use tagsoup?
06:29:59 <maciek`> so I will start from tagsoup. thanks.
06:31:02 <gwern> I mean, if you can assume the data is good, then a cheap solution is best, and tagsoup is popular
06:31:07 <gwern> and easy to use
06:31:15 <tusho> [[A noive asked the Master of Lazy Evalution "do you know the secret to enlightenment?"
06:31:15 <tusho> The master instantly replied "yes, I do!"
06:31:16 <tusho> The novice then asked what the secret was. With that the master lapsed into deep thought.]]
06:31:22 <Saizan> maciek`: it mostly depends on which kind of interface you'd prefer, tagsoup is pretty basic and simple, just a list of tags
06:31:44 <maciek`> so it's sufficient
06:31:52 <gwern> @quote koan
06:31:52 <lambdabot> No quotes match. The more you drive -- the dumber you get.
06:32:26 <maciek`> oh, and I need possibility for grouping. it's just <g><rect/><rect/></g>
06:32:30 <gwern> @quote lecture
06:32:31 <lambdabot> chessguy says: heh. i think i'm officially addicted. i'm chatting in #haskell, helping hack on a haskellwiki page, browing a reddit thread about haskell, while playing a haskell video lecture in the
06:32:31 <lambdabot> background
06:32:37 <maciek`> *ability, sry of my english
06:33:24 <gwern> @quote lecture
06:33:24 <lambdabot> Tac-Tics says: oerjan: I tried, but his zombie lectures were hard to follow
06:35:09 <gwern> @quote lecture
06:35:09 <lambdabot> chessguy says: heh. i think i'm officially addicted. i'm chatting in #haskell, helping hack on a haskellwiki page, browing a reddit thread about haskell, while playing a haskell video lecture in the
06:35:09 <lambdabot> background
06:37:07 <mauke> preflex: quote
06:37:07 <preflex>  <evilterran> "We were somewhere around Barstow, on the edge of the desert, when the phantom types began to take hold."
06:41:14 <gwern> yeah, that's a good one
06:41:16 <christastrophe> am I correct in seeing ghc View Patterns as nothing more than allowing a computation on the left-hand side of a pattern match?
06:41:33 <cjs> You should @remember that.
06:41:53 <gwern> @quote phantom types
06:41:54 <lambdabot> No quotes for this person. stty: unknown mode: doofus
06:42:06 <gwern> cjs: it should be in there already
06:42:14 <cjs> @quote phantom
06:42:14 <lambdabot> DavidRoundy says: With a higher-kinded monad and phantom existential witness types, darcs would be very fun... (not that it isn't already...)
06:42:20 <christastrophe> meaning that a View Pattern is really just syntactic sugar?
06:42:24 <cjs> @quote phantom
06:42:24 <lambdabot> DavidRoundy says: With a higher-kinded monad and phantom existential witness types, darcs would be very fun... (not that it isn't already...)
06:42:28 <cjs> @quote phantom
06:42:28 <lambdabot> DavidRoundy says: With a higher-kinded monad and phantom existential witness types, darcs would be very fun... (not that it isn't already...)
06:42:32 <cjs> Doesn't look like it.
06:42:35 <gwern> @quote phantom
06:42:35 <lambdabot> DavidRoundy says: With a higher-kinded monad and phantom existential witness types, darcs would be very fun... (not that it isn't already...)
06:42:36 <gwern> @quote phantom
06:42:36 <gwern> @quote phantom
06:42:36 <lambdabot> DavidRoundy says: With a higher-kinded monad and phantom existential witness types, darcs would be very fun... (not that it isn't already...)
06:42:36 <lambdabot> DavidRoundy says: With a higher-kinded monad and phantom existential witness types, darcs would be very fun... (not that it isn't already...)
06:42:46 <gwern> christastrophe: doesn't the GHC page say both that
06:42:50 <cjs> I mean we can't be sure, just decide that it's probable....
06:42:51 <gwern> damn. I was sure it was in there
06:43:04 <christastrophe> cjs: I just read through it, maybe I missed it.
06:43:12 <gwern> @remember <evilterran> "We were somewhere around Barstow, on the edge of the desert, when the phantom types began to take hold."
06:43:12 <lambdabot> I will never forget.
06:43:22 <mauke> gwern: fail
06:43:32 <cjs> @remember EvilTerran: We were somewhere around Barstow, on the edge of the desert, when the phantom types began to take hold.
06:43:32 <lambdabot> Good to know.
06:43:39 <mauke> FAIL
06:43:48 <cjs> OOps!
06:43:57 <cjs> @quote desert
06:43:57 <lambdabot> EvilTerran: says: We were somewhere around Barstow, on the edge of the desert, when the phantom types began to take hold.
06:44:01 <gwern> mauke: what?
06:44:14 <mauke> gwern: his nick is EvilTerran, not <EvilTerran>
06:44:19 <cjs> And it didn't want the colon. Oh well.
06:44:39 <cjs> Now he's got it in there with two wrong nicks! :-)
06:44:49 <gwern> mauke: the quote said <evilterran>. I didn't feel like exercising editorial control
06:44:56 <mauke> no, it didn't
06:45:05 <gwern> someone could use @forget to get one out, I suppose
06:45:20 <mauke> "<foo>" is just preflex's way of saing "foo said: "
06:45:32 <gwern> mauke: preflex said '<evilterran>'. I just looked at it again
06:45:37 <gwern> no camelcase
06:45:52 <mauke> that's an artifact of preflex normalizing all nicks
06:46:11 <mauke> still, the angle brackets aren't part of the nick
06:47:13 <gwern> if believing preflex is a crime, then I stand convicted!
06:47:23 <mauke> preflex: be gwern
06:47:23 <preflex>  no quotes found for gwern
06:47:49 <Axman6> ok, so, what is the coolest piece of short haskell you guys have seen? things that make you love haskell, and make you go :o
06:47:58 <mauke> fmap fix return
06:48:15 <Axman6> mauke: and what's it do?
06:48:16 <cjs> Ooo. The Mark Jones talk ("olymorphism and Page Tables -- Systems Programming From a Functional Programmer's Perspective") at ICFP 2008 sounds quite interesting.
06:48:19 <mauke> nothing
06:48:26 <Axman6> (should'ce added that)
06:48:28 <Axman6> ve*
06:48:59 <ivanm> Axman6: fibs = 1 : 1 : (zipWith (+) fibs (tail fibs)) <-- /me thinks this is absolutely brilliant!
06:49:07 <gwern> @quote gwern
06:49:07 <lambdabot> Gwern says: <jfoutz> is clean typed? <gwern> I hear some people dictate down their clean programs through voice recognition programs
06:49:36 <ivanm> gwern: O RLY? which people? :p
06:49:42 <Axman6> ivanm: yeah i saw that today on someone's blog, along with a nice prime generator
06:49:47 <gwern> mauke: where did preflex's quotes come from? did you unzip the files in lambdabot repo?
06:49:56 <Axman6> > nubBy(((>1) .) . gcd) [2..]
06:49:58 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
06:49:58 <gwern> ivanm: YOUR MOMMA
06:50:05 <mauke> gwern: I collected them manually
06:50:08 <ivanm> gwern: nah, she doesn't know how to code
06:50:15 <Axman6> by mux ...
06:50:51 <mauke> preflex: quote
06:50:51 <preflex>  <pndc> I am reminded of a sign put up on an electronics lab to keep the cleaners out: "Danger: 12,000 millivolts!"
06:51:16 <gwern> mauke: manually? seems wasteful of effort
06:51:18 <mercury^> the nice thing about the fibs is that they are actually efficient, opposed to the prime generator :)
06:52:00 <mercury^> also, an efficient implementation of gcd will already need primes
06:52:16 <Axman6> @src gcd
06:52:16 <lambdabot> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
06:52:16 <lambdabot> gcd x y = gcd' (abs x) (abs y)
06:52:16 <lambdabot>    where gcd' a 0  =  a
06:52:16 <lambdabot>          gcd' a b  =  gcd' b (a `rem` b)
06:52:18 <ayianus> Does anyone know what program was used to make the diagrams in this article: http://en.wikibooks.org/wiki/Haskell/Category_theory ?
06:52:59 <jeffersonheard> Has anyone in here ever given a tutorial at DEFUN or ICFP before?
06:53:01 <Axman6> ayianus: looks very OmniGraffley to me
06:53:29 <Axman6> or not, gets too complicated for omnigraffle
06:53:47 <jeffersonheard> Mostly I'm curious how versed in Haskell the attendees generally are
06:54:04 <ayianus> Axman6, ahuh. It isn't OmniGraffle.
06:54:07 <jeffersonheard> whether to include a general haskell primer at the beginning of my tutorial or just jump right into visualization
06:54:34 <gwern> fwiw, most wikimedians use inkscape for that sort of thing
06:54:44 <chr1s> ayianus: maybe graphviz?
06:54:56 <jeffersonheard> it's not graphviz
06:55:07 <jeffersonheard> I would imagine it's inkscape
06:55:13 <Cale> inkscape is delicious :)
06:55:35 * Cale looks to see
06:55:38 <pejo> jeffersonheard, the ICFP audience is diverse, with 200 people there you have everyone from SPJ down to some poor confused first year graduate student.
06:55:41 <Cale> yeah, that's likely inkscape
06:55:50 <Cale> It's certainly not graphviz.
06:56:08 <ayianus> Mhm. Inkscape. Thanks. :)
06:56:29 <jeffersonheard> Thanks, pejo, I'll add a primer, then.  Probably do a show-of-hands to see if I need to run through it
06:56:41 <Cale> http://cale.yi.org/index.php/Fold_Diagrams I did with inkscape
06:56:42 <lambdabot> Title: Fold Diagrams - CaleWiki
06:56:44 <Axman6> Cale: i always found inkscape to be quite painful
06:57:00 <Cale> Axman6: oh?
06:57:22 <Axman6> yeah, clunky, slow, and very inelegant
06:57:23 <Cale> If you're used to something like Adobe Illustrator, it's just fine.
06:57:38 <Axman6> i guess the fact i had to use X11 did't help
06:57:52 <Axman6> n*
06:57:55 <chr1s> ayianus: it could also have been tikz or pgf
06:58:02 <ayianus> Cale, your link doesn't work. =/
06:58:06 <Cale> oh?
06:58:07 <Cale> uh...
06:58:12 <mercury^> Cale: they look nice
06:58:38 <mercury^> how much time did you spend making them?
06:58:40 * Cale checks his dns...
06:58:48 <mauke> works here
06:59:50 <Cale> mercury^: Not too long, it was a while back, I don't remember. Maybe about 15-30 mins?
07:00:03 <ayianus> Cale, works now. :)
07:00:04 <benpicco> hi, is there some tab completition avaliable for hugs?
07:00:40 <Cale> benpicco: other than filename completion, I don't think so. GHCi has smart completion now though.
07:00:55 <cjs> GHCi's completion is very nice.
07:01:33 <Cale> It's been a while now since a new version of hugs came out, eh?
07:03:20 <ayianus> Cale, very nice diagrams.
07:11:40 <codacola> ive got a weird question. averageThree x y z = (x + y + z)/3  <- should be Int -> Int -> Int -> Float (x y and z are Int) right?
07:12:01 <mauke> codacola: no
07:12:09 <mauke> look at the type of (/)
07:12:30 <codacola> oh
07:12:38 <pejo> Is the meeting in 50 minutes, or am I thinking of the wrong timezone?
07:12:55 <BONUS> hint: use fromIntegral
07:13:01 <BONUS> > fromIntegral (5::Int) / 2
07:13:04 <lambdabot>  2.5
07:13:50 <codacola> BONUS: yeah thanks, i worked it out
07:19:03 <hackage> Uploaded to hackage: applicative-extras 0.1.2
07:19:03 <hackage> Uploaded to hackage: applicative-extras 0.1.1
07:19:54 <Axman6> well, this is fun ... iterate (\n -> n^n) 2
07:20:06 <Axman6> hits a wall pretty quickly
07:20:50 <dmwit> I should think so.
07:21:10 <dmwit> What, like, three iterations in?
07:21:26 <mauke> > iterate (join (^)) 2
07:21:30 <Cale> 2,4,256,<rather large number>
07:21:34 <Axman6> 4 here
07:21:34 <lambdabot>  [2,4,256,3231700607131100730071487668866995196044410266971548403213034542752...
07:21:38 <Cale> and then nothing more :)
07:21:43 <mercury^> heh
07:22:33 <Cale> length . show $ 256^256
07:22:35 <Cale> > length . show $ 256^256
07:22:36 <lambdabot>  617
07:22:46 <dmwit> The thing is, the answer to (n^n) has roughly O(n log n) digits!
07:22:56 <Axman6> ghci takes a long time to respond to ^C when you do that
07:22:58 <chrisdone> pejo: heh, "HAPPY BIRTHDAAAY, here's your surprise party!! wait, am I in the right time zone?"
07:23:27 <dmwit> Axman6: The trick I've learned is to use ^Z, kill.
07:26:47 <ketil> dmwit: try ^C first, if you exhaust memory, suspending the computation might still leave your computer unusable.
07:27:44 <dmwit> kill reclaims memory
07:27:58 <dmwit> Thank you, modern operating systems.
07:28:03 <Cale> Another handy thing is to have a program running at all times which displays things like memory usage. Gnome has one for its panel.
07:28:35 <Cale> (so you know ahead of time if a program is doing way too much allocation and is about to start swapping)
07:28:36 <ketil> On my laptop, I typically didn't get my command line back at all... I've since tuned some VM parameters, now stuff gets OOM'ed more quickly.
07:28:52 <dmwit> But yes, I normally only use ^Z when ^C stops working, because it's way convenient to have GHCi's readline history intact.
07:29:32 <gwern> @quote bats
07:29:33 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
07:29:49 <dmwit> Cale: That's not a bad idea.  Once it starts thrashing, you're really hosed.
07:29:51 <gwern> @quote phantom
07:29:51 <lambdabot> DavidRoundy says: With a higher-kinded monad and phantom existential witness types, darcs would be very fun... (not that it isn't already...)
07:30:05 <gwern> @quote phantom
07:30:05 <lambdabot> <evilterran> says: "We were somewhere around Barstow, on the edge of the desert, when the phantom types began to take hold."
07:30:17 <sebaseba> is there a way to tell GHCi to save history automatically, and load automatically upon restart?
07:31:18 <Cale> dmwit: I've also detected lame intrusion attempts using the same program, since it graphs disk I/O as well, and I could see the failed login attempts getting written to the auth.log :)
07:31:50 <Cale> sebaseba: I don't know, but it would be nice.
07:33:07 <judahj> sebaseba: the latest version of the readline package (maybe only in darcs at the moment) has readHistory and writeHistory; ghc-6.10 will use them, but you might be able to hack something up in the .ghci file.
07:33:12 <gwern> 'The only thing that really worried me was the unsafePerformIO. There is nothing in the world more helpless and irresponsible and depraved than a programmer in the depths of an unsafePerformIO binge. And I knew we'd get into that rotten stuff pretty soon.'
07:33:31 <dmwit> Cale: Whoa, that is some fine-grained graph you got there.
07:33:47 <dmwit> A few kilobytes get noticed??
07:33:52 <Cale> yeah
07:33:59 <dmwit> Oh, disk *IO*.
07:33:59 <Cale> little red spikes
07:34:01 <dmwit> yeah, ok
07:34:10 * dmwit has to learn to read more carefully
07:35:26 <sebaseba> judahj: will take a look, thanks
07:35:41 <guenni> hi, is there a dateTime lib for Haskell?
07:36:28 <dmwit> Data.Time
07:36:42 <guenni> dmwit: thx
07:38:10 <sebaseba> Cale, judahj: there's already a patch for persistent history in the GHC Trac, http://hackage.haskell.org/trac/ghc/ticket/2050
07:38:12 <lambdabot> Title: #2050 (GHCi should keep a persistent history file) - GHC - Trac
07:39:11 <judahj> sebaseba: right; that's been finished for 6.10.
07:47:52 <dmwit> There should be a better (read: less general) readInt function.
07:49:10 <Baughn> dmwit: What's wrong with the current one?
07:49:53 <dmwit> It's bad for readability to have to pass the extra (Char -> Bool) and (Char -> Int) functions.
07:50:13 <Baughn> Ah.
07:50:18 <dmwit> In almost all cases, those functions could be built from the first argument.
07:50:20 <pjdelport> dmwit: something like Python's int()?
07:50:45 <dmwit> pjdelport: It's been a while since I've lain with Python's libs.
07:51:03 <dmwit> But I want something like readIntBase :: a -> String -> [(a, String)]
07:51:40 <pjdelport> i.e. take a base, and assume the common (alphanumeric) digits and digit values
07:51:44 <pjdelport> yeah
07:51:53 <mauke> :t readInt
07:51:53 <lambdabot> forall a. (Num a) => a -> (Char -> Bool) -> (Char -> Int) -> String -> [(a, String)]
07:53:08 <mauke> at least the (Char -> Int) one is in the libraries
07:53:32 <dmwit> Yeah, digitToInt.
07:53:47 <pjdelport> [(a, String)] is probably a bit overkill
07:53:49 <dmwit> isDigit is in there, too, but you'd have to actually tweak it a bit if you wanted to be safe.
07:54:07 <dmwit> pjdelport: Maybe so.  What would you suggest as a return type?
07:54:15 <dmwit> MonadPlus => m a?
07:54:28 <mauke> Maybe (a, String)
07:54:29 <pjdelport> or just Maybe a
07:55:17 <dmwit> I think I'd probably prefer MonadPlus, just so I could use it more easily in list comprehensions.
07:58:37 <FordCortina> im trying to build ghc 6.9
07:58:49 <FordCortina> it cant run its pwd binary
07:58:51 <FordCortina> for some reason
07:59:18 <Igloo> FordCortina: Try removing utils/pwd/pwd and trying again
07:59:38 <FordCortina> checking for path to top of build tree... ./configure: line 3250: utils/pwd/pwd: cannot execute binary file
07:59:40 <FordCortina> ok
08:00:31 <FordCortina> ah brilliant :)
08:00:32 <mainland> you know, I always have that same exact problem when building 6.9
08:00:33 <FordCortina> works
08:00:47 <mainland> FordCortina: are you using HEAD or a snapshot?
08:01:16 <FordCortina> mainland its a snapshot, from a tarball not darcs
08:02:04 <mainland> FordCortina: good :)
08:05:58 <pjdelport> where was that discussion again about the return type of lookup (using Maybe versus type classes, and so on)?
08:06:33 <pjdelport> on haskell-cafe, IINM
08:30:16 <sebaseba> @quote
08:30:16 <lambdabot> Robert_Dockins says: A Turing-complete type-checker isn't enough!  Our work is not complete until the parser is a universal machine as well!
08:31:30 <pjdelport> as usual, Lisp already has that
08:33:24 <ketil> @botsnack
08:33:24 <lambdabot> :)
08:33:41 <ketil> Isn't the bot listening to hpaste?
08:33:57 * ketil pasted http://hpaste.org/9267
08:34:28 <ketil> function for combining monad actions - I suspect this is an old pattern, probably more general elsewhere.  Any hints?
08:35:04 <ketil> ...alternatively, it is much less useful than I thought :-)
08:35:10 <Twey> Uh, bind?
08:38:13 <Twey> Ah
08:38:25 <Winterstream> Has anyone here used Fudgets extensively? I really like FRP; is there any reason to be cautious about applying it fully?
08:38:42 <Twey> liftM2
08:38:54 <Twey> Is the name of your function, ketil (combineWith)
08:39:15 <EvilTerran> is it?
08:39:19 <EvilTerran> ?type liftM2
08:39:20 <Twey> Isn't it?
08:39:21 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
08:39:29 <EvilTerran> approximately
08:39:31 <Twey> combineWith :: Monad m => (b -> c -> d) -> (a -> m b) -> (a -> m c) -> (a -> m d)
08:39:48 <Twey> Oh I see, his takes functions
08:39:55 <Twey> Hmn.
08:40:32 <EvilTerran> ?type liftM2 . liftM2
08:40:32 <lambdabot> forall (m :: * -> *) a1 a2 r (m1 :: * -> *). (Monad m1, Monad m) => (a1 -> a2 -> r) -> m (m1 a1) -> m (m1 a2) -> m (m1 r)
08:41:58 <pjdelport> :t liftM2 `liftm` liftM2
08:42:02 <EvilTerran> ?type \f x g h -> (liftM2 . liftM2) f x g h
08:42:03 <lambdabot> forall t a1 a2 r (m :: * -> *). (Monad m, Monad ((->) t)) => (a1 -> a2 -> r) -> (t -> m a1) -> (t -> m a2) -> t -> m r
08:42:12 <pjdelport> :t liftM2 `liftM` liftM2
08:42:14 <lambdabot> forall (m :: * -> *) a1 a2 r (m1 :: * -> *). (Monad m1, Monad m) => (a1 -> a2 -> r) -> m (m1 a1) -> m (m1 a2) -> m (m1 r)
08:42:20 <EvilTerran> there we go
08:42:32 <EvilTerran> ?type \f x g h -> (liftM2 P.. liftM2) f x g h
08:42:32 <lambdabot> forall a1 a2 r (m :: * -> *) t. (Monad m, Monad ((->) t)) => (a1 -> a2 -> r) -> (t -> m a1) -> (t -> m a2) -> t -> m r
08:42:42 <EvilTerran> it's (liftM2 . liftM2)
08:44:31 <BMeph> Has anyone here used UUAG at all? Using AGs in Haskell looks like a workable way to deal with the "expression problem" - does anyone on have any experience with it?
08:46:32 <chrisdone> hi peaker
08:46:39 <Peaker> hi
08:46:46 <chrisdone> what are you working on?
08:46:51 <ketil> EvilTerran, Twey: thanks. :-)
08:47:00 <ketil> At least it wasn't entirely trivial :-)
08:47:51 <EvilTerran> do you know why liftM2.liftM2 works?
08:48:12 <EvilTerran> liftA2.liftA2 would also work, i believe
08:48:18 <EvilTerran> taking liftA2 from Control.Applicative
08:48:32 <DuClare> Is it bad practice or plain wrong to use (the name of) an existing type as a constructor for something?  data foo = String String | SomethingElse
08:48:50 <EvilTerran> it's... iffy
08:49:01 <chrisdone> confusing in that case
08:49:03 <ketil> EvilTerran, ups.  No - in fact, I can't make it work.
08:49:05 <EvilTerran> it's common practice to give a constructor the same name as the data it's a constructor of
08:49:14 <EvilTerran> ketil, you'll need to import Control.Monad.Instances
08:49:23 <ski> Winterstream : i haven't used it, but it would be nice to get it running
08:49:34 <EvilTerran> ketil, or Control.Applicative if you're using liftA2 instead of liftM2
08:49:50 <ski> BMeph : istr playing around a little with it
08:49:54 <ketil> one sec...
08:50:10 <DuClare> EvilTerran, What if it's a data type used to "contain" other types, like data Variable = String String | Int Int
08:50:31 <EvilTerran> ketil, i'd advise against using it unless you know why it works, btw
08:50:41 <ski> DuClare : sometimes i use `VString' or similar for the constructor, then
08:50:59 <DuClare> ski, Does V stand for something specific?
08:51:00 <EvilTerran> ketil, ie, why it makes sense to define "instance Monad (e ->)"
08:51:06 * EvilTerran would do what ski suggests
08:51:08 <ski> DuClare : your `Variable' in this case
08:51:09 <ketil> Okay.  Got it now.
08:51:13 <DuClare> ski, Ah
08:51:20 <EvilTerran> tacking the initial of the datatype name onto the beginning (or end)
08:51:24 <EvilTerran> of the constructor names
08:51:39 <DuClare> How about using C (standing for Constructor) ?
08:51:44 <DuClare> CString
08:51:47 <ski> too unspecific
08:51:47 <EvilTerran> data Expr = VarE String | IntE Int | AppE Expr Expr | ...
08:51:48 <ketil> ...although, that particular monad tends to get me into no end of trouble...
08:51:49 <ski> imo
08:51:49 <sioraiocht> is there an unsafeChr function? dons was talking about it
08:51:51 <EvilTerran> yeah, too vague
08:51:55 <DuClare> Okay
08:52:00 <EvilTerran> ?src liftA2
08:52:00 <lambdabot> liftA2 f a b = f <$> a <*> b
08:52:04 <sioraiocht> but I can't find it in hoogle
08:52:05 <DuClare> Thanks a lot. :)
08:52:08 <EvilTerran> ketil, do you know Control.Applicative at all?
08:52:42 <ketil> EvilTerran, by reputation?
08:53:07 <EvilTerran> heh... so you aren't familiar with what the Applicative class means?
08:53:11 <EvilTerran> ?src Applicative
08:53:11 <lambdabot> class Functor f => Applicative f where
08:53:11 <lambdabot>     pure  :: a -> f a
08:53:11 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
08:53:12 <pjdelport> yay for Control.Applicative
08:54:10 <ketil> I've seen them, but like so much advanced stuff, it's hard to learn to actually use it - make it part of my active vocabulary, so to speak.
08:54:40 <EvilTerran> it's a generalisation of Monad, basically
08:54:55 <EvilTerran> everything that can be defined as a correct instance Monad can be defined as a correct instance Applicative
08:54:56 <chrisdone> Yet Another Generalisation?
08:54:57 <EvilTerran> as can some other stuff
08:55:09 <EvilTerran> that can't be made into a Monad
08:55:28 <Winterstream> Are all arrows also applicatives?
08:55:31 <ketil> haskell is just a generalisation of generalisations..
08:55:39 * ketil sighs.
08:55:42 <EvilTerran> but, basically, for monads, pure = return, and (<*>) = ap
08:56:04 <EvilTerran> ketil, just you wait 'til folk start talking about the "Hask" category :P
08:56:05 <pjdelport> Applicative as sits between Functor and Monad
08:56:13 <Cale>    map f [] = []
08:56:13 <Cale>    map f (x : map f -> xs) = f x : xs
08:56:16 <Cale> cute :)
08:56:18 <pjdelport> it's richer / more specialized than Functor
08:56:30 <ketil> EvilTerran, heh.  That's when I look at my watch and start making excuses.
08:56:30 <pjdelport> but less specialized than Monad
08:56:38 <EvilTerran> cale, shurely map f (f -> x : map f -> xs) = x:xs ?
08:56:47 <ski> Cale : playing with transformational pattern syntax ?
08:56:55 <EvilTerran> (with more brackets as necessary)
08:57:19 <chrisdone> cale: that is cute
08:57:32 <Philippa> ketil: applicative has return and a form of sequencing but not join - it can't (on its own) do higher-order computations
08:57:47 <Cale> EvilTerran: ah, I parsed that the wrong way at first -- I wonder what the rule is about that :)
08:58:06 <Cale> ski: Just reading http://hackage.haskell.org/trac/ghc/wiki/ViewPatterns
08:58:09 <lambdabot> Title: ViewPatterns - GHC - Trac
08:58:19 <EvilTerran> altho neither of those transformations from the non-view-pattern version actually eliminate any variable names
08:58:23 <sioraiocht> :t unsafeChr
08:58:51 <EvilTerran> foldr f e (x : foldr f e -> y) = f x y
08:58:52 <EvilTerran> :D
08:59:10 <sioraiocht> EvilTerran: Obnoxious
08:59:31 <mar77a> > 1500 * 3 * 10
08:59:43 <lambdabot>  45000
09:01:14 * ketil must be going.  Thanks, y'all.
09:05:54 <ski>   (map (\x -> y))@(\xs -> ys) (x : xs) = y : ys  -- maybe this example is too much ? :)
09:06:25 <EvilTerran> whaaa
09:06:35 <ski> evidently too much.
09:06:43 <EvilTerran> i'm not convinced those \s make sense where they are
09:06:49 <EvilTerran> given that they seem to be in a pattern
09:07:22 <ski> well, in *my* mind, they make sense .. you may interpret that however you want ;)
09:08:28 <EvilTerran> hang on, let me put in my contact lenses i've been soaking in LSD, maybe then it'll make sense
09:08:29 <EvilTerran> :P
09:08:33 <ski> (seriously, if you're curious, i can attempt explaining)
09:08:42 <EvilTerran> nah, that's fine, i'l lhave a look at the page
09:09:22 <ski> that example i just conjured up out of my head .. it's not on that view page
09:09:44 <EvilTerran> i can compare it to the syntax discussed on the page, i mean
09:09:52 <ski> (and it's not really an example of what that page describes either .. just slighly related)
09:10:37 * EvilTerran must be off now, anywa
09:10:38 <jganetsk> was laziness a mistake?
09:10:50 <ski> EvilTerran : ok
09:10:58 <EvilTerran> jganetsk, if you mean in the design of haskell, not in the slightest!
09:11:02 * EvilTerran -> away!
09:12:25 <Cale> jganetsk: I consider it to be one of the most important features of the language.
09:12:53 <jganetsk> Cale: do you not fight it often?
09:13:06 <Cale> Not as often as I would fight strictness.
09:13:16 <Peaker> I think laziness requires better execution profiling tools, and that the profiling options ghc has are not good enough to help debug laziness issues
09:13:28 <jpcooper> jganetsk, like when you're folding a list, and there is a condition where you don't need to calculate anymore
09:13:32 <jpcooper> I had this in common lisp today
09:13:39 <seliopou> Cale: that sounds like rhetorical nonsense
09:13:41 <jpcooper> you don't have to do explicit return statements
09:13:55 <roconnor> most of my Haskell programs wouldn't work under strict evaluation
09:14:01 <Cale> When you're in a strict-as-default language, you end up turning algorithms inside-out in order for them to terminate correctly.
09:14:04 <roconnor> I use infinite lists everywhere
09:14:09 <jpcooper> yes
09:14:16 <roconnor> and try to tie the knot whenever I can
09:14:44 <Cale> This is because you can't just generate all of something, and then only use what you need. You have to decide as you're generating things whether you will later need it or not.
09:15:25 <Cale> That is often a very unnatural thing to do and often destroys opportunities for code-reuse.
09:15:57 <Cale> seliopou: Does it still sound like rhetorical nonsense?
09:16:07 <seliopou> Cale: yes
09:16:12 <Cale> seliopou: how so?
09:16:15 <ayianus> Uhm, can type classes in Haskell be seen as equivalence classes induced by some congruency relation on an algebraic structure?
09:16:28 <Peaker> I am trying to represent a functional program (factorial) as a data structure: Function "x" (If (Equals (Ref "x") (Value 0)) (Value 1) (Multiply (Ref "x") (Call "f" (Minus (Ref "x") (Value 1))))) -- this seems to be quite difficult to get the typing to work out here
09:17:00 <Peaker> Does this representation make sense at all?
09:17:02 <Cale> ayianus: They can be viewed as predicates on types, where when the predicate is true, some interface of functionality is provided.
09:17:23 <Baughn> Peaker: I can't help but think "start by thinking in sexps"
09:17:25 <ski> Peaker : what about the typing ?
09:17:28 <roconnor> > let {primes = 2:filter isPrime [3..]; isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p*p <= n) primes)} in isPrime 101
09:17:31 <lambdabot>  True
09:17:35 <seliopou> You've listed _some_ benefits. What's left to be show is that those benefits outweigh what a pain-in-the-ass debugging laziness issues tend to be
09:17:36 <roconnor> > let {primes = 2:filter isPrime [3..]; isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p*p <= n) primes)} in isPrime 102
09:17:38 <lambdabot>  False
09:17:43 <roconnor> > let {primes = 2:filter isPrime [3..]; isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p*p <= n) primes)} in primes
09:17:44 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
09:17:49 <seliopou> I'm thoroughly unconvinced that they do
09:17:57 <Cale> seliopou: Well, okay, you have to actually use the language for a while to see.
09:17:57 <roconnor> What a beautiful lazy program
09:18:09 <seliopou> Cale: I've used it plenty
09:18:24 <Peaker> ski: Well, the "Value" data constructor - what type does it take?  If I have: data FunctionalValue a = Value a | Equals (FunctionalValue ?) (FunctionalValue ?) -- what's in the question marks? How do I represent the fact that Equals means that "a" is always Bool?
09:18:36 <Cale> Perhaps you're still writing things in a strict style?
09:18:37 <roconnor> seliopou: by debugging are you talking about logical errors, or perfomance?
09:19:08 <seliopou> roconnor: performance, stack overflows, etc.
09:19:11 <Cale> You'll fight with strictness/laziness issues a lot if you write algorithms the same way as you would in a strict language.
09:19:13 <ayianus> Cale, that is, given a type class s for two Boolean operations, a function, say f :: (Eq s) => s -> [s]  will then be restricted to types matching the Eq s type class?
09:19:22 <ski> Peaker : GADT
09:19:42 <Cale> ayianus: s is not a typeclass in that type signature...
09:19:48 <Peaker> ski: I am not sure how one would work here -- also I am not sure if what I want is a bunch of data constructors, or a bunch of instances of some class
09:20:08 <Cale> ayianus: It's a type variable, which has been restricted to the set of types that are instances of Eq.
09:20:14 <ski>   data FunctionalValue :: * -> *
09:20:17 <ski>     where
09:20:18 <ski>     Equals :: Eq a => FunctionalValue a -> FunctionalValue a -> FunctionalValue Bool
09:20:18 <Cale> (Eq is a typeclass)
09:20:25 <ski> Peaker : maybe something like that ?
09:20:40 <roconnor> seliopou: so the programs actually work in theory.
09:20:41 <Peaker> ski: sounds great, I'll try that out, thanks
09:20:48 <seliopou> roconnor, yes
09:21:06 <ski> Peaker : of course there'll be other problems .. e.g. `Ref'
09:22:14 <roconnor> seliopou: usually people say to fix these errors by making your program more strict, but these issues can also often be solve by making you program more lazy
09:22:31 <seliopou> Cale: at least when I've run into laziness problems, that hasn't been the case
09:22:34 <ski> ayianus : well, types aren't in type classes until you make then be so
09:22:42 <ski> s/then/them/
09:23:01 <Peaker> ski: wouldn't   Ref :: RefID -> FunctionalValue a   work?
09:23:36 <ski> Peaker : sure .. only it's not fully type-safe (so you'll have to careful)
09:23:52 <Peaker> ski: yeah, this functional language is supposed to have its own type checking
09:24:04 <seliopou> roconnor: I'm more than aware you can write baller programs with laziness, which is why I like playing with it
09:24:04 <ski> Peaker : consider what the type of `Function' would be
09:24:25 <seliopou> but when it comes to "gettin' 'er dun", it gets in the way
09:24:26 <Peaker> ski: RefID -> FunctionalValue a -> FunctionalValue a ?
09:24:37 <ski> Peaker : oh .. then is there a reason for having a parameter to `FunctionalValue' at all ?
09:24:47 <Cale> seliopou: Well, I have a small argument for why we all like laziness so much. You can roughly break down data in programs into two classes "small" data being data which can't be evaluated in separate parts, and "large" data which can.
09:25:02 <Peaker> ski: When using Haskell values for the Value constructor
09:25:18 <ayianus> Cale, ah - therefore a type class Eq (can it be named differently?) is created with specific restrictions and then used to limit the types of the variables of a generally polymorphic function to those types that match the type class. (Is it right this time?)
09:25:20 <seliopou> Cale: you don't have to argue the merits of laziness with me. I like laziness
09:25:26 <ski> Peaker : i would have thought more like `RefID -> FunctionValue b -> FunctionValue (a -> b)' .. but maybe i misunderstood your intention wrt to the parameter
09:25:33 <seliopou> But, sometimes I think including laziness in haskell was a mistake
09:25:41 <roconnor> seliopou: I'm just saying that if more laziness can get rid of your stack problems, then laziness is obviously not the problem.
09:26:00 <seliopou> I'd rather have HaskellStrict and HaskellLazy, where in the former I can write get 'er done programs, and in the latter I can just mess around
09:26:01 <Peaker> ski: I want to write an interpreter/compiler for this language, Function should represent the code (for compilation), not a Haskell function value
09:26:47 <seliopou> and the the times where I really want laziness to get 'er done... well, that would be a sad day
09:26:56 <seliopou> but I think as it stands right now, I'd be ok with that
09:26:58 <Cale> seliopou: If you're going from small to small, then laziness/strictness doesn't matter. If you're going from small to large, laziness is better. If you're going from large to large, laziness is generally better because you can often produce part of the output from only part of the input.
09:27:18 * Philippa would like to see a separation between types intended to be used algebraically and ones intended to be used coalgebraically
09:27:24 <ski> Peaker : it seems you want some kind of mixture between host-language (haskell) type checking and hosted-language (your language) type checking
09:27:29 <Cale> When going from large to small by searching through the input for something, you again want laziness.
09:27:33 <ski> Philippa : seconded
09:27:42 <Cale> It's when going from large to small by summarizing the large data that you want strictness.
09:27:46 <Peaker> ski: I want to have no Haskell type checking - but I can't avoid it, it seems
09:28:10 <roconnor> Philippa: just annotations, or would it be used by the type checker or compiler?
09:28:10 <Peaker> ski: Perhaps its possible with an existential type
09:28:14 <Peaker> ski: (For the Value data constructor)
09:28:23 <Cale> and those places are often captured by nice higher order functions like foldl'
09:28:38 <ski> Peaker : ok .. even with function code, `.. -> FunctionValue (a -> b)' might be useful .. hm
09:28:47 <ski> Peaker : anyway, why do you want `Value' at all ?
09:28:49 <Cale> and even if not, it's usually not so hard to recognise them and add an annotation or two
09:29:06 <Peaker> ski: how else do I use literal values in the guest language?
09:29:20 <Cale> (especially when you have GHC's nice profiler)
09:29:34 <Peaker> Cale: I failed to understand what went wrong from GHC's profiler...
09:29:40 <Philippa> roconnor: I'd probably have algebraic stuff evaluated strictly by default
09:29:43 <mar77a> question, how does import work with the actual files?
09:29:52 <Cale> Peaker: were you getting an exception?
09:30:09 <Peaker> Cale: I had a memory leak when using the lazy state monad, even if I had no use at all of any state
09:30:23 <Peaker> Cale: and no problem at all when I converted the monadic code to regular lazy code
09:30:25 <roconnor> Philippa: oh, interesting
09:30:26 <Cale> Peaker: That's exactly when you'll get a memory leak from the lazy state monad.
09:30:36 <Cale> (when you never use the state)
09:30:38 <roconnor> mixing lazy and strict evaluation: http://r6.ca/blog/20060707T184300Z.html
09:30:39 <lambdabot> Title: Lazy vs. Strict
09:30:55 <roconnor> ``I find this a bit strange; to get the nice constant space results of lazy evaluation that I expect, I need to make it more strict. Of course too much strictness is no good. In a language like ML, (replicate 1000000 'a') would be evaluated right away and take up a million nodes.
09:31:13 <Philippa> roconnor: the idea being that it's rare you want to do something that might not terminate with an algebra, and even rarer that strictness is the issue
09:31:26 <Peaker> Cale: so if I had forced the state with 'seq' or so, and then threw the value away, it would solve the problem?
09:31:35 <ski> ayianus : you can name a type class with any valid name you like .. when you use it in a constraint in a type, that makes sure the constrained type variable(s) must satisfy the constraint (i.e. having been declared an instance), for the value of the type in question to be usable
09:31:42 <Cale> Peaker: quite possibly
09:31:45 <Philippa> (and if you really care, you can always introduce an intermediate type)
09:31:52 <brad_larsen> I think I see a bug in Haddock.
09:32:00 <Philippa> that said, I /also/ want good polytypic tools :-)
09:32:02 <ddarius> Philippa: Where should map fall?
09:32:06 <ski> Peaker : well, you could settle for a closed subset of literals
09:32:15 <Peaker> Cale: I think it would be awesome if there was a Haskell interpreter that visualized the execution with laziness..
09:32:18 <brad_larsen> Cale:  you wrote this module: <http://hackage.haskell.org/packages/archive/astar/0.1/doc/html/Data-Graph-AStar.html>
09:32:18 <lambdabot> http://hackage.haskell.org/packages/archive/astar/0.1/doc/html/Data-Graph-AStar.html>
09:32:18 <Cale> Peaker: the trouble is that the expression which holds the state gets built up a bit on each step of the computation, and by the end, you have something huge
09:32:24 <Cale> Peaker: I do too.
09:32:31 <Peaker> ski: I thought of having a set of exposed types: IntValue, StringValue, etc. But that's ugly :)
09:32:32 <roconnor> ddarius: one map for lists another map for streams?
09:32:35 <Cale> brad_larsen: yes, is there a bug?
09:32:37 <Philippa> ddarius: you'd end up wanting both variants, I suspect
09:32:38 <brad_larsen> the type signature that haddock reports omits some parenthesis
09:32:44 <Cale> brad_larsen: I'm aware of that.
09:32:51 <Cale> brad_larsen: It's a haddock 2.x bug.
09:32:56 <Philippa> roconnor: well, one corresponding to an association list and one to an association stream, anyway
09:33:00 <brad_larsen> Cale:  Ahh, I was wondering.
09:33:07 <ayianus> ski, aye. :) Thanks. What kinds of constraints to types are possible?
09:33:11 <Cale> brad_larsen: If you use haddock 0.9, there's no problem.
09:33:22 <Cale> brad_larsen: the 2.x series seems a bit experimental
09:33:23 <daf> roconnor: nice
09:33:30 <ski> ayianus : mostly class constraints .. there's also a couple of other extensions
09:33:32 <brad_larsen> Cale:  aha.  good to know.
09:33:38 <ddarius> roconnor: You often want a lazy map even for algebraic uses of lists.
09:33:40 <Cale> (of course, it's what hackage is using...)
09:33:43 <Philippa> ddarius: views would be interesting in this context, I guess
09:33:55 <Philippa> ddarius: default != only means of doing things though
09:34:00 <ski> Peaker : how about `Value :: Literal a => a -> FunctionalValue' ?
09:34:02 <ddarius> Philippa: Indeed.
09:34:03 <Cale> brad_larsen: I talked to someone working on hackage, and they said they'll make sure it's fixed in the next release :)
09:34:27 <Cale> er, on haddock, sorry
09:34:36 <Peaker> ski: how would I use that value later, e.g: via (*), (+) or (++)?
09:34:39 <Cale> hehe, too many ha* words ;)
09:35:21 <ddarius> roconnor: There should be a nice example of combining strictness/tail-recursive code with lazy/recursive code in the same function for optimal evaluation on hpaste somewhere.
09:35:57 <ski> Peaker : having `Value (*)' would be problematic, since you can't detect `(*)'
09:36:15 <ddarius> roconnor: http://hpaste.org/8011#a3 The encodeAcc function here.
09:36:18 <ski> (undecidability of function equality)
09:36:23 <Peaker> ski: I don't want (*) as a guest value, but I do want to have a Multiple guest value that can use (*) on the literals
09:36:25 <Cale> roconnor: With my little heuristic, your program goes from small to large to build the list, requiring laziness, and then large to small again to summarize it, requiring strictness :)
09:36:28 <Peaker> (in its implementation)
09:36:42 <ski> hm
09:36:53 <brad_larsen> When is it safe to use unsafeInterleaveIO?
09:37:03 <Peaker> ski: s/Multiple/Multiply
09:37:08 <roconnor> daf: it is important to see here that if only part of the preprocessed string is used, then the computer has wasted it's time tallying the length
09:37:09 <brad_larsen> I am using it to lazily list a directory tree.
09:37:12 <Baughn> brad_larsen: When you don't mind the IO occuring when demanded by pure code
09:37:22 <Baughn> brad_larsen: If the tree isn't /changing/, it won't be a problem
09:37:48 <Baughn> ..even if it is, there's no way to actually get a snapshot of a filesystem anyhow. No transactions.
09:37:53 <Peaker> Why isn't unsafeInterleaveIO called: lazilyDoIO or something like that?
09:38:00 <Baughn> Peaker: Because it's unsafe
09:38:08 <Peaker> Baughn: in what way?
09:38:11 <roconnor> daf: the compiler doesn't know that the entire preprocessed string will be used.
09:38:12 <brad_larsen> well, what is so unsafe about it?
09:38:27 <Baughn> Peaker: It can break transparency
09:38:41 <Baughn> By returning different results depending on /when/ you evaluate it
09:38:57 <Peaker> Baughn: yeah but that stems from the name "lazilyDoIO"
09:38:59 <Baughn> Granted, it isn't quite as observable as with unsafePerformIO
09:39:14 <brad_larsen> That makes sense.
09:39:16 <Philippa> there's an interpretation of IO in which that's legit anyway - I'm not convinced it's totally unsafe as opposed to just likely to give you odd IO semantics
09:39:47 <Peaker> Baughn: Or even: unsafeLazyIO -- my original question is more about "interleaving" than about "unsafe" -- its really about lazily doing the I/O, isn't it?
09:39:50 <Baughn> It /isn't/ totally unsafe
09:39:56 <Baughn> The name is because it's /sometimes/ unsafe
09:40:02 <Baughn> IOW, caveat emptor
09:40:05 <Philippa> (the interpretation is: given a deterministic-enough World, the result is fixed)
09:40:09 <ski> Peaker : i agree with not thinking `unsafeInterleaveIO' being unsafe ..
09:40:16 <lilachaze> unsafeInterleaveIO is a bit like sendIOActionThroughTimeMachineIntoTheFuture
09:40:20 <Twey> seliopou: Most of Haskell kind of falls apart if you make it strict
09:40:30 * Twey was scrolled up a bit, sorry
09:40:34 <Philippa> (because all your pure code doing the evaluation is still being evaluated from within an IO action)
09:40:41 <Philippa> (function pure, evaluation impure)
09:40:45 <Baughn> seliopou: You need laziness to make efficient, deterministic data structures
09:40:48 <Cale> unsafeInterleaveIO can produce values which are "funny" in the sense that their value depends on how you observe them.
09:41:11 <Twey> Heh
09:41:12 <_dolio> @remember JonHarrop the Haskell community generate almost no useful software
09:41:12 <lambdabot> I will remember.
09:41:13 <Twey> Quantum programming
09:41:32 <EvilTerran> you can demonstrate this fairly easily with an IORef and unsafeInterleaveIO
09:41:50 <Philippa> dolio: to be fair, compared to the P langs or Ruby it's true. Probably even ocaml
09:42:12 <Cale> However, they at least have the nice property that once observed, they remain consistent.
09:42:40 <Baughn> unsafePerformQuantumIO
09:42:43 <Cale> (quite a lot like collapsing waveforms!)
09:43:08 <Cale> unsafeCollapseWavefunction
09:43:14 <Twey> Haha
09:43:14 <brad_larsen> So I am using unsafeInterleaveIO to essentially do a walk of the filesystem.  It would be more honest, perhaps, to change my tree walk function to take a (FilePath -> IO a) action and call that as I am traversing...?
09:43:24 <Baughn> Cale: Hey, now. Copenhagen was disproved already. :P
09:43:25 <Elly> Cale: unsafeCollapseUnstableVacuum
09:43:30 <Philippa> brad_larsen: yeah
09:43:36 <EvilTerran> do ref <- newIORef True; liftM2 (,) (unsafeInterleaveIO $ readIORef ref <* modifyIORef not) (unsafeInterleaveIO $ readIORef ref <* modifyIORef not)
09:43:48 <Baughn> brad_larsen: That one already exists, I believe
09:43:49 <Baughn> :t walk
09:43:50 <EvilTerran> do ref <- newIORef True; (x,y) <- liftM2 (,) (unsafeInterleaveIO $ readIORef ref <* modifyIORef not) (unsafeInterleaveIO $ readIORef ref <* modifyIORef not) -- even
09:44:16 <brad_larsen> Baughn: Oh?  Maybe I didn't look hard enough.
09:44:20 <EvilTerran> if you "print x; print y" you'll get True then False. the same will happen if you "print y; print x"
09:44:37 <Baughn> brad_larsen: Well, I thought it did
09:44:46 <brad_larsen> nothing in hoogle
09:44:54 <Baughn> brad_larsen: But constructing a lazy tree should be fine. Really.
09:44:54 <EvilTerran> providing you don't compile with optimisations, because then the two identical expressions may get merged
09:45:01 <EvilTerran> in which case  you'll end up with True then True
09:45:07 <Baughn> brad_larsen: Users are generally aware that changing directory structures while programs are running is a bad idea
09:45:17 <Cale> Baughn: I still think it's probably a useful way to look at things. After all, the information discarded by collapsing a wavefunction through observation is information that can not affect anything for that observer.
09:45:38 <Baughn> Cale: Sure, but then you call it decoherence
09:45:43 <Philippa> Baughn: er, that depends on what the programs're supposed to be doing with them
09:45:56 <ski> @type mapM System.IO.Unsafe.unsafeInterleaveIO  -- ftw !
09:45:56 <lambdabot> forall a. [IO a] -> IO [a]
09:46:06 <Cale> (the observer's state is of course entangled with the system, but in some sense you don't have to care about that)
09:46:09 <greendemon> @Djinn (IO a, IO a) -> IO (a,a)
09:46:09 <lambdabot> -- f cannot be realized.
09:46:25 <ski> djinn doesn't know IO
09:46:28 <ski> it is untainted
09:46:38 <greendemon> does it know monads?
09:46:43 <Cale> nope
09:47:08 <roconnor> @djinn Bool
09:47:09 <lambdabot> f = False
09:47:16 <Cale> :t uncurry (liftM2 (,))
09:47:16 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => (m a1, m a2) -> m (a1, a2)
09:47:33 <EvilTerran> it doesn't know anything involving a typeclass
09:47:42 <roconnor> @djinn ()
09:47:42 <lambdabot> f = ()
09:47:46 <EvilTerran> and won't do recursive types either, iirc
09:47:47 <Cale> Or, \(x,y) -> do v <- x; w <- y; return (v,w)
09:47:49 <roconnor> @djinn Void
09:47:49 <lambdabot> -- f cannot be realized.
09:47:54 <ddarius> @djinn Eq a => a -> a -> Bool
09:47:54 <lambdabot> Cannot parse command
09:48:01 <ddarius> @djinn (Eq a) => a -> a -> Bool
09:48:01 <lambdabot> f = (==)
09:48:10 <EvilTerran> oh, it does do typeclasses?
09:48:17 <EvilTerran> just not Monad
09:48:20 <brad_larsen> Anyone have suggestions for accessing exif/IPTC/XMP metainfo from Haskell?
09:48:25 <ddarius> EvilTerran: Hackishly and only actual type classes as opposed to constructor classes.
09:48:35 <Cale> EvilTerran: Yeah, the author took my suggestion about how to handle them.
09:48:38 <brad_larsen> There are some very minimal bindings to libexif on hackage.  But nothing for IPTC or XMP
09:48:40 <EvilTerran> "constructor classes"?
09:48:41 <ddarius> brad_larsen: Use a library on hackage to do that.
09:48:45 <EvilTerran> ?djinn (a -> b) -> Void
09:48:45 <lambdabot> -- f cannot be realized.
09:48:46 <Cale> It's not too hackish in principle.
09:49:01 <EvilTerran> ?djinn (() -> a) -> Void
09:49:01 <lambdabot> -- f cannot be realized.
09:49:01 <ddarius> EvilTerran: type constructor classes
09:49:04 <Cale> It's the same algorithm, you're just providing the class methods as parameters to the function.
09:49:12 <roconnor> EvilTerran: monads are a type consturctor class
09:49:19 <brad_larsen> ddarius: any specific one?
09:49:24 * EvilTerran sees what he's doing wrong
09:49:32 * EvilTerran also sees what ddarius and roconnor are referring to
09:49:39 <ski> EvilTerran : are you sure that could get `True\nTrue' ?
09:49:41 <Cale> Does it really not support constructor classes? Maybe it doesn't support constructor type variables very well.
09:49:43 <EvilTerran> classes where the parameter has a higher-kinded types?
09:50:06 <roconnor> @dijnn m a -> m a
09:50:06 <lambdabot> f a = a
09:50:09 <EvilTerran> ski, if it's CSE'd and inlined, i think you could get the IO action only happening once
09:50:24 <ski> EvilTerran : i doubt that
09:50:36 <ddarius> Cale: Constructor classes would need higher-rank types.
09:50:44 <ddarius> EvilTerran: Yes.
09:50:50 <EvilTerran> ski, eh... i guess. i haven't thought about it in detail.
09:50:56 <Cale> @djinn ((a -> b) -> f a -> f b) -> (a -> b) -> Maybe a -> Maybe b
09:50:56 <lambdabot> f _ a b =
09:50:56 <lambdabot>     case b of
09:50:56 <lambdabot>     Nothing -> Nothing
09:50:56 <lambdabot>     Just c -> Just (a c)
09:51:13 <Cale> @djinn ((a -> b) -> f b -> f a) -> (a -> b) -> Maybe b -> Maybe a
09:51:14 <lambdabot> f _ _ _ = Nothing
09:51:16 <Cale> heh
09:51:16 <ski> EvilTerran : that's arguing `liftM2 (,) ma ma' is the same as `liftM (\a -> (a,a)) ma', which isn't the case in general .. or how were you arguing ?
09:51:21 <brad_larsen> there is Image::ExifTool module for perl that reads exif/iptc/xmp.  But it's 75k lines of pure perl, so no C to bind into.
09:51:28 <Cale> @djinn ((a -> b) -> f a -> f b) -> (a -> b) -> f a -> f b
09:51:28 <lambdabot> f a = a
09:51:40 <ddarius> @hackage xmpp
09:51:40 <Cale> @djinn ((a -> b) -> f a -> f b) -> (a -> b) -> f (f a) -> f (f b)
09:51:41 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/xmpp
09:51:41 <lambdabot> -- f cannot be realized.
09:51:42 <brad_larsen> I'll probably end up calling perl from haskell...
09:51:51 <EvilTerran> ski, as i said, i didn't think it through in detail
09:51:55 <brad_larsen> any suggestions?
09:51:57 <FordCortina> ghc needs to be compiled with readline support in order to get backspace,etc in ghci right?
09:52:04 <Cale> okay, I think that shows that it really doesn't know how to manage it :)
09:52:12 <ski> @djinn Void -> (() -> a) -> Void
09:52:12 <lambdabot> f = void
09:52:12 <ddarius> @hackage exif
09:52:13 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/exif
09:52:41 <roconnor> @djinn (forall a b. ((a -> b) -> f a -> f b)) -> (a -> b) -> f (f a) -> f (f b)
09:52:41 <ddarius> There should be some xmp thing somewhere.
09:52:41 <lambdabot> -- f cannot be realized.
09:53:09 <ski> EvilTerran : a simpler example would be that `do putStr "x"; putStr "x"' is the same as `do let {p = putStr "x"}; p; p' .. cf. C, et.c.
09:53:10 <roconnor> @djinn (forall a. a) -> Void
09:53:10 <lambdabot> -- f cannot be realized.
09:53:16 <ddarius> @google Haskell XMP
09:53:18 <lambdabot> No Result Found.
09:53:18 <brad_larsen> ddarius:  already using that.  It only reads exif though.  I'm going to call perl from haskell. o_O
09:53:22 <EvilTerran> ski, yeah, i see that now
09:53:26 <roconnor> Cale: you weren't being polymorphic enough
09:53:31 <EvilTerran> brad_larsen, you could at least call C from haskell!
09:53:52 <Cale> roconnor: oh, right
09:53:56 <brad_larsen> EvilTerran: I want to!  but there doesn't seem to be a free C library that reads all the formats I am interested in.
09:53:59 <Cale> roconnor: heh
09:54:01 <ski> (EvilTerran : .. but not the same as `let x <- putStr "x"; return x; return x', i forgot to add ..)
09:54:11 <brad_larsen> EvilTerran: just a bunch of pure perl code.
09:54:17 <Cale> roconnor: yeah, that's hard to deal with.
09:54:47 <Cale> brad_larsen: another option would be to extend the exim Haskell binding a bit
09:54:56 <Cale> oh
09:54:58 <brad_larsen> Cale:  exim?  or exif?
09:55:04 <Cale> exif
09:55:14 <Cale> I'm totally unfamiliar with all these formats :)
09:55:20 <EvilTerran> ?hackage hsmagick
09:55:21 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hsmagick
09:55:23 <ski> @fresh
09:55:23 <lambdabot> Ham
09:55:25 <EvilTerran> i dunno if that does it
09:55:28 <EvilTerran> ?list fresh
09:55:28 <lambdabot> fresh provides: freshname
09:55:29 <brad_larsen> Cale:  my problem is that the images I want to work with have all the metadata encoded as IPTC or XMP
09:55:31 <ski> .. ham's not fresh
09:55:33 <EvilTerran> heh
10:02:38 <Cale> http://libopenraw.freedesktop.org/wiki/Exempi -- maybe a Haskell binding to this would solve your problem?
10:02:40 <lambdabot> Title: libopenraw wiki - Exempi
10:02:52 <FordCortina> do you need to compile "extralibs" to be able to backspace in ghci?
10:03:18 <Cale> FordCortina: Is it somehow not using libreadline?
10:03:46 <brad_larsen> I'm looking at graphicsmagick now, and exempi...
10:04:24 <FordCortina> Cale: it seems so, i added --with-readline=yes when i invoked ./configure though
10:06:58 <FordCortina> or does it have to be --with-libreadline=yes ?
10:07:03 <FordCortina> i got no error
10:07:14 <FordCortina> but nothing in the log either
10:07:17 <Cale> FordCortina: did you compile GHC yourself?
10:07:35 <Cale> (maybe try a binary?)
10:07:36 <FordCortina> Cale: yes, im compiling the latest snapshot
10:07:39 <Cale> ah
10:07:54 <Cale> You can check and see if it's linked against libreadline, I suppose
10:08:54 <FordCortina> Cale: I compiled my original ghc installation though, had a similar problem. can't remember how i fixed it. i think the with-readline was sufficient
10:08:56 <Cale> (use ldd on the binary)
10:09:01 <FordCortina> thanks Cale
10:09:56 <Cale> (which is in the lib directory of the path in which you installed it, under ghc-*)
10:10:00 <FordCortina> Cale: I dont see readline in the current ldd output
10:10:13 <Cale> hmm
10:15:36 <brad_larsen> EvilTerran: it looks like graphicsmagick, what hsmagick binds into, can read IPTC and exif.  So that might work for me.
10:20:05 <Peaker> why do you think Ruby/Py/Perl have people spewing out more code/functionality than Haskell?  Is the Haskell community much smaller? More academically focused?
10:20:11 <lispy> gwern: ping
10:20:36 <Deewiant> smaller, certainly
10:20:42 <brad_larsen> Peaker: Haskell is much different from just about every other language.  very steep learning curve.
10:20:48 <Deewiant> and probably the latter as well
10:20:58 <baaba> why a steep learning curve
10:21:07 <Baughn> Much smaller. It's growing, but..
10:21:18 <lispy> A lot of the good haskell guides and tutorials are actually academic papers
10:21:29 <lispy> That's a barrier for the typical programmer I would guess
10:21:31 <brad_larsen> baaba: you have to get a handle on monads to do simple things like IO
10:21:43 <Peaker> I learned Haskell and it was easy for me to create a ray tracer, chess stuff, and some other toys.  Trying to do some more "advanced" things is puzzling me though.  I barely have to think before I mess around with Python code, though
10:21:46 <brad_larsen> baaba: most people don't have the time or patience to learn
10:22:03 <baaba> and monads are nothing but a few functions that work together in a certain way, in order to pass something around behind the scenes
10:22:09 <lispy> Peaker: what is an example of a more advanced thing in that context?
10:22:18 <Baughn> Peaker: Well, you're used to python. You /can/ get used to haskell, and it's well worth it, but it does take a while
10:22:36 <brad_larsen> baaba: i don't disagree, but it takes a while to figure that out.  took me a while, anyways.
10:22:40 <Elly> I have to say that Haskell and SML are the only languages I know where I spend more time thinking than typing
10:22:43 <Peaker> lispy: I am trying to implement a functional language on top of Haskell, as an educational experience, for example. Or another example: A differential computing framework.
10:22:45 <Elly> (I consider that a positive :P)
10:22:46 <baaba> i find most people have trouble understanding monads because other people try hard to convince them that monads are magical
10:23:00 <baaba> "omg monads are so magical and hard to get you'll never get them!"
10:23:05 <Philippa> yeah, it's a PITA
10:23:07 <baaba> and yet..they're nothing new
10:23:19 <Peaker> Baughn: I think Haskell lacks good tools
10:23:23 <lispy> Peaker: interesting, Haskell is often considered to be optimized for language dev, so making an FP language on top of Haskell should be easy ;)
10:23:27 <Philippa> <brad_larsen> baaba: you have to get a handle on monads to do simple things like IO <- no, you don't
10:23:30 <Baughn> Peaker: Such as..?
10:23:37 <geezusfreeek> the reason monads are hard to learn is because they are highly abstract
10:23:42 <baaba> not really
10:23:49 <Philippa> to do IO, you just need to get expression/statement distinctions and the idea that statements have a matching type constructor - then use do a lot
10:24:02 <brad_larsen> monad transformers, existential types,  and functional dependencies are other things that you may have to tackle in big programs.
10:24:04 <geezusfreeek> it's hard to envision how they might be used when you describe them in purest terms, and it's hard to get the big picture if you just look at individual cases
10:24:09 <geezusfreeek> (this is for a beginner, mind you)
10:24:11 <brad_larsen> those are things you simply don't have to face in other languages.
10:24:11 <lispy> brad_larsen: true
10:25:31 <EvilTerran> however, we don't have to face... unconstrained side-effects
10:25:40 <Peaker> Baughn: a better debugger, profiler. An execution visualizer would be great - better emacs support too
10:25:41 <EvilTerran> run-time type errors, or unpredictable coercions
10:25:49 <baaba> i still don't agree any of those are difficult to grasp
10:25:59 <EvilTerran> inheritance
10:26:05 <Baughn> Peaker: Hmm, yes. I can't argue with that.
10:26:26 <EvilTerran> which i maintain has significantly more complex semantics than h98 at least
10:26:35 <EvilTerran> *than the h98 type system
10:26:36 <Baughn> Peaker: Though I think the tools we have are /already/ better than is typical, we need even better than that to get around the "weirdness"
10:26:37 <Peaker> geezusfreeek: when I tell people about monads, I say they are a way to combine operations together - and then people don't find it too abstract or confusing
10:26:47 <EvilTerran> just more mainstream, so more people know how it works
10:27:04 <brad_larsen> baaba: you are in the minority of programmers, then, I think.
10:27:10 <geezusfreeek> Peaker: but are you actually trying to teach them how to apply this knowledge?
10:27:18 <Peaker> Baughn: I expected Haskell's debugger to be better (given that it seems easier to me to create a good debugger for an FP -- go backwards, forwards, etc), and was disappointed to find that the ghc debugger was far harder to use, not easier, than pdb/gdb/etc
10:27:27 <lispy> I would agree that lack of good "traditional" debugger sucks, but it's a hard problem
10:27:31 <erikc> i describe monads as 'programmable semicolon'
10:27:36 <Peaker> geezusfreeek: one of them - and he seems to get it, but I haven't tested him :)
10:27:39 <geezusfreeek> because i agree that even as a beginner it sounded crazy simple
10:27:47 <Baughn> Peaker: ghc's debugger does almost exactly the same thing as gdb. It's just that execution really /does/ jump around a lot
10:27:51 <baaba> i really do think the primary reason people might find those hard to grasp is that people are convinced by others of the magical quality of these things
10:27:51 <baaba> which severely inhibits understanding
10:27:57 <Philippa> <geezusfreeek> it's hard to envision how they might be used when you describe them in purest terms, and it's hard to get the big picture if you just look at individual cases <- the answer, as ever, is to do both
10:27:59 <baaba> "oh but there MUST be something more to this, i mean they said it was completely magical!"
10:28:11 <Baughn> Peaker: I think I'd like a graphical debugger, probably combined with profiler/visualizer. Show statements and thunks explicitly, and all..
10:28:32 <geezusfreeek> Philippa: yes, but you cannot do both at the exact same time, so it's hard to merge the knowledge gained from both experiences, initially
10:28:35 <Peaker> Baughn: the debugger didn't have to naively follow execution around - it could focus on a specific thunk's execution that you need
10:28:40 <lispy> Baughn: yeah, showing the evaluation graph would be interesting
10:28:58 <Baughn> Peaker: A useful option, yes
10:29:12 <Philippa> geezusfreeek: you can interleave the two, however
10:29:17 <geezusfreeek> sure
10:29:28 <Philippa> that and a bit of repetition helps
10:30:21 <geezusfreeek> i agree, but repetition is the key word. a beginner can't just look at an abstract description and fully understand it right then as some seem to be implying
10:30:42 <geezusfreeek> *most beginners
10:30:49 <cjs> It works the other way around for me. Repeat a pattern in various contexts, and then I abstract it.
10:30:51 <araujo> hi
10:31:56 <Philippa> geezusfreeek: agreed. I've mostly done teaching over IRC, so I tend to feel people out over their understanding
10:33:19 <FordCortina> aha
10:33:34 <FordCortina> has ghc-head switched "editline"
10:33:40 <FordCortina> instead of readline?
10:34:53 <ndm> @seen dcoutts
10:34:54 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-soc, #haskell-overflow, #ghc and #haskell. I last heard dcoutts speak 42m 21s ago.
10:35:24 <ndm> dcoutts_: setup haddock --haddock-args=-w doesn't work, what is the command? and for bonus points, where would i have found it with --help :)
10:35:45 <erikc> i found things a lot easier once i learned things bottom up (lambda calc -> haskell as language -> stg -> haskell as implementation), top down tutorials were really confusing, too much magic
10:36:01 <dcoutts_> ndm: --help lists --PROG-option(s)= and says what values PROG can take
10:36:54 <ndm> with Cabal library version 1.4.0.1 and runhaskell Setup I can't find it
10:38:14 <dcoutts_> ndm: it's a configure flag
10:38:15 <lispy> ?tell gwern Could you try building darcs HEAD out of the box on ghc 6.8.x.  I believe the test suite should compile now with type witnesses and whatnot without modification.  I would appreciate if you could verify this.
10:38:15 <lambdabot> Consider it noted.
10:40:12 <ndm> dcoutts_: ah, found it - any reason i can't pass a haddock flag to haddock at haddock time?
10:41:32 <Peaker> ski: Minimizing the "language" to just ints seems to resolve the issues and still provide me with enough educational challenge for now :)
10:41:48 <ski> ok
10:42:29 <lispy> ndm: hm...I thought you can
10:43:08 <Baughn> dcoutts_: Is there a cabal-install repo other than the one on darcs.haskell.org?
10:43:28 <lispy> ndm: Or maybe I misunderstand which tool you're working with.  But, I think haddock 2 can take command line options via options to ghc
10:43:35 <Baughn> I'm seeing references to patches that simply aren't in the latter
10:44:53 <BMeph> Is there anyone on that has worked (or "worked") with Attribute Grammars in Haskell?
10:45:22 <ndm> lispy: i'm trying to pass them through cabal
10:47:15 <Peaker> is there anything like assert, but that calls "fail" instead?
10:47:39 <lispy> Peaker: I assume you mean inside a monad?
10:47:49 <Peaker> lispy: yeah
10:48:04 <lispy> Peaker: any reason you don't want to call fail directly?
10:48:24 <Peaker> lispy: if a /= b then fail else <rest-of-code> creates ugly nesting
10:48:38 <Baughn> Peaker: unless (a==b) fail
10:48:39 <lispy> Peaker: Or you want assert :: Monad m => Bool -> m a -> m a ?
10:49:02 <Peaker> lispy: yeah, I can just write it, ofcourse
10:49:05 <lispy> ?hoogle Bool -> m a -> m a
10:49:06 <lambdabot> GHC.Exts.breakpointCond :: Bool -> a -> a
10:49:06 <lambdabot> Control.Exception.assert :: Bool -> a -> a
10:49:10 <Peaker> Baughn: what's that?
10:49:11 <dolio> guard
10:49:20 <Baughn> Peaker: Control.Monad.unless
10:49:25 <Peaker> Baughn: oh, thanks, exactly what I wanted
10:49:42 <Baughn> Peaker: Avoiding nesting is pretty much the point of a monad
10:49:44 <Peaker> oh wait, why is it m () and not m a ?
10:49:56 <Baughn> If it fails, it fails
10:50:03 <Baughn> If it doesn't fail, it returns ()
10:50:04 <lispy> :t fail
10:50:04 <Peaker> it can fail into an m a
10:50:05 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
10:50:29 <lispy> :t \e -> unless e fail
10:50:38 <Baughn> Peaker: Well, yeah. You're supposed to sequence it with >>, not =>>
10:50:42 <Baughn> >>=, even
10:50:59 <Deewiant> ?ty \x s -> when (not x) (fail s)
10:51:00 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> String -> m ()
10:51:09 <Baughn> Peaker: It's a standard monadic action, and one that does nothing whatsoever if the predicate fails
10:51:10 <dolio> > do x <- [1..10] ; guard (x == 3) ; return x
10:51:12 <lambdabot>  [3]
10:51:25 <Baughn> @src unless
10:51:25 <lambdabot> unless p s = if p then return () else s
10:51:38 <lispy> I'm not sure unless is the right thing
10:51:54 <lispy> ?pl \e -> unless e fail
10:51:54 <lambdabot> flip unless fail
10:51:59 <Baughn> Peaker: Can you paste the code you'd like to write?
10:52:03 <Peaker> Baughn: oh, I want fail, not "return ()" there
10:52:18 <lispy> Peaker: exactly, but note that fail does take a message
10:52:33 <Peaker> lispy: I am in the Maybe monad
10:52:37 <pmurias> hi
10:52:39 <lispy> so, your assert would be like assert :: Bool -> String -> m a -> m a
10:52:39 <Peaker> I could pass it an empty string too
10:52:47 <Peaker> Baughn: I'll paste it soon
10:52:52 <Baughn> Peaker: ..but the not-return branch should be the failing one
10:52:57 <lispy> Peaker: right, but what if you generalize to MonadError? ;)
10:52:59 <Peaker> Baughn: its toying around with defining a guest functional language on top of Haskell
10:53:11 <pmurias> did the ghc core representation change much from the one described in "An External Representation for the GHC Core Language."?
10:53:17 <Peaker> @hoogle MonadError
10:53:17 <lambdabot> Control.Monad.Error.Class.MonadError :: class Monad m => MonadError e m
10:53:33 <Baughn> Peaker: You're saying "unless foo (fail "not foo!")", which does nothing whatsoever (in any monad) if foo is True
10:53:41 <lispy> ?instances MonadError
10:53:42 <lambdabot> IOError IO, e (Either e), e (ErrorT e m), e (RWST r w s m), e (ReaderT r m), e (StateT s m), e (WriterT w m)
10:53:42 <Baughn> Well, at least in any monad I've seen
10:53:54 <Peaker> lispy, Baughn: I have a "typeCheck" function that returns Maybe Type
10:54:30 <lispy> Peaker: something like, typeCheck :: Expression -> Maybe Type
10:54:32 <lispy> ?
10:54:32 <Peaker> lispy, Baughn: I am using monadic typechecks recursively and return my result
10:54:44 <Peaker> lispy: yeah
10:54:54 <lispy> sounds good so far
10:55:46 <lispy> Oh, you do want guard and now I see why
10:55:52 <lispy> :t guard
10:55:53 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
10:55:55 <Peaker> typeCheck in the "If" case, wants to do something like:  do { condType <- typeCheck cond ; assert condType == BoolType ; trueType <- typeCheckTrue ; ... }
10:56:18 <Baughn> Peaker: And in the else case, fail?
10:56:20 <Baughn> That'S guard, yes
10:56:33 <Peaker> Baughn: yeah -- as in, evaluate the whole thing to Nothing
10:56:48 <Peaker> I guess I should replace Maybe with Either
10:56:52 <Peaker> So I can have a nicer message
10:56:54 <Baughn> > do a <- Just 3; guard (a==3); return a
10:56:57 <lispy> > do { x <- Just 1; y <- Just 2; guard (x==1); return y }
10:57:03 <Peaker> @src guard
10:57:03 <lambdabot> guard True  =  return ()
10:57:03 <lambdabot> guard False =  mzero
10:57:09 <lambdabot>  thread killed
10:57:10 <lambdabot>  Just 2
10:57:14 <Peaker> MonadPlus??
10:57:18 <Baughn> > do a <- Just 2; guard (a==3); return a
10:57:19 <lambdabot>  Nothing
10:57:35 <dolio> You shouldn't be calling fail unless it's a MonadPlus anyway.
10:57:37 <lispy> ?instances MonadPlus
10:57:38 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
10:57:53 <lispy> Peaker: you're golden because Maybe is a MonadPlus ^^
10:57:57 <Peaker> dolio: why?
10:58:16 <dolio> Because things that can't be made a MonadPlus don't have sensible notions of failure.
10:58:29 <dolio> (Or, MonadZero, but we're stuck with MonadPlus)
10:58:38 <lispy> I wish we had an ?instance-intersection MonadPlus MonadError
10:58:47 <Peaker> I never understood why it was sensible to replicate Monoid as an addition to Monads...
10:58:58 <Jedai> the fail method in Monad is just a wart to make translation of do-syntax easier
11:00:16 <b_jonas> what's MonadZero?
11:00:24 <BMeph> Peaker: Likely, because some types have more than one way to define a Monoid on them (I'm guessing)... :)
11:00:25 <Peaker> lispy: why not create my own:   assert cond explanation rest = if cond then rest else fail explanation ?
11:00:27 <Baughn> A hypothetical typeclass with only mzero in it
11:00:51 <b_jonas> I see
11:01:07 <lispy> Peaker: Because guard does what you want and it is simpler :)
11:01:19 <lispy> Peaker: It was a mistake for me to suggest that assert take the rest
11:01:31 <yitz> b_jonas: it actually existed years ago, but was combined into MonadPlus. Many people want it back (me included)
11:01:37 <lispy> Peaker: look at the definition for (>>=) in the Maybe Monad instance
11:01:46 <lispy> Peaker: then look at the definition of fail and guard
11:01:50 <lispy> ?src guard
11:01:50 <lambdabot> guard True  =  return ()
11:01:50 <lambdabot> guard False =  mzero
11:02:27 <lispy> Peaker: basically what happens is that guard False = Nothing, and a Nothing in (>>=) aborts all further computation in the Maybe monad
11:02:39 <Peaker> lispy: What if I do want the failure string?
11:02:48 <Peaker> lispy: yeah, that was what I was counting on with "fail" too
11:02:48 <lispy> Peaker: so it doesn't matter than guard returns Maybe (), you throw it way anyway
11:03:02 <lispy> Oh
11:03:08 <lispy> Well, in that case you need to do it yourself
11:03:09 <Peaker> lispy: I can s/Maybe/Either and get the fail-string with assert
11:03:10 <yitz> Peaker: then you should be using MonadError
11:03:25 <Peaker> @instances MonadError
11:03:40 <lambdabot> Couldn't find class `MonadError'. Try @instances-importing
11:03:42 <yitz> @src throwError
11:03:42 <lambdabot> Source not found. Maybe you made a typo?
11:03:52 <lispy> Peaker: if you want to use MonadError you could try switching to Either first
11:03:53 <yitz> @src Monad.Error.throwError
11:03:53 <lambdabot> Source not found. Just try something else.
11:04:01 <yitz> @src Control.Monad.Error.throwError
11:04:02 <lambdabot> Source not found. You untyped fool!
11:04:11 <yitz> She's right, of course.
11:04:18 <dolio> It's a typeclass method.
11:04:20 <Peaker> Seems like MonadError is not H98 (not that it matters :-)
11:04:24 <lispy> weird
11:04:24 <lispy> 10:53 <lispy> ?instances MonadError
11:04:24 <lispy> 10:53 <lambdabot> IOError IO, e (Either e), e (ErrorT e m), e (RWST r w s m), e  (ReaderT r m), e (StateT s m), e (WriterT w m)
11:04:29 <dolio> @src Either throwError
11:04:30 <lambdabot> Source not found. Just what do you think you're doing Dave?
11:04:34 <yitz> @type throwError
11:04:40 <lambdabot> forall e (m :: * -> *) a. (MonadError e m) => e -> m a
11:04:53 <Peaker> ok, so what's like assert/guard for MonadError?
11:05:06 <lispy> That i'm not sure
11:05:16 <Peaker> calling throwError when the assertion fails?
11:05:21 <yitz> when cond $ throwError "message"
11:05:28 <BMeph> @instances-importing MonadError
11:05:29 <lambdabot> IOError IO, e (Either e), e (ErrorT e m), e (RWST r w s m), e (ReaderT r m), e (StateT s m), e (WriterT w m)
11:06:00 <lispy> Peaker: http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Error-Class.html
11:06:01 <lambdabot> Title: Control.Monad.Error.Class, http://tinyurl.com/6jm7gk
11:06:41 <yitz> and http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Error.html
11:06:42 <lambdabot> Title: Control.Monad.Error, http://tinyurl.com/2cvgfn
11:06:53 <lispy> Peaker: as far as I know, assert :: MonadError m => Bool -> m (), is not defined already
11:07:43 <Peaker> lispy: I probably need   assert :: MonadError e m => Bool -> e -> m ()
11:07:44 <yitz> lispy, Peaker : yes it is - it's called "unless".
11:08:06 * Pistahh hates the word "unless"
11:08:11 <Peaker> @hoogle unless
11:08:12 <lambdabot> Control.Monad.unless :: Monad m => Bool -> m () -> m ()
11:08:12 <lambdabot> Control.Arrow.Operations.tryInUnless :: ArrowError ex a => a e b -> a (e, b) c -> a (e, ex) c -> a e c
11:08:12 <lambdabot> Control.Arrow.Operations.tryInUnlessDefault :: (ArrowError ex a, ArrowChoice a) => a e b -> a (e, b) c -> a (e, ex) c -> a e c
11:08:20 <ankh47> hi, i'm currently developing a web frontend for some data that are physically distributed across 120 locations. to minimize network usage, i want them cached locally.  since i'm pretty new to haskell, i don't really know what would be the best mechanism to use - in erlang, i used named process, i know i could do the same, but  isnt there a smarter way ?
11:08:29 <lispy> Peaker: er, MonadError m => Bool -> String -> m ()
11:08:35 <yitz> @type \p e -> unless p $ throwError e
11:08:36 <lambdabot> forall (m :: * -> *) e. (MonadError e m) => Bool -> e -> m ()
11:09:06 <yitz> Pistahh: unless you really need it
11:09:07 <lispy> ?src unless
11:09:08 <lambdabot> unless p s = if p then return () else s
11:09:08 <Peaker> lispy: MonadError has two type args, one of which is the error, which is more general than String (but can be String), so why not use that?
11:09:26 <lispy> Peaker: yeah, use it
11:09:53 <lispy> But, unless doesn't fail
11:09:59 <lispy> Oh wait, n/m
11:10:06 <lispy> That's why you combined it with throwError
11:10:08 <Peaker> use unless? that seems to only do part of what I need - I'd need to throwError in "s" yeah
11:10:20 <Peaker> I'll build assert on top of unless
11:10:33 <lispy> :t (unless .) . throwError
11:10:34 <lambdabot> forall (m :: * -> *) (f :: * -> *) e. (MonadError e f, Functor f, Monad m) => e -> f (m () -> m ())
11:10:38 <RayNbow> going from a 2007 conal talk to a 2000 conal talk... it feels odd... :p
11:10:49 <Pistahh> yitz: in my native language (hungarian) there is no word for unless. It is literally translated to "only if not". Therefore when I read an expression with unless, I have to negate it in my head to understand what it is intended to mean
11:11:44 <yitz> Pistahh: ah, ok. interesting.
11:11:58 <lispy> unless x  == when (not x) ;)
11:12:37 <Pistahh> lispy: I know. But just imagine, reading "hiuasdfi x" instead of "when not x"
11:13:15 <lispy> Pistahh: hiuasdfi meaning, gibberish?
11:13:31 <lispy> or is hiuasdf a hungarian word?
11:13:48 <Pistahh> no, it is just a random typing to demonstrate the feeling. :)
11:13:53 <lispy> gotcha
11:13:56 * sebaseba thinks chinese characters would be great for variable and function names
11:14:17 <Peaker> when I type "String" now, I think of Stringer. Anyone else watches the Wire?
11:14:18 <ankh47> it has to mean something in an obscure african dialect, are there any *buntu people around ? ;-)
11:14:22 * RayNbow once used Japanese identifiers in Java... :p
11:14:50 <RayNbow> can the GHC compiler handle unicode source files?
11:14:55 * sebaseba 楽しそう
11:15:01 <Deewiant> RayNbow: yes
11:15:06 <Peaker> > 楽しそう
11:15:06 <lambdabot>  Illegal character ''\27005''
11:15:06 <lambdabot>  at "}W]F" (column 1)
11:15:12 <ankh47> 2 raynbow> ineresting obfuscation technique ;-)
11:15:14 <Deewiant> lambdabot can't :-P
11:15:34 <RayNbow> Deewiant: you probably have to specify a charset flag?
11:15:45 <RayNbow> (just like with javac)
11:15:46 <Deewiant> I think UTF-8 works by default
11:15:51 <Peaker> can you call "fail" too, in a MonadError?
11:15:57 <Deewiant> or it might even have to be UTF-8
11:15:59 <Deewiant> not sure
11:16:28 <yitz> Pistahh: Once, my brother and sister-in-law were arriving on a flight in the middle of the night. I wanted to write a note on the door saying "it's unlocked, come in", but that's not safe. My sister-in-law speaks Hungarian. So I looked up each of those words on the Internet and wrote them. She didn't understand what I wrote. :)
11:16:34 <Peaker> because its unclear how it can convert a string to an error type
11:17:02 <ndm> I have a stack overflow in Hoogle
11:17:08 <ndm> how on earth do I begin to debug it?
11:17:12 <Peaker> I wanted to rely on pattern-match failures to call fail, but I'll have to do the pattern matching myself with case, I guess
11:17:31 <yitz> ndm: I would have said "ask ndm".
11:17:32 <ndm> it only happens when converting the base libraries, so with fairly large amounts of data
11:17:52 <ndm> but levels of data that shouldn't otherwise be a problem...
11:18:02 <Pistahh> yitz: bad luck if the burglar is a native hungarian ;)
11:18:04 <ndm> any way to see who put thunks on teh stack?
11:18:24 <lispy> ndm: I would start with the profiler
11:18:49 <ndm> lispy: heap or time?
11:18:50 <lispy> ndm: but, it's not something i have much experience debugging outside of infinite recursions
11:18:58 <yitz> Pistahh: yeah. some burglars are illiterate, so that increases my chances.
11:19:01 <ankh47> anybody could point me to some info on how to best represent a "cache" in haskell ? thread, State monad or something even better ?
11:19:44 <lispy> ndm: Well, heap isn't the problem, and time isn't either.  So, hmm.
11:20:12 <lispy> ndm: I would use it to see if I can determine who is getting called too much and what is going on the stack.
11:20:33 <lispy> I don't know if a crashing program generates a useful profile
11:21:16 <yitz> ndm: the first simple thing to do would be a quick browse through to make sure that there isn't a foldl or foldr that slipped through.
11:21:17 <ndm> lispy: yeah, i have debugged infinite recursions that way, but i am fairly certain this would terminate, given a chance :)
11:22:45 <ndm> yitz: how do you mean? slipped through?
11:22:46 <dolio> ndm: Maybe +RTS -xc? I've never used it before.
11:23:16 <dolio> (Needs the app to be compiled for profiling.
11:23:24 <ronwalf> hm... darcs get on the ghc head isn't so fast.
11:23:25 <yitz> ndm: that should have been a foldl'.
11:24:14 <ndm> dolio: what does -xc do? i can't find it eaisly
11:24:27 <ndm> i'm going to try -hc -xt, heap profile including the stack (i think)
11:24:36 <lispy> ndm: I think yitz is saying you might have some obvious place where you need strictness
11:24:38 <dolio> ndm: It supposedly uses cost centers to give 'helpful information' about the location of runtime errors.
11:25:07 <ndm> oh, that may actually have given something...
11:25:27 <dolio> But like I said, I've never actually used it.
11:25:30 <yitz> ndm, lispy: yeah. the most common case (and easiest to catch by eye when scanning through a large code base) being wrong fold.
11:26:30 <ndm> i've found a couple of foldl's and flipped them to foldl' 's
11:26:32 <Peaker> lispy: ok, it works :)
11:26:52 <lispy> Peaker: sweet
11:27:34 <dcoutts> Baughn: no
11:28:22 <dcoutts> ndm: not any especially good reason. What do you need to pass? and perhaps you'd like to comment on this ticket: http://hackage.haskell.org/trac/hackage/ticket/196
11:28:24 <lambdabot> Title: #196 (ability to specify custom args to haddock) - Hackage - Trac
11:30:03 <ndm> dcoutts: nothing special, just -w to supress warnings, and seemed a more logical time to pass it
11:30:11 <ndm> yay, have fixed the stack overflow :)
11:30:35 <yitz> ndm: great! we all love hoogle!
11:30:38 <ndm> two foldl -> foldl' things
11:32:06 <yitz> ndm: foldl is almost always a mistake.
11:33:52 <blarz> I LIKE CAPSLOCK DOMAINS
11:33:53 <blarz> ;)
11:37:02 <CosmicRay> i hate capslock
11:37:09 <CosmicRay> most useless key on the keyboad
11:37:14 <CosmicRay> and right where ctrl should be
11:37:25 <blarz> there's xmodmap :)
11:37:29 * CosmicRay uses it
11:37:39 <CosmicRay> causes me great consternation when I use someone else's keyboard though
11:37:45 <blarz> I got really used to sun keyboards
11:37:47 <CosmicRay> or when my boss tries to use mine
11:37:56 <dublpaws> at least is doesn't write over your program like the <insert> key does
11:38:02 <CosmicRay> heh
11:38:11 <Peaker> I prefer ctrl where it is..
11:38:20 <Peaker> I press it with the base of my hand, not any finger..
11:38:22 <jpcooper> does anyone know how to fix haskell-mode to indent if-statements properly?
11:38:30 <blarz> when I'm using screen and capslock is mapped to ctrl it's a bit nicer IMHO
11:38:32 <CosmicRay> the base of my hand doesn't reach out that far
11:38:37 <CosmicRay> and that would seem to be painful
11:38:54 <Peaker> CosmicRay: the base of the hand right next to the little finger
11:38:57 <erikc> when ppl sit at my visual studio which has viemu + ctrl as capslock, hilarity ensues
11:39:17 <Elly> the next step is to just use vim :P
11:39:26 <jpcooper> the next step is to just use emacs :p
11:39:30 * CosmicRay notices that the eee has vim but not emacs preinstalled
11:39:35 <CosmicRay> viper anyone?
11:39:38 <CosmicRay> I keep meaning to try it.
11:39:39 <thetallgu1> I've always wanted a keyboard with a smaller space bar, only accessible to the right thumb, and ctrl/alt under the left thumb
11:39:44 <CosmicRay> it actually looks like a better vi than vim
11:39:59 <erikc> i use viper + vimpulse to get vim-ness in emacs
11:40:03 <erikc> its mostly correct
11:40:05 <CosmicRay> vimpulse?
11:40:18 <erikc> http://www.emacswiki.org/cgi-bin/wiki/vimpulse.el
11:40:20 <lambdabot> Title: EmacsWiki: vimpulse.el
11:40:24 <blarz> erikc: why use emacs at all then?
11:40:25 <CosmicRay> vim's haskell indentation sucks worse than emacs' does by a long shot
11:40:45 <jpcooper> surely with all this talk of emacs, someone can tell me how to get indenting of if-statements to work
11:40:50 <erikc> blarz: cause i like elisp for manipulating text, i just grew up on vim's bindings
11:40:54 <Peaker> jpcooper: do you know elisp? :)
11:41:00 <CosmicRay> jpcooper: it works fine.  maybe just not how you want it to work eh ;-)
11:41:00 <jpcooper> sadly not
11:41:04 <shepheb> jpcooper: it seems to work for me
11:41:06 <blarz> erikc: I see
11:41:06 <thetallgu1> jpcooper: he
11:41:09 <shepheb> though I'm using the CVS version
11:41:12 <jpcooper> aah
11:41:12 <Peaker> I hate elisp, but its better than some ad-hoc kludge language which is what vim seems to have :)
11:41:27 <blarz> perhaps I'll check that out, too. as I really, really can't stand emacs keybindinds.
11:41:31 <thetallgu1> jpcooper: it works outside the do construct
11:41:34 <jpcooper> also, is there some kind of function which would see the function of anaphoric if-statements?
11:41:43 <Peaker> I override most of emacs's horrible defaults in my dotemacs
11:42:06 <erikc> yea, i've tried using the ruby/perl/python support im vim for scripting...its ok, but emacs just has a lot more code available in a single lang that works fairly seemlessly
11:42:22 <Peaker> I do not understand how anyone ever thought that these defaults are usable. 3 keys for the default UNDO operation?  3 keys to START a buffer switch? man
11:43:27 <jpcooper> shepheb, could you tell me how to get the cvs version? I see the link to the repository on the page, but I'm not too savvy with CVS
11:44:29 <shepheb> I was guessing too, there's a link on that page that leads somewhere with instructions on how to get it.
11:44:57 <jpcooper> aah, I see now
11:46:01 <jpcooper> @hoogle (a -> Bool) -> [a] -> Maybe [a]
11:46:02 <lambdabot> No matches, try a more general search
11:46:10 <jpcooper> is there no find all function?
11:46:17 <Deewiant> filter?
11:46:25 <jpcooper> duuh
11:46:29 <Deewiant> :-P
11:50:10 <andun> @hoogle (a -> Bool) -> [a] -> [a]
11:50:10 <lambdabot> Prelude.filter :: (a -> Bool) -> [a] -> [a]
11:50:11 <lambdabot> Prelude.takeWhile :: (a -> Bool) -> [a] -> [a]
11:50:11 <lambdabot> Prelude.dropWhile :: (a -> Bool) -> [a] -> [a]
11:50:37 <ndm> Hoogle 4 would have figured that out without a sweat...
11:50:51 <ndm> it considers Maybe [a] and [a] to be very very similar
11:51:49 <shepheb> you can fake it. do your liftX, then >> return id
11:51:54 <shepheb> mischan
12:03:45 <r3m0t> @users
12:03:45 <lambdabot> Maximum users seen in #haskell: 499, currently: 497 (99.6%), active: 19 (3.8%)
12:06:42 <Botje> OMG DONS LIED
12:06:48 <Botje> there's only 499 people here!
12:06:50 <Shiruka> \bot's mind is going
12:07:06 <Deewiant> yesterday, \bot thought there were a few more than there really were
12:07:09 <Deewiant> which might explain it
12:07:24 <Botje> is \bot on hallucinogenic foods?
12:07:33 <Deewiant> ?users
12:07:33 <lambdabot> Maximum users seen in #haskell: 500, currently: 500 (100.0%), active: 22 (4.4%)
12:07:34 <thetallgu1> I'm schizophrenic
12:07:35 <Deewiant> whee
12:07:37 <Shiruka> \bot's arithmetic was designed by Intel?
12:07:43 <thetallgu1> but I'm also logged on twice
12:09:14 <jeffersonheard> what wiki system does haskell.org use?
12:09:38 <jeffersonheard> n/m
12:09:39 <jeffersonheard> found it
12:10:10 <Peaker> annoying that Haskell wouldn't let me have that final comma (e.g [1,\n2,\n])
12:10:38 <EvilTerran> that's why a lot of folk put the , at the beginning, iirc
12:11:08 <EvilTerran> or, if you're splitting it over multiple lines, you could write 1:\n2:\n3:\n[]
12:11:22 <Peaker> interesting alternative
12:11:46 <sm> yes, I like that feature in python
12:12:35 <Peaker> is there a built-in memoize?
12:12:45 <Peaker> (that lives inside some monad)
12:15:01 <EvilTerran> Peaker, no, not really
12:15:08 <EvilTerran> you could write a memoising fix
12:15:17 <EvilTerran> but you'd need some kind of class constraint on the parameter
12:15:24 <EvilTerran> probably Ord, so you could memo in a Map
12:16:03 <EvilTerran> well, an IORef Map with unsafePerformIO
12:16:10 <Peaker> that makes sense - why isn't it in the stdlib?
12:16:13 <dolio> I'm not sure you'd want to memoize into a Map.
12:16:24 <dolio> At least, not with a memoizing fixedpoint combinator.
12:16:28 <EvilTerran> dolio, what would you suggest?
12:16:39 <Deewiant> HashTable!
12:17:05 <dolio> Either an Array if you want to specify the domain of memoization, or a lazy, infinite trie.
12:17:26 <EvilTerran> a trie was my next suggestion
12:17:41 <Peaker> well, its not really trie-able
12:17:41 <sebaseba> @users
12:17:41 <lambdabot> Maximum users seen in #haskell: 502, currently: 502 (100.0%), active: 20 (4.0%)
12:17:42 <EvilTerran> but that would require a new class constraint
12:17:45 <sms_> can anyone  help me with hdbc? i have a list of keys (e.g. [1..3]) and i want to do a query like "SELECT * FROM foo WHERE id = (1,2,3)"
12:17:58 <EvilTerran> (or a value-to-tree-path function)
12:18:14 <dolio> Sure.
12:18:47 <Peaker> EvilTerran: using an IORef Map with unsafePerformIO sounds evil
12:18:58 <EvilTerran> Peaker, indeed, i don't really like that idea
12:19:03 <EvilTerran> but it'd be the quickest to implement, i think
12:19:09 <hackage> Uploaded to hackage: edit-distance 0.1
12:20:11 <Peaker> EvilTerran: I'm writing an educational toy - I have a "namespace" of expressions that can refer to each other by name (where name is just an identifier, not necessarily a string-name). I want to be able to walk that graph and basically avoid cycling (I was hoping a simple memoize to avoid the cycles)
12:21:14 <Peaker> I guess that doesn't work anyhow, and I need to think about it some more :)
12:22:41 <EvilTerran> Peaker, could you uniquely label the graph nodes easily?
12:22:50 <Peaker> EvilTerran: those are the names, yeah
12:23:21 <EvilTerran> then you could store the graph as a Map Label ({- OtherData, -} Set Label)
12:24:21 <Peaker> well, I am storing the graph as Map Label OtherData  -- where OtherData has the set of labels inside it (as they have different roles)
12:24:52 <Peaker> I'm recursing on the graph to type-check it, and I don't want to re-typecheck something I already have type-checked
12:26:32 <Toxaris> Peaker: what about typechecking in a state monad with state (Map Label Type)
12:26:35 <dino-> sms_: You're talking about when calling something that takes a SQL string?
12:27:00 <Peaker> Toxaris: That could work - I think I ought to separate the type checking (which recurses everywhere) from the computation of the expression's type (which only recurses as necessary and must not cycle)
12:27:09 <dino-> Is this really a format [a] into "a1, a2, a3" string problem?
12:27:10 <sms_> dino-, my problem is that i don't know how many keys i will enter into the query
12:27:41 <sms_> if i search for one key, the query would be "SELECT .... WHERE key=?"
12:28:06 <dino-> sms_: As a total SQL beginner, I should ask if that "WHERE id = (1, 2, 3)" notation is actually legal SQL.. ?
12:28:25 <dino-> My naive guess is.. not really
12:28:44 <Twey> dino-: It isn't
12:28:47 <Twey> It's W
12:28:48 <sms_> no, i think it has to be "... key in (...)".
12:28:48 <Twey> Gah
12:28:55 <Twey> "WHERE id IN (1, 2, 3)"
12:29:08 <sms_> Twey, do you know how to do it with hdbc?
12:29:15 <Twey> Not a clue
12:29:25 <Twey> I know SQL, but still working on the Haskell end.  :)
12:29:30 <dino-> ah, so you could take your [k] and make that into "(k1, k2, k3)" string?
12:29:34 <gwern> @seen dons
12:29:34 <lambdabot> dons is in #arch-haskell, #xmonad, #ghc and #haskell. I last heard dons speak 1h 4m 2s ago.
12:29:54 <dino-> Oh, nevermind
12:29:58 <sms_> i already tried the string version but it didn-'t work
12:30:13 <dino-> It's the id part that you have an unknown number of?
12:30:20 <sms_> yes
12:30:25 <gwern> @tell dons if you want to dispell the idea that bytestring is fast primarily because of using C, scrapping those 'obsolete' C lines would be an excellent propaganda point
12:30:25 <lambdabot> Consider it noted.
12:31:41 <dolio> Does bytestring use C?
12:31:53 <erikc> i thought it just used peeks and pokes
12:32:02 <dolio> I thought it was all low-level GHC stuff.
12:32:42 <dino-> Maybe this could help:
12:32:44 <dino-> > Data.List.intercalate "," ["a", "b", "c"]
12:33:00 <lambdabot>  thread killed
12:33:08 <dino-> huh
12:33:30 <dolio> The only C I can name that it uses is memcpy.
12:34:34 <Jedai> dolio: On the other hand, is that even C ?
12:34:35 <dino-> > Data.List.intersperse "," ["a", "b", "c"]
12:34:45 <dolio> Jedai: No idea.
12:34:51 <lambdabot>  thread killed
12:34:55 <dino-> oh my
12:35:01 <dolio> > 2
12:35:06 <dino-> sms_: Well, plug that intercalate one into your ghci
12:35:16 <lambdabot>  thread killed
12:35:21 <EvilTerran> @bot
12:35:21 <lambdabot> :)
12:35:21 <dolio> @undefine
12:35:33 <dino-> I'm wondering if that can (perhaps with show, depending on your types) help to construct a IN (...) string for your query.
12:35:36 <lambdabot> thread killed
12:35:37 <dolio> > 2
12:35:53 <lambdabot>  thread killed
12:36:00 <dolio> Awesome.
12:36:08 <jeffersonheard> if I do a writeFile after a readFile, it whines that the file is locked...
12:36:09 <sms_> dino-, i already tried that
12:36:10 <EvilTerran> @undef
12:36:20 <lambdabot> Undefined.
12:36:23 <jeffersonheard> should it?  Algebraically, it makes sense
12:36:24 <EvilTerran> > 23
12:36:34 <jeffersonheard> but I don't much like using handles.
12:36:40 <lambdabot>  thread killed
12:36:44 <sms_> jeffersonheard, is it the same file?
12:36:58 <jeffersonheard> yes
12:37:04 <mauke> jeffersonheard: readFile hates you
12:37:09 <dolio> readFile reads lazily.
12:37:17 <sms_> jeffersonheard, and besides all the hat it is lazy
12:37:19 <EvilTerran> @vixen are you okay?
12:37:20 <lambdabot> yes, i am
12:37:51 <jeffersonheard> yeah, that's what I figured when I read it.  I'm switching to the h* method of file read/write
12:38:05 <EvilTerran> hGetContents reads lazily too
12:38:26 <jeffersonheard> yes, but if I do an hClose, it's closed
12:38:34 <EvilTerran> no, it's half-closed
12:38:45 <EvilTerran> if you hGetContents'ed it first
12:38:57 <EvilTerran> until reading the rest of the file is forced
12:39:01 <dolio> If you do an hClose, you'll kill any lazy input from hGetContents.
12:39:14 <EvilTerran> dolio, uh? i thought that was half-closing?
12:39:24 <EvilTerran> or is that the state between the hGetContents and the hClose?
12:39:31 <jeffersonheard> I realize that..
12:39:37 <dolio> I imagine hClose really closes it.
12:39:45 <EvilTerran> ok, that makes sense, now i think about it
12:39:45 <jeffersonheard> hClose really closes it
12:39:50 <jeffersonheard> which is why I ran into my last bug
12:40:01 <jeffersonheard> because I don't force the read until after the hClose takes place
12:40:11 <jeffersonheard> unfortunately.  easy to fix...
12:40:16 <jeffersonheard> thanks for helping me talk it out
12:40:52 <dino-> It's not something like they need to be wrapped in ' ', is it?
12:41:07 <dolio> There's some kind of strict IO on hackage, I think, so you don't have to do it manually.
12:41:25 <dino-> Not sure of types here (both in your Haskell and in the table field)
12:41:57 <dolio> @hackage strict
12:41:57 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/strict
12:42:23 <jpcooper> is there an exponentiation function that works with floats
12:42:24 <jpcooper> ?
12:42:39 <dolio> @type (**)
12:42:54 <lambdabot> thread killed
12:42:56 <dolio> Well, that's it.
12:43:13 <dolio> You'll have to take my word for it.
12:43:15 <r3m0t> @ho (Floating a) => a -> a -> a
12:43:15 <lambdabot> Maybe you meant: hoogle hoogle+ . ? @ bf echo ft ghc id pl rc show thx v wn yow
12:43:22 <r3m0t> @hoogle (Floating a) => a -> a -> a
12:43:23 <lambdabot> Prelude.(**) :: Floating a => a -> a -> a
12:43:23 <lambdabot> Prelude.logBase :: Floating a => a -> a -> a
12:43:23 <lambdabot> Prelude.asTypeOf :: a -> a -> a
12:43:30 <jpcooper> thanks
12:43:53 <jpcooper> @source asTypeOf
12:43:53 <lambdabot> asTypeOf not available
12:44:01 <jpcooper> @source Prelude.asTypeOf
12:44:01 <lambdabot> Prelude.asTypeOf not available
12:44:15 <r3m0t> jpcooper: asTypeOf = id
12:44:21 <r3m0t> jpcooper: asTypeOf = const
12:44:21 <jeffersonheard> dolio, I was able to take care of it with a simple $! after my liftIO call that I was already making
12:44:35 <jeffersonheard> kind of ugly, but it works fine, and this is just a CGI script
12:44:46 <r3m0t> :t 3 `asTypeOf` (5::Int)
12:44:47 <lambdabot> Int
12:44:59 <r3m0t> :t 3.0 `asTypeOf` (5::Double)
12:45:00 <lambdabot> Double
12:45:01 <gwern> @tell lispy src/Workaround.hs:31:17: Could not find module `System.Directory': it is a member of package directory-1.0.0.0, which is hidden <-- got stuck there, don't know how to fix this outside of cabal. looks like split-base problems
12:45:01 <lambdabot> Consider it noted.
12:45:20 <gwern> @tell lispy latest darcs, obviously; I did run autoreconf
12:45:20 <lambdabot> Consider it noted.
12:56:45 <FordCortina> no matter what i do the lastest ghc snapshot never builds with readline
12:56:55 <FordCortina> :(
12:57:52 <rwbarton> FordCortina: I think it no longer uses readline, but editline instead
12:58:11 <FordCortina> rwbarton: will i have both installed
12:58:13 <FordCortina> well*
12:58:19 <FordCortina> + dev packages
12:58:20 <Trinithis> @pl \s -> (liftS head s, liftS tail s)
12:58:20 <lambdabot> ap ((,) . liftS head) (liftS tail)
12:58:30 <rwbarton> hmm, I don't know then
12:58:48 <FordCortina> i suppose i havent tried --with-editline
12:59:00 <EvilTerran> Trinithis, (liftS head &&& liftS tail)
12:59:05 <Trinithis> :D
12:59:18 <EvilTerran> or ((&&&) `on` liftS) head tail
12:59:19 <EvilTerran> :P
12:59:39 <Trinithis> on is a cool combinator
13:00:04 <EvilTerran> so is (&&&)
13:00:20 <calvins_> any haskell folks interested in Twine (http://www.twine.com/tour/overview)? i have some invites to share.
13:00:20 <Trinithis> I ought to learn about arrows sometime soon
13:00:43 <Heffalump> Trinithis: they're a lot less useful than they seem they should be
13:00:45 <Heffalump> IME
13:01:11 <Heffalump> I keep finding what seems like a good application and then realising they don't quite fit.
13:01:18 <Trinithis> lol
13:01:27 <EvilTerran> Heffalump, mostly because of arr?
13:01:29 <Heffalump> And the arrow notation, while really cunning, is complicated and has a non-local desugaring.
13:01:45 <Heffalump> EvilTerran: the precise reason varies.
13:02:03 <kowey> gwern: wait for my new patch to arrive in the official darcs repo (or apply it yourself)
13:02:28 <kowey> gwern: it's about split base (unless I misunderstand) and telling GHC to hide all packages
13:03:37 <Trinithis> @pl \x -> if' (p x) (f x) (g x)
13:03:38 <lambdabot> ap (liftM2 if' p f) g
13:03:45 <gwern> kowey: sure. lispy asked to me whether it worked at the moment, tho
13:04:30 <kowey> gwern: oh, ok... it's just that I didn't see it when I did darcs pull
13:04:41 <Trinithis> @ty if' <*> p <*> f <*> g
13:04:42 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
13:04:55 <EvilTerran> if' isn't visible to @type
13:05:03 <Trinithis> o
13:05:15 <Trinithis> well is that equiv to : ap (liftM2 if' p f) g
13:06:05 <RayNbow> understanding Haskell is full of "Aha-Erlebnissen"... I finally see how liftM2 works for Reader :)
13:06:07 <EvilTerran> @let if' p x y = if p then x else y
13:06:07 <lambdabot> Defined.
13:06:12 <EvilTerran> @ty if' <*> p <*> f <*> g
13:06:13 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
13:06:16 <EvilTerran> ...
13:06:25 <Trinithis> @let if2 p x y = if p then x else y
13:06:26 <lambdabot> Defined.
13:06:32 <Trinithis> @ty if2 <*> p <*> f <*> g
13:06:33 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
13:06:37 <EvilTerran> @ty (undefined :: Bool -> a -> a -> a) <$> p <*> f <*> g
13:06:37 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
13:06:46 <Trinithis> lol
13:06:50 <EvilTerran> @ty undefined :: Bool -> a -> a -> a
13:06:51 <lambdabot> forall a. Bool -> a -> a -> a
13:06:59 <EvilTerran> @ty (undefined :: Bool -> a -> a -> a) <$> p
13:07:01 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
13:07:06 <EvilTerran> @ty (undefined :: Bool -> a -> a -> a) . p
13:07:07 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
13:07:09 <Trinithis> perhaps spec p
13:07:10 <EvilTerran> wait, no p
13:07:13 <EvilTerran> >.<
13:07:16 <EvilTerran> I FAIL
13:07:21 <EvilTerran> ?type liftA3 if'
13:07:22 <lambdabot> forall t (f :: * -> *). (Applicative f) => f Bool -> f t -> f t -> f t
13:07:30 <FordCortina> hmm ghc still isnt compiling with editline even with --with-editline
13:07:31 <EvilTerran> that's what you want
13:07:39 <Trinithis> k
13:07:53 <EvilTerran> ?type \p f g -> if' <$> p <*> f <*> g
13:07:54 <lambdabot> forall t (f :: * -> *). (Applicative f) => f Bool -> f t -> f t -> f t
13:07:56 <EvilTerran> is equivalent
13:08:10 <EvilTerran> why is that error message broken?
13:08:22 <stepcut> is there a function like, toExp :: (??? a) => a -> HsExp, which I can use to turn a value into a HsExp at run time ? I could show the value, and then parse it using the parser, but that seems a bit roundabout
13:08:51 <EvilTerran> don't think so
13:08:56 <EvilTerran> you can achieve a similar effect with TH
13:09:01 <EvilTerran> although then it's not at run-time
13:09:12 <EvilTerran> it's more that code gets run at compile-time
13:09:17 <stepcut> hrm
13:09:29 <Trinithis> Is there talk in Haskell' about sugaring (,) x to (x,) ?
13:09:38 <EvilTerran> there's muttering, yes
13:11:04 <erikc> is there a way to iterate over an arbitrary tuple's members, or do you need to make versions for each tuple size?
13:11:35 <mauke> .oO( HList )
13:11:54 <Trinithis> erikc: Template haskell?
13:12:44 <erikc> yea, TH could do it, or you could make a data type to represent a tuple where the second member might be another tuple recursively, and unpack it recursively
13:13:30 <Trinithis> data Hetero a = a :> Hetero b | Nil   ?
13:14:01 <mauke> not in scope: b
13:14:17 <byorgey> you would need a  forall b.
13:14:32 <Trinithis> oh
13:14:34 <byorgey> but that's probably not what you want anyway.
13:14:53 <byorgey> anyway, that's just HList =)
13:15:08 <mauke> it's also nested tuples
13:15:13 <_polux> hi
13:15:39 <Shiruka> "just HList"? Isn't HList some scary olegian type monster? :-O
13:17:12 <gwern> yes
13:17:28 <mauke> from what I've seen HList is just (a, (b, (c, ())))
13:17:32 <Trinithis> erikc: How about just nesting a bunch of pairs?
13:18:07 <erikc> yea
13:18:22 <erikc> that's how you'd do it in c++ template metaprogramming
13:19:14 <Candelagirl> hello
13:19:17 <Shiruka> every time you unsafePerformIO, Oleg's type monsters eat an innocent Haskell programmer
13:19:46 <Trinithis> What is an Oleg type monster O.o?
13:20:25 <mauke> @where oleg
13:20:25 <lambdabot> http://okmij.org/ftp/
13:20:27 <_polux> i've read the introduction to monads of the haskell wikibook, which starts with the construction and motivation step by step of a random monad
13:20:30 <gwern> this is so annoying; why do haskell-cafe emails on haskell.org rank so far down in search results?
13:20:47 <_polux> the type Random a is an alias for Seed -> (Int -> Seed)
13:21:09 <_polux> after that i wanted to experiment the Monad typeclass
13:21:23 <_polux> so I've tried :
13:21:32 <_polux> instance Monad Random where ...
13:22:06 <_polux> but then ghc complains about the alias "Random a" not to be fed with some a
13:22:13 <_polux> if I write
13:22:14 <byorgey> _polux: note, you can't really make instances of type aliases
13:22:26 <_polux> byorgey, that what my guess
13:22:37 <byorgey> _polux: you'll have to make a newtype, like this:  newtype Random a = Random (Seed -> (Int -> Seed))
13:22:40 <byorgey> that should work
13:22:43 <_polux> so I've changed for Ramdom a = Ran (Seed...
13:22:44 <_polux> ok
13:22:50 <_polux> you just wrote it :)
13:22:55 <byorgey> yeah, or Ran (Seed -> ...
13:23:07 <_polux> but that makes the code less readable..
13:23:30 <_polux> is'n there any solution like instance Monad (fa a, Random a) where
13:23:36 <_polux> or something like that ?
13:23:54 <byorgey> nope =)
13:24:06 <_polux> ok :)
13:24:15 <_polux> but is there a good reason for that ?
13:24:26 <byorgey> yeah, the Ran constructor everywhere is annoying
13:24:40 <byorgey> there probably is, but I don't know what
13:24:42 <_polux> 8ok
13:24:43 <_polux> ok
13:24:47 <_polux> thanks
13:24:49 <byorgey> sure
13:24:55 <byorgey> have fun playing with monads =)
13:25:17 <_polux> i'm sure i will :)
13:27:53 <monochrom> Hey! I heard #haskell finally broke through 500 while I was away!
13:28:08 * monochrom should be away more. maybe it'll hit 600 soon too. :)
13:28:10 <mrd> .users
13:28:14 <mrd> ?users
13:28:14 <lambdabot> Maximum users seen in #haskell: 503, currently: 492 (97.8%), active: 29 (5.9%)
13:28:36 <mrd> i was away too!
13:28:54 <monochrom> Yeah, we should all leave the channel so it grows faster!  *gasp*
13:30:49 <roconnor> can we still all fit on a jumbo jet?
13:31:21 <Heffalump> has anyone worked out whether the trend is exponential or polynomial?
13:31:50 <skorpan`> more like a nyquist curve
13:31:52 <roconnor> or superpolynomial but subexponential?
13:32:18 <skorpan`> http://upload.wikimedia.org/wikipedia/en/7/77/Nyquist.svg
13:32:44 <roconnor> Heffalump: I believe that the number of passengers that can fit on an airplane grows exponentially
13:33:05 * sebaseba thinks lambdabot somehow managed to do unsafePerformIO and multiplied itself
13:33:15 <roconnor> o_O
13:33:34 <byorgey> we can easily all fit on a jumbo jet, if we don't care too much about comfort =)
13:33:50 <roconnor> @vixen have you been seeing preflex?
13:33:59 <lambdabot> good question
13:34:13 <olsner> sebaseba: maybe \bot just forkIO'd a few children
13:35:51 <sebaseba> isn't today HWN day?
13:35:54 <monochrom> Cale was dating lambdabot. I didn't know they now have children!
13:36:04 <skorpan`> kan
13:36:47 <byorgey> sebaseba: it is! I'm working on it as we speak =)
13:37:40 <sjanssen> @quote augustss
13:37:40 <lambdabot> augustss says: Haskell already has enterprise monads; there is a fail method.
13:37:42 <sjanssen> @quote augustss
13:37:43 <lambdabot> augustss says: <wy> augustss: Wow. You win the IOCCC three times! <augustss> wy: i'm bad at C programming ;)
13:37:44 <sjanssen> @quote augustss
13:37:44 <lambdabot> augustss says: <wy> augustss: Wow. You win the IOCCC three times! <augustss> wy: i'm bad at C programming ;)
13:37:45 <sjanssen> @quote augustss
13:37:46 <lambdabot> augustss says: <wy> augustss: Wow. You win the IOCCC three times! <augustss> wy: i'm bad at C programming ;)
13:37:47 <sjanssen> @quote augustss
13:37:47 <lambdabot> augustss says: Haskell boggles my mind too. :)
13:37:49 <sjanssen> @quote augustss
13:37:49 <lambdabot> augustss says: Given that strength of the Haskell type system it wouldn't be that hard to write a compiler from some language into a Haskell type.
13:37:51 <sjanssen> @quote augustss
13:37:52 <lambdabot> augustss says: hbc still has some unique features, like views.  that i've never used..
13:37:54 <sjanssen> @quote augustss
13:37:54 <lambdabot> augustss says: <wy> augustss: Wow. You win the IOCCC three times! <augustss> wy: i'm bad at C programming ;)
13:37:57 <sjanssen> damnit
13:38:06 <sjanssen> lambdabot: you're so very forgetful
13:39:38 <Shiruka> can you do qualified imports in ghci?
13:40:23 <monochrom> Yes.
13:40:30 <gwern> Shiruka: just do fully qualified names
13:40:37 <gwern> Data.List.intercalate or something
13:41:11 <monochrom> I concur.
13:41:58 <Shiruka> yeah, that works, but if you e.g. ":m +Data.Map", then you get to use e.g. Prelude.lookup.. :-/
13:41:59 <yitz> @vixen you're so very forgetful
13:41:59 <lambdabot> i forget stuff pretty easily sometimes
13:41:59 <Twey> Doesn't appear to work
13:42:41 <monochrom> Oh, don't :m +Data.Map then.  You can use lookup and Data.Map.lookup
13:42:48 <monochrom> @bot
13:42:48 <lambdabot> :)
13:42:53 <Shiruka> .. ah
13:43:04 * Shiruka is enlightened
13:43:21 <gwern> yeah, GHCi lets you use fully qualified names without importing the appropriate module
13:43:27 <gwern> this is horrible security-wise, but convenient
13:43:40 <sebaseba> how do people here run GHCi? from emacs or vi, from bash...?
13:43:46 <pozic> Is there a package to draw graphs of user-functions?
13:44:01 <yitz> it would be great if ghci had an analogue of import qualified as.
13:44:03 <monochrom> I run ghci from emacs sometimes, bash sometimes.
13:44:26 <Twey> I run from bash
13:44:27 <gwern> sebaseba: usually from emacs, but emacs ghci doesn't let me do tab-completion, so sometimes frmo terminal
13:44:38 <sebaseba> is there a way to get syntax highlighting in GHCi?
13:44:45 <monochrom> I run ghci from bash when I finish grading and add up marks. :)
13:44:55 <Twey> gwern: You know, I never knew it had tabe-completion
13:44:58 <Twey> tab**
13:44:59 <sebaseba> i run from bash too
13:45:04 <monochrom> (Next time I'll just use lambdabot!)
13:45:31 <mauke> > 1366%768
13:45:37 <lambdabot>  683%384
13:45:43 <gwern> Twey: well, now you know. (CAUSE KNOWLEDGE IS POWER!)
13:45:54 <Twey> Mwahahahaha!
13:46:09 <jeffersonheard> er...  okay, this is odd
13:46:21 <RayNbow> @karma conal
13:46:21 <lambdabot> conal has a karma of 0
13:46:29 <gwern> jeffersonheard: I beg to differ. if you follow my allusion, it's not odd at all
13:46:29 <RayNbow> conal++
13:46:31 <jeffersonheard> I try //localhost/gigapixel/test/DeleteAnnotation.cgi?ordinal=1 with my new CGI script
13:46:33 <Cale> conal++
13:46:37 <monochrom> knowledge is power. information is entropy. haskell prime is hot air.
13:46:45 <jeffersonheard> and when I do readInput, I get Nothing
13:46:53 <jeffersonheard> readInput "ordinal", that is
13:47:16 <mauke> preflex: karma conal
13:47:16 <preflex>  karma for conal: 5
13:47:22 <mauke> preflex++
13:47:28 <monochrom> is readInput the right function to call?
13:47:46 <jeffersonheard> Network.CGI.readInput works for my *other* CGI script
13:47:55 <monochrom> I'm under the impression that "ordinal=1" goes into environment variables or something.
13:48:32 <sms_> @seen chrisdone
13:48:32 <lambdabot> chrisdone is in #haskell. I last heard chrisdone speak 4h 51m 13s ago.
13:49:01 <jeffersonheard> There is very little different between the two CGI scripts I've created today
13:49:22 <jeffersonheard> one is NewAnnotation.  one is DeleteAnnotation.
13:49:31 <byorgey> pozic: maybe try the Charts library?
13:49:42 <pozic> byorgey: yes, I already installed it.
13:49:43 <jeffersonheard> The only real difference is that NewAnnotation takes two vars, xcoord and ycoord.
13:49:55 <jeffersonheard> and DeleteAnnotation takes one var, "ordinal"
13:50:02 <pozic> byorgey: have you used it?
13:50:04 <yitz> jeffersonheard: hpaste
13:50:08 <byorgey> pozic: nope
13:50:08 <yitz> @hpaste
13:50:08 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:50:19 <monochrom> Does NewAnnotation use a form?
13:50:21 <byorgey> just a random suggestion, no idea if it does what you want =)
13:51:07 <jeffersonheard> http://hpaste.org/9270
13:51:08 <jeffersonheard> this one works
13:51:40 <jeffersonheard> http://hpaste.org/9271
13:51:42 <jeffersonheard> this one does not
13:51:55 <jeffersonheard> no, it doesn't.
13:54:09 <pozic> byorgey: the examples seem promising as they work.
13:54:47 <pozic> byorgey: but hackage does not contain the documentation.
13:55:08 <byorgey> ah, that's too bad
13:56:00 <yitz> jeffersonheard: so you get "Essential variable not found: ordinal"?
13:56:06 <jeffersonheard> yes
13:56:06 <pozic> Is there a way to build the documentation with cabal install?
13:57:05 <jeffersonheard> yitz, if do a wget http://localhost/gigapixel/test/NewAnnotation.cgi?xcoord=1&ycoord=1 this works fine
13:57:07 <lambdabot> http://tinyurl.com/6b4ksl
13:57:42 <byorgey> pozic: not yet, unfortunately, I think that's a rather frequently requested feature
13:57:59 <jeffersonheard> however, if I do a wget http://bluheron.europa.renci.org/gigapixel/test/DeleteAnnotation.cgi?ordinal=1 I get back an error 500
13:58:01 <lambdabot> http://tinyurl.com/66ysa7
13:58:16 <jeffersonheard> blueheron being my computer (sorry for the localhost)
14:01:49 <A__A> Simple non-geeky question for people from a newbie:  I want to browse William H. Burge's book "Recursive Programming Techniques" (1975, Addison-Wesley).  I can only find it online as a ".DJVU" file, not a PDF.  How do I best view DJVU files?  (I am on a Mac Tiger.)
14:02:41 <monochrom> jeffersonheard: saved? re-compiled?
14:02:49 <blarz> A__A: djview
14:02:55 <blarz> IIRC
14:03:17 <jeffersonheard> yep and yep
14:03:17 <pozic> A__A: http://djvu.sourceforge.net/
14:03:18 <lambdabot> Title: DjVuLibre: Open Source DjVu library and viewer
14:03:24 <rwbarton> A__A: the mac djvu readers I've found have been a little primitive, but I think my favorite was MacDjView
14:03:28 <jeffersonheard> Crazy, isn't it?
14:03:50 <jeffersonheard> ordinal isn't some kind of CGI reserved name is it?
14:03:52 <A__A> rwbarton, thank you!
14:05:29 <yitz> jeffersonheard: sure looks like it ought to work.
14:09:55 <jeffersonheard> oh wait...  I think I found it.  readInput would have to return a string.  I thought String had an instance of Read...
14:10:11 <jeffersonheard> @type read
14:10:13 <lambdabot> forall a. (Read a) => String -> a
14:10:23 <mauke> > read "1" :: String
14:10:24 <lambdabot>  "Exception: Prelude.read: no parse
14:10:28 <mauke> > read "\"1\"" :: String
14:10:29 <lambdabot>  "1"
14:10:34 <jeffersonheard> Gotcha
14:10:46 <jeffersonheard> so it was returning Nothing rather than failing
14:10:49 <jeffersonheard> that's kinda broke
14:10:55 <jeffersonheard> however, this'll work
14:11:03 <jeffersonheard> now getInput instead of readInput
14:11:38 <Candelagirl> soy espaola
14:12:17 <mauke> spam.
14:13:29 <dons> mauke: kick?
14:13:29 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
14:14:08 <dons> gwern: good idea.
14:14:27 <dafra> msg lambdabot @messages
14:17:49 <yitz> jeffersonheard: btw, readInput' nm = readInput' nm >>= maybe (fail $ msg ++ nm) return
14:18:24 <jeffersonheard> oh I know...  I've just been hacking these apart.  They contained a whole bunch of print statements earlier
14:18:32 <jeffersonheard> I'll clean up the code when I'm done
14:18:34 <jeffersonheard> but thanks
14:19:05 <yitz> jeffersonheard: could have fooled me, looks very clean :)
14:20:05 <dons> ?users
14:20:05 <lambdabot> Maximum users seen in #haskell: 503, currently: 496 (98.6%), active: 19 (3.8%)
14:20:08 <jeffersonheard> well, thanks :)
14:20:18 <dons> cool, we climbed back over 500 for the second day
14:20:57 <yitz> #haskell - join early, join often
14:22:36 <joao> How is the number of active users determined?
14:24:25 <jeffersonheard> thanks for everyone's help
14:24:27 <jeffersonheard> off the air now
14:27:41 <dafra> > 1+1
14:27:42 <lambdabot>  2
14:30:50 <dafra> i've read that since kernel 2.5 swap files are as good as swap partitions, but the hndbook is still ll about swap partitions : are swap files ok ?
14:31:21 <dafra> oops, wrong hannel :)
14:31:38 <oldsalt>  is it possible to append bytestrings in the sense that lists of encoded values are concatenated?
14:31:58 <TomMD> What is ghc-asm?
14:32:56 <stepcut> TomMD: I think that is the evil mangler that does nasty things to the asm generated by gcc ?
14:33:16 <TomMD> Someone e-mailed me saying pureMD5 doesn't build.  The last line of their verbose 'setup.lhs build' command is:
14:33:16 <TomMD> ﻿ghc-6.8.3: could not execute: /Library/Frameworks/GHC.framework/Versions/608/usr/lib/ghc-6.8.3/ghc-asm
14:33:42 <stepcut> hrm, that sounds like a problem with their compiler installation :-/
14:33:54 <stepcut> does pureMD5 try to force the compiler to use -via-C ?
14:34:02 <TomMD> exactly what I was thinking.  Seeing as I never heard of ghc-asm I figured I'd ask.
14:34:09 <TomMD> stepcut: nope
14:34:16 <TomMD> stepcut: it does do -O2
14:34:25 <TomMD> Does that still translate to via-c?
14:34:32 <stepcut> they could try building with -fasm and see if that works better...
14:34:34 <stepcut> dunno
14:34:59 <oldsalt> dons: can you help me?
14:35:19 <stepcut> TomMD: they could also try seeing if that file exists, is executable, and if the version of perl it needs is installed
14:35:26 <stepcut> (ghc-asm that is)
14:35:36 <TomMD> will do, thanks.
14:35:46 <dons> oldsalt: sure.
14:35:52 <dons> the 'append' function
14:36:52 <oldsalt> yeah, i was wondering if append would do what i want
14:36:55 <oldsalt> i am not sure about it
14:37:19 <oldsalt> dons: and is there also something like appendFile?
14:37:34 <dons> there is appendFile
14:37:44 <dons> check the API on hackage.haskell.org
14:38:20 <oldsalt> i try. i don't completely understand it
14:40:18 <oldsalt> dons, if i have a list of integers and write it encoded to a file and i append another list of integers, what would i have to decode?
14:40:40 <oldsalt> [[Int]] ?
14:40:50 <oldsalt> or [Int] ?
14:41:39 <dons> in Data.Binary ?
14:41:47 <oldsalt> yes
14:41:58 <dons> two [Int]
14:42:13 <dons> writing and reading should be the inverse of each other.
14:42:28 <oldsalt> so i have to know, how many i have written?
14:42:42 <Botje> read until EOF? :)
14:43:13 <dons> well, its length encoded, so it knows how many to read
14:43:32 <dons> put xs ; put ys      --> xs <- get ; ys <- get
14:43:40 <dons> it knows.
14:44:38 <oldsalt> alright, but i have to use get two times in this case?
14:50:05 <ddarius> @seen conal
14:50:06 <lambdabot> I saw conal leaving #haskell and #ghc 5h 30m 51s ago, and .
14:51:31 <ddarius> @hackage reactive
14:51:31 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/reactive
14:57:29 * sw17ch wonders if allocaBytes is the appropriate way to pass a struct to a C function
14:57:42 * sw17ch or if he should implement Storable for his data type
14:58:38 <ddarius> You should have a tool implement a Storable instance for you.
14:58:41 <mauke> Storable sounds like the obvious way
14:59:12 <sw17ch> ddarius, there's a tool?
14:59:21 <ddarius> @where c2hs
14:59:21 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/c2hs/
14:59:22 <sw17ch> or perhaps i have the tool and don't know it can do this yet
14:59:24 <ddarius> @where hsc2hs
14:59:24 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/hsc2hs.html
14:59:32 <sw17ch> can c2hs do this for me?
14:59:54 <ddarius> You haven't quite stated what "this" is.
15:00:08 <sw17ch> data SomeType = SomeType Int Int Double Int String
15:00:15 <sw17ch> instance Storable SomeType where
15:00:16 <mauke> hsc2hs simplifies the definition of Storable instances
15:00:27 <mauke> but you'll still have to write it manually
15:00:33 <sw17ch> alright
15:00:41 <sw17ch> i believe that there are a few helpers in c2hs
15:00:56 <sw17ch> {#sizeof is helpful
15:01:07 <ddarius> Is the C code supposed to manipulate this structure in any way or just pass it around (or is it a C structure)?
15:02:08 <sw17ch> it's passed in as const
15:02:16 <sw17ch> and it is a c struct
15:02:22 <sw17ch> const some_type * st;
15:02:25 <hml>  /window 2
15:03:26 <ddarius> Then use c2hs.  It should be able to automatically handle reading and writing fields of the structure on the Haskell side and should be able to handle creating new ones.
15:03:48 <sw17ch> yes, that's what i was planning on doing
15:04:00 <sw17ch> the only part i'm missing is that i need to allocate the bytes on my end
15:04:11 <sw17ch> and alloca from Storable seems to be what i want
15:04:17 <sw17ch> and i'm just making sure
15:04:52 <mauke> @index with
15:04:52 <lambdabot> Foreign.Marshal.Utils, Foreign.Marshal, Foreign
15:04:57 <mauke> :t Foreign.with
15:04:59 <lambdabot> forall a b. (Foreign.Storable.Storable a) => a -> (GHC.Ptr.Ptr a -> IO b) -> IO b
15:05:45 <sw17ch> @index alloca
15:05:46 <lambdabot> Foreign.Marshal.Alloc, Foreign.Marshal, Foreign
15:05:53 <sw17ch> :t Foreign.alloca
15:05:55 <lambdabot> forall a b. (Foreign.Storable.Storable a) => (GHC.Ptr.Ptr a -> IO b) -> IO b
15:06:09 <sw17ch> identical?
15:06:15 <sw17ch> or nearly...
15:06:27 <sw17ch> err... never mind
15:06:28 <mauke> alloca gives you uninitialized memory
15:08:22 <hml> slime::scheme == ???::haskell
15:08:53 <ddarius> slime:CL you mean or do Schemers use it too?
15:08:54 <bjrn> No editor, just essence of pure thought.
15:09:57 <eu-prleu-peupeu1> hi
15:10:13 <Nafai> ddarius: I believe Scheme48 or somesuch Scheme implementation is supported in SLIME
15:17:45 <lispy> hml: you want a dev env optimized for Haskell?  What platforms are you open to using?
15:18:30 <hml> linux
15:20:42 <hml> linux and ... either vim or emadcs; willing to switch to have the best ghc experience
15:22:36 <ToRA> there are some pretty good vim bindings for haskell available
15:22:37 <EvilTerran> emacs has haskell-mode or whatever it's called
15:22:39 <EvilTerran> haven't tried it
15:22:56 <jacobian> I'm partial to emacs, but it's a religious issue :)
15:23:00 <ToRA> http://www.cs.kent.ac.uk/people/staff/cr3/toolbox/haskell/Vim/
15:23:01 <lambdabot> Title: Haskell mode for Vim
15:23:10 <hml> ToRA: cool; thanks; let me look at that; i'm originally ya vim user too
15:23:20 <ToRA> click the "little tour" link
15:23:29 <ToRA> it has screenshots :)
15:23:54 * Shiruka blesses the channel and sprinkes holy emacs bits on the people present
15:24:06 <ToRA> argh, it burns, it burns!
15:24:10 <ToRA> :p
15:24:20 <Shiruka> ah, a vimpyre :-)
15:24:38 <ToRA> :!yes
15:26:25 <blarz> lol
15:26:48 * blarz votes for quotig this :)
15:27:05 <ToRA> i don't think the emacs users'd get it
15:27:50 <Twey> Hahaha, ToRA
15:27:56 * Shiruka is an emacs user, but guesses what that would do
15:28:29 <Shiruka> ! is a fairly common shell escape command, and there's a program called yes, so 1+1=...3?
15:28:44 <ToRA> yeah, pretty much
15:28:51 <ahmo> he he, people, look at this joke -> www.microsoft.ba
15:29:16 <ToRA> ahmo: awesome
15:29:38 * sw17ch smells a lawsuit
15:30:10 <ToRA> hmm, i'd love to see the google analytics stats that they've collected on that site
15:31:11 <easytige`> ahmo: .ba ? bahamas?
15:31:30 <Twey> http://www.mslinux.org/
15:31:30 <lambdabot> Title: Microsoft Linux - the premier linux distro
15:31:55 <Trinithis> Is writeFile lazy ornot?
15:32:38 <dolio> In what way would writing be lazy?
15:32:59 <Trinithis> I just remember that readFile is lazy
15:33:56 <Twey> Doesn't really make sense for writing to be lazy...
15:34:21 <Trinithis> Good thing I guess. I wanted strict writing
15:39:22 <Shiruka> oh, there _are_ Haskell modules where you get to UTSL
15:39:43 <Shiruka> everything's so well documented these days that I was afraid I would never need to UTSL again :-P
15:40:39 <Shiruka> though this one does have a paper describing much of it, so it's not really hard core :-<
15:47:26 <gwern> anyone have ACM access? could you send me a copy of http://portal.acm.org/citation.cfm?id=62417 (at gwern0@gmail.com)? thanks
15:47:28 <lambdabot> Title: UNIX Emacs: a retrospective (lessons for flexible system design)
15:49:49 <Gnezdo> does anybody have experience with running SYB over big data sets?
15:50:43 <Gnezdo> I have a case where there is a big String in the data structure
15:50:51 <Gnezdo> and I am running out of stack space...
15:52:03 <Gnezdo> basically what I want is have "everywhere" not traverse the [Char]
15:54:17 <vixey> yeah jorick
15:54:17 <vixey> I want to talk to you come to oz please
15:54:38 <jorick> ok
15:59:38 <Beelsebob> what's the most efficient way to extract a float from a bytestring (where the bs contains a textual representaiton of the float, not an encoded version)
15:59:52 <dons> using Data.ByteString.Lex.Double
16:00:07 <dons> which provides a readDouble function that's been carefully optimised.
16:00:08 <Beelsebob> ah, cool, genious
16:00:18 <dons> in the bytestring-lexing package
16:00:52 <dons> http://hackage.haskell.org/packages/archive/bytestring-lexing/0.1.2/doc/html/Data-ByteString-Lex-Double.html
16:00:53 <Beelsebob> I was spending about 60% of my time in (read $ CBS.unpack s)
16:00:53 <lambdabot> Title: Data.ByteString.Lex.Double, http://tinyurl.com/6qmka6
16:01:03 <Beelsebob> thanks a lot dons :)
16:02:22 <dons> NEVER USE read.unpack !
16:02:28 <dcoutts> :-)
16:02:33 <Beelsebob> yeh, I just couldn't think of any other way to do it
16:02:44 <Beelsebob> hmm, does it deal with more than just doubles?  I don't see anything in the bytestring-lexing docs
16:03:08 <mar77a> ?hoogle unpack
16:03:08 <lambdabot> Data.ByteString.unpack :: ByteString -> [Word8]
16:03:08 <lambdabot> Data.ByteString.Char8.unpack :: ByteString -> [Char]
16:03:08 <lambdabot> Data.ByteString.Lazy.unpack :: ByteString -> [Word8]
16:03:28 <mar77a> time to code some C
16:03:29 <mar77a> with haskell
16:03:31 <mar77a> <3
16:03:32 <Beelsebob> i.e. I need to get ints in this way too
16:04:08 <dcoutts> Beelsebob: that's already in the bytestring package
16:04:09 <dons> readInt is in Data.ByteString.Char8
16:04:20 <Beelsebob> oh, lame, I just suck at reading docs then
16:04:32 <monochrom> heh
16:04:59 <Beelsebob> thanks muchly :)
16:05:02 * Beelsebob disapears to bed
16:05:53 <mar77a> mmm
16:06:04 <mar77a> so bytestring is like a serializer/unserializer?
16:06:16 <mar77a> i've been wanting to read binary data for a while but i still don't know how
16:07:55 <mrd> i posted some code to use strtod to parse a bytestring into a double some time ago
16:08:03 <mrd> not sure what the Lex package does
16:08:31 <mar77a> how does pack work exactly
16:08:36 <mar77a> :t pack
16:12:39 <lispy> ?hoogle pack
16:12:39 <lambdabot> Data.ByteString.pack :: [Word8] -> ByteString
16:12:39 <lambdabot> Data.ByteString.Char8.pack :: String -> ByteString
16:12:39 <lambdabot> Data.ByteString.Lazy.pack :: [Word8] -> ByteString
16:12:55 <lispy> :t BS.pack
16:12:59 <lambdabot> [Word8] -> BSC.ByteString
16:13:12 <lispy> > BS.pack (ord "hello")
16:13:14 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
16:13:23 <lispy> > BS.pack (map ord "hello")
16:13:23 <lambdabot>  Couldn't match expected type `Word8' against inferred type `Int'
16:13:34 <lispy> > BS.pack (map (fromIntegral.ord) "hello")
16:13:36 <lambdabot>  "hello"
16:13:47 <lispy> mar77a: does that help?
16:13:53 <mar77a> can it be used to read serialized binary date
16:13:55 <mar77a> data
16:13:58 <mar77a> say a 4 byte int
16:14:09 <dons> mar77a: use Data.Binary
16:14:19 <lispy> :t BS.pack (map (fromIntegral.ord) "hello")
16:14:20 <lambdabot> BSC.ByteString
16:14:23 <dons> :t Data.Binary.runGet get :: Get Int
16:14:27 <dons> :t Data.Binary.runGet (get :: Get Int)
16:14:35 <dons> :t Data.Binary.runGet (Data.Binary.get :: Data.Binary.Get Int)
16:14:37 <mar77a> Data.Binary
16:14:43 <mar77a> doesn't seem to be default :<
16:14:49 <dons> default?
16:14:55 <mar77a> part of the std lib
16:14:58 <dons> $ cabal install binary
16:15:10 <dons> there's no std lib yet, just some things ghc provides.
16:15:10 <mar77a> $ cabal install cabal
16:15:18 <dons> you're expected to install things from hackage, or your distro.
16:15:29 <mar77a> mmm gotta install cabal first
16:15:32 <dons> if you're doing serious things, this is required.
16:15:46 <dons> well, your distro might already have it.
16:15:51 <mar77a> windows xp
16:16:12 <dons> so no then.
16:16:13 <mar77a> is there a .msi?
16:16:52 <geezusfreeek> mar77a: just manually do the http, zlib, and then cabal-install packages from hackage and then you will (hopefully) never have to do hackage stuff manually again
16:18:00 <mar77a> ok
16:18:17 <geezusfreeek> i believe those two are the only prerequisites that don't come with ghc, anyway
16:21:42 <easytige`> has anyone gone through "haskell: the craft of functional. programming"? I got to the exercises on pg 29 and he seems to be assuming you know all about haskell
16:23:22 <the_ez> easytige: can you give an example?
16:24:42 <easytige`> the_ez: well the first question i have no idea what he is looking for. "how would you make a definition of a black rectangle? How could you do this without using using white but assuming you have a function superimpose
16:25:17 <the_ez> ah ok. i don't have the book in front of me but i have used it in the past
16:25:38 <the_ez> if i recall it presents a set of functions that you can use to combine pictures
16:25:50 <easytige`> the_ez: yeap
16:26:07 <the_ez> it's asking you to write an application of functions to pictures that would give you a black rectangle
16:26:24 <the_ez> it shouldn't require too much deep haskell knowledge, just the basic idea of how functions can be applied to arguments.
16:26:45 <easytige`> the_ez: ahh. ok. so no zipping or mapping and such
16:26:56 <the_ez> right
16:27:37 <easytige`> i'll give it a go.
16:27:41 <the_ez> the early questions are all simple applications of the picture function, no loops, no higher-order anything...
16:29:05 <A__A> Does anyone here know of the story of how Tony Hoare came up with quick-sort?
16:30:07 <ivanm> a pivoted array fell on his head? :p
16:30:12 <easytige`> is there a story?
16:30:33 <lispy> Does it involve Santa Claus, the Easter Bunner or elves?
16:30:34 <ivanm> does it have a happy ending?
16:30:43 <lispy> Bunny*
16:30:46 <vixey> A__A: there's a book about it on ACM
16:30:47 <A__A> (You know, like the story of how Hamilton finally hit upon quaternions.)
16:31:10 <ddarius> Hamilton didn't know what the heck he was talking about.
16:31:26 <A__A> vixey, what is it called?
16:36:46 <Shiruka> I think the ideas in the basic sort algorithms are fairly obvious, there's unlikely to be much of "how" in coming up with them..
16:37:06 <A__A> I read, or heard, a long time ago (15 years ago?) a story about how Tony Hoare went from England to a computer conference in Amsetrdam, and had to get back to work on the Monday.  He took the ferry from Amsterdam across the North Sea, and everyone was violently seasick.  The journey took 10 hours or something, and the ferry rose up and down and up and down with everyone rolling about looking green.  In his delirium he envisaged the swinging o
16:37:06 <ddarius> @google k-funnel sort
16:37:06 <A__A> data around a pivot in what became the quicksort algorithm.  I know I read this story being told by Tony Hoare, but I can find absolutely no whiff of it on the web.
16:37:08 <Shiruka> proving properties about them is the real work :-)
16:37:09 <lambdabot> http://theory.csail.mit.edu/classes/6.895/fall03/projects/papers/youn.ps
16:38:21 <A__A> vixey?
16:39:20 <novas0x2a> !
16:40:05 <easytige`> the_ez: i don't suppose you recall how to make a black rectangle without inverting the white one and using superimpose? i can't figure it out
16:40:40 <ddarius> What are the primitives?  What are the means of composition?
16:41:02 <the_ez> what's wrong with inverting the white one?
16:41:31 <easytige`> the_ez: he says to do it by not inverting the white one
16:41:41 <sal23> I enabled "-ddump-rules" options in GHC to see if the defined rules are being applied....this output ( http://hpaste.org/9275 ) doesn't seem to say anything about the rules being applied. Is that correct?
16:41:43 <the_ez> i see
16:41:47 <easytige`> the_ex: http://www.cs.kent.ac.uk/people/staff/sjt/craft2e/Code/Pictures.lhs
16:41:49 <lambdabot> http://tinyurl.com/6hma3x
16:42:20 <the_ez> maybe you can do it by superimposing enough things to make all the pixels black? casting at straws here...
16:43:02 <easytige`> thats what i though... maybe by translating the horse several times and superimposing it.
16:44:35 <A__A> Where there is no vision, the people perish.
16:45:42 <EvilTerran> couldn't you write it as a value directly?
16:46:05 <ddarius> That'd be far to sensible EvilTerran.
16:46:13 <EvilTerran> > replicate 12 (replicate 16 '#')
16:46:14 <lambdabot>  ["################","################","################","################"...
16:48:00 <ddarius> scaleRow = replicate; scaleRows = map scaleRow; scaleColumns n = transpose . scaleRows n . transpose; scale h w = scaleColumns h . scaleRowns w
16:48:29 <ddarius> scaleRow = concatMap . replicate
16:49:19 <ddarius> And I guess it would make sense to flip the order of scaleColumns and scaleRows in scale
16:55:50 <easytige`> eh?
16:58:07 <dobblego> can you annotate the kind of a type parameter in a data declaration?
16:58:20 <EvilTerran> only with -XKindSignatures
16:58:22 <ddarius> With extensions, yes.
16:58:27 <EvilTerran> or the equiv in a LANGUAGE pragma
17:01:29 <dobblego> imagine a type that is uninhabited, which I will call Nothing, does it make sense to have a "lifted Nothing"? data LiftedNothing (f: * -> *) -- I can't figure out how to type annotate here
17:02:56 <dobblego> er, kind annotate
17:02:57 <EvilTerran> data LiftedNothing a
17:03:04 <EvilTerran> data LiftedNothing :: * -> *
17:03:10 <EvilTerran> with -XKindAnnotations
17:03:18 <EvilTerran> both need -XEmptyDataDecls
17:03:26 <EvilTerran> the latter may need -XGADTs
17:03:26 <dobblego> yeah I have that
17:03:42 <EvilTerran> btw, i think the conventional name is Void
17:03:47 <EvilTerran> that's what ?djinn calls it, at least
17:03:49 <EvilTerran> ?djinn-env
17:03:49 <lambdabot> data () = ()
17:03:49 <lambdabot> data Either a b = Left a | Right b
17:03:49 <lambdabot> data Maybe a = Nothing | Just a
17:03:49 <lambdabot> data Bool = False | True
17:03:49 <lambdabot> data Void
17:03:50 <dobblego> with just 'data LiftedNothing a', then I cannot use x :: LiftedNothing []
17:03:51 <lambdabot> type Not x = x -> Void
17:03:53 <lambdabot> class Eq a where (==) :: a -> a -> Bool
17:04:09 <EvilTerran> dobblego, ah, "data LiftedNothing :: (* -> *) -> *", then?
17:04:33 <EvilTerran> sadly, we do not have kind polymorphism
17:04:42 <dobblego> data LiftedNothing (f :: * -> *) -- seems to work
17:04:50 <EvilTerran> that'd do the same thing, yeah
17:04:51 <dobblego> ok, I have it all working
17:05:01 <vixey> you don't want that
17:05:02 <dobblego> so I was writing that to ask if it makes sense to do so :)
17:05:15 <vixey> if you add kind polymorphism you must add a type system for kinds
17:05:20 <EvilTerran> it'd be nice if we could just have "data Void :: k", but that'd involve a massive redesign of the typechecker, i imagine
17:05:50 <dobblego> http://hpaste.org/9276
17:06:16 <vixey> I don't think you could program with that
17:06:18 <EvilTerran> dobblego, you'd need a different empty type for each kind of void type
17:06:59 <Saizan> dobblego: you need it as a sort of proxy for instance selection, right?
17:07:28 <dobblego> hmm dunno
17:07:53 <dobblego> I want to apply the type constructor argument in a function, since it is "empty"
17:08:30 <dobblego> in particular, I may have a Foldable across this type constructor, which just returns the starting accumulator value
17:09:07 <dobblego> I could write a Foldable for LiftedNothing and apply that type constructor argument
17:09:41 <Saizan> you still need to create a value of type (f a), no?
17:10:08 <dobblego> actually yes
17:10:47 <Saizan> so i'm not seeing how LiftedNothing helps here
17:10:53 <dobblego> me neither now :)
17:11:08 <stepcut> using Language.Haskell.*, is there a way to parse a Haskell expression (ie, not a whole module)
17:11:33 <vixey> yeaoh use parseModule
17:11:39 <dons> awesome, http://www.reddit.com/comments/6u824/formlets_web_dev_form_builders_for_haskell/
17:11:40 <lambdabot> Title: Formlets (web dev form builders) for Haskell : reddit.com, http://tinyurl.com/6ofroq
17:12:06 <thetallguy> dons: yeah, looks very interesting
17:12:41 <thetallguy> dons: and should be highly accessible to non-Haskellers
17:12:49 <dons> yeah.
17:12:56 <dons> good to see the tupil boys pushing forward.
17:13:09 <mfp> does Text.XHtml.Strict use phantom types to ensure only valid XHTML is generated?
17:13:17 <stepcut> vixey: don't I have to parse a whole module with that ?
17:14:06 <vixey> stepcut: > parseModule "x = y"
17:14:11 <vixey> ParseOk (HsModule (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 1}) (Module "Main") (Just [HsEVar (UnQual (HsIdent "main"))]) [] [HsPatBind (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 1}) (HsPVar (HsIdent "x")) (HsUnGuardedRhs (HsVar (UnQual (HsIdent "y")))) []])
17:15:53 <mfp> hmm  table :: Html -> Html  Text.Xhtml.Strict is effectively untyped (!!) :-P
17:16:09 <stepcut> vixey: well, x = y *is* a full module...
17:16:20 <vixey> looks pretty typed to me
17:16:24 <stepcut> vixey: I want to parse something like, putStrLn "hello"
17:16:27 <vixey> stepcut: I know
17:16:34 <dobblego> Saizan, http://hpaste.org/9276#a1 do you agree?
17:16:54 <awarrin2> noob to haskell over here: I thought newtype was to define a type whose representation is identical to an existing one, but in a chapter on monads in the realworldhaskell book, i'm seeing things like this: newtype Logger a = Logger { runLogger :: (a, Log) }     what is the meaning of this? they say they are wrapping a tuple in the type Logger, and you have to call runLogger ot extract that tuple...are there other examples where this is u
17:17:17 <gwern> wow, 98 comments on the 'ghc to stop using darcs' story
17:17:20 <EvilTerran> newtype Foo = Bar { unFoo :: Baz }
17:17:24 <EvilTerran> gives you a type, Foo
17:17:29 <EvilTerran> a constructor, Bar :: Baz -> Foo
17:17:38 <EvilTerran> and a deconstructor, unFoo :: Foo -> Baz
17:17:44 <mfp> vixey: it allows you to put any Html inside a table
17:18:02 <mfp> instead of only valid elements
17:18:14 <awarrin2> EvilTerran: interesting, so the function inside is called a deconstructor
17:18:25 <vixey> mfp: Doesn't allow you to add cross a penguin with a kangaroo though
17:18:26 <EvilTerran> awarrin2, by me, yes. not in general, as far as i know.
17:18:47 <stepcut> awarrin2: its just using the record syntax -- otherwise it is a normal newtype
17:18:50 <EvilTerran> it's probably a coconstructor or something
17:18:52 <sjanssen> awarrin2: the syntax there is called record syntax
17:18:52 <EvilTerran> :P
17:19:09 <sjanssen> but here it is really just a trick to easily get an unwrapper
17:19:11 <awarrin2> sjanssen: record syntax, got it thank you
17:19:20 <mfp> and? putting a body inside a table is bad enough when we're talking about generating XHTML strict
17:19:29 <stepcut> awarrin2: is mostly the same as, newtype Logger a = Logger (a, Log), except a function like, runLogger (Logger x) = x, is also automatically defined for you...
17:20:46 <awarrin2> stepcut: i see, and that makes it easier/safer to control how you extract what is "inside" the type?
17:20:54 <awarrin2> guess it wouldn't make it easier
17:21:12 <awarrin2> better api design of the type maybe
17:21:17 <stepcut> awarrin2: easier, because you can do stuff like, map runLogger [list of loggers]
17:21:32 <stepcut> instead of, map (\(Logger x) -> x) [list of loggers]
17:21:48 <EvilTerran> it saves you having to write runLogger yourself
17:21:57 <awarrin2> ahhhh makes sense!
17:22:04 <EvilTerran> it also means you can write "Logger { runLogger = ... }" if you want
17:22:09 <EvilTerran> in expressions and patterns
17:22:16 <EvilTerran> this is more useful in datas than newtypes
17:22:21 <EvilTerran> where you can have more than one field
17:23:38 <awarrin2> EvilTerran: not sure i follow you totally on that
17:23:59 <awarrin2> EvilTerran: I understand what you mean by using it in expressions, but how can that help?
17:24:02 <EvilTerran> given "data Foo = Foo { bar :: Int, baz :: Char }", you can write a function like "f foo = foo {bar = digitToInt fooBaz} where Foo{baz=fooBaz} = foo"
17:24:40 <EvilTerran> or f Foo{bar = fooBar, baz = fooBaz} = Foo{bar = digitToInt fooBaz, baz = fooBaz}
17:25:34 <EvilTerran> note that "f (Foo fooBar fooBaz) = Foo (digitToInt fooBaz) fooBaz" would mean the same thing
17:25:49 <EvilTerran> using the record syntax in the type decleration doesn't restrict you to using it everywhere
17:26:43 <awarrin2> i see
17:27:21 <EvilTerran> anyway, in newtype declerations, basically this boils down to giving you the "deconstructor" for very little extra typing
17:27:33 <EvilTerran> because you wouldn't bother with explicit record syntax for values in a newtype
17:27:54 <awarrin2> ya makes sense
17:41:01 <dobblego> data T a = T -- does this have a well recognised name?
17:42:04 <hexpuem> phantom type i think
17:42:19 <Igloo> Sometimes it's called Proxy
17:43:00 <geezusfreeek> a phantom type would have no data constructors though, wouldn't it?
17:43:41 <hexpuem> yea i think im wrong
17:43:42 <hexpuem> haha
17:44:10 <Igloo> The "a" there is a phantom type
17:44:25 <Igloo> Because it doesn't appear on the right
17:44:27 <geezusfreeek> yes
17:45:00 <geezusfreeek> but T is not a phantom type
17:57:27 <nolrai_East> is there a standard function equal to (\x -> if x then y else z) ?
17:58:52 <nolrai_East> or more usefuly liftM that.
17:59:32 <monochrom> @type when
17:59:34 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
17:59:43 <monochrom> That's half of it. :)
18:00:33 <nolrai_East> hmm
18:02:11 <nolrai_East> is there a better way to write (this is part of a larger do block) do {b <- getRandom; let xOrY = if b then x else y}?
18:04:24 <nathanic> not standard, but the bot knows it by the name if'
18:04:26 <nathanic> ﻿> if' True "true" "false"
18:05:00 <nathanic> > if' True "true" "false"
18:05:01 <lambdabot>  "true"
18:05:12 <nolrai_East> hmm
18:05:16 <nolrai_East> thanks
18:05:57 <bwr> @src if'
18:05:58 <lambdabot> Source not found. Sorry.
18:06:48 <nolrai_East> if' a b c = if a then b else c
18:07:47 <chrisdone> :t if'
18:07:48 <lambdabot> forall t. Bool -> t -> t -> t
18:18:33 <nolrai_East> Whats the syntax for stand alone deriving clauses?
18:19:13 <nolrai_East> They do exist right?
18:19:16 <mauke> Ghost in the Shell: Stand Alone Deriving
18:19:32 <nolrai_East> lol (for real)
18:20:01 <mauke> something like 'deriving instance Show Foo'
18:21:20 <nolrai_East> thanks!
18:22:10 <nolrai_East> mauke++
18:24:28 <kpreid> that isn't H98, is it?
18:24:38 * Twey gives a chuckle at the GitS reference and also the Most Noble One.
18:25:20 * kpreid finds http://www.haskell.org/ghc/docs/latest/html/users_guide/deriving.html#stand-alone-deriving
18:25:21 <lambdabot> Title: 8.5. Extensions to the "deriving" mechanism, http://tinyurl.com/2ts9ot
18:25:29 <Shiruka> GitS - a distributed version control system in a unix shell
18:26:22 <Shiruka> (hm, s/a/the/ for better correspondence)
18:29:51 <Twey> Just to make sure this means what I think it means: what's the difference between `data` and `newtype`?
18:30:10 <kpreid> Twey: newtype hasn't got a _|_, and is implemented efficiently
18:30:22 <monochrom> Several perspectives.
18:30:25 <mauke> newtypes only exist in the mind of the compiler
18:30:31 <Twey> kpreid: But there are limitations on how it can be used, right?
18:30:38 <Saizan> s/compiler/typechecker/
18:30:48 <monochrom> Usability perspective: newtype wants exactly one data constructor, no more no less.
18:31:04 <Saizan> one data constructor with only one field
18:31:04 <kpreid> Twey: yes: newtype must have one data constructor, with exactly one field
18:31:05 <monochrom> Denotational perspective: what kpreid says.
18:31:20 <monochrom> Implementation perspective: for most compilers, what mauke says.
18:31:25 * Twey nods.
18:31:36 <Twey> Thanks :-)
18:31:45 <kpreid> Twey: newtype lets you make distinct types which are implemented in the same way as existing types
18:31:58 <kpreid> newtype English = Eng String
18:32:20 <monochrom> abstract typedef :)
18:32:38 <kpreid> twey: besides Extra Type Safety!!!, another use of newtype is that the new type can have different instances
18:32:44 <kpreid> @src Dual
18:32:44 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
18:32:52 <kpreid> @src Dual mappend
18:32:53 <lambdabot> Source not found. I feel much better now.
18:33:10 <kpreid> @src mappend Dual
18:33:10 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
18:33:43 <nolrai_East> @src ZipList >>=
18:33:43 <lambdabot> Source not found. That's something I cannot allow to happen.
18:33:50 <nolrai_East> @src ZipList (>>=)
18:33:50 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
18:33:54 * Twey chuckles.
18:34:16 <nolrai_East> :t Dual
18:34:17 <lambdabot> forall a. a -> Dual a
18:34:26 <Twey> nolrai_East: Oh you're Chris
18:34:36 <Twey> I was all excited
18:34:47 <nolrai_East> Yes?
18:34:50 <Twey> 'Oh yay, a new lojbo Haskeller!'
18:35:07 <nolrai_East> ah
18:35:29 <nolrai_East> well I know like 4 lojban content words.
18:36:54 <monochrom> I wish this is added to lambdabot's list of error messages: "Your mind just hasn't been the same since learning Haskell, has it?"
18:37:12 <Twey> Heheh
18:37:19 <Twey> 'It *broke* me T_T'
18:38:15 <Nafai> So, a friend and I were talking about Hungarian Notatin, and I'm reading Joel Spolsky's rationale for using it: http://www.joelonsoftware.com/articles/Wrong.html
18:38:15 <lambdabot> Title: Making Wrong Code Look Wrong - Joel on Software
18:38:34 <Nafai> It seems to me that he's using varible naming conventions for something that the compiler should handle, no?
18:38:43 <mauke> yes
18:38:47 <Shiruka> hungarian notation.. yuck
18:38:51 <mauke> HN constructs a type system in the mind of the programmer
18:39:29 <Nafai> mauke: That's the impression I was getting
18:39:38 <Nafai> Especially with his example of safe and unsafe strings
18:39:42 <Shiruka> HN drowns the signal in noise so that programmers have more work to do fixing all the bugs
18:39:56 <Shiruka> which is good, programmers get more money that way
18:40:22 <Twey> Hmn
18:40:27 <Nafai> Shiruka: Heh :)
18:40:29 <nolrai_East> hey in C hungarian notation is useful.
18:40:44 <mauke> nolrai_East: :-|
18:41:04 <Twey> Is there some way I can wrap data constructors?  E.G. if I have a datatype that contains a port number, it can take an integral and automatically convert it to a Network.PortNumber when storing?
18:41:22 <mauke> are you referring to smart constructors?
18:41:22 <Shiruka> although I'm sure when your mind is sufficiently gone, you no longer see the hungarian notation
18:41:40 <mauke> they're just functions
18:41:47 <hexpuem> people still use HN? haha
18:42:08 <Twey> mauke: Maybe
18:42:11 <Shiruka> hexpuem: my first reaction exactly :-)
18:42:57 <Twey> I have a data Server { host :: String, port :: PortNumber }
18:43:24 <dobblego> @remember mauke Hungarian Notation constructs a type system in the mind of the programmer
18:43:24 <lambdabot> I will remember.
18:43:34 <Twey> And it would be quite convenient to be able to go Server "foo.com" 80 rather than Server "foo.com" (PortNumber (fromIntegral 80))
18:43:52 <chessguy> type PortNumber = Int
18:43:56 <mauke> fromIntegral 80 is redundant
18:44:03 <Twey> Oh really
18:44:04 <Shiruka> the polish must be more sensible people than the hungarians
18:44:10 <mauke> @index PortNumber
18:44:11 <lambdabot> Network, Network.Socket, Network.BSD, Network
18:44:15 <chessguy> Twey:  i think that should work
18:44:32 <Twey> chessguy: Oh really?
18:44:38 <mauke> newtype PortNumber = PortNum Word16
18:44:41 <chessguy> oh, it's someone else's type?
18:44:44 <Twey> Aye
18:44:46 <Shiruka> because even backwards (=reverse ;-) polish notation is much better than hungarian notation!
18:44:47 <chessguy> hm
18:44:49 <Twey> PortNumber is defined in Network
18:44:53 <mauke> but it's a Num
18:45:07 <mauke> Twey: Server "foo.com" 80 does work
18:45:13 <nolrai_East> if its an instance of Num that will just work.
18:45:14 <Twey> Huh, OK
18:45:35 <Twey> I was looking at the 'Roll Your Own IRC Bot' code, and it uses PortNumber . fromIntegral
18:45:57 <nolrai_East> wierd
18:46:35 <nolrai_East> maybe what it's changing is specified to be an Int?
18:47:29 <mauke> haha, hax
18:47:34 <mauke> *> case 80 of PortNum n -> n
18:47:34 <mauke> 20480
18:49:13 <nolrai_East> ow
18:49:39 <nolrai_East> mauke: what is that from?
18:49:54 <mauke> huh? my ghci session
18:50:49 <Twey> mauke: O.O
18:50:58 <Twey> Why does that happen?
18:51:22 <mauke> because it has an "interesting" Num instance
18:51:41 <Twey> 'Interesting'?  (*winces anticipatorily*)
18:51:46 <mauke> it behaves sanely as long as you never use PortNum
18:52:09 <nolrai_East> pattern match on it you mean?
18:52:24 <mauke> pattern match and use it to construct a PortNumber
18:53:23 <nolrai_East> so does the fromIntegral add 20400 or what?
18:53:39 <mauke> no, converts to network byte order
18:53:47 <Twey> So I should do something like: `newServer host port = Server host (PortNumber . fromIntegral $ port)` ?
18:54:14 <mauke> Twey: wait, what's this PortNumber?
18:54:30 <Twey> mauke: Erm, it's in Network...
18:54:45 <mauke> ah, part of PortID
18:55:04 <mauke> and what's the type of port?
18:55:09 <Twey> Ah, yes indeed
18:55:28 <Twey> Oh
18:55:34 <Twey> I guess it should be PortID on Server, huh
18:56:36 <Twey> Oh wait
19:01:46 <dons> hmm, the tupil guys and dcoutts seem to be showing happs as rather viable. very exciting.
19:05:54 <solrize> going by alexj's talk, happs really seems to attack every webserver problem head-on and not cut corners.  maybe poorly documented and confusing to use for now, but hopefully that will improve
19:06:29 <johnnowak> ?pl (\x -> x x) (\x -> x x)
19:06:33 <lambdabot> ap id id (ap id id)
19:06:33 <lambdabot> optimization suspended, use @pl-resume to continue.
19:07:17 <solrize> @pl-resume
19:07:23 <lambdabot> ap id id (ap id id)
19:07:24 <lambdabot> optimization suspended, use @pl-resume to continue.
19:08:10 <bd_> solrize: which talk?
19:08:26 <johnnowak> ?pl (\f x -> f (f x)) (\x -> x x)
19:08:27 <lambdabot> join id . join id
19:08:48 <solrize> bd_ http://www.bayfp.org/blog/2007/10/16/alex-jacobson-on-happs-videos-slides/
19:08:52 <lambdabot> Title: Bay Area Functional Programmers :: Alex Jacobson on HAppS: Videos & Slides, http://tinyurl.com/253uhw
19:09:08 <johnnowak> :t (\f x -> f (f x)) (\x -> x x)
19:10:04 <bd_> solrize: thanks
19:10:22 <chrisdone> href = sub "td" >=> sub "a" >=> findAttr (name "href")
19:10:29 <chrisdone> ah, delicious Maybe monad
19:10:31 <mauke> :t (\f x -> f (f x)) (\x -> x x)
19:10:41 <dobblego> @type (>=>)
19:10:49 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
19:11:00 <johnnowak> @type join id . join id
19:11:07 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
19:11:15 <johnnowak> fine!
19:11:32 <mauke> @bot
19:11:39 <lambdabot> :)
19:11:45 <mauke> :t () ()
19:12:25 <mar77a> @bot
19:12:29 <lambdabot> :)
19:12:31 <mauke> @type () ()
19:12:39 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
19:12:50 <mauke> someone broke the type checker
19:13:26 <johnnowak> oops
19:13:47 <chrisdone> what's that nice mini language for XML for searching? like /element/directsubelement//subelementanylevelsdeep/* or whatnot
19:14:17 <bd_> sounds a bit like XPath
19:14:34 <chrisdone> that's the one
19:14:52 * chrisdone checks hackage
19:15:10 <monochrom> HXT can do XPath. Others probably too.
19:15:31 <araujo> http://web.archive.org/web/20041012103936/http%3a//www.bagley.org/~doug/ocaml/Notes/okoans.shtml
19:15:33 <lambdabot> Title: Functional Programming Koans, in OCaml, http://tinyurl.com/5aeag3
19:15:37 <araujo> hah
19:15:43 <chrisdone> monochrom: I don't see that on Hackage, is it on under another name?
19:16:21 <monochrom> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hxt
19:16:22 <lambdabot> Title: HackageDB: hxt-8.1.0
19:17:07 <chrisdone> monochrom: thanks :)
19:17:51 <mauke> Michel Mauny was giving a guest lecture to new computer science students. After the students were seated, Michel pronounced "Today's lecture will be about Lazy Evaluation", he paused for a moment then concluded with, "Are there any questions?"
19:17:55 <mauke> <3
19:18:20 <catface> ;)
19:21:39 <Elly> mauke: that's awesome :)
19:21:45 <chowmeined> is there a numeric sum function in the library somewhere?
19:21:54 <mar77a> > sum [1..10]
19:21:56 <lambdabot>  55
19:22:00 <mauke> @index sum
19:22:00 <lambdabot> Data.List, Prelude
19:22:09 <chowmeined> no, that one is inefficient.. it works with lists
19:22:16 <mauke> wat
19:22:20 <Elly> er...what do you want the sum of?
19:22:22 <chowmeined> i wrote my own.. but i dont want to reinvent the wheel
19:22:23 <chowmeined> summation first last = ((last - first) + 1) * (last + first) `div` 2
19:22:30 <chowmeined> if theres one already in the library
19:22:32 <Elly> oh, you mean summation
19:22:43 <mar77a> summation != sum :p
19:22:50 <Elly> I don't think there is such a thing in the standard library
19:22:53 <chowmeined> sorry.. my math is poor
19:23:08 <chowmeined> ok, thanks.. i just didnt want to not reuse code if there was one
19:23:13 <mauke> fizzle n = n * (n + 1) `div` 2
19:23:37 <Twey> I think we'd generally go summation f l = sum [f .. l] -- and let the compiler optimise out the list.
19:23:50 <chowmeined> except it doesnt
19:23:51 <mauke> @type let fizzle n = n * (n + 1) `div` 2 in (-) `on` fizzle
19:23:52 <lambdabot> forall a. (Integral a) => a -> a -> a
19:24:17 <Twey> You might try Yhc's Supero, I hear it's good at cases like this
19:25:31 <chowmeined> sum [f..l] is O(n) whereas the other one is O(1)
19:25:35 <Saizan> that might work only on rewrite rules
19:25:40 <chrisdone> "you might try ...", odd language to me
19:25:54 <dolio> supero isn't going to turn a summation loop into a closed-form formula. :)
19:26:06 <chowmeined> trying that on 1,000,000,000 eats up all my swap file
19:26:10 <dolio> Although that would be awesome. :)
19:26:23 <atp> you can probably do it with a rewrite rule though
19:26:32 <chowmeined> inductive reasoning in a compiler?
19:26:44 <Saizan> chowmeined: compiling with optimizations that should run in constant space
19:27:13 <Saizan> still O(n) time, of course
19:28:09 <chowmeined> interesting
19:28:21 <chowmeined> optimization makes it 10 times faster
19:28:46 <dolio> GHC doesn't do much fancy stuff on -O0.
19:30:00 <bwr> dolio: so what should be used? there shouldn't be any harm in using the best optimizations in haskell right?
19:30:16 <Shiruka> eh, closed forms are better left to the programmer :-)
19:30:17 <bwr> besides slow compiles?
19:30:24 <rwbarton> hah, evaluating the argument to error caused another exception:
19:30:24 <dolio> bwr: It makes compiling slower.
19:30:24 <rwbarton> *** Exception: RM*** Exception: Prelude.read: no parse
19:30:30 <dolio> That's about it.
19:31:38 <Shiruka> at least the stream-fusion lib should turn it into a loop without a list
19:31:49 <mauke> rwbarton: try 'fix error'
19:31:54 <rwbarton> mauke: Yeah, I did :)
19:32:00 <dons> chowmeined: -O2 is my default.
19:32:20 <dons> -O0 is for speed of compilation, it tries to do as little as possible.
19:34:21 <gwern> I thought that was -Onot
19:35:20 <dolio> I've never tried specifying it directly, so I wouldn't know.
19:35:37 <Shiruka> no reason why a compiler couldn't know about closed form of some series, but practical benefits are likely to be close to nil.. even interactive proof assistants need help to see such identities in anything but the most trivial cases :-/
19:36:34 <gwern> Shiruka: well, optimization is a subset of AI, in the limit...
19:37:18 <Shiruka> the surprising thing to me there is just how dumb the current systems are
19:39:04 <gwern> I'm not surprised. the field of optimization literature covers an incrdible number of optimizations, and implementators' time is limited
19:39:29 <gwern> I mean, what kernels do the Synthesis runtime optimizations? even if they result in huge gains
19:40:21 <erikc> my experience as a compiler developer was if it didnt make SPEC run faster, it was low priority
19:41:11 <Shiruka> ah, I meant the state of the art in theorem provers :-) completely automatic systems are somewhat impressive due to restricting the problem space, but the interactive ones.. you constantly go "What?! How could this _not_ see something this trivial?" if you aren't used to it..
19:42:16 <gwern> hm. I don't follow. if the completely automatic ones can do it, why not ones which can be completely automatic but also ask the human for help?
19:43:51 <Shiruka> the interactive ones are used for a much broader set of problems
19:44:18 <Shiruka> it's just the absurdly steep drop in performance when you step outside the part automatic tools can handle that's surprising
19:47:29 <gwern> why can't you just throw computing power at it? give it something to prove, and let it run over night on 4 cores or whatever
19:48:19 <O_4> Over night?
19:48:56 <gwern> yes, since usually you'll be asleep then and won't care if your computer is running flat out
19:49:56 <Shiruka> too large branching factor? I haven't tried implementing such a system, just used a few for a while out of curiosity
19:50:53 <erikc> so is HApps-Data's querying support a relational algebra?
19:54:21 <vixey> you can throw computing power at certain kinds of proof
19:54:31 <adu> hey
19:55:07 <adu> if func :: a -> b -> c -> d, then can you do x `(func w)` y?
19:55:16 <vixey> adu: No that's a syntax error
19:55:23 <adu> :(
19:55:32 <dolio> You'll need to finesse your own operators.
19:56:25 <Shiruka> heh, would be funny if you could have arbitrary expressions inside ``
19:56:27 <dolio> > let (-|) x f = f x ; (|-) g y = g y in [1..3] -| zipWith (+) |- [1..3]
19:56:28 <lambdabot>  [2,4,6]
19:56:49 <Shiruka> and have it be `' so that you can nest them like parens!
19:56:54 <rwbarton> I wanted to use unicode curly quotes for -| and |-, but ghc wouldn't let me
19:57:50 <adu> rwbarton: what encoding were you using?
19:58:13 <adu> rwbarton: and what does -| ...
19:58:16 <adu> do?
19:58:54 <shapr> @yow !
19:58:55 <lambdabot> Couldn't find fortune file
19:58:59 <shapr> @quote
19:58:59 <lambdabot> TuringTest says: They got it work in Haskell without understanding Haskell.  It is quite an achievement, of some description.
19:58:59 <rwbarton> UTF-8 I hope... some other symbols were accepted as operators; I don't understand how ghc decides what is and is not valid
19:59:12 <adu> @hoogle -|
19:59:12 <lambdabot> hoogle: unrecognized option `-|'
19:59:12 <lambdabot> HOOGLE - Haskell API Search
19:59:12 <lambdabot> (C) Neil Mitchell 2004-2008, York University, UK
19:59:12 <lambdabot>  
19:59:12 <lambdabot> Usage: hoogle [OPTION...] search
19:59:13 <rwbarton> adu: what dolio did above
19:59:14 <lambdabot> [15 @more lines]
19:59:32 <mauke> @hoogle +RTS -N42
19:59:32 <lambdabot> Hoogle Error: Parse Error: Unexpected character '+RTS -N42'
19:59:48 <shapr> So, can anyone introduce me to this crazy language?
19:59:54 <adu> shapr: ok
20:00:13 <shapr> adu: You can introduce me to Haskell?
20:00:18 <adu> shapr: are you familiar with Lisp?
20:00:32 <shapr> adu: Yeah, I've used it before.
20:00:39 <dcoutts> dons: you've been trying out our hackage-server eh? :-)
20:00:46 <adu> shapr: Haskell is just as powerful as Lisp, only without parentheses
20:00:47 <adu> :))
20:00:50 <shapr> adu: Sounds great!
20:00:55 <dcoutts> dons: we added the recent uploads .html and .rss this evening
20:00:58 <shapr> adu: How long have you been using Haskell?
20:01:01 <Shiruka> shapr-wrf hypothesis: learning haskell allows you to think new thoughts
20:01:05 <adu> shapr: for about 10 years
20:01:16 <shapr> Shiruka: hah!
20:01:34 <shapr> adu: That's impressive!
20:01:43 <dolio> If we could get some Agda syntax, you could write 'x -| f |- y = f x y'
20:01:48 <adu> shapr: I first heard about it in 1999, so more like 9 years
20:01:49 <vixey> shapr!
20:02:00 <shapr> adu: What do you do with Haskell?
20:02:02 <shapr> hiya vixey !
20:02:07 <vixey> #haskell hit 500 users
20:02:14 <Saizan> ?seen hpaste
20:02:15 <lambdabot> I haven't seen hpaste.
20:02:17 <shapr> @users
20:02:17 <lambdabot> Maximum users seen in #haskell: 450, currently: 441 (98.0%), active: 16 (3.6%)
20:02:18 <sm> shapr: you know haskell, surely
20:02:20 <adu> shapr: mostly math research, some sysadmin stuff, and lots and lots of prototyping
20:02:29 <mauke> haha, reset again
20:02:36 <shapr> sm: Well, maybe a little
20:02:40 <mauke> preflex: seen hpaste
20:02:40 <preflex>  hpaste was last seen on #haskell 19 days, 11 hours, 4 minutes and 2 seconds ago, saying:  Mitar pasted "Hot to indent?" at http://hpaste.org/8869
20:02:49 <sm> in fact you got me into it, as I recall :)
20:02:56 <shapr> sm: Ok, yeah..
20:02:58 <sm> your functional tests
20:03:02 <shapr> Really?
20:03:02 <mxc> shapr - learning this crazy fcked up language will be one of the hardest things you can do in the world of programming
20:03:08 <mxc> shapr  - also the most rewarding
20:03:12 <vixey> lol
20:03:20 <shapr> sm: The zope unit test stuff?
20:03:24 <sm> yup
20:03:26 <dolio> mxc: INTERCAL?
20:03:32 <shapr> sm: I didn't know that :-)
20:03:32 <adu> shapr: actually that might be the most interesting use for haskell, since its so easy to write things fast
20:03:37 <sm> ha! trying to go around the learning haskell ride a *second time* !
20:03:39 <mxc> intercal?
20:03:43 <shapr> sm: heh, yes!
20:03:47 <sm> cool :)
20:03:57 <dolio> I think it's crazier than Haskell.
20:03:58 <Nafai> sm: I'm still on my first time!
20:04:02 <shapr> mxc: How long have you been using Haskell?
20:04:08 <sm> me too!
20:04:09 <mxc> dolio - i  did qualify it with 'one of'
20:04:11 <shapr> adu: What prototyping?
20:04:15 <mxc> shapr a few months
20:04:23 <mxc> lots of good tutorials on the web
20:04:30 <mxc> yet another haskell tutorial is great
20:04:32 <mauke> http://koweycode.blogspot.com/2007/01/think-of-monad.html
20:04:32 <lambdabot> Title: koweycode: think of a monad...
20:04:42 <mxc> as is build yourself a scheme in 48 hours
20:04:54 <dolio> mxc: INTERCAL is rewarding too. It teaches you how to write programs with proper levels of politeness. :)
20:05:08 <adu> shapr: like if you have an idea for an editor or a screen saver or a build system or a programming language or a compiler or a web portal, etc
20:05:14 <mxc> shapr, but i have been doing a lot of ocaml coding before haskell.  ocaml is like a middle ground between haskell and conventional languages
20:05:16 <Shiruka> haskell does have a bit of a learning curve.. highest one of the languages I know :-\
20:05:22 <adu> shapr: so you whip something up, like a proof of concept
20:05:25 <Shiruka> maybe not haskell98, but all the extensions..
20:05:25 <glguy> shapr: we should learn Haskell together
20:05:29 <shapr> glguy: yes!
20:05:36 <mauke> @quote unle
20:05:36 <lambdabot> DukeDave says: Haskell has the greatest unlearning curve
20:05:41 <shapr> glguy: Are you learning Haskell also?
20:05:43 <mxc> glguy - last time i was here you knew more than I did (i think)
20:05:46 * vixey wants to learn haskell too
20:05:52 <sm> who's been reading http://book.realworldhaskell.org/beta/ ? does it rock ?
20:05:52 <shapr> vixey: Great!
20:05:53 <lambdabot> Title: Real World Haskell
20:05:58 * mxc also wants vixey to to learn haskell
20:06:03 <shapr> glguy: busted :-)
20:06:16 <mxc> just kidding, vixey has forgotten more than i'll ever know about haskell
20:06:22 <glguy> shapr: I can't pull it off :(
20:06:29 * shapr grins
20:06:38 <mxc> sm - great book, and the authors are often here
20:06:51 <adu> shapr: so you can show your friend/boss/mother: look I can generate genetic algorithms using neural nets and higher order polymorphism!
20:06:55 <adu> or something
20:07:03 <shapr> adu: w00!
20:07:09 <sm> I know the authors rock, so I assume the book does, hopefully
20:07:18 <shapr> adu: How would you build a genetic algorithm system with Haskell?
20:07:24 <shapr> vixey: When did #haskell hit 500?
20:07:31 <adu> shapr: i dunno, try prototyping it
20:07:33 <vixey> shapr, I think this was yesterday
20:07:44 <shapr> cool
20:07:48 <mxc> adu - 10 minutes to show how you implemented a neural net in 4 lines of code with some list comprehensions, 6 months to explain to mom why that matters
20:07:52 <dino-> I'm doing something with WriterT. Out of curiosity I was wondering what listen, pass, listens and censor are for. Having a lot of trouble both finding things on the web about them and getting it from the types.
20:07:58 <thetallguy> shapr: so, you going to take up extreme unicycling?
20:07:58 <shapr> mxc: heh
20:08:03 <adu> mxc: lololol
20:08:23 <vixey> yes
20:08:35 <shapr> thetallguy: Um, I thought I'd start with Agile behaviour driven unicycling. Ya know, every time I fall down, I try not to do that again, and in the future, dodge those trees sort of thing.
20:08:39 <Shiruka> besides, one can't really say they truly know haskell until they have read and understood all of oleg's papers and think they're actually a bit too trivial
20:08:52 * vixey finally convinced her dad non-lossy data compression is possible !
20:08:54 <thetallguy> shapr: :-)
20:09:03 <mauke> a hint to beginners: typing 'fix error' in ghci does not have the intended effect
20:09:03 <adu> who is oleg?
20:09:10 <shapr> @where oleg
20:09:10 <lambdabot> http://okmij.org/ftp/
20:09:19 <shapr> mauke: It sure sounds good though!
20:09:21 <Draconx> mauke, haha
20:09:22 <sm> vixey: :)
20:09:36 <shapr> vixey: How'd you do that? Demonstrate Huffman compression?
20:09:43 <vixey> shapr: RLE
20:10:04 <shapr> oh
20:10:07 <shapr> good point!
20:10:39 <sjanssen> @remember mauke a hint to beginners: typing 'fix error' in ghci does not have the intended  effect
20:10:39 <lambdabot> It is forever etched in my memory.
20:10:47 <dino-> shapr: Hey, I got one of those FreeRunner phones a week ago.
20:10:57 <sjanssen> lambdabot: that is a lie, you'll forget it in less than a week
20:10:59 <sjanssen> @flush
20:11:00 <shapr> dino-: What's it like?
20:11:14 <Shiruka> too bad you need to import Control.Monad.Fix to get the intended behavior of fix error :-)
20:11:17 <dino-> shapr: It's very rough yet, which I was expecting.
20:11:19 <shapr> Hm, where's hpaste?
20:11:29 <vixey> gone :(
20:11:31 <mauke> Shiruka: or Data.Function
20:11:37 <shapr> I hope it's not broken...
20:11:57 <dino-> shapr: Oh, no, just basically need a lot of developers to swarm over it.
20:11:57 <shapr> adu, mxc: Thanks for the motivational introductions :-)
20:12:00 <dino-> needs
20:12:14 <adu> anytime :)
20:12:23 <shapr> dino-: I have a BUG from buglabs showing up soon, I'm looking forward to that.
20:12:51 <dino-> I have to say sadly that I had some unfortunate rude experienced on #openmoko. And I was reminded of just how well people are treated here in this community.
20:12:51 * Shiruka thought fix error would have a bit different behavior than the actual one :-(
20:13:01 <dino-> s/experienced/experiences/
20:13:08 <Shiruka> I thought error would be strict in its argument, silly me :-)
20:13:19 <shapr> ei ole!
20:14:15 <adu> Haskell owes its popularity to nice people
20:14:35 <shapr> adu: Do you think community outweighs other factors?
20:14:42 <adu> will the real Haskell please stand up
20:14:50 <ddarius> Maybe we can run hpaste off of the BUG?
20:14:52 <adu> shapr: no
20:14:58 <Shiruka> community tends to be an important factor
20:15:26 <adu> shapr: but just take Java for example, you can't do anything with it, and yet 80% of people use it
20:15:28 <Shiruka> I think lisp would be hugely popular if its community were half as friendly as haskell's..
20:15:32 <dino-> shapr: With open projects, there's almost nothing but community. I think it's vitally important.
20:16:09 <dino-> I have to split very soon, but can anybody explain briefly to me what listen in MonadWriter does?
20:16:29 <dolio> @hoogle listen
20:16:29 <lambdabot> Control.Monad.Writer.Class.listen :: MonadWriter w m => m a -> m (a, w)
20:16:29 <lambdabot> Control.Monad.Writer.Class.listens :: MonadWriter w m => (w -> b) -> m a -> m (a, b)
20:16:51 <dolio> listen (blah) gives you the result and the stuff written by blah.
20:16:55 <adu> shapr: how long have you been using Haskell?
20:16:58 <dino-> I get using a Writer as a logger of something and what tell does. But all the other functions confuse me!
20:17:08 <shapr> adu: not as long as you!
20:17:12 <dolio> And may or may not write that overall. I can't recall.
20:17:25 <adu> shapr: so have you understood monads yet?
20:17:40 <shapr> adu: Yeah, I think I understand them.
20:17:46 <adu> good
20:17:54 <adu> what about arrows?
20:18:28 <dino-> dolio: The stuff written up to that point?
20:18:34 <shapr> I somewhat understand arrows. I understand the motivation behind Swierstra & Duponcheel's parsers, but I'm not sure I can generalize that understanding to other flavors of arrows.
20:18:36 <dino-> (for listen (singular) say)?
20:18:38 <Shiruka> my understanding of arrows goes like a sine wave..
20:18:58 <adu> shapr: I know only 1 instance of arrows
20:19:00 <dino-> As in, the complete monoid that has been accumulated at that stage?
20:19:02 <Shiruka> cycle "I read about them out of interest, then never use them and forget everything, then "
20:19:02 <sw17ch> using FFI, how does one marshal a (void *) with c2hs?
20:19:06 <dolio> dino-: It wraps a computation, and tells you what gets written within that computation.
20:19:17 <dino-> mmm
20:19:19 <shapr> adu: Is that the parsers that Hughes uses in his original paper(s) ?
20:19:19 <dino-> hmm
20:19:43 <dino-> dolio: Wow, thank you. I think I suddenly got it.
20:19:43 <dolio> So in 'do tell "a" ; (_, w) <- listen (tell "b") ; ...' w = "b".
20:19:51 <adu> shapr: no, I understand monadic parsers, but I never understood those papers, just a bunch of jibberish
20:20:02 <shapr> Which instance of arrows do you understand?
20:20:06 <dino-> so, this 'sub' computation may also be calling tell. And this lets you 'listen' in on it?
20:20:12 <dolio> Right.
20:20:15 <dino-> wow
20:20:21 <dino-> I will need to write code now to experiment.
20:20:24 <dolio> And it adds it to the overall output. I just checked.
20:20:50 <dolio> So the output starting at '...' will be "ab".
20:20:55 <mxc> shapr no problem
20:21:06 <adu> but then again I can't tell the difference between ad-hoc and parametric polymorphism, but I can't tell the difference between Haskell and C++ and thats what matters...
20:21:32 <dino-> dolio: Thank you very much.
20:21:39 <dolio> No problem.
20:21:43 <adu> shapr: Arrow (->)
20:22:05 <adu> shapr: I don't even understand the Kleisli  arrow even tho I understand monads
20:22:13 <dolio> pass is the really weird one.
20:22:24 <shapr> adu: Aren't they the same thing?
20:22:29 <dino-> I'll have to think about it more, I'm surprised that there are cases where you think "I'd like to listen" like that.
20:22:40 <shapr> vixey: I don't know what's wrong with hpaste.
20:22:54 <adu> shapr: all Monads are Kleisli Arrows, yes, but I don't remember if the reverse is true...
20:22:57 <shapr> vixey: It starts up, but the bot doesn't join, and I don't know why.
20:23:07 <vixey> humm...
20:23:30 <shapr> adu: There are arrows that are not kleisli arrows.
20:23:59 <shapr> I think Ross Paterson had some examples in some of the references on http://www.haskell.org/arrows/
20:24:00 <lambdabot> Title: Arrows: A General Interface to Computation
20:24:15 <dino-> dolio: Thanks again. That really helped quite a bit.
20:24:24 <adu> ya, I understand "ordinary functions"
20:25:03 <adu> I would have to use them more
20:25:14 <Shiruka> what do arrows correspond to in category theory? just morphisms?
20:25:14 <chowmeined> im trying to profile this code but i get: Stack space overflow: current size 8388608 bytes. Use `+RTS -Ksize' to increase it.
20:25:16 <dino-> I'll have to talk about pass and censor some other time.
20:25:22 <adu> shapr: so how did you learn about Arrows so fast?
20:25:25 <shapr> Shiruka: Freyd categories?
20:25:28 <shapr> adu: I cheated :-)
20:25:43 <adu> shapr: by reading? thats not cheating
20:25:57 <shapr> adu: I've been doing Haskell for awhile actually.
20:26:12 <dolio> I think I heard that Arrows don't correspond exactly to Freyd categories.
20:26:13 <adu> shapr: longer than 10 years?
20:26:20 <dolio> But I'm not up on the latter, and how exactly they're different.
20:26:22 <shapr> I'm not really the newbie I claimedto be when I just joined #haskell!
20:26:30 * Shiruka doesn't know almost anything about category theory, but a few terms would be useful to scare annoying people away in parties
20:26:43 <adu> shapr: then maybe you should introduce me to Haskell :)
20:26:45 <shapr> adu: Nah, not as long as you. More like just over seven years.
20:27:16 <sw17ch> haskell is like learning to program again
20:27:21 <dolio> We need to get @yow fixed so shapr will hang out here more and people won't mistake him for a n00b.
20:27:25 * shapr laughs
20:27:26 <adu> sw17ch: indeed
20:27:33 <glguy> @yow broke??
20:27:33 <lambdabot> Couldn't find fortune file
20:27:40 <glguy> <:-o
20:27:45 * shapr laughs more
20:27:59 <sw17ch> are my c2hs experts around tonight? :D
20:28:01 <shapr> adu: I don't know if I could answer any questions you might have, but I'll definitely try if you have some questions!
20:28:10 <glguy> @yarr
20:28:10 <lambdabot> Is that a hornpipe in yer pocket, or arr ya just happy ta see me?
20:28:28 <shapr> glguy: What's the story with hpaste? Is there a new version in the works?
20:28:47 <shapr> glguy: Is there a handy way to file out all the existing pastes in the old version into a static archive?
20:29:05 <glguy> shapr: not really. They are all neatly hidden away in the HAppS application state
20:29:11 <shapr> Because it seems that the hpaste announce bot on scannedinavian is broken
20:29:22 <glguy> and to export them I'd need to be able to compile the code and add an export handler
20:29:27 <Shiruka> what's an inavian :-O
20:29:38 <glguy> a not-bird
20:29:43 <Shiruka> haha
20:29:48 <shapr> Shiruka: avian is the genus of birds
20:30:04 <shapr> A scanned in avian would be a penguin strapped to a scanner!
20:30:05 <Shiruka> ah, scanned-in avian
20:30:41 <shapr> I thought it was a cute name när jag bodde i Sverige
20:30:49 <Shiruka> and as a penguin, it would be a scandinavian scanned-in avian
20:30:58 <shapr> Exactly!
20:31:19 <shapr> adu: What kind of math research do you do with Haskell?
20:31:36 <shapr> adu: btw, do you ever hang out with other Haskell users in the northeast?
20:31:44 <adu> well, tetration mostly
20:31:48 <shapr> oh
20:31:58 <sw17ch> good gosh, the answer is always that easy...
20:32:00 * sw17ch grumbles...
20:32:14 <adu> shapr: hmm, I went to FrinigeDC once
20:32:20 <sw17ch> see, that's the worst thing about haskell to me.. the problems i find the most difficult are the easiest to finally fix
20:32:45 <sw17ch> so, i guess it's not that bad
20:32:52 <shapr> glguy: So, save them all with a web browser instead?
20:32:59 <Shiruka> haskell: the difficult things should be easy and the easy things impossible?
20:33:13 <adu> Shiruka: lol
20:33:13 <sw17ch> Shiruka, not far off :)
20:33:21 <shapr> glguy: will the new version export to a text file?
20:33:31 <glguy> shapr: the new one uses sqlite3
20:33:35 <shapr> oh, nifty
20:33:44 <shapr> Is that one ready to replace the existing hpaste?
20:34:02 <glguy> apparently someone in this  channel has been using it for a while for personal use
20:34:03 <shapr> adu: I'm in Boston, just curious.
20:34:16 <shapr> Sounds like it's ready... where do I get it?
20:34:18 <glguy> shapr: There isn't a good place to run the new version
20:34:24 <adu> AI piece of cake, variables... um no we don't have those
20:34:27 <shapr> Why not on scannedinavian?
20:34:33 <glguy> I thought the point was to get it off?
20:34:45 * shapr shrugs
20:35:13 <glguy> my "server" is subject to power-outages and college parties
20:35:25 <Saizan> shapr: the serialization of hpaste state doesn't depend on happs at all, so we can just read the last checkpoint from the outside
20:35:25 <glguy> reliable isn't the right word for it
20:35:26 <glguy> :)
20:35:37 <shapr> Saizan: That's cool.
20:35:50 <adu> that seems to post-apocolyptic... Haskell with variables
20:35:58 <Saizan> (the old one i mean)
20:36:16 <shapr> checkpoints are nearly 6mb nowadays.
20:37:12 <shapr> glguy: I wonder if community.h.o would run hpaste?
20:37:13 <glguy> Saizan: I thought I encountered some HAppS dependency at some point when I  tried loading the checkpoint file
20:37:24 <glguy> shapr: its running Debian-old
20:37:26 <shapr> oh
20:37:43 <shapr> better to upgrade scannedinavian then.
20:38:07 <glguy> I tried building it a while back on there
20:38:24 <glguy> and ran out of steam trying to install everything in my home directory by hand
20:38:25 <shapr> Needs upgrading?
20:38:29 <shapr> sorry about that :-(
20:38:49 <glguy> I spent an evening basically installing a distro in my home  directory
20:38:54 <glguy> and I hit some snag I don't rmember
20:38:55 <shapr> yargh, suck!
20:39:21 <shapr> I'll try to find time to upgrade scannedinavian completely this weekend
20:39:23 <glguy> but if you are going to plan on  running on something that outdated, you need to develop targeting it from the start
20:39:51 <glguy> I was doing the dev on Fedora 8, so none of the versions major numbers matched up
20:40:14 <shapr> Why is community.h.o running haskell/old ?
20:40:17 <shapr> er, debian/old?
20:40:20 * shapr is very short of sleep
20:40:34 <glguy> I don't know
20:41:11 <shapr> oh well
20:41:55 <shapr> I gotta make up some missing sleep now... I'll return at some point, hopefully this weekend.
20:42:04 <sw17ch> is any one in here working on hayoo
20:42:05 <sw17ch> ?
20:42:07 <glguy> We'll be here waiting for ya ;)
20:42:18 <shapr> heh
20:42:27 <Shiruka> "debian/old".. I think "debian/new" would be an oxymoron
20:43:02 <adu> shapr: it was nice to see you again
20:43:10 <shapr> adu: nice to see you too :-)
20:43:25 <glguy> Shiruka: I think internally they refer to it as "stable"
20:51:25 <sw17ch> @index with
20:51:25 <lambdabot> Foreign.Marshal.Utils, Foreign.Marshal, Foreign
20:51:35 <vixey> @index without
20:51:36 <lambdabot> bzzt
20:51:37 <sw17ch> @type Foreign.with
20:51:40 <lambdabot> forall a b. (Foreign.Storable.Storable a) => a -> (GHC.Ptr.Ptr a -> IO b) -> IO b
20:52:20 <Shiruka> reading old ghc papers is interesting, but unfortunately you keep wondering how much of it is true anymore :-)
20:52:53 * Shiruka is reading "A transformation-based optimiser for Haskell", of vintage 1997
20:53:18 <ddarius> The vast majority of that should still be true modulo minor details.
20:54:13 <Shiruka> I seem to recall someone saying that the strictness analyzer is smarter these days
20:55:08 <Shiruka> what the paper describes is nicely simple :->
20:55:30 <Saizan> glguy: if you comment out the happs bits from PasteState and Pastes it works
20:56:13 <ddarius> Shiruka: It's best to assume the strictness analyzer is very simple-minded.
20:56:32 <Shiruka> oh, I do assume that
20:56:55 <Shiruka> mainly because ghci's strictness analyzer really is.. (does it even have one?)
20:58:02 <ddarius> ghci doesn't run the strictness analyzer.
20:59:52 <ddarius> I tend to write my code so that strictness analysis is not necessary to prevent stack overflows and such.
21:00:27 <Shiruka> yeah, it's not nice to have your code fail when it's interpreted
21:00:39 <hml> where can i get a list of xmonad key bindings suppoorted in X, in particuar, ,things of the form xK_* ?
21:03:21 <sw17ch> @index withCString
21:03:22 <lambdabot> Foreign.C.String, Foreign.C
21:03:24 <adu> :t (??)
21:03:36 <adu> @type (?)
21:03:39 <lambdabot> thread killed
21:03:51 <lambdabot> thread killed
21:04:04 <adu> @type (<|>)
21:04:06 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f a -> f a
21:05:26 <dons> Shiruka: use -fstrictness if you want ghci to use the strictness  analyser
21:05:36 <dons> all the usual optimisations are available, just not by default.
21:05:49 <dons> hml: from the X11 haddocks.
21:05:52 <dons> there's a link on xmonad.org
21:06:09 <sw17ch> @index withIntConv
21:06:09 <lambdabot> bzzt
21:06:17 <Shiruka> ic.. but I think I'll not depend on it anyway :-)
21:06:56 <dons> you can just be explicit about the strictness, with bang patterns.
21:07:07 <dons> useful sometimes. like explicit types
21:07:12 <Shiruka> correct strictness behavior (wrt stack overflows and such, not constant-factor performance) is something I like to have explicit in the code
21:07:22 <dons> yep.
21:07:25 <Shiruka> almost every haskell file I write uses bang patterns :-P
21:07:38 <dons> well, that's probably overkill.
21:07:49 * vixey has never used bang patterns
21:07:58 <dons> but if you're really not demanding the value in a loop, and its an atomic type, you might want to bang it.
21:08:13 <dons> f x n | n == 0 = ... f .. (n+1) -- no need to
21:08:27 <Shiruka> I would get rid of most of them simply by using foldl'
21:08:51 <Shiruka> but I don't want intermediate lists..
21:10:25 * sw17ch hasn't used bang patterns either
21:11:00 * Shiruka tends to use haskell for crunching numbers
21:14:40 <Shiruka> dons: that (or similar) might actually apply in many cases..
21:22:15 <painy> are system ticks an accurate way of timing your computations
21:41:30 <humasect> adu: is it that you say, arrows are fancier than monad ? what does it mean?
21:42:01 <adu> humasect: what that means is that there is a special arrow that can represent all monads
21:42:13 <humasect> oh =) that sounds interesting
21:43:22 <adu> http://www.haskell.org/haskellwiki/Arrow_tutorial#Kleisli_Arrows
21:43:23 <lambdabot> Title: Arrow tutorial - HaskellWiki
21:43:53 <adu> humasect: that means all Monads are Arrows, but there are Arrows that are not Monads
21:44:03 <humasect> mhm =) interesting ..
21:44:57 <adu> humasect: although I don't pretend to understand Arrows at all (I've never used them), I find that the function signature that everyone talks about is (a b -> a c)
21:45:13 <adu> humasect: just like everyone talks about (a -> m b) with Monads
21:45:15 <humasect> hm, yes i see
21:45:49 <dolio> a b -> a c?
21:46:31 <adu> or maybe its (a b c -> a c d -> a b d)
21:46:45 <vixey> :t (>>>)
21:46:47 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
21:46:48 <dolio> That seems more likely.
21:46:54 <adu> see what I mean? I don't understand
21:46:57 <vixey> I like writing it as
21:47:11 <vixey> (Arrow (~>)) => (b ~> c) -> (c ~> d) -> (b ~> c)
21:47:15 <vixey> makes more sense like that
21:48:07 <vixey> although I got it wrong
21:49:21 <humasect> hmm
21:50:00 <adu> humasect: so really, the function signature that everyone seems to be talking about is (a b c)
21:50:04 <vixey> > ((+1) >>> (*2)) 7
21:50:09 <humasect> =)
21:50:10 <lambdabot>  16
21:50:14 <vixey> > ((+1) . (*2)) 7
21:50:15 <lambdabot>  15
21:51:51 <Trinithis> I just found about the esoteric SMITH language. Has anyone here coded in it?
21:54:37 <adu> Trinithis: nope, is it related to funge?
21:55:09 <Trinithis> It's a turing complete language where you can only move forward in it. No loops. You copy code foreward
21:55:30 <Shiruka> wacky
21:55:39 <adu> intercal is the way to go
21:55:47 <Trinithis> adu: I'm almost done writing my Haskell n-funge interpreter!
21:56:03 <adu> Trinithis: is that different from funge98?
21:56:18 <Shiruka> the intercal standard is too old, it needs revision
21:56:21 <Trinithis> I meant Funge98 for an arbitrary dimension
21:56:35 <adu> Trinithis: yes, thats really the only way to do it
21:56:39 <Shiruka> maybe it should take a page from newer languages, like fortran has done with OO and stuff
21:56:51 <adu> I think arbitrary dimension is actually required by the funge98 standard
21:57:00 <Trinithis> Ah
21:57:10 <Shiruka> so intercal could take stuff from, say, lolcode and the new version would be called intercat
21:57:17 <adu> I'm quite fond of funge98
21:57:32 <adu> its the most beautiful ugly language
21:57:35 <Trinithis> lol
21:57:43 <Trinithis> have you written an implementation for it before?
21:57:48 <adu> yes, in perl
21:57:56 <sw17ch> dcoutts++
21:58:22 <adu> I should have a go at writing one in Haskell, too...
21:58:26 <adu> sounds fun
21:58:35 <_zenon_> Good morning
21:58:37 <Trinithis> adu: Do you know how Unefunge deals with inputting a multiline file into it?
21:58:49 <adu> nope
21:58:59 <Trinithis> when I'm done, I can show you my code
21:59:04 <adu> ok
22:01:52 <adu> Trinithis: but I've been planning writing another language
22:02:06 <adu> I've just been filling in the pieces, slowly but surely
22:02:06 <Trinithis> your own design?
22:02:08 <adu> yes
22:02:19 <Trinithis> What's it like?
22:02:24 <adu> uniform
22:02:48 <adu> and I would imagine dynamic
22:03:04 <adu> I can't think of a good way to make it compiled yet
22:03:08 <Trinithis> What paradigm?
22:03:27 <adu> I'd have to say the Io paradigm
22:04:29 <adu> The first thing I want to see if I can do is write a type-checker for a language with first-class types
22:04:32 <telexicon> if i have an infinite list, how can i filter it to get all the values say.. under 1000 ?
22:04:48 <Trinithis> A while ago, I was considering making a prototype OO language that used first-class coroutines and was dynamically typed
22:04:51 <telexicon> oh.. takeWhile?
22:04:59 <adu> Trinithis: well, i guess the FP paradigm
22:05:12 <adu> with heterogeneous lists
22:05:17 <Trinithis> statically typed*
22:05:19 <rwbarton> telexicon: if it's increasing, then yeah, takeWhile is the way to go
22:05:20 <telexicon> yeah.. takeWhile.. how clever
22:05:32 <telexicon> rwbarton, yeah it is.. excellent :D
22:06:46 <adu> Trinithis: well, I don't know, I think both variables and values should be typed
22:07:22 <Trinithis> I corrected myself to statically typed. Twaz a fruedian slip
22:08:48 <vixey> adu: lots of fun to be had with first class types
22:08:49 <adu> Trinithis: but I've really been letting the implications work themselves out, like if making heterogeneous lists work requires [Duck] to work properly, then that may require more dynamic typing
22:09:08 <vixey> you can do typed hetro lists
22:09:20 <adu> I know i've been reading that HList paper
22:09:24 <Trinithis> for my language* (unless I misunderstand)
22:09:28 <vixey> well I didn't mean that
22:09:40 <vixey> tuple : Type -> *, tuple [] = (), tuple (t:ts) = (t, tuple ts)
22:09:53 <vixey> (5, ("foo", ())) : tuple [int, string]
22:10:00 <vixey> that's what I was meaning
22:10:28 <vixey> oops [Type]
22:10:53 <adu> well I was thinking more along the lines of forEach :: (foldr1 (->) [xs;]) -> [xs;]
22:11:07 <adu> where [xs;] is a heterogeneous list of the types of the arguments of the function
22:11:25 <Trinithis> Duck typing requires something like type classes
22:11:46 <Trinithis> not requires, but you know what I mean
22:12:00 <dolio> Duck typing is structural typing, really.
22:12:01 <adu> oops i meant forEach :: (foldr1 (->) xs) -> [xs;]
22:12:30 <adu> that would implement map, zipWith, zipWith3, zipWith4 all at the same time
22:12:47 <Trinithis> adu: are you familiar with javascript?
22:12:56 <adu> Trinithis: nope
22:13:03 <adu> well kinda
22:13:04 <vixey> adu: huh , I don't get it
22:13:09 <solrize> http://math.ucr.edu/home/baez/rosetta.pdf   <--- this looks neat
22:13:10 <lambdabot> Title: Physics, Topology, Logic and Computation: A Rosetta Stone
22:13:25 <adu> vixey: well lets start with func :: a -> b -> c -> d
22:13:30 <Trinithis> JS is prototype OO and duck typed. Might be worth taking a look at
22:13:35 <dolio> If you have extensible records and variants, you have static duck typing, more or less.
22:13:57 <adu> and lets say [a; b; c; d] is a heterogeneous list in my Haskell-ish language
22:14:23 <vixey> zip : /\n : int, ((a ->)^n -> b) -> [a]^n -> [b]
22:14:29 <adu> then foldr1 (->) [a; b; c; d] would output the type (a -> b -> c -> d)
22:14:50 <Trinithis> is -> the type sig fr lists?
22:14:53 <dancor> is there something standard to get a random list element
22:14:58 <vixey> why are you writing ; instead of , ?
22:15:23 <Trinithis> to be creative/different ?? ?
22:15:28 <adu> Trinithis: no [x;] is the type signature. where  x :: [Type]
22:15:53 <adu> for example [3; "string"; True] :: [Int, String, Bool]
22:16:19 <adu> and [Int, String, Bool] :: [Type]
22:17:15 <adu> but if you don't care about the types, I was thinking [3; "string"; True] :: [a;] would be short-hand
22:17:35 <vixey> doesn't seem like there could be any foundation for it
22:18:01 <Trinithis> Perhaps have structural types?
22:18:02 <adu> foundation?
22:18:19 <adu> structural?
22:18:35 <Trinithis> like a type signifying that the object at hand has certain methods
22:18:54 <Trinithis> for static duck typing
22:19:00 <Trinithis> :: [toString]
22:19:18 <hackage> Uploaded to hackage: dephd 0.1.1
22:19:18 <hackage> Uploaded to hackage: clustertools 0.1.1
22:19:18 <hackage> Uploaded to hackage: bio 0.3.3.4
22:19:59 <Trinithis> forEach print xs, where xs :: [print]
22:20:06 <Saizan> btw, is there an idiom for witnessing equivalences between types in Agda?
22:20:48 <ketil> @seen dons
22:20:49 <lambdabot> dons is in #arch-haskell, #xmonad, #ghc and #haskell. I last heard dons speak 26m 37s ago.
22:21:14 <vixey> Saizan: are you using JMeq or something? (why do you want equality between types?)
22:21:20 <adu> vixey: I use (,) for homogeneous lists and (;) for heterogeneous lists
22:21:24 <Saizan> that if i have foo : A -> B, i'd like to lift it to foo' : A ~ A' -> A' -> B, without constructing A ~ A' explictily
22:21:44 <vixey> oh I don't even know what ~ is
22:21:44 <adu> vixey: and thats the syntax I intend on writing a parser for next weekend
22:21:53 <vixey> adu, oh cool
22:22:03 <Saizan> vixey: ~ is supposed to be a uder-defined equivalence
22:22:07 <Saizan> *user
22:22:33 <pjdelport> adu: how would heterogeneous lists differ from tuples?
22:22:47 <adu> pjdelport: they're linked
22:22:50 <vixey> Saizan: how is it defined?
22:23:14 <pjdelport> adu: linked?
22:23:40 <dolio> Saizan: I don't remember the standard library having a type equality.
22:23:47 <adu> pjdelport: i.e. (.) :: a -> [a] -> [a] is Haskell's (:) and my (:) :: a -> [b;] -> [c;]
22:24:12 <dolio> But otherwise that's something like: resp-~ (\T -> T -> B)
22:24:19 <chrisdone> is http://holumbus.fh-wedel.de/hayoo/ down for anyone else?
22:24:20 <lambdabot> Title: Hayoo!
22:24:29 <chrisdone> it seems really really slow
22:24:34 <ddarius> Apparently it's not down for lambdabot
22:24:59 <pjdelport> adu: as in (a, (b, (c, ())) ?
22:25:13 <adu> (.) constructs [a,b] lists and (:) constructs [a;b] lists
22:25:24 <adu> pjdelport: kinda, only with []
22:26:08 <adu> [a; b; c] is my syntax for (a, (b, (c, ())))
22:26:10 <humasect> what is hayoo? google fails
22:26:13 <dolio> Where resp-~ : {S : Set1} {T T' : S} {T ~ T'} (f : S -> Set) -> f T -> f T'
22:26:14 <pjdelport> adu: well, that's what i'm getting at;  tuples can be represented both flat and linked
22:26:19 <dolio> Or something like that.
22:26:45 <humasect> chrisdone: ah, interesting, thanks . this works for me
22:26:48 <pjdelport> ah, so [a; b; c] is just syntax?
22:26:51 <adu> actually (a, (b, (c, []))) to be more presice
22:26:52 <vixey> much more fun is proving types aren't equal :p
22:27:01 <vixey> i.e. prove bool <> nat
22:27:15 <vixey> that's a good puzzle
22:27:22 <adu> pjdelport: yes, but my plans are to investigate using it with first-class types
22:27:24 <vixey> at least it was for me :/
22:27:47 <dolio> Can you even do that in Agda? It doesn't let you typecase.
22:27:51 <chrisdone> humasect: I guess the server was just doing something weird, or the javascript "ajax" stuff
22:27:59 <humasect> =)
22:28:01 <vixey> oh you don't do it via typecase
22:28:05 <dolio> Otherwise it'd be trivial.
22:28:06 <vixey> but I've said too much!
22:28:10 <vixey> :p
22:29:24 <Saizan> dolio: uhm, no, i don't want exact equality, i'm trying to implement extensible records as in the scoped labels paper, where they use non-syntactic equality between types of records (the order of distinct fields doesn't matter)
22:30:00 <vixey> oh
22:30:08 <dolio> Hmm.
22:30:55 <Saizan> dolio: so i've a type-level list, and extractors like   get : forall {A tail l} -> Record (l := A , tail) -> A
22:31:06 <vixey> sounds like you need a procedure which decides if one type is a subtype of another, and when they are gives you an projection function
22:31:09 <solrize>    A cotheorem is like a theorem except you start from the conclusions and reason backwards until you prove the assumptions.
22:31:09 <solrize> A statement that easily leads to the proof of a cotheorem is called a ‘rollary’.
22:31:53 <vixey> also a subtype property  and a proof that if it holds the procedure will always return Just <projector>
22:32:06 <vixey> at least that's the first thing I'd try
22:32:36 <dolio> I'm going to concur with that.
22:33:54 <Saizan> so the type of get will be : SubtypeProperty xs (l := A, tail) -> Record xs -> A ?
22:34:07 <dolio> If you wanted strict 'equality', then I'd say you'd represent the equality by some function A' -> A, which reorders values of type A' in the right way to get an A.
22:34:40 <adu> vixey: What does "tuple : Type -> *" mean?
22:34:49 <vixey> :k Int
22:34:51 <lambdabot> *
22:34:57 <adu> oic
22:35:29 <humasect> what is the simple reverse of (a:as) :: a -> [a] -> [a]  , where it adds as tail and not head?
22:35:30 <adu> vixey: can you actually do that?
22:35:42 <vixey> adu: well the language doesn't exist :)
22:35:54 <adu> o
22:36:06 <mmorrow> *yet*
22:36:14 <humasect> > (1 : [2 3 4 5] reverse) reverse
22:36:14 <mmorrow> (i have no idea what we're talking about)
22:36:15 <lambdabot>  Couldn't match expected type `t1 -> [t]'
22:36:57 <dobblego> humasect, are you trying to write a reverse function?
22:37:10 <Twey> How do I create a module in a separate file that can be `import`ed by my Main module?  And why do I find so little documentation on how to do this?  :-\
22:37:35 <glguy> @seen dons
22:37:35 <lambdabot> dons is in #arch-haskell, #xmonad, #ghc and #haskell. I last heard dons speak 43m 24s ago.
22:38:06 <dobblego> > reverse (reverse (1 : [2, 3, 4, 5]))
22:38:07 <adu> Twey: you make a file called MyModule.hs, then at the top of that put "module MyModule where..."
22:38:07 <lambdabot>  [1,2,3,4,5]
22:38:20 <adu> Twey: then in your Main module you put "import MyModule"
22:38:27 <Saizan> dolio: do you know if type-inference or something could then construct the proofs of the property for me?
22:38:33 <humasect> dobblego: ah, thank you, wrong language! my brain is not working correctly.
22:38:51 <Twey> adu: How about nested modules?  Foo.Bar and so?  Is Foo just a directory or what?
22:38:53 <mmorrow> Twey: suppose you want   to do     import MyStuff.MyModule
22:38:58 <Twey> Aye
22:39:01 <humasect> > reverse (1 : reverse [2, 3, 4, 5])
22:39:02 <lambdabot>  [2,3,4,5,1]
22:39:02 <mmorrow> then you'd have MyStuff/MyModule.hs
22:39:05 <dolio> Saizan: I doubt Agda is smart enough to guess what permutation function you want just from the type.
22:39:21 <rwbarton> > [2, 3, 4, 5] ++ [1] -- probably preferable
22:39:22 <adu> lets say your sources are all at src/
22:39:22 <lambdabot>  [2,3,4,5,1]
22:39:22 <mmorrow> Twey: and Main would be in the same directory as the directory MyStuff
22:39:30 <Twey> Hmn, just a sec...
22:39:36 <mmorrow> Twey: (i meant Main.hs would be in ...)
22:39:37 <humasect> rwbarton: oh! thank you =)
22:39:48 <rwbarton> humasect: Note it's still linear time in the length of the list
22:39:56 <adu> Twey: you could put your top dir at src/My/Module.hs then at the top put module My.Module where...
22:39:58 <mmorrow> @seen chrisdone
22:39:58 <lambdabot> chrisdone is in #haskell. I last heard chrisdone speak 12m 7s ago.
22:39:59 <Saizan> dolio: i miss the logic programming given by typeclasses :)
22:40:13 <pjdelport> > foldr (:) [1] [2, 3, 4, 5]
22:40:14 <lambdabot>  [2,3,4,5,1]
22:40:18 <adu> Twey: then call GHC with ghc -isrc since thats the top of the dir
22:40:24 <humasect> and [1] is ok for single element concatenation ?
22:40:42 <humasect> pjdelport: hmm.. =)
22:40:51 <dobblego> humasect, are you trying to write reverse?
22:40:51 <adu> Twey: or if main is in src/ then you don't need to worry about it
22:41:16 <humasect> dobblego: nope, just wanting to change this old code here of mine to add to end of the list without rewriting the algorithm
22:42:12 <adu> Twey: if "src" is in the directories ghc looks in then "import My" will load "src/My.hs" and "import My.Module" will load "src/My/Module.hs"
22:42:19 <pjdelport> > let rcons = foldr (:) . (:[]) in 1 `rcons` [2..5]
22:42:20 <lambdabot>  [2,3,4,5,1]
22:42:35 <humasect> tsk=)
22:43:03 <pjdelport> humasect: appending costs O(N) instead of O(1), though
22:43:24 <pjdelport> it's almost certainly better to adjust the code so that you can prepend
22:43:52 <pjdelport> (there's a good chance that you'll end up with a simpler implementation along the way)
22:44:21 <humasect> it is already prepending,  but now the data needs to be in reverse
22:44:33 <humasect> i think the cost is ok for this application
22:44:36 <pjdelport> define "needs to be in reverse"?
22:44:47 <pjdelport> if it's for the result, reverse once at the end
22:44:59 <humasect> it is controlled by interface, so the last added element needs to be the last in the list
22:44:59 <pjdelport> so you only reverse once in total, instead of N times
22:45:12 <mmorrow> :t (mconcat .) . fmap
22:45:12 <lambdabot> forall a b. (Monoid b) => (a -> b) -> [a] -> b
22:45:16 <mmorrow> :t (concat .) . map
22:45:17 <lambdabot> forall a a1. (a1 -> [a]) -> [a1] -> [a]
22:45:18 <humasect> it is stateful so i think i will use [...] + [1]
22:45:36 <pjdelport> humasect: can you explain in a bit more detail?
22:45:44 <mmorrow> :t (foldr (++) mempty .) . map
22:45:45 <lambdabot> forall a b. (Monoid b) => (a -> b) -> [a] -> b
22:45:58 <dobblego> humasect, it is highly likely that you should not be doing that
22:46:05 <pjdelport> right
22:46:22 <humasect> it is a polygon editor, and it is clearer for the rest of implementation if the windings are clockwise just like they are created with user input
22:46:35 <pjdelport> besides the excess traversal, every append will require reallocating the entire list
22:48:10 <pjdelport> humasect: you can usually do that without appending each individual element
22:48:42 <Saizan> if the list is not big it shouldn't be a problem
22:48:52 <humasect> each element is driven essentially by mouse click, the data should reflect as it was created in the interface
22:48:58 <humasect> yes very very small lists
22:51:27 <telexicon> what would be the best way to find the largest Int in a list?
22:51:40 <humasect> Data.Array.Storable is immutable ?
22:51:46 <dobblego> @type maximum
22:51:47 <lambdabot> forall a. (Ord a) => [a] -> a
22:51:51 <dobblego> telexicon, using that ^
22:52:00 <telexicon> ah, thanks
22:55:18 <magthe> @info LocalTime
22:55:18 <lambdabot> LocalTime
22:56:32 <magthe> @type parseTime
22:56:33 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
22:57:31 <magthe> :t parseTime
22:58:17 <nyingen> I'm continually amazed at the quality of documentation available on the haskell wiki
22:58:31 <nyingen> Whoever wrote "IO Inside" deserves a medal or something
23:01:04 <mjrosenb> is there a form of error that will give me the line number that it was raised from?
23:19:43 <ptolomy2> Hmm.. can overloaded literals fail?
23:19:59 * ptolomy2 is pondering the possibility of regex literals.
23:20:15 <mjrosenb> what is an overloaded literal?
23:23:29 <gnut> hello all
23:23:37 <glguy> anyone have a link to a favorite core coloring and viewing script?
23:24:07 <gnut> anyone tried package NDP and got it to work?
23:24:13 <kaol> mjrosenb: you can get line numbers if you generate the error messages with TH, at least
23:24:39 <ptolomy2> mjrosenb: Well, for instance, we can have ByteString literals, where "foo" can be a bytestring.
23:24:40 <pejo> gnut, there's a lot of breakage right now, someone asked about that on ghc-users mailing list the other day iirc.
23:25:07 <gnut> pejo: ah. thanks.
23:25:22 <gnut> I see that what they have available is from mar 2007 (0.1 version, that is)
23:25:39 <gnut> I'm looking to writing some scientific code, and I'm going to try it with Haskell.
23:26:59 <mjrosenb>  kaol TH?
23:30:13 <kaol> Template Haskell. Though I don't have a ready example to point to.
23:39:03 <humasect> what is the inverse of fromIntegral ? ( 1.0 -> 1 :: Num)
23:39:52 <Saizan> ?ty round
23:39:55 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
23:40:02 <humasect> oh! thanks=)
23:40:19 <Saizan> there's also floor, ceiling and truncate
23:41:20 <humasect> yep, floor is being used too before it (to round to 1's) but only gives RealFrac
23:41:41 <humasect> (sometimes it needs to be Int, sometimes Fractional)
23:43:05 <_zenon_> Actually that is a quite interesting topic, all the different rounding methods :)
23:43:22 <humasect> i wonder what truncate does =)
23:43:23 <_zenon_> I read a short article on it in an old IEEE issue
23:43:48 <humasect> just removes the epsilon ?
23:45:58 <humasect> (ah, truncate is better for what i wanted than round)
23:50:26 <Beelsebob> humasect: truncate just pulls the fractional part off, while floor rounds down
23:50:35 <Beelsebob> so they're different for negative numbers
23:51:04 <Beelsebob> also, floor goes to Integral a
23:51:08 <Beelsebob> not RealFrac a
23:51:13 <humasect> ahh yes i see. it looks like floor rounded up
23:51:18 <humasect> err i mean:
23:51:19 <mjrosenb> is there a function that pulls off the integral part?
23:51:20 <humasect> > round 1.5
23:51:22 <lambdabot>  2
23:51:29 <mjrosenb> 1.23 -> 0.23
23:51:30 <mjrosenb> ?
23:51:31 <Beelsebob> > truncate 1.5
23:51:32 <lambdabot>  1
23:51:53 <humasect> > round 1.499999
23:51:54 <lambdabot>  1
23:51:55 <Beelsebob> mjrosenb: \x -> x - (truncate x)
23:51:55 <vixey> divMod
23:52:16 <vixey> quotRem
23:52:24 <Beelsebob> divMod needs integrals doesn't it?
23:52:25 <humasect> round goes up as well as down.
23:52:28 <dolio> > properFraction 1.5
23:52:29 <lambdabot>  (1,0.5)
23:52:38 <Beelsebob> humasect: yes -- round goes to the closest
23:52:49 <mjrosenb> :t (\x -> x - (truncate x))
23:52:50 <lambdabot> forall a. (Integral a, RealFrac a) => a -> a
23:53:08 <mjrosenb> > (\x -> x - (truncate x)) 1.3
23:53:09 <lambdabot>  Add a type signature
23:53:15 <Beelsebob> round: closest; truncate: remove fructional part; floor: round down; ciel: round up
23:53:16 <mjrosenb> > (\x -> x - (truncate x)) 1.3 :: Int
23:53:17 <lambdabot>   add an instance declaration for (RealFrac Int)
23:53:21 <vixey> :t \x -> x - truncate x
23:53:21 <mjrosenb> yeah.....
23:53:22 <lambdabot> forall a. (Integral a, RealFrac a) => a -> a
23:53:31 <Beelsebob> oh, duh
23:53:45 <Beelsebob> \x -> x - (fromIntegral $ truncate x)
23:53:56 <rwbarton> > 1.3 mod' 1
23:53:57 <lambdabot>        add an instance declaration for
23:53:57 <lambdabot>       (Fractional ((a -> a -> a) -> t ...
23:53:59 <Beelsebob> > \x -> x - (fromIntegral $ truncate x) 9.3
23:53:59 <lambdabot>   add an instance declaration for (Num (t -> a))
23:54:07 <rwbarton> > 1.3 `mod'` 1
23:54:07 <mjrosenb> it is kinda annoying like that
23:54:08 <lambdabot>  0.30000000000000004
23:54:13 <Beelsebob> > (\x -> x - (fromIntegral $ truncate x)) 9.3
23:54:14 <lambdabot>  0.3000000000000007
23:54:18 <mjrosenb> wait, mod seems to work?
23:54:21 <rwbarton> mod'
23:54:26 <mjrosenb> oh i see
23:54:28 <dolio> > snd . properFraction $ 9.3
23:54:29 <lambdabot>  0.3000000000000007
23:54:42 <mjrosenb> rwbarton: is that defined only for lambdabot?
23:54:54 <rwbarton> uh
23:54:57 <rwbarton> possibly? :)
23:55:01 <dolio> mod' is in Data.Fixed
23:55:16 <humasect> @source properFraction
23:55:16 <lambdabot> properFraction not available
23:58:19 <_zenon_> A funny thing, I am switching between Gedit and Vim, and suddenly, I find myself pressing Ctrl+C , : w   in gedit, and I wonder why it does not save :)
