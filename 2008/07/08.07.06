00:10:00 <Axman6> is there any easier way of computing the Nth prime number than computing all primes up to N?
00:10:13 <wuxia> so i'm readingf http://www.haskell.org/ghc/docs/6.4/html/libraries/base/Data.IORef.html ... after I create a IORef w/ newIORef, ... how can I write to it? I don't see how to use writeIORef to it since the types don't match
00:10:15 <lambdabot> Title: Data.IORef, http://tinyurl.com/57nwkb
00:10:52 <wuxia> you only have to calutlate them up to sqrt (n)
00:11:01 <wuxia> oh wait, n/m, the nth prime number
00:14:02 <bd_> Axman6: I don't think so, if you want to get an exact result, anyway.
00:14:30 <bd_> You could index into a list I suppose :)
00:16:20 <kiris> I'm get'ing xmonad with darcs but it's taking minutes to get. is there any way to speed it up?
00:16:56 <wuxia> xmoand is very bvery fast for me
00:16:59 <Axman6> kiris: cook some eggs
00:17:10 <wuxia> what are the specs of your machine?
00:17:11 <Axman6> passes the time
00:17:45 <kiris> 3Ghz, 1GB? basically fast enough
00:17:54 <wuxia> yeah, it should be measured in seconds
00:18:00 <wuxia> single digit seconds
00:18:37 <carl> is the type of a lazy byte string just ByteString if ive imported Data.Bytestring.Lazy
00:18:45 <kiris> reading blogs apparently it's doing loads of scp commands than it should need to but I dunno. ah, it's just finished. applying the patches took about one second
00:19:21 <Axman6> kiris: depends on your network speed
00:19:44 <wuxia> oh wait ... ur getting xmonad
00:19:46 <wuxia> not running it
00:19:53 <kiris> yes!
00:21:23 <wuxia> anyone have a good tutorial on how IORef is used?
00:24:51 <mbz> j #xmms2
00:24:54 <mbz> oops
00:31:50 <jre2> is haddock 2.0 stable?
00:34:21 <wuxia> why is it that: main = do va <- newIORef 0 writeIORef va 1
00:34:23 <wuxia> works, but :
00:34:33 <wuxia> va = newIORef 0
00:34:33 <wuxia> main = do writeIORef va 1
00:34:35 <wuxia> did not
00:36:10 <ziman> because the first va :: IORef Int while the other va :: IO (IORef Int)
00:36:29 <wuxia> how can IK make the latter work?
00:36:34 <kaol> newIORef 0 is an IO action. if you do va = newIORef 0, you are just storing the action. in va <- newIORef 0, you perform it too
00:36:36 <wuxia> i need to have a IORef i can access from many parts of my code
00:37:01 <wuxia> hmm, i'm a bit lost, can you help me write the following code: ... an accumulator ?
00:37:18 <wuxia> i.e. it takes a bunch of nmbers from stdio
00:37:22 <wuxia> and prints out an accumulated sum to stdout
00:38:33 <ziman> i suggest you read some monad tutorial to get the difference
00:39:10 <carl> is it possible to pick up an empty binarystring using pattern matching
00:39:18 <ziman> va <- newIORef 0 is just sugar for newIORef 0 >>= \va ->
00:39:45 <carl> i mean bytestring
00:44:24 <kiris> hehe. started xmonad inside gnome. this is awesome
00:57:24 <dabblego> kiris, where are the instructions for doing that? (I've been meaning to get to that)
00:57:45 <kiris> right here: http://haskell.org/haskellwiki/Xmonad/Using_xmonad_in_Gnome
00:57:46 <lambdabot> Title: Xmonad/Using xmonad in Gnome - HaskellWiki
00:58:07 <dabblego> ta
00:58:20 <kiris> :)
01:04:07 <zeno___> is there a function that does benchmarking (in GHCI)?
01:08:29 <dolio> Text.Parsec.Token is pretty handy.
01:26:26 <dmwit> zeno___: I have the following definitions in euler.hs.  If this is all you need, they can be handy:
01:26:47 <dmwit> timePrint c = do { x <- getCurrentTime; print c; y <- getCurrentTime; print (diffUTCTime y x) }
01:27:03 <dmwit> timeEquality = timePrint . join (==)
01:27:20 <zeno___> dmwit: wow thanks i was trying to figure out how to write that myself :)
01:27:23 <mjrosenb> dmwit: hopefully the printing doesn't take too long
01:27:36 <dmwit> mjrosenb: Right, that's actually why I wrote timeEquality. =)
01:28:36 <mjrosenb> dmwit: you can't just force an egar evaluation, and print it after the second time has been taken?
01:29:07 <dmwit> mjrosenb: "print" is a pretty good way to force eager evaluation.  So is (==).
01:29:13 <dmwit> mjrosenb: Better than, say, seq.
01:29:59 <mjrosenb> (==) i'd believe
01:30:13 <mjrosenb> but why is either better than seq?
01:30:34 <dmwit> Because [cheap, expensive] `seq` anything is cheap.
01:30:54 <dmwit> In fact, even [expensive, expensive] `seq` anything is cheap.
01:31:08 <dmwit> That is: print and (==) evaluate a bit "deeper" than seq does.
01:31:24 <mjrosenb> i see
01:31:36 <dmwit> "seq" evaluates to the first constructor only.
01:32:01 <mjrosenb> eww
01:32:13 <dmwit> So [expensive] `seq` () evaluates just enough to know that it's a (:), not a [].
01:32:21 <mjrosenb> i guess that makes sense
01:32:29 <dmwit> yep
01:32:48 <dmwit> There are type-classes for other forms of evaluation forcing.
01:32:59 <dmwit> But for quick throwaway tests, this is pretty good.
01:33:04 <dmwit> Okay, I've got to go to bed.
01:33:57 <mjrosenb> seq [bot] 2
01:34:02 <mjrosenb> return 2 :(
01:34:06 <mjrosenb> returns
01:34:57 <dmwit> Yes.  Semantically, seq = const.
01:35:11 <dmwit> It only differs from const operationally.
01:35:24 <dmwit> err... flip const.
01:35:27 <mjrosenb> ja, so seq bot 2 does'nt return
01:35:39 <dmwit> right
01:36:10 <mjrosenb> i like how if is an entirely superfuluous construct in haskell
01:43:37 <zeno___> does it compile to | + otherwise?
01:48:02 <mjrosenb> i'm just saying that it's possible to write a function that implements if
01:48:32 <mjrosenb> my guess would be case foo of True -> bar; False -> quux
01:48:42 <mjrosenb> at least that's how sml does it
01:52:07 <mjrosenb> anyone know how smart ghc's pattern compiler is?
01:58:55 <kiris> quantifying smartness
02:00:12 <Beelsebob> about, |<----this smart---->      but not this bit      |
02:16:40 <mjrosenb> so if i'm doing matching against a list of bools
02:17:16 <mjrosenb> and i have 5 cases that start with False, followed by a case that starts with True
02:17:38 <mjrosenb> and the list tha we end up matching against starts with True
02:18:04 <mjrosenb> will it end up running throug every case, or will it just jump to the first True case and start there
02:18:41 <therp> it will run through every clause I think.. you could split it into separate case statements
02:19:12 <mjrosenb> however that would look uglier and not be as obvious
02:19:33 <therp> true..
02:21:14 <mjrosenb> i'm just getting really annoyed that i can't have multiple matches in a single anonymous lambda
02:21:22 <mjrosenb> this seems like a stupid limitation
02:23:11 <therp> mjrosenb: (\x -> case x of ..) the best you can get I guess..
02:23:26 <mjrosenb> therp: that's what i'm using
02:23:41 <therp> haskell needs dirty meta-programming :)
02:23:55 <mjrosenb> hrmm, guess i should go to #ghc for a bunch of these questions
02:24:33 <mjrosenb> like (\x -> case x of True:t -> (foo, t))
02:24:34 <mjrosenb> and
02:25:15 <mjrosenb> (\x -> case map fromEnum x of 1:t -> (foo, map toEnum t))
02:25:41 <mjrosenb> should compile to identical code, right?
02:35:22 <Tobsan> is it possible to write integers as powers, as if i want to write 10^18, not having to write 18 zeros
02:35:34 <Beelsebob> > 10e18
02:35:39 <lambdabot>  1.0e19
02:35:52 <dabblego> > 10^18
02:35:53 <Tobsan> yes, but that is a fractional integer, isnt it?
02:35:54 <lambdabot>  1000000000000000000
02:35:59 <Tobsan> oh i see
02:36:08 <Beelsebob> > 10**18
02:36:10 <lambdabot>  1.0e18
02:36:15 <Beelsebob> all sorts
02:36:31 <Tobsan> didnt know one could write 10^18 just like that
02:36:45 <Beelsebob> @type (^)
02:36:47 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
02:38:01 <Beelsebob> note that it's not actually a constant -- it's an application, and thus in theory less efficient
02:38:11 <Beelsebob> otoh, any compiler with half a brain will partially compute that
02:38:27 <mjrosenb> however it should be constant-folded
02:38:42 <Beelsebob> idd
02:49:52 <Axman6> hmm, i don't like stack overflows
02:50:41 <paolino> a lazyness price
02:52:18 <mjrosenb> paolino: not neceserialy
02:52:25 <paolino> but there are good clue hunters around here usually
02:52:43 <mjrosenb> Axman6: it might be totally unrelated to laziness
02:53:43 <Axman6> well i'm trying to find the longest list in a list of lists created by a function i've written. seems that 'longest' is what's dying
02:54:18 <paolino> mjrosenb: well, those I met that I couldn't understand
02:54:28 <Axman6> better idea...
02:55:15 <mjrosenb> Axman6: try using foldl'
02:55:28 <Axman6> @src foldl'
02:55:29 <lambdabot> foldl' f a []     = a
02:55:29 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
02:55:50 <Axman6> @type foldl'
02:55:51 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
02:55:52 <kiris> are you running it from ghci?
02:55:56 <Deewiant> > maximumBy (comparing length) [[1..3],[1..10],[1..5]]
02:55:57 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
02:56:23 <ziman> now that's handy!
02:56:28 <Axman6> i need which number element it is
02:56:39 <Axman6> the index
02:56:49 <paolino> zip it with [1..]
02:57:26 <kiris> > fst $ maximumBy (comparing (length . snd)) $ zip [1..] [[1..3],[1..10],[1..5]]
02:57:29 <lambdabot>  2
02:57:37 <paolino> and comparing (length . )
02:57:39 <paolino> ops
02:57:43 <Deewiant> > fst . maximumBy (comparing (length.snd)) . zip [0..] $ [[1..3],[1..10],[1..5]]
02:57:45 <lambdabot>  1
02:57:58 <Deewiant> indices start from 0 :-)
02:58:14 <kiris> sometimes
02:58:22 <Deewiant> > "abc" !! 1
02:58:23 <Axman6> well i need the nth term, not the index
02:58:24 <lambdabot>  'b'
02:58:32 <kiris> right
02:58:46 <mjrosenb> > fst $ maximumBy (camparing (length . snd)) $ zip [1..] (map (\x -> [x..2*x]) [1..100000)
02:58:46 <lambdabot>  Parse error at ")" (column 88)
02:59:02 <Deewiant> > fst $ maximumBy (camparing (length . snd)) $ zip [1..] (map (\x -> [x..2*x]) [1..100000])
02:59:03 <lambdabot>   Not in scope: `camparing'
02:59:10 <mjrosenb> > fst $ maximumBy (comparing (length . snd)) $ zip [1..] (map (\x -> [x..2*x]) [1..100000])
02:59:17 <lambdabot>  Tried to use too much memory
02:59:23 <Deewiant> > fst $ maximumBy (comparing (length . snd)) $ zip [1..] (map (\x -> [x..2*x]) [1..1000])
02:59:25 <lambdabot>  1000
02:59:43 <mjrosenb> yeah... it seems like this is having the same issues
02:59:48 * mjrosenb tries it locally
03:00:03 <kiris> I needed something like this recently. I used (foldr max 0)
03:00:20 <kiris> actually (foldr (max . length) 0)
03:00:39 <mjrosenb> kiris: right, but foldr probably isn't the best solution there
03:00:57 <mjrosenb> what do i need to import to get comparing?
03:01:05 <kiris> @hoogle comparing
03:01:06 <lambdabot> Data.Ord.comparing :: Ord a => (b -> a) -> b -> b -> Ordering
03:01:31 <mjrosenb> right, that's giving me a stack overflow
03:01:37 <mjrosenb> it really shouldn't
03:01:51 <kiris> I got stack overflows in ghci, but not when compiled. does ghci optimise differently?
03:02:16 <Beelsebob> yes
03:02:21 <mjrosenb> yes
03:02:38 <mjrosenb> iirc, it does'nt bother with cps conversion
03:06:10 <Axman6> heh, got it wokring, had to use "./14 +RTS -K1000000000000" though
03:06:31 <Axman6> working*
03:09:49 <Beelsebob> how much stack???????? o.O
03:11:17 <mjrosenb> holy---
03:14:46 <chr1s> Axman6: http://www.cs.uu.nl/wiki/pub/Afp/CourseSchedule/AFP-2007.3-5.pdf
03:15:18 <chr1s> that's about strictness / folds
03:17:25 <Axman6> is there any way to speed up Fibonacci computation?
03:17:46 <mjrosenb> Axman6: how are you doing it currently?
03:17:48 <mattam> memoizing
03:18:16 <kiris> hm. I bet I could get lambdabot to show titles of PDF's using google's cache
03:18:29 <hpaste>  Axman6 pasted "Fib" at http://hpaste.org/8741
03:19:27 <u_quar1> Axman6: http://www.haskell.org/haskellwiki/Memoization
03:19:28 <lambdabot> Title: Memoization - HaskellWiki
03:19:42 <mjrosenb> Axman6: yes
03:21:49 <mjrosenb> although there are still faster methods
03:22:02 <paolino> Axman6: there are haskell solutions to the eulers problems on the haskell wiki, maybe they are interesting to learn
03:22:10 <mjrosenb> that will still choke on computing fib 1000000000
03:22:57 <mjrosenb> so for the simple memoized fib function
03:23:08 <paolino> (if you are working on them)
03:23:09 <mjrosenb> that uses map fib [0..] !!
03:23:11 <u_quar1> Axman6: or just use recursion as a loop like you would do in C
03:23:25 <Axman6> rawr, too tired
03:23:28 <mjrosenb> does it actually do a linear walk for each 'lookup'?
03:24:30 <dolio> > let (x:xs) !!! 0 = x ; (x:xs) !!! n = x `seq` xs !!! (n-1) in fix ((0:) . scanl (+) 1) !!! 1000000000
03:24:31 <lambdabot> Terminated
03:25:52 <Axman6> the answer on the wiki is painful
03:25:56 <Axman6> -_-
03:26:26 <ooxwo> Yeah Axman6 that is the tree-recursive version, many unnecessary computations
03:27:00 <ooxwo> The iterative version is very short and much improved complexity wise
03:28:53 <ooxwo> fib n = fib' 1 0 n
03:28:57 <Axman6> well i found the answer by hand in the end
03:29:35 <ooxwo> where fib' a b 0 = b
03:29:45 <mjrosenb> ooxwo: once again, that version still fails at large numbers
03:29:58 <ooxwo> Ah then you need the logarithmic version
03:30:07 <ooxwo> based on exponentiation
03:30:16 <ooxwo> Check out SICP exercise 1.19 for that one
03:30:41 <mjrosenb> ooxwo: that sounds like you're using real arithmatic
03:30:46 <mjrosenb> ooxwo: and that's evil
03:31:43 <ooxwo> Haha yeah with much coaxing from the masters.  That exercise in particular is brilliant, being the culmination of many points up until then.
03:32:21 <ooxwo> http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-11.html#%_sec_1.2.4
03:32:21 <lambdabot> http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-11.html#%_sec_1.2.4
03:33:22 * mjrosenb searches for his fib code
03:34:25 <ooxwo> fib 1000000 the iterative way takes 12 minutes on my machine
03:34:38 <ooxwo> fib 1000000 the logarithmic way takes a third of a second
03:34:52 <paolino> ok, noone helped me with http://hpaste.org/8553 maybe someone want to have fun with http://hpaste.org/8742
03:35:27 <mjrosenb> ooxwo: so does it use real math or no?
03:37:45 <dolio> > let foo 0 n = n ; foo k n = foo (k-1) (n+1) in foo 10 0
03:37:46 <lambdabot> Terminated
03:38:10 <ooxwo> mjrosenb: It is a pretty clever trick.  And some nice stuff with 'squaring' a transformation.  but I don't know what you mean by real math?
03:38:20 <ooxwo> Taylor series maybe?
03:38:23 <ooxwo> Complex analysis?
03:38:41 <dolio> > let foo 0 n = n ; foo k n = foo (k-1) (n+1) in foo 0 0
03:38:43 <lambdabot> Terminated
03:38:43 <u_quark> paolino: gcj ? :P eggdrop is a known problem i think ... hexagon is a bit tricky ... :)
03:38:44 <ooxwo> not really
03:38:45 <mjrosenb> ooxwo: i mean does it use floating point arithmatic or just integral
03:38:57 <quicksilver> @tell mmorrow Thanks for quadrics paper
03:38:57 <lambdabot> Consider it noted.
03:39:06 <dolio> Riddle me that.
03:39:07 <mjrosenb> hrmm, mine seems to segfault inside of libgmp
03:39:22 <ooxwo> mjrosenb:  No floating point, it is exact
03:39:55 <u_quark> is there a way to "select", like in posix select, from a number of handles ?
03:40:01 <mjrosenb> ooxwo: sounds like what i use.  still uses a ton of memory though
03:40:10 <quicksilver> u_quark: normally there is no need. Just use threads, that's what they do.
03:40:17 <paolino> u_quark: it's funny logic with small limits but interesting with big ones
03:40:33 <ziman> .
03:40:38 <ooxwo> Oh yeah, the numbers just get enormous really, no way to avoid that
03:41:04 <xerox> quicksilver: what about quadrics?
03:41:24 <u_quark> quicksilver: I don't know/understand ... how can i wait from many handles ?
03:41:27 <ooxwo> I remember when I discovered that one though, really gave me a shock.  I still suspect to this day that any linear process can somehow be coerced into a logarithmic one, somehow.
03:41:33 <quicksilver> xerox: mmorrow sent me a link to a paper on quadric error matrices to simplify meshes
03:41:43 <quicksilver> u_quark: blocking IO is a simpler model than select
03:41:53 <quicksilver> u_quark: so the standard haskell solution is to fork one or two threads for each handle
03:41:56 <quicksilver> u_quark: and just let them block.
03:41:56 <mjrosenb> ooxwo: i'd be a bit suspicious of that statement
03:42:08 <mjrosenb> ooxwo: how about the q function/series
03:42:26 <u_quark> paolino: I haven't solved them yet ... that a reason why i was looking into memoization ...
03:43:15 <ooxwo> mjrosenb:  Oh yeah I know it's ridiculous, but possibly we just lack the necessary cleverness.
03:43:36 <mjrosenb> ooxwo: you want to give q a try?
03:43:41 <u_quark> quicksilver: yes... but how can the threads communicate asynchronously after ??? do we have an actor model or events or something ?
03:43:46 <mjrosenb> ooxwo: i haven't found anything for it yet
03:43:59 <quicksilver> u_quark: MVars
03:44:05 <quicksilver> u_quark: Chans
03:44:11 <quicksilver> u_quark: and things built upon them.
03:45:15 <u_quark> all that doesn't seam to do the trick ... i am not sure though
03:45:27 <ooxwo> mjrosenb:  which q do you mean, the one from sicp or the pochhammer one?
03:45:38 <quicksilver> u_quark: I promise you it does :)
03:45:41 <paolino> u_quark: I still couldn't solve hexagons , while I think eggdrop is not needing memoization
03:45:50 <u_quark> i have to built a event framework on top of all that...
03:45:52 <mjrosenb> ooxwo: i got it from G.E.B
03:45:58 <quicksilver> u_quark: it's a much simpler model than coping manually with select.
03:46:27 <u_quark> paolino: memoization ingeneral for the gcj... :)
03:46:42 <quicksilver> in fact, if you try to use select in a sensible way you end up storing continuations to each handle
03:46:43 <ooxwo> mjrosenb:  Haha one of my favorite books.  I don't remember that part though, can you refresh my memory?  Was it one of the formal systems?
03:46:46 <mjrosenb> > let q 0 = 0; q 1 = q; q n = q (n-q(n-1)) + q (n-q(n-2)) in map q [1..20]
03:46:47 <lambdabot> Terminated
03:46:50 <quicksilver> which is just manual threading.
03:46:53 <mjrosenb> > let q 0 = 0; q 1 = q; q n = q (n-q(n-1)) + q (n-q(n-2)) in map q [1..10]
03:46:54 <lambdabot> Terminated
03:47:01 <mjrosenb> > let q 0 = 0; q 1 = q; q n = q (n-q(n-1)) + q (n-q(n-2)) in  q 4
03:47:03 <lambdabot> Terminated
03:47:05 <chr1s> > let maximumByStrict cmp = foldl' max
03:47:05 <lambdabot>  Parse error at end of input
03:47:33 <u_quark> quicksilver: well... :P yes
03:47:58 <mjrosenb> > let q 0 = 1; q 1 = 1; q n = q (n-q(n-1)) + q (n-q(n-2)) in  map q [1..20]
03:47:59 <lambdabot> Terminated
03:48:04 <mjrosenb> > let q 0 = 1; q 1 = 1; q n = q (n-q(n-1)) + q (n-q(n-2)) in  map q [1..10]
03:48:05 <lambdabot> Terminated
03:48:11 <dolio> Don't bother.
03:48:13 <mjrosenb> gnah
03:48:14 <dolio> > let foo 0 n = n ; foo k n = foo (k-1) (n+1) in foo 0 0
03:48:15 <lambdabot> Terminated
03:48:25 <dolio> There's something fubared.
03:48:26 <mjrosenb> >2+2
03:48:27 <chr1s> let maximumBy' cmp xs = foldl1' max xs in fst $ maximumBy' (compare . length . snd) $ zip [1..] (map (\x -> [x..2*x]) [1..1000000])
03:48:28 <ooxwo> mjrosenb:  Reminds me of the ackermann function
03:48:36 <chr1s> > let maximumBy' cmp xs = foldl1' max xs in fst $ maximumBy' (compare . length . snd) $ zip [1..] (map (\x -> [x..2*x]) [1..1000000])
03:48:38 <u_quark> but still ... i cant understand how can i wait for input from the peer and wait for event from other threads ...
03:48:39 <lambdabot>  1000000
03:48:39 <mjrosenb> ooxwo: sans the growth rate
03:48:43 <u_quark> quicksilver: ^^
03:49:02 * mjrosenb runs for 30 on his local box
03:49:10 <dolio> > 1 + 1
03:49:11 <lambdabot> Terminated
03:49:15 <dolio> @undefine
03:49:16 <lambdabot> Undefined.
03:49:18 <dolio> > 1 + 1
03:49:20 <lambdabot>  2
03:49:23 <dolio> There we go.
03:50:11 <quicksilver> u_quark: you have a thread blocking on each handle
03:50:22 <quicksilver> u_quark: each of those threads, if it receives something, has two choices
03:50:23 <mjrosenb> [1,2,3,3,4,5,5,6,6,6,8,8,8,10,9,10,11,11,12,12,12,12,16,14,14,16,16,16,16,20]
03:50:26 <quicksilver> (a) handle it locally
03:50:27 <chr1s> Axman6: ^^
03:50:32 <quicksilver> (b) stuff it in a "Chan" back to the main thread
03:50:38 <Axman6> ?
03:50:38 <quicksilver> depending what your computation model is
03:50:43 <mjrosenb> ooxwo: there we go.... it grows rather slowly
03:50:49 <mjrosenb> ooxwo: and erratically
03:50:50 <quicksilver> handle it locally might be "grab state MVar, make change, replace state"
03:51:13 <chr1s> Axman6: I get a result almost instantly when using foldl', see above =)
03:53:34 <Axman6> "maximumBy' cmp xs = foldl1' max xs in fst $ maximumBy' (compare . length . snd) $ zip [1..] (map (\x -> [x..2*x]) [1..1000000])" ?
03:53:53 <u_quark> quicksilver: ok.... but inside a thread with a socket i want to receive "events" from other threads *while* waiting for something from the remote peer so I can pass it to him...
03:53:58 <chr1s> Axman6: yes
03:53:59 <Axman6> ghci doesn't seem to like that
03:54:08 <Axman6> <interactive>:1:18: parse error on input `='
03:54:15 <chr1s> well, there should be a "let" in front of it
03:54:27 <chr1s> so "let maximumBy ...."
03:54:31 <Axman6> <interactive>:1:24: Not in scope: `foldl1''
03:54:46 <chr1s> Axman6: import Data.List
03:55:02 <chr1s> or, in GHCi, :m +Data.List
03:55:05 <ooxwo> mjrosenb:  You know, I haven't tried it but you could probably do something similar to the fib solution by defining the transformation it implies and then apply it to itself, sort out the algebra and use it to 'square' the factors applied to each iteration, progressively halving even values of n
03:57:12 <ooxwo> mjrosenb:  That is an interesting sequence though
03:57:27 <mjrosenb> i need explicitly write out a tree, and i don't seem to grok haskell's indentation rules yet
03:57:38 <mjrosenb> anyone feel like helping out?
03:57:47 <Axman6> chr1s: i'm missing something. i've got the definition of maximumBy', is there a maximumBy?
03:58:02 <ooxwo> mjrosenb:  Was he making a point about things that are defined simply can exhibit unpredictable behavior?
03:58:17 <mjrosenb> ooxwo: i believe so
03:58:25 <quicksilver> u_quark: then you want two threads
03:58:35 <quicksilver> u_quark: normally it's two thread per socket, a reader and a writer
03:58:37 <u_quark> two threads ??? :O
03:58:41 <quicksilver> yup.
03:58:47 <u_quark> oh....
03:58:54 <quicksilver> so one can block on reading and one on writing
03:58:56 <u_quark> ic :)
03:58:57 <chr1s> Axman6: well, I thought you had problems with the function that mjrosenb showed
03:59:21 <Axman6> i haven't been following this chan for a while now
04:00:43 <chr1s> Axman6: oh, nevermind then. I was just playing around with that code to see if I could optimize it a bit.
04:01:13 <u_quark> wouldn't it be interesting to have a event-based concurrency in haskell ? :)
04:01:44 <u_quark> quicksilver: tnx... i think that 2 threads will do the trick :)
04:01:59 <Axman6> i was quite happy to me answer to Q.9: answer = [(x*y*z) | x <- [1..500], y <- [1..500], z <- [1..500], x+y+z == 1000, x*x+y*y == z*z]
04:02:02 <Axman6> my*
04:03:26 <quicksilver> u_quark: I don't know what event based concurrency means
04:03:31 <quicksilver> sounds like a buzzword to me
04:03:34 <quicksilver> I'm sure haskell can do it though :)
04:03:36 <quicksilver> Chans ftw
04:03:37 <u_quark> LOL
04:03:44 <u_quark> xaaxaxaxa
04:03:58 <u_quark> i mean like erlang
04:04:04 <dolio> Haven't seen that one before.
04:04:12 <u_quark> actor-based ... i am not sure...
04:04:57 <dolio> Erlang 'just' has a Chan Dynamic automatically associated with every thread.
04:04:58 <Axman6> dolio: that answer?
04:05:10 <Axman6> oh, nm
04:05:11 <matthew-_> u_quark: you can sorta get there with the sessions stuff. But there are very good reasons why we'll never have the "one mailbox per process" thing
04:05:27 <dolio> No, "xaaxaxaxa". I've seen "ha" "ja" "ke"...
04:05:32 <matthew-_> yeah, unless you go the dynamic typeable route
04:05:35 <int-e> dolio: and integrated with the scheduler so that threads with full chans get a higher priority than empty chans.
04:05:36 <Axman6> oh, heh
04:06:06 <u_quark> :P
04:06:09 <dolio> I think that's covered in my scare-quoting of "just". :)
04:06:14 <matthew-_> int-e: the erlang schedular actually punishes threads that send messages to processes which are over loaded
04:06:37 <int-e> matthew-_: ok. the effect should be very similar.
04:07:56 <int-e> Punishing is more fair to all the uninvolved threads, I guess.
04:08:45 <hpaste>  mjrosenb pasted "needs to lose parens" at http://hpaste.org/8743
04:10:03 <Axman6> that looks like lisp >_<
04:10:42 <paolino> base = 1:map ((+1).(2 *)) base
04:10:42 <paolino> is there a pragmatic approach to explicit the definition ?
04:11:35 <mjrosenb> Axman6: i know
04:11:58 <mjrosenb> paolino: are you reffering to my code?
04:12:11 <paolino> no
04:12:20 <Axman6> i'd try and learn lisp if there were less parens
04:12:48 <mjrosenb> Axman6: i'd say it's not really worth it
04:12:56 <Axman6> heh
04:13:08 <Axman6> i've never been able to read any lisp i saw
04:13:50 <paolino> lisp is a write only language
04:16:39 <Deewiant> funny, I've always called lisp a read-only language :-)
04:17:04 <kiris> coming from lisp to haskell, I found haskell quite ugly in comparison
04:17:20 * schme agrees with kiris on the ugly haskell.
04:17:50 <paolino> ok, I guess things are subjective
04:18:00 <mjrosenb> what about haskell is  ugly?
04:18:08 <mjrosenb> the infix notation?
04:18:11 <int-e> there's a lot of syntactic sugar to learn and not all of it is immediately useful.
04:18:33 <kiris> its irregularity, I expect
04:19:10 <mjrosenb> ok so if i have foo :: a -> b -> c
04:19:15 <mjrosenb> and i want to compute
04:19:26 <mjrosenb> foo (foo 1 2) (foo 3 4)
04:19:49 <mjrosenb> is there a way of breaking that up with newlines and indenting it to eliminate all parens?
04:19:58 <schme> mjrosenb: It doesn't look like lisp. That's the ugly part :)
04:20:04 <Beelsebob> not to eliminate the parens, no
04:20:17 <Beelsebob> but you can put it on multiple lines to prettify it
04:20:27 <Heffalump> not without introducing extra operators, e.g. foo (foo 1 2) $ foo 3 4
04:20:32 <int-e> mjrosenb: let l = foo 1 2; r = foo 3 4 in foo l r
04:20:46 * mjrosenb int-e not going to work
04:21:35 <mjrosenb> Heffalump: would it then be possible to get rid of the ones that you have left?
04:22:00 <int-e> mjrosenb: what on earth for?
04:22:15 <Heffalump> not with ($)
04:22:23 <Heffalump> actually, foo 1 2 `foo` foo 3 4
04:22:28 <Heffalump> though that's pretty ugly
04:22:49 <Deewiant> > let infixl 9 $$; f $$ x = f x; foo x y = x + y in foo $$ foo 1 2 $$ foo 3 4
04:22:51 <lambdabot>  10
04:23:18 <Saizan> that's why $ should be infixl
04:23:28 <Deewiant> yep
04:24:15 <kiris> well, λb's title display can now support URLs with # in them and PDFs. any λb admins feel free to pull if you think these are good ideas http://chrisdone.com/phpdarcsview/?repo=lambdabot&inventory
04:24:18 <lambdabot> Title: phpDarcsView
04:24:29 <mjrosenb> int-e: so i'm trying to cut down on the total number of character present and to make the shape of the code vaguely resemble the structure of the data
04:24:46 <Heffalump> Saizan: too late to change now, though.
04:25:25 <mjrosenb> Saizan: i'd tend to disagree with it being infixl
04:25:48 * mjrosenb unloads a few tons of parens on his code
04:25:55 * Heffalump is coming round to the view that it'd be better if it had been infixl from the beginning
04:26:14 <u_quark> tnx all
04:26:25 <EvilTerran> it can be infixl in whatever comes after haskell
04:26:53 <Saizan> mjrosenb: why? it's more useful as infixl and it matches function application associativity
04:27:38 <mjrosenb> Saizan: so most of the time that i use it it's specifically to avoid the fact that function application is left associative
04:27:51 <mjrosenb> then again, that can usually be solved with .
04:28:02 <Saizan> always
04:28:02 <mjrosenb> which shouldn't have an associativity
04:28:30 <Heffalump> (.) needs an associativity declared so that it can be used without parens
04:28:35 <EvilTerran> mjrosenb, er, well, it's associative in the mathematical sense
04:28:38 <Heffalump> but since it is associative, it doesn't matter what is declared
04:28:59 <EvilTerran> so you need to have it associate one way or t'other so you can chain them
04:29:13 <mjrosenb> right
04:29:25 <Heffalump> I've been trying (foo . bar . baz $ x) for a bit
04:29:57 * mjrosenb thanks the nice ghc people who kindly optimize out all of those function calls
04:30:15 <EvilTerran> unless you're going to suggest an "infixa" (for "associative") which requires a proof that the operator really associates :P
04:30:31 <mjrosenb> EvilTerran: i've heard of worse ideas
04:30:32 <EvilTerran> (or at least assumes that it does)
04:31:06 <EvilTerran> so you can have rows of 'em without (...)s, but without specifying associativity
04:31:13 <MyCatVerbs> Only that wouldn't actually gain you anything, since if you *have* a proof that it doesn't matter whether you pick infixr or infixl, then... it doesn't matter whether you pick infixr or infixl anyway.
04:31:20 <EvilTerran> ... that way, you could also have both (. f . g) and (f . g .)
04:31:25 <EvilTerran> without anger
04:31:26 <Heffalump> well, it might gain you compiler optimisations
04:31:40 <EvilTerran> and, yes, it'd make more optimisations possible
04:31:41 <Heffalump> EvilTerran: that'd be nice (particularly for ++)
04:31:42 <EvilTerran> (maybe)
04:31:46 <EvilTerran> indeed
04:31:51 * Botje fires up the BEWBS combinator again
04:31:56 <EvilTerran> but the syntax-splice interpretation of operators would fix that
04:32:06 <MyCatVerbs> Heffalump: I'm tempted to say it almost certainly wouldn't, because the compiler would have to have some knowledge about which fixity is more efficient for any given operator.
04:32:08 <EvilTerran> without doing odd things involving unspecified fixities
04:32:11 <Heffalump> but ++ is a good example of where the right associativity declaration is very valuable despite it being associative
04:32:16 <Heffalump> MyCatVerbs: right
04:32:26 <EvilTerran> ie, (EXP OP) -> (\x -> EXP OP x), rather than ((OP) (EXP))
04:32:37 <MyCatVerbs> Heffalump: for instance, leftward use of (++) is suicidal, rightward usage is fine.
04:32:48 <EvilTerran> ... which'd even generalise to stuff like (++ [x] ++)
04:32:55 <Heffalump> MyCatVerbs: yeah, that's what I meant above
04:33:34 <MyCatVerbs> So just declare infixr (++), and yell at programmers who write foldl (++)
04:33:39 * mjrosenb would love to see (++ [x] ++)
04:34:00 <Heffalump> it'd give parsers nightmares though :-)
04:34:14 <EvilTerran> meh, that's an implementation detail :P
04:35:35 <EvilTerran> it'd also be nice with the splicing interpretation for (x ++ y ++) to be (\z -> x ++ y ++ z), ie (x++(y++z)), not (x++y)++z
04:35:52 <EvilTerran> which you can currently only get by writing ((x++).(y++)) instead of (x++y++)
04:36:02 <EvilTerran> (or using a lambda)
04:36:43 <matthew-_> Don't forget folks, if you're interested in coming to Anglo Haskell please add your name to  http://www.haskell.org/haskellwiki/AngloHaskell/2008
04:36:43 <matthew-_> -:- Topic (#anglohaskell): set by Philippa at Tue Jul  1 14:42:28 2008
04:36:45 <lambdabot> Title: AngloHaskell/2008 - HaskellWiki
04:36:45 <masak> EvilTerran: how come ((x++).(y++)) works but not (x++y++) ?
04:37:04 <EvilTerran> > (x++y++)
04:37:05 <lambdabot>      The operator `++' [infixr 5] of a section
04:37:05 <lambdabot>         must have lower preced...
04:37:21 <EvilTerran> because the precedences/associativities are wrong
04:37:25 <Heffalump> matthew-_: heh, I was just thinking about advertising it too :-)
04:37:29 <masak> EvilTerran: ah, ok
04:37:32 <Deewiant> ?ty (x ++ (y++))
04:37:33 <lambdabot>     Couldn't match expected type `Expr'
04:37:33 <lambdabot>            against inferred type `Expr -> Expr'
04:37:33 <lambdabot>     In the second argument of `(++)', namely `(y ++)'
04:37:33 <EvilTerran> > (1 + 2*) -- just like this doesn't work
04:37:36 <olsner> > (++x++y)
04:37:39 <lambdabot>   add an instance declaration for (Monoid Expr)
04:37:39 <lambdabot>      The operator `*' [infixl 7] of a section
04:37:39 <lambdabot>         must have lower precede...
04:37:46 <EvilTerran> aaaaaaa
04:37:53 <Deewiant> ?ty ((x ++ y) ++)
04:37:54 <lambdabot>     No instance for (Monoid Expr)
04:37:54 <lambdabot>       arising from a use of `++' at <interactive>:1:2-7
04:37:54 <lambdabot>     Possible fix: add an instance declaration for (Monoid Expr)
04:38:03 <EvilTerran> ... which was my error message,there? it got a bit lost
04:38:13 <EvilTerran> "The operator `*' [infixl 7] of a section must have lower precede..."
04:38:33 <olsner> yeah, I think "add an instance declaration for (Monoid Expr)" was mine and that was yours
04:39:05 <olsner> @ty let x = undefined; y = x in (++x++y)
04:39:06 <lambdabot> forall a. (Monoid a) => a -> a
04:39:12 <EvilTerran> masak, it's because if (x & y ? z) = x & (y ? z), it's not clear what (x & y ?) should mean
04:39:23 <EvilTerran> masak, (for any operators & and ?)
04:39:25 <int-e> @src (++)
04:39:25 <lambdabot> []     ++ ys = ys
04:39:25 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
04:39:25 <lambdabot> -- OR
04:39:25 <lambdabot> xs ++ ys = foldr (:) ys xs
04:39:25 <lambdabot> -- In lambdabot, this is generalised to:
04:39:27 <lambdabot> (++) = mappend
04:39:47 <EvilTerran> should (x & y ?) z = x & (y ? z), or (x & y) ? z
04:39:48 <EvilTerran> ?
04:40:11 <EvilTerran> i suggest the former, because, altho it makes parsing a bit harder, it's much more useful
04:40:19 <Heffalump> EvilTerran: the latter under your splicing interpretation, surely?
04:40:25 <EvilTerran> no...
04:40:30 <Heffalump> oh, no, whatever the &/? fixities say
04:40:35 <EvilTerran> exactly
04:40:39 <EvilTerran> (x & y ? z) = x & (y ? z)
04:40:46 <EvilTerran> i specified above :)
04:40:52 <int-e> (x & y ?) z = x & y ? z
04:40:59 <EvilTerran> int-e, indeed
04:41:11 <EvilTerran> a useful little equality to have, that one, IMO
04:41:25 <Heffalump> I think the splicing interpretation is very simple to understand.
04:41:37 <EvilTerran> and, as i mentioned earlier, that approach makes more sense for (x++y++), and extends to (++x++), and....
04:41:53 <EvilTerran> Heffalump, indeed, it boils down to what int-e just saifd
04:42:19 <Heffalump> once GHC plugins appear, perhaps it'll be easy to prototype..
04:42:53 <mjrosenb> aren't there things that let you transform the code pre compilation?
04:42:54 <bartwe> why does haskell have so much primary syntax ?
04:43:14 <Heffalump> mjrosenb: template haskell, but it has syntactic overhead
04:43:22 <mjrosenb> bartwe: you mean syntatic sugar?
04:43:23 <Heffalump> bartwe: it has very little compared to most languages
04:43:58 <mjrosenb> is perl :: foo.c -> foo.hs a good idea?
04:43:59 <bartwe> alot of discussions here are about what a bit of tokens means, and desugarring is rarely suggested
04:44:22 <Axman6> heh, running "last $ take 100000000000 [1..]" is a bad idea apparently
04:44:49 <Heffalump> Axman6: I think it works ok if you compile with -O2
04:44:52 <Heffalump> rather than using ghci
04:45:05 <Axman6> heh, fair enough
04:51:22 <povman> Axman6: A good optimisation on that would be "100000000000"
04:51:35 <Axman6> indeed
05:10:16 <gwern> @seen dons
05:10:16 <lambdabot> dons is in #arch-haskell, #xmonad, #ghc and #haskell. I last heard dons speak 7h 31m 48s ago.
05:11:11 <gwern> @tell dons yes, ztail and set look interesting. but you've already emailed him? then I won't step on your toes till he's replied and you have some plan of attack perhaps
05:11:11 <lambdabot> Consider it noted.
05:38:14 <plutonas_> how do i use Maybe to substitute another type?
05:38:21 <plutonas_> i tried Nothing
05:38:39 <plutonas_> and i tried (Just something-of-the-right-type)
05:38:43 <plutonas_> but nothing seems right
05:38:57 <dibblego> what do you mean by "substitute another type"?
05:38:59 <povman> plutonas_: what do you mean by 'substitute another type'?
05:39:00 <povman> lol
05:39:04 <dibblego> yeah that :)
05:39:27 <plutonas_> i am going through this online book
05:39:32 <plutonas_> and there is one exercise to make a tree
05:39:52 <plutonas_> the problem is that in the leafes the subtrees have to be null or emtpy or whatever
05:40:05 <plutonas_> but in general they have to be of type tree too
05:40:10 <plutonas_> i don't know if i state this clear enough
05:40:23 <drguildo> data Tree = ... | Null ?
05:40:33 <povman> data Tree a = Maybe a | Branch (Tree a) (Tree a)
05:40:34 <povman> ?
05:41:09 <plutonas_> povman: nope drguildo neither
05:41:18 <plutonas_> it sais i should construct Tree without |
05:41:45 <povman> oh.
05:41:46 <plutonas_> it's like this in the example in the book, but i should make it with only one constructor
05:42:08 <povman> type Tree = Maybe (Tree, Tree) ?
05:42:32 <ziman> newtype Tree a = Tree (Maybe (Tree a, Tree a)) ?
05:42:36 <Saizan> povman: type synonym can't be recursive
05:42:37 <plutonas_> oh i have to use maybe in the "data" definition? not when constructing nodes?
05:42:48 <povman> ziman: 'a' is useless there
05:43:06 <povman> plutonas_: data Tree = Tree (Maybe (Tree, Tree))
05:43:12 <plutonas_> povman: well there should also be an a, for the data in the node no?
05:43:23 <povman> then you get a tree _structure_ but no data contained in it
05:43:33 <plutonas_> hm
05:43:37 <Saizan> data Tree a = Branch a (Maybe (Tree a)) (Maybe (Tree a))
05:43:48 <plutonas_> just a sec
05:43:52 <ziman> plutonas_, yes, when constructing types you use *type* constructors (like, Maybe); when constructing data (values) you use *data* constructors (like Nothing, Just)
05:43:57 <Saizan> so, a leaf is Branch x Nothing Nothing
05:44:29 <plutonas_> Saizan: yes i think this is what i want, thanks
05:44:32 <ziman> data constructors construct values of the types constructed by the corresponding type constructors :)
05:44:53 <plutonas_> so maybe is used for "optional arguments)
05:44:55 <plutonas_> ?
05:45:03 <plutonas_> ziman: you confuse me
05:45:16 <Saizan> yes, it can be used like that
05:45:16 <ziman> plutonas_, think of it as a `nullable' value
05:45:56 <Saizan> however Maybe is not special in any way
05:46:03 <plutonas_> Saizan: yes but there is a problem in that line
05:46:09 <plutonas_> i can now construct nodes with this
05:46:17 <plutonas_> but not give constructed nodes as arguments
05:46:27 <plutonas_> for examlpe i make leftnode, rightnode
05:46:40 <Saizan> Branch 1 (Just leftnode) (Just rightnode)
05:46:41 <plutonas_> and then root = Branch 12 leftnode rightnode gives an error
05:46:46 <plutonas_> oh
05:47:25 <ziman> plutonas_, Maybe can contain either a value (Just value) or nothing (Nothing). Imagine you have an associative array. When looking up a key, the corresponding value may or may not exist. Therefore the lookup function should return Maybe value_type, so that when a value is found, it returns (Just value); if the value does not exist, it'll return Nothing.
05:48:06 <ziman> both (Just value, Nothing) still have the same type -- Maybe value_type
05:48:34 <povman> plutonas_: data Maybe a = Just a | Nothing
05:48:50 <povman> there's your |
05:48:58 * plutonas_ needs to think a bit
05:50:24 <plutonas_> i think i understand how it works now but still don't see the error
05:50:29 <plutonas_> just a sec
05:50:50 <plutonas_> ok
05:51:05 <plutonas_> the problem is that i defined rightchld = Branch 7
05:51:11 <plutonas_> and skipped the Nothings
05:51:28 <plutonas_> though i didn't get an error when doing this definition but when i wanted to define root using rightchld
05:51:31 <plutonas_> why?
05:51:55 <povman> plutonas_: because Branch is a function that takes a value and returns a function
05:52:21 <povman> plutonas_: namely,  Branch :: a -> Maybe a -> Maybe a -> Tree a
05:53:01 <povman> plutonas_: Branch 7 returns a function, which takes Maybe a as input and returns (Maybe a -> Tree a) as output
05:53:02 <Saizan> plutonas_: in haskell partially applying a function simply returns another function that takes the other arguments
05:53:26 <Shurique> echo -window 1 f
05:54:08 <povman> plutonas_: Branch 7 Nothing Nothing is equivalent to (((Branch 7) Nothing) Nothing)
05:54:16 <plutonas_> i see!
05:54:25 <plutonas_> thanks a lot, i really like this channel :)
05:54:39 <plutonas_> interesting approach though
05:54:51 <povman> plutonas_: it's called 'currying'
05:55:30 <dibblego> no, partial application (related to, but not same as currying)
05:55:42 <plutonas_> yes i guess it will be in a later chapter
05:55:48 <plutonas_> aha
05:58:36 <masak> dibblego: what's the difference between partial application and currying?
05:58:53 <Deewiant> ?ty curry
05:58:54 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
05:58:59 <Deewiant> that's currying
05:59:02 <Deewiant> ?ty (1+)
05:59:03 <lambdabot> forall t. (Num t) => t -> t
05:59:09 <Deewiant> that's partial application
05:59:42 <povman> it seems type classes can be used to represent mathematical structures, and datatypes for particular implementations of the structures
05:59:46 <Saizan> currying makes partial application nicer to use
06:00:46 <povman> which means that Map and Set ought to be typeclasses, not datatypes
06:02:01 <Deewiant> indeed, without currying you'd have to do something like:
06:02:06 <Deewiant> ?ty (\x -> uncurry (+) (1,x))
06:02:06 <lambdabot> forall a. (Num a) => a -> a
06:02:34 <Deewiant> which is kinda verbose (even without the 'uncurry', which would of course not be there if it were already uncurried)
06:03:09 <Saul__> What's the flag for existential types?
06:03:24 <povman> -XExistentialQuantification
06:04:03 <plutonas_> one more question because i think something is true but it's not clear in the book
06:04:09 <Saul__> povman: ok thanks
06:04:12 <plutonas_> in pattern matching x:xs for example
06:04:27 <plutonas_> if i only want to use xs, can i give just xs as an argument?
06:04:48 <povman> plutonas_: you can replace a variable name with _ if you don't want to match it
06:04:54 <povman> ie _:xs
06:05:56 <plutonas_> so giving just xs is not matching to everything but the rest of the list? it's just a variable like a b or whatever?
06:05:59 <povman> furthermore, in a@(x:xs) 'a' will represent the whole list
06:06:10 <plutonas_> and i could also do the x:xs matching using a:b for example, right?
06:06:25 <povman> yes
06:06:26 <Saizan> plutonas_: right
06:06:27 <plutonas_> povman: am not that far yet :)
06:06:31 <plutonas_> alright, thanks!
06:07:08 <povman> (just a hint :) i'm being too verbose because i'm procrastinating - bye
06:08:17 <plutonas_> hehe
06:19:57 <cinimod> @hoogle (Monad m, Monad n) => n (m a) -> m (n a)
06:19:58 <lambdabot> Prelude.id :: a -> a
06:19:58 <lambdabot> Unsafe.Coerce.unsafeCoerce :: a -> b
06:19:58 <lambdabot> Data.Function.id :: a -> a
06:25:32 <EvilTerran> cinimod, that's not possible in general
06:25:52 <EvilTerran> cinimod, however, if one of the Monads has extra constraints, it's possible
06:26:31 <EvilTerran> Data.Traversable.sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
06:26:52 <EvilTerran> or indeed Data.Traversable.sequence :: (Traversable t, Monad f) => t (f a) -> f (t a)
06:29:12 <EvilTerran> i imagine there's a more formal requirement than Traversable in category-extras
06:29:30 <cinimod> EvilTerran: yes one has to prove it exists so I'd expect it to belong to a typeclass
06:29:57 <cinimod> EvilTerran: in general you can compose two monads if you have a swap function
06:31:06 <cinimod> EvilTerran: do you think there is something in category-extras?
06:31:32 <EvilTerran> probably
06:31:34 <cinimod> EvilTerran: Data.Traversable.sequence looks promising
06:31:46 <EvilTerran> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/category-extras
06:31:53 <lambdabot> Title: HackageDB: category-extras-0.53.5, http://tinyurl.com/5leenf
06:32:44 <cinimod> There's a lot to search through in there
06:35:17 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/8744
06:35:32 <drguildo> can somebody please explain the last line of that to me
06:35:51 <drguildo> he seems to be passing two parameters to a function that only takes one
06:37:10 <int-e> drguildo: expand the StateT in (a -> StateT s b); you get (a -> s -> (b, s)) which takes two arguments
06:38:04 <drguildo> int-e, thanks
06:39:23 <drguildo> but wait
06:39:32 <drguildo> it's meant to return a StateT
06:39:38 <drguildo> thenST is
06:39:55 <drguildo> so you should only pass one parameter to f
06:39:58 <drguildo> to get the StateT?
06:40:43 <int-e> yes.
06:41:01 <int-e> remember that  f v s'  is  (f v) s'
06:43:01 <drguildo> but if that's the case
06:43:11 <drguildo> then it's applying a state transformer to a state transformer
06:43:15 <drguildo> which yields a tuple
06:43:20 <drguildo> which breaks the return type
06:43:38 <int-e> @type \s -> (2, s)
06:43:39 <lambdabot> forall t t1. (Num t1) => t -> (t1, t)
06:43:45 <drguildo> i meant applying a state transformer to a state
06:44:09 <int-e> drguildo: you missed the lambda. btw, it's not a state transformer, just the state monad.
06:44:14 <int-e> @src StateT
06:44:15 <lambdabot> Source not found. Maybe you made a typo?
06:45:22 <drguildo> oh yeah
06:45:43 <int-e> Control.Monad.State wraps this in a newtype, newtype State s a = State { runState :: s -> (a, s) }
07:19:18 <dolio> Man, extending a pure type system with a predicative tower is dead simple.
07:19:25 <dolio> (Same with lambda cube, I guess.)
07:31:17 <codacola> ok, haskell is confusing me
07:31:36 <codacola> learning about classes at the moment, and it gives "eq" as an example, but how does it make any sense?
07:31:41 <codacola> seems like circular logic to me....
07:32:49 <opqdonut> the definitions given in the class are "default implementations"
07:33:01 <opqdonut> the actual logic is hidden in the _instances_ of the class
07:33:14 <opqdonut> ?src Just (==)
07:33:14 <lambdabot> Source not found. I am sorry.
07:33:15 <Beelsebob> codacola: can you explain what seems circular to you?
07:33:18 <opqdonut> ?src Maybe (==)
07:33:18 <lambdabot> Source not found.
07:33:24 <opqdonut> ?src (==) Maybe
07:33:25 <lambdabot> Source not found. My mind is going. I can feel it.
07:33:29 <opqdonut> agh
07:33:42 <codacola>    x /= y     =  not (x == y)
07:33:42 <codacola>     x == y     =  not (x /= y)
07:33:46 <codacola> that seems circular...
07:33:46 <opqdonut> yeah
07:33:54 <Beelsebob> codacola: ah, okay
07:33:54 <kpreid> codacola: it is. instances override at least one
07:34:01 <jaj> codacola: you only have to define one so that the other is defined
07:34:04 <kpreid> codacola: definitions in classes are there as defaults
07:34:04 <Beelsebob> what that's saying is that "if you define one of them, the other one can be infered"
07:34:18 <Beelsebob> so in an instance, you may only defined (==), or only define (/=)
07:34:19 <codacola> ah
07:34:22 <Beelsebob> and you automatically get both
07:34:26 <codacola> so the other is defined elsewhere over those types?
07:34:39 <Beelsebob> the other one is defined by those default equations
07:34:43 <kpreid> @src Maybe ==
07:34:44 <lambdabot> Source not found. My brain just exploded
07:34:51 <jaj> codacola: yes in your instance
07:34:59 <Beelsebob> so if you define (==), you'll get (/=) defined automatically as not (==)
07:35:33 <ziman> opqdonut, Maybe is in Eq by `deriving'
07:35:47 <ziman> so there's no source to be displayed
07:36:41 <jaj> @src [] (==)
07:36:41 <lambdabot> []     == []     = True
07:36:41 <lambdabot> (x:xs) == (y:ys) = x == y && xs == ys
07:36:41 <lambdabot> _      == _        = False
07:37:37 <jaj> @src [] (/=)
07:37:37 <lambdabot> Source not found. It can only be attributed to human error.
07:38:05 <jaj> so only (==) is defined and (/=) is inferred as not (==)
07:38:07 <Saad_> Is there an extension to the deriving mechanism that allows for deriving instances of non-Haskell-98 constructors?
07:38:10 <lxuser> dolio, any pointers?
07:50:08 <EvilTerran> ?where Derive
07:50:08 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/derive
07:50:24 <EvilTerran> Saad_, you can use Derive, or TH, or there's a few others
07:50:27 <EvilTerran> ?where th
07:50:28 <lambdabot> http://www.haskell.org/th
07:51:22 <dolio> lxuser: On what? I used augustss' blog on implementing the lambda cube to make sure I was doing things right. It's pretty good.
07:51:22 <EvilTerran> also, if you use the GHC extension to derive (Typeable, Data), you can use the Data instance to write a generic version of what would otherwise be a class method
07:51:26 <EvilTerran> ?where SYB
07:51:26 <lambdabot> http://www.cs.vu.nl/boilerplate
07:51:42 <Saad_> Thanks EvilTerran
07:52:39 <dolio> lxuser: A pure type system is parameterized by a set of sorts, axioms for what constants have what sorts, and rules for determining the sort of a function space between two sorts, though.
07:53:31 <dolio> So at that point, going from lambda cube to predicative tower is just replacing 'data Sort = Star | Box' with 'data Sort = Set Integer' and redoing the two functions.
07:54:24 <dolio> 'axiom Star = Box ; axiom Box = error "Box"' ==> 'axiom (Set n) = Set (n + 1)'
07:55:00 <dolio> space Star Star = Star ; ...  ==> space (Set m) (Set n) = Set (max n m)
08:10:07 <codacola> ok think i understand now. one of the 2 functions is defined for that type. then both are defined in the class so that only 1 needs to be defined. then instances can override the version defined inside the class?
08:11:06 <dolio> Yes.
08:11:10 <codacola> yay
08:11:15 * codacola pats himself on the back
08:11:27 <dolio> And if you leave them both blank, it loops.
08:11:48 <codacola> always a wonderful thing
08:12:04 <codacola> at 3am it is anyways :P
08:28:43 <mjrosenb> @hoogle (a -> Either b c) -> [a] -> ([b],[c])
08:28:46 <lambdabot> No matches, try a more general search
08:28:50 <mjrosenb> :(
08:29:24 <opqdonut> :t partition
08:29:25 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
08:29:33 <opqdonut> and then map
08:29:45 <mjrosenb> opqdonut: 'tis what i'm doing
08:30:25 <EvilTerran> :t \f -> partition (const True `either` const False) . map f
08:30:26 <lambdabot> forall a b a1. (a1 -> Either a b) -> [a1] -> ([Either a b], [Either a b])
08:30:34 <EvilTerran> ehh
08:30:41 <opqdonut> :t mapEither
08:30:42 <lambdabot> Not in scope: `mapEither'
08:30:47 <EvilTerran> :t \f -> (fromLeft *** fromRight) . partition (const True `either` const False) . map f
08:30:48 <opqdonut> :t Data.Map.mapEither
08:30:49 <lambdabot> Not in scope: `fromLeft'
08:30:49 <lambdabot> Not in scope: `fromRight'
08:30:49 <lambdabot> forall a b c k. (Ord k) => (a -> Either b c) -> M.Map k a -> (M.Map k b, M.Map k c)
08:30:59 <opqdonut> mjrosenb: ^^ that's what you want but for maps
08:31:04 <EvilTerran> ?hoogle mapEither
08:31:04 <lambdabot> Data.Map.mapEither :: Ord k => (a -> Either b c) -> Map k a -> (Map k b, Map k c)
08:31:04 <lambdabot> Data.IntMap.mapEither :: (a -> Either b c) -> IntMap a -> (IntMap b, IntMap c)
08:31:04 <lambdabot> Data.Map.mapEitherWithKey :: Ord k => (k -> a -> Either b c) -> Map k a -> (Map k b, Map k c)
08:31:09 <opqdonut> yeah
08:31:23 <EvilTerran> i'd be inclined to write your own, tbh
08:31:36 <mjrosenb> ja
08:31:38 <EvilTerran> niether mapping then partitioning or partitioning then mapping is entirely satisfactory
08:32:20 <mjrosenb> partitioning than mapping seems to do the trick
08:33:08 <Saizan> ?ty \f ->  foldr (\a -> either (first . (:)) (second . (:))) ([],[]) . map f
08:33:09 <lambdabot>     Couldn't match expected type `Either' against inferred type `(->)'
08:33:09 <lambdabot>     Probable cause: `either' is applied to too few arguments
08:33:09 <lambdabot>     In the expression: either (first . (:)) (second . (:))
08:33:12 <EvilTerran> ?type \f -> foldr (either (first.(:)) (second.(:)) . f) ([],[])
08:33:14 <lambdabot> forall a b a1. (a1 -> Either a b) -> [a1] -> ([a], [b])
08:33:31 <dolio> I think there's an [Either a b] -> ([a],[b]) coming in some new version of base.
08:33:37 <dolio> I forget what it's called, though.
08:33:57 <Saizan> ?ty \f ->  foldr (either (first . (:)) (second . (:))) ([],[]) . map f
08:33:58 <lambdabot> forall a b a1. (a1 -> Either a b) -> [a1] -> ([a], [b])
08:34:19 <EvilTerran> ?type foldr (first.(:) `either` second.(:)) ([],[]) -- this kinda thing, dolio?
08:34:20 <lambdabot>     precedence parsing error
08:34:20 <lambdabot>         cannot mix `(.)' [infixr 9] and `either' [infixl 9] in the same infix expression
08:34:20 <lambdabot>     precedence parsing error
08:34:23 <EvilTerran> ach
08:34:38 <EvilTerran> ?type foldr (either (first.(:)) (second.(:))) ([],[])
08:34:39 <lambdabot> forall a b. [Either a b] -> ([a], [b])
08:34:53 <dolio> EvilTerran: Yeah.
08:35:29 <dolio> There were lots of proposed names and I can't remember which one was chosen.
08:35:50 <dolio> I liked demux, but i think most people thought it was too non-specific.
08:36:14 <dmhouse> ?hoogle lefts
08:36:14 <lambdabot> Language.Haskell.Syntax.HsLeftSection :: HsExp -> HsQOp -> HsExp
08:36:29 <dmhouse> Okay, that must have been one I wrote myself/
08:36:43 <EvilTerran> dolio, hm, that name reminds me of "reify"
08:36:54 <EvilTerran> in a "it's not very self-explanatory" kinda way
08:37:07 <dolio> Heh.
08:37:09 <EvilTerran> also "intercalate", altho that's fairly intuitive from the type
08:37:21 <EvilTerran> ?type intercalate
08:37:22 <lambdabot> forall a. [a] -> [[a]] -> [a]
08:39:18 <dolio> demux makes some sense if you think of [Either a b] as two separate streams of data sent over one channel.
08:41:43 <dolio> Heh, "boths" is pretty good, too.
08:42:20 <dolio> Looks like the final result was partitionEithers.
09:00:38 <hpaste>  Saul_ pasted "This won't compile :S" at http://hpaste.org/8745
09:00:59 <Saul__> The code I pasted doesn't compile, but I'm not sure why
09:01:27 <vixey> What happened when you tried to compile it ?
09:01:28 <Saul__> it seems that the gName and gUrl functions are too specific, but I'm not sure why that is a problem
09:01:47 <tusho> Saul_:
09:01:48 <tusho> type SqlMap a = [(String, forall b. (SqlBind b) => a -> b)]
09:01:53 <tusho> they need to be able to return any b
09:01:59 <tusho> that is SqlBind
09:02:09 <tusho> 'String' is not any b that has a SqlBind instance.
09:02:14 <tusho> It's 'String'
09:02:22 <Saul__> Oh I see
09:02:33 <Saul__> How do I do what I intend?
09:02:58 <Saul__> Or is it impossible?
09:03:14 <vixey> why don't you write type SqlMap a b = [(String,a -> b)]
09:03:21 <tusho> vixey++
09:03:37 <vixey> then list could be :: SqlBind b => SqlMap Game b
09:03:54 <vixey> (but I would let the compiler figure it out, you don't have to put the annotation down)
09:04:14 <Saul__> Will that work with different types though
09:04:29 <Saul__> In this instance they are both strings, but that is not generally the case
09:04:44 <vixey> > [635,"foo"]
09:04:46 <lambdabot>   add an instance declaration for (Num [Char])
09:04:46 <lambdabot>     In the expression: 635
09:04:46 <lambdabot>    ...
09:04:55 <vixey> > [Left 635,Right "foo"]
09:04:57 <lambdabot>  [Left 635,Right "foo"]
09:04:58 <vixey> :t [Left 635,Right "foo"]
09:04:58 <lambdabot> forall t. (Num t) => [Either t [Char]]
09:05:15 <Saul__> that kind of misses the point
09:05:36 <Saul__> I just want a list of selectors on my datatype that map to SqlBindable values
09:05:46 <Saul__> so I can then put it in a database row
09:05:49 <Taggnostr> can I use .. only inside a list for doing [a..], [a..b], [..b] or are there other situation where I can use it?
09:05:52 <HunterXHunter2> > [Right "foo",Left 635]
09:05:54 <lambdabot>  [Right "foo",Left 635]
09:06:27 <Saul__> Taggnostr: As far as I know only in lists
09:07:47 <hpaste>  Saul__ annotated "This won't compile :S" with "Extended example" at http://hpaste.org/8745#a1
09:08:01 <Saul__> vixey: I've extended my example a little
09:08:18 <Taggnostr> > [..3]
09:08:18 <lambdabot>  Parse error at "..3]" (column 2)
09:08:29 <Taggnostr> > [3..]
09:08:31 <lambdabot>  [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,3...
09:08:36 <vixey> > reverse [3..]
09:08:39 <lambdabot>  Tried to use too much memory
09:08:54 <vixey> Saul__: Instead of using a type class why not define
09:08:56 <HunterXHunter2> > sum [3..]
09:08:58 <Taggnostr> so only [a..b] and [a..] work?
09:09:01 <lambdabot>  Tried to use too much memory
09:09:10 <joey__> > [1, 3..]
09:09:12 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
09:09:19 <vixey> data SQLMap =  SQLString String | SQLRef (Ref Developer) | ...
09:09:30 <joey__> > [1, 3, 11]
09:09:33 <lambdabot>  [1,3,11]
09:09:34 <joey__> > [1, 3..11]
09:09:36 <lambdabot>  [1,3,5,7,9,11]
09:10:03 <joey__> As far as I'm aware, it's just sugar for the "enumFrom" family of functions
09:10:32 <ski> > [1,3..10]
09:10:34 <lambdabot>  [1,3,5,7,9]
09:10:35 <lambdabot> ski: You have 1 new message. '/msg lambdabot @messages' to read it.
09:10:36 <Saul__> vixey: The type class is part of the HSQL library, so I think I should use that
09:10:44 <ski> @messages
09:10:45 <lambdabot> Kamina said 2m 4d 4h 22m 27s ago: I don't agree: Having something of type Maybe (exists a. a) would be useful, you can typecast it to anything, because it can be every type. (Like you can convert
09:10:45 <lambdabot> read "5" to every type being of the "Read" class)
09:10:48 <Taggnostr> > [0, 5..10, 15..20]
09:10:48 <lambdabot>  Parse error at "," (column 10)
09:11:01 <vixey> ok I don't know about HSQL
09:11:08 <ski> lambdabot : *sigh* i've already seen this message two times. why do you insist on repeating it ?
09:11:31 <HunterXHunter2> @bot
09:11:32 <lambdabot> :)
09:12:07 <Saul__> vixey: Besides, the function I want gives a dictionary for each table column to a selector to be used in getting the string representation of the corresponding value
09:12:25 <Saul__> vixey: So that datatype isn't exactly handy
09:12:47 <Saul__> vixey: Game is not the only datatype I will use it with, and most will contain more fields
09:14:05 <enoksrd> I think I found some errors in http://www.haskell.org/tutorial/
09:14:06 <lambdabot> Title: A Gentle Introduction to Haskell, Version 98
09:14:10 <hesselink> Saul__: I think you want an existential datatype
09:14:15 <hesselink> like on http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types
09:14:17 <lambdabot> http://tinyurl.com/f9umb
09:14:31 <enoksrd> Is there a list of errors for the document somewhere?
09:14:46 <Taggnostr> are listcomps an haskell thing or they "copied" it from some other language?
09:15:13 <ddarius> Taggnostr: They are not original in Haskell.
09:15:23 <Saul__> hesselink: Yeah those were what I was looking for, thanks Erik
09:15:31 <joey`> Taggnostr: Haskell "copied" them from mathematics :P
09:15:35 <vixey> Taggnostr: lots of languages have them, it probably originates from notation people use when writing maths
09:15:48 <vixey> { x | x < 3 }
09:16:13 <Taggnostr> yes, but is the first language that actually used them?
09:16:19 <ddarius> Miranda had list comprehensions, but that's reasonable.  SETL I believe is the earliest language to have a similar notation.  Obviously it arises from set comprehension notation from set theory.
09:16:20 <Armored_Azrael> Hey, does anyone here know a good place to find texts on introductory category theory?
09:16:24 <opqdonut> yeah [ x |x <- ys ] is kinda like { x |x \in ys }:)
09:16:43 <Taggnostr> ok
09:18:44 <ddarius> http://www.cs.le.ac.uk/people/akurz/books.html
09:18:45 <lambdabot> Title: Electronically Available Books and Other Sources (mainly Category Theory)
09:18:54 <Armored_Azrael> ddarius: thanks
09:20:14 <nominolo> @djinn \s' a -> k s' (f a)
09:20:14 <lambdabot> Cannot parse command
09:20:34 <nominolo> @pl \s' a -> k s' (f a)
09:20:34 <lambdabot> (. f) . k
09:26:06 <baaba> is there a sort of null parser for parsec that always fails?
09:27:06 <baaba> i want to combine a bunch of parsers with foldl and <|> and i'd like to use a parser that always fails for the initial value
09:27:08 <ddarius> fail
09:27:30 <ddarius> or mzero (or empty with parsec3)
09:27:37 <baaba> thanks
09:27:38 <vixey> :t foldl1
09:27:40 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
09:27:52 <ddarius> Also, msum/choice will already combine a bunch of parsers like that.
09:27:56 <baaba> yeah i looked at foldl1 but they're not the same type
09:28:22 <baaba> like i have a foo :: Char -> Parser Bar
09:28:49 <baaba> and i want to have a list ['a', 'b', 'c'] etc and then get a result (foo 'a') <|> (foo 'b') <|> (foo 'c')
09:29:24 <ddarius> That would be just choice . map foo
09:29:52 <baaba> okay
09:34:54 <scodil> how come (+5) and (:[]) parse but (,x) doesn't?
09:35:11 <Riastradh> Because commas aren't ordinary infix operators.
09:35:30 <scodil> that's crap. So i have to do (flip (,) x) ?
09:35:31 <vixey> you can write (flip (,) x)
09:35:39 <Riastradh> flip (,) x     will work, though -- but it's not much of an improvement over (\y -> (y, x))
09:35:41 <vixey> no
09:35:53 <vixey> (~::) = (,)
09:35:55 <scodil> ok thanks
09:35:58 <vixey> (~:: x)
09:35:59 <scodil> wait what?
09:36:13 <vixey> you can define new infix operators in haskell
09:36:24 <Riastradh> (For that matter, I think (\y -> (y, x)) is much, much clearer than flip (,) x.)
09:36:25 <ddarius> vixey: That's a horrible name for that.
09:36:33 <vixey> then use those as sections
09:37:59 <vixey> > let (×) = (,) in (× "lambda bot sucks) 7
09:37:59 <lambdabot> Unbalanced parentheses
09:38:05 <vixey> > let (×) = (,) in (× "lambda bot sucks") 7
09:38:05 <lambdabot>  Illegal character ''\151''
09:38:05 <lambdabot>  at ")" (column 7)
09:38:19 <ddarius> You don't need unicode to get a better name than ~::
09:38:36 <scodil> > let (x) = (,) in (`x` "lambdabot rules") 7
09:38:39 <lambdabot>  (7,"lambdabot rules")
09:38:53 <vixey> × works in GHCi
09:39:02 <vixey> I see no reason why lambdabot can't handle it
09:39:07 <scodil> oh I can't tell the difference with this font
09:39:23 <monochrom> <3 $haskell
09:39:25 <scodil> I thought you were typing the 7-bit ascii 'x'
09:39:28 <monochrom> ha$kell :)
09:39:58 <monochrom> haskell × libs = $  :)
09:41:10 <HunterXHunter2> haskell != m$
09:42:34 <dogbite> hi all.  there was a popular blog post a couple weeks back describing using tagsoup and other tools.
09:42:39 <dogbite> it was a bit of a tutorial walk-through
09:42:50 <dogbite> can anybody remember what that was?
09:43:01 <ddarius> @google Neil Mitchell tagsoup
09:43:03 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/tagsoup/
09:43:03 <lambdabot> Title: Neil Mitchell - TagSoup
09:44:07 <dogbite> nope, that's not it
09:44:19 <ddarius> dogbite: That links to several blog posts by ndm.
09:44:20 <dogbite> the person was writing about a collection of packages
09:44:46 <dogbite> ddarius: i quickly looked through his posts over the past couple months and didn't see it
09:44:56 <ddarius> @where planet
09:44:56 <lambdabot> I know nothing about planet.
09:45:12 <ddarius> @where+ planet http://planet.haskell.org/
09:45:13 <lambdabot> It is forever etched in my memory.
09:45:57 <dogbite> is there any way to access planet haskell's history?
09:46:00 <dogbite> i think that's where i read it
09:46:09 <ddarius> http://www.cse.unsw.edu.au/~dons/blog/2008/06/24#daily-haskell-one
09:46:14 <lambdabot> Title: Haskell hacking, http://tinyurl.com/6dhftc
09:46:38 <dogbite> ddarius: yes, that's it!
09:46:59 <dogbite> ddarius:  thanks a lot.
09:48:50 <dogbite> ddarius:  did you find it by searching the planet history?  is there a way to do that?
09:49:27 <gwern> he probably just googled
09:49:38 <gwern> dons's stuff ranks pretty hihg usuall
09:51:05 <dogbite> gwern: i tried the googles but i failed.  had to turn to a more skilled googler
09:51:16 <cinimod> @seen EvilTerran
09:51:16 <lambdabot> EvilTerran is in #haskell. I last heard EvilTerran speak 1h 13m 55s ago.
09:51:55 <vixey> I can't fix lambdabot because it doesn't even work for me :/
09:52:07 <gwern> vixey: what error are you seeing?
09:52:35 <ddarius> No, I just remembered dons writing something like that.
09:52:38 <vixey> when I go > 1 + 1 it says no such command OIES
09:53:00 <gwern> did you install oeis?
09:53:26 <gwern> should'e been a dep, iric
10:02:12 <vixey> I am just disappointed about it
10:02:19 <vixey> but it will take too long to try and fix
10:07:20 <EvilTerran> cinimod?
10:08:46 <cinimod> EvilTerran: Just to let you know I now have two options for swapping monads compiled although not yet tested.
10:09:04 <cinimod> It was an interesting exercise.
10:09:11 <EvilTerran> @paste ?
10:09:11 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:09:14 <EvilTerran> sounds interesting
10:09:38 <cinimod> I'll just tidy them up and paste them in a few minutes
10:12:37 <hpaste>  cinimod pasted "Commuting Monads" at http://hpaste.org/8746
10:15:23 <KucukMubasir> why is there more people there than lisp? :S
10:15:27 <KucukMubasir> *are
10:15:42 <EvilTerran> hm... that's weird, i'd've expected there to be Foldable and Traversable instances for Maybe, Either, etc in the libraries
10:15:42 <KucukMubasir> !paste
10:15:42 <hpaste> Haskell paste bin: http://hpaste.org/
10:16:10 <EvilTerran> ah, only Maybe and []. that's still strange. might suggest they add that.
10:16:22 <mapreduce> KucukMubasir: Haskell is more interesting than lisp.
10:16:28 <dmwit> KucukMubasir: Because we are ever oh so much more friendly! =)
10:16:33 <EvilTerran> cinimod, if you're only going to need it for Either, i'd go for your version
10:16:35 <KucukMubasir> in what respects?
10:16:50 <KucukMubasir> in what respects? mapreduce
10:16:55 <KucukMubasir> !haskell
10:17:00 <KucukMubasir> !lisp
10:17:11 <EvilTerran> cinimod, well, except using liftM instead of fmap to get rid of that ugly Functor constraint
10:17:24 <cinimod> EvilTerran: that was my thinking although I much prefer using libraries
10:17:28 <mapreduce> KucukMubasir: In that Haskell has a typesystem.
10:17:31 <cinimod> @type fmap
10:17:32 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:17:34 <EvilTerran> cinimod, thus saving you from writing the instance Functor BitGet, too
10:17:38 <cinimod> @type liftM
10:17:39 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
10:17:40 <paolino> KucukMubasir: maybe lisp is easier
10:17:55 <EvilTerran> although that's just "instance Functor BitGet where fmap = liftM"
10:17:56 <cinimod> Excellent suggestion
10:18:02 <EvilTerran> it's in Control.Monad
10:18:20 <cinimod> I think I already import it
10:18:22 <EvilTerran> yeah, it's nice to use libraries and abstractions when you can, but sometimes it's not really worth it
10:18:34 <EvilTerran> it's still an interesting academic question, mind
10:19:02 <EvilTerran> "what's the least constraint on monads m, n such that a function transpose :: m (n a) -> n (m a) is possible?"
10:19:05 <cinimod> Yep I import it so option 1 is the obvious choice
10:19:22 <dmwit> KucukMubasir: There's a lot of things I like about Haskell.  One is that it admits that sometimes syntax can be nice.  Another is the beautiful type system.  Dead-simple partial application is nice, too.  Type-system-enforced purity is a god-send for composition. etc, etc
10:19:22 <newsham> evilterran: isnt that Data.Traverse ?
10:19:49 <EvilTerran> newsham, Traversable works, but i can't help but feel there could be something more general
10:20:20 <cinimod> Interestingly if you have such a swap then you can compose the two monads to be a monad
10:20:31 <EvilTerran> i had a dig through category-extras looking for such a thing, but most of that's over my head, so i likely missed it if it is there
10:20:41 <newsham> ?type traverse
10:20:42 <lambdabot> Not in scope: `traverse'
10:20:49 <newsham> ?type Data.Traversable.traverse
10:20:50 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Applicative f, Data.Traversable.Traversable t) => (a -> f b) -> t a -> f (t b)
10:20:51 <cinimod> I had a dig too but I don't think it's there
10:21:06 <cinimod> ?type Data.Traversable.sequence
10:21:06 <EvilTerran> cinimod, i don't think the inner one needs to be traversable for that
10:21:07 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Monad m, Data.Traversable.Traversable t) => t (m a) -> m (t a)
10:21:12 <newsham> hmm.. not quite
10:21:22 <EvilTerran> consider monad transformers
10:21:25 <newsham> ahh, sequence
10:21:52 <EvilTerran> ?type Data.Traversable.sequenceA -- this is more general
10:21:52 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Applicative f, Data.Traversable.Traversable t) => t (f a) -> f (t a)
10:21:59 <cinimod> you can prove monad transformer are what they say either directly or by using the existence of a swap
10:22:38 <cinimod> It's all in Chapter 9 of Toposes, Triples and Theories
10:23:21 <paolino> KucukMubasir: I feel in a sea of interesting things, which many math people choose to concretize with haskell, so by induction ,it's a language of choice to learn more than programming
10:23:34 <cinimod> Perhaps traversable => swap => composition?
10:24:13 <cinimod> EvilTerran: I don't know if there are weaker conditions that imply composition. Is that what you are asking?
10:25:54 <cinimod> EvilTerran: Is a monad always traversable?
10:25:59 <EvilTerran> cinimod, i mean, weaker conditions that allow that swapping operation
10:26:14 <EvilTerran> monads aren't always traversable
10:26:26 <KucukMubasir> paolino, because math people  haskell, it has more to give  than others? why is it preferred by math guys? functionality? and for what do they prefer it, any application example?
10:26:45 <EvilTerran> "IO (m a) -> m (IO a)" is impossible, i believe
10:26:58 <cinimod> I also believe this
10:27:09 <EvilTerran> because the structure of the result of the IO (m a) action would escape the IO
10:27:34 <EvilTerran> however, it's possible that all traversable monads can be made into monad transformers, and vice-versa
10:27:43 <newsham> kucukmabasir: there are deeper theoretical underpinnings than some other languages, like, say perl, for example.
10:27:45 <cinimod> Sorry I misread the type signature for sequenceA - of course a monad is applicative so it is more general
10:28:09 <EvilTerran> cinimod> you can prove monad transformer are what they say either directly or by using the existence of a swap <- ah, you said as much already
10:29:25 <dmwit> EvilTerran: As proof, consider m = Id. ;-)
10:29:36 <EvilTerran> dmwit, er, proof of what?
10:29:46 <EvilTerran> that "IO (m a) -> m (IO a)" is impossible?
10:29:50 <dmwit> IO (m a) -/> m (IO a)
10:29:50 <dmwit> yeah
10:29:52 <newsham> IO (Id a) -/-> Id (IO a)
10:29:53 <cinimod> EvilTerran: thanks for the input
10:29:56 <EvilTerran> i'd think Maybe would be a better example
10:30:06 <dmwit> Oh, actually, yeah, Id doesn't say much there.
10:30:09 <EvilTerran> 'cos you're not actually moving any information outside the IO if you use Id
10:30:14 <dmwit> right
10:30:24 <EvilTerran> cinimod, np, i find this sorta thing really interesting :)
10:30:31 <cinimod> ditto
10:31:04 <EvilTerran> i'm still wondering what category-theoretic constraint is required on the monad for swap to be possible
10:31:14 <EvilTerran> and, indeed, likewise for a transformer to be possible
10:31:58 <nolrai_East> what does local looklike on ((->) env)?
10:32:13 <monochrom> @type local
10:32:14 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
10:32:28 <EvilTerran> ?src (->) local
10:32:28 <lambdabot> local f m = m . f
10:32:37 <monochrom> m = ((->) env)
10:32:41 <nolrai_East> sweet.
10:32:51 <EvilTerran> ... i'm starting to suspect both are basically the same as the requirement for a traversable instance
10:33:01 <EvilTerran> it'll be a somethingmorphism or something
10:33:04 <EvilTerran> :P
10:33:11 <newsham> terranmorphism
10:33:11 <monochrom> (env -> env) -> (env -> a) -> (env -> a)
10:33:22 <EvilTerran> ?djinn (env -> env) -> (env -> a) -> (env -> a)
10:33:22 <lambdabot> f _ a b = a b
10:33:31 <EvilTerran> that's not helpful
10:33:32 <osfameron> zip12 !?
10:33:42 <EvilTerran> ?hoogle zip12
10:33:42 <lambdabot> No matches found
10:33:44 <dmwit> osfameron: I think it only goes up to zip7.
10:33:48 <monochrom> It is the same as the "hom functor"
10:33:56 <osfameron> there's an ML post now about it
10:34:08 <int-e> ?djinn (env1 -> env2) -> (env2 -> a) -> (env1 -> a)
10:34:08 <lambdabot> f a b c = b (a c)
10:34:16 <osfameron> isn't there a better way than zip3,zip4,zip5... ?
10:34:20 <EvilTerran> monochrom, what is, a traversable functor?
10:34:26 <EvilTerran> osfameron, yes, the ZipList applicative
10:34:32 <monochrom> local for ((->) env)
10:34:33 <nolrai_East> what file is the instance for MonadReader of (->) ?
10:34:38 <EvilTerran> osfameron, but, sadly, that's very clunky to use in haskell
10:34:43 <EvilTerran> ?hoogle ZipList
10:34:43 <lambdabot> Control.Applicative.ZipList :: newtype ZipList a
10:34:43 <lambdabot> Control.Applicative.ZipList :: [a] -> ZipList a
10:34:43 <lambdabot> Control.Applicative.getZipList :: ZipList a -> [a]
10:34:46 <osfameron> ah
10:34:48 <monochrom> It also happens to be fmap for ((->) env).
10:35:24 <osfameron> EvilTerran: shame - it's always surprising when haskell turns out to be clunky at certain types of abstraction/combination
10:35:27 <EvilTerran> > getZipList ((,,,) <$> ZipList [1..] <*> ZipList "abracadabra" <*> ZipList (cycle [False ..])
10:35:28 <lambdabot> Unbalanced parentheses
10:35:35 <EvilTerran> > getZipList ((,,) <$> ZipList [1..] <*> ZipList "abracadabra" <*> ZipList (cycle [False ..]))
10:35:36 <lambdabot>  [(1,'a',False),(2,'b',True),(3,'r',False),(4,'a',True),(5,'c',False),(6,'a',...
10:35:48 <osfameron> that *is* rather horrible
10:35:56 <newsham> > getZipList $ (+) <$> ZipList [1,2,3] <*> ZipList [10,20,30]
10:35:57 <lambdabot>  [11,22,33]
10:36:07 <EvilTerran> osfameron, yeah. in this case, it's because the other Applicative instance for [] is more generally useful
10:36:15 <EvilTerran> and works well with the Monad instance
10:36:39 <osfameron> having to specify (,,,,) with right number of commas is pretty yucky too
10:36:53 <marek_> hello there
10:36:56 <newsham> > (+) <$> [1,2,3] <*> [10,20,30]
10:36:57 <lambdabot>  [11,21,31,12,22,32,13,23,33]
10:36:59 <EvilTerran> well, you're stuck with that given our n-ary tuples arrangement
10:37:27 <EvilTerran> if we represented n-tuples as nested pairs, you could possibly do something horrible with typeclasses
10:37:40 <newsham> i often wonder why they didnt go that route
10:37:44 <newsham> isabelle uses nested pairs
10:37:50 <marek_> can anybody help me installing gtk2hs ? i'm having some problems with this
10:37:56 <EvilTerran> i'd use nested pairs, given the right syntactic sugar
10:38:12 <EvilTerran> (so i could still write (a,b,c,d,e))
10:38:23 <newsham> *nod* thats how it works in isabelle
10:38:42 <EvilTerran> "infixr :&; data x :& xs = x :& xs"
10:38:53 <ddarius> EvilTerran: Usually, in category theory, to allow m (n a) -> n (m a) one adds what is called a distributive law, but that's kind of a cop-out as a distributive law is a natural transformation of exactly that type.
10:38:53 <EvilTerran> (a :& b :& :c :& ())
10:39:16 <ddarius> That said, there are a lot of nice relationships between distributive laws and other parts of category theory.
10:39:16 <EvilTerran> ddarius, ah, ok. so that's basically the same as throwing a Traversable instance at the problem?
10:39:17 <newsham> et: why bother with :& () ?
10:39:31 <EvilTerran> newsham, eh, for consistency, as much as anything
10:39:38 <EvilTerran> makes it kinda like a heterogeneous list
10:39:45 <EvilTerran> allows more magic with functions that take n-tuples
10:40:02 <ddarius> EvilTerran doesn't want to upset the Lisp people with improper lists.
10:40:12 <EvilTerran> lets you distinguish between (a,(b,c)) and (a,b,c)
10:40:16 <mapreduce> How do you write a function that takes an n-tuple?
10:40:49 <EvilTerran> mapreduce, you can't in haskell. we're just hypothesising about how we would in another language
10:41:00 <EvilTerran> you can mock up something with Data.Generics or TH
10:41:18 <mapreduce> I see.
10:41:25 <ddarius> > id (1,2)
10:41:26 <lambdabot>  (1,2)
10:41:28 <ddarius> > id (3,4,5)
10:41:30 <lambdabot>  (3,4,5)
10:42:34 <newsham> > id id id id id (1,2)
10:42:35 <lambdabot>  (1,2)
10:42:45 <mapreduce> Sure, but id can take things other than n-tuples too. :)
10:42:56 <osfameron> does the value of an infinite sequence of ids eventually converge to id? ;-)
10:43:16 <dmhouse> Trivially. (id )* = id.
10:43:21 <newsham> > fix id :: (Int, String, IO ())
10:43:33 <dmhouse> So it converges to id in the same sense that 1,1,1,1... converges to 1.
10:43:36 <lambdabot>  thread killed
10:43:50 <newsham> they killed my thread.
10:43:56 <dmhouse> > fix id 4
10:44:11 <lambdabot>  thread killed
10:44:26 <newsham> > fix $ id 4
10:44:27 <lambdabot>   add an instance declaration for (Num (a -> a))
10:44:29 <int-e> . o O ( "error: id isn't broken." )
10:44:34 <dmhouse> Boo for struct functions.
10:46:36 <colonthree> DCC SEND "startkeylogger" 0 0 0
10:47:14 <newsham> ?type fix id :: IO (Maybe a) -> Maybe (IO a)
10:47:15 <lambdabot> forall a. IO (Maybe a) -> Maybe (IO a)
10:47:46 <Deewiant> ?type error "not an error" :: IO (Maybe a) -> Maybe (IO a)
10:47:47 <lambdabot> forall a. IO (Maybe a) -> Maybe (IO a)
10:51:33 <nolrai_East> I want to go from "b -> env -> Mytype a" to "env -> Mytype (b -> a)" but presurve how b changes the intepretation of env. Is this doable?
10:55:26 <noecksit> @type pure
10:55:27 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
10:55:40 <noecksit> @type <*>
10:55:41 <lambdabot> parse error on input `<*>'
10:55:48 <noecksit> @type (<*>)
10:55:49 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
10:56:04 <ziman> :t (<$>)
10:56:05 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:56:28 <nolrai_East> is that last one the one i want?
10:57:04 <noecksit> i think so
10:57:36 <nolrai_East> @hoogle <$>
10:57:36 <lambdabot> Control.Applicative.(<$>) :: Functor f => (a -> b) -> f a -> f b
10:58:06 <noecksit> it acts like map, however it works for anything that is a functor
10:58:45 <noecksit> > (*2) <$> Just 2
10:58:46 <lambdabot>  Just 4
10:58:49 <nolrai_East> hmm
10:59:15 <noecksit> > (*2) <$> [2] -- equivalent to map
10:59:17 <lambdabot>  [4]
11:01:20 <kiris> hey dons
11:02:20 <nolrai_East> @hoogle (a -> m b) -> m ( a -> b)
11:02:21 <lambdabot> Data.Function.fix :: (a -> a) -> a
11:02:21 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
11:02:21 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
11:08:55 <ski> nolrai_East : no
11:09:07 <nolrai_East> :t liftM (return) . flip . liftM head
11:09:08 <lambdabot> forall (m :: * -> *) a b c. (Monad m) => (a -> [b -> c]) -> b -> m (a -> c)
11:09:28 <nolrai_East> ski: yeah its more complex.
11:10:45 <nolrai_East> "liftM wrap . flip . liftm unwrap" looks like the right type.
11:11:06 <ski> nolrai_East> :t wrap
11:13:27 <nolrai_East> wrap :: a -> MyType a, unwrap :: MyType a -> a
11:16:13 <nolrai_East> the join/left messages drown out the conversations.
11:16:37 <ski> @type let wrap = Just; unwrap = fromJust in liftM wrap . flip . liftM unwrap
11:16:38 <lambdabot> forall a b c. (a -> Maybe (b -> c)) -> b -> Maybe (a -> c)
11:17:15 <ski> nolrai_East : does it scare you ?
11:18:13 <nolrai_East> Its getting closer.
11:19:09 <macondo> What do you think about this? divs n = [ x | x <- (reverse [(-1),(-2)..(-n)] ++ [1..n]), n `mod` x == 0]
11:20:10 <macondo> > let divs n = [ x | x <- (reverse [(-1),(-2)..(-n)] ++ [1..n]), n `mod` x == 0] in divs 8
11:20:12 <lambdabot>  [-8,-4,-2,-1,1,2,4,8]
11:20:29 <ski> > let divs n = [ x | x <- (reverse [(-1),(-2)..(-n)] ++ [1..n]), n `mod` x == 0] in divs (-12)
11:20:31 <lambdabot>  []
11:20:39 <ski> > let divs n = [ x | x <- (reverse [(-1),(-2)..(-n)] ++ [1..n]), n `mod` x == 0] in divs 0
11:20:41 <lambdabot>  []
11:21:06 <ski> maybe that's outside your precondition's, though ?
11:21:13 <ski> s/'//
11:21:47 <macondo> ski: no, using negative inputs is important. What would the fix be?
11:22:09 <macondo> ski: I know!
11:22:14 <ski> (:
11:23:10 <ski> (helping-by-saying-nothing seems like a useful technique to apply, sometimes)
11:25:05 <ski> macondo : but really, the integer divisors of zero should be every integer
11:27:19 <dmwit> > let double xs = reverse xs ++ xs; divs' n = [x | x <- [1..n], n `mod` x == 0]; divs = double . divs' . abs in divs (-12)
11:27:21 <lambdabot>  [12,6,4,3,2,1,1,2,3,4,6,12]
11:27:32 <dmwit> almost
11:27:32 <macondo> > let divs n = [ x | x <- (reverse (enumFrom (-n) (-1)) ++ [1..n]), n `mod` x == 0] where n = abs n in divs (-8)
11:27:33 <lambdabot>  Couldn't match expected type `a1 -> [a]'
11:27:51 <dmwit> > let double xs = (map negate $ reverse xs) ++ xs; divs' n = [x | x <- [1..n], n `mod` x == 0]; divs = double . divs' . abs in divs (-12)
11:27:53 <lambdabot>  [-12,-6,-4,-3,-2,-1,1,2,3,4,6,12]
11:28:08 <nolrai_East> @hoogle (a -> m b) -> m (a -> b)
11:28:08 <lambdabot> Data.Function.fix :: (a -> a) -> a
11:28:08 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
11:28:08 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
11:28:34 <macondo> what's the problem with my 'where' clause?
11:28:46 <ski> dmwit : now make it right for `0', too ..
11:29:05 <dmwit> macondo: You want enumFromThenTo, which takes 3 arguments.
11:29:21 <dmwit> macondo: Sorry, enumFromTo, which takes 2 arguments.
11:29:40 <macondo> > let divs n = [ x | x <- (reverse (enumFromTo (-n) (-1)) ++ [1..n]), n `mod` x == 0] where n = abs n in divs (-8)
11:29:43 <dmwit> ski: An easy special case, not very interesting.
11:29:55 <lambdabot>  thread killed
11:30:14 <int-e> n = abs n  is not a good idea
11:30:17 <macondo> Wow, thread killed are the divisors of (-8)
11:30:26 <dmwit> int-e++
11:30:45 <ski> > let n = abs n in n
11:31:01 <lambdabot>  thread killed
11:31:16 <dmwit> > let divs n = filter (liftM2 (&&) (== 0) ((== 0) . mod n)) [-abs n..abs n] in divs (-8)
11:31:17 <lambdabot>  Exception: divide by zero
11:31:22 <ski> dmwit : well .. macondo hasn't said if ordering is important
11:31:26 <dmwit> > let divs n = filter (liftM2 (&&) (/= 0) ((== 0) . mod n)) [-abs n..abs n] in divs (-8)
11:31:28 <lambdabot>  [-8,-4,-2,-1,1,2,4,8]
11:31:56 <macondo> That's counternaïve, dmwit
11:32:07 <dmwit> counternaive?
11:32:21 <Botje> counterintuitive, perhaps?
11:33:15 <macondo> > let divs n = filter (liftM2 (&&) (/= 0) ((== 0) . mod n)) [-abs n..abs n] in divs 0
11:33:16 <lambdabot>  []
11:33:17 <nolrai_East> perhaps counter-naive-intuition.
11:33:46 <int-e> > let divs n = filter (ap ((==).abs) (gcd n)) [-abs n..abs n] in divs (-8)
11:33:49 <lambdabot>  [-8,-4,-2,-1,1,2,4,8]
11:34:00 <int-e> (scnr)
11:34:15 <dmwit> beautiful
11:34:34 <macondo> @src ap
11:34:34 <lambdabot> ap = liftM2 id
11:34:38 <ski> `scnr' ?
11:34:49 <nolrai_East> Is it posible to go from (a -> b -> M c) to (a -> M (b -> c))?
11:34:56 <int-e> ski: sorry, could not resist
11:35:12 <opqdonut> no
11:35:17 <opqdonut> nolrai_East: no
11:35:21 <ski> nolrai_East : for every monad `M', and every `a',`b',`c', no
11:35:28 <ski> int-e : what does it mean ?
11:35:38 <nolrai_East> oh m not a monad.
11:35:57 <ski> then what ?
11:36:01 <nolrai_East> is there a M that it is posible for?
11:36:07 <opqdonut> nolrai_East: you see, "b -> M c" can be 'impure' but the b->c in M(b->c) has to be pure
11:36:17 <opqdonut> nolrai_East: well sure it's possible for, say, M = Id
11:36:31 <ski> nolrai_East : yes .. e.g. `type M a = Void'
11:36:39 <nolrai_East> its a wraper type.
11:36:40 <opqdonut> (the former comment was still discussing the monad case)
11:37:07 <int-e> ski: that question is a bit hard to answer without mocking you. :) s=sorry, etc.
11:37:52 <ski> int-e : ok, ty
11:38:53 <scodil> is there a function like "f p x = if p x then return x else mzero" ? Basically guard with return () replaced by mzero?
11:38:54 <ski> nolrai_East : is `M a' isomorphic to `a', for every `a' ?
11:40:03 <int-e> @src guard
11:40:03 <lambdabot> guard True  =  return ()
11:40:03 <lambdabot> guard False =  mzero
11:40:12 <scodil> ok not quite the same
11:40:13 <nolrai_East> ski: yes!
11:40:33 <opqdonut> ski: can you see any nontrivial M for which that holds, btw?
11:40:42 <opqdonut> er, for which such a function exists
11:40:45 <dmwit> ensure p x = guard (p x) >> return x -- scodil: I use this all the time
11:40:50 <ski> nolrai_East : then, given the isomorphism, of course you can convert between those two
11:41:50 <scodil> dmwit: yeah I do something similar. was wondering if it was in a lib somewhere
11:42:03 <dmwit> Well, it's in module Dmwit. ;-)
11:42:12 <ski> opqdonut : maybe `M' as `Stream' satisfy you ?
11:42:38 <opqdonut> hmm, yeah
11:42:52 <nolrai_East> ok, thats what my intuition was telling me.  now i just need to figure out how.
11:43:34 <dogbite> can somebody please suggest what I should do to get rid of this warning
11:43:35 <dogbite> Warning: No 'build-type' specified. If you do not need a custom Setup.hs or
11:43:57 <dmwit> Edit your cabal file.
11:43:58 <dogbite> should i put "build-type: Simple" in my cabal file?
11:44:05 <dmwit> yep
11:44:07 <dogbite> k
11:44:27 <opqdonut> nolrai_East: maybe "f x = \a -> in ( out . x a )" ?
11:44:39 <opqdonut> where in and out give the isomorphism
11:45:14 <dogbite> so does that make the Setup.lhs file meaningless?  should i remove it from my source control?
11:45:31 <nolrai_East> :t f x = \a -> Just ( fromJust . x a )
11:45:32 <lambdabot> parse error on input `='
11:45:33 <opqdonut> :t \a -> Just ( fromJust . (undefined :: b -> Maybe c) a )
11:45:34 <lambdabot> forall a b. b -> Maybe (Maybe a)
11:45:44 <nolrai_East> :t  \x a -> Just ( fromJust . x a )
11:45:45 <lambdabot> forall t a (f :: * -> *). (Functor f) => (t -> f (Maybe a)) -> t -> Maybe (f a)
11:45:54 <Saizan> dogbite: it's useful if you don't have cabal-install on that machine
11:45:59 <opqdonut> there, yeah
11:45:59 <dmwit> dogbite: I'm not sure.  I keep a Setup.lhs anyway.
11:46:13 <opqdonut> err, or not
11:46:47 <opqdonut> ah, it's lambdabot's generalized (.) making the type funny
11:46:48 <opqdonut> i think
11:47:20 <opqdonut> you just replace the f with (r->)
11:47:46 <nolrai_East> ah yess!
11:48:58 <dmwit> But, but... the resulting function is not total!
11:49:18 <ski> @djinn-add data M a
11:49:21 <ski> @djinn-add inn :: a -> M a
11:49:27 <ski> @djinn-add out :: M a -> a
11:49:32 <opqdonut> dmwit: well no, not with Maybe
11:49:32 <ski> @djinn (a -> b -> M c) -> (a -> M (b -> c))
11:49:33 <lambdabot> f _ a = inn a
11:49:41 <ski> that appears broken, no ?
11:49:45 <ski> @djinn-clr
11:49:49 <opqdonut> ski: yes
11:49:49 <MyCatVerbs> ski: skwaaaa, djinn handles data types now?
11:49:56 <nolrai_East> @src inn
11:49:56 <lambdabot> Source not found. You speak an infinite deal of nothing
11:50:00 <ski> @djinn-add data Id a = In a
11:50:10 <ski> @djinn-add out :: Id a -> a
11:50:14 <ski> @djinn (a -> b -> Id c) -> (a -> Id (b -> c))
11:50:15 <lambdabot> f a b =
11:50:15 <lambdabot>     In (\ c ->
11:50:15 <lambdabot>         case a b c of
11:50:15 <lambdabot>         In d -> d)
11:50:24 <opqdonut> yeh, that's the same, right?
11:50:29 <ski> that seems better, though it didn't use the `out'
11:50:40 <opqdonut> well no, it doesn't need to
11:50:48 <ski> MyCatVerbs : been for some time, i think
11:50:53 <ski> @djinn-env
11:50:54 <lambdabot> data () = ()
11:50:54 <lambdabot> data Either a b = Left a | Right b
11:50:54 <lambdabot> data Maybe a = Nothing | Just a
11:50:54 <lambdabot> data Bool = False | True
11:50:54 <lambdabot> data Void
11:50:56 <lambdabot> type Not x = x -> Void
11:50:58 <lambdabot> class Eq a where (==) :: a -> a -> Bool
11:51:00 <lambdabot> data Id a = In a
11:51:01 <opqdonut> because you're effectively saying "data Id a = In { out :: a }"
11:51:02 <lambdabot> out :: Id a -> a
11:51:13 <ski> opqdonut *nod*
11:51:20 <dmwit> ski: It pattern matches explicitly instead of using out.
11:51:23 <opqdonut> it's just the out doesn't have a name, thus the pattern match
11:51:25 <opqdonut> yeah
11:51:29 <ski> MyCatVerbs : but i think it still doesn't handle recursive types well
11:51:54 * ski was worrying that it didn't understand record syntax
11:51:59 <ski> but let's try
11:52:02 <opqdonut> :)
11:52:02 <ski> @djinn-clr
11:52:12 <ski> @djinn-add data Id a = In {out :: a}
11:52:12 <lambdabot> Cannot parse command
11:52:17 <ski> *nod*
11:52:20 <opqdonut> a shame
11:52:29 <dmwit> It hardly needs to.
11:53:30 <ski> nolrai_East : `inn' wasn't a standard function .. basically it corresponds to your `wrap'
12:00:33 <nolrai_East> :t M.insert
12:00:34 <lambdabot> forall k a. (Ord k) => k -> a -> M.Map k a -> M.Map k a
12:03:45 <dogbite> I'm trying to import the Text.CSV module.  it imports just fine but when i try to build with cabal,
12:03:53 <dogbite> cabal tells me that it could not find the module because
12:03:54 <dogbite> it is a member of package csv-0.1.1, which is hidden
12:04:06 <dogbite> do i need to edit my .cabal file?
12:04:14 <dmwit> yes
12:04:21 <plutonas> what do i do wrong in defining null this way: mynull [] = True mynull [_] = False
12:04:23 <dmwit> Add csv to your build-depends: section.
12:04:36 <dmwit> plutonas: [_] matches only length-one lists.
12:04:41 <mauke> plutonas: you don't handle the other cases
12:04:53 <dmwit> plutonas: (_:_) will match lists of any non-zero length.
12:05:03 <plutonas> oh
12:05:08 <mauke> mynull [] = True; mynull _ = False
12:05:09 <dogbite> thanks, that did it
12:05:13 <plutonas> thanks again
12:05:53 <tusho> Hm.
12:06:00 <tusho> I am going to use Language.C to make a C interpreter.
12:06:02 <tusho> Why? Dunno.
12:06:29 <dons> tusho: go for it!
12:06:29 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
12:06:34 <dons> a C compiler might be more fun ...
12:06:38 <tusho> dons: yes, but harder
12:06:42 <tusho> a c interpreter is, well, really easy
12:06:52 <tusho> (oh, and it'll access memory directly)
12:06:55 <tusho> (none of this virtual stuff.)
12:07:23 <dons> you'll end up with a haskell specification of C :)
12:07:38 <SamB> you could re-use some of it to make struct access easier from Haskell ;-P
12:08:30 <tusho> SamB: hehe
12:08:37 <tusho> but really, C is a terribly simple language
12:08:40 <SamB> how will you do function pointers
12:08:42 <SamB> ?
12:09:00 <tusho> SamB: hm, not sure
12:09:02 <tusho> how do most c interps do it?
12:09:23 <dmwit> longjmp
12:09:25 <SamB> uh ... I haven't really encountered very many C intrerpreters...
12:09:38 <tusho> SamB: you are not looking hard enough
12:09:45 <monochrom> Set up a virtual machine. Then you can mimick everything.
12:09:47 <dmwit> Most C "interpreters" are actually incremental compilers.
12:09:55 <SamB> tcc is not a real interpreter
12:09:56 <tusho> dmwit: Ch?
12:10:04 <SamB> it just compiles really quickly
12:10:07 <SamB> then runs
12:10:11 <tusho> ch is a real interp, SamB
12:10:47 <Tobsan> can somebody help me with the syntax of writing your own maximumBy
12:10:53 <Tobsan> @type maximumBy
12:10:54 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
12:11:23 <dmwit> Tobsan: What have you got so far?
12:11:34 <Tobsan> maximumBy (\(a,alen) -> (b,blen) -> compare alen blen) list
12:11:37 <Tobsan> and that does not work
12:11:48 <Tobsan> do i need to have \(b,blen) ?
12:11:58 <therp> drop the first ->
12:12:21 <dmwit> Tobsan: Yes, you can use \(b, blen).
12:12:29 <Tobsan> i made it work by changing to: maximumBy (\(a,alen) -> \(b,blen) -> compare alen blen) list
12:12:35 <dmwit> Tobsan: As a shorthand, "\(a, alen) (b, blen) ->" also works.
12:12:45 <Tobsan> oh, sweet =)
12:12:49 <dmwit> Tobsan: However!
12:12:53 <dmwit> :t comparing
12:12:54 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
12:13:04 <dmwit> Tobsan: You might just want "comparing snd" instead.
12:13:16 <Tobsan> oh
12:13:19 <dmwit> maximumBy (comparing snd) list
12:13:24 <dmwit> ;-)
12:13:28 <Tobsan> thanks :o
12:13:48 <Tobsan> now that looks a lot better
12:13:56 <ski> (.. oh, Tobsan was wanting to *use* `maximumBy', not *write* it ..)
12:14:05 <Tobsan> ski: yes :)
12:14:29 <dmwit> ski: Right, I was confused, too. =)
12:15:12 <ski> (Tobsan : vanligtvis s brukar "writing your own" betyda "skriva sin egen" ..)
12:16:19 <Tobsan> point taken. I was trying to express my ways of writing my own USE for maximumBy :)
12:17:58 <Tobsan> funny thing, i was pasteing something into notepad on windows, and then accidently tried pressing esc, :w to save :(
12:18:58 <dmwit> You know, you can get [g]vim for Windows, too.
12:19:12 * ski 's pressed `C-x C-s' in notepad quite some times
12:19:28 <dmwit> Well, at least that does what you wanted it to do.
12:19:35 <dmwit> ...assuming you wanted it to save. =P
12:20:51 <Tobsan> :P
12:21:26 <Tobsan> it got really complicated when me and my lab partner used different editor, where he was on emacs and i was in vim
12:21:47 <Tobsan> both of us made those mistakes lots of times
12:22:22 <plutonas> how do i append something on the right side of the list? : only puts an element on the front, and i'm supposed to not be aware of reversing
12:23:16 <Tobsan> plutonas: append x xs = xs ++ [x]
12:23:30 <cinimod> plutonas: ++ but are you sure you should be using a list
12:24:01 <cinimod> sounds like a queue
12:24:20 <MyCatVerbs> plutonas: if you're going to do that a lot, use Data.Sequence instead of a plain list.
12:24:26 <plutonas> i'm sure i'm using a list
12:24:35 <plutonas> but i'm not sure i know append either
12:24:46 <plutonas> oh ++ ok sorry
12:25:49 <MyCatVerbs> plutonas: whut? Don't apologise! I'm just saying, adding many elements to the end of a list one at a time is pretty slow. It'll be much quicker to use Data.Sequence if you want to do that.
12:26:27 <chr1s> plutonas: appending something to a list takes n time, with n the number of elements in the list.
12:26:27 <dmwit> "supposed to not be aware of reversing"?
12:26:46 <zachk> whats big O of reverse?
12:27:04 <dmwit> zachk: ...chr1s just said it was O(n), n the length of the list.
12:27:08 <plutonas> MyCatVerbs: yes, but you know i'm following this book and it presents functions one at a time and i should write them myself
12:27:19 <plutonas> so i should only use functions that have been taught before
12:27:31 <plutonas> i'll upload the file when i'm finished for comments, most functions are one-liners
12:27:48 <dmwit> plutonas: Sounds like fun. =)
12:27:53 <chr1s> plutonas: in that case you're safe. it's not a big problem for small lists, but once you need big performance...
12:28:18 <dmwit> ([a], [a]) is probably one of the simplest, coolest data structures that nobody talks about.
12:28:31 <mauke> list zipper?
12:28:39 <Botje> first rule of ([a],[a]), you don't talk about ([a],[a])
12:28:43 <dmwit> mauke: That would be ([a], a, [a]), no?
12:28:55 <BONUS> whats so special about ([a],[a])?
12:29:00 <hpaste>  plutonas pasted "some simple functions" at http://hpaste.org/8747
12:29:07 <dmwit> BONUS: You get O(1) prepend and append! =)
12:29:10 <Philippa> dmwit: yeah. It's a list context though, it just doesn't have the existing item in the hole
12:29:10 <maltem> it can be used to implement a queue
12:29:10 <mauke> dmwit: that's isomorphic to ([a], a : [a]) :-)
12:29:23 <Deewiant> or (a : [a], [a])
12:29:23 <ski> mauke : no .. lists are not streams
12:29:33 <dmwit> mauke: Sure, and [a] is isomorphic to ([a], [a]).
12:29:36 <plutonas> i'd look forward for your comments keeping in mind that i am supposed to use only basic functions for now
12:29:52 <mauke> only if you do it wrong
12:30:00 <dmwit> mauke: Also, it's not isomorphic.
12:30:11 <dmwit> mauke: ([], []) has no counterpart in ([a], a, [a]).
12:30:19 <mauke> yes
12:30:24 <Botje> plutonas: looks very nice. I'd add some error statements instead of failing to pattern match, though
12:30:30 <BONUS> haha hmm
12:30:32 <mauke> a : [a] is the type of non-empty lists
12:30:32 <Botje> myhead [] = error "can't take head of empty ist"
12:30:34 <nolrai_East> :t liftM2 (liftM2 (+))
12:30:35 <lambdabot> forall a1 (m :: * -> *) (m1 :: * -> *). (Monad m1, Monad m, Num a1) => m1 (m a1) -> m1 (m a1) -> m1 (m a1)
12:30:48 <byorgey> plutonas: looks good.
12:30:57 <dmwit> mauke: ...then your statement is pretty vacuous. =P
12:31:08 <byorgey> plutonas: I would implement mylast and myinit with pattern-matching rather than using 'if' and 'mynull'
12:31:13 <Botje> plutonas: also, i'd use pattern matching for mylast and myinit
12:31:17 <chr1s> plutonas: you could do some more pattern matching
12:31:31 <tusho> p.s. does anyone else have 'I WILL EAT YOUR SOUL' as their mental caption of http://upload.wikimedia.org/wikipedia/commons/d/d0/Simon_Peyton_Jones_01.jpg
12:31:32 <lambdabot> http://tinyurl.com/5b2qnv
12:31:33 <Botje> mylast [x] = x; mylast (x:xs) = mylast xs; mylast [] = error "can't take last of empty list"
12:31:34 <MyCatVerbs> dmwit: I thought the point was that the differential of a list(A) was 1+list(A)*list(A), not 1+list(A)*list(A)*A
12:31:38 <plutonas> ok, will try to make more pattern matching, thanks all
12:32:00 <ddarius> tusho: No
12:32:03 <plutonas> but how do i get the last element using pattern matching?
12:32:05 <Botje> tusho: that is one scary out-of-focus picture!
12:32:10 <tusho> ddarius: :(
12:32:14 <Botje> plutonas: i just typed it out above :)
12:32:21 <tusho> Botje: My right eyeball...WILL EAT YOUR SOUL
12:32:34 <Botje> [x] matches a list with exactly one element
12:32:43 <plutonas> Botje: oh yes,
12:33:01 <plutonas> should have thought of this
12:33:14 <Botje> and you can use the same structure for myinit
12:33:17 <chr1s> plutonas: and [x,y] matches a list with exactly two elements, and so on
12:34:07 <zachk> as * is to product + is to <what?> in haskell?
12:34:10 <zachk> sum?
12:34:16 <zachk> > sum [1..10]
12:34:17 <BONUS> yeah
12:34:18 <plutonas> thanks a lot. Was good idea in the end, to paste it for comments :)
12:34:30 <lambdabot>  55
12:34:45 <nominolo> @seen swiert
12:34:45 <lambdabot> I saw swiert leaving #haskell 19m 26s ago, and .
12:35:00 <ski> MyCatVerbs : huh ?
12:36:03 <plutonas> but in myinit even with pattern matching the let should remain? so that i collect the elements, right?
12:36:11 <tusho> MyCatVerbs: what on earth does your name mean
12:36:40 <dmwit> Verbing weirds language.
12:36:47 <ski> tusho : possibly `Verb' there is a metasyntactic variable for any intransitive verb ?
12:37:04 <byorgey> plutonas: you don't need the let, you could just say [] ++ [x] ++ myinit xs
12:37:15 <tusho> dmwit: yes but I don't think cats are clever enough to verb
12:37:27 <byorgey> plutonas: and in fact, [] ++ y = y, so the a ++  part is not necessary
12:37:46 <dmwit> ...and ([x] ++) = (x:).
12:37:54 <byorgey> ah, indeed =)
12:38:06 <byorgey> so [] ++ [x] ++ myinit xs  ===>  x : myinit xs
12:38:31 <ski> @check \x xs -> [x] ++ xs == x : (xs :: [Int])
12:38:40 <lambdabot>  OK, passed 500 tests.
12:38:41 <scodil> tusho: cats are, aren't they?
12:39:05 <tusho> scodil: yes but they can't talk
12:39:07 <tusho> so even if they did verb
12:39:11 <tusho> they wouldn't be able to show us the results
12:39:21 <byorgey> it doesn't matter whether cats can *in general*, just whether MyCatVerb's cat can
12:39:27 <byorgey> and apparently, it can
12:40:22 <tusho> byorgey: yes but I doubt it can
12:40:25 <tusho> what is the evidence?
12:40:27 <tusho> burden of proof.
12:40:42 <MyCatVerbs> ski: ?uhu?
12:40:51 <BONUS> does anyone know if the Purely Functional Data Structures pdf has the same content as the book?
12:40:56 <MyCatVerbs> tusho: MyCatSleeps, MyCatEats, MyCatCodes, etc...
12:40:56 <hpaste>  zachk pasted "how do i get fractional integers?" at http://hpaste.org/8748
12:40:59 <BONUS> i know the book has graphs and the pdf doesnt
12:41:02 <gwern> BONUS: it doesn't
12:41:07 <SamB> BONUS: no, that's his thesis
12:41:09 <BONUS> ah
12:41:11 <plutonas> ho works!!! haskell is a strange language, but a nice one :)
12:41:12 <Deewiant> zachk: without looking: `div` instead of /
12:41:16 <MyCatVerbs> tusho: it's parameterized over the set of all verbs that my cat might wish to engage in.
12:41:16 <SamB> the book is rather altered
12:41:17 <gwern> he expanded the book
12:41:18 <ski> MyCatVerbs : what is the meaning of `differential', there ?
12:41:22 <SamB> I think he wrote a blog entry about this
12:41:23 <BONUS> so is it worth getting the book
12:41:30 <zachk> Deewiant: ty
12:41:32 <MyCatVerbs> ski: you can take derivatives of data types.
12:41:33 <tusho> MyCatVerbs: Your cat does not code.
12:41:39 <gwern> BONUS: probably, if you are not hurting for money
12:41:40 <tusho> MyCatVerbs: I think that's pretty unlikely.
12:41:40 <byorgey> plutonas: =D
12:41:46 <dmwit> BONUS: Yes, I enjoyed it very much.
12:41:48 <BONUS> hehe
12:41:51 <MyCatVerbs> tusho: go stick your presumption somewhere shiny.
12:41:58 <MyCatVerbs> tusho: the output of a megawatt laser, perhaps.
12:42:02 <tusho> MyCatVerbs: Video of cat coding required.
12:42:10 <dmwit> false
12:42:17 <MyCatVerbs> tusho: video of cat coding not provided.
12:42:22 <dmwit> tusho: You assume MyCatVerbs cares whether you believe him or not.
12:42:23 <ski> MyCatVerbs : yes .. `differential' is not the same concept as `derivative', though .. assuming you meant the latter, i still can't make sense of your statement
12:42:30 <MyCatVerbs> tusho: your needs are not my problem.
12:42:35 <tusho> dmwit: That was the implicit assumption
12:42:45 <MyCatVerbs> ski: BBL, food, have this conversation in a bit
12:42:53 <MyCatVerbs> ski: differentiation, I meant.
12:43:11 * gwern suddenly feels hungry. I forgot about lunch
12:43:27 <ski> MyCatVerbs : i'll leave in a short while .. maybe another day, if you care enough
12:44:09 <byorgey> zachk: `div` does integer division.  if you actually want to end up with a floating-point value, you must apply 'fromIntegral' to n first, since the / operator cannot be applied to integral types
12:44:29 <byorgey> > let n = 3 :: Integer  in 4 / n
12:44:32 <lambdabot>   add an instance declaration for (Fractional Integer)
12:44:32 <lambdabot>     In the expression:...
12:44:35 <SamB> or perhaps you desire a Rational
12:44:37 <byorgey> > let n = 3 :: Integer  in 4 / fromIntegral n
12:44:39 <lambdabot>  1.3333333333333333
12:44:44 <byorgey> > let n = 3 :: Integer  in 4 % n
12:44:46 <lambdabot>  4%3
12:44:51 <byorgey> > let n = 3 :: Integer  in 4 `div` n
12:44:52 <lambdabot>  1
12:44:55 <mauke>  > let n = 3 :: Integer  in 4 / fromIntegral n :: Rational
12:44:56 <byorgey> those are the options =)
12:44:58 <scodil> whats the story with haddock and ghc 6.8.3?
12:45:03 <mauke> > let n = 3 :: Integer  in 4 / fromIntegral n :: Rational
12:45:05 <lambdabot>  4%3
12:45:45 <zachk> mauke: ty
13:02:27 <geezusfreeek> > let n = 3 :: Integer in 4 / fromIntegral n :: CReal
13:02:29 <lambdabot>  1.3333333333333333333333333333333333333333
13:06:05 <scodil> ?seen dons
13:06:06 <lambdabot> dons is in #arch-haskell, #haskell, #ghc and #xmonad. I last heard dons speak 48m 43s ago.
13:07:32 <dons> scodil: ?
13:07:57 <scodil> hi. re uvector: am I not meant to provide my own UArr instances? D.A.V.UArr is hidden
13:08:23 <dons> oh really? surely the class is exported... if not, that's an omission
13:08:36 <dons> oh i see,
13:08:37 <scodil> also indexU and lengthU do not appear to be exported
13:08:39 <dons>    -- * The pure and mutable array types UArr, MUArr,
13:09:11 <dons> no, they are. just no the direct ones yet. as you can see, the api is still not fully stabilised.
13:09:25 <dons> just modify Data.Array.Vector's export list as you see fit
13:11:21 <scodil> so do you expect the API to settle soon? I don't _need_ to use it right now, there's still other options. But I'd like to in the future, so I was just messing around with my own UArr types
13:11:29 * dolio laughs at zip12.
13:12:18 <scodil> also why does cabal not build the documentation for it?
13:12:44 <dons> because haddock doesn't understand type families yet :(
13:12:51 <dons> but work is underway to fix that , as of last week
13:12:52 <macondo> > let divs n = [ x | x <- filter (/=0) [(-a)..a], a `mod` x == 0 ] where a = abs n in divs (-8)
13:12:53 <lambdabot>  [-8,-4,-2,-1,1,2,4,8]
13:13:03 <dons> scodil: i'm happy to take any api patches
13:13:18 <dons> dolio: yeah, it was ... almost ... an April 1 style post :)
13:13:40 <scodil> api patches?
13:14:02 <scodil> like, omissions on your part, or changing the api to what I would like? :)
13:14:24 <dolio> dons: Did my patches get through?
13:14:45 <macondo> ping ski
13:15:03 <dons> dolio: yeah, i'll apply them later today
13:15:10 <dolio> All right.
13:15:20 <dons> scodil: well, if you need to write your own instances, that sounds like an omission.
13:15:24 <dons> the classes should be exposed
13:16:01 <hpaste>  dogbite pasted "what am i doing wrong with do and case" at http://hpaste.org/8749
13:16:45 <mauke> dogbite: what is the "in" supposed to do?
13:17:38 <mauke> :t liftM (either (const []) id) . ?parseCSVFromFile
13:17:40 <lambdabot> forall a a1 (m :: * -> *) (f :: * -> *). (Functor f, ?parseCSVFromFile::f (m (Either a1 [a])), Monad m) => f (m [a])
13:18:09 <EvilTerran> ?where zip12
13:18:10 <lambdabot> I know nothing about zip12.
13:18:39 <dogbite> mauke: sorry, lost my connection
13:19:01 <dogbite> mauke: i just can't figure out how to handle the Either.  i want to put a case in there
13:19:08 <mmorrow> scodil: ping
13:19:08 <lambdabot> mmorrow: You have 1 new message. '/msg lambdabot @messages' to read it.
13:19:13 <dogbite> mauke: but i keep getting an error
13:19:33 <dogbite> The last statement in a 'do' construct must be an expression
13:19:52 <pgavin> dogbite: 'in return c' is not an expression
13:20:03 <pgavin> dogbite: that's what the error message is referring to
13:20:27 <dogbite> pgavin: how can i convert it to an expression?
13:20:41 <hpaste>  mauke annotated "what am i doing wrong with do and case" with "(no title)" at http://hpaste.org/8749#a1
13:21:08 <pgavin> dogbite: do you understand how do-syntax gets rewritten?
13:21:29 <dogbite> pgavin: i thought i did :-/
13:21:38 <dons> looks like there's a return missing in that, mauke
13:21:45 <mauke> right
13:22:05 <pgavin> dogbite: ok, well you don't need to use 'in' for lets in do-expressions
13:22:10 <hpaste>  mauke annotated "what am i doing wrong with do and case" with "now with return" at http://hpaste.org/8749#a2
13:22:15 <scodil> dons: is the uvector darcs repo synced with hackage? I just pulled and I get "dependencies are missing: ghc-prim -any"
13:22:31 <dons> ah, let me push that patch.
13:23:37 <scodil> mmorrow: hi
13:24:05 <pgavin> dogbite: i suppose if you changed the indentation for 'in return c' so that it's part of the let expression about it, you would get what you wanted
13:24:06 <mmorrow> scodil: hey, my internet went out completely last night
13:24:06 <scodil> mmorrow: I couldn't get a build of ghc 6.9 to work, so I can't reproduce that build error
13:24:08 <dogbite> pgavin: okay i think i tried something like this earlier but i kept getting indentation errors
13:24:35 <dons> scodil: done.
13:24:40 <scodil> thx
13:24:41 <hpaste>  dogbite annotated "what am i doing wrong with do and case" with "this one worked" at http://hpaste.org/8749#a3
13:24:46 <pgavin> dogbite: add a space before 'in' and it should compile
13:25:00 <dogbite> oh i'm sorry i see what i wrote is the same as yours
13:25:18 <mauke> you can factor the 'return' out
13:25:29 <mmorrow> scodil: cool, i'll see if i can mess with it or just comment the LinAlg mod from the cabal
13:25:38 <pgavin> ah, I didn't see the annotations :)
13:27:24 <monochrom> import qualified Prelude as P=NP
13:27:58 <mauke> export disqualified Epilogue
13:27:59 <pgavin> that still won't let you solve NP problems in P time, monochrom
13:28:08 <monochrom> heh
13:28:11 <scodil> mmorrow: did you try with 6.8.3?
13:28:46 <mmorrow> scodil: no, but i will now...
13:29:55 <scodil> afaik, nothing is going to change in 6.9 re. multi-param type classes and fundeps, so it should still work. Maybe that's a ghc bug
13:30:06 <mmorrow> scodil: builds perfectly under 6.8.3 :)
13:35:36 <scodil> hah dons these patch names are awesome : some tweaks, tweaks, tweaks, some small tweaks, bump.
13:36:13 <dons> awesomeness in a can
13:36:52 <Arnar> greetings..
13:37:01 <dmwit> Hiya and welcome back, Arnar!
13:37:04 <Arnar> any ICALP'08 attendees around?
13:37:06 <Arnar> dmwit: hey :)
13:37:34 <scodil> am I missing something or is there no cabal uninstall?
13:38:10 <monochrom> Heh
13:38:23 <monochrom> No, there isn't.
13:39:40 <Botje> cabal uninstall == unsafeLaunchMissiles
13:39:59 <monochrom> First use "ghc-pkg unregister" to unregister a library. Then manually delete stuff under /usr/local/lib .  Not too hard to find.
13:40:05 <Arnar> there was a workshop today on mathematically structured functional programming.. sigfpe gave a great invited talk on "high-school algebra" on types (shut me up if this is off-topic noise)
13:40:38 <dmwit> neat
13:40:44 <dmwit> Was it recorded or anything?
13:40:48 <monochrom> Typing directory usage of a library. If it's called L version 4, and your ghc is version 6.8.2, the relevant directory is /usr/local/lib/L-4/ghc-6.8.2
13:40:53 <Arnar> dmwit: no, I don't think so :/
13:42:02 <monochrom> high-school algebra on types is on-topic! :)
13:43:08 <dibblego> @check \x -> nub (nub x) == nub x -- is nub idempotent?
13:43:10 <lambdabot>  OK, passed 500 tests.
13:43:16 <Arnar> monochrom: good to know :)
13:43:19 <mauke> @check \x -> nub x == x
13:43:21 <lambdabot>  Falsifiable, after 5 tests: [(),(),()]
13:43:23 <dibblego> @check \x -> nub (nub x) == nub (x :: [Int]) -- is nub idempotent?
13:43:24 <lambdabot>  OK, passed 500 tests.
13:43:48 <dibblego> I am just noting Michael Feathers' (nub . nub) on Haskell-Cafe
13:44:10 <mauke> :t join (.) nub
13:44:11 <lambdabot> forall a. (Eq a) => [a] -> [a]
13:44:41 <Arnar> actually.. I was wondering if anyone could quickly explain to me what a "bag" type is and why it is its own derivative?
13:44:54 <monochrom> bag is aka multi-set
13:45:37 <monochrom> you have the membership or elementhood relation, but moreover you can have multiple occurences, and the count matters.
13:46:04 <dibblego> @check \x -> (nub . nub) x == nub x -- is nub idempotent?
13:46:06 <lambdabot>  OK, passed 500 tests.
13:46:08 <monochrom> I am not well-versed in differentiating types, so I don't know how to do it for bags.
13:46:27 <Arnar> ah ok..
13:46:28 <EvilTerran> Bag(t) ~~ Set (t, N\{0})
13:46:40 <Arnar> but unordered..
13:46:46 <monochrom> Also, next century differentiation will cease to be high-school algebra, even college calculus; it will be PhD math. :)
13:46:56 <EvilTerran> Set t ~~ 2^t, iirc
13:47:05 <Arnar> EvilTerran: that makes sense
13:47:07 <ddarius> Arnar: Edward Kmett should be there.
13:47:35 <Arnar> ddarius: he's a regular here?
13:47:41 <ddarius> edwardk
13:47:48 <Arnar> ah, ok
13:48:11 <dmwit> dibblego: Yes, nub is idempotent.
13:48:21 <EvilTerran> so Bag t ~~ 2^(t*N)
13:48:33 <ddarius> EvilTerran: Yes, a set of X is the same as a function X -> 2, a bag of X is a function X -> N
13:48:34 <EvilTerran> nub is only idempotent if your (==) is an equivalence relation :P
13:48:53 <EvilTerran> ddarius, ah, yes, that definition of bag's easier to work with
13:49:36 <damg> is Debug.Traced only capable of tracking predefined expressions or user-defined, too?
13:49:59 <mauke> huh?
13:49:59 <dmwit> ?check \xs -> let n = nubBy (<) :: [Int] -> [Int] in n (n xs) == n xs
13:50:01 <lambdabot>  OK, passed 500 tests.
13:50:06 <dmwit> EvilTerran: Are you sure?
13:50:10 <Heffalump> damg: what do you mean be predefined?
13:50:10 <Arnar> so by X -> 2 you mean something isomorphic to X -> {0,1} ?
13:50:21 * monochrom is reminded of the asylum story with the resident that goes around saying "I differentiate you!"
13:50:28 <EvilTerran> dmwit, er, no
13:50:43 <dmwit> ?src nub
13:50:43 <lambdabot> nub = nubBy (==)
13:50:48 <dmwit> ?src nubBy
13:50:48 <lambdabot> nubBy eq []             =  []
13:50:48 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
13:50:53 <mauke> ʎp/p
13:51:02 <dmwit> Oooh, nub *can* be non-idempotent.
13:51:07 <Arnar> monochrom: heard the one about the constant and e^x walking down the street?
13:51:20 <dmwit> Let's see if I can do this on my first try...
13:51:32 <sanar> hi
13:51:44 <monochrom> No.
13:51:54 <sanar> ?
13:52:10 <EvilTerran> Arnar, yes, exactly. n is any type with n constructors
13:52:44 <dmwit> > let bad 0 1 = True; bad 0 2 = False; bad 1 2 = True in (nubBy bad [0,1,2], nubBy bad (nubBy bad [0,1,2]))
13:52:46 <lambdabot>  ([0,2],[0,2])
13:53:07 <EvilTerran> 0 is an empty data decleration "data Void;" - or, if you prefer _|_; 1 is (); 2 is Bool...
13:53:14 <jre2> I don't suppose anyone has an archive of haddock interface files available online?
13:53:15 <scodil> dons: you intend for lengthU and indexU to be exported from D.A.V.Strict.Basics, right? The stream versions? If so I can't figure out how to also export the UA class methods of the same name without conflicts
13:53:26 <damg> Heffalump, I mean ones in Prelude. e.g if I defined a rec fun like let fac n = if n == 0 then 1 else n * (fac $ n - 1), then it returns sth like n * (n - 1) * ... instead of fac ( fac ( fac ...
13:53:27 <Arnar> monochrom: the constant says "OH MY GOD.. dude, let's run - there's a differential operator coming.. he might make me disappear". e^x says "nah.. he can't do nothing to me". Once the differential operator catches up him, e^x says with a smug face "Hey, I'm e^x". The differential operator answers: "O hai, I'm d/dy"
13:53:29 <EvilTerran> by N we really mean #N
13:53:42 <Arnar> EvilTerran: ah..
13:53:56 <monochrom> Thanks.
13:53:59 <Heffalump> damg: I've only read augustss's blog post, not tried Debug.Traced, but I'd expect it to trace any user-defined expressions fine.
13:54:21 <EvilTerran> Arnar, we consider isomorphic types to be equivalent for the purposes of type differentiation
13:54:22 <Heffalump> it'll only tell you about operators in the Num class, I'd expect
13:54:32 <damg> Heffalump, I'll make a look into the source
13:54:34 <Heffalump> I'm not quite sure what you actually want
13:54:35 <dmwit> Oh, no, nub is always idempotent.
13:54:44 <EvilTerran> so, anyway, Bag(t) ~~ N^t
13:55:06 <dons> scodil: yeah, i've been umming and aahring about how best to expose, clearly, the streamable and direct implementations
13:55:13 <Arnar> right.. and the derivative of that is the same thing..
13:55:44 <sanar> Hi everyone, next year on my computer science coure I will be studying haskell language, apart from the main page are ther any other good resources to learn from?
13:55:57 <Arnar> sanar: check out "real world haskell"
13:55:59 <Botje> sanar: YAHT and real world haskell
13:56:09 <scodil> scodil: maybe give them different names? They seem very different to me.
13:56:11 <dmwit> sanar: The Gentle Introduction, YAHT, RWH.
13:56:15 <scodil> hah
13:56:17 <monochrom> Richard Bird's book "an introduction to functional programming using haskell", 2nd edition.
13:56:18 <scodil> talking to my self
13:56:21 <dons> sanar: the main page points at most everything, but the other things you need to get familiar with are perhaps hackage.haskell.org, the haskell-cafe@ mailing list, #haskell irc, and say, RWH/YAHT
13:56:50 <EvilTerran> Arnar, yeah, Bag'(t) = ln(#N)*N^t
13:56:51 <dons> sanar: hang out here over summer and you'll be in a good position
13:56:56 <sanar> thankyou everyone
13:57:11 <dons> and welcome, sanar !
13:57:16 <dmwit> maybe the Report, too?
13:57:20 <EvilTerran> and #(ln N) = #N, er, or something...
13:57:21 <ddarius> A pleasant lute piece.
13:57:23 <sanar> you mean hanging out here wouldn't confuse me even more.. :p
13:57:38 <Arnar> EvilTerran: sure.. like a constant I guess
13:57:39 <dons> no, you'd be on top of how the daily practice of writing and using haskell works.
13:57:40 <EvilTerran> Arnar, i'm afraid i get a bit lost around taking the logarithm of #N
13:57:59 <Arnar> EvilTerran: I don't blame you..
13:58:12 <sanar> are you all regularly on this channel?
13:58:21 <dmwit> EvilTerran: No problem, just create a data type with 2.718281828 constructors.
13:58:23 <EvilTerran> sanar, most of the active ones of us, yes
13:58:34 <scodil> most of the regulars are regularly here
13:58:40 <EvilTerran> dmwit, hang on, i'll send oleg an email
13:58:41 <EvilTerran> ;)
13:58:44 <dmwit> heh
13:59:05 <Arnar> EvilTerran: so if I may ask about simpler examples (just to help me understand).. when they say (x^2).. they mean pairs (x,x), right?
13:59:06 <ddarius> It's best to use power series for these types of things.
13:59:37 <dmwit> Arnar: yes
13:59:54 <EvilTerran> Arnar, yes
14:00:07 <Arnar> ok.. so the derivative of that is 2x = x+x.. I guess because the hole can be either on the left or the right side..
14:00:16 <Arnar> but what meaning does "x + x" for types?
14:00:21 <EvilTerran> Either
14:00:21 <Arnar> isn't that just  ?
14:00:22 <dmwit> ?src Either
14:00:22 <lambdabot> Source not found. The more you drive -- the dumber you get.
14:00:24 <Arnar> ah..
14:00:31 <EvilTerran> x+y = Either x y
14:00:37 <Arnar> but Either a a is not isomorphic to just x ?
14:00:41 <Arnar> sorry.. s/x/a/
14:00:54 <dmwit> Arnar: No, because you have the extra tag telling Left or Right.
14:00:54 <EvilTerran> () + () ~~ 1 + 1 ~~ 2 ~~ Bool
14:01:02 <EvilTerran> for a simple example
14:01:04 <Arnar> dmwit: ah, right..
14:01:16 <EvilTerran> Either x x ~~ x + x ~~ 2*x ~~ (Bool, x)
14:01:21 <monochrom> 2=1=0  *duck*
14:01:26 <sandbox> does haskell have a datatype like "Nat U 0" or UnsignedInt or something?
14:01:28 <Arnar> EvilTerran: ah, thanks. does that mean you can define all types in terms of () sort of like the peano numbers?
14:01:28 <mauke> NO QUACK
14:01:38 <dmwit> NO, QUACK
14:01:43 <EvilTerran> Arnar, because you can use the Bool to indicate Left or Right, and the x to indicatethe parameter
14:01:43 <mauke> sandbox: Word32
14:01:48 <sandbox> thanks
14:01:50 <Arnar> sure..
14:02:01 <scodil> dons: am I missing something or is the exported indexU O(n) ?
14:02:02 <EvilTerran> Arnar, yeah, you can define everything in terms of (), +, and *, i think
14:02:12 <EvilTerran> actually, you might need 0 as well
14:02:12 <ddarius> You need more than that.
14:02:23 <EvilTerran> and fix if you want recursive types
14:02:24 <ddarius> You need Id and ->
14:02:46 <Arnar> I guess I should really sit down with Pierce..
14:02:47 <mauke> why do I need Id?
14:02:48 <EvilTerran> ddarius, ah, yeah, i forgot (->)/(^)
14:03:02 <ddarius> mauke: Write Maybe using only (), Either, and (,)
14:03:03 <EvilTerran> (x^y ~~ y -> x)
14:03:19 <dmwit> I would think you could get (->) from Fix and (,).
14:03:20 <EvilTerran> ddarius, Either ()
14:03:22 <mauke> Maybe = Either ()
14:03:27 <dons> scodil: there's a stream-only version of indexU exported
14:03:31 <ddarius> Well, wrong either.
14:03:39 <EvilTerran> what?
14:03:41 <dons> scodil: not the direct implementation. similar for several other functions that have O(1) implementations
14:04:01 <dons> scodil: i've not worked out a satisfactory way to partiion the stream and direct implementations yet
14:04:09 <dons> i'd imagine we should default to direct implementations
14:04:10 <EvilTerran> Maybe x = 1 + x, makes sense to me
14:04:16 <dons> and users can pull in streaming versions if they wish
14:04:54 <dmwit> Of course, all of this is ignoring _|_.
14:05:00 <EvilTerran> yes
14:05:02 <scodil> dons: yeah I think many people would be surprised that indexU and lengthU are not O(1).  Maybe call the direct functions atU and sizeU?
14:05:12 <scodil> they seem like very different operations to me
14:05:13 <EvilTerran> because 0 + 0 /= 0 with _|_
14:05:13 <dons> scodil: well, i want to use the module system
14:05:25 <dons> Stream.index , and index, ideally
14:05:35 <dmwit> Well, 1 + 1 /= 2, anyway.
14:05:44 <dmwit> Oh, yeah, 0+0/=0, too.
14:05:46 <dons> since there's some interest, i'll have a look this week. dolio's also keen to clean things up i think
14:05:47 <EvilTerran> Left _|_ is distinct from Right _|_ with _|_s
14:05:52 <dmwit> exactly
14:05:57 <scodil> and I'm keen to use it
14:06:00 <sanar> is there a hello world equivalent in haskell?
14:06:10 <EvilTerran> main = putStrLn "hello world"
14:06:10 <mauke> sanar: factorial :-)
14:06:10 <Botje> main = print "hello world"
14:06:10 <EvilTerran> ?
14:06:11 <dmwit> sanar: main = putStrLn "hello, world"
14:06:11 <ddarius> putStrLn "Hello World"
14:06:16 <Arnar> EvilTerran: how would you define Integer.. as fix x.(1 + x) ?
14:06:18 <Botje> oh yeah. putstrln
14:06:22 <mauke> @where evolution
14:06:22 <lambdabot> http://www.willamette.edu/~fruehr/haskell/evolution.html
14:06:24 <scodil> I only have Storable to work with and I've posted 3 bugs related to it just this weekend
14:06:25 <chr1s> EvilTerran: and now recursive types, like []
14:06:33 <EvilTerran> chr1s, what about them?
14:06:42 <EvilTerran> [22:02] <EvilTerran> and fix if you want recursive types
14:06:43 <chr1s> those are harder without fix
14:06:47 <chr1s> ah
14:06:51 <chr1s> I'm sorry.
14:06:59 <EvilTerran> Arnar, yeah, that'd work, i think
14:07:09 <sanar> privmsg mauke factorial?
14:07:15 <EvilTerran> well, that's Nat
14:07:29 <EvilTerran> but they're isomorphic anyway, so it doesn't matter :P
14:07:30 <mauke> sanar: read the evolution link
14:07:31 <Arnar> EvilTerran: would Integer be isomorphic to what you called N before ?
14:07:32 <dmwit> sanar: See his ?where query.
14:07:48 <dons> dolio: hahaha it wa san april 1 joke.
14:07:53 <sanar> ah, thanx
14:08:24 <Arnar> EvilTerran: right.. so basically any type with countably infinite ctors
14:09:14 <EvilTerran> yeah
14:09:22 <EvilTerran> kinda
14:09:50 <EvilTerran> altho, be careful with that, 1+1 has countably many constructors
14:10:23 <Arnar> EvilTerran: mm.. ok. 1+1 is like a cross product of Nat I guess..
14:10:55 <Arnar> I think I'm confusing myself by thinking of types as "sets of possible values"
14:11:23 <dons> Arnar: that's a relatively standard way to view types
14:11:42 <dons> they define the sets of possibly values a variable may be.
14:11:46 <plutonas> if i already have matched a list to (x:xs) how can i test if it is []?
14:11:55 <plutonas> i tried (x:xs) == [] but it seems to not be working
14:11:57 <mauke> plutonas: er. it can't be.
14:11:57 <Botje> it can't be
14:12:00 <plutonas> oh
14:12:04 <Arnar> plutonas: use the l@(x:xs) syntax
14:12:05 <dons> f [] = 1 ; f (x:xs) = 2
14:12:05 <Botje> a list is EITHER (x:xs) or []
14:12:15 <Arnar> right.. of course
14:12:16 <dons> ?src []
14:12:16 <lambdabot> data [] a = [] | a : [a]
14:12:21 <plutonas> ok
14:12:26 <dons> you have to handle each variant separately
14:12:32 <dons>  [] or x : xs
14:12:34 <plutonas> thanks will do it seperately
14:13:15 <mauke> > case [] of ~y@(x:xs) -> y
14:13:16 <lambdabot>   Irrefutable pattern failed for pattern (y@(x : xs))
14:13:26 <mauke> what
14:13:54 <dons> > case [] of y@(~(x:xs)) -> y
14:13:55 <lambdabot>  []
14:14:06 <mauke> hax
14:14:13 <byorgey> hm, what's the difference?
14:14:16 <dons> > case [] of y@~x:xs -> y
14:14:16 <lambdabot>  Parse error in pattern at "->" (column 20)
14:14:22 <dons> > case [] of y@~(x:xs) -> y
14:14:22 <lambdabot>  Parse error in pattern at "->" (column 22)
14:14:33 <mauke> > case [] of y@ ~(x:xs) -> y
14:14:34 <lambdabot>  []
14:14:37 <dons> cute
14:14:49 <BONUS> how does haskell tell apart the composition function and the dot when you import qualified
14:14:52 <ddarius> > let f y@(~(x:xs)) = if null y then 0 else x+f xs in f [1,2,3]
14:14:53 <lambdabot>  6
14:15:18 <byorgey> BONUS: ah, now you are asking about dirty secrets!
14:15:18 <dons> BONUS: in the lexer.
14:15:24 <BONUS> haha
14:15:31 <mauke> BONUS: Uppercase.word is qualification
14:15:35 <BONUS> ah
14:15:36 <ddarius> BONUS: If the . is immediately against something that could be a module name, it is viewed as qualification.
14:15:36 <mauke> everything else is the . operator
14:15:42 <scodil> what about constructors?
14:15:45 <dons> > map (Just.id) [1..5]
14:15:46 <lambdabot>   Not in scope: `Just.id'
14:15:52 <dons> > map (Just . id) [1..5]
14:15:54 <BONUS> so you have to put a space in there
14:15:55 <BONUS> aha
14:16:01 <lambdabot>  [Just 1,Just 2,Just 3,Just 4,Just 5]
14:16:02 <monochrom> ~(y@(_:_)) means if you force y the pattern y@(_:_) kicks in.
14:16:02 <mauke> > map (Just. id) [1..5]
14:16:03 <lambdabot>  [Just 1,Just 2,Just 3,Just 4,Just 5]
14:16:11 <chessguy> oh, for a minute there, i was trying to figure out if there was some inside joke, that everyone was pointing out their comment as 'BONUS'
14:16:14 * byorgey cringes with the ugliness
14:16:33 <dons> PRO TIP: (.) is weird, and ~ is cool
14:16:38 <yitz> > (Just.id) 5
14:16:38 <lambdabot>   Not in scope: `Just.id'
14:16:47 <byorgey> chessguy: hehe
14:16:49 <yitz> > (Just. id) 5
14:16:49 <vixey> chessguy lol
14:16:50 <lambdabot>  Just 5
14:16:51 <BONUS> haha
14:16:52 <mauke> > (id.Just) 5
14:16:53 <lambdabot>  Just 5
14:17:11 <chessguy> > (Just.Just) 5
14:17:12 <lambdabot>   Not in scope: data constructor `Just.Just'
14:17:28 <chessguy> p0wnd!
14:17:31 <yitz> > (Just. Just) 5
14:17:31 <mauke> > (Just P..Just) 5
14:17:32 <dmhouse> Re ~: http://en.wikibooks.org/wiki/Haskell/Laziness#Lazy_pattern_matching
14:17:34 <lambdabot>  Just (Just 5)
14:17:34 <lambdabot>  Just (Just 5)
14:17:46 <lambdabot> http://tinyurl.com/ykch9p
14:18:43 <chessguy> so that air traffic control thing on -cafe was really a joke?
14:19:32 <yitz> chessguy: H# ??
14:20:07 <chessguy> yeah, i skimmed over that, thinking it was just an IDE or something
14:20:27 <chessguy> like Visual Haskell
14:21:59 <dogbite> chessguy: thanks for posting those microsoft questions
14:22:06 <dogbite> chessguy: i enjoyed answering them
14:22:11 <chessguy> sure thing
14:22:41 <dogbite> can somebody tell me the prefered way to convert a String to a float (fractional?)
14:22:43 <chessguy> it was quite an exhausting day. those were just the pure coding questions, too
14:22:53 <BONUS> read?
14:22:57 <mauke> dogbite: reads or read
14:23:02 <monochrom> > read "3.14" :: Rational
14:23:03 <lambdabot>  Exception: Prelude.read: no parse
14:23:09 <monochrom> > read "3.14" :: Double
14:23:10 <lambdabot>  3.14
14:23:25 <ddarius> > read "pi" :: Double
14:23:26 <lambdabot>  Exception: Prelude.read: no parse
14:23:30 <dogbite> mauke: okay i'm doing (read "3.14") * 1.0
14:23:37 <mauke> why * 1.0?
14:23:38 <monochrom> Ha
14:23:43 <dogbite> hacker cast?
14:23:48 <dogbite> hence the question, hehe :-)
14:23:50 <monochrom> poor man's coercion
14:23:53 <mauke> this isn't perl!
14:23:58 <dogbite> not yet it isn't
14:24:05 <dogbite> give it a few years
14:24:16 <ddarius> @where haskerl
14:24:16 <lambdabot> I know nothing about haskerl.
14:24:21 <ddarius> @google haskerl
14:24:23 <lambdabot> http://www.dcs.gla.ac.uk/~partain/haskerl.html
14:24:23 <lambdabot> Title: The Haskerl index
14:24:42 <ddarius> @where+ haskerl http://www.dcs.gla.ac.uk/~partain/haskerl.html
14:24:42 <lambdabot> Done.
14:24:45 <dogbite> chessguy: yeah those days are always exhausting
14:25:38 <mauke> http://mauke.ath.cx/stuff/haskell/hax.pl
14:25:40 <ddarius> @karma lwall
14:25:40 <lambdabot> lwall has a karma of 79
14:25:47 <yitz> > 3.14 :: Rational
14:25:48 <lambdabot>  157%50
14:25:58 <ddarius> @karma Cale
14:25:58 <lambdabot> Cale has a karma of 76
14:26:04 <dogbite> any good reason functions like stod don't exist?
14:26:09 <dogbite> (string to double)
14:26:24 <mauke> because we have read
14:26:34 <mmorrow> > let stod = (read::String->Double) in stod (show pi)
14:26:35 <dogbite> fair enough
14:26:35 <lambdabot>  3.141592653589793
14:26:56 <BONUS> because the type system is so good you dont need a special function for every time
14:27:04 <kiris> type inference will usually figure out that you want a double from read
14:27:12 <dons> all the strToTypeT functions are subsumed by the Read class
14:27:19 <mauke> I just define a completely generic "dwim" method for all types
14:27:22 <kiris> subsumed, I like that
14:27:32 <mauke> my programs look like main = dwim `dwim` dwim (dwim dwim)
14:27:35 <dons> :)
14:27:41 <dons> mauke programs soley in types
14:27:44 <scodil> dude you need a dwim monad
14:27:54 <MyCatVerbs> mauke: I've never been able to hack that kinda thing up.
14:28:01 <dogbite> can somebody define a doMyWork::Input->Output
14:28:01 <dogbite> ?
14:28:07 <monochrom> @remember mauke my programs look like main = dwim `dwim` dwim (dwim dwim)
14:28:07 <lambdabot> It is stored.
14:28:24 <MyCatVerbs> mauke: I get halfway through, then break down and switch to dwim `dwim` dwim $ dwim (dwim dwim) -- instead, to make the combinators easier. ;)
14:28:41 <plutonas> can i give to a function that expects as an argument a boolean function pred, (not pred)? because it seems not to work
14:28:53 <MyCatVerbs> plutonas: (not . pred)
14:28:53 <scodil> not . pred
14:29:00 <plutonas> oh what does the dot signify?
14:29:03 <MyCatVerbs> dogbite: surprisingly, yes. doMyWork = undefined
14:29:05 <plutonas> have not learned that
14:29:07 <mauke> composition
14:29:07 <MyCatVerbs> plutonas: function composition.
14:29:08 <kiris> foldr ($) dwim [dwim..dwim]
14:29:13 <yitz> @type \ dwim -> dwim `dwim` dwim (dwim dwim)
14:29:14 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
14:29:14 <lambdabot>     Probable cause: `dwim' is applied to too many arguments
14:29:14 <lambdabot>     In the first argument of `dwim', namely `(dwim dwim)'
14:29:19 <mauke> @src (.)
14:29:19 <lambdabot> (f . g) x = f (g x)
14:29:19 <lambdabot> -- In lambdabot, it's been generalised to:
14:29:19 <lambdabot> (.) = fmap
14:29:19 <BONUS> f (g x) = (f . g) x
14:29:44 <mauke> kiris: dwim (`dwim`) dwim (dwim dwim dwim)
14:29:51 <dogbite> MyCatVerbs: maps to my Input and Output quite well, actually
14:29:52 <kiris> ah, whoops
14:30:03 <monochrom> yitz: there is some monomorphism when you write \ dwim -> ...
14:30:19 <MyCatVerbs> dogbite: the success rate isn't brilliant, but the adaptability is second to none.
14:30:38 <kiris> @seen cale
14:30:38 <lambdabot> cale is in #haskell-overflow, #ghc and #haskell. I last heard cale speak 16h 56m 19s ago.
14:31:03 <EvilTerran> Arnar, er, sorry, wandered away for a minute. i didn't mean 1+1, i meant N+N
14:31:27 <yitz> monochrom: :)
14:31:37 <kiris> can someone pull my λb patch? http://chrisdone.com/lambdabot
14:31:40 <lambdabot> Title: Index of /lambdabot/
14:32:01 <Arnar> EvilTerran: no worries.. I wandered off myself :)
14:32:11 <vixey> kiris: Can you add unicode support ?
14:32:38 <kiris> sure
14:32:42 <kiris> I'll see
14:32:43 <vixey> > let (×) = (,) in "lambabot doesn't understand UTF-8"
14:32:43 <lambdabot>  Illegal character ''\151''
14:32:43 <lambdabot>  at ")" (column 7)
14:32:53 <Arnar> EvilTerran: although. I had to scroll up.. apparently I read it as N+N
14:33:00 <Arnar> EvilTerran: autocorrection at work
14:33:30 <vixey> I tried to but I had too much problems with the thing I just gave up :/
14:33:39 <vixey> I mean problems having it run in the first place
14:33:47 <EvilTerran> Arnar, heh. i guess it was the closest thing that made sense.
14:33:47 <schme> Hello #haskell
14:34:07 <kiris> ah, I've got it to run with the ./build script that came with it
14:34:34 <dmwit> schme: Hi!
14:34:34 <dons> ?users
14:34:35 <lambdabot> Maximum users seen in #haskell: 464, currently: 451 (97.2%), active: 26 (5.8%)
14:34:42 <schme> My gosh! It is dmwit !
14:35:17 <dmwit> Well, golly!
14:35:40 <schme> Any haskell gtk tutorials about?
14:37:22 <dmwit> schme: Have you looked at the Documentation page on the Gtk2Hs site?
14:38:12 <yitz> @go gtk2hs tutorial
14:38:13 <lambdabot> No Result Found.
14:38:35 <schme> dmwit: That is so funny. I have been looking for two hours here, and then I click real world haskell, see a GUI section. it points me to the doc page on the gtk2hs.. just as you say that.
14:38:36 <dmwit> There are lots of results at the real google.com.
14:38:58 <yitz> hmm, works for me in google. anyway: http://darcs.haskell.org/gtk2hs/docs/tutorial/Tutorial_Port/
14:38:59 <lambdabot> Title: Gtk2Hs Tutorial
14:40:18 <schme> Well this will be fun.
14:41:23 <schme> Which one is the easiest of all these gui toolkits?
14:41:44 <dmwit> Whichever one you already know.
14:41:53 <schme> Well that's McCLIM then.
14:42:08 <dmwit> If you know Gtk, use Gtk2Hs; if you know wxwindows, use wxHaskell; if you know Xlib, so help you god.
14:42:11 <vixey> whichever one actually installs ....
14:42:37 <schme> Ya. I do know Xlib, but I was hoping to not have to work directly with it 'cause it is a bit of a pain in the behind ;)
14:42:40 <dmwit> schme: Gtk2Hs is really nice.
14:42:56 <dmwit> If you're unsure, go with that one.
14:43:04 <schme> gtk2hs seems a bit more documented with the tutorials.. I'll check it out.
14:44:07 <schme> Well thanks, dolls!
14:44:16 * schme goes a'gladin'
14:45:48 * schme waits for aptitude.
14:46:06 <yitz> @vixen say hi to schme
14:46:07 <lambdabot> hello there
14:46:14 <schme> Hopefully this will result in game related things.
14:46:30 <schme> Hello, lambdabot.
14:56:02 <Arnar> if anyone's interested, there are a few (and will be more) pictures from icalp and affiliated events at picasaweb.google.com/icalp2008, including sigfpe's talk
15:07:44 <dmwit> @vixen say hi
15:07:44 <lambdabot> hello there
15:07:47 <dmwit> @vixen hi
15:07:48 <lambdabot> how're you?
15:10:36 <povman> has anyone used hopengl on os x?
15:11:54 <povman> Michi's hello world program beachballs until i forcequit it
15:12:07 <hpaste>  dogbite pasted "Am I not using IO correctly?  Weird output." at http://hpaste.org/8751
15:12:31 <dogbite> In my function that I pasted, the aligned data is only showing values from
15:12:36 <dogbite> one of the inputs.
15:12:58 <dogbite> I'm worried that the compiler is assuming some function has the same output
15:13:08 <dogbite> because I'm not using IO or do or something like that correctly
15:14:18 <dogbite> The printout includes this line
15:14:20 <dogbite> [(("1962-January-2",4.06),("1962-January-2",4.06)),(("1962-January-3",4.03),("1962-January-3",4.03))]
15:18:49 <dogbite> nevrmind found the error
15:18:53 <dogbite> my mistake in coding that's all
15:20:15 <hpaste>  dogbite annotated "Am I not using IO correctly?  Weird output." with "for anybody who might care -- variable error with v1/v2" at http://hpaste.org/8751#a1
15:22:37 <tromp> > ()
15:22:38 <lambdabot>  ()
15:23:53 <hpaste>  a-9 pasted "(no title)" at http://hpaste.org/8752
15:24:19 <povman> aha i found mine too :D have to call swapBuffer
15:25:07 <scodil> how do you do preformatted comments in haddock? Like a block of code?
15:26:16 <vixey> I can't tell if this is clear or obfuscated :S
15:26:26 <vixey> type' =  Left . (try ident)
15:26:26 <vixey>      <|> Right . parens data'
15:26:26 <vixey>      <|> Right . flip Data [] . name
15:26:26 <vixey> how is this ?
15:28:11 <Baughn> vixey: Looks fine to me
15:29:41 <ddarius> vixey: Seems reasonable enough, especially decorated with the BNF
15:30:15 <Saad_> Hehe, I made the compiler blow up
15:30:15 <Saad_> bar.hs:99:16:
15:30:15 <Saad_>     My brain just exploded. || Have to love awsome developers
15:31:34 <Baughn> I have noticed that GHC is considerably more.. colloquial, than most other compilers. Or compilers for other languages, perhaps.
15:32:00 <Baughn> Don't know if it reduces compiler-rage, or just wants you to say main=dwim more often..
15:32:05 <povman> vixey: why parentheses on the first line?
15:32:07 <Baughn> *makes you want to
15:34:35 <vixey> no reason, I removed the try as well
15:34:51 <dons> Baughn: that's because it is glorious
15:35:07 <Baughn> dons: Says so right there in the name, yep.
15:35:13 <vixey> you know how let types differently than lambda.. is the only disadvantage of making lambda have the same typing rules that it would make type checking take longer?
15:35:16 <ddarius> type' = Left . ((((((((ident))))))) <|> Right . parens data' <|> Right . flip Data [] . name
15:36:07 <ddarius> vixey: It would lead to higher rank types.
15:37:16 <povman> ddarius: thanks for that.
15:38:22 <marcot> Hello, the link in http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Monoid.html is broken.
15:38:22 <lambdabot> Title: Data.Monoid, http://tinyurl.com/y5qk9n
15:38:25 <marcot> Where should I report it?
15:38:29 <vixey> @unpl liftM2 (:) (oneOf ['A'..'Z']) (many alphaNum)
15:38:35 <lambdabot> ((oneOf ['A' .. 'Z']) >>= \ b -> (many alphaNum) >>= \ a -> return ((:) b a))
15:40:15 <povman> vixey: you could also do: pure (:) `ap` oneOf ['A'..'Z'] `ap` many alphaNum
15:40:33 <povman> @unpl pure (:) `ap` oneOf ['A'..'Z'] `ap` many alphaNum
15:40:34 <lambdabot> (((pure (:)) >>= \ h -> (oneOf ['A' .. 'Z']) >>= \ g -> return (h g)) >>= \ b -> (many alphaNum) >>= \ a -> return (b a))
15:40:34 <Baughn> marcot: Connection failed? Try again in a few days, if it's still broken then..
15:40:51 <marcot> hum...
15:41:02 <Baughn> marcot: citeseer isn't really the kind of site that can just /go away/
15:41:19 <marcot> ok, I'll just wait then.  I've found a monoid tutorial..
15:41:53 <ddarius> povman: If you're going to do that, use <*>
15:41:57 <ddarius> and <$>
15:41:59 <povman> *doh
15:42:01 <Baughn> marcot: Meanwhile, have http://scholar.google.no/scholar?q=Functional+Programming+with+Overloading+and+Higher-Order+Polymorphism&hl=en&lr=&btnG=Search&sourceid=Mozilla-search
15:42:02 <lambdabot> Title: Functional Programming with Overloading and Higher-Order Polymorphism - Google S ..., http://tinyurl.com/6yzqb4
15:42:09 <povman> my idiot.
15:42:21 <ddarius> (:) <$> oneOf ['A'..'Z'] <*> many alphaNum
15:42:55 <povman> oooh
15:43:24 <ddarius> Baughn: Citeseer has been down (more or less) for a while.  I think they are transitioning to CiteSeerX but it doesn't have all the content (yet?)
15:43:25 <marcot> Baughn: thanks.
15:44:14 <dons> google should step up.
15:44:54 <Baughn> ddarius: Huh. Well, hopefully they'll add a redirect when they're done breaking things
15:45:06 <povman> :t (<*>)
15:45:08 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
15:45:11 <povman> :t (<$>)
15:45:12 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:45:23 <Baughn> dons: I can't help but think google already stores quite enough of the internet. -_-;
15:45:45 <ddarius> Google has some embarassing videos of Baughn.
15:46:26 <vixey> is f x = (x,x) the same as f = \x -> something ?
15:46:49 <Baughn> vixey: Well, except the monomorphism restriction, that I really doubt could apply..
15:47:20 <Baughn> f = \x -> (x,x), presumably
15:48:47 <Baughn> vixey: And sadly, f = (,) falls prey to the same problem. Although without typeclasses, there is no problem.
15:49:06 <Baughn> ..well... f = foo (,)
15:49:22 <vixey> oh I see that's good
15:49:34 <ddarius> f = id&&&id
15:49:42 <Baughn> vixey: http://haskell.org/haskellwiki/Monomorphism_restriction <-- Just read this. More likely to work than my broken explanations.
15:49:42 <lambdabot> Title: Monomorphism restriction - HaskellWiki
15:49:56 <Baughn> @ty (&&&)
15:49:56 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
15:50:22 <Baughn> ddarius: Okay. Could you explain that one?
15:50:32 <ddarius> :t id &&& id
15:50:33 <lambdabot> forall a. a -> (a, a)
15:50:45 <vixey> a = (~>)
15:50:48 <Baughn> I mean, which arrow instance is that?
15:50:56 <vixey> (b ~> c) -> (b ~> c') -> (b ~> (c, c'))
15:51:11 <ddarius> Baughn: Just unify.
15:51:50 <vixey> the -> arrow
15:52:03 <ddarius> :t \a -> (a, a)
15:52:03 <lambdabot> forall t. t -> (t, t)
15:52:15 <ddarius> :t \a -> (a, a) :: a -> (a, a)
15:52:15 <lambdabot>     Couldn't match expected type `a -> (a, a)'
15:52:15 <lambdabot>            against inferred type `(t, t)'
15:52:15 <lambdabot>     In the expression: (a, a) :: a -> (a, a)
15:52:22 <ddarius> Stupid scoping
15:53:14 <ddarius> If we wrote, forall t as /\t it would be even better (\t -> (t,t)) :: /\t. t -> (t,t)
15:53:51 <Baughn> Why not write it as \t?
15:54:07 <vixey> what's weird is that the /\'s get applied automatically
15:54:24 <vixey> well I guess it's just neccesity since types are not values
15:54:27 <ddarius> That's not weird at all.  That's SOP for most things.
15:54:48 <ddarius> vixey: We could have explicit type application, but there is little reason to.
15:56:49 <mmorrow> ddarius: re: "stupid scoping" => interestingly that reminds me, i was randomly perusing Parser.y once and I think that the type annotation there is disallowed because it creates an unresolvable ambiguity
15:57:18 <ddarius> mmorrow: It parses the way it should.
15:57:45 <ddarius> I was just complaining about the (sensible) parse getting in the way of my fun.
15:57:53 <vixey> :t \x -> x :: Integer
15:57:53 <lambdabot> Integer -> Integer
15:58:01 <mmorrow> ddarius: hehe, i *hate* that
15:59:14 <mmorrow> ddarius: actually, i think the ambiguity *is* resolvable, but it would require always looking ahead to the end of the exp or some such
16:00:13 <ddarius> There is no way to disambiguate: \x -> undefined :: Int -> Int and (\x -> undefined) :: Int -> Int
16:01:00 <mmorrow> yeah, you're right, lemme find the particular comment i'm thinking of so we can disambiguate the situation regarding ambiguity
16:05:21 <mmorrow> ah, it's not *one* comment, but a series of them regarding various variations on that situation, which are in the "Conflicts: 38 shift/reduce (1.25)" comment block starting around line 107
16:05:29 <mmorrow> http://darcs.haskell.org/ghc/compiler/parser/Parser.y.pp
16:11:18 <marcot> Where do I get doc about Endo?
16:11:22 <marcot> Data.Monoid.Endo?
16:12:13 <ddarius> :t Endo
16:12:14 <lambdabot> forall a. (a -> a) -> Endo a
16:12:32 <ddarius> @src Endo mappend
16:12:33 <lambdabot> Source not found. Wrong!  You cheating scum!
16:12:36 <mmorrow> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Monoid.html#t%3AEndo
16:12:37 <lambdabot> Title: Data.Monoid, http://tinyurl.com/y5qk9n
16:12:56 <mmorrow> haha, "Source not found. Wrong!  You cheating scum!"
16:18:11 <tusho> loeb
16:21:10 <povman> AAGHAHG ok you _cannot_ run hopenGL code in ghci
16:21:41 <tusho> povman: not suprised
16:21:42 <povman> that is SO not documented anywhere
16:22:04 <povman> tusho: why?
16:22:13 <tusho> it just seems likely
16:22:29 <povman> why should it be different to compiling?
16:22:35 <dons> povman: well, it is a little surprising, but ghci does have some limitations on what FFI calls can be accessed through the bytecode interpreter
16:22:46 <povman> ah
16:22:56 <dons> so a very large, complicated FFI binding like opengl might involve some corner cases the bytecode interpreter in ghci can't handle
16:23:03 <dons> while of course, native code is fully compatible
16:23:23 <dons> remember ghc is like gcc + python in one system. full native code compiler, and bytecode interpreter :)
16:23:28 <povman> right. that would explain why it starts displaying a window then dies
16:23:42 <dons> it's worth reporting these things though
16:23:48 <dons> since the goal is to have everything work everywhere.
16:23:58 * povman checks trac
16:24:21 <marcot> This is not very much a documentation...
16:24:28 <marcot> It just shows the type definitions..
16:24:33 <dons> marcot: which library?
16:24:41 <marcot> Endo
16:24:51 <dons> inside Data.Monoid?
16:24:51 <marcot> I asked for some doc..
16:25:07 <ddarius> marcot: There should be a link to the source.  The source says it all.
16:25:13 <dons> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Monoid.html
16:25:13 <ddarius> There is not much to say about Endo.
16:25:14 <lambdabot> Title: Data.Monoid, http://tinyurl.com/y5qk9n
16:25:21 <dons> yep, it looks a little underdocumented. examples would be good
16:25:38 <dons> but what more do you need than "The monoid of endomorphisms under composition" :)
16:25:45 <mmorrow>  :)
16:26:00 <marcot> Some motivation to use, examples... =)
16:26:03 <dons> seriously though, if you put together some small examples, patches are welcome.
16:26:15 <povman> marcot: you put an a->a function in Endo, then mappend composes more a->a functions onto it
16:26:19 <dons> since i guess you have some use of Endo in mind?
16:26:31 <ddarius> marcot: While it is definitely handy, it doesn't need to be motivated.  If you don't need it, don't use it.
16:26:50 <dons> an example abstracting over say, dlists, or something, might be nice.
16:26:57 <Zao> povman: GLUT seems to work quite fine in ghci here on windows with 6.8.3
16:27:00 <marcot> I have, it's used in XMonad.
16:27:04 <marcot> And I'm reading the code...
16:27:06 <dobblego> what does (a -> b)'s mappend look like?
16:27:07 <dons> Endo is? huh.
16:27:12 <ddarius> dons: Are DLists a type synonym or a newtype?
16:27:19 <dons> dobblego: (.) ?
16:27:27 <dons> id and (.)
16:27:32 <ddarius> dobblego: That one is pointwise
16:27:34 <povman> around here, everything is (.)
16:27:42 <ddarius> Monoid b => Monoid (a -> b)
16:27:45 <povman> Zao: i'm using mac os x with 6.8.1 :/
16:27:48 <dobblego> how does (.) type-check? since (a -> b) -> (a -> b) -> a -> b ?
16:27:56 <dobblego> ah
16:28:00 <dons> instance Monoid b => Monoid (a -> b) where mempty _ = mempty mappend f g x = f x `mappend` g x
16:28:15 <dons> newtype Endo a = Endo { appEndo :: a -> a }
16:28:15 <dons> instance Monoid (Endo a) where mempty = Endo id Endo f `mappend` Endo g = Endo (f . g)
16:28:16 <dobblego> with (Monoid b) =>, I undertsand :)
16:28:21 <dons> yeah
16:28:24 <dobblego> thanks
16:28:57 <marcot> I think I got it..
16:29:23 <dons> ddarius: newtype DList a = DL { unDL :: [a] -> [a] }
16:29:34 <mmorrow> > let times2 = Endo (*2) ; f = mconcat (replicate 8 times2) in appEndo f 2
16:29:35 <lambdabot>  512
16:30:11 <mmorrow> > let times2 = (*2) ; f = foldl (.) id (replicate 8 times2) in f 2
16:30:12 <lambdabot>  512
16:30:19 <dons> marcot: ah, Endo's in xmonad are use for composing manageHooks
16:30:43 <ddarius> dons: Presumably DList is already an instance of Monoid?
16:30:45 <dobblego> duh, it turns out I've written the (a -> b) Monoid myself in Scala :)
16:30:55 <tusho> xz
16:30:59 <SamB> ddarius: I sure hope so, I wrote the instances long enough ago
16:31:01 <dons> ddarius: right.
16:31:17 <dons> dobblego: all your concepts are already in base
16:31:30 <dons> or however the phrase goes
16:31:32 <povman> must.. resust...
16:31:38 <ddarius> all your concepts are belong to base
16:31:42 <dons> all your concepts are in your base, killing your dudes?
16:31:47 <vixey> how come for a parser you do like
16:31:49 <dobblego> dons, sadly, not true for Scala (they hate abstraction over there)
16:31:52 <vixey> file = sepBy line spaces
16:31:52 <vixey> ?
16:32:00 <vixey> it says unexpected end of input
16:32:01 <SamB> well, yes, if dons is quoting newtypes ... since I put those in at the same time
16:32:01 <vixey> expecting space
16:32:16 <ddarius> vixey: Because eof is not whitespace.
16:32:20 <dons> SamB is often bitter and snarky. so sad, in someone so young.
16:32:25 <mmorrow> lol
16:32:53 <povman> i really don't understand why newtype even exists
16:33:05 <SamB> dons: well, I seem to remember having a long delay between when I wrote the code and when you released 0.2 ;-)
16:33:17 <dons> well, the code is circa 2002
16:33:17 <SamB> dons: so I wasn't positive the latter had actually happened yet
16:33:30 <ddarius> dons: Really?
16:33:32 <SamB> that was 2002???
16:33:49 <dons> Mon Dec 11 20:14:17 PST 2006  Samuel Bronson * Newtypify, add Monoid instance, add cons
16:34:00 <vixey> file = sepBy line spaces >> spaces >> eof
16:34:00 <dons> Tue Dec 12 21:25:39 PST 2006  Don Stewart * bump version
16:34:09 <vixey> doesn't work either though..
16:34:17 <dons> Thu Jan 25 00:18:19 PST 2007  Don Stewart tagged 0.2
16:34:19 <SamB> Sun Dec 10 22:21:53 EST 2006  Don Stewart <dons@cse.unsw.edu.au>
16:34:19 <SamB>   * Initial import of dlist package
16:34:26 <dons> SamB: yeah, imported from cvs.
16:34:31 <SamB> ah
16:34:45 <dons> from my honours thesis.
16:34:49 <marcot> dons: yes, I noticed, but I can't get, since I thought WindowSet was not (a -> a)
16:34:55 <dons> based on chak's code , from '99 or so
16:34:58 <ddarius> vixey: Will spaces succeed even if there are no spaces?
16:34:59 <SamB> okay, in that context the delay wasn't too bad
16:35:02 <dons> back when he was still a prolog programmer
16:35:02 <marcot> sorry, I got it.
16:35:17 <marcot> appEndo is a -> a, not the endo type..
16:35:24 <vixey> yes
16:35:24 <SamB> but it seemed like a long time at the time
16:35:26 <ddarius> dons: He was a prolog programmer?
16:35:36 <dons> ddarius: functional logic programming
16:35:55 <ddarius> dons: Ah yes, I think I'm recalling something like that.
16:36:02 <vixey> who ?
16:36:14 <ddarius> Manuel Chakravarty
16:36:18 <ddarius> ChilliX
16:36:27 <dons> see, e.g. "On the Relation Between a Rewriting Computational Model for Functional Logic Languages and Or-Parallelism." 1996
16:36:35 <dons> parallel functional logic programming
16:37:25 <dons> SamB: fwiw, the original dlist came from http://www.cse.unsw.edu.au/~chak/papers/Cha99.html
16:37:27 <lambdabot> Title: Research Papers of Manuel Chakravarty
16:37:36 <dons> which was based on some Prolog stuff
16:37:50 <dons> of course, ShowS has been around forever as well
16:37:52 <ddarius> Presumably difference lists.
16:38:07 <ddarius> Though dlists are rather different from Prolog difference lists despite the name.
16:43:17 <vixey> :(
16:43:27 <vixey> @hoogle readFile
16:43:28 <lambdabot> Prelude.readFile :: FilePath -> IO String
16:43:28 <lambdabot> System.IO.readFile :: FilePath -> IO String
16:43:28 <lambdabot> Data.ByteString.readFile :: FilePath -> IO ByteString
16:46:47 <vixey> file = do result <- many line ; eof ; return result
16:46:47 <vixey> parseFile filename = parseFromFile file filename
16:46:56 <vixey> see even with this there are problems using unicode ....
16:47:37 <vixey> could be my fault. ..
16:47:41 <glguy> use the readFile in the utf8-string package
16:47:47 <glguy> if you are trying to read utf8
16:47:59 <glguy> under the System.IO.UTF8 module
16:48:12 <ddarius> vixey: Haskell's main problems with Unicode currently are simply the IO functions.
16:49:32 <dons> utf8-string dudes. or the encoding package for other things.
16:51:44 <vixey> thank you this works
16:51:53 <vixey> import System.IO.UTF8
16:51:53 <vixey> import Text.ParserCombinators.Parsec hiding (parseFromFile)
16:51:53 <vixey> parseFromFile parser filename = readFile filename >>= return . parse parser filename
16:52:07 <dons> good show.
16:52:25 <ddarius> parse parser filename <$> readFile filename
16:52:59 <ddarius> dons: We just need to get the standard fixed.
16:53:24 <dons> a fair bit of progress was made early in the year on encoded IO for base.
16:53:32 <dons> not sure who's in charge of that now.
16:53:45 <dons> thankfully, it hardly matters, give a useful haskell platform based on hackage.
16:54:44 <ddarius> dons: Yeah, we pretty much have the "existing practice" down
16:55:17 <ddarius> vixey: Also: file = many line <* eof
16:55:33 <ddarius> vixey: The Applicative combinators are very nice for parsing.
16:56:23 <dons> hackage has meant base standardisation/merging is far less important than it needs to be, which is good for balancing backwards maintainability with new ideas.
16:56:30 <dons> s/than it used to be/
16:57:28 <ddarius> dons: The problem is having a bunch of "broken" functions be the default.
16:59:37 <vixey> now I need to figure out how to write a typechecker in haskell
16:59:51 <dons> thih is on hackage.
17:00:06 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/thih
17:00:08 <lambdabot> Title: HackageDB: thih-1.0
17:03:19 <ddarius> We need to put chunk in Data.List
17:04:45 <vixey> why not make length :: Num n => [a] -> n, and get rid of genericLength in place of specificLength :: [a] -> Int
17:07:28 <ddarius> And a generalization of unlines
17:07:40 <ddarius> er lines
17:08:39 <ddarius> lines = split ('\n'==); words = map (dropWhile isSpace) . split isSpace
17:09:18 <glguy> repeated whitespace handling?
17:09:38 <MyCatVerbs> @src lines
17:09:38 <lambdabot> Source not found. Where did you learn to type?
17:09:40 <glguy> while in other cases you'd want the empty elements
17:09:50 <glguy> part of why the generalized version isn't in Data.List
17:10:03 <ddarius> Actually my definition of words is broken.
17:12:31 <povman> @seen Syzygy
17:12:31 <lambdabot> I haven't seen Syzygy.
17:12:57 <ddarius> Having a split function that is an immediate generalization of lines seems reasonable as opposed to requiring someone to completely rewrite it for tabs or semicolons or commas or a single whitespace character etc.
17:13:37 <ddarius> That it doesn't catch all use-cases isn't a problem.  We can add more than one function.
17:15:15 <dobblego> why not a function like group that splits the list, then another like lines that filters the extraneous lists that contain '\n' and space?
17:17:49 <BONUS_> @src join
17:17:49 <lambdabot> join x =  x >>= id
17:19:13 <ddarius> :t intercalate
17:19:14 <lambdabot> forall a. [a] -> [[a]] -> [a]
17:19:40 <ddarius> :t (mconcat .) . intersperse
17:19:41 <lambdabot> forall a. (Monoid a) => a -> [a] -> a
17:25:37 <roconnor> Refactoring code in Haskell is sooo nice.  Once it typechecks again, it works!
17:26:05 <ddarius> Why does it ever stop type checking?
17:26:23 <dobblego> don't forget to run the QC
17:26:31 <byorgey> roconnor: hear, hear!
17:30:44 <ddarius> I wonder if translating Conal's Reactive stuff to C# would actually make any of what I do easier.
17:31:42 <roconnor> ddarius: during the middle of refactoring it stops typechecking
17:32:10 <roconnor> ddarius: in fact, I'm so lazy, that when I change one bit of code, I sometimes just let the type errors tell me where more changes are needed.
17:32:26 <dobblego> heh, I do that :)
17:33:59 <roconnor> I guess without a large set of testcases, refactoring code in untyped languages must be impractical.
17:34:40 <dobblego> roconnor, there are two people right next to me right now who would be nodding their heads wildly (working with Ruby)
17:34:42 <ddarius> In several cases they have tool support, but then so do we.
17:34:56 <roconnor> oh, they have tool support
17:35:04 <roconnor> (obvious the type checker is my tool support)
17:35:05 <dobblego> fsvo tool
17:35:11 <roconnor> fsvo?
17:35:23 <ddarius> @google Smalltalk refactoring browser
17:35:24 <lambdabot> http://st-www.cs.uiuc.edu/users/brant/Refactory/
17:35:24 <lambdabot> Title: Refactoring Browser
17:35:33 <ddarius> @where hare
17:35:34 <lambdabot> http://www.cs.kent.ac.uk/projects/refactor-fp/
17:35:35 <dobblego> they don't have no tools, but they don't have a type checker either
17:35:52 <roconnor> I didn't realize they had tools to help.
17:36:51 <ddarius> roconnor: The term "refactoring" came out of the dynamically typed world.
17:37:46 <roconnor> oh
17:37:56 <roconnor> what do typed language people do?
17:38:15 <ddarius> We do the same thing.
17:38:19 <roconnor> :)
17:42:27 <dons> we write code.
17:42:46 <roconnor> hmm
17:42:46 <dons> don't we just factor code?
17:43:10 <roconnor> actually, a few of my changes could potentially produce errors without producing type errors.
17:43:24 <roconnor> buy they are relatively rare
17:43:33 <roconnor> and possibly a sign I need more types. :)
17:43:55 <dons> yeah
17:44:07 <dons> refactoring bugs are often a sign of not enough type informatoin
17:44:20 <dobblego> hence, don't forget to run your QC ;)
17:44:31 <dons> quite so
17:45:41 <ddarius> refactoring shouldn't produce (or remove) bugs.
17:48:23 <hpaste>  morrow pasted "polymorphic map in C => commented gcc asm output" at http://hpaste.org/8754
17:49:49 <hpaste>  morrow annotated "polymorphic map in C => commented gcc asm output" with "uncommented gcc asm output" at http://hpaste.org/8754#a1
17:50:38 <mmorrow> does anyone know what this does?
17:50:40 <mmorrow> testl	%edi, %edi
17:51:56 <ddarius> It checks if edi is zero or not.
17:52:28 <roconnor> dobblego: Charts doesn't have any quick check properties at the moment. :(
17:52:55 <mmorrow> ddarius: ah i see, just found a description of testl online
17:53:15 <lxuser> mmorrow, this is offtopic. try ##asm
17:53:24 <mmorrow> lxuser: thx
17:53:36 <mmorrow> lxuser: :)
17:54:15 <mmorrow> cool, another channel to add to the defaults
17:54:38 <ddarius> I should write something in assembly.  It's been a long while.
17:56:13 <mmorrow> i'm finding gcc -S to be infinitely entertaining and instructive
17:56:16 <vixey> what sort of thing would be written in assembly?
17:56:46 <mmorrow> well, what sort of thing would generate assembly? (i think the question should be)
17:56:53 <Zao> Project Euler problems, if you're to believe the boards there.
17:57:03 <lxuser> mmorrow, you can also look at SSA intermediate representations.
17:57:32 <mmorrow> lxuser: cool, do you mean i can get gcc to dump that, or ...?
17:57:47 <lxuser> mmorrow, yes
17:58:00 <mmorrow> sweet
17:59:26 <lxuser> mmorrow, unfortunately, the dumps are not really a viable programming language or anything like that. that's mostly due to a political problem within the FSF.
17:59:34 <roconnor> I'm not sure how I feel about error bars that are cutoff outside a chart.
18:00:39 <roconnor> actually I think I do know how I feel
18:00:50 <roconnor> but I should put that change in a separate patch
18:01:19 <mmorrow> lxuser: hmm, interesting.
18:02:15 <ooxwo> Anybody here work through sigfpe's 'you could have invented monads' post?  I'm having trouble getting the random number section to compile.
18:02:38 <ooxwo> The types are not working out
18:03:23 <ooxwo> random :: StdGen -> (a,StdGen)
18:03:38 <vixey> ooxwo: I've read that
18:04:21 <ooxwo> vixey:  Are there further type constraints going on that he simplifies away in that Random part?
18:04:26 <dogbite> anybody have an idea why haskell is telling me that
18:04:28 <dogbite> > 100.0 / 724.71 * 726.01
18:04:29 <lambdabot>  100.17938209766663
18:04:44 <dogbite> but 'bc' tels me
18:04:45 <dogbite> 100.1167
18:05:09 <dogbite> oh
18:05:11 <dogbite> scale
18:05:17 <dogbite> interesting
18:05:37 <roconnor> bc tells me it is 0
18:05:40 <roconnor> stupid bc
18:05:41 <dogbite> :-)
18:05:50 <vixey> > 100.0 / 724.71 * 726.01 :: CReal
18:05:51 <lambdabot>  100.1793820976666528680437692318306632998027
18:05:52 <dogbite> for some reason i was thinking scale=4 was enough
18:06:25 <dogbite> i'll go back and study some numerics.  back to college for me.
18:06:42 <roconnor> I'm glad I use ghc for all my calculations
18:06:45 <roconnor> ghci
18:07:02 <ooxwo> I'm trying to write a simple random function that takes a number and a StdGen and multiplies it by the resulting random number, but can't get the type right.
18:07:14 <ddarius> ghc -O2 --expression '2*2'
18:07:19 <vixey> yeah bc is rubbish
18:07:27 <ooxwo> aaa n gen = (n*) $ random gen
18:07:29 <dons> so something like, f :: Num a => a -> StdGen g -> a ?
18:07:30 <vixey> it's really not a good tool at all
18:07:59 <ooxwo> dons:  Yeah basically, let me try that
18:08:40 <dogbite> vixey: alias bc=ghic
18:09:07 <freerainer> hi all
18:09:15 <roconnor> hi freerainer
18:09:18 <povman> hullo
18:09:26 <ooxwo> dons:  Except the function returns a tuple of the result and the modified StdGen
18:09:55 <ooxwo> dons:  like -- f :: Num a => a -> StdGen -> (a,StdGen)
18:11:41 <ooxwo>     Occurs check: cannot construct the infinite type: a = (a, StdGen)
18:11:54 <ooxwo> Ah okay, here's where I must be going wrong
18:12:14 <ooxwo> the random from the article returns a tuple of the value and the resulting StdGen
18:12:29 <ooxwo> But it looks like the Random random just returns a value
18:12:30 * freerainer enthusiastically dives into first pages of haskell tutorial
18:13:15 <ooxwo> No, but if I check random's type in ghci it's random :: (RandomGen g, Random a) => g -> (a, g)
18:13:15 <ooxwo>  
18:14:47 <povman> ooxwo: random :: RandomGen g => g -> (a, g) -- n * (random gen) is incorrect
18:15:44 <povman> you want aaa n gen = first (n*) $ random gen
18:16:14 <ooxwo> Yes I see that now.  Here is my new version: f n gen = let (n', gen') = random gen in (n*n', gen')
18:18:52 <povman> @src first
18:18:52 <lambdabot> Source not found.
18:19:20 <ooxwo> povman:  is it not fst for tuples?
18:19:26 <povman> not quite
18:19:28 <povman> :t first
18:19:28 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
18:19:29 <ooxwo> @src fst
18:19:29 <lambdabot> fst (x,_) =  x
18:19:34 <povman> :t fst
18:19:35 <lambdabot> forall a b. (a, b) -> a
18:19:45 <vixey> :t first
18:19:46 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
18:19:48 <povman> first applies a function to the first element of a tuple
18:20:12 <povman> first (*2) (1, 3)
18:20:15 <ooxwo> Ah, yes that is useful
18:20:22 <ooxwo> (2,3)
18:20:24 <ooxwo> Nice
18:20:29 <povman> thanks 'lambdabot' :)
18:20:39 <ddarius> Try adding > next time.
18:20:45 <povman> > first (*2) (1, 3)
18:20:46 <lambdabot>  (2,3)
18:20:58 <ooxwo> lambdabot is a trusty companion
18:21:12 <ddarius> @vixen are you a trusty companion?
18:21:13 <lambdabot> i truely am
18:21:22 <povman> @quote russia
18:21:22 <lambdabot> vegai says: in Soviet Russia, YOU blow up GHC's brain!
18:22:10 <povman> rofl
18:22:12 <freerainer> @quote monad
18:22:12 <lambdabot> Korollary says: You know, dons actually knows your phone number. He'll be calling you soon to check whether you have any questions about monad transformers.
18:22:42 <vixey> @quote
18:22:42 <lambdabot> swiert says: Of course! Who can live without covariant homfunctors?
18:23:13 <mmorrow> who can live w/out contravariant homfunctors??
18:23:29 <ooxwo> Does it just keep track of what everyone says?  Or do you save certain ones?
18:23:50 <povman> ooxwo: certain ones
18:23:55 <povman> @quote zygohistomorphic
18:23:55 <lambdabot> No quotes match. There are some things that I just don't know.
18:24:08 <vixey> @quote
18:24:08 <lambdabot> jlouis says: Q: When does one know he has programmed too much Haskell? A: When he uses == and /= in everyday IRC chat or when he tries to fix a relationship by passing himself as a continuation
18:24:13 <ddarius> @quote ooxwo
18:24:13 <lambdabot> No quotes match. Just what do you think you're doing Dave?
18:24:33 <ooxwo> Apparently I haven't been around long enough
18:24:37 <ddarius> That quote is from the old quotes page.  Long before lambdabot grew a @quote feature.
18:25:14 <ddarius> The quotes page was so much nicer than @quote.
18:25:35 <ooxwo> ddarius:  Really?  why's that?
18:26:00 <roconnor> darcs is fun
18:26:17 <povman> if a functor is a morphism between categories, where'd fmap come from?
18:26:19 <ddarius> Because there was a higher bar to getting on the quotes page, it was more browseable, and it was more varied.
18:26:19 <vixey> @quote
18:26:20 <lambdabot> vixen says: If you see this, gentle sir, know that you are being trolled by a poorly configured VixenLove program
18:26:38 <ddarius> povman: A category has objects and arrows.  fmap is the action of the functor on arrows.
18:27:24 <ddarius> Data.Complex should have more functions...
18:27:31 <ooxwo> @quote ddarius
18:27:31 <lambdabot> ddarius says: Alternatively, it could be arrived at from the continuity properties of exponentials.
18:28:18 <povman> ddarius: i don't see the connection between that and the type of fmap
18:28:20 <povman> :t fmap
18:28:21 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:28:45 <Cale> povman: think of it as fmap :: (Functor f) => (a -> b) -> (f a -> f b)
18:28:45 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
18:29:00 <mmorrow> Cale: heh, i was just typing that *exactly*
18:29:44 <solrize_> > fmap (+1) [1..5]
18:29:44 <lambdabot>  [2,3,4,5,6]
18:29:50 <povman> why not (f a -> f b) -> (g a -> g b)?
18:30:42 <solrize_> > fmap (++ [2,3]) (Just [1..5])
18:30:42 <lambdabot>  Just [1,2,3,4,5,2,3]
18:31:07 <solrize_> :t fmap (++ [2,3]) (Just [1..5])
18:31:07 <lambdabot> forall t. (Enum t, Num t) => Maybe [t]
18:31:10 <povman> i understand what it does in haskell terms, but not how it relates to CT. what is the haskell equivalent of a category?
18:31:12 <solrize_> :t fmap (++ [2,3])
18:31:12 <mmorrow> :t fmap (show . (+1))
18:31:12 <lambdabot> forall t (f :: * -> *). (Functor f, Num t) => f [t] -> f [t]
18:31:12 <lambdabot> forall a (f :: * -> *). (Functor f, Num a) => f a -> f String
18:31:23 <Cale> povman: It's taking an arrow in the category Hask to the image of that arrow under the functor f
18:31:25 <mmorrow> :t \f -> fmap (show . f)
18:31:25 <lambdabot> forall a a1 (f :: * -> *). (Functor f, Show a) => (a1 -> a) -> f a1 -> f String
18:31:28 <solrize_> povman Hask is the category of haskell types
18:31:36 <solrize_> where functions are morphisms
18:31:50 <vixey> :t fmap . (show .)
18:31:50 <lambdabot> forall a (f :: * -> *) a1. (Show a1, Functor f) => (a -> a1) -> f a -> f String
18:31:54 <Cale> povman: Note that instances of the Functor class are actually *endo*functors on the category of Haskell types.
18:32:10 <solrize_> @goo endofunctor
18:32:10 <Cale> (since that's the only category which we really concern ourselves with)
18:32:11 <lambdabot> No Result Found.
18:32:12 <mmorrow> :t funct f = M.fromList . f . M.toList
18:32:13 <lambdabot> parse error on input `='
18:32:22 <mmorrow> :t \f -> M.fromList . f . M.toList
18:32:22 <lambdabot> forall k a k1 a1. (Ord k) => ([(k1, a1)] -> [(k, a)]) -> M.Map k1 a1 -> M.Map k a
18:32:23 <Cale> An endofunctor is just a functor C -> C for some category C
18:32:24 <vixey> what's good about thinking of haskell types as a category?
18:32:55 <ddarius> vixey: We can apply categorical ideas to it.
18:32:58 <mmorrow> you can apply all the categorical machinery then
18:33:11 <Cale> vixey: They very naturally are a category. I suppose the benefit is that you get all the language of category theory to apply, which gives you good ideas for abstractions.
18:33:24 <vixey> I don't know what that is .. or why you would do that
18:33:33 <vixey> can you prove programs work or something ?
18:33:41 <vixey> oh which abstractions ?
18:33:49 <vixey> things like Monads.. Functors.. I guess
18:33:49 <ddarius> monad, functor, applicative functor
18:33:59 <povman> vixey: such as zygohistomorphic prepromorphisms!
18:34:02 <ddarius> pairs, sums, initial algebras, final coalgebras
18:34:04 <ddarius> recursion schemes
18:34:27 <solrize_> can someone explain initial algebras?
18:34:32 <ddarius> vixey: The main benefit of category theory is that it is a common language.
18:34:45 <solrize_> vixey did you see the category theory wikibook?
18:35:05 <vixey> I see
18:35:25 <vixey> I read a little bit about initial algebras in my book but I didn't really retain any of it
18:35:33 <ddarius> vixey: So I can take ideas from logic, view them in a cartesian category, et voila immediately relate that to the cartesian category that the STLC corresponds to and et voila again we have the Curry-Howard correspondence.
18:36:54 <vixey> a cartesian category is just one which any two object in it there is also the pair of objects ?
18:36:59 <mmorrow> well, the cat of haskell types is a category of categories of ..., where the (first level of) inner categories are individual types with morphisms functions (t -> t)
18:37:06 <ddarius> Oops, + closed
18:37:15 <ddarius> I should have just used CCC
18:37:24 <povman> so why doesn't Functor map types in Hask to other types?
18:37:36 <ddarius> A Functor, does.
18:37:43 <vixey> oh! -> is the "cartesian"
18:37:51 <mmorrow> povman: Functor could be a functor at various different levels in this cat of cats of ...
18:37:57 <ddarius> vixey: No, you were right.  -> is the "closed"
18:38:11 <ddarius> mmorrow: wtf are you talking about?
18:38:12 <vixey> is there a type of category for dependent products instead of -> ?
18:38:22 <povman> i thought a functor mapped objects to objects and morphisms to morphisms
18:38:26 <mmorrow> ddarius: my view of the situation :)
18:38:29 <povman> but fmap only does the latter
18:38:47 <ddarius> vixey: You can model dependent types in CT.  One way of doing this leads to what is called a comprehension category.
18:39:17 <mmorrow> ddarius: i think thinking of a cat where the objects aren't cats themselves and this enclosing cat isn't embedded in another enclosing cat as rather limiting ;)
18:39:36 <ddarius> povman: Yes, fmap is only the action on arrows (functions).  The objects are -types- not -values-.  A mapping on types is a -type constructor-, i.e. what you are making an instance of Functor.
18:40:19 <solrize_> povman did YOU see the category theory wikibook?  it is really good
18:40:24 <povman> ohhh
18:40:27 <vixey> mmorrow: they aren't all in the same category?
18:40:33 <ddarius> mmorrow: That's nice but if you don't define what these "inner" categories are, it is pointless.  I doubt you could usefully define an infinite tower of them (especially going down).
18:40:34 <povman> ok thanks
18:40:40 <povman> solrize_: i will now
18:40:47 <mmorrow> vixey: why? i havent defined them
18:40:52 <mmorrow> ddarius: yes, exactly
18:41:13 <vixey> solrize_: oh I *book* I thought you mean just the wikipage
18:41:16 <mmorrow> ddarius: wait, i'm only looking one level up and down
18:41:18 <povman> do you mean http://en.wikibooks.org/wiki/Haskell/Category_theory
18:41:18 <lambdabot> Title: Haskell/Category theory - Wikibooks, collection of open-content textbooks
18:41:19 <povman> ?
18:41:24 <solrize_> povman yes that one
18:41:24 <mmorrow> ddarius: (at any one time)
18:41:38 <ddarius> You still have to define the whole tower.
18:42:12 <mmorrow> ddarius: why? the objects which are cats themselves aren't necessarily cats of cats
18:42:25 <lxuser> ddarius, dependent types are the STLC-side equivalents of (constructive) forall and exists.
18:42:37 <ddarius> mmorrow: That's what you suggested before "cat of cats of ..."
18:43:13 <mmorrow> ddarius: yes, you're correct, but i meant what my correction says
18:43:14 <ddarius> lxuser: Dependent type theory is on the same "side" as STLC.
18:43:29 <vixey> lxuser: STLC-side ?...
18:43:31 <ddarius> mmorrow: Okay.  So what are these three categories.
18:43:37 <vixey> side of what? the lambda-cube ?
18:43:39 <roconnor> crap, I do have a bug
18:44:00 <povman> what's a 'lamba cube'
18:44:11 <ddarius> povman: Google will tell you.
18:44:43 <solrize_> stlc == simply typed lambda calculus
18:44:57 <povman> this is the kind of stuff that scares away beginners
18:45:32 <solrize_> well it scares away some and attracts others :)
18:45:45 <lxuser> mmorrow, looks like the most basic model of dependent types is "Locally-Closed Cartesian Categories".
18:45:56 <ddarius> povman: Why should someone who readily acknowledges that they don't understand everything about a topic (i.e. readily acknowledge that they are beginners) be scared away when they see something they don't understand?
18:46:00 <vixey> yeah we verged off topic
18:46:00 <vixey> it's still interesting though
18:46:05 <mmorrow> ddarius: lets drop the outermost enclosing category for now (since i just added that "just cuz"), so then Hask is a category of cats with cats as objects and morphisms functors of these cats, where the inner cats are monoids, one for each type T, w/ morphisms monoid endos.
18:46:07 <solrize_> berendregt's article about the lambda cube is dense but readable
18:46:38 <ddarius> mmorrow: What are these monoids?  What are the elements and what is the operation?
18:46:48 <vixey> lxuser: do you know any texts about that (ideally online..)?
18:46:52 <mmorrow> ddarius: implicitly using the fact that a monoid is a cat with a single object and only id (==endo) morphs
18:47:20 <ddarius> mmorrow: I understand that, but that means the arrows of the "outer" cat are monoid homomorphisms.  What are these monoids?
18:47:21 <mmorrow> ddarius: T a type. T is a monoid under (.) of morphisms (T -> T)
18:47:32 <mmorrow> ddarius: so then T is a cat
18:47:38 <solrize_> vixey, text about what?
18:47:50 <ddarius> mmorrow: So you are saying a type T is the set of functions (T -> T) ?
18:47:51 <mmorrow> ddarius: since a monoid may be alternatively thought of as a cat ...
18:47:55 <ddarius> (plus the monoid operations)
18:48:17 <vixey> Locally-Closed Cartesian Categories
18:48:31 <vixey> or comprehension categories
18:48:36 <mmorrow> ddarius: no, a type T is a type T, a function (T -> T) is a morphism of T to itself
18:49:00 <ddarius> mmorrow: Okay.  T isn't a monoid.  T -> T is.  If the objects are the types T, then the objects aren't monoids.
18:49:24 <mmorrow> ddarius: yes
18:49:31 <mmorrow> ddarius: that is what i mean
18:49:36 <mmorrow> wait
18:49:41 <solrize_> that meaning of "comprehension category" doesn't have many google hits
18:49:58 <ddarius> vixey: Bart Jacobs PhD thesis is something free but very hard reading.  He has a book based upon it that I suspect is much more readable, but it is much more expensive.
18:50:15 <ddarius> vixey: The Prospectus of it is online though and a decent introduction.
18:50:18 <mmorrow> ddarius: i'm saying nothing about any particular instance of any type T
18:50:28 <mmorrow> ddarius: just the type T itself
18:50:53 <vixey> ok thank you
18:50:55 <ddarius> The notion of ω-category is somewhat fuzzy and not all that useful for programming.  About a 2-category is what is useful.
18:50:56 <solrize_> the mathematical descriptions of these things are pretty disconnected from the CS ones
18:51:11 <ddarius> mispaste
18:51:12 <ddarius> http://www.cs.ru.nl/B.Jacobs/CLT/bookinfo.html
18:51:13 <solrize_> http://en.wikipedia.org/wiki/Cartesian_closed_category
18:51:13 <lambdabot> Title: Categorical Logic and Type Theory
18:51:29 <mmorrow> ddarius: but we're just talking about 2-cats here
18:51:50 <ddarius> mmorrow: We can form Hask into a 2-category, but not the way you seem to be trying to.
18:52:08 <ddarius> I was going to say that earlier but I decided not to.
18:52:23 <mmorrow> ddarius: i'm going to write this up rigorously (however that turns out) and i'll get back to you with a link :)
18:52:26 <ddarius> solrize: Actually, CCCs are rather easy to relate to programming practice.
18:52:40 <ddarius> mmorrow: Okay.
18:52:43 <paczesiowa> why newtypes can't use existentials?
18:52:47 <ooxwo> :t first
18:52:49 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
18:53:04 <ooxwo> :m first
18:53:17 <paczesiowa> Control.Arrow
18:53:33 <ooxwo> How do I ask lambdabot what module a function is in?
18:53:42 <ddarius> ooxwo: @index or @hoogle
18:53:49 <ooxwo> @index first
18:53:49 <lambdabot> Control.Arrow
18:53:55 <ddarius> vixey: Andrew Pitts also has a decent set of lecture notes or something but I don't recall if he gets to dependent types.
18:54:08 <solrize_> ddarius that book looks good
18:54:09 <ooxwo> Ha, thanks paczesiowa, ddarius
18:54:18 <ooxwo> @hoogle first
18:54:18 <lambdabot> Control.Arrow.first :: Arrow a => a b c -> a (b, d) (c, d)
18:54:19 <lambdabot> Data.Monoid.First :: newtype First a
18:54:19 <lambdabot> Data.Monoid.First :: Maybe a -> First a
18:55:06 <ooxwo> Wow that is quite a type signature
18:55:39 <ooxwo> types of types of types
18:55:47 <ddarius> http://scholar.google.com/scholar?hl=en&lr=&cluster=12681665015979567802
18:55:47 <ooxwo> And what is that, tupled types?
18:55:48 <lambdabot> Title: - Google Scholar, http://tinyurl.com/5u73ba
18:55:55 <ddarius> Ah it does.
18:56:14 <ooxwo> I have much to learn
18:57:27 <lxuser> ddarius, I looked at the prospectus from that B.Jacobs book, and the categorical formalism seems rather contrived
18:57:40 <lxuser> compared to LCCC's and other approaches,
18:57:44 <solrize_> ooxwo, a b c isn't type of type of type, it's just two nested type constructors
18:58:01 <solrize_> :k State
18:58:05 <lambdabot> * -> * -> *
18:58:07 <solrize_> :k StateT
18:58:08 <lambdabot> * -> (* -> *) -> * -> *
18:58:14 <ddarius> lxuser: It's equivalent to LCCC and indexed categories.
18:58:29 <noecksit> > (1:) <$> Right ([2])
18:58:36 <lambdabot>  Right [1,2]
18:58:56 <noecksit> > (1:) <$> Left ([2])
18:58:57 <lambdabot>  Left [2]
18:59:29 <ooxwo> solrize_: so what is with the tupled type constructors?
18:59:30 <noecksit> oh wow, why isnt the function applicable on Left?
18:59:39 <andyjgill> @seen igloo
18:59:40 <lambdabot> igloo is in #darcs, #ghc and #haskell. I last heard igloo speak 5h 53m 1s ago.
18:59:54 <noecksit> it that because its supposed to represent error by convention?
19:00:00 <noecksit> *is
19:00:03 <ddarius> noecksit: (<$>) is just fmap
19:00:24 <ddarius> noecksit: That's the only way Either can be a functor in Haskell.
19:00:30 <noecksit> ddarius : i know
19:01:04 <ooxwo> a (b,d) (c,d) ?
19:01:22 <noecksit> hmm, but it doesnt throw errors that Left is not a Functor
19:01:53 <ddarius> noecksit: Left is a data constructor, a value.  Values aren't functors, type constructors are.
19:02:05 <vixey> Left is a function
19:02:06 <paczesiowa> ooxwo: that's like Either (Int,String) (Double,String) but parametrized over all the types
19:02:22 <Euler_> what function is used to map to an IO [a]
19:02:37 <solrize_> ooxwo hmm c and d are just types, b is a type constructor
19:02:40 <noecksit> mapM i think
19:02:49 <ooxwo> paczesiowa:  Ah, I see
19:03:09 <ooxwo> I was under the impression the types have to qualify the types further to the right
19:03:14 <Euler_> fmap (\x->isInfixOf x "1") (print "123")
19:03:15 <noecksit> @type mapM
19:03:15 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
19:03:19 <solrize_> ooxwo overall i'm not sure what that signature means
19:03:19 <Euler_> > fmap (\x->isInfixOf x "1") (print "123")
19:03:20 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `()'
19:03:52 <ooxwo> solrize_:  Ah, okay :)
19:03:59 <paczesiowa> ooxwo: if I were you I'd google some arrow tutorial
19:04:04 <noecksit> Euler_ : print doesnt return a list, hence its not mappable
19:04:07 <ooxwo> I notice I am spending a lot of time just puzzling over type expressions
19:04:14 <ddarius> ooxwo: The syntax of types is very similar to the syntax of values in Haskell. a b c at the type level is like f x y at the value level.
19:04:38 <ddarius> It's the application of a type constructor 'a', to two types 'b' and 'c'.
19:04:49 <ooxwo> ddarius:  So the leftmost one governs all of the ones on right, rather than each affecting the next
19:04:53 <ooxwo> That helps
19:05:03 <solrize_> ddarius but what is (b,d) where b::*->* ?
19:05:33 <ooxwo> paczesiowa:  Thanks for the lead
19:05:42 <vixey> solrize_: that's a kind error
19:05:52 <vixey> (,) :: * -> * -> *
19:06:00 <solrize_> vixey that's the signature i was saying i couldn't figure out
19:06:14 <solrize_> :t first
19:06:15 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
19:06:22 <vixey> if you want to think about it at the tye level, you can imagine
19:06:32 <vixey> (,) :: () -> () -> ()
19:06:43 <vixey> now if you try to put b :: () -> () in there
19:06:43 <solrize_> there (a b c) is a type
19:07:04 <vixey> :t let tuple = undefined :: () -> () -> () ; b = undefined :: () -> () in tuple b ()
19:07:05 <lambdabot>     Couldn't match expected type `()' against inferred type `() -> ()'
19:07:05 <lambdabot>     In the first argument of `tuple', namely `b'
19:07:05 <solrize_> so :t first ==   * -> (*->*->*) (*->*, *) (*, *)
19:07:24 <vixey> let a = (~>)
19:07:44 <vixey> (b ~> c) -> ((b,d) ~> (c,d))
19:08:00 <vixey> (~>) :: * -> * -> *, b :: *, c :: *, d :: *
19:08:01 <solrize_> :t (~>)
19:08:02 <lambdabot> Not in scope: `~>'
19:08:22 <vixey> I just call it ~> myself
19:09:58 <Euler_> neocksit, I think I miss typed
19:10:05 <Euler_> > fmap (\w-> isInfixOf "2" w) ["1","2","3"]
19:10:06 <lambdabot>  [False,True,False]
19:10:06 <solrize_> that book is out of print
19:10:54 <solrize_> there are some used copies for 92.8 USD :(
19:10:59 <Euler_> my question is about how to map to the list of strings if they have type IO
19:11:10 <solrize_> 778 pages!
19:11:20 <paczesiowa> Euler_: you mean IO [String]?
19:11:26 <Euler_> yes
19:11:32 <solrize_> liftM
19:11:59 <solrize_> > liftM (infixOf "2") ["1","2","3"]
19:12:00 <lambdabot>   Not in scope: `infixOf'
19:12:17 <solrize_> > liftM (infixOf "2") (return ["1","2","3"] :: IO [String])
19:12:18 <lambdabot>   Not in scope: `infixOf'
19:12:28 <solrize_> well except for that function being missing
19:13:44 <Euler_> liftM (\w-> isInfixOf "2" w) (return ["1","2","3"] :: IO [String])
19:13:50 <Euler_> > liftM (\w-> isInfixOf "2" w) (return ["1","2","3"] :: IO [String])
19:13:51 <lambdabot>  Couldn't match expected type `Char' against inferred type `String'
19:13:57 <paczesiowa> > (return ["1","2"] :: IO [String]) >>= mapM (\w -> return (isInfixOf "2" w))
19:13:58 <lambdabot>  <IO [Bool]>
19:14:43 <dmwit> paczesiowa: Why would you do that in the IO monad?
19:15:04 <paczesiowa> Euler_ wanted it that way
19:15:27 <paczesiowa> I think
19:15:39 <chessguy> @pl \w -> r (i 2 w)
19:15:40 <lambdabot> r . i 2
19:15:40 <vixey> lol
19:16:28 <newsham> ?let isInfixOf x = any (isPrefixOf x) . tails
19:16:35 <lambdabot> Defined.
19:16:57 <paczesiowa> > "2" `isInfixOf` "123"
19:16:58 <lambdabot> Terminated
19:17:21 <newsham> > "foo" `isInfixOf` "megafoobar"
19:17:22 <lambdabot> Terminated
19:17:22 <jsnx> @seen Cale
19:17:22 <lambdabot> Cale is in #haskell-overflow, #ghc and #haskell. I last heard Cale speak 44m 11s ago.
19:17:27 <newsham> whats with the termination
19:17:40 <ddarius> @undefine
19:17:40 <lambdabot> Undefined.
19:17:43 <Cale> hell9o
19:17:46 <ddarius> > isInfixOf
19:17:47 <lambdabot>  <[()] -> [()] -> Bool>
19:17:53 <Cale> er, hello :)
19:17:56 <ddarius> > "foo" `isInfixOf` "123"
19:17:57 <lambdabot>  False
19:18:11 <vixey> o_o
19:18:17 <ddarius> @let isInfixOf _ _ = True
19:18:17 <lambdabot> Defined.
19:18:20 <jsnx> Cale: I am trying to construct the diagram for this: http://hpaste.org/8756
19:18:20 <vixey> why is it [()] -> [()] _
19:18:21 <ddarius> > isInfixOf
19:18:21 <lambdabot> Terminated
19:18:25 <vixey> hi Cale
19:18:26 <ddarius> @undefined
19:18:26 <lambdabot> Undefined.
19:18:38 <ddarius> vixey: That's the extended defaulting.
19:18:52 <jsnx> it is a universal-construction-as-adjunction thing
19:19:01 <jsnx> just a sec, let me add more information
19:19:12 <roconnor> ack! bug caused by shadowing variables
19:19:23 <ddarius> roconnor: It's been there for a while now.
19:19:34 <paczesiowa> what are the reasons for ghc to not like types infered earlier by ghci?
19:19:45 <vixey> I think this defaulting stuff is not good
19:20:36 <ddarius> vixey: Without it that would have been a type error.  In the case of lambdabot, the defaulting is only applied when you try to use a function.
19:20:37 <vixey> yaeoh
19:20:38 <vixey> yeah*
19:20:46 <vixey> ghci doesn't print out types that you can just paste back into a program
19:20:53 <newsham> > "foo" `isInfixOf` "megafoobar"
19:20:54 <lambdabot>  True
19:20:58 <roconnor> ddarius: what has
19:21:06 <ddarius> roconnor: That bug.
19:21:14 <paczesiowa> vixey: how come?
19:21:37 <ddarius> roconnor: That's how lambdabot says "ambiguous variable usage"
19:21:38 <vixey> that is the way it is
19:21:48 <vixey> the information is for you really.. at least I take it that way
19:21:53 <ddarius> It should accept them with the proper extensions enabled.
19:21:54 <roconnor> the bug that I introduced into my darcs Charts code?
19:21:58 <roconnor> ddarius: it is my bug
19:22:10 <vixey> I don't think there's much point in annotating you program with types though
19:22:13 <ddarius> roconnor: Okay, we are talking about different things then.
19:22:15 <roconnor> ddarius: what is shadowing variable names supposed to be illegal?
19:22:21 <vixey> if ghc can figure it out I'll let it
19:22:31 <jsnx> Cale: http://hpaste.org/8756#a1
19:22:35 <roconnor> ddarius: yeah, I had a bug in my refactored code (even though it typechecked)
19:22:52 <paczesiowa> vixey: unless you want to change slightly that inferred type
19:22:57 <roconnor> ddarius: it occured when I refactored one variable name in a where clause to be the same as a parameter name.
19:23:02 <roconnor> er
19:23:05 <jsnx> so, i am kind of unsure on where to start with this one
19:23:16 <roconnor> I refactored a parameter name to be the same as a name in the where clause
19:23:20 <vixey> paczesiowa: I don't think there's ever a need to do that
19:23:49 <vixey> if the type can be inferred it is the most general type (except for some technicalities with GADTs I suppose)
19:23:54 <ddarius> roconnor: Infinite loop or just bad data?
19:24:14 <roconnor> ddarius: for some reason it just caused bad data.
19:24:23 <jsnx> should i in fact have T(0) at the bottom there, for example? then i am not sure where the arrow from 0 to any other C object actually goes
19:24:33 <jsnx> it doesn't look like it fits in the diagram at all, actually
19:25:34 <Euler_> > let f x = fmap (\w-> isInfixOf "2" w) x in ((return ["1","2","3"]) :: IO [String]) >>= f
19:25:35 <lambdabot>  Couldn't match expected type `[String]'
19:26:00 <ddarius> jsnx: The only arrow in the category that's the target of T is the identity arrow.  There is no diagram to draw.
19:26:53 <jsnx> ddarius: oh
19:27:13 <paczesiowa> > let f x = fmap (\w-> isInfixOf "2" w) x in fmap f ((return ["1","2","3"]) :: IO [String])
19:27:14 <lambdabot>  <IO [Bool]>
19:27:24 <paczesiowa> > let f x = fmap (isInfixOf "2") x in fmap f ((return ["1","2","3"]) :: IO [String])
19:27:25 <lambdabot>  <IO [Bool]>
19:28:05 <dmwit> ?unlet
19:28:06 <lambdabot> Defined.
19:28:14 <paczesiowa> Euler_: you have monad in a monad in a monad:>
19:28:17 <dmwit> ?undefine
19:28:18 <lambdabot> Undefined.
19:28:29 <dmwit> > "foo" `isInfixOf` "megafoobar"
19:28:30 <lambdabot>  True
19:28:41 <dmwit> newsham: It already exists.
19:30:22 <jsnx> is this co-unit diagram right?
19:30:23 <jsnx> http://hpaste.org/8756#a2
19:30:26 <Euler_> IO is a bit confusing for me lol, thanks for the help you guys
19:30:44 <jsnx> oh, oops, no
19:30:55 <jsnx> i put 0 at the end of an arrow
19:31:56 <Cale> jsnx: I'm not sure which diagram you're trying to draw, exactly.
19:32:04 <paczesiowa> Euler_: what are you trying to do?
19:32:21 <Cale> Euler_: have you had a look at my very short tutorial? :)
19:32:40 <Cale> http://www.haskell.org/haskellwiki/Introduction_to_IO
19:32:41 <lambdabot> Title: Introduction to IO - HaskellWiki
19:33:26 <ddarius> jsnx: Is the C in the diagram supposed to be an object of C, because if you mean it to be the category C then your diagram makes no sense.
19:34:15 <carl> is STM suitable for large data structures?
19:34:28 <jsnx> ddarius: yeah, i keep doing that
19:36:36 <Cale> jsnx: Which diagram are you trying to draw?
19:36:36 <Euler_> I've only read "yet another Haskell tutorial", but I will go ahead read yours right now. I've just been trying to figure out how to map functions to IO lists.
19:36:53 <Cale> Euler_: It's just a really short overview to give the right way of thinking
19:38:08 <Euler_> thanks for the help paczesiowa and cale
19:38:13 <hpaste>  jsnx annotated "(no title)" with "without names of arrows" at http://hpaste.org/8756#a3
19:38:26 <jsnx> Cale: co-unit
19:38:51 <chessguy> @pl \n -> p (h ++ n ++ e)
19:38:51 <lambdabot> p . (h ++) . (++ e)
19:38:57 <ddarius> jsnx: "co-unit" isn't a diagram.
19:39:12 <newsham> "can I interest you in a monad tutorial" - haskell's witnesses missionary
19:39:14 <ddarius> jsnx: You could draw the naturality square or the triangle equality.
19:39:19 <jsnx> ddarius: oh
19:39:34 <Cale> The counit is a natural transformation. I suppose you could draw the square which says that it's natural.
19:39:36 <jsnx> ddarius: the book i'm using asks me to draw the "co-unit diagram"
19:39:48 <Cale> jsnx: I don't know what that would refer to.
19:39:51 <jsnx> ddarius: so i thought that's what Cale was asking about
19:40:08 <jsnx> Well, these diagrams in the book are always triangles
19:40:19 <Cale> Really?
19:40:20 <ddarius> jsnx: I'm guessing they mean the triangle equality.  They probably define what they mean.
19:40:46 <jsnx> Cale: i don't mean *all* the diagrams are triangles
19:41:04 <dogbite> cabal is telling me that it can't install 'chart' because
19:41:06 <dogbite> "There is no available version of cairo that satisfies >=0.9.11"
19:41:20 <dogbite> but i think i have version 1.4.14-3 of cairo installed
19:41:30 <jsnx> please excuse me for a moment while i refresh my memory of the triangle equality
19:43:02 <Cale> So, just for my sanity, if we let F: 1 -> C be the left adjoint here and G: C -> 1 be the right adjoint, the triangle you want to draw is probably the one where for each morphism f: X -> G(Y), there is a unique morphism g: F(X) -> Y such that epsilon_Y . F(f) = g
19:44:20 <jsnx> here are some similar diagrams: http://en.wikipedia.org/wiki/Adjoint_functors#Adjunctions
19:44:29 <jsnx> the one to the right is what i mean
19:44:35 <Cale> yeah
19:44:38 <Cale> me too
19:44:40 <jsnx> yes
19:44:46 <Cale> So we're done?
19:44:57 <jsnx> well, what are the arrows i wonder?
19:45:14 <Cale> Well, you know what epsilon_Y is.
19:45:15 <ddarius> They are natural transformations.
19:45:35 <jsnx> Cale: actually, i don't quite
19:45:47 <ddarius> Actually, those aren't the triangle identities.
19:45:54 <Cale> F(G(Y)) is the initial object in C
19:46:18 <ddarius> (Not exactly)
19:46:36 <jsnx> ddarius: oh, that is good to know
19:46:52 <jsnx> Cale: so, F(G(Y)) is 0
19:46:53 <ddarius> Those are universal arrow diagrams.
19:47:00 <Cale> epsilon_Y is the unique morphism from it to Y
19:47:24 <jsnx> Cale: oh
19:47:42 <jsnx> and `g` in this case is the arrow from 0 to itself?
19:48:03 <jsnx> oh, wait, no
19:48:17 <Cale> g also goes from the initial object to Y
19:48:22 <ddarius> The triangle identities are the ε_F ∘ Fη = id_F and Gε ∘ η_G = id_G
19:48:22 <jsnx> g is the same arrow as e_Y ?
19:48:28 <Cale> yes
19:48:51 <jsnx> ddarius: i am getting a lot of ? ? ? ? ? ? in your entry -- unicode?
19:49:20 <jsnx> Cale: i think in this case, `f` is the identity arrow in C
19:49:26 <ddarius> epsilon_F o F eta = id_F and G epsilon o eta_G = id_G where o is composition.
19:49:38 <Cale> f is an arbitrary arrow X -> G(Y)
19:50:15 <Cale> It's "for every morphism f: X -> G(Y), there exists a unique morphism G: F(X) -> Y such that ..."
19:50:19 <ddarius> jsnx: They are the equations described in the unit/counit subsections of that wikipedia page
19:51:07 <vixey> jsnx: you could try UTF-8
19:51:30 <jsnx> vixey: i can't remember how i broke it
19:51:36 <jsnx> used to work okay
19:51:48 <jsnx> vixey: got a new mac and changed the term settings
19:52:01 <jsnx> vixey: something to do with ANSI escapes or what ever
19:52:02 <Cale> ... heh, -jsnx- VERSION OpenVMS VAX V7.2
19:52:39 <jsnx> Cale: irssi, darwin 9 (OS X Leopard), gcc 4.0, perl 5.8
19:52:54 <jsnx> Client: irssi 0.8.12 (20071006 0939)
19:52:56 <vixey> it's a real shame how terrible support for anything non-ascii is today
19:53:04 <jsnx> vixey: yeah, really
19:53:10 <vixey> I don't know how it got so bad everything supports it except the programs you actually interact with
19:53:16 <jsnx> okay, but before that stuff above scrolls by, i need to write it down
19:53:28 <Cale> That's why I use X-Chat, since it seems to consistently work with UTF-8 :)
19:53:46 <jsnx> it's my terminal settings, that's all
19:53:47 <ddarius> vixey needs to write her Telegu
19:54:05 <jsnx> once your terminal works with UTF-8, any useful program will also work
19:54:39 * vixey looks up Telegu..
19:55:00 <Cale> ఝ
19:55:32 <Cale> ౠఊఈఋఆఞజషచఱఘ -- random Telugu letters :)
19:58:18 <jsnx> Cale: so, in this case, f is a 1-arrow
19:58:30 <jsnx> Cale: which means it is id, i think
19:58:54 <Cale> jsnx: Well, it's an arrow in 1, which makes it id automatically ;)
19:59:04 <jsnx> yes
19:59:19 <jsnx> so then i wonder what is F(id_1) ?
19:59:41 <jsnx> in this case, i think it's the arrow that goes from 0 to itself
19:59:58 <Cale> it must be
20:00:07 <jsnx> yeah
20:00:09 <jsnx> okay
20:00:34 <Cale> So this diagram doesn't really say a whole lot, but it's obviously true that it commutes in this case at least
20:00:46 <jsnx> aha
20:00:47 <jsnx> yeah
20:01:04 <jsnx> i have not has an easy time with these adjunctions
20:01:07 <Cale> Let's try the other identity that ddarius referred to.
20:01:14 <jsnx> which is?
20:02:07 <achilles14> hi, is hal daume here, or does anyone know his email?
20:02:08 <Cale> 1_F = epsilon F . F eta, and 1_G = G epsilon . eta G
20:03:43 <jsnx> Cale: is 1_F id_F or does it have something to do with the category 1?
20:03:57 <Cale> it's the natural transformation id_F
20:04:21 <jsnx> okay
20:04:35 <jsnx> what does 1_F, where F is a functor, mean exactly?
20:05:17 <jsnx> a natural transformation is a function between functors, so what does it do?
20:05:23 <Nafai> Are there slices in Haskell lists?  Like in Python?
20:05:37 <Cale> jsnx: It's the identity.
20:05:39 <ddarius> Nafai: Other than take and drop, no.
20:05:50 <ddarius> Nafai: It doesn't make as much sense as for arrays.
20:05:53 <jsnx> Cale: but identity in what category?
20:06:10 <ddarius> Cat
20:06:40 <jsnx> so now i am not sure what the F actually means in 1_F
20:06:52 <jsnx> the identity functor of Cat at F ?
20:06:59 <litb> helo there
20:07:00 <Cale> uh... no
20:07:06 <Cale> litb: hi
20:07:35 <Cale> jsnx: I suppose the category of functors C -> D, with natural transformations between them as the arrows.
20:07:58 <Cale> jsnx: F is such a functor, and it has an identity arrow.
20:08:27 <jsnx> so 1_F is the identity arrow in F
20:08:51 <jsnx> so how does F have arrows?
20:09:00 <jsnx> since when did functors have arrows?
20:09:11 <Cale> what?
20:09:19 <Cale> Functors are the objects of the category
20:09:29 <Cale> Natural transformations between them are the arrows.
20:09:30 <jsnx> oh
20:10:12 <jsnx> so when you say, F has an identity arrow, you mean, there is an arrow in the category of functors C -> D that goes from F to itself
20:10:23 <Cale> yes
20:10:25 <jsnx> and this arrow is a natural transformation
20:10:32 <jsnx> got it
20:13:12 <jsnx> →
20:13:19 <jsnx> i think i fixed the UTF8 thing
20:13:26 <jsnx> someone, send me telegu
20:13:58 <vixey> (λu, u u) (λu, u u)
20:14:18 <jsnx> vixey: looks lambda-ish to me
20:14:22 <roconnor> (λu. u u) (λu. u u)
20:14:38 <jsnx> i changed my terminal settings so that it sets the LANG variable on startup
20:14:42 <jsnx> so that was that
20:14:47 * vixey prefers ,
20:15:00 <Cale> http://cale.yi.org/autoshare/zigzag.png
20:15:06 <roconnor> vixey: . in math is $ is haskell
20:15:19 <vixey> the next step is getting lambdabot to do at least as good at unicode as GHCi can
20:15:26 <Cale> jsnx: can you see η and ε now?
20:15:39 <vixey> roconnor: . is a full stop
20:15:55 <vixey> huh
20:16:08 <jsnx> yes :)
20:16:14 <mjrosenb> is there any function that will say how much memory is being used by a data structure?
20:16:18 <vixey> actually I don't understand
20:16:22 <roconnor> vixey: yeah, but in math it means consider the stuff after the dot all together.
20:16:48 <roconnor> However, we typically see it only after variables in forall, exists, and lambdas
20:16:56 <roconnor> now-a-days
20:16:57 <dobblego> can you write a general Functor identity property for QuickCheck then test the (->) functor using it somehow?
20:17:13 <Cale> Okay, so the left diagram there is saying that we can use Fη to insert a GF on the right of F to get to FGF, and then εF to remove the FG on the left to get back to F, and that's the same as the identity.
20:17:24 <vixey> hmm
20:17:48 <roconnor> Russell uses . a lot.  I'm not sure if he invented the notation
20:18:35 <Cale> mjrosenb: You can profile your program, but that's not exactly the same thing.
20:19:14 <Cale> mjrosenb: If you're just interested in how large things are on the heap at various points in the program's execution, you can do heap profiling.
20:19:45 <mjrosenb> Cale: awesome
20:19:56 <mjrosenb> so i've resorted to auto generating code
20:20:16 <mjrosenb> and i'd like to find what format makes things the easiest
20:20:22 <mjrosenb> among other things
20:20:50 <jsnx> Cale: so if we have GF(X), where do we put Fη ?
20:21:41 <jsnx> oh, wait
20:23:14 <jsnx> Cale: i don't really understand what you said
20:24:00 <jsnx> i need to shut off the computer and get a bite to eat
20:24:03 <jsnx> Cale: thanks
20:24:05 <jsnx> ddarius: thanks
20:28:46 <vixey> Is there a mini prolog in haskell?
20:29:03 <vixey> something like a monad that gives you logic variables and backtracking
20:29:41 <dons> LogicT
20:29:42 <lambdabot> dons: You have 3 new messages. '/msg lambdabot @messages' to read them.
20:30:15 <vixey> LogicT dosen't have logic variables though
20:33:58 <Cale> vixey: It's a curious idea whether that's doable. I imagine your logic variables would have an interface something like STRefs.
20:35:24 <Cale> only instead of mutation, you have different primitives
20:39:07 <Zao> Watching a Deus Ex speedrun now. That's a large game...
20:39:20 <Zao> Erm, wrong channel, sorry.
20:41:29 <svref> I think my exim install is subverted and sending spam for outsiders, but need help determining it for sure. Can someone look at these headers sent to some poor guy and tell me if the mail came from my machine? http://www.osaurus.us/~dm/tmp/email.html
20:42:09 <roconnor> svref: why are you asking in #haskell ?
20:42:32 <xci> :)
20:42:39 <vixey> this isn't #haskell it's #wrong-channel
20:42:47 <xci> yeah
20:42:58 * roconnor fear clicking that link
20:43:06 <svref> roconnor: doh!
20:43:34 <Pseudonym> So when the police turned up, I told them she was already dead when I got there.
20:43:37 <Pseudonym> Oops, sorry!
20:46:38 <Cale> Zao: one of my favourites :)
21:22:33 <newsham> newtype Endo a = Endo { appEndo :: a -> a }
21:22:36 <newsham> what does "endo" stand for?
21:23:16 <dons> endomorphism?
21:23:18 <mauke> Pea, known in Japanese as endō (豌豆)
21:24:14 <mauke> endo-, "inside"
21:24:21 <Korollary> Endo was that alien in last year's icfp problem
21:43:11 <ddarius> vixey: I could send you the Prolog interpreter I wrote.
21:46:07 <ddarius> Actually it might be in hpaste somewhere.
21:51:59 <ddarius> I was wondering why they heck my pretty printer was producing insane rubbish.
21:52:20 <ddarius> I was using mconcat . intersperse (',':) and they changed the monoid instance out from under me.
21:52:55 <Heffalump> the monoid instance for functions?
21:53:09 <ddarius> Yes.
21:53:12 <Heffalump> ouch
21:55:22 <mauke> how did it change?
21:55:38 <ddarius> mauke: The Endo instance use to be the main one.
21:55:45 <mauke> ah
21:56:16 <mauke> the new one is more useful for 'sort' :-)
21:59:12 <ddarius> Much better now.  The sad thing was I just thought I was a freakin' retard and blind to boot the first time I resurrected this code, but didn't care enough to "fix" the code.
21:59:16 <dobblego> what's the Monoid instance for Endo? is it different than composition?
21:59:38 <ddarius> dobblego: It is the composition one.  The old one for functions use to be the one that Endo is now.
22:00:00 <newsham> dobblego: http://conal.net/blog/posts/implementing-a-type-for-partial-values/
22:00:01 <lambdabot> Title: Conal Elliott  Implementing a type for partial values, http://tinyurl.com/5rsch9
22:01:28 <dobblego> thanks
22:06:22 <hpaste>  morrow pasted "Hask (what I have so far)" at http://hpaste.org/8757
22:07:57 <mmorrow> ddarius: here's what I have so far: http://hpaste.org/8757
22:09:15 <mmorrow> ddarius: have to do other work now, but plan to add to it when i get time
22:09:28 <mmorrow> @seen ddarius
22:09:28 <lambdabot> ddarius is in #haskell-soc, #haskell-overflow, #haskell-blah and #haskell. I last heard ddarius speak 9m 49s ago.
22:13:39 <ddarius> mmorrow: When you turn a monoid, a triple (M,*,1) into a category, the set M becomes the set of arrows for that category, the composition is (*) and the identity, 1.  By saying the morphisms of your "type" categories are functions (T -> T) you are saying that the objects of your "outer" category are the endofunction monoids, i.e. "Int" in your category is set of functions Int -> Int.  Is that really what you want to say?
22:15:00 <scodil> mmorrow : i didn't get any patch in the mail
22:15:15 <mmorrow> ddarius: i have to think about my answer to that (and run to the store). be back in 15
22:15:28 <mmorrow> scodil: oops, i'll send it now manually
22:15:38 <scodil> cool thanks
22:15:47 <scodil> i know squat about template haskell, tho
22:16:36 <mmorrow> heh, neither did i until i realized how useful it could be, then progress became rapid :)
22:16:48 * mmorrow sends patch and goes to store
22:17:47 <scodil> yeah I image the whole library could be re-written more cleanly using it
22:22:41 <Kenny> HOW DO I PROGRAM PLAYSTATION 3 GAMES USING LINUX
22:23:24 <ddarius> Kenny: Unless you want to know how to do that using Haskell, you have the wrong channel.
22:23:59 <Kenny> HOW DO I PROGRAM PLAYSTATION 3 GAMES USING HASKELL
22:24:20 <dobblego> first you turn caps-lock off, since Haskell is mostly lower case
22:24:50 <mmorrow> scodil: sent
22:25:01 <Kenny> how do i program playstation 3 games using haskell
22:25:02 <scodil> awesome thanks
22:25:12 <Kenny> i truned off my cool cruise control
22:28:45 --- mode: ChanServ set +o dons
22:30:02 <ddarius> Kenny: Since GHC is the implementation you'd probably want to use and GHC doesn't cross-compile you'd first need to get GHC built on the PS3 (or a binary compatible system).  After that, port the libraries you need and write your code.  I believe there are some people looking into this stuff, but I don't know the details.
22:31:16 <nolrai_East> @hoogle loval
22:31:20 <nolrai_East> @hoogle local
22:31:25 <lambdabot> No matches found
22:31:25 <lambdabot> Control.Monad.Reader.Class.local :: MonadReader r m => (r -> r) -> m a -> m a
22:31:25 <lambdabot> Distribution.Simple.LocalBuildInfo.localPkgDescr :: LocalBuildInfo -> PackageDescription
22:31:25 <lambdabot> Distribution.Simple.Configure.localBuildInfoFile :: FilePath
22:32:59 <solrize_> http://www.nomaware.com/monads/html/   bah.  die spam
22:33:01 <lambdabot> Title: aware nom real estate apartment at nomaware.com
22:33:16 <dons> good thing we got it in the wikibook, solrize_
22:33:19 <mauke> @where all
22:33:19 <lambdabot> I know nothing about all.
22:33:29 <solrize_> yeah :)
22:34:26 <solrize_> there's a semi-cheesecake photo on that page too
22:34:40 --- mode: ChanServ set -o dons
22:42:23 <nolrai_East> @pl flipThroughFun x = \env -> do {f <- x env; return $ Fun (unwrap . f);}
22:42:24 <lambdabot> (line 1, column 31):
22:42:24 <lambdabot> unexpected "{"
22:42:24 <lambdabot> expecting variable, "(", operator or end of input
22:42:41 <nolrai_East> @undo do {f <- x env; return $ Fun (unwrap . f);}
22:42:41 <lambdabot> x env >>= \ f -> return $ Fun (unwrap . f)
22:43:04 <mauke> liftM
22:43:19 <nolrai_East> doh
22:46:30 <mmorrow> ddarius: yes, you're exactly correct, i meant "objects (T -> T), monoid prod (.), morphisms monoid homs"
22:47:20 <mmorrow> ddarius: well, i'd have to correctly insert that change into the rest to make sure everything is mutually consistent of course
22:48:04 <mmorrow> ddarius: actually, that should be a self-contained correction
22:48:34 <ddarius> Um, describe the arrow that corresponds to the function \x y -> x+y  or \(x,y) -> x+y if you prefer.
22:49:07 <ddarius> x and y Ints say.
22:49:56 <mmorrow> ddarius: the standard way of thinking of a monoid/group as a category... a monoid (M,*) is a cat with a *single* object and morphisms { (*x) | x `elem` M}
22:50:49 <mmorrow> everything gets weird when using the type system to describe itself
22:53:16 <ddarius> There's no necessity to sectioning the monoid multiplication.  The arrows of a monoid cum category are simply the elements of the monoid.
22:53:36 <mmorrow> yes!
22:53:48 <mmorrow> and the "*single* object" is 1
22:54:01 <ddarius> mmorrow: No.  The single object is completely irrelevant.
22:55:06 <mmorrow> it is, but if you map it to 1, then you may recover the elements x of M by applying the functions (x*) which each was mapped to to 1
22:56:24 <ddarius> Yes, you can do that as the object is completely irrelevant and how composition works is completely irrelevant as long as it's associative and unital.  The single object could just as well be George W. Bush.
22:56:26 <mmorrow> i may be jumping in circles, but the fact that saying you have a monoid is equiv to saying you have a cat w/ a single obj and only id morphisms is correct
22:56:53 <nolrai_East> @pl \f -> Fun ( unwrap . f )
22:56:53 <lambdabot> Fun . (unwrap .)
22:56:56 <mmorrow> ddarius: heh
22:57:17 <ddarius> If you only have a single object you only have one identity morphism, that would be the category 1.  Perhaps you meant only "endo" morphisms.
22:57:34 <Cale> One structure that I rather like is the groupoid, which is defined as a small category in which every arrow has an inverse.
22:57:48 <mmorrow> ddarius: by "identity morphisms" i mean endos
22:57:57 <ddarius> Cale: Indeed.  A favorite is the fundamental groupoid.
22:58:13 <mmorrow> Cale: oh yay, i *hate* basepoints
22:58:13 <Cale> Yeah :)
22:58:15 <atp> would that be \pi_{oid}  ? haha
22:58:47 <Cale> I've usually seen it written \Pi_1
22:58:53 <Cale> (with a capital Pi)
22:59:06 <mauke> Π₁
22:59:07 <atp> really? hm
22:59:40 <atp> i don't have any experience with fundamental groupoids, only fundamental groups
22:59:43 <ddarius> mmorrow: Okay, but I haven't been taking issue with how you are treating monoids as one object categories.  Whether you want to say you have a category of one object categories and functors, or a category of monoids and monoid homomorphisms doesn't change anything.  My question is, why do you want types to be monoids however you represent them?
22:59:49 <atp> so i was making a (very bad) joke
22:59:58 <Cale> atp: It's nice because you don't have to worry about the basepoint anymore.
23:00:25 <mmorrow> ddarius: i only used monoids as a way to map types to categories
23:00:25 <atp> Cale: what's a paper to read that introduces them?
23:00:47 <Cale> atp: hmm... I was introduced to it in lectures, so I'm not sure
23:01:01 <atp> Cale: hm, fair enough.  i'll stfw.  i'm sure i can find something.
23:01:02 <ddarius> mmorrow: Why do you want types to be monoids/categories?  What structure is that reflecting?
23:01:24 <ddarius> atp: You can probably find it in some CT stuff.
23:01:38 <atp> ddarius: thanks, i'll keep my eyes open.
23:01:45 <mmorrow> ddarius: and my somewhat open-ended goal was to make each type a cat, then wrap these in an enclosing cat Hask. I'm not yet sure the end-result of this.
23:01:53 <Cale> There's a PlanetMath article.
23:02:02 <Cale> PlanetMath is being a bit slow for me...
23:02:11 <Cale> http://planetmath.org/encyclopedia/FundamentalGroupoid.html
23:02:12 <lambdabot> Title: PlanetMath: fundamental groupoid
23:02:25 <atp> thanks, i'll take a look
23:02:28 <ddarius> mmorrow: Why do you think there will be a useful end result?
23:02:59 <atp> oh, that's kind of neat
23:03:12 <mmorrow> ddarius: for the same reason someone might think it useful to think of the collection of Haskell types as a category
23:03:29 <mmorrow> ddarius: to then be able to apply categorical machinery while reasoning
23:03:38 <Euler_> Never seen this before... ghc-6.8.2: panic! (the 'impossible' happened)   I just typed in :f fmap into ghci ...?
23:04:03 <Cale> heh, I get that too
23:04:12 <Euler_> a bug in haskell??
23:04:16 <_zenon_> Euler_ Now one of the lambda-cats make sense
23:04:18 <Euler_> this is a firt
23:04:35 <Cale> Euler_: However, you are telling it to do something slightly absurd.
23:04:37 <mauke> Euler_: you win!
23:04:46 <Cale> (but it surely shouldn't do that)
23:04:48 <_zenon_> http://arcanux.org/lambdacats/impossible.jpg
23:05:20 <Euler_> *hahahahahahaha
23:05:21 <Cale> Perhaps you meant to type  :t fmap  ?
23:05:30 <Euler_> yes
23:05:37 <_zenon_> :i fmap
23:06:10 <_zenon_> I like the :i better, also says where
23:06:37 <ddarius> mmorrow: Okay.  Then you want to start looking at what structure types have and see if it has categorical structure.  Making up categories and seeing if they reflect/reveal anything about types is a very slow way of doing things.
23:07:15 <nolrai_East> @hoogle (a -> m b) -> m (a -> b)
23:07:15 <lambdabot> Data.Function.fix :: (a -> a) -> a
23:07:15 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
23:07:15 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
23:07:36 <ddarius> mmorrow: For example, often types are modelled with CPOs which are special types of posets which can be viewed as a particular type of category.
23:07:39 <mmorrow> ddarius: that isn't my strategy or goal at all.
23:07:49 <solrize_> :f fmap
23:08:11 <Cale> Interesting... it seems to happen with class member functions that are type-constructor polymorphic.
23:09:18 <nolrai_East> what does m need to have for "(a -> m b) -> m (a -> b)" to be posible?
23:09:36 <Cale> For instance, it happens with <*> but not *> or showsPrec or (+)
23:09:37 <ddarius> nolrai_East: A function: (a -> m b) -> m (a -> b)
23:10:12 <nolrai_East> ddarius: :P
23:10:33 <Cale> Well, if a is something specific instead of polymorphic, you can construct an interesting function of that type.
23:10:48 <Cale> Or you could do something like [a] -> (a -> m b) -> m (a -> b)
23:10:49 <newsham> ?type (*>)
23:10:52 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
23:11:06 <ddarius> nolrai_East: I think it may be provable that the only monad that supports such a function (at least a total one), is the identity monad.
23:11:21 <nolrai_East> hmm.
23:12:18 <Euler_> is there a functor similar to fmap, only with :: (a -> b) -> f [a] -> f [b]
23:12:53 <quicksilver> Euler_: fmap.map
23:12:53 <newsham> thats just two fmaps
23:14:03 <Euler_> > :t fmap.map
23:14:04 <lambdabot>   parse error on input `:'
23:14:22 <nolrai_East> added some error tracking to my code, and so what used to be "(env -> b -> Fun) -> (env -> Fun)" now needs to be "(env -> b -> m Fun) -> (env -> m Fun)", ideas?
23:14:25 <Cale> :t fmap . P.map
23:14:25 <lambdabot> forall (f :: * -> *) a b. (Functor f) => (a -> b) -> f [a] -> f [b]
23:14:38 <Cale> :t map . map
23:14:38 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
23:14:46 <Cale> (lambdabot has generalised map :)
23:14:54 <Euler_> oh cool! thanks quicksilver
23:15:30 <newsham> fmap goes a->b to [a]->[b]  then another fmap goes [a]->[b] to f [a] -> f [b]
23:16:42 <mauke> :t map map map
23:16:43 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
23:18:17 <ddarius> Actually, I am wrong.  The reader monad does indeed have a natural function (a -> m b) -> m (a -> b), namely flip.
23:19:19 <nolrai_East> ddarius: yeah that makes sense.  but the Error monad doesnt does it?
23:19:53 <Trinithis> what gui libary should i get. I want to make tetris in haskell
23:20:24 <nolrai_East> I like gtk2hs.
23:20:28 <ddarius> nolrai_East: No.
23:20:47 <Trinithis> no?
23:20:55 <Trinithis> o nvm
23:22:16 <ddarius> Let a = Bool and b = (), then such a function were passed (\a -> if a then Left "" else Right ()) there would be no way total way to make an Either String (a -> ()) from it.
23:22:37 <ddarius> A similar scenario happens with IO, ST, Maybe, [], and State.
23:22:50 <syntaxfree> Uh, this is a broad ill-defined question, but how would you approach writing simulation software in Haskell?
23:23:03 <syntaxfree> like, simulations of economic systems or city traffic flow.
23:24:13 <ddarius> syntaxfree: I'd start by gathering requirements so that I could answer such a question...
23:25:36 <nolrai_East> hmm, i guesse just need to replace lookup with (!!) then. Too bad. if the the codes working they shouln't fail. but...
23:25:39 <syntaxfree> well, there are multiple agents reacting to a complex environment. they probably act serially, for a specification that doesn't require weird multithreading
23:25:46 <ddarius> (Well, you could write, in the Either case, simply fail "foo", but that isn't too helpful.)
23:26:34 <nolrai_East> Yeah, i think i was look for something imposibleish.
23:26:42 <ddarius> syntaxfree: The question I'd be trying to get answered isn't "how does it work" but what are the outputs.
23:28:42 <Trinithis> @ty const undefined :: (a -> m b) -> m (a -> b)
23:28:43 <lambdabot> forall a (m :: * -> *) b. (a -> m b) -> m (a -> b)
23:28:57 <syntaxfree> ddarius: well, every agent eats an environment (not sure how to model it -- a list of numbers or a graph) and spits out a same-typed environment so the next agent can do the same.
23:29:39 <syntaxfree> the system has also some constraints -- like, consequences from the agent actions that are not systemic.
23:29:39 <ddarius> syntaxfree: Again, I don't care how it works.  What does the end user see?  Is it an interactive simulation, a real-time one, one that crunches numbers for a while and then outputs a bunch of data?
23:29:49 <syntaxfree> (Not derived from the agents themsekves)
23:30:33 <povman> @quote russia
23:30:34 <lambdabot> vegai says: in Soviet Russia, YOU blow up GHC's brain!
23:30:51 <syntaxfree> ddarius: "interactive" means you're supposed to interfere with the system? Nah.
23:31:51 <syntaxfree> The general idea of what I want to do is experimenting with critical variables in complex systems.
23:32:19 <Trinithis> nolrai_East: is there a version of gtk2hs that will install for ghc 6.8.2. I get a complaint about not having 6.8.1
23:32:21 <syntaxfree> maybe optimizing for certain initial values or nonsystemic constraints.
23:34:28 <ddarius> syntaxfree: http://en.wikipedia.org/wiki/Discrete_event_simulation perhaps?
23:34:28 <lambdabot> Title: Discrete event simulation - Wikipedia, the free encyclopedia
23:36:56 <syntaxfree> http://www.facsim.org/  but no download link.
23:36:56 <lambdabot> Title: Facsimile | Simulation/Emulation Library
23:37:24 <syntaxfree> I'm thinking of giving Ruby a spin too, but my original question was how to approach it in Haskell.
23:37:28 <syntaxfree> State monads?
23:38:26 <povman> syntaxfree: ruby ist evil
23:39:14 <syntaxfree> evil-er than python?
23:39:44 <kiris> morning
23:39:53 <ddarius> I don't know, zombies are slow and ruby is slow and zombies are usually evil.
23:40:00 <mmorrow> syntaxfree: that's like asking an ambidextrous person which arm they'd rather lose
23:40:07 <kiris> that logic is flawless
23:40:34 <solrize_> +qotw
23:40:34 <syntaxfree> I'm liking Petri nets from what I see in Wikipedia.
23:44:42 <Mandoragon> morning
23:44:54 <dons> ddarius: i agree with kiris, you can't fault that logic.
23:45:50 <Mandoragon> ..I am so confused with this topic..on a language channel..
23:47:24 <_zenon_> Madoragon: What seems to be the problem?
23:47:30 --- mode: ChanServ set +o dons
23:47:34 --- topic: set to ' ["Zombies are slow and Ruby is slow and zombies are usually evil...", "Haskell: precision engineering for programmers", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org ", "Logs: http://tunes.org/~nef/logs/haskell/"]' by dons
23:47:39 --- mode: ChanServ set -o dons
23:48:03 <Mandoragon> evill..?..zombies..? Its too early on a monday morning :(
23:48:14 <dons> never to early for zombies!
23:48:23 <Mandoragon> lol
23:48:39 <_zenon_> @ty zombie
23:48:40 <lambdabot> Not in scope: `zombie'
23:48:44 <_zenon_> awww
23:48:48 <dons> night all, be careful about the brains.
23:49:01 <povman> @quote zombie
23:49:02 <lambdabot> Tac-Tics says: oerjan: I tried, but his zombie lectures were hard to follow
23:49:15 <kiris> (Evil a, Zombie a) ⇒ a → a
23:49:16 <Mandoragon> have you been playing too much boxhead> ;) http://www.boxheadzombiewars.com/
23:49:16 <lambdabot> Title: Boxhead Zombie Wars
23:49:55 <povman> @zombie
23:49:55 <lambdabot> Unknown command, try @list
23:49:57 <_zenon_> Should it not be: zombie :: a -> ()
23:50:10 <povman> @quote zombie
23:50:11 <lambdabot> Tac-Tics says: oerjan: I tried, but his zombie lectures were hard to follow
23:51:08 <kiris> nomNomNom :: (Zombie a, Brainz b) ⇒ a -> b -> a
23:51:58 <kiris> povman: we obviously need a zombie plugin
23:52:15 <povman> @zombie should yield a netsplit
23:52:16 <lambdabot> Unknown command, try @list
23:54:41 <_zenon_> Oh, I was thinking more in along the lines that zombies killed you
23:54:47 <_zenon_> but yes, I go with kiris
23:54:58 <Euler_> > liftM (\x-> show x) (return [1,2,3]) /= ["1","2","3"] --why
23:54:59 <lambdabot>  True
23:56:00 <povman> :t liftM (\x-> show x) (return [1,2,3])
23:56:01 <lambdabot> forall (m :: * -> *). (Monad m) => m String
23:56:09 <povman> > liftM (\x-> show x) (return [1,2,3])
23:56:10 <lambdabot>   add an instance declaration for (Show (m String))
23:56:35 <kiris> it's just lifting it into the monad, not using bind
23:56:39 <povman> because of the return
23:56:45 <nolrai_East> > liftM (\x-> show x) ([1,2,3])
23:56:46 <lambdabot>  ["1","2","3"]
23:56:48 <povman> > liftM (\x-> show x) ([1,2,3])
23:56:49 <lambdabot>  ["1","2","3"]
23:56:51 <povman> fine then
23:56:54 <solrize_> > liftM show [1,2,3]
23:56:54 <lambdabot>  ["1","2","3"]
23:56:57 <solrize_> oh
23:57:09 <solrize_> heh
23:57:15 <Euler_> but what if [1,2,3] :: IO
23:57:37 <povman> what
23:57:46 <Euler_> then I would need the bind function?
23:57:54 <povman> :t [1,2,3]
23:57:55 <lambdabot> forall t. (Num t) => [t]
23:57:57 <achilles14> hi all, is there any function I can use to produce [1,2,3,4,5,6,7,8,9,10,11] easyly?
23:58:03 <kiris> > [1..11]
23:58:04 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11]
23:58:16 <achilles14> thanks
23:58:25 <kiris> > enumFromTo 1 11 -- I think?
23:58:26 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11]
23:58:30 <_zenon_> > data Living = Living {name::String, animal::String}
23:58:30 <lambdabot>  Parse error at "data" (column 1)
23:58:48 <kiris> :(
23:58:53 <povman> :tliftM
23:58:59 <povman> :t liftM
23:58:59 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
23:59:19 <kiris> > fmap show [1,2,3]
23:59:20 <lambdabot>  ["1","2","3"]
23:59:25 <povman> Euler_: using liftM means you don't need to return
23:59:30 <solrize_> :t fmap
23:59:31 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
23:59:45 <povman> :t (.)
23:59:45 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
23:59:45 <_zenon_> Why did it not accept it?
