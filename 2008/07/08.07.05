00:03:17 <gwern> > 590 / 2
00:03:19 <lambdabot>  295.0
00:03:37 <jbapple> in fact, symmetric difference on ordered and sized finger trees, for two lists of size 2*m, with an intersection of size m, is O(m), but on AVL trees (without fingers), it's O(m lg m)
00:04:20 <jbapple> I think it's even worse for lists of uneven sizes
00:19:16 <ski> morning
00:20:26 <dmwit> "Symptoms: 1. You seriously consider malice to be a reason the compiler rejects your program."
00:21:24 <QtPlatypus> dmwit: What is that symptom of?
00:21:34 <wuxia> so I'm reading: http://www.haskell.org/onlinelibrary/maybe.htm and don't understnad how the fromMaybe works ... can anyone exploain whty the thpe is a -> Maybe a -> a, and what the 'd' means in: fromMaybe              :: a -> Maybe a -> a
00:21:38 <wuxia> fromMaybe d Nothing    =  d
00:21:39 <dmwit> QtPlatypus: "Dysfunctional Sense of Causality"
00:21:41 <wuxia> fromMaybe d (Just a)   =  a
00:21:43 <wuxia> ? thanks
00:22:02 <dmwit> wuxia: It's a default value.
00:22:08 <dibblego> wuxia, d is just the name of a parameter in the example; you can name it anything you like
00:22:38 <wuxia> if it's a default value, where is it defined?
00:22:55 <dibblego> a (Maybe a) is either a (Just a) or a Nothing and in the event it is a Nothing, there is no 'a' that can be returned, so the given argument (d) is instead returned in that case
00:22:59 <dmwit> It is defined there, in the pattern match.
00:23:12 <dmwit> fromMaybe d {- here is its definition -} Nothing = d
00:23:21 <dmwit> fromMaybe d {- here, too -} (Just a) = a
00:23:25 <wuxia> oh, i'm an idiot
00:23:36 <wuxia> a -> Maybe a -> a shoudl be readc as:
00:23:45 <wuxia> takes two argumenmts, one of type a, one of type Maybe a, and returns something of type a ?
00:23:53 <dmwit> That's one way to read it, yes.
00:23:53 <wuxia> so d, Nothing is simply 2 arguments
00:24:00 <dmwit> right
00:24:02 <wuxia> as is "d (Just a) "? got it
00:24:03 <wuxia> thanks
00:24:07 <gwern> @tell Cale hey, I finally got mueval fixed - the big gaping anus-like security hole has been plugged (in darcs and hackage). take a look at how it works and see whether we could replace lambdabot' > with it?
00:24:07 <lambdabot> Consider it noted.
00:24:46 <wuxia> so in the implemenation of listToMaybe
00:24:51 <wuxia> is only the first argument used, and the rest ignored?
00:25:42 <dmwit> :t listToMaybe
00:25:43 <lambdabot> forall a. [a] -> Maybe a
00:25:48 <dmwit> wuxia: There is only one argument.
00:25:55 <wuxia> listToMaybe            :: [a] -> Maybe a
00:25:55 <wuxia> listToMaybe []         =  Nothing
00:25:56 <wuxia> listToMaybe (a:_)      =  Just a
00:26:03 <wuxia> that makes it look like that the first elemnt of the list is used
00:26:06 <wuxia> and the rest of hte list is ignored?
00:26:09 <dmwit> wuxia: Oh, yes, only the first element in the list is used.
00:26:13 <wuxia> cool
00:26:35 <wuxia> can you explain to me what: catMaybes              :: [Maybe a] -> [a]
00:26:36 <wuxia> catMaybes ms           =  [ m | Just m <- ms ]
00:26:38 <wuxia> does?
00:26:51 <ddarius> wuxia: The type says it all.
00:27:01 <wuxia> so it takes a list of Maybe a
00:27:05 <wuxia> and creates a list of a
00:27:06 <dmwit> wuxia: What do you think it does?
00:27:32 <wuxia> oh man, I'm misunderstatning the meaning of |
00:27:35 <wuxia> i thought it meant concat
00:27:48 <wuxia> but it's some type of mapping going on here?
00:27:56 <Vq^> thats a list-comprehension
00:27:59 <wuxia> where i take ms, and sent it rhough   Just , with each arg of list bound to 'm' ?
00:28:19 <ddarius> wuxia: From the type alone, what do you think it does?
00:28:34 <wuxia> it takes a list of 'Maybe a'
00:28:37 <wuxia> and creates a list of 'a'
00:28:51 <dmwit> How?
00:29:03 <wuxia> then I look at the source, and from usunig 'Juyst'
00:30:13 <wuxia> what I don't undedstand about this list comprehension is that ecamples I have seem, like: http://www.zvon.org/other/haskell/Outputsyntax/listQcomprehension_reference.html
00:30:14 <lambdabot> Title: Haskell : list comprehension, http://tinyurl.com/hv26f
00:30:16 <wuxia> shows binding a list to a var
00:30:24 <wuxia> but here, I'm dealing with binding it to 'Just m' ?
00:31:05 <Vq^> wuxia: it's a patternmatching that can fail, resulting in filtering out all Nothing values
00:31:50 <wuxia> ah
00:31:57 <wuxia> can this be equiv writtten as:
00:32:18 <wuxia> [ m | m <- ms, isJust m]
00:32:31 <Vq^> no
00:32:43 <Vq^> because that wouldn't "unpack" the maybe values
00:33:18 <wuxia> oh wow
00:33:20 <Vq^> [fromJust m | m <- ms, isJust m]  -- might work thought
00:33:23 <wuxia> got it, thanks
00:33:51 <Vq^> but fromJust should really be avoided if possible
00:34:19 <wuxia> because it thorw an error?
00:34:34 <Vq^> yes
00:39:33 <wuxia> why is this named catMaybes?
00:39:41 <wuxia> when I think of 'cat', I either think of unix cat
00:39:42 <wuxia> or concatenate
00:39:49 <wuxia> what is the acrorynym here?
00:39:54 <Cale> concatenate
00:39:54 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
00:40:04 <dolio> If you think of maybes as a list of 0 or 1 elements, it's like concatenate.
00:40:12 <wuxia> ah
00:48:33 <wuxia> mapMaybe               :: (a -> Maybe b) -> [a] -> [b]
00:48:34 <wuxia> mapMaybe f             =  catMaybes . map f
00:48:42 <wuxia> so is there some implicit argument passing here?
00:48:50 <wuxia> it seems that mapMaybe f returms me a function xyz
00:49:19 <wuxia> where xyz, if given a list of 'a', will apply 'f' to every element of it, getting a list of 'maybe b', then apply catMaybes to it to get a list of 'b' ?
00:49:30 <Cale> wuxia: Yeah, that's right.
00:49:31 <wuxia> so question is ... what does the '.' mean, and how is the argument 'passed' ?
00:49:40 <Cale> . is function composition
00:49:44 <Cale> It's defined by:
00:49:49 <Cale> (f . g) x = f (g x)
00:50:09 <reubenf> is it possible to make it so a bunch of functions will be evaluated at compile time?
00:50:10 <wuxia> hmm, so map takes a function and returns a function?c
00:50:17 <Cale> mhm
00:50:20 <wuxia> so the idea is that map takes a function 'f', returns another function
00:50:21 <Cale> :t map
00:50:22 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
00:50:25 <Cale> hehe
00:50:27 <wuxia> and this returned function is composed with catMaybes ?
00:50:29 <Cale> :t Prelude.map
00:50:30 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
00:50:34 <Cale> (if you prefer)
00:50:43 <wuxia> :t forall
00:50:44 <lambdabot> Not in scope: `forall'
00:50:52 <Mr_Awesome> Cale: if only ;)
00:51:02 <Cale> You can ignore the forall a b part
00:51:18 <Cale> It's just saying that type is valid for any choice of types a and b
00:51:21 <wuxia> okay, alright, I think i understand of Monad maybe to go on with the monad tutorial
00:51:24 <wuxia> gotcha
00:51:34 <Cale> Note that -> associates to the right
00:51:44 <wuxia> ?
00:51:47 <Cale> So (a -> b) -> [a] -> [b] means (a -> b) -> ([a] -> [b])
00:52:14 <Cale> If you see a type like:
00:52:20 <Cale> A -> B -> C -> D -> E
00:52:23 <Cale> that means:
00:52:35 <Cale> A -> (B -> (C -> (D -> E)))
00:52:42 <wuxia> hmm
00:53:19 <wuxia> so (a->b) -> [a] -> [b] means ... this function takes something w/ input 'a' and output 'b'
00:53:25 <Cale> Conversely, function application associates to the left, so when you see
00:53:29 <Cale> f x y z
00:53:31 <Cale> it means
00:53:34 <wuxia> and produces something with input '[a]' and outp9ut '[b]' ?
00:53:35 <Cale> ((f x) y) z
00:53:45 <Cale> yeah
00:53:56 <wuxia> to make stuff more fun
00:54:04 <wuxia> is there anything that ssociates in the middle, or with evbery other arugmnet?
00:54:14 <Cale> Not in Haskell :)
00:54:19 <Cale> So when you write, say,  map (*2) [1,2,3,4,5]
00:54:28 <Cale> What that means is really  (map (*2)) [1,2,3,4,5]
00:55:30 <Cale> So you can think of it as map taking two args, or you can think of it as map taking one arg, and producing a function which takes another, and those are the same thing.
00:59:01 <reubenf> there's one thing i really don't get about that.   if i have a function "func :: A -> (B -> C)"  then i define it using "func A B = C" i don't really get how haskell is inferring everything correctly
00:59:10 <jre2> what happened to -fdisambiguate-record-fields ?
00:59:44 <reubenf> i guess because all functions take only one param it's not ambiguous, i'm probably just not used to the compiler inferring that much
01:02:05 <dolio> What else would func A B = C be?
01:02:13 <Cale> reubenf: Well, if you want to look at it at the implementation level, things are more complicated -- the compiler might specialise functions for taking multiple parameters at once, rather than taking a single parameter and returning another function which will immediately be applied.
01:02:50 <Cale> But that's an independent concern from how it treats definitions like that.
01:02:51 <reubenf> dolio: like i said i guess it's not ambiguous, i think i'm just used to my function definition only defining one function where i'm really defining two here
01:03:05 <Cale> reubenf: two?
01:03:33 <reubenf> well if you call func a you get a function B -> C
01:03:57 <reubenf> right?
01:04:08 <Cale> Well, okay, but that function is what func produces as its result.
01:04:38 <dolio> The alternative would be 'func = \A -> \B -> C' or something of that sort.
01:04:49 <reubenf> right, but when i read "func A B = C" i am reading it like func takes two params and returns C
01:05:02 <dolio> It's not too magic to just have \A B -> mean \A -> \B ->
01:05:10 <Cale> It does... it's just that that's the same thing as taking one parameter and returning a function ;)
01:06:08 <reubenf> i guess it is
01:06:18 <reubenf> i am so slow at this
01:06:29 <quicksilver> wuxia: yes, in a GLUT-type app you typically have a bundle of state which is updated by keypresses.
01:06:32 <dolio> It tkes a while.
01:06:32 <Cale> Of course, you can simulate the way that multiparameter functions work in other languages by using tuples
01:06:34 <reubenf> and i even majored in math :(
01:06:40 <quicksilver> there are ways to make this more implicit
01:06:58 <Cale> Ah, in mathematics, we tend to use Cartesian products as well
01:07:00 <dolio> Eh, math uses tuples, typically.
01:07:15 <Cale> A multiparameter function is usually A x B -> C
01:08:14 <Cale> But C^(AxB) is isomorphic to (C^B)^A
01:12:40 * dolio once again has too many papers littering his home directory.
01:28:13 <wuxia> really dumb question .. using maybe, how do I construct a type for 'sheep', where a sheep has a name, and maybe a father, and maybe a mother
01:28:36 <wuxia> (trying to understand the ecmaple at: http://www.haskell.org/all_about_monads/html/meet.html)
01:28:36 <lambdabot> Title: Meet the Monads
01:28:47 <wuxia> but can't test sample code since I don't know how to declare type Sheep = ...
01:30:30 <dibblego> data Sheep = Sheep Name (Maybe Father) (Maybe Mother)
01:30:58 <Beelsebob> I note that you don't specify that the Father/Mother were also sheep
01:31:08 <Beelsebob> data Father = Sheep | Welshman
01:31:09 <wuxia> father/mother are also sheep
01:31:14 <dibblego> type Father = Sheep
01:31:18 <wuxia> if they exist
01:31:18 <Beelsebob> :P
01:31:18 <dibblego> type Mother = Sheep
01:31:26 <dibblego> I was being more general :)
01:32:26 <wuxia> sorry, i'm a newb  can you show me the most basic one?
01:32:29 <wuxia> here's what ZI havbe so far:
01:32:30 <wuxia> type Sheep = (Name, Father, Mother)
01:32:30 <wuxia> type Father = Parent
01:32:30 <wuxia> type Mother = Parent
01:32:30 <wuxia> data Parent = None | Sheep
01:33:44 <dibblego> the 'type' keyword simply creates an alias
01:33:52 <bd_> data Sheep = Sheep { name :: String, father :: Maybe Sheep, mother :: Maybe Sheep }
01:35:07 <gwern> @tell sjanssen btw, the bug in mueval you pointed out is fixed. thanks for pointing it out
01:35:07 <lambdabot> Consider it noted.
01:36:13 <wuxia> bd_: cool thanks, i was hoping for something like that
01:36:27 <reubenf> is it possible to get functions evaluated at compile time? i have a lot of functions that are going to be evaluated every time my program runs
01:37:08 <bd_> reubenf: usually you should only second-guess the compiler after confirming that there's a performance problem :)
01:37:15 <bd_> what do you mean by evaluated at compile-time though?
01:37:17 <bd_> constant folding?
01:37:19 <bd_> inlining?
01:37:22 <bd_> memoizing?
01:37:22 <wuxia> what does {} do in the data declaration above? is it the same as constructing tuples ?
01:37:27 <reubenf> i memoizing
01:37:38 <gwern> partial evaluation?
01:37:59 <gwern> wuxia: no, it's part of the record syntax
01:38:02 <bd_> reubenf: You can force GHC to memoize a top-level constant value (not the results of a function) with {-# NOINLINE symbol #-}
01:38:04 <dibblego> wuxia, it allows you to name the fields of the data type (see name, mother, father)
01:38:05 <gwern> not tuples
01:38:15 <gwern> (`I don't think, anyway)
01:38:26 <dibblego> yes, records
01:38:27 <bd_> reubenf: however with functions, you're on your own... I think someone wrote a paper on how to do a magic memoization adapter some time back but I don't hjave the link offhand
01:38:42 <dibblego> @google simon peyton-jones weak pointers
01:38:43 <lambdabot> http://research.microsoft.com/users/simonpj/Papers/weak.htm
01:38:43 <lambdabot> Title: Simon Peyton Jones: papers
01:38:50 <dibblego> reubenf, that might help ^^
01:38:55 <reubenf> thanks :)
01:39:11 <wuxia> for educatino purposes; how can I create this type as a tuple? the following doesw not work: data SheepTuples = (String, Maybe SheepTuples, Maybe SheepTuples)
01:39:24 <dibblego> data SheepTuples = SheepTuples (String, Maybe SheepTuples, Maybe SheepTuples)
01:39:35 <bd_> wuxia: You can't make a recursive type without using data or newtype
01:39:44 <dibblego> data Type = Constructor1 <args> | Constructor2 <args> ...
01:39:59 * ski .oO( "Sheep" ? )
01:40:06 <bd_> wuxia: and the overhead of data is about the same as that of a tuple, so you might as well get rid of the tuple :)
01:40:09 <bd_> but with newtype:
01:40:23 <bd_> newtype SheepTuples = SheepTupls (String, Maybe SheepTuples, Maybe SheepTuples)
01:41:06 <bd_> newtype creates a new type for an existing set of data - that is, the variable's stored in memory exactly the same, and constructing or inspecting the value is optimized away at compile time, but it's /treated as/ a seperate type
01:41:11 <bd_> allowing recursion
01:41:22 <gwern> nominolo was the fellow working on the GHC API this summer, right?
01:41:57 <bd_> type is more like a macro which is expanded to a larger type at compile time, so you'd end up with (String, Maybe (String, Maybe (String (Maybe .... :) [theoretically, this could be fixed, but this is nearly always a mistake, so it was deliberately made an error message]
01:43:02 <wuxia> dumb qudstion, why is this multiple defintinos of 'father' ?
01:43:04 <wuxia> data Sheep = Sheep { name :: String, father :: Maybe Sheep, mother :: Maybe Sheep }
01:43:06 <wuxia> father :: Sheep -> Maybe Sheep
01:43:09 <wuxia> father s@(n, f, m) = n
01:43:20 <wuxia> the first 'father' is a field of Sheep, the second is just declaring it's type, the fhird actually defines it
01:43:28 <dolio> Record types automatically define accessor functions.
01:43:30 <Botje> that record already defines a function father:: Sheep-> Maybe Sheep
01:43:35 <gwern> wuxia: no, the field becomes a function
01:43:36 <Botje> so you don't have to do it
01:43:44 <ddarius> bd_: In the cases of type synonyms, it would dramatically change what they meant.  It is usually not a (conceptual) mistake to write such synonyms.
01:43:47 <wuxia> okay, so for a newb like me, who should learn how to do this manually
01:44:08 <wuxia> how would i define the type of Sheep ?
01:44:20 <Botje> data Sheep = Sheep String (Maybe Sheep) (Maybe Sheep)
01:44:30 <Botje> then use pattern matching to define name, father, mother
01:44:34 <wuxia> (OT: so I should treap haskell's type as C's typedef ?)
01:44:36 <wuxia> let me try that, thanks
01:44:49 <Botje> not quite
01:44:53 <Botje> type X = ... is a typedef
01:44:57 <bd_> wuxia: basically, yes, haskell's type acts like C's typedef. newtype makes a struct with a single element. Something like that :)
01:45:01 <Botje> data X = ... is something else :)
01:45:11 <bd_> and yes data makes a much more interesting thing
01:45:19 <wuxia> is data blah like unions ?
01:45:31 <bd_> wuxia: kinda like a union with a tag
01:45:42 <Botje> they're unions, except they don't suck
01:45:45 <ddarius> wuxia: You should be familiar with Haskell before you bother with "All About Monads"
01:46:21 <wuxia> yeah, the problem is, i really only learn if i have an ihnteresting projhect
01:46:30 <wuxia> and i can't do anything interesting w/o monads :-(
01:46:35 <Botje> write a compiler! >:)
01:46:41 <wuxia> but luckily,  there are many smart and kind hearted ppl on irc :-)
01:46:42 <bd_> data Sheep = Sheep String (Maybe Sheep) (Maybe Sheep)  [newline]  name (Sheep n _ _) = n   [newline]  father (Sheep _ f _) = f
01:46:43 <Beelsebob> then you deffinately shouldn't learn them wuxia
01:46:45 <bd_> etc
01:46:50 <Beelsebob> wuxia: you should learn to live without them
01:46:57 <Beelsebob> and *then* go back and learn about them
01:46:59 <ddarius> wuxia: Any Haskell tutorial will cover them in more than enough detail to use them.
01:47:14 <Botje> wuxia: there's always project euler
01:47:23 <ddarius> wuxia: But if you can't declare a data type, you hardly need to worry about understanding monads.
01:47:28 <Botje> although the avg score for haskell is embarassingly low >:(
01:47:43 <gwern> I favor the method where you rescue broken packages and learn through trial-and-error
01:48:05 * gwern is ignorant of types and monads, but I have a good handle on how to use cabal and ghc and everything!
01:48:10 <wuxia> hey, i'm famliar with scheme and have written code in assembly; onced I get monads and basic haskell syntac, i'll get set
01:48:38 <bd_> wuxia: Haskell is sufficiently different from either that that does not necessarily hold, imo :)
01:48:44 <Beelsebob> wuxia: yes -- but you'll be better off learning to love the applicative style, learn what it's all about, and why it's powerful -- and *then* going back and learning how monads really work
01:49:30 <wuxia> applicative style ... is like scheme w/o set!, no :-) ?
01:49:37 <sieni> wuxia: if you know scheme, then http://okmij.org/ftp/Scheme/monad-in-Scheme.html might be helpful
01:49:38 <lambdabot> Title: Monads in Scheme
01:50:06 <sieni> and also "Gentle introduction to Haskell" might be readable for you
01:50:14 <sieni> It's dense, but...
01:50:18 <gwern> @seen augustsson
01:50:19 <lambdabot> I haven't seen augustsson.
01:50:23 <wuxia> hmm, the foll.owing is kind of annoying:
01:50:24 <wuxia> data Sheep = Sheep { name :: String, father :: Maybe Sheep, mother :: Maybe Sheep }
01:50:28 <wuxia> data Cow = Cow { name :: String, father :: Maybe Cow, mother :: Maybe Cow }
01:50:28 <gwern> hm.
01:50:41 <ddarius> @seen augustss
01:50:41 <lambdabot> I saw augustss leaving #haskell 15m 37s ago, and .
01:50:44 <wuxia> so I can't have these two types have same field names?
01:50:49 <Botje> wuxia: yes. haskell records are rather annoying :)
01:51:00 <wuxia> so there's no wsay around this?
01:51:08 <gwern> @seen lennart
01:51:09 <lambdabot> I haven't seen lennart.
01:51:15 <ziman> pattern matching :)
01:51:19 <Botje> use my not-yet-written record-typeclass extension?
01:51:31 <gwern> preflex: seen augustsson
01:51:31 <preflex>  Sorry, I haven't seen augustsson
01:51:34 <Beelsebob> class Animal a where {mother :: a -> a; father :: a -> a}
01:51:43 <ddarius> wuxia: You can put them in different modules.  Modules are Haskell's namespace mechanism.
01:51:43 <Beelsebob> instance Animal Sheep...
01:51:54 <gwern> ok, I give up. what is lennart augustsson's IRC nick?
01:51:55 <ddarius> gwern: His nick is augustss and he left 15 minutes ago.
01:52:51 <gwern> @ask augustss So, what is up with djinn? I notice that the official darcs repo seems to be from 2005, but the one on hackage is from 2008. where's the real djinn darcs?
01:52:51 <lambdabot> Consider it noted.
01:52:54 <Botje> "ohshitmypostisuponplanethaskell! time to go sheep farming!"
01:52:55 <gwern> ddarius: thnx
01:53:21 <gwern> ...sheep farming?
01:53:28 <Botje> yes.
01:53:28 * gwern continues to shave some yaks
01:53:35 <Botje> they're like lambdas, except fuzzier
01:54:11 <gwern> you can see through them/are referentially transparent?
01:54:14 <Botje> and some of them are bastards >:)
01:54:56 <Botje> hehe
01:55:07 <Botje> transparent sheep would rather ruin the wool industry :p
01:55:17 <Botje> or any somewhat-blind sheep farmer
01:55:21 <Botje> "where'd they go!"
01:55:27 <gwern> and it would save the lingerie industry
01:55:36 <Axman6> Botje: would be great in the erotica clothing industry though
01:55:40 * gwern feels around for those pesky greeks
01:55:40 <Botje> hehehehe
01:55:53 * Axman6 high fives gwern 
01:56:14 * gwern low-fives. and around the backside!
02:02:17 <wuxia> mothersPaternalGrandfather :: Sheep -> Maybe Sheep
02:02:17 <wuxia> mothersPaternalGrandfather s = (Just s) `comb` mother `comb` father `comb` father
02:02:22 <wuxia> why does this work?
02:02:29 <wuxia> since its type os Sheep -> ...
02:02:34 <wuxia> how am I able to do (Just s)
02:02:42 <Botje> Just is just a data constructor for Maybe
02:02:45 <wuxia> doesn't that imply  it's really Maybe Sheep -> Maybe Sheep
02:02:48 <Botje> @hoogle Just
02:02:49 <lambdabot> Prelude.Just :: a -> Maybe a
02:02:49 <lambdabot> Data.Maybe.Just :: a -> Maybe a
02:02:49 <lambdabot> Data.Maybe.isJust :: Maybe a -> Bool
02:03:01 <wuxia> oh
02:03:04 <wuxia> hehe; thanks;
02:04:28 <wuxia> @hoogle >==
02:04:29 <lambdabot> No matches found
02:04:36 <dibblego> @hoogle (>==)
02:04:36 <lambdabot> No matches found
02:04:40 <dibblego> @hoogle (>>=)
02:04:40 <lambdabot> Prelude.(>>=) :: Monad m => m a -> (a -> m b) -> m b
02:04:40 <lambdabot> Control.Monad.(>>=) :: Monad m => m a -> (a -> m b) -> m b
02:04:40 <lambdabot> Control.Monad.Instances.(>>=) :: Monad m => m a -> (a -> m b) -> m b
02:04:55 <Botje> yay for scary types!
02:10:24 <ski> wuxia> :t comb
02:10:33 <wuxia> :t comb
02:10:34 <lambdabot> Not in scope: `comb'
02:10:45 <wuxia> comb :: Maybe a -> (a -> Maybe b) -> Maybe b
02:10:45 <wuxia> comb Nothing _ = Nothing
02:10:45 <wuxia> comb (Just x) f = f x
02:11:45 <ski> @src Maybe (>>=)
02:11:45 <lambdabot> (Just x) >>= k      = k x
02:11:45 <lambdabot> Nothing  >>= _      = Nothing
02:11:59 <ski> so `comb = (>>=)'
02:12:06 <wuxia> oh  wow
02:12:08 <wuxia> i love this tutorial
02:12:21 <wuxia> >>= seemed like blackmagic to me all this time
02:12:30 <ski> s :: Sheep
02:12:37 <ski> Just s :: Maybe Sheep
02:12:46 <ski> mother :: Sheep -> Maybe Sheep
02:12:54 <wuxia> wait, one thing i don't understand
02:12:56 <ski> Just s `comb` mother :: Maybe Sheep
02:12:58 <ski> etc
02:13:14 <wuxia> is >>= an user defined _infix_  functions?
02:13:22 <ski> yes
02:27:17 <Botje> it's different for every monad
02:27:34 <Botje> but it's just an ordinary function, sure :)
02:35:08 <EvilTerran> > let (\^.^/) = (,) in "user defined infix functions" \^.^/ "yay!"
02:35:10 <lambdabot>  ("user defined infix functions","yay!")
02:35:56 <Botje> :)
02:36:36 <EvilTerran> wuxia, you can make most strings of punctuation your own infix operator in haskell. it's really quite handy.
02:37:23 <EvilTerran> most: excluding the symbols "'()[] and a few others, and excluding special names like (\) and (<-)
02:41:38 <ziman> > let #$@ = (+) in 3 #$@ 4
02:41:39 <lambdabot>  Parse error at "#$@" (column 5)
02:42:41 <wuxia> in http://www.haskell.org/all_about_monads/html/analogy.html, where is Wrapped defined? I see the definitino for wrapper, but not for wrapped
02:42:42 <lambdabot> Title: A physical analogy for monads
02:44:48 <ski> > let (#$@) = (+) in 3 #$@ 4
02:44:50 <lambdabot>  7
02:46:40 <nornagon> ski: language!
02:49:18 <ski> nornagon : `Language.Haskell.Syntax' ?
02:49:34 <BONUS> hey, how do you split a Rational into two ints?
02:50:39 <ski> @src Rational
02:50:39 <lambdabot> type Rational = Ratio Integer
02:50:41 <ski> @src Ratio
02:50:41 <lambdabot> data (Integral a) => Ratio a = !a :% !a
02:50:45 <ski> @type numerator
02:50:46 <lambdabot> forall a. (Integral a) => Ratio a -> a
02:50:51 <ski> @type denominator
02:50:52 <lambdabot> forall a. (Integral a) => Ratio a -> a
02:50:54 <BONUS> ah
02:50:55 <BONUS> coo
02:50:55 <BONUS> l
02:51:12 <BONUS> wait where is numerator defined
02:51:18 <ski> @index numerator
02:51:18 <lambdabot> Data.Ratio
02:51:23 <BONUS> awesome
02:51:23 <BONUS> thanks
02:51:30 <ski> @botsnack
02:51:30 <lambdabot> :)
02:51:35 <BONUS> ski++
02:52:04 <BONUS> so to get it into a tuple you just do (numerator &&& denominator)
02:52:30 <ski> @type numerator &&& denominator
02:52:31 <lambdabot> forall a. (Integral a) => Ratio a -> (a, a)
02:53:48 <ski> > map (numerator &&& denominator) [n % d | [n,d] <- replicateM 2 [1,2,3,6,12]]
02:53:49 <lambdabot>  [(1,1),(1,2),(1,3),(1,6),(1,12),(2,1),(1,1),(2,3),(1,3),(1,6),(3,1),(3,2),(1...
02:54:50 <ivanm> ghc uses some graph theory stuff for optimizations, doesn't it?
02:55:32 <BONUS> that replicateM 2 there is like using n <- [1,2,3,6,12], d <- [1,2,3,6,12], right?
02:55:34 <hpaste>  iamabarnacle pasted ""Programming with Arrows" Exercise 1" at http://hpaste.org/8725
02:55:50 <ski> aye
02:55:57 <iamabarnacle> anyone here done exercise 1 of programming with arrows?
02:56:14 <iamabarnacle> my loop implementation sort of hangs :(
02:56:50 <wuxia> how can I define 'Wrapped' so I can write "Tray Wrapped Chopsticks" instead of "Tray (Wrapper Chopsticks)"?
02:58:21 <ski> iamabarnacle : surely `loop (Put (b, _) s) = Put b (loop s)' is wrong .. you should not throw away the right part of the pair
02:58:29 <ski> @type Control.Arrow.ArrowLoop.loop
02:58:30 <lambdabot> Couldn't find qualified module.
02:58:54 <ski> @type Control.Arrow.loop
02:58:55 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowLoop a) => a (b, d) (c, d) -> a b c
02:59:03 <iamabarnacle> ski: oh...  i thought i only needed d for matching
02:59:14 <ski> the right part should be fed back as input
02:59:47 <ski> (you may need a helper function for this ..)
03:00:04 * Beelsebob giggles, #macosx is slowly turning into #haskell2
03:00:06 <iamabarnacle> ski, oh, sorry, i was looking at the wrong def
03:00:21 <EvilTerran> wuxia, actually, that'd come down to how you define Tray
03:00:25 <iamabarnacle> thanks, i'll look into that
03:01:10 <EvilTerran> wuxia, if you have "type Tray' adj noun = Tray (adj noun)", then you could write "Tray Wrapper Chopsticks"
03:01:20 <EvilTerran> but that's not a very scalable approach
03:01:49 <EvilTerran> or you could just write "Tray . Wrapper $ Chopsticks" or whatever
03:03:27 <ski> iamabarnacle : (as could be guessed), the other defining equation of `loop' is also wrong .. it should not require a `Put' being used "after"/"inside" the `Get'
03:04:13 <iamabarnacle> i should handle the case where get is returned?
03:04:13 <BONUS> what's a shorter way of doing (f *** f) x
03:04:14 <BONUS> so you dont have to write f twice
03:05:35 <ski> join (***) f x
03:05:35 <ivanm> @pl (f *** f)
03:05:36 <lambdabot> f *** f
03:05:51 <BONUS> hmm kewl
03:05:57 <BONUS> i didnt know (***) was a monad
03:06:01 <Axman6> @src (***)
03:06:02 <lambdabot> f *** g = first f >>> second g
03:06:03 <ivanm> BONUS: what ski wrote only works though if it was the exact same type
03:06:06 <ski> (using `instance Monad (e ->)')
03:06:15 <Axman6> @src (>>>)
03:06:15 <lambdabot> Source not found.
03:06:41 <ziman> :t ((,) `on`)
03:06:42 <lambdabot> forall b a. (a -> b) -> a -> a -> (b, b)
03:06:45 <ivanm> if f is a class method and x = (y,z) :: (Y,Z), then join (***) f mightn't typecheck
03:06:46 <ski> ivanm : yes .. i assumed same instance
03:06:54 * ivanm had that problem the other day :s
03:07:18 <ziman> > (,) `on` (+1) 3
03:07:20 <lambdabot>   add an instance declaration for (Num (a -> b))
03:07:32 <ski> > ((,) `on` (+1)) 3
03:07:33 <ziman> > ((,) `on` (+1)) 3
03:07:36 <lambdabot>  <Integer -> (Integer,Integer)>
03:07:36 <lambdabot>  <Integer -> (Integer,Integer)>
03:07:43 <ziman> hmmm
03:08:37 <ziman> oh, it requires two a's :\
03:08:53 <ziman> > ((,) `on` (+1)) 3 4
03:08:54 <lambdabot>  (4,5)
03:10:23 <ziman> > join ((,) `on` (+1)) 3
03:10:25 <lambdabot>  (4,4)
03:12:31 <EvilTerran> ?type (,) `on` (+1)
03:12:32 <lambdabot> forall a. (Num a) => a -> a -> (a, a)
03:13:05 <EvilTerran> again with the rank-1 polymorphism tripping folk up
03:13:09 <ski>   loop (fix $ \foo -> Get $ \(x0,s0) -> Get $ \(x1,s1) -> Put (s0,x0:s1) $ Put (s1,x1:s0) $ foo) `runSP` [0,1,2,3]
03:13:13 <ski> should return
03:13:33 <ski>   [cycle [0,1],cycle [1,0],cycle [2,3],cycle [3,2]]
03:13:39 <ski> (if i'm not mistaken)
03:13:49 <ski> iamabarnacle ^
03:14:11 <EvilTerran> ?type (((,) `on`) :: (Num a, Num b) => (forall c. Num c => c -> c) -> a -> b -> (a,b)) (+1)
03:14:12 <lambdabot>     Couldn't match expected type `forall c. (Num c) => c -> c'
03:14:12 <lambdabot>            against inferred type `a -> b'
03:14:12 <lambdabot>       Expected type: (forall c. (Num c) => c -> c)
03:14:22 <iamabarnacle> noted, i see that the put def for loop should be something like the get def for first
03:14:30 <ski> iamabarnacle : so your case for `Get' must be able to handle there being another `Get' directly inside it
03:14:34 <ziman> > join (***) (+1) (join (,) 3)
03:14:35 <lambdabot>  (4,4)
03:14:40 <EvilTerran> ?type ((,) `on`)
03:14:41 <lambdabot> forall b a. (a -> b) -> a -> a -> (b, b)
03:15:06 <EvilTerran> ?type ((,) `on`) :: (forall a b. a -> b) -> a -> b -> (c,d)
03:15:07 <lambdabot>     Couldn't match expected type `forall a b. a -> b'
03:15:07 <lambdabot>            against inferred type `a -> b'
03:15:07 <lambdabot>       Expected type: (forall a2 b2. a2 -> b2) -> a1 -> b1 -> (c, d)
03:15:08 <iamabarnacle> ski, yeah, my first attempt handled that but i couldn't think of a way to handle it then
03:15:09 <EvilTerran> pah
03:15:24 <ski> iamabarnacle : "it" being ?
03:15:29 <kiris> is there a notation for expressing a number by its bits in haskell?
03:15:42 <iamabarnacle> the case where there is a get inside a get in the loop def
03:16:39 <ski> EvilTerran : maybe you want `forall f g a0 a1. (forall a. f a -> g a) -> f a0 -> f a1 -> (g a0,g a1)' ?
03:18:10 <EvilTerran> ski, that was just a useless type i was using to see if it was possible to use that shape of rank-2 type for "on"
03:18:21 <EvilTerran> ?type on -- but it seems you can't
03:18:22 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
03:18:31 <EvilTerran> you'd have to create an "on" with a more general type
03:19:29 <ziman> EvilTerran, what would it look like?
03:20:40 <EvilTerran> ?type let on :: (Num a, Num b) => (a -> b -> c) -> (forall d. Num d => d -> d) -> a -> b -> c; (??) `on` f = \x y -> f x ?? f y in (,) `on` (+1)
03:20:41 <lambdabot> forall a b. (Num a, Num b) => a -> b -> (a, b)
03:21:00 <EvilTerran> unfortunately, you'd need a new one for each typeclass you wanted that to work for
03:21:16 <EvilTerran> there's gotta be some cunning solution to that, but i don't know what it is
03:21:21 <EvilTerran> maybe i'll write a paper about it sometime :P
03:21:55 <ski> kiris : seems there's octal, decimal and hexadecimal integer literals .. but no binary ones
03:22:37 <EvilTerran> class-parameterised types or something
03:22:55 <solrize_> gadt?
03:23:18 <EvilTerran> that could work, but it'd take quite a bit of boilerplate for each class you wanted to use that way
03:24:04 <ski> maybe subkinds of `*' expressing required class constraints, together with kind polymorphism ?
03:24:40 <EvilTerran> if you had "data Fooy where Fooy :: Foo a => a -> Foo" for each class Foo you wanted to use, i think you could then use the current `on`. not sure.
03:24:50 <BONUS> hmm hey guys i made a function that gives the nth approximation of the square root of 2 in a rational form, do you think its cool? http://hpaste.org/8726
03:24:52 <EvilTerran> ski, yeah, something like that
03:25:01 <BONUS> because project euler doesnt seem to think it is
03:25:04 <BONUS> ;_;
03:25:18 <EvilTerran> ski, i was thinking a new variety of kind expressing "expects a class of n parameters"
03:25:40 <ski> elaborate ?
03:26:13 <EvilTerran> type OnType class = (class a, class b) => (a -> b -> c) -> (forall d. class d => d -> d) -> a -> b -> c
03:26:15 <EvilTerran> or something
03:26:27 <EvilTerran> er, ignoring the use of "class" as a variable when that's not allowed :)
03:26:45 <EvilTerran> not sure how that'd even work, but you get the rough idea
03:27:04 <solrize_> bonus, cute
03:27:10 <BONUS> hehe
03:27:20 <solrize_> that may not give you the closest fraction though
03:27:28 <BONUS> how so
03:27:29 <solrize_> like a continued fraction would
03:27:38 <BONUS> aha i didnt know that hmm
03:27:57 * ski was thinking something like `on :: forall k =< *. forall (a0 :: k) (a1 :: k) (b :: *). (a0 -> a1 -> b) -> (forall (a :: k). a -> a) -> a0 -> a1 -> b'
03:28:00 <BONUS> is it because of precision
03:28:01 <BONUS> or something else
03:28:02 <solrize_> i just mean that the nth step of that might be a/b  but there could be a smaller c/d that's closer to the actual sqrt 2
03:28:27 <solrize_> bonus you're doing newton's approximation and that will give you large denominators pretty quickly
03:28:28 <BONUS> oh
03:28:47 <BONUS> cause im actually trying to solve this http://projecteuler.net/index.php?section=problems&id=57
03:28:48 <lambdabot> Title: Problem 57 - Project Euler
03:28:55 <ski> where `k' in our application would be instantiated to `{ a :: * | Num a }' or however it should be written
03:29:14 <EvilTerran> ski, er... i think i might find this easier to think about if i make the implicit dictionary parameter explicit for a minute
03:29:17 <EvilTerran> i'll get back to you
03:29:23 <BONUS> the problem wants to know how many fractions contain a numerator with more digits than the denominator in the first 1000 fractions
03:29:38 <solrize_> oh i see, your implementation is probably ok
03:29:49 <solrize_> you just have to count how many of those items have the property
03:29:53 <BONUS> yeah
03:29:57 <BONUS> strange it doesnt work tho :\
03:30:08 <BONUS> let me put up the rest of my code
03:30:24 <hpaste>  (anonymous) annotated "square root of 2 fraction" with "(no title)" at http://hpaste.org/8726#a1
03:30:45 <ski> EvilTerran : so `forall a :: {a :: * | Num a}. ..a..' would be the same as `forall a :: *. Num a => ..a..'
03:31:15 <BONUS> i think that should give the proper answer after some churning but it doesnt :\
03:32:42 <solrize_> too fancy for me :)
03:33:32 <BONUS> haha well basically u is just (number of digits in numerator, number of digits in denominator)
03:33:44 <BONUS> oh well
04:11:57 <BONUS> @src iterate
04:11:57 <lambdabot> iterate f x =  x : iterate f (f x)
04:16:59 <oldsalt> when i try to install ghc-6.8.3, i get the following error message:
04:17:03 <oldsalt> checking for path to top of build tree... configure: error: cannot determine current directory
04:17:08 <oldsalt> can anyone help me with that one?
04:17:32 <Heffalump> is this some *nix?
04:17:36 <oldsalt> yes
04:17:53 <Heffalump> does opening a new shell fix it?
04:18:02 <Heffalump> I'm wondering if your current one has lost track of pwd somehow.
04:18:29 <oldsalt> no, a new shell does not fix it
04:18:59 <Heffalump> does pwd report the current directory correctly?
04:19:04 <oldsalt> yes
04:19:18 <oldsalt>  i think there is a pwd in utils/pwd that is trying to be used
04:19:44 <oldsalt> when i try to run that one i am getting some floating exception
04:19:52 <Heffalump> oh, then you have bigger problems
04:20:03 <Heffalump> that's just the first GHC-compiled executable anything tries to run
04:20:06 <Heffalump> they'll all be broken (probably)
04:20:19 <oldsalt> mmh
04:20:20 <Heffalump> is this x86?
04:20:44 <Smokey`> did dons end up figuring out the foldr Just (1,1) bug?
04:20:52 <oldsalt> yes
04:21:00 <Smokey`> what did it end up being?
04:21:09 <oldsalt> sorry, i meant heffalump
04:21:15 <Smokey`> ah :)  np
04:21:25 <ivanm> a google cache of martin erwig's fgl page says that a new version was released last month... anyone have any clue when it'll go up on hackage?
04:21:29 <Heffalump> oldsalt: and one of the standard binary distributions on the website?
04:21:33 <Smokey`> > foldr Just (1,1)
04:21:35 <lambdabot>  Couldn't match expected type `b -> b'
04:21:44 <oldsalt> i did not try yet
04:21:52 <oldsalt> ghc6.6 is running on that machine
04:21:53 <ivanm> (especially since his website seems to be down :s )
04:22:03 <Heffalump> you didn't try what?
04:22:31 <oldsalt> Heffalump, the binaries
04:22:37 <Heffalump> so what are you trying to install from?
04:23:22 <oldsalt> well, i have 6.6 and i thought it would be a good idea to update to 6.8.3
04:24:02 <Heffalump> right, but what are you using to get the error above? Building from source?
04:24:15 <oldsalt> yes
04:24:47 <oldsalt> i  downloaded the source and run the configure script as the installation instructions told me
04:25:08 <Heffalump> have you used your existing GHC installation?
04:25:28 <Heffalump> in particular does it make trivial binaries ok?
04:25:43 <oldsalt> you mean if i can use 6.6 to compile stuff?
04:25:51 <Heffalump> yes
04:25:57 <oldsalt> i think so
04:26:04 <oldsalt> at least i could when i tried some months ago
04:26:06 * Heffalump has to go for a few mins back in a bit
04:26:09 <Heffalump> just check that again
04:26:16 <Heffalump> it might be that library upgrades have broken it somehow
04:26:19 <oldsalt> did not touch the machine since then
04:26:22 <oldsalt> ok, i will
04:32:20 <oldsalt> Heffalump, i can compile trivial stuff
04:33:24 <Heffalump> hmm. And configure bombs out quite early? Or has it actually spent quite a bit of time before it dies?
04:41:05 <ski> Smokey` : huh ?
05:33:19 <Smokey`> ski: watch... (someone discovered a ghc bug the other day, I'm curious if dons has figured it out - and what the issue was)
05:33:24 <Smokey`> > unfoldr Just (1,1)
05:33:28 <lambdabot>  [1,
05:34:49 <ski> hrm, that should be a cyclic type error
05:35:23 <Saizan> :t unfoldr Just
05:35:24 <lambdabot> forall a b. (a, b) -> [a]
05:35:25 <ziman> Prelude Data.List> unfoldr Just (1,1)
05:35:26 <ziman> [1,Segmentation fault
05:35:37 <opqdonut> wow
05:36:04 <dolio> It's a bug in the type checker.
05:36:19 <dolio> dons isn't a GHC developer.
05:36:46 <opqdonut> yeah, typechecker
05:36:51 <opqdonut> :t unfoldr Just
05:36:52 <lambdabot> forall a b. (a, b) -> [a]
05:37:02 <opqdonut> :t unfoldr (id . Just)
05:37:03 <lambdabot>     Occurs check: cannot construct the infinite type: b = (a, b)
05:37:03 <lambdabot>       Expected type: b -> Maybe (a, b)
05:37:03 <lambdabot>       Inferred type: b -> Maybe b
05:37:05 <opqdonut> :P
05:37:15 <ski> @type (\x -> x x)
05:37:16 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
05:37:17 <lambdabot>     Probable cause: `x' is applied to too many arguments
05:37:17 <lambdabot>     In the expression: x x
05:37:31 <Saizan> weird
05:37:42 <opqdonut> mhmm
05:37:52 <olsner> hmm, weird
05:38:00 <dolio> Only happens when you use raw constructors.
05:38:10 <dolio> Or, so it seems.
05:38:25 <opqdonut> so it does
05:40:59 <ski> @type unfoldr (id . Just :: forall a. a -> Maybe a)  -- hah!
05:41:00 <lambdabot> forall a b. (a, b) -> [a]
05:41:41 <opqdonut> hmm, maybe a isn't getting scoped right there
05:41:42 <ski> it rather seems to be related to polymorphic instantiation
05:41:44 <opqdonut> yes
05:42:25 <dolio> Huh.
05:42:35 <dolio> You might want to add that to the bug report if it's not there already.
05:43:03 <ski> maybe `forall a. a -> Maybe a' gets used twice .. with `a' binding to one thing in one instantiation, and to another thing in the other one
05:43:46 <ski> @type unfoldr
05:43:47 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
05:45:05 <Saizan> :t id . Just
05:45:06 <lambdabot> forall a. a -> Maybe a
05:46:52 <damg> is it possible to make haskell-mode to load imported modules lying in different trees? e.g. one module in Control... while the imported one is in Data... ?
05:49:37 <Saizan> damg: if you have Control and Data both under the same directory "foo" you can change the current directory of the ghci instance with ":cd path/to/foo" at the ghci prompt
05:49:43 <Saizan> damg: and then reload
05:50:24 <damg> Saizan, ah, yes, that's directly what I needed. Thank you very much
05:51:00 <ivanm> for those people here using Auctex and typesetting haskell code in Latex... what do you do when your code snippet has a '$' in it to stop auctex from thinking its entered a math environment? :s
05:52:33 <Axman6> \$?
05:54:08 <ivanm> yes, but won't that then typeset the haskell code as having \$ ?
05:54:13 <ski> > fix `id` \xs -> 1 : xs  -- not sure how pretty you think this is ..
05:54:15 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
05:54:56 <ivanm> yup, it does :s
05:55:01 <ski> er, of course `id' is not right-associative, either
05:55:43 <lorne> ivanm: are you using an evironment for your code? You might be able to do something like (add-to-list 'LaTeX-verbatim-environments "code")
05:56:06 <ivanm> lorne: I'm using lstlistings
05:56:20 <ivanm> so that should do it?
05:56:36 <lorne> with \lstnewenvironment ?
05:56:41 * ivanm would prefer for latex mode to be used for those blocks, but mmm-mode doesn't seem to work :s
05:56:55 <ivanm> lorne: nope... I probably should, but haven't bothered to do so yet
05:58:51 <ivanm> lorne: OK, that works for now, thanks!
05:59:10 <lorne> you're welcome :)
05:59:43 <olsner> @index sorted
05:59:43 <lambdabot> bzzt
05:59:48 <olsner> :t sorted
05:59:50 <lambdabot> Not in scope: `sorted'
05:59:51 <opqdonut> auctex is a pretty solid emacs mode
05:59:56 <opqdonut> in terms of configurability and stuff
06:00:09 <olsner> no such function, eh...
06:04:34 <olsner> @qc all . (zipWith (<) `ap` tail) . sort
06:04:34 <lambdabot> Not enough privileges
06:04:42 <olsner> @help qc
06:04:43 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
06:04:48 <olsner> @help quickcheck
06:04:48 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
06:04:54 <ski> @help check
06:04:54 <lambdabot> check <expr>
06:04:54 <lambdabot> You have QuickCheck and 3 seconds. Prove something.
06:05:03 <olsner> @check all . (zipWith (<) `ap` tail) . sort
06:05:05 <lambdabot>  Couldn't match expected type `a -> Bool'
06:05:20 * olsner fail
06:05:36 <ski> @type all . (zipWith (<) `ap` tail) . sort
06:05:37 <lambdabot>     Couldn't match expected type `a -> Bool'
06:05:37 <lambdabot>            against inferred type `[Bool]'
06:05:37 <lambdabot>     Probable cause: `zipWith' is applied to too many arguments
06:06:27 <Axman6> @src ap
06:06:27 <lambdabot> ap = liftM2 id
06:06:38 <Axman6> @src liftM2
06:06:38 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
06:06:54 <saadahmad> Hey, out of curiosity, what is the point of check. What does "check" check?
06:07:02 <ski> @check False
06:07:04 <lambdabot>  Falsifiable, after 0 tests:
06:07:14 <olsner> @type zipWith (<) `ap` tail
06:07:15 <lambdabot> forall a. (Ord a) => [a] -> [Bool]
06:07:30 <olsner> @type (zipWith (<) `ap` tail) . sort
06:07:31 <lambdabot> forall a. (Ord a) => [a] -> [Bool]
06:07:38 <olsner> @type all . (zipWith (<) `ap` tail) . sort
06:07:39 <lambdabot>     Couldn't match expected type `a -> Bool'
06:07:39 <lambdabot>            against inferred type `[Bool]'
06:07:39 <lambdabot>     Probable cause: `zipWith' is applied to too many arguments
06:07:46 <olsner> @type all
06:07:47 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
06:07:51 <olsner> aaah!
06:07:51 <tchakkazulu> olsner: Try "and" instead of "all".
06:07:52 <ski> @check \x y -> ((x + y)^2 :: Int) == (x^2 + 2*x*y + y^2)
06:07:54 <lambdabot>  OK, passed 500 tests.
06:08:07 <ski> @check \x y -> ((x + y)^2 :: Int) == (x^2 - 2*x*y + y^2)
06:08:08 <lambdabot>  Falsifiable, after 1 tests: 1, 3
06:08:11 <Axman6> olsner: looking for and ?
06:08:14 <olsner> @check and . (zipWith (<) `ap` tail) . sort
06:08:16 <lambdabot>  Falsifiable, after 1 tests: [(),()]
06:08:28 <olsner> @check and . (zipWith (<=) `ap` tail) . sort
06:08:30 <lambdabot>  OK, passed 500 tests.
06:08:43 <olsner> wohoo, but did it test only lists of ()?
06:08:46 <tchakkazulu> olsner: This will only test lists of [()], so that doesn't mean much.
06:08:59 <tchakkazulu> olsner: Yeah, () is the default instance of Arbitrary it uses.
06:09:00 <paarden> olsner: add a type signature and it will test other types
06:09:20 <olsner> @check and . (zipWith (<=) `ap` tail) . (sort :: [Integer] -> [Integer])
06:09:21 <lambdabot>  OK, passed 500 tests.
06:09:47 <ski> saadahmad : it randomly generates test data, and checks a given property on them
06:10:13 <saadahmad> ski, Oh I see
06:14:20 <masak> what's the standard way to create a queue data structure in Haskell?
06:17:53 <ski> masak : the folk lore way is using a pair of lists .. this is an instance of a "zipper"
06:18:06 <masak> ok
06:18:20 <masak> anything good I can read on that?
06:19:16 <paarden> masak: okasaki would probably cover it
06:19:37 <paarden> masak: 'purely functional data structures'
06:19:47 <masak> paarden: thank you
06:23:17 <joey__> Can I use parsec to parse a string of Tokens rather than characters?
06:23:55 <vixey> joey__: Yes
06:23:56 <paarden> joey__: yes, you can. :)
06:24:13 <joey__> Suspected as much, thanks vixey, paarden
06:32:42 <byorgey> preflex: seen edwardk
06:32:42 <preflex>  edwardk was last seen on #haskell 20 hours, 16 minutes and 56 seconds ago, saying: dmwit: now for your next trick make sure that no two of them will respond to the same message ;)
06:33:22 <byorgey> @ask edwardk shouldn't ana g = InF . fmap (cata g) . g
06:33:22 <lambdabot> Consider it noted.
06:33:38 <byorgey> argh! dumb copy-pasted newline
06:34:06 <byorgey> @ask edwardk ignore the previous message.  I meant, shouldn't ana g = InF . fmap (ana g) . g?  you have 'cata' in the middle
06:34:06 <lambdabot> Consider it noted.
06:35:46 <ski> byorgey : that looks like a copy mistake, yes
06:36:06 <byorgey> that's what I thought, just making sure I'm not crazy =)
06:37:33 <Saizan> InF . fmap (ana g) . g  vs. f . fmap (cata f) . outF, it's like looking at a mirror
06:53:15 <vixey> :index many1
06:53:21 <vixey> @hoogle many1
06:53:21 <lambdabot> Text.ParserCombinators.ReadP.many1 :: ReadP a -> ReadP [a]
06:53:21 <lambdabot> Text.ParserCombinators.Parsec.Combinator.many1 :: GenParser tok st a -> GenParser tok st [a]
06:53:21 <lambdabot> Text.ParserCombinators.ReadP.skipMany1 :: ReadP a -> ReadP ()
06:53:32 <vixey> oh.....
06:53:40 <vixey> so GHC 6.9 doesn't have parsec
06:54:38 <olsner> will the next ghc come bundled with cabal-install?
06:57:07 <ski> Saizan : no wonder, the arrows are just reversed
06:58:48 <drguildo> can somebody please explain to me why none of these work: http://hpaste.org/8727
06:59:44 <vixey> why do I have to actually annotate GenParser Char st String to use parsec ?
07:01:00 <vixey> grguildo: use getGroups >>= mapM getGroupEntryForID
07:01:27 <ski> drguildo : mayhaps you want `mapM' ?
07:01:31 <drguildo> what am i doing wrong?
07:01:48 <vixey> using the wrong functions
07:01:54 <vixey> if the types don't match it will not work
07:01:54 <drguildo> i want to know why it isn't working
07:02:33 <araujo> drguildo, are you aware of the type signature of those functions?
07:02:34 <ski> drguildo : (a) `getGroups' is not a list (so you're right to use `(>>=)')
07:02:59 <drguildo> araujo, yeah
07:03:10 <ski> drguildo : (b) `(>>=)' wants the right argument to give an `IO'-action .. `map' will give a list
07:03:16 <ski> @type map
07:03:17 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:03:19 <ski> @type mapM
07:03:20 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
07:03:35 <ski> @type P.map  -- Cale !
07:03:36 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
07:04:33 <vixey> it says, No instance for (Text.Parsec.Prim.Stream s m Char)
07:04:38 <drguildo> can i use return on the result of the map?
07:04:43 <vixey> so I have to annotate, ident :: GenParser Char st String
07:04:49 <drguildo> *can't
07:04:52 <drguildo> or rather, why can't i
07:05:03 <vixey> how can I get rid of the Stream default so I don't haveto annotate?
07:05:27 <ski> vixey : hm, where does it complain ?
07:05:38 <vixey> when I load the file
07:05:39 <vixey> typechecking
07:05:52 <vixey> all I have is this ident = many (noneOf ",")
07:06:03 <drguildo> getGroups >>= \x -> return (map getGroupEntryForID x)
07:06:06 <drguildo> returns nothing
07:06:20 <vixey> grguildo: use getGroups >>= mapM getGroupEntryForID
07:06:29 <ski> vixey : sounds like DMR
07:06:37 <vixey> what's DMR?
07:06:40 <gbacon> how can I pack C structures with FFI?
07:06:45 <drguildo> i wan't to know why it doesn't work
07:06:55 <drguildo> not how to get it to work
07:07:29 <vixey> grguildo: understanding working code usually helps to know why broken things are broken but .. ok
07:07:47 <ski> vixey : the Dreaded Monomorphism Restriction
07:08:09 <vixey> ski, oh ! you're right
07:08:12 <ski> vixey : basically, either give an explicit type signature, or disable it
07:08:31 <araujo> drguildo, you know what mapM does?
07:09:30 <drguildo> not really
07:09:38 <drguildo> the type signature is confusing
07:09:41 <ski> drguildo : `getGroups >>= \x -> return (map getGroupEntryForID x) :: IO [IO GroupEntry]'
07:09:48 <drguildo> i would expect the result to be [m b]
07:09:51 <drguildo> not m [b]
07:09:57 <araujo> no way
07:10:05 <ski> drguildo : so you just get back a list of *unperformed* `IO'-actions
07:10:30 <drguildo> i don't know what that means
07:10:37 <ski> drguildo : to perform the actions, you either need to use `sequence' on the list .. or use `mapM' to begin with
07:11:50 <zx]treads> is there any speed improvements in ghc6.8.3 compared to 6.8.2?
07:11:58 <ski> drguildo : `[m b]' means a list of *unperformed* `m'-monad-actions, each giving a value of type `b' when performed  (`m' assumed to be a monad)
07:12:52 <drguildo> i don't know what unperformed is
07:12:56 <ski> drguildo : `m [b]' means an `m'-monad-action, that when performed (e.g. by using `<-' in `do'-notation) will give list of values of type `b'  (`m' assumed to be a monad)
07:12:59 <drguildo> and why doesn't m [b] return nothing
07:13:16 <ski> `m' is not the same as `Maybe'
07:13:25 <ski> @type getLine
07:13:26 <lambdabot> IO String
07:13:48 <ski> this is an `IO'-action, that *when*performed* will read a line of input, and return it
07:14:03 <ski> merely saying `getLine' somewhere in your program will not perform it
07:14:06 <ski> e.g.
07:14:11 <drguildo> so why doesn't m [b] stay unpeformed
07:14:47 <ski> it will, unless you sooner or later bakes it into the `main' action (or an action given to GHCi)
07:14:49 <araujo> drguildo, you have the resulting values on [b]
07:15:16 <drguildo> i don't know what bakes it into the main action means
07:15:24 <ski> main = do
07:15:27 <ski>   l <- getLine
07:15:35 <ski>   putStrLn (reverse l)
07:15:37 <araujo> it's what you are after for .... they just happen to be encapsulated inside an IO action
07:15:39 <drguildo> i'm using ghci
07:15:46 <drguildo> interactively
07:15:57 <ski> this "bakes" `getLine' into `main'
07:16:06 <ski> ok, in GHCi you can do
07:16:21 <ski> Blah> do l <- getLine; putStrLn (reverse l)
07:16:33 <ski> that will perform the `getLine' action
07:16:57 <ski> (btw, that's the same as `getLine >>= \l -> putStrLn (reverse l)', if you prefer that ..)
07:17:04 <drguildo> why doesn't m [b] stay unperformed and [m b] does
07:17:04 <ski> however, doing
07:17:07 <drguildo> when i'm using ghci
07:17:09 <drguildo> interactively
07:17:25 <araujo> :-\
07:18:05 <ski> Blah> do let {action = getLine}; print (length (replicate 10 l))
07:18:15 <araujo> drbean, m [b] /= [m b]
07:18:18 <ski> that will not perform the action `getLine'
07:18:18 <vixey> o_o
07:18:19 <araujo> er, drguildo
07:18:20 <vixey> @hoogle <<
07:18:21 <lambdabot> Text.XHtml.Frameset.(<<) :: HTML a => (Html -> b) -> a -> b
07:18:21 <lambdabot> Text.XHtml.Strict.(<<) :: HTML a => (Html -> b) -> a -> b
07:18:21 <lambdabot> Text.XHtml.Transitional.(<<) :: HTML a => (Html -> b) -> a -> b
07:18:26 <vixey> :t (<<)
07:18:27 <lambdabot> Not in scope: `<<'
07:18:38 <vixey> why is it not defined ?
07:18:46 <drguildo> i know they aren't the same
07:18:50 <ski> hm, istr it used to be
07:18:56 <drguildo> but that doesn't explain to me why one stays unperformed and the other does
07:18:58 <vixey> that's so odd though
07:20:13 <drguildo> why do you insist on using new examples to try and explain this rather than what i was trying to do?
07:20:19 <drguildo> it makes it more difficult to understand
07:20:23 <ski> drguildo : no action gets performed ever (apart from the starting point .. `main' or a GHCi given action) unless you put it as a "line" in `do'-notation  (or equivalently, using `(>>=)')
07:20:26 <drguildo> i am learning and so i don't know all the notation yet
07:20:48 <ski> drguildo : sorry .. i forgot your example
07:20:56 <drguildo> ok
07:21:29 <drguildo> so m [b] gets performed in ghci because the monad is used directly in an expression (in ghci)?
07:21:42 <drguildo> whereas i'd need to access an element of [m b] for it to be performed?
07:22:10 <araujo> That's because [m b] is not an action
07:22:16 <ski> lets look at `getGroups >>= \x -> mapM getGroupEntryForID x', ok ?
07:22:25 <araujo> [m b] is a _list_ of action
07:22:36 <araujo> that's why I asked you if you knew the difference
07:23:17 <drguildo> ski, ok
07:23:42 <ski> getGroups :: IO [System.Posix.Types.GroupID]
07:23:57 <sbahra> Someone here work with TLA+?
07:24:02 <ski> this is an `IO'-action, that when performed will give us a list of gids
07:24:49 <ski> now `(>>=)' is the main primitive way to "build" larger actions out of smaller actions
07:25:16 <ski> so, we want to get a hold of those gids .. but since haskell is pure, we can't have side-effects
07:25:56 <ski> so what we do is just build a larger `IO'-action, that *if*performed* will first get the list of gids .. then do something more with them, finally giving back some result we want
07:26:54 <ski> this larger `IO'-action can be *actually* performed by setting it to `main', or by feeding it to GHCi .. or by putting it inside yet another larger action which we then perform in the previous way
07:27:06 <ski> drguildo : ok so far ?  and question ?
07:27:09 <ski> s/and/any/
07:28:00 <drguildo> i think i understand
07:28:06 <ski> ok
07:28:13 <ski> so, now our concrete problem
07:28:16 <ski> we have something like
07:28:29 <ski>   getGroups >>= \x -> ..x..
07:28:32 <saadahmad> Can anyone help me with why I get kind errors in http://hpaste.org/8728?
07:28:59 <vixey> saadahmad: what if you use Set Stack ? instead of Set (Stack a) ?
07:29:29 <ski> `x' will here be the result of performing the `getGroups'  (whenever the larger action is actually performed, of course)
07:29:37 <ski> drguildo : ok ?
07:29:47 <ski> specifically
07:30:03 <ski>   x :: [System.Posix.Types.GroupID]
07:30:05 <saadahmad> vixey, Oh my bad thanks
07:30:07 <drguildo> but without being encapsulated in the monad?
07:30:33 <ski> right, `x' is the plain list result that we get from running the action *this* time
07:31:24 <ski> we can do anything we like with it .. the only catch is that we have to end with another `IO'-action .. this is usually expressed as : there is no "escape" from the `IO'-monad !
07:31:52 <ski> if you like, you can think of an `IO'-action as a list of instructions to perform
07:32:19 <ski> so, what we have to fill in the `..x..' with .. is just the list of instruction of what we want to do with `x'
07:32:22 <ski> ok ?
07:33:11 <drguildo> i think this is what i understood before
07:33:17 <ski> fine
07:33:17 <drguildo> so yeah
07:33:43 <ski> so, first, do you understand why `map' or `return (map ..)' doesn't work ?
07:34:10 <ski> alternatively, i can explain why `mapM' *is* what we want ?
07:34:30 <drguildo> ok so let me explain what i don't get
07:34:44 <ski> ok
07:34:52 <drguildo> the application of bind should result in a monad, right?
07:35:00 <drguildo> from evaluating the expression on the right of it
07:35:25 <ski> well, it should result in a monadic *action*  (the monad itself is the type .. plus `return' and `(>>=)')
07:35:34 <ski> but, yes
07:35:47 <ski> if you have
07:36:01 <ski> foo >>= \x -> ..x..
07:36:04 <drguildo> (i need to read up about actions, that is where most of my misunderstanding is, none of the tutorials i read spoke about them)
07:36:04 <ski> then given
07:36:15 <ski> foo :: IO Foo
07:36:19 <drguildo> (tutorials on monads)
07:36:23 <ski> x :: Foo
07:36:31 <ski> ..x.. :: IO Bar
07:36:36 <ski> foo >>= \x -> ..x..  ::  IO Bar
07:37:02 <drguildo> yeah
07:37:04 <drguildo> so anyway
07:37:17 <ski> drguildo : the `IO' itself is the monad .. the `foo' and the `getGroups' and the `getGroups >>= ...' is the `IO'-actions
07:37:26 <ski> it's just a naming issue, i think
07:37:27 <drguildo> map results in [a] and not IO [a]
07:37:41 <drguildo> but i thought return would convert [a] to IO [a]
07:37:43 <drguildo> or m [a]
07:37:44 <ski> well, it results in `[IO a]'  (for some `a')
07:37:45 <drguildo> or something
07:38:11 <ski> yes, `return' will convert `[IO a]' into `IO [IO a]'
07:38:18 <ski> however, that is not what you want
07:38:38 <ski> calling `return' on something never gives an action that actually *does* anything
07:39:08 <ski> in your case, you just get an action that does nothing, and returns back a list of actions that are still not performed once
07:39:33 <ski> so, one way to look at it is that you want to convert `[IO a]' into `IO [a]'
07:39:37 <ski> ok ?
07:39:58 <Aruz> hi all
07:40:19 <vixey> hey
07:40:28 <drguildo> yeah
07:40:45 <drguildo> i think
07:40:52 <ski> so, you have a list of actions .. you now want to get an action that performs all the list actions, and returns the list of the results
07:41:34 <ski> this function is called `sequence'  (i said before you could either use `mapM' or `sequence')
07:41:47 <ski>   sequence :: [IO a] -> IO [a]
07:42:02 <Aruz> I wanna AI
07:42:24 <ski> do you want to try defining this function (it is not very complex, if you've grasped simple recursion) ?
07:42:34 <ski> or should i just give the definition and explain it ?
07:42:48 <drguildo> erm
07:42:57 * Axman6 gives Aruz an AI
07:43:21 <ski> well, maybe i should first ask if you understand why this function could be handy in your case
07:43:22 <Aruz> Lisp or Haskell which I must learn
07:43:33 <Aruz> I am new to AI
07:43:34 <ski> Aruz : both !
07:43:43 <Aruz> both?
07:43:45 <Aruz> :)
07:43:45 <drguildo> would you just bind all the actions in the list and return the result?
07:44:01 <ski> drguildo : more or less that, yes :)
07:44:08 <ski> want to give it a stab ?
07:44:26 <drguildo> ok, can you give me something to test it with?
07:44:34 <BONUS> hint: sequence is really easy to implement with a fold
07:45:00 <BONUS> try making a function that will transform [Just 3, Just 4, Just 5] to Just [3,4,5] or [Just 1, Just 2, Nothing] to Nothing maybe?
07:45:22 <ski> drguildo : if you wanna test in e.g. GHCi, then maybe `map print [0,1,2,3]' can be a simple input ?
07:45:58 <Axman6> > map print [1..4]
07:46:00 <lambdabot>  [<IO ()>,<IO ()>,<IO ()>,<IO ()>]
07:46:03 <ski> BONUS : i believe drguildo is currently just learning the `IO'-monad  (i'm not sure how handy s/he is with folds, yes)
07:46:12 <BONUS> aha i see
07:46:34 <drguildo> i just started reading a bunch of tutorials on monads in general
07:46:44 <drguildo> i don't think i've read anything about IO specifically
07:46:52 <ski> ok
07:46:52 <drguildo> is that where all this action stuff is implemented?
07:47:10 <ski> each monad is defined on its own
07:47:49 <ski> its a bit like collections .. you've got list collections, set collections, etc .. each with a separate definition
07:48:07 <drguildo> yeah but monads all share stuff in common, right?
07:48:12 <drguildo> i mean do actions apply to all monads?
07:48:17 <ski> the `IO'-monad is used for .. well, I/O .. communicating with the outside world
07:48:32 <ski> yes, some parts are common
07:48:51 <mar77a> "This includes such issues as the nature of programming environments and the error messages returned for undefined programs (i.e. programs that formally evaluate to _|_)."
07:48:57 <mar77a> what does the in example bit mean ._o
07:49:16 <ski> the primitive `return' and `(>>=)' mean specifically different things in different monads .. but they have the "same overall" meaning, if that makes sense
07:50:08 <ski> then there's generic operations like `sequence' and `mapM' that work for any monad at all, those are just calling `return' and `(>>=)' for the specific monad that's used
07:50:41 <Aruz> which better lisp or haskell?
07:50:58 <Vq^> Aruz: why do you want to know?
07:51:01 <ski> Aruz : no
07:51:01 <Axman6> Aruz: that's s pretty silly question
07:51:14 <Aruz> I am new
07:51:21 <ski> the general concept of `action' and `performing' is shared by all monads .. the specifics of what it means is determined by what actual monad is used
07:51:24 <Aruz> I interested in nlp
07:51:36 <ski> Aruz : Neuro-Linguistic Programming ?
07:51:39 <Aruz> which I must learn?
07:51:40 <Aruz> yes
07:51:45 <vixey> Aruz: both
07:52:05 <Axman6> Aruz: do you know anything about nlp?
07:52:16 <Aruz> no
07:52:21 <Aruz> :P
07:52:27 <Aruz> I am new
07:52:27 <Axman6> anything about programming?
07:52:32 <Aruz> yes
07:52:33 <Axman6> new to what?
07:52:47 <Aruz>  to AI :)
07:52:51 <ski> Aruz : <http://en.wikipedia.org/wiki/Neuro-Linguistic_Programming> is about psychology
07:53:21 <vixey> not natural language programming ?
07:53:25 <ski> drguildo : did i lost you ?  or maybe you're just happy hacking together a `sequence' ?
07:53:59 <ski> vixey : that's another thing :)
07:54:02 <drguildo> ski, i am trying to write a sequence but i already have some error about "infinite type"s, *sigh*
07:54:17 <drguildo> haskell is impenetrable
07:54:23 <ski> drguildo : ok .. possibly you forgot a `return' in the base case ?
07:54:44 <ski> @hpaste
07:54:44 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:54:56 <ski> you can stuff what you have there
07:54:57 <drguildo> i have "sequence' [] = return", there probably needs to be more to it than that though
07:55:03 <ski> yes
07:55:24 <ski> `return' will only give you back an action if you pass it the result value it should give
07:55:31 <drguildo> yeah
07:55:32 <drguildo> but
07:55:56 <drguildo> i can't think of a way of getting at the results of all the performed actions
07:55:58 <ski> if you have a list of *zero* actions .. and you perform all of them .. collecting the results into a new list .. what should this new list be, then ?
07:56:10 <hpaste>  (anonymous) annotated "Kind Error help" with "(no title)" at http://hpaste.org/8728#a1
07:56:25 <drguildo> m []?
07:56:49 <shapr> @users
07:56:49 <lambdabot> Maximum users seen in #haskell: 462, currently: 437 (94.6%), active: 13 (3.0%)
07:57:10 <saadahmad> Err, why did it announce the hpaste here
07:57:13 <vixey> saadahmad: what if you use Set Tree ? instead of Set (Tree a) ?
07:57:28 <saadahmad> But doesn't the a need to be there since it must be an instance of Ord?
07:57:40 <Vq^> drguildo: which is exactly an empty list embedded in a monad
07:57:52 <vixey> and remove "Ord a => "
07:58:00 <ski> drguildo : since there were zero actions, there will be zero results .. so the list of the results will be the empty list
07:58:27 <drguildo> so was i right or wrong?
07:58:36 <saadahmad> vixey, but that messes it up completely
07:59:16 <ski> drguildo : `m' in `m []' was not a value (e.g. function) here .. it was a type .. we wanted a value to return
07:59:42 <ski> (drguildo : i may have been unclear about what kind of answer i wanted)
07:59:52 <saadahmad> vixey, I get http://hpaste.org/8728#a2
08:00:00 <drguildo> it has to be an instance of a monadic type though
08:00:03 <drguildo> an empty list in a monadic type
08:00:11 <ski> yes
08:00:20 <ski> the return type should be `IO [a]'
08:00:27 <vixey> saadahmad: ok, you could try the suggested "possible fix"
08:00:36 <ski> the empty list `[]' has type `[a]'
08:00:51 <ski> so we need to get from `[a]' to `IO [a]' .. how may we do this ?
08:01:22 <Axman6> add IO to the beginnging!
08:01:32 <ski> right
08:01:33 * Axman6 hopes that isn't actually right
08:01:35 <Axman6> damn
08:01:48 <vixey> :t return :: [a] -> IO [a]
08:01:48 <ski> how do we "add `IO' to the beginning"
08:01:49 <lambdabot> forall a. [a] -> IO [a]
08:02:12 <drguildo> the main problem i have is performing all the actions
08:02:15 <drguildo> i need to use bind
08:02:18 <saadahmad> vixey, but what if other data types that are instances of set don't require a to be instances of ord?
08:02:24 <drguildo> but now all this scope stuff is making me confused
08:02:24 <Vq^> drguildo: yes, you do
08:02:29 <drguildo> i don't know how to get to the results
08:02:35 <drguildo> so i can return them
08:02:42 <ski> drguildo : yes .. but you only need to use bind when you have more than one thing to do .. this is the recursive case
08:03:01 <ski> drguildo : what result do you want in the base case ?
08:03:09 <drguildo> IO []
08:03:26 <drguildo> i don't know how to run a single action then
08:03:41 <ski> drguildo : ok .. trying to ask better question :) .. what result *value* do you want the action to return ?
08:03:59 <drguildo> []?
08:04:01 <ski> yes
08:04:03 <ski> the empty list
08:04:12 <ski> now this is just a simple value
08:04:30 <ski> the right-hand-side of the `=' in the equation should be an action
08:04:31 <ski> agree ?
08:04:40 <drguildo> which equation?
08:04:52 <ski>   sequence' [] = ...
08:05:02 <drguildo> yeah
08:05:03 <drguildo> it does
08:05:08 <drguildo> i think
08:05:08 <ski> this is one of the defining equations for "sequence'"
08:05:17 <Vq^> drguildo: have you looked at the types of the functions in the Monad class? (return and >>= specificly)
08:05:40 <Saizan> saadahmad: there are various solutions to your problem, all of them involve some extension, but first of all if you declare a class like Set then the parameter you pass to it must have kind * -> * since 's' is applied to 'a' in the type signature of insert
08:05:49 <ski> so, since when we have zero actions, we have nothing special to *do*, we just want to *do*nothing* and return the empty result list
08:05:49 <drguildo> Vq^, yes
08:06:01 <Saizan> s/parameter/type/
08:06:27 <ski> drguildo : again, i repeat : the point of the function `return' is to give an action that doesn't actually *do* anything .. it just returns any value you like
08:07:31 <ski> drguildo : .. also, i'll say, after awhile, you don't need to think of the details here very much .. you just in some sense think like in an imperative language when you're coding monadic actions
08:07:41 <oldsalt> @seen Heffalump
08:07:41 <lambdabot> Heffalump is in #darcs and #haskell. I last heard Heffalump speak 3h 34m 17s ago.
08:08:02 <ski> anyway .. since i appear to have confused you too much, i'll tell you the answer here
08:08:12 <drguildo> i really have no idea what i'm doing anymore
08:08:15 <ski>   sequence' [] = return []
08:08:21 <ski> does that make any sense ?
08:08:42 <drguildo> it depends what you mean by make sense
08:08:47 <ski> we want to do nothing but "return" the empty list .. so that's what we write
08:09:08 <Heffalump> oldsalt: I'm here
08:09:13 <drguildo> i am trying to concatenate actions with it but it's failing
08:09:19 <drguildo> in the hope that the actions will be performed
08:09:23 <ski> `it' being ?
08:09:32 <drguildo> return []
08:09:32 <hpaste>  vicky annotated "Kind Error help" with "one way to do this ?" at http://hpaste.org/8728#a3
08:09:36 <drguildo> i really have no idea what i'm doing though
08:09:40 <drguildo> i'm just trying random stuff
08:10:00 <drguildo> i think i need to read about actions or something
08:10:00 <ski> what does your second defining equation look like, for the moment ?
08:10:25 <drguildo> sequence' (x:xs) = x ++ sequence' xs
08:10:32 <ski> ok
08:10:40 <ski> first remember
08:10:50 <ski>   sequence' :: [IO a] -> IO [a]
08:11:00 <ski> now, two questions
08:11:09 <ski> what types do `x' and `xs' have ?
08:12:15 <drguildo> x should be IO a
08:12:15 <drguildo> xs should be [IO a]
08:12:18 <Vq^> correct
08:12:30 <ski> so `x' is an *action*
08:12:55 <ski> how do we usually grab the result of an action ?
08:12:57 <drguildo> i know
08:13:17 <drguildo> i don't know
08:13:31 <ski> bind
08:13:35 <drguildo> i would say bind but you implied i shouldn't use it
08:13:37 <oldsalt> Heffalump, can i annoy you again with my compile problems?
08:13:45 <drguildo> because we aren't dealing with multiple values or something
08:13:45 <saadahmad> Saizan, sorry I was away a little, but could you explain kind's or a resource that explains them?
08:13:51 <Heffalump> sure
08:14:11 <oldsalt> k, i tried to compile something really trivial and it compiled
08:14:17 <Heffalump> my last question was about how early in the build process it failed - very close to the beginning?
08:14:29 <oldsalt> yes, very  early
08:14:36 <Vq^> drguildo: now you are, namely x and (sequence' xs)
08:14:43 <ski> drguildo : sorry .. in the first equation we weren't handling multiple things .. so there we didn't use bind
08:14:44 <Heffalump> so I can only imagine it was using your current GHC to build that. Odd.
08:14:44 <Frederick> Folks can someone suggest a good semantics book to have at home as bibliography?
08:15:10 <Heffalump> Do you have some technical or ideological reason to build from source, or would a binary dist do? If so and one is available I suggest you try that first.
08:15:20 <ski> drguildo : however, in the second eqation, we've got an action `x' and a whole list of more actions `xs' .. so here it's a good idea to consider bind
08:15:53 <oldsalt> no, i am pretty dogma free about everything
08:16:07 <oldsalt> i just did not find a current dist for debian
08:16:22 <Saizan> saadahmad: kinds are the types of types, they tell you if a type takes any parameter or not, for example Int :: * means that Int is plain type, while Maybe :: * -> * means that Maybe takes another type as argument and gives you a plain type
08:16:26 <ski> drguildo : does that help any ?
08:16:31 <ski> drguildo : if you feel like you aren't progressing here .. maybe it's time to read some, as you say .. or take a break
08:16:47 <saadahmad> Saizan, Thanks for the explanation :)
08:17:00 <drguildo> ski, that's what i was trying before but i don't know how to access all the values to return at the end
08:17:14 <ski> ok
08:17:21 <vixey> saadahmad: did you see my annotation to your paste? I don't know if this is a really good way but I think it is one solutinos
08:17:23 <ski> it's enough to begin with just a starting attempt
08:17:27 <drguildo> i am guessing i need to ++ or something
08:17:32 <ski> it doesn't need to try to be complete
08:17:32 <Heffalump> hmm, no, there doesn't seem to be one.
08:17:34 <saadahmad> vixey, Yes I did see it :)
08:17:53 <Vq^> drguildo: : is probably better suited
08:17:53 <Heffalump> You can get a binary tarball, though. That's basically equivalent to having a built source tree.
08:18:00 <mar77a> > (\x -> x + 1) == (+1)
08:18:01 <lambdabot>   add an instance declaration for (Eq (a -> a))
08:18:01 <lambdabot>     In the expression: (\ x -...
08:18:07 <mar77a> > (\a -> a + 1) == (+1)
08:18:08 <lambdabot>   add an instance declaration for (Eq (a -> a))
08:18:08 <lambdabot>     In the expression: (\ a -...
08:18:10 <Saizan> vixey: instance Context Tree a => Ord a where
08:18:19 <Saizan> vixey: that's quite scary :)
08:18:24 <ski> drguildo : yes .. you could use `(++)' .. but not until you get a grab of some result lists .. as of yet you only have lists of actions, not results
08:18:29 <Heffalump> Either Linux (x86) or Linux (x86_64) depending on your system
08:18:39 <oldsalt> i downloaded the binary tarball but i am unsure what to do then
08:18:39 <Vq^> drguildo: you want to evaluate both x and (sequence' xs) and then combine their results
08:19:26 <Vq^> maybe evaluate is a bad word :/
08:19:39 <ski> perform
08:19:39 <ski> execute
08:19:39 <ski> run
08:20:09 <drguildo> i'm just trying random stuff
08:20:18 <drguildo> i don't really understand anything about what's going on
08:20:25 <drguildo> maybe i'm not cut out for haskell
08:20:33 <saadahmad> Oooh, the errors finally make sense, thanks guys for the help :)
08:20:34 <drguildo> i seem to be 100% confused 100% of the time
08:20:39 <Vq^> drguildo: this is always tricky in the beginning
08:20:46 <hpaste>  Saizan annotated "Kind Error help" with "another solution, with fundeps" at http://hpaste.org/8728#a5
08:20:58 <ski> intuitively, what's the first thing you want to do if you've got the first action of the list, and the rest of the actions ?
08:21:09 <Vq^> drguildo: most of us has been where you are :)
08:21:18 <Giblaz> i'm currently learning haskell by doing the Scheme compiler tutorial
08:21:26 <Giblaz> and I was wondering what a Monadic Bind is
08:21:37 * ski smiles
08:21:40 <Vq^> :)
08:21:46 <saadahmad> Saizan, sorry for being not so experienced, but what is a FunDep?
08:21:53 <drguildo> store the result somewhere i can access later so that when i have the rest of them i can create a list out of them
08:22:01 <ski> saadahmad : no need to be sorry
08:22:01 <Vq^> Giblaz: you're in luck, thats todays topic
08:22:06 <drguildo> and return it
08:22:07 <Giblaz> XD
08:22:23 <Giblaz> hehe, i guess i am in luck
08:22:32 <drguildo> intuitively
08:22:33 <ski> drguildo : store *which* result ?
08:22:41 <drguildo> but that's because i'm so used to stateful programming
08:22:54 <drguildo> the result of performing the first action
08:22:54 <ski> drguildo : you're not off the track, here
08:22:54 <Giblaz> my friend has been bugging me to learn haskell for a while so I decided to finally try to pick it up
08:22:58 <Vq^> Giblaz: it binds/sequences two monadic actions/values
08:23:02 <sclv_> saadahmad: a fundep is a "functional dependency"
08:23:02 <ski> drguildo : right !
08:23:15 <ski> drguildo : how do you get a hold of the result of the first action ?
08:23:17 <sclv_> its the | s -> e part
08:23:23 <Saizan> saadahmad: it's short for functional dependency, a ghc extension, the part "| s -> e" means that for every 's' instance of Set s e, there will be only one 'e', i.e. that you can deduce 'e' by only knowing 's'
08:24:06 <Vq^> drguildo: have you seen any simple examples using >>= ?
08:24:13 <Giblaz> Vq^, what is meant by binding and sequencing
08:24:13 <saadahmad> Thank you again :)
08:24:22 <vixey> @slc modify
08:24:22 <lambdabot> Source not found. Maybe if you used more than just two fingers...
08:24:29 <drguildo> ski, well if the action doesn't need arguments, or has them already by currying i suppose bind
08:24:32 <Heffalump> oldsalt: unpack it, run ./configure --prefix=... and then make install
08:24:38 <drguildo> Vq^, yeah
08:24:39 <Saizan> saadahmad: the 'e' parameter is intended to be the type of elements of the set, this time (s :: *)
08:24:42 <ski> drguildo : yes .. go on
08:25:06 <oldsalt> Heffalump, it fails :-(
08:25:08 <saadahmad> I think understand :)
08:25:23 <drguildo> ski, then you have the result on the right side of bind?
08:25:26 <Vq^> Giblaz: depends a bit on the monad in question
08:25:38 <mar77a> can someone give me a few guidelines on how to read binary data
08:25:40 <Heffalump> oldsalt: configure does? In the same way?
08:25:43 <Vq^> Giblaz: monads are quite generic
08:25:45 <mar77a> from a file or a socket
08:25:51 <oldsalt> yes, configure fails
08:25:53 <Giblaz> yeah, i have begun to realize that :)
08:25:57 <Heffalump> ok, then I think you need to upgrade something. libc, perhaps.
08:25:57 <Vq^> Giblaz: in the IO monad bind sequences IO actions
08:26:00 <ski> Giblaz : "bind" is used to combine an action (a "sequence of statements with side-effects") with another action into a larger action .. also making sure you can use the result of the first action in the second one
08:26:05 <Heffalump> which Debian release is this?
08:26:11 <Vq^> Giblaz: in the list monad bind performs a cartesian product
08:26:15 <ski> drguildo : something like that, yes
08:26:20 <ski> you have currently
08:26:36 <ski>   sequence' (x:xs) = x >>= \r -> ...
08:26:40 <ski> drguildo : is that right ?
08:26:49 <Giblaz> ah, so its important to check the documentation when doing a Monadic Bind
08:27:00 <drguildo> sequence' (x:xs) = x >>= \y -> y : sequence' xs
08:27:02 <Giblaz> theres really no general action it performs I guess
08:27:03 <oldsalt> dont know *looks ashamed*
08:27:08 <Vq^> Giblaz: depends on what you are doing
08:27:19 <Heffalump> oldsalt: cat /etc/debian_version
08:27:23 <drguildo> it errors out though
08:27:31 <Vq^> Giblaz: some functions/concepts are general enough to do without knowing exactly what bind does
08:27:33 <oldsalt> 4.0
08:27:41 <Vq^> Giblaz: thake the function drguildo is writing for instance
08:27:45 <ski> Giblaz : for different monads "bind" does different things .. but they're all supposed to be "conceptually the same thing" .. sortof like membership tests for various different kinds of collections
08:28:03 <Giblaz> alright
08:28:04 <ski> drguildo : you're not far away
08:28:14 <ski> drguildo : consider what you know now
08:28:18 <ski>   x :: IO a
08:28:20 <ski>   y :: ?
08:28:28 <ski> what is the type of `y' ?
08:28:34 <Heffalump> oldsalt: ok, I've got that too. Will try it myself in a bit (5 mins or so)
08:28:35 <drguildo> a
08:28:37 <ski> yes
08:28:40 <ski> also you have
08:28:45 <ski>   xs :: [IO a]
08:28:50 <ski>   sequence' xs :: ?
08:28:51 <Giblaz> its almost like an interface of sorts (i'm trying to relate it to something i understand), but more general than that
08:29:06 <Vq^> Giblaz: thats a good way to think of it
08:29:07 <ski> drguildo : what should the second `?' there be ?
08:29:07 <drguildo> IO [a]
08:29:09 <ski> yes
08:29:14 <ski> *another* action
08:29:21 <araujo> drguildo, what tutorial are you reading for monads?
08:29:27 <ski> what do we do with actions, eh ? eh ?
08:29:34 <Giblaz> alright then that makes a lot more sense then
08:29:37 <oldsalt> Heffalump, dont ask me what i did but configure now works for the sources
08:29:46 <drguildo> araujo, i have looked at a *lot* of them to varying degrees
08:29:50 <Giblaz> so the monadic binds job is usually to do what
08:29:59 <Giblaz> generally speaking
08:30:08 <ski> Giblaz : "sequencing"
08:30:08 <Vq^> Giblaz: as i said it depends on the monad
08:30:11 <araujo> drguildo, check the monad as containers .. is a nice one
08:30:12 <Giblaz> ah yes
08:30:21 <Giblaz> alright
08:30:23 <Vq^> Giblaz: for state monads it binds together the functions that alters the state
08:30:38 <drguildo> ski, erm
08:30:49 <Vq^> Giblaz: it enforces a order of evaluation there, like in the IO monad
08:31:14 <drguildo> ski, i'm lost
08:31:23 <ski> drguildo : you've got one result `y' (the first result), and you've got one action that *when*performed* will give you the rest of the results
08:31:35 <andersca> hey ski
08:31:36 <ski> currently, you've only *performed* the first action
08:31:46 <Vq^> Giblaz: it can also be used to handle exception like behaviours (canceling the right hand value of bind for certain events)
08:31:50 <ski> you still have the rest of the actions to perform
08:31:51 <drguildo> what action will give me the rest of the results??
08:32:11 <ski> you have baked the rest of the actions together into *one* action, by using "sequence'"
08:32:19 <ski> but you still have to *perform* that large action
08:32:28 <drguildo> i don't understand
08:32:31 <ski> drguildo : sequence' xs
08:32:42 <ski>   xs :: [IO a]   -- this is the list of actions
08:32:49 <drguildo> oh
08:32:53 <Giblaz> Vq^: i think i'm understanding it a bit better, and let me ask you if this is a correct assumpting about the a state monadic bind - a state monadic bind when used between two functions will pass the results between them
08:33:00 <ski>   sequence' xs :: IO [a]   -- this is the action giving the list of results
08:33:00 <Giblaz> *assumption
08:33:16 <ski> andersca : hej p dig !
08:33:18 <Giblaz> or at least, from one to the other
08:33:21 <ski> esap : good evening
08:33:29 <Vq^> Giblaz: well, it flows from the first to the second
08:33:34 <Giblaz> yes
08:33:39 <Giblaz> i'm sorry
08:33:43 <Giblaz> i should have specified direction
08:33:43 <Vq^> :t (>>=)
08:33:44 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
08:33:46 <drguildo> i need to concatenate my result
08:33:50 <drguildo> with the list with all the other results
08:33:57 <Giblaz> that makes a bit more sense
08:33:59 <ski> yes
08:34:03 <Giblaz> at least for state monads
08:34:08 <esap> ski: good evening
08:34:12 <drguildo> but sequence' [a] is IO [a]
08:34:13 <Giblaz> i guess i'll have to hit the documentation for the other monads
08:34:18 <ski> drguildo : but first you need to *get*a*hold* of that list of the other results !
08:34:19 <Vq^> Giblaz: state monads are an interesting examples
08:34:23 <drguildo> so can i do that?
08:34:28 <drguildo> can i do a : IO [a]
08:34:31 <Giblaz> yeah, they seem very cool
08:34:35 <Giblaz> i've been reading a lot about them
08:34:39 <Vq^> Giblaz: there the bind operator is very similar to the ; in C or Java
08:34:39 <ski> drguildo : yes .. you've got an action .. how do you get a hold of its results ?
08:34:55 <Giblaz> the end of line?
08:35:08 <ski> (drguildo : i've asked that same question before :)
08:35:09 <Vq^> Giblaz: the separation of actions
08:35:12 <Giblaz> yeah
08:35:14 <Giblaz> hehe
08:35:32 <Giblaz> i just woke up
08:35:33 <drguildo> use bind
08:35:34 <drguildo> but
08:35:39 <ski> but ?
08:35:44 <Giblaz> so i'm not all there yet, i need my morning coffee
08:35:50 <EvilTerran> "{ foo; bar }" - "do foo's side effects, then do bar's side effects"
08:36:04 <EvilTerran> written like that in C, and (do foo; bar) in haskell :)
08:36:05 <drguildo> i'm confused ergh
08:36:13 <EvilTerran> or, as foo >> bar in haskell
08:36:14 <Vq^> EvilTerran: abomination :o)
08:36:22 <drguildo> how do i : a result with the result of a bind
08:36:24 <EvilTerran> Vq^, what?
08:36:41 <Saizan> any resources on performing reduction under lambda abstractions in a somewhat efficient way?
08:36:41 <Vq^> EvilTerran: can't say i like that ; syntax with haskell blocks
08:36:42 <drguildo> i don't even know how i would do that
08:36:48 <ski> drguildo : that is the next step .. first you need to get the rest of the results
08:36:59 <drguildo> i have them
08:37:02 <drguildo> sequence' xs
08:37:08 <ski> no
08:37:22 <ski> that's the *action* that *when*performed* will give you the results
08:37:28 <ski> you still haven't performed that action
08:37:33 <drguildo> ok
08:37:33 <EvilTerran> Vq^, i dunno, if i'm just linking a couple of actions in one line of code, i generally prefer to write (do ...; ...; ...) than (... >> ... >> ...)
08:37:53 <EvilTerran> and (do x <- ...; ...x...) is much nicer than (... >>= \x -> ...x...)
08:37:54 <Heffalump> oldsalt: errm, ok then :-)
08:37:56 <ski> you *have* performed the `x' action by doing `x >>= \y -> ...'  .. so `y' is the result of that `x' action
08:38:34 <Vq^> EvilTerran: i usually end up using some liftMx or ap then
08:38:44 <Vq^> EvilTerran: or wasting a few extra lines...
08:38:55 <oldsalt> Heffalump, but thanks anyway, i am no in the make-part  :-)
08:39:08 <vixey> @hoogle (u -> v) -> (u, x) -> (v, x)
08:39:10 <lambdabot> No matches, try a more general search
08:39:47 <drguildo> ski, i'm stuck
08:39:53 * ski wonders what wasps want with my room
08:39:56 <ski> drguildo : ok
08:39:59 <drguildo> i really don't have any idea what to do now
08:40:05 <Vq^> time to implement liftM2 instead :)
08:40:06 <drguildo> i need to concatenate the result
08:40:14 <drguildo> with the result of sequence' a
08:40:18 <drguildo> but i have no idea how to do it
08:40:19 <ski> drguildo : first recall .. what have you already done, in the second equation ?
08:40:45 <drguildo> which ones that?
08:40:46 <drguildo> return?
08:41:02 <ski> the one beginning with
08:41:08 <ski>   sequence' (x:xs) =
08:41:16 <drguildo> i performed an action
08:41:18 <ski> yes
08:41:19 <drguildo> then bound the result to y
08:41:23 <ski> which action ?
08:41:37 <drguildo> IO a?
08:41:44 <drguildo> the result was a
08:41:50 <ski> that's the *type* of the action, yes
08:41:58 <ski> the *action* itself was `x'
08:42:01 <ski> ok
08:42:15 <ski> so .. how did you go about performing the action ?
08:42:27 <ski> what did you have to write ?
08:42:31 <drguildo> by putting it on the left side of the bind
08:42:35 <ski> yes
08:42:36 <ski> ok
08:42:37 <drguildo> x >>=
08:42:45 <ski> so now you've got
08:42:57 <ski>   sequence' (x:xs) = x >>= \y -> ...
08:43:03 <ski> and you think you want to use
08:43:08 <ski>     sequence' xs
08:43:14 <ski> somewhere inside the `...'
08:43:20 <ski> ok ?
08:43:28 <drguildo> yes
08:43:34 <ski> what is the type of
08:43:37 <ski>   sequence' xs
08:43:38 <ski> ?
08:43:43 <drguildo> IO [a]
08:43:45 <ski> yes
08:43:53 <ski> what kind of value is
08:43:54 <ski>   sequence' xs
08:43:55 <ski> then ?
08:44:27 <ski> (hint, what was the type of `x' ? what kind of value/thing was `x' ?)
08:45:08 <drguildo> i don't understand what the difference between type and kind of value is
08:45:19 <drguildo> the type is the kind of value in my understanding
08:45:33 <ski> oh "kind of value" was just an informal expression
08:45:35 <ski> ok
08:45:40 <ski> (my bad)
08:45:48 <ski> so
08:45:51 <ski>   x :: IO a
08:45:55 <ski> (as you know, by now)
08:46:08 <ski> we then, informally say that `x' is an `IO'-action
08:46:11 <ski> right ?
08:46:27 <drguildo> is that why ghci uses an a?
08:46:34 <drguildo> as the type parameter
08:46:53 <ski> not really .. it just starts from the start of the ascii alphabet
08:46:55 <Vq^> the a is because it is general over all types
08:47:57 <Vq^> it's called a type-variable
08:47:58 <ski> `a' is a type variable .. that could be any type .. in your case, the type was `GroupEntry'
08:48:16 <ski> ok
08:48:28 <ski> so, `x' is an `IO'-action
08:48:36 <ski> what i wanted to hint to you was that
08:48:40 <ski>   sequence' xs
08:48:45 <ski> is also an `IO'-action
08:48:51 <drguildo> yeah
08:48:54 <drguildo> i want to perform it
08:48:57 <drguildo> and get a list back
08:49:03 <drguildo> so i can concatenate it with y
08:49:05 <ski> however, this one doesn't return a value of type `a' (as `x' does) .. it gives back a list of `a's
08:49:06 <drguildo> but i don't know how
08:49:08 <ski> yes
08:49:32 <ski> you perform this `IO'-action in the same way as you performed the previous `IO'-action, i.e. `x'
08:49:43 <ski> does that make sense ?
08:49:43 <drguildo> the way i think i should be able to doesn't work
08:49:52 <ski> let me reask :
08:50:02 <ski> how did you perform the `x' action ?
08:50:10 <drguildo> x >>=
08:50:12 <ski> yes
08:50:24 <ski> how can you perform the  sequence' xs  action ?
08:50:26 <drguildo> so i would do xs >>=
08:50:29 <drguildo> so it would be like
08:50:50 <drguildo> x >>= *xs* >>=
08:50:54 <esap> the action is "sequence' xs", not xs.
08:50:54 <drguildo> where * is some other stuff
08:50:56 <drguildo> i guess
08:51:10 <ski> (i'm sorry if i sound repetative, but i don't just want to give you the answer .. you will not understand it as well, then)
08:51:15 <drguildo> yeah, sorry
08:51:20 <drguildo> x >>= *sequence' xs* >>=
08:51:28 <drguildo> where * is some other stuff
08:51:34 <ski> yes, that is on the right track
08:51:46 <drguildo> so i also need the value from performing x
08:51:50 <drguildo> so that makes it
08:51:53 <ski> before you added a `\y ->' part to name the result of the first action into `y'
08:51:59 <drguildo> x >>= \y -> *sequence' xs* >>=
08:52:06 <ski> you also need to name the result of this second action
08:53:29 <drguildo> ok hmm
08:53:59 <ski> (just choose whatever name you fancy :)
08:54:10 <drguildo> now i came up with
08:54:11 <drguildo> sequence' (x:xs) = x >>= \y -> sequence' xs >>= \z -> (y : z)
08:54:20 <drguildo> but i get an error again
08:54:22 <ski> you're almost there now !
08:54:35 <ski> again, let's recall the types
08:54:41 <ski>   x :: IO a
08:54:49 <ski>   y :: a
08:54:52 <drguildo> because y : z is not a monadic type
08:54:55 <drguildo> so hmm
08:54:56 <ski>   xs :: [IO a]
08:55:04 <ski>   sequence' xs :: IO [a]
08:55:09 <ski>   z :: ?
08:55:18 <drguildo> [a]
08:55:21 <ski> yes
08:55:24 <ski> so
08:55:32 <ski>   (y : z) :: ?
08:55:43 <drguildo> i need to concatenate it with x and then "convert" it to IO a
08:55:48 <drguildo> [a]
08:55:49 <ski> exactly !
08:55:51 <ski> yes
08:56:03 <Vq^> with x?
08:56:11 <drguildo> erm
08:56:14 <drguildo> z
08:56:15 <ski> do you remember how to "convert" a plain value to a simple action just returning that value ?
08:56:26 <drguildo> return
08:56:29 <ski> yes
08:56:32 <ski> so
08:56:40 <ski>   return (y : z) :: ?
08:56:53 <drguildo> IO [a]?
08:56:58 <ski> yes
08:57:15 <ski> remember i said before that the catch with bind is that we always have to end with *another* action
08:57:26 <ski> this is why we need to use `return' here at the end
08:57:37 <ski> we have to make up an action to end with
08:57:54 <ski> do you see ?
08:58:27 <drguildo> yeah, that's what i understood that about >>= before
08:58:32 <ski> fine
08:58:38 <ski> so, what we've got now is
08:58:48 <drguildo> i have a question tho
08:58:50 <ski>   sequence' :: [IO a] -> IO [a]
08:58:57 <ski>   sequence' [    ] = return []
08:59:17 <ski>   sequence' (x:xs) = x >>= \y -> sequence' xs >>= \z -> return (y : z)
08:59:21 <ski> drguildo : yes ?
08:59:54 <monochrom> <3 haskell
09:00:02 <ski> monochrom :)
09:00:14 <drguildo> is z eventually going to be "return []"?
09:00:20 <drguildo> so IO []
09:00:25 <ski> not quite
09:00:29 <ski>   sequence' xs
09:00:38 <ski> is eventually going to be `return []'
09:00:49 <ski> let's take a simple example
09:00:54 <drguildo> ahh, of course!
09:01:00 <drguildo> but z will be it with the monad stripped
09:01:03 <drguildo> so just plain []
09:01:06 <drguildo> ?
09:01:08 <ski>     sequence' [foo,bar,baz]
09:01:09 <monochrom> The type of return [] is IO [you_need_something_here].  IO [] is not a type.
09:01:09 <Vq^> exactly
09:01:39 <ski>   = foo >>= x -> sequence' [bar,baz] >>= \z0 -> return (x : z0)
09:02:03 <monochrom> Alright, then z0 is a list, of type [something].
09:02:37 <ski>   = foo >>= \x -> (bar >>= \y -> sequence' [baz] >>= \z1 -> return (y : z1)) >>= \z0 -> return (x : z0)
09:03:10 <ski>   = foo >>= \x -> bar >>= \y -> sequence' [baz] >>= \z1 -> return (y : z1) >>= \z0 -> return (x : z0)
09:03:11 <monochrom> There are too many z's!
09:03:24 <ski>   = foo >>= \x -> bar >>= \y -> sequence' [baz] >>= \z0 -> return (x : y : z1)
09:03:52 <ski>   = foo >>= \x -> bar >>= \y -> (baz >>= \z -> sequence' [baz] >>= \z2 -> (z : z2)) >>= \z0 -> return (x : y : z1)
09:03:58 <ski>   = foo >>= \x -> bar >>= \y -> baz >>= \z -> sequence' [baz] >>= \z2 -> (z : z2) >>= \z0 -> return (x : y : z1)
09:03:58 <esap> ski: z0 != z1
09:04:15 <Axman6> ski: not sequence' []?
09:04:31 <Axman6> getting lost now :P
09:04:50 <ski> er, s/[baz]/[]' in the two last lines, also s/z1/z0/ in the three last lines  :(
09:05:07 <reubenf> if i have a data type "data T = A | B | C | D | E", if i want to generate each of its values do i have to do "[ x | x <- [A,B,C,D,E] ]" ?  i want to do something like "[ x | x <- T ]"
09:05:23 * SamB_XP looks at that and says "too many type-ofs"
09:05:36 <ski>   = foo >>= \x -> bar >>= \y -> baz >>= \z -> sequence [] >>= \z0 -> return (x : y : z : z0)
09:05:41 <ski>   = foo >>= \x -> bar >>= \y -> baz >>= \z -> return [] >>= \z0 -> return (x : y : z : z0)
09:05:50 <ski>   = foo >>= \x -> bar >>= \y -> baz >>= \z -> return (x : y : z : [])
09:05:56 <ski>   = foo >>= \x -> bar >>= \y -> baz >>= \z -> return [x,y,z]
09:06:04 <reubenf> SamB_XP: ?
09:06:05 <Axman6> reubenf: would deriving Enum help? (would that allow [A..E]?)
09:06:06 * ski is sorry for goof-ups
09:06:13 <Heffalump> Axman6: it would
09:06:15 <reubenf> yes, that would be great :)
09:06:23 * Axman6 wins
09:06:35 <SamB_XP> reubenf: I've been doing a lot of Coq lately, where : and :: are swapped relative to Haskell
09:06:35 <Axman6> i dominate at this haskell lark
09:06:44 <monochrom> haha
09:06:44 <Heffalump> it would also allow [toEnum 0..]
09:06:47 <ski> drguildo : maybe that last wasn't as much helpful as i wanted (using `do'-notaion instead of `(>>=)' would help here a bit)
09:06:48 <Heffalump> which is completely generic
09:06:48 <Axman6> t'was fun, but the final boss was too easy
09:06:55 <reubenf> heh
09:07:00 <reubenf> the final boss was a noob
09:07:05 <monochrom> haha
09:07:14 <SamB_XP> reubenf: and considering their relative importance in that setting, it's quite appropriate that this be the case
09:07:28 <Axman6> and with that, i'm going to sleep. g'night all
09:07:32 <ski> drguildo : anyway .. i hope you've managed to get a basic understunding of when to use bind ?
09:07:33 <monochrom> the final boss was a category theory noob
09:08:32 <esap> what about the initial boss? Is that dual of the final boss? :-)
09:08:47 <ski> of course, of course !
09:08:58 <Vq^> drguildo: it might be interesting to note that you have almost implemented liftM2 in that last row (the function that takes two monad actions and combines their results with a given function)
09:09:00 * esap wonders how to dualize bosses...
09:09:02 <Vq^> :t liftM2
09:09:03 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
09:09:54 <ski> drguildo : hm .. why were we wanting to define `sequence' ? .. oh yes .. you had used `map' and gotten a list of actions, and you wanted to get an action returning a list
09:09:54 <monochrom> the initial boss was a noob in coding pragmatics
09:10:57 <drguildo> the thing with haskell is
09:10:59 <drguildo> i find
09:11:09 <drguildo> everything i learn raises new questions
09:11:19 <ski> it's like starting to learn programming all over again !  (partially)
09:11:21 <drguildo> and then when i think i understand the answers to those question
09:11:24 <drguildo> later on it turns out i don't
09:11:33 <drguildo> i am hoping there will be a point where it clicks
09:11:46 <hpaste>  mar77a pasted "best way to get rid of desired file extensions?" at http://hpaste.org/8731
09:11:58 <drguildo> before when i learnt a "new" language there was a lot i could transfer from what i already know
09:12:09 <drguildo> but like you say, it is almost like starting all over again
09:12:18 <reubenf> apparently i don't know *how* to derive from enum, though, as i get "unexpected symbol 'Spades..'"  at line 8 http://codepad.org/yER1lHHy
09:12:20 <lambdabot> Title: Haskell code by Skeletor - 73 lines - codepad
09:12:33 <esap> drguildo: there will be. Probably the most difficult part is understanding new paradigms
09:12:39 <ziman> it's a whole new world with things you've never seen before :)
09:12:40 <drguildo> i'm sure there are even times when what i already know has been a disadvantage because i assumed things behaves in the way i am familiar with
09:12:46 <gwern> but do his proofs have the power of grey skull?
09:12:50 <ski> drguildo : this is because you've probably not learned another language in the functional programming paradigm before
09:12:59 <drguildo> ski, exactly
09:13:33 <ski> drguildo : yes .. definitely in some cases one has to unlearn stuff
09:13:51 <esap> drguildo: First it seems everything is different - then over time you start to integrate the old things with the new - and it'll improve your style even in the other languages
09:13:58 <plutonas> does indentation matter in haskell?
09:14:07 * gwern finds the nick 'ski' in the context of learning new FPs funny
09:14:08 <ski> plutonas : usually, yes
09:14:08 <Saizan> reubenf: put a space after Spades
09:14:14 <gwern> plutonas: if you want it to
09:14:16 <ski> gwern : how so ?
09:14:25 <drguildo> esap, i hope so
09:14:34 <dogbite> hi all.  i'm strugling to understand the output of random numbers.  can somebody tell me what i'm doing wrong?
09:14:37 <dogbite> map (\i -> (fst $ next (mkStdGen i)) `mod` 2) [1..10]
09:14:38 <reubenf> thanks Saiz
09:14:43 <gwern> ski: well, because of the SKI combinators
09:14:47 <dogbite> that outputs all 0s
09:14:53 <monochrom> When you find yourself in this onion-peeling experience, it is an indication that you are looking at Truth.
09:14:58 <drguildo> i am just hoping it is worth all the effort
09:15:03 <esap> drguildo: That's what happened to me when I learned Haskell.
09:15:06 <drguildo> i mean i am mainly doing it for fun
09:15:08 <reubenf> i have a feeling python programmers do ok learning haskell as their first functional language
09:15:18 <ski> gwern : well, if i may be so bold .. that may be because they are what originated my nick (*gasp* !)
09:15:30 <Saizan> :t next
09:15:31 <lambdabot> forall g. (RandomGen g) => g -> (Int, g)
09:15:35 <drguildo> but it's gone a bit beyond that
09:16:19 <SamB_XP> drguildo: you mean ... it's not fun anymore?
09:16:57 <monochrom> it's gone beyond fun.
09:17:11 <drguildo> not ultimately
09:17:30 <drguildo> but i mean it's got to the point where i will hammer on with things even though i'm getting frustrated
09:17:39 <ski> learning haskell is good for your brain (exploding your brain once in a while is good !, ohh yes)
09:17:48 <dogbite> i don't see why next is only creating even numbers
09:17:50 <SamB_XP> drguildo: like a video game?
09:18:01 <drguildo> but when i get my head around them it's a very good feeling
09:18:06 <drguildo> kinda
09:18:06 <monochrom> Oh you're addicted now! :)
09:18:18 <saadahmad> Is there a way to set options to be on each time I start up GHCI?
09:18:31 <gwern> saadahmad: sure. in one's .ghci
09:18:43 <drguildo> good analogy though because the difference is i'm hoping i will be able to use haskell at the end of all of this
09:18:47 <gwern> for example, mine as 'set +t +s -Wall -v -fforce-recomp -O2'`
09:18:50 <monochrom> Yes, enter stuff into file .ghci
09:18:50 <monochrom> See the GHC manual for details.
09:18:58 <drguildo> i.e. that i am comfortable enough with it to use it where i would use another language before
09:19:25 <ski> dogbite : that may be because you're having that "`mod` 2" part
09:19:28 <drguildo> because i like the ideas of no state, no side effects and strict typing
09:19:35 <ski> > map (`mod` 2) [0..]
09:19:38 <lambdabot>  [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1...
09:19:43 <gwern> > mod 3 2
09:19:45 <SamB_XP> drguildo: yes, I don't foresee using "The Wind Waker" in any job, true...
09:19:46 <lambdabot>  1
09:19:50 <gwern> > mod 2 3
09:19:50 <drguildo> with video games you put all the effort in and have nothing to show at the end of the day
09:19:51 <lambdabot>  2
09:20:01 <dogbite> ski: i don't get what you mean
09:20:03 <drguildo> you had fun, but there was nothing at the end of it
09:20:20 <Saizan> > find (==1) . map (\i -> fst (next (mkStdGen i)) ) $ [1..]
09:20:31 <lambdabot>  Exception: Time limit exceeded
09:20:34 <monochrom> Eh? There are now sponsored professional video gaming teams. They do it for a living.
09:20:43 <Saizan> > find (==1) . map (\i -> fst (next (mkStdGen i)) `mod` 2 ) $ [1..]
09:20:44 <lambdabot>  Just 1
09:21:15 <SamB_XP> monochrom: are there professional Zelda players?
09:21:27 <gwern> monochrom: by that argument, no sports is wasted time either. actually, one probably has a better chance of becoming a sports star than a videogame pro...
09:21:28 <dogbite> > map (\i -> (fst $ next (mkStdGen i)) `mod` 2) [1..30]
09:21:30 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
09:21:31 <monochrom> Not yet, but definitely FPS.
09:21:31 <drguildo> i'm not really just talking about money
09:21:43 <Saizan> > findIndex (==1) . map (\i -> fst (next (mkStdGen i)) `mod` 2 ) $ [1..]
09:21:43 <ski> dogbite : hm, i think i misread your problem
09:21:46 <lambdabot>  Just 53667
09:21:51 * monochrom aspires to be a Haskell sports star.
09:21:56 <drguildo> actually i'm not at all talking about money
09:22:01 <SamB_XP> I don't see how Zelda could be a professional sport
09:22:04 <dogbite> haha, that's pretty deep in the search
09:22:20 <reubenf> apparently you've never been to Korea
09:22:26 <drguildo> but something useful you can take away
09:22:31 <drguildo> having learnt something
09:22:33 <dogbite> Saizan: some result!
09:22:51 <ski> dogbite : possibly it is not very good to start with very small initial random seeds .. usually one uses time or something to initialize
09:22:51 <drguildo> i don't think i've ever learnt anything profound from playing a video game
09:22:54 <drguildo> fun as they are
09:23:19 <ski> drguildo : ok
09:23:32 <drguildo> probably because they don't warp your mind
09:23:40 <dogbite> ski: that doesn't make much sense to me
09:23:51 <drguildo> because it's quite uncomfortable
09:24:02 <esap> drguildo: nethack is an exception to that.
09:24:08 <saadahmad> I tried finding it in the manual, but I can't seem the find where .ghci is located :s
09:24:11 <drguildo> esap, really?
09:24:25 <drguildo> i play mangband quite a bit
09:24:30 <Saizan> ?type mkStdGen
09:24:31 <lambdabot> Int -> StdGen
09:24:44 <drguildo> i don't know how it compares
09:24:48 <esap> drguildo: well there are nice references to all kinds of things in nethack... [e.g. to P=NP]
09:26:05 <ski> dogbite : in that example above, you get trying initial random seeds between 1 and 30 .. represented as binary numbers (of some fixed bit length), most of the bits are zero .. i'm suggesting that such seeds doesn't necessarily give good pseudo-random-generators (at least to begin with)
09:26:08 <Baughn> esap: ..P=NP? Where?
09:26:10 <Saizan> dogbite: you usually compose applications of next to get more random numbers, rather than generating a new StdGen each time
09:26:33 <esap> Baughn: oracle
09:26:51 <Baughn> esap: I consider her mostly a source of food.
09:26:52 <dogbite> ski: oh, okay.  that make ssense.
09:27:18 <esap> baughn: heh
09:27:45 <ski> > unfoldr (Just . next) (mkStdGen 0)
09:27:49 <lambdabot>  [2147482884,2092764894,1390461064,715295839,79337801,347273588,1427314282,18...
09:28:04 <ski> > unfoldr (Just . next) (mkStdGen 0) `map` (`mod` 2)
09:28:05 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `[Int]'
09:28:26 <ski> @let pam = flip map
09:28:27 <lambdabot> <local>:5:11:     Ambiguous type variable `f' in the constraint:       `Funct...
09:28:30 <ski> > unfoldr (Just . next) (mkStdGen 0) `pam` (`mod` 2)
09:28:31 <lambdabot>   Not in scope: `pam'
09:28:35 <ski> arg
09:28:43 <ski> @let pam x y= flip map x y
09:28:44 <lambdabot> Defined.
09:28:46 <ski> ty
09:28:48 <ski> > unfoldr (Just . next) (mkStdGen 0) `pam` (`mod` 2)
09:28:50 <lambdabot>  [0,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,1,0,0,1,1,1,1,0,1,0,1,0,0,1,0,1,0,1,1,1,1,1...
09:28:51 <drguildo> lol
09:28:55 <ski> @botsnack
09:28:55 <lambdabot> :)
09:29:26 <ski> (DMR strikes again !)
09:29:54 <dogbite> ski: okay, i'l go back and tinker with my code... thank you
09:30:01 <ski> yw
09:30:17 <dogbite> Saizan: thanks to you too
09:31:41 <ski> Giblaz : did you have any questions about monadic bind ?
09:31:59 <drguildo> ski, do you know of any good tutorials on monads? and anything else haskelly
09:32:16 <drguildo> i bookmarked the one araujo recommended
09:33:17 <ski> you can try the ones located at <http://www.haskell.org/haskellwiki/Tutorials#Using_monads>
09:34:13 <drguildo> ok, thanks
09:35:23 <ski> drguildo : another tutorial that i happen to like is <http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/MONADS/Noel/research/monads.html>
09:35:24 <lambdabot> http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/MONADS/Noel/research/monads.html>
09:35:55 <drguildo> ahh, yeah
09:36:04 <drguildo> i have that one open in a browser tab :-)
09:36:11 <drguildo> i haven't looked at it properly yet though
09:36:13 <ski> (if'm not really sure how it compares to the other ones .. not having read many of them .. this is one that i did read when i was learning about monads)
09:37:44 * saadahmad is confused. Where do you put the .ghci file? :S
09:38:45 <EvilTerran> ~
09:39:22 <saadahmad> Huh?
09:39:27 <EvilTerran> Documents and Settings/you/ if you're on windows
09:39:32 <EvilTerran> ~ if you're on posix
09:40:51 <saadahmad> Ah, that helps. Thanks
09:44:16 <BONUS> is there a way to make the ghci prompt always show just ghci>
09:44:23 <BONUS> instead of showing all the modules and such
09:45:23 <SamB_XP> I think so...
09:45:33 <BONUS> i know you can do :set prompt "ghci> "
09:45:36 <BONUS> but you have to do it every time
09:45:44 <SamB_XP> put it in your .ghci
09:46:54 <BONUS> ah cool
09:46:56 <BONUS> works
09:55:41 <Trinithis> I just started reading about the Reader monad. Am I right in saying that it is exactly like the function monad (->e)?
09:55:48 <Heffalump> yes
09:55:57 <Trinithis> ok
09:56:01 <ski> (e ->)
09:56:02 <xerox> (e->)
09:56:06 <Trinithis> :D
09:56:08 <ski> xerox :)
09:56:09 <byorgey> @src Reader
09:56:10 <lambdabot> Source not found. My pet ferret can type better than you!
09:56:15 <xerox> hi ski (:
09:56:22 <ski> aka `(->) e'
09:56:22 <byorgey> yeah, Reader is just a newtype wrapper around (e ->)
09:56:25 <ski> hiya
09:56:40 <Trinithis> is it typically better? or when would you use one over the other?
09:57:01 <xerox> what is?
09:57:13 <Trinithis> reader newtype vs normal function
09:57:27 <ski> you'd use `Reader' when you don't need to "break the abstraction" many times .. i.e. relying on having functions, so that you can access the `e' environment
09:57:54 <Trinithis> ty
09:58:05 <ski> you'd use the plain function type constructor when you want to "break the abstraction" more often .. or when you're lazy :)
09:58:11 <Trinithis> lol
09:58:18 <Trinithis> lazy == haskellers
09:58:23 <Trinithis> bad pun i know
09:58:37 <Heffalump> or when you're writing obfuscated Haskell like join (+)
09:58:49 <ski> oh yes
09:58:52 <Trinithis> i love using join in that fashion
10:01:12 <ski> (the same way of thinking goes for `(,) w' vs. `Writer w' .. though the pair inside `Writer' is turned the wrong way around :/ ..)
10:01:46 <EvilTerran> the pair in State's the wrong way round too, isn't it?
10:01:54 <ski> @type Control.Monad.Writer.Writer
10:01:55 <lambdabot> forall a w. (a, w) -> Writer w a
10:02:00 <ski> @type Control.Monad.State.State
10:02:01 <lambdabot> forall s a. (s -> (a, s)) -> State s a
10:02:34 <ski> yes, in some sense .. though it doesn't matter so much here, since the corresponding non-abstract variant can't be expressed in haskell
10:02:57 <Trinithis> im guessing a reader composed with a writer yields state monad?
10:03:07 <ski> not quite
10:03:09 <SamB_XP> EvilTerran: wrong way round for what?
10:03:18 <SamB_XP> it's backwards from what I would expect
10:03:29 <Trinithis> what about writer with reader/
10:03:40 <ski> a reader together with a writer gets you one global unmodifiable "state", plus the ability to output (aka log) things
10:03:43 <SamB_XP> but I have never understood why I expect that ;-)
10:03:59 <SamB_XP> I guess I just like the least-varying things on the left???
10:04:06 <EvilTerran> because it'd make the tuple in State look like the tuple in (,)w
10:04:11 <ski> `Reader' is actually a misnomer, imho .. `Environment' would have been better naming
10:04:17 <EvilTerran> (and like the tuple in Writer should be)
10:04:23 <SamB_XP> ski: totally agread
10:04:30 <SamB_XP> except my spelling sux
10:04:42 <EvilTerran> it'd let you mesh different monads together more nicely
10:05:02 <ski>   instance Monoid w => Monad ((,) w)
10:05:04 <ski> is ok
10:05:06 <ski> that's basically
10:05:13 <ski>   instance Monoid w => Monad (\a -> (w,a))
10:05:16 <ski> however
10:05:19 <ski>   instance Monoid w => Monad (\a -> (a,w))
10:05:35 <ski> is now ok, since we can't express exactly that without using the (forbidden) type-lambda
10:05:36 <SamB_XP> but neither of those is allowed in Haskell
10:05:45 <ski> s/now/not/
10:05:53 <EvilTerran> i'm trying to remember now, there was something someone had involving reading from an IORef as an initial state and then writing it back to the IORef
10:05:55 <vixey> /\a -> (a,w)
10:05:59 <SamB_XP> because for some strange reason they forgot to make Haskell dependantly typed
10:06:06 <EvilTerran> which didn't quite work really elegantly because the tuple in Writer the wrong way round
10:06:17 <SamB_XP> (of course, then we'd have to merge the namespaces)
10:06:36 <EvilTerran> SamB_XP, would type lambdas alone be anough to call it "dependently typed"?
10:06:47 <ski> EvilTerran : no
10:06:49 <SamB_XP> EvilTerran: okay, not really
10:06:58 <vixey> If haskell was dependently typed you couldn't write anything in it
10:06:59 <EvilTerran> ... i guess that could depend on what kind system was
10:07:01 <SamB_XP> but I always forget the middle growned
10:07:02 <vixey> there would be no lambdabot
10:07:06 <vixey> no GHC ...
10:07:08 <vixey> etc..
10:07:10 <hpaste>  a-9 pasted "(no title)" at http://hpaste.org/8732
10:07:14 <SamB_XP> vixey: why say that?
10:07:15 <EvilTerran> vixey, why?
10:07:29 <vixey> by evidence,
10:07:30 <SamB_XP> see, I told you we needed a forallbot
10:07:31 <vixey>  what real programs have been written in dependently typed languages?
10:07:36 <vixey> about .. one or something
10:08:06 <SamB_XP> (since pibot is already taken by a moron...)
10:08:21 <ski> (also .. i'd prefer `Writer' being `Output' .. since that's what it's called in a lot of papers .. however, i suppose `Writer' is not as bad)
10:08:43 <SamB_XP> ski: I think Output would probably be more clear too, actually
10:08:51 <EvilTerran> i'd be inclined to call it something like Trace
10:09:11 * ski wonders who came up with these sub-optimal names ..
10:09:12 <EvilTerran> "the Logger monad", i dunno
10:09:48 <gwern> SamB_XP: does pibot taste better than DrPpprBot?
10:09:50 <ski> EvilTerran : that could work too .. though it makes me think of trace in linear algebra and compact closed categories (iirc)
10:10:05 <EvilTerran> whee
10:10:45 <ski> trace : (U (*) W >-> V (*) W)  >->  (U >-> V)
10:10:51 <ski> @type Control.Arrow.loop
10:10:52 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowLoop a) => a (b, d) (c, d) -> a b c
10:11:24 <SamB> EvilTerran: Logger monad is just about exactly right
10:12:05 <SamB> considering what I used it for the one time I'm certain I actually used it
10:12:11 <ski> imo `Reader' would be better reserved for parsing monads
10:12:36 <ski> considering how parsing and outputting/logging are the two main modes of DCG in Prolog
10:12:52 <Trinithis> when pattern matching against a tuple, can it always be lazily matched? aka ~(a, b, c)
10:13:02 <SamB> Trinithis: hmm?
10:13:14 <Trinithis> sec
10:13:20 <ski> > (\ ~(a,b,c) -> ()) undefined
10:13:22 <lambdabot>  ()
10:13:23 <EvilTerran> Trinithis, if you're matching against anything with one constructor, yes
10:13:26 <ski> > (\ (a,b,c) -> ()) undefined
10:13:26 <SamB> Trinithis: you match lazilly only if you want to survive matching against _|_, basically
10:13:28 <lambdabot>  Exception: Prelude.undefined
10:13:28 <EvilTerran> altho it will make your code lazier
10:13:32 <SamB> there are performance implications
10:13:33 <Trinithis> ok
10:13:50 <EvilTerran> yeah, you may end up evaluating loads of the body unnecessarily before th eerror as a result
10:13:54 <dmwit> Trinithis: Only if you are not recursively matching.
10:14:10 <dmwit> Trinithis: i.e. (x:xs, y, z) is matching against a tuple, but cannot be safely lazified.
10:14:27 <Trinithis> mm
10:14:49 <SamB> dmwit: well, yes, but the x:xs match would force the whole thing even if you split the case
10:15:16 <SamB> you know, into single-level cases
10:15:20 <vixey> ~> elimTup3 (\xxs y z -> elimList (\x xs -> ...))
10:15:37 <dmwit> SamB: I'm not sure I understand you.
10:15:41 <ski> s/List/Cons/
10:16:09 <vixey> oh
10:16:27 <vixey> ~> elimTup3 (\xxs y z -> elimList (\x xs -> ...) ( {- case for xxs = [] -} ))
10:17:06 <Trinithis> gtg. thanks for the info
10:17:10 <SamB> dmwit: you know how just about every Haskell compiler decomposes multi-level cases into nested single-level cases?
10:17:13 <dmwit> vixey: elimList sounds suspiciously like foldr. ;-)
10:17:39 <dmwit> SamB: I didn't know that, but I can imagine how it would work.  Go on.
10:18:06 <BONUS> does anyone know when real world haskell is coming out
10:18:15 <dmwit> By Christmas.
10:18:25 <BONUS> hmm
10:18:26 <SamB> well, if you do that transformation on the code you speak of, you can safely add a ~ to the tuple part
10:18:36 <SamB> but it won't do anything for you
10:18:58 <SamB> because the next case expression will force the thing anyway
10:19:05 <dmwit> > let f ~(x:xs, y, z) = y in f ([], 1, 1)
10:19:07 <lambdabot>   Irrefutable pattern failed for pattern (x : xs, y, z)
10:19:17 <dmwit> interesting
10:19:28 <BONUS> has anyone read The Haskell Road to Logic, Maths and Programming
10:19:28 <SamB> note:
10:19:42 <dmwit> > let f ~(~(x:xs), y, z) = y in f ([], 1, 1)
10:19:44 <lambdabot>  1
10:19:58 <dmwit> SamB: Okay, point taken.  Thanks!
10:20:03 <SamB> I was not actually saying that the compiler's doing that here was at all relevant
10:20:29 <SamB> just using that as a way to refer to the transformation
10:20:45 <dmwit> BONUS: But you can read the beta version of RWH right now, if you want.
10:20:52 <ski> @src (->) Control.Arrow.loop
10:20:53 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
10:20:57 <BONUS> yeah i know :)
10:20:58 <ski> bah!an
10:21:10 <SamB> dmwit: but I bet it isn't readily available on paper?
10:21:17 <BONUS> but it will be nice to have a nice solid copy to put on a shelf
10:21:26 <BONUS> and read through
10:21:33 <dmwit> Right, the trees are still alive for a little longer.
10:21:47 <SamB> besides who would want to waste the money to print a beta version of a book?
10:21:54 <SamB> even if they could get it printed someplace
10:22:04 <BONUS> will it be available online once it's published?
10:22:06 <SamB> (is it even available in beta PDF?)
10:25:12 <kaspyanand> hi
10:25:14 <sheik_> helloooo ^.^
10:25:20 <kaspyanand> i need help
10:25:26 <kaspyanand> i am unable to use ghc
10:25:35 <kaspyanand> i am getting error
10:25:38 <BONUS> what kind of error
10:26:11 <kaspyanand> <interactive>:1:0: Not in scope: `ghc'
10:26:20 <sheik_> kaspyanand: run ghci
10:26:21 <kaspyanand> i am using windows xp
10:26:28 <dmwit> kaspyanand: ghci is an interpreter; ghc is a compiler.
10:26:31 <kaspyanand> yes i have run that
10:26:37 <BONUS> which command do you run
10:26:37 <dmwit> kaspyanand: You typically do not invoke one from the other.
10:26:39 <BONUS> on what file
10:26:41 <dmwit> (They are separate.)
10:26:46 <kaspyanand> oh ok
10:26:59 <kaspyanand> so i just use ghc from command prompt and not from ghci
10:27:06 <BONUS> yeah
10:27:37 <kaspyanand> :)
10:27:39 <kaspyanand> thks man
10:27:42 <sheik_> can anyone help me get a haskell setup for emacs
10:27:45 <kaspyanand> got it
10:27:56 <kaspyanand> just compiled my first haskell prog
10:28:02 <sheik_> kaspyanand: congrats
10:28:15 <kaspyanand> thks
10:28:20 <dmwit> sheik_: Have a look at the wiki, I think there's a page there on emacs.
10:28:23 <sclv_> @hoogle haskell-mode
10:28:23 <lambdabot> Hoogle Error: Parse Error: Unexpected character '-mode'
10:28:29 <sclv_> @google haskell-mode
10:28:30 <lambdabot> http://www.haskell.org/haskell-mode/
10:28:30 <lambdabot> Title: Haskell Mode for Emacs
10:28:36 <sheik_> dmwit, sclv_ : thanks
10:28:48 <dmwit> sheik_: http://www.haskell.org/haskellwiki/Libraries_and_tools/Program_development#Emacs
10:28:49 <lambdabot> Title: Applications and libraries/Program development - HaskellWiki, http://tinyurl.com/rolrs
10:30:42 <kaspyanand> has anyone used memcache with haskell?
10:31:17 <dmwit> Check hackage.  If there's nothing there, it either hasn't been done, or gwern hasn't seen it yet. =P
10:32:43 <dmwit> kaspyanand: Are you writing (or planning to write) a web site in Haskell?
10:33:14 <kaspyanand> no just starting to explore functional programming using haskell and scheme
10:33:31 <BONUS> that reminds me
10:33:36 <BONUS> has anyone made something like WSGI
10:33:39 <BONUS> only for Haskell
10:33:42 <BONUS> seems like a nice match
10:34:11 <kaspyanand> dmwit:we are writing this application which is going to use memcache and do computation
10:34:29 <kaspyanand> n ussing c#
10:34:35 <vixey> What's the best typechecker for STLC in haskell?
10:34:57 <kaspyanand> dmwit:but i wa swondering how haskell could be better at such applications
10:39:25 <vixey> I don't know how to write a typechecker in haskell
10:39:38 <vixey> it seems to take huge amounts of code and be very low level
10:40:01 <dmwit> ?go stlc
10:40:02 <lambdabot> No Result Found.
10:40:36 <dmwit> http://en.wikipedia.org/wiki/Software_testing ?
10:40:37 <lambdabot> Title: Software testing - Wikipedia, the free encyclopedia
10:41:12 <kaspyanand> i am starting out learning haskell using http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/firststeps.html
10:41:13 <lambdabot> Title: Write Yourself a Scheme in 48 hours, http://tinyurl.com/uto4h
10:41:40 <Saizan> vixey: compared to the three lines of prolog i agree, but once you've unification it's very short again
10:41:50 <oklopol> kaspyanand: see you in 48 hours then
10:41:53 <oklopol> !
10:42:29 <vixey> but if I unify x and y, that doesn't affect "t" which I previously inferred
10:43:44 <Riastradh> Urgh.  Please be sure to perform a mental substitution of `not-Scheme' for `Scheme', and of `poor practice' for `good Haskell code', if you read that, kaspyanand.
10:44:07 <kaspyanand> oklopol:hey i am sure it will take more time than that!
10:44:51 <kaspyanand> riastradh:sorry do not understand ur point
10:45:18 <Saizan> vixey: if you represent the unificating substitution you're building up as a Map TyVar Type you can ask for the "normalized" value of some tyvar after you've considered all the equations
10:46:57 <Cale> ski: what?
10:47:10 <kaspyanand> how did you guys learn haskell?
10:47:19 <sheik_> agh... what's the proper way to set the location of 'inf-haskell binary?
10:47:28 <BONUS> i just read a bunch of tutorials
10:47:39 <BONUS> caues each one is different and focuses on different stuff
10:47:48 <BONUS> so you then you piece it together
10:47:50 <BONUS> :]
10:47:59 <Cale> kaspyanand: By reading online tutorials and using it for small combinatorial search things for a while, and then getting hired to write some, reading lots of research papers...
10:48:08 <dmwit> kaspyanand: I read the Gentle Introduction to Haskell.
10:48:10 <BONUS> also doing project euler
10:48:11 <dmwit> kaspyanand: It's very good!
10:48:22 <kaspyanand> anyone read http://book.realworldhaskell.org/beta/
10:48:24 <lambdabot> Title: Real World Haskell
10:48:25 <BONUS> after i learned it i found the real world haskell book
10:48:26 <Cale> kaspyanand: Asking questions in here also helps a lot :)
10:48:34 <dmwit> kaspyanand: Then I used it until I saw warts, and figured by then I pretty much knew the language. =)
10:48:35 <BONUS> yeah real world haskell looks great for learning it the first time off
10:48:36 <kaspyanand> cale:yes for sure
10:48:40 <ziman> what's the difference between Monoid and MonadPlus? when should i use which one?
10:48:52 <ski> Cale : hm .. ?
10:48:56 * ski tries to recall
10:49:22 <ziman> oh, a MonadPlus is a Monad
10:49:25 <dmwit> ziman: Monoid is more general than MonadPlus.
10:49:29 <dmwit> ziman: right
10:49:33 <ddarius> ziman: They instances of different kinds, it will always be obvious which to use.
10:49:46 <Cale> ziman: That's an interesting question, but yeah. MonadPlus is for when you have a monoid operation that agrees with the monad structure in some nice way.
10:49:48 <ski> Cale : oh, right .. i was just idly complaining to you about `@type map' when i was explaining something :) .. nothing special to care about
10:49:55 <Cale> ski: ah, okay
10:50:00 <vixey> Saizan: so it should really come out as a few pages ? I'm not just doing it in a roundabout way?aeou
10:50:24 <Cale> Unfortunately there are at least two major things which MonadPlus is used to mean, and the class really should be split in two.
10:51:19 <dmwit> Cale: What, split up mzero and mplus?  Or a different kind of split?
10:51:25 <Cale> http://www.haskell.org/haskellwiki/MonadPlus
10:51:26 <lambdabot> Title: MonadPlus - HaskellWiki
10:51:32 <Cale> dmwit: Well, that too
10:51:38 <ddarius> Stop representing unifications as substitutions.
10:51:43 <Cale> dmwit: But I'm talking about MonadPlus/MonadOrElse
10:51:57 <vixey> ddarius: I wish I knew a better way ...
10:52:06 <Cale> http://www.haskell.org/haskellwiki/MonadPlus_reform_proposal
10:52:06 <ddarius> Use mutable variables.
10:52:07 <lambdabot> Title: MonadPlus reform proposal - HaskellWiki
10:52:14 <ddarius> Preferably STRefs
10:52:15 <vixey> well I tried to do typed logic variables but I couldn't get it to work
10:52:31 <vixey> maybe I'll try again
10:52:45 <ddarius> What didn't work?
10:53:44 <ski> kaspyanand : i believe messiers Riastradh was alluding to the fact that that tutorial doesn't really implement a `Scheme' as defined by any of the `RnRS' pseudo-standard documents (nor the ISO-standard)
10:55:03 <vixey> I couldn't build the monad transformer stack I wanted
10:55:11 <vixey> too much confusion with foralls
10:55:45 <ski> vixey : did you see the papers by seres, spivey, claessen ?
10:56:02 <vixey> yes
10:56:09 <ddarius> vixey: You shouldn't need any foralls until the end.
10:56:20 <vixey> I was trying to use LogicT as well
10:56:27 <vixey> with ST IO
10:56:31 <vixey> it was a huge mess
10:57:19 <dmwit> ST IO?
10:58:23 <ddarius> vixey: I wrote an entire Prolog interpreter using typed logic vars albeit I used Hinze's BacktrT because LogicT wouldn't have been written for a couple of years.
10:58:56 <ski> ddarius : `BacktrT' being the one with two explicit continuation ?
10:59:02 <ski> s//s/
10:59:12 <ddarius> ski: Yes.  Unless I'm misremembering.
10:59:47 <ddarius> I think I used a different one to start and swapped in Hinze's later.  Really which I used is/was more or less irrelevant.
11:00:35 * ski used the two-continuation variant too .. and then changed it to omega-continuation variant
11:03:01 <dmwit> > 0 :: Double
11:03:03 <lambdabot>  0.0
11:03:08 <dmwit> Interesting...
11:03:13 <reubenf> as i understand, if i have f :: A -> (B -> C) then "f a" is of type B -> C.  is there a way for me to also get a function A -> C (like "f b" ?)
11:03:32 <byorgey> flip f b
11:03:40 <vixey> ok
11:03:42 <ski> f `flip` b
11:03:49 <byorgey> or \a -> f a b
11:04:09 <ddarius> ski: Why would you write that infix?
11:04:22 <vixey> f $ a, f `flip` b
11:04:22 <dmwit> `flip` takes the place of the first argument.
11:04:24 <gbacon> in general, how do I convert values between instances of, say, Real or RealFrac
11:04:26 <dmwit> It's interesting.
11:04:28 <geezusfreeek> i kind of like it. it makes the flip look like a placeholder
11:04:34 <dmwit> yeah
11:04:45 <ddarius> flip doesn't read like a placeholder.
11:04:45 <vixey> :t realToFrac :: Real -> RealFrac
11:04:46 <lambdabot>     Class `Real' used as a type
11:04:46 <lambdabot>     In the type `Real'
11:04:46 <lambdabot>     In the type `Real -> RealFrac'
11:04:50 <dmwit> ?src RealFrac
11:04:50 <lambdabot> class  (Real a, Fractional a) => RealFrac a  where
11:04:50 <lambdabot>     properFraction                   :: (Integral b) => a -> (b,a)
11:04:50 <lambdabot>     truncate, round, ceiling, floor  :: (Integral b) => a -> b
11:04:53 <ddarius> If you want to do that give it an appropriate name
11:04:53 <vixey> :t realToFrac :: Real a => a -> RealFrac
11:04:54 <lambdabot>     Class `RealFrac' used as a type
11:04:54 <lambdabot>     In the type `RealFrac'
11:04:54 <lambdabot>     In the type `a -> RealFrac'
11:05:00 <geezusfreeek> it does if you adopt it as a personal idiom
11:05:06 <byorgey> let blank = flip  in f `blank` b
11:05:08 <vixey> :t realToFrac
11:05:09 <lambdabot> forall a b. (Fractional b, Real a) => a -> b
11:05:17 <byorgey> dmwit: what's interesting about 0.0?
11:05:18 <gbacon> I have a POSIXTime that I want to convert to CDouble
11:05:28 <ski> ddarius : with larger expressions, it can reduce the number of parens .. which can sometimes make it slightly more readable
11:05:44 <dmwit> byorgey: show (0 :: Int) /= show (0 :: Double).  I'm just following along with http://augustss.blogspot.com/2008/07/lost-and-found-if-i-write-108-in.html
11:05:45 <lambdabot> Title: Things that amuse me, http://tinyurl.com/57eqc2
11:05:50 <vixey> let () = flip
11:05:55 <vixey> f  b
11:06:14 <dmwit> gbacon: Use Data.Time instead of System.Time, if you can.
11:06:19 <byorgey> dmwit: ah. I just skimmed that so I probably missed some of the finer details...
11:06:25 <gbacon> dmwit, vixey: thanks
11:07:22 <gbacon> dmwit: I am (viz. parseTime, which is giving me a UTCTime)
11:07:53 <dmwit> I think there's an instance Integral for UTCTime that gives things back in micro (milli?) seconds.
11:08:06 <byorgey> femto
11:08:13 <dmwit> yikes
11:08:17 <gbacon> :-)
11:08:19 <byorgey> kidding =)
11:09:31 * byorgey cooks some lambdabacon
11:09:41 <dmwit> In any case, I've never been stopped from doing things by Data.Time... but I've never found pretty ways of doing things with Data.Time.
11:09:52 <dmwit> So if it feels like you're pulling teeth, you might just be pulling teeth.
11:11:03 <gbacon> dmwit: no, UTCTime has instances of Eq, Ord, Read, Show, FormatTime, and ParseTime
11:11:26 <dmwit> hum
11:11:44 <gbacon> dmwit: so looks like I need to go UTCTime -> POSIXTime -> CDouble
11:11:47 <gbacon> :-/
11:13:08 <dmwit> I *know* there's a way to get the milliseconds as an Integer, I remember doing it.
11:13:49 <dmwit> Oh, via DiffTime.
11:21:19 <shapr> Can I use hxt to filter info out of an html page that does not follow the dtd? That is, with broken tags etc?
11:21:48 <Cale> shapr: I think maybe tagsoup is better at that.
11:21:54 <shapr> Ok, I'll look at that, thanks.
11:21:55 * byorgey <3 tagsoup
11:22:01 <ddarius> @tell augustss No ones = 1 : ones example?
11:22:01 <lambdabot> Consider it noted.
11:22:40 <Cale> shapr: But obviously gives a little less structure to examime, since it basically treats the document as a stream of opening and closing tags.
11:30:46 <sjanssen> gwern: so you fixed the import thing in mueval?
11:32:46 <gwern> sjanssen: yup
11:32:57 <gwern> or rather, the Hint guy fixed his library more belike
11:33:05 <Cale> gwern: Hint?
11:33:29 <gwern> sjanssen: so unless you know of any other security holes, I think it meets all the known challenges
11:33:33 <gwern> Cale: wrapper around GHC API
11:33:34 <sjanssen> gwern: neat
11:33:49 <sjanssen> gwern: I will fetch the latest version and see if I can find anything in the next few days :)
11:33:51 <dmwit> Does mubot frequent freenode?
11:34:43 <gwern> dmwit: alas, mubot is as of yet hypothetical. I decided mubot would be useless without a mueval, and since I only just this morning finished mueval...
11:34:58 * gwern is thinking of copping out and having preflex use mueval, which should resolve the big lambdabot stability issue. at least, I haven't seen preflex crash yet
11:35:15 <dmwit> Seems reasonable.
11:35:46 <gwern> oh yeah, I should tell mauke that mueval is more-or-less done
11:35:51 <gwern> @seen mauke
11:35:51 <lambdabot> mauke is in #xmonad and #haskell. I last heard mauke speak 11h 37m 43s ago.
11:36:18 <vixey> when is the next hoogle done?
11:36:55 <ddarius> vixey: The end of summer.
11:37:00 <gwern> @tell mauke so, you remember how I said it'd be cool if preflex could evaluate haskell code like lambdabot and how mueval could be a CLI-based way of doing so once it was done? well, mueval is done and on hackage. your thoughts?
11:37:00 <lambdabot> Consider it noted.
11:37:02 <Cale> gwern: I still need to take a closer look but I had a quick scan through the source code of mueval the other day...
11:37:39 <gwern> Cale: was there anything particularly unclear? I can do some refactoring
11:38:28 <Cale> gwern: In order to make it work just like lambdabot, we'd load L.hs, which is where definitions are kept, rather than a static list of modules.
11:38:58 <gwern> Cale: what is in L.hs?
11:39:13 <Cale> gwern: The stuff that people define with @let, plus some other stuff.
11:39:33 <gwern> strictly speaking, it wouldn't be terribly hard to load a file instead of a module
11:39:37 <Cale> like my little local definitions of (.) and (++), as well as all the imports (some of which are qualified)
11:39:41 <Cale> Right :)
11:39:49 <gwern> Cale: so as lambdabot operates, it is continuously appending to this l.hs?
11:39:59 <Cale> yeah, and recompiling it
11:40:11 <ziman> @pl \(x, y) (z, a) -> (x+z, y+a)
11:40:12 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (+))
11:40:23 <ziman> lovely :)
11:40:28 <gwern> hm. well, recompilation wouldn' be an issue, since you start mueval anew on every invocation
11:40:33 <vixey> would it be better to introduce the @let bindings with a series of mueval flags?
11:41:02 <gwern> vixey: how do you mean?
11:41:07 <scodil> is haddock fixed to work with 6.8.3 yet? I still have to use 6.8.2, whish is a pain.
11:41:17 <scodil> which is
11:42:06 <byte-> i think i'm going crazy
11:42:20 <gwern> byte-: the gods must be crazy
11:42:37 <byte-> I'm working with parsec
11:42:53 <byte-> and something that shouldn't be happening...is happening
11:43:07 <gwern> ah, the impossible happened?
11:43:12 <gwern> (a good lambdacat)
11:43:14 <byte-> parseTest (stringE <|> return (StringE "hi")) "{hi}"
11:43:14 <byte-> parse error at (line 1, column 2):
11:43:14 <byte-> unexpected "{"
11:43:14 <byte-> expecting "\\" or end of input
11:43:30 <byte-> how in the world is that getting past the second clause of <|>?
11:43:40 <gwern> Cale: actually, would it be possible to concat all of L.hs and append the IRC input to it?
11:43:48 <byte-> it shouldn't even matter what stringE is, right?
11:44:10 <byte-> parseTest (fail "bah" <|> ...) works as expected
11:44:14 <gwern> "mueval --expression "let (.) = madness; .....; in"++"+1""
11:44:20 <gwern> if you follow
11:44:36 <sjanssen> bad idea
11:44:44 <Cale> gwern: hmm...
11:44:48 <ddarius> byte-: parsec does not backtrack by default
11:44:51 <ziman> is there an elegant way to apply a tuple of functions onto a tuple of values to obtain a tuple of results?
11:45:02 <gwern> sjanssen: one bad let definition would contaminate all succeeding attempts?
11:45:03 <sjanssen> actually, the 'in' might make it safe
11:45:05 <byte-> ddarius: i don't follow
11:45:07 <ddarius> byte-: If stringE consumes anything, then the other alternative will not be tried.
11:45:07 <dmwit> byte-: Are you sure it's not "unexpected '}'"?
11:45:13 <oklopol> ziman: doubt it
11:45:21 <vixey> ziman: yes
11:45:22 <byte-> dmwit: yes
11:45:36 <byte-> ddarius: it won't?
11:45:37 <oklopol> i guess my doubt was unjust
11:45:38 <dmwit> ddarius: That doesn't really seem to apply, as it's not even consuming the first character here.
11:45:55 <byte-> ddarius: I thought <|> goes to the second argument if the first fails?
11:45:59 <dmwit> byte-: You better paste your code.
11:46:00 <byte-> ddarius: regardless of whether the first consumes anything?
11:46:05 <dmwit> byte-: Nope.
11:46:08 <ddarius> byte-: No, that's not how it works.
11:46:19 <byte-> ddarius: which is how what works?
11:46:23 <dmwit> byte-: It goes on to the second only if the first doesn't consume anything.
11:46:29 <ddarius> That's not how <|> works.
11:46:52 <dmwit> byte-: (i.e. if the first character of the input cannot be the first character of any successful parse of (<|>)'s first argument.)
11:46:53 <ddarius> byte-: If you write try stringE <|> ... then it will behave that way.
11:47:20 <Cale> gwern: Another thing I'm not certain about is how to do qualified/qualified as imports.
11:47:38 <Cale> gwern: although if we were using L.hs that wouldn't be a problem
11:48:07 <byte-> ok
11:48:16 <byte-> that seemed to work
11:48:40 <gwern> I suppose. although now I find myself wondering about what security holes L.hs could introduce if compiled/evaluated without security measures. allowing module imports could be very bad
11:48:46 <byte-> that explains a lot
11:48:48 <ddarius> You want to avoid try if possible though.
11:49:07 <byte-> i was pulling my hair out thinking about it
11:49:10 <gwern> import Foreign.Unsafe as FluffyBunnys; @let fluffyBunnys = FluffyBunnys.unsafePerformIO
11:49:32 <Cale> gwern: We don't let people add imports.
11:49:35 <gwern>  > fluffyBunnys $ readFile "/etc/passwd"...
11:49:48 <ddarius> @let data Foo = Bar | Baz
11:49:48 <lambdabot> Invalid declaration
11:49:58 <gwern> then why the need for qualified imports?
11:50:02 <vixey> why not allow data definitions?
11:50:16 <Cale> gwern: Because there are overlapping names in many modules.
11:50:49 <gwern> stupid small namespace :(
11:51:36 <vixey> (f) $ (x) = f x; (f,g) $$ (x,y) = (f x,g y); (f,g,h) $$$ (x,y,z) = (f x,g y,h z)
11:52:30 <ziman> nice
11:53:31 <vixey> :t (<$>) :: [a->b] -> [a] -> [b]
11:53:32 <lambdabot>     Couldn't match expected type `[a -> b]'
11:53:32 <lambdabot>            against inferred type `a1 -> b1'
11:53:32 <lambdabot>       Expected type: [a -> b] -> [a] -> [b]
11:53:51 <vixey> :t (zipWith ($)) :: [a->b] -> [a] -> [b]
11:53:52 <lambdabot> forall a b. [a -> b] -> [a] -> [b]
11:54:16 <byte-> is there an equivalent to <|> that works whether or not the first argument consumes anything?
11:54:31 <byte-> if I use 'try' I won't know what the first one consumed
11:54:34 <Cale> try x <|> y
11:54:45 <byte-> which is annoying when I'm trying to debug
11:54:49 <Cale> wha?
11:54:51 <vixey> if you use try either x succeds or it consumes nothing
11:55:00 <byte-> I can't figure out what the first one is consuming
11:55:05 <byte-> it should be failing on the first char
11:55:13 <jre2> how does mueval differ from lambdabot's sandboxing?
11:55:16 <Cale> You'll figure out what the first one is consuming if it succeeds.
11:55:27 <vixey> what are you parsing?
11:55:30 <byte-> it's failing and consuming
11:55:32 <byte-> that's the problem
11:55:35 <Cale> jre2: It's basically a repackaging of the sandboxing that lambdabot does, as a separate package.
11:55:46 <dmwit> byte-: I don't believe you, care to paste?
11:55:52 <joey_> If it's consuming, it's not failing to match
11:55:53 <Cale> jre2: gwern is on a quest to make lambdabot less monolithic
11:56:00 <jre2> Cale: no important distinctions then?
11:56:03 <ddarius> joey_: That's false.
11:56:04 <byte-> wait...wait
11:56:08 <OceanSpray> @index replace
11:56:09 <lambdabot> bzzt
11:56:11 <Cale> jre2: I'm not sure yet :)
11:56:11 <byte-> I think there's a terminology mismatch here
11:56:25 <byte-> when I say "consuming," I don't mean "at this exact moment"
11:56:26 <ddarius> joey_: char 'a' >> char 'b' will consume something in "ac" but fail to match
11:56:27 <byte-> I mean "has consumed"
11:56:32 <byte-> and then fails
11:56:40 <joey_> ddarius: Using try .. <|> .. will still comsume if it fails?
11:56:51 <byte-> no
11:56:53 <byte-> that's the problem
11:56:56 <ddarius> joey_: It depends on what the right alternative does.
11:56:58 <byte-> I want it to eat
11:57:03 <byte-> so I can figure out what the hell is going on
11:57:09 <ddarius> joey_: But try foo won't if foo fails regardless of what foo consumes.
11:57:15 <vixey> byte-: What language?
11:57:29 <byte-> vixey: haskell?
11:57:34 <joey_> ddarius: That was what I was saying.
11:57:46 <dmwit> byte-: No, what language are you parsing?
11:57:49 * gwern files another 2 evince bugs. evince does so much I don't like, but what other PDF viewer am I going to use really
11:57:50 <vixey> byte-: what are you parsing?
11:57:52 <byte-> heh
11:57:54 <byte-> that's what I figured
11:57:56 <joey_> ddarius: You seemed to have missed the context
11:57:56 <byte-> just wanted to be a smartass
11:58:06 <byte-> i'm parsing M-exprs
11:58:07 <byte-> for M
11:58:35 <byte-> neither of which you'll be familiar with, since AFAIK they're original
11:58:40 <ddarius> joey_: You said "try .. <|> .." will still consume if it fails.  I responded to that by saying only if the right alternative does.  try .. <|> .. is not try (.. <|> ..)
11:58:49 <byte-> hmm
11:58:59 <byte-> I think I still have the source code in the clipboard
11:59:00 <vixey> byte-: M-exprs go long back
11:59:13 <byte-> guess I need to pick a different name for the storage format
11:59:16 <vixey> byte-: they are not original
11:59:19 <ddarius> gwern: Overall I've been rather happy with evince.
11:59:23 <byte-> i checked out 'M', but never bothered with 'Mexpr'
11:59:32 <byte-> is there an 'M' language as well?
11:59:55 <vixey> byte-: anyway I still have no idea what you're parsing
12:00:26 <byte-> node{ node_item {list_item "optional parenthesis}}
12:00:37 <byte-> oopsn
12:00:39 <ddarius> Forget what you are parsing, what is the code.
12:00:45 <byte-> forgot the last quote
12:01:20 <byte-> give me a sec
12:01:50 <joey_> ddarius: Actually I ended my sentence with a question mark; I thought that was what you were implying. It is not what I was saying.
12:02:09 <hpaste>  byte- pasted "(no title)" at http://hpaste.org/8733
12:02:14 <jre2> @seen twanvl
12:02:15 <lambdabot> twanvl is in #haskell, #haskell.dut and #ghc. I don't know when twanvl last spoke.
12:02:48 <vixey> you can delete all those '{' and '}'s
12:03:01 <byorgey> byte-: https://secure.wikimedia.org/wikipedia/en/wiki/M_programming_language
12:03:02 <lambdabot> http://tinyurl.com/69l7g7
12:03:11 <byte-> byorgey: ok
12:03:14 <byte-> how about epsilon?
12:03:49 <byorgey> not that I know of
12:03:53 <byte-> ok
12:03:54 <byte-> anyway
12:05:01 <byte-> hmm... i can't remember the problem i was having with the code now
12:05:04 <byte-> this is troublesome
12:06:10 <dmwit> What is lookAhead?
12:06:11 <byte-> actually
12:06:31 <byte-> same as try
12:06:37 <byte-> but it reverts back even on success
12:06:47 <byte-> I think
12:06:49 <ddarius> dmwit: It's a function in parsec
12:07:06 <dmwit> Okay, the source makes it clear what it does.
12:07:18 <jre2> anyone know who "omnId" from http://hpaste.org/3018#a12 is?
12:07:18 <dmwit> It reverts only on success.
12:07:34 <byte-> dmwit: if it fails it doesn't need to revert back ;)
12:07:39 <dmwit> right
12:07:45 <ddarius> It succeeds if the inner parse succeeds without consuming anything and fails without consuming anything if the inner parse fails.
12:07:52 <jre2> I'd like to package that code and throw it onto hackage, but I'd rather ask permission first.
12:08:05 <dmwit> ?seen omniscientidiot
12:08:05 <lambdabot> I haven't seen omniscientidiot.
12:08:11 <ddarius> Which I guess can be simplified to it succeeds or fails without consuming anything.
12:08:11 <byte-> what code?
12:08:25 <jre2> some functional references and template haskell code
12:08:38 <twanvl> jre2: you rang?
12:08:54 <byte-> I wonder if I can use manyTill for readchars
12:08:56 <byte-> instead of recursing
12:08:57 <ddarius> jre2: That or something like it should already be on hackage.
12:08:57 <jre2> twanvl: do you know who omnniscientIdiot is?
12:09:13 <oldsalt> when i have a local darcs repository and a remote one where i push my patches and i want to darcs convert to version 2.x, do i have to run darcs convert on both repos or on one of them?
12:09:46 <dmwit> oldsalt: Convert one, then "darcs get" from it?
12:09:55 <byte-> anyway
12:09:59 <byte-> i remembered the problem in my code
12:10:25 <byte-> what in the world is stringE consuming with "{...}"?
12:10:30 <oldsalt> dmwit: well i dont know and my friend and i argue about it
12:10:30 <byte-> it should fail on the first {
12:10:48 <dmwit> oldsalt: Convert one, then "darcs get" from it.
12:10:56 <oldsalt> so you are really sure?
12:11:06 <dmwit> All repositories are created equal.
12:11:24 <twanvl> jre2: why do you want to know? I know him as omn(ischient)Id(iot) in IRC, but he has used a differrent name before.
12:12:00 <mapreduce> > 3^3^3^3
12:12:13 <lambdabot>  Tried to use too much memory
12:12:22 <byte-> busted
12:12:34 <jre2> twanvl: I wanted to (clean up then) put his TH bindings to your functional references code on hackage
12:12:36 <byte-> at least pm lambdabot when you do that ;)
12:12:43 <mapreduce> byte-: Why?
12:13:27 <byte-> mapreduce: great, now I've waited too long to say anything witty
12:13:31 <byte-> see what you made me do
12:13:33 <mapreduce> When you type 3^3^3^3 in ghci, how do you kill it?
12:13:43 <byte-> ctrl-C?
12:14:00 <Deewiant> > 3^3^3
12:14:02 <lambdabot>  7625597484987
12:14:09 <byte-> > 9^3
12:14:11 <lambdabot>  729
12:14:15 <Deewiant> > (3^3^3)^3
12:14:16 <byte-> > 3^9
12:14:16 <oldsalt> dmwit, so i convert the remote one, delete the local one and copy the remote to my local machine biy getting it?
12:14:17 <lambdabot>  443426488243037769948249630619149892803
12:14:18 <lambdabot>  19683
12:14:28 <byte-> wait...
12:14:30 <dmwit> oldsalt: That sounds like a fine process.
12:14:31 <byte-> 9 = 3^2
12:14:33 <byte-> whoops
12:14:50 <ski> @check 9 == 3^2
12:14:52 <lambdabot>  OK, passed 500 tests.
12:14:55 <byte-> 27^3
12:15:05 <byte-> > 27^3
12:15:06 <lambdabot>  19683
12:15:11 <oldsalt> is it the same as converting the remote one and the local one?
12:15:22 <mapreduce> Why would (3^3^3)^3 work but 3^3^3^3 not?
12:15:33 <dmwit> oldsalt: I do not know the answer to that.
12:15:33 <ski> `^' is right-associative
12:15:43 <ski> the latter number is much larger
12:15:43 <mapreduce> Ahh.
12:15:49 <dmwit> oldsalt: But you could certainly ask on #darcs if you want to try that instead.
12:15:58 <oldsalt> ok, i will, thanks
12:16:05 <mapreduce> So it's 3^7625597484987
12:16:20 <ski> aye
12:16:20 <dmwit> > let x = 3^3^3 in x `seq` 3^x
12:16:32 <lambdabot>  Tried to use too much memory
12:16:39 <twanvl> jre2: I have started an extension/clean up in the past, but I never finished it. You can find it at http://code.haskell.org/category/
12:16:39 <lambdabot> Title: Index of /category
12:17:24 <mapreduce> Why is it right-associative?
12:17:51 <ski> probably because it (at least often) is, in math notation
12:17:51 <dmwit> Because that's how it's done in mathematics.
12:18:17 <mapreduce> True. :)
12:18:27 <ski> now why it's usually (?) done that way in math is another question
12:18:48 <RayNbow> how many programming languages actually implement ^ in a right associative way?
12:18:50 <EvilTerran> because (x^y)^z = x^(yz)
12:18:58 <jeffwheeler> Is cabal-install stable enough to use for simple stuff?
12:19:04 <dmwit> yes
12:19:05 <vixey> > 2^2^2
12:19:06 <lambdabot>  16
12:19:09 <vixey> > (2^2)^2
12:19:09 <EvilTerran> there's already an unparenthesised way of writing (x^y)^z in maths
12:19:11 <lambdabot>  16
12:19:17 <vixey> ^ is associative :p
12:19:18 * RayNbow knows that his TI-83+ fails
12:19:26 <ski> EvilTerran : but  a -> (b -> c)  ~=  (a,b) -> c
12:19:28 <RayNbow> vixey: try QuickCheck :p
12:19:31 <EvilTerran> so they may as well let x^(y^z) have the ambiguous one
12:19:33 <mapreduce> Python seems to make ** right-associative.
12:19:40 <vixey> a -> b = b^a
12:19:54 <EvilTerran> ski, er... so?
12:19:55 <ddarius> mapreduce: It should be right associative.
12:20:01 <mapreduce> And you can interrupt it without killing the process, unlike in ghci :)
12:20:07 <ski> EvilTerran : so why is `->' right-associative in haskell ?
12:20:28 <RayNbow> ski: because it's natural :p
12:20:43 <EvilTerran> because there is a difference between your two types
12:20:55 <ski> @check \x y z -> (x^y)^z /= (x :: Int)^(y^z)
12:20:56 <lambdabot>  Falsifiable, after 0 tests: 0, 0, 2
12:20:58 <EvilTerran> and my two terms are indistinguishable
12:21:00 <ddarius> ski: Because (a,b) -> c is only isomorphic to a -> b -> c
12:21:06 <EvilTerran> (under the usual rules of arithmetic)
12:21:23 <vixey> in a lot of texts they write (a,b) -> c as shorthand for a -> b -> c
12:21:44 <ski> ddarius : yes .. but that doesn't really explain it .. it just refrains from explaining the converse situation
12:21:45 <EvilTerran> anyway, i meant what i said as an example of "it's more useful to use this associativity than the other one"
12:22:04 <ski> vixey : hm, where ?
12:22:22 <EvilTerran> and, for ->, given that currying is the norm, right-associativity is more useful than left
12:22:28 <EvilTerran> also, that's a convention from logic
12:22:34 <ski> EvilTerran : correct ! :)
12:22:35 <vixey> ski: Girard Huet
12:22:50 <EvilTerran> :)
12:22:58 <ski> (EvilTerran : re currying, i.e.)
12:23:13 <EvilTerran> i figured
12:24:58 <ddarius> Logicians are/were afraid of higher-order logic.
12:25:59 <ski> @check \x y z -> all (> 0) [x,y,z] ==> (x^y)^z /= (x :: Int)^(y^z)
12:26:01 <lambdabot>  Falsifiable, after 0 tests: 3, 3, 1
12:26:11 <ski> @check \x y z -> all (> 1) [x,y,z] ==> (x^y)^z /= (x :: Int)^(y^z)
12:26:13 <lambdabot>  Falsifiable, after 2 tests: 2, 2, 2
12:26:17 <ddarius> :t Text.ParserCombinators.Parsec.parse
12:26:18 <lambdabot> forall t s a. (Text.Parsec.Prim.Stream s Identity t) => Text.Parsec.Prim.Parsec s () a -> Text.Parsec.Pos.SourceName -> s -> Either Text.Parsec.Error.ParseError a
12:28:06 <ddarius> > Text.Parsec.parse (Text.Parsec.lookAhead (Text.Parsec.char 'a') Text.Parsec.<|> return 'b') "" "x"
12:28:07 <lambdabot>   Not in scope: `Text.Parsec.<|>'
12:28:24 <ddarius> > Text.Parsec.parse (Text.Parsec.lookAhead (Text.Parsec.char 'a') <|> return 'b') "" "x"
12:28:25 <lambdabot>   Not in scope: `Text.Parsec.char'
12:28:52 <ddarius> > Text.Parsec.parse (Text.Parsec.Combinator.lookAhead (Text.Parsec.Char.char 'a') <|> return 'b') "" "x"
12:28:54 <lambdabot>   Not in scope: `Text.Parsec.Char.char'
12:29:39 <ziman> @pl \f x -> if x == 0 then 1 else x * f (x-1)
12:29:40 <lambdabot> ap (flip if' 1 . (0 ==)) . ap (*) . (. subtract 1)
12:29:56 <ddarius> > Text.ParserCombinators.Parsec.parse (Text.ParserCombinators.Parsec.lookAhead (Text.ParserCombinators.Parsec.char 'a') <|> return 'b') "" "x"
12:29:57 <lambdabot>   Not in scope: `Text.ParserCombinators.Parsec.char'
12:30:13 <ddarius> Curses
12:30:15 <wuxia> in the following code,  why is the first type line okay, but the second type line give me errors? inc :: Integer -> Integer
12:30:18 <wuxia> inc n = n + 1
12:30:21 <wuxia> [1.2.3] :: [Integer]
12:30:39 <jeffwheeler> wuxia: shouldn't those be commas?
12:31:09 <wuxia> [1,2,3] :: [Integer] <-- still gives me errors
12:31:41 <Saizan> because you can't have an expression at the toplevel like that
12:31:52 <Saizan> it must be part of a definition
12:32:08 <Saizan> "inc n = n + 1" defines the function inc
12:32:43 <efh> > map fromJust $ concat $ map (dropWhile $ isNothing) $ map (:[]) [Just "1", Nothing, Just "2"]
12:32:44 <lambdabot>  ["1","2"]
12:33:13 <dmwit> > catMaybes [Just 1, Nothing, Just 2]
12:33:15 <lambdabot>  [1,2]
12:33:19 <tusho> > var $ "Deewiant" ++ replicate "++"
12:33:20 <lambdabot>  Couldn't match expected type `Int' against inferred type `[Char]'
12:33:25 <tusho> > var $ "Deewiant" ++ repeat "++"
12:33:26 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
12:33:32 <tusho> > var $ "Deewiant" ++ cycle "++"
12:33:34 <lambdabot>  Deewiant++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++...
12:33:44 <Deewiant> @karma Deewiant
12:33:45 <lambdabot> You have a karma of 0
12:33:47 <Deewiant> :-P
12:33:52 <tusho> *g*
12:34:01 <dmwit> 0 is just lambdabot's way of saying \infty
12:34:11 <Deewiant> of course
12:34:19 <Deewiant> @karma dmwit
12:34:20 <lambdabot> dmwit has a karma of 5
12:34:26 <tusho> @karma lambdabot
12:34:26 <lambdabot> lambdabot has a karma of 3
12:34:34 <Deewiant> lambdabot--
12:34:38 <tusho> hmm, wasn't it I who reduced that from like 50 to 0?
12:34:41 <tusho> i can't remember why
12:34:53 <tusho> i think I was wondering if it LET you spam --s
12:34:55 <tusho> guess it did
12:35:24 <dmwit> People like you are why we can't have nice things.
12:35:29 <ddarius> /2
12:35:53 <tusho> dmwit: But ... we DO have nice things/
12:35:57 <tusho> EXPLAIN THAT HUH
12:36:13 <qebab> a friend of mine tried to understand infinity the other day
12:36:28 <tusho> qebab: Was it too FAR OUT MAN?
12:36:45 <qebab> tusho: he was bothersome at least!
12:36:49 <shapr> @yow
12:36:49 <lambdabot> Couldn't find fortune file
12:37:00 <tusho> ok
12:37:02 <tusho> we have nice things
12:37:04 <tusho> but they're broken
12:37:21 <lxuser> tusho++++++++++++++++++++++++++++++ WOULD BUY FROM AGAIN. GREAT COMMUNICATION. A++++++++
12:37:25 <lxuser> @karma tusho
12:37:25 <lambdabot> tusho has a karma of 0
12:37:33 <shapr> What's going on here?
12:37:35 <tusho> lxuser++
12:37:38 <tusho> talked like an ebay user
12:37:43 <tusho> would listen to again
12:37:44 <tusho> A+++++++
12:37:45 <jre2> @karma Cale
12:37:45 <lambdabot> Cale has a karma of 76
12:37:46 <vixey> hi shapr
12:37:46 <tusho> @karma lxuser
12:37:46 <lambdabot> lxuser has a karma of 1
12:37:49 <jre2> Cale++
12:37:50 <dmwit> shapr: It has to be exactly two pluses.
12:37:51 <tusho> lxuser++
12:37:52 <tusho> @karma lxuser
12:37:52 <lambdabot> lxuser has a karma of 2
12:37:55 <jre2> @karma Cale
12:37:56 <lambdabot> Cale has a karma of 77
12:37:57 <tusho> ++
12:37:59 <tusho> @karma
12:37:59 <lambdabot> You have a karma of 0
12:38:01 <tusho> :(
12:38:02 <shapr> tusho: Hey, this doesn't look like Haskell talk...
12:38:04 <jre2> you guys are just bad at this
12:38:09 <tusho> shapr: It IS.
12:38:12 <shapr> tusho: How so?
12:38:15 <drguildo> the channel's gone all loldongz
12:38:16 <tusho> We are discussing the Algorithmic Language Report on Lambdabot.
12:38:19 <tusho> It's a superset of Haskell.
12:38:24 <tusho> (Haskell is available via >-prefixes.)
12:38:24 <Cale> Karma for me? :)
12:38:41 <shapr> tusho: Seriously man
12:38:52 <jre2> Cale: I actually owed you that from a long time ago for a SIGPIPE issue
12:38:52 <shapr> Looks like spam
12:39:10 <tusho> shapr: You look like a green blob of goo.
12:39:12 <Cale> ah
12:39:13 <Cale> hehe
12:39:15 <tusho> But I don't judge people by their looks.
12:39:32 --- mode: ChanServ set +o shapr
12:39:37 <shapr> tusho: Dude, it looks like spam.
12:40:07 <tusho> Dude, okay. Dude.
12:40:25 <shapr> That's me trying to be nice, I don't have to...
12:41:07 --- mode: shapr set -o shapr
12:42:47 <shapr> Sock puppets suck.
12:43:00 * shapr looks at qebab 
12:43:05 <mapreduce> Suck puppet's sock.
12:43:09 <dmwit> That was a shoe-in for most random comment.
12:43:27 * shapr grins
12:43:30 <qebab> what ):
12:43:34 * qebab is confused
12:43:37 <dmwit> I'll be stocking up on puns for a few days.
12:44:01 * shapr hugs qebab 
12:44:20 <qebab> thanks, now I feel better but I'm even more confused
12:44:27 * shapr grins
12:45:00 <oklopol> qebab: you taste nice
12:45:15 * shapr goes out to get a qebab...
12:45:24 <qebab> oklopol: only when you're drunk, I'm afraid
12:45:49 <ski> @quote
12:45:49 <lambdabot> <basti_> says: Snow doeth lay upon the lands. Even with cunning newtype; deriving the newtype is recursive. Great leaders brings less pain.
12:45:58 <dmwit> Mind your k's and q's, people.
12:46:54 <jeffwheeler> Pulling from darcs' 1.4 branch seems to be either very slow or broken for me. :-/
12:47:16 <jeffwheeler> I've been running this, and it starts to read inventory and then seems to do nothing: "darcs get --partial http://darcs.haskell.org/cabal-branches/cabal-1.4/"
12:47:18 <lambdabot> Title: Index of /cabal-branches/cabal-1.4
12:47:53 <byorgey> jeffwheeler: it's probably just taking a really long time.
12:48:02 <kiris> so I want to learn about the theory of monads and functors and such. is there a good book on category theory for math laymans?
12:48:05 <byorgey> just let it run in the background and see what it's doing in a couple hours
12:48:08 <jeffwheeler> byorgey: mmmk, then I'll let it run
12:48:09 <dmwit> Use --verbose.  Then it will spew a lot of garbage before it takes a long time.
12:59:22 <efh> it it possible to have a function f that map to an IO [a] where the IO [a]  is not >>= f
12:59:54 <efh> *maps
13:00:11 <jeffwheeler> It's done now; thanks for the advice.
13:01:07 <Deewiant> ?ty liftM . Prelude.map
13:01:08 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> b) -> m [a] -> m [b]
13:03:23 <dmwit> efh: I'm not sure what you're asking.
13:03:54 <dmwit> efh: There are several possible answers, depending on what you want; Deewiant showed one.  Here's another:
13:03:56 <dmwit> :t mapM
13:03:58 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
13:04:43 <EvilTerran> efh, you need to run the IO [a] action (ie bind it) in order to get the list out to map across
13:04:45 <efh> map (\x-> x+1) $ IO [1,2,3]
13:05:01 <EvilTerran> ?type map (\x-> x+1) <$> IO [1,2,3]
13:05:02 <lambdabot> Not in scope: data constructor `IO'
13:05:12 <dmwit> :t map . liftM
13:05:13 <EvilTerran> ?type map (\x-> x+1) <$> (return :: a -> IO a) [1,2,3]
13:05:13 <lambdabot> forall (f :: * -> *) a1 r (m :: * -> *). (Monad m, Functor f) => (a1 -> r) -> f (m a1) -> f (m r)
13:05:14 <lambdabot> forall a. (Num a) => IO [a]
13:05:18 <Deewiant> > (liftM . Prelude.map) (\x -> x+1) (return [1,2,3] :: IO [Int])
13:05:19 <lambdabot>   Not in scope: `Prelude.map'
13:05:20 <EvilTerran> ew, functor
13:05:22 <dmwit> :t Prelude.map . liftM
13:05:23 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> [m a1] -> [m r]
13:05:28 <Deewiant> > (liftM . P.map) (\x -> x+1) (return [1,2,3] :: IO [Int])
13:05:30 <lambdabot>  <IO [Int]>
13:06:16 <drigz> why is the definition of print in the /topic?
13:06:30 <dmwit> It was mentioned several times.
13:06:49 <dmwit> Either that, or dons just has weird whims. ;-)
13:06:59 <drigz> has it worked?
13:06:59 <Botje> @quote
13:06:59 <lambdabot> fr30n says: <fr30n> php? eso es para vrutos
13:10:21 <dmwit> ?quote
13:10:21 <lambdabot> <basti_> says: Snow doeth lay upon the lands. Even with cunning newtype; deriving the newtype is recursive. Great leaders brings less pain.
13:10:28 <dmwit> The deuce?
13:10:33 <dmwit> Are there only two quotes in there?
13:10:34 <dmwit> ?quote
13:10:34 <lambdabot> gubagem says: If I've made a monad by accident, am I heading in the correct direction?
13:10:54 <__pao__> hi all :-)
13:11:03 <dmwit> Hiya, __pao__!
13:11:12 <ziman> hello :)
13:11:16 <__pao__> what is the best way to "sandbox" an haskell installation?
13:11:54 <__pao__> I'd like to have parallel installation with different ghc versions and libraries versions
13:12:00 <ddarius> kiris: Conceptual Mathematics is a CT book aimed at a fairly "low" level, but it would need to be followed up with something else.  These lecture notes are good if you are coming from a computer science perspective: http://www.let.uu.nl/esslli/Courses/barr-wells.html
13:12:03 <lambdabot> Title: Courses: Barr / Wells
13:12:23 <ddarius> __pao__: You don't have to do anything.  Multiple versions of GHC can coexist with no problem.
13:12:44 <__pao__> ddarius: also different libraries versions?
13:12:57 <ddarius> Yes.
13:14:14 <__pao__> ddarius: I'll try a source installation... I feel very handfull to have "disposable" environments that I can you to experiment without worrying to leave garbage around in the filesystem
13:16:35 <ski> @babel sv en fika
13:16:35 <lambdabot> Plugin `babel' failed with: Error: Language sv not supported
13:33:11 <BearMac> hola
13:48:40 <Frederick> Can anyone pleasename a good book o semanthics of programming languages?
13:49:05 <vixey> Types and Programming Languages
13:50:07 <Frederick> vixey: from pierce right?
13:50:25 <vixey> no, the other book called Types and Programming Languages :P
13:50:36 <Frederick> I got it from the library havent found it very good isnt glen winskel book better?
13:50:44 <vixey> it is very good
13:51:17 <Frederick> which one is better?
13:52:07 <therp> Frederick: semantics of imperative programming languages?
13:52:21 <Frederick> therp: yep
13:52:23 <therp> because for functional ones lambda is pretty much sufficient :)
13:52:54 <Frederick> im graduating from universityand despite I thinksemantics sucks I recognize the impotance of having adecent book on the subject specially cause I dislike it
13:53:02 <therp> Frederick: http://www.daimi.au.dk/~bra8130/Wiley_book/wiley.html
13:53:03 <lambdabot> Title: Semantics with Applications
13:53:18 <Frederick> I have a copy of it at home also havent found it good
13:53:23 <Frederick> :p
13:53:43 <therp> really? I found it excellent, in detail and correctness
13:53:44 <vixey> maybe you should read a book about something you are actually interested in instead ...
13:53:52 <vixey> or am I the only one that does that ?
13:54:58 <Frederick> But it is nice to remember that this book is free
13:55:00 <Frederick> I will print it
13:56:11 <therp> Frederick: http://www.logic.at/lvas/185205/indexe.html that's the page of a lecture on semantics I did last term.. probably check the literature section
13:56:12 <lambdabot> Title: Semantik von Programmiersprachen / Semantics of Programming Languages, VU 3.0/2. ...
13:57:20 <therp> but I can't comment on the quality of these books.. I just read semantics with applications
13:58:10 <dons_> audreyt: where can i get the uconv C lib haskell-uconv depends on?
13:58:39 <Frederick> therp: Are you german? :P
14:00:07 <therp> Frederick: Austrian
14:00:35 <therp> we do speak german though :)
14:01:31 <Frederick> ich weise >)
14:01:43 <name> therp: a countryman :)
14:02:03 <Frederick> ich kann auch ein bisschen deutsch :0
14:02:10 <Frederick> I lived 1 year in kaiserslautern, germany
14:02:25 <name> is there any ide for haskell?
14:02:54 <jre2> name: vim + haskellmode is pretty slick
14:02:57 <wuxia> i've decided to write a ray tracer (install of an o9pengl app) to help me learn haskell
14:02:58 <kryptiskt>  name: eclipsef is an eclipse plugin
14:03:05 <wuxia> what should i use for blitting pixels to the screen?
14:03:05 <kryptiskt> eclipsefp
14:03:13 <therp> name: oh hi :)
14:03:27 <name> The OCaml subproject is no longer active. If you want to help and bring it back to life, please contact the EclipseFP mainling list.
14:03:33 <name> ah i misread
14:03:34 <name> sorry :)
14:04:07 <name> i think haskell will confuse me :)
14:04:51 <jre2> name: so long as you're learning in the process, it's a net gain
14:04:55 <SamB> name: when can only hope so
14:05:00 <dons_> you're looking for an ide on windows?
14:05:03 <therp> name: oh, countryman but not a haskeller? :)
14:05:15 <SamB> if you don't get confused, it's probably because you decided not to bother
14:05:15 <name> therp: pythoner :)
14:05:21 <SamB> and that would be sad ;-)
14:06:11 <ziman> wuxia, I used a simple PPM export
14:06:16 <name> i'm really interested in a different approach of programming
14:06:26 <vixey> different to what?
14:06:32 <name> procedural
14:06:42 <vixey> haskell is a good choice
14:06:46 <SamB> name: well, you've certainly come to the right place
14:06:46 <therp> name: haskell is the best choice for that.
14:06:54 <vixey> certainly not the best choice
14:07:02 <name> vixey: that would be?
14:07:09 <SamB> we can definately set you up with one or more different approaches to programming, haskell or otherwise ;-)
14:07:17 <vixey> It's impossible to put an ordering on these things
14:07:37 <SamB> vixey: at least, they lack a 
14:08:03 * vixey has a cup of 
14:08:23 <SamB> vixey: you must be getting  confused with T
14:08:27 <ziman> wuxia, ppm is just a text file, no fuss with file formats; and i used gqview to watch the file so i could see the image appearing as it was being rendered
14:08:38 <matthew-_> so, how many #haskell teams are ready to go for Friday?
14:08:47 <name> hum? invalid module name. haskell eclipse gives me that
14:08:55 * SamB wishes he could type _|_ properly, but \bot is how he types  for some odd reason
14:09:06 <name> for any name i choose
14:10:05 * SamB wonders why such useful tools as primes and rot13 are in the bsdgames package
14:10:07 <therp> matthew-_: well, if a single-man team counts, o/
14:10:17 <matthew-_> therp: of course ;)
14:10:26 <dmwit> rot13 is a useful tool?
14:10:34 * dmwit just uses g?G
14:10:36 <matthew-_> last year the judges' prize went to a single programmer
14:10:48 <therp> matthew: wasn't it "Team Smartass" from google?
14:10:54 <therp> ah the judges' prize..
14:11:02 <matthew-_> Team Smartass won overall
14:11:11 <matthew-_> IIRC
14:11:47 <Botje> SamB: you need an excuse to install the games package >:)
14:12:16 <SamB> Botje: what? I was considering removing it because I don't think I actually play any of those games
14:12:19 <SamB> sadly enough
14:12:21 <matthew-_> therp: have you been following the spam on the icfp-list ?
14:12:25 <dmwit> ?where hierarchical
14:12:25 <lambdabot> I know nothing about hierarchical.
14:12:30 <therp> matthew-_: oh not at all. there is an icfp list?
14:12:37 <matthew-_> therp: yeah.
14:13:08 <therp> matthew-_: icfp programming contents or icfp general (+conference)  ?
14:13:14 <matthew-_> therp: there's a live cd this year. And people have been endlessly moaning about "wah, my language isn't there" even though they state you can submit a binary. *sigh*
14:13:27 <matthew-_> therp: yeah, all this icfp contest.
14:13:33 <therp> matthew-_: huch.. live cd for what purpose?
14:13:40 <matthew-_> testing
14:13:40 <dmwit> > 26^4
14:13:42 <lambdabot>  456976
14:14:11 <matthew-_> it's clearly going to be a game AI, so the clients will run on the live cd environment
14:14:17 <vixey> matthew-_: It's not that if your langauge isn't there -you- submit a live CD?
14:14:26 <SamB> vixey: hah
14:14:30 <matthew-_> vixey: lol
14:14:40 <matthew-_> "here, enjoy this 700MB upload"
14:14:50 <SamB> how big is the CD?
14:14:58 <matthew-_> twice the length from the middle ;P
14:15:13 <SamB> well they aren't going to send it in the mail
14:15:25 <SamB> so that is obviously not the relevent quantity
14:15:45 <SamB> besides which your expression is implicitly recursive ;-)
14:15:47 <matthew-_> frankly, unless it's otherwise demanded, my team is just going to submit a static binary
14:15:52 <wuxia> what's wrong with the following: ? test0 = writeFile "test0.ppm" (createppm 16 16 (map mkcol [0..255]))
14:15:55 <wuxia> where mkcol x = [x,x,x]
14:16:11 <wuxia> erro rI get back is: Image.hs:23:0: parse error on input `where'
14:16:15 <vixey> :t createppm
14:16:16 <lambdabot> Not in scope: `createppm'
14:16:20 <wuxia> from following code at: http://www.ryanlothian.com/articles/haskell-raytracer
14:16:21 <lambdabot> Title: Haskell Raytracer Project - Part 1
14:16:22 <dmwit> wuxia: Probably an indentation issue.
14:16:26 <vixey> wuxia: I guess the error is elsewhere
14:16:28 <matthew-_> wuxia: sounds like indentation
14:16:32 <therp> matthew-_: so the task is to deliver a game AI?
14:16:38 <SamB> what linux distribution is the CD based on?
14:16:46 <matthew-_> therp: they've not said as much, but that's *my* guess
14:16:47 <name> this really confuses me :)
14:16:48 <wuxia> hmm, where should be idented
14:16:55 <wuxia> dmwit, matthew-_ : thanks
14:17:09 <dmwit> name: What confuses you?
14:17:11 <matthew-_> SamB: "Linux Kernel KNOPPIX 2.6.19 #7 SMP PREEMPT, and the libc version is libc6/libc6-dev 2.7"
14:17:18 <SamB> therp: can't think why else they'd need to run it themselves
14:17:25 <matthew-_> *sigh* that's pretty ancient.
14:17:34 <matthew-_> I wouldn't be surprised if it's only 6.8.2
14:17:41 <matthew-_> ...hence static binary
14:18:29 <matthew-_> therp: plus if you look back at past contests, there's lots of them that demand this sort of stupp
14:18:37 <matthew-_> s/pp$/ff/
14:18:50 <matthew-_> ...right finger, wrong hand
14:19:00 <therp> nice typo :)
14:19:12 <therp> but what keyboard layout are you on?
14:19:17 <matthew-_> dvorak
14:19:18 <dmwit> dvorak
14:19:26 <matthew-_> dmwit: *wink*
14:19:37 <vixey> ',.pyf
14:19:46 <dmwit> matthew-_: Typos are always what give you away. ;-)
14:20:00 <therp> I thought about that.. but I would rather create my own layout.. :)
14:20:02 <dmwit> vixey: That's a catchy name.
14:20:17 <matthew-_> dmwit: yeah, that and alcholism
14:20:21 <byorgey> dmwit: do you use dvorak?
14:20:26 <dmwit> yes
14:20:32 <byorgey> ah, cool
14:20:37 <therp> hey I could start a keylogger.. run it for a month to collect statistics and then use that as the input to some optimizer :)
14:20:56 <matthew-_> so who uses dvorak on a blank "Das Keyboard" ?
14:21:14 <vixey> therp I think someone did that (using a GA) and came up with something very close to dvorak
14:21:15 <name> why can i do take 5 squares in a hugs session but not in the module
14:21:30 <dmwit> name: You need to name the result.
14:21:36 <name> ahh
14:21:36 <dmwit> name: Like "foo = take 5 squares".
14:21:58 <therp> vixey: yes, that's what I was talking about.. but he didn't came even close to dvorak
14:22:11 <name> i need to name the result of print?
14:22:16 <drigz> perhaps he means close in performance
14:22:27 <vixey> therp, oh ... I thought you were going to do it yourself because you were talking future tense
14:22:31 <therp> vixey: in retrospect I have hear a few critics about dvorak when it comes to certain metrics
14:22:44 <dmwit> name: Yes.  And it's turtles all the way up.
14:22:54 <matthew-_> therp, et al: I don't think dvorak is necessarily optimal. I just think that learning to touch type "properly" on any keymap is a good idea
14:22:59 <name> dmwit: what do you mean?
14:23:10 <dmwit> name: "print" is just a function that constructs a representation of the IO action to do.
14:23:24 <name> and how to execute that then?
14:23:39 <drigz> name: whatever you call 'main' is executed
14:23:40 <dmwit> name: It isn't until an IO action appears in "main" that it will magically get turned from a representation into an actual behavior.
14:23:55 <therp> matthew-_: sorry could you elaborate that? what do you mean by any keymap/touch type properly?
14:24:14 <name> main is a module, right?
14:24:21 <dmwit> Main is a module.
14:24:23 <therp> name: use uppercase
14:24:29 <dmwit> main is a value with type IO ().
14:24:44 <therp> name: or better the first char has to be uppercase for it to be a proper module name
14:24:50 <dmwit> (In GHC, main may also have the type "IO a" for any a.)
14:25:18 <matthew-_> therp: ok, so, I learnt qwerty through use, and just didn't do it "right" - I didn't use the right fingers at all
14:25:30 <byorgey> name: so you could say:  module Main where  main = print foo
14:25:36 <wuxia> @hoogle Integer
14:25:36 <lambdabot> Prelude.Integer :: data Integer
14:25:37 <lambdabot> GHC.Exts.Integer :: data Integer
14:25:37 <lambdabot> Text.PrettyPrint.HughesPJ.integer :: Integer -> Doc
14:25:42 <dmwit> Modules, constructors, and classes must begin with an upper-case letter.  For constructors, ':' is considered to be an uppercase letter.
14:25:44 <matthew-_> therp: plus I had poor posture and didn't look after myself physically at the keyboard. Hence RSI
14:25:47 <wuxia> hmm, how do I use this Integer to convert a fraction to an Integer?
14:25:50 <wuxia> like 5/2 -> 2
14:25:55 <dmwit> Values and type variables must begin with a lower-case letter.
14:26:02 <byorgey> wuxia: just use `div`
14:26:03 <dmwit> wuxia: div
14:26:07 <byorgey> > 5 `div` 2
14:26:09 <lambdabot>  2
14:26:14 <matthew-_> therp: rather than trying to force myself to learn qwerty properly, I just switched to dvorak and did that properly
14:26:22 <therp> matthew-_: ah that's what you meant.. well I have a kinesis keyboard.. I had to relearn qwerty a bit.. but kinesis pretty much forces you to use the fingers intended for the key
14:26:26 <dmwit> > properFraction (5/2)
14:26:28 <lambdabot>  (2,0.5)
14:26:31 <matthew-_> therp: and got good keyboards, and chairs etc etc, and I'm ok atm
14:26:33 <byorgey> wuxia: if you already have a floating-point value you can use something like floor, round, or ceiling
14:27:01 <wuxia> byorgey , dmwit : great, thanks
14:27:02 <matthew-_> therp: yeah, I tried a knesis for a day, and couldn't really be bothered with it
14:27:02 <therp> matthew-_: any special chair?
14:27:13 <matthew-_> therp: I use a saddle stool
14:27:22 <wuxia> therp: I am using a kiknesis too, do yolu have special mappings for ->, it's rather incovenient to type
14:27:28 <matthew-_> therp: but it's just about finding a posture that works for you
14:28:22 <therp> wuxia: hmm.. no but for other things.. but a bit messy http://clemens.endorphin.org/therp.xkb
14:28:58 <therp> wuxia: also a bit outdated, as I'm doing it in a different way (as KDE will not properly recognize remapped modifier keys if done in that way)
14:29:32 <wuxia> therp: cool, thanks
14:29:43 <matthew-_> therp: I use one of these: http://www.beautelle.co.uk/water/Saddle%20Seating.htm
14:29:44 <lambdabot> Title: Ergonomic Seating - saddle stools to improve posture and help bad backs
14:30:05 <matthew-_> it's kinda hard to slouch in them
14:31:01 <therp> matthew-_: oh .. hmm .. the berich is cheering. the real ich wants to slouch
14:31:38 <matthew-_> therp: heh, which .de are you at?
14:32:03 <therp> matthew-_: .de? I'm from .at :)
14:32:13 <matthew-_> my apologies ;)
14:33:20 <name> this is too much for me :S
14:34:09 <dmwit> name: What's up?
14:34:15 <therp> name: module Main where main = putStrLn "Hello World"
14:34:18 <therp> name: shouldn't be hard :)
14:35:53 <dmwit> ?where lambdabot
14:35:53 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
14:36:28 <twifkak> hey, is there any way i can get ghc to output the set of flags it passes to gcc (for compiling .c files) so i can backtick it into another build system?
14:37:04 <name> therp: that worked ;)
14:37:15 <wuxia> @hoogle *l
14:37:15 <lambdabot> Hoogle Error: Parse Error: Unexpected character '*l'
14:37:20 <wuxia> what does: mult :: Scalar -> Vector -> Vector
14:37:20 <wuxia> mult l (Vector xs) = Vector (map (*l) xs)
14:37:24 <dmwit> name: You can even skip the "module Main where " bit. ;-)
14:37:26 <wuxia> mean? how does it convert a vector to a s5tring?
14:37:50 <dmwit> Why should it convert a Vector to a String?
14:37:59 <wuxia> -- to convert a vector to a string, just convert its value list to string
14:37:59 <wuxia> mult :: Scalar -> Vector -> Vector
14:37:59 <wuxia> mult l (Vector xs) = Vector (map (*l) xs)
14:38:07 <wuxia> from http://www.ryanlothian.com/articles/haskell-raytracer-2
14:38:13 <lambdabot> Title: Haskell Raytracer Project - Part 2
14:38:17 <wuxia> i'm an idiot
14:38:18 <dmwit> The comment is unrelated to the function, obviously.
14:38:20 <matthew-_> twifkak: try -pgml echo
14:38:21 <wuxia> i pasted the wrong code
14:38:24 <wuxia> sorry
14:38:58 <dmwit> The comment refers to the code *above* it, not below it.
14:38:59 <name> compilation IS NOT required < how does it know?
14:39:06 <dmwit> Black magic!
14:39:12 <dmwit> But more likely by date.
14:39:13 <name> i did change the code ^^
14:39:24 <drigz> name: it's not always right, either :(
14:39:26 <dmwit> Did you save?
14:39:34 <twifkak> matthew-_: will try, thanks.
14:39:39 <name> dmwit: yes i did
14:39:54 <drigz> name: which operating system are you on?
14:40:00 <name> drigz: linux
14:40:14 <drigz> run: touch file.hs
14:40:15 <matthew-_> twifkak: that causes args to the linker to be echo'd out. which may or may not be what you want
14:40:41 <twifkak> oh, i see, yes, that's useful.
14:40:51 <name> how do i print out an iteger?
14:40:52 <therp> matthew-_: how much members does your team have
14:40:57 <matthew-_> therp: 2
14:40:59 <dmwit> name: print
14:41:22 <name> rm *hi < that does it but pretty annoying
14:41:28 <matthew-_> twifkak: it's how I go about making static binaries seeing as none of the various -static parameters to or via ghc actually work
14:41:53 <drigz> name: did touching the file not work?
14:41:56 <name> how do i import my other module?
14:42:03 <drigz> but really your text editor should do it
14:42:22 <dmwit> name: ...maybe you should read a tutorial?
14:42:22 <ziman> import Module -- ;)
14:42:37 <name> doesn't do it
14:42:37 <twifkak> matthew-_: hehe, aren't there ghc flags that delegate to the individual binaries?
14:42:41 <therp> name: most things can be converted to a String with the help of "show <expr>"
14:42:41 <name> that's it ^^
14:42:47 <name> it complains
14:43:34 <twifkak> matthew-_: yes, -optl ?
14:43:40 <matthew-_> twifkak: if there are, I've never made them work. I basically do -pgml echo and then cc -static $$(tail -n 1 $(PGML) | sed -e 's/ -l/ -pthread -l/');
14:43:50 <drigz> the module should be called Whatever.hs and start with 'module Whatever where', but as dmwit says, these are basics and are well documented outside of irc
14:44:00 <matthew-_> twifkak: I never got -optl to do anything useful
14:44:38 <wuxia> therp: OT, do you know ikf there's an pdf of the kinesis manual? i onloy have a paper copy and am constantly afraid of losing mine
14:45:03 <twifkak> matthew-_: okeydoke
14:45:15 <therp> wuxia: oh hmm. no idea. I could only ask google, but you have certainly done that.. I only have the "essential edition".. that's pretty much feature free
14:45:54 <name> ah eclipse works. :)
14:46:08 <dmwit> ?help link
14:46:09 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:49:23 <drguildo> what's a hidden package?
14:49:34 <drguildo>     Could not find module `System.Random':
14:49:34 <drguildo>       it is a member of package random-1.0.0.0, which is hidden
14:50:08 <dmwit> Try ghc-pkg help.
14:50:17 <dons> have people seen http://downforeveryoneorjustme.com/
14:50:17 <lambdabot> Title: Down for everyone or just me?
14:50:19 <TomMD> drguildo: you need to add 'random' to your deps in the .cabal file
14:50:28 <dmwit> dons: Pretty fun. =)
14:50:44 <drguildo> i downloaded hsxmpp the other day
14:50:50 <drguildo> got the included demo bot working
14:50:55 <drguildo> and now it isn't working anymore
14:52:04 <drguildo>     Could not find module `Network':
14:52:04 <drguildo>       Use -v to see a list of the files searched for.
14:52:39 <dons> heya TomMD
14:52:47 <dons> back home?
14:53:23 <dmwit> Add the "network" package, too.
14:53:46 <drguildo> dmwit, it's weird, i had it working yesterday
14:57:03 <TomMD> hey dons
14:57:18 <TomMD> yeah, back!
14:58:01 <TomMD> But I was tempted not to leave - I should have just lived in my brothers living room till he kicked me out.
14:58:11 <dons> hehe :)
14:58:38 <__pao__> I'm building ghc from source
14:58:49 <TomMD> pao: ghc head?
14:58:50 <dons> we'll just have to find more excuses for you to visit :)
14:59:03 <__pao__> TomMD: 6.8.3
14:59:26 <__pao__> I've installed readline from sources as well but I cannot link ghc against it
14:59:31 <__pao__> any suggestion?
14:59:41 * __pao__ is on mac os x
14:59:45 <TomMD> I'm likely to be there more and more - I also talked with Andrew Tolmach about studying under him.
15:00:14 <dmwit> __pao__: Why are you building?
15:00:35 <__pao__> dmwit: I'd like to control --prefix
15:00:45 <dons> TomMD: you could do worse than Tolmach and PSU
15:01:21 <dmwit> __pao__: The binary distribution (for Linux, at least) allows that.
15:03:39 <hackage> Uploaded to hackage: Vec 0.9.1
15:03:39 <hackage> Uploaded to hackage: mueval 0.4
15:03:39 <hackage> Uploaded to hackage: OpenAFP-Utils 1.2.1
15:03:40 <hackage> Uploaded to hackage: AGI 1.2.2
15:03:42 <hackage> Uploaded to hackage: AGI 1.2.1
15:03:57 <drguildo> are there any xmpp/jabber libraries apart from hsxmpp?
15:05:39 <drguildo> here's one, haskell-xmpp
15:07:13 <dons> hmm, i don't know of others. there's barracuda, a full distributed, ad hoc chat system, so there's probably some reusable code in there.
15:08:06 <dons> also points at some useful dependencies, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Barracuda
15:08:14 <lambdabot> Title: HackageDB: Barracuda-1.0.2, http://tinyurl.com/5gtgu2
15:08:29 <dons> but, no time like now for a jabber lib
15:08:42 <matthew-_> drguildo: there's now an xmpp to amqp binding available from lshift.net
15:09:00 <drguildo> dons, thanks
15:09:11 <drguildo> matthew-_, what's amqp?
15:09:36 <matthew-_> drguildo: the "open" version of mq series, active mq etc etc
15:09:45 <matthew-_> middleware message systems
15:09:51 <dons> matthew-_: a haskell binding ?
15:10:05 <matthew-_> dons: nah, I've not written it yet
15:10:22 <matthew-_> but rabbitmq, which is from lshift in written in Erlang, which is kinda close...
15:10:31 <matthew-_> s/ in / is /
15:10:32 <dons> ah i c.
15:11:16 <matthew-_> it really needs properly modelling in session types, but the spec is too much up in the air atm
15:11:56 <dmwit> ?activity
15:11:56 <lambdabot> 0*total
15:12:03 <dmwit> ?help activity
15:12:03 <lambdabot> activity seconds. Find out where/how much the bot is being used
15:12:15 <dons> matthew-_: have you been using the sessions library in practice yet?
15:12:36 <matthew-_> dons: slowly. there are some recent changes which make it much more useful
15:12:51 <matthew-_> dons: the main issue has been statically determined lists
15:12:59 <matthew-_> which has made usage very tricky
15:13:06 <dons> i can imagine.
15:13:23 <matthew-_> but I'm starting to be able to relax that with other tradeoffs and that makes the whole thing more useful
15:13:24 <dons> we've been following the sessions uploads closely at work
15:13:38 <dons> if you're ever on the west coast, you should drop by to talk about them :)
15:13:39 <matthew-_> dons: I've yet to receive any feedback though ;)
15:13:57 <matthew-_> dons: well, hopefully I'll be out to ICFP when my team wins the prog contest... :p
15:13:57 <dons> well, we're following, not necessarily knowing what to use them for yet.
15:14:03 <dons> hehe
15:15:00 <matthew-_> dons: things like MultiReceive are really tricky if you don't know statically all the channels that you're receiving on. But if you simply know that they'll all do the same type-transformations, the length isn't important
15:15:04 <matthew-_> which is really useful
15:15:21 <matthew-_> hopefully I'll have a full chat server up in the next month, using all this stuff
15:16:13 <wuxia> in "rayforpixel :: Vector -> Ray
15:16:20 <wuxia> rayforpixel (Vector pixel) = Ray zerovector (normalise (Vector (1.0:pixel)))" what does (1.0:pixel) mean ?
15:17:22 <matthew-_> hey Corun. How did the exams go?
15:17:34 <newsham> matthew: you shooting for 2nd?
15:17:52 <matthew-_> newsham: no no, 1st and the judges prize will do ;)
15:18:04 <newsham> hmm, dont you thin kthats a little unrealistic?
15:18:40 <jre2> is there a standard symbol for flip ($) ?
15:18:50 <matthew-_> newsham: I personally don't see value in not aiming for the top
15:19:04 <ddarius> jre2: No
15:19:19 <ddarius> "Warning: empty file"
15:19:34 <macondo> what is the most haskellian way of summing all the digits of an Int?
15:20:19 <Corun> mathew-_, got all As
15:20:20 <Gilly> sum . (map digitToInt) . show (Not actually sure if digitToInt exists by that name)
15:20:20 <vixey> > sum . map digitToInt . show $ 123
15:20:22 <lambdabot>  6
15:20:35 <matthew-_> Corun: yeah, but did you drop any marks at all?
15:20:40 <vixey> I don't know if it's haskellian or not but it works
15:20:46 <Corun> It doesn't say, but I'm sure I did :-P
15:20:57 <matthew-_> Corun: get out. Now. :-P
15:21:19 <Corun> I won the Adrian Israel Memorial Prize
15:21:22 <Corun> 200 :-)
15:21:39 <ddarius> "Programmers and computer scientists may find the concept of a hierarchy consisting of only two elements to be a bit odd, but this appears to be an established tradition in literary criticism."
15:21:40 <Corun> But, Milen won the "Formicary Software Engineering Prize", 1150
15:22:02 <matthew-_> Corun: congrats. But Formicary are a horrible company with whom you want nothing to do.
15:22:20 <Corun> I notice that you won neither in your first year ;-)
15:22:31 * matthew-_ sticks up a selection of fingers at Corun
15:22:38 <Corun> :-P
15:22:47 <matthew-_> Corun: I got the IBM project prize. That'll do thank you.
15:22:53 <matthew-_> that nearly killed me anyway
15:23:08 <Corun> Milen and I are coming to invade your floor in 23 days :-)
15:23:10 <newsham> matthew: but if i come in first you cannot.
15:23:11 <Corun> Bwahaha.
15:23:18 <newsham> i dont want to disappoint
15:23:20 <newsham> but life is unfair like that
15:23:29 <matthew-_> newsham: them's fighting words
15:23:45 <newsham> :)
15:23:48 * Corun has currently made 755 in DoC prizes.
15:23:49 <Corun> :-D
15:24:06 <matthew-_> wow, that's only slightly less than 1 month's rent
15:25:07 <Corun> Is that like "That's nearly 25%!"? ;-)
15:25:20 <matthew-_> Corun: very similar indeed ;)
15:25:59 <glguy> @seen dons
15:25:59 <lambdabot> dons is in #arch-haskell, #haskell, #ghc and #xmonad. I last heard dons speak 11m 56s ago.
15:26:56 * byorgey is sorry to inform newsham and matthew-_ that, in fact, NEITHER of them can win if his team does.
15:27:31 <matthew-_> byorgey: you really don't have much hope tbh ;)
15:27:48 <byorgey> yeah, I know =)
15:28:24 <matthew-_> byorgey: oh, come on, where's the testosterone?! Denounce our l33t abilities!
15:28:27 <newsham> i have a new strategy this year.
15:28:34 <newsham> i plan to thunk empty thoughts.
15:29:40 <byorgey> matthew-_: oh, er, right!  you and your so-called 'abilities' don't stand a chance.
15:29:48 <byorgey> and if newsham is using Java I think I need not comment.
15:30:19 <matthew-_> byorgey: better ;)
15:30:20 <newsham> byorgey: just trying to keep it fair
15:30:38 <ddarius> byorgey: But if he uses sed...
15:30:46 <vixey> blehh all these people talking about how "very very nice" python is grosses me out
15:31:05 <matthew-_> ddarius: shell has be okay'd by the organisers, so I'd assume sed is in too
15:31:06 <byorgey> I, on the other hand, will be using a super-advanced higher-order language which I implemented using the language I implemented in Haskell.
15:31:19 <byorgey> all previous ICFP contests can be solved in one line of code.
15:31:31 <byorgey> the SAME one line of code.
15:31:31 <newsham> matthew: dsl livecd definitely has sed/awk/sh
15:31:37 <matthew-_> byorgey: is that basically a language implemented in epigram?
15:31:56 <vixey> we need epigram to win ICFP
15:32:07 <vixey> or maybe we should all use TAL ...
15:32:14 <matthew-_> yeah, you might also need to interact with the world
15:32:35 <newsham> team log entry july 12th, 2008, 13:15.  We just spent the first day and a half proving termination of our sorting algorithm.  We are now moving on to the build system.
15:32:46 <byorgey> matthew-_: sort of, except seventeen times more advanced
15:33:03 <vixey> newsham hehe
15:33:03 <matthew-_> newsham, byorgey: rotfl
15:33:16 <matthew-_> newsham: I've already written the build system
15:33:29 <newsham> team log entry july 12th, 2008, 14:24.  One of our members recently brought to our attention "types considered harmful."  Team is in disarray.
15:33:53 <vixey> I thought types considered harmful was a joke though
15:34:15 <byorgey> and newsham's team log entry isn't? ;)
15:34:22 <newsham> it was a joke with some message.   type systems can get very complicated,  hindley milner is a nice sweet spot
15:34:36 <newsham> grad students prefer dependent types
15:34:40 <matthew-_> s/log entry isn't//g
15:34:42 <newsham> especially when persuing phds
15:34:43 * matthew-_ ducks ;)
15:35:03 <byorgey> hehe
15:35:19 <byorgey> newsham: hehe, ouch ;)
15:35:33 * byorgey plans to pursue a phd having to do with dependent types...
15:35:45 <newsham> sweet
15:35:46 <sm> is there a haskell lib for reading ms excel files ?
15:36:18 <byorgey> sm: I doubt it, excel file format is proprietary
15:36:25 <vixey> byorgey, really? what sort of stuff are you interested in ?
15:36:26 <mar77a> i'm sure it has been reversed
15:36:39 <newsham> sm: dump to csv, get csv reading code from hackage
15:36:44 <mar77a> openoffice.org can read excel files can't it
15:36:47 <byorgey> mar77a: well, probably =)  but I'm not aware of a haskell lib
15:36:52 <byorgey> true
15:36:53 <mar77a> neither
15:36:54 <dons> sm: check with Heffalump, he might know
15:37:47 <byorgey> vixey: you mean, what kinds of stuff in general?  or what kinds of stuff related to dependent types specifically?
15:37:56 <sm> thanks all
15:37:59 <vixey> um. both :)
15:38:21 <mar77a> isn't "" recognized as a string
15:38:26 <mar77a> getProfiles :: IO [String]
15:38:36 <mar77a>     return "" (last line in a do seq)
15:38:41 <mar77a> gives an error :|
15:38:45 <vixey> "" is a string, [""] is a String, return [""] is an IO [String]
15:38:46 <byorgey> vixey: well, generally, I'm interested in all sorts of things... PL theory, logic, category theory, combinatorics...
15:39:09 <mar77a> what'a a 'string' and how is it different from a String?
15:39:22 <vixey> mar77a: typo, I meant String
15:39:28 <byorgey> vixey: with dependent types in particular I don't know yet =)
15:39:31 <vixey> oh and I meant [String]
15:39:34 <dmwit> mar77a: The key here is the difference between String and [String].
15:39:34 <vixey> byorgey: aww ok
15:39:38 <dons> byorgey: haskell job, http://www.cse.unsw.edu.au/news/news_0038.html
15:39:40 <lambdabot> Title: Research Assistant - Formal Verification Tools
15:39:41 <vixey> byorgey: There is a lot going on in the area ..
15:39:47 <byorgey> vixey: indeed.
15:40:15 <byorgey> vixey: ask me again in a few months, I'm going to be doing an independent study related to dependent types in the fall
15:40:22 <byorgey> thanks dons
15:41:09 <mar77a> yeah mb got it
15:41:13 <mar77a> stupid mistake hehe
15:41:19 <mar77a> trimExt :: String -> String
15:41:20 <mar77a> trimExt (h:".ini") = h
15:41:33 <mar77a> expected [Char] inferred Char?
15:41:41 <mar77a> does it only match to one element
15:41:45 <vixey> mar77a: what would the type of h be?
15:41:48 <dmwit> mar77a: h only matches a single element
15:41:52 <mar77a> bingo
15:42:02 <mar77a> i thought i had solved the problem nicely :(
15:42:04 <vixey> :t ?h:".ini"
15:42:05 <lambdabot> (?h::Char) => [Char]
15:42:09 <mar77a> guess i have to use  em
15:42:11 <mar77a> isSuffixOf?
15:42:17 <vixey> reverse
15:42:19 <dmwit> :t isSuffixOf
15:42:20 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
15:42:29 <dmwit> Or yeah, reverse it twice.
15:42:33 <vixey> > (init . init . init) "foo.ini"
15:42:35 <lambdabot>  "foo."
15:42:52 <mar77a> well i want to get rid of suffixing ".ini" or ".txt"
15:42:54 <mar77a> else leave as is
15:42:58 <mar77a> trimExt :: String -> String
15:42:58 <mar77a> trimExt (h:".ini") = h
15:42:58 <mar77a> trimExt (h:".txt") = h
15:42:59 <mar77a> trimExt h = h
15:43:02 <mar77a> that's the function
15:43:27 <byorgey> mar77a: that won't work, since the type of (:) constrains h to be a single Char there
15:43:36 <mar77a> yeah i understood that part
15:43:41 <mar77a> now i'm thinking of a nice solution
15:43:44 <byorgey> oh ok, sorry =)
15:43:47 <mar77a> np
15:43:55 <dmwit> trimExt = reverse . trimExt' . reverse; trimExt' ('i':'n':'i':'.':h) = h
15:43:56 <vixey> trimExt = reverse . removePrefixes (words . reverse ".ini .txt") . reverse
15:44:25 <vixey> removePrefixes prefixes word = if word starts with any of the prefixes remove them else don't
15:44:26 <vixey> :)
15:44:42 <mar77a> there's remove prefixes? *_*
15:44:45 <mar77a> :t removePrefixes
15:44:46 <lambdabot> Not in scope: `removePrefixes'
15:44:50 <vixey> no there is not you have to write it
15:44:55 <mar77a> almost trick me
15:44:58 * matthew-_ heads to bed. Night 'all
15:45:06 <mar77a> i'll just wrote remove suffix
15:45:15 <mar77a> write
15:45:32 <vixey> mar77a: Sounds harder and less efficient but ok
15:45:39 <byorgey> dons: hm, that link says applications closed 06 June
15:45:48 <byorgey> dons: is that date wrong?
15:45:57 <vixey> mar77a: any reason why ?
15:45:59 <dmwit> > let zipDrop xs ys = if xs `isPrefixOf` ys then drop (length xs) ys else ys in zipDrop "ini." "ini.lairucreM"
15:46:01 <lambdabot>  "lairucreM"
15:46:50 <dons> byorgey: hmm, it might be past then :( i just saw it on the site.
15:46:53 <mar77a> is there a "dropfromend"
15:47:14 <vixey> mar77a: Did the idea of reversing and taking off the start not make sense?
15:47:17 <mar77a> like a take with negative index
15:47:23 <mar77a> yes vixey but i'm always afraid of reversing lists
15:47:31 <vixey> mar77a: Why?
15:47:45 <mar77a> because my dad died while reversing one... it's a trauma
15:47:55 <dmwit> You won't possibly notice the time it takes unless your paths are, like, way more monstrous than they are.
15:47:57 <vixey> mar77a: ...
15:47:57 <mar77a> back in the day reversing a list would involve high risk card punching
15:48:29 <vixey> trying to help people is bad for my health
15:48:30 <mar77a> doesn't reversing a list go through it and copies it in reverse order
15:49:10 <mar77a> ah whatever i'll go with the reverse solution
15:49:43 <ooxwo> what happened to the 'unique' function?  did it get renamed without my knowing it?
15:49:43 <dmwit> mar77a: Dropping from the end requires at least one pass (to identify the end) and probably two (the second one copies the beginning).
15:49:52 <vixey> ooxwo: maybe it's called nub
15:49:59 <dmwit> So you might as well let "reverse" be your two passes, and use the high-level functions.
15:50:12 <ooxwo> > nub [1, 3, 2, 4, 5, 5, 2,3, 3, 1, 4, 1]
15:50:14 <lambdabot>  [1,3,2,4,5]
15:50:17 <mar77a> hmm
15:50:27 <ooxwo> thanks vixey!
15:51:35 <mar77a> bah
15:51:41 <mar77a> now i get a "cannot construct infinite list"
15:51:44 <mar77a> allow me to paste
15:51:47 <mar77a> trimExt h = (reverse . trimExt' . reverse) h
15:51:47 <mar77a> trimExt' ("ini.",h) = h
15:51:47 <mar77a> trimExt' ("txt.",h) = h
15:51:48 <mar77a> trimExt' h = h
15:52:09 <mar77a> oh
15:52:10 <mar77a> typo
15:52:11 <mar77a> heh
15:52:13 <dmwit> One: (,) /= (:)
15:52:24 <dmwit> Two: ("ini.":) does not have the type you are thinking it does.
15:52:30 <mar77a> oh right
15:52:32 <mar77a> cause it has a :[]
15:52:33 <mar77a> right
15:52:39 <Saizan> ?hoogle splitExtension
15:52:41 <lambdabot> System.FilePath.Windows.splitExtension :: FilePath -> (String, String)
15:52:41 <lambdabot> System.FilePath.Posix.splitExtension :: FilePath -> (String, String)
15:52:41 <lambdabot> System.FilePath.Windows.splitExtensions :: FilePath -> (FilePath, String)
15:53:01 <Saizan> > System.FilePath.splitExtension "foo.ini"
15:53:06 <lambdabot>   Not in scope: `System.FilePath.splitExtension'
15:53:24 <mar77a> excellent, works now
15:53:31 <twifkak> > System.FilePath.Posix.splitExtension "foo.ini"
15:53:32 <lambdabot>   Not in scope: `System.FilePath.Posix.splitExtension'
15:56:04 <newsham> ?type splitWhile
15:56:05 <lambdabot> Not in scope: `splitWhile'
15:56:26 <newsham> ?let splitWhile p xs = (takeWhile p xs, dropWhile p xs)
15:56:27 <lambdabot> Defined.
15:56:41 <newsham> ?let unfoldrp p f = unfoldr $ \x -> guard (p x) >> f x
15:56:48 <lambdabot> Defined.
15:57:17 <ddarius> Wonderful.  A ps to ps converter.  Just what I needed.
15:57:21 <newsham> ?let splitList ch = let f = (second (drop 1)) . (splitWhile (/= ch)) in unfoldrp (not.null) (return.f)
15:57:22 <lambdabot> Defined.
15:57:31 <newsham> > splitList '.' "foo.ini"
15:57:33 <lambdabot>  ["foo","ini"]
15:57:36 <plutonas> i'm folliwing this online book on haskell, so i put this line in a file
15:57:57 <dmwit> newsham: splitWhile seems nice
15:58:03 <plutonas> sumList (x:xs) = x + sumList xs
15:58:08 <newsham> i think splitWhile is in some versions of the lib?
15:58:08 <plutonas> and get an error when loading the file
15:58:19 <dmwit> plutonas: What error?
15:58:19 <plutonas> it's exactly like this in the book, any idea?
15:58:26 <mar77a> is there a function to remove duplicate copies in the lib?
15:58:38 <dmwit> plutonas: (You'll want a base case, but that shouldn't give an error.)
15:58:41 <plutonas> dmwit: parse error on input SumList
15:58:51 <dmwit> plutonas: You must lower-case your function names.
15:58:53 <plutonas> dmwit: the base case is the next line
15:58:54 <newsham> plutonas: that doenst say what "sumList []" is equal to
15:59:10 <plutonas> newsham: it's the next line, it's like this in the book too
15:59:23 <plutonas> dmwit: sorry it's sumList
15:59:24 <dmwit> plutonas: To be more precise: the first letter of function names must be lower-case.
15:59:33 <newsham> > let sumList (x:xs) = x + sumList xs; sumList [] = 0 in sumList [1,2,3]
15:59:35 <lambdabot>  6
15:59:38 <dibblego> plutonas, please post the entire source file to http://hpaste.org
15:59:38 <plutonas> it's lower-case, i did it wrong
15:59:42 <plutonas> in the copying
15:59:47 <plutonas> k
15:59:56 <dmwit> plutonas: Paste the whole error, too, please.
15:59:57 <newsham> plutonas: hpaste.org is helpful.  can you paste your code and the error?
16:00:06 <plutonas> ok doing it
16:00:33 * dmwit rrrrrrrrrrrrr in Firefox
16:01:06 <Botje> GHC should have an option to paste source file + error directly to hpaste.
16:01:16 <dmwit> Vim does. ;-)
16:01:21 <dmwit> Well, not the error.
16:01:28 <hpaste>  plutonas pasted "file" at http://hpaste.org/8734
16:01:30 <Botje> optionally leave an email adress back and get the fix in your mailbox!
16:01:31 <byorgey> emacs does too.
16:01:51 <newsham> plutonas: and the error?
16:01:54 <plutonas> couldn't paste the error, because my X's mouse pasting doesn't work
16:01:54 <Botje> just label the post "i'm pretty sure haskell cannot do X, anyone think otherwise?"
16:01:56 <dmwit> plutonas: De-indent the data lines.
16:02:03 <plutonas> and can't right click and copy in terminal
16:02:11 <plutonas> dmwit: ?
16:02:20 <dibblego> no spaces before the 'data' declarations
16:02:24 <plutonas> oh
16:02:26 <dmwit> plutonas: You have whitespace in front of the two "data" declarations.  Remove it.
16:02:26 <newsham> plutonas: indentation is significant in haskell sources
16:02:40 <twifkak> plutonas: download 'xsel'
16:02:51 <plutonas> it's like in python?
16:02:59 <plutonas> is there a rule to know what to indent?
16:03:02 <newsham> similar w/ indentation
16:03:04 <dmwit> It's similar.
16:03:08 <dmwit> Yes, there is a rule.
16:03:20 <dmwit> Let's see here...
16:03:22 <dmwit> ?where report
16:03:22 <lambdabot> http://www.haskell.org/onlinereport/
16:03:34 <hackage> Uploaded to hackage: hCsound 0.2
16:03:41 <plutonas> works now thanks
16:03:46 <byorgey> the rule is: the indentation of the first line in a block determines the indentation for the block.  the first line which is indented less, closes the block.
16:04:05 <dmwit> plutonas: Section 2.7 of the report is on layout.
16:04:09 <byorgey> so the first 'data' line determined the indentation for the rest of the file, and since the sumList definition was indented less...
16:04:12 <plutonas> thanks a lot
16:04:19 <plutonas> i see
16:04:27 <plutonas> didn't know that, but i'm a bit dissapointed
16:04:40 <plutonas> it was what i considered the worse "feature" in python
16:04:48 <plutonas> and now i find it again...
16:04:49 <dmwit> If you prefer {;} notation, that is also available.  But people will look at you oddly. =)
16:04:55 <byorgey> plutonas: hehe, well, it's actually optional in Haskell
16:04:59 <newsham> you are not required to use indentation
16:05:20 <mar77a> you get used to it quick... at least to haskell's
16:05:27 <mar77a> i remember it being one of the reasons i dropped python initially
16:05:32 <plutonas> newsham: you mean i can just write without indentation at all
16:05:53 <plutonas> or i can somehow set it to not have rules and i can indent as i like?
16:05:55 <byorgey> plutonas: yes, if you use { } to enclose blocks and ; in between expressions
16:06:01 <plutonas> aha
16:06:18 <byorgey> indentation is just a shorthand to avoid writing explicit { ; ; } everywhere
16:06:36 <plutonas> makes sense... but whitechars shouldn't be part of programs in my opinion
16:06:40 <dmwit> But please, give layout a chance.
16:06:50 <plutonas> anyway thanks, will read the layout section
16:06:57 <mar77a> i see they weren't any humble picking a name :p
16:06:58 <dmwit> If you do decide to give it a chance, be careful.
16:07:00 <dmwit> You might like it.
16:07:06 <newsham> > do { x <- readFile "/etc/passwd"; writeFile "/tmp/copy" x }
16:07:08 <lambdabot>  <IO ()>
16:07:09 <vixey> plutonas: it's not as bad as python
16:07:18 <newsham> see, no indents
16:07:40 <newsham> vixey is an antipythonist
16:07:47 <newsham> antipythonista?
16:08:30 <plutonas> dmwit: i'll give it a chance
16:08:35 <byorgey> pythonosta?
16:08:43 <mar77a> how would i write the typical "enter an option" loop in haskell?
16:09:03 <dmwit> atheonista?
16:09:03 <mar77a> i'd usually go with while(exitcondition){ ask for options/process }
16:09:04 <newsham> getopt stuff?
16:09:15 <dmwit> :t forever
16:09:17 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
16:09:34 <mar77a> and how do i exit slash break ?
16:09:56 <dmwit> ^C ;-)
16:10:04 <mar77a> :(
16:10:07 <dmwit> :t exitWith
16:10:08 <lambdabot> Not in scope: `exitWith'
16:10:13 <mar77a> ah
16:10:22 <dmwit> That's one possibility.
16:10:22 <byorgey> mar77a: it's fairly typical to have a function which prompts the user, calls any other functions which might need to be called, and then (possibly) calls itself recursively
16:10:31 <wuxia> i'm running a ray tracer in haskell ... please givbe me crazy optimixation flags :-)
16:10:32 <byorgey> that would deal with exit/breaking more elegantly.
16:10:34 <dmwit> That's the other possibility. =)
16:10:43 <vixey> -funroll-loops
16:10:44 <mar77a> i thought about that first
16:10:49 <dmwit> wuxia: -O2 ?
16:11:02 <mar77a> but i was worried about efficency
16:11:06 <newsham> > let loop = do { putStr "Enter Age or zero: "; x <- read <$> getLine; when (x /= 0) (do { print x; loop }) } in loop
16:11:08 <lambdabot>  <IO ()>
16:11:18 <byorgey> mar77a: nope, it's perfectly efficient
16:11:37 <mar77a> it seems haskell compilers are pretty good at optimizing
16:11:41 <byorgey> mar77a: in particular it should be tail-call optimized so it won't use tons of stack or anything
16:11:46 <plutonas> mar77a: i'm new to haskell, but about recursion, as long as you don't pass data from one call to the next it's as efficient as iterating
16:11:52 <byorgey> and garbage collection will take care of the rest
16:12:03 <mar77a> is what plutonas said correct
16:12:09 <plutonas> it's tail-recursion as byorgey said
16:12:16 <mar77a> smooth
16:12:17 <vixey> it's correct in Haskell
16:12:20 <vixey> not all languages
16:12:24 <byorgey> plutonas: indeed.  even if you do pass data from one call to the next, it can still be efficient
16:12:27 <mmorrow> wuxia: -O2 -fliberate-case-threshold50 -funfolding-use-threshold50
16:12:38 <mmorrow> Peaker: ping
16:12:38 <plutonas> byorgey: hm
16:12:45 <byorgey> as long as you don't need to do anything with the return value
16:12:55 <plutonas> ok true
16:12:56 <mmorrow> Peaker: did you see that @tell?
16:13:15 <plutonas> as long as you don't have to go back through the calls, is that what you mean?
16:13:21 <plutonas> for example to construct the solution
16:13:24 <byorgey> plutonas: right
16:13:42 <plutonas> true then
16:13:44 <plutonas> :)
16:15:30 <Saizan> beware accumulating parameters though :)
16:17:32 <mmorrow> > let f n [] = n ; f n (x:xs) = f (n+1) xs in f 0 [1..1000000]
16:17:35 <lambdabot>  1000000
16:17:43 <mmorrow> > let f n [] = n ; f n (x:xs) = let n' = n+1 in n' `seq` f n' xs in f 0 [1..1000000]
16:17:45 <lambdabot>  1000000
16:17:58 <mmorrow> ha, the first one overflow in my ghci
16:18:04 <mmorrow> overflows
16:18:14 <mmorrow> > let f n [] = n ; f n (x:xs) = f (n+1) xs in f 0 [1..10000000]
16:18:19 <lambdabot>  Tried to use too much memory
16:18:24 <mmorrow> > let f n [] = n ; f n (x:xs) = let n' = n+1 in n' `seq` f n' xs in f 0 [1..10000000]
16:18:24 <Deadnote> hello!
16:18:28 <lambdabot>  Tried to use too much memory
16:18:37 <wuxia> i  comp8ile my ray tracer with: ghc -prof -auto-all -O2 -fliberate-case-threshold50 -funfolding-use-threshold50 --make Vector.hs Image.hs Intersect.hs RayTracer.hs -o raytrace ; I run it wsith ./rtrace -p RTS; then I cat raytrace.prof, and it's empty -- what am i doing wrong?
16:18:37 <mar77a> urgh i hate when i try to think in haskell and fail
16:18:43 <mar77a> now i need a break cause my head hurts
16:19:20 <Deadnote> i've just graduated and did a cource in fp with miranda as the language we used
16:19:21 <mmorrow> wuxia: is there a "main" function in any of those .hs?
16:19:34 <Deadnote> are all the other languages easy enough to pick up
16:19:36 <wuxia> there is
16:19:43 <allbery_b> wouldn't that fail to compile?
16:19:49 <mmorrow> wuxia: if you're using --make, you only need to specify the file with main
16:19:51 <mar77a> i heard haskell grabbed a lot from miranda, Deadnote
16:19:56 <mar77a> today is your lucky day
16:19:57 <allbery_b> (I get something like "no main function defined")
16:20:05 <vixey> Deadnote: cool
16:20:09 <vixey> Deadnote: miranda is very much like haskell
16:20:20 <vixey> oh maybe I was thinking of gofer
16:20:20 <Deadnote> what's the jobs market like for fp then?
16:20:28 <allbery_b> haskell is rather a lot like a miranda++
16:20:29 <wuxia> ghc -prof -auto-all -O2 -fliberate-case-threshold50 -funfolding-use-threshold50 --make RayTracer.hs -o raytrace <-- new cmd line
16:20:34 <vixey> I'm not sure if mirada is quite as similar but I think haskell was inspired by it...
16:20:44 <mmorrow> wuxia: did it work?
16:21:01 <mar77a> Deadnote: http://www.haskell.org/haskellwiki/A_brief_introduction_to_Haskell
16:21:03 <lambdabot> Title: A brief introduction to Haskell - HaskellWiki, http://tinyurl.com/y6cbnf
16:21:23 <wuxia> mmorrow: compiles and runs fine; does not gibve me profiling info tyeough
16:21:26 <vixey> I don't think they want an introduction...
16:21:38 <Deadnote> ta
16:21:47 <mar77a> it's a bit more than an introduction
16:21:52 <allbery_b> I think it was like miranda -> ideas went into gofer -> matured into haskell
16:22:54 <ddarius> Miranda preceded Haskell by quite a bit.  Gofer was a experimental variant of Haskell including things like constructor classes and multiparameter type classes most of whose ideas got folded back into Haskell.
16:23:02 <Deadnote> the syntax looks almost identical
16:24:04 <Deadnote> so does anyone employ functional programmers these days
16:24:23 <ddarius> Yes
16:24:24 <Deadnote> is it too high level for most tasks?
16:24:34 <ddarius> How could something be "too high level"?
16:24:34 <allbery_b> @go site:haskell.org haskell in industry
16:24:36 <lambdabot> http://www.haskell.org/haskellwiki/Haskell_in_industry
16:24:36 <lambdabot> Title: Haskell in industry - HaskellWiki
16:24:41 <ddarius> @where jobs
16:24:42 <lambdabot> I know nothing about jobs.
16:24:49 <ddarius> Freakin' lambdabot
16:24:52 <idnar> is Dylan still alive?
16:25:16 <ddarius> @where+ jobs http://www.haskell.org/haskellwiki/Jobs
16:25:16 <lambdabot> Done.
16:25:21 <ddarius> idnar: Probably.
16:25:26 <mar77a> ddarius: not providing low level ways?
16:27:07 <Deadnote> development speed with an fp language is huge i'd imagine, but from what i've been told there is a resistance to the paradigm
16:27:39 <vixey> you can't count how many bytes the procedure you've written free()'s
16:27:39 <dons> "After viewing "Real World Haskell" , 8% buy this alternative "JavaScript: The Good Parts""
16:27:44 <Deadnote> well that should go unqualified, what i meant is that, you cant write more faster
16:27:45 <vixey> that's why there is resistance
16:27:47 <dons> should i cry a little?
16:28:18 <idnar> dons: eeek
16:28:22 <__pao__> ok... I got my --prefix customized ghc 6.8.3 on my mac
16:28:23 <Deadnote> vixey: i dont understand?
16:28:27 <__pao__> ghci is working
16:28:38 <__pao__> but ghc cannot link to gmp
16:29:11 <__pao__> it seems that /opt/local/lib is not included in library paths...
16:29:15 <__pao__> suggestions?
16:29:19 <mmorrow> Deadnote: http://code.haskell.org/~morrow/code/haskell/misc/Call.html
16:29:43 <mmorrow> http://code.haskell.org/~morrow/code/haskell/misc/fib.html
16:30:45 * __pao__ thinks this is a "bug" of ghc mac binary...
16:30:46 <Deadnote> mmorrow: is that a program?
16:31:04 <mmorrow> Deadnote: yes! :)
16:31:33 <mmorrow> Deadnote: which one are you refering to? fib or Call
16:31:42 <Deadnote> call
16:32:05 <mmorrow> Deadnote: well, i guess it's a "library" or whatever since it has no main
16:32:14 <Deadnote> the highlighting is burning my retinas
16:32:28 <mmorrow> haha, HsColour's default i'm afraid
16:32:40 <mmorrow> but HsColour -css allow you to tweak it to your desire
16:32:45 <Deadnote> so can i ask why you showed that to me?
16:33:04 <mmorrow> re: is functional programming too high-level
16:33:13 <Deadnote> ok
16:33:18 <mmorrow> no, you can do anything you can do in C, and more
16:33:34 <Deadnote> and about a thousand times faster
16:33:43 <Deadnote> my professor
16:33:47 <vixey> no not 1000x faster
16:34:02 <mmorrow> well, depends if he's talking about dev time or running time
16:34:07 <SamB> vixey: it depends on if he's talking about writing or runtime
16:34:08 <__pao__> -L/opt/local/lib flag to ghc did the trick
16:34:09 <Deadnote> dev time
16:34:12 <Deadnote> not runtime!
16:34:14 <dibblego> is your professor one of the idiots who put up irrational resistance?
16:34:42 <SamB> yeah, you only get like 2x the speed ;-P
16:34:45 <__pao__> but it should be included by default IMVHO
16:34:53 <mmorrow> SamB: heh
16:34:55 <Deadnote> so how "fast" is a program written in an fp lang opposed to a low level lang
16:34:56 <SamB> __pao__: what the heck is /opt ?
16:34:57 <dibblego> Deadnote, does your professor have any evidence for this claim?
16:35:07 <vixey> It's not going to be 1000x whatever you're talking about
16:35:12 <Deadnote> no no, i was exagerating
16:35:14 <__pao__> SamB: macports root dir (mac os x)
16:35:28 <vixey> oh
16:35:29 <Deadnote> an order of magniture at most
16:35:32 <vixey> ok
16:35:40 <SamB> vixey: it depends on how badly the need to remove all polymorphism kills you
16:35:48 <dibblego> Deadnote, my experience is that a *trained* FP user will easily beat a *trained* C user in development time
16:36:22 <vixey> that's likely because C is only useful for a tiny tiny fragment of programming tasks
16:36:35 <Deadnote> so when we start building large software systems, what can we do to organise our code?
16:36:44 <dibblego> Deadnote, it is also my experience that a poor FP user versus a poor C user may do worse in the case of FP
16:36:46 <SamB> particularly since in some cases the trained FP user might just say "meh, this program is so trivial I'll just do it in C because otherwise the FFI will just make it longer"
16:38:42 <dibblego> a bad car driver is sometimes better off just walking to their destination
16:38:53 <Deadnote> no i understand
16:39:18 <Deadnote> so is it possible to write a large scale software project in an fp lang?
16:39:37 <dibblego> what is "large scale"?
16:39:37 <SamB> it is best to avoid the existance of large-scale software projects
16:39:38 <vixey> yes
16:39:55 <dibblego> functional programming is all about taking smaller programs and making larger ones
16:40:18 <Deadnote> do you mean it makes it more complicated?
16:40:25 <SamB> Deadnote: heck no
16:40:31 <Deadnote> in my mind they're so short
16:40:32 <dibblego> no, the contrary; I mean it makes the term "large scale" meaningless
16:40:35 <SamB> we were talking about composition
16:40:52 <vixey> @src head
16:40:52 <lambdabot> head (x:_) = x
16:40:53 <lambdabot> head []    = undefined
16:40:59 <vixey> @src undefined
16:41:00 <lambdabot> undefined =  error "Prelude.undefined"
16:41:06 <vixey> @src error
16:41:06 <lambdabot> error s = throw (ErrorCall s)
16:41:13 <vixey> Deadnote: like that ^
16:41:18 <Deadnote> oh yeah
16:41:28 <vixey> everything is made of parts made up of parts..
16:41:31 <Deadnote> i've written quicksort and other algorithms
16:41:37 <Deadnote> they're just a line
16:41:42 <Deadnote> so simple
16:41:49 <Deadnote> i understand how powerful it is
16:41:50 <SamB> that wasn't REALLY quicksort
16:41:55 <dibblego> that the syntax is short is not the important part; the important part is gluing of smaller parts to make the larger part
16:42:22 <dibblego> Haskell just happens to have nice syntax too - it's designed by clever people
16:42:32 <SamB> though others here will claim that quicksort is about asymptotic complexity, I really must stick with my position that that isn't what quicksort means ;-)
16:42:47 <Deadnote> you're talking worst case
16:42:57 <Deadnote> everyone gabs on about this
16:43:04 <Deadnote> it's fast in average case
16:43:14 <Deadnote> although there hasn't been any research into average case
16:43:20 <SamB> worst, average, whatever -- real quicksort mutates arrays ;-)
16:43:32 <dmwit> Hey #haskell!
16:43:38 <dmwit> http://www.ocf.berkeley.edu/~wwu/riddles/cs.shtml
16:43:39 <lambdabot> Title: [ wu :: riddles(cs) ]
16:43:50 <dmwit> grep for "Excel"
16:43:55 <dmwit> First person to solve it correctly wins.
16:44:47 <mar77a> chr - 40?
16:44:52 <SamB> mutating arrays tends to take more than one line of Haskell code
16:44:59 <mar77a> i win the "I guarantee that your first solution will fail" way award
16:45:40 <dmwit> mar77a: Especially since you're converting in the wrong direction!
16:45:52 <mar77a> ops
16:45:57 <wuxia> @hoogle mesh
16:45:58 <lambdabot> No matches found
16:47:16 <Deadnote> so what are you saying dibblego is that you can write application software with fp
16:47:23 <Deadnote> i.e. something useful
16:47:38 <vixey> huh ? You are given a pointer to the middle node of a singly linked list. Delete that node.
16:47:45 <vixey> how is that possible ?
16:47:56 <vixey> set it's value to the next ?
16:48:05 <vixey> that's kind of lame
16:48:16 <wuxia> anyone know of a good library for constructive solid goemetry / solid modelling in haskell? there seems to be one 'good' result from google, but the lihnk is brokien;
16:48:53 <qwr> vixey: copy part of the list?
16:49:14 * qwr can't imagine any other solution with immutable lists
16:49:30 <dmwit> qwr: They're probably not immutable.
16:49:45 <SamB> it's impossible with immutable lists
16:50:30 <SamB> *this = *(this->next);
16:50:36 <vixey> oh just mutate the pointer :P
16:50:47 <SamB> vixey: can't do that
16:50:54 <qwr> SamB: when list is not given, then yeah impossible ;)
16:50:57 <SamB> the pointer is presumably immutable
16:51:07 <vixey> "you are given a pointer to ..."
16:51:11 <SamB> which is to say, presumably you've been given a copy
16:51:13 <vixey> I can what I want with it
16:51:16 <SamB> of the pointer
16:51:58 <SamB> which won't alter anything except the arument in your own stack frame
16:52:44 <dmwit> ptr->value = ptr->next->value
16:52:51 <dmwit> ptr->next = ptr->next->next
16:53:00 <dmwit> Seriously, why all the discussion?
16:53:15 <dmwit> Also: the prize is still waiting to be won! =)
16:53:34 <qwr> dmwit: 02:47 < vixey> set it's value to the next ?
16:53:36 <vixey> dmwit: "Excel" is not on that page
16:54:04 <dmwit> vixey: ...it is here. *shrug*
16:54:21 <mar77a> yeah i found it
16:54:29 <mar77a> lets see if i can solve this in less than 50 minutes
16:54:44 <hpaste>  dmwit pasted "Excel problem" at http://hpaste.org/8735
16:54:49 <dmwit> mar77a: Less than 50??
16:54:56 <dmwit> mar77a: You should be able to do it in less than 10.
16:54:57 <SamB> @let alphabet = ['A'..'Z']
16:54:58 <lambdabot> Defined.
16:55:31 <dmwit> mar77a: Of which probably the first 2 are doing it the obvious, wrong way. =)
16:55:38 <mar77a> ;(
16:56:17 <vixey> @hoogle showIntInBase
16:56:17 <lambdabot> No matches found
16:56:24 <dmwit> :t showIntAtBase
16:56:25 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
16:56:28 <vixey> @hoogle showIntAtBase
16:56:31 <lambdabot> Numeric.showIntAtBase :: Integral a => a -> (Int -> Char) -> a -> ShowS
16:56:41 <vixey> @hoogle showInt
16:56:41 <vixey> :/
16:56:41 <lambdabot> Numeric.showInt :: Integral a => a -> ShowS
16:56:41 <lambdabot> Numeric.showIntAtBase :: Integral a => a -> (Int -> Char) -> a -> ShowS
16:57:07 <SamB> @let excelSim n = (alphabet ++ liftM2 (\x,y -> [x,y]) alphabet alphabet ++ "AAA") ! n
16:57:07 <lambdabot>  Parse error
16:57:08 <vixey> @let excel = showIntAtBase 26 (!!alphabet)
16:57:09 <lambdabot> Couldn't match expected type `[a]' against inferred type `Int'
16:57:23 <SamB> @let excelSim n = (alphabet ++ liftM2 (\x y -> [x,y]) alphabet alphabet ++ "AAA") ! n
16:57:24 <lambdabot> Couldn't match expected type `[Char]' against inferred type `Char'
16:57:27 <vixey> > let excel = showIntAtBase 26 (!!alphabet) 701
16:57:28 <lambdabot>  Parse error at end of input
16:57:35 <SamB> @let excelSim n = (map return alphabet ++ liftM2 (\x y -> [x,y]) alphabet alphabet ++ "AAA") ! n
16:57:36 <lambdabot> Couldn't match expected type `[Char]' against inferred type `Char'
16:57:39 <vixey> > showIntAtBase 26 (!!alphabet) 701
16:57:40 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Int'
16:57:54 * dmwit chuckles gleefully
16:58:26 <SamB> @let excelSim n = (map return alphabet ++ liftM2 (\x y -> [x,y]) alphabet alphabet ++ ["AAA"]) ! n
16:58:26 <lambdabot> Couldn't match expected type `Array i e'
16:58:32 <SamB> @let excelSim n = (map return alphabet ++ liftM2 (\x y -> [x,y]) alphabet alphabet ++ ["AAA"]) !! n
16:58:34 <lambdabot> Defined.
16:58:40 <vixey> > showIntAtBase 26 (alphabet!!) 701
16:58:40 <dmwit> Also, SamB: those inputs are *samples only*, and not a specification.  You have to be prepared to deal with any positive input. ;-)
16:58:42 <SamB> > excelSim 27
16:58:42 <lambdabot>  <[Char] -> [Char]>
16:58:43 <lambdabot>  "AB"
16:58:49 <vixey> > showIntAtBase 26 (alphabet!!) 701 ""
16:58:51 <lambdabot>  "BAZ"
16:59:39 <dmwit> SamB: Though I like your approach a lot.  I think it can be saved...
17:00:10 <vixey> > replicateM 26 alphabet
17:00:13 <lambdabot>  ["AAAAAAAAAAAAAAAAAAAAAAAAAA","AAAAAAAAAAAAAAAAAAAAAAAAAB","AAAAAAAAAAAAAAAA...
17:00:48 <vixey> > (map (flip replicateM alphabet) [1..]) !! 701
17:00:50 <lambdabot>  ["AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA...
17:01:01 <SamB> > concatMap (`replicateM` alphabet) [0..]
17:01:03 <lambdabot>  ["","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R",...
17:01:09 <SamB> > concatMap (`replicateM` alphabet) [1..]
17:01:10 <vixey> > (flip replicateM alphabet) =<< [1..]) !! 701
17:01:10 <lambdabot> Unbalanced parentheses
17:01:11 <lambdabot>  ["A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S"...
17:01:15 <vixey> > (flip replicateM alphabet =<< [1..]) !! 701
17:01:17 <lambdabot>  "ZZ"
17:01:25 <SamB> @let excelSim2 n = concatMap (`replicateM` alphabet) [1..] !! n
17:01:25 <lambdabot> Defined.
17:01:26 <dmwit> vixey: Prize, sir!
17:01:44 <dmwit> Next time I see you, I'll buy you a drink. =)
17:01:51 <SamB> dmwit: why don't I get one too?
17:02:02 <dmwit> Because you weren't first?
17:02:05 <Zao> For bonus credits, explain to us mortals why the solution does what it does.
17:02:12 <vixey> umm
17:02:32 <SamB> > concatMap (`replicateM` "AB") [1..]
17:02:34 <lambdabot>  ["A","B","AA","AB","BA","BB","AAA","AAB","ABA","ABB","BAA","BAB","BBA","BBB"...
17:02:34 <dmwit> SamB: Never mind, you were first with the idea.  You may also have a prize. =)
17:02:56 <SamB> dmwit: depends which idea
17:02:58 <vixey> replicateM 2 "xyz" = do a <- "xyz" ; b <- "xyz" ; c <- "xyz" ; return [a,b,c]
17:03:01 <vixey> > do a <- "xyz" ; b <- "xyz" ; c <- "xyz" ; return [a,b,c]
17:03:04 <lambdabot>  ["xxx","xxy","xxz","xyx","xyy","xyz","xzx","xzy","xzz","yxx","yxy","yxz","yy...
17:03:07 <SamB> it seems me and vixey were stealing ideas and code left and right ;-P
17:03:09 <vixey> s/2/3/
17:03:12 <dmwit> Zao: replicateM n alphabet will produce all the sequences of length n containing letters from alphabet.
17:03:42 <dmwit> Zao: Now, all you have to do is sequence together all those sequences of length 1, 2, 3, ...
17:03:43 <schme_> #bdsmforum.se over on bdsm-net ?
17:03:50 <schme_> hah!
17:04:08 <SamB> schme_: what???
17:04:12 * Saad__ has a question yet again. For the following code data Item a = Item { item :: a }  | ItemWithKey { key :: Key, item :: a }. Would it be possible to make let it choose wheter a would need to be an instance of Ord should you choose either constructor?
17:04:21 <schme_> SamB: Inside joke. Nevermind :)
17:04:27 <vixey> no it's #haskell, as similar as they may seem
17:04:44 <SamB> schme_: inside joke for what value of inside?
17:04:48 <dmwit> > showIntAtBase 26 (alphabet!!) 26 "" -- why the obvious way fails
17:04:50 <lambdabot>  "BA"
17:05:32 <Saad__> Or would I be better of creating 2 data types?
17:05:33 <dmwit> Saad__: I'm not sure I understand.
17:06:12 <schme_> SamB: As in the opposite of outside :)
17:06:57 <Saad__> dmwit, Like lets say I have (Item foo) and (ItemWithKey 1 foo), if I choose the first constructor then a must have and instance of Ord, but if I choose the second there is no need
17:07:34 <schme_> hackage: Well good that I am in the right place then :)
17:08:12 <SamB> schme_: I was hoping you would give a partial specification of a predicate that is not etymologically obvious...
17:08:22 <vixey> schme_: you are talking to an IRC bot
17:08:52 <schme_> SamB: Wow.. I need to google half of those words. I'll get back to you on that :)
17:09:21 <dmwit> :t insert
17:09:22 <lambdabot> forall a. (Ord a) => a -> [a] -> [a]
17:10:52 <SamB> schme_: I really hope you are measuring "half" by number of characters ;-)
17:11:14 <vixey> lol
17:11:32 <schme_> Oh now I get it.
17:12:47 <dmwit> ?oeis 4 8 9 16 25 27 32
17:12:47 <lambdabot> Perfect powers: m^k where m is an integer and k >= 2.
17:12:47 <lambdabot> [1,4,8,9,16,25,27,32,36,49,64,81,100,121,125,128,144,169,196,216,225,243,256,...
17:14:50 <dmwit> > let merge ((x:xs):xss) = x : merge (insert xs xss); perfectPowers = map head . group . merge $ liftM2 (^) [2..] [2..] in perfectPowers
17:14:51 <lambdabot>   add an instance declaration for (Num [a], Enum [a])
17:16:13 <Saad__> Or even if there was a way to do the following -> data Item a b = Item { item :: (somehow set b to be the same as a) } | ItemWthKey { key :: b, item :: a }
17:17:12 <Saad__> Although I'm thinking its not possible :)
17:18:21 <dmwit> > let merge ((x:xs):xss) = x : merge (insert xs xss); perfectPowers = map head . group . merge $ [[m ^ n | m <- [2..]] | n <- [2..]] in perfectPowers
17:18:23 <lambdabot>  [4,8,9,16,25,27,32,36,49,64,81,100,121,125,128,144,169,196,216,225,243,256,2...
17:21:29 <dmwit> > liftM (flip liftM [2..] . (^)) [2..]
17:21:32 <lambdabot>  [[4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2621...
17:23:38 <dmwit> > map (flip map [2..] . (^)) [2..]
17:23:40 <lambdabot>  [[4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2621...
17:23:50 * dmwit grunts
17:24:03 <dmwit> liftM = map -- oh, duh
17:24:54 <Saad__> Actually I think I got it guys :)
17:32:32 <noecksit> @contains Int
17:32:32 <lambdabot> Unknown command, try @list
17:32:39 <noecksit> @list
17:32:39 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
17:33:57 <noecksit> @type Int
17:33:58 <lambdabot> Not in scope: data constructor `Int'
17:34:02 <mar77a> is there any way to ehm
17:34:13 <schme_> mar77a: Nope.
17:34:14 <mar77a> use replicate without the suffixing []
17:34:35 <noecksit> @instances Int
17:34:36 <lambdabot> Couldn't find class `Int'. Try @instances-importing
17:34:42 <noecksit> @instances int
17:34:43 <lambdabot> Couldn't find class `int'. Try @instances-importing
17:34:49 <noecksit> @instances Double
17:34:49 <lambdabot> Couldn't find class `Double'. Try @instances-importing
17:35:21 <noecksit> @help instances
17:35:21 <lambdabot> instances <typeclass>. Fetch the instances of a typeclass.
17:35:40 <noecksit> @instances Maybe
17:35:41 <lambdabot> Couldn't find class `Maybe'. Try @instances-importing
17:36:07 <noecksit> ok, how can i find the type classes that Int subclasses?
17:36:29 <dibblego> Haskell doesn't have subclassing
17:36:52 <drguildo> i think you want :info Int?
17:36:58 <noecksit> :info Int
17:37:05 <noecksit> @info Int
17:37:05 <lambdabot> Int
17:37:06 <drguildo> in ghci
17:37:17 <schme_> mar77a: How do you mean?
17:37:30 <mar77a> like
17:37:30 <drguildo> i don't know how you'd do it, or if you can do it, with lambdabot
17:37:36 <mar77a> replicate 5 'a' : []
17:37:46 <noecksit> drguildo : yeah, that'll work
17:38:01 <noecksit> i keep forgetting about that command actually
17:38:13 <dibblego> ?type replicate
17:38:14 <lambdabot> forall a. Int -> a -> [a]
17:38:16 <schme_> mar77a: I don't quite understand.. you want :  replicate 5 'a'   ?
17:38:19 <dibblego> > replicate 5 'a'
17:38:20 <lambdabot>  "aaaaa"
17:38:22 <drguildo> it's useful, worth remembering :-)
17:38:34 <EvilTerran> > [replicate 5 'a'] == replicate 5 'a' : []
17:38:35 <mar77a> i want to put more stuff after a replicate result
17:38:36 <lambdabot>  True
17:38:53 <EvilTerran> > replicate 5 'a' ++ ['A'..]
17:38:54 <dibblego> > replicate 5 'a' ++ " more stuff"
17:38:54 <mar77a> for example
17:38:56 <lambdabot>  "aaaaaABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\DEL\12...
17:38:56 <mar77a> AH
17:38:56 <lambdabot>  "aaaaa more stuff"
17:39:00 <mar77a> excellenyt
17:39:01 <EvilTerran> yes?
17:39:09 <EvilTerran> ?src (++)
17:39:10 <lambdabot> []     ++ ys = ys
17:39:10 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
17:39:10 <lambdabot> -- OR
17:39:10 <lambdabot> xs ++ ys = foldr (:) ys xs
17:39:10 <lambdabot> -- In lambdabot, this is generalised to:
17:39:11 <mar77a> i really
17:39:12 <lambdabot> (++) = mappend
17:39:15 <mar77a> forget about ++
17:39:17 <mar77a> for some reason
17:39:26 <mmorrow> @src concat
17:39:26 <lambdabot> concat = foldr (++) []
17:39:27 <mar77a> i keep thinking i have to get rid of the [] and replace it with :
17:42:53 <mmorrow> @src reverse
17:42:53 <lambdabot> reverse = foldl (flip (:)) []
17:45:30 <yitz> hmm, should be foldl', no?
17:46:01 <ddarius> foldl' makes no difference there
17:48:04 <dmwit> ?src foldl'
17:48:04 <lambdabot> foldl' f a []     = a
17:48:04 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
17:49:52 <yitz> ddarius: as stated, reverse will leave the old list unGCed, and build up a list of thunks the same size. seems like a waste.
17:51:03 <vixey> > head . reverse $ [undefined,87]
17:51:06 <lambdabot>  87
17:51:16 <vixey> > head . (foldl' (flip (:)) []) $ [undefined,87]
17:51:18 <lambdabot>  87
17:51:34 <vixey> that's not what I expected
17:51:54 <vixey> oh seq just forced WHNF
17:52:01 <vixey> ok that makes sense then
17:53:51 <MyCatVerbs> vixey: lemme guess, you only got the outer Cons ? :)
17:54:35 <yitz> the rule is: always use foldl' f xs instead of foldl f xs unless f is expensive or xs is guaranteed small.
17:54:35 <dmwit> MyCatVerbs: uh... I don't think that's right.
17:54:50 <dmwit> > length . (foldl' (flip (:)) []) $ [undefined,87]
17:54:52 <lambdabot>  2
17:54:58 <dmwit> All the conses are there waiting for consumption.
17:55:07 <dons> and the accumulator state is non-nested
17:56:32 <yitz> dons: was that in response to me or dmwit?
17:57:39 <dons> re. foldl', (general warning about using lazy tuples in the accumulator of foldl')
17:58:02 <MyCatVerbs> dmwit: I'm referring to what was evaluated, not what was available.
17:59:40 <dmwit> ah
18:00:06 <yitz> dons: mm, yeah. I guess what we need is foldl_deep'
18:00:28 <scodil> or strict tuple types
18:00:38 <dons> foldl-lazy, foldl-whnf, foldl-rnf
18:00:39 <ooxwo> is there any difference between a type signature f :: a -> b -> c and f :: a -> (b -> c)
18:00:49 <ooxwo> ?
18:00:51 <yitz> scodil: it's more than just tuples, anything with nested laziness.
18:01:07 <ooxwo> won't they always behave the same?
18:01:09 <dons> foldl-rnf is useful, since it can unbox into registers a tuple state
18:01:15 <dons> same thing, ooxwo
18:01:33 <scodil> yitz: right but tuples often get used with folds, like accumulating both a list and its length, or something
18:01:51 <dons> and almost always the user should be using :*:
18:02:03 <yitz> scodil: agreed.
18:02:10 <scodil> which is not standardized
18:02:17 <dons> http://hackage.haskell.org/packages/archive/strict/0.3.2/doc/html/Data-Strict-Tuple.html
18:02:20 <lambdabot> Title: Data.Strict.Tuple, http://tinyurl.com/6euguc
18:02:33 <dons> i should up date that to use :*: as uvector and ndp does
18:02:33 <scodil> nevermind then
18:02:46 <dons> the strict package should have element-strict lists too
18:03:07 <dons> also larger tuples
18:04:00 <scodil> there's shouldn't be any overhead from tuple nesting for the state arg of a strict fold, should there?
18:04:04 <scodil> will get specialized no?
18:04:06 <yitz> dons: this is starting to sound like it needs something more general
18:05:02 <dons> type annotations for strictness!
18:05:02 <scodil> I use nested tuples a lot and I see them get specialized often
18:05:10 <monochrom> :*)
18:05:19 <dons> scodil: they'll not be CPR-analysed if lazy
18:05:39 <dons> so you'll get (# Int, Int #) out, instead of (# Int#, Int# #)
18:05:59 <scodil> what's lazy? not the tuple nor the fold
18:06:14 <dons> foldl' isn't enough to remove space leaks from nested components
18:06:29 <dons> such as the usual mean :: [Double] -> Double functionn
18:06:58 <dons> since its only outermost strict, which isn't enough for the strictness analyser to deal with the pair's components
18:07:06 <scodil> foldl' (\ (a:*:b:*:c) d -> a+d:*:b+d:*:c+d) (0:*:0:*:0) [0..5]
18:07:11 <scodil> so that wouldn't get specialized?
18:07:22 <dons> a strict pair will be, yes.
18:07:32 <scodil> oh ok. that's what I meant
18:07:36 <dons> foldl' on the outer constructor, :*: on the inner parts
18:07:42 <dons> it fakes foldl'rnf
18:07:49 <scodil> the need for a strict n-tuple is not as great as for a lazy n-tuple
18:08:08 <dons> right. tuples > 3 are rare in general
18:08:53 <dons> also, CPR doesn't work on nested types, which means polymorphic tuples of whatever flavour cause register returns for unboxed values to fall down.
18:09:10 <scodil> ?
18:09:12 <dons> data T = T !Int !Int will have unboxed returns in a loop state
18:09:15 <dons> while (Int ,Int) won't
18:09:17 <jre2> how do you export an entire module you've imported?
18:09:29 <dons> module T ( module U ) where .. import module U ...
18:09:41 <scodil> I use strict nested tuples a lot and I see lots of specialization and unboxed tuple returns
18:09:44 <monochrom> module MyModule(module MyModule, module HisModule) where ...
18:09:51 <jre2> dons: thanks
18:10:08 <jre2> and monochrom
18:10:18 <ddarius> Given foldl' you can write foldl'rnf in terms of it.  In my opinion, foldl'rnf is an unnecessary and poor addition to the libraries.
18:13:30 <dons> scodil: see http://hackage.haskell.org/trac/ghc/ticket/2289
18:13:33 <lambdabot> Title: #2289 (Needless reboxing of values when returning from a tight loop) - GHC - Tra ...
18:56:53 <dolio> Max Boligbroke's work sounds pretty exciting.
18:57:03 <ddarius> Whose Max Boligbroke?
18:57:18 <dolio> The guy working on compiler plugins for GHC.
18:57:38 <ddarius> Bolingbroke
18:57:49 <dolio> Yeah, I can't type, apparently.
18:58:06 <ddarius> But yeah, the name didn't strike a bell with me.
18:58:34 <Saad__> I seek help yet again, I did a bit of googling around but couldn't find anything so I might aswell ask here, Is there some way to overload instances of classes. So like (Foo a) becomes an instance of Bar. But say I want to do something special for (Foo Int), is there any way to achieve this?
18:58:54 <dolio> Apparently he's got a plugin that makes everything strict, so that should put to rest the "why isn't there a switch that makes GHC strict" guy on comp.lang.functional.
18:59:33 <solrize_> what guy is that?  not jdh?
19:00:16 <dolio> No, although jdh made a post in that conversation.
19:00:35 <solrize_> that would be a pretty horrible switch, i sympathize with the idea of wanting easier strictness but adding a switch without making adjustments in the language would break everything in sight
19:00:39 <solrize_> vesa?
19:01:15 <dolio> Strictly speaking, he was asking about flipping the switch on a module-to-module basiss.
19:01:19 <solrize_> there are several people there who make the case for strictness but i don't remember anyone advocating doing it in such a brutal way as adding a strict to ghc :)
19:01:20 <vixey> it's a miserable thing to do to haskell code
19:01:21 <scodil> Saad__: I think that falls under overlapping instances.
19:01:30 <solrize_> i mean adding a switch
19:01:33 * vixey laughs at "strictly speaking"
19:01:44 <Saad__> Would that be possible to do or is that not possible?
19:02:02 <solrize_> disciple looks really interesting: http://www.haskell.org/haskellwiki/DDC
19:02:03 <vixey> Saad__: I think so.. I'm not sure how exactly though
19:02:04 <lambdabot> Title: DDC - HaskellWiki
19:02:09 <Mr_Awesome> well, lazily speaking, ...
19:02:32 <ddarius> Why isn't there a switch to make everything lazy in SML?
19:02:36 <solrize_> switching at the module level also sounds insane
19:02:40 <Saad__> vixey, thanks for telling me what it is. I can now atleast know what to search for :)
19:02:59 <solrize_> it really has to be managed in the type system
19:03:07 <vixey> ddarius: ..side effects
19:03:18 <dolio> ddarius: Because pervasive laziness with strictness annotations has time and time again been shown to be inferior to pervasive strictness with laziness annotations?
19:03:44 <dolio> At least, that seems to be the consensus in that thread.
19:04:02 <vixey> if you try to run code with mutables in a lazy way the mutations will happen at ranhom
19:04:06 <vixey> random*
19:04:11 <vixey> and the whole thing will not work as it should
19:04:25 <scodil> Saad__: http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html  section 8.6.3.3
19:04:27 <lambdabot> Title: 8.6. Class and instances declarations, http://tinyurl.com/245leb
19:04:34 <solrize_> spj had a presentation saying laziness was how haskell resisted the siren call of mutations
19:04:46 <Saad__> scodil, Yea, I found that soon after I found what what they were called. But thanks though :)
19:05:00 <UnorthodoxCodeFu> hallo, everyone... i am trying to get Yi up and running on my system... i've downloaded the latest version via darcs, installed the proper prereqs, got it to build, and copied examples/yi.hs to ~/.yi/... but when i start yi, i get 'could not find module 'Yi.Keymap.Keys': it is hidden'... am i missing a step in getting this working?
19:05:00 <solrize_> http://research.microsoft.com/~simonpj/papers/haskell-retrospective/HaskellRetrospective.pdf
19:05:02 <lambdabot> http://tinyurl.com/5hzq7p
19:05:48 <scodil> Saad__: np. The important thing there is that one instance is more specific than another, so if its a two-parameter type, you can't do C Int b and C a Int, because both apply to C Int Int
19:06:17 <scodil> but i think it your case its not a problem
19:06:20 <scodil> in your
19:06:24 <Associat0r> dolio that usenet thread?
19:06:31 <dolio> Yes.
19:06:53 <dolio> Maybe all the haskell folk have left comp.lang.functional in favor of comp.lang.haskell.
19:06:53 <Associat0r> "future of lazy programming"
19:07:14 <dolio> Yes, that's the one.
19:08:00 <Mr_Awesome> dolio: do you agree with that consensus?
19:08:02 <ddarius> I was on c.l.f a long time ago, but then I was off the net for a while and when I came back I didn't bother with usenet.
19:08:26 <solrize_> this is a thread going on right now?  i haven't looked at clf in a few months
19:08:41 <dolio> Mr_Awesome: No. I'm quite happy with Haskell's behavior. :)
19:08:54 <Mr_Awesome> dolio: good. i agree :)
19:09:17 <Associat0r> dolio : why can't a strict language be pure?
19:09:25 <Saad__> scodil, I see what you mean, but it isn't the problem so thanks again :)
19:09:36 <dolio> It can.
19:10:01 <Associat0r> then why do they say laziness was to ensure purity?
19:10:17 <vixey> for the reasons I just said
19:10:21 <Associat0r> or is it that the laziness forced them to stay pure?
19:10:23 <dolio> You can get away with impurity in strict languages. You can't in lazy ones.
19:11:21 <Associat0r> yes that is how I thougt of it too
19:12:08 <solrize_> yeah, see that spj slide show, that's more or less how he puts it
19:12:14 <solrize_> he describes it as wearing a hair shirt
19:12:36 <Associat0r> I hope that thread stays active
19:15:21 <vixey> I thought hair shirt was what really rich people wore!
19:15:30 <vixey> but it's like a punishment ?
19:15:40 <vixey> or was I right in the first place ?
19:15:53 <scodil> they're rich in spirit
19:15:57 <solrize_> nah, priests wore it to distract themselves from being distracted by their celibacy :)
19:16:16 <vixey> so what does it mean?
19:16:28 <solrize_> hairshirt?
19:16:50 <solrize_> it means to inflict physical pain on yourself in order to be morally pure
19:16:59 <UnorthodoxCodeFu> humina... no help to be had for Yi?
19:17:07 <vixey> I see
19:17:25 <solrize_> http://en.wikipedia.org/wiki/Hairshirt
19:17:26 <lambdabot> Title: Cilice - Wikipedia, the free encyclopedia
19:18:32 <solrize_> the slide show is worth looking at and is fairly quick
19:23:45 <atp> i wonder why "recursion schemes: a field guide" got lots of love on reddit, but anamorphisms: a field guide didn't
19:24:06 <atp> sometimes i don't really understand the logic of the masses on that site
19:24:28 <atp> i actually upmodded the anamorphisms link, but someone has since downmodded it
19:24:44 <vixey> anamorphisms is just one recursion scheme
19:25:14 <atp> yeah, but it's an update to edwardk's field guide links
19:29:45 <scodil> atp: the title "recursion schemes" contains "scheme" as a substring. Maybe lisp bots upvoted it.
19:30:43 <atp> ah.
19:30:52 <atp> are there actually lisp bots?
19:31:04 <atp> that seems somewhat... uh... conspiratorial?
19:35:53 <dmwit> UnorthodoxCodeFu: Either your cabal file is screwed up, or some important package is hidden.
19:36:17 <dmwit> UnorthodoxCodeFu: Have a look at the output of "ghc-pkg list"; packages surrounded in parens are hidden.
19:36:32 <dmwit> UnorthodoxCodeFu: caveat lector: I have never used Yi.
19:40:25 <dmwit> ?tell UnorthodoxCodeFu Take a look at "ghc-pkg list".  Maybe you have a package hidden that ought to be showing.  Packages surrounded in parens are hidden.
19:40:26 <lambdabot> Consider it noted.
19:43:49 <UnorthodoxCodeFu> the only hidden package i have is ghc-6.8.2... Yi.Keymap.Keys is hidden in the Yi package though... i'm not sure if there's anything to make of that though...
19:43:50 <lambdabot> UnorthodoxCodeFu: You have 1 new message. '/msg lambdabot @messages' to read it.
19:46:42 <dmwit> UnorthodoxCodeFu: Do you have the yi package installed?
19:47:54 <UnorthodoxCodeFu> dmwit: indeed... i ran 'ghc-pkg describe yi' to show me the exposed and hidden modules...
19:48:16 <dmwit> ah
19:48:19 <dmwit> Interesting.
19:48:30 <dmwit> The package is showing, but some modules are hidden?
19:48:54 <dmwit> Where did you get your config file from?
19:50:25 <UnorthodoxCodeFu> dmwit:  from the examples/yi.hs file in the yi directory downloaded from the darcs http://code.haskell.org/yi repository
19:50:26 <lambdabot> Title: Index of /yi
19:52:08 <dmwit> UnorthodoxCodeFu: Dunno for sure.
19:52:31 <dmwit> For now, you could move Yi.Keymap.Keys from the other-modules: section to the exposed-modules: section in the .cabal file.
19:54:00 <UnorthodoxCodeFu> dmwit: dernit =-)  okay... that was going to be my next step if i couldn't find another solution... thanks!
20:12:37 <wuxia> i currently have: data Point = Point { x :: Double, y :: Double, z :: Double } <-- this givbes a parse error; how do I create a data type with 3 elements, x, y, z ?}
20:13:21 <dmwit> That's fine, the error is somewhere else.
20:13:51 <dmwit> What's the error?
20:14:50 <wuxia> Point.hs:3:0: parse error on input `data'
20:15:01 <wuxia> entikre file is:
20:15:02 <wuxia> module Point
20:15:02 <wuxia> data Point = Point { x :: Double, y :: Double, z :: Double }
20:15:08 <dmwit> module Point where
20:15:11 <Saad__> You forgot a where
20:21:19 <Axman6> @src mod
20:21:19 <lambdabot> Source not found. Sorry.
20:21:23 <Axman6> @src rem
20:21:23 <lambdabot> Source not found. There are some things that I just don't know.
20:21:33 <dmwit> :t mod
20:21:35 <lambdabot> forall a. (Integral a) => a -> a -> a
20:21:38 <dmwit> ?src Integral
20:21:38 <lambdabot> class  (Real a, Enum a) => Integral a  where
20:21:38 <lambdabot>     quot, rem, div, mod :: a -> a -> a
20:21:38 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
20:21:38 <lambdabot>     toInteger           :: a -> Integer
20:22:06 <dmwit> Axman6: It's implemented differently for each Integral instance.  But in most cases it boils down to "this thing is built-in".
20:22:25 <Axman6> heh, thought so
20:22:53 <bd_> ?src Int mod
20:22:54 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
20:22:59 <bd_> ?src mod Int
20:22:59 <lambdabot> Source not found. stty: unknown mode: doofus
20:23:10 <dmwit> modInt#, probably ;-)
20:23:25 <bd_> something like that :)
20:23:36 <bd_> with requisite unboxing and reboxing
20:24:05 <dmwit> Is Int even boxed?
20:24:19 <bd_> yes
20:24:30 <bd_> > let f _ = 42 in f (undefined :: Int)
20:24:32 <lambdabot>  42
20:24:54 <bd_> unboxed types are always strict :)
20:25:05 <dmwit> ?slap me
20:25:05 * lambdabot beats up dmwit
20:32:30 <dons> gwern: https://datura.dylex.net:9947/~dylan/src/ gold mine.
20:32:38 <dons> gwern: we should find out who this guy is.
20:32:55 <dons> in particular, interface to MATLAB, including complete matrix access
20:33:40 <dons> gwern: i'll contact the author.
20:37:10 <dons> do we know Dylan Simon?
20:37:45 <mmorrow> not i, but that matlab interface could be nice (octave rulz!)
20:38:32 <dons> yeah, there's a lot of high powered code here for a guy we don't know.
20:39:36 <bd_> The haskell intelligence agency springs into action once again.
20:39:58 <mmorrow> dons: that *is* odd, how'd you find this page?
20:41:35 <ddarius> dons: There are all kinds of crazy people out there that we aren't aware of .
20:41:56 <dolio> dons: Did I send my patches to the right place?
20:43:57 <wuxia> how do I fix the following?
20:43:58 <wuxia> data Point = Point { x :: Double, y :: Double, z :: Double }
20:43:58 <wuxia> np = Point 0 0 0
20:43:58 <wuxia> add :: Point -> Point -> Point
20:43:58 <wuxia> add (Point x1 y1 z1) (Point x2 y2 z2) = Point x1+x2 y1+y2 z1+z2
20:44:11 <wuxia> something about x2 y1 parse error on the last line
20:44:17 <dibblego> instance Monoid Point where ...
20:44:18 <mmorrow> quicksilver: ping
20:44:19 <newsham> parenthesis around (x1+x2)
20:44:20 <dolio> Point (x1+x2) (y1+y2) ...
20:44:20 <newsham> etc
20:44:39 <vixey> that shouldn't be a parse error
20:44:52 <dolio> What you have parses as: (Point x1) + (x2 y1) + (y2 z1) + z2
20:45:11 <newsham> or  pairwise f (Point x y z) (Point x' y' z') = Point (f x x') (f y y') (f z z')
20:45:18 <newsham> add = pairwise (+)
20:45:19 <mmorrow> this is a cool js app: http://icicle.dylex.net/~ipmap/
20:45:20 <lambdabot> Title: IPv4 Map
20:45:37 <mmorrow> (or whatever app)
20:45:55 <newsham> instance applicative?
20:46:19 <newsham> (+) <$> p1 <*> p2
20:47:01 <dolio> You'd have to generalize it to Point a for that.
20:47:18 <dolio> Not that that's a problem.
20:48:11 <slavi1> are there any books/tutorials that teach the haskell syntax well?
20:49:32 <mmorrow> the haskell report, but i wouldn't say it "teaches" it
20:49:45 <mmorrow> it specifies it
20:50:46 <wuxia> in the following code, I get an error saying y1/z2 not defined; why not? instance Show Point where show (Point x1 y2 z1) = show ("<" ++ x1 ++ ", " ++ y1 ++ ", " ++ z2 ++ ">")
20:50:56 <slavi1> mmorrow: most of the tutorials I've read, teach just enough syntax to solve a particular problem ... I am looking for something similar that also adds other syntax stuff applicable to the data type employed.
20:51:20 <dmwit> wuxia: You put the wrong names in the pattern match.
20:51:30 <dmwit> wuxia: But why number them?  Just use x, y, z.
20:52:07 <mmorrow> slavil: reading real code would probably be good. all the standard libs at http://haskell.org/ghc/docs/latest/html/libraries/ have a link in the upper right of their haddock doc pages to see their source
20:52:08 <lambdabot> Title: Haskell Hierarchical Libraries
20:52:22 <dmwit> wuxia: Your code is broken for other reasons, too.  But you'll figure it out, I'm sure. ;-)
20:52:37 <wuxia> yeah, i have doubles, not [XChar]
20:52:47 <wuxia> how do I convert a double to a [Char] ? looking for the equiv of putStr
20:52:53 <dmwit> show
20:53:52 <wuxia> great, so the following code works, but looks really ugly, is there a good idiom I can use to make this look more haskelly / elegant?
20:53:55 <wuxia> data Point = Point Double Double Double
20:53:57 <wuxia> instance Show Point where show (Point x y z) = show ("<" ++ (show x) ++ ", " ++ (show y) ++ ", " ++ (show z) ++ ">")
20:54:09 <mmorrow> slavil: http://haskell.org/ghc/docs/latest/html/libraries/containers/src/Data-Tree.html
20:54:10 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/5deb2l
20:54:12 <mmorrow> slavil: http://haskell.org/ghc/docs/latest/html/libraries/containers/src/Data-Map.html
20:54:18 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/2bjwxd
20:54:20 <dmwit> wuxia: Get rid of parens, use concat.
20:54:59 <wuxia>   show (Point x y z) = show concat "<" x ", " y "," z
20:55:08 <wuxia> that compiles,  so concat calls show automatcally?i
20:55:18 <dmwit> That had better not compile.
20:55:25 <mmorrow> slavil: http://haskell.org/ghc/docs/latest/html/libraries/html/src/Text-Html-BlockTable.html
20:55:25 <scodil> wuxia : you can also derive Show. It will then print like "Point 0.5 0.33 0.55"
20:55:27 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/6p6fsz
20:56:05 <wuxia> scodil: can you show me the 2 lines of code that will be? (for learning puroses)
20:56:13 <wuxia> *purposes*
20:57:19 <dibblego> data Point = Point Double Double Double deriving Show
20:58:40 <mmorrow> slavil: i should've linked to this first: http://haskell.org/ghc/docs/latest/html/libraries/base/src/Data-List.html
20:58:41 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/392kwb
20:59:04 <noecksit> @src Data.Char
20:59:04 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
20:59:19 <wuxia> hmm,   show (Point x y z) = show concat "<" (show x) ", " (show y) "," (show z)
20:59:24 <wuxia> doesn'ta actually work
20:59:34 <dmwit> You better believe it doesn't.
20:59:36 <wuxia>     Couldn't match expected type `[Char]
20:59:37 <wuxia>                                   -> String
20:59:37 <wuxia>                                   -> [Char]
20:59:38 <wuxia> ...
20:59:45 <wuxia> but isn't String already a [Char] ?
20:59:47 <dibblego> > concat ["x", show 4.0, "y"]
20:59:49 <lambdabot>  "x4.0y"
21:00:27 <mmorrow> > concat . intersperse "," $ ["x", show 4.0, "y"]
21:00:29 <lambdabot>  "x,4.0,y"
21:00:33 <dmwit> > show concat -- even this part only works in \bot
21:00:35 <lambdabot>  Add a type signature
21:00:49 <dmwit> > intercalate ", " ["x", show 4.0, "y"]
21:00:51 <lambdabot>  "x, 4.0, y"
21:00:53 <slavi1> mmorrow: nothing book format?
21:01:10 <mmorrow> slavil: umm, i dunno
21:01:25 <dibblego> there is prolly a way of saying newtype ShowList = ShowList forall a. (Show a) => [a]
21:01:35 <dibblego> can existential types do that?
21:02:02 <wuxia> :t intercalate
21:02:03 <lambdabot> forall a. [a] -> [[a]] -> [a]
21:02:08 <wuxia> @hoogle intercalate
21:02:08 <lambdabot> Data.List.intercalate :: [a] -> [[a]] -> [a]
21:02:08 <lambdabot> Data.ByteString.intercalate :: ByteString -> [ByteString] -> ByteString
21:02:08 <lambdabot> Data.ByteString.Char8.intercalate :: ByteString -> [ByteString] -> ByteString
21:02:14 <mmorrow> slavil: if you want to *buy* a book, there's haskell code in the back of "Purely Functional Datastructures", and there's a book called "The Haskell School of Expression"
21:03:08 <slavi1> which would you recommend?
21:03:37 <mmorrow> slavil: they're very different. what type of programming do you do/want to do?
21:03:49 <slavi1> mmorrow: I like C and Perl :)
21:03:58 <slavi1> but I want to learn Haskell :)
21:04:02 <slavi1> parallel programming
21:04:24 <mmorrow> slavil: i recommend "Purely functional Datastructures"
21:04:43 <ddarius> That's not a book for learning Haskell.
21:04:44 <slavi1> and I understand how functional programming works :)
21:04:45 <mmorrow> slavil: but bear in mind that Haskell isn't the focus of it
21:05:32 <slavi1> hmm, I am looking for something haskell oriented (I think I know functional programming, but I want to learn Haskell specifically).
21:05:46 <ddarius> slavi1: http://www.haskell.org/haskellwiki/Learning_Haskell This page contains links to a variety of sources and discussions about what sources you may prefer.
21:05:48 <lambdabot> Title: Learning Haskell - HaskellWiki
21:06:01 <mmorrow> slavil: how could i forget: http://book.realworldhaskell.org/beta/index.html
21:06:05 <lambdabot> Title: Real World Haskell
21:06:30 <scodil> slavi1: Haskell School of Expression is good for learning both FP and Haskell, so if you don't mind paying for a few chapters you don't need, then check that one out
21:07:10 <ddarius> http://www.haskell.org/haskellwiki/Meta-tutorial
21:07:12 <lambdabot> Title: Meta-tutorial - HaskellWiki
21:07:35 <slavi1> ddarius: I did the quick tutorials ...
21:07:59 <ddarius> slavi1: If you went through, e.g. the Gentle Introduction to Haskell, you should be set.
21:08:16 <ddarius> Anyway, the meta tutorial is a resource for deciding which tutorial to read.
21:08:27 <wuxia> is there a buuilt in function for converting a tuple iknto a vector?
21:08:35 <dmwit> No.
21:08:45 <scodil> wuxia: haskell has no 'vector' type. you have to make your own
21:08:48 <wuxia> sorry, by vector, I meant list
21:08:54 <slavi1> but sometimes I write code that I don't understand why it doesn't work ... like this (it is a small peace: func l:ls n = (l*n):(func ls n-1) )
21:08:55 <dmwit> The answer is still no.
21:09:00 <vixey> wuxia: what length is the tuple?
21:09:09 <vixey> is it a pair, triple.. ?
21:09:11 <scodil> list elements are all the same type, tuple elements can be different
21:09:11 <wuxia> oh rigyt because tuples can hold elemnts of different types
21:09:22 <wuxia> hmm, so if i am declaring a 3d point
21:09:25 <wuxia> should it be a tuple of doubles
21:09:29 <wuxia> or a list ?
21:09:43 <dmwit> Why not use the Point data type you've just been defining?
21:10:10 <scodil> wuxia: what dmwit said. once you get further along, there are optimizations you can make to your Point type to make it more space-efficient
21:10:11 <wuxia> i'm trying to implement show w/ list comprehension and sending x, y, z throlugh it
21:10:16 <wuxia> okay
21:10:20 <wuxia> thanks, will ignore this for now
21:10:40 <scodil> more efficient than a list or tuple, that is
21:11:02 <dmwit> > let wrap a b xs = a ++ xs ++ b in wrap "<" ">" . intercalate ", " . map show $ [3, 4, 5]
21:11:08 <lambdabot>  "<3, 4, 5>"
21:13:49 <dons> data types are cheap, easy and efficient, use them! :)
21:14:28 <dmwit> Whoop, there goes the bot.
21:15:24 <xif> Howdy. When I try to define a function called "sum", I get the following error: "Ambiguous occurrence `sum'. It could refer to either `GS.sum', defined at c1.hs:29:0 or `Prelude.sum', imported from Prelude"
21:15:37 <dons> its clashing with the Prelude sum. what would you like to do?
21:15:49 <xif> override sum.
21:15:52 <dmwit> Name it differently, or use "import Prelude ()" at the top of the file, or qualify sum.
21:16:03 <dons> ok, so then you can: import Prelude hiding (sum)
21:16:29 <xif> cool, so `import Prelude hiding (sum)` is the same solution dmwit suggests, right?
21:16:44 <dmwit> Not quite; import Prelude () will hide everything. =P
21:16:55 <xif> dmwit: (how would I "qualify sum" in this case?  by tying it to a different type definition?)
21:17:00 <dmwit> GC.sum
21:17:25 <dmwit> Sorry, I meant GS.sum, obviously.
21:17:27 <dons> import qualified Prelude as P
21:17:29 <dons> then use P.sum
21:17:33 <dons> for example
21:17:48 <xif> interesting, thanks.
21:17:55 <xif> dons and dmwit.
21:18:18 <dmwit> xif: For each value bar that module Foo exports, "import Foo" binds two names: "bar" and "Foo.bar".
21:18:40 <dmwit> xif: If you add the "qualified" keyword to the import, it does not bind "bar" (but still binds "Foo.bar").
21:19:01 <dmwit> xif: If you add an "as Quux" clause, it will additionally bind "Quux.bar".
21:19:33 <dmwit> xif: You will note that "qualified" and "as" are orthogonal; you can have both if you like.
21:20:09 <xif> dmwit: thanks a lot, I'm starting to get this :)
21:20:21 <carl> how do i deal with this Ambiguous occurrence `tail'
21:20:22 <carl>     It could refer to either `Prelude.tail', imported from Prelude
21:20:22 <xif> (and I though Python's import syntax was rich ;)
21:20:24 <carl>                           or `Data.ByteString.Lazy.tail', imported from Data.ByteString.Lazy
21:20:35 <xif> carl: I just asked about that :)
21:20:45 <carl> lol i just joind xd
21:20:50 <carl> care to share
21:20:52 <xif> you're defining a "tail" function that's already defined in Prelude.
21:21:03 <dmwit> carl: You have a few options.
21:21:03 <xif> what do you want to do?
21:21:10 <carl> well importing it from bytestrings but yes
21:21:16 <carl> call tail on a bytestring
21:21:24 <dons> import qualified Data.ByteString.Lazy as L
21:21:29 <scodil> this is starting to look like an alien virus invasion
21:21:29 <dons> L.tail (L.map f xs)
21:21:48 <carl> ok thx
21:21:57 --- mode: ChanServ set +o dons
21:22:03 --- topic: set to '["import qualified Prelude as P", "Haskell: precision engineering for programmers", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org ", "Logs: http://tunes.org/~nef/logs/haskell/"]' by dons
21:22:07 --- mode: ChanServ set -o dons
21:22:19 <dmwit> heh
21:22:30 <dons> let it be henceforth known!
21:22:43 <monochrom> It's already in the Haskell 98 Report.
21:23:00 <dmwit> monochrom: Well, it's better than "print = putStrLn . show". =)
21:23:09 <dons> let the Haskell 98 Report be henceforth read thoroughly!
21:23:28 <monochrom> Precisely my sentiment.
21:24:01 <carl> dons: will that work in ghci?
21:24:19 <dmwit> Not really.
21:24:26 <dmwit> But you can put that line in a file and load the file.
21:24:37 <carl> kk
21:25:02 <carl> but theres no way to just play with bytestrings in ghci
21:25:09 <dmwit> Why not?
21:25:32 <dmwit> Oh, I see I was a bit ambiguous.
21:25:42 <dmwit> Stick the "import ... as L" line in a file.
21:25:52 <dmwit> Then, after you load the file, you can use L.map, L.tail, etc.
21:26:29 <dmwit> You could also just do ":m + Data.ByteString.Lazy" in ghci, but then you'd have to type "Data.ByteString.Lazy.map"... which is *way* too long. ;-)
21:26:37 <scodil> or you can get the source for ByteString and load that into ghci
21:26:49 <Cale> whoa, did lambdabot die?
21:26:51 <carl> never mind loading it in a file works
21:26:55 <dmwit> Cale: yes
21:27:05 <dmwit> Cale: But don't worry, it was only a few minutes ago.
21:27:42 <xif> `import Prelude hiding (sum)` doesn't work at the top of foo.hs when I `:l foo.hs` in GHCi
21:28:03 <Axman6> @join #macosx
21:28:07 <dmwit> xif: What error do you get?
21:28:10 <lambdabot> Not enough privileges
21:28:28 <Cale> Oh, people want it in #macosx?
21:28:33 <Axman6> yep
21:28:42 <Cale> Temporarily or permanently?
21:28:43 <wuxia> is accessing the nth element of a list o(1) or o(n) ... if it's not o(1) ... is there any built in type that gives me o(1) random access?
21:28:46 <dmwit> xif: You might need a language pragma, like -XNoImplicitPrelude or something.
21:28:56 <Cale> lambdabot: @join #macosx
21:29:01 <Axman6> had it in there yesterday, and BeelsebobWork and I were having fun
21:29:02 <xif> dmwit: `c1.hs:3:0: parse error on input `module'`
21:29:07 <Axman6> permanant would be nice :)
21:29:18 <dmwit> wuxia: O(n); Data.Map is a really fast O(log n); Data.Array is a really slow O(1).
21:29:30 <Axman6> thanks Cale :)
21:29:38 <dmwit> ?hpaste it, xif
21:29:39 <wuxia> err, how is O(log n) really fast and O(1) really slow ?
21:29:44 <lambdabot> Haskell pastebin: http://hpaste.org/new
21:30:00 <dmwit> wuxia: The constant on the O(log n) is pretty low, and the constant on the O(1) is pretty big.
21:30:02 <wuxia> i'm dealing with 3d meshes; should I not store a vertex array and have faces index into the array for points ?
21:30:17 <dmwit> wuxia: I've actually *sped up* an algorithm by moving from Array to [].
21:30:19 <Cale> Axman6: no problem. lambdabot no longer has a channel count restriction, so it doesn't hurt to put it in another chan :)
21:30:19 <wuxia> dmwit: please enlighten me; how can array be slow? it's trivial to implement in othe rother languages
21:30:30 <Axman6> excellent :)
21:30:53 <dmwit> wuxia: Oh, really?  What other languages have you implemented arrays in?
21:30:55 <Cale> wuxia: Suppose you want to construct a new array where all but the first element are the same
21:30:55 <hpaste>  xif pasted "(no title)" at http://hpaste.org/8737
21:31:05 <xif> dmwit: ^
21:31:11 <Cale> wuxia: You'll be forced to copy the entire array. With a list, the tails can be shared.
21:31:11 <wuxia> dmwit: c pointers :-)
21:31:18 <dmwit> wuxia: You didn't implement that.
21:31:26 <wuxia> dmwit: okay, sorry, I didn't implement it
21:31:33 <monochrom> xif: Heh, switch the module line and the import line!
21:31:38 <dmwit> xif: If you have a module name declaration, it must be the first thing in the file.
21:31:52 <dmwit> xif: So, put the "module GS where" at the top.
21:31:52 <monochrom> oops also the "where" goes with the module line.
21:31:55 <wuxia> okay, so if I have a read only array in haskell, it should be fast right< there's no reasn for it to be slow
21:31:56 <Axman6> been working on the euler project problems. i'm quite pleased with "last $ filter (\n -> 600851475143 `rem` n == 0 && prime n) [1..100000]" for the highest prime factor of 600851475143 problem
21:32:11 <Axman6> it's a lot faster than i thought it would be
21:32:12 <scodil> wuxia: you can do c pointers in haskell too. check out the Storable class. That's currently the most efficient way to deal with large amounts of 3d points/vectors
21:32:13 <xif> monochrom, dmwit: I see, thanks.
21:32:46 <scodil> wuxia: if the array is read only then the Array type is fast enough for most things
21:32:51 <Cale> wuxia: If you really need mutable arrays, we have STArray and IOArray, for the ST (pure stateful computation) and IO monads respectively.
21:32:56 <xif> btw, if I have a function foo, is there any way to get GHCi to print its source?
21:33:11 <dmwit> xif: no
21:33:14 <monochrom> Sorry, no.
21:33:25 <dmwit> xif: Some functions can be source'd in \bot:
21:33:27 <dmwit> ?src map
21:33:27 <lambdabot> map _ []     = []
21:33:27 <lambdabot> map f (x:xs) = f x : map f xs
21:33:34 <Cale> However, I believe :info will tell you where it's defined.
21:33:36 <dmwit> xif: But obviously not ones you've written. ;-)
21:33:38 <xif> ah, nevermind. I'm just a bit used to it from Javascript :)
21:34:19 <Cale> Try :i mySymbol  and see what that says :)
21:35:50 <xif> yeah, it gives a precise location.
21:36:09 <xif> in Python, we have an inspect module that simply goes there and grabs the source.
21:36:22 <dmwit> Seems like a nice idea.
21:36:54 <dons> xif: grabs it off the internets?
21:37:10 <xif> dons: off the local file where it's defined :)
21:37:15 <dmwit> dons: Probably just from off the disk.
21:37:22 <dons> ah right. i think recent ghci can do this via haddock's indicies
21:38:01 <dmwit> That's a great point.  Haddock does have "source" links for each function in its newer incarnations.
21:38:01 <dons> haddock's also showing the src for things now, fwiw.
21:38:03 <dons> see e.g. http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#11
21:38:06 <lambdabot> Title: Prelude, http://tinyurl.com/ovjef
21:38:22 <dons> i think simonmar added showing these fragments  in ghci to head a couple of months ago
21:38:23 <mmorrow> wuxia: are you doing any simplification of the meshes?
21:38:28 <dons> so yeah, :source will probably work soon
21:38:35 <wuxia> no
21:38:38 <mmorrow> wuxia: if so, this is excellent => http://research.microsoft.com/~hoppe/newqem.pdf
21:38:40 <mmorrow> ah
21:38:44 <wuxia> mmorrow: no, i'm still tryikng to figure out hot wo store it
21:39:01 <wuxia> mmorrow: ohn wait, this is from the guy who did progressive meshes
21:39:09 <mmorrow> wuxia: yesh
21:39:51 <mmorrow> wuxia: i meant to link you to *this* paper ==> http://www.soe.ucsc.edu/classes/cmps160/Spring05/finalpages/scyiu/
21:39:52 <lambdabot> Title: Mesh Simplification Using Quadric Error Metrics, http://tinyurl.com/64nftl
21:39:53 <wuxia> mmorrow: are yolu into computer graphics? i'm mostly interested in csg (if you know of a good hasekll implementation, taht'd be useful too)
21:40:08 <mmorrow> both are good
21:40:52 <scodil> why reinvent the wheel? http://graphics.cs.uiuc.edu/~garland/software/qslim.html
21:40:53 <lambdabot> Title: QSlim Simplification Software
21:41:11 <mmorrow> wuxia: i took a "advanced computer graphics" course in school, we had to implement quadric error meshes + other mesh stuff for one of the projects
21:41:26 <mmorrow> c + opengl (kill me!)
21:41:47 <wuxia> http://en.wikipedia.org/wiki/Generative_Modelling_Language <-- this is what i'm tryinng to implement
21:41:48 <lambdabot> Title: Generative Modelling Language - Wikipedia, the free encyclopedia
21:42:24 * mmorrow looks
21:44:43 <mmorrow> wuxia: interesting. having read the first paragraph, it seem analogous to representing products not as pairs of sets, but as pairs of projection functions
21:45:14 <mmorrow> (by analogous i mean "the general idea" is analogous)
21:46:18 <wuxia> mmorrow: wha5t's ur current status? student? working?
21:46:24 <mmorrow> working
21:46:30 <wuxia> mmorrow: graphics related?
21:46:46 <mmorrow> no, but i enjoy graphics stuff
21:47:02 <mmorrow> been meaning to check out the haskell OpenGL interface
21:49:32 <mmorrow> yourself?
21:49:52 <wuxia> a student trying to hit a siggraph paper :-)
21:50:02 <mmorrow> heh, nice.
21:51:10 <scodil> wuxia: I just made a library recently for 2d and 3d points, with emphasis on speed. It pairs well with the StorableVector library. http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Vec
21:51:13 <lambdabot> Title: HackageDB: Vec-0.9.1
21:51:32 <wuxia> scodil: cool, thanks; taking a look at it now
21:51:57 <mmorrow> scodil: oh man, you should add 4d also (alpha channel, homogenous 3d coords)
21:52:04 <scodil> mmorrow: its n-d
21:52:16 <mmorrow> cool
21:52:37 <wuxia> wait, you have support for inverting matrices in there?
21:52:41 <scodil> yeah
21:52:42 <wuxia> how well does it scale?
21:53:19 <mmorrow> scodil: oh yeah, i remember. nicely done.
21:53:33 <scodil> its pretty good. There's an example program, and C program to benchmark with. I think its like 3.5 secs for C and 6 secs for haskell
21:53:35 <scodil> so, not terrible
21:53:58 <scodil> but thats with ridiculous amounts of optimization. compiled normally its maybe 5-10x slower
21:54:06 <scodil> but you can always import the C function using the FFI
21:55:22 <mmorrow> scodil: heh, so what was the total compilation time with all the optims?
21:55:47 <scodil> for that one loop, maybe 30sec - 1min
21:55:50 <scodil> for that one loop :)
21:56:42 <mmorrow> scodil: (hmm, it was you that was in here maybe a week+ ago trying to get the core from that one program/lib that was taking hours to compile, right?)
21:56:59 <scodil> no it was taking hours to dump the core
21:57:17 <mmorrow> ah
21:57:45 <mmorrow> ha, i had a completely different picture of what was going on :)
21:58:06 <scodil> anyway its just that gaussian elimination function. The rest of the library compiles speedily and generates nice code
21:58:18 <mmorrow> nice.
21:58:49 <mmorrow> is there also a darcs repo anywhere, or is the hackage the most recent?
21:59:08 <scodil> I just uploaded that today. the darcs repo is mentioned there on the hackage page
21:59:31 <scodil> er no its not. its in the documentation
21:59:37 <mmorrow> ah, found it
22:01:28 <scodil> ok just compiled, the loop to invert an array of 4x4 matrices took 2m39 secs. Not awful, but the C version takes .5 secs :)
22:03:04 <mmorrow> scodil: have you seen harpy?
22:03:26 <scodil> no
22:03:42 <mmorrow> scodil: it could be used for ridiculously fast image manip stuff + linalg stuff
22:03:51 <mmorrow> oh man
22:03:53 * mmorrow gets link
22:04:04 <scodil> yeah I was about to ask. That's a tough one to google for :)
22:04:14 <mmorrow> heh
22:04:20 <ddarius> Harpy is a library for generating x86 machine code at run-time.
22:04:34 <dmwit> ?go harpy haskell
22:04:41 <lambdabot> http://uebb.cs.tu-berlin.de/harpy/
22:04:41 <lambdabot> Title: Harpy - Runtime code generation for x86 machine code
22:04:42 <ddarius> @where harpy
22:04:43 <lambdabot> http://uebb.cs.tu-berlin.de/harpy/
22:04:57 <dmwit> Doesn't look to be *too* hard to Google for. ;-)
22:06:48 <mmorrow> scodil: here's a harpy fib: http://code.haskell.org/~morrow/code/haskell/misc/fib.hs
22:08:13 <scodil> pretty cool
22:08:19 <mmorrow> scodil: way cool
22:08:30 <scodil> I'm still waiting for the Haskell -> CUDA bridge
22:08:48 <scodil> or a Haskell -> Cell bridge
22:09:32 <mmorrow> oh yeah, that cell proc looks super way cool
22:09:45 <scodil> total pain in the ass though
22:09:54 <mmorrow> do tell
22:10:06 <scodil> explicit cache management
22:10:34 <scodil> you have to explicitly load/store cache blocks from main memory
22:10:43 <scodil> including instructions
22:10:43 <mmorrow> have you programmed for one? (can one yet?)
22:11:11 <mmorrow> (as in are they available)
22:11:18 <scodil> I may end up working with them soon. A colleague is working on one now. He spent like a week writing Conway's game of life
22:11:39 <mmorrow> heh, but i bet it *crushes*
22:11:58 <scodil> Yeah it would if he actually had a cell :) He's using the simulator
22:12:04 <mmorrow> heh
22:12:53 <mmorrow> fpga are very interesting also
22:12:55 <scodil> yeah so the uber-manual memory management, combined with all-vector registers makes for tedious programming. Putting a nice haskell face on it would be great
22:13:21 <mmorrow> hmm, i wonder what the crux of that would be
22:13:28 <scodil> I have no idea
22:13:42 <scodil> Language.C will help though
22:14:01 <mmorrow> oh yeh, i've gotta darcs pull that...
22:15:59 <mar77a> > 0 ** -1
22:16:00 <lambdabot>      precedence parsing error
22:16:00 <lambdabot>         cannot mix `(**)' [infixr 8] and prefix...
22:16:04 <mar77a> > 0 ** (-1)
22:16:05 <lambdabot>  Infinity
22:17:09 <carl> is there an efficent way to convert an int into a bytestring of len 4 and visa versa or do i have to do it manually
22:20:01 <scodil> carl : Data.ByteString.Internal.create 4 (flip poke myInt)   ?
22:20:36 <carl> is all that sorta stuff in the internal package?
22:20:39 <scodil> er, you should do   create (sizeOf myInt) (flip poke myInt)
22:20:40 <scodil> yeah
22:20:59 <scodil> oh wait
22:21:02 <carl> thx
22:21:03 <scodil> you need a castPtr in there too
22:21:10 <scodil> flip poke myInt . castPtr
22:21:20 <carl> lol this is looking more and more like c
22:21:32 <carl> kk ill figure it out thx
22:21:59 <scodil> you could also just do pack [myInt]
22:22:22 <scodil> that might even optimize into the same thing
22:22:33 <scodil> oh shoot
22:22:34 <scodil> no
22:22:36 <scodil> I'm nuts
22:22:41 <mmorrow> carl: you'll also need Foreign.Ptr and Foreign.Storable
22:22:49 <carl> o i meant like a 32 bit int
22:22:55 <scodil> I'm thinking of StorableVector
22:22:58 <scodil> I use that one more
22:23:05 <scodil> its like ByteStrings but for any Storable type
22:23:25 <Axman6> hmm, anyone gone through the euler project problems?
22:23:39 <carl> cause im trying to implement a protocol and its a wee bit ugly converting the bytestrings into shorts and ints atm
22:24:21 <scodil> check out Data.Binary
22:26:59 <carl> lol sometimes i miss *(int*)charArr
22:27:38 <Axman6> sounds like something Erlang could excel at
22:27:47 <scodil> no way, castPtr is awesome. You don't even have to know what you're casting to :)
22:28:43 <carl> lol havent lived in the haskell world long enough yet to come across castPtr or anything to do with ptrs
22:29:32 <scodil> writing C in Haskell is actually nice, with type inference and higher-order functions. You just have to get used to it.
22:29:41 <scodil> It doesn't look pretty though
22:30:35 <carl> one of the first things i had to do was write an XTEA implementatin which stands for xtended tiny encryption algorithm in c its about 7 lines mine is about 50
22:31:28 <scodil> Maybe just leave it in C? It's just 1 line to import a C function, and you can just throw the .c file on the GHC command line and GHC will compile and link it for you
22:32:00 <hpaste>  morrow pasted "Vec-0.9.1 ghc-6.9 build failure" at http://hpaste.org/8738
22:32:08 <scodil> oh no
22:32:10 <scodil> users
22:32:31 <scodil> this is just building the library?
22:33:01 <scodil> I don't have ghc 6.9
22:33:57 <carl> is the Binary package not distributed with ghc?
22:34:25 <scodil> no
22:55:02 <Axman6> bleh, anyone managed http://projecteuler.net/index.php?section=problems&id=5 ?
22:55:02 <lambdabot> Title: Problem 5 - Project Euler
22:55:23 <solrize_> yeah i did that one
22:55:35 <Axman6> i've got a method that seems to be working, but it certainly doesn't take less than a minute
22:55:43 <bd_> Ah, apparently I did it at some point
22:55:53 <solrize_> it should be easy
22:56:08 <bd_> yeah, that one can probably be done by hand
22:56:43 <Axman6> @hpaste
22:56:43 <lambdabot> Haskell pastebin: http://hpaste.org/new
22:57:08 <hpaste>  Axman6 pasted "euler project problem 5" at http://hpaste.org/8740
22:57:28 <bd_> don't brute force it :)
22:57:32 <bd_> there's a trick to it
22:57:37 <Axman6> :\
22:57:41 <Axman6> any hints?
22:57:59 <bd_> think about the fundamental theorem of arithmetic
22:58:45 * ddarius has considered proving the fundamental theorem of algebra in an article he's working on just because it is right there.
22:59:10 <bd_> once you see the trick, you can probably compute the answer with pencil and paper in a minute or two
22:59:13 <bd_> :)
23:01:26 <Axman6> is it that it has to be divisible by 20, and all primes less than 20?
23:01:35 <Axman6> english++
23:01:50 <bd_> close!
23:01:58 <bd_> but that won't ensure it's divisible by 9
23:02:06 <Axman6> all primes less than 20?
23:02:14 <Axman6> hmm
23:02:25 <bd_> Axman6: if you multiply all primes less than 20, times 20, you will have a number not divisible by 9
23:02:38 <Axman6> all primes less than 20, and powers of those less than 20?
23:02:50 <bd_> Axman6: what conditions must the prime factorizations of X and Y satisfy for X to be divisible by Y?
23:03:46 <Axman6> that Y is divisible by primes? :\
23:03:57 <paolino> subsets
23:04:12 <bd_> is (2^2 * 3^2) divisible by (2^3 * 3^2)?
23:04:17 <bd_> or even
23:04:19 <bd_> is (2^2 * 3^2) divisible by (2^3 * 3^1)?
23:04:21 <bd_> and if not, why?
23:04:36 <bd_> turn that into a general condition, and you will be close to the solution :)
23:04:49 <Axman6> no, because (2^2 * 3^2) is prime?
23:04:57 <bd_> Axman6: 2^2*3^2 is most certainly not prime :)
23:05:16 <Axman6> 4+9 = 13 no?
23:05:16 <bd_> 2^2 * 3^2 = 2 * 2 * 3 * 3
23:05:25 <Axman6> ah, my bad
23:05:31 <Axman6> heh, * not +
23:05:33 <bd_> :)
23:05:40 <bd_> now, without multiplying it out
23:05:52 <bd_> how can you tell whether (2^2 * 3^2) is divisible by (2^3 * 3^1)?
23:06:25 <Axman6> (2^2 * 3^2) = (2^2 * 3^1) * 3?
23:06:53 <bd_> I think you may have misread the second value :)
23:06:57 <bd_> 2^3 * 3^1
23:07:01 <Axman6> ah, yes
23:07:13 <Axman6> hmm
23:08:05 <bd_> hint: see what happens when you divide both sides by various values
23:08:41 <Axman6> rawr, i'm not getting it. i'll come back to this one i think
23:09:10 <bd_> hehe
23:09:14 <bd_> well
23:09:25 <atp> hm
23:09:45 <bd_> problem 5 is basically a quiz on prime factorizations
23:10:01 <bd_> and I don't want to give it away... but do meditate on the relationship between prime factorizations and divisibility
23:10:16 <Axman6> something which my brain doesn't seem up to today
23:11:17 <Axman6> #6 was a hell of a lot easier
23:11:48 <paolino> what is the math name for sets with not unique elements  (if this is math)?
23:12:15 <Axman6> independant?
23:12:22 <Axman6> oh, dependent*
23:12:24 <Axman6> ?
23:12:31 <ddarius> You mean where elements can occur more than once?
23:12:36 <ddarius> If so, then multiset or bag.
23:12:36 <paolino> yes
23:13:01 <paolino> so prime factorization is a multiset
23:13:20 <paolino> of prime numbers
23:15:11 <ddarius> paolino: So what is divisibility correspond to on those bags?
23:15:27 <paolino> Axman6: anytime you compare two factorizations you compare 2 multisets of prime numbers
23:15:31 <carl> with lazy bytestreams do u usually choose a chunksize and work with that size or is that somehow taken care of in the background
23:16:28 <solrize_> chunksize is 64k and not user selectable unless i'm mistaken
23:17:07 <paolino> ddarius: I guess improper subsetting means divisibility
23:18:49 <paolino> mcd should be intersection
23:19:33 <paolino> mcm union
23:20:56 <ddarius> So a set is equivalent to a function X -> Bool and a bag is equivalent to a function X -> N.  In this case, X = P the set of primes which is not only countable but has a natural ordering on it.  So P ~ N and thus a bag is a function N -> N.  A stream (infinite list/sequence) is a function N -> X.  So we can reduce the prime factorization to a stream of natural numbers.
23:22:13 <stepcut> carl: the chunk-size is fixed. But it is completely transparent to you as the user.
23:22:24 <ddarius> (It's probably more convenient to use a stream of integers though.)
23:22:45 <ddarius> Actually scratch that.  We just want to use a torsor.
23:23:45 <ddarius> That is view N as a Z-torsor.
23:24:28 <paolino> torsor ?
23:24:34 <ddarius> @google torsor
23:24:36 <lambdabot> http://math.ucr.edu/home/baez/torsors.html
23:24:36 <lambdabot> Title: torsors
23:31:53 <paolino> ok, nice to know positions are Rn-torsors element
23:32:22 <ddarius> paolino: That's actually a very good way to structure graphics code.
23:32:35 <ddarius> I.e. have a Point type and a distinct Vector type.
23:32:51 <ddarius> s/Point/Position
23:33:51 <paolino> it's also dumb not to teach them together with vectors, I agree
23:34:23 <paolino> the name is a bit scary
23:34:43 <ddarius> It has a nice ring to it though.
