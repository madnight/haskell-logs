00:00:08 <mgdtgd> Saizan_: thank you
00:08:25 <codacola> mgdtgd: ive already learnt assembly, hated it, but i love C :P
00:08:50 <mgdtgd> codacola: I can't understand how someone could possibly love C
00:08:59 <codacola> why?
00:09:23 <wkh> it has a kind of spartan minimalism to it
00:09:54 <wkh> other than that, if you aren't doing low-level stuff it's a waste of time IMO :p
00:10:04 <mgdtgd> I for my part hate it with a passion. The compiler doesn't tell you anything even if you compile with -Wall and all that jazz. Errors are extremely mysterious
00:10:21 <mgdtgd> I once had to write a simple webserver in C
00:10:32 <codacola> your fault for making errors ;)
00:10:36 <mgdtgd> it worked on my computer, but didn't on a friends
00:10:53 <wkh> that's projecting assumptions of a real programming environment on it. once you realize C is a portable assembly language it becomes more approachable
00:11:06 <mgdtgd> turned out there was a magical int somewhere, unused, but it aligned stuff just right to hide a buffer overflow
00:11:32 <mgdtgd> No sane language should allow for that
00:12:03 <mgdtgd> gcc just assumes "oh well, he's programming in C, probably he actually WANTS to do crazy shit with his memory"
00:12:53 <_zenon_> mgdtgd, :)
00:13:18 <mgdtgd> also, the complete lack of polymorphism is just annoying
00:13:23 <olsner> but that's not gcc, that's just how C is
00:13:30 <_zenon_> gcc -o myprog *.c --crazy-Shit
00:14:50 <mgdtgd> I'll stick to my ghc. He actually tells me "oh look, that piece of code seems fishy, you'd better correct that if you want me to compile it"
00:14:57 <codacola> mgdtgd: you DONT want to do crazy shit with your memory?
00:15:23 <mgdtgd> codacola: only on Saturday nights
00:15:49 <olsner> but ghc doesn't compile C code, so how is that a fair comparison of C compilers? :P
00:15:57 <_zenon_> mgdtgd, ah, then you should use it in conjunction with the saturday-night flag
00:16:03 <codacola> arr, i want to install linux but scared ill do something thatll screwup my vista install. why cant hp just give out vista dvds with their laptops?
00:16:35 <_zenon_> codacola, most new linux dists should be able to partition the drive during install and move all memory blocks neatly to the side
00:16:48 <codacola> shouldnt one of those s's be a u?
00:16:54 <wkh> codacola, try a vmware image first?
00:17:03 <mgdtgd> codcola: even if you screw up vista, nothing is lost
00:17:03 <_zenon_> but I agree, it sucks balls that you don't get a backup cd nowadays, even though you DID pay for that license
00:17:16 <codacola> _zenon_: yeh they can i think, problem is theres still the risk something weird will go wrong
00:17:43 <codacola> _zenon_: yeah thats what i thought. ive even got a vista license thingie stampped on the bottom of the laptop, yet all i get is the "right" to make 1 set of backup cds
00:17:44 <_zenon_> mgdtgd, :D hehe
00:17:56 <_zenon_> codacola, sucks balls
00:17:57 <codacola> and of course that screwed up halfway and ive lost 1 of the cds
00:18:26 <codacola> but i can now get a vista dvd from the university for free, which is cool
00:18:30 <_zenon_> What sucks the MOST, are the resellers that won't accept the laptop for a rutine check while ON GARANTY, since you installed debian on it
00:18:46 <_zenon_> "No, I can't do that, you altered the computer, the waranty is void"
00:18:57 <mgdtgd> codacola: just don't try bsd, http://xkcd.com/349/
00:18:58 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
00:19:04 <codacola> _zenon_: when i was looking at mine i said to them quite clearly "will installing linux on here void the warrenty", just so i had someone to blame if it did
00:19:17 <_zenon_> mgdtgd, that one is priceless :!!
00:19:30 <_zenon_> codacola, good.
00:20:32 <codacola> heh, i did get it under warrenty last time
00:21:10 <codacola> weird story. i was working all day so couldnt ring the people who reimage them, so got mum to do it, and she didnt know what id done, and she said something weird had happened and id lost everything
00:21:21 <codacola> and the woman goes "oh well we'll gert it under warrenty then"
00:21:32 <codacola> so i formatted it completely before sending it :P
00:21:57 <_zenon_> codacola, hehe a safe bet
00:22:09 <codacola> oh theres an idea. i could simply use another hdd
00:22:10 <_zenon_> better not encrypt the hard drive though
00:22:28 <_zenon_> they'll send the computer to the NSA and homeland security from the U.S will bust your house :P
00:22:40 <_zenon_> codacola, of course.
00:22:48 <_zenon_> but nuke the disk first
00:22:57 <codacola> its kind of amussing how easy warrenties are. no one even bothers to check them
00:23:16 <codacola> i was working for an electrical place for a few weeks. this woman had an old washing machine, and the guy simply backdated it a year to get it under warrenty
00:24:03 <codacola> another was for a drill. the switch was stuffed (quite common), and so it went under warrenty. i changed the switches over, and said "um, still doesnt work"
00:24:18 <codacola> wasnt the switch in the end :P
00:24:31 <_zenon_> well, some people on the earth ARE good people with goodwill
00:24:37 <_zenon_> however, ONOFF is not one of those places
00:24:46 <_zenon_> worst shop in the world.
00:24:46 <codacola> onoff?
00:25:04 <codacola> ah
00:25:05 <codacola> why?
00:25:06 <_zenon_> a bunch of newbies without any knowledge of technology
00:25:18 <_zenon_> everyone in the store is just a seller.
00:25:33 <codacola> ah yeah, ive been to plenty of stores like that
00:26:06 <_zenon_> that's where I was 4 f*cking hours with my girlfriends laptop, trying to make them agree to fix her broken DVD-Reader, but they wouldn't cause it had ubuntu (another story as well) which voided warranty
00:26:27 <codacola> whereas the one i go to now is quite good. went in to get a remote for my camera, she said she cant help me since there were no camera people in there at the time, so had to wait until someone who actually knows something came back
00:26:38 <codacola> which id prefer to someone with no knowledge just trying to make a sale
00:27:46 <codacola> i bought a custom made system once, and then the cd writer stuffed up, so rang them up, asked if id have to bring the whole computer in, he said "nah just bring the writer back in", so did so, a few days later i had a 48x (i think, the origional was a lot slower)
00:28:00 <codacola> funny enough that one broke too
00:28:29 <_zenon_> you seem to have a knack for the good folks
00:28:49 <codacola> i just run away from teh stores that dont serve me well :P
00:29:12 <codacola> i wont go to one of them anymore simply because the staff are lazy. asked someone where the headphones are, they just pointed
00:29:19 <codacola> so walked over there, $200+ headphones
00:29:31 <codacola> so asked someone else, they pointed as well, eventually found them on my own
00:29:37 <_zenon_> but lazy is good!
00:30:01 <codacola> howso?
00:30:24 <codacola> well it is to a degree, but not when you want them to do something
00:30:37 <_zenon_> haskell is lazy
00:31:42 <codacola> anyways, as a result the good store managed to get me to buy a laptop, a camera (dslr), and various other things
00:31:57 <codacola> within a years time, not bad for whoever was getting commission
00:32:58 * codacola hates shopping for laptops offline
00:33:04 <codacola> went in with a $1000 budget when i got this
00:33:17 <codacola> saw something and thought "guess i could go with $1500"
00:33:24 <codacola> then saw this "guess i could go with $2000"
00:33:29 <_zenon_> uhoh, price drifting :)
00:33:57 <codacola> went in to get my camera, thank god theres such a gap between entry level and "the rest" of the dslrs
00:34:03 <codacola> went from $1300 to $1500
00:34:25 <glguy_> 1500 is entry level?
00:34:38 <codacola> yeah, had 2 lenses
00:34:42 * hml buys cameras in the $150.00 range ...
00:34:47 <hml> digital cameras too
00:34:48 <codacola> dslr
00:34:54 <hml> what's dslr?
00:34:59 <glguy_> digital single lens reflex
00:35:08 <hml> went over my head
00:35:11 <hml> what's so great about it
00:35:37 <codacola> the best thing about it is removable lenses :P
00:35:48 <codacola> dont have to stick with 1 lens for everything
00:36:20 <codacola> http://www.kenrockwell.com/nikon/d40x/images/d40x.jpg <- thats mine
00:36:45 <codacola> btw $1500 to me is $1100 to you (im in nz)
00:37:10 <hml> so dslrs start at 1K ?
00:37:11 <_zenon_> kamera porn
00:39:31 <mgdtgd> I wish I could afford a dslr
00:40:04 <hml> lol; i know of someone who picked a kinesis ergo over a dslr
00:40:08 <codacola> nope, that was $500 usd without the lenses
00:40:19 <mgdtgd> but even if I could I'd have a hard time justifying spending so much money at a time to myself
00:41:02 <codacola> mgdtgd: i do too. but my attitude seems to change the moment im in a store :P
00:42:28 <mgdtgd> My reasoning always goes something like this: Either I buy this gizmo and have fun for a year or two or I could bring my money to a bank ang get EXPONENTIAL GROWTH mwhahaha
00:43:05 <hml> hmm;  are you in a couhntry whnere interest rate is more than inflation?
00:44:09 <mgdtgd> it's a bit above 3% here, while the banks offer 4-5% on saving accounts
00:45:06 <codacola> but if youre going to have your money in there for a long term wouldnt it make more sense to throw it into one of those long term accounts? (cant access it for a year, but increased interest....)
00:45:24 <hml> or ... as a hakell programmer; write your own finance investing routines
00:46:20 <mgdtgd> codacola: yeah, but what if I really *need* that new shiny thing that's coming out next month?
00:46:58 <mgdtgd> hml: I thought about that, but I wouldn't trust my money to an artificial intelligence, even if I created it myself
00:47:27 <codacola> mgdtgd: just think about all that exponial interest as opposed to having fun ;)
00:47:51 <codacola> ok i should write soem more code
00:47:58 <codacola> still got something like 15 functions to write
00:48:44 <hml> anyone know of any haskell success stories in the web2.0 world?
00:49:43 <codacola> i wonder if i even need windows now. i could always use monodevelop and then use the university computers to create the "visual studio projects"
00:50:24 <mgdtgd> codacola: The only thing I use my windows machine nowadays is copying DVDs
00:50:50 <mgdtgd> codacola, I haven't found an alternative to DVDshrink
00:51:07 <codacola> i reinstalled it (ok got them to reimage it) just so i could use visual studio.
00:51:31 <codacola> id much prefer to use linux for haskell and prolog
00:52:00 <mgdtgd> codacola: Since I only code in Haskell and Java I don't need Visual Studio
00:52:22 <codacola> ive gotta use c# for 1 of my classes
00:53:51 <mgdtgd> codacola: mono should work, I believe
00:54:07 <mlh_> use F# and then use a decompiler to turn it into C# :-)
00:54:22 <_zenon_> only problem (as I remember) is that mono won't show graphics
00:54:49 <glguy_> it will do GUIs and primitive drawing operations
00:54:50 <glguy_> at least
00:55:02 <codacola> mgdtgd: problem is the VS "project" format. but i could just write my code with mono, then take that to university and use their labs to make sure it runs under vs
00:55:30 <Zao> codacola: Try cmake, see if it does C#?
00:55:50 <mgdtgd> codacola: possibly you could even use a remote desktop connection
00:56:16 <hml> athere's also vmware
00:56:17 <codacola> http://hpaste.org/9155?lines=true
00:56:19 <codacola> oops
00:56:22 <codacola> ignore that
00:56:34 <codacola> MonoDevelop now uses the MSBuild project format as its native file format. This improves compatibility with Visual Studio, and will allow MonoDevelop to transition to using xbuild/MSBuild as the build engine.
00:56:35 <codacola> cool
00:56:38 <codacola> should work then
00:57:01 <codacola> ok, monday ill write a dvd for vista at the university, come home, install both vista and linux, adn ignore windows :P
01:03:18 <_zenon_> codacola, Good!
01:03:27 <_zenon_> Leave the evil empire
01:22:20 <_zenon_> Hmm--
01:22:42 <_zenon_> Is there some meta-quickCheck tool?
01:22:51 <_zenon_> to quickcheck your quickcheck properties
01:23:00 <codacola> heh
01:23:06 <codacola> sorry, sounds amussing :P
01:23:12 <_zenon_> Maybe that's where you are supposed to show your haskell skillz :)
01:24:30 <codacola> i have none, so wouldnt be much of a show
01:24:33 <Saizan_> speaking of quickcheck, any suggestions on how to generate a random rose tree with n nodes?
01:25:28 <codacola> whats a rosetree?
01:26:27 <Saizan_> a tree where each node has a list of children
01:26:32 <Vq^> data RoseTree a = RoseTreeNode a [RoseTree a]
01:29:56 <masak> why "rose"?
01:30:06 <BeelsebobWork> also, why is that hard?
01:30:24 <BeelsebobWork> at each level generate an arbitrary integer less than the remaining number of nodes to be generated
01:30:34 <BeelsebobWork> and then generate an arbitrary list of that length
01:30:44 <BeelsebobWork> splitting the remaining nodes amongst them
01:30:47 <masak> that might not generate all trees with equal probability
01:31:07 <BeelsebobWork> true dat
01:31:18 <BeelsebobWork> but then very few quickcheck generators do
01:31:24 <masak> you'd want a probability function of some sort when generating the integer
01:31:27 <codacola> Saizan_: ah so basicly any tree that isnt a binary tree? (yeah, havent learnt much about trees yet)
01:31:29 <masak> BeelsebobWork: oh.
01:32:31 <masak> codacola: you could encode a binary tree as a rose tree also
01:32:33 <BeelsebobWork> masak: the list generator for example has a 20% chance of generating an empty list, a  16% chance of generating a 1 element list, a 12.8% chance of generating a 2 element list... etc
01:32:39 <masak> codacola: see http://www.haskell.org/haskellwiki/Algebraic_data_type
01:32:40 <lambdabot> Title: Algebraic data type - HaskellWiki
01:33:36 <Saizan_> BeelsebobWork: yeah, i was aiming for an uniform distribution :) not that it's so important
01:33:48 <masak> it might be
01:34:14 <BeelsebobWork> I'm more concerned about guarenteeing good program coverage than guarenteeing good distributions in tests
01:34:27 <BeelsebobWork> which I guess actually means coming up with the special cases more often
01:34:47 <_zenon_> Saizan_, You can control how plausible a generated entity is
01:35:13 <BeelsebobWork> indeed
01:35:21 <_zenon_> frequency :: [(Int, Gen a)] -> Gen a
01:35:31 <codacola> oh theres a good question. i saw a book on data structures in FP in the library, though it used ML. anyone know of any good ones for haskell?
01:35:52 <BeelsebobWork> arbitrary on lists is frequeency [(1,[]),(4,liftM2 (:) arbitrary arbitrary)]
01:42:05 <Saizan_> that's a shame, it means that 1/5 of your tests will work on the same value..
01:44:18 <BeelsebobWork> yep, on the other hand, probably 50% of your program coverage comes from that 1/5 of tests
01:44:21 <BeelsebobWork> so it's probably a bit low
01:46:25 <_zenon_> Saizan_, Define your own datastruct for list and set the distribution
01:46:50 <BeelsebobWork> yep
01:46:50 <_zenon_> maybe a bit too much work
01:46:53 <codacola> curious. in real world programming, can you often test functions using a random number generator to produce lots of random input?
01:47:16 <BeelsebobWork> I'm in the middle of writing a makeHaskellArbitrary package taht adds a whole load of interesting generators for various types
01:47:20 <dolio> Depends on what you're doing.
01:47:49 <BeelsebobWork> codacola: in real world Haskell programming my experience is that generating random inputs does very well
01:48:11 <codacola> well not just haskell, in general real world programming
01:48:42 <Saizan_> i'm just surprised that it makes you run the same test with so much probability, and i understand better the concerns on having quickcheck properties in the standard library testsuite
01:48:46 <codacola> right now im doing exercises in a chapter where i have to create a list of test data by hand, just curious if in the real world youd setup a small program to spit out random input
01:49:37 <earthy> that's called QuickCheck
01:49:41 <earthy> :)
01:49:48 <BeelsebobWork> codacola: I don't have any experience of that at the moment -- just of using quickcheck in production
01:50:22 <earthy> but yeah, there are real world systems where random inputs get generated for stresstesting programs
01:50:39 <BeelsebobWork> in other languages you may have problems -- a lot of the reasons QC works for Haskell is strong type checking
01:50:45 <BeelsebobWork> so it may not be so good in other languages
01:50:45 <earthy> the big question there is to generate data with a wide enough spread to check all code paths
01:51:18 <BeelsebobWork> indeed -- I really want to combine QC with HPC
01:51:27 <BeelsebobWork> and just keep running tests until HPC says it's covered everything
01:52:02 <codacola> my reasoning was in the time its taking me to think of these values, i could have spent that time evulating what the result should have been from values a generator gave me
01:52:21 <codacola> plus in bigger functions in other languages you might get other weird issues that might only happen with a few values...
01:52:45 <codacola> i dunno, im avoiding my work :P
01:53:25 <BeelsebobWork> codacola: the problem is generating things that aren't integers
01:53:34 <BeelsebobWork> generating arbitrary data structures is hard
01:53:45 <BeelsebobWork> if you don't have strong type checking
01:53:58 <_zenon_> Well, I am using quickcheck now to test the sanity of my functions for simulation
01:54:56 <codacola> yeah. but lets try a situation. lets say youre developing a 2d game. has a map editor feature, and you want to test the map editor, how on earth do you go about that?
01:55:20 <BeelsebobWork> test things like parsing a map file and then unparsing it is the id function
01:57:35 <BeelsebobWork> (and the other way round)
02:02:35 <codacola> just remembered what my booltoint function was for. howManyAboveAverage a b c = boolToInt(a > average(a b c)) + boolToInt(b > average(a b c)) + boolToInt(c > average(a b c))
02:02:45 * codacola is easily amussed
02:06:00 <Saizan_> foo a b c = length . filter id . map (> average a b c) $ [a,b,c] ?
02:11:06 <yakov> hey
02:11:16 <codacola> hello
02:11:54 <yakov> guys, anybody remembers if ghc66 supports in proper way ffi+concurrent haskell?
02:14:13 <codacola> heh i should stop putting my code in a pastebin, if anyone decides to google it itll look like ive cheated
02:14:16 <RayNbow> @quote oleg
02:14:16 <lambdabot> <JohnMeacham> says: of course any minute now oleg is going to come along and actually express the second law of thermodynamics via functional dependencies as a purely incidental part of improving
02:14:16 <lambdabot> HList syntax or something.
02:14:42 <masak> @quote oleg
02:14:43 <lambdabot> audreyt says: assembly would require metaolegs (or megaolegs)
02:15:12 <codacola> @quote codacola
02:15:12 <lambdabot> No quotes match. It can only be attributed to human error.
02:15:16 <codacola> how sad :(
02:18:43 <hml> anyone know; how on x86_64, to build ghc that cranks out 32bit binaries?
02:19:03 <Zao> It'd probably be easiest in a full 32-bit chroot.
02:28:37 <codacola> annoying, cant find anything on the $ operator :P
02:29:56 <mgdtgd_> let's say I wanted to implement some kind of math captcha, as seen here: http://www.johnmwillis.com/other/top-10-worst-captchas/
02:29:57 <lambdabot> Title: Top 10 Worst Captchas | IT Management and Cloud Blog
02:30:11 <mgdtgd_> how would I generate them?
02:30:29 <catface> can you implement show for some types of an ADT and derive the rest?
02:32:20 <mgdtgd_> alternatively, where do I optain a huge pile of math problems with solutions?
02:33:12 <masak> mgdtgd_: project euler?
02:34:11 <Zao> masak: You'd have to solve those yourself.
02:34:15 <mgdtgd_> masak: I doubt those are solvable in under 5 minutes
02:34:30 <mgdtgd_> masak: good idea though
02:34:36 <Zao> I assume that mgdtgd_ is looking for questions like " what's 356 added to 232, if all threes are twos"
02:34:58 <RayNbow> mgdtgd: Project Euler problems are meant to be solvable in under 1 minute though ;)
02:35:00 <masak> Zao: oh. well, one could generate those fairly easily
02:35:33 <mgdtgd_> zao: no, those aren't challenging enoug
02:35:45 <mgdtgd_> some calculus should be required
03:20:46 <lomeo> "Implementing the darcs patch formalism and verifying it" not found.
03:36:02 <sannysanoff> @pl collectNeighbours tri >>= return . filter (\t -> not (S.member t excluded))
03:36:02 <lambdabot> filter (not . flip S.member excluded) `fmap` collectNeighbours tri
03:37:06 <Pistahh> is there something for ghc which is like pydoc or perldoc?
03:37:12 <Pistahh> (on linux)
03:37:20 <sannysanoff> haddock
03:37:21 <sannysanoff> ?
03:37:59 * Pistahh chedcks
03:41:04 <Pistahh> no, pydoc and perldoc are like a manpage browser
03:41:29 <Pistahh> pydoc e.g. pydoc sys.exit gives the description about that function
03:41:50 <codacola> http://mibbit.com/pb/1clwTQ  <- heh
03:41:50 <lambdabot> Title: Mibbit: PasteBin
03:43:32 <Axman6> codacola: yuck
03:43:49 <Axman6> code repetition ftl
03:44:44 <Axman6> looks like something you could use map and sum for
03:45:44 <hackage> Uploaded to hackage: yi 0.4
03:47:18 <Axman6> @t zipWith
03:47:18 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
03:47:24 <Axman6> @type zipWith
03:47:25 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
03:47:25 <pozic> Is there any criterion for choosing at design time whether or not to use a state monad?
03:48:40 <Botje> codacola: length [ () | let s = [a,b,c,d], x <- s, y <- s, guard $ x == y ] - 4
03:48:41 <ski> @type maximum . map length . group . sort
03:48:42 <lambdabot> forall a. (Ord a) => [a] -> Int
03:49:02 <Botje> of course that's still double ..
03:49:12 <Botje> hmm
03:49:42 <Botje> length s - length (nub s) + 1 ?
03:49:46 <Cale> pozic: Well, to some extent. If you can imagine writing code that does a lot of fiddly parameter passing to keep track of what is essentially a state variable, then making use of a state monad there might help.
03:50:49 <ski> Botje : `[0,0,1,1]' ?
03:51:41 <Twey> @src filter
03:51:42 <lambdabot> filter _ []     = []
03:51:42 <lambdabot> filter p (x:xs)
03:51:42 <lambdabot>     | p x       = x : filter p xs
03:51:42 <lambdabot>     | otherwise = filter p xs
03:51:47 <lilachaze> pozic: i guess if your data model really doesn't work unless it's mutable, you might consider using ST.
03:51:53 <pozic> Cale: I am now building something for which I don't understand the domain yet, so I now need to add a parameter to all the functions calling the current one. I think it's best to group everything that's physically also tied together.
03:52:02 <pozic> lilachaze: state monad is not about mutability.
03:52:56 <osfameron> it is kind of about giving the illusion of, and convenience of mutability, isn't it?
03:53:20 <codacola> Botje: list comprehensions havent been defined by this stage of the book :P
03:53:23 <pozic> osfameron: sort of.
03:53:26 <Cale> osfameron: To some extent, yeah.
03:53:57 <ski> `State' gives you one global mutable state variable
03:54:08 <Cale> I find that even if you're not using a state monad, grouping your 'state' together into a single datastructure helps a great deal to keep things tidy.
03:54:11 <RayNbow> howManyEqualOfFour a b c d = (maximum . map length . group . sort) [a,b,c,d]  -- how about this one?
03:54:24 <codacola> map hasnt been mentioned either
03:54:38 <steven_ashley> why such a complex problem so early?
03:54:42 <steven_ashley> (before map)
03:54:45 <codacola> anyways, got a smaller definition now, and im happy with it
03:54:49 <ski> RayNbow : yes, i mentioned that above :)
03:54:50 <codacola> i dunno
03:54:59 <codacola> im just doing the exercises i have to :P
03:55:02 <pozic> Cale: so, instead of f extraParameter oldParameter = undefined, it would be f datastructureHoldingExtraParameterAndOldParameter.
03:55:03 <codacola> got 8 to go
03:55:12 <lilachaze> pozic: i'm not sure i agree. HashTable lives in IO basically for mutability reasons (and arguably it should be in ST)
03:55:20 <Cale> pozic: yeah
03:55:28 <Philippa> Cale: give or take. I swear my biggest use for extensible records is in bundling up state
03:55:33 <Cale> lilachaze: In other news, never use Data.HashTable
03:55:39 <RayNbow> ski: bah... sometimes #haskell goes too fast... :p
03:55:57 <lilachaze> Cale: that seems a little draconian :) is there a better hash table somewhere in the libraries?
03:56:02 <Cale> (since it always performs worse than Data.Map, and is less scalable)
03:56:04 <pozic> Ski is correct.
03:56:15 <lilachaze> *blink*
03:56:16 <ski> i am ?
03:56:17 <Cale> (and is restricted to the IO monad)
03:56:52 <lilachaze> Cale: did someone seriously mess up the implementation?
03:56:54 <RayNbow> but is ski sound and complete? ;)
03:56:58 <pozic> Most of the times when you need mutability, you need a lot of mutable locations (that's when you use ST/IO).
03:57:08 <Cale> lilachaze: No, they just wrote a rather naive implementation.
03:57:18 <osfameron> Cale: *always*?  I thought hashtables were generally quite efficient apart from some pathological cases?
03:57:23 <pozic> RayNbow: with respect to what semantics?
03:57:26 <Cale> lilachaze: Hash tables are quite hard to get right :)
03:57:29 * ski can complete a sound
03:57:41 <pozic> ski: but I can never hear you
03:57:44 <osfameron> ah ok
03:57:48 <Cale> osfameron: Well, I'm specifically referring to the one in the libraries.
03:57:56 <osfameron> fair enough then
03:58:10 <steven_ashley> RayNbow, ski:  howManyEqualOfFour 1 2 3 4 = 1
03:58:14 <osfameron> and I do see why it's bad structure for pure functional
03:58:22 <pozic> Anybody else who used the dimensional library?
03:58:29 <Cale> But in general, it's actually a lot harder to get a hashtable implementation which reliably outperforms a decent balanced tree.
03:58:30 <ski> steven_ashley : yes ?
03:58:47 <ski> > (maximum . map length . group . sort) [1,2,3,4]
03:58:48 <lambdabot>  1
03:59:04 <steven_ashley> ski: shouldnt it be 0? unless I am mis-interpreting something
03:59:05 <pozic> I used it and unfortunately the type level numbers give bad error messages, but it's not that hard to use.
03:59:24 <RayNbow> hmm...
03:59:24 <O_4> Can someone explain to me what '$=' is used for?
03:59:31 <O_4> It's not an easy term to google for :-/
03:59:40 <Axman6> @src ($=)
03:59:40 <lambdabot> Source not found. :(
03:59:44 <Botje> @hoogle ($=)
03:59:45 <lambdabot> No matches found
03:59:49 <pozic> O_4: aren't that the properties in GTK2HS?
03:59:56 <Axman6> @type ($=)
03:59:57 <Cale> O_4: Depends on which library you're using exactly...
03:59:57 <lambdabot> Not in scope: `$='
04:00:02 <steven_ashley> O_4: they are in OpenGL also
04:00:03 <O_4> I don't know, this is in HOpenGL
04:00:19 <steven_ashley> they are used for assigning properties
04:00:20 <ski> steven_ashley : we're partitioning the bag into a set of bags, one for each kind of element, and then want the maximum cardinality of the bags .. seems to me the minimum value possible would be `1'
04:00:27 <O_4> I'd guess "state var assignment", but assumptions don't make me comfortable :-p
04:00:36 <steven_ashley> ahh sure, that makes sense
04:00:43 <Cale> O_4: yeah, that's right
04:00:56 <Cale> O_4: http://www.haskell.org/ghc/docs/latest/html/libraries/OpenGL/Graphics-Rendering-OpenGL-GL-StateVar.html
04:00:57 <lambdabot> Title: Graphics.Rendering.OpenGL.GL.StateVar, http://tinyurl.com/24hd3h
04:01:02 <Cale> See the documentation there :)
04:01:05 <ski> steven_ashley : of course, i may have misunderstood the problem .. codacola didn't specify it
04:01:15 <Cale> Basically it sets things which have a defined way to set them :)
04:01:28 <O_4> Cale: ah, I see
04:01:32 <O_4> Thanks
04:02:56 <O_4> Also, in a line like "reshape size@(Size w h) = do", does the '@' mean something like "match the one arg against both these patterns" ?
04:03:38 <xerox> It's a synonym, the argument of the function reshape is called size, and it has the shape (Size w h), both at one time.
04:03:39 <ski> O_4 : it means, name the matched value by the first part, an identifier, and match against the second part, a pattern
04:04:17 <ski> so the syntax is `<identifier> @ <pattern>'
04:04:23 <dolio> > let f (x:_)@(_:xs) = x:xs in f [1,2,3]
04:04:24 <lambdabot>  Parse error at "@(_:x..." (column 12)
04:04:31 <_zenon_> It's called As-pattern
04:04:41 <O_4> Right, so you can't use it to combine arbitrary patterns, it just allows you to assign to an identifier and match a pattern.
04:04:42 <RayNbow> > let duplicateHead list@(x:xs) = x : list   in    duplicateHead [1..4]
04:04:43 <lambdabot>  [1,1,2,3,4]
04:05:04 <O_4> Cool, thanks :-)
04:05:10 <ski> O_4 : yes .. if it allowed matching against two patterns, it would be an `and'-pattern
04:05:36 <ski> (there's also `or'-patterns, in O'Caml e.g., but alas not in Haskell)
04:06:09 <dolio> Yeah, those come in handy sometimes.
04:06:14 <ToRA> > let duplicateHead list@(~(x:xs)) = if null list then [] else x:list in duplicateHead []
04:06:16 <lambdabot>  []
04:16:41 <Toxaris> > let duplicateHead list = if null list then [] else head list : list in duplicateHead []
04:16:42 <lambdabot>  []
04:16:58 <Toxaris> no need to use scary pattern constructs like @ and ~
04:17:16 <Twey> Erm
04:18:35 <Twey> > let duplicateHead [] = []; duplicateHead s@(x:_) = x : s in duplicateHead [3, 4]
04:18:37 <lambdabot>  [3,3,4]
04:18:40 <Twey> > let duplicateHead [] = []; duplicateHead s@(x:_) = x : s in duplicateHead []
04:18:41 <lambdabot>  []
04:19:02 <ToRA> > let duplicateHead list = fromMaybe [] . fmap (:list) . listToMaybe $ list in duplicateHead []
04:19:03 <lambdabot>  []
04:20:04 <_zenon_> "scary" :)
04:20:15 <Twey> Mine was unscary :<
04:20:34 <Twey> Very simple.
04:21:02 <_zenon_> http://www.haskell.org/haskellwiki/Keywords#.7E
04:21:03 <lambdabot> Title: Keywords - HaskellWiki
04:30:31 <dolio> > 3 :+ 4
04:30:33 <lambdabot>  3.0 :+ 4.0
04:34:36 <steven_ashley> Can anyone hint me as to which of these is considered better style:
04:34:36 <steven_ashley> IO (Either a a)
04:34:36 <steven_ashley> IO (a, Bool)
04:34:36 <steven_ashley> The flag returned is whether the function should be called again in future.
04:35:29 <Cale> I'd probably go with the latter, myself.
04:36:18 <mgdtgd> me too. To make it more descriptive you could use an alias for Bool, like type Again = Bool
04:36:20 <_zenon_> the more general the nicer
04:39:38 <Toxaris> I would consider (Either a a) if the a's have different meaning, but the same type by chance
04:40:31 <Toxaris> e.g. if (Left x) means "call me with x again", and (Right x) means "x is the result"
04:40:37 <Toxaris> so one x is input, the other is output
04:41:11 <steven_ashley> I agree :)
04:41:20 <steven_ashley> Toxaris: they have the same meaning
04:41:25 <_zenon_> more general = better
04:41:34 * _zenon_ is stuck in a loop
04:41:36 <steven_ashley> I was looking at http://www.haskell.org/haskellwiki/WebApplicationInterface#Specification_Overview
04:41:37 <lambdabot> Title: WebApplicationInterface - HaskellWiki, http://tinyurl.com/5mwzys
04:41:40 <dolio> Are you branching immediately, or is there shared code between the two paths?
04:42:09 <phlpp> @src iterate
04:42:09 <lambdabot> iterate f x =  x : iterate f (f x)
04:42:24 <dolio> Or, I should say, do you use the a separately from the information about whether you should call again?
04:42:44 <dolio> If not, then I'd go with Either. Otherwise with Bool.
04:42:45 <Axman6> > iterate (^2) 2
04:42:48 <lambdabot>  [2,4,16,256,65536,4294967296,18446744073709551616,34028236692093846346337460...
04:43:05 <Toxaris> :t join (+++)
04:43:05 <lambdabot> forall (a :: * -> * -> *) b c. (ArrowChoice a) => a b c -> a (Either b b) (Either c c)
04:43:09 <steven_ashley> dolio: ï»¿they are separate as far as I am concerned
04:43:09 <RayNbow> > iterate f x
04:43:10 <lambdabot>  [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (f...
04:43:47 <FordCortina> in a class declaration, Foo f where bar :: f -> f -> Int , both 'f's are the exact same type right?
04:44:04 <Botje> yes
04:44:08 <FordCortina> thanks
04:45:07 <just> GNU\caust1c
04:45:08 <just> o/
04:46:06 <dolio> Does anyone know if there's a way to get the GHC profiler to record information about what functions within a library are taking time?
04:46:30 <dolio> Or do I just have to import the code into my test application?
04:51:19 <steven_ashley> dolio: I would guess that you have to build it with the -prof flag
04:51:48 <dolio> I built the library with cabal's --enable-library-profiling.
04:52:03 <steven_ashley> ahh, I am out of ideas then
04:52:04 <dolio> But that doesn't insert any profiling annotations, I think.
04:52:12 <steven_ashley> I see
04:52:14 <dolio> Or use -auto or anything.
04:53:25 <codacola> is it just me or is the entire haskell syntax quite complex?
04:53:50 <osfameron> oh the syntax is quite easy
04:53:57 <osfameron> it's just the rest of it...
04:53:59 <steven_ashley> the indentation occasionally gets me
04:54:05 <steven_ashley> re: tabs and spaces
04:54:13 <RayNbow> Haskell programs cannot easily be parsed by a scannerless parser
04:54:39 <RayNbow> (a scannerless CFG parser that is)
04:55:16 <dolio> I mean, I wrote the library, so it's not that big a problem, but libraries are always just a black box as far as profiling goes in my experience.
04:55:24 <dolio> I wonder if that's a bad thing.
04:55:37 <steven_ashley> I think so
04:56:23 <steven_ashley> the more you know the better decisions you can make, especially regarding optimising your code
04:56:36 <dolio> I wonder if I can manually {-# SCC ... #-} annotate the library and have it show things.
04:58:14 <dolio> Ah, I can.
04:58:23 <steven_ashley> :)
04:59:19 <dolio> That's kind of a pain, though. I wonder if cabal has a way to turn on -auto-all and such.
05:01:02 <steven_ashley> in cabal
05:01:06 <steven_ashley> ghc-prof-options:               token list
05:02:46 <_zenon_> I really need a coffee now
05:02:47 <BeelsebobWork_> runhaskell Setup.lhs configure --enable-library-profiling I thought
05:04:56 <dolio> Awesome. Now we just need everyone to start adding that to their .cabal files.
05:20:27 <matthew-_> no
05:22:01 <dcoutts> dolio: no, adding -auto-all to .cabal files is a bad idea
05:22:10 <dcoutts> dolio: at least if you upload them to hackage like that
05:22:10 <dolio> It is?
05:22:21 <dcoutts> because you don't want SCCs in all of the libs you depend on
05:22:26 <dcoutts> that's too much
05:22:39 <dcoutts> you want them in the one package you're currently profiling
05:22:59 <dcoutts> or maybe, maybe, you want them in one or two dependent packages
05:23:03 <dcoutts> but not all of them
05:23:18 <dcoutts> if that was the solution then cabal would just use -auto-all everywhere without asking
05:23:25 <dolio> Well, when I'm profiling a library, I want them on that one package.
05:23:49 <osfameron> ooo, italian haskell workshop
05:23:51 <dolio> When I'm writing a program, I want to know, potentially, which calls to all the libraries I'm using are hosing me.
05:24:10 <dcoutts> dolio: http://hackage.haskell.org/trac/hackage/ticket/200
05:24:13 <lambdabot> Title: #200 (Allow more convenient use of ghc profiling options -auto and -auto-all) -  ...
05:24:13 <osfameron> bummer, anglohaskell *and* italohaskell clash with my holidays+perl conference :-(
05:24:56 <Twey> So who's going to be at Anglohaskell?  *interest*
05:25:05 * dcoutts will be
05:26:58 <dcoutts> dolio: so we can make it easier to profile this lib/exe as described in that ticket
05:29:49 <ivanm> speaking of anglohaskell and italohaskell... would anyone from down under be interested in having a haskell miniconf at linux.conf.au 09?
05:30:00 <ivanm> since ozhaskell doesn't seem to have eventuated as of yet :p
05:30:41 <dolio> dcoutts: I guess ideally what you'd want is two sets of profiling files for libraries, one with annotations and one without.
05:31:00 <steven_ashley> ivanm: woah, its in Tazmania :P
05:31:07 <dolio> And the ability to choose which one to build with on a per-package basis for your application.
05:31:21 <dcoutts> dolio: your point about finding which lib calls are expensive is an interesting one
05:31:28 <dcoutts> dolio: perhaps you can comment on the ticket
05:31:55 <Philippa> Twey: I'll be there
05:31:58 <dolio> Is the login the same as for the GHC trac?
05:32:18 <ivanm> steven_ashley: yeah, I know... that _could_ cause some problems... :p
05:32:58 <steven_ashley> ivanm: I went to the one in Sydney in 07, I'm in Christchurch
05:33:05 <ivanm> ahhhh
05:33:12 <ivanm> this year was my first
05:33:18 <steven_ashley> heh, mine too :P
05:33:36 <steven_ashley> Didn't go to it when it was in NZ :P
05:33:54 * osfameron considers a northwest(uk) haskell meeting.  I don't think anyone else here is in that area? But a fair few of the geekup lot are interested in FP, and might turn up to a talk if we got a good speaker
05:33:57 <Twey> Philippa: I'm wondering if I should go, being the newbie that I am :-)
05:33:58 <codacola> :O
05:34:03 <codacola> another kiwi in #haskell
05:34:12 <pozic> Is there a function that takes a function::a->Int and list of a and returns a s.t. f a is a global maximum?
05:34:19 <steven_ashley> codacola: I know of several
05:34:20 <steven_ashley> :)
05:34:26 <codacola> :O
05:34:29 <steven_ashley> abrehaut, sitiveni
05:34:30 <codacola> ok i only know of me
05:35:06 <Philippa> Twey: go for it. The thing about something like this is that there's actually room for newbie questions if you don't get something in a talk, and plenty of room to pick stuff up from the more experienced folks
05:35:19 * RayNbow would be interested in a Haskell meeting... if there was one in the Netherlands :p
05:35:28 <hubmike2> hey
05:35:29 <xerox> ?type maximumBy
05:35:29 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
05:35:38 <hubmike2> mewbie question here
05:35:47 <Twey> Philippa: I see, hm... thanks :-)
05:35:52 <Twey> hubmike2: Fire away
05:35:56 <hubmike2> how do u just output a string on to main
05:36:11 <Twey> main = putStrLn "Some string" ?
05:36:15 <hubmike2> so main -> welcome
05:36:21 <hubmike2> ok thanks
05:36:26 <Cale> Twey: hey!
05:36:26 <codacola> ms is telling me on dialup i can download 3.5 gig in 14 hours
05:36:28 <RayNbow> main = putStrLn "Hello World" -- a better example :p
05:36:32 <Twey> Hi Cale :-)
05:36:36 <Zao> main has type    main :: IO ()
05:36:39 <Twey> Hahaha, RayNbow
05:36:45 <Zao> So any action of IO () type can be executed.
05:36:50 * Twey nods.
05:37:01 <steven_ashley> codacola: is that with xtra ;)?
05:37:25 <xerox> ?type maximumBy . comparing -- pozic
05:37:26 <lambdabot> forall b a. (Ord a) => (b -> a) -> [b] -> b
05:38:04 <steven_ashley> codacola: I love that "price of dialup" plan ($16.95) with a 200mb cap :P
05:38:46 <codacola> steven_ashley: im not on dialup, but been capped, so pretty much on dialup for now
05:39:00 <codacola> and just found out im allowed free copies of vista and xp
05:39:02 <hubmike2> ok how do u output 2 lines in main
05:39:16 <hubmike2> main =putStrLn "Hello World",putStrLn "Hello World"?
05:39:35 <steven_ashley> main = do putStrLn "Hello,"
05:39:36 <steven_ashley>                   putStrLn "World!"
05:39:36 <Cale> hubmike2: You can use do-notation to glue IO actions together into larger ones
05:39:40 <Twey> hubmike2: main = do { putStrLn "Hello World"; putStrLn "Hello World" }
05:39:42 <hubmike2> ah ok
05:39:47 <Twey> But, uh, you might want to read a tutorial
05:40:00 <ivanm> Twey: read a tutorial? what a ridiculous idea!
05:40:05 <pozic> xerox: yes, I already have it.
05:40:10 * Twey chuckles.
05:40:25 <Cale> #haskell is a continuous live tutorial :)
05:40:47 <Twey> The assumed skill level jumps back and forth a bit though :-P
05:40:59 * therp just loves the friendly atmosphere on this channel
05:41:14 <Cale> hehe, but we try to be beginner friendly :)
05:41:22 <gwern> huh. yi 0.4 is on hackage now
05:41:26 <gwern> how surprising
05:41:39 <gwern> yi 0.3 just went up, relatively speaking
05:42:09 <steven_ashley> gwern: only went up 2 hours ago :)
05:42:19 <Twey> 0.3 did?  o.@
05:42:29 <Twey> That *is* fast development
05:42:44 <steven_ashley> ï»¿ï»¿ï»¿(10:46:03 UTC) hackage:
05:42:44 <steven_ashley> Uploaded to hackage: yi 0.4
05:42:59 <gwern> Twey: well, given that it was like a year or something between 0.2 and 0.3, and only a few months between 0.3 and 0.4, it feels very quick
05:43:05 <codacola> i still fail to see how i can download 3.5 gig on 56k
05:43:11 <dogbite> what's the best way to take the sqrt of an Integer to produce a new Integer?
05:43:15 <steven_ashley> ahh hold on, its 12:46 utc*
05:43:31 <gwern> Cale: I see no new patches in the lambdabot repo...
05:43:32 <codacola> 12:47 by my watch :P
05:43:37 <Twey> gwern: Haha, aye.
05:43:37 * gwern frowns in his general direction
05:43:42 <Twey> codacola: Very slowly.
05:43:49 <Cale> gwern: I recorded the patch in my local repo, but hadn't pushed it
05:44:08 <Cale> gwern: If you want, I can do that now
05:44:18 <steven_ashley> ï»¿codacola: on 56k not possible in a day, if you have been capped sometimes they 'forget' to cap your connection
05:44:20 <gwern> ...how do you take the time to flush, record, and so on, but not do one last little command?
05:44:43 <steven_ashley> codacola: I had a friend that went over every month and never had any kind of speed limit applied .. :/
05:45:06 <codacola> steven_ashley: i havent even tried yet,. but the estimates on the ms site claim 14 hours on 56k, and 7 hours on a 1mb connection
05:45:16 <gwern> 'Oh, I just built a working full-scale model of the Titanic this morning. I suppose I should christen it with a bottle of wine, but meh - I just can't be arsed.'
05:45:16 <Cale> gwern: just didn't think of it
05:45:18 <dogbite> floor . sqrt . fromIntegral
05:45:32 <EvilTerran> dogbite, (\n -> head $ dropWhile ((<n).(^2)) [0..]) -- this works pretty well
05:45:34 <codacola> steven_ashley: back home i had an uncapped connection. not used to this :|
05:45:37 <EvilTerran> don't use sqrt
05:45:39 <gwern> (whee, huge yi compile errors)
05:45:52 <EvilTerran> dogbite, you don't want to be using floating point for an integer operation
05:46:11 <Cale> However, there's no library function for integer sqrt included with GHC.
05:46:19 <codacola> steven_ashley: i wanna get linux installed. might just install it tomorrow, leave 20 gig free, and install vista again on monday after i get a copy from massey
05:46:22 <EvilTerran> you can get a better complexity than mine using a fancier recursion, but it's not usually worth the hassle
05:46:24 <Cale> So you'll have to either get something from Hackage or write one yourself.
05:46:25 <steven_ashley> codacola: where is home?
05:46:40 <codacola> says on the whiteboard that theres isos of the software in their labs
05:46:44 <Cale> If you only need the integer square root for relatively small values, going via floating point isn't so bad.
05:46:52 <codacola> invercargill, moved to palmerston north 2 weeks ago
05:47:01 <Cale> But it's going to be inaccurate for large values.
05:47:28 <steven_ashley> codacola: sometimes they are student editions, or restricted in some way
05:47:33 <EvilTerran> @scheck \x -> (floor . sqrt . fromIntegral) x == (head $ dropWhile ((<x).(^2)) [0..])
05:47:35 <lambdabot>     Failed to load interface for `SmallCheck':
05:47:35 <lambdabot>       Use -v to see a list of ...
05:47:38 <EvilTerran> @check \x -> (floor . sqrt . fromIntegral) x == (head $ dropWhile ((<x).(^2)) [0..])
05:47:39 <codacola> steven_ashley: business edition
05:47:43 <lambdabot>  Falsifiable, after 3 tests: -1
05:47:59 <EvilTerran> @check \x -> (x >= 0) ==> ((floor . sqrt . fromIntegral) x == (head $ dropWhile ((<x).(^2)) [0..]))
05:47:59 <lambdabot>  Falsifiable, after 15 tests: 8
05:48:01 <codacola> steven_ashley: plus i dont want windows. just need it for visual studio
05:48:08 <EvilTerran> > floor . sqrt . fromIntegral $ 8
05:48:10 <lambdabot>  2
05:48:30 <EvilTerran> > head $ dropWhile ((<8).(^2)) [0..])
05:48:31 <lambdabot> Unbalanced parentheses
05:48:33 <EvilTerran> > head $ dropWhile ((<8).(^2)) [0..]
05:48:35 <lambdabot>  3
05:48:45 <steven_ashley> codacola: yep, dual-booting ubuntu / vista here, ubuntu as primary, only use vista for gaming really
05:48:46 <EvilTerran> hm
05:48:50 <Twey> Is there any sort of plugin architecture for Haskell?  And how does it work?
05:48:53 <EvilTerran> i've done something wrong here
05:49:23 <Twey> EvilTerran: ?  Looks right to me
05:49:24 <hubmike2> is there any quick way i can sum the 3rd component in x tuples  in a list of tuples
05:49:31 <Twey> 4 ^ 2 = 16
05:49:34 <Twey> Oh wait.
05:49:37 <steven_ashley> Twey: http://www.cse.unsw.edu.au/~dons/hs-plugins/ may be of interest
05:49:39 <lambdabot> Title: hs-pluginsDynamically Loaded Haskell Modules
05:49:39 <hubmike2> the component is an INT
05:49:40 <mattam> Off by one.
05:49:41 <Twey> 3 ^ 2 = 9 *headdesk*
05:49:46 <steven_ashley> Twey: no idea how it works ;)
05:49:56 <Twey> Hmn hmn hmn.
05:49:59 <Twey> steven_ashley: Thanks :-)
05:50:01 <gwern> steven_ashley: don't recommend hs-plugins, its deprecated
05:50:12 <Twey> Oh!
05:50:12 <steven_ashley> ahh, sorry, didnt realise
05:50:14 <Twey> What for?
05:50:42 <codacola> steven_ashley: the problem is i dont have a vista dvd here, just one of those stupid backup things. so this will give me an easy way to make sure ive got a real vista dvd sitting here if i ever need to reinstall it
05:51:07 <steven_ashley> gwern: is there a replacement lib?
05:51:54 <Cale> @check \x -> (x >= 0) ==> ((floor . (sqrt :: CReal -> CReal) . fromIntegral) x == (head $ dropWhile ((<x).(^2)) [0..]))
05:51:57 <lambdabot>  Falsifiable, after 1 tests: 3
05:52:04 <gwern> steven_ashley: I think we're supposed to use the GHC API
05:52:05 <EvilTerran> @let isqrt x = chop 0 $ head $ dropWhile (<x) (iterate (*2) 1) where chop lo hi | (lo >= hi-1) = lo | (mid^2 <= x) = chop mid hi | otherwise = chop mid hi where mid = (lo + hi) `div` 2
05:52:11 <lambdabot> Defined.
05:52:29 <hubmike2> any ideas guys?
05:52:30 <EvilTerran> > map (isqrt &&& floor.sqrt.fromIntegral) [0..]
05:52:31 <lambdabot>  [(0,0),(0,1),(1,1),(3,1),(3,2),(7,2),(7,2),(7,2),(7,2),(15,3),(15,3),(15,3),...
05:52:39 <EvilTerran> hm
05:52:47 <Cale> hehe
05:52:59 <EvilTerran> i hate how much thinking i seem to need for binary chop searches =/
05:53:10 <steven_ashley> Twey: I guess this is what you want then, http://www.haskell.org/haskellwiki/GHC/As_a_library
05:53:11 <lambdabot> Title: GHC/As a library - HaskellWiki
05:53:12 <EvilTerran> so much scope for off-by-one errors
05:53:13 <Cale> It really should be last / takeWhile
05:53:15 <EvilTerran> @undef
05:53:15 <lambdabot> Undefined.
05:53:34 <Cale> (I think)
05:53:42 <EvilTerran> Cale, that last one really should be head/dropWhile, as it's finding an upper bound in O(x) time
05:54:11 <Cale> @let isqrtByCReal x = floor . (sqrt :: CReal -> CReal) . fromIntegral $ x
05:54:12 <lambdabot> Defined.
05:54:28 <Cale> That *should* be correct :)
05:55:25 <EvilTerran> > let isqrt x = chop (hi `div` 2) hi where hi = head $ dropWhile (<x) (iterate (*2) 1); chop lo hi | (lo >= hi - 1) = lo | (mid^2 <= x) = chop mid hi | otherwise = chop lo mid where mid = (lo + hi) `div` 2 in map isqrt [0..]
05:55:26 <lambdabot>  [0,0,1,2,2,4,4,4,4,8,8,8,8,8,8,8,8,16,16,16,16,16,16,16,16,16,16,16,16,16,16...
05:55:37 <Cale> mmm
05:55:38 <EvilTerran> > map isqrtByCReal [0..]
05:55:40 <lambdabot>  [0,1,1,1,2,2,2,2,2,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,6,6...
05:55:50 <EvilTerran> ....
05:55:54 <EvilTerran> i'm still doing something wrong
05:56:50 <tromp> your low it too high?
05:56:52 <mar77a> morninghttp://rafb.net/p/vlshj393.html
05:56:52 <lambdabot> Title: Nopaste - bitstream
05:56:56 <mar77a> ugrh
05:56:57 <tromp> is
05:57:01 <mar77a> gatdamn right click
05:57:22 <Cale> iterate (*2) 1  is the sequence of powers of 2
05:57:35 <EvilTerran> s/O(x)/O(log x)/
05:57:54 <EvilTerran> sorry, that's the point of that iterate - it's to find the upper bound in O(log x) time instead of O(x)
05:58:00 <Cale> mm
05:58:07 <EvilTerran> and then the binary search should be O(log x) as well
05:58:19 <Cale> yeah
05:58:28 <Cale> I see what you're getting at
05:59:19 <Cale> So something is going wrong with chop, it's always giving a power of 2 somehow
05:59:31 <tromp> it's just giving the lower bound
05:59:45 <tromp> which was too high to start with
05:59:52 <mattam> @check \x -> (x >= 0) ==> ((floor . (sqrt :: CReal -> CReal) . fromIntegral) x == (last $ takeWhile ((<=x).(^2)) [0..]))
05:59:54 <lambdabot>  OK, passed 500 tests.
05:59:59 <EvilTerran> > let isqrt x = chop 0 hi where hi = head $ dropWhile (<x) (iterate (*2) 1); chop lo hi | (lo >= hi - 1) = lo | (mid^2 <= x) = chop mid hi | otherwise = chop lo mid where mid = (lo + hi) `div` 2 in map isqrt [0..]
06:00:01 <lambdabot>  [0,0,1,1,2,2,2,2,2,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,6,6...
06:00:48 <EvilTerran> that looks a little closer to reality
06:02:06 <Cale> I wonder what happened with 1
06:02:39 <Cale> isqrt 1 = chop 0 hi where hi = head $ dropWhile (<1) (iterate (*2) 1)
06:02:54 <Cale> isqrt 1 = chop 0 1
06:03:27 <Cale> chop 0 1 | (0 >= 1 - 1) = 0
06:03:58 <Cale> that first guard is matching...
06:04:22 <ziman> > map head . groupBy ((==) `on` snd) . map (id &&& isqrt) $ [1..]
06:04:27 <lambdabot>  [(1,1),(4,2),(9,3),(16,4),(25,5),(36,6),(49,7),(64,8),(81,9),(100,10),(121,1...
06:04:28 <Twey> How does one return an exit code from a Haskell program?
06:04:39 <pozic> How is average defined for an empty list of numbers?
06:04:50 <pozic> I would say undefined.
06:04:50 <Twey> pozic: I would say _|_
06:04:51 <Cale> Twey: System.Exit.exitWith
06:04:51 <xerox> it's not
06:04:56 <Twey> Cale: Ah, thanks
06:05:05 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Exit.html
06:05:06 <lambdabot> Title: System.Exit, http://tinyurl.com/yyce5n
06:05:11 * Twey nods.
06:08:57 <Cale> EvilTerran: It looks like 1 is the only value for which your implementation is incorrect.
06:09:08 <Cale> So it could just be special-cased :)
06:11:12 <Twey> I can't seem to get the Network module to compile: http://hpaste.org/9157
06:11:30 <Twey> Library, even.
06:13:10 * Cale looks
06:13:23 <Cale> hpaste is slow today...
06:13:36 <Cale> hmm
06:14:43 <welterde> hi!
06:15:36 <Twey> Cale: Sorry, there's a bit more, annotated
06:15:51 <Cale> welterde: hello
06:15:59 * Twey waves to welterde.
06:16:18 * welterde waves back
06:17:08 <Cale> Twey: Out of interest, where'd you get your copy of GHC?
06:17:17 <Cale> (normally it comes with that package)
06:17:21 <Twey> Cale: Portage
06:17:22 <Twey> Hmn
06:17:29 <Twey> Maybe I'm missing a USE flag *checks*
06:17:58 <ziman> Twey, are you installing tha Netwrok package via portage?
06:18:00 <sw17ch> Tewy: I've noticed that the ghc in portage leaves out a bunch of packages
06:18:02 <Cale> Also, compiling GHC yourself usually isn't recommended unless you're hacking on it... there are good binary packages.
06:18:07 <Twey> ziman: Aye
06:18:22 <ziman> i had no problems with that
06:18:26 <sw17ch> you need to either install them through portage, or (my favorite way) install them with cabal install
06:18:42 <sw17ch> actually, the versions in portage are often quite out of date in my experience :(
06:19:22 <ziman> just be sure to unmask all ghc-related packages if you unmask ghc (i mean the ~arch keyword)
06:19:39 <Twey> Really?  6.8.2?
06:19:50 <ziman> 6.8.2 is ~arch in gentoo, iirc
06:19:52 <Twey> Yeah
06:19:59 <Twey> I'm running ~arch on here
06:20:08 <welterde> is there a file-path-package somewhere?
06:20:22 <welterde> (because it seems like the fink-package of ghc misses it)
06:20:29 <Cale> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/filepath
06:20:30 <Twey> welterde: There's one called 'filepath'
06:20:32 <lambdabot> Title: HackageDB: filepath-1.1.0.0, http://tinyurl.com/2kc9q2
06:20:33 <ziman> i'm running stable and i had to add all ghc-related stuff to package.keywords
06:20:59 <ziman> because i want 6.8.2
06:21:09 <Cale> welterde: If you're on Mac, I recommend getting GHC from the GHC download page.
06:21:09 * Twey does a -uDav, because -uDav fixes everything!
06:21:27 <welterde> Cale: that might solve it as well ;)
06:21:52 <Cale> (actually, I recommend that regardless of platform)
06:21:55 <sw17ch> no! it's -vuDa!
06:22:31 <sw17ch> and while you're at it, put an N on there too :)
06:22:45 <welterde> hmmm... seems like both packages are for Leopard...
06:23:56 <Twey> sw17ch: Sometimes I like to emerge -Dave, just because I can.
06:24:28 <sw17ch> Twey, dangit, you may have just changed my habit with that one
06:24:35 <Twey> Heheh
06:26:03 <SamB_XP_> Cale: even on Debian?
06:27:08 <steven_ashley> SamB: I prefer it with Ubuntu
06:27:23 <Cale> SamB_XP_: Well, perhaps Debian unstable would be okay. I do it with Ubuntu.
06:28:00 <SamB_XP_> I don't think Igloo does ubuntu though
06:28:04 <Twey> Yay, a bug
06:28:06 <Twey> http://bugs.gentoo.org/show_bug.cgi?id=227515
06:28:08 <lambdabot> Title: Gentoo Bug 227515 - dev-haskell/network-2.1.0.0 fails to build
06:29:09 <steven_ashley> Twey: go with the binaries ;)
06:29:17 <Twey> Aye
06:29:57 <steven_ashley> http://haskell.org/ghc/download_ghc_683.html#binaries
06:29:57 <lambdabot> Title: GHC: Download version 6.8.3
06:32:18 <DuClare> Growl.  Anybody got some ideas for easy-ish applications to do with haskell as an excercise?
06:32:58 <steven_ashley> tic-tac-toe + AI?
06:32:58 <Cale> Twey: If you're interested, here's what a successful build of that package looks like http://hpaste.org/9158 -- it seems that there were extra steps in your build.
06:33:38 <sw17ch> DuClare: write a prefix notation calculator with parsec? :)
06:33:45 <halberd> is there a library uniquify function that takes a list and returns the unique elements of the list?
06:33:51 <sw17ch> nub
06:33:59 <halberd> where is nub?
06:34:02 <sw17ch> > nub [1,1,1,2,2,3,3]
06:34:07 <Cale> > nub [1,1,6,3,1,4,7,23,6]
06:34:07 <DuClare> sw17ch, Doesn't sound too bad.  More ideas welcome though. :]
06:34:14 <sw17ch> Data.List
06:34:18 <lambdabot>  thread killed
06:34:20 <halberd> thanks
06:34:20 <Cale> huh
06:34:22 <lambdabot>  thread killed
06:34:28 <Cale> code.h.o must be busy with something
06:34:33 <sw17ch> or is it in Prelude?
06:34:45 <sw17ch> nope, Data.List
06:35:00 <Cale> halberd: note that if the elements of your list can be ordered, it's often faster to go with  map head . group . sort
06:35:22 <Cale> (group and sort are also in Data.List)
06:36:04 <sw17ch> yes... isn't nub n^2?
06:36:07 <sw17ch> @src nub
06:36:07 <lambdabot> nub = nubBy (==)
06:36:18 <sw17ch> @src nubBy
06:36:19 <lambdabot> nubBy eq []             =  []
06:36:21 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
06:36:59 <steven_ashley> ahh, thats not particularly efficient :/
06:37:21 <Cale> It's lazy though, so it works rather well in certain cases.
06:37:38 * sw17ch always forgets to remember the lazy part
06:37:50 <sw17ch> at least when doing runtime analysis
06:38:11 <Cale> For example,  x == nub x  is a rather nice way to check if a list has duplicate elements, and actually is pretty efficient.
06:38:29 <halberd> only efficient if it's not true
06:39:06 <halberd> and if the place where it's not true shows up early
06:39:40 <Gwern-away> sw17ch: if you want an efficient nub, why not do the Data.Set trick?
06:39:56 <sw17ch> Gwern-away, i haven't heard of it
06:39:58 <sw17ch> :(
06:40:12 <halberd> you mean just put them in a set as you go along and check for elementhood
06:40:14 <sw17ch> (I very much Haskell in isolation)
06:40:17 <Cale> Which Data.Set trick?
06:40:22 <sw17ch> oh good, i'm not alone :)
06:40:26 <Cale> (there are at least two)
06:40:40 <halberd> requires Ord
06:41:13 <Gwern-away> sw17ch: no, toList . fromList
06:41:29 <sw17ch> oh!
06:41:35 <Cale> Gwern-away: Last I checked, that's no better than  map head . group . sort
06:41:53 * sw17ch hasn't had to use Data.Set yet
06:42:03 <halberd> it could be better if set were done with a hash table
06:42:08 <Cale> But maintaining a set as you go can keep the order of the list.
06:42:10 <Gwern-away> Cale: well, I am not an algorithms person, nor do I know how to analyze laziness properties, so if you say so...
06:42:13 <Cale> halberd: not really :)
06:42:18 <mar77a> this is funny
06:42:25 <halberd> yrly
06:42:25 <Gwern-away> yeah, that's the downside - it isn't a stable uniq
06:42:37 <halberd> hash table insertion time is less than log n if the table is large enough
06:43:08 <DuClare> sw17ch, Hmm, I'll try RPN instead; purely because I find it more interesting. :]
06:43:14 <catface> can you call an 'inherited' function from an instance function?
06:43:27 <Cale> Actually, insertion time in any data structure is at least log n, but the fact that you have a finite amount of memory hides this fact.
06:43:48 <Cale> catface: not sure what you mean there, but yes?
06:44:05 <sw17ch> DuClare, :)
06:44:06 <catface> neither am i now, actually
06:44:18 <halberd> well okay Cale but practically speaking you can assume you have a large amount of random access memory
06:44:22 <Cale> catface: functions defined in instances are allowed to call anything they want, even mutually recursively
06:44:58 <Cale> halberd: But if you assume that memory is finite, then log n is bounded anyway
06:45:07 <Cale> and lookup in Sets is O(1) again :)
06:45:31 <halberd> sure but it's still slower than lookup in hash tables
06:45:44 <Cale> In practice? Depends on the hashtable.
06:45:55 <halberd> I mean the "best" (asymptotically best) matrix multiplication algorithm has a huge constant multiplicative factor, so nobody uses it
06:45:57 <Cale> Data.Set is much faster than many hashtables.
06:45:59 <halberd> it's not actually the best in practice
06:45:59 <Shiruka> Cale: it's worse than log n for very big n ;-)
06:46:41 <halberd> asymptotics only matter if the function behaves like it does as it goes to infinity, when working with data of the size you want it to handle
06:47:07 <Shiruka> since you're limited by the amount of bits you can fit in a ball of some radius, access speed limited by radius and light speed
06:47:31 <Cale> If you're talking about practical issues, Data.Set is really quite efficient for sets of all practical sizes.
06:47:52 <Cale> (millions of elements are not a problem)
06:48:12 <Cale> Shiruka: right
06:48:18 <halberd> yes, but still probably not AS efficient as a hash table
06:48:20 <Cale> Shiruka: I actually often bring that up as well :)
06:48:35 <Shiruka> not that it's a very practical limit! :-D
06:48:41 <Cale> halberd: Certainly better than Data.HashTable
06:48:45 <halberd> you know I've heard of an alternate asymptotic notation that ignores log factors as well as constant factors
06:48:54 <Cale> halberd: yeah, soft-O
06:49:19 <welterde> ok... package was for leopard only *sigh*
06:50:00 <Cale> welterde: :|
06:50:07 <catface> well, maybe, light travels about 30cm in one 1Ghz clock cycle
06:50:19 <welterde> will have to build it from source then...
06:50:26 <Gwern-away> why ignore log factors? aren't they pretty common and important?
06:50:36 <Cale> welterde: which will require a binary for an earlier version
06:50:39 <Shiruka> (although you could see having to use NUMA for huge amounts of memory as a result of that problem)
06:50:52 <Cale> Gwern-away: common, yes, important, not that often
06:51:01 <welterde> Cale: as long as it doesnt require filepath for building...
06:51:02 <SamB_XP_> don't we routinely ignore certain log factors?
06:51:17 <SamB_XP_> (like those associated with increased amounts of RAM?)
06:51:23 <Cale> Like the log factor associated with using memory addresses :)
06:51:27 <Cale> yes
06:51:44 <Philippa> Gwern-away: in a good many cases they actually translate into a known constant
06:51:45 <SamB_XP_> I was thinking more in terms of the log factor associated with decoding more bits of address
06:51:57 <Shiruka> log n is
06:52:03 <Shiruka> about O(1) for small n :-)
06:52:03 <Gwern-away> Philippa: how does that work?
06:52:07 <Philippa> as in "log n is 32"
06:52:21 <Philippa> (used to be 16, becoming 64 on some platforms)
06:52:32 <Philippa> because you have a real-world upper bound for n
06:52:48 <Philippa> (need I explain the magic numbers above?)
06:52:59 <SamB_XP_> Philippa: well, perhaps often it's more like log(n) <= 2^W
06:53:00 <EvilTerran> well, log(n) <= 32
06:53:53 <Shiruka> I mean if n is something that's less than the amount of elementary particles we have access to (i.e. if it is counting something directly limited by the amount of some real-life objects), then log n will never grow very high..
06:53:57 <Philippa> SamB: yeah, but often you can just use the number of bits of address space you have as an approximation that'll cover your worst case
06:54:10 <SamB_XP_> incidentally, since when does log refer to base 2?
06:54:11 <halberd> actually the question of whether a data structure always must have logarithmic access time in the asymptotic case is a physical one, not a mathematical one
06:54:45 <Cale> halberd: Actually, if you want to talk about physics, it's n^(1/3) or perhaps even n^(1/2)
06:54:58 <SamB_XP_> Cale: hmm?
06:55:03 <SamB_XP_> what physics is that based on?
06:55:04 <Philippa> SamB: it doesn't specifically, no. It's often the case though
06:55:07 <halberd> yeah because you can only fit so many memory elements in a sphere
06:55:12 <Shiruka> SamB_XP_: in CS it often does.. some people also use it for base e, and some for base 10, so it's not like there's any consistency there anyway..
06:55:14 <Cale> SamB_XP_: assuming information density has a finite upper bound
06:55:15 <Philippa> and it's extremely rare for it to refer to a smaller base
06:55:22 <halberd> or perhaps even less depending on how large the wires are compared to the memory elements
06:55:30 <halberd> er, i mean, even more
06:55:31 <SamB_XP_> Cale: you forgot to include the physics of decoding the references
06:56:23 <Cale> SamB_XP_: O(log n) is a subset of O(n^(1/3)) ?
06:56:33 <halberd> but still for most "mathematical" models of a modern computer, memory access is assumed O(1), even though it's not really, physically speaking
06:56:53 <nornagon> hrm, if i wanted to have a list of objects (in this case, circles) and a bunch of references into that list (lines between certain circles), and i wanted to mutate the state of the circles (change their position/radius/etc), what structure would I be looking at? [IORef Circle]? STRef maybe?
06:57:01 <Philippa> halberd: it is on a given modern computer
06:57:13 <Cale> nornagon: Must it be a list?
06:57:18 <Cale> nornagon: Is the ordering important?
06:57:19 <Philippa> it's just that the constant is 'cost of a worst-case main memory access'
06:57:21 <nornagon> Cale: no
06:57:37 <halberd> yes it is Philippa but asymptotics are technically meaningless if your numbers never go to infinity
06:57:40 <nornagon> i guess 'collection' would be a more appropriate word
06:57:40 <Cale> nornagon: Use a Data.Map then
06:57:59 <Cale> nornagon: from the 'name' of a circle to its information
06:58:03 <vixey> estimates aren't always meaningless
06:58:04 <Philippa> halberd: we treat memory as 'conceptually infinite' at the same time...
06:58:21 <nornagon> Cale: then i have the issue of generating unique names...
06:58:22 <welterde> hmmm.... "/usr/bin/ld: can't locate file for: -lHSbase"
06:58:25 <Shiruka> n^(1/2) sounds reasonable if you model the CPU as a sphere that has to communicate with the memory outside, then the interface speed to the memory is limitied by the surface area of the sphere..
06:58:30 <Philippa> and they're plenty meaningful as soon as you're at the point where they dominate over the constants
06:58:31 <Cale> nornagon: Well, you can use integers, for instance.
06:58:56 <Cale> nornagon: Or find the highest index in the Map and increment it
06:59:09 <nornagon> i guess I could have a (Data.Map Int Circle,Int), where the latter is the highest
06:59:10 <Philippa> now, if you're working with a system that uses local HDs and then network storage etc etc for memory too then you're probably justified in wanting to factor it that way
06:59:21 <SamB_XP_> Cale: so O(log n) + O(n^(1/2)) == O(n^(1/2)) ?
06:59:28 <Cale> nornagon: Finding the highest index is log(n) time anyway
06:59:31 <Philippa> but for a local PC app on a machine that isn't thrashing like crazy, O(1) memory access is justified
06:59:35 <Cale> SamB_XP_: yeah
06:59:51 <SamB_XP_> where by ==, as per standard notation, I mean \subsetof
07:00:07 <nornagon> Cale: it is? i would have expected n... maybe i should read more about O notation :)
07:00:16 <Twey> Bahhh
07:00:37 <SamB_XP_> Cale: okay, that's okay then. I'm a bit rusty with these things.
07:01:02 <SamB_XP_> hey, did big-O notation originate in computer science or did it come from the study of sequences and series?
07:01:13 <Cale> nornagon: Data.Map is implemented with a nice tree structure that cuts the number of elements in half every time you take a step through it
07:01:32 <Twey> Even binary GHC doesn't have Network
07:01:37 <Shiruka> a bit strange though how common hash tables are
07:01:47 <Cale> SamB_XP_: I'm pretty sure it originated in analytic number theory.
07:01:52 <SamB_XP_> Shiruka: I agree completely
07:01:54 <Cale> SamB_XP_: But not 100%.
07:02:20 <SamB_XP_> Cale: does that sort of fit in with my "sequences and series" or not?
07:02:35 <Cale> Shiruka: yes, especially as they are *much* harder to write than something using balanced trees.
07:02:37 <Shiruka> one might suppose that something like splay trees that caches the most common elements would be more efficient due to it keeping the most common els in a more CPU cache -friendly format
07:02:44 <Cale> SamB_XP_: yeah
07:03:04 <SamB_XP_> Cale: and those hash functions!
07:03:08 <SamB_XP_> those are not clear how to write
07:03:16 <Shiruka> but maybe the hash tables end up being more efficient for some reason anyway :-/
07:03:35 <Cale> Shiruka: I haven't had this experience... maybe if you work hard enough at it.
07:04:13 <Philippa> Shiruka: what people actually do is try to find a cache-friendly hash function
07:04:18 <Cale> I think also that maybe it's just that tree data structures are harder to work with in non-functional languages?
07:04:19 <Philippa> scary, huh?
07:04:27 <Philippa> Cale: much, yeah
07:04:29 <SamB_XP_> Shiruka: potentially for some applications they end up more efficient than binary trees due to having lower space usage ? I'm not sure they would, but it seems quite possible that they would...
07:04:37 <Shiruka> the relative size of the data structure and cache probably matters too.. if the hash tbl fits in cache, then it's gonna be fast anyway, and you can make hash tbl very compact
07:04:46 <SamB_XP_> Cale: that's not really true
07:05:00 <SamB_XP_> it's easy to write tree code in C or C++, too
07:05:19 <SamB_XP_> the deallocation is a bit of a pain, though, I admit...
07:05:35 <Philippa> SamB: it's significantly harder in C than in Haskell
07:05:51 <SamB_XP_> Philippa: a great many things are ;-)
07:06:01 <Philippa> especially if you're working from a newbie POV or don't trust your compiler to inline functions
07:06:29 <SamB_XP_> but remember, we are speaking of the comparative difficulty of hashtables and search trees ;-)
07:07:00 <SamB_XP_> do you think that hashtables are less harder in C than search trees?
07:07:08 <Philippa> by the time you balance the tree? Yeah
07:07:11 <Shiruka> writing good implementations of either is not newbie-grade material..
07:07:24 <SamB_XP_> oh, true, good implementations are harder ...
07:07:28 <pejo> Shiruka, you can't reall fill your hashtables 100%, so it should waste more space than the binary trees for storing the same amount of data.
07:07:31 <SamB_XP_> you do have to go and balance then :-)
07:07:59 <SamB_XP_> pejo: show me some pseudo-data to support this conclusion
07:08:04 <Cale> Balancing is not so hard in a functional language, but I suspect it's hell in something like C
07:08:07 <SamB_XP_> or hand-wavy data or whatever you call it
07:08:30 <Cale> You don't have a convenient pattern matching notation to help you ;)
07:08:32 <Shiruka> pejo: many hash tables contain small data
07:09:01 <SamB_XP_> i.e, I'll let you come up with a fill number, and then we can discuss the number of words used by tables with so many entries in each form
07:09:03 <Shiruka> if your hash table wastes 50% of the space and every entry takes exactly the amount of data there, then it's going to take less space than a binary tree with data + two pointers in it
07:09:23 <SamB_XP_> Shiruka: you seem to have forgotten about the allocation overheads
07:10:46 <Shiruka> allocation overheads where?
07:10:48 <pejo> SamB, show you some hand-wavy data that you get excessive collisions when you fill your hash-tables to 100%?
07:11:03 <SamB> pejo: no, no
07:11:29 <Shiruka> filling hashtables to 100% is obviously not reasonable..
07:11:37 <SamB> I realize 100% fill is unreasonable ;-)
07:12:09 <SamB> but name a typical fill figure ... and we'll work out the overhead ...
07:12:11 <Philippa> pejo: it depends a bit on whether the key and value costs are enough to drown the tree structure
07:12:49 <SamB> to be as unflattering to binary trees as possible, we will use pointers to the keys and values
07:13:04 <Cale> and what happens as the hashtable fills up and you need to resize it?
07:13:07 <Shiruka> you can have smaller keys and values
07:13:20 <Philippa> Cale: a big time cost once in a while
07:13:31 <SamB> Shiruka: if you have smaller keys on a 32-bit system, you should use an array ;-)
07:13:32 <Botje> is this still the same hashtable discussion from three hours ago?
07:13:36 <Philippa> you can keep the table within a given size range though
07:13:36 <Botje> my, aren't we persistent :)
07:13:50 <Shiruka> for instance both could be ints, or chars in C++ (STL allows you to remove very much of the overhead, other implementations that do that don't come to mind)
07:14:27 <Shiruka> SamB: different on 64-bit :-) there pointers would be 64-bit and ints still 32-bit
07:14:37 <SamB> Shiruka: true
07:14:45 <Cale> hmm, I suppose that amortises out to constant time.
07:14:48 <pejo> Cale, it's still an amortised O(1) iirc, if you resize at the right levels (so you can't construct  a sequence of inserts/deletes where the hash table has to resize every time).
07:14:51 <Cale> yeah
07:14:53 <catface> is there a Parsec parser that parses haskell somewhere? I'm sure i saw one...
07:15:24 <Cale> catface: I'm not sure about Parsec specifically...
07:15:38 <Cale> But there's Language.Haskell.Parser
07:15:48 <catface> that was probably it
07:16:19 <Cale> haskell-src and haskell-src-exts on Hackage
07:16:20 <pejo> SamB, I'm not sure of "typical" fill levels. I remember cuckoo hashing, and I tthink that with some modifications you can get a 75% fill there.
07:16:23 <Shiruka> OTOH, there are other advantages to hash tables that make them popular in some contexts
07:16:51 <nornagon> Cale: oh ah :)
07:16:54 <nornagon> @index lift
07:16:54 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List, Language.Haskell.TH.Syntax, Text.
07:16:54 <lambdabot> ParserCombinators.ReadPrec, Text.Read
07:16:58 <Shiruka> in slow languages such as python it's an advantage not to have to call a slow equality comparison, instead being able to implement pretty much all of the lookup in C :-)
07:16:58 <SamB> hmm, this malloc I'm looking at has what looks like two INTERNAL_SIZE_T of overhead ...
07:17:05 <nornagon> :t lift
07:17:09 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Monad m, MonadTrans t) => m a -> t m a
07:17:12 <SamB> Shiruka: hmm, good point!
07:19:17 <SamB> actually I was misunderstanding
07:19:32 <SamB> apparantly it only has 1 word of overhead ...
07:20:01 <iabal> hi
07:20:05 <pejo> SamB, if you are writing code that cares about your cache you are probably prepared to provide your own memory allocator too.
07:20:52 <pejo> SamB, I'll get back to you on the exact levels of the cuckoo hashing though, I need to ask a colleague about some pointers and he's currently on vacation.
07:21:09 <Philippa> pejo: What value of 'cares about your cache', and similarly 'memory allocator'?
07:21:18 <Shiruka> one of the nice features of C++ is ability to specify in much detail exactly how you want things done.. very good for speed
07:21:30 <vixey> :S
07:21:39 <SamB> and the minimum allocated size is 3 ptrs (not including overhead)
07:21:51 <Philippa> Shiruka: Hah. Tell that to someone compiling a language with continuations to C++
07:22:02 <vixey> http://www.cs.bu.edu/~hwxi/ATS/ATS.html "as efficient as C/C++"
07:22:03 <lambdabot> Title: Home Page for ATS
07:22:08 <Shiruka> the not-so-nice feature of course being that you'll want to write 90% of your app in another language where you can be productive ;-)
07:22:10 <Philippa> hell, intermodule TCO's hard enough
07:22:18 <SamB> so ...
07:22:22 <Philippa> (though it's the same solution, really)
07:22:32 <SamB> and the alignment is 2-word ...
07:22:41 <pejo> Philippa, isn't the discussion about fitting your datastructures in cache, to get good performance?
07:22:43 <Shiruka> Philippa: I meant human-written, human-understandable code
07:22:48 <Shiruka> compilers are a bit different :-)
07:23:24 <Philippa> pejo: if that's all you care about, plenty of people do that without worrying about their own allocators - or at least without thinking of them that way
07:23:37 <Philippa> ("I've got this array..." that looks suspiciously like a pool is pretty common, mind)
07:23:40 <SamB> which means that a binary tree node takes (1 key ptr + 1 value ptr + 2 child ptrs + 1 word padding + 1 word overhead)
07:23:51 <Philippa> Shiruka: yeah. So you come back to 'exactly what you want it to do', and sometimes you can't
07:24:09 <Shiruka> vixey: btw, thanks for the forth asm implementation link, it was actually a quite interesting read :-) I even read much of the assembly..
07:24:21 <pejo> Philippa, yes. The hurdles people are prepared to jump over to get good "performance". :-)
07:24:36 <vixey> glad you found it interesting
07:24:49 <SamB> and hashtable entries take (1 word hash + 1 key pointer + 1 value pointer)
07:25:03 <Cale> Shiruka: hehe, everyone knows that compilers are all written by the Protoss.
07:25:04 <lilachaze> Philippa: re continuations, if you know exactly how you want them implemented, i don't see the problem. if you don't, you're going to have trouble compiling to any von Neumann-style language.
07:25:08 <Philippa> pejo: there're contexts where it's justified - what's sad is the amount of work people have to go to because they can't spec the same things in a higher-level manner
07:25:13 <Shiruka> Philippa: yeah.. but alternatives aren't much better :-(
07:25:31 <Philippa> lilachaze: the 'problem' is that you can't mess with the C++ stack
07:25:41 <Shiruka> it's like complaining that Haskell doesn't optimize list folds perfectly.. there is no alternative language that does, either :-)
07:26:03 <Philippa> Shiruka: it is, however, surprisingly easy to envisage good alternatives. It's a matter of development effort by now
07:26:19 <lilachaze> Philippa: ruby manages, as i recall :-)
07:26:30 <vixey> ruby is written in C
07:26:37 <vixey> isn't it ? do they use some C++ now?
07:26:50 <Philippa> ruby's an interpreter, it keeps its own stack, no?
07:26:53 <lilachaze> not as far as i'm aware, but their trick works for c++ too
07:27:12 <BeelsebobWork_> interesting -- using the debian language shootout programs, Haskell averages 2 times faster than C on OS X
07:27:16 <Philippa> it's basically that or do something non-portable
07:27:22 <BeelsebobWork_> because malloc is so so slow in the C versions
07:28:28 <lilachaze> Philippa: AFAIR, ruby uses the c stack rather than having its own, and implements continuations by copying around chunks of the stack
07:29:09 <Philippa> lilachaze: that's in no way portable
07:29:20 <SamB> Philippa: define "in no way"
07:30:10 <Shiruka> with sufficient effort, any trick is portable (<--- new hypothesis)
07:30:11 <Philippa> SamB: OK, OK, I can find very minor platform variants it still works across. But it's not portable between compilers
07:31:10 <Shiruka> even boehm gc is pretty portable, and it has to do magic to implement a C gc in C..
07:31:41 <vixey> it has different code for each platform
07:31:51 <SamB> Shiruka: I bet it doesn't work in segmented x86 memory models!
07:32:05 <Shiruka> vixey: sure, that's the "sufficient effort" part ;-)
07:32:06 <Philippa> SamB: I bet it works in Tiny :-)
07:32:10 <SamB> vixey: which, ruby or boehm ;-)
07:32:30 <Philippa> Shiruka: in that case all you did was rediscover what 'turing complete' means
07:32:31 <SamB> Philippa: isn't tiny the one with only 64kb ?
07:32:47 <Philippa> SamB: with all the segment registers set to the same value, yeah. Assuming I've got the right one too
07:33:01 <Shiruka> Philippa: not really, I meant with reasonable performance and locality of changes in the codebase
07:33:18 <Shiruka> like, doing bits of the thing in asm and leaving the rest untouched
07:33:21 <SamB> just checking to make sure you weren't talking about the 32-bit version of that ... hmm, I think we call that one "flat"?
07:33:47 <Shiruka> ah, and anyone using segmented memory models in x86 deserve all the pain they're gonna get!
07:33:51 <SamB> Philippa: do you really think it would work in 64k ?
07:34:23 <Philippa> SamB: it's certainly possible to get /a/ GC working in that little space
07:34:26 <SamB> Shiruka: they are useful for motivating the restrictions on manipulation of C pointers ;-)
07:34:33 <Philippa> still writing a useful program as well may be another issue
07:34:57 <Shiruka> I think they are useful as horror stories to the children ;-)
07:36:03 <siponen> Whht? Hppnd?
07:36:22 <siponen> The channel has became huge...
07:36:30 <Shiruka> smn st us p th bmb
07:36:38 <Shiruka> oops, stray vowel
07:36:48 <siponen> Forgiven.
07:36:56 <Apocalisp> @users
07:36:56 <lambdabot> Maximum users seen in #haskell: 489, currently: 461 (94.3%), active: 22 (4.8%)
07:37:43 <lilachaze> Shiruka: the ruby trick doesn't work on the Itanium (which has two stacks).
07:38:59 <siponen> Should I be able to pass a class name around like a type?
07:39:16 <vixey> um..
07:39:23 <lilachaze> siponen: can you clarify with an example?
07:39:25 <vixey> you can't pass types around, can you ?
07:39:41 <vixey> so.. yes, you can't pass class names around either
07:40:02 <lilachaze> unless you're using TH...
07:40:05 <Shiruka> maybe he has a dependently typed haskell from the future
07:40:22 <lilachaze> siponen: can i borrow your time machine?
07:40:22 <SamB> Shiruka: who?
07:40:31 <Shiruka> siponen:-)
07:40:39 <SamB> siponen: GIVE IT TO ME!
07:40:47 <siponen> Like can my function return something that is a class and not a specific instance?
07:41:01 <lilachaze> ah, i think i see what you mean.
07:41:01 <vixey> siponen, no
07:41:18 <siponen> :(
07:41:24 <lilachaze> siponen: or possibly yes.   x :: (Num a) => a; x = 42
07:41:30 <siponen> It started to sound so useful...
07:41:46 <vixey> a function can only return a value
07:42:03 <SamB> siponen: you mean can it return no-particular-instance ?
07:42:04 <SamB> sure!
07:42:14 <SamB> :t mzero
07:42:18 <vixey> the type of that value could be a variable, a ground type, or a type from some class
07:42:19 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
07:42:30 <vixey> (or composition of those)
07:42:33 <lilachaze> :t undefined
07:42:34 <lambdabot> forall a. a
07:42:54 <dolio> @type fromInteger
07:42:55 <lambdabot> forall a. (Num a) => Integer -> a
07:43:15 <lilachaze> @quote stereo
07:43:15 <lambdabot> dolio says: fasta: At least the 'stereo' quote is no longer in lambdabot. That was _way_ overused.
07:43:16 <siponen> Ok. This gives me hope.
07:43:22 <lilachaze> :-/
07:43:36 <lilachaze> siponen: what do you want to do?
07:43:40 <vixey> @quote 5.1
07:43:40 <lambdabot> No quotes match. My mind is going. I can feel it.
07:43:53 <lilachaze> @quote glorious
07:43:54 <lambdabot> Cale says: Welcome to #haskell, where your questions are answered in glorious stereo!
07:44:03 * dolio laughs maniacally.
07:44:08 <Shiruka> @type unsafeCoerce#
07:44:09 <lambdabot> Not in scope: `unsafeCoerce#'
07:44:12 <Shiruka> :-<
07:44:14 <siponen> Get rid of a datatype that just collects other datatypes that have some functions in common.
07:44:21 <Shiruka> \bot does not know the power of the dark side
07:44:32 <lilachaze> siponen: that sounds exactly like you want a typeclass :)
07:44:34 <vixey> :t unsafeCoerce
07:44:35 <lambdabot> Not in scope: `unsafeCoerce'
07:44:43 <vixey> :t Unsafe.Coerce. unsafeCoerce
07:44:44 <lambdabot> Couldn't find qualified module.
07:45:02 <siponen> Eventually I want to write a better version of our RPG-clubs VTES-simulatior :) (a cardgae)
07:45:12 <siponen> (a cardgame), even
07:46:02 <lilachaze> vixey: possibly not present for security reasons?
07:46:12 <lilachaze> :t unsafePerformIO
07:46:12 <lambdabot> Not in scope: `unsafePerformIO'
07:46:13 <vixey> :t Unsafe.Coerce.unsafeCoerce
07:46:14 <lambdabot> forall a b. a -> b
07:47:22 <dolio> > (Unsafe.Coerce.unsafeCoerce ()) :: Int
07:47:23 <lambdabot>   Not in scope: `Unsafe.Coerce.unsafeCoerce'
07:47:26 <Shiruka> ah, thank you emperor vixeytine, for showing the Way to \bot ;-)
07:47:28 <siponen> lilachaze: Yes, but I don't want to write the functions all over again for each datatype.
07:48:12 <siponen> But I think I'll manage.
07:48:26 * Twey installs GHC from binary.
07:48:30 * Twey feels dirty.
07:48:36 <lilachaze> siponen: the best path to enlightenment on #haskell tends to be to hpaste some code and wait for it to be torn to shreds
07:48:53 <codacola>  thats always fun
07:49:26 <Shiruka> and then you get to keep all the pieces :-)
07:49:49 <codacola> of your broken heart?
07:50:09 <Botje> coding haskell mostly involves brains
07:50:15 <codacola> it does?
07:50:17 <Botje> or rather, skull fragments and pieces of brain.
07:50:47 <codacola> i think it requires courage to look at somehting so ugly :P
07:50:51 <lilachaze> and a friendly company who clean grey matter off walls and don't ask too many questions
07:50:58 <AJ_> Hey all, What should be used in Haskell when you need a multidimensional data structure? for example when you are representing a 2d game board
07:51:01 <Shiruka> it involves channeling alien category theory gods
07:51:08 <chrisdone> aj: an array can do that
07:51:10 <Botje> AJ_: Data.Array
07:51:33 <lilachaze> @faq can haskell represent a 2d game board as an array?
07:51:33 <lambdabot> The answer is: Yes! Haskell can do that.
07:51:35 <Botje> but a list of lists will do in a pinch
07:51:45 <AJ_> is it still possible to write in a functional way?
07:51:54 <Botje> of course
07:52:11 <AJ_> yes I wrote it as a list of lists but some of the functions are getting uber complex
07:52:12 <codacola> be a man, write in c
07:52:20 <dmwit> AJ_: I found a Data.Map to be more convenient (and speedy) for 2D game boards.
07:52:24 <AJ_> and my problem domain is really small
07:52:30 <Botje> > listArray ((1,1),(20,20) [1..] ! (5,4)
07:52:30 <AJ_> just a tic tac toe game
07:52:30 <lambdabot> Unbalanced parentheses
07:52:38 <Botje> > (listArray ((1,1),(20,20)) [1..]) ! (5,4)
07:52:53 <lambdabot>  thread killed
07:52:56 <vixey> AJ_: I like  data Triple a = Triple a a a
07:53:04 <vixey> AJ_: type Board a = Triple (Triple a)
07:53:18 <dmwit> > listArray ((1,1),(20,20)) [1..] ! (5,4) -- no extra parens needed there
07:53:20 <lambdabot>  84
07:53:34 <Botje> but i gave the exact same code!
07:53:40 <dmwit> vixey: cute!
07:53:41 <Philippa> siponen: typeclasses support defaults
07:53:42 <Botje> @vixen are you mad at me?
07:53:42 <lambdabot> i truely am
07:53:48 <dmwit> Botje: You missed a parenthesis in the tuple.
07:53:49 <Botje> :'(
07:53:53 <jamii> dons: Does plugs allow you to define classes and instances at the prompt?
07:53:54 <AJ_> vixey: well my tic tac toe board is potentially infinite!
07:53:58 <Botje> dmwit: yeah, i corrected that in my second one
07:54:11 <Shiruka> err, isn't tic-tac-toe played on a 3x3 board only?
07:54:14 <Philippa> AJ: if it's all getting too complicated, you need to factor your code better
07:54:16 <vixey> AJ_: :((
07:54:34 <Philippa> names for all the common operations you think of when you're trying to do stuff with a board
07:54:59 <AJ_> well it's mostly the 'play a move' function which is complicated
07:55:15 <AJ_> especially the part which checks for a win
07:55:15 <chrisdone> tic tac toe tun?
07:55:45 <AJ_> is it okay if I paste a dozen or so lines of code here?
07:55:50 <Botje> no, use hpaste;org
07:55:51 <Shiruka> hpaste
07:56:02 <chrisdone> http://hpaste.org/
07:56:17 <lilachaze> pasting a dozen lines is not ok. it is, however, ok for us to tell you to use hpaste a dozen times.
07:56:52 <vixey> AJ_: how do you display it ...?
07:57:00 <vixey> is each game on a fixed size board?
07:57:01 <AJ_> I pasted it at http://hpaste.org/9159
07:57:05 <vixey> or is the board really unbounded
07:57:09 <AJ_> could someone take a look at it please?
07:57:22 <AJ_> vixey: unbounded board
07:57:32 <Shiruka> the difference is that one of these things is O(n) where n is the number of persons, the other O(n*m) where m is the average amount of pasted lines per person during their lifetime :-)
07:57:33 <dolio> > (-0.0)
07:57:35 <lambdabot>  -0.0
07:57:49 <vixey> AJ_: Then I would say .. just store it as something like [(Location,Maybe Piece)]
07:57:57 <tromp> for 3x3 boards, i'd use a bitboard encoding
07:58:13 <Shiruka> I'd just be lazy and use a string
07:58:18 <tromp> that works well upto 8x8
07:58:24 <vixey> actually not that, [(Location,Piece)] is fine, no need for Maybe
07:58:25 <Shiruka> "X.O\n...\nOXO\n"
07:58:31 <Shiruka> easily printed out!
07:59:05 <dmwit> vixey: As I suggested... a Data.Map. ;-)
07:59:19 <vixey> not a Map
07:59:28 <AJ_> vixey: well I haven't given that a thought.. I should probably try your suggestion
07:59:40 <dmwit> You're not suggesting a Map.  But I am.
07:59:57 <AJ_> yup a map might work
08:00:15 <vixey> if you use Map how do you iterate over all the pairs?
08:00:26 <vixey> does it basically mean converting to a list?
08:00:30 <dmwit> yes
08:00:36 <dmwit> vixey: or fmap
08:01:54 <hackage> Uploaded to hackage: yi 0.4.1
08:01:54 <hackage> Uploaded to hackage: yi 0.4
08:01:54 <hackage> Uploaded to hackage: RJson 0.3.5
08:01:55 <hackage> Uploaded to hackage: haskeline 0.2.1
08:01:55 <Shiruka> AJ_: a simple way to check for a win would be to write functions to convert the array into horizontal, vertical and both types of diagonal lines.. then search for "XXX" or "OOO" in each line
08:01:57 <hackage> Uploaded to hackage: AERN-Real 0.9.5
08:02:17 <chrisdone> yeah, Data.Map has map and fold
08:02:48 <AJ_> Shiruka: that's what I am doing actually.. with some optimisation
08:03:18 <dmwit> ?quote evil
08:03:18 <lambdabot> paczesiowa says: my friends (evil, imperative and objectionable) from university laugh at me that I love haskell and I wont find any job as haskell programmer. I get sad when I start to believe them.
08:03:19 <lambdabot>  but then I look at some java code and I'm all happy again
08:03:28 <Shiruka> "premature optimization is the root of all evil" :-)
08:03:41 <dmwit> "premature evil is the root of all optimization"
08:03:47 <dmwit> That's the quote I was looking for. =P
08:04:19 <tromp> testing for a win in a bitboard is a simple matter of anding with a mask
08:04:33 <chrisdone> how much does tic-tac-toe need to be optimised? it's a solved game, and trivial Â·â.
08:04:51 <vixey> if it's people putting the bits down on a board then you'll never get enough bits down on it that speed of checking wins is an issue
08:04:53 <dmwit> Your eyes are in weird places.
08:04:58 <siponen> What about premature optimism?
08:05:11 <mar77a> is there any other type of optimism
08:05:26 <dmwit> mature optimism
08:05:30 <chrisdone> dmwit: ._Â·
08:05:31 <Shiruka> the corollary is "the power of premature optimization is all evil"
08:05:38 <dmwit> chrisdone: Much better. =)
08:06:13 <mfp> vixey: what about   mapWithKeyM_ f = M.foldWithKey g $ return () where g k v = (f k v >>)   ?
08:06:18 <AJ_> people! well when i said optimisation, I am not doing some convulated thing
08:06:25 <AJ_> I am only doing what makes code simpler
08:06:47 <dmwit> Luckily, I can persist, as I am not a person.
08:06:48 <mfp> mapWithKeyM_ :: (Monad m) => (k -> a -> m ()) -> M.Map k a -> m ()
08:06:52 <AJ_> instead of checking each row and column on every move, I only check the ones which include the cell where the piece is placed
08:06:53 <vixey> cool
08:06:57 <chrisdone> dmwit: hehe
08:07:26 <vixey> AJ_: yeah, that's a good idea.. otherwise your code has to check an infinite grid :p
08:07:49 <dmwit> vixey: The grid is bounded at game start.  ...according to his code.
08:08:01 <AJ_> vixey: no a potentially infinite grid! never one in actual practice :)
08:08:15 <vixey> it's either infinite or it's not
08:08:52 <dmwit> vixey: He just meant there's no arbitrary bound on the size until the game starts.
08:09:03 <dmwit> vixey: So types like i.e. Triple just won't cut it.
08:09:08 <AJ_> dmwit: yup exactly
08:09:15 <Shiruka> oh :-( I thought it's played on a Map of (Integer, Integer)
08:09:38 <AJ_> Shiruka: how do you check for wins then?
08:09:43 <Shiruka> (or map from (Integer, Integer) -> Piece, I mean)
08:09:55 <Shiruka> AJ_: well, each time you do a local check, which is very finite :-)
08:10:38 <AJ_> Shiruka: I mean don't the rules of tic tac toe say that you have to completely fill a row/column/diagonal to win?
08:10:54 <Shiruka> oh
08:11:04 <vixey> AJ_: no, you have to get 3 in a row
08:11:04 <Shiruka> I thought it was to get 3 in a row
08:11:06 <AJ_> Shiruka: atleast that's what my code checks for
08:11:19 <vixey> it's just a coincidence that the board is 3x3
08:11:39 <Shiruka> interesting way to generalize :-) the rules are underspecified!
08:11:41 <AJ_> hmmm yeah that makes sense too
08:12:01 <AJ_> heh yeah
08:12:11 <tromp> there's a forced win in 3 moves on any board >= 4x4
08:12:19 <vixey> :t any
08:12:20 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
08:13:05 <Shiruka> tromp: you wouldn't have anything to do with tromp-taylor rules?-)
08:13:06 <AJ_> so any pointers on how to make the "play" function look better
08:13:27 <vixey> :t all
08:13:28 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
08:13:41 <astrolab1> Shiruka: Yeah.  He's John Tromp.
08:13:46 <AJ_> I used this code to explain functional programming to someone and he is completely stuck on the play function
08:13:56 <tromp> yes, i would
08:14:38 <astrolab1> AJ: Have you heard of go-moku?
08:14:46 <Twey> Hehehe
08:14:53 <Twey> I showed someone Haskell for the first time last night.
08:15:00 <EvilTerran> yay gomoku
08:15:10 <AJ_> astrolab1: nopes
08:15:17 <AJ_> but I just googled for it!
08:15:21 <Twey> äºç®?
08:15:22 <AJ_> sounds interesting
08:15:25 <Twey> o.@
08:15:38 <Shiruka> äºç®å
08:17:11 <dolio> Is that a monocle?
08:17:43 <Shiruka> looks like a black eye to me
08:18:04 <Twey> Å.Ã²
08:18:06 <mar77a> > "haskell" \\ "fun"
08:18:09 <lambdabot>  "haskell"
08:18:22 <Twey> Monocle: o.q
08:18:31 <DuClare> Hoy.
08:18:33 <BeelsebobWork_> o.â
08:18:41 * Twey waves hello to DuClare.
08:18:52 <DuClare> Can you enter multiple numbers in RPN?  Like, 40 9 4 + -
08:19:00 <Twey> Wow
08:19:00 <vixey> yes
08:19:01 <mar77a> yeah
08:19:03 <DuClare> Okay
08:19:10 <DuClare> Hi Twey *hugs*
08:19:14 * Twey hugs back.
08:19:20 <Twey> Haskell has RPN support?
08:19:36 <mar77a> it has polish notation support
08:19:37 <Shiruka> the next version of GHC requires you to write everything in RPN
08:19:43 <BMeph> DuClare: That's kind of the point of RPN; stack-based comp model. :)
08:19:52 <mar77a> > (*) 2 $ (/) 4 2
08:19:52 <BeelsebobWork_> â¢.â¢ Twey
08:19:53 <lambdabot>  4.0
08:20:23 <Twey> mar77a: Well obviously :-)
08:20:32 <EvilTerran> you can probably do something clever with Num instances
08:20:45 <BeelsebobWork_> âËâ
08:20:52 <Twey> > (* 2) . (/) 4 2
08:20:52 <lambdabot>   add an instance declaration for (Fractional (f a))
08:20:55 <Twey> :<
08:21:18 <Shiruka> â¢. looks like a nuclear sign with a leak..
08:21:26 <Twey> Hahaha
08:21:32 <BeelsebobWork_> rofl
08:21:37 <Twey> A.K.A. 'You're screwed now!'
08:21:39 <Deewiant> > (* 2) . (/ 4) $ 2
08:21:40 <lambdabot>  1.0
08:21:51 <Twey> Oh of course.
08:21:52 <mar77a> > "parents" \\ "leash"
08:21:53 <lambdabot>  "prnt"
08:21:55 <vixey> AJ_: ugh I tried my way
08:21:58 * Twey is an idiot.
08:22:01 <vixey> AJ_: You made me code!!!
08:22:03 <Twey> Haha
08:22:09 <BeelsebobWork_> âº.o -- good black eye one
08:22:27 <Twey> Ah Unicode, how we love you
08:22:40 <AJ_> vixey: ha ha
08:22:43 <mar77a> ah i love how it shows as squares
08:22:45 <Shiruka> é».O
08:22:47 <BeelsebobWork_> â¯.â¯ -- drunk?
08:23:00 <mar77a> how many pixels does a ttf have
08:23:02 <mar77a> per font
08:23:02 <AJ_> vixey: so what was the result?
08:23:11 <mar77a> per character i mean
08:23:13 <BeelsebobWork_> â -- inverse smiley?
08:23:20 <BeelsebobWork_> ã 
08:23:21 <Deewiant> mar77a: isn't it a vector format?
08:23:27 <mar77a> well lets pretend it's fixed
08:23:31 <mar77a> say
08:23:37 <Deewiant> well then it's infinite :-P
08:23:58 <mar77a> lets say
08:24:05 <mar77a> 20x30 rects
08:24:08 <Deewiant> .FONs were a bitmap format, they'd have some limit
08:24:16 <mar77a> and
08:24:23 <mar77a> 9999 different characters
08:24:29 <mar77a> > 20*30*9999
08:24:30 <lambdabot>  5999400
08:24:40 <mar77a> if you do all possible pixel combinations
08:24:53 <mar77a> wait
08:25:00 <mar77a> > 20*30*2
08:25:01 <Shiruka> what about grayscale values? it looks so bad without antialiasing!
08:25:02 <lambdabot>  1200
08:25:06 <mar77a> ok
08:25:17 <mar77a> > 20!*30!*128
08:25:17 <lambdabot>   Not in scope: `!*'
08:25:22 <vixey> AJ_: http://hpaste.org/9159#a1
08:25:24 <Shiruka> and 20*30 is so bad resolution.. I want at least 200*300 in my characters!
08:25:32 <mar77a> okay
08:25:38 <vixey> I don't have GHC installed so I don't know if that'll even typecheck...
08:25:45 <Shiruka> so 256^(200*300)?
08:25:52 <DuClare> Shiruka, Me too.  But I blame people and display manufacturers for creating crap.
08:25:58 <Deewiant> > 256^200
08:25:59 <lambdabot>  4446241647709404462001681406551736431581923451213783931941822309375368306976...
08:26:09 <Deewiant> > length . show $ 256^200
08:26:10 <lambdabot>  482
08:26:23 <DuClare> Shiruka, People don't want better DPI because they think everything goes small then! :o
08:26:27 <Deewiant> > length . show $ 256^(200*300)
08:26:28 <lambdabot>  144495
08:26:35 * Twey laughs.
08:26:36 <DuClare> Most LCDs are horrible.
08:26:43 <Twey> My mother said that
08:26:56 <Twey> When she got a new graphics card, I upped the resolution to take advantage of it
08:27:01 <Shiruka> > 200*300*log(256)/log(10)
08:27:03 <lambdabot>  144494.39791871095
08:27:07 <DuClare> Embedded devices tend to have great DPIs.
08:27:09 <Twey> And she says 'I don't like this card, it makes everything small!'
08:27:13 <Shiruka> faster way to evaluate ;-)
08:27:19 <DuClare> Twey, That's a popular failure. :(
08:27:46 * therp wants 120dpi LCDs
08:27:52 <Shiruka> heh
08:28:11 <vixey> AJ_: wonders if what I wrote makes any sense?
08:28:14 <DuClare> I'd like something like the embedded stuff.
08:28:24 <Twey> OLED monitors?
08:28:24 <Shiruka> I'd like all software to scale reasonably well to any DPI
08:28:30 <DuClare> Twey, The Neo for example has 285dpi.
08:28:48 <Twey> DuClare: Do you have one?
08:29:03 <Twey> They sold out so fast :-(
08:29:10 <DuClare> Shiruka, Should be pretty much doable with the vector graphics we have nowadays (although I don't really understand why DEs still want bitmaps generated from the vectors, isn't that lame?!)
08:29:14 <Twey> And the FreeRunner too
08:29:21 <DuClare> What, is it already sold out?
08:29:33 <Shiruka> DuClare: doesn't OS X do it right these days?
08:29:35 <vixey> it could probably be simpler..
08:29:37 <Twey> From the retailers near me
08:29:38 <DuClare> Shiruka, No clue
08:29:53 <Shiruka> at least that what the apples-are-better-than-oranges people tell me
08:29:57 <Deewiant> @check \x -> x > 0 ==> length (show (x :: Integer)) == floor (log (fromIntegral x) / log 10 + 1)
08:29:57 <lambdabot>  OK, passed 500 tests.
08:29:59 <therp> DuClare: can they please scale that to 17" or 19"?
08:30:12 <Twey> Er, 'retailer'
08:30:28 <Twey> Shiruka: Apples *are* better than oranges.
08:31:08 <Twey> DuClare: https://www.truebox.co.uk/trueboxportal/index.php?wk=Openmoko
08:31:11 <dons_> cool stuff, http://www.reddit.com/r/programming/comments/6tf4e/write_a_library_to_access_bus_timetable_info/
08:31:12 <lambdabot> Title: Write a library to access bus timetable info :: Haskell : programming, http://tinyurl.com/639oez
08:31:17 <Shiruka> not a fair comparison! the orange technology has advanced far since the invention of apples in Eden!
08:31:26 <Shiruka> compare modern mandarin oranges to apples, then oranges win!
08:33:16 <simony> Hey, why is "if" syntax, and not just a function?
08:34:13 <Shiruka> so that you wouldn't have to define then = True and else = True in addition to otherwise = True?
08:34:45 <myxie> simony: syntactic sugar
08:35:28 <Philippa> simony: there's a function version somewhere, but people like to read the 'traditional' form
08:35:33 <Shiruka> or maybe then = else = error "Syntax Terror"
08:37:40 <simony> @pl f x = if x == 0 then 1 else 2
08:37:40 <lambdabot> f = flip (flip if' 1 . (0 ==)) 2
08:37:48 <simony> @hoogle if'
08:37:49 <lambdabot> No matches found
08:37:51 <simony> where is if' ?
08:37:54 <Deewiant> nowhere
08:38:04 <Deewiant> or maybe somewhere, but not in any standard library
08:38:16 <Deewiant> if' x y z = if x then y else z
08:38:32 <Twey> Uhm
08:38:51 <Twey> > if' True True False
08:38:52 <lambdabot>   Not in scope: `if''
08:38:58 <Twey> Uh
08:39:07 <Deewiant> only @pl knows of it
08:39:12 <Twey> So... it uses a magic function that's not defined except in @pl?
08:39:17 <Twey> Odd
08:39:24 <Deewiant> it's not magic, it's a perfectly normal function :-P
08:39:31 <Twey> Yes yes
08:39:40 <Twey> Except that nothing defines it :-P
08:39:50 <Deewiant> yep!
08:39:51 <DRMacIver> It's a misleadingly named one though.
08:39:54 <Twey> (obviously it's in the bowels of @pl somewhere, but you know what I mean)
08:40:00 <Shiruka> > let {then' = undefined; else' = undefined; if' x _ y _ z = if x then y else z} in if' True then' 1 else' 2
08:40:08 <pejo> Is anyone here working on QuickCheck or related *Checks?
08:40:08 <Deewiant> it's not even necessarily defined in @pl
08:40:15 <lambdabot>  thread killed
08:40:17 <simony> What's the equivalent of Yampa's dpSwitch in conal's Reactive library?
08:40:23 <Shiruka> :-<
08:40:25 <myxie> -- iiif True y z = y; iff False y z = z
08:40:45 <DRMacIver> (Because ' is usually used to name strict equivalents, and the if' defined there is just as lazy as if is)
08:41:05 * EvilTerran prefers to call it "bool" and put the parameters in a different order
08:41:12 <EvilTerran> like "maybe" and "either"
08:41:50 <vixey> simony: it's so that you can use less ()'s
08:42:05 <vixey> you could define
08:42:09 <vixey> data Syntax = Syntax
08:42:12 <vixey> then = Syntax
08:42:15 <vixey> else = Syntax
08:42:25 <vixey> if True Syntax x Syntax y = x
08:42:29 <vixey> if False Syntax x Syntax y = y
08:42:42 <Shiruka> if True else x then y :-P
08:42:43 <vixey> but then you have to write if (f x) then y else z instead of the usual if f x then y else z
08:42:48 <Deewiant> and then ?type if is wonderfully readable :-P
08:43:09 <Deewiant> Boolean -> Syntax -> a -> Syntax -> a -> a
08:51:19 <vixey> can every data type be turned into lambda expressions? with pattern matching turned into applications
08:51:30 <vixey> (is there a proof of this.. It's often stated as fact)
08:51:54 <dons> its all lambdas, yeah.
08:52:01 <vixey> do those lambdas typecheck?
08:52:08 <EvilTerran> yes
08:52:25 <dons> vixey: http://en.wikipedia.org/wiki/ChurchâTuring_thesis
08:52:51 <EvilTerran> basically, you represent a value as the catamorphism for that type for that value
08:52:56 <reilly> is there a way to get haddock to compile under ghc 6.8.3
08:53:05 <EvilTerran> with a parameter function for each constructor
08:53:34 <Shiruka> "lambdas all the way down"? :-)
08:53:47 <EvilTerran> and all the way up again!
08:54:19 <Shiruka> does the universe being turtles all the way down then imply that it was written in LOGO?
08:54:46 <vixey> ok so,
08:54:46 <vixey> data Term a = Var a | Lam (a -> Term a) | App (Term a) (Term a)
08:54:57 <dons> hmm, someone could clean up that wikipedia page a bit, "computing non-recursive functions is physically impossible"
08:56:37 <Philippa> and here I thought that binary not is trivial...
08:56:47 <Shiruka> > let f = print "The physically impossible just happened" in f
08:56:49 <lambdabot>  <IO ()>
08:56:52 <vixey> [[Var x]] = \a b c -> a x ; [[Lam m]] = \a b c -> b (\x -> [[m x]]) ; [[App m n]] = \a b c -> c [[m]] [[n]] ?
08:58:25 <Benigno> hi!
08:58:59 <EvilTerran> vixey, er, aside from me being unsure of what a catamorphism does with a constructor that takes a function parameter, that looks right
09:00:01 <mattam> vixey: It may not work for non-polynomial functors I guess.
09:00:25 <vixey> oh
09:00:29 <mattam> Things that don't really represent algebras.
09:00:40 <vixey> I see that makes sense
09:00:51 <vixey> my eval function doesn't type check
09:00:54 <vixey> :t let e t = e (\x -> x) (\m -> \x -> e m) (\m n -> e m (e n)) in e
09:00:55 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
09:00:55 <lambdabot>     Probable cause: `e' is applied to too many arguments
09:00:55 <lambdabot>     In the expression: e m (e n)
09:01:25 <vixey> I guess it's because you could represent terms with Term that doen't typecheck though
09:01:43 <mattam> Right. You need dependent types to type this.
09:01:49 <hackage> Uploaded to hackage: HXQ 0.8.5
09:02:05 <foo`> Hi Haskellers! I just want to say that I finally understood MONADS! Am I a smart guy like you right now? :D
09:02:22 <lilachaze> > let thn True b = Just b; thn False b = Nothing; els Nothing c = c; els (Just c) _ = c in  True `thn` 12 `els` 42
09:02:23 <lambdabot>  12
09:02:55 <mattam> Hmm, wait. You can't write eval on Term but you should be able to write [[]] :)
09:03:09 <lilachaze> vixey: my favourite implementation of if without syntax ^^
09:04:42 <chrisdone> foo`: now you must understand nomads
09:06:09 <lilachaze> foo`: when you reach the third or fourth time of thinking "now i *really* understand monads" you're probably getting close ;-)
09:06:57 <Shiruka> monad -> nomad -> damon -> demon? deals with the devil the IO monad promises to the Haskell nomad
09:07:49 <foo`> Well, long way is waiting for me
09:07:56 <foo`> ]:->
09:08:09 <chrisdone> ^Â·âÂ·^
09:09:29 <Philippa> lilachaze: I wouldn't say that. First time I reckoned I really had it, I had
09:09:59 <foo`> Oh, and the funniest part is that I had enlightment while reading Real Wold Haskell's chapter about monad TRANSFORMERS
09:10:07 <FordCortina> @quote Pseudonym newbie
09:10:07 <lambdabot> Pseudonym says: A "newbie", in Haskell, is someone who hasn't yet implemented a compiler. They've only written a monad tutorial.
09:10:20 <Philippa> foo`: that's not so silly, really
09:10:29 <FordCortina> :D
09:10:35 <vixey> foo`: well the question is, what will you do with knowing this?
09:10:42 <Philippa> once you've first got that monad transformers are just "functions" on monads, it does help show up what you're dealing with
09:10:55 <Philippa> vixey: launchMissiles!
09:11:04 <vixey> hehe
09:11:10 <Shiruka> vixey: write lots of cool software and upload it on hackage?
09:12:00 <Shiruka> </wishesForChristmas>
09:14:06 <foo`> I always wanted to write a game
09:14:14 <foo`> In functional style
09:14:19 <vixey> foo`: that sounds like a good idea
09:14:41 <foo`> just because I am curious how to do something like a game without side-effects
09:15:21 <Twey> With monads.
09:15:50 <foo`> I learned how to program (imperative) on games and this should also begin my new chapter in programming - FP
09:15:52 <xif> foo`: program it with special effects instead
09:15:54 <Cale> foo`: Well, you do need to express effects at some point. :)
09:15:59 <Twey> Haha
09:16:04 <xif> (I'll be here all week)
09:16:13 <Twey> foo`: Haskell programs can't perform side effects
09:16:35 <Twey> But they can create a value that tells the compiler what side effects should happe
09:16:38 <Twey> n
09:17:07 <xif> foo`: take a look at this: http://people.cs.uu.nl/stefan/blog/00010.html
09:17:10 <lambdabot> Title: Personal Web Pages of Stefan Holdermans: Monadic Game Engine
09:17:13 <lilachaze> Haskell is a weird language, where what you write is not a program to do what you want, but a program to compute and return the program which performs the side effects you want
09:17:20 * Shiruka secretly performs some unsafe IO
09:17:36 <foo`> xif: HOpenGL?
09:17:50 <Japsu> Shiruka: http://arcanux.org/lambdacats/unsafeperformio.jpg
09:17:52 <Botje> "what are you doing there?" "i'm masturbating!" "oh, I thought you were unsafePerformingIO"
09:18:00 <Twey> Hahaha
09:18:02 <Shiruka> :-D
09:18:20 <xif> foo`: hm?  no. it's a small scale demonstration of writing a simple game in Haskell with monads.
09:19:06 <vixey> xif, very nice
09:19:45 <Cale> foo`: I suppose a game wouldn't be too different in large scale design than most Haskell programs that do IO. You'd have some model of the game state (and pure functions that transform that in various ways), and then a shell around that which takes input from the user and displays the current state.
09:19:53 <foo`> do they implement something like simplified opengl? operating directly on pixels? Coz I am looking for sth like this
09:20:36 <geezusfreeek> foo`: the standard libs come with direct opengl/glut bindings
09:20:52 <geezusfreeek> well, ghc anyway
09:21:19 <geezusfreeek> there are also SDL and GLFW bindings out there
09:22:37 <geezusfreeek> foo`: oh, wait, you mean you _want_ something a bit more limited than opengl?
09:22:49 <foo`> No, something like ogl
09:22:58 <foo`> but implemented in Functional ALnguage
09:23:00 <geezusfreeek> ah, well there is opengl already ;)
09:23:01 <Shiruka> hm, interesting @ the monadic game engine link
09:23:16 <geezusfreeek> there are also some small attempts at declarative 3d programming
09:23:17 <foo`> *Language
09:23:25 <Shiruka> yesterday someone was asking here about SDL bindings on OS X, as he couldn't get it to work
09:23:39 <geezusfreeek> Shiruka: do you recall who it is? i have it working
09:23:43 <geezusfreeek> it wasn't trivial
09:24:22 <Shiruka> I don't, unfortunately..
09:26:35 <Shiruka> fortunately we have logs :-)
09:26:46 <Shiruka> 20:27:16 <O_4> Unfortunately, it's still trying to find a SDL_main, which I seriously doubt is gonna exist.
09:26:48 <foo`> Do you think some day most games will be in functional language? You know, I think about transparent concurrency on multimultimulticore PS4/5/6.
09:26:56 <Shiruka> 20:28:03 <O_4> I wonder if this ever actually got tested on OS X...  Does anyone know?
09:27:09 <vixey> um....
09:27:20 <geezusfreeek> ah, i know this person from another channel
09:27:23 <Cale> foo`: I fully expect that someday most programs in general will be written in a functional language.
09:27:26 <foo`> Coz I think if yes, they will, we need something like functional opengl
09:27:29 <vixey> look at the link xif gave....
09:27:35 <vixey> http://people.cs.uu.nl/stefan/downloads/gameloop.html
09:27:35 <lambdabot> Title: Personal Web Pages of Stefan Holdermans: Simple Maze Game
09:27:40 <vixey> this is SDL on mac os x
09:27:53 <Cale> foo`: Yeah, we do need a nice design for a functional library that manages that sort of 3D
09:28:08 <Shiruka> vixey, that link is exactly why I recalled O_4 asking this yesterday :-)
09:28:15 <vixey> oh
09:28:23 <Cale> foo`: We have an IO-monadic binding to OpenGL, but of course, that means it's still fairly imperative.
09:28:23 <Shiruka> I use only Linux myself, so couldn't answer anything..
09:28:44 <geezusfreeek> the problem is that the SDL library on OS X has its own main function
09:29:00 <geezusfreeek> which clashes with the one generated by haskell
09:29:20 <geezusfreeek> so you have to write your program with a false main function and call it from C
09:30:19 <Shiruka> would be nice to have that documented on the wiki
09:30:30 <geezusfreeek> and also have to arrange for a .app bundle too
09:30:40 <geezusfreeek> otherwise input doesn't always work properly
09:30:44 <foo`> Cale: If it all will be functional, when can I expect teaching Haskell in elementary schools? :D
09:31:05 <geezusfreeek> yeah, i think i should add that to the wiki sometime
09:31:06 <Cale> foo`: Actually, I've helped a bit with a project that was doing just that.
09:31:29 <foo`> teaching Haskell kids in elementary?
09:31:31 <foo`> %)
09:31:38 <Cale> foo`: There was a group of 10 and 11 year old kids that were learning some basic mathematics and Haskell using "The Haskell Road"
09:32:09 <Cale> I was actually working on another project, but I was in the same room as them, so I'd help them with things from time to time.
09:32:15 <foo`> Isn't it too much math dense?
09:32:27 <Cale> They seemed to manage just fine.
09:33:14 <foo`> Well, in Poland in elementary I haven't seen a computer at school. I am 19 now.
09:34:18 <Twey> Owch
09:34:30 <Twey> I have 'The Haskell Road'
09:34:33 <Twey> Is it good?
09:34:46 <Twey> It doesn't seem to involve monads *sniffs it suspiciously*
09:35:51 <jberryman> I'm trying to figure out how to use random data in a program. reading the wiki I came to If you want different numbers then you have to use a different StdGen argument.
09:35:51 <jberryman> sorry, that last bit was meant to be in quotes and not sent yet...
09:35:51 <jberryman> here: http://en.wikibooks.org/wiki/Haskell/Hierarchical_libraries/Randoms
09:35:53 <lambdabot> http://tinyurl.com/2fpup7
09:35:58 <jberryman> which StdGen argument would one use?
09:36:11 <FordCortina> @src const
09:36:11 <lambdabot> const x _ = x
09:36:49 <Shiruka> "main = print result" should be enough for anyone
09:36:57 <Botje> @hoogle getstdgen
09:36:58 <lambdabot> System.Random.getStdGen :: IO StdGen
09:37:23 <Botje> jberryman: that one, for example
09:38:39 <jberryman> so let triple = generate 1 (getStdGen 1) randomTriple ?
09:39:40 <jberryman> when using Test.QuickCheck?
09:40:03 <Cale> Twey: It makes a nice course, but if you're just trying to learn Haskell or just trying to learn basic mathematics, there are less compromising approaches to each.
09:40:31 <Twey> Cale: I see :-\
09:41:08 <Cale> But it is a neat book, certainly check it out :)
09:42:45 <foo`> Just curious: what was YOUR first Haskell program after understanding monads?
09:43:07 <Shiruka> > take 3 $ randoms (mkStdGen 0) :: [Int]
09:43:10 <lambdabot>  [2092838931,-2143208520,2034827062]
09:43:17 <Shiruka> > take 3 $ randoms (mkStdGen 1) :: [Int]
09:43:18 <lambdabot>  [-604496784,-727467101,-1561284000]
09:43:22 <foo`> I feel it is magical moment, I should pick up something special :)
09:43:36 <vixey> foo`: I wrote lots of haskell code without having a clue what anything meant
09:43:40 <Cale> I'm not sure that I remember. It was something involving a parser, since the point at which I understood monads was when I learned Parsec.
09:43:55 <geezusfreeek> i think i solved some logical problems with the List monad
09:44:11 <geezusfreeek> and then i played with parsers for a short bit
09:45:52 <Shiruka> I didn't really write any Haskell code before reading a lot about all kinds of things, including monads
09:46:23 <Shiruka> then when I did write something I had many sledgehammers to utterly crush small innocent fly-sized problems
09:46:23 <foo`> Shikura: Lazy evaluating? :>
09:47:59 <foo`> I've done sth like you with Common Lisp. I read Practical Common Lisp and On Lisp. But after that I think that Lisp is boring and I didn't write ANY code in Lisp.
09:48:06 <Shiruka> sort of lazy evaluating haskell, putting off using it until I had read enough that I just had to try :-)
09:48:23 <vixey> that sounds more like strict evaluation to me ...
09:49:03 <Shiruka> vixey: think of it like reading a book about math and being lazy about all the exercises ;-)
09:49:09 <geezusfreeek> that is exactly what i did with scheme. i read all about it and then did nothing
09:49:16 <foo`> vixey: programming terms in real life aren't accurate, I think
09:49:30 <geezusfreeek> ah the math book example is good. i do that
09:49:32 <chrisdone> real.. life?
09:50:18 <foo`> yes, beer, chicks, evenings. I've read about it on digg.
09:50:30 <chrisdone> ...digg?
09:50:31 <geezusfreeek> it's weak head normal form. the exercises are constructors and the solutions are thunks
09:50:44 <Shiruka> my first haskell programs were stuff like solving puzzles using the list monad with some maybe monad thrown in
09:51:27 <geezusfreeek> project euler is always fun, but it gets old since it doesn't exercise your IO-fu very much
09:51:46 <chrisdone> mine was a four in a row computer player. I went from YAHT to that and had a massive learning curve. "OMG CHRIS HAET COMPILE TYPE ERRORS"
09:52:20 <ksandstr> my first proper haskell program was a huffman compressor. the interesting part was doing binary I/O in haskell though
09:52:36 <foo`> huffman. bingo. thanks.
09:53:41 <Shiruka> my conjecture that people try haskell only after they have multiple other languages under their belt just gets stronger and stronger..
09:53:58 <ptolomy2> Hrm. The Macports hs-plugins doesn't build.
09:54:03 <Cale> Shiruka: that's mainly because it's not high profile enough :)
09:54:06 <ptolomy2> This makes me sad, because I wanted to try out yi.
09:54:08 <geezusfreeek> i _still_ haven't made a huffman compressor. it always seems like it'd be a good exercise
09:54:19 <Cale> Shiruka: There are some people for whom Haskell is their first programming lanugage :)
09:54:30 <chrisdone> cale: really?
09:54:30 <ksandstr> geezusfreeek: go for the adaptive huffman compressor in that case, it's more entertaining
09:54:31 <dolio> Most people only hear of Haskell after learning multiple other languages.
09:54:34 <Cale> chrisdone: yeah
09:55:04 <chrisdone> cale: that would be interesting. like a reverse of the "BASIC" effect
09:55:09 <Cale> yeah :)
09:55:47 <ddarius> chrisdone: I imagine people who learn Haskell as a first language never go on to learn "BASIC"
09:56:00 <kriomant> is there inverted '$' operator (i.e. 'a -> (a -> b) -> b') somewhere in the standard lib?
09:56:13 <Shiruka> uh, people still learn "BASIC" these days?
09:56:14 <geezusfreeek> "You mean in C I have to use these _numbers_ to refer other things in memory?!"
09:56:27 <Cale> kriomant: no, but you can write  flip ($)
09:56:36 <Shiruka> I thought the only basic left alive was Visual Basic, and that it'd be just C# with a slightly different syntax
09:56:42 <ksandstr> Shiruka: sure. friend of mine started his son out on a c64 because of "tradition"
09:56:52 <Shiruka> lol
09:57:07 <Shiruka> I started with c64 basic when I was a kid, but that's only because I'm old
09:57:12 <ksandstr> in a way it's pretty good, given that it's very difficult to irreparably break a c64
09:57:30 <chrisdone> I was referring to Dijkstra's observation that people whose first language was BASIC are broken beyond repair
09:57:35 <Cale> A hammer will do that nicely.
09:57:41 <geezusfreeek> i started with basic as a kid too, but that's just because it was all the library had books on that i could understand (oriented toward kids)
09:57:57 <Shiruka> chrisdone: take what dijkstra has said with a lot of salt..
09:58:11 <chrisdone> Shiruka: of course. BASIC was my first language
09:59:01 <dolio> Visual Basic was my first language, but it's well beyond BASIC as programming langauges go, I think.
09:59:22 <chrisdone> dolio: yeah, VB was my second
09:59:33 <Philippa> Dijkstra's observation was from back when BASIC didn't even have GOSUB, wasn't it?
09:59:43 <Shiruka> these days I'd recommend python as the first language
09:59:46 <ksandstr> and wasn't dijkstra a fortran man himself?
09:59:48 <Vq^> ZX80 BASIC was my first language
10:00:37 <kryptiskt> dijkstra was more of an algol-60/pascal man
10:01:00 <Shiruka> python, C, asm, lisp, haskell, in that order, might be a good route
10:01:32 <chrisdone> I went BASIC->VB->C->CL->Scheme->Haskell, in terms of most used languages, that is
10:01:34 <vixey> logo prolog and pascal
10:01:35 <Vq^> i think assembler with pen and paper saved me :o)
10:01:40 <chrisdone> basically gradually more and more functional
10:01:49 <hackage> Uploaded to hackage: Pugs 6.2.13.9
10:02:04 <Shiruka> asm is one of the things which you won't be using much but I wouldn't much trust a programmer who doesn't understand asm at all
10:02:26 <vixey> I've never written any assembly
10:02:30 <chrisdone> me neither
10:02:34 <Vq^> a C programmer probably has to understand asm
10:02:37 <vixey> why would I want to?
10:02:38 * Elly has written altogether too much assembly
10:02:43 <dolio> I remember learning C++ before C because I thought it was supposed to be easier.
10:02:47 <vixey> you don't need to know any assemby for C
10:02:51 <Cale> I've only written assembly for toy architectures. Unless you count the programs I wrote which write assembly.
10:03:00 <Shiruka> you could say that C is portable assembly so it's a first approximation, but.. :-/
10:03:05 <Elly> I've written too much x86 assembly :X
10:03:17 <Vq^> vixey: no, but it gives better understanding of the keywords and behaviour
10:03:18 <chrisdone> knowing asm tends to corrupt people's understanding of C's semantics
10:03:25 <Elly> chrisdone: 'corrupt'?
10:03:27 <vixey> oh well I've written small amounts when I had to actually
10:03:29 <geezusfreeek> corrupt? for like liberate
10:03:50 <xif> wrt the earlier game programming discussion:
10:03:50 <xif> http://beust.com/weblog/archives/000375.html
10:03:51 <lambdabot> Title: Otaku, Cedric's weblog: A programming language for 2010
10:03:56 <kryptiskt> it's good to be able to read assembly for debugging, source views lie every now and then
10:04:18 <Vq^> i wrote a small telnet-like program for UNIX in assembler and Haskell, gives some perspective :)
10:04:21 <geezusfreeek> i think learning assembly is good even if only to force you to learn the architecture you are working with
10:04:22 <Philippa> Shiruka: C makes a shit portable assembly, for reasons discussed earlier. It's probably the next level up from that
10:04:23 <ksandstr> I've never quite understood exactly why one wouldn't teach C as a first language. it's a small language, few bells and whistles, the parts combine exactly as you'd expect them to and there's no magic in it
10:04:25 <chrisdone> elly: well, check out ##c and observe the people asking questions that make assumptions about architecture and "the stack"
10:04:27 <Philippa> (cf FORTH)
10:04:35 <Shiruka> chrisdone: it's more about understanding the execution model of the underlying computer
10:04:52 <geezusfreeek> ksandstr: "there's no magic in it" ... have you ever used gcc? ;)
10:05:01 <vixey> ksandstr: It's horribly complex and (should be) useless
10:05:01 <Philippa> ksandstr: and it's also got fuck all actual /support/ for serious data structure work
10:05:02 <Shiruka> I don't mean that you should know every instruction, just how it basically works
10:05:32 <ksandstr> Philippa: sorry, what do you mean with actual support?
10:05:34 <Philippa> Shiruka: I have a machine sitting a short way from me with no hardware stack, btw
10:05:52 <Cale> Programming in C forces the programmer to worry about details that programmers should generally not have to worry about.
10:05:57 <Elly> vixey: by what measure is C horribly complex?
10:05:57 <ksandstr> vixey: ... is that wishful thinking?
10:06:03 <Elly> Cale: someone has to worry about them
10:06:18 <chrisdone> elly: yes, those who are writing device drivers or something
10:06:20 <Elly> Cale: training programmers who are not even informed that those details exist seems like a bad idea
10:06:30 <vixey> Elly: the syntax and semantics of the language ...
10:06:35 <Elly> chrisdone: or writing a memory allocator or something
10:06:38 <Shiruka> Philippa: well, often portability isn't as important as other considerations
10:06:41 <Philippa> ksandstr: the only structures C knows about are records and "overlapping" unions
10:06:44 <qwr> assembler is boring, real programmers write in hex (i have done it) ;)
10:06:47 <vixey> It's easy to write pages and pages of C code that work
10:06:49 <ksandstr> Cale: who determines "should not have to understand"?
10:06:52 <Shiruka> few programs are written in pure ISO C
10:06:52 <Elly> qwr: I've done it too, it sucks
10:06:52 <Vq^> Elly: quite a few things in C gets complex
10:06:52 <Philippa> Shiruka: at which point it makes a shit asm
10:06:54 <Cale> Elly: I think it's best to start with something having nice clean semantics and doesn't bother with architectural details at first.
10:06:56 <kryptiskt> if C was so bad, every other language surely wouldn't write their RTS in C.
10:06:57 <vixey> you do this by trial and error
10:07:10 <Cale> ksandstr: I said "generally should not have to worry about"
10:07:13 <ksandstr> Cale: I mean, I for one think that people should understand manual memory management or go back to flipping burgers
10:07:25 <ksandstr> Cale: ah, apologies
10:07:28 <Vq^> Shiruka: what are the exceptions?
10:07:33 <vixey> programming by trial and error is why 90% of software is completely broken
10:07:34 <geezusfreeek> real programmers use punch cards like my grandpa
10:07:38 <Shiruka> Philippa: it's more portable than asm though.. a reasonable compromise
10:07:48 <Philippa> geezusfreeek: punch cards are cheating. Hardwire it!
10:07:56 <ksandstr> Philippa: why would a language know about data structures? by that token Haskell wouldn't know about trees.
10:08:24 <Cale> ksandstr: and I don't think manual memory management is really all that important. If you understand how a garbage collector works, that easily makes up for it :)
10:08:41 <Philippa> ksandstr: Haskell does know about recursive datatypes, however
10:09:02 <kryptiskt> actually if C had templates, tagged unions and typease it would be a very nice language, but I guess that's Cyclone.
10:09:10 <kryptiskt> typecase
10:09:17 <Elly> Cyclone isn't a nice language :(
10:09:18 <Cale> C + algebraic datatypes?
10:09:33 <vixey> oCaml
10:09:35 * Elly wrote a file system in Cyclone and regrets it to this day
10:09:38 <ksandstr> Philippa: ... yeeeeees... and one can declare a pointer to a structure inside the structure itself in C. I don't see the thing that distinguishes the two here
10:09:51 <geezusfreeek> work time, byebye
10:09:52 <Shiruka> chrisdone: why the CL->scheme transition, btw?-)
10:09:57 <Cale> C's type language is probably its worst aspect.
10:10:05 <Benigno> mmm
10:10:05 <Philippa> ksandstr: in Haskell I don't have to fuck about with pointers and memory management just to have a recursive datatype, that's the difference
10:10:07 <Cale> (just that it's unreadable)
10:10:15 <Elly> Cale: how so?
10:10:16 <Benigno> if I have an anonymous function
10:10:34 <Shiruka> I think that scheme->CL is common enough, but CL->scheme I don't hear about so often
10:10:36 <Vq^> function types in C looks quite horrific
10:10:37 <chrisdone> shiruka: better default libraries and documentation
10:10:40 <Philippa> not only that, even when I'm done my program still doesn't know what a 'recursive datatype' looks like - I don't mind having to start from low-level, it's having to stay there that's bad
10:10:42 <Benigno> \a b -> a ++ show b
10:10:45 <ksandstr> Philippa: okay. how does this translate into proper support for data structures, other than programmer convenience?
10:10:48 <Elly> Vq^: void (*func)()?
10:10:48 <Cale> Elly: The reason that Vq^ points out :)
10:10:50 <Shiruka> chrisdone: mzscheme?
10:10:55 <chrisdone> shiruka: right
10:10:59 <Benigno> how can I tell him that b must be an Int¿?
10:11:00 <Philippa> ksandstr: support means more than "you can do it"
10:11:00 <Vq^> Elly: yeah
10:11:11 <wjt> @ty (\a (b::Int) -> a ++ show b)
10:11:11 <Elly> Vq^: use a typedef :)
10:11:14 <lambdabot> String -> Int -> String
10:11:18 <vixey> Benigno: why would you want to though?
10:11:20 <Elly> Vq^: haskell looks pretty ugly too if you never define your own datatypes
10:11:23 <Benigno> nice wjt
10:11:25 <pejo> ksandstr, programmer convenience shouldn't be underestimated.
10:11:30 <Philippa> C doesn't /support/ OO. It's doable, sure.
10:11:33 <Cale> Elly: C gets bad well before Haskell does though.
10:11:43 <ksandstr> pejo: agreed. but that's distinct from support for data structures
10:11:48 <Benigno> ambigous variable occurrences
10:11:51 <Cale> Fairly simple types in Haskell are brutal to express in C. :)
10:12:01 <Cale> (if they can be expressed at all)
10:12:02 <Elly> sure, because Haskell is a high-level language and C is not
10:12:03 <Philippa> Cale: exactly!
10:12:08 <vixey> Benigno: huh? is that a compiler error?
10:12:15 <Elly> on the other hand, *((int*)0xdeadd00d) = 0; is fairly brutal to express in Haskell
10:12:16 <kryptiskt> Philippa, No OO is the best thing about C!
10:12:17 <vixey> C is a high level language ...
10:12:31 <baaba> who says you can't do OO in C
10:12:34 <vixey> Elly, What are the semantics of that in C?
10:12:41 <vixey> Elly, (there aren't any...)
10:12:43 <Elly> vixey: write the integer zero to address 0xdeadd00d
10:12:46 <chrisdone> who says you can't do numbers in lambda calculusâ½
10:12:47 <Benigno> the hugs tells me that "show" can be from Hugs.Prelude.show or NeuralNetwork.show
10:12:47 <vixey> no
10:12:54 <Elly> vixey: it's an ordinary pointer dereference o_O
10:12:56 <vixey> that's what it might do, you could figure out it based on your compiler
10:12:56 <Vq^> it's not tainted by the OO trolls at any rate
10:13:01 <vixey> but this is not valid C code
10:13:07 <vixey> C does not give semantics to that statement
10:13:08 <Elly> it certainly is
10:13:19 <Shiruka> chrisdone: I haven't actually used CL for anything more than very short programs, I periodically look at it like "hmm, I wonder why I still don't use CL", then look at available third-party libs, see them talking about "support for gtk2 is around the corner" (I forgot that gtk1 existed a long long time ago in a galaxy far far away..)
10:13:21 <baaba> it's undefined behavior, he's trying to say
10:13:22 <Elly> okay, maybe not in C99
10:13:24 <Philippa> ksandstr: this lack of support makes for a bad first language because it makes it much harder to write high level code
10:13:24 <baaba> only in a smart way
10:13:25 <chrisdone> yes, you can emulate and hack lots of things in languages, but that's not the same as the language directly supporting it
10:13:32 <Shiruka> and then I remember why I always end up using something else :-)
10:13:32 <Elly> yes, it is undefined, but it acts as you'd expect
10:13:37 <baaba> no it doesn't
10:13:39 <baaba> it's undefined behavior
10:13:49 <baaba> it _might_ act as you'd expect
10:13:55 <vixey> baaba: she.. and I am not trying to be smart, I'm trying to point out all the C code everybody writes is meaningless
10:13:57 <Elly> find me a compiler where it doesn't
10:13:58 <Cale> Prelude Foreign.Ptr Foreign.Storable> poke (plusPtr nullPtr 0xdeadd00d) 0
10:13:59 <Cale> Segmentation fault
10:14:01 <ksandstr> Philippa: but you wouldn't write high-level code in your first programming language, would you? after all you'd just be learning how to print "hello, world!" and read files and count words and so forth
10:14:10 <baaba> vixey, that's a fairly strange statement
10:14:12 <Philippa> vixey: C is not a high level language for general purpose by Perlis' definition
10:14:15 <vixey> Elly: compilers don't matter, I care about algebraic reason over my code
10:14:18 <BMeph_> WriteToMyIORef {addr = 0xdeadd00d} 0 -- that's tough? ;)
10:14:27 <Vq^> Elly: not the point, there could theoretically be one where the code breaks
10:14:33 <Elly> BMeph_: like other people said, that is fairly brutal :P
10:14:35 <vixey> Elly: If you want to write correct code in C, it's just not even worth using C
10:14:45 <MyCatVerbs> BMeph_: actually...
10:14:46 <BMeph_> Cale: You forgot (core dumped). :)
10:14:52 <Philippa> ksandstr: yes, yes you would. High level code is precisely about keeping everything that simple once you know how, you should be encountering the idea within a few hours
10:14:55 <Cale> I think I have core turned off.
10:14:55 <baaba> vixey, that's another fairly strange statement
10:15:14 <Elly> vixey: there is no other language for writing operating systems in...
10:15:17 <Philippa> just as you'd expect to encounter the idea of functions or procedures
10:15:20 <baaba> Elly, wrong
10:15:27 <Elly> baaba: what do you suggest instead?
10:15:28 <RayNbow> HOUSE is written in Haskell
10:15:33 <Shiruka> language standards don't usually even define enough of the language to be really useful
10:15:35 <baaba> both sides have completely retarded arguments
10:15:37 <baaba> i don't know what to do
10:15:38 <baaba> :(
10:15:38 <MyCatVerbs> BMeph_: Foreign.Storable.poke, surely?
10:15:39 <RayNbow> or something like that...
10:15:50 <ksandstr> Philippa: how is the usual way of doing data structures in C not simple? I mean, function calls. that's not barbie-level hard right?
10:16:00 <RayNbow> http://x86vmm.blogspot.com/2005/10/house-haskell-os.html
10:16:01 <lambdabot> Title: Gimme Hardware/Software Interface.: House -- The Haskell OS
10:16:03 <Shiruka> does even std haskell define what _|_ is? would it be a conforming implementation of an eternal loop to launch nethack and exit?
10:16:08 <slarba> where's Ada? :)
10:16:14 <smtms> oh, and I thought I was in the C channel
10:16:25 <baaba> Elly, C++, Forth, C#, Haskell, Java, Brainfuck, whatever
10:16:30 <chrisdone> shiruka: well I remember a specific point of a week or two of frustration with CL, of trying to do some simple socket programs and discovering that the CL implementation I was using had dodgy sockets which weren't even documented, and that to get a portable library to work on all CL's never worked properly (if it even compiled.. I can't remember). anyway, I downloaded mzscheme and had (1) threads -- lightweight threads! (2) sockets (3) a GUI, ...
10:16:32 <zaarg> Gosh, another relative merits of C and Haskell discussion.
10:16:33 <MyCatVerbs> ksandstr: shopping is hard, let's prove isomorphisms using operational semantics.
10:16:38 <Philippa> ksandstr: You've clearly never seen entire classes struggle with pointers and implementing their own linked lists
10:16:51 <dolio> @type intPtrToPtr (fromInteger 0xdeadd00d) :: Ptr Int
10:16:52 <lambdabot> Not in scope: `intPtrToPtr'
10:16:52 <lambdabot> Not in scope: type constructor or class `Ptr'
10:17:10 <ksandstr> Philippa: how is that bad? struggling is part of learning, isn't it? (also a part of weeding out the unworthy, klingon-style, but that's beside the point)
10:17:16 <BMeph_> MyCatVerbs: Well, yes, if we're staying strictly with library commands.
10:17:34 <ksandstr> Philippa: and again people would run into the "wait, why is this list accessed by reference again?" thing with Python and Java and whatever
10:17:47 <Shiruka> chrisdone: otoh, mzscheme's libs aren't portable to other schemes either :-)
10:17:49 <Elly> baaba: I should like to see an OS written in any of those to vixey's standard of linguistic awesomeness
10:18:01 <BMeph_> baaba, smtms: If you don't like the topic,...start a new one! :)
10:18:13 <vixey> Elly, I don't know what you're referring to
10:18:19 <Philippa> ksandstr: I didn't cite Python and Java as better alternatives
10:18:40 <baaba> Elly, wait, why did you just add strange indecipherable conditions to your initial query?
10:18:44 <Philippa> and yes, it's bad because you have to solve that /before/ being able to do anything useful
10:18:46 <chrisdone> shiruka: well, personally I don't care. I'll stick with mzscheme. the lispers seem to take a similar attitude with SBCL, and haskellers may do with GHC
10:18:50 <Elly> baaba: maybe! :P
10:18:52 <Shiruka> ksandstr: in python everything is accessed by reference..
10:18:58 <ksandstr> Philippa: very well. but would you rather shield students from having to ever get sort-of intimate with the machine, by putting mittens on their hands?
10:19:15 <baaba> Elly, you asked for languages other than C to write an OS in; i gave you some
10:19:18 <Cale> ksandstr: I don't think anyone claimed that. We were discussing *first* languages :)
10:19:19 <Philippa> ksandstr: Take the strawman and shove it, thanks
10:19:22 <vixey> the problem with teaching C, is the students might go out and -use- it
10:19:32 <dolio> poke (intPtrToPtr (fromInteger 0xdeadd00d)) (0 :: Int)
10:19:37 <smtms> Elly, any language which doesn't prevent you from accessing low-level hardwdare features is good enough for OS programming
10:19:39 <ksandstr> Cale: true
10:19:39 <chrisdone> vixey: hehe
10:19:43 <Philippa> vixey: that, or think it's all they can use as soon as they get out of a browser
10:19:44 <pejo> ksandstr, the problem for new students is that they can't see the forest for all the trees though. They will see (and remember) the problems with getting things to work, and many of the first year students pretty much program by permuting the program until it does what they hope for.
10:19:46 <baaba> Elly, you can check out the l4ka kernels and BeOS for C++, check out microsoft Singularity for c#, what they gave above for Haskell,
10:19:52 <baaba> and there was a java OS too but i forget its name
10:20:09 <baaba> certainly there is no requirement that an OS be written in C
10:20:09 <Elly> baaba: Singularity has a CLR written in C as its core afaik, with the rest of the OS running on that
10:20:19 <Philippa> being able to handle abstraction and see multiple layers of the stack at once is far more important overall
10:20:20 <Shiruka> chrisdone: that's pretty much my worlview too, scheme = mzscheme, CL = SBCL, haskell = GHC.. modulo some value
10:20:26 <baaba> Elly, it's in C++ actually
10:20:32 <dolio> Actually, that fromInteger is unnecessary.
10:20:33 <Elly> yes
10:20:35 <baaba> and it's a very small part
10:20:37 <ksandstr> pejo: but that sounds like an issue with the teaching rather than the language
10:20:43 <Elly> and I would imagine it's C++ without RTTI or exceptions
10:20:50 <baaba> possibly
10:20:51 <dolio> 0xdeadd00d is a valid IntPtr literal.
10:20:56 <ksandstr> pejo: I mean it's not like you could get very far by randomly permuting a haskell program, right?
10:21:11 <baaba> you could do those parts in assembler too
10:21:23 <MyCatVerbs> BMeph_: writeIORef will box it though, won't it? Storable's poke will get you the same in-memory representation as the appropriate C type, no?
10:21:28 <baaba> and writing a microkernel in some lower level language does not mean the rest of the OS needs to be written in that language
10:21:33 <baaba> the microkernel is just that
10:21:38 <chrisdone> shiruka: I remember having some problem with CLISP and talking about it in #lisp, and the concensus seemed to be "well, it works in SBCL, ... [so use SBCL like everyone else]"
10:21:44 <baaba> and the rest of the OS is much larger and much more significant
10:22:10 <baaba> there are other languages that can be used for that as well
10:22:20 <Cale> poke (intPtrToPtr 0xdeadd00d) 0
10:22:20 <vixey> ksandstr, pejo is saying exactly what I've been saying.. C doesn't have meaningful semantics for half the of the crap a compiler accepts, when you write in C you are doing it by trial and error
10:22:21 <baaba> i see no reason why you couldn't write the lowest level core in D for example
10:22:23 <baaba> or Forth
10:22:30 <baaba> C is not necessary, contrary to common claims
10:22:40 <baaba> it's strange how people have that idea
10:22:42 <Elly> you can write them in those languages as long as you use those languages like C
10:22:43 <baaba> it reeks of magical thinking
10:22:47 <baaba> wrong
10:22:48 <pejo> ksandstr, if that statement is true then it doesn't matter what language you teach in the first course, it's all a matter of teaching.
10:22:51 <kryptiskt> is there any life in other haskellen besides GHC? JHC? YHC? nhc?
10:22:51 <ksandstr> vixey: ... what?
10:22:58 <baaba> writing low level Forth code is nothing like writing low level C code
10:23:00 <Elly> you can't, e.g., allow a GC run during an interrupt handler
10:23:02 <dolio> baaba: What's your Forth written in! Hur! :)
10:23:15 <chrisdone> forth
10:23:21 <vixey> ksandstr: Something I said didn't make sense?
10:23:22 <dolio> Oh no!
10:23:24 <Cale> kryptiskt: people are working on those, but obviously they have less resources available to them
10:23:42 <Philippa> ksandstr: a language that forces you to face particular problems is worse for teaching purposes where you don't intend to face that problem than one that doesn't
10:23:50 <chrisdone> fix (write-with forth)
10:23:53 <Associat0r> http://bitc-lang.org/
10:24:00 <lambdabot> Title: The BitC Programming Language
10:24:27 <Elly> alright, I actually have work to do, so I'd better detach from IRC
10:24:30 <Philippa> similarly, a sufficiently high-level language will allow you to construct exercises that face precisely those problems and no others
10:24:44 <Elly> you guys are probably write but I still like C :)
10:24:44 <Philippa> (at least, a sufficiently high-level general-purpose one!)
10:24:51 <baaba> sure like it all you want
10:24:59 <baaba> i'm not against that
10:24:59 <Elly> I may be biased because my job involves hacking on a C compiler
10:25:00 <ksandstr> vixey: well you make it sound as though every C program written so far is unfit to exist, when this clearly isn't so
10:25:04 <baaba> but i'm against magical thinking
10:25:07 <Philippa> Elly: I'll still use C (OK, more likely C++) when I have to work on that level
10:25:10 <baaba> which is incredibly annoying
10:25:15 <vixey> kz
10:25:22 <Elly> I can't believe I just switched 'right' and 'write'
10:25:24 <baaba> it's unbelievable that people in an engineering discipline still employ so much magical thinking
10:25:30 <baaba> mind boggling even
10:25:38 <Elly> heh
10:25:43 <Elly> that is the motto of our operating systems class
10:25:43 <Philippa> ksandstr: merely that it has questionable value
10:25:45 <Elly> "No more magic"
10:25:49 <Philippa> an awful lot of C code has nasal demons
10:26:31 * Elly goes to do actual work now
10:26:33 <Shiruka> for values of magical equaling "not thinking the thing quite through" (too lazy evaluation?)
10:26:33 <RayNbow> baaba: well, bootstrapping is often found to be hard ;)
10:26:43 <dolio> chrisdone: I suppose a more amusing retort is "what's your assembler written in?" Probably not assembly.
10:26:52 <jamii> dependencies conflict: ghc-6.8.3.20080611 requires bytestring
10:26:53 <jamii> ==0.9.0.1.1 however
10:27:10 <jamii> yi-0.3 requires bytestring ==0.9.0.1
10:27:16 <jamii> Now thats just petty
10:27:32 <RayNbow> so it's no surprise that a lot of people think you can't write an OS using a high level language
10:27:33 <pejo> ksandstr, and it should be noted how similar experience different people from different universities have when it comes to teaching the programming.
10:27:38 <Shiruka> Elly: so your computers are stuck with the magic switch set to "magic" instead of "more magic"? ;-P
10:27:46 <ksandstr> Philippa: I have no idea what to say to that. I certainly haven't written code on purpose that had nasal demonsm, and can't really see how one would do that on purpose either unless one were confused about C's semantics
10:28:03 <vixey> ksandstr: Because C is so complex
10:28:20 <Elly> Shiruka: heh
10:28:20 <vixey> ksandstr: it takes years to be able to write C well
10:28:34 <baaba> the cases of nasal demons are fairly limited
10:28:40 <Elly> Shiruka: the goal of the class is to give students an understanding of what the OS does from hardware up to running user programs
10:28:43 <ksandstr> vixey: well it takes years to be able to do anything complex well
10:28:48 <Elly> Shiruka: we do this by making them implement a small unix kernel :)
10:28:50 <baaba> and it doesn't take that much effort to avoid them
10:28:53 <vixey> ksandstr: I am not saying somebody can't pick up C and write whatever they want in a months, it's just that there's no guarantee of it being anywhere correct
10:29:10 <Elly> vixey: there's no guarantee of the hardware being correct either
10:29:13 <kryptiskt> but it only takes hours until beginning haskellers starts writing their first monad tutorial :-)
10:29:14 <baaba> (i prefer C++ though, i like to live dangerously)
10:29:21 <Philippa> ksandstr: I've seen a lot of code with subtle nasal demons. Admittedly C++ is worse
10:29:27 <Shiruka> hmm, hardware.. interesting
10:29:33 <vixey> Elly, hardware doesn't matter
10:29:41 <Shiruka> "What language is your hardware implemented in?"
10:29:43 <Philippa> and the difficulty of catching them without careful hand-scrutiny is a valid criticism
10:29:44 <vixey> compilers don't matter
10:29:56 <Shiruka> hardware is in some sense compiled.. :-)
10:29:57 <baaba> Shiruka, verilog
10:29:58 <baaba> :P
10:30:01 <ksandstr> vixey: well true, a program fragment is only guaranteed to do well-defined things if the program hasn't done ill-defined things right before
10:30:34 <baaba> ksandstr, the funny part is that nasal demons are time traveling
10:30:49 <Philippa> Shiruka: you shouldn't assume that. I'm pretty sure my brain's not compiled, for example
10:30:59 <bd_> Philippa: it's compiled from DNA
10:31:33 <kryptiskt> Writing hardware in Haskell is quite possible
10:31:52 <bd_> your parents provide the program and a compiler, and then you spend 9 months boostrapping
10:32:38 <Philippa> bd_: *no*. 9 months bootstrapping, sure, but the mechanism's a tower of interpreters
10:33:34 <Philippa> *hardware* interpreters, operating on hardware.
10:34:02 <bd_> Philippa: hardware /compilers/. Your DNA codes for particular pieces of hardware, which in turn build bigger pieces of hardware out of themselves.
10:34:20 <chrisdone> bd, philippa: how much of what you're saying is meaningful and how much of it is speculative and abstract?
10:34:52 <Philippa> chrisdone: all of it's at least somewhat abstract. Not so speculative though - effectively we're tweaking at each others' definitions of compiler and interpreter
10:35:30 <bd_> anyway, my point is, your brain isn't running through DNA codons each time a neuron fires - the DNA just acts as instructions to build and resupply  the neurons. thus, compiled
10:36:59 <Shiruka> but maybe the brain is just an interpreter for a program running in it
10:37:04 <Philippa> bd_: interpreter for a metaprogram, IMO. Which is closely related (see partial evaluation blah blah blah), but still
10:37:18 <ksandstr> apologies for my saying so, but this channel has some _weird_ ideas about C
10:37:38 <Philippa> ksandstr: it'd probably do you some good to spend a while understanding them
10:37:48 <Shiruka> channels don't have ideas, they would be very schitzophrenic
10:38:05 <Shiruka> -t
10:38:27 <Philippa> it's true, for example, that C has no formal semantics. Granted, most languages don't either (the closest for Haskell is using a bunch of fairly ad-hoc reasoning based on equations in the report), but it's still a valid criticism
10:38:45 <Philippa> it's also true that having no formal semantics is a *major* PITA if you want to verify software
10:38:58 <ksandstr> Philippa: that C is brittle? well yes. that there's no fancy data structures in C? indeed! but man, that sounds more like "I'd like to program LISP as if it was x86 assembly too"
10:39:03 <Philippa> you may simply not want to verify it, and that's fair enough
10:39:03 <Nafai> Philippa: What's an example of something that does?  Coq or something?
10:39:16 <Cale> It's a shame that the formal semantics for Haskell wasn't maintained.
10:39:20 <vixey> Nafai: Scheme
10:39:25 <pejo> Nafai, SML
10:39:28 <Philippa> Nafai: Standard ML
10:39:31 <Philippa> dammit, pejo :-)
10:39:45 <Elly> mmm, SML
10:39:45 <vixey> Coq does too, of course
10:39:54 <Nafai> I guess I don't understand formal semantics enough to know why SML does and Haskell doesn't
10:40:12 <dolio> Nafai: No one's put in the effort for Haskell.
10:40:14 <Cale> It's mostly a matter of sitting down and writing the document.
10:40:15 <Philippa> ksandstr: not LISP, but being able to write high-level code about low-level activity is a good thing. So far FORTH's one of the better examples there (albeit a thoroughly weird one)
10:40:16 <vixey> Nafai: just because nobody wrote it down on an official bit of paper I guess
10:40:20 <Shiruka> but verifying softwareis a major PITA itself anyway :-P
10:40:45 <Nafai> So it isn't a property of the language that makes it impossible, it's just that it hasn't been done
10:40:48 <Cale> (We're using the real-world sense of the term 'exists', not the mathematical one :)
10:41:00 <Cale> Nafai: Right
10:41:09 <Nafai> Ok
10:41:14 <Cale> Nafai: In fact, the document used to exist, it just hasn't been kept up to date.
10:41:24 <Nafai> Is this pre Haskell 98?
10:41:26 <Cale> Yeah.
10:41:43 <RayNbow> Shiruka: verifying a model is already a major PITA... I don't want to imagine how awful verifying full blown software would be :p
10:41:43 <Philippa> ksandstr: even hooking up haskell to an assembler gives you an interesting level of power for example, even if it'd take a while to write useful libs. But not as much as could be, because Haskell's still not as hot as it could be for EDSLs
10:42:20 <Philippa> (naturally you lose portability there, but hey - pick another layer of abstraction as foundational, same difference)
10:42:23 <ksandstr> Philippa: I get the impression that we're discussing different things here
10:43:03 <Shiruka> I've actually been thinking of using haskell that way using LLVM..
10:43:17 <Philippa> ksandstr: I'm pretty sure your impression of what I was saying doesn't entirely match what I meant
10:43:33 <vixey> hmmmmm
10:43:38 <Shiruka> I also read a paper where they generated C for a markov simulation using haskell, it was interesting enough
10:43:38 <vixey> you want to use haskell like a forth
10:43:56 <Philippa> vixey: ...vaguely. Like a FORTH that's also a theorem prover, perhaps
10:44:05 <vixey> heh
10:44:25 <Shiruka> (.. hm, or actually it was a long time a go, so I'm no longer sure.. I _think_ it was MCMC, but maybe it was just some other monte carlo thing)
10:44:28 <Philippa> so you end up with one significant layer that's lower level than C, and another that's far higher level
10:44:44 <vixey> that would be one strange mix
10:44:58 <RayNbow> Shiruka, if you find it, would you like to submit it to reddit?
10:45:02 <Philippa> it's only so far off from the IO monad, y'know
10:45:17 <Philippa> or from monadic parsing
10:45:19 <vixey> hmm that's true
10:45:34 <Shiruka> RayNbow: I could give you the url if I find it :-P
10:45:55 <dogbite> http://hpaste.org/9160
10:46:04 <Philippa> ksandstr: my point is that I'd far rather educate beginning programmers to see low-level work as just another level of abstraction, no different from any other
10:46:08 <dogbite> i'm getting a stack overflow and don't know the best way to debug it
10:46:12 <baaba> is someone working on an llvm backend for some haskell compiler?
10:46:19 <pejo> RaynBow, Shiruka, Sounds like a paper by dons - check his unsw homepage.
10:46:19 <baaba> or is there one already
10:46:29 <RayNbow> Shiruka: well, one way or another... it's probably going to end up on reddit... I use reddit to store interesting bookmarks :p
10:46:35 <Philippa> and that means teaching them enough to think about layers of abstraction in the first place, which means aiming for code that's in a sense high-level pretty fast
10:46:48 <dolio> baaba: The GHC people seem more interested in their own backend.
10:46:49 <vixey> dogbite: what are you diong that causes it?
10:46:54 <dolio> baaba: C-- and whatnot.
10:46:57 <baaba> that's sad
10:47:05 <baaba> llvm is pretty fucking awesome
10:47:08 <dogbite> vixey: if i only knew
10:47:21 <slarba> baaba: agreed
10:47:24 <dogbite> vixey: i do build a list of about 1MM elements...
10:47:26 <dogbite> is that bad?
10:47:30 <vixey> dogbite: What expression are you evaluating that causes it
10:47:43 <dogbite> vixey: it just says Exception: stack overflow in ghci
10:47:47 <chrisdone> dogbite: are you running it inside ghci? that tends not to do full optimisation, sometimes causing overflows which usually wouldn't happen
10:47:54 <Cale> dogbite: tail recursion is your problem :)
10:47:54 * vixey gives up
10:47:57 <dogbite> i'll try outside
10:48:09 <welterde> yay! finally done with compiling
10:48:11 <baaba> imho any work on native backends anywhere should be ceased and diverted to either (initially) creating an llvm backend, or improving llvm
10:48:12 <dogbite> dogbite: oh i put in tail recursion to fight stack overflow
10:48:12 <Cale> dogbite: The problem is that you're building up large expressions in the parameters to collatz
10:48:17 <Shiruka> ahhh, looks like it was yet another one of dons' papers
10:48:18 <kryptiskt> vixey, think you missed his paste
10:48:33 <Cale> dogbite: it's important to remember that in Haskell, expressions are evaluated outermost-first
10:48:33 <Philippa> baaba: given that GHC is a pretty weird client, it's understandable to have a case of NIH
10:48:36 <dogbite> cale: yeah i'm building up a long list of cached values 'm'
10:48:39 <vixey> kryptiskt: I don't see any haskell expression you can evaluate in the paste which causes a stack overflow
10:48:44 <Shiruka> RayNbow: I think that one's it: http://www.cse.unsw.edu.au/~dons/papers/SCKCB07.html
10:48:46 <lambdabot> Title: Generative Code Specialisation for High-Performance Monte-Carlo Simulations
10:49:01 <baaba> Philippa, i guess?
10:49:04 <Cale> dogbite: actually I think it might be the s
10:49:05 <baaba> still though
10:49:21 <Philippa> baaba: doubly so having got bitten once with GCC
10:49:28 <Cale> dogbite: collatz runs and in its base case gives s + 1
10:49:40 <jganetsk> FORMAL SEMANTICS ROCKS!!!
10:49:44 <baaba> bitten?
10:49:47 <dogbite> Cale: before i wasn't doing 's' that way..
10:49:48 <RayNbow> Shiruka: thanks :)
10:49:48 <vixey> dogbite: which problem on project euler is this?
10:49:53 <baaba> fsf politics?
10:49:59 <vixey> jganetsk: What are you reading?
10:50:00 <dogbite> problem 14
10:50:03 <Cale> dogbite: but by that time, s looks like ((....((0 + 1) + 1) ... ) + 1) + 1
10:50:20 <Cale> dogbite: and evaluating that expression kills the stack
10:50:22 <dogbite> Cale: oh.. before i didn't have 's'
10:50:29 <jganetsk> vixey: i just heard that y'all were having a discussion about the awesomeness of formal semantics, so i figured i'd throw in my 2 cents
10:50:32 <Cale> dogbite: well, it could happen in a number of ways
10:50:35 <dogbite> Cale: instead my base case was '1'
10:50:41 <RayNbow> ah Shiruka, it was already submitted to reddit 8 months ago: http://www.reddit.com/comments/60ess/generative_code_specialisation_for
10:50:42 <lambdabot> Title: Generative Code Specialisation for High-Performance Monte Carlo Simulations : re ..., http://tinyurl.com/5fr29g
10:50:48 <dogbite> Cale: and i was adding 1 + at each recursive step
10:50:57 <Philippa> baaba: GHC did things with GNU C that pushed GCC in ways nothing else did. Having your compiler's development halted until someone else fixes the problem stinks
10:50:57 <Cale> dogbite: an easy fix is just to stick a seq s in before the recursive call
10:50:59 <dogbite> Cale: how can i build that accumulator?
10:51:06 <Cale> at least, that'll solve that problem
10:51:09 <Elly> I would just like to add that I would literally kill someone to have this compiler be in Haskell or SML instead of C
10:51:13 <baaba> Philippa, ah true
10:51:14 <RayNbow> Shiruka, the reddit entry contains a link to a more recent version of the paper
10:51:21 <baaba> Philippa, i'd argue gcc is a lost cause though
10:51:24 <baaba> it's a jungle
10:51:31 <Cale> dogbite: However, there might be a better way to write this program...
10:51:32 <baaba> llvm is a lot easier and faster to improve
10:51:37 <Elly> baaba: it's a really fast jungle, and probably the best free jungle out there :P
10:51:46 <Philippa> baaba: nevertheless, a non-strict language is an odd client. Where politics happens, we wouldn't get high priority
10:51:47 <baaba> llvm is a better static compiler than gcc
10:51:49 <dogbite> Cale: oh i don't doubt it.  it started to get messy when i wanted to chache values
10:51:50 <baaba> produces better faster code
10:51:57 <baaba> and llvm is an infant compared to gcc
10:51:58 <dogbite> Cale: what do you mean by adding in Seq?
10:51:59 <Philippa> my arse is a better static compiler than GCC :-)
10:52:19 <Philippa> (less portable, though)
10:52:19 <baaba> and llvm is not a jungle
10:52:29 <baaba> true, it doesn't have as many supported target platforms as gcc
10:52:33 <Cale> dogbite: the expression (seq x y), when evaluated, will cause x to be evaluated (up to determining the top-level constructor), before resulting in y
10:52:37 <Philippa> jganetsk: you showed up a bit late for the trolling run, I'm afraid :-)
10:52:37 <baaba> but that's only a matter of time
10:52:43 <baaba> llvm is set to rocket right past gcc
10:52:49 <Cale> dogbite: It's a way of making things a bit stricter.
10:53:14 <kryptiskt> the worst thing is that gcc is a jungle on purpose to keep out non-free plugins
10:53:15 <dogbite> so would (seq (s+1) (s+1))
10:53:22 <Cale> that wouldn't help
10:53:25 <thoughtpolice> i'm waiting for clang
10:53:47 <Cale> seq x x is always the same as x
10:53:48 <baaba> clang is already viable for C
10:53:58 <baaba> if you're waiting for C++ then you'll be waiting for a while :P
10:54:03 <dogbite> hmmm....
10:54:04 <Cale> seq s (collatz (n `div` 2) m x (s + 1))
10:54:22 <Cale> This however, will force s to be evaluated before the recursive call is made.
10:54:33 <Cale> (remember -- outermost first evaluation)
10:54:34 * Botje solved euler14 from within ghci
10:54:42 <maltem> dogbite: "Before evaluating s+1, first evaluate s+1" - that's not strictly an optimization
10:54:46 <baaba> i guess instead of whining about that i should do something about it though..
10:54:52 <chrisdone> Botje: well done
10:54:59 <dolio> Botje: The early ones aren't computationally hard enough to stop you from doing that. :)
10:55:04 <dogbite> the seq didn't help
10:55:15 <Cale> dogbite: okay.
10:55:36 <Botje> dolio: i know, i solved the first 84 :)
10:55:49 <kryptiskt> yes, a LLVM code generator would be nice
10:56:14 <Cale> dogbite: let me try one thing :)
10:56:22 <Cale> dogbite: oh, and what numbers are you running it on?
10:56:29 <Philippa> baaba: cluestick those responsible for C++? The language is seriously intractable to tools
10:56:36 <dogbite> 1000000
10:56:39 * Elly checks out llvm
10:56:54 <dogbite> ./question14 +RTS -K83886080 that worked, heh
10:56:56 <dolio> Botje: I like the problems that are like "Do the same thing as 10 problems ago, only now you can't brute force it."
10:56:57 <baaba> Philippa, heh :)
10:57:01 <Philippa> in face, while I figured out a neat way to implement Haskell's layout rule per the report in my own langs I'm seriously thinking of going to something akin to John Meacham's variants specifically because it makes life much easier for tools
10:57:06 <baaba> it's rather hilarious with regard to tools yes
10:57:18 <Botje> dolio: yeah. that pyramid "find the longest path down" one was funny
10:57:24 <Philippa> (if you haven't read the definition, read it: you'll see what's icky)
10:57:34 <Botje> I solved it the correct way first and went "wtf is so hard about this one?"
10:57:35 <pejo> baabaa, both gcc and llvm are awfully complex from an outsiders pov. The entry barrier is incredibly high, especially if you want to do the kind of research that Norman Ramsey and his graduate students are doing.
10:57:38 <baaba> definition?
10:57:41 <Shiruka> phew, this channel suddenly turned high volume
10:57:51 <Philippa> baaba: of the layout rule
10:57:52 <chrisdone> @users
10:57:53 <lambdabot> Maximum users seen in #haskell: 489, currently: 458 (93.7%), active: 24 (5.2%)
10:57:53 <MyCatVerbs> baaba: "< baaba> if you're waiting for C++ then you'll be waiting for a while :P" <-- if you're waiting for C++ then you're already waiting for death, IMO.
10:57:53 <baaba> pejo, i would say for llvm that's not quite true
10:57:55 <Botje> DAMN KIDS AND THEIR SHOUTING
10:58:02 <MyCatVerbs> baaba: because you'd probably be happier that way. ;P
10:58:02 <chrisdone> haha
10:58:09 <Shiruka> look for one paper on the net for a minute and it takes a long time to catch up :-P
10:58:27 <Botje> race against the clock :)
10:58:39 <kryptiskt> pejo, best thing with LLVM is that it's easily extensible
10:58:53 <baaba> pejo, llvm has a pretty clean and easily accessible design actually
10:58:54 <ddarius> A few more months and we'll have 500+
10:58:55 <MyCatVerbs> Philippa: question: from whom did you pick up the phrase "nasal demons", and where are they located? I feel the need to send whomever this person is a cookie.
10:59:03 <baaba> that's one of its greatest strengths versus gcc
10:59:04 <kryptiskt> if you don't mind C++ of course
10:59:09 <erikc> philippa: making tools that can deal with c++ is on the order of making tools that deal with template haskell
10:59:10 <vincenz> MyCatVerbs: usually in the nose
10:59:40 <Cale> dogbite: Okay, I'm not exactly sure what's going on. I could figure it out if you like, but it's probably better just to show you how to do memoisation the sane way :)
10:59:42 <MyCatVerbs> vincenz: y'know, the pun I was expecting was a joke about "picking up" the phrase, but nevermind.
11:00:14 <chrisdone> Botje: god, I spend like a week last year solving euler problems and missed loads of coursework :\
11:00:17 <pejo> baaba/kryptiskt, well - it would surely be interesting to see what kind of results you'd get from having llvm as an alternative backend for ghc, so by all means, hack away. :-)
11:00:21 <vincenz> MyCatVerbs: bit sick today, my humor is hence low
11:00:26 <MyCatVerbs> Cale: also, intPtrToPtr is disgusting. wordPtrToPtr, dammit! Pointers aren't signed values!
11:00:34 <Botje> chrisdone: I did mine in between exams
11:00:40 <Philippa> erikc: no, it's not. Template Haskell is easier.
11:00:42 <dogbite> Cale: yes please... ready to learn
11:00:43 <chrisdone> MyCatVerbs: "bogeys"?
11:00:49 <MyCatVerbs> Cale: but thanks for pointing it out anyway, I was having difficulty finding it. :)
11:00:49 <Botje> the first .. 30 can be done in a day if you're motivated
11:00:53 <ddarius> MyCatVerbs: Pointers clearly form torsors.
11:01:20 <Philippa> MyCatVerbs: http://www.catb.org/jargon/html/N/nasal-demons.html
11:01:21 <lambdabot> Title: nasal demons
11:01:28 <Philippa> (though that wasn't where I first encountered it)
11:01:46 <Cale> dogbite: Lists don't make the best datastructures to hold memo tables, because it takes O(n) time to search through them. However, let's stick with that for the moment.
11:01:49 <hackage> Uploaded to hackage: bytestring-show 0.1.1
11:01:54 <MyCatVerbs> Philippa: oh wow, haha. I must've read that damn thing like three times through, and I still missed that phrase. What a pity. :)
11:02:08 <dogbite> Cale: yeah it was a bit of a hack because I don't know anything else in haskell
11:02:19 <MyCatVerbs> ddarius: yyy... but machine pointers have semantics related to timing, as well as just their denotional semantics.
11:02:30 <Philippa> erikc: You can do a fair amount with Template Haskell without having to evaluate and splice. With C++ is another matter
11:02:41 <ddarius> MyCatVerbs: I was agreeing with you.
11:02:51 <erikc> ah ok
11:03:03 <erikc> full expansion of template haskell would be rough :)
11:03:19 <MyCatVerbs> ddarius: oh, sorry. I didn't know what torsors were, I assumed some generalisation of a group.
11:03:32 <Philippa> erikc: well, that's time to call a compiler, no? Merely parsing C++ is a nightmare though
11:03:33 <ddarius> MyCatVerbs: They are kind of like G-sets.
11:03:50 <MyCatVerbs> ddarius: so my thought process went, "Well of course pointers form a group under addition, but those aren't the only interesting properties of them, dag-nabbit."
11:04:02 <MyCatVerbs> ddarius: sorry, I just failed to understand you and thought you were brushing me off. :)
11:04:24 <Cale> http://hpaste.org/9161 -- before we go on, just check that this program means the same thing as yours
11:04:34 <dogbite> k
11:04:41 <ddarius> Pointers aren't signed, but they can be subtracted, however, their difference is an offset not another pointer.
11:05:04 <ddarius> Offsets acting on pointers form a torsor.
11:05:08 <chrisdone> ptr_diff_t or somesuch
11:05:19 <dolio> Clearly we need a torsor type class.
11:05:24 <Cale> (In case I badly misinterpred that :)
11:05:28 <Shiruka> pointers form a group under addition..
11:05:32 <MyCatVerbs> ddarius: yyyy... heh. Yes, torsors are the perfect mathematical structure. You can't (usually) meaningfully inspect a pointer, but you can sure as Hell inspect the differences between pointers. :)
11:05:35 <Cale> misinterpreted*
11:05:38 <Shiruka> pointer + pointer = useless usually..
11:05:55 <dogbite> Cale: yup
11:06:07 <Cale> okay
11:06:40 <Shiruka> can't meaningfully inspect a pointer? what about all those runtime systems, gcs etc. which tag pointers? :-)
11:06:40 <MyCatVerbs> Shiruka: unless one's an offset. But in that case, it's better to give offsets a different type to pointers, so a group isn't the right structure at all.
11:07:06 <Shiruka> but it's a strange coincidence if the offset is itself a pointer
11:07:17 <Shiruka> a useful pointer that is
11:07:23 <chrisdone> Botje: damnit, I was supposed to be working, not reading euler problems! what would you do thatâ½
11:07:30 <MyCatVerbs> Shiruka: In this case, I define "(usually)" to mean "without being gratituitously low-level". ;P
11:07:40 <Twey> Cale: So, I installed the binary x86-linux-unknown GHC, and it worked fine, but when I try to use it it says /usr/local/lib/ghc-6.8.2/ghc-6.8.2: error while loading shared libraries: libreadline.so.4: cannot open shared object file: No such file or directory
11:07:47 <Cale> dogbite: Or are you after the whole list?
11:08:06 <Cale> Twey: mm... so you got the readline 4 version :)
11:08:12 <Twey> Cale: :-\
11:08:16 <dogbite> Cale: yeah i need to find the maximum collatz
11:08:16 <Twey> What should I have got?
11:08:22 <Cale> Twey: (and your system apparently doesn't have readline 4)
11:08:24 <Shiruka> MyCatVerbs: but it's not gratuitous :-)
11:08:25 <Twey> Also, there doesn't seem to be an uninstall target
11:08:25 <dogbite> Cale: over all 'n' from [1..1000000]
11:08:27 <MyCatVerbs> Shiruka: since pointers' exact values never have any implementation-independent meaning.
11:08:29 <Twey> :-\
11:08:35 <Shiruka> even ghc does pointer tagging these days, doesn't it
11:08:41 <dogbite> so i wanted to memoize the colatz when it sees a repeat
11:08:52 <Cale> oh...
11:08:58 <Cale> that's interesting...
11:09:17 <Cale> There used to be a separate version for readline 5 users, but that's not there now.
11:09:21 <MyCatVerbs> Shiruka: yes, but it *is* low-level. The highest level at which you can possibly say something meaningful about a pointer's value is to test if for NULL-ness and to compare it to the set of pages that you've gotten the OS to map in for you.
11:09:31 <Shiruka> MyCatVerbs: in theory, but in practice they are memory addresses, possibly with tags..
11:09:35 <Cale> However, you can just install an old readline and you'll be fine.
11:09:46 <MyCatVerbs> Shiruka: that *is* graituitously low-level iff you attempt to do it from Haskell code. :)
11:09:52 <Cale> (it's okay to have both)
11:09:53 <Shiruka> :-)
11:09:56 <MyCatVerbs> Shiruka: as an implementation strategy, it's just dandy, of course. ^^
11:09:58 <Cale> dogbite: right
11:10:38 <MyCatVerbs> Shiruka: remember, anything that doesn't impinge on anything not denoted "implementation-defined" or "undefined" by the spec is fair game, doubly so if it leads to an interesting optimization. :)
11:11:02 <Shiruka> in theory, again not in practice
11:11:04 <Cale> dogbite: okay. So we actually want to compute map collatz [1..1000000], but in such a way that previous results are reused
11:11:05 <Twey> Cale: :-\
11:11:08 <Twey> But, but...
11:11:13 <dogbite> Cale: exactly
11:11:14 <Shiruka> implementers are constrained by what users actually do
11:11:17 <Twey> Then I'd have to remove my new readline
11:11:22 <Twey> And break half my system
11:11:28 <Cale> Twey: they should coexist just fine
11:11:44 <Twey> Will Portage like them?  *looks wary*
11:11:52 <Cale> I don't know about gentoo or BSD.
11:11:57 <Shiruka> I doubt a ghc version that broke the global variable hack would be widly popular, for instance..
11:12:02 <MyCatVerbs> Shiruka: hah. Well, okay. As long as it doesn't impinge on anything not denoted "undefined", and doesn't impinge on anything denoted "implementation-defined" more often than your community of developers are willing to put up with. ;)
11:12:04 <dogbite> Cale: haskell won't automagically cache, right?
11:12:07 <Shiruka> *wildly, even
11:12:13 <Cale> dogbite: If you define a constant it will.
11:12:19 <Shiruka> MyCatVerbs: yeah :-)
11:12:19 <idnar> global variable hack?
11:12:29 <Shiruka> the one with unsafePerformIO
11:12:33 <MyCatVerbs> idnar: using unsafePerformIO to create a global variable.
11:12:53 <Cale> dogbite: So instead of being recursive, collatz can do a lookup in a constant table, which itself is defined using collatz
11:13:02 <dogbite> Cale: hit me with the less on of how to memoize in haskell
11:13:05 <Philippa> MyCatVerbs: it's fair for users to expect implementation-defined functionality to remain reasonably consistent across versions of the same compiler up to a certain point
11:13:10 <dogbite> Cale: how do i define said constant?
11:13:31 <Cale> collatz' = map collatz [1..]
11:13:44 <Cale> or collatzes, if you want :)
11:13:55 <MyCatVerbs> idnar: it goes like so: {-# NOINLINE foo #-} foo :: IORef Integer \n foo = unsafePerformIO (newIORef 0) \n, and then, ideally, before you use foo for the first time, foo `seq` return ().
11:14:04 <dogbite> Cale: oh, okay... let me try that!
11:14:10 <Shiruka> MyCatVerbs: with time, languages tend to ossify though
11:14:22 <MyCatVerbs> Shiruka: jah. Pity, in some ways.
11:14:29 <Shiruka> for instance when gcc devs go and break something implementation-defined, then there's lots of wailing and gnashing of teeth
11:14:32 <idnar> MyCatVerbs: hmm, ok
11:14:47 <Shiruka> and perhaps rightly so
11:14:53 <Philippa> Shiruka: that's perhaps more understandable than usual, mind - there is such a thing as GNU C
11:14:56 <Cale> dogbite: actually, maybe it should be [0..] (though we haven't defined collatz for 0)
11:15:07 <Cale> dogbite: it'll make indexing just that much easier :)
11:15:10 <MyCatVerbs> Philippa: bugger'm. Force the lazy dirtbags to #ifdef _everything_ and never, ever trust your implementation. :D
11:15:10 <painy> how doeos haskell do factorial so quickly
11:15:40 <Cale> painy: factorial of what?
11:15:57 <Cale> painy: You have a computer in front of you which does billions of operations a second.
11:15:58 <painy> i did factorial 32948239 something like that
11:16:03 <MyCatVerbs> painy: by using a fast algorithm for it, same as any other language on the planet. You can write a fast factorial function in Perl, if you like.
11:16:08 <painy> and it printed it in a split second
11:16:12 <Botje> painy: haskell cheats.
11:16:18 <Botje> it contacts a server and downloads the answer
11:16:28 <Cale> haha!
11:16:28 <MyCatVerbs> Oh yeah, that.
11:16:29 <Botje> but you don't know this from me *shifty eyes*
11:16:34 <painy> why cant i script one like this
11:16:34 <MyCatVerbs> The trick is that the server is on Mars.
11:16:38 <painy> in mirc
11:16:40 <Shiruka> MyCatVerbs: yeah, like #ifdef SOME_COMPILER\n /* dear god how this compiler sucks, the devs are total morons, let's kludge around their wackiness */\n ...\n #endif ;-)
11:16:41 <sbok> I thought it precomputed the answer for every 32bit integer?
11:16:51 <MyCatVerbs> painy: mIRC's scripting system isn't designed to be fast.
11:16:59 <Botje> sbok: that would explain the size of ghc-extralibs ;)
11:17:02 <painy> ah i see
11:17:03 <idnar> hahaha
11:17:08 <MyCatVerbs> painy: you can still write that's plenty fast enough though, by using a fast algorithm.
11:17:11 <idnar> @src factorial
11:17:11 <lambdabot> Source not found.
11:17:12 <painy> okay thanks, i was just blown away by that when i was going through one of the tutorials
11:17:40 <painy> jeez the sheer power of the computer! amazing
11:17:44 * ddarius doubts mIRC script has arbitrary precision integers.
11:18:02 <sbok> Just write your own bignum library in mIRC script :-P
11:18:12 <MyCatVerbs> painy: yeah. 2GHz is a really really big number. :)
11:18:16 <Shiruka> ghc's factorial is fast because it really does cheat
11:18:23 <Shiruka> by using GMP :-)
11:18:34 <centrinia> GMP doesn't use the gamma function trick. :)
11:18:37 <sbok> GMP is aw/win 1e
11:18:37 <vixey> How GMP is cheating ?
11:18:41 <Shiruka> (eh, ghc's arbitrary precision ints I meant)
11:18:49 <centrinia> vixey, it doesn't.
11:18:52 <Shiruka> vixey: it's cheating because it's not slow!
11:18:54 <centrinia> It just uses neat tricks.
11:18:55 <chrisdone> how do I cheat GMP?
11:19:57 <Shiruka> anyway, "cheating" in the same vein as "farming the computations to a supercomputer on Mars"
11:20:06 <Shiruka> gmp is supercomputerey enough
11:20:13 <Shiruka> and faster in this case since the latency to mars is awful :-)
11:20:24 <ddarius> There is no built-in factorial function.
11:20:34 <painy> if you characterize the human brains operation speed, how many ghz is it??
11:20:45 <dolio> 7.3
11:20:47 <Shiruka> ddarius, that's why < Shiruka> (eh, ghc's arbitrary precision ints I meant)
11:20:52 <Cale> painy: it's hard to measure, since it's not on a clock
11:20:57 <cjb> painy: meaningless comparison.
11:21:03 <cjb> Cale: that's debatable!
11:21:14 <Cale> cjb: true, it is a bit debatable :)
11:21:19 <painy> ah i see, then why do they say the Blue Gene project to build a computer with the same Ghz as the brain?
11:21:23 <painy> or is this just bad journalism?
11:21:32 <chrisdone> there is good journalism?
11:21:32 <rwbarton> bad journalism/marketing
11:21:34 <Cale> At least it doesn't seem to be on a fast clock, like the ones our computers use.
11:21:37 <centrinia> painy, you don't really measure asynchronous processors with a clock speed. :p
11:21:42 <PO8> So I've got this weird case where it looks like GHC isn't being sufficiently lazy.  Can someone help me look at it?
11:21:45 <cjb> Cale: several theories of memory recall involve spiking neurons that introduce feedback loops.  Is that the same as a clock?
11:21:49 <dogbite> http://hpaste.org/9161#a1
11:22:03 <Cale> cjb: global ones?
11:22:05 <dogbite> Cale: am i doing the constant right?
11:22:21 * Shiruka is waiting for the time when we have enough CPUs on our laptops as there are neurons in the avg human brain
11:22:26 <painy> haaha chrisdone :D
11:22:53 <painy> ahhh, so that is a more accurate comparison Shiruka?
11:23:10 <Shiruka> nah, it would just be awesome
11:23:12 <Cale> dogbite: not quite, because collatz doesn't use collatz'
11:23:31 <cjb> Cale: well, it becomes as global as the neurons that respond to that stimulus pattern are dispersed.
11:23:32 <MyCatVerbs> painy: off the top of my head, I think neurons operate at something like 10kHz.
11:23:35 * cjb fuzzy understanding.
11:23:51 <kryptiskt> MyCatVerbs, more like 20 Hz
11:24:06 <painy> i have a difficult time understanding how simply circuits of neurons makes our mind... do you think if i do a course on electronic circuits i'll better understand?
11:24:07 <dogbite> Cale: oh... so i should define collatz' at a top level, not within the let?
11:24:12 <Cale> dogbite: right
11:24:24 <Cale> dogbite: this list does eat quite a lot of memory though
11:24:25 <centrinia> painy: No. Do a course in neurology. :)
11:24:29 <painy> and what is at the end of the neurons...
11:24:44 <painy> i saw a picture of a nerve, and it's like a node, a line, and a node
11:24:45 <MyCatVerbs> kryptiskt: varies, doesn't it?
11:24:50 <painy> what's in that little node..
11:24:56 <painy> that makes it a memory :O
11:25:10 <Cale> painy: that's not how memories are stored
11:25:11 <centrinia> Axons branch off to connect to dendrites. :p
11:25:12 <Shiruka> painy: at the end of the neurons are tiny interdimensional connections to the soul, so that dualism retains its dignity
11:25:13 <painy> oh right my bad centrinia
11:25:17 <dogbite> Cale: let me see... trying
11:25:22 <MyCatVerbs> painy: no. Digital electronics won't teach you much about how neurons form a mind. That hasn't been worked out by *anyone* yet, AFAIK.
11:25:38 <Cale> painy: memories are stored by the neurons forming interconnections
11:25:48 <MyCatVerbs> painy: if you want to know how neurons work on the inside, study neuroscience. Lots of interesting biochemistry there.
11:25:51 <ptolomy2> Anyone have an anecdotal evidence of how well cabal-install interacts with macports?
11:26:04 <painy> Hooww - such mind boggling stuff
11:26:07 <dcoutts> ptolomy2: it does not interact at all
11:26:11 <centrinia> I thought that quantum computations occurring in the microtubules are the physical manifestations of the soul.
11:26:28 <painy> yeah i'd kinda like to study neurology
11:26:41 <painy> but i can't realisticly ever see me getting into it
11:26:54 <painy> i regret everything i did when i was in school, i wasted everything
11:26:59 <painy> and now i'm much more interested
11:27:04 <dcoutts> ptolomy2: it uses programs on the path and packages registered with ghc, so if your macports installed programs to the path or installs ghc libs then cabal-install will work with them. There's no direct interaction.
11:27:08 <ptolomy2> dcoutts: So if I were to install a package with cabal-install, then later acidentally install something that requires it on macports, I'll get crazy double installs and possible universe implosion?
11:27:16 <ptolomy2> Oh.
11:27:22 <ptolomy2> That's better than what I thought.
11:27:33 * ptolomy2 generally opposes universe implosion.
11:27:49 <dcoutts> ptolomy2: you'd find that macports installed it's own version yes.
11:28:00 <Shiruka> PO8: maybe you should just put some code on hpaste.org and put a link here :-)
11:28:07 <dcoutts> ptolomy2: since it only looks at what it knows about, not what is registered with ghc
11:28:13 <painy> so you have studied neurology, centrinia?
11:28:25 <centrinia> Not in any detail.
11:28:35 <dcoutts> ptolomy2: I recommend doing per-user installs with cabal-install for this reason. (it's also the default)
11:29:07 <PO8> Shiruka: Didn't know the procedure.  Thanks much!
11:29:52 <Cale> dogbite: however, the list eats lots and lots of memory
11:30:01 <painy> someone in the java chat on dalnet told me he suggest i learn haskell as a first language, do you agree this is the smart thing to do
11:30:15 <ptolomy2> painy: Depends on what you want to use programming to do.
11:30:29 <Cale> painy: I think it's a good idea.
11:30:31 <painy> or wait.. is it going to be hard to get an unbiased answer in this chat? :P
11:30:39 <centrinia> painy: I think it is a horrible idea.
11:30:49 <centrinia> You should learn the lambda calculus first.
11:30:51 <ptolomy2> I think it is a mediocre idea.
11:31:23 <pejo> painy, it's always good to know different types of languages, regardless of what you end up programming in in the end.
11:31:39 <Cale> painy: Well, if you're looking to become a commercial programmer, learning Haskell is potentially profitable, but you should be aware that there are not nearly as many commercial users as some other languages.
11:31:53 <centrinia> The fallacy in knowing different types of languages lies in one example: Visual Basic. :(
11:31:57 <PO8> Might someone take a look at http://hpaste.org/9162#a0 ?  I think it shouldn't eat memory, but it sure does...
11:32:06 <Cale> painy: However, it's by far my favourite programming language to use, and it's fun to program in.
11:32:23 <Shiruka> centrinia: lol
11:32:37 <painy> i see, yeah i'm not wanting to learn for a career or anything
11:32:54 <centrinia> painy, write yourself a Haskell in 48 days. :)
11:33:06 <Cale> dogbite: I think you'll discover the same as me that in order to do this, we should limit the size of the memo table to a fraction of the space we're exploring
11:33:09 <centrinia> It should be pretty educational.
11:33:35 <r3m0t> is there a Data.Graph.Inductive tutorial
11:33:45 <ddarius> r3m0t: There are papers on it.
11:33:48 <Shiruka> I still think that python is better as a first language, as it has more batteries included than haskell and more third-party libraries, so you can get results faster
11:34:17 <dons> first languages aren't about libraries though.
11:34:18 <vixey> not really
11:34:20 <Twey> Cale: Help :-(
11:34:23 <ddarius> painy: Learn Haskell, Scheme, Smalltalk, C, assembly, Prolog, Icon, and J
11:34:23 <rwbarton> PO8: you're building an accumulation of thunks in "i + 1"
11:34:30 <Twey> GCC no longer works
11:34:33 <PO8> rwbarton:  Doh.  Thanks much
11:34:36 <Shiruka> dons: it keeps the interest and gives a lot of bang for the buck
11:34:38 <vixey> why Icon?
11:35:00 <centrinia> painy: Learn Brainfuck as well.
11:35:05 <Cale> Twey: what?
11:35:07 <painy> lol
11:35:08 <dons> Shiruka: right, but a good gui library and some web stuff is what we're talking about. nothing beyond the 580 libraries on hackage.haskell.org...
11:35:25 <Philippa> Shiruka: I think it's a case of "it depends"
11:35:29 <dons> dcoutts does an intro course with gtk, cairo and haskell
11:35:32 <thoughtpolice> Shiruka: indeed, i've seen many people get discouraged fast. being able to build stuff *really* quickly builds motivation and gives you ideas
11:35:32 <dons> unsw's uses opengl.
11:35:34 <Philippa> dons: Python's still easier to just get going with
11:35:42 <dons> for beginner programmerS?
11:35:44 <Shiruka> ... hmmright, maybe the beginner doesn't really need _all_ of those python libs..
11:35:49 <Twey> Cale: Oh, forget that
11:35:53 <Philippa> yeah. Amongst other things, it ships with more of the libs
11:35:54 <Twey> Cale: *pant* *gasp*
11:35:57 <painy> i think i am just going to continue reading this c++ book
11:36:04 <dons> the install bundle thing is an interesting question.
11:36:13 <Twey> Cale: I did something stupid and thought I'd killed gcc and bricked my system.  *laughs*
11:36:14 <painy> what's lambada calculus, as opposed to normal calc?
11:36:15 <Cale> Twey: all you need to do is get a libreadline.so.4 from somewhere and copy it into /usr/lib
11:36:16 <centrinia> painy: Write yourself a C++ in 21 days. :)
11:36:25 <Cale> (or /usr/local/lib
11:36:26 <Cale> )
11:36:27 <araujo> painy, new to Haskell?
11:36:27 <painy> hahahaha rightio
11:36:29 <Philippa> painy: "normal calc" is just /a/ calculus
11:36:33 <Philippa> the lambda calculus is another one
11:36:34 <MyCatVerbs> painy: lambada is a dance. :)
11:36:35 <dons> ?google haskell platform
11:36:36 <lambdabot> http://www.haskell.org/haskellwiki/Haskell_Platform
11:36:36 <lambdabot> Title: Haskell Platform - HaskellWiki
11:36:38 <centrinia> painy, Lambda calculus has those lamdbda characters.
11:37:00 <centrinia> Analytical calculus has those long 'S' characters.
11:37:03 <MyCatVerbs> painy: lambda calculus revolves around manipulating functions.
11:37:08 <painy> and it is really spelt with mdbd? :o what a difficult name
11:37:10 <dolio> Philippa: You're not one of those people who calls it "the calculus"? :)
11:37:26 <mar77a> (e^x)' = e^x !???
11:37:27 <mar77a> Â¿Â¿Â¿Â¿
11:37:33 <vixey> :tt In
11:37:35 <vixey> :t In
11:37:38 <lambdabot> forall (f :: * -> *). f (Mu f) -> Mu f
11:38:28 <Philippa> dolio: no, because it's only a calculus :-)
11:38:33 <painy> well i am just learning standard calc at the moment, i havn't even got past "derivative" chapter yet
11:38:50 <Philippa> painy: the lambda calculus is pretty much totally unrelated. And much simpler
11:39:08 <centrinia> It is simpler for people who have not been corrupted by our education system. :(
11:39:17 <Philippa> painy: can you use lambdas in haskell, and apply functions? If so, ditch the type system and anything but variables, applications and lambdas and you have the lambda calculus
11:39:50 <Shiruka> painy: there are many answers to picking the "right choice", but in any case it's best to stick to the high-level languages at first, whichever you end up with
11:39:53 <painy> i see, interesting
11:40:35 <painy> okay thanks everyone!
11:40:42 <painy> i feel encouraged for some reason
11:40:44 <dublpaws> painy, python, c++, lisp, haskell : easy, straight jacket, power, correct.  :D
11:40:45 <Philippa> painy: the lambda calculus is turing complete btw. Variants of it form the foundation of a lot of functional languages
11:40:51 <Shiruka> high-level languages would be such as haskell, python, ruby
11:41:00 <Cale> painy: If you decide to learn Haskell, make sure to hang around here and ask questions whenever you get stuck :)
11:41:01 <dublpaws> in that order
11:41:05 <Philippa> dublpaws: C++'ll make you need a straight jacket, more like ;-)
11:41:43 <Philippa> also, Haskell's the easiest of the four to do your budget in
11:41:49 <Cale> dogbite: So, if we limit the size of the memo list to 500000, I think it works, but very very slowly.
11:41:50 <painy> i'm up to chapter 4 in "thinking in c++", i think i'll finish this book, make the two things i had in mind, then move onto haskell
11:42:09 <Cale> dogbite: However, replacing that list with an array or Data.Map is easy and speeds things up a lot
11:42:13 <painy> though the syntax is probably different, i get the drift that the basic "logic" of all programming is very siilar
11:42:18 <Philippa> not least because by the time you've syntax highlighted it and said "* is multiplication" pretty much anyone can read it if you do it that way :-)
11:42:32 <Philippa> painy: yes and no
11:42:44 <vixey> painy: most programming languages are quite similar, but it's not true in general since there are ones based on different foundations
11:42:59 <Philippa> there are some fundamental differences between pure functional languages and imperative languages, for example
11:43:01 <painy> hmmm i see
11:43:05 <Philippa> and logic languages again
11:43:11 <vixey> well not 'most are similar' .. but most fit into large groups
11:43:19 <Philippa> but from a step further back they start to look similar again too
11:43:28 <Apocalisp> C++ is based on the Diabolical Calculus
11:43:32 <Philippa> you find ways to encode each in the others
11:43:45 <Shiruka> painy: try to pick a language where you can type in commands interactively instead of having to compile
11:43:55 <vixey> haskell is one
11:43:58 <vixey> you can use ghci
11:44:07 <taruti> ghci + emacs is very nice.
11:44:22 <painy> so there are no programs which will do that for c++, Shiruka?
11:44:32 <painy> agh, yeah, probably not hey
11:44:34 <Philippa> ghci + kate is a lot better than you might think, even. Hacking on my eee's surprisingly comfortable even with xandros
11:44:36 <Shiruka> yes :-) there are many languages satisfying that criterion, but those that don't tend to be beginner-unfriendly in one way or another
11:44:41 <MyCatVerbs> painy: beware of "Thinking in C++".
11:44:54 <MyCatVerbs> painy: I found it to be a very, very good C++ textbook.
11:44:55 <Philippa> beware "thinking in C++" too :-)
11:45:02 <painy> yeah i liked the haskell thingo - tha'ts where i did the factorial thing
11:45:13 <ddarius> There is a "programing" skill transcending any particular programming language or paradigm.
11:45:26 <Shiruka> painy: even if there are for C++, pretty much nobody uses them.. pick a language that comes with one :-)
11:45:26 <MyCatVerbs> painy: dangerously so, even. Specifically, it's a good enough textbook to have made me temporarily acutally like the damn language.
11:45:39 <Philippa> ddarius: I'm not sure I'd call it programming. It's actually more general than that
11:45:50 <MyCatVerbs> ddarius: I think most of us refer to it as "taste".
11:45:52 <Apocalisp> Philippa: inductive reasoning
11:45:53 <Philippa> I mean, I'm pretty sure I'd be surprisingly effective let loose on business processes
11:45:58 <Shiruka> (at least I think I saw a C interpreter somewhere, maybe someone bonkers enough has implemented one for C++, you never know..)
11:46:03 <MyCatVerbs> Apocalisp: good name.
11:46:17 <painy> asking which books in chatrooms is never any good, you get one person say it's great and one person say it's lousy
11:46:22 <painy> then a debate between them lol
11:46:27 <Philippa> Apocalisp: no. Not least because if you can only handle induction and not coinduction you can't code
11:46:29 <MyCatVerbs> Shiruka: it has and hasn't been done, respectively.
11:46:32 <centrinia> > (\f -> (\x -> f (x x))  (\ x -> f (x x))) (\x->x)
11:46:34 <lambdabot>      Occurs check: cannot construct the infinite type: t = t -> t1
11:46:34 <lambdabot>     Probab...
11:46:39 <painy> but yeah i agree, i'm finding this book real coherant
11:46:40 <ddarius> Philippa: It's correlated with many things, but you can be good at them and be incompetent at programming.
11:46:44 <centrinia> My Y combinator doesn't work. :(
11:46:54 <Philippa> painy: in smarter places people explain /why/ it was great/sucked, mind
11:46:58 <ddarius> Simply, learning your first language, no matter what it is, is dramatically different from learning your second.
11:47:07 <MyCatVerbs> centrinia: you want y f = f (y f), because that comes out as f (f (f (f (f ...
11:47:14 <PO8> rwbarton: I'm still not getting it.  why doesn't the first guard force the evaluation of the previous (+ 1) thunk?  in any case, the obvious tricks for strictifying don't seems to help.  Suggestions?
11:47:28 <MyCatVerbs> centrinia: except because of sharing and laziness, that infinite chain doesn't cost you anything.
11:47:41 <Philippa> that too. I'm thinking of programming as the art of understanding and translating between (specialisations of) various systems
11:47:46 <rwbarton> PO8: hmm, that's a good point.
11:47:49 <Apocalisp> Philippa: "inductive reasoning" in the general epistemological sense, as in concept formation and abstraction.
11:48:16 <vixey> centrina: that's why type systems exist
11:48:25 <Philippa> Apocalisp: that's necessary but not sufficient, IMO
11:48:36 <centrinia> Inductive reasoning as in: 1) S_0 is true 2) if S_n is true then S_{n+1} is true 3) \{S_n\} is true for all natural numbers n.
11:48:46 <Philippa> you pretty much have to be able to do the whole n-category tango
11:48:50 <vixey> centrina: Every program you can possibly write in haskell out of just lambda and applications will terminate
11:48:53 <Apocalisp> Philippa: deduction skills also necessary
11:49:31 <vixey> centrina: if you want to loop you'll need data or let
11:49:49 <centrinia> I thought I needed a let for loops.
11:49:54 <Shiruka> painy: read that article: http://en.wikipedia.org/wiki/REPL
11:49:55 <lambdabot> Title: Read-eval-print loop - Wikipedia, the free encyclopedia
11:50:12 <dolio> You can wrap terms in your Y combinator in data such that it will type.
11:52:14 <PO8> Well, I give up for now.  I'll check back in a while, after I've had lunch.
11:52:26 <Cale> dogbite: http://hpaste.org/9163#a1 works, when compiled with -O
11:53:18 <Cale> > (\f -> (\x -> f (out x x))  (In (\ x -> f (out x x)))) (\x->x)
11:53:19 <lambdabot>      Occurs check: cannot construct the infinite type: f = (->) (Mu f)
11:53:19 <lambdabot>     Pr...
11:53:26 <Cale> > (\f -> (\x -> f (outR x x))  (InR (\ x -> f (outR x x)))) (\x->x)
11:53:31 <lambdabot>  ghc: failed with error code 24
11:53:35 <Cale> heh
11:53:37 <ddarius> Congratulations.
11:53:37 <vixey> !!!!
11:53:51 <vixey> @remember ghc failed with error code 24
11:53:51 <lambdabot> It is forever etched in my memory.
11:54:20 <centrinia> What is error code 24?
11:54:26 <centrinia> !google ghc error code 24
11:54:38 <Cale> Probably something to do with the inliner going haywire :)
11:54:56 <Cale> I don't really know.
11:55:08 <dolio> You have that type defined in lambdabot? :)
11:55:12 <Cale> dolio: yeah
11:55:17 <Shiruka> 42 in little-endian decimal
11:55:20 <Cale> newtype Rec a = InR { outR :: Rec a -> a }
11:55:27 <vixey> :k Mu (Either ())
11:55:28 <lambdabot> *
11:55:40 <vixey> oh
11:55:42 <vixey> @src Mu
11:55:42 <lambdabot> Source not found.
11:55:46 <vixey> :(
11:55:49 <Cale> I don't have it in @src
11:55:54 <Cale> Mu is the usual Mu
11:55:59 <vixey> please add it ?
11:56:06 <vixey> I don't know what it takes to add something
11:56:31 <ddarius> Edit the file @src consults.
11:57:11 <dolio> @type \f -> fix (\cata -> f . fmap cata . out)
11:57:12 <lambdabot> forall b (f :: * -> *). (Functor f) => (f b -> b) -> Mu f -> b
11:57:13 <dogbite> Cale: thanks.. i will examine yours now
11:57:14 <dogbite> http://hpaste.org/9163#a2
11:57:20 <Cale> @src Mu
11:57:20 <lambdabot> Source not found. My pet ferret can type better than you!
11:57:23 <Cale> hmm
11:57:32 <centrinia> @src outR
11:57:32 <lambdabot> Source not found. :(
11:57:33 <Cale> apparently also need to restart lambdabot
11:57:49 <dolio> @type \g -> fix (\ana -> In . fmap ana . g)
11:57:50 <lambdabot> forall a (f :: * -> *). (Functor f) => (a -> f a) -> a -> Mu f
11:58:15 <rwbarton> PO8: it's a nasty problem :)
11:58:20 <Shiruka> file \bot consults? is it written in prolog? :-O
11:58:34 <Cale> @src Mu
11:58:34 <rwbarton> PO8: it seems that [1..] is bad when you demand the spine of the list but not the values
11:58:38 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
11:58:40 <dogbite> Cale: okay, i undertand your use of Map.  that's neat
11:58:47 <vixey> great!
11:58:51 <Cale> @src Rec
11:58:56 <lambdabot> newtype Rec a = InR { outR :: Rec a -> a }
11:59:08 <ddarius> @src Nu
11:59:14 <lambdabot> Source not found. Where did you learn to type?
11:59:32 <Shiruka> rwbarton: ouch
11:59:52 <rwbarton> Yep.  just because you didn't demand the first million values doesn't mean you won't demand the next
11:59:53 <Shiruka> what is it with std functions not doing + strictly :-(
12:00:04 <Cale> Shiruka: (+) is strict.
12:00:16 <Shiruka> Cale: it is, but its users produce thunks
12:00:24 <Shiruka> such as sum and apparently [1..]
12:00:36 <Cale> right.
12:00:58 <Cale> [1..] is a particularly annoying case.
12:01:03 <Shiruka> is there some benefit to defining them that way, or is it just an oversight?
12:01:11 <rwbarton> I think this is actually a bug that can be fixed, unlike the definition of sum which might need to be non-strict for some weird Num instance
12:01:17 <Cale> Well, you might conceivably want lazy evaluation in (+)
12:01:23 <ddarius> Shiruka: sum is not specialized to strict numbers.
12:02:17 <Cale> I'll admit that this isn't *so* often.
12:02:45 <Cale> There are some nice cases, like infinite series, though.
12:02:56 <vixey> you know how say
12:03:02 <vixey> data N = Z | S N
12:03:07 <vixey> is different to
12:03:25 <vixey> data Stack = End | Next Stack
12:03:27 <MyCatVerbs> instance Num [()] where...
12:03:43 <erikc> is there a way to do 'read-once' values in haskell like uniqueness types in clean
12:03:45 <MyCatVerbs> vixey: huh? All you did was change the names.
12:03:53 <vixey> yes
12:03:59 <Cale> vixey: they're different but isomorphic
12:04:06 <vixey> when you write data ... = ..., you extend the language haskell with some new typing rules
12:04:18 <vixey> it changes the typechecker, for example
12:04:30 <Shiruka> ddarius: but if you have (sum something) and you force that thunk, then sum has to evaluate all the (+):s (which are strict) anyway to produce the result
12:04:44 <vixey> how do you know that it's not possible to write   data Evil = ....   which makes haskell not type safe anymore?
12:04:54 <MyCatVerbs> Shiruka: yeah, but foldl' (+) 0, yo.
12:04:55 <ddarius> Shiruka: (+) isn't strict in general as Cale said
12:04:58 <Shiruka> so how can there be any benefit in the case of sum of constructing the (a+(b+(c+... thunk in memory as an intermediate data structure?
12:05:02 <Cale> erikc: mm... it depends on exactly what you mean by that
12:05:18 <Cale> erikc: Haskell doesn't have any direct equivalent to uniqueness types.
12:05:19 <Shiruka> ... ahum, true
12:05:26 <MyCatVerbs> vixey: because data Foo = Bar isn't altering the typechecker, it's an extra piece of data for the type checker to chew on.
12:05:41 <erikc> i want to do substructural typing, so a set of types for the states of an object, and transition functions between the states
12:05:45 <Shiruka> MyCatVerbs: yeah, that's what I use :-)
12:05:54 <erikc> but i want to make sure you cant use the old states
12:05:55 <MyCatVerbs> vixey: and because it's been formally proven that there's nothing in H98 which will make the type checker loop.
12:06:00 <erikc> so a thunk can only be accessed onced
12:06:08 <taruti> Shiruka: e.g. data MyUnit = MyUnit; instance Num MyUnit where ... ; a + b = a ; ...
12:06:08 <Cale> erikc: But you could construct a library which enforced this sort of thing in a kind of domain-specific language.
12:06:11 <vixey> MyCatVerbs: I don't beileve you :p
12:06:13 <erikc> right
12:06:15 <vixey> MyCatVerbs: Where is the proof?
12:06:40 <MyCatVerbs> vixey: there *are* constructs involvinging multi-parameter typeclasses, fundeps, overlapping instances and some maliciousnes which do break the type-checker.
12:06:56 <Cale> erikc: you might consider just using a state monad.
12:06:58 <vixey> also, it's possible for a type checker not to loop .. but allow programs which go wrong
12:06:59 <MyCatVerbs> vixey: it'll be in a paper somewhere.
12:07:02 <centrinia> You could write a Reader monad that keeps a (Maybe a) that makes the state Nothing right after a read. :)
12:07:04 <Philippa> MyCatVerbs: you want to be careful about claims about formal proofs. I can believe one might exist, but I don't know where and it'd be recent
12:07:17 <vixey> "in a paper somewhere" -_-
12:07:18 <erikc> yea, im gonna do that
12:07:23 <MyCatVerbs> Philippa: well, there exists one for Hindley-Milner type checking, doesn't there?
12:07:28 <Cale> erikc: There's nothing to guarantee that something won't just hold on to an old state explicitly, and use it later, but it'll be obvious, at least :)
12:07:31 <MyCatVerbs> (Otherwise no bugger would ever use it.)
12:07:34 <dolio> > unfoldr Just ((),())
12:07:36 <lambdabot>  [(),
12:07:45 <vixey> MyCatVerbs: I am specifically talking about an -extension- of HM
12:07:50 <Philippa> MyCatVerbs: H98 has at least two really significant extensions
12:07:53 <vixey> MyCatVerbs: that one which lets you add new datatypes
12:08:06 <Philippa> vixey: that's not actually an extension at all
12:08:13 <Philippa> the proof re H-M is for any set of datatypes
12:08:22 <MyCatVerbs> Philippa: yep, but both of those have been dealt with in seperate papers, AFAIK.
12:08:43 <ddarius> Philippa: Type classes and polymorphic recursion or do you have another one as opposed to polymorphic recursion?
12:08:43 <Philippa> effectively you pick the exact set of types just before typechecking
12:08:49 <erikc> hrm, might be a neat extension if you could flag a thunk so that the value is not updated after evaluation, it stays blackholed
12:08:50 <Philippa> ddarius: those'd be the ones, yeah
12:08:54 <erikc> so further reference causes divergence
12:08:58 <Philippa> MyCatVerbs: sure, but that's an idea you want to be careful with
12:09:01 <vixey> oh
12:09:25 <vixey> I've only seen ones with  var/lam/app/let/fix and a/a -> a/()
12:09:30 <vixey> I think....
12:09:32 <ddarius> Haskell 98's type system is embeddable in System F.
12:09:36 <Philippa> MyCatVerbs: sometimes, features combine in an unexpected manner
12:09:46 <jganetsk> System F, or System Fw ?
12:09:58 <vixey> oh
12:10:00 <MyCatVerbs> Philippa: yes, but they're been dealt with in combination with one another and vanilla HM.
12:11:15 <Cale> erikc: maybe I'm confused, but wouldn't that mean that the first thing to evaluate it would get a blackhole as well?
12:11:25 <Philippa> ddarius: News to me (which I guess means: can I see the paper?), unless you mean a Curry-style one?
12:11:28 * vixey &
12:12:04 <Shiruka> jganetsk: oh, so someone else _does_ use "System Fw"
12:12:26 <Shiruka> the other day some people were going on there about "Fomega" and it took me a few minutes to figure out it's Fw :-)
12:12:34 <Philippa> jganetsk: a minorly extended system F, normally. You don't need full Fw
12:12:36 <Shiruka> *here, not there
12:12:39 <Philippa> and yeah, the w is really an omega
12:12:45 <Cale> FÏ
12:12:47 <erikc> cale: oh, my understanding of thunks in ghc was that the thunk gets blackholed once evaluation starts, and then after evaluation, its updated with the value, so the idea would be not to do the update, but return the evaluated value
12:12:54 <MyCatVerbs> Philippa: I'm looking for the paper on System O because I'm pretty certain it must have been referenced from there.
12:13:21 <Shiruka> yeah, it is omega, but Ï has less of the omega-nature to me than Î©, which is _the_ omega ;-)
12:13:34 <MyCatVerbs> Here we go. Oh crap, there are a lot of references.
12:13:44 <Cale> erikc: I was thinking that the updated value is what the case expression that's forcing the evaluation is going to inspect, but I suppose you could work out some way
12:13:53 <Philippa> MyCatVerbs: don't strain too hard :-) I'm certainly happy that it's very very strongly believed to be the case
12:13:55 <erikc> ah, k
12:13:59 <ddarius> Philippa: I'm sure there there's a translation for type classes somewhere.  Polymorphic recursion looks like it would translate "trivially."  HM is certainly embeddable in some well studied variant of System F or another.
12:14:03 <Cale> Or maybe it does return the value separately already
12:14:09 <MyCatVerbs> Philippa: "A Second Look At Overloading" by Odersky, Wadler and Wehr.
12:15:04 <rwbarton> > sum $ take 1000000 [0..]
12:15:05 <lambdabot>  499999500000
12:15:07 <rwbarton> > last $ take 1000000 [0..]
12:15:08 <lambdabot>  Exception: stack overflow
12:15:17 <MyCatVerbs> Philippa: that one proposes a generalisation of Haskell's typeclasses, and I think there's a proof of decidability in here.
12:15:31 <ddarius> > last $!! take 1000000 [0..]
12:15:32 <lambdabot>   Not in scope: `$!!'
12:15:37 <xerox> ?seen centrinia
12:15:37 <lambdabot> I saw centrinia leaving #haskell 1m 56s ago, and .
12:16:00 <MyCatVerbs> But, Hell, isn't System F proven to be decidable?
12:16:03 <ddarius> MyCatVerbs: Who cares about decidability?  It's soundness that would be interesting.
12:16:23 <Philippa> MyCatVerbs: it's been proven that /inference/ for System F is undecidable
12:16:25 <Cale> > let xs = take 1000000 [0..] in seq (rnf xs) (last xs)
12:16:26 <lambdabot>  999999
12:16:42 <ddarius> Of course, soundness technically needs a semantics...
12:17:05 <MyCatVerbs> Philippa: oh. Damn. :)
12:17:26 <MyCatVerbs> ddarius: soundness has been proven, hasn't it?
12:17:57 <MyCatVerbs> And don't the GHC maintainers firebomb anyone's home who suggests a non-decidable extension to the type system? :)
12:18:27 <ddarius> There are already undecidable instances as well as perfectly legal Haskell 98 programs that put GHC into a loop.
12:18:30 <PO8> rwbarton: Interesting!  So it's [1..] that's piling up thunks.  Thanks!
12:18:46 <ddarius> @wiki Stack overflow
12:18:46 <lambdabot> http://www.haskell.org/haskellwiki/Stack_overflow
12:18:51 <ddarius> PO8: Read that.
12:19:16 <MyCatVerbs> ddarius: there are H98 programs that GHC loops on?
12:19:20 <ddarius> Yes.
12:19:59 <MyCatVerbs> ddarius: example, please?
12:20:15 <MyCatVerbs> ddarius: because I was under the impression that there weren't, by construction...
12:20:19 <PO8> ddarius:  I'm not overflowing the stack.  I'm running out of heap...  I'm not getting it.
12:20:43 <ddarius> http://www.haskell.org/ghc/docs/latest/html/users_guide/bugs.html
12:20:44 <lambdabot> Title: 13.2. Known bugs or infelicities
12:22:04 <MyCatVerbs> ddarius: k, but that's a bug in the inliner, not the type checker.
12:22:15 <MyCatVerbs> ddarius: still, your point is made, and I am disconcerted. :/
12:22:30 <Trinithis> why is reverse defined with foldl instead of foldl'?
12:22:43 <ddarius> Trinithis: It doesn't really make a difference in that case.
12:22:49 <ddarius> And foldl is H98
12:22:50 <geezusfreeek> @src reverse
12:22:50 <lambdabot> reverse = foldl (flip (:)) []
12:23:11 <Shiruka> if it's in the inliner, one might work around it with noinline..
12:23:26 <Trinithis> ok
12:25:41 <vixey> ok
12:25:46 <vixey> I think I have an idea for the proof
12:26:06 <vixey> you can say that data Piece = X | O .. is isomorphic to Bool.. or 1 + 1
12:26:59 <vixey> so. it should be fine to prove that the language with types 0,1,+,*,mu is sound.. and that the haskell typechecking is strictly <= that
12:27:06 <PO8> back in a bit
12:28:06 <_qq> hi, what's the way to go to have ada/pascal like ranged int, float, complex, array index, etc. types in haskell that are checked at runtime?
12:28:28 <ddarius> vixey: It took you that long to think of that?  And anyway, your set of primitives is not enough.
12:28:42 <vixey> ddarius: I went and had my dinner ..
12:29:09 <vixey> oh I must add variables and ->
12:29:18 <vixey> and application
12:42:05 <Shiruka> argh, statistics has maimed my brain
12:42:40 <Shiruka> whenever I see "likelihood" used in colloquial text, I go off on a track of thought "likelihood? or probability?"
12:43:02 <Shiruka> where "colloquial" means anything that's not about statistics..
12:43:03 <roconnor> what's likelihood?
12:43:44 <Shiruka> http://en.wikipedia.org/wiki/Likelihood_function
12:43:45 <lambdabot> Title: Likelihood function - Wikipedia, the free encyclopedia
12:45:39 <Shiruka> basically, if an event happens, you look at its probability in different possible worlds as a likelihood of those worlds
12:46:13 <Shiruka> it's not a probability because it doesn't sum to 1, but you can normalize it (and weigh it by the prior probability of each world)
12:47:22 <Shiruka> but colloquially it's all the same, which has begun to irk me; thus is my brain maimed by terminology of statistics, alas :-)
12:50:15 <ddarius> Shiruka: Read Jaynes' book?
12:51:09 <RayNbow> <roconnor> what's likelihood? <-- I used to know this... :X
12:51:13 <Shiruka> I did read parts of it from the net some years back
12:51:44 * RayNbow wonders why he actually had to take the course about Statistics
12:52:13 <Shiruka> so that your world would not be all black and white, but of glorious shades of gray?
12:52:30 * shepheb did the math today. he needs 50% on the final to pass, and that 50 will give him a final mark of 60% even with a 0 on the last assignment. other assignments it is!
12:52:33 <roconnor> likelihood sounds like part of probability theory rather than about statistics.
12:52:57 <RayNbow> roconnor: the course was a combination of both
12:52:58 <vixey> is abs (\t -> (lam (x : t) -> x)) the usual way to represent id : /\t, t -> t ?
12:53:07 <shepheb> I can see some value in a basic grounding in stats, but the course seems a bit much and it doesn't fit in my brain
12:53:44 <vixey> (when thinking about typing rules)
12:53:58 <vixey> of course abs is implicit in haskell
12:54:51 <ddarius> vixey: Your notation doesn't (immediately) make sense.
12:55:19 <ddarius> \/\t.\x:t.x
12:55:24 <ddarius> Curses
12:55:28 <Shiruka> I thought probability theory was about proving stuff like central limit theorem and statistics was about actually doing something useful with probabilities.. but then again I'm more interested in methods and results than labels for different fields..
12:56:04 <ddarius> Jaynes' book is titled "Probability Theory: The Logic Of Science" and he doesn't care for the Central limit theorem at all.
12:56:42 <Shiruka> didn't he call it the central theorem of statistics or something?
12:57:28 <ddarius> Jaynes' doesn't think the central limit theorem is relevant.
12:59:58 <Shiruka> the most salient thing I recall from that book is the explanation of the derivation of the normal distribution
13:00:14 <Shiruka> from various qualitative properties
13:00:26 <ddarius> Shiruka: I'd suggest you reread it (and read all of it)
13:03:23 <Shiruka> might be a good idea, I don't recall why he wouldn't like the central limit theorem
13:04:40 <mcnster> hi.  is there a "read" fn to read hex digits?
13:04:43 <adekoba> I'm using Data.ByteString in parsing a file, and was wondering how I would go about making a string into [Word8]
13:05:03 <ddarius> adekoba: Why do you want that?
13:05:05 <dolio> > read "0xbcde" :: Int
13:05:10 <lambdabot>  48350
13:05:30 <mcnster> ahso!  thanks dolio :)
13:05:50 <ddarius> :t readHex
13:05:51 <lambdabot> forall a. (Num a) => String -> [(a, String)]
13:06:18 <adekoba> ddarius: to match a certain string in the file. "foo" `Data.ByteString.isPrefixOf` <bytestring> ...
13:06:35 <ddarius> :t Data.Bytestring.pack
13:06:36 <lambdabot> Couldn't find qualified module.
13:06:40 <ddarius> :t Data.ByteString.pack
13:06:41 <lambdabot> [Word8] -> BSC.ByteString
13:06:56 <ddarius> :t Data.ByteString.Char.pack
13:06:56 <lambdabot> Couldn't find qualified module.
13:07:25 <dolio> @type BSC.pack
13:07:26 <lambdabot> String -> BSC.ByteString
13:07:54 <ronwalf> Anyone have a guestimate for ghc 6.10's release date?
13:08:04 <Shiruka> there's also the utf8-string package
13:08:22 <Shiruka> Data.ByteString.UTF8 has fromString and toString
13:08:35 * ronwalf is deciding whether to hit 6.9 for the bug fix to generics compilation
13:08:56 <adekoba> that would work. Well what type would be best for parsing a binary file?
13:09:34 <dolio> If you're reading a binary file, you'll probably want Data.Binary.
13:09:44 <thoughtpolice> ronwalf: it's an indeed unfortunate (were you the one on -cafe with that issue?)
13:09:53 <thoughtpolice> ronwalf: sometime around ICFP
13:10:07 <ronwalf> thoughtpolice: Yes, that's me
13:11:00 * ronwalf bites the bullet and goes bleeding-edge
13:11:05 <thoughtpolice> ronwalf: ah, i was the one that replied. i need to update my ghc-head, but apparently some of the build system broke or somesuch. :/
13:11:18 <ronwalf> oh, hrm
13:11:19 <thoughtpolice> ronwalf: but yeah sometime around ICFP so... september?
13:12:18 <ronwalf> I wonder if I can use the C backend...
13:12:21 <adekoba> dolio: is there anything that is available in base? I'd rather not use an external package if it's not necessary
13:12:35 <dons> adekoba: Data.Binary is part of the core haskell platform.
13:12:47 <dons> adekoba: depending on your distro, it might be preinstalled.
13:12:56 <dons> if not, cabal install binary, or get it manually from hackage.haskell.orgb
13:13:00 <dolio> binary is, like, *the* method for read binary data for byte strings.
13:13:16 <dons> like totally, dude.
13:13:22 <adekoba> oh, alright then. Thanks.
13:13:23 <MyCatVerbs> adekoba: anything on Hackage can be safely considered "part of the core platform", in that it's trivial to install with cabal install now.
13:13:26 <thoughtpolice> ronwalf: with -fvia-C the issue is still arises :/
13:13:28 <dolio> And anything else will probably be significantly more pain.
13:13:46 <dons> MyCatVerbs: well, close. a subset is actually proposed for the batteries included library suite.
13:14:03 <dcoutts> MyCatVerbs: quality of hackage libs is variable
13:14:15 <MyCatVerbs> adekoba: in fact, if you use Cabal for your own code, people will be able to just "cabal install adekobasprogram" and it'll automatically fetch and compile everything on Hackage that's necessary in order to support your program.
13:14:36 <MyCatVerbs> dcoutts: ah. Point.
13:15:03 <dolio> I wouldn't consider the package I just uploaded yesterday to be part of the "core haskell platform". :)
13:15:24 <adekoba> MyCatVerbs: yeah, I'm familial with cabal-install. I wasn't aware that Data.Binary came prepackaged, however.
13:16:05 <dcoutts> adekoba: it's not prepackaged, it's in the binary package which you can get using cabal-install
13:16:50 <dolio> Ubuntu does actually have packages for binary.
13:16:56 <dolio> For instance.
13:16:57 <MyCatVerbs> adekoba: it isn't right now, but it's trivial to pull down using cabal install.
13:17:11 <MyCatVerbs> adekoba: chances are it soon will be prepackaged -too-, though.
13:17:25 <dolio> Although they're older than what's on hackage.
13:17:32 <dolio> Not surprisingly.
13:17:39 <dons> depending on your disto, it is prepackaged. as a developer, you're expected to use cabal-install though.
13:17:42 <adekoba> yeah. (@MyCatVerbs)
13:24:40 <thoughtpolice> heh, neato. thanks to cabal install yi i've actually been able to run it since version 0.1 I think?
13:25:31 <dcoutts> thoughtpolice: though I think it no longer works with 0.4, the deps are inconsistent
13:25:57 <erikc> it worked with ghc 6.8.2, but didnt with 6.8.3
13:26:13 <erikc> the bytestring in 6.8.3 is too high a version
13:26:18 <thoughtpolice> dcoutts: hm? i just got yi 0.4.1 working
13:26:28 <dcoutts> thoughtpolice: oh, perhaps they fixed it
13:26:40 <thoughtpolice> dcoutts: yeah cabal install yi for 0.4.1 works nicely.
13:26:42 <dcoutts> erikc: it's because yi specifies an exact version, which is just bogus
13:26:47 <erikc> yea
13:27:53 <thoughtpolice> 0.4.1 works fine here on 6.8.3, the dependency on bytestring was laxed a little apparently
13:29:16 <jganetsk> how does haskell gc solve the issue that thunk evaluation makes the thunk point to a newer heap object?
13:29:57 <dons> jganetsk: you mean, how do updates affect gc?
13:30:12 <jganetsk> dons: yes
13:30:52 <dons> have a look in here for the details http://hackage.haskell.org/trac/ghc/wiki/Commentary
13:30:53 <lambdabot> Title: Commentary - GHC - Trac
13:32:26 <jganetsk> there are no updates other than thunk eval, right?
13:32:57 <dons> right. eval a thunk, update the indirection with the result.
13:33:16 <dons> oh, pointers get low bits set once the thunks evaluated, and to what constructor
13:33:57 <Shiruka> how about iorefs?
13:36:27 <ronwalf> Should I be worried or merely gratified that ghc turns 352 lines of haskell into 52k lines of C?
13:36:41 <dons> gratified.
13:36:58 <ronwalf> dons: I'd be even more gratified if it worked :)
13:37:23 <dons> the C is used in assembly-like form, of course.
13:37:39 <dons> not leveraging the incredible computational expressivity of C.
13:37:55 * ronwalf is trying to debug his stupid generics problem
13:38:03 <ronwalf> It's probably hopeless (for me, anyway)
13:39:45 <thoughtpolice> ronwalf: what're you using it for btw?
13:40:32 <ronwalf> thoughtpolice: Extensible records
13:42:25 <ronwalf> I'm a grad student studying automated planning.  There is a defacto common language, PDDL, but half the planners have their own extensions
13:42:41 <ronwalf> (including mine!)
13:44:40 <ronwalf> So I needed a very flexible representation system.  Ended up going with Wouter-style expressions, and extensible records (ala http://fmapfixreturn.wordpress.com/2008/05/03/simple-extensible-records-now-quick-generic-tricks-pt-1/ )
13:44:42 <lambdabot> Title: Simple Extensible Records  Quick Generic Tricks, Pt. 1 « fmap fix return, http://tinyurl.com/5khmaw
13:44:51 <vixey> dons lol!
13:44:55 <vixey> "not leveraging the incredible computational expressivity of C."
13:45:05 <dons> finally.
13:47:27 * ronwalf figures that he can't just have ghci dump core after compilation and before executing main
13:53:04 <hml> besides harpy; what is the closest thing to an assembler written in x86_64
13:53:33 <r3m0t> question: why is buildGr :: DynGraph gr => [Context a b] -> gr a b
13:53:44 <r3m0t> instead of Graph gr => [Context a b] -> gr a b
13:56:00 <Cale> r3m0t: Because DynGraph is the class needed to combine contexts into a graph
13:56:08 <Cale> class Graph gr => DynGraph gr where
13:56:08 <Cale> (&) :: Context a b -> gr a b -> gr a b
13:56:33 <r3m0t> Cale: but from a [Context a b] you could make [LNode] and [LEdge
13:57:45 <Cale> You could, but that would sidestep the approach they were using... why not just write an instance of DynGraph?
13:58:03 <erikc> the 'occurs check' in occurs check: cannot construct the infinite type... is a unification occurs check right?
13:58:09 <r3m0t> I was just asking to understand it
13:58:19 <r3m0t> so basically it's just to simplify the code. ok
13:58:36 <vixey> erikc: yes
14:00:53 <Cale> @tell r3m0t Just in case you don't know about it, http://web.engr.oregonstate.edu/~erwig/papers/InductiveGraphs_JFP01.pdf
14:00:53 <lambdabot> Consider it noted.
14:18:52 <PO8> rwbarton: Thanks again for the help.
14:19:30 <PO8> All...  Anyone have any comments on http://hpaste.org/9162#a4 ?  See in particular the final annotation...  Thanks much for any advice you may have.
14:23:48 <gnut> hi
14:23:53 <PO8> Hi!
14:24:02 <tusho> hi?
14:24:03 <gnut> I'm trying to build ghc, but configure says I need happy.
14:24:06 <gnut> how do I build happy?
14:24:06 <vixey> PO8, hmm what does it mean
14:24:14 <tusho> god damnit
14:24:17 <tusho> you proke it
14:24:18 <gnut> I got it via darcs, but I'm confused on how to build it.
14:24:19 <tusho> er
14:24:19 <PO8> vixey: http://fob.po8.org
14:24:19 <tusho> broke
14:24:20 <lambdabot> Title: FOB | Friends Of Bart
14:24:28 <thoughtpolice> gnut: http://haskell.org/happy
14:24:28 <lambdabot> Title: Happy: The Parser Generator for Haskell
14:24:40 <gnut> thoughtpolice: I'm on that page...
14:24:42 <tusho> gnut: Note that GHC requires GHC to compile.
14:25:03 <gnut> yup. I have ghc binaries installed.
14:25:06 <tusho> ah, good
14:25:08 <tusho> just making sure
14:25:08 <gnut> I want to use package ndp
14:25:12 <gnut> that's why I'm going through all this.
14:25:14 <thoughtpolice> gnut: good luck
14:25:18 <thoughtpolice> i've been trying for a while
14:25:25 <thoughtpolice> Simon M. tells me that NDP is under a major refactoring
14:25:30 <thoughtpolice> so a lot of it still isn't in place
14:25:36 <gnut> thoughtpolice: hrm
14:25:37 <tusho> i bet the only reason ghc requires itself is because the devs were sitting around
14:25:39 <tusho> and they went like
14:25:43 <tusho> "whoa, bootstrapping is totally awesome"
14:25:46 <tusho> "yeah it breaks your mind"
14:25:48 <tusho> "hey let's do that"
14:25:49 <tusho> "haha yeah"
14:25:50 <vixey> PO8: I think I know why that happens
14:25:58 <PO8> vixey: cool
14:26:09 <tusho> years later they're like, crap
14:26:11 <thoughtpolice> gnut: see my post here on -cafe: http://www.haskell.org/pipermail/haskell-cafe/2008-July/045406.html
14:26:12 <lambdabot> Title: [Haskell-cafe] Building NDP with latest GHC, http://tinyurl.com/6edhk4
14:26:32 <thoughtpolice> whoops, it was actually Chakravarty
14:26:35 <gnut> thoughtpolice: okay... any ideas then on making efficient sparse matrix code... should I just use UArray?
14:26:56 <thoughtpolice> gnut: to build happy though you can just follow the README instructions surely
14:27:01 <thoughtpolice> gnut: not sure, tbh
14:27:25 <tusho> i let macports kill itself for me to compile ghc
14:27:29 <tusho> :D
14:27:30 <wagle> @yow
14:27:30 <lambdabot> Couldn't find fortune file
14:27:34 <gnut> thoughtpolice: wow... you just tried it 5 days ago
14:27:41 <gnut> I guess things wouldn't have changed much since then
14:27:45 <thoughtpolice> gnut: it'll probably be some time before before NDP is in place even in the HEAD
14:27:48 <thoughtpolice> yeah
14:27:57 <thoughtpolice> gnut: various other problems arose including darcs not being nice at all
14:28:01 <PO8> vixey: It seems clear that [1..] is piling up unevaluated +1 thunks. What doesn't seem clear is that this would ever be a good idea.  It seems like [1..] should be strict in its values.
14:28:26 <PO8> vixey: Just like [1..n] is for any fixed n.
14:28:29 <vixey> PO8: I am not sure the best way to explain what I think about it
14:28:29 <gnut> I've been having issues pulling ghc-HEAD with darcs, too.
14:28:34 <roconnor> > length [1..1000000000]
14:28:39 <lambdabot>  Tried to use too much memory
14:28:40 <Elly> wow, I can't write C++ any more
14:28:50 <roconnor> er
14:28:51 <Elly> whenever I try to think about a problem, I think of the answer in SML/Haskell
14:28:52 <roconnor> too big
14:28:54 <tusho> Elly: Is that a bad thing? :)
14:28:55 <Elly> then try to translate it to C++
14:29:09 <tusho> Elly: Maybe you could use -fvia-c
14:29:09 <Elly> tusho: well, my job requires C++ :P
14:29:11 <tusho> :D
14:29:11 <vixey> :/
14:29:16 <tusho> The translation part is done for you!
14:29:16 <roconnor> > length [1..10]
14:29:17 <lambdabot>  10
14:29:18 <PO8> roconnor: huh.  not at my house...
14:29:30 <Elly> tusho: in theory, someone will try to maintain the C code
14:29:32 <roconnor> > length [1..10000000]
14:29:34 <lambdabot>  Tried to use too much memory
14:29:35 <tusho> Elly: pfffffffffft
14:29:38 <tusho> who cares about them
14:29:39 <roconnor> > length [1..1000000]
14:29:40 <lambdabot>  1000000
14:29:56 <gnut> thoughtpolice: I'm probably not going to go through with happy anymore then, but just so you know, the README is pretty empty and there is no INSTALL
14:30:07 <PO8> > [1..100000000000000000] !! 99
14:30:08 <lambdabot>  100
14:30:15 <thoughtpolice> gnut: is there a Setup.hs?
14:30:21 <roconnor> > length $ map (const ()) [1..10000000]
14:30:21 <thoughtpolice> if so you can build it using the regular cabal-dance
14:30:23 <lambdabot>  Tried to use too much memory
14:30:25 <PO8> > [1..] !! 99
14:30:26 <lambdabot>  100
14:30:34 <vixey> PO8: Have you seen the memoization of fibs
14:30:43 <PO8> vixey: sure
14:30:44 <roconnor> oh right
14:30:57 <vixey> PO8: I think it's that
14:31:00 <gnut> thoughtpolice: Setup.lhs
14:31:01 <PO8> roconnor: What evaluator is lambdabot running
14:31:05 <roconnor> > length $ map (const () $!) [1..10000000]
14:31:07 <lambdabot>  Tried to use too much memory
14:31:11 <PO8> vixey: not quite following
14:31:13 <gnut> I'm not familiar with cabal
14:31:14 <thoughtpolice> gnut: right, then doing 'runghc Setup.hs configure ...' will work to install it
14:31:17 <gnut> ah
14:31:20 <gnut> ok
14:31:26 <gnut> thanks
14:31:31 <PO8> roconnor: my home ghci 6.8 doesn't do the same things here
14:31:32 <thoughtpolice> gnut: do runghc Setup.lhs configure; runghc Setup.lhs build; runghc Setup.lhs install
14:31:36 <gnut> i should read up on cabal
14:31:41 <thoughtpolice> gnut: if you want to install it somewhere else, give the flag '--prefix' to cabal
14:31:56 <roconnor> PO8: maybe you have more memory
14:31:57 <thoughtpolice> i.e. I normally do runghc Setup.lhs configure --prefix=$HOME
14:32:24 <gnut> thanks for pointing that out
14:32:26 <thoughtpolice> so I don't have to sudo (plus it keeps /usr/bin clean)
14:32:30 <vixey> PO8, for example:
14:32:31 <vixey> > let fib 0 = 0 ; fib 1 = 1 ; fib n = fib (n-1) + fib (n-2) in fib 100
14:32:37 <lambdabot>  Exception: Time limit exceeded
14:32:44 <vixey> ok it runs out of time ,.. too much recomputation
14:32:48 <vixey> > let fib 0 = 0 ; fib 1 = 1 ; fib n = fib' (n-1) + fib' (n-2) ; fibs = map fib [0..] ; fib' = (fibs!!) in fib 100
14:32:49 <lambdabot>  354224848179261915075
14:33:00 <vixey> this works though, because the big list there is reused and saved
14:33:17 <vixey> I think the lists in your code are being saved or not which is either causing the memory overflow or not
14:33:17 <thoughtpolice> gnut: yes, doing some reading would be nice. also, there is now cabal-install, so you can just do 'cabal install <pkgname>' and it will download and install it directly from hackage.haskell.org
14:33:40 <thoughtpolice> gnut: also, fwiw, if I get anywhere with getting NDP to work in the future I'll notify you
14:33:47 <gnut> thoughtpolice: thanks
14:34:13 <PO8> vixey: Yes, this seems to be what's happening.  But it's confusing why they would be saved, maybe?
14:34:21 <thoughtpolice> but I wouldn't count on anything until the HEAD becomes STABLE and lots of tweaks are in place, since DPH is going to be (in some way) apart of ghc 6.10
14:34:29 <PO8> vixey: I guess I see why the example at the end loses.
14:34:49 <PO8> > [1..] !! 999999
14:34:52 <lambdabot>  Exception: stack overflow
14:35:00 <Shiruka> > foldl' (\i _ -> i `seq` i+1) 0 $ map (const () $!) [1..10000000]
14:35:03 <lambdabot>  Tried to use too much memory
14:35:04 <PO8> > [1..10000000000000000000000000000000000] !! 999999
14:35:05 <lambdabot>  1000000
14:35:08 <Shiruka> :-<
14:35:40 <PO8> There.  That's more (not) like it.
14:38:07 <PO8> > [1..100000000000000000000000000000000000000000000000000000000000000000000000000000000] !! 999999
14:38:08 <lambdabot>  1000000
14:38:26 <PO8> > [1..] !! 999999
14:38:28 <lambdabot>  Exception: stack overflow
14:38:39 <PO8> This difference disturbs me greatly.
14:39:03 <vixey> why?
14:39:14 <vixey> hey lets try something
14:39:23 <vixey> @let bajillion = 100000000000000000000000000000000000000000000000000000000000000000000000000000000
14:39:24 <lambdabot> Defined.
14:39:44 <vixey> > let upfrom i = i : upfrom (i+1) in upfrom 0 !! 999999
14:39:45 <lambdabot>  Exception: stack overflow
14:39:59 <lelf> > foldl1 (const . (+1)) [1..10000000]
14:40:00 <lambdabot>  10000000
14:40:11 <vixey> > let upfromTo i j = if i < j then i : upfromTo (i+1) j else [] in upfromTo 0 bajillion !! 999999
14:40:12 <lambdabot>  999999
14:40:15 <Shiruka> why not bajillion = 10^80.. more readable :-p
14:40:24 <PO8> vixey: Because their execution should be fundamentally the same.
14:40:29 <PO8> Shiruka: Good point.
14:40:36 <vixey> PO8: See what I got there?
14:40:44 <vixey> (the same thing as you've got with [..]
14:40:53 <PO8> vixey: yes...
14:41:19 <vixey> no watch this :p
14:41:21 <vixey> > let upfrom i = i `seq` (i : upfrom (i+1)) in upfrom 0 !! 999999
14:41:22 <lambdabot>  999999
14:41:38 <vixey> so why has this happened ?
14:41:45 <vixey> (is it clear now or not?)
14:41:55 <geezusfreeek> i find this example amusing
14:42:14 <tusho> sclv_: any progress on hvac?
14:42:50 <vixey> PO8: so how much memory does 'bajillion' take up and compared to 0+1+1+1...+1 a bajillion times?
14:43:03 <vixey> it must be 0+1+1+1...+1 takes up lots more memory
14:43:52 <vixey> actually we only went up to 999999 but the it's the thought that counts
14:44:26 <tusho> bajillion + 7
14:44:47 <jberryman> if I wrote my own function 'insertAt' or whatever, I could do the following more efficiently, correct?
14:44:50 <jberryman> > let (l,r) = splitAt 3 [1,2,3,5,6] in l ++ 4 : r
14:44:51 <lambdabot>  [1,2,3,4,5,6]
14:45:34 <vixey> > let insertAt index value list = let (l,r) = splitAt index list in l ++ value : r in insertAt 3 4 [1,2,3,5,6]
14:45:35 <lambdabot>  [1,2,3,4,5,6]
14:46:20 <jberryman> the first bit of the original list is being traversed twice though, correct? so it could be faster?
14:46:21 <PO8> vixey: I guess I'm just saying that I expected [1..] to have the operational behavior of your second form---to be spine-lazy, but value-strict.  Isn't this a reasonable expectation?
14:46:34 <vixey> PO8: Did you see my example with seq?
14:47:16 <vixey> jberryman: How could it be faster?
14:47:27 <PO8> vixey: That's what I was referring to.
14:47:34 <vixey> @src enumFromTo
14:47:35 <lambdabot> Source not found. Maybe if you used more than just two fingers...
14:47:38 <vixey> ugh...
14:47:50 <vixey> enumFromTo i j = what I wrote earlier, the one without seq
14:47:57 <MyCatVerbs> vixey: enumFromTo is defined differently for every single instance.
14:48:21 <geezusfreeek> PO8: that would be a reasonable expectation if the field of the (:) constructor was strict
14:48:49 <rwbarton> I think PO8's expectation is a fair one.  Consider
14:48:59 <rwbarton> > length $ take 100000000 ([0..] :: Integer)
14:48:59 <geezusfreeek> as in data List a = Cons !a (List a) | Nil
14:49:00 <lambdabot>  Couldn't match expected type `Integer' against inferred type `[a]'
14:49:04 <rwbarton> > length $ take 100000000 ([0..] :: [Integer])
14:49:06 <lambdabot>  Tried to use too much memory
14:49:07 <rwbarton> > length $ take 100000000 ([0..] :: [Int])
14:49:09 <lambdabot>  Tried to use too much memory
14:49:19 <rwbarton> hmm
14:49:54 <jberryman> vixey: if I wrote a new function that went through the list counting elements and inserted the value at the proper point all in one go would that be faster?
14:50:14 <vixey> jberryman: How could it be faster?
14:50:16 <dolio> There's not much reason to not make it element strict in practice, except maybe that the report doesn't define it that way.
14:50:16 <rwbarton> Well, try those two in ghci
14:50:31 <dolio> For Ints at least.
14:51:00 <rwbarton> It is element strict for Int.
14:51:24 <vixey> jberryman: Oh I see what you mean
14:51:40 <dolio> > ([1..] :: [Int]) !! 999999
14:51:41 <lambdabot>  1000000
14:51:42 <geezusfreeek> > [0..] !! 100000000 :: Int
14:51:44 <lambdabot>  Tried to use too much memory
14:51:46 <jberryman> vixey: right, or am I reasoning about laziness wrong
14:51:54 <dolio> > ([1..] :: [Int]) !! 2000000
14:51:55 <geezusfreeek> > [0..] !! 10000 :: Int
14:51:56 <lambdabot>  2000001
14:51:56 <lambdabot>  10000
14:52:04 <vixey> jberryman: I don't really know, I think your reasoning is fine
14:52:06 <dolio> Which was it failing on? Integer?
14:52:10 <geezusfreeek> > [0..] !! 10000 :: Integer
14:52:11 <lambdabot>  10000
14:52:14 <dolio> There's not much reason to make that lazy, either.
14:52:16 <geezusfreeek> > [0..] !! 1000000 :: Integer
14:52:17 <lambdabot>  Exception: stack overflow
14:52:20 <geezusfreeek> > [0..] !! 1000000 :: Int
14:52:21 <rwbarton> (In GHC, that is.  Search http://haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-Enum.html for Enum Int)
14:52:21 <lambdabot>  1000000
14:52:22 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/645dsz
14:52:25 <geezusfreeek> there we go
14:52:56 <clanehin> @seen gwern
14:52:57 <lambdabot> Last time I saw gwern was when I left ##logic, #arch-haskell, #darcs, #dreamlinux-es, #friendly-coders, #gentoo-haskell, #gentoo-uy, #ghc, #haskell, #haskell-blah, #haskell-books, #haskell-hac07, #
14:52:57 <lambdabot> haskell-hac4, #haskell-overflow, #haskell-soc, #haskell.cz, #haskell.de, #haskell.dut, #haskell.es, #haskell.fi, #haskell.fr, #haskell.hr, #haskell.it, #haskell.jp, #haskell.no, #haskell.ru, #
14:52:57 <lambdabot> haskell.se, #haskell_ru, #japanese, #jhc, #jtiger, #macosx, #parrot, #perl6, #rosettacode, #scala, #scannedinavian, #thunks, #unicycling and #xmonad 4d 23h 40m 57s ago, and .
14:53:12 <dolio> > [1..] !! 999999
14:53:14 <lambdabot>  Exception: stack overflow
14:53:25 <dolio> > [1..] !! 999999 :: Integer
14:53:28 <lambdabot>  Exception: stack overflow
14:53:39 <Armored_Azrael> Wait, do we not have tail recursion optimizations yet?
14:53:41 <geezusfreeek> > ([0..] !! 1000000 :: Int, [0..] !! 1000000 :: Integer)
14:53:42 <lambdabot>  (1000000,Exception: stack overflow
14:53:44 <Armored_Azrael> Or is !! just silly
14:53:54 <rwbarton> No, [0..] is just silly
14:53:56 <dolio> !! isn't causing the overflow.
14:54:05 <Armored_Azrael> oh ok
14:54:15 <dolio> (+) (or something like it) is causing the overflow.
14:54:40 <vixey> having a big series of +1's is taking up lots of memory
14:54:45 <dolio> @src enumFrom Integer
14:54:45 <lambdabot> Source not found. Sorry.
14:54:55 <dolio> @src Integer enumFrom
14:54:55 <lambdabot> Source not found. That's something I cannot allow to happen.
14:55:05 <vixey>  = map toEnum . iterate (+1)
14:55:11 <vixey> or fromEnum .. or something
14:55:14 <rwbarton> I believe a more correct definition would be  instance Enum Integer where enumFrom x = map (x+) (enumFromStrict 0) ; enumFromStrict x = x `seq` (x : enumFromStrict (x+1))
14:55:57 <rwbarton> (Why the map (x+)?  Because I believe enumFrom technically shouldn't be strict in its argument.)
14:56:11 <rwbarton> > length $ take 3 $ ([undefined..] :: [Integer])
14:56:12 <lambdabot>  3
14:56:22 <vixey> rwbarton: oh, I like that
14:58:06 <PO8> rwbarton: I was just looking at the Haskell98 Report.  enumFrom is required to be strict in its argument.
14:58:16 <rwbarton> Oh really?
14:58:19 <rwbarton> Interesting
14:58:23 <PO8> rwbarton: (for numeric types)
14:58:24 <jpcooper> @info sortBy
14:58:24 <lambdabot> sortBy
14:58:44 <jpcooper> where is sortBy defined?
14:58:46 <clanehin> gwern: Hello
14:58:52 <PO8> rwbarton: But the Report is totally agnostic about whether the result is value-strict.
14:58:53 <dolio> Data.List
14:59:05 <jpcooper> right, sorry
14:59:07 <PO8> (as near as I can determine)
14:59:24 <tusho> which argument
14:59:25 <rwbarton> PO8: I see, you're right.  So that "length $ take 3 $ ..." is a bug?
14:59:27 <tusho> first, second, both?
14:59:42 <rwbarton> "all of the enumFrom family of functions are strict in all their arguments"
14:59:45 <tusho> ah
15:00:12 <PO8> rwbarton: In their arguments; that's not the question here, though, I think?
15:00:17 <gwern> clanehin: hi
15:00:30 <gwern> hm. my internet is back
15:00:43 <tusho> yes it is gwern
15:00:45 <PO8> rwbarton: Never mind.  You're right.  That's a bug.
15:01:06 <Shiruka> :-D "My suspicion is that reactive animation works very nicely for the examples constructed by reactive animation folk, but not for my examples."
15:01:17 <gwern> anything interesting happen today in haskell-land?
15:01:26 <Shiruka> one rarely gets to laugh when reading papers, so it's doubly funny
15:01:35 <PO8> Shiruka: Nice
15:01:47 <clanehin> gwern: Since cabalizing things has been your hobby of late, I was curious if you felt any motivation to work (optionally with me) on stripping the autotoolisms from HOpenGL.  I don't know cabal so well.
15:01:57 <hackage> Uploaded to hackage: haddock 2.2.0
15:02:03 <Shiruka> (this from a paper which purports to give a solution to such problems :-)
15:02:09 <dolio> > [undefined..] :: [Int]
15:02:10 <lambdabot>  Exception: Prelude.undefined
15:02:10 <rwbarton> That behavior is easier to implement anyways.  And it's how the Int instance works already
15:02:23 <gwern> clanehin: hopengl? why does that have autoolisms?
15:02:24 <roconnor> > [undefined..]
15:02:25 <lambdabot>  Exception: Prelude.undefined
15:02:25 <dolio> > length . take 3 $ ([undefined..] :: [Int])
15:02:26 <lambdabot>  Exception: Prelude.undefined
15:02:28 <gwern> but sounds worthwhile
15:02:38 <bwr> rwbarton: I like your google code jam solutions. I've been learning IO from them :P
15:02:44 <clanehin> gwern: cabal calls into a configure script
15:02:44 <PO8> dolio: Oh.  Not a bug.
15:02:59 <tusho> bwr: *Io
15:02:59 <dolio> It's a bug that it isn't that way for Integer.
15:03:04 <rwbarton> bwr: thanks :)
15:03:15 <clanehin> gwern: from the mailing list it seems to possibly be a problem
15:03:34 <PO8> dolio: Got it.  My head is spinning so much now that I can't keep straight what we're doing. :-)
15:03:39 <gwern> clanehin: ln pls?
15:03:41 <dolio> :)
15:03:55 <dolio> > length . take 3 $ ([undefined..] :: [Float])
15:03:56 <lambdabot>  3
15:04:00 <dolio> > length . take 3 $ ([undefined..] :: [Double])
15:04:02 <lambdabot>  3
15:04:06 <dolio> Also bugs.
15:04:15 <clanehin> gwern: pls?
15:04:15 <rwbarton> I think the summary is (1) The Enum Integer doesn't match the report about strictness in its argument (which is obviously easy to fix)
15:04:29 <gwern> clanehin: please, the magic word
15:04:34 <rwbarton> (2) the Enum Integer also could be written to avoid constructing big thunks, with no change in semantics
15:05:01 <dolio> I think making enum* strict will probably automatically fix that.
15:05:08 <rwbarton> If it's recursive, yeah.
15:05:43 <dolio> Which is nice, since it's a periodic source of real errors.
15:06:01 <erikc> is there a way to ask ghci for the infix type for functions like . and $
15:06:02 <dolio> Or "real" errors.
15:06:10 <PO8> dolio: Heh
15:06:13 <dolio> @type (.)
15:06:14 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:06:36 <erikc> sorry, i mean, get the precedence and associativity
15:06:46 <erikc> couldnt find the right words heh
15:06:47 <dolio> Oh. That should be in :info, I think.
15:06:54 <clanehin> gwern: Oh.  Link please: http://www.haskell.org/haskellwiki/Opengl
15:06:55 <PO8> Thank you all hugely.  Who is going to post the bug?
15:06:56 <erikc> ah awesome
15:06:57 <lambdabot> Title: OpenGL - HaskellWiki
15:10:13 * PO8 listens to the crickets.
15:10:26 <PO8> I'll try to figure out how to do it.  Any advice appreciated.
15:10:40 <dolio> Well, I can post it to the libraries list if no one else is going to.
15:11:09 <PO8> dolio: That would be great.
15:13:10 <dolio> > length . take 3 $ (enumFromThen 0 1 :: [Integer])
15:13:11 <lambdabot>  3
15:13:16 <dolio> > length . take 3 $ (enumFromThen 0 1 :: [Float])
15:13:17 <lambdabot>  3
15:13:23 <gwern> huh. Randy Pausch is dead
15:13:24 <dolio> > length . take 3 $ (enumFromThen 0 1 :: [Double])
15:13:25 <lambdabot>  3
15:13:28 <gwern> that didn't take so long
15:13:29 <dolio> > length . take 3 $ (enumFromThen 0 1 :: [Int])
15:13:30 <lambdabot>  3
15:13:42 <dolio> Oh, wait, what am I doing.
15:14:36 <twanvl> you are asking lambdabot to print 3?
15:14:56 <idnar> heh\
15:14:59 * Twey laughs.
15:15:04 <dolio> Well, that's not what I was hoping for, but it's what I was actually doing. :)
15:15:06 <rwbarton> dolio: also you might want to mention that the comment "Blarg: technically I guess enumFrom isn't strict!" appearing twice in GHC.Enum is wrong
15:15:57 <hml> in my current dir; how do I load Cube.hs into ghci?
15:17:37 <dolio> rwbarton: Well, one of those is on Chars, which isn't exactly specified.
15:17:41 <erikc> hrm, i wonder if windows exposes enough window management hooks to get xmonad working on windows
15:17:43 <dcoutts> hml: ghci Cube.hs
15:18:24 <gwern> erikc: that's been discussed before, and I still hold it's madness!
15:18:31 <shepheb> erikc: a better pondering might be "does Windows expose /any/ window management hooks". it's probably impossible.
15:18:40 <shepheb> Windows just doesn't expect a replacement window manager
15:18:53 <erikc> i've spent an hour crawling msdn and cant find anything meaty
15:18:55 <shepheb> though I agree, it would be awesome
15:18:57 <erikc> but litestep does exist
15:19:02 <hml> dcoutts: thanks
15:19:32 <erikc> but litestep is an entire shell replacement, not just window management
15:19:41 <hml> is there a way to fit a [Int] into the following code: let order = [4, 5, 1, 3, 2, 6]
15:19:56 <Botje> uh
15:20:01 <Botje> order *IS* an [Int]
15:20:15 <Shiruka> not [Integer]?
15:20:35 <hml> Botje: yeah, I want to have an order :: [Int] somewhere in that let statement
15:20:55 <Shiruka> let order = [4, 5, 1, 3, 2, 6] :: [Int]
15:21:02 <hml> ah; thanks
15:21:04 <vixey> hml: Why?
15:21:42 <Shiruka> performance raisins, probably
15:21:52 <Shiruka> very fast dried berries
15:21:53 <hml> vixey: debugging reasons
15:22:17 <dolio> Is libraries@ the right place to talk about GHC.* modules?
15:23:22 <PO8> dolio: That's part of what I was wondering too.  I was tempted to just submit a bug report to http://hackage.haskell.org/trac/ghc/wiki/ReportABug
15:23:23 <lambdabot> Title: ReportABug - GHC - Trac
15:23:43 <dons> dolio: sure.
15:23:55 <dons> dolio: what is the issue?
15:24:09 <dolio> Strictness of enumFrom*
15:24:20 <dolio> 1) It causes stack overflows, 2) it doesn't match the report.
15:24:35 <dolio> (The report version presumably won't cause stack overflows.)
15:24:37 <PO8> Specifically on Numeric types other than Int
15:24:49 <rwbarton> dolio: It's not specified with the numeric types (Enum Char that is), but it is specified to be strict in the standard prelude section if I understand the definition there correctly.
15:26:11 <twanvl> dolio: In that case you could submit it to libraries@, since the bug also affects non Ghc-specific things
15:26:24 <dons> dolio: there's a trac ticket.
15:26:29 <dons> and yeah, that's a libraries@ question.
15:26:45 <dons> if you're making it lazy, be warned, it probably kills performance
15:26:55 <dolio> No, it's already lazy.
15:27:09 <dons> if you want to strictify the atomic types, i'm all for it. :)
15:27:24 <PO8> dons: The Report seems to require that it be strict on Integer, Float and Double, but it isn't
15:27:38 <dolio> Or, they're lazy in their arguments, and the report specifies that they should be strict in all arguments.
15:28:00 <PO8> Yeah, what he said. :-)
15:28:06 <PO8> dons: Which trac ticket are you looking at?
15:28:10 <dolio> But making them strict in their arguments should probably make them produce element-strict lists, which is desirable.
15:28:55 <dons> PO8: well, its one i proposed about 6 months ago to fix Integer.
15:29:01 <dons> and the Double/Float fromEnum behaviour.
15:29:07 <dons> SimonM gave it the ok.
15:29:14 <dons> i've even a patch against head to fix it.
15:29:31 <PO8> dons: Excellent!  Thanks much.  Sorry to be rediscovering it for you. :-)
15:29:32 <dons> so look for fromEnum
15:29:38 <PO8> dons: Will do
15:29:40 <dons> no, no, find the ticket. and add some comments.
15:29:47 <dons> and we can just solve it.
15:29:51 <dolio> Should I not send a mail to libraries, then?
15:30:20 <dons> please send mail. but if you can possibly reference the original discussionn & ticket.
15:30:28 <dons> i'll hunt for it after i'm out of this meeting.
15:30:32 <dolio> Okay, I'll see if I can find it.
15:30:50 <PO8> dons: I'm looking on the GHC trac, but can't find it.  Am I at the right place?
15:30:58 <dons> ?bug
15:30:58 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
15:31:31 <dons> http://hackage.haskell.org/trac/ghc/ticket/1997
15:31:33 <dons> that one.
15:31:33 <lambdabot> Title: #1997 (Stricter enumFrom instance for Integer, to match Int) - GHC - Trac
15:31:50 <dolio> rwbarton: If I'm reading the standard prelude section right, it looks like their definition of enumFrom* for Float and Double aren't strict, despite the comment in the earlier section. :)
15:31:57 <dons> "I suggest we do as Don suggests, and make all the numeric types behave consistently with respect to strictness of enumFrom*. "
15:32:00 <dons> :)
15:32:19 <dolio> The ones for Int and Integer are elided.
15:33:02 <dolio> Oh, that's noted in the discussion in that bug, too.
15:33:05 <PO8> I was searching on fromEnum :-)  Thanks
15:33:17 <rwbarton> dolio: Yes :)  I didn't get that far
15:33:40 <dolio> The one on Char is defined in terms of Int, though, so it should be strict as well, I guess.
15:34:06 <rwbarton> dolio: I reasoned that it was strict for the same reason [5..0] is empty
15:34:44 <rwbarton> (that was poorly worded)
15:35:00 <gnut> do DiffArrays really get the advantages of both IOArray and regular Array?
15:35:05 <gnut> Is there such thing as a free lunch?
15:35:19 <dolio> > length . take 3 $ (enumFromThenTo undefined 1 1 :: [Integer])
15:35:20 <lambdabot>  Exception: Prelude.undefined
15:35:40 <PO8> It's not obvious to me how to register on the GHC Trac to add to this bug...  When I try, I get an http auth dialog
15:35:46 <twanvl> gnut: DiffArrays are incredibility slow
15:35:47 <dons> ?bug
15:35:47 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
15:35:51 <gnut> twanvl: oh
15:35:52 <dons> ^ regiser an account
15:35:56 <gnut> didnt know that :)
15:36:02 <gnut> twanvl: which is the fastest? ioarray?
15:36:09 <rwbarton> dolio: Right
15:36:13 <PO8> dons: I'm trying: that's what's asking me for authentication...
15:36:40 <gwern> aha, cabal-install is broken in sdist because it omitted a module in cabal-install.cabal
15:37:13 <twanvl> gnut: If you want to change the array, then ST(U)Array is probably the best. But, depending on the situation, using a Map might be better
15:37:16 <dcoutts> gwern: oh?
15:37:34 <kryptiskt> gnut: Look up Data.IntMap
15:37:50 <Cale> Or if the arrays are not so huge, or not *so* many changes will be made, just a UArray isn't so bad.
15:38:08 <PO8> dons: nevermind.  got it
15:38:12 <kryptiskt> Otherwise IOUArray is fast and ugly
15:38:13 <gwern> dcoutts: as I keep saying, we need to make cabal build from sdist by default, or at least easy...
15:38:21 <gnut> kryptiskt: twanvl: thanks...
15:38:51 <gwern> dcoutts: I'm darcs-sending a patch, but will the ml hold for moderation?
15:38:57 <gnut> kryptiskt: I'm trying to write Sparse matrix code... dunno if a map will be sufficient for me
15:39:05 <dcoutts> gwern: perhaps, you're not subscribed?
15:39:29 <gwern> I'm not; too many emails
15:39:36 <dcoutts> gwern: you're right of course, there's that ticket open if you or I can persuade anyone to hack on it
15:39:44 <kryptiskt> well then IntMap has the advantage that indexes without data doesn't exist and take up space
15:39:48 * gwern isn't *that* interested in the minutia of development, and I get way too many emails as it is
15:40:20 <dcoutts> gwern: tell me your address and I'll add you to the list of addresses that can send, though not subscribed
15:40:34 <gwern> dcoutts: gwern0@gmail.com
15:44:25 <dcoutts> gwern: oh, you're already on the list :-)
15:52:17 <PO8> dons: I added a report to the Trac.  Thanks again for all your help.
15:52:30 <PO8> rwbarton: Thanks hugely!  That was great.
15:52:36 <PO8> dolio: Thanks very much.
15:52:42 <dolio> No problem.
15:55:22 <halberd> is there a library function that does the same as this:  accumulate f a (b:bs) = accumulate f (f a b) bs; accumulate f a [] = a
15:55:50 <halberd> accumulate :: (a -> b -> a) -> a -> [b] -> a
15:56:00 <vixey> :t foldr
15:56:03 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
15:56:04 <mauke> @src foldl
15:56:04 <lambdabot> foldl f z []     = z
15:56:04 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
15:56:12 <vixey> :t foldl
15:56:13 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
15:56:34 <kryptiskt> room's cold? go to the ghc directory and type "make -j 4". Thought my computer was going to catch fire for a while there :-)
15:56:51 <thoughtpolice> kryptiskt: i normally do make -j6 on this macbook
15:56:57 <halberd> oh I see, I was aware of that I just was thinking in different terms
15:57:01 <halberd> thanks
15:57:02 <dcoutts> kryptiskt: mm, could do though I prefer the peace and quiet :-)
15:57:20 <kryptiskt> thoughtpolice, any burn marks?
15:57:23 <thoughtpolice> kryptiskt: the little strip above the F keys can cook stuff sometimes, I swear it :)
15:57:28 <erikc> make -j12
15:57:40 <thoughtpolice> kryptiskt: no, although it has gotten incredibly uncomfortable on the lap to say the least
15:57:52 <thoughtpolice> i make it principle to only build GHC when it's on a flat surface
15:58:23 <erikc> are there quad core laptops yet
15:59:17 <dublpaws> dunno but I hope AMD catches up with Intel soon so the next bigger better is sooner
15:59:19 <kryptiskt> erikc, only fake with hyperthreading yet, i believe
15:59:20 <thoughtpolice> heh, on the trac page with a quad core ghc was timed to build in under 8 minutes.
15:59:50 <thoughtpolice> i think with -j6 and some reasonable build optimizations for the HEAD I can do it in approximately ~15
16:00:15 <thoughtpolice> now, compiling GHC on an archlinux box with 256mb of RAM and a p4 with just 'make,' that will take a little time :)
16:00:22 <erikc> hehe
16:00:44 <thoughtpolice> i think on average it roughly came out to 6 hours or something for a 'production build.'
16:01:10 <thoughtpolice> i was going to try it on my old pentium 3 with 198mb RAM when it ran freebsd
16:01:16 <erikc> i built it a while back to burn in my 8 core box, it went fast
16:01:17 <thoughtpolice> i decided to go for a binary package instead
16:01:27 <kryptiskt> that has to be a real bottleneck in the GHC on ARM efforts
16:02:00 <thoughtpolice> no doubt, considering cross-compilation isn't possible.
16:02:48 <thoughtpolice> hopefully the new ghc backend can alleviate the porting/cross-compiling/code-generator-addition process
16:03:10 <thoughtpolice> although still, the RTS and whatnot makes a good few assumptions about your system based on the output I see from the build in certain places
16:03:17 <thoughtpolice> so cross-compilation might still be a 'no way'
16:07:29 <O_4> Hmm, if display :: Window -> IO (), how does ghc know that "displayCallback $= display window" needs to set the callback to the partially-compiled display invocation, rather than the result of invoking display?
16:09:58 <Cale> O_4: because you're passing  display window,  which is an IO action to $=, and not the result of that IO action
16:10:10 <Cale> If you wanted to do the latter, you'd have to add another line to your do-block
16:10:26 <Cale> (in order to run display window and get the result)
16:11:05 <O_4> So if display was a pure func, then it would be the result of evaluating it that the callback was set to?
16:11:39 <O_4> And it's only because it's an IO action that it isn't evaluated?
16:11:45 <Cale> In fact, you can think of display as a pure function
16:12:09 <Cale> It's a pure function which for the same Window parameter always gives the same IO action
16:12:28 <Cale> which is just a value describing some stuff to possibly be done sometime
16:12:55 <O_4> Oh hold on a second, "display window" evaluates to an IO action, which can then be evaluated to do my display stuff?
16:13:04 <Cale> executed
16:13:09 <O_4> Right
16:13:11 <Cale> evaluation does nothing to IO actions
16:13:19 <Cale> Well, nothing observable anyway.
16:13:36 <O_4> So the "display window" is in fact being evaluated, and it's resulting in an IO action
16:13:40 <Cale> yes
16:13:48 <O_4> That makes much more sense
16:14:35 <Cale> Well, $= might also just be passing along a thunk for that IO action without evaluating what the action actually is, but you don't need to care about that. The evaluation of the action will get done whenever it needs to.
16:14:51 <O_4> Yeah, ok.
16:14:56 <Cale> (at some point before it's executed)
16:14:58 <O_4> Thanks Cale :-)
16:15:02 <Cale> No problem
16:18:17 <chrisdone> > (id $ \x -> x) ()
16:18:19 <lambdabot>  ()
16:18:35 <chrisdone> just checking $ worked with \
16:18:49 <dons> > (\x -> x $ \x -> x $ \x -> x $ \x -> x) ()
16:18:50 <lambdabot>  Couldn't match expected type `(((((t -> t) -> b2) -> b2) -> b1)
16:18:54 <dons> hehe
16:19:27 <chrisdone> hehe
16:19:57 <mauke> > (\x -> x $ \x -> x $ \x -> x $ \x -> x) id
16:19:57 <lambdabot>  Add a type signature
16:25:50 <vixey> What is the next program I should write?
16:27:01 <drguildo> can somebody please explain what's meant by "These two restrictions together mean that any function call can be omitted, repeated, or replaced by the result of a previous call with the same parameters, and the language guarantees that all these rearrangements will not change the program result" in http://haskell.org/haskellwiki/IO_inside
16:27:02 <lambdabot> Title: IO inside - HaskellWiki
16:28:00 <dons> drguildo: referential transparency?
16:28:01 <drguildo> surely if you can omit function calls without changing the result then you could just have an empty source file which would run any program
16:28:19 <dons> drguildo: omit a function call *if you have a previous call's result *
16:28:47 <vixey> if you knew f 4 = 7 you don't have to calculute f 4 again, .. you can just use the result 7
16:28:58 <drguildo> oh
16:29:13 <vixey> that's not true in a language where calling f 4 might.. say.. print something out
16:29:14 <drguildo> am i misreading it or something?
16:29:22 <gnut> too many words
16:29:23 <vixey> but haskell is pure so it's o
16:29:27 <drguildo> because that makes sense, but i don't get that from that text
16:29:30 <vixey> k
16:29:48 <vixey> then edit the text
16:30:37 <drguildo> well i don't want to go editing stuff if i'm the only person who it doesn't make sense to
16:30:42 <Cale> drguildo: another way of saying what the text is awkwardly trying to say is that in Haskell, if f x is equal to g x for all values x, then any occurrence of f in the program can be replaced with g
16:31:32 <Cale> (not exactly the same as the way that the text puts it, but I think that's probably clearer)
16:31:48 <drguildo> Cale, yep, i understand that but couldn't quite see what the text was getting at
16:32:28 <Cale> yeah, the text is unclear
16:32:48 <Cale> (specifically the part about omitting or repeating the call)
16:32:51 <gnut> does the language guarantee the rearrangements are valid? or the purity of the language guarantees?
16:32:56 <chrisdone> vixey: make a hackage package?
16:33:03 <drguildo> it seemed to be saying that you could omit any function call (entirely), replace it (with god knows what, the same function call is obvious), or the result from a previous call with the same parameters
16:33:10 <chrisdone> of something cool
16:33:18 <Cale> drguildo: yeah, which is not right
16:33:31 <Cale> gnut: both?
16:34:08 <gnut> Cale: I suppose so, but emphasizing the purity might make it clearer?
16:34:23 <gnut> dunno. I guess it might depend on the previous sentence, which I haven't read.
16:35:02 <Cale> I think the confusion mostly stems from the description of the rearrangements, which is incorrect.
16:35:05 <drguildo> gnut, it's the first paragraph so there's not much previous stuff covered
16:35:27 <gwern> hm. what's a good synonym for 'extension' which doesn't start with  e/i/m/p/t?
16:35:54 <mauke> supersized
16:36:09 <gnut> hehehe
16:36:17 <gnut> or in the simpsons, megasized!
16:36:18 <Cale> adjunct?
16:36:24 <Twey> 'Augmentation'
16:36:25 <clanehin> feature?
16:36:34 <gnut> bug?
16:36:38 <mauke> bloat
16:36:40 <Cale> What do you mean by 'extension'?
16:36:46 <gnut> extension cable?
16:36:53 <gwern> Cale: as in -fglasgow-exts
16:37:01 <vixey> addition
16:37:21 <Twey> I like 'augmentation' :-(
16:37:22 <gwern> hm. reasonable, if somewhat roundabout
16:37:42 <mauke> sugar
16:37:44 <kryptiskt> xtension
16:37:48 <gnut> addons
16:38:01 <Twey> mauke: Lemon!
16:38:09 <Shiruka> Extension, with a capital E
16:38:14 <gnut> ++
16:38:28 <mauke> dialect
16:38:30 <gwern> hm. 'Extension' almost feels like cheating
16:38:40 <gwern> but capital letters are valid in CLI flags...
16:39:13 <chrisdone> augand^_^
16:39:15 <Cale> gwern: What are you trying to do?
16:39:25 <chrisdone> augend?
16:39:45 <Twey> Augend?  No no.
16:39:45 <gnut> additives
16:39:59 <Twey> That's not even semantic.
16:40:02 <clanehin> maybe you're trying to make a short flag -x and e i m p and t are taken?
16:40:13 <chrisdone> augend goes nice with augmentation
16:40:19 <Cale> -X
16:40:24 <Twey> It does, but that's something that gets augmented
16:40:37 <chrisdone> twey: that's right
16:40:39 <Twey> Mathematically speaking
16:40:39 <vixey> -XGADTs etc.. already exist though
16:40:43 * Twey scrolls up
16:40:48 <gwern> Cale: adding a CLI flag to Mueval to allow the -fglasgow-exts flags, which I need for NoMonomorphismRestriction, which I need to be able to run quickcheck tests in mueval, which I need to finally scrap hs-plugins in lambdabot, which I need to make lambdabot not such an unreliable buggy pile of shite, which I need to render my existence in haskell-land slightly less vexing, which I need to render my computer existtence slightly less vexing./....
16:40:53 <Twey> Yes
16:41:09 <Twey> I think we're looking for a word for the thing that augments the augend
16:41:11 <drguildo> "These two restrictions together mean that any function call can be replaced by the result of a previous call with the same parameters, and the language guarantees that all these rearrangements will not change the program result."
16:41:15 <drguildo> is that correct?
16:41:22 <Cale> gwern: use -X
16:41:23 <chrisdone> twey: addend?
16:41:28 <Cale> gwern: because it's what GHC uses
16:41:33 <Twey> Yes, chrisdone
16:41:37 <vixey> gwern keep going . !
16:41:38 <drguildo> i.e. a valid replacement for the current text
16:41:43 <Twey> Doesn't sound as nice as augmentation though :-(
16:41:50 <chrisdone> twey: no :(
16:41:54 * vixey wants to know what you get after a few more levels..
16:42:03 <gwern> vixey: no, I think beyond that it gets a little tedious
16:42:30 <gwern> '...which I need to render existing more attractive than comitting suicide'
16:42:41 <chrisdone> drguildo: is that a definition of referential transparency?
16:43:14 <drguildo> chrisdone, yeah
16:43:26 <Shiruka> apparently it's a claim a wiki page makes of all haskell functions, including IO
16:43:27 <ddarius> gwern: Give up on your computer existence.  It is not all that worth it anyway.
16:43:29 <chrisdone> drguildo: I guess it is then, hehe
16:43:31 <pejo> drguildo, what are the two restrictions you're talking about?
16:43:55 <Cale> drguildo: yes, that's correct
16:44:44 <drguildo> pejo, functions not having side-effects and their results being determined solely by their parameters
16:45:36 <gwern> ddarius: no! but then that means my last several years have been wasted!
16:45:48 <vixey> what is beyond that?
16:45:50 <ddarius> gwern: I hate to break it to you ...
16:46:08 <Shiruka> the page promises interesting things, maybe I should read it too :-) thus far I've just used all the IO idioms/hacks as black box black magic that works because gurus say so
16:46:30 <chrisdone> IO idioms/hacks?
16:46:39 <vixey> Shiruka: Cale told me how IO could be thought of working
16:46:43 <Cale> http://www.haskell.org/haskellwiki/Introduction_to_IO
16:46:44 <lambdabot> Title: Introduction to IO - HaskellWiki
16:46:44 <Shiruka> things like the global var with noinline and unsafeperformio..
16:46:52 <Cale> That's my little introduction to IO.
16:46:58 <vixey> oh
16:47:01 <vixey> cool
16:47:39 <chrisdone> lovely jubbly
16:47:49 <Cale> It should give anyone enough information that they'd know what to do with things they find in the documentation.
16:47:54 <vixey> hmm
16:48:02 <vixey> no Cale that page has not got on it the description I really like
16:48:09 <Cale> vixey: hmm
16:48:14 <Cale> vixey: Which was that?
16:48:16 <ddarius> Cale's "little introductions" to IO/Monads have Borg like names: 2 of 7, 1 of 3.
16:48:19 <vixey> data IO a where
16:48:31 <Cale> vixey: ah, that one
16:48:33 <vixey>  PutChar :: Char -> IO ()
16:48:35 <vixey> etc..
16:48:37 <Cale> yeah
16:48:46 <vixey> Cale: because I never understood how IO can possibly be pure until that
16:48:47 <chrisdone> does a web site that people add little tutorials too which get up modded like reddit based on clarity and accuracy sound like a good idea? like wikipedia but for teaching plus user moderation?
16:48:51 <Shiruka> plain IO without any hacks is quite understandable without knowing how it works inside :-)
16:48:52 <chrisdone> s/too/to
16:49:33 <vixey> although I think roconnor was extending the idea so that it is even closer to the semantics of IO
16:49:37 <vixey> but I'm not sure about it....
16:50:47 <Shiruka> some people (like me usually) like to know how things Really Work (by UTSLing if all else fails) behind the scenes though.. I've just not bothered yet with Haskell's IO
16:51:01 <ddarius> chrisdone: It's cheap enough to try that you might as well.  It might make you rich!
16:51:13 <chrisdone> ddarius: thanks, Paul!
16:51:31 <roconnor> @wiki IO Semantics
16:51:32 <lambdabot> http://www.haskell.org/haskellwiki/IO_Semantics
16:51:32 <vixey> I don't care much about how say GHC does it in practice .. but how any implementation could work
16:51:59 <ddarius> Indeed.  You can only know how IO works conceptually.
16:52:12 <Saizan_> the nasty thing is lazy IO / concurrency
16:52:19 <Cale> How GHC does it in practice is that it cheats horribly.
16:52:49 <Cale> But you don't need to know that :)
16:52:58 <ddarius> Why did hbc have to die?
16:53:44 <ddarius> hbc is like Haskell's Lisp Machines.
16:54:09 <Cale> Too bad Lennart isn't here to tell us why ;)
16:54:30 <roconnor> Any good representations for concurrent semantics?
16:54:35 <Saizan_> it didn't cheat?
16:54:36 <mauke> preflex: seen augustss
16:54:36 <preflex>  augustss was last seen on #haskell 6 days, 23 hours, 42 minutes and 27 seconds ago, saying: There should have been a 'bool' function
16:54:42 <gwern> how was hbc like haskell's lisp machines?
16:55:32 <ddarius> It is something that is built up as being better in it's hey-day than anything even now accomplished.
16:55:58 <Cale> The reason hbc died was that it was just too good for Haskell 98. ;)
16:56:00 <gwern> hm. what could hbc do that ghc doesn't?
16:56:13 <ddarius> Cale: Proving my point even more.
16:56:24 <gwern> (ghc always seemed pretty capable to me)
16:56:55 <Cale> The current version is 0.9999.4.
17:00:44 <gwern> @check \x -> x == x
17:00:47 <lambdabot>  OK, passed 500 tests.
17:01:03 <gwern> hm. confusing. why does it work in lambdabot and not mueval...
17:01:09 <vixey> @check 1 + 1 == 2
17:01:09 <chrisdone> @check join (==)
17:01:10 <lambdabot>  OK, passed 500 tests.
17:01:10 <lambdabot>  OK, passed 500 tests.
17:01:16 <mauke> extended defaulting?
17:01:32 <mauke> @check (==)
17:01:33 <lambdabot>  OK, passed 500 tests.
17:01:45 <gwern> but 1 + 1 == 2 works in mueval
17:01:53 <gwern> mauke: what is this extended defaulting you speak of?
17:01:58 <hackage> Uploaded to hackage: mueval 0.4.6
17:02:36 <ddarius> gwern: If I'm not mistaken, hbc has free existentials.  It's interactive mode can accept all of the language it supports, and it produces reasonably fast code outperforming GHC upon occassion.
17:03:10 <gwern> ddarius: ..how could hbc outperform ghc? (for that matter, I thought hbc has been broken for years, how could they be compared?)
17:03:37 <ddarius> gwern: There is an hbc that accepts Haskell 98.
17:04:34 <ddarius> hbc is probably still under development.  Just very, very quietly.
17:05:19 <gwern> so quietly I've never heard of it :)
17:05:30 <ddarius> gwern: It happened to me.
17:06:04 <ddarius> gwern: Several years ago I thought hbc was dead and had been dead for years, then I was surprised by an announcement for a Haskell 98 supporting version of hbc.
17:06:20 <ddarius> I thought hbc was dead for at least a couple of years.
17:06:31 <gwern> heh. 'It came - from the depths!'
17:06:40 <ddarius> Indeed.
17:07:13 <chrisdone> that is not dead which eternal lies
17:07:35 <Shiruka> it's like that with many things.. you think that amiga is dead, and then you .. oh! amiga _is_ dead. OK, freebsd then!
17:08:16 <Botje> hbc is not dead, it's resting
17:08:40 <nornagon> @index ($!)
17:08:41 <lambdabot> Prelude
17:08:42 <ddarius> hbc is perfectly poised to be the first implementation supporting Haskell'
17:08:46 <nornagon> :t ($!)
17:08:48 <chrisdone> Botje: lovely plumage
17:08:49 <lambdabot> forall a b. (a -> b) -> a -> b
17:08:53 <Botje> :)
17:08:54 <nornagon> @src ($!)
17:08:54 <lambdabot> f $! x = x `seq` f x
17:09:22 * vixey wishes people would design other languages than haskell' ...
17:09:42 <ddarius> vixey: Your wish is granted.
17:09:48 <ddarius> Pick a harder one next time.
17:10:02 <Botje> s/other/better/
17:10:22 <chrisdone> ddarius: it's not like one of those miscontrued grantings, is it?
17:10:46 <ddarius> chrisdone: No.  There are plenty of people right at this very moment designing languages other than Haskell'.
17:11:29 <vixey> ddarius: I wish there was something meaningful I could use my life to achieve...
17:11:58 <Saizan_> vixey: join hbc or ghc developement toward haskell''
17:12:35 <ddarius> vixey: You're in luck!  You could easily make a significant difference in many children's lives through a whole variety of means.
17:12:36 <chrisdone> so, when's haskell' out?
17:12:45 <carl> is there a haskell equivelent for #define right now im defining things as "x = fromIntegral 123"
17:12:51 <ddarius> chrisdone: November 2006
17:12:59 <Cale> carl: what's wrong with that?
17:13:09 <chrisdone> ddarius: needs more jiggawatts?
17:13:12 <ddarius> Except x = 123 is essentially equivalent.
17:13:15 <Cale> carl: btw, that fromIntegral is unnecessary...
17:13:24 <bd_> x :: Num a => a
17:13:25 <carl> well ok lol
17:13:25 <bd_> x = 123
17:14:49 <Cale> carl: numeric literals are automatically expanded into appropriate calls to fromInteger or fromRational
17:15:05 <ddarius> > 1 :: Double
17:15:08 <ddarius> > 1 :: Int
17:15:12 <lambdabot>  1
17:15:12 <lambdabot>  1.0
17:15:12 <ddarius> > 1 :: Rational
17:15:13 <lambdabot>  1%1
17:15:34 <Cale> > 1 :: CReal
17:15:35 <lambdabot>  1.0
17:15:49 <bd_> > 1 :: Complex CReal
17:15:51 <lambdabot>  1.0 :+ 0.0
17:16:24 <vixey> > 1 :: Complex (Ratio Integer)
17:16:25 <lambdabot>        add an instance declaration for (RealFloat (Ratio Integer))
17:16:25 <lambdabot>     In the...
17:16:50 <ddarius> preflex: seen shapr
17:16:50 <preflex>  shapr was last seen on #haskell-blah 1 day, 23 hours, 17 minutes and 55 seconds ago, saying: bbl
17:17:07 <Shiruka> ah, modern documentation tools have apparently spoiled me
17:17:28 <Cale> Shiruka: what?
17:17:28 <Shiruka> if you browse the html docs for libraries, there's the nice link "source code" you can click to get syntax highlighted source
17:17:36 <Cale> yep
17:17:51 <Shiruka> I went to ghc user documentation and searched for a similar button there, then had to laugh at myself :-D
17:18:05 <Cale> In the Hackage documentation, this is nowhere to be found either.
17:18:19 <Shiruka> yeah, too bad
17:18:29 <Cale> (and that's kind of inexcusable, given that it's the same tool which generates the documentation)
17:19:11 <erikc> yea, i quite like that source link, especially after having to deal with closed source nonsense all day
17:20:06 * Shiruka settles on using emacs on a darcs checkout of ghc :-)
17:20:50 <O_4> Gah, how do I actually find stuff in the hackage docs?
17:21:06 <O_4> I just want to know how to glEnable(GL_BLEND) in haskell!!
17:21:19 <chrisdone> @hoogle blend
17:21:20 <lambdabot> No matches found
17:21:28 <vixey> using HOpenGL ?
17:21:31 <O_4> Yes
17:21:51 <O_4> @hoogle enable
17:21:51 <lambdabot> No matches found
17:22:13 <vixey> ?docs OpenGL
17:22:13 <lambdabot> OpenGL not available
17:22:19 <Shiruka> wow
17:22:24 <luqui> chrisdone, blend $= True ?
17:22:27 <Shiruka> there are more .lhs files in ghc sources than .hs files
17:22:42 <Cale> yep :)
17:22:44 <luqui> chrisdone, docs are in G.R.OpenGL.GL.PerFragment
17:23:10 <chrisdone> luqui: thanks but I was searching on behalf of O_4
17:23:13 <codacola> horrible, its a haskell day
17:23:16 <luqui> (I used hayoo++ to find it)
17:23:23 <luqui> oh, right, that's who I meant to reply to
17:23:41 <O_4> Ah, blend $= Enabled works
17:24:26 <Shiruka> hayoo.. fast? :-)
17:24:26 <vixey> codacola: What does that mean
17:24:33 <O_4> Those docs really need a good search tool... :-p
17:24:59 <luqui> my biggest complaint about hopengl is the doc organization
17:25:21 <O_4> It's really hard to navigate :-/
17:25:21 <luqui> I guess that's related to the pseudo-abstraction it attempts
17:25:30 <luqui> I would prefer just IO bindings to every opengl function
17:25:33 <Shiruka> ("hayoo" = dialectic/old japanese for "fast(er)" :-)
17:25:54 <luqui> Shiruka, thanks for explaining :-)
17:26:30 <luqui> in particular I've been bitten by renderPrimitive's style (doesn't interact well with monad transformers)
17:26:40 <Cale> æ©ã
17:26:45 <luqui> and would prefer GL.begin and GL.end...
17:27:48 <Saizan_> yeah, tranformers + callbacks == madness
17:27:52 <O_4> Well, begin/end is a bit ugly, but renderPrimitive is a bit inconvenient
17:28:08 <O_4> But you shouldn't usually be using immediate mode anyway :-p
17:28:15 <Saizan_> we should sort that out at a library level..
17:28:16 <luqui> says you
17:28:24 <O_4> Says me, indeed.
17:28:34 <O_4> I'm using it right now anyway so I can't talk.
17:29:06 * luqui uses opengl because I can quickly get graphics on the screen
17:29:11 <luqui> s/I/he/
17:29:41 <luqui> and it's easier to use immediate than any other alternative (without some infrastructure)
17:29:47 <Cale> Shiruka: or is it really æ©ã, and it's too old for my dictionary? Silly romanisations and their o/u confusion :)
17:30:05 <Shiruka> no, æ©ã :-)
17:30:15 <luqui> Saizan_, what do you mean "we should sort that out at a library level"?
17:30:21 <O_4> luqui: yeah, immediate mode certainly is easier to start with
17:31:58 <Cale> ãæ©ããããã¾ã
17:32:15 <chrisdone> Â·âÂ·
17:34:09 <luqui> looks like a stuffed hippo
17:34:23 <Shiruka> haha
17:35:12 <ddarius> Having fun Cale?
17:36:50 <Shiruka> funny, looks like hayoo is a common typo of yahoo
17:37:16 <Shiruka> I didn't even notice the similarity before googling..
17:37:25 <chrisdone> spoonerism
17:37:27 <vixey> ddarius  do you have a site ?
17:38:29 <Shiruka> should've guessed, as hoogle is from google too
17:38:53 <Shiruka> but how am I supposed to remember that yahoo has a search engine (if it still has that) :-)
17:39:06 <luqui> although if you want to go with the typo theme, it should have been hoohlr
17:39:11 <luqui> or hpph;e
17:39:44 <vixey> hpph;e is catchy
17:40:06 <chrisdone> heh
17:40:21 <shepheb> pronounced "hippie"?
17:40:25 <chrisdone> kashell
17:40:42 <Shiruka> pronounced "hpphprphph" (*the listener wipes his face*)
17:41:02 <ShockSMX> hmm, so, i'd like to learn haskell. i drift in and out, but i haven't gotten far yet.
17:41:16 <codacola> vixey: means ill be writing haskell all day
17:41:17 <ShockSMX> i don't need a tutorial or a book, i need the equivalent of some homework assignments
17:41:21 <ShockSMX> anyone have any suggestions?
17:41:32 <chrisdone> http://projecteuler.net
17:41:32 <ddarius> vixey: No.
17:41:36 <lambdabot> Title: Project Euler
17:41:38 <luqui> ShockSMX, what do you like to program?
17:41:39 <Shiruka> chrisdone: dang, you were faster
17:42:03 <ShockSMX> luqui: traditionally, i'm a web guy. but that doesn't matter. i could do some project euler stuff, i guess.
17:42:11 <vixey> codacola.... that sounds fun
17:42:27 <ShockSMX> luqui: what are the potential categories you have in mind
17:42:40 <shepheb> PE has stopped being an effective Haskell practice ground for me. now it's three days of pondering the math and an hour of coding, repeat.
17:42:42 <ddarius> ShockSMX: Many of the bigger tutorials have exercises included.
17:42:57 <ShockSMX> ddarius: oh yeah? like what?
17:43:11 <ShockSMX> does the haskell wiki have any?
17:43:18 <ddarius> @where yaht -- I believe.  I haven't looked at YAHT in years.
17:43:18 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
17:43:32 <luqui> ShockSMX, mostly I suggest writing something you'll enjoy writing.  That's how I learn the best at least :-)  So I was trying to get a sense of that.
17:43:33 <chrisdone> it's pretty sad if you can't think of any problems to work on
17:44:10 <ShockSMX> luqui: yeah, and that'd wind up being web stuff. i want to pick up some basics first so i know how to approach bigger things ever so slightly better. i know it'll be lots of rewrites anyway.
17:44:36 <luqui> ShockSMX, but haskell's strength is algorithms, not glue, so web was kind of a miss (not that it can't do it, but it gets more abstract before it gets better :-)
17:45:04 <ShockSMX> is this any good? http://www.amazon.com/dp/0201342758/
17:45:13 <ShockSMX> luqui: yeah, that's what i'm thinking
17:45:25 <Shiruka> shepheb: ah, for me it's often "think some, code a bit, notice it's too slow, try every trick in the dons's collected haskell sources, notice that it wouldn't be fast enough even in asm, think a bit more, code a better algorithm"
17:45:37 <ddarius> luqui: You are going to invite the wrath of dons now.
17:45:38 <ShockSMX> or is YAHT the definitive starting point?
17:45:55 <ShockSMX> i'll check some exercises in yaht
17:45:57 <ddarius> ShockSMX: I don't like YAHT, but a lot of people do.
17:46:01 <shepheb> Shiruka: yeah, I've recently had the "dammit, it's not fast enough" after days on pondering. now I need an even better algorithm
17:46:04 <ShockSMX> what do you like, ddarius
17:46:07 <ddarius> There are others that have exercises too.
17:46:28 <ddarius> ShockSMX: I couldn't really tell you.  Most of the big tutorials weren't around when I started learning Haskell.
17:46:28 <ShockSMX> because, like, if you don't like anything... it doesn't help me
17:46:41 <ShockSMX> heh, ok. that's what i guessed you'd say
17:46:50 <codacola> ShockSMX: thats the book ive got
17:47:01 <ShockSMX> codacola: any good/
17:47:06 <Shiruka> ShockSMX: write a monad tutorial
17:47:09 <ddarius> Several of the books are popular and I imagine they all have some exercises.
17:47:16 <ShockSMX> Shiruka: as an exercise?
17:47:21 <ShockSMX> ...
17:47:24 <Shiruka> I'm just kidding :-)
17:47:30 <ShockSMX> it'd be a tough start, heh
17:47:47 <ShockSMX> i wanna avoid monads until i have some other stuff figured out
17:47:48 <gwern> hopengl is fine. but - WILL IT BLEND?
17:47:52 <codacola> ShockSMX: i dont like how it starts out.  basicly gotta skip chapter 2. after that its pretty good
17:48:02 <ShockSMX> codacola: thanks
17:48:04 <vixey> lol
17:48:14 <Cale> ShockSMX: good way to start... in fact, monads are more a library structuring thing than something you need to know right away
17:48:18 <gwern> ShockSMX: the joke is on you: you can't, as even List is a monad!
17:48:27 <gwern> (bwa ha ha ha)
17:48:30 <codacola> though it seems to have like 5 pages on monads at the very end of the book
17:48:51 <ShockSMX> gwern: i bet using monads is way easier than defining new ones
17:49:03 <Twey> It's a lie
17:49:05 <Shiruka> the lits monad is a good monad to start with though
17:49:10 <Twey> Defining monads is easy
17:49:11 <Cale> ShockSMX: however, it seems that many people when they figure out what monads are about, it seems that they feel compelled to write a tutorial
17:49:20 <ShockSMX> heh
17:49:23 <meltingwax> figuring GLFW-0.3...
17:49:28 <meltingwax> Sfiguring GLFW-0.3...
17:49:32 <ShockSMX> so i'm sure there's a wealth of tutorials waiting to be read
17:49:32 <gwern> ShockSMX: I'll bet I can use 100 monads
17:49:38 <Twey> Cale: That's because they go 'oh crap, it's taken me three months to figure this out, I must be able to explain it better'
17:49:46 <ShockSMX> gwern: sir, you have yourself a bet
17:49:59 <O_4> Clifford attractors in Haskell: http://hpaste.org/9166
17:50:06 <O_4> Thanks for the help guys :-)
17:50:10 <Cale> gwern: in the same module for a reasonable goal?
17:50:18 <gwern> ShockSMX: sry, that was a bad injoke from reddit
17:50:29 <ShockSMX> eh, i don't run with reddit
17:50:34 <ShockSMX> sounds juvenile
17:50:41 <O_4> I'm really gonna have to find a better way to pass state around, though...
17:50:57 <gwern> most injokes sound juvenile from the outside
17:51:01 <ShockSMX> yeah
17:51:15 <Shiruka> with sufficient indignation, anything can be considered juvenile
17:51:17 <codacola> ShockSMX: btw the reason i dont like the first chapter is that it throws all of these functions at you though no syntax has actually been covered yet, so i skipped to chapter 2 (first script) and came back to chapter one after about 5 chapters
17:54:01 <dogbite> Cale: thanks again for the help earlier.  now i understand memoization... and really lazy eval.. better in haskell
17:58:16 <drguildo> write a new programming language
17:58:38 <O_4> drguildo: who?
17:58:44 <drguildo> ShockSMX
17:59:59 <ShockSMX> yo
18:00:30 <gwern> @check \_ -> 1+1==2
18:00:31 <lambdabot>  OK, passed 500 tests.
18:01:28 <drguildo> and that statement about haskell and web stuff was strange
18:01:39 <ShockSMX> what in particular
18:01:47 <gwern> @check \x -> x == x
18:01:47 <lambdabot>  OK, passed 500 tests.
18:02:02 <drguildo> it works just great for "web stuff"
18:02:44 <drguildo> actually that statement was a double whammy of strange
18:02:54 <ShockSMX> okay. point is, luqui might have been right about web stuff being mostly glue, and i'd like to expose myself to the algorithmic stuff first
18:03:04 <drguildo> "haskell's strength is algorithms"
18:03:04 <ShockSMX> well, explain
18:03:11 <drguildo> i.e. haskell's strength is computer programs :-)
18:03:15 <ShockSMX> heh
18:03:17 <ShockSMX> alright
18:03:28 <drguildo> i'm writing a jabber bot in haskell
18:03:40 <drguildo> i'm completely new to haskell
18:03:44 <drguildo> and functional programming
18:03:47 <drguildo> and it's going great
18:04:11 <drguildo> i can actually understand the xml parsing code in the xmpp library as well
18:04:16 <Shiruka> what statement?-)
18:04:30 <drguildo> <luqui> ShockSMX, but haskell's strength is algorithms, not glue, so web was kind of a miss (not that it can't do it, but it gets more abstract before it gets better :-)
18:06:44 <drguildo> write an abstract algorithm for gluing stuff together
18:06:56 <drguildo> a glue monad
18:06:57 <Shiruka> I haven't done any web stuff with haskell, but it doesn't strike me as a strong area of haskell
18:07:24 <Shiruka> I mean, with web apps you want a lot of other people writing you tools for writing web apps
18:07:32 <drguildo> that's a library thing though, isn't it?
18:07:34 <Shiruka> tools suchas RoR or django
18:07:45 <drguildo> not a flaw in the language
18:07:46 <chrisdone> um, happs
18:07:54 <drguildo> yeah
18:08:00 <drguildo> i've never used happs though so couldn't say
18:08:20 <geezusfreeek> i have started. it has quite the learning curve, but so far i love it
18:08:20 <vixey> all I want is to be able to mix code and XML/HTML effortlessly and be able to edit both while the site is running
18:08:29 <Shiruka> me neither, I'm just using a "more people are working on it" general argument :-)
18:08:43 <vixey> I can't realy think what else anybody would want
18:09:09 <chrisdone> sessions
18:09:32 <drguildo> this
18:09:33 <drguildo> is
18:09:40 <drguildo> zombo cooooooommmmmm
18:09:47 <Shiruka> vixey: code edits immediately affecting how the server works?
18:10:13 <vixey> yes
18:10:22 <drguildo> make a haskell version of zombo.com
18:10:28 <drguildo> with happs
18:10:38 <Shiruka> I mean, program code edits, not just xml/html
18:10:39 <chrisdone> maybe hint could do the livecoding part
18:10:51 <vixey> yes
18:11:13 <Shiruka> hmm, sounds interesting.. maybe I should take a look how that's implemented :-)
18:12:09 <Shiruka> (time-wise dangerous way of thinking - the same thought pattern is why I'm looking at ghc sources now..)
18:12:46 <drguildo> that's what time is for
18:12:55 <drguildo> otherwise it'd be useless
18:12:58 <drguildo> useless i tells ya
18:13:18 <chrisdone> who needs time when you can be lazy
18:14:40 <codacola> i like chrisdone's way of thinking
18:14:43 <chrisdone> I actually just installed Ruby on Rails for this teaching reddit thing I want to write. have to learn ruby for a job, otherwise I'd try happs
18:17:50 <shepheb> in your ~/.xmonad/xmonad.hs, you can customize what layouts you have
18:17:53 <shepheb> mischan, argh
18:18:25 <codacola> oh yeah
18:18:29 <codacola> i wanted to install linux today
18:19:18 <codacola> now ive just gotta work out where id buy cds
18:19:19 <Shiruka> heh, descriptive error messages
18:19:24 <Shiruka> unpackCString# a = error "urk"
18:19:58 <chrisdone> > error "pc load letter"
18:20:00 <lambdabot>  Exception: pc load letter
18:20:08 <mar77a> > undefined
18:20:19 <lambdabot>  Exception: Prelude.undefined
18:22:25 <drguildo> > error "lp0 on fire"
18:22:26 <lambdabot>  Exception: lp0 on fire
18:27:12 <Elly> codacola: buy CDs? o_O
18:27:46 <codacola> Elly: yeah, im new to this city, so still not sure where i should buy certain things :P
18:27:56 <Elly> you mean blanks, right?
18:27:57 <codacola> no car = best store is the closest store
18:28:00 <codacola> yeah
18:28:12 <Elly> well, if you're running windows right now, Wubi might work
18:28:17 <Elly> (disclaimer: I have never tried it)
18:29:33 <codacola> Wubi does not require you to modify the partitions of your PC <- does it install it entirely on the current partition?
18:30:24 <Elly> it installs to a file, I believe
18:30:37 <Elly> it's relatively new software
18:30:45 <Elly> but if you are just looking to try linux, it might be good
18:31:57 <codacola> no, i usualy use debian. though i will be installing ubuntu this time.
18:32:05 <drguildo> try not
18:32:09 <drguildo> do, or do not
18:32:11 <drguildo> there is no try
18:33:26 <dons> dcoutts: google for 'haskell sparc' :)
18:35:21 <codacola> Elly: didnt want to reinstall debian on here since i dont have a "real" vista dvd. but seems im allowed a free copy from the university, so dont have to wrory about the hp setup stuff anymore
18:35:42 <codacola> im not even sure if i can use the hp backup cds if i remove the backup partition
18:39:55 <gnut> is there any advantage to using a list as opposed to Data.IntMap?
18:40:06 <gnut> it seems to be that they do the same things, but with IntMap being faster...??? no?
18:40:45 <olsner> well, the subtle differences are always subtle...
18:41:21 <olsner> and what's isomorphic in theory is not always isomorphic in practice
18:41:25 <gnut> yes... what are the subtle differences?
18:42:46 <olsner> well, slightly below my threshold of subtlety I guess :P ... (PS: I'm mostly drunk and fooling around)
18:43:09 <gnut> always good to be thinking about Haskell then.
18:43:42 <olsner> yes, it is always good to be thinking in/about haskell :D
18:44:05 <dons> gnut: they have wildly different complexity for indexing.
18:45:06 <dons> patricia trees vs lists, and all.
18:45:12 <vixey> :t foldM
18:45:12 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
18:45:15 <dons> much faster for insertion as well.
18:45:39 <dons> hey, there you go, it was an andyjgill paper, http://citeseer.ist.psu.edu/okasaki98fast.html
18:46:01 <gnut> thanks
18:46:24 <gnut> enumerating I suppose is faster with lists
18:46:33 <gnut> in order, that is.
18:46:56 <dons> well, if the list is already in order
18:47:01 <dons> versus flattening to a list.
18:50:42 <vixey> you know this
18:50:48 <vixey> > filter (\x -> odd x || x == 2) [1,2,3,4,5]
18:50:49 <lambdabot>  [1,2,3,5]
18:50:58 <dons> dcoutts: awesome, http://blogs.sun.com/darren/entry/t5120_donated_to_haskell_community
18:51:04 <vixey> is there some operater which you can write  odd @ (==2)  ?
18:51:06 <dons> byorgey: might even be HWN worthy
18:51:08 <codacola> hm, i wonder if a 40 gig partition would be big enough for my linux install
18:51:21 <dons> codacola: i hope so!
18:51:29 <vixey> like liftA2 (||)
18:51:38 <vixey> except an operator...
18:51:52 <drguildo> my main os partition is only 4GB
18:52:03 <vixey> I don't thin there is
18:52:35 <drguildo> that main was extraneous
18:52:47 <Saizan_> gnut: a list has O(1) insertion/indexing at the head, and it can be efficiently used as a control structure thanks to deforestation
18:53:39 <pejo> dons, heh - Darren Moffat is a glasgow alumni?
18:54:16 <gnut> Saizan_: ah... thanks.
18:54:52 <dons> pejo: apparently!
18:55:10 <Shiruka> if list were implemented as an IntMap, how would you implement (:) without evaluating the arguments and still do tail sharing like lists can?
18:58:33 <Shiruka> with tail sharing you'd need to keep the indices in the tail constant, so you'd have to add the head with index one less than the least in the tail.. but what if the tail is again implemented using (:), and is infinite? :-|
18:59:16 <dons> going to be hard to keep it balanced
19:13:53 <vixey> what's better
19:14:00 <vixey> do guard foo ; bar
19:14:05 <vixey> or, guard foo >> bar ?
19:14:55 <Shiruka> the latter has less characters, so it must be better
19:15:18 <steven_ashley> hey dudes, is there a function like fmodf in haskell?
19:15:25 <steven_ashley> doing gcj ;)
19:15:37 <dolio> What's fmodf?
19:15:43 <steven_ashley> modulo for doubles
19:15:52 <dolio> :t mod'
19:15:53 <lambdabot> forall a. (Real a) => a -> a -> a
19:16:16 <steven_ashley> :t mod
19:16:16 <lambdabot> forall a. (Integral a) => a -> a -> a
19:16:19 <steven_ashley> ahh
19:16:33 <steven_ashley> :info mod'
19:16:36 <steven_ashley> hmm
19:16:38 <steven_ashley> where is it?
19:16:45 <dolio> Data.Fixed
19:16:49 <steven_ashley> cheers :)
19:16:55 <codacola> ugh, unsure if i should go get a cd or not
19:17:02 <vixey> what operator do you use for zip ?
19:17:14 <Shiruka> `mod'` looks funny :-)
19:17:19 <MyCatVerbs> vixey: `zip` :)
19:17:43 <vixey> I meant an operator
19:17:58 <MyCatVerbs> That is.
19:17:59 <jeffwheeler> vixey: what are you trying to do?
19:18:13 <MyCatVerbs> Well, it's infix, anyway. Good enough for me.
19:18:15 <vixey> find on operator that people use for zip
19:18:38 <Shiruka> a-ha, haskell library docs are hiding modules from me :-O
19:18:56 <MyCatVerbs> I'd use something like \/, but that's just me.
19:19:22 <Shiruka> must be important secrets in these GHC.IO, Base, IOBase modules
19:19:53 <MyCatVerbs> Shiruka: yes, they're full of the code that makes your primitives work.
19:20:20 <MyCatVerbs> Shiruka: if you want to read it, you'll want to download GHC's source and look in libraries/base/.
19:20:33 <Shiruka> I'm browsing the darcs repo :-)
19:20:51 <Shiruka> I wanted to see how IO is Really Implemented(TM)
19:21:10 <jeffwheeler> Shiruka: be sure to share, if you find anything interesting :)
19:22:12 <Shiruka> at least I found out that ghc really does operate on RealWorld :-)
19:22:13 <MyCatVerbs> Shiruka: oh, for *that* have a look at ghc-core's output for any program which does IO. :)
19:22:19 <MyCatVerbs> Shiruka: indeed.
19:23:13 <Saizan_> @src IO >>=
19:23:13 <Shiruka> heh, I've actually looked at many of those, but never the IO bits.. I've jumped directly to the code I'm optimizing to see how it looks :-)
19:23:13 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
19:23:19 <Saizan_> @src >>= IO
19:23:19 <lambdabot> Source not found. Take a stress pill and think things over.
19:23:58 <Shiruka> (or actually raw ghc core output, I didn't know about ghc-core helper until quite recently)
19:24:20 <dolio> @src IO (>>=)
19:24:21 <lambdabot> m >>= k     = bindIO m k
19:24:47 <Saizan_> ah, evil
19:25:16 <Shiruka> I also found out that they lied to me about list implementation in some tutorial I read ages ago
19:25:34 <Saizan_> how?
19:25:35 <ahunter1> > printf "foo\n"
19:25:36 <lambdabot>  Add a type signature
19:26:00 <Shiruka> IIRC the tutorial said that "lists could be implemented using data [] .. etc if it were legal syntax, but really they aren't" or something like that
19:26:06 <Shiruka> but they _are_ implemented that way :-O
19:26:19 <dolio> They aren't legal Haskell 98.
19:28:24 <Shiruka> somehow I doubt it's even legal in GHC outside GHC internals :-)
19:29:59 <dolio> Yeah.
19:30:03 <Shiruka> but still, in GHC/Base.lhs there's the nice definition data [] a = [] | a : [a]
19:30:40 <dolio> Even with -fglasgow-exts ghci yells at me.
19:31:16 <Shiruka> maybe there's an undocumented flag for Base.lhs, -fdeep-glorious-mysteries or something
19:32:22 <dolio> Even GHC.Base just has -fno-implicit-prelude.
19:32:56 <dolio> So GHC must special case that module or something.
19:32:59 <vixey> :t liftA2 (||) (const True) (const False)
19:33:00 <lambdabot> forall b. b -> Bool
19:33:15 <vixey> @hoogle (b -> Bool) -> (b -> Bool) -> (b -> Bool)
19:33:15 <lambdabot> No matches, try a more general search
19:33:53 <vixey> (^||^) = liftA2 (||)  -- is this ok ?
19:34:23 <Shiruka> looks like a weird smiley
19:34:37 <vixey> what operator should I use?
19:36:05 <Saizan_> <||>?
19:36:21 <vixey> oh ok
19:37:01 <Shiruka> (^||^) = vixey hiding behind a pole, <||> = saizan hiding behind a pole, <^||^> = saizan after taking a step backwards
19:37:35 <carl> what would be the closest equivelent to a haskell vector perferably with a constant append time
19:37:48 <Twey> :t printf
19:37:49 <lambdabot> forall r. (PrintfType r) => String -> r
19:38:10 <Twey> @src printf
19:38:10 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
19:38:16 <Twey> :<
19:38:28 * Twey wonders quite how that works.
19:38:33 <dmwit> carl: Lists have a constant prepend time.
19:38:45 <dmwit> ?source Text.Printf
19:38:45 <lambdabot> http://darcs.haskell.org/packages/base/Text/Printf.hs
19:38:59 <Twey> Ooh, thanks
19:39:07 <dmwit> Twey: Via the magic of typeclasses and run-time errors.
19:39:50 <Shiruka> carl: haskell vector?
19:40:11 <Twey> Implementation not visible :-(
19:40:13 <Shiruka> if you just want dynamic arrays, then arrayref has those
19:40:15 <Twey> Yeah.  Seems so.
19:40:21 <Shiruka> http://haskell.org/haskellwiki/Library/ArrayRef
19:40:28 * Twey would probably just use a list...
19:40:45 <Twey> I guess there's no currying with a list.
19:40:59 <vixey> I am not allowed to use â¢ as an operator in haskell?
19:41:16 * rwbarton wanted to use ââ :(
19:41:58 <dolio> Is UnicodeSyntax on?
19:42:15 <Shiruka> there's such a thing? :-O
19:42:23 <dolio> Yes.
19:42:29 <vixey> I put it on now, but that didn't make a difference
19:42:39 <vixey> just says lexical error at character '\8226'
19:42:54 <dolio> I don't know how it decides what's punctuation and so on.
19:42:56 <geezusfreeek> perhaps it is a "letter"?
19:42:59 <dolio> Or what it allows, really.
19:43:00 <rwbarton> {-# LANGUAGE UnicodeSyntax #-}? Yeah, no effect
19:43:07 * vixey uses â instead...
19:43:25 * geezusfreeek really needs to find an easy way to insert unicode in emacs
19:43:45 <Shiruka> clearly then a new proposal is needed for Unicode Consortium to add heaps and heaps of new for-Haskell-use operators which nobody has yet ever seen to make the most of UnicodeSyntax :->
19:43:48 <rwbarton> I only know a hard way... M-x ucs-insert if you know the hex value
19:44:04 <geezusfreeek> ew
19:44:34 <geezusfreeek> maybe i could just go with a more os x native editor so i can use some of the handy option key shortcuts
19:44:35 <rwbarton> probably worse than google + copy & paste
19:44:40 <geezusfreeek> or i could use a character chooser
19:44:42 <dolio> quail works passably.
19:45:04 <dolio> You can type most stuff you'd want in haskell via its latex name.
19:45:17 <geezusfreeek> ah that sounds somewhat handy
19:46:03 <vixey>         cannot mix `(?)' [infix 7] and `(?)' [infix 7] in the same infix expression
19:46:05 <vixey> ... ...
19:46:23 <dolio> Sub/superscript numbers (and some letters) too, but I don't know if would like those.
19:46:45 <dolio> Is it actually "infix"?
19:46:52 <dolio> If so, that probably doesn't declare which way it should associate.
19:46:55 <geezusfreeek> hmm, it appears that i can just use os x's character palette
19:47:02 <geezusfreeek> should work fine i suppose
19:48:05 <rwbarton> I'm guessing vixey would like to actually see the operator in question
19:49:29 <codacola> what interperter does everyone recommend for linux?
19:50:01 <Shiruka> ghci?
19:50:20 <Draconx> hm, with 6.6 billion people in this world, it's unlikely that there is one intepreter that every single one of them recommends.
19:50:46 <vixey> everyone recommends ghc
19:50:59 <dolio> Ruby.
19:51:10 <Shiruka> I haven't actually tried others, but given that I gratuitously use ghc extensions left and right, I doubt anything else works..
19:52:02 <rwbarton> ld-linux.so.2 is pretty popular
19:52:36 <Shiruka> ah, but none of these interpret linux itself.. how about bochs or qemu?
19:54:53 <codacola> ok, ill rephrase, for haskell
19:55:03 <codacola> to be run in linux
19:55:46 <jeffwheeler> codacola: /most/ people use GHCi, I think
19:56:27 <vixey> @pl \s (p,q) -> (p * q) s
19:56:28 <lambdabot> (`ap` snd) . (. fst) . flip (flip . (*))
19:56:46 <Shiruka> ghci could do a bit better in the user-friendliness department, but it has all the features of ghc so..
19:57:20 <jeffwheeler> Y'know . . . if HUGS and Happy didn't pick silly names, they'd probably be way more popular.
19:57:47 * CosmicRay thinks hugs is a fine name
19:58:05 <Shiruka> happy? I thought it's a parser generator, not an interpreter
19:58:05 <CosmicRay> I keep wanting to invent a library named kisses.
19:58:22 <jeffwheeler> Shiruka: It is; I was just giving names of things with cheesy names
19:58:31 <Shiruka> oh, ic
19:58:47 <codacola> heh, im using winhugs at the moment
19:58:53 <Shiruka> fwiw, I never thought of HUGS except as a meaningless acronym standing for something I don't know :-)
19:59:27 <Shiruka> +some words to make that grammatical..
20:00:14 <jeffwheeler> Heh. I always think they're silly, and go for things like Glasgow Haskell Compiler (which, btw, sounds _really_ cool)
20:00:58 <jeffwheeler> Fortunately for me, he one with the awesome name was also the more popular.
20:00:59 <Shiruka> and almost makes you think it is GNU Haskell Compiler
20:01:08 <jeffwheeler> s/he/the
20:02:09 <codacola> wow, my ghc install on here is 480mb
20:03:26 <Shiruka> hm.. is there always only one thread in the GHC RTS even with -N (n>1) if you don't manually start any extra ones yourself, except for parallel GC?
20:06:11 <ddarius> Haskell User's Gofer System.
20:06:52 <Shiruka> Gopher?
20:07:32 <ddarius> @where gofer
20:07:32 <lambdabot> http://www.cse.ogi.edu/~mpj/goferarc/
20:09:13 <chessguy> dead link
20:09:50 <Shiruka> gofer, implemented in P.G.'s Arc? ;-P
20:10:48 <funktio> @pl \x -> f (g x) (h x)
20:10:48 <lambdabot> liftM2 f g h
20:11:07 <Twey> Haha
20:11:17 <funktio> cool
20:11:21 <vixey> it really sucks how ``'s are at the top precedence
20:12:28 <chessguy> wasn't gofer an old www-via-email program?
20:15:19 <Shiruka> sounds like a painful way to browse the web
20:15:44 <steven_ashley> haskell got 4th on google code jam :)
20:16:17 <steven_ashley> I got 220nd of 2394 (top 840 advance)
20:17:20 <chessguy> steven_ashley: nice. what was the problem?
20:17:31 <chessguy> err, problems, i guess
20:17:51 <jeffwheeler> chessguy: you can browse them without participating
20:18:03 <chessguy> yeah, but i'm lazy
20:18:08 <steven_ashley> ahh
20:18:14 <ddarius> gopher is a protocol http://www.complete.org/
20:18:14 <lambdabot> Title: Complete.Org
20:18:26 <ddarius> Gofer was a Haskell-like research language.
20:18:37 <chessguy> oh, different spelling
20:18:51 <steven_ashley> first one you were given two vectors and you had to reorder them such that the dot product was minimal
20:19:22 <chessguy> how big were the vectors?
20:19:31 <heatsink> pejo++
20:19:31 <steven_ashley> 1000 I think
20:19:35 <steven_ashley> up to anyway
20:19:38 <chessguy> oh
20:19:45 <chessguy> interesting
20:19:51 <heatsink> @karma pejo
20:19:52 <lambdabot> pejo has a karma of 1
20:19:52 <steven_ashley> dont brute force it ;)
20:19:58 <steven_ashley> you sort one vector
20:20:03 <steven_ashley> and reverse sort the other ;)
20:20:16 <ddarius> > product [2..1000]
20:20:18 <lambdabot>  4023872600770937735437024339230039857193748642107146325437999104299385123986...
20:21:00 <steven_ashley> question 2 was making batches of milkshake to keep customers happy
20:21:03 <Armored_Azrael> Is there currently a serialize/deserialize typeclass setup to be derivable from read/show?
20:21:31 <steven_ashley> the customers like a set of milkshakes, only one has to be in stock to keep them happy
20:21:42 <Armored_Azrael> (the idea being some kind of smart compression based on the kinds of data that can be produced by the read/show)
20:21:54 <steven_ashley> the milkshakes come in malted or unmalted varieties (you can only make one or the other)
20:22:11 <steven_ashley> and customers can only like one malted milkshake at the most
20:22:17 <steven_ashley> a bit odd but not too hard
20:22:37 <steven_ashley> you had to output whether or not to malt each flavour, or whether it was impossible :P
20:23:04 <steven_ashley> question C was finding (3.0 + (sqrt 5.0)) ** n for different n
20:23:13 <steven_ashley> most of the correct answers used some matrix math
20:23:16 <heatsink> That sounds like SAT.
20:23:19 <jeffwheeler> I can't compile pureMD5 0.2.3 on OS X (Leopard): I get an error about not being able to execute the ghc-asm binary.
20:24:03 <jeffwheeler> I installed ghc 6.8.3 through the premade package, yesterday.
20:24:32 <lilachaze> "milkshakes come in malted or unmalted. different customers have different preferences. maximise the number of boys brought to the yard."
20:25:42 <steven_ashley> ï»¿heatsink: I used an intuitive approach that seemed to work, I set everything to unmalted, then for each unhappy customer, if they have a drink they like malted, set it to malted, otherwise its impossible.
20:26:04 <Saizan_> ?hackage pureMD5
20:26:04 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/pureMD5
20:26:09 <steven_ashley> I got them both right using that approach, it was fairly easy to code so I guess my instincts were right :P
20:31:23 <jeffwheeler> Saizan_: yeah, that's where I got it
20:32:04 * Shiruka is having more fun reading IOBase.lhs and ST.lhs than any descriptions of how they work and what can be assumed of them :-)
20:32:50 * jeffwheeler is trying xmonad for the first time. I liked ratpoison a long time ago, but have been using GNOME since.
20:34:41 <lament> mice aren't manly enough! it's like shaving with a safety razor!
20:35:02 <jeffwheeler> lament: agreed; so I intend to use neither
20:35:19 <Saizan_> jeffwheeler: about the error, don't you have a ghc-asm in your ghc installation directory? however i think removing -fvia-C from the .cabal file might work
20:35:27 <ShockSMX> lament: what's the alternative
20:35:43 <ShockSMX> lament: do you just interface with the wire directly?
20:35:46 <lament> oh i dunno, aks xmonad guys
20:35:47 <jeffwheeler> ShockSMX: stuff like old-school Merkur razors
20:36:04 <lament> what does dons shave with
20:36:05 <ShockSMX> jeffwheeler: instead of... a mouse?
20:36:15 <jeffwheeler> ShockSMX: oh, instead of a safety razor :P
20:36:24 <ShockSMX> pssh. that's trivial.
20:37:03 <steven_ashley> does anyone here know the math technique involved to accuratecalculate something like
20:37:03 <steven_ashley> power :: Double -> Int
20:37:03 <steven_ashley> power n = ((3.0 + (sqrt 5.0)) ** n) `mod'` 1000.0
20:37:09 <jeffwheeler> Saizan_: I do have ghc-asm in my dir, and it is executable; I'll try the second part of that.
20:37:10 <steven_ashley> accurately*
20:37:38 <Shiruka> keyboard is for wussies of the text messaging generation, real men use a mouse and when they need to type they transmit the bytes to the computer by using one mouse button for morse code!
20:37:39 <lament> instead of a mouse, you could just use zygohistomorphic prepromorphisms
20:38:39 <jeffwheeler> Saizan_: that worked perfectly; thanks!
20:38:42 <heatsink> Shiruka: Stephen Hawking is a Real Man.
20:40:43 <Saizan_> jeffwheeler: np :) maybe you should report that error to the ghc maintaners if you just installed it regulary
20:41:02 <jeffwheeler> Saizan_: I might do that
20:41:15 <ddarius> steven_ashley: Field extensions presumably.
20:41:39 <steven_ashley> ddarius: cheers, I will have a look :)
20:41:52 * ddarius missed the mod but is pretty sure his answer is still correct (ish)
20:41:56 <steven_ashley> ddarius: could you run that with a matrix / matrix multiplication
20:42:15 <steven_ashley> (or a modulo variant)
20:43:53 <ddarius> steven_ashley: If instead of 5.0 what if you had -1.0?
20:44:27 <steven_ashley> ddarius:  the number is fixed by the problem
20:44:50 <ddarius> I know, but hypothetically...
20:45:02 <steven_ashley> you would have complex numbers
20:45:52 <dmwit> steven_ashley: Do you want the technique, or just the answer?
20:46:18 <steven_ashley> dmwit: just the technique will be fine
20:46:40 <dmwit> Too bad, if you just wanted the answer, we could do that. ;-)
20:47:02 <dmwit> > 3 + 10 * sqrt 5 :: CReal
20:47:03 <lambdabot>  25.3606797749978969640917366873127623544062
20:48:22 <steven_ashley> lol, that was my first approach :D I think I understand roughly how it works, cheers both of you :)
20:54:28 * vixey wrote unification algorithm in 3 lines :D
20:54:45 <dmwit> unify = (>>=)
20:54:49 <dmwit> ;-)
20:55:14 <vixey> :t (>>=)
20:55:15 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
20:55:26 <vixey> mmm I think that doesn't make any sense
20:58:13 <steven_ashley> ddarius: works now, thanks :)
20:58:32 <steven_ashley> I had the right idea, but I was using floating point for storing the sqrt part
20:58:37 <steven_ashley> rather than an integer
20:58:45 <steven_ashley> :P
20:58:47 <steven_ashley> what a nub ;)
20:59:14 <dmwit> > nub "steven_ashley"
20:59:15 <lambdabot>  "stevn_ahly"
20:59:49 <steven_ashley> lol
20:59:49 <TomMD> > map pred "steven_ashley"
20:59:50 <lambdabot>  "rsdudm^`rgkdx"
21:00:03 <dmwit> > on (==) sort "lashy_vent" "stevn_ahly"
21:00:04 <lambdabot>  True
21:02:04 <hackage> Uploaded to hackage: Pugs 6.2.13.10
21:04:26 <vixey> :/
21:04:46 <vixey> I am always coming up against the problem of making fresh variables
21:05:27 <vixey> I have written a few slightly different monads/monadTs for it but it's not often you can reuse them
21:08:34 <Saizan_> try the supply comonad then :)
21:09:18 <vixey> awwww it's in IO
21:09:29 <heatsink> comonad?
21:09:56 <heatsink> vixey: There's a solution that doesn't require a monad, if you prefer.  It works like Random.
21:10:16 <heatsink> I mean, it's not literally random, it just has a similar interface.
21:10:44 <dogbite> man i got destroyed by the google code
21:10:50 <dogbite> i'm totally humbled
21:10:59 <dogbite> and bummed out
21:11:12 <vixey> what I need to do is a little bit more complex than the supple comonad though
21:11:13 <steven_ashley> ahh
21:11:22 <Twey> :t on
21:11:22 <steven_ashley> dogbite: where did you place?
21:11:25 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
21:11:26 <vixey> and I definitely want this to be monadic..
21:11:30 <Twey> @src on
21:11:30 <lambdabot> (*) `on` f = \x y -> f x * f y
21:11:37 <ddarius> vixey: Really?
21:11:54 <vixey> well I think so....
21:12:14 <ddarius> You can do both.
21:12:18 <dogbite> steven_ashley: 1700ish
21:12:32 <dogbite> i only got the short part of part 1 correct
21:12:46 <steven_ashley> yep, looking at your code now :)
21:12:48 <ddarius> You'll presumably need an environment, but you could use a supply comonad rather than a state monad to generate fresh names.
21:12:57 <steven_ashley> add me as a friend if you want "StevenAshley"
21:13:17 <dogbite> done
21:13:29 <steven_ashley> hmm
21:13:39 <steven_ashley> I had the same algorithm as you for the first question
21:13:40 <dogbite> steven_ashley: i'm just so crushed... i really didn't expect to fare so poorly
21:13:54 <dogbite> you just did sort, reverse . sort?
21:14:03 <steven_ashley> yep
21:14:14 <dogbite> yeah i think that's right... wonder what happened!
21:15:10 <steven_ashley> my source is up if you want it to compare
21:15:35 <dogbite> how how do i see it?
21:15:49 <steven_ashley> click solution download
21:15:52 <steven_ashley> (the tick box)
21:15:59 <steven_ashley> then click on the one you want
21:16:07 <steven_ashley> (on the friends page)
21:16:18 <dogbite> k
21:17:36 <dogbite> huh
21:17:56 <steven_ashley> same results?
21:18:13 <dogbite> checking now
21:18:25 <dogbite> yours takes longer than mine... could be a sign something went wrong for me
21:18:44 <dogbite> yours is takin a bit... is that expected?
21:18:54 <steven_ashley> you have to cat the input to it
21:18:58 <dogbite> oh
21:19:00 <steven_ashley> cat file | runhaskell Base.hs
21:19:25 <dogbite> no, very diff output
21:22:46 <steven_ashley> you sure :S
21:22:49 <dogbite> honestly... i don't have a clue on that one why it's diff
21:22:51 <steven_ashley> they are the same on mine
21:22:56 <dogbite> huh
21:22:56 <koninkje> @pl \a b c d -> f (g a b c d)
21:22:57 <lambdabot> (((f .) .) .) . g
21:23:02 <koninkje> meh
21:23:32 <steven_ashley> $ cat A-small-attempt0.in | runhaskell Base.hs > mine
21:23:33 <steven_ashley> $ runhaskell question1.lhs A-small-attempt0.in  > his
21:23:33 <steven_ashley> $ diff mine his
21:23:33 <steven_ashley> $
21:23:43 <dogbite> what on earth
21:23:54 <dogbite> i'm running it right now
21:24:10 <ddarius> @pl \f g a b c d -> f (g a b c d)
21:24:10 <lambdabot> (.) . (.) . (.) . (.)
21:24:24 <dogbite> i'm getting Case #1: 850008040
21:24:38 <dogbite> maybe because i use Int not Integer!!!
21:25:06 <dogbite> damn
21:25:07 <chrisdone> koninkje: just use (f g)?
21:25:07 <dogbite> that's it
21:25:20 <dogbite> you must have like.. more bits than i do because when i switched Int to Integer it worked
21:25:30 <dogbite> well that sucks, heh
21:25:42 <chrisdone> koninkje: oh
21:25:59 <dogbite> steven_ashley: i think i solved #2 but mine went too slow
21:26:01 <koninkje> chrisdone: I was just seeing if there happened to be a shorter version than that one
21:26:47 <steven_ashley> you can do number 2 without testing combinations
21:27:12 <dmwit> koninkje: fmap fmap fmap fmap fmap fmap fmap ;-)
21:27:45 <dogbite> steven_ashley: i suspected as much but couldn't think of how
21:27:47 <heatsink> dmwit: Eew, not in this forum!
21:27:56 <koninkje> dmwit: heh heh :)
21:28:11 <dogbite> i'll look at your code tomorrow... i hope i fare better in round 2!
21:28:31 <dogbite> i had NO clue on 3rd problem
21:29:18 <heatsink> Backwards state monads are fun =D
21:29:42 <heatsink> {- line 7 -} tr <- someFunction
21:29:54 <heatsink> {- line 8 -} setState foo -- we need this to compute tr
21:30:31 <bd_> better yet, setState (f tr) :D
21:30:44 <dmwit> Oy, you there!  You're violating code 16 of the International Time Traveler's Constitution, I'm going to have to ask you to turn in your badge.
21:31:08 <ddarius> heatsink: Ever study attribute grammars?
21:31:35 <bd_> dmwit: nah, it's cool - the timeline converges. As long as you don't stare too hard.
21:31:44 <heatsink> ddarius: Nope
21:33:11 <lfamorim> People, haskell have a portuguease tutorial?
21:42:22 <koninkje>  can anyone explain why this works with Control.Exception.catch and fails with Prelude.catch?
21:42:25 <koninkje> safely f x = unsafePerformIO $ catch (let fx = f x in fx `seq` return (Just fx)) (\_ -> return Nothing)
21:43:47 <heatsink> koninkje: I think Prelude.catch only catches the exceptions defined in the prelude, and ignores others.  Control.Exception.catch catches more kinds of exceptions.
21:44:40 <koninkje> aren't user-defined errors ala 'error' in the Prelude?
21:45:20 <heatsink> Hmm, let me see what error throws.
21:45:21 <Draconx> Prelude.catch only catches IOErrors, I think.
21:45:35 <koninkje> yeah it does
21:45:45 <heatsink> @source error
21:45:45 <lambdabot> error not available
21:45:48 <heatsink> @src error
21:45:48 <lambdabot> error s = throw (ErrorCall s)
21:46:14 <heatsink> yeh, ErrorCall is a Control.Monad.Exception Exception, not an IOError.
21:47:24 <koninkje> ah, dankje wel
21:49:55 <koninkje> alas, whyfor did Haskell98 declare some exceptions to be uncatchable...
21:52:47 <dons> i think plain config parsers are probably more plausible, fwiw.
21:53:22 <dons> error "wrong chan"
21:53:36 <dons> koninkje: Control.Exception ftw.
21:53:57 <koninkje> indeed, but non-portable alas
21:55:11 <dons> non-portable to what?
21:55:35 <koninkje> it declares itself non-portable, I haven't actually tried
21:55:39 <dons> what system only implements the decade old proto-haskell, that you could be worried?
21:55:46 <koninkje> heh heh
21:55:55 <dons> ah, ok. i see. Control.Exception *is* portable.
21:56:05 <dons> its implemented by all haskell compilers that exist now.
21:56:10 <dons> please use it.
21:56:26 <koninkje> I was planning on using it anyways ;)
21:58:02 <geezusfreeek> O_4: did you manage to get it worked out?
21:58:07 <O_4> Nah
21:58:17 <O_4> I'm using GLUT atm, it seemed easier.
21:58:21 <geezusfreeek> i have it working here if you still want to get it figured out
21:58:45 <O_4> Did you have any issues with it looking for SDL_main during link?
21:58:53 <geezusfreeek> yes
21:59:16 <geezusfreeek> i had to make a main function in C and call a faked Haskell main function from it
21:59:20 <O_4> Did you have to write a C wrapper to get everything to play nice, or was it easier than that?
21:59:24 <O_4> Ah, yeah.
21:59:33 <geezusfreeek> it's not too bad really
21:59:34 <O_4> I figured that's what I'd have to do.
21:59:46 <O_4> Nah, but GLUT is easier for the time being :-p
22:00:24 <geezusfreeek> even once you get that you still have to make a .app bundle for it to behave properly
22:00:31 <O_4> Yeah
22:00:49 <geezusfreeek> if you are fine with glut for now then i just won't bother wikifying this stuff just yet, but i am thinking i will eventually get around to it
22:00:50 <O_4> Though I have a script to build an OS X app bundle somewhere
22:02:17 <geezusfreeek> what really got me with the C wrapper was that i had to set of an NSAutoreleasePool, which took me a while to figure out
22:02:22 <geezusfreeek> *set up
22:04:02 <O_4> Yeah, I think the way I've done it in the past is to setup an ARP, call NSRunApplicationMain or whatever, then return via my callback once that's running.
22:04:51 <geezusfreeek> thats sounds like what most of the (scarce) documentation on this said to do that i read
22:05:11 <geezusfreeek> but i just used C to call out the obj-c methods manually instead of setting up callbacks and stuff
22:28:47 <andyjgill> Hey, does anyone know if someone has tried to use type families to implement monad transformers?
22:34:33 <O_4> Huh, haskell lists don't support random access?
22:34:49 <O_4> I know they aren't optimised for it, but I'd expect it to still be an option.
22:35:04 <rwbarton> > ["foo", "bar", "baz", "quux"] !! 2
22:35:08 <lambdabot>  "baz"
22:35:56 <O_4> Ugh, thanks :-p
22:44:31 <solrize> anyone know if there's a library around somewhere that compresses short text strings?
22:45:52 <luqui> solrize, hm, using rle or something
22:45:55 <luqui> ?
22:46:54 <solrize> i was thinking something like gzip, but pre-initialized with some big text file
22:48:37 <solrize> i.e.    let wp=contents_of_war_and_peace; c0=gzip(wp); c1=gzip(wp+mystring) in drop (length c0) c1
22:48:44 <solrize> figuratively speaking
22:51:13 <Saizan_> andyjgill: there are some of them on hpaste.org iirc
22:51:29 <Saizan_> if you mean classes like MonadState
22:51:46 <andyjgill> Ah Saizan_: thanks!
23:46:39 <novas0x2a> m
23:47:14 * novas0x2a is bitten by focus follows mouse and a touchpad.
23:50:42 * ski tries to make sense of that, from the perspective of a computer illiterate
23:53:03 <mjrosenb> i'm assuming that ONLY identifiers can be infixed, yes?
23:53:32 <halberd> http://hpaste.org/9168
23:53:51 <halberd> I can't figure out why this doesn't behave the way I want it to, I've done a trace of it and it seems to be evaluating more than it should
23:54:25 <halberd> i.e. I do "stepBoard f (0,0)" to solve the (already solved) board f
23:54:37 <ski> mjrosenb : well `+' in `a + b' is infix .. but if you mean the surrounding with back-appostrophes, then yes
23:54:53 <halberd> and it should just recurse straight to the last square of the board, see that it's solved, and then return the board all the way back up
23:55:10 <mjrosenb> ski: so for example
23:55:15 <mjrosenb> ++ is isfix
23:55:20 <halberd> but it gets to the last square of the board and then starts going to strange squares
23:55:21 <mjrosenb> i'd like
23:55:29 <mjrosenb> liftM2 (++)
23:55:36 <mjrosenb> to act like it's infix
23:55:46 <mjrosenb> since it's doing more or less the same thing
23:55:48 <halberd> it does seem to work when I try it closer to the end
23:56:00 <halberd> like at (7,7) it will work
23:56:05 <ski> mjrosenb : yes, sadly you can't do that .. the best you can do is make a (usually) local binding for the infix thing
23:56:18 <halberd> but when I try it at the beginning it is just too slow because it is evaluating more than I want it to
23:56:32 <mjrosenb> :(
23:56:44 <halberd> and I don't know why it is evaluating that much
23:56:45 <mjrosenb> (+++) = liftM2 (++)
23:56:53 <mjrosenb> *sigh*
23:57:52 <halberd> to be clear, all the functions except for "stepBoard" are working properly, I have tested those
23:58:17 <halberd> it is just stepBoard that is too slow, seemingly because it is not lazy enough
23:58:53 <Trinithis> Can anyone point me in the right direction for parsing javascript expressions? In particular, its conditional, array-style member, and function application operators?
