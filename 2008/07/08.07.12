01:04:05 <stepcut> are we winning yet ?
01:12:40 <dcoutts> cinimod: pong
01:15:21 <cinimod> dcoutts: ping?
01:15:42 <dcoutts> cinimod: you were looking for me?
01:15:50 <cinimod> dcoutts: to say thanks for the help on cabal
01:15:59 <dcoutts> oh, right, so it's working?
01:16:23 <cinimod> dcoutts: the cabal is working but the code no longer compiles :-(
01:16:46 <cinimod> I last compiled it in 2005
01:16:46 <dcoutts> cinimod: heh :-), well so long as it's not cabal's fault I don't mind
01:18:01 <cinimod> Did you manage to process the account request for community? No rush but will I get an email notification?
01:18:15 <dcoutts> cinimod: I didn't and you will get email notification
01:19:22 <cinimod> dcoutts: whenever it's convenient - then I can move the ASN.1 issues acrros from google code
01:20:35 <dcoutts> cinimod: done
01:20:44 <dcoutts> cinimod: check if you can log in
01:21:20 <dcoutts> cinimod: I guess you'll also want a project, what name do you want for it?
01:21:38 <dcoutts> oh, or a trac?
01:21:42 <cinimod> dcoutts: I haven't got an email yet so no password or do I set one on login
01:21:58 <dcoutts> cinimod: it's not password based, you supplied your ssh key
01:22:14 <cinimod> dcoutts: of course
01:22:27 <dcoutts> we do not use passwords at all, only keys
01:23:16 <cinimod> dcoutts: initially I was going to set up asn1 but I'll also do crypto at some point
01:23:44 <cinimod> dcoutts: yes I'd like a trac but I thought I could do that for myself?
01:24:01 * cinimod goes away to try logging on
01:24:38 <dcoutts> cinimod: you can do the trac yourself, you need to file a request for project space or I can do it now if you like.
01:24:41 <Armored_Azrael> Any idea why lifted IO functions inside a StateT version of the IO monad, inside threads, would suddenly hang indefinitely?
01:25:17 <cinimod> dcoutts: could you do asn1 and crypto? Thanks.
01:25:56 <cinimod> dcoutts: login successful
01:27:06 <cinimod> dcoutts: do you want me to fill in the project request form so you have a record / trail?
01:27:50 <dcoutts> cinimod: doesn't matter too much
01:28:54 <cinimod> dcoutts: ok if you don't mind doing it now that would be great
01:34:11 <dcoutts> cinimod: done asn1 and crypto
01:34:47 <vixey> I wrote this topological sort http://hpaste.org/8880
01:34:57 <agnokapathetic> i'm refactoring some code to work with bytestrings and the linker's going wonky "wf.o(.text+0xc0):fake: undefined reference to `bytestringzm0zi9zi0zi1zi1_DataziB
01:34:57 <agnokapathetic> yteStringziFusion_ZCztZC_con_info'"
01:35:24 <vixey> is it best to detect loops first, or would there be a way to put loop detection into the code itsself?
01:36:21 <vixey> -_-
01:36:30 <vixey> I figured it out, it was very simple
01:36:40 <vixey> just check if now is null
01:37:33 <dcoutts> bd_: you were asking about the type of user hooks, we removed the ExitCode from most of the return types since they were never used correctly.
01:39:26 <vixey> I annotated with the correction.. any comments about it though?
01:39:51 <vixey> (does subtract or sift or +++ already exist under different names?)
01:54:38 <taruti> Is there any reason STM is not in MonadFix?
02:15:44 <EvilTerran> vixey, sift looks like partition to me
02:15:47 <EvilTerran> ?type partition
02:15:48 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
02:16:11 <vixey> @src partition
02:16:11 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
02:16:11 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
02:16:11 <lambdabot>                               | otherwise = (ts, x:fs)
02:16:27 <vixey> thanks
02:16:27 <vixey> aoeu
02:16:43 <EvilTerran> and +++ looks kinda like mappend
02:16:46 <EvilTerran> ?src Maybe mappend
02:16:47 <lambdabot> Source not found. My pet ferret can type better than you!
02:17:47 <EvilTerran>   Nothing `mappend` m = m
02:17:47 <EvilTerran>   m `mappend` Nothing = m
02:17:47 <EvilTerran>   Just m1 `mappend` Just m2 = Just (m1 `mappend` m2)
02:18:14 <EvilTerran> well, vaguely related
02:18:39 <EvilTerran> actually, (xs +++) = fmap (xs ++), that's simplter
02:23:09 <Peaker> how come "forkIO (forM_ [1..10] $ \i -> putStrLn (show i)) >> forkIO (forM_ [10..20] $ \i -> putStrLn (show i))" prints nothing?
02:24:08 <_Dae_> Peaker: I thought you could only print strings to the console from the main thread? I could be wrong however
02:24:36 <Peaker> oh. Just looking to tinker with some thread
02:26:08 <EvilTerran> i suspect a bound thread will work too
02:27:17 <Peaker> EvilTerran: "bound"?
02:28:38 <EvilTerran> Peaker, it's something weird described in Control.Concurrent
02:30:52 * _Dae_ notices that Peakers code, run in ghci, gives the weirdest output
02:31:43 <_Dae_> Seriously..... thats just odd!
02:32:42 <Peaker> _Dae_: what does it do?
02:33:06 <Peaker> oh heh
02:33:46 <Peaker> _Dae_: its just mangling the outputs
02:33:50 <Peaker> _Dae_: of all the threads
02:33:58 <Peaker> (which doesn't happen in the compiled)
02:34:08 <_Dae_> Right....
02:34:17 <_Dae_> is that a bug?
02:34:35 <Peaker> I think threads are supposed to suck that way :)
02:35:21 <_Dae_> Right.... heh, ok I would just expect ghci to do the same thing as ghc without optimization ;)
02:36:44 <Peaker> seems not to
02:38:36 <_Dae_> yeah.... I'm suspecting ghci of not being quite able to multithread
02:51:37 <dibblego> in the expression, x <$> y <*> z, where are the parentheses?
02:51:48 <vixey> (x <$> y) <*> z
02:51:54 <dibblego> thanks
02:51:56 <vixey> :info <$>
02:51:59 <vixey> hmm
02:58:20 <BSP_> has anyone seen a situation with ghc-pkg where you are able to >describe< a package, but neither hide nor expose it (getting a "cannot find package" error)? i'm not really sure what to make of this
02:59:01 <Lemmih> BSP_: Typo?
02:59:07 <Peaker> @info (<$>)
02:59:08 <lambdabot> (<$>)
02:59:23 <vixey> hehe
02:59:25 <BSP_> Lemmih: no, i actually use bash history to copy the package name exact between commands...
03:01:55 <jpcooper> is it possible to enable tab-completion in haskell-mode?
03:02:03 <jpcooper> both in editing source-code and on the REPL
03:02:35 <schme_> what's haskell-mode though?
03:02:40 <jpcooper> for emacs
03:02:44 <jpcooper> what do you use?
03:03:14 <schme_> vim.
03:03:18 <schme_> For haskell anyway.
03:03:24 <jpcooper> is it more common for haskell programmers to use vim
03:03:25 <jpcooper> ?
03:03:30 <schme_> No idea. :)
03:03:39 <_Dae_> I think most use emacs?
03:03:46 <jpcooper> good!
03:04:12 <Lemmih> jpcooper: alt-/ ?
03:04:26 <_Dae_> Well, I don't know.... it's a bit of "whatever floats your boat" I guess.... I just never could get vim to indent the code right...
03:04:36 <jpcooper> Lemmih, right, I'll try that
03:04:59 <schme_> _Dae_: I use tab to indent code ;)
03:05:19 <jpcooper> aah, nice one
03:05:45 <schme_> Oh right. *that* haskell-mode. I remember I had some problems with that.
03:06:12 <_Dae_> schme_: right.... but vim doesn't really help you there, does it? the emacs plugin cycles through the legal indents, which is a feature I have yet to encounter in any other editor
03:06:32 <schme_> _Dae_: What are the legal indents though?
03:06:59 <_Dae_> schme_: indents that make sense in the context?
03:07:27 <schme_> _Dae_: Right. I don't buy that for haskell.
03:07:36 <schme_> I find emacs quite nice for lisp though :)
03:07:51 <schme_> Oh yeah. that's the problem M-x run-haskell fires up ghci in a buffer, and I can't do shit with it.
03:07:59 <hackage> Uploaded to hackage: AERN-Real 0.9.3.1
03:07:59 <hackage> Uploaded to hackage: AERN-Real 0.9.3
03:08:09 <_Dae_> schme_: why not?
03:08:17 <schme_> Why not what ? :)
03:08:22 <_Dae_> both
03:08:43 <_Dae_> why don't you buy it for haskell, and why can't you do shit with ghci in a buffer?
03:08:58 <schme_> Well haskell-mode is not doing a very well work of detecting the "context" I want it in.
03:09:27 <schme_> and I get ghci in a buffer. I type 1+1 at the repl and ith minibuffer says "No more errors yet"
03:09:30 <schme_> and that's about it.
03:10:00 <schme_> I seem to recall haveing the same problem with erlang-mode.
03:10:59 <schme_> I'd love to use emacs for it, running vim in emacs is a bit of a pain :)
03:11:51 <riverrun> lol
03:12:15 <riverrun> I'd love to use emacs, but i'm so used to single-key commands
03:12:23 <_Dae_> The context has always worked for me, I've never had to redo it tbh.  and what you say of ghci in a buffer.... what??? it doesn't behave at all like that
03:12:39 <schme_> It behaves exactly like that.
03:12:50 <_Dae_> ghci in a buffer works just like it does in the terminal
03:12:55 <schme_> No, it does not.
03:13:11 <_Dae_> yes it does? give me an example
03:13:21 <schme_> An example of what though?
03:13:34 <schme_> When I enter 1 + 1 in a terminal I get 2 and a new prompt.
03:13:54 <schme_> When I run it in emacsen it just says "No more errors" in the minibuffer.
03:14:01 <schme_> and the prompt is still 1+1
03:14:23 <_Dae_> no... it doesn't.... I just ran it 2 seconds ago. it does the exact same thing. Are you sure you're using the latest version?
03:14:36 <schme_> No idea if it is the latest version.
03:14:52 * jpcooper goes to get the flamewar wafter
03:15:10 <jpcooper> *editor Jihad
03:15:24 <schme_> I'm using http://www.iro.umontreal.ca/~monnier/elisp/haskell-mode.tar.gz
03:15:54 <anne> Hello. Just a quick question. Is there a way to get a new unique key for a Data.Map Map other than getting a list of all keys (O(n))?
03:16:09 <Peaker> anne: there's Bimap
03:16:19 <Peaker> anne: oh sorry, misread you
03:16:44 <anne> oh
03:16:55 <vixey> anne: you could start with the infinite list [0..]
03:17:04 <Peaker> anne: you have a Data.Map and you want to generate a new unique key of any (forall k. k) type? Or do you have the specific key type?
03:17:05 <_Dae_> schme_: that's odd... I am too and it's working fine.... or rather i'm using an rpm i found somewhere, but....
03:17:08 <vixey> anne: each time you want a new key take the head, and then store the tail
03:17:28 <vixey> anne: maybe? If that's suitable you can put this into a monad
03:18:12 <anne> The keys are integers. I was just wondering if there is a way to do this without passing around extra data.
03:18:30 <vixey> anne: Using a monad makes passing around the data implicit
03:18:56 <opqdonut> anne: have you had a look at Data.Unique
03:18:58 <opqdonut> ?
03:19:16 <vixey> gensym :: State [String] String
03:19:17 <vixey> gensym = do (g:gs) <- get ; put gs ; return g
03:19:17 <vixey> withGensyms freshVariables = flip evalState freshVariables
03:19:21 <anne> Hmm... So you're saying it's not feasible to generate a new key from the Map itself?
03:19:21 <vixey> simple version..
03:19:22 <opqdonut> if you need the keys to be integers you'll have to pass a counter around or something
03:19:38 <opqdonut> anne: of course getting the max key is O(log n)
03:19:45 <opqdonut> you could just take that and increment by 1
03:20:14 <anne> opqdonut: Well, the data is serialised and the keys must be unique for all sessions.
03:20:52 <opqdonut> anne: hmm, for all sessions
03:20:53 <anne> opqdonut: The document says it's On)
03:20:56 <anne> O(n)
03:20:59 <opqdonut> Data.Unique might be the way to go
03:21:20 <vixey> why would you refer IO over State ?
03:21:50 <opqdonut> anne: no, it's log n: http://haskell.org/ghc/docs/latest/html/libraries/containers/Data-Map.html#v%3AfindMax
03:21:51 <lambdabot> Title: Data.Map, http://tinyurl.com/2mpwee
03:22:05 <Peaker> anne: Given that the map's key-type is arbitrary, I don't think there's any way to generate a new value of an arbitrary type at all, let alone a unique value
03:22:16 <opqdonut> that is true
03:22:18 <EvilTerran> indeed not
03:22:28 <vixey> it's Integer
03:22:31 <EvilTerran> you need an instance of some class with an appropriate method for that
03:22:43 <EvilTerran> ah. or a concrete type, that works too
03:23:06 <Peaker> well, I don't think Maps would have any Integer-key-specific functions :)
03:23:07 <anne> opqdonut: Aha, well, I stand corrected.
03:23:23 <opqdonut> anne: but yeah, just keeping a counter around is a good solution also
03:23:47 <vixey> what about IntMap
03:24:04 <opqdonut> isn't that just specialized map?
03:24:13 <anne> Peaker: Ah, ok, now I understand...
03:24:50 <opqdonut> min is still logn
03:25:49 <dons> "I guess I'll embrace the Lisp way and try to simulate the convenience of monadic parsing with a big tangle of macros and special variables"
03:26:30 <dons> not bad at all, http://marijn.haverbeke.nl/monad.html
03:26:31 <lambdabot> Title: Why monads have not taken the Common Lisp world by storm
03:27:42 <vixey> dons: I don't know if that was written by someone very experienced..
03:27:43 <vixey> "a lot of the advantages of monads become moot"
03:27:45 <vixey> oops
03:27:52 <vixey> "in the presence of mutable state, a lot of the advantages of monads become moot."
03:29:12 <Peaker> I think his claim that monads only work with type-classes misses the case of "duck typing" which has the power of type-classes (albeit lacks in type-safety, ugliness, etc)
03:29:18 <opqdonut> mhmm
03:29:28 <opqdonut> a pretty low-brow explanation
03:29:37 <opqdonut> things like Parsec could still be useful in CL
03:29:51 <schme> Peaker: Well you could add type-classes to CL ;)
03:30:04 <opqdonut> with macros 8]
03:32:27 <Lemmih> dcoutts: So, any premonitions about my prospects of attending AngloHaskell?
03:38:09 <anne> IntMap looks nice. Interestingly enough, it doesn't have a findMax. :-) Anyway, we'll see.
03:43:16 <Peaker> where can I find an FRP example of a value that can be increased/decreased in-place by the user?
03:43:45 <Peaker> (or any "in-place" mutation, as far as the user's concerned)
03:52:53 <paczesiowa> what is a ground type?
03:53:28 <vixey> probably a type that doesn't have any variables in it
03:53:38 <vixey> like Bool, or Maybe (Integer,[()])
03:53:48 <paczesiowa> so fully monomorphic?
03:53:55 <vixey> where did you read it ?
03:54:06 <paczesiowa> HList paper
04:01:09 <paczesiowa> googling for ground types results in pokemon sites:>
04:01:24 <vixey> haha
04:10:38 <Peaker> Yampa seems cool!
04:10:51 * Peaker is beginning to understand what's going on there :)
04:11:21 <Peaker> Trying to reverse engineer it from examples was far less productive than reading about it, this time, heh
04:13:48 <Beelsebob> Peaker: I'd suggest you're much better off looking at Reactive than at Yampa
04:14:05 <Peaker> Beelsebob: I couldn't find any tutorial or meaningful examples of Reactive
04:14:35 <Beelsebob> yep, there is that -- one of my workmates is writing a tutorial for it
04:14:41 <Peaker> Beelsebob: also, it requires you to explicitly fork threads, and has a practical problem with the thread racing, right?
04:14:45 <Beelsebob> but it's a much more functional library than Yampa does
04:14:56 <Peaker> more functional in what sense?
04:15:06 <Beelsebob> in that it's all nice applicative style stuff
04:15:21 <Beelsebob> not pissing about with arrows, which are very sequential
04:15:38 <Beelsebob> it's also a lot more efficient, and scales better
04:15:50 <Peaker> well, currently I just want to get the "hang" of FRP with some real examples
04:15:59 <Beelsebob> fair enough
04:16:04 <Peaker> I don't really expect/care about performance/scalability yet :)
04:16:07 <Beelsebob> the Yampa tutorials are a fair start then
04:16:21 <Beelsebob> but keep an open mind about what FRP means
04:16:30 <Beelsebob> because Reactive is quite a bit different
04:17:12 <Peaker> when it has that tutorial, I'll definitely give it a try too :)
04:17:35 <Beelsebob> hehe, I'll tell david to get on with it :P
04:22:23 <Peaker> what does "rec" mean in the context of the arrow's syntactic sugar?
04:23:12 <Beelsebob> can you paste bin it?
04:23:38 <Peaker> copying from PDF is hard, I'll have to do it line-by-line, sec :)
04:23:46 <Beelsebob> haha
04:25:44 <Peaker> http://hpaste.org/8882
04:26:09 <Beelsebob> recursive
04:26:46 <Peaker> what's recursive about it?
04:27:17 <Beelsebob> v is taken from one "frame" and passed into that computation of v for the next frame
04:28:07 <Beelsebob> (one of the very non-functional parts of Yampa)
04:28:27 <Peaker> why is it non-functional?
04:28:48 <Peaker> also, does that "rec" sit in any meaningful position? Would it matter if the entire "do" was a "rec"?
04:29:04 <Beelsebob> because it involves a discretisation of time, and essentially setting variable values each frame
04:29:07 <Beelsebob> it's essentially mutable state
04:30:44 <Peaker> Why is "x <- (x0+) ^<< integral -< v" inside the "rec" too? It uses "v", but so does the returnA line
04:30:54 <Peaker> (I cut the use of "v" line from there)
04:32:08 <Beelsebob> that's a good point
04:32:12 <Beelsebob> not entirely sure
04:32:45 <chrisdone> indentation?
04:33:05 <Beelsebob> I think he meant "why does that line need to be indented"
04:33:11 <Beelsebob> i.e. why is it within the rec
04:33:28 <chrisdone> ah, sorry
04:33:57 <Peaker> Why not allow recursive uses like that everywhere? Is it because it demands it to be ArrowLoop?
04:41:44 <Peaker> hmm, Yampa seems to require you to specify an LCD type for both input and output of all of your objects.. Seems to create a danger of coupling unrelated entities
04:41:57 <Peaker> (and all code then depends on that type?)
05:07:27 <Peaker> The last 30 minutes can easily be used to conclude what timezone everyone's in..
05:08:57 <smtms> the timezone where it's Saturday
05:14:12 <_Dae_> my favorite
05:19:20 * gwern wishes it were sunday. cause that's my fun day
05:20:27 <_Dae_> fun day?'
05:26:14 <_Dae_> has anyone made a benchmark test of MArrays vs C's arrays?
05:27:55 <quicksilver> MArray is a class, not a type.
05:28:19 <quicksilver> if you were going to benchmark anything it would be a particular implementation.
05:29:32 <_Dae_> STArray then...
05:30:17 <quicksilver> STArray/IOArray being boxed and range-checked will be quite a lot slower than C.
05:30:32 <quicksilver> perhaps 4-10x slower depending on the benchmark you chose?
05:31:18 <_Dae_> STU then? I merely wanted an "optimal c vs optimal haskell" test...
05:31:46 <quicksilver> STU is presumably bound-checked too.
05:32:01 <mauke> isn't there an unsafeIndex?
05:32:07 <Deewiant> there's Ptr
05:32:08 <name> hey
05:32:10 <quicksilver> using unsafe read/write primitive you'll probably get between 1.2x and 1.8x C
05:32:32 <quicksilver> but quite a lot will depend on the rest of your benchmark (i.e. what you actually do with the data once you've got it out of the array)
05:32:43 <name> how do I let test(x:xy:z) know that xy should be the last but one element of the list?
05:32:55 <quicksilver> name: (x:y:z:[]) ?
05:32:56 <DRMacIver> But using the unsafe read/write primitives in Haskell is a clear instance of You're Doing It Wrong.
05:33:16 <quicksilver> DRMacIver: compared to what?
05:33:21 <_Dae_> allright...say matrix multipliocation, could (heavily optimized) haskell compete with blitz?
05:33:38 <quicksilver> since our compiler is not capable of deducing static properties like "this index is definitely in bounds"
05:33:49 <quicksilver> until we have a compiler which can, we'll need unsafe read/write.
05:34:06 <mauke> oleg had something like that
05:34:22 <quicksilver> _Dae_: no, I doubt it can. blitz is *clever*.
05:34:36 <name> quicksilver: *** Exception: <interactive>:1:4-21: Non-exhaustive patterns in function test
05:34:45 <DRMacIver> ok. I guess you're right that there are cases where it's ok. I retract the statement.
05:34:49 <quicksilver> _Dae_: haskell + RULES would be a fairer comparison.
05:34:54 <_Dae_> quicksilver: and you could not make haskell just as clever?
05:35:06 <quicksilver> because blitz is, as I understand it, using templates as a mechanism to write compiler optimisations.
05:35:09 <_Dae_> quicksilver: ohh, I ment haskell + RULES
05:35:17 <name> quicksilver: http://paste.pocoo.org/show/79217/
05:35:24 <_Dae_> that's what I ment by "heavily optimized"
05:35:31 <quicksilver> name: then you called it on a list which didn't have 3 elements :P
05:35:53 <quicksilver> well with haskell + RULES you can do anything
05:35:57 <DRMacIver> mauke: Yeah, lightweight static capabilities.
05:36:03 <quicksilver> (including generating totally incorrect code)
05:36:05 <name> quicksilver: i did not want this :) i want to get the last but one elem of a list of variable size
05:36:15 <quicksilver> name: you can't do that with a pattern match.
05:36:30 <name> quicksilver: damn :)
05:36:33 <quicksilver> name: head . head . reverse list
05:36:35 <quicksilver> well
05:36:39 <quicksilver> name: head . head . reverse $ list
05:36:40 <quicksilver> I mean.
05:36:44 <quicksilver> ah!
05:36:46 <quicksilver> rubbish
05:36:48 <quicksilver> too early
05:36:51 <quicksilver> need more coffee
05:36:55 <name> lol
05:36:57 <quicksilver> name: head . tail . reverse $ list
05:37:03 <Deewiant> last . init $ list
05:37:06 <quicksilver> > head . tail . reverse $ [1,2,3,4,5]
05:37:12 <lambdabot>  4
05:37:15 <Deewiant> > last . init $ [1..5]
05:37:17 <lambdabot>  4
05:37:22 <name> hm seems pretty hard for such an easy task ;)
05:37:32 <name> s/hard/much to type/
05:37:39 <mauke> it's not easy
05:37:46 <Deewiant> > ap (!!) (subtract 1 . length) [1..5]
05:37:48 <mauke> you have to walk the entire list
05:37:48 <lambdabot>  5
05:37:52 <Deewiant> oops
05:37:56 <Deewiant> > ap (!!) (subtract 2 . length) [1..5]
05:37:57 <lambdabot>  4
05:38:18 <vixey> hard ?
05:38:25 <vixey> it's like 8 characters
05:40:00 <hukolele> how can make an if/else expression to be strict?... if it has any sense...
05:40:49 <chrisdone> I think if/else expressions are one of the main causes of evaluation
05:41:23 <hukolele> what do u mean?
05:41:43 <taruti> a `seq` b `seq` c `seq` if a then b else c ?
05:41:55 <kig> ?type hylo
05:41:57 <lambdabot> Not in scope: `hylo'
05:42:30 <vixey> is there an Identity.Strict monad ?
05:42:48 <hukolele> thx taturi... ill try that
05:43:26 <Deewiant> if a then c `seq` b else b `seq` c
05:43:45 <marcot> Good morning.
06:25:31 <rhz> Is there an equivalent to "gethostbyname" in the Haskell libraries?
06:25:51 <Zao> Several.
06:25:59 <Zao> getHostByName and getAddrInfo comes to mind.
06:26:10 <Zao> The second of which is much better, since it does more than just AF_INET.
06:27:04 <rhz> oh, right. It didn't show up in Hoogle..
06:27:13 <Zao> http://haskell.org/ghc/docs/latest/html/libraries/network/Network-Socket.html#v%3AgetAddrInfo
06:27:14 <lambdabot> Title: Network.Socket, http://tinyurl.com/fkdb4
06:33:41 <chrisdone> is it possible to convert an Integer to a CInt?
06:33:55 <chrisdone> or an Int to a CInt
06:34:08 <mauke> sure
06:34:12 <mauke> fromIntegral
06:39:12 <chrisdone> ah, well, I have a Double that I want to get to a CInt. I used toInteger to get the Integer part, but there is a type error with: fromIntegral (toInteger n) -- where n :: Double, No instance for (Integral Double) arising from use of toInteger
06:39:50 <rwbarton_> :t floor
06:39:51 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
06:40:06 <rwbarton_> > floor (5.6 :: Double) :: CInt
06:40:07 <lambdabot>   Not in scope: type constructor or class `CInt'
06:40:12 <chrisdone> ah, I see
06:40:19 <chrisdone> thanks
06:40:49 <mauke> chrisdone: you can't use toInteger with Double
06:42:26 <chrisdone> ok
07:02:52 <qebab> can I extract the numerator and denominator of a Rational somehow?
07:03:17 <vixey> :t (numerator , denominator)
07:03:19 <lambdabot> forall a a1. (Integral a1, Integral a) => (Ratio a -> a, Ratio a1 -> a1)
07:03:34 <qebab> ah /o\
07:04:16 <mauke> :t [numerator, denominator]
07:04:16 <lambdabot> forall a. (Integral a) => [Ratio a -> a]
07:05:37 <qebab> ah, I just had to import it
07:05:42 <qebab> thanks
07:21:29 <Zao> :t numerator &&& denominator
07:21:30 <lambdabot> forall a. (Integral a) => Ratio a -> (a, a)
07:21:55 <vixey> :t uncurry (%)
07:21:56 <lambdabot> forall a. (Integral a) => (a, a) -> Ratio a
07:27:08 <jpcooper> hello
07:27:25 <jpcooper> could anyone recommend a good book that teaches proper functional programming AND haskell?
07:27:34 <jpcooper> as in the design of large programmes
07:31:14 <jpcooper> could anyone give me their thoughts in http://www.amazon.co.uk/Introduction-Functional-Programming-Prentice-Hall-Computer/dp/0134843460/ref=sr_1_5?ie=UTF8&s=books&qid=1215872948&sr=1-5 ,please?
07:31:17 <lambdabot> http://tinyurl.com/6cd22f
07:31:48 <carl> will building a bytestring from a series of cons (ie show looks something like Chunk "a" (Chunk "b" (Chunk "c" Empty))) result in string like performance ?
07:32:46 <carl> a lazy bytestring *
07:43:02 <SamB_XP> huh
07:43:45 <SamB_XP> this concatenative implementation of the naturals is facinating...
07:43:59 <vixey> where?
07:44:06 <SamB_XP> (last paragraph of http://users.bigpond.net.au/d.keenan/Lambda/)
07:44:07 <lambdabot> Title: To Dissect a Mockingbird: A Graphical Notation for the Lambda Calculus with Anim ...
07:44:43 <SamB_XP> it's mentioned only because the author feels it is connected to the lambda calculus but doesn't see how ;-)
07:45:48 <SamB_XP> I may be mistaken in calling it concatenative
07:48:06 <SamB_XP> data Arith = Log [Arith] | Exp [Arith]
07:51:06 <jpcooper> has no one read the book?
07:58:57 <marcot> I'm trying to build X11 from darcs, and I'm getting:
08:01:13 <marcot> Xinerama.hsc:26:31: error: X11_extras_config.h: No such file or directory
08:01:51 <marcot> Is it broken, or am I missing something?
08:02:18 <Igloo> Sounds like you need to auto(re)conf
08:02:42 <marcot> Igloo: thanks... =)
08:08:15 <hackage> Uploaded to hackage: vector 0.1
08:11:40 <gwern> Igloo: darn you for linking to that split patch. twanvl's split seems to be still different from my split, split', and probably bytestring split
08:13:10 <Igloo> heh
08:13:19 * gwern somtimes wonders just how many definitions of split people've come up with
08:14:14 <gwern> I mean, thus far I've collected 4, not including one variant of split' and various abortions...
08:14:22 <kpreid> gwern: string split?
08:14:48 <gwern> despair! despair! This cruel world of haskell programmers all defining slightly different functions has left me in despair!
08:14:57 * gwern hangs myself
08:14:58 <gwern> kpreid: list split, techniaclly, not just string
08:15:35 <kpreid> have you got a split such that split "--" "a--b---c" = ["a","b","","c"]
08:15:46 <kpreid> (silly)
08:16:08 <gwern> kpreid: naw, my splits are all a -> [a] -> [[a]]
08:16:17 <kpreid> bah
08:16:30 <gwern> kpreid: besides - you would have it remove "---" when you specified "--"?
08:16:51 <kpreid> well, "---" is clearly two delimiters separated by -1 elements
08:16:54 <gwern> split "--" "a--b---c" == ["a","b","","-c"], I would've thought...
08:17:11 <Igloo> ITYM ["a","b","-c"]
08:17:17 <marcot> Is there a reason why XGetCommand is not in X11?  There's something about it in http://darcs.haskell.org/X11/Graphics/X11/Xlib/Window.hs
08:17:21 <gwern> ,,,
08:18:32 <gwern> marcot: try #xmonad, specifically sjanssen or dons, who wrote x11. I suppose 'almost good enough' translates to 'not good enough' :)
08:19:01 <kpreid> you could get a split that works this way by e.g. finding all possible occurrences of the separator string, then taking the substrings between them
08:19:08 <kpreid> </silly>
08:19:41 <monochrom> good morning #haskell
08:19:44 <gwern> arrgh....
08:19:44 <gwern> despair
08:20:11 <gwern> despair! this world of haskell programmers demanding functions with weirdo behaivour has left me in despair!
08:20:27 * gwern goes & hangs self by the neck until dead (amen)
08:20:53 <marcot> gwern: ok, thanks.
08:21:20 <Saizan> gwern: nice citation :D
08:21:47 <gwern> Saizan: ah, you recognize it?
08:21:59 <Saizan> gwern: yup :)
08:22:23 <gwern> Saizan: for bonus points: which reference did you recognize?
08:23:11 <Saizan> gwern: wasn't it only sayonara zetsubou sensei?
08:23:52 <gwern> Saizan: no, I threw in a pirates of the caribbean reference too, for good measure
08:24:59 <gwern> (Saizan: although I did just watch sayonara. hilarious, even if the graffitti and text was painful to keep pausing for just to keep up)
08:26:13 <Saizan> (gwern: yeah, it's great :) but sometimes i just let go some of the text..)
08:26:52 <carl> is there an IO function that does nothing so you can do something like if (a == 2) then putStrLn "yay" else `do no IO`
08:27:24 <gwern> well, I felt compelled to try to catch it all, for the director's commentary on events and also commentary on other series like Death Note
08:27:52 <Saizan> carl: return ()
08:28:26 <carl> lol i was forgetting the return
08:28:46 <carl> i was like wtf this worked before o well i should go to bed thx
08:29:50 <Saizan> gwern: yeah, but if you put all those fast-scrolling writings you probably don't expect them to be fully read either :)
08:30:40 <Saizan> however a split that takes an [a] as delimiter would be nice
08:32:52 <gwern> Saizan: come on. if people are willing to examine each frame of the flashes in End of Evangelion, I think some scribbling visible for a while will be read
08:32:52 <gwern> (although I am very impressed with the fansub group; that was some very good work)
08:36:56 <Saizan> heh, i'm a more relaxed watcher :)
08:43:22 <marcot> The Copyright field in a file contains the name of the person that created the file, or of everyone that have changed it?
08:43:54 <lilachaze> carl: when (a == 2) (putStrLn "yay")
08:45:01 <lilachaze> marcot: usually, the convention is that it lists everyone who holds copyrights for that file
08:45:51 <marcot> lilachaze: which means everyone that changed the file?
08:48:52 <name> is there something like docstrings for haskell?
08:51:16 <Saizan> name: there's haddock
08:51:51 <name> tmx
08:51:53 <name> *tnx
08:53:00 <jpcooper> damn, I miss a good haddock and chips
09:34:10 * SamB_XP subscribes to the rejecta mathematica newsletter...
09:39:59 <chrisdone> woo, my algorithm works!! here's a word cloud of `Software transactional memory' http://img155.imageshack.us/img155/6853/stmwordcloudhb0.png
09:40:49 <Baughn> chrisdone: Hm. The clutsering looks better than most others, too
09:40:59 <Baughn> Though you might want to tone down the size increments a biit
09:41:12 <chrisdone> Baughn: sure, good idea
09:41:27 * Baughn makes delicious pancakes. You can't have any.
09:41:31 <chrisdone> : (
09:41:46 <shepheb> Baughn: damn it, now I want pancakes. argh.
09:41:53 <Saizan> and use a little brighter colours, i couldn't see blu ones
09:42:01 * shepheb remembers that he is completely out of food. curses!
09:42:03 <Baughn> shepheb: Go make some. ;)
09:42:21 <Baughn> What, out of flour, milk and eggs?
09:42:29 <shepheb> the most calorie-loaded thing I have is some sugarfree gum
09:42:35 <shepheb> Baughn: yes.
09:42:39 <Baughn> ..ah.
09:42:41 <Baughn> Time to graze, then.
09:42:45 <shepheb> I have some butter, iirc.
09:42:54 <mauke> mmh, butter
09:42:56 <shepheb> my landlord has a couple chickens... or I could just walk to the store.
09:43:01 <Baughn> Then I imagine /that/ is the most caloric thing you have
09:43:13 <mauke> eat your fist
09:43:15 <shepheb> yeah, it is. mmm anmal fat.
10:48:00 <audreyt> @seen ncalexan
10:48:01 <lambdabot> I haven't seen ncalexan.
11:00:43 <mdmkolbe|work> A bit off topic, but there are enough geniouses around here that I figure it's worth a shot. Is there an efficient algorithm for the d-dimensional least weight subsequence problem?  In particular if the size of each dimension is n, I'd like to find something in O(n*d) rather than O(n^d) (for which I've already found solutions).  Reasonable restrictions on the problem (e.g. convexity or sparceity) are acceptable.
11:08:03 <geezusfreeek> i know absolutely nothing about the least weight subsequence problem, but it seems to me that it would be impossible to visit every point in a space in O(n*d), which i assume (without context) would be necessary for the problem, no?
11:08:50 <geezusfreeek> hmm, except perhaps for a sparse space i guess
11:09:04 <geezusfreeek> i missed your restrictions qualification
11:09:15 <geezusfreeek> okay, i'll just read up on the problem some time
11:10:41 <mdmkolbe|work> geezusfreeek: yeah, the restrictions are what make it interesting (e.g. line breaking is known linear even though the TeX (i.e. Knuth and Plass) uses a quadradic algorithm (sort of, it's linear in the product of the number of words and the number of words in a line).
11:11:35 <geezusfreeek> do you have any recommended reading on the least weight subsequence problem?
11:12:00 <geezusfreeek> it sounds interesting just based on the name
11:12:00 <mdmkolbe|work> heh, that's what I'm asking all of you for ;-)
11:12:06 <geezusfreeek> :P fine then
11:14:07 <name> would you recommend me buying a book on algorithms?
11:14:49 <mdmkolbe|work> but if you only want to know about the 1D case (which is known linear for convex cost functions), it's basicaly the problem that you have to get from point A to point B in a number of hops (e.g. air plane that needs to refuel) and each hop has some cost (e.g. cost of landing) which depends on the start and end points of the hop.  You want to minimize the total cost.
11:16:00 <mdmkolbe|work> geezusfreeek: Line breaking is another example where each hop coresponds to a single line and the cost is how well the words in that hop fit the line width.
11:16:23 * geezusfreeek is already reading up on line breaking algorithms ;)
11:16:41 <geezusfreeek> i have always been passively curious about TeX's algorithm anyway
11:17:33 <pejo> mdmkolbe, is that problem related to k maximum sums in any way?
11:18:56 <mdmkolbe|work> pejo: IIRC they are both related to the knapsack problem and can both use dynamic programing, but I don't recall the k-max sums problem too well
11:20:22 <pejo> mdmkolbe, if so there's one at http://portal.acm.org/citation.cfm?id=1165000.1165009, but I think Takaoka has a more efficient version.
11:20:24 <lambdabot> Title: Efficient Algorithms for k Maximum Sums
11:20:28 <mdmkolbe|work> geezusfreeek: you and me both.  The bits and peices are easy (Knuth and Plas have a paper on it or start at http://en.wikipedia.org/wiki/Word_wrap), but more complicated parts are not clear (e.g. evening out the columns, etc)
11:20:55 <geezusfreeek> we are looking at the same things
11:22:06 <Abraxas038> in hugs, is the command history saved somewhere, if, let's say, i cause the GC to fail and have to close hugs?
11:23:59 <Abraxas038> i tried sth like "squares!!1000000", squares being a list of squares
11:24:17 <Abraxas038> i got: ERROR - Garbage collection fails to reclaim sufficient space
11:38:35 <Baughn> Abraxas038: Not to my knowledge. Ideally, you fit it all into a .hs file that you can reload, instead of having state that's only in memory
11:40:57 <plutonas> i'm still having trouble making my own version of groupBy using fold, could someone help me out?
11:42:13 <plutonas> looks like this now: myGroupBy f xs = foldr step (last xs) xs
11:42:13 <plutonas>     where step y ys = (mytakeWhile (f y) ys) : [(dropWhile (f y) ys)] <-- but i get type errors
11:52:16 <mdmkolbe|work> @src groupBy
11:52:17 <lambdabot> groupBy _  []       =  []
11:52:17 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
11:52:17 <lambdabot>     where (ys,zs) = span (eq x) xs
11:53:01 <plutonas> mdmkolbe|work: i looked the source
11:53:24 <mdmkolbe|work> bot down! bot down!
11:53:46 <mdmkolbe|work> err .. me needing to "scroll" down, sorry
11:54:14 <mdmkolbe|work> @. src pl gropuBy
11:54:23 <mdmkolbe|work> @. src pl groupBy
11:54:28 <plutonas> hm
11:55:27 <Abraxas038> btw, how can i find out how to use the bot?
11:56:16 <monochrom> You have to sign up with a mentor.
11:56:26 <monochrom> Then wipe floors for him every night.
11:56:44 <monochrom> Then eventually he's away and you get to read his magic spell book.
11:56:47 <Abraxas038> why can't one get a straight answer in IRC :D
11:57:02 <Saizan> @list
11:57:03 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
11:57:04 <monochrom> Then you misapply a spell and lambdabot keep forking itself.
11:57:30 <monochrom> Then you play Paul Dukas's music very loud.
11:57:34 * shepheb thinks "spell" would've been a better name for "function"
11:57:53 <chrisdone> ‚ÄúWe conjure the spirits of the computer with our spells.‚Äù ‚Äî Jay `Gerald` Sussman
11:58:33 * monochrom goes listen to Paul Dukas's music.
11:58:51 <plutonas> why can't someone give me a hint on groupBy using fold? what did i do wrong in the idea?
11:59:20 <monochrom> I don't understand groupBy or fold.
11:59:30 <plutonas> :)
12:00:21 <Abraxas038> hello, fellow n00b
12:00:32 <monochrom> "The Functional Programmer's Apprentice"
12:00:48 <Abraxas038> thx saizan =)
12:01:41 <twanvl> plutonas: you can't use takeWhile / dropWhile there, because the fold already loops over the entire list, you now have a nested loop.
12:02:16 <plutonas> hm
12:03:39 <Abraxas038> does the :gc in hugs have any use? i mean, because once i jammed hugs with "squares!!<outrageus number>" it couldn't help, either
12:04:13 <Abraxas038> *outrageous
12:04:32 <monochrom> No amount of GC can erase such top-level bindings as your squares.
12:04:53 <twanvl> plutonas: writing groupBy without foldr is probably easier
12:05:08 <monochrom> So you cause squares to bind to a billion-long list. GC is not entitled to erase that.
12:05:29 <plutonas> twanvl: i know, but i'm just learning haskell, and this book.realworldhaskell.org thing has it as an exercise
12:05:37 <plutonas> it's the only until this point i can't do
12:05:39 <plutonas> :S
12:05:48 <plutonas> although someone commented it's difficult on it
12:05:53 <monochrom> That is an outworldly exercise.
12:07:46 <earthy> 5
12:08:01 <twanvl> The step function should have type  (list-element) -> (result-type-of-groupBy) -> (result-type-of-groupBy).  Since groupBy returns something of type [[a]], that would give step :: a -> [[a]] -> [[a]]
12:08:43 <plutonas> hm
12:08:52 <plutonas> i see
12:09:33 <plutonas> so i seed to call step (last xs) [xs]
12:10:29 <plutonas> but i think this breaks other things
12:10:44 <Saizan> step is what you pass to foldr
12:10:53 <plutonas> yeap, i know
12:11:11 <twanvl> The idea with foldr is that you extend a partial result with another list element, starting with the result you get for an empty list
12:11:32 <twanvl> So you need to answer two questions:
12:11:33 <Abraxas038> but does :gc come in handy in lesser cases?
12:11:38 <plutonas> twanvl: i don't think so, but do you think that foldl would be better?
12:11:46 <twanvl> 1. what is groupBy f []
12:11:56 <Abraxas038> or could i try it 1000 times and might clean up again :D
12:12:05 <plutonas> twanvl: i have this, it's []
12:12:21 <twanvl> 2. if you know  groupBy f xs, how do you determine groupBy f (x:xs) ?
12:17:35 <name> wher is my mistake: http://paste.pocoo.org/show/79258/ Gives me a type error
12:18:42 <sjanssen> name: if not (divideable nmb x)
12:19:29 <twanvl> name: Or rather, use the && operator
12:20:02 <sjanssen> divideable x y = x `mod` y == 0
12:20:21 <sjanssen> (your current code is correct, but the if statement is redundant)
12:23:45 <name> and what's wrong now? http://paste.pocoo.org/show/79259/
12:24:05 <sjanssen> (x+1)
12:24:10 <name> uh :)
12:25:51 <name> how do i get the last item of a list?
12:26:01 <sjanssen> last
12:26:02 <twanvl> > last [1,2,3]
12:26:04 <lambdabot>  3
12:27:06 * plutonas gives up on groupBy, perhaps he'll come back on it later
12:31:04 <schme_> plutonas: I have a horribly ugly solution for that around somewhere :)
12:31:30 <schme_> plutonas: I could see if I can find it if you wan
12:31:32 <schme_> t
12:31:45 <plutonas> schme_: sure. So you managed to do it!
12:32:30 <name> yay i wrote the first program that makes some sense in Haskell :)
12:32:39 <plutonas> name: makes sense?
12:32:56 <name> computes something
12:33:18 <plutonas> what does it compute?
12:33:44 <monochrom> a computable function.  *duck*
12:33:45 <name> the first number that is divideable trough all items of a list of numbers
12:34:42 <mauke> > lcm [10, 24, 5, 15]
12:34:43 <lambdabot>   add an instance declaration for (Integral [t])
12:34:47 <mauke> er
12:34:52 <mauke> > foldr1 lcm [10, 24, 5, 15]
12:34:53 <lambdabot>  120
12:36:16 <schme_> plutonas: grepping for it right now.
12:36:26 <plutonas> schme_: thanks
12:40:56 <name> oh that's built-in and i wrote a stupid slow algorithm :)
12:42:41 <SamB_XP> name: which is built-in ?
12:42:46 <name> integral
12:42:56 <SamB_XP> ???
12:43:09 <mauke> @seen integral
12:43:10 <lambdabot> integral is in #perl6 and #haskell. I don't know when integral last spoke.
12:43:19 <name> lcm function
12:43:24 <name> isn't that the integral?
12:43:32 <SamB_XP> what the ???
12:43:48 <sjanssen> name: lcm means least common multiple
12:43:50 <SamB_XP> integral is sort-of inverse of differentiation
12:44:03 <name> ahh i mixed something
12:44:10 <name> sry about that
12:45:09 <name> i don't know these math things in english :)
12:45:45 <mauke> http://dict.leo.org/ende?search=kgv
12:45:46 <lambdabot> Title: LEO Ergebnisse f¸r "kgv"
12:46:13 <name> ah leo knows these
12:46:30 <name> good ;)
12:46:37 <name> wouldn't have thought
13:08:43 <name> http://paste.pocoo.org/show/79269/ <- where's the problem? n/2 has to be an Integer still it gives me a type error
13:09:19 <kpreid> name: types don't know anything about values
13:09:29 <kpreid> @type /
13:09:30 <lambdabot> parse error on input `/'
13:09:32 <kpreid> @type (/)
13:09:33 <lambdabot> forall a. (Fractional a) => a -> a -> a
13:09:38 <kpreid> name: use n `div` 2 instead
13:09:56 <kpreid> @type quotRem
13:09:57 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
13:09:59 <kpreid> or that
13:10:16 <kpreid> > quotRem 17 5
13:10:18 <lambdabot>  (3,2)
13:10:50 <kpreid> @let nextArgument n = if n `mod` 2 == 0 then n `div` 2 else 3 * n + 1
13:10:51 <lambdabot> Defined.
13:10:59 <kpreid> @undefine
13:11:00 <lambdabot> Undefined.
13:11:29 <kpreid> @let nextArgument n = if r == 0 then q else 3 * n + 1 where (q,r) = quotRem
13:11:30 <lambdabot> Couldn't match expected type `(t, t1)'
13:11:34 <kpreid> @let nextArgument n = if r == 0 then q else 3 * n + 1 where (q,r) = quotRem n
13:11:35 <lambdabot> Couldn't match expected type `(t, t1)'
13:11:52 <kpreid> uh...duh
13:11:54 <kpreid> @let nextArgument n = if r == 0 then q else 3 * n + 1 where (q,r) = quotRem n 2
13:11:55 <lambdabot> Defined.
13:14:45 <Abraxas038> name, whatever, built-in or not, it's practice =)
13:16:12 <Abraxas038> i try that now
13:17:08 <name> hm how do i tell a function that i need the tail element and the rest of a list?
13:18:17 <name> like (x:xs) only the other way round
13:19:02 <mauke> can't do that with pattern matching
13:19:12 <mauke> > (init "name", last "name")
13:19:14 <lambdabot>  ("nam",'e')
13:21:37 <kpreid> @let unsnoc [x,y] = (y, x); unsnoc x:y:xs = fmap (x:) $ unsnoc (y:xs)
13:21:37 <lambdabot>  Parse error in pattern
13:21:53 <kpreid> @let unsnoc [x,y] = (y, x); unsnoc (x:y:xs) = fmap (x:) $ unsnoc (y:xs)
13:21:54 <lambdabot> <local>:2:53:     Occurs check: cannot construct the infinite type: t = [t]  ...
13:22:27 <kpreid> @let unsnoc [x,y] = (y, [x]); unsnoc (x:y:xs) = fmap (x:) $ unsnoc (y:xs)
13:22:27 <lambdabot> Defined.
13:22:34 <kpreid> > unsnoc "name"
13:22:35 <lambdabot>  ('e',"nam")
13:22:39 <kpreid> yay
13:22:54 <kpreid> oh hm, can simplify
13:22:56 <kpreid> @undefine
13:22:57 <lambdabot> Undefined.
13:23:16 <kpreid> @let unsnoc [x,y] = (y, [x]); unsnoc (x:xs) = fmap (x:) $ unsnoc xs
13:23:17 <lambdabot> Defined.
13:23:24 <kpreid> > unsnoc "name"
13:23:25 <lambdabot>  ('e',"nam")
13:23:44 <kpreid> name: how do you like that? :)
13:26:13 <name> kpreid: huh :D
13:34:02 <Abraxas038> hey name, here's mine: http://hpaste.org/8886
13:34:10 <Abraxas038> what does your look like?
13:42:24 <name> Abraxas038: lot worse
13:43:23 <misterbeebee>  Why does this fail? (Network IO)
13:43:23 <misterbeebee> http://hpaste.org/8887
13:43:32 <misterbeebee> main = connectTo "google.com" (PortNumber 80) >>= hGetChar  >>=  putStrLn . show
13:43:36 <Abraxas038> hold on, it was too slow
13:43:57 <Abraxas038> replace with: my_lcm list =  ([n| n<-[max_value, 2*max_value..], is_cm n list]!!0) where max_value = maximum list
13:44:23 <profmakx> j,
13:44:28 <profmakx> hm
13:44:36 <jre2> @seen dons
13:44:36 <lambdabot> dons is in #arch-haskell, #xmonad, #ghc and #haskell. I last heard dons speak 10h 18m 6s ago.
13:44:38 <Deewiant> hmm, how would one get every possible list that is constructible from a given list, in a tree? E.g. f [1,2] = [Node 1 [Node 1 [...], Node 2 [...]], Node 2 [...]] (i.e. [those that start with 1 [that continue with 1...], that start with 2 [...]])
13:45:00 <profmakx> there is a nice and clean algorithm for lcm
13:46:32 <Abraxas038> yeah, we know, we are practicing =)
13:47:19 <mauke> :t fix (map . flip ?node)
13:47:21 <lambdabot> forall a (f :: * -> *) c. (?node::a -> (f a -> f c) -> c, Functor f) => f a -> f c
13:48:01 <name> how do i get the largest element of a list?
13:48:09 <mauke> name: maximum
13:48:14 <monochrom> misterbeebee: the HTTP requires the client, your program, to send stuff first.
13:48:45 <Abraxas038> name: look above, i used it to replace the old line
13:48:49 <misterbeebee> oh, do.
13:49:24 <misterbeebee> I tested with "telnet google.com 80",  but all the initial output was from telnet, not the server. oops
13:50:45 <monochrom> Heh
13:51:26 <Mr_Awesome> mauke: whoa, whats this ?node mean?
13:51:30 <SamB_XP> misterbeebee: should have used nc!
13:51:34 <misterbeebee> arg. "127.0.0.1" works for connectTo, but "localhost" doesn't
13:51:41 <misterbeebee> nc?
13:51:49 <misterbeebee> oh
13:51:52 <SamB_XP> the command provided by the netcat program
13:52:08 <misterbeebee> well, my point is that i'm writing a haskell program. my hpaste was my simplest bug repro
13:56:08 <kpreid> Mr_Awesome: "implicit parameters"
13:56:38 <profmakx> @src minimum
13:56:38 <lambdabot> minimum [] = undefined
13:56:38 <lambdabot> minimum xs = foldl1 min xs
13:56:43 <misterbeebee> if  "localhost" is not working as a hostname for Network / Network.Sockets, is that a flaw in the library, a misconfiguration of my OS, or just how the world works?
13:57:26 <Mr_Awesome> kpreid: hmm. never heard of them
13:57:34 <wuxia> for x :: T, why does return x have type IO T ? I had a C function ending with "return x"; it would have type T
13:58:24 <kpreid> Mr_Awesome: it's an uncommonly used GHC extension
13:58:34 <kpreid> wuxia: because return means something completely different
13:58:42 <kpreid> > do return 1; return 2
13:58:44 <lambdabot>   add an instance declaration for (Show (t t1))
13:58:46 <wuxia> what exatcly does it mean?
13:58:48 <kpreid> er
13:58:54 <kpreid> > do return 1; return 2 :: [Int]
13:58:56 <lambdabot>  [2]
13:59:08 <kpreid> "return 1; return 2" in C would return 1, of course
13:59:12 <Mr_Awesome> wuxia: it basically wraps the value to which it is applied in a monad
13:59:14 <kpreid> "return" is not a control flow operator in Haskell
13:59:26 <kpreid> it's just a type transition
13:59:29 <kpreid> @type return
13:59:30 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
13:59:33 <kpreid> @type fromIntegral
13:59:35 <lambdabot> forall a b. (Num b, Integral a) => a -> b
13:59:37 <Mr_Awesome> if you dont understood exactly what "return" does, you would do well to read a bit about monad theory
13:59:38 <kpreid> same sort of thing
13:59:52 <kpreid> return is for when you have a value not in the monad and want it in
14:01:18 <name> http://paste.pocoo.org/show/79274/ <- This blows the recursion limit. Why?
14:03:56 <monochrom> name: which function should I call to begin?
14:04:11 <name> getArguments [1..10^6]
14:05:49 <monochrom> First improvement: replace "maximum" by "foldl1' max".  need to import Data.List
14:07:37 <wuxia> since sequence has type [IO a] -> IO (); ... how can i build a list of commands that return different things; is that possible?
14:08:04 <monochrom> The whole algorithm is a highly inefficient approach, but I'm too lazy to pick on it.
14:08:35 <name> monochrom: :'(
14:09:42 <name> monochrom: just some tips
14:10:18 <gwern> despair! despair! this world of dog-shed painting over defining ¬¥split¬¥ has left me in despair!
14:10:25 * gwern commits suicide
14:11:20 <monochrom> Some habits from eager imperative languages don't carry over.
14:11:46 <name> was that to me?
14:11:57 <mofmog> I have a string "3 2 3 [1 2 [3] 4] 3 2" for example. I want to words it so that it comes out ["3", "2", "3", "[1 2 [3] 4]", "3", "2']. So far I have this terrible implementation involving replacing anything with brackets on either end to be "[ "++symbol or symbol++" ]".
14:12:18 <monochrom> Consider this homework question: "I give you a list of numbers. You give me back a list with all those numbers doubled."
14:12:30 <dolio> gwern: We now also have two high performance integer-indexed vector libraries based on the DPH arrays. :)
14:12:32 <mofmog> map (*2) list ??
14:12:53 <name> monochrom: map?
14:13:01 <monochrom> Eager imperative habit: create state. initially empty list. go through input list. double numbers, append them to state.
14:13:11 <gwern> dolio: well, I¬¥ll worry about two libraries when the 6 or 7 different sha modules are merged...
14:13:21 <gwern> among other gross redundancies
14:13:21 <mofmog> wouldn't you do that inplace?
14:13:41 <gwern> darcs-curl vs curl is another one, in that case because the darcs-curl code is so impenetrable
14:13:42 <name> monochrom: actually i wouldn't do that i'd use listing comprehensions :)
14:13:42 <mofmog> oh wait it's a list not an array
14:13:42 <dolio> :)
14:14:07 <monochrom> Lazy pure habit: yes map, but look at what map does.  Go through input list, start outputting right away.
14:14:42 <monochrom> If you say "list comprehension" you still need to look at what that does.
14:15:37 <monochrom> If I look at your code and see lots of appends, especially appending singletons, "oldlist ++ [x]", I wonder if you are still using eager imperative habits.
14:16:03 <name> monochrom: i guess
14:17:04 <name> monochrom: just started with this today so
14:19:38 <gbacon> given a list of pairs, how can I augment it with running "m of n" counts?
14:19:45 <monochrom> You're counting "collatz sequence, how many iterations before 1"?  There are two better approaches.
14:20:22 <gbacon> e.g., [(True,True),(True,True),(True,False)] -> [(1,2,True,True), (2,2,True,True), (1,1,True,False)]
14:20:32 <petekaz> Is there a function that takes a pair and applies some other function to it returning a new pair?  something like (a->b) -> (a,a) -> (b,b)?
14:20:47 <gbacon> ?hoogle  (a->b) -> (a,a) -> (b,b)
14:20:48 <lambdabot> No matches, try a more general search
14:20:59 <dolio> @type join (***)
14:20:59 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
14:21:18 <gbacon> @type first (1,2)
14:21:19 <lambdabot>     No instance for (Arrow (,))
14:21:19 <lambdabot>       arising from a use of `first' at <interactive>:1:0-10
14:21:19 <lambdabot>     Possible fix: add an instance declaration for (Arrow (,))
14:21:27 <monochrom> A more beginner approach, still efficient, is don't build the whole sequence. Use an accumulator parameter to count. Use tail recursion.
14:21:28 * gbacon frowns at the bot
14:21:49 <jpcooper> chrisdone, you there?
14:22:19 <jpcooper> does anyone know of some simple image libraries for haskell?
14:22:36 <monochrom> A more advanced approach is build the whole sequence using one function, chop it off at 1 using another function, count length using third function.
14:22:39 <wuxia> window 2
14:23:09 <wuxia> in vim, does anyone have a good/intuitive script for identing haskell files? I find myself having to manually ident lots of things
14:23:16 <monochrom> In the "chop it off at 1" part, recall what map and comprehension do. Don't use eager imperative habit.
14:23:25 <ziman> :t join (***) :: (a->b)->c
14:23:26 <lambdabot>     Couldn't match expected type `c'
14:23:26 <lambdabot>            against inferred type `(a, a) -> (b, b)'
14:23:26 <lambdabot>       `c' is a rigid type variable bound by
14:24:02 <twanvl> mofmog: For your splitting problem, I would sugest you define a function splitBracketed :: Int -> String -> (String, String), that splits a string into two parts at the first space. The int parameter gives a nesting level, when you encounter a '[' the level is increased, with a ']' it is decreased.
14:24:21 <gbacon> monochrom: yeah, I'm trying to exercise my grasp of laziness
14:24:46 <gbacon> monochrom: but the tricky part is that there can be "inner loops" of depth at most one
14:24:51 <mofmog> twanvl: that's what I'md oing but it's a bit messy
14:25:11 <petekaz> so is this *** supposed to work?  I can't tell from the type sig
14:25:57 <ziman> > join (***) (+1) (3,4)
14:25:59 <lambdabot>  (4,5)
14:26:14 <petekaz> oh. I was just doing ***
14:26:18 <petekaz> missed the join part.
14:26:44 <ziman> (***) alone takes two functions
14:27:37 <wuxia> :t Graphic
14:27:38 <lambdabot> Not in scope: data constructor `Graphic'
14:27:39 <petekaz> thanks!
14:28:44 <ballzack3> hello
14:29:38 <jpcooper> anyone?
14:29:47 <jpcooper> have I said something wrong? :)
14:29:59 <ballzack3> hi cooper :)
14:30:08 <dons> feurbach++ !!
14:30:15 <dons> data parallel physics engine videos, http://uk.youtube.com/watch?v=uziCn2SBbxs
14:30:16 <lambdabot> Title: YouTube - Hpysics simulation
14:30:35 <jpcooper> hello
14:30:54 <jpcooper> ballzack3, would you know of some simple graphics libraries for haskell, which can do bitmaps on Linux?
14:30:59 <jpcooper> apparently HGS can't
14:31:15 <ballzack3> so are monads really like assembly line  machines that allow you to apply different functions to different things in similar ways?
14:31:24 <ballzack3> cooper, haha, no way
14:31:38 <dons> jpcooper: bitmaps on linux? how about just using gtk2hs ?
14:31:44 <vixey> ballzack3: yes
14:31:50 <dons> jpcooper: go to hackage.haskell.org, there's also an imlib binding, a gd binding and others
14:31:57 <jpcooper> thanks
14:32:10 <ballzack3> vixey i never really understood the practical use of them
14:32:21 <ballzack3> i do love me some SML, though
14:33:34 <ballzack3> oh yeah, there's this article about lisp not having monads, saying monads allow IO to be purely functional in haskell
14:33:36 <vixey> ballzack3: It's like higher order functions... they might seem useless, but..
14:33:38 <dons> abstracting over the programming environment. we use them to pick and choose which programming language features particular code will run in (continuations + state + backtracking? or logic + state) etc
14:33:52 <ballzack3> but i love higher order functions...
14:34:13 <ballzack3> but isn't IO not purely functional regardelss of monads?
14:35:13 <dons> IO's functional, as they're all World -> (World, Result), functions
14:35:20 <ziman> monads are a way of abstraction that can be applied to io
14:35:21 <dons> if the World parameter wasn't there, it'd be impure.
14:35:44 <ballzack3> how does that make it purely functional?
14:36:08 <jre2> ballzack3: if you give it the same world as input why wouldn't it be?
14:36:25 <dons> http://www.reddit.com/info/6rhm1/comments/ go feurbach
14:36:26 <lambdabot> Title: reddit.com: A data parallel physics engine in Haskell: Summer of Code project: n ...
14:36:49 <ballzack3> you dont always have the same input, that's why io isn't purely functional, afaik
14:36:59 <petekaz> Is this okay haskell coding style?  http://hpaste.org/8888
14:37:10 <mofmog> um same input -> same output is FP
14:37:15 <monochrom> 8888 is a nice number
14:37:34 <dons> looks ok petekaz
14:37:50 <ballzack3> ug...you dont need a program if you always have the same  input and already know the output
14:37:57 <petekaz> I wasn't sure if people actually use a list in do notation often.
14:38:01 <jre2> dons: btw, you have a typo on your blog. 2nd paragraph of latest entry ends with "and letting your simply and quickly get your work done."
14:38:11 <vixey> ballzack3: Oh?
14:38:11 <dons> ah thanks jre2
14:38:25 <ballzack3> vixey i could just paste the results soewhere then
14:38:26 <vixey> ballzack3: So calculators aren't useful?
14:39:03 <ballzack3> they arent always given the same input...
14:39:37 <ballzack3> if all i ever gave my calculator was 9+1 then no, it wouldnt be useful
14:39:52 <vixey> no, every time you input 9+1 it outputs 10
14:40:13 <vixey> that's what's meant by pure functional
14:40:19 <dons> http://www.reddit.com/info/6rhmc/comments/ also nice
14:40:20 <lambdabot> Title: reddit.com: Tail-Recursive, Linear-Time Fibonacci via Fold Fusion
14:40:20 <ballzack3> i understand that
14:40:39 <jre2> ballzack3: but all possible inputs are already known at the time the device was made.
14:40:50 <ballzack3> but i thought IO wasnt purely functional because you dont know what the user is going to input, so different runs have different results
14:41:13 <ballzack3> and i dont see how monads fix that
14:41:18 <dons> ballzack3: in Haskell, one way to implement the IO monad is to give the entire world as input. that's the abstraction trick.
14:41:23 <Baughn> They don't. They just allow you to deal with it
14:41:28 <ballzack3> ok
14:41:34 <dons> so given the same world, you get the same result. and reasoning is preserved.
14:41:42 <SamB> dons: it sucks at threads though
14:41:43 <dons> of course, we don't actually feed the entire world in
14:41:54 <monochrom> You may input 9+1 today, 45*23 tomorrow, 3/4 yesterday...  You input varies, but the calculator is still pure functional.
14:42:04 <SamB> and, well, doesn't work very well if I smash the computer in the middle of the program
14:42:09 <ballzack3> i dont see how monads help that, really
14:42:18 <dons> help what?
14:42:24 <ballzack3> IO
14:42:27 <dons> it turns out that IO is a state monad with the world as a state.
14:42:33 <monochrom> But anyway, I feel that this is silly.
14:42:44 <dons> so if you're in a purely functional language without wired in mutable state, you can implement it as a monad instead.
14:42:53 <SamB> ballzack3: the IO monad makes it okay that you don't know what's going to happen
14:43:05 <ballzack3> samb  how?
14:43:06 <dons> but IO is the least interesting monad, really, since its just a simple state passing monad.
14:43:06 <ziman> monads help deal with the World in a quite elegant way so that the code isn't cluttered with explicit World passing
14:43:20 <Baughn> dons: If we did feed in the world.. could we tell?
14:43:31 <dons> yes, in contrast, look at Clean. and all their world passing glue
14:43:37 <SamB> ballzack3: by making that not break referential transparency
14:43:55 <SamB> there are plenty of ways to accomplish the same thing, some more confusing than others...
14:44:00 <dons> anyway, its important not to get hung up on IO as the canonical monad. its the most boring monad.
14:44:12 <SamB> indeed
14:44:28 <dons> far more interesting are custom monads for things like parsing, logic programming, continuations, transactional memory et al.
14:44:40 <SamB> it's like talking at length about the complexity of the semicolon in C
14:44:52 <vixey> I thought Identity was more boring
14:44:54 <monochrom> haha, that one is complex.
14:45:12 <dons> Identity is pretty useful though, as a taint tracker
14:45:25 <dons> and as a 'id' for monad transformer stacks
14:46:08 <ballzack3> samb how does it not break referential transparency?
14:46:59 <SamB> ballzack3: by seperating evaluation from execution (conceptually)
14:47:14 <jpcooper> Cale, are you there?
14:47:30 <ballzack3> so the IO monad keeps the input separate from the rest of the program?
14:47:39 <Cale> jpcooper: actually, I am
14:47:46 <Cale> jpcooper: what's up?
14:47:57 <jpcooper> I'm having trouble with your imlib binding
14:48:07 <jpcooper> During interactive linking, GHCi couldn't find the following symbol:
14:48:07 <jpcooper>   imlib_context_set_dither_mask
14:48:16 <jpcooper> could this be because I need imlib development headers?
14:48:30 <jpcooper> I thought maybe cabal would have checked for this, but maybe not
14:48:58 <dons> hmm. could also be an incompatibility in the imlib bindings.
14:49:08 <dons> can you compile the code? rather than loading it in ghci/
14:49:40 <SamB> ballzack3: it avoids the need for the same function to return different results for the same value, where by "return", I mean the usual can-be-bound-with-let variety
14:49:48 <ballzack3> if you eventually use your input in the rest of the program, aren't you just shifting the thing that breaks referenial transparancy from one location to another?
14:50:19 <jpcooper> dons, sadly not
14:50:39 <SamB> ballzack3: referential transparency basically just means "my expressions don't randomly decide to have different values at different times"
14:50:40 <dons> do you have imlib installed?
14:50:55 <jpcooper> dons, I have the development headers installed
14:50:55 <monochrom> make sure the "dev" part of imlib is also installed
14:51:03 <ballzack3> samb that's how i was using that term
14:51:03 <jpcooper> yeah
14:51:13 <dons> ballzack3: the key thing is that with the World -> World, a encoding, all optimisations and reasoning continue to work, as if the entire world really had been passed in, and thus the IO is referentially transparent.
14:51:21 <SamB> ballzack3: can you point at an expression that does
14:51:27 <SamB> ?
14:51:27 <dons> as an optimisation, we don't pass the whole world in
14:51:31 <chrisdone> maybe the imlib versions are incompatible
14:51:38 <chrisdone> I'll try imlib here
14:51:39 <ballzack3> samb does what?
14:51:51 <SamB> dons: I thought that world thing was just for humour value
14:52:02 <SamB> ballzack3: randomly return different values
14:53:19 <dons> i'm not sure you're clearing things up for ballzack3, Sam.
14:53:21 <ballzack3> If you do IO, you have some random input that affects your program.
14:53:33 <ballzack3> affects the values of something, somewhere
14:54:44 <ballzack3> if tne IO monad return? (world, input), don't you just later use 'input' to affect the world?
14:54:46 <dons> ballzack3: right. but that input is taken into account by the World parameter to IO functions.
14:55:00 <ballzack3> ok
14:55:01 <dons> ballzack3: no, the world isn't mutated :)
14:55:11 <dons> a new world is created.
14:55:13 <ballzack3> the world doesn't change with time?
14:55:14 <dons> in the model
14:55:17 <ballzack3> oh
14:55:49 <chrisdone> I get
14:55:50 <chrisdone> Loading package Imlib-0.1.1 ... can't load .so/.DLL for: Imlib2 (libImlib2.so: cannot open shared object file: No such file or directory)
14:55:53 <jre2> ballzack3: are you wondering if there's a race condition?
14:55:54 <Baughn> ballzack3: The monad part is used to hide the world, so after making a new one you can no longer access the old version
14:56:06 <Baughn> Just like State. Except unlike state, it doesn't actually pass any state.
14:56:16 <chrisdone> I have installed the imlib and imlib11-dev packages
14:56:30 <chrisdone> installed imlib from `cabal install`
14:56:48 <ballzack3> baugn, you mean how in a >>= b, b can't affect a?
14:56:52 <dons> you might need to rebuild it, if you installed the C deps afterwards.
14:56:55 <monochrom> oh, probably imlib11 /= imlib2
14:57:05 <ballzack3> not that i'm too familiar with >>= :)
14:57:18 <chrisdone> dons: I didn't, I just installed it sequentially. the imlib packages, followed by imlib from hackage
14:57:57 <Baughn> @type (>>=)
14:57:57 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
14:58:09 <monochrom> software is hard. let's go hardwaring.
14:58:28 <chrisdone> dons: I've had this error elsewhere on other packages... I'd be interested in seeing how to solve this problem
14:58:52 <Baughn> chrisdone: ..I'm thinking.
14:58:57 <Baughn> *ballzack3
14:59:12 <ballzack3> :)
15:00:38 <vixey> why doesn't foldM_ have type (a -> b -> m quux) -> a -> [b] -> m ()
15:00:42 <vixey> :/
15:00:56 <chrisdone> :t foldM
15:00:57 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
15:01:08 <chrisdone> good point
15:01:14 <Baughn> :t foldM_
15:01:14 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m ()
15:01:20 <chrisdone> yeah
15:01:38 <Baughn> But it's going to pass the fold's return value back into the next call to the function, right?
15:01:42 <Baughn> So it can't be quux
15:01:48 <vixey> oh yeah Baughn true
15:01:49 <chrisdone> ah
15:02:19 <Baughn> ballzack3: I can't do it. My view of how IO works is based on how it actually works, not the neat mathematical model. :P
15:03:13 <Baughn> ballzack3: The fact is, IO is just a bog-standard procedural language. Nothing fancy. It's the /other/ monads that are useful, and IO is a monad because that make the compiler produce the correct code by pretending it's passing a world
15:03:52 <ballzack3> hah :) I sort of dont see how monads improve on just using curried functions/or just regular functions  in a language that doesnt mutate variables
15:03:54 <Baughn> ballzack3: In do foo; bar it won't call bar before foo, simply because it believes foo is returning a value (the "world") that bar needs. The monad helps.
15:04:09 <ballzack3> ok
15:04:10 <Baughn> ballzack3: But IO functions /do/ mutate variables. ;)
15:04:22 <Baughn> Mostly variables outside your program, but not always - see IORef
15:04:43 <ballzack3> baugn then cant just create new variables?
15:04:49 <ballzack3> they*
15:05:10 <Baughn> If they can't be mutated, they aren't variables, by the way. ;)
15:05:10 <ballzack3> what is this IORef?
15:05:19 <ballzack3> bindings then 8-|
15:05:26 <Baughn> IORef is.. well, basically what every other language calls a "variable"
15:05:44 <Baughn> You usually don't need it.
15:05:58 <ballzack3> in scheme or SML i would assign input to new bindings/values/variables
15:06:33 <Baughn> ballzack3: My advice for you is: Don't worry about it. IO is easy to use; it's the /other/ monads that are hard.
15:06:38 <ballzack3> ok
15:06:44 <Baughn> If you /must/ have the theory right now, you'll need to ask someone else
15:06:50 <ballzack3> ok, no rush
15:07:01 <Baughn> Meanwhile, just treat IO blocks as a different language than the rest of haskell. (They are, effectively)
15:07:31 <gbacon> ?hoogle [a] -> (a,a)
15:07:32 <lambdabot> No matches, try a more general search
15:07:52 <Baughn> gbacon: What's that supposed to do, return its first two values as a tuple?
15:08:04 <ballzack3> the type signatures of monads seem just like the type signatures of HOF's in SML
15:08:07 <Baughn> @djinn [a] -> (a,a)
15:08:07 <lambdabot> -- f cannot be realized.
15:08:34 <lilachaze> Baughn: every time i try that someone says "sadly, djinn can't handle lists" :)
15:08:34 <gbacon> Baughn: something like (,) . take 2 . words
15:08:36 <chrisdone> so I have my function which makes a word cloud of some text, trouble is there are lots of options for it, so I've put them in a config type and put them in the function's monad, what do you think of this? http://hpaste.org/8889
15:08:44 <gbacon> Baughn: of course, that doesn't typecheck
15:08:44 <ziman> :t (head *** (head.tail))
15:08:44 <wuxia> how do i convbert an integer to a floating point? and how do i convert a flaoting point to an inteber?
15:08:46 <lambdabot> forall a a1. ([a], [a1]) -> (a, a1)
15:08:52 <ziman> hm
15:09:00 <vixey> wuxia: realToFrac and fromIntegral
15:09:17 <ziman> :t (head &&& (head.tail))
15:09:18 <lambdabot> forall a. [a] -> (a, a)
15:09:18 <ballzack3> frac the psylons are coming!
15:09:26 <Baughn> gbacon: Little point in that function, I think. Just "take 2" would suffice
15:09:34 <dons> gwern: http://haskell.org/haskellwiki/Bullet
15:09:35 <lambdabot> Title: Bullet - HaskellWiki
15:09:44 <Baughn> gbacon: (Meaning you'll have to write it yourself)
15:10:05 <chrisdone> vixey: how would you do the above?
15:10:32 <vixey> what ?
15:10:40 <wuxia> how do i fix the following? : hexVertices :: Int -> Int -> Int -> [(Int, Int)]
15:10:40 <wuxia> hexVertices x y size = [(x + (cos t / 6.0 * pi), y) | t <- [1..6]]
15:11:25 <vixey> wuxia: Are you sure Int is useful here?
15:11:32 <wuxia> it is
15:11:35 <wuxia> i'm going to multipy it by size
15:11:43 <wuxia> but didn't show it for ismplicity, just to get typing right
15:11:45 <vixey> wuxia: cos t / 6.0 * pi is pretty small
15:11:55 <wuxia> it's going to be size * cos t  ...
15:12:05 <plutonas> schme: probably missed your post
15:12:09 <vixey> ok why don't you paste your actual code in hpaste with the error you get
15:12:13 <wuxia>  vixey: how do i get the typing right?
15:12:21 <plutonas> and it got truncated with the buffer, so i can't see it... did you find the groupBy?
15:13:31 <chrisdone> is there a library with common functions like `io' defined in it? it's odd just defining `io = liftIO' at some place in my file
15:13:31 <vixey> my type checker is 150 lines, 70 are comments
15:13:37 <wuxia> :t cos
15:13:38 <lambdabot> forall a. (Floating a) => a -> a
15:13:47 <wuxia> > cos 1 / 6.0
15:13:49 <lambdabot>  9.005038431135662e-2
15:14:06 <Baughn> chrisdone: There's missingH, but I don't know if it has that one
15:14:07 <wuxia> > hexVertices x y size = [(cos fromIntegral t, y) | t <- [1..6]]
15:14:07 <lambdabot>  Parse error at "=" (column 22)
15:14:17 <chrisdone> Baughn: I'll look at it
15:14:30 <wuxia> > let hexVertices x y size = [(cos fromIntegral t, y) | t <- [1..6]]
15:14:31 <lambdabot>  Parse error at end of input
15:14:56 <vixey> yeah I've seen it on holomorphy
15:15:29 <vixey> wli isn't here.. and there's no index on the site
15:15:30 * vixey sighs
15:17:02 <wuxia> :t round
15:17:04 <wuxia> :t Round
15:17:05 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
15:17:05 <lambdabot> Not in scope: data constructor `Round'
15:17:34 <wuxia> :t realToInt
15:17:35 <lambdabot> Not in scope: `realToInt'
15:19:07 <wuxia> :t realToFrac
15:19:08 <lambdabot> forall a b. (Fractional b, Real a) => a -> b
15:20:38 <wuxia> round realToFrac 1.5
15:20:42 <wuxia> why doesn't tha5t work?
15:20:44 <wuxia> > round realToFrac 1.5
15:20:45 <lambdabot>   add an instance declaration for (Integral (t -> a1))
15:21:10 <lilachaze> > let hexVertices x y size = [(fromIntegral x + cos t / (6 * pi), fromIntegral y) | t <- [1..6]] in hexVertices (1::Int) (2::Int) (3::Int)
15:21:11 <lambdabot>  [(1.0286639275809546,2),(0.9779227246371558,2),(0.9474792668473843,2),(0.965...
15:21:13 <Saizan>  vixey : my type checker is 150 lines, 70 are comments <-- with logical variables? are you going to put that up somewhere?
15:21:28 <vixey> Saizan: oh logic variables are in a different file..
15:22:00 <wuxia> lilachaze: cool; thanks ... one more thing ... how do i convert float's back to integer?
15:22:25 <lilachaze> > round (1.5 :: Double) :: Int
15:22:27 <lambdabot>  2
15:22:44 <vixey> I would like to put it up somewhere but I had some trouble with ssh
15:22:45 <lilachaze> > floor 1.5
15:22:46 <lambdabot>  1
15:23:08 <wuxia> got it; i didn't have proper TY whe i was tyrin got use round
15:23:11 <wuxia> lilachaze: thanks!
15:24:59 <dons> Prelude> let (!) n = product [1..n]
15:24:59 <dons> Prelude> (10 !)
15:24:59 <dons> 3628800
15:25:16 <dons> Prelude> (10!)
15:25:16 <dons> 3628800
15:25:40 <ziman> :t (!)
15:25:41 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
15:26:04 <lilachaze> > let (!) n = product [1..n] in (-10!)
15:26:05 <lambdabot>      The operator `!' [infixl 9] of a section
15:26:05 <lambdabot>         must have lower precede...
15:26:23 <dons> -XPostfixOperators
15:26:23 <wuxia> how can I make the following shorter: seems like I can factor out some of the code: hexVertices x y size = [( x + (round $ fromIntegral size * cos (fromIntegral t / 6.0 * pi)), ( y + (round $ fromIntegral size * sin (fromIntegral t / 6.0 * pi)))) | t <- [1..6]]
15:26:52 <vixey> :t realToFrac
15:26:53 <lambdabot> forall a b. (Fractional b, Real a) => a -> b
15:26:59 <vixey> :t realToFrac.fromRational
15:27:00 <lambdabot> forall b. (Fractional b) => Rational -> b
15:28:42 <dons> http://www.reddit.com/info/6rhqx/comments/
15:28:43 <lambdabot> Title: reddit.com: Postfix operators for Haskell: you can now write factorial as 10!
15:29:15 <vixey> what!
15:29:17 <vixey> dons: what's set -XPostfixOperators
15:29:34 <dons> hmm?
15:29:43 <vixey> *Main> :set -XPostfixOperators
15:29:43 <vixey> unrecognised flags: -XPostfixOperators
15:30:01 <dons> ah, it was only added today
15:30:04 <dons> use -fglasgow-exts instead
15:30:19 <vixey> ~_~
15:30:40 <vixey> your example works without extensions......
15:30:45 <Igloo> You've been able to do it for ages: http://www.haskell.org/ghc/docs/6.6/html/users_guide/syntax-extns.html#postfix-operators
15:30:48 <lambdabot> Title: 7.3. Syntactic extensions, http://tinyurl.com/5w5kaa
15:31:06 <vixey> oh ok
15:31:09 <dons> yep. i figure its just under appreciated.
15:31:09 <Igloo> I just fixed a buglet in that it was always allowed
15:31:40 <dons> yep
15:33:08 <TomMD> Was there any decision about a time and DAY for GHC meetings?
15:33:21 <dons> nope. just 1 suggestion
15:33:34 <lilachaze> let hexVertices x y size = [let r = fromIntegral size; theta = fromIntegral t / 6.0 * pi in (x + (round $ r * cos theta), y + (round $ r * sin theta)) | t <- [1..6]] -- wuxia
15:33:46 <Igloo> If you're interested you should reply, even if just to show that there is interest
15:34:02 <TomMD> I'm far from a GHC developer though.
15:34:17 <fiddlerwoaroof> wuxia: http://hpaste.org/8890
15:35:21 <gwern> dons: aye, I know of Bullet
15:35:42 <wuxia> fiddlerwoaroof: omg, that's awesome, when i first saws helper cos t, i thought 'this guy is an idiot, cos t is not what i want' then i look at helper, and i see that it transforms t before passing it to cos; cool; thanks
15:36:20 <Igloo> I don't think there'll be an entrance exam or anything  :-)
15:36:21 <fiddlerwoaroof> wuxia: you're welcome
15:37:02 <fiddlerwoaroof> Itcould be further simplified along the same lines
15:37:33 <chrisdone> so does anyone know what to do about this ghci error? can't load .so/.DLL for: pthread (/usr/lib/libpthread.so: invalid ELF header) the .so file is actually some link script not the actual .so which is .so.0 I think. what can do I do to tell ghci to load the real file?
15:37:46 <dons> chrisdone: which library is that?
15:38:09 <dons> some libs incorrectly list pthread as a dependency. removing that from the extra-libs: line of the .cabal file fixes this error.
15:38:16 <chrisdone> dons: well it's libgd, but I've googled and people using other libs that use pthread had this problem
15:38:20 <dons> yes, libgd.
15:38:30 <dons> remove 'pthreads' from the haskell gd's cabal file.
15:38:36 <chrisdone> dons: righto! :DD
15:38:39 <dons> then everything works (we hit this at work this week)
15:38:48 <chrisdone> dons: ahhh. thanks a lot :)
15:39:10 <dons> Igloo: i think that's a collision between ghci's linker not being able to grok linker scripts, and thus not being able to tell that pthreads is already linked.
15:39:30 <lilachaze> wuxia: hexVertices x y size = do
15:39:30 <lilachaze>   t <- [1..6]
15:39:30 <lilachaze>   let r     = fromIntegral size
15:39:30 <lilachaze>       theta = fromIntegral t / 6.0 * pi
15:39:43 <chrisdone> dons: that's what I read on the maliing list post that I read
15:39:50 <lilachaze> sorry all, not what i wanted to paste :(
15:39:58 <Igloo> dons: ghci not working with linker scripts is a known problem. There's a trac ticket with a messy solution, I think
15:40:17 <lilachaze> wuxia: http://hpaste.org/8890 annotated with another possible refactoring
15:41:07 <wuxia> lilachaze: cool thanks; i'm being greedy here, iks it possible to fold the let r / theta into a list comprehension?
15:41:50 <lilachaze> like this you mean: hexVertices x y size = [let r = fromIntegral size; theta = fromIntegral t / 6.0 * pi in (x + (round $ r * cos theta), y + (round $ r * sin theta)) | t <- [1..6]]
15:42:21 <wuxia> yhmm okay; what you had pasted looks more readable, i'll stick with the non-list-comprehension one
15:42:42 <dons> Igloo: right. so this is to be expected.
15:42:49 <lilachaze> wuxia: list comprehensions and do-notation for the list monad are pretty similar anyway :)
15:43:16 <wuxia> http://hpaste.org/8892 <-- i wrote two functikons, for extracting every other element of a list; but clearly they're not well written; can someone help me shorten them?
15:43:33 <ballzack3> there should be an unzip funtion somewhere
15:44:07 <vixey> wuxia: they are fine
15:44:16 <vixey> wuxia: How would you have liked to write them?
15:44:24 <wuxia> each using only one line
15:44:30 <wuxia> seems like a very simple concept
15:44:32 <fiddlerwoaroof> muxia: more shortening in http://hpaste.org/8890
15:44:33 <chrisdone> dons: hmm, I removed pthread from the dependancies and rebuilt and reinstalled and the same load error occurs in a fresh ghci. what now?
15:44:34 <vixey> how about this,
15:44:36 <wuxia> there has to be built in functions that i can use
15:44:42 <vixey> getEven = map fst . pairUp
15:44:47 <opqdonut> wuxia: no that's pretty idiomatic and nice
15:44:48 <vixey> getOdd = map snd . pairUp
15:44:55 <lilachaze> wuxia: you can rewrite getOdd as getEven . tail
15:44:56 <vixey> wuxia
15:45:03 <lilachaze> or possibly vice versa :)
15:45:14 <vixey> lilachaze: why not both :P
15:45:26 <vixey> getOdd = getEven . tail ; getEven = getOdd . tail
15:45:28 <ballzack3> doesn't whether you're actually getting odd or even depend on the length of the list?
15:45:34 <dons> chrisdone: you fixed 'gd', rebuilt and reinstalled it?
15:45:42 <chrisdone> dons: right
15:45:44 <dons> then cleaned your app that uses gd, and built it?
15:45:53 <lilachaze> vixey: i can't tell if you're kidding, but i do like the idea :)
15:46:08 <dons> so that worked for me on thursday. just double check its using the new lib, that doesn't have pthread as a dep.
15:46:12 <chrisdone> dons: I'm loading it in ghci, that's where the problem occurs. I didn't clean the .os though. I'll do that
15:46:13 <ballzack3> oh nevermind
15:46:31 <ballzack3> there's no library with an unzip function?
15:46:44 <dibblego> ?type unzip
15:46:46 <lambdabot> forall a b. [(a, b)] -> ([a], [b])
15:46:46 <vixey> hmm
15:46:52 <dibblego> ?info unzip
15:46:53 <lambdabot> unzip
15:46:57 <dibblego> ?index unzip
15:46:58 <lambdabot> Data.List, Prelude
15:47:25 <vixey> is there a symbol I might use, instead of x ‚â° y, but x 'R' t, which makes a copy of t then does x ‚â° t' ?
15:47:36 <vixey> I'm not sure if there's a common symbol for that kind of thing ...
15:47:40 <dons> chrisdone: yes, following that process fixed exactly this for me in ghci.
15:48:06 <vixey> oh I guess
15:48:07 <vixey> ‚áê
15:48:30 <chrisdone> dons: I think I installed gd with `cabal install', just now I've downloaded the package .tar.gz to edit it manually and installed. will ghci be looking at the cabal version? O_o
15:49:03 <lilachaze> > let odds l = maybe [] (:evens (tail l)) (listToMaybe l); evens = odds . drop 1 in odds "Hello world"
15:49:04 <lambdabot>  "Hlowrd"
15:49:06 <dons> it might make sense to unregister any previous version, yes.
15:49:39 <ballzack3> is there a function that would pair up items in a list so that the paired up list could be fed to unzip?
15:49:52 <chrisdone> heh, doesn't seem cabal has an unregister function. i guess I'll try ghc-pkg
15:49:53 <fiddlerwoaroof> ?type zip
15:49:54 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
15:49:55 <dons> ballzack3: zip :)
15:50:03 <opqdonut> no he doesn't mean that
15:50:03 <ballzack3> oh nice :)
15:50:07 <lilachaze> vixey: ^^ is that what you had in mind?
15:50:11 <dons> that's so cool you asked for an inverse of unzip :)
15:50:17 <ballzack3> i mean [a] -> [(a,a)]
15:50:25 <opqdonut> he wants [a,b,c,d] -> [(a,b),(c,d)]
15:50:33 <ballzack3> or [(a_1, a_2)]
15:50:33 <dons> ah right.
15:50:36 <ballzack3> yeah
15:50:38 <vixey> lilachaze: neat
15:50:58 <vixey> lilachaze: actually that's much better than what I was thinking of :)
15:51:06 <dons> > let f [] = [] ; f [x] = [(x,x)]; f (x:y:xs) = (x,y) : f xs in f "haskell"
15:51:07 <lambdabot>  [('h','a'),('s','k'),('e','l'),('l','l')]
15:51:32 <fiddlerwoaroof> > let f [] = [] ; f [x] = [(x,x)]; f (x:y:xs) = (x,y) : f xs in f "haskel"
15:51:33 <lambdabot>  [('h','a'),('s','k'),('e','l')]
15:51:45 <dons> > let s = "haskell" in zip s (tail s)
15:51:47 <lambdabot>  [('h','a'),('a','s'),('s','k'),('k','e'),('e','l'),('l','l')]
15:51:47 <lilachaze> > let odds l = maybe [] (:evens (tail l)) (listToMaybe l); evens = odds . drop 1; pairUp xs = zip (evens xs) (odds xs) in pairUp "Hello world"
15:51:49 <lambdabot>  [('e','H'),('l','l'),(' ','o'),('o','w'),('l','r')]
15:52:01 <opqdonut> > map head . iterate (tail.tail) $ "haskell rules"
15:52:02 <lambdabot>  "hselrlsException: Prelude.tail: empty list
15:52:04 <ballzack3> zips s drop(2,s) ?
15:52:20 <opqdonut> ballzack3: try something like mine
15:52:36 <opqdonut> > map head . iterate (tail.tail) $ "haskell rules!"
15:52:37 <lambdabot>  "hselrlsException: Prelude.head: empty list
15:52:40 <ballzack3> what's iterate?
15:52:52 <opqdonut> > iterate (+2) 3
15:52:53 <lambdabot>  [3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,5...
15:52:55 <SamB> isn't the H supposed to be one of the evens?
15:52:58 <chrisdone> dons: I unregistered with ghc-pkg and then reinstalled the gd package and I still get the error :( ghc-pkg describe shows that pthread is no longer in the dependancies, so..
15:53:12 <ballzack3> what's $?
15:53:23 <chrisdone> right associative application
15:53:23 <ballzack3> haskell has so much weird crap like $
15:53:29 <chrisdone> :t ($)
15:53:30 <lambdabot> forall a b. (a -> b) -> a -> b
15:53:34 <lilachaze> @src ($)
15:53:34 <lambdabot> f $ x = f x
15:53:37 <opqdonut> f $ x is just f (x)
15:53:40 <SamB> wrongly-associative, even
15:53:45 <opqdonut> evades parenthesis
15:53:49 <dibblego> it's not weird, just different to what you're used to
15:53:50 <ballzack3> oh
15:54:06 <ballzack3> that's what i mean
15:54:10 <vixey> :t foldr
15:54:11 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
15:54:29 <chrisdone> ._.
15:54:50 * vixey laughs
15:55:02 <vixey> ever seen C++?
15:55:04 <dons> chrisdone: is it possibly you're using another library that depends on pthreads too?
15:55:04 <Armored_Azrael> Anyone know how to get the value in picoseconds out of nominaldifftime?
15:55:13 <dons> or something else built against the old gd?
15:56:55 <chrisdone> I don't know. nothing I know of uses gd. I'm just loading one stand-alone file in ghci and I get: Loading package gd-3000.4.0 ... can't load .so/.DLL for: pthread (/usr/lib/libpthread.so: invalid ELF header)
15:57:46 <SamB> chrisdone: and does it have an invalid ELF header?
15:57:55 <SamB> hint: run file on it
15:58:00 <wuxia> are there bulit in functions for getting nth element of a list?
15:58:21 <SamB> wuxia: ITYM bulat
15:58:28 <wuxia> ITYM ?
15:58:34 <SamB> I think you mean
15:58:39 * SamB was kidding
15:58:40 <wuxia> :t bulat
15:58:41 <lambdabot> Not in scope: `bulat'
15:58:42 <chrisdone> SamB: yes, it's some linker script: /usr/lib/libpthread.so: ASCII C program text
15:58:48 <SamB> wuxia: that's a guy's name
15:59:04 <SamB> chrisdone: well GHCi can't load those
15:59:07 <chrisdone> /* GNU ld script \n OUTPUT_FORMAT(elf32-i386) \n GROUP ( /lib/libpthread.so.0 /usr/lib/libpthread_nonshared.a )
15:59:12 <pantsd> I'm a pirate ninja! (aka my code works for a change :))
15:59:19 <chrisdone> I know, I don't want it to. I want it to load the proper thing
15:59:23 <dons> chrisdone: can you construct a minimal program that displays it?
15:59:30 <dons> preferably something that only links against haskell-gd
15:59:38 <wuxia> so if I want to cycle thro7ugh a list of 6 colors at different levels of recursion (drawing fractals) ... should i represent the colors as a list and get the nth element of the likst, or is there a better wsay to do this?
15:59:40 <chrisdone> dons: of course, one minute
16:00:42 <ballzack3> what's a good haskell turoial?
16:00:49 <wuxia> haskell school of ecpression
16:00:51 <lilachaze> > foldr (\v (a,b) -> (v:b,a)) ([],[]) "Hello World"
16:00:52 <wuxia> expression
16:00:53 <lambdabot>  ("HloWrd","el ol")
16:01:11 <SamB> dons: why does he need a program?
16:01:17 <lilachaze> @pl \v (a,b) -> (v:b,a)
16:01:17 <SamB> what does ghc-pkg describe have to say?
16:01:18 <lambdabot> (`ap` snd) . (. fst) . flip . ((,) .) . (:)
16:01:34 <wuxia> :t fst
16:01:35 <lambdabot> forall a b. (a, b) -> a
16:01:58 <Saizan> wuxia: use (cycle colors), at each level you use the head of it and pass the tail in the recursive call
16:02:01 <lilachaze> @type uncurry flip
16:02:02 <lambdabot> forall a b c. (a -> b -> c, b) -> a -> c
16:02:22 <wuxia> > cycle [1, 2, 3, 4, 5]
16:02:23 <lambdabot>  [1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3...
16:02:34 <dons> import *.Gd ; main = print $ newImage (3,3) should be enough.
16:02:49 <wuxia> saizan: omg, so i'm using an infinite list? this is so cool
16:03:15 <ballzack3> any good, free, online tutorial for haskell?
16:03:18 <Saizan> yeah :)
16:03:19 <fiddlerwoaroof> ballzack3: http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf was the best one I found
16:03:21 <lambdabot> Title: Yet Another Haskell Tutorial
16:03:21 <dibblego> @where yaht
16:03:22 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
16:03:23 <ballzack3> thanks
16:03:27 <SamB> ballzack3: no, I ate them all
16:03:32 <ballzack3> Tradition, hey!
16:05:13 <fiddlerwoaroof> ballzack3: http://en.wikibooks.org/w/index.php?title=Haskell/Understanding_monads&oldid=933545 was the first description of 'Monads' I understood
16:05:14 <lambdabot> http://tinyurl.com/5eldgd
16:05:46 <ballzack3> thanks
16:06:08 <chrisdone> mmkay, hpaste isn't notifying today
16:06:09 <chrisdone> dons: http://hpaste.org/8893
16:08:17 <chrisdone> dons: does it do it for you?
16:08:21 <vixey> which is the front and which is the back end of a compile *-*
16:08:24 <vixey> compiler
16:08:30 <dons> ok, i can reproduce it,
16:08:30 <dons> $ ghci A.hs
16:08:30 <dons> *Main> main
16:08:31 <dons> can't load .so/.DLL for: pthread (/usr/lib/libpthread.so: invalid ELF header)
16:08:35 <dons> now let's see if fixing gd helps.
16:08:39 <chrisdone> oki
16:10:39 <SamB> why doesn't ghci call on libdl to open C libraries, anyway?
16:10:40 <dons> $ vim *.cabal
16:10:40 <dons> $ cabal install
16:10:45 <dons> $ ghci A.hs
16:10:45 <dons> *Main> main
16:10:45 <dons> *Main>
16:10:46 <dons> fixed.
16:10:59 <dons> my gd.cabal now has,   Extra-libraries: gd, png, z, jpeg, m, fontconfig, freetype, expat
16:11:04 <dons> and then i ran: cabal install
16:11:09 <dons> to rebuild it it and install / registe.r
16:11:21 <dons> chrisdone: ^
16:11:50 <chrisdone> ok I'll try that
16:12:05 <dons> that's not what you did?
16:12:23 <chrisdone> well I did runhaskell Setup.* install
16:12:35 <chrisdone> not cabal install
16:13:16 <dafra_> dons: package cairo-0.9.13 requires bytestring-0.9.0.1.1
16:13:25 <dafra_> dons: i cant find 0.9.0.1.1
16:13:41 <dafra_> only 0.9.0.1 is on hackage
16:14:16 <chrisdone> dons: yaaay. running `sudo cabal install' fixed it
16:14:39 <chrisdone> dons: what did using cabal do differently to runhaskell Setup.*?
16:14:51 <dons> well, it registers as --user
16:15:02 <dons> dafra_: hmm? 0.9.1.0 is on hackage.
16:15:09 <chrisdone> I run them both as root
16:15:33 <dafra_> i have 0.9.1.0 installed
16:16:03 <dafra_> i cant find this 0.9.0.1.1
16:16:06 <chrisdone> dons: thanks, much appreciated :]
16:16:28 <dons> great.
16:17:06 <vixey> > let (f && g) (x , y) = liftM2 (,) (f x) (g y) in ([1,2] && "xyz" && ["foo","bar"])
16:17:07 <lambdabot>  Couldn't match expected type `t -> m a1'
16:17:24 <vixey> > let (f && g) = liftM2 (,) f g in ([1,2] && "xyz" && ["foo","bar"])
16:17:24 <lambdabot>  Parse error in pattern at "in" (column 31)
16:17:28 <vixey> :[
16:18:22 <chrisdone> dons: did you see this? :P made with gd, without the aid of ghci *dramatic anguish pose* http://img155.imageshack.us/img155/6853/stmwordcloudhb0.png
16:20:39 <dons> hmm. did anyone else notice that google's now favicon is stolen from galois'? :)
16:20:49 <dons> nice!
16:20:55 <chrisdone> yeah, I wtf'd
16:21:29 <dibblego> the 'g' is a little different
16:21:45 <dons> ours is courier 10, iirc.
16:21:48 <dibblego> or is it? I think not on second look
16:22:05 <chrisdone> hopefully I can make it in a nice web application like Wordle, except not proprietary
16:22:27 <wjt> dons: cf. http://www.guardian.co.uk/
16:22:29 <lambdabot> Title: Latest news, sport, business, comment and reviews from the Guardian | guardian.c ...
16:22:31 <dons> the galois one is prettier.
16:22:39 <dons> wjt: heh
16:22:49 <dibblego> is it flattery or grounds to be annoyed a little?
16:23:29 <dons> dibblego: i guess they don't know or care.  see http://googleblog.blogspot.com/2008/06/one-fish-two-fish-red-fish-blue-fish.html
16:23:31 <lambdabot> Title: Official Google Blog: One Fish, Two Fish, Red Fish, Blue Fish, http://tinyurl.com/6rekcl
16:25:33 <dons> i'll let Marissa Mayer know next time I see her :)
16:25:47 <dafra_> when will Galois open an office in Paris ?
16:26:11 <dons> that would be tempting fate...
16:27:16 <vixey> not sure what to do now..
16:27:26 <jamii> Butting my head against type constructors.
16:28:03 <jamii> I have a nice class that looks like 'class Map map k | map -> k' where map has kind *->* so its polymorphic in the elements
16:28:55 <jamii> Which works fine up for all my own types. But I cant figure out how to declare 'instance Map [(k,_)] k'
16:29:31 <jamii> I seem to need a type level compose. Like ' [] . (,) k '
16:29:43 <jamii> Any ideas?
16:29:51 <rwbarton> jamii: Yes, you do, which requires a newtype (bleh), I think
16:30:10 <vixey> yeah programming without lambda
16:30:39 <jamii> rwbarton: Im trying to avoid newtyping because Ill be making massive use of data.list to write out all 30 instance methods.
16:30:46 <chrisdone> an anonymous type level compose would be..
16:30:56 <jamii> And packing and unpacking every argument is going to be a pain in the ass
16:31:21 <jamii> Type synonyms dont work either. GHC expects them to be fully applied
16:31:51 <vixey> is instance Map [(k,v)] k v possible? if you change the Map class a bit
16:32:52 <rwbarton> I'm not a type system guru but I think you need to either take vixey's suggestion (but then you can't write fmap) or use a newtype
16:32:56 <jamii> vixey: Ummm ... not sure. Let me see if changing the class breaks anything
16:33:23 <vixey> what's the longest length of line you'd reasonably see in haskell code?
16:33:23 <vixey> a
16:33:49 <lilachaze> vixey: longer than "a"
16:34:25 <rwbarton> vixey: My currently-open file has a 151-character line.  I try not to exceed that by too much
16:34:28 <vixey> @pl return . f <=< g
16:34:28 <jamii> vixey: No, wont work. I need to enforce that every map is fully polymorphic in its elements or the maps dont compose properly
16:34:29 <lambdabot> (line 1, column 12):
16:34:29 <lambdabot> unexpected "=" or "<"
16:34:29 <lambdabot> expecting variable, "(", ".", space, operator or end of input
16:34:29 <lambdabot> ambiguous use of a left associative operator
16:34:41 <SamB> vixey: the longest one that fit in my emacs frame
16:34:53 <SamB> if it was any longer, I couldn't reasonably see it, now could I?
16:35:03 <vixey> oh I am around 118 colums here
16:35:41 <jamii> Newtypes it is, i guess. Thats a pain
16:38:26 <lilachaze> @pl \f g -> return . \a -> g a >>= f
16:38:27 <lambdabot> ((return .) .) . flip (flip . ((>>=) .))
16:41:31 <chrisdone> heh, I have a function which gives me a type error when defined globally but when defined locally with where works as expected
16:41:56 <vixey> does the local scope bind some variables it uses?
16:42:00 <jamii> chrisdone: Monomorphism?
16:42:02 <vixey> shawo*
16:42:07 <vixey> shadow*
16:42:22 <theprogrammer> sup guys
16:42:58 <chrisdone> ah, it was local conflicts
16:43:36 <chrisdone> hi
16:43:39 <theprogrammer> hi
16:44:46 <theprogrammer> i found this cool programming site yesterday
16:45:06 <theprogrammer> www.graybox.ccjmac.com/cave_com  check it out
16:45:17 <vixey> lol
16:45:47 <theprogrammer> i needed some help with html and i posted and i got a quick reponse
16:46:19 <vixey> I'm not sure if I should print out java bytecodes
16:46:40 <vixey> I guess it could work ok..
16:47:25 <vixey> what's the jist of augustss paper about compiling pattern matching?
16:47:29 <chrisdone> weird choice of channel for advertising a newbie programmer web site, but mmkay
16:47:35 <vixey> is it desugering into eliminators?
16:48:05 <vixey> i.e. f True = a; f False = b  -->  f x = elimBool x (a) (b)
16:48:18 <vixey> (I still haven't found anywhere to download it)
16:50:41 <Abraxas038> [x| n<-[4..10], x<-[1..floor (sqrt n)], n `mod` x == 0]
16:50:47 <Abraxas038> why doesn't this work
16:51:06 <vixey> Abraxas038: ghci will tell you -why-
16:51:22 <Abraxas038> what is ghci
16:51:36 <vixey> it's for haskell interaction
16:51:39 <dibblego> Glasgow Haskell Compiler interpreter
16:51:42 <vixey> > "It's basically this"
16:51:46 <lambdabot>  "It's basically this"
16:52:12 <vixey> >  let isqrt x = fromIntegral x in [x| n<-[4..10], x<-[1 ..floor (isqrt n)], n `mod` x == 0]
16:52:14 <lambdabot>  [1,2,4,1,5,1,2,3,6,1,7,1,2,4,8,1,3,9,1,2,5,10]
16:52:26 <augustss> vixey: you can read the gist in Simon's first book
16:55:21 <Abraxas038> thx, got it
16:59:20 <gwern> whew. ok, so the split situation isn't as bad as I feared. turns out twanvl's split patch has the same semantics as the bytestring split
16:59:55 <vixey> gwern: patching what?
16:59:57 <awesame> so I'm using System.Posix.forkProcess
17:00:12 <awesame> for debugging reasons, I want to wait for the forked process to exit
17:00:14 <gwern> vixey: to data.list
17:00:24 <vixey> Can you add groups too ?
17:00:27 <awesame> but I'm having trouble finding the funtion that will let me do that
17:00:28 <vixey> I mean chunk
17:00:31 <awesame> does anyone know it?
17:01:23 <dons> awesame: typically that's done via an MVar.
17:01:29 <dons> have the forked thread write to an empty MVar
17:01:30 <gwern> vixey: which is?
17:01:32 <dons> and the main thread waits on it.
17:01:41 <awesame> eek
17:01:46 <awesame> I don't know MVar
17:01:56 <vixey> chunk 3 [1..10] = [[1,2,3],[4,5,6],[7,8,9],[10]]
17:02:03 <awesame> the forked thread is executing a non-haskell process, so that sounds unlikely to work
17:02:06 <gwern> awesame: oh, they're really quite easy
17:02:12 <awesame> I think I'm looking for a waitpid wrapped
17:02:32 <awesame> wrapper
17:02:40 <gwern> awesame: I figured them out in a few minutes back when I decided to use them in mueval, altho admittedly that was pure haskell
17:03:35 <dons> awesame: http://hpaste.org/8895
17:03:49 <dons> you can abstract that out as a waitthread function if you like, its trivial.
17:04:03 <gwern> woah. emacs's zoning out mode is especially creepy with syntax highlighting
17:04:15 <gwern> (or do I mean especially cool)
17:04:24 <vixey> gwern, you don't like it ?
17:04:28 <awesame> what does MVar mean?  monad variable?
17:04:47 <gwern> dons: do you think I could get away with proposing 4 splits for data.list?
17:04:48 <dons> ?docs Control.Monad.MVar
17:04:49 <lambdabot> Control.Monad.MVar not available
17:04:55 <dons> ?docs Control.Concurrent..MVar
17:04:55 <lambdabot> Control.Concurrent..MVar not available
17:04:57 <dons> ?docs Control.Concurrent.MVar
17:04:58 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent-MVar.html
17:04:58 <dons> sigh.
17:05:04 <dons> gwern: no.
17:05:16 <macondo> How can I get the biggest n items of a list without having to sort the whole list (take n ( sort s ) )?
17:05:17 <dons> but feel free to put a string library on hackage.
17:05:19 <vixey> why don't you write a regex library
17:05:29 <dons> vixey: there's already 10 of them :)
17:05:45 <tusho> Octopus are multiple. The & sign in a book.
17:05:54 <lilachaze> @t System.Posix.forkProcess
17:05:55 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
17:05:55 <vixey> macondo: That's fine
17:06:00 <lilachaze> @type System.Posix.forkProcess
17:06:01 <lambdabot> IO () -> IO System.Posix.Types.ProcessID
17:06:03 <vixey> macondo: You could write it as take n . sort
17:07:25 <tusho> jinjing: i personally hold you responsible for that awful redefinition of (.)
17:11:42 <lilachaze> awesame: use System.Process or System.Cmd instead -- they appear to allow you to wait for the child process
17:12:16 <dolio> dons: What's the deal with vector?
17:12:44 <dons> it looks like roman packaged up the flat, unlifted part of the NDP library
17:12:48 <dons> and released it standalone.
17:12:58 <dolio> Isn't that almost the same thing as uvector?
17:13:18 <dons> it'll be quite similar. uvector is a reimplementation of vector, basically, with a bigger api, and more instances.
17:13:55 <dons> maybe vector has more of a focus on fancier fusion schemes?
17:14:14 <dons> or numerics stuff. it'd have a bigger set of example programs.
17:14:34 <dolio> It didn't seem too much fancier in the code to me, but I'm not an expert on rewrite rules.
17:15:15 <dolio> It does look like he doesn't automatically convert everything to streams, though.
17:15:29 <dolio> All the immutable stuff, that is.
17:15:44 <dons> right. he's picked a middle line, choosing only those that don't duplicate work.
17:15:53 <dons> while i want to preserve the option of fully fused code
17:21:10 <dibblego> can mapM be written with Data.Traversable.traverse?
17:21:46 <dolio> traverse is the applicative one, right?
17:21:55 <dibblego> related to it yes
17:22:11 <dolio> @type Data.Traversible.traverse
17:22:11 <lambdabot> Couldn't find qualified module.
17:22:21 <dibblego> @type Data.Traversable.traverse
17:22:22 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Applicative f, Data.Traversable.Traversable t) => (a -> f b) -> t a -> f (t b)
17:23:21 <kpreid> looks possible to me
17:23:39 <Saizan> mapM is an instance of traverse..
17:23:40 <dolio> Yeah, it's something like... 'mapM f t = unwrapMonad $ traverse (WrapMonad . f) t'
17:23:57 <kpreid> dolio: there needs to be a list type somewhere in there...
17:24:17 <dolio> List type?
17:24:25 <Saizan> lists are Traversable
17:24:33 <dolio> We're talking about defining Data.Traversable.mapM, right?
17:25:29 <kpreid> I assumed implementing mapM in terms of traverse
17:25:29 <dolio> @type \f t -> unwrapMonad $ Data.Traversable.traverse (WrapMonad . f) t
17:25:30 <lambdabot> forall (m :: * -> *) a a1 (t :: * -> *). (Monad m, Data.Traversable.Traversable t) => (a1 -> m a) -> t a1 -> m (t a)
17:25:53 <dolio> @type Data.Traversable.mapM
17:25:54 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Monad m, Data.Traversable.Traversable t) => (a -> m b) -> t a -> m (t b)
17:26:54 <dibblego> oh didn't see that, cheers :)
17:26:58 <dibblego> ?type unwrapMonad
17:27:00 <lambdabot> forall (m :: * -> *) a. WrappedMonad m a -> m a
17:27:30 <dibblego> @src WrappedMonad
17:27:31 <lambdabot> Source not found. Maybe you made a typo?
17:27:38 <dibblego> @index WrappedMonad
17:27:39 <lambdabot> bzzt
17:28:24 <dibblego> newtype WrappedMonad m a = WrappedMonad { unwrapMonad :: m a } -- ?
17:28:26 <dolio> If Applicative were a superclass of Monad, that wouldn't be necessary, either.
17:42:06 <dibblego> you mean the whole mapM wouldn't be necessary? (or the wrap/unwrap?) since it seems to be equivalent to traverse?
17:42:39 <dibblego> equivalent, but specific to Monad instead of Applicative
17:42:47 <dibblego> (and [] of course)
17:43:52 <dolio> I mean mapM would be unnecessary.
17:44:05 <dibblego> ah great, that's what I thought, thanks
17:44:11 <dolio> Since it'd just be a more specific type than traverse.
17:44:15 <dibblego> right
17:44:26 <dibblego> a bit like fmap/liftM I guess
17:45:02 <dolio> Right.
17:45:18 <dibblego> cheers for that tip
17:45:35 <dolio> No problem.
17:58:30 <wuxia> please point me to a good uit testing framework for haskell
18:00:03 <dibblego> @where QuickCheck
18:00:04 <lambdabot> http://www.cs.chalmers.se/~rjmh/QuickCheck/
18:00:19 <dibblego> @check \a b -> a + b == b + a
18:00:20 <lambdabot>  OK, passed 500 tests.
18:00:41 <dibblego> @check \x y -> reverse (x ++ y) == reverse y ++ reverse x -- I think the paper mentions this example
18:00:42 <lambdabot>  OK, passed 500 tests.
18:00:43 <vixey> quick check
18:02:23 <kpreid> @check \a b -> a / b * b == a
18:02:24 <lambdabot>  Falsifiable, after 1 tests: 0.0, 0.0
18:03:11 <geezusfreeek> @check \a b -> (a / b * b :: CReal) == a
18:03:12 <lambdabot>   add an instance declaration for (Arbitrary CReal)     In the expression: le...
18:03:16 <geezusfreeek> aw
18:03:20 <geezusfreeek> i guess that makes sense
18:03:40 <geezusfreeek> it shouldn't work anyway i guess
18:04:01 <geezusfreeek> @check \a b -> (a / b * b :: Rational) == a
18:04:03 <lambdabot>  Exception: Ratio.%: zero denominator
18:04:21 <geezusfreeek> @check \a b -> b /= 0 ==> (a / b * b :: Rational) == a
18:04:22 <lambdabot>  OK, passed 500 tests.
18:06:29 <vixey> @check \x y -> x == y
18:06:31 <lambdabot>  OK, passed 500 tests.
18:06:38 <dibblego> ha!
18:06:41 <vixey> > True == False
18:06:42 <lambdabot>  False
18:06:47 <dibblego> @check \x y -> x == (y :: Int)
18:06:48 <lambdabot>  Falsifiable, after 0 tests: -1, 3
18:07:28 <byte-> @check \x y -> x == (y :: Bool)
18:07:29 <lambdabot>  Falsifiable, after 3 tests: True, False
18:07:32 <vixey> @check \p q -> p*q == 3723
18:07:34 <lambdabot>  Falsifiable, after 0 tests: 2, -1
18:07:45 <vixey> @check \p q -> p*q /= 3723
18:07:46 <lambdabot>  OK, passed 500 tests.
18:08:18 <vixey> > 73*51
18:08:20 <lambdabot>  3723
18:08:36 <wuxia> is there an equiv of assert() in haskell?
18:08:40 <dibblego> check testing == type system
18:08:50 <vixey> :t guard
18:08:50 <dibblego> Falsifiable
18:08:51 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
18:08:55 <mauke> @hoogle assert
18:08:56 <lambdabot> Control.Exception.assert :: Bool -> a -> a
18:08:56 <lambdabot> Test.HUnit.Base.assert :: Assertable t => t -> Assertion
18:08:56 <lambdabot> Control.Exception.assertions :: Exception -> Maybe String
18:14:53 <geezusfreeek> @check \x y -> x /= y
18:14:53 <lambdabot>  Falsifiable, after 0 tests: (), ()
18:15:00 <geezusfreeek> oh, it's defaulting to ()
18:15:18 <geezusfreeek> that is what i suspected, but i wasn't sure
18:18:11 <mmorrow> @check \x y -> x+1 `seq` x /= y
18:18:11 <lambdabot>  Falsifiable, after 0 tests: 0, 0
18:18:37 <mmorrow> @check \x y -> x == y
18:18:38 <lambdabot>  OK, passed 500 tests.
18:18:45 <mmorrow> haha
18:18:58 <mmorrow> @check \x y -> x+1 `seq` x == y
18:18:59 <lambdabot>  Falsifiable, after 0 tests: 0, -1
18:20:27 <mauke> @check \x y -> mappend x y == mappend y x
18:20:28 <lambdabot>  OK, passed 500 tests.
18:20:43 <mauke> @check \x y -> x ++ y == y ++ x
18:20:44 <lambdabot>  OK, passed 500 tests.
18:20:51 <rwbarton> Caleskell strikes again
18:21:05 <vixey> rwbarton: sigh
18:21:20 <dolio> Eh?
18:21:24 <mmorrow> > () ++ ()
18:21:25 <lambdabot>  ()
18:21:30 <rwbarton> :t (++)
18:21:31 <lambdabot> forall m. (Monoid m) => m -> m -> m
18:22:08 <vixey> rwbarton: Look
18:22:08 <vixey> @check \x y -> x == y
18:22:09 <lambdabot>  OK, passed 500 tests.
18:22:21 <rwbarton> Yeah, that one makes some sense...
18:22:25 <mmorrow> @check \x y -> length x `seq` x ++ y == y ++ x
18:22:26 <lambdabot>  OK, passed 500 tests.
18:22:26 <mauke> rwbarton: how is this caleskell?
18:22:33 <dibblego> ++ is Caleskell
18:22:35 <rwbarton> @instances monoid
18:22:36 <lambdabot> Couldn't find class `monoid'. Try @instances-importing
18:22:37 <rwbarton> @instances Monoid
18:22:39 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
18:22:59 <mauke> @check \x y -> x ++ y == y ++ (x ++ [])
18:22:59 <lambdabot>  OK, passed 500 tests.
18:23:02 <mauke> no, it isn't
18:23:06 <mauke> it uses lists
18:23:15 <dibblego> ?type (++)
18:23:16 <lambdabot> forall m. (Monoid m) => m -> m -> m
18:23:23 <mmorrow> mauke: *that* one used lists
18:23:27 <mmorrow> but the prev used ()
18:23:39 <mauke> mmorrow: how do you know?
18:23:42 <vixey> [()]
18:23:42 <mmorrow> that's scary that the list one passed
18:23:50 <mmorrow> since it seems to default to ()
18:23:53 <mmorrow> because of..
18:24:05 <mmorrow> @check \x y -> x /= y
18:24:06 <lambdabot>  Falsifiable, after 0 tests: (), ()
18:24:10 <rwbarton> :t \x y -> x ++ y == y ++ (x ++ [])
18:24:11 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
18:24:15 <mmorrow> > () ++ ()
18:24:16 <lambdabot>  ()
18:24:28 <mauke> does @check use the enhanced prelude?
18:24:31 <vixey> > let x = [(),(),()] ; y = [()] in x ++ y
18:24:33 <mmorrow>  vixey: ah, true
18:24:33 <lambdabot>  [(),(),(),()]
18:24:34 <vixey> > let x = [(),(),()] ; y = [()] in y ++ x
18:24:36 <lambdabot>  [(),(),(),()]
18:24:45 <mmorrow> of course
18:24:52 <rwbarton> :t \x y -> x ++ () == x
18:24:52 <vixey> mauke: no rwbarton just loves complaining about it
18:24:53 <lambdabot> forall t. () -> t -> Bool
18:24:57 <rwbarton> @check \x y -> x ++ () == x
18:24:58 <lambdabot>  OK, passed 500 tests.
18:25:02 * idnar is confused
18:25:06 <rwbarton> vixey: It's true I do :)
18:25:10 <mmorrow> haha
18:25:10 <mauke> @check \x -> id . [x] == [x]
18:25:11 <lambdabot>  OK, passed 500 tests.
18:25:18 <mauke> looks like it does
18:26:08 <idnar> @type id . [?x]
18:26:09 <lambdabot> forall a. (?x::a) => [a]
18:26:12 <mmorrow> @check \x y -> fmap (+1) x `seq` x ++ y == y ++ x
18:26:13 <lambdabot>        add an instance declaration for (Eq (f a), Monoid (f a))
18:26:14 <dolio> "note to readers: i'm not just interested in functional programing, i'm the world's top expert, far beyond the common lisp fuckheads here that has some 10 years of experience programing in CL."
18:26:21 <mmorrow> @check \x y -> map (+1) x `seq` x ++ y == y ++ x
18:26:21 <lambdabot>        add an instance declaration for (Eq (f a), Monoid (f a))
18:26:30 <mmorrow> :t map
18:26:30 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:26:32 <idnar> @check \x -> id . [x] == id `fmap` [x]
18:26:34 <lambdabot>  OK, passed 500 tests.
18:26:34 <dolio> Good ol' Xah Lee.
18:26:52 <dibblego> dolio, haha! where boots?
18:26:53 <mmorrow> @check \x y -> map (+1) (x++[]) `seq` x ++ y == y ++ x
18:26:54 <lambdabot>  Falsifiable, after 2 tests: [-1], [-1,0,-4]
18:27:00 <mmorrow> victory!
18:27:54 <mmorrow> @check \x y -> x ++ y == y ++ (x `asTypeOf` [0])
18:27:55 <lambdabot>  Falsifiable, after 1 tests: [-1], [1]
18:27:59 <dolio> @check \x y -> x ++ y == y ++ (x :: [Int])
18:28:00 <lambdabot>  Falsifiable, after 1 tests: [1], [0,3,1]
18:28:14 <mmorrow> ha, silly me
18:28:16 <dolio> dibblego: Eh?
18:28:27 <dibblego> dolio, where did you find that quote by Xah Lee?
18:28:43 <dolio> Oh. Recent post to comp.lang.functional.
18:28:53 <dolio> Cross posted to other places, of course.
18:28:57 <dibblego> what a funny guy
18:29:28 <mauke> (xah lee)--
18:29:39 <dolio> He's a character.
18:30:07 <vixey> hes' probably high on the curry-howard isomorphism
18:30:11 <mauke> he's an EBCDIC character in a UTF-8 world
18:30:15 <Korollary> XahLee.Char
18:31:31 <dons> is xahlee still around?
18:31:39 <dons> i've not heard anything in a couple of years.
18:32:03 <vixey> dons: he still comes on IRC but I stopped talking to him since he was rude to me
18:32:09 <dons> in this channel?
18:32:19 <vixey> #math
18:32:22 <dons> ok.
18:32:42 <mmorrow> whoa, didn't know there was a #math
18:32:48 <mmorrow> (never checked either, though)
18:33:18 <dolio> He never talked much in here.
18:33:31 <dolio> Only once that I saw, I think.
18:33:40 <vixey> I taught him about Curry howard a few months ago
18:33:55 <dolio> He's been trolling usenet with regularity for some time, though.
18:33:55 <dons> 07.08.13:06:03:14 <xahlee> what does the up-arrow mean in haskell?
18:33:57 <vixey> maybe more like a year
18:33:59 <dons> 07.08.13:06:04:14 <xahlee> in graham's book. e.g. 2‚Üë3*4
18:34:37 <dolio> He's definitely among the world's top experts in antagonizing lispers. :)
18:34:49 <dons> part of the secret society
18:35:17 <dons> poor lisp community
18:38:38 <vixey> how do you create a comp.lang.<something> ?
18:44:41 <chrisdone> white whale holy grail
18:44:58 <mmorrow> vixey: how's your typechecker coming along?
18:45:06 <vixey> I've finished it
18:45:13 <mmorrow> ooh, exciting
18:45:23 <mmorrow> is it anywhere online?
18:46:25 <mauke> vixey: http://groups.google.de/group/news.groups.proposals/browse_thread/thread/73492162d19fe233#
18:46:26 <lambdabot> Title: Creating and removing newsgroups in the Big-8 Hierarchies - news.groups.proposal ..., http://tinyurl.com/62oxzw
18:46:49 <vixey> mmorrow: Not yet
18:46:52 <vixey> thanks mauke
18:47:29 <mmorrow> vixey: cool, i wait anxiously :)
18:47:34 <vixey> I had some problems with ssh
18:47:40 <mmorrow> ruhroh
18:47:44 <mmorrow> like what?
18:48:09 <vixey> well I just couldn't log in, it was as if I kept putting in the wrong password
18:48:20 <mmorrow> to code.haskell.org?
18:48:31 <vixey> no
18:48:58 <mmorrow> oh
18:49:07 <mmorrow> you should get an account there
18:49:36 <mmorrow> http://community.haskell.org/admin/account_request.html
18:49:36 <lambdabot> Title: Account Request
18:50:13 <mmorrow> apparently you can gen a dsa *or* rsa key
18:50:20 <mmorrow> and rsa is the way to be
18:51:22 <dibblego> I use rsa
18:52:12 <mmorrow> i guess they just recently allowed rsa keys to be submitted with new account requests
18:52:21 <dibblego> hope so, cause I just did :)
18:52:28 <mmorrow> ha
18:54:21 <schme_> Why is fromJust not named unJust ?
18:54:44 <schme_> It'd be a lot more fun :)
18:54:49 <Korollary> for great justice
18:55:20 <schme_> take off every zig!
18:55:45 <mofmog> how do i get mutually recursive data types?
18:55:52 <mauke> you just do it
18:55:57 <schme_> plutonas: You around?
18:56:01 <mofmog> but it says the types are undefined
18:56:30 <mauke> then you're doing it wrong
18:56:31 <mmorrow> data A a = A a | AB (B a)  ; data B a = B a | BA (A a)
18:56:57 <mofmog> what if i want
18:57:13 <mofmog> hmm
18:57:22 <mmorrow> newtype F a = F (G a)   ;   newtype G a = G (F a)   ==> this'll compile but it's impossible to actually have a value of type F a or G a other than undefined
18:57:48 <mmorrow> well, F undefined ,  G (F (G undefined)), etc
18:58:00 <mauke> same thing
18:58:04 <mmorrow> yeah
18:58:09 <sm> @seen CosmicRay
18:58:09 <lambdabot> I saw CosmicRay leaving #haskell 11h 50m 34s ago, and .
18:58:16 <bd_> mmorrow: those values are the same :)
18:58:32 <bd_> newtype constructors are strict
18:58:37 <mmorrow> well, not necessarily ==> suppose ..
18:58:38 <vixey> mmorrow: is not :P
18:58:39 <mmorrow> ohj
18:58:45 <vixey> fix (F . G)
18:58:54 <mofmog> howabout a data type where certain constructors use constructors already defined
18:59:00 <mauke> mofmog: no
18:59:02 <mofmog> in the same data
18:59:04 <mofmog> =/
18:59:08 <mmorrow> vixey: yay
18:59:10 <bd_> mofmog: what do you mean by that?
18:59:20 <mofmog> for example if a had
18:59:46 <mofmog> data Expr = Number Integer | Sign String | Name String | Definition Name Sign
18:59:50 <mofmog> of course you can't do that
18:59:52 <mofmog> but something similar
18:59:55 <schme_> Is there some technique for remembering to comment haskell code while writing it?
19:00:03 <vixey> mofmog: hmmmmm
19:00:05 <bd_> mofmog: 'Name' and 'Sign' aren't constructords
19:00:10 <bd_> You could do Definition Expr Expr
19:00:12 <vixey> mofmog: You've used 'Sign' as a constructor and a type
19:00:13 <mmorrow> vixey: that reminds me, i have a module somewhere where i was playing with essentially exactly that...
19:00:17 <mauke> bd_: they are constructors
19:00:18 <bd_> er
19:00:19 * mmorrow finds it
19:00:22 <bd_> 'Name' and 'Sign' aren't types I mean
19:00:32 <mofmog> of course, that's the problem
19:00:33 <vixey> data Expr where
19:00:37 <vixey> data Expr ty where
19:00:45 <vixey>  Number :: Integer -> Expr Integer
19:00:45 <bd_> vixey: do you mean class?
19:01:09 <mauke> mofmog: maybe you can factor them out into their own types
19:01:16 <vixey>  Definition :: Expr Integer -> Expr String -> Expr Foo
19:01:36 <mofmog> when I pattern match a definition i want to also pattern match a name and a sign inside of it
19:01:39 <bd_> Valodim: class members can't start with a capital letter
19:02:01 <mauke> bd_: that wasn't a class
19:02:03 <vixey> bd_: Oh, let me find something on hpaste
19:02:06 <bd_> mofmog: You can use Definition Expr Expr and have something like f (Definition (Name a) (Sign b)) = ...
19:02:15 <mmorrow> mauke, bd_: yeah, i never really explicitly realized that Newtype cons are strict, but they totally have to be since they're nonexistent at runtime
19:02:25 <mofmog> but i also want definition to be of type expr
19:02:33 <bd_> mmorrow: That is /the/ difference between newtype and data after all :)
19:02:53 <mofmog> well, it's not exactly a type but i dont wanna rewrite my parser -_-
19:02:56 <mofmog> but i guess i'll have to
19:03:10 <schme_> @src fromJust
19:03:10 <lambdabot> fromJust Nothing  = undefined
19:03:10 <lambdabot> fromJust (Just x) = x
19:03:17 <schme_> right.
19:03:22 <bd_> mofmog: i mean, data Expr = Name String | Sign String | ... | Definition Expr Expr
19:03:27 <vixey> seems to be missing
19:03:38 <bd_> mofmog: then you can match with nested patterns: doSomething (Definition (Name x) (Sign y)) = ...
19:04:00 <mofmog> oh right
19:04:30 <mmorrow> bd_: which diff are you refering to? that they're nonexistent at runtime or that they're strict ==> the former implies the latter but not vice-versa
19:04:57 <bd_> mmorrow: the former is a compiler optimization allowed by the fact that there is only one, single-argument constructor which is strict
19:05:44 <mmorrow> bd_: yes, but single arg single con datas *do* exist at runtime
19:05:44 <bd_> It's perfectly reasonable for a compiler to newtype Foo = Bar Baz into data Foo = Bar !Baz
19:05:51 <bd_> mmorrow: that's because they're not strict :)
19:05:59 <bd_> and thus the optimization no longer applies
19:06:02 <mmorrow> data A a = A !a
19:06:28 <bd_> mmorrow: GHC is just missing that optimization for that case :)
19:06:39 <mmorrow> hehe
19:06:59 <bd_> semantically-speaking, data A a = A !a is equivalent to newtype A a = A a
19:07:16 <bd_> in that there's no way to distinguish between their behavior, besides cpu/memory usage
19:07:33 <vixey> why are newtypes strict?
19:07:46 <mmorrow> db_: that's interesting, but would erasing the data A a = A !a con at runtime be a valid thing to do?
19:07:50 <mofmog> alright this works!
19:08:16 <mmorrow> ie is there any situation where that would break a correct program?
19:08:30 <rwbarton> I thought data A a = A !a ; f (A _) = 1 ; f undefined = _|_ while newtype A a = A a ; f (A _) = 1 ; f undefined = 1
19:08:34 <bd_> mmorrow: I believe so. There's an isomorphism between (A a) and a, after all - (A undefined) is equivalent to (undefined), and every other inhabitant of (a) has a corresponding (A a)
19:08:56 <paczesiowa> dolio: I have a question about your redditem zipWithN implementation, how did it work with: polymorphic in their return value types (const 1) and types like id:: a->a which could act like zipWith1(=map) or zipWith3, depending on instantiation of a->a
19:09:02 <bd_> rwbarton: It's not possible to construct an (A undefined) inthe former case; you'd end up with an (undefined) thanks to the strictures
19:09:36 <mmorrow> bd_: hmm, maybe this should be brought up on the ghc trac?
19:09:36 <rwbarton> bd_: True, but that doesn't affect what I wrote
19:09:57 <bd_> rwbarton: well ,you never defined f...
19:10:05 <bd_> so I'm not sure what you mean then :)
19:10:10 <mmorrow> rwbarton: that's what i thought too
19:10:14 <dolio> paczesiowa: Do you have a link? I wrote it a while ago.
19:10:15 <rwbarton> I did, it's in the middle
19:10:36 <bd_> rwbarton: I'm not sure if you're defining f or passing it values...
19:10:43 <rwbarton> Oh, sorry! I see
19:10:45 <dolio> Also, are we talking about the Agda version or the Haskell version?
19:10:51 <paczesiowa> dolio: http://hpaste.org/7116#a1
19:10:56 <chrisdone> heh, not bad, takes ten seconds to workout the whole book of Moby Dick: http://chrisdone.com/thewhitewhale.png . have a place with it if you want p_p: http://chrisdone.com/wordfreq.cgi
19:11:01 <vixey> @src foldl
19:11:02 <lambdabot> foldl f z []     = z
19:11:02 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
19:11:02 <rwbarton> The last third is supposed to be an assertion about the value of f, the middle third the definition of f
19:11:14 <paczesiowa> dolio: haskell, I never used agda
19:11:17 <bd_> rwbarton: with f (A _) = (); if data A a = A a; then f (A undefined) = (). With newtype or strict data, it's undefined
19:11:51 <bd_> since with strict data, (A undefined) == (undefined)
19:11:56 <rwbarton> Yes, but evaluating f undefined distinguishes between newtype and strict data
19:12:06 <bd_> rwbarton: how?
19:12:07 <rwbarton> (I believe)
19:12:35 <bd_> with the 'f' I just defined, f undefined is always undefined, regardless of A
19:13:15 <ddarius> bd_: newtype is -not- semantically equivalent to strict data.  There are contexts that distinguish them.
19:13:28 <rwbarton> bd_: Not if A a is a newtype.  Try it in ghci
19:13:30 <bd_> ddarius: What contexts?
19:13:40 <paczesiowa> dolio: I wrote version of zipwithn that decides its type only on zipping function (without any "witnesses") but it works only for mononorphic-in-return-value functions
19:13:57 <bd_> ahhhh
19:13:58 <bd_> I see
19:14:22 <bd_> pattern matching against an undefined newtype isn't undefined
19:14:27 <dolio> paczesiowa: Unfortunately, I don't have 6.9.* compile anymore to try this out.
19:14:49 <paczesiowa> dolio: and I'm still scratching my head, how it should work for types like (Int -> Num) or (Int -> a)
19:15:29 <paczesiowa> dolio: :/
19:16:05 <ddarius> http://www.haskell.org/haskellwiki/Newtype
19:16:06 <lambdabot> Title: Newtype - HaskellWiki
19:16:27 <dolio> If it says it's polymorphic in r, though, it probably is.
19:17:51 <dolio> The reson it needs the witness in mine is that you can't infer ts from Fun ts r, I think, since Fun isn't guaranteed to be injective.
19:17:56 <dolio> How did you get around that?
19:18:05 <paczesiowa> wait, hpaste
19:22:12 <paczesiowa> http://hpaste.org/8899
19:24:30 <paczesiowa> it would be easier if ghc would allow switch -fOleg, than to write all those useful typecasts all the time
19:26:21 <slowriot> so do any of you plan to participate in the google code jam?
19:26:59 <mmorrow> bd_: i think this *maybe* show's that they're not equiv http://hpaste.org/8900
19:27:05 <mmorrow> s/'//
19:27:16 <mmorrow> (i'm not sure though)
19:28:43 <bd_> mmorrow: <-?
19:29:03 <mmorrow> so it's not that newtypes are *strict*, but that if eg newtype F a = F a , then  F undefined is undefined, but data A a = A !a and A undefined actually tries to *evaluate* undefined
19:29:24 <bd_> *nod*
19:29:25 <mmorrow> bd_: oh, that's just pattern guard syntax
19:29:32 <bd_> ah, I've not seen it before, somehow
19:29:37 <mmorrow> i love it
19:29:53 <rwbarton> paczesiowa: what is the purpose of TypeCast, TypeCast' and TypeCast''?  Is it easily explained?
19:30:50 <mmorrow> oh, i just saw the part the previous part of the conversation that says essentially the same thing as my paste
19:30:54 <rwbarton> paczesiowa: it seems you could delete all the TypeCast stuff and write instance IsFunction (x->y) True ...?
19:31:21 <paczesiowa> rwbarton: appendix D of HList paper. it is ugly ghc-only hack to delay some typechecker optimisations
19:31:35 <rwbarton> paczesiowa: oh...
19:32:09 <dolio> paczesiowa: Oh, I see what you're getting at. I don't know if my version had the same problem or not.
19:32:28 <paczesiowa> rwbarton: but Oleg wrote it, his ugly hacks are still beautiful code
19:34:15 <dolio> paczesiowa: Wouldn't surprise me if it did.
19:34:23 <paczesiowa> rwbarton: there is alternative working even in hugs, but it requires separate compilation
19:35:32 <dolio> Since type families probably want concrete types, too.
19:44:57 <dons> google guy's noticed there was already a haskell protocol buffers implementation, http://diveintomark.org/archives/2008/07/12/protobuf
19:44:58 <lambdabot> Title: Protocol buffers: the early reviews are in [dive into mark]
19:45:14 <dons> there's actually 2, sigbjorn's also written one.
19:54:13 <mmorrow> love haskell-src-exts
19:56:38 <sm> evening all
20:00:06 <sm> where does SearchPath.hs install the libs it downloads ?
20:06:00 <dons> i'm not sure anyone uses searchpath.
20:12:25 <carl> is there a way to print out a debug msg outside of the IO monad like error except without crashing the program
20:12:34 <vixey> trace
20:12:40 <vixey> from Debug.Trace
20:13:22 <carl> thx
20:15:58 <sm> dons: I used it as part of the getting started on happs.org
20:16:23 <sm> it's pretty slick.. both the dynamic fetching and especially the rebuild/restart on file change
20:35:59 <vixey> @hoogle flush
20:36:01 <lambdabot> GHC.ConsoleHandler.flushConsole :: Handle -> IO ()
20:36:01 <lambdabot> System.IO.hFlush :: Handle -> IO ()
20:45:16 <vixey> how come you can't use the delete key with getLine ?
20:48:04 <kaspyanand> import Data.Char (toUpper)  upperCase :: String -> String  upperCase (x:xs) = toUpper x : upperCase xs upperCase []     = []
20:48:29 <vixey> hey kasypanand
20:48:34 <kaspyanand> hi
20:48:41 <paczesiowa> vixey: use rlwrap or rlfe or directly readline
20:49:09 <vixey> kaspyanand: map f [x,y,z] = [f x, f y, f z]
20:49:14 <kaspyanand> i dont understand how call to uppercase xs does pattern matching,since we say upperCase (x:xs)
20:49:20 <vixey> kaspyanand: Since a String is a list of characters, you could use map
20:49:30 <vixey> oh
20:49:42 <vixey> > let (x:xs) = "chop" in (x,xs)
20:49:43 <dons> vixey: getLine doesn't do any termio fanciness
20:49:46 <lambdabot>  ('c',"hop")
20:49:51 <vixey> > let (x:xs) = "hop" in (x,xs)
20:49:53 <lambdabot>  ('h',"op")
20:49:59 <dons> use editline or readline for that kind of stuff
20:50:06 <vixey> kaspyanand: it just works the way along the string like thta
20:50:35 <vixey> why doesn't getLine do it ?
20:50:50 <kaspyanand> vixey:i dont get it
20:51:08 <vixey> kaspyanand: What about it isn't clear yet?
20:51:58 <kaspyanand> vixey:well
20:52:06 <kaspyanand> say i wrote my own length function
20:52:11 <kaspyanand> myLength :: [a] -> Int
20:52:11 <kaspyanand> myLength []=0
20:52:11 <kaspyanand> myLength x= 1 + myLength (tail x)
20:52:21 <vixey> ok
20:52:30 <dons> myLength (x:xs) = 1 + myLength xs
20:52:31 <kaspyanand> here call is mtachinh to my declartion
20:52:32 <dons> -- better form.
20:52:45 <vixey> What's mtachinh?
20:52:50 <allbery_b> "matching"
20:52:51 <kaspyanand> mtaching
20:52:56 <kaspyanand> matching
20:52:59 <vixey> ok
20:53:23 <kaspyanand> dons:so my question is how mylength xs mtaches myLength (x:xs)
20:53:40 <dons> once you've ruled out [] , it falls through to try another case.
20:53:41 <vixey> no
20:53:46 <allbery_b> (x:xs) is a list in "cons cell" form
20:53:49 <dons> and xs will match whatever is left.
20:53:56 <vixey> kaspyanand: something like [5,6,87,3,4] matches (x:xs)
20:54:03 <dons> the other way to think about it is to look at the definition of the list type
20:54:05 <dons> ?src []
20:54:05 <lambdabot> data [] a = [] | a : [a]
20:54:08 <allbery_b> 91,2,3,4
20:54:11 <allbery_b> oops
20:54:13 <dons> which has two alternatives, [] or x : xs
20:54:23 <allbery_b> [1,2,3,4] = 1:2:3:4:[]
20:54:24 <vixey> kaspyanand: since x and xs are variables, and [5,6,87,3,4] is the list, (5 : (6 : (87 : (3 : (4 : [])))))
20:54:30 <dons> [1,2,3] is sugar for 1 : (2 : (3 : []))
20:54:38 <vixey> kaspyanand: x is bound to 5, xs is bound to [6,87,3,4]
20:55:01 <vixey> same with "chop" example I gave earlier
20:55:18 <vixey> "chop" = 'c' : 'h' : 'o' : 'p' : []
20:59:06 <kaspyanan1> hi
21:00:03 <kaspyanan1> i lost connection
21:00:17 <vixey> hey
21:00:33 <vixey> you probably missed some things people have said
21:00:39 <kaspyanan1> vixey:i was asking about pattern matching
21:00:41 <kaspyanan1> yes
21:00:54 <vixey> look at the end of this file
21:00:54 <vixey> http://tunes.org/~nef/logs/haskell/08.07.12
21:01:52 <wuxia> what's the type of the following? it's certain not [a] -> a
21:01:53 <wuxia> listSum [] = 0
21:01:53 <wuxia> listSum (x:xs) = x + listSum xs
21:02:16 <vixey> wuxia: You can ask ghci what the type is
21:02:26 <wuxia> how?
21:02:28 <vixey> put this code into a file then, :l <filename>
21:02:31 <vixey> then :t listSum
21:02:38 <wuxia> cool; thanks
21:02:48 <vixey> In Haskell you can always have types inferred by the compiler*
21:02:59 <vixey> (* this is actually lie )
21:03:28 <jbapple> This is actually a lie*
21:03:34 <jbapple> (* this is actually a lie)
21:03:51 <vixey> lies
21:03:54 <vixey> :)
21:04:13 <vixey> what's new jbapple?
21:04:22 <vixey> that types site is good
21:04:35 <jbapple> Dan Piponi's slides are new
21:04:41 <wuxia> how do I interpret the (num T) part of: listSum :: (Num t) => [t] -> t
21:04:47 <jbapple> They have me thinking about logarithms of types
21:04:51 <vixey> is it online ?
21:05:04 <jbapple> http://types.reddit.com/
21:05:08 <jbapple> Should be the top link
21:05:08 <vixey> ok I have not thought about transendental functions like that (is that the name?)
21:05:21 <vixey> wuxia: Num is a type class, t is any member of the Num class
21:05:24 <vixey> @instances Num
21:05:25 <lambdabot> Double, Float, Int, Integer
21:05:33 <jbapple> I think log counts as transcendental, yes
21:05:34 <vixey> wuxia: any of these.. there are more actually as well
21:05:42 <wuxia> why can't it be more genral
21:05:46 <wuxia> i don't need it to supporrt (
21:05:50 <wuxia> err, *
21:05:56 <wuxia> it needs only to suppor5t +
21:05:57 <vixey> wuxia: More specific you mean?
21:06:06 <wuxia> no, more general
21:06:07 <jbapple> It turns out that e^x means "bags of type x"
21:06:11 <vixey> jbapple: oh I read that Thrists thing yesterday it's cool
21:06:18 <wuxia> Num requires that the ytpe supports * and +; in actualitiy; the type needs only support +
21:06:32 <vixey> wuxia: + is part of Num
21:06:37 <wuxia> yeah
21:06:41 <wuxia> byt the typing can be more general
21:06:41 <vixey> wuxia: + might be defined in terms of * and so on
21:06:46 <wuxia> how?
21:06:54 <wuxia> this sounds likie nonsense
21:06:55 <vixey> wuxia: You can make your own typeclas which only supports addition
21:06:59 <vixey> wuxia: This is haskell
21:07:01 <jbapple> Since e^x is x + x^2/2 + x^3/3! + x^4/4! . . .
21:07:19 <vixey> wuxia: It's either nonsense or not, but at least we can both communicate with it
21:07:36 <jbapple> Which can be seen as either an x, or two x's without order, or three x's without order, etc.
21:07:38 <wuxia> i5t might also be undecidable
21:07:54 <vixey> yeah division by factorial makes sense as saying.. I don't care about ordering
21:08:26 <jbapple> So, what is the ln of a type?
21:09:25 <jbapple> ln x is a type y that x is a bag of
21:09:34 <jbapple> Here are a few examples:
21:10:02 <jbapple> There is only one bag of the empty type: the empty bag
21:10:12 <jbapple> so e^0 = 1 and lg 1 = 0
21:10:27 <vixey> oh
21:10:29 <jbapple> e^x = x and lg e^x = x
21:10:38 <jbapple> but here's a strange one:
21:11:13 <jbapple> let the type constructor t be t(x) = (t(x),t(x))
21:11:24 <jbapple> That is, a t(x) is a pair of t(x)'s
21:12:06 <jbapple> so lg (t(x)) = lg (t(x),t(x))
21:12:23 <jbapple> = (lg t(x))*(lg t(x))
21:12:33 <vixey> jbapple, data T x where T :: T (T x, T x) ?
21:12:35 <jbapple> sorry, scratch that, typo
21:12:39 <bd_> wouldn't t(x) only be inhabited by one value?
21:12:42 <vixey> just to be sure I understand your notation
21:12:44 <jbapple> bd_: yes
21:12:59 <jbapple> data T x = T (T x) (T x)
21:13:04 <bd_> thus wouldn't it be the same case as lg 1? assuming 1 = a type inhabited by a single value
21:13:13 <vixey> oh right I was complicating things for no reason
21:13:18 <jbapple> lg t(x) = lg t(x) + lg t(x)
21:13:34 <bd_> therefore lg t(x) = 0 = lg 1?
21:13:37 <jbapple> bd_: seems like it
21:14:00 <jbapple> but this derivation gives us lg t(x) = lg t(x) + lg t(x)
21:14:09 <jbapple> or lg t(x) is a stream of bools
21:14:24 <vixey> oh neat
21:14:32 <jbapple> but how could we get a bag of streams of bools out of a t(x)?
21:14:43 <jbapple> I dunno
21:14:50 <jbapple> Here's another one:
21:14:51 <dolio> lg t(x) = lg 1 = 0 = 0 + 0 = lg 1 + lg 1 = lg t(x) + lg t(x)
21:15:03 <bd_> lg t(x) = lg t(x) + lg t(x) <-- isn't this kind of not useful, since we know lg t(x) = 0, and can construct any number of such statements?
21:15:18 <bd_> or am I confusing myself now...
21:15:36 <bd_> wait, I think I'm confusing types and numbers XD
21:15:42 <jbapple> Maybe you guys are right
21:16:52 <dolio> How is that a stream of bools?
21:17:00 <dolio> I'm not following.
21:17:33 <jbapple> dolio: data Lgt x = Either (Lgt x) (Lgt x)
21:18:12 <jbapple> You can think of it as an infinite binary tree with all but one descending path deleted
21:19:10 <jbapple> here's another one: data From x = From (x -> From x)
21:19:26 <vixey> F(x) = F(x)^x ?
21:19:39 <bd_> oh, (t(x),t(x)) was alternation, not a pair constructor...
21:19:54 <vixey> hey we should use log base 2 right? :)
21:19:56 <jbapple> bd_: No, it is pairs
21:20:00 <bd_> ... oh XD
21:20:07 <bd_> then it's not a stream of bools, is it?
21:20:25 <jbapple> vixey: No, we should use the natural log, for the bag/factorial reason
21:20:35 <vixey> oh right, of course
21:20:46 <jbapple> bd_: Well, T isn't, but Lgt is
21:21:16 <jbapple> ln (F(x)) = ln (F(x)^x) = x * ln(F(x))
21:21:25 <jbapple> ln (F(x)) = Stream x
21:21:29 <dolio> I'm not sure about these rules.
21:21:43 <dolio> 0 = 0 + 0 is a valid rule, but only for strict sums.
21:21:45 <jbapple> but, of course, there's only one inhabitant of F(x)
21:21:57 <vixey> huh
21:22:07 <vixey> forget _|_
21:22:35 <jbapple> let y = From (const y)
21:22:56 <dolio> But T x = T x * T x is uninhabited inductively, for instance.
21:23:14 <jbapple> Right, these are coinductive types
21:23:21 <vixey> 0+0 doesn't have any coinductive inhabitant
21:26:29 <mofmog> for some reason parsec has decided to stop parsing stuff 0_0
21:26:41 <vixey> not here
21:26:48 <vixey> parsec is still working
21:27:02 <mofmog> i have something like parseExpr = parseA <|> parseB <|> parseC
21:27:11 <mofmog> then i messed around with A and itll no longer parseC
21:27:20 <mofmog> even though they dont take in the same input
21:27:28 <vixey> parseExpr = try parseA <|> parseB <|> parseC
21:27:31 <vixey> try this
21:27:35 <dolio> If you allow 0+0 = 0, then z : 0 ; z = Left z
21:27:45 <vixey> if it works again, you'll know why it didn't work without try
21:28:14 <mofmog> try means that if it fails you put back the taken input right?
21:28:20 <vixey> dolio: I guess = is a bad name for it
21:28:31 <vixey> they have the same cardinality
21:28:42 <vixey> but you can't substitute them
21:28:47 <dolio> Yeah, they're isomorphic.
21:29:28 <jbapple> Are they isomorphic?
21:29:35 <jbapple> I guess so
21:29:36 <vixey> there's more about types than just cardinality though
21:29:41 <jbapple> The isomorphism is {}
21:29:56 <vixey> I mean [N] and N are the same cardinality, and of course there exists bijections...
21:29:59 <mofmog> nope, try doesn't help
21:30:07 <mofmog> *** Exception: Prelude.read: no parse
21:30:15 <mofmog> if i try to run one parser at a time they all work
21:30:18 <vixey> mofmog: maybe parseA is just broke
21:30:26 <vixey> oh really do they use recursion?
21:30:38 <vixey> I mean does parseA or B or C depend on parseExpr
21:30:50 <mofmog> yeah they do
21:31:01 <mofmog> parseB might be a list of parseExprs
21:31:14 <kaspyanand> vixey:i understood explanation related to my q on pattern matching
21:31:16 <jbapple> Maybe isomorphic means only in the sense used in "seven trees in one"
21:31:19 <kaspyanand> thks
21:31:48 <vixey> kaspyanand: ok good I'm glad
21:32:03 <jbapple> that is, a bijection that terminates
21:32:19 <vixey> jbapple: I've never heard about seven trees in one, what's that?
21:32:26 <vixey> oh
21:32:42 <vixey> I'll read it
21:34:12 <vixey> jbapple: A fun thing to do in Coq is prove Bool <> Nat or Bool <> (Bool * Bool)
21:34:29 <kaspyanand> there is an example in chapter on functional programming,http://book.realworldhaskell.org/beta/fp.html
21:34:30 <lambdabot> Title: Chapter¬ 5.¬ Functional programming
21:34:39 <kaspyanand> in which there is this statement
21:34:50 <kaspyanand> loop acc (x:xs) = let acc' = acc * 10 + ord x - ord '0'
21:34:51 <kaspyanand> in loop acc' xs
21:35:01 <kaspyanand> what is happening here?
21:35:52 <mofmog> oh shoot i found my problem
21:35:57 <mofmog> i used "many" instead of "many1"
21:35:59 <mofmog> *rolleyes*
21:40:04 <Cale> kaspyanand: Well, it looks like code for turning a string into an integer
21:40:59 <wuxia> :t xip
21:41:01 <lambdabot> Not in scope: `xip'
21:41:05 <wuxia> :t zip
21:41:05 <Cale> kaspyanand: It might be helpful just to run it by hand on a given parameter
21:41:06 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
21:41:21 <jbapple> Here's another logarithm:
21:41:49 <dolio> Anyhow, I guess I'm just weirded out by there being two distinct solutions to 'x ~~ x + x'.
21:41:49 <jbapple> All ()'s are equal
21:41:50 <jbapple> So bags of ()'s are lists of ()'s
21:41:51 <wuxia> hmm, haskell SOE says the type of zip is: ( a -> b -> c) -> [a] -> [b] -> [c] ...
21:42:04 <jbapple> so ln [()] = ()
21:42:06 <vixey> haha "The reader who objects that this is nonsense has not truly entered into the eighteenth-century spirit"
21:42:21 <Cale> loop 0 "123"
21:42:24 <Cale> = let acc' = 0 * 10 + ord '1' - ord '0' in loop acc' xs
21:42:32 <jbapple> or ln [1] = 1
21:42:32 <Cale> = let acc' = 1 in loop acc' xs
21:42:47 <Cale> er... xs = "23" of course :)
21:42:49 <jbapple> so e = [()] = 2.718281828
21:42:56 <Cale> = loop 1 "23"
21:43:02 <jbapple> :-)
21:43:09 <vixey> hehe
21:43:22 <Cale> = let acc' = 1 * 10 + ord '2' - ord '0' in loop acc' "3"
21:43:40 <Cale> = let acc' = 10 + 2 in loop acc' "3"
21:43:46 <Cale> = loop 12 "3"
21:44:10 <Cale> = let acc' = 12 * 10 + ord '3' - ord '0' in loop acc' ""
21:44:20 <Cale> = let acc' = 120 + 3 in loop acc' ""
21:44:27 <Cale> = loop 123 ""
21:44:37 <jbapple> Bags of bools are just some number of Trues and some number of Falses.
21:44:46 <Cale> kaspyanand: follow that?
21:44:51 <jbapple> So exp(Bool) = Bool -> Nat
21:45:10 <jbapple> and Nat = [()]
21:45:58 <jbapple> so ln (exp(Bool)) = ln (Bool -> Nat) = ln(Nat^Bool) = 2 * ln e = 2
21:46:43 <jbapple> In fact, bags of anything are just maps from these things to Nat
21:47:31 <jbapple> Which looks right with lnn (x^y) = y ln x
21:49:10 <bremner> I'm having newbie trouble with mkUGraph from fgl. Simple examples seem to fail http://pastebin.ca/1070604
21:49:32 <bremner> ^^ in ghci
21:50:35 <wuxia> for built in functions in prelude, i can write my own version (for education) by prepdnting it with my; i.e. length -> myLength, etc ... what is a good convention for infix opeartors, like ++?
21:50:40 <wuxia> since i can't use alpha numeric chars in them
21:50:50 <vixey> wuxia,
21:50:57 <wuxia> yeah
21:50:58 <vixey> import Prelude hiding ((++),length)
21:51:06 <vixey> at the start of your file
21:51:12 <wuxia> hmm, i'd rather not hide them; jus5t create my own vbersion
21:51:15 <wuxia> so i can compare results of the two
21:51:24 <vixey> You can then use, Prelude.++
21:51:26 <vixey> or ++
21:52:26 <wuxia> is there some char that haskell does not use ?
21:52:36 <wuxia> like maybe i can preprend aoo my own versions with ##
21:52:57 <vixey> just hide the Prelude definitinos
21:53:01 <Cale> wuxia: Sure
21:53:11 <Cale> You can define #++ if you want.
21:53:18 <Cale> or myLength
21:57:59 <wuxia> so `[a-z]+` is an infix operator?
21:58:18 <vixey> syntax error
21:58:24 <wuxia> regex
21:58:37 <vixey> :t (`[a-z]+`)
21:58:38 <lambdabot> parse error on input `['
21:59:21 <jbapple> and a pair of bags of t's (t -> Nat, t -> Nat) is the same as a bag of (Either t t)'s or a bag of pairs of t's and Bools: lg N^t * N^t = lg N^2t = 2t lg N
22:00:08 <kaspyanan1> hi
22:00:50 <TomMD> Hello kaspyana1.
22:00:50 <kaspyanan1> in this statement aaa x y = let r = 3
22:00:50 <kaspyanan1>               s = 6
22:00:50 <kaspyanan1>               in  r*x + s*y
22:01:19 <kaspyanan1> it means that r and s value will be used in the expression as 3 and 6
22:03:30 <kaspyanan1> this loop acc (x:xs) = let acc' = acc * 10 + ord x - ord '0'    in loop acc' xs
22:03:42 <kaspyanan1> represents tail recursion?
22:04:36 <kaspyanan1> whereas a function  like
22:04:37 <kaspyanan1> myLength :: [a] -> Int
22:04:38 <kaspyanan1> myLength []=0
22:04:38 <kaspyanan1> myLength x= 1 + myLength (tail x)
22:04:44 <kaspyanan1> is a normal recursion?
22:05:46 <vixey> kaspyanan1: Exactly
22:08:21 <misterbeebee> If I have a data type "data Struct  = mkStruct Foo Bar Baz" , and I want to modify Foo or Bar frequently and independently in an STRef (for efficiency, to re-use the structure that is not changing) , is it possible to write it using one "STRef s Struct", or must I go with  "mkStruct  (STRef Foo) (STRef Bar) (STRef Baz)" ?
22:08:34 <dolio> jbapple: ln T = ln T + ln T --> ln T = ln (T*T) --> T = T*T ; ln T = 2^Nat --> T = e^(2^Nat)?
22:09:51 <misterbeebee> in other words, if I have a giant structure, and I really really know that I'm only every going to read from it in one loop, and all other users of the data will get strict results, how can I maintain the changing state efficiently?
22:10:04 <ddarius> dolio: ln is not injective in general
22:10:51 <jbapple> dolio: How did you get "Ôªøln T = 2^Nat"
22:11:12 <dolio> 2^Nat is the type of infinite boolean streams.
22:11:21 <jbapple> oh, right
22:11:39 <bd_> misterbeebee: unfortunately, haskell's type system does not support uniqueness typing, so it's not possible to update a field in a struct safel
22:11:42 <bd_> y
22:12:12 <bd_> ie you must recreate the struct, or insert a ST or IORef in between
22:12:37 <vixey> is uniquness typing is different to affine typing?
22:12:39 <misterbeebee> alas.
22:12:52 <vixey> misterbeebee: It's not a big deal, e.g. ST exists
22:12:56 <jbapple> dolio: Something funny is going on with this datatype T
22:13:00 <ddarius> vixey: I believe so.
22:13:25 <ddarius> Actually, it's definitely different.
22:13:47 <dolio> jbapple: Maybe a bag of boolean streams is isomorphic to 1?
22:13:47 <vixey> it says here "In computing, a unique type guarantees that an object is used in a single-threaded way, with at most a single reference to it."
22:14:05 <misterbeebee> vixey: I know ST exists. So do I need to make an STRef for every  element in an ADT?
22:14:21 <vixey> misterbeebee: Only the ones which you will mutate
22:14:38 <misterbeebee> Right.
22:14:49 <jbapple> dolio: But there are at least two different bags of boolean streams, and only one 1.
22:16:34 <ddarius> vixey: http://lambda-the-ultimate.org/node/2708
22:16:35 <lambdabot> Title: Uniqueness Typing Simplified | Lambda the Ultimate
22:16:56 <vixey> thank you
22:18:25 <vixey> I thought linear meant used once
22:18:30 <vixey> not will not be duplicated
22:18:50 <vixey> I was looking at this permutation program which uses o-
22:19:11 <vixey> and if you have linear mean use once it works, but if you have linear means not duplicated it gives a powerset instead
22:19:33 <vixey> is it just that the term linear is being used for whatever anyone wants ?
22:19:40 <electronx> just wandering anyone created a site in haskell?
22:20:04 <Cale> electronx: yeah
22:20:18 <electronx> how did it go?
22:20:26 <Cale> electronx: (well, not me specifically, but people have created a number of successful web applications in Haskell)
22:20:28 <ddarius> vixey: linear is often used to refer to the collection of the main substructural logics.
22:20:43 <electronx> would a language like ruby be much better?
22:20:46 <vixey> ok that makes sense
22:20:56 <electronx> Haskell is strongly typed
22:21:18 <geezusfreeek> electronx: so is ruby, but i suppose you mean statically typed?
22:21:24 <Cale> That's an advantage of Haskell, in my mind :)
22:21:26 <electronx> ya
22:21:48 <electronx> i'm currently making my site in ror but i'm worried about peformance
22:22:04 <ddarius> Cale: What's a web application without buffer overflow exploits?
22:22:18 <electronx> i'm hoping that ruby 1.9 will fill that gap
22:22:19 <dolio> jbapple: e^(2^Nat) * e^(2^Nat) = e^(2^Nat + 2^Nat) ~ e^(2^Nat)?
22:22:19 <Cale> (btw, types are not about performance, but correctness)
22:22:23 <geezusfreeek> electronx: i wouldn't worry about performance, but if i did then haskell would be a fine choice over ruby
22:22:46 <vixey> I like common lisp for it
22:22:47 <electronx> yes haskell would be much faster no doubt
22:23:01 <vixey> I don't know if you can hack the site written in haskell while it's still running
22:23:06 <electronx> just wandering the dev time
22:23:36 <Cale> electronx: The only disadvantage to using Haskell would be that there are most likely far fewer people who have written web apps in Haskell as of yet.
22:23:37 <electronx> any sites with links i can visit i have only seen one and i wasn't impressed
22:24:03 <electronx> Cale: thats what concerns me
22:24:05 <geezusfreeek> hpaste is made in happs, right?
22:24:09 <Cale> Well, there's hpaste, which we use all the time. There's also Hope.
22:24:20 <jbapple> dolio: By "~", do you mean cardinality?
22:24:36 <geezusfreeek> and of course happs.org is running happs
22:24:39 <Cale> Yeah, hpaste is using happs
22:24:43 <electronx> Cale: Happs doesn't seem like it has been updated for a while
22:24:52 <dolio> jbapple: I was thinking isomorphic.
22:24:56 <geezusfreeek> no happs is under very active development
22:25:01 <Cale> It's still in active development as far as I know
22:25:01 <geezusfreeek> it's documentation sucks so far though
22:25:09 <electronx> geezusfreeek: neither of those sites seem to be impressive
22:25:23 <geezusfreeek> electronx: afraid you won't find very impressive ones yet
22:25:24 <vixey> does happs build ?
22:25:24 <jbapple> dolio: How is Ôªøe^(2^Nat + 2^Nat) isomorphic to e^(2^Nat)?
22:25:34 <geezusfreeek> unless you make one, which is not infeasible
22:25:35 <Cale> Is any website impressive?
22:25:46 <dolio> jbapple: 2^Nat + 2^Nat is isomorphic to 2^Nat.
22:26:10 <dibblego> Cale, no
22:26:15 <Cale> (For any reason other than its content)
22:26:17 <jbapple> dolio: By interleaving, say?
22:26:39 <jbapple> I still think we want the restricted idea of bijection offered in 7 trees in 1
22:26:53 <dolio> f (Left s) = False:s ; f (Right s) = True:s ; g (False:s) = Left s ; g (True:s) = Right s
22:27:33 <geezusfreeek> i think google is pretty impressive
22:28:34 <jbapple> dolio: hm
22:30:22 <jbapple> So, a pair of bags of streams of bools is isomorphic to a bag of stream of bools
22:30:33 <dolio> Apparently.
22:30:57 <jbapple> How do we go from a bag of streams of bools to a pair?
22:32:12 <jbapple> we could remove the first bool from every stream
22:32:24 <dolio> Looking up (False:s) is looking up s in the left bag, looking up (True:s) is looking up s in the right bag.
22:32:25 <jbapple> then put the trues in one bag and the falses in another
22:32:29 <jbapple> :-)
22:33:13 <dolio> But how do you look up a stream?
22:33:20 <dolio> You can't decide equality on streams.
22:33:53 <jbapple> Why do we need "looking up"?
22:34:38 <vixey> Is this a fact "Because linear types are very visible to the programmer, it makes no sense to infer linearity a la ML type inference" ?
22:34:48 <dolio> How do you tell how many of a given stream are in a bag, I mean?
22:35:08 <jbapple> dolio: You can't
22:35:15 <dolio> Right.
22:36:00 <ddarius> vixey: I'm not sure what that's supposed to mean.  Clean infers uniqueness types I'm pretty sure.  Of course it does make sense that usually you'll want to enforce a particular modality.
22:36:03 <dolio> So the 2^Nat -> Nat can only look at a finite prefix of the stream.
22:36:03 <jbapple> So, how could we represent bags of streams, since we can't expect Stream Bool -> N to terminate?
22:36:08 <jbapple> hm.
22:36:17 <vixey> I see
22:37:03 <dolio> So it must contain equal numbers of streams for each particular prefix.
22:37:37 <jbapple> So, for instance, there are no finite bags of streams except for the empty one
22:37:40 <electronx> can haskell have metprogramming
22:37:47 <electronx> metaprogramming
22:38:11 <jbapple> dolio: Maybe that explains the strange behavior of T
22:38:16 <dolio> Right.
22:38:20 <jbapple> wow
22:38:23 <electronx> just wandering if a rails type framework is possible in haskell
22:38:54 <dibblego> electronx, it's possible, but nobody in their right mind would write it
22:39:11 <dibblego> that's why you won't find it
22:39:34 <dolio> jbapple: Is e^x defined as finite bags of x?
22:39:53 <ddarius> dibblego: I'd like my programming framework to add bugs for me to save me the time.
22:40:07 <jbapple> dolio: I don't know
22:40:17 <dolio> If it is, then it is isomorphic to 1.
22:40:20 <ddarius> dolio: It should be.
22:40:45 <jbapple> dolio: If it is, then t -> N is not e^t for any infinite t
22:40:47 <electronx> dibblego: why wouldn't they write it?
22:40:59 <electronx> dibblego: to difficult?
22:41:01 <dolio> Because the only finite bag of boolean streams is the empty bag.
22:41:33 <dibblego> electronx, because Haskell prefers abstraction, composition and overall a much saner approach; it's not difficult, it's just silly
22:42:09 <electronx> dibblego: i see :)
22:43:34 <dolio> At least, the only computable such bag, I guess.
22:49:48 <jbapple> dolio: OTOH, if we define a bag of bitstreams to be an ordered list of bitstreams, then we can certainly list some more finite bags
22:50:42 <jbapple> But we can't for instance, insert a bistream into a bag
22:51:02 <Armored_Azrael> Is there any kind of idiom for memoization? I've been just using an IORef to construct a memoized function up until now, but it feels really unclean
22:51:03 <jbapple> At least, not always
22:52:11 <dolio> A bag isn't an ordered list, though.
22:52:20 <dolio> It's an unordered list.
22:52:46 <jbapple> dolio: I should have said a sorted list
22:53:27 <jbapple> I meant to put a constraint on the ordering so that two equal bags must be rendered the same as lists.
22:53:34 <dolio> Oh, I see.
22:53:44 <dolio> I was thinking ordered in the wrong way.
22:56:06 <paczesiowa> Armored_Azrael: http://www.haskell.org/haskellwiki/Memoization
22:56:07 <lambdabot> Title: Memoization - HaskellWiki
23:02:22 <jbapple> http://hpaste.org/8901
23:02:34 <jbapple> Finite bags of natural numbers
23:20:33 <mmorrow> some things to think about when webprogramming http://www.isecpartners.com/files/iSEC-Attacking_AJAX_Applications.BH2006.pdf
23:20:34 <lambdabot> Title: Slide 1, http://tinyurl.com/yy7px6
23:23:09 <wuxia> how cna I rewirt the following, expressing revO(p in  lambda notation> myReverse3 lst = foldl revOp [] lst where revOp a b = b : a
23:23:34 <vixey> revOp a b = b : a
23:23:41 <vixey> revOp = \a b -> b : a
23:23:44 <vixey> revOp = \a b -> (:) b a
23:23:51 <vixey> revOp = flip (:)
23:24:10 <vixey> yourReverse3 = foldl (flip (:)) []
23:24:17 <vixey> @src reverse
23:24:19 <lambdabot> reverse = foldl (flip (:)) []
23:26:40 <wuxia> vixey: cool, thanks
23:26:45 <mmorrow> wuxia: nice, you independently discovered the best way to write reverse
23:27:43 * vixey prefers reverse xs = revappend xs []
23:28:07 <wuxia> mmorrow: no, i'm just readintg school of expression; i'm not that smart
23:28:22 <mmorrow> and a bad liar
23:28:32 <mmorrow> ;)
23:28:40 <wuxia> err, page 71
23:28:47 <wuxia> of haskell scholl of expression ...
23:29:12 <mmorrow> heh, i didn't even notice that the word "haskell" was missing
23:39:27 <mmorrow> hah. the haskell syntax highlighting in gedit also is haddock-syntax aware, and renders stuff in -- | /...here.../  in italics
23:41:07 <mmorrow> i don't think i've ever seen a syntax highlighter that also changes the style/whatever-the-general-term-for-italics-etc-is of text
23:42:20 <wuxia> anyone here code for haskell in yi?
23:43:26 <mmorrow> not i, vim or kdevelop(nice highlighting)
23:44:16 <mmorrow> i've always meant to try yi, though
23:44:40 <mmorrow> i read a paper about hs-plugins that had a section describing yi and it sounds sweet
23:45:24 <mmorrow> wuxia: do you?
23:46:41 <wuxia> i'm also a vim user
23:46:56 <wuxia> what scripts do you use for haskell editing?
23:46:59 <wuxia> i find myself manually editing alot
23:47:17 <wuxia> whereas with other langauges, I just do 1G= and have everyhting autoindented
23:47:20 <vixey> I gave up on haskell-indentation-mode it was so painful
23:47:51 <mmorrow> the one (and only) awesome thing about gedit is that, if there's already a gedit instance running, and you do "$ gedit somefile.txt", it connects to the gedit instance which is listening on some port, tells it to load that file, then somefile.txt loads in the already-running gedit instance
23:48:17 <wuxia> vim does suck in taht it goes ".somefile.txt.swp already ecists ..."
23:48:34 <mmorrow> so you can just be walking through some project dir, and keep $ gedit interesting.hs files, and they'll all be collected in tabs in a single gedit instance
23:48:53 <mmorrow> *so* convenient
23:50:15 <mmorrow> wuxia: oh, if somefile.txt is already opened in the gedit instance you're trying to open another one in, it doesn't load it (or tell you that its not doing so...)
23:51:35 <mmorrow> oh, it's not listening on a port:
23:51:48 <mmorrow> unix  2      [ ACC ]     STREAM     LISTENING     587424 19858/gedit         /tmp/gedit.m.4055904243
23:51:48 <mmorrow> unix  2      [ ACC ]     STREAM     LISTENING     587419 19858/gedit         /tmp/orbit-m/linc-4d92-0-569a15e6b3e3
23:51:48 <wuxia> having used xmonad for a month; i now have faith that something like yi can succeed
23:52:08 <mmorrow> xmonad is rad^2
23:52:38 <mmorrow> i used it for a few months, but never installed it when i upgraded to fedora8 a few months ago
23:53:21 <wuxia> having configured it; i can't imagine switching back at all
23:53:31 <wuxia> plus, it's only like 1k loc
23:54:26 <mmorrow> as long as i have the gnome-toolbar also running, i'd be happy
23:54:37 <mmorrow> (an you can and i did)
23:54:42 <mmorrow> s/an/and/
23:55:45 <mmorrow> the little system-monitor realtime graphs for proc/mem/net/swap/disk are something that i just can't live without
23:59:43 <mmorrow> wuxia: you just convinced me to install it again...
