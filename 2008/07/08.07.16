00:02:31 <pyNem> dmwit, oh .. thanks :)
00:07:11 <quicksilver> dobblego: Traversable is more general than lists, how would it know what shape to arrange your numbers in?
00:07:20 <quicksilver> dobblego: it could take an input traversable and copy that shape.
00:08:03 <quicksilver> there is no straightforwrd Traversable generalisation of unfold: you need to replace the 'Maybe' in the unfold with a more complex type which indicates wich direction to walk around the structure.
00:08:16 <quicksilver> (which depends on the exact structure)
00:12:56 <_zenon_> Good morning
00:18:26 <_zenon_> to early?
00:19:04 <dmwit> Where's early?
00:19:23 <_zenon_> Well, it's 09:19, I give you that, it's not really early
00:19:38 <_zenon_> but someone in here might be -X h
00:19:38 <dolio> It's 3:19 here. That's pretty early.
00:19:47 <_zenon_> dolio, or late
00:20:15 * ski sips early grey
00:20:42 * _zenon_ is going for a Svenska Kaffe
00:20:50 <_zenon_> Damn auto completion!
00:20:53 <_zenon_> Svensk*
00:21:03 <ski> Cirkel ?
00:21:33 <_zenon_> ski, Cirkel?
00:21:52 <dolio> That's what he said.
00:22:10 <ski> yes, i did
00:22:21 <ski> _zenon_ : Cirkel Kaffe ?
00:23:05 <_zenon_> ski, Ah, nej. Löfbergs
00:23:25 * ski vet inte mycket om kaffe, iofs
00:26:26 * _zenon_ lyssnar på Ring p1 :)
00:27:01 <_zenon_> For those outside Sweden, "Call P1" is a radio program where people call and say how angry they are about something and then debate on it.
00:27:35 <dmwit> ?index readFile
00:27:36 <lambdabot> System.IO, Prelude
00:27:48 <pyNem> i am a n00b to haskell.. can someon explain to me why "hello!" and "bye!" dont get printed here - http://dpaste.com/65299/ (relevant part lifted from hitchikers guide to haskell)
00:27:50 <dmwit> ?index getArgs
00:27:50 <lambdabot> System.Environment
00:28:25 <dmwit> pyNem: The "let" binding only creates an IO action; it doesn't run it.
00:28:30 <ski> _zenon_ : oh, radio .. i've heard about that
00:28:48 <dmwit> pyNem: Try adding a line just containing "b" after the two let bindings.
00:28:49 <_zenon_> ski, don't you listen to radio?
00:28:49 <pyNem> dmwit, yeah i thought so ... then how come c is executed ?
00:29:01 <pyNem> in let d = (combine c c)
00:29:02 * shepheb wonders how many Haskellers who know enough Swedish to understand your discussion wouldn't know about the radio program
00:29:06 <dmwit> pyNem: It's not.
00:29:08 <ski> _zenon_ : well, sometimes i listen to SLAY, but otherwise, no
00:29:25 <dmwit> pyNem: Note that (combine c c) is also the first line of the do block.
00:29:28 <pyNem> oh .. the c that was getting executed is on the first line
00:29:32 <dmwit> yep
00:29:50 <pyNem> dmwit, while we are it, can you explain the syntax indentation to me? i had a tough time.. i ended up with braces and ;
00:30:18 <dmwit> pyNem: "do" and "let" (and maybe a few others?) introduce "blocks".
00:30:24 <pyNem> ok ..
00:30:32 <_zenon_> shepheb, maybe more than you know :) There are some nice places in the US with a lot of Swedish traditions
00:30:33 <dmwit> pyNem: The beginning of each expression in a block must start in the same column.
00:30:41 <pyNem> ok ..
00:31:08 <dmwit> pyNem: That's pretty much it.  Tabs go to the next column that's a multiple of 8, but in reality, tabs ought to go to Hell. =)
00:31:30 <pyNem> thats all is it? so it is of no significance that the main do block is indented further than the combine do block?
00:31:47 <pyNem> dmwit, i cant write with tabwidth=4 in vim?
00:31:49 <dmwit> pyNem: Right, those are separate blocks, so they need not be indented the same amount.
00:32:14 <dmwit> pyNem: Sure you can.  Just be aware that if you don't also set expandtab, you will likely get lexical errors.
00:32:49 <pyNem> dmwit, i hadnt set expandtab
00:32:50 <pyNem> :D
00:33:02 <dmwit> pyNem: I set sts=4, tw=4, ai, and et
00:33:19 <dmwit> s/tw/ts/
00:33:20 <pyNem> dmwit, oh .. :) ill add it autocmd hs then :)
00:33:41 <pyNem> dmwit, lastly, can i have indentation like this http://dpaste.com/65300/ ?
00:33:51 <dmwit> Certainly.
00:34:01 <pyNem> dmwit, thanks :)
00:34:16 <dmwit> pyNem: Also, if you post to hpaste.org, you'll get nicely syntax-coloured results, and it will be announced here for you. =)
00:34:35 <pyNem> dmwit, oh ok .. thanks :)
00:34:58 <_zenon_> pyNem, this is a good small entry on indentation http://en.wikibooks.org/wiki/Haskell/Indentation
00:35:17 <Adamant> anyone try using Haskell's GLUT bindings on OS X?
00:35:35 <pyNem> _zenon_, thanks .. looking at it right now :)
00:35:56 <Adamant> does OS X come with GLUT or do I need to get freeglut/openglut?
00:40:36 <BeelsebobWork> Adamant: OS X has a glut install already
00:40:55 <BeelsebobWork> various people say it's rather limiting -- I find that rather farsical in the context of talking about glut
00:42:51 <Adamant> thanks, I found the problem - forgot to name the module Main
00:49:31 <dmwit> Darn it!
00:49:46 <dmwit> I wish ($) was assocl.
00:53:34 <therp> isn't the whole idea of $ not that it's right associative?
00:54:20 <dmwit> infixr 0 $ -- according to my GHC
00:54:34 <dmwit> But it should be infixl 0, so you could do
00:54:40 <dmwit> ((f . g) x) y -> f . g $ x $ y
00:55:06 <TSC> @type uncurry3
00:55:16 <therp> you don't need the second pair of brackets.. (f . g) x y
00:55:22 <lambdabot> thread killed
00:55:27 <dmwit> therp: That parses as (f . g) (x y)
00:55:34 <dmwit> therp: Which *definitely* isn't what I want.
00:55:59 <dmwit> ...I think it parses that way.
00:56:05 <therp> dmwit: regular "application" is left associative. (f . g) x y should parse as (f . g) x y
00:56:14 <therp> also f . g $ x y should work
00:56:15 <dmwit> > ((+) . id) 1 2
00:56:18 <lambdabot>  3
00:56:21 <dmwit> ok
00:56:41 <dmwit> therp: But f . g $ x y -- definitely not.
00:56:42 <Trinithis> $ is correcly infixr'ed
00:56:48 <dmwit> > ((+) . id) $ 1 2
00:56:49 <lambdabot>   add an instance declaration for (Num (t -> a))
00:57:49 <therp> hmm right.. f . g $ x y parses as f . g $ (x y)
00:57:52 <dmwit> Okay, in this case it didn't matter. =)
00:57:55 <Trinithis> @let dot = (.).(.)
00:57:56 <lambdabot> <local>:3:6:     Ambiguous type variable `f' in the constraint:       `Functo...
00:58:04 <dibblego> quicksilver, I am thinking of a function :: (Traversable t) => Int -> t Int I am not sure if such a function is possible though
00:58:05 * dmwit hums a tiny tune
00:58:44 <Trinithis> > ((+) `(.).(.)` id) $ 1 2
00:58:45 <lambdabot>  Parse error at "(.).(..." (column 7)
00:58:53 <Trinithis> > ((+) `((.).(.))` id) $ 1 2
00:58:54 <lambdabot>  Parse error at "((.)...." (column 7)
00:59:17 <dmwit> You can't enclose anything more complicated than a single identifier in ``s.
00:59:25 <Trinithis> oh
00:59:27 <dmwit> > (((+) .) . id) 1 2
00:59:29 <lambdabot>   add an instance declaration for (Num (t -> a))
01:00:27 <Trinithis> > let dot = (.).(.) in (id `dot` (+)) 1 2
01:00:31 <lambdabot>  3
01:12:56 <pyNem> i am on a ubuntu system .. ghc says unable to find Text.ParserCombinators.Parsec .. any idea how to fix this?
01:14:56 <BeelsebobWork> download and install parsec from hackage
01:15:48 <pyNem> BeelsebobWork, no apt-get possible?
01:16:20 <BeelsebobWork> pyNem: you can always install cabal-install, and then you'll get cabal install parsec
01:16:29 <_zenon_> pyNem, do an apt-cache search libghc parsec
01:16:45 <pyNem> _zenon_, will do ..
01:17:06 <pyNem> BeelsebobWork, if the apt-file search or apt-cache search doesnt work .. ill do it the cabal way
01:17:10 <Leaves> Hey, if I know a number is even and divide it by two, what is the best way to let the result be an Int and not a Fraction?
01:17:11 <_zenon_> pyNem, libghc6-parsec-dev - Haskell monadic parser combinator library for GHC
01:17:23 <_zenon_> pyNem,  sudo apt-cache search libg parse
01:17:51 <pyNem> _zenon_, Thanks :)
01:19:41 <_zenon_> pyNem, your'e welcome
01:23:21 <BeelsebobWork> @docs renderPrimative
01:23:22 <lambdabot> renderPrimative not available
01:23:37 <dibblego> primitive?
01:23:52 <Leaves> could someone help me, If I do n/2 and I know (even n) == True, what is the best way to let n/2 be an Integral?
01:24:24 <BeelsebobWork> dibblego: thank you, lysdexia for the win
01:24:28 <BeelsebobWork> @docs renderPrimitive
01:24:29 <lambdabot> renderPrimitive not available
01:24:31 <BeelsebobWork> lame
01:25:22 <quicksilver> that's not what @docs does, is it?
01:25:25 <quicksilver> @docs filter
01:25:25 <lambdabot> filter not available
01:25:30 <quicksilver> @docs Data.List
01:25:30 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
01:25:34 <quicksilver> that's what @docs does
01:25:34 <BeelsebobWork> oh, duh
01:25:40 <BeelsebobWork> I'm in moron mode today :(
01:25:46 <quicksilver> dibblego: no, it's not possible.
01:25:59 <osfameron> @index renderPrimitive
01:26:00 <dibblego> quicksilver, ok cheers :) it's been puzzling me
01:26:00 <lambdabot> Graphics.Rendering.OpenGL.GL.BeginEnd, Graphics.Rendering.OpenGL.GL, Graphics.Rendering.OpenGL, Graphics.UI.GLUT
01:26:15 <quicksilver> dibblego: certain traversables might, for example, only support supporting 'N' elements for some fixed N
01:26:24 <quicksilver> or some restriction on 'N's like exact powers of 2.
01:26:53 <quicksilver> Complete perfect balanced binary trees (every node filled, same height everywhere) are a traversable instance
01:26:54 <BeelsebobWork> @docs Graphics.Rendering.OpenGL
01:26:55 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/OpenGL/Graphics-Rendering-OpenGL.html
01:27:03 <quicksilver> but always have fixed power of two elements
01:27:15 <quicksilver> BeelsebobWork: HOpenGL has rather limited documentation.
01:27:22 <quicksilver> BeelsebobWork: fortunately I know it backwards. So ask away.
01:27:53 <BeelsebobWork> quicksilver: just trying to figure out how to chuck renderPrimitives Polygons a load of verticies, normals and texture coords
01:29:21 <quicksilver> renderPrimitive Polygons $ do vertex this; texcoord that; normal other; repeat; wash; rinse; repeat
01:29:29 <BeelsebobWork> ah, lame
01:29:44 <quicksilver> how's that lame?
01:29:48 <BeelsebobWork> probably a moment for sequence_
01:29:53 <quicksilver> (it's Polygon not Polygons, though)
01:29:57 <BeelsebobWork> because I have a big list of them
01:30:09 <quicksilver> yes, use forM-
01:30:11 <quicksilver> forM_
01:30:20 <quicksilver> HOpenGL doesn't reinvent the generic haskell combinators :)
01:30:28 <quicksilver> 99% of my uses of renderPrimitive involve forM_
01:30:46 <BeelsebobWork> heh
01:30:50 <quicksilver> however if you have a 'load' of vertices you might prefer to use VAs
01:30:58 <BeelsebobWork> what's different between forM_ and sequence_?
01:31:10 <BeelsebobWork> sure -- just doing this the naïve way atm
01:31:15 <BeelsebobWork> just want something on the screen
01:35:00 <quicksilver> sequence_ is for a list of IO actions
01:35:16 <quicksilver> forM_ feeds a list of values to an IO action which takes a parameter.
01:35:18 <quicksilver> :t sequence_
01:35:24 <quicksilver> :t forM_
01:35:34 <lambdabot> thread killed
01:35:40 <lambdabot> thread killed
01:36:34 <quicksilver> :t sequence_
01:36:35 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
01:36:35 <quicksilver> :t forM_
01:36:37 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
01:42:16 <visof> map f . map g = map (f.g) , how can i prove this ?
01:42:28 <visof> is this correct firstly?
01:42:59 <dibblego> yes, it's the law of composition over functors
01:43:14 <dibblego> there are proofs using the Coq system out there iirc
01:44:17 <BeelsebobWork> thanks quicksilver
01:47:18 <quicksilver> visof: you can prove it simply by expanding the definitions of the functions, carefully
01:48:37 <visof> quicksilver how?
01:50:21 <ski> map f . map g  =  \xs0 -> (map f . map g) xs0  =  \xs0 -> map f (map g xs0)  =  ..induction on xs0..  =  \xs0 -> map (f . g) xs0  =  map (f . g)
01:50:26 <ski> roughly
01:51:08 <BeelsebobWork> how does one go about removing a package from ghc?
01:52:38 <slarba> hm. is there read :: ByteString -> a
01:54:33 <visof> ski i can't understand
01:55:31 <ski> visof : which part don't you understand ?
01:56:02 <visof> map f . map g  =  \xs0 -> (map f . map g) xs0 , how ?
01:56:09 <ski> eta-expansion
01:56:24 <ski> @pl \x -> f x
01:56:25 <lambdabot> f
01:56:33 <visof> ah
01:57:11 <ski> (note that there's some evil cases with `seq' where this breaks, though ..)
01:59:39 <ski> for the induction, i think one needs to infer `\xs0 -> map f (map g xs0)  =  \xs0 -> map (f . g) xs0' from  `forall xs0.  map f (map g xs0)  =  map (f . g) xs0', and then use the induction on that
02:00:47 <visof> yeah
02:03:07 <ski> (well, possibly one could go directly to `map f . map g  =  map (f . g)' from `forall xs0.  (map f . map g) xs0  =  map (f . g) xs0' .. if one has such a functional completeness rule)
02:05:14 <visof> map f . map g  =  map (f . g), i can't understand why?
02:05:57 <visof> is it distribution rule?
02:06:03 <dibblego> no, the law of composition
02:06:14 <_zenon_> @src (.)
02:06:15 <lambdabot> (f . g) x = f (g x)
02:06:15 <lambdabot> -- In lambdabot, it's been generalised to:
02:06:15 <lambdabot> (.) = fmap
02:06:15 <quicksilver> map f says 'apply f to every element of the list'
02:06:39 <quicksilver> map f . map g says 'apply g to every element, then apply f to every element'
02:06:44 <visof> yeah
02:06:48 <quicksilver> map (f.g) says 'apply g then f to every element'
02:06:52 <quicksilver> that is the same thing.
02:06:54 <visof> can i prove (f . g) x = f (g x) ?
02:07:03 <quicksilver> that is the definition of .
02:07:10 <ski> yes, using the definition of `(.)'
02:07:31 <_zenon_> (map f) . (map g) y = (map f (map g y))
02:07:41 <ski> no
02:07:59 <ski> ((map f) . (map g)) y = (map f (map g y))
02:08:13 <_zenon_> ops, the outer paren
02:08:31 <_zenon_> true, it's something different without them
02:10:51 <visof> i understood
02:11:04 <visof> thanks
02:17:30 <BeelsebobWork> I need Arbitrary instances for the types defined in Graphics.Rendering.OpenGL, is there a better way to do this than to create a package that installs a Graphics.Rendering.OpenGL.TestInstances module?
02:18:57 <dolio> According to my profiling, that guy's CSV code spends 70% of its time and 78% of its allocation in maybeRead.
02:19:13 <ball_licker> I had bent haskell over in the br before
02:19:40 <ball_licker> nice dolio
02:19:51 <ball_licker> I thought it was just me
02:20:00 <dolio> Nope, not just you.
02:20:19 <ball_licker> well, hell to the fuck yeah then baby, so whats the next step
02:20:41 <ball_licker> need to lower those percentages
02:21:07 * ball_licker slaps aculich around a bit with a large trout
02:23:30 <slarba> BS.unpack is the root of all evil
02:24:03 <dolio> What's the state of the art C way to turn strings into doubles?
02:24:35 <slarba> my version of the csv parsing program completes in one second (160000 rows) if there was parser for floats in bytestring library
02:24:36 <Deewiant> C? strtod
02:24:37 <level2tech> lmao
02:24:57 <level2tech> try using a real lang
02:25:02 <slarba> eh
02:25:04 <slarba> :))
02:28:34 <visof> > reverse $ map (+2) [1..10]
02:28:42 <visof>  > reverse $ map (+2) [1..10]
02:28:49 <lambdabot>  thread killed
02:29:15 <visof> > map (+1) [1..10]
02:29:22 <visof>  > map (+1) [1..10]
02:29:25 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
02:29:55 <visof>  > take 3 $ map (+1) [1..10]
02:31:10 <visof> is "(reverse.map) (+1) [1..10] = reverse $ map (+1) [1..10] ?
02:31:18 <BONUS> yeah
02:31:28 <visof> $ = . ?
02:31:29 <BONUS> i prefer to write it as reverse . map (+1) $ [1..10]
02:31:50 <BONUS> wait no its not
02:31:57 <visof> @src $
02:31:57 <lambdabot> f $ x = f x
02:32:02 <BONUS> (reverse . map (+1)) [1..10] = reverse $ map (+1) [1..10]
02:32:51 <BONUS> $ is function application, . is function composition
02:33:04 <BONUS> you can imagine $ as extending parantheses all the way to the left and the right
02:33:37 <visof> take 3 $ [1..10]
02:33:41 <visof>  > take 3 $ [1..10]
02:33:49 <visof>  >take 3 $ [1..10]
02:34:03 <visof> what is the wrong?
02:34:45 <BONUS> i guess lambdabot is slow today
02:34:52 <BONUS> take 3 $ [1..10] works correctly
02:35:01 <visof> so i understood
02:35:09 <visof> thanks BONUS
02:35:13 <BONUS> hehe np
02:35:35 <BONUS> when you do, say: reverse . map (+1) . filter (> 5)
02:35:44 <BONUS> it will make a function that takes what filter (> 5) takes
02:35:56 <oklopol> > reverse $ map (+2) [1..10]
02:35:57 <BONUS> and then it will give what that produces to map (+1)
02:35:58 <lambdabot>  [12,11,10,9,8,7,6,5,4,3]
02:36:01 <oklopol> oh.
02:36:05 <BONUS> and then it will give what that produces to reverse
02:36:12 <oklopol> what was the "thread killed" about
02:36:12 <BONUS> and return the type that reverse returns
02:36:18 <BONUS> yeah
02:44:28 <Leaves> I'm solving ProjectEuler problems, and I wrote a solution to problem 14: http://hpaste.org/8958 (4 lines of code),  but it is extremely slow, do you know what step is the bottleneck?
02:45:30 <osfameron> yeah, I found 14 hard
02:45:38 <osfameron> at least, I think I must have done, as I've skipped it
02:45:40 <BONUS> yeah with 14 you have to do memoization
02:45:54 <osfameron> memoization is hard in haskell :-(
02:46:10 <osfameron> that said, iirc I attempted the question in Perl which I also failed at
02:46:10 <BONUS> because what you're doing is that if you get to calculate say
02:46:11 <BONUS> 40
02:46:27 <BONUS> in your code, you're calculating it all from the beginning
02:46:36 <BONUS> even though you already calculated the 40 chain when you were doing 13
02:48:11 <Leaves> aah, ok, so I have to store the length of a chain for all numbers I have had, ok, I though I did something very inefficient wrong but the solution just isn't smart enough
02:48:17 <BONUS> yeah
02:48:25 <BONUS> you culd try having a list
02:48:43 <BONUS> and then storing the length of, say, 13 at the 13th place in the list
02:49:11 <BONUS> so then when you're doing the chain at each step you first check if you already have it in the list
02:49:19 <Leaves> ok, I'm going to try that, thanks for your help
02:49:20 <BONUS> and if you do just return 1 + that length
02:49:21 <BONUS> hehe np
02:50:23 <osfameron> what is the best way to do that in haskell?  progressively "update" an array?
02:50:44 <pep> Hi !
02:51:02 <Leaves> I think I'm going to create an Array with length 999999 and then start filling it
02:52:05 <ejt> morning
02:52:19 <pep> I have a question about the ghci :info command.
02:52:21 <BONUS> Leaves yeah thats how i did it
02:52:52 <osfameron> insisting on no mutability makes things like memoization seem very hard to implement
02:52:55 <BONUS> osfameron: this is usually done by recursively filling the array
02:53:14 <BONUS> this is what i did for the array (spoiler):lengths = listArray(1,999999) (map (\x -> if cNext x < x then (lengths ! (cNext x))+1 else cLength x) [1..999999])
02:53:41 <osfameron> you can't just write "memoize :: (a->b) -> (a->b)    as the second version would have to be called in a stateful context
02:54:12 <quicksilver> doesn't make it hard to implement
02:54:17 <quicksilver> just means that isn't the type.
02:54:27 <pep> Where does the ghci :info command looks for the functions and types and type constructors it gives info about ?
02:54:38 <quicksilver> memoize :: (a->b) -> (a -> m b)
02:54:43 <osfameron> quicksilver: yeah, I was just thinking something along those lines...
02:54:47 <osfameron> but I wouldn't know how to do it...
02:54:48 <quicksilver> where m is, perhaps State (Map a b)
02:55:11 <quicksilver> pep: it digs it out of the object code of the libraries, basically
02:55:11 <_zenon_> > take 3 $ [1..10]
02:55:27 <lambdabot>  thread killed
02:55:28 <BONUS> lambdabot is borked atm imho
02:56:03 <quicksilver> > take 3 $ [1..10]
02:56:05 <lambdabot>  [1,2,3]
02:56:08 <quicksilver> just resource issues.
02:58:05 <BONUS> i just recieved my copy of Programming in Haskell w00t
02:58:32 <visof> BONUS for free?
02:58:55 <osfameron> quicksilver: why not (a->b) -> (m a -> m b) ?  don't we need to take a map in input too?
02:58:55 <BONUS> haha no
02:58:57 <BONUS> i paid for it
02:58:59 <pep> While working on the happs-tutorial, the ghci :info command does not find infos about functions the tutorial says it should (http://rippledeals.com:5001/tutorial/main-function).
02:58:59 <BONUS> but still
02:59:55 <BONUS> flipping through it now, it's a bit too basic but it still makes for a nice read since its the writing style is perfect
02:59:57 <PeakerWork> osfameron: you only need (m a) instead of a if you want to be able to "rerun" the "m a" computation -- if you just need the value, and want to be able to be in a stateful context, only the result has to be inside the monad
03:01:29 <quicksilver> osfameron: that's not how monads work :)
03:01:40 <quicksilver> osfameron: (m a) would be a computation returning an a
03:01:54 <quicksilver> you're not going ot be being given computations
03:01:55 <quicksilver> just 'a's
03:02:11 <quicksilver> pep: means they're not in scope.
03:02:28 <osfameron> ok.  I don't yet get State or Reader, must get around to spending time understanding that...
03:02:46 <PeakerWork> @hoogle memoize
03:02:52 <lambdabot> No matches found
03:02:58 <_zenon_> osfameron, Have you read "all about monads" ?
03:03:03 <BONUS> osfameron i wrote a little tutorial on the State monad just a few days ago :]
03:03:05 <PeakerWork> osfameron: Carefully reading how the State monad works finally got me to understand monads :)
03:03:23 <_zenon_> osfameron, imo it's one of the best monad introductory texts, together with wadlers paper of course :>
03:03:30 <quicksilver> moggi ftw!
03:03:33 <osfameron> yeah, I've been working through all about monads... just takes a looon gtime for it to sink into my head
03:03:46 <pep> quicksilver: that's what I thought. How can I put them in scope?
03:04:06 <BONUS> state monad tutorial i wrote: http://forums.somethingawful.com/showthread.php?threadid=2841145&pagenumber=6#post346173552
03:04:08 <lambdabot> Title: Want to Learn Haskell? - The Something Awful Forums, http://tinyurl.com/5ns5lx
03:04:14 <BONUS> i think it explains it nicely
03:04:40 <_zenon_> I think that was one of the biggest problems for me when learning monads, too few examples on using State
03:04:50 <BONUS> yeah
03:05:07 <quicksilver> pep: :m Module.Name
03:05:23 <BONUS> also while System.Random might be a good match because it has stateful computations, the StdGen business confuses a lot of people
03:05:31 <_zenon_> There are some examples around, but they only cover random number generation or push the envelope into complex parsing
03:05:53 <BONUS> yeah thats why in my tutorial i used the state monad to represent a stack
03:06:00 <BONUS> cause everyone knows what a stack is pretty much
03:06:42 <osfameron> BONUS: ta
03:06:45 <_zenon_> BONUS, nice,
03:07:43 <_zenon_> BONUS, I wrote a small robot with State, it made the last neurons fire to the end :)
03:07:51 <BONUS> haha
03:07:51 <BONUS> cool
03:08:07 <_zenon_> simple enough: a grid, a robot, it moves around, taking command-lists,
03:08:21 <quicksilver> BONUS: hmm are you jfre? or is that someone else?
03:08:23 <_zenon_> it's more examples like that which are needed i think
03:08:28 <BONUS> quicksilver no thats someone else
03:08:30 <BONUS> im Bonus
03:08:31 <BONUS> :]
03:08:40 <quicksilver> ah no, you're bonus.
03:08:41 <quicksilver> ;)
03:08:49 <visof> what is the meaning of "state" ?
03:08:55 <quicksilver> I don't agree with the way jfre draws a hard line between IO/State and Maybe/List
03:09:03 <ejt> dons has a nice example of using state in his irc bot
03:09:10 <quicksilver> he suggests you 'can't get the value out of a State' but you can out of a Maybe
03:09:13 <quicksilver> that's not really true.
03:09:17 <quicksilver> where is the value in 'Nothing' ?
03:09:18 <BONUS> quicksilver yeah
03:09:54 <_zenon_> Maybe that's what's lacking
03:10:14 <_zenon_> One place to rule them all, one place for a lot of monad examples
03:10:22 <_zenon_> Or maybe that already exists
03:10:56 <_zenon_> It would be a great place for people to post their own examples
03:11:28 <BONUS> yeah every explanation and tutorial (for haskell in general, not just monads) resonates with a specific reader a bit differently
03:11:50 <BONUS> so when i was learning the basics of haskell and such it helped me to read up on a few different tutorials and just get the info via osmosis
03:12:11 <slarba> http://hpaste.org/8959
03:12:19 <quicksilver> BONUS: you don't need the return () after put (a:s)
03:12:25 <quicksilver> BONUS: cos put always returns ().
03:12:32 <BONUS> quicksilver yeah i know
03:12:38 <BONUS> i was wondering whether to put that there or not
03:12:47 <BONUS> i thought it might be beneficial to people learning
03:12:54 <quicksilver> yes, perhaps you're right.
03:12:56 <_zenon_> class MonadState m s | m -> s where
03:12:56 <_zenon_>     get :: m s
03:12:56 <_zenon_>     put :: s -> m ()
03:12:56 <_zenon_> instance MonadState (State s) s where
03:12:56 <_zenon_>     get   = State $ \s -> (s,s)
03:12:58 <_zenon_>     put s = State $ \_ -> ((),s)
03:12:58 <BONUS> cause otherwise they might be like: where the heck is the result?
03:13:13 <BONUS> i'll add an explanation that return () is redundant and there for illustratory purposes
03:13:13 <quicksilver> s <- get; put (a:s); is more idiomatically writted as modify (a:)
03:13:18 <quicksilver> but you probably know that :)
03:13:29 <BONUS> hehe yeah :)
03:13:38 <quicksilver> (x : xs) <- return s is weird.
03:13:45 <quicksilver> why not use let (x : xs) = s ?
03:14:08 <BONUS> i wanted to demonstrate how return works for binding
03:14:21 <ski> hooking into `fail' of the MonadFail ?
03:14:32 <BONUS> even though it's the classic monad return x >>= f thing
03:14:56 <quicksilver> ski: not in this case, I don't think
03:15:23 <_zenon_> BONUS, hahaha, great pictures :D
03:15:35 <BONUS> hehe
03:15:55 <_zenon_> hahaa, all colorful and happy :)
03:16:00 <ski> (oh .. BONUS wrote a tutorial, which is being discussed)
03:16:31 <_zenon_> http://www.monadtutorials.com/
03:16:39 <_zenon_> could be a nice candidate address
03:16:53 * ski 'd add a hyphen
03:16:57 <BONUS> hehe
03:17:58 <_zenon_> Or one could put it into wikibooks ?
03:18:29 * _zenon_ must eat
03:18:35 <BONUS> or maybe someone could make a monads del.icio.us account
03:18:43 <BONUS> and then just link to all stuff monadic
03:18:54 <PeakerWork> Would it be accurate to describe: "Monads facilitate the describing of a computation as a chain of computations that each get the previous computation's result"?
03:19:29 <BONUS> hmm
03:19:35 <pep> How can I load every HApps.* modules inside ghci with the :module command, so as to be able to use the :info command for every functions, types, type contructors inside those modules?
03:19:51 <ski> BONUS : here you go <http://www.newadvent.org/cathen/10447b.htm>
03:20:07 <BONUS> lol :D
03:20:25 <BONUS> i suck at describing haskell stuff with precisely the right terminology :\
03:22:01 <Armored_Azrael> Hey, if anyone has time, want to give me some comments on things that should be put in a monad like this?
03:22:01 <Armored_Azrael> http://plhs.matthewmaurer.org/darcsweb/darcsweb.cgi?r=haskellutils;a=headblob;f=/src/Control/Monad/Rand.hs
03:22:08 <lambdabot> Title: darcs - haskellutils, http://tinyurl.com/5d28ly
03:22:42 <pyNem> what would be the quickest way to parse a line containing two numbers in haskell, after a line has been read by getLine?
03:22:48 <pyNem> i am a newbie ..
03:23:05 <ejt> pyNem: use 'words' to split it
03:23:08 <quicksilver> map read . words
03:23:12 <ejt> then 'read'
03:23:13 <quicksilver> would give you a list of numbers
03:23:23 <pyNem> oh :) thanks quicksilver ejt  :)
03:23:24 <quicksilver> > map read . words $ "1 2" :: [Int]
03:23:35 * quicksilver slaps lambdabot 
03:23:39 <lambdabot>  thread killed
03:23:46 <quicksilver> > map read . words $ "1 2" :: [Int]
03:23:47 <lambdabot>  [1,2]
03:24:17 <ski> using violence often helps
03:24:44 <quicksilver> seems to.
03:25:38 * ski wants to use `mapM' or a `chain' operator somewhere there ..
03:27:18 <PeakerWork> @type chain
03:27:25 <lambdabot> Not in scope: `chain'
03:27:31 <PeakerWork> @hoogle chain
03:27:33 <lambdabot> Text.ParserCombinators.ReadP.chainr :: ReadP a -> ReadP (a -> a -> a) -> a -> ReadP a
03:27:33 <lambdabot> Text.ParserCombinators.ReadP.chainl :: ReadP a -> ReadP (a -> a -> a) -> a -> ReadP a
03:27:33 <lambdabot> Text.ParserCombinators.ReadP.chainl1 :: ReadP a -> ReadP (a -> a -> a) -> ReadP a
03:28:29 * ski idly wonders why mofmog differentiates between primitive and non-primitive words
03:37:11 <taruti> Is there a version of Data.Binary.Get that counts the number of consumed bytes?
03:38:48 <pyNem> er.. basically i am struggling with a simple program where the user inputs a and b in a single line and i have to output a^b .. can anyone show me how?
03:39:20 <ejt> pyNem: have you written a program that reads a line, then prints it ?
03:39:41 <pyNem> ejt, yeah
03:39:51 <PeakerWork> pyNem: how are the two numbers put in that single line?  space-separated?
03:40:00 <pyNem> PeakerWork, yeah .. space seperated
03:40:09 <ejt> ok, now you need to convert the line to numbers
03:40:23 <ejt> eg, let xs = map read . words $ line
03:40:24 <pyNem> ejt, then i used map read.words to get a list of numbers of length 2
03:40:29 <pyNem> ejt, yeah
03:40:42 <ejt> then you can pattern match to check it's the right length
03:40:43 <ejt> eg
03:40:46 <taruti> print =<< fmap ((\[a,b] -> a^b) . map read . words) getLine
03:41:08 <ejt> taruti: well done
03:41:15 <mauke> needs more liftM2 (^) head (head . tail)
03:41:47 <pyNem> taruti, oh ..  i guess i have to read up more then ... i dont know what =<< is or fmap is
03:42:07 <mauke> main = do { line <- getLine; let {chunks = words line; [x, y] = map read chunks}; print (x ^ y) }
03:42:07 <taruti> well you can use do notation and not need them
03:43:03 <pyNem> taruti, oh .. i dint know that you could have [x, y] on the right hand side, like python .. thanks a lot :) .. should be easy from here on
03:44:02 <pyNem> i was trying to do something like map (^) (head chunk2) (tail chunk2) where chunk2 was map read chunks
03:44:16 <pep> I load a program in ghci (ghci Main.hs). Then I read : 'Ok, modules loaded: Main, Model, Controller, ...'. But if I want some info (ghci :info command) about functions or types defined inside for example the Controller module, it doesn't work. Do you know why?
03:44:43 <mauke> pyNem: that's almost right
03:44:59 <mauke> pyNem: first, no need for map. you're doing something with two numbers, not a list
03:45:21 <pyNem> mauke, bit i dint know how to get it out of the list .. :) .. now i do
03:45:22 <ski> @let heail = head . tail
03:45:31 <mauke> pyNem: second, tail gives you a list of numbers starting from offset 1, not one element
03:45:38 <lambdabot> thread killed
03:45:48 <mauke> pyNem: so ... (^) (head chunk2) (head (tail chunk2)) should work
03:46:29 <mauke> > let xy = [2, 3] in (^) (head xs) (head (tail xy))
03:46:32 <lambdabot>   Not in scope: `xs'
03:46:37 <mauke> > let xy = [2, 3] in (^) (head xy) (head (tail xy))
03:46:43 <lambdabot>  8
03:47:04 <mauke> > let xy = [2, 3] in head xy ^ head (tail xy)
03:47:05 <lambdabot>  8
03:47:06 <pyNem> mauke, yeah .. but it thought i wrote ..  map (^) (head chunk2) (tail chunk2)  with a map before that
03:47:25 <mauke> what?
03:48:18 <pyNem> mauke ... er .. in the chunk2 [2, 3]  (tail chunk2) would return a singleton list .. i was trying to exploit that using the initial element (head chunk2) and a map ..
03:48:30 <pyNem> mauke, whatever.. mine was very very complex :D
03:48:41 <pyNem> mauke, taruti thanks again :)
03:48:53 <mauke> oh, hmm
03:49:08 <mauke> map ((^) (head chunk2) (tail chunk2) then
03:49:15 <pyNem> mauke, yeah :)
03:49:17 <mauke> otherwise you're calling map with three arguments
03:49:38 <pyNem> mauke, yeah go that
03:49:39 <mauke> > let xy = [2, 3] in map ((^) (head xy) (tail xy)
03:49:39 <lambdabot> Unbalanced parentheses
03:49:45 <mauke> > let xy = [2, 3] in map ((^) (head xy)) (tail xy)
03:49:46 <lambdabot>  [8]
03:52:14 <quicksilver> taruti: Yes.
03:52:20 <quicksilver> taruti: it's called Data.Binary.Get
03:52:24 <pep> Bye.
03:52:55 <ski> au revouir
04:01:11 <taruti> quicksilver: so how does one count the number of consumed input bytes with that? using 'remaining' does not work if the stream is infinite.
04:01:47 <quicksilver> taruti: bytesRead ?
04:02:30 * _zenon_ just found this, http://www.haskell.org/haskellwiki/Simple_monad_examples
04:02:31 <lambdabot> Title: Simple monad examples - HaskellWiki
04:02:45 <_zenon_> We could expand it with our own examples :)
04:04:20 <taruti> quicksilver: hmm. I was reading an older version of the API that lacked it. Thanks for the pointer :)
04:04:51 <quicksilver> taruti: ah ;)
04:06:00 <levi13> Hi, is c2hs currently the 'best practice' for c/haskell interfaces?
04:20:02 <dcoutts> levi13: yeah, or for simpler tasks you can use hsc2hs
04:26:49 <levi13> ok, thanks. I'm just trying to get it working from a cabal build now
04:27:06 <levi13> I have it listed under build-tools
04:27:32 <levi13> and the file I want it to process as a .hsc extension,
04:27:40 <levi13> but when it tries building it says it can't find that module
04:33:12 <levi13> fixed. Typo in other-modules :(
04:46:43 <vixey> @seen shapr
04:46:44 <lambdabot> I haven't seen shapr.
04:46:59 <roconnor> @get-shapr
04:47:00 <lambdabot> shapr!!
04:47:25 <vixey> my language can run fibs
04:47:30 <mauke> preflex: seen shapr
04:47:30 <preflex>  shapr was last seen on #haskell 4 days, 10 hours, 5 minutes and 45 seconds ago, saying: * shapr boings furiously
04:47:32 <roconnor> horray
04:48:02 <roconnor> I should write my ICFP blog post
04:48:13 <roconnor> but I just want to close my eyes
04:48:24 * roconnor ZZzzZZzz
04:48:29 <vincenz> roconnor: hey
04:48:35 <roconnor> vincenz: hey
04:48:42 <vincenz> roconnor: how's icfp?
04:48:49 <roconnor> I started Sunday night
04:48:57 <roconnor> it's possible to write an entry in a few hours
04:49:01 <vincenz> Oh, the contest?
04:49:06 <roconnor> right
04:49:32 <vincenz> Cool
04:51:19 <dcoutts> @seen conal
04:51:19 <lambdabot> conal is in #haskell and #ghc. I don't know when conal last spoke.
04:53:30 <dcoutts> @seen dibblego
04:53:31 <lambdabot> dibblego is in #jtiger, #scala and #haskell. I last heard dibblego speak 2h 24m 7s ago.
04:57:41 <roconnor> ahhh http://www.chat.carleton.ca/~tcstewar/illusions/Colorcross1.jpg
04:57:44 <dcoutts> @seen dobblego
04:57:45 <lambdabot> dobblego is in #scala, #haskell and #jtiger. I last heard dobblego speak 5h 13m 46s ago.
04:57:53 <roconnor> the centre of each cross is the same colour
04:59:39 <rhz> is there a way to enter a function having several equations into ghci?
05:00:15 <roconnor> > let {f 0 = true; f 1 = false} ?
05:00:17 <lambdabot>  Parse error at "?" (column 31)
05:00:51 <vixey> who needs mutual recursion?
05:01:10 <roconnor> need is a bit strong
05:01:12 <vixey> you can just use use sum types and continuation passing
05:01:13 <roconnor> it is convienent
05:02:04 <vixey> oh
05:02:41 <vixey> comment = \ you dont need built in support for comments either, comment
05:02:55 <vixey> oops s/'/->/
05:03:00 <mjrosenb> ermm, it seems like i have some code that shouldn't typecheck, but it does....
05:04:08 <roconnor> vixey: Error, 'in' is a reserved word
05:04:15 <vixey> :(
05:04:36 <vixey> built in language constructs ..
05:05:21 <roconnor> ?
05:05:33 <rhz> comment = "you dont need built in support for comments either"
05:05:39 <mjrosenb> \YouDontNeedBuiltInSupportForCommentsEither -> ()
05:06:05 <roconnor> Error, unknown constructor 'YouDontNeedBuiltInSupportForCommentsEither'
05:06:16 * mjrosenb grumbles
05:06:31 <mauke> _ = "what"
05:08:06 <vixey> multiply m n = unchurch (λf, (church n) (church m f)).
05:08:09 <vixey> fast multiplication
05:08:52 <mjrosenb> for which definition of 'fast'?
05:08:58 <vixey> the wrong one
05:09:06 <mjrosenb> gah....
05:09:26 <mjrosenb> typeclasses make writing type-correct code more annoying
05:09:35 <mjrosenb> part2Length :: (Num (MP3SideData -> t), Num t) => MP3SideData -> MP3SideData -> t
05:10:30 <mjrosenb> part2Length :: (Num (MP3SideData -> t), Num t) => MP3SideData -> MP3SideData -> t
05:10:40 <PeakerWork> mjrosenb: ?
05:10:45 <mjrosenb> gah, up+enter in wrong terminal
05:11:02 <vixey> @src enumFromTo
05:11:02 <lambdabot> Source not found. Wrong!  You cheating scum!
05:11:29 <mjrosenb> vixey: isn't that defined on a per-instance basis?
05:11:40 <vixey> I hope not
05:12:25 <mjrosenb> indeed, my bad
05:13:21 <quicksilver> yes, enumFromTo is a method.
05:13:44 <mauke> @src Enum
05:13:44 <lambdabot> class  Enum a   where
05:13:44 <lambdabot>     succ                     :: a -> a
05:13:44 <lambdabot>     pred                     :: a -> a
05:13:44 <lambdabot>     toEnum                   :: Int -> a
05:13:44 <lambdabot>     fromEnum                 :: a -> Int
05:13:46 <lambdabot> [3 @more lines]
05:14:13 <jkff> Hi people, I've written yet another monad tutorial :) http://spbhug.folding-maps.org/wiki/MonadsEn Its russian version received good response and I decided to translate it. Hope that it will be interesting and probably useful for someone over here, too.
05:14:14 <quicksilver> it has a default implementation which essentially defers to the Int implementation
05:14:15 <lambdabot> Title: MonadsEn - SPb Haskell User Group
05:14:19 <quicksilver> via to/from Enum
05:25:11 <vixey> > iterate const True
05:25:27 <lambdabot>  thread killed
05:25:57 <roconnor> > 5
05:26:03 <lambdabot>  5
05:26:18 <mauke> > iterate const
05:26:18 <lambdabot>      Occurs check: cannot construct the infinite type: a = b -> a
05:26:18 <lambdabot>     Probabl...
05:26:28 <hansfbaier> @seen las
05:26:28 <lambdabot> I haven't seen las.
05:26:47 <ski> > iterate (const True) False
05:26:48 <lambdabot>  [False,True,True,True,True,True,True,True,True,True,True,True,True,True,True...
05:27:03 <vixey> :(
05:27:08 <vixey> iterate const True typechecks in my thing
05:27:15 <roconnor> > iterate id True
05:27:15 <vixey> it is all falling apart
05:27:16 <lambdabot>  [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,...
05:27:26 <ski> vixey : cyclic types ?
05:27:32 <Syzygy|de> > iterate id False
05:27:34 <lambdabot>  [False,False,False,False,False,False,False,False,False,False,False,False,Fal...
05:27:45 <mauke> vixey: \x -> x x
05:27:48 <roconnor> > iterate (ap const const) True
05:27:49 <lambdabot>  [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,...
05:28:05 <kaol> > iterate not True
05:28:07 <lambdabot>  [True,False,True,False,True,False,True,False,True,False,True,False,True,Fals...
05:30:04 <rhz> > let p f n = if gcd f n == 1 then n : (p (f*n) (n+1)) else p f (n+1) in p 1 2
05:30:06 <ski> > iterate (ap const id) ()
05:30:06 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
05:30:07 <lambdabot>  [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),...
05:30:21 <vixey> there is another bug in the topological sort
05:31:52 <quicksilver> jkff: hi.
05:32:16 <vixey> that is ridiculous
05:32:22 <jkff> Hi quicksilver
05:32:24 <quicksilver> jkff: I am about a third of the way through your blog
05:32:24 <vixey> I found a bug in my code, so I went to use Data.Graph
05:32:28 <quicksilver> the beginning is very good :)
05:32:38 <jkff> Nice to hear :)
05:32:38 <quicksilver> but then it goes wrong when you describe IO
05:32:41 <vixey> and ... I actually should have reversed the result
05:32:48 <jkff> You mean the 'seq'?
05:32:54 <vixey> so fixing bugs is definitely a bad idea
05:33:06 <quicksilver> jkff: yeah.
05:33:25 <quicksilver> (IO a) >>= f = a `seq` (IO (f a))
05:33:30 <quicksilver> this is really not true :)
05:33:39 <ski> `IO' ?
05:33:46 <jkff> Yes, you are right. I am a bit confused at how one should actually explain IO
05:33:59 <quicksilver> ski: data IO a = IO a
05:34:22 * ski stares flatly
05:34:29 <jkff> 'seq' gets close but incorrect, 'State World a' gets correct but somewhat less intuitive
05:34:45 <quicksilver> ski: have a look at jkff's blog. It's good until this bit :)
05:34:50 <quicksilver> ski: http://spbhug.folding-maps.org/wiki/MonadsEn
05:34:51 <lambdabot> Title: MonadsEn - SPb Haskell User Group
05:35:07 <quicksilver> jkff: well you've actually tapped into a common misapprehension about IO.
05:35:44 <jkff> I looked into the sources and I know that it is actually not seq, but I don't know how to explain it really well
05:36:37 <quicksilver> there is a common misconception that IO somehow introduces strictness
05:36:41 <roconnor> return undefined >> print "ignore that last command"
05:36:50 <roconnor> er
05:36:50 <quicksilver> (or, indeed, that monads in general introduce strictness)
05:36:52 <roconnor> putStrLn
05:36:56 <quicksilver> actually they don't.
05:37:01 * ski suppose he has no right to be considered an FP newbie ..
05:37:08 <quicksilver> monads are in some sense 'strict in their effects'
05:37:14 <quicksilver> although that's a bit vague
05:37:15 <jkff> Presenting IO as a giant State does not explain why IO actions are performed sequentially
05:37:24 <jkff> Well, it does explain, but not intuitively
05:39:08 <jkff> I'll try to fix that by saying that the part about 'seq' is close to true only with respect to effects, whereas 'normal' computations are lazy as usually, and by saying that IO is actually a world-scale State.
05:41:59 <ski> `t[0]' vs. `world(t=0)' vs. `world(0)' ?
05:42:59 <jkff> Hm?
05:43:16 <ski> just slighly confused by the changing notations
05:43:44 <quicksilver> jkff: data IO a = IO a isn't a very helpful picture, either.
05:43:55 <quicksilver> it suggests that IO actions really 'store their value'
05:44:08 <ski> getChar :: IO Char
05:44:18 <quicksilver> in fact IO actions don't have any value hidden inside them in general; they only acquire one once run.
05:44:22 * vixey applies for a community.haskell account
05:44:30 <vixey> 500 Internal Server Error
05:44:31 * vixey gets
05:44:31 <vixey> Newline in ssh key
05:44:31 <quicksilver> they can of course be run more than once in which case they acquire different values on the different instances
05:44:35 <quicksilver> in general.
05:44:38 <jkff> Well, IO a is really 'IO (Lazy a)' since everything is lazy
05:44:51 <jkff> Oh, you're right again
05:44:51 <quicksilver> no, that's not the point I'm making.
05:45:03 <quicksilver> as you say, everything is lazy :)
05:45:12 <roconnor> data IO a = IO (a -> IOTree) -> IOTree
05:45:18 <levi13> I've always found thinking of 'IO a' as return a function
05:45:20 <roconnor> newtype IO a = IO (a -> IOTree) -> IOTree
05:45:31 <quicksilver> one model people also discuss is:
05:45:34 <jkff> Probably they are 'lazy without memoization'
05:45:39 <jkff> What is an IOTree?
05:45:54 <quicksilver> data IO = GetChar | PutStr | PutStrLn | ....
05:46:03 <Gwern-away> the result of an IOSeed?
05:46:09 <quicksilver> (note that this is an ADT really but perhaps that isn't important for explaining)
05:46:19 <levi13> something like putStrLn, returns a function, that when run, will output a string. Is that accurate?
05:46:28 <quicksilver> levi13: except for use of the word 'function'
05:46:31 <vixey> levi13: no
05:46:38 <vixey> :t putStrLn
05:46:39 <quicksilver> putStrLn returns an 'action' which when run will output a string.
05:46:40 <jkff> Heh. Looks like one article on programming a continuation-based web server in Haskell
05:46:54 <quicksilver> levi13: but yes, you are basically right.
05:46:54 <lambdabot> thread killed
05:47:01 <quicksilver> modulo pedantry about what  'function' means.
05:47:09 <ski> roconnor> @src IO return
05:47:19 <levi13> k, cool. Yes, I'm using function in a non-strict sense, just to help me understand :)
05:47:28 <ddarius> A continuation based approach seems the most intuitive, most understandable and most reasonable based implementation.
05:47:44 <quicksilver> putStrLn returns a chunk of code which when run will output a string
05:47:47 <quicksilver> is another model.
05:47:50 <roconnor> data IOTree = PutChar Char | GetChar (Char -> IOTree) | IOTree `Then` IOTree | ...
05:48:06 <vixey> I like the GADT way
05:48:07 <roconnor> ski: return x = \f -> f x
05:48:14 <vixey> it is pure
05:48:34 <ski> roconnor : oh right ..
05:48:43 <roconnor> ski: return x = IO \f -> f x
05:48:59 <roconnor> http://luqui.org/blog/category/code/haskell/
05:49:00 * ski wasn't thinking
05:49:01 <lambdabot> Title: Haskell @ The dreams that stuff is made of
05:49:21 <roconnor> Actually I think his IOTree is not quite optimal, but I haven't figured out the proper datatype yet
05:49:28 <Gwern-away> hm. these two CSV posts are mildly embarassing
05:49:48 <roconnor> roconnor: it should be some sort of Coinductive-inductive type.
05:49:57 * roconnor is talking to himself again
05:49:59 <frevidar> is there a way to indicate that a function argument is strict?
05:50:12 <matthew-_> prefix it with !
05:50:23 <roconnor> f x | x `seq` False = undefined
05:50:23 <roconnor> ...
05:50:26 <frevidar> in the function definition?
05:50:39 <matthew-_> oh, I'm thinking of strict fields, sory
05:51:01 <jkff> You have certainly changed my understanding of how IO works. Now I'll have to translate it into a form understandable to one who doesn't understand monads at all :-|
05:52:04 * ski 'd name `IOTree' `Answer' or `Omega' or something ..
05:52:11 <vixey> why can't I find any SSH keys online
05:52:24 <jkff> Maybe is an explanation that 'IO is a monad where *effects* are sequenced, and you don't yet want to know how exactly that works' sufficient? :)
05:52:31 <ddarius> vixey: Why are you looking for SSH keys online?
05:52:46 <vixey> ddarius: I want to see what one looks like to compare with my one
05:53:00 <vixey> I think this ssh-keygen program has done the wrong thing
05:53:49 <vixey> or could be my terminal
05:54:24 <roconnor> ... IO a is a function that takes a function taking a to a bunch of effects, and returns a bunch of effects.
05:54:31 <quicksilver> no, you were right matthew-_
05:54:38 <vixey> it still says Newline in ssh key
05:54:42 * roconnor is dizzy
05:54:44 <quicksilver> frevidar: you can prefix function args with !
05:54:46 <ddarius> quicksilver: With an extension...
05:54:50 <quicksilver> if you have the appropriate extension on
05:54:53 <quicksilver> BangPatterns
05:55:17 <quicksilver> jkff: in all monads effects are sequenced.
05:55:22 <roconnor> ddarius: actually, that does sort of claify things.
05:55:26 <quicksilver> jkff: from one perspective, that's exactly what monads are.
05:55:37 <frevidar> quicksilver: ah, thanks. Much nicer than a long `seq` line.
05:55:41 <int-e> vixey: did you use the public key? those are a single line
05:55:48 <roconnor> ddarius: in a confusing sort of way
05:56:05 <vixey> yeah it is a just one line but this form is still complaining about it
05:56:12 <ddarius> I clarified something?
05:56:54 <roconnor> <ddarius> A continuation based approach seems the most intuitive, most understandable and most reasonable based implementation.
05:57:36 <jkff> Well.. I don't like that perspective but from some point of view, it's true. Explaining IO looks a lot harder than it seemed. Are you sure that the CPS approach is really understandable for someone who fears the word 'monad'? I feared the word 'continuation' for much longer than 'monad'.
05:57:57 <ddarius> jkff: It comes up very naturally.
05:58:03 <roconnor> jkff: I don't think it is understandable, but it might be the most understandable.
05:58:18 <ski> roconnor : foo :: IO Bool; foo = IO $ \k -> k False `zipIOTree` k True
05:59:05 <roconnor> ski: Error, IO not exported from module System.Roconnor.IO
05:59:11 <vixey> this is irritating
05:59:16 <ddarius> http://luqui.org/blog/archives/2008/03/29/io-monad-the-continuation-presentation/ is a reasonable description of how one person ended up arriving at such an approach accidentally.
05:59:18 <lambdabot> Title: IO Monad: The Continuation Presentation @ The dreams that stuff is made of, http://tinyurl.com/5dbq4p
05:59:20 <ski> jkff : i think the "state-transformer" view is simpler to grasp
05:59:25 * vixey gives up
05:59:37 <ski> roconnor : that'd be a primitive, of course ;)
06:00:02 <jkff> Yes, I've already linked to that post in the version of tutorial that I'm going to submit after I fix the IO section :)
06:01:08 <roconnor> the state-transformer is simpler to grasp, but I vaguely recall it has issue when you really try to formalize it.
06:01:45 <roconnor> in the end I decided it was, in some sense, misleading
06:01:52 <roconnor> but I forget how I came to that conclusion
06:02:02 <ski> (:
06:02:51 <jkff> Probably it is the monad of 'transforming internal runtime state like registers and ports in a way that leads to side effects' :)
06:03:10 <ski> (maybe to possibility of duplicating state ? or maybe related to strictness of states ?)
06:03:25 <roconnor> ski_: I think it was more likely related to strictness issues
06:03:36 <jkff> But from a distant point of view, IO is just a monad where observable side-effects are sequenced
06:03:38 <ddarius> jkff: That would be a reasonable view of the state transformer approach, but that is not how it is usually presented.
06:04:17 <roconnor> The problems with dupicating state are presumably similar to calling a continuation twice
06:06:48 <ddarius> jkff: You might be interested in reading the paper: On the Expressiveness of Purely Functional I/O Systems.
06:06:52 <roconnor> I think one can get rid of the Then constructor for IOTree by having PutChar Char IOTree instead.
06:07:12 <roconnor> and NoOp should be renamed to Done
06:07:57 <jkff> ddarius: Thanks, I'll have a look at it.
06:09:11 <ski> stop :: IO Void
06:09:12 <ski> stop = IO $ \k -> Done
06:09:48 * ski had something similar in a monad of his
06:09:52 <roconnor> stop :: IO a
06:10:08 <roconnor> or stop' = fmap void stop
06:10:12 <roconnor> stop' :: IO a
06:10:13 <roconnor> same thing
06:10:43 <roconnor> in some sense IO should never stop
06:10:58 <roconnor> in some sense IO should be renamed to OS in Haskell 98
06:11:06 <roconnor> because IO is really mediated by the OS
06:11:48 <chr1s> @seen dons
06:11:49 <lambdabot> dons is in #arch-haskell, #xmonad, #ghc and #haskell. I last heard dons speak 14h 20m 57s ago.
06:12:40 <jkff> Is it, even in the case of IORef's?
06:12:54 <ski> -- Kill the current thread, swapping in another thread, if any, otherwise finish the simulation
06:12:57 <ski> kill :: SystemM Void
06:13:07 <roconnor> the OS manages the virtual memory of processes
06:13:44 <jkff> Probably a somewhat more clear name for IO would be 'Irreversible'.
06:13:45 <roconnor> I mean, the whole notion of a process is an OS concept
06:14:13 <jkff> The notion of irreversible effects is not an OS concept
06:14:48 <roconnor> Haskell's IO monad makes certain assumptions about the interface to the OS
06:15:00 <roconnor> these assumptions are common, but hardly universal
06:17:10 <saml> how do you i18n ?
06:17:38 <saml> general process of it. it seems that i need to extract translatable strings + translate + compile + profit??
06:17:55 <SamB_XP> how about SinBin?
06:18:45 <saml> @hoogle i18n
06:18:51 <lambdabot> No matches found
06:19:45 <SamB_XP> @hoogle gettext
06:19:45 <lambdabot> No matches found
06:20:02 <SamB_XP> @hoogle locale
06:20:03 <lambdabot> System.Locale :: module
06:20:03 <lambdabot> System.Locale.TimeLocale :: data TimeLocale
06:20:03 <lambdabot> System.Locale.TimeLocale :: [(String, String)] -> [(String, String)] -> [(String, String)] -> (String, String) -> String -> String -> String -> String -> TimeLocale
06:27:07 <jkff> I've modified the section about IO; could you have a look at whether now it lies less? :)
06:29:12 <Jedai> Hello, is there a GHC API expert on the channel (I would settle for a knowledgeable person too) :)
06:30:23 <_zenon_> Well, I guess PHP doesn't handle partial application
06:30:46 <saml> Jedai: i know someone who is expert. his name is hoogle
06:31:10 <saml> @hoogle "a -> a"
06:31:11 <lambdabot> Hoogle Error: Parse Error: Unexpected character '"a -> a"'
06:31:19 <saml> @hoogle a -> a
06:31:21 <lambdabot> Prelude.id :: a -> a
06:31:21 <lambdabot> Data.Function.id :: a -> a
06:31:21 <lambdabot> GHC.Exts.breakpoint :: a -> a
06:31:27 <Jedai> saml: Yeah well.... Hoogle isn't quite smart enough to answer my question just yet...
06:31:39 <vixey> Jedai: Have you tried asking the question?
06:31:40 <mauke> saml: does hoogle index the GHC API?
06:31:49 <pejo> Is the GHC meeting thing in 1.5 hours?
06:31:49 <yakov> hey
06:31:58 <saml> Jedai: mauke . oh sorry . misunderstood
06:33:30 <Jedai> vixey: That's a good question ! Ok, is there a way, in the GHC API to know what's the origin of a HsVar in a HsExpr or to know whether two HsVar have the same origin
06:34:17 <Jedai> In other words, is there a way to get scoping information on the AST (before transformation into Core or other)
06:34:33 <yakov> is Network library part of the standard?
06:34:57 <yakov> as well is Network.Socket
06:35:02 <Jedai> yakov: There is not really a standard library but Network is part of the extra-library shiped with GHC
06:36:40 <stulli> I have a small piece of code i do not understand. Is anybody in the mood for explaining it to me?
06:36:41 <thorkilnaur_> pejo, I understand the GHC meeting to take place at 15.00 UTC which is in about 1 hour and 20 minutes
06:36:47 <yakov> Jedai, is it more desirable then to use System IO which is standard in turn over sockets?
06:37:15 <yakov> via socketToHandle i suppose
06:37:20 <stulli> hpasted: http://hpaste.org/8960
06:38:06 <scook0> stulli: it's the magic of the list monad!
06:38:59 <scook0> your first comment is incorrect: b is not [6,10], but rather a "non-deterministic" choice of either 6 or 10
06:39:04 <Jedai> yakov: They don't really have the same usage... System.IO isn't standard anyway, IO is in Haskell98 but that's all. Don't worry too much. Except if you have specific requirement, target GHC, Network.Socket comes with its binary distribution and in the extra-library package, so you'll almost always have it available
06:39:16 <jkff> b <- f a is not an assignment. It is syntactic sugar for (f a >>= \b -> ...) and a notion for 'let b be computed with the help of f a'
06:39:30 <scook0> basically, the program will try all of the possible values for a, b and c, and return all the outcomes in a list
06:39:44 <stulli> scook0, hm, this sounds strange to me :) do you have a link for me to learn more about the list monad?
06:39:46 <jkff> (>>=) for the List monad uses its left argument in this way: it applies its right argument to each item of the left argument
06:39:48 <SamB_XP> the standard is deprecated as far as libraries go ;-P
06:40:01 <jkff> What about http://spbhug.folding-maps.org/wiki/MonadsEn ? :)
06:40:05 <lambdabot> Title: MonadsEn - SPb Haskell User Group
06:40:05 <scook0> stulli: how familiar are you with (non-IO) monads in general?
06:40:34 <stulli> scook0, im a bloody beginner :) i know monads as space stations :)
06:40:56 <scook0> heh
06:41:22 <SamB_XP> stulli: you need to write your monad tutorial and then you can become a newbie ;-P
06:41:27 <stulli> scook0, so if im using a list in an arbitrary monad, its no longer a list but a list monad?
06:41:46 <scook0> well basically, <- inside do-notation is syntactic sugar for (>>=)
06:41:53 <SamB_XP> I seem to have skipped the newbie stage by writing a compiler or similar before ever completing a monad tutorial
06:41:55 <jkff> Nope, in the code you showed, you are using List in the list monad
06:41:58 <lilachaze> stulli: one way of thinking about the list monad is 'non-determinism', but i think that's pheonmenally unhelpful. i think of it as SIMD (single-instruction, multiple-data), that is, applying the same transformation to each element of a list.
06:42:21 <jkff> It's just that you've used the result of your list-monadic computation in the IO monad, but that doesn't change the computation in any way
06:42:36 <jkff> You computed a value in the List monad and then used it in the IO monad.
06:42:42 <scook0> when you're using the IO monad, (>>=) has the rough meaning of "perform some IO action and pass on the result"
06:43:16 <scook0> when you're using the list monad, (>>=) has the rough meaning of "try all the different possibilities in the list, passing each of them on in turn"
06:43:27 <lilachaze> stulli: the monad definitions might help you. return x = [x]. xs >>= f = concat $ map f xs  (put another way, >>= = concatMap).
06:43:29 <ski> SamB_XP : <scoff> tutorial, what's that ? in my day, we learned monads by staring hard at the type-signature .. </scoff>
06:44:07 <SamB_XP> ski: in my day, we learned monads by trying to figure out what in the world they were, giving up, and then just using them ;-)
06:44:18 <ski> (:
06:44:19 <stulli> hm, thanks for all your help. lilachaze : i think that will help me once i understood it
06:44:42 <SamB_XP> lilachaze: actually (>>=) = flip concatMap
06:44:58 <stulli> i was just wondering if haskells type system was broken for me ;)
06:45:23 <scook0> @botsmack
06:45:24 <lambdabot> :)
06:45:31 <ski> > do x <- [1,2,3]; y <- [4,5]; return (100*x + y)
06:45:34 <lambdabot>  [104,105,204,205,304,305]
06:45:39 <scook0> > do { a <- [1..10]; b <- [1..10]; c <- [1..10]; if a+b+c == 10 then return (a, b, c) else [] }
06:45:41 <lambdabot>  [(1,1,8),(1,2,7),(1,3,6),(1,4,5),(1,5,4),(1,6,3),(1,7,2),(1,8,1),(2,1,7),(2,...
06:45:41 <SamB_XP> @smack scook0
06:45:41 * lambdabot secretly deletes scook0's source code
06:45:41 <jkff> You can try staring at the Cont monad and probably you will be broken by the haskell's type system :)
06:45:42 <lilachaze> SamB_XP: yeah, oops. obviously i meant (=<<) = concatMap :)
06:45:51 <ski> > [100*x + y | x <- [1,2,3], y <- [4,5]]
06:45:53 <lambdabot>  [104,105,204,205,304,305]
06:46:13 <jkff> > do [1,2,3]; y <- [5,6]; return y
06:46:15 <lambdabot>  [5,6,5,6,5,6]
06:46:43 <jkff> do [1,2,3]; [5,6]; return 42
06:46:45 <stulli> ski, the list monad works like list comprehension?
06:46:51 <ski> stulli : yes
06:46:52 <jkff> > do [1, 2, 3]; [5, 6]; return 42
06:46:53 <lambdabot>  [42,42,42,42,42,42]
06:47:05 <scook0> stulli: can you see some of the little problems we are solving here using the list monad?
06:47:06 <lilachaze> > do { a <- [1..10]; b <- [1..10]; c <- [1..1]; guard (a+b+c == 10); return (a,b,c) }
06:47:08 <lambdabot>  [(1,8,1),(2,7,1),(3,6,1),(4,5,1),(5,4,1),(6,3,1),(7,2,1),(8,1,1)]
06:47:47 <lilachaze> > [ (a,b,c) | a <- [1..10], b<-[1..10], c<-[1..1], a+b+c == 10 ]
06:47:49 <lambdabot>  [(1,8,1),(2,7,1),(3,6,1),(4,5,1),(5,4,1),(6,3,1),(7,2,1),(8,1,1)]
06:47:53 <jkff> > filterM [const True, const False] [1,2,3]
06:47:54 <lambdabot>  Couldn't match expected type `a -> m Bool'
06:47:57 <jkff> Whoops
06:48:20 <scook0> > filterM (const [False ..]) [1..3]
06:48:24 <lambdabot>  [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
06:48:28 <jkff> Yep
06:48:39 <stulli> scook0, it gets clearer after every example
06:48:56 <scook0> don't boil your brain on that filterM one though ;)
06:49:11 <_zenon_> ?ty filterM
06:49:13 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
06:50:02 <lilachaze> stulli: in your case, haskell figures out which monad you're using because you say, for instance, "c <- f b", where f b :: [Int], so the monad must be [] (and the type of c must be Int)
06:50:32 <scook0> @type sequence [const False, const True]
06:50:33 <lambdabot> forall b. b -> [Bool]
06:51:13 <lilachaze> stulli: in general, when you see x <- y within a do block, y must have the type "m a" (for some monad m and some type a), and x must have the type a (the same a as in y's type). every statement in the do block must be in the same monad (using the same value for m).
06:52:03 <stulli> lilachaze, ah, that makes sense
06:53:28 * scook0 wonders if "monads as a generalization of list comprehensions" has any pedagogical merit/precedent
06:53:39 <vixey> no
06:53:45 <ski> monads as containers
06:54:01 <SamB_XP> @go comprehending monads
06:54:04 <lambdabot> http://homepages.inf.ed.ac.uk/wadler/topics/monads.html
06:54:04 <lambdabot> Title: Wadler: Monads
06:54:13 <SamB_XP> scook0: how about that?
06:54:48 <scook0> I'll take that as a yes
06:55:09 <ski> <http://www.haskell.org/haskellwiki/Monads_as_containers>
06:55:24 <SamB_XP> scook0: you are supposed to try to read it ;-P
07:08:01 <quicksilver> yakov: Network.Socket is low level and hard to use
07:08:03 <quicksilver> Network is easier.
07:11:08 <yakov> quicksilver, well i dont understand this well enough "These should normally only be used where the socket will not be required for further calls"
07:11:34 <Baughn> yakov: "If you use these, you should immediately forget the socket ever existed"
07:11:48 <yakov> seems like there's no way to do sequence of reads
07:11:49 <Baughn> Etc.. analogous to the C fdopen function, for example
07:12:07 <quicksilver> yakov: just don't use them
07:12:22 <yakov> so.. where's the profit over Net.Socket?!
07:12:22 <quicksilver> yakov: you use connectTo
07:12:25 <quicksilver> then you have a Handle
07:12:29 <yakov> aha
07:12:32 <quicksilver> and you just use ordinary IO functions.
07:12:34 <quicksilver> it's easy.
07:12:37 <yakov> ok
07:12:42 <yakov> so there
07:13:05 <quicksilver> for server sockets you use listen and accept
07:13:07 <yakov> it's a thing i ve started from
07:13:09 <quicksilver> (much like in C)
07:13:12 <Baughn> And after you've got the handle, you should no longer touch the socket
07:13:19 <Baughn> (Doing so would mess up buffering, and more)
07:13:27 <quicksilver> Baughn: in connectTo there is no Socket.
07:13:36 <quicksilver> Baughn: in accept you do keep the socket for future accepts.
07:13:55 <chrisdone> what's the next haskelly thing to learn?
07:13:59 <yakov> this mean i will use normal IO over socket being transformed to Handle
07:14:04 <chrisdone> I've done arrows
07:14:21 <frevidar> hi, I'm trying to use the parsec library, but I'm getting a compile error with this line: number = do { ds <- float; return ds }
07:14:28 <Baughn> chrisdone: Control.Applicative is handy. So are rank-n types
07:14:28 <frevidar> is there anything wrong with that line?
07:14:33 <frevidar> it won't compile by itself
07:14:38 <frevidar> nothing is referencing it
07:14:53 <vixey> frevidar: You could just write number = flout
07:14:53 <yakov> chrisdone, what about to write real world app ;)
07:14:55 <vixey> frevidar: You could just write number = float
07:15:21 <Baughn> frevidar: I assume it's a type error?
07:15:21 <chrisdone> Baughn: aye, Control.Applicative!
07:15:30 <frevidar> this compiles fine: number  = do { ds <- many1 digit; return (read ds) }
07:15:45 <frevidar> baughn: yes
07:15:56 <frevidar> I'll paste it into the bin
07:16:10 <Baughn> frevidar: The compiler can't figure out its entire type, without either you /using/ it or having an explicit type signature
07:16:15 <ski> frevidar : DMR ?
07:16:21 <Baughn> frevidar: So do one of the two.
07:16:29 <Baughn> Well, or comment it out
07:17:24 <opqdonut> Baughn: not true generally, though
07:17:30 <quicksilver> yakov: yes, that's what you're doing behind the scenes. But you don't need to know about the Socket in the simple conntectTo case :)
07:17:39 <SamB_XP> Cale: apparantly there *was* an attempt to add an "in popular culture" section to the Wood article on July 7th...
07:17:45 <opqdonut> the compiler can figure out, for instance, the type of Just.head.head without one using it
07:17:49 <opqdonut> SamB_XP: multiple
07:18:10 <Baughn> opqdonut: Of course
07:18:14 <vixey> :t Just.head.head
07:18:16 <lambdabot> Couldn't find qualified module.
07:18:19 <vixey> :t Just . head . head
07:18:20 <lambdabot> forall a. [[a]] -> Maybe a
07:18:42 <SamB_XP> but even before that it didn't begin quite like the XKCD comic depicts it
07:19:26 <Baughn> frevidar: Actually, please do paste the error
07:19:35 <ski> @type \x -> listToMaybe =<< listToMaybe x
07:19:36 <lambdabot> forall a. [[a]] -> Maybe a
07:19:54 <vixey> :t listToMaybe <=< listToMaybe
07:19:56 <lambdabot> forall a. [[a]] -> Maybe a
07:20:04 <Baughn> It's not quite making sense to me. *float* has to have a (sufficiently) complete type, so float >>= return should too
07:20:14 <frevidar> baughn: actually, I've confused myself a little bit, but I've worked it a little. I'm only getting an error with the signature now.
07:20:17 <frevidar> I'll paste it
07:20:23 <chrisdone> yakov: define “real world app”
07:21:34 <frevidar> baughn: pasted
07:21:56 <Baughn> frevidar: *Where*?
07:22:09 <frevidar> http://hpaste.org/8961
07:22:10 <frevidar> sorry
07:22:14 <frevidar> I thought it would announce
07:22:24 <Baughn> Normally it would, but..
07:22:26 <frevidar> which means I wouldn't of had to say pasted
07:22:29 <frevidar> silly me
07:23:27 <quicksilver> :t Text.ParserCombinators.Parsec.float
07:23:28 <lambdabot>     Not in scope: `Text.ParserCombinators.Parsec.float'
07:24:06 <quicksilver> what's float?
07:24:09 <frevidar> :t Text.ParserCominators.Parsec.Token.float
07:24:10 <lambdabot> Couldn't find qualified module.
07:24:22 <Baughn> frevidar: Try just "number2 = float"
07:24:44 <frevidar> t Text.ParserCombinators.Parsec.Token.float
07:24:49 <frevidar> :t Text.ParserCombinators.Parsec.Token.float
07:24:49 <Baughn> Hopefuly quicksilver will tell me what's going on here, for it looks to me like it's decided you should be using the ((->) r) monad or some such
07:24:50 <lambdabot> forall s u (m :: * -> *). Text.Parsec.Token.GenTokenParser s u m -> Text.Parsec.Prim.ParsecT s u m Double
07:24:51 <quicksilver> float is a field of TokenParser.
07:25:06 <quicksilver> what are you trying to do here?
07:25:08 <Baughn> ...oh. DOh.
07:25:31 <quicksilver> have you called makeTokenParser to make a token parser?
07:26:39 <frevidar> http://hpaste.org/8962
07:26:57 <chrisdone> :t ap
07:26:58 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
07:26:59 <quicksilver> frevidar: did you read my comments?
07:27:31 <frevidar> quicksilver: I'm basically trying to follow http://legacy.cs.uu.nl/daan/download/parsec/parsec.html
07:27:32 <lambdabot> Title: Parsec, a fast combinator parser
07:27:55 <frevidar> and create a parser, eventually one that will recognise variables
07:29:01 <lilachaze> > [1] :: ([]) Int
07:29:03 <lambdabot>  [1]
07:29:44 <frevidar> quicksilver: but I'm finding, for example, the code in the section "buildExpressionParser  ::" does not compile
07:29:51 <vixey> > ([],[]) :: (,) ([] [] Int) ([] Int)
07:29:53 <lambdabot>      Kind error: `[]' is applied to too many type arguments
07:29:53 <lambdabot>     In the type `...
07:29:57 <vixey> aww
07:30:13 <frevidar> quicksilver: do a text search for that string to find the code in question
07:30:21 <quicksilver> frevidar: that document is completely out of date
07:30:26 <frevidar> quicksilver: so I'm trying to back up and see whats happening
07:30:26 <quicksilver> it doesn't work with the current parsec I dont' think.
07:30:33 <lilachaze> > [] :: [] ([] ([] ([] Int)))
07:30:34 <lambdabot>  []
07:31:19 <quicksilver> the only instance of the word 'float' in that document I can see
07:31:22 <quicksilver> is in the TokenParser
07:31:43 <frevidar> http://legacy.cs.uu.nl/daan/download/parsec/parsec.html has the similar code
07:31:44 <lambdabot> Title: Parsec, a fast combinator parser
07:31:49 <frevidar> hang on
07:31:52 <frevidar> thats the same spot
07:31:55 <quicksilver> you have to use makeTokenParser to get a TokenParser
07:32:01 <quicksilver> which you pull the float out of
07:32:05 <quicksilver> it's described there
07:32:07 <vixey> frevidar: Have you made a data type for the result of the parsing?
07:33:18 <frevidar> vixey: before I had
07:33:31 <frevidar> but I'm trying to simplify things to find the problem
07:33:39 <vixey> frevidar: It's probably worth doing that first, then you can build the parser to fit it, It could be something like data Expr = Variable Name | Constant Number | Function Name [Expr]
07:34:20 <frevidar> vixey: the result of the parsing at the moment should be a Double
07:34:36 <vixey> frevidar: I thought you wanted to parse things like "sin(x)"
07:34:43 <frevidar> vixey: eventually
07:34:51 <frevidar> I haven't got to sin(2) yet
07:35:05 <frevidar> or, sin(2.5), as the case is
07:35:06 <quicksilver> frevidar: if your intention is to simplify I think you want to stop trying to use TokenParser
07:35:07 <vixey> frevidar: it is not going to make things easier going that route
07:35:16 <quicksilver> why is it that whenever I mention TokenParser you just ignore me?
07:35:23 <quicksilver> float is a FIELD from TokenParser
07:35:28 <vixey> frevidar: the data I gave, gives you the first line of code, parseExpr = parseVariable <|> parseConstant <|> parseFunction -- It wont support infix yet but you can add it later
07:35:28 <quicksilver> you're tryign to use it as if it was not a parser
07:35:32 <quicksilver> as if it was a parser
07:35:34 <quicksilver> it's not a parser
07:35:40 <quicksilver> it's a FIELD from TokenParser
07:35:51 <quicksilver> you need to apply it to a TokenParser to actually get a float parser
07:35:55 <vixey> frevidar: so now parseVariable should just read some letters and return a Variable <letters>, and so on
07:36:00 <frevidar> quicksilver: ah, ok...
07:36:17 <quicksilver> I suggest leaving TokenParser entirely out for now
07:36:17 <vixey> frevidar: Is this approach making sense?
07:36:25 <quicksilver> if you're just learning Parsec that's making things too fiddly
07:38:01 <vixey> I guess not ..
07:38:30 <frevidar> quicksilver: I'm not ignoring you quicksilver sorry, I'm just having another look at the docs to try to make things make sense
07:38:48 <frevidar> vixey: I can't do sin(2.5) at the moment, the problem is parsing floats
07:39:07 <vixey> frevidar: no... I really think your whole approach is not a useful route
07:39:19 <quicksilver> I would parse floats as, something like
07:39:32 <vixey> frevidar: the example in there is not how you would do this in practice
07:39:35 <quicksilver> many digit >> option (dot >> many digit)
07:39:43 <quicksilver> (did I get that right? I never use parsec)
07:40:22 <quicksilver> I think it's better practice to write your first parser 'literally' without a separate tokenising / lexing step
07:40:32 <quicksilver> otherwise too many layers to absorb in one go.
07:41:33 <BMeph> quicksilver: So what do you use for parsing? Or do you mean that you "roll your own parser"? :)
07:42:51 <roconnor> @src many
07:42:52 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
07:42:52 <quicksilver> BMeph: to date I have always rolled my own parser.
07:43:09 <quicksilver> BMeph: it is such a simple thing to write that I'm too lazy to learn an API
07:43:15 <quicksilver> I don't really like parsec's API.
07:43:19 <quicksilver> I should try polyparse.
07:43:25 <quicksilver> but it's so easy to write by hand...
07:46:03 <oldsalt> hey guys, who updated haddock on hackage..haskell.org?
07:47:19 <chrisdone> oldsalt: have the ghc 6.8.3 issues for haddock been fixed?
07:47:44 <oldsalt> i dont know
07:48:08 <oldsalt> chrisdone: i am just wondering there are still no links to highlighted sources
07:49:38 <waern> oldsalt: simon marlow, I think
07:49:48 <waern> oldsalt: ah, sorry, no
07:50:05 <waern> thought you meant the homepage
07:50:31 <frevidar> quicksilver: number  = do { x1 <- many1 digit; dot1 <- dot; x2 <- many1 digit; return (read (x1 ++ "." ++ x2)) } fails to compile
07:50:45 <frevidar> am I doing something obviously wrong here?
07:50:47 <oldsalt> yes, i meant the homepage. until a few day ago, haddock 0.8 was used to build the docs, now it is 2.1.0
07:51:18 <mauke> what's the error?
07:51:22 <waern> oldsalt: you mean the docs on hackage.haskell.org?
07:51:27 <oldsalt> yes
07:51:54 <waern> oldsalt: Ross does that I think
07:52:09 <waern> but haddock 2 has been used there for quite a while I think, perhaps not for all packages
07:52:33 <oldsalt> k, "few" days i meant ;)
07:52:40 <frevidar> mauke: http://hpaste.org/8963
07:53:24 <mauke> frevidar: what is dot?
07:53:51 <quicksilver> frevidar: it turns out that dot is defined in Text.ParserCombinators.Parsec.Token
07:53:54 <quicksilver> that's not what I meant
07:54:00 <quicksilver> I meant for you to define your own dot
07:54:08 <quicksilver> ;)
07:54:11 <frevidar> quicksilver: oh, oops
07:54:13 <quicksilver> you don't want to import Text.ParserCombinators.Parsec.Token at all.
07:54:18 <quicksilver> it's just wasting valuable namespace
07:54:20 <frevidar> dot is one of those token thingies hey
07:54:28 <mauke> what is cabal-install trying to tell me?
07:54:30 <mauke> % cabal install haddock
07:54:30 <mauke> Resolving dependencies...
07:54:35 <mauke> cabal: cannot configure haddock-2.1.0. It requires ghc >=6.8.2 && <6.9 && >=6.8.2 && <6.9
07:54:55 <quicksilver> frevidar: all I meant was (char '.')
07:55:31 <dcoutts> mauke: and what version of ghc are you using there?
07:55:40 <mauke> ghc --version says 6.8.2
07:56:58 <dcoutts> mauke: and ghc-pkg list tells you that the 'ghc' package is there?
07:57:54 <mauke> ... no, actually
07:57:57 <frevidar> quicksilver: ah, thats works! (though thats complusory decimal points, I can make them optional I assume
07:58:00 <frevidar> thanks
07:58:04 <mauke> thanks
07:58:36 <quicksilver> frevidar: yeah, you probably want to wrap them in option or optionMaybe
07:58:41 <quicksilver> frevidar: check out the 'Combinators' package
07:58:58 <quicksilver> frevidar: it has no documentation but fortunately you can always guess from the type :)
07:59:43 <masak> always? :)
08:00:01 <frevidar> quicksilver: cool, I'll check that out
08:00:03 <frevidar> thanks
08:00:25 <masak> quicksilver: is that one of those statements that depend on the value of 'you'?
08:02:07 <chrisdone> when you have “foo `mu` bar `mu` zot”, is that “(foo `mu` (bar `mu` zot))” or “((foo `mu` bar) `mu` zot)”?
08:02:25 <dmwit> chrisdone: It's up to you!
08:02:27 <laz0r> frevidar: http://hpaste.org/8963#a1
08:02:30 <lilachaze> (reading up) you don't want to import Text.ParserCombinators.Parsec at all, you want to import Text.Parsec :)
08:02:54 <dmwit> chrisdone: You can infixr/infixl all identifiers, even ones that aren't obviously operators.
08:03:00 <JaffaCake> GHC meeting is happening over in #ghc, if anyone is interested
08:03:42 <laz0r> frevidar: don't know if that helps you, but i like reading other peoples source code to figure out things, so I thought it might help you as well
08:04:07 <lilachaze> JaffaCake: will it be accessible to non-ghc-developers?
08:04:19 <JaffaCake> lilachaze: sure
08:04:29 <chrisdone> > return (:) `ap` (return 1) `ap` (return [2]) :: [[Int]]
08:04:30 <lambdabot>  [[1,2]]
08:06:44 <chrisdone> dmwit: well, I was confused about this line but I didn't realise the “return (:) `ap` (return 1)” would make a partially applied function for the next `ap`
08:08:11 <chrisdone> heh, looks like my irssi has a bug
08:08:30 <chrisdone> 16:07 < chrisdone> dmwit: well, I was confused about this line but I didn't realise the “return (:) `ap` (return 1)” would make a partially applied function
08:08:34 <chrisdone> 16:05 <lambdabot>  for the next `ap`
08:08:39 <chrisdone> O_O
08:08:54 <dmwit> whoop
08:09:08 <dmwit> Where did that lambdabot come from?
08:09:20 <chrisdone> I've got it open in privmsg
08:09:36 <chrisdone> it shouldn't pass over into #haskell though :P
08:11:44 <byorgey> > (:) <$> pure 1 <*> pure [2] :: [[Int]]
08:11:45 <lambdabot>  [[1,2]]
08:11:47 <vixey> frevidar, http://hpaste.org/8963#a2
08:11:53 <chrisdone> dmwit: I suppose it could also be my terminal (gnome-terminal): http://img179.imageshack.us/img179/4883/oorc1.png *shrug*
08:12:19 <byorgey> > (:) <$> [1,2] <*> [[3],[4]] :: [[Int]]
08:12:20 <lambdabot>  [[1,3],[1,4],[2,3],[2,4]]
08:12:21 <chrisdone> :t pure
08:12:21 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
08:12:23 <lilachaze> > pure (:) <*> pure 1 <*> pure [2] :: Maybe [Int]
08:12:25 <lambdabot>  Just [1,2]
08:12:34 <chrisdone> heh, I'm just right now reading the pure paper
08:12:35 <byorgey> chrisdone: pure is like return, but for Applicative instead of Monad
08:12:55 <chrisdone> hence figuring out “ap” :P
08:12:55 <chrisdone> errr
08:12:55 <chrisdone> the applicative paper, I mean
08:12:55 <lilachaze> > (:) <$> 1 <$> [[2]]
08:12:56 <lambdabot>   add an instance declaration for (Num ([t] -> a))
08:13:00 <Asgaroth> what's the best way to implement an endless loop for writing output to a pipe?
08:13:03 <byorgey> chrisdone: right, cool =)
08:13:10 <chrisdone> Asgaroth: “forever”?
08:13:11 <vixey> Asgaroth: recursion
08:13:19 <byorgey> forever a = a >> forever a
08:13:19 <chrisdone> :t forever
08:13:20 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
08:13:38 <patco444> The Best Online RPG / Strategy game ever : http://www.fallensword.com/?ref=1461055
08:13:56 <Asgaroth> wouldn't that create a stack overflow, since this is going to run every 10 seconds for hours
08:14:20 <dmwit> lambdabot: Shame on you, that type is too restrictive.  Monad m => m a -> m b
08:14:31 <dmwit> Asgaroth: Gotta love tail-call optimization.
08:15:06 <quicksilver> dmwit: although that's not a tail-call :P
08:15:25 <chrisdone> tail recursion modulo a
08:15:25 <chrisdone> :P
08:15:36 <quicksilver> no, it's the >> in the tail position.
08:15:37 <Asgaroth> ok, thanks
08:15:45 <quicksilver> forever a = (>>) a (forever a)
08:15:57 <vixey> frevidar, did you see it?
08:15:57 <quicksilver> it not a tail recursive expression, a priori
08:16:16 <quicksilver> of course if (>>) gets inlined and turns out to place its second argument in a tail position
08:16:19 <quicksilver> then it will be.
08:16:30 <quicksilver> but you can't inline (>>) from IO, because (>>) from IO isn't expressible in haskell :P
08:18:17 <quicksilver> so in actual fact the reason that forever works without building up a huge stack is less obvious than it appears.
08:18:20 <FordCortina> in functional dependencies, is "(a,b) -> c" equivalent to "a->c, b->c"?
08:18:21 <quicksilver> it does work, in GHC, though.
08:18:31 <quicksilver> FordCortina: no.
08:18:33 <dmwit> FordCortina: no
08:18:56 <vixey> is a -> (b,c) equavalent to a -> b, a -> c?
08:18:58 <quicksilver> is (A AND B) IMPLIES C equivalanet to A IMPLIES C AND B IMPLIES C?
08:19:03 <quicksilver> vixey: yes.
08:19:23 <dmwit> (a,b) -> c means: given both a and b, I can tell you c; a -> c, b -> c means: given *either* a or b, I can tell you c.
08:20:12 <chrisdone> quicksilver: why can't forever a = (>>) a (forever a) be made tail recursive modulo (>>)?
08:20:12 <lilachaze> (a&b)->c <=> !(a&b)|c <=> !a|!b|c <=> a->(!b|c) <=> a->b->c
08:20:35 <quicksilver> chrisdone: it just isn't
08:20:40 <quicksilver> chrisdone: how do you know what (>>) does?
08:20:52 <quicksilver> chrisdone: (>>) might ignore its right argument, or call it 1 million times.
08:21:09 <vixey> what's the ! ?
08:21:22 <quicksilver> logical not
08:21:37 <quicksilver> although I find lilachaze's use of classical logic to be inappropriate in this context :)
08:21:42 <dmwit> quicksilver: (>>) can't call its right argument 1 million times.
08:21:55 <quicksilver> dmwit: why not?
08:21:59 <dmwit> quicksilver: Then your monad would break the (return a >>= f) = (f a) rule.
08:22:07 <quicksilver> [1.1000000] >> x does precisely that
08:22:21 <quicksilver> with an extra . ;)
08:22:40 <quicksilver> anyhow tail recursion is a static property.
08:22:50 <dmwit> Oh, you mean it like that.
08:22:52 <quicksilver> forever a = a >> forever a is not in tail recursive form.
08:22:52 <dmwit> ok
08:23:11 <dmwit> Right, no argument there.
08:23:31 <quicksilver> it might be, if your compiler inlines (>>)
08:23:34 <chrisdone> well, I was attempting to apply the tail recursion modulo cons idea
08:23:38 <quicksilver> but that would depend on the form of (>>)
08:23:57 <quicksilver> (i.e. it would depend on the monad instance)
08:24:03 <dmwit> (In my defense: I read "might call its right side 1 million times" as "it might be true that the right side is guaranteed to be called 1 million times"... which I still don't think make sense.)
08:25:03 <lilachaze> quicksilver: re classical logic, fundeps are kinda a model of computation, and curry howard, and... :)
08:25:18 * lilachaze waves hands here
08:25:31 <vixey> haha
08:25:32 <quicksilver> lilachaze: ... and as such, should use intuitionistic logic.
08:25:37 <quicksilver> lilachaze: precisely.
08:25:49 <quicksilver> lilachaze: the currey howard isomorphism is onto intuitionistic logic, not classic.
08:26:11 * lilachaze waves hands more vigorously
08:26:25 <vixey> curry howard works with classical too
08:26:36 <vixey> just add water^H call-with-current-continuation
08:26:57 <FordCortina> so basically fundeps are like propositional logic, except they must be a conjunction of implications?
08:27:26 <quicksilver> a conjuction of implications on conjunctions
08:27:45 <quicksilver> vixey: that's not the most natural setting though.
08:27:54 <quicksilver> vixey: and certainly fundeps don't have a useful notion of negation.
08:27:58 <quicksilver> which is the context we were in here.
08:27:59 <lilachaze> do fundeps have a _|_?
08:28:04 <quicksilver> no.
08:29:26 <frevidar> vixey: wow. I just did.
08:30:58 <frevidar> vixey: is that easy to change into something that does multiple variables?
08:31:01 <wmealing> can anyone recommend a quick guide to haskell , I could google it, but I prefer something human recommended for sanity.
08:31:10 <vixey> freividar: it already does multiple variables
08:31:17 <frevidar> vixey: wow
08:31:36 <frevidar> I'll have a play around with it
08:31:51 <mauke> wmealing: http://haskell.org/haskellwiki/Tutorials
08:31:52 <lambdabot> Title: Tutorials - HaskellWiki
08:32:12 <frevidar> I think I'm going to have to look at how this works in detail tomorrow
08:32:13 <wmealing> thankyou
08:32:40 <chrisdone> !!! http://book.realworldhaskell.org/beta/
08:32:42 <lambdabot> Title: Real World Haskell
08:33:12 <mar77a> very good book
08:33:27 <mar77a> wow, big update since i last checked
08:33:39 <mar77a> only 3 chaps left..
08:33:43 <mar77a> success
08:34:38 <chrisdone> ^_^
08:34:46 <frevidar> vixey: I mean, can you do things like sin(x,y)?
08:35:01 <LordBrain> yeah.. chapter 10 says bytestrings have already been introduced, but 1-9 doesn't introduce them... i'm wondering if htey're going to fix that by introducing them or changing the text of chapter 10
08:35:08 <vixey> frevidar: you could add a clause,  apply "sin" [x,y] = ...
08:35:41 <vixey> frevidar: so you can parse the expression to get an Expr, then eval [("x",5),("y",7)] parse will evaluate ita
08:35:42 <frevidar> vixey: it only returns a Maybe (Double -> Double) though
08:35:47 <mar77a> is using Maybe when defining function arguments the common way to implement pseudo-optional arguments in a function?
08:35:57 <mar77a> oops ...well you get the idea
08:36:12 <frevidar> vixey: something like ([Double] -> Double)
08:36:17 <vixey> mar77a: that sounds like a horrible idea .....
08:36:22 <mar77a> :(
08:36:27 <mar77a> what other options are there?
08:36:44 <LordBrain> could use a monad m =>
08:36:49 <LordBrain> maybe
08:36:50 <LordBrain> haha
08:36:53 <mar77a> '-'
08:36:57 <vixey> frevidar: If it' double you don't really know how many or which order, so I'd go with [(Name,Double)] -> Double or Map Name Double -> Double or whatever
08:37:21 <LordBrain> i think using Maybe in the function argument is fine
08:37:38 <vixey> it is, just not for simulating default parameters
08:37:38 <laz0r> mar77a: there is that Text.Printf.printf function that accepts an arbritrary number of arguments
08:37:54 <LordBrain> he said optional
08:37:55 <vixey> mar77a: options for what, what do you want to do?
08:37:58 <LordBrain> not default..
08:38:13 <mar77a> sorry, default
08:38:14 <mar77a> :x
08:38:16 <quicksilver> the way printf does it is horrible.
08:38:20 <laz0r> but i guess using Maybe is the simple solution
08:38:27 <quicksilver> I think Maybe is the simple solution
08:38:33 <LordBrain> well
08:39:01 <mar77a> something like f Maybe x = x; f Nothing = 0; ?
08:39:02 <vixey> the whole idea is horrible
08:39:04 <LordBrain> he could just make the parameter mandatory, on the canonical form of the function.. but have some temporary binding so that he doesn't have to put it in.
08:39:07 <mar77a> guess it needs brackets
08:39:15 <vixey> mar77a: syntax error
08:39:21 <mar77a> f (Maybe x) = x ?
08:39:23 <vixey> I was thinking of more like
08:39:29 <LordBrain> f (Just x) = x
08:39:32 <mar77a> oh yeah
08:39:39 <vixey> f Nothing b c d = f <default> b c d
08:39:40 <mar77a> Just hehe
08:39:46 <vixey> f a Nothing c d = f a <default> c d
08:39:47 <vixey> ...
08:39:57 <vixey> f (Just x) (Just y) (Just z) (Just w) = <actual function>
08:40:00 <frevidar> vixey: thanks, that code will really help me understand whats going on in parsec I think. I'll play around with it and try to work out the details
08:40:02 <vixey> which is horrible...
08:40:03 <frevidar> thanks again
08:40:19 <vixey> why would this help ?
08:40:22 <chrisdone> take a list of Maybes and then zipWith mplus with the default values
08:40:37 <vixey> chrisdone: yeah there are various horrible ways to achive this
08:40:47 <mar77a> is there a way which is vixey-aprooved
08:40:49 <mar77a> approved
08:40:51 <mar77a> !?!?
08:41:02 <quicksilver> mar77a: I would suggest that vixey-approval is a poor metric
08:41:11 <LordBrain> lol
08:41:14 <mar77a> i heard it's higher than ISO 9007
08:41:21 <vixey> mar77a: You still haven't said what you want to do
08:41:23 <quicksilver> vixey: I don't really see what you think is horrible at all.
08:41:36 <mar77a> default argument functions, like in *don't hurt me* c++
08:41:37 <vixey> quicksilver: it looks horrible and doesn't acheive anything
08:41:46 <mar77a> void f(int n=2){ ... }
08:41:48 <vixey> oh if you want to embed C++ in haskell
08:41:51 <vixey> ok
08:41:54 <quicksilver> it achieves making a parameter optional
08:42:04 <quicksilver> there are quite a few functions in the standard lib which work this way.
08:42:09 <mar77a> '-'
08:42:15 <vixey> I don't think that's the best way to program effectively in haskell
08:42:19 <vixey> but ....
08:42:39 <quicksilver> installHandler :: Signal -> Handler -> Maybe SignalSet -> IO Handler
08:42:41 <quicksilver> for example.
08:42:55 <quicksilver> well you haven't suggested an alternative, viexy.
08:43:02 <quicksilver> what would you rather do with an optional parameter?
08:43:02 <chrisdone> for optional arguments in my wordcloud code I used a data Config = Config { foo :: ..., bar :: ... } and then (myFunc (defConfig { foo = 1 }))
08:43:14 <frevidar> mar77a: are only the trailing parameters optional?
08:43:30 <mar77a> mmm yeah
08:43:35 <mauke> chrisdone: I'd make Config an instance of Default and use def{ foo = 1} :-)
08:43:45 <chrisdone> mauke: ooo, thanks for that
08:43:48 <vixey> quicksilver: that's not like Nothing == NULL is it?
08:43:54 <vixey> quicksilver: and Just x = <pointer to something>
08:43:57 <mar77a> void f(int x, int y=2){ }... i think something like void f(int x=2, int y){ .. } is ill-typed
08:44:02 <vixey> (I don't think it's quite the same as defaults)
08:44:02 <mauke> chrisdone: the problem with that is that you'll have to install Data.Default separately
08:44:41 <chrisdone> mauke: ah
08:44:44 <mar77a> well
08:44:47 <vixey> mar77a: besides being like C++, why do you want this?
08:44:49 <mar77a> i guess you can use partial application
08:44:56 <mauke> anyway, hackage++
08:45:05 <mar77a> i was just wondering how to do it vixey
08:45:10 <mar77a> since it's been handy
08:45:13 <quicksilver> well there are a variety of cases in the continuum between one optional parameter and a huge record full of defaults.
08:45:34 <vixey> I don't think this is useful in haskell
08:45:40 <quicksilver> I think for a small number of optional parameters, Maybe is perfectl fine.
08:45:43 <LordBrain> if he's making bindings for a c++ library, being like c++ is good
08:45:54 <mar77a> how does it work in that case btw
08:46:01 <quicksilver> vixey: I think that's a stupid thing to say.
08:46:03 <mar77a> if you use a c++ function with optional parameters
08:46:06 <frevidar> f x = g (x ++ (drop ((length x) - non_optional_params) defaults)) where defaults = [default1, default2, ...]
08:46:10 <quicksilver> it's useful, if it's useful to solve a particular problem.
08:46:16 <vixey> quicksilver: it's not
08:46:19 <jsnx> anybody heard of HLP?
08:46:21 <frevidar> pass your params in a list?
08:46:22 <jsnx> what is it?
08:46:26 <frevidar> g does the work
08:46:31 <frevidar> f hacks on the optional ones
08:46:31 <quicksilver> suppose I have 'displayDialog' which displays an alert to the user
08:46:34 <frevidar> maybe?
08:46:34 <quicksilver> with an optional message
08:46:37 <chrisdone> mauke: yes, it's only a tiny package anyway
08:46:46 <quicksilver> isn't : displayDialog :: Maybe String -> IO ()
08:46:50 <quicksilver> a fine way of modelling that?
08:47:00 <vixey> String -> IO ()
08:47:10 <mar77a> displayDialogDefault = displayDialog "default message"
08:47:18 <mar77a> yeah i think partial application is a nice way to solve it too
08:47:21 <frevidar> non_optional_params is the number of non_optional_parametres
08:47:30 <vixey> partial application does something different
08:47:36 <mar77a> so does using Maybe
08:47:43 <vixey> optional arguments are for when you can't remember what you're doing
08:48:06 <mar77a> '-'
08:48:06 <LordBrain> or for refactoring
08:48:20 <byte-> vixey, or for providing a nice interface
08:48:25 <LordBrain> sort of a lazy way to refactor in c++
08:48:27 <quicksilver> why would you prefer displayDialogDefault to displayDialog Nothing
08:48:29 <byte-> that cascades from newbie to expert
08:48:35 <quicksilver> I don't really see much difference between them to be honest.
08:48:37 <byte-> imagine if the win32 api had optional parameters
08:48:42 <quicksilver> I think they're equally acceptable.
08:48:50 <vixey> never used win32
08:49:04 <quicksilver> vixey: String -> IO() is not an answer to my question.
08:49:06 <LordBrain> quicksilver, one of them might just be a local binding
08:49:09 <quicksilver> I said the message was optional.
08:50:14 <mmorrow> arguing over Nothing...
08:50:19 <laz0r> i like haskells Maybe, it makes it pretty clear if something is optional
08:50:22 <byte-> mmorrow, please no
08:50:27 <mmorrow> hehe
08:50:27 <byte-> mmorrow, I get enough of that at reddit
08:50:35 <vixey> mmorrow: I tried to make an account but it didn't work :/
08:50:58 <mmorrow> what? bad jokes referencing the Maybe a type??
08:51:32 <mmorrow> vixey: uhnos! it took me about 2 weeks to figure everything out from the time i submitted a key ;)
08:51:49 <vixey> yeah I didn't get past submitting the key
08:51:55 <mmorrow> hehe
08:52:01 <mmorrow> what happened?
08:52:04 <vixey> nothing is working, it's frustrating
08:52:06 <LordBrain> I think it is acceptable stylistic choice either way... using maybe might mean there is a little more cognitive load in keeping the type straight...
08:52:12 <vixey> it says, error newline in ssh key
08:52:17 <vixey> there is no newline
08:52:26 <quicksilver> LordBrain: if you have two optional parameters, you need 4 renameds functions.
08:52:28 <mmorrow> vixey: i just love when everything goes wrong
08:52:41 <quicksilver> displayDialog :: Maybe String -> Maybe Icon -> IO ()
08:52:43 <byte-> LordBrain, using Maybes means you have to manually set the defaults in the function
08:52:56 <quicksilver> byte-: as opposed to what?
08:53:05 <LordBrain> quicksilver, yeah but you could just put a let func' = func default1 default2
08:53:09 <FordCortina> ghc doesnt seem to accept (a,b) -> c or a -> b -> c. I'm having difficulty converting it to a form that it will accept. Any ideas?
08:53:09 <chrisdone> using separate functions
08:53:10 <byte-> well, you obviously have to specify a default either way
08:53:27 <vixey> mmorrow: I got about half of pattern matching done so I can fun fibs and stuff
08:53:36 <byte-> but optional parameters don't add code
08:53:38 <vixey> I am kind of bored of this code now though
08:53:42 <FordCortina> (these are fun deps)
08:53:42 <byte-> you just annotate the function arguments
08:54:03 <mmorrow> vixey: how are you trying to paste it? i'm sure something that's going to be obvious after-the-fact is happening..
08:54:09 <mmorrow> vixey: ooh, cool
08:54:12 <vixey> I was going to compile it to something but I think I will pick a real language to compile
08:54:24 <LordBrain> @where polyvariadic
08:54:24 <lambdabot> I know nothing about polyvariadic.
08:54:27 <LordBrain> hm
08:54:39 <mauke> http://okmij.org/ftp/Haskell/types.html#polyvar-fn
08:54:40 <vixey> @src printf
08:54:40 <lambdabot> Title: Haskell Programming: Types
08:54:41 <lambdabot> Source not found. Wrong!  You cheating scum!
08:54:46 <Saizan_> FordCortina: a b -> c
08:54:55 <mar77a> yesterday when my father asked me what use was haskell i said "everything but oriented towards research" ... he wasn't happy with "everything"... not that he knows anything about programming
08:54:56 <LordBrain> mar77a, here is another interesting solution for you: http://okmij.org/ftp/Haskell/vararg-fn.lhs
08:55:00 <mar77a> lets see
08:55:03 <mmorrow> vixey: how are you doing the pattern matching?
08:55:07 <quicksilver> mar77a: so, in the absence of any argument to the contrary, I think using Maybe types is a fine way to model optional arguments.
08:55:12 <mmorrow> with gadts?
08:55:15 <vixey> mmorrow: desuging case trees into eliminators
08:55:24 <quicksilver> mar77a: although with very large complex sets of arguments you might prefer a record type.
08:55:32 <FordCortina> Saizan_: and that stands for a & b -> c?
08:55:37 <vixey> mmorrow: I've written this before in lisp but it turned out a lot harder than I thought
08:55:43 <mmorrow> vixey: fancy pants!
08:55:45 <byte-> quicksilver, it's pretty much the only way, outside of creating separate functions
08:55:53 <Saizan_> FordCortina: yes
08:55:55 <byte-> unless you do something like assume "" means default
08:55:57 <FordCortina> thanks
08:56:01 <byte-> which is ugly
08:56:25 <mar77a> yeah
08:56:29 <chrisdone> I wonder if "" means False in Python
08:56:41 <vixey> >>> not ""
08:56:42 <vixey> True
08:56:45 <mmorrow> vixey: i just realized a little earlier that it's pretty much impossible to translate a regular (pre-existing) ADT in another syn for the same lang that's written using GADTs.
08:56:50 <chrisdone> haha, ok
08:57:02 <vixey> mmorrow: what does syn mean?
08:57:04 <byte-> [] is considered false
08:57:12 <mmorrow> vixey: um yeah, that came out convoluted
08:57:12 <byte-> so i'm not surprised that "" is, too
08:58:53 <byte-> hmm
08:58:54 <vixey> you can turn ADTs into GADTs
08:58:54 <mmorrow> vixey: i was trying to use the hjs parser to parse javascript, but i wanted to use the syntax from hjavascript because it's nice, so i thought i could just translate the hjs AST after parsing to the hjavascript AST
08:58:57 <byte-> > "" == []
08:58:59 <lambdabot>  True
08:59:03 <byte-> > 1:2:3:""
08:59:04 <lambdabot>   add an instance declaration for (Num Char)
08:59:05 <vixey> ohh I see
08:59:13 <vixey> and what was tde problem in doing it?
08:59:14 <byte-> that's disappointing
08:59:22 <chrisdone> byte-: no it's not
08:59:29 <vixey> byte-, look at the types
08:59:33 <vixey> :t []
08:59:34 <chrisdone> :t ""
08:59:34 <vixey> :t ""
08:59:35 <lambdabot> [Char]
08:59:36 <lambdabot> [Char]
08:59:37 <lambdabot> forall a. [a]
09:00:22 <byte-> i know :)
09:00:34 <mmorrow> vixey: the regular ADTs are eg    Exp = Var String | Fun String [Exp] | ...       and the GADT one is like        data Var a where Var :: String -> Exp t               data Exp t where  JInt :: Int -> Exp Int  ...
09:00:36 <byte-> i just thought it would be fun if haskell typed that as [a]
09:00:43 <byte-> because that's what it technically is
09:00:51 <chrisdone> technically, it's not
09:00:59 <LordBrain> yeah that would be bad
09:01:11 <chrisdone> > ("hello" ++ ([] :: [Int]))
09:01:11 <lambdabot>  Couldn't match expected type `Char' against inferred type `Int'
09:01:11 <LordBrain> "" should type as [char]
09:01:16 <LordBrain> Char
09:01:22 <mmorrow> vixey: and i saw no easy way of doing it (i may have overlooked something). so i just started to write my own AST
09:01:28 <byte-> chrisdone, perhaps you're confused about my use of the term "technically"
09:01:52 <chrisdone> byte-: does it mean “in a non statically typed world”?
09:01:58 <byte-> no
09:02:02 <mar77a> :t ""
09:02:02 <lambdabot> [Char]
09:02:05 <vixey> mmorrow: oh, yeah unless you know what the 'a' in Var a is, but once you do think sometimes you would even have to use typeclasses to write the converter
09:02:07 <mmorrow> vixey: (i meant ... data Var a where Var :: String -> Var t ...)
09:02:11 <mar77a> > "" == []
09:02:11 <byte-> the only reason haskell knows what type "" is is because there are quotes around it
09:02:12 <lambdabot>  True
09:02:15 <byte-> it's not like there are any chars in it
09:02:16 <mar77a> there
09:02:20 <chrisdone> byte-: and?
09:02:28 <mar77a> > 5:4:3:2:1:""
09:02:29 <lambdabot>   add an instance declaration for (Num Char)
09:02:29 <LordBrain> two things can be == and one have a type which is a generalization of the other
09:02:36 <byte-> chrisdone, that's what i mean by "technically"
09:02:37 <mar77a> > 'a':""
09:02:39 <lambdabot>  "a"
09:02:43 <mar77a> hoho
09:02:49 <quicksilver> byte-: the only reason that haskell knows what type anything is is because of the characters used to write it.
09:02:52 <chrisdone> byte-: you said, technically "" is equal to forall a. [a]
09:02:59 <quicksilver> byte-: I'm not quite getting what you're aiming at :)
09:03:17 <mmorrow> vixey: yeah totally. it seemed/s like there's no real way to do it other that generating the converted GADT src, then compiling that (ie have to feed it back through the compiler)
09:03:38 <quicksilver> how is "" inferring to [Char] any different from any other kind of inference?
09:03:40 <byte-> quicksilver, differently typed values generally have different structures
09:03:40 <vixey> mmorrow: What is the type of the parser (that produces a GADT)?
09:03:49 <chrisdone> > "" == ([] :: [Int])
09:03:50 <lambdabot>  Couldn't match expected type `Char' against inferred type `Int'
09:03:52 <byte-> but "" is the same as []
09:03:56 <byte-> structurally
09:04:05 <quicksilver> it might be, it might not be.
09:04:06 <vixey> (because I was looking at this kind of thing... I had to write  String -> Term undefined   basicaly)
09:04:07 <byte-> i'm not saying it would be useful (or advisable) for haskell to type "" as [a]
09:04:08 <byte-> i just thought it would be fun
09:04:14 <quicksilver> that's the way GHC implements it sure
09:04:20 <vixey> @src asTypeOf
09:04:21 <lambdabot> asTypeOf = const
09:04:23 <vixey> :t asTypeOf
09:04:24 <lambdabot> forall a. a -> a -> a
09:04:26 <quicksilver> but there is no promise that another compiler woudl do the same.
09:04:29 <vixey> byte-: ^ check it out
09:05:19 <mmorrow> vixey: the hjs parser parser to a regular ADT, but the hjavascript package has a nice GADT ast and i wanted to somehow get from javascript src to that, but so much information is lost.
09:05:44 <vixey> ah I understand
09:05:58 <mmorrow> (ignore the fact that i can't speak coherently currently ;) tired..)
09:06:01 <LordBrain> well, i think byte- might be noticing that for any other list type, the representation of the null case would not be enough information for the compiler to infer a monomorphic type, but with the "" syntax, [Char] can be inferred.
09:06:19 <quicksilver> sure, because string syntax is special.
09:06:22 <LordBrain> perhaps that offends some sensibility in him
09:06:39 <vixey> :t let emptyString = [] :: String in    emptyString
09:06:41 <lambdabot> String
09:06:42 <vixey> :t let emptyString = [] :: String in   ""
09:06:43 <lambdabot> [Char]
09:06:47 <vixey> :/
09:06:52 <vixey> :t let emptyString = [] :: [Char] in    emptyString
09:06:54 <lambdabot> [Char]
09:07:10 <byte-> the thing i dislike about irc
09:07:30 <byte-> is that pointless asides escalate into full-scale discussions
09:07:40 <LordBrain> lol
09:08:00 <byte-> complete with examples and counter-arguments
09:08:35 <chrisdone> better than ad hominem
09:08:55 <byte-> i guess
09:09:08 <byte-> but it's not like that's absent in irc, either
09:09:17 <quicksilver> it's absent in #haskell, more or less
09:09:23 <chrisdone> indeedy
09:09:25 <quicksilver> which is rather nice thing.
09:09:31 <quicksilver> however, we are hungry for knowledge
09:09:49 <dons_> jsnx: ok. this CSV stuff is getting annoying. can you put the input data up somewhere, and the expected output? I want to solve it.
09:09:52 <quicksilver> and if you say something unclear, we descend upon it like a pack of dogs, tugging and gnawing to try to find the insight concealed within.
09:10:16 <mmorrow> vixey: here's a (caballed) darcs repo with the parser half of hjs (significantly cleaned up) and the hjavascript syntax also. that parser may not be pretty, but it parses *full* javascript.
09:10:17 <mmorrow> http://code.haskell.org/~morrow/code/haskell/js-lang/
09:10:19 <lambdabot> Title: Index of /~morrow/code/haskell/js-lang
09:10:38 <chrisdone> mmorrow: wow, cool
09:11:20 <mmorrow> (bear in mind, that is code from the hjs package and the hjavascript package. i just pulled out the hjs parser and cleaned it up some)
09:11:39 <byte-> ooh, nice
09:11:48 <mmorrow> but yeah, definitely cool
09:11:54 <byte-> Linus just called "the OpenBSD" crowd "a pack of masturbating monkeys"
09:11:55 <LordBrain> what is it?
09:12:01 <byte-> i see he's still got his golden tongue
09:12:10 <byte-> oops
09:12:13 <byte-> too many sets of quotes
09:12:28 <LordBrain> javascript implemented in haskell?
09:12:57 <chrisdone> what next; an operating system? :P
09:13:10 <byte-> while i'm in here, i might as well ask a haskell-related question
09:13:15 * chrisdone waits
09:13:26 <dons_> jsnx: ping me when the input data is available.
09:13:29 <byte-> suppose i have a compiler for a language with macros
09:13:32 <LordBrain> there was work i remember hearing about in 2006 to make an operating system kernel at least in haskell... not sure what the state of that is now.
09:13:46 <chrisdone> LordBrain: that's correct
09:14:00 <byte-> i want to split the compiling phase into two passes: macroexpansion and compilation
09:14:09 <byte-> the former works on an AST
09:14:14 <byte-> and the latter works on the same AST, without macros
09:14:18 <chrisdone> LordBrain: http://programatica.cs.pdx.edu/House/
09:14:18 <lambdabot> Title: House
09:14:36 <byte-> how would you implement this in Haskell without using the same ADT?
09:14:38 <__pao__> the nice thing about proliferation of languages is that you can have fun with combinatorial explosion of potential projects :-)
09:14:41 <mmorrow> Lorbrain: the hjs pkg (on hackage) is a *working* javascript interpreter in haskell. unfortunately it seems to not be very maintained/actively worked on anymore. it's pretty much split into two halves => parser/interpreter. check it out!
09:14:47 <LordBrain> look at that i got the year right and everything
09:15:00 <vixey> byte-: huh?
09:15:04 <LordBrain> did they stop working on it in 2006?
09:15:10 <chrisdone> LordBrain: dunno
09:15:31 <__pao__> everyone can have his own "actor model for a python interpreter written in OCaml" ... :-)
09:15:34 <LordBrain> version 0.8 at the top there says august 2006
09:15:56 <quicksilver> byte-: it's a fairly well known problem.
09:15:59 <byte-> vixey, actually, i can simplify it further
09:16:06 <byte-> i have function1 that operates on an ADT
09:16:10 <mmorrow> byte-: i don't understand how you mean
09:16:11 <quicksilver> byte-: when you make an incremental change
09:16:15 <byte-> and also function2, which operates on ADT-some constructor
09:16:18 <quicksilver> byte-: and you get a "slightly differeent type"
09:16:24 <quicksilver> byte-: shoudl you call taht a separate type or not?
09:16:54 <byte-> what i'd like to do is 'data ADT a = X | Y | Z | a'
09:16:56 <byte-> and do
09:17:06 <vixey> dons_: Do you know if it's me that made a mistake or hackage site? It said something about a newline in the ssh key but I didn't have one? (sorry if you are busy just ignore me)
09:17:16 <quicksilver> byte-: there isn't a simple answer, unfortunately :(
09:17:21 <vixey> byte-: that's not valid
09:17:22 <byte-> function1 :: ADT () -> ADT F
09:17:31 <byte-> function2 :: ADT F -> ADT F
09:17:34 <quicksilver> byte-: one approach is to use a tool like catch to prove what you're doing is sensible.
09:17:34 <vixey> but you can write
09:17:36 <byte-> but obviously that isn't possible with haskell
09:17:37 <vixey> data ADT a where
09:17:43 <vixey>   x :: ADT ()
09:17:45 <vixey>   y :: ADT ()
09:17:49 <vixey>   z :: ADT anything
09:18:06 <byte-> i thought about that
09:18:09 <quicksilver> even without GADTs you could do
09:18:10 <vixey> and ADT Bool is a subset of ADT Anything
09:18:14 <byte-> but it doesn't quite work with a recursive ADT
09:18:20 <quicksilver> data ADT a = X | Y | Z | A a
09:18:25 <vixey> byte-: you can have recursive GADTs
09:18:29 <quicksilver> with GADTs you can do more cleverness.
09:18:49 <quicksilver> byte-: this is closely related to the well-known expression problem
09:18:52 <byte-> quicksilver, but then that's still the same problem
09:19:12 <byte-> i basically have two variations of an ADT: one with the X data constructor, and one that's identical except it doesn't have X
09:19:22 <quicksilver> yes, I understand you perfectly.
09:19:25 <byte-> (and also, since it's recursive, all of the recursive references are the same as the base type)
09:19:30 <vixey> byte-: did you get that?
09:19:33 <quicksilver> and there is no simple answer.
09:19:40 <byte-> vixey, get what?
09:19:43 <quicksilver> GADTs do help though.
09:19:48 <vixey> byte-: you can have recursive GADTs
09:20:03 <geezusfreeek> i just skimmed over this conversation and i don't understand what the problem is
09:20:05 <quicksilver> you can use the tags in the GADT to exclude some constructors.
09:20:21 <vixey> unless you have a specific problem with GADTs or whatever, it's very likely that you can keep saying there's a problem when there isn't really
09:20:24 <byte-> whoah, GADTs are a haskell construct?
09:20:29 <quicksilver> geezusfreeek: coping with two types which differ only in the presence or absence of a single construtor.
09:20:41 <vixey> byte-: what I wrote there will work in GHC
09:20:45 <quicksilver> geezusfreeek: without *actually* writing out two types and having to duplicate lots of code.
09:20:49 <byte-> i did not know that
09:20:58 <quicksilver> they're a GHC extension, byte-
09:21:04 <geezusfreeek> aha
09:21:05 <byte-> i just thought you meant GADT in the theoretical sense
09:21:17 <byte-> let me read the wiki page on gadts and i'll get back to you
09:21:23 <mmorrow> byte-: maybe it would be helpful to split up the datatype into two (or more)? possibly make a separate datatype for *each* constructor, then recombine the with a GADT
09:21:41 <quicksilver> geezusfreeek: consider for example an AST before variable lookup and an AST after variable lookup.
09:21:49 <geezusfreeek> right, i get it now
09:21:51 <quicksilver> geezusfreeek: the latter has no nodes of type Var
09:22:07 <quicksilver> but it's a pain to write two entirely separate types which are the same in all respects exact.
09:22:12 <quicksilver> except...
09:22:15 <quicksilver> I meant to type.
09:22:16 <quicksilver> damn fingers.
09:22:41 <mmorrow> something like    data Var = Var String      data Exp = Lam Var Exp           data Syn a t where ExpS :: Exp -> Syn Exp t   VarS :: Var -> Syn Var t    etc
09:23:01 <byte-> mmorrow, would that let you work with either of the two datatypes within the same function?
09:23:04 <byte-> i.e. ADT a
09:24:05 <LordBrain> well i guess that's what a type class is for...
09:24:09 <roconnor> > recip 23356231572.65
09:24:15 <byte-> oohhh, ok
09:24:16 <lambdabot>  4.281512609983683e-11
09:24:20 <vixey> no need
09:24:32 <roconnor> wow
09:24:33 <vixey> you just make it polymorphic for the superset
09:24:38 <vixey> restrict the type for the subset
09:24:47 <mmorrow> byte-: well, i'm not sure if i know exactly what you're asking, but you could be like  class A a     instance A Var   instance A Exp          go :: (A a) => Syn a t -> something
09:25:01 <byte-> would typechecking GADTs be considered dependent typing?
09:25:01 <vixey> just hope you don't use -Wall
09:25:08 <vixey> byte-: no
09:25:46 <quicksilver> well GADTs do make it easier to do some kinds of dependent typing.
09:25:56 <quicksilver> it's a continuum.
09:26:04 <vixey> you still can't make types depend on values, so you can't reflect programs into the type system
09:27:08 <byte-> that's what i figured
09:27:17 <byte-> i guess ghc just bails out in the undecidable case?
09:27:29 <vixey> which undecidable case?
09:27:39 <byte-> i'm looking at the SafeList example
09:27:41 <mmorrow> it seems to me, as i've gathered over the last little bit, that GADTs are more useful (and less painful) when you're making an AST that you want to eval/interpret w/in your program, whereas regular ADTs are more convenient when you want to transform that datatype into another ... generate code.
09:28:08 <byte-> oh, i see
09:28:19 <byte-> there's no way to say "this list is either empty or notempty"
09:28:22 <mmorrow> that's my personal observation/opinion though...
09:28:23 <byte-> so it never becomes undecidable?
09:28:41 <vixey> typechecking functions that use GADTs is decideable
09:28:46 <byte-> ok
09:31:28 <quicksilver> to get undecidability in there you need to add in type classes + certain extensions.
09:31:42 <byte-> hmm
09:33:02 <Asgaroth> is there a function to get the nth element of the list?
09:33:15 <geezusfreeek> :t (!!)
09:33:16 <lambdabot> forall a. [a] -> Int -> a
09:33:25 <Asgaroth> thanks
09:33:27 <mauke> @hoogle Int -> [a] -> a
09:33:28 <lambdabot> Prelude.(!!) :: [a] -> Int -> a
09:33:28 <lambdabot> Data.List.(!!) :: [a] -> Int -> a
09:33:31 <vixey> I think (!!) only works for getting the ith :P
09:33:37 <geezusfreeek> :P
09:33:38 <vixey> @src (!!)
09:33:39 <lambdabot> xs     !! n | n < 0 = undefined
09:33:39 <lambdabot> []     !! _         = undefined
09:33:39 <lambdabot> (x:_)  !! 0         = x
09:33:39 <lambdabot> (_:xs) !! n         = xs !! (n-1)
09:33:41 <vixey> aww
09:33:44 <vixey> yeah it's n'th
09:34:19 <quicksilver> Asgaroth: as a general pattern, thouhg, you probably dont' want to use (!!) :)
09:34:30 <geezusfreeek> just for the record, needing to use (!!) sometimes is an indicator that you are doing something wrong
09:34:32 <byte-> while we're on lists
09:34:37 <byte-> is there a way to 'update' a list
09:34:38 <geezusfreeek> ... beaten again
09:34:49 <byte-> at a certain index
09:34:57 <quicksilver> not a built in combinator.
09:35:04 <quicksilver> again, that's probably a sign you shouldn't be using lists.
09:35:06 <byte-> it's rather difficult to implement tic tac toe without something like that
09:35:09 <geezusfreeek> byte-: sounds like you would want an array
09:35:09 <Asgaroth> quicksilver: i'm using it to get some text from a file which is always at line 2. is !! wrong in this context?
09:35:10 <byte-> i wound up implementing it myself
09:35:16 <quicksilver> Asgaroth: no, that's fine.
09:35:35 <quicksilver> byte-: I'd recommend Data.Sequence for general "list-like structure with efficient update"
09:35:36 <vixey> if you want tic-tac-toe,
09:35:39 <carl> im doing some file io right now and im finding myself writing this kinda thing "a <- hGet 4 ; b <- return (decode a)" is there i nicer way to do that sorta thing
09:35:44 <quicksilver> Asgaroth: if 'n' is always under 10 you're fine :)
09:35:46 <vixey> Triple (Triple Cell) is nice
09:36:01 <vixey> nicer than []
09:36:02 <quicksilver> byte-: tic-tac-toe sounds like a reasonable example where an array would be a good structure.
09:36:15 <byte-> hmm... ok
09:36:15 <quicksilver> or as vixey says, simply Triple . Triple
09:36:16 <Asgaroth> quicksilver: what would one do if it wasn't below 10?
09:36:21 <byte-> i think i knew about arrays/sequences
09:36:26 <quicksilver> Asgaroth: think again about your algorithm.
09:36:28 <byte-> i guess i was just too lazy to use them
09:36:38 <wmealing> http://hpaste.org/8966  ( helloworld.hs:23:12: parse error on input `<-' )
09:36:40 <quicksilver> Asgaroth: (!!) is slow in lists; with large lists you want to "stream" them.
09:36:52 <quicksilver> Asgaroth: if your use case isn't streaming, for a large list, you probably want a different structure.
09:37:03 <wmealing> i'm doing it wrong.. i just dont know what to do otherwise.
09:37:07 <Asgaroth> quicksilver: ok. thanks for the explanation
09:37:17 <quicksilver> wmealing: lines 23 onwards need to be indented
09:37:24 <wmealing> oh, right
09:37:32 <wmealing> same intent as the putstr i gather ?
09:37:41 <quicksilver> wmealing: well, 23-25 need to go "right" by two spaces
09:37:52 <quicksilver> 26-27 need to go "left" two spaces
09:37:54 <wmealing> is 2 a magic number, ie, should i have a vim mode for this ?
09:37:54 <quicksilver> if I read that right.
09:38:00 <quicksilver> no, 2 isn't a magic number
09:38:08 <quicksilver> it's whatevr you need to match your first one (the putStr)
09:38:11 <wmealing> ok
09:38:22 <wmealing> sweet, thanks
09:38:23 <quicksilver> I think the vim mode is capable of doing something sensible
09:38:27 * wmealing nods
09:38:29 <quicksilver> but I don't use vim so I don't know how :)
09:38:35 <wmealing> i'm usually a python coder, i can fix it.
09:39:42 <wmealing> haskells indentation doesn't scare me
09:39:45 <quicksilver> ;)
09:40:15 <wmealing> other things suuure..
09:43:24 <roconnor> http://hpaste.org/8967
09:43:35 <roconnor> Is there a better way to write this parsing code. One that less prone to forgetting a ' ?
09:44:39 <xerox> maybe you could use numbered variabile names
09:44:50 <Saizan_> roconnor: newtype that as a monad or write a specialized >>=?
09:45:14 <quicksilver> roconnor: yes, using a state monad
09:45:22 <quicksilver> (or your own custom monad if you can be bothered)
09:45:42 <roconnor> hmm
09:46:09 * roconnor nods
09:46:20 <quicksilver> this is exactly the advantage of state monads
09:46:24 <chrisdone> looks like a fold?
09:46:26 <quicksilver> (reducing the risk of dropping a prime)
09:46:38 <quicksilver> but the disadvantage is syntax overhead
09:46:43 <quicksilver> actually chrisdone is right
09:46:45 <quicksilver> :t foldM
09:46:46 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
09:46:53 <quicksilver> hmm
09:47:02 <quicksilver> :t mapAccumM
09:47:03 <lambdabot> Not in scope: `mapAccumM'
09:47:12 <quicksilver> nah, I don't think the right combinator is there :)
09:47:19 <quicksilver> :t mapAccumL
09:47:20 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
09:47:29 <quicksilver> mapAccumL is mapM in the state monad, unwrapped.
09:47:38 <chrisdone> cool
09:47:43 <quicksilver> there isn't an equivalent one for when you're in a different base monad
09:47:49 <quicksilver> (lists in roconnor's case)
09:48:12 <roconnor> the readsPrec's are deciving because they are all of difference instances.
09:48:22 <roconnor> I don't think it is a fold because of this
09:48:38 <roconnor> unless folds are more magically polymorphic than I think
09:48:50 <quicksilver> ah yes that's a good point.
09:50:07 <sebaseba> How can I make an instance of Show for a list of, say, MyType?
09:50:21 <geezusfreeek> could be a fold over a data type like data Readable = forall a . Read a => Readable a
09:50:25 <quicksilver> sebaseba: well the first answer is you can't.
09:50:33 <quicksilver> sebaseba:  you should only make instancse for MyType
09:50:39 <geezusfreeek> over a list of those, that is
09:50:41 <quicksilver> the instance fo the list is automatic, based on that one.
09:50:54 <quicksilver> sebaseba: however, the second answer is that actually there is already a hack in place for String
09:50:58 <quicksilver> and you can (ab)use that hack
09:51:03 <roconnor> quicksilver: yes you can
09:51:04 <quicksilver> :t showList
09:51:05 <lambdabot> forall a. (Show a) => [a] -> String -> String
09:51:10 <geezusfreeek> oh i misread the paste anyway
09:51:12 <roconnor> oh
09:51:15 <quicksilver> by overloading 'showList' in MyType
09:51:24 <roconnor> quicksilver: sorry, please continue. :)
09:51:25 <quicksilver> I dont' really recommend it though.
09:51:33 <geezusfreeek> but something along those lines
09:51:38 <roconnor> I totally recommend it
09:51:58 <quicksilver> I'm of the opinion that Show instances should produce valid haskell code fragment.s
09:51:59 <misterbeebee>  How does Data.Sequence Char compare to a hypothetical Data.Sequence Char# , that uses unboxed chars? I'd imagine something like a 10:1 memory difference
09:52:08 <roconnor> quicksilver: ah
09:52:14 <misterbeebee> (which matters if the Sequence is the largest piece of data in the program)
09:52:15 <sebaseba> so it would be something like "instance Show MyType where showList x = ..." ?
09:52:50 <roconnor> does sebaseba also have to provide a normal show instance?  I expect so
09:53:18 <quicksilver> misterbeebee: I think 10:1 is overly pessimistic
09:53:20 <quicksilver> sebaseba: yes.
09:53:20 <roconnor> sebaseba: you will have to define show as well, because you will lose your deriving instance.
09:53:30 <quicksilver> misterbeebee: most of the data.sequence overhead is fixed.
09:53:43 <quicksilver> misterbeebee: I'd be quite surprised if it was worse than 2:1
09:54:07 <misterbeebee> oh, i thought boxing was much more than that. when you have a polymorphic wrapper like Data.Sequence
09:54:15 <misterbeebee> (but I don't understand this stuff well)
09:54:22 <quicksilver> boxing is only one pointer
09:54:34 <quicksilver> so, 32 or 64 bits
09:54:47 <sebaseba> quicksilver: I see. What is the String parameter in showList?
09:54:56 <misterbeebee> well  32:8 is 4:1, for 8bit Chars
09:54:58 <quicksilver> sebaseba: the string so far
09:55:05 <quicksilver> misterbeebee: haskell doesn't have 8 bit chars
09:55:22 <quicksilver> but my point is the *rest* of Data.Sequence is a bigger overhead
09:55:32 <quicksilver> at least 2 or 3 pointers per cell I imagine
09:55:34 <misterbeebee> well, it has Word8's, for when I want to deal with 8-but chars
09:55:40 <quicksilver> so saving 1 point isn't going to save you much.
09:55:55 <quicksilver> well word8s only actually take 8 bits if they're packed together.
09:56:08 <quicksilver> and how could you expect GHC to pack together word8s which occur in different branches of a tree?
09:56:36 <misterbeebee> I guess what I'm thinking about is sequence vs ByteString. ByteString is very memory efficient, but has no insert ability
09:56:37 <quicksilver> sebaseba: you should return a function of the form (foo++) basically
09:56:50 <quicksilver> misterbeebee: agreed.
09:57:37 <quicksilver> misterbeebee: an efficient structure for update on large bytestrings is probably some kind of clever fingertree where each node is of decent size
09:57:41 <quicksilver> say, 16K or 64K
09:58:26 <sebaseba> quicksilver: thanks, I'll give it a try. But, since you mentioned you prefer to make instances of Show produce valid Haskell code, how would you do this?
09:58:26 <misterbeebee> and, in a perfect world, the leaves of the sequence/fingertree would be raw char-arrays, by the time the compiler got through with them. So... either the tree part kills memory anyway, or a Sufficiently Smart Compiler (TM) could generate memory- efficient trees.
09:59:04 <quicksilver> sebaseba: I just wouldn't override this instance.
09:59:14 <quicksilver> sebaseba: why are you unhappy with the default Show for [MyType] ?
09:59:30 <quicksilver> misterbeebee: well it's a balance between node size and tree size
09:59:31 <sebaseba> quicksilver: Maybe I should give more information about what I'm trying to do. I'm building a translator that converts from one file format to another. So I'm worried about ++ing too many strings.
09:59:55 <sebaseba> quicksilver: because I want the resulting string to be in the format of my target file format.
09:59:58 <chrisdone> roconnor: I can't actually get your readsPrec to run. can you give a sample string?
10:00:08 <roconnor> sebaseba: use difference lists.
10:00:16 <Toxaris> sebaseba: you can use the ShowS-technique independent of class Show
10:00:17 <roconnor> is there a wiki link for difference lists for sebaseba?
10:00:32 <roconnor> or listen to Toxaris
10:00:39 <ddarius> They shouldn't be called difference lists in my opinion.
10:00:59 <Asgaroth> if I use =~ to match a string(from Text.Regex.Posix) with a pattern with grouping( '(...)'), how do i access the individual groups?
10:01:13 <roconnor> chrisdone: are you using firefox?
10:01:17 <misterbeebee> anyway, if Data.Sequence in practice is a fixed constant, and it fits in RAM, I shouldn't be afraid  of it. Beats the heck out of repeatedly reallocating arrays...
10:01:17 <sebaseba> I've read about dlists before. But what's this ShowS-voodoo thing?
10:01:20 <vixey> > let toDlist l = (l++) ; fromDlist d = d [] in fromDlist (toDlist "foo" ++ toDlist "bar")
10:01:23 <lambdabot>  "foobar"
10:01:31 <quicksilver> sebaseba: ShowS is just (String -> String)
10:01:46 <chrisdone> roconnor: sorry? I'm running your paste in ghci O_o
10:01:57 <quicksilver> > ("foo"++) . ("bar"++). ("baz"++) $ ""
10:01:58 <lambdabot>  "foobarbaz"
10:02:02 <roconnor> chrisdone: see http://r6.ca/blog/20080716T131235Z.html
10:02:03 <lambdabot> Title: ICFP 2008 Post-Mortem
10:02:08 <quicksilver> sebaseba: those three () expressions are String -> String
10:02:11 <quicksilver> those are DLists
10:02:19 <quicksilver> it's faster to compose String -> String functions
10:02:22 <roconnor> chrisdone: follow the link "what I submitted"
10:02:23 <quicksilver> and then 'run it once' on ""
10:02:37 <quicksilver> than it is to ++ lots of strings
10:02:38 <roconnor> chrisdone: you need a zillion instances that I left out of my paste
10:03:10 <chrisdone> roconnor: oh, I see
10:04:05 <sebaseba> quicksilver: That sounds much better than show with lots of ++.
10:04:39 <vixey> > let toDlist l = (l++) ; fromDlist d = d [] in fromDlist (toDlist "foo" ++ toDlist "bar")
10:04:41 <lambdabot>  "foobar"
10:04:43 <vixey> sabaseba: ^
10:05:01 <roconnor> > showS 5 . showS true . shows (sin 4) ""
10:05:03 <lambdabot>   Not in scope: `true'
10:05:55 <Toxaris> imho the idea of a "DList" as a data type is confusing, it is easier to understand as a design pattern to be applied explictly.
10:06:30 <chrisdone> @hoogle Data.Number.Dif
10:06:30 <lambdabot> No matches, try a more general search
10:06:31 <roconnor> > showS 5 . showS True . showS (sin 4) $ ""
10:06:32 <lambdabot>   Not in scope: `showS'
10:06:36 <quicksilver> sebaseba: well it's rather orthogonal to whether you use show or not.
10:06:39 <roconnor> > shows 5 . shows True . shows (sin 4) $ ""
10:06:41 <lambdabot>  "5True-0.7568024953079282"
10:06:49 <quicksilver> sebaseba: show is just a way to go from Type -> String
10:06:55 <quicksilver> sebaseba: what you do after that is up to you ;)
10:07:01 <Toxaris> e.g., instead of writing showXxxx :: Xxxx -> String, write showsXxxx :: Xxxx -> String -> String with the property that showXxxx = showsXxxx ""
10:07:03 <quicksilver> but if you do go the (String -> String) way
10:07:04 <dons_> anyone around interested in this CSV parser discussion?
10:07:05 <roconnor> > shows 5 . (" "++) . shows True . (" "++) . shows (sin 4) $ ""
10:07:07 <lambdabot>  "5 True -0.7568024953079282"
10:07:17 <quicksilver> then it's helpful to know that 'shows' is the (string -> string) version of show
10:07:20 <quicksilver> as it were.
10:08:03 <Toxaris> since DLists vs. Strings is about operational behaviour, I think a high-level denotational-style discussion is not really helpful
10:08:11 <roconnor> http://hackage.haskell.org/packages/archive/numbers/2008.4.20/doc/html/Data-Number-Dif.html
10:08:23 <sebaseba> thanks for the help. I'll give it a try.
10:08:26 <lambdabot> Title: Data.Number.Dif, http://tinyurl.com/6epkpo
10:08:47 <Toxaris> roconnor: great rover approach! I had exactly the same idea, but much fuzzier, and I would have never expected that it could be so easy to implement
10:09:00 <chrisdone> dons: I am interested in it
10:09:06 <lilachaze> Toxaris: link? my rover sucked :)
10:09:11 <roconnor> Toxaris: thanks.  I think it worked well given my time constraints
10:09:18 <roconnor> Toxaris: I don't think I will come in last.
10:09:45 <chrisdone> roconnor: curious, any reason parsec is not used?
10:09:46 <roconnor> lilachaze: http://r6.ca/blog/20080716T131235Z.html
10:09:47 <lambdabot> Title: ICFP 2008 Post-Mortem
10:10:23 <roconnor> chrisdone: I was too lazy to learn parsec, esp given that parsing was straightforward
10:11:01 <chrisdone> roconnor: ah.
10:11:06 <lilachaze> roconnor: that's *really* cool :)
10:11:31 <roconnor> lilachaze: I remembered reading an article saying that the sims navigate this way
10:11:40 <roconnor> presumably more refined than what I have.
10:12:03 <lilachaze> i wasted all of sunday and monday on pathfinding algorithms which, in the end, i didn't get working in time :(
10:12:11 <Toxaris> lilachaze: link? to my rover? there isn't any. I have only a very basic solution, compute angle, steer left or right, accelerate always
10:12:29 * Codex_ didnt submit anything to the rover problem. (but learned erlang while trying to do it :-)
10:12:31 <roconnor> lilachaze: yeah, pathfinding is harder, but more effictive than what I have.
10:12:34 <Toxaris> I decided on sunday morning to give up and go to sleep instead :)
10:12:54 <roconnor> lilachaze: it was probably worth attempting
10:13:23 <misterbeebee> Is DList basically a way of converting left-associative (a ++ b ++ c) to a right-associative version (a ++ (b ++ x)) to avoid repeatedly forcing the (++) of the front of the list?
10:13:30 <dons> chrisdone: have you been following the discussion on reddit?
10:13:58 <Asgaroth> how do i get the third element in a triple?
10:14:00 <Toxaris> misterbeebee: yes
10:14:10 <chrisdone> dons: yessir. has he posted his sample data?
10:14:14 <Toxaris> Asgaroth: (\(x, y, z) -> z)
10:14:16 <lilachaze> Toxaris: I decided that about Sunday mid-day, when it became clear that dealing with a triangular tesselation was a complete pain in the [...REDACTED...]
10:14:22 <Asgaroth> Toxaris: thanks
10:14:30 <dons> not yet. but I think I'll start with a bytestring Double & Float parser
10:14:36 <dons> get that going first.
10:14:46 <roconnor> lilachaze: *L*
10:14:48 <dons> then a CSV parser for ByteStrings should't be too hard.
10:14:50 <mfp> chrisdone: this is what I've used to generate the data http://www.reddit.com/r/programming/info/6rz5m/comments/c04pr4s
10:14:50 <lambdabot> Title: programming: Followup: CSV Parsing in Haskell and Python
10:14:52 <Toxaris> Asgaroth: there is no predefined function to do that. you may consider using (a, (b, c)) or a user-defined data type instead
10:15:22 <chrisdone> mfp: ah, cheers
10:15:26 <Asgaroth> Toxaris: yes, but the triple is returned by a library function, so not an option in this case.
10:15:26 <Toxaris> Asgaroth: or case x of (_, _, x) -> use x here
10:15:53 <dons> mfp: yeah,i'm looking too.
10:16:19 <dons> this is just a stupidly easy thing, it should be knockdown, imo. if haskell's fast at *anything*, it's parsing
10:16:30 <mfp> chrisdone, dons: do you get something close to 0.6s with that?
10:16:34 <Toxaris> what CSV parsing stuff are you talking about?
10:16:55 <dons> was it dogbite's blog originally?
10:18:12 <dons> so I propose a couple of bytestring-based parser functions, similar to readInt in Bytestring.Char8, and then a Text.CSV.ByteString lib on top.
10:18:25 <mfp> dons: the sum-file solution is so fast because it doesn't perform line-oriented IO like most other solutions (so less GC load) and parses the int as it scans the bytes, right?
10:18:48 <dons> mfp: it does lazy IO, like the Clean entry. and it parses the Int without copying, yes.
10:19:05 <chrisdone> mfp: I don't know python; I get a parse error running “python generate.py” “invalid syntax near def randrow(ticker_num, year, mon, day) <-- here". should I run a specific python implementation?
10:19:17 <BONUS> you forgot a :
10:19:17 <mfp> chrisdone: ruby generate.rb :)
10:19:30 <BONUS> its
10:19:31 <chrisdone> mfp: hahaha. oh dear >_>
10:19:34 <BONUS> def name(a, b, c):
10:19:40 <dons> mfp: the main thing to take advantage of is parsing without copying out of a bytestring.
10:20:01 <dons> if we can't rely on zero-copying properties of pure structures, then hope is lost :)
10:20:52 <chrisdone> right
10:20:55 <dons> my general view is that there should be no python programs faster than haskell ones. if you see such a thing, then something's wrong. either a poor impl, or a library needs to be fixed or written.
10:21:07 <dons> the native code advantage is just that huge.
10:21:12 <chrisdone> that was my impression
10:21:31 <dons> so things like this csv thing are good for that -- as it points to some gaps in the libs
10:22:08 <mfp> Bytestring uses regular IO, right? /me wondering if a mmap-based BS-alike would be much faster at sum-file & such
10:22:18 <dons> there is also an mmap interface
10:22:22 <dons> sometimes it really helps
10:22:57 <dons> particularly when you don't need to touch all the data
10:23:15 <misterbeebee> so Dlist could be generalized by replacing (++) and (:) with mplus and return ?
10:23:26 <Toxaris> a parser combinator lib which creates Stream consumers would be great for this kind of problems
10:23:43 <vixey> > let toDlist l = (l++) ; fromDlist d = d [] in fromDlist (('e' :) . toDlist "foo" ++ toDlist "bar")
10:23:44 <lambdabot>  "efoobar"
10:24:01 <misterbeebee> er, mplus and (mplus. return)
10:24:02 <Toxaris> so you could write in parser combinator style, but get a fusable ByteString -> [YourDataHere] back
10:24:57 <Toxaris> misterbeebee: mconcat and mplus?
10:25:05 <Toxaris> misterbeebee: hmm. not. whatever.
10:26:56 <sclv_>  Isn't that parsec3?
10:28:06 <misterbeebee> > let toDlist l = (l `mappend`) ; fromDlist d = d mzero in fromDlist ((((mplus . return) 'e') . toDlist "foo") `mappend` toDlist "bar")
10:28:08 <lambdabot>  "efoobar"
10:28:08 <chrisdone> the python one gives me 0m17.503s and the haskell version with foreign calls gives me 0m9.154s
10:28:19 * chrisdone shrinks his dataset a bit
10:28:26 <misterbeebee> not sure if that's an improvement :)  mappend and mzero and mplus are hard to read in a line
10:29:14 <misterbeebee> (aha, figured how to turn off emoticons in colloquy (:)
10:29:23 <Toxaris> sclv_: I don't know. has a parsec3 parser the property that every char of the input stream is read exactly once?
10:30:16 <Toxaris> misterbeebee: why are you mixing MonadPlus stuff with Monoid stuff?
10:30:34 <vixey> o_o
10:30:38 <vixey> misterbeebee:
10:30:40 <vixey> > let toDlist l = (l++) ; fromDlist d = d [] in fromDlist (('e' :) . toDlist "foo" ++ toDlist "bar")
10:30:42 <lambdabot>  "efoobar"
10:30:47 <misterbeebee> because Monoid doesn't have > let toDlist l = (l `mappend`) ; fromDlist d = d mzero in fromDlist ((((mappend . return) 'e') . toDlist "foo") `mappend` toDlist "bar")
10:30:52 <vixey> use ++ to append
10:30:55 <misterbeebee> > let toDlist l = (l `mappend`) ; fromDlist d = d mzero in fromDlist ((((mplus . return) 'e') . toDlist "foo") `mappend` toDlist "bar")
10:30:57 <lambdabot>  "efoobar"
10:31:00 <vixey> ugh
10:31:03 <misterbeebee> (++) is specific to List.
10:31:07 <vixey> no it's not
10:31:08 <misterbeebee> mappend works in any monoid
10:31:10 <misterbeebee> it's not?
10:31:10 <mfp> chrisdone: any idea regarding why it's so far from 0.6s?
10:31:11 <misterbeebee> oh
10:31:12 <vixey> no
10:31:16 <misterbeebee> d'ph
10:31:19 <vixey> ++ is an operator you can use it for anything you like
10:31:26 <vixey> (++) = mappend -- is perfectly valid haskell
10:33:06 <sclv_> Toxaris: I think so, I just browsed the source again to check...
10:33:08 <misterbeebee> oh, you are suggesting I define (++) = mappend, to make it look nicer?
10:33:27 <sclv_> There is the backtracking issue however...
10:33:32 <misterbeebee> (++) = mappend -- is not in the Prelude or standard libraries, so far as I can see
10:33:40 <vixey> I give up
10:33:51 <misterbeebee> sorry, I'm not understanding. I'm tryinh
10:34:07 <misterbeebee> > mappend Nothing (Just "blah")
10:34:09 <lambdabot>  Just "blah"
10:34:10 <sclv_> I don't know how that's actually implemented... but the basic stream type that parsec operates over only has one operation -- uncons.
10:34:17 <misterbeebee> > (++) Nothing (Just "blah")
10:34:19 <lambdabot>  Just "blah"
10:34:27 <misterbeebee> whoa. that's not what my ghci said
10:34:41 <sclv_> caleskill strikes again!
10:34:54 <sclv_> misterbeebee: lambdabot has a few functions more polymorphic than you normally get.
10:35:04 <misterbeebee> ohhh
10:35:08 * Toxaris looks at parsec3
10:35:16 <misterbeebee> i'll apologize to vixey late
10:35:18 <misterbeebee> r
10:35:58 <Toxaris> is there a url on hackage which is suitable for a quicksearch, e.g. hackage.haskell.org/findPackage=%s or similiar?
10:36:14 <dons> there's a search facility, yes.
10:36:22 <dons> but its a google site search
10:36:44 <Toxaris> ohh just realized that http://hackage.haskell.org/cgi-bin/hackage-scripts/package/parsec points to the latest version of parsec, so thats what I want
10:36:49 <misterbeebee> @src (++)
10:36:50 <lambdabot> []     ++ ys = ys
10:36:50 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
10:36:50 <lambdabot> -- OR
10:36:50 <lambdabot> xs ++ ys = foldr (:) ys xs
10:36:50 <lambdabot> -- In lambdabot, this is generalised to:
10:36:52 <lambdabot> (++) = mappend
10:36:55 <lambdabot> Title: HackageDB: parsec-3.0.0
10:37:09 <chrisdone> Toxaris: maybe cabal-install should have one
10:37:15 <misterbeebee> ohhh.... is there a library I can import to get lambdabot's definitions? It's not in hoogle, i don't think
10:38:08 <lilachaze> Toxaris: one thing which i find has not been made anywhere near clear enough is that Text.ParserCombinators.Parsec is Parsec2 (even if Parsec3 is installed), whereas Text.Parsec is Parsec3.
10:39:17 <Toxaris> lilachaze: I realized that Parsec3 still supports Parsec2
10:39:35 <BMeph> misterbeebee: Better luck downloading Cale's brain... ;)
10:39:46 <Toxaris> chrisdone: should have what?
10:40:14 <lilachaze> quicksearch?
10:40:34 <chrisdone> something like apt-get's search.
10:40:40 <Toxaris> well, I mean these firefox things where you enter "keyword searchstring" into the adress bar and it gets expanded to some url
10:40:50 <chrisdone> ah, yeah. an “engine”
10:40:54 <Toxaris> not a really search, but more like a shortcut when i already know what i want
10:40:58 <sclv_> Hmm... so parsec3 and "try" is the same as parsec 2 I think. If you fail in a try, the entire previous state of the stream is kept around to backtrack to -- i.e. there isn't a "buffer" of unconsed tokens that's restored...
10:41:12 <chrisdone> I use one of those for Hoogle, as I'm sure you do. very handy
10:41:25 <sclv_> Parser optimization isn't my speciality though... and parsec3 as I recall hasn't really been tuned yet.
10:41:41 <Toxaris> chrisdone: no an engine is more complex to configure, the quicksearch can be configured by users. you just enter the properties of a bookmark to include "%s" into the url and add a keyword.
10:42:42 <lilachaze> it strikes me that it'd be pretty easy to implement a table-based form of something parsec-like (requiring the stream element to be in Ord)
10:42:54 <lilachaze> by "pretty easy" i mean very hard, of course :)
10:43:29 <chrisdone> Toxaris: ohh, yeah. I have made those before, yes, sorry
10:44:06 * lilachaze wonders whether you could generate the tables at compile-time with a bit of TH
10:45:24 <sjanssen> lilachaze: I think the use of monads prohibits that sort of static analysis
10:46:48 <schme> hello #haskell
10:47:11 <lilachaze> sjanssen: that's a pity if it's true. i'm not sure i see why it would be true, though
10:48:11 <lilachaze> hmm, if anything, i think referential transparency is the killer
10:48:16 <misterbeebee> Parsec3's main feature over Parsec 2 is ByteString support?
10:49:02 <Cale> misterbeebee: Plus the fact that it's a monad transformer.
10:49:22 <chrisdone> so you can do stuff as you're parsing?
10:49:29 <misterbeebee> awesome
10:49:29 <lilachaze> can't you do bytestrings in parsec2 with a lazy bytestring->list conversion?
10:49:43 <sclv_> It can work over any sort of token and yeah, any monad.
10:49:44 <chrisdone> yeah but conversion is expensive, no?
10:49:55 <lilachaze> you're pulling the elements out anyway
10:50:18 <chrisdone> I think the point of ByteString is that you don't convert, you use it all the way through
10:50:19 <Toxaris> lilachaze: but I don't want to create a list.
10:50:45 <Toxaris> lilachaze: I want to go from ByteString to double, never seeing [Char]
10:50:45 <lilachaze> Toxaris: the list should get optimized away if you don't use 'try'
10:51:18 <Toxaris> lilachaze: really? that would be great! how sure are you about that?
10:52:49 <lilachaze> about 40%. :) if your bytestring -> list conversion is suitably lazy, then there'll never be any need for more than one list element to exist. so i guess the list will get created, but it'll be a candidate for garbage collection right away.
10:56:49 <slarba> about the test data: for the 600 millisecond result I used way too few distinct tickers...
10:59:29 <slarba> with 500 distinct tickers and 160k rows, the difference is 7.5sec haskell vs 10.2sec python
10:59:29 <dons> slarba: hehe
10:59:36 <slarba> that's still better
10:59:43 <dons> slarba: could you post your canonical data somewhere?
10:59:55 <dons> i think we can do much much better here.
11:00:11 <slarba> dons: well you can use the ruby generator. just change the modulus 500 to something else
11:00:12 <dons> since sum-file can process 50Mb files in fractions of a second, we can surely do more
11:00:19 <dons> slarba: ok.
11:00:47 <dons> not splitting the file into lots of tiny bytestrings will be one big win
11:01:00 <dons> we want to just continuously stream Doubles off the data, into rows.
11:01:09 <dons> avoiding ForeignPtr costs for substrings.
11:01:16 <chrisdone> I think the problem here is making the haskell code idiomatic, like the python code is
11:01:16 <slarba> true.
11:01:43 <slarba> chrisdone: well, the optimized implementation is not that different from the python one
11:01:47 <dons> chrisdone: what would that require? just a library?
11:01:49 <slarba> it's just different
11:02:03 <slarba> every language has its idiomatic ways to do things
11:02:46 <slarba> I'm not saying that my example is good, it's basically a little refactored and optimized version of the original author's version
11:02:54 <slarba> there must be a better way to do it
11:03:12 <chrisdone> well, it's different from the start because you might be writing code to beat python as opposed to haskell code as you usually would. seems like apples and oranges in some ways
11:04:26 <dons> so what would the idiomatic haskell look like?
11:04:34 <chrisdone> I don't know
11:04:41 <dons> import Text.CSV.ByteString ; main = parseCSV =<< readFile "f"
11:04:48 <dons> ?
11:06:07 * schme is more intrigued by how idiomatic lisp looks ;)
11:06:22 <opqdonut> ((((((((())))))))))
11:06:35 <schme> (:
11:06:41 <slarba> hehe
11:06:49 <chrisdone> never gets old
11:07:06 <opqdonut> (except the parens would match)
11:07:16 <schme> yeah. just blame the parens.
11:07:40 <sclv_> slarba: yeah, you can use a single traversal and no sorting...
11:08:02 <dons> yeah, that's what I'd expect sclv_
11:08:12 <dons> one pass, pull Doubles straight off the input buffer
11:08:16 <dons> no copying.
11:08:58 <dons> really, we should be building a huge set of parser libraries
11:09:05 <dons> that's something haskell can be really good at.
11:09:21 <schme> dons: Why is haskell so good for parsing?
11:09:35 <dons> parser combinator libraries
11:09:37 <EvilTerran> partial application, laziness, monads...
11:09:41 <dons> so we can roll new parsers really quickly.
11:09:42 <sclv_> and algebraic data types!
11:09:47 <dons> and that.
11:09:48 <sclv_> so we have nice things to parse into.
11:09:50 <EvilTerran> indeed, algebraic data types
11:09:51 <FordCortina> @src <*>
11:09:51 <lambdabot> Source not found. Maybe if you used more than just two fingers...
11:10:01 <schme> @src dons
11:10:02 <lambdabot> Source not found. Sorry.
11:10:04 <schme> :(
11:10:06 <dons> so in the long term, i'd expect all that productivity should pay off with more libraries for parsing
11:10:22 <FordCortina> @src Control.Applicative.(<*>)
11:10:22 <lambdabot> Source not found. You untyped fool!
11:10:22 <EvilTerran> with a GADT at least, you could derive a significant chunk of the parser structure from the type definition alone
11:10:29 <schme> I was hoping to find the source for dons, so I wouldn't have to learn stuff meself. Oh well :)
11:10:31 <EvilTerran> FordCortina, it's a class method, it varies depending on the type
11:10:41 <EvilTerran> ?src [] (<*>)
11:10:41 <lambdabot> (<*>) = ap
11:10:46 <FordCortina> oh yeh oops
11:10:48 <dons> well, it doesn't even have to be fancy. just a parser combinator based parser, an ADT for the syntax, and a pretty printer.
11:10:48 <EvilTerran> ?src ZipList (<*>)
11:10:49 <lambdabot> Source not found. You speak an infinite deal of nothing
11:10:51 <EvilTerran> ...
11:10:57 <sclv_> I think the problem is that 90% of the time we're really happy enough with, e.g., unpacking bytestrings into strings and then reading doubles out of them.
11:11:03 <EvilTerran> ?src Maybe (<*>)
11:11:04 <lambdabot> (<*>) = ap
11:11:07 <EvilTerran> saw that coming =/
11:11:25 * EvilTerran would suggest updating the ?src database with non-Monad-based definitions for <*> where possible
11:11:27 <sclv_> So there's not the same urge to push forward with lots of the bytestring based stuff...
11:11:31 <EvilTerran> ?src Maybe fmap
11:11:31 <lambdabot> fmap _ Nothing       = Nothing
11:11:31 <lambdabot> fmap f (Just a)      = Just (f a)
11:11:53 <EvilTerran> much like fmap - it's not like it's got "fmap = liftM" for every Monad
11:12:00 <dons> schme: yes.
11:12:02 <dons> sclv_: ^
11:12:33 <sclv_> So we have good core libs based on strings and then things like network-bytestring, http-bytestring, etc... that all are one-offs without enough momentum...
11:13:14 <dons> a definitive, clearly faster, parser lib for bytestrings would help.
11:13:46 <sclv_> I thought the plan was to treat parsec3 as that and then optimize later...?
11:13:53 <EvilTerran> something for next year's SoC project, perhaps?
11:13:57 <EvilTerran> *projects
11:14:00 <chadz> hey -- what it packages.conf to modify to add extra lib/include dirs for all compilations?
11:14:02 <chrisdone> I intend on making a ByteString version of GD's drawString and measureString functions... should I make it Graphics.GD.ByteString, or drawStringBS, or what?
11:14:06 <jsnx> dons: i think the problem is more sophisticated than that
11:14:19 <dons> jsnx: than just what?
11:14:28 <jsnx> parsing bytestrings fast is of no use for CSV
11:14:29 <EvilTerran> chrisdone, i'd go for the former - if people want something like the latter, they can import qualified
11:14:35 <jsnx> you need to parse character strings
11:14:46 <slarba> ?
11:14:46 <jsnx> we need fast unicode strings of some kind
11:14:56 <dons> encoding is a separate issue.
11:15:10 <EvilTerran> parsing of binary data is also useful
11:15:17 <chrisdone> EvilTerran: okay
11:15:24 <jsnx> dons: but if the parser is a "byte parser" it's mode of operation would not be compatible with chars
11:15:33 <EvilTerran> and much easier with parser combinators than piles of regexes
11:15:34 <chrisdone> is it a good idea to have both a lazy and strict ByteString version?
11:15:40 <dons> jsnx: hmm, ascii Chars.
11:15:45 <sclv_> jsnx: parsec, e.g., can be parameterized over any token at all...
11:15:57 <EvilTerran> sclv_, but not any stream type as yet
11:16:08 <jsnx> sclv_: yeah, but parsec is not a byte parser
11:16:08 <chrisdone> I've noticed Network.CGI's ByteString output (outputFPS) is lazy only
11:16:22 <EvilTerran> jsnx, in general, we need better unicode support
11:16:25 <sclv_> EvilTerran: what's the story with that exactly?
11:16:32 <jsnx> well, we actually have great unicode support
11:16:33 <dons> utf8-string has a great bytestring encoder/decoer
11:16:38 <jsnx> dons: yes
11:16:46 <dons> we use it for web apps all the time.
11:17:01 <jsnx> dons: i wrote my chinese dictionary thing with it
11:17:01 <chadz> (rephrased), i need to make ghc aware of my off-location lgmp install for xmonad, and other things. i lost my previous hack that did this along with the harddrive, and afaik, it was packages.conf i once edited. i tried editing the ghc package to no avail
11:17:04 <EvilTerran> is utf8-string going to be bundled with ghc?
11:17:16 <chrisdone> oh, crap
11:17:23 <dons> EvilTerran: it'll be part of the 'haskell platform'
11:17:26 <EvilTerran> sclv_, what do you mean?
11:17:28 <chrisdone> ghci 6.8.3 supports unicode? ZOMG!!!11
11:17:46 <chrisdone> ^_________^
11:17:55 <sclv_> EvilTerran: when you said that parsec can't be parameterized over any stream type, what do you mean exactly?
11:18:03 <dons> chadz: you edit the ldOptions line
11:18:10 <jsnx> EvilTerran: http://haskell.org/haskellwiki/Haskell_Platform
11:18:11 <dons> to include "-L/usr/local/lib" et al.
11:18:21 <lambdabot> Title: Haskell Platform - HaskellWiki
11:18:25 <jsnx> chrisdone: they all support it
11:18:36 <jsnx> [Char] is a word
11:18:38 <chrisdone> jsnx: 6.8.2. would mess up when I typed unicode in it
11:18:40 <EvilTerran> sclv_, as in, (GenParser tok st) works over [tok], not (Stream s => s tok) or whatever
11:18:44 <jsnx> or i mean Char
11:18:58 <jsnx> chrisdone: you mean, when you type UTF8
11:19:04 <EvilTerran> jsnx, oh, that looks good to have
11:19:07 <chrisdone> jsnx: yeah
11:19:15 <chadz> dons: ah, for pkgName "ghc"?
11:19:17 <EvilTerran> better definition of a standard than "whatever ghc's bundling this month"
11:19:18 <jsnx> there is not support for encoding unicode
11:19:29 <jsnx> just storing/manipulating it
11:19:31 <chrisdone> UTF8 is a kind of unicode
11:19:38 <chrisdone> O_o?
11:19:39 <jsnx> well, no
11:19:45 <jsnx> UTF8 is a unicode encoding
11:19:55 <chrisdone> uh huh
11:20:01 <jsnx> the distinction is a little narrow
11:20:04 <jsnx> but look at C
11:20:12 <jsnx> what is a char? it is a byte
11:20:29 <jsnx> can you store unicode characters in it? no -- there are too many
11:20:34 <jsnx> so you have to have a new type
11:20:35 <misterbeebee> http://haskell.org/haskellwiki/Haskell_Platform <- this page is missing a section "next steps" - what people should do to contribute to the effort
11:20:36 <lambdabot> Title: Haskell Platform - HaskellWiki
11:20:36 <jsnx> w_char
11:20:55 <chrisdone> so?
11:21:13 <jsnx> chrisdone: whereas in Haskell, the Char type is large enough to hold all valid unicode
11:21:22 <chrisdone> jsnx: yes.
11:21:29 <sclv_> EvilTerran: even in parsec3? hmm...
11:21:33 <jsnx> so if you start processing unicode, you don't have to change the type signatures all over your program
11:21:35 <EvilTerran> and we have a new type - Word8 - for when we explicitly want octets
11:21:46 <EvilTerran> sclv_, i'm not sure, i haven't really been keeping track of parsec4
11:21:49 <EvilTerran> er, parsec3
11:21:51 <jsnx> however, there is no direct support for utf8
11:22:05 <jsnx> which is a byte grammar
11:22:11 <jsnx> essentially
11:22:29 <chrisdone> consider a comma
11:22:35 <jsnx> yes
11:22:37 <jsnx> considering
11:22:59 <jsnx> okay...done
11:23:53 <jsnx> dons: basically, i think String should be a parameterized by it's encoding
11:24:05 <jsnx> String UTF8, String ASCII, &c.
11:24:45 <EvilTerran> that seems... painful
11:24:57 <EvilTerran> not very good encapsulation
11:25:01 <jsnx> differently encoded strings have different implementations of Traversable and Foldable
11:25:06 <jsnx> EvilTerran: well, how not?
11:25:24 <EvilTerran> i quite like the Stream abstraction for that
11:25:34 <jsnx> but where is the encoding in that?
11:26:03 <EvilTerran> i don't see the need, particularly, to express the encoding in the type
11:26:27 <jsnx> well, the need lay in having different implementations of the enumerators
11:26:56 <jsnx> unless you want to have foldUTF8, foldASCII, &c. for ByteStrings
11:27:15 <EvilTerran> maybe a newtype wrapper around ByteString?
11:27:31 <jsnx> well, yes
11:27:36 <EvilTerran> ByteString is a stream of bytes, any matter of encoding isn't relevant to it
11:27:37 <jsnx> that's what i imagines
11:27:45 <jsnx> you take a bytestring
11:27:46 <EvilTerran> that should go on in another layer
11:27:54 <jsnx> and you wrap it in a String UTF8
11:28:09 <jsnx> and then you fold/map to your heart's content
11:28:23 <EvilTerran> so you're having a phantom type parameter, then?
11:28:38 <jsnx> yes
11:28:39 <EvilTerran> newtype EncodedBS a = EncodedBS ByteString
11:28:42 <EvilTerran> or whathaveyou
11:29:07 <jsnx> well, String still has some properties that are special to it
11:29:12 <jsnx> that are shared by all strings
11:29:18 <jsnx> namely, that they are made of Chars
11:29:25 <jsnx> and can be regexerixed
11:29:29 <jsnx> stuff like that
11:29:37 <EvilTerran> well, that can be expressed through the Stream interface
11:30:22 <jsnx> the operations i'm discussing are peculiar to strings
11:30:51 <EvilTerran> aka, peculiar to streams of Chars
11:31:00 <jsnx> well, yes
11:31:03 <jsnx> i see
11:31:28 <jsnx> so you would say, Stream Char is in Regexable or whatever
11:31:30 <jsnx> great
11:31:58 <jsnx> so then we would not have Strings ?
11:32:09 <jsnx> or String = Stream Char i guess
11:32:39 <EvilTerran> eliminating String = [Char] altogether seems a tad heavy-handed
11:32:56 <jsnx> well, keeping it would be silly
11:33:06 <sjanssen> String is the only decent string type we have!
11:33:09 <EvilTerran> i was thinking more "instance Stream s => Regexable (s Char)" or whatever the Stream interface is about
11:33:15 <jsnx> because we want to steer people away from it
11:33:20 <sjanssen> jsnx: WHY?!
11:33:31 <jsnx> sjanssen: it is slow and embarasses us on reddit
11:33:42 <sjanssen> it is also correct and elegant
11:33:44 <jsnx> sjanssen: it is also stupid
11:33:49 <EvilTerran> jsnx, NO U
11:33:51 <jsnx> sjanssen: no, it is not
11:33:56 <EvilTerran> if you're gonna resort to name-calling :P
11:33:56 <jsnx> it is incorrect
11:34:22 <sjanssen> jsnx: name other String types in common use that can handle the Unicode range
11:34:33 <EvilTerran> "it's stupid" isn't an argument, it's a conclusion (of dubious validity)
11:34:33 <jsnx> String = RegexableThingyWithUpperLowerAndOtherOpsNotSharedByLists
11:34:45 <jsnx> sjanssen: [Word32]
11:34:59 <jsnx> sjanssen: the problem isn't that it can't handle unicode
11:34:59 <EvilTerran> "in common use"
11:35:15 <jsnx> the problem is that it does not carry enough semantic information
11:35:25 <sjanssen> jsnx: that represents more than the Unicode range, isn't in common use, and I can't write Word32s as character literals
11:35:37 <jsnx> also, we should be able to make ByteStrings full of unicode act like strings
11:35:46 <sjanssen> "should", but we haven't yet
11:35:47 <EvilTerran> it carries semantic information - "this is a list of (unicode) characters"
11:35:58 <jsnx> EvilTerran: but that is not what a string really is
11:36:06 <EvilTerran> the problem is that things like the Prelude IO functions don't follow this semantic information
11:36:09 <jsnx> okay, it isn't stupid
11:36:17 <jsnx> i was overstating my case
11:36:24 <EvilTerran> or, they do, but only insofar as you assume 8-bit ASCII
11:37:06 <jsnx> strings should be foldable, but they should not actually be lists
11:37:19 <jsnx> i can think of only a few cases where pattern matching on strings was helpful
11:37:26 <sjanssen> jsnx: why shouldn't they be lists?  Are you speaking purely from an efficiency standpoint?
11:37:34 <jsnx> sjanssen: yes
11:37:41 <jsnx> sjanssen: and isn't that important with strings?
11:37:55 <opqdonut> well pretty much depends on what one's doing
11:38:05 <jsnx> i'd like to script in haskell some day
11:38:18 <EvilTerran> efficiency is an implementation detail
11:38:23 <EvilTerran> scripting languages are never fast :P
11:38:32 <jsnx> EvilTerran: in this case, we have just made the wrong decision
11:38:37 <EvilTerran> says you
11:39:18 <olsner> just make String viewable as [Char] and let the implementation decide what a string actually is?
11:39:35 <jsnx> EvilTerran: they are faster than haskell http://techguyinmidtown.com/2008/07/15/followup-csv-parsing-in-haskell-and-python/
11:39:38 <lambdabot> Title: Followup: CSV Parsing in Haskell and Python  tech guy in midtown, http://tinyurl.com/6fev5b
11:39:45 <EvilTerran> [Char] is easier to work with for most purposes. it has cleaner semantics and complexities than, say, ByteString, even if they're not faster in general
11:39:47 <jsnx> olsner: no, don't make if viewable as [Char]
11:39:52 <jsnx> olsner: make it foldable
11:40:03 <EvilTerran> if [Char] is too slow, *then* you switch to something else
11:40:08 <jsnx> and enforce it's representation as UTF8
11:40:16 <sjanssen> jsnx: folds can't express all the things we want to do with strings
11:40:19 <EvilTerran> but, for most circumstances, [Char] is a good start, IMO
11:40:23 <jsnx> sjanssen: right
11:40:29 <jsnx> so it should be other things, as well
11:40:33 <sjanssen> jsnx: try to write 'takeWhile' on any Foldable
11:40:51 <jsnx> sjanssen: there is traversable, right?
11:41:11 <sjanssen> jsnx: also, it isn't possible to use Foldable on any ByteString derived structures
11:41:19 <jsnx> sjanssen: why not?
11:41:55 <sjanssen> jsnx: a Foldable type can contain all types, ByteString can only contain Word8's (or types that can be changed into Word8)
11:42:14 <jsnx> well, shoot
11:42:19 <jsnx> we can has problem
11:42:20 <sjanssen> jsnx: see the well known Set/Monad issue for more information
11:42:24 <EvilTerran> ... is hpaste.org broken?
11:42:41 <sjanssen> EvilTerran: works for me
11:43:47 <jsnx> well, we can use a phantom type
11:43:53 <EvilTerran> http://downforeveryoneorjustme.com/hpaste.org <- looks down from here, too
11:43:53 <sjanssen> nope
11:44:04 <jsnx> and it wouldn't be ByteStrings that are foldable
11:44:10 <jsnx> sjanssen: no?
11:44:11 <sjanssen> jsnx: it is hard to explain why that won't work, but it just won't work
11:44:28 <jsnx> okay, can you link me to the discussion?
11:44:38 <jsnx> i'd like to know more
11:45:20 <sjanssen> jsnx: I don't know if this has been discussed publically, but I've tried
11:46:11 <sjanssen> so you recommend a phantom type -- this means that all the class methods are working on that phantom, not the actual bytes in the string
11:47:32 <jsnx> sjanssen: well, hold on
11:47:42 <jsnx> so we have Foldable String encoding
11:47:48 <sclv_> I think that String is great, if we had slightly better prelude functions supporting it...
11:48:04 <sjanssen> jsnx: we don't have Foldable String, we have Foldable []
11:48:18 <sjanssen> sclv_: what is missing?
11:48:27 <jsnx> String is now going to take a phantom type
11:48:36 <jsnx> `Foldable String encoding`
11:48:46 <sjanssen> okay, then we have 'Foldable String'
11:48:55 <jsnx> right, got it
11:49:26 <sclv_> I mean 95% of the time its plenty fast, especially if you're doing lots of listy things to it (i.e. reversing it, etc.) and the other 5% where you want high performance then you can drill down and think about bytes.. big deal.
11:49:30 <jsnx> so there is a way to vary the implementation of fold and friends based on the phantom type?
11:50:09 <sclv_> sjanssen: the utf-8 read/write stuff mainly.
11:50:13 <jsnx> i assume that there is
11:50:59 <sjanssen> see, I think the functions in the Haskell '98 spec are fine for basic use.  The problem is the implementation in GHC
11:50:59 <jsnx> oh, goodness
11:50:59 <Saizan_> ?type foldMap
11:51:00 <lambdabot> Not in scope: `foldMap'
11:51:07 <sjanssen> jsnx: no, there isn't.  See parametricity
11:51:38 <sclv_> ?ty Data.foldable.fold
11:51:40 <EvilTerran> ?hoogle foldMap
11:51:40 <lambdabot> Couldn't find qualified module.
11:51:40 <lambdabot> Data.Foldable.foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
11:51:40 <lambdabot> Data.Traversable.foldMapDefault :: (Traversable t, Monoid m) => (a -> m) -> t a -> m
11:51:47 <sclv_> ?ty Data.Foldable.fold
11:51:49 <lambdabot> forall (t :: * -> *) m. (Monoid m, Data.Foldable.Foldable t) => t m -> m
11:51:53 <jsnx> sjanssen: "see parametricity" where?
11:52:05 <sclv_> there we go -- how are you going to fold t m -> m when m is a phantom type!?
11:52:29 <jsnx> right, yes
11:52:34 <jsnx> i am surprised, indeed
11:52:35 <sclv_> sjanssen: ah, you mean that you think that the report spec would let readFile and such play better with unicode?
11:53:43 <sjanssen> sclv_: yes, I think the report allows (and encourages) such an implementation
11:54:03 <jsnx> oh, that is annoying, Traversable is the same way
11:54:19 <EvilTerran> i don't think the report specifies what encoding readFile and friends should use
11:54:24 <jsnx> so why is it done that way?
11:54:34 <sjanssen> in an ideal world, all of the Prelude IO functions would use the user's locale to encode text
11:54:40 <EvilTerran> jsnx, because it makes sense in the vast majority of cases
11:54:48 <EvilTerran> just like using [Char] for strings does
11:54:53 <jsnx> sjanssen: that would be bad, actually
11:54:53 <sjanssen> jsnx: any other approach requires MPTCs+fundeps (or associated types)
11:55:05 <sclv_> sjanssen: have you filed a bug report against ghc?
11:55:09 <jsnx> sjanssen: you want to be able to specify the encoding
11:55:25 <sjanssen> and we'd also have some new functions for System.IO to modify the encoding of certain Handles
11:55:28 <sjanssen> sclv_: there is a bug
11:55:50 <sclv_> good to know.
11:55:50 <jsnx> ah, well, you could shove the encoding on to the handles, i guess
11:56:12 <jsnx> MPTC is what?
11:56:20 <Toxaris> MultiParameterTypeClasses
11:57:07 <sjanssen> jsnx: I think it is best to leave encoding in the Handle, it is just too annoying to pass it to each IO function
11:57:22 <jsnx> sjanssen: well, that was not my suggestion
11:57:53 <jsnx> but it looks like my idea is not compatible with the present definition of Foldable, Traversible, &al.
11:58:35 <sjanssen> jsnx: you wanted to put the encoding in the String type?  I think this is silly
11:58:48 <jsnx> sjanssen: why is it silly?
11:58:54 <Toxaris> jsnx: encoding is unrelated to strings in memory, it is only related to strings on my hard disk
11:59:08 <sjanssen> jsnx: what Toxaris said :)
11:59:28 <jsnx> if strings are backed with ByteStrings, then it is relevant
11:59:29 <Toxaris> Haskell is a high-level language, so I want <stream of unicode code points> as string type
11:59:39 <sjanssen> jsnx: also, I want to manipulate Strings as an abstract sequence of characters, I don't care about the in-memory format
11:59:54 <jsnx> sjanssen: fine well and good
11:59:57 <sjanssen> jsnx: it is relevant to whomever writes the library
12:00:17 <Toxaris> jsnx: it is important on the value level, but not on the type level
12:00:22 <sjanssen> that person should evaluate the options, and just pick one, then provide us with an abstract interface
12:00:59 <jsnx> Toxaris: i do not think you should be able append String UTF8 to String ASCII without a cast
12:01:16 <sjanssen> jsnx: I don't think there should be such a thing as String UTF8
12:01:41 <Toxaris> jsnx: why not?
12:01:54 <jsnx> it is abominable that simple ASCII grows in size four times when I load it into Haskell
12:02:11 <Toxaris> why?
12:02:15 <ndmitchell> jsnx: its no where near that low - have you ever actually measured it?
12:02:25 <sjanssen> also, phantom types are going to cause trickiness when the encoding is selected dynamically (such as in an HTTP server, text editor, XML parser, the list goes on)
12:02:37 <jsnx> ndmitchell: there is overhead due to the list representation, sure
12:02:48 <sjanssen> jsnx: UTF-8, learn it :)
12:02:54 <ndmitchell> jsnx: yes, which is the vast majority of overhead, the overhead of char's doesn't actually happen
12:02:54 <Toxaris> jsnx: more importantly, nothing would have to grow to allow String (internally as UTF8) ++ String (internally as ASCII)!
12:03:05 <jsnx> ndmitchell: but even if it were gone, there'd still be bloat due to the representation as Word32
12:03:13 <Toxaris> jsnx: consider data String = UTF8 ByteString | ASCII ByteString
12:03:18 <jsnx> Toxaris: you shouldn't be doing that
12:03:26 <ndmitchell> jsnx: its represented as pointers to characters because its unboxed, there is actually no cost from having Word32
12:03:34 <jsnx> ?
12:03:40 <ndmitchell> jsnx: GHC has a cache of all the ASCII characters, so never creates them
12:03:58 <ndmitchell> or rather, only creates one copy of 'a' ever
12:04:00 <jsnx> okay, but then you leave ASCII and boom
12:04:09 <jsnx> and pointers are Word32
12:04:09 <Toxaris> jsnx: now (UTF8 a) ++ (ASCII b) = UTF8 (a `BS.append` asciiToUtf8 b)
12:04:12 <sjanssen> (and even if it were Word8, all data is padded to the size of an Int anyway)
12:04:13 <ndmitchell> no, then you leave ASCII and pay for exactly what you use
12:04:34 <ndmitchell> yes, the pointers are Word32, but that's laziness hitting you, not UTF8/UCS4/ASCII issues
12:04:39 <Toxaris> jsnx: since ASCII is efficiently encodable in UTF8, you have to pay a runtime overhead if your representations don't match, but no memory overhead, and everything works as expected
12:05:01 <ndmitchell> the whole UCS4/ASCII thing is entirely irrelevant in GHC :)
12:05:01 <jsnx> Toxaris: but BIG5 is not encodable in UTF8
12:05:12 <jsnx> ndmitchell: hmm
12:05:17 <ndmitchell> a [Char] in GHC takes up less than [Word8]
12:05:34 <ndmitchell> i.e. if you flip to Word8, you _will_ pay a memory use penalty
12:05:45 <Toxaris> jsnx: so what? (BIG5 x ++ UTF8 y) = WhatEver (big5ToWhatEver x `BS.append` utf8ToWhatEver)
12:05:48 <jsnx> ndmitchell: but what about ByteString ?
12:06:04 <ndmitchell> jsnx: that's not [Word8], that's entirely different, and non-inductive
12:06:10 <jsnx> Toxaris: but actually, i like your idea
12:06:13 <sjanssen> jsnx: if BIG5 isn't representable by Unicode, then Haskell can't handle it anyway
12:06:13 <sclv_> oh hey, some digging on the ghc trac reveals that unicode text io support is scheduled for 6.10. yay
12:06:14 <Toxaris> jsnx: clearly, that is not the most clever implementation, but you get the idea
12:06:23 * sclv_ now vaguely remembers that whole discussion.
12:06:26 <jsnx> String = UTF8 ... | ASCII ... | BIG5 ...
12:06:56 <Toxaris> jsnx: statically it is a <stream of codepoints>, but dynamically it knows how it is encoded
12:07:11 <jsnx> ndmitchell: my understanding of [Char] was incorrect
12:07:19 <jsnx> ndmitchell: thank you for explaining
12:07:25 <ndmitchell> its very subtle :)
12:07:26 <Toxaris> jsnx: so if everything goes well, you never have to change the encoding (or you only reencode short strings, and leave the long ones as they are), but if you want, you get transparent reencoding for free
12:07:41 <jsnx> Toxaris: sure
12:07:48 <jsnx> Toxaris: i can live with that
12:07:53 <ndmitchell> once you have got rid of laziness, using unboxed items, then the cost of Word8 vs Word32 starts to matter, but not until after that
12:07:54 <jsnx> it's also Foldable
12:09:00 <sjanssen> ndmitchell: it doesn't actually matter, since in GHC Word8 = Word
12:09:01 <jsnx> ndmitchell: i am really arguing against the `[]` in `[Char]`, not the `Char`
12:09:16 <Toxaris> a more clever implementation would capture "knows how it is encoded" in a record of functions, and use data ByteStringBackedStream a = BSBS (RecordOfFunctions a) ByteString
12:09:50 <sjanssen> I still don't understand why we want to pack the encoding in the String
12:09:54 <Toxaris> so that you could make it work for every type a if you provide a RecordOfFunctions, not just a = Char
12:10:00 <sjanssen> this just seems like added complexity to me
12:10:09 <jsnx> sjanssen: so that you can read in raw bytes and just leave them there
12:10:20 <ndmitchell> sjanssen: really?
12:10:42 * ndmitchell just assumed Word8 was real...
12:11:01 <Toxaris> sjanssen: so that fusion can reduce whatever-stream-operations into ByteString-operations by fusing the processing with the encode-decode operations
12:11:20 <jsnx> sjanssen: that Toxaris said
12:11:21 <Toxaris> at least that's my idea, I'm not sure I understand jsnx ideas
12:11:35 <Toxaris> hehe seems I do :)
12:12:05 <jsnx> i personally think also, that String is not a []
12:12:33 <jsnx> i almost never pattern match on the things
12:12:37 <sjanssen> ndmitchell: data Word8 = GHC.Word.W8# GHC.Prim.Word# -- Defined in GHC.Word
12:12:47 <Toxaris> so in the end, you get a single tail-recursive function which reads the ByteString Byte by Byte and produces output Byte by Byte and is incredibely complicated and much better as everything the c geeks could ever write by hand, but exactly what they would like to write by hand
12:13:17 <ndmitchell> sjanssen: fair enough, thinking about it it makes sense...
12:13:40 <jsnx> Toxaris: and that's what is cool about haskell
12:13:47 <jsnx> or one of many things, really
12:13:52 <ndmitchell> Toxaris: have you seen Supero? it can sometimes do what you describe
12:13:53 <Toxaris> that you are allowed to dream about such stuff
12:14:00 <jsnx> heh
12:14:03 <sjanssen> Toxaris: seems like wishful thinking
12:14:06 <ndmitchell> i.e. you can write word counting faster in Haskell than in C, even using words :)
12:14:11 <Leaves> hello, I would like to have the index of the maximum number in an array, do you know if there is a function to do that or do I have to do this:  elemIndex (maximum.elems $ a) (elems a)  ?
12:14:13 <sjanssen> how many uses of strings are actually fusible?
12:14:25 <ndmitchell> (ditto at sjanssen about optimising Haskell with Supero)
12:14:34 <jsnx> sjanssen: i'll have to think about that
12:14:38 <Toxaris> sjanssen: sure it is. purely academically. I'm not a software developer :)
12:14:51 <Toxaris> sjanssen: but it sounds not so bad a goal, does it?
12:15:17 <sjanssen> Toxaris: I'd rather not sacrifice a simple interface for imagined chances for optimization later
12:15:30 <sjanssen> that, in itself, is not the Haskell Way :)
12:15:36 <jsnx> sjanssen: the optimizations are not imagined
12:15:55 <jsnx> sjanssen: and incorrect semantics in the interest of listiness is the schem way, not the haskell way
12:15:59 <lde> There is an excercise in YAHT to 'write a fold function for BinaryTrees', where data BT a = Lf a | Br (BT a) a (BT a)
12:16:02 <ndmitchell> if the interface is ugly, its bad - optimisation is about making beautiful code fast
12:16:05 <jsnx> s/schem/scheme/
12:16:22 <lde> The problem is that leafs have values, so should it take another function for leafs?
12:16:30 <jsnx> ndmitchell: i do not pattern match on strings at all
12:16:33 <sjanssen> Leaves: how about: fst . maximumBy (comparing snd) . assocs
12:16:34 <Toxaris> sjanssen: as I understand e.g. Stream fusion, you don't loose the [Char] interface, but add optimization as an alternative which is used when applicable
12:17:12 <sjanssen> lde: yes, that seems reasonable
12:17:15 <jsnx> ndmitchell: the interface i most need is split, fold, &c.
12:17:21 <Toxaris> therefore, jsnx, I strongly disagree with "[Char] is bad". It is great, absolutely clever and a wonderfull way of representing strings
12:17:23 <jsnx> ndmitchell: and s///
12:17:27 <Toxaris> the only problem is how slow it is :(
12:17:47 <jsnx> Toxaris: it is not a clever way of representing strings
12:17:48 <sjanssen> lde: when writing a fold, you usually need to have a function argument for each data constructor.  The function argument should have the same number of arguments as the constructor
12:17:55 <jsnx> Toxaris: maybe it is a good interface
12:18:02 <jsnx> Toxaris: but as a backing store, what is good about it?
12:18:10 <Toxaris> jsnx: representation != backing store
12:18:19 <jsnx> Toxaris: but [] is both
12:18:21 <Toxaris> jsnx: at least how I use the word *here*
12:18:32 <jsnx> Toxaris: okay, i understand your meaning
12:18:41 <Toxaris> yeah, it is too slow, that's the problem
12:18:43 <ndmitchell> jsnx: i think i know how to automatically optimise [Char] to an unboxed array automatically with full generality
12:19:03 <jsnx> ndmitchell: that is not the problem, though
12:19:07 <jsnx> ndmitchell: not as i see it
12:19:21 <jsnx> i'd rather just wrap my bytes and use the right functions on them
12:19:48 <jsnx> though, now that i think about it, infinite strings have their uses
12:20:06 <jsnx> so i am conflicted
12:20:08 <ndmitchell> i love String = [Char], it seems just perfect :)
12:20:10 <Toxaris> jsnx: but [Char] is the obvious representation for "a sequence of characters of unknown length", it is basically isomorphic to that description
12:20:27 <jsnx> Toxaris: however, string is more than that
12:20:31 <Leaves> sjanssen: that looks good (and efficient), I had to look up a couple of functions because I hadn't see them before but I think that's what I'm looking for, thanks!
12:20:42 <jsnx> which is to say, in common use, we expect regexen
12:21:04 <sjanssen> what is this about regex?
12:21:23 <jsnx> String should be a regexable something
12:21:24 <Toxaris> sjanssen: well, a regex is a finite state machine over a sequence of characters of unknown length
12:21:28 <jsnx> not just a listable something
12:21:37 <Toxaris> jsnx, sjanssen: sorry confused you
12:21:51 <jsnx> anyways, i have got to think about this more
12:21:58 <Toxaris> jsnx: so to regex a string, you need a list and nothing else
12:22:12 <Toxaris> jsnx: you build the automaton, and mapAccumL it or whatever
12:22:14 <jsnx> Toxaris: that would be a very bad implementation of Regexen
12:22:25 <sjanssen> regexes are not exactly common use in Haskell
12:22:31 <jsnx> you really just want the raw bytes and the encoding
12:22:36 <jsnx> sjanssen: they need to be
12:23:00 <Toxaris> jsnx: whats the problem with that implementation?
12:23:08 <sjanssen> jsnx: why?  Structured parsing with Parsec and friends seems nicer
12:23:17 <jsnx> sjanssen: it is not nicer
12:23:18 <sjanssen> why import the ad-hoc programming ways of Perl and Python?
12:23:24 <jsnx> sjanssen: it's crazily verbose
12:23:34 <jsnx> sjanssen: it's not ad hoc
12:23:45 <Toxaris> sjanssen: how are regular languages ad-hoc?
12:24:00 <jsnx> sjanssen: what Toxaris said
12:24:06 <jsnx> it's beautiful and fabulous
12:24:07 <sjanssen> Toxaris: their use as parsers is rather ad-hoc, in my opinion
12:24:26 <Toxaris> sjanssen: to parse context-free non-regular languages: yes, of course, thats the wrong tool for the job
12:24:37 <Toxaris> sjanssen: but if you want to parse a regular language, why not use a regular expression?
12:24:55 <jsnx> yeah, or what if you want to parse a logfile?
12:25:08 <Toxaris> jsnx: a context-free or a regular logfile?
12:25:19 <jsnx> an apache logfile
12:26:23 <jsnx> why do i want to write 8 lines of parsec for that?
12:26:34 <Toxaris> jsnx: looking at http://httpd.apache.org/docs/1.3/logs.html, I come to the conclusion that I don't want to do that :)
12:26:34 <jsnx> so i've go to use sed or ruby or perl
12:26:35 <lambdabot> Title: Log Files - Apache HTTP Server
12:26:47 <jsnx> Toxaris: well, you are an academic
12:26:50 <jsnx> Toxaris: i am not
12:26:51 <schme> jsnx: sed or awk seems better than anything for that ;)
12:27:14 <jsnx> schme: unfortunately, they have very weak control structures
12:27:34 <Toxaris> jsnx: actually, one of the goals for my research is to invent languages where you can add Perl-like regex support as a Parsec-style library
12:28:04 <jsnx> Toxaris: can you get // and s/// to work in haskell?
12:28:07 <schme> jsnx: What control structures are you lacking?
12:28:44 <Toxaris> jsnx: with a preprocessor: easily :) but as an embedded DSL, no, not possible. So i'm looking into how a language should be to allow that
12:29:17 <sjanssen> jsnx: we could do that in Haskell, with modified syntax
12:29:24 <jsnx> schme: i guess i really mean more than control structures
12:29:24 <jsnx> schme: i mean, awk has if
12:29:25 <Toxaris> jsnx: unfortunately, syntactic issues are underrated in academica, so nobody cares
12:29:31 <Toxaris> awk is not so bad
12:29:39 <jsnx> i use sed and awk extensively
12:29:50 <jsnx> but awk can't tell which file it's in
12:29:58 <jsnx> sed can't open files, as far as i can tell
12:30:03 <jsnx> so irritating
12:30:16 <Toxaris> awk has a cryptic global variable for the current filename, hasn't it?
12:30:29 <jsnx> Toxaris: it is extremely unreliable
12:30:40 <Toxaris> oh I was not aware of that
12:30:41 <jsnx> that filename might be /usr/bin/gawk
12:30:45 <lde> sjanssen: Right. Thanks.
12:30:46 <jsnx> not your script
12:30:52 <jsnx> Toxaris: so was i
12:30:57 <jsnx> found out the hard way
12:31:03 <Toxaris> jsnx: oh you mean that, that's a problem with shebang afaik
12:31:20 <Toxaris> jsnx: I understood "which input file it currently processes"
12:31:23 <jsnx> no, it's not a shebang problem
12:31:35 <Toxaris> jsnx: why do you need the name of the script?
12:31:51 <jsnx> Toxaris: ad-hoc module system
12:31:58 <jsnx> i need the path to the script
12:32:01 <jsnx> oh well
12:32:03 <schme> bummer.
12:32:04 <jsnx> back to sh for me
12:32:12 <Toxaris> now, that's the problem. awk is just not a modern language with <insert feature here>
12:32:31 <jsnx> Toxaris: it offers features that it doesn't really deliver on
12:32:41 <jsnx> like the "current file" variable
12:32:44 <jsnx> which is unreliable
12:32:48 <jsnx> so, that's annoying
12:32:59 <Toxaris> I would like to see an haskell-like awk :)
12:33:04 <jsnx> it's lack of modernity is otherwise very attractive
12:33:10 <Toxaris> :)
12:33:35 <jsnx> Toxaris: an awk script is matches and operations on the input
12:33:48 <Toxaris> I know
12:33:53 <jsnx> would not be too hard to get the exact format under do notation
12:34:10 <jsnx> though we still need //
12:34:14 <jsnx> and if awk had s///
12:34:17 <jsnx> that would be cool
12:34:27 <Toxaris> well, one could borrow a little bit from perl :)
12:34:30 <Toxaris> but not too much
12:34:36 <jsnx> that stuff is from sed
12:34:39 <Toxaris> I want a pure functional language of course
12:34:43 <jsnx> no need to talk about perl
12:35:01 <Toxaris> e.g., awk is "match input and perform operations", I want "match input and produce output"
12:35:17 <jsnx> Toxaris: we can think of awk that way
12:35:26 <jsnx> as long as it is done with do
12:35:47 <jsnx> since the output is passed from match to match
12:36:03 <jsnx> which is a find idiom for text processing
12:36:11 <jsnx> s/find/fine/
12:36:27 <jsnx> anyways, back to regexen and [Char]
12:36:52 <Toxaris> hehe let's start by writing a purely functional regex lib in Haskell, as a first building block for the embedded super-awk
12:37:01 <jsnx> lolz
12:37:08 <jsnx> there are already pure regexen in haskell
12:37:14 <jsnx> there are too many
12:37:26 <Toxaris> oh fine, so we are in common ground :)
12:37:35 <Toxaris> noo, known ground, no, how it is called?
12:37:45 <jsnx> familiar
12:37:48 <jsnx> familiar ground
12:38:00 <LordBr4in> I don't understand the String = [Char] debate... it seems to me ByteString was all about giving us the best of both worlds
12:38:16 <jsnx> LordBr4in: well, you can't have infinite ByteStrings
12:38:26 <LordBr4in> no...
12:38:26 <jsnx> LordBr4in: so one use case of [Char] is lost
12:38:35 <Toxaris> jsnx: there are lazy ByteStrings
12:38:37 <LordBr4in> pattern matches are lost too
12:38:44 <jsnx> LordBr4in: right
12:38:50 <jsnx> LordBr4in: i can live with that
12:39:00 <jsnx> who uses pattern matches on Strings?
12:39:01 <LordBr4in> yeah, Toxaris is right, there is lazy
12:39:13 <Toxaris> with our embedded super-awk, we would have regexp-based pattern matching
12:39:18 <jsnx> Toxaris: yeah, but consider how much easier it is to make infinite lists
12:39:30 <LordBr4in> i've used pattern matching on strings some
12:39:36 <jsnx> Toxaris: well, embedded sed
12:39:47 <Toxaris> embedded whatever.
12:39:54 <jsnx> Toxaris: awkishness does not really show up till you get past matching
12:40:08 <jsnx> so, what if all strings were made with regexen
12:40:13 <LordBr4in> i can't remember how or where but i know i have
12:40:21 <jsnx> and you could make infinite strings like this:
12:40:26 <jsnx> /ab.+/
12:40:26 <LordBr4in> and then missed them when i wanted to try it with bytestrings
12:40:30 <jsnx> heh
12:40:37 <Toxaris> I use it for simple commandline argument processing
12:41:02 <jsnx> so regexen would be the string constructor!
12:41:06 <jsnx> syck!
12:41:48 <Toxaris> jsnx: that is not one infinite string, that are infinitely many finite strings
12:41:50 <eidan> fuck england!
12:42:06 <LordBr4in> wha?
12:42:13 <Toxaris> jsnx: a regexp is finite description of a infinite language of finite strings
12:42:19 <eidan> FUCK ENGLAND FUCK ENGLAND FUCK ENGLAND!!!!hahahah
12:42:29 <TomMD> dons: How does one get op privilages?
12:42:38 <jsnx> Toxaris: yeah, you are right
12:42:47 <eidan> TomMD: you´re a very big mothafucka.
12:43:02 <jsnx> there's no way to get the next string from /ab.+/
12:43:05 <jsnx> could be anything
12:43:29 <Mr_Awesome> TomMD: the first step is spelling what one wants correctly
12:43:49 --- mode: ChanServ set +o sjanssen
12:44:05 <eidan> Mr_Awesome: fuck your grandparents.
12:44:08 --- mode: sjanssen set +b *!*n=WP-Gast@91.135.163.*
12:44:09 --- kick: eidan was kicked by sjanssen (sjanssen)
12:44:18 <tusho> WP-Gast, hah.
12:44:20 <tusho> I love WP-Gast.
12:44:23 --- mode: ChanServ set -o sjanssen
12:44:35 <TomMD> Mr_Awesome: Fair enough, but not a requirement, thank goodness.
12:44:37 <LordBr4in> what is WP-Gast?
12:45:03 <Toxaris> jsnx: I would like regexp-syntax in case statements over strings, with the option of bind named variables(!) instead of the awkward backreference numbering scheme
12:45:31 <jsnx> Toxaris: that amounts to making regexen a string constructor
12:45:36 <jsnx> Toxaris: at least in Haskell
12:45:42 <Toxaris> jsnx: nope, a string *destructor*
12:45:47 <jsnx> Toxaris: oic
12:45:53 <jsnx> interesting
12:45:59 <Toxaris> similiar to n+k patterns
12:46:06 <jsnx> oh
12:46:09 <jsnx> interesting
12:46:17 <jsnx> yeah, i never use those things, but...
12:46:18 <Toxaris> this would probably be possible in Scala, but with awkward syntax
12:46:39 <jsnx> we should form a SIG to get regexen as a destructor
12:46:41 <Toxaris> in scala, you can define your own destructors by defining a unapply method
12:47:01 <jsnx> Toxaris: yeah, i saw a talk on that once
12:47:02 <LordBr4in> which style regexes would you use?
12:47:15 <jsnx> LordBr4in: POSIX
12:47:18 <Toxaris> well, that are the things I'm thinking about: do you need a language to support user-defined destructors to allow cool EDSL implementations?
12:47:19 <jsnx> with character classes
12:48:13 <jsnx> to return to the Strings thing for a moment
12:48:16 <Toxaris> we already have these however-they-are-called active patterns with the <- syntax
12:48:26 <Asgaroth> how do i partially apply a function omitting a parameter in the middle of its arguments?
12:48:30 <Toxaris> but it is not the real thing, and nobody seems to use it
12:48:30 <jsnx> it looks like we are heading toward a ByteString future
12:48:44 <jsnx> Asgaroth: use flip and such
12:48:49 <Toxaris> Asgaroth: you can use lambda abstraction with \, or sometimes flip
12:49:01 <LordBr4in> do you mean a future where ByteString is the default?
12:49:05 <Asgaroth> thanks, i'll try
12:49:07 <Toxaris> Asgaroth: lambdabot can help you find the right cominbation of flip and (.)
12:49:09 <jsnx> LordBr4in: yes
12:49:19 <jsnx> LordBr4in: or rather, where everybody codes in ByteStrings
12:49:29 <TomMD> Everyone doesn't already?
12:49:32 <TomMD> Damn!
12:49:34 <LordBr4in> even simple tutorials?
12:49:39 <jsnx> LordBr4in: no
12:49:43 <Toxaris> @pl \x -> foo a x b c
12:49:44 <lambdabot> flip (flip (foo a) b) c
12:49:49 <jsnx> so newbies will have to learn a new secret
12:49:55 <LordBr4in> "" is rather nice list syntax for just demonstrating list functions
12:49:59 <Toxaris> Asgaroth: but sometimes it's just better to use \
12:50:18 <jsnx> character parsing with ByteStrings is impractical, due to encoding issues
12:50:28 <jsnx> character parsing with Strings is beastly slow
12:50:37 <Asgaroth> Toxaris: I think flip would work in my case(only 3 params) but lambda notation seems more readable to me
12:50:43 <TomMD> Let them learn parsec.
12:51:07 <jsnx> TomMD: does not really get you past the slowness of String, does it?
12:51:23 <jsnx> TomMD: does not address issue at all, really
12:51:32 <TomMD> Text.Parsec.ByteString.  I thought was faster, perhaps I am wrong.
12:51:52 <jsnx> TomMD: how do you parse UTF8 with that?
12:51:54 <TomMD> jsnx: I'll have to test and find out.
12:51:56 <Toxaris> I don't think a monadic parser combinator library can be really fast
12:52:05 <jsnx> TomMD: does not get you past the encoding issue
12:52:09 <TomMD> jsnx: I deal with ASCII data mostly, so I can't help there.
12:52:15 <jsnx> indeed
12:52:22 <Toxaris> there is just not enough possibility for optimization or fusing when >>= is involved
12:53:03 <Toxaris> jsnx: newtype UTF8 = UTF8 ByteString; newtype WhatEver = WhatEver ByteString
12:53:28 <jsnx> anyways, de-listifying String could help to unify ByteString and String
12:53:30 <Toxaris> jsnx: and now you can (maybe; I don't understand parsec3) write different instances for these ByteString variants which do the encoding for you
12:53:52 <Toxaris> jsnx: so you can deal with Char in Parsec, but only one Char at a time is converted from a chunk of bytes
12:54:14 <jsnx> Toxaris: the Parsec becomes the defacto String implementation
12:54:19 <jsnx> not clean at all
12:54:27 <Toxaris> ?
12:54:38 <Toxaris> well, it's ad-hoc, yes
12:55:08 <Toxaris> but everything is ad-hoc in some way except making [Char] fast enough by super-clever but general-purpose compiler optimization
12:55:13 <jsnx> String should really be a layer above ByteString (which could just as well be ByteStream)
12:55:30 <Asgaroth> can i map a function which returns IO String over a list somehow?
12:55:41 <LordBr4in> hmmmm
12:55:43 <Asgaroth> if i want to have the strings in the list
12:55:50 <jsnx> Asgaroth: no
12:56:02 <jsnx> Asgaroth: you have IO String in the list
12:56:02 <LordBr4in> yeah you can
12:56:11 <LordBr4in> use mapM
12:56:22 <Toxaris> Asgaroth: you can map it, that gives you [IO Whatever]. then you use sequence to get IO [Whatever]
12:56:23 <LordBr4in> you'll get IO [String]
12:56:25 <jsnx> @type mapM
12:56:27 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
12:56:34 <jsnx> yeah, he's right
12:56:46 <Toxaris> @src mapM
12:56:47 <lambdabot> mapM f as = sequence (map f as)
12:57:04 <Toxaris> but you cannot get the result of your function out of IO, since that would be impure
12:57:26 <Asgaroth> i see
12:57:28 * tibbe really wants more time so he can rewrite network-bytestring to completely replace network
12:57:32 <jsnx> Toxaris: if you just made String its own type, separate from List, it would be clean and clear
12:58:04 <jsnx> a character string is not really used like a list
12:58:37 <LordBr4in> I think that's an over-statement
12:58:39 <Toxaris> I'm not sure. How is a <sequence of characters which is backed by a longer sequence of bytes> different from <a sequence of A which is backed by a longer sequence of bytes>
12:58:43 <LordBr4in> i think it sometimes is used like a list
12:59:19 <Toxaris> I think we need general <sequence of A which is backed by ByteString> type, and then can easily specialize A = Char to get ByteString backed Srings
13:00:02 <LordBr4in> it may not be the typical use ...
13:00:07 <jsnx> Toxaris: okay, fair enough
13:00:26 <sclv_> tibbe: we were just talking about how network didn't have an official maintainer...
13:00:27 <jsnx> LordBr4in: i grant your point
13:00:27 <Toxaris> but if you start to define things separately because the have different usage scenarios, you start duplicating code
13:00:39 <jsnx> Toxaris: well, no
13:00:57 <sclv_> It would be awesome if you wanted to slowly take responsibility for pushing things forward in general...
13:01:02 <jsnx> Toxaris: Int and [Char -> String]
13:01:12 <jsnx> are used differently and we let them be different
13:01:24 <Toxaris> jsnx: no, they *are* differently
13:01:28 <Asgaroth> hmm if i have a list of IO String can i concatenate them and returm the resulting string in a function that is declared as IO String?
13:01:32 <jsnx> Toxaris: your argument leaves us with scheme
13:01:54 <LordBr4in> Asgaroth, yeah
13:02:00 <jsnx> Asgaroth: do you know about Hoogle?
13:02:10 <LordBr4in> as long as you don't exit IO, you are fine
13:02:13 <jsnx> http://haskell.org/hoogle
13:02:15 <lambdabot> Title: Hoogle
13:02:15 <Asgaroth> yes, but i don't know what to search for
13:02:19 <tibbe> sclv_: I'm maintaining network-bytestring but there isn't much code in there yet. I'm a bit afraid of the network package because the huge amount of preprocessor code and hugs/ghc code in there
13:02:28 <jsnx> [IO a] -> IO [a]
13:02:29 <Toxaris> Asgaroth: you want liftM
13:02:45 <tibbe> sclv_: so writing a new network library would be quite and undertaking since it needs testing on many platforms
13:02:52 <Toxaris> Asgaroth: on top of sequence, which you already know
13:02:56 <Asgaroth> ah so it can search for types, that i did not know. I guess i might bother you less often then
13:03:07 <jsnx> Asgaroth: well, it's no bother
13:03:17 <jsnx> i just thought you might not have heard of it
13:03:42 <Asgaroth> ok. but my questions are quite stupid from the perspective of an experienced haskeller I guess
13:03:44 <Toxaris> jsnx: I see, we want newtype (e.g., arbitrary differences between isomorphic types)
13:04:06 <jsnx> Toxaris: there is no reason to think a string is a list
13:04:14 <jsnx> that's a choice, and i think it was the wrong one
13:04:23 <jsnx> ByteString isn't [Byte]
13:04:38 <Toxaris> jsnx: I have never seen a sensible String implementation which isn't isomorphic to [Char]
13:05:13 <jsnx> isn't ByteString isomorphic to [Byte] ?
13:05:34 <Toxaris> jsnx: of course it is. it's the absolutely same thing. it just happens to be faster for some uses
13:05:51 <Toxaris> (module laziness, which is to complicated to take into account)
13:06:21 <jsnx> Toxaris: the same decision needs to made for string
13:06:23 <Toxaris> so I can write a program with [Byte], or with ByteString, and it will mean the exactly same thing. therefore, I want the compiler to decide which one is better for my program
13:06:36 <jsnx> Toxaris: well, it can't today
13:06:49 <jsnx> and not for the next five years, i bet
13:06:59 <Toxaris> hehe, actually, laziness is a big problem there, I guess
13:07:17 <Toxaris> because to replace [Byte] with ByteString, the compiler has to prove that it's no problem
13:07:53 <Toxaris> I think we should five years, if it takes that long
13:08:00 <Toxaris> insert a "wait" there
13:08:05 <jsnx> Toxaris: no, we should fix the strings last year
13:08:11 <jsnx> so i can stop writing sed
13:08:20 <Toxaris> (not that you can't use ByteString now, it's just not the default)
13:08:23 <jsnx> Haskell does not have to be perfect
13:08:34 <jsnx> Toxaris: you can't use ByteString for character parsing
13:09:20 <Toxaris> well, so write a String-like layer on top of ByteString which allows it, as we have discussed
13:09:45 <Toxaris> then, you (1) can use ByteString for efficient character parsing and (2) have helped to get the 5 years work done
13:10:05 <Toxaris> since your layer can be used in the final perfect Haskell, which inserts it automatically where appropriate
13:10:12 <jsnx> Toxaris: oic
13:10:16 <schme> Hoh. Is it still the String conversation? :)
13:10:26 <Toxaris> I don't see why you have to remove [Char] to add CoolThingYouWant
13:10:27 <jsnx> schme: yes
13:10:56 <schme> What are we replacing [Char] with then?
13:11:07 <Toxaris> (and obviously, removing [Char] is not possible anyway, given legacy code etc)
13:11:15 <BMeph> jsnx: Just curious, but have you worked at all with PEGs or packrat parsers?
13:11:24 <schme> Pfft. go ghc 7 and fuck legacy :)
13:11:53 <Toxaris> fine for me, but not fine for jsnx, who wants to do real stuff with Haskell
13:12:11 <jsnx> Toxaris: we can accomodate legacy code with a language pragma
13:12:24 <jsnx> BMeph: no, what are they?
13:13:31 <jsnx> oh, interesting
13:13:55 <BMeph> I don't mind legacy breaks, especially if there's a relatively simple way to "fix" source code to comply with the new system. It's when the code was "quasi-buggy" to start, and the new system's specs are still "being hashed out" and no one's sure of how the changes change things, but only aware that there are breaking changes, that the Hatorade(R) gets passed out by the barrel. :)
13:14:04 <BMeph> @goo ford packrat
13:14:05 <lambdabot> http://portal.acm.org/citation.cfm?id=581483
13:14:21 <BMeph> jsnx: ^^ start with that paper.
13:14:25 <jsnx> BMeph: there should be a version pragma
13:14:32 <jsnx> BMeph: thanks
13:14:55 <jsnx> if your code does not compile anymore, add a version pragma and the compiler will do it the old way or reject it
13:15:05 <BMeph> He explains it better than I can. I just know of them because I dabble in Lua at times.
13:15:06 <jsnx> (if it does not support such old code)
13:15:37 <jsnx> okay, i have enjoyed chatting with you all
13:15:43 <jsnx> i need to work now
13:15:48 <jsnx> cheers
13:17:44 <BMeph> So, that "language pragma" bit was just for GHC? Considering its rep for slow compiles as it is, I don't see such a pragma helping things...
13:20:32 <BMeph> Hmm, too bad jsnx left; http://pdos.csail.mit.edu/~baford/packrat/thesis/ is a much better reference for that paper. Not to mention, there's a prototype parser generator...in Haskell, natch! ;)
13:20:33 <lambdabot> Title: Packrat Parsing: a Practical Linear-Time Algorithm with Backtracking
13:21:30 <gwern> 'adding split to Data.List. Gwern Branwen [33]proposed adding some split-like functions to Data.List. Will they actually get added this time? Will people be able to agree on one of the seventeen possible sets of semantics? Tune in next time...'
13:21:36 * gwern vaguely suspects byorgey is amused by me
13:22:01 <BONUS> you mean like python's split?
13:22:37 * BMeph suspects gwern isn't the only one to ask for "split-like functions"
13:23:20 <gwern> BMeph: oh no. this is at least the 3rd attempt by my count
13:23:42 <gwern> BONUS: yeah, but less lossy, from what I hear
13:23:58 <BMeph> gwern: Maybe we'll get a Data.List.Split module... 8D
13:24:19 <LordBr4in> where's the proposals, i want to take sides and dig my heels in
13:24:50 <gwern> LordBr4in: it's on the libraries list
13:25:19 <gwern> BMeph: don't lauch, I have 4 or 5 split variants banging around in my scratch module
13:25:32 <gwern> enough for a module, yes
13:27:10 <BONUS> what are the intricacies of the split function though?
13:27:42 <BONUS> i suspect like if you want to split "fooo,foo,,,foo" on ','
13:27:44 <BONUS> or something like that
13:28:03 <Toxaris> I know of two orthogonal issues:
13:28:11 <Toxaris> (1) should empty things be ignored?
13:28:17 <Toxaris> (2) should the separator be included?
13:28:20 <Toxaris> are there more issues?
13:29:15 <gwern> BONUS: there are tons of things. for example, what does 'split 'a' ['a'] produce? or split 'a' []?
13:29:38 <BONUS> i'd venture to say they both produce []
13:29:44 <BONUS> that seems the most logical to me
13:29:51 <Toxaris> > lines "\n"
13:29:54 <lambdabot>  [""]
13:29:55 <gwern> for the latter, could be [[]], ["",""], or [""]
13:30:12 <Toxaris> hmm.. crazy.
13:30:14 <gwern> Toxaris: lines and words are bad models, as they are lossy. they don't even work the same way
13:30:36 <Toxaris> gwern: of course not, so they are *good* models to explore the design space, since they provide two data points
13:30:37 <gwern> ie unlines . lines \= id
13:30:38 <BONUS> now thinking aobut it
13:30:50 <BONUS> split 'a' "a" should produce [[],[]]
13:30:52 <BONUS> imho
13:31:02 <Toxaris> so it seems that my question (1) should empty things be ignored? is complicated
13:31:04 <gwern> @test \x -> (unlines . lines x) == x
13:31:05 <lambdabot> Maybe you meant: let list tell
13:31:16 <gwern> @check \x -> (unlines . lines x) == x
13:31:17 <lambdabot>  Couldn't match expected type `String' against inferred type `Char'
13:31:20 <Toxaris> e.g. you could have special rules for an empty thing just before the first separator
13:31:27 <Deewiant> @check \x -> (unlines . lines $ x) == x
13:31:28 <lambdabot>  Falsifiable, after 0 tests: "\583160\220285"
13:31:46 <Toxaris> now that's unlines :)
13:31:54 <Toxaris> unlines "test"
13:31:59 <Toxaris> unlines "test"
13:32:01 <Toxaris> > unlines "test"
13:32:02 <lambdabot>  Couldn't match expected type `String' against inferred type `Char'
13:32:04 <gwern> @check \x -> (unwords . words $ x) == x
13:32:06 <lambdabot>  OK, passed 500 tests.
13:32:11 <Toxaris> > unlines ["test"]
13:32:12 <lambdabot>  "test\n"
13:32:17 <Deewiant> @scheck \x -> (unwords . words $ x) == x
13:32:17 <lambdabot>     Failed to load interface for `SmallCheck':
13:32:17 <lambdabot>       Use -v to see a list of ...
13:32:21 <Deewiant> O_o
13:32:27 <gwern> see? as I said, words and lines do not work the same way
13:32:53 <gwern> this is reflected in my proposal - they need different split definitions
13:33:15 <Toxaris> I have not read your proposol because the mail in that mail archive comes out unreadable :(
13:33:18 <Toxaris> (ok, bad reason)
13:33:57 <gwern> BONUS: the ["",""] response to [] is actually somewhat popular - that's the bytestring definition of split
13:34:00 <gwern>  -- split 'x'  "x"          == ["",""]
13:34:14 <gwern> er, to a [a], I meant
13:35:00 <gwern> that is, split [] [[]] is [[], []]
13:35:58 <BONUS> its also how it behaves in python :]
13:36:29 <gwern> and then there's the http://www.haskell.org/pipermail/haskell-cafe/2006-July/016574.html suggestion where split [] [[]] becomes []
13:36:31 <lambdabot> Title: [Haskell-cafe] Re: Why is there no splitBy in the list module?, http://tinyurl.com/6fkj7f
13:36:41 <Toxaris> so split [] is a kind of succ?
13:37:10 <Toxaris> split [] [] = [[]]; split [[]] = [[], []]; split [[], []] = [[], [], []]
13:37:15 <gwern> the generalised bytestring-style split can be found at http://hackage.haskell.org/trac/ghc/ticket/2048 btw
13:37:20 <Toxaris> that seams to be strong point linking split back to number theory
13:37:20 <lambdabot> Title: #2048 (Add split and splitWith to Data.List) - GHC - Trac
13:39:03 <LordBr4in> I like the non-deliminator eating version of split, if we have to choose
13:39:31 <BMeph> Toxaris: Hm, shouldn't split [] [[],[]] == []? :)
13:40:33 <Toxaris> BMeph: well depends on split, doesn't it?
13:40:48 <tromp> > split 'a' "aa"
13:40:50 <lambdabot>  Couldn't match expected type `[Char] -> t'
13:41:08 <tromp> :t split
13:41:09 <Deewiant> ?ty split
13:41:10 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
13:41:10 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
13:41:15 <Toxaris> :)
13:41:17 <dons> " John Dias is hard at work on GHC's back end, and we should be in reasonable shape by mid Sept."
13:41:20 <dons> exciting!
13:41:58 <LordBr4in> what is going to be in shape by mid september?
13:42:37 <Toxaris> BMeph: I find split x [x, x] = [[], [], []] reasonable. you have two delimiters, so you get three parts
13:43:37 <frevidar> is there a way to "debug print" something easily, which is deep inside a number of pure functions?
13:43:44 <chrisdone> trace
13:43:57 <Plareplane> is book.realworldhaskell.org not working for anyone else right now?
13:44:14 <chrisdone> doesn't work for me either
13:45:57 <Jedai> frevidar: Debug.Trace (trace function)
13:46:14 <frevidar> chris, jedai, thanks!
13:47:07 <BMeph> Toxaris: Sounds like a line-based, vice a word-based, defn. Which is a legitimate function - and a point of choice for more functions.
13:48:07 <Toxaris> BMeph: well, from my choices somewhere above, it's (1) empty things are never ignored and (2) separators are never included
13:49:08 <Toxaris> BMeph: imho that's the obvious choice. no need to include the separators, since you know them anyway. no need to ignore anything, since you can to it with post-processing.
13:49:29 <Toxaris> but maybe split :: a -> [a] -> [Either a [a]] would be even better
13:49:46 <LordBr4in> since you can easily get rid of separators, i think it is better to leave them in, because i have a feeling they are indeed useful at times.
13:50:02 <Toxaris> and then post-processing to e.g. ignore all Lefts, or ignore empty Rights or whatever
13:50:21 <LordBr4in> although i'd probably be fore using a predicate to test to see if something is a seperator
13:50:38 <Toxaris> LordBr4in: hehe ok then you want to get them of course
13:50:46 <Toxaris> but maybe there just are not empty Rights
13:51:52 <Toxaris> what about ([a] -> Bool) -> [a] -> [Either [a] a]
13:51:57 <LordBr4in> also, leaving them in makes it reversable
13:52:07 <dons> slarba: good work!
13:52:52 <LordBr4in> i am not seeing how you are using Either
13:52:53 <Toxaris> hmm not the predicate has to return how many chars it wants to consume
13:53:17 <Apocalisp> Equal Rights for Eithers!
13:53:26 <RayNbow> @index comparing
13:53:26 <lambdabot> bzzt
13:53:28 <Deewiant> ([a] -> Maybe Int) -> [a] -> [Either [a] [a]] !!
13:53:37 <RayNbow> @hoogle comparing
13:53:37 <lambdabot> Data.Ord.comparing :: Ord a => (b -> a) -> b -> b -> Ordering
13:54:02 <Toxaris> the idea was to have something similar to (split "abc" "xxabcyyyabcx" == [Right "xx", Left "abc", Right "yyy", Left "abc", Right "x"])
13:54:17 <Deewiant> yeah, so Either [a] [a] and not Either [a] a
13:54:31 <Toxaris> Deewiant: yeah I used your suggestion on-the-fly :)
13:54:37 <Deewiant> :-)
13:54:54 <Toxaris> Deewiant: we need a small combinator language to write these ([a] -> Maybe Int) things
13:55:01 <Deewiant> but, ehm, such a type signature seems like overkill to me :-P
13:55:26 <dons> slarba: btw, useAsCString does a memcpy.
13:55:48 <dons> so i think that's probably going to make performance suck.
13:56:16 <Toxaris> Deewiant: so we are near to ([a] -> Maybe ([a], b)) -> [a] -> [Either [a] b]
13:56:17 <dons> slarba: around, do you have the test data the original blogger used to get the 1s result?
13:56:33 <Deewiant> Toxaris: still need to return the number of eaten a's
13:56:34 <Toxaris> which may be actually usefull: parse all occurences you find, and return the rest of the token stream unparsed
13:56:45 <Deewiant> ah, right, like that
13:56:53 <Deewiant> I guess that works too
13:57:09 <Toxaris> yeah it's a ReadS-approach, but with Maybe instead of [] to avoid backtracking
13:57:18 <LordBr4in> well split may no longer be the appropriate name for such a function
13:57:34 <Deewiant> yeah, hence "overkill" :-P
13:57:35 <LordBr4in> :/
13:57:36 <Toxaris> no it's the secret core on top of which the various splits could be built
13:57:48 <Toxaris> what's wrong with Data.List.overkill?
13:57:52 <LordBr4in> lol
13:58:19 <LordBr4in> it is useful
13:58:29 <Toxaris> I guess it is an unfold
13:58:34 <Toxaris> *and* I think it is usefull
13:58:47 <gwern> Toxaris: come up with a way to do that, and I would be interested
13:59:11 <Toxaris> e.g. you can throw the parsed parts away and get split, or you throw the unparsed parts away and you get a noise-ignoring parser
14:01:19 <gwern> actually, that's a not a bad idea. the Left would be Delimiter, and the Right would be Unmatched or something, and from there you presumaly have a principled way of trhowing away information to get the various splits
14:01:36 <gwern> I doubt we could use Prelude breaks, tho, if we wanted to put stuff into Either
14:01:56 <LordBr4in> prelude breaks?
14:01:58 <sclv_>  although would introducing that extra adt hurt efficiency?
14:02:26 <gwern> @hoogle break
14:02:27 <lambdabot> Prelude.break :: (a -> Bool) -> [a] -> ([a], [a])
14:02:27 <lambdabot> Data.List.break :: (a -> Bool) -> [a] -> ([a], [a])
14:02:27 <lambdabot> Data.ByteString.break :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
14:02:39 <sclv_> If we call split unintercalate instead, then the implementation becomes obvious...
14:02:58 <gwern> @src intercalate
14:02:59 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
14:03:26 <mauke> escalate
14:03:35 <LordBr4in> unintercalate is too long and nerdy
14:03:36 <Deewiant> and what about unintersperse? :-P
14:03:41 <LordBr4in> lol
14:04:11 <LordBr4in> could call it lex
14:04:40 <LordBr4in> isn't that what it is? a sort of lexer?
14:04:54 <Japsu> foldr (break . snd) ([], s)?
14:05:18 <Japsu> *break mySplitPredicate
14:05:27 <LordBr4in> and lex is nice and easy to type
14:05:38 <Toxaris> why is there no (b -> (a -> [a] -> b) -> [a] -> b)?
14:05:44 <sjanssen> if you want lex, I'd generalize the type
14:05:47 <Japsu> :t foldr (break ?f . snd) ([], s :: String)
14:05:48 <Deewiant> ?ty \f -> foldr (break f . snd) . (,) []
14:05:48 <lambdabot>     Couldn't match expected type `b -> b'
14:05:48 <lambdabot>            against inferred type `([a], [a])'
14:05:48 <lambdabot>     Probable cause: `break' is applied to too many arguments
14:05:49 <lambdabot>     Couldn't match expected type `a -> a'
14:05:50 <lambdabot>            against inferred type `([a1], [a1])'
14:05:50 <Toxaris> would be handy in combination with unfoldr over lists
14:05:52 <lambdabot>     Probable cause: `break' is applied to too many arguments
14:05:57 <Toxaris> would allow #haskell-compatible one-liners
14:06:01 <LordBr4in> sjanssen, which type?
14:06:23 <LordBr4in> lex :: (a -> Bool) -> [a] -> Either [a] [a]
14:06:29 <sclv_> "extrapolate" is what msn sez the antonym for intercalate is, but thats no good.
14:06:41 <sclv_> varigate
14:06:43 <sclv_> maybe
14:06:46 <sjanssen> lex :: [([a] -> Maybe (b, [a], [a])] -> [a] -> [b]
14:07:06 <sclv_> intracalate!
14:07:21 <LordBr4in> tercalate
14:07:25 <Asgaroth> what's the most elegant way insert subsequent elements of list in a template-like string like "first: %a, second: %a"? Do I really have to concat these strings one by one?
14:07:38 <Deewiant> Toxaris: eh? that's an impossible type
14:07:52 <Toxaris> Asgaroth: there is printf :)
14:07:56 <Deewiant> unless you wanted const . const :-P
14:08:09 <dons> Asgaroth: printf?
14:08:24 <Deewiant> printf for the win
14:08:27 <Asgaroth> thanks
14:08:33 <Toxaris> deewiant: I'm pretty sure my type is correct
14:08:45 <Deewiant> how are you going to get a "b"
14:08:50 <Deewiant> given "a -> [a] -> b" and no "a"
14:09:01 <sclv_> > concat ["This is the first element: ", show 22, ", And the second: ", show 12]
14:09:03 <lambdabot>  "This is the first element: 22, And the second: 12"
14:09:03 <BMeph> Hm, someone just did a blog entry on those lines, let me poke around some more
14:09:10 <Deewiant> or what's the first "b" for then
14:09:18 <LordBr4in> it's not clear to me how sjanssen's lex is a generalization of mine
14:09:21 <Deewiant> if you're just using the "[a]" for everything
14:10:06 <Toxaris> > (\n c xs -> case xs of {[] -> n; x:xs -> c x xs})
14:10:07 <lambdabot>  Add a type signature
14:10:11 <Toxaris> @type (\n c xs -> case xs of {[] -> n; x:xs -> c x xs})
14:10:12 <lambdabot> forall t t1. t -> (t1 -> [t1] -> t) -> [t1] -> t
14:10:22 <Toxaris> Deewiant: that's what I want
14:10:32 <Deewiant> O_o
14:11:05 <LordBr4in> i guess split is a fine name
14:11:35 <sclv_> outercalate!
14:11:44 <gwern> -- Two adjacent separators result in an empty component in the output.
14:11:54 <gwern> er. mispate
14:11:58 <Asgaroth> about printf: it still requires the arguments to be given one by one. is there a way to use the elements of a list instead without taking it apart manually?
14:12:03 <LordBr4in> i dont think intercalate was such a great choice personally
14:12:17 <LordBr4in> for a name
14:12:34 * sclv_ loves intercalate as much as he loves haskell itself.
14:12:41 <Deewiant> ?ty let if' a b c = if a then b else c in (. flip (ap . (. head)) tail) . ap . flip (if' . null)
14:12:42 <lambdabot> forall b a. b -> (a -> [a] -> b) -> [a] -> b
14:12:44 <LordBr4in> lol
14:13:09 <Deewiant> I think it's a pretty crap name to be honest
14:13:12 <sclv_> function names like intercalate = a new meaning for "literate" programming!
14:13:24 <sclv_> I think its very expressive actually.
14:13:34 <dons> sclv_: :)
14:13:49 <LordBr4in> i dont find it so expressive
14:13:54 <Deewiant> my dictionaries seem to agree that it's inserting something in a calendar :-P
14:13:55 <LordBr4in> maybe because the word is too obscure
14:15:00 <Toxaris> Asgaroth: maybe you can use: concat (zipWith printf ["first: %s", "second: %s"] values)
14:15:06 <Toxaris> Asgaroth: but that's pretty crazy
14:15:23 <Toxaris> And may not even work due to printfs advanced type
14:15:37 <Asgaroth> Toxaris: is there a better/less crazy way to do it?
14:15:38 <sclv_> @web intercalate
14:15:42 <LordBr4in> catsperse or something would have been better for me
14:15:43 <lambdabot> *** "Intercalate" web1913 "Webster's Revised Unabridged Dictionary (1913)"
14:15:47 <lambdabot> Intercalate \In*ter"ca*late\, v. t. [imp. & p. p.
14:15:49 <lambdabot>    {Intercalated}; p. pr. & vb. n. {Intercalating}.] [L.
14:15:51 <lambdabot>    intercalatus, p. p. of intercalare to intercalate to
14:15:53 <lambdabot>    intercalate; inter between + calare to call, proclaim. See
14:15:55 <lambdabot> Plugin `dict' failed with: thread killed
14:15:56 <sclv_> @more
14:16:23 <Toxaris> Asgaroth: hmm. what about concat (zipWith (++) ["first: ", "second: "] values)
14:16:36 <sclv_> Anway, it eventually says "to insert among others as a verse in a stanza"
14:16:54 <Asgaroth> Toxaris: that would do it thanks.
14:17:13 <LordBr4in> it's not really that helpful if you have to look it up in a dictionary, and once you do, you still are left wondering in fact since nothing about the words definition entails multiple insertions
14:17:16 <Toxaris> Asgaroth: probably you need (map show values)
14:17:28 <LordBr4in> interweave would have been better
14:17:43 <mauke> still better than strcspn
14:17:46 <sclv_> "to introduce as a bed or a stratum between the layers of a regular series of rocks"
14:17:49 <Asgaroth> Toxaris: the values are already strings, so i guess i won't need it.
14:18:11 <Toxaris> Asgaroth: true. show would escape fancy characters, though, which sometimes is good, sometimes bad
14:18:51 <LordBr4in> oh well, i gtg
14:21:16 <dons> slarba, jsnx, got a basic readDouble parsing 50M of Doubles in 4s
14:21:21 <dons> so 160k should be easy :)
14:21:32 <dons> $ du -hs x
14:21:33 <dons> 52M	x
14:21:33 <dons> $ time ./Double < x
14:21:33 <dons> 6144000.0
14:21:33 <dons> ./Double < x  2.68s user 0.13s system 70% cpu 3.998 total
14:21:40 <dons> just summing a list of doubles.
14:21:59 * dons yells "bring it on!"
14:22:32 <sclv_> nice -- just a handcoded parser?
14:22:52 <dons> just a non-copying strtod call.
14:23:03 <sclv_> heh. simpler is better.
14:23:20 <twobitwork> can GHC parallelize haskell code?
14:23:22 <dons> the examples going around for the fast csv parser were using copying, which is not good
14:23:26 <dons> twobitwork: yes.
14:23:29 <twobitwork> i.e., for multicore systems?
14:23:30 <dons> with help.
14:23:33 <sjanssen> twobitwork: no
14:23:39 * twobitwork confused
14:23:47 <dons> well, it takes haskell code that is parallelised, and runs it on multiple cores.
14:23:47 <sjanssen> twobitwork: but you can parallelize your code and GHC will run it on multiple cores
14:23:47 <sclv_> twobitwork: You can write parallel code and ghc can compile it.
14:23:53 <dons> you have to put the `par` s in place.
14:23:57 <twobitwork> ahh
14:24:09 <dons> it doesn't discover the parallel algorithms for you
14:24:29 <twobitwork> shouldn't it be possible to do some auto-parallelizing of haskell code due to the well-formedness of the language? i.e., data dependancy trees, etc
14:25:01 <dons> ok, 50M / 2.7s now.
14:25:01 <Terabyte> Hey, could sombody give me a snippet or two of code where C++ does consistently worse for parallel stuff than Haskell?
14:25:11 <stepcut> twobitwork: possible: yes. easy: no.
14:25:15 <dons> Terabyte: on the shootout there's several parallel programs
14:25:20 <sclv_> Terabyte: take a look at the threadring benchmark.
14:25:21 <dons> which Haskell wins handily
14:25:27 <Terabyte> shootout?
14:25:32 <sclv_> ?go language shootout
14:25:34 <lambdabot> http://shootout.alioth.debian.org/
14:25:34 <lambdabot> Title: The Computer Language Benchmarks Game
14:25:38 * sjanssen notes that threadring is not parallel at all
14:25:44 <dons> oh, theyve not implemented C++ solns
14:25:45 <twobitwork> stepcut: http://cgi.cse.unsw.edu.au/~dons/blog/2007/11/29#smoking-4core
14:25:46 <lambdabot> Title: Haskell hacking
14:26:00 <dons> too hard to write, I guess
14:26:02 <dons> :)
14:26:23 <Terabyte> thanks
14:26:28 <dons> 50M/2.0s
14:26:55 * dons thinks this 160k csv benchmark is dead meat.
14:27:39 <stepcut> twobitwork: ?
14:27:49 <mfp> as sjanssen said, threadring doesn't measure parallelism at all, only context switching; a better example would be something were you have allocation happening in multiple threads
14:27:54 <mfp> oops
14:28:04 <litb> hello all there
14:28:17 <litb> they are flaming haskell right now in ##c++
14:28:24 <stepcut> litb: yay!
14:28:31 <dons> good for them.
14:28:49 <stepcut> litb: that means they are not busy writing  more of that wretched C++
14:28:56 <mauke> preflex: quote bos
14:28:56 <preflex>  <bos> i'm very pleased by the recent progress of the C++ standard.  it's gradually eroding the performance advantage of C++ compilers over GHC, without the simons having to do anything.
14:29:00 <dons> and they're scared :)
14:29:04 <stepcut> litb: I can only consider that a good thing
14:29:18 <mfp> iow. the standard "GHC pwns C++ at parallelism" example shouldn't be threadring but anything doing actual work involving allocation (C++ will suck at that)
14:29:21 * sjanssen <3 Data.Monoid
14:29:31 <sjanssen> newtype Lexer a b = Lexer (a -> (Maybe (Lexer a b), First b))
14:29:35 <dons> mfp: its a great benchmark for measuing how "light" threads are.
14:29:41 <dons> which is part of the story.
14:29:48 <dons> and how good the scheduler is
14:29:49 <sjanssen> and combination of lexers is derived :)
14:29:58 <mfp> well, context switching speed, which is not what ppl usually worry about
14:30:09 <twobitwork> stepcut: sorry, that was for terabyte
14:30:15 <mfp> because ppl with the C++ mindset don't conceive more than a few threads
14:30:28 <stepcut> twobitwork: ah. That is a good example of why auto-parallelization is hard though ;)
14:30:47 <mfp> and we don't have 513 cores yet
14:31:20 <twobitwork> mfp: yet is the keyword here... cores on the order of hundreds are going to be The Next Big Thing
14:31:43 <mfp> twobitwork: GHC doesn't scale to hundreds of cores either
14:31:59 <mfp> at least not much better than C++ would, does it?
14:32:02 <twobitwork> I mean... its grid computing on the die, its innevitable
14:32:04 <dons> we don't know.
14:32:15 <dons> the biggest machines ghc's been on were 40 cores.
14:32:28 <twobitwork> dons: how'd it do?
14:32:40 <mfp> iow., is there a reason for GHC to work better than C++ for > 40 cores?
14:32:43 <dons> good! there are benchmarks in the data parallel arrays paper.
14:33:18 <mfp> if there's allocation, the GC becomes the bottleneck quickly --- similarly to C++ with malloc
14:33:22 <dons> it's all the same assembly underneath
14:35:24 <Cale> I can imagine GHC doing well on >40 cores.
14:35:41 <mfp> dons: well, the GC could be better than a (pt_)malloc, but we don't know; we do know that GC becomes a bottleneck very quickly if there's significant amounts of allocation, but not if it's better than C++; at any rate, it scales worse than something like Erlang
14:36:43 <mfp> so given hundreds of cores, Erlang could catch up: it's 100 times slower than native code at worst...
14:36:52 <dons> We don't know though.
14:37:36 <dons> I'd imagine if 32 core boxes land on SimonMs desk next year, we'll have per-thread GC soon enough.
14:37:49 <dons> if the parallel GC turns out to be the next bottleneck.
14:38:07 <mfp> we can't use future developments as an arg, can we? :-)
14:38:19 <dons> we're using future architectures as an argument...
14:38:35 <dons> for existing architectures, the GC isn't the problem .. afaik.
14:38:37 <mfp> there might also be some ueber-performant parallel malloc in the works
14:39:34 <mfp> right, so instead of saying "it'll eventually pwn C++, when we have hundreds of cores" (speculative), we can show programs that beat it _today_ with 4-8 cores
14:40:04 <dons> right.
14:40:27 <dons> so right now, small N multicore is a ghc sweet spot.
14:40:47 <mfp> take for instance this ->  http://labs.trolltech.com/blogs/2008/06/27/wide-finding/
14:40:51 <lambdabot> Title: Trolltech Labs Blogs  Wide Finding
14:41:06 <dons> why isn't there a strntod
14:41:09 <dons> sigh.
14:41:13 <dons> i guess i have to write a aprser.
14:41:50 <dons> oh, opensolaris has one.
14:42:28 <mfp> above link -> great potential ex. for parallelism + ByteString
14:42:40 <dons> yeah, didn't bos write a really fast bytestring version?
14:42:56 <mfp> haven't seen that one
14:43:11 <dons> maybe it was the first wide-finder
14:43:13 <dons> on his blog.
14:43:48 <mfp> this one? ->  http://www.serpentine.com/blog/2007/09/25/what-the-heck-is-a-wide-finder-anyway/
14:43:50 <lambdabot> Title: teideal glic deisbhéalach  Blog Archive  What the heck is a Wide Finder, anyw ..., http://tinyurl.com/2mcz47
14:45:00 <mfp> wide finder 2 has got more processing than the first iteration, the likes of Python will be comparatively slower
14:47:27 <zachk> i am probably going to vomit going back to java for school
14:50:02 <lament> all over the classroom
14:51:22 <zachk> half the class cant figure out what an object is mmmmm
14:51:47 <mauke> an object is a lambda function
14:51:59 <orzo> i want to combine static libraries into a single static library
14:52:12 <orzo> using ar on os x
14:52:20 <mauke> "sending a message" means applying the function to an argument ("message")
14:53:27 <zachk> they make sense as closures to me where i can mutate state
14:53:54 <mauke> the message is of course another object (function)
14:54:04 <mauke> actually, every value is an object
14:54:13 <dons> slarba: yeah, the use of useAsCString would be killing the performance. at least 10x slower
14:54:15 <mauke> and the return value is also an object
14:54:33 <mauke> thus we have reached lambda calculus
14:54:52 <chrisdone> yay λ_λ
14:55:42 <orzo> when i try a straight forward aporach of extracting the modules in each and combinging them all together again in a nwe library, I get erros that the modules have no symbols
14:56:50 <zachk> there is a c++ irc evluation bot, but its written in haskell  http://www.xs4all.nl/~weegen/eelis/geordi/
14:57:08 <mar77a> geordi is written in haskell?
14:57:10 <dons> yeah, that's awesome :)
15:02:30 <orzo> i have two bash variables each with space deliminated lists in them.  I want to zip them like haskell's zip.  Does bash have anything like this?
15:02:46 <ddarius> Ask on #bash or whatever?
15:02:51 <dons> ghc -e zip
15:02:52 <dons>  :)
15:03:08 <ddarius> dons: `on` words
15:04:21 <bos> for all modestly complicated programming tasks, bash makes you jump through hoops to achieve them.
15:12:30 <mulletron> can someone recommend a haskell xml parser - google seems to inform me that HaXml and hxt are both popular - does anyone have an experienced opinion on the matter?
15:12:53 <dons> go to hackage.haskell.org
15:12:59 <dons> if 'xml' doesn't work, try haxml.
15:14:13 <sclv_> haha oh wau the hxt hate is strong here.
15:14:27 <mulletron> ok, thanks ;)
15:14:39 <mulletron> haxml appears to be in debian as well which is a help
15:14:40 <sclv_> but yeah I'd give it a shot with xml which is the simplest lib first, and see if that didn't meet your needs.
15:16:00 <yitz> bos: launching programs and connecting them with pipes are modestly complicated programming tasks.
15:16:13 <BMeph> sclv_: Planning on writing an XML-with-Haskell tutorial sometime soon? :)
15:16:42 <sclv_> BMeph: I've only really used hxt and explored the other two a bit.
15:16:49 <ddarius> "How to Lex Haskell Using XSLT"
15:17:02 <yitz> ddarius: eww
15:17:10 <sclv_> What I really want to do is to write a good set of pickler combinators, probably over the galois lib, because the hxt ones are awful.
15:17:43 <yitz> ddarius: how about "How to Lex XSLT using Haskell"
15:18:42 <bos> yitz: what?
15:19:16 <sclv_> How to XSLT Haskell using Lex.
15:19:31 <sclv_> 1) Shot web.
15:19:51 <RayNbow> hmm...
15:19:55 <RayNbow> @faq Will it blend?
15:20:04 <RayNbow> oh, lambdabot died
15:20:06 <gwern> sclv_: -_-
15:20:26 <gwern> sclv_: ima chargin' mah credit card!!
15:21:02 <yitz> bos: you said: "for all modestly complicated programming tasks, bash makes you jump through hoops to achieve them". true, except for the main things a shell is designed for. trivial comment. never mind.
15:21:42 <davidL> does haskell have something like python's timeit module (takes a function and returns how long it takes to execute N times)?
15:21:56 <bos> davidL: no.
15:22:00 <ddarius> @hackage microbench
15:22:05 <yitz> bos: but you do get reminded of that when you try to do shell-like tasks using System.Command and such.
15:22:08 <ddarius> Curses!
15:22:29 <bos> davidL: in general, that doesn't even make sense. you could time an IO action, but timing a pure function takes a bit more wile.
15:22:53 <davidL> ddarius: I don't see microbench in hackage =\
15:22:55 <ddarius> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/microbench Maybe
15:23:03 <ddarius> I see it.
15:23:16 <davidL> ah, nvm, thanks ;)
15:23:38 <ddarius> I don't actually know what is in that package though.
15:24:04 <bos> interesting that it would try to estimate how many iterations are needed to get a decent measurement.
15:24:32 <yitz> > 2
15:24:41 <yitz> ping Cale
15:25:08 <davidL> bos: yeah, timeit just uses N=1e6 by default
15:26:06 <yitz> bos: how about using quickcheck to force a pure function to run a given number of times?
15:27:24 <bos> yitz: you wouldn't need quickcheck, just Control.Parallel.Strategies.rnf
15:27:28 <chrisdone> are there any admins of hackage in here who might give me a username so I can upload this word cloud package?
15:28:22 <yitz> bos: true. quickcheck has the advantage (or disadvantage) of averaging the time over varying input.
15:30:57 <yitz> lambdabot's demise happened at almost exactly the same time that ghcbot reported a bunch of build failures on #ghc.
15:34:48 <edwardk> Some days I don't understand reddit.
15:35:01 <ddarius> Every day I don't read reddit.
15:35:09 <edwardk> The screwed up asymptotic analysis of Haskell quicksort gets modded to 16, while the corrected version goes to 0. http://www.reddit.com/info/6s41r/comments/
15:35:12 <chrisdone> ddarius: high five
15:35:40 <dolio> Disliking haskell is fashionable.
15:35:45 <dolio> dons has promoted it too much. :)
15:35:57 <edwardk> Yeah but the screwed up analysis was also positive w.r.t Haskell ;)
15:36:24 <edwardk> All I did was show you can fix the common qsort example to get n log n performance out of it using a difference list.
15:36:35 <dolio> But it allows you to dislike haskell, because it points out a flaw. :)
15:36:45 <ddarius> Gah.  Stop using the term "difference list."
15:36:52 <edwardk> heh
15:37:17 <edwardk> ok, how about 'a screwed up limited form of a Mendler-style recursion scheme'
15:37:26 <edwardk> meh, i'll stick to difference list, its shorter ;)
15:37:37 <ddarius> How about "functional lists"?
15:37:38 <gwern> dlistcious!
15:37:51 <mfp> edwardk: how was it screwed up? it also proved that it was O(n log n) on avg
15:38:05 <edwardk> mfp: it didn't prove that. it thought it did. it counted conses.
15:38:19 <mfp> and?
15:38:21 <edwardk> but you don't pay for conses you pay for every reduction even non-terminal ones.
15:38:32 <edwardk> by its reasoning naive reverse is also linear.
15:38:51 <mfp> it counts conses which give an upper bound for the number of comparisons under a strict semantics
15:39:09 <edwardk> but we aren't under strict semantics so we traverse that set of reductions multiple times.
15:39:31 <mfp> hmm
15:39:41 <dons> regarding haskell pr in general, i'll just point out that 2 years ago we weren't even in the debate.
15:40:09 * mfp reads the article
15:40:37 <edwardk> mfp = eigenclass?
15:40:51 <mfp> yes, I wrote it
15:40:53 <edwardk> dons: very true
15:40:57 <dolio> ddarius: What's wrong with difference list, by the way? Besides the fact that it makes my brain think of something like DiffArray instead of what it actually is.
15:41:32 <ddarius> dolio: Because the term "difference list" comes from Prolog and there it means something only tenuously related (and also there the name makes a lot more sense.)
15:41:46 <dolio> Ah, okay.
15:41:59 <dolio> Now that you mention that, that does ring a bell.
15:42:11 <dolio> But I was never into prolog enough to remember what they mean in that context.
15:42:22 <edwardk> in fact there is a fairly common prolog difference list qsort which is like the one i implemented ;)
15:42:28 <ddarius> They both are schemes for "fast appending," but the properties of Prolog difference lists are rather different from Haskell "difference lists"
15:43:43 <edwardk> I was going to build up a version of this using a Mendler-style recursion scheme for catamorphisms (forced cata/build fusion) in which case you don't have the 'floppy type' that a difference list does (every inhabitant corresponds to a real list)
15:43:53 <edwardk> but this was shorter
15:44:35 <ddarius> edwardk: And more people would be able to read it...
15:44:41 <edwardk> yeah
15:45:27 <EvilTerran> i missed a few lines - what's wrong with "difference list"?
15:45:37 <edwardk> i was surprised when i was searching that i hadn't seen this formulation of haskell qsort before though.
15:45:50 <edwardk> has anyone seen it before?
15:46:52 <ddarius> edwardk: One of the "Concatenate, Reverse and Map Vanish For Free" papers may have it.
15:47:04 <ddarius> I've seen it before though I've probably written it before
15:47:12 <edwardk> ddarius: good. coz it was fairly obvious. =)
15:48:13 <edwardk> mfp: does it make sense that under non-strict semantics that counting conses fails to work?
15:49:25 <edwardk> http://en.literateprograms.org/Quicksort_(Haskell) has a qsort 3 with an explicit accumulator its just not written pointfree.
15:49:44 <edwardk> @src sort
15:50:24 <yitz> edwardk: the bot died a few minutes ago. No sign of Cale to the rescue.
15:50:29 <edwardk> ah well
15:51:11 <mfp> edwardk: I'm still pondering about your reversal with reverse
15:51:40 <edwardk> mfp: profile naive reverse without optimizations on.
15:51:45 <yitz> edwardk: anyway, sort is a mergesort that starts by splitting the list into tiny pieces.
15:51:52 <mfp> the problem is that, even if it invalidates my proof, I'm not observing O(n^2) behavior in practice
15:52:03 <mfp> and you haven't proved that it's O(n^2) either, have you?
15:54:00 <edwardk> I didn't run a proof of it in there. it may not be n^2, but i seem to recall it comes out at least n log^2 n because you retraverse a logarithmic number of applications to reach the conses for the next element under them
15:54:20 <edwardk> the reverse is definition O(n^2) though
15:54:39 <edwardk> because you traverse an average of n/2 applications to reach each cons.
15:54:53 <edwardk> er is by
15:55:35 <mfp> n log^2 n I can believe, that's what I tried to prove first :-)
15:55:41 <edwardk> heh
15:56:06 <edwardk> it also fits with my numbers
15:56:46 <edwardk> the recurrence looks like a bit of a bear to solve correctly though in terms of applications
15:57:16 <edwardk> mfp: have you read chris okasaki's book?
15:57:27 <mfp> this sucks though, I wanted to believe that pretending we have a strict semantics would give upper bounds, following Okasaki's remarks
15:57:29 <mfp> yes
15:57:45 <yitz> edwardk: hmm, hpaste seems to be equally dead. well, the various sort implementations are in http://darcs.haskell.org/packages/base/Data/List.hs, search for "Quick Sort".
15:58:42 <augustss> whee im typing this on my iphpne where a vnc cloent is cpntrollomg my laptppop
15:59:00 <Philippa> I can tell - the on-screen keyboard clearly sucks :-)
15:59:07 <BMeph> Oh, sa an aside, the paper the Janis referenced in the "...Vanish for Free" paper is at: http://citeseer.ist.psu.edu/albert00improving.html
15:59:14 <dobblego> can I use unfoldr in a source file, without using an import; e.g. Data.List.unfoldr ... ?
15:59:21 <augustss> Philippa: it sure does :)
15:59:45 <yitz> augustss: sounds like there are better ways to irc from an iphone.
15:59:55 <edwardk> mfp: i'll see if i can prove the n log^2 n average case under non-strict semantics. its probably easier in the mendler style scheme though.
15:59:55 <Philippa> augustss: that's my biggest reason for avoiding convergence devices so far, though I'm going to have to replace my zaurus sometime
15:59:59 <augustss> yitz: there might be
16:00:06 <BMeph> dogbblego: That is an import, heh-heh. But that looks like a valid ref. :)
16:00:09 <yitz> dobblego: no. only in ghci
16:00:17 <dobblego> ok cheers
16:00:23 <Philippa> still. Shiny toys shiny, etc etc
16:00:27 <Philippa> 'lo Smokey`, LTNS
16:00:28 <BMeph> yitz: Really?
16:01:45 <yitz> yeah. you'll say Data.List.unfoldr if the import is qualified, but you still need the import.
16:02:21 <mfp> the recollection of this is what misled me: "Programmers in such (non-strict) languages are often reduced to pretending the language is actually strict to make even gross estimates of running time!"
16:03:36 <mfp> edwardk: looking forward to it
16:09:44 <Smokey`> hey Philippa :)
16:12:03 <yitz> @botsnack
16:12:10 <lambdabot> :)
16:12:18 <RayNbow> @faq Will it blend?
16:12:22 <BMeph> yitz: No smiley 4 j00! ;)
16:12:26 <lambdabot> The answer is: Yes! Haskell can do that.
16:12:35 <yitz> @vixen welcome back
16:12:42 <lambdabot> you sir are no gentleman
16:13:06 * RayNbow can't wait for the apparance of the Haskell Blender package on hackage
16:13:28 <RayNbow> *appearance
16:17:31 <dons> slarba: another point, realToFrac :: Int -> Double, is inefficient. use fromIntegral.
16:18:00 <dons> it's fixed in GHC HEAD, but you're likely not using that.
16:18:06 <stepcut> hrm, getting listed on planet haskell is hard. Maybe I can just buy a blog from someone who is already listed ;)
16:18:17 <augustss> is it?
16:18:28 <edwardk> stepcut: it just takes forever, its not hard ;)
16:18:39 <stepcut> edwardk: ah
16:18:55 <stepcut> but I want to publish *now*
16:18:58 <dons> hmm. i'm supposed to have access to p.h.o's admin stuff
16:19:03 <stepcut> heh
16:19:05 <dons> i should look at how i use that.
16:19:22 <edwardk> Heh, well for a reasonable fee, I'd be willing to sell the comonad.reader... meh, nah.
16:19:33 <BMeph> dons: Any reason why you give that advice (i.e., is this a discovered flaw, or an intentional quirk)?
16:19:38 <stepcut> edwardk: :p
16:20:35 <BMeph> edwardk: Do it! Just make a c-e write-up part of the price. ;)
16:20:53 <BMeph> Write-up in advance, too, heh-heh. :)
16:20:55 <edwardk> heh
16:21:53 <dons> BMeph: realToFrac just has a generic implementation in 6.8.x and older.
16:21:55 <newsham> I'm looking for a short/simple comparison of OO organization vs. haskell-style type classes..  I think I saw one before but i dont remember enough details to find it again
16:22:07 <dons> it can mean a 50x slow down when using realToFrac in a tight loop
16:22:24 <dons> so just use fromIntegral
16:22:55 <Pseudonym> ?fact-set ghc-head http://arcanux.org/lambdacats/fixed-in-head.jpg
16:22:55 <lambdabot> Fact recorded.
16:23:03 <dons> :)
16:23:15 <Pseudonym> Now you have a standard answer.
16:23:24 <dons> true as it ever was.
16:23:58 <dons> i'm putting this up in the office here, Pseudonym :)
16:24:13 <Pseudonym> :-)
16:24:22 <Pseudonym> I think I have the full-res version somewhere if you want me to mail it to you.
16:25:40 <Pseudonym> No, apparently I don't.
16:25:43 <dons> it looks pretty good
16:26:28 <BMeph> dons: This is changed in HEAD, already, I gather?
16:26:37 <dons> BMeph: yes.
16:26:55 <dons> RULE realToFrac :: Int -> Double = int2Double
16:26:59 <dcoutts> @seen SyntaxNinja
16:26:59 <lambdabot> SyntaxNinja is in #haskell-blah and #haskell. I don't know when SyntaxNinja last spoke.
16:27:09 <dons> he just went to get his bike.
16:27:21 <RayNbow> hmm, http://comonad.com/reader/2008/a-sort-of-difference/ reminded me of http://pseudo.fixme.fi/~opqdonut/blog/Fast_concatenation.html
16:27:22 <dons> dcoutts: he'll be back in a minute, but is on his way out.
16:27:23 <lambdabot> Title: The Comonad.Reader  A Sort of Difference
16:27:30 <dcoutts> dons: 'k
16:27:55 <chrisdone> I just spent like 15 minutes figuring out why “cloudClonf” was “not in scope”, trying all sorts of changes in my code :P
16:29:24 <dobblego> @src foldr1
16:29:24 <lambdabot> foldr1 _ [x]    = x
16:29:24 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
16:29:24 <lambdabot> foldr1 _ []     = undefined
16:29:31 <dobblego> where isn't that defined using foldr?
16:31:01 <dons> dcoutts: want to speak to him?
16:31:18 <dcoutts> dons: well, only if it's convenient
16:31:21 <chrisdone> dobblego: I'd bet it's defined as such in Data.Foldable
16:31:24 <dons> he's right here.
16:31:36 <SyntaxNinja> hi dc
16:31:40 <SyntaxNinja> dcoutts
16:31:42 <dcoutts> SyntaxNinja: yo :-)
16:32:26 <Pseudonym> RayNbow: Also checkout Data.Sequence for nicely-wrapped fast concatenation.
16:33:49 <Pseudonym> Hmm, where does LicensedPreludeExts live now?
16:33:56 <chrisdone> dobblego: http://haskell.org/ghc/docs/latest/html/libraries/base/src/Data-Foldable.html#(line118)
16:33:57 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/56j5vg
16:34:03 <Pseudonym> There's also a fast concatenation sequence thingy there.
16:34:10 <chrisdone> HsColour really needs to add relevant titles, eh?
16:34:46 <dobblego> chrisdone, cheers
16:35:04 <chrisdone> :)
16:35:32 <mar77a> heh i read a gentle introduction to haskell yesterday night
16:35:41 <mar77a> after some months of reading it for the first time
16:35:54 <mar77a> it's like
16:36:02 <mar77a> it's good to settle things down in your head
16:36:07 <mar77a> but definitely not good for a starter
16:37:45 <Pseudonym> What's not often appreciated is that you can mechanically derive the continuation implementation of sequences with O(1) append.
16:37:47 <yitz> mar77a: a few years ago that and the report were pretty much all there were online.
16:38:08 <chrisdone> Pseudonym: are those fast concatenation thingies based on functions sort of that return a function that takes something to cons to? like mystring = (\r -> 'f' : 'o' : 'o': r) and mystring2 = (\r -> 'b' : 'a' : 'r' : l) and appending them to a final String is `mystring mystring2 []'?
16:38:29 <Pseudonym> Yes.
16:38:30 <chrisdone> Pseudonym: whoops, made a mistake there, but generally
16:38:35 <mar77a> it's a good tutorial
16:38:41 <mar77a> just a bit misleading since it's not gentle at all
16:38:46 <edwardk> chrisdone: same trick
16:39:23 <yitz> mar77a: nor is it an introduction
16:39:30 <chrisdone> edwardk: very sweet trick
16:39:44 <edwardk> chrisdone: its actually an instance of a more general schema that works for other functors, which i need to get around to blogging about
16:39:47 <mar77a> exactly :p
16:39:59 <chrisdone> edwardk: I'd be interested in reading that :)
16:40:29 <ddarius> Pseudonym: You can more than mechanically derive it.
16:40:43 <chrisdone> edwardk: is there a class, or do you think there could be a class, for generalising this kind of clever appending?
16:41:13 <edwardk> chrisdone: you can view it as a particular case of cata/build fusion where you've partially applied 'cata' by fixing the case for 'Cons' to be 'Cons' =)
16:41:49 <edwardk> @type foldr (:)
16:41:50 <lambdabot> forall a. [a] -> [a] -> [a]
16:42:35 <yitz> @src (++)
16:42:36 <lambdabot> []     ++ ys = ys
16:42:36 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
16:42:36 <lambdabot> -- OR
16:42:36 <lambdabot> xs ++ ys = foldr (:) ys xs
16:42:36 <lambdabot> -- In lambdabot, this is generalised to:
16:42:38 <lambdabot> (++) = mappend
16:43:33 <mfp> edwardk: have you seen the comments I've left on reddit and your blog? (argh, should pick one)
16:43:37 <edwardk> > foldr (:) " World" "Hello"
16:43:38 <lambdabot>  "Hello World"
16:44:38 <RayNbow> Pseudonym: I have Data.Sequence used before :) (sorry for the late reply)
16:44:54 <edwardk> The reverse example simply shows that you can't count conses, which was all I was using it to motivate.
16:47:32 <mfp> edwardk: it shows is that one must not forget the conses implied by list concatenation, doesn't it?
16:47:56 <edwardk> correct
16:48:08 <mfp> in this case, the number of conses is  C(n) = C(n-1) + n - 1 + 1  -> thus O(n^2)
16:48:29 <edwardk> mfp: so can we go back and apply that to the qsort version
16:48:29 <mfp> I did take them into account for the qsort analysis
16:49:11 <edwardk> then why does your haskell version start to lose by a wider and wider margin to your ocaml version ;)
16:49:26 <mfp> the recurrence is C(n) = C(p) + p + 1 + C(q) + q + 1  with n = p + q - 1
16:49:40 <mfp> well, that's only 1 data point for n=3e6
16:50:04 <mfp> I attributed that to Haskell using much more memory and decreased locality
16:50:14 <edwardk> yeah but i see the same drift in relative performance
16:50:33 <mfp> compared to the other quicksort, OK
16:51:31 <mfp> But then where's the error in the analysis? The one you pointed to was orthogonal to the strictness issue, and didn't happen in the first place.
16:51:41 <edwardk> fair enough
16:52:01 <edwardk> So lets go through it
16:52:19 <edwardk> I don't purport to know the answer here. =)
16:54:37 <RayNbow> just posted by bos... http://www.reddit.com/r/programming/info/6s4qt/comments/ "The expression lemma explained (blogs.msdn.com)"
16:54:37 <lambdabot> Title: programming: The expression lemma explained
16:56:06 <chrisdone> wish someone would explain loeb
16:56:26 <edwardk> chrisdone: the paradox? or the function?
16:56:49 <chrisdone> function
16:58:31 <edwardk> will do after i figure out how the analysis of mfp's function =)
16:58:42 <chrisdone> hehe
16:58:58 * chrisdone watches office space for the first time
16:59:04 <mfp> edwardk: hmmm do you know some example of an analysis under a strict semantics _not_ being applicable with a non-strict one?
16:59:22 <mmorrow> what was the def/type of loeb again?
16:59:39 <edwardk> mfp: honestly i was at work when i saw your post and had misrecalled chris okasaki's words on the topic.
17:00:24 <mmorrow> i recall it being something like :: (Functor f) => f (f a -> a) -> a
17:00:27 <mmorrow> ?
17:00:40 <edwardk> its cofix or something like that
17:01:23 <mmorrow> found it
17:01:28 <mmorrow> let loeb x = fmap ($ loeb x) x
17:01:33 <mmorrow> http://www.haskell.org/haskellwiki/Blow_your_mind
17:01:33 <lambdabot> Title: Blow your mind - HaskellWiki
17:01:44 <mmorrow> let loeb x = fmap ($ loeb x) x in   loeb [ (!!5), const 3, liftM2 (+) (!!0) (!!1), (*2) . (!!2), length, const 17]
17:01:46 <mmorrow> > let loeb x = fmap ($ loeb x) x in   loeb [ (!!5), const 3, liftM2 (+) (!!0) (!!1), (*2) . (!!2), length, const 17]
17:01:47 <lambdabot>  [17,3,20,40,6,17]
17:02:04 <mmorrow> :t let loeb x = fmap ($ loeb x) x in loeb
17:02:04 <lambdabot> forall (f :: * -> *) b. (Functor f) => f (f b -> b) -> f b
17:02:13 <mfp> my recollection of Okasaki was that strict _ served as an upper bound for non-strict (then he went on to improve significantly on that bound with his improved banker's and physicist's methods
17:02:52 <edwardk> mmorrow: yeah. i think i may have been conflating something he said with the traditional accumulating parameter problem of generating an enormous thunk and hence space leak)
17:03:10 <edwardk> i can't find the book (just got home)
17:03:38 <mmorrow> (i take that that was @mfp)
17:03:44 <edwardk> ueaj
17:03:47 <edwardk> er yeah
17:03:48 <edwardk> =)
17:03:50 <mmorrow> heh
17:03:59 <mmorrow> ueaj: "the new yes"
17:04:22 <Cale> heh, we should adopt that as a spoken word :)
17:04:44 <mmorrow> totally. and pronounce it differently each time
17:04:49 * Pseudonym can't wait to see the Roger Dean album cover for ueaj
17:05:56 <yitz> Cale: ursj
17:06:02 <mfp> I can't find anything stating that it's an upper bound, the best I've found so far is p 59. "historically, the most common technique for analyzing lazy programs has been to pretend that they are actually strict. However, this technique is completely inadequate for analyzing lazy amortized data structures."
17:07:04 <edwardk> mfp: hrmm
17:07:27 <edwardk> mfp: i'm more than happy to lose this point. i just can't seem to make the data fit ;)
17:08:43 <mmorrow> looks like hpaste has the sickness
17:09:26 <mmorrow> ping: unknown host hpaste.org
17:09:29 <mfp> edwardk: I don't really care about qsort anymore :P but would love to know for sure if eager analysis can serve as a bound for the non-strict case
17:10:43 <dons> dcoutts: its frustrating that Maybe (Int, ByteString) won't unpack Int
17:10:53 <edwardk> mfp: likewise
17:10:54 <mfp> if it cannot, I'll have to read Okasaki again and do everything the hard way instead of performing the simpler strict analysis and stopping there when I get a satisfying bound :)
17:11:00 <edwardk> mfp: heh
17:11:23 <dcoutts> dons: oh the Maybe you mean? because it's always generic and not specialised to (Int, ByteString)
17:11:40 <dons> yeah. so the Int can't be done as an Int#
17:11:44 <dcoutts> dons: can't it ever do that? even with worker wrapper?
17:11:49 <dons> for tight loops this is a 20% difference.
17:11:51 <dons> that's nested CPR
17:12:02 <dcoutts> dons: mm
17:12:03 <dons> with enough inlining, we might get there.
17:12:05 <dons> i wonder.
17:12:15 <dons> but I don't really want to inline the entire parser
17:12:17 <dons> hmm
17:12:17 <dcoutts> dons: no, it's not just inlining I think
17:12:20 * shepheb_ imagines someone giving CPR, who is themself receiving CPR...
17:12:46 <dons> yeah, no I want Just (n, x) -> JustI Int# ByteString#
17:12:54 <dons> doing that by hand works well.
17:12:55 <dcoutts> dons: the tricky thing is the disjunction, it has to allocate a Just on the heap at the moment, always
17:13:03 <dons> yeah, that's fine.
17:13:11 <dons> its the D# or I# field that then needs to be taken apart
17:13:15 <dons> which hurts a bit
17:13:18 <dcoutts> right
17:13:25 <dons> might be the difference between us and Clean in the sum-file test.
17:13:37 <dons> since I get a 20% improvement with specialisation
17:13:39 <mfp> edwardk: I'll keep an eye on your blog & tell you if I find something
17:13:59 <dons> if only we could ask to specialise and unpack polymorphic types
17:14:08 <dcoutts> dons: right, of course one has to be careful, it's not always a pay off, only if it's used immediately in a case
17:14:14 <dons> yep
17:14:18 <dons> inner loops
17:14:43 <dcoutts> dons: so yes, an extension of CPR as you say
17:14:44 <mfp> dons: haha such is human nature. GHC is doing a zillion nifty optimizations and you keep asking for more ;-))
17:15:00 <dcoutts> dons: and thus an extended worker/wrapper transform
17:15:01 <dons> right.
17:16:01 <dcoutts> dons: you'd want to arrange that if the wrapper ended up being used, that it'd eliminate with the worker via a case of case
17:16:02 <dons> dcoutts: would the world fall over if I changed the return types of D.B.C.readInt and readDouble ? :)
17:16:16 <dcoutts> dons: yes :-) hands off
17:16:20 <dons> bah!
17:16:23 <dcoutts> ;-)
17:16:28 <dcoutts> solve it more generally
17:16:38 * dons sees if i can tweak it through with enough inlining, now i know what's going on.
17:16:45 <dons> inlining and bangs.
17:17:13 <dcoutts> dons: we can write a paper on it in the autumn
17:17:21 <dons> hmm!
17:17:22 <dcoutts> along with worker wrapper for -> types
17:17:24 <dons> that's not a bad idea.
17:17:35 <dons> i'd really like nested CPR to work.
17:17:39 * dcoutts wants to unpack/specialise -> types
17:17:42 <dons> yeah.
17:17:47 <dcoutts> like the kind you get in cont monads etc
17:17:51 <dons> if [Char] -> [!Char]
17:18:02 <dcoutts> eg changing  Int -> Foo, to Int# -> Foo
17:18:02 <dons> ok. good idea.
17:18:02 <edwardk> mfp: hrmm. one thought is the naive version creates and has to collect a lot of intermediate lists which may be where we start to see the practical performance hit
17:19:48 <mfp> oh! got an idea
17:20:01 <edwardk> ?
17:20:11 <mfp> what if we're observing O(n^2) behavior of the GC, with a small constant for the higher order term?
17:20:28 <dons> dcoutts: yeah, it just isn't possible to get ghc to fix up Just's components.
17:20:46 <dons> products would be fine.
17:20:50 <dons> they'd just get taken apart.
17:20:51 <dcoutts> dons: right
17:20:59 <edwardk> it doesn't even have to be O(N^2) it could even be O (n log n) or since its in terms of O (n log n) data to begin with
17:21:01 <dons> Nested Sum Analysis!
17:21:05 <dcoutts> @yarr!
17:21:05 <lambdabot> I heard andersca is a pirate
17:21:12 <bos> how long before we get a hugs port to the iphone?
17:21:15 <dons> bit tag in reg1, result in reg2
17:21:36 <dons> bos, it was under discussion last week.
17:21:37 <dons> ghc actually.
17:21:44 <dons> stepcut is in charge.
17:21:55 <dons> he was trying to sort out an iphone hackathon
17:22:02 <dons> down your way, iirc.
17:22:02 <dcoutts> dons: that's more than just specialising and unpacking Maybe
17:22:03 <bos> i'd be impressed if ghc could make it.
17:22:20 <shepheb_> I've been working with GHC on ARM
17:22:29 <dons> well, you wouldn't necessarily put ghc *on* the phone. in the development env though.
17:22:29 <dcoutts> dons: that's a custom calling/return convention for sums
17:22:31 <shepheb_> don't know if it would fit on an iPhone, don't know the specs.
17:22:40 <shepheb_> it's troublesome since GHC's bootstrapping is broken
17:22:45 <thetallguy> I think that was an ARM hackathon
17:22:45 <lambdabot> thetallguy: You have 1 new message. '/msg lambdabot @messages' to read it.
17:22:51 <dons> dcoutts: yeah. its a new transformation
17:22:57 <dcoutts> dons: indeed it's an unlifted sum
17:23:07 <mfp> yeah I don't think the implementors would tolerate O(n^2), but say O(n log n + n) with a low enough constant is conceivable
17:23:11 <dcoutts> dons: which afaik doesn't exist yet in ghc as a concept
17:23:15 <dons> Maybe (Int, Bool) -> (# Tag, (# Int#, ..  #) #)
17:23:25 <dons> unlifted sums in general, hmm.
17:23:37 <dons> now that would be an interesting paper.
17:23:47 <dcoutts> unlifted sums might be a good way to explain a nested cpr transform
17:23:50 <mmorrow> i love the dataToTag :: a -> Int# function
17:23:52 <dons> all those nice early 90s papers on unboxedness. then nothing for 15 years.
17:23:55 <dons> maybe its time to revisit!
17:24:00 <dcoutts> @yarr!
17:24:01 <lambdabot> I'll crush ye barnacles!
17:24:09 <thetallguy> ouch
17:25:38 <mfp> the easiest way to test this conjecture would be to create a benchmark with similar mem access patterns but a clearly O(1) algorithm, and see if it's 100% linear for different mem usages
17:25:40 <dons> dcoutts: so generalised constructed results.
17:25:46 <dons> dcoutts: for the nested case, and the sum case.
17:26:07 <dons> so that, (x , (y , z)) would work, as would Either (x,y) a
17:26:26 <dcoutts> dons: mm
17:26:43 <dons> which would need unlifted sums.
17:27:01 <dons> the CPR guys were lucky (#, #) was already implemented
17:27:07 <edwardk> ok, hypothesis
17:27:37 <edwardk> we get large enough we trip the mark and sweep garbage collector, because we get big enough to not fit into the copying collector which is used when you have a lot of memory free
17:28:18 <dcoutts> dons: you can be less radical and just specialise Either (x,y) a
17:28:45 <mfp> I don't know GHC's GC; does it use a copying GC for the minor heap + an incremental mark & sweep for the major, like OCaml, or does it have more generations?
17:28:54 <dcoutts> dons: giving Either' = Left' x y | Right' a
17:29:10 <dcoutts> dons: and perhaps further #'ing if you know the types of x or y
17:29:26 <edwardk> once you are in mark and sweep a mark and sweep collector is basically a mark loop and a sweep loop. a mark loop should be n log n in terms of data because its mark p = unless (marked p) $ do mark p; mapM mark $ eachObjectReferencedBy p
17:29:28 <mfp> even with an incremental mark & sweep, the complexity would depend on how it estimates the amount of work to be performed in the major heap
17:29:45 <leoncamel> hey . folks . how can I set "-x" for ld in ghci ?
17:29:53 <edwardk> (thats pseudocode, but just following the general model for mark in mark and sweep)
17:30:08 <edwardk> er typo
17:30:27 <edwardk> mark p = unless (marked p) $ do setMarked p; mapM mark $ eachObjectReferencedBy p
17:30:39 <edwardk> heh it was going to take a LONG time otherwise ;)
17:30:48 <edwardk> but thats a tree traversal
17:31:20 <mfp> uhm if you take "incremental" away from mark & sweep, it's O(n^2)
17:34:09 <dons> dcoutts: also, remember that now, after a case analysis, the constructor is written into the lower bits of the ptr.
17:34:24 <dcoutts> dons: yes
17:34:30 <mulletron> if I have an unmodifiable library function which takes as an argument a function in the IO Monad e.g. (String -> IO Int) is there a way to lift the type of the argument s.t. I can use a transformed monad (e.g. of type StateT String IO)?
17:34:36 <dcoutts> dons: so it's kind of partial unboxing
17:34:47 <dons> we kind of want to short cut to that. don't allocate on the heap at all. don't produce a thunk. just give me the tag, and the components.
17:34:51 <dcoutts> dons: but we know it cannot be an unevaluated thunk of course
17:35:00 <dons> sicne i'll immediately need it.
17:35:14 <edwardk> mfp: i'll have to chew on it some more. i'll check in with you tomorrow and let you know if i have something but the fact that we do have to do something non-linear in terms of the amount of intermediate garbage is interesting.
17:35:28 <dons> i should make a ticket about this general sums problem, as we see it with readInt
17:35:36 <dons> since its a bit different to the nested CPR issue
17:36:04 <edwardk> it also says that you might be able to affect asymptotic performance of algorithms by working in a region allocated language because of the O(1) collections
17:36:39 <edwardk> which makes sense and i'd used it as an argument for region allocation before, but i hadn't thought in terms of super-linearities in the collector.
17:37:08 <edwardk> in the meantime i'd better spend some time with my wife tonight =-)
17:37:51 <dolio> Unlifted sums could be something like tag + C-like union.
17:37:58 <ddarius> edwardk: wife > haskell
17:38:07 <mfp> it's late in this timezone, so I'm leaving too :)
17:38:23 <dolio> Where you just have a blob the size of the largest alternative.
17:38:25 <edwardk> yep. wife 1, haskell 0 =)
17:38:36 <dolio> And the tag tells you which alternative it is.
17:39:44 <dolio> Although if you're immediately doing case analyzis, isn't that constructor specialization territory?
17:40:02 <dons> that's for loops, but it is similar.
17:40:17 <dons> we want to see that one function's returned value is immediately inspected, and thus can be kept in registers
17:40:21 <dons> even for sums.
17:40:42 <dons> so its a generalisation of the constructed product results transformation.
17:40:48 <dons> to sums :)
17:41:18 <dons> dcoutts: i think Clean's readDouble returns a triple, fwiw. (Bool, Int, String)
17:41:29 <dcoutts> dons: ah right
17:41:35 <dcoutts> dons: so it gets CPRd
17:41:40 <dolio> I suppose splitting the branch into separate functions coudl cause code duplication.
17:41:57 <dons> sumints f sumi # (ok,i,f) = freadi f | not ok = sumi = sumints f (sumi+i)
17:41:59 <dons> yeah, that's easy.
17:42:03 <dons> bunch of cheaterers :)
17:42:20 <dons> i wonder if they intentially eschew Maybe, for speed.
17:42:31 * bos pokes around at the mystery of ghc's build process building haddocks, but then not installing them.
17:42:53 <mmorrow> dons/dcoutts : what's a good paper to read on the cpr transformation?
17:42:53 <ddarius> What are the Int and String in the two cases?
17:42:58 <dons> so that's one of the things the Clean sum-file does that GHC's doesn't. which explains much of the final gap.
17:43:03 <dons> ddarius: for a parsing function?
17:43:29 <ddarius> Shouldn't readDouble return a Double somehow?
17:43:32 * dons has a slightly lower opinion of Clean's compiler now.
17:43:44 <dons> readDouble :: ByteString -> Maybe (Double, ByteString)
17:43:47 <dcoutts> mm_freak: http://citeseer.ist.psu.edu/baker-finch00constructed.html
17:44:15 <mmorrow> dcoutts: thx
17:44:18 <dcoutts> oops, I didn't mean mm_freak, I mean mmorrow :-)
17:44:24 <mmorrow> ;)
17:44:30 <dcoutts> mm_tab-completion :-)
17:44:46 <dons> Clean doing (ok,i,f) = freadi f
17:45:12 <dolio> dons: How'd you implement that? Are you calling C, or did you actually write a double parser?
17:45:13 <dons> is just yucky. Haskell does look pure, if even Clean sells out on parsers not returning Maybe.
17:45:21 <dons> dolio: i'm writing a double parser, yeah.
17:45:26 <dolio> Wow.
17:45:32 <dons> though i called C earlier. but FFI is too slow.
17:45:38 <dons> dolio: not so wow, ghc already has one.
17:45:46 <dolio> Ah, that's true.
17:45:57 <dons> and alex will spit them out on demand
17:46:16 <dolio> Yeah, the thing with calling C is (I think) you'd have to use useAsCString which still results in a lot of copying.
17:46:34 <dolio> Not as much as unpack, but still bad.
17:46:42 <dons> which while enough to defeat Python, still takes my 50M input from 0.9s to 30s
17:46:50 <dons> yep.
17:47:02 <dons> hence I had to write my own, since strtod /= strtond
17:47:15 <dons> strntod is actually in solaris, curiously.
17:47:26 <dolio> Yeah. Dumb ol' C.
17:47:48 <dons> it means most of the str* functions aren't useful to us.
17:48:02 <dons> and there's no memtod
17:57:46 <ecks> whoever created an account for me on code.haskell.org, id like to thank them
18:01:51 <dons> dcoutts: and (Bool, Int, ByteString) doesn't work as it is nested.
18:02:05 <dons> ghc can't see though (,) (I#)
18:02:12 <dons> to the Int# at the bottom.
18:02:24 <dons> we'd have to unpack the product one level.
18:02:54 <dolio> Yeah, nested CPR doesn't get done at all in my experience.
18:03:02 <dolio> Even (# Bool, Int, ByteString #) wouldn't work.
18:03:13 <dons> no, it doesn't work. it isn't implemented.
18:03:26 <dons> data T !Int ... is the way to get this done currently.
18:03:36 <dolio> The only way is to make a custom strict product.
18:03:43 <dons> that'll get returned in registers.
18:03:44 <dolio> Yeah.
18:03:57 <dons> it can't be polymorphic
18:04:02 <dolio> Right.
18:04:09 <dons> if it is, then the nested CPR that's missing won't kick in. since its missing.
18:04:35 <dons> and if we put a sum in front, then we'd also fail, since CPR is for Ps  not Ss.
18:04:54 <dolio> Oh, is that what the P is for?
18:05:01 <dolio> I don't actually know what the acronym means.
18:05:01 <dons> the P is for Product :)
18:05:20 <dons> "Constructed Product Results (will be eliminted)"
18:05:29 <dolio> Ah.
18:05:45 <dons> i'd have called it the Deconstructed Product Result analysis.
18:05:59 <dons> like strictness analysis isn't known as Laziness Analysis.
18:06:16 <dons> well, hmm, i guess that does make sense.
18:06:25 <dons> its hunting for constructed products, and doing something cool with 'em.
18:07:03 <dons> so analyis passes get named after the thing they're looking for.
18:07:30 <dons> while transformations are named after the thing to which we transform. like pointer tagging.
18:07:41 <dolio> You might do laziness analysis in an eager language.
18:07:46 <dolio> Except no one does. :)
18:08:03 <dons> or "thunk transformations" if we view analsyis / transformation as duals.
18:08:18 <dons> CPR analysis / deCPR transformation
18:08:18 <jsnx> allbery_b: is there a way to start a shell such that it executes commands written to /proc/PID/fd/0
18:08:19 <mar77a> thunks are the internal data stored by the interpreter/compiler used to generate data "lazily", correct?
18:08:22 <jsnx> ?
18:08:42 <dons> mar77a: they're the objects on the heap that represent suspended computations, yep.
18:09:13 <mar77a> how inefficient can they be performance wise as opposed to the benefits which you can get code-wise
18:09:23 <mar77a> eh well, efficient
18:09:31 <mar77a> why aren't they "manually" implemented in other languages
18:09:32 <dons> they can be a significant overhead if you have a tight loop allocating thunks.
18:09:42 <mar77a> i can see myself writting lazy C++
18:09:43 <dons> or they can be very useful if you have a large computation you don't need.
18:10:01 <dons> main = do let _ = solve_halting_problem ; print ()
18:10:11 <dons> -- thunks are infinitely efficient :)
18:10:29 <mar77a> and finitely inefficient
18:10:36 <dons> right.
18:10:38 <mar77a> for "almost all" problem
18:10:39 <mar77a> :D
18:10:45 <mar77a> problems hmmhmh
18:10:56 <dons> so strict programs might get somewhat slower. but lazy programs become possible.
18:11:04 <dolio> Are you sure you could see yourself writing lazy C++? :)
18:11:08 <dolio> Lazy D maybe...
18:12:27 <dolio> Although maybe with boost-like hackery you can make doing laziness in C++ not a pain in the ass as well.
18:12:40 <dolio> Or, a different kind of pain, at least.
18:12:45 <mar77a> well isn't GHC written in C or something
18:12:56 <dolio> Mostly haskell.
18:13:01 <dolio> The runtime system is in C.
18:13:09 <mar77a> ca $hing
18:13:10 <dolio> (I think.)
18:13:25 <jsnx> dolio: the pain of unreadable, multi-kilobyte compiler errors
18:13:41 <dolio> jsnx: That's what I was thinking of. :)
18:14:47 <ddarius> A kilobyte of text is not all that much.
18:15:21 <ecks> would anyone know on code.haskell.org if we are allowed to make our own directory under /srv/code or we need an admin to do it?
18:15:34 <jsnx> ddarius: you are right, i am a goon
18:15:46 * jsnx tazes himself
18:16:08 <allbery_b> jsnx: generally the access control on /proc/$$/fd/* are such that you can't do that, even as root
18:16:21 <dolio> augustss told me that dpiponi got a 50M error message from a C++ compiler once.
18:16:26 <mmorrow> mar77a: the parts of the rts that require beyond what C can handle are in cmm (==c--) though
18:17:32 <jsnx> allbery_b: permissions are not the problem for me
18:17:42 <jsnx> allbery_b: i can write in my terminal windows just fine
18:17:48 <allbery_b> what exactly are you trying to do?
18:17:56 <jsnx> but it just dumps the stuff right in, no execution at all
18:18:06 <jsnx> allbery_b: demo message passing
18:18:39 <mmorrow> jsnx: maybe you can do something with mkfifo
18:18:44 <allbery_b> right, it doesn't hook up the way you want.
18:18:51 <allbery_b> I think you need to use a fifo for that
18:19:06 <jsnx> mmorrow: yeah, i'm doing that now
18:19:13 <mmorrow> you can do some pretty cool stuff with fifos and shell
18:19:22 <allbery_b> (but fifos have their own problems and idiosyncracies)
18:19:29 <mmorrow> heh
18:19:44 <jsnx> i just though doing with proc would be so cute, you know
18:20:39 <mmorrow> hehe. the thing i love about shellscripts is that they're so hackish to begin with, anything is game
18:21:35 <allbery_b> unfortunately /proc/*/fd doesn't allow for arbitrary plumbing.
18:22:04 <allbery_b> not sure that would be possible, you'd have to rearrange the process's fds out from under it.  if it's using stdio, that is nearly suicidal
18:22:05 <jsnx> yeah
18:22:14 <jsnx> mmorrow: indeed
18:22:30 * allbery_b doesn't consiuder shell scripts hackish
18:22:47 <allbery_b> shell is the ultimate "glue things together to make a a program"
18:23:05 <mmorrow> "..by whatever means necessary" ;)
18:23:12 <allbery_b> http://www.amazon.com/Unix-Programming-Environment-Prentice-Hall-Software/dp/013937681X
18:23:15 <lambdabot> http://tinyurl.com/6leo7a
18:23:31 <allbery_b> read it.  learn it.  live it.
18:24:05 <allbery_b> (the great irony is that this programming methodology is ultimately what's behind ActiveX, just with fancier IPC)
18:24:36 <mmorrow> allbery_b: "hackish" is a good sense
18:24:38 <jsnx> allbery_b: yeah, i have that book
18:24:42 <mmorrow> s/is/in/
18:24:50 <allbery_b> COM/ActiveX, SOM (IBM), CORBA, Bonobo (GNOME), DCOP (KDE), etc.
18:25:26 <allbery_b> pipes are a bit limited as an ipc mechanism, fifos don't actually help the situation, you end up with mailboxes or sockets
18:25:52 <allbery_b> (I could argue that /bin/sh is the Visual BASIC of UNIX)
18:27:09 <jsnx> allbery_b: the difference between pipes and CORBA, ActiveX, all that stuff, is their OOness
18:27:22 <jsnx> they have validation of a kind, and allow method calls on the thingies
18:29:34 <allbery_b> not really.  you can develop an OO protocol over pipes
18:29:46 <allbery_b> there's just no point because pipes are one-way and fixed endpoint
18:30:13 <allbery_b> but there are (rare) programs out there which run an OO protocol over pipes
18:30:32 <jsnx> so what do you see the difference as?
18:31:05 <jsnx> i mean ActiveX doesn't send plain bytes, right?
18:31:17 <allbery_b> no, it uses an object protocol
18:31:40 <allbery_b> the thing is, pipes don't let you have general services; you need to hook things together explicitly, one-to-one.
18:31:40 <jsnx> and it enforces it?
18:32:22 <allbery_b> fifos fix that but at the cost that you can't detect or handle interleaved I/O, or detect the end of a message (without encoding it into the communication protocol)
18:33:28 <jsnx> well, yeah
18:33:29 <allbery_b> once you move to mailboxes or sockets you have a basis to handle messages; that is the minimum you need to implement a reliable communication protocol, at whioch point you can write an OO layer in top of the messaging system
18:33:34 <weilawei> anyone else having trouble with real world haskell's DNS not resolving?
18:33:46 <weilawei> i'd finished chapter 3 and i want to continue
18:34:06 <allbery_b> you can do this on unix but there are few standards (there is CORBA but it's heavyweight)
18:34:26 <jsnx> allbery_b: well, as long as you have a parser, FIFOs should be enough
18:34:49 <weilawei> and i have some other questions to throw out. how good is haskell at doing parallel/distributed programming? and are there any impls for lock-free algorithms?  both are pretty key to stuff I do in other languages
18:34:51 <allbery_b> so there's the Bonobo and DCOP frameworks, and DBus which is expected to subsume them
18:35:06 <allbery_b> jsnx: not really.  you still haver the porblem that the system won't handle interleaved I/O
18:35:41 <allbery_b> writes to FIFOs aren't fully atomic
18:35:54 <allbery_b> so if two processes write into the same FIFO you can get garbage on the far end
18:36:24 <weilawei> no lock-free fifo? :'(
18:36:32 <allbery_b> typically on Unix you end up moving to AF_UNIX sockets to deal with this, but then you can't just write to it
18:36:53 <mmorrow> allbery_b, jsnx: since hpaste is down, i put this here: http://code.haskell.org/~morrow/code/bash/fifos.txt
18:36:55 <allbery_b> fifos never really caught on because of that
18:37:09 <mmorrow> connecting fifos is easy
18:37:39 <mmorrow> you could make an arbitrarily complex graph/network of them if you desired (i've always wanted to do something like that)
18:38:13 * mmorrow catches up on the fifo discussion
18:38:18 <allbery_b> (strictly speaking:  as long as the total queued data in a FIFO is less than the system PIPE_BUF value (traditionaly 512 bytes, generally larger on linux) you have atomic writes.  if the queued data goes over that, not atomic any more
18:39:08 <allbery_b> so if two processes write 300 bytes each, one of them wil block in mid-write write and the two chunks are liable to have someone else's write in between them
18:40:26 <allbery_b> at which point you give up and switch to AF_UNIX sockets, which aren't necessarily atomic but *do* preserve message boundaries
18:40:54 <jsnx> interesting
18:41:09 <mmorrow> indeed
18:43:07 <allbery_b> and the fact that it depends on the fifo's buffer, not the size of any given write(), means that if you write more than 1 byte per "message" you risk running into this, depending on how many other processes are writing.
18:43:57 <BMeph> See y'all tomorrow (except for all of you alread experiencing "tomorrow", in which case, see you later "today")! :)
18:44:17 <allbery_b> so most FIFO-using pograms read a single byte as a trigger to do something else (an example being telinit writing a single character to init's fifo to tell it what state to switch to, or crontab writing a single byte after which cron rescans everything)
18:45:54 <mmorrow> i remember reading about someone who implemented a "db system" with bash, fifos, and plain files. i never got around to searching for it, but i think it sounds interesting
18:45:58 * mmorrow looks for it now
18:47:41 <allbery_b> not that hard, actually
18:47:48 <allbery_b> cut, paste, sort, join
18:47:58 <allbery_b> and grep/awk
18:48:21 <jsnx> consistency would be the hardest part
18:48:46 <davidL> put it all under a VCS?
18:48:51 <allbery_b> actually, if you've been paying attention, there is a write size other than 1 byte which is safe.  but it is, unfortunately, not portable
18:49:01 <mmorrow> but i recall this particular implem made interesting larger scale global structures in the fifo->fifo graph
18:50:03 <mmorrow> analogous to what happens when you build Arrows out of Arrows out of .. etc
18:50:15 <allbery_b> (spevifically, writes of exactly PIPE_BUF bytes are guaranteed atomic ands safe.  but PIPE_BUF varies between unixen)
18:50:22 <mmorrow> (Arrows as in the haskell Arrow class or something equiv)
18:50:25 <chrisdone> Arrows out of Arrows out of Arrows out oInterrupted.
18:50:29 <jsnx> allbery_b: what size is that?
18:50:36 <jsnx> oh
18:50:39 <jsnx> just saw it
18:51:25 <mmorrow> chrisdone: heh
18:52:07 <allbery_b> unfortunately PIPE_BUF is 512 on Solaris, 4096 on Linux, and I think 1024 on the *BSDs
18:52:39 <mmorrow> i can't find it (and i only read someone passing description of it (and i don't even remember where)) :(
18:54:22 <mmorrow> allbery_b: where is the bufsize set? a #define in the kernel? in /proc or /sys ?
18:54:30 <allbery_b> kernel #define
18:54:37 <mmorrow> crap
18:54:37 <allbery_b> usually not a tunable parameter
18:54:59 <allbery_b> often closely related to the memory page size (hence 4096 on linux and 512 on traditional unix)
18:55:11 <mmorrow> ah, i see
18:58:32 <adu> hi
18:58:57 <adu> i think i passed the test
19:02:53 <dmwit> adu: Congrats!
19:02:55 <dmwit> ...what test?
19:03:12 <adu> to see if i can program
19:03:45 <adu> also, on a different note, I graduated yesterday
19:04:05 <adu> i guess i could have been referring to that
19:05:54 <adu> even tho the questions were about C, I was thinking in Haskell the whole time
19:06:39 <adu> o well
19:06:50 <newsham> congrats
19:06:52 <adu> also good news on the HOC project
19:07:15 <adu> I got in contact with one of the maintainers
19:07:50 <adu> he said the guy who does all the work hasn't been around
19:08:03 <adu> which explains why HOC only works with GHC 6.2
19:10:41 <adu> but the hard part now is deciding what patches to send
19:11:55 <Apocalisp> Do you know if there's a generalisation of (.), (.).(.), (.).(.).(.), etc?
19:13:07 <mmorrow> i dunno about that in particular, but @pf taught me about this:
19:13:26 <mmorrow> @pf \x -> g(f(x))
19:13:26 <lambdabot> Maybe you meant: bf pl
19:13:30 <mmorrow> yes
19:13:33 <mmorrow> @pl \x -> g(f(x))
19:13:33 <lambdabot> g . f
19:13:38 <mmorrow> @pl \x y-> g(f(x y))
19:13:38 <lambdabot> ((g . f) .)
19:13:44 <mmorrow> @pl \x y z-> g(f(x y z))
19:13:44 <lambdabot> (((g . f) .) .)
19:13:52 <mmorrow> and the other way too
19:14:08 <mmorrow> g . f
19:14:11 <dolio> I think there might be something on oleg's site that does composition with varying numbers of arguments, but it's complex.
19:14:13 <mmorrow> (g .) . f
19:14:18 <mmorrow> ((g .) .) . f
19:14:43 <HarpyFiend> hey guys
19:14:52 <Apocalisp> I have an f::(a->b) and some function g of arity-n,  and I want to say (magicFunction f g)
19:15:04 <HarpyFiend> i was taking a dump
19:15:11 <mmorrow> awesome!
19:15:11 <HarpyFiend> and haskell came to my head
19:15:17 <mmorrow> rad!
19:15:19 <HarpyFiend> but it quickly came out of my large colon
19:15:36 <mmorrow> did you pass any kidney stones!?
19:16:34 <HarpyFiend> it was the large
19:16:38 <adu> HarpyFiend: lol
19:17:13 <mmorrow> Apocalisp: what is (magicFunction f g) supposed to do?
19:17:27 <HarpyFiend> hey guys, stop talking haskell. let's get to the real deal
19:18:16 <mmorrow> you mean like card houses and roofing?
19:18:29 <adu> HarpyFiend: its 10:00 pm, do you know where you are?
19:18:47 <HarpyFiend> ask your mother
19:22:35 <adu> HarpyFiend: do you know Haskell?
19:22:46 <HarpyFiend> isn't it a city in bosnia?
19:23:03 <adu> no
19:23:13 <HarpyFiend> oh... sorry then
19:23:14 <mmorrow> HarpyFiend: your wit is blinding.
19:23:33 <HarpyFiend> ohhh seriously mmorrow?
19:23:56 <mmorrow> i'd answer you, but i can no longer see my display :(
19:24:06 <HarpyFiend> you have the shine too :)
19:25:08 <mmorrow> "danny isn't here, mrs. torrance"
19:25:22 <mmorrow> lol
19:25:23 <HarpyFiend> oh my god, and IT does quote movies
19:25:28 <HarpyFiend> very brilliant
19:27:16 <adu> HarpyFiend: have you ever been here before?
19:27:24 <dons> hmm.
19:27:28 <HarpyFiend> ask your mother, adu
19:28:02 <dons> are you here to learn about Haskell, HarpyFiend ?
19:28:04 <mar77a> i just read that GHC can compile to C code? how can i do that?
19:28:24 <HarpyFiend> no, dons, i'm here just to be a harpy fiend
19:28:33 <dons> ok. you should leave then.
19:28:43 <adu> mar77a: "ghc -C"
19:28:48 <mar77a> ty
19:28:51 <HarpyFiend> your mom is having a party
19:28:56 --- mode: ChanServ set +o dons
19:28:59 --- mode: dons set +b *!*n=oxy@81.193.54.*
19:28:59 --- kick: HarpyFiend was kicked by dons (dons)
19:29:00 --- mode: ChanServ set -o dons
19:29:33 <mar77a> so, where is it?
19:29:36 <mar77a> bah
19:29:54 <dons> what you looking for, mar77a ?
19:30:03 <mar77a> the party :p
19:30:05 <adu> mar77a: its the "*.hc"
19:30:08 <dons> hehe
19:30:09 <mar77a> anyways lets see this C code
19:30:12 <dons> the party is RIGHT HERE!
19:30:14 <dons> ?yow
19:30:14 <lambdabot> Couldn't find fortune file
19:30:15 <dons> woop woop
19:30:22 <dons> and so forth.
19:31:19 <adu> interesting, i never wrote the base_GHCziRead_read_closure function...
19:32:48 <mmorrow> adu: heh, have you ever run nm on a ghc-made binary?
19:32:56 <adu> mmorrow: no
19:33:08 <mmorrow> hehe. do it :)
19:34:56 <mmorrow> this is nice: $ nm Main | grep -iE "barf|belch"
19:35:35 <adu> hmm, why is Conc and Parsec in there?
19:35:52 <adu> i didn't even import them
19:36:21 <bd_> adu: could've been pulled in by something else
19:36:37 <adu> Data.Char and System.Environment
19:36:43 <adu> ?
19:38:04 <dmwit> adu: Try ghc-pkg hide parsec and compile again?
19:38:08 <dmwit> See if it complains?
19:38:15 <adu> dmwit: ok
19:39:30 <adu> nope
19:39:49 <adu> o wait, that wasn't parsec, that was "TextziParserCombinatorsziRead"
19:39:51 <adu> oops
19:39:59 <dmwit> heh
19:40:05 <mar77a> http://hpaste.org/8972
19:40:14 <dmwit> preflex: zdec TextziParserCombinatorsziRead
19:40:14 <preflex>  Text.ParserCombinators.Read
19:40:46 <dmwit> mar77a: You can only pattern-match in cases.
19:40:56 <mar77a> mm
19:40:56 <dmwit> mar77a: If you want arbitrary conditions, you can use guards.
19:41:01 <dmwit> mar77a: But for your application:
19:41:06 <mar77a> but i can't put that do thingy before
19:41:12 <mar77a> unless i use a seperate function?
19:41:29 <dmwit> case cmp (read guess) n of EQ -> ...; LT -> ...; GT -> ...
19:41:45 <mar77a> ah
19:41:46 <dmwit> mar77a: What do thingy?
19:41:53 <mar77a> the readline bit
19:42:07 <mar77a> ?hoogle cmp
19:42:08 <lambdabot> Data.ByteString.Internal.memcmp :: Ptr Word8 -> Ptr Word8 -> CSize -> IO CInt
19:42:11 <dmwit> Whoops.
19:42:13 <dmwit> :t compare
19:42:13 <chessguy> readLine you mean
19:42:14 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
19:42:19 <dmwit> I meant "compare".
19:42:20 <mar77a> right
19:42:29 <mar77a> very handy
19:43:34 <dmwit> mar77a: I annotated.
19:43:51 <dmwit> Oh!
19:43:52 <mar77a> yes got it
19:43:55 <dmwit> I understand your question now.
19:43:56 <mar77a> but it's giving me lower than
19:44:00 <mar77a> nvm it
19:44:09 <dmwit> mar77a: I meant guards in the case.
19:44:15 <dmwit> mar77a: I'll show you how that would look, give me a sec.
19:44:26 <mar77a> i got an idea of it
19:44:33 <mar77a> http://hpaste.org/8972#a2 <-
19:45:09 <adu> mmorrow: I got barf, but not belch
19:45:29 <mar77a> any idea why that doesn't work
19:45:30 <adu> what does barf do anyways?
19:45:50 <dmwit> mar77a: http://hpaste.org/8972#a3 This is what I meant by using guards.
19:46:06 <mar77a> mmm looks hackish
19:46:11 <mar77a> can you spot the problem with my approach
19:46:13 <dmwit> mar77a: What do you mean by "doesn't work"?
19:46:14 <mar77a> in #a2
19:46:20 <mar77a> i posted it in the title
19:46:23 <mar77a> it always says it's too low
19:46:27 <mar77a> (the guess)
19:46:40 <dmwit> Why not stick a "print n" in before the case?
19:47:04 <dmwit> err... "print n'", of course
19:47:11 <mar77a> now it works
19:47:21 <dmwit> Also, it looks like you've got the compare the wrong way around.
19:47:28 <mar77a> doesn't seem like it
19:47:32 <mar77a> let me post the version that works
19:48:08 <mar77a> http://hpaste.org/8973
19:48:37 <mar77a> if i remove "print n" it doesn't work tho
19:48:39 <mar77a> strange '-'
19:48:49 <mar77a> actually
19:48:53 <mar77a> it does but like you said
19:49:00 <adu> mar77a: change readLine to readLn and >>= to >>
19:49:10 <mar77a> the "too high" "too low" messages are inverted
19:49:17 <dmwit> yep
19:49:33 <mar77a> why, adu ?
19:49:48 <adu> hmm readLn doesn't work...
19:49:50 <mar77a> i'm using getLine btw
19:50:02 <dmwit> :t readLn
19:50:03 <lambdabot> forall a. (Read a) => IO a
19:50:31 <dmwit> adu: Those two errors were my fault, not mar77a's, I think.
19:51:32 <Quadrescence> <troll>You haskelletons with your confusing language.</troll>
19:51:44 <mar77a> ok now it works
19:52:12 <mar77a> http://hpaste.org/8973#a1 <- that one
19:52:13 <mar77a> whirr
19:52:16 <mar77a> lemme see the C code
19:52:57 <mar77a> i'm about to cry
19:53:10 <mar77a> what... is this ..... *sniff*
19:53:18 <Quadrescence> mar77a: Why? :O
19:53:28 <mar77a> i was expecting
19:53:42 <dmwit> ghc -via-c
19:53:51 <mar77a> something different
19:54:10 <mar77a>  malformed integer argument in -via-c
19:54:12 <Quadrescence> DQ: Something different.
19:54:18 <adu> mar77a: are you looking at the .hc files?
19:54:22 <mar77a> yes
19:54:45 <dmwit> Whoops, I meant "-fvia-c".
19:54:56 <dmwit> -fvia-C
19:55:01 <dmwit> third time's a charm?
19:55:15 <mar77a> ah
19:55:30 <mar77a> "compilation IS NOT required"
19:55:48 <mar77a> guess i need --make?
19:55:50 <dmwit> rm your .h* files (except the .hs, of course =)
19:56:00 <dmwit> You might.
19:56:25 <adu> just remove *.* and -rf / while you're at it, it will make your life so much more peaceful :)
19:56:33 <dmwit> You might also need -keep-tmp-files
19:56:49 <mar77a> eh
19:57:12 <mar77a> requesting
19:57:15 <mar77a> step by step
19:57:18 <mar77a> i have guess.hs
19:57:35 <adu> ghc -fvia-C guess.hc
19:57:39 <mar77a> ok
19:57:49 <mar77a> .hc?
19:57:52 <adu> o
19:57:57 <mar77a> !?
19:57:59 <adu> ghc -C guess.hs
19:58:01 <mar77a> k
19:58:06 <adu> ghc -fvia-C guess.hc
19:58:15 <mar77a> and the file i want to read now is...?
19:58:21 <adu> guess.hc
19:58:26 <dmwit> Here we go!
19:58:31 <dmwit> -keep-hc-file
19:58:32 <adu> or are you wanting the .S file?
19:58:40 <mar77a> there's no .hc
19:58:41 <dmwit> This command successfully created indicator.hc for me:
19:58:44 <mar77a> ok lets see
19:58:51 <dmwit> ghc -fvia-C --make -keep-hc-file indicator.hs
19:59:09 <dmwit> But you won't get much joy out of it.
19:59:14 <dmwit> It's totally unreadable. =)
19:59:28 <mar77a> :(
19:59:58 <mar77a> what
19:59:59 <mar77a> is this
20:00:03 <mar77a> i feel like i've entered the matrix
20:00:12 <dmwit> It's spineless, tagless G-machine code! =D
20:00:19 <adu> doesn't work for my, only "-C" works for me
20:00:27 <mar77a> 824 lines
20:00:32 <mar77a> of rubbish C code
20:00:40 <Quadrescence> Hahahah
20:00:42 <mar77a> i'm gonna
20:00:47 <mar77a> this is gonna be brilliant
20:00:52 <mar77a> i'm gonna hand in my C assignments
20:00:52 <dmwit> My beautiful 36-line cairo script turns into a lovely 2527 lines of unreadable C. =)
20:01:00 <mar77a> in this format
20:01:03 <Quadrescence> HahahahHAHAHAHAHahhah
20:01:06 <mar77a> code them in haskell, then this
20:01:07 <adu> lolololololol
20:01:08 <mar77a> and hand this in
20:01:16 <mar77a> "i am dead sure it works, sir"
20:01:25 <mar77a> "but how...?"
20:01:27 <dmwit> mar77a: For ultimate points, include the haskell code as a comment at the top.
20:01:34 <adu> hehe
20:01:37 <mar77a> "my father taught me"
20:01:51 <mar77a> "he was in the DOS 5.0 team"
20:02:00 <mar77a> i need a way to convert these includes
20:02:45 <dmwit> P.S. Cairo is absolutely fucking brilliant.
20:02:56 <adu> hmm i should try it
20:03:21 <adu> after fixing hoc, i'd like to try wx, gtk and cairo
20:03:33 <dmwit> ?go hoc haskell
20:03:34 <lambdabot> http://hoc.sourceforge.net/
20:03:34 <lambdabot> Title: HOC: A Haskell to Objective-C Binding
20:03:40 <dmwit> yipe!
20:03:51 <adu> yipe?
20:04:12 <dmwit> yep
20:04:22 <adu> what do you mean?
20:05:36 <adu> the hardest part is the "cbits" part isn't really C so can't be in Cabal's c-source-files because its really "ocbits" if you know what i mean
20:07:40 <dcoutts> adu: what needs to be done differently for objective C ?
20:07:54 <dcoutts> doesn't gcc do objective C ?
20:08:34 <mar77a> how come the guess program takes
20:08:34 <mar77a> nvm
20:08:38 <mar77a> buffering
20:08:46 <dcoutts> adu: and have you filed Cabal feature requests, does the ticket describe the need properly, what packages are blocking on the feature etc
20:09:22 <mar77a> well this is weird
20:09:42 <adu> dcoutts: like -lobjc
20:10:08 <dcoutts> adu: that's easy, extra-libraries: objc
20:10:15 <Quadrescence> Hay is there a haskell-to-COBOL converter? I rly need it. </troll>
20:10:26 <mar77a> http://hpaste.org/8974 doesn't work when compiled
20:10:38 <mar77a> it waits for input instead of printing the "guess blah blah" message
20:10:38 <adu> dcoutts: hmm, maybe you can then
20:13:19 <adu> Quadrescence: is there a troll2hs converter? then we could decuple (10x) the channel by running "troll2hs #large-distro-here"
20:14:23 <Quadrescence> adu: :) :) I am just here to ask haskell questions, learn, lurk, and "troll" when mar77a is about to cry. :[
20:14:23 <mar77a> any ideas?
20:16:04 <mar77a> :(}
20:16:12 <mar77a> :( *
20:17:47 <chessguy> mar77a:  try switching the putStrLn and the hSetBuffering
20:17:59 <mar77a> switching?
20:18:03 <mar77a> around?
20:18:10 <chessguy> yeah, switch the 2 lines
20:18:12 <mar77a> ahh
20:18:15 <mar77a> i see the problem now
20:18:21 <mar77a> is there a way to force flush
20:18:30 <mar77a> << std::flush'ish?
20:18:42 <chessguy> @hoogle flush
20:18:42 <lambdabot> GHC.ConsoleHandler.flushConsole :: Handle -> IO ()
20:18:42 <lambdabot> System.IO.hFlush :: Handle -> IO ()
20:18:52 <mar77a> hFlush stdin i guess
20:19:22 <mar77a> er stdout
20:19:25 <chessguy> @type hSetBuffering
20:19:26 <lambdabot> Not in scope: `hSetBuffering'
20:19:32 <chessguy> @hoogle hSetBuffering
20:19:33 <lambdabot> System.IO.hSetBuffering :: Handle -> BufferMode -> IO ()
20:19:34 <sclv_> why do you need line buffering at all?
20:19:39 <sclv_> set it to NoBuffering instead?
20:19:46 <mar77a> mm
20:20:05 <sclv_> oh, by the way, you can just annotate previous hpastes instead of making new ones each time.
20:20:09 <mar77a> doesn't work
20:20:14 <chrisdone> LIES
20:20:15 <mar77a> (with no buffering)
20:20:18 <chrisdone> oh
20:20:25 <chessguy> are you using hugs?
20:20:31 <chessguy> (mar77a )
20:20:32 <mar77a> negative
20:20:33 <mar77a> actually
20:20:44 <mar77a> i'm setting it on stdin only
20:21:24 <mar77a> yeah now i got this
20:21:26 <mar77a> i GOT this
20:21:45 <mar77a> ey
20:21:58 <mar77a> the guess program is 880497 bytes
20:22:01 <mar77a> >:(
20:22:21 <sclv_> yeah -- haskell binaries include the runtime. you can usually strip and save a bit...
20:22:37 <mar77a> include the what?
20:23:14 <sclv_> The runtime. Haskell has a runtime environment for garbage collection, etc.
20:25:14 <cjs_> Gah. sysadmin hell.
20:27:04 <newsham> reboot the webserver
20:27:49 <newsham> http://www.youtube.com/watch?v=BcQ7RkyBoBc <- sysadmin hell
20:27:50 <lambdabot> Title: YouTube - The Website Is Down: Sales Guy vs. Web Dude
20:32:27 <adu> dcoutts: this is what i get: http://hpaste.org/8975
20:38:31 <chessguy> newsham:  that's awesome
20:38:49 <newsham> indeed.
20:39:57 <adu> I'm having trouble telling what operating system that is
20:40:09 <newsham> in the video?  there are many used.
20:40:09 <edwardk> @pl \phi -> mcata (\f -> phi . fmap f)
20:40:10 <lambdabot> mcata . (. fmap) . (.)
20:40:17 <edwardk> @pl \f -> phi . fmap f
20:40:18 <lambdabot> (phi .) . fmap
20:41:25 <adu> i'm assuming either vmware or vnc is at work
20:41:38 <newsham> seems to be.
20:51:27 <Shurique> I'm trying to compile lambdabot, and the build script errors with "./build: line 10: cabal: command not found". I have Cabal-1.4.0.1 installed, but I can't find such a binary anywhere - do I need to install something more for this?
20:52:26 <Axman6> Shurique: you need cabal-install
20:53:41 <Shurique> ah, thanks
20:54:26 <adu> i had so much trouble with cabal-install
20:55:30 <woochiwoochiwa> Hi guys
20:55:36 <adu> so what's the difference between "cabal" and "runhaskell Setup.hs"?
20:55:54 <woochiwoochiwa> here's some Erlang code to parse an IP header
20:56:00 <woochiwoochiwa> <<IPVer:4,
20:56:01 <woochiwoochiwa> HLen:4,
20:56:03 <woochiwoochiwa> SrvcType:8,
20:56:04 <woochiwoochiwa> TotLen:16,
20:56:06 <woochiwoochiwa> ID:16,
20:56:08 <woochiwoochiwa> Flgs:3,
20:56:08 <adu> hpaste.org
20:56:09 <woochiwoochiwa> FragOff:13,
20:56:11 <woochiwoochiwa> TTL:8,
20:56:12 <woochiwoochiwa> Proto:8,
20:56:14 <woochiwoochiwa> HdrChkSum:16,
20:56:15 <woochiwoochiwa> SrcIP:32,
20:56:18 <woochiwoochiwa> DestIP:32,
20:56:19 <woochiwoochiwa> RestDgram/binary>> = Datagram
20:56:20 <adu> hpaste.org!
20:56:22 <woochiwoochiwa> how does one do that with Haskell?
20:56:42 <adu> woochiwoochiwa: what does it do?
20:57:02 <adu> what does the << and >> mean?
20:57:42 <Axman6> adu: it's binary paters matching
20:57:48 <Axman6> pattern*
20:57:52 <Axman6> paters, yes
20:57:54 <Axman6> -_-
20:58:03 <mar77a> aba
20:58:05 <dons> woochiwoochiwa: with Data.Binary (i.e. pattern guards)
20:58:16 <dons> there's a bitsyntax library on hackage too, if you'd like.
20:58:20 <dons> based on erlang's bit syntax
20:58:27 <dons> bit syntax isn't wired into the language though.
20:58:57 <Shurique> I installed cabal-install, but now the build script fails with "unrecognized option `--global'"
20:59:43 <dons> maybe you have an old version of cabal?
21:00:08 <Shurique> I just installed 1.4.0.1
21:00:39 <dons> and then rebuilt cabal-install ?
21:01:01 <b7j0c> i have a couple of naive questions. please no flames! i was searching for information on closures with respect to haskell, and found little. are they supported? i have a feeling that currying and partial-evaluation in haskell may obviate the need for this technique?
21:01:19 <dons> yeah, they're supported :)
21:01:20 <Shurique> well, built, not re-built since I didn't have a previous cabal-install installed :)
21:01:32 <dons> > let x = (+) 2 in x 7
21:01:36 <lambdabot>  9
21:01:45 <dons> b7j0c: everything's a closure in haskell.
21:02:01 <b7j0c> okay, thanks dons, i had a feeling it was more "fundamental"!
21:02:04 <Shurique> cabal -V gives "cabal-install version 0.5.1; using version 1.4.0.1 of the Cabal library"
21:02:09 <chessguy> b7j0c: by the way, this is a very friendly channel. no need to worry about getting flamed in here
21:02:17 <dons> yeah. :D
21:02:20 <b7j0c> thanks chessguy!
21:02:52 <Pseudonym> What you would call a call to a function with multiple arguments in some other language is done, in Haskell, with closures.
21:03:08 <Pseudonym> They pervade the system in a way that they don't in other languages.
21:03:11 <adu> b7j0c: <flame>burn</flame>
21:03:24 <chessguy> @quote flame
21:03:24 <lambdabot> No quotes match. Wrong!  You cheating scum!
21:03:30 <chessguy> @quote burn
21:03:30 <lambdabot> Tac-Tics says: I get the feeling if all I ever use is the IO monad, someone here will shower me in holy monad fire and cleanse the evil from me.... leaving burn marks all over
21:03:36 <chessguy> there we go
21:03:39 <chessguy> fire!
21:03:42 <b7j0c> thanks Pseudonym
21:04:17 <adu> b7j0c: it makes it easy to set defaults too
21:04:19 <Sartak> > 1/0
21:04:21 <lambdabot>  Infinity
21:04:37 <b7j0c> not surfe i follow adu
21:05:19 <Sartak> > tail "lament"
21:05:22 <lambdabot>  "ament"
21:05:31 <mar77a> > tail "donkey"
21:05:32 <adu> b7j0c: like if f x y z = some definition, then f 3 is a function with the default x=3 and f 3 2 is a function with x=3, y=2
21:05:32 <lambdabot>  "onkey"
21:05:45 <b7j0c> ah, i see adu, thanks!
21:06:07 <dons> the closure is just object with those variables captured.
21:06:42 <Pseudonym> This usually gets people:
21:06:45 <Pseudonym> @type (+)
21:06:47 <lambdabot> forall a. (Num a) => a -> a -> a
21:06:59 <b7j0c> seems like it is fundamental to the language that if you get haskell, you implicitly get closures. whereas with other languages they are not fundamental so worthy of discussion as a feature
21:07:08 <adu> @type print
21:07:14 <lambdabot> forall a. (Show a) => a -> IO ()
21:07:14 <Pseudonym> You normally think of addition as being of a type like RxR -> R
21:07:57 <b7j0c> interesting Pseudonym
21:08:14 <Sartak> > foldl1 (++) $ map (take 4) ["lament", " ", "monkey"]
21:08:16 <lambdabot>  "lame monk"
21:08:21 <Pseudonym> But it's actually (using more pseudo-mathematical notation) more like R -> (R -> R)
21:08:29 <Pseudonym> It takes an argument, and returns a function.
21:08:30 <b7j0c> well i need to rename and reorder 10k music files based on their id3 info. i'm going to let haskell have a crack at that
21:09:12 <b7j0c> dons i already have your blog entry on system interaction bookmarked to help out
21:09:19 <b7j0c> very useful info!
21:09:41 <adu> b7j0c: http://www.cse.unsw.edu.au/~dons/hmp3.html
21:09:42 <lambdabot> Title: hmp3 - curses/ncurses mp3 player
21:10:09 <b7j0c> yeah i have seen that - may give it a try! i currently use ncmpc with mpd
21:10:28 <adu> b7j0c: the source might be useful
21:10:28 <b7j0c> in ten years or so i may be ready for a gui music client
21:10:41 <b7j0c> thanks adu, i will crack it open and see
21:10:45 <adu> b7j0c: for extracting id3
21:11:11 <b7j0c> yeah, for now i was literally just going to use the command line ogg tools (all my files are ogg) and capture the output
21:11:25 <b7j0c> i know there is a Hogg lib too
21:11:36 <adu> lol what a name
21:12:01 <b7j0c> and props to the author, he actually documented it
21:12:26 <b7j0c> anyway i better scoot and get on it!
21:12:32 <b7j0c> thanks for all the great info folks!
21:13:36 <Quadrescence> How would we make a kind of database/table to which we can add records/values?
21:13:46 <Quadrescence> (and hopefully without file IO)
21:14:42 <chessguy> anybody know who Russell O'Connor is?
21:15:31 <vixey> @seen roconnor
21:15:32 <lambdabot> I saw roconnor leaving #haskell 7d 3h 43m 29s ago, and .
21:16:18 <chessguy> oh, duh
21:16:33 <vixey> @seen shapr
21:16:35 <lambdabot> Last time I saw shapr was when I left ##logic, #arch-haskell, #darcs, #dreamlinux-es, #friendly-coders, #gentoo-haskell, #gentoo-uy, #ghc, #haskell, #haskell-blah, #haskell-books, #haskell-hac07, #
21:16:35 <lambdabot> haskell-hac4, #haskell-overflow, #haskell-soc, #haskell.cz, #haskell.de, #haskell.dut, #haskell.es, #haskell.fi, #haskell.fr, #haskell.hr, #haskell.it, #haskell.jp, #haskell.no, #haskell.ru, #
21:16:35 <lambdabot> haskell.se, #haskell_ru, #japanese, #jhc, #jtiger, #macosx, #parrot, #perl6, #rosettacode, #scala, #scannedinavian, #thunks, #unicycling and #xmonad 7h 19m 13s ago, and .
21:18:17 <chessguy> i liked roconnor's simple approach to ICFP
21:19:22 <Quadrescence> (I ask because I am still not in the hang of working with values which can't be destroyed)
21:19:44 <vixey> :D
21:19:45 <lambdabot> vixey: You have 1 new message. '/msg lambdabot @messages' to read it.
21:19:47 <chessguy> Quadrescence:  you want something you can persist?
21:19:50 <vixey> @messages
21:19:51 <lambdabot> dolio said 5d 20h 23m 4s ago: I rewrote my more polished PTS type checker to use unification (and fixed up the unification algorithm a little). You can see it at http://code.haskell.org/~dolio/pts/ (
21:19:51 <lambdabot> it's a darcs repo, it's got a little REPL, too).
21:20:04 <vixey> dolio: cool! taking a look now
21:20:37 <Quadrescence> chessguy: I don't know what you mean by "persist"
21:21:01 <chessguy> umm, store somewhere other than memory
21:21:16 <chessguy> like, on the file system
21:21:53 * vixey sighs, ghc Could not find module `Control.Monad.Reader':
21:22:06 <Quadrescence> chessguy: I mean store it IN memory (and maybe put it in a file later)
21:22:37 <vixey> how do you get 6.9 working? or is it just not ready yet?
21:23:00 <chessguy> Quadrescence: ok, then look at something like Data.Map
21:25:44 <sjanssen> vixey: sounds like you need to install mtl
21:26:40 <vixey> sjanssen: thing is I already did, and lots of other things but 6.9 doesn't see them
21:27:10 <sjanssen> vixey: libraries are not compatible across different GHC releases
21:27:18 <vixey> ohh
21:35:32 <Quadrescence> To whomever's familiar: Does Data.Map basically make editable 2xN tables?
21:36:30 <vixey> sort of I guess
21:37:38 <sjanssen> seems like an awkward way to say it
21:37:57 <Quadrescence> It might be... But I don't know how else to say it.
21:38:13 <vixey> yeah without using the word 'map' it's kind of hard to describe
21:38:34 <vixey> it's like a big [(Key,Value)] thing but more efficient since it's stored in trees
21:38:43 <sjanssen> other programming languages call this a "dictionary"
21:40:05 <Quadrescence> Stored in trees...
21:40:24 <Quadrescence> What would the branches of this tree ... branch to?
21:40:52 <vixey> other branches or leaves
21:41:18 <sjanssen> Quadrescence: have you heard of binary search trees?
21:42:13 <jsnx> Quadrescence: check out tries (yes, i spelled that right)
21:42:37 <Quadrescence> sjanssen: A tree that has zero branches (leeeeeeeeeaf :D), one branch, or two branches?
21:42:43 <jsnx> re*trieval* trees
21:43:02 <jsnx> re*trie*val trees -- heh
21:43:16 <sjanssen> Quadrescence: 'search' is the important word here
21:44:05 <sjanssen> Quadrescence: the nodes are stored in order (all the elements in the left subtree are smaller, all the elements in the right are larger), this allows us to look up elements in O(log n) time
21:44:19 <Quadrescence> sjanssen: okay I cheated I just looked up the wikiwkiwikwiikik articcle. :<
21:44:47 <Quadrescence> ( jsnx: I didn't ignore your comment either )
21:45:10 <Quadrescence> sjanssen: It would usually take O(n) time, right?
21:45:29 <sjanssen> Quadrescence: exactly
21:48:27 <Quadrescence> So the _values_ in Data.Map are stored in a BST?
21:48:52 <sjanssen> both the keys and values are stored in the trees
21:49:00 <sjanssen> but the tree is only sorted by key
21:49:09 <Quadrescence> Right, yes, that's what I meant.
21:49:24 <Quadrescence> (except I said value, so that's incorrect)
21:53:57 <Quadrescence> jsnx: Thanks, this might be needed later in the program. :D, sjanssen and vixey: Thank you two too. :]
21:56:42 <Quadrescence> It seems like 'tries' can work with pruning tables.
21:57:35 <Quadrescence> But I still don't know enough about trees of any sort to be effective with anything yet. D:
22:01:36 <Quadrescence> I wonder if it can be efficient to search a tree with 5 branches per node. D:
22:02:20 <_zenon_> good morning
22:04:15 <Quadrescence> _zenon_: I don't know you, but good morning! :D
22:04:40 <Cale> Quadrescence: well, what do you know about the branches given the value at the root?
22:04:43 <_zenon_> Quadrescence, hehe :) All lambdas are equal :)
22:05:06 <sarehu> i got somebody on another channel thinking lambdabot evaluates R6RS scheme :D
22:05:17 <vixey> lol
22:05:53 <sjanssen> > ((+) ((*) 2 4) 1)
22:05:55 <lambdabot>  9
22:07:16 <Quadrescence> Cale: Well. It is a Rubik's cube. Each note represents a position, and each branch represents a turn on the cube, leads to another node (position). (In reality, there are about 3*5 branches. :( )
22:07:40 <Cale> Quadrescence: oh, you're going to try a brute force approach to solving it?
22:08:03 <_zenon_> Quadrescence, going bruteforce: have you thought about the possible prunings?
22:08:13 <Cale> Quadrescence: I doubt that's terribly effective without taking more of the group structure into account.
22:08:25 <Quadrescence> Cale: Well, brute force is extremely impractical...well...impossible. The diameter of the group generated by the cube is way too large.
22:08:32 <Cale> right.
22:09:20 <Quadrescence> _zenon_: Yes. I have some literature (online) on it, and even source code, but I have a hard time looking through, like, 8 header files and 8 c++ files. :|
22:09:32 <Cale> GAP contains algorithms which can find a word in specified generators to solve the cube. You might have a look at it (though it's not written in Haskell).
22:10:15 <Cale> http://www.gap-system.org/Doc/Examples/rubik.html
22:10:17 <lambdabot> Title: Analyzing Rubik's Cube with GAP
22:10:30 <Quadrescence> Cale: I've read that actually. :D
22:11:00 <Cale> I love that quote at the top :)
22:11:11 <_zenon_> Quadrescence, Sounds like a lot indeed.
22:11:15 <Quadrescence> Hahah, yeah.
22:11:36 <_zenon_> Quadrescence, http://en.wikipedia.org/wiki/Speedcubing
22:11:37 <lambdabot> Title: Speedcubing - Wikipedia, the free encyclopedia
22:11:41 <Quadrescence> Initially what I want to do is be able to break it into smaller groups and solve those groups optimally.
22:11:47 <Quadrescence> _zenon_: I am a speedcuber. :O
22:12:16 <_zenon_> Oooh, well, transfer your awesome knowledge into a module and it's done :)
22:12:25 <kaspyanand> hi
22:12:52 <Quadrescence> http://kociemba.org/cube.htm <-- The Mathematics behind Cube Explorer
22:12:53 <lambdabot> Title: Solve Rubik's Cube with Cube Explorer
22:12:59 <Cale> _zenon_: but likely in a fairly useless way if one would want to solve any other puzzle :)
22:13:13 <Quadrescence> It's more algorithms and stuff, not really MATH.
22:13:59 <Quadrescence> I want to try to implement this guys nearly optimal algorithm, Kociemba's algorithm, for a start.
22:14:52 <mmorrow> Quadrescence: cool. imagine it was a free (noncomm) group for a moment. how many generators would it have? it seems to me 6*2=12 (rotate each of the 3 levels once, and there are two axes to do this on, so 6) the (*2) for rotating each one either of the two ways.
22:14:52 <Quadrescence> Them I want to expand the program to solve puzzles in general where you can specify how possible moves affect the puzzle (this has been done with a program called ksolve, and it has the sourcecode included -- that's the C++ program)
22:15:01 <kaspyanand> i am writing a function to calculate sum of all numbers less than 1000 divisible by 3 or 5
22:15:10 <kaspyanand> sumOfAllNumbers::Int
22:15:10 <kaspyanand> sumOfAllNumbers=helper 0 [1..999]
22:15:10 <kaspyanand> helper initial x:xs |(x `rem` 3==0 || x `rem` 5==0) =helper (initial + x) xs				
22:15:11 <kaspyanand> 	            | otherwise=helper initial xs
22:15:33 <kaspyanand> it is giving me parse error in pattern on compiling
22:15:40 <mmorrow> then say "a" is one of the generators => (*(a*a*a)) == (*(1/a)) etc
22:15:46 <Quadrescence> kaspyanand: Look through list functions. I think you can make that a one liner.
22:16:02 <mmorrow> (three twists one way is the same as one twist the other)
22:16:06 <Quadrescence> mmorrow: Yes
22:16:14 <kaspyanand> Quadrescence:ok
22:16:21 <mmorrow> so 12 generators then
22:16:25 <_zenon_> Pruning, it's your friend
22:16:33 <sjanssen> kaspyanand: (x:xs)
22:16:47 <Quadrescence> _zenon_: http://kociemba.org/math/pruning.htm
22:16:48 <lambdabot> Title: Pruning Tables
22:16:50 <Quadrescence> :}
22:17:08 <_zenon_> http://en.wikipedia.org/wiki/Pruning_fruit_trees
22:17:09 <lambdabot> Title: Fruit tree pruning - Wikipedia, the free encyclopedia
22:17:11 <_zenon_> :>
22:17:47 <_zenon_> Spur pruning, Renewal pruning and Regulatory pruning
22:17:53 <kaspyanand>  sjanssen:rite,thks
22:17:59 <Quadrescence> mmorrow: Wait, why are A2 moves (A*A) considered part of the list of generating moves?
22:19:02 <mmorrow> hmm, i'm not sure exactly how you mean that, but how i'm interpreting (a*a) is twisting whatever plane a corresponds to twice to whichever way a corresponds to
22:19:13 <Quadrescence> Yes.
22:19:52 <Quadrescence> I mean...why arem
22:20:18 <Quadrescence> why aren't the basic 6 moves just the generators for the group?
22:20:31 <mmorrow> oh yeah, of course
22:20:35 <mmorrow> (heh)
22:20:40 <Quadrescence> :}
22:20:58 <loki_> @hoogle date
22:20:58 <lambdabot> System.Locale.dateTimeFmt :: TimeLocale -> String
22:20:58 <lambdabot> System.Locale.dateFmt :: TimeLocale -> String
22:20:58 <lambdabot> Data.Time.Calendar.OrdinalDate :: module
22:21:41 <loki_> say i want to get a date and output the dates in intervals of 3.5 hours afterwards
22:21:48 <loki_> how would i go about it?
22:22:19 <lowki> its for polyphasic sleeping
22:23:06 <Quadrescence> lowki: Couldn't you just do something like [date, date + 3.5 ..]? (pseudo-haskellcode)
22:23:07 <Quadrescence> :}
22:23:22 <Quadrescence> (if date is expressed in hours)
22:23:23 <mmorrow> i remember once a few years ago i tried to give the group a topology by first giving it a metric ( d(x,y) = the number of "moves" to get from on to the other) then have the topology be the one induced by this metric
22:23:32 <mmorrow> don't remember how that turned out
22:23:40 <mmorrow> (probably not well if i can't remember)
22:23:54 <Shurique> I managed to satisfy the dependencies of lambdabot, but now the build script fails with "ghc-6.8.3: could not execute: /Library/Frameworks/GHC.framework/Versions/608/usr/lib/ghc-6.8.3/ghc-asm" while it's compiling Plugin.Pl.Common. What should I do?
22:24:06 <mmorrow> i don't think i really had a goal i was trying to achieve by doing that either
22:25:14 <lowki> Quadrescence: well what would the date be?
22:25:30 <lowki> as in how do i calculate it
22:25:33 <lowki> is there a type?
22:25:44 <lowki> upon which addition can be performed/
22:27:38 <Quadrescence> lowki: I don't mean to be...I don't know. I don't really have an exact answer; I'm not very experienced. But I read a lot today about different functions, and maybe http://www.zvon.org/other/haskell/Outputtime/index.html might help.
22:27:39 <lambdabot> Title: Zvon - Haskell Reference
22:27:59 <idnar> lowki: http://www.supermemo.com/articles/polyphasic.htm (not related to the programming task, but you may find it of interest)
22:28:01 <lambdabot> Title: Polyphasic Sleep: Facts and Myths
22:29:02 <mmorrow> lowki: Check out Data.Time and diffUTCTime :: UTCTime -> UTCTime -> NominalDiffTime
22:29:33 <mmorrow> addUTCTime :: NominalDiffTime -> UTCTime -> UTCTime
22:29:56 <lowki> kk
22:30:13 <mmorrow> and
22:30:16 <mmorrow> :t scanl
22:30:17 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
22:30:27 <mmorrow> (or somthing)
22:30:31 <mmorrow> e
22:30:52 <lowki> take probably if i make an infinite function
22:31:24 <mmorrow> yeah, take n . iterate ... would work
22:31:53 <mmorrow> lowki: oh, i see how you mean. yeah take n . <whatever>
22:32:49 <lowki> :)
22:35:31 <lowki>  Could not find module `Date.Time.Clock':
22:35:34 <lowki> :<
22:35:55 <lowki> do you know what package it might be a part of?
22:36:15 <lowki> oopps
22:36:19 <lowki> Data
22:36:22 <lowki> not Date
22:37:13 <lowki> but still same result
22:39:12 <lowki> hmmm its part of the time library
22:40:12 <lowki> fortunatly there is ebuild dev-haskell/time :D
22:43:51 <Quadrescence> Can someone tell me the general premise of pruning?
22:44:23 <vixey> pruning ?
22:44:29 <vixey> like pruning a search space?
22:45:15 <Quadrescence> No I mean pruning apple trees. :D
22:45:25 <Quadrescence> (yes like that, vixey) :}
22:46:20 <vixey> say you have an orchard 600x600 of apple trees
22:46:30 <vixey> and you're looking for the reddest apple,
22:46:52 <vixey> but the sun casts a big shadow on half of the orchard, (where x < y)
22:47:19 <vixey> then you can prune your search space in half, and only walk around looking in the (sunny) lower left corner
22:47:30 <vixey> that'll obviously take half the time to search
22:48:22 <Quadrescence> So it's just reducing the search space where you know the solution doesn't exist.
22:48:27 <vixey> exactly
22:49:03 <vixey> you take all the things you know, mash the information together to reduce the things you'll have to test to find the answer
22:49:17 <quicksilver> or more generally, it's "short circuiting" or "returning early" from one branch of an exchaustive search
22:49:31 <Quadrescence> I wish this was easier done than said. :D
22:49:41 <quicksilver> because you've decided the answer either isn't, or with very high probability isn't, in this subtree.
22:50:13 <vixey> yeah there's a lot to implementing it
22:50:15 <joed> to reduce especially by eliminating superfluous matter <pruned the text> <prune the budget> b: to remove as superfluous <prune away all ornamentation>
22:50:32 <vixey> it's incredibly fast though, you can speed up logic programs many many times with it
22:50:39 <vixey> well some of them
22:52:37 <Quadrescence> I think I will just write a 2x2x2 cube solution program first to get an understanding of all of this. D:
22:53:20 <_zenon_> good idea
22:53:47 <vixey> I don't think 2^3 will be any easier than 3^3
22:53:53 <vixey> it will just take longer to get to your goal
22:53:58 <Quadrescence> I think so.
22:54:08 <Quadrescence> I know what you mean
22:54:23 <Quadrescence> but the 3x3 has corners and edges (pieces between the corners)
22:54:32 <vixey> what program is more complex:   n = 3 or n = 2  ? :p
22:54:41 <Quadrescence> And you have to treat those differently.
22:55:02 <Quadrescence> a 2x2x2 only has 3 _distinct_ moves
22:55:12 <Quadrescence> as opposed to 6 on the 3x3x3 cube
22:55:35 <Quadrescence> I think it will just be easier to start with, since I don't know much about anything, AND I am a noob to haskell
22:55:49 <quicksilver> it's fairly fiddly to model everything
22:55:54 <quicksilver> once your model is right the program is easy :)
22:56:15 <quicksilver> 3 distinct moves in which sense of the word 'distinct' ?
22:56:43 <Quadrescence> moving the left side is the same as moving the right side in the opposite direction
22:56:59 <quicksilver> more then 3 then, surely?
22:57:30 <Quadrescence> on the 2x2x2 cube, the left is right^-1, bottom is top^-1, front is back^-1
22:57:33 <quicksilver> there are 3 axes; you can twist a square about each axis
22:57:48 <quicksilver> and there are two squares on each axis, near and far.
22:57:51 <quicksilver> and two directions.
22:58:07 <quicksilver> I make it 3 x 2 x 2 = 12 distinct moves
22:58:17 <Quadrescence> Each direction can be constructed by going the opposite direction three times.
22:58:29 <quicksilver> ok you're not taling about distinct
22:58:36 <quicksilver> you're talking about generators of the group
22:58:40 <quicksilver> that's different.
22:58:43 <Quadrescence> Oh. :D Okay.
22:58:50 <quicksilver> Yes, the generating set is smaller than the number of distinct elements
22:58:52 <Quadrescence> <-- has not studied groooooooooooooup theory
22:59:06 <quicksilver> it's not 12 though becuse on any given axis
22:59:18 <quicksilver> movin top clockwise is the same as moving bottom anti clockwise
22:59:23 <Quadrescence> As I said. :D
22:59:23 <quicksilver> btu I think it is 6.
23:00:08 <sarehu> crap I need to learn prolog
23:00:36 <vixey> sarehu: oh no!!
23:00:58 <sarehu> sorry wrong server
23:01:22 <mmorrow> Quadrescense: so the free group gen by 3 elems (a,b,c) is every possible {a*(1/(b*a*a))*(1/b)*c, c, b*c*b,...}
23:02:14 <Quadrescence> Indeed
23:02:43 <mmorrow> *every* other group gen by 3 elems can be arrived at by identifying as "equal" some of the elements of this free group, eg   a*a=b , c*a=1, etc
23:02:50 <dons> dogbite: btw, you should try using 'unsafeUseAsCString' for the strtod call.
23:03:06 <dons> it avoids copying the data. when reading a 50M file I had runtime drop from 30s to 0.9s as a result.
23:03:16 <lowki> for some strange reason show curTime is not working claims no instance of show even though it is clearly written in the haddock
23:03:19 <dons> dogbite: i'd not be surprised if that's the main thing holding back performance at this point.
23:03:32 <dons> dogbite: let me know if that helps.
23:04:40 <mmorrow> so that is to say, every other group gen by 3 elems is isomorphic to the group of the equivalence classes formed by this (these) relations => iso to a quotient of this group
23:05:43 <Quadrescence> mmorrow: Yes, that makes sense. :}
23:05:54 <mmorrow> the group of integers under +, (Z,+), is iso to ("is") the free group on one element
23:06:18 <mmorrow> there only exists one free group on one element (up to isomorphism)
23:06:42 <mmorrow> (and there only exists one free group gen by n elems for any n (up to iso))
23:08:35 <mmorrow> these relations *define* the group <== uh, that came out slightly badly "so that is to say, every other group gen by 3 elems is isomorphic to the group of the equivalence classes formed by this (these) relations"
23:09:15 <mmorrow> (that's meant to be read right to left)
23:09:16 <mmorrow> heh
23:10:52 <lowki> how do i get the third element from a tuple?
23:11:15 <vixey> lowki: define a function to do, then use that function
23:11:17 <mmorrow> > (\(_,_,a)->a) ([0..],(),"asdf")
23:11:19 <lowki> (Int,Int,Int)
23:11:24 <lambdabot>  "asdf"
23:11:29 <vixey> why not (a,b,c) -> c
23:11:40 <quicksilver> mmorrow: ISTR that fact is not entirely trivial to prove.
23:11:45 <quicksilver> mmorrow: although it's certainly true.
23:11:53 <mmorrow> > let p3 (_,_,x) = x in p3 (0,1,2)
23:11:54 <lambdabot>  2
23:12:02 <lowki> cool thanks
23:12:05 <mmorrow> quicksilver: indeed!
23:12:14 <mmorrow> quicksilver: (to both)
23:12:19 <Quadrescence> By exploiting these equivalence classes, solving could be reduced by a factor of at least 20, I think. :| Though hard to implement.
23:12:52 <quicksilver> Quadrescence: the trick is to choose your data structures so they exhibit the equivalence classes
23:13:02 <quicksilver> built the symmetries into
23:13:23 <quicksilver> the code you work with.
23:14:10 <Quadrescence> Right.
23:14:51 <Quadrescence> some of that's described --> http://kociemba.org/math/symmetries.htm and http://kociemba.org/math/symcord.htm
23:14:53 <lambdabot> Title: Equivalent Cubes and Symmetry
23:15:04 <Quadrescence> (if you were curious to look)
23:30:57 <Quadrescence> Hmm, how might I go about multiplying each element in a list by some number (numb) raised to a power (pow) defined by (pow = elements_in_array - index)?
23:31:45 <vixey> map (*(numb ^ pow)) list
23:32:12 <Quadrescence> I don't think so... :/
23:32:28 <vixey> then you have not said what you meant
23:33:02 <Quadrescence> (ex. [1,2,3] where numb = 5, result = [1*5*2, 2*5*1, 2*5^0])
23:33:12 <Quadrescence> oops...
23:33:19 <Quadrescence> (ex. [1,2,3] where numb = 5, result = [1*5^2, 2*5^1, 2*5^0])
23:34:07 <vixey> > zip ['x','y','z'] [1..]
23:34:09 <lambdabot>  [('x',1),('y',2),('z',3)]
23:34:24 <vixey> > zip ['x','y','z'] (reverse . take (length ['x','y','z']) $ [1..])
23:34:26 <lambdabot>  [('x',3),('y',2),('z',1)]
23:34:38 <vixey> > zipWith replicate ['x','y','z'] (reverse . take (length ['x','y','z']) $ [1..])
23:34:40 <lambdabot>  Couldn't match expected type `Int' against inferred type `Char'
23:34:46 <vixey> > zipWith (flip replicate) ['x','y','z'] (reverse . take (length ['x','y','z']) $ [1..])
23:34:49 <lambdabot>  ["xxx","yy","z"]
23:38:19 <mmorrow> heh, i was trying to do a similar thing earlier but didn't get it to work ==> for ["a","b","c"], generate the free group gen by them (where the * is (++)). i was thinking to use the perms : [a] -> [[a]] function and continually return the result and feed it back in ...
23:38:59 <mmorrow> so all of these would appear at some point ==> ["acbbbacaaabcbbcbc", "a", "bbbbbbbbbbbacac", ...
23:39:24 <mmorrow> but i need to sleep, night
23:39:26 <Quadrescence> mmorrow: Hehehe :D
23:39:58 <Quadrescence> > zip [1,0,2,1] [1..]
23:39:59 <lambdabot>  [(1,1),(0,2),(2,3),(1,4)]
23:40:10 <vixey> > replicateM 3 ["a","b","c"]
23:40:11 <lambdabot>  [["a","a","a"],["a","a","b"],["a","a","c"],["a","b","a"],["a","b","b"],["a",...
23:40:32 <vixey> > (concat . flip replicateM ["a","b","c"]) =<< [1..]
23:40:34 <lambdabot>  ["a","b","c","a","a","a","b","a","c","b","a","b","b","b","c","c","a","c","b"...
23:40:43 <vixey> hum :[
23:42:16 <vixey> > map concat $ flip replicateM ["a","b","c"] =<< [1..]
23:42:31 <lambdabot>  ["a","b","c","aa","ab","ac","ba","bb","bc","ca","cb","cc","aaa","aab","aac",...
23:42:43 <Quadrescence> vixey: You slut. :D
23:42:47 <Beelsebob> okay, that's neat
23:42:52 <Beelsebob> but eww
23:43:10 <Beelsebob> I'd have to spend 10 minutes trying to figure out what the crap it did
23:43:59 <mmorrow> vixey: yay!
23:47:49 <mmorrow> hmm http://hpaste.org/8976
23:47:57 <mmorrow> ok now sleep for realz
23:50:36 <Quadrescence> > zipWith (\x y -> 3^(3-y)*x) [1,0,2,1] [1..]
23:50:40 <lambdabot>  [9,0,2,Exception: Negative exponent
23:50:47 <Quadrescence> oops
23:50:54 <Quadrescence> > zipWith (\x y -> 3^(3-y)*x) [1,0,2,1] [0..]
23:50:55 <lambdabot>  [27,0,6,1]
23:51:32 <Quadrescence> > sum.zipWith (\x y -> 3^(3-y)*x) [1,0,2,1] [0..]
23:51:32 <lambdabot>   add an instance declaration for (Num [a])
23:51:42 <Quadrescence> > sum . zipWith (\x y -> 3^(3-y)*x) [1,0,2,1] [0..]
23:51:43 <lambdabot>   add an instance declaration for (Num [a])
23:51:46 <Quadrescence> :[
23:51:59 <Quadrescence> > sum $ zipWith (\x y -> 3^(3-y)*x) [1,0,2,1] [0..]
23:52:01 <lambdabot>  34
23:52:04 <Quadrescence> winnar
23:54:09 <Quadrescence> :t length
23:54:13 <lambdabot> forall a. [a] -> Int
23:57:49 <Quadrescence> Why did haskell make coding that so simple? D:
23:58:18 <vixey> hey dolio
23:58:38 <Axman6> Quadrescence: coding what?
23:58:43 <vixey> I just had a read through your code and I'm getting 6.9 to try it out
23:58:55 <Quadrescence> > sum $ zipWith (\x y -> 3^(3-y)*x) [1,0,2,1] [0..]
23:59:03 <Quadrescence> Axman6: That :D
23:59:08 <Axman6> ah
23:59:08 <lambdabot>  34
23:59:49 <Quadrescence> I suppose the original haskelletons must be familiar with Occam's razorrrrrrrrrr.
