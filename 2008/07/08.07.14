00:03:03 <wuxia> wow, so this is like my new favborite idiom:
00:03:18 <ankh47> hi, does HDBC have its own channel ? or is there sb. who tried it ?
00:03:22 <wuxia> zip pts Ttail pts ++ [head pts])
00:03:43 <vixey> wuxia: writing code that doesn't typecheck?
00:03:57 <wuxia> modifier + T = (
00:03:59 <wuxia> typo
00:05:36 <ski> (itym s/T/(/)
00:05:50 <wuxia> itym ?
00:06:05 <ankh47> well, i'll take silence for yes and fire the question ;-))
00:06:06 <ski> i take you mean
00:06:23 <vixey> :t let loop list = fix (list ++) in \x -> iterate tail (loop x)
00:06:25 <lambdabot> forall a. [a] -> [[a]]
00:06:26 <wuxia> oh; yeah
00:07:31 <vixey> > let loop list = fix (list ++) in (\x -> map (take (length x)) . iterate tail $ (loop x)) "whirl"
00:07:33 <lambdabot>  ["whirl","hirlw","irlwh","rlwhi","lwhir","whirl","hirlw","irlwh","rlwhi","lw...
00:07:49 <ankh47> any reason why `rows <- quickQuery' conn "SELECT CISLO_PRAC, JMENO, ? FROM ?" [toSql pl, toSql db]` should throw an exception
00:08:01 <ankh47> while `rows <- quickQuery' conn ("SELECT CISLO_PRAC, JMENO, " ++ pl ++ " FROM " ++ db) [ ]` works ?
00:08:23 <glguy> columns to be selected are probably not allowed as ? variables
00:08:40 <glguy> same is likely for table names
00:08:49 <opqdonut> vixey: loop is just cycle
00:08:51 <ankh47> :-(( i was afraid of that :-((
00:09:10 <opqdonut> > let f list = map take (length list) $ interate tail (cycle list) in f "Haskell"
00:09:11 <lambdabot>   Not in scope: `interate'
00:09:16 <opqdonut> > let f list = map take (length list) $ iterate tail (cycle list) in f "Haskell"
00:09:17 <lambdabot>  Couldn't match expected type `a -> Int' against inferred type `Int'
00:09:19 <opqdonut> heh
00:09:31 <opqdonut> > let f list = map (take (length list)) $ iterate tail (cycle list) in f "Haskell"
00:09:32 <lambdabot>  ["Haskell","askellH","skellHa","kellHas","ellHask","llHaske","lHaskel","Hask...
00:10:29 <vixey> grr
00:10:48 * vixey thought she had escaped alpha-conversion issues
00:12:41 <ankh47> and a theoretical one: from erlang days i remember that using ++ for concatenation is hit to performance (always having to get to the tail ...), but since haskell is lazy, it shouldn't matter, am i right (ie. its done while traversing the list first time after the concatenation) ?
00:14:19 <misterbeebee> as long as you don't accidentally force evaluation
00:15:08 <misterbeebee> foldl' (++) [] list  -- would be bad, i believe
00:15:18 <sjanssen> ankh47: xs ++ ys is still O(length xs) if you consume that much of the list
00:15:52 <sjanssen> foldl vs. foldr is a nice example here
00:16:32 <mmorrow> let f list = map (take (length list)) $ iterate tail . foldr (++) [] . fix . (:) $ list in f "
00:16:36 <sjanssen> foldl (++) [] is quadratic where foldr (++) [] is linear
00:16:40 <mmorrow> let f list = map (take (length list)) $ iterate tail . foldr (++) [] . fix . (:) $ list in f "asdfg"
00:16:45 <mmorrow> > let f list = map (take (length list)) $ iterate tail . foldr (++) [] . fix . (:) $ list in f "asdfg"
00:16:46 <lambdabot>  ["asdfg","sdfga","dfgas","fgasd","gasdf","asdfg","sdfga","dfgas","fgasd","ga...
00:17:01 <mmorrow> wee
00:17:59 <sjanssen> ankh47: in other words, appending repeatedly is still slow in Haskell
00:18:11 <ski> > let f list = map (take (length list)) $ iterate tail . foldr (++) [] . fix . (:) $ list in f ""
00:18:12 <lambdabot>  ["","","","","","","","","","","","","","","","","","","","","","","","","",...
00:18:34 <mmorrow> > fix ("":)
00:18:35 <lambdabot>  ["","","","","","","","","","","","","","","","","","","","","","","","","",...
00:19:08 <mmorrow> > fix ("fix ("":)":)
00:19:09 <lambdabot>  Couldn't match expected type `t -> a'
00:19:15 <mmorrow> > fix ("fix (\"\":)":)
00:19:16 <lambdabot>  ["fix (\"\":)","fix (\"\":)","fix (\"\":)","fix (\"\":)","fix (\"\":)","fix ...
00:21:42 <ankh47> was hoping for more magic than there is, but at least i know how to do it effectively ... thx
00:24:41 <ew[efg]> Hi, can you please explain how to use State monad?  Let's say I have an initState function that takes a String and gives a state and an processState function that takes another string and returns an updated state
00:24:51 <ew[efg]> How could initState and processState look?
00:25:59 <Baughn> ew[efg]: How to use? Or how to make?
00:26:11 <ew[efg]> Baughn: what's the difference?
00:26:26 <Baughn> Uh. Well, someone else already made it.
00:27:05 <Baughn> Normally you'd just use Control.Monad.State.runState, or one of its variants
00:27:06 <ew[efg]> No, nobody did :-(
00:28:57 <ski> ew[efg] : what's the difference between the `initState' and `processState' functions ?
00:29:28 <ew[efg]> ski: initState starts with no state and some initial info and processState modifies the existing state with some additional info
00:29:54 <Baughn> ew[efg]: And what's wrong with Control.Monad.State?
00:29:56 <ski> and what do you want to do with these ?
00:30:37 <ew[efg]> Baughn: I can't understand it, that's why I asked
00:30:42 <roconnor> > PortNum 8888
00:30:42 <roconnor> 47138
00:30:43 <lambdabot>   Not in scope: data constructor `PortNum'
00:30:45 <roconnor> WTF?
00:30:56 <Baughn> roconnor: It gets byte-swapped
00:31:05 <roconnor> oh right
00:31:11 <ew[efg]> ski: update "test" $ update "test" $ init "init" or something like that
00:31:13 <ski> roconnor : don't use the constructor, use a literal (or `fromIntegral')
00:31:30 <roconnor> fromIntegral sounds good
00:31:56 <ski> ew[efg] : it seems you don't want `Control.Monad.State'
00:32:27 <ski> or are you asking about how to use `Control.Monad.State'
00:32:28 <ski> ?
00:32:54 <ew[efg]> ski: maybe, but I don't know what people normally use in such cases
00:33:03 <Baughn> > runState (do put 5; modify (+1); a <- get; return (a+1) 42
00:33:03 <lambdabot> Unbalanced parentheses
00:33:07 <Baughn> > runState (do put 5; modify (+1); a <- get; return (a+1)) 42
00:33:08 <lambdabot>  (7,6)
00:33:38 <Baughn> ew[efg]: Really. Not hard.
00:34:31 <ski> > (do modify (++ "bar"); modify reverse; modify ("baz" ++); return False) `runState` " foo "
00:34:32 <lambdabot>  (False,"bazrab oof ")
00:34:52 <Baughn> .."oof" is right
00:35:35 <Baughn> But it /is/ convenient how repeated applications of ++ don't actually produce quadratic behaviour
00:40:56 <vixey> @seen shapr
00:40:57 <lambdabot> I saw shapr leaving #scannedinavian, #haskell-soc, #haskell-blah and #haskell 2d 5h 58m 39s ago, and .
00:41:41 <misterbeebee> hmm, i just tried to build/install hmake, but i had to manually compile scripts/echo.c to make it work.
00:43:46 <ew[efg]> Baughn: ski: thanks!  Looks like it
00:47:20 <misterbeebee> is there a modern version or equivalent of 'hat' ? http://haskell.org/hat/
00:47:20 <lambdabot> Title: Hat - the Haskell Tracer
00:47:41 <misterbeebee> for expanding an expression into the call-tree?
00:53:42 <Baughn> misterbeebee: Well, ghci has a stepper these days. Don't know if that helps; it isn't the same, but..
00:56:28 <masak> Baughn: how do I use it?
00:57:05 <misterbeebee> oh, slick
00:57:21 <misterbeebee> I had to copy a Prelude definition into a
00:57:28 <misterbeebee> module and then load it,
00:57:37 <misterbeebee> :break myfunction
00:57:40 <misterbeebee> myfunction
00:57:42 <misterbeebee> (breaks)
00:57:44 <misterbeebee> :step
00:58:42 <Baughn> masak: Read the manual?
00:59:05 <Baughn> misterbeebee: Yeah, sadly it only works with interpreted code
00:59:48 <misterbeebee> masak: http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-debugger.html
00:59:49 <lambdabot> Title: 3.5. The GHCi Debugger, http://tinyurl.com/2orwlb
01:00:03 <masak> misterbeebee: thanks
01:04:53 <cinimod> @hoogle Either a b -> Either b a
01:04:54 <lambdabot> No matches, try a more general search
01:06:12 <Baughn> cinimod: Now, why would you want that?
01:07:06 <cinimod> Baughn: because I'm modifying some code which has a & b the wrong way round for the error monad
01:07:33 <Baughn> > let a = Right 42 in (case a of Left _ -> Right; case a of Right _ -> Left) a
01:07:33 <lambdabot>  Parse error in pattern at ")" (column 74)
01:07:36 <cinimod> Baughn: i.e. he uses left as the value and right as the error
01:08:04 <Baughn> cinimod: Unusual. Well, you'll just have to define it yourself
01:08:21 <cinimod> Baughn: yes it's easy enough but I thought there might be a library function
01:08:35 <Baughn> There usually is. Oh well.
01:08:52 <cinimod> Baughn: mind you I'm not sure hoogle is 100% reliable in these matters
01:09:46 <Baughn> > either Right Left (Right 42)
01:09:50 <lambdabot>  Left 42
01:10:20 <vixey> oh (either Right Left . either Right Left) = id
01:10:24 <vixey> cool
01:11:38 <cinimod> nice
01:12:04 <cinimod> :t either
01:12:05 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
01:12:17 <cinimod> :t either Rigth Left
01:12:19 <lambdabot> Not in scope: data constructor `Rigth'
01:12:25 <cinimod> :t either Right Left
01:12:27 <lambdabot> forall a a1. Either a a1 -> Either a1 a
01:12:51 <cinimod> see there is a library function - you just had to know how to use it
01:13:10 <Baughn> No, there isn't. Just one that can be easily made into one. ;)
01:13:13 <cinimod> @hoogle Either a b -> c
01:13:15 <lambdabot> Prelude.either :: (a -> c) -> (b -> c) -> Either a b -> c
01:13:15 <lambdabot> Data.Either.either :: (a -> c) -> (b -> c) -> Either a b -> c
01:13:35 <cinimod> @hoogle Either a b -> Either b a
01:13:36 <lambdabot> No matches, try a more general search
01:13:58 <cinimod> I apologise to hoogle - I should have tried a more general search
01:14:17 <_Dae_> rofl
01:16:14 <misterbeebee> Djinn> data Either a b = Left a | Right b
01:16:15 <misterbeebee> Djinn> f ? Either a b -> Either b a
01:16:15 <misterbeebee> f :: Either a b -> Either b a
01:16:15 <misterbeebee> f a =
01:16:16 <misterbeebee>     case a of
01:16:16 <misterbeebee>     Left b -> Right b
01:16:16 <misterbeebee>     Right c -> Left c
01:17:15 <misterbeebee> how much/trouble could you have if you wrote a script to let Djinn write all your functions in your program?
01:17:32 <Baughn> Oh, quite a lot of trouble. ^^;
01:17:35 <misterbeebee> (er: how much fun/trouble ....)
01:17:36 <osfameron> hehe
01:17:37 <vixey> Djinn can't do much
01:17:49 <vixey> :t map
01:17:50 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
01:17:55 <osfameron> is there a script to integrate Djinn into vim?
01:18:03 <vixey> ?djinn (a -> b) -> Maybe a -> Maybe b
01:18:04 <lambdabot> f a b =
01:18:04 <lambdabot>     case b of
01:18:04 <lambdabot>     Nothing -> Nothing
01:18:04 <lambdabot>     Just c -> Just (a c)
01:18:10 <vixey> ?djinn (a -> b) -> [a] -> [b]
01:18:11 <lambdabot> -- f cannot be realized.
01:19:08 <misterbeebee> djinn -> lambdabot --> vim ?
01:19:09 <misterbeebee> http://www.haskell.org/haskellwiki/Applications_and_libraries/Program_development
01:19:11 <lambdabot> Title: Applications and libraries/Program development - HaskellWiki, http://tinyurl.com/yt5nlf
01:19:18 <misterbeebee> "In particular, automatic point-free refactoring is available via a vim interface, as well as access to Hoogle, djinn, ghci, and much much more. "
01:21:15 <schme_> morgon
01:22:22 <_zenon_> morgon
01:24:39 <schme_> (:
01:24:50 <wuxia> http://hpaste.org/8919 <- how do i simplify this via currying? exercise 9.1 in haskell soe
01:25:22 <_zenon_> schme: Stad?
01:25:44 <schme> _zenon_: Malmö. Var annars? :)
01:25:58 <_zenon_> schme, Gamle goa götlaborg :)
01:26:04 <vixey> wuxia: You suffix p like it's common lisp code
01:26:05 <Baughn> wuxia: Well, you're /supposed/ to figure it out yourself..
01:26:36 <vixey> (that is bizarre and unusual in haskell)
01:26:57 <Baughn> Mind you, I don't think that code would be simplified by using pointsless style
01:27:09 <schme> _zenon_: Nej nej, inte är jag norrlänning heller.  Ska ni ha busstrejk där oppe med?
01:27:13 <wuxia> the p' can be taken out
01:27:26 <Baughn> Yep, and that's about it
01:27:32 <vixey> wuxia: I mean isLeftOfp
01:27:38 <vixey> wuxia: you should just write isLeftOf
01:27:43 <wuxia> okay; wanted to see if i was missing anything else
01:28:05 <_zenon_> schme, Vette fan, har varit farligt isolerad ifrån nyheterna :/ Har hackat mycket haskell (såklart) och kollat på startrek
01:28:08 <_zenon_> schme, men kanske
01:28:31 <schme> _zenon_: Maj gad. Gött liv du lever då :D
01:29:16 <_zenon_> schme, hehe :) Jo, nu är det ju sommarjobb som gäller, otroligt mycket tid över på kvällarna :)
01:29:30 <Baughn> @pl contains polygon p = let pts = depoly polygon; leftOfList = map isLeftOfp (zip pts (tail pts ++ [head pts])); isLeftOfp p' = isLeftOf p p' in and leftOfList
01:29:30 <lambdabot> contains = (. isLeftOf) . (and .) . flip map . ap zip (liftM2 (++) tail (return . head)) . fix . const . depoly
01:29:38 <Baughn> wuxia: There you go.
01:29:40 <_zenon_> schme, har du blivit drabbad eller? Hmm, vi kanske inte skall sitta och tjöta svenska i #haskell
01:29:52 <wuxia> wha5t does @pl do?
01:29:54 <_zenon_> Okay, sorry for that. No more swedish
01:30:00 <schme> Hahah :)
01:30:02 <Baughn> wuxia: De-points expressions
01:30:07 <_zenon_> wuxia, Rewrite the given expression to point free form
01:30:30 <_zenon_> @pl filter (\x -> x /= []) list
01:30:30 <lambdabot> filter ([] /=) list
01:30:33 <schme> _zenon_: That's funny though. I've taken 3 weeks vacation from my job so now I have *less* free time :)
01:30:47 <wuxia> man; that rewrite looks unreadable in the point free style
01:30:47 <_zenon_> schme, Hehehe :) What do you do on your spare time?
01:30:58 <_zenon_> wuxia, You'll get used to it :)
01:31:08 <Baughn> wuxia: It /is/ unreadable
01:31:21 <_zenon_> wuxia, Sometimes it makes entangled expressions littered with lambda's more readable
01:31:24 <Baughn> wuxia: Never mind that, without depoly, you /can't/ write it pointlessly. ;)
01:31:45 <schme> _zenon_: lift weights, hack code, play backgammon, and try to learn haskell. Average geek there, aight :D
01:31:57 <_zenon_> schme, Backgammon! I like :)
01:32:23 <schme> yeees.. excelleent.
01:33:18 <_zenon_> The only thing I have a hard time accepting with backgammon is the chance element
01:33:25 <schme> _zenon_: any day you are up for a low to modest wager game of backgammon, just send me a message at ladbrokes. eeeeasy money for ya.
01:33:31 <schme> That's the best part.
01:33:32 * Baughn hands schme a white cat and a guide to world domination
01:33:47 <schme> Baughn: Fluffy! I have been looking for her :D thanks!
01:34:01 <schme> _zenon_: The dice is what makes it better than chess and go :)
01:34:05 <_zenon_> schme, Humm.. I don't know. I try to stay of money-gambles :)
01:34:26 <schme> But.. eeeeeasy money .. ?
01:34:45 <_zenon_> @pl filter (\x -> /=[]) $ map (\x -> toUpper x) $ map (\x -> someFunction x) input
01:34:46 <lambdabot> (line 1, column 15):
01:34:46 <lambdabot> unexpected "/"
01:34:46 <lambdabot> expecting lambda abstraction or expression
01:35:07 <Baughn> schme: You're a haskeller. You're supposed to /despise/ horrible icky things like IO, randomness and backgammon!
01:35:11 <Baughn> Haskellers play go.
01:35:23 <_zenon_> Baughn, exactly :)
01:35:37 <_zenon_> Baughn, but still, it's a fatal attraction
01:35:50 <schme> Baughn: Go is fucking boring though. No element of gambling at all :)
01:36:08 <schme> Maybe that is why I'm not finding haskell so horribly attractive ;)
01:36:30 <_zenon_> @pl filter (\x ->x /=[]) $ map (\x -> toUpper x) $ map (\x -> someFunction x) input
01:36:30 <lambdabot> filter ([] /=) (map toUpper (map someFunction input))
01:36:44 <_zenon_> wuxia, You see, it became more logical
01:37:04 <schme> No randomness - no money games - no fun :S
01:37:09 <Baughn> @pl fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
01:37:09 <lambdabot> fibs = fix ((0 :) . (1 :) . ap (zipWith (+)) tail)
01:37:10 <dolio> pl doesn't do map fusion, eh?
01:37:16 <Baughn> wuxia: See, it became more logical
01:37:34 <_zenon_> Baughn, mister funny funny
01:37:47 <Baughn> _zenon_: Better than the last one. I almost understand this one
01:38:05 <opqdonut> schme: they play go for money in china
01:38:09 <_zenon_> wuxia, My point is, if you have some expression littered with lambdas (like I have when I am thinking) it sorts it out in a nice form
01:38:29 <opqdonut> korea probably too
01:38:55 <Baughn> I don't know. I don't think "for some x, x is unequal to []"; I think "it's unequal to []".
01:38:56 <schme> opqdonut: That's fucking stupid though, innit?  There's no element of gambling whatsoever.  It's like playing chess for money. People do it, it's still dumb :)
01:39:26 <Baughn> schme: Let me clarify. They play go for /other people's/ money.
01:39:33 <schme> Hah.
01:39:48 <schme> Very strange.
01:40:01 <_zenon_> Baughn, I think we made our point about waht @pl does :)
01:40:09 <Baughn> And there are few things more exciting than a high-level go match, so I can understand they'd want to spend money so they can /have/ some
01:41:04 <opqdonut> schme: well there's the element of haggling over the bet and handicap
01:41:28 <ejt> I think by 'gambling' schme means 'chance'
01:41:42 <schme> Well yes.
01:41:50 <Baughn> Horrible, icky chance. I really dislike games that involve chance. :/
01:42:05 <schme> They're the only games that earns one money though ;)
01:42:11 <Baughn> Play as well as you might, you can still lose
01:42:21 <Baughn> schme: I believe we just proved that isn't true. :P
01:42:21 <ejt> schme: tell that to Kasparov
01:42:40 <schme> Indeed. and the crappiest player in the world can go beat the best player in the world. just 'cause of the dice.
01:43:12 <Baughn> Exactly. DOesn't that strike you as /wrong/?
01:43:19 <schme> Well of course, other games can earn one money. But it's *easier* to go play poker or backgammon and win money there.
01:43:37 <ejt> hmm
01:44:02 <_zenon_> Baughn, what's /wrong/ is that hockey players earn more money than surgeons / doctors and firemen
01:44:15 <schme> Baughn: Not at all. If one would take these two players and have 'em play the same amount of games over a year, say 10 / day, then we would see the world class player coming out with more profit at the end of the year, and the crap player selling his house.
01:44:17 <_zenon_> Baughn, and all other vital parts of society
01:44:41 <_zenon_> schme, Of course, the law of big numbers :)
01:45:01 <Baughn> schme: But that's just taking the chance out of the game via statistics
01:45:30 <ejt> perhaps games of chance are the ones that lure niave people into thinking they can make money
01:45:38 <Baughn> schme: Another way of putting it is that there isn't as much difference between good and bad players. If you define one skill level as the amount of skill that gives you a 90% chance of winning over the level below.. how many levels are there in, say, backgammon?
01:45:41 <schme> Baughn: Well that is the overall idea of playing backgammon anyway. Playing it to make profit, and not loss.   One can't really just look at the individual games :)
01:45:50 <Baughn> I know that in go it would be at least thirty
01:46:21 <schme> Baughn: There is a *lot* of difference between a good backgammon player and a bad backgammon player :)
01:46:35 <Baughn> schme: Sure. How many skill levels? ;)
01:46:39 <_zenon_> Baughn, I would define skill as: The probability of beating an arbitrary opponent.
01:46:56 <Baughn> _zenon_: That one's very hard to calculate, though
01:46:58 <schme> I have no idea how many skill levels.
01:47:17 <_zenon_> Baughn, Indeed, but that's kind of how it works in real life, innit?
01:47:33 <_zenon_> Baughn, Of course, we do have "levels" in tournaments and such
01:48:15 <Baughn> _zenon_: Not so much. It seems strangely.. easy to assign levels in go, at least; I'm used to knowing before I start a match what my chances are
01:48:21 <Baughn> Usually "poor", but that's another story. :P
01:49:17 <schme> IIRC backgammon is considered more complex than chess, so it's not really a good game for "the average" player.   Not as high complexity as Go though.
01:49:33 <ejt> !
01:49:50 <schme> It just adds a small element of chance on top of that.
01:50:26 <schme> For good players the element of chance is just much smaller :)
01:50:26 <_zenon_> Baughn, Never played go =/ however, using a system of Skill := p(beat X in lvl y) , y = mylevel - 1, is it transitive?
01:50:40 <Baughn> That's very individual. I've always found go easier than chess; same as in haskell, the pieces don't move around, they board just gets more refined
01:51:11 <Baughn> _zenon_: Yes, I'd say so. Statistically only, of course, but the tendency is very clear
01:51:33 <Baughn> Someone at 22 kyu /will/ beat someone at 24 kyu most of the time, same with 20 vs. 22, etc.
01:51:58 <_zenon_> Baughn, In an AI perspective, Backgammon is _much_ harder than chess, also Go is harder. It's the nondeterminism that cracks it
01:52:02 <Baughn> Though it's more clear-cut at lower (that is, higher) levels, where players can be expected not to have any obvious holes
01:52:22 <schme> Though the backgammon AI's are really good these days :)
01:52:25 <ankh47> another stupid queston, in erlang, functions with different arity (number of parameters) were considered different functions, so helper functions fixing some params (ie. current date) could have same name. anything like this possible in haskell, or i just have to come up with different names ?
01:52:33 <schme> gnubg == kick arse.
01:52:39 <Baughn> schme: The Go AIs still beat me handily, too. ;)
01:52:58 <ejt> ankh47: different names - in a way functions all have 1 arg in haskell
01:53:05 <Baughn> ankh47: Come up with different names, or use Maybe or some such
01:53:41 <schme> Baughn: I recall reading that the Go AIs were not really that hot.. maybe the have gotten better. :)   In the backgammon world the AIs can actually get to competitive level with the world class players.
01:53:44 <Baughn> It isn't common to have functions with more than maybe three-four parameters or so at most, so the problem doesn't show up much
01:53:51 <schme> Now if just gnubg ran as fast on linux as it does on windows, I'd be a happy camper :S
01:54:08 <schme> 4 times as fast on windows :(
01:54:26 <Baughn> schme: No, go AIs are stuck at 15 kyu or so; that's 20-25 below world-class. It's just that *I'm* stuck at 22 - seven worse than the AIs. :P
01:54:41 <schme> Baughn: Keep at it, you'll kick their arses :D
01:54:46 <Baughn> schme: That skill system is based on handicaps, by the way, not the 90% thing I suggested earlier
01:54:59 <_zenon_> However, let's point finger at schme  for playing indeterministic games
01:55:16 <schme> Baughn: How does the handicap work?
01:55:22 <ankh47> thx
01:55:27 <schme> _zenon_: haha!
01:55:45 <Baughn> schme: The lower-skill player gets to place a number of stones on the board before the game starts, in a predetermined arrangement. It's a great benefit
01:55:57 <schme> Oh cool.
01:56:14 <Baughn> schme: The /maximum/ handicap is nine stone; I can manage to beat the AIs more or less 50% of the time with seven, which is a lot better than I used to at least. ;P
01:56:26 <ankh47> 2 ejt> right, i haven't put the twos together ;-))
01:56:34 <_zenon_> Baughn, how does the handicap reflect on the game score?
01:56:45 <schme> I've played backgammon with people at times and allowed 'me "handicap" of taking a few of their checkers off the board at start.. one or maybe two.   The game is to get all off of the board.  They tend to love the idea. It also increases my winning chances a *lot* :D
01:56:51 <ejt> Baughn: are the AIs good for a novice to learn with ?  I tried to teach myself Go, but couldn't find an opponent
01:56:57 <Baughn> _zenon_: It doesn't. Go games are win/lose.
01:57:09 <_zenon_> Baughn, Oh,, that doesn't seem all to fair.
01:57:23 <schme> Baughn: There are good go servers around for playing live opponents though?
01:57:40 <Jedai> ankh47: You can also do tricks with records to have default arguments
01:57:50 <Baughn> _zenon_: Only non-handicapped games count for ranking, though
01:58:16 <Baughn> ejt, schme: Yep, use kiseido and play against live opponents. There are lectures too, for a very modest price
01:58:29 <osfameron> schme: because on the first time around their pieces are less well defended?
01:58:35 * _zenon_ liked chessmaster, with the school and all :)
01:58:47 <Baughn> That said, the AI should be very decent for a newbie; it doesn't make any obvious mistakes I've found, so you won't get bad habits. I think.
01:58:49 <Jedai> ankh47: like myFunction (defaultArgs { day = 5, month = "June" })
01:59:26 <ejt> Baughn: thx, will try it.  Have got bored of my FICS chess rating not moving
02:00:24 <schme> osfameron: first time around?   There tend to be several times around over a game.   But less checkers actually make it harder to do things like block your opponents checkers, build a strucker for safe transport of your own checkers, and most importantly it lessens the moves you can do with every roll of the dice. One just gets into crappier structures, and it all breaks down. :)
02:00:59 <osfameron> schme: yeah, that's more or less what I meant.  Interesting!
02:01:12 <schme> osfameron: It's a good trick :)
02:01:17 <osfameron> schme: heh, yeah
02:02:00 * _zenon_ sets topic to "Backgammon and other Stochastic games"
02:02:17 <schme> Anyway I'm quite sure you'll all get converted to the dark side once I finish my haskell backgammon thingie :P
02:02:35 <_zenon_> schme, Interesting, will you put it on hackage?
02:03:07 <osfameron> backgammon is lovely, though I haven't really played since uni, 10 years ago :-(
02:04:02 <schme> _zenon_: Sure!   Just let me google that up so I know what it is first :)
02:04:22 <schme> :(
02:04:38 <_zenon_> schme, http://hackage.haskell.org/
02:04:40 <lambdabot> Title: HackageDB: introduction
02:06:03 <schme> Right. A bit like cliki.
02:06:48 <schme> Seems about a good a place to put it as any other :)
02:11:03 <BeelsebobWork> hmm, where in the module hierarchy would you lot put a module for loading a 3D file format
02:11:10 <BeelsebobWork> (not for displaying it at all, just loading it)
02:12:34 * BeelsebobWork is pondering if it goes in Data.Graphics, or in Graphics,Data
02:12:52 * BeelsebobWork wishes modules were in a tag based system
02:13:07 * vixey wishes there -was- a module system
02:13:19 <BeelsebobWork> heh, well, there is -- just not a standard one
02:13:21 <DRMacIver> It doesn't seem appropriate for Data.*
02:13:30 <opqdonut> i'd say Graphics
02:13:33 <BeelsebobWork> DRMacIver: even though it's doing nothing but manipulating Data?
02:13:47 <BeelsebobWork> and creating a data structure with which you happen to be able to display graphics
02:14:16 <BeelsebobWork> (note, not disagreeing, just clarifying)
02:14:33 <DRMacIver> I'm not sure of the formal intent of Data, but it seems more of a data structures than data formats package. *checks the library docs for exampless*
02:14:34 <_zenon_> Data.Graphics.yourthingie
02:14:57 <BeelsebobWork> _zenon_: yep, but you could argue strongly for Graphics.Data.mythingy too
02:15:06 <BeelsebobWork> DRMacIver's logic makes a good amount of sense there
02:15:20 <DRMacIver> In particular I can't see another instance of a data format living in Data.*
02:15:44 <_zenon_> BeelsebobWork, However, It is a Particular Datastructure for handling Graphical thingies, I'd say Data.Graphics.Thingie
02:16:06 <BeelsebobWork> _zenon_: well, it's a particularly boring data structure -- it's only interesting because it's the structure in the file format
02:16:20 <BeelsebobWork> and in fact, the whole idea is to get it out of that structure and into FieldTrip's various formats
02:16:29 <DRMacIver> But Graphics is already a top level package, and Data doesn't seem to get used for that sort of thing. Having a new Data.Graphics for this seems incoherent.
02:16:34 <BeelsebobWork> I think I'm leaning towards Graphics.Data.Obj
02:17:03 <BeelsebobWork> or possibly Graphics.ImportExport.Obj
02:17:07 <BeelsebobWork> or something like that
02:17:23 <osfameron> does "Obj" add anything?
02:17:30 <BeelsebobWork> Obj is the format
02:17:49 <DRMacIver> Empirically, file formats in hackage appear to be spread throughout the appropriate top level packages to which they belong to.
02:17:51 <BeelsebobWork> i.e. I'd expect for example Graphics.ImportExport.Lightwave to live side by side with it
02:17:52 <osfameron> the format is called "Obj"? heh, nice overloaded name :-)
02:17:53 <vixey> what about Graphics.Formats.Obj
02:18:06 <BeelsebobWork> vixey: oh, that's a nice one
02:18:10 <DRMacIver> I like vixey's suggestion.
02:18:14 <BeelsebobWork> yeh, I think that's probably a good place to put it
02:18:23 <DRMacIver> Anyway, got to go. Bye.
02:21:16 <Baughn> So, this thing instances Binary, right?
02:21:25 <BeelsebobWork> nope
02:21:32 <BeelsebobWork> Obj isn't a Binary format
02:21:43 <Baughn> Hm. Then what is it?
02:21:49 <BeelsebobWork> just text
02:22:12 <Baughn> That doesn't mean you can't instance binary. ;)
02:22:26 <BeelsebobWork> it does however mean I don't want to though
02:22:33 <Baughn> It could be useful for people who want to embed it in another format, you know
02:22:58 <BeelsebobWork> it could, but I have a very specific purpose at the moment, and it may not be made public
02:23:04 <BeelsebobWork> so at the moment, I'm being rather quick and dirty
02:23:30 <BeelsebobWork> at some point, I may add a Data.Binary instance
03:01:43 <_zenon_> so silent
03:02:23 <schme> Yes, indeed.
03:02:30 * schme heads off to paint some walls.
03:03:04 * ankh47 is listening to the sound of silence ;-)
03:05:11 <_Dae_> ankh47: isn't that a Simon and Garfunkel song?
03:17:45 <ankh47> 2 dae: yeah, it is. i had to find it to make that statement doubly true ;-))
03:24:07 <conal> does anyone here use ghc-6.9 on Win32?  i'm looking for a recommended version.
03:40:00 <pierre-> hello
03:52:03 <_zenon_> pierre-, hello
04:05:22 <plutonas> how do i check if some element is in a list?
04:07:00 <Zao> :t elem
04:07:03 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
04:08:07 <_zenon_> (/=[]) [x|x<-list, e == x]
04:08:16 <plutonas> Zao: thanks, but now that i think of it, is there also a way to get the match?
04:08:20 <_zenon_> @src elem
04:08:20 <lambdabot> elem x    =  any (== x)
04:08:28 <_zenon_> oh, nifty def
04:08:32 <Zao> plutonas: The index?
04:08:39 <plutonas> index would do
04:08:42 <plutonas> but wait a sec
04:08:49 <DRMacIver> I enjoy the documention "RealWorld is deeply magical" in ST.
04:08:56 <Zao> :t Data.List.elemIndex
04:08:57 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
04:09:10 <_zenon_> @src Data.List.elemIndex
04:09:10 <lambdabot> Source not found. Where did you learn to type?
04:09:11 <plutonas> actually what i want to do is something like having a list [(a, b), (c, d)...]
04:09:13 <_zenon_> awww
04:09:35 <plutonas> where the first element in each tuple is the key and the second should be returned if the first matches
04:09:43 <Zao> _zenon_: http://haskell.org/ghc/docs/latest/html/libraries/base/src/Data-List.html#elemIndex
04:09:44 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/392kwb
04:10:01 <plutonas> perhaps there is some other function already for this?
04:10:43 <_zenon_> plutonas: Sounds like a Data.Map
04:12:10 <_zenon_> plutonas, Have you looked through Data.List ?
04:12:16 <_zenon_> plutonas, A lot of nifty things there
04:12:26 <plutonas> looking now, thanks
04:13:03 <_zenon_> plutonas, What you wanted earlier is lookup, however, a Data.Map could be nice if you do it frequently
04:13:08 <Zao> @type \x y -> snd.filter ((==x).fst) y
04:13:09 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> [b]
04:13:27 <Zao> A proper Map is most likely better though.
04:14:21 <plutonas> Zao: i think lookup is what i want
04:14:23 <plutonas> thanks all
04:14:53 <BONUS> a Data.List lookup has O(n) worst case performance (afaik)
04:15:00 <BONUS> a Data.Map lookap has O(logn)
04:17:15 <noteventime> lol
04:17:20 <noteventime> Opps, wrong channel
04:17:59 <Zao> Well said :)
04:18:24 <DRMacIver> BONUS: Not just worst case: expected case.
04:18:51 <Zao> DRMacIver: Surely it can early out?
04:19:10 <DRMacIver> Zao: It can early out, but the expected number of steps to do so is still O(n). :)
04:19:43 <DRMacIver> And for any key not in the list you have to traverse the entire list to verify that.
04:23:57 <vixey> :t (\x -> ?f (\y -> ?g))
04:23:58 <lambdabot> forall t t1 t2 t3. (?g::t3, ?f::(t2 -> t3) -> t1) => t -> t1
04:24:58 <vixey> @pl (\x -> f (\y -> g))
04:24:59 <lambdabot> const (f (const g))
04:25:01 <BONUS> whats ?f
04:25:46 <DRMacIver> Implicit function arguments. One amongst the myriad GHC extensions (and not a very popular one)
04:27:08 <BONUS> ah
04:27:38 <vixey> I don't think I'll be able to write up this algorithm before I get some sleep -_-
04:33:39 <tibbe> dcoutts: I'm having trouble compiling Gtk2Hs using ports on a map, it segfaults on linking
04:36:24 <zachk> how do i get abritrary precision decimal numbers in haskell?
04:37:03 <mauke> it's not decimal but Rational has arbitrary precision
04:37:43 <ndm> zachk: Integer has it
04:38:00 <tibbe> dcoutts: never mind, fixed it :)
04:38:10 <ndm> zachk: for integers, Ratio Integer has it otherwise
04:38:38 <zachk> ndm: thank you
04:38:39 <tibbe> gotta perform a phone screen, brb
04:40:01 <dcoutts_> tibbe: any idea what was wrong?
05:07:21 <quicksilver> zachk: CReal might be better than Ratio Integer for some uses
05:07:37 <quicksilver> you don't have much control over the way that Ratios of Integers 'collect precision'
05:14:52 <chrisdone> quicksilver: is this awesome (y/n)? http://img514.imageshack.us/img514/9206/algosxh9.png
05:16:51 <_zenon_> chrisdone, It's nice.
05:17:32 <_zenon_> chrisdone, What controls how tight the words will be?
05:18:39 <Saul_> chrisdone: That's pretty cool
05:18:48 <quicksilver> chrisdone: it is very nice.
05:19:00 <quicksilver> chrisdone: can you use the space exposed by the ascender of the "h" ?
05:19:00 <Saul_> chrisdone: Is there going to be an HTML version?
05:20:23 <chrisdone> quicksilver: I can't because gd doesn't give me the coordinates of the glyph, so it's only capable of rectangular placement at the moment :)
05:20:35 <Toxaris> to be conform with CT-inspired Haskell terminology, we may need initial@haskell.org and terminal@haskell.org as beginners / teachers list names, since beginners can still be morphed into every possible Haskell programmer by education, but teachers have found their programming style and are able to relate it to everyone.
05:20:44 <Baughn> chrisdone: Randomize colors? Or at least, please, /not the purple/!
05:21:08 <Lemmih> andyjgil1: ping.
05:21:26 <Twey> Baughn: The purple is *awesome* :-P
05:21:35 <Baughn> Twey: It's dinosaur purple.
05:21:42 <chrisdone> _zenon_: it places words from the largest to smallest, and for each one, tries to place it somewhere around the largest word, if it can't, it tries the next largest, and so on until it finds a small word that will have space, somewhere around the edge. algo2 just picks a word to sit next to that is closer to the centre
05:21:54 <Twey> Baughn: Yes.  Yes it is.
05:22:07 <chrisdone> Saul_: a HTML version? I haven't thought about that
05:22:20 <_zenon_> chrisdone, would be nice
05:22:28 <Baughn> chrisdone: It would be nigh-impossible, too. Do it!
05:22:41 <chrisdone> Baughn: okay :P no Barney colours
05:22:48 <Toxaris> nice picture<html shouldn't
05:22:56 <Baughn> Good luck making something that doesn't make my browser lock up
05:23:03 <Toxaris> html shouldn't be too hard with CSS and explicit positions
05:23:14 <Baughn> Maybe set all the words to (distinct) absolute coordinates?
05:23:20 <Baughn> Toxaris: But that doesn't work with IE.
05:23:45 <Saul_> There are already tag clouds made in other languages, so it's probably not that hard
05:23:48 <Toxaris> really? too bad. who cares?
05:24:09 <chrisdone> a problem with that would be ensuring the fonts and font sizes were as the generator expected them to be
05:24:10 <Baughn> "#haskell: Sponsored by Microsoft"
05:24:17 * Twey laughs.
05:24:24 <chrisdone> hehe
05:24:36 <Toxaris> I have no problem with Microsoft, sitting on Windows laptop right now, but IE is crap
05:24:38 <Baughn> chrisdone: Well, you can specify font sizes in pixels. That should be good enough.. hopefully..
05:24:49 <Baughn> Give it a few extra pixels of clearing, I guess
05:25:02 * _zenon_ joins #linux
05:25:16 <Twey> But IE allows resizing of pixel-sized fonts
05:25:43 <quicksilver> chrisdone: shame, it would look much nicer.
05:25:45 <quicksilver> ;)
05:26:10 <Twey> Baughn: The dinosaur purple is proof of the long-suspected axiom that *anything* goes with black.
05:26:14 <BeelsebobWork> @hoogle (a,b,c) -> a
05:26:16 <lambdabot> No matches, try a more general search
05:26:25 <BeelsebobWork> bah
05:26:29 <BeelsebobWork> not fst3?
05:26:36 <chrisdone> quicksilver: yeah, I looked around for a library that would give me glyph information but haven't yet found a haskell library
05:26:38 <ejt> define it yourself
05:26:46 <BeelsebobWork> ejt: sure -- but... effort :P
05:26:46 <ejt> BeelsebobWork: ^
05:26:49 <ejt> :)
05:27:11 <Toxaris> BeelsebobWork: sometimes it helps to use (a, (b, c)) instead of (a, b, c). more often, a data type is appropriate
05:27:36 <Baughn> Twey: Okay. Solution: Render the fonts on the server, stick <a href="F.png"> in to get an F.
05:27:39 <BeelsebobWork> Toxaris: true enough, I have always wondered why Haskell doesn't only have pairs
05:27:46 <BeelsebobWork> after all, they're slightly more general than tuples
05:28:14 <Twey> Baughn: You mean <img src="F.png">?  :-P
05:28:24 <Twey> alt="F"?
05:28:31 <Baughn> Twey: Possibly. and no, no alt text.
05:28:39 <mauke> Baughn: ILLEGAL
05:28:41 * Twey backs away.
05:28:47 <chrisdone> mauke: haha
05:28:48 <Twey> He DOESN't FOLLOW STANDARDS!
05:28:48 <BeelsebobWork> Baughn: get your html right <img src="F.png" alt="F" />
05:28:53 <Baughn> mauke: Operation executed. Terminate program?
05:29:01 <mauke> BeelsebobWork: /> is also wrong
05:29:02 <Twey> BeelsebobWork: We don't want an extra >, thanks
05:29:05 <Baughn> BeelsebobWork: That's XHTML
05:29:12 <quicksilver> chrisdone: I don't think any font tool will give you the information "the ascender of the h only takes 10% of the width and is on the left"
05:29:23 <BeelsebobWork> Baughn: I know it is -- but XHTML 2.0 is the current most recent html standard
05:29:27 <quicksilver> chrisdone: I think you'd have to render to a test resolution and generate experimental bounding boxes.
05:29:41 <Baughn> BeelsebobWork: Sorry. I write only to actual browsers, not pies in the sky
05:29:53 <Baughn> Which is to say, I follow the HTML 4.01 standard slavishly
05:29:57 * Twey nods.
05:30:00 <quicksilver> chrisdone: after all glyphs can have arbitrarily complet  sahpes.
05:30:01 <BeelsebobWork> Baughn: I write plenty of XHTML 2.0, it works in all browsers
05:30:06 <Twey> I hope that's HTML 4.01 Strict :-P
05:30:06 <quicksilver> complex.
05:30:09 <Twey> BeelsebobWork: No, it doesn't
05:30:10 <BeelsebobWork> (noting that Internet Explorer is not a browser)
05:30:13 <Twey> Oh
05:30:15 * Twey laughs.
05:30:24 <BeelsebobWork> it doesn't render html -- therefor it's not a browser
05:30:25 <Twey> Things have XHTML2 support now?
05:30:41 <BeelsebobWork> Twey: WebKit and Gecko certainly both deal with it fine
05:30:44 <Baughn> BeelsebobWork: Did they add <include> support to XHTML2?
05:30:50 <Baughn> *Please* tell me they did! For the love of god!
05:30:54 <BeelsebobWork> Baughn: not that I know of
05:31:01 * Baughn weeps
05:31:35 <chrisdone> quicksilver: yeah, I considered composing letters out of smaller boxes and specifying that somewhere, but then I am limited to 26 letters...
05:32:16 <Twey> Baughn: Heh
05:32:18 <Twey> Baughn: It's OK
05:32:28 <Twey> Baughn: It's XHTML, so you can mix in the XInclude namespace
05:32:33 <BeelsebobWork> in the mean time... why doesn't the internet run on Haskell with web page rendering combinators?
05:32:34 <Twey> . . . in theory.
05:32:37 <Baughn> Twey: Which no browsers support.
05:32:41 * Twey chuckles.
05:32:42 <Twey> Aye.
05:32:57 <BeelsebobWork> main = html (head doom) (body more doom)
05:33:05 <BeelsebobWork> if you must
05:33:09 <BeelsebobWork> or something nicer if you musn't
05:34:11 <chrisdone> quicksilver: by “generate experimental bounding boxes”, do you mean drawing and comparing the actual pixels? I could see that working. comparing a drawn letter with a drawn letter next to another and see if the pixels in the rectangle have changed although it sounds kind of slow?
05:34:46 <BeelsebobWork> it also sounds like something unlikely to work on any OS that antialiases text
05:35:31 <Baughn> Or even worse, sub-pixel rendering
05:35:37 <BeelsebobWork> idd
05:35:50 <Baughn> "101%3:30" is an annoying sort of size
05:35:51 <Toxaris> BeelsebobWork: I would generate a low resolution rastering of the letter (e.g. 8x8) and use that for placement
05:36:19 <chrisdone> I think Java's font API (what Wordle uses) gives you letters as shapes so that it's easy to recognise overlapping.
05:37:21 <gwern> @seen dons
05:37:22 <lambdabot> dons is in #arch-haskell, #xmonad, #ghc and #haskell. I last heard dons speak 6h 26m 48s ago.
05:37:39 <Baughn> Twey: Oh hey. IE 7 supports xinclude.
05:37:44 <Baughn> This is troubling
05:37:47 <chrisdone> “The shapes that a font uses to represent the characters in the string are called glyphs. A font might represent a character such as a lowercase a acute using multiple glyphs, or represent certain character combinations such as the fi  in final with a single glyph. In the Java 2D API, a glyph is simply a Shape that can be manipulated and rendered in the same way as any other Shape.”
05:38:03 <Twey> Baughn: *blink*
05:38:12 <Twey> How can IE7 support XInclude?
05:38:13 * Baughn is currently using an autogenerated 700-chars-long document.write for the purpose
05:38:17 <Twey> It doesn't even support XHTML.
05:38:29 <BeelsebobWork> Twey: sure it does
05:38:36 <BeelsebobWork> IE7 supports a decent amount of XHTML
05:38:40 <BeelsebobWork> IE6 fails at it
05:38:41 <Twey> BeelsebobWork: What?  No it doesn't
05:38:51 <Twey> It still doesn't even recognise the MIME-type
05:39:01 <BeelsebobWork> it does for me
05:39:11 <chrisdone> it's funny looking at the source of Google's homepage
05:39:14 <Twey> Are you serving your 'XHTML' as text/html?
05:39:53 <BeelsebobWork> nope, application/xhtml+xml
05:40:01 <gwern> @tell dons I know all about frakview. I followed it from the start and have it locally. for weeks it was at the top of my todo list; if nomeata had cooperated it would've been on hackage the next day. but the problem is, I've asked several times in several ways what the frakview license is (only one module has any info) and he has stolidly ignored me
05:40:02 <lambdabot> Consider it noted.
05:40:04 <BeelsebobWork> with an XHTML2.0 DTD tag at the start
05:40:31 <trittweil> I'm getting <interactive>: out of memory (requested 1048576 bytes) from ghci when trying to print stuff that's moderately large. Now is there some problem known? (I can't exclude that the box has some memory restrictions, but 1MB looks kiddingly low.)
05:41:08 <Baughn> trittweil: That's "requesting 1MB on top of what I already have"
05:41:13 <Twey> Nope, BeelsebobWork, can't be application/xhtml+xml
05:41:15 <Twey> Link?
05:41:27 <BeelsebobWork> Twey: internal things :/
05:41:47 <Twey> BeelsebobWork: telnet into it and do a HEAD with an IE7 UA string
05:41:49 <Baughn> trittweil: Run with +RTS -Sstderr and you'll get continual feedback on memory use. Can be a bit annoying, mind; use -Sgc.log and tail gc.log in another terminal, maybe
05:42:08 <Twey> I'd bet a reasonable amount of money it's serving tag soup
05:42:41 <olsner>  Warning: No explicit method nor default method for `toEnum' In the instance declaration for `Enum LocalToGlobalBlock' ... shouldn't that be an error?
05:43:25 <olsner> does that yield a default method toEnum = undefined or something like that?
05:43:29 <Toxaris> olsner: is well defined in report to be undefined for whatever stupid reason
05:43:32 <chrisdone> I guess it's only an error if your code tries to use it
05:43:44 <trittweil> Baughn: Thanks, I'll try that out.
05:43:54 <BeelsebobWork> Twey: I don't know how to speak HTTP -- could you clarify in pm?
05:44:15 <Baughn> trittweil: Oh, and since an actual OOM condition tends to involve massive system slowdowns, you might want -M128m or something to limit heap size to something sane
05:44:16 <olsner> oh, how very unhaskelly
05:44:16 <chrisdone> GET / HTTP/1.1\nHost: yourhost\n\n
05:44:17 <chrisdone> done
05:44:32 <chrisdone> olsner: seems like “lazy” compilation to me :P
05:44:39 <BeelsebobWork> chrisdone: he wants various headers specified
05:44:40 <trittweil> Baughn: I can't imagine it's a real OOM from the kernel, as the box got 4GB.
05:44:52 <Baughn> trittweil: Hm. 32-bit OS?
05:45:02 <olsner> chrisdone: heh, I'm just waiting for the lazy type checker :D
05:45:09 <chrisdone> olsner: hehe
05:45:26 <chrisdone> BeelsebobWork: ok
05:45:26 <Toxaris> lazy static type checking: the worst of two worlds?
05:45:30 <Baughn> trittweil: If you get that message, without a set memory limit, that means your program /is/ getting an OOM from the kernel
05:45:31 <trittweil> Baughn: No 64, I believe.
05:45:44 <olsner> Toxaris: something like that :)
05:46:09 <Baughn> trittweil: Well, use -Sstderr and check what it tops out at. A memory-eater will happily chew a couple dozen gigabytes, actually..
05:46:55 <ddarius> "Despite the positive ju-ju of 'dynamic' it has come to be associated with 'slow'.  For the 21st century we choose a new term that is more associated with speed: just-in-time typechecking."
05:47:36 <chrisdone> ju-ju
05:47:46 <ejt> ddarius: where's that quote from ?
05:47:59 <ddarius> Nowhere.
05:49:48 <Toxaris> ddarius: could be a good idea to avoid runtime tags
05:50:31 <Toxaris> partial evaluation of typecase constructs at just-in-time compile time
05:51:16 <ddarius> Something like that is already done in some (many?) JIT systems.
05:51:43 <Toxaris> why are all obvious ideas already taken?
05:52:12 <Baughn> That's how you know they're obvious
05:52:26 <gwern> @tell dons also, the email for the hspark guy is dead as well as the cvs server
05:52:27 <lambdabot> Consider it noted.
05:53:01 <Philippa> ddarius: not "just too late" typechecking? :-)
05:54:45 <olsner> "almost-in-time" typechecking? :P
05:55:45 <trittweil> Baughn: Well, I pretty much know what's causing the problem. I want to trace some internal data structure, and to get a nice print out, I first use the haskell-src-exts parser to parse the stuff, and use it together with Text.PrettyPrint to get nicely indented haskell code as output.
05:56:23 <trittweil> Baughn: There's probably a better way to achieve that, isn't there? :-)
05:56:59 <Baughn> trittweil: Um. You're doing something like print . prettyprint-haskell . show ?
05:57:12 <Baughn> How large is this data structure?
05:57:12 <trittweil> Yeah
05:57:36 <trittweil> two, or three pages
05:57:45 <Baughn> I can't see you running out of memory on that, then. Except..
05:58:02 <trittweil> Without tracing I allocate less than 150Mb in total
05:58:05 <Baughn> Try print . length . show instead - is it possible there's a cycle?
05:58:35 <Baughn> 150MB in total? Or peak memory use?
05:58:41 <Baughn> Also, define "tracing"
05:59:16 <trittweil> Debug.trace (my_pretty_print datum) datum
06:00:06 <Baughn> And how much memory does it end up using then?
06:00:12 <Baughn> That's the /only/ line that's different?
06:01:46 <trittweil> Without tracing, gc.log contains 147 Mb total memory in use
06:02:36 <trittweil> With tracing, I have no idea how to get at that information, as the resulting gc.log is truncated at printing an allocation frame
06:03:04 <Baughn> Well, how about the line before it?
06:03:26 <trittweil>    923864    131872  68571136  0.00  0.00    4.09    9.42    0    0  (Gen:  0)
06:03:44 <Baughn> ..not very much.
06:03:45 * ddarius should use usw. in his English speaking/writing more often.
06:04:01 <kpreid> ddarius: ?
06:04:11 <BeelsebobWork> does cabal have support for quickcheck, and if so, how do I go about running all tests?
06:04:19 <vixey> why must texts exist on ACM but not elsewhere
06:04:24 <trittweil> Baughn: But it indeed seems to slow down tremendeously
06:04:40 <Baughn> trittweil: Okay. Can't say I have many more idea, but.. compile with -threaded (for the deadlock detection), and then try tracing but only printing (length (show datum)) instead of pretty-printing
06:05:09 <ddarius> kpreid: "und so weiter"
06:05:19 <trittweil> Baughn: You mean I should compile the whole thing, not pass -threaded to ghci, don't you?
06:05:23 <Baughn> Yes
06:06:28 <olsner> is there no english acronym for "and so on" or some equivalent idiom?
06:07:00 <ddarius> olsner: There is.  "and so forth" would be the most natural equivalent.  No acronym, I don't think.
06:07:06 <trittweil> etc.
06:07:35 <astrolabe> although etc isn't strictly an acronym
06:08:03 <olsner> wouldn't it be more logical to start introducing asf into english rather than trying to use a german acronym?
06:08:25 <astrolabe> olsner: etc. fills the roll quite well.
06:08:30 <ddarius> olsner: Assuming I'm trying to be logical was your first mistake.
06:09:23 <ddarius> astrolabe: Actually, et cetera has somewhat different connotations to me though it is often interchangable.  Anyway, Latin is okay but German isn't?
06:09:37 <ddarius> Heck, English is a Germanic language not a Romance one.
06:10:16 <astrolabe> ddarius: But etc. is a standard abbrieviation.  'asf' is not.
06:10:52 <ddarius> I never suggested "asf."  That would just be stupid.
06:11:25 <ddarius> Anyway, I have to go to work.
06:11:32 <trittweil> Baughn: Not using ghci seems to make the problem go away.
06:12:07 <Baughn> trittweil: That does occasionally happen. It's a bug, but I couldn't help you do anything about it.
06:12:19 <trittweil> It's a bug in my code?
06:12:24 <Baughn> No, in ghci
06:12:34 <Baughn> Oh.. it might work anyway if you start ghci with -fobject-code
06:13:04 <trittweil> I'm chewing hard on ghci anyway as it regularly loses some trace output. But I think I bugged you on that one before.
06:15:07 <olsner> hmm, I have a readP-based parser that fails mysteriously - but I don't know what it's trying to parse ... I'd like some way to easily run a ReadP-parser in an error monad and get an error message out of it :)
06:16:59 <trittweil> Baughn: What's that supposed to do?
06:17:15 <Baughn> trittweil: That makes ghci compile code before executing it
06:17:26 <Baughn> Using, I assume, the same code generator as ghc
06:19:06 <trittweil> Can't find interface-file declaration for variable pprintConversionUnit
06:19:20 <Baughn> No idea.
06:19:24 <trittweil> I try to invoke pprintConversionUnit at the toplevel
06:22:28 <trittweil> Baughn: Thank you for your help!
06:22:50 <lilachaze> @hoogle [a] -> [b] -> [(a,b)]
06:22:54 <lambdabot> Prelude.zip :: [a] -> [b] -> [(a, b)]
06:22:54 <lambdabot> Data.List.zip :: [a] -> [b] -> [(a, b)]
06:23:06 <lilachaze> heh, not that one :)
06:23:24 <rwbarton> :t liftM2 (,) -- ?
06:23:40 <lambdabot> thread killed
06:23:41 <lilachaze> @undo \a b -> [(x,y) | x <- a, y <- b]
06:23:43 <lambdabot> \ a b -> concatMap (\ x -> concatMap (\ y -> [(x, y)]) b) a
06:23:50 <bos> @seen dcoutts
06:23:50 <lambdabot> dcoutts is in #gentoo-haskell, #haskell, #ghc, #haskell-overflow and #haskell-soc. I last heard dcoutts speak 4h 3m 24s ago.
06:23:53 <sander___> hi
06:23:55 <rwbarton> > liftM2 (,) [1,2,3] [4,5,6]
06:24:03 <lambdabot>  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
06:24:10 <lilachaze> :) cool, thanks
06:24:36 <sander___> what's the recommended way to parse a tab delimited string in haskell?
06:25:02 <Baughn> sander___: splitBy (== '\t') would work
06:25:14 <rhz> Anybody know what this could mean: "Couldn't match expected type `Vector3 GLdouble' against inferred type `Vertex3 GLdouble'"?
06:25:16 <Baughn> THough you'll have to wait for 6.8.4 until that one's part of the standard library
06:25:20 <sander___> nice idea:)
06:26:22 <quicksilver> rhz: Yes. Vector3 and Vertex3 are different types.
06:26:27 <quicksilver> you used one instead of the other.
06:26:31 <rhz> so they are..
06:26:50 <Baughn> sander___: http://hpaste.org/8848 <-- Here's one
06:27:02 <sander___> Baughn: thanks!
06:27:08 <Baughn> ..though not, I think a good one. Hmm..
06:27:27 <sander___> lol
06:28:43 <Baughn> sander___: plitBy f s = case dropWhile f s of "" -> []; s' -> let (w, s'') = break f s' in w : splitBy f s''
06:29:10 <BeelsebobWork> trittweil: I didn't find what your problem was with a bit of scrolling up, but the major difference I've found between ghci and compiled code wtr to threading that I've found is that when running from compiled code, the main thread gets bound
06:29:13 <BeelsebobWork> which is not true in ghci
06:29:23 <BeelsebobWork> you may want to use runInBoundThread
06:30:00 <sander___> Baughn: works pretty well
06:32:32 <olsner> @bot
06:32:32 <lambdabot> :)
06:33:12 <olsner> hmm, is there something like mconcat but for MonadPlus and not Monoid?
06:33:57 <Baughn> olsner: msum
06:34:11 <olsner> ah, thanks
06:34:21 <Baughn> @instances MonadPlus
06:34:36 <lambdabot> Couldn't find class `MonadPlus'. Try @instances-importing
06:34:45 <Baughn> @instances-importing Control.Monad MonadPlus
06:34:46 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
06:35:01 <Baughn> > msum [[1..3],[9..15]]
06:35:06 <lambdabot>  [1,2,3,9,10,11,12,13,14,15]
06:36:16 <BeelsebobWork> Does anyone know how to get cabal-test to work?
06:43:04 <dcoutts_> BeelsebobWork: never used it, sorry. What does it do?
06:43:07 <cnwdup_> http://hpaste.org/8921 I am having trouble with this piece of code. I'd like to declare a default method for emitSignal in the class definition. But since this depends on addToQeueue (of type Queue Signal -> Signal -> IO ()) depends on its second argument to be of type Signal there's some kind of include circle I guess. How can I solve that?
06:43:10 <dcoutts_> bos: pong
06:43:23 <bos> dcoutts_: just filed a few gtk2hs bugs :-)
06:43:29 <cnwdup_> Someone here was helping me earlier on this. But I didn't show him enough code, I guess.
06:43:30 <BeelsebobWork> dcoutts_: I'm not 100% certain -- I'm hoping it allows me to do runhaskell Setup.hs test, and have all my quickcheck properties tested
06:43:46 <dcoutts_> bos: good good :-) any vital ones you need fixing for RWH?
06:43:46 <bos> dcoutts_: one is a trivial trac issue, the other looks like a ghc bug on ppc.
06:43:54 <bos> dcoutts_: nope.
06:44:28 <dcoutts_> BeelsebobWork: runhaskell Setup test will work if you use the test hook in your Setup.hs, it is basically just an IO () action though
06:45:06 <BeelsebobWork> dcoutts_: oh? so is there something I can jam in there to get it to run tests on all prop_s?
06:45:42 <dcoutts_> BeelsebobWork: nothing built-in, you get an IO () action and access to the core libs so you can do whatever you like
06:45:53 <BeelsebobWork> ah, k
06:46:21 <BeelsebobWork> not 100% sure if that's useful or not -- it may require significant jibbling about to find all the prop_s
06:46:42 <SamB_XP> BeelsebobWork: just jam in an existing Haskell script ;-)
06:46:42 <quicksilver> cnwdup_: I don't see the connection between your own description of the problem and the error in that paste.
06:47:04 <quicksilver> cnwdup_: the error in that paste simply indicates that your instance for Signal Ping looks wrong because you didn't define the method in it.
06:47:05 <BeelsebobWork> SamB_XP: you know of an existing Haskell script that does that?
06:48:16 <SamB_XP> BeelsebobWork: generally they are called quickcheck.hs or something like that
06:48:32 <SamB_XP> maybe quickcheck.lhs...
06:48:33 <SamB_XP> I forget
06:48:40 <Jessehk> Hello all. Is there an easy way to represent infinity in Haskell? What I really need is a quantity that will always be larger in a comparison.
06:49:01 <quicksilver> Jessehk: in IEEE types there is actually an Infinity.
06:49:12 <quicksilver> outside of that, you see people 'augmenting' types with extra values.
06:49:17 <cnwdup_> quicksilver: The error results from emitSignal being defined in an instance declaration not as a default method in the class itself. But I want it to be as a default method. Maybe this will make it more clear: http://hpaste.org/8922
06:49:43 <Jessehk> quicksilver: http://www.haskell.org/hoogle/?q=Infinity ?
06:49:43 <BeelsebobWork> SamB_XP: the normal quickCheck script needs you to tell it what file to look at -- which isn't so easy from within Cabal
06:49:44 <lambdabot> Title: Infinity - Hoogle
06:49:47 <BeelsebobWork> in that you want it for all files
06:50:04 <SamB_XP> BeelsebobWork: hmm
06:50:05 <quicksilver> > 1/0
06:50:08 <lambdabot>  Infinity
06:50:09 <quicksilver> Jessehk: ^^
06:50:20 <cnwdup_> Line 8 might be bogus. But it doesn't effect the error.
06:50:31 <quicksilver> cnwdup_: In your first paste emitSignal was defined neither as a default method, nor in the instance for Ping.
06:50:43 <cnwdup_> Yeah. But I can't define it as default method.
06:50:59 <quicksilver> what is the type of addToQueue?
06:51:01 <Jessehk> quicksilver: Ah, looks good. Thanks :)
06:51:28 <cnwdup_> quicksilver: addToQueue :: Queue Signal -> Signal -> IO ()
06:51:30 <SamB_XP> dcoutts: so cabal doesn't provide any info to the "cabal test" hook?
06:51:50 <quicksilver> cnwdup_: right. And you pass it as its second parameter something of type (SignalClass a => a)
06:52:00 <quicksilver> cnwdup_: which is not type "Signal".
06:52:18 <dcoutts_> SamB_XP: runTests :: Args -> Bool -> PackageDescription -> LocalBuildInfo -> IO (),
06:52:22 <quicksilver> perhaps you meant liftIO @ addToQueue q (Signal s) ?
06:52:24 <Zao> Does anyone know if there has been any talk about making cabal-install use the architecture somehow when it generates the ~/.cabal/ paths?
06:52:28 <quicksilver> s/@/$/
06:52:36 <dcoutts_> SamB_XP: so that's quite a bit of info, enough to find all the modules in the package for example
06:52:42 <Zao> Sharing a ${HOME} over multiple architectures is rather bothersome.
06:53:25 <cnwdup_> quicksilver: Thank you! (-:
06:53:47 <dcoutts_> Zao: that'd be pretty easy, we just need to add ${arch} as a path template
06:54:09 <dcoutts_> Zao: file a feature request please
06:54:23 <dcoutts_> Zao: http://hackage.haskell.org/trac/hackage/
06:54:26 <lambdabot> Title: Hackage - Trac
06:55:39 <quicksilver> cnwdup_: are you always going to use the default method?
06:55:47 <quicksilver> cnwdup_: if so, what's the point of it being a method?
06:55:54 <quicksilver> it might as well just be a plain function.
06:56:39 <cnwdup_> quicksilver: I thought it would be good if I can wrap all Signals in a class since each might carry different data.
06:56:51 <quicksilver> that may or may not be good
06:56:57 <quicksilver> I can't say, since I don't know the rest of your code.
06:57:07 <quicksilver> I'm specifically talking about emitSignal
06:57:14 <quicksilver> if the implementation of emitSignal is always the same
06:57:20 <quicksilver> there is no reason for it to be a method.
06:57:36 <cnwdup_> quicksilver: I'll see if I am able to do the same thing with just a function.
06:57:59 <quicksilver> the raison d'etre of a method is to have a separate implementation for each class.
06:58:15 <quicksilver> if your method just has one, default, implementation then it has no business being a method :)
06:58:56 <cnwdup_> But can I use existential types without defining a class SignalClass? My Queue has to be of type Signal which could carry a Int, maybe a String or some other values.
06:59:32 <cnwdup_> Eh, I mean the data structures being members of the SignalClass carry those values.
06:59:44 <quicksilver> well these are separate questions.
06:59:45 <SamB_XP> quicksilver: well, to have a seperate implementation in SOME instances
06:59:53 <quicksilver> SamB_XP: right.
06:59:59 <SamB_XP> also you meant for each instance, not for each class ;-P
07:00:12 <quicksilver> certainly you will find your existential entirely useless if your class has no methods.
07:00:17 <quicksilver> but that's not the point here.
07:00:23 <quicksilver> you could have a class with no methods if you want
07:00:24 <quicksilver> ;)
07:00:40 <quicksilver> the point is that apparantly emitSignal doesn't need to be a method.
07:00:55 <quicksilver> when you come to actually try to *do* something with your Signals
07:01:03 <quicksilver> then I suspect you will find you need over methods.
07:01:42 <quicksilver> I harbour a further suspicion that you don't really need classes or existentials at all :) but I'm not trying to rewrite your entire program.
07:02:32 <cnwdup_> quicksilver: I am going to think about that. Thanks for the hints. (-:
07:03:27 <Zao> dcoutts_: This should be filed against "cabal-install tool", right?
07:03:46 <SamB_XP> Zao: eh? no!
07:03:51 <dcoutts_> Zao: no, the Cabal library
07:04:07 <Zao> Ah.
07:04:24 <Zao> Ignorance is bliss :)
07:04:33 <ejt> cnwdup_: when I first started with haskell I kept trying to use classes when the problem didn't require it, brain damage from an OO background I guess
07:05:02 <SamB_XP> cnwdup_: what did you say you are doing with these things?
07:05:23 <dcoutts_> Zao: thanks!
07:05:40 <cnwdup_> samb_xp: With the signals or with your hints?
07:05:47 <SamB_XP> cnwdup_: the signals
07:06:00 <SamB_XP> that you think requires you to use a class
07:06:12 <Zao> Took me a while to find out that the GHC trac and hackage trac were separate entities.
07:06:39 <quicksilver> rule 1: don't use classes. rule 2: don't use existentials. rule 3: if you do use existentials, don't believe the deceivers who claim you must then use classes.
07:07:02 <quicksilver> I should write a "when not to use classes" essay for the wiki.
07:07:12 <dmwit> data is nice
07:07:23 <vixey> public static class Functor {
07:07:26 <cnwdup_> samb_xp: I want to receive incomming irc messages and then derive signals from it and put it into a queue for being processed. E.g. there would be a Signal Raw containing the raw message. Then a plugin decides to abstract it further emiting a PrivateMessage signal of type PrivateMessage String String String for maybe the channel, nickname and text. And another plugin might catch that signal and emit another signal that someone just sa
07:07:52 <Baughn> cnwdup_: Blackboard-style concurrency?
07:07:56 <cnwdup_> I thought I need a class for that since I want to group a bunch of data structures with abitrary types.
07:08:06 <edwardk> there are at least two category theoretic excuses to use existentials. i'm not sure about most other scenarios though ;)
07:08:29 <dmwit> cnwdup_: data is nice
07:08:48 <SamB_XP> cnwdup_: you can just use an existential with no class for that
07:08:52 <cnwdup_> baughn: I am not really familiar with that term. I want to copy irssi's signal handling for an IRC bot. Don't know if it is good but something I wanna try.
07:08:56 <SamB_XP> afaict...
07:09:12 <vixey> edwardk, hey I saw your HOAS post about expfunctors
07:09:21 <edwardk> cnwdup: that can also be encapsulated in a real function
07:09:29 <mauke> cnwdup_: preflex does something like that
07:09:32 <edwardk> vixey: nice =)
07:09:39 <edwardk> vixey: any thoughts/questions?
07:09:39 <SamB_XP> certainly the class is unneeded
07:09:42 <mauke> it's not completely irssi-style, though
07:09:42 <vixey> yes
07:09:58 <Baughn> cnwdup_: Blackboard-style concurrency, in one sentence: Send function takes no recipient, recipients gather data based on pattern-matching it
07:10:03 <edwardk> cndup: then the thing that you are being existential over can just become the environment captured by the function
07:10:10 <Baughn> cnwdup_: It's oddly simple to use, actually
07:10:20 <vixey> I just wondered.. Why actually define an expfunction, as opposed to writing definitions that deal with the HOAS is pattern matching/equations
07:10:30 <vixey> expfunctor*
07:10:32 <cnwdup_> Ok. I'll drop the class and see where I get with that. (-:
07:10:37 <SamB_XP> if you can't see there ever being more than one implementation of a method, you probably don't need it ;-)
07:10:38 <edwardk> vixey: because I canted a nice generic cata, etc. for them
07:10:58 <edwardk> vixey: and because I was hoping to assemble them a la carte using functor combinators
07:11:04 <trittweil> Is it meanwhile possible to get backtraces from ghci?
07:11:09 <vixey> ah ok
07:11:10 <sander___> What is a smart way to create an enum type datatype instance from a list of strings? The datatype looks like data Line = Line { name :: String, ammount :: String }
07:11:23 <edwardk> vixey: that way i could be sure that later passes of the compiler really did strip out all instances of certain constructors, etc.
07:11:35 <SamB_XP> trittweil: if you use the debugger you can sort-of get a backtrace...
07:12:00 <trittweil> SamB_XP: My program errors out at some point, I'd like to get some context.
07:12:01 <SamB_XP> trittweil: alternatively you can build with profiling, and use +RTS -xc
07:12:15 <edwardk> vixey: you can do pattern match based hoas to a point. you can even flip around the defintioon to get weak hoas, but the result doesn't feel as nice to program with
07:12:23 <SamB_XP> (the more cost centers, the better the traceback will be)
07:12:26 <vixey> that would be great, there's a lot of things I've left out in my code (invisible invariants)
07:12:39 <edwardk> yeah
07:13:53 <SamB_XP> trittweil: do you know how to build with profiling?
07:14:29 <edwardk> i keep trying to work out a way to get a paramorphism in there, but my investigations say it would require me to work with a pair comonad in the category of isomorphisms of Hask, which as near as I can tell doesn't exist cleanly. i'm trying to see if i can get away with only needing a left inverse like fegaras and sheard but i don't know if the rabbit hole goes any deeper. =(
07:15:15 <davep> Hello, I'm looking for some help with Data.Map.   I want to write each element in the Map to a file, but don't want to convert the Map to a list first.  Is it possible to have something like a foldM on a Data.Map?
07:15:35 <trittweil> Saizan: I tried to pass -prof, then run with +RTS -xc --RTS ... but I'm disappointed by the result.
07:15:55 <ejt> davep: what's wrong with converting to a list ?
07:16:11 <davep> It is a very large
07:16:18 <ejt> it will be lazy
07:16:22 <Baughn> davep: Laziness.
07:16:31 <edwardk> anyways regardless of boxes goes bananas or fegaras/sheard or Chlipala's lets-reinvent-weak-hoas-and-call-it-PHOAS representation I can't seem to get a hoas-based typechecker for the calculus of constructions to type check in haskell.
07:16:33 <Baughn> People keep forgetting it
07:16:50 <trittweil> Sorry, my last comment was supposed to go to SamB_XP.
07:17:06 <ejt> davep: I think of lists as control structures (like for loops) in haskell
07:17:07 <Baughn> trittweil: Pass -prof and -auto-all
07:17:07 <edwardk> and i don't really want to cheat and dumb down to a debruijn rep or something
07:17:11 <vixey> lol
07:17:18 <vixey> I've got to read about weak HOAS then
07:17:37 <davep> That makes sense.  thanks
07:17:40 <SamB_XP> trittweil: yeah, clean and rebuild with -prof and -auto-all and probably you'll get better results
07:18:06 <edwardk> data Term v = App (Term v) (Term v) | Lam (v -> Term v) | Var v
07:18:33 <SamB_XP> edwardk: eh?
07:18:34 <edwardk> only 'v' occurs in negative position so it passes the positivity condition imposed by coq and most other total languages
07:18:44 <vixey> yeah
07:19:15 <edwardk> samb: a weak hoas/phoas untyped lambda calculus term system
07:19:33 <SamB_XP> what fails to typecheck in haskell exactly?
07:19:52 <edwardk> samb: iirc the typechecking of pi types you wind up with no place to shoehorn the environment
07:20:34 <edwardk> samb: i welcome a counter example actually =)
07:20:38 <vixey> oh it's the actual dependency bit of dependent types that's causing the trouble?
07:20:46 <edwardk> vixey: go figure ;)
07:20:53 <therp> OT question (category theory): in the category of sets, how could I image an arrow that uses 0 (=the empty set) as source? As arrows are functions in this particular category how would I ever apply such a function, if the source type does not contain any element to apply it to?
07:21:11 <SamB_XP> edwardk: Haskell has pi types now?
07:21:12 <SamB_XP> what?
07:21:24 <vixey> SamB: HOAS ...
07:21:47 <edwardk> samb: no i had a small hoas implementation of a dependently typed language i was trying to put together, it was when i was trying to see if the boxes go bananas encoding was worthwhile
07:22:04 <Baughn> therp: Pretend, and use () instead?
07:22:54 <edwardk> samb: the sandbox supplied by the boxes go bananas mendler-style recursion scheme that limited me to catamorphisms was too smal, so i switched to fegaras/sheard's rep, which also didn't work, and i tried the traditional weak hoas rep, and i also couldn't get that to work. i needed to explicitly manipulate an environment which left me dumbing it down to a non-hoas rep
07:23:00 <therp> Baughn: but when thinking in Haskell conventions () is the member of a set called (), which implies that () has one element, hence it's not empty..
07:23:10 <therp> s/set/type/
07:23:22 <edwardk> which was very disappointing
07:23:46 <Baughn> therp: That does make it harder. There are no types with actually /zero/ members, and I suppose you can't make it a function of no parameters (aka. value), right?
07:24:04 <edwardk> therp: think 'data Void' as being the closest you can get in Haskell to the empty set. unfortunately even that fails because it is inhabited by _|_.
07:24:14 <edwardk> therp: there is no Haskell empty type.
07:24:29 <mauke> Void#
07:24:56 <edwardk> mauke: ?
07:24:59 <SamB_XP> mauke: you're just making it up
07:25:02 <SamB_XP> aren't you?
07:25:13 <mauke> yes :-(
07:25:14 <pejo> edwardk, about reinventing HOAS and calling it PHOAS - are there no other differences?
07:25:27 <edwardk> pejo: not when i last looked at the paper.
07:25:30 <therp> edwardk: yeah, I somehow mentally tried to presume that _|_ is part of any set (even the empty one).. it is kind of strange to assume that but that's the only notion that makes function from an empty type seem possible
07:25:38 <edwardk> pejo: its just a weak hoas rep
07:25:40 <quicksilver> data Void is good enough for many purposes.
07:25:59 <pejo> edwardk, are you talking about the ICFP'08 paper?
07:26:00 <quicksilver> it's as close as haskell will ever get, anyway.
07:26:11 <SamB_XP> at kind *, yes
07:26:23 <therp> quicksilver: but to me it doesn't even make sense mathematically
07:26:43 <SamB_XP> therp: well clearly that doesn't make any sense
07:26:44 <edwardk> therp: here, how about this. i'll give you a function that if you give me an integer that is both negative and positive will give you anything you want. that is an example of a function from the empty set. ;)
07:26:46 <therp> because usually mathematicians don't assume types to a have a bottom element..
07:26:58 <SamB_XP> the empty set just isn't available as a Haskell datatype, is all
07:27:13 <chrisdone> man undefined is useful
07:27:42 <edwardk> therp: there are plenty of such functions. you supply something that can't exist and they can in turn promise you anything.
07:27:51 <quicksilver> mathematicians who are doing semantics of haskell-like langauges are well aware of all types having a bottom element.
07:27:57 <therp> edwardk: so you would give me a function that Nat -> ({} -> Foo)? :)
07:28:08 <SamB_XP> quicksilver: quite so ;-)
07:28:13 <quicksilver> equally, it's often convenient to work in "pure data"
07:28:20 <quicksilver> consider you're in a total fragment of haskell
07:28:26 <quicksilver> in which case Void does indeed have zero members
07:28:33 <quicksilver> (and () has exactly one)
07:28:42 <lilachaze> @hoogle (a,b) -> (b,a)
07:28:44 <lambdabot> No matches, try a more general search
07:28:57 <mauke> :t snd &&& fst
07:28:58 <lambdabot> forall a b. (a, b) -> (b, a)
07:29:09 <edwardk> there is a concept in logic 'ex falso quodlibet' which says if you can prove any one falsehood you can prove all falsehoods.
07:29:21 <chrisdone> what's the difference between “data” and “information”?
07:29:22 <edwardk> 'from falsehood anything you please' basically
07:29:30 <dmwit> chrisdone: data is a keyword
07:30:03 <edwardk> therp: I'd give you a function from :: { n : Nat | n < 0 && n > 0 } -> anything you want. ;)
07:30:22 <therp> edwardk: hm, right but how does that help to understand the initial object in the category of Sets? http://folli.loria.fr/cds/1999/library/pdf/barrwells.pdf - page 18, 3.2.1 claims that {} is the only initial object in Set
07:30:26 <lambdabot> Title: Category Theory Lecture Notes for ESSLLI Michael Barr Department of Mathematics  ...
07:30:53 <therp> sorry for the offtopic chattering.. I presume there is no #categorytheory? :)
07:31:05 <edwardk> therp: correct. because the function from {} to anything else is well defined. no matter what you claim about it you know that it will just sit on its hands and know it will never be able to be called
07:31:31 <edwardk> therp: nah i never got anyone interested in starting such a channel ;)
07:31:43 <edwardk> and they put up with all of my category theoretic chatter in here so you should be fine ;)
07:33:04 <therp> edwardk: ah ok, but isn't that more like "I can proof anything about {} -> X even it's well-definedness as I can proof that there is no proof of the opposite?"
07:33:10 <lilachaze> is "newtype T = C X" equivalent to "data T = C !X" ?
07:33:17 <quicksilver> lilachaze: no.
07:33:22 <quicksilver> lilachaze: but it's pretty close.
07:33:25 <edwardk> remember a function doesn't have to use all of its range. so it just doesn't use any of it.
07:33:45 <lilachaze> quicksilver: ah, right, the bottoms are in different places.
07:33:50 <therp> edwardk: in Haskell notation "f _ = foobar" ?
07:34:12 <dmwit> lilachaze: newtype's can derive any instance that their wrapped type has.  Also, as an implementation detail, newtype constructors exist only in the type-checker; the compiler drops them on the floor completely.
07:34:37 <edwardk> therp: if you think of a function in set as a subset of (domain * range) such that each element in the domain is represented exactly once, then your definition for a function from {} -> Anything is easy. your representation of that function is {}, the empty subset of (domain * range)
07:34:46 <quicksilver> dmwit: not *completely* an implementation detail. Some of that is semantically visible.
07:35:02 <quicksilver> dmwit: namely whether or not case undefined of C _ -> .... is undefined or not.
07:35:03 <dmwit> quicksilver: Even with the strictness annotation he has?
07:35:05 <lilachaze> semantically, the former has a "C _|_" value but no "_|_", whereas the latter has a "_|_" value but no "C _|_" value, right?
07:35:19 <pejo> edwardk, sorry, got caught in other stuff - as for PHOAS, were you talking about the ICFP'08 paper?
07:35:25 <edwardk> therp: that is stronger. in Haskell because you have bottom you can't define a function from {} in a canonical way. because you always have the notion of 'well, what does it map _|_ to?
07:35:30 <edwardk> pejo: yes
07:35:48 * dmwit always has trouble thinking about this
07:35:57 <edwardk> pejo: the main contribution it has is '... in coq'
07:35:58 <edwardk> ;)
07:35:59 <dmwit> quicksilver: Ah! I see.
07:36:17 <quicksilver> for the newtype, case .. of C _ -> ... generates no code at all
07:36:21 <quicksilver> it's completely a no-op
07:36:22 <dmwit> right
07:36:30 <quicksilver> it just relates to type information, erased at compile time
07:36:38 <lilachaze> quicksilver: is my characterization of bottoms above correct?
07:36:44 <quicksilver> for the strict data, it will check the constructor and thus force the inner field.
07:36:45 <therp> edwardk: interesting. this point of view {}: (domain * range) defining f  demonstrate better to me that any predicate I assert over {}, ∀x: P(x) is trivially true as {} is uninhabited
07:36:47 <quicksilver> lilachaze: no.
07:36:50 <quicksilver> lilachaze: all types have _|_
07:36:55 <edwardk> therp: f _ = foobar defines a function in terms of Haskell's omega-CPO with { (_|_, foobar) }
07:37:15 <edwardk> therp: correct
07:37:25 <quicksilver> lilachaze: the former has, in a sense, _|_ and C _|_ but they are *the same*
07:37:28 <therp> edwardk: I get { (_|_, foobar) } but what's 'omega-CPO' ?
07:37:32 <quicksilver> the latter has _|_ but not C _|_
07:37:52 <lilachaze> quicksilver: it seems to me that if "newtype T = C X" has a _|_, then case undefined :: T of C _ -> ... should not be OK, but it is
07:38:02 <edwardk> therp: ok, in haskell you define functions over values right? but you always have that pesky _|_ term floating around.
07:38:34 <pejo> edwardk, hm, he even mentions that PHOAS is weak HOAS in the related work section. On the other hand, there's a contribution in the mechanization too I guess.
07:38:43 <dmwit> lilachaze: Since it's a newtype, the compiler *knows* that C is the only constructor, so it compiles away the case.
07:38:43 <edwardk> therp: the idea is that you want to be able to express the fact that you can't pattern match on _|_. so you say that you only support monotone functions over a lattice where you place _|_ as the least element and everything else one level above it.
07:39:02 <therp> edwardk: ah ok thanks
07:39:05 <edwardk> pejo: the weak hoas connection was something i think a few of us pointed out to him
07:39:33 <lilachaze> dmwit: it's more than an optimization; Haskell98 guarantees it works that way
07:39:46 <therp> edwardk: I have seen that concept already, CPO abbreviates Construction P.. O..?
07:40:31 <edwardk> therp: by working with monotone functions then you can say that i map say in a more interesting example consisting of () and _|_ that if I map  ((),_|_)  then I have to also include (_|_,_|_) by monotonicity, there is nothing else i could map _|_ to.
07:40:43 <edwardk> complete partial order
07:41:21 <therp> edwardk: "nothing else i could map _|_ to" because otherwise the function would violate the monotonicity requirement, right?
07:41:28 <edwardk> therp: exactly
07:41:57 <therp> edwardk: thanks, I greatly appreciate your hints and remarks
07:42:27 <edwardk> now if i had another function from {(),_|_} -> {(),_|_} such that ((),()) was in the representation then I'd be free to map _|_ to () or _|_ as I please, which would indicate whether or not I was strict in my argument.
07:42:27 <therp> it's not that I have a regular saturday afternoon category theory chat club at my local university :/...
07:42:52 <edwardk> therp: no problem. I had to pick this up with just the background noise on this channel as a guide myself ;)
07:43:00 <lilachaze> dmwit: perhaps i'm reading too much into the syntax, but it seems like _|_ does not match the pattern "C _", but C _|_ does, so "newtype T = C X" should have bottom values C _|_ but not _|_.
07:43:41 <lilachaze> dmwit: i was trying "data Void'; newtype Void = Void !Void'" (to create a type with no values), but the compiler said no :)
07:44:00 <therp> lilachaze: you need an extra flag for data Void to be valid
07:44:09 <therp> (at least in GHC)
07:44:32 <PeakerWork> what about a data type that has no data constructors?
07:44:32 <lilachaze> therp: it's the strictness annotation on the newtype it didn't like
07:44:42 <edwardk> the newtype ! trick isn't valid unfortunately
07:44:45 <quicksilver> lilachaze: newtype says that two types are isomoprhim
07:44:56 <quicksilver> lilachaze: (perhaps surprisingly) *including* their _|_
07:44:58 <edwardk> there is nothing it could compile it down to in the back end if you think about it.
07:45:15 <quicksilver> so , e.g., the _|_ of newtype I = I Int is the same as the _|_ of Int.
07:45:19 <edwardk> you'd need to have an oracle for the halting problem for the compiler to know if you could use the type
07:45:27 <quicksilver> that's why I mean when I say _|_ is the same value as I _|_
07:45:46 <lilachaze> quicksilver: a strictness annotation says, "this type without its head _|_s", though, and that overrides the default in data. i don't really see why newtype should be different
07:46:17 <edwardk> lilachaze: the trick comes down to implementation. what does that mean operationally?
07:46:50 <lilachaze> and the penny drops!
07:47:02 <edwardk> lilachaze: i can never write a non-total function that returns such a thing. to typecheck it would require a pervasive change to the language, proof terms, etc.
07:47:12 <quicksilver> lilachaze: I don't know why it should.
07:47:19 <quicksilver> lilachaze: I'm just telling you that it *is*.
07:47:53 <quicksilver> some decisions have been made
07:47:54 <lilachaze> edwardk: thanks, i think i get it! for a function returning such a type to typecheck, the compiler would need to prove it must always terminate.
07:48:00 <quicksilver> they may seem arbitrary.
07:48:03 <edwardk> lilachaze: exactly =)
07:48:09 <quicksilver> certainly I don't know the reasons for them.
07:48:30 <lilachaze> quicksilver: every time i think "this seems like a strange decision", it turns out that there's a really good reason for it :)
07:48:41 <quicksilver> there were discussions about whether a conforming haskell implementation should be allowed to optimise a strict single field data to a newtype.
07:48:49 <quicksilver> the answer was considered to be 'no'
07:48:57 <quicksilver> but there were people arguing both sides.
07:49:20 <edwardk> lilachaze: yeah for almost everything except for the few bits of temporary insanity that happened in Haskell 98 when they removed monad comprehensions and butchered the monad typeclass I agree ;)
07:49:28 <quicksilver> edwardk: which is not that hard really; you could have a total sublanguage.
07:49:39 <quicksilver> and restrict expressions of certain types to that language.
07:49:46 <quicksilver> c.f. Turner's work on total programming.
07:49:51 <olsner> is there some way (for debugging) to trace the polymorphic type of a function? (i.e. a function typeOf :: a -> String or similar which you could apply to the polymorphic argument)
07:50:10 <edwardk> quicksilver: sure, just with haskell's lack of universes to build up a program in it'd be a pretty boring sublanguage =)
07:50:12 <lilachaze> quicksilver: but there's nothing stopping a conforming implementation from laying out a data with a single strict field in memory as it does a newtype, is there?
07:50:15 <mauke> :t typeOf
07:50:16 <lambdabot> forall a. (Typeable a) => a -> TypeRep
07:50:30 <mauke> :t show . typeOf
07:50:31 <lambdabot> forall a. (Typeable a) => a -> String
07:50:32 <quicksilver> lilachaze: no that's right. It's just the subtle difference in 'case' semantics.
07:50:44 <mauke> > show . typeOf $ ()
07:50:45 <lambdabot>  "()"
07:50:50 <mauke> > show . typeOf $ "fiddlesticks"
07:50:51 <lambdabot>  "[Char]"
07:51:05 <quicksilver> edwardk: it would be expressive enough for all total terms of type Void though!
07:51:09 <quicksilver> edwardk: that's not to high a bar :P
07:51:14 <lilachaze> hehe
07:51:16 <edwardk> quicksilver: =)
07:51:24 <olsner> mauke: ooh, nice ... just hope I won't have to derive Typeable for a lot of types
07:51:49 <olsner> @index Typeable
07:51:49 <lambdabot> Data.Typeable, Data.Dynamic, Data.Generics.Basics, Data.Generics
07:51:57 <edwardk> quicksilver: unfortunately though its not a proper sublanguage. you can't use terms from it in the larger whole. it'd be like living outside of a partiality monad.
07:52:20 <quicksilver> well I think turner had some ideas, but I don't remember the details.
07:52:25 <BeelsebobWork> Hmm, is there any sensible way to be able to work on a cabal based library in ghci?
07:52:27 <edwardk> quicksilver: which is the way that you work if you want to build up what we have in something like coq, etc.
07:52:31 <olsner> gaah, typeable doesn't include instances for 10-tuples
07:52:45 <BeelsebobWork> I (quite reasonably) get errors about modules I need being hidden by the package
07:53:23 <olsner> hmm, I'm probably reading that wrong.. ghc says the 10-tuple instance doesn't apply to the 17-tuples being used in the code :D
07:53:46 <edwardk> quicksilver: sure the turner paper is nice and it says a lot of stuff that people have been saying for years in the coq and charity communities, etc. but if you sit down and try to write the language it suggests you get agda ;)
07:53:54 <DRMacIver> Dare I ask why you're using a 17-tuple?
07:53:58 <dcoutts_> BeelsebobWork: ghci doesn't hide anything, so often if you're not using lots of options in the .cabal file you can just use ghci directly
07:54:17 <dcoutts_> BeelsebobWork: if you're relying on Cabal to run pre-processors etc then it's a bit more tricky
07:54:53 <olsner> DRMacIver: it's a parser for a network protocol built for emacs lisp ... don't expect sanity :)
07:54:53 <dcoutts_> @seen dons
07:54:53 <lilachaze> olsner: this might help you: http://groups.google.com/group/fa.haskell/msg/b9602b8aab776f2c
07:54:54 <lambdabot> dons is in #arch-haskell, #xmonad, #ghc and #haskell. I last heard dons speak 8h 44m 19s ago.
07:54:54 <BeelsebobWork> dcoutts_: if I ghci directly I get errors about "Graphics.Formats.Obj.Parse does not exist (is hidden by objParse-0.1)
07:55:00 <lambdabot> Title: Having trouble with zip12.. - fa.haskell | Google Groups
07:55:05 <BeelsebobWork> because it's looking at my installed modules, before the source in the directory
07:55:12 <DRMacIver> olsner: Well, sure, but I really mean "Why are you using a 17-tuple rather than a named type?"
07:56:02 <dcoutts_> BeelsebobWork: hmm, that's odd. ghci looks in the src dirs first before installed packages. If your source is in a subdir then you'd need -isrc or whatever
07:56:13 <BeelsebobWork> hmm, okay
07:56:22 <edwardk> oslner: data MyType { this :: Should, probably :: Be, broken :: Out, into :: Something, sane :: !Yes }
07:56:31 <edwardk> er = MyType
07:56:59 <olsner> probably laziness from the original coders; I should berate them properly next time I see one of them
07:57:07 <edwardk> then you get record sugar for replacing single fields in it, etc.
07:57:33 <olsner> it could also be the amazement of finding an actual use for a 17-tuple that led them to actually use it
07:57:35 <edwardk> and you can extend it by adding more parameters without killing yourself everywhere you mention any part of it
07:58:05 <edwardk> repeat after me: there is no use for a 17 tuple ;)
07:58:26 <edwardk> @type (,,,,,,,,,,,,,,,,)
07:58:30 <lambdabot> forall a b c d e f g h i j k l m n o p q. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q)
07:58:34 <edwardk> ugly ;)
07:59:36 <quicksilver> it is, however, mechanical to derive a Typeable instance for such.
07:59:52 <quicksilver> and I thought GHC would do so automatically
08:00:01 <quicksilver> if not, standalone deriving shoudl do it?
08:00:04 <edwardk> > (,,) "this" 15 "silly"
08:00:06 <lambdabot>  ("this",15,"silly")
08:00:16 <quicksilver> failing that, Data.Derive or DrIFT
08:01:22 <lilachaze> @pl \a b c d e f g h i j k l m n o p q r s t u v w x y z -> (t,h,e, q,u,i,c,k, b,r,o,w,n, f,o,x, j,u,m,p,e,d, o,v,e,r, t,h,e, l,a,z,y, d,o,g)
08:01:26 <lambdabot> (((((((((((((((((const .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((((((flip .) .) .) .) .) .) .) . ((((((((flip .) .) .) .) .) .)
08:01:26 <lambdabot>  .) .) . (((((((((flip .) .) .) .) .) .) .) .) .) . ((((((((((flip .) .) .) .) .) .) .) .) .) .) . (((((((((((flip .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((flip .) .) .) .) .) .) .) .) .) .) .)
08:01:26 <lambdabot>  .) . (((((((((((((flip .) .) .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((((flip .) .) .) .) .) .) .) .) .) .) .) .) .) .) . (((((((((((((((flip .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) . ((((
08:01:26 <lambdabot> ((((((((((((flip .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) . (((((((((((((((((flip .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((((((((flip .) .) .) .) .) .) .) .) .) .) .) .
08:01:28 <lambdabot> ) .) .) .) .) .) .) . (((((((((((((((((((flip .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((((((((((flip .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) . (((((((
08:01:31 <lambdabot> [70 @more lines]
08:01:33 <lambdabot> optimization suspended, use @pl-resume to continue.
08:01:53 <lilachaze> eep!
08:01:55 <edwardk> hrmm i think i'd be kinda funny to run the pattern matching like that: myFun ((,,,,,,,,,,,,,,,,) this is a very long list of variables because my coauthors are crazy) = (,,,,,,,,,,,,,,,,) this is a very long list of variables because my coauthors' are crazy where coauthors = ...
08:02:45 <edwardk> hah
08:02:45 <olsner> can you pattern-match tuples like that?
08:02:46 <edwardk> I have it
08:02:54 <dmwit> no
08:03:06 <edwardk> type MyType = (,,,,,,,,,,,,,,,,)
08:03:09 <edwardk> =)
08:03:14 <lilachaze> rofl
08:03:43 <edwardk> > (\(,) a b -> a + b) (1,2)
08:03:45 <lambdabot>      Constructor `(,)' should have 2 arguments, but has been given 0
08:03:45 <lambdabot>     In t...
08:03:50 <edwardk> =(
08:03:53 <edwardk> sad
08:04:09 <olsner> type This = (,,,,,,,,,,,,,,,); f (This <etc>) = (This <etc>) :D
08:04:12 <edwardk> only works at the type level
08:04:18 <edwardk> olsner: yeah
08:04:26 <dmwit> olsner: This is not a constructor.
08:04:47 <edwardk> unfortunately it won't work for the data constructor though
08:04:49 <olsner> oh, yes, d'oh
08:05:07 <edwardk> In kata i could define a view, in Haskell you're out of luck
08:05:22 <dmwit> data This my coauthors are crazy = This my coauthors are crazy; f (This my coauthors are crazy) = ...
08:05:29 <olsner> in Haskerl, views would be implicit
08:05:32 <lilachaze> fixed it for you: data Tuple a b = Tuple a !b; data Nil = Nil; type MyType a b c d e f g h i j k l m n o p q = Tuple a (Tuple b (Tuple c (Tuple d (Tuple e (Tuple f (Tuple g ... Nil))))...
08:05:32 <dmwit> Even better:
08:05:44 <dmwit> data My coauthors are crazy = My coauthors are crazy
08:06:18 <edwardk> Even better: data I quit = I quit
08:07:39 <edwardk> olsner: they can't be explicitly giving the type of all 17 arguments over and over again can they?
08:09:14 <olsner> nah, it's in a newtype somewhere and goes through type inference the rest of the way, or something like that
08:09:44 <edwardk> type or newtype? if its a newtype you're already halfway there ;)
08:09:48 <hackage> Uploaded to hackage: sphinx 0.0
08:09:56 <edwardk> just kill a ton of spurious (,)'s and make it a data type
08:10:06 <edwardk> a newtyped (,,,,,) is just a data constructor anyways
08:12:06 <olsner> newtype, which reuses the parser instance for 17-tuples rather than implementing the parser explicitly for the new type..
08:13:17 <olsner> @seen hpaste
08:13:18 <lambdabot> I saw hpaste leaving #haskell 2d 17h 51m 51s ago, and .
08:13:25 * edwardk stops grinding the axe ;)
08:13:25 <olsner> http://hpaste.org/8923
08:15:06 <Saizan> what's weird is that there's a Parse instance for 17-tuples
08:15:17 <edwardk> the question is how much stuff directly uses Conference?
08:20:55 <edwardk> http://hpaste.org/8923#a1
08:20:58 <lilachaze> @hoogle Int -> (a -> a) -> a -> a
08:20:59 <lambdabot> No matches, try a more general search
08:21:09 <edwardk> er not newtype data
08:21:26 <quicksilver> :t iterate
08:21:27 <lambdabot> forall a. (a -> a) -> a -> [a]
08:21:36 <quicksilver> lilachaze: surprisingly, there's only iterate.
08:22:00 <quicksilver> you have a choice between foldr (.) + replicate, or iterate + (!!)
08:22:02 <lilachaze> @type (foldl (.) id .) . replicate
08:22:03 <lambdabot> forall a. Int -> (a -> a) -> a -> a
08:22:49 <lilachaze> iterate + (!!) seems less insane :)
08:25:18 <edwardk> heh or you could go temporarily insane and write it as a prepromorphism
08:25:51 <vixey> or a zygohistomorphic prepromorphism!?
08:26:04 <edwardk> meh no need for the zygo or histo ;)
08:26:52 <olsner> just insert the identity zygo- and histomorphism (if there is such a thing) and you'll have something wonderfully obfuscated
08:26:59 <edwardk> yeah
08:27:01 <lilachaze> @hoogle a -> [a] -> Int
08:27:02 <lambdabot> No matches, try a more general search
08:27:22 <vixey> yeah I'm still not even sure what a natural transformation is
08:28:24 <edwardk> vixey: type Nat f g = forall a. f a -> g a
08:28:42 <DRMacIver> It is a thing of darkness and evil, spawned from the depths of category theory.
08:29:15 <vixey> how can it be that simple ..
08:29:19 <vixey> in books they always draw a square
08:29:23 <edwardk> vixey: parametricity there ensures that if you fmap over the values in f or g before or after applying it, you get the same result.
08:29:48 <edwardk> vixey: because fmap can only affect the values contained and the natural transformation can only affect the structure and not the values.
08:29:58 <edwardk> vixey: hence that diagram commutes
08:30:11 <edwardk> vixey: thats what the diagram is trying to say its just doing a terrible job of it
08:30:23 <vixey> mm
08:31:58 <edwardk> So given e :: Nat f g, d :: a -> b then fmap d . e = e . fmap d
08:32:20 <edwardk> they operate at completely different 'levels'
08:32:33 <vixey> that makes perfect sense
08:32:50 <edwardk> vixey: there you go, you now understand natural transformations
08:32:54 <edwardk> no diagrams involved ;)
08:33:02 <edwardk> the diagram is just that fmap d . e = e . fmap d equation
08:33:34 <edwardk> the diagram in cata, ana etc just is a way of expressing another one of those one line equations in a lot of space
08:37:14 <Duddle> hello everybody! quick question about strings: they are lists of chars, aren't they? so I should be able to access the first element of the string with (a:x) just like a normal list
08:37:24 <Baughn> Yes
08:37:25 <edwardk> Duddle: yep
08:37:43 <Baughn> Or head or !!0, of course
08:37:57 <PeakerWork> Hey, I finally understand/use the pl-style of:  f x = g x `infix` h x   (f = liftM2 infix g h). I want a cookie :-)
08:38:04 <Duddle> then what is wrong with something like: foo (a:x) = if a == "m" then
08:38:08 <PeakerWork> (Don't need @pl to know that, that is)
08:38:19 <Duddle> it says the type of "m" is [char]
08:38:21 <mauke> Duddle: "m" is not a Char
08:38:51 <Duddle> because.... I have "" around it? or how can I declare a single char?
08:38:55 <mauke> 'm'
08:39:00 <lilachaze> is there a 'startsWith'-type function in the library somewhere?
08:39:06 <mauke> lilachaze: isPrefixOf
08:39:12 <lilachaze> thankyou :)
08:39:18 <Duddle> oh, nice... thanks :)
08:39:20 <mauke> @hoogle [a] -> [a] -> Bool
08:39:20 <lambdabot> Data.List.isPrefixOf :: Eq a => [a] -> [a] -> Bool
08:39:21 <lambdabot> Data.List.isSuffixOf :: Eq a => [a] -> [a] -> Bool
08:39:21 <lambdabot> Data.List.isInfixOf :: Eq a => [a] -> [a] -> Bool
08:39:28 <olsner> PeakerWork: I'm out of cookies... but do you want a 17-tuple?
08:39:50 <Deewiant> ?ty (,,,,,,,,,,,,,,,,)
08:39:51 <lambdabot> forall a b c d e f g h i j k l m n o p q. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q)
08:39:55 <edwardk> peaker: heh there is a type level version of that in category-extras: newtype Lift p f g x = Lift (f x `p` g x)
08:40:17 <edwardk> i dropped the M and the 2 to avoid scaring the bejeezus out of people though
08:43:46 <gsan> Hello all. About Data.Binary: I read the discussions on haskell-cafe, but still not sure if this has sense: decode (encode (0 / 0)) :: Double == -Infinity. Might this be a problem with my system?
08:44:37 <Baughn> gsan: That's supposed to be NaN, yep
08:44:50 <gsan> So, is there a cure for this? :-)
08:45:11 <Baughn> Sure. Check for NaN and store that differently.
08:45:18 <gsan> Eheh. OK, thanks.
08:45:38 <quicksilver> well perhaps gsan is talking about the built in binary instance for doubles
08:45:41 <quicksilver> in which case, this is a bug.
08:46:23 <gsan> Isn't this a bug either way?
08:47:10 <quicksilver> it's a bug with the library if it's the default instace
08:47:18 <gsan> I'm guessing it's related to fromRational's take on the issue.
08:47:20 <gsan> Yes it is.
08:47:32 <quicksilver> does the double instance go via fromRational?
08:47:37 <quicksilver> that would explain it if so.
08:47:59 <quicksilver> Rationals are not an adequate "all-encompassing type" for Real/Fractional types
08:48:10 <quicksilver> although fromRational/toRational makes it look like they should be.
08:48:13 <gsan> No, it's a NaN before getting encoded
08:48:16 <edwardk> i think they tried to encode it directly in case the platform wasn't ieee, etc.
08:48:21 <quicksilver> since they don't understand the IEEE special values.
08:48:29 <edwardk> http://www.haskell.org/pipermail/haskell-cafe/2008-January/037702.html
08:48:30 <lambdabot> Title: [Haskell-cafe] Data.Binary and serialising doubles in IEEE format, http://tinyurl.com/5pvrj7
08:50:06 <gsan> :-/ Well, it's not a big problem, NaN's need to get treated specially anyway. I'll put the treatment before encoding. :-)
08:50:37 <dcoutts_> @seen dons
08:50:38 <lambdabot> dons is in #arch-haskell, #xmonad, #ghc and #haskell. I last heard dons speak 9h 40m 3s ago.
08:50:45 <dcoutts_> @localtime dons
08:50:47 <lambdabot> Local time for dons is Mon Jul 14 08:50:46 2008
08:54:05 <BMeph> @localtime dcoutts_
08:54:05 <lambdabot> Local time for dcoutts_ is Mon Jul 14 16:54:04
08:54:15 <dcoutts_> @arr!
08:54:15 <lambdabot> I want me grog!
08:54:29 <BMeph> dcoutts_: Good afternoon. :)
08:54:50 <dcoutts_> BMeph: good afternoon indeed :-)
09:00:14 <olsner> @quote \.\.\.
09:00:19 <lambdabot> dons says: [When asked what qualifications Guido van Rossum has...] a chip on his shoulder?
09:00:54 <drguildo> is there any way to prevent ghci crapping out when i have two copies of the same library installed (an old one globally and a newer one in my homedir), without hiding one of them?
09:00:54 <Twey> Hahaha, what?
09:01:06 <drguildo> such as tell it to use the newest one
09:01:18 <drguildo> ghci/ghc
09:02:50 <ct529> does anyone have a good example on transforming comma separated values files into other formats?
09:03:47 <BMeph> drguido: You mean, how do you tell ghc/ghci to "pick one" of the available packages? :)
09:03:49 <Baughn> ct529: concat . intersperse "\t" . splitBy (== ',') -- Well, here's one. Kinda trivial. What exactly where you looking for?
09:03:54 <quicksilver> drguildo: the correct solution is to hide one.
09:04:02 <quicksilver> drguildo: why would you not like that?
09:04:19 <drguildo> BMeph, i think so, yeah. if two or more modules with same name, pick newest one and ignore oldest
09:04:32 <drguildo> quicksilver, because i have to do it manually
09:04:48 <mauke> Baughn: hah, if only
09:05:34 <Baughn> Works fine.. so long as there aren't any commas in the fields. ^^;
09:05:36 <ct529> Baughn: I am an absilute newbie .... they told me haskell is really good for transforming data between different formats, and I was browsing and reading the documentation, but did not find anything.
09:05:54 <drguildo> ct529, who's they?
09:06:08 <quicksilver> drguildo: I think if you use cabal to install, it always hides all but the most recent, doesn't it?
09:06:09 <bd_> data transformation are pure functions after all :3
09:06:16 <Baughn> ct529: It doesn't have a "transform data to the format I want" function, no. That wouldn't be referentially transparent.
09:06:21 <ct529> drguildo: there is a research group who works on haskell at our University
09:06:24 <drguildo> quicksilver, nope
09:06:35 <Baughn> ct529: You'll have to actually learn the language first. ;)
09:06:38 <dcoutts_> quicksilver: it hides all the ones not being used
09:06:39 <DRMacIver> Baughn: It could just live in the Telepathy monad though. :)
09:06:41 <drguildo> quicksilver, althought maybe it would have if i'd ran it as root
09:06:52 <ct529> Baughn: that was not actually my request, as you could easily understand from my question.
09:07:21 <Baughn> ct529: Think you missed my <snark> tag. Anyhow, sure, haskell can transform data pretty easily
09:07:21 <quicksilver> dcoutts_: no, I'm talking about default visibility
09:07:34 <quicksilver> dcoutts_: not visibility whilst using cabal to compile
09:07:53 <Baughn> ct529: Easier than most other languages, I'd say - the exception being perhaps perl in some cases. But it's not a /single/ feature that does that; it's all of them in combination
09:07:57 <dcoutts_> drguildo: if you're using ghci you have to hide one of them, otherwise it complains that two packages provide the same module
09:08:21 <ct529> thanks .... is there a tutorial on data transformation using haskell? I need to do some comparison with perl.
09:08:24 <drguildo> dcoutts_, meh, ok. i was just wondering if there was a way around it.
09:08:27 <dcoutts_> drguildo: if they're the same package name then it's not a problem, ghc just picks the later one
09:09:03 <ct529> we are using perl at the moment, but haskell seems to offer some interesting plus.
09:09:04 <drguildo> dcoutts_, ok, thanks
09:09:18 <dcoutts_> drguildo: and if they're the same version registered in the global and user package db then the user one masks the global one
09:09:23 <sander___> Is there a way to make Read accept 12,2 as a double? (mind the , instead of .)
09:09:53 <dcoutts_> sander___: no, you'd have to munge the input into the right format
09:10:06 <sander___> ok, s/,/. it is :)
09:10:21 <drguildo> is there any way to get cabal to go through all the visible packages and hide all the old versions?
09:10:26 <drguildo> or some other program
09:10:44 <dcoutts_> drguildo: it's not necessary
09:11:05 <drguildo> dcoutts_, but what about ghci
09:11:16 <drguildo> i want to avoid doing it manually
09:11:23 <drguildo> if possible
09:11:29 <dcoutts_> drguildo: same, ghc/ghci just picks the latest version of a package, there's no need to hide anything
09:11:38 <Baughn> ct529: I don't know of any tutorials for that in particular, no. I do know that any /simple/ example would probably end up favoring perl.. hmm..
09:11:48 <dcoutts_> drguildo: perhaps you can explain what problem you're running into
09:11:51 <drguildo> dcoutts_, i'm using 6.8.2 and i'm sure it doesn't
09:12:12 <drguildo> dcoutts_, sec, this calls for a hpaste i think
09:12:26 <Baughn> ct529: http://brage.info/~svein/recyclopedia.hs.txt <-- You could study this. It's not too well written, and obviously a WIP, but it does manage to compress and index a wikipedia database dump in a reasonable amount of time.
09:13:14 <Baughn> ct529: The last third or so of it uses haxml instead of hacky bytestring pattern matching, which is nicer.. and far, far too slow. Oh well.
09:14:34 <Trinithis> is there a class like Monad, but has kind * rather than *->*?
09:14:54 <drguildo> dcoutts_, http://hpaste.org/8924
09:15:20 <therp> edwardk: may I ask another question? when envisioning functions as a restricted form of (domain*range), then a singleton sets is only a terminal objects in the category of Sets, when we require functions to be total. otherwise there would be multiple partial functions pointing to singleton sets differing in their degree of "definedness". is that insight correct?
09:17:25 <dcoutts_> drguildo: I bet your local install of the network package is messed up
09:17:51 <drguildo> dcoutts_, i doubt it, it happens with all modules where there's a global and local version
09:17:51 <dcoutts_> drguildo: my guess is that it's using the network-2.2.0.0 package but the files really are missing
09:18:18 <drguildo> dcoutts_, where should they be?
09:18:19 <dcoutts_> drguildo: well use -v and see if the files it says its looking for really exist
09:18:27 <dcoutts_> or use ghc-pkg describe network
09:18:34 <dcoutts_> and see if the files it lists exist
09:19:08 <dcoutts_> the module's .hi files should be in the dir listed in the 'import-dirs' field
09:19:11 <drguildo> dcoutts_, looks like you're right
09:19:25 <drguildo> i used cabal to install them
09:19:28 <drguildo> i think
09:19:38 <drguildo> actually i can't remember
09:19:41 <drguildo> so ignore that
09:19:46 <dcoutts_> drguildo: solution is to unregister the local version and optionally to re-install the network package locally
09:19:56 <quicksilver> Trinithis: in what way could it be like monad withouth being * -> * ?
09:20:07 <quicksilver> Trinithis: in particular, what type do you envisage "return" having?
09:20:14 <Trinithis> err: in the sense that it has a >> operator
09:20:19 <quicksilver> Monoid
09:20:24 <Trinithis> ty
09:20:45 <drguildo> dcoutts_, does unregister delete the package or will i have to do that after unregistering?
09:21:15 <Trinithis> :t (++)
09:21:17 <lambdabot> forall m. (Monoid m) => m -> m -> m
09:21:19 <dcoutts_> drguildo: registering/unregistering does not affect any other files
09:22:10 <quicksilver> Trinithis: sadly, that's not true :)
09:22:16 <quicksilver> Trinithis: it's called "mappend" in haskell.
09:22:27 <chrisdone> I want to make my word cloud code into a library which I will call gdcloud and later pop it on hackage. should I have it as Graphics.GDCloud or maybe Graphics.GD.Cloud?
09:22:28 <Trinithis> i know. im going to add it to my PreludeExt module
09:22:33 <quicksilver> ah good stuff :)
09:22:39 <vixey> is PreludeExt online ?
09:22:49 <drguildo> dcoutts_, ok, i'll try and hunt them down and try what you suggested. thanks.
09:22:55 <quicksilver> chrisdone: I would be included just to call it Graphics.WordCloud
09:23:02 <Trinithis> vixey: its in the making. its very small right now
09:23:04 <quicksilver> chrisdone: you might later switch backend away from GD, after all.
09:23:17 <pyNem> can anyone link me to a good place for learning io in haskell? I basically want to use it for spoj, and am comfortable with writing functions in haskell. Just input output is lacking.
09:23:23 <vixey> Trinithis: ok please tell me when you get a URL for it :)
09:23:24 <chrisdone> quicksilver: okay
09:23:39 <Trinithis> vixey: sure. perhaps ill work on it some more today
09:23:41 <ct529> Baughn: thanks a lot .... I will read through.
09:23:48 <Trinithis> ill write a note for me to give it to you
09:23:55 <ddarius> dcoutts: We should add tags to hackage and co.
09:24:04 <dcoutts_> ddarius: yep
09:24:39 <scook0> pyNem: perhaps try http://sigfpe.blogspot.com/2007/11/io-monad-for-people-who-simply-dont.html
09:24:45 <lambdabot> Title: A Neighborhood of Infinity: The IO Monad for People who Simply Don't Care, http://tinyurl.com/yplmwx
09:24:54 <pyNem> thanks scook0 looking at it :)
09:25:28 <ct529> Baughn: why do you think it would favour perl? by the way, we also need to implement some statistics on data later, and I think perl is not terribly good with that.
09:25:36 <chrisdone> quicksilver: I was going to have it maybe return a Gd.Image value (as well as ByteString and simply outputting to file) incase someone wanted to modify it further, you know?
09:25:40 <Jedai> pyNem: For spoj though you definitely wants to use ByteString rather than simple String (but don't worry, the API looks the same)
09:25:46 <quicksilver> chrisdone: yes, that's a good idea.
09:25:56 <pyNem> Jedai, ByteString ?
09:26:03 <quicksilver> chrisdone: I'm just saying being dependent on GD isnt necessarily a key part of your code
09:26:10 <quicksilver> chrisdone: it's just the way you happen to have done it now.
09:26:18 <chrisdone> quicksilver: I agree
09:26:24 <quicksilver> so I'm not sure it deserves to be part of your packagane name
09:26:37 <chrisdone> quicksilver: ahh, okay. yes
09:27:03 <Jedai> ct529: Mostly, Perl is better at quick and dirty (the regex are integrated for example, though we should have that in the next GHC (or rather we'll have something that allows you to add it,that's awesome))
09:28:41 <ct529> Jedai: yes, you are right, it is good at that
09:28:45 <Jedai> pyNem: String in Haskell are normally linked list of unicode characters ( that is [Char] ), while that is fine for interactive usage or moderate charge, it never do for intensive IO, so ByteString (which are extremely optimized Array of bytes) are much better in this case
09:28:48 <chrisdone> quicksilver: I'll go with Graphics.WordCloud :)
09:29:06 <pyNem> Jedai, thanks :) .. will read it up ..
09:29:16 <Jedai> pyNem: And if my memory is correct, SPOJ has some intensive IO
09:29:24 <pyNem> Jedai, it does :)
09:32:16 <edwardk> therp: exactly =)
09:32:36 <edwardk> therp: in fact if you grab categories for the working mathetician you'll find exactly that stated when it talks about sets
09:34:50 <ddarius> When one talks about functions in Set theory, one usually means total functions.
09:35:06 <Baughn> ct529: Think algorithmic complexity. Haskell's is lower, but perl has a smaller constant
09:35:06 <wuxia> can  the following snipplets of code be written in  a more concise manner?
09:35:18 <wuxia> applyEach funcs arg = map f funcs where f b = b arg
09:35:18 <wuxia> applyAll funcs arg = foldr f arg funcs where f new old = new old
09:35:23 <olsner> @index liftIO
09:35:27 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
09:35:34 <Baughn> wuxia: Homework, right?
09:35:37 <vixey> :t ($ ?arg)
09:35:38 <wuxia> haskellllll soe
09:35:42 <wuxia> self stujdy
09:35:43 <lambdabot> forall a b. (?arg::a) => (a -> b) -> b
09:35:48 <vixey> wuxia
09:35:48 <wuxia> exercise 9/4, 9/5
09:35:56 <chrisdone> what's this ?arg stuff?
09:36:08 <vixey> f new old = new old --> f = ($)
09:36:12 <chrisdone> :t (?arg ?arg)
09:36:14 <Baughn> chrisdone: An attempt at dynamic variables
09:36:16 <lambdabot> :t -> t1,
09:36:18 <lambdabot>         arising from a use of implicit parameter `?arg'
09:36:18 <lambdabot>                      at <interactive>:1:1-9
09:36:21 <vixey> dynamic .. no
09:36:22 <Baughn> chrisdone: See the GHC manual for details. It's an extension
09:36:41 <Baughn> wuxia: Okay. You do realize that, by the time you see the exercise, you're supposed to already have the knowledge to solve them?
09:36:41 <chrisdone> Baughn: I see
09:36:54 <Baughn> wuxia: If you can't, I suggest you reread the section instead
09:37:34 <wuxia> baughn : why do you assume that I can't solve the exercise? it asked me to define applyYEach and applyAll -- I did that; now i'm trying to figure out is there'a a more idiomatic way to write it; and you're assuming that i'm an idiot, based on what?
09:37:51 <vixey> wuxia: Stop arguing with folk
09:38:00 <vixey> wuxia: Did you see what I wrote for you earlier?
09:38:21 <wuxia> yeah, still trying to parse why  ($) works
09:38:37 <vixey> @src ($)
09:38:39 <lambdabot> f $ x = f x
09:38:52 <vixey> you already know about sections like how (++ x) = (\a -> a ++ x)
09:39:12 <wuxia> 'sections' come in the next section of the book
09:39:31 <wuxia> the ($) is clever;  i never thought of using an infix operator as a prefix one
09:43:56 <wuxia> wow,  currying infix operator is really cool
09:44:07 <vixey> yes
09:47:16 <wuxia> how do i tell lambdabot to unpac k an expression?
09:47:25 <mauke> define "unpack"
09:47:33 <wuxia> expand it out
09:47:38 <mauke> what
09:47:40 <masak> :)
09:47:43 <vixey> it's impossible
09:47:54 <Deewiant> ?unpl f x = (+x)
09:47:54 <lambdabot> f x a = a + x
09:47:58 <Zao> I want to unscramble eggs.
09:48:26 <wuxia> ?unpl [twice twice twice, twice (twice twice)] where twice f = f f
09:48:26 <lambdabot>  Parse error at "where" (column 42)
09:48:45 <Deewiant> ?ty twice f = f f
09:48:47 <lambdabot> parse error on input `='
09:48:53 <Deewiant> ?ty \f -> f f
09:48:55 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
09:48:55 <lambdabot>     Probable cause: `f' is applied to too many arguments
09:48:55 <lambdabot>     In the expression: f f
09:48:58 <Deewiant> doesn't work
09:49:15 <wuxia> > let twice f x = f f x
09:49:15 <lambdabot>  Parse error at end of input
09:49:43 <Deewiant> ?ty let twice f x = f f x in twice
09:49:45 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t2 -> t1
09:49:45 <lambdabot>     Probable cause: `f' is applied to too many arguments
09:49:45 <lambdabot>     In the expression: f f x
09:49:50 <wuxia> ?unpl [twice twice twice, twice (twice twice)] where twice f = f $ f
09:49:51 <lambdabot>  Parse error at "where" (column 42)
09:50:09 <Deewiant> in general lambdabot doesn't understand 'where', use let..in
09:50:20 <ddarius> Deewiant: That's not valid Haskell.
09:50:36 <Deewiant> what's not
09:50:44 <ddarius> expr where f x = x
09:50:46 <quicksilver> lambdabot understands all valid expressions using where.
09:50:56 <Deewiant> it's not an expression, yes. :-)
09:51:29 <Deewiant> > let f x = y where y = x + 1 in f 1
09:51:31 <lambdabot>  2
09:51:34 <Deewiant> wowzers
09:54:05 <nus> ehm, I'm trying to build tar-0.1.1.1 and it says Couldn't match expected type `L.ByteString' against inferred type `bytestring-0.9.0.1:Data.ByteString.Lazy.Internal.ByteString'. Any guesses on what's going on?
09:54:26 <mauke> version mismatch
09:54:55 <nus> mauke, i.e rebuild everything?
09:55:02 <mauke> dunno
09:55:29 <nus> and I've got only one version of bytestring installed.
10:01:08 <tusho> http://hpaste.org/8906 Anyone wanan help me with this? :P
10:01:11 <tusho> *wanna
10:01:32 <mauke> not this stuff again
10:01:47 <Baughn> What would be a good NFData instance for bytestring? Would BS.length do?
10:02:01 <nus> hmm, L.Bytestring is actually a qualification of Data.ByteString.Lazy.Char8
10:02:37 <nus> L, even
10:06:36 <ddarius> Baughn: For lazy bytestrings I'd imagine rnf . chunks would do.
10:06:44 <dons> Baughn: for strict bytestring?
10:06:45 <lambdabot> dons: You have 3 new messages. '/msg lambdabot @messages' to read them.
10:06:48 <dons> NFData x = x
10:07:26 <Baughn> dons: I was just experimenting. Yes, rwhnf works for strict ones, but.. yep, I need lazy ones too
10:07:36 <Baughn> Though I imagine ddarius is right
10:07:48 <vixey> what do rnf and rwhnf stand for?
10:07:56 <Baughn> Reduce (weak head) normal form
10:08:00 <ddarius> +to
10:08:03 <Baughn> *reduce to
10:08:05 <vixey> oh
10:08:59 <wuxia> given  an  arbitrary function defintionnn; what's the algorithm i can use to manually work out the type signature?
10:09:12 <vixey> wuxia: Type inference
10:09:13 <ahunter> Hindley-Milner?
10:09:17 <Baughn> wuxia: Unification?
10:09:19 <dons> Baughn: i'd walk the spine for L.ByteString
10:09:34 <wuxia> which one of these has readable pseudo code?
10:09:40 <Baughn> dons: length.chunks, then?
10:09:56 <vixey> I have readable real code
10:09:58 <dons> i'd probably not use chunks
10:09:59 <Baughn> I'll use rnf anyway. It'll do the same, and works if I have to change the instance later
10:10:01 <dons> use length, sorry
10:10:09 <dons> be efficient, and avoid the int parameter :)
10:10:17 <dons> http://www.infoq.com/news/2008/07/phasers someone should implement this today <--
10:10:19 <ahunter> wuxia: I like http://en.wikipedia.org/wiki/Hindley-Milner#Hindley.E2.80.93Milner_type_inference_algorithm
10:10:21 <lambdabot> Title: InfoQ: New Java Concurrency Feature: Phasers
10:10:21 <lambdabot> http://tinyurl.com/6h4959
10:10:52 <vixey> When is pseudocode better than real code?
10:10:53 <Baughn> wuxia: I have to admit, I prefer just feeding the code to LB
10:11:18 <Baughn> vixey: When the real code has to be mangled to fit the language instead of being just the algorithm you had in mind
10:11:23 <Baughn> Which happens a lot, even in haskell
10:12:02 <wuxia> ahunter: thanks
10:12:09 <dons> vixey: we don't use pseudocode anymore. haskell made it obsolete.
10:12:12 <dons> (seriously)
10:12:19 <vixey> dons: that is my wish
10:12:20 <vixey> :)
10:12:29 <vixey> I am not happy with informal notations
10:12:33 <ahunter> dons: ...getting  a bit hyperbolic, are we?
10:12:46 <dons> haskell is the only psuedocode i use now.
10:12:54 <ahunter> I mean, I don't use a lot of pseudocode with most good HLL, but saying it's obsolete is a bit over the top
10:13:03 <dons> for good reason -- can you think of something at an even higher level of abstraction?
10:13:13 <vixey> I don't think that it has been made obsolete
10:13:22 <dons> well, it has a new notation.
10:13:24 <vixey> but it was always a terrible thing
10:13:39 <shepheb> I write very mathmatical pseudocode for my algos class, but I want Haskell
10:13:39 <geezusfreeek> i sometimes think in terms of psuedo-dependent types
10:13:43 <dons> i still sketch code, of course, but it tends to be haskell syntax.
10:14:01 <shepheb> it has a bigger library. I can't write 'takeWhile' and expect the marker to know what I mean
10:14:29 <dons> yeah, you need to stick to the Prelude.
10:14:33 <dons> and you get to use more math
10:14:36 <vixey> shepheb: what do you write instead then?
10:14:46 <dons> somone should implement Language.Pseudo
10:14:51 <vixey> lol
10:14:54 <geezusfreeek> haha
10:14:55 <chrisdone> I'd prefer people to write in a proper language than something imprecise and vague
10:14:57 <dons> providing all the kinds of things you typically need for pseudocode
10:15:08 <shepheb> vixey: I have to describe what I mean using pseudocode, maybe a look. I basically have to inline takeWhile.
10:15:11 <dons> basically, more symbols, more math in the prelude, sloppy types
10:15:19 <shepheb> s/look/loop/
10:15:20 <vixey> shepheb: I see
10:15:22 <dons> and lots of kinds of undefined
10:15:48 <vixey>  Language.Pseudo could be every monad in one stack
10:16:54 <vixey> I think that wiki article is pretty much rubbish
10:17:27 <pejo> dons, is the array fusion new stuff on top of the ICFP paper you had last year?
10:17:34 <pejo> (Is it already published?)
10:17:38 <wuxia> whoa
10:17:41 <wuxia> papers are written about yhasikell?
10:17:48 <wuxia> is it possible to do a thesis in this topic?
10:17:52 <tusho> yhasikell?
10:17:56 <vixey> wuxia: What is yhasikell?
10:18:03 <tusho> vixey: a typo for haskell
10:18:06 <wuxia> it is haskell typed on a kinesis ergo keyboard
10:18:36 <tusho> "It's ergonomic and unusable!"
10:18:37 <pejo> wuxia, I just jumped in the middle with a question I really had yesterday, it wasn't related in any way to the current discussion. Sorry.
10:18:48 <vixey> wuxia: There are papers about implementing most interesting languages
10:19:31 <dons> pejo: it has further progressed.
10:19:33 <wuxia> pejo: no no, i think this is relaly cool, please go on, i'm the one interrupting; i'd love to hear this discussion
10:19:40 <dons> uvector has the same as the paper, vector has some new stuff
10:19:51 <dons> so 'uvector' should be considered the stable branch
10:20:49 <wuxia> fix f = f (fix f) -- working this out manually, I get (a -> b) -> a ... ghci gives me: (a -> a) -> a ... can someone enlighten me?
10:21:15 <Deewiant> ?ty fix
10:21:16 <lambdabot> forall a. (a -> a) -> a
10:21:17 <vixey> wuxia, start by annotating the whole thing with variable types
10:21:32 <vixey> (fix::a) (f::b) = (f::c) ((fix::d) (f::e))
10:21:47 <vixey> now you traverse the expression
10:21:55 <mauke> a = d, b = c = e
10:22:09 <vixey> when you have an application...  f x, you know that f is a type a -> b, and x is a type a, and (f x) is a type b
10:22:40 <vixey> so you walk down the expression, constraining the types in this way
10:23:09 <mauke> wuxia: how do you get a -> b for f?
10:23:12 <vixey> once you've do this, since it's a recursive function.. you must unify the type of fix with the infered type of the use of fix in the  body
10:23:43 <mauke> wuxia: the body is a call to f, so f x must have the same type as fix f
10:25:16 <pejo> wuxia, there's plenty of research around Haskell. The Haskell Symposium (http://haskell.org/haskell-symposium/) has atleast the table of contents of the proceedings available for free online, you can browse those to get an idea what research is being done. Most authors keep a copy of the papers they publish on their homepages.
10:25:16 <lambdabot> Title: The Haskell Symposium
10:25:33 <wuxia> mauke: ah, that's what i was missing; thanks
10:25:48 <dons> the haskell.org 'research papers'  link has most papers going back 20 years.
10:26:49 <ahunter> dons/pejo: the new vector library--someone said it's based off the ndp/dph stuff, right?
10:27:05 <ahunter> anyone happen to know if there's an ETA for dph working?
10:27:28 <pejo> dons, nice to hear that it has progressed. Can you still be as involved or have you had to cut back due to work?
10:27:41 <dons> ahunter: vector and uvector are subsets of the data parallel arrays library
10:27:51 <dons> pejo: not so much on the research, no.
10:27:59 <dons> ahunter: well, much of it is working now.
10:28:26 <jpcooper> hello
10:29:25 <jpcooper> I don't know the correct term for this, but I remember that there's an option for say being able to do data Ray a b ...
10:29:29 <jpcooper> is this standard to haskell?
10:29:58 <dons> hmm?
10:30:02 <dons> an algebraic data type?
10:30:57 <jpcooper> no
10:31:14 <Armored_Azrael> Give a more full example then?
10:31:20 <dons> well, data Ray a b is fine. we need to know what's in the ...
10:31:21 <jpcooper> data Ray a b = Ray {point :: Vector a, vector :: Vector b}
10:31:27 <dons> everything so far is valid haskell98
10:31:34 <dons> looks good to me.
10:31:37 <Armored_Azrael> Ah, that's called a record type, and is standard
10:32:04 <jpcooper> aah. so that's possible
10:32:28 <dons> you wrote exactly the valid code.
10:35:09 <olsner> long ghc compile time is long...
10:35:28 <olsner> and I only wanted to upgrade gtk2hs
10:37:13 <tusho> :\
10:38:07 <jpcooper> sadd :: Num a => Vector a -> Vector a -> Vector a
10:38:08 <jpcooper> sadd (Vector x y z) (Vector a b c) = Vector (x + a) (y + b) (z + c)
10:38:19 <jpcooper> say I have vectors of type Int, Double and Float
10:38:22 <jpcooper> will it work for that?
10:38:38 <mauke> TIAS
10:38:54 <jpcooper> when called with one of each
10:39:07 <jpcooper> tias?
10:39:17 <sander___> hmm Text.Regex.Posix doesn't support [1-9]\{2,5\} notation?
10:39:32 <jpcooper> try it and see, of course
10:39:49 <sander___> got a lexical error on the 2
10:39:54 <sander___> so guess not
10:40:04 <jpcooper> mauke, why does it work?
10:40:56 <jansz> @pl foldr (\ c r  -> c:' ':r) []
10:40:57 <lambdabot> foldr ((. (' ' :)) . (:)) []
10:41:21 <jpcooper> surely a means one instance of Num
10:42:17 <sjanssen> jpcooper: it won't work
10:42:51 <jpcooper> sjanssen, strange, it works when I call it with Vector 1 2 3 and Vector 1.2 2.3 2.4
10:42:53 <fons> hi all
10:43:01 <dons> sander___: i bet it does.
10:43:09 <sjanssen> jpcooper: 1 :: Num a => a
10:43:09 <dons> if that's a posix regex..
10:43:17 <sjanssen> > 1 :: Double
10:43:20 <lambdabot>  1.0
10:43:25 <sander___> dons: according to http://en.wikipedia.org/wiki/Regular_expression#POSIX_Basic_Regular_Expressions it is :)
10:43:26 <lambdabot> Title: Regular expression - Wikipedia, the free encyclopedia, http://tinyurl.com/dfdb8
10:43:30 <sander___> ehm
10:43:30 <jpcooper> sjanssen, yes, it is
10:43:38 <sander___> checks regex for typos :) :)
10:43:47 <fons> does anybody have an idea about why gshow and gread (from Data.Generics.Text) require extra parenthesis?
10:44:07 <fons> (in the case of show, it generates enclosing parenthesis)
10:44:19 <sjanssen> jpcooper: so both vectors are actualy Vector Double, thanks to numeric defaulting
10:44:30 <jpcooper> right
10:44:35 <jpcooper> so actually it shouldn't work?
10:45:09 <sjanssen> sadd can not be applied to Vector Double and Vector Int
10:45:23 <sjanssen> but your example applies Vector Double and Vector Double
10:45:32 <jpcooper> okay
10:45:59 <jpcooper> but actually I should do (Num a, Num b) => Vector a -> Vector b -> Vector c?
10:46:35 <sjanssen> jpcooper: try sadd (Vector 1 2 3 :: Vector Int) (Vector 1 2 3 :: Vector Double) -- for an example
10:46:41 <sander___> hm regex seems typo free
10:46:53 <sjanssen> jpcooper: it isn't exactly easy to add two different numeric types
10:47:05 <dons> http://www.reddit.com/info/6rpse/comments/
10:47:06 <lambdabot> Title: reddit.com: Building a small search engine with Haskell: stemming
10:47:23 <jpcooper> okay
10:47:44 <jpcooper> so I should keep it the way it is?
10:48:01 <zachk> how do i use an ioref to get incremented values on every call
10:48:09 <sjanssen> jpcooper: yeah, that's what I would do
10:48:20 <jpcooper> okay
10:48:27 <jpcooper> thank you
10:48:28 <sjanssen> jpcooper: if necessary, you can other functions to convert Vectors between different numeric types
10:48:52 <jpcooper> how should I do that?
10:50:24 <sjanssen> integralToNum :: (Integral a, Num b) :: Vector a -> Vector b; integralToNum (V x y z) = V (fromIntegral x) (fronIntegral y) (fromIntegral z)
10:51:14 <jpcooper> okay
10:51:16 <sjanssen> to go the other way, from floating to integral, you'd have to choose how to round the fractional parts
10:51:40 <pejo> When cabalizing libraries you follow the module structure for directories. Where do you put the example programs that link to these libraries?
10:51:40 <jpcooper> or I could only take Double vectors?
10:53:48 <therp> edwardk: thanks!
11:00:48 <zachk> holycrap gmp is fast
11:01:25 <augustss> yes
11:02:23 <dons> "   There's something I want to do with Haskell, and after tinkering for a
11:02:24 <dons>    while I think it's not possible."
11:02:37 <dons> now that's an invitation if ever I saw one..
11:03:14 <glguy> Someone knows you too well, dons.
11:03:40 <cjb> it's a new way of asking homework questions :)
11:04:06 <zachk> or getting your research done by someone else
11:04:11 * glguy wants all of the tickets on his bug tracker fixed, but thinks that might not be possible in Haskell...
11:04:11 <taruti> ... whether P/=NP :)
11:04:13 <therp> "reverse psychology does not work"
11:04:18 <cjb> "Ah, I see that it's not possible to write mergesort in Haskell.  It's a shame, I was interested in using Haskell but now I'm going to switch to ocaml."
11:04:19 <glguy> if only there was someone to do them and show me...
11:04:20 <dons> glguy: let's see then!!
11:04:22 <cjb> <five minutes pass>
11:04:34 <cjb> "What are you talking about?  <code>"
11:05:02 <olsner> @faq Can haskell fix all my bugs? In the type system?
11:05:02 <lambdabot> The answer is: Yes! Haskell can do that.
11:05:27 <dons> see. simple.
11:05:42 <olsner> :)
11:05:59 <Codex_> I've always wanted to know how to do co-routines with haskell :)
11:06:35 <glguy> > unfoldr Just (1,1)
11:06:36 <lambdabot>  [1,
11:06:56 <Baughn> @type unfodlr
11:06:57 <lambdabot> Not in scope: `unfodlr'
11:06:58 <Baughn> @type unfoldr
11:06:59 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
11:07:28 <sjanssen> glguy: see, Haskell can even segfault!
11:07:44 <glguy> sjanssen: Its the new adaptive type-system
11:07:55 <Baughn> @faq Can haskell be used to launch nuclear weapons?
11:07:56 <lambdabot> The answer is: Yes! Haskell can do that.
11:08:48 <dons> glguy: we prefer "dynamic"
11:08:56 <dons> also "agile"
11:08:59 <glguy> unsound?
11:09:04 <dons> the type system is 17% more agile now.
11:09:12 <mauke> what the hell
11:09:28 <olsner> Codex_: after playing around with yield in python, I'm thinking lazy evaluation replaces many uses of co-routines
11:09:29 <mauke> how is unfoldr Just valid?
11:09:48 <olsner> I guess a continuation monad would take care of the rest of them
11:09:49 <sjanssen> mauke: the type checker is busted
11:10:14 <glguy> mauke: Imagine a world where too many unnecessary extensions have introduced bugs into the type-checker
11:10:23 <mauke> ;_;
11:10:31 <Baughn> @type unfoldr Just (1,1)
11:10:32 <lambdabot> forall a. (Num a) => [a]
11:10:49 <Baughn> @type unfoldr Just
11:10:50 <lambdabot> forall a b. (a, b) -> [a]
11:11:33 <mauke> bug url?
11:11:38 <Baughn> ..bus error?
11:11:41 <sjanssen> http://hackage.haskell.org/trac/ghc/ticket/2414
11:11:46 <lambdabot> Title: #2414 (GHCi / GHC segfault : type checker problem) - GHC - Trac
11:11:47 <Igloo> It's fixed in the HEAD
11:12:00 <mauke> thanks
11:12:42 <quicksilver> SPJ blames boxy types
11:12:47 <quicksilver> and yet the bug is in 6.6
11:12:53 <quicksilver> I thought 6.6 was pre boxy?
11:13:00 <glguy> "Also GHC 6.4.3 is fine. "
11:13:16 <glguy> Oh, 6.6 was bad though
11:14:05 <Baughn> Boxy types? Does that mean rank-n types?
11:14:43 <quicksilver> I thought it mean impredicative types
11:15:16 <Baughn> "Boxy types generalize bidirectional inference, and also allow impredicative types (type variables may be instantiated to polytypes, and polytypes may occurs as arguments of type constructors)" <-- I have no idea what this means
11:15:54 <dolio> The answer is, yes, it has to do with rank-n types.
11:16:02 <dolio> :)
11:16:06 <mauke> runST $ do
11:16:32 * olsner wonders how much of the channel had their brains 'sploded by that quote :)
11:17:04 <glguy> bos: Do you know if GHC 6.8.3 is still expected to make it into F9? (I saw that the F10 rpm was able to build successfully)
11:17:09 <Baughn> So.. a polytype is any type that isn't a monotype (haskell'98 type, that is)?
11:17:15 <quicksilver> Baughn: Maybe (forall a. a -> b)
11:17:25 <quicksilver> polytypes embedded inside data types
11:17:34 <quicksilver> inside parametric data types, even.
11:17:46 <quicksilver> instantiating general type variables to a higher order type.
11:17:48 <Baughn> quicksilver: Ah. There we go. Now I at least have the delusion that I understand it a bit.
11:17:50 <quicksilver> and so on recursively, of course.
11:17:59 <Baughn> I'll read the papers instead. ;)
11:22:53 <Twey> olsner: *raises hand*
11:23:07 <dolio> Bidirectional inference is (I think) where you do inference in conjunction with user-specified annotations.
11:23:33 <dolio> Which is necessary for rank-n types, since inference for those is undecidable in general.
11:23:54 <dolio> (And GHC won't even attempt to infer rank-n types on its own.)
11:25:56 <Baughn> dolio: So 6.4 ghc didn't support type annotations? o_O
11:26:15 <dolio> It probably used a different algorithm.
11:26:32 <Baughn> Or, wait.. "generalize", not allow
11:28:22 <Trinithis> what's the difference between TMVar and MVar?
11:28:36 <sjanssen> Trinithis: TMVar is used in STM, MVar is used in IO
11:28:45 <Trinithis> ok
11:28:57 <sjanssen> MVar also has some additional guarantees, like FIFO
11:29:46 <Baughn> FIFO? That's..
11:29:56 <Trinithis> first in first out
11:29:59 <Baughn> Oh, knowing that would have been useful. ^_^
11:30:09 <Trinithis> if i have the option, i shoud use MVar ?
11:31:02 <sjanssen> Trinithis: you'd only use TMVar if you're using STM
11:31:12 <Trinithis> k
11:31:30 <sjanssen> or if you need transactional features, like polling on multiple variables simultaneously
11:31:58 <quicksilver> as a guideline I generally think you need STM if you imagine needing 'retry'
11:32:07 <quicksilver> that is, the ability to rollback a transaction and try again
11:32:44 <quicksilver> MVars are simpler.
11:34:35 <Trinithis> hoogle says swapMVar can create a race. Does modifyMVar have that same issue?
11:35:26 <sjanssen> Trinithis: yes
11:35:26 <quicksilver> modifyMVar is race free.
11:35:30 <quicksilver> ?
11:35:54 <Trinithis> chaos!
11:35:56 <sjanssen> quicksilver: not according to my reading
11:36:21 <quicksilver> oh, I see.
11:36:30 <quicksilver> Trinithis: only a race if the program is written by an idiot.
11:36:41 <Trinithis> lol
11:36:42 <mauke> what's the race?
11:36:44 <quicksilver> when you are using MVars in take/put discipline, then you always use them thus.
11:36:47 <lament> A program written by an idiot, full of sound of fury, signifying nothing.
11:37:00 <sjanssen> mauke: another thread putMVaring in between the reading and the writing
11:37:02 <quicksilver> and if you always use take/put discipline, you can't have races.
11:37:50 <mauke> let's see if I'm affected
11:37:51 <sjanssen> modifyTMVar will not have this race condition
11:38:00 <quicksilver> if you wished to tidy up the details you might layer a newtype on top to guard against it.
11:38:10 <sjanssen> mauke: it is probably difficult to observe
11:38:11 <quicksilver> but I must admit I find sticking to MVar disciplines not a big problem.
11:38:24 <quicksilver> normally you either use take/put throughout
11:38:30 <quicksilver> which is "safe shared variable"
11:38:45 <quicksilver> or you use put/take which is "1-location channel"
11:38:47 <taruti> readMVar having non-obvious semantics is a pity
11:39:09 <quicksilver> well, readMVar is under the take/put assumption.
11:39:11 <mauke> I use it in select
11:39:11 <sjanssen> yeah, readMVar has a race condition too
11:40:02 <mauke> so if a bunch of threads use modifyMVar at the same time, I should be safe?
11:40:20 <sjanssen> yes
11:40:23 <taruti> yes.
11:40:34 <mauke> phew
11:40:34 <Trinithis> cool
11:41:03 <taruti> but if you mix in e.g. tryPutMVar things will get more complex.
11:41:40 <mauke> newMVar -> { modifyMVar_ } -> takeMVar
11:41:48 <quicksilver> yes, I guess the documentation could be more explict here.
11:41:53 <Trinithis> what about mixing in tryTakeMVar? i have one function that does that. and then it puts in a value
11:41:54 <Baughn> @ty modifyMVar
11:41:55 <lambdabot> Not in scope: `modifyMVar'
11:42:05 <Baughn> @ty Control.Concurrent.MVar.modifyMVar
11:42:06 <lambdabot> forall a b. GHC.IOBase.MVar a -> (a -> IO (a, b)) -> IO b
11:42:15 <quicksilver> modify, read and swap are all race-free under a global take/put assumptin.
11:42:29 <quicksilver> tryPut is more likely to be useful in a put/take assumption.
11:43:08 <quicksilver> Trinithis: tryTake is safe; it just adds a "initial segment" to you take/put discpline during which the mvar might be empty.
11:43:09 * Baughn notes that, yep, modifyMVar has a race condition against putMVar
11:43:33 <quicksilver> Baughn: yes, as I said: modify/swap/read are all to be used with a take/put setup.
11:43:34 <taruti> Trinithis: think about the following execution trace, 1) modifyMVar takes the value, 2) (try)Put fills the mvar, 3) modifyMVar blocks because the var is already full.
11:43:35 <Trinithis> quicksilver: ok. anyway, i just realized that it's the only function that will touch that var anyway
11:44:26 <Baughn> quicksilver: Aye, though it would be beneficial if the documentation noted this
11:45:43 <Baughn> quicksilver: This is odd, though; the race condition takes /exactly/ 21ms to trigger, every time
11:45:53 <quicksilver> heh.
11:46:06 <quicksilver> that'll be because the default context switch granularity is 20 ms
11:46:13 <Baughn> Ah
11:46:23 <quicksilver> -RTS -C0
11:46:28 <quicksilver> should make it almost instant
11:46:33 <quicksilver> if I have my rts params right
11:46:55 <Baughn> Hm. No, it takes 21ms regardless of -C setting
11:46:57 <quicksilver> Baughn: yes, some docs about common safe MVar patterns would be nice.
11:47:00 <Baughn> That might just be the smallest amount of time os x can measure
11:48:46 <quicksilver> I imagine the haskell conc. developers were so familiar with the literature on race-free concurrency
11:48:56 <quicksilver> that it was 'obvious' to them the safe ways to use MVars
11:49:02 <quicksilver> and they forgot to doc it :)
11:49:23 <quicksilver> MVars are notable for having simple smenatics and yet subsuming several different concurrency primitives.
11:49:23 <dons> there was what, 10 years of MVars in the Id language before appearing in concurrent Haskell.
11:49:31 <dons> so yeah, it was probably obvious
11:49:37 <dons> or was it Ph.
11:49:55 <quicksilver> dons: where they value-carrying mvars? or all MVar () ?
11:50:02 <Baughn> Yeah, I was assuming all operations were atomic except where otherwise noted
11:50:06 * dons hunts
11:50:14 <Baughn> Fortunately I haven't actually relied on modifyMVar /being/ atomic, but that's just luck
11:50:19 <quicksilver> things isomorphic to MVar () are common in the literature. things isomorphic to MVar a less so.
11:50:22 <dons> yesh, in Id
11:50:25 * quicksilver nods
11:50:33 <dons> Id's M-structures.
11:50:51 <dons> http://citeseer.ist.psu.edu/nikhil91id.html
11:50:54 <lambdabot> Title: ID Language Reference Manual Version 90.1 - Nikhil (ResearchIndex)
11:50:59 <dons> http://citeseer.ist.psu.edu/barth91mstructures.html
11:51:00 <lambdabot> Title: M-Structures: Extending a Parallel, Non-strict, Functional Language with State - ...
11:51:32 <dons> MVars made shared state concurrency easy.
11:54:48 <chrisdone> argh I can't build haddock
11:55:03 <quicksilver> Yes. Shared state easy and also simple 1-place blocking buffers
11:55:07 <quicksilver> are the main things I use them for.
11:55:26 <quicksilver> of course you can build unbounded non-blocking channels, but fortunately someone else has done the hard work there :P
11:55:30 <chrisdone> @seen hpaste
11:55:30 <lambdabot> I saw hpaste leaving #haskell 2d 21h 34m 4s ago, and .
11:55:37 <chrisdone> mmkay
11:55:53 <quicksilver> you can still use hpaste
11:55:57 <quicksilver> you'll just have to paste the link manually
11:56:03 <Baughn> The only thing I'm missing are bounded channels. Sure, they're simple, but.. *shrug*
11:56:25 <quicksilver> bounded with blocking or bounded with error?
11:56:30 <quicksilver> I suppose both are useful.
11:56:37 <chrisdone> I had this error building lambdabot but ignored it because well, it was lambdabot, but now I can't build haddock: http://hpaste.org/8925 I have no idea how to fix this problem
11:56:40 <quicksilver> sometimes even perhaps bounded with discarding.
11:57:10 <Baughn> In my case bounded with blocking, but you have a point. I could parametrize that, write it up properly, and upload to hackage
11:57:18 <Baughn> Unless someone else already wrote it..?
11:58:54 <quicksilver> I don't think so.
11:59:04 <quicksilver> It appears to be an exercise in chap 26 of RWH
11:59:09 <Baughn> It would be a very /tiny/ library, yes
12:00:36 <Saizan> btw, isEmptyChan blocks if there's another thread waiting in a readChan
12:00:43 <Baughn> Almost not worth the bother of downloading.. now here's an idea: Would it be reasonable to have a ghc --make variant that invokes cabal-install as appropriate?
12:01:05 <dcoutts> Baughn: no, but the other way round makes sense
12:01:53 <dcoutts> Baughn: ie the 'cabal' tool should take on the task of ghc --make (like the old hmake did). We're running a GSoC project to do just that. (hia Saizan!)
12:02:01 <Saizan> you mean compile a non-cabalized project and have cabal download the dependencies?
12:02:02 <Baughn> dcoutts: You're sure? It would be kinda nice to have a global haddock site somewhere with all the packages from hackage, be able to add a module to your program, and have it Just Work
12:02:46 <Baughn> More or less. ghc --make has a nice set of defaults; cabal has a nice way of picking your own settings, but they /should/ be the same thing
12:02:50 <Saizan> the hard thing is mapping modules to packages
12:03:09 <Baughn> Most of the module names are unique, aren'T they?
12:03:11 <dcoutts> Baughn: ah, so like Saizan says, discovering the deps of a bunch of modules and then working out which hackage packages provide those modules.
12:03:14 <Baughn> And hackage already knows what modules there are
12:03:27 <chrisdone> >_<
12:04:04 <Baughn> dcoutts: I should put this another way. Who's running hackageDB?
12:04:11 <Saizan> chrisdone: were you able to install other packages?
12:04:28 <dcoutts> Baughn: we should certainly be able to use 'cabal' without writing a .cabal file for simple projects, and pick packages that provide the necessary modules (like ghc --make does)
12:04:48 <dcoutts> Baughn: the cabal team is responsible for hackagedb
12:06:40 <Baughn> dcoutts: Thanks. Let's see if I can't figure something out...
12:06:42 * Baughn goes poof
12:07:20 <dcoutts> Baughn: so you want to implement a ModuleName -> [PackageId] lookup
12:07:28 <Saizan> the information we need (if we assume non-unique module names are enough rare) it's in the index cabal-install downloads from hackage
12:07:32 <dcoutts> all the packages that expose that module
12:07:43 <Baughn> basically. Hoping it's usually "one"
12:07:52 <dcoutts> right, it'll usually be one
12:08:17 <Baughn> I wanted to ask for permission first because, well, I'll have to download the entirety of hackage to figure it out
12:08:17 <dcoutts> Baughn: as Saizan says, it's in the index and you can use the cabal-install code to load the index and do queries
12:08:27 <dcoutts> Baughn: no, you just need the index
12:08:27 <Baughn> Though not just yet. I guess I can write the program with just a few examples. ;)
12:08:37 <Baughn> dcoutts: So there is an index?
12:08:49 <dcoutts> yes, it's what cabal-install downloads
12:09:32 <dcoutts> so PackageIndex AvailablePackage -> ModuleName -> [PackageId] would be easy to implement
12:09:45 <Baughn> Oh hey. Yes, I see
12:09:47 <dcoutts> though without a cache it'll be O(n)
12:10:14 <Baughn> The index should probably be stored as an sqlite db anyway, don't you think?
12:10:37 <dcoutts> better would be to write a conversion PackageIndex AvailablePackage -> Map ModuleName [PackageId]
12:10:50 <dcoutts> that'd be O(n) and subsequently give O(log n) lookups
12:11:12 <dcoutts> Baughn: no, I think that adds needless complexity and dependencies
12:11:46 <dcoutts> Baughn: if you were doing a lot of ad-hoc queries then it might make sense, but not something to include in cabal-install
12:12:02 <Baughn> dcoutts: An O(lg n) in-memory structure is fine, but how often do you install multiple packages in one run?
12:12:35 <Baughn> Well, it doesn't need to be done now. Not enough packages for it to matter yet
12:12:49 <dcoutts> Baughn: in your use case you'd be scanning N .hs modules and doing lookups for all the imports
12:13:20 <Baughn> Point
12:14:08 <quicksilver> dons: who's doing the RWH conc chapter?
12:23:05 <zachk> >: t log
12:23:17 <zachk> @type log
12:23:18 <lambdabot> forall a. (Floating a) => a -> a
12:23:29 <zachk> > log 10 20
12:23:31 <lambdabot>   add an instance declaration for (Floating (t -> a))
12:23:43 <zachk> what did i do wrong and how do i fix it
12:24:04 <zachk> > log 81.0 9.0
12:24:06 <lambdabot>   add an instance declaration for (Floating (t -> a))
12:24:22 <zachk> whats "casting" between types called in haskell?
12:25:09 <zachk> oops i want logBase
12:25:09 <mapreduce> @hoogle unsafeCoerce
12:25:10 <lambdabot> Unsafe.Coerce.unsafeCoerce :: a -> b
12:25:39 <zachk> >logBase 2 20000
12:25:58 <quicksilver> conversion, generally
12:26:01 <zachk> @type logBase
12:26:02 <lambdabot> forall a. (Floating a) => a -> a -> a
12:26:05 <quicksilver> the two you normally need are fromIntegral and realToFrac
12:26:08 <zachk> is calling it casting the wrong thing?
12:26:12 <quicksilver> > logBase 2 200
12:26:12 <lambdabot>  7.643856189774724
12:26:18 <bd_> :t realToFrac
12:26:19 <lambdabot> forall a b. (Fractional b, Real a) => a -> b
12:26:32 <quicksilver> people will probably know what you mean. casting covers a multitude of sins.
12:26:37 <quicksilver> even C++ split it into 4.
12:26:49 <zachk> split what into 4?
12:27:17 <chrisdone> Saizan: what do you mean by able to install other packages? I've just ran cabal upgrade and installed lots of new packages successfully, so I am able to install other packages
12:27:17 <quicksilver> the concept of 'cast'
12:27:20 <mauke> static_cast, const_cast, dynamic_cast
12:27:21 <bd_> static_cast, dynamic_cast, reinterpret_cast, const_cast :)
12:27:30 <bd_> and of course the old C cast
12:27:45 <bd_> which does the right thing /most/ of the time
12:27:46 <mauke> bitwise_cast (hi, memcpy)
12:28:11 <bd_> string_cast (sprintf->sscanf) ? :)
12:28:23 <mauke> that's called lexical_cast
12:28:26 <bd_> heh
12:28:27 <mauke> and uses stringstreams
12:28:42 <bd_> oh, hah, boost actually has it
12:29:19 <Saizan> chrisdone: it was just to see if your ghc installation was working fine
12:29:39 <chrisdone> Saizan: oh
12:30:22 <chrisdone> I just rebuilt and installed containers but it didn't help
12:31:00 <Saizan> ah, so the problem is that you've updated containers while the ghc-api was built against an earlier version, i bet
12:31:27 <Saizan> but i thought cabal warned against that
12:32:26 <chrisdone> are you saying I should build ghc?
12:32:48 <Saizan> no
12:35:00 <Saizan> chrisdone: so, you've two versions of containers installed? you can see it with ghc-pkg list containers
12:35:21 <chrisdone> I'll see
12:36:02 <chrisdone> it lists two, one “/usr/local/lib/ghc-6.8.2/package.conf” and one “/home/chris/.ghc/i386-linux-6.8.2/package.conf”, both the same version “containers-0.1.0.1”
12:36:33 <chrisdone> so the one in ~/ is cabal's and the other came with ghc?
12:36:53 <Saizan> yes
12:37:10 <chrisdone> should I remove one or select a default one or?
12:37:49 <Saizan> i'd try ghc-pkg --user unregister containers, to remove the second
12:38:23 <Saizan> not sure if that will fix the problem
12:38:36 <chrisdone> okay, I have done that. I'll try to build haddock again
12:39:53 <chrisdone> hmm, the same linker error occurs
12:40:16 <chrisdone> /usr/local/lib/ghc-6.8.2/libHSghc.a(RtClosureInspect.o): In function `ghczm6zi8zi2_RtClosureInspect_a73_info': (.text+0xee1e): undefined reference to `containerszm0zi1zi0zi1_DataziSequence_a26_info'
12:42:14 <chrisdone> maybe I should try unregistering ghc's and use the --user one?
12:51:00 <chrisdone> okay
12:57:18 <olsner> hmm, in the cabal file, can you only enter a single author in the Author field?
12:58:33 <pejo> olsner, that works fine for me.
13:00:26 <olsner> hmm, seems I have to wait for gtk2hs to finish installing
13:05:07 <olsner> "One author should be enough for any haskell library"?
13:06:34 <_zenon_> olsner, Who said that?
13:07:19 <olsner> _zenon_: no-one, that was just the meaning I seemed to extract from pejos statement
13:07:45 <_zenon_> olsner, oh.
13:09:37 <pejo> olsner, doh! I interpreted your question backwards. Sorry!
13:10:12 <olsner> hmm, which language extension is this? data Bitstring :: * -> * where Bitstring :: [Bool] -> Bitstring l
13:10:45 <olsner> pejo: oh, so you're saying "multiple authors works fine for me"? :D btw, I tried it now, and it did indeed seem to work, so never mind my question :)
13:11:42 <mauke> GADT
13:12:40 <edwardk> olsner: GADT syntax gives the data ... where and the * -> * is a kind annotation (also technically an extension)
13:13:09 <olsner> LANGUAGE GADTs doesn't seem to enable it - gives a syntax error for the '*'
13:13:28 <edwardk> olsner: that is a kind annotation, a separate extension
13:13:54 <olsner> ah, KindSignatures seems to be it
13:16:38 <_zenon_> olsner, I think it would be
13:16:50 <olsner> maybe just using -fglasgow-exts wasn't such a bad idea after all ... a three-line language clause just screams "ugly dirty type system hacks" like nothing else
13:16:54 <_zenon_> > reverse "One author should be enough for any haskell library"
13:16:57 <lambdabot>  "yrarbil lleksah yna rof hguone eb dluohs rohtua enO"
13:17:11 <edwardk> alas, it looks like my proposal to do a session on comonads/comonad transformers for DEFUN got rejected =(
13:17:32 <edwardk> olsner: heh
13:19:34 <dons> edwardk: we just had too many applications in the end, unfortunately.
13:19:46 <_zenon_> ?ty fix
13:19:51 <edwardk> dons: i understand completely
13:19:52 <lambdabot> forall a. (a -> a) -> a
13:19:56 <BMeph> dons: Too many?
13:20:08 <edwardk> dons: it simplifies my life a great deal anyways, now i don't have to figure out how to get out there ;)
13:20:11 <dons> yes, we got about twice as many applications as we expected.
13:20:31 <dons> so the corresponding acceptance rate is about 40% or so.
13:20:37 <edwardk> *nods*
13:20:38 <dons> which is pretty tight.
13:20:55 * BMeph ponders writing a paper on lambda-powered strange attractors...
13:21:19 * BMeph thinks it'd be a better start to read one first, though
13:21:50 <nus> BMeph, sounds unattractingly strange (-;
13:22:27 <BMeph> nus: Pshaw, more like unstrangely attractive... ;)
13:22:34 <olsner> BMeph: if there's already a paper to read about it, shouldn't that eliminate the need for your paper?
13:22:53 <olsner> or maybe I'm underestimating the width of the field of lambda-powered strange attractors
13:22:58 <olsner> :)
13:23:02 <dons> http://blog.inquirylabs.com/2008/07/14/haskell-is-popular-on-irc/ nice.
13:23:03 <lambdabot> Title: Haskell is Popular on IRC
13:23:44 <dogbite> i'm getting a read no parse exception.  what's the best way to investigate it.
13:23:49 <dogbite> is it possible to trap at that point and like
13:23:55 <dogbite> print out what it was trying to 'read'
13:23:56 <dogbite> ?
13:24:03 <dons> use a readMaybe function
13:24:12 <dogbite> dons: okay
13:24:30 <mauke> is there a readMaybe in the libraries?
13:24:42 <dogbite> mauke: i'm not seeing one immediately
13:24:52 <mauke> because I've always used reads
13:25:15 <olsner> ooh, I believe I've just cabalized my first package :) (not really *mine* yet, by the limited volume of my contributions)
13:25:17 <dons> http://www.haskell.org/pipermail/libraries/2008-February/009202.html
13:25:18 <lambdabot> Title: Proposal: Add Text.Read.maybeRead :: Read a => String -> Maybe a, http://tinyurl.com/5ru8su
13:25:55 <olsner> hmm, shouldn't that rather be readM :: (Monad m, Read a) => String -> m a?
13:26:20 <mauke> no
13:26:30 <dons> http://www.reddit.com/info/6rqnw/comments/ :)
13:26:31 <lambdabot> Title: reddit.com: The Haskell community "reminds me of the Ruby community a few years  ...
13:26:39 <olsner> no? :(
13:26:45 <dons> no!
13:26:54 <mauke> not just no, but HELL NO
13:26:55 <dons> fail in a monad is as a bad as error
13:27:27 <dons> ?users
13:27:28 <lambdabot> Maximum users seen in #haskell: 473, currently: 442 (93.4%), active: 15 (3.4%)
13:27:51 <olsner> hmm, so MonadZero or MonadError or something similar is the class it should be in?
13:28:13 <mauke> what's wrong with Maybe?
13:28:32 <olsner> hmm, otoh, maybe nothing is wrong with Maybe after all
13:28:39 <edwardk> leaning on fail is an admission of failure ;)
13:28:45 <edwardk> MonadZero ok. ;)
13:28:49 <Quadrescence> Can a function take an integer parameter n and use that to perform the function n times (I am actually asking if there is a practical way)?
13:29:21 <Quadrescence> inb4 haskell noob :D
13:29:21 <edwardk> or MonadPlus in that case so you can get more than one answer
13:29:23 <Zao> Quadrescence: Apply the function to what?
13:29:36 <edwardk> @type iterate
13:29:36 <lambdabot> forall a. (a -> a) -> a -> [a]
13:29:44 <edwardk> > iterate (+1) 0
13:29:46 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
13:29:59 <edwardk> @type (!!)
13:29:59 <lambdabot> forall a. [a] -> Int -> a
13:30:00 <Zao> If you're talking about repeating an IO action, sequence.replicate n $ f  ought to do it.
13:30:37 <olsner> I'm thinking it would sometimes be useful to be able to extract a parse failure message from the failed Read, which you would get from e.g. readM str :: Either String a
13:30:37 <mauke> replicateM
13:30:44 <Quadrescence> Zao: Apply it to a datatype consisting of two tuples containing lists. D:
13:31:42 <Saizan> olsner: but the "parser monad" of the Read class doesn't have error messages
13:31:48 <edwardk> > let repeat 0 f = id; repeat n f = f . repeat (n - 1) f in repeat 3 (*2) 1
13:31:49 <lambdabot>  8
13:32:24 <olsner> Saizan: yeah, I realized that the Read parser doesn't have that ... so there would be no more information in it than what's in a Maybe
13:33:11 <Quadrescence> edwardk, et al.: Thanks. :D
13:34:00 <dogbite> i'm sorry for being dense... but what's the best way of
13:34:02 <olsner> one of these days I'll start writing my Haskerl compiler where everything is a view anyway
13:34:08 <dogbite> printing somethin gout in the error part of maybeRead
13:34:19 <dons> dogbite: trace ?
13:34:23 <mauke> error
13:34:26 <dons> you want to side effect an error message?
13:34:32 <dons> mauke: but if he's erroring, why not just use read?
13:34:41 <mauke> > read "wat" :: Int
13:34:42 <lambdabot>  Exception: Prelude.read: no parse
13:34:45 <dogbite> no i can barf.  i don't know trace or error
13:34:52 <mauke> because that tells you nothing about why it failed
13:35:09 <dons> dogbite: so you want to log an error?
13:35:20 <dons> or just case-analyse the result, and print something?
13:35:30 <dogbite> dogs: yeah i'd like to log an error
13:35:37 <mauke> > (\s -> case reads s of [(n, "")] -> n :: Int; _ -> error $ "read failed: " ++ s) "wat"
13:35:38 <dons> case readMaybe of .. Nothing -> hPutStrLn stderr "yo, bad"
13:35:38 <lambdabot>  Exception: read failed: wat
13:35:40 <dogbite> dons: or print it in some way
13:35:55 <dogbite> thanks
13:37:02 <dogbite> dons: okay that's a great help.
13:38:55 <zachk> is there anything on wikipedia that program examples have to be in a certain computer language?
13:39:21 <dons> zachk: i thought there was a rule all pseudocode had to be either math or Haskell?
13:39:28 <dons> isn't that one of the wiki policiesd?
13:39:44 <zachk> hehe
13:40:17 <lament> actually, it has to be both math and haskell at the same time.
13:40:52 <zachk> i know one guy from college, i gave him a bignum problem and he used Excel
13:41:35 <lament> did he solve it?
13:42:24 <zachk> actually no, the problem had no solution, i was off one digit, and the problem he gave me had no factors, so our size of manhood contest ended in there is no solution to either of our given problems
13:42:50 <schme> You need bignum to measure your manhood?
13:42:58 <schme> wow!
13:43:20 <zachk> factorial(xy)=yx.... where x and y are single digits, i had it reversed
13:45:55 <olsner> ooh, this is nice, a couple of the files turned out not to use a single glasgow-exts feature so didn't need any language pragmas at all
13:46:23 <edwardk> schme: depends on the units
13:46:34 <schme> edwardk: well meters, obviously ;)
13:46:48 <edwardk> schme: once you get past a certain scale ;)
13:46:52 <olsner> and the old makefile needlessly passed -fglasgow-exts to the options for every file
13:52:02 <dons> this is interesting, http://merd.sourceforge.net/pixel/language-study/various/is-a-cow-an-animal/
13:52:04 <lambdabot> Title: Is A Cow An Animal? ++, http://tinyurl.com/59dbqz
13:52:10 <dons> edwardk: want to increase haskell's score?
13:53:00 <dons> oh, that's pre-type families. i wonder if we can do better now than 8/11
13:53:11 <dogbite> if trace isn't printing something -- but it's pretty clear that it's being called
13:53:31 <dogbite> is there a trick like having to turn debug on?
13:53:34 <dons> then it's no being called.. you could try compiling with -fhpc and looking at the code coverage
13:53:38 <dons> to see exactly what is being executed.
13:54:08 <edwardk> hrmm you could get 11/11 with Clean i think
13:54:35 <edwardk> its the previously eaten stuff not being detected that cause the last 3 no?
13:54:45 <dons> i think so.
13:55:05 <dons> i'd imagine there's a way to solve that though.
13:55:38 <edwardk> i can't figure out how to say it unless you use some sort of weird 'add everything to an environment and check for no duplication in it'
13:57:12 <Igloo> But in Haskell everything is immutable, so you're allowed to eat something twice!
13:57:20 <Igloo> The bug is in the spec!
13:58:49 <gwern> the program is not wrong - you're wrong!
13:59:07 <Igloo> Clean has uniqueness types, right?
13:59:18 <olsner> ... but the type system is always right!
13:59:52 <edwardk> igloo: yeah
14:00:04 <edwardk> hence the fact that they should be able to peg the list
14:00:25 <Igloo> So I think it boils down to, can you simulate uniqueness types in Haskell's^WGHC's type system?
14:00:37 <edwardk> my current answer to that is no.
14:01:20 <zachk> whats the generic version of !! for integrals
14:01:29 <Igloo> genericIndex
14:01:37 <BMeph> edwardk, dons: I find it amusing that the "pure functional" OCaml program got the best score.
14:01:46 <zachk> ty: Igloo
14:01:54 <BMeph> s/pure/purely/
14:02:33 <edwardk> bmeph: something is missing in the haskell example somehow then
14:02:49 <BMeph> Haskell: Where the names of functions almost write themselves... :)
14:03:13 <Igloo> The OCaml description says "but doesn't ensure previous elements are not used"
14:03:21 <edwardk> looks likely to be a_human.eat(a_beef) -- beaf already eaten, a_cow.eat(grass) -- the cow is already dead, and a_cow.slaughter() -- you can't slaughter something twice
14:03:39 <edwardk> then how the !@&#( do they get 10/11 at compile time? i cry foul ;)
14:04:22 * BMeph re-reads the problem spec
14:04:36 <BMeph> No, no fowl, just cows and rabbits... ;)
14:04:47 <edwardk> oh
14:04:49 <edwardk> they cheat
14:05:04 <edwardk> they use namespacing to protect the old cow
14:05:07 <edwardk> we could do the same thing
14:05:09 <edwardk> lame
14:05:16 <edwardk> do cow <- slaughter cow
14:05:17 <BMeph> "If at first you don't succeed,...cheat!"
14:05:28 <Igloo> Ah, yes
14:05:57 <Igloo> That's against the spirit, as you could write a program that should be rejected but isn't
14:05:59 <glguy> edwardk: is cow shadowing there? or is mdo intended?
14:06:06 <edwardk> shadowing
14:06:07 <glguy> I think the mdo case is more interesting!
14:06:09 <glguy> :(
14:06:09 <glguy> oh
14:06:18 <edwardk> igloo: exactly
14:06:26 <dons> mdo is underappreciated.
14:06:43 <edwardk> i'm this close to making mdo the default do in kata actually ;)
14:06:50 <edwardk> it just has a fairly complicated desugaring
14:10:01 <hackage> Uploaded to hackage: sphinx 0.1
14:10:11 <dolio> Yeah, that isn't preventing things from being slaughtered/eaten twice.
14:10:22 <dolio> Lame.
14:10:54 <mauke> who runs hackage the bot?
14:11:10 <glguy> dons?
14:11:45 <mauke> could we make it announce in ctcp actions?
14:11:51 <dons> glguy!
14:11:54 <mauke> as in "* hackage upload: sphinx-0.1"
14:12:01 <dons> mauke: we could. all is possible
14:12:36 <olsner> I might soon have something to upload to hackage btw :) just gotta get the patches back into the upstream darcs repository and figure out what license it's going to be under (as well as add the proper license headers and license file)
14:14:13 <olsner> but now, sleep
14:15:06 <therp> is the "Functional programming with bananas lenses and bared wire" famous because of the content or because of the awful type setting?
14:15:37 <dons> the content. and the stunning type setting.
14:16:10 * therp feels stunned
14:16:22 <dons> i want to get some squiggol on a tshirt.
14:16:35 <pejo> therp, what is wrong with the type setting?
14:17:12 <dons> computermodern yay
14:17:52 <dons> ok. that's it. i'm definitely getting some banasas/lenses tshirts printed for the HW this year
14:18:02 <dons> hylo, cata, ana symbols
14:18:10 <therp> pejo: there is nothing wrong with cata(..,..) or maybe a neat Greek symbol for cata. but in no case, I would choose strange overlaying of (| and |)
14:18:24 <dons> lenses and bananas!
14:18:26 <therp> pejo: also the symbol for "bared wire" is barely readable.
14:18:40 <edwardk> dons: actually i have a chart for one that shapr keeps threatening to make into a physical shirt
14:18:47 <dons> hehe :)
14:19:04 <dons> edwardk: i'd love to have the category-extras species layed out nicely for a poster
14:19:28 <therp> also they use a strange small-caps symbol that looks wrong (but that's just an aesthetic font choice).. the (| |) |( )| is wrong by concept to me.
14:19:29 <edwardk> dons: its basically the charts for cata, ana, para, apo, etc.. through g-hylo with a what part of .... don't you understand? printed around it.
14:19:35 <dons> hehe
14:20:26 <Quadrescence> Could someone be more descriptive?: parse error on input `='
14:20:31 <cjs> Man, we came up with the ultimate team name for the contest.
14:20:56 <jpcooper> @hoogle Int -> a -> [a]
14:20:58 <lambdabot> Prelude.replicate :: Int -> a -> [a]
14:20:58 <lambdabot> Data.List.replicate :: Int -> a -> [a]
14:21:02 <mauke> Quadrescence: what?
14:21:19 <Quadrescence> mauke: GHC gave me that. :<
14:21:33 <mauke> what code?
14:21:48 <Quadrescence> let repeat :: Int -> a -> a
14:21:49 <Quadrescence> 	repeat 0 = id
14:21:49 <Quadrescence> 	repeat n = f.repeat (n - 1)
14:22:03 <mauke> why is there a 'let' in there?
14:22:12 <Quadrescence> I saw it in someone's source D:
14:22:24 <mauke> and why are the other lines indented?
14:22:29 <cjs> "Cargo cult programming."
14:23:21 <Quadrescence> Before that, I have main = do
14:23:31 <Quadrescence> So I indent things after that. D: Is that incorrect?
14:23:47 <mauke> oh, so this is a local definition?
14:24:00 <Quadrescence> Yeah.
14:24:21 <Quadrescence> Well, I don't even need main = do, probably.
14:24:37 <mauke> ?
14:25:44 <Quadrescence> mauke: I am just learning, so I don't recognize errors easily, whether they be syntactic or stylistic.
14:26:01 <mauke> paste your program somewhere so I can fix it
14:26:13 <Quadrescence> Okay.
14:28:40 <Quadrescence> mauke: http://hpaste.org/8926
14:30:29 <mauke> Face is undefined
14:30:53 <Quadrescence> omg D:
14:31:07 <Quadrescence> Change Move to Face
14:31:14 <Quadrescence> (on 18)
14:31:33 <mauke> http://rafb.net/p/rnRkbh77.html
14:31:33 <lambdabot> Title: Nopaste - No description
14:31:35 <mauke> compiles, at least
14:33:27 <Quadrescence> Is there a sort of "debug" command? You guys may have just talked about this earlier. Something that just prints something the console and can be placed anywhere in the code
14:34:23 <zachk> you dont need a debugger, just use the type system
14:34:24 <Zao> @type Debug.Trace.trace
14:34:27 <lambdabot> forall a. String -> a -> a
14:34:27 <zachk> or that
14:36:41 <cjs> Quadrescence: Replace "foo" with (trace ("foo: " ++ show foo) foo), or your particularly liked variation thereof.
14:37:34 <Quadrescence> Thanks. :)
14:47:28 <Quadrescence> I am really beginning to like Haskell.
14:47:37 <lament> the beginning of the end
14:47:49 <Quadrescence> :D
14:49:35 <dcoutts_> @tell olsner the author field is free form, you can enter multiple authors, most people use ',' to separate them
14:49:35 <lambdabot> Consider it noted.
14:53:40 <leoncamel> hey. folks. is there any tools which can automatically download package and resolve the dependency and install it ?
14:53:54 <leoncamel> I mean something like apt or emerge in Gentoo ..
14:54:03 <chrisdone> cabal
14:54:35 <leoncamel> chrisdone: can you tell me about it ?
14:54:58 <dcoutts_> the package is called cabal-install and it provides a command line tool 'cabal'
14:55:00 <chrisdone> leoncamel: cabal is a package handling program, if you install cabal-install, it can be used as apt-get
14:55:17 <dcoutts_> eg: $ cabal install xmonad
14:56:43 <leoncamel> ok. I have to install cabal by hand in my Ubuntu box ?
14:57:19 <dcoutts_> yes, it also has two deps, zlib and HTTP packages, all three can be got from hackage.haskell.org
14:57:39 <leoncamel> dcoutts_: you mean the cabal-install package ?
14:59:39 <DRMacIver> What are the "expose" functions in the stream fusion library for?
15:00:08 <stepcut> what is a good name for a filter than always returns true. For example: const True
15:00:08 <dcoutts_> leoncamel: yes, zlib and HTTP and cabal-install are all available on hackage.
15:00:09 <DRMacIver> (Well, I guess there's only one expose function, just defined as part of a class)
15:00:18 <ddarius> stepcut: const True
15:00:27 <leoncamel> dcoutts_: ok. thanks. working on it .
15:01:17 <dcoutts_> stepcut: I agree with ddarius, it's a pretty short name and says exactly what it does.
15:02:11 <DRMacIver> Controversially, how about calling it "true". :)
15:02:44 <stepcut> ddarius: well, In this case my filter has the type, (Response -> IO Response), and it performs validation on the Response. If validation suceeds it returns the original Response. If it fails it returns a different Response which contains the error. What I want is a name for the validator which always succeeds...
15:03:16 <stepcut> and I had the feeling that there was perhaps already a turn to describe the idea of always succeeding
15:03:30 <stepcut> s/turn/term/
15:03:31 <ddarius> stepcut: return
15:03:42 <DRMacIver> (I don't seriously suggest that in the absence of a more general suggestion which would imply it)
15:04:10 <stepcut> ddarius: hrm...
15:05:42 <ddarius> stepcut: Admittedly it doesn't read as well, but return is associated with success.  (>>) is conjunction, mplus disjunction, mzero failure.
15:05:53 <stepcut> yes
15:06:25 <stepcut> unfortunately, I don't think it will make the intent of the function obvious from just the name
15:06:34 <stepcut> but, it is a correct answer ;)
15:08:00 <stepcut> originally I had, nullValidate. But that makes it sound like it will just throw everything away.
15:08:34 <stepcut> anyValidate would be closer... like anyChar in Parsec or anyRequest in HAppS-Server (which is where this function is going)
15:08:56 <stepcut> succeedValidate
15:09:02 <ddarius> So anyRequest = return and call it a day.
15:09:17 <stepcut> anyValidate r = (toResponse r) { rsValidate = Just return }
15:10:04 <stepcut> good enough, lemmih can change it if he doesn't like it ;)
15:10:04 <hackage> Uploaded to hackage: sphinx-cli 0.1
15:10:04 <hackage> Uploaded to hackage: sphinx 0.1.1
15:10:19 <omg911>  /quit
15:10:22 <chrisdone> oo
15:10:39 <ddarius> stepcut: Why not anyResponse?
15:11:05 <stepcut> ddarius: well, there is already wdgValidate
15:11:40 <stepcut> though, I could change that since the patch for that has not been submitted yet
15:11:41 <ddarius> I have no clue what wdgValidate does, so perhaps that function's name needs changing.
15:12:22 <stepcut> it runs wdg validate ;)
15:12:35 <ddarius> What is wdg validate?
15:13:08 <stepcut> one of many validators for html and xhtml
15:13:34 <ddarius> What does a typical usage of one of these functions look like?
15:13:57 <stepcut> simpleHTTP nullConf [ anyRequest $ ok =<< wdgValidate =<< execTemplate \"Index.hs\" ]
15:14:00 <leoncamel> dcoutts_: how can I remove a package ? I want reinstall it with *global*
15:14:31 <dcoutts_> leoncamel: ghc-pkg --user unregister $pkgname
15:14:50 <dcoutts_> leoncamel: though that does not delete any files
15:15:23 <stepcut> ddarius: would you prefer, wdgHTMLValidate ?
15:15:54 <leoncamel> dcoutts_: thanks. how can I re-install it into global ? cabal xmonad --global ?
15:16:28 <dcoutts_> leoncamel: right, though that'd have to be as root or with sudo
15:16:50 <dcoutts_> leoncamel: there's not really much advantage to installing globally, I wouldn't bother
15:16:52 <ddarius> stepcut: I'd probably make a HOF so I could write runValidator wdgValidator foo, runValidator trivialValidator foo
15:17:26 <stepcut> ddarius: yes, I was just thinking of that, and then got confused by some code
15:17:48 <ddarius> stepcut: If you are making an analogy to anyRequest/anyChar those are anyNoun while anyValidate is anyVerb
15:18:04 <stepcut> hrm
15:18:30 <ddarius> Perhaps validateAll validateWDG ?
15:19:17 <Quadrescence> Can functions be defined in functions (for local use inside the function)?
15:19:17 <stepcut> validateAll seems a bit ambigious, as does it mean, 'accept all' or 'run all the validators'
15:19:34 <chrisdone> Quadrescence: yes, use let or where
15:19:39 <ddarius> The more natural reading is the former.
15:19:45 <leoncamel> dcoutts_: because I manually install some package into global, I would like upgrade them .
15:19:47 <chrisdone> > let add1 = (+1) in add1 2
15:19:50 <lambdabot>  3
15:19:54 <Quadrescence> chrisdone: gracias :}
15:19:54 <ddarius> Only strange programmer butchering of English would lead one to think the latter.
15:20:27 <stepcut> how would you specific run all of them then ?
15:20:36 <stepcut> validateEvery ?
15:20:38 <dcoutts_> leoncamel: no need, just install the newer versions and leave the existing versions installed
15:21:25 <ddarius> validateUsingAll perhaps though I'd probably use some way of combining a list of validators and write combineValidators allValidators
15:21:34 <stepcut> maybe, skipValidation, would be better, since that is the intended effect
15:21:46 <dcoutts_> leoncamel: you can have multiple versions of a package installed simultaneously and the default is to use the highest installed version
15:22:14 <leoncamel> dcoutts_: great, that is my question .. thanks. ..
15:22:41 <ddarius> stepcut: That's reasonable enough except that it is inconsistent with wdgValidate.  Perhaps rename the latter to wdgValidation?
15:22:44 <stepcut> hrm, actually that is not the case either. Because sometimes you might use this validator in the middle of a pipeline
15:23:20 <stepcut> (re: skipValidation)
15:24:57 <stepcut> original I picked wdgValidate, because the executable is named validate, but that is not critical
15:25:20 <stepcut> anyway, looking at the code, I think it should be more like:
15:25:34 <stepcut> simpleHTTP nullConf [ anyRequest $ ok =<< setValidator wdgValidate =<< execTemplate \"Index.hs\" ]
15:26:02 <stepcut> because it does not actually run the validator there, it just sets the preferred validator
15:26:32 <ddarius> stepcut: Okay that seems reasonable, but then wdgValidate should be wdgValidator.
15:27:33 <ddarius> simpleHTTP nullConf [ anyRequest $ withValidator wdgValidator (execTemplate "Index.hs") >>= ok ] maybe?
15:27:57 <stepcut> ddarius: yeah, because if someone wants to use 'tidy' instead then it would be either, tidy or tidyValidator. And the latter gives more information about what is going on
15:30:37 <stepcut> setValidator matches the naming of the existing code better
15:31:21 <lispy> > map chr [1..255]
15:31:21 <stepcut> in some cases set* and with* would do different things, not sure if that is the case here.
15:31:22 <lambdabot>  "\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\SYN\ET...
15:33:21 <lispy> > map chr (drop 32 [1..255])
15:33:22 <lambdabot>  "!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghi...
15:33:58 <lispy> > '!' < '#'
15:33:59 <lambdabot>  True
15:34:47 <lispy> > 'A' < 'a' -- I've always thought this was an interesting consquence of the lexical ording
15:34:47 <lambdabot>  True
15:38:43 <mjrosenb> lispy: that depends on the locale
15:44:52 <wuxia> @src draw
15:44:53 <lambdabot> Source not found. Take a stress pill and think things over.
15:45:06 <Baughn> lambdabot: It had to be /some/ order, so why not that one?
15:45:09 <wuxia> @src Graphics.SOE.draw
15:45:10 <lambdabot> Source not found. Where did you learn to type?
15:47:34 <schme> @src lambdabot
15:47:34 <lambdabot> Source not found. You untyped fool!
15:48:46 <patchwork> Oooo... Untyped, burn.
15:49:22 <schme> :(
15:50:05 <schme> @src bananas
15:50:05 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
15:50:15 <schme> @src what-next?
15:50:15 <lambdabot> Source not found. Are you on drugs?
15:50:20 <schme> @src drugs
15:50:20 <lambdabot> Source not found. You untyped fool!
15:50:29 <Baughn> schme: It's working its way up to deleting you. Stop while you still can!
15:50:58 <schme> my gosh! Thanks for saving me, Baughn :)
15:51:36 <ddarius> @version
15:51:36 <lambdabot> lambdabot 4.1
15:51:36 <lambdabot> darcs get http://code.haskell.org/lambdabot
15:52:06 <Baughn> An even 4.1? THat's unusual.. or else they changed the code
15:53:08 <wuxia> @src Graphics.SOE.Region
15:53:09 <lambdabot> Source not found. :(
15:54:38 <Quadrescence> > [0,0::10]
15:54:38 <lambdabot>  Parse error at "10]" (column 7)
15:54:44 <Quadrescence> ewps
15:54:47 <Quadrescence> > [0,0..10]
15:54:48 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
15:54:52 <Baughn> "10" is not a type. -_-
15:54:52 <Quadrescence> Aww. :(
15:55:04 <Baughn> Quadrescence: Don't worry. If you wait long enough, it'll reach 10.
15:55:04 <ddarius> Quadrescence: What were you expecting?
15:55:11 <Quadrescence> ten 0s
15:55:12 <Quadrescence> :(
15:55:17 <ddarius> > replicate 10 0
15:55:18 <lambdabot>  [0,0,0,0,0,0,0,0,0,0]
15:55:20 <Baughn> > replicate 0 10
15:55:21 <Zao> @type genericTake
15:55:21 <lambdabot>  []
15:55:22 <lambdabot> forall i a. (Integral i) => i -> [a] -> [a]
15:55:24 <Quadrescence> :| Thanks. :)
15:55:59 <Quadrescence> (p.s., I do know what [a,b..c] is supposed to do)
16:15:47 <dolio> "I must say, sometimes i lookup to your courage in frequent cross posting..."
16:16:57 <Quadrescence> "OPENING DOORS  	YES "A NECCESARY EVIL"  	6/10"
16:20:16 <dogbite> hi all.  i just posted some code here
16:20:18 <dogbite> http://hpaste.org/8928
16:20:41 <dogbite> a python script i wrote to do the same thing takes 1.7s seconds (processing about 160k rows)
16:20:53 <dogbite> and this haskell program takes about 7.5 seconds
16:20:57 <dogbite> clearly i'm doing someting wrong
16:21:20 <shepheb> dogbite: without looking at the code, are you using Bytestrings?
16:21:36 <dogbite> shepheb: yup
16:21:55 <shepheb> hm. I'll leave it to the masters, then.
16:22:19 <dogbite> before Byteestring it was attrocious
16:32:26 <schme> I can't even compile that code :S
16:32:52 <dogbite> scheme: hmmm
16:33:12 <dogbite> words for me :-)
16:33:17 <dogbite> srsly, what's the error?
16:33:42 <ddarius> dogbite: You do realize last xs is O(length xs), length xs is O(length xs) for that matter.  xs !! n is O(n).
16:34:09 <schme> dogbite: It complains about > on the first line
16:34:10 <dogbite> ddarius: oh man... okay
16:34:44 <ddarius> Also the strict bytestring readFile will read in the entire input at once (is that what you want?)
16:34:45 <Baughn> dogbite: There are, of course, plenty of alternatives once you decide you need something faster
16:35:10 <dogbite> okay all -- let me think about the O(n) thing
16:35:13 <dogbite> that's clearly a problem
16:35:27 <schme> Seriously though, how do I compile this file with ghc?
16:35:38 <dogbite> schme: i used cabal
16:35:42 <Baughn> schme: What code?
16:35:54 <schme> Baughn: http://hpaste.org/8928
16:36:08 <Baughn> schme: ghc --make?
16:36:25 <schme> oh it needs --make.
16:36:28 <schme> I'll try that.
16:36:36 <Baughn> Or -package bytestring, but yeah
16:36:42 <dogbite> schme: i added a cabal to the hpaste
16:36:45 * shepheb can't wait until --make is the default.
16:36:46 <Baughn> --make is easier. It'll deal with /all/ dependencies
16:36:54 <schme> Gonk.hs:1:0: parse error on input `>'
16:36:58 <schme> Is what I get though.
16:37:04 <dogbite> i unfortunately gotta step away from the machine
16:37:06 <Baughn> shepheb: Looks more like it's getting moved into cabal
16:37:15 <dogbite> will think about some O(n) issues though...
16:37:55 <schme> That's with --make
16:38:09 <dcoutts> Baughn: what's getting moved into cabal?
16:38:18 <ddarius> schme: You need to put it in a .lhs
16:38:30 <schme> oh.
16:38:31 <Baughn> dcoutts: Duplicated in cabal?
16:38:34 <schme> That's weird.
16:38:52 <Baughn> dcoutts: The job Saizan is doing, anyhow. You'd know better than me.
16:39:09 <dcoutts> Baughn: ah, the make stuff
16:39:46 <Baughn> dogbite: The solution might be as simple as replacing it with Data.Sequence, or you might need to change your structure a bit
16:41:46 <ddarius> Except for (potentially) the last, I assume most of the usages of the functions are on relatively small lists.  The length r > 0 is a horrible way of writing (not (null r)) though.
16:43:07 <ddarius> doReadData (as most functions named do<something>) is ridiculous.  The only IO thing it does is read the file.
16:44:00 <matthew-_> @seen Heffalump
16:44:00 <lambdabot> Heffalump is in #darcs and #haskell. I last heard Heffalump speak 1d 3h 39m 14s ago.
16:44:12 <schme> So this style of writing haskell with code starting with > and comments on blank lines. Is this normal?
16:44:30 <Twey> schme: It's called 'literate Haskell'
16:44:30 <ddarius> schme: It's called a literate haskell source file.
16:44:39 <schme> Ok.
16:44:44 <Twey> It's the default mode for files ending in .lhs
16:44:44 <schme> It looks much better than the other style, really.
16:45:01 <schme> Is there some way to make vim insert the > automatically? ;)
16:45:09 <ddarius> I'm sure there is.
16:45:18 <schme> I need to check that out.
16:46:12 <schme> or maybe try that Yi.
16:50:38 <dogbite> Baughn: What do you mean about Data.Sequence.  instead of what?
16:50:57 <dogbite> is the sorting of regular lists expensive?
16:51:14 <schme> oh hum.. Is there some way to make the runghc Setup.hs configure   thing automatically retrieve and install all packages it says I need?
16:51:16 <Baughn> dogbite: Not particularily, no
16:51:36 <TomMD> Don't sort something huge ;-).
16:51:45 <Baughn> dogbite: No, I just meant that /if/ profiling shows that things like 'last list' are taking a lot of time, replacing it with a sequence would help
16:52:28 <dogbite> Baughn: gotcha
16:52:33 <Saizan> schme: you can use "cabal install" instead
16:53:09 <schme> Saizan: Hoh.. I don't seem to have a command named cabal here :)
16:53:28 <Saizan> schme: because you've to install it :)
16:53:35 <Saizan> ?hackage cabal-install
16:53:35 <schme> argh.
16:53:36 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/cabal-install
16:53:47 <schme> sbcl 1 - ghc 0
16:54:02 <ddarius> dogbite: How long are the lists that oneDay typically sees?
16:54:24 <dogbite> ddarius: on the order of 100
16:54:44 <schme> Right.
16:55:00 <ddarius> dogbite: How big is the input file?
16:55:06 <schme> So how do I get the cabal-install Setup.ghc automatically retrieve all dependencies?
16:55:12 <dogbite> about 160k lines
16:55:12 <schme> Setup.hs even
16:55:39 <dogbite> 157562  630226 9779275
16:56:41 <schme> I get this bugger: Setup.hs: At least the following dependencies are missing:  Cabal >=1.4&&<1.5, network >=1&&<3, HTTP >=3000&&<3002, zlib >=0.4
16:56:45 <Saizan> schme: you don't, you've to install those 3 manually
16:56:47 <schme> and I assume those will need something else.
16:56:58 <Saizan> they won't
16:57:01 <schme> :S
16:57:23 <schme> this is too complicated.
16:57:44 <dogbite> schme: cabal is the bomb
16:58:14 <Saizan> btw, network is usually installed with ghc
16:58:14 <dogbite> schme: i was also thrown by having to manually install roughly 3 packages by myself at first before cabal would work
16:58:25 <dogbite> but once i did, it rocked
16:58:34 <schme> dogbite: It's three too many though.
16:58:51 <schme> dogbite: What is good about it?
16:58:56 <schme> Saizan: Not on debian it seems.
16:59:03 <schme> That's what I get for using debian packages. horray.
16:59:08 * schme spits at debian.
16:59:18 <Saizan> schme: apt-get install libghc6-*
16:59:22 <ddarius> schme: Once you manually install cabal the first time.  You can write 'cabal install foo' from then on.
16:59:25 <dogbite> schme: because it magically handles make, package management, etc
16:59:29 <ddarius> Including 'cabal install cabal-install'
16:59:30 <schme> Hell no. I'm not installing more debian packages.
16:59:48 <schme> dogbite: Oh. Finally something normal.
16:59:52 <schme> dogbite: thanks.
17:00:15 <schme> I'll do that right after I remove this shoddy debian package :P
17:00:50 <ddarius> In the future, cabal-install will probably be distributed with GHC so you won't even have to manually install it the first time.
17:00:56 <schme> hoh.
17:01:14 <schme> I did runghc Setup install   then tried cabal install cabal-install.  No command cabal
17:01:20 <schme> horray \o/
17:01:51 <Saizan> runghc Setup install should have told you where the binary is installed
17:01:59 <Saizan> is that directory on your PATH?
17:02:12 <schme> Installing: /home/marcus/lib/Cabal-1.4.0.1/ghc-6.8.2
17:02:13 <schme> Registering Cabal-1.4.0.1...
17:02:13 <schme> Reading package info from "dist/installed-pkg-config" ... done.
17:02:13 <schme> Saving old package config file... done.
17:02:13 <schme> Writing new package config file... done.
17:02:15 <schme> is what it said.
17:02:17 <schme> oh yah.
17:02:22 <schme> There it was.
17:02:24 <schme> :D
17:02:33 <Saizan> Cabal is not the same package as cabal-install
17:02:43 <schme> Saizan: so?
17:03:02 <ddarius> schme: So you're not going to get the 'cabal' command by installing the wrong package.
17:03:03 <Saizan> Cabal is just the library
17:03:07 <schme> Saizan: I was just told I just had to do    cabal install cabal-install   now thata cabal is running :)
17:03:13 <schme> Huh.
17:03:23 <Saizan> cabal-intall has the program called cabal in it
17:03:27 <schme> ech.
17:03:35 <schme> The pain.
17:03:47 <schme> it's nice that you people are so helpful.
17:04:42 <Quadrescence> schme: I was in another channel /me coughs, C /me coughs again, and they were the opposite. D:
17:04:58 <schme> my gosh.
17:05:02 <schme> I need ghc installed to build ghc?
17:05:10 <schme> crap. I just removed it :(
17:05:11 <chrisdone> yes, ##c has downgraded in activity and quality
17:05:27 <Armored_Azrael> schme: No, but it will be annoyint to bootstrap
17:05:37 <Saizan> schme: install the generic linux binary
17:05:53 <schme> Armored_Azrael: Annoying in what way though?
17:06:10 <Baughn> schme: *Someone* needs ghc installed. It doesn't have to be you, or the same machine.
17:06:28 <Baughn> I think it was, at one point, supposed to be able to build itself from C sources too. No idea if that still works.
17:06:33 <Armored_Azrael> schme: You'll have to build the version of GHC that only sets compiles core haskell, written in C, which is frequently not stable in the darcs
17:06:38 <schme> Saizan: I'm a bit scared by it being built on fedora :)
17:06:42 <ddarius> Baughn: Of course that still works.
17:07:06 <Baughn> ddarius: Never have when I tried it. Perhaps I should use a point release instead of darcs.
17:07:06 <schme> Armored_Azrael: ho ok.
17:07:19 <Saizan> schme: always worked fine for me on debian and ubuntu
17:07:44 <Armored_Azrael> schme: Just install the binary, build GHC, uninstall the binary, install ghc
17:07:47 <Armored_Azrael> It works nicely that way
17:07:48 <schme> Saizan: That is good news. I'm a bit worried about "This was built on Fedora FC5, your mileage may vary" as it says :)
17:07:58 <schme> Ya. I'm grabbing it now.
17:08:06 <Baughn> schme: Or download binary, build GHC, overwrite binary, done. That works too
17:08:56 <schme> yup.
17:09:02 <schme> waiting for it.
17:09:17 <Quadrescence> Tips on how to get this to compile? http://hpaste.org/8929
17:09:18 <Armored_Azrael> Baughn: Oh. I was assuming he was using a package manager, and so would have installed /usr/bin/ghc, and need to install from source to /usr/local/bin/ to be reasonable :P
17:10:03 <schme> Armored_Azrael: Don't insult me :(
17:10:10 <schme> Armored_Azrael: I *hate* package managers.
17:10:11 <schme> :)
17:10:15 <mjrosenb> mapM (id) == sequence, right?
17:10:26 <mjrosenb> schme: you're a slack type of guy?
17:10:36 <schme> mjrosenb: I wish. Can't use it.
17:10:45 <Saizan> schme: why you want cabal-install then?:)
17:10:45 <Nafai> schme: Why?
17:10:47 <Quadrescence> mjrosenb: I don't know what mapM is. D:
17:10:48 <chrisdone> Quadrescence: function application binds most tightly, so “putStr show newCube'
17:10:52 <Saizan> mjrosenb: yes
17:10:54 <ddarius> mjrosenb: Yes.
17:10:57 <ddarius> @src mapM
17:10:58 <lambdabot> mapM f as = sequence (map f as)
17:11:01 <chrisdone> Quadrescence: uh, applies putStr to show, rather than to (show newCube)
17:11:08 <chrisdone> Quadrescence: you need parentheses or a $
17:11:10 <Armored_Azrael> schme: ... what's wrong with package managers?
17:11:13 <mjrosenb> erm, i see
17:11:34 <mmorrow> imo this is the best description of haskell aimed at a programmer that doesn't know haskell that i've seen anywhere: http://www.updike.org/articles/Pure_Lazy_Functional
17:11:35 <lambdabot> Title: Haskell: Pure and Lazy, yet Functional
17:11:59 <schme> Saizan: It's quite ok for individual things. like asdf-install, sure thing. ruby gems, sure thing. XE packages, sure thing.  but when one goes a step above that they just tend to make things worse...   like debian insisting on installing CLC to install sbcl.
17:12:14 <schme> Armored_Azrael: They mess my system up by installing stuff I don't want, and tend to be broken :)
17:12:23 <schme> Nafai: It's just ia32 IIRC.
17:12:26 <chrisdone> Quadrescence: that is “putStr $ show newCube”
17:12:40 <mmorrow> i'm going to spam all the people i try to convince on a regular basis to learn haskell with a link to that article
17:12:48 <mjrosenb> schme: have you tried gentoo?
17:12:50 <chrisdone> Quadrescence: I don't see any other problems off-hand
17:12:58 <Nafai> schme: I was asking why you hate package managers, but you answered that.
17:13:01 <schme> mjrosenb: Yes.
17:13:04 <schme> Nafai: oh!
17:13:04 <Quadrescence> There shouldn't be any others. :}
17:13:12 <schme> Nafai: my bad :D
17:13:24 <Nafai> That's okay :)
17:13:50 <schme> mjrosenb: When I found out that OE used a system that was a bit gentooish I cried for days ;)
17:13:55 * schme spreads the hate.
17:14:19 <schme> Anyway thanks for the help there, guys and gals. I need to go eat :)
17:30:49 <chrisdone> ?happy
17:30:49 <lambdabot> Unknown command, try @list
17:35:54 <mjrosenb> i seem to be using maybe mzero alot.  is there anything that does more or less that?
17:36:14 <ddarius> :t maybe mzero
17:36:15 <lambdabot> forall (m :: * -> *) a a1. (MonadPlus m) => (a1 -> m a) -> Maybe a1 -> m a
17:36:57 <Baughn> > fail :: []
17:36:58 <lambdabot>      `[]' is not applied to enough type arguments
17:36:58 <lambdabot>     Expected kind `?', but ...
17:37:05 <Baughn> > fail :: [Int]
17:37:06 <lambdabot>  Couldn't match expected type `[Int]'
17:37:22 <ddarius> mjrosenb: You could split it into fmap and fromMaybe mzero
17:37:52 <Baughn> @instances MonadPlus
17:37:52 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
17:38:02 <ddarius> Unless the MonadPlus instance you are usually using is Maybe in which case you just have fmap.
17:38:23 <mjrosenb> so i was thinking of a single function that would be equivalent to maybe mzero
17:38:48 <mjrosenb> ddarius: unless i'm not understanding what you meant
17:38:51 <mjrosenb> ddarius: it isn't
17:39:13 <mjrosenb> although it internally uses Maybe
17:40:10 <|jedai|> :t maybe
17:40:11 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
17:40:49 <Jedai> :t fromMaybe
17:40:49 <lambdabot> forall a. a -> Maybe a -> a
17:41:33 <Jedai> mjrosenb: If you're using maybe mzero that much, why not just defining this function ?
17:41:53 <chrisdone> fromMaybe = flip maybe id?
17:41:55 <chrisdone> @src fromMaybe
17:41:56 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
17:42:00 <chrisdone> =o
17:43:07 <mjrosenb> Jedai: because i thought that it might already exist.
17:50:49 <chrisdone> wows, installed ghc and cabal fresh on my laptop and lambdabot installed from cabal install with no problems
17:52:06 <gwern> it did? something's not right then
17:54:03 <chrisdone> indeed
17:55:08 <gwern> my faith in cabal and ghc will only be restored if you assure me that lambdabot doesn't run correctly :)
17:55:22 <cjs> It doesn't give me much confidence in their hiring process. Or about who is going to be working next to me.
17:55:48 <cjs> (Though, honestly, the guy working next to me ought to be a lot more worried about me than me about him.)
17:56:00 <cjs> Oops!
17:56:04 <cjs> Sorry!
17:56:08 <chrisdone> @_@
17:56:20 <bwr> huhu
17:56:29 <chrisdone> gwern: well, @run doesn't work fd:6: hClose: resource vanished (Broken pipe)
17:56:47 <fons> > gread "(True)" :: [(Bool,String)]
17:56:49 <lambdabot>  [(True,"")]
17:56:49 <chrisdone> gwern: I suspect it's simply looking for runplugs in the wrong place
17:57:06 <fons> gread "(())" :: [((),String)]
17:57:16 <fons> > gread "(())" :: [((),String)]
17:57:18 <lambdabot>  []
17:57:22 <chrisdone> gwern: it also says it can't find the djinn binary even though it's in my PATH. maybe I have to stick it in /usr/bin
17:57:30 <fons> > gread "()" :: [((),String)]
17:57:31 <lambdabot>  []
17:57:38 <bwr> I am trying to do the google code jam sample problems in haskell. why does map ((length "0123456789abcdef")^) [x|x<-[0..((length "0123456789abcdef")-1)]] give a different result from map (16^) [x|x<-[0..15]]
17:57:52 <fons> is it just me or gread is broken for ()
17:57:52 <dmwit> chrisdone: dmwit.homelinux.com/blah.log
17:57:55 <TomMD> note to self: don't work next to cjs right now, his rather negative.
17:58:11 <Giblaz> anyone here have a moment to help me with an algorithm i'm working on?
17:58:11 <cjs> Only about Google!
17:58:24 <dmwit> :t gread
17:58:25 <lambdabot> forall a. (Data a) => String -> [(a, String)]
17:58:35 <ddarius> > gshow ()
17:58:36 <lambdabot>  "(())"
17:58:47 <TomMD> :i Data
17:58:54 <fons> > gread "(())" :: [((),String)]
17:58:56 <lambdabot>  []
17:59:05 <fons> that should work
17:59:10 <dmwit> ?index Data
17:59:10 <lambdabot> Data.Generics.Basics, Data.Generics
17:59:23 <ddarius> dmwit: It's probably parsing parentheses and then viewing that as a pair of nested parentheses (for grouping) rather than as an empty tuple.
17:59:39 <chrisdone> dmwit: I don't understand that log, sorry
17:59:40 <ddarius> It does seem broken.
17:59:57 <dmwit> chrisdone: me neither =/
18:00:10 <gwern> chrisdone: I would not be surprised if the djinn executable shell is bypassing the shell, in which case $PATH is irrelevant
18:00:16 <Giblaz> get_full_token [] [] = []
18:00:18 <Giblaz> get_full_token [] y = y
18:00:19 <Giblaz> get_full_token (x:xs) y | x == close = y:x
18:00:21 <Giblaz>                         | otherwise = get_full_token xs y:x
18:00:23 <Giblaz> this is not working so well
18:00:31 <Saizan> bwr: because length :: [a] -> Int, while in the second case 16 defaults to Integer
18:00:42 <chrisdone> gwern: running lambdabot in the same directory as djinn, it finds it. but runplugs on the other hand, still broken pipe :)
18:01:17 <bwr> Saizan: if i just convert everything to Integer everywhere will it work?
18:01:19 <bwr> :P
18:01:50 <Saizan> bwr: yes, with fromIntegral, or use genericLength from Data.List
18:01:58 <dmwit> Giblaz: occurs check?
18:02:13 <gwern> chrisdone: yeah, hs-plugins is kind of not cool these days
18:02:14 <dmwit> Oh, I misparsed.
18:02:17 <Giblaz> i'm not following dmwit, i'm sorry
18:02:25 <dmwit> never mind
18:03:16 <dmwit> Giblaz: What is it supposed to do?
18:03:31 <Giblaz> i'm sorry
18:03:33 <chrisdone> at least I can now build haddock on my laptop without that stupid containers link error. I guess I need to eradicate all ghc and cabal stuff from my pc and then re-install from scratch
18:03:37 <Giblaz> i didn't write it properly
18:03:51 <Giblaz> what its supposed to do is be a helper function for a recursive data structure algorithm
18:04:35 <Giblaz> so you can have tokens, written much like lisp, in this style: (command (nested_command argument) (another_nested_command argument1 argument2))
18:04:55 <Giblaz> i haven't played around with types yet
18:05:01 <Giblaz> although i think it would be nice to have a Token type
18:05:14 <Giblaz> i might make one, but again i haven't tried out that stuff yet
18:05:28 <Giblaz> i'm still learning haskell, trying to learn by "jumping in" and working on some stuff in it
18:05:57 <dmwit> Without seeing the error/desired output it's hard to say; but are you sure you want (:) everywhere and not (++) anywhere?
18:06:12 <Giblaz> hmmm i'm not so sure
18:06:14 <Giblaz> i don't know really
18:06:26 <Giblaz> does : not do list concatenation?
18:06:33 <Giblaz> i thought it did (i know that ++ does)
18:06:34 <dmwit> It does not do list concatenation.
18:06:38 <Giblaz> ahh ok
18:06:50 <dmwit> > "hey" ++ " world" -- this is concatenation
18:06:51 <lambdabot>  "hey world"
18:06:58 <Giblaz> ahh
18:07:00 <Giblaz> can you go like
18:07:02 <dmwit> > 'h' : "ey world" -- this is cons
18:07:03 <lambdabot>  "hey world"
18:07:05 <Giblaz> "hey" ++ 'w'
18:07:09 <dmwit> no
18:07:15 <Giblaz> hmm
18:07:17 <Giblaz> ok
18:07:22 <Giblaz> so i will have to throw x into a list
18:07:27 <Giblaz> of size 1
18:07:31 <chrisdone> "hey" == 'h' : 'e' : 'y' : []
18:07:41 <Giblaz> ahhh thanks chris
18:07:45 <Giblaz> thanks dmwit as well
18:07:49 <Giblaz> hmm this makes more sense now
18:07:53 <dmwit> Giblaz: You should consider building the list backwards, then reversing at the very end.
18:08:01 <dmwit> (appending to lists is slow)
18:08:06 <Giblaz> oh?
18:08:12 <Giblaz> i didn't know this
18:08:30 <dmwit> a ++ b -- is O(length a)
18:08:35 <chrisdone> you have to do at least n steps where n is the length of the first list
18:08:36 <dmwit> ...sort of
18:08:38 <Giblaz> this is true
18:08:42 <Giblaz> i see what you're getting at
18:08:46 <Giblaz> well i could alter my algorithm
18:08:50 <Giblaz> instead of appending to the list
18:08:55 <Giblaz> i keep track of the indice i'm at
18:09:07 <Giblaz> then do take list ending_indice
18:09:22 <dmwit> The singular form of "indices" is "index". ;-)
18:09:27 <Giblaz> when i hit the close parentheses of the token
18:09:37 <Giblaz> haha, my language skills are not so hot after today :P
18:09:49 <dmwit> Yep, that's another possible solution.
18:10:10 <Giblaz> my brain has been fizzled by a giant enterprise grade data collection and display system written in perl and php
18:10:25 <Giblaz> i'm trying to purify myself by using some haskell XD
18:10:48 <cjs> Giblaz: you're so lucky! It wasn't some weird SAP scripting language!
18:10:49 <Giblaz> yeah i think keeping track of the indice is the best solution (for now at least)
18:10:52 <Giblaz> LOL
18:10:58 <Giblaz> i love obscure scripting languages
18:11:11 <Giblaz> i was reading about the brainf*ck interpreter written in LOLcode
18:11:20 <Giblaz> i showed my boss and we both laughed for like 10 minutes reading the code
18:15:10 <chrisdone> get out of bed, resistance is futile, wake up and assimilate the day
18:16:04 <Giblaz> i like that mantra
18:16:17 <ddmnshs> \quit
18:16:22 <ddarius> And the world turns away as you tap the snooze button in bed.
18:17:02 <oklopol> you snooze you lose
18:19:41 <mjrosenb> this is why the snooze button needs to have a 110V potential between it's left half and it's right haly
18:20:57 <oklopol> or perhaps between the snooze button and the bed
18:29:59 <cjs> Giblaz: What was the language where the program was like a Mondran painting?
18:30:38 <Giblaz> Do you mean a Mondrian painting?
18:32:06 <cjs> Yeah, sorry, spelling.
18:32:33 <ddarius> Piet?
18:32:44 <Giblaz> hehe, i was just unsure if you were talking about someone else, no need to be sorry :P
18:32:49 <ddarius> @google Piet programming language
18:32:50 <lambdabot> http://www.dangermouse.net/esoteric/piet.html
18:32:50 <lambdabot> Title: DM's Esoteric Programming Languages - Piet
18:33:33 <Giblaz> oh god
18:33:35 <Giblaz> what is this
18:33:39 <Giblaz> this is
18:33:40 <Giblaz> terrible
18:35:09 <Giblaz> btw cjs, the language's were php and perl
18:35:33 <chrisdone> hey gwern, can you actually run the runplugs with lamdabot?
18:35:49 <Giblaz> my pet peeve when programming is making a thousand temporary files to do like 2 operations
18:36:41 <Giblaz> i hate the idea of taking something from the disk, putting it to ram, doing stuff to it, putting it back to disk, taking it off, doing stuff to it, rinse repeat a hundred times
18:39:16 <cjs> Ah, Piet, yes. I can never remember the name.
18:40:44 <cjs> Giblaz: BTW, what?
18:40:59 <Giblaz> I was talking about the system you asked me about
18:41:05 <Giblaz> more or less ranting though
18:41:13 <Quadrescence> :t show
18:41:14 <Giblaz> hmm
18:41:15 <lambdabot> forall a. (Show a) => a -> String
18:41:40 <Quadrescence> hmmm
18:41:42 <cjs> Oh. I'm not really understanding that, but I'll pretend I do. It makes me look better.
18:41:49 <Giblaz> ;)
18:42:09 <Giblaz> I'm probably not explaining myself well then
18:42:12 <Giblaz> :P
18:42:31 <cjs> BTW, regarding the disk I/O thing, if you're doing it often enough, much of it never hits disk.
18:42:57 <cjs> And if you're not doing it often enough, it's such a small amount of I/O that you don't care.
18:43:24 <Saizan> chrisdone: the was to get a lambdabot running is to grab it from the darcs repo and use the script named build
18:43:33 <Saizan> ?version
18:43:34 <lambdabot> lambdabot 4.1
18:43:34 <lambdabot> darcs get http://code.haskell.org/lambdabot
18:43:56 <cjs> IOW, you can trust the buffering of modern (by this I mean, late '90s or later) OSes.
18:44:17 <cjs> @vixen
18:44:17 <lambdabot> do you trust the government?
18:45:30 <Giblaz> depends on the government
18:46:03 <Quadrescence> I still can't get line 41 to do what I'd like: http://hpaste.org/8929
18:46:03 <Quadrescence> D:
18:46:19 <Quadrescence> But there's a response!
18:46:23 <Quadrescence> Which I did not see.
18:46:25 <Quadrescence> :|
18:46:59 <Quadrescence> You haskelletons are tricky people.
18:48:23 <chrisdone> Saizan: oki
18:50:01 <cjs> What's the issue, Quadrescence?
18:52:02 <Quadrescence> cjs: I found it. I didn't see the reply to the code I posted.
18:59:39 <Giblaz> how do you reference an index in a list?
19:01:31 <Giblaz> i figured it out
19:04:30 <edwardk> hrmm. found a good 'intro to what type theory is' lecture: http://www.youtube.com/watch?v=h0OkptwfX4g that might be useful if you need to explain to someone a bit about how Haskell differs from other languages, etc.
19:04:31 <lambdabot> Title: YouTube - Advanced Topics in Programming Languages Series:...
19:06:20 <Giblaz> this is cool
19:06:23 <Giblaz> thanks edward
19:07:27 <edwardk> i changed the video playing in the lively haskell cafe over to it too, since its a google video thats about a half hour long so it loops less ;)
19:08:09 <zachk> wait there is a lively haskell cafe?
19:08:37 <edwardk> http://comonad.com/reader/2008/haskell-cafe/
19:08:41 <lambdabot> Title: The Comonad.Reader  A Lively Haskell Café
19:09:30 <zachk> already googled and downloading
19:10:12 <zachk> is there a python channel on freenode?
19:10:42 <edwardk> I didn't realize when I built the room that there were so few haskeller's that actually ran windows and hence could actually participate there, but its had a fairly steady stream of folks come through.
19:11:58 <bwr> is there an easy way to convert from binary to hex in haskell?
19:14:48 <oklopol> zachk: freenode has a channel for every language
19:16:09 <atp> bwr: lots of ways
19:16:21 <atp> bwr: or by easy do you mean "a library function"
19:16:30 <edwardk> the main things i'd like to see in lively is the ability for you to pause the video, fast forward/rewind, etc. even if its only your own client that sees the video tweaks
19:16:55 <bwr> yea, i was wondering if there was a library function
19:16:57 <edwardk> though if they were shared it'd work well for group watching of clips, etc.
19:17:01 <bwr> i did a search but didn't see anything
19:20:24 <dmwit> bwr: Take a look at the Numeric module.
19:20:32 <dmwit> :t readIntAtBase
19:20:34 <lambdabot> Not in scope: `readIntAtBase'
19:20:39 <dmwit> :t showIntAtBase
19:20:39 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
19:21:04 <dmwit> :t readInt
19:21:06 <lambdabot> forall a. (Num a) => a -> (Char -> Bool) -> (Char -> Int) -> String -> [(a, String)]
19:21:31 <bwr> thanks
19:23:32 <dmwit> > let binaryToHex = showHex . fst . head . readInt 2 (`elem` "01") digitToInt in binaryToHex "110" ""
19:23:34 <lambdabot>  "6"
19:23:42 <dmwit> > let binaryToHex = showHex . fst . head . readInt 2 (`elem` "01") digitToInt in binaryToHex "110" "0x"
19:23:43 <lambdabot>  "60x"
19:23:49 <dmwit> Whoops, heh.
19:24:05 <dmwit> > let binaryToHex = showHex . fst . head . readInt 2 (`elem` "01") digitToInt in binaryToHex "10010" ""
19:24:06 <lambdabot>  "12"
19:24:25 <bwr> cool
19:33:32 <atp> hey edwardk, what do you call a catamorphism that consumes several elements of a structure instead of just one?
19:33:37 <atp> is there a name for that kind of scheme?
19:34:01 <chrisdone> kpreid: ping?
19:35:19 <kpreid> pong
19:37:36 <oklopol> oh, catamorphisms are a simple concept
19:37:45 <oklopol> i've been too scared of the word to google :)
19:37:57 <kpreid> chrisdone: I have not too many minutes remaining today...
19:38:27 <chrisdone> kpreid: ah, nevermind then
19:39:12 <kpreid> ahem. you have my attention. please continue...
19:39:50 <dmwit> chrisdone: Hurry up about it! =P
19:40:06 <chrisdone> kpreid: I saw you experiencing the broken pipe with runplugs and lambdabot on an IRC log and was wondering how you solved it
19:40:34 * chrisdone chortles
19:40:54 <kpreid> chrisdone: long ago? that would have been using the without-runplugs configuration
19:41:15 <chrisdone> kpreid: I see
19:44:18 <chrisdone> gwern: this is really cool! http://groups.google.co.uk/group/fa.haskell/browse_thread/thread/c430f55bca25e9c6
19:44:29 <lambdabot> Title: ANN: Mueval 0.21 - fa.haskell | Google Groups, http://tinyurl.com/68arq5
19:47:04 <cetin> hi, what is the difference between regex base and regex posix (Text.Regex.Posix)?
19:47:09 <dogbite> i'm building with cabal -- is there an easy way to enable profiling?
19:47:29 <dolio> --enable-library-profiling or something like that.
19:47:32 <dolio> On the configure.
19:47:59 <wuxia> is there anything like erlang's mnesia in haskell?
19:47:59 <edwardk> ack client died
19:48:03 <zachk> my lively finally crashed
19:48:04 <edwardk> atp: did you ever get a response?
19:48:27 <dogbite> dolio: thanks -- maybe --enable-executable-profiling
19:48:35 <dogbite> dolio: trying now
19:48:35 <edwardk> atp: a histomorphism can look back at previous responses for several levels basically
19:48:59 <edwardk> which isn't quite what it sounds liek you are looking for
19:49:07 <atp> edwardk: no, not really...
19:49:11 <dogbite> I'm getting "Perhaps you haven't installed the profiling libraries for package bytestring-0.9.1.0"
19:49:17 <atp> collectByLen :: Int -> [a] -> [[a]]
19:49:18 <edwardk> but its the closest duality gets you i think
19:49:19 <atp> collectByLen n [] = []
19:49:19 <atp> collectByLen n xs = let (h, t) = splitAt n xs in h : collectByLen n t
19:49:27 <dogbite> how would i get those libraries?
19:49:31 <atp> edwardk: see, that looks like a foldr
19:49:43 <dolio> That looks like an unfoldr.
19:49:59 <atp> dolio: you think?
19:50:08 <edwardk> atp: the problem is that you need to know what you are doing when you don't have an even multiple, etc.
19:50:10 <atp> dolio: hm, i suppose it could be.
19:50:43 <atp> edwardk: yeah, and i suppose take is itself not primitive-recursive
19:51:03 <atp> edwardk: so really i'm already too high-level
19:51:16 <edwardk> @src take
19:51:16 <lambdabot> take n _      | n <= 0 =  []
19:51:16 <lambdabot> take _ []              =  []
19:51:16 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
19:51:28 <edwardk> take as an unfold works fine
19:51:35 <atp> yeah
19:51:39 <edwardk> you have a simple seed (the original list and an integer)
19:51:40 <atp> so it's a fold with an unfold in it...
19:52:00 <edwardk> atp: there is a nice name for an unfold followed by a fold ;)
19:52:04 <zachk> edwardk: lively crashed and now firefox has crashed :-( neat idea though
19:52:06 <dolio> @type unfoldr (\l -> if null l then Nothing else Just (splitAt n l))
19:52:07 <lambdabot>     Couldn't match expected type `Int' against inferred type `Expr'
19:52:07 <lambdabot>     In the first argument of `splitAt', namely `n'
19:52:07 <lambdabot>     In the first argument of `Just', namely `(splitAt n l)'
19:52:14 <edwardk> zachk: ah well
19:52:15 <atp> edwardk: a hylomorphism?
19:52:15 <dolio> @type \n -> unfoldr (\l -> if null l then Nothing else Just (splitAt n l))
19:52:17 <lambdabot> forall a. Int -> [a] -> [[a]]
19:52:22 <zachk> edwardk: is that a summo-morphism?
19:52:32 <edwardk> zachk: how much of the continuation passing style explanation made it through before the crash?
19:52:46 <edwardk> zachk: nah, a hylomorphism, its one of the 'big 4'
19:52:53 <edwardk> atp: exactly
19:52:59 <zachk> edwardk: ive looked at cps but dont really grok it
19:53:08 <atp> edwardk: so you think my collect function is a hylo? hmm
19:53:12 <zachk> let me go to to your comonad again
19:53:23 <edwardk> here lemme just ramble through it here
19:53:26 <edwardk> you get a better log this way
19:53:35 <zachk> ok
19:53:47 <dolio> > (\n -> unfoldr (\l -> if null l then Nothing else Just (splitAt n l))) 5 [1..20]
19:53:49 <lambdabot>  [[1,2,3,4,5],[6,7,8,9,10],[11,12,13,14,15],[16,17,18,19,20]]
19:53:55 <edwardk> ok, so i'll use javascript this time since perl just introduces noise in the translation with all the my ($foo) = @_; crap
19:53:57 <edwardk> same idea
19:54:03 <atp> dolio nice.
19:54:04 <edwardk> so we'll start with
19:54:18 <edwardk> function square(x) { return (x*x); }
19:54:26 <edwardk> and the statement print(square(x));
19:54:52 <edwardk> and we'll cps transform square yielding, function squarek(x,k) { k(x * x); }
19:54:59 <edwardk> and the statement squarek(x,print);
19:55:16 <edwardk> now we never use the 'return' of our functions, we just call another argument we were given with the answer instead
19:55:27 <ddarius> Not that it is off-topic, but #haskell-overflow may be better?
19:55:34 <edwardk> ddarius: probably
19:55:42 <edwardk> i just realized this was going to get spammy =)
19:55:45 <dogbite> I'm trying to profile this code I wrote (I was discussing it earlier on here but had to leave)
19:55:46 <zachk> is that it?
19:55:50 <dogbite> http://hpaste.org/8928
19:55:55 <cetin> can I use a 64-bit ghc to compile a 32-bit binary?
19:55:59 <edwardk> zachk: in a nutshell, yes.
19:56:06 <dogbite> Just the doReadData function alone takes 3.6 seconds
19:56:27 <edwardk> zachk: call/cc just gives you access to the 'continuation' as a function you can call explicitly with the answer to the current function
19:56:30 <dogbite> and the entire equiv python program takes about a second
19:56:52 <dolio> How big is the file?
19:57:01 <dogbite> dolio: 160k lines
19:57:10 <atp> :e
19:57:14 <atp> hehe
19:59:09 <dolio> unpacking to Strings probably isn't going to be nice.
19:59:40 <dolio> At a guess.
20:00:01 <dmwit> :t (compare `on` head) `mappend` (compare `on` (!!5))
20:00:01 <lambdabot> forall a. (Ord a) => [a] -> [a] -> Ordering
20:00:03 <dogbite> dolio: yeah i'd agree but i'm not sure how to accomplish what i need to do
20:00:04 <dogbite> without that
20:00:16 <dolio> Although I don't know if there's a ByteString -> Double...
20:00:21 <dmwit> dogbite: You might like that way of writing sortByTicker. =)
20:00:40 <dogbite> :t mappend
20:00:42 <lambdabot> forall a. (Monoid a) => a -> a -> a
20:01:15 <dmwit> :t comparing head `mappend` comparing (!!5)
20:01:15 <lambdabot> forall a. (Ord a) => [a] -> [a] -> Ordering
20:01:22 <dmwit> That's even better!
20:01:37 <dogbite> dmwit: neat!
20:02:08 <dmwit> dogbite: But: is it necessary to resort to Char lists at all?
20:02:40 <dolio> Apparently there's no readDouble.
20:02:41 <dmwit> Or... am I confused?
20:02:51 <dmwit> > read "3.5" :: Double
20:02:51 <lambdabot>  3.5
20:02:56 <dmwit> dolio: ?
20:03:00 <dmwit> oh
20:03:02 <dmwit> in BS?
20:03:04 <dolio> That's not a ByteString.
20:03:05 <dolio> :)
20:03:09 <dmwit> ok
20:03:27 <bwr> anyone want to see my terribly ugly solution to google code jam sample problem 1? :P (i am a haskell newbie)
20:03:35 <dmwit> bwr: Sure!
20:03:37 <dolio> You could do slightly les BS -> String conversion by storing ByteStrings instead of Strings.
20:03:39 <ddarius> You could no doubt change it so that you only unpack small parts at a time.
20:03:40 <chrisdone> I need a rest from programming, it's getting me down. back in a few days
20:03:45 <dmwit> bwr: A link to code jam 1 wouldn't be refused, either. ;-)
20:03:58 <bwr> http://hpaste.org/8931
20:04:14 <bwr> http://code.google.com/codejam/
20:04:16 <lambdabot> Title: Google - Code Jam
20:04:27 <bwr> you have to register to see the problem unfortunately
20:04:40 <ddarius> String has a 12 or 24 fold size increase on ByteString so that 10MB file becomes 120-240MB unpacked.
20:04:53 <bwr> i can paste the problem though on hpaste
20:04:55 <dmwit> bwr: Paste the jam?
20:04:56 <dmwit> yeah
20:05:12 <dogbite> dmwit: okay well i'll think about what to do about this ByteString to String thing though
20:05:18 <dolio> dogbite: I'd try to do stuff like 'makeRow [r1,r2,r3,r4,r5]' instead of using !! all over. You're not traversing big lists, but it might add up doing it 160,000 times.
20:05:49 <dogbite> dolio: alright
20:05:53 <ddarius> Switching to lazy bytestrings may also significantly help with even no other changes (or maybe not)
20:05:56 <dmwit> I was just going to suggest that. =P
20:06:12 <dogbite> dmwit: yeah?  seems like i shoudl ahve plenty of ram
20:06:16 <dmwit> where "that" means the [r1..r5] thing
20:06:28 <bwr> http://hpaste.org/8932
20:06:29 <dogbite> also, won't my sort immediately bring it all in anyway?
20:06:43 <bwr> some of the characters turned funky atleast for me
20:07:04 <bwr> eww, and no word wrap
20:07:37 <bwr> anyway, it isn't a very hard problem... but i'm pretty new to haskell
20:07:39 <bwr> so my solution is ugly]
20:08:07 <dmwit> bwr: Take a look at Numeric. ;-)
20:08:24 <bwr> yea, i wrote this before i asked the question about converting between binary and hex
20:08:58 <bwr> i am currently working on the second sample problem
20:09:12 <bwr> which seems much tougher
20:10:25 <atp> > (\n -> reverse . unfoldr (\l -> if l == 0 then Nothing else Just . uncurry (flip (,)) . divMod l $ n)) 10 232432232
20:10:26 <lambdabot>  [2,3,2,4,3,2,2,3,2]
20:10:31 <atp> hm
20:10:42 <atp> base conversion is an anamorphism, it seems
20:10:50 <atp> > (\n -> reverse . unfoldr (\l -> if l == 0 then Nothing else Just . uncurry (flip (,)) . divMod l $ n)) 16 2234232
20:10:51 <lambdabot>  [2,2,1,7,7,8]
20:11:47 <atp> you know, i don't much like how unfoldr uses Maybe instead of having a predicate argument the way it does in bananas & lenses
20:11:56 <atp> it makes nice point-free code cumbersome
20:12:38 <dolio> Woo! Someone who agrees with me. :)
20:12:40 <ddarius> atp: You can efficiently implement that one in terms of this one, but not the other way around.
20:12:47 <dmwit> > let convert num from to = showIntAtBase (length to) (to!!) (fst . head $ readInt (length from) (`elem` from) (fromJust . flip findIndex from) num) "" in convert "CODE O!CDE? A?JM!"
20:12:47 <lambdabot>  Couldn't match expected type `Char'
20:12:50 <zachk> @type fmap
20:12:51 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
20:13:02 <ddarius> I often find "predicates" that return Maybe Something more useful than boolean predicates.
20:13:28 <atp> hm
20:14:51 <bwr> dmwit: wouldn't the convert at the end need to be convert "bleh" "bleh" "bleh"
20:15:03 <atp> dmwit: are you going to fix that mess? :)
20:15:11 <atp> dmwit: we're all waiting with baited breath
20:15:17 <dmwit> I'm working on it.
20:15:30 <dons> here's something to think about http://www.reddit.com/info/6rs94/comments/
20:15:31 <lambdabot> Title: reddit.com: "IBM going after a 10 petaflop system (peak) comprised of 38,900 eig ...
20:16:35 <atp> ugh, cookies
20:17:03 <atp> why do so many webmasters design their sites to put 300 different cookies on my browser and then not even use the cookies for anything stateful?
20:17:13 <atp> it's like webprogramming entirely in the IO monad for no good reason
20:17:41 <dmwit> > let convert num from to = showIntAtBase (length to) (to!!) (fst . head $ readInt (length from) (`elem` from) (fromJust . flip findIndex from . (==)) num) "" in convert "CODE O!CDE? A?JM!"
20:17:42 <lambdabot>  <[Char] -> [Char] -> [Char]>
20:17:47 <dmwit> blast!
20:18:07 <bwr> i have no idea what that response means :/
20:18:17 <atp> what is this?  this looks like perl golf :)
20:18:19 <dmwit> It means the result is a function.
20:18:27 <bwr> ah
20:18:28 <atp> oh.
20:18:45 <atp> well, you didn't give it from or to
20:19:01 <dmwit> Oh, quite right.
20:19:09 <dmwit> > let convert num from to = showIntAtBase (length to) (to!!) (fst . head $ readInt (length from) (`elem` from) (fromJust . flip findIndex from . (==)) num) "" in convert "CODE" "O!CDE?" "A?JM!"
20:19:09 <lambdabot>  "MMA!"
20:19:17 <atp> is that success?
20:19:19 <dmwit> Not quite right. =P
20:19:20 <dmwit> no
20:19:22 <atp> hehe
20:19:28 <dmwit> "JAM!" is the right answer. =)
20:19:35 <atp> ah
20:19:39 <bwr> so much shorter than mine
20:19:45 <atp> this kind of reminds me of APL hacking
20:19:49 <bwr> haha
20:20:00 <dmwit> Well, anybody can write short, wrong code.
20:20:04 <atp> you can write an entire operating system in 5 glyphs but goddamn if anyone but you will ever know how it works
20:20:16 * atp hugs APL.
20:20:37 <bwr> i took a look at APL today actually... some people in #nethack were talking about it... it looks crazzzy
20:20:52 <atp> bwr: it's a great language.
20:21:00 <bwr> is it really?
20:21:03 <atp> yeah.
20:21:08 <atp> it'll blow your mind :)
20:21:24 <bwr> i did something evil today
20:21:31 <bwr> i stuck the c preprocessor on java :P
20:21:34 <bwr> and used macros in java
20:21:47 <atp> hm
20:21:51 <atp> that doesn't sound evil.
20:22:00 <atp> just think of all the useless boilerplate you can get rid of that way.
20:22:10 <bwr> well, maybe not... but think of all the java programmers who would freak out
20:22:12 <bwr> if they saw that
20:22:14 <ddarius> J was a lot more readable than I was expecting, though still rather harder to read than Haskell or C# say.
20:22:33 <atp> ddarius: i've heard J is pretty neat, but i've never hacked it.
20:22:45 <ddarius> J is fun, but it would be an insane language to develop something large in (albeit for quite surmountable reasons)
20:23:17 <bwr> how do you program in APL on modern computers?
20:23:21 <atp> ddarius: hm, yeah, i don't think i'd ever write something huge in APL, either.  but you certainly can do some scary things with just one line in those languages
20:23:32 <atp> bwr: just get an APL interpreter
20:23:40 <atp> bwr: it's just a programming language
20:23:46 <atp> bwr: there are compilers, too.
20:23:49 <bwr> yea, but how do you type the characters
20:24:08 <atp> bwr: oh.  i used an emacs mode of some sort... can't recall which now, i'm sure there are lots
20:24:43 <bwr> ah
20:24:47 <atp> bwr: on the Euler project there are some people writing in APL/J/K and they solve some of the more complex problems in one very short and cryptic line
20:24:52 <atp> it's pretty cool :)
20:24:55 <bwr> cool
20:25:02 <ddarius> bwr: Just use J nowadays.
20:25:10 <bwr> i've done a few of them in haskell
20:25:20 <bwr> which is the strangest language i've used :P
20:25:41 <atp> haskell is a better general purpose language imho, but array-based languages are worth it if only for the mental flexibility that results
20:25:42 <bwr> having an imperative programming background
20:25:58 <dmwit> bwr: I wonder if their sample output is broken.
20:26:05 <bwr> it works for mine
20:26:18 <dmwit> bwr: Since my convert function works on the first three cases, but not the last one, it makes me wonder...
20:26:41 <bwr> weird
20:26:46 <bwr> what do you have now?
20:27:10 <dmwit> I haven't changed anything since the last eval here.
20:27:12 <dmwit> So:
20:27:23 <dmwit> convert num from to = showIntAtBase (length to) (to!!) (fst . head $ readInt (length from) (`elem` from) (fromJust . flip findIndex from . (==)) num) ""
20:27:47 <bwr> does the let ... in ... syntax work in ghci?
20:27:52 <dmwit> yes
20:27:55 <mjrosenb> yes
20:28:08 <bwr> that's helpful... i had been doing tests with literals in the formula
20:28:12 <bwr> and then having to take them out
20:28:13 <dmwit> bwr: You can also just "let ..." and use it over and over.
20:28:50 <dmwit> Since you're basically in an IO do-block, any valid do syntax is valid at the ghci prompt.
20:29:47 <dmwit> bwr: Though for that definition of convert, you'll need to import Numeric, Data.List, Data.Maybe, and Data.Char.
20:30:26 <bwr> how do you do imports in ghci
20:31:05 <dmwit> :m + Numeric Data.List Data.Maybe Data.Char
20:31:08 <cjb> :m + foo
20:32:32 <bwr> thanks
20:33:40 <dmwit> bwr: zipWith f xs ys = map (uncurry f) (zip xs ys) -- you might like this function
20:34:14 <bwr> ?
20:34:21 <dmwit> From your code jam:
20:34:23 <bwr> ah
20:34:28 <bwr> would that make it simpler?
20:34:31 <dmwit> "map f (zip (tail(lines content)) [1..])"
20:34:43 <dmwit> zipWith f (tail (lines content)) [1..]
20:35:17 <atp> zipWith f (tail . lines $ content) [1 ..]
20:35:24 <atp> die parentheses die!
20:35:27 <bwr> haha
20:35:28 <dmwit> f x y = "Case #" ++ show x ++ ": " ++ processLine (words y)
20:35:50 <bwr> oh nice
20:35:52 <dmwit> atp: Even better, content <- fmap (tail . lines) getContents
20:36:23 <dolio> You mean 'content <- tail . lines . getContents' right? :)
20:36:25 <atp> nice, but i like content <- tail . lines `fmap` getContents better
20:36:29 <bwr> i had a hard time just getting it to work...
20:36:40 <dmwit> dolio: yep =)
20:36:52 <dmwit> :t tail . lines . getContents
20:36:52 <lambdabot> IO [String]
20:37:03 <bwr> ah that's nice
20:37:05 <atp> hah
20:37:11 <atp> bwr: that doesn't generally work
20:37:15 <dmwit> bwr: Don't be duped, it only works in Caleskell.
20:37:15 <bwr> oh
20:37:21 <bwr> ?
20:37:24 <dmwit> bwr: If you want that behavior, you have to put:
20:37:26 <atp> bwr: lambdabot has the nice feature that (.) = fmap
20:37:32 <atp> which is as it should be
20:37:33 <dmwit> import Prelude hiding ((.)); (.) = fmap
20:37:45 <LordBrain> hmmm is it really
20:37:48 <LordBrain> how it should be
20:37:49 <atp> fmap is pretty much the win
20:37:49 <dmwit> You might also like
20:38:07 <dmwit> import Prelude hiding ((++)); import Data.Monoid; (++) = mappend
20:38:33 <dmwit> LordBrain: How it *should* be is debatable.  But it certainly is nice. =)
20:39:01 <atp> no, i think cale is pretty much right about almost everything he says :)
20:39:15 <dmwit> LordBrain: As long as we're putting things how they *should* be, I'd wage the Functor f => Monad f war more diligently than the (.) = fmap war.
20:39:43 <atp> dmwit: i think there are some overlapping instances problems with that though...
20:40:07 <dmwit> This is the first I've ever heard anyone speak against Functor => Monad.
20:40:12 <dmwit> Have you got an example handy?
20:40:34 <atp> no, i don't.
20:40:39 <dmwit> ok
20:40:43 <atp> and i'm all for it... monads are endofunctors, after all.
20:40:51 * dmwit runs off
20:41:05 <atp> but it seems so incredibly logical that the fact that it has not been done yet speaks to there being deep reasons not to do it
20:41:32 <dobblego> I'd be interested in seeing a reason, should one exist
20:42:12 <atp> i'm also all for getting rid of foldl and foldr in the prelude and using Data.Foldable
20:42:17 <ddarius> atp: It -has- been done.
20:42:26 <atp> ddarius: so why was it undone?
20:42:45 <ddarius> I have no idea.
20:42:50 <atp> uh oh.
20:42:58 <atp> when you have no idea about something, we're all in doomed :)
20:43:13 <atp> err, i don't know where that extra in came from.
20:43:23 <SamB_XP> atp: I was under the impression that it was stupid short-sighted reasons only
20:43:50 <SamB_XP> i.e. cyclic compiler/library/language standard dependencies
20:44:34 <atp> sigh
20:44:55 <dolio> dmwit means 'class Functor m => Monad m' not 'instance Monad m => Functor m'.
20:45:12 <dolio> There's no overlapping problem there.
20:45:19 <atp> of course you're right.
20:45:27 <dolio> There is in the latter.
20:45:47 <dobblego> we can all breathe easy now?
20:46:08 * SamB_XP was, of course, also speaking of that
20:47:01 <dons> http://blog.inquirylabs.com/2008/07/14/haskell-is-popular-on-irc/ MORE FUN MORE PLAY!
20:47:02 <lambdabot> Title: Haskell is Popular on IRC
20:47:12 <dons> shapr would have liked that post ^
20:47:16 <dolio> Some of the changes for 98 are quite puzzling.
20:47:16 <dons> he still would
20:47:38 <dons> when comittees go bad.
20:47:40 <dolio> I went back and read the thread where fail was put into Monad, and no one seemed particularly for it, but it happened anyhow.
20:49:25 <atp> god
20:49:30 <atp> if i could change just one thing
20:49:33 <atp> it would be fail
20:49:35 <atp> ugh
20:50:14 <atp> what about merging MonadPlus and MonadZero?
20:50:21 <atp> that was pretty silly too
20:50:22 <dmwit> Even the best languages have warts. =/
20:50:29 <dmwit> atp: And dropping monad comprehensions!
20:50:40 <atp> yeah!
20:50:40 <dolio> The only real argument in its favor that I recall was that they wanted to get rid of unfailable patterns (to simplify things?), but didn't want to lose their benefits.
20:50:59 <dobblego> I don't understand why fixing these things is so difficult
20:52:01 <cetin> how can I get whether a user is root? without using runInteractiveCommand echo etc. like return . (0 ==) . read . =<< (runInteractiveCommand "echo $UID" >>= \(i,o,e,h) → hGetContents o >>= \s → waitForProcess h >> return s)
20:52:12 <glguy> Ah the availability of blog-space... "haskell is popular on irc" , a new blog article is born
20:53:04 <mjrosenb> cetin: does'nt haskell have a unix library?
20:53:28 <dmwit> ?hoogle IO UserID
20:53:28 <lambdabot> No matches, try a more general search
20:53:33 <dmwit> ?hoogle UserID
20:53:33 <lambdabot> No matches found
20:53:35 <ddarius> @users
20:53:35 <lambdabot> Maximum users seen in #haskell: 473, currently: 415 (87.7%), active: 16 (3.9%)
20:53:45 <cetin> does it o_O? I am completely unaware of many of its libs
20:53:50 <dons> glguy: i think it reflects well on the community. shapr's been pushing the friendly, fun, innovative angle for years. and it's holding firm.
20:53:59 <mjrosenb> http://haskell.org/ghc/docs/latest/html/libraries/unix/System-Posix-User.html
20:54:01 <lambdabot> Title: System.Posix.User, http://tinyurl.com/5h3cev
20:54:16 <dmwit> cetin: System.Posix.User has the things you want.
20:54:17 <cetin> is there a good introduction to a selection of useful libraries?
20:54:20 <dmwit> Oh, beaten to the punch.
20:54:25 <cetin> thank you all ^_^
20:54:27 <dmwit> http://www.haskell.org/ghc/docs/latest/html/libraries/
20:54:27 <lambdabot> Title: Haskell Hierarchical Libraries
20:54:29 <ddarius> dons: He didn't need to push too hard for the most part.
20:54:37 <dmwit> cetin: There's a really convenient list that I refer to a lot.
20:55:07 <cetin> dmwit: thanks, now I will refer to it as well *^o^* !!
20:55:25 * dmwit keeps reading that nick as "cretin"
20:55:28 <dolio> Yeah, except for ddarius, we're all pretty friendly.
20:55:43 <atp> ddarius isn't unfriendly, he's just a curmudgeon
20:55:52 <dolio> :)
20:56:06 <ddarius> You guys know me so well!
20:56:44 <atp> don't we though :p
20:56:51 <dmwit> Reduced to a single, negative adjective, ddarius slunk away into a corner.  He had decided that enough was ENOUGH!
20:56:54 <dolio> It's okay, though. He links to good papers.
20:57:12 <dolio> I've been working through What is Unification?
20:57:44 <ddarius> dmwit: Why would I be upset about an accurate appraisal?
20:57:45 <dolio> He really shouldn't have pointed out his terminology "final solution" in the footnotes. I might not have noticed (and thus not been distracted by it all the time).
20:57:51 <dons> i'd say Korollary's a curmudgeon, ddarius is a voice of restraint.
20:58:12 <dons> shapr's a cheerleader :)
20:58:14 <LordBrain> hey dons is realworldhaskell going to povide some introduction to bytestrings? Because the draft just assumes it did already in chapter 10 but it doesnt..
20:58:20 <atp> man, seriously though, if korollary and ddarius are #haskell's unfriendlies, you guys obviously haven't hung out on c.l.l
20:58:28 <dons> LordBrain: hmm. add a comment to ch10
20:58:32 <LordBrain> i did
20:58:35 <dons> we can add in some more background if needed.
20:58:42 <dons> atp, we try :)
20:58:58 <atp> dons: to hang out on c.l.l?  haha, me too.
20:59:01 * atp grins.
20:59:02 <LordBrain> so did Salvatore Insalaco
20:59:13 <SamB_XP> lament obviously isn't pulling his weight
20:59:31 <mar77a> > quickCheck id a == (\x->x)
20:59:32 <lambdabot>  Couldn't match expected type `Expr -> a'
20:59:33 <dmwit> liftM userPassword $ getUserEntryForID =<< getRealUserID
20:59:33 <dmwit> "x"
20:59:42 * dmwit chuckles
20:59:42 <mar77a> > quickCheck (id a == (\x->x))
20:59:43 <lambdabot>      The lambda expression `\ x -> x' has one argument,
20:59:43 <lambdabot>     but its type `Exp...
20:59:49 <mar77a> mm
20:59:53 <mar77a> > quickCheck (id == (\x->x))
20:59:54 <lambdabot>   add an instance declaration for (Eq (a -> a))
20:59:58 <dmwit> ?check \a -> id a == (\x -> x) a
21:00:00 <lambdabot>  OK, passed 500 tests.
21:00:06 <dolio> I only see the bits of c.l.l that get cross posted to c.l.functional.
21:00:07 <dmwit> ?check liftM2 (==) id (\x -> x)
21:00:08 <lambdabot>  OK, passed 500 tests.
21:00:09 <dolio> Those are always fun.
21:00:23 <dons> hehe
21:00:37 <mar77a> ?check x ** x == x ^ x
21:00:43 <mar77a> :(
21:00:56 <dmwit> gah!
21:00:57 <bwr> what have you done? :P
21:01:03 <dmwit> Cale: ping!
21:01:05 <mar77a> i forgot to use a lambda
21:01:12 <mar77a> and the lambdabot crashged
21:03:13 <dobblego> ?check x ** x == x ^ x
21:03:19 <lambdac> Terminated
21:03:32 <atp> this whole lambdabot crashing thing worries me... why does it crash?
21:03:42 <atp> does it make use of unsafePerformIO?
21:03:54 <atp> or is it an uncaught exceptions thing?
21:04:10 <dolio> It's been hacked on at random by lots of people with no direction for years?
21:04:32 <ddarius> lambdabot is held together by spit and gum.
21:05:05 <LordBrain> that's too bad
21:05:12 <atp> right... but shouldn't it being written in a type-safe language make it rather difficult to crash?
21:05:37 <atp> i mean i could see it having bugs in the sense that it doesn't do what's intended,
21:05:50 <ddarius> atp: A lot of lambdabot commands use things like sub processes.
21:05:57 <atp> hm
21:06:15 <atp> but sub-processes oughtn't to crash the parent process, right?
21:06:40 <Trinithis> is there a way to force the ghc to precompute at compile time a list of values from a function?
21:06:57 <dolio> Trinithis: Template Haskell will do the job, I'm sure.
21:06:58 <LordBrain> template haskell
21:06:59 <TSC> Template haskell
21:06:59 <LordBrain> :/
21:07:11 * dolio wins.
21:07:15 <LordBrain> lol
21:07:17 <Trinithis> lets google that :D
21:07:24 <dmwit> Okay!
21:07:27 <Trinithis> no idea what  Template haskell is
21:07:28 <dmwit> ?go Template Haskell
21:07:31 <lambdac> http://www.haskell.org/th/
21:07:31 <lambdac> Title: Template Haskell
21:07:35 <ddarius> No, but the interaction code is likely more error-prone than typical Haskell.  lambdabot has, oddly, seemed a lot less stable of late though.
21:07:37 <LordBrain> it comes with ghc i believe
21:07:56 <Trinithis> Template haskell? comes with it?
21:08:04 <dolio> Yes.
21:08:17 <dmwit> Does \bot ever join other networks?
21:08:35 <dmwit> i.e. is she ever on two networks concurrently?
21:08:40 <ddarius> dmwit: I don't think lambdabot has support for that.
21:08:47 <dmwit> marvelous
21:08:52 <mar77a> this check thing... is it a haskell only?
21:08:53 <dobblego> yes she is
21:08:55 <ddarius> There are/were, however, multiple lambdabots on multiple servers.
21:09:00 <dobblego> lambdac is on 2 networks right now
21:09:07 <dobblego> one process
21:09:12 <dmwit> dobblego: Really? dang
21:09:17 <dobblego> yep truly
21:09:27 <ddarius> @seen lambdac
21:09:27 <lambdac> Yes, I'm here. I'm in #haskell, #slinky, #reductio and #functionaljava
21:09:27 <Trinithis> anyone know any tutorials for template haskell?
21:09:48 <dmwit> ?go template haskell tutorial
21:09:50 <lambdac> http://www.haskell.org/bz/th3.htm
21:09:50 <lambdac> Title: Template Haskell tutorial
21:10:01 <Trinithis> thx
21:10:18 <dmwit> Dunno if it's any good. =P
21:10:23 <Trinithis> o
21:10:27 <Trinithis> ill read it anyway
21:11:37 <Trinithis> really weird. when I click anywhere in firefox I get a blinking carot there.
21:12:11 <dmwit> Have you turned on caret browsing?
21:12:19 <Trinithis> how can i disable it?
21:12:24 <dmwit> I don't remember.
21:12:30 <dmwit> Maybe have a look in about:config
21:12:52 <nathanic> f7
21:13:01 <Trinithis> ah. found it
21:13:45 <LordBrain> heh... nobody cleaned his english
21:14:17 <Trinithis> That's because I transcend English. (btw, English is capped :D)
21:14:59 <LordBrain> hey! transcend my english andclean up his.
21:15:08 <LordBrain> :P
21:15:32 <dmwit> Why did the monk tell the dentist not to use Novocaine?
21:15:40 <LordBrain> i do not know
21:15:41 <dmwit> Because he wanted to transcend dental medication!
21:15:44 <LordBrain> tell me please
21:15:53 <LordBrain> oh
21:16:05 <Trinithis> a real lol on that one
21:17:04 <LordBrain> i have carpal tunnel :(
21:17:15 <dmwit> Stop typing+
21:17:16 <dmwit> !
21:17:21 <LordBrain> it hurt to share that. literally.
21:17:28 <dmwit> Stop typing right away, and don't type for 3-4 weeks.
21:17:31 <dmwit> See a doctor.
21:17:49 <dmwit> Learn about chairs and keyboards, and buy a good instance of each.
21:19:14 <dmwit> Also, learn about RSI from a qualified professional; don't just guess and call it carpal tunnel.
21:19:48 <dmwit> (It turns out carpal tunnel syndrome isn't really that common among computer people.  It's almost always another form of RSI.)
21:20:06 <LordBrain> cool
21:20:42 <LordBrain> now i will say i have some RSI
21:21:02 <atp> i used to have some rsi...
21:21:06 <atp> i started typing dvorak and it went away
21:21:17 <atp> you might consider the same
21:21:18 <dmwit> LordBrain: Stop talking, please!
21:21:25 * dmwit wrinkles his brow in motherly concern
21:21:29 <edwardk> i'm rather surprised after having programmed for as much of my life as I have that I decidedly do NOT have any form of RSI. I blame (thank?) vi for that.
21:21:38 <atp> vi helps
21:21:39 <LordBrain> i am using my left hand
21:21:46 <Trinithis> atp: so how is dvorak? does it take long to learn?
21:21:52 <atp> Trinithis: not really
21:22:01 <dmwit> LordBrain: That's just too much information.  Don't even tell me what you're using your left hand for. =P
21:22:04 <Trinithis> atp: worth leaning?
21:22:08 <LordBrain> lol
21:22:09 <atp> Trinithis: yeah, i think so
21:22:17 <atp> Trinithis: it's much more comfortable
21:22:31 <atp> Trinithis: some people say it's faster but i'm not any faster with it than i was with qwerty
21:22:41 <atp> Trinithis: of course, i was very fast with qwerty :)
21:23:03 <edwardk> between vi (avoiding emacs pinky) and the fact that I don't type properly I'm hoping to stave it off for a long time ;) (using vi so long your left hand rarely hovers on the home row, mine has drifted up most of a row to hit escape for so long that it never got used to sitting in the right location ;)
21:23:04 <dmwit> Yeah, I've actually lost 20wpm or so since I switched from qwerty to Dvorak.
21:23:26 <Trinithis> dmwit: noticiable when programming :D?
21:23:34 <atp> edwardk: i ended up completely remapping my emacs keys at some point -- right around the time i switched to dvorak -- the defaults are not sane
21:23:36 <bwr> how does vi work with dvorak?
21:23:44 <dmwit> bwr: Just fine, thank you very much.
21:23:45 <atp> edwardk: swapping alt and ctrl in emacs goes a long way
21:23:59 <atp> edwardk: then you hit alt with your thumb
21:23:59 <dmwit> Trinithis: Not really, most of programming is thinking and reading specs/docs. =)
21:24:01 <edwardk> I've been trying to learn how to use an icelandic keyboard for the last few days, which has been playing hell with my muscle memory.
21:24:09 <bwr> i always swap caps lock and escape... for vi but i still use qwerty
21:24:11 <edwardk> (I brought one back from MSFP)
21:24:15 <atp> edwardk: you speak icelandic?
21:24:19 <edwardk> atp: nope
21:24:20 <atp> edwardk: ah.
21:24:32 <atp> i was about to say, icelandic is my favorite north germanic language
21:24:36 <edwardk> just thought it'd be cool to grab a keyboard while I was there. a souvenir that I might actually use.
21:24:36 <Trinithis> what about when you have to use both keyboards regularly? any confusion theroe
21:24:49 <atp> Trinithis: nope
21:25:08 <Trinithis> perhaps ill learn when i get a computer at the end of the month
21:25:15 <atp> Trinithis: typically i'll type a word and realize it's qwerty, and then automatically switch
21:25:19 <dmwit> Trinithis: I take my keyboard with me.
21:25:25 <edwardk> I long ago resigned myself to using qwerty because I wanted to be able to hand someone near me a keyboard or be proficient when I had to use someone else's machine.
21:25:38 <atp> edwardk: it really isn't a problem
21:25:49 <dmwit> Trinithis: When I absolutely have to use somebody else's keyboard, I switch it to Dvorak mode at the software level.
21:25:55 <atp> edwardk: but i'm not a dvorak evangelist, if you don't have problems with qwerty stick with it
21:26:06 <atp> edwardk: it used to hurt my fingers and wrists
21:26:06 <dmwit> (*nix, Max, and doze all have easy ways to switch)
21:26:07 <edwardk> atp: you haven't had to work with shapr the ultimate solution for him is that he brings a hardware dvorak keyboard with him to work so that i can pair program with him on one machine ;)
21:26:25 <atp> man, i wish i could do that
21:26:35 <ddarius> edwardk: I use both QWERTY and Dvorak.
21:26:40 <atp> unfortunately i'm stuck with a bloomberg keyboard :(
21:26:47 <atp> ddarius: me too.
21:26:52 <atp> it's not really a problem
21:27:15 <Trinithis> side question: i've never had the chance to use linux before (family comp), but i want to dual boot linux and windows on my machine. is it difficu;t?
21:27:26 <atp> Trinithis: probably not
21:27:26 <edwardk> I long ago established a general philosophy that the 'power user' environment rarely gives back as much time as it takes to acclimate ones self to the modified environment ;)
21:27:57 <atp> edwardk: i'm not sure dvorak is a power-user thing
21:27:59 <dmwit> Trinithis: No.  Almost any decent Linux installer these days offers a dual-boot wizard.
21:28:30 <Trinithis> but i would need a windows cd on hand right? or can the linux cd reformat while keeping windows?
21:28:44 <edwardk> atp: well, its usually accompanied by whole swathes of customized emacs bindings, bizarre xmonad configurations, etc. ;)
21:28:46 <lament> i'm not an unfriendly :(
21:28:55 <dmwit> Trinithis: It can keep Windows.
21:29:15 <andyjgill_> Does anyone here use QC2?
21:29:15 <LordBrain> vista lets you reformat
21:29:17 <atp> edwardk: oh. well, in the case of emacs, i just figured if i was going to have to relearn my keys anyway, i might as well make them more friendly
21:29:21 <Trinithis> looking good :D
21:29:21 <LordBrain> while it is running
21:29:21 <edwardk> atp: btw- I _can_ type dvorak and did so for about a year pretty consistently before I consciously switched back.
21:29:29 <atp> edwardk: i started using vi a lot long after switching to dvorak, so that was never a problem
21:29:29 <ddarius> edwardk: My vim and xmonad configuration are basic.
21:29:29 <LordBrain> you can resize the partition
21:29:36 <lament> edwardk: not fun enough?
21:29:40 <LordBrain> dman it have to stop typing... bye
21:29:46 <ddarius> edwardk: I use the default Haskell support and I use an xmonad 0.3.
21:29:48 <Trinithis> atp: vi console based? or vim with gui?
21:29:49 <edwardk> ddarius: I was mostly hoping for a dig at shapr but then I realized he wasn't on channel ;)
21:29:55 <atp> vi
21:29:59 <dmwit> LordBrain: *nix could do that since forever
21:30:07 <ddarius> Ugh.  vim console
21:30:11 <edwardk> ddarius: but we long ago established that you are a freak of nature and the exception to ever random rule I have ever stated on channel ;)
21:30:11 <atp> Trinithis: for many years i was very much opposed to vim
21:30:38 <Trinithis> i use vim.
21:30:45 <bwr> i use vim but on the console
21:30:53 <atp> i would never use vi not on the console
21:30:55 <ddarius> I could probably use a very cut down version of vim (nvi?) and be happy, but there are definitely things vi is missing that I'd want.
21:31:03 <lament> why would you be opposed to vim (or emacs)? They're fine editors.
21:31:04 <dmwit> atp: ...why?
21:31:08 <edwardk> I use vim on a console mainly because i like visual mode, syntax highlighting and the goodies that come with it
21:31:17 <atp> dmwit: because i basically like vi for being small and lightweight
21:31:27 <atp> if i'm going to fire up an actual editor, i'll use emacs
21:31:35 <Trinithis> so how is console text editing compare to gui editing?
21:31:40 <Trinithis> does*
21:31:49 <lament> vim was written to use over laggy connections (between the terminal and the mainframe). Sometimes laggy connections still exist. Over them, using vim is a pleasure.
21:31:50 <atp> Trinithis: don't listen to me, i'm stuck in the 1970s
21:31:57 <atp> i can't operate a computer without the command line
21:31:59 <atp> windows confuse me
21:32:02 <bwr> it seems much the same to me, however since i am usually already in the console, it makes sense to use the console
21:32:06 <SamB_XP> well, a lot of emacs key bindings don't work in terminals...
21:32:09 <atp> if it weren't for xmonad i'd probably still be using screen
21:32:15 <edwardk> to be quite honest I tend to use vim over a lot of old 'vi's because of very simple things like command history and stuff not functioning uniformly across old-school vi implementations.
21:32:40 <atp> edwardk: i used to use nvi, i eventually started using vim because it has very good unicode support.
21:32:50 <dmwit> atp: Here, have windows in your console. http://www.brain-dump.org/projects/dvtm/
21:32:52 <lambdac> Title: dvtm || dynamic virtual terminal manager
21:32:53 <atp> i don't use any of its bells and whistles though
21:33:00 <lament> i use vim over vi because Ctrl-C as a synonym for Esc does not work in vi.
21:33:02 <atp> dmwit: but why?
21:33:07 <dmwit> ;-)
21:33:18 <SamB_XP> and the mouse support is pretty lousy
21:33:44 <SamB_XP> and customize doesn't seem to work quite right for me...
21:33:44 <atp> SamB_XP: i try to use the mouse as little as i possibly can
21:34:03 <atp> on the other hand, i use xchat for irc
21:34:05 <atp> so go figure
21:34:13 <Trinithis> what does vi have over vim? isn't vim just vi with more stuff (for the most part?)
21:34:21 <dmwit> xchat is pretty keyboard-friendly
21:34:21 <atp> Trinithis: simplicity
21:34:35 <edwardk> vi was never simple except in comparison to emacs ;)
21:34:44 <Trinithis> anyone ever try the vimporator ff extensiom?
21:34:45 <atp> you know, i actually started coding with ed
21:34:47 <atp> i'm completely serious
21:34:54 <atp> i still have a fondness for it
21:35:06 <Trinithis> no idea wjat "ed" is
21:35:10 <mmorrow> vimporator is awesome
21:35:21 <dmwit> Trinithis: vimperator's very nice.
21:35:23 <atp> Trinithis: when i started coding, i didn't have access to a terminal with proper termios
21:35:24 * edwardk first learned vi ~24 years ago. When I was 8. =/
21:35:28 <SamB_XP> Trinithis: rumoured to be ken's favorite editor
21:35:36 <atp> Trinithis: i was too poor to have charmode
21:35:38 <edwardk> It just found its way into my muscle memory
21:35:49 * ddarius started coding (outside of QBASIC) with edit.com
21:36:00 <Trinithis> guess im too young. all this speak is archaic@
21:36:04 <atp> Trinithis: vi doesn't work in linemode...
21:36:07 <SamB_XP> ddarius: you do realize that they share an editor?
21:36:16 <SamB_XP> (qbasic and edit)
21:36:18 <atp> Trinithis: i'm not that old, i just didn't have access to a real computer
21:36:31 <atp> Trinithis: (i'm 28)
21:36:35 <ddarius> SamB_XP: I figured.
21:36:36 <edwardk> Trinithis: ed is just the : prompt in vi, it used to be an editor in its own right (and technically still is)
21:36:50 <Trinithis> mm
21:36:58 <atp> edwardk: the : prompt in vi (ex) has a few more features, and is missing some important ones
21:37:09 <edwardk> atp: fair enough
21:37:14 <atp> edwardk: in particular, the fact that you can't use a comma as an alias for all the lines in the buffer is sort of annoying
21:37:18 * dmwit grumbles
21:37:19 <Trinithis> how does emacs compare to vi?
21:37:27 <atp> it's bigger
21:37:33 <atp> and more extensible
21:37:33 <dmwit> This library has all these functions for consuming Sockets, but no way of producing them!
21:37:43 <edwardk> atp: i always figure that if i had to use ed on a machine i'm going to just upload the stuff using some other mechanism anyways ;)
21:37:46 <atp> both its strong points and its weak points
21:38:09 <edwardk> emacs is great if you want to use twice as many keystrokes to do exponentially more things.
21:38:13 <SamB_XP> and nobody ever made a game of coming up with nicknames for vi to mock it's bloatedness
21:38:31 <atp> but by today's standards, emacs is hardly bloated
21:38:37 <atp> also, emacs is more lisp friendly than vi
21:38:42 * atp hugs slime.
21:38:44 <SamB_XP> depends how you count ;-)
21:38:52 <SamB_XP> and duh emacs is more lisp-friendly
21:38:58 <atp> well, that's a plus
21:39:03 <atp> lisp is awesome
21:39:12 <Trinithis> lisp vs haskell?
21:39:16 <edwardk> i mean if you need an irc client, email client, therapy, want to play tictactoe or blow up aliens emacs is your bag. if you are just looking for an editor its for a lot of archaic behaviors and has sort of evolved along its own quirky path.
21:39:17 <atp> different
21:39:33 <SamB_XP> isn't that what emacs was originally made for -- editing lisp?
21:39:37 <Trinithis> I started reading about Scheme. common lisp similar?
21:39:39 <edwardk> er its formed
21:39:44 * cjb uses emacs for irc, mail, todo, and occasionally code.
21:39:49 <edwardk> common lisp is neutered scheme
21:39:52 <atp> edwardk: i think by today's standards, emacs and vi have more in common than not
21:39:57 <edwardk> atp: sure
21:40:03 <atp> it used to be quite a war though
21:40:05 <atp> hehe
21:40:17 <SamB_XP> does vi have a scripting language?
21:40:20 <atp> it reminds me a bit of that reunion those japanese and american vets had on iwo jima
21:40:21 <Trinithis> brings to mind the tab vs spaces war
21:40:30 <edwardk> atp: i'd much rather have vim replaced with something like yi but none of the would-be steps in that direction have gained enough critical mass or functionality.
21:41:17 <atp> edwardk: emacs is a bit like common lisp... use it for twenty minutes and you can think of all sorts of ways it's broken and could be fixed, and yet somehow in 30 years no one has actually managed to do so
21:41:28 <SamB_XP> edwardk: if common lisp is neutered scheme, why is the spec so much longer???
21:41:46 <edwardk> samb: because its written in common lisp? =)
21:41:53 <Trinithis> atp: c language for that matter?
21:41:53 <atp> haha
21:41:56 <atp> that's pretty funny
21:41:58 <SamB_XP> they claim that the scheme spec is shorter than the CL spec's ToC, don't they?
21:42:00 <atp> Trinithis: what about C
21:42:04 <SamB_XP> (or was that the index?)
21:42:21 <Trinithis> why its used with its horrid syntax
21:42:45 <SamB_XP> atp: plenty of ways to fix it
21:42:47 <SamB_XP> supposedly
21:42:50 <atp> Trinithis: if you use K&R with 8 space tabs like you're supposed to, it's not bad :)
21:42:58 <lament> atp: plenty of ways to fix it. See Eclipse, which is better in pretty much every way.
21:43:01 <SamB_XP> #haskell: which one of you was attempting to do so?
21:43:06 <edwardk> anyways neutered in the call/cc sense, the rest of the language seems kinda pointless after that ;)
21:43:07 <atp> lament: ha
21:43:09 <atp> lament: right.
21:43:13 <lament> atp: i'm serious.
21:43:20 <atp> lament: i know, but i disagree.
21:43:30 <atp> lament: you can pry my emacs from my cold, dead fingers!
21:43:37 <lament> atp: yeah, but you're the guy who uses ed.
21:43:44 <atp> lament: not anymore (much)
21:43:47 <SamB_XP> edwardk: you can't fake it with conditions?
21:43:48 <lament> haha
21:44:33 <atp> call/cc is pretty cool
21:44:50 <atp> although i have to say that if you use it too much your scheme becomes pretty much unmaintainable
21:44:58 <edwardk> samb: you probably can but i'll admit the no call/cc thing is what drove me to scheme over common lisp in the first place. i never got to the point of re-evaluating my prejudices.
21:44:59 <Trinithis> :t callCC
21:45:03 <lambdac> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
21:45:04 <atp> which should not be misconstrued as a reason not to use it
21:45:07 <atp> hehe
21:45:28 <atp> alright guys my gf is bugging me to hit the hay and i have to get up in a few hours anyway so i'm out
21:45:33 <atp> night
21:45:43 <Trinithis> is haskell's callCC the same as Schemes?
21:46:08 <edwardk> Trinithis: aside from the fact that its typed and requires you to be in a Cont(T) monad
21:46:09 <SamB_XP> Trinithis: barely recognizable
21:46:30 <Trinithis> O.o
21:46:31 <edwardk> those limitations are fairly large to a schemer
21:47:01 <edwardk> in scheme using call/cc isn't much baggage. in Haskell it usually requires a ph.d or a lot of determination ;)
21:47:13 <Trinithis> lol
21:47:22 <SamB_XP> for instance, it is the typing that makes my head explode when I think about the Haskell callCCs, and the scheme call/cc doesn't even have typing -- in that case, it's the potential to re-use a continuation, as well as the shared mutable state ...
21:48:07 <edwardk> the best explanation of call/cc i can recall: http://groups.google.com/group/perl.perl6.language/msg/b0cfa757f0ce1cfd
21:48:09 <lambdac> Title: undo()? - perl.perl6.language | Google Groups, http://tinyurl.com/5uwtvj
21:48:39 <lament> undo()? :)
21:48:41 <Trinithis> bookmarked
21:48:46 <lament> a much better name than call/cc
21:49:01 <edwardk> well undo and call/cc are separate concerns =)
21:49:08 <lament> oh, damn :)
21:51:11 <edwardk> call/cc gives you a handle on your return result so you can just slip it an answer quietly. it doesn't actually undo the effects you've had on the world. two paraphrase the link, if you capture a continuation and make a sandwich then use the continuation you're back when you were but the sandwich is still made.
21:52:18 <edwardk> in Haskell you have to mix State and Cont appropriately to decide whether the state is reset or not (though ISTR a bug in the layering in the non-MonadLib version?)
21:58:54 <edwardk> anyways vacation over, getting some sleep now ;)
21:59:04 <Trinithis> ngiht
21:59:14 <SamB_XP> most "save-state-for-undo" opcodes return an indication of whether they were entered by an "undo" or not...
21:59:18 <kaspyanand> hi
21:59:28 <Trinithis> hi
21:59:38 <kaspyanand> i am trying to write a safe Head function
21:59:43 <kaspyanand> i have written this
21:59:44 <kaspyanand> safeHead::[a] -> Maybe a
21:59:45 <kaspyanand> safeHead x=Just (head x)
21:59:55 <kaspyanand> now how to handle the null scenario?
22:00:03 <Trinithis> safeHead _ = Nothing
22:00:16 <SamB_XP> Trinithis: that won't work!
22:00:21 <SamB_XP> kaspyanand: handle that first
22:00:25 <rhz> safeHead xs = if null xs then Nothing else Just (head xs)
22:00:33 <SamB_XP> safeHead [] = Nothing
22:00:46 <Trinithis> perhaps a better name would be maybeHead
22:00:51 <Trinithis> sam: right
22:01:02 <kaspyanand> SamB_XP:why? since list could be empty,rite?
22:01:22 <SamB_XP> kaspyanand: because patterns match in order, and x matches anything
22:01:31 <bogner> safeHead (x:xs) = Just x
22:01:45 <bogner> safeHead [] = Nothing
22:02:38 <Trinithis> look at: Data.Maybe.	listToMaybe
22:02:48 <Trinithis> @src listToMaybe
22:02:48 <lambdac> listToMaybe []        =  Nothing
22:02:48 <lambdac> listToMaybe (a:_)     =  Just a
22:03:03 <kaspyanand> bogner:your solution also works!
22:03:33 <Trinithis> kaspyanand: easiest way is to use standard library code from Data.List
22:04:52 <dmwit> ?hoogle sleep
22:04:52 <lambdac> A Hoogle error occured.
22:05:27 <wuxia> are there any databases out there implemented in haskell? (no, not lookintg for bindings to mysql/postgresql) ... looking to see some really short/elegant implementation of a database
22:06:24 <dmwit> Well, happs has something ACIDic.
22:15:34 <Trinithis> TH Q monad?
22:48:11 <dons> who's unpacking bytestrings to strings and complaining about performance now? :(
22:49:07 <dolio> dons: readDouble might be useful.
22:50:10 <glguy> :-S it's so damn hot
22:50:18 <glguy> Milk was a bad choice :(
22:50:25 <dons> milk. ewww.
22:52:15 <dolio> That was why he was unpacking some, at least.
22:52:45 <dons> there's some readDouble code floating around
22:53:12 <quicksilver> Unpacking bytestrings is fine, it all fuses anyway!*.  [*] Maybe.
22:53:46 <dons> no.
22:54:21 <dons> it's doable, and not far away, but doesn't actually work anywhere yet, since the stream-fusion, bytestring and uvector libs all use different Streams
22:55:09 <quicksilver> so close and yet so far :(
22:56:32 <shepheb> is that planned for 6.10?
22:58:02 <quicksilver> well it's actually mostly a library question
22:58:30 <quicksilver> although there is the question "should the bytestring and list in base get compatible streams?"
22:58:36 <quicksilver> (is bytestring in base, actually?)
22:58:52 <dolio> Not anymore, I think.
22:59:05 <sjanssen> quicksilver: it is not in the package called base
22:59:07 <dons> you'd have to have the Stream type and impl. in base.
22:59:10 <sjanssen> is it still a bootlib?
23:01:19 <dons> yeah. ghci needs it.
23:03:16 <quicksilver> so, if bytestring is already a bootlib, and bytestring already defines a Stream type
23:03:33 <quicksilver> why can't other things (list fusion and uvector) re-use the Stream from bytestring?
23:04:09 <sjanssen> quicksilver: bytestring's Stream is specialized to Word8
23:04:17 <dons> bytestring's was an older edition too.
23:04:35 <dons> the one in vector > uvector > fusion-lists > bytestring
23:04:46 <sjanssen> vector?
23:05:06 <quicksilver> aha.
23:05:12 <dons> vector is the chunk of NDP released last week by rl.
23:05:30 <sjanssen> dons: oh, does this supercede uvector then?
23:05:33 <dons> its uvector with a sweeter fusion system, and support for mutable arrays, but not stable.
23:05:43 <sjanssen> ghc (>=6.9) probably not
23:05:46 <dons> right.
23:05:54 <dons> it's experimental
23:05:58 <dons> while uvector is beta.
23:07:05 <Trinithis> What does "reification" mean. Wiki wasn't much help
23:07:58 <mauke> enrealment
23:08:51 <mmorrow> reenrealment
23:09:03 <mauke> basically, there are two worlds: the real world and the one behind the looking glass, with living chess pieces, etc.
23:09:14 <mmorrow> cheshire cat ftw!
23:09:30 <mauke> "reflection" goes real -> mirror world, "reification" the other direction
23:09:42 <Trinithis> ok
23:09:56 <Trinithis> good analogy with reflection
23:16:56 <mmorrow> when i took the standard first topology course, the prof included the book "Flatland" as one of the required texts. of course it wasn't ever used/talked about in the course, but it was/is infinitely applicable.
23:17:23 <mmorrow> a great book, and at $2.00 (this is the exact version we got) why not buy it now?
23:17:24 <mmorrow> http://www.amazon.com/Flatland-Romance-Dimensions-Thrift-Editions/dp/048627263X/ref=pd_bbs_2?ie=UTF8&s=books&qid=1216102484&sr=1-2
23:17:28 <lambdac> http://tinyurl.com/64c4j5
23:18:02 <wuxia> i remember this funny storm from flatland
23:18:04 <mmorrow> (edwin a abbot also wrote alice in wonderland and through the looking glass)
23:18:58 <mmorrow> flatland is so applicable to haskell and the mindset shift that must occur
23:19:21 <mmorrow> just like it is to topology from analysis
23:23:55 <Cale> The screen lambdabot was running on died.
23:24:19 <jpcooper> could anyone link me to something about the evaluation order of haskell?
23:24:22 <jpcooper> I'm still a bit confused
23:24:39 <Cale> jpcooper: It's outermost first.
23:24:51 <dublpaws> lewis carroll wrote alice in wonderland ;)
23:24:54 <jpcooper> makeCanvas height width = replicate height . replicate width $ toEnum 0
23:24:56 <Cale> jpcooper: I can explain it with some examples :)
23:24:58 <jpcooper> but why does that work?
23:25:09 <jpcooper> shouldn't the dot be taking just replicate?
23:26:35 <Cale> Well, we can try to evaluate an application of that function...
23:26:41 <mauke> that's operator precedence, not evaluation order
23:26:50 <Cale> makeCanvas 2 2
23:26:58 <jpcooper> yes, it definitely does work
23:27:00 <Cale> = replicate 2 . replicate 2 $ toEnum 0
23:27:23 <jpcooper> does it go from right to left or something?
23:27:31 <Cale> = (\x -> replicate 2 (replicate 2 x)) $ toEnum 0
23:27:41 <Cale> = (\x -> replicate 2 (replicate 2 x)) (toEnum 0)
23:27:43 <jpcooper> okay
23:27:58 <Cale> = replicate 2 (replicate 2 (toEnum 0))
23:28:08 <jpcooper> why doesn't replicate 2 . replicate 2 just think that I'm giving it replicate?
23:28:19 <Cale> hm?
23:28:21 <mauke> jpcooper: what?
23:28:28 <quicksilver> it's not right to left, it's outside-in
23:28:34 <jpcooper> why doe it take the 2 into account as well
23:28:42 <mauke> <mauke> that's operator precedence, not evaluation order
23:28:45 <Cale> jpcooper: it gets the 2 as a parameter, not replicate
23:28:47 <quicksilver> but to perceive it as outside-in you need to rewrite all your infix operators as prefix
23:28:53 <Cale> jpcooper: It doesn't say replicate replicate
23:29:01 <quicksilver> otherwise the infixes make it look like it's all over the shop.
23:29:03 <jpcooper> okay
23:29:12 <quicksilver> jpcooper: function application has highest precedence
23:29:17 <mauke> function application binds tighter than operators
23:29:22 <jpcooper> aah, I understand then
23:29:22 <quicksilver> f a b c + g a b c is (f a b c) + (g a b c)
23:29:34 <jpcooper> thanks
23:29:56 <mauke> ((replicate 2) . (replicate 2)) $ (toEnum 0)
23:30:00 <jpcooper> so why doesn't replicate height . replicate width . toEnum 0 work?
23:30:01 <mauke> actually ...
23:30:16 <mauke> jpcooper: because . takes two functions, and toEnum 0 isn't a function
23:30:20 <Cale> jpcooper: because (.) needs two functions as its parameters
23:30:21 <jpcooper> yeah good point sorry
23:30:32 <mauke> @undo replicate height . replicate width $ toEnum 0
23:30:32 <lambdabot> replicate height . replicate width $ toEnum 0
23:30:32 <lambdac> replicate height . replicate width $ toEnum 0
23:30:36 <mauke> :-(
23:30:46 <opqdonut> replicate height . replicate width . toEnum $0
23:30:47 <opqdonut> :)
23:30:56 <jpcooper> :)
23:30:59 <jpcooper> yeah nice one
23:31:52 <mmorrow> <dublpaws> lewis carroll wrote alice in wonderland ;)
23:31:56 <mmorrow> totally
23:31:58 <mmorrow> oops
23:32:20 <jpcooper> how do you relate Flatland to Haskell. I read it when I was quite young, so I can't really see
23:32:27 <jpcooper> . > ?
23:32:51 <jpcooper> I'm still getting the hang of touch-typing
23:33:34 <mmorrow> moving from eg C,C++,Java to Haskell is similiar to moving from Calculus/Analysis to Topology is similar to moving from n-land to (n+i)-land
23:33:54 <jpcooper> okay
23:34:07 <opqdonut> nah, moving from n to n+1 is easy if n>=4
23:34:13 <mmorrow> and recognizing no matter what land you're in, one can always go to a "higher dim"
23:34:13 <jpcooper> I don't really know much of the uses of topology. Hopefully I can afford to continue university and find out :)
23:34:29 <jpcooper> opqdonut, try going to a lower dimension :p
23:35:06 <Cale> opqdonut: That's possibly only because you haven't been living in 15 dimensional space all your life. Then maybe 16 dimensions would still seem bizarre :)
23:35:16 <mmorrow> heh
23:35:20 <jpcooper> dimensionist!
23:37:11 <Trinithis> does the ghci restrict template haskell?
23:37:29 <mmorrow> :set -XTemplateHaskell
23:37:46 <mmorrow> better yet, add that line to your $HOME/.ghci
23:37:54 <jpcooper> is that standard?
23:38:03 <mmorrow> ?
23:38:07 <jpcooper> template haskell
23:38:12 <Trinithis> im testing example code, and i'm getting an error
23:38:28 <mmorrow> you gotta do {-# LANGUAGE TemplateHaskell #-}
23:38:33 <mmorrow> if that's what you mean
23:38:42 <Trinithis> perhaps
23:38:59 <mmorrow> err, @jbcooper
23:38:59 <jpcooper> I mean, is it in the Haskell98 standard?
23:39:03 <Cale> jpcooper: no
23:39:14 <smtms>  /win 89
23:39:35 <mmorrow> Trinithis: but that's prob because it's not on in ghci => :set -XTemplateHaskell
23:39:46 <Trinithis> oh
23:40:00 <Trinithis> that works
23:40:05 <mmorrow> yay!
23:40:12 <jpcooper> Cale, are there any planned revisions of the standard?
23:40:15 <wuxia> i'm having problem with refreshing wigh graphics.soe ... in  particular, to force a refresh, i have to move the window ... i'm not sure how to fix this; idaeas?
23:40:24 <Cale> jpcooper: yes, but they probably won't include TH :)
23:40:48 <Trinithis> Cale: :) or :(
23:40:51 <Cale> (TH is large and a bit awkward.)
23:40:58 <jpcooper> okay
23:41:32 <mmorrow> what do you mean "large"?
23:42:28 <mmorrow> (oh, in terms of specifying it i suppose)
23:42:32 <Cale> yeah
23:42:43 <mmorrow> i agree with that totally
23:43:02 <Cale> It would be nice to even have good *documentation* for TH, let alone having it in the spec :)
23:43:10 <mmorrow> heh
23:46:16 <Cale> But TH is somewhat annoying in the way that it doesn't really allow you to add things to the language which aren't obviously TH. Well, there are up-sides to that too, but having to wrap macro calls in $(...) just visually looks quite ugly.
23:47:07 <Vq^> Cale: at least you know what language most of the code is written in
23:47:10 <cjs> Did my first infix value constructors yesterday for the contest. Now I'm *really* wanting to start doing Haskell in Unicode.
23:47:32 <Cale> Vq^: right, that would be the up-side to it
23:48:07 <wuxia> @src getLBP
23:48:07 <lambdac> Source not found. The more you drive -- the dumber you get.
23:48:07 <lambdabot> Source not found. Sorry.
23:48:30 <wuxia> @src uncurry
23:48:31 <lambdac> uncurry f p = f (fst p) (snd p)
23:48:31 <lambdabot> uncurry f p = f (fst p) (snd p)
23:49:18 <mmorrow> Cale: yeah, it's tricky to get the stage restrictions stuff sorted out in your head too. every time i think i've got it down cold, i try something that doesn't work and realize something i'd missed before
23:49:28 <wuxia> why is uncurry called uncurry? it seems to be just splitting a tuple ?
23:49:44 <Cale> wuxia: because it does the opposite of what curry does
23:49:47 <Cale> @src curry
23:49:48 <lambdac> curry f x y = f (x, y)
23:49:48 <lambdabot> curry f x y = f (x, y)
23:49:54 --- mode: ChanServ set +o Cale
23:49:59 --- kick: lambdac was kicked by Cale (Cale)
23:50:02 --- mode: Cale set -o Cale
23:50:48 <Cale> uncurry is to pairs what foldr is to lists and what maybe is to Maybe-values.
23:51:15 <Cale> But I suppose that wasn't what the person who named it had in the front of their mind at the time.
23:51:19 <joed> Which is to steak what bbq sauce is to ribs.
23:51:46 <wuxia> which is to vim what elisp is to emacs
23:52:14 <cjs> Cale: No. Which is a typical example of Haskell mutating thinking in the name of unifying the word, cateogory-theory style. :-)
23:53:59 <wuxia> @src curry
23:53:59 <lambdabot> curry f x y = f (x, y)
23:54:06 <cjs> Argh! I have gcc 6.8.2 on this machine. Thus, my 6.8.3-tweaked haddock doesn't compile.
23:54:09 <vixey> :t curry
23:54:11 <vixey> :t uncurry
23:54:11 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
23:54:12 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
23:54:13 <cjs> Grr.
23:54:49 <Trinithis> how can I compute all the True-False NxN matrices with exactly N True entries?
23:54:51 <wuxia> (curry (+)) (2, 3)
23:54:54 <wuxia> why doedsnt't athw work
23:55:00 <vixey> :t curry
23:55:01 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
23:55:03 <vixey> :t (+)
23:55:05 <lambdabot> forall a. (Num a) => a -> a -> a
23:55:15 <vixey> a -> a -> a /= (a, b) -> c
23:55:47 <wuxia>  @src curry
23:55:53 <wuxia> @src curry
23:55:54 <lambdabot> curry f x y = f (x, y)
23:55:54 <vixey> wuxia: Ignore the src
23:55:59 <vixey> wuxia: just look at the types
23:56:09 <wuxia> why? I can't infer the type from looking at the souder for curry
23:56:31 <vixey> because the src are confusing and unenlightening
23:56:34 <wuxia> something's wrong with my understanding
23:56:36 <vixey> the types are what really matters
23:56:46 <mmorrow> > uncurry (+) (4,2)
23:56:48 <lambdabot>  6
23:56:49 <vixey> also I don't know what "sounder" means
23:57:29 <mmorrow> > curry (uncurry (+)) (4,2)
23:57:30 <lambdabot>   add an instance declaration for (Num (t, t1))
23:57:32 <mmorrow> > curry (uncurry (+)) 4 2
23:57:33 <lambdabot>  6
23:57:35 <wuxia> ah; i confused curry and uncourry
23:57:37 <wuxia> morrow: thanks
23:57:43 <mmorrow> ;)
23:58:20 <vixey> wuxia: How did you confuse them?
23:58:32 <mmorrow> yeah, it's confusing which is which since the haskell way of giving functions args is curried by default
23:59:20 <wuxia> (curry (+)) (2, 3) <- if you replace curry withn uncurry, it works; i read the src backward somehow
23:59:43 <vixey> that's why you should look at the types and not the src
23:59:48 <wuxia> no
23:59:53 <wuxia> this is why i should read more careflully
23:59:59 <wuxia> if you only look at type, how does + and - differ?
