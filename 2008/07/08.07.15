00:00:30 <wuxia> (admittedtely, types are vbery useful, and if i read types, i would not have made that error; so yes, i should read types too; perhaps firstY
00:04:41 <wuxia> i'm reading soe page 128 ... so aparently let can match 'case of' instead of 'in'?
00:07:11 <Cale> wuxia: hm... no
00:07:39 <Cale> wuxia: case <expr> of ...  is another expression form altogether
00:08:36 <wuxia> http://hpaste.org/8934
00:08:42 <wuxia> so does let no need a corresponding 'in' ?
00:09:09 <Cale> the only case where it doesn't is inside of a do-block
00:09:28 <wuxia> okay, so it stays in 'contect' util the end of the do block?
00:09:34 <Cale> where  do { let <decls> ; <stmts> } --> let <decls> in do { <stmts> }
00:09:42 <wuxia> fantastic; thanks
00:09:51 <wuxia> and this let does not need to be the first in the do blo9ck either right?
00:09:55 <Cale> right
00:10:09 <Cale> That's the rule from the thing which desugars the do-notation
00:10:40 <Cale> do { x ; <stmts> } --> x >> do { <stmts> }
00:10:49 <Cale> do { v <- x ; <stmts> } --> x >>= \v -> do { <stmts> }
00:11:44 <Cale> That's applied recursively. So basically, the definitions made in the let will scope over the remainder of the do-block -- from that point downward
00:14:08 <wuxia> got
00:14:11 <wuxia> got it; thanks
00:14:18 <wuxia>  for more detials, see haskell report? :-)
00:29:06 <wuxia> i love haskell but don't like the vim editing mode for haskell that i have found so far; is identing haskell in emacs 'intuitive' ?
00:29:49 <vixey> What's "de Bruijn ratio"?
00:30:52 <_zenon_> Does someone have a neat vim haskell markup file?
00:31:10 <_zenon_> I used vim for a while but let it go, I like the gedit markup better
00:32:17 <wuxia> i'm cofused gby the def of strictness ... so the idea is that in this lazy lahnguage, a function is strict if: if one of it's arguments does not terminate, the computation must not terminate?
00:33:30 <vixey> no
00:33:41 <vixey> that's a consequence of, not the definition of
00:34:00 <rhz> strict is the opposite of lazy. And lazy who knows what lazy means. It just allows one to do wierd counter intuitive things like take the head of an infinite list.
00:34:27 <vixey> lazy is pulling sucessive WHNFs from the top of your program
00:34:34 <vixey> strict is eval/apply as in SICP
00:35:13 <wuxia> please explain to me what this means:
00:35:16 <wuxia> for all strict f
00:35:20 <rhz> exactly what I was saying..
00:35:51 <wuxia> map f. head = head map f
00:36:04 <wuxia> err, head . map f
00:36:16 <vixey> rhz: No I said something quite different to what you said
00:36:29 <vixey> rhz: What you said was a consequence of the definitions
00:37:12 <rhz> what I said was "who knows what lazy means". So your now saying that is a consequence of the definitions?
00:37:40 <Cale> I know what lazy means :)
00:37:44 <vixey> I also do
00:38:08 <rhz> Well I'm glad someone does
00:38:31 <lament> lazy = if it terminates for some order of evaluation, it will terminate.
00:38:35 <Cale> Lazy evaluation is outermost-first evaluation with sharing of expression which came from expanding the same function parameter
00:38:44 <Cale> expressions*
00:39:13 <wuxia> lament: I like that definition; thanks
00:39:23 <Cale> I'll give my favourite small example again... if we have  double x = x + x
00:39:31 <Cale> and we're evaluating  double (double 5)
00:39:47 <lament> wuxia: it's not really a definition, the definition is what Cale said, but this is the most important consequence of the definition
00:39:48 <Cale> then under strict (innermost-first) evaluation, we do:
00:39:51 <Cale> double (double 5)
00:39:53 <vixey> wuxia: It's not a definition, it's a consequence of the definition
00:39:54 <Cale> -> double (5 + 5)
00:39:58 <Cale> -> double 10
00:40:01 <Cale> -> 10 + 10
00:40:03 <Cale> -> 20
00:40:30 <Cale> We could also do outermost-first evaluation. If we do it naively, it goes like this:
00:40:33 <Cale> double (double 5)
00:40:35 <rhz> lament, that's not even correct.
00:40:40 <Cale> -> (double 5) + (double 5)
00:40:46 <Cale> -> (5 + 5) + (double 5)
00:40:49 <Cale> -> 10 + (double 5)
00:40:53 <Cale> -> 10 + (5 + 5)
00:40:57 <Cale> -> 10 + 10
00:40:59 <Cale> -> 20
00:41:00 <lament> rhz: counterexample?
00:41:11 <Cale> rhz: following?
00:41:22 <rhz> I'm thinking
00:41:31 <vixey> rhz: It is correct
00:42:08 <wuxia> cale: got it; thanks
00:42:17 <rhz> what about: head [1..]
00:42:21 <Cale> Now, lazy evaluation does something a little more than this
00:42:28 <rhz> there is only one way to evaluate that
00:42:29 <lament> > head [1..]
00:42:40 <lambdabot>  1
00:42:42 <rhz> oh wait asec
00:42:43 <Cale> Note how in the above, we evaluated double 5 twice
00:43:14 <Cale> What lazy evaluation says is that whenever a function parameter occurs multiple times in the body of a function, we share the results of evaluating it between the copies
00:43:26 <Cale> If you'll allow me to use let ... in ... to represent the sharing...
00:43:30 <Cale> double (double 5)
00:43:35 <Cale> -> let x = double 5 in x + x
00:43:40 <Cale> -> let x = 5 + 5 in x + x
00:43:43 <Cale> -> let x = 10 in x + x
00:43:46 <Cale> -> 20
00:44:01 <Cale> and that's how lazy evaluation goes
00:44:29 <Cale> There's no magic, it's just outermost first evaluation, plus a little mechanism to share things which came from the same function parameter.
00:45:12 <lament> are you saying Santa does not exist?
00:45:15 <rhz> so whats an example of an expression where the order of evaluation does affect whether it terminates or not in a strict language?
00:45:24 <vixey> rhz: id 3
00:45:37 <Quadrescence> lament: he does if you multiply him by sqrt(-1)
00:45:38 <vixey> rhz: oh , head [1..]
00:45:38 <Quadrescence> :D
00:45:40 <Cale> rhz: Saying that a language is strict imposes an order of evaluation
00:45:52 <Cale> rhz: (strict means innermost-first)
00:45:52 <masak> > print $ unlines ["1","2","3","4"]
00:45:53 <lambdabot>  <IO ()>
00:46:00 <masak> > unlines ["1","2","3","4"]
00:46:01 <lambdabot>  "1\n2\n3\n4\n"
00:46:19 <masak> what should I do to get newlines instead of literal "\n" here?
00:46:25 <rhz> vixey: that's not an example.
00:46:31 <vixey> rhz: OK
00:46:44 <Cale> > rhz: let loop = loop in const 4 loop
00:46:46 <lambdabot>   Not in scope: `rhz'
00:46:48 <Cale> > let loop = loop in const 4 loop
00:46:48 <vixey> > var . unlines . words $ "1 2 3 4"
00:46:49 <lambdabot>  4
00:46:52 <lambdabot>  1
00:46:52 <lambdabot> 2
00:46:52 <lambdabot> 3
00:46:52 <lambdabot> 4
00:47:36 <Cale> rhz: If that was evaluated strictly, then loop would never finish evaluating
00:47:37 <rhz> Cale, I don't see how that is an example either
00:47:41 <osfameron> :t var
00:47:43 <lambdabot> forall a. String -> Sym a
00:48:10 <Cale> Under innermost first evaluation in expanding (const 4 loop), we would first evaluate 4 and loop.
00:48:12 <rhz> ok
00:48:25 <masak> vixey: ah, thanks. turns out I was using print instead of putStr
00:48:33 <Cale> but of course, loop would evaluate to loop again, and would never finish evaluating
00:48:50 <Cale> You can replace loop = loop with something less trivial, like loop = loop + 1 if you prefer
00:49:10 <Cale> But, under strict evaluation, that's a non-terminating expression.
00:49:18 <rhz> I think I was thinking about a different meaning of the phrase "order of evaluation" from everyone else
00:49:30 <Cale> Under lazy evaluation, or normal-order evaluation, it's const which is evaluated first
00:49:47 <Cale> const 4 loop -> (\x y -> x) 4 loop -> 4
00:50:09 <Cale> and the loop is never reached.
00:51:34 <rhz> Cale, that example doesn't have anything to do with order of evaluation. It is simply an example of something where some terms in the expression are not evaluated at all.
00:51:50 <vixey> rhz: That's exactly the point ..
00:51:51 <Cale> If you prefer not to use value recursion, but only function recursion, you can replace loop with something like f n where f n = f (n+1) or something
00:52:10 <Cale> const 4 (f 0)
00:52:13 <rhz> "evaluation" /= "order of evaluation"
00:52:36 <Cale> The order in which you evaluate the reducible subexpressions of that expression affects termination behaviour
00:52:55 <Cale> We can also choose a different order from either strict or lazy
00:53:09 <Cale> For example, I could start off by evaluating f 0
00:53:16 <Cale> const 4 (f 0) -> const 4 (f 1)
00:53:28 <Cale> and then apply const
00:53:35 <Cale> -> 4
00:54:16 <Cale> Strict evaluation always picks the innermost (leftmost) reducible subexpression first, however, and so it will never finish evaluating f
00:54:33 <wuxia> reading up on  qualified type classes ... should i think of them as purely abstract C++ classes with certain virtual functions?
00:54:52 <vixey> no
00:54:56 <weilawei> good morning
00:54:58 <Cale> Whereas lazy evaluation always picks the outermost (leftmost) reducible subexpression first, and so it will finish.
00:55:00 <vixey> hi
00:55:09 <rhz> Cale, "The order in which you evaluate the reducible subexpressions of that expression affects termination behaviour". This is false. There is only one way to evaluate the reducible subexpressions.
00:55:20 <Cale> rhz: No, there's clearly a choice
00:55:47 <Cale> rhz: I can start by evaluating the application of const to its parameters, or by evaluating (f 0)
00:55:51 <rhz> Cale, well technically 4 is not reducible
00:55:55 <Cale> Right.
00:56:04 <weilawei> so.. i've tried haskell. repeatedly. i don't -think- i'm a terrible programmer. but every time i try to learn haskell, it beats me soundly about the ears and sends me packing.
00:56:13 <Cale> and 0 is not reducible either
00:56:26 <Cale> So the only reducible subexpressions are f 0 and the whole expression.
00:56:36 <weilawei> this is round #n. i've been coding for quite a long time in C and related languages, more recently in Python for ease of use..
00:56:40 <weilawei> any suggestions on where to start?
00:56:45 <Cale> weilawei: Well, here is good :)
00:56:51 <weilawei> i usually end up going" WTF does that syntax mean"
00:56:55 <Cale> weilawei: Make sure to ask questions here when you get stuck.
00:57:16 <Cale> weilawei: There are some good books for beginners coming out... one of which has many free chapters available.
00:57:20 <vixey> weilawei: Haskells syntax is a lot simpler than C :)
00:57:29 <weilawei> but less familiar ;)
00:57:35 <weilawei> that would be useful as my budget is zero dollars and less cents.
00:57:51 <rhz> weilawei, I think I started from the "Gentle Introduction to Haskell" on the net
00:58:33 <weilawei> do you mostly use GHC?
00:58:49 <weilawei> choice of compiler in the C world is pretty straightforward..
00:58:57 <rhz> who is that question directed at?
00:58:59 <vixey> yes GHC
00:59:04 <masak> looking for review comments on this program: http://hpaste.org/8935 -- given a permutation of 1234, buildQueue finds out if the permutation can be generated using only stack (front) and queue (back) insertions.
00:59:18 <weilawei> it's you (plural)_
00:59:22 <weilawei> not you (singular)
00:59:24 <Cale> The Gentle intro isn't terribly gentle :)
00:59:24 <weilawei> y'all
00:59:36 <rhz> Cale, neither is Haskell though
00:59:59 <Cale_> Haskell is certainly not harder than, say, Java.
01:00:28 <rhz> Well this kind of depends on one's interpretation of "gentle"
01:00:37 <Cale_> It's just that it's not so imperative, so if you already know an imperative language, that's not going to help you, and in fact, you might have to unlearn some things you already know :)
01:00:42 <Cale_> http://book.realworldhaskell.org/beta/
01:00:45 <lambdabot> Title: Real World Haskell
01:01:08 <Cale_> There's a nice book which bos, dons and CosmicRay (if I have my name/nick mapping right) are writing :)
01:01:30 <weilawei> im willing to unlearn, but gentle is the order of the day
01:01:45 <weilawei> i come back to trying haskell every few months.. so thats 4 tries per year
01:01:49 <weilawei> not a lot ;)
01:02:12 <Cale_> Another book you might look at is "Programming in Haskell" by Graham Hutton
01:02:48 <Cale> If you're looking for something made of dead trees. Watch out for the e-book though, as people have not had much luck reading it on anything but windows.
01:02:54 <weilawei> cool, ill check those out and get back to you guys when i feel my hair turning gray and my beard falling out
01:03:05 <Cale> weilawei: There are some online tutorials as well.
01:03:07 <weilawei> thank you (plural)
01:03:08 <rhz> weilawei, it's like riding a bike. Difficult until you get the hang of it and can balance
01:03:50 <Cale> weilawei: Is there anything in particular which you're stuck on at the moment?
01:04:35 <Cale> weilawei: Don't be afraid to ask questions here, as there are typically a lot of people hanging around who enjoy helping beginners :)
01:04:39 <weilawei> Cale, not at the moment, because I always get confused and walk away. This time I decided to enlist live help to start off the right way and then have someone to yell at.
01:04:43 <weilawei> Okay not yell
01:04:46 <weilawei> But you get the idea
01:04:51 <Cale> hehe
01:05:00 <weilawei> I did this with Python originally.. xD but it was worth trying again and again
01:05:15 <weilawei> C makes my brain not quite suited for learning the fun stuff
01:05:30 <jstanley> So I just added an argument to a value constructor, and changed all uses of it, but ghci is complaining that I'm giving the constructor the wrong number of arguments, even though ghc compiles it fine. Ideas?
01:06:00 <rhz> in many ways functional programming is closer to one's intuitive notion of programming I think.
01:06:41 <masak> I'd say buildQueue is the most complicated function I've written in Haskell to date. but is there any way to make it simpler? http://hpaste.org/8935
01:07:09 <Cale> jstanley: hmmm... make sure there are no annoying temporary files (*.o *.hi) lying around.
01:07:16 <weilawei> rhz, i think I beat my intuitive notion to death when I was 4 and played with BASIC on a C64
01:07:19 <jstanley> Cale: Yeah, is the first thing I did =/
01:07:40 <rhz> weilaway, sadly your not the only one
01:08:19 <weilawei> most people seem to be more comfortable with functional if they dont know anything yet
01:08:24 <weilawei> so it would suggest your theory is right
01:08:43 <weilawei> but for those of us who grew up on slinging chunks of memory
01:08:47 <weilawei> doesn't quite work
01:08:48 <jstanley> Cale: What's really strange is that if I do a ":l f1.hs f2.hs" (where f1.hs is the guy that defines the constructor and is the code that changed), it works.
01:09:07 <jstanley> Cale: But I don't want to have to do that...=/
01:09:35 <Cale> jstanley: Try naming the files the same as their module names (which you declare at the top of each file)
01:09:51 <opqdonut> gah, should really finish ptII of my GADT blog entry :\
01:09:53 <Cale> jstanley: Then ghci/ghc will be able to locate them automatically from the import declaration
01:09:56 <jstanley> Cale: Also already done.
01:10:05 <rhz> weilawei, well the moral of that story is I guess to keep an open mind... after all Haskell isn't the end of the story either I don't think
01:10:06 <Cale> hmmm
01:10:07 <jstanley> Cale: It's really strange. =/
01:10:23 <Cale> jstanley: Could you possibly hpaste them?
01:10:27 <weilawei> rhz, right, someone will come along with less forbidding and seemingly perl inspired syntax someday
01:10:46 <Cale> weilawei: What? You mean Perl 6?
01:10:47 <rhz> I've never actually learned perl to be honest
01:10:52 <jstanley> Cale: Yeah gimme a sec.
01:11:09 <weilawei> Cale, when i say perl, im speaking broadly about all the terribly obtuse and overly brief syntaxes ever made
01:11:20 <weilawei> python made me appreciate being able to -read- my code
01:11:30 <Cale> (Perl 6 has now been incredibly influenced by Haskell)
01:11:36 <weilawei> oh
01:11:37 <weilawei> xD
01:12:03 <weilawei> i dont know perl 6 tbh
01:12:06 <Cale> (Since the first interpreter for it was written in Haskell)
01:12:09 <weilawei> i learned perl 5 stuff
01:12:30 <weilawei> and quickly decided perl was the devil
01:12:42 <vixey> perl is useful
01:12:44 <rhz> All programming languages are
01:12:58 <weilawei> vixey, useful can be readable too ;)
01:13:01 <weilawei> anyways
01:13:06 <weilawei> i need to escape and read this book and try things
01:13:07 <earthy> um. really? then I have a brainfuck to sell to you, rhz
01:13:10 <weilawei> so i know what im screwing up on
01:13:15 <weilawei> i have a whitespace ;)
01:13:15 <Cale> There's an ugly Perl script which is (was?) in the GHC source code called the Evil Mangler.
01:13:24 <rhz> earthy, I meant they are the devil
01:13:39 <weilawei> evil mangler?
01:13:53 <Cale> (It mangles the assembly output of gcc)
01:13:58 <weilawei> (oh IRC, i love you like insects love zappers)
01:14:13 <Cale> Since GHC is moving more and more to native code generation, it's not really used as much anymore.
01:14:22 <earthy> yup, the evil mangler. truly evil.
01:14:52 <rhz> brainfuck and such languages just embrace the inherent devilishness
01:14:56 <weilawei> i had a sysadmin who blocked us for downloading torrents at work. in reality, we just got bored of our music sometimes and pandora didn't always cut it. so we had to change mac addresses routinely.
01:15:19 <vixey> aj..
01:15:21 <weilawei> i wrote a little script in Python (in 1337) to generate messages that could be properly represented as mac addresses using 1337
01:15:41 <weilawei> i still don't know if he ever noticed
01:16:11 <jstanley> Cale: alright, the description of the error is up at http://hpaste.org/8936
01:16:37 <wuxia> OT:  in linux, is there anyway to make a free international call over voip ?
01:16:40 <vixey> who runs the hpaste bot?
01:16:55 <vixey> why don't lambdabot consume its function?
01:17:16 <weilawei> wuxia, as long as it doesn't stray into POTS, then yes, it's all free ;)
01:17:17 <Cale> jstanley: hmm...
01:17:32 <jstanley> Cale: Yeah; like I mentioned before, ghc doesn't have a problem with it
01:17:35 <weilawei> if you connect to POTS, then i dont know of a free solution
01:17:37 <Cale> jstanley: The only thing I can think of is if ghci is finding a different copy of the file.
01:17:52 <wuxia> weilawei: what's POTS? how do I do this?
01:17:52 <jstanley> Cale: Hmm.
01:17:59 <wuxia> weilawei: can you pm me with more info
01:18:00 <weilawei> plain old telephone system
01:18:08 <wuxia> weilawei: trying to make a call into china
01:18:15 <foofoofoo> can the check parameters be adjusted to lambdabot's @check?
01:18:20 <jstanley> Cale: Just not sure how that's possible at all in this case. I thought it might be the load-it-from-emacs thing I was doing, but I checked a manual ghci run from a shell
01:18:51 <weilawei> that probably comes with additional issues.. but VoIP can be just two computers. but as soon as you involve a normal telephone handset connected to a normal line, it tends to cost money
01:18:57 <jstanley> I've also nuked Errors{Xml}.{o,hi} recursively from the tree
01:19:00 <weilawei> skype and ekiga do voip
01:19:41 <Cale> jstanley: okay, and these modules are in a directory Blah, and f1.hs is really Blah/Errors.hs or Blah.Errors.hs ?
01:20:04 <jstanley> *nod*
01:20:17 <jstanley> one sec, might have found something
01:20:21 <weilawei> wuxia, if you're building something -serious-, get a book and asterisk. but for calls, stick to consumer apps like skype and ekiga
01:20:26 <Cale> Try removing the constructor altogether and see what happens :)
01:20:34 <jstanley> good idea ;)
01:20:53 <wuxia> that's cool; i didn't even think of rolling my own
01:21:01 <jstanley> Cale: Note in scope: data constructor UnusedArguments
01:21:06 <jstanley> Cale: Now it's even weirder.
01:21:11 <Cale> mm
01:21:15 <Cale> Put it back again?
01:21:17 <Cale> hehe
01:21:26 <jstanley> Cale: wtf, it worked
01:21:29 <Cale> haha
01:21:38 <Cale> I have no idea :)
01:21:39 <jstanley> Cale: lol. thanks ;)
01:21:52 <jstanley> Cale: I seriously would have been banging my fist on this thing for the next hour ;)
01:24:25 <weilawei> okay my first problem is that
01:24:37 <weilawei> i type something that appears to be an example into GHCi and it says error
01:24:40 <weilawei> when i typed it verbatim
01:24:56 <Cale> weilawei: GHCi only wants expressions to evaluate
01:25:03 <Cale> weilawei: declarations are supposed to go into a file
01:25:11 <Cale> (which you load into GHCi to test)
01:25:12 <weilawei> grr.. someone needs to make that obvious
01:25:39 <Cale> I find it convenient to keep an editor window open alongside ghci, and whenever I save the file, :r in ghci will reload it
01:25:48 <weilawei> how do i load it in the first place?
01:25:50 <Cale> (in fact, just a single : will as well)
01:25:55 <Cale> Either :l file.hs
01:26:03 <Cale> or pass it as a parameter on the commandline
01:26:29 <weilawei> thanks Cale
01:26:30 <jstanley> Cale: Oh, man, this is so strange. It just happened again but this time the previous fix didn't change it. It must been a combination of that and clearing out intermediate files.  What a pain =/
01:28:13 <Cale> jstanley: something strange is definitely going on there... I'm not certain, but I think it uses timestamps on files to check if it has to rebuild... I can imagine a situation where for some reason your editor isn't updating the timestamp and so the file isn't being reloaded.
01:29:32 <jstanley> Cale: Yeah, it might be something like that.  Thanks.
01:29:59 <rhz> the problem with all programming languages is that they require an underlying operating system and they are thus inherently limited by the limitations of that
01:30:41 <vixey> rhz: .. what
01:30:55 <rhz> what?
01:31:18 <vixey> how is that a problem, to me that seems like the entire purpose
01:31:55 <rhz> what purpose?
01:32:13 <vixey> running them on a computer
01:32:25 <quicksilver> of course, what rhz isn't remotely true.
01:32:31 <quicksilver> languages don't require operating systems.
01:32:38 <roconnor> quicksilver++
01:32:49 <quicksilver> they are conventionally run with useful bindings to operating system calls.
01:32:55 <quicksilver> but that's not necessary or universal.
01:33:17 <quicksilver> for example the OS itself is written in a programming language :)
01:33:20 <rhz> quicksilver, I'm not convinced
01:33:34 <quicksilver> various embedded systems have little or no OS to speak of.
01:33:49 <quicksilver> there's no OS on your washing machine (probably), the program speaks directly to the sensors.
01:34:10 <opqdonut> well it all depends on what you call an os
01:34:12 <rhz> but the programmers used an operating system to develop the code
01:34:28 <cjs> Sure, for convenience.
01:34:40 <quicksilver> they used an OS to *develop* the code, sure.
01:34:47 <quicksilver> but that OS does not "underly" the code.
01:34:54 <roconnor> Coq doesn't have access to any hardware or system calls
01:34:54 <quicksilver> it just underlay the editors + compilers they used.
01:34:56 <cjs> I've hand-assembled 6502 and 6809 assembly code, on paper, and punched it in via a monitor.
01:35:07 <quicksilver> once the code is  running there is no underlying OS.
01:35:09 <lament> People use hangars to construct planes.
01:35:17 <quicksilver> good analogy.
01:35:20 <quicksilver> and scaffolding, too.
01:35:40 <cjs> I could have punched cards or paper tape with it, on a teletype or card punch, and loaded it that way. Or even toggled it in via a front panel (though I've never done that except with trivial programs on a PDP-8.)
01:35:41 * dibblego watches a hangar fly over
01:36:04 <lament> cjs: oldskool
01:36:11 <cjs> Yeah!
01:36:30 <rhz> quicksilver, cjs: I'd like to see you hand assemble Haskell
01:36:45 <cjs> There was something wonderful about the PDP-8. All those little cards, each with one or to 7400-series parts (e.g., quad-NAND-gate) on it....
01:36:46 <vixey> -_-
01:36:48 <lament> i've never even wrote a program that sat in the MBR :(
01:37:06 <cjs> rhz: I could. It would take time, and be error-prone, but it's not rocket-science.
01:37:25 <quicksilver> cjs: unless the haskell you were assembling was a rocket guidance system, of course
01:37:28 <cjs> A lot (most?) computer stuff is about doing a lot of trivial things very quickly.
01:37:29 <quicksilver> then it would be rocket science.
01:37:47 <vixey> lol
01:37:49 <lament> @faq can Haskell guide rockets?
01:37:49 <lambdabot> The answer is: Yes! Haskell can do that.
01:38:00 * cjs thinks that was a pretty geeky joke....
01:38:11 <cjs> lament: ! :-)
01:38:14 * quicksilver thinks most of his jokes are pretty geeky.
01:38:19 <quicksilver> got a problem with that? :)
01:38:30 <cjs> Damn, I've still got this contest on my mind.
01:39:01 <roconnor> I once gave a set of instructions to individutal kindergarden students telling them to go up to the front of the room when given a ball, and rearrange the blocks in a particular mannar and pass the ball to another studend depending on the blocks they adjusted.
01:39:15 <cjs> We got to the point where we started to discover the really interesting parts of the problem, and then didn't have time to implement stuff for that.
01:39:18 <roconnor> Thus I programmed a kindergarden class as a universal computing device.
01:39:30 <roconnor> (actually it wasn't me, I heard about this from someone else)
01:39:33 <cjs> roconnor: Turing-complete!
01:39:47 <roconnor> my point is: no operating system.
01:41:14 <rhz> roconnor: where is your language though?
01:41:44 <roconnor> it was on the paper I handed out the the students and/or the inital blocks I placed at the front of the class.
01:41:46 <cjs> Kindergol.
01:42:07 <roconnor> (again, wasn't actually me)
01:42:11 <cjs> BIAW.
01:42:13 <rhz> what if the students malfunctioned
01:42:23 <lament> Programming is all about child abuse.
01:42:36 <rhz> child abuse?
01:42:43 <Baughn> roconnor: Did you consider the chinese day-care room problem?
01:42:58 <roconnor> rhz: the same thing that happened when sunspots screw up my md5 sums.
01:43:16 <rhz> this is getting ridiculous. But the students didn't have to followthe instructions you gave them
01:43:40 <roconnor> Baughn: *L*  Each child doesn't know how to do universal computation, but the collection of children do.
01:44:08 <lament> rhz: neither do the transistors in your computer.
01:44:20 <roconnor> rhz: but they do follow the directions with high probability.
01:44:35 <rhz> hmm
01:44:43 <rhz> the transistors don't have a mind
01:44:52 <quicksilver> neither do the children
01:44:53 <roconnor> neither do the children
01:44:56 <rhz> of their own
01:44:57 <vixey> haha
01:44:58 <rhz> what?
01:45:11 <quicksilver> they're all just electrical effects and high probabilities
01:45:22 <Baughn> roconnor: Mmh. I once had a religionist tell me, in all seriousness, that the room as a whole would gain a soul and that would push out the souls of the people running it.
01:45:26 <quicksilver> I imagine the transistors have a significantly higher probability of behaving deterministically
01:45:30 <rhz> the children do have minds
01:45:34 <quicksilver> but that's just a quantative comparison.
01:45:54 <rhz> i mean usually children do I would say.
01:46:04 <Baughn> Of course the children have minds. If we were mindless, AI wouldn't be such a big problem
01:46:18 <lament> AU
01:46:32 <rhz> what is AU?
01:46:42 <Baughn> Alternate universe? Can't be..
01:46:43 <vixey> rhz: A joke
01:46:59 <rhz> Astronomical Unit?
01:47:12 <Baughn> Artificial unintelligence?
01:47:29 <rhz> oh that must be it
01:47:32 <rhz> haha
01:47:45 <Baughn> That's /usually/ called AS
01:47:48 <weilawei> roconnor, cjs, lament: submitted for bash.orgification
01:48:00 <weilawei> turing complete child abuse ftw.
01:48:38 <roconnor> there is a continum from electrial transitors, to lego blocks, to plants they receive light and by obscuring light to other plants, to insects, to trained fish, to kindergarden students, that are all capable of being used to implement universal computation.
01:49:13 <Baughn> roconnor: Assuming the laws of physics are turing-complete
01:49:44 <vixey> laws of physics don't matter
01:49:46 <weilawei> this is true.. i'd discussed making a rudimentary computer based on fluids of varying viscosity, powered by gravity
01:49:57 <vixey> nothing is turing-complete except your mathematical models of these things
01:49:58 <roconnor> Baughn: well, all these require access to some representation of the unbounded tape to really be universal.  But we ignore that as usual.
01:50:01 <rhz> what definition of "Turing-complete" are you people talking about?
01:50:20 <vixey> rhz: the only definition
01:50:21 <lament> you need very, very little for universal computation, and almost any set of physical laws would suffice
01:50:27 <Baughn> roconnor: I'm worrying more about the possibility that infinite reliability may be impossible, even in principle
01:50:28 <rhz> which is what ?
01:50:48 <rhz> vixey?
01:50:59 <quicksilver> capable of modelling a turing machine.
01:51:02 <quicksilver> is what it means.
01:51:07 <quicksilver> more info on wikipedia, no doubt.
01:51:10 <vixey> rhz: You will probably look it up
01:51:16 <roconnor> Baughn: that's probably technically true as well for all attempts physical realization of universal computation
01:51:23 <yitz> rhz: btw, roconnor thanks you for unwittingly being part of a calculation he is carrying out by participating in this conversation.
01:51:27 <lament> Baughn: assuming no proton decay, i don't think there're any problems...
01:51:29 <Baughn> roconnor: Yes, see, that's the problem
01:51:44 <lament> Baughn: uncertainty principle doesn't really affect stuff much, I don't think
01:51:45 * rhz smiles to himself
01:51:46 <Baughn> lament: I suspect quantum mechanics will have issues with that assertion
01:51:51 <roconnor> Baughn: I have computed two different md5sums for the same file in the past.
01:51:56 <Baughn> lament: Just you wait. Wait for it... any moment now...
01:51:59 * rhz thanks everyone for being part of a computation he is carrying out
01:52:09 <Baughn> There! A water molecule in andromeda spontaneously fell apart
01:52:36 <lament> Baughn: uncertainty principle gives a lower limit on specific position/velocity, but that just means you build a machine with parts bigger than that limit
01:53:29 <quicksilver> ball bearings, say.
01:53:37 <quicksilver> they're quite a bit bigger than the heisenberg limits
01:53:52 <vixey> turing complete doesn't make any sense when you talk about actual physical things as opposed to mathematical models
01:53:53 <quicksilver> I bet there is a youtube video of a turing complete computer using ball bearings
01:53:58 <rhz> vixey: I may look it up one day
01:54:05 <lament> quicksilver: i was thinking ball bearings, too :)
01:54:06 <vixey> rhz: OK
01:54:09 <quicksilver> vixey: it makes sense
01:54:11 <Baughn> lament: Maybe that works; I'm no physicist. But are you quite sure that, being made of atoms, the ball bearings won't spontaneously degenerate over the course of some 10^50 years?
01:54:16 <vixey> quicksilver: not to me ...
01:54:21 <quicksilver> why not?
01:54:22 <lament> Baughn: right, i said "assuming no proton decay"
01:54:28 <quicksilver> if my physical machine can simulate a turing machine
01:54:31 <quicksilver> then it's turing complete
01:54:35 <quicksilver> how hard is that?
01:54:38 <Baughn> lament: SUre, feel free to assume no proton decay
01:54:42 <Baughn> There are other mechanisms
01:54:55 <vixey> if you've shown your physical machine can simulate a turing machine .. the proof is regarding a mathematical idealization of the machine
01:55:06 <quicksilver> if you like.
01:55:10 <vixey> Since turing complete is a rigerously defined concept
01:55:13 <quicksilver> the sentence still makes perfect sense though.
01:55:24 <lament> Baughn: i think it's doable to keep it safe
01:55:29 <quicksilver> there is no confusion in the sentence "This physical machine is turing complete"
01:55:30 <vixey> I think it's misleading ..
01:55:33 <quicksilver> it is entirely clear what it means
01:55:40 <quicksilver> and what is means is a perfectly sensible notion.
01:55:42 <lament> Baughn: you can't avoid some influence of external radiation and something might have to be done about that
01:56:10 <vixey> It's not clear what level of detail .. which details are ignored .. etc
01:56:21 <roconnor> quicksilver: The statement is relative to your mathematical model of physics.
01:56:28 <quicksilver> perhaps.
01:56:32 <quicksilver> it still makes sense though.
01:56:57 <roconnor> yep, so long as you are aware of the implicit parameter
01:57:00 <quicksilver> I can take a rather simple empirical model, for example.
01:57:08 <quicksilver> like newtonian physics
01:57:12 <quicksilver> would be fine for ball bearings.
01:57:25 <roconnor> well, if you have enough of the ball bearings
01:57:36 <quicksilver> well as you said, the infinite tape is a problem.
01:57:52 <quicksilver> but I can say something like "For any given finite tape size, I can imagine a machine..."
01:58:04 <quicksilver> and then we rather gently blur that into unbounded tapes
01:58:10 <roconnor> :)
01:58:26 <quicksilver> any particular program I need to run has a bound on the tape size it needs after all
01:58:31 <quicksilver> so this blurring is not a stupid thing.
01:58:54 <roconnor> well, I suppose we need frictionless infinitely cold ball bearings
01:59:23 <lament> not really
01:59:31 <quicksilver> no I don't think we do
01:59:31 <roconnor> hmm
01:59:38 <lament> normal ball bearings + an energy source will do
01:59:42 <quicksilver> we just design our machine with friction tolerances
01:59:50 <quicksilver> oh yes, you certainly need an energy source :)
01:59:59 <quicksilver> I wasn't suggesting "Free Computation" :)
02:00:17 <quicksilver> it's quite possible to design physical parts with negative feedback
02:00:29 <quicksilver> under certain friction tolerances you get consistent speeds and so on
02:00:41 <weilawei> quicksilver, mobius strip to increase the space available on said tape? it's not infinite, but it's a darn sight smaller in space that it occupies
02:00:44 <lament> quicksilver: the world would be a pretty unbearable place otherwise :)
02:00:45 <quicksilver> clockmaking is full of cleverly design negative feedbacks.
02:01:01 <quicksilver> weilawei: heh ;)
02:01:01 <roconnor> good point
02:01:12 <quicksilver> I think the ball-bearings would fall off the 'bottom' of the tape, weilawei
02:01:17 <weilawei> er right
02:01:19 <weilawei> xD
02:01:30 <weilawei> sticky infinitely cold frictionless ball bearings?
02:01:47 <vixey> weilawei: I think they do that in biscuit factories ...
02:01:57 <vixey> weilawei: to make they conveyor belts last longer
02:02:12 <lament> vixey: they use sticky infinitely cold frictionless ball bearings?
02:04:10 <roconnor> of course, newtonian mechanics isn't the way physics actuallly works. :)
02:04:23 <weilawei> just a model, as is everything else
02:04:25 <quicksilver> Of course.
02:04:36 <quicksilver> Which is why I carefully said 'I can take a simple empirical model'
02:04:47 <quicksilver> and design parts with negative feedback, and so on.
02:05:09 <roconnor> sure, but you are realy divorcing your argument from reality at that point.
02:05:22 <weilawei> over 60% of american families are divorced now
02:05:24 <quicksilver> careful use of discretisation, negative feedback, and things like that can give precise answers (of fixed precision) from imprecise tools.
02:05:27 <weilawei> so why can't his argument?
02:05:30 <weilawei> are you prejudiced?
02:05:39 <quicksilver> divorced from reality in what sense?
02:05:42 <quicksilver> I could build this machine.
02:05:44 <quicksilver> it would work.
02:05:45 <quicksilver> isn't that real?
02:05:47 <rhz> well I've just looked up the definition of "turing complete" on wikipedia. It says this "A computational system that can compute every Turing-computable function is called Turing-complete (or Turing-powerful)." This is a little bit unclear however since the phrase "computation system" has not been defined..
02:06:05 <weilawei> i think purposely undefined
02:06:11 <weilawei> any system that gets the job done
02:06:20 <roconnor> I think you can replace "computaitonal system" with "system"
02:06:25 <lament> computation system, n: A room full of children
02:06:27 <quicksilver> yes, it's hard to make it precise. A computation system is a system for computing things.
02:06:33 <roconnor> "computational" is simply extra description.
02:06:44 <quicksilver> for simplicity you may like to take 'things' as 'natural numbers'
02:06:45 <roconnor> describing the "intent" of the system
02:06:48 <weilawei> lament, you should start the devil's dictionary: turing edition
02:06:50 <rhz> but "system" then remains undefined
02:07:00 <quicksilver> it's not undefined.
02:07:03 <quicksilver> it's a normal english word.
02:07:06 <quicksilver> it means what it means.
02:07:13 <lament> system, n: A system.
02:07:23 <roconnor> @dict system
02:07:24 <lambdabot> Supported dictionary-lookup commands:
02:07:24 <lambdabot>   all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
02:07:24 <lambdabot> Use "dict-help [cmd...]" for more.
02:07:30 <weilawei> quicksilver, denoted with flexible terms, ambiguous in connotation
02:07:30 <roconnor> @wn system
02:07:31 <weilawei> happy?
02:07:31 <lambdabot> *** "system" wn "WordNet (r) 2.0"
02:07:31 <rhz> This definition would not terminate ina strict language clearly
02:07:31 <lambdabot> system
02:07:31 <lambdabot>      n 1: a group of independent but interrelated elements comprising
02:07:31 <lambdabot>           a unified whole; "a vast system of production and
02:07:31 <lambdabot>           distribution and consumption keep the country going"
02:07:33 <lambdabot> [29 @more lines]
02:07:50 <quicksilver> weilawei: but nonetheless there is no ambiguity here.
02:07:53 <lament> wouldn't terminate in a lazy language either
02:07:57 <quicksilver> natural language is a flexible thing.
02:08:03 <lament> > let system = system in system
02:08:03 <quicksilver> that doesn't make it useless.
02:08:14 <quicksilver> it may be sometimes hard to formalize
02:08:18 <lambdabot>  thread killed
02:08:20 <quicksilver> formalisation isn't always a useful process
02:08:30 <rhz> I said it was unclear
02:08:36 <lament> nuclear!
02:08:39 <lament> nuclear turing machines
02:09:02 <weilawei> nukular*
02:09:08 <weilawei> there, i fixed it for you
02:09:08 <rhz> feel free to freely associate over irc
02:09:57 <roconnor> You might even be able to replace "system" with "anything"
02:10:12 <roconnor> or "a thing"
02:10:21 <lament> @faq Can some guy named Haskell construct a Turing-complete device out of ball bearings?
02:10:21 <lambdabot> The answer is: Yes! Haskell can do that.
02:10:30 <quicksilver> rhz: well it isn't unclear to me.
02:10:30 <weilawei> roconnor, the next step is to replace anything with "girlfriend that can code"
02:10:34 <weilawei> and then ?
02:10:35 <weilawei> profit.
02:10:39 <quicksilver> rhz: if you can explain how it's unclear to you?
02:11:53 <rhz> might need to think about that for a little while
02:12:33 <weilawei> quicksilver, the same way marketing works
02:12:38 <weilawei> and politicians
02:13:03 <weilawei> if it sounds good, we go to press
02:13:08 <quicksilver> sure, natural language can be used to deceive and confuse
02:13:14 <quicksilver> but it isn't *always* used this way
02:13:21 <rhz> quicksilver, it is unclear because words like "system" and "anything" need to be taken in context to have meaning.
02:13:22 <quicksilver> natural language is also used to communicate effectively.
02:13:29 <quicksilver> rhz: I don't think they do.
02:13:43 <quicksilver> a system, in the definition of turing complete, really can be in any context
02:13:49 <quicksilver> it's a way of doing computations
02:13:59 <weilawei> and what, pray tell, is a computation?
02:14:02 <quicksilver> could be on paper, in atoms, in a computer, with ball bearings, in your mind
02:14:02 <rhz> be back in a minute..
02:14:05 <quicksilver> a function from N -> N
02:14:33 <lament> we could formalize it
02:14:33 <roconnor> a particular subset of those (partial) functions.
02:14:40 <lament> but that would be a gigantic waste of time
02:14:54 <lament> feel free to do it anyway.
02:15:24 <quicksilver> roconnor: only a particular subset turn out to be computable.
02:15:32 <quicksilver> roconnor: but functions from N -> N is a reasonable 'goal set'
02:15:46 <quicksilver> then we find that any particular system can only compute some of them
02:15:48 <quicksilver> that's not a problem
02:15:51 <quicksilver> (in fact it's the poitn!)
02:16:12 <roconnor> Those n-ary (partial) functions on nat constructed from 0 successor, projections, compositon, primitive recursion, and minimization
02:16:31 <roconnor> (prehaps minimization subsumes primitive recursion.  I forget, so I stuck it in anyways)
02:16:31 <DRMacIver> Question. Isn't this sort of trying to formalise "computational system" exactly what the notion of a turing machine was originally created to do?
02:16:55 <quicksilver> roconnor: sure, but that's the answer not the question :)
02:16:58 <vixey> no I think you must have primitive recursion and minimization
02:17:10 <quicksilver> roconnor: when you're thinking about what computation + turing machine means, you admit any function
02:17:19 <quicksilver> then the challenge is to find out which ones you can, in fact, compute.
02:17:39 <quicksilver> it is twisted to restrict the set before hand
02:17:42 <DRMacIver> (Well, it was trying to formalise "mechanical process" or something like that, but essentially the same thing)
02:17:50 <roconnor> quicksilver: prehaps I misunderstood the question
02:17:52 <quicksilver> after all, you might imagine I'll find a new kind of computation which can computer a larger set.
02:18:01 <quicksilver> roconnor: perhaps there is more than one question :)
02:18:20 <quicksilver> you can imagine various kinds of computation system.
02:18:30 <quicksilver> a priori, it is not obvious that they all compute the same set of functions.
02:18:38 <quicksilver> you take turing machines as an example.
02:18:48 <quicksilver> it turns out that turing machines can calculate precisely the set you just described
02:18:52 <quicksilver> then you compare other systems
02:18:53 <rhz> i think I missed a lot of points there
02:19:06 <quicksilver> and it turns out that other systems are equivalent to the turing machine
02:19:09 <quicksilver> (or weaker)
02:19:16 <quicksilver> this is surprising (a priori) and interesting
02:19:18 <roconnor> perhaps we should forget about talking about computable functions, and stick to talking about "recursive" functions.
02:19:21 <quicksilver> if you're interested in that kind of thing.
02:19:25 <roconnor> to avoid the loaded term "computable"
02:19:30 <vixey> roconnor: yes!
02:19:57 <roconnor> (even though the modern definition of "computable" is currently taken to mean "recursive")
02:20:41 <quicksilver> in this context 'computable' means 'computable'
02:20:43 <rhz> wikipedia's defn of recursive function: "A function computable by a Turing machine, as a synonym for computable function"
02:20:48 <quicksilver> no more and no less.
02:21:01 <quicksilver> a function is computable by a particular system
02:21:07 <quicksilver> if that system can compute that function.
02:21:08 <vixey> recursive functions are defined in isolation of turing machines
02:21:16 <rhz> how?
02:21:43 <yitz> you mean general recursive
02:22:11 <DRMacIver> Incidentally, the interesting aspect of things which are "turing complete" isn't so much things which can do more than a turing machine (as we don't know of any) as things which can do a strict subset of what a turing machine can do. Maybe there's a more sensible definition for "computational process" in that context?
02:22:40 <rhz> oh Wolfram has a more detailed definition
02:22:58 <DRMacIver> e.g. computable by some sort of automaton.
02:24:22 <earthy> computable by some sort of rigorously specified process, rather
02:24:35 <yitz> DRMacIver: e.g., partial recursive functions
02:24:39 <earthy> not necessarily automaton. it may be a human executing a strict process
02:25:08 <DRMacIver> Automaton in the formal sense. :) It doesn't matter whether the execution of it is done by a human.
02:25:45 <DRMacIver> yitz: Sure. There are plenty of examples. (Do you mean primitive recursive functions?)
02:25:46 <yitz> DRMacIver: people do study functions that can be computed by things that can do more than a turing machinge (even though those things don't physically exist).
02:26:29 <vixey> like ZFS
02:26:34 <DRMacIver> Some people study what you can do with turing machines + oracles (like, what would I do if I had a turing machine with the added ability to solve the halting problem for a normal turing machine?)
02:26:44 <yitz> DRMacIver: mm, in our day we called them "partial recursive", as opposed to "general recursive", maybe the terminology has evolved.
02:27:03 <DRMacIver> Could also be a dialect difference between different universities and countries.
02:27:31 <vixey> general recursion can mean partial or total recursive
02:27:32 <yitz> DRMacIver: right. it turns out that there is a rich hierarchy of such functions. they give me a headache though.
02:27:34 <DRMacIver> To me "partial recursive function" is too suggestive of combining "partial function" and "recursive function", which is why the term confused me.
02:27:44 <earthy> ;)
02:27:48 <DRMacIver> yitz: Right. I don't know anything about the theory either. :)
02:27:50 <vixey> it's got two meanings, which kind of sucks
02:27:52 * earthy should dig up his lecture notes on recursion theory
02:28:07 <DRMacIver> (Also I misread your previous statement as a question, sorry)
02:28:34 <yitz> I took a course in it once. When they got to the infinite injury method, I ran out of aspirin.
02:28:50 <earthy> in which a very nice proof was given that markov transition matrices were turing-capable
02:29:14 <vixey> oh the markov thing is really neat
02:29:27 <DRMacIver> I've not taken a course on anything more godlike than a turing machine. :)
02:29:43 <DRMacIver> I've just occasionally glanced at scott aaronson writing about them and gone "Huh?"
02:29:45 <vixey> there are some programming languages based on it
02:29:56 <weilawei> is there a simple way to break something running in haskell? like.. htting some special key to stop it printing out 6 ^ 9999?
02:29:59 <weilawei> >_>
02:30:17 <weilawei> or you know, a really big range
02:30:26 <rhz> Control-C
02:30:27 <rhz> ?
02:30:42 <weilawei> ah yes.. didnt seem to work before.. stupid unresponsive slow POScomp
02:30:46 <yitz> kill -9
02:30:48 <DRMacIver> The Haskell standard specifies that if you squawk like a chicken and wear a lettuce on your head, programs in your presence are required to halt.
02:30:51 <weilawei> that's a bit too much
02:31:01 <weilawei> kill -9i
02:31:03 <weilawei> not the chicken bit
02:31:53 <rhz> DRMacIver, how is the program going to know that you are squawking?
02:32:10 <weilawei> monads?
02:32:14 <DRMacIver> @faq Can Haskell hear if the programmer is squawking?
02:32:15 <lambdabot> The answer is: Yes! Haskell can do that.
02:32:15 <yitz> when the heap starts sucking up all available memory and you don't hit ^C in time, sometimes kill is the only option
02:32:32 <weilawei> yitz, alt+sysrq+REIUSB
02:32:34 <rhz> Haskell can do anything it seems
02:32:55 * yitz looks for those keys on his macbook
02:33:06 <weilawei> sysrq is commonly known as print screen and it wont work on a mac
02:33:14 <weilawei> it's a linux kernel feature
02:34:04 <rhz> thinking about the definition of recursive function.. it is a bit unclear too unless one specifies the underlying types one is working with and various other things too...
02:34:05 <DRMacIver> What on earth is REIUSB?
02:34:10 <weilawei> magic sysrq key.. restores keyboard control, sync, term, kill, unmount, reboot
02:34:23 <weilawei> very very useful for uberstuck comps
02:34:26 <DRMacIver> rhz: Generally one assumes "tuples of integers"
02:34:36 <yitz> rhz: it's simplest to define in terms of positive integers only
02:34:40 <weilawei> if sysrq doesn't work, the kernel faulted or the CPU triple faulted
02:34:42 <rhz> tuples of what size?
02:34:52 <yitz> size = 1
02:35:12 <rhz> yitz, what operations is one allowed?
02:35:27 <weilawei> DRMacIver, you literally type alt+sysrq+r+e+i+u+s+b
02:35:32 <weilawei> no plusses
02:35:34 <weilawei> er..
02:35:36 <weilawei> crap
02:35:37 <DRMacIver> Well, that's not quite right. The recursive functions are defined in terms of functions  f : N^n -> N for all n
02:35:40 <DRMacIver> weilawei: Oh, right.
02:35:43 <weilawei> alt+sysrq+reiusnb
02:35:44 <weilawei> -n
02:35:55 * weilawei can't type at 5:30 AM\
02:37:59 <roconnor> u = unmount
02:38:02 <roconnor> b = boot
02:38:06 <roconnor> (the last step)
02:38:13 <roconnor> not sure of the others
02:38:25 <DRMacIver> http://en.wikipedia.org/wiki/Magic_SysRq_key
02:38:27 <lambdabot> Title: Magic SysRq key - Wikipedia, the free encyclopedia
02:39:03 <weilawei> reisub, sorry. it's busier, but backwards
02:39:18 <roconnor> oh right, sync
02:39:33 <weilawei> returns keyboard, sync drives, send TERM, send KILL, unmount, reboot
02:39:42 <roconnor> It seems to be a sort of progression. Your computer may become unstuck at anytime during the process
02:39:55 <weilawei> roconnor, this is true, but in practice it rarely does
02:40:37 <roconnor> "Raising Elephants Is So Utterly Boring
02:40:38 <weilawei> usually Bad Things (TM) have happened by the time I can't switch to another virtual console for the kill -9
02:40:48 <weilawei> busier is easier to remember ;)
02:40:53 <weilawei> jut flip it
02:40:58 <weilawei> *just
02:42:56 <thoughtpolice> this is absolutely absurd; darcs has been trying to just read the inventory of darcs.haskell.org/packages/base for probably an hour now and is using 99% cpu
02:43:24 <thoughtpolice> anybody else have an issue like this when trying to get the GHC head (specifically ./darcs-all pull -a)
02:43:29 <roconnor> sounds like what the rumours tell me about darcs :)
02:43:29 <thoughtpolice> ?
02:43:45 <roconnor> may want to try  #darcs
02:43:48 <yitz> rhz: there are different definitions of which operations are allowed. i don't remember what we used exactly, but it definitely wasn't what wolfram says.
02:44:59 <olsner> they say they've improved things with darcs-2 though :)
02:45:16 * thoughtpolice is using 2.0.2
02:45:40 <rhz> yitz, ok. I imagine it doesn't require many operations to become "turing-complete"...
02:45:53 <roconnor> oh
02:46:02 <roconnor> I thought darcs 2.0.2 was supposed to be all better :(
02:46:06 <thoughtpolice> on a related note, trying to get a copy of NDP (which is the primary reason I'm checking out the HEAD) by doing 'darcs get http://darcs.haskell.org/packages/ndp' was *also* absurdly slow.
02:46:34 <DRMacIver> Have the servers upgraded to the 2.0.x format?
02:46:44 <roconnor> ah, good point
02:46:57 <DRMacIver> Because otherwise I don't think darcs 2 is subtantially better. (I've no experimental verification for this though. I don't use darcs)
02:47:08 <thoughtpolice> i normally don't either
02:47:20 <thoughtpolice> but i'm not sure; just getting the GHC-head tarball from darcs.haskell.org was pretty bad too
02:47:42 <thoughtpolice> and I'm talking I had to let wget run for probably 7 hours to get a ~100mb file because it couldn't get anything above 5kb/s
02:48:07 <DRMacIver> Hm. darcs stores the latest version of the files in place in the repo. I wonder if "wget" doesn't make a good darcs get replacement. :)
02:48:11 <yitz> thoughtpolice: did you look at http://hackage.haskell.org/trac/ghc/wiki/Building/GettingTheSources?
02:48:14 <lambdabot> Title: Building/GettingTheSources - GHC - Trac, http://tinyurl.com/5rdyem
02:48:20 <thoughtpolice> yitz: yes, that's what I'm following
02:48:29 <yitz> it says in bold: you cannot use darcs get to get a full GHC repository
02:48:30 <thoughtpolice> DRMacIver: no, I was getting a copy of the full repository
02:48:35 <thoughtpolice> yitz: exactly
02:48:41 <DRMacIver> thoughtpolice: I meant in general
02:49:07 <thoughtpolice> so I did 'wget http://darcs.haskell.org/ghc-HEAD-...corelibs-testsuite.tar.bz2'
02:49:14 <thoughtpolice> and yeah, that took about 7 hours
02:50:39 <DRMacIver> Sounds like the problem might just be crappy servers
02:50:41 <thoughtpolice> so i don't know if just this internet really sucks, darcs.haskell.org needs a speed boost or there are more diabolical factors here like ninjas or something
02:50:53 <DRMacIver> Ninjas are often the culprit, yes.
02:50:56 <DRMacIver> Anyway, got to go.
02:50:59 <thoughtpolice> i was afraid of that
02:51:04 <thoughtpolice> you can fix bad internet and a crappy server
02:51:09 <_zenon_> Are there some Haskell groups in Sweden?
02:51:13 <thoughtpolice> a ninja is a little more of a challenge
02:52:26 <_zenon_> Ninjas are no match for haskell
02:53:09 <earthy> zenon: there's a group at Chalmers that does Haskell (and Agda and...)
02:53:26 <_zenon_> earthy: Which group is that?
02:53:53 <thoughtpolice> *sigh*
02:54:03 <thoughtpolice> screw it, i'ma ^C and go to bed
02:54:09 <_zenon_> whatIsLeftOfNinjaWhenHaskellIsDoneWithNinja _ = Nothing
02:54:44 <earthy> zenon: http://www.cs.chalmers.se/Cs/Research/Functional/
02:54:46 <lambdabot> Title: The Multi Group
02:57:21 <wuxia> hmm, so two different type classes can't have the same functions?
02:57:34 <wuxia> so if I have (==) already in Eq, then I can't have it in MyEq ?
02:58:31 <_zenon_> earthy, I was refering to more like an interest group, not a research group :)
02:59:43 <rhz> _zenon_, I think that a problem one sometimes encounters is that there is only so far one can go whilst being interested in something before one is forced to start researching it..
03:01:09 <_zenon_> rhz, I see no reason for why there can't be an interest group.
03:01:17 <olsner> _zenon_: I haven't heard of any such groups (yet)
03:01:23 <_zenon_> olsner, http://www.nabble.com/NW-Functional-Programming-Interest-Group-td15234371.html
03:01:25 <lambdabot> Title: Nabble - Haskell - Haskell - NW Functional Programming Interest Group, http://tinyurl.com/66bdc2
03:01:29 <earthy> zenon: that would be easier asked on #haskell.se methinks
03:01:32 <rhz> _zenon_, well the research group - don't they count?
03:01:38 <olsner> (in sweden, that is)
03:01:57 <_zenon_> rhz, Sure, however I doubt strongly that I will be accepted there.
03:02:27 <_zenon_> olsner, Maybe one should try starting one.
03:02:45 <earthy> good advice, _zenon_! Take it to heart! :)
03:10:35 <hackage> Uploaded to hackage: dnsrbl 0.0.1
03:15:30 <wuxia> how can i see what the code "deriving Ord" genera5tes looks like?
03:15:37 <rhz> _zenon_, what do you mean by accepted?
03:25:09 <_zenon_> rhz, Become a member of their group
03:26:38 <rhz> is it possible to define a function that is total but whos complexity is at least as large as any other function?
03:27:31 <rhz> _zenon_, well I suppose you could ask them and see
03:28:15 <_zenon_> rhz, Of course, however, I have nothing scientifical to contribute
03:29:55 <rhz> _zenon_, well how do you know that? Maybe you do but you don't realise it yet?
03:30:44 <_zenon_> rhz, Okay, I shall ask them.:)
03:30:59 <rhz> _zenon_, great
03:35:03 <rhz> *any other total function I should have said above
03:43:57 <Baughn> rhz: Short of having infinite complexity, I don't see how
03:44:09 <Baughn> No matter how complex it is, you should be able to construct an even worse one
03:48:51 <BeelsebobWork> @src mapM_
03:48:52 <lambdabot> mapM_ f as = sequence_ (map f as)
03:49:03 <BeelsebobWork> @src sequence_
03:49:04 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
03:49:58 <wuxia> how do I find the liknux equiv of Win32Misc.timeGetTime ?
03:50:20 <Baughn> wuxia: Search the library overview page for "time"
03:50:33 <BeelsebobWork> @hoogle time
03:50:35 <lambdabot> System.Time :: module
03:50:35 <lambdabot> Data.Time :: module
03:50:35 <lambdabot> System.Timeout.timeout :: Int -> IO a -> IO (Maybe a)
03:50:41 <BeelsebobWork> looks likely, yes?
03:51:01 <BeelsebobWork> @docs System.Time
03:51:02 <Baughn> Yep, but he did ask "how do I find", not "where is". ;)
03:51:02 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Time.html
03:51:25 <BeelsebobWork> right, well, the how do I find is what I did -- you type in @hoogle <thing you'd like>
03:51:30 <BeelsebobWork> and then look at the documentation
03:51:56 <wuxia> Baughn: BeelsebobWork : thanks
03:52:00 <Baughn> That's fine for type signatures and such, yes
03:52:11 <BeelsebobWork> Baughn: and random words too
03:52:15 <Baughn> When you're looking for a /category/ of stuff, searching the standard library and/or hackage makes more sense
03:52:28 <Baughn> BeelsebobWork: And it totally missed Data.Time ;)
03:52:36 <Baughn> Wait. No, it didn't.
03:52:38 <BeelsebobWork> Baughn: uh, second result
03:52:58 <Baughn> Dyslexia? No.. uh, blindness?
03:53:05 <BeelsebobWork> hehe
03:53:06 <BeelsebobWork> :D
03:53:20 <BeelsebobWork> in general, I find hoogle works very well
03:53:34 <BeelsebobWork> unless I am searching for a type signature, that has a lot of classes mess
03:53:45 <wuxia> @hoogle Draw
03:53:46 <lambdabot> Data.Tree.drawTree :: Tree String -> String
03:53:46 <lambdabot> Data.Tree.drawForest :: Forest String -> String
03:53:49 <BeelsebobWork> super-general type signatures tend to turn up crap all
03:54:47 <Baughn> wuxia: Okay, "draw"?
03:55:02 <wuxia> page 163 of SOE
03:55:08 <wuxia> import Draw
03:57:47 <Baughn> wuxia: Well, if it's SOE, you probably want the soegtk package
03:58:05 <Baughn> The version actually bundled with SOE has long since succumbed to bit rot, I believe
03:58:43 <wuxia> i'm pulling soe from  Graphics.SOE
03:58:55 <wuxia> it's worked so far for the first 12 chapters :-)
03:59:17 <Baughn> Hm. My version of ghc doesn't have it, but.. okay, if it works
03:59:26 <Baughn> Anyhow, "import Draw" isn't going to work
03:59:44 <quicksilver> I thnk you prepand 'Graphics.SOE' to everytging don't you?
03:59:47 <quicksilver> to get the compatibility packages?
03:59:51 <quicksilver> I've never used them myself.
03:59:54 <Baughn> Graphics.SOE.Draw, maybe. I don't know the hierarchy. Or were you supposed to write the module on your own?
04:00:36 <wuxia> i'm not su4re l... going to try more of the code in 13
04:00:53 <wuxia> and from there, i'll see what i'm suppoosed to get from this Draw module
04:10:38 <hackage> Uploaded to hackage: AERN-Real 0.9.4
04:12:50 <Cale> We have a hackage bot?
04:14:45 <wuxia> @hoogle openWindow
04:14:46 <lambdabot> No matches found
04:14:56 <wuxia> useless
04:38:37 <Syzygy|de> Oooooh! I'm on proggit!
04:40:21 <_zenon_> Syzygy|de, What's proggit?
04:40:46 <Syzygy|de> programming.reddit.com
04:41:05 <Syzygy|de> dons submitted the HaskellWiki OpenGL tutorials - which are basically copy-pasted from my blog.
04:43:55 <_zenon_> Syzygy|de, hm... Did you get some cred?
05:02:50 <Syzygy|de> Yeah.
05:02:59 <Syzygy|de> My name is given as source on the top of the wikipage.
05:03:06 <Syzygy|de> And I gave express permission before it got included.
05:08:05 <vixey> Cale: yes no hpaste bot though
05:09:34 <Cale> Who is running the hackage bot?
05:09:49 <vixey> I don't know, maybe dons
05:10:08 <mauke> dons said glguy
05:10:24 <vixey> oh does glguy work at galois?
05:12:44 <_zenon_> Syzygy|de, ah,.. I interpreted it a bit negative "which are basically copy-pasted from my blog." like, if you said it with a bit of distate :)
05:12:59 <_zenon_> Syzygy|de, however, it was just my personal interpretation
05:15:26 <masak> what's the closest equivalent to indexOf in Haskell?
05:15:55 <vixey> what's indexOf?
05:16:06 <_zenon_> @src indexOf
05:16:07 <lambdabot> Source not found. Sorry.
05:16:19 <masak> given a list and a possible element, it returns the first index containing that element
05:16:39 <_zenon_> masak, Check out the Data.List module
05:16:46 <vixey> indexOf x (e:es) | x == e = 0
05:16:47 <masak> _zenon_: thank you
05:16:50 <_zenon_> masak, you'll find a lot of good stuff there :)
05:16:56 <masak> :)
05:17:06 <vixey>                  | otherwise = 1 + indexOf x es
05:17:12 <vixey> you wont find this in Data.List
05:17:18 <_zenon_> masak, http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
05:17:20 <lambdabot> Title: Data.List, http://tinyurl.com/yhrw65
05:17:27 <masak> yup, found it
05:18:09 <mauke> @hoogle [a] -> a -> Int
05:18:10 <lambdabot> No matches, try a more general search
05:18:14 <mauke> @hoogle [a] -> a -> Maybe Int
05:18:15 <lambdabot> Data.List.elemIndex :: Eq a => a -> [a] -> Maybe Int
05:18:54 <masak> ah, it's called elemIndex
05:19:21 <masak> and it has a more powerful cousin findIndex
05:21:04 <therp> can anyone point me to a small scale example using the category-extra package?
05:21:39 <vixey> > map fst . filter (('e'==) . snd) . zip [0..] $ "elephant"
05:21:43 <lambdabot>  [0,2]
05:21:48 <therp> I'd like to see the definitions of FAlgebra and cata in action, but I have trouble coming up with examples on my own
05:25:02 <roconnor> http://haskell.org/haskellwiki/Zygohistomorphic_prepromorphisms
05:25:03 <lambdabot> Title: Zygohistomorphic prepromorphisms - HaskellWiki
05:26:24 <masak> only in the Haskell world am I unsure whether that name is a joke or not.
05:26:35 <vixey> heh
05:26:38 <vixey> the name is real
05:27:01 <mauke> http://haskell.org/haskellwiki/?title=Special:Whatlinkshere&target=Zygohistomorphic_prepromorphisms
05:27:03 <lambdabot> Title: Zygohistomorphic prepromorphisms - HaskellWiki, http://tinyurl.com/5bcquu
05:27:33 <masak> if it's linked from Real World, it _must_ be real...
05:32:07 <mehrheit> oh, new chapters in Real World #haskell
05:32:16 <mehrheit> can't wait for it's release
05:37:30 <BONUS> awesome
05:37:31 <BONUS> yeah me too
05:37:36 <BONUS> gonna preorder it :]
05:42:38 <roconnor> I'm gonna complete lattice it
05:43:44 <vixey> lol
05:43:51 <_zenon_> Oh, would be nice to have a copy @ home
05:43:56 <pyNem> i am learning haskell now .. how do i set my editor to vim in ghci or something? when i do :e test.hs it says editor is not set.
05:44:32 <roconnor> vixey: sadly "preorder" doesn't invoke the same ideas for me that it does for normal people.
05:44:36 <_zenon_> however, damn customs always push the price up a bit
05:45:06 <mehrheit> pyNem: try setting the EDITOR environment variable to vim
05:45:07 <vixey> everyone else is crazy :p
05:45:25 <pyNem> mehrheit, in bash?
05:45:42 <mehrheit> yes, and export it
05:46:49 <pyNem> mehrheit, thanks :) it worked
05:47:37 <mehrheit> you can also ':set editor vim' in ghci
05:48:30 <profmakx> eh
05:48:33 <pyNem> mehrheit, oh :) .. is there a .ghcirc or something where i can put these commands to run at startup?
05:48:51 <mauke> ~/.ghci
05:49:17 <pyNem> mauke, i put them in as they are ? without any prefixes?
05:49:27 <mauke> my file has prefixes
05:49:27 <Asgaroth> is there an operator for binary and of two integers(like & in C)?
05:49:35 <mauke> Asgaroth: .&.
05:49:42 <Asgaroth> mauke: ah. thanks
05:50:16 <masak> are there other useful modules like Data.List that I should know about? :)
05:50:40 <DRMacIver> You should really commit the entire standard library to memory.
05:51:01 <masak> sounds like a plan.
05:51:40 <masak> any good place to get an overview of the standard library?
05:51:56 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
05:52:00 <pyNem> DRMacIver, as somone who is a just learning haskell, are you serious about committing the entire thing to mem?
05:52:04 <DRMacIver> No.
05:52:09 <Cale> Those are the libraries that come with GHC
05:52:12 <pyNem> mauke, it worked :)
05:52:12 <Cale> (and Hugs)
05:52:17 <DRMacIver> There's rather a lot of it. :)
05:52:30 <pyNem> DRMacIver, oh .. sorry for the n00bish q then ..
05:52:31 <DRMacIver> I mean, a good knowledge of the standard library is important, same as in any language.
05:52:40 <Cale> Eventually you'll learn a lot of it anyway.
05:52:50 <pyNem> DRMacIver, yeah i got that :) ..
05:52:53 <DRMacIver> But there's no point in actively setting out to memorize it
05:53:05 <DRMacIver> (Also same as in any language)
05:53:06 <pyNem> DRMacIver, yeah :)
05:53:16 <masak> need-to-know basis :)
05:53:17 <Cale> But the really important ones are probably Data.List, Control.Monad, and I suppose Data.Set and Data.Map
05:53:37 <masak> Cale: thanks. that answered my question.
05:53:45 <pyNem> DRMacIver, are there like modules for everything? As in python like import foo; foo.do(); sys.exit(0) ? (inc. third party)
05:54:06 <mauke> pyNem: yeah, more or less
05:54:10 <Cale> That'd be a great start anyway :)
05:54:14 <DRMacIver> It's not on par with python yet. There are quite a few though. :)
05:54:41 <Cale> It's also important to know about hackage: http://hackage.haskell.org/packages/archive/pkg-list.html
05:54:44 <DRMacIver> "on" from Data.Function is worth knowing about in the minimal bag of tricks as well.
05:54:44 <lambdabot> Title: HackageDB: packages by category
05:54:44 <masak> when will I need to worry about arrows? I think I'm starting to grok monads now.
05:54:50 <pyNem> mauke, DRMacIver, i am going to love this then :)
05:55:00 <mauke> masak: I haven't learned arrows yet
05:55:11 <Cale> masak: Well, if you ever need to use a library which uses the arrow combinators.
05:55:15 <mauke> except for stuff like (&&&) and (***), which is useful in pointless code
05:55:21 <masak> ok.
05:55:26 <pyNem> DRMacIver, the main reason i started learning haskell was the difference in times i saw when a friend of mine fired up python interpreter and ghci and did (some large no.) ^ (some other large no.)
05:55:40 <Cale> Control.Applicative is another interesting approach along those lines
05:55:58 <pyNem> DRMacIver, but now, i am starting to appreciate the func prog paradigm too :)
05:56:21 <masak> wow! `on` seem pretty neat!
05:56:26 <Cale> Monad/Applicative/Arrow/Comonad/etc. are all just ways to structure libraries. You don't really need to know about them until you want to use a library which uses them, or write such a library yourself :)
05:56:43 <Cale> Of course, Monad is pretty important in Haskell, since you use the monad operations to compose IO actions.
05:57:13 <DRMacIver> pyNem: Would it turn you off if I told you that that's just because ghc uses a highly optimised C + ASM library for its arbitrary precision integers (it uses GMP)? :)
05:57:20 <mauke> Monoid can be useful in surprising ways
05:57:30 <Cale> Yes :)
05:57:58 <SamB_XP> DRMacIver: well, why doesn't Python have such an optimized implementation?
05:58:44 <pyNem> DRMacIver, it would have initially, but i have started appreciating other things about haskell. I love math. Haskell is very close to math. Loved the whole purity of it. Starting to like the whole lazy eval thing too :).
05:58:51 * SamB_XP is guessing it has to do with licensing and compiler bugs?
05:58:58 <vixey> > map (+) <$> [1,2,3] <$> [4,5,6]
05:59:01 <vixey> > map (+) <$> [1,2,3] <*> [4,5,6]
05:59:03 <SamB_XP> (and/or GMP bugs)
05:59:05 <lambdabot>  Couldn't match expected type `a -> f a1'
05:59:05 <lambdabot>   add an instance declaration for (Num (a -> a1))
05:59:57 <mauke> > (+) <$> [1,2,3] <$> [4,5,6]
05:59:58 <lambdabot>  Couldn't match expected type `a -> a1' against inferred type `[a2]'
06:00:04 <mauke> > (+) <$> [1,2,3] <*> [4,5,6]
06:00:06 <lambdabot>  [5,6,7,6,7,8,7,8,9]
06:00:31 <vixey> instead of
06:00:31 <vixey> map3 f [] [] [] = []
06:00:31 <vixey> map3 f (x:xs) (y:ys) (z:zs) = f x y z : map3 xs ys zs
06:00:34 <vixey> what do you do ?
06:00:45 <mauke> :t zipWith3
06:00:45 <lambdabot> forall a b c d. (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
06:00:57 <vixey> oh cool
06:01:15 <vixey> there's not some applicative form for it though?
06:01:21 <mauke> > getZipList ((,,) <$> ZipList "foo" <*> ZipList "bar" <*> ZipList "baz")
06:01:21 <lambdabot>  [('f','b','b'),('o','a','a'),('o','r','z')]
06:01:33 <vixey> ohh ok
06:01:49 <mauke> orz
06:08:02 * SamB_XP wonders if the "wood" article *really* has an "in popular culture" section...
06:08:16 <Cale> It doesn't
06:08:23 <SamB_XP> okay ;-)
06:08:24 <Cale> (Or it didn't when I checked)
06:08:56 <Cale> I wonder if someone has tried to add it since that comic came out :)
06:09:02 <jaj> Hi! I was wondering if anybody looked into writing gtk2hs bindings for webkit-gtk.
06:09:08 <mauke> http://en.wikipedia.org/wiki/Talk:Wood#In_Popular_Culture_.28see_http:.2F.2Fxkcd.com.2F446.2F.29
06:09:09 <lambdabot> Title: Talk:Wood - Wikipedia, the free encyclopedia, http://tinyurl.com/5dl4bs
06:09:21 <SamB_XP> Cale: I hope nobody was stupid enough to think that was a good idea
06:09:23 <dcoutts> jaj: not yet
06:09:26 <SamB_XP> since it would NEVER END
06:09:39 <dcoutts> jaj: it would be a good thing to do, if you're looking for a project
06:09:57 <jaj> dcoutts: do you think it would be hard to do? since it relies a lot on gobject
06:10:16 <dcoutts> jaj: we have gobject bindings in gtk2hs and a code generator
06:11:07 * SamB_XP is very very late...
06:11:13 <lilachaze> SamB_XP: it needs an In Popular Culture section which references xkcd
06:11:21 <jaj> I'm currently writing a minimalist webkit based browser which can be controlled using only the keyboard in C but I'd really love to do it in haskell.
06:11:23 <mauke> lilachaze: see my link
06:11:39 <bos> dcoutts: we've finally turned on opengl support in the fedora build of gtk2hs. there are still a few optional bits unbuilt: svg, gnomevfs, and gstreamer. are these worth turning on?
06:11:46 <jaj> but I never used ffs, c2hs and all this stuff
06:11:57 <dcoutts> bos: the svg bit is, it's pretty handy
06:12:27 <bos> ok, cool.
06:12:36 <dcoutts> bos: and it uses the standard librsvg so you'll have all the stuff already
06:14:07 <lilachaze> mauke: that's not in the article though :)
06:15:00 <jaj> ffi rather. is there any tutorial out there on how to write haskell bindings for various libraries?
06:19:02 <DRMacIver> SamB_XP: I have no idea. :)
06:46:04 <rhz> anyone know what the approximate male to female ratio is of people that frequent this irc channel?
06:46:06 <ddarius> Is it just me or should that "Haskell-Edu" thread have ended over a week ago?
06:48:16 <ADEpt> rhz: since each participant is either male or female, naive view is 50%/50% ;)
06:49:19 <ddarius> ADEpt: I believe, world-wide, there are more females than males.
06:50:11 <ADEpt> ddarius: ok, I stand corrcted: 51%/49%
06:51:13 <quicksilver> rhz: somewhere between 40/1 and 400/1 :P
06:51:25 <rhz> that would be if the Haskell irc users actually represented an arbitrary cross section of the society
06:51:31 <paczesiowa> is there any specific reason that there are no read functions in bytestring for Floating ?
06:51:35 <rhz> quicksilver 40 male to 1 female?
06:51:45 <quicksilver> yes.
06:52:01 <xci> though we should definitely take into consideration that there are much more males in china as opposed to females and additionally more males are born
06:52:07 <xci> all over the world
06:52:40 <xci> and women don't live longer in developing countries
06:54:18 <xci> I would guess that there are more males
06:54:21 <rhz> wouldn't Chinese people have a much harder time programming in a language based on English like Haskell, unless they were fluent in English?
06:55:04 <quicksilver> most programmers in whichever language are forced to obtain a working knowledge of english
06:55:05 <vixey> Yeah I was quite shocked when I found out that the English language has completely taken over programming
06:55:05 <scook0> pretty much all PLs in use today are "in English", aren't they?
06:55:16 <quicksilver> most documentation, most websites are in english.
06:55:46 <scook0> unless you love ocaml or ruby :)
06:55:46 <quicksilver> (the fact that the syntax of a few keywords is english is hardly important, what matters is that all the standard library docs are)
06:56:10 <vixey> scook0: What is it about ocaml or ruby?
06:56:50 <scook0> from what I hear, ocaml has quite good french docs, and ruby has quite good japanese docs
06:56:51 <RayNbow> http://en.wikipedia.org/wiki/Ruby_%28programming_language%29
06:56:51 <lambdabot> Title: Ruby (programming language) - Wikipedia, the free encyclopedia
06:57:01 <vixey> oh
06:57:01 <RayNbow> "Ruby originated in Japan during the mid-1990s and was initially developed and designed by Yukihiro "Matz" Matsumoto"
06:57:07 <scook0> (I was responding to the point about docs and websites)
06:57:21 <vixey> RayNbow: Even the implementation of Ruby is english
06:57:39 <vixey> I mean in C .. but with english language docs.. comments.. names..
06:57:42 <vixey> it is very strang
06:58:20 <vixey> there are about 400 that come here to talk about haskell, out of everyone in the world
06:58:51 <vixey> but there are not communities of people talking about haskell or lisp or anything in different languages
06:59:24 <Asgaroth> vixey: i guess there's not enough interest for languages like haskell in one single country
06:59:29 <quicksilver> sure there are, vixey
06:59:36 <quicksilver> there are IRC channels for several other languages
06:59:47 <vixey> Asgaroth: no not like haskell, I am talking about every language
07:00:15 <vixey> well #haskell.jp has nobody in it
07:00:35 <quicksilver> a few of the others have had traffic at times
07:00:37 <vixey> I couldn't find any foriegn language IRC for any lisps
07:00:39 <quicksilver> nothing like here though, as a rule
07:00:51 <vixey> yes it is very strange
07:00:56 <vixey> I don't understand why this is
07:01:11 <vixey> maybe they are all busy hacking code
07:01:13 <Asgaroth> it makes sense actually, since with more people in the channel, you're more likely to get an answer
07:01:19 <paczesiowa> oh I get it now why in bytestring lib there are only read functions for integers, dons needed it to write beautiful shooutout entry for sumfile:P
07:01:34 <Asgaroth> and since most people speak english there are the most people in english channels
07:01:34 <RayNbow> there are non-English communities for certain programming languages, but not all of them are on IRC
07:02:06 <rhz> paczesiowa, that sounds Polish. Do you write code using Polish words or English?
07:02:10 <vixey> RayNbow: really? I have looked but not found any
07:02:37 <Asgaroth> there are discussion boards for many languages (at least german ones)
07:02:48 <Asgaroth> in many languages
07:02:53 <RayNbow> vixey, try the programming language PHP... I'm sure you can find a non-English community :p
07:03:17 <paczesiowa> rhz: that depends on my mood, the more angry I am - the more polish cursing is in code:>
07:03:47 <Quadrescence> What is the difference between hugs and GHC? D:
07:03:52 <rhz> so you reserve you good mood for English?
07:03:56 <quicksilver> they are different implementations, Quadrescence
07:04:01 <quicksilver> they have a million differences.
07:04:05 <Quadrescence> :O
07:04:07 <paczesiowa> rhz: yes
07:04:13 <vixey> GHC is better :p
07:04:14 <quicksilver> hugs is said to be a faster interpreter
07:04:25 <quicksilver> ghc has a native code compiler and many more extensions
07:04:37 <RayNbow> Hugs is fine for learning Haskell basics
07:04:46 <Saul_> I really don't think there is a reason to use hugs
07:05:01 <quicksilver> I'm only aware of one advantage of hugs
07:05:05 <quicksilver> it's claimed to be faster
07:05:09 <Quadrescence> Well, I have GHC and all that (well, that's it) installed. I was just wondering, because I see it occasionally.
07:05:09 <quicksilver> but I've never found ghci to be slow.
07:05:21 <quicksilver> ndm says he prefers winhugs' interface
07:05:25 <Saul_> I've used it in a introductory course on Haskell, but that would work with GHC just as well
07:05:34 * RayNbow hates the WinHugs interface :p
07:05:35 <quicksilver> it is unusual for ndm and I to ever agree on something about user interfaces
07:05:42 <quicksilver> and this is certainly a case when we disagree.
07:06:06 <rhz> There was a time I think when Hugs was the only interpreter for Haskell in existence.
07:06:13 <Saul_> even if ghci is a bit slower, who cares? it's only for testing
07:06:37 <Quadrescence> Can I troll about "how hard Haskell is"? It's 9AM in the morning. :D
07:06:42 <Asgaroth> and one has already installed it as a dependency for xmonad anyway ;)
07:06:48 * RayNbow used to use the console version of Hugs instead of the GUI version
07:06:49 <Quadrescence> (that was redundant)
07:07:00 <Saul_> rhz: That's true, but ghc gives a complete package these days
07:07:16 <vixey> has anyone noticed this kind of pattern before?  foo f = \x -> (f (\y -> ... x y ... )) ?
07:07:18 <Saul_> Quadrescence: Haskell isn't hard, it's just alien at first
07:07:35 <quicksilver> rhz: I don't think that's true.
07:07:40 <quicksilver> I think hbi goes back as far as hugs.
07:08:03 <rhz> ok then perhaps Hugs used to be the best interpreter
07:08:26 <quicksilver> hugs is proabbly the most portable.
07:08:32 <quicksilver> It's written in fairly portable C.
07:08:34 <ddarius> quicksilver: I've never heard anyone claim that Hugs is faster.  It -loads- faster is all I've heard.
07:08:45 <quicksilver> ghc is not particularly portable.
07:08:52 <quicksilver> ddarius: yes, that's actually what I meant.
07:09:11 <quicksilver> ddarius: a faster interpreter in the sense of "the compilation phase of interpretation is faster"
07:09:12 <Asgaroth> quicksilver: well it should be available on most unixes, shouldn't it?
07:09:35 <quicksilver> Asgaroth: can you compile GHC for my debian/mips or my debian/arm?
07:09:42 <quicksilver> because if you can, I'll be very happy :)
07:09:44 <quicksilver> no one else can.
07:10:26 <ddarius> hbi is likely the best Haskell interpreter.
07:11:24 <Asgaroth> quicksilver: good point. i was only thinking of different OSes not of different architectures
07:11:49 <quicksilver> well being portable to "most unixes" by virtue of only using portable functions from the BSD/POSIX common subset
07:11:57 <quicksilver> is not really a huge portability acheivement :P
07:12:17 <quicksilver> the point is GHC doesn't have native code backends for anything other than x86/ppc
07:12:21 <quicksilver> and bootstrapping it is hard
07:12:33 <quicksilver> and the art of doing unregisterised builds is dying
07:12:34 <quicksilver> ;)
07:12:50 <rhz> well basically I just remember using Hugs when I was first trying to learn Haskell quite some years ago. At that stage GHCi didn't exist yet I think.
07:13:19 <Quadrescence> Would anyone care to explain what this is a little more? http://www.haskell.org/happy/
07:13:20 <lambdabot> Title: Happy: The Parser Generator for Haskell
07:13:39 * vixey thinks it was a bad time to ask
07:13:44 <Quadrescence> D:
07:16:39 <vixey> Quadrescence: What do you want to know about it?
07:17:03 <Quadrescence> Well, what might be "a typical" application of it?
07:17:15 <vixey> Parsing C code
07:17:24 <vixey> then printing out bindings for use in other haskell programs
07:17:35 <mmorrow> Quadrescence: http://darcs.haskell.org/haddock/src/HaddockParse.y
07:18:28 <vixey> Quadrescence: (do you know what parsing is?)
07:18:38 <mmorrow> Quadrescence: here's ghc's parser (not a good starting example) http://darcs.haskell.org/ghc/compiler/parser/Parser.y.pp
07:18:50 <Quadrescence> vixey: (If the definition is more-or-less universal, yes)
07:19:02 <rhz> what I think is more interesting than the fact that most Haskell users speak English is the fact that they are male rather than female. Why is that?
07:19:51 <Quadrescence> rhz: I'd venture to say that is nearly universally true.
07:20:05 <Cale> rhz: It's no worse than with other programming languages.
07:20:07 <Quadrescence> (i.e., for all programming languages)
07:20:10 <rhz> Quadrescence: what is?
07:20:33 <Quadrescence> That men are more populous in the coding ... population.
07:20:53 <vixey> the first programmer was a woman :)
07:20:59 <mmorrow> rhz: have you ever been in a cs/math/engineering class at any (coed) university?
07:21:06 <rhz> well I'd venture to guess there may be a larger ratio of females involved in web design work
07:21:07 <Quadrescence> The only time I remember a female coder was the ENIAC women. :O
07:21:33 <rhz> but yes I suppose there are more males involved in coding in general
07:21:41 <rhz> but the question remains - why??
07:22:44 <Cale> rhz: Cultural reasons.
07:22:44 <mmorrow> i've read articles that give various theories
07:23:00 <mmorrow> most say what Cale just did
07:23:07 <Quadrescence> Supposing we ignore the fact that I am generalizing, I think men usually work more.
07:23:15 <Quadrescence> Yeah, what Cale said. D:
07:23:19 <Saul_> Would anybody mind if I did a small rewrite of the HSQL library?
07:23:44 <rhz> Cale, I'm not quite sure I understand what you mean by "Cultural Reasons"
07:23:48 <mmorrow> Saul_: I'll help. I use it a bunch and have a lot of things I could add
07:23:52 <Cale> Saul_: More Haskell code is always good. :)
07:24:00 <Saul_> I want to take the IO functions and make it of type MonadIO m
07:24:50 <Cale> rhz: As in, computer science is generally viewed as a male activity and thus it attracts more males than females. There's no reason that women can't do well at it, it's just that in general they seem more interested in doing other things.
07:24:52 <mmorrow> Saul_: why? I usually use it in other monads which are MonadIO and then just liftIO
07:25:01 <paczesiowa> Saul_: I wouldn't mind if you'd rewrite every lib that way:>
07:25:17 <paczesiowa> mmorrow: there is plenty of lifting then
07:25:25 <Cale> rhz: I've known quite a few really talented female programmers, computer scientists and mathematicians.
07:25:30 <Saul_> mmorrow: That usually works, but not in things like transactions
07:25:42 <mmorrow> Saul_: cool. go for it :)
07:26:06 <Saul_> I'll try that and get back to you when I'm done
07:26:15 <mmorrow> awesome
07:26:48 <paczesiowa> Saul_: what do you mean that it doesn't work with transactions? it always works, it's just looks bad when you do 10 things and you have to lift 9 because of one middle already lifted thing
07:27:38 <rhz> Cale, maybe so. Were any of them interested in FPS games?
07:27:58 <quicksilver> I'd like to see all IO lifted to monadIO
07:28:05 <quicksilver> it's not so easy where there are callbacks though
07:28:11 <Saul_> paczesiowa: The transaction function is of type Connection -> (Connection -> IO) -> IO
07:28:12 <quicksilver> and inversion of control is quite common in haskell
07:28:21 <Cale> rhz: Not particularly.
07:28:27 <quicksilver> yeah, then you need an interleavable constraint
07:28:39 <Saul_> which means you can't use monadIO m in the argument function
07:28:53 <rhz> Cale, my point there is that the FPS game developers and players are probably almost exclusively males
07:29:00 <quicksilver> well you can, Saul_, it's just a bit more work.
07:29:06 <quicksilver> and you can't make it completely general
07:29:07 <zachk> on more male coders: the male fetus when it develops gonads, those gonads begin producing testosterone which causes irreversible brain damage to the male fetus's brain, it seperates the emotional part of his brain from the logical part of his brain, so men are hence brain damaged from birth, comp sci is more logic then emotion, so any emotion would most likely just get in the way or cause you to add a crazy easter egg to a program you have worked on for 3 years
07:29:08 <scook0> how easy is it to tunnel past the IO type?
07:29:09 <paczesiowa> Saul_: you have to lift argument too I think
07:29:14 <quicksilver> but it works for the common monads.
07:29:19 <scook0> (i.e. I know it's possible, but how real-world feasible is it?)
07:29:30 <vixey> rhz: burger is female, she wrote wolfenstien
07:29:36 <vixey> (which is an FPS)
07:29:43 <quicksilver> scook0: http://www.haskell.org/pipermail/haskell-cafe/2007-July/028501.html
07:29:44 <lambdabot> Title: [Haskell-cafe] Monadic tunnelling: the art of threading one monad through anothe ..., http://tinyurl.com/3xmhco
07:29:55 <roconnor> vixey: that's awesome
07:30:09 <chazzwazzer> Hoh.. I installed Cabal yesterday, and now I try to install cabal-install and it says: Setup.hs: At least the following dependencies are missing: Cabal >=1.4 && <1.5         . How do I configure ghc to actually find Cabal ?
07:30:09 <vixey> oops wolfenstein
07:30:10 <zachk> i thought carmack wrote wolfenstein 3d?
07:30:28 <rhz> yeah I thought it would have been that Carmack person
07:30:29 <scook0> quicksilver: yeah, that's what I meant by "I know it's possible"
07:30:32 <vixey> zachk, he wrote quake 3 (and about a billion others)
07:30:43 <Saul_> quicksilver: I didn't know that
07:30:46 <dcoutts> chazzwazzer: use ghc-pkg list to see if Cabal-1.4.x is installed
07:30:49 <pejo> chazzwazzer, which version of cabal did you install yesterday?
07:31:04 <chazzwazzer> pejo: Good question. I just grabbed one from hackage.
07:31:32 <chazzwazzer> dcoutts: ghc-pkg list  says it's there.
07:31:49 <chazzwazzer>     Cabal-1.4.0.1
07:32:12 <dcoutts> chazzwazzer: if it's in the user db then you need to configure with --user to tell Cabal to look in the user package db
07:32:19 <chazzwazzer> oh ok.
07:32:32 <zachk> vixey: "Burger" Bill Heinemann -> http://www.3drealms.com/news/1998/08/wolfenstein_3d_2.html, ive heard of a boy named Sue, but a girl named Bill? Billy mayhaps
07:32:33 <lambdabot> Title: 3D Realms News: Wolfenstein 3D for the Apple IIgs
07:33:02 <chazzwazzer> dcoutts: Excellent, that works. Thanks :)   Is there a way to tell ghc to use --user by default?
07:33:06 <dcoutts> chazzwazzer: cabal-install uses --user by default, but previously --global was the default, so configuring things with runhaskell Setup.hs configure often needs --user
07:33:27 <chazzwazzer> Ho hum.
07:33:30 <dcoutts> chazzwazzer: as I say, cabal-install uses more sensible defaults so you should not find it's a problem in future
07:33:42 <chazzwazzer> My worry here is that later on ghc and runghc will be using the globally installed packages.
07:33:59 <dcoutts> chazzwazzer: no, they use both
07:34:21 <chazzwazzer> Hmmm.. So why the need of --user then? ;)
07:35:08 <dcoutts> chazzwazzer: because historically Cabal defaulted to global installs to /usr/local
07:35:35 <dcoutts> chazzwazzer: and so if it's doing global installs then it's vital that it not look at packages in the user package db.
07:35:51 <chazzwazzer> oh ho. That makes sense.
07:35:53 <chazzwazzer> Thanks :)
07:35:54 <dcoutts> chazzwazzer: now that cabal-install does per-user installs by default it uses the user package db too.
07:36:10 <rhz> Looks like Wolfenstein 3D was written by a male
07:40:36 <chazzwazzer> Right that seems to have sorted things out. Now  for ghc --make, is there anything like make -j4 ?
07:41:48 <rhz> zachk: I'm not so convinced by your theory that brain damage due to testosterone production is the reason more males code though
07:44:45 <zachk> rhz: well in men they have "logical thoughts" and then crazy feelings they dont have words for, i think these are what people call "emotions" though im not sure
07:45:34 <rhz> zachk: "crazy feelings"
07:45:35 <rhz> ?
07:45:48 <chazzwazzer> Hoh.. ok. How do I uninstall with cabal-install?
07:46:01 <vixey> chazzwazzer: I don't think that you do
07:46:19 <chazzwazzer> eh.
07:46:21 <dcoutts> chazzwazzer: there's no support for that yet, you can unregister using ghc-pkg --user unregister and files have to be deleted manually
07:46:26 <Philippa> zachk: in light of the pretty well-documented social factors you've got a big burden of proof there
07:46:36 <chazzwazzer> :S
07:47:34 <Saul_> mmorrow: Hmm HSQL's execute in the source code return (), while when I use it it returns an Integer (presumably the number of fields affected(?))
07:47:47 <Philippa> hell, there're big social factors in how men handle emotions
07:48:21 <zachk> anyone else: <Think> that we should start teaching all children to code to some degree so we do not become mastered by machines in a few generations?
07:49:00 <Philippa> no: I think there are far better reasons to do that
07:49:07 <vixey> I think they should teach logic in school
07:49:18 <chazzwazzer> I think it's better to teach children to do things like welding.
07:49:21 <vixey> then I wouldn't have these huge gaps in my understanding of mathematics
07:49:27 <zachk> algebra was easy cause i already knew BASIC and about variables
07:49:47 <zachk> LOGO was also quite cool in 3rd grade
07:50:40 <vixey> Logo is very nic
07:50:41 <chazzwazzer> I don't quite understand here. I do cabal install alex. It does shit. Still yi says I need alex. Anyone have any idea?
07:51:08 <vixey> chazzwazzer: Install Alex (not using cabal)
07:51:13 <dcoutts> chazzwazzer: currently we install progs into ~/.cabal/bin which is probably not on your path
07:51:45 <dcoutts> chazzwazzer: so if you used cabal-install to install alex, check if you've got ~/.cabal/bin/alex
07:51:53 <rhz> Philippsa and zachk: perhaps it would be best to somehow raise children that are inclined to learn for themselves
07:53:00 <zachk> rhz: do you have any experience in the matter? cause im so going to be a newbie in that matter
07:53:14 <rhz> zachk: in raising children? No.
07:53:49 <rhz> although I have some experience in having been a child
07:54:20 <zachk> likewise, and furthermore i was inclined for quite some time to learn for myself, went up to about highschool level material, then just stopped
07:55:42 <rhz> yeah puberty can do that
07:56:57 <Quadrescence> LOGO
07:57:07 <Quadrescence> That must have been the first language I really liked.
07:57:27 <vixey> Quadrescence: You know how it's basically a weird looking lisp?
07:57:44 <Quadrescence> Logo?
07:57:48 <vixey> yes :)
07:58:01 <Quadrescence> I would not have related logo and lisp.
07:58:06 <zachk> rhz: i more or less hit calculus and went derrrr, uh puberty, didnt really get any females for a long long time
07:58:12 <vixey> We were drawing fractals with it in class, everyone else was trying to write to polygon :n :side
07:58:41 <zachk> vixey: you were doing that as a child? i never got much past the polygons :-(
07:59:16 <zachk> though i did code in multiple turtles and a thing that could answer yes or no questions yes or no or tell you that your question was not a yes or no question
07:59:27 <vixey> that's pretty cool
07:59:47 <Quadrescence> The only thing big I did was draw a cat with a box-y body. D:
08:00:00 <chazzwaz1er> maj gadd.
08:00:13 <vixey> I can do that with an etch-a-sketch :p
08:00:18 <chazzwaz1er> Anyway. I do cabal install alex, and yet Yi says I need alex. Anyone have any idea here?
08:00:22 <FordCortina> does anybody know where i can find a list of valid language pragmas?
08:00:32 <paczesiowa> ghc docs?
08:00:47 <zachk> vixey: what kind of fractals?
08:00:49 <dcoutts> chazzwazzer: so was alex installed at ~/.cabal/bin/alex ?
08:00:58 <chazzwazzlen> dcoutts: Yes.
08:01:00 <Cale> ghc --supported-languages
08:01:07 <Quadrescence> vixey: I treated Logo like etch-a-sketch. This was before I knew anything about programming. D:
08:01:16 <dcoutts> chazzwazzer: put ~/.cabal/bin/ on your path and it'll work
08:01:41 <FordCortina> thanks
08:01:47 <rhz> zachk: Well I think I actually learned calculus after I went through puberty but nevertheless I do remember puberty being a problematic experience
08:01:58 <zachk> i was first shown logo in kindergarten, they took us 3 at a time to a back room and showed it to us on an apple2e
08:02:10 <Quadrescence> (hehe, I used http://www.microworlds.com/solutions/mw.html for logo back in the day when they had that version on Windows)
08:02:11 <lambdabot> Title: LCSI - Solutions - MicroWorlds 2.0
08:02:26 <Philippa> by my teens I'd been writing a fair number of small file-processing utilities - some of them for doing stuff to the samples I was tracking with. Didn't get round to actually writing a MOD player though
08:02:29 <chazzwazzler> dcoutts: Oh tahnks a bunch.
08:03:27 <vixey> Quadrescence: oh that's good software
08:03:40 <vixey> for education
08:03:48 <Philippa> zachk: we had the BBC micros over here
08:03:59 <Quadrescence> Interesting enough, my programming route went logo > applesoft basic (I bought an apple //e on ebay for this reason D:) > qbasic > FreeBASIC (I've done most things here) > And now Haskell
08:04:15 <zachk> i stole my copy from school when my comp teacher wasnt looking, ahh  disckcopy, though the copy protection made my logo command prompt look like garbage, but it still worked
08:04:18 <vixey> basic to haskell.. wow :)
08:04:20 <RayNbow> http://www.engadget.com/2008/07/15/intel-bringing-quad-core-cpus-to-laptops-next-month/ <-- yay, multicores :)
08:04:22 <lambdabot> Title: Intel bringing quad-core CPUs to laptops next month? - Engadget, http://tinyurl.com/5fgs2g
08:04:42 <zachk> basic to haskell...nice jump
08:04:49 <Quadrescence> :)
08:05:01 <mmorrow> <Saul_> mmorrow: Hmm HSQL's execute in the source code return (), while when I use it it returns an Integer (presumably the number of fields affected(?))
08:05:11 <Quadrescence> Are there some intermediate steps I should have taken? :P
08:05:17 <mmorrow> Saul_: yeah, number of rows affected
08:05:27 <zachk> Quadrescence: can you do recursion?
08:05:28 <vixey> Quadrescence: no, just very unusual
08:05:39 <mmorrow> Saul_: hmm, but you say it returns () in the src? i'll look
08:05:41 <vixey> zachk: not in basic :p
08:06:01 <zachk> vixey: either or recursion is recursion
08:06:32 <Quadrescence> zachk: I made a Fast Fourier transform/bignum multiply program in O(n log(n)) in FreeBASIC that can loop or recurse. :D
08:06:36 <Saul_> mmorrow: I'm really having a difficult time changing the types, since a bunch of functions are based on libraries that also use IO callbacks
08:06:51 <Quadrescence> So, yeah, I've done some recursion. :P
08:07:01 <zachk> Quadrescence: /me grovels at your feet
08:07:11 <zachk> i dont get fourier analysis
08:07:24 <zachk> freebasic is decent then mmmm
08:07:40 <vixey> Philippa: What did you do after that (and how did you discover fp?)
08:07:41 <Quadrescence> FreeBASIC is more like C than BASIC
08:08:34 <Saul_> mmorrow: Also the foreign code doesn't help, as I have zero experience with that
08:08:46 <Quadrescence> zachk: And you don't need to get fourier analysis completely to write an FFT. :}
08:08:47 <Philippa> vixey: oh, I didn't really /start/ on the BBCs. First encountered basic on my dad's Amstrad PCW aged 5, was being taught Pascal at 7, saner basics 'til my teens, a 32bit Pascal under DOS + a bit of x86 asm (both 16bit and 32bit), C, C++, met Haskell when I got to uni
08:09:07 <Philippa> by which point I'd kinda blown the top off C++'s capability for sane abstractions and wanted something better
08:09:19 <vixey> ooh cool
08:09:45 <Quadrescence> (I also wrote a fast number theoretic transform, which I liked more than the FFT, but was admittedly slower because ... I don't know. It was done completely with integer operations)
08:10:12 <zachk> Quadrescence: bigInts???
08:10:13 <Quadrescence> (as to avoid round-off error for biiiiiiiiiigggggggg numbers)
08:10:23 <mmorrow> Saul_: ah. i'm about to pull up the code now to have a look. so what exactly are you aiming to change (in summary)
08:10:28 <rhz> Philippa you must be one of the most precocious female computer programmers I've heard of (I am making an assumption here that you are a woman)
08:10:32 <Quadrescence> zachk: Yeah. That was my passion in programming. :)
08:10:42 <zachk> Quadrescence: so you wrote your own arbritary precision code :-) i like bigNums myself
08:10:43 <Saul_> mmorrow: In summary, change every IO to MonadIO m
08:11:07 <mmorrow> Saul_: heh, ok.
08:11:10 <Quadrescence> zachk: Yep. Technically, it was more than bigints. It was bigfloats. :D
08:11:14 * mmorrow looks at HSQL code
08:11:29 <Philippa> rhz: I am. One way or another computers've been a pretty damn big part of my life though, in a way that they haven't for a lot of people until very recently
08:11:29 <zachk> sweet, did you treat them as strings of digits or in binary?
08:13:21 <Quadrescence> Originally, I treated them as strings. Then I stripped the string from decimals and did operations on it like ints, then placed the decimal back in. I did write a version with arrays/pointers to keep it numerical and to avoid having to convert strings to numbers back to strings. Very surprisingly, the strings one was still a lot faster, even with parsing the string and stuff.
08:13:34 <Quadrescence> s/from/of/
08:14:12 <Philippa> sounds like you did something daft with the arrays/pointers version?
08:14:28 <Quadrescence> I don't know... Perhaps, but I don't think so...
08:14:38 <vixey> which looks more like an error:  head . filter ..., or fromJust $ find ..., ?
08:14:41 <Philippa> well, that or the language implementation really sucks :-)
08:14:52 <Quadrescence> Philippa: Entirely possible. :D
08:15:28 <Philippa> oh yeah, I missed out a few things on my list - got taught VB back when it was version 1, for example
08:15:40 <Philippa> most of my real distaste for MS products comes from that
08:15:47 <Quadrescence> I plan to try again in Haskell when I am more proficient. My first 'project' in Haskell is to write a Rubik's cube solver (as well as other Cube tools in the same program)
08:16:12 <rhz> Philippa, that's very interesting. I was also playing with computers when I was quite young. I sometimes heard that my generation was one of the first to have access to computers from the beginning
08:16:12 <vixey> I should write a rubics cube solver too
08:16:22 <vixey> I have never solved a rubiks cube :(
08:16:36 <Philippa> rhz: yep. I'm 25, you?
08:16:45 <rhz> 26
08:16:45 <Quadrescence> vixey: I have a website where you can learn. :> But I don't want to "ADVERTISE."
08:16:52 <zachk> the diamter of the rubik's cube group is conjectured to be <=26 moves
08:17:05 <vixey> Quadrescence: I already gave up solving it manually
08:17:06 <Quadrescence> zachk: Actually, it was recently cut down to 23
08:17:14 <vixey> Quadrescence: I haven't tried doing it with a computer though
08:17:18 <Saul_> rhx, Philippa: I'm 23, but I haven't had a computer until I was 8 or so
08:17:25 <Philippa> I ended up talking to a friend a few years younger who's doing mecheng here about how I'm also part of the last generation who were at all likely to've talked to the bare metal
08:17:33 <zachk> so they found something faster for the 4spot composed with the superflip?
08:17:47 * vixey has never really been that low level
08:18:01 <Quadrescence> Well, I know the superflip has a MINIMUM of 22 moves, if I remember correctly.
08:18:06 * RayNbow is 23 years (and a day) and started programming VB at age 11 or something
08:18:13 <vixey> I've worked with perpherals but that's still a higher level..
08:18:14 <Philippa> you had to if you wanted to do reasonable graphics, play around with games etc
08:18:31 <Philippa> A0000 and all that
08:18:49 <zachk> wow alot of us started with basic ........mmmmm maybe djistrka was wrong
08:18:49 * vixey used high level shading languages and opengl to do graphics -_-
08:19:07 <vixey> zachk: I doubt it :p
08:19:39 <Philippa> zachk: I'm damn glad that the basics I did much real work in were modern ones
08:19:54 <Philippa> the basic dijkstra commented on was one where you did everything with GOTO...
08:21:18 <RayNbow> Philippa: goto is evil... I once found an old VB program I wrote... it was full of gotos :p
08:21:26 <rhz> oddly enough however my parents always seemed to see computers as a potential threat to my wellbeing
08:21:39 <RayNbow> (but then again, I knew the goto concept from .bat files :p)
08:22:21 <vixey> speaking of cybernetic revolution... I must see metropolis soon
08:23:40 <roconnor> @go 1 EUR in USD
08:23:42 <lambdabot> http://www.x-rates.com/d/USD/EUR/graph120.html
08:23:42 <lambdabot> Title: Exchange Rates Graph (Euro, American Dollar)
08:23:58 <Philippa> rhz: thankfully mine didn't
08:24:34 <rhz> that's great. Thankfully my grandfather was really into computers and had an Atari ST
08:25:41 <rhz> I got to play with that every time I visited him as a child
08:25:45 <Philippa> cool
08:27:55 <rhz> yeah. It was one of the only computers to come with built in midi ports I think
08:28:32 <kryptiskt> I started on a TI99/4A (where you couldn't get at machine code because the basic had no peek and poke, after that experience I will never buy an iPhone...)
08:33:28 <rhz> Well I sure wish there were more people like you around Philippa
08:34:45 <rhz> Having said that, there probably are a lot of woman computer programmers around I just haven't bothered to talk to for whatever reason
08:35:20 * vixey discovers an evil debugging trick
08:35:40 <cjb> rhz: IRC isn't a very welcoming place for women, in general.
08:35:55 <kryptiskt> vixey: evil debugging trick is redundant
08:35:55 <chazzwazzer> Right. I just followed the install instructions for Yi and I run yi   and I get this error http://hpaste.org/8941 . Anyone ?
08:36:06 <vixey> why is it redundant?
08:36:17 <rhz> cjb: really?
08:36:22 <Philippa> cjb: yes'n'no. What most guys think of as "IRC", yes
08:36:25 <kryptiskt> all debugging tricks are evil
08:36:38 <Philippa> rhz: take a look at the amount of sexist crap zachk's come out with today, for example
08:36:54 <cjb> The few women I know brave enough to hang out on technical IRC channels with a female nickname get a lot of (occasionally inappropriate) /msg spam from people.
08:36:55 <vixey> oh
08:36:55 <rhz> hmm
08:37:20 <Philippa> cjb: I only seem to be saved by the fact my name's apparently a lot rarer in the US than the UK...
08:38:08 <Philippa> then there's dealing with the "OMG, a technical woman!" factor in its many forms
08:38:12 <cjb> also, IRC/mailing lists are quite confrontational, and enjoying confrontation seems to be a mostly male personality trait.
08:38:38 <Philippa> cjb: it's not so much that they're confrontational as the style of the confrontation that's most off-putting
08:38:44 * BMeph pities the man named "Meredith" who innocently joins an IRC channel...
08:38:44 <cjb> (the Haskell channels are definitely on the polite/respectful end.)
08:38:51 * vixey has avoided mailing lists
08:38:55 <rhz> I actually haven't used IRC much myself technical or non technical
08:39:04 <kryptiskt> #haskell is incredibly nice exception to IRC normality
08:39:16 <Philippa> right - actually, by #haskell standards I'm one of the people who's more likely to be seen getting into a vicious argument
08:39:19 <rhz> but I don't really see how it could be that different for women
08:39:28 <osfameron> tbh, many chans on freenode are fairly respectful
08:39:35 <osfameron> as the admins tend to take things quite seriously
08:39:46 <cjb> and finally, the mere fact that there aren't *already* lots of women around is a huge turn-off.  imagine being a man walking into a room with 300 women in, and you're imagining being a woman on IRC.  :)
08:39:50 <Philippa> osfameron: where they're aware there's something to respect, yes. You'd be surprised how much stuff people miss
08:40:05 <cjb> role models can be a necessary precondition for joining a community.
08:40:15 <osfameron> Philippa: nah, I've seen stuff.  But I do think many channels make an effort
08:40:19 <Philippa> cjb: no, no you're not. Not quite. It's close, but there's a whole aspect to that...
08:40:30 <rhz> cjb: I think that a man's reaction to that circumstance may depend on many things
08:40:38 <mmorrow> * BMeph pities the man named "Meredith" who innocently joins an IRC channel...
08:40:39 <mmorrow> lol
08:40:45 <BMeph> rhz: It isn't that it is different, so much as the other users /make/ it different,,,
08:41:49 <vixey> well it's more of an evil type inference trick actually
08:42:09 <pir> 5
08:42:15 <roconnor> > 5
08:42:15 <rhz> BMeph, is it the others, or the individual?
08:42:22 <pir> lol sry :)
08:42:31 <lambdabot>  thread killed
08:42:31 <BMeph> mmorrow: I just saw a re-run of "Stargate: Atlantis" last night, which mentioned that one of the main character's first name is actually "Meredith," which now-a-days is almost exclusively used as a woman's name.
08:42:32 <kryptiskt> If you want to see male dominance, go to a DB developer/admin conference.
08:42:37 <osfameron> hmm, only 5 of top 25 talkers on london perl channel are female http://ilmari.org/ircstats/london.pm.html
08:42:39 <lambdabot> Title: #london.pm @ MAGnet stats by ilmari
08:42:40 <roconnor> lambdabot: WTF?
08:43:01 <roconnor> lambdabot: that computation isn't so difficult
08:43:14 <roconnor> sure, there is defaulting
08:43:25 <roconnor> and then fromInteger
08:43:27 <roconnor> hmm
08:43:37 <roconnor> suddenly > 5 seems like a pretty complicated program
08:43:42 <vixey> :D
08:43:55 <pir> yes :) get ready for some haskell domination with this program :P
08:44:07 <pir> behold the power of 5
08:44:21 <mmorrow> BMeph: i understood your comment to mean that they would have to deal with being extensively hit on/etc by the all male channel
08:44:42 <roconnor> > ()
08:44:43 <lambdabot>  ()
08:44:44 <Philippa> mmorrow: and having to show a higher level of technical competence to earn the same respect, amongst other things
08:44:45 <chazzwazzer> It's far from just the IT industry that is "male dominated".
08:44:55 <rhz> mmorrow: but how they reacted to that would be up to them
08:44:55 <chazzwazzer> truck driving, metal working, yada yada.
08:45:22 <Philippa> rhz: yeah, you can just magically decide not to have a problem with it and it's not one? Right...
08:45:31 <mmorrow> rhz, Philippa: i was referring to " * BMeph pities the man named "Meredith" who innocently joins an IRC channel...", but yeah
08:46:31 <rhz> Philippa: are we taking "hit on" to mean flirted with?
08:46:51 <rhz> because I think some people may react positively to that..
08:46:52 <Philippa> rhz: more like "flirted /at/, and probably badly"
08:47:20 <Philippa> flirting is a two-way process, being flirted at is very much degenerate
08:47:21 <mmorrow> rhz: no. talking hit on to mean being /msg with overtly sexual/"innapropriate" comments or something (in the worst case)
08:47:34 <mmorrow> of course "innapropriate" depends on context...
08:47:36 <Philippa> mmorrow: the worst case isn't comments, it's demands
08:47:40 <mmorrow> yeah
08:47:50 <mmorrow> true
08:48:12 * Philippa adds "pics!" and the whole "there are no women on the internet, so I don't believe you" trope to the list of problems
08:48:50 <Quadrescence> zachk and vixey: I don't know how interested you are in the computational aspects of the cube, but http://arxiv.org/abs/0803.3435 is a paper on how the diameter was reduced to 25 moves back in March (2008).
08:48:51 <rhz> actually there are plenty of women on the internet... in other parts of it
08:49:09 <Japsu> http://xkcd.com/322/
08:49:10 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
08:49:15 <Philippa> rhz: no shit
08:49:16 <vixey> does diameter mean the most number of moves you have to make?
08:49:18 <Japsu> (re women and the internets)
08:49:22 <olsner> ey, wtf, my gtk2hs program crashed with a bus error... grmbl
08:49:45 <BMeph> Philippa: I thought the phrase was "There's no gurls on teh intarwebs!" ;)
08:50:04 <vixey> Quadrescence: thanks
08:50:08 <vixey> (looks interesting)
08:50:54 <Philippa> BMeph: the trope predates "intarwebs"
08:51:02 <cjb> rhz: flirting usually involves a concerted effort based on what you know someone to like, and so on.  IRC flirting involves treating women as objects because they happen to have a female name and therefore must want to have sex with you, even if you have no idea who they are.
08:51:37 <Philippa> cjb: I'd distinguish IRC "flirting" from flirting over IRC which I've done a fair amount of
08:51:50 <rhz> Philippa: that's a bit rude!
08:51:52 <cjb> Philippa: right, that's what I was trying to do.
08:52:07 <Quadrescence> cjb: THERE ARE NO GIRLS ON THE INTERNET! </cruise control for cool>
08:52:11 <paczesiowa> I use female nick but I don't do that kind of thing cjb is talking about:P
08:52:22 <kaol> girls are a myth
08:52:38 <Philippa> rhz: it's not at all rude when the flirtation develops naturally. Not every IRC channel is technical, either
08:52:43 <Saizan> maybe this all belong to #haskell-blah
08:52:53 <Philippa> Saizan: good call
08:52:56 <rhz> I meant that word "shit"
08:52:58 <cjb> rhz: I agree that other parts of the internet are better.  <1% of free software developers are women, whereas other groups are ~50%.
08:53:33 <Philippa> cjb: some're even predominantly women
08:54:07 <Philippa> rhz: merely colloquial unless you're in a formal setting. We're not.
08:54:07 <quicksilver> vixey: the diameter of a group is the longest possible 'expression' in it which doesn't reduce to a simpler one (as far as I can remember)
08:54:16 <cjb> Philippa: I guess that's right :)
08:54:31 <vixey> oh there is an interpretation of rubiks cubes as formula in some group?
08:54:33 <quicksilver> vixey: so yes, in this concrete case it would be the largest "smallest path" between two positions
08:54:45 * cjb wishes more people were appalled and trying to fix the <1% statistic.
08:54:55 <quicksilver> yes, you can think of rubix operations as associative
08:55:02 <quicksilver> and 'do nothing' is the identity
08:55:06 <rhz> Philippa: well now you've lost me
08:55:06 <quicksilver> so they form a group
08:55:32 <mmorrow> a noncommutative one
08:55:38 <quicksilver> well I should add "and they're all invertible"
08:55:39 <quicksilver> of course
08:55:44 <quicksilver> mmorrow: yes, very much noncommutative
08:55:50 <quicksilver> btu then, commutative groups are boring
08:55:54 <quicksilver> and don't make good puzzles at all :)
08:55:59 <mmorrow> heh, hence the difficulty of t3h cube
08:56:04 <mmorrow> yeah
08:56:18 <Philippa> rhz: you're not at all familiar with "no shit" as a relative of "no kidding"?
08:56:49 <Quadrescence> The cube actually isn't hard if you understand commutators.
08:57:05 <rhz> Philippa: yeah I am. Just not coming from a woman's mouth - only kidding
08:58:05 <frevidar> is there any haskell library which has something like a function like say this: readFormula :: String -> (Double -> Double) which reads a formula like "sin(x)" and returns a function with that formula
08:58:14 <frevidar> or that sort of vibe?
08:58:15 <rhz> "shit" is much more aggressive
08:58:25 <Philippa> rhz: y'see, this is an area where there isn't the margin to make the jokes
08:58:49 <Philippa> frevidar: not a library. There's a hundred and one hand-built parsers out there, but you have to know what grammar you're after first
08:59:00 <Philippa> rhz: depends on tone, context etc
08:59:13 <vixey> frevidar: mm.. I think it would be more useful String -> ([String],([(String,Double)] -> Double))
08:59:31 <vixey> actually forget that, It's not complex enough
08:59:44 <vixey> I would try to account for parse errors
08:59:52 <Philippa> frevidar: you can build something pretty quickly using Parsec if you know a little about parsing
09:00:02 <Philippa> but there's no one standard grammar to use, so no one library
09:00:23 <Philippa> also: the task's equivalent to a small interpreter :-)
09:00:45 <_zenon_> Philippa, tried out BNFC?
09:01:22 <rhz> Philippa: basically I find it interesting to wonder about whether women have fundamentally different ways of thinking about things as compared with men and how that relates to computing. As for being "hit on" or other undesirable types of interactions between men and women - everyone makes mistakes. If someone makes a mistake and you realise it - point it out to them
09:02:41 <cjb> rhz: I find making assumptions of alienness to be extremely problematic.
09:02:52 <_zenon_> rhz, Go get a girlfriend and ask her how she thinks.
09:03:19 <rhz> cjb: I have no idea what your comment means
09:03:20 <cjb> Why not assume that men and women are of about equal interest and ability until you have a _really good reason_ to assume that there's a cultural difference instead?
09:03:28 <cjb> Sorry, I mean a biological difference instead.
09:03:30 <Philippa> rhz: yeah, I'll spend all my damn time educating people huh?
09:03:42 <rhz> _zenon_: "Go get a girlfriend" is also unhelpfull
09:03:59 <cjb> rhz: It means that your suggestion of "well, maybe this is just the way things are naturally" is a dangerous suggestion, in my opinion.
09:03:59 <frevidar> philippa: thanks, I'll check out parsec
09:04:12 <cjb> Because we have ample evidence for it not being natural.
09:04:21 <Philippa> cjb: no, we do not
09:04:22 <rhz> cjb: I still have no idea what you are talking about
09:04:27 <Philippa> wait, misread
09:04:29 <Philippa> yes we do
09:04:29 <_zenon_> frevidar, Ah, it was you who would parse :) I though Philippa was the one, have you checked out BNFC ?
09:04:30 <cjb> for example, women receive their first computer at average age 19, and men at average age 16.
09:04:46 <cjb> those are some pretty key years for deciding whether or not you want to spend your career with computers.
09:04:58 <cjb> rhz: I don't know how to restate it, sorry.
09:05:48 <rhz> cjb: how did you infer that I thought that women and men have different interest or ability?
09:05:57 <vixey> hmmm #haskell-blah is silent
09:06:00 <rhz> you are making the assumptions here not me
09:06:19 <cjb> rhz: you said that you think women might just be fundamentally different to men in this regard.
09:06:38 <rhz> they are fundamentally different to men in many ways.
09:06:49 <_zenon_> This is so off topic
09:06:53 <rhz> anyhow I agree this conversation is going nowhere.
09:06:58 <cjb> which is a claim of biological/psychological difference.  and I'm saying, we have plenty of evidence that suggests that instead we treat women very differently in ways that turn them off from becoming programmers.
09:08:39 <cjb> and that instead of taking the cop-out answer of "it's not our fault, they just don't like programming", the onus is on us to investigate what some reasons we might be able to do something about are.  Even if we do find some personality differences, that just means *we* should make a more welcoming community by accomodating them.
09:08:47 <cjb> anyway, I'll stop talking for a while, I know it's off-topic.
09:09:00 <rhz> cjb: I think you completely do not understand what I was saying. But that is fine.
09:09:29 <vixey> just make the next reply on this thread of conversation happen in #haskell-blah
09:09:53 <Philippa> rhz: "Everyone makes mistakes" - much of male computing culture has the mistakes firmly embedded in it, and we should /not/ have to do all the work of pointing out and counteracting it
09:12:23 <dons> hmm. am i in #haskell-blah ?
09:12:35 <vixey> hey dons
09:12:43 <Philippa> dons: fair enough, I guess
09:12:46 <vixey> do you run the hackage bot ?
09:12:47 <dons> morning all.
09:12:49 <dons> vixey:  yes.
09:12:58 <vixey> cool
09:13:03 <vixey> good morning :)
09:14:48 <mmorrow> vixey: did you ever request that code.haskell.org account?
09:15:04 <mmorrow> err community.haskell.org
09:15:05 <vixey> mmorrow: not yet, I was hoping to ask shapr about something before I do
09:15:12 <mmorrow> cool
09:16:10 <_zenon_> Annyone got a good paper on "Advanced type classes"
09:16:12 <_zenon_> ?
09:16:24 <vixey> what are they
09:16:44 <Baughn> Will hugs compile on any arbitrary posixish machine? Like, say, the iphone?
09:16:56 <_zenon_> By "paper" I mean introduction, and by "advanced" I mean >= multi parameter
09:17:09 <BMeph> _zenon_: A paper on advanced type classes, or an advanced paper on type classes? :)
09:17:17 <Baughn> _zenon_: The haskell wiki has lots of stuff
09:17:19 <vixey> ok I thought you were quoting something specific
09:17:20 <_zenon_> BMeph, hehe :) Both will suffice :)
09:17:21 <Philippa> There isn't a single good paper there, because the field keeps evolving
09:17:34 <_zenon_> BMeph, but I would greatly appreciate the paper ON advanced type classes
09:17:38 <paczesiowa> dons: why aren't there functions to read floating point numbers in bytestring? is that style of readInt functions ok? isn't that calling unsafeTail slow and it would be faster to call some bytestring fold?
09:17:41 <Baughn> _zenon_: 2-rank types, N-rank types, overlapping/undecidable instances.. actually, just read all of it
09:18:02 <_zenon_> Baughn, Okay, I'll check it out (again), seemed a bit thin though.
09:18:06 <Philippa> there was a survey paper in the mid-90s back when fundeps were a totally new idea, then you'd want to read some of the bigger papers on fundeps, associated types and encoding dependent types into haskell
09:18:09 <dons> paczesiowa: sounds like time to add them.
09:18:19 <Baughn> paczesiowa: Basically, because that belongs in Binary or some such, not ByteString. Note that Binary doesn't have it either.
09:18:23 <dons> paczesiowa: along with readInt,Integer, i'll add an IEEE float reader
09:18:29 <dons> anything else you can use Binary for
09:18:39 <_zenon_> I read Hughes paper on Arrows,
09:18:41 <_zenon_> was gr8
09:18:48 <dons> people like parsing doubles from bytestrings, so let's make it easy
09:19:13 <_zenon_> Baughn, you mean this ? http://en.wikibooks.org/wiki/Haskell/Advanced_type_classes
09:19:34 <paczesiowa> dons: I'm having some fun with that csv parsing from proggit, and I made his code 3x faster by parsing bytestrings to doubles directly (but it is stpuid and only works for digits[.digits])
09:19:39 <Baughn> _zenon_: Uh, perhaps. "Advanced type classes" is a bit vague.
09:19:50 <Baughn> _zenon_: I meant the haskell wiki, though, not the haskell wikibook
09:19:52 <Philippa> dons: do singles too? There are fields where singles really are appropriate (audio being the best example)
09:19:52 <dons> paczesiowa: i'd hope we could just destroy all comers in that kind of benchmark.
09:19:58 <_zenon_> Baughn, ....... oh
09:20:03 <dons> paczesiowa: since its almost the same as the sum-file shootout program
09:20:06 <Baughn> _zenon_: http://haskell.org/haskellwiki/Rank-N_types <-- This, for example
09:20:07 <lambdabot> Title: Rank-N types - HaskellWiki
09:20:15 <dons> so if you're not beating C here, something's wrong.:)
09:20:18 <_zenon_> Baughn, on it.
09:20:20 <dons> Philippa: singles?
09:20:28 <Philippa> dons: single-precision floats
09:20:32 <dons> oh sure. yes.
09:20:37 <_zenon_> Baughn, ... uhm, page is empty
09:20:58 <Baughn> _zenon_: Empty?
09:21:03 <Baughn> Reload.
09:21:25 <Baughn> _zenon_: http://haskell.org/haskellwiki/GHC/AdvancedOverlap <-- Here's a page on advanced use of type classes, too. Probably /too/ advanced, but.. :P
09:21:25 <lambdabot> Title: GHC/AdvancedOverlap - HaskellWiki
09:21:55 <_zenon_> Baughn, it does contain text .)
09:22:35 <Baughn> _zenon_: As I said, read the whole wiki. Some parts will be useful to you right away, some won't. When you've advanced a bit on the learning cliff, revisit and learn more. :P
09:22:41 <Baughn> It's not /too/ large
09:22:49 <Baughn> (And there are useful categories)
09:22:51 <rhz> Philippa: the day there are more women in the Haskell irc channel and less on porn sites will be a great day I'm sure
09:23:12 <_zenon_> Baughn, I'll just have to re-read it some times :)
09:23:28 --- mode: ChanServ set +o Philippa
09:23:31 <paczesiowa> dons: right now, sortByTicker takes 50% of cpu time, so I don't know if we can go much faster in pure world
09:23:48 <Philippa> rhz: there is no way I can read that as anything but a piece of horribly sexist piss-taking. Do *not* do it again
09:23:57 --- mode: ChanServ set +o dons
09:24:00 --- mode: dons set +b *!*n=rhz@*.wavrl2.nsw.optusnet.com.au
09:24:00 --- kick: rhz was kicked by dons (dons)
09:24:09 <dons> that's just not ok.
09:24:18 --- mode: ChanServ set -o dons
09:24:24 --- mode: Philippa set -o Philippa
09:25:03 <_zenon_> Me so wants haskellwiki in a single bundle, is that doable?
09:25:16 <cjb> sigh.  and that was *almost* a useful conversation, too.
09:25:22 <paczesiowa> wouldn't those wikipedia dumping methodes work here too?
09:25:23 * cjb == optimist, apparently.
09:25:24 <_zenon_> For off-line on-the-beach browsing :)
09:25:49 <_zenon_> Of course, I could crawl them, but that would be.... wrong
09:26:47 <_zenon_> Baughn, so many links,,, where to start?
09:27:00 <sclv_> paczesiowa: the sorting looked sort of inefficient in the program?
09:27:16 <paczesiowa> sclv_: ?
09:27:42 <sclv_> I'm not sure if there's a way to make it more efficient though...
09:27:54 <sclv_> just a few layers of indirection to get to the ticker each time.
09:28:26 <Baughn> _zenon_: http://haskell.org/haskellwiki/Category:Haskell <-- Here. ^_^
09:28:27 <lambdabot> Title: Category:Haskell - HaskellWiki
09:28:27 <sclv_> and probably lots of extraneous comparisons if the first part of "ticker" is the same for each element...
09:28:32 <paczesiowa> sclv_: that shoudln't be the problem for -O2
09:28:44 <Baughn> _zenon_: Language, Idioms and Style are especially useful
09:28:50 <_zenon_> Baughn, I was looking at it :)
09:29:02 <_zenon_> Baughn, ok, thanks
09:29:16 <sclv_> You sure? Unboxing helps with allocation, but you still have to index into the right part of the data structure....
09:29:38 <paczesiowa> sclv_: the biggest problem with that code is: 1) hardcoded paths 2) that guy doesn't know that maybe is a monad
09:29:54 <sclv_> But again, I don't have any better solution except maybe a really evil one...
09:30:37 <paczesiowa> maybe switching between lazy/eager bytestrings would make a difference
09:30:41 <Baughn> _zenon_: For the beach, I would suggest wget -r 1 on maybe those categories. Anything more would be rude; bandwidth seems rather limited at times
09:30:43 <sclv_> explicitly unpack the data structure... make sure you're sorting on an int field and that it comes first, and do the sorting with unsafe coerce :-P
09:30:55 <sclv_> yeah, or that...
09:31:08 <sclv_> alternately, why is there sorting at all?
09:31:23 <_zenon_> Baughn, yes, I agree, annything but downloading an officiall tar.gz would be .... "rude" :)
09:31:24 <sclv_> as I recall, the dude only wanted the maximum and minimum, right?
09:31:27 <paczesiowa> sclv_: no idea, I don't even know what a ticker is
09:31:38 <sclv_> So forcing a full sort is probably overkill.
09:31:45 <Baughn> _zenon_: That's if there /is/ an official tarball
09:32:03 <paczesiowa> sclv_: python was sorting it too
09:32:06 <_zenon_> Baughn, exactly my point, probably there is not. So I keep my hands in my pocket. :)
09:32:24 <sclv_> yeah well, haskell programmers are smarter, so better algorithms should be factored in :-)
09:32:30 <_zenon_> Should maybe mail someone and ask for a nightly build or something to become official
09:32:58 <sclv_> python's sort is famously good and robust actually, as I recall?
09:33:15 <lilachaze> python uses timsort, which is ... unique
09:33:19 <paczesiowa> _zenon_: how about downloading Oleg's website? it should be small (only txt) and it is enough for any man for any number of holidays
09:33:25 <lilachaze> but good in practice
09:33:38 <lilachaze> http://svn.python.org/projects/python/trunk/Objects/listsort.txt
09:33:42 <_zenon_> paczesiowa, hmmm link?
09:33:56 <paczesiowa> @google oleg kiselyov
09:33:57 <lambdabot> http://okmij.org/ftp/
09:33:57 <lambdabot> Title: This FTP site
09:34:44 <paczesiowa> _zenon_: but you are probably most interested in this: http://okmij.org/ftp/Haskell/types.html
09:34:45 <lambdabot> Title: Haskell Programming: Types
09:35:15 * _zenon_ bows for paczesiowa 
09:35:37 <paczesiowa> don't bow for me, just worship Oleg like the rest of us:>
09:36:25 * _zenon_ unbows
09:36:32 <_zenon_> *rollback*
09:37:29 <mmorrow> lilachaze: there's a "generalNaturalMergeSort" in ghc/compiler/utils/Utils.lhs (which compares to the python on i'm not sure how)
09:38:12 <mmorrow> oops, Util.lhs
09:38:13 <mmorrow> http://darcs.haskell.org/ghc/compiler/utils/Util.lhs
09:39:36 <mmorrow> it has a nice little commentary attached in the form of an email
09:42:29 <laz0r> hi, can anyone tell me how i am supposed to to use Graphics.Rendering.OpenGL.GL.Shaders? i can see in the source code that there are functions like 'createShader', or 'genShaderNames', which i assume can be used to create an initial ShaderObject... but when i try to use them, ghc always complains that these are not in scope
09:43:23 <laz0r> and sure enough, in the 'module header', createShader for example is not exported
09:44:43 <laz0r> on the other hand, it exports the VertexShader constructor, but i can't use that either
09:44:51 <laz0r> maybe there are some (..) missing?
09:47:09 <FordCortina> how do you run functions interactively in Agda2? I've only ever used the interactive console, however that's not supposed to be the way! :S .
09:47:17 <lilachaze> laz0r: looks like attachedShaders is the only call which returns a shader
09:47:25 <vixey> FordCortina: Are you in emacs?
09:47:31 <FordCortina> I've got the emacs mode working
09:47:46 <vixey> FordCortina: Look in the menu for normalize term, you can use that command
09:47:48 <FordCortina> is there a way to call functions with arguments, etc
09:47:53 <FordCortina> ah
09:48:00 <FordCortina> i wondered if that might be it
09:49:05 <_zenon_> Baughn, it is a good page :) I uhm.. swedish:: skummar  through it.
09:49:16 <_zenon_> Does lambdabot translate?
09:49:18 <Baughn> _zenon_: "I'm skimming it"
09:49:46 <_zenon_> Baughn, yes :) Some things are known, others are small pieces of candy :)
09:50:24 <_zenon_> Could be nice with a lambdabot feature @translate word fromLang toLang
09:50:26 <quicksilver> laz0r: generate a shader name with genObjectNames
09:50:43 <quicksilver> laz0r: set the source with shaderSource
09:50:52 <quicksilver> laz0r: compile and then link
09:50:55 <quicksilver> laz0r: as far as I know
09:51:10 <quicksilver> laz0r: (I've never used it but that's based on what is exported and the others bits of opengl I have usd)
09:51:11 <Baughn> @hoogle genObjectNames
09:51:11 <lambdabot> No matches found
09:51:40 <laz0r> quicksilver: i tried that, but shaderSource needs an argument, namely VertexShader or FragmentShader, which are both instances of Shader
09:52:39 <quicksilver> laz0r: yes, you generate those with genObjectNames
09:52:46 <FordCortina> thanks vixey, it seems to work now :)
09:52:51 <quicksilver> laz0r: thats how you generate all named objects in HOpenGL
09:53:01 <quicksilver> you use it e.g. for textures too
09:53:12 <laz0r> ok, wait a second, i'll try again
09:55:08 <laz0r> ah, it works like this: [shaderid] <- genObjectNames 1 :: IO [VertexShader]
09:55:20 <laz0r> and then i can do: shaderSource shaderid $= source
09:55:31 <quicksilver> currect.
09:55:53 <laz0r> thanks, i thought i had to put in VertexShader to tell opengl the i want to create a VertexShader
09:56:10 <quicksilver> not sure what you mean.
09:56:22 <laz0r> still, i am wondering why i can't use genShaderNames, but i guess i can live without it for now
09:56:26 <quicksilver> you don't need the type annotation there by the way.
09:56:30 <quicksilver> genShaderNames is not exported
09:56:33 <quicksilver> if it was, you could use it.
09:56:39 <quicksilver> but you're supposed to use genObjectNames
09:56:44 <laz0r> ok
09:56:52 <vixey> somehow > fst (Z, (S Z)) -- > (S (Z))
09:56:54 <vixey> :S
09:57:54 <saml> fst (Z, (S Z)) --> Z
09:58:03 <sclv_> so here's my random haskell gripe of the moment -- we use prime for strict functions, like readFile', etc...
09:58:11 <quicksilver> laz0r: it's using type inference to help you :)
09:58:24 <sclv_> but for lots of functions (such as readFile) we actually want strictness by default, and optional laziness...
09:58:52 <sclv_> but we don't want to denote the lazy function by a prime, because then it gets confusing....
09:58:57 <quicksilver> laz0r: once you've used shaderSource, it can infer the type of shaderid
09:59:02 <sclv_> so what should the convention be?
09:59:06 <sclv_> readFileLazy?
09:59:09 <sclv_> traceLazy?
09:59:11 <sclv_> etc...?
09:59:13 <quicksilver> sclv_: my gripe: readFile/readFile' is TOTALLY DIFFERENT from foldl/foldl'
09:59:20 <laz0r> without the type annotation i get an 'ambiguous type variable' error, but i think thats because it can't infer the type with this little program
09:59:28 <quicksilver> the difference in the latter is just a change of strictness.
09:59:37 <laz0r> and you kinda answered while i typed the question...
09:59:45 <quicksilver> laz0r: oh, you're probably right: both kinds of shader have shaderSource
09:59:54 <sclv_> while in the former?
09:59:57 <quicksilver> laz0r: once you linked the program it wouldn't be ambiguous any more
10:00:08 <quicksilver> sclv_: while the former is BROKEN NON REFERENTIALLY TRANSPARENT lazy IO
10:00:09 <quicksilver> ;)
10:00:31 <sclv_> right...
10:00:44 <quicksilver> foldl and foldl' can both be implemented in pure haskell
10:00:48 <quicksilver> readFile' can be too
10:00:49 <quicksilver> readFile can't be
10:00:53 <sander___> Hi, I created a very ugly function, and have the idea this could be done much more pretty :) see http://hpaste.org/8940
10:00:55 <quicksilver> (it needs unsafeInterleave)
10:00:56 <sander___> any tips?
10:01:15 <quicksilver> it is my main gripe that we don't distinguidsh the two types of laziness :)
10:01:26 <quicksilver> sclv_: and, as answer to your direct question
10:01:31 <quicksilver> I'd be in favour of readFileLazy
10:01:36 <sclv_> I think that's what I meant -- IO functions should be strict by default with optional laziness, while general functions should be lazy by default with optional strictness...
10:01:56 <quicksilver> sclv_: the point I'm trying to make is that by writing a sentence like that, you suggest the situations are parallel
10:01:59 <quicksilver> they are not.
10:02:10 <quicksilver> in the one case we're talking about evaluation strategy for pure haskell expressions, controlled by seq
10:02:14 <sclv_> no -- you're right, you put your finger on what's bugging me about it.
10:02:18 <quicksilver> in the other case it's nasty nasty unsafeInterleaveIO
10:02:27 <quicksilver> which has it's uses sure.
10:02:30 <vixey> working with tabular data is painful.. trees are so much simpler
10:02:37 <quicksilver> but I'd rather a slightly different word was used
10:02:43 <quicksilver> readFileInterleavedIO ?
10:02:49 <quicksilver> a bit verbose.
10:02:56 <quicksilver> maybe we can agree that 'IIO' means interleaved IO?
10:02:59 <quicksilver> readFileIIO
10:03:02 <quicksilver> hGetContentsIIO
10:03:19 <saml> xkb: i think you have overlapping pattern
10:03:35 <xkb> the first two I guess?
10:03:37 <sclv_> There are also different places to hide the interleaving, so it gets tricky....
10:04:10 <saml> xkb: sorry nevermind. i read it wrong.
10:04:10 <sclv_> characterwise, chunkwise, linewise, etc...
10:04:39 <xkb> The thing I think is pretty ugle is the "double" passing of the built-up list
10:04:39 <quicksilver> true indeed.
10:05:11 <saml> xkb: then you can use where or let
10:05:15 <paczesiowa> sclv_: I think sorting is needed to group it by ticker (whatever that is) and then finding max/min in each group
10:05:48 <sclv_> paczesiowa: but you don't really need to sort for that... you could just use buckets, no?
10:06:00 <saml> xkb: ... = a : buildDebiterList xs [a]   where a = (debitAccountNr, comment x) ....
10:06:53 <paczesiowa> sclv_: what buckets? like in hashtable? (I'm stupid, I need plenty of explanations)
10:07:16 <xkb> saml: can u also use where over multiple patterns?
10:08:07 <sclv_> I dunno... any structure you want -- use a writer monad and mapM over the list even, passing along your state as a tuple of linked lists as you go... (assuming you know how many tickers there are in advance, and as a set rather than tuple if you don't...)
10:09:07 <BMeph> xkb: Yes. the where clause is valid over the Doesn't a where clause in a definition act like it does in a case statement, i.e., in scope over all of the branches?
10:09:23 <sclv_> the point being that you only need an O(n) traversal to stick them in buckets... and for that matter if you complicate things (or just use a sufficiently smart monoid for the writer) then you only need that same single traversal to find the mins and maxes of the buckets as you go...
10:09:45 <BMeph> Wow, I need to learn how to use the Delback key... :)
10:09:53 <xkb> BMeph: parse error :)
10:10:00 <xkb> by me :) :)
10:10:03 <paczesiowa> sclv_: I'll try that later, first I'll finish that parsing doubles from bytestring
10:10:07 <sclv_> Which should also mean that you need O(m) space instead of O(n) (where n is the size of the input file and m is the number of tickers)
10:10:35 <vixey> I accidentally wrote a bit of code inside out
10:11:06 <sclv_> paczesiowa: well, yeah, the latter is more generally worthwhile, what I'm talking about is a varient on the old "your fib benchmark stinks... look what happens when you memoize!" sort of thing...
10:11:40 <vixey> Does anyone have a use for this sort of thing:  \x -> f (\y -> ... x y ... ?
10:12:09 <sclv_> On the other hand, the writer monad would look clean and pretty and tiny as compared to the current code...
10:12:14 <carl> hehe thats what i use for my binary instances is that bad?
10:16:14 <BONUS> hmm
10:16:19 <BONUS> wouldnt it be cool if you could do
10:16:41 <BMeph> vixey: Maybe it's a new monad... ;)
10:16:58 <BONUS> f@(\a -> f (a-1) + f (a-2))
10:17:06 * vixey is absolutely confused
10:17:24 <BONUS> i.e. lambda recursion
10:17:27 <BONUS> that would be pretty cool
10:18:14 <vixey> fix (\f a -> not good enough!?
10:18:23 <_zenon_> BONUS fixpoint
10:18:28 <BONUS> hmmm
10:18:55 <BMeph> BONUS: Check out loeb for more coolness... :)
10:18:59 <lilachaze> xkb: i posted a refactoring
10:19:08 <BONUS> loeb?
10:19:13 <xkb> lilachaze: Ill have a look at it
10:19:13 <vixey> :t loeb
10:19:14 <lambdabot> Not in scope: `loeb'
10:19:15 <lilachaze> xkb: i *think* it's correct, but the handling of ys is a bit subtle
10:19:18 <vixey> :[
10:19:19 <_zenon_> http://en.wikipedia.org/wiki/Fixed_point_combinator
10:19:20 <lambdabot> Title: Fixed point combinator - Wikipedia, the free encyclopedia
10:19:35 <vixey> _zenon_: of course that wont type in haskell
10:19:46 <xkb> lilachaze: ahhh nested where's :)
10:19:52 <BONUS> ahh thats the y combinator
10:19:52 <_zenon_> vixey, well no, but it's the fundament
10:20:25 <_zenon_> A spanish joke (while on "fundament") :: La boina es funda-mental
10:20:52 <_zenon_> The Y combinator could make a rather nice tatoo :)
10:21:20 <BONUS> hehe
10:21:26 <_zenon_> http://carlzimmer.typepad.com/photos/uncategorized/2008/02/17/y_combinator.jpg
10:21:28 <lambdabot> http://tinyurl.com/56kvkx
10:21:39 <_zenon_> Already done, however, the world is big enough for > 1
10:21:47 <lilachaze> vixey: can't you get it to type by wrapping everything in a data, like 'data Lambda = Lambda (Lambda -> Lambda)'?
10:22:00 <vixey> lilchaze: well that's a different thing
10:22:13 <lilachaze> fair enough
10:22:20 <xkb> lilachaze: nice one perfect! much better readability
10:22:26 <vixey> lilchaze: anyway the main point is that every expression made only of lambdas and applications will always terminate
10:22:33 <vixey> (when you try to evaluate it)
10:22:47 <_zenon_> BMeph, what coolnes where you refering to? I would also like to  see some cool
10:22:57 <vixey> it's only when you start naming things that everything goes haywire again (general recursion)
10:23:07 <loki_> is there a pattern match in haskell? say i have long string ""!QF!QA@IQIFFFIFIFIFA@DDd ao2qefi" and need to find DD ?
10:23:19 <xkb> there's a regex lib
10:23:20 <vixey> loki_: You should use a function to find it
10:23:31 <loki_> yea i was making a function
10:23:34 <xkb> although that would be very much overkill here, regex :)
10:23:38 <vixey> that's the right way to continue
10:23:46 <loki_> but is not everything a function in haskell?
10:23:46 <vixey> xkb: no regex is fine
10:23:47 <loki_> kk
10:24:03 <vixey> (for small things)
10:24:20 <loki_> well i actually need it for a compiler and to search through tokens
10:24:38 <loki_> which do not resemble the upstairs gibberish
10:24:45 <vixey> loki_: If it's a rainy day you could implement KMP
10:24:59 <loki_> whats KMP?
10:25:05 <vixey> It's a fun algorithm to implement
10:25:31 <BMeph> :t loeb
10:25:32 <lambdabot> Not in scope: `loeb'
10:25:33 <loki_> what does it stand for?
10:26:15 <loki_> just out of curiosity
10:26:44 <loki_> i guess i'll just do a search function
10:27:31 <_zenon_> loki_, do you want the index of "DD" ?
10:28:18 <loki_> naw its okay i found another way
10:28:26 <BMeph> loeb xs = fmap (\fs -> fs (loeb xs)) xs
10:28:37 <loki_> hmmm
10:28:40 <vixey> :t let loeb xs = fmap (\fs -> fs (loeb xs)) xs in loeb
10:28:40 <olsner> hmm, is there a shorthand syntax for (\x -> x { field = newVal })?
10:28:41 <lambdabot> forall (f :: * -> *) b. (Functor f) => f (f b -> b) -> f b
10:29:03 <_zenon_> @pl (\x -> x { field = newVal })
10:29:04 <lambdabot> (line 1, column 10):
10:29:04 <lambdabot> unexpected "{"
10:29:04 <lambdabot> expecting variable, "(", operator or ")"
10:29:04 <loki_> bill gates doesn't know any haskell like at all it seems
10:29:05 <vixey> olsner, what about ($ { field = newVal })? (I don't know if that would actually work)
10:29:56 <_zenon_> ?ty id
10:29:57 <lambdabot> forall a. a -> a
10:30:00 <BMeph> loeb [(!!1)+(!!2),(!!3)*3,2,1]
10:30:29 <vixey> > let loeb xs = fmap (\fs -> fs (loeb xs)) xs in loeb [(!!1)+(!!2),(!!3)*3,2,1]
10:30:31 <lambdabot>   add an instance declaration for (Num ([a] -> a))
10:30:40 <vixey> > let loeb xs = fmap (\fs -> fs (loeb xs)) xs in loeb [(!!1)+(!!2),(!!3)*3,const 2,const 1]
10:30:41 <lambdabot>   add an instance declaration for (Num ([a] -> a))
10:30:43 <_zenon_> (. id {field = newVal})
10:30:57 <vixey> > let loeb xs = fmap (\fs -> fs (loeb xs)) xs in loeb [liftM2 (!!1) (!!2),(*3).(!!3),const 2,const 1]
10:30:59 <lambdabot>      The section `(!! 2)' takes one argument,
10:30:59 <lambdabot>     but its type `[[b -> r]]' h...
10:31:35 * _zenon_ heads for startrek. Fire the photons!!!
10:33:23 <vixey> > let loeb xs = fmap (\fs -> fs (loeb xs)) xs in loeb [\x -> (x!!1)+(x!!2),(*3).(!!3),const 2,const 1]
10:33:25 <lambdabot>  [5,3,2,1]
10:38:33 * shepheb files loeb under "To be used in obfuscation contest". That has huge potential to be nigh-incomprehensible.
10:39:07 <mauke> shepheb: for some reason, loeb is also a meme on 4chan /prog/
10:41:22 <lilachaze> @pl \z -> ap (ap x z) (ap y z)
10:41:23 <lambdabot> ap (ap . ap x) (ap y)
10:41:44 <lilachaze> @pl \z -> f (f x z) (f y z)
10:41:45 <lambdabot> ap (f . f x) (f y)
10:51:59 <lilachaze> @index on
10:52:00 <lambdabot> bzzt
10:52:10 <mauke> Data.Function
10:52:23 <vixey> no
10:52:25 <vixey> @src on
10:52:27 <lambdabot> (*) `on` f = \x y -> f x * f y
10:52:35 <mauke> why "no"?
10:52:38 <vixey> there's nothing useful in Data.Function
10:52:46 <mauke> @hoogle on
10:52:46 <lambdabot> Data.Function.on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
10:52:46 <lambdabot> Test.QuickCheck.oneof :: [Gen a] -> Gen a
10:52:46 <lambdabot> Language.Haskell.Pretty.onsideIndent :: PPHsMode -> Indent
10:52:47 <vixey> the line of code is better than an import :(
10:52:56 <mauke> no
10:53:03 <idnar> @type on
10:53:04 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
10:54:34 <lilachaze> heh, the prelude contains everything in Data.Function except 'on' and 'fix'
10:54:40 <_zenon_> olsner, Did you find a solution to the field problem?
10:55:09 <olsner> _zenon_: nah, I figured it's something to put on the todo for Haskerl
10:55:23 <_zenon_> olsner, ait
10:55:45 <olsner> (i.e. whenever I build a haskell dialect, which may well never come to pass)
11:00:09 <lament> HaskeRL?
11:00:23 <mauke> haskell + perl
11:04:25 <marcot> How do I know which value to use as alignment in a instance of Storable?
11:04:42 <mauke> you ask C
11:05:03 <mar77a> ?seen C
11:05:04 <lambdabot> I haven't seen C.
11:05:44 <rog_> hi, folks. i get a syntax error from hugs when i try to define a function like: foo {x=99, y=x} = x; is this because you can't do record pattern matching or because i've got the syntax wrong?
11:05:56 <mauke> rog_: missing constructor name
11:06:08 <rog_> brilliant, ta!
11:06:21 <vixey> can you really use x twice like this?
11:06:34 <marcot> mauke: how do I ask C?
11:06:54 <mauke> marcot: are you using hsc2hs?
11:07:42 <marcot> mauke: yes.
11:07:48 <mauke> #let alignof t = "%lu", (unsigned long)offsetof(struct {char bump__; t(data__); }, data__)
11:08:08 <mauke> instance Storable Foo where alignment _ = #{alignof Foo}
11:08:31 <mauke> oh, that "alignof" definition may require #include <stddef.h>
11:08:49 <marcot> It's not in http://haskell.org/ghc/docs/latest/html/users_guide/hsc2hs.html
11:08:49 <lambdabot> Title: 11.3. Writing Haskell interfaces to C code: hsc2hs
11:09:31 <mauke> what isn't? #let?
11:09:58 <marcot> #alignof
11:10:06 <mauke> I just pasted the definition
11:10:07 <lilachaze> vixey: that pattern matching probably doesn't do what you might expect.
11:10:19 <marcot> ah, ok.
11:10:22 <marcot> thanks.
11:10:29 <vixey> lilachaze: I have no idea what it does
11:10:30 <lilachaze> vixey: or rather, what one might naively expect :)
11:10:35 <vixey> lilachaze: What does it do?
11:10:58 <rog_> another newbie quickie: is there any easy inline way of getting access to a particular member of a tuple with more than two members (without defining a new function to do it)?
11:11:21 <lilachaze> > let x = 42 in case Just 12 of Just x -> x
11:11:24 <lambdabot>  12
11:12:07 <lilachaze> vixey: ^^ it binds the name x to whatever's in y, regardless of whether its value is 99
11:12:22 <vixey> lilachaze: I meant {x=99, y=x}
11:12:33 <mauke> rog_: a destructuring binding
11:12:36 <mauke> rog_: "let" or "case"
11:12:42 <vixey> oh is this exactly the same
11:12:53 <vixey> lilachaze: ah I get it now, thanks
11:13:04 <marcot> mauke: is this the same of #{offset _XtransConnInfo} ?
11:13:23 <mauke> huh?
11:13:51 <marcot> _XtransConnInfo is the struct I'm porting to Haskell.
11:15:25 <lilachaze> rog_: if you've got a tuple with more than 2 elements, you may find it easier to work with a data type with record names anyway -- plus, you get more type safety :)
11:16:45 <rog_> so if, say, i've got an object x of type [Int, Int, String] and i want to call foo on string from the first item of the list, the best way to do it is foo (let (_, _, s) = x in s)?
11:17:03 <kaol> what'd be a pretty way to write this: foo (a1,b1) (a2,b2) = (a1++a2, b1++b2)
11:17:14 <vixey> rog_: [Int, Int, String] is not a type
11:17:19 <lilachaze> rog_: i guess you mean (Int, Int, String)? i'd destructure it pretty much as soon as i got it
11:17:58 <rog_> i actually meant foo (let (_, _, s) = head x in s)
11:18:02 <vixey> rog_: I would define thrd (_,_,e) = e
11:18:08 <vixey> rog_: then foo . thrd $ x
11:18:11 <mauke> kaol: foo = join (***) (++)
11:18:38 <rog_> vixey: problem with that is that fst and snd don't work with 3tuples... so you'd have to think of a naming scheme...
11:18:41 <vixey> rog_: then foo . thrd . head $ x
11:18:46 <vixey> rog_: *thrd*
11:18:47 <Deewiant> ?ty join (***) (++)
11:18:47 <lambdabot> forall b. (Monoid b) => (b, b) -> (b -> b, b -> b)
11:18:53 <vixey> rog_: frst, scnd, thrd
11:19:08 <byorgey> kaol: (++) *** (++)
11:19:19 <Deewiant> ?ty \(a1,b1) (a2,b2) -> (a1++a2,b1++b2)
11:19:19 <lambdabot> forall t t1. (Monoid t1, Monoid t) => (t, t1) -> (t, t1) -> (t, t1)
11:19:21 <vixey> rog_: for 4 tuples, first, secnd, third, forth ...
11:19:39 <lilachaze> fst and snd really ought to be members of a Tuple typeclass
11:20:02 <lilachaze> vixey: 'first' and 'second' are already used, though
11:20:07 <rog_> vixey: with my memory i'd instantly forget which name referred to which degree of tuple.
11:20:20 <lilachaze> vixey: number of letters = size of tuple + 1 :)
11:20:24 <vixey> import Prelude hiding (first)
11:20:25 <lilachaze> s/vixey/rog_
11:20:38 <vixey> rog_: OK
11:20:54 <vixey> rog_: I guess you could just inline everything everwhere but I don't think that's good style
11:21:14 <lilachaze> vixey: let ft (x) = (x); f () = () ;-)
11:21:36 <vixey> f = ()
11:21:44 <vixey> hmm
11:21:49 <vixey> no you were right
11:22:01 <mar77a> > fst ()
11:22:02 <lambdabot>  Couldn't match expected type `(a, b)' against inferred type `()'
11:22:08 <mar77a> > fst ((),())
11:22:09 <lambdabot>  ()
11:22:35 <vixey> @check True
11:22:38 <lambdabot>  OK, passed 500 tests.
11:22:47 <sioraiocht> well done, vixey p
11:22:48 <sioraiocht> =p
11:23:34 <lilachaze> heh, (infinite types notwithstanding) "join on join" === "join `on` join"
11:24:01 <rog_> currently i'm just using t0, t1, etc but it'll only work for 3tuples. if a 3tuple was defined as (t0, (t1, t2)) then it'd be possible to operate on tuples generically, but that'd probably lead to horrible problems. hmm.
11:24:42 <rog_> thanks
11:25:27 <lispy> Well, if tuples were defined that way it would be lisp :)
11:25:49 <lispy> car = fst; cdr = snd
11:25:52 <vixey> MULTIPLE-VALUE-BIND
11:26:06 <mauke> rplacd
11:26:23 <lilachaze> DYNAMIC-WIND
11:26:31 <vixey> oh no
11:26:49 <mauke> UNWIND-PROTECT
11:27:59 <lispy> mapcar f () = (); mapcar f xs = (f (fst xs), mapcar f (snd xs)) -- I think...
11:28:25 <lispy> let { mapcar f () = (); mapcar f xs = (f (fst xs), mapcar f (snd xs)) } in mapcar
11:28:33 <lispy> > let { mapcar f () = (); mapcar f xs = (f (fst xs), mapcar f (snd xs)) } in mapcar
11:28:33 <lambdabot>  Couldn't match expected type `(a, b)' against inferred type `()'
11:29:10 <vixey> you would need typeclasses for the sort of recursion here I think
11:30:07 <_zenon_> @unwind
11:30:08 <lambdabot> Unknown command, try @list
11:30:45 <olsner> hmm, cabalisation ... what's the difference between BSD3 and BSD4?
11:30:58 <olsner> (the licenses, that is)
11:31:38 <olsner> this numbering seems to be specific to cabal/haskell projects
11:32:11 <glguy> olsner: BSD4 is the 4-clause license
11:32:15 <glguy> and has an advertising clause
11:32:19 <thoughtpolice> they're different revisions of one license
11:32:27 <glguy> and is typically not used
11:32:28 <olsner> glguy: oh, okay
11:44:56 <olsner> hmm, how do you make cabal figure out the set of source files for an executable? I did a cabal sdist and had hoped all the recursive dependencies for Main would get included automatically..
11:45:48 <Saizan> olsner: you've to list them in other-modules
11:45:53 <thoughtpolice> olsner: unfortunaetly no, they dont. you have to list them
11:46:16 <olsner> oh, I see
11:46:31 <Saizan> olsner: after this summer it should come automatically
11:46:40 <olsner> (y)
11:50:23 <BMeph69> olsner: How would you have cabal figure out which files are "leftover" from work, and which ones should build, but aren't? :)
11:50:52 <BMeph69> aren't building, that is. :)
11:51:53 <olsner> BMeph69: hmm, I'm mostly referring to the dependencies of Main (which should be straight-forward to figure out)
11:53:03 <olsner> modules that are in the source tree but not used by any exported module or executable are another issue, but you wouldn't actually need them in the source distribution to build the software anyway
11:53:21 <BMeph69> olsner: Take that phrase, and post it on the wall: "should be straight-forward to figure out". ;)
11:53:38 <tibbe> can I have guards ("|") in lambda expressions? it would be jolly convenient right now. I couldn't find anything about it in the report but "|" is hard to search for in a grammar ;)
11:53:52 <mauke> tibbe: only one of them, I think
11:53:59 <loki_> if i make two lists [[String]] is there a function to see that the first [[String]] is a subset of the second [[String]]
11:54:12 <ski> > (\x | x > 0 -> ()) 1
11:54:12 <lambdabot>  Parse error at "|" (column 5)
11:54:15 <loki_> or would i need to make a function based on elem?
11:54:16 <olsner> BMeph69: well, compared to, for example, building a haskell type checker or any choice of type system extension :)
11:54:23 <mauke> tibbe: or none :-(
11:54:30 <ski> tibbe : you could try a `case'
11:54:38 <mauke> loki_: why not use a Set?
11:55:00 <loki_> Set? thats cool its actually set of [String]
11:55:09 <vixey> case () of () | _ -> _ is usual
11:55:13 <loki_> well actually set is hot how do i use it?
11:55:26 <mauke> loki_: http://haskell.org/ghc/docs/latest/html/libraries/containers/Data-Set.html
11:55:28 <lambdabot> Title: Data.Set, http://tinyurl.com/5tm3pu
11:55:36 <loki_> kk
12:00:19 <Parkkeeper> Excuse me (might be obvious), can someone explain me the difference:
12:00:22 <Parkkeeper> *Main> :t add
12:00:22 <Parkkeeper> add :: (Num a) => t -> t1 -> a -> a -> a
12:00:22 <Parkkeeper> *Main> :t \x -> \y -> x+y
12:00:22 <Parkkeeper> \x -> \y -> x+y :: (Num a) => a -> a -> a
12:00:35 <mauke> what is add?
12:00:39 <Parkkeeper> add is add x y = \x -> \y -> x+y
12:00:42 <mauke> heh
12:00:51 <_zenon_> bringert, are you the creator of #haskell.se ?
12:00:56 <mauke> that's the same as add = \x -> \y -> \x -> \y -> x+y
12:01:10 <paczesiowa> plenty of shadows
12:01:25 <vixey> How come I am having trouble with pattern matching.. I've even written the code before
12:04:17 <Parkkeeper> mauke: but why doesn't ":t add" give me add :: (Num a) =>  a -> a -> a -> a -> a in this case and how to define add to get (Num a) => a -> a -> a ?
12:04:47 <mauke> because the first two arguments can be of any type at all
12:04:59 <mauke> you don't use them in the function body, so no constraints apply
12:05:07 <mauke> add x y = x + y
12:06:09 <Saul_> Parkkeeper: In general, f x = y is the same as f = \x -> y
12:07:14 <vixey> you wrote
12:07:21 <vixey> add x y = \x -> \y -> x+y
12:07:23 <vixey> it's the same as
12:07:26 <vixey> add p q = \x -> \y -> x+y
12:07:29 <vixey> which is the same as
12:07:35 <vixey> add p q x y = x+y
12:07:38 <vixey> (rougly)
12:07:44 <Parkkeeper> mauke, vixey & Sauul_: TNX, now I can see
12:08:15 <Saul_> happy to help
12:09:58 <Leaves> Hello, I use ghc, I have to do import Char and then I can do for instance isDigit, but in a lot of examples they do just Char.isDigit, do you know how I can do it without import too?
12:10:19 <vixey> use Char.isDigit
12:10:23 <mauke> only in ghci
12:10:43 <vixey> import qualified Char
12:11:25 <Leaves> but I do not want to do import (since I only use the function one time), why is there a difference between ghci and ghc?
12:11:39 <vixey> Leaves: if you do import qualified Char
12:11:40 <mauke> the language definition says you need an import
12:11:49 <vixey> Leaves: or import Char (isDigit)
12:11:56 <vixey> Leaves: only those names will be around
12:12:01 <mauke> ghci is an interactive interpreter, it doesn't really need to follow the rules
12:12:41 <Leaves> ok, If the standard says so I will use the import, aah I see, that's why ghci is a bit different.
12:13:15 <Leaves> I have another question, in examples they often use isEven, but I have to type even, do you know what the standard says?
12:13:25 <mauke> it says even
12:13:29 <mauke> where do you see isEven?
12:13:47 <vixey> isEven = even
12:13:52 <vixey> then you can use 'isEven'
12:14:33 <int-e> > let is = id in map (is odd) [2^0, 2^1, 2^2]
12:14:34 <lambdabot>  [True,False,False]
12:14:44 <Leaves> mauke: on the bottom here: http://en.wikibooks.org/wiki/Haskell/Solutions/More_about_lists
12:14:45 <vixey> heh
12:15:05 <Leaves> vixey: I understand, but I want to follow the standart, so I will use even
12:15:23 <int-e> > let is  = flip id in 2^0 `is` odd
12:15:24 <lambdabot>   add an instance declaration for (Integral Bool)
12:15:24 <lambdabot>     In the expression: let ...
12:15:28 <mauke> Leaves:  One could handcraft a recursive function called retainEven, based on a test for evenness which we've already written called isEven:
12:15:32 <Leaves> mauke: in other functions they often use the is prefix when it is a bool, is this a lottle inconsitency?
12:15:42 <int-e> > let is  = flip id in (2^0) `is` odd
12:15:43 <lambdabot>  True
12:17:05 <Leaves> mauke: I did not understand the last message from you, I though the is prefix was there to say it is a bool?
12:17:17 <mauke> that was a quote from the wiki
12:17:57 <Leaves> ok, I see
12:18:57 <Leaves> but I will use even from now on, thanks for your help explaining :)
12:31:28 <paczesiowa> weird question: my first shot at ffi, I foreign imported strtod() from header file and it works in ghci, where does binary code come from?
12:32:32 <olsner> paczesiowa: libc?
12:35:45 <loki_> so far i have written the rpoku compiler without any imports of non standard functions
12:36:03 <vixey> What is rpoku?
12:36:15 <BMeph69> Is it Finnish? :)
12:36:32 <loki_> rpoku bong is 4 bit human speakable programming language
12:36:48 <loki_> rpoku just human speakable programming language
12:37:03 <paczesiowa> ghc-produced programs (on linux) are statically linked with haskell libraries but dynamically with c code, right?
12:37:55 <loki_> so far my Tokenizer Parser is just under 1000 lines
12:38:21 <loki_> more of a Library actually
12:38:33 <vixey> I think 1000 lines is a lot
12:38:39 <loki_> the compiler imports the Tokenizer and does the langauge specific stuff
12:38:45 <vixey> just how complex is this language?
12:39:00 <loki_> well its like lojban
12:39:08 <vixey> oh I understand
12:39:11 <loki_> just more formal
12:39:19 <loki_> yep
12:39:26 <vixey> It looked like lojban had a much much bigger parser written in C
12:39:27 <loki_> and designed to be a programming language
12:40:20 <loki_> yea lojban is a grammatical parser mainly for telling right from wrong its a judicial system
12:40:36 <loki_> has a *
12:41:12 <loki_> the people in #lojban really aren't great fans of me for using "wrong expressions"
12:41:25 <loki_> oh well
12:41:31 <LordBr4in> is rpoku related to lojban, or is it like it in the way of being a similar idea?
12:42:05 <LordBr4in> i mean do you base its vocab on lojban?
12:42:06 <loki_> its derived, rpoku bong is 4 bit so has 16 letters 14 phonemes
12:42:29 <loki_> the vocab is the same but softened into rpoku phonetics
12:42:58 <LordBr4in> is it a functional language?
12:43:19 <loki_> rpoku l3-\B! or ki-gbu is 8 bit and so has room for 256 characters and extended vocab
12:43:24 <loki_> LordBr4in: yep
12:43:33 <LordBr4in> interesting
12:43:41 <loki_> LordBr4in: functional and predicate
12:44:08 <LordBr4in> what does it being predicate mean?
12:44:13 <loki_> so arguments can be predicate but i am hoping on making it one word one function sorta deal -- different than lojban
12:44:28 <LordBr4in> one word one function hmmm
12:44:58 <loki_> well for addition 3 AND 4 (function ADD)
12:45:01 <LordBr4in> is it currying?
12:45:23 <loki_> or kibqkq.uki.uikqzi-dxi
12:45:31 <loki_> currying? whats that?
12:46:00 <LordBr4in> currying means that f x y  = (f x) y
12:46:13 <vixey> :t curry
12:46:15 <vixey> :t uncurry
12:46:19 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
12:46:19 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
12:46:52 <LordBr4in> it is the reason partial applications are functions in haskell
12:47:57 <LordBr4in> scheme doesn't curry... although they have nifty cut and cute operators
12:48:27 <loki_> hmmm well one thing at a time really .u but can make multi argumented functions by adding more words  so a function to assign variable could be called NumberName Na-mjujma-Na taking two arguments
12:48:39 <LordBr4in> which in some ways is better... since you dont have to mess around with flip and things... you can leave out which ever parameters you want
12:49:56 <Codex_> :t curry id
12:49:58 <lambdabot> forall a b. a -> b -> (a, b)
12:50:03 <Heffalump> :t (,)
12:50:04 <lambdabot> forall a b. a -> b -> (a, b)
12:50:24 <loki_> so how would that be in English?
12:50:41 <Codex_> :t uncurry id
12:50:43 <lambdabot> forall b c. (b -> c, b) -> c
12:50:52 <vixey> :t ($)
12:50:53 <lambdabot> forall a b. (a -> b) -> a -> b
12:51:10 <loki_> thats all plain haskell to me
12:51:24 <vixey> lambdabot: Why not be more consistent with your naming of types .{
12:51:41 <LordBr4in> loki_, it's like implicitely every function is actually of one parameter... so f x y z = is just really short hand for f = \x -> \y -> \z ->
12:51:43 <wuxia> i'm reading soe ... and i can't find the motivation behind 'lifting' ... can anyone enlighten me?
12:51:58 <LordBr4in> soe?
12:52:03 <wuxia> school of ecpression
12:52:06 <LordBr4in> school of expression ah
12:52:07 <wuxia> haskell school of expression
12:52:12 <LordBr4in> i see
12:53:01 <thoughtpolice> loki_: currying is building functions that take multiple arguments from functions that take one argument. partial application is the reverse: you can create functions that take one parameter from functions that take multiple ones
12:53:13 <LordBr4in> is it lift in the context of monad transformers or lift as in liftM ?
12:53:23 <loki_> well i guess lujvo ku-jvu compoundWords could be curry expressions with  definable argument set
12:53:26 <vixey> thoughtpolice: no it's not ..
12:53:40 <vixey> thoughtpolice: Look at the types of curry and uncurry instead of the confusing source definitions
12:54:13 <vixey> (unless by a function that takes multiple arguments you mean a function that takes a single tuple?)
12:54:45 <thoughtpolice> vixey: i was going from what I gout ot of tapl
12:54:51 <thoughtpolice> s/gout/got/
12:55:18 <LordBr4in> tapl? is that another book?
12:55:23 <loki_> so what is a simple example where currying is used?
12:55:28 <thoughtpolice> sorry, were we actually talking about the functions curry and uncurry?
12:55:42 <vixey> to curry is to take a function  A  B  C -> D  to A -> (B -> (C -> D))
12:55:46 <thoughtpolice> LordBr4in: pierce's types and programming language
12:55:46 <loki_> i use lots of functions in my tokenizer with upwards of 5 args
12:55:59 <LordBr4in> loki_, well whenever we use partial applications we're making use of currying:
12:56:08 <LordBr4in> > map (3+) [1..5]
12:56:09 <lambdabot>  [4,5,6,7,8]
12:56:13 <thoughtpolice> loki_: all functions in haskell actually take one parameter. a function of type int -> int -> int is actually int -> (int -> int)
12:56:54 <loki_> so how does the conversion process take place?
12:56:55 <thoughtpolice> for example if you have the function 'plus x y = x + y', it's actual definition could be thought of as 'plus x = \y -> x + y'
12:57:24 <thoughtpolice> meaning plus actually takes one parameter and returns a function that takes another parameter.
12:57:43 <thoughtpolice> types are right associative, meaning A -> B -> C -> D == A -> (B -> (C -> D))
12:57:59 <thoughtpolice> and function application is left associative, meaning f x y == (f x) y
12:58:34 <thoughtpolice> the reason they're that way is because of currying.
12:58:59 <loki_> hmmm kk i think i understand the function with one argument returns a function that takes an arguments
12:59:00 <LordBr4in> and haskell is currying because lamda calculus is currying..
13:00:40 <loki_> well perhaps i will look up some lambda calculus as well then
13:00:47 <vixey> haskell curries only for pragmatic reasons
13:01:00 <thoughtpolice> loki_: types and programming languages has an excellent introduction to the lambda calculus
13:01:01 <loki_> but actually rpoku compiles into assembly
13:01:06 <thoughtpolice> it's a good book
13:01:21 <stepcut> is there a way (in GHCi) to kill all the threads started by forkIO if I don't know any of the ThreadIds ? (It could be a GHCi command, and not a Haskell function)
13:01:24 <_zenon_> loki_, May I recommend http://www.cs.chalmers.se/Cs/Research/Logic/TypesSS05/Extra/geuvers.pdf
13:01:26 <lambdabot> Title: Introduction to Lambda Calculus, http://tinyurl.com/5htcb2
13:01:38 <loki_> kk
13:02:22 <thoughtpolice> stepcut: i don't believe so, no.
13:03:28 <stepcut> thoughtpolice: ok, I didn't see anything either.
13:04:46 <LordBr4in> loki, look at scheme's cut/cute too... pragmatically, currying is useful for ommiting parameters from functions to get new functions... but currying only lets you omit the final paraemters... cut/cute let you do things like use f () () z  (where f takes 3 parameters) as a function of two parameters... I like currying, but i have to admit that it is cool.
13:05:02 <vixey> schemes cut is not currying
13:05:30 <LordBr4in> i didn't say it was
13:06:21 <dmhouse> That could get annoying if you only want to pass the tenth parameter, etc.
13:06:23 <LordBr4in> i like the nice clean notation haskell has for currying tho
13:06:52 <LordBr4in> for partial applications i should say
13:07:09 <dmhouse> I'm yet to see a mainstream programming language where named parameters are standard. I think you should have to annotate every parameter with its name, at the site of calling.
13:07:25 <dmhouse> Improve inline documentation and allows you to specify any subset of the parameters.
13:07:53 <tibbe> dons: ping
13:08:01 <LordBr4in> hmmm yeah, but when you leave off parameters in most langauges you don't get a function back, you just get the same function with defaults applied..
13:08:24 <LordBr4in> i like getting a function
13:08:50 <vixey> I don't know any languages which do that
13:09:00 <Beelsebob> dmhouse: how about Objective-C or Smalltalk
13:09:01 <LordBr4in> do what?
13:09:11 <vixey> what you just said
13:09:12 <dons> tibbe: yo
13:09:15 <LordBr4in> give a functino back?
13:10:16 <tibbe> dons: what's the fastest way you know of checking two bytestrings for equality *and* if they're not equal retrieving the location where they didn't match?
13:10:19 <LordBr4in> c lets you define default values and ommit parameters that way. haskell you can take advantage of currying to leave off parameters and get a functino back.
13:10:28 <dons> tibbe:  hmm.
13:10:44 <vixey> LordBr4in: Can you show me an example of this in C?
13:10:45 <tibbe> dons: memcmp unfortunately doesn't return the index
13:10:48 <dons> tibbe: modify the existing compare function in Data.ByteString
13:11:04 <vixey> LordBr4in: oh did you mean C++?
13:11:10 <LordBr4in> yes i suppose i did
13:11:17 <tibbe> dons: memcmp is so nice and fast! does a word at the time instead of a byte at the time etc
13:11:22 <vixey> LordBr4in: OK, I don't doubt C++ does it
13:11:22 <LordBr4in> sorry
13:11:24 <vixey> but C doesn't
13:11:45 <dons> tibbe: yeah, the existing compare uses memcmp underneath
13:11:51 <tibbe> dons: is the latest bytestring under code. or darcs.haskell.org?
13:11:54 <dons> but i wonder how hard it is to modify.
13:12:18 <dons> http://darcs.haskell.org/bytestring
13:12:20 <lambdabot> Title: Index of /bytestring
13:12:50 <tibbe> dons: I would like to avoid copying the underlying code in memcmp since it is implemented differently on different platforms. it's a surprisingly long C function if you check in e.g. glibc
13:13:04 <LordBr4in> i knew it was in c++, i wasnt sure about c
13:13:20 <dons> tibbe: hmm.
13:13:22 <LordBr4in> i suspect java does that too
13:13:35 <vixey> No I think that Java doesn't do this
13:13:42 <tibbe> dons: memcmp is perfect except for the index issue
13:13:56 <stulli> > let f x = [1+x,2*x]
13:13:56 <lambdabot>  Parse error at end of input
13:14:03 <stulli> > putStrLn . show $ do f 6 >>= \a -> f a >>= \b -> return b
13:14:07 <lambdabot>        add an instance declaration for (SimpleReflect.FromExpr (t a1))
13:14:09 <marcot> @hoogle Monad m => (a -> b -> m c) -> m a -> m b -> m c
13:14:10 <lambdabot> Prelude.flip :: (a -> b -> c) -> b -> a -> c
13:14:10 <lambdabot> Data.Function.flip :: (a -> b -> c) -> b -> a -> c
13:14:10 <lambdabot> Data.Function.on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
13:14:12 <vixey> > let f x = [1+x,2*x] in f 1
13:14:14 <lambdabot>  [2,2]
13:14:19 <stulli> ow, right
13:14:34 <vixey> :t liftM2
13:14:34 <marcot> Do you know of a function like this?  Or I'll have to use do in this case.
13:14:36 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
13:14:41 <tibbe> dons: if I wrote a function that did it would you be interested of including it in bytestring or isn't it useful enough? like longestCommonPrefix
13:14:42 <vixey> mm
13:15:00 <stulli> > let f x = [1+x,2*x] in putStrLn . show $ do f 6 >>= \a -> f a >>= \b -> return b
13:15:02 <vixey> :t \f ma mb -> join (liftM2 f ma mb)
13:15:04 <lambdabot> forall a1 a2 (m :: * -> *) a. (Monad m) => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
13:15:08 <lambdabot>  <IO ()>
13:15:15 <tibbe> dons: I don't want to add it if it's not useful enough since the interface is quite wide already
13:15:20 <vixey> :t ((.).(.)) join liftM2
13:15:21 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a2)
13:15:21 <lambdabot>     Probable cause: `liftM2' is applied to too many arguments
13:15:21 <lambdabot>     In the second argument of `((.) . (.))', namely `liftM2'
13:15:50 <vixey> @pl \f ma mb -> join (liftM2 f ma mb)
13:15:51 <lambdabot> ((join .) .) . liftM2
13:16:29 <dmhouse> Beelsebob: hah, can't believe I haven't spotted those examples already
13:17:20 <tibbe> dons: there's a pure haskell version of compareBytes commented out in the code
13:19:57 <LordBr4in> delphi,php,python are other langauges with default parameters
13:20:13 <LordBr4in> similar to c++
13:20:41 <_zenon_> LordBr4in, you mean default parameters as in, if not given, assume defined value?
13:20:47 <LordBr4in> yes
13:20:52 <vixey> that's interesting I've programmed in php python and C++ but I must have erased all that horrible experince from my mind
13:20:57 <_zenon_> Ah, lisp has those 2 :)
13:20:58 <BMeph69> tibbe: Does stripPrefix do what you want? Oh, wait, is there a stripPrefix in BS?
13:22:04 <LordBr4in> having the omit-parameter means it returns a function instead is much nicer in my opinion.. of course that's probably not controversal here...
13:22:34 <tibbe> BMeph69: doesn't have it
13:22:57 <tibbe> BMeph69: it's also a bit too expensive for what I want to do
13:23:19 <tibbe> BMeph69: the best would be if memcmp did it already
13:23:24 --- mode: ChanServ set +o dons
13:23:27 --- mode: dons set -b *!*n=rhz@*.wavrl2.nsw.optusnet.com.au
13:23:32 --- mode: ChanServ set -o dons
13:23:55 <tibbe> BMeph69: it would be exactly the same as the memcpy code (in C) except it would return the index instead of the byte difference
13:24:47 <BMeph69> tibbe: Okay, I smell what you're stepping in. ;)
13:25:23 <tibbe> heh
13:25:32 <tibbe> OK, I need to leave, I'll be online again later
13:26:48 <macondo> @src nub
13:26:49 <lambdabot> nub = nubBy (==)
13:27:14 <macondo> @src nubBy
13:27:15 <lambdabot> nubBy eq []             =  []
13:27:15 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
13:31:06 <_zenon_> Maybe this already exists
13:31:36 <_zenon_> but what about a huuuge database of different haskell hacks for different problems ?
13:32:31 <EvanCarroll> HALLO NEWBS.
13:32:37 <_zenon_> Not hackage, more like. (Problem, [User code])
13:32:41 <vixey> hackage
13:33:05 <vixey> there's something a bit like that but it's for every language
13:33:11 <_zenon_> rosetta stone?
13:33:16 <_zenon_> I believe, or whatsname
13:33:41 <macondo> Can I indent lambda calculi?
13:33:43 <_zenon_> vixey, whas I dead wrong on it?
13:33:54 <_zenon_> macondo, how do you mean?
13:34:45 <macondo> > (\x -> (\y -> y+1) x+1) 1
13:34:46 <lambdabot>  3
13:34:55 <_zenon_> For example, say someone wants to see some examples on using list comprehension, thus all those examples would be gathered on _one_ place
13:35:03 <macondo> _zenon_: that :)
13:35:13 <_zenon_> macondo, Well, yes :)
13:35:34 <_zenon_> macondo, you meant "nest  lambda expressions  ?"
13:35:46 <gbacon> anyone know of any HDF5 bindings for ghc?
13:35:49 <macondo> yep
13:36:42 <orzo> ghc 6.8.3 does not support cross compiling, correct?
13:37:13 <Baughn> Nope
13:37:58 <orzo> i want to make universal binaries on os x. I'm thinking of getting a universal of ghc and runing it twice, once under rosetta in order to cross compile for the ppc platform.  Since ghc will be running in ppc emulation, it wont need to know its cross compiling and everything should work
13:38:35 <Baughn> No, I don't think it would
13:38:47 <orzo> damn
13:38:50 <orzo> why not
13:38:54 <Beelsebob> orzo: I think your only option is to -fvia-c it and use gcc in cross compiling mode
13:39:03 <Baughn> orzo: All the /other/ files would collide
13:39:25 <orzo> what other files
13:39:28 <Baughn> orzo: You could instead have two distinct ghc installations, compile separately, and combine afterwards
13:39:31 <_zenon_> Did someone think it was a good idea of the gathered code examples?
13:39:38 <Baughn> The libraries, .hi files from compilation, etc. etc. etc.
13:40:05 <Baughn> orzo: That is to say, install one ghc with --prefix /usr/local/intel, one with /usr/local/ppc
13:40:23 <vixey> _zenon_: yeah add to rosettacode
13:40:26 <orzo> i'm doign my linking directly
13:40:30 <orzo> the hard way
13:40:30 <Baughn> And make sure not to install packages in your homedir, unless you change it from the default path of ~/.ghc
13:40:33 <orzo> ghc isnt doing it for me
13:40:45 <orzo> does that make it more promissing?
13:40:49 <Baughn> Nope
13:40:55 <Baughn> You still need both the intel and ppc libraries for ppc
13:40:58 <Baughn> *for ghc
13:41:02 <_zenon_> vixey, Does rosettacode not only accept example code for specific algorithms?
13:41:03 <orzo> well yes
13:41:14 <Baughn> They'll want to use the same name and path, unless you use distinct prefixes
13:41:16 <orzo> but mac ports has a +universal variant of ghc
13:41:21 <orzo> macports
13:41:23 <Baughn> So just do that. It's the path of least resistance, really
13:41:51 <orzo> i'm installing the universal variant of ghc now
13:41:57 <vixey> _zenon_: it's categorized by what programs do
13:41:58 <orzo> i guess i'll try it out
13:42:21 <orzo> i believe you can run universals as ppc even though they contain native code
13:42:44 <Beelsebob> orzo: you can, but you need to do it via get-info
13:42:50 <macondo> > let pitagos n = nubBy (\x y -> fst' x == snd' y) $ [(a, b, h) | a <- [1..n], b <- [1..n], h <- [1..n], h^2 == a^2 + b^2] where fst' (a,_,_) = a; snd' (_,a,_) = a in pitagos 20
13:42:52 <lambdabot>  [(3,4,5),(5,12,13),(6,8,10),(8,15,17),(9,12,15),(12,16,20)]
13:42:54 <Beelsebob> which is somewhat hard to do with calls to ghc
13:42:56 <orzo> get-info?
13:43:02 <Beelsebob> in the finder
13:43:24 <orzo> well there's probably some command line trick to do it too.  You don't think so?
13:43:36 <macondo> What do you think about my very inefficient pythagorean triple finder?
13:43:37 <Beelsebob> macondo: surely you can find a better name for a pythagorianTripples function
13:44:27 <macondo> Beelsebob: actually in Spanish it's called Pitgoras, hence that name.. :)
13:45:22 <vixey> > [ (u^2-v^2,2*u*v,u^2+v^2) | u <- [1..] , v <- [1..u] , u > v , u`gcd`v == 1 , (odd u && even v) || (odd v && even u) ]
13:45:24 <lambdabot>  [(3,4,5),(5,12,13),(15,8,17),(7,24,25),(21,20,29),(9,40,41),(35,12,37),(11,6...
13:46:00 <Beelsebob> macondo: but your name doesn't match the spanish either
13:46:26 <LordBr4in> you'd complain less if he just called it f
13:46:34 <Beelsebob> true dat
13:46:40 <Beelsebob> foo is a way more explanatory name
13:46:41 <LordBr4in> :)
13:46:44 <macondo> "diminutive", it's called
13:46:45 <lament> MacOndo
13:47:29 <orzo> /usr/libexec/oah/translate will launch ppc apps from the command line.  I don't know if i can force it to use ppc when running a universal though
13:48:18 <macondo> yes, lment
13:54:36 <orzo> what do i miss out on with -via-c ?  Can i use -via-c only to make the ppc objects but not the intel objects and everything will work out?  or does -via-c completely change how the code is divided into linker modules?
13:55:12 <Baughn> orzo: Well, -fvia-c is somewhat slower to compile. Idealy, it'd also produce slower code
13:55:25 <Baughn> As it is, I don't think there are any actual downsides
13:56:19 <Baughn> Oh, but it does change the entirety of code generation, from C-- (or whatever they're calling it) on down
13:57:04 <stepcut> orzo: -fvia-c was the default until recently. dons ran some tests that showed the the -fasm backend produced code that was on par with -fvia-C, but took half the time to generate. So, the default was changed...
13:57:37 <Baughn> orzo: The native backend /should/ produce better code than -fvia-c. It's getting there.
13:57:48 <Baughn> So, yes, sticking to the default is best, if you can
13:58:05 <stepcut> orzo: I suspect you can link even if half your code was -fasm and half was -fvia-c
13:58:06 <paczesiowa> dons: take a look at http://hpaste.org/8946 I think that C is the way to go, perhaps bsd libc?
13:58:17 <dolio> It doesn't do significantly worse in most cases.
14:06:16 <dolio> paczesiowa: What are the imports for that code?
14:06:56 <dolio> Some bang patterns would probably make the haskell perform better (although it probably won't match C).
14:07:16 <dons> parsing's an interesting question though.
14:07:43 <ddarius> Baughn: -fvia-C currently produces significantly better code for floating point arithmetic.  Otherwise they're about comparable though the native code backend "currently" (as of 6.8) has a less than amazing register allocator.
14:08:02 <novas0x2a> i know this is probably easy, but i'm not sure how to do it: a function with the signature (Maybe a, Maybe b) -> Maybe (a, b)
14:08:08 <stepcut> @pl \a -> f a >>= g
14:08:08 <lambdabot> (g =<<) . f
14:08:40 <Baughn> @pl \(Just a, Just b) -> Just (a,b)
14:08:40 <lambdabot> (line 1, column 8):
14:08:40 <lambdabot> unexpected "a"
14:08:40 <lambdabot> expecting operator or ")"
14:08:43 <paczesiowa> dolio: 90% of imports is the same as ByteString.Char8 (plenty)
14:08:44 <Heffalump> @type liftM2 (,)
14:08:46 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
14:08:55 <Heffalump> @type uncurry (liftM2 (,))
14:08:56 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => (m a1, m a2) -> m (a1, a2)
14:09:05 <vovik> @map (\x x+1) (1,2,3)
14:09:06 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
14:09:09 <novas0x2a> a hah! thanks Heffalump, liftM2 was what i was missing
14:09:54 <paczesiowa> dolio: if you are interested I can put all that in one file
14:10:10 <dolio> paczesiowa: I just wanted to compile it and look at the core.
14:10:42 <paczesiowa> dolio: loops are strict, bang patterns didn't help
14:10:46 <BMeph69> @type sequenceA
14:10:48 <lambdabot> Not in scope: `sequenceA'
14:11:28 <BMeph69>  @type Data.Traversable.sequenceA
14:11:49 <dolio> loop doesn't look strict in n or i.
14:11:49 <BMeph69> @ho sequenceA
14:11:50 <lambdabot> Maybe you meant: hoogle hoogle+ . ? @ bf echo ft ghc id pl rc show thx v wn yow
14:12:17 <BMeph69>  
14:12:17 <BMeph69> ERC>
14:12:17 <BMeph69> ERC> @hoogle sequenceA
14:12:18 <paczesiowa> dolio: wait 5 min, I'll cat my files together
14:12:29 <dolio> Okie dokie.
14:12:40 * BMeph69 sighs at how awkward ERC feels.
14:12:49 <BMeph69> @hoogle sequenceA
14:12:51 <lambdabot> Data.Traversable.sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
14:12:51 <lambdabot> Data.Foldable.sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f ()
14:13:51 <BMeph69> > Data.Traversable.sequenceA (Just 2, Just 'd')
14:13:53 <lambdabot>        add an instance declaration for
14:13:53 <lambdabot>       (Data.Traversable.Traversable ((...
14:14:06 <vovik> @show map (\x x+1) (1,2,3)
14:14:07 <lambdabot> "map (\\x x+1) (1,2,3)"
14:14:20 <vovik> @ghc map (\x x+1) (1,2,3)
14:14:21 <lambdabot> No quotes match. Do you think like you type?
14:14:29 <vovik> hmm how do you work this thing
14:14:37 <vovik> er i guess
14:14:44 <vovik> @map (\x x+1) [1,2,3]
14:14:45 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
14:14:54 <vovik> @ghc map (\x x+1) [1,2,3]
14:14:54 <lambdabot> No quotes match. My pet ferret can type better than you!
14:14:58 <BMeph69> vovik: map (\x->x+1) [1,2,3] --did you mean this?
14:15:08 <vovik> oh yes
14:15:19 <BMeph69> >  map (\x->x+1) [1,2,3]
14:15:19 <vovik> @ghc map (\x -> x+1) [1,2,3]
14:15:19 <lambdabot> No quotes match. My brain just exploded
14:15:21 <lambdabot>  [2,3,4]
14:15:34 <vovik> oh thx :D
14:16:11 <Baughn> > map (+1) [1..3]
14:16:12 <lambdabot>  [2,3,4]
14:16:28 <macondo> > [2..4]
14:16:29 <lambdabot>  [2,3,4]
14:16:49 <Baughn> > take 3 $ iterate (+1) 2
14:16:50 <lambdabot>  [2,3,4]
14:16:51 <vovik> > [1..]
14:16:52 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
14:17:24 <vovik> what's the point of the $, i realize it replaces parens but what's the point?
14:17:34 <Baughn> It replaces parens.
14:17:42 <marcot> vovik: the point is not to use a lot of parens
14:17:48 <Baughn> vovik: Oh, and you can do this:
14:17:52 <vixey> > map ($ 3) [(+1),(*2)]
14:17:53 <lambdabot>  [4,6]
14:18:00 <vovik> is to to prevent haskell from looking like lisp?
14:18:01 <Baughn> ..that.
14:18:09 <macondo> > 2:3:4:[]
14:18:10 <lambdabot>  [2,3,4]
14:18:12 * vixey Baugns assistant: p
14:18:15 <marcot> vovik: instead of f (g (h (i (j k)))), you use f $ g $ h $ i $ j k...
14:18:32 <vixey> bleh write f . g . h . i . j $ k
14:18:32 <Baughn> vovik: Or you could say (f.g.h.i.j) k
14:18:48 <Baughn> #Haskell: There's more than one way to do it
14:18:51 <vovik> ok that makes sense i guess
14:19:04 <vovik> #haskell: perl with monads!
14:19:04 <jberryman> I've been working on a programming problem involving taking an integer and adding the squares of its digits. I found my first attempt at that algorithm was much slower than the second method I tried. I wondered if anyone here would extract the digits differently from my second method: http://hpaste.org/8947#a0
14:19:39 <Baughn> vovik: That's "Perl with more than one monad, and the option of none"
14:20:04 <vovik> perl has a monad?
14:20:09 <Baughn> Yes. IO.
14:20:24 <dmhouse> > sum . map ((^2) . read . (:[])) . show $ 1234
14:20:26 <lambdabot>  30
14:20:29 <ddarius> jberryman: I can make it faster.  Just job the reverse.
14:20:33 <vovik> i wouldn't call perl's io monadic
14:20:37 <vixey> if you use haskell long enough every impure language looks monadic
14:20:43 <orzo> hmm, i installed +universal variant of ghc via macports and got i386 binaries
14:21:26 * dmhouse reminds himself to look at the paste before suggesting answers
14:22:02 <lispy> dmhouse: what is that (:[]) for?
14:22:13 <Baughn> lispy: SCSI terminator
14:22:16 <dmhouse> > sum . map ((^2) . read) . show $ 1234
14:22:18 <lambdabot>  Couldn't match expected type `String' against inferred type `Char'
14:22:23 <ddarius> > let f = sum . map (join(*) . digitToInt) . show in f 200
14:22:23 <lambdabot>  4
14:22:51 <dmhouse> lispy, read :: (Read a) => String -> a. It needs a String, not a Char.
14:23:12 <dmhouse> lispy: so (:[]), a.k.a., \x -> [x], turns a Char into a singleton String.
14:23:14 <lispy> oh, right
14:23:16 <glguy> :t digitToInt
14:23:17 <lambdabot> Char -> Int
14:23:18 <jberryman> ddarius: do you mean get rid of the reverse? I know it's pointless the way I'm using it here
14:23:27 <waern> is there a common class for one element functors?
14:23:31 <lispy> dmhouse: yeah, I know that last bit, I just forgot that read couldn't read a char as a number
14:24:19 <vovik> jberryman: why does one have output and the other not?
14:24:30 <Saizan> ?hoogle readEither
14:24:32 <lambdabot> No matches found
14:24:36 <Saizan> ?hoogle read
14:24:37 <lambdabot> Prelude.read :: Read a => String -> a
14:24:37 <lambdabot> Text.Read.read :: Read a => String -> a
14:24:37 <lambdabot> Text.Read :: module
14:24:45 <ddarius> Yes, s/job/drop.  That's quite the typo.
14:25:31 <byorgey> waern: what do you mean by 'one element functors'?
14:25:45 <dmhouse> ddarius: my chinese coworker pronounces the latter as the former. Very confusing.
14:25:54 <waern> byorgey, Maybe, SrcLoc etc
14:26:22 <byorgey> waern: I think I know what you mean, there isn't a common class for that as far as I know
14:26:31 <jberryman> ddarius: I think I'll start using 'job' that way
14:26:34 <waern> byorgey: would be useful
14:26:40 <jberryman> vovik: what do you mean?
14:26:45 <byorgey> waern: 'Pointed' is pretty common as a class for functors which also have an  a -> f a operation, but that's not the same thing as what you're talking about, is it?
14:27:23 <vovik> jberryman: where you the one with the paste? i was just saying that the output in the first solution would slow it down a lot compared to the second solution
14:27:23 <byorgey> waern: why would it be useful?
14:28:00 <waern> byorgey: I'm mostly after an  (a -> b) -> f a -> b  operation
14:28:06 <tibbe> dons: the C implementation of memcmp is a 381 line file :/
14:28:20 <dons> hah
14:28:23 <dolio> That'd be copointed, I guess.
14:28:24 <byorgey> waern: ah, I see.
14:28:27 <vixey> waern: Yuo would make it out of f a -> a ...
14:28:30 <dons> just do it in haskell. it'll be within a few percent of C.
14:28:47 <vixey> waern: Without f a -> a existing, (a -> b) -> f a -> b shouldn't, could it ?
14:28:48 <byorgey> yeah, Copointed would be a good name =)
14:28:59 <tibbe> dons: ok fine
14:29:23 <tibbe> dons: is fpstring.c still used in bytestring?
14:29:28 <waern> vixey, yep, I think you are right
14:29:37 <byorgey> is there a Copointed in category-extras?
14:29:42 <dons> tibbe: maybe its been removed?
14:29:48 <dons> if not, it could be.
14:29:54 <ddarius> vixey: You could just choose id as the first function and get an f a -> a
14:29:54 <tibbe> dons: it's still in the repo
14:29:57 <dolio> I think it's in there.
14:30:06 <dons> i mean to remove it.
14:30:23 <ddarius> This is probably a special case of Yoneda's lemma
14:35:11 <waern> thanks for suggesting Copointed
14:36:32 <waern> too bad Haddock is going to be built during the GHC build process :(
14:36:43 <waern> it mean it can't depend on lots of fun libraries
14:36:55 <waern> means, even
14:38:18 <Igloo> What sort of libraries?
14:39:24 <waern> in this case, category-extras
14:39:45 <waern> but it's a silly case, since it would just use one class from it ;)
14:39:55 <Igloo> :-)
14:40:08 <waern> Igloo: can it depend on HLP packages?
14:40:32 <orzo> ok, is there a way to pass cflags to use when going -fvia-C ?
14:40:57 <Igloo> waern: No - that's going to end up being far larger than extralibs
14:40:58 <orzo> i was thinking i'd use -C and invoke gcc directly, but then i gota worry about headers
14:41:14 <orzo> its not finding the headers it needs to
14:41:26 <waern> Igloo: ok, what about extralibs then?
14:41:47 <Igloo> waern: No, and extralibs are being removed
14:41:52 <waern> ah, heh
14:42:04 <Igloo> orzo: -optc-foo passes -foo to the C ompiler
14:42:26 <Igloo> orzo: but flags like -I you should be able to pass without the -optc
14:43:43 <orzo> oh
14:54:09 <wuxia>  test.hs:(189,0)-(190,74): Non-exhaustive patterns in function picToGraphic
14:54:14 <wuxia> is there a way to have ghc tell me what i'm missing?
14:54:22 <wuxia> looking at the function and the data type, it looks like i hit all the cases
14:55:28 <LordBr4in> i remember seeing a tool which would scan and tell you if your non-exhaustive pattern match really corresponds to a bug or if the unmatched case is provably unreachable anyway
14:55:48 <wuxia> n/m; found that bug ... it was my fault :-Y
14:56:23 <wuxia> on a separate note ... anyone know of a terminal emulator written in haskell? i kinda wnat to see a really short / hackable terminal emulator
14:56:53 <RayNbow> dons, could you explain the induction part in your comment? ( http://www.reddit.com/r/programming/info/6rsn2/comments/c04p51i )
14:56:53 <lambdabot> Title: programming: CSV Parsing: Haskell versus Python
14:56:57 <LordBr4in> ah.. here it is http://www-users.cs.york.ac.uk/~ndm/catch/
14:56:58 <lambdabot> Title: Neil Mitchell - Catch: Case Totality Checker for Haskell
14:57:08 <wuxia> cool; thanks
14:58:05 <dons> RayNbow: lists are an inductive structure. a base case, and a (recursive) cons case.
14:58:22 <sutats> Anyone who uses Arch Linux know if yi's in any repository or AUR?
14:58:25 <dons> unlike arrays, which are a mishmash of length, index, non-empty weirdness
14:58:29 <dons> sutats: yes.
14:58:35 <dons> sutats: its not .
14:58:40 <dons> as wxHaskell isn't ported yet.
14:58:50 <dons> 450 other libs have been
14:58:50 <sutats> dons: Ah, that's unfortunate.
14:59:22 <sutats> dons: Does that mean that there's no CLI version of yi?
14:59:39 <marcot> dons: have you seen the patch I've send to X11?
14:59:53 <Nafai> dons: I thought Yi used gtk2hs
15:00:04 <dons> marcot: yeah, in my inbox.
15:00:12 <RayNbow> dons: ah right, thx
15:00:26 <marcot> dons: ok. =)
15:03:53 <orzo> theres problems
15:03:59 <orzo> using -fvia-C
15:04:09 <orzo> and multiple -arch options to gcc
15:04:20 <tusho_> mauke
15:04:27 <orzo> because multiple -arch options arent supported with every combination of options you can give gcc
15:04:43 <orzo> and ghc is passing -M or something
15:05:10 <orzo> is there a way i can just ask ghc what include paths i need to build a generated c file?
15:07:27 <orzo> gcc-4.0: -E, -S, -save-temps and -M options are not allowed with multiple -arch flags
15:11:47 <orzo> oh, it's passing -S
15:12:04 <tusho_> orzo: for the evil mangler
15:12:09 <orzo> gcc doesn't like -S with multiple -arch flags, so idunno how to create a universal binary this way
15:12:46 <tusho_> orzo: You can't.
15:12:47 <tusho_> :p
15:13:14 <orzo> ok
15:13:22 <orzo> well i can pass a single arch at a time
15:13:33 <orzo> and assemble a universal from the parts
15:17:42 <petekaz> is there a builtin in uncurry3?  I have a function that takes 3 args and then I have a list of [(a,b,c)] and I want to map the function over using those as args.  so something like map (uncurry f) l?
15:18:08 <vixey> no
15:18:13 <Peaker> I wish 2-tuples were the building blocks of higher-tuples
15:18:22 <vixey> they are
15:18:27 <Peaker> could do interesting things with that
15:18:31 <vixey> :k (Integer,((),String))
15:18:33 <lambdabot> *
15:18:37 <vixey> you may use them
15:18:51 <vixey> it doesn't have to be baked into an implementation
15:18:55 <Peaker> Yeah, but whenever I encounter (a,b,c), I need to convert them to something else
15:19:05 <vixey> so never encounter (a,b,c)
15:19:18 <vixey> just always use (a,(b,c)) or (a,(b,(c,()))) or whatever you like
15:19:26 <Peaker> also - could be nice if there was syntax sugar for (a,(b,(c,d)))
15:19:31 <Peaker> (e.g (a,b,c,d) meant that)
15:19:49 <vixey> > let (*) = (,) in 1 * 2 * 3 * 4
15:19:50 <lambdabot>  (((1,2),3),4)
15:20:01 <vixey> no need for sugar
15:20:14 <Peaker> That's the next best thing :)
15:22:53 <mar77a> my haskell books arrived weee
15:24:52 <BONUS> which ones
15:25:07 <mar77a> some printed tutorials
15:25:17 <BONUS> i ordered Purely Functional Data Structures
15:25:21 <BONUS> and Programming in Haskell
15:25:41 <BONUS> although i heard the second one is intended more for total beginners, but still, nice to have
15:26:21 <dons> cool! http://eof.jp/dtwitzen/ cute. (and haskelly!)
15:26:22 <lambdabot> Title: dtwitzen - a compact twitter client using dzen
15:27:46 <BONUS> wow pretty cool
15:28:56 <vixey> you make me want new books
15:29:32 <BONUS> i also ordered Practical Django Projects but i doubt most people here are interested about that :]
15:45:32 <mar77a> i got hm
15:45:42 <mar77a> "haskell 98 language and libraries the revised report"
15:45:51 <mar77a> "yet another haskell tutorial"
15:45:59 <mar77a> "python tutorial 2.5"
15:46:09 <mar77a> and "a gentle introduction to haskell"
15:46:46 <wuxia> @src memo
15:46:46 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
15:47:34 <wuxia> is memoixation techniques implemented in haskell programs, or do they have to be built into ghci?
15:47:53 <vixey> wuxia: No
15:48:06 <dons> well, 'let' is built in to haskell.
15:48:26 <wuxia> so memoization can  be implemented in programs?
15:48:31 <dons> yes.
15:48:36 <dons> can and is.
15:48:43 <vixey> wuxia: Do you want me to show an example?
15:48:50 <wuxia> that'd be wonderful
15:49:12 <vixey> fib 0 = 0 ; fib 1 = 1 ; fib n = fib (n-2) + fib (n-1)
15:49:17 <vixey> We can memoize this,
15:49:25 <wuxia> let's do it
15:49:37 <vixey> the idea is that a toplevel definition of an infinite list will be lazy evaluated
15:49:53 <vixey> and that means bits of it wont get recomputed
15:49:55 <vixey> so,
15:49:59 <wuxia> wait wait; I know the 1 : 1 : zipWidth ... solutino
15:50:03 <vixey> delet the earlier line
15:50:11 <vixey> fib 0 = 0 ; fib 1 = 1 ; fib n = fib' (n-2) + fib' (n-1)
15:50:16 <vixey> fib' n = fibs !! n
15:50:23 <vixey> fibs = map fib [0..]
15:50:49 <wuxia> question, is how to I implement this memo f x = f x
15:51:10 <vixey> wuxia: First, do you understand this
15:51:34 <wuxia> this looks different from what i saw in haskell soe
15:51:37 <wuxia> let me parse ur solution
15:51:53 <vixey> (you could try running it too, that might be helpful)
15:52:08 <vixey> compare speed with the naive def. to see that it actually does memoize
15:52:56 <wuxia> yeah, i understand it
15:52:57 <wuxia> go on
15:53:10 <vixey> that's all I wanted to say
15:53:26 <vixey> you can make the fibs and fib' definitions local to change the behaivor slightly
15:55:17 <vixey> @hoogle unsafeCoerce
15:55:19 <lambdabot> Unsafe.Coerce.unsafeCoerce :: a -> b
16:09:06 <wuxia> @hoogle vector
16:09:06 <lambdabot> Test.QuickCheck.vector :: Arbitrary a => Int -> Gen [a]
16:10:23 <mulletron> does anyone know why the gtk2hs binding for 'onInsertAtCursor' for the Entry class was removed between 0.9.10 and 0.9.12 and if there's a workaround?
16:17:46 <wuxia> how do i use darcs to pull everything from: http://darcs.haskell.org/packages/GLUT/examples/ ?
16:17:47 <lambdabot> Title: Index of /packages/GLUT/examples
16:18:48 <Saizan> wuxia: darcs get --partial http://darcs.haskell.org/packages/GLUT/
16:18:50 <lambdabot> Title: Index of /packages/GLUT
16:19:07 <Saizan> "examples/" is just a subdir of the repo
16:19:19 <wuxia> Invalid repository:  http://darcs.haskell.org/packages/GLUT/examples
16:19:21 <lambdabot> Title: Index of /packages/GLUT/examples
16:19:21 <wuxia> darcs failed:  Failed to download URL http://darcs.haskell.org/packages/GLUT/examples/_darcs/inventory : HTTP error (404?)
16:20:26 <Saizan> yeah, the repo is at http://darcs.haskell.org/packages/GLUT/ , without "examples" at the end
16:20:29 <lambdabot> Title: Index of /packages/GLUT
16:21:11 <Armored_Azrael> Does anyone know anything equivalent to the State monad for STM?
16:21:45 <Armored_Azrael> Alternatively, a way to do atomic state monad transitions?
16:22:57 <Saizan> the State monad doesn't use mutation, so i'm not sure what do you mean by atomic
16:23:34 <orzo> cc1: error: invalid option no-omit-leaf-frame-pointer
16:23:44 <orzo> i am passing only one -arch to gcc now
16:23:59 <orzo> the ppc arch (even though i'm running on intel)
16:24:09 <orzo> i'm using ghc with -fvia-C
16:25:57 <Armored_Azrael> Saizan: I'm going to place references of some sort into a monad, which I will use to seed two concurrent monadic computations
16:26:14 <Armored_Azrael> Saizan: And I want these computations' state changes to have an effect on each other
16:26:24 <Armored_Azrael> Saizan: Thus why I wanted STM
16:26:43 <Saizan> Armored_Azrael: STM has TVar
16:27:16 <Armored_Azrael> Hm. I suppose that works
16:47:16 <orzo> is it possible to tell ghc not to use the evil mangler when going -fvia-C ? or to substitute the mangler with an alternate (without overwriting the old script)
16:47:52 <chrisdone> getting Haddock to document type constructors; any tips? http://hpaste.org/8949
16:50:42 <Saizan> chrisdone: do you export the constructors?
16:51:13 <marcot> I have two types which has the same instances in Storable, namely, convertion to CString and read/show.  I was wondering if I could write this only once, with something like instance (Read a, Show a) => Storable a where...
16:51:15 <wuxia> @src sequence_
16:51:15 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
16:51:35 <marcot> So GHC is asking for FlexibleInstances.  Do you think it worths?
16:52:02 <edwardk> heh its conal http://www.youtube.com/watch?v=faJ8N0giqzw
16:52:04 <chrisdone> Saizan: ahh, no. I export the type, thought that would do it. thanks
16:52:08 <lambdabot> Title: YouTube - Tangible Functional Programming
16:53:27 <chrisdone> Saizan: how do I export a type constructor? Not in scope: type constructor or class `Original'
16:54:19 <chrisdone> (well, value constructor)
16:54:41 <wuxia> http://hpaste.org/8950 <-- pleasae help me simplify
16:55:20 <vixey> > liftM3 (,,) [0,1] [0,1] [0,1]
16:55:23 <lambdabot>  [(0,0,0),(0,0,1),(0,1,0),(0,1,1),(1,0,0),(1,0,1),(1,1,0),(1,1,1)]
16:55:36 <wuxia> vixey: the third element is incorretc
16:55:49 <wuxia> i need it to run as the four vertices of a square, in that order
16:55:55 <wuxia> good try though :-)
17:02:16 <edwardk> @seen conal
17:02:16 <lambdabot> I saw conal leaving #haskell and #ghc 3h 17m 41s ago, and .
17:05:47 <chrisdone> Saizan: ah, figured it out
17:09:29 <Armored_Azrael> If I want to have a data structure where one of the elements is an arbitrary data object that satisfies a specific typeclass, how would I go about this?
17:12:03 <TSC> Armored_Azrael: Have a look at http://www.haskell.org/haskellwiki/Existential_type
17:12:05 <lambdabot> Title: Existential type - HaskellWiki
17:14:26 <vixey> oh
17:14:31 <vixey> edwardk I found something neat
17:14:41 <vixey> kind of in the same vien as thrists
17:15:33 <vixey> http://sneezy.cs.nott.ac.uk/fun/nov-07/R-star.pdf
17:15:35 <lambdabot> Title: cache:http://sneezy.cs.nott.ac.uk/fun/nov-07/R-star.pdf - Google Search
17:15:57 <vixey> why did lambdabot mention google?
17:16:50 <Armored_Azrael> TSC: How do I get ghc to allow forall? (The example code there gives me compilation errors)
17:19:06 <Armored_Azrael> TSC: Seems to work with fglasgow-exts, is there any more specific extension?
17:19:32 <thoughtpolice> -XExistentialQuantification ?
17:22:24 <djsiegel> I can't seem to find any id3 tag libraries for Haskell. Does anyone know of one?
17:22:52 <mjrosenb> djsiegel: i'm writing one...
17:23:06 <djsiegel> how's it coming?
17:23:40 <mjrosenb> so it works for id3v2
17:23:52 <mjrosenb> i haven't tried id3v1 or id3v1.1
17:24:09 <djsiegel> can I pull it from somewhere?
17:24:24 <mjrosenb> now i'm more working on an mp3 decoder
17:24:29 <mjrosenb> hrmm.....
17:24:40 <djsiegel> btw, does ogg use id3?
17:24:49 <mjrosenb> i don't think so
17:24:58 <djsiegel> durn
17:25:06 <mjrosenb> iirc, ogg has it's own better documented format
17:25:16 <mjrosenb> i know there's an ogg decoder for haskell.
17:26:08 <djsiegel> I'm writing a program that keeps copies of your music library in sync across multiple formats
17:26:26 <djsiegel> so I can have a (master) flac tree, an ogg tree, an mp3 tree
17:26:30 * mjrosenb does not know how to set up darcs to act as it's own server
17:26:43 <mjrosenb> djsiegel: yeah, i'm writing more or less the same thing
17:26:54 <djsiegel> hmm, maybe we should work together
17:27:01 <djsiegel> would you mind emailing me what you've got?
17:27:12 <mjrosenb> when i saw there was no id3/mp3/flac support, i decided to just write my own.
17:27:19 <djsiegel> I'm a haskell amateur so don't worry about being judged :)
17:27:37 <mjrosenb> this is the first thing that i've done in haskell
17:28:01 <djsiegel> what exactly are you trying to do?
17:28:52 <mjrosenb> something to help me manage my music
17:28:57 <mjrosenb> detect duplicates
17:29:03 <djsiegel> yeah, cool
17:29:10 <mjrosenb> merge my collection with other people's collections
17:29:19 <mjrosenb> without copying everything
17:29:50 <mjrosenb> and determine when i want to replace one copy of a file with another
17:32:28 <bwr> is there a way to convert something that accepts 6 numbers to accept 3 pairs instead?
17:32:36 <bwr> where something = function
17:32:38 <bwr> sorry
17:32:38 <bwr> :P
17:33:00 <dolio> @type (uncurry .) . uncurry
17:33:01 <lambdabot> forall a b c a1 b1. (a1 -> b1 -> a -> b -> c) -> (a1, b1) -> (a, b) -> c
17:33:22 <bwr> i've used curry/uncurry for much smaller examples
17:33:23 <dolio> @type ((uncurry .) .) . (uncurry .) . uncurry
17:33:25 <lambdabot> forall a b c a1 b1 a2 b2. (a2 -> b2 -> a1 -> b1 -> a -> b -> c) -> (a2, b2) -> (a1, b1) -> (a, b) -> c
17:33:36 <dolio> w00t
17:33:44 <bwr> that's crazy
17:34:20 <BMeph69> Haskell: From Newb to Rocket Scientist, for pennies a day! ;)
17:34:33 <Peaker> @unpl (uncurry .) . uncurry
17:34:34 <lambdabot> (\ d g -> uncurry (uncurry d g))
17:34:48 <bwr> so does this make sense (2 line paste ok i hope)
17:34:50 <bwr> triangle_area = ((uncurry .) .) . (uncurry .) . uncurry triangle_area
17:34:51 <bwr> triangle_area_ xa ya xb yb xc yc = 0.5 * (xa*yc - xa*yb + xb*ya - xb*yc + xc*yb - xc*ya)
17:34:56 <bwr> oops
17:34:57 <bwr> haha
17:35:05 <vixey> I have no clue what the hell ((uncurry .) .) . (uncurry .) .  means
17:35:15 <dolio> I'm not sure I'd actually recommend that chain of uncurrys.
17:35:22 <bwr> ah
17:35:26 <dolio> Despite the fact that I know how to build it.
17:35:31 <bwr> i have no idea how it works
17:35:32 <bwr> :P
17:35:40 <vixey> bwr: then it certainly should not be in your code
17:35:44 <Peaker> bwr: f (a, b) = g a b
17:35:46 <bwr> vixey: true
17:35:49 <dolio> I've just looked at the output of @pl far too many times.
17:35:54 <Peaker> heh
17:36:36 <BMeph69> bwr: Haskell doesn't do variables, as much as references. We're big on "one value, one name" in Haskellville. ;)
17:37:00 <bwr> BMeph69: what do you mean?
17:37:03 <dolio> So, (f .) . g, if you work it out, allows g to take 2 arguments before you compose it with f.
17:37:30 <dolio> So (uncurry .) . uncurry uncurries the function, and then lets it take one pair, and then uncurries it again.
17:37:44 <bwr> ok
17:37:50 <dolio> And similarly for the third pair.
17:38:08 <bwr> seems like you could write a function that will uncurry a function for as many pairs as you want
17:38:52 <dolio> Conal has some renamings of various functions that he says makes that kind of thing clearer, but I haven't yet grocked them.
17:39:11 <BMeph69> bwr: If you're creating a new value (for example, making a new function in the place of your older one), don't try to call it by the same name. Haskell assumes that things with the same name are supposed to be the same thing. :)
17:39:35 <bwr> BMeph69: i'm not...
17:39:39 <BMeph69> I.e., Haskell doesn't do "change the variable to a different value." :)
17:39:42 <bwr> i have one that is _ at the end
17:40:02 <bwr> the _ takes 6 ints and the other takes 3 pairs
17:40:37 <BMeph69> The first go you had at it dropped the underscore. That's what my pit bull-mentality reacted to. :)
17:40:54 <Peaker> bwr: the convention is to use ' there :)
17:40:54 <bwr> yea, i noticed it as soon as i posted... hence the immediate oops
17:40:57 <bwr> ah ok
17:41:00 <bwr> makes sense
17:41:09 <bwr> not used to using ' in function names :)
17:41:14 <bwr> no in programming atleast
17:41:15 <BMeph69> <bwr> triangle_area = ((uncurry .) .) . (uncurry .) . uncurry triangle_area
17:41:21 <BMeph69> ^^ That line. :)
17:41:23 <bwr> yea
17:41:51 <dolio> That's actually wrong, it should be "... uncurry $ triangle_area"
17:41:57 <bwr> yea, i noticed that
17:41:59 <bwr> i already fixed it
17:42:03 <bwr> thanks though
17:42:05 <dolio> Okay.
17:42:06 <bwr> i am still learning this stuff
17:42:13 <bwr> and i switched to using '
17:42:19 <BMeph69> After I kept reading, I then figured that that line was why you said "oops" later. See, I'm slow, but not untrainable - just ask my wife! ;)
17:42:57 <bwr> :)
17:43:27 <BMeph69> Oh, also, bwr: The ' after the name is a popular convention, but if you don't follow it, no one will come after you with pitchforks. They might look at you funny, but that's all. :)
17:44:34 <Peaker> BMeph69: speak for yourself! :)
17:44:40 * Peaker carries a pitchfork around
17:45:07 * BMeph69 waves for "authorities" to keep Peaker away from the pointy implements...
17:46:02 <BMeph69> Peaker: And if anyone wants to do a modern rework of "American Gothic," I bet you'll be a shoe-in for a subject. :)
17:46:50 <ddarius> American Gothic isn't exactly old
17:47:48 <Pseudonym> It's older than me.
17:48:08 <Pseudonym> You know, most people can name that painting, but very few know who painted it.
17:48:56 <vixey> emacs changed all my code into some weird encoding instead of UTF-8 .. again and again
17:49:51 <ddarius> fix encode
17:55:32 <vixey> oh this is terrible
17:55:35 <vixey> I found a bug in my code
17:55:54 <Twey> A WHAT?!  *gasp of horror and shock*
17:56:05 <vixey> :(
17:56:12 <chrisdone> not in vixey's code. nevar D:
17:56:13 <ddarius> How will you live with yourself?
17:56:21 <vixey> http://hpaste.org/8880
17:56:32 * Twey hands vixey a katana.
17:56:34 <vixey> if anyone is bored there is a puzzle
17:56:35 <Twey> There's nothing else for it.
17:56:40 <ddarius> tanto
17:57:45 <chrisdone> sift p = foldr (choose p) ([],[])
17:57:52 <chrisdone>  where choose p x (ys,ns)
17:58:05 <BMeph69> ddarius: wakizashi?
17:58:16 <chrisdone> why pass p to choose?
17:58:40 <ddarius> chrisdone: Perhaps it changes, maybe it is unnecessary.
17:59:09 <chrisdone> ddarius: I have not yet achieved satori
18:07:17 <edwardk> vixey: oh?
18:07:28 <edwardk> vixey: re the found something neat
18:08:12 <vixey> yeah the R*
18:08:14 <vixey> stuff
18:09:06 <edwardk> ah found the later message
18:09:33 <vixey> I'm so confused about this bug
18:09:45 * vixey wants to go back to programming with proof assistants
18:10:06 <vixey> I don't have bugs there.. just can't write anyhing useful yet
18:10:30 <edwardk> hah
18:10:55 <edwardk> yeah i love the output of programming in coq, just not the journey so much
18:14:41 <chrisdone> nice, I actually used Control.Arrow in my code. `map (first L.unpack)'
18:28:37 <bwr> hey dolio, you still around? i've been playing around with that uncurry stuff
18:28:59 <dolio> Yeah, I'm here.
18:29:02 <bwr> and i found that (i think) uncurry `dot` uncurry `dot` uncurry is the same as ((uncurry .) .) . (uncurry .) . uncurry
18:29:21 <bwr> and i am trying ndot = 0 = uncurry and ndot n = uncurry `dot` (ndot(n-1))
18:29:30 <bwr> er, there is an extra = in there obviously
18:29:36 <bwr> any idea why that doesn't work
18:29:40 <bwr> i've also tried foldr :P
18:29:46 <stepcut> my application build-depends on a version of the trhsx preprocessor (an executable) that was built using haskell-src-exts >= 0.3.5. But, my app does not build-depend on haskell-src-exts (nor would depending on it ensure trhsx was built against it). Is there anyway to specify this in the .cabal ? I am thinking: no.
18:29:58 <bwr> i keep stuff about infinite types
18:30:03 <bwr> i keep getting stuff
18:30:08 <dolio> Yeah, that's a dependently typed function you're trying to make. :)
18:30:21 <bwr> ah, so it can't be done?
18:30:43 <dolio> Well, it can, even in haskell, but it requires some significant hackery.
18:30:48 <bwr> ah
18:30:56 <dolio> Less hackery in a dependently typed language.
18:31:16 <dolio> @type uncurry . uncurry . uncurry
18:31:23 <lambdabot> forall b c b1 a b2. (a -> b2 -> b1 -> b -> c) -> (((a, b2), b1), b) -> c
18:31:46 <bwr> oh yea, i am using dot as ((.).(.)) from the pointfree wiki
18:31:57 <stepcut> bwr: in dependently typed languages, it was designed to be done. In Haskell, it was discovered it could be done ;)
18:32:00 <dolio> @type ((uncurry .) . ) . (uncurry .) . uncurry
18:32:02 <lambdabot> forall a b c a1 b1 a2 b2. (a2 -> b2 -> a1 -> b1 -> a -> b -> c) -> (a2, b2) -> (a1, b1) -> (a, b) -> c
18:32:18 <bwr> what is an example of a dependently typed language?
18:32:21 <bwr> i've never heard the term
18:32:25 <vixey> bwr: Coq
18:32:28 <bwr> ah
18:32:29 <edwardk> bwr: ah the notorious boob combinator
18:32:36 <stepcut> bwr: epigram, agda, coq, or more
18:32:45 <dolio> @type let comp2 = (.) . (.) in uncurry `comp2` uncurry `comp2` uncurry
18:32:45 <vixey> you can write functions like,  foo : Integer -> *
18:32:48 <lambdabot> forall a b c a1 b1 a2 b2. (a2 -> b2 -> a1 -> b1 -> a -> b -> c) -> (a2, b2) -> (a1, b1) -> (a, b) -> c
18:32:54 <vixey> then bar : x -> foo x
18:32:58 <dolio> Huh, so it is.
18:33:27 <dolio> Oh, yeah, that makes some sense.
18:33:50 <stepcut> also the Eccentrica Gallumbits combintor, (.) . (.) . (.)
18:33:51 <bwr> yea, i am starting to understand the uncurry curry stuff
18:34:00 <bwr> stepcut: lol
18:34:02 <bwr> is that real?
18:34:12 <edwardk> @type (.) . (.) . (.)
18:34:13 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f2, Functor f1, Functor f) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
18:34:21 <bwr> wow
18:34:35 <edwardk> oh wait caleskell
18:34:36 <bwr> what mischief could i use that for
18:34:38 <chessguy> @type (.)
18:34:40 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:34:52 <bwr> oh
18:35:03 <edwardk> (.) . (.) . (.) :: (b -> c) -> (a -> a1 -> a2 -> b) -> a -> a1 -> a2 -> c
18:35:05 * BMeph69 wishes he could uncurry his curry chicken at times...
18:35:13 <Twey> @src uncurry
18:35:14 <lambdabot> uncurry f p = f (fst p) (snd p)
18:35:54 * Twey toljimpe
18:36:24 <chrisdone> jimpe cevni
18:36:39 <Twey> xu mi go'i
18:36:52 <chrisdone> I don't play pokemon
18:36:58 * Twey blinks -- wait, this is #haskell O.O
18:37:14 <edwardk> chrisdone: heh
18:37:44 <chrisdone> Graphics.GD returns a strict ByteString, Network.CGI outputs a lazy ByteString. COINCIDENCE???
18:38:02 <Twey> Heh
18:38:13 <BMeph69> @goo do-we-need
18:38:15 <lambdabot> http://discussionleader.hbsp.com/erickson/2008/07/do_we_need_weekends_1.html
18:38:16 <lambdabot> Title: Do We Need Weekends? - Tammy Erickson
18:38:20 <chrisdone> converting a strict BS to a lazy one shouldn't be a costly operation should it
18:38:27 <BMeph69> Bah. :P
18:38:37 <BMeph69> @goo do we need dependent types
18:38:39 <dolio> No.
18:38:40 <lambdabot> http://www.brics.dk/RS/01/10/
18:38:40 <lambdabot> Title: Do we Need Dependent Types?
18:39:04 * vixey needs dependent types ...
18:39:05 <dolio> fromChunks [bs] or something.
18:39:10 <vixey> I don't care about writing zipWith4
18:39:22 <vixey> I want proofs :|
18:39:42 <vixey> maybe I should stop treating haskell like a dynamic language
18:42:53 <BMeph69> vixey: ...and start treating it like a dynamical one? ;)
18:43:03 * Pseudonym needs codependent types
18:43:11 <Pseudonym> Useful when you're doing dysfunctional programming.
18:43:16 * edwardk is a codependent type.
18:43:42 <edwardk> or so my wife likes to tease me ;)
18:43:47 <Pseudonym> Everyone agrees the old jokes are... well, old.
18:45:44 <BMeph69> remember  Pseudonym  Pseudonym needs codependent types - Useful when you're doing dysfunctional programming.
18:46:18 <BMeph69> @remember  Pseudonym  Pseudonym needs codependent types - Useful when
18:46:18 <BMeph69> 	  you're doing dysfunctional programming.
18:46:19 <lambdabot> I will remember.
18:46:32 <BMeph69> @quote Pseudonym
18:46:33 <lambdabot> Pseudonym says: Smart programmers naturally write monadic code, even if they don't realise it.
18:46:55 <BMeph69>  @quote Pseudonym
18:47:06 <BMeph69> @quote Pseudonym
18:47:07 <lambdabot> Pseudonym says: the halting problem is [solved] in GHC HEAD
18:47:11 <chrisdone> @quote cthulhu
18:47:11 <lambdabot> No quotes match. You untyped fool!
18:47:48 <BMeph69> So, a story about day-trading cultists would be...
18:47:56 <lambdabot> I can make up a quote if you like...
18:48:02 <BMeph69> "Margin Call of Cthulu"? :)
18:48:29 <mofmog> Today in discussion sections we had to write up examples of say theta(n^2) algorithms on the board just to check if we remembered what they were. So the class is taught in java and I wasn't about to write "public class BLHSALBHRK" a million times so I wrote it in Java.
18:48:35 <mofmog> The TA didn't appreciate that much.
18:48:38 <lambdabot> lambdabot says: Is the Call of Cthulhu call by value or call by need?
18:48:48 <mofmog> CALL BY THE END OF HUMANITY
18:49:58 <chrisdone> I am confused as to what just happened
18:50:11 <chrisdone> what weird puppetry is this?
18:50:40 <fnord123> so the story begins with a bas relief of a technicals chart?
18:51:19 <BMeph69> fnord123: s/technicals/futures/ :)
18:52:35 <Pseudonym> I do all my sequent calculus in bas relief.
18:52:43 <chrisdone> lambdabot: white whale is holy grail
18:52:50 <bwr> is there a function to split a list into groups of pairs?
18:53:02 <ddarius> mofmog: Your story was underwhelming.  I think you have a "typo" in it.
18:53:03 <chrisdone> :t break
18:53:03 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
18:53:15 <chrisdone> :t span
18:53:16 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
18:53:35 <chrisdone> I can't remember its name
18:53:42 <bwr> ah
18:53:43 <lambdabot> lambdabot chrisdone: Call me Idh-mael.
18:53:55 <chrisdone> ah, group?
18:53:57 <chrisdone> :t group
18:53:58 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
18:54:00 <bwr> is lambdabot programmed to do that?
18:54:07 <lambdabot> Gah. The admin doing the sock-puppeting really fscked that one up.
18:54:30 <dcoutts> stepcut: you can specify a build-tool: trhsx, however we do not currently map those back to dependencies on packages that might provide said build tools.
18:55:05 <stepcut> dcoutts: ok. Adding build-tool trhsx seems like a good idea though, since I do not have that
18:57:36 <chrisdone> bwr: what should [1,2,3] output?
18:57:59 <ddarius> > group [1,2,3[
18:57:59 <lambdabot>  Parse error at end of input
18:58:04 <ddarius> > group [1,2,3]
18:58:06 <lambdabot>  [[1],[2],[3]]
18:58:15 <bwr> chrisdone: that should produce an error
18:58:23 <chrisdone> bwr: I thought so
18:58:25 <ddarius> > group . group . group . group $ [1,2,3]
18:58:26 <lambdabot>  [[[[[1]]]],[[[[2]]]],[[[[3]]]]]
18:58:50 <Twey> Mmm
18:58:56 * BMeph69 is going home now
18:58:57 <Twey> :t group
18:58:59 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
18:59:04 <bwr> [1,2,3,4] should produce [(1,2),(3,4)]
18:59:06 <Twey> Ah
18:59:08 <Twey> On ==
18:59:23 <mofmog> ddarius: what, you thought i was about to write one in haskell?
18:59:26 <Twey> Is there a more general version of group?
19:00:09 <fnord123> > group [1, 1, 2, 3]
19:00:12 <lambdabot>  [[1,1],[2],[3]]
19:00:20 <fnord123> not if you want to use Eq
19:00:26 <Twey> @src group
19:00:28 <lambdabot> group = groupBy (==)
19:00:32 <Twey> Ah, groupBy.
19:00:48 <chrisdone> > let group' [] = []; group' (a:b:xs) = (a,b):group' xs; group' _ = error ":(" in group' [1,2,3,4]
19:00:50 <ddarius> mofmog: I admit it.  I was expecting something other than Java.
19:00:50 <lambdabot>  [(1,2),(3,4)]
19:01:02 <bwr> wow
19:01:05 <bwr> that's crazy
19:01:11 <chrisdone> :(
19:01:11 <Pseudonym> > [(1,2),(3,4)] >>= \(a,b) -> [a,b]
19:01:13 <lambdabot>  [1,2,3,4]
19:01:34 <chrisdone> that's nice ^_^
19:01:47 <mofmog> well that'd be sillyt its a java class
19:02:01 <Twey> Who said 'Java'?
19:02:03 <Twey> O.O
19:02:09 <ddarius> mofmog: Okay.  Then your story was just underwhelming.
19:02:14 * Twey lowers his lance.
19:02:21 <mofmog> Ddarius is using java!
19:02:30 <mofmog> HE LOVES STATE
19:02:32 <bwr> chrisdone: that does what i want... let me see if i can figure out how it work :) thanks
19:02:32 * ddarius uses C#.
19:02:36 <mofmog> FREEBASE STATE
19:02:44 <chrisdone> bwr: oh, cool :)
19:03:04 <Twey> Hahaha
19:03:14 <mofmog> C is for Coke
19:03:26 <chrisdone> Cokec?
19:03:27 * ddarius prefers juice.
19:03:41 <mofmog> organic juice?
19:03:56 <chrisdone> juicec?
19:04:33 <mofmog> If C is coke then I guess Java is is coffee. Lisp is green tea I guess- used by hippies.
19:04:44 <mofmog> Haskell would be acid.
19:04:46 <bwr> chrisdone: oh ok i get it... not that bad when i move it to seperate lines :)
19:04:58 <chrisdone> bwr: cool ^_^
19:05:32 <fnord123> C is coke? I guess I see that when you're tracking down segfaults
19:05:41 <fnord123> it brings in the aggro sometimes :)
19:05:53 <mofmog> would C++ be crack?
19:05:54 <chrisdone> I don't get these jokes because I'm not a big druggy
19:06:01 <bd_> mofmog: You're thinking of boost
19:06:02 <fnord123> mofmog: meth.
19:06:18 <mofmog> Python is adderall? It's what all the kids use
19:06:28 <bd_> boost::mpl is just /scary/
19:06:39 <chrisdone> "programmer tears case off computer and feeds to dog"
19:06:44 <Twey> Hahahahaha
19:06:53 <Twey> C++ overdose.
19:07:28 <fnord123> C++ was made in a toilet
19:07:31 <vixey> http://cvs.haskell.org/Hugs/pages/libraries/base/Data-Graph.html#t%3ATable
19:07:39 <lambdabot> Title: Data.Graph, http://tinyurl.com/5qvfar
19:07:44 <vixey> does this Data.Graph not have any way to check if i graph is cyclic ?
19:08:15 <chessguy> @quote boost
19:08:16 <lambdabot> No quotes match. Maybe if you used more than just two fingers...
19:08:53 <mofmog> So at Cal we get student accounts for the Berkeley CS intranet. The whole system works on Solaris and I think half of them have Sparc processors. The thing is... I want to somehow install GHC or Hugs or something that I can use on all of them. I think the best solution so far is to find some haskell implementation hosted on Java but that seems a no-go
19:09:09 <dolio> @remember qwe1234 you along with haskell authors are just stupid.
19:09:10 <lambdabot> Done.
19:09:51 <ddarius> vixey: You could calculate the SCCs and if there are none then the graph is acyclic.
19:10:55 <ddarius> mofmog: Use yhc to compile yhc to javascript
19:11:35 <fnord123> mofmog: http://www.haskell.org/ghc/download_ghc_682.html#sparcsolaris
19:11:36 <lambdabot> Title: GHC: Download version 6.8.2
19:12:59 <mofmog> fnord: the problem is that half are intel half are sparc
19:13:06 <mofmog> and there's no telling which one i'll use
19:14:09 <fnord123> so set a script in the shell you're using so it relocates either way. ARCH=`uname -m`
19:14:12 <Baughn> mofmog: So you install both, and have a script decide based on uname
19:14:23 * fnord123 high 5's Baughn
19:16:35 <chrisdone> is babylon 5 as good as battlestar galactica?
19:17:02 <Baughn> They're different genres. B5 is sci-fi.
19:17:49 <fnord123> they both have too much talking and not enough sweet sweet space action
19:18:17 <Baughn> If you want action, you'll want a book. Harrington, maybe.
19:18:49 <mofmog> TIGH IS A CYLON
19:18:50 <mofmog> wait
19:18:53 <chrisdone> got hold of Office Space, going to watch that in a bit
19:18:53 <mofmog> -dang-
19:19:01 <chrisdone> slowpoke.jpg
19:22:23 <dogbite> I've done some more tinkering with the CSV parsing that I've been workin on
19:22:29 <dogbite> that i wrote up here
19:22:31 <dogbite> http://techguyinmidtown.com/2008/07/14/csv-parsing-haskell-versus-python/
19:22:32 <lambdabot> Title: CSV Parsing: Haskell versus Python  tech guy in midtown, http://tinyurl.com/6xrymq
19:22:39 <chrisdone> dogbite: got it any faster?
19:22:59 <dogbite> well i made it *somewhat* faster if i don't convert every part to a String
19:23:17 <dogbite> just the parsing part goes from about 3.5 seconds to 2.5 seconds
19:23:35 <dogbite> if i only unpack the cells that contain the two numbers that I use maybeRead on to create a Double
19:23:48 <dogbite> then I gain a second on the parsing part
19:24:16 <dogbite> btw, if I use Parsec as some suggested (not here, comments on the post)
19:24:22 <dogbite> then it takes about 9 seconds to do the parsing
19:25:03 <chrisdone> is that with -O2?
19:25:22 <dogbite> i don't know -- i'm just doing a straight 'cabal configure; cabal build'
19:25:30 <dogbite> is -O2 standard?
19:25:59 <chrisdone> it's not default
19:26:01 <dogbite> oh i see default is -O1
19:26:04 <dogbite> let me try
19:26:04 <Baughn> You'll want "ghc-options: -O2" in the .cabal file
19:27:41 <dogbite> that seems to have zero effect
19:28:36 <SamB> clean first ?
19:28:38 <chrisdone> I see
19:28:48 <dogbite> no i'll clean to be double sure
19:29:01 <SamB> that was actually meant as a suggestion
19:29:06 <SamB> not a question ;-)
19:29:26 <SamB> unfortunately english lacks a suggestion mark
19:29:27 <dogbite> SamB: did cabal clean -- no effect
19:29:36 <SamB> no idea!
19:30:03 <SamB> ... maybe you forgot to write a program?
19:30:25 <dogbite> SamB: i've done that before but i think i have a program this time
19:30:44 <dogbite> by no effect i mean the program is not faster
19:42:00 <chrisdone> ahhhh, that's coool
19:42:30 <chrisdone> I'm using my Graphics.WordCloud library, and compiling a project with it. when I change the word cloud code it recompiles it when I build this other project
19:44:37 <chrisdone> :))) http://hpaste.org/8952
19:53:12 <davidL> > let f [] = []; f (x:y:ys) = (x,y):f ys in f [1..10] -- is there a built-in for this somewhere?
19:53:14 <lambdabot>  [(1,2),(3,4),(5,6),(7,8),(9,10)]
19:53:54 <chrisdone> someone asked that just before, I don't think so
19:54:14 <chrisdone> tip:
19:54:22 <chrisdone> > let f [] = []; f (x:y:ys) = (x,y):f ys in f [1]
19:54:23 <lambdabot>   Non-exhaustive patterns in function f
19:55:04 <chrisdone> > let group' [] = []; group' (a:b:xs) = (a,b):group' xs; group' _ = error ":(" in group' [1..10]
19:55:05 <lambdabot>  [(1,2),(3,4),(5,6),(7,8),(9,10)]
19:55:13 <chrisdone> > let group' [] = []; group' (a:b:xs) = (a,b):group' xs; group' _ = error ":(" in group' [1]
19:55:13 <lambdabot>  Exception: :(
19:55:21 <dmwit> > let ensure p x = guard (p x) >> return x; chunk i = unfoldr $ ensure (not . null . fst) . splitAt i in chunk 2 [1..10]
19:55:22 <lambdabot>  [[1,2],[3,4],[5,6],[7,8],[9,10]]
19:55:36 <dmwit> > let ensure p x = guard (p x) >> return x; chunk i = unfoldr $ ensure (not . null . fst) . splitAt i in chunk 2 [1..9]
19:55:37 <lambdabot>  [[1,2],[3,4],[5,6],[7,8],[9]]
19:56:11 <dmwit> > let group' [] = []; group' (a:b:xs) = (a,b) : group' xs; group' _ = error "- (" in group' [1]
19:56:13 <lambdabot>  Exception: - (
19:56:14 <chrisdone> I am guessing there will always be an even number of list items
19:56:20 <chrisdone> dmwit: hehe
19:56:51 <dmwit> davidL: Anyway, "chunk" does *almost* what you want, but with lists instead of tuples.
19:57:09 <chrisdone> > error ":noitpecxE"
19:57:10 <lambdabot>  Exception: :noitpecxE
19:57:40 <davidL> > let chop n = unfoldr (\xs -> if null xs then Nothing else Just $ splitAt n xs) in chop 2 [1..10]
19:57:43 <lambdabot>  [[1,2],[3,4],[5,6],[7,8],[9,10]]
19:57:55 <dmwit> davidL: Right, that's basically the same.
19:59:08 <davidL> alright, thanks all :)
20:00:31 <chrisdone> peyton `simon` jones
20:03:49 <dmwit> ?remember chrisdone peyton `simon` jones
20:03:50 <lambdabot> Okay.
20:04:11 <bwr> haha, i like that
20:04:59 <dmwit> > let chop n = unfoldr (\xs -> if null xs then Nothing else Just $ splitAt n xs) in chop 2 [1..9]
20:05:01 <lambdabot>  [[1,2],[3,4],[5,6],[7,8],[9]]
20:09:17 <davidL> > let chop = unfoldr (\xs -> if null xs then Nothing else Just $ ((xs!!0,xs!!1), drop 2 xs)) in chop [1..10]
20:09:19 <lambdabot>  [(1,2),(3,4),(5,6),(7,8),(9,10)]
20:10:18 <dmwit> > let chop = unfoldr (\xs -> if null xs then Nothing else Just $ splitAt n xs) in map (\[x, y] -> (x, y)) $ chop 2 [1..10]
20:10:19 <lambdabot>   add an instance declaration for (Show (f (t, t)))
20:10:45 <dmwit> > let chop n = unfoldr (\xs -> if null xs then Nothing else Just $ splitAt n xs) in map (\[x, y] -> (x, y)) $ chop 2 [1..10]
20:10:47 <lambdabot>  [(1,2),(3,4),(5,6),(7,8),(9,10)]
20:10:57 <davidL> > let chop n = unfoldr (\xs -> if null xs then Nothing else Just $ splitAt n xs) in map (\[x, y] -> (x, y)) $ chop 2 [1..9]
20:10:59 <lambdabot>   Non-exhaustive patterns in lambda
20:11:13 <dmwit> > let chop n = unfoldr (\xs -> if null xs || null (tail xs) then Nothing else Just $ splitAt n xs) in map (\[x, y] -> (x, y)) $ chop 2 [1..9]
20:11:15 <lambdabot>  [(1,2),(3,4),(5,6),(7,8)]
20:11:29 <davidL> nice
20:12:57 <davidL> @pl \[x,y] -> (x,y)
20:12:58 <lambdabot> (line 1, column 2):
20:12:58 <lambdabot> unexpected "["
20:12:58 <lambdabot> expecting pattern
20:15:20 <dmwit> ?pl \(x:y:[]) -> (x, y)
20:15:20 <lambdabot> (line 1, column 7):
20:15:20 <lambdabot> unexpected "["
20:15:20 <lambdabot> expecting "()", natural, identifier, "_" or "("
20:15:31 <dmwit> ?pl \(x:y:_) -> (x, y)
20:15:31 <lambdabot> ap ((`ap` tail) . (. head) . (const .) . (,) . head) tail
20:15:55 <dmwit> ?pl \xs -> (head xs, head (tail xs))
20:15:56 <lambdabot> liftM2 (,) head (head . tail)
20:16:13 <dmwit> That's not so bad.
20:16:23 <dmwit> :t liftM2 (,) (!!0) (!!1)
20:16:24 <lambdabot> forall a. [a] -> (a, a)
20:17:09 <davidL> :)
20:17:11 <dmwit> But \[x, y] -> (x, y) is way more readable, and shorter too. =)
20:19:29 <ddarius> And more efficient
20:19:55 <SamB> but works only on lists of length two
20:21:07 <ddarius> \(x:y:_) -> (x,y)
20:23:34 <saml> > (\(x:y) -> x:y) "i didn't know lambda can do pattern matching"
20:23:36 <lambdabot>  "i didn't know lambda can do pattern matching"
20:37:52 <saml> > (\_ -> \_ -> \_ -> _) 1
20:37:53 <lambdabot>  Parse error in expression at end of input
20:38:20 <saml> > (\_ -> \_ -> \_ -> 1) 1 "a" 'c'
20:38:22 <lambdabot>  1
20:46:41 <bwr> i am doing something stupid... anybody have a second to look at http://hpaste.org/8954   the angles aren't turning out right
20:54:06 <catface> i think they are right
20:54:35 <bwr> they don't match the expected output
20:55:14 <bwr> well... is it possible that i need to do something like abs(maxAngle - 90)<0.1 to check to see if it is close to 90
20:55:24 <catface> i think the expected output is wrong
20:55:28 <catface> try 4 4 4 5 5 4 for no.4
20:55:38 <bwr> it is straight from google code jam
20:57:36 <bwr> Case #4: scalene acute triangle
20:58:31 <catface> oh hang on, i'm reading the wrong one
20:58:44 <Twey> That would be equilateral...
20:59:24 <bwr> yea, the google code jam said there were not going to be any equilateral triangles
20:59:31 <bwr> so i didn't bother with them :)
20:59:37 <Twey> Ah, I see
20:59:58 <Twey> Equilateral triangles get labelled as isoceles
21:00:38 <bwr> yea, you would think so
21:00:44 <bwr> seems like a bug
21:01:50 <bwr> is there any special comparison for floats that takes into account a margin of error?
21:01:59 <ddarius> Nope.
21:17:31 <wuxia> anyone know a good module/system for compiling haskell expressions to opengl shaders? (doing procedural texture synthesis)
21:18:19 <ddarius> @where hackage
21:18:19 <lambdabot> http://hackage.haskell.org/
21:21:45 <wuxia> there's no matches for 'shader'
21:21:48 <wuxia> so has no one done this then?
21:28:19 * wuxia rephrases question
21:28:33 <wuxia> anyone here has experine writing hlsl shaders in haskell?
21:28:56 <dogbite> the best that i could get my csv parsing program was 4.3 seconds from 7.5 seconds
21:28:59 <dogbite> http://techguyinmidtown.com/2008/07/15/followup-csv-parsing-in-haskell-and-python/
21:29:00 <lambdabot> Title: Followup: CSV Parsing in Haskell and Python  tech guy in midtown, http://tinyurl.com/6fev5b
21:29:22 <sjanssen> 7.5 -> 4.3 is pretty good
21:32:51 <dogbite> sjanssen: yeah it's better, for sure
21:33:06 <dogbite> sjanssen: just not as good as python, which was about 1.7
21:33:10 <sjanssen> I hadn't seen your original post
21:33:18 <sjanssen> but yes, we should be able to beat Python
21:33:33 <sjanssen> do you use a CSV library in Python?
21:33:47 <dogbite> nope, but i could
21:33:47 <dolio> I was thinking about it, and how do you parse bytestrings that doesn't essentially end up unpacking them?
21:34:06 <dolio> Parse with the output as a Put () or something?
21:34:23 <sjanssen> dolio: ideally you only 'unpack' one character at a time with head
21:34:24 <ddarius> dolio: You could just parse them the same way Read parses strings.
21:35:20 <ddarius> @google Haskell GPU compiler
21:35:21 <lambdabot> No Result Found.
21:35:33 <dolio> Right, but if you're parsing CSV, the output is essentially strings.
21:35:37 <dolio> Or nested lists thereof.
21:35:38 <dogbite> yeah some way of going ByteString->Double would be great
21:35:50 <sjanssen> dogbite: is that your bottleneck?
21:35:54 <ddarius> dolio: Why?  Why not be ByteStrings?
21:36:11 <dogbite> sjanssen: i'm not sure.  seems to be critical.
21:36:28 <dolio> In general, at least. If you know more about the format, you can go straight to that (Double, Int, whatever).
21:36:32 <sjanssen> dogbite: also, how big is your input?
21:36:42 <dogbite> sjanssen: 160k lines
21:36:50 <dolio> ddarius: They can be. Does parsec have combinators that produce ByteStrings?
21:36:56 <dolio> many1?
21:36:58 <dolio> Etc.
21:37:04 <sjanssen> dogbite: what's the average line length? (I'd like to know how big the file itself is)
21:37:25 <dogbite> 157562  630226 9779275 IG_US.csv
21:37:34 <ddarius> dolio: Parsec3 can operate solely in terms of ByteStrings.
21:37:43 <dogbite> the size is 9779275
21:37:55 <dogbite> oh it's right there in the wc output
21:38:05 <sjanssen> dogbite: did you try with lazy ByteStrings?
21:38:22 <dogbite> sjanssen: no but i don't see how that would mater since i'm applying a sort
21:38:24 <dolio> Which module has the parsers that produce ByteStrings? I didn't notice them earlier?
21:38:28 <dogbite> so it should need to suck it all in
21:40:30 <ddarius> dolio: Parsec3 operates on a generic "stream" type.  Admittedly the Token and Char modules produce strings.
21:40:44 <dolio> I know they can take ByteStrings as input.
21:40:53 <dolio> How do I produce ByteStrings as output?
21:41:04 <ddarius> dolio: return aByteString
21:41:31 <dolio> There aren't any combinators for that.
21:41:39 <sjanssen> dogbite: BS.pack $ show $ openR r,
21:41:44 <ddarius> dolio: I just gave one.  That was code.
21:41:47 <sjanssen> dogbite: that will merely slow down your program
21:42:00 <dogbite> sjanssen: how can i optimize that?
21:42:01 <ddarius> dolio: Parsec returns whatever the you have it return.
21:42:12 <dogbite> how do i go Double -> ByteString
21:42:17 <sjanssen> dogbite: I'm not sure yet, I'm trying to understand your whole program
21:42:42 <sjanssen> dogbite: String -> ByteString (and vice versa) are always slow
21:42:53 <dogbite> sjanssen: heh yeah it's a little cluttered
21:42:54 <dolio> Where is the combinator 'ParsecT s u m Char -> ParsecT s u m ByteString'?
21:43:06 <sjanssen> ah, you convert it to write to a file
21:43:10 <dolio> Of various types.
21:43:29 <dolio> Presumably which efficiently constructs the output ByteString, so that you don't do lots of O(n) cons/snoc.
21:43:43 <dogbite> yeah the program reads in lines of quotes for tickers where each ticker can have multiple quotes a day
21:43:49 <dogbite> and produces one line per day per ticker
21:43:58 <dogbite> with open hi lo close -- in another csv file
21:44:06 <ddarius> dolio: Parsers are usually meant to produce structured output.  Your questions/concerns make little/no sense.
21:44:28 <sjanssen> dogbite: is there a test file available?
21:44:41 <dolio> What is the type of a parser for a CSV file?
21:44:49 <dogbite> not readily... i'd have to spend some time anonymizing it
21:45:00 <dogbite> it's proprietary at the moment :-/
21:45:43 <dolio> Presumably it's something like 'ParsecT s u m [[String]]'.
21:45:58 <ddarius> Parser ByteString () Identity [[ByteString]] (say) or String if you want
21:46:08 <sjanssen> dogbite: that's fine
21:46:51 <dolio> At that point, you've unpacked the whole file into strings. Or if you use ByteStrings, you've reconstructed the file using slow operations.
21:46:57 <dolio> Unless I'm missing something.
21:47:42 <ddarius> dolio: The output is more structured than the input.  That is all a parser does.  Most parsers simply "reconstruct" their input.
21:47:44 <sjanssen> compare (a !! 5) (b !! 5) -- is also expensive, dogbite
21:48:21 <sjanssen> oh, looks like that is gone in the final program
21:48:43 <sjanssen> nope, it is still there
21:50:17 <dogbite> sjanssen: oh that's really bad?
21:50:27 <dogbite> suggestion on how to improve it?
21:51:11 <sjanssen> dogbite: remeber that (!!) is O(n)
21:51:25 <sjanssen> so you're traversing 5-ish pointers doing that
21:51:47 <dogbite> sjanssen: that doesn't seem too bad... let me try removing and see
21:51:50 <sjanssen> dogbite: I think you should pack things into your RowBytes record *before* sorting
21:52:15 <sjanssen> dogbite: perhaps it doesn't happen often, because it's a secondary case
21:52:27 <dogbite> no effect
21:52:35 <dogbite> or minimal effect.. 4.4 seconds
21:53:13 <sjanssen> dogbite: just by removing that case, or by sorting RowBytes directly?
21:53:25 <dogbite> just removing the !!5
21:53:37 <dogbite> sort by head seems okay to have?
21:53:51 <ddarius> sjanssen: It would be much quicker for you simply to write a decent version from scratch...
21:54:12 <dogbite> ddarius: ha
21:54:16 <sjanssen> dogbite: it's okay, but we can do better
21:54:33 <dogbite> sjanssen: i'm all for better
21:54:36 <ddarius> dogbite: I wasn't joking.
21:54:46 <dogbite> sjanssen: i don't care about my code -- trying to learn this stuff
21:55:04 <dogbite> ddarius: that's good!
21:55:35 <sjanssen> (\r -> (length r) > 0) == not . null
21:55:39 <sjanssen> also expensive
21:56:10 <sjanssen> dogbite: remember that we're working with linked lists, meaning that length is O(n)
21:56:57 <dogbite> sjanssen: you mean in the filter?
21:57:38 <dogbite> i guess i hoped that would be optimized away in a lazy fashion
21:57:42 <sjanssen> dogbite: yes, in sortedByteRows
21:57:44 <bwr> is there an example of using Data.Tree ? i already searched google and found nothing useful
21:57:50 <sjanssen> dogbite: nah, 'length' is anti-lazy
21:57:57 <sjanssen> > length (repeat 1) > 0
21:58:02 <dolio> ddarius: It just seems to me that you could do significantly better with CSV, since the output is almost a nested array of substrings of the original input.
21:58:04 <dogbite> better way to test non empty?
21:58:13 <lambdabot>  thread killed
21:58:16 <sjanssen> dogbite: not . null is the canonical way
21:58:17 <dogbite> clearly could write my own function
21:58:36 <sjanssen> dogbite: or (\r -> not (null r)) -- if you're not comfortable with point-free yet
21:58:46 <ddarius> dolio: You could have Parsec produce exactly a list of lists of ByteStrings -which are effectively indexes into the original ByteString-
21:58:52 <dolio> Which is overhead of around 2 ints per field, instead of k bytes. But "" -> " breaks that.
21:59:31 <dogbite> had no effect
21:59:41 <dolio> ddarius: Yeah, I was thinking of making [[(Int,Int)]] or something.
22:00:39 <ddarius> dolio: That would be a pain to use and no more efficient than producing a [[ByteString]] (less efficient actually)
22:01:01 <ddarius> Admittedly there are "good" ways of producing those ByteStrings and "bad" ways.
22:01:39 <dolio> I'm not clear on how you're suggesting we make [[ByteString]] from within parsec that shares state with the original.
22:01:45 <dogbite> sjanssen: i do much prefer the (not . null) -- and i'm fine with point free
22:02:34 <sjanssen> dogbite: so that should make things slightly quicker
22:02:59 <dolio> ddarius: Unless it's producing something like an (Int,Int) in an intermediate stage, and doing taking a substring within the parser.
22:03:33 <dolio> Minus the doing.
22:04:07 <ddarius> dolio: \p -> liftM (BS.takeWhile p) getInput
22:04:47 <dogbite> sjanssen: didn't have much of an effect, if any
22:05:36 <ddarius> That said, Parsec was never really meant for mass quantities of data.  I wouldn't suggest parsec for parsing large amounts of CSV.
22:05:55 <sjanssen> dogbite: http://hpaste.org/8955
22:06:16 <sjanssen> might not be faster, but the style is getting closer to what I prefer
22:06:34 <sjanssen> I might have gone overboard on the pointfree in 'doReadData', however
22:07:37 <ddarius> sjanssen: doReadData shouldn't exist.  There should be a liftM pureFunction (BS.readFile filename) in the main code and doReadData should be replaced by pureFunction.
22:08:10 <sjanssen> ddarius: yeah, I'll do that now
22:08:27 <ddarius> sjanssen: Again, it is probably easiest to start from scratch rather than trying to transform the code and of comparable didactic value.
22:08:52 <dogbite> looking...
22:09:17 <sjanssen> ddarius: I'm trying to do as many edits as possible without actually understanding the code :)
22:09:28 <dogbite> same speed
22:09:33 <sjanssen> starting from scratch would require that I actually read what's going on
22:09:47 <dogbite> sjanssen:  words, words, word
22:09:58 <ddarius> main itself is basically a BS.interact anotherPureFunction
22:10:14 <ddarius> (assuming an interact like function on ByteStrings)
22:10:17 <sjanssen> ddarius: I have a hunch that we need to stay away from BS.interact
22:10:38 <sjanssen> this Double to String to ByteString is probably killing the big problem
22:10:48 <sjanssen> s/killing/causing/
22:11:06 <ddarius> sjanssen: My point is that all 'main' does is read in a file, perform some pure processing on it, and write it out.
22:11:26 <sjanssen> yeah
22:11:27 <sjanssen> @hoogle on
22:11:28 <lambdabot> Data.Function.on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
22:11:28 <lambdabot> Test.QuickCheck.oneof :: [Gen a] -> Gen a
22:11:28 <lambdabot> Language.Haskell.Pretty.onsideIndent :: PPHsMode -> Indent
22:11:46 <dolio> Someone was in here earlier making a readDouble for this purpose.
22:11:55 <dolio> And showing how much better just calling C was. :)
22:12:02 <dolio> Although I optimized their code somewhat.
22:12:28 <dolio> It's still probably slower than C, if I had to guess.
22:12:40 <ddarius> Calling "atod" or whatever is probably the best idea.
22:12:44 <dolio> (And only handles a subset of all double syntax.)
22:12:57 <ddarius> Writing a correct Double lexer is a pain.
22:13:23 <dolio> He was calling strtod, which I guess was some function he wrote that he didn't paste.
22:13:27 <dolio> http://hpaste.org/8946
22:13:54 <dolio> Yeah, calling C is probably a good idea just so that you don't have to get the parsing right.
22:15:23 <dogbite> okay i'm going to hang it up for the night but i do appreciate your help
22:15:49 <dogbite> wish i could help more but i'm on the learning end, as is clear from my code!
22:15:54 <sjanssen> BS.concat $ intersperse (BS.singleton ',') $ bytes r -- is death on strict ByteString
22:16:47 <dogbite> sjanssen: yeah?
22:17:04 <sjanssen> dogbite: yeah
22:17:48 <dogbite> sjanssen: how do i plug in lazy?
22:18:11 <sjanssen> I can't remember how concat is implemented, but I do believe that it will sum the lengths of each component, then allocate a big buffer
22:18:30 <sjanssen> dogbite: just change your import to 'import qualified Data.ByteString.Lazy.Char8 as BS'
22:20:03 <dogbite> no improvement
22:21:27 <bwr> I can't figure out how to construct a tree i have done :m + Data.Tree but nothing i seem to do gets Tree to work it even says <interactive>:1:10: Not in scope: data constructor `Tree'
22:21:54 <dmwit> :i Tree
22:22:01 <dmwit> It's constructors are not Tree, but Node and Leaf.
22:22:06 <ddarius> @src Tree
22:22:06 <lambdabot> Source not found.
22:22:11 <sjanssen> dogbite: you are building with -O2, right?
22:22:22 <dmwit> bwr: (Do ":i Tree" in ghci.)
22:22:26 <bwr> ok
22:22:43 <ddarius> dmwit: Actually, I believe it is just Node.
22:22:49 <bwr> oh, that helps
22:23:24 <ddarius> bwr: How were/are you expecting to use the library without reading the documentation?
22:23:53 <bwr> ddarius: i am reading the docs... the ones in http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-Tree.html#3
22:23:54 <lambdabot> Title: Data.Tree, http://tinyurl.com/5fmn2f
22:23:56 <bwr> i guess i didn't get it
22:24:46 <dogbite> sjanssen: yup i have "ghc-options:         -O2
22:24:50 <dogbite> in my cabal
22:24:50 <ddarius> bwr: I'd recommend making your own tree type by the way unless Data.Tree is exactly what you are looking for.
22:25:15 <bwr> no, i was just exploring things in haskell
22:25:20 <bwr> i don't have anything particular in mind
22:25:42 <ddarius> bwr: Okay.  Then, in my opinion, Data.Tree is a waste of space.
22:25:54 <bwr> that would probably be a good exercise though because i've never made data type in haskell yet
22:26:15 <bwr> although, it is my bed time now
22:26:25 <bwr> peace guys and thanks a lot for your help
22:40:42 <dmwit> ?bot
22:40:42 <lambdabot> :)
23:03:54 <dobblego> is it possible to write a function e.g. f 123 = [1,2,3] using Traversable?
23:06:00 <sjanssen> dobblego: sure, with a sufficiently funky Num instance
23:06:06 <dobblego> perhaps with show f "123" = [1,2,3]
23:06:15 <slava> so here's a little puzzle
23:06:25 <slava> you have a stack machine with 4 operations: + - * rot
23:06:33 <slava> rot is (a,b,c) -> (b,c,a)
23:06:43 <slava> you start with 4 numbers on the stack
23:06:55 <slava> you have to try to apply operations so that you're left with 24 and nothing else
23:07:09 <slava> the question is, how many 4-tuples of numbers 1..10 can make 24
23:07:25 <slava> i implemented this using continuations and memoization, but its a little slow, takes 4 seconds to arrive at the conclusion
23:07:35 <slava> is there a super-fast and super-concise haskell version that uses lazy list comprehensions?
23:07:41 <sjanssen> slava: can one use a number more than once?
23:07:56 <slava> sjanssen: you test each 4-tuple in turn
23:08:08 <slava> eg, 1 2 3 4 can make 24 very easily
23:08:10 <slava>  * * *
23:08:13 <slava> but 1 1 1 1 cannot
23:08:26 <sjanssen> "1 1 1 1" was what I was wondering about
23:08:26 <slava> you want an algorithm which counts the number of quadruples which can make 24, and print this result
23:08:32 <slava> 1 1 1 1 is admissible
23:08:47 <jberryman> dobblego: weird I happened to look at the channel when you posted, but I was playing with this today: http://hpaste.org/8947
23:09:38 <dobblego> jberryman, I have a similar implementation in Scala, though I want to get rid of the [] type constructor
23:11:04 <jberryman> cool, I'm fairly new to haskell but I'd be interested to see how else one might do that
23:11:14 <slava> dobblego: try my puzzle :)
23:11:22 <slava> i'm sure a clever solution can run much faster than 4 seconds
23:11:25 <dobblego> jberryman, you might use scanl for the recursive call
23:11:36 <dobblego> slava, bit busy atm :)
23:11:41 <slava> np
23:12:12 <sjanssen> slava: I'd use memoization
23:12:25 <slava> that's what i'm doing. without memoization it was 12 seconds
23:12:31 <sjanssen> ah
23:12:34 <dolio> Is that equivalent to asking how many infix expressions (including parentheses) yield 24?
23:12:53 <dolio> Or are there such expressions the stack operations can't produce?
23:13:03 <slava> 'rot' cannot produce every possible permutation of 4 items
23:13:19 <slava> but its a similar problem
23:13:29 <slava> if you can solve one you can solve the other, pretty much
23:14:14 <xkb> are there any solutions to this years ICFP written in haskell available on the web?
23:14:24 <xkb> besides http://www.herrmann.eti.br/haskell/ICFP08/LambdaRover/Hello.hs
23:15:35 <rhz> www.cse.unsw.edu.au/~rubenz/repos/icfp08
23:15:38 <dmwit> dolio: I think there might be some infix expressions that can't happen with +-*/rot.
23:15:52 <dolio> I suppose there might be stack expressions that don't correspond to infix strings that keep the numbers in order.
23:15:57 <xkb> rhz: thx! Your entry?
23:16:05 <rhz> xkb: yes!
23:16:22 <slava> if you add two more shufflers, (a,b) -> (b,a), (a,b,c,d) -> (b,c,d,a) you can produce any permutation of the 4 items
23:16:39 <xkb> rhz: cool! Friends of mine did a Java solution. Their navigation AI sucked a bit though :P
23:16:41 <slava> and so you could produce the result of any infix expression also
23:16:50 <slava> but not vice versa, i think
23:16:56 <dmwit> [2,3,5,7] -> 2 - (5 / 3 + 7) -- can't happen?  if [x,y] / -> x / y
23:17:02 <dolio> Like rot op rot op op cooresponds to (1,2,3,4) -> (2 op 3) op (1 op 4)
23:17:17 <rhz> xkb: yeah navigation was the hardest part of it really
23:17:38 <xkb> rhz: they especially ran into problems evading the martians
23:19:10 <rhz> xkb: the craters posed more of a problem to me. Anyhow feel free to give it a whirl if you like.
23:19:38 <xkb> rhz: will do :) Just read a blogpost about a team using Q-trees.. also very interesting!
23:19:45 <xkb> should have thought of that..
23:20:24 <rhz> xkb: you might also like to watch this: http://www.youtube.com/watch?v=bAK3oYGvvpI
23:20:35 <lambdabot> Title: YouTube - ICFP08 3D Rover Visualisation
23:21:24 <xkb> rhz: hehe cool vid
23:21:57 <dolio> Seems to have trouble with whatever the green is.
23:22:09 <rhz> xkb: I know
23:22:12 <dolio> Or is green good?
23:25:31 <dmwit> dolio: green is home
23:25:44 <dolio> Ah, that makes sense, then.
23:25:52 <dmwit> Which is why it heads straight for it every time. =)
23:25:57 <dolio> U-turning into a crater doesn't make much sense. :)
23:26:05 <xkb> yellow is prob. boulder
23:26:11 <xkb> brown a crater
23:26:13 <xkb> or vice versa
23:26:26 <rhz> brown is boulder. yellow is crater
23:26:33 <rhz> indeed green is home base
23:26:39 <xkb> 50% chance :)
23:27:02 <rhz> which apparently is a poor colour scheme according to someone who suffers from colour blindness
23:27:06 <dmwit> My only issue: you can't see through craters in this visualization. =P
23:27:28 <rhz> yeah I could make them translucent I suppose
23:28:44 <rhz> but I'll just leave that to anyone else who wants to fiddle with the source code to do if they want to
23:30:06 <xkb> just gtalked the link to the Java team, to bad they can't read haskell :)
23:30:56 <xkb> noticed one guy did a sol. in TeX
23:33:59 <dobblego> does Traversable produce a Functor?
23:35:01 <geezusfreeek> isn't functor a prerequisite for traversable?
23:35:21 <dobblego> of course, Applicative
23:36:58 <dolio> @type Data.Traversable.fmapDefault
23:37:10 <lambdabot> forall a b (t :: * -> *). (Data.Traversable.Traversable t) => (a -> b) -> t a -> t b
23:37:20 <dobblego> that just uses Id in traverse right?
23:37:25 <geezusfreeek> fmapDefault f = getId . traverse (Id . f)
23:37:29 <dobblego> yep, cheers
23:43:32 <dobblego> jberryman,
23:43:34 <dobblego> > reverse $ unfoldr (\b -> if b == 0 then Nothing else Just (b `mod` 10, b `div` 10)) 713
23:43:35 <lambdabot>  [7,1,3]
23:43:45 <dobblego> but I'm sure it can be done with Traversable; I might rest on it
23:43:58 <dobblego> reverse + unfoldr -> Foldable, MonadPlus
23:44:09 <dmwit> ?hoogle a -> [a] -> [[a]]
23:44:12 <lambdabot> No matches, try a more general search
23:53:26 <chylli> @type const
23:53:27 <lambdabot> forall a b. a -> b -> a
23:54:15 <chylli> ?hoogle const
23:54:15 <pyNem> does the haskell compiler do automatic memoization ?
23:54:17 <lambdabot> Prelude.const :: a -> b -> a
23:54:17 <lambdabot> Data.Function.const :: a -> b -> a
23:54:17 <lambdabot> Control.Applicative.Const :: newtype Const a b
23:55:28 <dmwit> pyNem: Which compiler?  Under what conditions?
23:55:50 <dmwit> pyNem: The short answer is no, in most cases, Haskell implementations do not memoize things for you.
23:58:01 <pyNem> dmwit, can I make ghc memoise a particular recursive function?
23:58:26 <dmwit> Certainly!
23:58:39 <dmwit> http://article.gmane.org/gmane.comp.lang.haskell.cafe/7737
23:58:42 <lambdabot> Title: Gmane -- Mail To News And Back Again
23:59:03 <dmwit> That article uses an Array as the memoization store, but feel free to substitute a more appropriate data structure.
