00:00:01 <quicksilver> ah
00:00:03 <SamB_XP_> roconnor: well, uh, in one of those two papers he says that if you take the CJ context and identify clowns with jokers, you get the derivative back
00:00:05 <dons> while openbsd would say 200%, yes.
00:00:20 <wuxia> quicksilver: i think ur right; at the top, it says: cpu, only 50% in use; whereas for tthe HRay.exe command, it says 100% ikn use
00:00:30 <SamB_XP_> I don't think the derivative paper payed any attention to which order the list was in, honestly...
00:00:31 <roconnor> SamB_XP_: you can basically take the derivative of any thing.
00:00:56 <roconnor> SamB_XP_, but you can only take a zipper of something of the form mu X. F X.
00:01:07 <wuxia> ot: so for ray tracing, it sholujdl be tribvial to make it to real time (for interactive modeling) if I limit ray reflections/bo7unces to depth 1 right? ther'es no reason in   this case why it can't do it at 30fps
00:01:16 <wuxia> or is there something trivial i'm missing
00:01:23 <roconnor> A derivative gives you a walk from the root to the hole
00:01:32 <roconnor> A zipper gives you a walk from the hole to the root
00:01:49 <SamB_XP_> Hmm.
00:02:21 <SamB_XP_> they must be closely connected, still...
00:03:15 <roconnor> given mu X. F X, it's zipper, Zipper F := [dF (mu X . F X)]
00:03:28 <roconnor> so the derivative of F is used in the definition.
00:03:50 <roconnor> (note we are taking the derivative of the functor, rather than the derivative of mu X. F X
00:05:52 <wuxia> what is the difference between *.hs and *.lhs files?
00:06:08 <earthy> *.lhs files are Literate Haskell
00:06:30 <earthy> they contain both literate text and Haskell code
00:06:34 <wuxia> wow, so HRAY is written in literate haskell; how nice of that person
00:06:47 <earthy> in 2 styles, either 'birdtracks' or 'tex blocks'
00:06:48 <SamB> @remember roconnor given mu X. F X, it's zipper, Zipper F := [âˆ‚F (mu X . F X)]
00:06:48 <lambdabot> It is stored.
00:06:49 <dolio> According to the zipper wikibook, Zipper F = mu F * Context F, and Context F = [dF (mu F)].
00:08:00 <SamB> ... that doesn't sound right ...
00:08:12 <SamB> what does that give for a binary tree?
00:10:57 <roconnor> dolio: It seem unclear whether a Zipper is just the context, or is both the context and highlighted value for that context.
00:11:08 <roconnor> I mean there is disagreement
00:11:13 <dolio> Ah.
00:11:14 <roconnor> for the terminology
00:11:40 <roconnor> but I don't think there is any disagreement about derivative/zipper.
00:12:23 <roconnor> I have no stance on the Zipper / Context bikeshed debate at the moment.
00:14:32 <roconnor> for a binary tree BTree = mu X. (1 + Id * Id) X, Zipper (1 + Id * Id) ~= [BTree + BTree]
00:14:40 <SamB_XP_> yeah, zippers are kind of expected to be inside-out
00:15:10 <roconnor> the list goes from the hole to the root giving either the tree on the left or the tree on the right.
00:15:47 <SamB_XP_> the fact that the two forms (with and without value at hole) coincide for lists doesn't help :-(
00:16:51 <roconnor> a zipper of a list with a value is ([a],a,[a]), so it is different.
00:17:09 <roconnor> the centre a is the highlighted element.
00:17:50 <quicksilver> I'd call ([a],_,[a]) a context, and ([a],a,[a]) a zipper
00:17:55 <quicksilver> maybe I'd be wrong :)
00:18:01 <quicksilver> but that's what I've always called it.
00:18:09 <solrize_> list a = 1 + a + a**2 + a**3 +... = exp(a)
00:18:42 <SamB_XP_> solrize: eh?
00:18:43 <solrize_> no wrong
00:18:45 <roconnor> mabye I should start using that terminology
00:18:49 <solrize_> list a = 1 / (1-a)
00:18:52 <solrize_> i'm sleepy
00:19:24 <solrize_> figuring out zipper for list
00:19:27 <roconnor> set a = exp (a)
00:19:35 <roconnor> (lists modulo permuations)
00:19:51 <solrize_> d/da (list a) = 1 + 2a + 3*a**2 + 4*a**3 +...
00:20:21 <solrize_> how do you get two lists from that?
00:20:42 <solrize_> i'm using sigfpe's notation, his article made a lot more sense than the wikibook
00:20:56 <solrize_> http://homepage.mac.com/sigfpe/Computing/diff.html
00:20:56 <lambdabot> Title: Differentiation of Datastructures for Non-Functional Programmers
00:21:10 <dolio> What's the derivative of 1/(1-a)?
00:21:40 <solrize_> 1/(1-a)**2  ?
00:22:03 <dolio> Yeah.
00:22:15 <dolio> Which is (1/(1-a)) * (1/(1-a))
00:22:26 <solrize_> aha
00:23:43 <povman> is there a library for deriving Binary?
00:23:53 <roconnor> hmm
00:23:54 <solrize_> derivebinary or something like that
00:23:56 <solrize_> it's in the docs
00:24:00 <roconnor> the derivative of set a is set a
00:24:42 <dolio> That makes some sense.
00:25:04 <solrize_> povman, ration of Binary instances has been automated by a script using Scrap Your Boilerplate generics. Use the script here: http://darcs.haskell.org/binary/tools/derive/BinaryDerive.hs.
00:25:10 <solrize_> ration -> generation
00:25:20 <solrize_> from http://hackage.haskell.org/packages/archive/binary/0.4.1/doc/html/Data-Binary.html#3
00:25:21 <lambdabot> http://tinyurl.com/yqlto4
00:25:47 <povman> solrize_: thanks - (couldn't that be a TH macro?)
00:26:19 <solrize_> poman you'd have to put template cruft around all your types?
00:26:21 <solrize_> i dunno
00:26:46 <povman> solrize_: slightly better than generating new code every time you change the data type
00:26:48 <solrize_> why is set a = exp a?
00:27:33 <solrize_> povman, i saw this cool "power of pi" paper that made it look like agda can do all this automatically but i didn't understand it and want to read it more carefully
00:29:42 <dolio> x^n/n! = an unordered n-tuple
00:30:37 <dolio> And set is the union of unordered n-tuples for all n.
00:30:56 <solrize_> how do you get 1/n! = unordering?
00:31:19 <dolio> I don't remember.
00:31:26 <solrize_> i mean there's n! permutations...
00:32:09 <solrize_> (n!) * (unordered tuple) = ordered tuple      since the n! says which permutation you want
00:32:15 <solrize_> kewl
00:32:22 <solrize_> so unordered tuple = ordered tuple / n!
00:32:32 <solrize_> this is madness, i love it :)
00:32:51 <dolio> Ah, yeah, that makes sense.
00:33:56 <solrize_> 1/(1+x**2) is the zipper over Arctan x
00:34:01 <solrize_> so what does that mean?  :)
00:35:00 <dolio> I'm not sure you can divide by arbitrary n.
00:36:48 <solrize_> a**n / n  = select one element of a set and use it as an equivalence class label
00:39:23 <dolio> I don't know what subtraction means, off hand, either.
00:39:32 <solrize_> good point
00:46:34 <dolio> I suppose it could make some sense, like 'Integer - Nat' could be negative integers.
00:46:39 <dolio> But I don't know of any language that does that.
00:47:18 <dolio> Or you could do A + B - B = A
00:47:36 <solrize_> that doesn't seem like the right shape
00:47:48 <solrize_> i mean the integer - nat
00:47:55 <dolio> But that doesn't make sense when it's x - x^3/3 + x^5/5 ...
00:47:55 <solrize_> a + b - b = a    looks right
00:48:37 <quicksilver> I'm not sure you can make sense of "x - x^2"
00:48:39 <quicksilver> as a type
00:48:58 <solrize_> x - x^2 = x * (1-x)
00:49:11 <quicksilver> clearly "ln x" makes much more sense ;)
00:50:36 <dolio> Yeah, not everything has an analogue. At least, not one that people have figured out yet.
00:50:42 <carl> how do u get the nth element of a tuple ?
00:50:58 <mjrosenb> carl: errr that doesn't seem very typesafe
00:51:10 <vixey> carl: Which tuple?
00:51:15 <mjrosenb> carl: at least as long as n isn't a compile time constant
00:51:23 <vixey> carl: 2-tuple, 3-tuple..?
00:51:26 <carl> i have a tuple containing 4 ints
00:51:37 <vixey> nth 0 (x,_,_,_) = x
00:51:39 <carl> which are to be used as a key for an ktea
00:51:42 <vixey> nth 1 (_,x,_,_) = x
00:51:44 <dolio> Like, I don't think you can make sense of x^n/5.
00:51:47 <vixey> nth 2 (_,_,x,_) = x
00:51:51 <vixey> nth 3 (_,_,_,x) = x
00:52:03 <vixey> carl: Have a definition like that to get the nth
00:52:16 <carl> yea ok thx
00:52:31 <solrize_> 5 * (x^n/5) = x^n
00:52:34 <mjrosenb> vixey: and here i thought you would leave us in suspense as to what the last one was going to be
00:53:05 <solrize_> x^n/5 represents some minor clobbering of the 5-tuple
00:53:24 <solrize_> if it's x^n/6 then it just means 3 elements have been permuted
00:54:02 <dolio> 3 elements of what?
00:54:04 <dolio> What if n = 1?
00:54:07 <dolio> x/6
00:54:39 <solrize_> well say n=5  so x^n = (x1,x2,x3,x4,x5)   and by swapping 3 of those around you get x^n/3!
00:55:24 <solrize_> when n=1 or the divisor isn't a factorial then some generalization is needed
00:55:53 <solrize_> like there would be a different divisor for each permutation subgroup
00:55:55 <vixey> x^5/3! should be ((a,b),{x,y,z})?
00:56:05 <solrize_> vixey yeah
00:56:25 <dolio> Yes, but that's only because you can write x^5/3! as (x^2) * (x^3/3!).
00:56:31 <vixey> how do you write a -> b ?
00:56:57 <dolio> There are constraints on n and m for x^n/m to make sense.
00:57:47 <vixey> oh sure it's ^
00:57:55 <vixey> (a,a) = Bool -> a
00:57:56 <solrize_> x^5/60 = even_permutation(a,b,c,d,e)
00:58:52 <dolio> Something like 'm = f(p), p < n, and x^p/m makes sense'.
00:59:11 <dolio> Or, <=.
00:59:37 <solrize_> f(p)?
00:59:47 <dolio> Some appropriate function f.
00:59:59 <dolio> So far id and factorial are the candidates.
01:00:03 <dolio> I guess.
01:02:54 <wuxia> hmm, so it looks like hray doesn't build any acceleartion structures at all
01:02:56 <wuxia> ?
01:02:58 <vixey> m is any number that p is divisible by though ?
01:03:49 <solrize_> what are the roots of a polynomial type?
01:03:57 <solrize_> like x**3+x+1
01:04:34 <vixey> what roots ?
01:05:02 <vixey> the question is data Foo x = ..., for which x does Foo x have no constructors
01:05:14 <solrize_> hmm
01:05:47 <xerox> vixey: why should such x exist in general?
01:05:48 <solrize_> like Foo (a->b) ?
01:06:03 <vixey> xerox: I think it should not
01:06:27 <xerox> vixey: if Foo has got an 0-ary costructor x does not make a difference
01:07:14 <solrize_> above for factorial above we have p=5, m=p!, p   what's n supposed to be?
01:07:22 <solrize_> for the x^5/60 example
01:07:27 <solrize_> to get the alternating group on 5 letters
01:08:27 <dolio> 5! = 120
01:08:44 <vixey> so negative values don't make sense as types
01:08:55 <solrize_> oh they must :)
01:08:58 <vixey> Foo x = Either x ()
01:09:04 <vixey> Foo x = x + 1
01:09:13 <vixey> there is no -1, so that Foo -1 = Void
01:10:14 <vixey> Foo x is always >= 1
01:10:16 <solrize_> what's Foo 2x ?
01:10:27 <vixey> 2*x = x + x
01:10:31 <solrize_> right
01:10:36 <vixey> Foo 2* = Either (Either x x) ()
01:10:43 <solrize_> Foo (x+1)+(x-1) = Foo 2x
01:11:21 <solrize_> yow it's late here
01:11:50 <solrize_> i gotta sleep but this is really fun and i bet there are a lot more factoids waiting to be written down
01:26:13 <Dae_> is there an equivilant of "until" for monadig code?
01:26:58 <araujo> when ?
01:27:25 <vixey> I think untilM doesn't exist
01:27:42 <vixey> since I saw an incorrect version of it on some wiki
01:28:06 <Dae_> ok, I'll just handcode one
01:28:28 <araujo> @where when
01:28:28 <lambdabot> I know nothing about when.
01:28:48 <Dae_> araujo: isn't when just a glorified if?
01:28:58 <vixey> :t when
01:29:00 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
01:29:06 <vixey> :t f
01:29:07 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
01:29:11 <vixey> :t if
01:29:12 <lambdabot> parse error (possibly incorrect indentation)
01:29:14 <vixey> ...
01:29:26 <vixey> :t \x a b -> if x then a else b
01:29:27 <lambdabot> forall t. Bool -> t -> t -> t
01:29:42 <araujo> Dae_, so .. you are looking for a loop constructor?
01:29:49 <vixey> see if takes an alternative but when and unless don't
01:30:10 <Dae_> araujo: Yeah, just have a nice piece of code that I'm trying not to ruin too much when making it monadic
01:30:52 <araujo> Dae_, looping constructs are evil
01:30:53 <araujo> :-P
01:31:30 <Dae_> araujo: until is very nice I'd say..... it made sense
01:32:09 <araujo> nothing you can't do without a better approach ... I'd say
01:34:31 <Dae_> Ohh really?
01:34:53 <hpaste>  Dae_ pasted "Jacobi algorithm" at http://hpaste.org/8677
01:35:23 <araujo> well, I guess ... loops constructs are not usually used around ... In Haskell code I mean :-P
01:36:21 <Dae_> araujo: I'm doing a lot of iterative algorithms in haskell... I haven't found a way out of using loops
01:36:30 <Dae_> or faking them, rather
01:36:42 <araujo> hah, yeah
01:38:04 <Jomyoot> we need haskell on rails
01:38:06 <Dae_> but I have to rewrite the above in monadic code, because it leaks, and it really sucks.  3 faked loops using the ugly MArray syntax :s
01:38:11 <Jomyoot> haskell on hell
01:38:19 <stepcut> Jomyoot: HAppS ?
01:38:36 <Jomyoot> last time i looked could barely find documentation
01:38:46 <stepcut> Jomyoot: still mostly true
01:39:03 <stepcut> Jomyoot: though a tutorial was just recently published by a user
01:39:14 <stepcut> Jomyoot: and I expect to publish something later this month or early next
01:39:50 <Jomyoot> did you like real world haskell?
01:40:52 <Jomyoot> did you write
01:44:28 <Dae_> speaking of MArrays.... is unsafeFreeze expensive?
01:44:39 <sjanssen> it is free
01:45:02 <sjanssen> well, not quite -- it has to allocate a few bytes.  Call it O(1)
01:46:10 <dolio> Nothing like a guy referencing M-theory while arguing that Amdahl's law doesn't apply to the human brain.
01:46:28 <Dae_> O(1) isa lot of things. The O(1) access time to UArray and DiffArray are two very different things ;)
01:46:56 <Dae_> sjanssen: but almost free is good
01:49:07 <dolio> Dae_: Were you the one asking about uvector some time yesterday?
01:49:21 <Dae_> dolio: yes, that would be me
01:49:28 <dolio> Did you get answers?
01:50:36 <Dae_> dolio: yeah, mostly. Wasn't quite what I had hoped though.
01:51:06 <dolio> Heh.
01:52:31 <Dae_> I thouhgt it would allow ghc to see through a foldr on an array, so it would replace the array with a mutable version. Learned a lot about ghc rules though....
01:53:47 <dolio> Yeah, well, currently it's not really set up for use as immutable arrays.
01:54:51 <dolio> The arrays are just an API for getting GHC to generate fast loops, more or less.
01:55:02 <dolio> And then there's the mutable arrays which actually are fast mutable arrays.
01:56:29 <Dae_> dolio: So they are, but the syntax is horrible. It seems to go a bit against what haskell stands for.
01:56:54 <dolio> Which part?
01:57:11 <Dae_> MArrays that is, Uvectors seem ok, just the array part that's a bit misleading
01:57:25 <dolio> The immutable array stuff isn't much different than functions on lists with a U tacked on the end.
01:58:15 <dolio> Oh, yeah, well, mutable arrays in haskell take some getting used to, I guess.
01:58:41 <dolio> They can be verbose.
01:59:01 <Dae_> dolio: Every other part in haskell I've had a sorta "Ohh THAT's the bright idea. That's birlliant"experience. When uisng MArrays, I miss C# :S
01:59:17 * Dae_ kills the typo demon
02:01:50 <Dae_> But then again that's the price I have to pay for being mad enough to do numeric computations in a functional language :p
02:02:40 <dolio> I thought about using the new quasiquoter to write a tiny language that would help working with mutable arrays, but a) I don't know how hard that'd be, and b) I don't know if I'd be able to match performance with writing the stuff by hand without prohibitively worsening a).
02:02:55 <Heffalump> Dae_: perhaps DPH will restore your faith in future :-)
02:03:51 <Dae_> dolio: Actually, I think the solution is to make it less of a problem that you're using IArrays. Making ghc smarter
02:04:50 <Dae_> Heffalump: I have tons of faith in the future of Haskell, that's why I'm here. I love the language. I'm giggling all the time (happens mostly when I'm adding to infinite lists)
02:05:01 <dolio> Yeah, well, turning IArray code into MArray code is magic-level stuff.
02:05:33 <dolio> Unless you go with uniqueness types like Clean.
02:06:54 <luqui> I have two packages installed that export the same module name, how do I compile a program to select only one of them?
02:07:01 <luqui> alternatively, how do I remove a package
02:07:06 <Dae_> Magic level? I don't think so.... I'm not talking about doing it all the time, but like in folds where you know the inbetween values are just that: inbetween
02:09:31 <Dae_> the packages are in /home/usrname/.cabal I believe?
02:09:52 <Dae_> assuming you're not on windows
02:10:16 <dolio> You should be able to use 'ghc-pkg hide' to hide one of the packages temporarily, I think.
02:10:22 <Heffalump> luqui: you can use -hide-package on the ghc command-line too
02:14:45 <luqui> thanks
02:16:36 <quicksilver> or you can specify a cabal build dependency which only one of them satisfies
02:16:40 <quicksilver> ah well, he's gone.
02:19:04 * Dae_ has a theory that quicksilver is the worlds most advanced IRC bot.....
02:19:41 <quicksilver> you can't prove anything
02:20:52 <mapreduce> Dae_: Don't forget to make an arbitrary distinction between bot and human.
02:21:33 <Dae_> mapreduce: Are you suggesting quicksilver is the worlds most advanced IRC human?
02:22:09 <Dae_> quicksilver: Well, you're online more than lambdabot.... and somewhat more reliable
02:23:37 <mapreduce> > let q="quicksilver" in q
02:23:44 <lambdabot>  "quicksilver"
02:24:14 <mapreduce> I was expecting "Terminated" as per pretty much everything I asked lambdabot to do yesterday.
02:25:38 <Dae_> Yeah... ever since someone linked lambdabot to 4chan she's been a nervous wreck
02:43:21 <dolio> @vixen Are you nervous?
02:43:21 <lambdabot> nevermind about that
02:43:43 <Dae_> rofl
02:52:17 <Dae_> after attempting to compile his code and getting a screen full of errors, I get the feeling I still haven't understoof monads ^_^
03:01:17 <hpaste>  Dae_ pasted "Monadic Jacobi" at http://hpaste.org/8678
03:01:53 <Dae_> I simply can't see what I'm doing wrong, there's something I'm obviously not getting here... any chance one of you could take a look at it for me?
03:02:38 <ziman> Dae_, and what's the error message?
03:04:06 <hpaste>  Dae_ pasted "Errors" at http://hpaste.org/8679
03:04:27 <Dae_> I'm pretty sure it's the same thing I'm doing over and over
03:09:03 <Saizan_> ?type thaw
03:09:04 <lambdabot> Not in scope: `thaw'
03:09:10 <Saizan_> ?hoogle thaw
03:09:10 <lambdabot> Data.Array.MArray.thaw :: (Ix i, IArray a e, MArray b e m) => a i e -> m (b i e)
03:09:10 <lambdabot> Data.Array.MArray.unsafeThaw :: (Ix i, IArray a e, MArray b e m) => a i e -> m (b i e)
03:10:13 <Saizan_> Dae_: for the second error s/b <- rotations a/let b = rotations a/
03:10:24 <Saizan_> because rotations is not in the ST monad
03:10:33 <Arnar_> mornin'
03:10:37 <Arnar_> ?seen byorgey
03:10:37 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
03:10:56 <Saizan_> Dae_: same thing for (aChanges,vChanges) <- change maF mvF
03:11:34 <Saizan_> ?hoogle unsafeFreeze
03:11:35 <lambdabot> Data.Array.MArray.unsafeFreeze :: (Ix i, MArray a e m, IArray b e) => a i e -> m (b i e)
03:13:20 <Saizan_> Dae_: in isDiagonal you've to add a type annotation to tell it which type of array you want to freeze to, and in diagonalize you've to use something like do a' <- unsafeFreeze ma; v' <- unsafeFreeze mv; return (a',v')
03:14:04 <Saizan_> or "liftM2 (,) (unsafeFreeze ma) (unsafeFreeze mv)"
03:14:22 <osfameron> who maintains planet.haskell these days?  I emailed the address on the site (planet@community.haskell.org) but istr someone mentioning it was inactive?
03:15:09 <ibid> i do
03:15:14 <ibid> and it's not inactive
03:15:18 <ibid> it just was broken for a few days
03:15:35 <osfameron> ah ok, no worries then :-)
03:15:39 <ibid> (or a bit longer, nobody knows when it went broken just when it was noticed)
03:15:44 <osfameron> just didn't want to have reported url change to a black hole
03:15:50 <ziman> > liftM2 (+) (*1) (+2) 4
03:15:52 <lambdabot>  10
03:15:54 <ibid> i think i've seen the request :)
03:16:23 <ibid> i've also asked dons to join me, but he hasn't shown much interest after the initial discussion
03:16:48 <Dae_> Thanks a lot Saizan :D
03:17:11 <ibid> osfameron: i'm slow ... as always :)
03:17:35 <osfameron> ibid: no worries, not urgent at all -- thanks for taking the time to maintain it :-)
03:18:06 <Saizan_> Dae_: np :), the errors make more sense if you think that [] is a monad too
03:19:25 <Dae_> Saizan_: Yeah, the errors all make sense now. I think the "let =" was the main misunderstanding on my part
03:42:50 <_zenon_> Saizan: [] _is_ a monad
03:46:18 <Dae_> _zenon_: I think he ment that most people don't think of [] as a monad. That you should think of monads as lists
03:47:29 <_zenon_> Dae_ : well yes, I didn't mean to troll or annything, just make it clearer
03:47:54 <Dae_> _zenon_: I know )
03:47:57 <Dae_> * :)
03:48:47 <Saizan_> i was referring to the second error, where b is inferred as (Int,Int) because (rotations a) :: [(Int,Int)]
03:49:04 <Saizan_> knowing that [] is a monad you can see why
03:51:11 <Dae_> if I use "import qualified x" it can only affect my module if I go x.f, and not just f, right?
03:51:50 <Saizan_> right, unless you also import it nromally
03:53:34 <Dae_> that's bloody weird... I have this module that normally causes a stack overflow, but if I import another module qualified it doesn't....
03:54:55 <Saizan_> maybe it triggered recompilation?
03:57:22 <Dae_> I'm not sure... only works in ghci though, so....
04:06:37 <Dae_> wait.... -O seems to be making my program cause a stack overflow???
04:06:42 <plutonas`> is there some prefix i should type when on ghci?
04:06:48 <plutonas`> in comparison to writting in a file i mean
04:07:15 <Dae_> plutonas`: not sure I follow. What do you want to do?
04:07:47 <plutonas`> Dae_: i remember somenoe told me last time, for example if i type inc :: Integer -> Integer in ghci, i get an error
04:08:00 <plutonas`> i remember there was some_word inc :: Integer -> Integre
04:10:20 <Dae_> plutonas`: Well yeah, doesn't make much sense trying to define a type in ghci
04:11:07 <plutonas`> hm, why not?
04:14:07 <plutonas`> i suppose this question sounds stupid to someone familiar with haskell, but I need to know :)
04:14:07 <Dae_> plutonas`: Well, ghci isn't a text editor. It's a bit like a stand-up comedian, it only thinks in oneliners
04:14:31 <Dae_> plutonas`: I'm currently grand master of asking stupid questions in this channel ;)
04:14:56 <Dae_> but basicly, it will only run something you can describe in 1 line
04:20:29 <plutonas`> i see...
04:20:47 <plutonas`> i'm coming from lisp, and there i have the first difference :)
04:21:21 <Dae_> well, ghci is more like a test tool for your modules. You can load any module and try to run it. or tha's how I use it
04:21:37 <opqdonut> and for hacking up oneliners
04:21:44 <Dae_> indeed
04:22:04 <plutonas`> but you can't try some things without writting them in a file?
04:22:14 <opqdonut> yeah
04:22:16 <Dae_> sure you can
04:22:17 <opqdonut> for example types
04:22:27 <opqdonut> but pretty much everything else can be done in ghci
04:22:51 <opqdonut> except it doesn't do any optimizations so code that ghc compiles into O(1) memory usage might blow the stack in ghci
04:23:14 <plutonas`> opqdonut: well that second one is not of a problem i guess
04:23:28 <Dae_> opqdontut: or... as I have recently discovered, the other way around
04:23:39 <opqdonut> heh yeah i read that
04:23:48 <opqdonut> possibly strictness analysis going wrong or something
04:23:48 <_zenon_> plutonas`: You can write  let f = \x -> x + 1          in ghci if you want to
04:24:12 <_zenon_> plutonas` : and then use f  like a function
04:24:30 <Dae_> opqdonut: Yeah, might be..... I'll file a bug report later, but for now: is there a way to turn off optimization for a single module?
04:24:46 <opqdonut> compile it with -O0
04:24:52 <opqdonut> there might even be a pragma for that
04:25:32 <opqdonut> {-# OPTIONS_GHC -O0 #-} should do it
04:28:27 <Dae_> perfect
04:30:58 <Dae_> because I like asking questions, and most haskell information is hidden in secret mailing lists: is there any plans for reviving GPH?
04:31:06 <EvilTerran> btw, you can do multi-line stuff in 6.8+ ghci if you put :{ on a line on its own
04:31:10 <EvilTerran> type the multi-line stuff
04:31:17 <EvilTerran> then a :} on a line on its own
04:31:32 <EvilTerran> still no types or anything tho
04:32:00 <dolio> Huh. Never knew that.
04:32:06 <Dae_> Nice :)
04:32:15 <EvilTerran> i didn't see it in the changelog, but it comes up in :?
04:32:59 <_zenon_> EvilTerran : Niiice :)
04:33:22 <EvilTerran> the joys of RingTFM from time to time :D
04:33:29 <dolio> Nice.
04:33:37 <dolio> EvilTerran++
04:34:08 <EvilTerran> :DD
04:34:41 <EvilTerran> ?karma
04:34:41 <lambdabot> You have a karma of 8
04:37:12 <FordCortina> @hoogle In
04:37:12 <lambdabot> Prelude.in :: keyword
04:37:12 <lambdabot> Data.Int :: module
04:37:12 <lambdabot> Control.Monad.Instances :: module
04:37:24 <FordCortina> :t in
04:37:25 <lambdabot> parse error on input `in'
04:37:28 <FordCortina> :t In
04:37:29 <lambdabot> forall (f :: * -> *). f (Mu f) -> Mu f
04:37:34 <EvilTerran> ?src Mu
04:37:34 <lambdabot> Source not found. :(
04:37:56 <EvilTerran> newtype Mu f = In { out :: f (Mu f) } -- iirc
04:37:57 <FordCortina> anybody know what In is?
04:38:01 <FordCortina> ah
04:38:15 <FordCortina> @hoogle Mu
04:38:15 <lambdabot> Distribution.Extension.MultiParamTypeClasses :: Extension
04:38:15 <lambdabot> Language.Haskell.Extension.MultiParamTypeClasses :: Extension
04:38:15 <lambdabot> Text.ParserCombinators.ReadP.munch :: (Char -> Bool) -> ReadP String
04:38:16 <EvilTerran> it's for type-level fixed-point
04:38:21 <FordCortina> ic
04:39:15 <EvilTerran> given "data Cons x xs = Nil | Cons x xs", Mu (Cons x) is isomorphic to [x]
04:40:10 <EvilTerran> ... they're both isomorphic to Mu (Maybe `O` (,) x)
04:40:52 <EvilTerran> where O is type-level compose - newtype O f g x = O { unO :: f (g x) }
04:41:21 <EvilTerran> it's for weird stuff like that, anyway :)
04:41:23 <FordCortina> thanks
04:41:56 <EvilTerran> ?hackage category-extras
04:41:56 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/category-extras
04:42:24 <EvilTerran> has stuff like that in it, iirc
04:43:07 <EvilTerran> in amoungst the http://haskell.org/haskellwiki/Zygohistomorphic_prepromorphisms and whatnot :P
04:43:11 <lambdabot> Title: Zygohistomorphic prepromorphisms - HaskellWiki
04:44:07 <ziman> ah, the -morphism porn :)
04:44:31 <EvilTerran> in Control.Functor.Composition and Control.Functor.Fix, specifically, albeit with different names
04:44:45 <povman> what the heck
04:44:54 <FordCortina> that's a nice name :D
04:45:24 <opqdonut> :P
04:46:14 <ziman> opqdonut, i always read your name as `opaque donut' mentally; is that what your name means? :)
04:46:24 <opqdonut> actually it is :)
04:46:41 <FordCortina> no i meant "Zygohistomorphic prepromorphisms" :D
04:46:45 <opqdonut> comes from my dark raytracing past :P
04:47:14 <Dae_> heh, raytracers must be the 3rd most popular haskell program
04:47:15 <_zenon_> opqdonut : Funny :)   "dark" + "raytracing" at the same time
04:48:00 <dolio> 3rd?
04:48:13 <dolio> Behind fibonacci numbers and quicksort?
04:49:04 <EvilTerran> you mean partition sort? :P
04:49:12 <EvilTerran> (or whatever the heck the non-in-place one is called)
04:49:19 <dolio> Yeah, yeah. Deforested tree-sort.
04:49:29 <Dae_> dolio: exactly
04:49:40 <_zenon_> enhanced memory efficient quad-quick sort
04:49:42 * EvilTerran likes the haskell merge-sort better, actually
04:49:45 <dolio> I'm not an in-place stickler.
04:49:48 <Dae_> Though pirme comes close
04:50:04 * _zenon_ just made that up :P
04:50:04 <EvilTerran> the merge function is one of those things lists are perfect for
04:50:19 <Dae_> EvilTerran: I agree.... merge-sort beats quicksort anny day of the week. People are just too lazy to make 'em
04:50:45 <ziman> people are used to in-place sorts
04:51:40 <povman> is there any real world use for these zygohistomorphic prepromorphisms?
04:52:00 <Dae_> povman: Real...world...? As in IO Monad?
04:52:20 <povman> yeah - why did someone implement it in haskell?
04:52:51 <_zenon_> povman: For the same reasons people implement A LOT of things in haskell.
04:53:09 <povman> because it was there?
04:53:09 <_zenon_> povman: because you are up to the challenge, because it's fun, because you can :)
04:53:30 <povman> fair enough :)
04:53:38 <_zenon_> because haskell. ........ is haskell :)
04:53:41 <profmakx> because you can being the only valid reason
04:54:32 * Dae_ is quite certain the high quality of haskell stems from it only being used by people with computer sciences degrees
04:55:07 <_zenon_> Dae_ : No cash involved => grow in peace
04:55:40 <povman> Dae_: it's a pity about that
04:57:01 <Dae_> Yeah, it is.... I've written the exact same program in haskell and in c#. Took me a half a month in c#, took me half a week in haskell. Not to mention making it use both cores on my cpu...
04:58:45 <_zenon_> Dae_ : What did you write?
04:59:18 <Dae_> _zenon_: An SVM quantum simulator....
05:00:07 <_zenon_> Dae_ : What is an SVM quantum simulator? I suppose SVM is not Support Vector Machine?
05:01:18 <profmakx> one can write pretty crappy software in haskell too
05:01:24 <profmakx> believe me i have seen that
05:01:52 <Dae_> _zenon_: No, Stochastic Variational Method. Allows me to study quantum systems that cannot be solved analytically. I could link you an article?
05:01:53 <profmakx> then again, rewriting and/or restructuring seems quite a lot easier
05:02:00 <_zenon_> of course, the chain is never stronger than it's weakest link :)
05:02:39 <olsner> oh no, crappy software can pass typechecking? :S
05:02:42 <_zenon_> Dae_ : Hmm.... maybe, ... no, I must pass :) I am not so interested in quantum systems (not hardly annything about it)
05:02:57 <olsner> (shouldn't we have done something about that by now? :P)
05:03:37 <Dae_> _zenon_: I get that a lot ;)
05:06:56 <Dae_> olsner: if crappy software couldn't pass the type checker we would not be able to make any of the delicious hacks that make haskell feel so warm and fuzzy
05:06:57 <_zenon_> Dae_ : Sorry :) But at least we all have our obsessions :)
05:08:47 <olsner> hmm, so you're saying warm and fuzzy haskell is crappy?
05:08:55 <Dae_> nooo.....
05:09:23 <Dae_> I'm saying that if we choose to write crappy code, it should be ghc's problem, not ours
05:09:47 <FordCortina> how do I go about finding the definition of this constructor called In?
05:09:53 <FordCortina> All ive got is this paper
05:09:54 <FordCortina> http://www.cs.utexas.edu/~wcook/Drafts/2006/MemoMixins.pdf
05:09:56 <_zenon_> Dae_ : I disagree, that would deteriorate our ability to think, if we can write all the crap we want.
05:10:04 <FordCortina> and the constructor is used in section 3.1
05:10:09 <_zenon_> Like Visual Basic
05:10:24 <_zenon_> never written in it myself actually, just a lot of prejudice
05:10:31 <olsner> otoh, limiting yourself to writing crap that type-checks is a pretty good gain in itself
05:11:09 <Dae_> _zenon_: Point taken. I've written quite a bit of jaca and c#..... A friend of my specialized in abusing the Java type machine...
05:11:14 <FordCortina> isn't a memoized mutually recursive function is zygohistomorphic prepromorphism?
05:11:30 <FordCortina> it seems to do the zygo and histo part anyway
05:11:36 <FordCortina> :S
05:12:01 <Cale> The newer versions of VB aren't really any worse than any of the other popular programming languages. There are some smart people working on VB now.
05:13:11 <Dae_> Cale: True that, but most popular languages aren't that smart to begin with.
05:14:06 <Cale> Right. It's just that VB is not so especially bad as it used to be. :)
05:15:35 <Dae_> Cale: Syntax still bothers me, but... C#, VB, J# are all just different interfaces to the same machine anyway.
05:15:57 <_zenon_> wasn't C# the answer to Java?
05:16:01 <Cale> The LINQ stuff Erik Meijer and those guys are working on is pretty smart anyway. They've had to make lots of improvements just to support it.
05:17:39 <Dae_> _zenon_: I guess... they're pretty much the same though. Better overloading in C#, way better library in Java
05:18:15 <Cale> I haven't used either in a while, but I'm fairly sure that C# at least has lambdas.
05:18:30 <_zenon_> Dae_ : And proprietary
05:18:38 <_zenon_> Cale: I heard that they introduced it
05:18:56 <_zenon_> Cale: I have M$-loving friend, surely he had to brag about it
05:19:42 <Randroid> Steve Ballmer invented lambdas with the help of Al Gore.
05:19:47 <Dae_> _zenon_: Java is almost opensource these days I believe....
05:19:48 <Randroid> On the internet.
05:19:48 <Dae_> ROFL
05:19:58 <Cale> Heh, I actually kind of consider that a 'bare-minimum' feature rather than something to really brag about, but I suppose these things are not doing so well out in the industry.
05:20:26 <_zenon_> Dae_ : I was refering to C#.
05:21:07 <Dae_> _zenon_: Actually, you could use mono, which would sorta make it ok....ish....
05:21:13 <_zenon_> Cale: indeed, I think he never heard about Lisp, A wonder M$ haven't made some M$Lisp or annything
05:21:21 <_zenon_> Dae_: Tried it once,
05:21:25 * Randroid writes C# code all day long for a living. It's really not too bad.
05:21:28 <_zenon_> Dae_ : Mono that is
05:21:47 <Cale> _zenon_: Well, the people working on C# and VB now are people who worked on the Haskell standard.
05:21:57 <Cale> _zenon_: So they should improve quickly :)
05:22:06 <Dae_> Randroid: I'd agree, but.... haskell! now C# feels like putting on those shoes that never really fitted in the first place
05:22:29 <Randroid> Cale: That's true. HaskellDB, for instance, influenced the new Language Integrated Query (LINQ) feature in C#. There's a paper about it on the net.
05:22:34 <Cale> Right.
05:23:02 <Dae_> Anyway, I have to run..... see ya guys later
05:23:05 <Dae_> maybe...
05:23:30 <Randroid> Dae_: So true. Believe me, I infinitely prefer Haskell, with the exception that C#'s (well, .NET's) libraries are much more comprehensive and mature in most cases. Of course, Parsec has no equal.
05:28:12 <Cale> Yeah, the funny thing about the approach of improving things in imperative languages, is that for many issues, you sort of start out screwed by side effects and you have to either ask programmers to be very careful or do complicated things to try and save yourself. I think starting from a pure language and adding side effects in a more reasoned way is a much more direct approach to solving a lot of problems -- especia
05:28:12 <Cale> lly regarding parallelism and concurrency.
05:28:55 <nornagon> i wrote a tiny shell of a roguelike in haskell
05:29:07 <Cale> nornagon: cool! :)
05:29:07 <nornagon> the record semantics are pretty severely limiting
05:29:22 <Cale> In what way?
05:29:29 <nornagon> i can't imagine going much further than what i have without everything exploding into a mess of state
05:29:41 <ejt> nornagon: can we see the code ?
05:29:46 <Cale> What do your datatypes look like?
05:29:48 <chr1s> Cale: I think there is a cool interview about that with Erik Meijer and I think also Gilad Bracha
05:29:55 <Cale> You're using static record types to hold everything?
05:30:12 <_zenon_> Cale: I agree, there is no turning back once the side effects are open
05:30:14 <Cale> chr1s: Also a number with Simon Peyton Jones
05:30:16 <nornagon> let me refresh the code in my head
05:30:29 <nornagon> also map generation was a bit of a trick to get my head around
05:30:42 <nornagon> I ended up with a type Landscape = Array Position Feature
05:30:47 <chr1s> nornagon: cool, I also rote a roguelike
05:30:50 <Cale> nornagon: One thing Haskell could really use at the moment is a real record system.
05:30:56 <nornagon> with Position being (Int,Int) and Feature being Ground | Wall
05:30:59 <kosmikus> kosmikus: me too :)
05:31:04 <kosmikus> oops
05:31:13 <chr1s> kosmikus: really? :p
05:31:23 <nornagon> then I have some game state which is just a record type
05:31:26 <Cale> (as opposed to a thin candy shell on algebraic datatypes, which admittedly has its place, but is not a real replacement for extensible polymorphic records)
05:32:03 <Cale> For a lot of things though, you can use Data.Map.
05:33:19 <hpaste>  nornagon pasted "basic roguelike" at http://hpaste.org/8680
05:33:33 <chr1s> Cale: it wash this interview: http://channel9.msdn.com/posts/Charles/Simon-Peyton-Jones-Towards-a-Programming-Language-Nirvana/
05:33:35 <lambdabot> Title: Simon Peyton-Jones: Towards a Programming Language Nirvana | Charles | Channel 9, http://tinyurl.com/5blppb
05:33:37 <Cale> (especially for the sets of attribute/value pairs which come up quite a lot in such games)
05:33:45 * _zenon_ grabs coffe
05:33:46 <Cale> chr1s: yeah, I've seen that one :)
05:34:21 <nornagon> oh dear, my darcsweb seems to have lost its css.
05:34:32 <nornagon> crap crap, that was custom css, too.
05:34:36 <Cale> ... and hpaste's draconian text size limit strikes again!
05:34:42 <nornagon> oh. :(
05:34:43 <chr1s> nornagon: see http://www.cs.uu.nl/wiki/bin/view/Afp/ProgrammingTask for 7 different roguelikes in Haskell
05:34:43 <kosmikus> nornagon: the roguelike I've written is available on hackage as LambdaHack.
05:35:28 <nornagon> well, http://nornagon.net/roguelike.txt
05:38:07 <kosmikus> nornagon: what about the other modules?
05:38:30 <nornagon> kosmikus: which?
05:38:37 <profmakx> very nice assignment
05:38:40 <Cale> FOV?
05:38:43 <profmakx> field of vision
05:38:52 <nornagon> darcs get http://nornagon.net/code/hfov
05:38:52 <lambdabot> Title: Index of /code/hfov
05:39:07 <nornagon> but
05:39:07 <Cale> ah... is that on hackage too? ;)
05:39:10 <profmakx> *selfslap*
05:39:13 <nornagon> i don't think so.
05:39:19 <nornagon> i didn't put it there, at least.
05:39:37 <nornagon> also, i think i may be using some hscurses things that aren't in the mainline
05:39:39 * Cale has an unreasonable expectation for everything to be on hackage already :)
05:39:52 <nornagon> i don't really know how to put stuff on hackage.
05:39:56 <nornagon> @where hackage
05:39:56 <lambdabot> http://hackage.haskell.org/
05:40:41 <Cale> It's quite easy if you already have the thing set up as a cabal package.
05:40:42 <nornagon> oh, you actually have to email someone to get an upload account.
05:40:58 <nornagon> i have some .cabal file, it seems.
05:41:29 <Feuerbach> hi all. How do I do reverse lookup in Data.Map?
05:41:41 <dmwit> You don't.
05:41:59 <nornagon> slowly.
05:42:05 <dmwit> You can use assocs, but it's better to just keep a reverse Map yourself.
05:42:10 <Feuerbach> nornagon: it's ok
05:42:31 <nornagon> i mean, you can do the obvious thing and just search through all the values in the map.
05:42:39 <Cale> You could use filter
05:42:47 <Cale> (and then elems)
05:42:56 <Feuerbach> nornagon: I understand, just wanted to use standard function
05:43:05 <nornagon> i don't think there is one.
05:43:14 <Cale> er, keys rather
05:43:20 <SamB_XP_> someone mentioned a Bimap last night, I think...
05:43:23 <Cale> keys . filter (== x)
05:43:26 <ddarius> Feuerbach: If the elements are in one-to-one correspondence you can use a Bimap instead.
05:43:41 <Feuerbach> ddarius: thanks, I'll take a look
05:44:08 <ddarius> @hackage bimap
05:44:08 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/bimap
05:44:14 * Cale really wishes that Wolfram Kahl would put his awesome relation library on the web somewhere.
05:44:56 * Cale wonders how much awesome Haskell code is being hoarded by researchers who don't know about things like Hackage :)
05:45:39 <ddarius> How many people (currently active) in the Haskell community don't know about Hackage?
05:45:59 <povman> > let 1 + 1 = 3 in 1 + 1
05:46:00 <lambdabot>  3
05:46:15 <Cale> (or are just too lazy to package things :)
05:46:26 <nornagon> in other news, records suck.
05:46:36 <Cale> nornagon: what sucks about them?
05:46:45 <ddarius> Cale: The real question is how much awesome code is being hoarded by researches who don't know about gwern.
05:46:51 <Cale> ddarius: ahaha
05:47:10 <SamB_XP_> ddarius: isn't it more a matter of researchers who gwern doesn't know about?
05:47:20 <carl> lol i finally finished my xtea algo and its 6 times the size of the c implementation, but then again i am a noob
05:47:26 <povman> it'd be nice to get built-in syntax for lenses
05:47:43 <nornagon> Cale: in that i want to keep a bunch of related information together (say, information about my game map/player state/monsters/etc), but can't do that in an encapsulated way
05:47:46 <Cale> carl: xtea?
05:47:52 <povman> other than that i'm happy with records
05:47:56 <SamB_XP_> Extreme Tea?
05:47:58 <Cale> nornagon: Data.Map
05:48:00 <nornagon> because the record accessor functions all go global
05:48:22 <SamB_XP_> nornagon: you don't have to export them
05:48:25 <nornagon> Cale: lookup time slooow :(
05:48:30 <Cale> nornagon: huh?
05:48:36 <Cale> nornagon: It's as fast as could be.
05:48:39 <jre2> nornagon: what exactly are you working on?
05:48:41 <nornagon> compared to just an accessor function.
05:48:48 <nornagon> jre2: a roguelike game
05:49:04 <povman> nornagon: don't export the record accessors from your module, only export wrapper functions
05:49:11 <nornagon> Cale: O(1) doesn't mean it's a small constant time
05:49:16 <Cale> nornagon: This is 2008, last I checked.
05:49:24 <nornagon> and i might be running this code on a Nintendo DS.
05:49:26 <Cale> nornagon: O(1) doesn't mean O(1) :)
05:49:36 <nornagon> which has 66MHz of PURE POWER
05:49:39 <nornagon> and 4MB ram.
05:49:44 <jre2> nhc?
05:49:58 <nornagon> actually i intend to modify GHC's runtime system
05:50:00 <povman> module Thing (func, func2) where -- only exports func and func2
05:50:02 <carl> Cale: xtended tiny encryption algo has a very nice implementation under c
05:50:04 <nornagon> for a project early next year
05:50:40 <Cale> carl: ah, okay, looking at the code on wikipedia, that looks like a job for Data.Bits
05:51:06 <carl> Cale: yep, its still ugly as
05:51:11 <Cale> But yeah, because of all the mutation, you might have a bit of overhead.
05:51:44 <Cale> A better approach would be to use a library for composing Feistel networks :)
05:52:10 <Cale> I wonder if such a thing already exists :)
05:52:47 <Cale> It sounds like the sort of thing which Galois Inc. would have
05:52:59 <nornagon> and hopefully by that time 6.8.10 will be out and the backend rewrite will be ARM-happy
05:53:17 <ddarius> 6.8.10 will never be out
05:53:26 <nornagon> ;(
05:53:30 <nornagon> er
05:53:36 <nornagon> 6.10, whatever
05:53:47 <nornagon> i scared of your version numbering.
05:55:24 <Cale> There's a good project for someone. A library (possibly using arrows?) for connecting up the standard components of cryptographic algorithms, and then maybe use Harpy to generate and execute efficient x86 code :)
05:56:34 <opqdonut> heh
05:56:49 <opqdonut> sounds like a nice application for arrows, yes
05:57:05 <opqdonut> as cryptographic algorithms are often presented as block diagrams
05:57:14 <Cale> right
05:57:22 <nornagon> it feels like haskell really isn't the right language for heavily state-dependent things like most games
05:57:27 <nornagon> at least, not at the moment.
05:57:31 <opqdonut> STM works wonders
05:57:35 <Cale> nornagon: It's not so bad.
05:57:48 <_zenon_> nornagon: The more the incentive to do it :)
05:58:01 <jre2> nornagon: I've been using STM, ST, and MonadPlus to handle games somewhat well
05:58:12 <Cale> nornagon: Really, don't worry about log factors like that. Many operations most people consider O(1) are actually at least logarithmic anyway.
05:58:26 <nornagon> jre2: where does STM come into it? I mean, if you're not doing any multithreading stuff.
05:58:42 <olsner> Cale: ooh, that sounds interesting
05:58:48 <Cale> (you can't look at a whole memory address in better than log time)
05:58:51 <jre2> nornagon: messing passing between different components of the game server
05:59:06 <nornagon> Cale: it just feels wrong to ask for that kind of data from a map instead of something akin to C's structs.
05:59:20 <povman> nornagon: use records!
05:59:32 <nornagon> except records suck :(
05:59:37 <Cale> nornagon: Well, if you'd be happy with C structs, what's wrong with records?
06:00:13 <nornagon> the lack of namespacing.
06:00:17 <Cale> nornagon: Modules.
06:00:19 <jre2> for example, players can send actions over the network, internally (for testing), etc and just through them in a TChan
06:00:39 <Cale> nornagon: Namespacing in Haskell is provided by the module system.
06:01:23 <Cale> Or of course, you can just invent some prefixes.
06:01:23 <nornagon> Cale: so, you suggest defining the record in a seperate module and doing e.g. import qualified Creature as C and using C.hp some_creature, yes?
06:01:32 <Cale> If you prefer that.
06:01:35 <jre2> Ex. import qualified Weapons as W, then you can prefix exported stuff with W.
06:01:40 <Cale> Personally, I wouldn't worry about it.
06:01:55 <ejt> heh, I didn't know about TChan, I always roll my own
06:02:07 <ejt> except I normaly have a way of closing the channel for shutdown
06:02:34 <Cale> ejt: Which is kind of funny given the usual intricacies of developing a working concurrent channel :)
06:02:47 <Cale> (but STM makes it fun :)
06:03:00 <ddarius> Cale: But if you develop a -non-working version...
06:03:25 <povman> er -- all this talk about tchan -- i'm actually working on a distributed version of IORef atm, should i not be?
06:03:50 <SamB_XP_> povman: indeed, it should be more like MVar ;-P
06:03:54 <Cale> povman: STM has nothing to do with distributed computation, only concurrency and possibly SMP parallelism.
06:04:20 <Cale> povman: However, you probably don't want to design such a thing without looking at STM.
06:04:37 <Cale> (at least so you know how that works)
06:04:42 <povman> i understand stm
06:04:53 <ddarius> I question the benefit of having "distributed IORefs."
06:05:07 <SamB_XP_> yeah, IORefs are bad enough ;-P
06:05:19 <ejt> Cale: is it that hard if you start from TVars ? (TChan)
06:05:28 <povman> SamB_XP_: what's wrong with them?
06:05:34 <Cale> ejt: Not really... that's the point I was making.
06:05:38 <ejt> y, see that now
06:05:40 <ejt> :)
06:05:46 <Cale> ejt: Starting from locks, it's pretty tough.
06:05:58 <ejt> and yes, I've done it a few times in C, and it's difficult
06:06:35 <SamB_XP_> povman: race conditions galore?
06:06:58 <povman> what i mean by 'distributed ioref' is a nice interface around a tvar
06:07:21 <povman> equivalent to DRb for ruby
06:07:28 <SamB_XP_> oh, I thought you meant some kind of networked thing
06:07:33 <povman> i do
06:07:45 <SamB_XP_> tvar isn't networked
06:08:18 <dmwit> ...Hence the "nice interface around" comment?
06:08:21 <povman> i'm writing a generic server procedure for letting stuff access a tvar
06:08:24 <Cale> nornagon: Personally I'd probably use a Data.Map in order to hold attributes so that I don't have to pin everything down, and design things in order to handle failure of any given object to have a particular attribute gracefully.
06:08:27 <povman> over a network
06:09:08 <ddarius> Cale really likes Maps.
06:09:08 <Cale> nornagon: However, if I knew exactly how I wanted the game to work from the outset, I'd just use records and pick field names that don't overlap.
06:09:14 <nornagon> Cale: i'd rather not have to think about whether or not this monster actually has an HP value.
06:09:58 <Cale> nornagon: Well, sure, you can also split things up and have some fields which every object has.
06:10:09 <ejt> I'd just write a little language for specifying rogue alikes
06:10:10 <ddarius> Cale is really a Perl/Python/Smalltalk programmer who just hangs around here.
06:10:16 <povman> ejt: haha
06:10:18 <Cale> ddarius: haha
06:10:19 <nornagon> ejt: -.-
06:10:27 <jre2> nornagon: then type class Vulnerable?
06:10:28 * ejt wasn't joking
06:10:43 <nornagon> jre2: wow, that feels like overengineering things...
06:10:49 <Cale> ddarius: I'm just pointing out that if you want the lack of specification which those languages provide, you can easily have it.
06:10:51 <nornagon> maybe not, though
06:11:03 <povman> nornagon: typeclasses /= overengineering
06:11:05 <nornagon> i haven't really done a lot with typeclasses, and i'm generally not very good at code organisation
06:11:20 <nornagon> povman: typeclasses for something like 'hp' seems like it.
06:11:34 <jre2> for specifying capabilities, they're pretty good
06:11:47 <Cale> Actually, if you want to go full tilt on the engineering, use lenses.
06:12:16 <povman> someone ought to make syntax sugar for lenses
06:12:24 <nornagon> ... lenses?
06:12:55 <Cale> nornagon: something like this: http://twan.home.fmf.nl/blog/haskell/overloading-functional-references.details
06:12:56 <lambdabot> Title: Overloading functional references - 21 thoughts, http://tinyurl.com/2ustba
06:13:54 <Cale> povman: One idea is to make field names of records refer to lenses for the corresponding fields rather than extractors.
06:14:40 <povman> that's what i was thinking
06:15:04 <povman> actually that might be horrible
06:15:05 <Cale> We really need a proper record system though.
06:15:23 <povman> what do you mean by that?
06:15:36 <Cale> I really like Daan's proposal with regard to semantics. I'd make the syntax quite different though.
06:15:49 <Cale> one sec, I'll get a PDF
06:16:19 * jre2 leaves to work
06:16:28 <Cale> http://research.microsoft.com/users/daan/download/papers/scopedlabels.pdf -- pretty sure this is the one
06:16:36 <lambdabot> http://tinyurl.com/392r4k
06:16:49 <dolio> "My hunch would be that an impure functional language like this (OCaml is another example) makes optimisation easier, compared to Haskell"
06:16:56 <dolio> That doesn't sound right.
06:16:56 <Saizan_> Cale: that doesn't seem to have first-class labels though
06:17:08 <Cale> dolio: It isn't right :)
06:17:32 <Cale> Saizan_: That's okay with me.
06:17:52 <povman> Saizan_: labels don't always work first-class as it is
06:18:02 <nominolo> Cale: what's your syntax proposal?
06:18:31 <Arnar_> @localtime byorgey
06:18:32 <lambdabot> Local time for byorgey is Thu Jul  3 09:18:31 2008
06:18:55 <Saizan_> well i considered lenses a poor man first-class label
06:18:57 <Cale> I would start by having all record field names start with a single quote, making them syntactically distinguished. They would refer to lenses for the various record operations on that field
06:19:35 <Cale> So you'd have something along the lines of...
06:20:03 <Cale> get 'myField myRecordValue
06:20:14 <Cale> set 'myField value myRecord
06:20:23 <Cale> extend 'myField value myRecord
06:20:25 <nominolo> Cale: that looks like Lisp's quote
06:20:31 <dolio> Lenses actually came up in a thread on comp.lang.haskell recently (well, I brought them up).
06:20:31 <Cale> delete 'myField myRecord
06:20:48 <nominolo> Cale: so what would the type-level syntax look like?
06:20:53 <Cale> Note that field names also exist at the type level, right.
06:20:54 <nominolo> Record 'foo 'bar ?
06:21:04 <dolio> And how the state-in-context comonad is isomorphic to a partially-applied lens.
06:21:11 <nornagon> Cale: that looks scarily like you'd be implementing the record as a map :)
06:21:25 <Cale> { 'foo :: Foo, 'bar :: Bar }
06:21:34 <Cale> { 'foo :: Foo, 'bar :: Bar | r }
06:21:50 <Cale> (where r would be a row variable :)
06:21:55 <nominolo> and < 'foo :: Foo, 'bar :: Bar > for variants?
06:22:09 <Cale> yeah, that'd work
06:22:35 <Cale> nornagon: Well, that's one implementation, but I don't really give a damn about low-level details like that.
06:22:43 <nominolo> we could use {: ... :} alike to the DPH syntax
06:22:48 <Cale> There are more efficient approaches though.
06:22:57 <povman> it'd be also good to import labels and fields from another type, like inheritence
06:23:00 <Cale> (using vectors)
06:23:29 <Cale> povman: hm?
06:23:30 <Saizan_> would 'myField have a type?
06:23:35 <nominolo> Cale: i think the real issue is how you relate records to modules and how you handle type classes and associated dictrionaries
06:23:50 <Cale> Saizan_: In a value position, it would evaluate to a lens.
06:24:00 <nominolo> povman: you don't need that
06:24:01 <nornagon> I hope the people who write the language do. I have a dual-core 2GHz processor and 2GB of ram, and some things (sadly) just need C.
06:24:07 <nominolo> povman: these records are extensible
06:24:08 <Cale> Saizan_: with various functions to extract the record operations from it
06:24:14 <povman> nominolo: ?
06:24:23 <nominolo> povman: you could say this is "static duck-typing"
06:24:42 <nominolo> ie., is-a(X) == has-label(X)
06:25:08 <povman> data A = { fruit :: Int, cake :: Bool}; data B <import A> = { cheese :: String } -- fruit (x :: B) works
06:25:21 <Cale> nornagon: I'm always annoyed when people complain that lookup in some structure is O(log(n)). So is memory access, if you think about it :)
06:25:33 <nornagon> Cale: how so?
06:26:00 <nominolo> Cale: but things should be cache-friendly
06:26:05 <Cale> nornagon: You can't address n memory locations with addresses shorter than log(n) bits.
06:26:14 <Cale> (log base 2)
06:26:15 <nominolo> Cale: which, say, a linked list or tree is not
06:26:25 <nornagon> sure
06:26:36 <yitz> Cale: but parallel hardware emulates O(1). So it makes sense that we put that in IO - you're using a specialized hardware device. :)
06:26:39 <nornagon> but the asm for loading something from memory is a fixed number of cycles
06:26:43 <Cale> So as you continue adding memory to your system, the cost of addressing that memory goes up.
06:26:55 <dolio> It'd probably be more like 'type A = { fruit :: Int, cake :: Bool} ; type B = { cheese :: String | A }'
06:27:05 <nornagon> or at least close to fixed.
06:27:07 <Cale> Asymptotic notation is only important in large cases.
06:27:35 <Cale> If you're worried about the small-case costs, the asymptotic complexity is irrelevant.
06:27:38 <dolio> Although that's not entirely accurate because A isn't a row variable.
06:27:56 <dolio> Or, a row.
06:28:02 <nornagon> Cale: when you're doing things in a tight loop over several gigabytes of data, the cycles count.
06:28:14 <yitz> nornagon: same is true of Data.Map - it's also O(log n), limited to the log of your memory size.
06:28:15 <povman> i'm not entirely sure what you're talking about so i might wait until i've read that paper
06:28:28 <Cale> Sure, but the fact that it's logarithmic time doesn't mean that it's automatically slow.
06:28:38 <nominolo> dolio: no, { foo :: Bar | x } is extension
06:28:44 <nominolo> ie, x can be a record
06:28:44 <nornagon> Cale: right
06:28:46 <yitz> nornagon: so it's constant in that same sense, like memory access
06:29:00 <nornagon> but Data.Map is slower than tuple/record member access.
06:29:09 <dolio> It's been a long time since I read the paper.
06:29:12 <Cale> nornagon: In fact, that's as fast as you can expect any addressing operation in any unbounded structure to be.
06:29:14 <yitz> nornagon: it's a hardware optimization
06:29:25 <nornagon> yitz: exactly :)
06:29:41 <nornagon> memory is a Data.Map address -> int
06:29:51 <Cale> If you have an additional guarantee, like that there will only ever be at most n elements in your structure, well, you're down to constant time again.
06:30:16 <nornagon> there are only ever n elements in my record.
06:30:23 <Cale> And Data.Map is *very* practical in terms of the constant factors.
06:30:40 <Cale> (try it!)
06:31:47 <nornagon> I should, sometime. But I don't really have enough knowledge of how GHC compiles things to optimise the rest of the program.
06:31:55 <_zenon_> Cale: Data.Map should be able to grow, yes?
06:32:07 <Cale> You're talking about implementing a game where there will be at most on the order of thousands of objects around at any time, and that's pushing it really. Data.Map scales very well to millions of elements.
06:32:11 <yitz> For most situations, Data.Map works great and arrays are a premature optimization that obscures code.
06:33:07 <mm_freak_work> yitz: i find STArrays and STUArrays quite readable, although you give up a lot of the functional paradigm
06:33:12 <Cale> (and surely never more than a handful of properties per object!)
06:33:13 <nornagon> Cale: I'm also talking about the possibility of implementing it on a very limited system
06:34:10 <hpaste>  olsner pasted "This is where I realize I don't know arrows..." at http://hpaste.org/8681
06:34:21 <nornagon> and it'd be nice to do it in haskell, but i think haskell may just be the wrong hammer for this particular nail :)
06:34:37 <yitz> mm_freak_work: if you need it, ST is not all that bad, but you do lose a lot.
06:35:02 <nornagon> a system with a number of objects with properties naturally lends itself to object-oriented code
06:35:07 <nornagon> which haskell is not so good at.
06:35:21 <Cale> where's olsner?
06:35:33 <olsner> I seem to have understood how to route a single value through an arrow and out into a value in the other end - but how do I connect more than one arrow?
06:35:37 <olsner> (here :P)
06:35:39 <Cale> ah, there you are :)
06:36:03 <mm_freak_work> i still haven't found a good solution for global application stateâ€¦  code tends to get quite large
06:36:06 <mauke> :t (>>>)
06:36:07 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
06:36:12 <Saizan_> the problem is not connecting arrows there
06:36:16 <Cale> olsner: The first problem there is that you're using the result of one arrow-computation to decide what the rest of the arrow computation is
06:36:29 <mm_freak_work> my current solution is:  while :: Monad m => a -> (a -> Bool) -> (a -> m a) -> m a
06:36:34 <Cale> olsner: In order to be able to do that, you need an instance of ArrowApply
06:36:49 <Cale> olsner: (which incidentally implies that your arrow is actually a monad)
06:36:56 <mm_freak_work> while x p c = if p x then c x >>= (\y -> while y p c) else return x
06:37:03 <olsner> woah :)
06:37:17 <mm_freak_work> and 'a' is usually some configuration type
06:37:32 <mm_freak_work> data Configuration = Configuration { quit :: Bool, â€¦ }
06:37:47 <mm_freak_work> while defaultCfg (not . quit) $ \cfg -> do â€¦
06:37:53 <Cale> There is a nice syntax however...
06:38:15 * Cale quickly looks up the syntax in the GHC user guide
06:38:20 <yitz> nornagon: mm_freak_work: INLINE pragma and IORef is unfortunately still the current state of the art
06:38:20 <Cale> it was something like  -<<
06:38:24 <povman> mm_freak_work: what's wrong with that?
06:38:31 <mauke> ooh, I want â€¦ = error "yada yada yada"
06:38:34 <nornagon> yitz: ;(
06:38:36 <Saizan_> yeah, it's "-<<"
06:39:13 <yitz> nornagon: sorry. getting used to a new irc client.
06:39:43 <Cale> Yeah, so try using -<< in place of -< on the line where you have that  add arot
06:40:20 <mm_freak_work> yitz: well, i'd prefer my solution over that, because mine is pure =)
06:40:23 <olsner> that's scarily magical... what does -<< actually do?
06:40:25 <Cale> err...
06:40:32 <Cale> wait a sec :)
06:40:39 <mm_freak_work> povman: dunnoâ€¦  it's just that it looks a lot duct-taped
06:40:41 <Cale> (that's not actually what you want to do apparently :)
06:40:47 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/arrow-notation.html
06:40:47 <lambdabot> Title: 8.9. Arrow notation, http://tinyurl.com/tts6c
06:41:30 <Cale> btw, there's tabs in that
06:41:44 <Cale> just a warning, you don't want tabs in Haskell source files :)
06:42:01 <_zenon_> insert spaces
06:42:21 <vixey> you know Normalisation by Evaluation, are there other ways to normalize a lambda term?
06:42:24 <tromp> or in any other source files for that matter
06:42:37 <olsner> I just like tabs :)
06:42:39 <vixey> I want tabs in my Makefiles
06:42:42 <_zenon_> my "tab" is 4 spaces, that's enough .)
06:42:46 <vixey> otherwise they don't run ...
06:43:00 <Cale> vixey: I don't want Makefiles ;)
06:43:10 <vixey> well I can't build GHC without them
06:43:29 <vixey> (but I definitely agree Make is terrible and should be replaced)
06:43:36 <tromp> my "tabs" are 2 spaces
06:43:53 <vixey> (I don't care enough and don't except anyone to pick up any replacement I wrote though so I don't both to write one)
06:44:01 <hesselink> vixey: the question is just: with what?
06:44:05 <mm_freak_work> i indent 2 spaces mostly, but more if it's appropriate
06:44:32 <olsner> hmm, so since I now have brought in ArrowApply, my arrow is just a more difficult way to write a monad?
06:45:08 <_zenon_> tromp: Just 2 ?
06:45:15 <vixey> hesselink: I don't know what you mean
06:45:26 <vixey> I'm wondering what other ways there are to normalize a term that evalutaion
06:45:33 <hesselink> you want to replace Make, but with what?
06:46:05 <vixey> I said I don't want to replace make
06:46:15 <vixey> because nobody would use my replacement
06:46:16 <tromp> 2 is enough
06:46:25 <hpaste>  Cale annotated "This is where I realize I don't know arrows..." with "compiles now, at least" at http://hpaste.org/8681#a1
06:46:28 <olsner> Cale: oh, and why was -<< not actually what I wanted to do?
06:46:34 <Cale> oh, it is
06:46:45 <Cale> olsner: There were just other problems
06:46:56 <Cale> Like, the lines where you didn't have an arrow command at all
06:46:57 <_zenon_> tromp: That's .... tight.
06:47:07 <olsner> yeah, noticed those afterwards
06:47:10 <Cale> and the type error involving f t
06:47:16 <olsner> yeah, that too
06:48:31 <Cale> oh, in that code I have  arot <- rotateA 5 -<< a, and that's unnecessary... -< will do fine there
06:48:53 <EvilTerran> ?type (-<<)
06:48:54 <lambdabot> Not in scope: `-<<'
06:48:59 <Cale> -<< is syntax
06:49:04 <EvilTerran> ok
06:49:05 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/arrow-notation.html
06:49:05 <lambdabot> Title: 8.9. Arrow notation, http://tinyurl.com/tts6c
06:50:24 <EvilTerran> i se
06:50:25 <EvilTerran> e
06:55:00 <_zenon_> I should return to the Home monad now ;)
06:55:14 <_zenon_> bye'
07:04:28 <greenrd> Where can I find documentation on how to use Lazy Smallcheck?
07:06:58 <Cale> greenrd: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/lazysmallcheck
07:07:02 <Cale> Click on the module names
07:07:02 <lambdabot> http://tinyurl.com/6ym28r
07:07:19 <Cale> oh, huh
07:07:31 <Cale> I suppose the haddock documentation is a bit spartan
07:08:11 <Cale> I suppose there's also http://www-users.cs.york.ac.uk/~mfn/lazysmallcheck/
07:08:11 <lambdabot> Title: Lazy SmallCheck
07:08:29 <carl> whats the best way to deal with a network stream if u need to cruch it at a byte level
07:09:05 <carl> right now im using map ord "str"
07:09:09 <SamB> carl: lazy bytestring?
07:09:23 <SamB> strict bytestring?
07:13:26 <mm_freak_work> say i have a program with a main loop and LOTS (hundrets of thousands) of objects it's operating on
07:13:32 <mm_freak_work> is there a state of the art solution?
07:13:54 <vixey> > 100*1000
07:13:57 <lambdabot>  100000
07:13:58 <vixey> that's not that many
07:14:08 <vixey> > sum [1..100000]
07:14:10 <lambdabot>  5000050000
07:14:20 <mm_freak_work> vixey: it's a real time program
07:14:30 <mm_freak_work> a game or a real time simulation, for example
07:14:55 <mm_freak_work> my idea was to just use a list, which i map and filter
07:15:26 <mm_freak_work> newObjects = filter alive . map run $ objects
07:15:40 <Cale> mm_freak_work: If you're processing things in order all the time, lists work nicely.
07:16:10 <mm_freak_work> Cale: my fear is that it'll be a memory hog
07:16:15 <mm_freak_work> am i wrong?
07:17:05 <Cale> Well, that depends a bit on whether the lists are kept around or garbage collected quickly or removed entirely by fusion.
07:17:25 <Cale> (which depends on exactly how you're processing them)
07:17:50 <HunterXHunter2> mm_freak_work: check this out http://www.cse.unsw.edu.au/~pls/thesis/munc-thesis.pdf
07:18:41 <mm_freak_work> Cale: precisely as aboveâ€¦  i have a list as part of a configuration (the app state)
07:19:05 <mm_freak_work> and i have a 'while' loop like above:  while :: Monad m => a -> (a -> Bool) -> (a -> m a) -> m a
07:19:40 <Cale> mm_freak_work: Well, I imagine that won't be so bad.
07:20:37 <Cale> mm_freak_work: Assuming that you're, say, printing each generation as you go, you'll need to hold on to the list of elements for the current generation, but that's it.
07:20:53 <mm_freak_work> HunterXHunter2: interesting, thanks
07:20:55 <Cale> and that size is going to be constantly decreasing apparently
07:21:23 <quicksilver> you need to 'do something' to the list each iteration
07:21:28 <quicksilver> otherwise you hang onto big thunks
07:21:36 <mm_freak_work> Cale: new objects can be added by existing objects (i don't know how i'm gonna do that, but that's less of a matter)
07:21:40 <quicksilver> display data to screen nrmally does the trick :)
07:21:47 <yakov> hey
07:21:58 <quicksilver> mm_freak_work: I've used lists for a realtime particle system with 10s of 1000s of particles
07:22:00 <Cale> mm_freak_work: perhaps what you really want is a concatMap
07:22:02 <quicksilver> mm_freak_work: and it ran fine.
07:22:11 <mm_freak_work> Cale: but yes, the old list will be dropped at each iteration, creating a new one
07:22:13 <Cale> (rather than map and filter)
07:22:17 <quicksilver> yes, I used a mixture of concatMaps and filters
07:23:06 <mm_freak_work> Cale: the concatMap idea is great
07:23:22 <yakov> how does type for C function void foo() look like in haskell ffi?
07:23:27 <Cale> (or if you're a list monad person, that's (>>=) :)
07:23:39 <Cale> yakov: foo :: IO ()
07:24:07 <mm_freak_work> then an object has to return itself as well as other objects it creates and just returns an empty list, when it vanishes completely
07:24:22 <Cale> mm_freak_work: right
07:24:35 <quicksilver> mm_freak_work: http://hpaste.org/3558
07:24:45 <mm_freak_work> wellâ€¦  what if objects need to interact?  will lists still work well?
07:24:59 <quicksilver> mm_freak_work: the "filter" part is the "termination" member
07:25:08 <quicksilver> and the "new objects" part is "evolution"
07:25:13 <Cale> mm_freak_work: If interaction involves random access, then probably not so well.
07:25:24 <quicksilver> there was a reason I went for explicit termination and not "just not returning it"
07:25:27 <mm_freak_work> quicksilver: it'll be more general in my case
07:25:29 <quicksilver> I can't entirely remember why
07:25:34 <Cale> mm_freak_work: At that point, I'd move to using Data.Map
07:25:35 <quicksilver> I think it was more composable
07:25:51 <quicksilver> mm_freak_work: sure, that was just intended as an example of something which had worked.
07:26:34 <mm_freak_work> hmm
07:30:15 <gbacon> ?src filter
07:30:37 <gbacon> @bot
07:30:48 <vixey> > sum [1..100000]
07:30:54 <lambdabot> filter _ []     = []
07:30:55 <lambdabot> filter p (x:xs)
07:30:55 <lambdabot>     | p x       = x : filter p xs
07:30:55 <lambdabot>     | otherwise = filter p xs
07:30:55 <lambdabot> :)
07:30:57 <lambdabot>  5000050000
07:31:39 <gbacon> so is it possible to write filter without repeating "filter p xs" in both branches?
07:31:47 <vixey> yes
07:31:57 <quicksilver> yes, with a where clause
07:32:00 <vixey> if f x then (x :) else id
07:32:08 <quicksilver> there's no particular gain in doing so though
07:32:20 <ziman> or let rest = filter p xs in ...
07:32:32 <quicksilver> ziman: that would break the guards :)
07:32:36 <quicksilver> that's why I suggested a where clause.
07:32:44 <vixey> or filter f = foldr (\x ys -> if p x then x:ys else ys) []
07:32:49 <quicksilver> obviously you could layer in another scope to attach the guards too.
07:32:50 <quicksilver> to
07:33:00 <ziman> quicksilver, yes, i thought of the if version
07:33:07 <gbacon> or play games with concat
07:33:25 <quicksilver> I stopped doing that
07:33:28 <quicksilver> it always beats me.
07:34:15 <vixey> concat . foldr (\x ys -> if p x then [x] else []) []
07:34:25 <vixey> oops
07:34:32 <vixey> concat . map (\x -> if p x then [x] else [])
07:34:46 <EvilTerran> concatMap?
07:34:56 <gbacon> >>= !!
07:35:04 <ziman> fmap! :)
07:35:05 <vixey> "concatMap?"?
07:35:28 <EvilTerran> foldr (\x -> if p x then (x:) else id) []
07:36:28 * EvilTerran is tempted to pf that, but won't
07:36:43 <vixey> @pf (\x -> if p x then (x:) else id)
07:36:44 <lambdabot> Maybe you meant: bf pl
07:36:51 <vixey> @pl (\x -> if p x then (x:) else id)
07:36:51 <lambdabot> flip (liftM2 if' p (:)) id
07:36:59 <ziman> @pl join . fmap f
07:36:59 <lambdabot> (f =<<)
07:38:35 <ziman> @hoogle if'
07:38:36 <lambdabot> No matches found
07:39:51 <gbacon> ?pl \x -> (x:)
07:39:51 <lambdabot> (:)
07:48:28 <HunterXHunter2> @type (f =<<)
07:48:29 <lambdabot> forall a (m :: * -> *) b. (Monad m, SimpleReflect.FromExpr (m b), Show a) => m a -> m b
07:49:19 <ziman> :t (_ =<<)
07:49:20 <lambdabot> Pattern syntax in expression context: _
07:49:37 <vixey> :t (?x =<<)
07:49:38 <lambdabot> forall a (m :: * -> *) b. (Monad m, ?x::a -> m b) => m a -> m b
07:52:43 <chr1s> gbacon: what about filter p ys = [y | y <- ys, p y]
07:53:22 <Deewiant> @undo f p xs = [ x | x <- xs, p x ]
07:53:22 <lambdabot> f p xs = concatMap (\ x -> if p x then [x] else []) xs
07:53:34 <Deewiant> @. pl undo f p xs = [ x | x <- xs, p x ]
07:53:34 <lambdabot> f = (=<<) . flip flip [] . (`ap` return) . (if' .)
07:54:02 <gbacon> chr1s: of course!
07:54:19 <olsner> :t flip flip []
07:54:20 <lambdabot> forall a c a1. (a -> [a1] -> c) -> a -> c
07:54:20 <chr1s> I always try to use list comprehensions whenever I see a concatMap
07:54:33 <gbacon> the function I'm writing is more complicated, but I want to throw away some elements
07:54:37 <chr1s> if it clarifies the code, of course.
07:54:52 <olsner> wth, did that even type? weird
07:55:04 <olsner> or... I was surprised at least
07:55:14 <Deewiant> ?ty flip flip [] . flip ap return
07:55:15 <lambdabot> forall c a a1 (m :: * -> *). (Monad m) => (a1 -> m a1 -> [a] -> c) -> a1 -> c
07:55:16 <gbacon> I have a case, but I was trying to avoid repeating the recursive call to the end of each branch
07:55:22 <Deewiant> ?ty concatMap . flip flip [] . flip ap return
07:55:23 <lambdabot> forall b a a1 (m :: * -> *). (Monad m) => (a1 -> m a1 -> [a] -> [b]) -> [a1] -> [b]
07:55:33 <gbacon> s/to/at/
07:55:37 <Deewiant> ?ty let if' x y z = if x then y else z in concatMap . flip flip [] . flip ap return . (if' .)
07:55:38 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
07:55:43 <Deewiant> magic
07:56:24 <chr1s> gbacon: also, if you do recursion on lists, try to do folds. that separates traversal from logic.
08:00:39 <gbacon> chr1s: I'm partitioning a list.. sometimes I want to throw away the head, sometimes I may want only the head, and sometimes I may want to pull off multiple elements
08:01:28 <_zenon_> gbacon: Which is your predicate that determine each case?
08:01:48 <Dae_> is it possible to get ghc to output the source files of the code after the optimizations have been run? I can't seem to find any info 'bout it in the user manual
08:02:20 <_zenon_> Dae_  : Honestly, about -> 'bout, you didn't save a character there :P
08:02:48 <gbacon> _zenon_: case (dataReference d) of ...
08:03:05 <_zenon_> gbacon: d is your list ?
08:03:15 <gbacon> _zenon_: no, d is the head
08:03:19 <gbacon> (d:ds)
08:03:39 <_zenon_> gbacon: Okay, then, what is the problem?
08:03:43 <Dae_> _zenon_: 'bout is the strict version of bout...
08:03:49 <_zenon_> seems like you got this covered
08:05:52 <gbacon> _zenon_: I'm trying to take chr1s's advice and refactor to a fold.. as is, I'm using Maybe and break
08:06:58 <_zenon_> gbacon: Oh, okay, I missed that.
08:18:38 <_zenon_> ?ty foldl'
08:18:39 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
08:18:41 <lilachaze> @index comparing
08:18:41 <lambdabot> bzzt
08:24:51 <BMeph> Dae_: Check out http://blog.unsafeperformio.com/?p=27
08:24:52 <lambdabot> Title: Functional Thinking » GHC Core for Performance Debugging
08:25:21 <ndm> @messages
08:25:21 <lambdabot> You don't have any new messages.
08:28:02 <HunterXHunter2> @message
08:28:02 <lambdabot> Maybe you meant: messages messages?
08:28:05 <HunterXHunter2> @messages
08:28:05 <lambdabot> You don't have any new messages.
08:29:03 <gwern> @mâ‚¬ssagâ‚¬s
08:29:04 <lambdabot> Unknown command, try @list
08:29:30 <HunterXHunter2> @list
08:29:30 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
08:30:06 <gwern> @messages
08:30:06 <lambdabot> You don't have any new messages.
08:31:45 <gwern> phooâ‚¬y
08:31:56 <EvilTerran> she'll tell you when you talk, anywa
08:32:32 <gbacon> ?index on
08:32:32 <lambdabot> bzzt
08:32:45 <HunterXHunter2> @index google
08:32:45 <lambdabot> bzzt
08:33:05 <pastorn> BMeph: in distrib :: (LMapDom a s, VectorSpace b s, VectorSpace c s, VectorSpace u s) =>
08:33:05 <pastorn>            (b -> c -> u) -> (a :> b) -> (a :> c) -> (a :> u), what is ":>"?
08:33:42 <gwern> offhandÂ¸anyonâ‚¬ know how to writâ‚¬ a quickchâ‚¬ck tâ‚¬st which takâ‚¬s two argumâ‚¬nts
08:33:55 <cjay> lol
08:33:58 <gwern> of diffâ‚¬râ‚¬nt typâ‚¬sÂ¸I mâ‚¬an
08:34:06 <HunterXHunter2> @ft
08:34:07 <lambdabot>  FTshell (version 0.2) - Automatic generation of free theorems
08:34:07 <lambdabot>  Press `:help' for help or `:quit' to quit.
08:34:07 <lambdabot>  Loading `/home/cgibbard/local/share/ftshell-0.2/ftshell-0.2/declarations.hs' ... found 187 declarations.
08:34:07 <lambdabot>  > > >
08:34:23 <pastorn> gwern: my_prop var1 var2 = sumthin(var1,var2)
08:34:29 <pastorn> gwern: or?
08:34:43 <orbitz> HunterXHunter2: stop followign em to channels!
08:35:39 <gwern> I want to tâ‚¬st that '\x y -> id == concat . intâ‚¬rspâ‚¬rsâ‚¬ a . brâ‚¬aks a'
08:36:18 <pastorn> gwern: paste
08:36:20 <pastorn> @paste
08:36:20 <lambdabot> Haskell pastebin: http://hpaste.org/new
08:36:41 <olsner> gwâ‚¬rn: why thâ‚¬ wâ‚¬ird â‚¬'s?
08:36:46 <EvilTerran> gwern, er, what's with the â‚¬s?
08:36:59 <EvilTerran> is your e key broken?
08:38:11 <BMeph> pastorn: Check out Conal's blog on a differential data structure: http://conal.net/blog/posts/what-is-a-derivative-really/#NewDif
08:38:13 <EvilTerran> also, i think you can just write those quickcheck properties directly
08:38:14 <gwern> noÂ¸ubuntu is
08:38:30 <gwern> pastorn: I am just a littlâ‚¬ uncâ‚¬rtain bâ‚¬causâ‚¬ I usually writâ‚¬ tâ‚¬sts likâ‚¬ 'eepCheck (\s -> height s > 0 && increasing height s)'
08:38:42 <EvilTerran> @check (\x y -> reverse x ++ reverse y == reverse (y ++ x)) :: [Int] -> [Int] -> Bool
08:38:44 <lambdabot>  OK, passed 500 tests.
08:39:04 <gwern> `whâ‚¬râ‚¬ dâ‚¬â‚¬pChâ‚¬ck is quickChâ‚¬ckWith
08:40:05 <qwr> does \x y -> y has some wellknown name?
08:40:15 <lilachaze> flip const ?
08:40:20 <_zenon_> qwr: K*
08:40:22 <EvilTerran> flip const, const id, curry snd...
08:40:23 <gwern> x and y arâ‚¬ diffâ‚¬râ‚¬nt variablâ‚¬sÂ¸thâ‚¬n
08:40:33 <_zenon_> qwr: The other is K = \xy.x
08:40:45 <EvilTerran> gwern, and cedillas instead of commas? that's very broken...
08:40:54 <_zenon_> qwr: The third in the quartet is S = \xyz.xz(yz)
08:40:57 <lilachaze> gwern: seriously, what's up with the EUR instead of e's?
08:41:07 <_zenon_> qwr: The first is Id = \x.x
08:41:14 <qwr> hmm k is good
08:41:42 <gwern> thâ‚¬ altâ‚¬rnativâ‚¬s arâ‚¬ just as painful
08:41:44 <qwr> although it's somehow too short to put into lib ;)
08:41:46 <_zenon_> qwr: Those are some standard lamda combinators
08:41:46 <EvilTerran> gwern, is your AltGr key stuck or something? try tapping your modifier keys a few times, see if that fixes it
08:42:00 <gwern> lilachaze: I am using an intâ‚¬rnational kâ‚¬ymap to bypass thâ‚¬ brokâ‚¬n râ‚¬turn kâ‚¬y in thâ‚¬ us kâ‚¬ymap
08:42:15 <gwern> `I do intâ‚¬nd to fix this at somâ‚¬ pointË™Ë™Ë™
08:42:26 <qwr> _zenon_: yes i thought that it could be some standard lambda combinator
08:42:28 <EvilTerran> er
08:42:31 <ibid> what international keymap has â‚¬ for e? :)
08:42:49 <EvilTerran> and Ë™ for .
08:43:46 <gwern> ibid: microsoftprooâ‚¬mÂ¸it would sâ‚¬â‚¬m
08:44:14 <ibid> stuck altgr wouldn't create this kind of trouble
08:44:39 <ibid> Ã¾hÄ±ÃŸÂ Ä±ÃŸÂ whÉ™Ã¾Â hÉ™â‚¬Å‹ÃŸÂ Ä±fÂ Ä±Â Ä¸â‚¬â‚¬Â É™Ã¾grÂ Ã°Å“wÅ‹'
08:44:59 <ibid> (that was: this is what happens if i keep altgr down - plus a suprious apostrophe)
08:44:59 <EvilTerran> ibid, ok, that's quite a lot worse :P
08:45:25 <ibid> (in the fi keymap, at least)
08:45:25 <olsner> â€ Ë›Ä±ÃŸÂ Ä±ÃŸÂ â€™Ã©Â Î©Ä±â€ Ë›Â ï£¿ï¬â€ Â Ï€Â®Ã©ÃŸÃŸÃ©âˆ‚ (this is me with Alt pressed)
08:45:39 <geezusfreeek> wow
08:45:42 <EvilTerran> thÃ­s Ã­s whÃ¡t hÃ¡ppÃ©ns Ã­f *Ã­* kÃ©Ã©p ÃltGr dÃ³wn
08:45:53 <orbitz> hah
08:45:56 <orbitz> taht's awesome
08:45:57 <olsner> oh, that's even readable
08:46:00 <geezusfreeek> â€ Ë™Ë†ÃŸÂ Ë†ÃŸÂ ÂµÂ´Â âˆ‘Ë†â€ Ë™Â Ã¸Ï€â€ Ë†Ã¸ËœÂ Ï€Â®Â´ÃŸÃŸÂ´âˆ‚
08:46:05 <EvilTerran> it's a rather more acute problem than the others :D
08:46:10 <_zenon_> map CtrlOrAltorAltrGrkeydown channel
08:46:10 * qwr wonders if k isn't in haskell library just because they didn't want one-letter function...
08:46:20 <geezusfreeek> ^ option key
08:46:20 <EvilTerran> qwr, k is, it's called "const"
08:46:33 <orbitz> qwr: they prefer one symbol funcions
08:46:35 <olsner> EvilTerran: a cute pun there :D
08:46:48 <EvilTerran> olsner, ye- wait, i see what you did there
08:46:49 <EvilTerran> :D
08:47:02 <olsner> heh
08:47:24 <_zenon_> qwr: simply flip const
08:47:50 <_zenon_> or by all means, define your own K* :)
08:48:28 <geezusfreeek> Control.Applicative is a generalization of SK
08:48:43 <_zenon_> mmhmmm
08:48:52 <EvilTerran> (\x y -> y) = flip const = const id = curry snd = ...
08:49:13 <olsner> const id?
08:49:19 <EvilTerran> ?unpl const id
08:49:20 <lambdabot> (\ _ b -> b)
08:49:22 <olsner> yes, I see you already mentioned that.. nm
08:49:32 <EvilTerran> ?unpl curry snd
08:49:32 <lambdabot> curry snd
08:49:35 <EvilTerran> huh
08:49:46 <qwr> _zenon_: yes i want to define it. i asked because i just discovered that i often want to get value of second argument... and wanted some good name for it. ;)
08:49:48 <tromp> :t ap const
08:49:49 <lambdabot> forall a b. (a -> b) -> a -> a
08:49:54 <pastorn> @src curry
08:49:55 <lambdabot> curry f x y = f (x, y)
08:50:02 <pastorn> @src uncurry
08:50:02 <lambdabot> uncurry f p = f (fst p) (snd p)
08:50:03 <_zenon_> qwr: Sure, go with the std def then :)
08:50:14 <EvilTerran> uncurry f ~(x,y) = f x y -- if you prefer
08:51:01 <tromp> uncurry is useful in making dishes less spicy
08:51:04 <olsner> :t liftM2 f fst snd
08:51:05 <lambdabot> forall r a b. (SimpleReflect.FromExpr r, Show b, Show a) => (a, b) -> r
08:51:12 <qwr> ~(x,y) what this means?
08:51:19 <olsner> :t liftM2 ?f fst snd
08:51:20 <lambdabot> forall r a b. (?f::a -> b -> r) => (a, b) -> r
08:51:26 <_zenon_> tromp: that's bananas you are talking about, really soothens your mouth
08:51:30 <BMeph> @unpl uncurry snd
08:51:30 <lambdabot> uncurry snd
08:51:34 <_zenon_> let bananas = uncurry
08:51:35 <EvilTerran> qwr, ~(pattern) means the pattern never fails
08:51:37 <ibid> qwr: "assume that this parameter is a pair and let x and y stand for its components"
08:51:59 * qwr wonders, how (x, y) could fail ;)
08:52:02 <ibid> qwr: without the tilde it becomes "check that this parameter is a pair and ..."
08:52:04 <EvilTerran> qwr, so that bit of the expression being matched against doesn't get forced at all at matching time
08:52:09 <ibid> qwr: give it bottom
08:52:26 <geezusfreeek> qwr: it's a lazy pattern match, basically
08:52:26 <EvilTerran> qwr, it only gets forced when you try to use one of the variables bound by the irrefutable pattern
08:52:42 <EvilTerran> > (\(x,y) -> "boom") undefined
08:52:44 <lambdabot>  "Exception: Prelude.undefined
08:52:44 <qwr> a, ok
08:52:48 <EvilTerran> > (\~(x,y) -> "cool") undefined
08:52:48 <lambdabot>  Parse error at "->" (column 10)
08:52:56 <EvilTerran> > (\ ~(x,y) -> "no, really") undefined
08:52:57 <lambdabot>  "no, really"
08:53:10 <EvilTerran> ?src fst
08:53:10 <lambdabot> fst (x,_) =  x
08:53:17 <olsner> lambdabot parse fail?
08:53:31 <EvilTerran> olsner, no, (\~) is a valid operator name, iirc
08:53:40 <EvilTerran> > let (\~) = (,) in 1 \~ 2
08:53:42 <lambdabot>  (1,2)
08:54:06 <olsner> ooh, perlskelly
08:54:23 <ibid> ym haskerl?
08:55:00 <olsner> yes, or some other variation of letters ;)
08:55:09 <EvilTerran> line-noise-skell
08:55:20 <ibid> olsner: there is precedent for haskerl :)
08:55:23 <_zenon_> I can has kell?
08:55:27 <EvilTerran> &^%$kell
08:56:00 <paolino> ask hell
08:56:07 <ibid> olsner: http://www.dcs.gla.ac.uk/~partain/haskerl.html
08:56:07 <lambdabot> Title: The Haskerl index
08:56:31 <_zenon_> Ska Hell
08:56:33 <_zenon_> :P
08:57:31 <_zenon_> Monad transformers => Transformed Romans
08:57:44 <_zenon_> Nomad Transformers
08:58:03 <byorgey> preflex: seen Arnar_
08:58:03 <preflex>  Arnar_ was last seen on #haskell 2 hours, 39 minutes and 32 seconds ago, saying: @localtime byorgey
08:59:13 <olsner> ibid: ooh *reading intently*
09:09:36 <ibid> olsner: i hope you noticed larry wall's response :)
09:10:11 * olsner was disappointed when he saw it'd been posted on April 1st
09:11:12 <olsner> ibid: the problem is, it wouldn't surprise me the least if Perl 5 actually *had* that feature :D
09:11:42 <SamB> olsner: what was posted on april 1st?
09:11:54 <SamB> also sometimes people don't notice it is april 1st
09:11:59 <olsner> SamB: http://www.dcs.gla.ac.uk/~partain/haskerl.html
09:11:59 <lambdabot> Title: The Haskerl index
09:12:05 <SamB> oh, that ;-)
09:12:20 <SamB> wasn't that the codename for Perl6?
09:13:27 <Arnar_> hey there
09:13:33 <Arnar_> byorgey: ping
09:13:39 <byorgey> hey Arnar_
09:13:42 <byorgey> you were looking for me?
09:13:57 <Arnar_> byorgey: yeah.. wanted to say thanks for including my blog in the HWN
09:14:02 <SamB> olsner: isn't there a package for that on CPAN?
09:14:09 <byorgey> Arnar_: oh, you're welcome =)
09:14:12 <Arnar_> byorgey: I was wondering if you were willing to put up my full name :)
09:14:22 <ibid> olsner, SamB: at least there is one for latin :)
09:14:28 <byorgey> Arnar_: I'd be happy to, I just didn't know what it is =)
09:14:31 <Arnar_> byorgey: it was my mistake not to include it on the blog
09:14:36 <olsner> SamB: as said, it would not surprise me the least :)
09:14:36 <SamB> olsner: I mean, maybe not square ones
09:14:38 <Arnar_> byorgey: sure.. it's Arnar Birgisson :)
09:14:42 <byorgey> ok, thanks
09:14:54 <Arnar_> byorgey: thank _you_ :)
09:15:17 <Arnar_> I should change my blog post signatures I guess :)
09:15:20 <ibid> Lingua::Romana::Perligata
09:15:30 <smg> hi.
09:15:32 <smg> i have a file foo.hs.
09:15:36 <smg> how can i import it to another file say bar.hs ?
09:15:44 <ibid> smg: you can't
09:15:52 <ibid> smg: it needs to start with an upper case letter for that
09:16:14 <ibid> smg: and you don't import files, you import modules
09:16:19 <ibid> there's a small difference there
09:16:53 <SamB> http://cpan.org/modules/by-category/09_Language_Interfaces/
09:16:53 <lambdabot> Title: Index of /modules/by-category/09_Language_Interfaces
09:17:05 <SamB> http://cpan.org/modules/by-category/09_Language_Interfaces/Language/
09:17:06 <lambdabot> Title: Index of /modules/by-category/09_Language_Interfaces/Language, http://tinyurl.com/55jztm
09:17:35 <ibid> http://99-bottles-of-beer.net/language-perligata-1501.html
09:17:37 <lambdabot> Title: 99 Bottles of Beer | Language Perligata
09:17:41 <Cale> actually, it doesn't *have* to start with an uppercase character, but it makes it easier for GHC to find the module that way
09:17:49 <Cale> Otherwise, you need to pass it on the commandline.
09:19:02 <smg> ibid: i know
09:19:14 <byorgey> Arnar: if there are other posts you write in the future that you'd like included, let me know
09:19:15 <ibid> know which?:)
09:19:16 <smg> ibid: can i somehow use then this file called "foo.hs" anyway in another file say "bar.hs"?
09:19:26 <smg> ibid: module/file thingy
09:19:43 <ibid> smg: simplest is to rename it :)
09:19:45 <byorgey> Arnar: I found it through a google blog search for haskell-related things, but I can't guarantee I will always find things =)
09:19:53 <smg> ibid: ok ty
09:19:54 <vixey> Cale: computer formalized math is painful :(
09:20:12 <ibid> smg: but if that's impossible then preprocessor include might work (depending on the content of the files)
09:20:24 <smg> mh
09:20:29 <smg> i have now called it Foo.hs
09:20:38 <smg> but if i create a file bar.hs with import Foo it will fail
09:20:38 <ibid> import Foo
09:20:59 <ibid> you probably need to have module Foo where at the beginning
09:21:07 <smg> ah, typo! sorry it works.
09:21:12 <ibid> cool
09:23:56 <Cale> vixey: tell me something new ;)
09:23:58 <Cale> vixey: hehe
09:25:00 <jamii> Does Data.Foldable only guarantee the associativity of foldl and foldr or also that they have the same laziness behaviours as the list versions?
09:25:33 <SamB> I hope not ;-P
09:25:43 <SamB> foldl would be kinda dumb if it did
09:26:15 <jamii> Thats what I was hoping. They should probably both be lazy like foldr, right?
09:26:28 <smg> ty ibid
09:26:31 <SamB> foldl is over-lazy, actually
09:26:34 <SamB> on lists
09:26:41 <Cale> I'd expect it to be highly dependent on the instance in question
09:26:44 <SamB> yeah
09:26:45 <SamB> me too
09:26:58 <SamB> for lists, I'd expect foldl to be like Data.List.foldl'
09:27:11 <Cale> I'd expect it to be like foldl
09:27:27 <jamii> Cale: Im considering having maps depend on Foldable. I want to make sure it behaves how people expect
09:27:32 <SamB> Cale: you are thinking more about the mathematics than whether it would be able to be used for anything
09:27:53 <Cale> SamB: I just expect the compiler to do more legwork :)
09:28:01 <SamB> Cale: the compiler can't do that
09:28:16 <jamii> There will be foldl, foldr, fold' and foldr'. The folds are guaranteed to go in ascending key order.
09:28:22 <Cale> That was the original intention with the prelude foldl
09:28:34 <SamB> was a silly idea
09:28:42 <SamB> has not happened, never will happen
09:29:01 <SamB> I just hope that foldl is moved to Data.List and foldl' brought in from there
09:30:22 <jamii> How about foldl and foldr have the same behaviour as List.foldr and the strict versions behave like List.foldl' ?
09:30:23 <jdrake> On this page: http://www.haskell.org/haskellwiki/List_comprehension it shows an example of the sieve of atkin, but it uses a function called poly that I am not familiar with. Any ideas what it is?
09:30:24 <lambdabot> Title: List comprehension - HaskellWiki
09:30:33 <Cale> I'd certainly expect foldl in Data.Foldable to be the usual foldl because Data.Foldable has a foldl' of its own
09:31:05 <SamB> Cale: oh
09:31:11 <SamB> in that case, I guess things are different
09:31:47 <SamB> I shouldn't speak from such ignorance :-(
09:34:13 <vixey> Martin-L Â¨
09:34:13 <vixey> of â€™s type theory [M-L71a] is a well established and convenient arena in which computational Christians are regularly fed to logical lions
09:34:52 <SamB> what the heck are computational Christians?
09:35:39 <orzo> hello
09:36:00 <Arnar> byorgey: ah, thanks.. I will
09:36:01 <_zenon_> :http://magic.falseblue.com/output/1215102945.png
09:36:32 <orzo> I have an idea that would make my particular program especially elegant
09:36:40 <jamii> Ok, Ill rephrase the question. Suppose you could choose to have your list go in either direction for free. Would you want foldr to be defined as it normally is or to be defined like 'foldr f a = foldl f a. reverse'
09:36:47 <orzo> it would require a modified ByteString
09:36:55 <Cale> jamii: I'd want foldl to change
09:37:23 <jamii> 'foldl f a = foldr f a . reverse' . Any particular reason?
09:37:26 <orzo> I'd like to bounce it off some more experienced haskeller
09:37:34 <Cale> @src foldr
09:37:34 <lambdabot> foldr f z []     = z
09:37:34 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
09:37:47 <jamii> Bearing in mind that maps are unlikely to have an infinite number of keys
09:37:47 <vixey> jamaii: that's not true
09:37:51 <Cale> If f doesn't happen to need its second parameter, the recursive case is unused.
09:37:56 <Cale> (and hence uncomputed)
09:38:00 <vixey> jamaii: you must flip f in one side
09:38:01 <_zenon_> Is there some statistic on what is the most common target for @src ?
09:38:17 <Cale> @src foldl
09:38:17 <lambdabot> foldl f z []     = z
09:38:17 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
09:38:38 <jamii> vixey: Sure, I was being fairly vague. Im just trying to decide what would be the preferred behaviour
09:38:41 <Cale> foldl always just immediately recurses until it reaches the end of the list, so it's bad for things like infinite lists
09:38:49 <Cale> (or very large ones)
09:38:57 <jamii> vixey: It will be defined directly on the map structure either way
09:39:19 <SamB> Cale: is there a mathematical definition of "very large" that is relevent here?
09:39:40 <Cale> SamB: well, not a mathematical one so much :)
09:39:57 <jamii> Cale: But foldr on large lists can overflow the stack?
09:39:59 <SamB> okay, so you were thinking Haskell then ;-P
09:40:06 <Cale> jamii: You're thinking of foldl
09:40:13 <jamii> Ok. Fair enough
09:40:17 <SamB> jamii: foldr doesn't overflow stacks on it's own
09:40:50 <Cale> You can make expressions with either one which will overflow the stack.
09:41:02 <orzo> The situation is that C code is passing in a buffer to a haskell function that is doing parsing and such on the buffer.  I want to avoid copying from the buffer whenever possible.  Therefore, create ByteStrings using ByteString.Internal directly from the buffer during my computations.  Anything ByteString that I want to be remembered after I return to C, i must take care to copy to the heap.
09:42:03 <jamii> > foldr (+) [1..100000]
09:42:04 <lambdabot>   add an instance declaration for (Num [t])
09:42:12 <jamii> > foldr1 (+) [1..100000]
09:42:14 <lambdabot>  5000050000
09:42:16 <orzo> I would like to keep track of all created bytestrings with a collection of weak pointers and just before I return to C, i will copy whatever ByteSTring objects are still alive on the heap
09:42:19 <jamii> > foldl1 (+) [1..100000]
09:42:21 <lambdabot>  5000050000
09:42:36 <jamii> Hmm. More zeros?
09:42:44 <jamii> > foldr1 (+) [1..1000000]
09:42:47 <lambdabot>  Exception: stack overflow
09:42:53 <jamii> > foldl1 (+) [1..1000000]
09:42:55 <lambdabot>  500000500000
09:42:59 <orzo> thatway, i can write code that is oblivious to the fact that the bytestrings are in the temporary buffer
09:43:10 <cnwdup> How can I send a POST request using curl processing the received data? Unfortunately(?) curlPost return IO () showing the response. But how can I access it?
09:43:16 <jamii> There we go. Thats what I was thinking of. Can you give an example thats the other way round?
09:43:17 <Arnar> @src foldr
09:43:17 <lambdabot> foldr f z []     = z
09:43:17 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
09:43:31 <Arnar> @src foldl
09:43:31 <lambdabot> foldl f z []     = z
09:43:31 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
09:43:44 <quicksilver> jamii: that works because the strictness analyser can see that (+) is strict, basically.
09:43:53 <orzo> of course, the bytestrings would need to have a way to change their pointers and they'd need pointers to the weak pointer colection and the bytestring primitives would be responsibple for keeping the weak poitner collection up to date
09:43:56 <quicksilver> if it wasn't for the strictness analyser foldl would overflow too
09:44:11 <Arnar> quicksilver: really.. is it not because foldl is tail recursive while foldr is not?
09:44:14 <orzo> So, was anybody listening?
09:44:18 <Cale> Arnar: really
09:44:30 <_zenon_> Did someone see this ?
09:44:30 <Cale> foldl (+) 0 [1,2,3]
09:44:31 <_zenon_> http://magic.falseblue.com/output/1215102945.png
09:44:40 <Cale> -> foldl (+) (0 + 1) [2,3]
09:44:46 <Cale> -> foldl (+) ((0 + 1) + 2) [3]
09:44:53 <Cale> -> foldl (+) (((0 + 1) + 2) + 3) []
09:44:58 <Cale> -> ((0 + 1) + 2) + 3
09:45:09 <Cale> and that's where you get a stack overflow if that expression is too large
09:45:18 <Arnar> oh I see
09:45:19 <Cale> because the reducible subexpression is possibly too deep
09:45:39 <quicksilver> with strictness inferred by the compiler it can mop up the subexpressions as it goes
09:45:42 <Arnar> so parts of it are evaluated strictly?
09:45:44 <quicksilver> and then it doesn't overflow.
09:46:03 <quicksilver> the compiler will, in some cases, strictly evaluate the arguments to functions it knows are strict.
09:46:09 <quicksilver> it knows (+) is strict on Int.
09:46:12 <PeakerWork> Cale: why doesn't the stack dynamically grow as necessary?
09:46:14 <jamii> So foldl is more amenable to strictness analysis but can do too much work if the function shortcircuits
09:46:29 <Arnar> nice.. always learning I guess
09:46:41 <quicksilver> PeakerWork: it is the opinion of the developers that huge stacks are more often than not a sign of bugs.
09:46:56 <quicksilver> PeakerWork: so they deliberately limit the stack.
09:47:18 <PeakerWork> quicksilver: is this foldl expression actually a bug?
09:47:18 <quicksilver> it happens to be the case that GHC compiled apps have an O(n^2) time factor on stack length
09:47:26 <quicksilver> PeakerWork: no.
09:47:31 <jamii> > foldl1 (&&) $ replicate 1000000 True
09:47:33 <lambdabot>  True
09:47:33 <quicksilver> "more often than not"
09:47:37 <jamii> > foldr1 (&&) $ replicate 1000000 True
09:47:39 <lambdabot>  True
09:47:58 <Arnar> I'm curious how GHC represents the call stack.. is there a traditional stack or a linked list of activation records, or something else entirely?
09:48:02 <quicksilver> so it would be undesirable to have an unlimited stack on GHC as it is.
09:48:05 <jamii> @type repeat
09:48:06 <lambdabot> forall a. a -> [a]
09:48:12 <PeakerWork> quicksilver: well, is it a good idea to make some bugs be found this way, while making legitimate programs harder to write?
09:48:17 <jamii> > foldl1 (&&) $ repeat True
09:48:21 <quicksilver> PeakerWork: that is a good question.
09:48:31 <lambdabot> Terminated
09:48:31 <quicksilver> PeakerWork: but the point is your legitimate program will run EXTREMELY SLOWLY
09:48:33 <jamii> > foldr1 (&&) $ repeat True
09:48:34 <quicksilver> quadratic time.
09:48:42 <quicksilver> so it's not reall a feasible strategy anyway
09:48:44 <vixey> Arnar: spineless tagless g-machine and how to make a fast curry are good text about this
09:48:45 <lambdabot>  Exception: Time limit exceeded
09:48:48 <quicksilver> even if you turn off the stack check
09:48:50 <quicksilver> which you can do.
09:48:51 <jamii> What?
09:49:00 <jamii> Oops
09:49:11 <jamii> > foldl1 (&&) $ repeat False
09:49:15 <jamii> Is what I meant to be doing
09:49:19 <Arnar> vixey: thanks.. will google
09:49:23 <orzo> anybody here ever embed haskell in a program whose main is in C?
09:49:24 <lambdabot> Terminated
09:49:31 <jamii> > foldr1 (&&) $ repeat False
09:49:33 <lambdabot>  False
09:49:37 <jamii> Ok.
09:54:35 <asdftimo> hey guys, i have a list of pairs (x,y) and i need to find the x that corresponds to the maximum y. i can't figure out how to do this without losing the x. can someone help?
09:55:30 <smtms> asdftimo, "maximum y" implies your y's are ordered
09:55:45 <jamii> How often would you want foldl over foldl'
09:55:45 <smtms> asdftimo, create an ordering on pairs, that is based on the ordering on y's
09:56:26 <asdftimo> smtms: i understand what you are saying, but i don't know how to implement it.
09:56:35 <vixey> :t sortBy (comparing snd)
09:56:37 <lambdabot> forall a b. (Ord b) => [(a, b)] -> [(a, b)]
09:56:52 <ziman> jamii, i can't think of a case when you would want foldl instead of foldl'
09:57:00 <tromp> :t maximumBy
09:57:01 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
09:57:09 <vixey> > sortBy (comparing snd) $ [('a',7),('o',3),('z',6)]
09:57:10 <lambdabot>  [('o',3),('z',6),('a',7)]
09:57:17 <ziman> i mean, that's a rule of thumb -- for lazy lists use foldr, for strict reduction use foldl'
09:57:26 <asdftimo> thanks vixey, tromp. i think i can figure it out from here.
09:57:30 <vixey> > head . sortBy (flip (comparing snd)) $ [('a',7),('o',3),('z',6)]
09:57:32 <lambdabot>  ('a',7)
09:57:35 <jamii> Seems reasonable
09:57:38 <jamii> Cheers
09:59:39 <asdftimo> vixey: what module do i need to use 'comparing'
09:59:48 <vixey> I don't know
09:59:51 <Deewiant> @index comparing
09:59:51 <lambdabot> bzzt
09:59:52 <vixey> @index comparing
09:59:52 <lambdabot> bzzt
09:59:55 <vixey> huh..
09:59:57 <Deewiant> Data.Ord probably
09:59:58 <vixey> probably Data.List
09:59:59 <Deewiant> @hoogle comparing
09:59:59 <lambdabot> Data.Ord.comparing :: Ord a => (b -> a) -> b -> b -> Ordering
10:00:03 <vixey> awww
10:00:03 <Deewiant> I win
10:12:14 <monochrom> @bot
10:12:14 <lambdabot> :)
10:12:18 <monochrom> <3 #haskell
10:12:45 <vixey> :)
10:15:04 <EvilTerran> ziman, jamii: you'd want foldl instead of foldl' in the cases where f may not be strict in the accumulator (likely dependent on the value of the current cell)
10:16:38 <jamii> EvilTerran: Im thinking about my map interface. Ive roughly decided on having foldrAsc, foldrDesc. foldlAsc', foldlDesc' . Would you still need a nonstrict foldl, do you think?
10:16:58 <EvilTerran> it'd be nice to have for completeness, i guess
10:17:22 <EvilTerran> altho you can implement foldl in terms of foldl' and "data Id a = Id a"
10:17:28 <EvilTerran> it would be gratuitous and ugly
10:18:04 <jamii> or 'foldl' f = foldl (f $!) ' ?
10:18:20 <EvilTerran> er... not sure
10:18:24 <jamii> foldl' f = foldl (f $!)          -- In case that was hard to read
10:19:21 <jamii> Oh.
10:19:22 <monochrom> > foldl1 (*) [0..1000000000]
10:19:28 <jamii> @src Data.Foldable.foldl'
10:19:28 <lambdabot> Source not found. There are some things that I just don't know.
10:19:33 <lambdabot>  Exception: Time limit exceeded
10:19:34 <jamii> Bah
10:19:41 <vixey> 0
10:19:44 <jamii> foldl' f z xs = foldr f' id xs z
10:19:44 <jamii>   where f' x k z = k $! f z
10:19:52 <jamii> Is the library version
10:20:15 <EvilTerran> weird
10:20:18 <jamii> foldr' f z xs = foldl f' id xs z
10:20:18 <jamii>   where f' k x z = k $! f x
10:20:27 <jamii> I agree. Very confusing
10:20:57 <jamii> Oh, its folding the functions rather than the elements.
10:21:45 <monochrom> Magic is indistinguishable from confusion.
10:22:06 <jamii> No, magic is sparklier, with little purple bits. This is definitely confusion
10:22:22 <pyNem> hey, can someone give me good pointers to monads.. I am comfortable with elementary func prog .. like basic scheme. I am finding I/O a difficult thing in haskell. A good tut would do
10:22:25 <EvilTerran> but sometimes my confusion is sparkly with little purple bits...
10:22:39 <EvilTerran> ?go you could have invented monads
10:22:39 <jamii> EvilTerran: You might want to see a doctor about that...
10:22:40 <lambdabot> http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
10:22:40 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ...
10:22:45 <EvilTerran> i like that one
10:23:04 <ddarius> @where goodtutorial
10:23:04 <lambdabot> http://homepages.inf.ed.ac.uk/wadler/papers/essence/essence.ps
10:23:06 <monochrom> Phil Wadler's "monads for functional programming"
10:23:14 <jamii> Also Dons programmable semicolon one?
10:23:17 <monochrom> Real World Haskell
10:23:18 <vixey> ?go mauke IO do haskell
10:23:19 <lambdabot> No Result Found.
10:24:04 <pyNem> thanks a lot .. ill have a look at wadler's and sigfpe
10:24:14 <jamii> http://book.realworldhaskell.org/beta/monads.html
10:24:18 <lambdabot> Title: ChapterÂ 16.Â Monads
10:24:28 <vixey> pyNem: this is what I was looking fro http://mauke.ath.cx/stuff/haskell/how-to-io.html
10:24:30 <lambdabot> Title: Haskell: How To IO
10:24:31 <lament> no unicode = fail
10:24:54 <jamii> lament: fail :: Maybe Ok
10:25:59 <monochrom> mauke's looks good
10:28:22 <hackage> Uploaded to hackage: obdd 0.2
10:28:22 <hackage> Uploaded to hackage: AGI 1.2
10:28:22 <hackage> Uploaded to hackage: uconv 0.0.3
10:28:23 <hackage> Uploaded to hackage: GraphSCC 1.0
10:28:25 <hackage> Uploaded to hackage: hpodder 1.1.5
10:30:13 <asdftimo> hey guys, how can i write a type signature for a function that takes in an int and outputs a fractional int?
10:30:18 <_zenon_> A good idea for a Haskell-ish tattoo ?
10:30:32 <vixey> :k Fractional Integer
10:30:32 <lambdabot> Class `Fractional' used as a type
10:30:34 <wuxia> how do i access the sin/cos/sqrt functions in haskell?
10:31:00 <vixey> :t (undefined :: (Fractional x, Integral x) => Integer -> x)
10:31:01 <lambdabot> forall x. (Integral x, Fractional x) => Integer -> x
10:31:10 <vixey> asdftimo: Just like that I guess
10:31:13 <paolino> @hoogle cos
10:31:13 <lambdabot> Prelude.cos :: Floating a => a -> a
10:31:13 <lambdabot> Prelude.cosh :: Floating a => a -> a
10:31:13 <lambdabot> Control.Arrow.Transformer.CoState :: module
10:31:17 <vixey> @instances Fractional
10:31:18 <lambdabot> Double, Float
10:31:22 <vixey> @instances Integral
10:31:22 <_zenon_> wuxia: The prelude
10:31:23 <lambdabot> Int, Integer
10:31:27 <paolino> > cos 4
10:31:28 <lambdabot>  -0.6536436208636119
10:31:41 <vixey> asdftimo: but there's no x that satisfies those constraints in the Prelude
10:31:57 <_zenon_> wuxia: Hoogle is your friend :) http://haskell.org/hoogle/
10:31:57 <lambdabot> Title: Hoogle
10:32:39 <asdftimo> arg that didnt work for me vixey. i basically need to divide integers but i can't use div because i need the remainder.
10:33:00 <vixey> :t divMod
10:33:01 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
10:33:12 <vixey> you could use this instead sometimes..
10:33:22 <asdftimo> this is my function:
10:33:23 <asdftimo> sumofdivisors n = (product [ (p^(a)-1)/(p-1) | (p,a)<-instanceslist n])-n
10:33:26 <vixey> > divMod (2*7 + 4) 7
10:33:28 <lambdabot>  (2,4)
10:33:40 <vixey> no no no
10:33:49 <vixey> asdftimo: sumofdivisors = sum . divisors
10:34:16 <asdftimo> @hoggle divisors
10:34:16 <lambdabot> No matches found
10:34:39 <vixey> divisors n = filter (`divides` n) [2..n]
10:34:53 <asdftimo> thats extremely slow code
10:35:11 <wuxia> crap, using cos/sin/sqrt has gotten me floating points ... how do i round them to integers?
10:35:13 <shrimpx> speed is in the eye of the beholder
10:35:15 <asdftimo> i have a good prime factorization function. and you can get the sum of divisors from prime factorization
10:35:29 <asdftimo> http://planetmath.org/encyclopedia/FormulaForSumOfDivisors.html
10:35:29 <lambdabot> Title: PlanetMath: formula for sum of divisors
10:35:52 <vixey> oh very nice
10:36:12 <vixey> are we allowed to call functions Î  in Haskell?
10:36:23 <asdftimo> ??
10:36:26 <ddarius> vixey: No.  That would be a constructor.
10:36:31 <vixey> that sucks
10:36:33 <ToRA> Ï€ is fine though
10:36:34 <pyNem> vixey, thanks :)
10:36:38 <asdftimo> sumofdivisors n = (product [ (p^(a)-1)/(p-1) | (p,a)<-instanceslist n])-n
10:36:43 <jpcooper> hello
10:36:53 <jpcooper> could anyone recommend some papers of functional software design?
10:36:56 <jdrake> :t poly
10:36:57 <lambdabot> Not in scope: `poly'
10:36:58 <asdftimo> this is that product, but ghc keeps bitching at me
10:37:03 <ddarius> wuxia: round.
10:37:19 <wuxia>     (polygon [(round x - size/2 * sqrt(3.0), round y-size/2),
10:37:19 <wuxia>               (round x + size/2 * sqrt(3.0), round y),
10:37:19 <wuxia>               (round x, round y + size)]))
10:37:23 <wuxia> how do I fix that code?
10:37:38 <wuxia> seems like i'm  having loats of floating/int problems, according to ghc
10:37:43 <vixey> wuxia: remove the brackets first
10:37:59 <wuxia> this is useing soegraphics
10:38:05 <wuxia> i'm pretty sure polygon takes a list
10:38:22 <asdftimo> anyway, vixey, do you have any ideas on how to fix my code?
10:38:25 <wuxia> in fact, that's how they implemented the fillTri function
10:38:50 <vixey> asdftimo: The first thing I'd suggest is renaming instanceslist to something else
10:39:23 <asdftimo> vixey:ok. what about the fractional int issue?
10:39:34 <jpcooper> anyone?
10:39:50 <vixey> asdftimo: is (p^(a)-1)/(p-1) always an integer?
10:39:51 <wuxia> hmm,  is * Int -> Int -> Int ?
10:39:58 <vixey> asdftimo: if so then you can use `div` instead of /
10:40:05 <vixey> wuxia: No, but that's one possible type for it
10:40:10 <asdftimo> vixey: no, it isn't, but the resulting product is always an integer
10:40:23 <vixey> asdftimo: in that case, you could round the result
10:40:24 <asdftimo> vixey: is there some kind of typecasting i can do?
10:40:52 <vixey> :t round :: Float -> Integer
10:40:53 <lambdabot> Float -> Integer
10:42:08 <lilachaze> @hoogle (a,a) -> (a -> b) -> Array a b
10:42:09 <lambdabot> No matches, try a more general search
10:42:32 <_zenon_> @hoogle mapM
10:42:32 <lambdabot> Prelude.mapM :: Monad m => (a -> m b) -> [a] -> m [b]
10:42:32 <lambdabot> Control.Monad.mapM :: Monad m => (a -> m b) -> [a] -> m [b]
10:42:32 <lambdabot> Data.Traversable.mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
10:42:40 <ddarius> lilachaze: There should be functions like that, but there are not.
10:43:48 <vixey> has anyone extended buildExpressionParser?
10:44:01 <lilachaze> > array (1,2) ((1,()):undefined) ! 1
10:44:03 <lambdabot>  Exception: Prelude.undefined
10:44:14 <ddarius> vixey: Extended it to?
10:44:50 <vixey> It would be nice if Prefix and Postfix has associativities but other extensions would be interesting too
10:47:35 <ddarius> vixey: I'm not sure why they would need associativities.  Maybe you mean have them be associative (assuming they aren't already?)
10:48:52 <vixey> say you defined, Prefix "s" AssocRight, you could write s s s z = s (s (s z)) but if you have it no assoc. then it would be a (s s) (s z)
10:49:04 <vixey> or maybe it would be an error, I don't konw
10:49:17 <ddarius> vixey: If s is prefix it should associate right or be an error.
10:49:43 <vixey> yeah, you can't currently choose which with buildExpressionParser
10:55:34 <asdftimo> would someone mind explaining how this function works? i know i converts a base10 int into a base2 int, but it is confusing.
10:55:35 <asdftimo> showBin = flip (showIntAtBase 2 intToDigit) ""
10:56:05 <vixey> @src flip
10:56:06 <lambdabot> flip f x y = f y x
10:57:11 <roconnor> @instances Ord
10:57:11 <lambdabot> (), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
10:57:15 <vixey> flip (showIntAtBase 2 intToDigit) "" = \y -> flip (showIntAtBase 2 intToDigit) "" y = \y -> (showIntAtBase 2 intToDigit) y "" = \y -> showIntAtBase 2 intToDigit y ""
10:57:28 <vixey> showBin y = showIntAtBase 2 intToDigit y ""
10:57:34 <roconnor> I wonder if Char shouldn't be an instance of Ord.
10:57:46 <vixey> > showIntAtBase 2 id 5454315 []
10:57:47 <lambdabot>  Couldn't match expected type `Char' against inferred type `Int'
10:57:53 <vixey> grr
10:58:14 <vixey> that type is stupid
10:58:47 <vixey> asdftimo: showIntAtBase 2 id 5454315 [] should be [5,4,5,4,3,1,5]
10:58:53 <prb> Got an HDBC/Sqlite3 threading question if anyone's game.
10:58:55 <vixey> oh no sorry not that
10:59:02 <vixey> asdftimo: it should be the binary version of that
10:59:14 <asdftimo> ok.
10:59:25 <vixey> > showIntAtBase 10 intToDigit 5454315 []
10:59:26 <lambdabot>  "5454315"
10:59:33 <vixey> > showIntAtBase 9 intToDigit 5454315 []
10:59:34 <lambdabot>  "11232820"
10:59:50 <mauke> preflex: calc '9 5454315
10:59:51 <preflex>  11232820
11:00:04 <mauke> preflex: calc '9 pi
11:00:04 <preflex>  3.124188124074427
11:00:07 <vixey> preflex: calc '(1+1) 56465
11:00:07 <preflex>  Lexical error
11:00:28 <vixey> preflex: calc 'pi 9
11:00:28 <preflex>  Lexical error
11:00:36 <jinjing> is length a O(1) operation?
11:00:41 <ddarius> jinjing: NO.
11:00:49 <ddarius> Freakin' keyboard.
11:00:50 <jinjing> ddarius: oh..
11:01:12 <jinjing> why not :)
11:01:24 <paolino> @src length
11:01:25 <lambdabot> Source not found. That's something I cannot allow to happen.
11:01:31 <ddarius> Because lists are singly linked lists.
11:01:39 <vixey> length [] = 0
11:01:45 <vixey> length (x:xs) = 1 + length xs
11:01:53 <vixey> length = foldr (const (1+)) 0
11:01:54 <jinjing> vixey: i c
11:02:02 <vixey> add a stupidly restrictive type signature
11:02:09 <vixey> length :: [a] -> Int
11:02:43 <ddarius> > let length = foldl' (flip const (1+)) 0 in length $ replicate 1 10
11:02:44 <lambdabot>      Occurs check: cannot construct the infinite type: a = b -> a
11:02:44 <lambdabot>     Probabl...
11:03:15 <ddarius> > let length = foldl' (\cnt _ -> 1+cnt) 0 in length $ replicate 1 10
11:03:17 <lambdabot>  1
11:03:34 <ddarius> :t foldl'
11:03:35 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
11:03:56 <jinjing> ddarius, vixey: thanks
11:04:00 * ddarius is having argument order issues today.
11:07:48 <ddarius> data SizedList a = Nil | SizedList !Int a (SizedList a);  headSL (SizedList _ x _) = x; tailSL (SizedList _ _ xs) = xs; consSL x Nil = SizedList 1 x Nil; consSL x xs = SizedList (lengthSL xs + 1) x xs; lengthSL Nil = 0; lengthSL (SizedList len _ _) = len
11:10:52 <paolino> mmh make the [] functions in a class to have O (1) length :) , filter, map, scanl ..
11:11:16 <ddarius> Of course, onesSL = cons 1 onesSL doesn't work.
11:12:10 <mauke> length = fix (1+)
11:17:24 <jdrake> Is there any method of tracking the position of a function that is recursing on itself? Such that if there was a parameter n guarded by m, that you could trace n to get an idea of how long it might take.
11:18:10 <EvilTerran> probably a monad :P
11:18:22 <jdrake> I was hoping for something in ghci :p
11:18:34 <byorgey> jdrake: there are some nice general methods of 'instrumenting' recursive functions by making them take an extra parameter which is the function to be called instead of recursing
11:19:02 <byorgey> jdrake: to get back the original function you just use 'fix'; or you can use something more general which does some computation before recursing on the function
11:19:12 <byorgey> with that said, I'm not entirely sure what you are asking =)
11:19:24 <byorgey> but I could give you some links if that sounds like the kind of thing you're looking for.
11:19:47 <hpaste>  jdrake pasted "Euler5" at http://hpaste.org/8683
11:20:11 <monochrom> Debug.Trace.trace
11:20:43 <monochrom> Example.  f n = trace (show n) (f (n-1))
11:20:46 <jdrake> byorgey: This function that I am running like euler5 1 670442572800  and it will take a while :-)
11:20:54 <jdrake> hmm
11:21:12 <byorgey> jdrake: for that particular problem, I suggest solving it in a more clever way =)
11:21:40 <jdrake> byorgey: I am not sure how cleaver I am. The best I could come up with is getting rid of certain numbers that are redundant.
11:21:57 <byorgey> jdrake: do you know about the lcm function?
11:22:05 <byorgey> @type lcm
11:22:06 <lambdabot> forall a. (Integral a) => a -> a -> a
11:22:14 <jdrake> No, but I can guess about its function
11:22:25 <byorgey> > lcm 20 16
11:22:26 <lambdabot>  80
11:22:50 <byorgey> Well, that's all I will say for now =)
11:22:56 <monochrom> Oh my goodness.
11:23:08 <byorgey> monochrom?
11:23:30 <byorgey> hey chessguy
11:23:32 <monochrom> I'm in perfect agreement with you. :)
11:23:47 <jdrake> monochrom: Is the omg with regards to that code?
11:23:48 <chessguy> howdy
11:23:48 <wuxia> why is intToFloat n implemented as: intToFloat n = fromInteger(toInteger n) ?
11:24:17 <Baughn> wuxia: Is it? Did you check in ghc?
11:24:28 <wuxia> Baughn: according to soe, it is
11:24:41 <monochrom> @quote fromIntegral
11:24:42 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
11:24:48 <byorgey> wuxia: that might be old
11:25:08 <byorgey> wuxia: it works fine, but intToFloat = fromIntegral is probably more idiomatic nowadays
11:25:15 <byorgey> perhaps there wasn't a fromIntegral when SOE was written
11:25:17 <Baughn> @src fromIntegral
11:25:17 <lambdabot> fromIntegral = fromInteger . toInteger
11:25:25 <byorgey> well, there you go =)
11:25:39 <Baughn> @src Num
11:25:39 <lambdabot> class  (Eq a, Show a) => Num a  where
11:25:39 <lambdabot>     (+), (-), (*)           :: a -> a -> a
11:25:39 <lambdabot>     negate, abs, signum     :: a -> a
11:25:39 <lambdabot>     fromInteger             :: Integer -> a
11:25:49 <Baughn> No toInteger? Hm
11:25:56 <Baughn> @type toInteger
11:25:57 <lambdabot> forall a. (Integral a) => a -> Integer
11:25:59 <byorgey> Baughn: that's in Integral
11:26:05 <Baughn> Ah. Quite.
11:26:19 <monochrom> Default implementation of fromIntegral is fromInteger . toInteger.  But you should prefer fromIntegral because there are optimized implementations once you pin down certain types.
11:26:29 <jinjing> @src Integral
11:26:30 <lambdabot> class  (Real a, Enum a) => Integral a  where
11:26:30 <lambdabot>     quot, rem, div, mod :: a -> a -> a
11:26:30 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
11:26:30 <lambdabot>     toInteger           :: a -> Integer
11:26:58 <jdrake> Problem 5 solved, merci byorgey
11:27:05 <byorgey> =D
11:27:10 <Baughn> @type fromIntegral
11:27:11 <lambdabot> forall a b. (Num b, Integral a) => a -> b
11:27:21 <Baughn> monochrom: What class is integral in, then?
11:27:26 <Baughn> *fromIntegral
11:27:27 <byorgey> jdrake: how did you do it?
11:27:48 <jdrake> byorgey: lcm 20 19, then took that result and did it with 18, and repeated all the way down.
11:27:49 <monochrom> fromIntegral involves both Num and Integral.
11:28:07 <Baughn> And thus the answer involves extensions?
11:28:13 <byorgey> jdrake: cool. you can also automate that process with a fold.
11:28:19 <jdrake> byorgey: I seem to be quite bad at coming up with the simplest solution.
11:28:24 <byorgey> > foldl' lcm 1 [1..20]
11:28:26 <lambdabot>  232792560
11:28:37 <byorgey> jdrake: that's ok, that's what practice is for =)
11:28:41 <jdrake> Everything I come up with tends to be very processor intensive
11:29:19 <jdrake> One guy solves this problem like this: {_ x*y%{:[~x;y;_f[y;x!y]]}[x;y]}/1+!20
11:29:19 <chessguy> is there some kind of "unfoldable" class?
11:29:43 <byorgey> jdrake: eek.  what language is that?
11:29:56 <BMeph> byorgey: Looks like J.
11:30:05 <byorgey> BMeph: I know J, and that's not J
11:30:13 <jdrake> It was a relative to that I think
11:30:22 <monochrom> Try K
11:30:24 <wuxia> OT: is the amd phenom x4 worth buying? it's speed looks good, but it seems to have such small cacnes, compared to intel curo 2 duos
11:30:24 <byorgey> it does kind of look like it though =)
11:30:30 <mauke> heh, reminds me of False
11:30:30 <jdrake> Just by looking at it, I am not really interested in the language ;-)
11:30:49 <BMeph> mauke: Naugh, FALSE is much nicer. ;)
11:30:52 <jdrake> I use haskell because of its beauty
11:30:52 <Baughn> wuxia: Well, it's cheaper..
11:31:26 <BMeph> byorgey: Then you're right, it's K. I only know J and K from cursory exposure.
11:31:31 <Baughn> jdrake: Admit it, you don't mind the speed increase either. ;)
11:31:37 <byorgey> yeah, I don't know K at all
11:31:47 <jdrake> Well...
11:32:03 <monochrom> J and K are just kidding.
11:32:26 <byorgey> chessguy: I don't think so
11:33:00 <chessguy> seems like it would be a sensible thing to have
11:33:52 <jdrake> This problem looks interesting: http://projecteuler.net/index.php?section=problems&id=55
11:33:53 <lambdabot> Title: Problem 55 - Project Euler
11:35:06 <byorgey> chessguy: what would an unfoldable class look like?
11:35:13 <jdrake> How well does haskell do fractions?
11:35:24 <byorgey> jdrake: very well, check out Data.Ratio
11:35:30 <byorgey> > 3%5 + 9%17
11:35:32 <lambdabot>  96%85
11:35:54 <byorgey> > sum $ map (1%) [1..10]
11:35:55 <lambdabot>  7381%2520
11:36:04 <chessguy> byorgey: something like this: class Unfoldable a where unfoldTree :: (b -> (a, [b])) -> b -> Tree a
11:36:13 <telexicon> byorgey, wow thats pretty cool
11:36:26 <vinicius> > "x"%"y"
11:36:27 <lambdabot>   add an instance declaration for (Integral [Char])
11:36:27 <lambdabot>     In the expression: "x...
11:36:30 <vinicius> heh
11:36:42 <vinicius> it's not like symbolic math comes free from fractions =P
11:36:52 <vinicius> *with
11:36:55 <byorgey> chessguy: but can't unfoldTree be implemented independently of a?
11:37:01 <Baughn> > x%y
11:37:12 <lambdabot>  (x * signum y `quot` Exception: Time limit exceeded
11:37:29 <byorgey> chessguy: unfoldTree is a nice function but I don't see why you need a type class for that
11:37:30 <chessguy> byorgey: if you have an unfoldTree function, sure
11:37:38 <chessguy> it's already in Data.Tree
11:37:45 <monochrom> Ha! I see what's going on.
11:37:51 <chessguy> but there's no way of knowing whether the function exists for a particular a
11:38:18 <byorgey> chessguy: why would it *not* exist for some particular a?
11:38:38 <chessguy> if the unfoldTree function isn't efined
11:38:44 <chessguy> s/ef/def/
11:38:55 <monochrom> x * signum y `quot`...  is part of a gcd calculation. The poor thing is trying to reduce x%y to simplest terms (like you reduce 100/200 to 1/2) before printing.
11:38:57 <RayNbow> wow
11:39:01 <RayNbow> new Lambdacat posted...
11:39:13 <RayNbow> (actually yesterday)
11:39:14 <byorgey> chessguy: what I am trying to say is, isn't unfoldTree completely polymorphic in a and b?  that is, unfoldTree already works for any types a and b
11:39:29 <byorgey> you don't need separate definitions of unfoldTree for each different type a
11:39:38 <chessguy> hrm
11:39:40 <byorgey> unless I am completely misunderstanding what unfoldTree does
11:39:41 <RayNbow> http://arcanux.org/lambdacats/gentle-intro.jpg <-- dons, for the cover of RWH? :p
11:39:57 <chessguy> oh wait
11:40:01 <chessguy> my mistake
11:40:11 <chessguy> class Unfoldable a where unfoldTree :: (b -> (a, [b]))
11:40:20 <chessguy> except unfoldTree isn't a good name any more
11:40:59 <byorgey> chessguy: do you mean Unfoldable a b where ... ?
11:41:10 <chessguy> maybe
11:41:31 <byorgey> the way you wrote it, you would need to be able to unfold a tree of a's from *any* starting type b
11:41:46 <asdftimo> @hoggle comp
11:41:47 <lambdabot> Prelude.compare :: Ord a => a -> a -> Ordering
11:41:47 <lambdabot> Data.Ord.compare :: Ord a => a -> a -> Ordering
11:41:47 <lambdabot> Data.Ord.comparing :: Ord a => (b -> a) -> b -> b -> Ordering
11:41:50 <asdftimo> @hoggle comb
11:41:50 <lambdabot> System.FilePath.Windows.combine :: FilePath -> FilePath -> FilePath
11:41:50 <lambdabot> System.FilePath.Posix.combine :: FilePath -> FilePath -> FilePath
11:41:50 <lambdabot> Language.Haskell.TH.Lib.combine :: [([(Name, Name)], Pat)] -> ([(Name, Name)], [Pat])
11:42:04 <chessguy> maybe it would be easier to make the type more specific: unfold :: a -> [a]
11:42:20 <byorgey> ah, indeed
11:42:21 <chessguy> or a -> (a, [a])
11:44:26 <byorgey> the nice thing about the separate b type is that it lets you carry along extra state during the unfolding, of course
11:44:57 <chessguy> true
11:47:03 <vinicius> is this discussion related to the typechecking bug?
11:47:22 <vinicius> directly related, I mean.
11:47:33 <chessguy> you mean the unfolding discussion?
11:47:43 <byorgey> what typechecking bug?
11:47:53 <vinicius> http://hackage.haskell.org/trac/ghc/ticket/2414
11:47:55 <lambdabot> Title: #2414 (GHCi / GHC segfault : type checker problem) - GHC - Trac
11:48:41 <asdftimo> hi, can someone tell me what '@' means in a pattern match? ie (x:xs@(y:_))
11:48:57 <dons> it names the pattern
11:49:07 <dons> meaning you can use the matched part as a variable
11:49:25 <byorgey> vinicius: no, the discussion wasn't related to that bug
11:49:25 <dons> > let f x@(_:xs) = x in f [1..10]
11:49:27 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
11:49:29 <dons> > let f x@(_:xs) = x in f []
11:49:30 <lambdabot>   Non-exhaustive patterns in function f
11:49:54 <asdftimo> thanks dons
11:50:03 <monochrom> > case [1,2,3] of me@(x:_) -> (me, x)
11:50:05 <lambdabot>  ([1,2,3],1)
11:50:34 <monochrom> > case [1,2,3] of (x:xs@(y:_)) -> xs
11:50:35 <lambdabot>  [2,3]
11:51:32 <tusho> fun infinite loop:
11:51:35 <tusho> main@m=m
11:51:38 <tusho> even m@main=m works
11:51:47 <mauke> m@in
11:51:55 <tusho> hah
11:52:01 <tusho> that won't compile though :(
11:52:07 <Baughn> x@> x
11:52:14 <tusho> we could embed emails though
11:52:22 <tusho> tusho@tusho<.>org
11:52:27 <tusho> for a datatype named (<.>) i guess
11:52:46 <vinicius> wut
11:52:58 <mauke> > let tusho@example.com = var"wat" in x.x
11:52:59 <lambdabot>  wat
11:53:09 <tusho> wow
11:53:11 <tusho> does that work
11:53:14 <Baughn> ..wat
11:53:24 <tusho> i wish I was 'tasho', actually, because I could have t@sho.org
11:53:28 <tusho> but that's just cheesy
11:53:36 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/8684
11:53:46 <tusho> > let tusho@tusho.org = "test" in x.x
11:53:47 <lambdabot>      Conflicting definitions for `tusho'
11:53:47 <lambdabot>     In the definition of `.'
11:53:52 <tusho> oh, I see
11:53:58 <tusho> it defines (tusho @ tusho) . org
11:54:06 <tusho> awesome
11:54:17 <monochrom> hahaha
11:54:28 <Baughn> tusho: Don't worry. With ICANN's latest move, you can have t@sho.tusho
11:54:42 <tusho> author = tusho@tusho.org        where tusho = org; org = tusho
11:58:58 <EvilTerran> doesn't that define (.)?
11:59:09 <monochrom> Yes absolutely.
11:59:11 <EvilTerran> > x.y
11:59:12 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `Expr'
11:59:23 <Baughn> > f x
11:59:27 <lambdabot>  Add a type signature
11:59:45 <Baughn> THis thing needs more default. And.. .didn't that use to work?
12:00:17 <monochrom> > f x :: Expr
12:00:19 <lambdabot>  f x
12:00:42 * BMeph is most impressed by the Austrian email: dot@dotat.at
12:00:52 <monochrom> haha
12:00:56 <EvilTerran> that must be really hard to explain over the phone
12:01:10 <monochrom> hahaha
12:01:10 <chessguy> @hoogle a -> [a]
12:01:10 <EvilTerran> "dot at dot at dot at" "pardon?"
12:01:12 <lambdabot> Prelude.repeat :: a -> [a]
12:01:12 <lambdabot> Data.List.repeat :: a -> [a]
12:01:12 <lambdabot> Prelude.iterate :: (a -> a) -> a -> [a]
12:01:13 <glguy> That was the goal off http://slashdot.org
12:01:13 <lambdabot> Title: Slashdot: News for nerds, stuff that matters
12:01:35 <EvilTerran> chessguy, return works too
12:02:18 * EvilTerran sticks his tongue out at @hoogle
12:02:46 <chessguy> if i have an instance of Arbitrary, and i want to generate, say, 10 arbitrary values, how do i do it? i can't remember
12:03:06 <Saizan> replicateM 10 arbitrary
12:03:21 <monochrom> You can solve that with intonation.  dÃ³t at dÃ³t Ã¡t dot Ã¡t  may work.
12:04:42 <vixey> or you could just say the ASCII codes over the phone, 100 111 116 64 100 111 116 97 116 46 97 116
12:04:43 <jnaimard> or by being austrian: dot bei(?) dotat punkt at
12:04:44 <vinicius> sounds like a polonaise =P
12:07:30 <asdftimo> @hoggle cycles
12:07:30 <lambdabot> No matches found
12:07:42 <vixey> > cycle "cycle"
12:07:43 <lambdabot>  "cyclecyclecyclecyclecyclecyclecyclecyclecyclecyclecyclecyclecyclecyclecycle...
12:08:00 <thetallguy> > cycle "bi"
12:08:02 <lambdabot>  "bibibibibibibibibibibibibibibibibibibibibibibibibibibibibibibibibibibibibib...
12:08:02 <lambdabot> thetallguy: You have 1 new message. '/msg lambdabot @messages' to read it.
12:11:06 <thetallguy> Hmm..  How do you delete messages that the lambdabot has for you?
12:11:32 <EvilTerran> by reading them, i think
12:11:51 <EvilTerran> ah, @clear-messages
12:12:05 <thetallguy> Thanks.  And where did you find that?
12:12:14 <thetallguy> The command help seems to be out of date
12:12:30 <EvilTerran> @list messages
12:12:30 <lambdabot> tell provides: tell ask messages messages? clear-messages
12:12:33 <EvilTerran> @help clear-messages
12:12:33 <lambdabot> clear-messages. Clears your messages.
12:12:41 <EvilTerran> detective work :)
12:13:40 <thetallguy> when I do at list it gives me a url
12:13:50 <thetallguy> which doesn't mention messages
12:14:21 <Dae_> EvilTerran - Detective extrodinaire
12:15:58 <Baughn> thetallguy: Around here, we /read the source/.
12:16:24 <Baughn> (More realistic than you'd think. LB's source is - mostly - cleanish.)
12:16:38 <thetallguy> Baughn: I'm perfectly capable of doing that, of course.
12:17:03 <SamB> also the URL is on the wrong website
12:17:16 <Baughn> thetallguy: Putting it another way, nobody has updated that url in a long time
12:17:20 <SamB> I really wish lambdabot served a page of it's own
12:17:21 <Baughn> A bit odd, as it should be automatic
12:17:27 <SamB> for that purpose
12:17:32 <thetallguy> Baughn: but I'm much more interested in figuring out to make functional programming provide an infrastructure that helps programmers provide professional software easily, not the shoddy nonsense that gets put out there now.
12:18:09 <SamB> not possible
12:18:30 <Dae_> Programmers provide professional software? I am amazed by the prospect
12:18:36 <thetallguy> :-_)
12:18:36 <SamB> ... if it were easy, it wouldn't be worth having a professionall do it
12:18:43 <thetallguy> Lifelong project.
12:19:02 <Baughn> I don't think it'll be solved. Ever.
12:19:17 <vinicius> > forever $ Just 1 -- awesome
12:19:17 <thetallguy> Baughn: Bet?
12:19:28 <Baughn> Rebuild humans to have codic cortexes? We'll build /even more complex software/, until we reach our competence ilimit again
12:19:30 <lambdabot> Terminated
12:19:52 <Dae_> Baughn: Well, most frameworks require people not to be stupid. That's not likely to happen
12:19:53 <thetallguy> Thanks guys, clearnly I need to get back to work.
12:20:05 <thetallguy> cheers
12:20:09 <Dae_> cheers
12:20:16 <Baughn> thetallguy: No point. So long as there is no effective upper limit on complexity, we'll just get as much of it as we can.
12:20:53 <Baughn> Dae_: But as I was suggesting, even if we fix that it might not help. :P
12:21:44 <vinicius> > forever $ Just (forever :: Maybe a -> Maybe[]) -- extra awesome
12:21:45 <lambdabot>      `[]' is not applied to enough type arguments
12:21:45 <lambdabot>     Expected kind `*', but ...
12:21:56 <vinicius> fail
12:22:16 <Dae_> Baughn: but you are assuming there is no upper bound on perfection. Not that I disagree as such, it's just hard (or even impossible) to prove
12:22:42 <Baughn> Dae_: Perfection? No, I'm assuming there's no upper limit on /complexity/, or desire for same
12:23:03 <Baughn> Which, given that we'd happily build systems more complex than we are if we could, seems a fair bet
12:23:16 <Baughn> At that point we get into AI territory and all bets are off. :/
12:23:23 <EvilTerran> vinicius, that's not a valid type for forever
12:23:27 <EvilTerran> ?type forever
12:23:28 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
12:23:37 <EvilTerran> and that looks like it'd be an infinite loop to me
12:23:39 <vinicius>  forever $ Just (forever :: Maybe a -> Maybe()) -- I know but I'm not wasting cycles for that
12:23:53 <Dae_> AI's can't be made with Turing machines anyway, so.... :p
12:24:00 <Baughn> > iterate Just 1 -- Just.. not.
12:24:01 <lambdabot>      Occurs check: cannot construct the infinite type: a = Maybe a
12:24:01 <lambdabot>       Expe...
12:24:45 <lament> how would you store the notes for a homophonic tune?
12:24:47 <SamB> programming needs to become a proper craft
12:24:53 <Baughn> Dae_: The jury's still out on that. If we find that physics allows hyperturing machines, and our brains actually use such features.. well, then we'll use the same in computers.; )
12:25:00 <Dae_> is lambdabot immune to forkbombs btw?
12:25:09 <EvilTerran> yes
12:25:10 <Baughn> Yes
12:25:10 <vinicius> Dae_: it doesn't do any IO
12:25:23 <EvilTerran> ghc green threads are immune from forkbombs, i think
12:25:24 <SamB> Dae_: there's no way to make it fork more than O(1) times per command
12:25:42 <Baughn> Dae_: There's no way to make it fork more than 1 time per command
12:25:55 <SamB> Baughn: I wouldn't count on that
12:26:02 <EvilTerran> ?hoogle form
12:26:03 <lambdabot> Text.XHtml.Frameset.form :: Html -> Html
12:26:03 <lambdabot> Text.XHtml.Strict.form :: Html -> Html
12:26:03 <lambdabot> Text.XHtml.Transitional.form :: Html -> Html
12:26:04 <EvilTerran> ?hoogle fork
12:26:05 <lambdabot> GHC.Conc.forkIO :: IO () -> IO ThreadId
12:26:05 <lambdabot> GHC.Conc.forkOnIO :: Int -> IO () -> IO ThreadId
12:26:07 <lambdabot> Control.Concurrent.forkIO :: IO () -> IO ThreadId
12:26:12 <Dae_> so no "forever forkIO"
12:26:14 <Baughn> SamB: I've traced it
12:26:17 <SamB> There could be commands that call a shellscript that calls another program or something...
12:26:29 <SamB> (without exec)
12:26:39 <Baughn> Okay, true. I was thinking >-commands
12:26:40 <vinicius> wait, it doesn't evaluate IO at all, does it?
12:26:49 <EvilTerran> the forking function's in IO, you can't use it from lambdabot at all
12:26:50 <Baughn> vinicius: No
12:27:08 <SamB> vinicius: but it does call other programs from various plugins
12:27:16 <Dae_> Seems pretty resonable that it's not giving access to something that could modify the host
12:27:28 <vinicius> what about par stuff?
12:27:29 <EvilTerran> > 1 `par` 2
12:27:30 <lambdabot>  2
12:27:31 <Baughn> > let fork = forkIO fork >> return () in forever fork -- Don't try this at home
12:27:32 <vinicius> oh
12:27:33 <lambdabot>   Not in scope: `forkIO'
12:27:47 <Baughn> vinicius: par doesn't create actual threads, just "sparks" - lazily
12:27:56 <EvilTerran> it's probably configured to only use one thread for evaluating sparks
12:27:57 <SamB> vinicius: even if it worked, yeah, what Baughn said
12:28:06 <Baughn> There's no way to make it use asymptotically more memory than s/par/seq/
12:28:07 <SamB> oh, it did work
12:28:32 <Baughn> EvilTerran: Well, it might be running with -N2
12:28:47 <Baughn> Which would make it two threads. Not yet a forkbomb.
12:28:56 <vinicius> @hoogle par
12:28:57 <lambdabot> GHC.Conc.par :: a -> b -> b
12:28:57 <lambdabot> Control.Parallel.par :: a -> b -> b
12:28:57 <lambdabot> Data.List.partition :: (a -> Bool) -> [a] -> ([a], [a])
12:29:12 <Baughn> For that matter, even forkIO threads just use haskell heap memory, not OS resources
12:29:18 <Baughn> (forkOS, now)
12:29:26 <SamB> > forkbomb n = forkbomb (2*n) `par` forkbomb (2*n+1)
12:29:26 <lambdabot>  Parse error at "=" (column 12)
12:29:33 <SamB> @let forkbomb n = forkbomb (2*n) `par` forkbomb (2*n+1)
12:29:33 <lambdabot> Defined.
12:29:34 <EvilTerran> let f n = f (2*n) -
12:29:36 <EvilTerran> damn
12:29:44 <EvilTerran> the very same example. that's crazy.
12:29:47 <Baughn> > forkbomb 20
12:29:48 <SamB> > forkbomb 1
12:29:56 <lambdabot> Terminated
12:30:00 <EvilTerran> @bot
12:30:04 <EvilTerran> uh-oh
12:30:12 <Baughn> Oh. RIght.
12:30:14 <Tobsan> man that was really unneccessary....
12:30:16 <EvilTerran> vinicius, well, i think that answers your question
12:30:21 <Tobsan> ;-)
12:30:25 <Baughn> Tobsan: It's not /supposed/ to be a problem..
12:30:35 <Baughn> It's just that LB is running with too little memory./ I keep forgetting.
12:30:36 <SamB> Baughn: perhaps it used too much memory?
12:30:37 <EvilTerran> time to redefine par to seq in caleskell?
12:30:44 <SamB> how much memory does it have?
12:30:57 <Baughn> Too little. A couple hundred megs, tops
12:31:04 <Baughn> And it's leaking memory
12:31:22 <Baughn> (Should be running with -M64m in a loop, maybe
12:32:35 <vinicius> lal
12:33:12 <Dae_> Ohh my god! You killed lambdabot!
12:36:45 <Baughn> SamB: It will happily chew up two-three hundred MB if you give it the wrong input. No big deal on a modern machine, but foo.haskell.org only /has/ 384MB. It's a VM, I believe.
12:36:51 <hpaste>  chessguy pasted "Arbitrary instance for a tree-ish type" at http://hpaste.org/8685
12:37:12 <chessguy> i know i'm missing something silly here, but i always get pretty trivial values of TreeTraversal here
12:37:21 <ziman> Baughn, what do the slashes you use mean?
12:37:40 <Baughn> ziman: Italic. See, the first one pushes the letters over, and the second keeps them from falling down.
12:37:51 <ziman> oh, i see :)
12:39:26 <ziman> hm, but i still don't understand why you italicized that word; emphasis doesn't make much sense for me there
12:40:08 <ziman> *to me
12:40:12 <Baughn> I probably overuse them, but.. mentally, I had emphasis on that word.
12:40:16 <Baughn> "Makes sense" doesn't really apply
12:41:24 <ziman> okay ;)
12:41:27 <monochrom> I don't understand some authors' emphasis either.  E.g., "<A> You are the murderer.  <B> No, you /are/ the murderer."  Shouldn't it be "<B> No, /you/ are the murderer." ?
12:41:45 <Dae_> Will you have to reset it to work, or will it come back when it's done?
12:41:55 <Baughn> Dae_: Reset to work.
12:41:57 <Dae_> @let it = lambdabot
12:42:11 <Baughn> That was the OOM killer at work, too; there's a good chance it took something else down with it
12:42:26 <Dae_> on a VM?
12:42:44 <Baughn> Well, the VM doesn't just run LB
12:42:51 <Dae_> Ahh, right
12:43:07 <Baughn> With all the interest lately, you'd think /someone/ would sponsor a proper server for us. Oh well.
12:43:43 * Baughn hopes intel's thousand-core cpu plans go through. Nothing's going to come close to haskell for speed on such things...
12:43:52 <Baughn> (Well, maybe erlang)
12:43:59 <Heffalump> a proper server for lambdabot?
12:44:08 <Baughn> Something with more memory. ;)
12:44:19 <Heffalump> what does it need?
12:44:40 <Baughn> Two-three hundred MB, probably
12:44:40 <jamii> chessguy?
12:44:41 <jamii> *Test System.Random> generate 4 (mkStdGen 1000) (replicateM 4 (arbitrary :: Gen (TreeTraversal Int)))
12:44:41 <jamii> [Cond (-3) TurnRight TurnRight,Compose (Compose TurnRight TurnLeft) (Compose TurnRight (Compose Up (Cond 2 Up Id))),Up,TurnRight]
12:44:57 <Baughn> On top of what's needed for normal operation
12:45:22 <Igloo> It actually needs either unbounded memory, or to be fixed, AIUI
12:45:44 <Igloo> 200-300M is just when community runs out of memory and kills it
12:45:49 <Baughn> I was actually working on that. Hm, let's see..
12:45:56 <Baughn> @version
12:46:07 <chessguy> jamii:  hmm, i just need to pass something bigger to mkStdGen?
12:46:07 <Baughn> ..doh
12:46:42 <jamii> chessguy: Try using newStdGen a couple of times and see what distribution you get
12:46:43 <ddarius> chessguy: That magnitude of that number is irrelevant.
12:47:01 <jamii> You were just unlucky with the number you picked
12:47:12 <chessguy> i picked several numbers
12:48:00 <jamii> try this:    replicateM 100 ((\g -> return $ generate 4 g (arbitrary :: Gen (TreeTraversal Int))) =<< newStdGen)
12:48:30 <jamii> try this:    replicateM 100 (newStdGEn >>= (\g -> return $ generate 4 g (arbitrary :: Gen (TreeTraversal Int))))
12:48:54 <jamii> I get a fairly reasonable distribution
12:49:07 <jamii> You could always use frequency to weight it
12:49:11 <jamii> :t frequency
12:49:22 <jamii> @bot
12:49:24 <jamii> Damn
12:49:41 <jamii> frequency :: [(Int, Gen a)] -> Gen a
12:51:35 * byorgey hacks on Graphics.Rendering.Diagrams after a long hiatus
12:51:51 <byorgey> it's always interesting coming back to projects you haven't touched in a couple months
12:52:17 <jamii> byorgey: The bitrot gremlins come and remove all your comments
12:52:21 <roconnor> byorgey: are you all like, WTF was I doing?
12:52:24 <jamii> while youre not looking
12:52:29 <roconnor> this is terrible code!
12:52:31 <byorgey> jamii: heh, indeed
12:52:31 <roconnor> etc
12:52:49 <byorgey> roconnor: I've had a couple of those moments
12:53:07 <byorgey> although overall I've been pleased =)
12:53:23 <SamB> I think that's normal for proof developments ;-)
12:53:28 <chessguy> @type replicateM
12:53:36 <chessguy> bah
12:53:53 <SamB> chessguy: sorry we forkbombed it
12:54:29 <chessguy> isn't there an infinite version of replicateM?
12:54:35 <EvilTerran> forever
12:55:06 <chessguy> EvilTerran: no, i need the values
12:55:09 <Dae_> Why would you ever want to use forever btw?
12:55:18 <Dae_> wouldn't it just kill your program?
12:55:21 <jamii> chessguy: No. You would need to write one using unsafeInterleaveIO or it will just hang
12:55:26 <SamB> Dae_: if you were writing a coprogram
12:55:39 <jamii> SamB: I bet that cleared things up...
12:55:41 <EvilTerran> well, it won't necessarily hang
12:55:44 <EvilTerran> but it'll never return
12:55:52 <_zenon_> ?ty replicateM
12:55:54 <EvilTerran> the action will still be run
12:56:03 * Baughn notes that, indeed, runplugs /does not set memory limits/
12:56:05 <Baughn> Oops?
12:56:07 <EvilTerran> and will still have side-effects if  the forever's in IO
12:56:09 <jamii> Dae_: Its an infinite loop, like a server constantly handling connections
12:56:20 <SamB> bad dons! bad!
12:56:23 <_zenon_> replicateM is not found by lambdabot?
12:56:33 <jamii> _zenon_: lambdabot is dead
12:56:36 <Baughn> zeno__: LB's down
12:56:37 <SamB> assuming everyone has infinite memory
12:56:47 * Baughn fixes it. Good baughn.
12:56:50 <_zenon_> In which module is it defined ?
12:56:50 <Deewiant> Baughn: and it's all your fault! :-P
12:56:51 <Dae_> jamii: Right ok :)
12:56:51 <jamii> replicateM :: (Monad m) => Int -> m a -> m [a]
12:56:56 <SamB> _zenon_: terribly sorry, but we forkbombed it
12:57:06 <_zenon_> SamB: How devious.
12:57:06 <Baughn> Deewiant: It is?
12:57:10 <Deewiant> oh, SamB as well
12:57:12 <SamB> we didn't expect it to actually WORK
12:57:19 <Dae_> Deewiant: I think it was my fault actually.... I asked if LB was vulnerable to forkbombs
12:57:24 <Deewiant> 2008-07-03 22:29:48 ( Baughn) > forkbomb 20
12:57:24 <Deewiant> 2008-07-03 22:29:48 ( SamB) > forkbomb 1
12:57:39 <SamB> Deewiant: plus I defined the forkbomb function
12:57:42 <Deewiant> no, I blame them for answering that way ;-)
12:57:56 <SamB> Deewiant: we were attempting to answer in the negative
12:58:01 <Deewiant> heh
12:58:05 <SamB> anyway, we found a bug
12:58:06 <Baughn> Deewiant: Oh. No, actually the lack of memory limits might be my fault
12:58:07 <SamB> so it's all good
12:58:10 <Baughn> I'd have to look it up
12:58:15 <Heffalump> I guess you can use as much memory as you can allocate in the time the forked process has.
12:58:48 <Deewiant> so if you're quick enough... *BOOM*
12:58:50 <Baughn> Indeed. On my system, that isn't enough time to get an OOM
12:59:07 <Baughn> It does allocate one gig, though. On a 384MB system..
12:59:22 <BONUS> is replicateM basically just replicate and then sequence
12:59:22 <BONUS> or what
12:59:28 <Baughn> Yes
12:59:29 <Deewiant> yes
12:59:33 <BONUS> nice
12:59:44 <Deewiant> replicateM = (sequence .) . replicate
12:59:49 <Deewiant> or?
12:59:57 <byorgey> replicateM n = sequence . replicate n
12:59:58 <byorgey> right
13:00:10 <Deewiant> so yep
13:00:10 <SamB> byorgey's looks nicer
13:00:18 * byorgey agrees ;)
13:00:18 <Deewiant> yep
13:00:22 <jamii> Fight! Fight!
13:00:31 <_zenon_> Deewiant's looks neater
13:00:36 <_zenon_> Deewiant++
13:00:39 <newsham> ?bot
13:00:46 <Deewiant> ENOBOT
13:00:49 <SamB> newsham: still down
13:00:51 <jamii> newsham: Deaded
13:01:03 <_zenon_> Too bad lambdabot was down :/
13:01:05 <BONUS> i never understood nesting function composition like that
13:01:08 <Deewiant> the one time I get karma and then the bot's not here :-P
13:01:10 <byorgey> @bot
13:01:11 <BONUS> probably because i never wanted to
13:01:11 <noBotE> :)
13:01:14 <byorgey> huzzah!
13:01:17 <byorgey> newsham++
13:01:27 <Deewiant> @@ @pl @src replicateM
13:01:28 <noBotE>  (line 1, column 1):
13:01:28 <noBotE> unexpected end of input
13:01:28 <noBotE> expecting white space, "()", natural, identifier, lambda abstraction or expression
13:01:31 <Deewiant> bah
13:01:34 <newsham> :(
13:01:50 <newsham> ?pl \a -> a + 1
13:01:50 <noBotE> (1 +)
13:01:55 <newsham> ?src replicateM
13:01:55 <noBotE> replicateM n x = sequence (replicate n x)
13:01:57 <Deewiant> lies
13:02:06 <Deewiant> ?pl (+ 1)
13:02:06 <noBotE> (1 +)
13:02:11 <Deewiant> lies
13:02:16 <newsham> ?djin a -> a
13:02:16 <noBotE> Maybe you meant: djinn djinn-add djinn-clr djinn-del djinn-env djinn-names djinn-ver
13:02:20 <newsham> ?djinn a -> a
13:02:21 <noBotE> Plugin `djinn' failed with: Prelude.tail: empty list
13:02:24 <newsham> my djinn is broken
13:02:27 <vinicius> requesting rename of pl to mul (mostly ugly lambda)
13:02:39 <SamB> Deewiant: PL is assuming that the (+) operator forms commutative monoid
13:02:51 <EvilTerran> vinicius, nah, that'd have to pass it through my fmapper a few times, too
13:02:59 <Deewiant> SamB: yes
13:03:02 <jamii> ((sequence .) . replicate) n act => sequence . (replicate n) act => sequence (replicate n act)
13:03:04 <Deewiant> hence, "lies". :-P
13:03:22 <SamB> Deewiant: that's largely accepted to be implied by defining a "Num" instance...
13:03:34 <EvilTerran> (sequence .) . replicate = fmap (fmap sequence) replicate = (fmap.fmap) sequence replicate = fmap fmap fmap sequence replicate
13:03:34 <newsham> ?pl \a -> a ** 2
13:03:34 <noBotE> (** 2)
13:03:37 <Deewiant> ?pl (* 2)
13:03:37 <noBotE> (2 *)
13:03:44 <EvilTerran> :D
13:03:50 <Deewiant> now, if we have a Num instance of Matrix where that doesn't apply... ;-)
13:04:05 <SamB> of course, such an assumption is not correct for Float or Double
13:04:13 <SamB> but then neither are most of the assumptions we ever make
13:04:29 <Dae_> Well, Matrix should never be instance of Num. I know this because I have written a matrix lib where it is instance of Num
13:04:39 <Baughn> > let x=[1..] in (last x,head x) -- Memory overuse now plugged
13:04:41 <Cheiron>  (
13:04:46 <Dae_> Or rather, Num is not as generally defined as one might like
13:04:56 <noBotE>  thread killed
13:05:04 <SamB> @let forkbomb n = forkbomb (2*n) `par` forkbomb (2*n+1)
13:05:05 <Cheiron> Defined.
13:05:10 <noBotE> Defined.
13:05:11 <SamB> > forkbomb 1
13:05:13 <Cheiron>  Heap exhausted;
13:05:13 <Cheiron> Current maximum heap size is 64000000 bytes (61 Mb);
13:05:13 <Cheiron> use `+R...
13:05:19 <noBotE>  Exception: Time limit exceeded
13:05:26 <SamB> > forkbomb 20
13:05:27 <Cheiron>  Heap exhausted;
13:05:27 * jamii cant type
13:05:27 <Cheiron> Current maximum heap size is 64000000 bytes (61 Mb);
13:05:27 <Cheiron> use `+R...
13:05:33 <noBotE>  Exception: Time limit exceeded
13:05:46 <SamB> newsham: you have too much RAM to forkbomb
13:05:54 <Dae_> until (false) (forkbomb 20)
13:06:07 <SamB> :t forkbomb
13:06:09 <noBotE> forall t a. (Num t) => t -> a
13:06:21 <SamB> does anyone have any two-lambdabot spam exploits?
13:06:24 <Dae_> > until (false) (forkbomb 20)
13:06:25 <Cheiron>   Not in scope: `false'
13:06:25 <noBotE>   Not in scope: `false'
13:06:30 <SamB> this is an excellent time to try them out
13:06:33 <Dae_> > until (False) (forkbomb 20)
13:06:34 <Cheiron>  Couldn't match expected type `a -> Bool'
13:06:34 <noBotE>  Couldn't match expected type `a -> Bool'
13:06:38 <newsham> did djinn binary get separated from lbot repository?
13:06:55 <newsham> i think so
13:07:20 <SamB> Baughn: why doesn't Cheiron answer my :t ?
13:07:25 <SamB> @type forkbomb
13:07:26 <Cheiron> Plugin `type' failed with: invalid ghci output: no type signature
13:07:27 <noBotE> forall t a. (Num t) => t -> a
13:08:06 <mauke> @where @where
13:08:06 <noBotE> I know nothing about @where.
13:08:06 <byorgey> SamB: I'm not aware of any, since generally \bot only accepts commands that start in the leftmost column, and prints all output with one space at the beginning
13:08:07 <Cheiron> I know nothing about @where.
13:08:26 <Baughn> SamB: Cheirn has a slightly different setup from LB. Use @type.
13:08:29 <newsham> hrmm.. should I keep nobote in here or will cheiron be in here?
13:08:41 <mauke> @bot
13:08:51 <vinicius> :)
13:08:52 <SamB> byorgey: I seem to recall seeing someone manage to get output starting in the left column in the last month or so
13:08:59 <Baughn> newsham: It'll be.. back. Doh.
13:09:05 <byorgey> SamB: that's possible.
13:09:16 <newsham> baughn: so yes I should ?leave nobote?
13:09:19 <SamB> I mean, potentially loopable
13:09:25 <Baughn> > let x=[1..] in (last x,head x)
13:09:27 <Cheiron>  (
13:09:30 <byorgey> > var "foo"
13:09:31 <Cheiron>  foo
13:09:32 <noBotE>  foo
13:09:37 <mauke> @where xmonad
13:09:37 <Cheiron> http://xmonad.org/
13:09:39 <SamB> newsham: you could have it stay in case it could be used to test feedback exploits
13:09:39 <Baughn> > forkbomb 20
13:09:41 <mauke> excellent
13:09:41 <Cheiron>  Heap exhausted;
13:09:41 <Cheiron> Current maximum heap size is 64000000 bytes (61 Mb);
13:09:41 <Cheiron> use `+R...
13:09:46 <vinicius> > "> \"foo\""
13:09:47 <newsham> samb: you can loop with ?fact
13:09:47 <Cheiron>  "> \"foo\""
13:09:51 <byorgey> > var "\bfoo"
13:09:52 <Cheiron>  foo
13:09:59 <byorgey> darn =)
13:10:04 <mauke> @where+ @where @where @where
13:10:05 <Cheiron> Done.
13:10:05 <newsham> ?fact-set ?fact ?fact
13:10:05 <Cheiron> Fact recorded.
13:10:08 <newsham> ?fact ?fact
13:10:08 <Cheiron> ?fact: ?fact
13:10:11 <vixey> @seen glguy
13:10:11 <mauke> @where @where
13:10:11 <Cheiron> Unknown command, try @list
13:10:11 <Cheiron>  @where @where
13:10:15 <mauke> :-(
13:10:21 <vixey> ?where ?where
13:10:22 <Cheiron> ?where ?where
13:10:27 <newsham> ?fact-set ?fact: ?fact:
13:10:27 <Cheiron> Fact recorded.
13:10:31 <newsham> ?fact ?fact:
13:10:31 <Cheiron> ?fact:: ?fact:
13:10:38 <newsham> err.. you get the idea
13:11:24 * SamB likes vixey's hole
13:11:36 <vinicius> wut
13:11:39 <SamB> apparantly lambdabot is filtering for @ explicitly
13:12:03 <Baughn> SamB: Somewhere. *Somewhere*. Trying to set it to another value has only partial effect, but I can't figure out why.
13:12:11 <newsham> ?seen gwern
13:12:12 <Cheiron> Unknown command, try @list
13:12:16 <Baughn> > forkbomb 20 -- Now with user-friendly error messages
13:12:18 <Cheiron>  Tried to use too much memory
13:12:29 <Baughn> newsham: Also, seen leaks. I disabled it.
13:12:32 <newsham> ?djinn a -> a
13:12:32 <Cheiron> Plugin `djinn' failed with: Prelude.tail: empty list
13:12:44 <newsham> do you know where to find djinn now that its not in lbot srcs?
13:12:49 <newsham> where is gwern?
13:12:49 <vinicius> > forkbomb 1
13:12:51 <Cheiron>  Tried to use too much memory
13:13:01 <vinicius> Just in case =P
13:13:10 <ddarius> > var "foo\n@quote"
13:13:11 <Cheiron>  foo
13:13:11 <Cheiron>  @quote
13:13:13 <SamB> http://www.augustsson.net/Darcs/Djinn/
13:13:20 <ddarius> They fixed that.
13:13:20 <SamB> fourth google hit for "djinn"
13:13:44 <SamB> considering that that means something else, I think that's pretty good
13:15:03 <Baughn> Cale: Patch to limit runplugs' heap size at http://brage.info/~svein/cale
13:15:15 <kryptiskt> google gives a nerd bonus or something, try 'oleg' in google and yahoo...
13:16:27 <jamii> I think if you're logged into google it personalises your search?
13:16:31 <kryptiskt> oops, seems like yahoo has understood the greatness of oleg too
13:16:47 <Baughn> jamii: If you allow cookies it personalizes your search
13:17:06 <jamii> If I google ltu then lambda the ultimate comes up first. Thats not normal
13:18:26 <Baughn> jamii: Came up second for me. But click on it once, and.. yep, next search it came up first
13:20:54 <Baughn> @leave #haskell
13:21:01 <lambdabot> Not enough privileges
13:23:46 <SamB> http://www.google.com/support/accounts/bin/answer.py?answer=54048&topic=14153
13:23:47 <lambdabot> Title: Personalized Search Results : Turning off personalization - Google Accounts Help, http://tinyurl.com/5744vf
13:24:33 <SamB> in retrospect, it's a fairly obvious solution ...
13:24:49 <SamB> but you'd think there ought to be an option which would work even if you didn't log out
13:24:58 <SamB> (what if you wanted to keep gmail open?)
13:25:53 <Baughn> Use a separate browser profile?
13:26:40 <SamB> well also you might want it to save the history but just prefer to see the same search results as everyone else...
13:26:54 <nus> SamB, there's some cookie switcher extension for FF.
13:28:48 <chessguy> @bot
13:28:48 <lambdabot> :)
13:30:01 <vinicius> :) -- human bot at service
13:30:34 <Baughn> > lifeMeaning life
13:30:35 <lambdabot>   Not in scope: `life'
13:30:47 <Spark> > 42
13:30:48 <lambdabot>  42
13:30:50 <vinicius> 42
13:31:03 <Baughn> vinicius: Only in base 13
13:31:14 <vinicius> heh
13:31:15 <jamii> SamB: I have the same google account everywhere. So I always see the same search results
13:31:28 <SamB> even logged out, I still get it as result #4
13:31:48 <jamii> SamB: log out and delete the cookies?
13:32:04 <jamii> ctrl-alt-backspace in ff
13:32:05 <SamB> jamii: are you claiming that the help page was wrong?
13:32:21 <Baughn> SamB: We *know* it's wrong
13:32:37 <Baughn> Oh, sure your account will override the cookie-induced anonymous account settings
13:32:46 <jamii> SamB: But I know that ltu still comes up 1st when Im logged out
13:33:02 <vinicius> jamii: that's so wrong (not that someone would fall for it)
13:33:19 <SamB> @google ltu
13:33:20 <lambdabot> http://www.ltu.edu/
13:33:20 <lambdabot> Title: Lawrence Technological University
13:33:26 <Baughn> jamii: I pressed ctrl-alt-backspace, but nothing happened. Now what?
13:33:41 <vinicius> Baughn: use a better OS ;)
13:33:58 <Baughn> vinicius: I'd like to. :/
13:34:04 <SamB> Baughn: congrats on setting X up not to quit when you do that
13:34:09 <mapreduce> I used ctrl-alt-backspace on an asus eee in a shop and it worked, but I still couldn't find a shell.
13:34:13 <Baughn> SamB: Quartz, and it didn't take a lot
13:34:34 <SamB> why would quartz quit when you do that?
13:34:40 <Baughn> It wouldn't
13:35:35 <jamii> correction - ctrl-shift-del deletes cookies in firefox.
13:35:45 <jamii> And thank god for autosave
13:36:00 <jamii> I was wondering vinivius was complaining about...
13:36:09 <jamii> *vincius
13:36:26 <vinicius> heh
13:36:27 * jamii ran out of coffee :-(
13:37:18 <SamB> jamii: use extract in the coffee comonad
13:37:35 <Baughn> jamii: "Del"?
13:38:02 <Baughn> jamii: Oh, you mean shift-backspace. (Wait..)
13:38:05 <jamii> import Coffee
13:38:07 <jamii> Nooooo
13:38:14 <SamB> I deleted all the cookes
13:38:20 <jamii> I definitely meant del
13:38:23 <SamB> I still geg djinn in number 4
13:38:34 <Baughn> My keyboard lacks del. I mapped it to shift-backspace, just to have one, but..
13:38:55 <SamB> Baughn: you have a silly laptop eh?
13:39:25 <jamii> Baughn: ctrl-shift-del => ctrl-shift-shift-backspace? I spy a problem
13:39:38 <SamB> jamii: only an emacs user could type that
13:39:43 <jamii> SamB: Ok. Maybe djinn really is properly
13:39:43 <Baughn> SamB: Under the assumption that a good.. software engineer? Urk. Should be familiar with at least two of the three major OSs
13:39:54 <Baughn> I plan to avoid windows like the plague
13:40:05 <roconnor> OS/2 and Plan 9 ?
13:40:06 <jamii> ?
13:40:13 <jamii> s/properly/popular
13:40:22 <SamB> roconnor: what three major OSes do you believe in?
13:40:26 <jamii> import qualified Coffee as Fast.As.Possible
13:40:37 <roconnor> OS/2, Plan 9, BeOS
13:40:40 <SamB> jamii: do you know what the joke is?
13:40:50 <kryptiskt> SamB FreeBSD, NetBSD and OpenBSD
13:40:51 <_zenon_> @bot
13:40:51 <lambdabot> :)
13:41:00 <SamB> it's based on misreading Cofree as Coffee
13:41:05 <_zenon_> Yey!! \x-bot is on :)
13:41:06 <ziman> lambdabot, hello
13:41:09 <Baughn> roconnor: UNIX and UNIVAC
13:41:20 <roconnor> I know UNIX!
13:41:23 <SamB> UNIVAC is not an OS
13:41:25 <jamii> SamB: It should be illegal to explain jokes. Its like torturing a puppy
13:41:26 <SamB> is it?
13:41:29 <kryptiskt> kidding I use Vista and Ubuntu, I'm as mainstream as they come.
13:41:35 <Baughn> SamB: Not "is", no
13:41:41 <_zenon_> http://magic.falseblue.com/gallery/thumbs/1215102945.png
13:41:45 <_zenon_> in case you missed it
13:41:50 <Baughn> SamB: And, okay, no. Not an os. Not that anyone really cares.
13:41:53 <_zenon_> Last time I post it today
13:42:09 <SamB> jamii: so ever since I saw a blog post about it, which since disappeared, now I misread Cofree Comonad as Coffee Comonad
13:42:22 * Baughn notes that downloading half-gig files over gprs takes Way Too Long
13:42:30 <roconnor> _zenon_: why is it so small?
13:42:35 <jamii> _zenon_: Its too small. My compsci eyes cant see it
13:42:52 <_zenon_> ow... will fix that
13:42:58 <kryptiskt> Baughn: if you pass a border, that could be some truly epic roaming charges
13:43:08 <_zenon_> http://magic.falseblue.com/output/1215102945.png
13:43:15 <_zenon_> there we go, I think
13:43:24 <Baughn> kryptiskt: Meh. I'm on an unlimited plan.
13:43:39 <_zenon_> roconnor: fixed
13:43:42 <_zenon_> jamii : fixed
13:43:48 <Baughn> ..though yes, the only thing more expensive than gprs is sms
13:43:56 <stepcut> heh
13:44:30 <SamB> that costs me about 0.3*25 cents per message
13:44:53 <Baughn> What's that per MB?
13:45:11 <_zenon_> "epic roaming charges "  heheh
13:45:16 <SamB> I don't send MB worth of messages
13:45:25 <Baughn> Imagine you did
13:45:27 <SamB> my phone can only hold like 10 or 20
13:45:34 <jamii> ouch
13:45:40 <Baughn> IP over SMS!
13:45:42 <SamB> it's a $15 phone
13:45:56 <kryptiskt> Baughn: I have an unlimited plan, that costs me 15 euro/MB if I go to Germany. Europe sucks for mobile data if you travel.
13:45:57 <roconnor> _zenon_: the aspect ratio of the logo isn't preseved. ... and I can see the pixels :P
13:45:59 * Baughn feels buirgoise for simply /considering/ an iphone
13:46:02 <jamii> Ive been eyeing up an openmoko
13:46:09 <jamii> Does haskell run on arm?
13:46:14 <Baughn> Yes
13:46:18 <dmhouse> kryptiskt: aren't the prices for that coming down though?
13:46:20 <_zenon_> roconnor: yeah, I am no graphics engineer :P
13:46:23 <Baughn> Well, it runs on posix, pretty much. POrting is simple
13:46:31 <SamB> _zenon_: designer, they call them
13:46:32 <Baughn> jamii: But arm is one thing. Does the phone support posix?
13:46:33 <SamB> not engineer
13:46:37 <jamii> Excellent. Lambdabot on legs
13:46:44 <kryptiskt> dmhouse: not far enough for data
13:46:47 <jamii> Baughn: It runs linux
13:46:49 <_zenon_> Okay, it was for fun :)
13:46:57 <Baughn> jamii: Ah. That's a "no", then.
13:47:07 <SamB> Baughn: huh?
13:47:13 <roconnor> _zenon_: :)
13:47:13 <SamB> phone linux not posixy enough?
13:47:18 <stepcut> jamii: hugs and jhc do, but GHC does not yet -- though there is a bunch of interest on the mailings lists on porting GHC to ARM
13:47:19 <_zenon_> but was it fun?
13:47:23 <Baughn> Linux not posixy enough
13:47:28 <Baughn> It should be plenty for ghc, though
13:47:31 <_zenon_> Did it give you the hint of a smile?
13:47:38 <dmhouse> kryptiskt: there's been some recent legislation, can't remember whether it was European or just British, though.
13:48:14 <SamB> Baughn: it's more posixy than anything ELSE -- that is, there's not really another adjective that describes it better, besides linuxy or buggy...
13:48:27 <jamii> stepcut: Any idea how much effort it would take?
13:48:31 <kryptiskt> dmhouse: It was european, but it doesn't help heavy users, really
13:48:43 <stepcut> jamii: yes -- as I have tried it myself ;)
13:48:57 <stepcut> jamii: it should be easier now that GHC uses libffi
13:49:02 <Baughn> SamB: I'm torn. Which is worse, buggy deviations from posix, or deliberate deviations from posix?
13:49:13 <Baughn> Linux has too many of the latter for my taste. :/
13:49:20 <kryptiskt> GHC on ARM would be great, I could use it at work
13:49:21 <_zenon_> Annyone else thought about  monad transformers in the sense that.... how would such a robot look?
13:49:27 <_zenon_> A Monad Transformer :)
13:49:31 <SamB> Baughn: is there a list?
13:49:46 <Baughn> SamB: I can't deny it
13:49:50 <kryptiskt> GHC for ARM, I don't expect to compile on my phone :-)
13:49:55 <SamB> @quote comment
13:49:55 <lambdabot> blackdog says: I'm not encouraged by the comment "i don't know haskell, but CL is much better", though. it doesn't suggest careful thought and objectivity...
13:49:57 <SamB> @quote comment
13:49:57 <lambdabot> SamB_XP says: I once saw it eat a comment (:[{- Help! -}])
13:50:01 <Baughn> _zenon_: Like a nanofactory?
13:50:22 <Baughn> Hm, probably more like a teapot whistle attachments
13:50:22 <Liempt> @quote ping
13:50:22 <lambdabot> HP says: [sweeping statements day] There's no point in running a program in 1024 threads, if the single-core C# version runs faster than that, and often it does!
13:50:24 <_zenon_> Baughn: Hmm.. not a bad idea! Maybe I will try to cook something up :)
13:50:29 <SamB> that's actually the return function for lists ;-)
13:50:37 <Liempt> @quote ping
13:50:37 <lambdabot> geezusfreeek says: i was half hoping lambdabot would lie and make something up :)
13:50:41 <dmhouse> SamB: hehe.
13:50:48 <stepcut> jamii: it's not a lot of work, just very picky low-level work
13:51:11 <stepcut> jamii: and, since you have to either compile on a real ARM, or use qemu to emulate an ARM, the compile times can be pretty long
13:51:33 <stepcut> jamii: however, the recently switch to using libffi and the stripped down GHC base libs should help with both of those problems
13:51:34 <Baughn> jamii: Well, you could buy a fast ARM
13:51:34 <jamii> stepcut: Hmmm. I have a stange craving for lambabot powered robots
13:51:36 * Dae_ wishes his arm could compile haskell too....
13:52:00 <stepcut> jamii: I would say, a week maybe ? (with lots of waiting around time)
13:52:41 <stepcut> assuming you had an ARM development environment already setup (I used maemo for the nokia 770 internet tablet)
13:52:44 <_zenon_> Nah, I give up
13:52:51 <_zenon_> No idea for a monad transformer
13:53:03 <jamii> I suspect I dont know enough to attempt it. Would be a shame to be reduced to python though
13:53:42 <jamii> A galois party?
13:53:45 <_zenon_> instance Monad Transformer where
13:53:57 <stepcut> there are also a few parts to the GHC port, one is the processor (ARM) and the other is the OS (Linux, etc)
13:54:10 <SamB> dons: are you guys smoking?
13:54:26 <stepcut> there is interest in the ARM for the Nokia internet tables, the iPhone (and other phones), the Nintendo DS, and probably more
13:54:34 <jamii> stepcut: The phone runs linux mostly unmodified. That bit should be easy at least
13:55:01 <nus> @hoogle Limonad
13:55:01 <lambdabot> No matches found
13:55:26 <nus> therp, that's better name (-;
13:55:49 <stepcut> in the old process, you had to modify a perl script (the evil mangler) which used regular expressions to strip code out of the assembly output of gcc -S :) I blieve libffi fixes that ;)
13:56:32 <Dae_> stepcut: An iPhone running ghc? That would be awesome, in a Kylie Minque playing D&D kinda way
13:56:37 <SamB> stepcut: why wasn't it already modified?
13:56:40 <stepcut> also, it depends if you want to use GHC via C, or if you want to use native asm genertaion. Native asm is a bit more work
13:57:03 <stepcut> SamB: because the expression are architecture specific
13:57:21 <jamii> Dae_: Have you seen openmoko?
13:57:22 <Baughn> But isn't the via-c approach also faster, so far? -_-
13:57:25 <stepcut> SamB: it was code for striping out some pointless stack checks and frame handling stuff
13:57:26 <SamB> stepcut: so why didn't the necessary additions get committed to the repository?
13:57:43 <SamB> there's already an assload of arch-specific code in there
13:58:00 <stepcut> Baughn: not really. Sometimes yes, sometimes no. The compiles times with -via-C are about twice as long though
13:58:18 <stepcut> SamB: because no one has ported to the ARM yet
13:58:25 <Baughn> Does the iphone run arm?
13:58:55 <Baughn> ..so it does. Hm, haskell should work fine
13:58:59 <Dae_> jamii: Nope, not really. I don't have an iPhone....
13:59:05 <stepcut> Baughn: yes. Pretty much every cell phone in the world does.
13:59:10 <jamii> Dae_: www.openmoko.com
13:59:28 <jamii> Like an foss iphone
13:59:34 <jamii> s/an/a
13:59:44 <stepcut> Baughn: in part, because there are lots of cell-phone specific libraries already written and optimized for ARM, so moving to anything other processor would be a giant effort
14:00:31 <Heffalump> ARM also offers good power/performance ratios across a whole range of performances
14:00:50 <Dae_> jamii: Looks sweet... but no G3? How can it not have G3??
14:00:51 <stepcut> right, the ARM is also just a good choice :)
14:00:53 <shepheb> stepcut: are you the original person who was working on the GHC-on-ARM project?
14:01:06 <stepcut> Dae_: 3G comes out July 11
14:01:07 <SamB> arm is cute
14:01:12 <stepcut> shepheb: yes, one of them
14:01:16 <Baughn> Dae_: Never Buy First Generation Apple Stuff
14:01:28 <stepcut> Baughn: agreed :)
14:01:32 <Baughn> Dae_: The lack of 3g is just a /small/ problem, as that sort of thing goes
14:01:40 * stepcut hopes iPhone 3G will support a bluetooth keyboard :(
14:01:46 <jamii> Dae
14:01:54 <jamii> bah
14:02:04 <shepheb> stepcut: I've got a Nokia N810 I'd like to run GHC on, there was some other interest in reviving the project later this year
14:02:08 <Dae_> Baughn: I ment the openmoko actually. I have a policy against support Mr. Jobs
14:02:18 * jamii not a mutitasker
14:02:31 <Dae_> *supporting
14:02:33 <stepcut> shepheb: yes -- though it appears that GHC 6.9 might already have the modifications needed to do it now
14:03:23 <shepheb> stepcut: indeed, but I'm not sure. most of those interested in the ARM project aren't very familiar with the GHC internals, not even enough to know if 6.9 has already settled that part.
14:03:42 <jamii> Dae:_ It has usb. Does that help make up for it?
14:04:08 <jamii> I think of it more as a small computer than a phone.
14:04:25 <stepcut> shepheb: yeah. The people who know the answer can be reached via email though and are probably happy to respond :)
14:05:33 <shepheb> stepcut: well, the big coup would be if dons or some other master had an ARM device and got interested. still, I think a registerized build is possible and worth the effort. any idea how heavy the RTS would end up being?
14:06:00 <Baughn> Dae_: But.. shiny..
14:06:02 <yitz> shepheb: I don't think you have to worry. ARM could be very important for the future of GHC, so I think the gurus will be very helpful and supportive.
14:06:28 <Dae_> jamii: It -is- very cool, I'll give you that
14:06:29 <jamii> Baughn: www.openmoko.com  :  Almost as shiny. And linux flavoured
14:06:40 <Japsu> BUT NO 3G!!!
14:06:42 <Japsu> ;<
14:06:47 <slam28> yitz is it ok if i give you a ring? or will i be waking the ppl up
14:06:49 <jamii> Dae_: It -is- most of my wages for the month
14:06:49 <stepcut> shepheb: no, but if you compile and run a simple hello world app on linux, it is less than 1MB of resident memory
14:07:01 <jamii> Dae_: And yet...
14:07:12 * Heffalump wants a Chumby
14:07:34 <Dae_> Baughn: Iphones are bad. God kills a kitten everytime a person buys an iphone.
14:07:40 * stepcut knows a chumby founder
14:07:45 <Dae_> jamii: is it that expensive? bugger...
14:08:16 <stepcut> (duane maxwell)
14:08:20 <shepheb> is there a better mailing list (wiki? a single page of the GHC wiki is kind of constricted) to take ongoing discussion of the project to? ghc-something?
14:08:26 <jamii> Dae_: No, Im that poorly paid. $400 from the store. $360 from some of the resellers
14:08:36 <tromp> i gave my wife a chumby on her bday
14:08:38 <Baughn> jamii: Okay, I'm confused. Can I actually /get/ an openmoko?
14:08:52 <Dae_> Baughn: Yes.
14:09:00 <Dae_> jamii: Bummer
14:09:08 <Heffalump> they don't ship outside the US though
14:09:18 <stepcut> :-(
14:09:20 <Baughn> That's "n", then
14:09:29 <Baughn> (Plus, I don't see gps. I want gps.)
14:09:30 <jamii> Baughn: The commercial edition was released about 4 days ago and is currently sold out. They dont ship outside the us but they do have resellers in germany and italy who will have stock soon
14:09:35 <jamii> It does have gps
14:10:20 <jamii> The wiki has better information : http://www.openmoko.org/wiki/FreeRunner_Overview
14:10:22 <lambdabot> Title: FreeRunner Overview - Openmoko
14:10:31 <SamB> what is commercial about it?
14:10:37 <Dae_> Why on earth are they not shipping outside us? I never got why companies don't do that. It seems silly
14:10:56 <Dae_> SamB: You have to pay for it?
14:11:07 <Heffalump> they probably don't want to be exposed to regulatory problems in other countries when they move in there for real
14:11:08 <jamii> SamB: The first version was effectively a hardware alpha and was marketed to developers. This one actually works
14:11:18 <SamB> ah
14:11:23 <SamB> Dae_: that can't be it
14:11:33 <SamB> Dae_: you nearly ALWAYS have to pay for hardware
14:11:37 <jamii> Dae_: They dont sell outside the us themselves. They sell in bulk to resellers who are listed somewhere on the wiki
14:11:54 <Baughn> jamii: GPS check. Headphones? Battery life? 3G?
14:12:08 <SamB> it's perfectly reasonable not to want to individually ship units overseas
14:12:15 <Dae_> SamB: Clearly you have never robbed the local computerstore
14:12:20 <SamB> but that doesn't explain canada...
14:12:22 <jamii> gps, headphones, battery life is discussed on the mailing list (will hunt down a link shortly), no 3g unfortunately
14:12:23 <Dae_> SamB: Why?
14:12:34 <SamB> Dae_: hmm?
14:12:41 <Baughn> jamii: ..why isn't this info on wikipedia?
14:12:48 <SamB> because it's more hassle than shipping locally?
14:12:55 <Heffalump> SamB: can anything explain Canada?
14:12:59 <Dae_> Why is it more hastle?
14:13:01 <jamii> Baughn: No idea
14:13:05 <Dae_> *hassle
14:13:18 <SamB> Dae_: than shipping a large shipment to a reseller?
14:13:29 <shepheb> stepcut: in addition to 6.10, two of the interested devs (one of them me) are short on time for the next 45-ish days.
14:13:49 <SamB> Dae_: why do you need a passport to go anywhere?
14:13:51 <jamii> Baughn: Be aware they have the original prototype (1973) and the new version (freerunner). I dont think the first had gps
14:14:21 <Dae_> SamB: Look, they have a shipping department for the US. They now get that shipping department to put their international packages to a trusted postal firm, and off they go. No hassle anywhere?
14:14:27 <SamB> and I thought 1984 was a strange name
14:14:32 <araujo> SamB, because politicians need to justify their salary
14:14:36 <Baughn> jamii: Okay. It looks like an interesting platform, and I'd love to play with it
14:14:38 <lament> another phone with no buttons?..
14:14:48 <SamB> araujo: tell that to Dae_
14:14:56 <Baughn> jamii: But /for the momment/ the iphone seems like a better match. Kitties or no kitties.
14:15:05 * Baughn just wants the thing to work
14:15:10 <araujo> Dae_, , because politicians need to justify their salary
14:15:12 <SamB> Baughn: where are the kitties
14:15:21 <Baughn> SamB: There aren't any. I killed them all.
14:15:45 <Dae_> Baughn: God removes a pair of boobs everytime someone installs itunes... it's very sad.
14:15:54 <jamii> Baughn: Fair enough. Im more interested in using it for my own software. Not too fussed about using it as a phone. I guess it depends what you want from it. The software certainly isnt battlehardened yet
14:16:09 <Baughn> jamii: I want fewer devices in my jacket. ;)
14:16:19 <Baughn> GPS, phone, ipod... I'm suffering here.
14:16:24 <jamii> Baughn: Implants?
14:16:38 * Baughn cites health risks
14:16:45 <Dae_> jamii: for the boobs?
14:17:00 <jamii> Dae_: Ipod boobs? I think we have a business plan
14:17:10 <SamB> Baughn: but ... http://arcanux.org/lambdacats.html
14:17:10 <lambdabot> Title: Lambdacats
14:17:18 <jamii> Baughn: Weigh up the alternatives: Health OR Ipod boobs
14:17:33 <araujo> isn't that IBoobs?
14:17:46 <Baughn> jamii: Being male, I'll take the health.
14:18:01 <SamB> jamii: ipod boobs?
14:18:06 <jamii> Baughn: Fool
14:18:15 <Dae_> jamii: Indeed! We shall conquer the world with boobs of ipodness!
14:18:30 * araujo would like a lambda phone
14:18:30 <jamii> SamB: The solution to having too many electronic devices in your pocket and having too few boobs in the world
14:18:57 <SamB> oh ... kay ...
14:19:07 <jamii> araujo: Ask stepcut really nicely?
14:19:21 <BMeph> No, no - iBoobs, natch. ;)
14:23:18 <BMeph> Personally, I find it interesting how it seems that the most popular cell phones are the ones that you can use all day, but not as a phone. It seems like there's a Lesson to be Learned there... :)
14:23:47 <lament> the iphone is called a 'phone' by convention, but of course it's not a phone
14:24:01 <Dae_> BMeph: Well, iPhone isnt the most popular phone. It's the most talked about
14:24:20 <quicksilver> it's the most popular single model.
14:24:25 <quicksilver> which is cheating, in a way
14:24:31 <quicksilver> because all its competitors have multiple models.
14:24:37 <Dae_> quicksilver: Really? I thought that was a nokia?
14:24:40 <quicksilver> but, still, it's quite a long way to have come in a short time.
14:24:47 <hpaste>  morrow pasted "(no title)" at http://hpaste.org/8687
14:24:50 <quicksilver> most popular single model of smartphone, that is.
14:24:51 <lament> i wonder what terminology will prevail
14:25:06 <lament> it's very likely that in 50 years, people will say "phone" to mean the only kind of computer they know
14:25:09 <Dae_> quicksilver: Aaaahh... that's a bit of a difference.
14:25:12 <quicksilver> or lambda.
14:25:22 <BMeph> Dae_: I didn't mean the iPhone in particular, although it does fit the trend in general. :)
14:26:23 <lament> they should have called the iPhone the iCamera, since it can take pictures! Yeah.
14:26:36 * BMeph is happy to be acquainted with many lambdas...
14:26:44 <shepheb> asking again, is there a mailing list we should take ongoing discussion of GHC-on-ARM to without spamming haskell-cafe?
14:26:48 <Dae_> BMeph: People still mainly user thier cellphones for text-messages and phones?
14:26:54 <Dae_> *phoning
14:27:19 <kryptiskt> shepheb: it's possible to spam haskell-cafe?
14:27:22 <Dae_> lament: Well, it does make a better substitute for a phone than it does for a camera
14:27:31 <lament> Dae_: i suppose...
14:27:34 <stepcut> shepheb: not yet
14:27:38 * araujo doesn't like cell-phones 
14:27:40 * shepheb mostly uses his phone as a pocketwatch, actually
14:27:42 <lament> i don't mind the terminology, "phone" is as good a word as any
14:27:58 <lament> i just enjoy observing how words and ideas evolve
14:28:01 <lament> we truly live in interesting times :)
14:28:05 <araujo> though I have recently been in need of one .. just trying to look for a good geeky one :-]
14:28:15 <araujo> But I have like 5 years without cell-phone
14:28:28 <kryptiskt> Nokia has pushed hard for discarding the term "phone" for a couple of years now
14:28:31 <quicksilver> shepheb: you might argue that glasgow-haskell-users is more appropriate
14:28:36 <Baughn> "Phone''s just "sound". For something I intend to use primarily as an ipod, it works well
14:28:38 * araujo got fed up with cell-phones in the 90's
14:28:40 <quicksilver> shepheb: considering it's GHC-specific not haskell general.
14:28:48 <quicksilver> shepheb: I don't think you'll find people get very upset either way.
14:28:51 <araujo> Sometimes I got 5~6hrs. per day talking by cell-phone
14:28:57 <araujo> I don't want to touch one anymore
14:28:58 <Dae_> araujo: doesn't get nerdier than this http://en.wikipedia.org/wiki/Image:Mobira_Cityman_200.jpg
14:29:14 <araujo> Sadly, I am needing one
14:29:15 <lament> kryptiskt: no reason to discard it
14:29:16 <araujo> LEt's check
14:29:17 <BMeph> My buddy at work, when we go out to test at our remote location, uses his phone to watch videos and listen to music. Every now and then, he does get a call in the four-hour period we're out there, though. :)
14:29:28 <lament> kryptiskt: what is happening is evolution, not branching
14:29:39 <jamii> I suspect that if I could run basKet on my phone I would use that more than the actual phone
14:29:46 <kryptiskt> lament: they want to use "terminal" which is very prosaic
14:29:47 <lament> kryptiskt: just like birds are still dinosaurs, modern phones are still phones
14:30:28 <lament> but the word now means something different than it used to
14:30:57 <lament> and i suspect that in the future, "phone" will come to mean "computer"
14:31:00 <BMeph> quicksilver, shepheb: Why not ghc-devel... oh, wait, you're talking mailing lists. Never mind. :)
14:31:01 <lament> as the two merge
14:32:43 <araujo> Dae_, http://en.wikipedia.org/wiki/Image:Nokia6020.jpg
14:32:46 <araujo> best phone ever
14:33:14 <jamii> Thats not a cellphone, its a monster
14:33:32 <lament> it's certainly better than the iphone at, you know, phoning people
14:33:37 <Dae_> araujo: What does it eat?
14:33:40 <araujo> lament, by far
14:33:44 * EvilTerran likes his 6820
14:33:57 <lament> i have a nokia which i love, but don't know the model name :(
14:34:07 <araujo> I throw that phone at competition for actually making calls to any moder phone out there
14:34:12 <EvilTerran> it's got a fold-out qwerty keyboard. a remarkably chunky one, too, owing to the mechanism
14:34:13 <quicksilver> I had, essentially, one of those but under the UK branding 'Nokia Orange 5.1'
14:34:16 <quicksilver> or something.
14:34:43 <lament> this is the one i have: http://i17.photobucket.com/albums/b94/ladyarcher85/for%20my%20blog/nokia_3100_blau.jpg
14:34:44 <lambdabot> http://tinyurl.com/6cyply
14:34:57 <lament> 3100 i guess
14:35:03 <EvilTerran> http://www.trustedreviews.com/images/article/inline/1893-1.jpg <- 6822
14:35:06 <Dae_> araujo: well.. what are the qualities of it? I mean what actually makes it better at phoning people?
14:35:24 <lament> Dae_: than the iphone? For one, it has buttons!
14:35:28 <EvilTerran> http://www.welectronics.com/gsm/Nokia/nokia6822.jpg <- actually, this is probably a better pic. you can see how the mechanism works
14:36:30 <lament> EvilTerran: looks like it's faster to just type a typical SMS using predictive text and the numpad than opening that thing, typing and closing it :)
14:36:42 <EvilTerran> eh. i type long texts
14:36:58 <EvilTerran> i also use its calendar and whatnot
14:37:05 <araujo> Dae_, by that time, it was one of the first Digital phone in the market .. it also had cool battery lifetime and
14:37:15 <qebab> Man, Haskell is actually easy from time to time. This code wrote itself :)
14:37:34 <mwc> qebab: that's the feature that makes me love Haskell
14:37:35 <byorgey> qebab: congrats =)
14:37:45 <Dae_> araujo: at the time... but compared to new ones?
14:38:04 <BMeph> Best. Phone. EVAR! ;p
14:38:07 <qebab> mwc: I'm not quite there yet, but I'm getting better. I can see the attraction in the language very clearly now though
14:38:23 <araujo> Dae_, Also, check the antenna .. it was quite cool, when the rest of the phones had those thin and large ones, this one had practically none
14:38:43 <araujo> Dae_, The reception of the calls _was_ excellent
14:39:01 <araujo> Dae_, I still don't find a modern phone with such a quality
14:39:40 <araujo> In other words, the thing was explicitly designed for calling ... not like today phones, they doo all great, except calls
14:39:56 <qebab> I sort of agree really
14:40:03 <qebab> I mean, my phone can do a gazillion things
14:40:08 <araujo> Dae_, I had it like 5 years, never ever had problems receiving or making calls
14:40:22 <araujo> Dae_, And used it in several countries too
14:40:23 <qebab> it can play music and take pictures, but I only need to call/send sms
14:40:25 <qebab> heh
14:41:25 <monochrom> In a sense this is like programming languages.
14:41:48 <monochrom> Java says "you can do more objects and more objects!"  Python says "you can do even more objects!"
14:42:10 <kig> hih, ported most of the nice utils in prelude to ocaml: http://pastie.org/227442
14:42:11 <lambdabot> Title: #227442 - Pastie
14:42:19 <monochrom> But you just want to write some pure functions and types, and you want a language that lets you write them damn well.
14:42:52 <qebab> Java really is in a league of its own. I mean, the documentation for the JS2E classes is nearly 300 MB. I was mortified when I had to use it in a university project, and found out the sheer size of the thing
14:42:59 <dons> cute, kig
14:43:24 <vixey> kig: It works for infinite lists?
14:43:27 <BMeph> Interesting, that no one's porting Ocaml's built-ins to Haskell... ;)
14:43:31 <araujo> qebab, hah, know the feeling
14:43:32 <kig> vixey: oh, no
14:43:36 <dons> kig: using pcre things is a bit weird for lists :)
14:43:53 <dons> vixey: strict languages :)
14:43:55 <mapreduce> qebab: It's quite easy to ignore most of Java.  I'm hoping to one day ignore all of it.
14:44:34 <Dae_> I heard someone was making a compiler for haskell to java bytecode....
14:44:35 <mmorrow> @src minimum
14:44:35 <lambdabot> minimum [] = undefined
14:44:35 <lambdabot> minimum xs = foldl1 min xs
14:44:45 <qebab> mapreduce: I ignore it when they can, but it is the only language that is mandatory to learn at uni, so I'm stuck using it every now and then for a few years still
14:44:57 <mapreduce> Dae_: There's CAL and lambdavm, which are both relevant in that space.
14:46:30 * araujo sometimes get in troubles at univ because of ignoring java 
14:46:30 <Dae_> qebab: I am told that most software firms are having trouble getting decent programmers because all the unis teach are java
14:46:30 <araujo> but they are worthy troubles
14:46:30 <araujo> :-P
14:46:30 <jamii> CAL also has cool record types
14:46:30 <jamii> But no monads ;-(
14:46:30 <araujo> yea Dae_
14:46:30 <araujo> And that has a perfect logical reason ...
14:46:30 <qebab> Dae_: I do not have a hard time believing that. Most of the people I've worked at projects with are pretty incompetent, except for on a select few special areas of OOP.
14:46:30 <araujo> java is one of the worse languages to teach programming
14:46:31 <mapreduce> jamii: Not even Maybe?
14:46:46 <shepheb> any GHC wizard around who knows if there's any changes in 6.9 or 6.10 that makes the Porting to a New Platform wiki page out of date?
14:46:51 <kryptiskt> Dae_: that's ok, most software firms are looking for mediocre java programmers
14:46:58 <dons> shepheb: nope
14:47:08 <mapreduce> Java should never be a first language.
14:47:11 <shepheb> dons: no there are no such changes, or no there are no wizards?
14:47:13 <qebab> Dae_: I mean, they can do some things well, because they learnt of some pattern or some such thing, but they can't invent things on their own as they go along, which is makes them pretty useless unless you tell them exactly what to do
14:47:16 <Dae_> araujo: I think it's great to teach programming to highlevel users (ie multimedia-guys). It's rubbish for teaching computer scientists
14:47:18 <araujo> mapreduce, I agree
14:47:20 <dons> shepheb: the former.
14:47:32 <mapreduce> I wonder what is missing from Haskell that would make it appropriate as a first language.
14:47:36 <araujo> Dae_, what mapreduce said ... not a good first language
14:47:39 <EvilTerran> Dae_, there are better things for the highlevel users too
14:47:43 <vixey> nothing
14:47:47 <dons> mapreduce: nothing? its a common first language.
14:47:51 <EvilTerran> we got haskell as a first language
14:47:51 <qebab> mapreduce: mainstream popularity (it's not enterprisey enough!!)
14:47:53 <shepheb> dons: ah, good, thanks. I'm considering doing a preliminary unregisterised ARM build tonight as a PoC
14:47:54 * dons had haskell as a first langauge
14:47:56 <Dae_> EvilTerran: Such as? Eiffel?
14:47:59 <EvilTerran> (comlab.ox.ac.uk)
14:47:59 <araujo> I think Haskell is perfect for first language mapreduce
14:48:00 <qebab> you lucky people
14:48:06 <EvilTerran> Dae_, well... haskell? :P
14:48:08 <dons> oxford teaches haskell as a first language, as does chalmers.
14:48:20 <qebab> is it common outside Britain?
14:48:21 <araujo> Just don't start with Monads and Arrows .. and your students will get it at first :-]
14:48:28 <qebab> as a first language, I mean
14:48:29 <mwc> dons: that's perfect, because I find it makes a great last language
14:48:30 <EvilTerran> Dae_, or python, ecmascript...
14:48:31 <dons> there's a bunch of books on haskell as a first language-- since it lays the foundation for most concepts
14:48:36 <dons> mwc: :)
14:48:51 <Dae_> EvilTerran: Come on... haskell is hard if you don't like maths to begin with
14:49:10 <monochrom> programming is hard. lets' do math.
14:49:16 <qebab> Python was my first language, and I have fewer brainblocks than most people, so I think it was a lucky choice :)
14:49:17 <araujo> Dae_, Not really ... Haskell is quite simple ... traditional math only
14:49:19 <mwc> not that Haskell doesn't need to evolve, it's just that looking at other languages makes me pull my hair and stomp on the ground yelling "You're doing it all wrong!"
14:49:40 <Dae_> araujo: but if what you need to make is a fancy gui.....
14:50:47 <araujo> I mean, Haskell can get 'obscure' at some concepts ... but basic concepts are just plain math you learn in school
14:50:47 <EvilTerran> Dae_, and the other two?
14:50:47 * cladhaire refers everyone to the public consultation on CC2001: http://wiki.acm.org/cs2001/index.php?title=SIGPLAN_Proposal
14:50:47 <lambdabot> Title: SIGPLAN Proposal - CS2001 Wiki
14:50:47 <EvilTerran> lua's nice, too
14:50:47 <cladhaire> Not that it gets into specific languages, but should be considered :P
14:50:47 <araujo> Dae_, check haskell.org/himerge
14:50:47 <araujo> :-]
14:50:47 <kryptiskt> haskell needs no more math than basic
14:50:47 <cladhaire> You could make a case for _any_ programming language as the first
14:50:47 <cladhaire> I know, I've done the lit review :P
14:50:47 <cladhaire> And none are inherently more difficult than any other
14:50:47 <Dae_> EvilTerran: Well, I dont know ecmascript, but if the first is your only language, and you need to use it in a professionel context...
14:50:47 <rumbleca> !c++ is a good first choice
14:50:48 * dons wants to know what math you need to be a haskell programmer
14:50:52 <cladhaire> dons: indeed!
14:51:00 <mar77a> none
14:51:02 <qebab> well... I think the problem is more that there are a lot of people who choose to never learn more than one language, and when that one language is Java :x
14:51:03 <EvilTerran> an intuitive grasp of abstract algebra
14:51:10 <mapreduce> dons: Reading the *excellent* Haskell wikibook, with its repeated mentions of ignoring scary compiler errors, I think at least the compiler errors need to be improved to make it an appropriate first language.
14:51:12 <EvilTerran> which most people have
14:51:26 <mar77a> psh
14:51:31 <mar77a> did you see the c++ std lib errors
14:51:41 <mar77a> CHAR TRAITS <>>>><<<<< line :348574 stl___char__.cpp
14:51:45 <mar77a> aJSJsjjsj188 asskkk <<<<<
14:51:49 <mapreduce> dons: Perhaps if you already come from a mathematical background you might have more of a clue as to those errors.
14:52:00 <Zao> mar77a: Humble compared to boost misuse.
14:52:08 <mar77a> heh yeah
14:52:10 <osfameron> haskell seems less receptive to brute force trial and error to get things done than other languages, dunno if that's an advantage or disadvantage as a first language
14:52:15 <mar77a> well, c++0x is supposed to address those
14:52:16 <mapreduce> mar77a: Better than shit /= good
14:52:16 <Zao> mar77a: I once got 480MB of error message from one broken line.
14:52:16 <araujo> cladhaire, I publicly state java is one of the worse languages to teach for a main reason , it is an hybrid language ... that implicit characteristic makes it ugly and confusing to teach programing
14:52:23 <qebab> I don't really find that you need to know much math to do programming in general, but chances are if you are good at math (in the being creative, and a clear thinker kind of way) you might have a more intuitive grasp of much programming
14:52:23 <Dae_> EvilTerran: In my experience most people don't have an intuitive grasp of abstract algebra.... I mean outside the natural science faculty
14:52:27 <mar77a> agreed, mapreduce
14:52:37 <vixey> java is fine, C is the problem
14:52:39 <cladhaire> araujo: that happens to be your opinion, and I've heard some excellent cases why it makes a good language.
14:52:44 * araujo read c++0x will have lambdas
14:52:50 <cladhaire> EvilTerran: I think stating you need abstract algebra is a bit of an overstatement.
14:52:58 <mapreduce> C is ok in its way, because it doesn't impose any ideals on you.
14:53:06 <cladhaire> I've successfully taught 10 years olds in 10 minutes recursive functions in haskell
14:53:09 <mapreduce> s/ideals/false ideals/
14:53:13 <EvilTerran> i don't mean knowing roughly what absalg is by name
14:53:13 <araujo> cladhaire, Not only an opinion .. but facts
14:53:20 <mmorrow> vixey: oh no you diint! :)
14:53:26 <Dae_> C is a good language because it gives you an idea of how things actually -work-
14:53:28 <cladhaire> araujo: and the other side has facts that speak to Java being a good started language
14:53:37 <EvilTerran> just understanding the whole string-substitution equational-reasoning idea
14:53:44 <EvilTerran> being able to apply it
14:53:48 <araujo> cladhaire, That's why you get a bunch of students confused and knowing no proper programing practices at the end ... it has a root
14:53:48 <cladhaire> Dae_: many would argue that you don't need that level of hardware detail and it takes away from what you're trying to teach the student
14:53:54 <mwc> Dae_: forth is better for that, I think
14:54:08 <cladhaire> araujo: You can teach well in ANY language
14:54:10 <cladhaire> that's a fact
14:54:19 <cladhaire> don't confuse the language that is being offered with the material offered in the course
14:54:21 <qebab> I think that knowing C is probably a good thing, but I don't see it as a good first language
14:54:23 <araujo> cladhaire, The answer I have received about java being a good language .. is .. 'help me to get a job' really
14:54:23 <cladhaire> there isn't a direct correlation
14:54:37 <cladhaire> araujo: then you're talking to the wrong people, and refer to my last statement
14:54:48 <mapreduce> cladhaire: The more that you need to see to understand a simple program the harder it is to teach and learn in that language.
14:54:54 <araujo> cladhaire, The first language is always important ... and can make a _huge_ difference for a student
14:54:55 <mar77a> i think learning about pointers while learning C was very important for me
14:55:01 <cladhaire> araujo: yes, I'm fully aware.
14:55:02 <BMeph> C has the worst compiler message, hands down:
14:55:05 <Dae_> cladhaire: I am sure many would. I would disagree, to some extent. It depends on who were to be taught
14:55:07 <mar77a> and i wouldn't have learned with any other high level languages i know
14:55:10 <BMeph> Segmentation fault (core dumped).
14:55:12 <qebab> mar77a: indeed :)
14:55:24 <mapreduce> cladhaire: class X { public static void main(String[] args) { System.out.println("Hello world"); } } is ridiculous as a first program.
14:55:26 <qebab> BMeph: that's not a compiler message, that's the operating system
14:55:32 <cladhaire> You guys are walking a path already thoroughly tread
14:55:34 <araujo> cladhaire, And that's precisely my point about java not being a good language for that .. it makes that first experience worse than other languages
14:55:35 <mapreduce> > "Hello world"
14:55:36 <lambdabot>  "Hello world"
14:55:45 <qebab> mar77a: doesn't it have to be a public class? (I don't really know)
14:55:54 <vixey> you should write something useful as a first program
14:55:56 <mar77a> what? o_o
14:55:58 <cladhaire> I'm not saying Java is a good language
14:56:03 <cladhaire> or well suited to teaching
14:56:07 <mapreduce> qebab: No.
14:56:13 <qebab> err, mapreduce sorry about that, I mean mapreduce
14:56:16 <mar77a> oh
14:56:19 <cladhaire> but I'm saying I've done the absurd amounts of lit review required on this topic, since its one of the focuses of my DPhil
14:56:24 <qebab> jesus ): my tab is going all astray
14:56:25 <cladhaire> and there are counters to the arguments you guys are making
14:56:27 * mapreduce confiscates qebab's tab key.
14:56:34 <cladhaire> that's why CC2001 was written, and you guys should comment on it.
14:56:48 <mapreduce> @go cc2001
14:56:51 <cladhaire> to ensure the _topics_ and concepts being covered are still in line with what we should be teaching our students.
14:56:55 <lambdabot> http://www.sigcse.org/cc2001/
14:56:55 <lambdabot> Title: CC2001 (December 15, 2001)
14:57:05 <cladhaire> http://wiki.acm.org/cs2001/index.php?title=SIGPLAN_Proposal specifically
14:57:06 <lambdabot> Title: SIGPLAN Proposal - CS2001 Wiki
14:57:19 <cladhaire> thats the SIGPLAN proposal to add functional programming as a specific subtopic
14:57:25 <cladhaire> instead of having the "fundamentals" just spread around
14:57:44 <mapreduce> cladhaire: I have taught Java programming for 3 years, and did quite well in comparison to my fellow lecturers.  But increasingly I knew it was a bad thing to do.
14:57:49 <cladhaire> whether its taught in a purely functional programming language, or not.
14:57:56 <cladhaire> mapreduce: I would agree with you, its not the right thing to do
14:57:57 <Dae_> cladhaire: But in a world were a little programming goes a long way, what -should- students be taught?
14:58:10 <cladhaire> but you can get the topics across to the student and get them out the door well prepared as well
14:58:20 <cladhaire> Dae_: that's the question :P
14:58:32 <rumbleca> the k&r book was a good intro for me, 15 years ago, anyways
14:58:40 <cladhaire> aye
14:58:42 <mapreduce> Dae_: Scheme, Haskell, assembly, C and perhaps forth.
14:58:42 <cladhaire> i loved k&r
14:58:47 <qebab> Java makes a lot of things you should know about impractical to use
14:58:56 <qebab> every language should have a k&r
14:59:01 <cladhaire> and even the BASIC manual for c64, Leading Edge 8088 gave me enough of what I needed
14:59:14 <BMeph> qebab: My point being, there should've been a compiler message before you get to that point. :)
14:59:14 <cladhaire> qebab: Thats precisely why the Groovy people exist
14:59:23 <mapreduce> Dae_: I really can't believe that anyone who knows those 4 (or 5) could not pick up enough Java or C# or python in a week to be useful on a job.
14:59:26 <cladhaire> to give a pedagogical java-compatible language on the jVM
14:59:26 <lament> qebab: you mean, every language should be small enough that you can have k&r for it?
14:59:34 <Dae_> mapreduce: I'm sure the multimedia-designers will be thrilled at learning assembly.. :p
14:59:44 <mapreduce> Dae_: I assumed you meant CS.
14:59:49 <qebab> lament: that's not really what I mean, but I guess you have a point
14:59:51 <lament> mapreduce: of course they can, given that the whole point of java, c# and python is to be easy to learn and use.
15:00:32 <cladhaire> I happen to believe in teaching students about programming language concepts so they are capable of picking up other languages quickly.  It makes the student more versatile and when taught properly helps them get outside of issues of notation and syntax in their first year.  Computer Science isn't about programming, it's about computing.
15:00:56 <mapreduce> lament: Ok, ok, add Perl to that list.
15:01:15 <lament> i'm far less sure about perl :)
15:01:21 <BMeph> I liked learning Icon, if only because it was my first experience with generators as a top-level concept.
15:01:26 <cladhaire> But parents and students don't often want to listen about how it will make them more versatile and well suited to jobs in the market.. because they see the assinine way lower level programmers are hired :P
15:01:33 <saml> all you need to know to understand computation is to know natural numbers
15:01:43 <Dae_> mapreduce: No, I ment everyone. I agree roughly on your guide for CS's, though I couldn't write "hello world" in half those languages myself
15:01:58 <kryptiskt> Is there any person that has used all features of Perl?
15:02:14 <cladhaire> i think the world would explode if that were to happen kryptiskt
15:02:30 <osfameron> some people come close I think
15:02:58 <qebab> I tried Perl once, then it flattened a list I made all by itself and I got scared
15:03:10 <araujo> hahaha
15:03:15 <qwr> you're easily scared
15:03:19 <qebab> I know
15:03:19 <osfameron> but I think like Crockford says about Javascript, Perl benefits from using the "good parts" of it and avoiding the misfeatures
15:03:24 <qwr> perl can do _much_ more ;)
15:03:33 <araujo> @quote add qebab I tried Perl once, then it flattened a list I made all by itself and I got scared
15:03:33 <lambdabot> No quotes for this person. Listen, broccoli brains, I don't have time to listen to this trash.
15:03:40 <mar77a> i was scared when i wrote a ruby backend to a php script as my first program
15:03:40 <araujo> somebody adds that qupote
15:03:42 <araujo> :-]
15:03:44 <mar77a> without any tutorial
15:03:45 <lament> qebab: i have honestly seen people claim that that's a feature.
15:03:58 * geezusfreeek too
15:04:07 <BMeph> @remember add qebab I tried Perl once, then it flattened a list I made
15:04:07 <BMeph> 	 all by itself and I got scared
15:04:07 <lambdabot> Done.
15:04:10 <qebab> lament: when I asked about it, people seemed to think it entirely normal, and that's why it scared me
15:04:29 <Saizan> @quote add
15:04:30 <lambdabot> add says: qebab I tried Perl once, then it flattened a list I made
15:04:37 <olsner> :D
15:04:39 <BMeph> Ooh, superfluous add, D'Oh!
15:04:48 <olsner> superfluous linebreak too :)
15:04:54 <mar77a> flatten the quote
15:05:03 <qebab> haha
15:05:07 <lament> qebab: that's true of every questionable feature in any language, of course (witness monads)
15:05:26 <mapreduce> Dae_: Haskell and Scheme: "Hello world", Python and Perl: print "Hello world", Java: class Main { public static void main(String[] args) { System.out.println("Hello world"); } }, C#: namespace MyApp { static class Main { static void Main(string[] args) { Console.WriteLine("Hello world"); } } }
15:05:33 <olsner> ... since =<< flattens lists
15:05:37 <osfameron> you get used to list flattening and the explicit references isn't too bad (it's one of the less pleasant aspects of Perl syntactically but really not all that bad)
15:05:47 <lament> Yegge has a wonderful rant about why perl sucks
15:05:52 <qebab> lament: you're probably right
15:06:02 <Dae_> mapreduce: Didn't know scheme.... know for the assembly one? :p
15:06:08 <Dae_> *now
15:06:17 <mapreduce> I've not really found Yegge readable.
15:06:30 * Dae_ cannot spell at this hour
15:06:32 <osfameron> Yegge makes some nice points about Perl yeah :-)
15:06:39 <mmorrow> oh, i have an asm helloworld, have to find it though...
15:06:47 <mapreduce> Sure, but you have to filter through the waffle.
15:06:52 <qebab> mapreduce: tried putting his posts through a markov-chain based gibberish generator?
15:06:59 <BMeph> mar77a: I'd flatten it, but I don't want qebab to get scared. :)
15:07:01 <mmorrow> (it's a disasm from mauke's)
15:07:24 <qebab> BMeph: don't worry about me, I'm very nearly a grownup these days
15:07:24 <mapreduce> "I might be wrong, it's been known before, in fact back in 2002 I was wrong but only for 2 minutes, but I have this slight feeling that perhaps $_ is not a good feature of Perl's."
15:07:47 <osfameron> but it's funny because a lot of the good things about Perl are things that he's really keen on
15:07:48 <mar77a> > a++;
15:07:48 <clad|sleep> mapreduce: :P
15:07:48 <lambdabot>  Parse error at ";" (column 4)
15:07:49 <mapreduce> qebab: No, but I think he has.
15:07:49 <mar77a> *GASP*
15:08:05 <qebab> mapreduce: very possible :p
15:08:06 <BMeph> qebab: Okay, but Haskell (and #haskell) is all about the hospitality. Well, that, and adjoints. ;)
15:08:19 <lament> mapreduce: come on, the perl rant is pretty readable
15:08:20 <Peaker> and cryptic @pl's
15:08:21 <qebab> thanks for the concern
15:08:26 <lament> mapreduce: and to the point
15:08:28 <mar77a> and when someone asks a question, see who can solve it with the most obfuscated fold
15:08:37 <Baughn> Haskell is about three things. Hospitality, adjoints, laziness and obfuscation.
15:08:39 <Peaker> mar77a: that's cryptic @pl's :)
15:08:57 <dons_> http://ecx.images-amazon.com/images/I/41LzlJntlZL._SS500_.jpg
15:09:02 <Peaker> Baughn: Which of those 2 are the same thing?
15:09:02 <gbacon> Section 9.2.1 of the GHC User's Guide reads, "When linking the program, remember to include M_stub.o in the final link command line..." but where can I find docs on what else to put on the link command?
15:09:07 <BMeph> @seen pl
15:09:07 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
15:09:16 <olsner> dons: oooh!
15:09:18 <Baughn> Peaker: Hospitality and obfuscation
15:09:18 <lament> Haskell is about three things.
15:09:24 <mapreduce> @pl \x y z -> x + y + y + z
15:09:25 <lambdabot> ((+) .) . join . ((+) .) . (+)
15:09:37 <hpaste>  morrow pasted "asm helloworld (for att and intel)" at http://hpaste.org/8688
15:09:41 <qebab> dons_: why does that book have a bug on it ): hardly the ideal cover for a book about anything related to programming!
15:09:56 <Dae_> dons: Why the bug?
15:10:02 <mmorrow> hello world x86 machinecode:
15:10:04 <mmorrow> "\232\14\0\0\0Hello, world!\n\186\14\0\0\0\89\187\1\0\0\0\184\4\0\0\0\205\128\49\192\195"
15:10:04 <dons_> that would be a rhinoceros beetle
15:10:08 <vinicius> haskell is macgiver with bananas, barbed wired and envelopes
15:10:15 <dons_> http://en.wikipedia.org/wiki/Rhinoceros_beetle
15:10:22 <gbacon> I'm trying to link a module that uses FFI in a project built with autotools
15:10:26 <dons_> "Rhinoceros beetles are also the strongest animals on the planet, proportionally."
15:10:39 <qebab> cool :o
15:10:41 <Baughn> gbacon: ..oh, you poor thing
15:10:43 <monochrom> @remember vinicius haskell is macgyver with bananas, barbed wired and envelopes
15:10:43 <lambdabot> It is stored.
15:10:56 <gbacon> Baughn: not so encouraging :-)
15:11:23 <olsner> "Haskell bugs are fewer, but bigger, uglier and stronger"?
15:11:37 <mapreduce> Between real-world haskell and the haskell wikibook I think haskell docs have really come on since the time when I was pointed at yaht.
15:11:48 <gbacon> I could cargo-cult the commands from ghc -v, but do I need to take such a step?
15:12:04 <Baughn> gbacon: Depends. What exactly is the issue?
15:12:15 <kiris> evening chaps
15:12:59 <basvandijk> Hello, is it possible to embed images in Haddock docs? (I couldn't find anything in the documentation)
15:13:30 <mmorrow> in the hackish end, you could proc the html output
15:13:35 <gbacon> Baughn: .hs -> .o is straightforward of course, and the UG says don't forget *_stub.o, but the linker complains about lots of undefined references
15:13:56 <Dae_> are let's used in monads executed right away?
15:13:59 <nus> @hoogle ack
15:13:59 <lambdabot> Data.ByteString.pack :: [Word8] -> ByteString
15:13:59 <lambdabot> Data.ByteString.unpack :: ByteString -> [Word8]
15:13:59 <lambdabot> Data.ByteString.Char8.pack :: String -> ByteString
15:14:12 <Baughn> gbacon: Umh. Use ghc for linking?
15:14:43 <Baughn> gbacon: Actually, ideally, use a cabal wrapper around autoconf, and leave the /compilation/ to cabal
15:15:28 <yitz> Dae_: no, they're lazy.
15:15:32 <gbacon> Baughn: I'd like to avoid autoconf surgery if possible
15:15:44 <jre2> olsner: that's somewhat true. For an average coder, compare "null pointer exeception? oops, I must have forgotten to check that." with "monomorphism restriction? WTF does that mean?"
15:16:00 <Dae_> yitz: Arff...bug found... any way I could force the evaluation? It's a list, to make matters worse
15:16:02 <Baughn> bgWell, ghc should be able to do it. I hope.
15:16:09 <Baughn> *gbacon
15:16:21 <Baughn> Calling ld directly is rarely the best option. :/
15:16:21 <gbacon> ?
15:16:33 <mar77a> question
15:16:34 <Baughn> "ghc foo.o bar.o -o baz"
15:16:46 <mar77a> if i have a computation that's looped
15:16:57 <mar77a> and each iteration takes less time than the previous one
15:16:58 <geezusfreeek> i just ran never gonna give you up through a markov chain generator...
15:17:02 <mar77a> will the loop ever end?
15:17:12 <Peaker> mar77a: depends on how much less?
15:17:17 <yitz> Dae_: foldl'?
15:17:19 <Baughn> mar77a: No, but if you compile with -threaded you'll get an exception if it's a data loop
15:17:19 <mar77a> lets just say half
15:17:20 <EvilTerran> if it's strictly decreasing, yes
15:17:29 <EvilTerran> as running time is quantised by clock cycles
15:17:38 <mapreduce> jre2: Many Java developers think that npes are best removed after the fact rather than prevented, i.e., that they're not a problem.
15:17:39 <asdftimo> hey guys, i need some help with taking elements from a list. i basically need to make a list like [5,4,3,2,1...1 (on infinitely)] become [5,4,3,2,1]. how can i do this?
15:17:39 <EvilTerran> :D
15:17:42 <mar77a> so at one point the step will be too small
15:17:46 <mapreduce> Probably like most Haskellers treat head [].
15:17:47 <mar77a> for the processor
15:17:49 <Peaker> mar77a: well, the sum of 2^-n for n=0..inf is limited by a constant
15:17:55 <Baughn> mar77a: Well, no
15:17:56 <geezusfreeek> "You known each other guy. I just wanna tell a lie and so do I. A full commitment's what's been aching"
15:18:07 <gbacon> Baughn: thanks for your help
15:18:13 <Baughn> mar77a: *Mathematically*, they're right. *Realistically*[, haskell doens't work like math.
15:18:13 <EvilTerran> geezusfreeek, what?
15:18:25 <geezusfreeek> EvilTerran: markov chain
15:18:27 <mar77a> oh i'm not talking about haskell strictly
15:18:34 <mar77a> not any language in particular
15:18:41 <EvilTerran> oh, right
15:18:44 <Peaker> asdftimo: I think you want the nub function ?
15:18:47 <Baughn> Then it's a simple limit calculation
15:18:58 <shepheb> hmm, it appears that the last nightly GHC 6.9 HEAD failed on Linux x86, anyone know a date that works on that platform?
15:19:03 <asdftimo> you cant run nub on an inifite list, though, peaker.
15:19:07 <SamB> mar77a: yeah, you can't infinitely subdivide the clock cycles available
15:19:11 <asdftimo> i mean, you can, it just hangs
15:19:20 <mar77a> so you could find out the clock speed at least :p
15:19:33 <SamB> a lower bound, yes
15:19:42 <Baughn> mar77a: If each loop is strictly half of the one before, it'll take a finite amount of time. It's just that inr eality there'll be a constant factor too. :P
15:20:24 <Peaker> asdftimo: well, that's because its impossible to know if any new elements will come - why are you forcing the entire result of nub?
15:20:30 <yitz> asdftimo: do you know that you can stop at the first repetition?
15:20:37 <vixey> jre: Anyone is able to look up what an error means though
15:20:39 <basvandijk> asdftimo: So the problem is to make a function that keeps taking elements from the list until two consecutive elements are equal?
15:20:42 <Baughn> SamB: Why do people keep talking about "quantized"? :/
15:20:55 <Baughn> It'll end in a finite time, even if it takes an infinite number of cycles
15:21:05 <asdftimo> basvandijk: yes, i know how to do what im asking, i just came here to find the most optimal solution.
15:21:15 <kiris> AshyIsMe: hey
15:21:18 <EvilTerran> because real computers can't do an infinite number of cycles in finite time
15:21:27 <AshyIsMe> hey
15:21:33 <EvilTerran> each cycle will take at least one processor tick
15:21:52 <Baughn> That's not what was postulated, though. *shrug*
15:21:58 <Peaker> asdftimo: I don't understand your exact problem from the original description
15:22:02 <Dae_> yitz: yeah.... I guess...
15:22:32 <asdftimo> im iterating euler's totient function
15:22:33 <asdftimo> http://en.wikipedia.org/wiki/Euler%27s_totient_function
15:22:40 <asdftimo> and phi(1)=1
15:22:43 <shepheb> is 6.9.20080614 working on x86-linux?
15:22:47 <asdftimo> and every iterate goes to 1
15:23:04 <asdftimo> so i have a list like [n,phi(n),...,1...,1 (infinitely)]
15:23:09 <AshyIsMe> kiris, OH chris done
15:23:11 <asdftimo> and i want to truncate it after the first one
15:23:12 <SamB> Baughn: real computers have discrete clock cycles, duh
15:23:22 <yitz> Dae_: if it's not a fold, why would laziness cause a bug?
15:23:25 <vinicius> A monadtransformer is a good idea for a infinite list that uses some complicate state for next element?
15:23:30 <vinicius> *an
15:23:33 <AshyIsMe> kiris, was wracking my brain for where i new your name from
15:23:35 <SamB> Zeno's paradox only works when you don't have to stop at each point
15:23:37 <asdftimo> i can use takeWhile(>1) and then ++1 but i would like to figure out how do it so that it doesn't repeat at the end for OTHER functions
15:23:37 <AshyIsMe> kiris, what's happenin man?
15:23:43 <SamB> otherwise it really *is* a paradox
15:23:45 <vixey> asdftimo: I call it iterateProgress
15:23:48 <asdftimo> because i will be iterating OTHER functions that don't converge at one
15:23:48 <kiris> AshyIsMe: nothing much. just hacking on lambdabot at the moment. you?
15:23:51 <Baughn> SamB: Zeno's paradox was disproved with the introduction of calculus, I'd say
15:23:56 <yitz> vinicius: yes, but use ListTDoneRight, not the ListT that comes with mtl.
15:24:10 <yitz> @go ListT Done Right
15:24:11 <Dae_> yitz: it's a forM_
15:24:11 <lambdabot> http://www.haskell.org/haskellwiki/ListT_done_right
15:24:11 <lambdabot> Title: ListT done right - HaskellWiki
15:24:13 <AshyIsMe> kiris, yeah not much.  i got a job doing vb.net full time
15:24:22 <kiris> AshyIsMe: do you like that kind of thing? :p
15:24:33 <AshyIsMe> kiris, it beats laboring on a banana farm
15:24:35 <AshyIsMe> heh
15:24:35 <asdftimo> vixey: what do you mean?
15:24:44 <vixey> asdftimo: iterateProgress f x = let fx = f x in if x == fx then [] else x : iterateProgress f fx
15:24:46 <kiris> AshyIsMe: true
15:24:50 <yitz> Dae_: so you're blowing the stack?
15:24:55 <AshyIsMe> im moving to the big smoke soon so hopefully i can get work in a better environment
15:24:58 <AshyIsMe> but it's not too bad really
15:25:05 <vixey> > let iterateProgress f x = let fx = f x in if x == fx then [] else x : iterateProgress f fx in iterateProgress (`div`2) 300
15:25:06 <lambdabot>  [300,150,75,37,18,9,4,2,1]
15:25:20 <vixey> > 1 `div` 2
15:25:21 <lambdabot>  0
15:25:30 <EvilTerran> s/then []/then [x]/
15:25:32 <asdftimo> thanks vixey, let me contemplate what that function means for a bit
15:25:46 <vixey> yeah ammendment
15:25:49 <Dae_> yitz: Much worse..... the list is made from an array.... that I made using unsafeFreeze. The STArray is the one I'm modifying....
15:25:53 <vixey> iterateProgress f x = let fx = f x in if x == fx then [x] else x : iterateProgress f fx
15:26:12 <EvilTerran> > let iterateProgress f x = x : if x == fx then [] else iterateProgress f fx where fx = f x in iterateProgress (`div`2) 300
15:26:13 <lambdabot>  [300,150,75,37,18,9,4,2,1,0]
15:26:26 <EvilTerran> good to move the (x:) outside the if - makes it lazier
15:26:46 <yitz> Dae_: ah. oh what a tangled web we weave...
15:26:52 <vixey> o_o
15:26:57 <vixey> you can use where in lambdabot!
15:27:06 <EvilTerran> vixey, er...
15:27:13 <EvilTerran> only in a let or a case
15:27:15 <kiris> when did that get added?
15:27:16 <kiris> oh
15:27:23 <EvilTerran> ie, where it's allowed in expressions anyway
15:27:38 <EvilTerran> (or in another where)
15:27:38 <vixey> I avoided it completely ever since it didn't work once
15:27:39 <Dae_> yitz: Yeah, it's not pretty, I was just trying to get around having to se MArray syntax, which would have added 20 or so lines of code
15:27:44 <vixey> > x where x = 1
15:27:44 <lambdabot>  Parse error at "where" (column 3)
15:27:53 <EvilTerran> see, that's not a valid expression
15:28:01 <kiris> > let x = b in x where b = 1
15:28:02 <lambdabot>  Parse error at "where" (column 16)
15:28:03 <EvilTerran> > let y = x where x = 1 in y -- this is
15:28:04 <vixey> I'd still have liked it to work
15:28:05 <lambdabot>  1
15:28:16 <kiris> ah
15:28:21 <EvilTerran> > case () of _ -> x where x = 1 -- so is this
15:28:22 <lambdabot>  1
15:29:02 <kiris> reason why Î»b doesn't treat everything as an expression?
15:29:09 <EvilTerran> kiris, um, it does
15:29:15 <kiris> I see
15:29:21 <EvilTerran> "where" is not valid in general in expressions
15:29:35 <EvilTerran> only in the two cases i described above
15:29:36 <dons_> Î»b is a great nick for the bot
15:29:38 <yitz> Dae_: perhaps look at Control.Exception.evaluate, or just seq
15:29:42 <roconnor> @pl join const
15:29:42 <lambdabot> join const
15:29:54 <EvilTerran> ?type join const
15:29:55 <lambdabot> forall a. a -> a
15:29:59 <roconnor> @pl . unpl join const
15:30:00 <lambdabot> (line 1, column 1):
15:30:00 <lambdabot> unexpected "."
15:30:00 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
15:30:00 <EvilTerran> ?djinn a -> a
15:30:00 <lambdabot> f a = a
15:30:06 <EvilTerran> :D
15:30:10 <roconnor> @. pl unpl join const
15:30:10 <lambdabot> join const
15:30:19 <geezusfreeek> from a steve yegge markov chain generator: "I met my first big nasty surprise when I was in the Navy Nuclear Power School program in Orlando, Florida, and I was setting historical record, because I had no idea what to do."
15:30:28 <Dae_> yitz: actually.... wouldn't "a <- b" evaluate b?
15:30:33 <yitz> @check \x -> join const x == x
15:30:34 <lambdabot>  OK, passed 500 tests.
15:30:46 <mapreduce> geezusfreeek: The "no idea" bit is uncanny.
15:30:57 <kiris> what's this fptools and do I need it to compile and run lambdabot?
15:31:03 <yitz> Dae_: not until you use a somewhere.
15:31:14 <Peaker> hey, why are people releasing all their acadmic work in less readable PDF, rather than HTML form?
15:31:22 <Dae_> yitz: I thought monads were always strict?
15:31:23 <kiris> googling it seems to show old cvs repos.
15:31:31 <EvilTerran> ?pl (\f x -> f x x) const
15:31:31 <lambdabot> join const
15:31:31 <dons> Peaker: journals require pdf submissions
15:31:38 <dons> Peaker: they don't accept html
15:31:42 <EvilTerran> ?pl \x -> const x x
15:31:42 <lambdabot> id
15:31:43 <olsner> hmm, whatever happened to the obfuscated haskell contest(s)?
15:31:44 <EvilTerran> ha
15:31:47 <dons> and there aren't until recently good pdf/html converters
15:31:47 <EvilTerran> hmm
15:31:52 <mwc> Peaker: because pdflatex is easier than finding an TeX->HTml converter and producing decent results
15:31:59 <yitz> Dae_: no, and you wouldn't want them to be. There are strict versions of each of the mtl monads though.
15:32:02 <dons> the new google converter is really good
15:32:04 <yitz> and IO is strict, mostly.
15:32:16 <mwc> Peaker: also, PDF looks vastly better when printed
15:32:19 <vinicius> what? the new google converter can't even handle accents
15:32:25 <kiris> :(
15:32:30 <vinicius> new as in, what worked as far as 2 days ago
15:32:41 <EvilTerran> check your encodings?
15:33:00 <Dae_> yitz: Right...ofcourse... that's waht I get for hacking.....
15:33:04 <dons> vinicius: interesting. i got very good results on the few papers i tried
15:33:10 <asdftimo> vixey: ok, i get it now, thanks. for my purposes i needed "if x ==fx then [x]" instead of "[]".
15:33:22 <Peaker> mwc, dons: I see, thanks.  Could be nice to have HTML side-by-side though
15:33:34 <EvilTerran> asdftimo, or read [x] as (x : []), and then bring the (x:) outside the if to make it lazier
15:33:49 <ziman> bah, python's "
15:33:49 <EvilTerran> > let iterateProgress f x = x : if x == fx then [] else iterateProgress f fx where fx = f x in iterateProgress (`div`2) 300 -- like so
15:33:51 <lambdabot>  [300,150,75,37,18,9,4,2,1,0]
15:34:01 <ziman> bah, python's "map(float, list)" seems weird to me
15:34:11 <Peaker> ziman: what about Python's " ?
15:34:18 <EvilTerran> er, float?
15:34:21 <vinicius> dons: I tried it with a few portuguese pdf and it goes out of hand
15:34:32 <ziman> it's (map float list)! :)
15:34:47 <ziman> i mean just the syntax...
15:34:49 <Peaker> ziman: itertools.imap
15:34:56 <Peaker> ziman: oh
15:35:20 <Peaker> ziman: Python is not a functional programming language :)  I do prefer its list comprehension syntax and the colon-before-blocks iae
15:35:23 <Peaker> s/iae/idea
15:35:37 <ziman> i should've used `looks weird to me', i guess
15:36:02 <kiris> does `darcs get http://darcs.haskell.org/cabal' hang for anyone else?
15:36:23 <kiris> oh, it's started now. nevermind >_> just took a few minutes
15:37:17 <ziman> the parentheses cut the expression in a bit confusing place
15:37:51 <asdftimo> EvilTerran: cool, thanks. sorry, it took me a second to figure out what you did and why i worked.
15:37:56 <asdftimo> it*
15:41:17 <EvilTerran> np :)
15:42:18 <Dae_> yitz: solved by reversing the lists ;)
15:43:00 <yitz> Dae_: bravo!
15:43:34 <BONUS_> imap and izip is going to be the default behavior for generator expressions, map and zip in py3k
15:43:36 <BONUS_> which is p kewl
15:44:12 <yitz> BONUS_: I hope they fix iterator.chain, it's too strict.
15:44:28 <BONUS_> how is it strict
15:44:47 <BONUS_> does it evaluate the iterators supplied to it first?
15:45:28 <yitz> BONUS_: if it is an infinite iterator of iterators, chain(it) hangs before returning anything
15:45:38 <shepheb> hmm, my ./configure --..... on the scratchbox dev environment is failing because I can't run pwd, which appears to be a Haskell app... how am I supposed to run ./configure on the GHC-less target environment?
15:45:44 <LordBrain> list comprehensions are a neat piece of sugar i suppose, but they're rarely that useful to me... i could live without them really.
15:45:51 <BONUS_> really? i didnt know that. interesting
15:45:56 <olsner> > map fst . takeWhile (uncurry (/=)) . ap zip tail $ iterate (`div`2) 300
15:45:58 <lambdabot>  [300,150,75,37,18,9,4,2,1]
15:46:12 <yitz> BONUS_: I once got burned by that. Wrote my own chain in the end.
15:46:42 <olsner> misses the terminating zero though... hmm
15:47:01 <shepheb> :t ap
15:47:02 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
15:47:27 <shepheb> oh right, fmap = ap
15:47:56 <olsner> hmm, so in lambdabot-haskell, I could've written zip . tail?
15:47:59 <olsner> :t (.)
15:48:01 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:48:08 <vinicius> :t fmap
15:48:09 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:48:13 <olsner> > map fst . takeWhile (uncurry (/=)) . zip . tail $ iterate (`div`2) 300
15:48:15 <lambdabot>  Couldn't match expected type `[(a, a)]'
15:48:18 <vinicius> not quite
15:48:26 <olsner> > map fst . takeWhile (uncurry (/=)) . (zip . tail) $ iterate (`div`2) 300
15:48:27 <lambdabot>  Couldn't match expected type `[(a, a)]'
15:48:44 <Saizan> for (->) e, fmap = (.), ap = S
15:49:03 <olsner> oh, I see... (a -> b) vs m (a -> b)
15:49:18 <dobblego> @users
15:49:18 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
15:49:41 <Dae_> yitz: which worked until -O saw right through my evil trick....
15:49:41 <yitz> @seen dobblego
15:49:42 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
15:49:49 <yitz> hmm
15:49:57 <yitz> @seen Cale
15:49:57 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
15:51:23 <Dae_> > sequence [1..4]
15:51:24 <lambdabot>        add an instance declaration for (Enum (m a), Num (m a))
15:52:35 <BMeph> shepheb: fmap == ap . return
15:54:01 <asdftimo> hey. a sum of positive numbers that im working with turned out negative. it isn't a problem with the code. what is the Integer limit in haskell? can i do something to make this work?
15:54:20 <vixey> Integer has no limit
15:54:48 <asdftimo> arg, this is weird. im only summing 10 digit numbers, so i should be fine, since i can do 100!...
15:55:05 <vixey> why don't you view the list of numbers
15:55:09 <macondo> Is it me or Haskell sources take a while to compile? (I'm not trolling, please)
15:55:14 <Peaker> asdftimo: maybe you're summing Int's and not Integers?
15:55:18 <ziman> you must have Ints somewhere
15:55:19 <SamB> asdftimo: and you're sure you didn't use Int by mistake?
15:55:24 <asdftimo> no i am not sure
15:55:34 <asdftimo> how can i check/fix?
15:55:50 <asdftimo> ok, i did.
15:57:13 <augustss> yowsa!
15:57:15 <asdftimo> arg, stupid mistake, thanks for the help guys ive got it worked out
15:58:38 <Cale> yitz: grr, stupid seen plugin :)
15:59:55 <yitz> @tell Cale @seen is acting up again. sigh. Thanks!
15:59:59 <lambdabot> Consider it noted.
16:00:04 <Cale> @seen
16:00:07 <Cale> @seen Cale
16:00:15 <lambdabot> You are in #haskell-overflow, #ghc and #haskell. I last heard you speak 2s ago.
16:00:16 <Cale> ...
16:00:21 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
16:00:31 <yitz> @seen augustss
16:00:39 <lambdabot> augustss is in #haskell. I don't know when augustss last spoke.
16:00:44 <dons> > sum [10^20, 7^21]
16:00:47 <yitz> fixed now. thanks!
16:00:48 <augustss> I've been seen.
16:00:51 <lambdabot>  100558545864083284007
16:01:05 <vixey> hi augustss
16:01:14 <augustss> yowsa!
16:02:01 <Peaker> is there anything like arrows but without arr/pure?  they seem to make any static analysis of data-dependencies impossible
16:02:02 <Saizan> Peaker: for arrows without pure there's Category in the darcs version of base iirc
16:02:22 <Peaker> where can I read about Category?
16:02:31 <Saizan> but it also lacks (***)/fisrt etc..
16:02:32 <augustss> Peaker: I'll blog again tomorrow.  I've been lazy.
16:02:42 <Peaker> augustss: cool!
16:02:52 <Peaker> augustss: looking forward to it :)
16:03:20 <augustss> Peaker: don't expect much
16:03:47 <yitz> Cale: that person who wanted to know about monads from zero yesterday called me on the phone. He's actually got it. Unbelievable, great job!
16:03:59 <saadahmad> Hey guys, lets say I have a a constructor Foo, how would I code it so that I can set an array to be part of a constructor.
16:04:12 <saadahmad> Such that I can go Foo myArray
16:04:26 <Peaker> augustss: btw: Isn't it annoying that all the cool class-based tricks (e.g "Expr", but also conal's Behavior instances of everything) fail because of a few unclassed types (e.g Bool)?
16:04:35 <shachaf> saadahmad: Are you sure you want an array?
16:04:37 <augustss> yitz: going from zero tone one in a single phone call?
16:04:49 <Cale> saadahmad: What type of array?
16:05:20 <saadahmad> Cale, The one in the array module
16:05:24 <dobblego> is [] a group? if so, what is its inverse?
16:05:28 <augustss> Peaker: it is annoying.  My post tomorrow will have some of that yet again
16:05:40 <saadahmad> shachaf, I have static data that needs quick access :)
16:05:43 <vinicius> it's a monoid
16:05:49 <vinicius> iirc
16:06:10 <saadahmad> (Unless there is a better alternative)
16:06:11 <yitz> augustss: a beginning programmer, no math background. Cale explained it.
16:06:11 <Cale> dobblego: for any type t, [t] is a monoid with [] as the identity and (++) as the multiplication.
16:06:12 <macondo> > take 10 [0.1,0.2..] :: [Double]
16:06:14 <lambdabot>  [0.1,0.2,0.30000000000000004,0.4,0.5,0.6,0.7,0.7999999999999999,0.8999999999...
16:06:19 <augustss> dobblego: negative lists?
16:06:23 <macondo> > take 10 [0.1,0.2..] :: [Float]
16:06:24 <Cale> dobblego: There's obviously no inverse, because we don't have antilists :)
16:06:25 <lambdabot>  [0.1,0.2,0.3,0.4,0.5,0.6,0.70000005,0.8000001,0.9000001,1.0000001]
16:06:40 <macondo> Why that aberrations?
16:06:50 <dobblego> of course, thanks
16:07:02 <Cale> macondo: Because you're using floating point numbers. 0.1 isn't exactly representable
16:07:15 <Cale> macondo: and there are rounding errors
16:07:25 <Peaker> Saizan: googling for a "category class" in Haskell context is a recipe for disaster :)
16:07:29 <Saizan> Peaker: it's just class Category cat where id :: cat a a; (.) :: cat b c -> cat a b -> cat a c
16:07:38 <ziman> > take 10 [0.1,0.2 ..] :: [CFloat]
16:07:38 <Saizan> Peaker: http://darcs.haskell.org/packages/base/Control/Category.hs
16:07:39 <lambdabot>   Not in scope: type constructor or class `CFloat'
16:07:56 <Cale> > take 10 [0.1,0.2..] :: [CReal]
16:07:57 <lambdabot>  [0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0]
16:08:09 <ziman> i always forget what the name is
16:08:14 <ziman> @where CReal
16:08:14 <lambdabot> I know nothing about creal.
16:08:21 <Cale> @hackage numbers
16:08:21 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/numbers
16:08:22 <yitz> > take 10 [0.1,0.2..] :: [Rational]
16:08:24 <lambdabot>  [1%10,1%5,3%10,2%5,1%2,3%5,7%10,4%5,9%10,1%1]
16:08:36 <augustss> rationals are nice
16:09:02 <Peaker> Saizan: too small, it seems
16:09:04 <EvilTerran> > [0.1..1 :: Rational]
16:09:05 <lambdabot>  [1%10,11%10]
16:09:15 <vinicius> heh
16:09:18 <EvilTerran> > [0.1,0.2..1 :: Rational] -- er
16:09:20 <lambdabot>  [1%10,1%5,3%10,2%5,1%2,3%5,7%10,4%5,9%10,1%1]
16:09:20 <macondo> Wow
16:09:33 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/8690
16:09:44 <Peaker> Saizan: is "id" just for Monoid instances and convenience?
16:10:06 <mofmog> so in my code here http://hpaste.org/8690
16:10:06 <saadahmad> Any assistance Cale?
16:10:24 <mofmog> i'm basically doing a search and replace
16:10:33 <Saizan> Peaker: well, a category has id..
16:10:41 <augustss> id is for conveniecce, like verey other function
16:10:45 <augustss> every
16:10:47 <Cale> saadahmad: Do you want your datatype to be parametrised by the index and element type of the array?
16:10:51 <Peaker> Saizan: well I don't know any category theory
16:10:56 <Cale> data Foo i e = Foo (Array i e)
16:10:58 <mofmog> if a "word" in exp matches a "name" in [(String,[String])], it will replace the word with the [String] part
16:11:01 <mofmog> for course, it doesnt work
16:11:04 <Peaker> augustss: I meant in the Category class
16:11:04 <vinicius> @check Rationa Integral
16:11:05 <lambdabot>   Not in scope: data constructor `Integral'
16:11:06 <vinicius> err
16:11:10 <vinicius> @hoogle Rationa Integral
16:11:10 <lambdabot> No matches, try a more general search
16:11:10 <Cale> saadahmad: something like that perhaps?
16:11:21 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/8691
16:11:21 <Saizan> Peaker: i've not seed much use of that class besides Functional References
16:11:25 <saadahmad> I believe that will doo
16:11:31 <saadahmad> do*
16:11:36 <vinicius> @instance Rational
16:11:36 <lambdabot> Maybe you meant: instances instances-importing
16:11:39 <mofmog> http://hpaste.org/8691 is the error
16:11:41 <vinicius> @instances Rational
16:11:42 <lambdabot> Couldn't find class `Rational'. Try @instances-importing
16:11:50 <Peaker> Saizan: I think there's another way out except forbidding arr
16:11:52 <vinicius> @instances-importing Rational
16:11:53 <lambdabot> Couldn't find class `Rational'. Try @instances-importing
16:12:16 <Peaker> Saizan: you could also use something other than a tuple, that can't be looked through except by the arrow instance
16:12:17 <vinicius> maybe it's a datatype and not a class...
16:12:32 <mofmog> wait
16:12:33 <mofmog> no
16:12:35 <mofmog> my brain is fried
16:12:36 <mofmog> NVM
16:12:43 <Peaker> Saizan: so the lifted functions can only manipulate a "single" value, and not mess the structure itself
16:13:17 <Saizan> Peaker: right, but somewhere you probably need to use those values at once
16:13:33 <Peaker> Saizan: "at once"? what do you mean?
16:14:57 <Saizan> Peaker: that a lifted function might actually need to see both the values in this special pair
16:15:28 <Peaker> Saizan: well, then there could be a special arrow method to convert it to a tuple (which indeed will lose dependency information, but in that case rightly so)
16:15:32 <roconnor> > fix ((ap ((:) . (1 /) . (1 +)) (return . (1 +)) =<<) . (1 :)) :: [Rational]
16:15:34 <lambdabot>  [1%2,2%1,2%3,3%2,1%3,3%1,3%5,5%3,2%5,5%2,3%4,4%3,1%4,4%1,5%8,8%5,3%8,8%3,5%7...
16:16:39 <Saizan> Peaker: right :)
16:16:45 <roconnor> hm, I lost 1
16:17:00 <Saizan> Peaker: now we need a way to enforce this with types
16:17:27 <Peaker> Saizan: class Arrow a tupleType where ... is not Haskell98 right?
16:18:17 <Saizan> no, MultiParamTypeClasses are probably going to be haskell' though
16:18:25 <Peaker> Saizan: I think that's the right way (then just change (a,b) to tupleType a b, and add a collapse :: tupleType a b -> (a,b) method..
16:18:38 <roconnor> > fix ((1:).(ap ((:) . (1 /) . (1 +)) (return . (1 +)) =<<)) :: [Rational]
16:18:40 <lambdabot>  [1%1,1%2,2%1,2%3,3%2,1%3,3%1,3%5,5%3,2%5,5%2,3%4,4%3,1%4,4%1,5%8,8%5,3%8,8%3...
16:19:35 <yitz> @unpl ((1:).(ap ((:) . (1 /) . (1 +)) (return . (1 +)) =<<))
16:19:35 <lambdabot> (\ h -> 1 : (h >>= ((\ q -> ((:)) (1 / (1 + q))) >>= \ j -> (\ w -> return (1 + w)) >>= \ i -> return (j i))))
16:21:23 <Peaker> how do I define an infix class (e.g b~>c instead of "a b c") ?
16:21:28 <yitz> roconnor: isn't there some variation of that that converges to pi?
16:22:25 <vixey> You cannot
16:22:48 <LordBrain> oh vixey
16:22:56 <LordBrain> you are such the heart breaker
16:23:02 <LordBrain> :)
16:23:32 <Saizan> Peaker: class Arrow (~>) tupletype where ..
16:23:39 <yitz> @vixen you are such a heart breaker
16:23:40 <lambdabot> you remind me of that actor, whatshisname
16:23:46 <Peaker> Saizan: thanks
16:23:54 <Peaker> Saizan: its SArrow for Structured-Arrow :)
16:28:10 <Peaker> (&&&) can be defined in terms of arr and (***) right?
16:28:45 <ddarius> :t \f g -> arr (\x -> (x,x)) (f *** g)
16:28:52 <ddarius> :t (&&&)
16:28:53 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> (a (b, b') (c, c'), a (b, b') (c, c'))
16:28:53 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
16:29:03 <ddarius> Oops.
16:29:05 <ddarius> :t \f g -> arr (\x -> (x,x)) >>> (f *** g)
16:29:06 <lambdabot> forall b (a :: * -> * -> *) c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
16:29:22 <Peaker> thanks, was making sure I'm not being crazy :)
16:37:46 <Peaker> Saizan: I'm starting to think that maybe its a bad idea.  While second is a default method, you can implement it - and not lose the important structure information...
16:38:25 <Peaker> Saizan: the pair type only adds a bit of difficulty to manipulating those tuples but it is still possible so it is essentially equivalent to arrows, but more cumbersome
16:39:54 <Peaker> oops, I didn't think it through. I take it back. Need to think some more :)
16:41:10 <Saizan> the meat of the problem is that you want to avoid silly arrows like "arr (\(x,y) -> (x+1,y)" in favor of "first (arr (+1))"
16:42:36 <Peaker> Saizan: yeah, but you can just assume the worst when someone binds a tuple arrow to a pure function, and know better when he's binding to your methods
16:44:15 <Peaker> given referential transparency, is it possible to detect reference cycles in data structures?
16:44:16 <shepheb> which version of libffi do I want to have installed for GHC 6.9.20080614?
16:44:24 <ddarius> Peaker: No.
16:44:41 <ddarius> Unless you explicitly model them, but then there aren't any cycles.
16:46:21 <ddarius> Well, you could also uniquely label each "node" as you build the structure and use those, but you can't for just any data structure.  Being able to do so would -directly- violate referential transparency.
16:46:40 <Peaker> yeah, I see
16:48:40 <Peaker> There's no DebugShow or anything that functions are an instance of, right?
16:49:21 <ddarius> Not anything useful in the standard libraries.  HOOD may have something though.  I'm not sure what the GHCi debugger does with functions.
16:50:02 <Peaker> I'm trying to toy around with an arrow instance that can show the computation denoted as a graph, with dependencies
16:50:58 <ddarius> You'd want to look at the work in Buddha and HOOD then and maybe Hat.
16:51:26 <ddarius> Also see what RTS functions and primitives GHC provides.
16:51:31 <Cale> uh, hey, why is isSuffixOf missing from Data.ByteString.Lazy.Char8 ?
16:51:41 <ddarius> E.g. there is reallyUnsafePtrEq# that will do a reference comparison.
16:51:43 <Cale> It's present in Data.ByteString.Lazy
16:51:47 <Peaker> ddarius: thanks
16:51:51 <Cale> Odd.
16:52:09 <Peaker> ddarius: I think my cycle detection question was born out of misguided thoughts.. I need to think about it some more
16:53:12 <BMeph> :t uncurry join
16:53:13 <lambdabot> forall a b. (b -> b -> a, b) -> a
16:53:24 <shepheb> make in /rts fails saying it can't execute utils/mangler/ghc-asm  there's no such file, but there is ghc-asm.lprl
16:53:30 <BMeph> :t uncurry . join
16:53:30 <lambdabot> forall a b c. (a -> a -> b -> c) -> (a, b) -> c
16:53:46 <BMeph> :t join . uncurry
16:53:47 <lambdabot> forall a a1 b. (a1 -> b -> (a1, b) -> a) -> (a1, b) -> a
16:54:09 <ddarius> :t join uncurry
16:54:10 <lambdabot>     Couldn't match expected type `a -> b -> c'
16:54:10 <lambdabot>            against inferred type `(a, b)'
16:54:10 <lambdabot>       Expected type: (a -> b -> c) -> (a -> b -> c) -> a1
16:54:45 <ddarius> :t join curry
16:54:46 <lambdabot>     Occurs check: cannot construct the infinite type: a = (a, b) -> c
16:54:46 <lambdabot>     Probable cause: `curry' is applied to too few arguments
16:54:46 <lambdabot>     In the first argument of `join', namely `curry'
16:55:10 <BMeph> :t join . curry
16:55:11 <lambdabot> forall b c. ((b, b) -> c) -> b -> c
16:55:24 <BMeph> Yay, got it!
16:56:15 <BMeph>  :t join . curry (***)
16:56:33 <ddarius> :t join $ curry (***)
16:56:33 <lambdabot>     No instance for (Arrow (,))
16:56:33 <lambdabot>       arising from a use of `***' at <interactive>:1:13-17
16:56:33 <lambdabot>     Possible fix: add an instance declaration for (Arrow (,))
16:57:00 <BMeph>  :t join . curry . (***)
16:57:15 <shepheb> dons, yitz, any other GHCers: newbie help?
16:57:36 <EvilTerran> :t join $ curry . (***)
16:57:37 <lambdabot>     No instance for (Arrow (,))
16:57:37 <lambdabot>       arising from a use of `***' at <interactive>:1:15-19
16:57:37 <lambdabot>     Possible fix: add an instance declaration for (Arrow (,))
16:57:43 <EvilTerran> fail
16:58:10 <ikeda> anybody run haskell on the iPhone yet?
16:58:26 <ddarius> I think so, but I'm not sure.
16:58:41 <dons_> ikeda: work is underway
16:58:43 <vixey>  wasn't alpheccar doing that?
16:58:51 <vixey> maybe it was a different type of phone
16:58:53 <shepheb> ikeda: I'm working on a crude first-port of GHC for ARM right now, as well.
16:59:12 <shepheb> someone may've cross-compiled with jhc or ported hugs
16:59:51 <stepcut> hugs compiled for me on the ARM with little effort
16:59:58 <shepheb> stepcut: maybe you've seen this: during an unregisterised port build, make in /rts on the host failed because it couldn't execute utils/mangler/ghc-asm
17:00:11 <ikeda> sweet: cool. eagerly awaiting it.
17:00:15 <stepcut> The jhc author said jhc worked for him on the nokia N800
17:00:17 <BMeph> :t (join . curry.).(***)
17:00:18 <lambdabot>     The operator `.' [infixr 9] of a section
17:00:18 <lambdabot>         must have lower precedence than the operand `(.)' [infixr 9]
17:00:18 <lambdabot>         in the section: `(join . curry .)'
17:00:39 <stepcut> shepheb: hrm, perhaps, it's been a few years
17:00:43 <BMeph>  :t ((join . curry).).(***)
17:00:53 <stepcut> shepheb: but, build failures are not uncommon
17:00:58 <shepheb> stepcut: clearly since 6.4 was "coming soon"
17:01:02 <stepcut> :)
17:01:12 <stepcut> I have tried 6.6 as well I think, but not 6.8
17:01:13 <shepheb> yeah, I'm learning that the hard way. several false-starts so far
17:01:19 <stepcut> shepheb: are you building 6.8 or 6.9 ?
17:01:27 <shepheb> stepcut: 6.9
17:01:29 <stepcut> shepheb: there is only the hard way
17:01:30 <shepheb> 20080614
17:01:38 <stepcut> cool
17:01:48 <stepcut> I hope you are taking notes ?
17:02:03 <shepheb> stepcut: see your old ArmLinuxGhc Trac page :P
17:02:08 <stepcut> running it under screen, emacs, etc, so you can see what you did after the fact ?
17:02:11 <stepcut> :p
17:02:12 <shepheb> documenting everything I've tried that's worked so far.
17:02:17 <BMeph> Uh-oh, I hope I didn't hurt lambdabot... :|
17:02:27 <BMeph> > 2 + 2
17:02:29 <lambdabot>  4
17:02:36 <ddarius> BMeph: You keep putting spaces in front of the :t
17:03:09 <BMeph> ddarius: Hmm, must be trying to align with all you six-lettered folks. :)
17:03:20 <BMeph> :t ((join . curry).).(***)
17:03:21 <lambdabot> forall c b' c'. (b' -> c) -> (b' -> c') -> b' -> (c, c')
17:03:42 <stepcut> anyway, if I have a literate .lhs file, how can I extract just the Haskell source ?
17:04:04 <ddarius> stepcut: There is an option to GHC that will preprocess it.
17:04:14 <ddarius> There should also be a program called "unlit" somewhere.
17:04:27 <stepcut> ddarius: yeah, I remember something existed, just not the details of where to start looking ;)
17:04:39 <ddarius> stepcut: The GHC User Manual
17:05:52 <stepcut> hrm, ghc -E is close, but a bit too aggresive, maybe unlit will do what I want
17:09:29 <stepcut> I think, sed -n 's/^> //p'  HitCounter.lhs, does what I want best ;)
17:11:31 <stepcut> sed -n 's/^> \?//p'  HitCounter.lhs
17:14:39 <stepcut> cool. Now I can write my blog post as a literal haskell file with the literal part being valid html. Then I can use HsColour to turn the .lhs into a syntax hightlighted .html file and sed to extract the program as a plain .hs file (so users can use it as a starting point to modify)
17:16:06 <stepcut> and I've modified my blogger profile so that it understands the css that HsColour generates
17:16:34 <Saizan> Peaker: btw, see the RULES called */arr after the class definition, they actively lose indipendence information http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Control-Arrow.html
17:16:35 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/62bzdg
17:17:22 <stepcut> *and* it even uses the same colors as emacs :)
17:23:39 <hpaste>  kiris pasted "hackage and cabal are quite scriptable" at http://hpaste.org/8692
17:24:12 <kiris> ah, it cut it off. here is the full version: http://rafb.net/p/gDgHdm48.txt
17:26:12 <mmorrow> stepcut: ghc/utils/unlit/{Makefile,README,unlit,unlit.c,unlit.o}
17:27:23 <mmorrow> actually,
17:27:25 <mmorrow> http://darcs.haskell.org/ghc/utils/unlit/
17:27:26 <lambdabot> Title: Index of /ghc/utils/unlit
17:29:16 <stepcut> mmorrow: cool
17:30:24 <kiris> Linking dist/build/runplugs/runplugs ...
17:30:24 <kiris> /usr/local/lib/ghc-6.8.2/libHSghc.a(RtClosureInspect.o): In function `ghczm6zi8zi2_RtClosureInspect_a73_info':
17:30:28 <kiris> (.text+0xee1e): undefined reference to `containerszm0zi1zi0zi1_DataziSequence_a26_info'
17:30:31 <kiris> collect2: ld returned 1 exit status
17:30:33 <kiris> ;_;
17:30:45 <stepcut> kiris: yay!
17:30:46 <kiris> how do I go about debugging this?
17:30:57 <BMeph> use --make
17:31:33 <kiris> ok I'll try
17:31:46 <stepcut> kiris: are you using, runhaskell Setup.hs build, to build that ?
17:31:56 <kiris> yes!
17:32:16 <stepcut> kiris: I think it is a diamond dependency issue perhaps
17:32:38 <kiris> what's that?
17:33:01 * ddarius always thinks "Glimmer of Hope" is a later song.
17:33:32 <kiris> ah. this problem http://blog.well-typed.com/2008/04/the-dreaded-diamond-dependency-problem/
17:33:33 <lambdabot> Title: blog.well-typed.com » Blog Archive » The dreaded diamond dependency problem, http://tinyurl.com/6hbfwv
17:33:37 <mmorrow> stepcut: yeah, unfortunately it's in c
17:33:42 <stepcut> kiris: I suspect runplugs depends on a library that was built against a different version of the containers module than what you have installed now
17:34:10 <kiris> hmm, I see
17:34:11 <stepcut> mmorrow: sed does what I need for now. ghc -E was close -- but it left blank lines where it remove the literate stuff
17:34:32 <mmorrow> stepcut: sed has saved my life many times
17:34:36 <stepcut> kiris: the short version is, you probably just need to make sure everything it built against the latest version of everything
17:34:48 <kiris> stepcut: aye, I'll do that
17:35:08 <kiris> thanks
17:35:27 * shepheb shudders to think how long this GHC build is going to take when emulating an ARM processor
17:35:55 <stepcut> shepheb: for 6.4 it took about 8 hours on my 1GHz pentium ;)
17:36:22 <stepcut> shepheb: but, 6.8 has much less  stuff in base, so I think it could be much faster. Also, I was not using the qemu kernel module
17:38:04 <shepheb> stepcut: well, this is (one core of) a Core 2 Duo 2.8 GHz, and hopefully the smaller base will cut it down.
17:38:29 <shepheb> incidentally, what's the make target to build a binary package from the bootstrapped, unregisterised build so I can try it live on the device?
17:38:40 <shepheb> (or will that not work since it lacks a gcc?)
17:40:43 <stepcut> shepheb: not sure what you mean. Once you have a unregisterised build you will have a program named ghc
17:41:36 <shepheb> stepcut: well, the porting page gives an example using compiler/ghc-inplace
17:42:00 <shepheb> I'm wondering what steps (and dependencies?) I would need to have to get that unregisterised GHC running on my Nokia N810
17:42:10 <shepheb> after it built in the scratchbox
17:42:28 <stepcut> shepheb: do you want to run ghc on the N810, or just use it to compile for the N810 ?
17:42:54 <shepheb> either would be sweet, but the end goal is the former.
17:44:05 <stepcut> I think the ghc-inplace would require you to copy the entire source tree onto the N810. Usually ghc-inplace is just used to make another unregistered build of ghc. But this time it is built not-in-place. So that version will install in /usr/local/bin like normal.
17:44:39 <stepcut> or, you could do, configure --prefix=/opt/ghc-6.9, so that you can just copy the whole /opt/ghc-6.9 directory after you do 'make install'.
17:45:08 <stepcut> though, you would also need gcc and friends on the N810.
17:45:30 <shepheb> stepcut: ah, I re-read that section, and it says "...just use the compiler in that tree to build a fresh compiler from scratch, this time without booting from C files. Before doing this you might want to check that the bootstrapped compiler is generating working binaries:" and then the example I quoted.
17:46:16 <shepheb> stepcut: right, that's what I thought. this is looking cross-compilation only until/if we get native code gen... which is a pretty big project, I imagine.
17:48:24 <stepcut> shepheb: what do you mean by cross-compilation? I expect that you will be able to produce a vesrion of ghc that runs on ARM and produces ARM code. You would just be running it in scratchbox, not on the N8xx.
17:48:47 <shepheb> stepcut: right, that was what I meant, that isn't technically cross-compilation.
17:48:55 <stepcut> ah
17:49:09 <stepcut> yeah, with native code gen, you would not need gcc (though you probably would need ld)
17:50:45 <stepcut> I'm not sure how hard native code gen is. I don't think it is too bad.
17:51:24 <shepheb> yeah, I'm looking at the porting guide, it seems like it's fairly well cut out. I'd need to learn a lot more about ARM asm to do it, don't know if any other interested devs know more.
17:52:31 <shepheb> and, unfortunately ld doesn't seem to be installed, so I suspect you're right that it would have to be included.
17:53:01 <stepcut> shepheb: at least one dev said they knew ARM asm pretty well
17:53:08 <stepcut> shepheb: I don't however
17:55:33 <shepheb> I have no idea how difficult it would be to port ld. the scratchbox environment uses a native cross-compilation toolchain rather than an ARM-ARM toolchain.
17:58:14 <stepcut> shepheb: see if someone has compiled binutils already
17:58:54 <stepcut> shepheb: that is where it comes from
18:01:49 <xerox> yeah one of them worked for arm even, iirc
18:03:00 <stepcut> searching for 'maemo binutils' gives the impression that someone has already done it for us
18:03:15 <stepcut> and debianized it
18:03:47 <shepheb> stepcut: yeah, that should be straightforward then.
18:08:54 <shepheb> argh failed on the last step, rts/{AutoApply_thr.hc,AutoApply_debug.hc,AutoApply_thr_debug.hc,AutoApply_thr_p.hc} and libraries/base/GHC/PrimopWrappers.hs are missing when I try to make hc-file-bundle Project=Ghc
18:11:54 <stepcut> shepheb: :p
18:12:42 <stepcut> thr is probably short for threaded, not sure what that means though
18:13:20 <noecksit_> hello, is there any way to find out in ghc what the constructors of a type are, and how many parameters they have?
18:13:41 <monochrom> :info Maybe
18:14:00 <monochrom> try that at the ghci prompt
18:14:19 <mmorrow> noecksit_: do you mean at runtime or just in general (like in ghci)
18:14:25 <noecksit_> monochrom : that's perfect, thanx
18:14:39 <mmorrow> :i is the awesome
18:15:29 <EvilTerran> ?src Maybe
18:15:30 <lambdabot> data Maybe a = Nothing | Just a
18:15:37 <EvilTerran> is how you'd do it in lambdabot
18:15:53 <EvilTerran> or you can look in the haddock for the module it's from
18:15:59 <mmorrow> unfortunately :i doesn't give you the source of functions
18:16:07 <mmorrow> @src foldl'
18:16:08 <lambdabot> foldl' f a []     = a
18:16:08 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
18:18:25 <dmwit> mmorrow: In the case of (pre-compiled) libraries, how could it?
18:19:19 <shepheb> stepcut: output and ls -l output is up on the wiki page ( http://hackage.haskell.org/trac/ghc/wiki/ArmLinuxGhc )
18:19:22 <lambdabot> Title: ArmLinuxGhc - GHC - Trac
18:19:22 <shapr> stepcut: Hiya!
18:23:54 <vixey> shapr hi D
18:23:55 <vixey> :D
18:24:27 <mmorrow> dmwit: of course, you'd have to *have* the source tell ghci where, possibly in your .ghci
18:24:51 <dmwit> mmorrow: Yeah.  You could install GOA, if you wanted. ;-)
18:25:21 <mmorrow> dmwit: heh, i had that installed at one point. i have lambdabot built though
18:25:58 <mmorrow> (at the time i had goa, i couldnt get lambdabot built)
18:26:02 <joey_> I don't suppose anyone has any interesting compiler related project ideas? :)
18:26:20 <dmwit> mmorrow: ...how did you have goa without \bot?
18:26:22 <shepheb> joey_: GHC on ARM? :P
18:26:23 <joey_> I'm trying to think up something exciting for my final year project.
18:26:26 <dmwit> joey_: Sure!
18:26:28 <shapr> vixey: y0
18:26:35 <mmorrow> dmwit: it didn't work (haha)
18:27:13 <vixey> joey_: compilers with mechanically checked correctness proofs is in vogue
18:27:20 <joey_> I've been pouring over wikipedia for the last hour looking for inspiration
18:27:20 <dmwit> joey_: I'd like my text editor to do syntax coloring by coloring the *identifiers* rather than the keywords.
18:27:32 <dmwit> joey_: Bonus points if it colors are determined by the name of the identifier.
18:27:53 <vixey> joey_: The Wonder Years of Sequential Prolog Implementation inspired me to write a compiler by the way
18:27:56 <mmorrow> joey_: i'm excited by this area also. check out the second harpy tutorial, that inspired me.
18:27:58 <joey_> dmwit: It's a nice idea, but I'm not sure if it'd qualify as 3rd year dissertation worthy :(
18:28:05 <dmwit> Oh, dissertation.
18:28:12 <byte-> I'm looking to parse a pretty simple data format
18:28:14 <dmwit> I was thinking senior in college, sorry.
18:28:32 <joey_> vixey: How're you finding it? You're using haskell I assume?
18:28:33 <byte-> I was looking at parsec
18:28:35 <ddarius> vixey: How is that coming?
18:28:38 <dmwit> byte-: Consider Parsec, it's pretty nice for one-offs.
18:28:41 <joey_> I will, thanks mmorrow
18:28:43 <dmwit> byte-: Err... yeah. =)
18:28:48 <byte-> it looks rather...unmaintained, though
18:28:51 <vixey> no I wrote it in Prolog (with a bit of runtime in Scheme)
18:28:55 <mmorrow> joey_: http://uebb.cs.tu-berlin.de/harpy/download/larger-tutorial.pdf
18:29:00 <byte-> and also I can't get it to make...
18:29:06 <mmorrow> vixey: cool!
18:29:21 <ddarius> byte-: You should be able to just cabal install parsec
18:29:21 <dmwit> byte-: Parsec comes with GHC.
18:29:38 <byte-> dmwit: oh
18:29:41 <dmwit> byte-: ...so you shouldn't have to install anything.
18:29:42 <byte-> interesting
18:29:52 <byte-> ddarius: I looked on hackage but couldn't find a cabal package
18:29:53 <shapr> @users
18:29:53 <lambdabot> Maximum users seen in #haskell: 449, currently: 424 (94.4%), active: 17 (4.0%)
18:30:00 <ddarius> @hackage parsec
18:30:00 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/parsec
18:30:01 <byte-> I guess that's because it comes with GHC
18:30:03 <byte-> "the more you know"
18:30:07 <vixey> ddarius: it can compiler the parser, printer, stdlib and repl.. they all work, but I have kind of stopped there because I'm trying to figure out what I can improve on the language now
18:30:23 <dmwit> byte-: Also, I don't think it's *too* unmaintained, though I can't remember who it is that's working on it.
18:30:43 <fons> byte-: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Cabal
18:30:49 <ddarius> dmwit: I'm not really working on it, but I'm the maintainer.
18:30:54 <dmwit> ah
18:30:57 <byte-> hmm
18:31:01 <byte-> don't know how I missed it on hackage
18:31:02 <dolio> Parsec 3 wasn't released that long ago.
18:31:09 <joey_> vixey: How long has it taken you so far?
18:31:11 <mmorrow> vixey: so the source language is one you've created and the target language is scheme?
18:31:22 <byte-> oh well, since it comes with ghc I guess it doesn't matter
18:31:30 <byte-> the latest version on the parsec website is a 2.0 tarball
18:31:36 <joey_> vixey: Do you think there's scope in that sort of area for a solid, but achievable 3rd year project?
18:31:42 <byte-> ok, thanks guys
18:32:16 <stepcut> shepheb: mysterious
18:32:23 <mmorrow> joey_: check out milc, a minimal ML to C compiler that Botje wrote for a compilers course project
18:32:33 <joey_> Got a link mmorrow?
18:32:33 * mmorrow looks for the milc darcs repo url
18:33:10 <mmorrow> joey_: http://infogroep.be/~dharnie/milc
18:33:13 <lambdabot> Title: Index of /~dharnie/milc
18:33:13 <shepheb> stepcut: there is an AutoApply_thr.thr_o and similar for the others in rts/, I wonder what happened to the .hc files.
18:33:20 <joey_> I was considering writing something like Scheme -> C, or something along those lines
18:33:26 <vixey> joey_: I think it was about a month and a bit, I've written Prolog interpreters before in a variety of ways so I had a decent plan.. I don't know what 3rd year means but it was fun
18:33:29 <mmorrow> joey_: cool
18:33:31 <joey_> But there doesn't seem to really be a "twist" to it
18:33:35 <joey_> It's a little played out
18:33:38 <vixey> joey_: Scheme -> C should only take 90 mins :P
18:33:59 <mmorrow> joey_: i have another awesome link that's related to scheme to C, lemme find it
18:34:00 <shepheb> a grep -R AutoApply_thr . shows a bunch of binaries, and hc-files-to-go but nothing in Makefiles or whatever :(
18:34:06 <joey_> vixey: I suspected as much, but it might be a good place to start
18:34:10 <vixey> ( http://www.iro.umontreal.ca/~boucherd/mslug/meetings/20041020/minutes-en.html )
18:34:10 <joey_> Scheme++!
18:34:11 <lambdabot> Title: '(Montreal Scheme/Lisp User Group) / Bienvenue, http://tinyurl.com/fj4af
18:34:22 <joey_> mmorrow: Thanks!
18:34:40 <fons> does anybody know if hackage keeps statistics of the times a package has been downloaded?
18:35:52 <joey_> vixey: By the looks of it, I'd need something a bit more substantial than scheme -> c then :P
18:36:17 <vixey> joey_: Prolog compilation has a very interesting history
18:36:40 <joey_> Honestly haven't ever used Prolog
18:36:55 <ddarius> joey_: So learn it.
18:36:58 <joey_> I'll take a look at it
18:37:06 <vixey> I wonder how long it takes to learn Prolog
18:37:22 <ddarius> vixey: Not very, especially if you are familiar with functional programming.
18:37:33 <ddarius> It will drive you insane though.
18:37:44 * shapr hugs ddarius 
18:38:29 <ddarius> shapr: Don't you have a Portuguese woman for that?
18:38:31 <mmorrow> joey_: i couldn't find a link to where i got it from, but have it saved and put it here: http://code.haskell.org/~morrow/misc/schemec.txt
18:38:41 <shapr> ddarius: No, just a tenative date...
18:38:45 <joey_> mmorrow: Thanks
18:38:54 <shapr> ddarius: Anyway, I don't like you in quite that same way.
18:38:55 <vixey> mmorrow: ah that's a really nice text
18:39:04 <mmorrow> vixey: totally
18:39:22 <joey_> I mean, there's no mandate that I write a compiler for an existing language
18:39:25 <mmorrow> vixey: i can't remember where i got it from though
18:39:42 <joey_> If anyone has any interesting ideas for something domain specific.
18:39:48 <vixey> I don't know where I read it, probably googled across it when I was obsessing over lisp
18:41:00 <mmorrow> joey_: QuasiQuotes ( http://haskell.org/haskellwiki/Quasiquotation ) are new and hugely expand the possibilities of embedding langs into haskell
18:41:02 <lambdabot> Title: Quasiquotation - HaskellWiki
18:41:11 <shapr> ddarius: But I do like you, thus the hug :-)
18:41:24 <mmorrow> vixey: heh
18:41:41 <stepcut> shepheb: the .hc files are generated in an earlier step. So perhaps they were never generated in the first place ? That could be because they are not supposed to be, but the manifest lists them when it shouldn't. Or the manifest is correct, but the files did not get generated. Or, you accidently did something which destroyed them.
18:41:53 <stepcut> shepheb: I forget how the manifest is generated though
18:43:04 * shapr hugs stepcut
18:43:28 * stepcut licks shapr
18:43:30 <shapr> yow!
18:43:41 <cjb> ello shapr.
18:43:44 <shepheb> stepcut: well, I'm going to try just removing those manifest lines and seeing if it will work in a minute
18:43:50 <stepcut> shepheb:  ;)
18:43:58 * shapr hugs cjb
18:44:09 <cjb> gosh, many hugs.
18:44:18 * stepcut gofers shapr
18:44:22 * vixey was trying to think of something to code also
18:44:54 * ddarius suddenly remembers he was reading a paper.
18:44:58 * shapr is just grabbing ghc 6.9 source for building on the XO
18:45:17 <stepcut> shapr: let me know if that works, we have on at work
18:45:34 <stepcut> s/on/one/
18:45:37 <shapr> stepcut: Are you using the latest stable XO software?
18:46:42 <stepcut> shapr: no, everyone (children included) hated it, so we put it up high on some shelf and left it there ;)
18:46:57 <LordBrain> XO as in "the $100 pc" ?
18:47:12 <kiris> heh, I just tried to compile some code with a module that doesn't exist yet imported, thinking that it the import would be "lazy" >_>
18:47:17 <ddarius> Here vixey, add local modules to GHC.
18:47:28 <stepcut> kiris: ;)
18:48:21 <shapr> stepcut: Want to get rid of it?
18:48:41 <shapr> I'll offer you a fair price for it :-)
18:49:06 <dmwit> ?pl \l -> forM_ allModules (mapM_ putStrLn . flip runModule l)
18:49:06 <lambdabot> forM_ allModules . (mapM_ putStrLn .) . flip runModule
18:49:18 <stepcut> shapr: dunno, it's not mine. In theory, it is relevant to our business, so we might hold onto it for a bit
18:49:23 <shapr> stepcut: Ok
18:51:35 <shapr> hiya andyjgill! How's the new job?
18:53:34 <vixey> hmm it seems a bit too hard
18:54:36 <ddarius> vixey: I wouldn't think it would be that hard.  You could probably do a hacky version pretty easily.
18:56:49 * shapr boings quietly
19:00:04 <mmorrow> shapr: what do you consider a fair price for an XO?
19:00:16 <shapr> Probably $250
19:00:26 <hpaste>  povman pasted "Binary" at http://hpaste.org/8694
19:00:27 <mmorrow> o
19:00:47 <shapr> The market on ebay fluctuates dramatically. I've seen as low as ~$150 and as high as ~$350
19:01:13 <povman> ^^ doesn't compile because it doesn't know the type of 'a'. Is there an extension that will let me do it anyway?
19:01:28 <mmorrow> wow, i'm suprised by that since (most) everyone that has one had to pay double price for it
19:01:29 <shapr> mmorrow: Why do you aske?
19:01:35 <roconnor> it used to be a $100 PC, until the US dollar crashed :P
19:01:37 <mmorrow> shapr: i have two
19:01:40 <shapr> mmorrow: Cool!
19:01:48 <mmorrow> shapr: yeah, they're pretty nifty
19:01:52 <shapr> mmorrow: How'd you get two?
19:02:04 <mmorrow> i bought two through give-one-get-one
19:02:10 <shapr> oh, neat
19:02:18 <shapr> I didn't have any money then, so I got mine on ebay.
19:02:35 <mmorrow> heh, if ida only known they'd be going for so cheap
19:02:53 <mmorrow> but since two kids got one, i dont regret it
19:02:59 <shapr> mmorrow: The downside is that the ebay items aren't always in good shape.
19:03:11 <mmorrow> ah, yeah
19:03:35 <shapr> And they usually don't have the T-Mobile subscription either.
19:03:50 <mmorrow> oh, yeah....i forgot about those
19:03:50 <shapr> I think one of mine was sold to me specifically because the keyboard is sticking.
19:03:59 <mmorrow> ha
19:04:05 <mmorrow> how many do you have then?
19:04:08 <shapr> Only two
19:04:27 <shapr> In any case, don't feel bad about doing the G1G1 thing, it's the best choice.
19:04:31 <cjb> shapr: the repair centers'll fit you a replacement keyboard now, at least.
19:04:36 <shapr> ooh!
19:04:57 <mmorrow> shapr: yeah, i don't :)
19:05:00 <shapr> mmorrow: Of course, one benefit of living just outside of Boston is that I've been to the OLPC offices THREE TIMES!
19:05:10 * shapr boings furiously
19:05:23 <stepcut> shapr: ;)
19:05:30 <mmorrow> shapr: lol
19:05:38 <dolio> Lots of boinging today.
19:06:22 <shapr> cjb: Is the Cambridge repair center still alive?
19:06:29 <cjb> I don't think so
19:06:33 <shapr> oh, too bad
19:06:51 <asdftimo> hey guys. is there a way to have "elem" work as if it is in a sorted list, ie in elem n (x:xs) if n<x FALSE?
19:07:03 <dmwit> Yup, use orderedElem.
19:07:09 <asdftimo> thanks
19:07:32 <dmwit> orderedElem    x = isPrefixOf [x] . dropWhile (< x) -- from module Dmwit
19:07:47 <dmwit> I think isPrefixOf is in Data.List.
19:07:56 <ddarius> @index isPrefixOf
19:07:56 <lambdabot> Data.List
19:08:14 <ddarius> We have machines so we don't -have- to think.
19:08:29 <asdftimo> lol @ ddarius
19:08:36 <hpaste>  povman annotated "Binary" with "simplified version" at http://hpaste.org/8694#a1
19:10:04 <dmwit> ?pl \x -> isPrefixOf [x] . dropWhile (< x)
19:10:04 <lambdabot> ap ((.) . isPrefixOf . return) (dropWhile . flip (<))
19:10:14 <dmwit> Yeah, I think I'll keep the pointful version.
19:10:29 <hpaste>  povman annotated "Binary" with "and the error message..." at http://hpaste.org/8694#a2
19:19:14 <povman> ^^ peh, nevermind I'm an idiot
19:19:59 <povman> (don't code `par` sleep)
19:30:16 <shepheb> okay, the target-side stuff is failing now because the $(GHC) variable is empty.
19:30:42 <shepheb> should I have a ghc-inplace after I copy the *-hc.tar.gz?
19:34:40 <stepcut> shepheb: I don't think so
19:35:13 <shepheb> hmm then something is screwy, it seems to be expecting me to already have a GHC when I make the libraries.
19:35:48 <shepheb> perhaps the order is screwy? it seems odd a priori to build the libraries before the compiler
19:36:26 <stepcut> shepheb: I think you first generate .hc files (which are just source). Then you move those onto the architecture you actually want to build on. Then you compile those to build a ghc-inplace compiler, which will be used to build the libraries
19:37:00 <stepcut> shepheb: even during a normal build of ghc on a support platform, like x86-linux, there compiler gets built a few different times and ways
19:37:10 <stepcut> and the libraries get built atleast twice
19:37:23 <stepcut> which is why removing the extra libs from base helps a lot
19:37:46 <stepcut> i think the ghc compiler gets built 3 times (stage1, stage2, and final)
19:38:44 <shepheb> well, I'm manually performing the steps of the script supposedly used to bootstrap from hc files.
19:39:13 <shepheb> namely distrib/hc-build
19:39:18 <jre2> is ghc HEAD stable enough to play around with?
19:40:29 <gwern> sometimes. sometimes it won' build tho
19:42:28 <stepcut> http://nhlab.blogspot.com/2008/07/extending-asterisk-with-happs.html
19:42:29 <lambdabot> Title: n-heptane lab: Extending Asterisk with HAppS, http://tinyurl.com/6nxvv7
19:42:35 * stepcut pimps himself
19:43:05 * shepheb tries compiler before libraries for kicks
19:43:32 <stepcut> shepheb: yeah, I remember doing things like that too (doing what the scripts are supposed to do, but one step at a time by hand)
19:44:13 <stepcut> shepheb: I think maybe you set $GHC by hand at some points in time
19:44:41 <shepheb> well, I would've done that if I'd had one to set; I don't have one on the target yet.
19:46:37 <stepcut> yeah
19:46:41 <stepcut> I figured ;)
19:48:28 <vixey> umm
19:48:40 <vixey> what does Illegal polymorphic or qualified type: forall a. a mean?
19:48:45 <stepcut> hehe
19:48:51 <shepheb> argh compiler failed too, it wants -lHSregex-compat... which is a library?
19:49:06 <stepcut> shepheb: yeah
19:49:17 * shepheb is catch-22'd
19:49:22 <vixey> oh
19:49:32 <vixey> I have Ctr (forall a. a) but you have to write forall a. Ctr a
19:49:58 <stepcut> shepheb: in theory, the hc bundled should contain .hc files for all the compiler and libraries
19:50:07 * stepcut goes out to the store
19:50:07 <vixey> hm... how do I make an untuped hetrogenous list?
19:50:14 <shepheb> yeah, that's what I thought too.
19:50:38 <vixey> [forall a. a] doesn't work
19:54:06 <dolio> [exists a. a]
19:55:55 <pa-ching> So for runtime typeclass function calls, Haskell passes around a dictionary with the instances, I believe? In that case, how are the dictionary keys generated?
19:56:57 <jre2> not all haskell compilers do, iirc
19:57:07 <dolio> The keys would be some internal representation of the name of the function.
19:57:32 <pa-ching> Hmm, so it's just mangled enough to be unique?
19:57:46 <pa-ching> Yeah I guess implementation dependent
19:58:06 <pa-ching> Just wondering I'd go implementing it...
19:58:09 <dolio> Yeah, I don't know what exactly GHC does, but that'd be the idea.
19:58:11 <pa-ching> how I'd*
19:59:00 <dolio> jhc would pass around a representation of the type at runtime instead of a dictionary.
19:59:57 <pa-ching> It'd have to be a dictionary or something at some point though eh if you can have any number of instances for a type
20:00:17 <pa-ching> Hmm... oh well.
20:00:27 <dolio> What would?
20:00:38 <pa-ching> The representation
20:00:46 <kiris> @hoogle [a] -> Maybe [a]
20:00:47 <lambdabot> Data.List.stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]
20:01:29 <dolio> No, it just passes the type.
20:01:33 <dolio> Not a dictionary of functions.
20:01:49 <pa-ching> Er I mean, what would the type be carrying?
20:02:03 <ddarius> pa-ching: The "dictionaries" aren't hash tables or maps or anything.  It's just a tuple.
20:02:25 <pa-ching> OK, thanks
20:02:30 <dolio> The type representation would be like an algebraic data type.
20:03:02 <dolio> data Type = PrimInt | PrimDouble | Pair Type Type | ...
20:03:12 <pa-ching> Okes
20:03:48 <pa-ching> (Maybe I'm missing something but I'm still not sure how you do the runtime dispatch with that)
20:03:51 <dolio> Although it's open, and automatically generated by the compiler, of course.
20:04:04 <dolio> You do case analysis on the type.
20:05:12 <dolio> instance Foo Int where f = ... ; instance Foo Double where f = ...  becomes something like 'f PrimInt = ... ; f PrimDouble = ...'
20:05:42 <pa-ching> Oh. Er.
20:05:59 <dolio> In the intermediate language, where you can actually do that.
20:06:19 <pa-ching> So a whole-program-knowledge thing then?
20:07:08 <ddarius> Here's an interesting exercise.  What is the use of FP-style strictness analysis in LP?
20:09:22 <andyjgill> Hi shapr, very well!
20:09:35 <shapr> yay!
20:09:53 <Korollary> ddarius: LP = logic programming?
20:10:05 <shapr> lambda prolog?
20:12:14 <chessguy> Linear Programming is my guess
20:16:42 <jre2> anyone have any neat examples using quasiquotation?
20:18:49 <dolio> Some people were writing regular expression languages the other day.
20:22:35 <kiris> Cale: ping
20:22:45 <Cale> kiris: pong
20:22:51 <Cale> @bot
20:22:51 <lambdabot> :)
20:23:14 <kiris> Cale: I may have a patch for Î»b, should I darcs send to your e-mail? =o
20:23:27 <Cale> yeah
20:24:55 <Cale> I suppose I'll find out soon enough, but what's your patch?
20:25:51 <kiris> just a different function to extract the title from pages
20:26:08 <kiris> using tagsoup
20:26:26 <Cale> cool
20:28:20 <HunterXHunter2> @bot
20:28:20 <lambdabot> :)
20:28:37 <HunterXHunter2> @ping
20:28:38 <lambdabot> pong
20:28:50 <kiris> successfully sent, it says =o. feel free to have a gander
20:30:07 <Cale> Hasn't shown up in my inbox yet, but I'll check again in a few
20:30:27 <kiris> ah, oki
20:32:29 <kiris> it supports entities, returns Nothing when the string is empty "", and just has the benefit of parsing all the strange ways people write their HTML thanks to TagSoup
20:34:07 <vixey> How do I make a hetrogenous list ?
20:34:20 <vixey> [forall a. a] can't do it
20:34:42 <Cale> vixey: That would be a list of undefined values :)
20:35:10 <Cale> vixey: You can't do it with the standard list type, except by creating a type which subsumes all the cases you want to handle.
20:35:42 <vixey> there's no way to write this:?
20:35:43 <vixey> unquote :: [(String,forall a)] -> Raw -> forall a. Term a
20:36:17 <hpaste>  kiris pasted "I want to see what the diff looks like on hpaste" at http://hpaste.org/8695
20:36:22 <Cale> I'm not sure that you understand what the type (forall a. a) means
20:36:34 <hpaste>  kiris annotated "I want to see what the diff looks like on hpaste" with "modified" at http://hpaste.org/8695#a1
20:36:56 <Cale> If some value v has that type, it means that for any type a, v has type a
20:37:15 <Cale> That is, v is as polymorphic as can be. In Haskell, the only value of that type is undefined.
20:37:42 <Euler_> is it possible to go from [IO a] -> IO [a] without leaving the IO Monad?
20:37:51 <Cale> Euler_: sequence
20:38:11 <Cale> Euler_: In fact, the code for sequence is so enlightening, that it's a good idea to read it :)
20:38:14 <Cale> @src sequence
20:38:14 <lambdabot> sequence []     = return []
20:38:14 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
20:38:14 <lambdabot> --OR
20:38:14 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
20:38:15 <roconnor> @type sequence
20:38:16 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
20:38:42 <Euler_> oh it works cool!
20:38:57 <Euler_> yeah I gotta check that out
20:39:04 <vixey> @hoogle unsafeCoerce
20:39:04 <lambdabot> Unsafe.Coerce.unsafeCoerce :: a -> b
20:39:05 <nolrai_East> whats the best way to get an random element of a Set?
20:39:38 <ddarius> LP = logic programming, yes.
20:40:11 <vixey> oh ok
20:40:12 <Korollary> ddarius: I think it may have a place
20:40:13 <vixey> *Main> (foo !! 0) :: Integer
20:40:13 <vixey> 965
20:40:13 <vixey> *Main> (foo !! 1) :: String
20:40:13 <vixey> "foo"
20:40:14 <vixey> it's that easy
20:40:23 <vixey> you just give the type foo :: [x]
20:40:48 <Cale> vixey: That's rather evil.
20:40:53 <Korollary> ddarius: They similarly don't implement breadth-first search even though it's more correct due to performance reasons
20:40:59 <Cale> vixey: You'll easily end up crashing your program that way.
20:41:16 <vixey> if I don't write a buggy program I wont crash
20:41:39 <nolrai_East> Korollay: and termination reasons too.
20:41:49 <Cale> vixey: A better way is to simply create a datatype which enumerates the possible cases.
20:41:50 <chessguy> if you're going to completely bypass the type system, why not write it in some other language?
20:42:00 <vixey> Cale: that's impossible in my case
20:42:04 <Cale> vixey: Why?
20:42:15 <Cale> vixey: You can only use finitely many types in your program.
20:42:54 <Cale> and if you're writing a library, well, I'm pretty sure your users don't want to have to fear treating elements of a list accidentally as the wrong type and having everything die
20:43:53 <nolrai_East> is there a way to get to the nth element of a Set in better then O(n) time?
20:43:59 <chessguy> otherwise they wouldn't use haskell...
20:44:12 <ddarius> Korollary: There are more reasons than just performance for why breadth-first search is not used or alternatively iterative deepening.
20:44:14 <roconnor> use Data.Seq
20:44:42 <kiris> could you just use existentials and a type class?
20:44:47 <nolrai_East> roconnor: is that to me?
20:44:52 <roconnor> yes
20:45:12 <nolrai_East> thanks
20:45:50 <nolrai_East> roconnor: do you mean "Data.Sequence"?
20:45:57 <Cale> yeah
20:46:12 <kiris> vixey: http://www.haskell.org/haskellwiki/Existential_type maybe ?
20:46:13 <roconnor> yeah
20:46:13 <lambdabot> Title: Existential type - HaskellWiki
20:46:14 <Cale> Though it's a little sad that the Data.Set API lacks such an operation, given that internally, sets are counted balanced trees.
20:46:18 <mmorrow> vixey: but if you're not writing a library and what you want to do isn't possible within the typesystem then you have no choice :)
20:46:38 <Korollary> ddarius: like what?
20:47:05 <mmorrow> vixey: well, even if you're writing a library it's ok with proof
20:47:22 * vixey types unsafeCoerce . fromJust
20:47:31 <mmorrow> vixey: i've seen unsafeCoerce used in a few libraries
20:47:54 <Cale> vixey: What is it that you're actually trying to accomplish?
20:48:09 <vixey> I'll paste it if I get it to work
20:48:15 <ddarius> Korollary: Like the fact that most systems are not pure and thus breadth-first search or iterative deepening would result in effects happening in an even more cryptic order and quantity than they already do.
20:48:20 <Cale> vixey: I mean on a larger scale?
20:48:21 <vixey> (it would be great to get other ways to do it)
20:48:48 <Cale> What does your program do?
20:49:08 <Cale> It's really quite a silly idea to have a list of elements which you know absolutely nothing about their types.
20:49:17 <Korollary> ddarius: Yeah I was ignoring side effects. They need something like monads again.
20:49:22 <vixey> I know everything about the types
20:49:28 <nolrai_East> yeah and i need both the auto sorting, and the quick retrival. so weather to use Sequence with sorting, or Set and tranform to Sequence is a nontrivial question to me.
20:49:32 <Cale> Then why not encode it in the type system?
20:50:03 <Cale> Create a type which expresses what you know about the types of the elements of the list, and use that as your list element type.
20:50:20 <ddarius> Korollary: I have heard of "pure" LP systems that used different search orders.  On a different tack, I have considered whether the monad in LolliMon could be abused for this purpose.
20:51:07 <Korollary> ddarius: I think in some implementations you can plug in a different search strategy for wisely chosen portions.
20:51:10 <mmorrow> like newtype Exp t = Exp t (forall a. a)
20:51:25 <Cale> That's a rather useless newtype
20:51:39 <mmorrow> well, obviously unsafeCoerce is required
20:51:39 <Cale> The only value of type forall a. a is undefined.
20:51:51 <mmorrow> what if you put template-haskell's Type as the t
20:51:56 <ddarius> Korollary: In Oz, in particular, you can program search strategies arbitrarily.
20:51:58 <mmorrow> and do your own type inference
20:52:06 <roconnor> if you are going to unsafecoerce, I think GHC.Any is better than (forall a.a)
20:52:11 <Cale> Bah, don't use unsafeCoerce.
20:52:16 <mmorrow> hehe
20:52:52 <mmorrow> i would never use it in anything at all critical unless i *had* to
20:53:09 <Cale> I think if you really want type system features that badly, you're better off contributing to GHC.
20:53:31 <mmorrow> i'm slowly learning ghc :)
20:53:36 <vixey> ok
20:53:58 <hpaste>  vicky pasted "unquote" at http://hpaste.org/8696
20:54:04 <vixey> (in progress)
20:54:05 <Cale> Regardless, unsafeCoerce should never be your first line of attack.
20:54:11 <mmorrow> i agree
20:54:44 <vixey> you can try the example, it doesn't crash
20:54:56 <mmorrow> hehe, famous last words
20:55:00 <roconnor> nolrai_East: I think you should be able to easily wrap up Data.Sequence to aways insert in order.
20:55:57 <nolrai_East> roconnor: have it sort as I insert?
20:56:15 <kiris> Cale: well, my sendmail probably is not setup properly. I guess you could pull from http://code.haskell.org/lambdabot or I'll figure out how to make the patch into a tarball and e-mail it manually tomorrow. night
20:56:15 <lambdabot> Title: Index of /lambdabot
20:56:38 <Cale> kiris: Oh, you just pushed it there?
20:56:47 <kiris> yeah
20:56:55 <kiris> oh, whoops
20:56:59 <Cale> kiris: Oh, then don't worry about it, I pull from there all the time.
20:57:04 <nolrai_East> The gedit code hilighting for Haskell is wrong. its anoying.
20:57:14 <kiris> no, I don't have access there. I mispasted. I meant http://chrisdone.com/lambdabot/
20:57:17 <kiris> sorry
20:57:19 <Cale> ah
20:57:26 <jre2> nolrai_East: that's why you should use vim
20:57:32 <vixey> is there a different way to do this?
20:57:40 <vixey> I know that template haskell is one other option
20:59:42 <roconnor> nolrai_East: sure, why not?
21:00:06 <Cale> kiris: Oh, you forgot to update the .cabal for lambdabot-utils. Don't worry though, I've got it :)
21:00:39 <roconnor> nolrai_East: hmm, I could be wrong about the easy insert
21:01:00 <Cale> A nice thing about my setup on code.h.o is that I'll immediately notice if there are new dependencies, since I have my own build of GHC and I only use my account for building lambdabot :)
21:01:15 <roconnor> nolrai_East: I am wrong. :(
21:01:17 <roconnor> nolrai_East: sorry
21:01:28 <mmorrow> vixey: interesting, i have to think about it
21:02:30 <nolrai_East> yeah, I think my options are either convert the Set to Seq, or write my own Set.  The second i most likly a little more efficent but much harder.
21:02:31 <Cale> Okay, your patch is in :)
21:02:31 <roconnor> ... reversing a Seq could be O(1) if they wanted.
21:03:01 <nolrai_East> roconnor: cant you just use left and right views?
21:03:15 <Cale> nolrai_East: Or contribute a patch to Data.Set, I suppose :)
21:03:39 <roconnor> nolrai_East: you mean for reverse?
21:03:51 <mmorrow> roconnor: i've totally thought that
21:04:05 <mmorrow> roconnor: i wonder why they actually *reverse* it
21:04:08 <Cale> actually, I wonder -- he might be able to use Data.FingerTree
21:04:12 <nolrai_East> roconnor: umm, that woudnt work would it?
21:04:13 <Cale> hmm
21:04:25 <roconnor> Cale: I was thinking that.
21:04:42 <roconnor> Hey, isn't Data.Set etc being rewritten at the moment?
21:04:48 <nolrai_East> oh yeah i asked about fingerTree before on something else.
21:05:01 <roconnor> now would be a good time to get them to implement nth element
21:05:17 <mmorrow> Seq is just a fingertree with a particular instance of Measured
21:05:39 <mmorrow> Data.Sequence that is
21:05:50 <ddarius> vixey: You can encode the environments and open terms in a typed way.
21:05:50 <Cale> roconnor: and split at nth element :)
21:05:50 <roconnor> mmorrow: I don't think that is as true as we wish
21:06:10 <mmorrow> really
21:06:11 <vixey> ddarius: By boxing and unboxing?
21:06:11 <kiris> Cale: ahh, yep. forgot about the cabal file :P oh dear, it's live!? hehe
21:06:11 <Cale> roconnor: Well, the code is specialised, but otherwise it is.
21:06:11 <roconnor> Cale: who's working on that for SoC
21:06:15 <nolrai_East> Cale: it would be a fairly simple patch, right?
21:06:23 <Cale> roconnor: I don't know
21:06:26 <mmorrow> roconnor: interesting
21:06:30 <roconnor> mmorrow: the code is specalized
21:06:33 <Cale> nolrai_East: To what?
21:06:42 <Cale> nolrai_East: To Data.Set? Yes.
21:06:42 <nolrai_East> Set?
21:06:51 <ddarius> vixey: "boxing and unboxing"?
21:07:06 <vixey> well I don't know how to do it really
21:07:20 <mmorrow> roconnor: i'm confused, are you saying this is good or bad?
21:07:40 <leoncamel> > isPrime p = p > 1 && all (\n -> p `mod` n /= 0 ) $ takeWhile (\n -> n*n <= p) [2..]
21:07:40 <lambdabot>  Parse error at "=" (column 11)
21:07:50 <mmorrow> roconnor: or is it specialized in such a way that it has lost its fingertreeness?
21:08:08 <roconnor> mmorrow: It's bad that haskell is so sucky that Data.Seq cannot just be an instance of fingertrees.
21:08:17 <nolrai_East> are FingerTrees useful
21:08:19 <mmorrow> roconnor: totally
21:08:28 <leoncamel> I found this code from haskell. but it can't works here, so where is wrong ?
21:08:57 <dolio> It's specialized in that FingerTree Whatever will never be compiled as efficiently as Seq, I imagine.
21:08:59 <kiris> @let isPrime p = p > 1 && all (\n -> p `mod` n /= 0 ) $ takeWhile (\n -> n*n <= p) [2..]
21:09:00 <lambdabot> Couldn't match expected type `Bool'
21:09:07 <chessguy> > let isPrime p = p > 1 && all (\n -> p `mod` n /= 0 ) $ takeWhile (\n -> n*n <= p) [2..] in isPrime 484721
21:09:08 <lambdabot>  Couldn't match expected type `Bool'
21:09:16 <bd_> precedence issue
21:09:19 <nolrai_East> > let isPrime p = p > 1 && all (\n -> p `mod` n /= 0 ) $ takeWhile (\n -> n*n <= p) [2..] in isPrime 3
21:09:20 <lambdabot>  Couldn't match expected type `Bool'
21:09:39 <bd_> >  let isPrime p = p > 1 && ( all (\n -> p `mod` n /= 0 ) $ takeWhile (\n -> n*n <= p) [2..]) in isPrime 3
21:09:40 <lambdabot>  True
21:09:43 <bd_> >  let isPrime p = p > 1 && ( all (\n -> p `mod` n /= 0 ) $ takeWhile (\n -> n*n <= p) [2..]) in isPrime 4
21:09:45 <lambdabot>  False
21:09:52 <ddarius> vixey: What do you mean by "boxing and unboxing"?
21:10:08 <mmorrow> dolio: oh yeah, i'd hope that's the case
21:10:49 <vixey> ddarius: I was just guessing at ways to encode this, I haven't thought of any that would work though
21:11:53 <nolrai_East> what is a FingerTree? I'm looking at the docs and they dont seem to say.
21:12:24 <Cale> Aha, you should be able to get a nice (multi)-set implementation using fingertrees and the monoid (Integer, Key a) (where Key is the type stolen from the paper)
21:13:02 <Cale> (where the Measured instance is the natural elementwise one on pairs)
21:13:03 <ddarius> vixey: Write unquote as a method in a type class.  That would handle undefined1 trivially.
21:13:36 <Cale> nolrai_East: There's a paper
21:14:00 <ddarius> Except for the Var case.  To handle the Var case you have to make explicit that Var x refers to some environment.
21:14:00 <Cale> nolrai_East: These docs? http://hackage.haskell.org/packages/archive/fingertree/0.0/doc/html/Data-FingerTree.html
21:14:10 <nolrai_East> Just noticed that.
21:14:11 <kiris> gulp
21:14:16 <nolrai_East> Cale: yeah.
21:14:17 <ddarius> vixey: Look at this paper for some ideas on how to handle that.
21:14:18 <ddarius> http://www.iro.umontreal.ca/~monnier/tcm.pdf
21:14:20 <kiris> Cale: what happened there?
21:14:29 <Cale> kiris: I'm not sure, I'll have a look :)
21:14:53 <Cale> Segmentation fault
21:15:10 <kiris> Cale: mmmkay. I've tested the Url module as it is and I only rewrote one function. it seems odd that it would cause a crash!
21:15:15 <ddarius> vixey: Ultimately, you should get a method operation like unquote :: Term t -> t
21:15:59 <ddarius> vixey: In fact, with an appropriate form of HOAS, you may be able to just do that.
21:16:35 <leoncamel> in http://www.haskell.org/haskellwiki/99_questions/31_to_41 , it seems the problem-31 is wrong. so can anybody fix it ?
21:16:54 <Cale> leoncamel: why not you? :)
21:17:08 <Cale> Yeah, there's definitely something wrong with that patch :/
21:17:12 <kiris> Cale: unless it's the change on line 123 from 2048 to 3048? I'd doubt it, though. I changed that because in some pages the title is further down. didn't expect you to accept the change >_>
21:17:22 <kiris> okay, well, I'll look through it
21:17:41 <vixey> cool will try that now
21:18:02 <hpaste>  vicky annotated "unquote" with "untyped lambda calculus" at http://hpaste.org/8696#a1
21:18:06 <vixey> Cale, that's what I was trying to do
21:18:08 <Cale> kiris: I'm basically just maintaining the repository. I accept most changes.
21:18:13 <leoncamel> Cale: OK. :)
21:18:13 <vixey> use haskell to evaluate untyped lamda terms
21:18:18 <kiris> Cale: sure
21:18:40 <Cale> kiris: Shall we try changing that 3048 back down?
21:18:56 <kiris> Cale: sure, why not :)
21:19:52 <Cale> well...
21:19:54 <vixey> that omega thing will just diverge away until you halt it
21:19:58 <Cale> http://www.iro.umontreal.ca/~monnier/tcm.pdf
21:20:03 <Cale> http://www.iro.umontreal.ca/~monnier/tcm.pdf
21:20:08 <Cale> nope ;)
21:20:35 <kiris> hmm. that is very strange. for PDF files it would never reach the code I changed because the content type is wrong
21:20:40 <kiris> so I'm not sure??
21:20:51 <Cale> hmm
21:21:38 <kiris> it's not segfaulting when it's being loaded, is it?
21:22:41 <Cale> @bot
21:22:41 <nolrai_East> vixey: I did that a while back. That was fun. (I even wrote a Lazy-K interpeter)
21:22:45 <lambdabot> :)
21:22:49 <Cale> > 1 + 1
21:22:56 <lambdabot>  2
21:23:08 <Cale> http://www.iro.umontreal.ca/~monnier/tcm.pdf
21:23:19 <Cale> heh
21:23:20 <vixey> nolrai_East: using haskells lambdas?
21:23:24 <kiris> hmm!
21:23:39 <vixey> oh directly rewriting on data?
21:23:53 <hpaste>  Cale pasted "output" at http://hpaste.org/8697
21:24:26 <nolrai_East> vixey: no using haskells lambdas. and exetensial types. or rather i think i did it both ways.
21:24:33 <nolrai_East> dont rember why.
21:24:43 <Cale> (the script mentioned is just a script which runs lambdabot in a loop)
21:24:48 <kiris> Cale: not much information..
21:24:49 <kiris> right
21:24:52 <vixey> nolrai_East: do you have the code? that sounds cool
21:24:57 <kiris> @tiny-url http://www.haskell.org/
21:25:04 <lambdabot> http://tinyurl.com/z2aba
21:25:10 <mmorrow> nolrai_East: what vixey said
21:25:20 <Cale> wait, what the...
21:25:28 <kiris> hm?
21:26:16 <Cale> Heh, interesting... lambdabot is somehow running, even though my screen session is gone.
21:26:25 <Cale> Not sure how that happened :)
21:26:30 <kiris> what has I done! ;_;
21:26:50 <hpaste>  kiris annotated "output" with "this is the whole patch..." at http://hpaste.org/8697#a1
21:27:08 <nolrai_East> no, I'm afraid that was a OS reinstal or 2, and a phisical move ago.  I *think* its on an unlabled cd *somewhere*. It wasnt too hard to write though.
21:27:36 <kiris> Cale: do you think loading the TagSoup module is causing issues? because I have no idea what could be causing a segfault otherwise
21:28:08 <mmorrow> nolrai_East: what was the *key* type at least?
21:28:18 <Cale> ah, there we are
21:28:22 <Cale> kiris: perhaps
21:28:27 <Cale> kiris: let me try it
21:28:35 <kiris> if you ran the old code but included the modules..
21:28:36 <kiris> ok
21:29:18 <mmorrow> nolrai_East: rephrasing, what is a oneline (new)type/data decl that captures the way you used existentials?
21:29:58 <Cale> kiris: hmm, it basically works in ghci
21:30:09 * kiris decides on an all-nighter (or all-dayer, as it stands..)
21:30:17 <kiris> Cale: okay
21:31:12 <kiris> well let me try compiling and runing it myself. I only tested it from ghci assuming it would be the same compiled
21:32:21 <nolrai_East> mmorrow: data Fun = Fun (Fun -> Fun) | FunInt Int --this was what i used the first time.
21:32:43 <Cale> kiris: huh...
21:32:55 <hpaste>  kiris annotated "output" with "works fine" at http://hpaste.org/8697#a2
21:33:08 <kiris> works fine for me when compiled O_O
21:33:11 <Cale> kiris: When I do  :m + Lambdabot.Url  from ghci, I get  "module main:Lambdabot.Url is not loaded"
21:33:18 <nolrai_East> I can't remember what the exetentials were for.
21:33:24 <kiris> Cale: woah, what
21:33:54 <kiris> Cale: what happens if you load a simple file that includes TagSoup?
21:34:13 <kiris> Cale: is your TagSoup build up to date? I'm just guessing here
21:34:29 <mmorrow> nolrai_East: cool
21:34:42 <Cale> kiris: It's 0.6, the same as in Hackage
21:34:49 <Cale> and yeah, that works fine
21:35:04 <Cale> Let me see if anything else from lambdabot-utils will load.
21:35:09 <kiris> oki
21:35:23 <kiris> haha, weird behaviour is weird
21:35:38 <Cale> Yeah, the *other* modules work fine...
21:36:15 <kiris> haha, I wrote such infeasibly poor code that Ghci rejects it!
21:36:38 <Cale> Heh, compiles it and then rejects it after.
21:36:51 <Cale> I'm going to clean up the dist directory and rebuild and see if that helps
21:37:03 <kiris> alright
21:38:08 <Cale> http://www.iro.umontreal.ca/~monnier/tcm.pdf
21:38:14 <Cale> huh...
21:38:32 <kiris> beard strokingly odd
21:38:34 <Cale> well, at least the Lambdabot.Url module loads now.
21:38:39 <kiris> ah?
21:38:46 <kiris> hm
21:39:20 <Cale> I'll rebuild the rest of lambdabot as well, and see if that helps.
21:39:26 <kiris> oki
21:39:58 <vixey> the lambdabot debugging is present in every channel
21:39:58 <Cale> Normally it's pretty good at figuring out when stuff needs recompiling, but the result with lambdabot-utils just now makes me less confident :)
21:40:05 <Cale> vixey: I'm aware.
21:40:27 <kiris> Cale: indeed
21:40:40 <Cale> I'm too lazy to edit the config :)
21:40:48 <kiris> hehe
21:41:22 <kiris> likewise, for lambdabot I wrote a script to download and install hackage packages so I didn't have to do it manually
21:41:59 <Cale> kiris: That exists. It is called cabal-install
21:42:07 * dolio apparently doesn't understand what cabal options are necessary to correctly install C parts of a library.
21:42:20 <Cale> http://www.iro.umontreal.ca/~monnier/tcm.pdf
21:42:24 <Cale> ...
21:42:26 <kiris> yay!!
21:42:29 <Cale> hooray!
21:42:31 <kiris> http://hackage.haskell.org/packages/archive/tagsoup/0.6/doc/html/Text-HTML-TagSoup-Type.html
21:42:38 <lambdabot> Title: Text.HTML.TagSoup.Type, http://tinyurl.com/5lquc4
21:42:40 <kiris> woo!
21:42:56 <Cale> great, so none of your fault :)
21:42:59 <kiris> :P
21:43:14 <Cale> I should add some cleanup commands to the build script perhaps :)
21:43:25 <kiris> hm, yeah =]
21:44:23 * kiris installs cabal-install
21:44:46 <Cale> Is it just me or is hackage.haskell.org down?
21:45:00 <kiris> it works for me
21:45:04 <Cale> huh
21:45:43 <Cale> oh, it's working now for me too...
21:46:06 <Cale> Just took a while to cabal update for some reason, and it doesn't reply to pings.
21:47:01 <kiris> what an interesting day :p
21:47:11 <Cale> kiris: Have you tried cabal-install? It's really nice.
21:47:18 <kiris> I'm trying it out now :)
21:49:24 <kiris> well, it's pretty fun getting code into lambdabot^_^
21:50:02 <Cale> :)
21:52:30 <Cale> kiris: btw, the 'build' script in lambdabot should download and install any extra packages you might need if you don't already have them
21:53:53 <kiris> Cale: ah, I had ran runhaskell Setup.* instead
21:54:28 <Cale> (barring cabal-install itself ;)
21:55:33 <kiris> ah. funny. I just realised I thought that the "runhaskell" stuff *was* cabal. except I've installed Cabal just now with "runhaskell", so I guess that was just ghc's clever package stuff
21:55:56 <Cale> Cabal itself comes with GHC
21:56:09 <Cale> cabal-install (and the cabal user command) is currently separate
21:56:15 <kiris> ahhhh
21:56:55 <kiris> you say "currently". do you hope that Cabal will be part of GHC in the future?
21:57:15 <Cale> Cabal-install should become part of cabal, and get bundled with GHC.
21:57:22 <kiris> ah
21:58:03 <Cale> At least in my opinion. I don't know what the plan is exactly, but I think it's something close to that :)
21:58:16 <kiris> cool!
22:02:33 <kiris> Cale: do you know what the story is behind the MiniHTTPS module in Lambdabot? was it written before Network.HTTP and such?
22:02:55 <Cale> dons would probably know
22:03:03 <Cale> He was the maintainer before me
22:03:19 <kiris> sure
22:03:22 <Cale> It's quite likely that they were. Lambdabot's been around for quite a while now.
22:03:44 <kiris> true
22:04:14 <kiris> seems like some bits were written before there were libraries to make that kind of thing easy
22:04:52 <Cale> Yeah, there's been a huge explosion of available libraries since I started using Haskell just a few years ago.
22:06:12 <ddarius> kiris: Yes it was.
22:06:36 <ddarius> kiris: The first version of lambdabot was in like 2002 or 2003.
22:07:40 <kiris> right
22:08:04 * kiris looks for more things to hack on
22:10:41 <kiris> hey what happened to the new hpaste?
22:37:28 <Zao> I've seen some code using an 'io $' construct to lift IO commands into a state transformer, but I can't seem to find any reference to it in hoogle.
22:37:35 <Zao> Is 'io' some function people reinvent?
22:37:44 <kiris> indeed
22:37:48 <kiris> usually short for liftIO
22:37:54 <Cale> Zao: Yeah, you'll probably see  io = liftIO somewhere
22:38:04 <bd_> :t liftIO
22:38:05 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
22:38:38 <Zao> I see, thanks.
22:39:50 <jre2> is there a good way to have a custom compose function (i.e., (.)) without name clashing issues? or can anyone recommend an alternative symbol that still conveys composition?
22:40:18 <Euler_> > dropWhile (\x->x==(_,True)) [("T",True),("F",False),("F",False)]
22:40:18 <lambdabot>  Parse error in expression at end of input
22:40:21 <Cale> What kind of composition?
22:40:44 <jre2> I'm playing with functional references
22:41:01 <Cale> Maybe reuse >>> from Control.Arrow?
22:41:50 <Zao> Euler_: <interactive>:1:19: Pattern syntax in expression context: _
22:42:16 <_zenon_> Euler: I don't think it's possible to pattern match like that
22:42:17 <jre2> hmm, that might not be bad. iirc, they have a relation to arrows as well
22:42:41 <Zao> > dropWhile snd [("T",True),("F",False),("F",False)]
22:42:42 <lambdabot>  [("F",False),("F",False)]
22:43:00 <_zenon_>  > dropWhile (\x->case x of (_,True) ) [("T",True),("F",False),("F",False)]
22:43:28 <shapr> @seen ivanm
22:43:28 <lambdabot> I haven't seen ivanm.
22:43:31 <shapr> foo
22:43:33 <bd_> hmm, do arrows and functional references belong to some higher class of composable objects that's just waiting to have a typeclass named after it?
22:43:34 <Cale> case x of (_,True) -> True; _ -> False -- if you're going to use case
22:43:51 <Cale> bd_: Category
22:43:55 <_zenon_> Cale: Yeah, didn't get the time to it, a premature enter there :)
22:44:02 <Cale> bd_: A typeclass for categories enriched over Hask.
22:44:24 <Cale> bd_: It'll be in the next GHC.
22:44:27 <bd_> heh
22:44:34 <bd_> :t (.)
22:44:35 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
22:44:41 <bd_> not in lambdabot yet I guess :)
22:44:45 <Cale> oh hey, what happened there?
22:44:49 <Cale> @undefine
22:44:50 <lambdabot> Undefined.
22:44:59 <Cale> :t (.)
22:45:00 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
22:45:05 <Cale> There we go :)
22:45:10 <_zenon_> nice
22:45:36 <Cale> I like a different generalisation for (.) itself.
22:45:58 <hpaste>  kiris pasted "can't tell which I prefer" at http://hpaste.org/8698
22:46:09 <Cale> I prefer reusing the arrow operators for categories enriched over Hask, because at least at the time being there are not as many of those as there are functors.
22:46:27 <bd_> :t (>>>)
22:46:28 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
22:46:54 <_zenon_> What is the main theory behind the Arrows?
22:47:26 <Cale> There are some papers describing formalisms into which they fit.
22:47:27 <nolrai_East> @Hoogle on
22:47:27 <lambdabot> Maybe you meant: google hoogle
22:47:33 <nolrai_East> @hoogle on
22:47:33 <lambdabot> Data.Function.on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
22:47:33 <lambdabot> Test.QuickCheck.oneof :: [Gen a] -> Gen a
22:47:33 <lambdabot> Language.Haskell.Pretty.onsideIndent :: PPHsMode -> Indent
22:47:37 <kiris> they're like machines in a factory with conveyor belts that you can attach to other machines with corresponding types
22:48:15 <kiris> http://en.wikibooks.org/wiki/Haskell/Understanding_arrows
22:48:22 <Cale> http://www.cs.ru.nl/~heunen/publications/2006/arrows/arrows.pdf
22:48:50 <Cale> (that link is if you're asking about a category theoretic formalism)
22:48:59 <proqesi> I'm building a haskell app but get an error "ghc: Can't find package.conf as C:\WIN\driver\package.conf.inplace" from the command "ghc --make Main monadius.res stub.o -o monadius -O -optl-mwindows -lwinmm". is this a common problem?
22:49:01 <_zenon_> Cale kiris:  tips deriving ( Ord ) ?
22:50:02 <nolrai_East> @src on
22:50:02 <lambdabot> (*) `on` f = \x y -> f x * f y
22:50:04 <_zenon_> I mean to say; Is there a specific order in which your tips will fall nicely? arrows.pdf before Understanding_arrows, or the other way around, or at the same time?
22:50:25 <_zenon_> Maybe I should just have said it,.... but I wanted to do it Haskell-ish
22:50:40 <_zenon_> After all, can you get too much haskell?
22:50:50 <Cale> _zenon_: Oh, if you don't already know what arrows are about, and you're not a category theorist, don't bother with the paper I linked to yet :)
22:51:04 <koninkje> Given (Functor f) is there a generic way to write sequenceF :: (Functor f, Monad m) => f (m a) -> m (f a)? It seems like there should be, but the only way I can think of would require coreturning out of the monad...
22:51:09 <nolrai_East> programers(myself included) make the worst puns.
22:51:19 <_zenon_> Cale: No, I don't know arrows yet, therefore I would like an introduction.
22:51:27 <Cale> _zenon_: ah, okay
22:51:42 * SamB_XP just watched a demo while waiting for Firefox to load
22:51:45 <Cale> _zenon_: http://www.haskell.org/arrows/
22:51:46 <lambdabot> Title: Arrows: A General Interface to Computation
22:51:56 * SamB_XP thinks that's kind of pathetic
22:52:11 <_zenon_> SamB_XP which demo?
22:52:11 <Cale> That's the really-super-quick description :)
22:52:15 <bd_> koninkje: Wouldn't you need Data.Traversible at least, to give an order to it?
22:52:17 <joed> Firefox3 or the demo?
22:52:18 <SamB_XP> Heaven 7
22:52:25 <SamB_XP> joed: firefox 2
22:52:27 <bd_> Traversable*
22:52:27 <SamB_XP> actually ;-)
22:52:35 <Cale> http://www.haskell.org/arrows/syntax.html -- there are some more nice diagrams here :)
22:52:35 <lambdabot> Title: Arrow syntax
22:52:35 <bd_> :t Data.Traversable.sequence
22:52:35 <SamB_XP> maybe I should upgrade
22:52:36 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Monad m, Data.Traversable.Traversable t) => t (m a) -> m (t a)
22:52:37 <_zenon_> Ohh! John Hughes
22:52:39 <_zenon_> nice :)
22:52:40 <bd_> @ koninkje
22:52:44 <SamB_XP> but firefox hasn't been after me to do that
22:52:50 <joed> SamB_XP: nah, most things of use do not work.
22:52:50 <Cale> Do you know him?
22:52:57 <bd_> @src Data.Traversable.sequence
22:52:57 <lambdabot> Source not found.
22:53:00 <_zenon_> I had him in my introductory class :)
22:53:15 <Cale> _zenon_: oh, cool, you should just go and ask him what Arrows are then ;)
22:53:32 <_zenon_> http://www.cs.chalmers.se/~rjmh/
22:53:33 <lambdabot> Title: John Hughes
22:53:39 <chowmeined> how would i make a custom instance of a class with a tuple of a certain type?
22:53:41 <_zenon_> There you have him, he works at CTH
22:54:12 <koninkje> bd_: It's not so easy to make an instance of Traversable (I'm using coproducts rather than normal union types), so I was hoping category theory would win over boilerplate instances
22:54:14 <_zenon_> Cale: Hehe. Maybe, if I do the pasta and the table, maybe he will explain it :)
22:55:06 <bd_> koninkje: Well, it does need to give an order to things, so at the very least Foldable is needed...
22:55:13 <nolrai_East> what do the derived orders for data MyData = MyConstructor type1 type2 deriving (Ord, Eq) look like?
22:55:29 <Cale> nolrai_East: Lexicographic
22:55:42 <nolrai_East> sweet
22:55:44 <Cale> nolrai_East: Compare the first field, if they're the same, compare the second, and so on.
22:55:47 <_zenon_> Darn it, I should be working...
22:56:03 <koninkje> bd_: that's true...
22:56:09 <jre2> anyone know what the state of the record-access package is?
22:56:14 <bd_> koninkje: and then you need to build the thing back up again, which foldable doesn't give you
22:56:19 <kiris> chowmeined: maybe with -XFlexibleInstances
22:56:35 <chowmeined> kiris, then i get Overlapping instances for Show (t, Maybe t1)
22:57:11 <koninkje> bd_: the functors in question all have only one "element" (or none) so Foldable is fairly trivial, though that also requires boilerplate instances... alas
22:58:00 <bd_> koninkje: actually, I think it might be able to construct foldable and traversable instances using general sequence - to build foldable, use a state monad, map to modify the state variable by the functor's value and the fold function, then toss away the functor result and return the state
22:58:58 <kiris> chowmeined: what's the rest of your code? instance Show (t,Maybe t) compiles fine for me
22:59:19 <bd_> you can also mapM or traverse by converting to a list (using the state monad again) and back (by using a state monad to replace the contents of the functor in order)
23:00:14 <chowmeined> kiris, Overlapping instances for Show (t, Maybe t1)
23:00:20 <chowmeined> kiris, sorry..
23:00:24 <bd_> chowmeined: you'll need to newtype it to give it a new type
23:00:27 <chowmeined> kiris, Could not deduce (Show t) from the context (Show (t, Maybe t))
23:00:37 <bd_> newtype MyType t t1 = MyType (t, Maybe t1)
23:00:49 <bd_> now write a show instance for MyType t t1
23:00:54 <chowmeined> bd_, oh.. thanks
23:01:08 <kiris> chowmeined: `instance Show (t, Maybe t1) where' works fine for me. how are you implementing `show'?
23:01:09 <_zenon_> Arrows seem more general than monads
23:01:17 <dobblego> they are
23:01:17 <bd_> you'll need to use the MyType constructor here, in order to convert to and from
23:01:45 <Cale> _zenon_: they are, which means that while there are more instances, it doesn't mean as much for something to be an arrow.
23:01:46 <koninkje> bd_: I think all that conversion would be a bit expensive (in heap), moreso than a direct implementation I mean (which still isn't terribly heap friendly)
23:01:46 <bd_> chowmeined: you might also want to consider an ordinary data - newtype doesn't buy much when wrapped around a pair: data MyType t t1 = MyType t (Maybe t1)
23:01:56 <bd_> koninkje: actually it's free for newtype :)
23:02:17 <koninkje> bd_: to and from the lists I mean
23:02:25 * koninkje is using newtype extensively :)
23:02:26 <bd_> koninkje: oh! sorry, mixed up threads
23:02:36 <koninkje> no worries
23:02:43 <kiris> I don't think a newtype is necessary in this context
23:02:49 <bd_> koninkje: anyway, my point wasn't about efficiency, but rather proving that your general sequence implies Foldable and Traversable :)
23:02:52 <_zenon_> Cale: Precisely, like a monoid, doesn't actually give much in itself.
23:03:24 <bd_> koninkje: obviously my method is horribly inefficient, but - it works! I think. I haven't actually tried writing the instances :)
23:03:40 <_zenon_> Cale: Thanks for the link, seems nice, I will delve more into it, but I really have to work a bit also ;)
23:04:06 <koninkje> bd_: ah. That'd be true. In order to sequence we must pick some ordering of the contents, and that's the only real thing a fold adds that a fmap lacks...
23:04:29 <joed> _zenon_: it's only 8 am in Sweden, and 4th of July in the US, you clearly should have time.
23:04:38 <bd_> koninkje: we also need to be able to rebuild the structure from the results somehow
23:04:47 <bd_> which is what traversable adds
23:04:55 <chowmeined> bd_, how do you unwrap just?
23:05:01 <bd_> chowmeined: unwrap?
23:05:09 <chowmeined> bd_, er Maybe
23:05:18 <bd_> chowmeined: also, the newtype version or maybe version? :)
23:05:22 <koninkje> bd_: but fmap already does that (though I suppose you loose it in the fold)
23:05:30 <_zenon_> joed: Yeah, but I work from 07 to 16
23:05:54 <_zenon_> joed: So , right now, I "should" be working :)
23:05:59 <_zenon_> but Arrows seem much more interesting
23:06:03 <_zenon_> as usual
23:06:08 <joed> _zenon_: That is a horrible work schedule.
23:06:21 <bd_> koninkje: consider: sequence (const $ modify succ >> get) [return 1, return 1]
23:06:39 <_zenon_> joed: hehe, maybe, but your'e free from 16:00 -> 23:00 :)
23:06:41 <bd_> koninkje: you can replace elements with fmap, but the elements are indistinguishable
23:06:46 * koninkje ponders an unsafeInterleaveMonad solution...
23:07:04 <bd_> koninkje: as such, you can't do it with just fmap
23:07:21 <joed> _zenon_: I prefer to code / work 10-15:00 22:00-2:00
23:07:40 <joed> Or skip the first and extend the latter.
23:07:49 <koninkje> bd_: indeed. Come to think of it, I've encountered that particular state passing issue elsewhere too (and resolved it)
23:08:02 <_zenon_> but.... that's just 4 hours work ?
23:08:31 <joed> Well, depends on what you bill/produce :)
23:08:52 <_zenon_> joed: surely
23:09:10 <mmorrow> an excellently clear and well-colored graphviz diagram found in the lighttpd source distrib's doc dir (rendered with dot -Tpng): http://code.haskell.org/~morrow/misc/lighttpd.png
23:09:21 <_zenon_> joed: what do you do for a living?
23:10:14 <bd_> koninkje: you could always write an implementation for each functor you need
23:10:15 <joed> _zenon_: Self employed coder. Right now I'm writing childrens games (Videogames) extras, i.e if you do this/this/this I give you this type thing.
23:10:48 <_zenon_> joed: ah, okay.
23:11:09 <koninkje> bd_: That's what I've done so far. It's just the instances look the same (only pushing sequenceF down rather than pushing f down). I was just hoping to escape the boilerplate
23:15:50 <joed> _zenon_: It is a great way of life.. :)
23:16:10 <_zenon_> joed: I surely think so.
23:16:55 <povman> is there a nice way of pulling a complete ByteString from a Handle?
23:17:08 <bd_> :t Data.ByteString.hGetContents
23:17:09 <lambdabot> GHC.IOBase.Handle -> IO BSC.ByteString
23:17:14 <bd_> :t Data.ByteString.Lazy.hGetContents
23:17:15 <lambdabot> GHC.IOBase.Handle -> IO BSLC.ByteString
23:17:28 <povman> will that only pull a single one?
23:17:29 <bd_> there you go :)
23:17:41 <bd_> povman: it will pull all of the remaining data in the file as a single bytestring
23:17:58 <povman> oh - so bytestrings aren't terminated?
23:18:02 <bd_> note that if an IO error happens in the lazy version, your program will explode at some random point, if you're not careful
23:18:09 <bd_> povman: Well, bytestrings are just a bunch of bytes :)
23:18:14 <povman> i wasunder the impression Empty marked the end
23:18:14 <bd_> they're not nul-terminated like strings in C
23:18:30 <bd_> A ByteString is just a chunk of bytes (possibly 0)
23:18:50 <bd_> a Lazy ByteString breaks it into multiple chunks, and allows you to generate chunks streamily
23:19:21 <bd_> but, well, if you want to write a bytestring to a file, you'll need some way to mark the end of it :)
23:19:32 <bd_> Or use hGetContents and absorb the entire file
23:19:41 <povman> i'm trying to encode things using binary and send them across a network connectsion
23:19:51 <bd_> povman: You may be interested in Data.Binary
23:19:55 <povman> ^
23:20:46 <bd_> povman: ?
23:20:57 <povman> should i send the number of bytes then the string, or is there a nice wrapper for doing that?
23:21:04 <bd_> povman: Data.Binary is the nice wrapper :)
23:21:24 <povman> er - Data.Binary gives me a ByteString which i then have to send
23:21:32 <bd_> oh
23:21:51 <quicksilver> yes, you need some kind of top-level protocol
23:22:00 <quicksilver> which sends length markers
23:22:02 <quicksilver> proabbly
23:22:06 <bd_> hmmm
23:22:38 <povman> quicksilver: from the way you said that, i guess it doesn't already exist?
23:22:39 <bd_> I think there's a function in Data.Binary which returns the unused lazy bytestring - if you do a deep seq on the resulting structure you should be able to catch any IO errors, I think?
23:23:12 <bd_> actually forcing the first byte of the remainder bytestring ought to be enough
23:23:38 <povman> bd_: what do you mean?
23:23:45 <mmorrow> and the graphviz .dot src for that image http://code.haskell.org/~morrow/misc/lighttpd.dot.txt
23:23:50 * bd_ looks up the docs
23:23:58 <povman> it shouldn't be too hard to whip something up using from/toChunks
23:25:14 <bd_> hmm
23:25:16 <bd_> maybe I'm wrong
23:25:32 <bd_> yeah you'll need to send the length ahead
23:26:36 <povman> actually - if i just send a Data.Binary encoded bytestring, then use decode on a hGetContents on the other end - decode should know how many bytes to read
23:27:20 <bd_> povman: the danger is if you have an IO error, you don't necessarily know when it'll manifest as an exception
23:27:57 <bd_> you need to have a way to force it to deliver any such error at a point where you are ready to catch the error
23:28:02 <bd_> :t Data.ByteString.hGet
23:28:03 <lambdabot> GHC.IOBase.Handle -> Int -> IO BSC.ByteString
23:28:08 <bd_> ^^^ if you know how much to read
23:28:34 <povman> bd_: do you mean using hGetContents is dangerous?
23:30:43 <bd_> povman: hGetContents /with a lazy bytestring/ is dangerous
23:30:59 <bd_> and hGetContents on a network connection with a non-lazy bytestring will block until the socket is closed
23:32:57 <povman> >2 ^ 64
23:33:04 <povman> @bot
23:33:04 <lambdabot> :)
23:33:09 <povman>  > 2^64
23:33:18 <povman> feh
23:33:31 <povman> that should be a big enough number anyway
23:33:34 <mmorrow> s/^\s//
23:33:55 <mmorrow> > 2^64
23:33:56 <lambdabot>  18446744073709551616
23:34:09 <povman> what
23:34:19 <povman> > 2^64
23:34:20 <lambdabot>  18446744073709551616
23:34:23 <mmorrow> no leading spaces allowed
23:34:27 <povman> o
23:34:27 <mmorrow> :)
23:34:27 <vixey> >1
23:34:27 <vixey> > 1
23:34:27 <vixey>  >1
23:34:29 <lambdabot>  1
23:34:49 <kiris>  1 <
23:35:25 <povman> > "I can't imagine my bytestrings being more than " ++ show (2^64) ++ " bytes long"
23:35:26 <lambdabot>  "I can't imagine my bytestrings being more than 18446744073709551616 bytes l...
23:36:45 <povman> is that like 16 terrabytes
23:39:59 <Cale> It's 18 quintillion bytes, so 18 exabytes or so.
23:41:16 <koninkje> @src mapM
23:41:17 <lambdabot> mapM f as = sequence (map f as)
23:41:25 <Cale> Or exactly 16 exbibytes.
23:41:38 <kiris> I like that definition
23:43:49 <kiris> Cale: would you mind pulling some changes I made to Url.hs, if you're not busy? I'd left the previous entities replacement in there, so at the moment it's doing two passes. I've removed it and changed it to use ReaderT instead of passing the proxy around @_@
23:44:06 <Cale> Give me that url again?
23:44:15 <kiris> http://chrisdone.com/lambdabot/
23:44:16 <lambdabot> Title: Index of /lambdabot/
23:45:24 <Cale> Okay, building.
23:45:29 <kiris> yay!
23:45:33 <kiris> thanks
23:46:51 <Cale> Plugin/Url.hs:62:21:
23:46:51 <Cale>     Couldn't match expected type `Maybe ([Char], Integer) -> IO a'
23:46:51 <Cale>            against inferred type `Lambdabot.Url.WebReq [String]'
23:47:21 <Cale> kiris: ^^
23:47:42 <kiris> eek
23:48:14 <kiris> ahh, I didn't realise that
23:48:17 <kiris> sorry. I'll fix that
23:48:45 <kiris> I keep building the file in isolation to the rest of the project. lesson learned
23:48:50 <Cale> ah
23:49:44 <povman> "16 exbibytes ought to be enough for anyone"
23:51:40 <Cale> It's not nearly enough to store the entire visible universe. ;)
23:51:41 <kiris> well, now I'm not sure the ReaderT is a good idea if the functions are used from the outside. I would have to use runWebReq every time. would that be a bad idea? it sounds pretty bad..
23:52:01 <Cale> Not necessarily.
23:52:29 <Cale> It's probably only used in the Url module.
23:53:52 <kiris> ah well, I'll make a runWebReq function. there'll only be two calls to it. no problems
23:58:00 <povman> why does Data.ByteString.Lazy.hGet take Int instead of Int64?
23:58:11 <povman> everything else in that module uses Int64
