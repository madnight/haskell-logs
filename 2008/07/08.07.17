00:02:51 <geezusfreeek> @pl \x y -> 3^(3-y)*x
00:02:52 <lambdabot> (. ((3 ^) . (-) 3)) . (*)
00:03:04 <geezusfreeek> blecchk
00:04:19 <dolio> vixey: Hey.
00:08:04 <Quadrescence> Hey will I need these tools to implement pruning for searching the binary trees? http://en.wikipedia.org/wiki/Image:Pruning_Tools_M_D_Vaden.jpg
00:08:05 <lambdabot> Title: Image:Pruning Tools M D Vaden.jpg - Wikipedia, the free encyclopedia
00:09:00 <Quadrescence> I'm afraid the large bypass lopper is proprietary. :<
00:10:09 <vixey> dolio: I tried to make a community.haskell account but it refused :[
00:10:31 <dolio> Like, you got an e-mail saying no or something?
00:10:44 <vixey> the form said newline in ssh key, but there wasn't
00:11:04 <dolio> Huh, weird.
00:11:28 <dolio> I got mine a long time ago. I'm not sure it was a form then.
00:11:32 <dolio> I think I just e-mailed someone.
00:11:39 <vixey> oh I see
00:11:53 <dolio> I couldn't tell you who, though.
00:12:10 <vixey> I am trying to find somewhere to put my code so I can do something else -_-
00:20:50 <Quadrescence> @hoogle factorial
00:20:51 <lambdabot> No matches found
00:20:53 <Quadrescence> :<
00:21:44 <vixey> @pl return . Left <=< thaw
00:21:47 <lambdabot> (line 1, column 15):
00:21:48 <lambdabot> unexpected "=" or "<"
00:21:48 <lambdabot> expecting variable, "(", ".", space, operator or end of input
00:21:48 <lambdabot> ambiguous use of a left associative operator
00:22:52 <dolio> fmap Left . thaw?
00:24:51 <Quadrescence> Could someone help me make a fuction :: [int] -> [int] such that the input array is a list of 8 numbers (1 to 8 permuted in some order), and the output is an array that tells how many numbers to the left of each number in the input array are greater than that number? :<
00:25:25 <vixey> > inits [1,5,6,8,4,7,2,3]
00:25:41 <lambdabot>  thread killed
00:25:43 <vixey> @pl return . Left <=< thaw
00:25:44 <lambdabot> (line 1, column 15):
00:25:44 <lambdabot> unexpected "=" or "<"
00:25:44 <lambdabot> expecting variable, "(", ".", space, operator or end of input
00:25:44 <lambdabot> ambiguous use of a left associative operator
00:25:45 <vixey> > inits [1,5,6,8,4,7,2,3]
00:26:00 <lambdabot>  thread killed
00:26:06 <dolio> Awesome.
00:26:14 <vixey> > inits [1,5,6,8,4,7,2,3]
00:26:16 <lambdabot>  [[],[1],[1,5],[1,5,6],[1,5,6,8],[1,5,6,8,4],[1,5,6,8,4,7],[1,5,6,8,4,7,2],[1...
00:26:56 <vixey> > let countLessThan (e:xs) = length . filter (<e) $ xs in map countLessThan $ inits [1,5,6,8,4,7,2,3]
00:26:58 <lambdabot>   Non-exhaustive patterns in function countLessThan
00:27:46 <Quadrescence> ex. func [8, 2, 3, 5, 4, 1, 7, 6] = [0,1,1,1,2,5,1,1]
00:28:55 <dolio> What do you have so far?
00:31:27 <Quadrescence> I think vixey put me on the right track.
00:31:59 <dolio> Yeah, although another approach might be more efficient, if you care about that.
00:32:19 <Quadrescence> I do.
00:33:55 <dolio> Since inits is O(n^2), and then you want 'countLessThan l = let e = last l ; xs = init l ...' if I understand your original problem correctly.
00:34:08 <dolio> And that init is O(n), as is last.
00:35:27 <dolio> Interestingly, I think this problem is exactly a use for a zipper comonad. :)
00:35:45 <dolio> Although I won't couch it as such. :)
00:38:03 <dolio> Anyhow, I'd suggest you think about walking down the original list, keeping a list of the stuff to the left of where you are.
00:38:57 <vixey> you want to write a function  f list = ...
00:39:34 <vixey> since the list is in an awkward way,  then you would write f list = g (reverse list)
00:39:54 <vixey> now you need to rephrase the specification a little bit for 'g', but writing that should be easier
00:40:12 <vixey> > tails "Will also be useful"
00:40:14 <dolio> Yeah, you could do that, too.
00:40:16 <lambdabot>  ["Will also be useful","ill also be useful","ll also be useful","l also be u...
00:40:49 <dolio> That doesn't lead you to zipper comonads, though. So it's lame. :)
00:40:57 <vixey> (oh you might want to do f = g . reverse . tail)
00:41:46 * vixey imagines hyping up a new lisp, geared at writing webapps using zipper comonads
00:41:57 <dolio> Totally.
00:42:39 <dolio> And accessible printing functions, like pf and p.
00:42:45 <vixey> heh
00:43:11 <vixey> mm, does anyone know where I could find a derivation of topological sort?
00:47:23 <ertai> @users
00:47:25 <lambdabot> Maximum users seen in #haskell: 460, currently: 414 (90.0%), active: 6 (1.4%)
00:52:18 <vixey> why does GHC say     Could not find module `System.IO.UTF8':
00:52:23 <vixey> but ghci can load this module
00:54:07 <Quadrescence> How do you load the list module in GHC? :<
00:54:19 <Armored_Azrael> Quadrescence: import Data.List
00:54:23 <Quadrescence> GHCi *
00:54:26 <vixey> :m Data.List
00:54:39 <Quadrescence> Armored_Azrael: Thanks, vixey: thanks. :>
00:59:55 <augustss> hi
01:00:17 <vixey> hello
01:02:04 <Trinithis> are zippers both monads and comonads?
01:15:39 <dolio> Zippers are comonads.
01:16:14 <dolio> Zipper monads that people usually talk about (I think) are state monads with a zipper as the state.
01:16:42 <smtms> I want monads for dummies
01:16:44 <dolio> So you have monadic actions that walk around the implicit zipper, and an action for getting the current item.
01:22:38 <vixey> :(
01:22:43 * vixey has to generate fresh names
01:29:46 <Quadrescence> greaterThanList l = let countGT (a,b) = length $ filter (>a) b in map countGT (zip l (inits l))
01:30:00 <Quadrescence> or however you type it. That was my solution i just made. :>
01:30:24 <quicksilver> dolio: and changing it, indeed.
01:30:41 <dolio> Yeah, that too.
01:30:56 <quicksilver> I didn't realise zippers were comonads though.
01:31:00 <quicksilver> co-return is obvious enough
01:31:07 <quicksilver> what's co-join?
01:31:20 <dolio> Hold on, I'll paste it in a minute.
01:31:31 <quicksilver> ah, zippers are only comonads if the structure in question is a monad, right?
01:31:40 <quicksilver> so a list zipper is a comonad because lists are monads?
01:32:03 <dibblego> what is the data type declaration for a zipper?
01:32:05 <dolio> The list zipper is the cellular automata comonad, essentially.
01:32:17 <quicksilver> but "MyCustomeType" zipper won't be a comonad unless I can write a monad instance for MyCustomType
01:33:20 <dibblego> if you abstract over a type constructor, then my reading in this zipper tutorial is incorrect
01:34:21 <quicksilver> dibblego: was that a question or a statement? :)
01:34:55 <dibblego> it's a question; you seem to be implying that a zipper abstracts over a type constructor, yet I see no such thing in this tutorial
01:35:21 <dibblego> type Zipper a = (Thread a, Node a) -- I see this
01:35:28 <quicksilver> dibblego: zipper doesn't abstract in a clean way
01:35:34 <quicksilver> dibblego: but, for each type there is a zipper
01:35:37 <quicksilver> e.g. list -> list zipper
01:35:40 <quicksilver> tree -> tree zipper
01:35:45 <vixey> well not in haskell
01:35:49 <quicksilver> mycustometype -> mycustomtype zipper
01:36:03 <Quadrescence> How do you define a function locally inside another function again? :(
01:36:09 <quicksilver> it's not easy to express the general algorithm even in TH
01:36:10 <dibblego> Quadrescence, let or where
01:36:17 <quicksilver> because you need to think of names for constructors.
01:36:20 <mlLK> hi haskellers
01:36:25 <quicksilver> it's just a bit fiddly.
01:36:32 <dibblego> hm ok, cheers
01:36:32 <Quadrescence> can I define the type of the function inside the dunction?
01:36:37 <Quadrescence> f*
01:36:40 <dibblego> Quadrescence, yes
01:36:44 <quicksilver> Quadrescence: you can although people normally don't bother
01:36:49 <quicksilver> let f :: Int -> Int
01:36:53 <quicksilver>     f n = n +1
01:36:55 <dibblego> for some functions though, you cannot
01:37:06 <mlLK> oh neat
01:37:12 <mlLK> a zipper program?
01:41:51 <dolio> quicksilver: http://hpaste.org/8977
01:46:45 <dolio> quicksilver: I don't think that depends on the underlying structure being a monad.
01:46:50 <dolio> I could be wrong, though.
01:49:25 <quicksilver> dolio: well it certainly depends on it being a functor.
01:50:09 <dolio> That's true, I suppose.
01:51:06 <quicksilver> :t unfoldr
01:51:22 <lambdabot> thread killed
01:51:41 <vixey> does anyone know how to sort this?
01:51:41 <vixey> /var/folders/9U/9U2ymE5GFQa66b9pgg2VUk+++TM/-Tmp-/ghc63322_0/ghc63322_0.split__817.s:109:0:
01:51:42 <vixey>     FATAL:Symbol L_glVertex4iv$stub already defined.
01:51:56 <vixey> when compiling GHC
01:52:17 <quicksilver> dolio: unfoldr (dup.left) is a very obfuscated way of iterating left, isn't it?
01:52:25 <quicksilver> well "very obfuscated" being in the eye of the beholder.
01:52:43 <dolio> It iterates until there are no more lefts to be had.
01:52:57 * quicksilver nods
01:53:18 <quicksilver> so I'm wrong about it requiring functor.
01:53:25 <dolio> I have a personal bias against takeWhile . iterate. :)
01:53:29 <quicksilver> that fmap is the ((->) r) fmap?
01:53:40 <dolio> It's the Maybe fmap.
01:53:53 <quicksilver> ah. duh. right.
01:55:12 <quicksilver> so the co join has, at each place in the zipper, instead of the element, the zipper at that point.
01:55:40 <quicksilver> so you "insert the local context" at each element.
01:55:54 <dolio> Yeah.
01:56:19 <quicksilver> doesn't scale well to zippers which don't have the same type everywhere.
01:56:21 <dolio> The focused element is the zipper, To the left are the zippers you'd get by moving left, and to the right are the zippes you'd get by moving right.
01:56:23 <quicksilver> I don't think.
01:56:46 <quicksilver> but then they're not functors
01:56:54 <dolio> Yeah, I'm not sure about zippers for non-regular types and the like.
01:56:55 <quicksilver> so it wouldn't be surprising if they weren't comonads
01:57:20 <quicksilver> one of the few serious uses of zippers I have done was for such a type
01:57:22 <dolio> Perhaps you do need zippers of functors for this to work.
01:57:26 <quicksilver> just a general ADT
01:58:09 <vixey> > error "not yet implemented"
01:58:25 <lambdabot>  thread killed
01:59:15 <dolio> @undefine
01:59:17 <lambdabot> Undefined.
01:59:36 <dolio> > error "fubar"
01:59:37 <lambdabot>  Exception: fubar
02:01:02 <dolio> quicksilver: I'm not sure zippers of things that aren't functors would even have the right kind to be a comonad.
02:01:09 <johanj> quicksilver: we just wrote a paper about how to define zippers for systems of datatypes (ie zippers that do scale)
02:01:26 <quicksilver> dolio: no.
02:01:31 <vixey> johanj: is this online?
02:01:33 <quicksilver> johanj: I know how to do it, too :)
02:01:35 <johanj> see: http://people.cs.uu.nl/andres/Rec/
02:01:36 <lambdabot> Title: Generic programming with fixed points for mutually recursive datatypes
02:01:38 <quicksilver> johanj: and I did it, indeed.
02:01:55 <quicksilver> johanj: it's just I was saying they aren't functors and prbably aren't comonads.
02:02:10 <quicksilver> I didn't do it generically though.
02:02:19 <quicksilver> I thought about it but decided it was too much like hard work.
02:02:29 <johanj> it was hard work...
02:03:21 <vixey> thank you
02:03:48 <quicksilver> dolio: no, they wouldn't have a type parameter, or they'd have more than one :)
02:03:58 <dolio> Yeah.
02:04:00 <quicksilver> dolio: is the comonad instance for the zipper useful?
02:04:14 <quicksilver> does it let us use generic comonad combinators in a surprising and useful way?
02:04:51 <quicksilver> ah well I see your count example
02:04:53 <dolio> Can't say I've seen it used besides for dpiponi's cellular automata comonad.
02:05:20 <dolio> Yeah, that guy's particular function is nicely expressible in terms of it.
02:05:30 <quicksilver> I dont'have a very good feel for what good comonad combinators are.
02:05:47 <quicksilver> I know it's "worthwhile" writing a monad instance for somethign because then you get to use sequence and mapM
02:05:56 <quicksilver> which turn out to be useful.
02:06:55 <dolio> The original category extras didn't really have that many combinators.
02:07:29 <dolio> The only one I see is 'sequenceW :: [w a -> b] -> w a -> [b]' I'll have to think about what that means in the zipper comonad.
02:08:12 <dolio> Actually, that doesn't look that exciting.
02:09:12 <quicksilver> presumably that is not just \fs w -> map ($w) fs ?
02:09:19 <quicksilver> otherwise that's a really boring combinator
02:09:31 <quicksilver> ah.
02:09:36 <quicksilver> shouldn't it be w [b] ?
02:10:04 <dolio> That'd probably be more interesting.
02:11:20 <quicksilver> still seems like the wrong name
02:11:26 <quicksilver> should be mapW
02:11:29 <quicksilver> or comapW
02:11:49 <quicksilver> wouldnt' sequenceW have the type w a -> w [a] ?
02:11:59 <quicksilver> or something.
02:12:00 <quicksilver> hmm.
02:12:06 <quicksilver> I never know which arrows to reverse :P
02:13:00 <quicksilver> hmm. I guess the types are right.
02:15:46 <dolio> Let's see what edwardk has.
02:16:27 <dolio> mapW :: (w a -> b) -> w [a] -> b, parallelW :: w [a] -> [w a], unfoldW :: (w b -> (a,b) -> w b -> [a]
02:17:56 <quicksilver> mapW looks right.
02:18:03 <quicksilver> sequenceW still looks bizarre
02:18:11 <quicksilver> to me.
02:18:23 <dolio> It doesn't look like it has anything to do with comonads.
02:18:46 <quicksilver> sequence isn't about functions, so why would sequenceW be?
02:19:23 <dolio> Well, parallelW is the dual of sequence.
02:19:31 <dolio> sequenceW is something else.
02:19:54 <quicksilver> ah I didn't notice parallelW
02:20:06 <quicksilver> that's what I'd call sequenceW I think
02:20:15 <quicksilver> maybe I'm not following the logic of his naming convention
02:20:32 <dolio> Well, it's like cosequence.
02:20:58 <dolio> I don't know what a monadic analogue of sequenceW would be.
02:21:42 <dolio> (a -> m [b]) -> [a -> m b] doesn't seem right.
02:22:30 <dolio> maybe [a -> m b] -> a -> m [b]
02:23:20 <dolio> @type \fs a -> sequence . sequence fs $ a
02:23:22 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => [a1 -> m a] -> a1 -> m [a]
02:24:01 <dolio> sequenceW is just sequence in the (->) r monad.
02:24:20 <quicksilver> yes
02:24:26 <quicksilver> which is the same as map ($w)
02:24:30 <quicksilver> as I said
02:24:31 <dolio> Right.
02:24:35 <quicksilver> and doesn't make use of the comonad strucutre
02:24:38 <quicksilver> which seems wrong?
02:24:54 <quicksilver> is it supposed to be w [a -> b] -> w a -> [b]
02:24:55 <quicksilver> ?
02:26:33 <Feuerbach> I've just built GHC from darcs, but ghci doesn't understands key codes (it prints ^? when I press backspace, etc.). Also ldd doesn't show linkage against readline (but I suppose it can be linked statically). Any ideas how to resolve this?
02:26:57 <earthy> link to readline, or use rlwrap
02:27:03 <earthy> (the latter is probably easier)
02:27:51 <Feuerbach> how do I link to readline? I thought ./configure should do it automatically
02:29:46 <Feuerbach> I just can't understand why it went wrong
02:30:05 <earthy> you might not have it in your path
02:30:50 <earthy> (configure should pick it up if it is)
02:31:01 <earthy> you could just explicitly tell configure where it is
02:31:11 <earthy> --with-readline=/path/to/readline
02:32:56 <Feuerbach> 'ldconfig -p' shows libreadline.so.5 (libc6) => /lib/libreadline.so.5
02:33:29 <mmorrow> i changed my csv parser to use ByteString   http://hpaste.org/8978
02:33:33 <mmorrow> it's pretty fast
02:34:27 <mmorrow> (a *real* csv parser)
02:36:06 <Feuerbach> by the way, configure script doesn't mention readline at all... weird
02:36:29 <BeelsebobWork_> @pl (\x -> if (x ==0) then Nothing else Just x)
02:36:30 <lambdabot> ap (flip if' Nothing . (0 ==)) Just
02:36:39 <BeelsebobWork_> bah, that's horrible
02:36:48 <mmorrow> the ByteString version is about 2.4 seconds faster on a 205271 line file
02:37:00 <Feuerbach> @src if'
02:37:00 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
02:37:23 <quicksilver> if' c t e = if c then t else e
02:38:33 <Axman6> mmorrow: percent wise, how much faster?
02:38:37 <BeelsebobWork_> can you tell I'm trying to get something into Haskell from C land?
02:39:04 <mmorrow> i have a bunch of timings here http://hpaste.org/8978#a1
02:39:08 <jaj> BeelsebobWork_: hehe C's lack of proper typing
02:39:12 <mmorrow> the String version was about 4.6s
02:39:32 <mmorrow> ByteString about 2.2
02:39:55 <mmorrow> more like 2.3-4
02:40:04 <mmorrow> with bytestring-mmap it goes to 2.1
02:40:21 <mmorrow> (and i'm printing each individual cell to /dev/null)
02:40:24 <Feuerbach> earthy: btw, rlwrap doesn't help
02:40:34 <BeelsebobWork_> @i if'
02:40:35 <lambdabot> Maybe you meant: id ignore index instances instances-importing irc-connect . ? @ v
02:40:41 <BeelsebobWork_> @index if'
02:40:42 <lambdabot> bzzt
02:40:46 <BeelsebobWork_> fail
02:40:57 <BeelsebobWork_> something I have to define myself?
02:42:38 <mmorrow> Axman6: err, i meant       ByteString with regular IO => 2.145s       ByteString with mmap => 2.117s
02:43:06 <mmorrow> same function but with String and regular IO => 4.512s
02:43:51 <quicksilver> BeelsebobWork_: yes.
02:43:53 <quicksilver> BeelsebobWork_: or not.
02:43:58 <quicksilver> BeelsebobWork_: I've never want it.
02:44:22 <quicksilver> if you want a cute way to write if (x==0) then Nothing else Just x
02:44:31 <quicksilver> try : guard (x/=0) >> return x
02:54:40 <mmorrow> Feuerbach: no more readline. they switched to editline in 6.9+ since it's not gpl. it worked for me just to install all the editline libs with my pkg manager  (libedit i believe it's called)
02:54:58 <mmorrow> sudo yum install -y *libedit* *editline*
02:55:09 <mmorrow> (or whatever)
02:55:26 <mmorrow> unfortunately you'll have to rebuild ghc
02:55:35 <titusg> I need some help with existential types and hiding extra type info from users and type sigs
02:55:54 <titusg> I wrote about it on cafe here : http://www.nabble.com/Type-level-sets-with-GADTs%2C-fundeps-etc-td18465246.html
02:55:56 <lambdabot> Title: Nabble - Haskell - Haskell-Cafe - Type level sets with GADTs, fundeps etc, http://tinyurl.com/6on8xl
02:56:56 <vixey> > 8*8*8
02:56:57 * yitz looks at titusg's cafe post
02:57:12 <lambdabot>  thread killed
02:57:41 <Feuerbach> mmorrow: thanks for the tip, I'll try it
02:58:31 <Feuerbach> (maybe this should be in ghc faq?)
02:59:59 <vixey> addr c O O = Pair O c;addr c I I = Pair c I;addr O O I = Pair O I;addr I O I = Pair I O;addr c I O = addr c O I
03:00:00 <mmorrow> probably. it took me over a week to figure out what the hell was happening
03:00:04 <vixey> can it be written shorter?
03:00:11 <mmorrow> Feuerbach: probably. it took me over a week to figure out what the hell was happening
03:00:30 <lowki> idnar: wow you are a horrible person whats wrong with you who wants to read about polyphasic sleep haters
03:00:35 <lowki> lol
03:00:46 <idnar> lowki: heh
03:01:15 <lowki> oh well its okay the most hateful text i have ever read about polyphasic sleeping i must admit
03:01:39 <lowki> its like the board of nutrition that encourages obesity with their ridiculously large portions
03:01:59 <_Dae_> Obesity for the masses?
03:02:10 <ksandstr> literally
03:02:15 <mmorrow> vixey: that seems like the perfect kind of function to generate it's definition
03:03:00 <lowki> well idnar gave me a link to a sleep expert that encourages sleeping or "free running sleep" though he did mention one good thing that babies and animals polyphasically sleep
03:03:22 * vixey has written an adder machine
03:03:44 <lowki> stupid animals tend to sleep more than smart animals strangely enough it seems similar with eating
03:04:31 <lowki> from what he says anyways
03:04:40 <lowki> and some previous research i did
03:04:55 <lowki> apparently platapuses sleep like 18 hours a day or some other marsupial
03:05:16 <dibblego> playpuses are monotremes
03:05:29 <lowki> yea it was an australian animal
03:05:30 <dibblego> egg-laying mammals
03:05:40 <lowki> what freaks lol
03:05:41 <dibblego> echidna is the only other monotreme
03:06:00 <lowki> really i thought platapus was the only one
03:06:23 <dibblego> they are two
03:06:38 <lowki> cool
03:06:55 <lowki> i was thinking maybe humans could hatch from womb eggs that would be nice
03:08:10 <lowki> bypass the whole female getting pregnant stage with plastic replacements .u probably need heaters for fetal juices and what not stuff like shaking the egg and playing it music as early life input
03:08:11 <yitz> vixey: I don't get addr c I I = Pair c I and addr c I O = addr c O I
03:08:51 <jaj> http://hpaste.org/8979 hmm is this because my ghc is too old?
03:08:56 <mmorrow> vixey: heh, it took me a second to realize that's *add*r  and not addr(ess)
03:10:56 <vixey> hehe
03:11:05 <vixey> data Syntax = Syntax.
03:11:05 <vixey> then = Syntax. else = Syntax.
03:11:05 <vixey> if True  Syntax x Syntax y = x.
03:11:05 <vixey> if False Syntax x Syntax y = y.
03:11:15 <vixey> now I can write  if foo then bar else baz
03:12:25 <mmorrow> and also if foo else bar then baz
03:13:05 <mmorrow> == if (not foo) then baz else bar
03:14:23 <yitz> lowki: see Brave New World, by Aldous Huxley.
03:14:57 <olsner> parantheses aren't required in if, since it's a special syntax ... so you can write 'if not foo then baz else bar'
03:16:13 <mmorrow> that's not a regular if ;)
03:16:24 <vixey> http://rafb.net/p/dMekUA82.txt
03:16:33 <vixey> :/
03:16:35 <mmorrow> (although they may still not be required)
03:16:41 <vixey> &#955 should be a lambda character
03:17:23 <titusg> yitz: hi, any thoughts?
03:17:23 <vixey> oh and all those parenthesis can go
03:23:12 <yitz> titusg: well, the error is pretty obvious. you require the constraints in the definition of insert, but then don't satisfy them in insertChar.
03:30:06 <titusg> yitz: I want the constraint to be hidden from insertChar, that's what I thought existential types would achieve
03:34:27 <yitz> titusg: I don't understand. If you need the constraints, how can you expect to hide them? You can only insert something that is a member.
03:40:44 <yitz> titusg: would it make sense to include the constraints in the Box types? forall a. (Member..., If...) =>
03:42:36 <lowki> yitz: yep read it a bunch of times
03:43:01 <lowki> i was reffering mainly to my past life as a gray cetacean hominid
03:43:19 <lowki> we had the womb eggs for more host bodies and such
03:43:31 <lowki> well and the hybrids were always fun
03:43:35 <quicksilver> mostly we talk about haskell and functional programming here, lowki
03:43:42 <lowki> kk
03:43:43 <quicksilver> I'd appreciate it if you'd think along those lines
03:43:56 <lowki> lambda
03:44:56 <vixey> gamma
03:45:20 <_Dae_> Don't get me started on gamma... you'll be bored
03:45:28 <vixey> hm?
03:46:00 <_Dae_> Seriously.... I'll be all "electromagnetic radiation"
03:46:06 <vixey> oh
03:46:46 <lowki> gamma rays how would that be expressed in lambda calculus?
03:47:12 <lowki> lambda photonWave frequency
03:47:13 <yitz> lowki: you can use #haskell-blah for that stuff.
03:47:19 <lowki> kk
03:47:19 <vixey> I am really tired of dealing with alpha conversion
03:47:49 <_Dae_> ROFL! Not entirely sure..... It's all differential equations, so I could you could define it in terms of lambdas and d's
03:47:54 <vixey> I guess I should do HOAS for pattern matching
03:48:25 <_Dae_> on a more lambdarific note: anyone know a good tutorial for template haskell?
03:49:54 <vixey> other than the wiki has some examples, I don't know really
03:50:30 <ivant> guys, I'm trying to make this code typecheck, to no avail: http://hpaste.org/8980
03:50:31 <yitz> Haskell exposes many "alpha-geeks" as actually being "beta-geeks".
03:50:44 <_Dae_> huh?
03:50:49 <olsner> alpha-geeks? beta-geeks?
03:51:07 <ivant> GHC says "Illegal operator `.' in type `forall a . (([String] -> (a, [String])) -> (a -> String) -> IO [String])"
03:51:30 <vixey> ivant: -XRankNTypes  or something like that is needed
03:51:32 <BeelsebobWork_> olsner: I think he's trying to say that it exposes people who are just good programmers as good programmers instead of good programmers and good mathemetitians too
03:51:52 <BeelsebobWork_> in the mean time.. shouldn't this type check without the monomorphism restriction? http://hpaste.org/8982
03:52:05 <Baughn> vixey: Isn't that a rank-1 type?
03:52:17 <vixey> yes it is
03:52:19 <ivant> vixey, -XRankNTypes didn't help
03:52:20 <olsner> BeelsebobWork_: don't you mean {-# GHC_OPTIONS or something like that?
03:52:28 <BeelsebobWork_> oh, probably, yes
03:52:31 <quicksilver> yes, but RankNTypes turns on the 'forall' keywords
03:52:35 <olsner> or a LANGUAGE pragma
03:52:40 <vixey> oh well I don't know which flag it is for the forall
03:52:45 <quicksilver> well, it's one of a number of extensions which turns on the forall keyword
03:52:53 <BeelsebobWork_> adding GHC_OPTIONS in results in the same type error though
03:52:59 <BeelsebobWork_> any further ideas?
03:53:01 <quicksilver> RankNTypes, Rank2Types, ExistentialTypes, ScopedTypeVariables should all work
03:53:44 <mmorrow>  BeelsebobWork_: maybe giving ne a typesig in the where clause'll help?
03:53:58 <quicksilver> ivant: well drop the forall because that's not your problem.
03:54:06 <quicksilver> that's a distraction.
03:54:22 <lilachaze> BeelsebobWork_: {-# OPTIONS_GHC -XExistentialQuantification #-} or {-# LANGUAGE ExistentialQuantification #-}
03:55:09 <olsner> BeelsebobWork_: I think you're misusing ne for the liftM P case (P [Int] vs P [(a,b)])
03:55:24 <olsner> *F [(a,b)] I mean
03:55:53 <BeelsebobWork_> I'm missing what you're saying there olsner
03:55:55 <ivant> quicksilver, okay, then I get "Couldn't match expected type `a1' against inferred type `a'"
03:55:55 <yitz> "alpha-geeks" is a term invented by Tim O'Reilley, here played off the discussion about Brave New World. A desperate attempt at a parting comment as lowki moves that discussion to #haskell-blah.
03:56:04 <olsner> seems to me it should be liftM P arbitrary rather than liftM P ne
03:56:28 <BeelsebobWork_> olsner: nope, arbitrary can generate empty lists -- ne is an arbitrary for non-empty lists
03:56:59 <olsner> ooh, okay, I'm misreading things
03:57:09 <BeelsebobWork_> ne' is an arbitrary for non-empty lists containing only non-empty lists
03:57:09 <yitz> ivant: the type of getCases is too general. It can only work with b=String, because of the type fo parseCase.
03:57:43 <ivant> yitz, oops, pardon me, there was "a" instead of "b" originally
03:58:07 <mmorrow> BeelsebobWork_: maybe just start inlining things until it typechecks, then selectively uninline one-by-one until it breaks. that would be my strategy
03:58:39 <mmorrow> then once it breaks it'll probably be clear why
03:59:08 <BeelsebobWork_> ah, sorted
03:59:18 <mmorrow> what was it?
03:59:19 <BeelsebobWork_> both existential types, and adding a type signature for ne sorted it
03:59:25 <mmorrow> nice
03:59:42 <BeelsebobWork_> first time I've actually had to use existential types
04:02:07 <olsner> BeelsebobWork_: for me, adding -fno-monomorphism-restriction to the cmd line or the language pragma fixes the type error
04:02:24 <olsner> but GHC_OPTIONS -fno-etc didn't work
04:03:13 <olsner> ... because it's called OPTIONS_GHC :D
04:03:25 <BeelsebobWork_> ah, rofl
04:03:55 <BeelsebobWork_> well, I think I'll go for no-monomorphism-restriction, over existential types
04:07:16 <olsner> seems weird that enabling existential types would fix it; is it doing something weird like automatically disabling the MR?
04:07:56 <olsner> I thought it shouldn't change anything until you add type signatures which actually use existential quantification
04:09:07 <BeelsebobWork_> indeed
04:09:10 <BeelsebobWork_> tis a bit odd
04:09:36 <vixey> is having 4 nested where's a bad sign?
04:09:36 <BeelsebobWork_> @hoogle Arbirary a => Gen a -> Gen a
04:09:38 <lambdabot> Test.QuickCheck.resize :: Int -> Gen a -> Gen a
04:09:38 <lambdabot> Test.QuickCheck.variant :: Int -> Gen a -> Gen a
04:09:54 <ivant> {-# LANGUAGE ScopedTypeVariables #-} worked. Thanks!
04:09:55 <BeelsebobWork_> vixey: I'd call it a code smell, certainly
04:10:10 <BeelsebobWork_> @docs Test.QuickCheck
04:10:12 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/QuickCheck/Test-QuickCheck.html
04:10:19 <olsner> vixey: not as bad as a 17-tuple :D
04:10:24 <BeelsebobWork_> rofl
04:10:29 <Axman6> ha
04:11:29 <Baughn> vixey: Nested where's? Why.. are you shadowing names?
04:11:42 <Pistahh> hello
04:11:50 <Pistahh> how can I convert "3" to 3 at the ghci prompt?
04:12:04 <quicksilver> > read "3"
04:12:09 <vixey> lots of mapping <function> with <function> locally defined
04:12:10 <quicksilver> like that
04:12:19 <lambdabot>  thread killed
04:12:20 <Pistahh> quicksilver: that gives an error
04:12:33 <quicksilver> Pistahh: you need to choose the type
04:12:36 <quicksilver> read can return any type
04:12:38 <Baughn> vixey: Well sure, but where clauses are mutually recursive/ they can refer to each other
04:12:41 <Pistahh> quicksilver: how?
04:12:42 <quicksilver> try (read "3" :: Int)
04:12:50 <vixey> they are nested though
04:12:52 <vixey> I mean like
04:12:55 <vixey>  where ...
04:12:56 <vixey>    where ...
04:12:57 <Pistahh> quicksilver: that works, thanks
04:12:58 <vixey>       where ...
04:13:22 <olsner> but you can move names from inner where's into outer where's; most if not all names should be movable
04:13:40 <quicksilver> not if they capture local variables.
04:13:47 <quicksilver> although that would be a bit odd
04:13:52 <quicksilver> (if four levels did that)
04:13:54 <Baughn> vixey: Can we see your code? ;)
04:14:09 <olsner> hmm, yeah, ok ... so maybe not all, but those that don't capture would be movable
04:15:08 <vixey> Baughn, http://hpaste.org/8983
04:16:04 <Pistahh> quicksilver: and how to read '3' instead of "3" ?
04:16:22 <vixey> read . return $ '3'
04:16:25 <Baughn> vixey: Ouch
04:16:29 <quicksilver> Pistahh: read ['3']
04:16:52 <Pistahh> quicksilver: thx
04:17:11 <quicksilver> vixey: I would put 'hasConstructot' at the same level as 'takeOut'
04:17:26 <BeelsebobWork_> hmm, does anyone know of a version of manyTill in Parsec that *doesn't* consume the end condition
04:18:01 <olsner> vixey: abstract could move out to the top-level where I think
04:18:23 <quicksilver> vixey: you only *need* to nest the wheres where you capture pattern variables, really
04:18:30 <quicksilver> like XXXXXX captures 'term'
04:20:20 <vixey> the biggest problem is making up fresh namesa
04:20:43 <vixey> it's going to be awful set in a monad
04:20:55 <quicksilver> maybe you're too willing to name things?
04:21:00 <ksandstr> i just abuse '
04:21:04 <quicksilver> if something is only used once I'll happly make it a lambda
04:21:18 <quicksilver> e.g. XXXX looks like it could be a lambda
04:21:24 <vixey> objects in the AST need named
04:21:26 <quicksilver> unless there is more than what you pasted.
04:21:30 <quicksilver> yes this is true.
04:24:11 <Jedai> To read '3', digitToInt should be better, no ? Much faster than read
04:24:17 <Jedai> :t digitToInt
04:24:21 <lambdabot> Char -> Int
04:24:24 <quicksilver> yes.
04:24:32 <vixey> faster ? ...
04:24:48 <vixey> I don't think so
04:24:55 <dolio> Slightly.
04:24:57 <Jedai> vixey: read is a hog (but that's because it try too hard for most situations)
04:25:50 <vixey> > 10**(-200) < 10**(-300)
04:25:51 <SamB_XP> vixey: when did you learn to speak southern?
04:25:52 <lambdabot>  False
04:25:57 <Jedai> You think read would be faster ? I hardly how that could be, it has to do more checks
04:26:07 <vixey> SamB: southern?  o_o
04:26:17 <SamB_XP> vixey: yeah, "need named"?
04:26:33 <vixey> Jedai: I think the difference is so marginal you couldn't even make a comparison
04:26:57 <Baughn> Jedai: Well, how do you think read does it?
04:27:20 <Baughn> Not to mention that, yes, it's IO. IO performance is almost never an important issue.
04:27:22 <Jedai> Baughn: Same as digitToInt but it checks more things
04:27:47 * Baughn blinks at that last statement. That's not what i meant to say..
04:28:06 <vixey> it's kind of like wondering if  x++ or ++x is faster
04:28:21 <Baughn> ..in which language?
04:28:48 <Baughn> I once had to deal with a program where accidentally typing x++ would make a copy of a 200GB database
04:28:48 <Jedai> If it's an operation he does thirty time a second it won't do much difference, if he does it very often, it will do a difference I believe (well a benchmark is in order here gentlemen)
04:29:16 <Jedai> vixey: Actually, (++) is pretty costly if you do it wrong
04:29:27 <SamB_XP> Baughn: methinks that "x" was a BAD name for that variable
04:29:30 <vixey> -_-
04:29:45 <Baughn> SamB_XP: True. As I recall, it was called "d".
04:29:58 <Baughn> It was also program-global.
04:30:01 <dolio> read probably ends up like "digitToInt '3' + 0".
04:30:02 <SamB_XP> very slight improvement
04:32:08 <Jedai> dolio: Yeah, sure but it does other checks too, I'm pretty sure there is a difference (probably not important in our case, but I signaled it because I've seen many people realize that read was a problem in their program)
04:33:27 <dolio> well "digitToInt '3' + 0" is almost certainly slower than just digitToInt '3'.
04:33:35 <dolio> There's also a list const being built and destroyed.
04:33:40 <vixey> :(
04:33:40 <dolio> Cons, even.
04:33:42 <SamB_XP> hah
04:34:06 <vixey> "is IF faster than COND?"
04:34:26 <dolio> But, I mean, unless you're doing it an unbelievable number of times per second, I doubt you'll see a difference.
04:34:52 <Jedai> vixey: Probably not, that depends on the compiler, anyway you don't use it for the same thing :)
04:34:55 <vixey> I say that even if you are doing it an unbelievable number of times that it will not make a difference
04:35:31 <Jedai> vixey: Let us do a benchmark then, this kind of thing is not really intuitive
04:35:32 <dolio> Two function calls are the same speed as one function call?
04:36:15 <vixey> the algorithmic complexity is the same and the constant factors are nearly 0
04:36:19 <Jedai> @src Int read
04:36:19 <lambdabot> Source not found. It can only be attributed to human error.
04:36:29 <vixey> difference in
04:36:46 <Jedai> @src Read Int read
04:36:46 <lambdabot> Source not found. Sorry.
04:36:54 <SamB_XP> @src read
04:36:54 <lambdabot> read s = either error id (readEither s)
04:37:09 <SamB_XP> @src readEither
04:37:10 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
04:37:21 <Jedai> @src Int readEither
04:37:21 <lambdabot> Source not found. Maybe you made a typo?
04:37:23 <SamB_XP> lambdabot: NYAH!
04:37:30 <Baughn> @src Int read
04:37:30 <lambdabot> Source not found. You speak an infinite deal of nothing
04:37:39 <dolio> readEither involves reads and lex and such.
04:38:29 <olsner> @src ap
04:38:30 <lambdabot> ap = liftM2 id
04:39:36 <dcoutts> Shurique: did you get cabal-install working in the end? solve the problem with the '--global' flag?
04:39:58 <dcoutts> @seen Baughn
04:39:58 <lambdabot> Baughn is in #japanese and #haskell. I last heard Baughn speak 2m 28s ago.
04:40:09 <vixey> @src Baughn
04:40:10 <yitz> read is usually more of a problem because of its type, not because of performance.
04:40:10 <lambdabot> Source not found. Where did you learn to type?
04:41:04 <Jedai> dolio: Yeah, that's why I'm pretty sure it's much slower that digitToInt (which anyway is the right function to use here, I mean you don't have to artificially create a string for read in this case)
04:42:32 <Pistahh> I need to convert a number to the list of its digits. Now I do  map (\y -> read [y] :: Int) (show 234)   is there any more haskellish way?
04:42:50 <quicksilver> I think that's perfectly acceptable
04:42:54 <dolio> Yeah, you're right. the read version is more complex, really.
04:43:07 <quicksilver> arguably it's more elegant to do it by hand using div 10
04:43:09 <quicksilver> and mod
04:43:20 <dolio> More complex than I stated, that is.
04:43:22 <quicksilver> but heck, that code already exists in show, why not (ab)use it.
04:43:41 <Baughn> map digitToInt . show?
04:43:41 <quicksilver> why does this question come up about once a day? Is it an exercise in the wikibook or something? :)
04:43:45 <vixey> > map digitToInt . show $ 65465765456
04:43:48 <lambdabot>  [6,5,4,6,5,7,6,5,4,5,6]
04:43:57 * vixey guesses project euler
04:44:08 <quicksilver> Baughn: ping.
04:45:00 <dolio> It's more like 'either error id (case [digitToInt 3 + 0,""] of [] -> Left "No parse" ; [(d,"")] -> Right d ; _ -> Left "Ambiguous parse.")
04:45:20 <Baughn> quicksilver: Pong?
04:45:24 <Pistahh> quicksilver: no, I just decided to write a checker for the hungarian national id number. :)
04:45:30 <dolio> And that leaves out the step taken to get to [(digitToInt '3' + 0,"")], which, as I said, involves lex and such.
04:45:47 <SamB_XP> Pistahh: I really doubt that explains all the other askings ;-)
04:46:50 <quicksilver> Baughn: lambdabot. history. leaks.
04:47:00 <quicksilver> Baughn: I think you had some solution which improved things a bit?
04:47:27 <Baughn> quicksilver: Oh, right. I was going to see if the profiling tools /work/ with 6.8.3, too..
04:47:27 <yitz> > let digits = map (`mod` 10) . takeWhile (> 0) . iterate (`div` 10) in digits 2468
04:47:29 <lambdabot>  [8,6,4,2]
04:47:35 <dolio> Of course, the fact that read uses a function that attempts to lex haskell to check for trailing whitespace is kind of bizarre already.
04:47:57 <quicksilver> Baughn: do I remember that you concluded that the history module is basically useless, as well as being a memory leak, so might as well be excised?
04:48:04 <Baughn> quicksilver: But yeah. I've tracked down 99% of the leaking to seen (have to disable the whole thing), plus log keeping the /entire/ irc conversation in memory
04:48:12 <SamB_XP> dolio: eh?
04:48:24 <Baughn> You don't need to /disable/ log, unless nobody uses it. Just to disable the in-memory part
04:48:28 <SamB_XP> dolio: I thought it used that to lex haskell?
04:48:33 <quicksilver> Baughn: obviously 'seen' is actually useful so ideally we'd fix it.
04:48:40 <quicksilver> but the in-memory log seems just pointless
04:48:44 <quicksilver> I imagine that alone would help a lot.
04:49:28 <Baughn> quicksilver: Just remove the appendEvent call, then
04:49:55 <dolio> SamB_XP: Why do you need to lex haskell to reject "1234 foobarbaz{{{}}}}}" as a valid Int string?
04:50:20 <SamB_XP> dolio: oh, well, you don't I guess.
04:50:31 <dolio> That's all I'm saying.
04:50:42 <Baughn> quicksilver: Seen is too complex for me to want to bother. You could try rnf'ing the state at each call, I suppose
04:50:53 <smg> Pistahh:
04:51:00 <Pistahh> yep?
04:51:14 <SamB_XP> is that inherent to read or is that just a silly detail of the implentation for Int etc?
04:51:16 <smg> http://hpaste.org/8984 <--?
04:51:24 <smg> yitz: lovely
04:51:44 <quicksilver> Baughn: OK, I'll pass your comments on. THanks.
04:51:46 <smg> Pistahh: but yitz solution is the best
04:51:49 <dolio> SamB_XP: I'm pretty sure it's in readEither, which means it's baked into every read.
04:52:20 <SamB_XP> does it have to be, or can it be reworked?
04:53:16 <SamB> oh, hmm.
04:53:17 <yitz> smg: thanks, but I didn't invent it of course. Old Haskell folklore.
04:53:21 <SamB> Prelude> read "(1)" :: Int
04:53:22 <SamB> 1
04:53:22 <Jedai> SamB_XP: Yeah it can be, there are better alternatives to read
04:53:25 <smg> yitz: hehe :)
04:53:37 <dolio> I think you could just nix the call to lex and do 'all isSpace s' where s is the string output of reads.
04:53:47 <SamB> dolio: I guess it has to stay there :-(
04:53:51 <Jedai> But that depends on what you want read to do of course...
04:53:58 <dolio> Since that's all it's checking for.
04:54:42 <SamB> dolio: is what you are saying consistant with "(1)" parsing ?
04:55:02 <dolio> > read "(1)"
04:55:07 <lambdabot>  Exception: Prelude.read: no parse
04:55:09 <dolio> > read "(1)" :: Int
04:55:11 <lambdabot>  1
04:55:43 <dolio> Let me go refresh my memory.
04:57:02 <SamB> not that I *care* about that particular case, but it has to parse parenthesized forms too, and changing the spec for what it can parse is a lot more involved than changing the implementation
04:57:27 <dolio> Oh, apparently it no longer uses lex.
04:57:32 <SamB> ah.
04:57:41 <SamB> so I guess that appearence was inessential?
04:57:46 <dolio> Yeah.
04:57:57 <dolio> It may have been readIO that uses lex, I can't recall.
04:58:31 <SamB> if ALL it was doing was checking for trailing junk, sure, that doesn't need lex ;-)
04:58:45 <SamB> I mean, it's not like read parses comments
04:58:49 <SamB> (I just checked ;-)
04:58:54 <dolio> It now uses P.skipSpaces
04:59:02 <SamB> yay P
04:59:04 <SamB> I love P
04:59:17 <osfameron> P ?
04:59:17 <SamB> I hope it's standardized
04:59:28 <SamB> @hoogle ReadP
04:59:31 <lambdabot> Text.ParserCombinators.ReadP :: module
04:59:31 <lambdabot> Distribution.Compat.ReadP :: module
04:59:31 <lambdabot> Text.ParserCombinators.ReadP.ReadP :: data ReadP a
04:59:41 <EvilTerran> parallel read
05:00:00 <EvilTerran> uses lists for nondet parsing
05:00:03 <quicksilver> Baughn: well, if you go ahead and darcs send a patch which cuts out appendEvent then I'm sure #haskellers woudl honour your name for time immemorial :)
05:00:04 <SamB> oh, I thought it stood for ReadParser
05:00:21 <EvilTerran> i'd rather see it adapted to work for any token type, mind
05:00:31 <EvilTerran> i think someone's done it, but i don't think it's on hackage
05:00:32 <SamB> oh, sure, that'd be cool too
05:00:33 <dolio> SamB: Yeah, readIO is the one that uses lex.
05:00:38 <Baughn> quicksilver: If I remove all the other code that no longer works, the whole module will be fifteen lines or so
05:00:41 <EvilTerran> IIRC, it was called ParseP, which makes sense
05:00:42 <Jedai> Oh that's good, it means read is slighly faster then
05:00:47 <Baughn> quicksilver: But I'm sorry, *most* of the leak is in Seen
05:01:05 <EvilTerran> i'm tempted to roll up a generalised ReadP using LogicT or whatever
05:01:07 <SamB> but what I mean is that the Haskell 98 way of implementing Read seems to be neither elegant nor efficient
05:01:08 <Baughn> ..rnf might work. Seems like a cheap trick, though.
05:01:28 <SamB> whereas that way seems to be both
05:01:28 <dolio> readIO s =  case (do { (x,t) <- reads s ; ("","") <- lex t ; return x }) of [x]    -> return x ; []     -> ioError (userError "Prelude.readIO: no parse") ; _      -> ioError (userError "Prelude.readIO: ambiguous
05:01:42 <EvilTerran> representing lists by their catamorphisms for efficiency reasons or whathaveyou
05:02:03 <quicksilver> Baughn: definitely most of it? hmm. shame.
05:03:29 <Jedai> Still, I just did a benchmark : http://hpaste.org/8985
05:04:11 <EvilTerran> oleg++ for the MonadLogic paper
05:04:19 <EvilTerran> preflex: karma oleg
05:04:19 <preflex>  karma for oleg: 1
05:04:22 <EvilTerran> hm
05:04:41 <Jedai> It seems there is a difference of x100 between the read solution and the digitToInt
05:04:41 <yitz> @karma oleg
05:04:42 <lambdabot> oleg has a karma of 1
05:05:00 <quicksilver> Jedai: compiled with -O?
05:05:24 <EvilTerran> oleg++ HList
05:05:36 <EvilTerran> oleg++ Kiselyov is an awesome name
05:05:41 <EvilTerran> (ok, i'll stop that now :P)
05:05:50 <Baughn> quicksilver: Is there some way I can stop LB (or any haskell program, I guess) at some point and then explore its memory structures?
05:06:13 <quicksilver> Baughn: the closest thing to that is the ghci debugger AFAIK
05:06:18 <Jedai> quicksilver: No, with -O2, they are the same (I'm impressed but why exactly ?)
05:06:24 <quicksilver> Jedai: magic.
05:06:34 <quicksilver> -O2 is "invoke strange logrus"
05:06:46 <Baughn> quicksilver: But LB won't work in ghci.. and what I really want is the ability to read cores. Well, I guess that's going on the todo list too.
05:06:47 <EvilTerran> Jedai, i suspect specialisation would be relevant
05:06:48 <yitz> quicksilver, Baughn: is seen a buggy leak, or does it really eat too much memory? if the latter, it should just cache recent seens in memory and keep the rest on disk.
05:07:25 <quicksilver> yitz: it's a buggy leak as far as we guess. It's building up big thunks of, essenetially all of everyone's comments.
05:07:26 <Baughn> yitz: Buggy leak. It uses almost no memory, but has.. leaks.
05:07:32 <Jedai> quicksilver: Ghost would seem better suited to these tasks :)
05:07:33 <EvilTerran> Jedai, eliminating the run-time typeclass resolution could save a *lot* of time, but, iirc, it doesn't do it unless you at least do -O
05:07:45 <yitz> oh. hmm.
05:07:52 <mar77a> for the sake of cross-posting if anyone knows the answer to http://rafb.net/p/Y9OANv51.html, please do tell
05:07:52 <lambdabot> Title: Nopaste - problem
05:08:08 <Baughn> yitz: It's also sufficiently complex that there's no *way* I could fix it. Its original author might, or maybe someone like quicksilver. Me, I'd rewrite it.
05:08:24 <Jedai> EvilTerran: I didn't think about the specialization, of course, digitToInt is probably still faster but they're both so fast that I don't really see the difference
05:09:01 <quicksilver> mar77a: are there some missing primes there? as in differentiation?
05:09:06 <EvilTerran> read is infamously slow, i thought
05:09:11 <yitz> (b)
05:09:20 <mar77a> missing primes? ô_o
05:09:29 <quicksilver> mar77a: ah, it's (b).
05:09:41 <quicksilver> mar77a: f(x) > f(a)/2 for some neighbourhood
05:09:43 <SamB> EvilTerran: of course
05:09:44 <quicksilver> because of continuity.
05:09:45 <Jedai> EvilTerran: Seems that's not really true anymore (good news), well in the Int case at least
05:09:45 <EvilTerran> mar77a, as in f'(a) rather than f(a)
05:10:00 * EvilTerran -> lunch
05:10:02 <mar77a> why is that quicksilver
05:10:16 <Jedai> In derived instances it's probably still slow
05:10:18 <quicksilver> because near a, f(x) is near f(a)
05:10:22 <marcot> Hello, I'm trying to debug a Storable instance, and I'm getting a strange behaviour:  I'm doing: p <- mallocBytes 32 --the size of the structure; mapM (\x -> poke (castPtr p) (RestartStyleHint x) >> (peek (castPtr p) :: IO Prop) [RestartIfRunning]
05:10:24 <quicksilver> that's what continuous means
05:10:26 <lambdabot> marcot: You have 2 new messages. '/msg lambdabot @messages' to read them.
05:10:35 <quicksilver> and if you're "near" f(a) you're obviously > f(a)/2
05:10:39 <smg> lambdabot i love you
05:10:40 <quicksilver> since f(a) is positive.
05:10:56 <yitz> smg: use @vixen
05:11:06 <conal> how do i specify a ghc version dependency in a .cabal file?
05:11:13 <MyCatVerbs> yitz: to be fair, lambdabot is a much better conversationalist.
05:11:18 <smg> yitz: mh?
05:11:23 <conal> e.g., ghc-6.9
05:11:37 <quicksilver> Baughn: AFAIk there is no tool for observing unforced thunks in a compiled program
05:11:38 <yitz> @vixen lambdabot i love you
05:11:39 <lambdabot> you love me? you don't even know me
05:11:42 <dcoutts> conal: you can't really. You can say that you're using extensions that only that version supports.
05:11:44 <quicksilver> Baughn: which is (I think) what you're asking for.
05:11:50 <BeelsebobWork_> @pl let maybeGen x = oneof [return Nothing, liftM Just x] in maybeGen
05:11:51 <lambdabot> oneof . (return Nothing :) . return . fmap Just
05:12:02 <MyCatVerbs> Eh? On my machine, ghc-6.8.3 exports a package called "ghc", with version 6.8.3.
05:12:02 <smg> yitz: lol
05:12:03 <dcoutts> conal: do you actually mean you want a dependency on the libs that come with ghc-6.9?
05:12:17 <marcot> RestartStyleHint is a constructor that takes one parameter CARD8, and RestartIfRunning is a constructor of CARD8 without parameters...
05:12:24 <conal> dcoutts: no -- my lib depends on type families working better than in 6.8.x
05:12:30 <MyCatVerbs> It's hidden by default, but you can still use it (haddock does, for example).
05:12:33 <quicksilver> heh.
05:12:35 <marcot> It works like this, but when I add something to the list in mapM, it stops working.
05:12:44 <dcoutts> conal: and you can do things differently depending on the ghc version
05:12:48 <quicksilver> depend on NotBrokenTypeFamilies
05:13:20 <Baughn> quicksilver: Yep. And nobody working on it either?
05:13:22 <conal> dcoutts: fail if < 6.9
05:13:25 <MyCatVerbs> dcoutts: there's a package called "ghc" exported by ghc, with the version number being that of the compiler. It's hidden by default, but you can still use it.
05:13:39 <dcoutts> conal: you could do, but it doesn't get handled very well at the moment.
05:14:00 <dcoutts> conal: you could do: if impl(ghc < 6.9) { buildable: False }
05:14:05 <quicksilver> Baughn: I must admit it's not something I've ever wanted or needed.
05:14:11 <MyCatVerbs> dcoutts: e.g. on my home machine, "ghc-pkg latest ghc" spits out "ghc-6.8.3" while on the lab machines here "ghc-pkg latest ghc" spits out "ghc-6.8.3".
05:14:15 <quicksilver> Baughn: but then I've not worked on many long running programs
05:14:26 <quicksilver> Baughn: I have on a couple, and they didn't leak, but there you go...
05:14:37 <conal> dcoutts: ok, thanks.
05:14:38 <dcoutts> conal: but the current behaviour for that isn't great. It does not fail at configure time, only at the build step and not with a very helpful message.
05:14:53 <Baughn> quicksilver: The profiler would probably suffice, if it /worked/. But again, I haven't tried 6.8.3's yet, so..
05:15:01 <conal> oh yeah -- maybe an informal comment would be as helpful
05:15:09 <dcoutts> MyCatVerbs: that's the ghc api package. Presumably conal's package does not depend on it.
05:16:04 <MyCatVerbs> dcoutts: yeah, but it's probably a "good enough" surrogate for working out the version of GHC itself.
05:16:32 <dcoutts> MyCatVerbs: but then the package would actually depend on the ghc package which is not a good thing at all
05:17:20 <MyCatVerbs> dcoutts: well, it already depends on having GHC HEAD, doesn't it?
05:17:42 <dcoutts> MyCatVerbs: it's silly to link to the ghc package if it's not used.
05:19:17 <MyCatVerbs> dcoutts: yeah, but it'd work. (Also, won't GHC omit linking against libraries from which nothing is actually imported in the code?)
05:19:23 <yitz> conal: here's a kluge - you can include code that fails to compile in 6.8.
05:19:34 <dcoutts> MyCatVerbs: heh, don't count on it
05:20:05 <dcoutts> MyCatVerbs: but even if it doesn't end up linking with it much, there's still the drawbacks that it has to use libs consistent with the ones that the ghc lib uses
05:20:52 <MyCatVerbs> dcoutts: that's a moot point between now and the time that one of the other implementations gets type families.
05:21:42 <MyCatVerbs> dcoutts: they'll have to become stable before that'll happen, and when it does, conal can switch to a different kludge.
05:22:04 <dcoutts> MyCatVerbs: no, I mean things like if you depend on ghc-6.8.2 then you must use bytestring-0.9.0.1 and not bytestring-0.9.1.0 etc
05:22:43 <dcoutts> well, I think it's a horrible kludge and would not recommend it
05:23:32 <MyCatVerbs> dcoutts: I fail to understand why you'd be forced to use the specific version of, say bytestring, that comes with that version of the compiler.
05:24:41 <MyCatVerbs> dcoutts: most packages aren't too fussy about which version they use of most of the libraries, and it's now almost trivial to update most of the libraries that come with GHC to whatever the latest version available on Hackage is.
05:25:03 <dcoutts> MyCatVerbs: because ghc-6.8.2 depends on bytestring-0.9.0.1 and we must pick our own deps consistently, so if we depend on bytestring then it must be the same version as is used by the ghc package. Same goes for all deps of all packages but it's worse for the ghc package because you cannot rebuild it against later versions of deps.
05:25:24 <MyCatVerbs> dcoutts: ah, I see.
05:25:40 <MyCatVerbs> dcoutts: right, of course that is more of a pain in the hindquarters.
05:27:34 <MyCatVerbs> dcoutts: in which case the best kludge is presumably yitz's - include code that will compile with HEAD but cause all the other compilers to blow up.
05:27:58 <dcoutts> my suggestion was slightly nicer than that
05:28:17 <dcoutts> not by much, still fails at build time, but fails immediately and not with a compile failure
05:28:17 <yitz> please, please find an alternative to my suggestion. :)
05:28:30 <olsner> is there no generic Monad m => Applicative m instance?
05:28:43 <MyCatVerbs> dcoutts: heh, yeah.
05:28:48 <quicksilver> well there is a Monad M => Applicative (WrappedMonad m), IIRC
05:29:44 <MyCatVerbs> olsner: no, because you'd get overlapping instances when you defined it for your own types. Hence the WrappedMonad newtype.
05:29:55 <olsner> hmm, ok
05:30:34 <dcoutts> MyCatVerbs: with my suggestion you currently get "cabal: Package foo-0.1 can't be built on this system." at the build step.
05:30:47 <dcoutts> which isn't great obviously
05:30:47 <yitz> even worse suggestion: make sure the code compiles on 6.8, then blow at runtime with the message "this only runs on ghc 6.9 and higher".
05:30:50 <marcot> http://hpaste.org/8986
05:31:03 <MyCatVerbs> dcoutts: yeah, but it's at least vaguely civilised.
05:31:05 <marcot> With two members in the list it works, with three no.
05:31:06 <MyCatVerbs> dcoutts: oooh, ooh, I know.
05:31:13 <marcot> Is there something stupid I'm doing?
05:31:25 <MyCatVerbs> dcoutts: use a ported version of BSD4.4's "banner" to make sure the user doesn't miss that message. :D
05:31:25 <dcoutts> yitz: nice, but too hard :-) the problem was that the type families was more than ghc-6.8 could cope with
05:32:09 <yitz> how about #ifdef ...
05:32:39 <titusg> yitz: sorry, I was away. thanks for looking at my problem. the idea is to make runtime data with static assurances that are hidden from the user...I'm experimenting and probably barking up the wrong tree.
05:43:08 <vixey> brr
05:44:11 <Asgaroth> I'm using a String in a case-expression. Is there a way to evaluate a specific branch if there string is either "a" or "b"? Would I have to use HaRP for this?
05:44:27 <Asgaroth> s/there/the/
05:44:27 <yitz> titusg: well, yes, that is what types are for after all. the way it works is that it forces you to propagate the assurances back to the source of the data. you want to hide the specific assurances from your library user at intermediate stages of processing by using existentials. Have I gotten that right?
05:45:18 <quicksilver> Asgaroth: case x | x == "a" || x == "b" -> do someting
05:45:36 <titusg> yitz: exactly, and in the end by module interfaces
05:46:04 <MyCatVerbs> quicksilver: oh hey, you can use guards in any case expression?
05:46:55 <matthew-_> yeah, even on functions with no arguements
05:46:58 <quicksilver> MyCatVerbs: yes.
05:47:15 <matthew-_> as it where x | y > 56 = True | otherwise = False
05:47:20 <matthew-_> s/it/in/
05:47:39 <MyCatVerbs> quicksilver: damn, blast, and I'd like to bean myself for not knowing this.
05:51:53 <quicksilver> MyCatVerbs: live and learn, we all do.
05:52:06 <quicksilver> only this morning I learnt that functorial zippers are comonads.
05:52:50 <MyCatVerbs> quicksilver: by zippers you mean zipper(D(x)) = D'(x) * x, right?
05:52:51 <yitz> titusg: the problem is that you can't always use the existential to hide assurance, if you need the assurances to do a calculation. They have to be there in the type. But you might still be able to hide it using the module namespace.
05:52:52 <mar77a> this morning i learned that shower mornings are nice
05:53:59 <MyCatVerbs> quicksilver: I mean, zipper of a structure is a pair of the first derivative of that structure and the removed element?
05:54:01 <olsner> hmm, no liftM17 either
05:54:13 <MyCatVerbs> olsner: that's what `ap` is for, surely? ;P
05:54:31 <olsner> hmm, I guess
05:55:02 <MyCatVerbs> olsner: wait, were you actually being serious?
05:55:35 <olsner> MyCatVerbs: yes :D
05:56:12 <MyCatVerbs> olsner: fffff... to paraphrase Perlis, if you have a routine that takes ten or more parameters, you probably forgot a few.
05:56:53 <olsner> well, in this case it's a data constructor of a 17-field data structure (which used to be a 17-tuple)
05:57:26 <MyCatVerbs> olsner: oh crikey. Is this in the main event loop of a program or something?
05:57:47 <olsner> MyCatVerbs: nah, message parsing of messages coming in from the network
05:57:58 * MyCatVerbs takes a look at something.
05:59:17 <MyCatVerbs> olsner: ah. Just wondering, because I've written a program where I ended up passing such a huge nest of parameters around that I ended up building a little data structure for.
06:00:32 <olsner> I don't intend to do a lot of liftM17'ing anyway (I just rewrote the already too repetitive parse-something-with-17-fields function to use ap)
06:00:47 <MyCatVerbs> olsner: only through one routine, even. It was just "mainloop params = readChan { eventChannel params } >>= \message -> case message of ..., where each of the cases would finish with some variation on "mainloop params{ someSetting = newValue }".
06:01:07 <MyCatVerbs> Er, readChan (eventChannel params), even.
06:01:07 <yitz> quicksilver, Baughn: seen plugin: couldn't you just replace $ with $! in each of the 5 or so occurrences of Right $ M.insert ...? Those are the only places where the map is rebuilt.
06:06:22 <olsner> what's the difference between a newtype A = A (b,c) and data A = A b c?
06:07:24 <yitz> olsner: data wraps it in a lazy thunk.
06:08:34 <olsner> hmm, but isn't (a,b) already a lazy thunk?
06:09:38 <yitz> olsner: oh, i see. you manually wrapped in a lazy thunk in the newtype.
06:10:13 <EvilTerran> olsner, nothing but the syntax and the type, i think
06:10:40 <EvilTerran> they're completely isomorphic, IIRC
06:11:51 <olsner> yeah, that is how it seems to me it should be
06:12:50 <jaj> just wondering, is anybody here under OpenBSD amd64?
06:12:50 <yitz> so I guess the only difference would be if the compiler is smarter about unwrapping the newtype and fusing the tuple. I'm not sure about that.
06:13:14 <jaj> because ghci from the official package segfaults for me :/
06:13:52 <olsner> well, that's an optimization issue :)
06:14:23 <yitz> jaj: better post that on glasgow-haskell-users
06:14:46 <jaj> yitz: ok thanks
06:15:29 <olsner> oh, crap, I need a deconstructor for the 17-field structure for the message unparser
06:15:44 <MyCatVerbs> olsner: hahaha, Hell.
06:15:51 <MyCatVerbs> jaj: oooh.
06:16:14 <MyCatVerbs> jaj: using OpenBSD's official ghc package? ghci always segfaulted for me with that, on i386 too.
06:17:00 <vixey> Can anyone help me to get a community.haskell account? :S
06:17:02 <MyCatVerbs> jaj: however, the compiler proper still works, I believe. When I ran into that, the solution was to install the ghc 6.6 from sources (which then worked perfectly).
06:17:04 <jaj> MyCatVerbs: it used to work fine for me
06:17:04 <vixey> I tried this thing http://community.haskell.org/admin/account_request.html
06:17:08 <lambdabot> Title: Account Request
06:17:16 <stevan> works well for me on 4.3-stable i386.
06:17:36 <quicksilver> yitz: that sounds plausible to me
06:18:08 <MyCatVerbs> jaj: oh, okay. Well, just so you know, I had a similar issue between about 3.6 and 4.0 i386, and installing from sources cleared it up.
06:18:22 <MyCatVerbs> jaj: mind, that was a while back, so maybe the situation's entirely different now.
06:18:42 <jaj> MyCatVerbs: I'll try building it from source, thanks for the hint!
06:18:53 <vixey> or can I put something on hackage?
06:20:46 <vixey> I guess I will tyr to make a hackage account
06:21:33 <vixey> how long does it take ?
06:21:36 <vixey> to get a reply
06:22:07 <MyCatVerbs> vixey: presumably quicker if you chase people up by email and on IRC. ;)
06:22:17 <vixey> I don't know who runs anything :S
06:22:28 <vixey> and I am having endless problems with ssh
06:22:59 <vixey> it's such a hassle to try and get rid of this code :p
06:25:00 <peti> Is anyone using the Gentoo overlay?
06:26:24 <peti> Thought so. :-)
06:27:59 <vixey> mmm :/
06:28:08 <vixey> can anyone give me a community.haskell account?
06:34:54 <olsner> hmm, there, I believe the last use of the 17-tuple has been eliminated
06:35:47 <olsner> but where do you put the cut-off for too-large-tuple? we have a few 10-, 8- and 7-tuples left :D
06:37:36 <yrlnry> Is there a way to get ghci to display newlines in strings literally?  For example, if I ask ghci to evaluate '"a\nb"', it emits the four characters 'a', '\', 'n', 'b', but I want it to emit 'a', '\n', 'b'.
06:37:41 <yrlnry> Hope that wasn't too unclear.
06:38:02 <vixey> yrlnry: You could putStr the result
06:38:05 <vixey> the string*
06:38:09 <yrlnry> Thanks.
06:39:07 <yrlnry> Maybe I should ask me real question.  I have this function that produces a list of stuff.  It's hard to read.  I think it would be easier to read if each list item were on a separate line.
06:39:21 <yitz> @tell Cale lambdabot seen plugin: couldn't you just replace $ with $! in each of the 5 or so occurrences of Right $ M.insert ...? Those are the only places where the map is rebuilt. What do you think?
06:39:22 <lambdabot> Consider it noted.
06:39:28 <vixey> yrlnry: mapM_ putStrLn
06:39:39 <yrlnry> THanks again.
06:40:03 <vixey> oh
06:40:05 <vixey> mapM_ print
06:40:10 <vixey> if it's stuff and not strings
06:41:49 <quicksilver> yrlnry: unlines?
06:42:34 <yrlnry> mapM_ (putStrLn . show) ...  worked fine.
06:42:37 <yrlnry> Just what I wanted.
06:42:44 <PeakerWork> I think print = putStrLn . show
06:42:52 <yrlnry> okay then.
06:42:52 <PeakerWork> @src print
06:42:53 <lambdabot> print x = putStrLn (show x)
06:42:56 * vixey sighs
06:43:22 <yrlnry> @pl \x y -> foo (bar x y)
06:43:22 <lambdabot> (foo .) . bar
06:43:43 <vixey> @pl \x y z -> foo (bar x y z)
06:43:44 <lambdabot> ((foo .) .) . bar
06:43:47 <vixey> @pl \x y z w -> foo (bar x y z w)
06:43:48 <lambdabot> (((foo .) .) .) . bar
06:44:09 <yrlnry> @pl \ -> foo bar
06:44:09 <lambdabot> (line 1, column 3):
06:44:09 <lambdabot> unexpected "-"
06:44:09 <lambdabot> expecting pattern
06:44:16 <PeakerWork> heh
06:45:39 <Baughn> @instances-importing Data.Map NFData
06:45:47 <lambdabot> Couldn't find class `NFData'. Try @instances-importing
06:45:51 <vixey> @seen shapr
06:45:52 <lambdabot> Last time I saw shapr was when I left ##logic, #arch-haskell, #darcs, #dreamlinux-es, #friendly-coders, #gentoo-haskell, #gentoo-uy, #ghc, #haskell, #haskell-blah, #haskell-books, #haskell-hac07, #
06:45:52 <lambdabot> haskell-hac4, #haskell-overflow, #haskell-soc, #haskell.cz, #haskell.de, #haskell.dut, #haskell.es, #haskell.fi, #haskell.fr, #haskell.hr, #haskell.it, #haskell.jp, #haskell.no, #haskell.ru, #
06:45:52 <lambdabot> haskell.se, #haskell_ru, #japanese, #jhc, #jtiger, #macosx, #parrot, #perl6, #rosettacode, #scala, #scannedinavian, #thunks, #unicycling and #xmonad 16h 48m 31s ago, and .
06:45:58 <vixey> I wish shapr was here
06:46:17 <vixey> why is there so many haskell channels
06:46:24 <vixey> I don't think anyones in them
06:46:27 <Baughn> @instances NFData
06:46:27 <lambdabot> Couldn't find class `NFData'. Try @instances-importing
06:46:50 <dolio> @instances-importing Control.Parallel NFData
06:46:50 <lambdabot> Couldn't find class `NFData'. Try @instances-importing
06:46:55 <dolio> @instances-importing Control.Parallel.Strategies NFData
06:47:10 <lambdabot> Couldn't find class `NFData'. Try @instances-importing
06:51:22 <vixey> I guess I'm thinking about what to code next
06:52:55 <quicksilver> dolio: due to the unpleasantness of abstract data types
06:53:09 <quicksilver> dolio: it's not possible to write an instance of NFData anywhere except inside 'Data/Map.hs'
06:53:12 <quicksilver> :(
06:53:30 <quicksilver> dolio: and a quick grep of the source code suggests there isn't one.
06:53:45 <dolio> The docs for Control.Parallel.Strategies say there is one.
06:54:03 <quicksilver> oh, I'm wrong
06:54:05 <quicksilver> they cheat.
06:54:19 <quicksilver> they use toList
06:54:20 <quicksilver> heh.
06:54:23 <quicksilver> well fair enough, I guess.
06:54:28 <quicksilver> I didn't think of that :)
06:54:45 <quicksilver> it doesn't guarantee to rnf data.map's internal magix parts, but fortunately they are all defined as strict anyway.
06:55:04 <quicksilver> rnf = rnf . Data.Map.toList
06:55:35 <dolio> I was just trying to get lambdabot to say so.
06:55:44 <dolio> She's uncooperative, though.
06:56:32 <chrisdone> she's electric
07:05:45 <MyCatVerbs> vixey: for finding shapr, try leaving a message on lambdabot? Either that or I think it might be worth asking around in #scannedinavian.
07:09:00 <twobitwork> http://shootout.alioth.debian.org/debian/benchmark.php?test=chameneosredux&lang=ghc&id=0
07:09:04 <lambdabot> Title: chameneos-redux Haskell GHC program | Debian : AMD" Sempron" Computer Language B ..., http://tinyurl.com/5enruf
07:09:06 <twobitwork> what does "default(Int)" mean?
07:12:04 <quicksilver> twobitwork: it means choose Int as default for Num a =>
07:12:15 <quicksilver> twobitwork: when the monomorphism restriction forces you to choose something.
07:12:29 <quicksilver> (the default default is Integer,Double)
07:14:47 <MyCatVerbs> quicksilver: I am occasionally alarmed by the number of corners of language that I don't know. ;)
07:15:18 <MyCatVerbs> quicksilver: fortunately, mostly syntactic sugar rather than semantics. I'd be outright scared witless if I didn't know the semantics. :)
07:21:07 <quicksilver> MyCatVerbs: do you know that newtype Foo = Foo Bar is different, semantically, from data Foo = Foo !Bar ? :)
07:22:47 * MyCatVerbs ponders.
07:23:22 <MyCatVerbs> quicksilver: how does that work? Shouldn't Foo _|_ come out as _|_ in the strict data case, exactly the same as how Foo _|_ = _|_ in the newtype case?
07:23:54 <quicksilver> well that's a question about data representation.
07:24:01 <quicksilver> which is of course compielr-dependent
07:24:14 <quicksilver> the compiler independent question is to ask how you can write a program to distinguish them
07:24:25 <quicksilver> and the key is how "case undefined of Foo a -> " behaves
07:25:35 <MyCatVerbs> quicksilver: methought the semantics were that a record diverges if any of its strict fields diverge.
07:26:50 <MyCatVerbs> quicksilver: where's the observable difference?
07:27:06 <DrSyzygy> DRMacIver: Ping?
07:28:47 <MyCatVerbs> quicksilver: nttest = case undefined of NT _ -> [] -- doesn't diverge, sdtest = case undefined of SD _ -> [] -- diverges
07:29:06 <MyCatVerbs> quicksilver: what a pain in the hindquarters.
07:29:24 <dolio> Ordinary matches of newtypes are equivalent to irrefutable matches against the strict type.
07:29:33 <MyCatVerbs> quicksilver: Sometimes I really don't envy compiler writers who have to maintain these invariants. :)
07:29:47 <dolio> And banged matches against newtypes are equivalent to ordinary matches against the strict type.
07:31:05 <dolio> case undefined of NT _ -> [] = case undefined of ~(SD _) -> []
07:31:21 <dolio> case undefined of !(NT _) -> [] = case undefined of SD _ -> []
07:31:32 <quicksilver> MyCatVerbs: you're right about a record diverging when a strict field diverges
07:31:45 <quicksilver> MyCatVerbs: the difference is in whether or not a single 'case' is enough to force WHNF
07:33:23 <MyCatVerbs> quicksilver: http://hpaste.org/8987 -- when in doubt, resort to empiricism. ;)
07:33:44 <quicksilver> MyCatVerbs: agreed.
07:33:53 <quicksilver> MyCatVerbs: one of the nice thins about haskell is empiricism is so easy
07:33:59 <quicksilver> MyCatVerbs: REPL, small programs, etc.
07:34:06 <paolino> hi , anyone is having fun with google jam ?
07:34:13 <quicksilver> demonstrating a minimal counterexample in java is normally 1000 lines of code.
07:34:20 <MyCatVerbs> quicksilver: except when the doubt is about whether or not your development environment implements the spec correctly. In which case you're basically up shit creek.
07:34:28 <quicksilver> well that's true.
07:34:49 <quicksilver> but it's not *that* hard to load something into hugs
07:35:14 <MyCatVerbs> quicksilver: how sure are you that Hugs and YHC and GHC don't share a common error? ;)
07:35:25 <od> im reading the graph reduction page on wikibooks. did i get this right: square (square 3) -- is 4 steps for inner reduction, 6 steps for outer, and 3 steps with outer + graph
07:35:31 <MyCatVerbs> quicksilver: (obvious answer: "well then just try JHC too." ;D)
07:38:58 <od> http://hpaste.org/8988
07:39:49 <paczesiowa> is there a tool to print those reductions one by one?
07:40:07 <od> yea i was wondering that too
07:40:18 <vixey> it's not hard to write one
07:40:34 <quicksilver> 'hat'
07:40:44 <quicksilver> I think it might have slightly bitrotted though
07:40:55 <quicksilver> http://www.haskell.org/hat/
07:40:55 <lambdabot> Title: Hat - the Haskell Tracer
07:41:02 <od> nice
07:41:04 <dolio> od: Shouldn't there be an extra step in the graph one?
07:41:21 <od> i dunno haha
07:41:28 <dolio> For 'let x = square 3 in x * x' or something?
07:42:04 <od> just read the article a few min ago and wanted to check the excercise result
07:43:21 <dolio> I wouldn't expect it to take less steps than inner, at least.
07:43:27 <dolio> For that example.
07:44:43 <vixey> humf
07:44:48 <vixey> I don't know what to do then
07:44:49 <chrisdone> unf
07:56:07 <gbacon> so will the work on c2hs eventually allow marshaling C structures?
08:06:25 <Baughn> I wonder, what does "NFData" stand for?
08:06:29 <Baughn> Normal form?
08:11:02 <dolio> Yes.
08:11:31 <Baughn> Why "normal"? I assume it doesn't refer to geometry
08:11:50 <dolio> Normal form like lambda calculus.
08:12:43 <vixey> normalized vector is length 1
08:13:12 <dolio> The normal form of an expression (if it has one) is a canonical term where no additional evaluation rules apply.
08:14:04 <Baughn> Works for me
08:14:38 <dolio> Which is essentially what rnf gives you. A fully evaluated whatever.
08:15:04 <dolio> @type rnf
08:15:18 <Baughn> That, I am aware of.
08:15:19 <lambdabot> thread killed
08:15:29 <luite> what would be a good way to remove all odd indexes from a list (odd positions, not values)?
08:15:50 <DRMacIver> DrSyzygy: Pong?
08:16:00 <vixey> luite: removeOdd (x:y:zs) = x:removeOdd zs
08:16:18 <vixey> luite: removeOdd e = e
08:16:29 <Baughn> I can't help but think it should be handled at a lower level, though. Add an extra bit to thunks to mark them as fully evaluated (recursively so), so you don't have to go walking everything just on the off chance there's a thunk on one leaf somewhere
08:16:42 <luite> vixey: yeah, I wanded to do it without explicit recursion, but the other ways I've come up with seem to be much more complex
08:16:54 <vixey> luite: why o_o
08:17:17 <RayNbow> vixey: because it's a mental challenge ;)
08:17:37 <RayNbow> fst . unzip $ filter (even . snd) $ zip xs [0..] -- it's long, but it's without explicit recursion :p
08:17:47 <Lemmih> luite: [ x | (x,n) <- zip lst [1..], not (odd n) ]
08:18:16 <RayNbow> Lemmih: not (odd n) ?
08:18:22 <vixey> > let removeOdd (x:y:zs) = x:removeOdd zs ; removeOdd e = e in removeOdd "txexsxt"
08:18:23 <RayNbow> even n?
08:18:24 <lambdabot>  "test"
08:18:56 <Lemmih> RayNbow: We don't want the odds. That 'not . odd' = 'even' is coincidental.
08:19:05 <RayNbow> :p
08:19:56 <dolio> > let f (x:xs) = Just (x, drop 1 xs) ; f [] = Nothing in unfoldr f "txexsxt"
08:19:57 <lambdabot>  "test"
08:20:13 <dolio> > let f (x:xs) = Just (x, drop 1 xs) ; f [] = Nothing in unfoldr f "txexsxtx"
08:20:14 <lambdabot>  "test"
08:22:27 <weilawei> so.. is there a good haskell/objective-c binding (i'm thinking HOC, but don't know what people think of it) for developing OS X apps?
08:22:52 <Baughn> weilawei: Hm. Well, the objective-c ABI is supposedly compatible with C
08:23:07 <Baughn> weilawei: You should be able to treat obj-c functions as C functions, just passing the object as the first parameter
08:23:13 <vixey> I think HOC is ancient and broken
08:23:35 <weilawei> hrm, good to know. i'm new to haskell, but that's where I'm headed..
08:24:24 <twobitwork> weilawei: #haskell is probably a better place to ask... but yes, using foreign like you would calling any other C function should work
08:24:25 <weilawei> Baughn, where would I find resources on c interop? every time i see something for haskell that involves anything not like.. in the language spec, i have 4000 choices
08:24:34 <weilawei> twobitwork, um
08:24:36 <Baughn> weilawei: Also, the SDL binding uses some obj-c code to set things up. Have a look at that
08:24:37 <weilawei> im in #haskell
08:24:38 <twobitwork> weilawei: oops :P I thought I was looking at #debian, sorry
08:24:54 <weilawei> twobitwork, haha okay
08:26:29 <dublpaws> [fst pair + snd pair | pair <- (zip [1..10] [2..11])] --is there a better way to do this, especially the summation part?
08:26:45 <vixey> zipWith (+)
08:26:54 <dublpaws> ok thanks :)
08:33:26 <quicksilver> there has been work on HOC fairly recently
08:33:28 <luite> @pl removeOdd lst = [ x | (x,n) <- zip lst [1..], not (odd n) ]
08:33:28 <lambdabot> removeOdd = (: [not (odd n)]) . ((x | (x, n)) <-) . flip zip [1..]
08:33:37 <quicksilver> it's not completely daed
08:33:42 <quicksilver> but it's certainly not very 'fresh'
08:34:25 <vixey> when?
08:34:30 <vixey> last update on the site is 2004
08:36:02 <RayNbow> > let removeOdd = (: [not (odd n)]) . ((x | (x, n)) <-) . flip zip [1..]    in    removeOdd [1..10]
08:36:02 <lambdabot>  Parse error at "|" (column 41)
08:36:11 <RayNbow> bug in @pl? :p
08:38:31 <quicksilver> vixey: last update on the site is a poor indicator of activity :P
08:38:39 <quicksilver> sites are the *last* thing most developers update.
08:40:35 <quicksilver> there are CVS commits from 2007
08:40:42 <quicksilver> and I think I've seen a mailing list post in 2008
08:46:43 <canadaduane> So, I'm curious... I recently discovered that you can define both ++ and concat in terms of foldr... it's so elegant.  Now I'm wondering if there's a way to use partial function application to create concat without ++
08:46:51 <canadaduane> e.g. let concat = foldr (foldr (:)) []
08:47:26 <vixey> :t let concat = foldr (foldr (:)) [] in concat
08:47:26 <lambdabot> forall a. [[a]] -> [a]
08:47:37 <canadaduane> this almost works, but it appends the inner list backwards
08:47:55 <vixey> canadaduane: What is yoru definition of ++ and of concat?
08:48:16 <canadaduane> ++ is the regular definition
08:48:23 <canadaduane> i.e. append two strings / lists
08:48:25 <vixey> show me
08:48:39 <canadaduane> "hello" ++ "there"
08:48:43 <canadaduane> => "hellothere"
08:48:48 <vixey> the definition
08:48:59 <canadaduane> myAppend a b = foldr (:) b a
08:49:13 <vixey> ok and concat?
08:49:13 <quicksilver> foldr (flip (foldr (:))) []
08:49:26 <vixey> oh well the ending is spoiled
08:49:30 <quicksilver> sorry.
08:49:34 <quicksilver> I didn't realise it was a story ;)
08:49:39 <canadaduane> myConcat = foldr myAppend []
08:49:40 <canadaduane> lol
08:49:49 <canadaduane> thanks, both of you
08:49:54 <canadaduane> that's neat
08:53:42 <BMeph> foldl (foldr (:)) [] ? :)
08:54:26 <Baughn> BMeph: Only if you like stack overflows, horrible memory usage or lack of streaminess
08:55:05 <canadaduane> ooh, yes, I do
08:55:10 * canadaduane tries
08:55:22 <Baughn> > take 10 $ (foldr (foldr (:)) [] ["foo","bar"]
08:55:22 <lambdabot> Unbalanced parentheses
08:55:47 <canadaduane> BMeph: I tried, but I think it still concats them backwards :)
08:55:49 <Baughn> > take 10 $ (foldr (flip (foldr (:)))) [] ["foo","bar"]
08:55:58 <lambdabot>  "foobar"
08:56:07 <Lemmih> dcoutts_: Salam, are you free to continue our mini hackathon?
08:56:22 <Baughn> > take 10 $ (foldr (flip (foldr (:)))) [] (repeat "foo")
08:56:23 <lambdabot>  "foofoofoof"
08:56:29 <Baughn> > take 10 $ (foldl (flip (foldr (:)))) [] (repeat "foo")
08:56:31 <lambdabot>  "
08:56:49 <Baughn> ^-- That's supposed to be an "exception: stack overflow". Dunno why it's not..
08:56:57 <dcoutts_> Lemmih: Arr!
08:56:59 <canadaduane> ah well, point taken :)
08:56:59 <quicksilver> well it can show the " laizly
08:57:10 <BMeph> Baughn: "Streaminess" is overrated. ;)
08:57:12 <Baughn> quicksilver: And it shows the full error here, too
08:57:23 <quicksilver> "here" = runplugs?
08:57:29 <Baughn> quicksilver: Nope, lb
08:57:33 * quicksilver nods
08:57:33 <Baughn> BMeph: Tell me that after you've dealt with parsing a 15G dataset
08:57:36 <quicksilver> (lb uses runplugs)
08:57:41 <quicksilver> odd.
08:58:05 <Baughn> I'm the one who fixed it so it would, but.. *something*'s wrong on the server it's running, and I have no idea what
08:58:08 <BMeph> canadaduane: Yes, it does. quicksilver did it right (which is typical), and I was just fooling arouind (which is also typical). :)
08:58:41 <canadaduane> gotcha
08:59:21 <Baughn> quicksilver: All I can think of its that maybe it hits an os-set stack limit before the ghc-set one
08:59:53 <BMeph> Baughn: After I've parsed a 15G dataset, I'd hope not to be using lists... :)
09:00:13 <Baughn> BMeph: So I was using bytestrings. So what?
09:00:23 <Baughn> The streaminess is what counts
09:00:24 <bastl> i just created my first cabal file, but my environment seems to be messed up: Setup.hs configure says: "ghc-pkg version >=0 is required but it could not be found." ghc and ghc-pkg are both available from commandline in version 6.8.2 on ubuntu. Can anyone help ?
09:00:58 <Baughn> BMeph: Try running it with -v, see what happens
09:01:17 <dcoutts_> bastl: mm, that is odd. If it could not be found then it would not complain about the version I think.
09:01:26 <Baughn> *bastl
09:01:32 <dcoutts_> bastl: what version of ghc and cabal?
09:01:37 <bastl> running what with -v ?
09:01:44 <canadaduane> btw, if anyone's new (like me) in Haskell and is curious about foldr, I wrote a bit about it here: http://blog.inquirylabs.com/2008/07/17/using-foldr-in-haskell/
09:01:45 <lambdabot> Title: Using foldr in Haskell
09:01:51 <Baughn> bastl: runghc Setup.*hs configure -v
09:01:58 <bastl> dcouts: 6.8.2 cabal 1.2.3
09:02:25 <bastl> Baughn: no verbose infos, same errormsg
09:02:25 <dcoutts_> Lemmih: so want to come round here? you'll have to tell me when you expect to arrive since the reception will be closed.
09:02:36 <dcoutts_> use -v3
09:03:46 <bastl> dcoutts_: more output: http://hpaste.org/8989
09:04:07 <bastl> ah, usr/local/bin
09:04:10 <BMeph> canadaduane: I'll check it out, but Cale's probably already done better... :)
09:04:20 <bastl> hm, why that?
09:04:31 <dcoutts_> bastl: and what does /usr/local/bin/ghc-pkg --version say?
09:04:57 <dcoutts_> bastl: or did you not expect it to find ghc in /usr/local/bin ?
09:05:01 <canadaduane> BMeph: lol, I'm sure there is better writing out there.  This is just my own groking-as-I-go kind of a post.
09:05:24 <bastl> theres a symlink in /usr/local/bin: ghc -> /usr/bin/ghc
09:05:29 <bastl> but no ghc-pkg anywhere
09:05:58 <bastl> one day i tried to install something and had to install a newer version of some tool, perhaps ghc-pkg !? im confused
09:06:25 <bastl> some wrong package list somewhere
09:06:26 <bastl> ?
09:07:26 <bastl> ah, i remember i installed haddock-2.0.0.
09:07:54 <Baughn> bastl: It doesn't really make sense to install ghc-pkg separately of ghc
09:07:56 <Lemmih> dcoutts_: Okay, I'll ping you from Greens cafe. My classes end in about 90 minutes.
09:08:04 <Baughn> Well.. rm -rf /usr/local/* would probably clear it up
09:08:06 <dcoutts_> Lemmih: ok
09:08:52 <bastl> Baugh: right, removing the symlnk to ghc there solvedf it. thanks a lot . that was quick.
09:09:06 <bastl> -v3 was new to me :-)
09:40:05 <dons> ?yow
09:40:07 <lambdabot> Couldn't find fortune file
09:40:08 <dons> ?users
09:40:08 <lambdabot> Maximum users seen in #haskell: 460, currently: 458 (99.6%), active: 6 (1.3%)
09:41:09 <ndmitchell> dons: is lambdabot likely to want to upgrade to Hoogle 3.9 when it comes out early next week?
09:41:36 <dons> check with Cale.
09:41:44 <dons> i don't work on lambdabot much now.
09:42:03 <marcot> Does catchError catches all Exceptions?
09:42:13 <dons> marcot: from Control.Exception ?
09:42:16 <ndmitchell> will do :)
09:43:28 <marcot> dons: yes.
09:43:35 <dons> marcot: yes, then.
09:43:48 <dons> but check the docs.
09:43:50 <marcot> I wonder why the Control.Exception aren't generalized for MonadIO m
09:44:05 <quicksilver> because nothing is.
09:44:17 <dons> that would be a useful hackage package.
09:44:24 <quicksilver> still, you can't generalise callbacks to MonadIO
09:44:29 <dons> its one of the first things you have to do when writing interactive apps
09:44:31 <quicksilver> you need a slightly stricter constraints.
09:44:38 <dons> is lift a bunch of things into MonadIO
09:44:59 <marcot> Wouldn't this be good is the standard libraries?
09:45:11 <quicksilver> yes, it would.
09:45:18 <dons> well, MonadIO isn't in the standard libraries
09:45:27 <dons> so it would have to be a 3rd party package.
09:45:33 <quicksilver> is monadIO independent of the non-h98 parts of mtl?
09:45:42 <dons> good question.
09:45:47 <quicksilver> in fact, is monadIO itself h98-compliant?
09:45:52 <quicksilver> or does it have overlapping isntances
09:46:37 <marcot> dons: what else do you think it would be useful to have as MonadIO?
09:46:45 <quicksilver> everything.
09:46:47 <quicksilver> putStrLn
09:46:53 <marcot> I thought of that answer.
09:47:01 <quicksilver> all the IO you want.
09:47:06 <quicksilver> you would ideally like to be in MonadIO
09:47:11 <quicksilver> but, as I say, you can't do callbacks.
09:47:15 <marcot> quicksilver: but for functions that take IO functions as parameter the case is worse...
09:47:20 <quicksilver> need MonadInterleavableIO.
09:47:25 <quicksilver> marcot: yes, you can't promote them to IO.
09:47:29 <quicksilver> erm
09:47:31 <quicksilver> to MonadIO.
09:47:44 <marcot> with the other ones you can use just liftIO
09:49:25 <marcot> @hoogle MonadInterleavableIO
09:49:26 <lambdabot> No matches found
09:49:30 <quicksilver> it doesn't exist
09:49:32 <quicksilver> maybe it should
09:49:34 <quicksilver> :)
09:49:39 <ndmitchell> @hoogle MonadIO
09:49:40 <lambdabot> Control.Monad.Trans.MonadIO :: class Monad m => MonadIO m
09:49:51 <quicksilver> you can only do it for a particular subset of monads, marcot
09:49:55 * ndmitchell is still scared that hoogle not finding something is used as evidence that something doesn't exist
09:50:06 <quicksilver> mixtures of state and exceptions are OK
09:50:07 <dons> http://www.reddit.com/info/6s938/comments/
09:50:08 <lambdabot> Title: reddit.com: Integrating unit testts into your Haskell packages
09:50:10 <quicksilver> Cont would not be.
09:50:12 <dons> grr.
09:50:13 <dons> typo.
09:50:23 <marcot> What's interleavable?
09:50:39 <dons> http://www.reddit.com/info/6s93c/comments/
09:50:40 <lambdabot> Title: reddit.com: Integrating unit tests into your Haskell packages
09:50:40 <dons> :)
09:50:44 <quicksilver> monads which can be interleaved with IO in the way you're asking for.
09:50:56 <quicksilver> I.e. you can thread callbacks through IO.
09:51:06 <marcot> quicksilver: hum...
09:51:25 <quicksilver> marcot: http://www.haskell.org/pipermail/haskell-cafe/2007-July/028501.html
09:51:26 <lambdabot> Title: [Haskell-cafe] Monadic tunnelling: the art of threading one monad through anothe ..., http://tinyurl.com/3xmhco
09:51:42 <marcot> I asked dcoutts_ about why gtk2hs wasn't MonadIO, but then I noticed nothing is...
09:51:55 <dons> http://www.reddit.com/info/6s93n/comments/
09:51:56 <lambdabot> Title: reddit.com: Haskell Weekly News: databases, full-text search, array fusion, prot ...
09:51:57 <Saizan_> ndmitchell: have you used yhi? it seems to want the .hbc for all the imported modules in the current directory apart from what's in base
09:52:01 <dcoutts_> marcot: aye, it's a big pita
09:52:24 <dcoutts_> marcot: and it's not needed for things like using a custom state monad in event handlers
09:53:03 <dcoutts_> ndmitchell: lots of responsibility :-)
09:53:11 * quicksilver was pretty surprised at how little response that -cafe post provoked.
09:54:53 <BMeph> Could someone tell me of a useful reason to have dynamic scoping (in the sense of, using a variable with the same name as one used in a function body will change that internal variable)? I'm not trying to be funny, I'm just trying to understand.
09:55:22 <BMeph> Or should I try asking that in #lisp and hope that someone answers me before /kicking me out? :)
09:55:33 <dcoutts_> BMeph: it makes some sense in latex
09:55:52 <dcoutts_> BMeph: but we achieve the same sort of thing using reader/state monads
09:56:46 <quicksilver> BMeph: it's safer than global variables.
09:56:53 <quicksilver> it's a global variable which you "only change locally"
09:57:03 <ndm> Saizan_: i have, but not for a while, i nearly always just use Yhc for the Core
09:57:04 <quicksilver> or a global variable which "automatically gets reset when you leave this scope"
09:57:21 <quicksilver> So, if you live in a world where global variables are common, dynamic scoping is definitely an improvement.
09:57:34 * BMeph ponders those answers
09:57:41 <quicksilver> in this world here we prefer to eschew globals completely.
09:57:46 <sclv_> http://www.haskell.org/pipermail/haskell/2006-February/017547.html
09:57:48 <lambdabot> Title: [Haskell] generic catch in a MonadIO, http://tinyurl.com/65t58t
09:57:58 <Saizan_> ndm: i see, thanks
09:58:17 <quicksilver> sclv_: nice, I hadn't seen that.
09:58:20 <ndm> Saizan_: but it should just work...
09:58:33 <sclv_> That's what takusen uses and I use in hvac too...
09:58:36 <BMeph> quicksilver: Well, I'll give you that point. I guess I'm just spoiled growing up in a generation where namespaces are taken for granted. :)
09:58:37 <quicksilver> sclv_: it's very similar to my post, although simpler.
09:58:53 <quicksilver> BMeph: namespaces are entirely orthogonal to globality.
09:58:59 <quicksilver> std::foo is every bit as global as foo
09:59:03 <sclv_> I'm curious about just how much this notion can be generalized.
09:59:17 <quicksilver> sclv_: did you read the one I posted?
09:59:39 <sclv_> I also have a number generic functions for STM, e.g., gAtomically along the same lines...
10:00:14 <sclv_> I was thinking something like monadApplyAndRebase.... as a way to generalize induction on a monad stack, but I never got very far.
10:00:36 <BMeph> quicksilver: Hmm, I'll think about that, too.
10:00:56 <quicksilver> BMeph: namespaces just let you manage your globality a bit better.
10:01:09 <quicksilver> of course the critical point here is global + mutable, not just global :)
10:01:14 <quicksilver> Data.List.filter is global.
10:04:12 <sclv_> quicksilver: looking at your post, it seems your trick is to seperate the calling and the lifting...
10:05:13 <quicksilver> sclv_: yes, taht's my trick.
10:05:17 <quicksilver> I'm not sure it's necessary
10:05:21 <quicksilver> but it made it easier in my head :)
10:08:51 <Axman6> anyone know if a much shorter way of doing this? http://hpaste.org/8990
10:09:06 <sclv_> It also seems to require IO refs, which I'm not so sure of when they're needed and when they're not -- you can certainly get more behaviours with them. When I first read your post ages ago it seemed more to apply to graphics library type things where you have to provide callbacks to begin with...
10:09:17 <sclv_> and in which case your approach makes a lot of sense.
10:09:29 <quicksilver> sclv_: well the IOrefs are the standard functionality that IO gives you for storing arbitrary state.
10:09:41 <quicksilver> in some circumstances you can "capture" that state in a local reference
10:09:50 <quicksilver> but you can't make a general combinator that way
10:09:58 <quicksilver> cos the local reference can't change it.
10:10:11 <quicksilver> it works with catch because, if the bracket runs at all, it runs at the end.
10:10:27 <quicksilver> that doesn't work for interleaving an arbitrary callback 'in the middle of' your code
10:10:33 <quicksilver> especially if it gets run multiple times.
10:11:10 <quicksilver> Axman6: you could case match on the char directly but it woudln't be much shorter
10:11:15 <ndm> Axman6: yes, i hpasted it as an annotation
10:11:32 <ndm> quicksilver: its a map :)
10:11:38 <Axman6> ah, noice
10:11:45 <quicksilver> well yes.
10:11:50 <quicksilver> that wasn't the bit I was focussing on
10:11:52 <quicksilver> but yes :)
10:12:17 <ndm> Axman6: so two things, you can use f 'A' instead of f char | char == 'A'
10:12:26 <ndm> Axman6: and you can use map for that pattern of recursion
10:12:38 <Axman6> can you do convert ('T':string) = 'A' : convert string?
10:12:52 <ndm> yes
10:13:08 <Axman6> ok, excellent, wasn;t sure if i could do that in haskell.
10:13:15 <ndm> although often convert ('T':xs) = 'A': convert xs would be more common
10:13:19 <Axman6> now i think about it, i've done that many many times, heh
10:13:27 <ndm> and using a map is better style, and less verbose
10:13:36 <Axman6> yeah
10:14:04 <sclv_> gotcha -- yeah. it seems like your approach is tackling a different problem space... I'd have to think more about how they might be combined or not... I really like the induction style generality of the gcatch approach, but it leaves something to be desired for what you can handle.
10:14:09 <ndm> you could even make the 'f' function a proper name, swapPair or something
10:14:17 <ndm> if its useful elsewhere
10:14:21 <Axman6> apparently using the tr command would be much simpler: cat file|tr TACG ATGC
10:14:39 <ndm> if that is absolutely all you want to do, it probably would be :)
10:15:05 <Axman6> yeah. but it's fun to find the haskell way of doing things :)
10:15:12 <ndm> indeed
10:15:26 <ndm> and its better generality, when you want to do something else you can easily do it
10:16:41 <quicksilver> sclv_: yes it only works because of the special style of catch.
10:16:44 <quicksilver> but it's prettier that's for sure.
10:17:45 <ndm> i was rather scared to find a lot of biologists use a lot of Perl
10:18:03 <marcot> dcoutts_: you mean it's not needed because you can workaround that with IORef?
10:18:04 <ndm> but my girlfriend is slowly being converted to Haskell
10:18:11 <dcoutts_> marcot: right
10:20:25 <marcot> dcoutts_: do you still have that link about how to automate this?
10:20:52 <dcoutts_> marcot: quicksilver posted it earlier
10:26:52 <canadaduane> BMeph: thanks for your clarification on my blog post
10:31:40 <tusho> f
10:31:42 <tusho> d
10:31:42 <tusho> d
10:31:43 <tusho> d
10:31:43 <tusho> d
10:31:43 <tusho> d
10:32:11 <dcoutts_> hrm
10:32:25 <dcoutts_> tusho: cat on the keyboard?
10:32:36 <tusho> dcoutts_: irc client weirdness on the keyboard
10:32:40 <tusho> the haskell tab was blank
10:32:47 <tusho> so I sent a load of messages seeing if it'd fix
10:32:50 <tusho> it didn't, so I restarted the client
10:33:14 <dcoutts_> tusho: ok, we'll let you off ;-)
10:33:22 <sclv_> quicksilver: hmm.. I'd have to think about it more, and probably play more with callback-based binding libs to really explore the issue... its a back burner thing that I keep wanting to play with.
10:33:30 <tusho> dcoutts_: aw damn! ok then, actually I did it to flood
10:33:32 <tusho> :-P
10:33:38 <dcoutts_> heh heh
10:38:10 <BMeph> canadaduane: I know for a fact that I left out much of the facts, but I think I summed it up well enough to get a little understanding.
10:39:07 <canadaduane> Aye, completeness is the eventual goal, but "a little understanding" is more realistic right now ;)
10:39:15 <canadaduane> thanks
10:41:37 <chrisdone> tusho: tuché
10:41:50 <BMeph> :)
10:41:50 <tusho> chrisdone: god, that was terrible.
10:41:56 <tusho> stop making puns immediately.
10:42:55 <chrisdone> tusho: ^_^
10:43:07 <tusho> chrisdone: just done make another pun, okay?
10:44:20 <chrisdone> tusho: I needed an excuse to use e acute
10:44:36 <tusho> chrisdone: that already rhymes, are you rapping now?
10:45:51 <chrisdone> tusho: let's not descend into the likes of those reddit threads
10:46:10 <tusho> chrisdone: jesus chris', I'd never do that
10:47:02 <chrisdone> tusho: terrible! now I have to do this just tusho you how it's done
10:47:24 <marcot> So why isn't http://www.haskell.org/pipermail/haskell/2006-February/017547.html implemented in a hackage package?
10:47:25 <lambdabot> Title: [Haskell] generic catch in a MonadIO, http://tinyurl.com/65t58t
10:47:31 <tusho> chrisdone: i done think this'll work. we need more source material.
10:48:03 <chrisdone> tusho: I am laughing
10:48:18 <tusho> chrisdone: you broke it
10:48:45 <ndmitchell> i have a stack overflow in my program, how do i track it down?
10:49:10 <ndmitchell> the program runs for ~100 seconds before stack overflowing, so i have virtually no idea where it is
10:49:26 <ndmitchell> and whether its a "stack too small" or "loops forever" variety
10:49:33 <chrisdone> tusho: you repeated the same pun, which ends the game :(
10:49:46 <tusho> chrisdone: how could we do any more?
10:49:49 <tusho> we'd exhausted it all
10:51:15 <chrisdone> (I don't know how to track down stack overflows)
10:51:32 * ndmitchell neither :(
10:51:40 <sjanssen> ghci debugger?
10:51:45 <bos> the profiler.
10:52:03 <bos> heap profiling usually points you at stack overflows pretty quickly.
10:52:18 <ndmitchell> bos: i'm familiar with time profiling but not heap profiling
10:52:33 <bos> if that doesn't work, roll up your sleeves and try retainer profiling. it's much harder to use.
10:52:52 <ndmitchell> -hc as a basic heap profile guess?
10:53:25 <Armored_Azrael> How can I make a monadic action strictly evaluated?
10:53:56 <bos> ndmitchell: nah, just compile with -prof -auto-all, and run with +RTS -P
10:53:58 <chrisdone> I think evaluate might suffice
10:53:59 <chrisdone> :t evaluate
10:54:09 <chrisdone> lambdabot: omfg
10:54:14 <lambdabot> thread killed
10:54:34 <ndmitchell> bos: i tried -p, will do -P now - its not in the heap profiling section of GHC's manual
10:54:43 <bos> they're almost identical.
10:54:49 <bos> -P just gives you a bit more info.
10:54:59 <ndmitchell> in fact, it says -P is "hardly ever used"
10:56:08 <chrisdone> azrael: ah, there is Control.Exception.evaluate :: a -> IO a, but I don't know of a function for general monads. I do know that `return $! myValue' will strictly evaluate myValue, if that helps
10:57:12 <Armored_Azrael> chrisdone: I'll try that with unsafePerformIO, see what happens
10:58:15 <Armored_Azrael> whee, it works
10:58:16 <Armored_Azrael> Thanks
10:58:31 <chrisdone> I'm not sure unsafePerformIO is necessary...
10:59:43 <bwr_> which package is uniq in?
10:59:49 <bwr_> i can't seem to find it in the library list
10:59:50 <chrisdone> @hoogle uniq
10:59:50 <lambdabot> Language.Haskell.TH.Syntax.Uniq :: type Uniq
10:59:50 <lambdabot> Data.Unique :: module
10:59:50 <lambdabot> Data.Unique.Unique :: data Unique
11:00:00 <bwr_> ah sweet thanks
11:00:05 <chrisdone> :)
11:00:11 <bwr_> weird i didn't see that though
11:00:11 <bwr_> :/
11:00:48 <chrisdone> I wonder if there's a Hoogle script for emacs
11:01:10 <bwr_> ah hmm... i am looking for a function to remove duplicates from a list
11:01:20 <ndmitchell> chrisdone: there is
11:01:21 <tromp> :t nub
11:01:22 <lambdabot> forall a. (Eq a) => [a] -> [a]
11:01:26 <lilachaze> Armored_Azrael: are you writing the monad or using it?
11:01:32 <chrisdone> haskell-hoogle, nice
11:01:48 <tromp> > nub "hello, world"
11:01:51 <lambdabot>  "helo, wrd"
11:01:58 <bwr_> oh no wonder i didn't find it
11:01:59 <chrisdone> @let engrish = nub
11:02:05 <lambdabot> <local>:1:10:     Ambiguous type variable `a' in the constraint:       `Eq a'...
11:02:09 <chrisdone> ;_;
11:02:23 <lilachaze> @let engrish = nub :: String -> String
11:02:26 <lambdabot> Defined.
11:02:30 <chrisdone> ^_^
11:02:30 <ndmitchell> bwr_: its based on some latin name, apparently nub means essence - a fairly wacky choice
11:03:35 <tromp> @src nub
11:03:36 <lambdabot> nub = nubBy (==)
11:03:41 <tromp> @src nubBy
11:03:42 <lambdabot> nubBy eq []             =  []
11:03:42 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
11:03:45 <tusho> > nub "hi how are you"
11:03:47 <lambdabot>  "hi owareyu"
11:03:51 <tusho> HAHHAHAHAHAHAHA
11:03:56 <tusho> > nub "i am a pink princess"
11:03:57 <lambdabot>  "i ampnkrces"
11:04:01 <tusho> that's perfect.
11:04:24 <ndmitchell> bos: thanks for the help, i think i've tracked it down :)
11:04:26 <quicksilver> wikipedia + mathematics, what a beautiful combination: imagine an ant which is tied to P with a short thread of length r
11:05:41 <tromp> > nub "quicksilver> wikipedia + mathematics, what a beautiful combination:"
11:05:43 <lambdabot>  "quickslver> wpda+mth,bfon:"
11:06:46 <Armored_Azrae1> So... either that didn't work or I've got the wrong point in mind for it to be allocating a bunch of memory
11:06:59 <tromp> > nub "the quick brown fox jumped over the lazy dog"
11:06:59 <quicksilver> Armored_Azrael: eww yuck. unsafePerformIO + evaluate just to get something forced? Just use 'seq'.
11:07:01 <Armored_Azrae1> I fell off the net because my computer thrashed paging.
11:07:02 <lambdabot>  "the quickbrownfxjmpdvlazyg"
11:07:12 * PeakerWork prefers "uniquify" to "nub". or any other name with "unique" in there
11:07:31 <tromp> unix has uniq
11:07:44 <lilachaze> > nub "crazy kirk yard scar"
11:07:46 <lambdabot>  "crazy kids"
11:08:41 <sclv_> ?all-dicts nub
11:08:42 <lambdabot> *** "Nub" gcide "The Collaborative International Dictionary of English v.0.48"
11:08:42 <lambdabot> Nub \Nub\, v. t. [Cf. {Knob}.]
11:08:42 <lambdabot>    To push; to nudge; also, to beckon. [Prov. Eng.]
11:08:42 <lambdabot>    [1913 Webster]
11:08:42 <lambdabot>  
11:08:44 <lambdabot> [44 @more lines]
11:08:47 <sclv_> @more
11:08:48 <lambdabot> *** "Nub" gcide "The Collaborative International Dictionary of English v.0.48"
11:08:48 <lambdabot> Nub \Nub\, n.
11:08:51 <lambdabot>    A jag, or snag; a knob; a protuberance; also, the point or
11:08:52 <lambdabot>    gist, as of a story. [Colloq.]
11:08:54 <lambdabot>    [1913 Webster]
11:08:55 <sclv_> @more
11:08:56 <lambdabot> [39 @more lines]
11:08:58 <lambdabot>  
11:09:00 <lambdabot> *** "nub" wn "WordNet (r) 2.0"
11:09:02 <lambdabot> nub
11:09:04 <lambdabot>      n 1: a small lump or protuberance [syn: {nubble}]
11:09:06 <lambdabot>      2: a small piece; "a nub of coal"; "a stub of a pencil" [syn: {stub}]
11:09:08 <lambdabot> [34 @more lines]
11:09:10 <Deewiant> @more
11:09:10 <lambdabot>      3: the choicest or most essential or most vital part of some
11:09:12 <lambdabot>         idea or experience; "the gist of the prosecutor's
11:09:14 <lambdabot>         argument"; "the heart and soul of the Republican Party";
11:09:16 <lambdabot>         "the nub of the story" [syn: {kernel}, {substance}, {core},
11:09:18 <lambdabot>          {center}, {essence}, {gist}, {heart}, {heart and soul}, {inwardness},
11:09:20 <lambdabot> [29 @more lines]
11:09:24 * chrisdone calls the λ knights to stop this spam
11:12:48 <gwern> the knights who say ski?
11:13:14 <sclv_> ouch!
11:13:36 <sclv_> are they demanding that we bring them a trie?
11:14:17 <glguy> ^ flood
11:14:29 <glguy> better done in /msg
11:17:36 <gwern> personally, I say it should've been uniq. nub is cute, but everyone knows uniq, and it looks more like unique. 'uniquefy' is almost self-explanatory
11:17:49 <gwern> plus, only one letter longer
11:20:42 <marcot> I wonder why these ideas sent by mail don't come out to be a package...
11:23:00 <quicksilver> I think the guys who initilaly sat down and drew up the haskell standard lib were no, as a rule, unix hackers.
11:23:03 <quicksilver> --       with [     texture Texture2D := Enabled,
11:23:05 <quicksilver> --                  textureBinding Texture2D := spheremap ms
11:23:06 <quicksilver> gah, sorry
11:23:08 <quicksilver> --            ] .
11:23:15 <dolio> Heh.
11:23:17 <quicksilver> If they had been, it might have been called uniq, not nub.
11:23:19 <quicksilver> Having said that, uniq is more like map head . group; which is how it is defined in quite a few of my programs.
11:23:48 <quicksilver> marcot: because no one has written them and uploaded them :)
11:24:04 <marcot> quicksilver: but what about copyright issues?
11:24:19 <marcot> quicksilver: it's already written in the e-mail..
11:25:19 <sclv_> Lots of times its a neat idea that doesn't seem worth it to be a lib in itself, because its more of just a trick, or a few lines of copypasta, or it would take more work to turn it into a real lib.
11:25:49 <dons> copypasta eh?
11:26:04 <dolio> What are we talking about?
11:26:06 <marcot> I think that InterleaveIO seems very interesting.
11:27:23 <sclv_> marcot: I think generally when people send neat things to -cafe they recognize they're putting them out in the public domain.
11:28:43 <dolio> Oleg doesn't make packages of any of his stuff, really.
11:29:00 <marcot> sclv_: this is a good assumption, but maybe it worths asking them..
11:29:03 <dolio> Other than maybe a zip file on his website if some trick takes multiple source files.
11:31:16 <sclv_> hmm... does -cafe have some sort of default license policy?
11:31:19 <sclv_> maybe it should.
11:31:27 <dublpaws> is a data type allowed to have the same name as the module where it is defined?
11:31:39 <dons> dublpaws: yeah.
11:31:40 <sclv_> dublpaws: it should...
11:31:43 <dublpaws> goody
11:31:51 <dolio> Many do.
11:33:07 <Toxaris> sclv_: there used to be a wiki page where people could license all their contributions to "the Haskell community" (-cafe, hpaste, wiki) under the license used for the wiki
11:36:08 <peti> Hi.
11:37:08 <chrisdone> hello
11:37:52 <desp> Hi.
11:38:31 <Dr_Foo> would anyone be able to help me figure out where i'm going wrong with a small opengl/sdl program?
11:43:25 <quicksilver> Toxaris: I believe I entered my name on that page
11:44:01 <quicksilver> marcot: speaking for the interleavble stuff, I wouldn't bother to package it until I'd used it in a decent sized program
11:44:12 <quicksilver> until you actaully use a library in practice, you rarely get the API quite right.
11:45:32 <Lemmih> dcoutts_: Hi, Greens was closed. I'm outside the university.
11:45:52 <dcoutts_> Lemmih: outside my building you mean?
11:46:09 <Lemmih> Yes.
11:46:14 <dcoutts_> Lemmih: ok, see you in a sec...
11:46:19 <sclv_> http://www.haskell.org/haskellwiki/Haskell_Cafe_migration
11:46:21 <lambdabot> Title: Haskell Cafe migration - HaskellWiki
11:46:26 <sclv_> maybe it should be moved/highlighted
11:46:27 <Lemmih> Did a bit of warwalking.
11:47:28 <marcot> quicksilver: I think the API can evolute with the time...
11:48:14 <sclv_> Dr_Foo: by the way, its usually better to just hpaste/ask away and someone will jump in 80% of the time.
11:48:14 <quicksilver> sclv_: damn I'm not on the list!
11:48:17 * quicksilver adds.
11:48:39 <quicksilver> Dr_Foo: I have plenty of experience of opengl/haskell but none of SDL. Still I can try.
11:49:19 <Dr_Foo> http://omploader.org/vbTNl
11:49:20 <lambdabot> Title: pasta (VimColour)
11:49:32 <Dr_Foo> ^ this should display a square and a triangle but it doesn't
11:50:29 <Dr_Foo> and i wish i could be more specific but sadly "it doesn't work" is the best i can manage
11:51:02 <quicksilver> Dr_Foo: all black screen?
11:51:08 <Dr_Foo> yep
11:51:19 <PeakerWork> Dr_Foo: btw: There's withSDL or something like that, does a brack SDL.init/quit for ya
11:51:46 <Dr_Foo> i'll remember to try that out, at the moment i'm just working with a direct translation of the equivalent C program
11:51:47 <quicksilver> Dr_Foo: you don't set a colour before drawing the quads/tri
11:51:54 <quicksilver> so you're drawing black on black perhaps?
11:52:07 <dons> next week's galois tech talk, http://groups.google.com/group/pdxfunc/browse_thread/thread/9f30e09bc96fc133
11:52:10 <lambdabot> Title: Galois Tech Talk: Equivalence Checking Public-Key Crypto Algorithms - pdxfunc |  ..., http://tinyurl.com/5kbsoq
11:52:39 <marcot> @hoogle IO (a, b) -> (a -> IO c) -> (b -> IO d) -> IO (c, d)
11:52:41 <lambdabot> No matches, try a more general search
11:52:41 <desp> How would you create a lookup table from Strings to Ints?
11:52:51 <PeakerWork> Dr_Foo: I think the SDL parts look okay, so its probably a GL problem
11:53:00 <PeakerWork> desp: Data.Map String Int
11:53:02 <mauke> Map String Int
11:53:05 <desp> Thanks.
11:53:11 <desp> (Doh.)
11:53:39 <Dr_Foo> i'd use [(String, Int)] but i'm a recovering lisp addict
11:53:58 <tusho> Dr_Foo: uh. no. :p
11:54:01 <Vq^> Dr_Foo: there isn't any associative arrays in lisp?
11:54:23 <quicksilver> [(String,Int)] is isomorphic to Data.Map and perfectly find for simple cases.
11:54:29 <quicksilver> there is even a standard function to deal with that case:
11:54:33 <quicksilver> :t lookup
11:54:39 * quicksilver slaps lambdabot 
11:54:48 <lambdabot> thread killed
11:54:49 <quicksilver> :t lookup
11:54:54 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
11:55:02 <tusho> Vq^: there is.
11:55:04 <desp> That's pretty cool.
11:55:07 <tusho> but not in scheme.
11:55:10 <desp> The slapping thing, I mean.
11:55:10 <tusho> (in the standard.)
11:55:41 <Vq^> tusho: but still, that can't be the standard way of emulating it, right?
11:55:59 <tusho> Vq^: In Scheme, you use your implementations libs, or [(String,Int)].
11:56:08 <Vq^> hmm
11:56:12 <tusho> ((a . 2) (b . 3))
11:56:12 <olsner> heh, apparently, \bot likes light spanking
11:56:18 <PeakerWork> Dr_Foo: also, you might be drawing into a single pixel?
11:56:19 <tusho> R5RS defines some functions for operating on them.
11:56:20 <tusho> BUT
11:56:23 <tusho> r6rs has hashes and stuff.
11:56:26 <quicksilver> bearing in mind that lisp lists are mutable in the middle
11:56:26 <tusho> But, you know.
11:56:29 <tusho> everyone hates r6rs
11:56:38 <quicksilver> lists of pairs are quite decent for assoc arrays in lisp
11:56:51 <quicksilver> in haskell they should only be used for read-only arrays of small size.
11:56:55 <tusho> > product [1..555555555]
11:56:57 * tusho slaps lambdabot 
11:57:10 <tusho> it should totally use /me slaps lambdabot as a 'kill thread'
11:57:11 <lambdabot>  thread killed
11:57:14 <PeakerWork> Dr_Foo: what does GL.perspective set up for you, in terms of the meaning of (-1, 1) coordinates?
11:59:03 <Dr_Foo> PeakerWork: i wish i knew the answer to that question almost as much as i wish i understood the question
11:59:05 <quicksilver> PeakerWork: viewing frustrum pointing down negative Z
11:59:24 <quicksilver> PeakerWork: with near clip at -0.1 Z
11:59:27 <quicksilver> far clip at 100 Z
11:59:34 <quicksilver> and FOV 45 degrees.
11:59:39 <Dr_Foo> http://omploader.org/vbTNn <- this is the C program i'm translating from
11:59:39 <lambdabot> Title: pasta (VimColour)
11:59:42 <quicksilver> eye at origin
12:00:06 <quicksilver> Dr_Foo: I believe your error is in your Gl.translate call
12:00:11 <quicksilver> Dr_Foo: you want (-6) not 6.0
12:00:22 <quicksilver> Dr_Foo: you drew all your geometry behind the camera
12:01:04 <quicksilver> Dr_Foo: and glEnable(GL_DEPTH_TEST) is translated to depthTest $= Enabled, by the way.
12:01:28 <Dr_Foo> hah, you're right that was the problem
12:01:32 <Dr_Foo> stupid typo i didn't spot
12:01:33 <quicksilver> ;)
12:01:45 <quicksilver> most common openGL problem 1 : objects not in view of camera
12:01:50 <Dr_Foo> i've lost count of how many times that has happened to me
12:01:54 <PeakerWork> quicksilver: so the Z seems ok, but what about (0..1) x/y values - will those map to the viewport nicely, or fit inside a pixel?
12:01:54 <quicksilver> 2 is probably lights are off it's all dark.
12:02:21 <quicksilver> PeakerWork: well you'd have to draw the pyramid on a piece of paper to work that out ;)
12:02:35 <quicksilver> since the eye is at the origin
12:02:36 * PeakerWork delegates that work to Dr_Foo 
12:02:56 <quicksilver> and the FOV is 45 degree
12:03:03 <quicksilver> erm...
12:03:17 <quicksilver> at 0.1 you'd have a 0.1x0.1 viewable screen if your monitor was square
12:03:27 <quicksilver> from (-0.5,-0.5) to (0.5,0.5)
12:03:43 <quicksilver> monitors aren't really square but that gives you the general idea
12:03:50 <quicksilver> from (-0.05,-0.05) to (0.05,0.05)
12:03:52 <quicksilver> of course :)
12:04:04 <quicksilver> as the Z coord goes more negative you can 'see more'
12:04:15 <quicksilver> Dr_Foo's objects are drawn at Z=-6
12:04:22 <quicksilver> so the screen is approx 6x6 there
12:04:26 <quicksilver> depending on his actual aspect ratio
12:06:30 <Dr_Foo> i don't see a depthTest in the docs... i think probably it's enabled automatically if you set depthFunc to anything other than Nothing
12:06:37 <chrisdone> quicksilver: haha, today's IRC log --> http://chrisdone.com/haskell.png ( program to make it: http://hpaste.org/8992 ). this is why I made this library, just so I could generate this :P /shame
12:07:04 <quicksilver> chrisdone: mwhahahahaha
12:07:25 <quicksilver> Dr_Foo: no, it's not.
12:07:30 <quicksilver> not as far as I can remember.
12:07:39 <quicksilver> but you don't need a depthTest for your simple program
12:07:42 <quicksilver> nothing overlaps.
12:07:57 <Dr_Foo> i know
12:08:49 <quicksilver> Dr_Foo: I was wrong though.
12:08:56 <quicksilver> it's depthMask $= Enabled
12:08:57 <quicksilver> (sorry!)
12:10:08 <quicksilver> Dr_Foo: I think sven slightly adjusted the API there, probably because he thought the openGL way was a bit odd.
12:10:21 <quicksilver> so depthMask controls depth writes, and depthTest controls depth reads.
12:10:26 <quicksilver> depthFunc!
12:10:30 <quicksilver> damn typos.
12:10:32 <Dr_Foo> :)
12:10:36 <quicksilver> so depthMask controls depth writes, and depthFunc controls depth reads.
12:10:55 <quicksilver> rather than having a glEnable AND a mask AND a func
12:10:59 <quicksilver> which seems over-complex
12:11:21 <quicksilver> in a few places sven's translation notably simplifies the API or makes it more haskell-like
12:12:16 <Dr_Foo> well my previous experience with 3d programming was directx in vb6 for a small company whose code was over a decade old in places, so i consider pretty much anthing a step up, sanitywise
12:15:28 <quicksilver> well the real win of haskell in this is the abstraction abilities
12:15:55 <Dr_Foo> indeed
12:18:39 <Dr_Foo> well thanks for the help quicksilver, i'm off to break me some more code
12:19:03 <quicksilver> Dr_Foo: minor improvement for you http://hpaste.org/8995
12:19:15 <quicksilver> Dr_Foo: less repeated 'vertex' stuff :)
12:19:18 <quicksilver> more concise coord lists
12:22:19 <olsner> :t uncurry3
12:22:24 <lambdabot> Not in scope: `uncurry3'
12:25:10 <Maro> hello everyone
12:25:31 <od> how do you think opengl 3.0 is gonna workout for haskell
12:25:41 <od> i heard theyre making objects immutable or something
12:27:09 <Maro> but this would be a bad thing to do
12:28:46 <gwern> 'The function everyone has been asking for, it seems to me, is actually the right inverse of intercalate.  This suggests that it might be named "deintercalate", which would be awesome assuming we hate each other and ourselves.'
12:29:11 <olsner> what's wrong with extracalate?
12:29:25 <dolio> I thought we'd decided on ubercalate.
12:29:43 <mauke> escalate
12:29:47 <byorgey> outercalate?
12:29:57 <olsner> intracalate?
12:30:06 <gwern> paracalate
12:30:07 <byorgey> parahypozygohistocalate
12:30:22 <olsner> chocalate
12:30:44 <sclv_> reverseAnIntercalationPreviouslyDone
12:31:03 <sclv_> I'm actually a big fan of unintercalate -- so much fun to say!
12:31:16 <quicksilver> od: well that fits well with the haskell notion of immutable values
12:31:25 <dolio> I'll go with split.
12:31:52 <sclv_> what would you call his split/splits though?
12:32:08 <od> yea would be nice to have a native 3d engine in haskell
12:32:09 <sclv_> its not exactly partitions...
12:32:22 <mfp> gwern: a function that picks every 2nd element starting from 0?
12:32:48 <mfp> in DSP, that'd be "downsample"
12:33:49 <sclv_> instead of unintercalate, maybe "stanzas" would be a good name!
12:34:04 <dolio> At a glance, I'd say I'd never use his function split/splits.
12:34:11 <mauke> stanzae
12:34:23 <quicksilver> I think stanzas is a good name for what I call groupsOf
12:34:24 <sclv_> stanzaux
12:34:44 <quicksilver> groupsOf n = takeWhile (not.null) . map (take n) . iterate (drop n)
12:34:54 <gwern> y'all're having entirely too much fun with this
12:34:59 <chrisdone> olsner: yeah, there really needs to be an uncurry3, I needed it today =o
12:35:06 <quicksilver> which is of course, a left inverse to concat
12:35:42 <olsner> chrisdone: otoh, once you start down that road, eventually you'll be looking for uncurry17 :P
12:35:58 <brad_larsen> uncurryN+1
12:36:04 <olsner> indeed
12:36:23 <sclv_> oh, groupsOf is chunk!
12:36:25 <chrisdone> well uncurry3 is great for x,y,z
12:36:49 <quicksilver> sclv_: yes, I just prefer that name.
12:38:29 <BMeph> What's the comonadic mu called?
12:38:54 <BMeph> s/mu/mu analogue/
12:38:55 <dolio> You mean w a -> w (w a)?
12:39:12 <chrisdone> olsner: uncurry3 crops up a lot for different people, and that seems to be how things are deemed to be worthy of being added to the standard library
12:39:17 <dolio> Epsilon, maybe...
12:39:21 <BMeph> dolio: Genau^H^H^H^H^H Exactly.
12:39:30 <byorgey> BMeph: nu is used to indicate greatest fixed point, is that what you mean?
12:39:31 <augustss> BMeph: cowmoo
12:39:40 <mauke> ^H^H^H^H^H better written as ^W
12:39:48 <BMeph> augustss: Ha-ha! ;p
12:40:02 <byorgey> oh, not that mu
12:40:21 <byorgey> misunderstood the question =)
12:40:31 <chrisdone> ^W better written as M-x whoops-i-didnt-mean-that
12:40:34 <dolio> Epsilon might be the eta analogue...
12:40:35 <dmhouse> Mu as in eta and mu being the monad natural transformations.
12:40:43 <gwern> chrisdone: well, how else would you decide what went into the standard libs?
12:40:48 <BMeph> mauke: Still re-learning Emacs - it's been years since I've last used it.
12:40:49 <sclv_> speaking of, is his splits just the following?
12:40:51 <olsner> I think, some of these things should be auto-generated by e.g. the compiler so that uncurry1048576 works whenever insanity gets widespread and bad enough that someone finds a need for it
12:40:52 <sclv_> > uncurry zip $ inits &&& tails $ [1..10]
12:40:54 <lambdabot>  [([],[1,2,3,4,5,6,7,8,9,10]),([1],[2,3,4,5,6,7,8,9,10]),([1,2],[3,4,5,6,7,8,...
12:40:55 <mauke> BMeph: emacs‽
12:41:00 <quicksilver> dolio: I'm fairly sure I've seen it just written as mu for the comonad case too.
12:41:11 <mauke> BMeph: I use ^W in shells, irssi and vim
12:41:12 <BMeph> mauke: EMACS? ;)
12:41:14 <dolio> Really?
12:41:23 <chrisdone> gwern: that's my point. olsner suggested adding uncurry3 will lead to (read: slippery slope fallacy) uncurry17
12:41:25 <sclv_> in which case yeah, giving it a special name hardly seems worth it.
12:41:26 <dmhouse> mauke: interrobang?
12:41:31 <mauke> dmhouse: yep
12:41:35 * byorgey suggests using 'um' and 'ate'
12:41:36 <olsner> or maybe there could be an UnCurry type class that can recursively deconstruct tuples
12:41:37 <chrisdone> pinnacle of optimisation
12:41:44 <dmhouse> Wow, I actually knew the name for that off the top of my head. Go Wikipedia.
12:41:47 <quicksilver> dolio: or mu-bar
12:42:16 <dolio> Not sure if I've seen that. But comonad literature is somewhat rarer than monad literature.
12:42:23 <gwern> chrisdone: maybe someone should write some Template Haskell to construct up to uncurry20 :)
12:42:29 <dozer> is there a good place to start if I want to do some opengl stuff with haskell?
12:42:31 <olsner> chrisdone: hmm, yeah, there was a bit of slippery-slope there, but also the idea that requiring the manual addition of uncurry functions is wrong from the start since N will always be less than N+1
12:42:39 <dolio> So I've read less of it.
12:42:49 <dons> dozer: there's an opengl/haskell tutorial on the wiki
12:43:06 <chrisdone> olsner: yeah, I agree there
12:43:23 <gwern> actually, why don't we have a generalized uncurry? it seems to me you should be able to turn a tuple into a list, and then index into it
12:43:28 <quicksilver> dolio: of course I can't effectively google because it's all haskell stuff :)
12:43:39 <dolio> Yeah, I know. :)
12:43:40 <dons> gwern: what's the type?
12:43:40 <quicksilver> dolio: and I don't have any of my CT to hand
12:43:44 <quicksilver> CT books.
12:43:47 <gwern> so you'd have 'uncurry n tup = n !! (listify tup)'
12:43:51 <Baughn> Have only two-tuples, and have (a,b,c) desugar to (a,(b,c))?
12:43:58 <quicksilver> gwern: you can write a tuple typeclass
12:43:59 <ddarius> Usually delta is used for the comonadic analogue of mu
12:44:01 <dons> what's the type of listify.
12:44:04 <Baughn> That would let you use whatever type tricks you need to generalize
12:44:05 <quicksilver> but nobody bothers
12:44:09 <quicksilver> because it's just not much fun.
12:44:12 <gwern> dons: er... oh.
12:44:20 <dons> neither fun nor useful. :)
12:44:26 <BMeph> gwern: For the same reason why we don't have a generalized zip/zipWith - Haskell doesn't (quite, yet) bend so easily that way. :)
12:44:35 <dons> now, why don't tuples have labelled fields?
12:44:42 <ddarius> So use the Applicative instance
12:44:45 <dolio> Ah, yeah, found something in my comonad folder.
12:44:50 <dolio> (T, epsilon, delta)
12:44:58 <quicksilver> dons: well, I occasionally want something a bit like it when I write code which wants to work in 2 or 3 dimensions
12:45:05 <gwern> BMeph: phooey
12:45:10 <quicksilver> dolio: ah yes, of course, Delta for diagonal.
12:45:18 <quicksilver> x -> (x,x)
12:45:19 <sclv_> dons: I thought they did... we just called them records?
12:45:33 <ddarius> quicksilver: Uh, "duplicate" is usually the word
12:45:38 <sclv_> and declared them explicitly
12:45:47 <quicksilver> he means the actual types (a,b,c,d)
12:45:49 <quicksilver> e.g.
12:46:05 <quicksilver> data (a,b,c,d) = (#1 :: a, #2 :: b, #3 : c, #4 :: d)
12:46:06 <BMeph> dolio: So eta's is epsilon, and mu's is delta?
12:46:08 <quicksilver> which is what ocaml does
12:46:10 <quicksilver> IIRC.
12:46:18 <dolio> BMeph: Yeah.
12:46:23 <dolio> In at least one paper. :)
12:46:39 * chrisdone ponders functional references again
12:46:42 <BMeph> dolio: So where did you acquire this folder of yours? :)
12:46:46 <quicksilver> ddarius: well multiplication and co-multiplication and closely related to diagonal and co-diagonal
12:47:01 <dolio> The internet.
12:47:05 <quicksilver> dons: at leat I assume that's what you meant.
12:47:44 <dolio> The first paper in that folder was Computational Comonads and Intensional Semantics, which uses that notation.
12:49:00 <dons> i mean, like  data (,) a b = (,) { fst :: a, snd :: b }
12:49:06 <quicksilver> yup
12:49:10 <quicksilver> data (a,b,c,d) = (#1 :: a, #2 :: b, #3 : c, #4 :: d)
12:49:17 <quicksilver> generalises better to n ;)
12:49:35 <byorgey> yeah, but then what's the type of #1?
12:49:39 * Cale wants a proper record system...
12:49:55 <BMeph> Cale: Which means...? :)
12:49:57 <olsner> oh, great... I can't remove the 17-tuple instances for these type classes until I've record-syntaxified the *other* use of 17-tuples :D
12:50:10 <Cale> I know exactly what I want, but I'm not competent enough to implement it.
12:50:14 <byorgey> maybe data (a,b,c,d) = (#4_1 :: a, #4_2 :: b ...
12:50:27 <dolio> The next one, "Comonadic functional attribute evaluation," uses epsilon and _^dagger for coextension :: (w a -> b) -> w a -> w b.
12:50:36 <Cale> BMeph: For the overall semantics, see Daan Leijen's proposal.
12:51:16 <BMeph> Cale: in -cafe, the Wiki, or a separate paper? :)
12:51:25 <Cale> In a paper :)
12:51:29 <Cale> one sen
12:51:30 <Cale> sec*
12:51:40 <quicksilver> "extensible records with scoped labels" ?
12:51:42 <Cale> http://research.microsoft.com/users/daan/download/papers/scopedlabels.pdf
12:51:44 <lambdabot> Title: Extensible records with scoped labels, http://tinyurl.com/392r4k
12:51:54 <quicksilver> I'm sure there was something I didn't like abut that.
12:51:59 <quicksilver> can't remember now.
12:52:03 <Cale> The syntax the paper uses sucks.
12:52:08 <Cale> Other than that, it's great.
12:52:27 <Cale> I'd like what is essentially that, but a slightly different interface to the functionality
12:52:43 <Cale> (allowing the record labels to act as lenses)
12:53:37 <Cale> There's one thing which I can imagine some people not liking at first, and that's that a record is allowed to have multiple fields with the same label.
12:53:52 <quicksilver> I think that's just there to make the rules simpler
12:53:56 <quicksilver> in a sense
12:54:00 <Cale> But that's actually quite a useful property in a lot of cases too.
12:54:08 <quicksilver> it's not necessarily intended that you actually use that feature.
12:54:09 <dolio> Yeah, it eliminates the need for lacks predicates.
12:54:12 <Cale> yes, and it makes everything simpler by not requiring lacks predicates
12:54:19 <quicksilver> it just makes your polymorphism feel simpler
12:54:20 <quicksilver> right.
12:54:31 <quicksilver> it probably makes implementation easier too.
12:54:33 <quicksilver> I should guess.
12:54:36 <Cale> It's also nice to know that you can add a field to a record and later remove it and end up with the same thing
12:54:49 <Cale> Without any constraint on the record type.
12:54:54 <quicksilver> Cale: even replacing our current haskell record sugar with lenses would probably help a lot.
12:55:13 <Cale> But our records aren't really records :)
12:55:24 <quicksilver> well that depends what you mean by record, but yes.
12:55:36 <quicksilver> I'm increasingly using lenses with them by hand.
12:55:59 <olsner> any new record syntax should allow for same-named fields in different data types, at the least
12:56:19 <quicksilver> funnily enough, that's one of the things I care about least.
12:56:20 <Cale> Oh, for the syntax, I would steal all the names starting with a single quote (and not containing a second single quote) for label names.
12:56:26 <quicksilver> I can't get excited about namespaces
12:56:38 <quicksilver> haskell has enough namespace tools.
12:56:49 <Baughn> I /would/ like to stop having to prefix everything. It's annoying, and the compiler should be able to keep them apart most of the time without assistance
12:57:00 <chrisdone> Baughn: me too
12:57:00 <quicksilver> I'm not saying it wouldn't be convenient sometimes, but it's not one of things that bothers me.
12:57:03 <Cale> It would help if we could define submodules.
12:57:19 <Baughn> Cale: Can you point me to a paper/explanation of lenses?
12:57:43 <Cale> Baughn: The idea is simple enough. Basically a lens is a tuple consisting of the operations on a record
12:57:59 <Cale> Baughn: and you have extractors which can be used to get at those operations of course
12:58:02 <quicksilver> I can point you to a simple implementation of lenses: http://hpaste.org/8254
12:58:17 <Baughn> Cale: THat's just basic OO, isn't it? Accessors
12:58:21 <Cale> Baughn: yes
12:58:32 <Cale> Baughn: but without any mutation :)
12:58:49 <Baughn> OO does not require mutation. ^^;
12:58:58 <quicksilver> I don't think this has got anything to do with OO.
12:59:11 <ddarius> Cale: Yes, I'm thinking about making a simple proposal for a "local modules" system.
12:59:26 <quicksilver> no more so that "data" is to do with OO.
12:59:27 <Baughn> Oh, functional references
12:59:34 <Baughn> I have a blog post on that in a tab.. somewhere..
12:59:37 <Cale> Baughn: yeah
12:59:43 <quicksilver> probably twanvl's one
12:59:45 <quicksilver> it's good.
12:59:48 <quicksilver> (blog post)
12:59:48 <Cale> Baughn: Clearly you have too many tabs open :)
13:00:11 <Baughn> Clearly. Three hundred and fourteen, which is almost two thousand less than my last peak.
13:00:20 <Cale> I've stopped using so many tabs now that firefox's address bar searches through history
13:00:44 <Cale> But I never used all that many anyway :)
13:00:44 <Baughn> The search function is nice, but it does require you to /remember/ you're supposed to read something
13:00:54 <Baughn> Like the functional references tab. I'd've gotten to it eventually.
13:00:55 <Heffalump> Baughn: how much RAM do 2000 tabs take up?
13:01:24 <Baughn> Heffalump: It was an accident. Also, too much - I don't know exactly how much, but it pushed an 8GB system into swap.
13:01:25 <chrisdone> get field foo, set field newV foo, update (\x -> x+1) foo, it would be kind of cool if this worked on lists, maps, user-defined..
13:01:42 <chrisdone> er, update field (\x->x+1) foo
13:02:04 <Cale> chrisdone: Well, of course you can define lenses which make those work on any structure
13:02:30 <quicksilver> chrisdone: yes, that's exactly what lenses are for.
13:02:39 <quicksilver> chrisdone: with the added benefit that you can compose them
13:02:53 <quicksilver> get (field1 <.> field2) foo
13:02:58 <chrisdone> quicksilver: well that sounds great
13:02:59 <Baughn> quicksilver: So the end result looks somewhat like CL's setf?
13:03:08 <quicksilver> where field2 is a lense on whatever structure field1 is.
13:03:17 <chrisdone> not sure how composable setf is
13:03:23 <chrisdone> I thought it was just clever macros
13:03:36 <Baughn> It is, but they're /supposed/ to be infinitely composable
13:03:41 <chrisdone> oh, I see
13:03:46 <Baughn> "Clever macros" just means "compile-time logic", after all
13:04:03 <quicksilver> http://hpaste.org/8996
13:04:16 <quicksilver> chrisdone: for example, that's how I update three fields in a structure
13:04:23 <quicksilver> (two of them being nested fields and one not)
13:04:35 <Baughn> Okay. How efficient is that?
13:05:13 <quicksilver> not really thought about it. it all inlines away I guess
13:05:21 <Baughn> Wrong question, I suppose.. you'll just need to make ghc smarter if it doesn't
13:05:38 <quicksilver> it's updating a fair few pointers and creating some new cells, sure
13:05:43 <quicksilver> that's the price we pay for mutability
13:05:51 <quicksilver> on the flipside, all the bits which didn't change get shared.
13:06:00 <chrisdone> quicksilver: hmm very nice indeed
13:06:30 <olsner> "darcs: bug in get_extra commuting patch:"
13:06:37 <Baughn> So if you alter a cell containing 3::Int to 1::Int, it only costs you one bit? ;)
13:06:38 <chrisdone> quicksilver: how do you define the lenses? template haskell?
13:06:50 <dozer> mm - glxgears works just fine but the HelloWindow haskell opengl example is rendering random memory into the window
13:06:51 <quicksilver> chrisdone: annoying boilerplate but at least you only have to write it once
13:06:58 <quicksilver> TH could automate it certainly.
13:06:58 <chrisdone> quicksilver: I suppose a GHC rule could kind of automate it?
13:07:09 <chrisdone> quicksilver: ah
13:07:15 <olsner> oh, I have the same patch applied at different times in the two repositories
13:08:14 <quicksilver> chrisdone: updated paste : http://hpaste.org/8996#a1
13:08:19 <quicksilver> it is annoying but it's only one line per field
13:09:30 <chrisdone> quicksilver: ahh, I see it. yeah, write-once for a lot of benefit
13:09:35 <quicksilver> exactly.
13:09:38 <BMeph> Looks like that paper's written with OO devotees in mind.
13:09:43 <sclv_> I'm sort of curious about the relation between lenses as getter/setter tuples and pickler/unpicklers as a different sort of bidirectional tuple.
13:09:45 <quicksilver> and it's pretty clear it could be automated.
13:10:00 <sclv_> maybe we can see pickler pairs as a special case of general lenses?
13:10:00 <quicksilver> sclv_: yes, me too.
13:10:04 <chrisdone> quicksilver: right
13:10:21 <quicksilver> sclv_: I often thiink about a DSL for writing both halves of a Binary instance at once
13:10:27 <gwern> I saw one research group working on lenses, and they mentioned picklers were lenses
13:10:28 <quicksilver> sclv_: or more generally, read/write a file format at once.
13:10:35 <gwern> the guys who did Unison, iirc
13:10:39 <quicksilver> the problem is that you can only reduce the problem so far
13:10:45 <ddarius> sclv_: They are a special case of general lenses.
13:10:52 <quicksilver> and then you need to get from (MyType -> general tuple -> MyType)
13:11:02 <quicksilver> and that ends up being boilerplate no matter how celver you are.
13:11:12 <sclv_> and lenses are a special case of "composable things" -- i.e. "Control.Category"...
13:11:13 <ddarius> The "guys who did Unison" would be Benjamin Pierce
13:11:22 <chrisdone> I was trying to write updateConfig config f v = config { f = v }, a couple days ago. stupid but it seemed to make sense at the time
13:11:31 <sclv_> I'm not sure how much I agree with his argument that you need language-level support to do it right...
13:11:42 <quicksilver> sclv_: yes, certainly. although I don't think Control.Category is very useful.
13:11:49 <BMeph> Isn't that the example they use in the Boomerang paper?
13:11:49 <quicksilver> sclv_: lenses are 'composable things', sure.
13:11:58 <quicksilver> but 'composable things' don't have enough interesting structure
13:12:11 <quicksilver> there are no interesting generic combinators on 'composable things'
13:12:25 <sclv_> right... so the question in a sense is what other laws do lenses obey, or picklers, such that we can provide more structure to them...
13:12:29 <quicksilver> except perhaps multicompos :: [a->a] -> a->a
13:12:42 <BMeph> quicksilver: It's all about the "decomposable things," eh? :)
13:13:07 <quicksilver> :)
13:13:13 <dibblego> http://www.reddit.com/info/6saab/comments/
13:13:13 <lambdabot> Title: reddit.com: Haskell exercises for beginners
13:13:16 <chrisdone> quicksilver: is your lenses code in a module somewhere that I could maybe steal and use in my own projects? v_v
13:14:20 <quicksilver> chrisdone: I haven't uploaded it. I'm happy to hpaste the latest version for you though
13:14:25 <chrisdone> quicksilver: actually, I'm fairly surprised there isn't a hackage package? what do you think about that?
13:14:29 <chrisdone> quicksilver: please do :)
13:14:37 <quicksilver> thre is a hackage package by someone else
13:14:42 <quicksilver> data.accessor I think it's called?
13:14:46 <quicksilver> not quite the same API as mine
13:14:54 <chrisdone> hmm, I will look at that too
13:15:29 <quicksilver> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/data-accessor
13:15:34 <lambdabot> Title: HackageDB: data-accessor-0.0.1, http://tinyurl.com/58srnn
13:15:40 <sclv_> quicksilver: not so sure about whether that boilerplate can't be abstracted away...
13:15:41 <chrisdone> quicksilver: thanks
13:16:15 <sclv_> the stuff I'm playing with for staticrecord, for instance...
13:16:21 <sclv_> mapFromTuple et al
13:16:33 <quicksilver> sclv_: I think that to do so you need an isomorphism between each structure and its "generic haskell tuple cousin"
13:16:52 <quicksilver> e.g. for data MyType = MkMT String Int [Char]
13:17:05 <quicksilver> you need MyType <-> (String,Int,[Char])
13:17:17 <quicksilver> or possibly (String,(Int,([Char],())))
13:17:23 <sclv_> right -- but you can get that with SYB.
13:17:32 <quicksilver> yes I mean you can't do it in haskell.
13:17:40 <quicksilver> and of course you have to unwrap any recursion
13:17:46 <quicksilver> into parameters
13:17:46 <sclv_> SYB is in haskell.
13:18:07 <quicksilver> no it's not, it's a GHC metaprogramming tool with a haskell API
13:18:13 <quicksilver> I'm not just trying to be pedantic here :)
13:18:20 <quicksilver> but the real *meat* of SYB is in the Data instances
13:18:29 <quicksilver> which you either write yourself (boilerplate) or get GHC to (compiler support)
13:18:59 <quicksilver> chrisdone: data.accessor lacks my (.=) operator which seems sad.
13:19:13 <sclv_> haha ok, but for practical purposes you can do it all in "haskell + deriving data"
13:19:36 <sclv_> is (.=) just sugar for `set`?
13:19:51 <quicksilver> sugar for set, flipped
13:19:52 <quicksilver> yes.
13:20:01 <quicksilver> http://hpaste.org/8254#a1
13:20:09 <quicksilver> but this whole exercise is about sugar :)
13:20:22 <quicksilver> chrisdone: current version pasted there
13:20:42 <sclv_> eh, I think lenses are a bit more than that...
13:21:16 <chrisdone> quicksilver: thanks, that Data.Accessors uses template haskell which I'm a little wary of, and its get and set functions are only for in monads which won't do for me
13:21:52 <quicksilver> chrisdone: yes, I have separated Lens and MonadLens
13:21:54 <quicksilver> both are useful.
13:22:01 <chrisdone> quicksilver: indeed :)
13:22:11 <quicksilver> sclv_: but anyhow, yes, you're right, haskell + deriving data is very powerful
13:22:22 <quicksilver> deriving data is a substantial chunk of metapgroamming power.
13:22:42 <quicksilver> you can do many clever things
13:22:53 <quicksilver> but like all metaprogramming beware of how it destroys equational reasoning.
13:23:14 <sclv_> for instance there's this -- lenses for free over any type deriving Data
13:23:17 <sclv_> http://www.haskell.org/pipermail/haskell-cafe/2008-April/042193.html
13:23:18 <lambdabot> Title: [Haskell-cafe] Generic functional references for free, now!, http://tinyurl.com/58vzwk
13:23:24 <sclv_> (with a runtime course, of cost)
13:23:34 <chrisdone> quicksilver: what is the separate IO lens for when there is a monad lens? readability?
13:23:35 <sclv_> quicksilver: howso with destroying equational reasoning?
13:24:04 <quicksilver> chrisdone: legacy code :P
13:24:10 <chrisdone> quicksilver: ahh :P
13:24:15 <quicksilver> sclv_: well, there are loads of examples.
13:24:25 <quicksilver> A simple one: deriving Show breaks alpha-substitution
13:24:47 <quicksilver> deriving data breaks all kinds of things, most obviously reordering constructors
13:25:24 <ddarius> quicksilver: The point of Scrap Your Boilerplate is to have only -one- collection of boilerplate.  Rather than many.
13:25:33 <quicksilver> ddarius: yes, I recognise that :)
13:25:54 <quicksilver> sclv_: very nice, by the way, the generic FRs
13:27:53 <sclv_> quicksilver: thanks. the exception trick is sort of ridiculous, but its lots of fun.
13:28:13 <chrisdone> @src Typeable
13:28:13 <lambdabot> Source not found. I've seen penguins that can type better than that.
13:28:37 <sclv_> as for reordering constructors, doesn't that always break things? (i.e. you can also get at constructor order with structural induction, etc.)
13:28:53 <sclv_> oh, wait, that's the order of arguments *to* constructors... nevermind.
13:29:21 <quicksilver> sclv_: it 'sort of' doesn't matter.
13:29:38 <quicksilver> until you do a refactoring where this shouldn't be relevant, and you break all your binary file formats
13:29:54 <quicksilver> because you realise your binary file formats were generated by SYB and dependent on constructor order, etc.
13:30:08 <quicksilver> I agree that's not exactly a common pitfall.
13:34:18 <quicksilver> sclv_: *lightbulb*
13:34:24 <quicksilver> I see how your code works.
13:34:33 <quicksilver> using SYB to stuff a record with numbered exceptions.
13:34:36 <quicksilver> that's... weird?
13:35:20 <quicksilver> who invented the idea of being able to distinguish different _|_? What monsters have they unleashed for sclv to tame?
13:36:20 <quicksilver> thus giving us a way to embed the integers into *any* type
13:36:29 <quicksilver> generically.
13:36:56 <sclv_> I think its the most useful evil thing I've ever come up with.
13:37:06 <quicksilver> in fact you can give any type any other type!
13:37:15 <quicksilver> you can write: disguise :: a -> b
13:37:23 <quicksilver> which conceals a value of type a into a _|_-value of type b
13:37:34 <quicksilver> and reveal :: b -> a which pulls it out.
13:37:48 <quicksilver> bye bye logic! ...
13:39:04 <Carlos_Pereira> hello
13:39:12 <Carlos_Pereira> i've a question
13:39:23 <Carlos_Pereira> is haskell a replace for lisp?
13:39:35 <dons> yes.
13:39:39 <quicksilver> haskell can be used to replace lisp as a programming language, yes.
13:39:47 <sclv_> buh-bye typing, buh-bye hm inference. we're through the looking glass people!
13:39:51 <dibblego> @faq Can Haskell replace Lisp?
13:39:51 <quicksilver> for any program written in lisp you could have written it in haskell.
13:39:51 <lambdabot> The answer is: Yes! Haskell can do that.
13:40:03 <Carlos_Pereira> thaks
13:40:11 <quicksilver> depending on the program the translation may be easy or hard :)
13:40:12 <Carlos_Pereira> i'm new into the language
13:40:31 <bd_> Carlos_Pereira: Note: The answers you are getting are to what you asked, but possibly not what you meant :)
13:40:53 <bd_> any programming language can replace any other, by the turing equivalency
13:40:53 <sclv_> if he was writing in a strongly typed language, this wouldn't be an issue :-)
13:40:57 <bd_> and he's gone :)
13:41:11 <quicksilver> sclv_: I'm not sure you even need the evil unsafePerformIO
13:41:24 <quicksilver> sclv_: I think a carefully placed 'seq' can force the exception out ?
13:41:26 <ddarius> quicksilver: Writing a Lisp interpreter is easy thus the translation is easy as well. QED.
13:41:57 <sclv_> quicksilver: hmm... good point, but don't I need to be in IO to catch it?
13:42:08 <quicksilver> :t Control.Exception.catchDyn
13:42:24 <lambdabot> thread killed
13:42:33 <quicksilver> :t Control.Exception.catchDyn
13:42:34 <lambdabot> forall a exception. (Typeable exception) => IO a -> (exception -> IO a) -> IO a
13:43:03 <chrisdone> is it possible to derive an instance for a type after it's been declared? by derive, I mean not specifying the implementation, but letting ghc derive it
13:43:16 <sclv_> chrisdone -- lookup standalone deriving in the manual.
13:43:23 <quicksilver> sclv_: yes, of course you're right.
13:43:26 <dons> chrisdone: yes.
13:43:26 <chrisdone> sclv_: oki
13:43:34 <quicksilver> that's the 'excuse' for being able to distinguish _|_
13:43:43 <quicksilver> "IO is nondeterministic, who cares what happens there?"
13:43:44 <quicksilver> ;)
13:43:47 <sclv_> enable StandaloneDeriving and the syntax is currently something like "deriving instance Show for MyData" though I forget exactly.
13:44:23 <xerox> what classes does StandaloneDeriving cover?
13:44:35 <quicksilver> the ones that deriving covers
13:44:36 <sclv_> anything ghc can normally autoderive.
13:44:37 <quicksilver> AFAIK
13:45:37 <sclv_> I think standalone deriving gets a bit silly in some rare corner cases, at the moment though...
13:45:38 <quicksilver> sclv_: if you do any more thinking about the simultaneously pickle/unpickle I'll be interested.
13:45:51 <sebaseba> Newbie needs help yet again from the Masters of #haskell. I'm building a translator using Parsec, and I need to perform IO in one of my parser functions. What are my options?
13:46:06 <quicksilver> sclv_: there is one canonical case which exemplifies what you want to be able to do.
13:46:11 <quicksilver> sclv_: which is length + string
13:46:19 <ddarius> Use parsec3 or structure your code not to use IO in the middle.
13:46:33 <quicksilver> sebaseba: it is very likely that it's a terrible idea to do IO mid-parse
13:46:37 <sclv_> quicksilver: as in for binary data packing?
13:46:43 <quicksilver> sclv_: yeah.
13:46:59 <quicksilver> sclv_: but I want to use neutral combinators, not separate read/write halves
13:47:07 <sebaseba> quicksilver: part of my environment during parsing is contained in separate files
13:47:07 <sclv_> I'm working on some stuff with XML at the moment, just starting out... when I get somewhere with it I'll announce.
13:47:18 <quicksilver> sclv_: cool.
13:47:43 <quicksilver> sebaseba: load the files before the parse and then have them ready for the parser?
13:47:56 <sclv_> sebaseba: what sort of IO exactly?
13:48:20 <sebaseba> slcv_: read some parameters from files given in the main file
13:48:38 <quicksilver> sounds like you're trying to do "too much" in your first parse.
13:48:49 <quicksilver> in the first parse I would just parse the file, including the references to other files
13:48:57 <quicksilver> giving an abstract representation of the file.
13:49:02 <quicksilver> then I'd load the other files
13:49:05 <quicksilver> and then combine the whole
13:49:32 <chrisdone> hi orbitz
13:49:56 <sebaseba> quicksilver: so the IO would be around my 1st parsing and the combining part?
13:50:01 <quicksilver> yes.
13:50:12 <quicksilver> parsing isn't supposed to actually 'execute' the file
13:50:21 <quicksilver> it's just supposed to convert it into an internal data structure
13:50:24 <quicksilver> which you then process later
13:50:58 * gwern watches one of the SICP lectures. wow, everyone looks so totally '80s
13:51:06 <sebaseba> quicksilver: yet again I become I little wiser thanks to the Masters.
13:51:16 <ddarius> gwern: Yeah. It's -really- 80's.
13:51:30 <ddarius> s/80's/'80s/
13:51:33 <quicksilver> sebaseba: ;)
13:52:05 <gwern> and the video itself has the whole '80s coloring vibe
13:52:42 <ddarius> "pitiful" is an ugly word
13:53:19 <chrisdone> I recite my SICP every night before I go to bed
13:53:21 <gwern> I always wonder what the technical term is for that
13:53:31 <chrisdone> religion
13:53:38 <gwern> how videos from different eras just look different, even accounting for subject matter
13:54:31 <quicksilver> I wonder how you calculate the curvate of an implicit surface
13:55:02 <mauke> haddock: Prelude.Enum.Bool.toEnum: bad argument
13:55:07 <ddarius> The same way you do for an explicit surface.
13:55:26 <quicksilver> ddarius: I mean, if you have the implicit surface defined as the zero of a scalar field
13:55:33 <chrisdone> gwern: have you seen this? :P http://www.youtube.com/watch?v=7LqYBncyKpM
13:55:34 <lambdabot> Title: YouTube - Look Around You - 2 - Water
13:55:43 <quicksilver> ddarius: then obviously the normal field is given by Nabla
13:55:49 <gwern> chrisdone: doubt it
13:55:55 <quicksilver> ddarius: but it's not obvious to me how to get the curvature
13:56:14 <gwern> chrisdone: er, what is it?
13:56:25 <gwern> the description and comments are notably lacking
13:56:38 <chrisdone> gwern: it's a modern satire of those old science videos we had to watch in high school
13:58:05 <gwern> ok...
13:58:33 <chrisdone> gwern: well, maybe it's only a british thing
14:01:47 <dons> dcoutts: going over the email text now. the markdown page looks lovely.
14:03:09 <dcoutts_> @yarr!
14:03:09 <lambdabot> Aye
14:03:14 <dcoutts_> hia dons, great
14:03:55 <dons> dcoutts: i'll send you a diff perhaps?
14:04:02 <dcoutts_> dons: or a darcs patch
14:04:04 <dons> or darcs patch.
14:04:04 <dons> ok.
14:04:08 * dcoutts_ and Lemmih just got back from dinner
14:04:15 <dons> url handy?
14:04:25 <dcoutts_> dons: url of the repo?
14:04:28 <dons> yup
14:07:00 <dcoutts_> everyone can tell there's some secret brewing when our conversation cuts off like that ;-)
14:07:14 <dcoutts_> but they'll just have to stew until we announce it :-)
14:29:50 <marcot> I'm trying to generalise Jules Bean's InterleaveIO, but I'm having some type problems:
14:29:57 <marcot> http://hpaste.org/8997
14:39:29 <Toxaris> marcot: you call embed to implement embed in the StateT instance
14:40:10 <Toxaris> marcot: maybe you want (lift embed) instead, to call the embed of the inner monad?
14:41:05 <marcot> Toxaris: maybe lift embed... but the problem is more in callback.
14:41:33 <marcot> Toxaris: cause callback is an IO monad, so I can't get rid of the IO of m.
14:41:50 <marcot> at least, with runStateT used like this.
14:42:55 <marcot> But it's unlift the problem..
14:43:18 <dancor> @type length . fst . break (== x)
14:43:21 <lambdabot> [Expr] -> Int
14:43:30 <dancor> @type length . fst . break (== 4)
14:43:31 <lambdabot> forall a. (Num a) => [a] -> Int
14:43:41 <dancor> @type \ x -> length . fst . break (== x)
14:43:43 <lambdabot> forall a. (Eq a) => a -> [a] -> Int
14:43:55 <mauke> @type length . fst . break (== ?x)
14:43:56 <lambdabot> forall a. (Eq a, ?x::a) => [a] -> Int
14:45:07 <RayNbow> http://www.reddit.com/info/6rkvh/comments/ <-- dons, nice find :)
14:45:08 <lambdabot> Title: reddit.com: Implementing the State monad in JavaScript
14:45:44 <Toxaris> marcot: maybe you need class MonadIO m => InterleavableIO m a where ...
14:46:22 <marcot> Toxaris: I've tried something like that, but it's not being easy...
14:46:44 <marcot> @hoogle MonadIO m => IO a -> m a
14:46:45 <lambdabot> Foreign.unsafePerformIO :: IO a -> a
14:46:45 <lambdabot> System.IO.Unsafe.unsafePerformIO :: IO a -> a
14:46:45 <lambdabot> Data.ByteString.Internal.inlinePerformIO :: IO a -> a
14:49:12 <Baughn> @hoogle inlinePerformIO
14:49:12 <lambdabot> Data.ByteString.Internal.inlinePerformIO :: IO a -> a
14:52:33 <Toxaris> marcot: I do not understand the intended use of embed.
14:53:06 <marcot> Toxaris: take a look at the paste again, I've annotated it.
14:53:36 <marcot> Toxaris: it's used to call functions that asks for a IO Monad with a MonadIO m.
14:54:02 <Peaker> @type embed
14:54:04 <lambdabot> Not in scope: `embed'
14:54:07 <Toxaris> marcot: by "a IO Monad", you mean "something of type IO a for some a"?
14:54:29 <mdmkolbe|work> Is there an implementation of Dijkstra's algorithm for Haskell that implements the "choose lowest weight first" varient?  (I'm not sure but Data.Inductive/Query.BFS appears to be "choose lowest number of links first")
14:54:49 <marcot> Toxaris: http://www.haskell.org/pipermail/haskell-cafe/2007-July/028501.html
14:54:51 <lambdabot> Title: [Haskell-cafe] Monadic tunnelling: the art of threading one monad through anothe ..., http://tinyurl.com/3xmhco
14:54:58 <marcot> Toxaris: I'm trying to generalize this a little bit more.
14:55:40 <nominolo> @losers
14:55:40 <lambdabot> Maximum users seen in #haskell: 473, currently: 450 (95.1%), active: 16 (3.6%)
14:56:06 <Toxaris> marcot: let's say we have StateT s (ReaderT r IO a). both StateT and ReaderT need a different IORef to thread their state through, but the user of this monad transformer stuff is supposed to call only one embed method? how is that possible?
14:56:52 <marcot> Toxaris: the current version only supports on IORef.  I'm trying to make it call embed again, and create another IORef to these cases.
14:57:09 <Toxaris> and I don't see how that could work :)
14:57:10 * brad_larsen is away: Gone away for now.
14:58:00 <marcot> Toxaris: http://hpaste.org/8997#a2
14:58:26 <marcot> Toxaris: the user calls embed once, and it calls embed again.
14:58:35 <marcot> Till it get to instance InterleaveIO IO
14:58:43 <marcot> And stops calling itself.
14:58:58 <Toxaris> marcot: but how does embed now how to produce an a?
14:59:17 <Toxaris> marcot: currently, it always produce IORefs, but some inner monads may need other buffer types
14:59:26 <Toxaris> e.g. IO as an inner monad need ()
14:59:55 <marcot> Toxaris: embed doens't always produce IORefs..  It produces IORefs when it's called with StateT
15:00:53 <marcot> Toxaris: it should know the type of a because of Functional Deps.
15:00:56 <Toxaris> marcot: if the buffers are produced automatically anyway, why not   embed :: IO b -> (a, m b)
15:01:45 <mdmkolbe|work> Is there a good implementation of weighted dijkstra or bidirectional dijkstra for Haskell?
15:02:16 <nominolo> isn't "Monadic Tunneling" == Filinski's Monadic Reflection?
15:02:30 <Toxaris> hmm no that's the wrong way around, you want to call callback first, then embed
15:02:48 <Toxaris> since you want to construct the IO action given to embed using the already created callback
15:02:53 <marcot> Toxaris: I'm calling callback inside embed.
15:03:05 <Toxaris> yeah and I have no clue why :)
15:03:18 <Toxaris> maybe I should the original posting again :)
15:03:36 <marcot> Toxaris: have you seen the last error message?
15:03:41 <Cale> mdmkolbe: hmm... I did a quick translation of A* the other day.
15:03:56 <marcot> Toxaris: it seems that the Functional Deps are not being considered.
15:04:35 <Cale> mdmkolbe: It should be pretty easy to translate from the pseudocode on wikipedia...
15:05:39 <nominolo> Cale: did A* really make sense for the icfp problem?
15:05:44 <mdmkolbe> Cale: yeah, it should be too hard to write my own, I was just wondering if a per-cooked version existed (performance matters (sort of) for my application)
15:05:57 <nominolo> how do you consider turning speed and angles
15:06:00 <Cale> nominolo: Combined with a quadtree, it made some sense :)
15:06:17 <nominolo> i thought about it, but then figured, nah
15:06:17 <Cale> nominolo: That had to be considered separately
15:06:32 <nominolo> but i didn't finish anyway
15:06:49 <nominolo> i just fiddled around a few hours
15:06:53 <Cale> nominolo: There was a part which handled driving between waypoints and avoiding obstacles while turning and such, and a part which decided on waypoints to move between.
15:07:44 <nominolo> Cale: my idea was to just drive towards the target and do some calculations with circles to avoid the obstacles
15:08:01 <Cale> nominolo: Yeah, that was basically what the steering part did.
15:08:22 <nominolo> ie, with the turning ratio and current speed you can guess your future path which is a circle with some radius
15:08:55 <nominolo> i accidentally re-invented A* in school
15:08:56 <Cale> In the end, I think there were still some problems integrating the two components...
15:09:26 <Cale> mdmkolbe: I can write a Dijkstra for you if you like. What's your graph type?
15:09:55 <nominolo> i'm looking forward to the result presentations
15:10:08 <nominolo> i wonder if there were some very clever methods
15:10:27 <nominolo> (ignoring crazy things, like writing it in tex or that ilk)
15:10:27 <Cale> I think there were some problems for us submitting on time.
15:11:48 <nominolo> you didn't submit on time?
15:12:02 <nominolo> did you submit some earlier version?
15:12:09 <Cale> I think it turned out to be something like 9 seconds late.
15:12:19 <Cale> Someone was going to talk to them about it, I'm not sure.
15:12:38 <Cale> It doesn't really matter, since I'm sure that someone else's will have ended up working better.
15:13:25 <nominolo> still, it's nice to have some chance
15:13:39 <Cale> I'm not really in it for competition :)
15:14:55 <Baughn> I was considering writing one that would always make for the nearest crater. With the scoring, that might actually beat someone. :P
15:15:00 <mdmkolbe> Cale: Well my graph type is in flux.  But this is what I can tell you, the problem is to find the shortest path from cord (x_1...x_n)=(0,0,...,0) to (l_1,...l_n) where the distance between two points in an expensive computation (i.e. graph edges should be implicit and the algorithm should travsere as little of the graph as possible).  All costs are positive and it is likely (though not settled) that for any start point it will be possible to com
15:16:09 <Toxaris> marcot: I think you want something like: instance InterleavableIO m a -> InterleavableIO (StateT s m) (IORef s, a)
15:16:22 <Cale> mdmkolbe: Your message was cut off as "it will be possible to co"
15:16:37 <mdmkolbe> Cale: be possible to compute a set of feasible (i.e. non-infinite cost) end points (and vice versa if you want a bidirectional dijkstra)
15:16:37 <Toxaris> marcot: so that the "internals" of the various monad transformers in a monad transformer stack get combined into a nested tuple structure
15:17:18 <Toxaris> marcot: but I'm totally not sure :)
15:17:36 <marcot> Toxaris: hum, I'll try this.
15:17:51 <marcot> Toxaris: I just want to understand this error message...
15:18:33 <Toxaris> fundeps are tricky to understand. imho you need some understanding of the *operational* behaviour of type inference
15:18:47 <hydo> I'll be glad when I learn enough of the language that the majority of the chat in here doesn't sound like witchcraft anymore.
15:19:02 <mdmkolbe> Cale: current thinking is that paths far from the optimal path have a sufficiently high cost that a well written dijkstra will only explore a small fraction of the graph (the graph is a high degree grid so a full exploration would be too costly think n^k where k > 4 and n > 5000)
15:19:12 <nominolo> Baughn: mine always went full-throttle towards the origin
15:19:15 <sm> heh.. a year or two in, still waiting for that
15:19:16 <Toxaris> hydo: at this point, you will realize that it's all co-witchcraft and start learning math
15:19:25 <mdmkolbe> (...and the program must run in less than a second)
15:19:37 <nominolo> actually worked 40% of the time on the test maps
15:19:37 <Baughn> hydo: Ironically, the type inference engine actually /does/ use a third-order summoning circle to find the right types
15:19:47 <hydo> haha
15:20:23 <marcot> Toxaris: what do you mean by operational?
15:20:26 <nominolo> not a co-circle?
15:20:35 <Toxaris> marcot: not what it means, but how it works
15:20:42 <Baughn> nominolo: I figured there would be a lot of martians on later levels, which makes avoiding them more important than just winning, and you get a 250% higher score by being eaten thane exploding
15:21:35 <Toxaris> marcot: it is no longer enough to understand the type system (e.g. type checking rules) and believe that type inference works, now you have to understand type inference to understand how fundeps fit in, and how not
15:21:49 <nominolo> Baughn: i had some clever tricks how to avoid them
15:22:12 <nominolo> Baughn: but i was first trying to avoid all the other crap on that map
15:24:10 <mdmkolbe> Cale: so anyway, it's probably complicated enough that I should just write my own.  (I'm not even sure it will work, I have conjectures about the behaviour of the problem domain (e.g. the domain is to large for a full exploration, but has steap enough sides that a probably optimal partial exploration might be effective), but those conjectures will have to be proven by experiment)
15:25:09 <Toxaris> marcot: regarding your error: try to infer the type of the callback you call in embed's definition by hand
15:25:14 <Peaker> BeelsebobWork_: did that dude make any progress with the FRP tutorial?
15:25:26 <Toxaris> marcot: e.g., what type has a x, what type has buffer?
15:26:12 <marcot> Toxaris: I'm doing this now..
15:26:12 <Cale> mdmkolbe: Would representing the graph by a function  Vertex -> [Vertex], and Vertex -> Vertex -> Cost be reasonable?
15:26:16 <marcot> The inference by hand.
15:26:23 <marcot> I've just found a problem...
15:26:40 <marcot> the embed in r <- embed... is StateT ...
15:27:03 <marcot> It should be the inner monad.
15:27:41 <mdmkolbe> Cale: probably
15:27:44 <Cale> oh, right, Dijkstra also needs to know the full set of nodes you're looking through...
15:27:57 <mdmkolbe> Cale: ???
15:28:19 <Toxaris> marcot: sure, as I said, you want some lift there
15:28:36 <Toxaris> marcot: or mapStateT or whatever
15:28:50 <Cale> mdmkolbe: mm... possibly not.
15:29:41 <Cale> mdmkolbe: The pseudocode on wikipedia seems to imply that though
15:30:29 <marcot> lift!
15:30:29 <marcot> =)
15:30:41 <marcot> Toxaris: first time I can compile it.
15:30:46 <marcot> Now let's see if it works.
15:31:19 <Bourbaki> moin
15:32:20 <Cale> mdmkolbe: otoh, A* avoids that by adding to a set of explored nodes as it goes.
15:32:42 <Cale> (at least, in the descriptions on wikipedia... it seems you could probably do something similar for Dijkstra)
15:33:38 <mdmkolbe> Cale: yeah that sounds right.  A* and Dijkstra are the same when the huristic function always returns "0"
15:34:50 <mdmkolbe> (modulo the fact that there are many different algorithms that get called "Dijkstra")
15:35:50 <pastorn> anyone here a vim-h4xx0r? how do i search+replace one string with another?
15:36:03 <mauke> :h :s
15:36:39 <pastorn> :s "oldstring" "newstring"
15:36:42 <pastorn> or?
15:37:19 <Nafai> :%s/oldstring/newstring/g will replace oldstring with newstring in the entire file
15:37:32 <mauke> you have failed to read :h :s
15:37:57 <pastorn> mauke: it's only annoying, i'm using dvorak
15:38:10 <mauke> ?
15:38:11 <pastorn> Nafai: thanks :D
15:38:41 <pastorn> hjkl aren't where they're supposed to, making most of the stuff seem very un-intuitive
15:39:56 <mauke> what does that have to do with reading the manual?
15:40:50 <pastorn> all i'm saying is that i would have done that a long time ago if there was some cool dvorak mode for vim
15:47:40 <paczesiowa> does anybody know a hack to write a \+ (not) on typeclass-level?
15:50:13 <mdmkolbe> paczesiowa: e.g. for "foo :: (Not Integer a) => a -> a"?
15:51:59 <paczesiowa> mdmkolbe: more like Not Num a
15:52:27 <Toxaris> paczesiowa: instance Num a => IsNum a HTrue
15:52:34 <Toxaris> paczesiowa: instance IsNum a HFalse
15:53:08 <Toxaris> paczesiowa: with data HTrue; data HFalse
15:53:21 <Toxaris> paczesiowa: and then you can use IsNum a HFalse   for   IsNotNum
15:54:00 <Toxaris> paczesiowa: but you need to enable some extensions to make that work
15:54:07 <paczesiowa> Toxaris: I have to do some thinking if I didn't simplify too much that Num example
15:54:22 <paczesiowa> Toxaris: I already use plenty of HList so that's no problem
15:54:40 <tusho> @src flipM
15:54:40 <lambdabot> Source not found. Where did you learn to type?
15:54:45 <tusho> :(
15:54:46 <Toxaris> If I remember correctly, HList contains some type-level equality predicate
15:54:49 <tusho> @src mapM
15:54:50 <lambdabot> mapM f as = sequence (map f as)
15:54:59 <Toxaris> paczesiowa: which is implemented like this
15:55:46 <mdmkolbe> Toxaris: I tried that and it doesn't work
15:55:51 * mdmkolbe prepares an hpaste
15:55:56 <paczesiowa> Toxaris: I know, but TypeEq works only for ground types, I want TypeEq HFalse for unground (?)
15:56:13 <paczesiowa> Toxaris: are you familiar with IsFunction ?
15:56:41 <Toxaris> read about it once
15:57:11 <paczesiowa> Toxaris: I'd like to have instance IsFunction a HFalse
15:57:50 <mdmkolbe> Toxaris, paczesiowa: it doesn't seem that that trick actually works. Running http://hpaste.org/8998 produces "1" (IIUC, it should have given a type error)
15:58:46 <Toxaris> mdmkolbe: you need some fundeps
15:58:58 <Toxaris> mdmkolbe: to make the second instance unavailable if the first instance matches
15:59:32 <Toxaris> mdmkolbe: this way, you just have both for Num types
15:59:47 <Toxaris> mdmkolbe: try class IsNum a b | a -> b where
16:00:36 <dcoutts> dons: did you darcs send something? if so I didn't get it
16:00:36 <mdmkolbe> Toxaris: that gives me a "dependancies conflict" error.  I suppose I need -fallow-overlapping-instances or something
16:00:48 <dons> dcoutts: on its way.
16:00:57 <Toxaris> mdmkolbe: yeah something :) I'm not a really expert :)
16:01:06 <dcoutts> dons: ok, no rush, was just checking
16:01:57 <Toxaris> paczesiowa: I read something about forcing instance selection to be before chosing types (e.g., with unground types) recently, surely in the context of HList
16:02:38 <kpreid> does there exist a non-implementation-specific test suite for Haskell implementations?
16:02:41 <Toxaris> paczesiowa: IIRC you can do some magic tricks to make it work, basically :)
16:02:51 <dons> kpreid: yes. it is called 'nofib' and 'nobench'
16:02:55 <paczesiowa> Toxaris: that sounds just crazy and complicated enough that it might work, thanks for google keywords
16:03:01 <Toxaris> paczesiowa: but I don't know the reference now, sorry
16:03:15 <dons> kpreid: http://www.cse.unsw.edu.au/~dons/nobench/x86_64/results.html
16:03:17 <lambdabot> Title: nobench: Haskell implementation shootout
16:03:26 <mdmkolbe> Toxaris: hmm, still can't make it work, oh well
16:03:34 <kpreid> dons: I mean conformance tests, not timing
16:03:47 <Toxaris> mdmkolbe: you can look up IsFunction on olegs site, that is similiar
16:03:53 <dons> ah, there are h98 conformance tests in ghc's suite, that are also usable from nhc and hugs.
16:12:38 <Maro> hello
16:12:47 <Maro> i need to ask about simple something here
16:13:04 <Zao> Then ask_
16:13:20 <mdmkolbe> Maro: ask away. we are friendly here.  "Don't ask to ask, just ask."
16:13:54 <Maro> ok now i was looking for a java complier so that i could simply complie socket java simple chat program
16:13:56 <Maro> i have installed
16:14:24 <Zao> I can't quite see the relevance to Haskell though, yet.
16:14:25 <Maro> java se development kit 6
16:14:36 <mauke> how is that a haskell question?
16:14:38 <paczesiowa> this is going to be  good:P
16:14:57 * Zao hands mauke some mid-side encoded stereo.
16:15:12 <mar77a> math time again
16:15:15 <dobblego> Maro, we don't use Java around here
16:15:23 <mauke> sadly, this kind of situation occurs often enough that I have a macro for it
16:15:33 <mar77a> hihih, how do i solve x*ln(x^2+1)=2/x?
16:15:36 <dcoutts> @seen pgavin
16:15:37 <lambdabot> pgavin has changed nick to pgavin-away.
16:15:37 <lambdabot> I saw pgavin-away leaving #haskell 1h 40m 13s ago, and .
16:15:41 <Maro> mmm okkkkieee  i know that why i asked first
16:15:43 <Maro> anyways sorrry
16:16:19 <kpreid> mar77a: a*ln(b) = ln(b^a) perhaps?
16:16:30 <Zao> Maro: Out of curiousity? Why did you ask here?
16:16:35 <mdmkolbe> Maro: if there is a connection to Haskell we could help, but this sounds like a question for #java
16:16:50 <Zao> err, s/? W/, w/
16:17:09 <mar77a> yes that'll do
16:17:10 <mar77a> thanks
16:19:03 <mar77a> i end up with (x^2+1)^2x = e^2
16:20:58 <mar77a> which isn't handy kpreid
16:21:23 <kpreid> oh, yeah..
16:21:27 <Baughn> Cale: http://brage.info/~svein/cale <-- Here's a patch to fix the leak in Log
16:21:56 <Cale> Baughn: cool!
16:22:25 <Baughn> Cale: Sadly, two third of it is in Seen. But I'll be going at it with superior 6.8.3 profiling tools now.
16:22:42 <kpreid> mar77a: actually, shouldn't it be (x^2+1)^(x^2) = e^2 (which isn't any more handy, though)?
16:23:00 <mar77a> yeah
16:23:07 <mar77a> but it's not any cool
16:24:00 <Cale> Baughn: cool, I'm applying that one right now anyway :)
16:25:06 <Cale> mar77a: The answer is "numerically"
16:25:18 <mar77a> i don't think it is
16:25:19 <mar77a> well
16:25:21 <mar77a> the question is
16:25:30 <mar77a> "how many solutions (positive) does it have"
16:25:43 <Cale> one positive solution
16:25:44 <mar77a> and the options are "3, 1, 0, 4"
16:25:50 <mar77a> how can you tell?
16:26:38 <Cale> well, I'm just using mathematica to plot it :) However, to actually prove it, you'd use the intermediate value theorem and inequalities.
16:27:06 <mar77a> mmm
16:27:41 <Cale> Someone reduced it to (x^2+1)^(x^2) = e^2 ?
16:28:55 <Cale> yeah...
16:29:34 <Cale> So show that (x^2+1)^(x^2) is monotonic and continuous on [0,inf).
16:29:57 <mar77a> derivatives
16:30:02 <Cale> and that implies that there's only one solution
16:30:05 <mar77a> langrange theorem?
16:30:14 <mar77a> or rolle
16:30:18 <mar77a> bolzano
16:30:19 <mar77a> argh
16:30:21 <mar77a> so many things
16:30:31 <mar77a> calc final tomorrow
16:30:32 <mar77a> ;(
16:30:33 <Cale> hmm...
16:30:48 <Cale> I would say it's an application of the intermediate value theorem.
16:31:11 <mar77a> TVM
16:31:12 <mar77a> ok thanks
16:35:53 <kpreid> Cale: Isn't the intermediate value theorem only capable of showing that there is zero or at least one solution, and not that there is no more than one solution?
16:36:13 <Cale> kpreid: Well, yes.
16:36:14 <Baughn> How should I have cabal pass -auto-all as well as -prof when building?
16:36:22 <Cale> kpreid: But the monotonicity gets you the rest.
16:36:38 <dcoutts> Baughn: cabal build --ghc-options=-auto-all
16:36:39 <kpreid> Oh. Duh.
16:37:45 <Baughn> Righto. Hope telling ghc to profile itself works, now..
16:41:11 <BMeph> Haskell: Where even the newest newcomer acts monadically:
16:41:35 <BMeph> Note - join:: ask (ask something) -> ask something
16:42:50 <mauke> groan
16:43:51 * mdmkolbe finishes 3 minutes of laughing
16:43:53 <tusho> hah
16:44:28 <kpreid> @remember BMeph Haskell: Where even the newest newcomer acts monadically: join :: ask (ask something) -> ask something
16:44:28 <lambdabot> It is stored.
16:46:34 <Baughn> BMeph: Oh, that one needs to go in the topic
16:46:38 <Baughn> Horrendous on so many levels
16:47:03 <BMeph> Thank you, I'll be here all week! Try the veal! ;)
16:53:55 <dobblego> what is the name of the emerging Haskell IDE?
16:54:44 <Baughn> dobblego: leksah?
16:54:49 <dobblego> that's it ta
17:10:56 <chrisdone> baughn: are you working on anything at the moment?
17:11:18 <chrisdone> baughn: anything haskelly?
17:12:57 <Baughn> chrisdone: At the moment I'm going to sleep. More long-term, trying to un-leak lambdabot and adding mirror/security support to cabal/hackage
17:13:32 <dcoutts> Baughn: oh, we should talk about that latter project some time
17:13:56 <Baughn> Sure. I've yet to write any code, but I'll give you a ping once I do.
17:14:11 <dcoutts> Baughn: you should be aware that we're writing a new hackage-server
17:14:44 <chrisdone> baughn: very nice! I shall have to ask you about that when you are fully compus mentus
17:15:13 <chrisdone> dcoutts: really? what will be different?
17:15:37 <dcoutts> chrisdone: based on happs
17:16:12 <dcoutts> chrisdone: we hope it'll be much easier to deploy and extend with more features
17:16:13 <chrisdone> baughn: that should have been “compos mentis”, jove
17:16:20 <chrisdone> dcoutts: ahh, I see, I see
17:16:44 <dcoutts> it's already trivial to deploy, unlike the current hackage scripts which need apache etc
17:17:14 <chrisdone> dcoutts: will you be making the source public? it's always lovely to see haskell code written by the “gurus”
17:17:21 <dcoutts> deployment will be: cabal install hackage-server && hackage-server
17:17:23 <r3m0t> any nice Haskell solutions to Google Code Jam in here?
17:17:31 <chrisdone> dcoutts: wow, that's great!
17:17:45 <Taejo> r3m0t: I'm afraid I infidelled it in Python
17:17:59 <r3m0t> Taejo: what, you again? get out.
17:18:04 <r3m0t> heh heh
17:18:08 <Taejo> r3m0t: I hang out here
17:18:19 <dcoutts> chrisdone: of course. The source for both the existing scripts and the new prototype are already publicly available.
17:18:41 <chrisdone> dcoutts: are they in obvious places, or should I inconvience you in asking for a link?
17:19:41 <dcoutts> chrisdone: the existing code is at http://darcs.haskell.org/hackage-scripts/
17:19:43 <lambdabot> Title: Index of /hackage-scripts
17:19:50 <chrisdone> dcoutts: thank you
17:19:59 <dcoutts> chrisdone: there's no point looking at the new prototype yet though
17:19:59 <dcoutts> give it a couple weeks
17:20:14 <dcoutts> chrisdone: unless of course you're a happs hacker and want to help out
17:20:28 <r3m0t> oh well, I'm out
17:20:42 <chrisdone> dcoutts: I am by no means a happs hacker, but I will watch
17:21:24 <dcoutts> chrisdone: I'm not either really. Lemmih has been teaching me about happs, he's in town for a few weeks and we've been meeting up for hackage hacking
17:21:53 <chrisdone> dcoutts: that sounds very productive, and fun
17:23:33 <chrisdone> dcoutts: what town and country is this?
17:24:27 <dcoutts> chrisdone: Oxford, England
17:25:09 <chrisdone> dcoutts: oh, wow! I'm up t'north, Wigan :)
17:26:52 <dcoutts> chrisdone: will you be going to AngloHaskell next month then?
17:27:33 <chrisdone> dcoutts: hmm. I may take this time I have to learn some happs. I had avoided it for fear of the template haskell, but it is something I have intended on learning for to not be prejudice
17:27:46 <chrisdone> dcoutts: I had not heard of it until now, let me research it
17:28:39 <dcoutts> @where anglohaskell
17:28:40 <lambdabot> http://haskell.org/haskellwiki/AngloHaskell
17:31:37 <chrisdone> dcoutts: how funny, it starts on my birthday :)
17:31:56 <chrisdone> dcoutts: (the 8th, that is)
17:33:10 <dcoutts> chrisdone: I expect you'll be wanting to do something more interesting that day then :-)
17:33:43 <mauke> hmm, regexes get even more cryptic after z-encoding
17:33:50 <mauke> ZLz3fUZCZLz3fUzlznzrwZRZLz3fUzezrwZRzbZLz3fUzlzezrwZRZLz3fUznzrwZRZR
17:36:30 <chrisdone> dcoutts: hanging out with a bunch of haskellers in person would be an excellent birthday. depending on arrangments nearer the time, I think I will come! I'll stick my name down under possible. this is very exciting :)
17:37:37 <int-e> @remember mauke hmm, regexes get even more cryptic after z-encoding: ZLz3fUZCZLz3fUzlznzrwZRZLz3fUzezrwZRzbZLz3fUzlzezrwZRZLz3fUznzrwZRZR
17:37:37 <lambdabot> Okay.
17:37:49 <dcoutts> great
17:47:34 <Baughn> Cale: Nope. There's still something about lambdabot that makes the profiler stop working.
17:48:13 <gwern> profiling lambdabot? lolwut
17:50:34 <chrisdone> dcoutts: do you recommend this tutorial? http://www.haskell.org/haskellwiki/HAppS_tutorial2
17:50:39 <lambdabot> Title: HAppS tutorial2 - HaskellWiki
17:53:27 <chrisdone> dcoutts: disregard that, this is fine
17:55:42 <dcoutts> chrisdone: actually a better tutorial I think is this blog someone did where it develops the ideas over a series of posts. I'm just looking for it...
17:56:32 <chrisdone> dcoutts: is it this one? http://dbpatterson.com/articles/5
17:56:32 <lambdabot> Title: dbpatterson.com - Building on HAppS - Part 1 - More User Functionality
17:57:36 <chrisdone> dcoutts: and/or Software Simply? http://softwaresimply.blogspot.com/2008/02/intro-to-happs-part-1.html
17:57:37 <lambdabot> Title: Software Simply: Intro to HAppS Part 1, http://tinyurl.com/2uz3rn
17:58:12 <dcoutts> chrisdone: yes
17:58:22 <chrisdone> dcoutts: roger!
18:01:48 <dcoutts> chrisdone: the first has more details (over several posts) but that second is good too.
18:51:32 * dcoutts bangs his head against css positioning
18:52:07 <dcoutts> I've got two spans within a div, I want one left aligned and one right aligned. How hard can it be?
18:54:58 <chrisdone> float:left; and float:right;?
18:59:37 <chrisdone> dcoutts: http://chrisdone.com/foo.html
18:59:47 <thetallguy> dcoutts: almost anything specific in CSS is nearly impossible
19:00:06 <thetallguy> dcoutts: I've been fighting with it myself, and I just keep wanting to replace it
19:00:18 <dublpaws> and then to test in IE5
19:00:49 <dcoutts> chrisdone: ah, floating. Unfortunately that doesn't quite do what I want because subsequent paragraphs end up inbetween the two floated spans.
19:01:20 <thetallguy> dcoutts: a table won't do?
19:01:31 <kpreid> dcoutts: two ideas;
19:01:35 <chrisdone> dcoutts: perhaps the subsequent paragraph needs `clear:both;'
19:01:37 <dcoutts> thetallguy: oh, maybe it would
19:01:42 <kpreid> 1. use table formatting on the spans
19:01:45 <dcoutts> chrisdone: oh, will try
19:01:55 <kpreid> set the div to display; table and the spans to display: table-cell
19:02:19 <kpreid> 2. what chrisdone said. or, put a third empty element inside the div with clear set on it
19:02:48 <chrisdone> dublpaws: I find http://browsershots.org/ very handy for working out cross-browser consistency
19:02:51 <lambdabot> Title: Test your web design in different browsers - Browsershots
19:03:07 <chylli`> who can help me to see my irc protocol parser ?
19:03:08 <chrisdone> dublpaws: visual consistency, of course, not other kinds
19:03:09 <chylli`> http://hpaste.org/8999
19:03:15 <dublpaws> yeah that's pretty good, can take awhile for the queue though
19:03:34 <chrisdone> dublpaws: true enough
19:03:54 <chylli`> the 'params' parser is wrong. but I dont know where is the problem
19:03:56 <dcoutts> chrisdone: woo! floating the images to left and right and then clearing the next para works
19:04:19 <chrisdone> dcoutts: wizzard!
19:04:59 <chrisdone> chylli`: hmm
19:05:41 <chrisdone> chylli`: from first impressions, skipMany1 space
19:05:51 <chrisdone> chylli`: that means “at least one space”, you are aware, yes?
19:05:56 <chylli`> yes
19:06:10 <chylli`> chrisdone: it can parse ' hello '
19:06:19 <chylli`> but cant parse ' hello \r\n'
19:06:42 <chrisdone> I see, I see
19:07:47 <chrisdone> chylli`: I'm not sure about this, let me try compiling and running it in ghci
19:07:51 <chylli`> chrisdone: no, it can parse " hello \r\n", but params >> string "\r\n" dont work
19:08:47 <chylli`> chrisdone: thanks. you can run it by : testParse "command param1 \r\n" message
19:08:57 <chrisdone> chylli`: thank you
19:09:37 <chrisdone> IRC.hs:94:36: Not in scope: `user'
19:09:43 <chrisdone> chylli`: was your paste cut off by hpaste?
19:10:01 <chrisdone> chylli`: it seems to have been truncated
19:10:16 <chylli`> oh,yes. let me paste again
19:10:24 <chrisdone> it will truncate again, there is a limit!
19:10:29 <chrisdone> try http://paste.lisp.org/
19:10:32 <chrisdone> I believe the limit there is larger
19:10:48 <chrisdone> if you wouldn't mind
19:11:34 <chylli`> chrisdone: http://hpaste.org/9000
19:11:44 <chylli`> chrisdone: I removed some comment
19:11:45 <chrisdone> chylli`: by the way, I presume this is a parsing exercise? otherwise I would suggest the Network.IRC library: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/irc
19:11:53 <lambdabot> Title: HackageDB: irc-0.4.3
19:12:24 <chrisdone> chylli`: roger
19:12:26 <chylli`> chrisdone: yes, it just a exercise. but thanks for your advice , I never know that package before.
19:12:51 <chylli`> chrisdone: I'm trying to write a toy like bitlbee :p
19:13:00 <chrisdone> chylli`: no problem
19:13:01 <chrisdone> chylli`: ah, very good
19:13:12 <chrisdone> chylli`: hmm, let's see here...
19:13:44 <chylli`> chrisdone: BNF is here: http://www.irchelp.org/irchelp/rfc/chapter2.html#c2_3_1
19:13:45 <lambdabot> Title: RFC 1459
19:18:13 <ddarius> You hardly need parsec to parse IRC
19:18:14 <chrisdone> hm, I am making some progress, bear with me
19:19:10 <chylli`> ddarius: why ? because it very simple ?
19:19:24 <chylli`> chrisdone: thanks, take your time.
19:21:30 <kpreid> chylli: "channel = ... (chan1 <|> chan2)" could be rewritten as "channel = ... (chan '#' Chan1 <|> chan '&' Chan2)"
19:21:39 <kpreid> (with an appripriate definition of chan)
19:21:50 <kpreid> same for 'mask'
19:22:19 <chylli`> kpreid: then chan is a combinator ?
19:22:39 <kpreid> I wouldn't say that.
19:22:46 <chylli`> kpreid: thanks. I know my code ugly very much.
19:23:20 <kpreid> it might be true, I don't really follow; but it's not relevant to knowing that you can eliminate duplication with functions
19:23:47 <kpreid> also params/pTrailing/middleParams can surely be simplified by appropriate use of many/many1
19:24:58 <chrisdone> chylli`: it seems that your params and middleParams is written such that there always has to be another `params' instance; it seems you leave no room for this not being so
19:25:18 <kpreid> also, in 'channel' you have "result <- chstring; return $ Chan2 $ result" -- this can be written as "liftM Chan2 chstring"
19:25:31 <chrisdone> I agree with kpreid, `many param' or something like that might work better and be more concise
19:25:41 <kpreid> this simplification also applies to 'command' and 'servernamePart' and many others
19:26:13 <kpreid> in fact: command = liftM Lcommand (many1 letter) <|> liftM Dcommand (count 3 digit)
19:26:25 <kpreid> it's so short you don't need any local names
19:26:29 <pgavin> anyone here familiar with ghc core?
19:27:27 <chylli`> reading carefully
19:27:42 <pgavin> hmm, irc client was messed up :)
19:28:11 <pgavin> anyhow, what does this mean:    case blah1 of blah2 { __DEFAULT -> ...
19:29:22 <ddarius> kpreid: Or Chan2 <$> chstring
19:29:33 <kpreid> you and your newfangled applicatives
19:30:04 <kpreid> I'm off to sleep, no more advice today
19:30:36 <dobblego> applicative r0x
19:32:10 <chylli`> chrisdone: I'm afraid many param will be different behavior with my version.
19:32:52 <chylli`> it will be like this : <params> ::= {<param>}
19:33:10 <chylli`> <param> ::= SPACE trailing .....
19:33:18 <chylli`> then it will produce many trailing
19:33:18 <chrisdone> the Parsec equivalent to that is params = many param
19:34:48 <chrisdone> oh, I see, you are copying the BNF directly. <params> ::= <SPACE> [ ':' <trailing> | <middle> <params> ]
19:35:39 <chylli`> chrisdone: yes. in fact, I'm study from book <<grammers and parsing>>
19:36:53 <TomMD> Instead of Parsec, what does one use when the input is large and to be parsed in a lazy manner?  Do people typically still parse entry by entry with parsec and have a lazy wrapper ( :: Parsable a => ByteString ->  [a]) or is there some different package I am ignorant of?
19:36:54 <chrisdone> so would this be accurate? params = space >> ( (char ':' >> trailing) <|> middle >> params )
19:37:18 <chrisdone> TomMD: there are peg parsers, too
19:37:27 <ddarius> Tomas: There are a lot of parsing packages.
19:37:29 <ddarius> @hackage polyparse
19:37:30 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/polyparse
19:37:42 <ddarius> @google Utrecht Parsing Combinators
19:37:44 <lambdabot> http://www.cs.uu.nl/wiki/bin/view/HUT/ParserCombinators
19:37:47 <chrisdone> http://repetae.net/computer/frisby/
19:37:48 <lambdabot> Title: Text.Parsers.Frisby
19:38:14 <chylli`> chrisdone: I think that be accurate except that can't return a parse tree.
19:38:24 <chylli`> I mean, a list
19:39:31 <TomMD> ddarius: I guess I could narrow my question as well.  "If one of these parsers were to be part of HLP, perhaps due to its popularity, which is a candidate?"
19:39:49 <ddarius> The two I listed are both candidates.
19:40:13 <ddarius> Also, I don't know what "HLP" means.
19:40:47 <TomMD> ddarius: "Haskell Platform" - see the wiki or wednesdays GHC meeting.
19:41:30 <TomMD> Basically - to aid distributions importing of Haskell packages several people feel it would be good to have a standard "base" that is larger than what we call "base" with ghc and smaller than all of hackage.  Make sense?
19:44:54 <chylli`> chrisdone: ok, let me study irc pacakge if you have no more advice. THANK YOU!!
19:45:12 <chylli`> kpreid: THANK YOU!!
19:46:25 <chrisdone> chylli`: I'm still looking at it, but sure, no problem
19:46:58 <leoncamel> is there any material about algorithm design by Haskell ?
19:47:04 <chylli`> chrisdone: then I wait your advice ? it takes your time too long ...
19:48:28 <chrisdone> chylli`: I'm just experimenting. no worries
19:57:19 <chrisdone> chylli`: ah, figured it out
19:57:30 <chylli`> chrisdone: oh ?
19:57:35 <chylli`> what's the problem ?
19:58:46 <chrisdone> well, I think you needed some kind of `try' construct to allow it to fail and go to the \r\n
19:58:49 <chrisdone> chylli`: http://hpaste.org/9000#a1
19:59:04 <chrisdone> chylli`: this is a working `params' function I came up with
19:59:44 <chylli`> chrisdone: thanks. but I think it not eat any things before meet "\r\n"
20:02:19 <chrisdone> chylli`: I'm not sure what you mean but I'm going to bed now! good luck! :)
20:02:50 <chylli`> chrisdone: thanks very much
20:02:58 <chylli`> chrisdone: good night.
20:03:04 <chylli`> chrisdone: to me is morning now :p
20:06:12 <chrisdone> chylli`: hehe. 4AM here. good night :P
20:07:46 <dobblego> can GHC run on the iphone?
20:08:40 <chessguy> @src span
20:08:41 <lambdabot> Source not found. :(
20:08:50 <chessguy> @type span
20:09:06 <lambdabot> thread killed
20:09:11 <chessguy> eh?
20:09:18 <chessguy> @hoogle [a] -> [[a]]
20:09:21 <lambdabot> Data.List.inits :: [a] -> [[a]]
20:09:21 <lambdabot> Data.List.tails :: [a] -> [[a]]
20:09:21 <lambdabot> Data.List.group :: Eq a => [a] -> [[a]]
20:11:56 <chessguy> @p \b -> a p (m l (g b))
20:11:57 <lambdabot> Maybe you meant: palomer part paste ping pl pl-resume pointful pointless pointy poll-add poll-close poll-list poll-remove poll-result poll-show pretty print-notices protontorpedo purge-notices . ? @
20:11:57 <lambdabot> v
20:12:13 <chessguy> @pl \b -> a p (m l (g b))
20:12:14 <lambdabot> a p . m l . g
20:19:56 <chessguy> hmm, strange.
20:20:47 <newsham> ?pl \b -> n e (a t (o b))
20:20:48 <lambdabot> n e . a t . o
20:21:01 <chessguy> i want to write a function of type a -> [Maybe a] -> [[Maybe a]]
20:21:24 <dobblego> return -- :)
20:21:29 <chessguy> that will generate a new list for each place where there's a Nothing in the original list, putting a Just a there instead
20:21:45 <dobblego> Traversable?
20:22:23 <chessguy> hm, haven't worked with that one much
20:22:32 <dobblego> it's the best!
20:22:38 <newsham> beats the rest
20:22:51 <dobblego> fills you with zest
20:23:01 <newsham> cellular modular interactiveodular
20:23:01 <dobblego> @google The Essence of the Iterator Pattern
20:23:02 <lambdabot> No Result Found.
20:23:07 <dobblego> wtf?
20:23:45 <chessguy> this one? http://lambda-the-ultimate.org/node/1410
20:24:09 <dobblego> yeppers; I am only about 75% confident that will solve your problem
20:24:26 <dobblego> the other 25% is my instinct
20:25:47 <chessguy> yeah.....that looks like great fun
20:27:06 <chessguy> so much fun i think i'll save it for a rainy day
20:29:15 <newsham> > map (Just . fromMaybe 5) [Just 2, Nothing, Just 3, Just 4, Nothing]
20:29:22 <lambdabot>  [Just 2,Just 5,Just 3,Just 4,Just 5]
20:30:38 <chessguy> i'd be looking for [[Just 2,Just 5, Just 3, Just 4, Nothing], Just 2, [Nothing, Just 3, Just 5, Just 5]] there
20:30:52 <chessguy> err, bracket in the wrong place
20:31:09 <chessguy> [[Just 2,Just 5, Just 3, Just 4, Nothing], [Just 2, Nothing, Just 3, Just 5, Just 5]
20:31:23 <chessguy> whatever, you get the idea
20:31:32 * ddarius doesn't get the idea.
20:31:40 <newsham> so once resulting list per each Nothing
20:31:55 <chessguy> right, and the new list replaces that Nothing with Just x
20:32:42 <chessguy> otherwise, it's the same as the original list
20:34:52 <chessguy> so f 'x' [Nothing, Nothing] = [[Just 'x', Nothing], [Nothing, Just 'x']] -- to give another data point
20:35:27 <vixey> > mapMaybe id [Just 2, Nothing, Just 3, Just 4, Nothing]
20:35:43 <lambdabot>  [2,3,4]
20:36:06 <chessguy> @src mapMaybe
20:36:07 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
20:36:47 <chessguy> you could do it via indices, i suppose
20:37:16 <vixey> so...
20:38:45 <jeffwheeler> Sorry if the pastie bot just posted in here; accidentally didn't uncheck announce.
20:40:35 <chessguy> ugh
20:40:40 <chessguy> i don't get why this is so ugly
20:40:49 <chessguy> seems straightforward enough
20:40:59 <vixey> it's because you're using a horrible language like haskell
20:41:09 <chessguy> haha
20:41:59 <vixey> so you have a list of holes (Nothing).. and you want to fill them in one by one ?
20:42:05 <chessguy> more like, because i'm using an O(n) data structure for a O(1) problem :)
20:42:43 <chessguy> yeah, think of it like an empty board, and you want to build a tree of possible ways you could place a piece on the board
20:43:01 <chessguy> empty board = [Nothing..]
20:43:30 <chessguy> > [Nothing..]
20:43:31 <lambdabot>  Parse error at "Nothi..." (column 2)
20:43:39 <newsham> > let l = [Just 2, Nothing, Just 3, Just 4, Nothing]; r n = if isNothing (l !! n) then Just (take n l ++ [Just 100] ++ drop (n+1) l) else Nothing in catMaybes (map r [0..length l - 1])
20:43:41 <lambdabot>  [[Just 2,Just 100,Just 3,Just 4,Nothing],[Just 2,Nothing,Just 3,Just 4,Just ...
20:44:21 <chessguy> > let l = [Just 2, Nothing, Just 3, Just 4, Nothing]; r n = if isNothing (l !! n) then Just (take n l ++ [Just 1] ++ drop (n+1) l) else Nothing in catMaybes (map r [0..length l - 1])
20:44:23 <lambdabot>  [[Just 2,Just 1,Just 3,Just 4,Nothing],[Just 2,Nothing,Just 3,Just 4,Just 1]]
20:44:31 <chylli`> ?liftM
20:44:31 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
20:44:50 <vixey> > mapM (maybe [Nothing,Just 5] (return . Just)) [Just 2, Nothing, Just 3, Just 4, Nothing]
20:44:52 <lambdabot>  [[Just 2,Nothing,Just 3,Just 4,Nothing],[Just 2,Nothing,Just 3,Just 4,Just 5...
20:45:18 <vixey> @let midsection = tail . reverse . tail . reverse
20:45:28 <vixey> > midsection . mapM (maybe [Nothing,Just 5] (return . Just)) [Just 2, Nothing, Just 3, Just 4, Nothing]
20:45:29 <lambdabot>   Not in scope: `midsection'
20:45:31 <lambdabot> Defined.
20:45:36 <chessguy> lol
20:45:40 <vixey> oh well...
20:45:51 <vixey> I guess that didn't really solve the problem anyway
20:46:38 <chessguy> > drop 1 $ mapM (maybe [Nothing,Just 5] (return . Just)) [Just 2, Nothing, Just 3, Just 4, Nothing]
20:46:40 <lambdabot>  [[Just 2,Nothing,Just 3,Just 4,Just 5],[Just 2,Just 5,Just 3,Just 4,Nothing]...
20:47:06 <chessguy> > mapM (maybe [Nothing,Just 5] (return . Just)) [Nothing, Just 3, Nothing]
20:47:07 <lambdabot>  [[Nothing,Just 3,Nothing],[Nothing,Just 3,Just 5],[Just 5,Just 3,Nothing],[J...
20:47:41 <chessguy> hm
20:48:49 <newsham> > (\x -> zip3 (inits x) x ((drop 1.tails) x)) "test"
20:48:51 <lambdabot>  [("",'t',"est"),("t",'e',"st"),("te",'s',"t"),("tes",'t',"")]
20:49:26 <newsham> map across that zip3
20:50:25 <chessguy> @pl \(x,y,z) -> x ++ [y] ++ z
20:50:26 <lambdabot> (line 1, column 6):
20:50:26 <lambdabot> unexpected ","
20:50:26 <lambdabot> expecting letter or digit, operator or ")"
20:50:26 <lambdabot> ambiguous use of a non associative operator
20:50:30 <chessguy> boo
20:50:54 <chessguy> @pl \x y z -> x ++ [y] ++ z
20:50:55 <lambdabot> (. (:)) . (.) . (++)
20:51:01 <chessguy> yay!
20:51:42 <vixey> grr
20:51:55 <vixey> Has anybody seen this error message: "500 Internal Server Error Newline in ssh key"
20:52:17 <dolio> > let f x Nothing xs z = (Just x : xs) : map (Nothing:) z ; f _ x@(Just _) _ z = map (x:) z in para (f 5) [] [Nothing,Nothing]
20:52:18 <lambdabot>  [[Just 5,Nothing],[Nothing,Just 5]]
20:52:40 <dolio> > let f x Nothing xs z = (Just x : xs) : map (Nothing:) z ; f _ x@(Just _) _ z = map (x:) z in para (f 5) [] [Just 2, Nothing, Just 3, Nothing]]
20:52:41 <lambdabot>  Parse error at "]" (column 142)
20:52:45 <dolio> > let f x Nothing xs z = (Just x : xs) : map (Nothing:) z ; f _ x@(Just _) _ z = map (x:) z in para (f 5) [] [Just 2, Nothing, Just 3, Nothing]
20:52:46 <lambdabot>  [[Just 2,Just 5,Just 3,Nothing],[Just 2,Nothing,Just 3,Just 5]]
20:52:53 <newsham> http://codepad.org/LjR1OC46
20:53:08 <chessguy> @hoogle para
20:53:09 <lambdabot> Text.XHtml.Frameset.paragraph :: Html -> Html
20:53:09 <lambdabot> Text.XHtml.Frameset.param :: Html
20:53:09 <lambdabot> Text.XHtml.Strict.paragraph :: Html -> Html
20:53:28 <newsham> vixey: did you cut&paste your ssh key?
20:53:37 <vixey> yes
20:53:45 <newsham> it probably pasted as several lines
20:53:51 <newsham> when it should all be on a single line
20:54:10 <newsham> use an editor to fix (ie. capital-J in vi, followed by deleting the extra spaces)
20:54:43 <vixey> does it end at == ?
20:54:50 <chessguy> dolio:  what's para?
20:55:10 <newsham> which key file are you doing?  authorized_keys? ?
20:55:11 <dolio> para f z [] = z ; para f z (x:xs) = f x xs (para f z xs)
20:55:20 <vixey> .ssh/id_dsa.pub
20:55:28 <dolio> Paramorphism.
20:55:40 <newsham> there's an optional email address after the =
20:55:51 <vixey> yeah
20:55:52 <newsham> which is on the same line
20:56:12 <newsham> so "ssh-dss<space><base64><space><email addr>\n"
20:56:22 <newsham> all one big happy line
20:56:44 <newsham> alternately, scp the file up instead of cut&paste
20:57:00 <vixey> I don't think I can scp
20:57:14 <vixey> I was trying to make an account on community.haskell.org
20:57:15 <newsham> if you can ssh you can scp
20:57:52 <newsham> how did you send the file?  via web server somehow?
20:58:05 <vixey> yeah I pasted into this form http://community.haskell.org/admin/account_request.html
20:58:15 <vixey> it just keeps erroring though
20:58:17 <newsham> chessguy: did you see my codepage.org url?  is that good for you?
20:58:39 <newsham> vixey: hmm, can you make it all one line when pasting?
20:58:46 <vixey> yes it is all one line
20:59:07 <newsham> *shrug* then i'm not sure. email tech support?
20:59:40 <newsham> are you cutting and pasting from windows?
20:59:50 <vixey> no mac os
20:59:54 <chessguy> @pl newsham  eh?
20:59:55 <lambdabot> (line 1, column 13):
20:59:55 <lambdabot> unexpected end of input
20:59:55 <lambdabot> expecting white space or simple term
20:59:58 <chessguy> err, whoops
21:00:03 <newsham> [17:52] < newsham> http://codepad.org/LjR1OC46
21:00:18 <chessguy> sorry, didn't know that was for me
21:00:58 <vixey> lol beh. this is a mess
21:01:25 <newsham> perhaps haskell.org needs to filter the input they get from that form
21:02:19 <vixey> no I think software is just conspiring against me
21:02:31 <chessguy> @pl \x y -> f (g x) [] y
21:02:32 <lambdabot> flip f [] . g
21:03:27 <ddarius> vixey: Which OS are you on?
21:03:33 <vixey> mac os k
21:03:34 <vixey> x
21:06:05 <newsham> if you cut from inside certain programs it will have newlines in your paste, too.
21:06:12 <newsham> ie. if you do it from in vi.
21:07:56 <newsham> well.. i just tried that in my vim and my vi, and its only true for my vi (freebsd) and not vim.
21:08:40 <newsham> but anyway, be aware of that, some programs format your data to include newlines
21:20:02 <vixey> ⊗ ⊕ are so rubbishly similar
21:20:14 <vixey> they are too small
21:20:23 <ddarius> Increase your font size
21:20:40 <vixey> that makes everything else too big except them
21:20:48 <ddarius> Hack the font file.
21:21:41 <hml> what's a good tutorial for the haskell ffi? i'm implementing a meshing library in c++ and want to be able to interface it from haskel
21:21:49 <ddarius> @where ffi
21:21:50 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
21:23:11 <hml> thanks
21:27:22 <hml> a mesh is a list of faces; where each face is a tuple of vertex id's; mapping into an array of vertices
21:27:41 <hml> so i prolbably don't want to store my array of vertices as an list
21:27:45 <hml> since i want random access
21:27:59 <hml> does haskell have any read only structure with O(1) random access?
21:29:44 <ddarius> Yes.  They are called arrays.
21:30:04 <hml> hmm, i only saw list in the haskell tutorials
21:30:04 <ddarius> In fact, there is a plethora of them.
21:30:10 <hml> can you point me to one i should use/learn ?
21:30:24 <ddarius> I don't know which one you should use.
21:46:25 <kaspyanand> hi
21:46:31 <vixey> hi kaspy
21:46:38 <kaspyanand> i am trying to understand partial function application
21:46:54 <kaspyanand> say a function is niceSum xs = foldl (+) 0 xs
21:47:17 <kaspyanand> in terms of partial application we can write  -niceSum xs = foldl (+) 0
21:47:27 <kaspyanand> but this function does not work,why?
21:47:39 <vixey> you didn't drop the xs
21:47:44 <vixey> niceSum xs = foldl (+) 0 xs
21:47:48 <dobblego> because of its type; you need to apply xs or drop it both sides
21:47:49 <vixey> niceSum = \xs -> foldl (+) 0 xs
21:47:53 <vixey> niceSum = foldl (+) 0
21:47:57 <kaspyanand> ol
21:47:59 <kaspyanand> ok
21:49:27 <kaspyanand> now this works since foldl expects 3rd argument to be a list
21:49:35 <kaspyanand> so compiuler is able to evaluate it
21:49:45 <kaspyanand> *compiler*
21:50:21 <vixey> > map (* 3) [x,y,z]
21:50:22 <lambdabot>  [x * 3,y * 3,z * 3]
21:50:34 <vixey> > map ((*) 3) [x,y,z]
21:50:37 <lambdabot>  [3 * x,3 * y,3 * z]
21:50:53 <kaspyanand> rite
21:51:13 <kaspyanand> on its own if i use (+1) is does not work
21:51:24 <vixey> (+1) works
21:51:27 <vixey> :t (+1)
21:51:29 <lambdabot> forall a. (Num a) => a -> a
21:52:01 <kaspyanand> i am getting an error on ghci,when i evaluate (+1)
21:52:13 <kaspyanand> not with (-1)
21:52:43 <allbery_b> (+1) is a section
21:52:51 <allbery_b> :t (+1)
21:52:52 <lambdabot> forall a. (Num a) => a -> a
21:53:23 <kaspyanand> allbery_b:whats a section? i have not yet read about it
21:53:26 <allbery_b> (-1), due to a quirk of the language definition, is negative one
21:53:33 <kaspyanand> k
21:53:34 <allbery_b> a partially applied operator
21:53:44 <allbery_b> (+1) is \x -> x + 1
21:54:13 <allbery_b> whidh, being a function, can't be displayed
21:55:29 <kaspyanand> yu said "whidh, being a function, can't be displayed",but functions return value so why not displayed,sorry i dont get it
21:55:46 <vixey> they can be displayed
21:55:52 <vixey> GHCi doesn't do this though
21:55:54 <allbery_b> a function, when applied, returns a value.  this is only partially applied
21:55:59 <vixey> > (+1)
21:56:00 <vixey> > (+1) 7
21:56:01 <lambdabot>  <Integer -> Integer>
21:56:02 <lambdabot>  8
21:56:24 <kaspyanand> ok
21:56:57 <allbery_b> let me try it this way:  you have an operator (+).  if you write (1+) or (+1) you are supplying one side or the other to the operator, but leaving the other side undefined; instead of being a 2-argument operator you now have a 1-argument operator
21:57:41 <kaspyanand> rite
21:58:01 <allbery_b> haskell being a functional languiage, this is an entirely acceptable thing to pass around... but you can't display it because de-compiling code to haskell source is Hard
21:58:32 <allbery_b> (even ghci compiles code, but to a bytecode interpreter vaguely like JVM or CLR)
21:58:41 <kaspyanand> OK
21:59:03 <allbery_b> > map (1+) [1..10]
21:59:05 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
21:59:17 <allbery_b> > map (+1) [1..10]
21:59:19 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
22:01:34 <kaspyanand> ok
22:01:52 <vixey> > map (/6) [1..10]
22:01:58 <lambdabot>  [0.16666666666666666,0.3333333333333333,0.5,0.6666666666666666,0.83333333333...
22:01:59 <vixey> > map (6/) [1..10]
22:02:01 <lambdabot>  [6.0,3.0,2.0,1.5,1.2,1.0,0.8571428571428571,0.75,0.6666666666666666,0.6]
22:02:11 <kaspyanand> dropWhile isSpace "  \n\nfoo"
22:02:19 <allbery_b> Just remember that (-) si a weird special case
22:02:34 <kaspyanand> now in this case (dropWhile IsSpace) too is a function
22:02:58 <allbery_b> you can say (1-), but (-1) is a number; (subtract 1) is the Prelude-blessed way to specify the section, but there are other ways to do it
22:03:11 <allbery_b> yes
22:03:17 <allbery_b> :t dropWhile isSpace
22:03:19 <lambdabot> [Char] -> [Char]
22:04:22 <ddarius> allbery_b: It would be no problem, implementationally, to display functions.
22:04:42 <ddarius> The problem is to display them in a way that does not violate referential transparency.
22:05:01 <vixey> hey that's no problem
22:05:10 <vixey> well unless you restrict 'show' to take finite time
22:05:26 <dobblego> ddarius, you mean, collect arguments and results, then display those?
22:05:31 <kaspyanand> in this case dropWhile isSpace "  \n\nfoo" ,does the interpreter/compiler first calls dropWhile isSpace ?
22:05:34 <ddarius> dobblego: No.
22:05:56 <vixey> > dropWhile isSpace "  \n\nfoo"
22:05:58 <lambdabot>  "foo"
22:06:42 <vixey> > (dropWhile isSpace) "  \n\nfoo"
22:06:44 <lambdabot>  "foo"
22:06:52 <kaspyanand> vixey:i understand that
22:06:54 <vixey> > let x = (dropWhile isSpace) in x "  \n\nfoo"
22:06:56 <lambdabot>  "foo"
22:07:19 <kaspyanand> what i am not getting is the how to think of this concept of partial functions while writing my own functions,what power it gives us?
22:07:43 <ddarius> kaspyanand: Don't think about it.  It's not that important.
22:07:52 <kaspyanand> ok
22:10:38 * vixey looks for the next programming language to implement ....
22:11:50 <vixey> hi
22:16:50 <dolio> Implement Java.
22:33:25 <dolio> Man, I need to get this new linux kernel that might shave 5% off my bzip2 compression times.
22:35:20 <Caelum> how does it do that?
22:36:24 <dolio> I don't know, but there's an article in front of me that's benchmarking 2.6.25 vs. 2.6.26.
22:36:47 <Caelum> weird
22:37:16 <dolio> The differences are pretty negligible.
22:37:57 <ddarius> 5% is actually reasonably significant.
22:38:16 <dolio> Although the new kernel only gets a 7558163.50 on the BYTE Unix Benchmarks v3.6, vs. 7911183.40 for the old one.
22:38:35 <dolio> Whatever that means.
22:38:56 <dolio> Most of the differences aren't 5%.
22:46:20 <dublpaws> is it possible to read data from the disk and store it in data structures outside of the IO monad?
22:46:56 <vixey> not really
22:47:09 <vixey> :t unsafePerformIO
22:47:14 <lambdabot> Not in scope: `unsafePerformIO'
22:48:12 <vixey> why would you want to do something like that outside of IO?
22:48:32 <thetallguy> plenty of reasons
22:48:33 <dublpaws> I'm trying to process a datafile that's all.
22:48:45 <vixey> thetallguy: I meant to ask dublpaws
22:49:01 <thetallguy> if an external action is purely functional, then there is no need to sequence it in the IO monad
22:49:32 <thetallguy> vixey: I know, horning in, sorry.
22:49:35 <vixey> dublpaws: so did you try something and got problems because of IO?
22:49:36 <quicksilver> dublpaws: yes, it is.
22:49:51 <quicksilver> dublpaws: however, your "outermost control structure" will be in IO
22:50:04 <quicksilver> dublpaws: but that doesn't matter; all the functions which merely use the data won't be.
22:50:25 <dublpaws> ok, I think I read something about that, where main is type IO
22:51:03 <vixey> so actually everything is inside IO
22:51:20 <paolino> anyone solved the flyswatter problem in the google code jam ?
22:51:21 <vixey> You can do pure things inside IO, but you cannot do IO inside pure functions*
22:51:51 <vixey> (* ignoring unsafePerformIO)
22:54:12 <quicksilver> well I think "everything is inside IO" is a deceptive statement, only true from one perspective.
22:54:35 <quicksilver> sure, from a 'program flow' point of view, 'main' is your entry point, so everything is 'behind IO'
22:54:43 <quicksilver> however, most of your functions have types :
22:54:52 <quicksilver> PureData -> PureAnswer
22:55:07 <quicksilver> and in the most natural sense to me of 'in IO' I would not call that function 'in IO'.
22:56:23 <vixey> you can't write a function readDataFromDisk :: FilePath -> String
22:56:33 <vixey> It's got to be readDataFromDisk :: FilePath -> IO String
22:56:35 <dublpaws> yeah, that is clear now
22:56:41 <dublpaws> it took 12 hours
22:58:46 <paolino> because IO is changing while the program is running you must thread the world state, to preserve transparency (if I got that right)
23:03:36 <dublpaws> thanks for the heads up about unsafePerformIO vixey, that looks like the ticket :)
23:06:33 <vixey> dublpaws: so did you try something and got problems because of IO?
23:07:12 <dublpaws> just because my functions expecting string arguments were getting IO String instead
23:07:28 <vixey> dublpaws: Have you seen do notation yet?
23:07:44 <dublpaws> so I shuffled more and more of the program into the do expression until it dawned what was happening
23:08:57 <vixey> dublpaws: Try this example out,
23:08:58 <vixey> do line <- getLine ; let reversedLine = reverse line in return reversedLine
23:09:08 <vixey> :t getLine
23:09:09 <vixey> :t reverse
23:09:23 <lambdabot> thread killed
23:09:25 <lambdabot> thread killed
23:09:44 <vixey> see getLine is type IO String, so the type of line is String
23:10:00 <vixey> that means you can use theString -> String function reverse on it
23:10:18 <vixey> dublpaws: does that relate to the problem you were talking about?
23:10:33 <dublpaws> one second please :)
23:11:13 <quicksilver> dublpaws: unsafePerformIO is not the ticket.
23:11:21 <quicksilver> it is very poor advice.
23:11:34 <vixey> "advice"?
23:11:43 <quicksilver> you write most of your programs as pure functions
23:11:54 <quicksilver> and you drive them from main which happens to be in IO.
23:13:59 <dublpaws> vixey: that do line returns an IO [Char], similar to the situation I've got
23:14:14 <vixey> dublpaws: Notice that reverse is String -> String
23:14:39 <vixey> dublpaws: *inside* the IO block, you can use pure functions on data that has been read etc etc from IO
23:14:40 <dublpaws> inside the do expression
23:18:09 <dublpaws> like a little side effect jail as far as I can tell.
23:18:18 <vixey> exactly
23:33:39 <vixey> is there a place to put haskell code?
23:58:41 * robyonrails and here's to you, Mrs. Robinson
23:59:13 * robyonrails wo wo wo
