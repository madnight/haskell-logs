00:07:33 <novas0x2a> hm. i can see how this would make another problem easier- playAI will need to use random numbers, and i liked the Random monad that the haskell wiki used to carry around the state- i wasn't quite sure how to separate the pure functions from the monadic ones when the board would be a Random board
00:16:40 <Trinithis> how can i enable -fglasgow-exts in my source code
00:17:13 <_Dae_> novas0x2a: in my experience, just pqssing around a RandomGen is easier to work with
00:17:22 <mauke> {-# OPTIONS_GHC -fglasgow-exts #-}
00:17:28 <Trinithis> ah ok
00:24:30 <pantsd> so how do I go about adding tests to a cabal package? The online documentation left at a 404 :P
00:27:45 <mmorrow> pantsd: hmm. the pdf user's guide is at http://www.haskell.org/ghc/docs/latest/Cabal.pdf
00:27:46 <lambdabot> Title: Common Architecture for Building Applications and Libraries
00:28:12 <mmorrow> section 3.11 details "setup test"
00:28:24 <mmorrow> "Run the test suite specified by the runTests field of Distribution.Simple.UserHooks"
00:28:34 <mmorrow> http://www.haskell.org/cabal/release/latest/doc/API/Cabal/Distribution-Simple-UserHooks.html
00:28:35 <lambdabot> Title: Distribution.Simple.UserHooks, http://tinyurl.com/6bvl58
00:28:38 <mmorrow> :)
00:30:28 <_zenon_> lol number 4542 @ php: They have type restricted equality comparison , but not type restricted ordering comparison.
00:30:47 <_zenon_> And no one in there understand what I mean
00:32:01 <mauke> just use perl
00:32:19 <_zenon_> mauke: You and your perl again
00:32:33 <_zenon_> http://everything2.com/index.pl?node_id=1515187
00:32:33 <lambdabot> Title: Why Perl sucks@Everything2.com
00:32:34 <_zenon_> :D
00:32:35 <mauke> I imagine teaching perl to a haskell programmer should be easy
00:33:16 <mauke> you already know map/filter, the magic of context, lexical scoping, etc
00:33:24 <_Dae_> perl as an alternative to php??
00:33:30 <_zenon_> yeah, but I prefer haskell :)
00:35:44 <_Dae_> _zenon_: you could write haskell via the javasript compiler? it only has a small memory-leak....
00:38:15 <_zenon_> _Dae_: Yeah, I've translated haskell code into jbc and used Jasmin ..   http://jasmin.sourceforge.net/
00:38:15 <lambdabot> Title: Jasmin Home Page
00:43:32 <_zenon_> Do we have some channel-diff script?
00:44:01 <_zenon_> like @diff #haskell #c++  and get the intersection of the two channels, (in users) ?
00:44:16 <mauke> I don't think so
00:45:16 <_zenon_> could be nice,
00:45:19 <_zenon_> :)
00:45:40 <_Dae_> I sense a project comming up?
00:45:47 <_zenon_> _Dae_: Indeed,
00:45:50 <_zenon_> betcha
00:46:27 <osfameron> yeah, you could also get it to query the channels users are in and recursively compute the intersections of all common channels
00:47:03 <osfameron> mauke: haskell has context magic?  Oh, you mean things like the typing of mempty/return/etc ?
00:47:16 <mauke> osfameron: yeah
00:47:17 <osfameron> actually, the haskell version sometimes seems even more magical, tough I guess it's actually more consistent
00:47:30 <_zenon_> could put it into lamdabot when it's done .)
00:47:31 <mauke> I mean, just look at printf or =~
00:47:42 <_zenon_> @intersect #haskell #python #lisp ....
00:47:42 <lambdabot> Unknown command, try @list
00:48:12 <osfameron> mauke: perl's or haskell's printf/=~ ?
00:49:29 <mauke> deemon astrobunny|afk tapas kayess randomity Eelis ZsoL pragma_ xci mwti dmead kalven_ rumbleca DuClare levitation[A] synthasee issal mauke Associat0r Smokey` z` ichor yahooooo orbitz lstor agemo felipe noj Mr_Awesome r0bby mornfall kawfee Spark
00:49:36 <mauke> osfameron: haskell's
00:50:19 <xci> hm?
00:50:45 <mauke> xci: you're in the intersection of #haskell and ##c++
00:51:18 <mauke> (computed using Perlâ„¢)
00:52:57 <_Dae_> I don't know.... I just always end up writing messy code in multi-paradigm......
00:53:20 <_zenon_> _Dae_: It's because multi paradigm is made to be messy
00:53:40 <_Dae_> Ahh, I should've known
00:54:20 <dolio> @seen vixey
00:54:21 <lambdabot> vixey is in #rosettacode, #haskell and ##logic. I last heard vixey speak 1h 48m 44s ago.
00:54:31 <Vq^> depends a bit on what paradigms you mix, imperative and functional like in lisp can create quite a good mess if you don't keep to one of them
00:54:58 <_Dae_> Sooo... the logical consequence of that is that multi-paradigms are only to be used in code that only 1 person needs to maintain?
00:55:01 <DuClare> Hi mauke, what's up.
00:55:21 <_zenon_> yeah
00:55:47 <Vq^> _Dae_: well, at least then there is only one person shooting herself in the foot
00:56:36 <_Dae_> Vq^: As in, all multi-paradigm languages are, in fact, rubbish? (and not just compared to haskell)
00:56:46 <dolio> @tell vixey: I rewrote my more polished PTS type checker to use unification (and fixed up the unification algorithm a little). You can see it at http://code.haskell.org/~dolio/pts/ (it's a darcs repo, it's got a little REPL, too).
00:56:46 <lambdabot> Consider it noted.
00:57:00 <_zenon_> @seen kiris
00:57:00 <lambdabot> kiris is in #haskell. I last heard kiris speak 3h 45m 24s ago.
00:57:14 <_zenon_> kiris: How's the word-poster coming?
00:57:53 <Vq^> _Dae_: i would say that you need a stricter coding discipline
00:58:27 <_Dae_> Vq^: Even when compared to c++?
00:59:00 <Vq^> i don't even know if C++ can be non-messy :o)
00:59:34 <_Dae_> Well sure it can.....
00:59:55 <_Dae_> The trick is not to use the ++ part
01:00:17 <Vq^> i guess
01:00:53 <Vq^> i used some of those partial-application template macro thingiemajjigs once (bind1,bind2 or whatever they were called)
01:01:07 <dolio> The trick is to use lots of underscores.
01:01:11 <Vq^> and the result where apparantly not very readable
01:01:13 <dolio> At least, that's what the GNU STL does.
01:01:33 <_Dae_> I was joking.  Most of the groundwork in software arcitechture was done with c++. Patterns, etc makes it ok, as long as everyone agrees on how to do it
01:02:10 <Vq^> software architecture?
01:02:33 <_Dae_> software design?
01:02:48 <Vq^> OOP-idioms you mean?
01:03:00 <_Dae_> We can call 'em that if you want
01:03:15 <columbin> ok heres a real good request (:x)
01:03:25 <_Dae_> Design patterns, basicly
01:03:38 <Vq^> columbin: lets hear it :)
01:04:13 <columbin> i havent searched /downloaded this crap since i was in junior high, but im trying to build transparent bsd fire wall with http/ftp and email virus scanning
01:04:23 <Vq^> _Dae_: i guess there was a few more languages involved than C++
01:04:28 <columbin> but i cant find a collection of virus's anywhere to test it lol
01:05:11 <columbin> :)
01:05:26 <_Dae_> Vq^: well... a bit of smalltalk
01:05:39 <columbin> yes :(
01:06:08 <_zenon_> columbin: http://vx.netlux.org/vl.php
01:06:10 <lambdabot> Title: Virus collection (VX heavens)
01:06:30 <_Dae_> columbin: You could always just setup a pre- service pack xp machine and plug it to the net. That should give you a fair collection
01:06:44 <columbin> thx, lol _dae_
01:07:05 <columbin> i have a nice collection on a hd from long long time ago, but its in storage somewhree...
01:07:17 <_zenon_> columbin: http://vx.netlux.org/vl.php
01:07:18 <lambdabot> Title: Virus collection (VX heavens)
01:07:39 <columbin> is that the same db av.comparitives uses by chance?
01:07:56 <Vq^> _Dae_: the weird thing is that if you pick up a book on it (say gang of four), a couple of the patterns are general and nice that could apply almost everywhere
01:08:19 <Vq^> _Dae_: and other things are _more_ imperative OOP specific
01:08:46 <Vq^> things that perhaps shouldn't even be patterns but be library functions instead
01:11:01 <_Dae_> Vq^: I agree, which is why we're not seeing tat many for haskell. I'm not a big fan of design patterns, but using them will give you readable c++ code, which is quite a feat
01:12:07 <Vq^> a fun example that is very objc or c++ specific is the prototype pattern
01:12:27 <Vq^> it exists because a few oop languages doesn't implement oo fully
01:13:15 <_Dae_> hmm?
01:13:19 <Vq^> i would like to see them put in a couple of categories depending on how general they are but i have never seen that in practice
01:13:41 <Vq^> prototype pattern is basicly a replacement for a metaclass
01:14:17 <Vq^> oh, my bad, i should have said java instead of objc
01:15:10 <_Dae_> heh... yeah I agree with you there
01:15:12 <Mitar> why does not (!!) operator return Maybe?
01:15:37 <_zenon_> Mitar: It throws an exception
01:15:42 <_zenon_> @src (!!)
01:15:43 <lambdabot> xs     !! n | n < 0 = undefined
01:15:43 <lambdabot> []     !! _         = undefined
01:15:43 <lambdabot> (x:_)  !! 0         = x
01:15:43 <lambdabot> (_:xs) !! n         = xs !! (n-1)
01:15:50 <mauke> Mitar: because it hates you
01:16:01 <mauke> on the other hand, how often are you going to use it anyway
01:16:01 <therp> aggressive source code
01:16:40 <mauke> hmm, transforming a list into Maybe seems redundant
01:16:47 <Mitar> ehm, i am using it ...
01:16:58 <Saizan> --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
01:17:03 <quicksilver> if you're using (!!) you're doing something wrong.
01:17:07 <Mitar> why?
01:17:10 <quicksilver> thanks for sharing, Saizan :P
01:17:13 <mauke> if you can write case xs !! n of Nothing -> ...; Just x -> ..., you can also write case drop n xs of [] -> ...; x : _ -> ...
01:17:16 <Mitar> why is there then ?
01:17:23 <quicksilver> because it has linear complexity
01:17:34 <quicksilver> so use of (!!) almost always indicates you're using the wrong structure.
01:17:48 <Mitar> ahh, i am parsing program arguments :-)
01:17:53 <_zenon_> quicksilver: Not if you do it once
01:17:56 <Mitar> it is a list of strings ... cannot be helped :-)
01:18:18 <Mitar> so I would like to read a switch and the next param
01:18:19 <_zenon_> quicksilver: Repeated use is an abuse though
01:18:20 <therp> I always require craft my API to return a dyphantine equation and higher order function, where the higher order function only yields a result of called with the solution of the dyphantine, otherwise it returns undefined. <-- aggressive APIs.
01:18:46 <mauke> Mitar: why not use an existing GetOpt module?
01:18:48 <hpaste>  Mitar pasted "params" at http://hpaste.org/8863
01:18:58 <Mitar> because it is only one param :-)
01:18:58 <quicksilver> _zenon_: I was exaggerating, which is a trait of mine.
01:19:06 <mauke> Mitar: so?
01:19:18 <_zenon_> quicksilver: Hmmm.. a nasty trait
01:19:25 <quicksilver> _zenon_: however, (!!) is often a sign of misuse.
01:19:28 <mauke> and argument parsing can be done left to right
01:19:34 <mauke> no need for !!
01:19:58 <_zenon_> quicksilver: surely, when used repeatedly, however, used once or twice, for small n, I don't see the problem
01:20:04 <quicksilver> _zenon_: programming is a complex issue. Full answers to problems often require paragraphs and paragraphs of explanation.
01:20:16 <quicksilver> it is often a convenient simplification to give brash generalisations.
01:20:22 <mauke> and/or a kick in the nuts
01:20:24 <_zenon_> quicksilver: Sure, but there is no need to obfuscate the whole truth
01:20:40 <quicksilver> I'm not obfuscating anything.
01:20:50 <_Dae_> I thought obfuscation was an essential part of any programming language?
01:20:54 <_zenon_> Now this is becoming a debate of pedagogical issues
01:21:06 <_zenon_> _Dae_: No, only perl and c
01:21:07 <_zenon_> :P
01:21:14 <quicksilver> I'm here to elaborate on my comments if needed.
01:21:22 <_Dae_> _zenon_: I think you forgot brainfuck.....
01:21:25 <quicksilver> mauke picks me up fast enough if I say anything badly wrong :P
01:21:45 <_zenon_> quicksilver: Of course, but most newcomers don't argue against an oldie
01:21:54 <quicksilver> which is reasonable.
01:22:03 <quicksilver> because I'm almost always giving correct advice, in fact.
01:22:17 <quicksilver> it's more efficient to say "don't use (!!)" oor "you probably shouldn't use (!!)"
01:22:26 <quicksilver> than embark on a 1000 word explanation of complexity classes
01:22:29 <quicksilver> and exceptions to rules.
01:22:55 <quicksilver> if I end up being wrong, you're welcome to a full and total refund of all the monies you paid for my training and advice.
01:23:20 <_Dae_> _zenon_: quicksilver is the prophet of haskell, AND the worlds most advanced IRC bot.... his are words of truth
01:23:41 <osfameron> the Quicksilver Moneyback Guaranteeâ„¢
01:23:50 <mauke> why do I need this function all the time
01:24:16 <mauke> > let nc n c = (n - 1) `div` c + 1 in nc 17 8
01:24:17 <lambdabot>  3
01:24:31 <_zenon_> quicksilver: You could have said. "as long as you don't use it repeatedly"
01:25:02 <dolio> `div` c?
01:25:09 <Mitar> http://www-users.cs.york.ac.uk/~ndm/catch/ << is not that checked by ghc when using -Wall?
01:25:11 <lambdabot> Title: Neil Mitchell - Catch: Case Totality Checker for Haskell
01:25:14 <quicksilver> mauke: I'm not sure. I don't remember ever needing it :)
01:25:36 <quicksilver> Mitar: Catch does something profoundly cleverer than what -Wall checks.
01:25:45 <mauke> quicksilver: maybe you're not writing in C
01:26:14 <dolio> Mitar: GHC will tell you if you left out a case. Catch will tell you if you left out a case that matters.
01:26:31 <mauke> it answers the question: how many containers do I need to store n items given that each container can store c items?
01:27:34 <quicksilver> > let nc n c = (n - 1) `div` c + 1 in nc 16 8
01:27:36 <lambdabot>  2
01:28:04 <quicksilver> mauke: Ah yes. I have needed that once or twice, now you mention it :)
01:28:05 <dolio> > let nc n c = (n - 1) `div` c + 1 in nc 0 8
01:28:06 <lambdabot>  0
01:29:06 <quicksilver> _zenon_: yes, I could. But even using it once for n bigger than, say, 2, often indicates something is odd :)
01:32:34 <Mitar> why this does not catch exception: param <- catch (return $ read (args !! (i + 1))) (\_ -> error "Missing argument")
01:32:49 <mauke> because it doesn't throw one
01:33:24 <_zenon_> quicksilver: maybe, or maybe not.
01:39:31 <quicksilver> Mitar: don't use read. Don't use to catch to catch exceptions in pure code.
01:39:53 <quicksilver> Mitar: for this use case, use reads, which indicates its failure explicitly.
01:41:45 <Mitar> yes, but the error is in (!!)
01:41:49 <Mitar> not in read
01:41:58 <Mitar> Main: Prelude.(!!): index too large
01:48:49 <Mitar> how can i catch this?
01:48:59 <mauke> stop using !!
01:49:43 <mmorrow> mauke: stop using what ??
01:49:50 <mauke> Â¡!
01:49:53 <mmorrow> hehe
01:51:22 <Mitar> ehm, but there must be a way to catch it?
01:51:23 <mmorrow> surely you meant to insert PELIGRO in there
01:51:46 <mauke> Mitar: not necessarily
01:52:09 <Mitar> perl has nice eval :-0
01:52:47 <mmorrow> which has to invoke the compiler
01:53:01 <mmorrow> just like haskell's eval does!
01:53:07 <mmorrow> (in plugins)
01:53:58 <mauke> Mitar: and haskell has catch
01:53:59 <_Dae_> Some day, someone must explain to me the advantage of compiling your code at runtime....
01:54:02 <mauke> mmorrow: wrong
01:54:08 <mmorrow> oops
01:54:27 <mmorrow> i coulda sworn i read that perl's eval invokes the compiler
01:54:32 <mauke> Mitar: the difference is that (!!) doesn't call "die"
01:54:41 <mauke> mmorrow: perl has two functions called "eval"
01:54:49 <mmorrow> oh
01:54:51 <mmorrow> do tell
01:54:53 <mauke> we're talking about the other one :-)
01:55:08 <mauke> eval BLOCK - execute BLOCK and catch exceptions
01:55:19 <mmorrow> interesting
01:56:01 <mmorrow> what happens upon catching an exception?
01:56:20 <mmorrow> oh, does it go in $? or something
01:56:27 <mauke> eval returns undef and stores the exception in $@
01:56:36 <mmorrow> ah
01:56:36 <Mitar> :-)
01:57:12 <Vq^> whats that? some symbolic version of errno?
01:57:29 <mauke> no, just a variable that contains the "current exception"
01:57:39 <mauke> (or undef if the last eval didn't see an exception)
01:57:50 <mmorrow> my guess was where the money's at
01:59:41 <_zenon_> _Dae_: The state of the program can be determined during runtime, so the compiler can optimize with respect to that.
01:59:47 <_zenon_> _Dae_: I think,
02:02:03 <_Dae_> _zenon_: But that's just a VM like java, I'm talking about compiling raw code, java at least preprocesses its
02:04:11 <_zenon_> _Dae_: Then I don't know.  On a side matter: http://edocs.bea.com/jrockit/geninfo/diagnos/underst_jit.html
02:04:12 <lambdabot> Title: Understanding JIT Compilation and Optimizations
02:04:52 * _Dae_ points to people using "eval" and similar functions
02:07:53 <mmorrow> _Dae_: suppose you generate code at runtime based on information that's only available then
02:07:55 <Vq^> _Dae_: could it be to allow for the user to enter expressions into the application?
02:08:24 <Vq^> _Dae_: compiling regex is easy to defend for example
02:09:49 <_Dae_> mmorrow: Such as?
02:10:14 <_Dae_> Vq^: Allright, it's a bit roundabout way of doing it, but I can see your point
02:10:19 <mmorrow> _Dae_: for example, in haskelldb you can generate modules which completely describe all the tables in a database. so the only way to immediately mke use of this code to make (typesafe queries) is to compile it then load it
02:11:04 <mmorrow> or you'd have to recompile the program/another program which import these modules, then run that in order to query the db
02:11:21 <_Dae_> mmorrow: Right....ok that makes sense :)
02:11:27 <mmorrow> :)
02:11:34 <_zenon_> _Dae_:Hotswapping code :)
02:11:44 * _Dae_ strikes "eval" from the "Do NOT want" list
02:12:13 <mmorrow> heh
02:12:44 <_Dae_> _zenon_: yeah.... I've just seen a lot of really ugly code done using eval, and had ended up at the conclusion that all it did was slow down your code
02:12:54 <Toxaris> > "_Dae_: Did you consider me when trying to avoid eval?"
02:12:55 <lambdabot>  "_Dae_: Did you consider me when trying to avoid eval?"
02:13:18 <_Dae_> Toxaris: hmm?
02:13:24 <mauke> > 2 + 2
02:13:25 <lambdabot>  4
02:13:46 <mmorrow> lambdabot invokes ghc for every single exp it evals
02:13:59 <_zenon_> > 2 + ( foldl' (+) 0 $ repeat 2 )
02:14:00 <_Dae_> I thought it was an interface to ghci?
02:14:05 <lambdabot>  Exception: Time limit exceeded
02:14:12 <_Dae_> not that there's a difference....
02:14:16 <mmorrow> oh no, it uses hs-plugins
02:14:25 <_zenon_> @pl 2 + ( foldl' (+) 0 $ repeat 2 )
02:14:25 <lambdabot> 2 + foldl' (+) 0 (repeat 2)
02:14:30 <_zenon_> bleh
02:14:30 * _Dae_ goes and hides in a corner, feeling dumb
02:15:02 <Toxaris> of course, lambdabot is not plain eval, but eval + sandboxing, but it compiles and runs user-defined code at runtime
02:16:14 <Toxaris> but still, eval is to be avoided *where possible* imho. e.g., many use cases of eval in simple dynamic languages can be done with first-class functions in advanced static languages
02:16:54 <_Dae_> which was more or less my experience.....
02:17:12 <_Dae_> but then again 50% of all the eval-using code I've seen is matlab...
02:17:30 <schme_> Hoh.. reading real world haskell here.. and I was wondering if there is any difference whatsoever betwixt mapM and flip forM. It seems to me that forM could be tossed out. :S
02:17:38 <mauke> @src forM
02:17:39 <lambdabot> forM = flip mapM
02:17:42 <schme_> right.
02:17:58 <schme_> Well that solves it.
02:17:59 <mauke> it looks better if your list is in a variable and the action is long
02:18:01 <mmorrow> _Dae_: it takes the string-to-eval, parses it/some other stuff to check for evil, then writes the string with a module wrapper around it to a file in /tmp, calls ghc on, then loads the resulting symbol for that exp from the resulting .o file
02:18:08 <schme_> well flip mapM looks better than forM :)
02:18:10 <Toxaris> in a sense, lambda is a variant of eval: ((lambda a . t) x) corresponds to (eval (replace t a))
02:18:24 <_Dae_> schme_: it adds understanding to the code, making it more readable
02:18:29 <mauke> forM_ xs $ \x -> do
02:18:31 <mauke>    print x
02:18:32 <Toxaris> the cool thing is of course that lambda is typed
02:18:40 <schme_> _Dae_: Huh. I think the otherway around there. I thought it made it less clear :S
02:18:57 <mauke> foreach loops should be obvious
02:19:28 <schme_> Hmm..
02:19:33 <schme_> for just seems odd to me.
02:19:34 <schme_> Oh well :)
02:19:41 <Toxaris> imho mapM is a bad thing. (sequence . map) is much clearer.
02:19:53 <_Dae_> schme_: They feel very different to me, in when and whereI'd use them, even if they are the same. I guess forM reminds me imperative languages....
02:20:00 <mauke> ITYM (sequence .) . map
02:20:22 <schme_> _Dae_: Right, yes. I guess my head is wired wrong :)
02:20:29 <_Dae_> mmorrow: That seems like a slightly odd way to go about it, doesn't it? why not just wrap ghci?
02:20:37 <mmorrow> _Dae_: unfortunately after ghc6.6, the .hi file format changed, so the new hs-plugins that works with 6.8+ uses the GHC api instead of parsing the .hi files itself and manually loading the syms from the .o
02:20:47 <mauke> schme_: maybe you should use perl for a while!
02:20:56 <Toxaris> hehe, yes, mauke. ... . mapM f . ... == ... sequence . map f ... so in a sense, mapM get replaced by sequence . map in my typical use case :)
02:21:10 <_Dae_> schme_: don't listen to mauke. Stay here with haskell, where it's warm and fuzzy
02:21:23 <mmorrow> binaries that result from importing the GHC api are around 20+M unstripped
02:21:33 <osfameron> Toxaris: many cases of eval in dynamic languages can be replaced by function refs in *dynamic* languages too...
02:21:42 <schme_> mauke: Yes. perl tends to be the answer to all major problems in the world.   :)   "Why is the server down again!? Oh! perl!" ;)
02:21:44 <_Dae_> mmorrow: is that a problem?
02:21:53 <_Dae_> schme_: rofl
02:22:04 <schme_> _Dae_: Well #haskell is warm and fuzzy anyway. Not so sure about haskell :)
02:22:05 <mauke> I consider this a benign form of trolling :-)
02:22:15 <mauke> telling #C to use Haskell, telling #haskell to use Perl
02:22:26 <mauke> telling ##c++ they're all idiots
02:22:28 <mmorrow> no, but much more heavyweight of a thing than the old hs-plugins which didn't depend on the ghc beast
02:22:46 <_Dae_> schme_: ohh? why not?
02:23:37 <_Dae_> mauke: tell #perl to use javascript?
02:23:44 <mmorrow> schme_: lol
02:23:58 <mmorrow> (re: perl)
02:24:04 <Toxaris> osfameron: sure, but *simple* dynamic languages may not have function refs. Maybe I should have said ... in advanced languages (without "static")
02:24:07 <mauke> _Dae_: nah, Haskell
02:24:16 <schme_> _Dae_: It's a bit different from what I'm used to. That's all.
02:24:41 <schme_> _Dae_: I haven't yet quite understood what's "oh so amazing!" about it as I have been told I would :)
02:24:44 <_zenon_> another interesting tool (besided channel sets) is connection graphs, creating graphs that show from where people are connecting
02:24:46 <osfameron> _Dae_: to be fair, we tell #perl to use haskell quite often :-)
02:24:57 <_Dae_> schme_: what are you used to? -inserts wild guess- Scheme?
02:24:58 <osfameron> well, not #perl, because they're too busy talking about dongs, but some of the other perl channels
02:25:11 <_zenon_> osfameron: I did it now 2
02:25:28 <mauke> _zenon_: you did it wrong
02:25:49 <_Dae_> schme_: learning haskell is a bit of a " 'oohh that's NICE!' and then giggle the next 20 minutes" - kind of experience
02:25:54 <mauke> you have to 1) know perl and 2) recommend haskell where it's at least somewhat appropriate
02:26:19 <schme_> _Dae_: :(  That's really more of a bad choice of nick by me. It's the classic C/CL/Prolog combo for me. So the heavy typeing is a bit.. odd. :)
02:26:25 <mauke> e.g. "I want to have 10,000 threads" "use Haskell!"
02:27:39 <_Dae_> schme_: don't worry. You'll get it soon. The first time you do something in 2 lines that would've taken 20 in c# is a very special moment
02:27:55 <schme_> Right.
02:28:05 <schme_> Haven't really used C# so I wouldn't know :)
02:28:07 <_Dae_> or it was for me anyway....
02:28:20 <_Dae_> c, c++, c#.....whatever really
02:28:41 <_Dae_> any OOP or imperative language will do
02:28:58 <schme_> Aha.
02:29:19 <_Dae_> anyway, what are you writing?
02:29:27 <schme_> a fibs client.
02:30:03 <schme_> I was writing it in another language, but it turns out it is missing good GUI libraries. Figured I'd might use it to learn haskell.
02:30:19 <schme_> (also I crashed the harddrive with the old code)
02:30:58 <_Dae_> hmm, ok that might be a difficult angle for a new program, a bit monad heavy, but it should be ok I think...
02:31:25 <schme_> Right. I have no other new program to do in haskell, so it's the best choice :)
02:31:27 <_zenon_> mauke: how do you mean?
02:32:11 <schme_> It was either that or fixing xmonad. Which seems a bit too much for me at the moment :)
02:33:00 <_Dae_> schme_: Yeah, I know that feeling
02:33:05 <osfameron> are there more lambdacamels than programmers with other dynamic-lang/haskell crossover insterest?  It feels that way to me, but of course I'd be biased being a Perl programmer so I listen out for that evidence
02:34:08 <quicksilver> osfameron: I suspect so, because of pugs.
02:34:24 <schme_> Hmm..
02:38:18 <schme_> _Dae_: I'm still waiting to feel the great benefit of the strict+strong typeing. It seems more of a pain then a benefit at the moment, but I suppose I'll come around.
02:38:28 <schme_> Quite entertaining language to play around with it seems.
02:39:12 <mauke> as lwall once said, the trick is to make use of the strengths of [static typing], not its weaknesses
02:39:38 <schme_> Well, of course.
02:39:47 <schme_> I'm still waiting to find 'em :)
02:40:18 <_Dae_> schme_: It's a bit of a change in thinking tbh, once you get beyond the imperative way of thinking, a lot of things become clear
02:40:50 <schme_> _Dae_: It really has nothing to do with "imperative thinking" :)
02:41:07 <EvilTerran> ok, "weakly typed thinking"
02:41:07 <_Dae_> I started out using haskell for a numerical methods course.... where every algorithm is written with imperative languages in mind
02:41:40 <schme_> EvilTerran: That sounds better :D
02:42:07 <mauke> well, you can't really write 'return' without static typing
02:42:20 <schme_> How so?
02:42:21 <EvilTerran> _Dae_, well, that's a little unfortunate as your first exposure to haskell
02:42:44 <mauke> because the surrounding type context determines which instance to call
02:42:49 <EvilTerran> not as bad as my school computing teacher, who took a command-line based syllabus and wedged it into VB6, mind =/
02:43:09 <_Dae_> EvilTerran: Nah, it was cool. I learned a lot.
02:43:18 <_Dae_> EvilTerran: Hahaha! Seriously?
02:43:24 <EvilTerran> seriously
02:43:59 <EvilTerran> i ended up ignoring the form builder and just working with a series of popup message boxexs and input boxes, thus approximating a command line
02:44:15 <schme_> _Dae_: I have been pretty well weened off of imperative think for quite some time. The functional part of it all, nor the declarative part of it all, is not so very new to me. It's mostly just the lazyness and typeing :)
02:44:31 <EvilTerran> meanwhile, i suspect the rest of the class got, as dijkstra would put it, "irreperably broken"
02:44:32 <schme_> mauke: Sounds complicated (:
02:44:41 <mauke> schme_: it's just a virtual constructor
02:44:51 <_Dae_> well, outside the university I've yet to see a competent computing teacher. And even there it's not always the best....
02:45:10 <EvilTerran> _Dae_, amen. i've had to suffer some pathetically bad lecturers.
02:45:12 <_Dae_> EvilTerran: it sounds horrible to be honest
02:45:16 <schme_> mauke: Right. I'm sure that'll make sense in some time (:
02:45:27 <mauke> huhu
02:45:53 <mauke> > sum (replicate 10 0.1)  :: Double
02:45:55 <lambdabot>  0.9999999999999999
02:45:58 <mauke> > sum (replicate 10 0.1)  :: Rational
02:45:59 <lambdabot>  1%1
02:46:03 <EvilTerran> i figure, if you want to lecture a course at uni, you need to 1) know the course very well 2) have a good grasp of the language you're expected to speak and 3) be good at public speaking and presenting information
02:46:05 <_Dae_> schme_: it grows on you :) a lot
02:46:13 <EvilTerran> some of my lecturers have failed on all three accounts =/
02:47:16 <_zenon_> EvilTerran: That sucks balls, I must say. How can they lecture the course then?
02:47:36 <schme_> Hrm.. I'm a bit confused by doesFileExist here though. Why is it saying False to doesFileExist "." ?
02:47:37 <mauke> Terrible!
02:47:38 <_zenon_> EvilTerran: Especially point 19
02:47:40 <_Dae_> EvilTerran: My first course in programming at uni had multimedia guys, nano-techns and geologists learning Java (of all things) together with the computer scientists. Needless to say it was VERY basic
02:48:04 <the_unmaker> nanotechnology is a farce
02:48:11 <mauke> @index doesFileExist
02:48:12 <lambdabot> System.Directory, Distribution.Compat.Directory
02:48:14 <the_unmaker> as well to study teleportation
02:48:20 <the_unmaker> or distant galaxies
02:48:25 <mauke> schme_: I have no idea
02:48:27 <the_unmaker> nothing useful comes from it
02:48:37 <_zenon_> the_unmaker: Nano tech /= teleportation ...
02:48:43 <schme_> teleportation
02:48:47 <schme_> Cool stuff.
02:48:48 <the_unmaker> mass production of housing should be higher on the list methinks
02:48:51 <_Dae_> the_unmaker: Well.... it's more that nano-technology is being used as a buzz-word for EVERYTHING
02:48:52 * schme_ teleports some coffee.
02:49:21 <_zenon_> http://www.chalmers.se/en/sections/education/masterprogrammes/programme-descriptions/materials-nanotechnology
02:49:23 <lambdabot> Title: Chalmers: Materials and Nanotechnology, http://tinyurl.com/5z6f6x
02:49:25 <the_unmaker> physicists on radio might as well be talking about dengeons and dragons for all thier lightly comedic babble has to do with reality
02:49:36 <mauke> schme_:  The operation doesFileExist returns True if the argument file exists and is not a directory, and False otherwise.
02:49:42 <_zenon_> the_unmaker: Who are you? What do you know about these areas?
02:49:58 <the_unmaker> I am the avatar of lord poesidon if the sea
02:50:03 <the_unmaker> of the sea
02:50:05 <the_unmaker> that is
02:50:24 <_zenon_> okay, thanks, that cleared a lot for me.
02:50:25 <quicksilver> excellent news. Mine's a battered plaice, lightly fried.
02:51:25 <the_unmaker> [hellboy 2 was really bad]
02:52:01 <_zenon_> you must put it in string
02:52:04 <quicksilver> EvilTerran: to add to everything you say, teaching programming is hard.
02:52:13 <quicksilver> EvilTerran: even good teachers agree.
02:52:16 <EvilTerran> quicksilver, indeed
02:52:22 <quicksilver> (compared to, say, teaching basic differential calculus)
02:52:34 <_zenon_> @pl map toUpper $  words ["hellboy 2 was really bad"]
02:52:34 <lambdabot> map toUpper (words ["hellboy 2 was really bad"])
02:52:40 <EvilTerran> i'd file that under a mixture of 1 and 4
02:52:41 <_zenon_> > map toUpper (words ["hellboy 2 was really bad"])
02:52:41 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
02:52:42 <EvilTerran> er, 3
02:52:52 <_zenon_> do'h forgot
02:52:53 <EvilTerran> got to know the course, and got to be good at teaching
02:53:05 <_zenon_> map (map toUpper)  (words ["hellboy 2 was really bad"])
02:53:07 <_zenon_> > map (map toUpper)  (words ["hellboy 2 was really bad"])
02:53:08 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
02:53:19 <EvilTerran> > words . map toUpper $ "hellboy 2 was really bad"
02:53:20 <lambdabot>  ["HELLBOY","2","WAS","REALLY","BAD"]
02:53:28 <quicksilver> well, in my opinion it's a further issue. You can be a skilled teacher and an excelletn programmer and still hit the problem that teaching programming is hard :)
02:53:38 <_zenon_> thx EvilTerran,
02:53:41 <_zenon_> :P
02:53:44 <EvilTerran> yeah, true
02:53:48 <_Dae_> EvilTerran: half the problem is making it relevant t the people you're teaching.
02:53:54 <EvilTerran> ok, 4) you need a competent class :P
02:54:09 <quicksilver> teachers aren't permitted to require (4)
02:54:11 <_zenon_> 5) You need a good pay
02:54:11 <quicksilver> more's the pity :P
02:54:12 <schme_> mauke: That's very odd behaviour, me thinks.
02:54:18 <_zenon_> or 5)
02:54:29 <mauke> schme_: yep
02:54:34 <quicksilver> schme_: yes, they are slightly bizarre choices of primitive.
02:54:36 <_Dae_> quicksilver: well if you have a competent class they'll be able to learn it without the teacher, won't they?
02:54:43 <schme_> Maybe it's some portability thing.
02:54:46 <quicksilver> schme_: however, they are comparable to the venerable (-d and -f)
02:55:34 <schme_> I'm not really complaining. The file handling stuff seems quite a bit easier to work with than what I am used to :)
02:55:37 <quicksilver> _Dae_: perhaps. And yet teachers are still useful. Not everyone can/will self-teach, and self-teaching is not always the most effective way.
02:55:40 <_zenon_> as a lecturer at TU, you must put a LOT of your time on teaching, and the rest at what you really want: research
02:55:47 <quicksilver> says he, being self-taught.
02:56:03 <quicksilver> zeno: TUE?
02:56:15 <_zenon_> Technical University
02:56:36 <quicksilver> yes, I know. The one that most famously uses that title in my experience is TUE (in Eindhoven)
02:56:43 <quicksilver> I was wondering if that's the one you meant.
02:56:48 <_zenon_> In swedish, to learn is  "to teach oneself"
02:56:58 <_Dae_> quicksilver: Well that's true, my point is that even with a bad teacher, students who -want- to learn how to program, will learn it.
02:57:10 <hpaste>  plutonas pasted "what's wrong with this?" at http://hpaste.org/8864
02:57:10 <quicksilver> etymology is not always the source of ultimate truth ;)
02:57:34 <plutonas> can someone tell me why this error appears? the code looks ok to me :S
02:57:40 <_Dae_> Lies! Bow to the church of word-history!
02:57:52 <quicksilver> plutonas: you meant -> Maybe a
02:57:56 <quicksilver> plutonas: not -> Maybe [a]
02:57:57 <mauke> plutonas: the return type should be Maybe a
02:57:58 <quicksilver> (in the type)
02:58:08 <plutonas> oh, thanks
02:58:15 <plutonas> should have seen that... anyway thank you
02:58:25 <quicksilver> you're welcome.
02:58:57 <_zenon_> _Dae_: Hehehe, I love jokes on religion
02:59:18 <_zenon_> No matter how upset religious people get
03:00:03 <_Dae_> _zenon_: it's a side effet of natural science, isn't it?
03:00:32 <_zenon_> _Dae_: I believe so, and definitively a side effect of thinking.
03:00:48 <_zenon_> Uh oh,,, maybe we are saying to much.
03:01:48 <_Dae_> Nah, it's not like we're saying that religion is bad. Just that extremism is? Don't interpret the stuff so rigidly
03:03:31 <_zenon_> _Dae_: I'm not interpeting it rigidly, just watching my back. Don't want hatemails. Religious people you know. Burning witches an' all
03:04:01 * quicksilver bundles together some witches, lights them, and throws _zenon_ on top.
03:04:03 <_Dae_> That's not true....
03:04:16 <quicksilver> lambdas make great firelighters!
03:04:25 <_zenon_> lambdas? what? hahaha
03:04:36 <_Dae_> I know plenty religious people. Most have a "live and let live" kind of thinking
03:05:01 <_zenon_> uh oh. someone got stepped on their toes.
03:06:00 <_Dae_> Well, _zenon_ , in a chat containing 400 people, chances are most of them will be believing in some religion or another.
03:07:11 <_zenon_> Maye, but hopefully they have the sense of free-thinking not to be bothered by the history of what they believe in.
03:07:53 <_zenon_> It's a fact christianity has abused it's power imensely, secularisation is a must for a people to evolve a free mind.
03:08:02 <JafaCake> _Dae_: I think you'll find most people here are disciples of the Church, yes
03:08:14 <quicksilver> I believe you are sliding off-topic, zenon.
03:08:39 <_zenon_> quicksilver: Yeah, let's talk haskell instead
03:08:42 <_zenon_> lambda
03:08:44 <_Dae_> JafaCake: church of emacs, probably *grins* Doesn't matter, let's change topic
03:08:46 <_zenon_> there we go
03:08:56 * quicksilver hands JafaCake a spare 'f'.
03:09:00 <_zenon_> lambda is great, don't you think?
03:09:17 <mauke> lambda is so 20th century
03:09:22 <mauke> I use kappa
03:09:43 <_Dae_> Actually.... (warning: radical statement comming) I dont find it that useful
03:09:52 <hpaste>  Saul pasted "Pattern Signatures" at http://hpaste.org/8865
03:10:04 <JafaCake> _Dae_: I mean, of the Alonzo variety
03:10:12 <Saul> Can anyone help me with the problem I just pasted?
03:10:18 <_zenon_> Church rocks........
03:10:23 <_zenon_> ;)
03:10:44 <_zenon_> Like, who doesn't like the church numerals?
03:11:00 <_Dae_> JafaCake: as in Don Quixote?
03:11:09 <JaffaCake> quicksilver: thanks :)
03:11:18 <_Dae_> Saul:  what's the problem?
03:11:36 <quicksilver> Saul: I don't really understand the problem; it's OK to leave 'a' as a free type variable
03:11:42 <quicksilver> it will be determined by the enclosing context.
03:11:54 <Saul> No it won't
03:12:07 <quicksilver> heh. That's a very negative response.
03:12:15 <quicksilver> Actually I can assure you it will :P
03:12:19 <quicksilver> but maybe it's not what you wanted?
03:12:19 <Saul> Since I use the function structure to determine the table name
03:12:32 <Saul> and there I get an ambiguity error
03:12:48 <quicksilver> what's the type of "structure" ?
03:12:54 <Saul> since it's just a string and it's not bound to the output directly
03:13:00 <Saul> Structure a
03:13:12 <quicksilver> well you can annotate it to Structure a
03:13:16 <Saul> well, (WikiEntity a) => Structure a
03:13:19 <quicksilver> just like you did in the first function
03:13:26 <quicksilver> (assuming you have scoped type vars on)
03:13:29 <Saul> Yeah but then a won't be in scope
03:13:43 <quicksilver> it will be with scoped type vars on
03:13:50 <Saul> I have pattern signatures
03:13:56 <Saul> I thought that was the same
03:14:11 <Saul> I assume the flag is -XScopeTypeVariables?
03:14:14 <mauke> pattern signatures let you put type annotations in patterns
03:14:34 <quicksilver> ScopedTypeVariables (with a 'd')
03:14:47 <quicksilver> and you will need to add some 'foralls' to the function types
03:14:48 <Saul> ok I'll try it out
03:14:56 <quicksilver> that's the keyword which turns on the scoping
03:15:03 <quicksilver> forall a . (WikiEntity a) => String -> WCGI [Ref a]
03:15:04 <quicksilver> I think
03:15:28 <Saul> I need to explicitly use forall?
03:16:19 <Saul> Wow that worked :)
03:16:32 <Saul> the forall is required
03:16:39 <quicksilver> yeah.
03:16:51 <quicksilver> backward compatibility, I guess.
03:17:02 <_Dae_> I'm curious btw..... most of us are on here quite a lot.... what are people doing that allow them to be roaming IRC all day?
03:17:17 <quicksilver> well, as a bot I don't really have much else to do.
03:17:41 <_Dae_> Right.... that makes sense
03:20:58 <ndmitchell> _Dae_: i'm a summer of code student, for haskell
03:21:23 <_Dae_> ndmitchell: Ohh, lucky bastard ;)
03:21:38 <Saul> Well it's working like a charm now, thanks for your help quicksilver
03:22:05 <Saul> I also did away with a bunch of pattern signatures that were superflous
03:22:42 <Saul> _Dae_: I'm coding a website during my vacation from uni
03:23:15 <quicksilver> Saul: yay ;)
03:23:27 <the_unmaker> wow
03:23:54 <Saul> superfluous even
03:24:11 <the_unmaker> I never knew that the guy who invented doctor strange and spiderman, Ditko, had an objectivist character the question in an old comic.
03:24:33 <_Dae_> Saul: coding a website in haskell? that gets points for awesomeness
03:24:34 <mauke> the_unmaker: how is this related to #haskell?
03:24:50 <Saul> _Dae_: Yeah I really wanted to try it
03:25:02 <Saul> I thought it would be a pain but it really isn't
03:25:14 <_Dae_> Saul: so... you have a haskell program generating the html code?
03:25:42 <Saul> I made a first go over the weekend, ran into a bunch of stuff I didn't handle elegantly and am now doing a full refactoring
03:26:03 <opqdonut> _Dae_: i'm a research assistant :)
03:26:17 <opqdonut> should really be writing latex and approximating combinatoric stuff
03:26:29 <opqdonut> but there's always time for IRC and reddit!
03:26:41 <Saul> _Dae_: Not really, I still write the html myself (using the Text.XHtml.Strict library)
03:26:50 * quicksilver hands opqdonut a combinatorial approximation to reddit.
03:27:00 <_Dae_> opqdonut: sounds like the right atitude ;)
03:27:05 <Saul> _Dae_: I am making a wiki site with structured pages
03:27:08 <quicksilver> Saul: did you look at StringTemplate. I haven't, but it's supposed to be nice :)
03:27:30 <opqdonut> quicksilver: heh :)
03:27:42 <Saul> quicksilver: I haven't, I might though, thanks for the suggestion
03:27:54 <Saul> The Html part isn't the problem though
03:28:15 <quicksilver> Saul: no, but it's always fun to see interesting solutions to things which aren't problems :)
03:28:16 <plutonas> is there a way to say if a then b c else d (that is in the then case execute two things
03:28:24 <quicksilver> Saul: I find it a great way to while away the hours.
03:28:34 <quicksilver> plutonas: yes of course
03:28:44 <quicksilver> plutonas: any where there is an expression you can have a do block
03:28:52 <quicksilver> if a then do { b ; c } else d
03:28:53 <plutonas> oh like { b c}
03:28:58 <quicksilver> or, simple if a then b >> c else d
03:29:05 <Saul> But basically I have a couple of types, and each type has enough info to make a form for adding them and editing them, and putting and retrieving from a database
03:29:09 <plutonas> i see... indentation wouldn't work?
03:29:15 <quicksilver> it's important to realise that b, c, b >> c and do {b;c} are all expressions.
03:29:20 <quicksilver> Yes, indentation would work fine
03:29:22 <Saul> and then stuff like history is free
03:29:25 <quicksilver> I just use the short form in IRC :)
03:29:30 <plutonas> indentation seems to not do
03:29:38 <quicksilver> well you probably got it slightly wrong :)
03:29:41 <_Dae_> plutonas: you still ave to use do
03:29:42 <quicksilver> paste?
03:29:58 <Saul> quicksilver: Yeah whiling away the hours isn't the problem at the moment
03:30:55 <plutonas> hm, can i also use that in a case i have a function like f x | x == 5 = {b ; c} | otherwise d?
03:31:11 <quicksilver> plutonas: yes but you need the "do" :P
03:31:21 <quicksilver> plutonas: ANYWHERE you have an expression you can have a do expression.
03:31:31 <quicksilver> there is nothing special about "do" (apart from the way it does indentation)
03:31:37 <plutonas> oh i see thanks
03:31:40 <quicksilver> it's just one of the tools you have to build expressions.
03:31:58 <quicksilver> you can for example nest do expressions, like do { do { a ; b } ; c }
03:32:00 <quicksilver> this is pointless :)
03:32:12 <quicksilver> I just make the point as an example : you can put 'do' anywhere you have an expression.
03:32:48 <quicksilver> "do { a ; b }" and "a + b" are both the same kind of thing, for haskell. They're both expressions.
03:32:56 <plutonas> quicksilver: but is it expecting type Bool?
03:33:03 <quicksilver> well yes, you need the types to match.
03:33:23 <quicksilver> so you probably can't put a "do" block in the condition part of the if
03:33:30 <quicksilver> unless you found a way to make Bool a monad.
03:33:40 <plutonas> well thats too advanced for me
03:33:46 <quicksilver> the type system makes restrictions, sure.
03:33:51 <plutonas> i want to execute two things and return the second
03:33:57 <quicksilver> You can put a "do" anywhere you have an expression : but your types must match.
03:34:11 <quicksilver> if a then do {b ; c} else d
03:34:13 <quicksilver> is fine
03:34:17 <quicksilver> but the types must be right!
03:34:23 <plutonas> wait i'll make a paste
03:34:24 <quicksilver> "a" must be Bool.
03:34:32 <quicksilver> b and c must be from some monad.
03:34:37 <quicksilver> d must be from the same monad.
03:34:42 <quicksilver> then the whole expression is in that monad.
03:34:57 <quicksilver> (and 'c' and 'd' must also return the same type)
03:35:05 <hpaste>  plutonas pasted "(no title)" at http://hpaste.org/8866
03:35:34 <plutonas> take a look, both expressions have the same right type, but none of them is Bool
03:35:53 <mauke> what is mmap?
03:36:25 <plutonas> it calls something for a value inside a Maybe
03:36:40 <mauke> but it doesn't do anything
03:36:52 <plutonas> for example mmap (y:) (Just [a]) = Just y:[a]
03:37:08 <mauke> oh, it's fmap
03:37:32 <mauke> plutonas: your code doesn't make sense
03:37:33 <quicksilver> plutonas: well mmap doesn't "do anything"
03:37:39 <quicksilver> plutonas: so it's weird to have it inside a do block.
03:37:53 <mauke> you don't want to execute two things and return the second
03:38:02 <quicksilver> plutonas: what are you expecting to do with the result of the mmap.
03:38:07 <mauke> because the first one is just a value and "executing" it doesn't mean anything
03:38:09 <_Dae_> plutonas: mathc is not of type bool, how can you use it in an "if"?
03:38:38 <plutonas> mauke: i want to update acc, and then recurse appropriately
03:38:55 <plutonas> _Dae_: you're right
03:38:57 <mauke> you can't update acc
03:39:04 <plutonas> quicksilver: return it in the end
03:39:10 <mauke> variables don't change
03:39:40 <plutonas> hm
03:40:15 <quicksilver> if you want to return it in the end, you probably want to save the value
03:40:31 <quicksilver> like let foo = mmap (y:) acc in .... (eventually return doo)
03:40:39 <quicksilver> however, as mauke says, variables don't change
03:40:44 <quicksilver> so perhaps you have a design flaw here ;)
03:40:57 <plutonas> actually what i want to do is give a wildcard as an argument, and then two strings, like "pluto*s" "plutonas" and then it should return Just "na"
03:41:05 <_Dae_> quicksilver: are they in fact variables if they do not vary?
03:41:10 <plutonas> if they don't match, it should return Nothing
03:41:16 <quicksilver> _Dae_: this is an amusing point.
03:41:27 <quicksilver> _Dae_: yes, because they vary over separate invocations of the function.
03:41:29 <plutonas> but how can i keep and update the matching characters list?
03:41:31 <quicksilver> _Dae_: is one answer.
03:41:44 <quicksilver> _Dae_: (another answer is to say that this is a formal notation of variable)
03:42:03 <quicksilver> plutonas: you don't "update" so much as "gradually build"
03:42:16 <quicksilver> rather than updating an exist list, you incrementally build the match list
03:42:29 <quicksilver> that's the typical functional style.
03:42:58 <plutonas> quicksilver: i know, but i don't know if i want to call match a xs .. or match a (x:xs) ..
03:43:11 <plutonas> to concatenate the result, as one of them, or maybe both will return Nothing
03:43:28 <quicksilver> often you define a function in terms of another one
03:43:35 <quicksilver> the 'worker' function has a more complex return type
03:43:42 <quicksilver> (building up list in progress or something)
03:43:52 <quicksilver> and when it's finished, you only return to the user what they actually wanted.
03:43:54 <plutonas> hm
03:44:57 <quicksilver> suppose I have foo :: Int -> Int, but foo works over a list internall. Then probably foo i calls foo_aux i []; foo_aux takes and return a list doing its job, then in then end foo throws away the list (it's not needed any more) and just returns the answer.
03:45:11 <quicksilver> I don't think it's easy to explain this idea in the abstract. It's quite obvious when you see it in practice.
03:45:46 <plutonas> no i think i know what you mean, i'm just thinking on how to make it in my case
03:45:55 <plutonas> as recursion gets involved
03:50:24 <the_unmaker> anyone here got happs running?
03:50:34 <the_unmaker> I did the darcs and now it wont start
03:50:38 <the_unmaker> sp ghc -isrc src/Main.hs --make --run --http-port=5000
03:50:46 <the_unmaker> my system doesn't reconize 'sp'
03:50:52 <the_unmaker> http://happs.org/
03:50:53 <lambdabot> Title: HAppS  The Haskell Application Server
03:50:56 <Lemmih> the_unmaker: 'sp' is searchpath.
03:51:09 <hpaste>  _Dae_ pasted "is this what you want plutonas?" at http://hpaste.org/8867
03:51:21 <the_unmaker> oh?
03:51:34 <Lemmih> the_unmaker: There's a link to it in the dependencies. Also, we have a specific channel for happs issues: #happs.
03:51:43 <the_unmaker> ya no one awake
03:52:28 <_Dae_> plutonas: was that what you wanted?
03:53:36 <RayNbow> augustss, could you explain your comment @ http://www.reddit.com/r/programming/info/6r0r7/comments/c04n215 ?
03:53:36 <lambdabot> Title: programming: Recursion Fail (or, use higher order functions)
03:54:06 <plutonas> _Dae_: just a second
03:54:37 <dolio> RayNbow: The version that uses foldr rebuilds the list at any particular level.
03:54:54 <plutonas> _Dae_: just got it in another way, but want to read yours too, it probably is better
03:55:05 <plutonas> but i'll also paste mine
03:55:27 <_Dae_> plutonas: actually... wait...mine doesn't work if the * is at the end of the word....
03:56:01 <RayNbow> dolio: ah, right... but is there a way to prevent rebuilding the list?
03:56:35 <dolio> Not when defining it with foldr, at least.
03:56:51 <hpaste>  plutonas pasted "this one works" at http://hpaste.org/8868
03:57:56 <FordCortina> I'm having difficulty understanding the constraints enforced by multi param type classes. What's the difference between baz :: Foo z x => x -> z x and bar :: Foo z x => a -> z a ?
03:58:40 <plutonas> _Dae_: mine works except in the case when there are more wildcards, where i'm supposed to return the first match only, i return a concatenation of both
03:58:44 <plutonas> (or more)
03:59:10 <dolio> What's the difference between baz :: Foo f => a -> f a and bar :: Foo f => a -> g a?
03:59:13 <plutonas> i don't understand why you reverse
03:59:28 <the_unmaker> do I have to learn regular expressions to do pattern matching in haskell or in general?
03:59:50 <_Dae_> plutonas: because I want the end of the list as well?
04:00:03 <_Dae_> plutonas: yours seem a bit confusing to me tbh....
04:00:22 <plutonas> _Dae_: so does yours to me :)
04:00:28 <FordCortina> dolio: the restriction in your bar function is redundant, it doesnt do anything...
04:00:43 <dolio> Sure.
04:01:18 <FordCortina> dolio: so are you saying that the restriction in my bar function is also redundant?
04:01:42 <dolio> No, but the type of a is independent of the typeclass constraint there.
04:02:14 <quicksilver> the_unmaker: no, haskell pattern matching is not like regexps.
04:02:14 <dolio> It still constrains z, though.
04:02:42 <the_unmaker> thank lord poseidon!!
04:02:53 <the_unmaker> I might learn haskell just to avoid regexxes
04:03:18 <matthew-_> there are regex libraries in haskell
04:03:27 <FordCortina> dolio: the reason i ask is because i see code like this in the Agda project: chainr1 :: Parser p tok => p a -> p (a -> a -> a) -> p a
04:03:35 <plutonas> _Dae_: so once you find the first match, you reverse both lists and check them again, and then once you find the next match in the other direction you say that what is left in x:xs is the matching in reverse order, right?
04:03:38 <_Dae_> plutonas: heh, that's amusing ;) I think I get what yours is doing now. not quite sure I like the elegance of it, but both our implementations will have problems with large strings
04:03:47 <FordCortina> so is "p a" a Parser or what?
04:03:48 <_Dae_> plutonas: yes
04:04:17 <plutonas> hm, _Dae_ give me an example string to test
04:04:28 <dolio> FordCortina: Probably. And I suspect there's a functional dependency 'p -> tok', so that the latter is fully determined by the former.
04:04:49 <FordCortina> dolio: yes there is a functional dependency
04:04:54 <plutonas> i found that there are problems in cases like this for mine: match '*' "* and *" "you and me"
04:05:00 <_Dae_> plutonas: take (1e8) (repeat 'a')
04:05:06 <FordCortina> there is such* a functional dependency
04:05:10 <plutonas> where i get "youme" instead of "you"
04:05:59 <_Dae_> plutonas: ohh, you want more than one * ?
04:06:31 <plutonas> _Dae_: i want more to match, but return only the first match, [] if there is no * and strings match, or Nothing if they don't match
04:06:41 <hackage> Uploaded to hackage: Takusen 0.8.3
04:06:55 <plutonas> but you are right about the large strings
04:07:51 <opqdonut> fundeps can be represented with associated types right?
04:07:51 <plutonas> but i don't see why from the error
04:08:41 <shapr> @users
04:08:41 <lambdabot> Maximum users seen in #haskell: 460, currently: 433 (94.1%), active: 17 (3.9%)
04:09:21 <_Dae_> plutonas: Stack overflow I should think?
04:09:44 <shapr> @usÃ¥rs
04:09:44 <lambdabot> Maximum users seen in #haskell: 460, currently: 433 (94.1%), active: 16 (3.7%)
04:10:23 <plutonas> _Dae_: hm, yes, shouldn't be a problem though as I don't think I'd never need more than lets say 100
04:12:18 <_Dae_> plutonas: ok, just note that your implementation spawns a new computation quite often, which could be a performance problem
04:12:52 <plutonas> _Dae_: you mean the computation of orElse?
04:13:03 <_Dae_> plutonas: exactly
04:13:43 <plutonas> hm, that gets called only m times, where m is the length of the returning string
04:14:05 <plutonas> O(m)
04:14:44 <plutonas> (i think)
04:15:20 <_Dae_> plutonas: yeah, sorry, my bad... I thought it was going to be O(2^(m))
04:15:40 <_Dae_> plutonas: you should make it tail recursive though
04:15:57 <plutonas> _Dae_: actually this whole line looks like beeing O(nm) where m is what before and n is the length of the beginning strings
04:16:20 <_Dae_> plutonas: No, only O(n) I believe
04:16:41 <quicksilver> where is your latest version, plutonas?
04:16:56 <_Dae_> quicksilver: http://hpaste.org/8868
04:17:21 <plutonas> but if we have pl*s and then plaaa....aaas then * will match to aaa...aaa, and each time it will first check if the rest matches
04:18:09 <plutonas> anyway it's not so important, but I just noticed that take 1e8 (repeat 'a') has a problem too
04:18:18 <plutonas> because it transforms 1e8 to 1.0e8
04:19:00 <_Dae_> plutonas: ok, take 100000000 (repeat 'a') then ;)
04:19:55 <EvilTerran> ?hoogle ==>
04:19:56 <lambdabot> Test.QuickCheck.(==>) :: Testable a => Bool -> a -> Property
04:20:54 <plutonas> yeap stack overflow
04:22:14 <plutonas> _Dae_: how do i make it tail recursive? by changing the order of the first two clauses of the function?
04:22:20 <plutonas> because otherwise i guess should be last
04:23:24 <plutonas> hm, nope i think it's not possible to make it tail-recursive
04:23:29 <quicksilver> it's quite a tricky one to make tail recursive
04:23:33 <quicksilver> I was pondering that myself.
04:23:39 <plutonas> (the way i've written it)
04:23:55 <quicksilver> you'll need to transform the list-so-far into an accumulating parameter
04:24:01 <plutonas> yeap, i think it'll stay like that, as it's to match human sentences, shoud be enough
04:24:03 <quicksilver> instead of building up a thunk of 'mmap' s
04:24:23 <quicksilver> I think your way is fine ;)
04:24:38 <plutonas> my only problem is to match only the first * if there are more... but will have to think about it first before perhaps asking questions
04:26:37 <_Dae_> plutonas: you could keep a boolean along, making it stop when it hits the second?
04:31:28 <plutonas> _Dae_: yes maybe but it'll be tricky, because one * may be read multiple times
04:32:18 <matthew-_> if you compile -fasm, exactly what asm does it produce?
04:32:21 <_Dae_> plutonas: No, you only set the boolean in the implementation where you don't send the * along
04:32:39 <matthew-_> generic i386? or does it use cpu specific instructions?
04:33:21 <plutonas> _Dae_: by the way now that i think of it, how do i set a Boolean If i can't change it?
04:34:03 <plutonas> i mean the idea would be to have it to false, when it sees a * it checks if its false and matches it, and changes the boolean to true, otherwise it continues matching without accumulating
04:34:06 <plutonas> but...
04:34:25 <_Dae_> plutonas: (orElse (match a xs ys True ) (match a (x:xs) ys False))
04:39:49 <plutonas> i'm not sure i want to add more arguments to the function... but i'll find a solution
04:42:49 <_Dae_> plutonas: you hide the extra arguments, so "match a ys xs = internalMatch a ys xs False"
04:42:58 <jacobian> is there a simple way to do "tabling" in parsec
04:43:09 <jacobian> such that I can express left-recursive grammars and not get non-termination
04:44:00 <plutonas> _Dae_: i see, thanks
04:58:25 <Lemmih> Underscore overflow.
04:59:57 <opqdonut> :)
05:00:07 <quicksilver> jacobian: well, parsec contains combinators for the most common forms of left-recurision.
05:00:12 <quicksilver> jacobian: many, manyTill, etc.
05:01:54 <mauke> preflex: nickr dcoutts__
05:01:54 <preflex>  dcoutt_s_
05:08:55 <ttt--> how is something like "let x = 3" in ghci done in a functional way?
05:09:05 <mjk> i plan to learn haskell network programming, where is good tutorial? is import Network
05:10:21 <mauke> ttt--: in the usual way
05:10:49 <vinicius> :t (+).(*)
05:10:51 <lambdabot> forall a. (Num a, Num (a -> a)) => a -> (a -> a) -> a -> a
05:11:43 <dcoutts> Lemmih: heh :-)
05:11:46 <ttt--> mauke: do you mean the usual let? because it remembers the value for x
05:11:51 <telemach> mOOh.
05:11:53 <mauke> so does let
05:12:07 <mauke> or what are you asking here?
05:12:19 <_Dae_> telemach: wrong channel. Not quite sure if there is a #moo channel though....
05:12:27 <telemach> :)
05:12:59 <telemach> is anyone into numerical stuff here?
05:13:21 <ttt--> sorry, im a noob
05:13:40 <ttt--> is there something else in haskell code beside let .. in ?
05:13:56 <telemach> i'm planning to write write some kind of mathematica clone, but just for numerical calculations.
05:14:25 <FordCortina> the difference between chainr1 :: Parser p tok => p tok -> p (tok -> tok -> tok) -> p tok and chainr1' :: Parser p tok => p a -> p (a -> a -> a) -> p a, is that we are allowing the token types to vary?
05:14:35 <telemach> ttt: ... where ... maybe?
05:14:36 <FordCortina> vary in prime i mean...
05:15:03 <FordCortina> that's probably not it
05:15:05 <_Dae_> telemach: Numerical stuff? Well...yes... it's -all- I've done in haskell ;)
05:15:35 <FordCortina> but p is restricted differently in chainr' than in chainr
05:15:35 <vinicius> ttt--: mm... are you asking how to keep state in haskell?
05:15:46 <vinicius> fsvo "keep state"
05:15:55 <_Dae_> telemach: and haskell really needs a decent math library.... not quite sure if you want to copy mathematica or matlab though
05:16:22 <ttt--> no, i'm asking how the "let" in ghci is implemented (i only know let.. in)
05:16:31 <mwc> ttt--: it's monadic let
05:17:16 <mwc> you can think of the ghci prompt as living inside a do block of an io monad. That's why you can sequence IO actions there
05:17:28 <mwc> _Dae_: we have BLAS bindings now, it's a start
05:18:03 <_Dae_> mwc: yeah.... I'm not quite sure I like it though....
05:19:36 <mwc> yeah, it's ugly eh? I've been meaning to see what I can knock together along the lines of Blitz++ in Haskell. Expression templates are used in that lib to deforest temporary values. Lambdas + Lazyness should do similar
05:20:12 <_Dae_> mwc: heh, been meaning to do something similar as it happens
05:24:28 <ttt--> how is let a monad?
05:25:52 <vinicius> is there are a pretty arrow command in lambda bot?
05:26:16 <ttt--> i was just wondering if you would write all the things you type into ghci, and write them as a normal function. how would that work
05:26:29 <vinicius> @pa \x y z-> (x+y)*z
05:26:29 <lambdabot> Maybe you meant: palomer part paste pl
05:26:39 <Cale> ttt--: They were referring to the fact that the 'let' in ghci mimics the let in the do-syntax
05:27:09 <vinicius> -are
05:27:11 <ttt--> it would be a function that has  "show 3" and "let x = 3", how would that work?
05:27:17 <ttt--> ok i see
05:27:51 <Cale> (not that it really has anything to do with monads)
05:28:22 <ttt--> i mean: you could do it by nesting all the lets.
05:29:06 <ttt--> or by passing an environment that holds the variables?
05:30:03 <ziman> afaik, in do-notation `let x; ...' desugars to `let x in ...'
05:30:14 <rwbarton> ttt--: the 'let' in ghci is just like the 'let' in ...
05:30:22 <rwbarton> > do { let x = 3; return x } :: [Integer]
05:30:23 <lambdabot>  Parse error at "}" (column 26)
05:30:30 <rwbarton> > do let x = 3; return x  :: [Integer]
05:30:31 <lambdabot>  Parse error at "::" (column 25)
05:30:36 <rwbarton> Well you get the idea
05:30:41 <mauke> > do let {x = 3}; return x :: [Integer]
05:30:42 <lambdabot>  [3]
05:31:24 <ttt--> so if you typed  "let x = 3" "let y = 3" "show 3". it would be  "let x = 3 in ( let y = 3 in ( show 3 )) "
05:36:30 <ttt--> > do let{x = 3}; let{ y = 4}; show 3
05:36:31 <lambdabot>  "3"
05:37:27 <quicksilver> well there is something slightly weird about that example.
05:37:34 <quicksilver> it only works because [] happens to be a monad.
05:38:11 <ttt--> how do you mean?
05:38:43 <quicksilver> it's a do block, so it has to be a monad
05:38:55 <quicksilver> by a coincidence [] happens to be a monad
05:39:00 <quicksilver> and show 3 is a String which is [Char[
05:39:03 <rwbarton> I believe what's really going on in ghci is that if you enter an expression of type not of the form IO a, then it runs the action "print ..." instead
05:39:17 <quicksilver> yes.
05:40:07 <rwbarton> so your example should be
05:40:17 <rwbarton> > do let{x = 3}; let{ y = 4}; print (show 3)
05:40:19 <lambdabot>  <IO ()>
05:40:23 <quicksilver> right.
05:44:18 <ttt--> do the let's in that expression have type IO too?
05:44:35 <ttt--> does the variable binding happen with IO?
05:45:18 <mauke> no and no
05:45:30 <mauke> @undo do let{x = 3}; let{ y = 4}; print (show 3)
05:45:30 <lambdabot> let { x = 3} in let { y = 4} in print (show 3)
05:47:58 <ttt--> the let (without in) can only be used in do-blocks and always gets translated like that?
05:48:05 <mauke> yes
05:48:09 <ttt--> ok thanks
05:48:18 <ttt--> i think i understand now
05:48:35 <quicksilver> it's just a convenient shorthand
05:48:46 <quicksilver> (well that's true of everything abotu do blocks, of course)
05:49:03 <quicksilver> it's some times convenient to name intermediate pure calculations in the middle of a do block
06:00:49 <gwern> icfp starts today, right?
06:01:52 <rwbarton> yes
06:02:17 <gwern> wonder what crazy data structure will be needed this year
06:03:42 * gwern roots for bloom filters or zippers. cuz I'm lazy and don't want to implement anything myself
06:04:37 <Igloo> :-)
06:06:53 * osfameron notes that he'll be in a train for 2 hours at the time the rules are posted, in first class for a change.  Good environment to start on the contest
06:07:08 <osfameron> except dunno if the rules will be easy to interpret over a mobile phone browser
06:08:59 <gwern> "This is a list of sha-512 hashes of each page of the rule. Good luck."
06:09:16 <gwern> *rules
06:09:20 <saml> what are cool and fundamental expressions (probably lambda expressions) to put on t-shirt?
06:09:30 <quicksilver> (\x . x x) (\x . x x)
06:10:15 <osfameron> huh?
06:10:24 <saml> that's a good one.
06:10:25 <osfameron> where's the -> ?
06:10:30 <quicksilver> the . is a ->
06:10:40 <osfameron> is it?
06:10:42 <quicksilver> it's not haskell, since it doesn't type.
06:10:45 <quicksilver> yes
06:10:56 <quicksilver> traditional maths notation is lambda X dot X X
06:11:04 <saml> is there a one combinator system that is turing complete?
06:11:10 <mauke> Î»x.xx
06:11:13 <mauke> saml: yes
06:11:22 <quicksilver> there are many!
06:11:28 <quicksilver> (such systems)
06:11:49 <osfameron> what does Lx.xx do?
06:12:06 <mauke> apples a function to itself
06:12:10 <ddarius> saml: Be different, put the rules of the sigma calculus on your shirt.
06:12:11 <quicksilver> osfameron: takes a function x and applies it to itself.
06:12:20 <quicksilver> saml: SKI is probably the most famous.
06:12:23 <osfameron> so for making monstrosities with fix?
06:12:34 <SamB_XP> quicksilver: ski is three-combinator
06:12:51 <quicksilver> ah. I mis-parsed saml.
06:13:00 <quicksilver> I thought he was saying one system, not one combinator.
06:13:46 <wjt> IIRC there's a combinator from which you can construct S and K, so yes, there is a one-combinator system
06:14:01 <quicksilver> osfameron: yes, (\x . x x) (\x . x x) is closely connected to fix. It is an interesting observation than in a typed calculus you need fix (or recursion) as a primitive, but in an untyped system you can write it elementarily.
06:14:03 <mauke> http://barker.linguistics.fas.nyu.edu/Stuff/Iota/
06:14:15 <SamB_XP> wjt: indeed
06:14:34 <wjt> that's the badger
06:14:39 <mauke> http://en.wikipedia.org/wiki/Combinatory_logic#One-point_basis
06:14:40 <lambdabot> Title: Combinatory logic - Wikipedia, the free encyclopedia
06:15:14 <saml> my tshirt is now universal.
06:15:20 <gwern> sigma calculus? that's a new one on me. (wikipedia doesn't even have an article on it)
06:15:32 <gwern> saml: your tshirt has unbounded space? :)
06:17:25 <osfameron> quicksilver: that doesn't explain why the y-combinator is so complex and haskell definition of "fix" is so simple (to look at, not to understand, well, leastways not for me)
06:17:46 <osfameron> where y-combinator is untyped and haskell is typed, I mean
06:18:03 <mauke> fix is simple because haskell has recursion built in
06:19:26 <Igloo> gwern: FYI: This proposal seems to be abandoned
06:19:30 <osfameron> not just recursion.  laziness too
06:19:31 <Igloo> Doh
06:19:37 <Igloo> gwern: http://hackage.haskell.org/trac/ghc/ticket/2048
06:19:40 <lambdabot> Title: #2048 (Add split and splitWith to Data.List) - GHC - Trac
06:19:41 <osfameron> perl has recursion, but I don't think you can implement fix in it that simply
06:19:54 <osfameron> oh, maybe with Scalar::Defer / Data::Thunk whatever
06:20:08 <mauke> sure you can, just not for data
06:20:21 <quicksilver> @src fix
06:20:21 <lambdabot> fix f = let x = f x in x
06:20:43 <quicksilver> this doesnt use laziness, per se.
06:20:46 <mauke> sub fix (&) { my $f = shift; sub { $f->(&fix($f), @_) } }  # curried fix
06:20:51 <quicksilver> but it uses value recurision in 'x'.
06:20:58 <quicksilver> perl doesn't have value recursion
06:21:03 <quicksilver> only function recursion.
06:21:08 <quicksilver> if you restrict to functions, you're fine.
06:22:04 <_zenon_> <_zenon_> woho... just 1 hour left!
06:22:04 <_zenon_> <AlexC_> backslash7, $key is a string, it's not the same as doing $_POST[foo]
06:22:04 <_zenon_> <_zenon_> then I'm going home for some haskell
06:22:04 <_zenon_> <_zenon_> oops
06:22:04 <_zenon_> <_zenon_> wrong channel :)
06:22:14 <_zenon_> hehe, in the #php
06:24:00 <saml> > let y f = f (y f) in y (\fac n -> if n <= 1 then 1 else n * fac (n - 1)) 10
06:24:03 <lambdabot>  3628800
06:24:23 <_zenon_> @pl let y f = f (y f) in y (\fac n -> if n <= 1 then 1 else n * fac (n - 1)) 10
06:24:23 <lambdabot> fix (ap id) (ap (flip if' 1 . (<= 1)) . ap (*) . (. subtract 1)) 10
06:24:39 <saml> oh it's still using value recursion on f
06:25:08 <_zenon_> ?ty fix
06:25:09 <lambdabot> forall a. (a -> a) -> a
06:25:14 <mauke> hmm, we should get buubot in here so we can eval perl
06:25:22 <_zenon_> no way
06:25:49 <_zenon_> read: no way! (like in questioning)
06:25:54 <_zenon_> no way?!
06:26:14 <osfameron> mauke, quicksilver: ok... I must look at fix again I suppose
06:27:24 <quicksilver> it's true that value recursion appears to only make sense given laziness.
06:27:30 <quicksilver> but they're not precisely the same thing :)
06:27:39 <SamB_XP> @pl let y f = f (y f) in y
06:27:39 <lambdabot> fix (ap id)
06:28:12 <mauke> perl -wle 'sub fix (&) { my $f = shift; sub { $f->(&fix($f), @_) } }  print for fix { my ($self, $n) = @_; $n < 2 ? 1 : $n * $self->($n - 1) }->(5)'
06:29:17 <_zenon_> mauke: You really really really like perl
06:29:27 <mauke> what
06:29:46 <_zenon_> you like pearl?
06:29:58 <_zenon_> http://otierney.net/images/perl6.gif
06:29:59 <_zenon_> hahaha
06:30:03 <_zenon_> what does haskell look like?
06:30:33 <quicksilver> I think it's more accurate to say mauke is very knowledgeable about perl.
06:30:43 <quicksilver> than that he really really really likes it.
06:31:03 <_zenon_> quicksilver: I though we only handed out half the truths :)
06:31:15 <pejo> Could someone point me to a definition of value recursion, or explain what it is?
06:31:32 <quicksilver> pejo: definition: value recursion is defining a value recursively.
06:31:41 <quicksilver> example: ones = 1 : ones
06:32:02 <mauke> struct node ones = { 1, &ones };
06:32:04 <_zenon_> pejo: then you can use lazyness for it
06:32:06 <pejo> quicksilver, oh, in that case you want to read http://www.unsafeperformio.com/papers/RecBinds-sub.pdf and the related work.
06:32:09 <lambdabot> Title: cache:http://www.unsafeperformio.com/papers/RecBinds-sub.pdf - Google Search
06:32:25 <quicksilver> most conventional languages only permit^Wexpect you to recurse in the definition of functions, not values themselves
06:32:26 <_zenon_> take 10 ones  (for quicksilvers definition of ones)
06:33:02 <quicksilver> as mauke accurately points out, C++ supports value recursion too :) not many people know that.
06:33:07 <quicksilver> (C as well?)
06:33:12 <quicksilver> certainly it's not often used.
06:33:13 <mauke> that was C
06:33:23 <mauke> (see "struct")
06:33:24 <pejo> quicksilver, why does it only make sense with laziness though?
06:33:39 <quicksilver> "appears to only make sense with laziness"
06:33:41 <quicksilver> is what I said.
06:33:42 <dmwit> C++ has struct
06:33:44 <mauke> it's not really value recursion
06:33:54 <mauke> dmwit: yeah, but C++ autotypedefs structs
06:34:01 <mauke> so you'd write 'node ones;'
06:34:14 <farhan_> FUCK YEAH TAIL RECURSION
06:34:35 <mauke> TUCK YEAH FAIL RECURSION
06:34:42 <mauke> > fix fail
06:34:43 <lambdabot>  ""
06:34:57 <farhan> :(
06:35:11 <pejo> quicksilver, true.
06:35:18 <mauke> > fix error
06:35:33 <lambdabot>  thread killed
06:35:49 <mauke> haskell doesn't let you fix errors
06:35:59 <_zenon_> fix fix
06:36:01 <_zenon_> > fix fix
06:36:02 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -> a
06:36:02 <lambdabot>     Probabl...
06:36:22 <mauke> don't fix it if it ain't broken
06:37:38 <_zenon_> ?ty fix
06:37:38 <lambdabot> forall a. (a -> a) -> a
06:38:02 <_zenon_> ?src fix
06:38:03 <lambdabot> fix f = let x = f x in x
06:38:46 <mjrosenb> :t fix (fix id)
06:38:48 <lambdabot> forall a. a
06:39:15 <mjrosenb> not like fix id had a different type
06:47:31 <_zenon_> what do you think about introducing haskell at junior level school ?
06:47:46 <gbacon> _zenon_: do it!
06:47:54 <_zenon_> not as programming per say, but the way of thinking
06:48:01 <_zenon_> the function paradigm
06:48:04 <_zenon_> functional
06:48:17 <gbacon> how would they learn it without doing it?
06:48:23 <_zenon_> lambda calculus and such
06:49:03 <SamB_XP> give them a library to make pretty pictures
06:49:04 <qwr> pure calculus is never same as programming
06:49:15 <_zenon_> http://worrydream.com/AlligatorEggs/
06:49:16 <lambdabot> Title: Alligator Eggs!
06:49:32 <_zenon_> Lambda calculus for children :)
06:50:08 <SamB_XP> just don't show them a lambda if you aren't going to let them loose on the computer... that's all I have to say...
06:50:27 <_zenon_> How come?
06:50:29 <smg> haskell i love you :)
06:50:47 <SamB_XP> it'll make them think lambda calculus is boring
06:50:58 <_zenon_> Ah.. I see, hmm... true true.
06:51:07 <_zenon_> Have you seen C-jump?
06:51:17 <_zenon_> http://www.c-jump.com/
06:51:19 <lambdabot> Title: c-jump: computer programming board game
06:51:42 <_zenon_> One could make the same thing,... a boardgame,  but with haskell :)
06:52:24 <_zenon_> http://haskell.org/pipermail/haskell-cafe/2008-March/040731.html
06:52:24 <lambdabot> Title: [Haskell-cafe] Haskell board game, anyone?
06:52:29 <_zenon_> I see it's already been taken up
06:52:52 <Vq^> what should that be about? unicycle cruising? :o)
06:53:59 <_zenon_> hmm.....
06:54:14 <_zenon_> I know! Making the type signatures match!
06:54:38 <_zenon_> You get figures with type sigs, and you have to put them together to make them match?
06:54:48 <_zenon_> Or something about transformers
06:54:57 <Japsu> lambda calculus for children is a good idea, after all the Enemy is going for the kids too
06:55:14 <Japsu> http://java.sun.com/new2java/learning/young_developers.jsp
06:55:52 <_zenon_> Japsu: Let's team up! Lock and load the lambda
06:55:57 <Japsu> :D
06:56:01 <Japsu> sorry, I'm working for the Enemy
06:56:07 <Japsu> MUHAHAHAHA
06:56:17 <_zenon_> fix Japsu
06:56:47 <Japsu> _zenon_: cannot construct the infinite type: a = a -> a
06:56:51 <Japsu> ^___^
06:56:57 <_zenon_> ><
06:57:31 <Japsu> no wait, not a -> a
06:57:48 <Japsu> :t fix Just
06:57:49 <lambdabot>     Occurs check: cannot construct the infinite type: a = Maybe a
06:57:49 <lambdabot>       Expected type: a -> a
06:57:49 <lambdabot>       Inferred type: a -> Maybe a
07:06:21 <SamB_XP> Japsu: I don't think the kids will really be interested in Java
07:06:26 <SamB_XP> so it's not a big deal...
07:08:26 <SamB_XP> http://users.bigpond.net.au/d.keenan/Lambda/
07:08:27 <lambdabot> Title: To Dissect a Mockingbird: A Graphical Notation for the Lambda Calculus with Anim ...
07:08:38 <SamB_XP> they can move on to that after the alligator game ;-P
07:10:12 <_zenon_> uhhmmm I really don't know it that made it easier :)
07:10:21 <_zenon_> hehe, I'll stay with the normal lambda notation :)
07:11:04 <the_edge> hello all, is there a way to get help on functions when using ghci? Like if I want help on the 'many' function, can I do something like 'help many'?
07:11:14 <_zenon_> I think all those boxes and lines make it more confusing (at least for me) and I know lambda calculus.
07:11:39 <_zenon_> the_edge:    :i many
07:11:49 <_zenon_> will give you the type signature
07:11:58 <_zenon_> and where it is defined
07:12:02 <Baughn> So will :t many. :i sometimes gives you more
07:12:03 <SamB_XP> okay, maybe not that then
07:12:08 <_zenon_> other than that, try hoogle
07:12:31 <_zenon_> But I like the spirit! We should enlighten the children
07:13:06 <the_edge> _zenon_: many thanks!
07:13:22 <_zenon_> the_edge: sure, no problem. #haskell at your service
07:13:36 <SamB_XP> I forgot how odd this notation was ;-)
07:15:03 <SamB_XP> failing that, we could just give them copies of Barendregt and Barendsen's introduction
07:15:36 <SamB_XP> the_edge: for more help, you can look at the haddock...
07:15:40 <SamB_XP> @doc Data.List
07:15:40 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
07:16:01 <SamB_XP> @doc Prelude
07:16:01 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
07:16:23 <the_edge> SamB_XP: thanks
07:17:03 <Baughn> @doc System.IO.UTF8
07:17:03 <lambdabot> System.IO.UTF8 not available
07:17:22 <the_edge> ooohhh hoogle is quite nice
07:17:38 <_zenon_> the_edge: indeed :)
07:17:38 <the_edge> that's exactly what I was looking for
07:18:43 <the_edge> thanks _zenon_ and SamB_XP, now back to learning Haskell, see ya :)
07:18:56 <_zenon_> the_edge: You would maybe also like this http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hoogle
07:19:00 <lambdabot> Title: HackageDB: hoogle-3.1
07:19:01 <_zenon_> the_edge: np
07:19:41 <Baughn> the_edge: The offline version zenon linked to has a considerably larger database. Or something like that.
07:19:45 <Baughn> (cabal install works)
07:20:34 <dcoutts> @yarr!
07:20:34 <lambdabot> Har de har har!
07:22:11 <Baughn> @garr
07:22:11 <lambdabot> Maybe you meant: arr yarr
07:23:20 <dcoutts> @seen Saizan
07:23:21 <lambdabot> Saizan is in #haskell-soc, #haskell-blah, #haskell-overflow, #haskell.it and #haskell. I last heard Saizan speak 6h 6m 22s ago.
07:26:18 <_zenon_> Actually, where is the documentation for that package?
07:26:20 <_zenon_> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hoogle
07:26:24 <lambdabot> Title: HackageDB: hoogle-3.1
07:27:06 <_zenon_> Other than here   http://www.haskell.org/haskellwiki/Hoogle
07:27:06 <lambdabot> Title: Hoogle - HaskellWiki
07:30:14 <Baughn> _zenon_: http://www.haskell.org/hoogle/
07:30:15 <lambdabot> Title: Hoogle
07:33:30 <_zenon_> time to go home
07:33:31 <_zenon_> cu
07:35:07 <monochrom> <3 rank-n types
07:36:58 <monochrom> And good morning.  Cf. Today's xkcd.com :)
07:44:58 <conal> @seen dcoutts
07:44:58 <lambdabot> dcoutts is in #gentoo-haskell, #haskell, #ghc, #haskell-overflow and #haskell-soc. I last heard dcoutts speak 21m 38s ago.
07:45:10 <dcoutts_> hia conal
07:47:14 <conal> dcoutts_: oh, hi
07:47:35 <conal> dcoutts_: i just realized that i asked for "Reactive" when i really wanted "reactive"
07:47:57 <conal> dcoutts_: on c.h.o.  would you mind renaming it for me?
07:48:19 <dcoutts_> conal: no problem
07:48:52 <conal> dcoutts_: great :)
07:51:11 <pflynn> I has anyone seen this link error when trying to build the 2.0.0 or the 2.1.0 versions of Haddock with the linux binary dist of GHC 6.8.2 "libHSghc.a(RTClosureInspect.o):In function `saHz_info' (.text+0xe416): undefined reference to `containerszm0zi1zi1_DataziSequence_a26_info'"
07:51:53 <dcoutts_> conal: done
07:52:34 <conal> dcoutts_: whee!  thanks a bunch
07:55:28 <plutonas> hello, i'm trying to write my own groupBy using fold, myGroupBy f xs = foldr step (last xs) xs
07:55:28 <plutonas>     where step y ys = (mytakeWhile (f y) ys) : [(dropWhile (f y) ys)]
07:55:32 <tunaka> Good morning all: I'm trying to do a "mod" operation using zipWidth, but get a type error i'm not sure how to deal with, see http://pastebin.com/d5a3c73c4 -- any thoughts?
07:55:46 <plutonas> of course the type is wrong, but i have no idea how to write it otherwise, does anyone?
07:57:13 <lilachaze> plutonas: presumably you want x `mod` y not x mod y
07:57:23 <lilachaze> tunaka: ^^ (sorry)
07:57:26 <plutonas> oh
07:57:30 <tunaka> it's `mod`?
07:57:40 <lilachaze> tunaka: if you want to use it infix, yes.
07:57:47 <lilachaze> tunaka: or "mod x y"
07:57:50 <plutonas> tunaka: it's either mod a b or a `mod` b
07:57:52 <Baughn> > mod 42 3
07:57:53 <lambdabot>  0
07:57:59 <Baughn> > 42 `mod` 3
07:58:00 <lambdabot>  0
07:58:03 <tunaka> lilachaze: OK, I get it.. thanks..
07:58:21 <lilachaze> > zipWith mod [1..9] [1..15]
07:58:23 <lambdabot>  [0,0,0,0,0,0,0,0,0]
07:58:43 <tunaka> I didn't know you needed infix (+ and - don't need it), but now it makes sense..
07:58:45 <lilachaze> tunaka: you don't need the take (length k) bit either; zipWith stops when either list runs out
07:59:08 <plutonas> what about plutonas :)
07:59:09 <rwbarton> (\x y -> x `mod` y)  is the same as just  mod
07:59:20 <Baughn> tunaka: Prefix is default for function names that start with letters; infix is default for symbols
07:59:30 <RayNbow> oh great, I broke WinHugs... :p
07:59:37 <Baughn> tunaka: You can turn symbol-named functions such as + into prefix functions by saying (+), too
07:59:48 <Baughn> > (+) 3 4 `mod` 5
07:59:49 <lambdabot>  2
08:00:00 <tunaka> okay, good..
08:00:06 <tunaka> I wish the compiler errors were more intelligible..
08:00:15 <tunaka> I thought I was sending the wrong type..
08:00:28 <tunaka> but then when I changed it to something like + it worked fine..
08:00:49 <tunaka> thanks
08:01:19 <rwbarton> tunaka: You'll generally get better error messages if you put type annotations on top-level declarations, like  testcombine :: [Int] -> [Int] -> [Int]
08:01:27 <rwbarton> tunaka: in this case it will only help a little
08:03:16 <lilachaze> tunaka: http://pastebin.com/m3ba39f0a
08:04:16 <tunaka> Yeah, i've got it all working now :-)
08:05:20 <rwbarton> It's hard for the compiler to give you a good error message, because your original testcombine actually does compile:
08:05:27 <rwbarton> @ty \f k = zipWith (\x y -> x mod y) k (take (length k) f)
08:05:28 <lambdabot> parse error on input `='
08:05:32 <rwbarton> @ty \f k -> zipWith (\x y -> x mod y) k (take (length k) f)
08:05:33 <lambdabot> forall b a c. (Integral a) => [b] -> [(a -> a -> a) -> b -> c] -> [c]
08:06:51 <dbueno> There's no way in cabal to only build one of the Executables in the .cabal file, but not the other, right?
08:07:41 <dcoutts_> dbueno: not really, the developer can mark an executable as not buildable, but as a user/packager you cannot easily do it, at least not without editing the .cabal file.
08:08:03 <dbueno> dcoutts_: Ah, well at least the buildable flag is only a one-line change.  Thanks.
08:08:11 <dcoutts_> dbueno: one day we'll have a make-like framework internally and that'll make it easy to specify particular targets
08:08:23 <dcoutts_> dbueno: how's the SAT stuff going?
08:08:37 <dbueno> dcoutts_: Slowly, unfortunately.  My masters project is eating up all my time.
08:08:38 <dcoutts_> dbueno: oh and have you seen http://www.edos-project.org/
08:08:41 <lambdabot> Title: XWiki - Main - EDOS - Environment for the development and Distribution of Open S ...
08:08:51 <dbueno> dcoutts_: Yes, I'm familiar with EDOS.
08:09:08 <dcoutts_> dbueno: heh, I wasn't though I really should have been :-)
08:09:19 <dcoutts_> they use SAT to find unbuildable packages
08:09:24 <dbueno> dcoutts_: There's some pretty neat stuff there.  But they don't have much in the way of practical tools, I think, yet.
08:09:43 <dcoutts_> right, I didn't see anything for actual package planning
08:09:45 <dcoutts_> just QA
08:09:58 <dbueno> dcoutts_: Right.  Repository evolution and all that.  And I'm all for that, too.
08:10:15 <dcoutts_> yeah, we should apply these things to hackage QA
08:10:38 <dbueno> dcoutts_: The nice thing is, once you have a way to describe the problems as SAT problems, all sorts of doors open.  That is one of them.
08:10:48 <dbueno> It'd be quite easy to make that sort of thing commonplace, once the framework is there.
08:11:00 <dcoutts_> dbueno: if we had a fast SAT based test for whether a package was buildable at all then that could be used as a gateway test to reject packages on upload
08:11:03 <dbueno> dcoutts_: I'm trying to be careful in the embedding of SAT to make it general enough to be reusable
08:11:08 <dcoutts_> right
08:11:25 <dcoutts_> and error messages start to become important too
08:11:46 <dcoutts_> because people will want to know why their package is rejected, what exactly made it unbuildable
08:11:50 <quicksilver> dcoutts_, dbueno : many algorithms which are hard in (say) C, suddenly become easy in a language with lists + good list combinators. I wonder if graphs/SAT and good combinators could provoke a similar revolution.
08:11:57 <quicksilver> (in program expressiveness)
08:12:31 <dbueno> dcoutts_: Indeed.  A while back I added unsatisfiable core generation to funsat --- this should generate minimal "reasons" for the rejection of a configuration.
08:12:39 <dbueno> dcoutts_: This is my core idea for better error messages.
08:12:43 <dcoutts_> right
08:13:04 <dcoutts_> sounds like a good approach
08:13:10 <dcoutts_> I've heard of similar things for CP
08:13:15 <dbueno> quicksilver: Most modern SAT solvers are written in C, so in that sense the techniques are well known and the work is done.
08:13:49 <pyNem> i program in python often, and am fairly comfy with a little scheme .. have been finding haskell very difficult .. been through the usual yaht tuts .. etc.. does anyone know a good tut? (And is there a ghc addon for vim ?)
08:13:51 <dcoutts_> quicksilver: but you probably mean combinators for easily expressing problems in terms of SAT/CP
08:13:56 <dbueno> quicksilver, however, ever since I saw Oleg et. al's "Backtracking, Interleaving, and Terminating Monad Transformers" I've had my eye on such an approach.
08:14:28 <quicksilver> dcoutts_: yes, that is indeed what I mean.
08:14:49 <dcoutts_> quicksilver: it does seem to be the hard part of SAT/CP atm
08:14:49 <dbueno> quicksilver: It would potentially make for a much more obviously correct implementation.  Only in the last few years (!) have people figured out how to properly test SAT solver (e.g. how do you test if an "unsatisfiable" formula is indeed unsatisfiable)?
08:14:52 <quicksilver> dcoutts_: I know the techniques are well known (in certain fields); my hope is that if they become more generally availble...
08:15:01 <eck> everyone: i expect to see some good icfp entries from the haskell camp
08:15:21 <eck> don't disappoint!
08:15:27 * dcoutts_ isn't entering icfp this year
08:15:33 <dcoutts_> it's too stressful :-)
08:15:58 <eck> this will be my first year, i'll see how it goes :-)
08:16:19 <dcoutts_> best of luck! :-)
08:17:49 <morgoth_> how do i get the inferior haskell process(ghci) in emacs' haskell-mode to support tab-completion?
08:18:52 <rwbarton> morgoth_: You can use emacs's built-in M-/ as an approximation
08:19:03 <rwbarton> morgoth_: (there may be something better, I don't know)
08:20:48 <guenni> has anybody successfully installed HGL on Windows?
08:20:49 <morgoth_> rwbarton: hmm, not really what i wanted. i could run ghci in a term, but then i'd lose the integration with opened files
08:21:35 <rwbarton> morgoth_: I guess M-/ won't expand names that are in scope but not mentioned in your source files
08:21:50 <dbueno> dcoutts_: Hey, can I guard the buildable flag with a flag "hasQuickCheck" so that if QuickCheck isn't there, the target won't get built?
08:22:22 <dcoutts_> dbueno: yes
08:23:19 <dcoutts_> dbueno: however cabal install will probably just decide to install quickcheck, at least my solver will, dunno about yours :-)
08:23:40 <dbueno> dcoutts_, Huh, also, it seems like Cabal-1.2.3.0 (which ships with GHC 6.8.2) still wants quickcheck, even if the only executable that needs it is not buildable.
08:24:17 <dcoutts_> dbueno: mm, I think it probably doesn't look at the buildable flag 'til later
08:24:34 <dcoutts_> dbueno: the integration between the configurations and the buildable field is not good
08:24:46 <dbueno> Hm, okay.  I guess I'll have to resort to more drastic measures.
08:24:57 <quicksilver> morgoth_: what did you want, in fact?
08:25:02 <quicksilver> morgoth_: what kind of completion were you hoping for?
08:26:25 <morgoth_> quicksilver: the standard completion you get when running ghci in a shell
08:26:50 <quicksilver> morgoth_: that only completes commands and file names, doesn't it?
08:27:02 <quicksilver> morgoth_: overall I find M-/ style completion considerably more valuable.
08:27:03 <morgoth_> quicksilver: no, also function names, etc.
08:27:18 <_zenon_> package hoogle is grrrrreat
08:27:21 <_zenon_> as tiger says
08:28:22 <quicksilver> morgoth_: Heh. I never knew that.
08:28:35 <quicksilver> morgoth_: it should be possible to ask inf-haskell-mode to go into char mode.
08:28:50 <morgoth_> it even completes module names, etc, great for learning the language
08:28:56 <morgoth_> quicksilver: thanks, i'll try
08:29:57 <morgoth_> quicksilver: no, after running term-char-mode it blocks every input
08:32:47 <_zenon_> I get this error when trying to build Yi
08:32:51 <_zenon_> Yi.hs:46:17:
08:32:51 <_zenon_>     Could not find module `Data.Map':
08:32:51 <_zenon_>       it is a member of package containers-0.1.0.1, which is hidden
08:33:40 <Mitar> how could I get rid of that "Program name:" prefix when exiting with "error"
08:34:50 <Baughn> _zenon_: Yi (or the version you're building) hasn't been updated for ghc 6.8.x
08:35:00 <Baughn> _zenon_: The fix is to add containers to the build-depends line in yi.cabal
08:35:29 <_zenon_> Baughn: Aha, I am not familiar with the cabal system at all :/
08:35:43 <Baughn> _zenon_: Just open it. It should be obvious.
08:39:17 <_zenon_> Baughn: Not so obvious.
08:39:24 <_zenon_> I am reading the Cabal user guide
08:39:37 <Baughn> _zenon_: Just read the /cabal/ file
08:39:50 <_zenon_> I am
08:39:53 <Baughn> _zenon_: "build-depends: foo, bar" to "build-depends: foo, bar, containers". Simple.
08:41:02 <_zenon_> I didn't know you meant containers litterally, I thought it was some term , ie. Containers == definition of something with version numbering etc. Therefore I started reading up on Cabal
08:41:50 <Baughn> Does it work now, then?
08:42:12 <_zenon_> Nope, a new error
08:42:21 <_zenon_> Yi/Core.hs:203:7:
08:42:21 <_zenon_>     Could not find module `System.Directory':
08:42:21 <_zenon_>       it is a member of package directory-1.0.0.0, which is hidden
08:42:31 <Baughn> I imagine you know how to fix that by now.
08:42:47 <_zenon_> yeah
08:42:48 <_zenon_> thanks
08:42:53 <_zenon_> for the pointers
08:42:55 <_zenon_> *void
08:42:55 <_zenon_> :
08:42:56 <_zenon_> :)
08:43:54 <_zenon_> quite a lot of continuous errors
08:44:15 <quicksilver> I'm sure there are versions of Yi which are working on 6.8
08:44:25 <quicksilver> this leads me to theorise you have obtained an old version.
08:44:42 <_zenon_> I think I got the latest,
08:44:46 <_zenon_> at least the one from hackage
08:45:04 * quicksilver shakes his head
08:45:08 <quicksilver> that's proabbly not the latest
08:45:15 <quicksilver> Yi is very much an unfinished program
08:45:22 <quicksilver> I imagine the latest is some darcs repo somewhere.
08:45:24 <quicksilver> @where yo
08:45:25 <lambdabot> I know nothing about yo.
08:45:28 <quicksilver> @where yi
08:45:28 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
08:45:53 <quicksilver> (NOTE: the 0.2 release does not work with recent versions of GHC/libraries, and is not supported at all. Please use the darcs repo version instead.)
08:45:56 <quicksilver> ;)
08:45:59 <quicksilver> http://haskell.org/haskellwiki/Yi
08:46:00 <lambdabot> Title: Yi - HaskellWiki
08:47:02 <byorgey> getting Yi from hackage is like getting a loaf of bread from the second-hand store
08:47:12 <Mitar> if I have a list of elements of: data Flag = Fractal Float | Render | Help deriving Eq, how can I `elem` on it to find if it contains a Fractal value?
08:47:24 <quicksilver> @where+ yi http://haskell.org/haskellwiki/Yi
08:47:25 <lambdabot> I will never forget.
08:47:39 <quicksilver> Mitar: elem is for lists.
08:47:56 <Mitar> yes, i have a list of Flag values
08:48:00 <quicksilver> Mitar: you just want case flag of Fractal f -> {- yay it's a fractal -}; _ -> something else.
08:48:00 <byorgey> Mitar: you can't use `elem` for that purpose, but you could do something like   null [ c | c@(Fractal _) <- lst ]
08:48:34 <quicksilver> any isFractal list
08:48:48 <quicksilver> where isFractal (Fractal _) = True; isFractal _ = False
08:50:26 <monochrom> not (null (do { Fractal _ <- list }))
08:51:58 <quicksilver> monochrom: error: last statement in a do block must be an expression.
08:52:17 <monochrom> I failed.
08:52:57 <monochrom> Punishment: no free lunch today. :)
08:53:28 <_zenon_> monochrom: You get free lunch?
08:54:07 <monochrom> Yes, such as syntax sugar.
08:54:11 <_zenon_> Annyway, you cant': the no free lunch theorem => http://www.no-free-lunch.org/
08:54:12 <lambdabot> Title: No Free Lunch Theorems
08:54:37 <_zenon_> :)
08:54:59 <_zenon_> Or can you? =|    *dramatic music*
08:57:54 <Mitar> thanks
08:57:55 <BMeph> If you pay for it in advance, you can always get lunch for free... ;p
08:58:38 <hpaste>  Mitar pasted "Hot to indent?" at http://hpaste.org/8869
09:00:04 <_zenon_> BMeph: Free(X) => Notpayed(X)
09:00:24 <_zenon_> oops, should be <=>
09:01:10 <Mitar> how can i use where properly in pasted code?
09:01:56 <tunaka> So now i'm trying to cycle through the same list, like so: testcycle (f:fx) (k:kx) = f `mod` k ++ (kx ++ k)
09:02:03 <tunaka> I'm getting  an error in "(kx ++ k)"
09:02:14 <tunaka> is there another way of doing this?
09:02:42 <Deewiant> k is not a list (or, at least, it's not the same type as kx)
09:02:49 <Deewiant> ++ appends two lists of the same type
09:02:52 <tunaka> oh thats the problem
09:02:54 <Deewiant> ?ty (Prelude.++)
09:02:55 <lambdabot> forall a. [a] -> [a] -> [a]
09:02:55 <tunaka> so I need an insert
09:03:06 <Deewiant> the easy way to do it is (kx ++ [k])
09:03:17 <tunaka> yeah, makes sense
09:03:31 <Deewiant> and then similarly for the f`mod`k, but there you can also replace the ++ with :
09:03:39 <tunaka> types are tricky, you would think that ++ would also have a definition for one element.
09:04:13 <_zenon_> ?ty (++)
09:04:14 <lambdabot> forall m. (Monoid m) => m -> m -> m
09:04:37 <_zenon_> partial application will yield a type-def for one argument
09:04:38 <tunaka> cool, I think I can implement autokey now
09:04:42 <_zenon_> ?ty (++[1])
09:04:42 <lambdabot> forall t. (Num t) => [t] -> [t]
09:04:46 <tunaka> which is what I wanted to try to get myself started.
09:05:12 <_zenon_> time for Star-Trek :)
09:05:28 * _zenon_ warpdrives the stability subspace matrix :P
09:05:34 <farhan> yes.
09:06:58 <hackage> Uploaded to hackage: AERN-Real 0.9.0
09:07:58 <quicksilver> tunaka: you might hope that (for ++ to magically work with single elements)
09:08:02 <_zenon_> "Fire the photons!" - Chakotay
09:08:04 <quicksilver> tunaka: and indeed, you could make it work.
09:08:13 <quicksilver> tunaka: but then when you're dealing with lists of lists its ambiguous
09:08:35 <quicksilver> tunaka: do you want me to treat this list on the right as a single element (of a list of lists), or a list...
09:09:11 <tunaka> quicksilver: yeah, i understand the why now..
09:10:56 <BMeph> tunaka: But you still want it to just "do what you mean, not what you said" though, don't you? ;)
09:12:20 <tunaka> of course, but understanding why makes me less angry about it..
09:17:40 <mnislaih> ping Toxaris
09:18:16 <mnislaih> @seen Toxaris
09:18:17 <lambdabot> Toxaris is in #scala and #haskell. I don't know when Toxaris last spoke.
09:18:49 <Mitar> @seen help with indention
09:18:50 <lambdabot> I haven't seen help.
09:21:00 <_zenon_> Mitar: http://en.wikibooks.org/wiki/Haskell/Indentation
09:21:00 <lambdabot> Title: Haskell/Indentation - Wikibooks, collection of open-content textbooks
09:22:57 <Mitar> of no help
09:23:25 <_zenon_> Mitar: What is your indentatin problem?
09:23:38 <Mitar> http://hpaste.org/8869
09:23:48 <Mitar> where part
09:24:17 <_zenon_> i'll look
09:25:09 <quicksilver> Mitar: you can't have a where block there.
09:25:20 <Mitar> where could i put it?
09:25:28 <quicksilver> where blocks only attach to definitions.
09:25:40 <quicksilver> for your particular example I would make isFractal top-level
09:25:47 <quicksilver> it's a generally useful thing
09:25:54 <_zenon_> use let
09:25:54 <quicksilver> "isFoo" predicates for constructors are often useful.
09:26:05 <_zenon_> or a predicate
09:26:09 <_zenon_> like quicksilver said
09:26:17 <Mitar> how can i catch a read exception?
09:28:03 <quicksilver> Mitar: don't.
09:28:06 <quicksilver> Mitar: use reads.
09:33:11 <Mitar> thanks
09:33:34 <quicksilver> "errors" which are that kind of exception are not meant to be caught.
09:33:40 <quicksilver> and doubly-not when they occur in pure code.
09:35:24 <sjanssen> are any #haskell teams doing ICFP this year?
09:37:36 <quicksilver> I think there are one or two.
09:37:41 <quicksilver> I think lazy bottoms are competing again?
09:37:45 <sjanssen> ah yes
09:38:52 <kiris> lazy bottoms is an excellent name
09:41:56 <childe_> How about "Lazy _|_".
09:43:25 <quicksilver> I hope it's not like last year's though.
09:43:50 * ronwalf dies from Typeable and fancy types
09:44:06 <ronwalf> with a helping of lists, too
09:46:24 <sjanssen> quicksilver: yeah, let's hope for something more like the previous year
09:47:55 <DRMacIver> I was planning on doing ICFP, but probably won't be able to. (And likely wouldn't have done it in Haskell anyway)
09:48:10 <ptolomy2> scala?
09:48:11 <ronwalf> Are there any Typeable experts in the room?
09:48:46 <DRMacIver> ptolomy2: There was some discussion among the group as to what to do it in. I think we settled on a mix of scala and jython (scala, python and Haskell were the options)
09:49:14 <DRMacIver> (I would have been perfectly fine with doing it in Haskell but at least one member of the group doesn't know it at all)
09:49:28 <sjanssen> ronwalf: I've used Typeable, but I certainly wouldn't call myself an expert
09:49:53 <ronwalf> sjanssen: Do you see my posting to Haskell-cafe?
09:49:57 <sjanssen> ronwalf: it is probably best to describe your problem, and hope one of our silent geniuses speaks up :)
09:50:12 <sjanssen> haven't yet, I'm way behind on my mailing lists
09:50:25 <ronwalf> In short, I defined my own instance of Typeable (I had fancy types)
09:50:38 <ronwalf> typeOf fancy works
09:50:46 <ronwalf> typeOf [fancy] throws undefined
09:51:09 <quicksilver> :t typeOf1
09:51:10 <lambdabot> forall (t :: * -> *) a. (Typeable1 t) => t a -> TypeRep
09:51:23 <wjt> does your typeOf implementation examine its argument?
09:51:54 <wjt> (it must not, else it will break when container types' instances call it on undefined :: Fancy)
09:52:03 <sjanssen> "The value of the argument should be ignored by any instance of Typeable, so that it is safe to pass undefined as the argument.
09:52:16 <ronwalf> ooh, response from Antoinne!
09:53:24 <ronwalf> a ha
09:53:26 <sjanssen> and the [a] instance surely must pass undefined because one can't produce a value of type 'a' from []
09:53:30 <ronwalf> Thank you
09:56:06 <skippycostin> dobblego: you around?
10:11:38 <ptolomy2> I think I have more trouble with cyclical type dependencies in haskell than I do in any other language I've messed with. Partially, because most either don't care about static types, or have header files.
10:16:03 <Baughn> ptolomy2: No, it's pretty simple to avoid
10:16:17 <Baughn> You just have to remember that "type" statements don't really make a new type, just an alias
10:17:31 <ptolomy2> .. I don't think I follow.
10:17:42 <kiris> what program do you guys use to read haskell cafe?
10:17:53 <ptolomy2> gmail.
10:18:01 <Baughn> gmail.
10:18:02 <Deewiant> mozilla thunderbird
10:18:11 <Deewiant> (via gmane)
10:18:24 <Baughn> I was going to switch to something better, but haven't quite managed it yet
10:19:29 <kiris> I'm also using gmail at the moment. I've never really used mailing lists or usenet but now I'd like to
10:20:55 <Baughn> ptolomy2: Can you give me an example of the sort of cycle you're having trouble with?
10:20:58 <lament> usenet is best avoided
10:21:23 <kiris> lament: because of the trolls?
10:21:35 <Baughn> kiris: Because of September
10:21:55 <kiris> Baughn: I don't follow
10:22:18 <Baughn> kiris: The september that never ended. Trolls, spammers.. it's just getting worse, really
10:22:32 <Baughn> And you wouldn't think that was possible
10:22:55 <Baughn> It's really a pity. Usenet was a good idea, even if it could use some updates
10:22:56 <kiris> Baughn: oh, right. well, I've noticed the spam while looking at archives. it's a pity
10:24:04 <Baughn> The only place that is still everything it used to be is Scary Devil Monastery
10:26:14 <_zenon_> gmail is good with the hole conversation - layout
10:26:32 <Baughn> Bad with threading, though
10:28:39 <_zenon_> Baughn: How do you mean?
10:29:15 <Baughn> _zenon_: It orders messages in a given thread by their date, not by who responded to which messages
10:30:30 <_zenon_> Baughn: ohh, I've never reflected on that
10:34:50 <paczesiowa> is it possible for ghci to provide different looking types (perhaps later they can be unified) for two semantically equal expressions? I have written function foo and "foo (\x -> '1')" and "let bar = (\x -> '1') in foo bar" have different types
10:35:46 <phlpp_> @let qs (x:xs) = (qs $ filter (x) xs) in qs [6323,211,12,3,677,1,77,49]
10:35:47 <lambdabot>  Parse error
10:36:10 <Baughn> You want >
10:36:15 <phlpp_> eh
10:36:16 <phlpp_> yeah
10:36:22 <phlpp_> > let qs (x:xs) = (qs $ filter (x) xs) in qs [6323,211,12,3,677,1,77,49]
10:36:23 <lambdabot>      Occurs check: cannot construct the infinite type: t = t -> Bool
10:36:23 <lambdabot>     Prob...
10:36:31 <phlpp_> meh
10:36:44 <Baughn> phlpp_: Stop adding extra, unneeded parantheses
10:36:53 <phlpp_> oh well
10:37:00 <phlpp_> > let qs (x:xs) = qs $ filter (x) xs in qs [6323,211,12,3,677,1,77,49]
10:37:01 <Baughn> You only need one pair of parantheses in that expression. Of course, it still wouldn"t work.
10:37:01 <lambdabot>      Occurs check: cannot construct the infinite type: t = t -> Bool
10:37:01 <lambdabot>     Prob...
10:37:09 <phlpp_> hehe
10:37:11 <phlpp_> okay ;)
10:37:20 <phlpp_> (x) uneeded too, oh my god :>
10:37:24 <Baughn> What are you trying to filter for?
10:38:37 <_zenon_> People with too much time on their hands
10:38:38 <_zenon_> http://weightpull.se/
10:38:39 <lambdabot> Title: WEIGHT PULL SWEDEN
10:40:05 <noecksit> why is it possible that I can use <$> on an Either data type but can't use <*>?
10:40:17 <vixey> <$> and <*> are different
10:40:26 <noecksit> > (\a -> a*2) <$> (Right 2)
10:40:27 <lambdabot>  Right 4
10:40:37 <Baughn> > let qs (x:xs) = x : qs (filter (> x) xs) in qs [14,1222,12,134,1918]
10:40:38 <lambdabot>   Non-exhaustive patterns in function qs
10:40:51 <ndmitchell> > (*2) <$> Right 2
10:40:53 <vixey> > (*2) . (Right 2)
10:40:53 <lambdabot>  Right 4
10:40:54 <lambdabot>  Right 4
10:40:59 <Baughn> > let qs (x:xs) = x : qs (filter (> x) xs); qs [] = [] in qs [14,1222,12,134,1918]
10:41:00 <lambdabot>  [14,1222,1918]
10:41:03 <noecksit> > (\a b -> a*b) <$> (Right 2) <*> (Right 2)
10:41:03 <lambdabot>        add an instance declaration for (Applicative (Either a))
10:41:16 <shepheb> vixey: Caleskell only, that one :P
10:41:31 <vixey> No it's haskell
10:41:36 <ndmitchell> is this the effect of Cale taking over lambdabot maintenance?
10:41:38 <vixey> you just import Prelude hiding ((.))
10:41:40 <shepheb> :t (.)
10:41:41 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:41:42 <Deewiant> > (*2) Prelude.. Right 2
10:41:43 <lambdabot>   Not in scope: `Prelude..'
10:41:44 <ndmitchell> redefineing (.) ?
10:41:48 <Deewiant> > (*2) P.. Right 2
10:41:49 <lambdabot>  Couldn't match expected type `a -> b'
10:41:55 <Baughn> ndmitchell: Caleskell is a great language. Really.
10:42:04 <vixey> It's not a different language
10:42:05 <shepheb> Caleskell has (.) = fmap
10:42:16 <vixey> this is haskell you can do this with GHC today!
10:42:23 <shepheb> go try it in ghci
10:42:45 <shepheb> :t P..
10:42:47 <lambdabot> parse error on input `P..'
10:42:48 <noecksit> so hiding the (.) from prelude will import a functor instance?
10:42:58 <shepheb> :t P.(.)
10:42:59 <lambdabot> Not in scope: data constructor `P'
10:43:00 <vixey> no you also have to write  x . y = fmap x y
10:43:07 <vixey> or (.) = fmap if you turned off monomorphism
10:43:25 <ndmitchell> vixey: does Caleskell have MR off? (it should do!)
10:43:42 <shepheb> vixey: okay, fine. I meant that "that expression won't work in stock Haskell out of the box"
10:44:09 <vixey> shephed sure, neither does 90% of the code I've written
10:44:22 <Baughn> :t (P..)
10:44:23 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
10:44:26 <vixey> it's still haskell
10:45:01 <vixey> I do with y <- x was a synonym for x -> y
10:45:04 <vixey> wish*
10:45:24 <noecksit> i guess i could use ap instead i think
10:45:27 <Baughn> I'm sure that would create an ambiguity. *Somewhere*.
10:45:45 <Baughn> It seems to me that just about any change to the syntax that doesn't add more keywords adds amibguities
10:45:45 <noecksit> > (\a b -> a*b) <$> (Right 2) ap (Right 2)
10:45:46 <lambdabot>  Couldn't match expected type `t -> t1 -> f a'
10:45:53 <vixey> > do a <- Right 2 ; b <- Right 3 ; return (a*b)
10:45:54 <lambdabot>  Add a type signature
10:46:15 <vixey> > do a <- Right 2 ; b <- Right 3 ; return (a*b) :: Either String Integer
10:46:16 <lambdabot>  Right 6
10:46:31 <vixey> > liftM2 (*) (Right 2) (Right 3) :: Either String Integer
10:46:33 <lambdabot>  Right 6
10:46:43 <vixey> > (*) <$> (Right 2) <*> (Right 3) :: Either String Integer
10:46:44 <lambdabot>        add an instance declaration for (Applicative (Either String))
10:46:44 <lambdabot>     In t...
10:47:00 <noecksit> my function requires 8 arguments, so i need something like liftM8
10:47:20 <vixey> I don't really know what's going on there
10:47:24 <shepheb> noecksit: that's the beauty of the <*>... syntax.
10:47:26 <ndmitchell> noecksit: or to rewrite your function, 8 arguments is a little on the high side
10:47:31 <vixey> > (*2) <$> (Right 2) :: Either String Integer
10:47:32 <lambdabot>  Right 4
10:47:38 <vixey> :t (<$>)
10:47:39 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:47:40 <vixey> :t (<*>)
10:47:41 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
10:47:43 <vixey> oh I see
10:47:55 <vixey> Can you define a Applicative for Either String ?
10:48:03 <shepheb> vixey: it's a monad, so yes
10:48:24 <noecksit> ndmitchell : its a data structure that i get from parsing a string, i need 8 entities there
10:48:49 <shepheb> (*) <$> (Just 3) <*> (Just 4)
10:48:52 <shepheb> > (*) <$> (Just 3) <*> (Just 4)
10:48:54 <lambdabot>  Just 12
10:49:04 <shepheb> > (*) <$> (Right 3) <*> (Right 4)
10:49:06 <lambdabot>        add an instance declaration for (Applicative (Either a))
10:49:14 <shepheb> hmm, I guess it just hasn't been written?
10:49:15 <schme_> @src Maybe
10:49:16 <lambdabot> data Maybe a = Nothing | Just a
10:49:18 <noecksit> shepheb : Maybe is instance of applicative, Either is not
10:49:29 <Deewiant> ?instances Applicative
10:49:30 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
10:49:32 <Baughn> What does <*> do, abstractly?
10:49:46 <shepheb> noecksit: but Either String has a monad instance, so an Applicative /can/ be define. it just apparently hasn't been
10:49:48 <Deewiant> ?instances-importing Control.Applicative Applicative
10:49:49 <lambdabot> ((,) a), ((->) a), Const m, IO, Maybe, WrappedArrow a b, WrappedMonad m, ZipList, []
10:50:11 <Baughn> @src Maybe <*>
10:50:11 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
10:50:11 <shepheb> ?instances-importing Control.Monad.Monad Monad
10:50:13 <lambdabot> IO, Maybe, []
10:50:16 <noecksit> shepheb : right, and its part of functor which seems even easier to be defined
10:50:17 <Baughn> @src Maybe (<*>)
10:50:18 <lambdabot> (<*>) = ap
10:50:25 <Baughn> @src ap
10:50:25 <lambdabot> ap = liftM2 id
10:50:52 <shepheb> > (+4) `id` 3
10:50:54 <lambdabot>  7
10:51:02 <rwbarton> Baughn: when I tried to figure that out, the best I could do was to note that it's equivalent to having the following method:
10:51:04 <noecksit> > return (\a b -> a * b) `ap` (Right 2) `ap` (Right 2)
10:51:05 <lambdabot>  Add a type signature
10:51:05 <rwbarton> @ty \a b -> (,) <$> a <*> b
10:51:06 <lambdabot> forall a a1 (f :: * -> *). (Applicative f) => f a -> f a1 -> f (a, a1)
10:51:19 <Baughn> > (*) <$> (Just 3) <*> (Just 4)
10:51:20 <lambdabot>  Just 12
10:51:25 <Baughn> > (*) <$> ((Just 3) <*> (Just 4))
10:51:26 <shepheb> ap confused the hell out of me until I saw that.
10:51:26 <lambdabot>   add an instance declaration for (Num (a -> a1))
10:51:27 <rwbarton> (equivalent mod the interaction between strictness and currying, maybe)
10:52:09 <shepheb> the <$> ... <*> ... syntax depends on <$> binding tighter, and that <*> is left-assoc.
10:52:16 <Baughn> @ty (*) <$> (Just 3)
10:52:16 <lambdabot> forall a. (Num a) => Maybe (a -> a)
10:52:38 <Baughn> > (*) <$> (Just 3) <$> (Just 4)
10:52:38 <lambdabot>  Couldn't match expected type `a -> a1'
10:53:20 <Baughn> > ($ 4) <$> ((*) <$> (Just 3))
10:53:21 <lambdabot>  Just 12
10:53:45 <shepheb> > (*4) <$> (Just 3)
10:53:47 <lambdabot>  Just 12
10:54:26 <Baughn> OKay. fmap, or <$>, runs a function on each element of a container, or so. <*>... let me think..
10:54:49 <shepheb> > zip3 <$> (Just [1,2,3]) <*> (Just [4,5,6]) <*> (Just [7,8,9])
10:54:51 <lambdabot>  Just [(1,4,7),(2,5,8),(3,6,9)]
10:55:01 <Baughn> > [(+1),(*2)] <*> [1]
10:55:02 <lambdabot>  [2,2]
10:55:07 <Baughn> > [(+1),(*2)] <*> [1,3]
10:55:08 <lambdabot>  [2,4,2,6]
10:55:18 <shepheb> the real win of <$>...<*> syntax is arbitrary length, unlike liftA#
10:55:51 <noecksit> > return (\a b -> a + b) `ap` (Just 2) `ap` (Just 2)
10:55:52 <lambdabot>  Just 4
10:55:58 <Baughn> <*>.. takes a container containing functions, and applies.. gah, no that's just List
10:56:12 <shepheb> :t <*>
10:56:13 <lambdabot> parse error on input `<*>'
10:56:16 <noecksit> > return (\a b -> a + b) `ap` (Right 2) `ap` (Right 2)
10:56:17 <lambdabot>  Add a type signature
10:56:17 <shepheb> :t (<*>)
10:56:18 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
10:56:34 <noecksit> why does that not work but it works with Just?
10:56:55 <Baughn> @src ap
10:56:55 <lambdabot> ap = liftM2 id
10:57:02 <_zenon_> Which types are instance Applicative?
10:57:10 <shepheb> noecksit: I'm pretty sure there just isn't an instance Applicative (Either String) defined
10:57:16 <rwbarton> noecksit: It doesn't know what the parameter a is in Either a Integer
10:57:16 <noecksit> Baughn : <*> lets u extend the parameters that you have on a function, thats how i like to think about it
10:57:18 <shepheb> ?instances-importing Applicative
10:57:18 <Baughn> noecksit: Incomplete type? You haven't specified what the type of the corresponding Left would be
10:57:19 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
10:57:29 <shepheb> ?instances-importing Control.Appicative.Applicative
10:57:30 <lambdabot> Couldn't find class `Control.Appicative.Applicative'. Try @instances-importing
10:57:32 <Baughn> noecksit: Now explain the list thing I did earlier
10:57:34 <shepheb> ?instances-importing Control.Appicative.Applicative Applicative
10:57:35 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
10:57:38 <shepheb> argh
10:58:05 <noecksit> Baughn : couldnt u retype it, the screen went away for me
10:58:12 <Baughn> > [(+1),(*2)] <*> [1,3]
10:58:13 <lambdabot>  [2,4,2,6]
10:58:19 <vixey> > let (<*>) = ap in (*) <$> (Right 2) <*> (Right 3) :: Either String Integer
10:58:21 <lambdabot>  Couldn't match expected type `Integer'
10:58:31 <Baughn> It's pretty obvious what's going on there, but the /intuition/ is.. missing.
10:58:36 <vixey> > let (<*>) = ap in ((*) <$> (Right 2) <*> (Right 3) :: Either String Integer)
10:58:37 <lambdabot>  Couldn't match expected type `Integer'
10:58:42 <vixey> > let (<*>) = ap in (((*) <$> (Right 2)) <*> (Right 3) :: Either String Integer)
10:58:44 <lambdabot>  Right 6
10:58:51 <dcoutts_> sioraiocht: ping
10:58:57 <dcoutts_> @seen sioraiocht
10:58:58 <lambdabot> sioraiocht is in #haskell-blah and #haskell. I don't know when sioraiocht last spoke.
10:59:13 <noteventime> Hey
10:59:26 <noteventime> Is there a way to manually deregister a cabal package?
10:59:35 <dcoutts_> ghc-pkg unregister
10:59:39 <Baughn> noecksit: How manually?
10:59:49 <shepheb> Baughn: you take a function, use <$> to lift it into the Functor, then <*> takes the function on the left and (partially) applies it to the argument on the right
10:59:57 <noecksit> Baughn : the type of [(+1),(*2)] is [] (a -> b), right?
11:00:13 <vixey> Num n => [n -> n]
11:00:16 <vixey> infact ....o
11:00:16 <Baughn> noecksit: More commonly name [a->b], but yes
11:00:24 <vixey> :t [(+1),(*2)]
11:00:25 <noteventime> dcoutts_: Ohh, I see. Thanks!
11:00:25 <lambdabot> forall a. (Num a) => [a -> a]
11:00:29 <vixey> computers can figure these things out
11:00:58 <Baughn> ..yes, okay.
11:01:18 <noecksit> Baughn : the type of the second parameter is [] a
11:01:19 <Baughn> noecksit: [n], please
11:01:30 <noecksit> gdm, the thing went away again
11:01:47 <noecksit> > [(+1),(*2)] <*> [1,1]
11:01:48 <lambdabot>  [2,2,2,2]
11:01:49 <Baughn> @type (<*>)
11:01:49 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
11:02:12 <Baughn> @instances-importing Control.Applicative Applicative
11:02:13 <lambdabot> ((,) a), ((->) a), Const m, IO, Maybe, WrappedArrow a b, WrappedMonad m, ZipList, []
11:02:17 <noecksit> Baughn : i like to think of [] being m, thats just the way i think of [] being a monad
11:02:41 <Baughn> > (2,3) <*> (+2)
11:02:41 <lambdabot>      The section `(+ 2)' takes one argument,
11:02:41 <lambdabot>     but its type `(t, a)' has none
11:02:50 <vixey> [] x = [x]
11:02:55 <Baughn> > ((+2),3) <*> 2
11:02:55 <vixey> there is no difference
11:02:55 <lambdabot>        add an instance declaration for (Num (a1 -> a1, a), Num (a -> b))
11:03:16 <Baughn> > ((+2),3) <*> (2,5)
11:03:16 <lambdabot>        add an instance declaration for (Num (a1 -> a1), Num (a -> b))
11:03:25 <noecksit> Baughn : so what happens is <*> strips away the [] monad, and applies every instance inside the second parameter of <*> to the function inside the first parameter
11:03:41 <noecksit> Baughn : () is not a monad, actually
11:03:43 <Baughn> noecksit: Yes, I figured that out
11:04:06 <Baughn> @src ((,) a) <*>
11:04:07 <lambdabot> Source not found. I feel much better now.
11:04:13 <Baughn> @src ((,) a) (<*>)
11:04:13 <shepheb> ((,) a) is a Functor, though, and I think an Applicative.
11:04:13 <lambdabot> Source not found. Wrong!  You cheating scum!
11:04:21 <Baughn> It's an applciative; I just checked
11:04:37 <rwbarton> > (*100) <*> (3, 4)
11:04:38 <lambdabot>  Couldn't match expected type `(a -> b) -> a'
11:04:43 <rwbarton> > (*100) <$> (3, 4)
11:04:44 <lambdabot>  (3,400)
11:04:49 <Baughn> > (1,(+2)) <*> (42,17)
11:04:50 <lambdabot>  Add a type signature
11:04:51 <rwbarton> That's the functor...
11:04:55 <mauke> > Juï¬† Tráµ«
11:04:56 <Baughn> > (1,(+2)) <*> (42,17) :: (Int,Int)
11:04:57 <lambdabot>   Not in scope: data constructor `Trk'
11:04:57 <lambdabot>   add an instance declaration for (Monoid Int)
11:04:57 <lambdabot>     In the expression: (1, (+ ...
11:05:31 <noecksit> > (\a -> a * 100) <*> (2)
11:05:32 <lambdabot>        add an instance declaration for (Num ((a -> b) -> a), Num (a -> b))
11:05:49 <noecksit> > ((\a-> a * 100)) <*> (2)
11:05:50 <shepheb> @src Functor ((,) a)
11:05:50 <lambdabot>        add an instance declaration for (Num ((a -> b) -> a), Num (a -> b))
11:05:51 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
11:05:53 <rwbarton> that makes more sense.  ((,) a) is a monad when a is a monoid, and every monad is an applicative
11:06:43 <shepheb> so shouldn't ((,) String) be an Applicative? maybe not without being defined, though
11:07:05 <shepheb> would be sweet if \bot would let us define instances
11:07:06 <hackage> Uploaded to hackage: AERN-Real 0.9.2
11:07:06 <hackage> Uploaded to hackage: AERN-Real 0.9.1
11:07:22 <Baughn> shepheb: No, shouldn't be needed
11:07:23 <rwbarton> should work... yes, it needs to be defined explicitly somewhere, but it was in that list above
11:07:32 <Baughn> Applicative is already instanced for ((,) a)
11:07:42 <rwbarton> ("foo", (*100)) <*> ("bar", 7)
11:07:46 <rwbarton> > ("foo", (*100)) <*> ("bar", 7)
11:07:47 <lambdabot>  ("foobar",700)
11:08:05 <shepheb> although apparently with a (Monoid a) => constraint?
11:08:11 <rwbarton> Yes
11:08:30 <rwbarton> it'd be nice if lambdabot showed the constraints.
11:08:53 <Baughn> That's what was tripping me up? -_-
11:09:10 <shepheb> either that, or would actually show the code when asked with @src Applicative ((,) a)
11:09:38 <rwbarton> It's surely  pure = return ; (<*>) = ap
11:09:50 <Baughn> "Monoid a => Applicative ((,) a)" <-- Ah.
11:10:00 <rwbarton> (Unless it shows you the instance line as well, in which case yes :)
11:10:14 <noecksit> > do { a <- Right 2; b <- Right 2; return (a+b)}
11:10:14 <lambdabot>  Add a type signature
11:10:17 <Baughn> instance Monoid a => Applicative ((,) a) where pure x = (mempty, x) (u, f) <*> (v, x) = (u `mappend` v, f x)
11:10:19 <noecksit> > do { a <- Right 2; b <- Right 2; return (a+b);}
11:10:20 <lambdabot>  Add a type signature
11:10:21 <shepheb> @src Monad []
11:10:22 <lambdabot> Source not found. I feel much better now.
11:10:30 <shepheb> I could've sworn it used to show those
11:10:48 <shepheb> maybe not instances, oh well.
11:10:56 <Baughn> > pure 2 :: (String,Int)
11:10:57 <lambdabot>  ("",2)
11:10:57 <rwbarton> shepheb: I agree
11:11:19 <noecksit> wait a sec, i dont think Either is an instance of monad right?
11:11:26 <Deewiant> > do { a <- Right 2; b <- Right 2; return (a+b);} :: Either String Int
11:11:28 <lambdabot>  Right 4
11:11:29 <shepheb> noecksit: it couldn't be, wrong kind
11:11:32 <vixey> @instances Monad
11:11:33 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
11:11:34 <shepheb> :k Either
11:11:35 <lambdabot> * -> * -> *
11:11:49 <Baughn> > pure id <*> ([],42)
11:11:51 <lambdabot>  ([],42)
11:11:52 <shepheb> Either e is though, for e a Monoid, iirc.
11:11:53 <rwbarton> Wait, didn't it use to print ?? -> ? -> *  ?
11:12:00 <vixey> :k (->)
11:12:01 <lambdabot> ?? -> ? -> *
11:12:05 <rwbarton> Ooh
11:12:10 <rwbarton> Someone please enlighten me :)
11:12:17 <shepheb> that's something of a special case, I think
11:12:22 <vixey> ?where GHC documentation
11:12:23 <lambdabot> http://haskell.org/ghc
11:12:33 <shepheb> the ?? and ? are not necessarily of kind * in (->)
11:12:50 <rwbarton> :k (->) Either Maybe
11:12:52 <lambdabot>     `Either' is not applied to enough type arguments
11:12:52 <lambdabot>     Expected kind `??', but `Either' has kind `* -> * -> *'
11:13:01 <noecksit> Deewiant : why is it necessary to type cast that statement?
11:13:19 <Deewiant> ?ty do { a <- Right 2; b <- Right 2; return (a+b);}
11:13:21 <lambdabot> forall t a. (Error a, Num t) => Either a t
11:13:28 <noecksit> oh, because it doesnt know what Left will return probably
11:13:32 <Deewiant> yep
11:13:39 <Deewiant> the Num would default, but the Error won't
11:13:40 <_zenon_> Is there a way to interface with an IRC client using haskell?
11:13:45 <Baughn> > Nothing <|> Just 3
11:13:46 <lambdabot>  Just 3
11:13:54 <_zenon_> Or will Network suffice?
11:13:56 <Zao> _zenon_: Apart from the irc library on hackage?
11:14:02 <vixey> rwbarton:http://hackage.haskell.org/trac/ghc/wiki/IntermediateTypes
11:14:07 <lambdabot> Title: IntermediateTypes - GHC - Trac
11:14:07 <_zenon_> Zao: ooooh I didn't know it existed :)
11:14:25 <atp> _zenon_: do you mean interface with an irc server, or a client?
11:14:32 <_zenon_> irc server
11:14:37 <_zenon_> to act as a client
11:14:37 <atp> _zenon_: ok, because you said client :)
11:14:51 <vixey> _zenon_: Lambdabot is written in haskell
11:14:53 <_zenon_> I meant server,
11:14:56 <Baughn> > "" <
11:14:57 <lambdabot>   parse error on input `}'
11:15:05 <Baughn> > "" <|> "foo" <|> "bar"
11:15:06 <lambdabot>  "foobar"
11:15:06 <vixey> > }
11:15:07 <lambdabot>  Parse error at "}" (column 1)
11:15:16 <atp> writing an irc application is a favorite beginning programming task because it's pretty straightforward
11:15:19 <shepheb> :t (<|>)
11:15:20 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f a -> f a
11:15:27 <_zenon_> vixey: Yeah, I was afraid they had written their own protocoll parsers and such
11:15:27 <atp> in basically any language
11:15:31 <rwbarton> vixey: oh, thanks!
11:15:36 <vixey> that's odd, `}' and "}"
11:15:42 <_zenon_> which would be hidden within lambdabot
11:15:50 <atp> lambdabot is open source
11:15:50 <Deewiant> _zenon_: that's not too hard either for simple stuff
11:16:04 <noecksit> > (return (\a b -> a+b) `ap` (Right 2) `ap` (Right 2)) :: Either String Int
11:16:05 <lambdabot>  Right 4
11:16:12 <monochrom> "Do you know lambda calculus?"  "Yes, they made me take Calculus I and Calculus II."
11:16:15 <_zenon_> Main point: It's there on hackage
11:16:21 <atp> monochrom: haha
11:16:23 <noecksit> ah, ok
11:16:52 <monochrom> I made that up. Fictional dialogue.
11:16:55 <cjs> Now, if they had "Lambda Calculus I" and "Lambda Calculus II"...
11:17:04 <atp> i was talking to my boss' son yesterday, and he told me that he wanted to skip analysis at princeton his freshman year because he's already had it in high school
11:17:11 <atp> i was like, what's the book at princeton
11:17:16 <atp> baby rudin
11:17:26 <atp> then he told me he'd done continuity but not derivatives
11:17:54 <cjs> Is nobody getting excited here about the contest?
11:17:56 <_zenon_> ooooh. hurts.
11:17:57 <atp> but try as i might i could not convince him that it was possible that princeton's analysis class might offer him something more
11:18:06 <atp> he's going to have the surprise of his life
11:18:08 <_zenon_> atp: that's a sad story
11:18:21 <atp> well, i brought in baby rudin so he could see it before he decided to skip the class
11:18:25 <monochrom> But real life is more scary. The following was real event. A highschool came to our university our CS department to ask about teaching AI in highschool.  CS: "You need a lot of background. For example, lambda calculus."  Highschool: "Yes, we have Calculus."
11:18:33 <atp> apparently he'd decided that it was short and couldn't cover too much material
11:18:38 <atp> i just laughed
11:18:58 <vixey> what has lambda calculus got to do with AI ?
11:19:28 <cjs> vixey: They sort of had a one-night-stand a few decades ago.
11:19:40 <monochrom> Yeah. :)
11:19:47 <atp> what do computers have to do with intelligence, that's the better question
11:19:49 <mauke> Î±Î¹
11:19:54 <chris2> it's a nice thing to teach your intelligence, imo :)
11:19:55 <monochrom> Lisp used to be a popular language among AI people.
11:20:06 <Baughn> atp: About as much as submarines have to do with swimming
11:20:11 <atp> Baughn: exactly :)
11:20:38 <atp> computer science is to computers as astronomy is to telescopes
11:20:42 <_zenon_> vixey: Well, It's part of CS fundaments, but straight connection to AI? Maybe not.
11:21:20 <atp> lambda calculus is deep, beautiful, and simple
11:21:27 <_zenon_> atp: agree
11:21:28 <atp> for that reason alone it should be studied
11:21:28 <_zenon_> :)
11:21:33 <_zenon_> agree
11:21:33 <cjs> Actually, my old uni called it "Computing Science," explicitly avoiding the "computer" thing.
11:21:44 <atp> cjs: nice
11:22:15 <cjs> University of Alberta. Well known for its good agricultural programmes. :-)
11:22:38 <monochrom> And poker programs.
11:22:44 <atp> and great weather
11:22:52 <monochrom> And checker programs.
11:23:24 <cjs> A bit of chess, too.
11:23:56 <cjs> But yeah, who was it that used to go down to Vegas every year and rake in a medium size pot?
11:24:09 <monochrom> It has a good software engineering faculty. It sets up a lab so students participate in realistic projects.
11:24:15 <cjs> Somehow I'm thinking Keith Smillie, though I'm not sure....
11:24:29 <atp> vegas doesn't like it when people do that
11:24:38 <atp> especially since the place has historically been run by the mob...
11:25:02 <cjs> Yeah, he was rather low key about it. Take out a few ten grand and leave it at that.
11:25:19 <cjs> And that gets you pretty far in Edmonton. :-)
11:25:45 <atp> whenever i get depressed about living in alaska, i always think that it could be worse, i could be in alberta
11:25:49 <atp> weather-wise
11:25:56 <cjs> Ah, right, it was Tony Marsland who did the chess thing. I was in love with his daughter, once.
11:26:06 <monochrom> Haha atp.
11:26:10 <cjs>  /brick atp
11:26:41 <atp> in feb we had a cold snap and it was negative 25 C or something
11:26:47 <atp> and in edmonton it was like minus 40
11:26:55 <cjs> Alberta's weather is just fine! It rarely gets below -35 degC.
11:27:04 <cjs> -25? Nice!
11:27:11 <atp> spoken like a canadian
11:27:20 <atp> i'd say we'll beat you in hockey but who am i kidding
11:27:33 <pejo> The odd part is that the first time you get -25 of the year it feels darn cold. Even -10. After a while -20 is ok though.
11:27:34 <_zenon_> http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot#Getting_started
11:27:35 <lambdabot> Title: Roll your own IRC bot - HaskellWiki, http://tinyurl.com/y4prf8
11:27:37 <_zenon_> Great page :)
11:27:47 <shepheb> I'm from Ottawa, -40 days suck.
11:27:47 <_zenon_> Good to get going with IRC connection and haskell
11:27:57 <atp> pejo: -10 is very doable, surprisingly... but -25... that's kill you weather
11:28:03 <atp> -10 you can survive in
11:28:11 <atp> for a while, anyway.
11:28:21 <atp> -40 is horrible
11:28:29 <atp> and then there's fairbanks... it was -60 C this year
11:28:33 <atp> but only crazies live there
11:28:35 <pejo> I think the key insight is to not spend too much time outdoors when it's cold. Atleast that's what I try to do.
11:28:38 <cjs> After a couple of years in NYC I went up to Montreal for a Christmas holiday, and I was overjoyed to walk out of the aeroport into a beautiful -20 degC day. It felt so good, after all that Florida-style warmth...
11:28:55 <atp> montreal is beautiful, but it's not the weather
11:29:02 <atp> but it's definitely a great place
11:29:09 <cjs> -40 definitely sucks. Now that's *cold*.
11:29:23 <atp> cjs: at some point it's not like you can tell the difference anymore
11:29:30 <atp> it's just a matter of how quickly you die
11:30:39 <cjs> Yeah, but that's well below -25. -10, -20, -25, you can tell the difference.
11:31:09 <atp> i don't like temps below -25
11:31:28 <cjs> I remember moving to Vancouver when I was eight and being amazed that there were all these parking lots with no electrical sockets to plug in your block heater.
11:31:38 <atp> bc is totally temperate
11:31:42 <atp> and beautiful
11:31:53 <ahunter> cjs: I currently live in SoCal, it sucks...originally from massachusetts, where we get plenty of cold weather, I miss it so
11:32:02 <atp> cold weather sucks
11:32:06 <atp> i'm originally from norcal
11:32:29 <atp> it's 15 degrees in july and it's been overcast for two months straight
11:32:29 <cjs> I'm in Tokyo. I know the feeling. And I die during the summers, which have just started.
11:32:44 <atp> see, i like asian summers, i lived in beijing for many years
11:32:51 <_zenon_> Iv'e read that there is some tradition in Japan where they water the streets?
11:32:53 <atp> hot and humid, 34 C for the win
11:32:55 <cjs> I found myself this evening thinking, "Oh, humidity's down to 95% now. Great!"
11:33:05 * atp kicks alaska.
11:33:11 <sioraiocht> dcoutts_: ?
11:33:21 <dcoutts_> sioraiocht: how're things?
11:33:26 <cjs> _zenon_: Yeah, the do that, for some reason. To clean it or something. I see it all the time.
11:33:33 <dcoutts_> sioraiocht: I've been away for over a week, just wanted to catch up
11:33:38 <sioraiocht> ah
11:34:00 <sioraiocht> i had a 1 week course to do, haven't worked much due to the exam
11:34:08 <sioraiocht> am actually turning it in beginning of next week
11:34:14 <sioraiocht> and will probably have more to tell you end of next week
11:34:19 <sioraiocht> am actually in america right now
11:34:20 <sioraiocht> heh
11:34:24 <dcoutts_> sioraiocht: oh nice :-)
11:34:30 <ahunter> cjs: ah, humidity...one thing I don't miss in Massachusetts.  It may not get cold in LA, but the heat is dry and there's no bugs
11:34:38 <sioraiocht> but will still be working, just from warmer weather ;)
11:34:45 <dcoutts_> sioraiocht: when do you get back? and can I persuade you to give a short talk at AngloHaskell in August?
11:34:49 <sioraiocht> yes
11:34:51 <sioraiocht> what date?
11:34:55 <cjs> ahunter: that sounds wonderful. Like Edmonton. :-)
11:34:55 * dcoutts_ checks
11:35:24 <dcoutts_> sioraiocht: http://haskell.org/haskellwiki/AngloHaskell/2008
11:35:25 <lambdabot> Title: AngloHaskell/2008 - HaskellWiki
11:35:33 <sioraiocht> yes
11:35:36 <sioraiocht> i wil be back and free then
11:35:40 <sioraiocht> consider me committed :)
11:35:47 <dcoutts_> cool, add your name to the wiki
11:36:04 <dcoutts_> and join #anglohaskell
11:36:09 <sioraiocht> i'm there, actually
11:36:09 <cjs> I can't belive I'm staying up until 4 a.m. (Tokyo time) to see what the heck the problem is this year.
11:36:47 <noecksit> > let R = R String String String in (return (\a b c -> R a b c) `ap` (Right "hello") `ap` (Right "hello") `ap` (Right "hello")) :: Either String R
11:36:48 <lambdabot>   Not in scope: type constructor or class `R'
11:37:01 <pgavin> dcoutts_: did you happen to get my email about the gtk2hs docs?
11:37:42 <dcoutts_> pgavin: I'm getting to the end of my email backlog :-)
11:37:46 <noecksit> > let data R = R String String in (return (\a b -> R a b) `ap` (Right "hello") `ap` (Right "hello")) :: Either String R
11:37:47 <lambdabot>  Parse error at "data" (column 5)
11:37:47 <dcoutts_> pgavin: you want the docs moving right?
11:38:02 <dcoutts_> pgavin: do I just need to unpack a tarball or is there more to it?
11:38:09 <noecksit> @help data
11:38:09 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:38:13 <pgavin> dcoutts_: no, that should be it
11:38:27 <dcoutts_> pgavin: remind me where the tarball is and I'll do it now
11:38:28 <pgavin> dcoutts_: thanks :)
11:39:04 <pgavin> dcoutts_: http://code.haskell.org/~pgavin/gtk2hs-0.9.13/gtk2hs-0.9.13-doc.tar.bz2
11:39:05 <lambdabot> http://tinyurl.com/5brexp
11:39:39 <dcoutts_> 'k
11:41:07 <noecksit> > let Test = Test String in f (Test a) = a
11:41:07 <lambdabot>  Parse error at "=" (column 38)
11:41:25 <noecksit> > let data Test = Test String in f (Test a) = a
11:41:26 <lambdabot>  Parse error at "data" (column 5)
11:41:45 <noecksit> how would u be able to define your own datatype in lambdabot?
11:41:50 <pgavin> dcoutts_: I was thinking about getting haddock 2 working with gtk2hs, or should I wait until the cabal stuff is ready?
11:42:11 <mauke> noecksit: can't
11:42:16 <dcoutts_> pgavin: I'd leave haddock 2 for a bit, it's not really mature yet I think
11:42:26 <pgavin> dcoutts_: k
11:42:27 <dcoutts_> pgavin: and it'll be a pain to work into the current build system
11:42:38 <pgavin> dcoutts_: yeah, I thought so
11:42:49 <dcoutts_> pgavin: cabalising will make that easy hopefully
11:43:02 <pgavin> dcoutts_: I'd have to do checks in the configure script to figure out which version of haddock is available
11:43:06 <noecksit> oh, a let statement won't suffice?
11:43:23 <dcoutts_> pgavin: aye. So the major blocker for cabalising is using mainline c2hs I think.
11:43:37 <pgavin> dcoutts_: yeah, maybe I'll start working on that
11:43:39 <dcoutts_> pgavin: as you saw, axel is pretty pessimistic about it
11:43:44 <dcoutts_> pgavin: I've started :-)
11:43:49 <RayNbow> hmm, ICFP starts in... about 15 minutes?
11:43:50 <pgavin> ah, ok
11:44:06 <vinicius> omg omg omg omg
11:44:10 <dcoutts_> pgavin: I've been refactoring c2hs a bit in preparation to add some features we want
11:44:21 <pgavin> cool
11:44:26 <dcoutts_> pgavin: perhaps you can help with the design of what we want
11:44:38 <pgavin> sure
11:44:56 <dcoutts_> pgavin: the basic problem is that our c2hs diverged in that we added some simple marshaling support to the {# call #} hooks, but in an ad-hoc way
11:45:08 <pgavin> right
11:45:16 <dcoutts_> pgavin: and mainline c2hs added the {# fun #} hooks with a more complete marshaling system
11:45:24 <pgavin> but more complicated :)
11:45:31 <pgavin> and harder to use
11:45:41 <dcoutts_> but gtk2hs does not want to use the {# fun #} hooks since I think it's actually too limited for the kind of marshaling we do
11:46:10 <dcoutts_> but it would make our life easier if there were some (optional) marshaling support added to {# call #} hooks
11:46:18 <dcoutts_> so that our code could be simpler
11:46:25 <pgavin> right
11:46:38 <dcoutts_> so my plan is to extend the marshaling system for fun hooks and add it to call hooks too
11:46:46 <dcoutts_> eg currently one cannot declare new default marshalers
11:46:50 <pgavin> I'd also like a way to have c2hs provide just a bare, unmarshalled function from {# call #}
11:47:05 <dcoutts_> right, so we must keep {# call #} as it is currently
11:47:16 <dcoutts_> if we add marshaling stuff it has to be with some extra syntax
11:47:24 <dcoutts_> we can't just go redefining the existing stuff
11:47:38 <pgavin> dcoutts_: right
11:47:51 <dcoutts_> pgavin: so designing the syntax is one important task
11:48:06 <dcoutts_> pgavin: honestly, I've never liked the {# fun #} marshaling syntax
11:48:18 <pgavin> dcoutts_: hmm, since {#pointer#} lets you add newtype, maybe we can have {#call newtype#} or similar
11:48:44 <pgavin> dcoutts_: it's not any easier to use than adding marshalling around the {#call#}
11:49:00 <dcoutts_> pgavin: the real advantage comes when we have default marshalers
11:49:30 <RayNbow> #seen ndmitchell
11:49:30 <dcoutts_> pgavin: eg the default marshaler for a {# pointer Foo foreign newtype #} would be something that unwraps the newtype and uses withForeignPtr
11:49:34 <RayNbow> erm
11:49:39 <RayNbow> @seen ndmitchell
11:49:40 <lambdabot> I saw ndmitchell leaving #haskell-soc and #ghc 36m 19s ago, and .
11:49:43 <pgavin> dcoutts_: yes, that would be nice
11:49:58 <dcoutts_> pgavin: which is precisely the ad-hoc marshaling that we added to gtk2hs's c2hs fork
11:50:12 <RayNbow> ndmitchell maintains Hugs, right?
11:50:19 <dcoutts_> pgavin: the automatic unwrapping of newtypes and foreign ptrs
11:50:34 <dcoutts_> RayNbow: no, that's Ross Patterson, but ndm helps a bit here and there
11:50:39 <RayNbow> ah
11:51:03 <RayNbow> oh, I already found my source of problems...
11:51:14 <RayNbow> I got used to ghci's :m...
11:51:24 <dcoutts_> pgavin: I've gotta go, see you later
11:51:29 <RayNbow> and forgot that in Hugs you need to use :l most of the times :p
11:51:34 <pgavin> dcoutts_: ok, cya
11:52:34 <noecksit> @instances Monad
11:52:35 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
11:52:51 <noecksit> @instances Either
11:52:51 <lambdabot> Couldn't find class `Either'. Try @instances-importing
11:53:07 <noecksit> @instances-importing Either
11:53:08 <lambdabot> Couldn't find class `Either'. Try @instances-importing
11:53:23 <noecksit> @ty Either
11:53:24 <lambdabot> Not in scope: data constructor `Either'
11:53:31 <noecksit> @type Either
11:53:32 <lambdabot> Not in scope: data constructor `Either'
11:53:38 <Baughn> @kind Either
11:53:39 <lambdabot> * -> * -> *
11:53:46 <Baughn> It's a type constructor, not a type or a class
11:54:45 <noecksit> hmm, what does it mean that Either e is an instance of Monad? does it mean that only the Left constructor is a monad?
11:55:01 <dons> ?src Monad Either
11:55:02 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
11:55:02 <mauke> look at the kinds
11:55:07 <dons> ?src Either Monad
11:55:07 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
11:55:10 <ahunter> noecksit: are you familiar with the Maybe instance?
11:55:13 <Baughn> > return 2 :: Either String Int
11:55:14 <lambdabot>  Right 2
11:55:15 * dons never remembers how to  index indices
11:55:20 * dons never remembers how to  index instances
11:55:31 <noecksit> ahunter : to a degree
11:55:36 <atp> dons: just wake up? :)
11:56:00 <noecksit> @kind Maybe
11:56:01 <lambdabot> * -> *
11:56:08 <Baughn> @src Either >>=
11:56:09 <lambdabot> Source not found. That's something I cannot allow to happen.
11:56:10 <sjanssen> @src Monad (Either a)
11:56:11 <lambdabot> Source not found. stty: unknown mode: doofus
11:56:12 <Baughn> @src Either (>>=)
11:56:12 <lambdabot> Left  l >>= _ = Left l
11:56:12 <lambdabot> Right r >>= k = k r
11:56:19 <sjanssen> @src (Either a) Monad
11:56:20 <lambdabot> Source not found. My mind is going. I can feel it.
11:56:24 <atp> noecksit: Either is used typically when you want to propagate more than one exception
11:56:26 <sjanssen> pssh
11:56:39 <atp> noecksit: whereas Maybe is used when you only need one error condition
11:56:47 <sjanssen> but there is no Monad instance for Either!
11:56:56 <rwbarton> Either a
11:57:06 <atp> sjanssen: haha
11:57:14 <atp> sjanssen: it's true, wrong kind
11:57:20 <Baughn> @src Either fail
11:57:20 <lambdabot> fail msg      = Left (strMsg msg)
11:57:27 <sjanssen> @type strMsg
11:57:28 <noecksit> atp : yes, thats exactly what im trying to do
11:57:28 <lambdabot> forall a. (Error a) => String -> a
11:57:40 <Baughn> ..it has to be a string? Bad monad! Bad!
11:57:51 <sjanssen> it is actually: instance Error a => Monad (Either a)
11:57:52 <atp> Baughn: fail is stupid
11:58:11 <Baughn> atp: I'm inclined to agree
11:58:11 <sjanssen> Baughn: it has to be something that can be derived from a String, which is not necessarily the same thing
11:58:14 <Baughn> @instances Error
11:58:14 <lambdabot> IOError, String
11:58:27 <Baughn> sjanssen: So I see. Well, at least I can instance it at need
11:58:53 <RayNbow> @karma fail
11:58:53 <lambdabot> fail has a karma of 0
11:59:03 <sjanssen> fail--
11:59:29 <Baughn> sjanssen: "Next time, fail less"?
11:59:30 <atp> noecksit: anyway, it puts the value you're working with in Right and the exception if there is one into Left.  Left x >>= f = Left x so it short circuits when it sees an error, propagating it
11:59:50 <atp> noecksit: just like Maybe and Nothing
12:00:01 <mauke> preflex: karma fail
12:00:01 <preflex>  karma for fail: -1
12:00:06 <atp> noecksit: think of it as Maybe with Nothing carrying a value that you can set :)
12:01:18 <noecksit> > return 2 >>= \a -> Just a
12:01:19 <lambdabot>  Just 2
12:01:27 <noecksit> > return 2 >>= \a -> Right a
12:01:28 <ronwalf> So for finding where an exception is thrown, what's the best tool?
12:01:28 <lambdabot>  Add a type signature
12:01:36 <noecksit> > return 2 >>= \a -> Left a
12:01:37 <lambdabot>  Add a type signature
12:01:43 <ronwalf> Hat seems... not updated?
12:01:45 <atp> noecksit: you need to specify what the type of Right and Left will be
12:01:56 <atp> noecksit: remember that Either a b has two types
12:01:59 <sjanssen> time to ddos icfpcontest.org!
12:02:02 <atp> noecksit: whereas Maybe a has only one
12:02:03 <noecksit> > (return 2 >>= \a -> Right a) :: Either String Int
12:02:04 <lambdabot>  Right 2
12:02:26 <RayNbow> are there any plans of removing fail from the Monad class in Haskell'?
12:02:47 <atp> gosh i hope so
12:02:57 <ahunter> Is it just me, or is icfpcontest.org currently getting a bit hammered? :P
12:02:58 <atp> that's what MonadZero is for
12:03:11 <atp> or was, i guess
12:03:12 <noecksit> > (return "error" >>= \a -> Left a) :: Either String Int
12:03:13 <lambdabot>  Left "error"
12:03:27 <atp> noecksit: try this:
12:03:43 <noecksit> > (return "error" >>= \a -> Left a >>= \b -> Right b) :: Either String Int
12:03:44 <lambdabot>  Left "error"
12:03:58 <atp> yeah, that works :p
12:04:12 <noecksit> atp : that means it doesn propagate it, like u said
12:04:13 <atp> well, it doesn't show it as cleanly
12:04:42 <atp> > (Left "error" >>= \x -> return (2 * x)) :: Either String Int
12:04:43 <lambdabot>  Left "error"
12:04:50 <atp> see, it doesn't evaluate the second function
12:04:59 <atp> it just passes on Left
12:05:02 <atp> in the same way that
12:05:04 <vixey> > throwError "Yukc" >> return (Right 7)
12:05:06 <lambdabot>   add an instance declaration for (MonadError [Char] m)
12:05:11 <atp> >  Nothing >>= \x -> return (2 * x )
12:05:12 <lambdabot>  Nothing
12:05:18 <atp> for Maybe
12:05:23 <RayNbow> ahunter: site works here
12:05:26 <vixey> > runErrorT (throwError "Yukc" >> return (Right 7))
12:05:27 <lambdabot>        add an instance declaration for
12:05:27 <lambdabot>       (Show (m (Either [Char] (Either ...
12:05:34 <atp> in the monad definition of Either a, Left a is just like Nothing
12:05:40 <atp> they are essentially the same
12:05:55 <atp> with the important distinction that Left can carry a value, and Nothing can't
12:05:58 <vixey> yeah there's no MaybeT
12:06:02 <vixey> you might use ErrorT instead
12:07:29 <atp> Maybe a is almost isomorphic to Either () a
12:07:45 <Japsu> whaddyamean, almost?
12:07:52 <atp> () can also be bottom iirc
12:07:52 <vixey> they both = 1 + a
12:08:04 <atp> there's some wackiness with lifting
12:08:06 <atp> isn't there?
12:08:07 <vixey> :t undefined :: Maybe Integer
12:08:09 <lambdabot> Maybe Integer
12:08:13 <atp> in a bottomless world they're definitely isomorphic
12:08:22 <Japsu> hmm
12:08:31 * atp slaps bottom.
12:08:32 <vixey> what lifting ?
12:08:33 <atp> heheh
12:08:43 <atp> i mean lifting bottom into the types
12:08:50 <atp> so () has two values, not just one
12:09:19 <vixey> is _|_  Left () or Right 3 ?
12:09:26 <Baughn> And /that's/ only if you don't use functions like "isInfiniteLoop" on it
12:09:41 <atp> i believe Either a b can carry () in either a or b, as well as in the data structure itself
12:09:51 <Baughn> vixey: ..Neither. It's _|_
12:10:10 <Baughn> Which is another valid value of an Either, too
12:10:27 <Baughn> (Left, Right and _|_)
12:10:39 <atp> right... _|_, Left _|_, and Right _|_ are all valid eithers
12:10:51 <ronwalf> hm, martian rovers
12:11:00 <atp> _|_, Nothing, and Just _|_ are all valid maybes, but
12:11:09 <atp> Left _|_ and Left () are both valid Either () a
12:11:17 <noecksit> atp : thanx
12:11:18 <atp> so there's an extra value there
12:11:24 <atp> so it can't be really isomorphic
12:11:26 <atp> i don't think
12:11:43 <atp> i don't like bottom
12:11:49 <vinicius> lol, dead reckoning in haskell is going to be fun
12:15:36 <augustss> vinicius: are you navigating haskell blindfolded?
12:16:28 <augustss> atp: I don't like _|_ either
12:25:12 <lilachaze> it's gone quite in here since icfp08 started :)
12:25:15 <lilachaze> *quiet
12:27:22 <augustss> oh, the contest.  i had forgotten :)
12:27:56 <ski> Do push-ups
12:27:56 <lambdabot> ski: You have 1 new message. '/msg lambdabot @messages' to read it.
12:27:59 <ski> Then a sauce
12:28:02 <ski> Evade
12:28:08 * cjs bricks augustss
12:28:23 <byorgey> @seen Cale
12:28:24 <lambdabot> Cale is in #japanese, #haskell-overflow, #ghc and #haskell. I don't know when Cale last spoke.
12:28:26 <ski> @clear-messages
12:28:26 <lambdabot> Messages cleared.
12:28:34 <mauke> preflex: seen cale
12:28:35 <preflex>  cale was last seen on #haskell 7 hours and 43 seconds ago, saying: (not that it really has anything to do with monads)
12:28:49 <vincenz> @seen cale
12:28:50 <lambdabot> cale is in #japanese, #haskell-overflow, #ghc and #haskell. I don't know when cale last spoke.
12:29:16 <ski> lambdabot : let's see if you forgets about forgetting to forget you've given me that message, this time ..
12:33:15 <vinicius> augustss: no, i'm talking about icfp contest's task =)
12:34:38 <Saizan> is it out yet or not?
12:34:42 <vinicius> yes
12:35:15 <cjs> Yup. But damn. DEGREES?!?
12:36:15 <byorgey> cjs: hehe
12:45:05 <noecksit> > (return (\a b -> a+b) `ap` (Right 2) `ap` (Right 2)) :: Either String Int
12:45:06 <lambdabot>  Right 4
12:51:03 <cjs> Interesting. You score higher if you take longer to get back?
12:52:03 <noecksit> im not sure why but i copied this exact statement into ghci and i get an instance error
12:52:20 <Igloo> cjs: I haven't finished reading it yet, but if so then perhaps the point is to avoid the obstacles and martians for as long as possible?
12:52:32 <vixey> you don't have instances available, load the modules :m + <whatever>
12:52:57 <cjs> Igloo: while still getting home just in time. Yes. Interesting.
12:53:24 <noecksit> vixey: well i loaded Data.Either and Control.Monad im not sure what else i need
12:53:58 <cjs> Really, it seems that if the Martians are not too hard to avoid, you could do well by just running around avoiding them until the time runs out.
12:54:11 <cjs> Now what makes me think that they're not that easy to avoid? :-)
12:54:19 <luite_> cjs: you have to minimize the score (run time plus penalties)
12:54:52 <gwern> cjs: this is the same as the xkcd velociraptor problem
12:54:56 <gwern> they're gonna catch up
12:55:37 <cjs> Oops. "As in ski racing, lower scores are better."
12:55:40 <rwbarton> cjs: You only score higher if you take longer to die.
12:56:00 <rwbarton> cjs: (where by "higher" I meant "better")
12:56:04 <vixey> @index ap
12:56:05 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List, Data.Graph.
12:56:05 <lambdabot> Inductive.Query.ArtPoint, Data.Graph.Inductive.Query, Data.Graph.Inductive
12:56:13 <shepheb> gwern: what, the getting mauled by velociraptors for using goto?
12:56:24 <vixey> noecksit: just Control.Monad.Error
12:56:25 <cjs> Yeah, you meant lower. I just didn't read far enough along before I started thinking.
12:56:30 <vixey> Error is the name for Either String
12:56:36 <cjs> Apparently a common mistake in this contest....
12:57:29 <noecksit> vixey : oh thanx, i wouldnt have been able to figure that out
12:57:37 <noecksit> i need to write it down somewhere
12:57:41 * ski races
12:57:41 <vixey> noecksit: of course you would
12:57:44 <gwern> shepheb: no, 'you are surrounded by an equilateral triangle of velociraptors who travel at 3 m/s. one has a wounded leg and can only travel at 2.6 m/s. you travel at 2.5 ms/. at which angle should you flee to maximize your remainig life?"
12:57:47 <gwern> I paraphrase
12:57:57 <vixey> noecksit: It would just mean reading through every monad instance until you found ita
12:57:59 <shepheb> gwern: hahaha
12:58:27 <vixey> ski: who do you race ?
12:58:44 <ski> oh, i don't know
12:58:50 <gwern> shepheb: the answer turns out to be surprisingly difficult to get, and requires numerical approximation
12:58:51 <cjs> You know, I'm just feeling glad that for a first try, we got an easy one....
12:58:53 <ski> maybe cjs
12:59:57 <gwern> dunno. think I would've preferred a more algorithmic one. I'm bad with parsing and state and network
13:00:15 <vixey> ST is really weird
13:01:04 <vixey> this is a bit rubbish http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Control-Monad-ST.html
13:01:05 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/589hsf
13:01:29 <shepheb> vixey: it's trying to give mutable structures without all the other evil of IO
13:02:18 <cjs> "Prepare for the worst!" Aiieee!
13:02:29 <ski> why's it weird ?
13:02:51 <cjs> gwern: Well, it plays to my (admittedly rather limited) strengths.
13:02:57 <vixey> because it does exactly what shepheb said
13:02:58 <noecksit> > return (\a b -> a + b) `ap` (Right 1) `ap` (Left "error") :: Either String Int
13:02:59 <vixey> in haskell..
13:02:59 <lambdabot>  Left "error"
13:03:27 <noecksit> i think i finally am understading Either better as a monad
13:03:34 <cjs> Wow, but this is serious: "Because the controller program is sensitive to network latency, you should disable Nagleâ€™s algorithm for the socket."
13:03:48 <ski> vixey : have you seen Clean yet ?
13:04:05 <vixey> I read a tutorial about it but I've never used it
13:04:20 <shepheb> vixey: it guarantees evaluation order and doesn't let you keep old copies of the structures, so mutation is safe.
13:04:25 <noecksit> > return (\a b -> a + b) `ap` (Right 1) `ap` (Left "error")
13:04:26 <lambdabot>  Left "error"
13:04:30 <mauke> TCP_NODELAY
13:04:51 <noecksit> huh, so u dont need a type constructor when your output is Left I guess
13:05:13 <Igloo> That's something I think I'd have announced in advance if I was organising the tournament
13:06:02 <vixey> > cycle "crÃ¨me de la "
13:06:03 <lambdabot>  "cr\232me de la cr\232me de la cr\232me de la cr\232me de la cr\232me de la ...
13:06:08 * vixey sighs
13:06:46 <mauke> > "Î‘Î’Î™"
13:06:47 <thetallguy> vixey: nice.
13:06:47 <lambdabot>  "\913\914\921"
13:06:48 <vixey> Text.PrettyPrint or whatever this is surely supports unicode
13:06:48 <lambdabot> thetallguy: You have 1 new message. '/msg lambdabot @messages' to read it.
13:07:31 <vixey> I don't really understand how the rank 2 two type ensures safety, but I haven't thought about it yet
13:07:46 <dolio> Type safety of what?
13:07:50 <mauke> runST
13:07:51 <ski> `ST'
13:08:06 <vixey> oh I suppose that it stops you doing runST on anything which ends up having strefs left over
13:08:11 <vixey> so that's quite straightforward infact
13:08:17 <dolio> Yeah.
13:08:56 <dolio> It prevents you from doing other stuff, too.
13:09:03 <vixey> which other things ?
13:09:21 <mauke> misnesting ST
13:09:30 <dolio> Like 'runST (newSTRef 1 >>= \r -> runST (readSTRef r))'
13:09:38 <dolio> Missing a return in there, probably.
13:09:44 <osfameron> hmmm, icfp is daunting as always. should've got together with a team
13:10:22 <vixey> oh
13:10:56 <dolio> Anyhow, the phantom type on r is set to, say, s by the outer runST, whereas it needs to be 'forall t. t' to run in the inner runST.
13:11:23 * vixey nod
13:11:31 <noecksit> osfameron : its still something fun to do without a team
13:11:42 <vixey> hi grahamhutton :)
13:11:52 <grahamhutton> hi vixey!
13:12:43 <cjs> Igloo: but you could argue that it would have been giving away something....
13:12:56 <Vq^> evening mr Hutton
13:13:03 <cjs> Anyway, if you can't do this in your language, it's clearly lame.
13:13:13 <cjs> BTW, how do you do that in Haskell? :-)
13:14:05 <mauke> http://haskell.org/ghc/docs/latest/html/libraries/network/Network-Socket.html#5
13:14:06 <lambdabot> Title: Network.Socket, http://tinyurl.com/fkdb4
13:15:08 <gwern> mauke: is Network too high level?
13:15:14 <noecksit> i really hope that Either will sometime be an instance of Applicative, is would it be hard to write it?
13:15:16 <gwern> I was going with that instead of Network.Socket
13:15:17 <mauke> dunno
13:15:29 <vixey> noecksit: <*> = a
13:15:30 <vixey> noecksit: <*> = ap
13:15:33 * gwern isn't entirely convinced that textual socket io will be a bottleneck
13:15:52 <Igloo> cjs: You could, but if I was running it I think I would have announced it
13:15:59 <cjs> Network is too high-level.
13:16:00 <noecksit> vixey : i know, i just had all my functions in applicative when I was using Maybe and now i have to rewrite it
13:16:21 <vixey> I don't think you have to rewrite it
13:16:23 <atp> noecksit: isn't any monad an applicative
13:16:23 <Heffalump> noecksit: vixey means that you can make an Applicative instance using that definition
13:16:43 <atp> pure = return, (<*>) = ap
13:16:54 <atp> i think there's already such an instance, isn't there?
13:16:54 <noecksit> oh, i see
13:17:06 <dolio> instance Applicative (Either e) where return = Right ; Left e <*> _ = Left e ; _ <*> Left e = Left e ; Right f <*> Right x = Right (f x)
13:17:07 <atp> instance Monad m => Applicative m
13:17:11 <atp> or something?
13:17:29 <Heffalump> atp: I doubt it, that would cause overlapping problems
13:17:32 <cjs> Anyway, Haskell wins again. I almost feel sometimes like I'm programming in C. (In a good way.)
13:17:39 <dolio> I wouldn't define it from Monad, because that restricts you to Error e =>, but that's just me.
13:17:54 <atp> Heffalump: hm, like what?
13:17:57 <vixey> I think I will try to have a term rewriting interpreter, a HOAS interpreter and compiler to JVM or something else
13:18:12 <Heffalump> atp: well, it's not Haskell 98, for one thing.
13:18:24 <atp> ok, and the real problems?
13:18:25 <cjs> And then I discover the PortNum takes a Word16 in *machine-order*, rather than network order.....
13:18:36 <mauke> atp: it will conflict with every other Applicative instance
13:18:44 <Heffalump> it won't exactly conflict, but it confuses things
13:19:05 <atp> are there any situations where an applicative functor that is also a monad is defined in a way not consistent with pure = return ; (<*>) = ap ?
13:19:14 <Heffalump> because resolution now depends on whether a type variable has been instantiated or not during type-checking
13:19:29 <noecksit> Applicative is not necessarily a monad right?
13:19:37 <atp> noecksit: no, but every monad is applicative
13:19:47 <Heffalump> atp: Malcolm Wallace mentioned some case on the libraries mailing list, but others seemed to think that what he was doing was a bad idea.
13:20:10 <atp> i would be extremely confused if a type behaved one way as applicative and one way as monad...
13:20:49 <noecksit> atp : then why even have return and ap when you could just use pure and <*>?
13:21:04 <atp> noecksit: because sometimes you want to use it as a monad
13:21:14 <dolio> Because Applicative was invented after the monad libraries were already written.
13:21:48 <Heffalump> we really need class aliases
13:21:56 <atp> noecksit: you'll find that a large number of functions are repeats of each other
13:22:03 <noecksit> so what is the case where something is Applicative but is not a monad?
13:22:06 <atp> noecksit: try counting how many map functions there are
13:22:08 <Peaker> if we could say how classes are themselves instances of other classes....
13:22:23 <noecksit> atp : yea true
13:22:34 <Vq^> we also need a class for all those arr/pure/return/embed thingies
13:22:41 <Peaker> Heffalump: what are class alises?
13:22:45 <edwardk> atp: you can't do the instance Monad m => Applicative m without requiring overlapping instances which makes things very very ugly
13:22:55 <noecksit> sometimes thats a good thing though since it lets you apply ideas from previous knowledge
13:23:12 <Peaker> edwardk: why is that ugly?
13:23:17 <dolio> Oh, it's edwardk.
13:23:22 <atp> edwardk: hm, i guess i'll have to think about it, i'm not sure i understand
13:23:24 <dolio> I've a question for you.
13:23:52 <edwardk> peaker: because if you forget to include a module you can get different behavior. overlapping instances don't always resolve the way you expect
13:23:55 <edwardk> dolio: shoot
13:23:57 <atp> noecksit: sure, but after a while you can't help wondering why things were structured the way they were...
13:24:01 <dolio> Is 'para f = hylo f (fmap dup . out) where dup = id &&& id' correct? It doesn't seem type correct to me.
13:24:11 <edwardk> dolio: probably not =)
13:24:15 <Peaker> edwardk: I think its reasonable to expect overlapping instances to behave in the same ways?
13:24:28 <atp> dolio: you mean outF?
13:24:34 <dolio> Yeah.
13:24:36 <edwardk> peaker: check the mailing list i think iavor posted up a well known counter example recently
13:24:54 <Heffalump> Peaker: a haskell' proposal
13:25:06 <atp> @instances Applicative
13:25:07 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
13:25:18 <dmhouse> http://repetae.net/recent/out/classalias.html
13:25:19 <lambdabot> Title: Class Alias Proposal for Haskell
13:25:23 <edwardk> dolio: i grabbed it from a paper and didn't typecheck it and probably broke it in translation. i'll fix it up
13:25:26 <atp> @instances Applicative a
13:25:26 <lambdabot> Couldn't find class `Applicative a'. Try @instances-importing
13:25:29 <noecksit> @src <$>
13:25:29 <lambdabot> f <$> a = fmap f a
13:26:20 <dmhouse> ?instances Applicative
13:26:21 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
13:26:23 <atp> noecksit: re: applicative but not Monad, there are a bunch, looking at the instance definitions will show you a few, like ZipList
13:26:36 <dolio> Okay.
13:26:40 <dmhouse> ?instances-importing Control.Applicative Applicative
13:26:41 <lambdabot> ((,) a), ((->) a), Const m, IO, Maybe, WrappedArrow a b, WrappedMonad m, ZipList, []
13:27:01 <atp> i like <$>
13:27:03 <atp> <$> is the win
13:27:14 * vixey likes .
13:27:22 * atp too
13:27:23 <noecksit> atp : oh yeah, ZipList is a big one
13:27:31 <edwardk> I currently spend a lot of time in category-extras explicitly avoiding overlapping instances, because when they screw up its a pain in the ass ;)
13:27:32 <atp> noecksit: really there are lots though
13:27:55 <edwardk> which means you can't do the simple things like instance Bifunctor f => Functor (f a), etc.
13:27:59 <atp> hey edwardk, speaking of which, what's your covariant functor typeclass called?
13:28:07 <atp> err
13:28:09 <atp> contravariant?
13:28:11 <edwardk> contravariant you mean?
13:28:14 <atp> yeah
13:28:15 <edwardk> ContraFunctor I think
13:28:36 <atp> yesterday someone on here was playing with that and i said i was sure you'd defined one, but we couldn't remember what it was called
13:28:41 <edwardk> there is also CFunctor in Control.Functor.Categorical that can be instantiated as a functor from Dual Hask.
13:28:55 <atp> so now what was the deal with PFunctor and QFunctor again?
13:29:00 <atp> it was to define BiFunctor right?
13:29:20 <atp> is this also an attempt to avoid overlapping instances?
13:29:22 <edwardk> sometimes you can't infer the type of the left or right hand category, so PFunctor and QFunctor allow you to use first or second in those scenarios
13:29:36 <edwardk> not for overlapping instances, just the need to define a signature that you can't actually define ;)
13:29:44 <atp> ah...
13:30:09 <edwardk> i seem to recall that i couldn't even give a signature for bicata and biana without those
13:30:12 <atp> so if the left hand category is undefined, what's first in that situation?
13:30:22 <atp> maybe i should just go look
13:31:04 <edwardk> the problem was you just couldn't give a type for the Bifunctor instance because it referenced a type you didn't use
13:31:48 <atp> hm
13:32:12 <edwardk> any attempt to use the function wanted you to supply a type signature that you couldn't actually give ;)
13:32:12 <atp> so is pfunctor for when you don't use the left type, and qfunctor for the right?  i can't find the haddock docs online right now, kick google
13:32:41 <atp> oh, i found it,  http://comonad.com/haskell/category-extras/dist/doc/html/category-extras/
13:32:43 <lambdabot> Title: category-extras-0.53.6: Various modules and constructs inspired by category theo ..., http://tinyurl.com/58ftkr
13:32:47 <edwardk> iirc PFunctor gave first and QFunctor gave second, so its flipped around from that
13:33:53 <atp> yeah, pfunctor gives first and qfunctor second
13:34:22 <edwardk> the term PFoo came from ghani and johann's use of PMonad for parameterized monads which when the second argument was fixed yielded a monad, so i was able to consistently use P
13:34:49 <edwardk> and its fairly common to refer to the arguments of a bifunctor as p and q so that much at least makes some sort of syntactic sense.
13:34:56 <atp> yeah
13:35:32 <atp> ooh, zap
13:35:36 <atp> dual of zip?
13:35:39 <edwardk> not quite
13:35:41 <dibblego> skippycostin_, how is Haskelling?
13:35:48 <edwardk> cozip is dual of zip ;)
13:36:01 <atp> cozip is not very useful i imagine?
13:36:02 <edwardk> zap is sort of a weaker concept than adjunction that i came up with on my blog a while back
13:36:13 <edwardk> cozip is plenty useful i have a post on it somewhere
13:36:13 <atp> yeah, i seem to remember something about that
13:36:19 <atp> really?
13:36:31 <edwardk> http://comonad.com/reader/2008/cozipping/
13:36:33 <lambdabot> Title: The Comonad.Reader » Cozipping
13:36:35 <atp> cozip :: [a] -> [b] -> [Either a b] basically, right?
13:36:48 <vixey> cozip ?!
13:37:00 <edwardk> class Functor f => Cozip f where cozip :: f (Either a b) -> Either (f a) (f b)
13:37:07 <atp> i mean, with [] replaced by endofunctors with a least fixed point
13:37:26 <skippycostin_> hey dibblego.  yeah it's pretty cool.  i am doing a little java tonight because i am trying to finish a project, but i've been going through the tutorial.  i did want to ask about something though.  say if you did something like "map (+1) [0..9]" does it get converted into a loop of some kind at the very low level?
13:37:28 <atp> Either (f a) (f b) ?
13:37:29 <atp> hm
13:37:52 <atp> oh i see
13:38:02 <edwardk> counzipping is universal cozipping is not. just like you can always unzip, but not always zip for any functor
13:38:14 <dibblego> skippycostin_, no that is not a loop, because of the way it is written; instead it is "lazily evaluated". To make it "effectively use a loop", you'd use the foldl (or foldl') function
13:38:18 <atp> because zip :: [a] -> [b] -> [(a, b)] is isomorphic to ([a], [b]) -> [(a, b)]
13:38:22 <skippycostin_> dibblego: another thing i like about it is how closely related to maths it is
13:38:32 <edwardk> yeah
13:38:34 <dibblego> skippycostin_, head (map (+1) [3, error "you won't see this!"])
13:38:39 <dibblego> > head (map (+1) [3, error "you won't see this!"])
13:38:41 <lambdabot>  4
13:38:42 <atp> so it really is sort of distributive
13:39:05 <edwardk> yeah there are also strength laws and costrength laws that act like distributive properties
13:39:18 <atp> aren't all categories in haskell strong though
13:39:20 <edwardk> iirc those are in control.functor.strength or control.functor.strong
13:39:23 <atp> i seem to recall something about that
13:39:27 <edwardk> All fucntors in Haskell are strong
13:39:32 <atp> right, functors!
13:39:32 <edwardk> but not all functors are costrong
13:39:37 <dibblego> skippycostin_, it's a very practical language ;)
13:39:50 * atp isn't sure about costrength yet.
13:39:53 <edwardk> only the traversable ones (and maybe some other perverse ones you could come up with)
13:40:00 <atp> so if zip is an anamorphism, is cozip an apomorphism?
13:40:02 <skippycostin_> dibblego: i getcha
13:40:11 <edwardk> @type fmap . (,)
13:40:12 <skippycostin_> laziness... i love that
13:40:13 <lambdabot> forall a (f :: * -> *) a1. (Functor f) => a1 -> f a -> f (a1, a)
13:40:18 <edwardk> thats strength
13:40:49 <atp> hm, i'm not sure i follow :/
13:41:16 <edwardk> class Functor f => Costrong f where costrength :: f (Either a b) -> Either a (f b) -- decides whether or not there are any a's in your f, and if so gives you one.
13:41:20 <edwardk> you can't do that in general though
13:41:31 <atp> oh, i see.
13:41:48 <atp> so wait, what's an example of a category-theoretic functor that isn't strong?
13:42:11 <atp> (as opposed to a functor in category Hask)
13:42:23 <edwardk> in the case of strength, you can use the fact that we reduce asymmetrically with a bias that enables us to use the environment in function application so you can always fmap and drop the extra term in next to every location already in the functor mainly because we are lazy.
13:42:47 <atp> right, that makes sense.
13:42:58 <edwardk> move to Hask-Op, then in that category there are plenty ;)
13:42:58 <atp> so strength is a result of laziness then...
13:43:06 <atp> Hask-Op ?
13:43:26 <edwardk> the dual category of hask, then you are asking a question about what functors are not costrong in Hask ;)
13:43:27 <monochrom> Hask-Op is probably a nice category.
13:43:39 <atp> oh i see.
13:43:55 <edwardk> its not quite a CCC, but is a full Co-CCC.
13:44:14 <vixey> if it was CCC and Co-CCC it would be boring !
13:44:43 <edwardk> its products fail to be monoidal (since hask's coproduct isn't comonoidal, it lacks a unit since there is no initial object for haskell, since every type is inhabited by _|_)
13:45:01 <atp> hm
13:45:36 <edwardk> anyways things that fail to be costrong include streams since you can show you'd need an oracle for the halting problem, or pretty much any 'exponential' functor that includes a function
13:45:37 <atp> right, so unit is inhabited by two values
13:45:53 <edwardk> and more importantly even data Void is inhabited by bottom
13:46:11 <atp> hm
13:46:15 <Peaker> @unpl fmap . (,)
13:46:16 <edwardk> so you lack a unit for Either, since there is no type X such that Either X a -> a can safely always know it will receive a 'Right a'
13:46:16 <lambdabot> (\ c -> fmap (((,)) c))
13:46:47 <atp> right, of course
13:46:48 <atp> that makes sense
13:46:49 <vixey> in data Maybe a = Nothing | Just a, what do you call 'Maybe a' ?
13:46:59 <edwardk> with a baked in call-CC to the language you can play devil's bargain games to make a costrength, you can get away with that in lisp.
13:47:07 <atp> vixey: the type constructor
13:47:15 <vixey> it's not a type constructor though..
13:47:30 <atp> vixey: oh, you mean the whole thing?
13:47:33 <dibblego> edwardk, does category-extras contain a contra-variant Functor/Monad?
13:47:35 <atp> edwardk: really?
13:47:35 <vixey> I mean 'Maybe a' including the a
13:47:37 <edwardk> basically you return a data structure such that if it ever had to give you back an a 'goes back in time' and calls your other continuation saying oh here's an 'a'! nevermind all that work you were doing ;)
13:47:58 <edwardk> dibblego: Functor Yes, Monad No.
13:48:00 <monochrom> "Maybe a" is a type.
13:48:07 <dibblego> edwardk, what shall I grep for?
13:48:09 <edwardk> er not lisp, scheme
13:48:30 <atp> edwardk: how would you represent these things in an untyped language?  functional representations?
13:48:37 <edwardk> dibblego: http://comonad.com/haskell/category-extras/dist/doc/html/category-extras/Control-Functor-Contra.html
13:48:39 <lambdabot> Title: Control.Functor.Contra, http://tinyurl.com/55ryzq
13:48:45 <dolio> (The functor component of) Monads are endofunctors, so I don't know what a contravariant monad would be.
13:48:53 <vixey> specifically Just a :: Maybe a, and Nothing :: Maybe a
13:49:01 <dibblego> edwardk, great thanks
13:49:38 <edwardk> vixey: the type? =)
13:49:58 <vixey> well I can't call a variables 'type' in haskell
13:50:09 <dibblego> edwardk, is there a reason for the absence of a contra-variant monad? just haven't got to it yet?
13:50:09 <atp> they're type variables
13:50:12 <vixey> but I do call about a thousand other things typ or type' or whatever
13:50:19 <edwardk> dibblego: um, have any examples of one?
13:50:26 <dibblego> edwardk, nope :)
13:50:37 <edwardk> dibblego: you could build one if you can think of one using CFunctor and CMonad in Control.Functor.Categorical
13:50:51 <edwardk> i can't see how one would work with the monad laws though
13:51:03 <dibblego> I am thinking of a comonad type-class
13:51:16 <edwardk> i have comonads, but those are not contravariant monads
13:51:17 <atp> dolio's point about monads being endofunctors does seem to make contravariant monads untenebal
13:51:18 <dibblego> coreturn :: m a -> a -- for example
13:51:24 <atp> untenable even
13:51:25 <dibblego> oh ok, sorry boot that
13:51:43 <dolio> There are comonads, but that doesn't stand for contravariant monad.
13:51:49 * vixey guesses there is no name for this -_-
13:51:57 <dibblego> dolio, I didn't realise that
13:52:09 <edwardk> vixey: well if you include the universal quantification over the 'a' it really is a type, no?
13:52:17 <atp> dibblego: the co-prefix usually indicates that something is the categorical dual of something else
13:52:21 <dolio> I'm sure he has a comonad class. :)
13:52:26 <edwardk> dibblego: what you want almost works but the map for the functor fails
13:52:28 <rwbarton> dibblego: A comonad is a monad on the opposite category.
13:52:32 <vixey> edwardk: yeah, I hereby declare it be called the declaredType :)
13:52:39 <rwbarton> dibblego: A contravariant functor has only the domain category replaced with its opposite.
13:53:14 <atp> hm
13:53:30 <atp> right, so since a monad is an endofunctor, ie, a functor from C onto itself,
13:53:40 <atp> a contravariant monad doesn't make sense really
13:53:43 <dibblego> ok thanks for the help guys
13:53:43 <atp> unless C = C^op
13:53:52 <atp> in which case the two coincide?
13:53:53 <edwardk> no problems
13:54:32 <atp> rwbarton: what do you call a functor with the codomain replaced by the opposite category?
13:54:33 <dolio> Those would probably be pretty boring categories.
13:54:38 <atp> yeah
13:54:44 <dolio> Categories where every morphism is an isomorphism?
13:54:54 <rwbarton> atp: Also a contravariant functor.
13:54:59 <atp> yeah, they'd have to be i guess
13:56:13 <atp> i remember really struggling with the covariant/contravariant distinction in tensor analysis back in uni
13:56:19 <atp> what's the difference?
13:56:39 <atp> and the teacher (a physicist, not surprisingly) said "it's whether the little i is on the top, or on the bottom"
13:56:47 <edwardk> atp: i usually remember it from covariance and contravariance in inheritance
13:56:48 <atp> that's about when i decided i needed to switch to math :p
13:57:27 <atp> edwardk: my background isn't really CS, so i'm not sure what you mean...
13:57:36 <dibblego> sorry I had to run (the inevitable time has come for me to start whitelisting the websites my children visit)
13:57:44 <atp> why?
13:57:57 <atp> are the looking at pornografia?
13:58:00 <dmhouse> Whitelist, ouch.
13:58:01 <edwardk> the idea in general when you deal with object oriented programming is that a subclass's methods are allowed to 'do more' or 'require less' you can make the arguments to your methods more general or you can make the return type more specific.
13:58:02 <atp> they?
13:58:22 <dibblego> they are and they don't know it
13:58:32 <edwardk> you can weaken the precondition or strengthen the post condition
13:58:44 <lament> subclass slaves do more and require less!
13:58:44 <atp> right, this has to do with the lsp iirc
13:58:52 <atp> but i don't know much about CS
13:58:57 <edwardk> now when you make object hierarchies this yields somewhat counter intuitive results
13:59:04 <atp> and i try to avoid OOP
13:59:09 <atp> if i can help it :)
13:59:42 <tromp> > ()
13:59:43 <lambdabot>  ()
13:59:46 <edwardk> if you make a person class and then subclass it with a baby, and then make food  and then try to subclass it to make baby-food you can't make it so that the baby can only eat baby-food. so contravariance yields what a lot of computer science types thing of as a counter intuitive result
13:59:59 <edwardk> er think
14:00:04 <tromp> ~.
14:00:05 <tromp> ~.
14:00:07 <tromp> 
14:00:07 <tromp> 
14:00:07 <tromp> 
14:00:10 <tromp> 
14:00:19 <atp> tromp?
14:00:19 <tromp> 
14:00:22 <tromp> 
14:00:24 <tromp> 
14:00:24 <edwardk> so you either have to make a person a subtype of baby or food a subtype of baby-food to get the desired behavior.
14:00:25 <atp> someone kick?
14:00:26 <mauke> heh
14:00:29 <atp> ah.
14:00:40 <mauke> ~. is ssh disconnect
14:00:44 <pejo> ~. is disconnect :-)
14:00:49 <atp> ha
14:00:51 <pejo> Doh, too slow again!
14:01:02 <edwardk> or you have to go back and redesign this thing so that you are thinking about parallel class hierarchies. which is an argument i got into with tim sweeney about several years back
14:01:09 <edwardk> i think there is a version of it online actually, hrmm
14:02:11 <edwardk> http://www.flipcode.com/archives/Harmless_Algorithms-Issue_03_Design_Patterns_And_3D_Gaming.shtml gives a description of how to do parallel class hierachies in C++ from an old online game programming mag i used to write stuff up on
14:02:13 <lambdabot> Title: flipcode - Harmless Algorithms, http://tinyurl.com/5lwf72
14:02:52 <edwardk> mainly wrote it because sweeney was calling for a brand new language feature to encompass this idea when it was readily realizable by the machinery we already had.
14:02:59 <dolio> Heh, the boilerplate pattern.
14:03:35 <atp> hm, i'll take a look... it's been many years since i've written an C++
14:03:35 <edwardk> the funny thing is that name survived and can be found in a bunch of design pattern reference manuals now. ;)
14:03:46 <pejo> edwardk, a new feature might be better (in a different sense than "more powerful") though.
14:04:00 <BMeph> edwardk: Have you considered making a CT tutorial out of your blog posts? I'd appreciate not having to curl-scrape it up... :)
14:04:14 <edwardk> bmeph: i plan to at some point
14:04:40 <edwardk> bmeph: whether as a tutorial or a book or whatever, we'll see
14:05:03 <atp> i think your field guide is a good start
14:05:08 <edwardk> it will be
14:05:16 <edwardk> though the organization of the field guide is wrong for a tutorial
14:05:25 <atp> i don't know...
14:05:40 <atp> recursion schemes are a good gateway drug to category theory
14:05:52 <edwardk> well, the later recursion schemes are pretty damn scary ;)
14:06:07 <BMeph> atp: Haskell is a great gateway drug to CVT, I'd say. :)
14:06:08 <atp> yeah, i saw... sychromorphisms?
14:06:11 <edwardk> heh
14:06:16 <BMeph> s/CVT/CT/
14:06:26 <edwardk> also synchro as implemented in my library is subtly wrong
14:06:37 <edwardk> because the definition for dialgebra in category-extras is too weak
14:06:45 <atp> BMeph: haskell is putting the CS back into CS i think... for the last decade it's been java trade school at a lot of unis it seems
14:06:59 <edwardk> atp: very well said
14:07:23 <atp> it seems we're getting the beginnings of swing back to dijkstra & co
14:07:33 <atp> one can hope :)
14:07:47 <edwardk> i can't begin to recount the number of people i've met who seriously have confused the distinction between programmer and computer scientist.
14:07:50 <jamii> Does anyone know if its possible to make haddock show the default functions for class methods?
14:08:16 <atp> edwardk: yeah, same here.  the sad thing is, universities are making the mistake, not just laypeople
14:08:31 <edwardk> yeah
14:08:43 <edwardk> thats because more and more 'professors' are just programmers with tenure ;)
14:09:34 <atp> i don't really understand the anti-intellectualism that seems so common in the programmer world these days
14:09:47 <atp> when i read reddit sometimes it just makes me really sad
14:09:57 <dolio> Yeah, I don't get that, either.
14:10:04 <pejo> atp, many are self taught with an aversion for schooling, for example.
14:10:19 <atp> pejo: an aversion for schooling should not translate into an aversion for knowledge
14:10:29 <atp> pejo: which is how it manifests itself
14:11:43 <edwardk> yeah i do a lot of work for a guy who thinks of himself as a computer scientist but can't seem to wonder why i hang my head when he can't be bothered to think about the difference between n and n^2 and just knows that when i write things they run instantaneously and when he writes them the run for hours.
14:12:04 <vixey> sequence . repeat $ newSTRef Nothing
14:12:04 <vixey> I found out that doesn't work
14:12:04 <vixey> it tries to make them all
14:12:12 <edwardk> even when its 'just SQL' the asymptotics catch up to you eventually ;)
14:12:18 <atp> yeah.
14:12:37 <atp> but i mean, i don't mind people being ignorant, because we're all ignorant about something... it's more that they seem to celebrate it
14:12:49 <dolio> repeatM doesn't work in most monads.
14:12:59 <dibblego> atp, and fail to address it should it come to their attention
14:12:59 <atp> or that when confronted by something they don't understand, they belittle you for understanding it, or trying to
14:13:31 <atp> i think it may have something to do with the combative/competitive/alpha geek attitude that for better or for worse many programmers have
14:13:46 <lament> mm
14:13:48 <vixey> @src repeatM
14:13:48 <lambdabot> Source not found. It can only be attributed to human error.
14:13:50 <vixey> :t repeatM
14:13:51 <kig> or that when they understand something, they use greek terms to aggrandize it :/
14:13:51 <lambdabot> Not in scope: `repeatM'
14:13:56 <edwardk> atp: yeah. ignorance is forgivable. I'll explain anything once or twice its the deliberate aversion to knowledge that should be punished ;)
14:14:03 <lament> kig: even greek letters :(
14:14:08 <vixey> kig: like lambda? :P
14:14:08 <atp> they want to be right and they want to be the most knowledgeable, and when they don't understand something they try to make like it's not important to understand it
14:14:12 <dolio> vixey: That's why it doesn't exist. :)
14:14:20 <vixey> dolio: oh, hehe
14:14:42 <lament> ignorance is forgivable, taking pride in ignorance should be punished by death... unless it's ignorance of Perl or C++ :)
14:14:44 <vixey> hm I don't know how to do this then
14:14:47 <dolio> vixey: I think (->) r is one of the few where it does work.
14:14:51 <edwardk> kig: to be quite honest a lot of mathematicians use greek letters because when you are writing on a blackboard a shorthand is convenient and to people steeped in the background it helps ELIMINATE confusion.
14:15:05 <atp> i like greek letters
14:15:15 <atp> there are only 26 latin ones
14:15:15 <atp> 52 with caps
14:15:20 <atp> it's clearer than using primes and substcripts all the time
14:15:20 <edwardk> kig: i use phi and psi for algebras and coalgebras as a form of mathematical hungarian notation reminding me what the hell those things are.
14:15:38 <dolio> vixey: Why do you need an infinite number of STRefs?
14:15:53 <vixey> dolio: oh I only need a finite number, I just don't know which finite number
14:15:55 * ddarius simply uses 'x' for everything and lets context remove ambiguity.
14:16:16 <atp> ddarius: what if your expression has two distinct quantities?
14:16:17 <vixey> I can easily calculute an upper bound
14:16:30 <ddarius> atp: Which x is meant where will be clear from context.
14:16:39 <edwardk> the issue is that what ddarius thinks of as unambiguous requires a Ph.D to know all of the reasons why it is unambiguous ;)
14:16:40 <atp> hm
14:16:46 <lament> ddarius: x x xx x xxxx x x x x xxx x xxx x xx x xx x x x x.
14:16:49 <kig> yeah, it's a jargon, which are okay. just makes for a bit higher barrier for entry
14:16:54 <rwbarton> "unsafeInterleaveST"?
14:17:12 <atp> kig: when you're dealing with things of sufficient complexity, the barrier to entry is going to be a base knowledge that requires work to attain regardless
14:17:17 <vixey> kig: whether they use funny shaped symbols or familiar shaped symbols.. it'll still make no sense at all
14:18:43 <kig> "there's a reason it's called math and not creative writing", or something like that
14:18:55 <atp> kig: creating writing is harder for me than math
14:19:08 <atp> kig: everyone has their strengths
14:19:12 <atp> kig: (or weaknesses)
14:19:12 <vixey> atp: You can't be doing very interesting math then ...
14:19:43 <ddarius> vixey: Perhaps you aren't doing very interesting creative writing.
14:21:10 <atp> vixey: hm, i'm trying to figure out if that was meant to be a joke?
14:21:11 <edwardk> the main thing i like about math is that the material (especially as presented by a university) tends to be of constant difficulty. you keep climbing and everything is incremental. in a creative writing class if you miss one idea you aren't screwed, but in a math course? you constantly work on expanding your foundation to reach new heights.
14:21:47 <edwardk> after mathematics most other disciplines that universities try to put on equal footing with it seem like a collection of locally applicable tricks.
14:22:06 <ddarius> edwardk: That's what lower levels of mathematics look like.
14:22:20 <ddarius> (oftentimes)
14:22:29 <atp> math is pretty artistic i think, in a lot of ways
14:22:57 <Maddas> Anyone here doing the ICFP contest?
14:23:02 <edwardk> ddarius: sure after you reach a point there are just a few narrow valleys to get through (lesbegue measure, etc) to get to the good stuff, and then it flattens out., but it flattens out a lot later than a lot of the other disciplines I've been exposed to.
14:23:19 <edwardk> maddas: i thought about it until i saw the problem and then became singularly uninterested ;)
14:23:32 <atp> measure theory wasn't particularly difficult i didn't think...
14:23:32 <Maddas> :/
14:23:41 <atp> cohomology made my brain hurt
14:23:41 <Peaker> I see art as the mere exploitation of brain vulnerabilities :)
14:23:54 <atp> but in a good way.
14:23:58 <Peaker> good artists can identify and exploit the brain better than others :)
14:24:09 <vixey> hey jbapple
14:24:09 <edwardk> atp: its not difficult, its just places where you have to graft on a whole new set of tools onto your way of thinking. cohomology is another good example.
14:24:11 <Maddas> Peaker: why 'mere'?
14:24:30 <kig> is catamorphism a foldr?
14:24:38 <edwardk> kig: the short answer is 'yes' =)
14:24:41 <atp> kig foldr is a catamorphism :)
14:24:42 <Peaker> Maddas: well, I get the impression that people think art is "beyond" that
14:24:43 <kig> yay :)
14:24:44 <vixey> foldr is a catamorphism
14:24:54 <jbapple> vixey: yo
14:25:00 <mauke> the short answer is "no". the long answer is "yes".
14:25:00 <edwardk> kig: catamorphisms generalize foldr to other functors than just lists.
14:25:03 <Maddas> Peaker: Is anything beyond 'brain exploitation' in the general sense? :-)
14:25:18 <Peaker> Maddas: if god existed, maybe :)
14:25:33 <zeno> this isnt installed by default in ghc? import Data.Time.Clock; could not find
14:25:41 <ddarius> God is mere brain exploitation.
14:26:18 <mauke> it's in package time
14:26:28 <kig> (been writing some combinators and refactoring code with them, hence got interested in the morphisms)
14:26:30 <mauke> and came in the extralibs tarball
14:26:38 <atp> are you talking about God or Time?
14:27:28 <mauke> import Control.God
14:27:40 <Elly> universe monad?
14:27:48 <dancor> does that give you reflection
14:28:30 <Peaker> I think I need arrows without arr/pure
14:29:26 <Peaker> would be a shame to redefine everything
14:30:29 <jaj> oh, this years' icfp contest is sponsored by NASA
14:30:57 <Heffalump> jaj: I suspect this isn't serious.
14:31:47 <kig> it also has fourteen-fingered martians
14:32:11 <dancor> it's interesting that they don't say how they will choose the five test runs
14:32:44 <dancor> "prepare for the worst!"
14:33:21 <edwardk> mauke: yeah i was trying to fit him into category-extras but the compile time is a bitch
14:34:52 <mmorrow> why don't you just rep him as an empty data decl with a phantom type and call it good?
14:34:54 <atp> i wonder if taking the fixed point of God gives you polytheism
14:35:01 * mmorrow ducks
14:35:48 <atp> i think lambdabot should throw a tomato for effect at everyone who ducks in the channel
14:36:03 <mauke> No quack!
14:36:07 <lament> immediately before they duck
14:36:20 <zeno> is there a currently developed haskell ide?
14:36:29 <mauke> @where leksah
14:36:29 <lambdabot> I know nothing about leksah.
14:36:31 <atp> vim and emacs aren't bad
14:37:03 <mauke> @where+ leksah http://leksah.org/
14:37:04 <lambdabot> Good to know.
14:37:17 <zeno> thx
14:39:07 <Peaker> Could I say that IO's monad instance + forkIO  form some sort of arrow, or something like it?
14:39:25 <zeno> Leksah reads and writes pure ASCII Code files, but can nevertheless show you nice symbols for lambda and so on   < does this mess with indenting?
14:39:36 <Peaker> IOW, why isn't forkIO in some class extending Monad?
14:40:08 <atp> so you can do forkST?
14:40:11 <atp> or what?
14:40:19 <atp> it doesn't seem like it would be useful for most monads
14:40:22 <Peaker> so I get a warm fuzzy feeling about forkIO :)
14:41:05 <atp> i don't really see how it would be useful
14:41:14 <mmorrow> wow, that just gave me evil plans for forkIO and unsafePerformIO
14:41:31 * mmorrow cackles and wrings hands together
14:42:07 <Peaker> atp: wouldn't forkST make sense?
14:42:29 <mmorrow> Peaker: check out GHC.Prim
14:42:30 <atp> well, each instance of st has its own state
14:42:34 <atp> but i guess it could
14:42:35 <mmorrow> in particular the fork# function
14:42:45 <mmorrow> (it's not in any monad at all)
14:44:29 <ahunter> Out of curiosity, has there ever been discussion of somehow splitting the IO monad into submonads?
14:44:43 <ahunter> Like, a monad for file I/O, one for threading, one for mutable memory.
14:44:48 <ahunter> Which somehow compose to make the IO monad.
14:45:04 <ddarius> You could write: forkIO' m n = do forkIO m; n and then make an MonadPlus isntance with mplus = forkIO'
14:45:09 <ddarius> Does that make you happy?
14:45:25 <dolio> It's been disussed.
14:45:32 <mmorrow> well, ok i'm not entirely correct
14:45:33 <mmorrow> fork# :: a -> State# (RealWorld) -> (# State# (RealWorld),ThreadId# #)
14:46:18 <quicksilver> ahunter: yes. quite often.
14:46:18 <mmorrow> (but since you have the IO/ST internals exposed, unsafePerformIO is just snd (but pattern matching))
14:46:28 <quicksilver> Peaker: forkIO is useless without some way to communicate between threads.
14:46:32 <dolio> http://citeseerx.ist.psu.edu/viewdoc/summary;jsessionid=99834483C1A4AA7E3EDFB3E4999F2E96?cid=5761238
14:46:35 <ahunter> quicksilver: have we ever come to some sort of conclusion
14:46:38 <lambdabot> Title: Abstract Beauty in the Beast A Functional Semantics for the Awkward Squad - Cite ..., http://tinyurl.com/6o27wb
14:46:55 <quicksilver> Peaker: the interesting structure I guess, is forkIO + MVar, or forkIO + TVar, etc.
14:47:02 <quicksilver> Peaker: so, no, forkST doesn't make sense.
14:47:09 <quicksilver> it's useless since ST threads can't communicate.
14:47:12 <ddarius> We've come to a conclusion that it can all be done over-top IO.
14:47:25 <quicksilver> ahunter: yes, it's a good idea in principle
14:47:36 <mmorrow> ahunter: you can just wrap IO in a newtype
14:47:37 <quicksilver> ahunter: nobody has a solid suggestion of how to make it manageable in practice.
14:47:50 <mmorrow> (or newtype*s*)
14:47:51 <quicksilver> yeah, you don't need language changes, you can go and do it today if you want.
14:48:07 <quicksilver> but it's not quite obvious the best/most useful/ most effective way to partition the capabilities.
14:48:35 <quicksilver> mmorrow: fork#, of course, isn't a function. Not in the haskell sense.
14:48:44 <quicksilver> pedantic but important point.
14:48:48 <mmorrow> heh, that's true
14:49:00 <ahunter> qicksilver: true.  It'd be nice, however, if the submonads trivially composed.  I.e. if a :: File Int  and b Int -> Memory (), then a >>= b :: IO (), or some such.
14:49:01 <quicksilver> fork# belongs to GHC's underlying primitive "language which looks like haskell but isn't"
14:49:15 <quicksilver> ahunter: yes, you can do that.
14:49:15 <mmorrow> (hence the nonexistent implem)
14:49:29 <quicksilver> a :: MonadFile m => m Int
14:49:40 <quicksilver> b :: MonadMemory m => Int -> m ()
14:49:47 <ahunter> ah, have each submonad as typeclass?
14:49:55 <quicksilver> (a >>= b) :: MonadFile m, MonadMemory m => m ()
14:50:01 <ddarius> That's how the mtl works.
14:50:04 <quicksilver> which, presumably, you could instantiate at IO.
14:50:09 <ahunter> mmorrow had suggested newtype, which didn't seem to obviously work
14:50:12 <quicksilver> (since presumably IO is a member of those two)
14:50:20 <quicksilver> you need newtypes as well as classes. perhaps ;)
14:50:24 <quicksilver> depends how you do it.
14:50:50 <quicksilver> ahunter: see http://www.haskell.org/pipermail/haskell-cafe/2007-September/031795.html
14:50:54 <quicksilver> for a (simple) worked example.
14:50:56 <lambdabot> Title: [Haskell-cafe] MonadGL - Partitioning effects without giving up type inference, http://tinyurl.com/yq7aku
14:50:57 <ahunter>  thx
14:51:05 <quicksilver> I'm not claiming the idea is mine
14:51:09 <quicksilver> it's been in the folklore for ages
14:51:16 <quicksilver> (but I didn' tknow that when I wrote that message)
14:52:14 <mmorrow> you could do something like what the Quasi monad does from template-haskell but go another step and do  ==> newtype WrapIO a = WrapIO (forall m. (Monad m) => m (IO a))
14:52:33 <mmorrow> oh wait, hold on i think i messed that up
14:53:11 <mmorrow> ok, something like
14:54:15 <mmorrow> class MIO a where ...          then        newtype WrapIO a = WrapIO (forall m. (MIO m) => m a)
14:54:31 <mmorrow> where MIO coresponds to Quasi, and WrapIO to Q
14:55:01 <mmorrow> then make WrapIO and instance of Monad
14:57:04 <mmorrow> (so that's exactly what what TH does, not a step more or less)
14:57:12 <mmorrow> http://haskell.org/ghc/docs/latest/html/libraries/template-haskell/src/Language-Haskell-TH-Syntax.html
14:57:13 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/67ddnk
14:59:10 <stepcut> HsColour needs to generate better page titles
14:59:23 <stepcut> or perhaps that is haddocks fault ?
14:59:46 <mmorrow> (important) correction, s/MIO a/(Functor m,Monad m)=>MIO m/
15:03:27 <ndmitchell> stepcut: how would you suggest hscolour did that? its lazy, but if it had to wait for a module name it wouldn't be :(
15:03:43 * ndmitchell was hte person who added the current <title> tags in
15:04:48 <ndmitchell> although obviously it would be better if it did know!
15:04:59 <ndmitchell> perhaps cabal could be persuaded to pass a title flag to hscolour....
15:05:50 <stepcut> ndmitchell: that sounds reasonable
15:06:09 <ndmitchell> will suggest it to malcolm, may even patch it myself
15:06:12 <stepcut> ndmitchell: or, let (title, html) = haddock title program
15:06:16 <ndmitchell> @seen malcolmw
15:06:16 <lambdabot> I haven't seen malcolmw.
15:06:34 <ndmitchell> stepcut: ?
15:07:00 <stepcut> ndmitchell: oops, that should be, let (title,html) = hscolour title program
15:07:09 <ndmitchell> so hscolour takes in the title?
15:07:13 <ndmitchell> and gives back the title?
15:07:17 <stepcut> ndmitchell: have hscolour return the title, and then just pass in the title it returns, tada!
15:07:20 <hackage> Uploaded to hackage: uniplate 1.2.0.1
15:07:35 <ndmitchell> stepcut: still not lazy, since the html would have to block
15:07:43 <stepcut> ndmitchell: indeed
15:07:53 <ndmitchell> its a cute trick, but it certainly wouldn't work in this case, since <html><title>TITLE HERE</title>...
15:08:08 <stepcut> ndmitchell: it is perhaps, 'lazy', but not 'online'
15:08:40 <mmorrow> send a javascript onload function to find some hidden span you send last and set the title to that!
15:08:53 <ndmitchell> that would work :)
15:08:55 <ndmitchell> but yuk!
15:08:59 <mmorrow> hehe
15:09:07 <ndmitchell> plus it requires hscolour to figure out module imports etc, which is not ideal
15:09:36 <stepcut> put some affiliate links in the title, so that when people paste the links in #haskell, lambdabot reads the URL out, people click on it, and then you cash in big ?
15:10:18 <stepcut> perhaps hscolour should use the GHC API or something? I recently discovered it does not properly mark up function definitions if you are using bird notation literal haskell
15:10:48 <ndmitchell> stepcut: yuk, the GHC API is like a sledge hammer, best not swung unless you want everything destroying
15:11:06 <ndmitchell> stepcut: submit a bug report to malcolm
15:11:16 <ndmitchell> i've just emailed him to suggest the --title feature
15:11:18 <stepcut> for example, in "main = ...", the main should have the class 'definitionid' but gets 'varid' instead (or something like that)
15:11:27 <dbueno> I have a problem installing network-bytestring  when using a special-purpose --package-db argument, but not otherwise.  I'm using Cabal 1.4.0.1 and the error message is: "ghc-6.8.2: unknown package: bytestring-0.9.1.0"
15:11:42 <dbueno> FWIW it works with the Cabal 1.5 that I tried.
15:11:59 <ndmitchell> stepcut: email malcolm, he'll be able to fix it
15:12:09 <stepcut> ndmitchell: perhaps not the GHC API, but maybe some sort of proper haskell parser ?
15:12:12 <ndmitchell> or fix it yourself, the code is available, and he accepts patches
15:12:28 <stepcut> ndmitchell: well, I wrote the code to do definition highlighting in the first place, so technically, it's my bug ;)
15:12:44 <dbueno> @seen dcoutts
15:12:45 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-soc, #haskell-overflow, #ghc and #haskell. I don't know when dcoutts last spoke.
15:12:45 <ndmitchell> stepcut: no, there are many advantages to having a lexer - much less rigid adherenece to specs and acceptance of extensions
15:12:49 <stepcut> ndmitchell: and, getting it to do that was a big hack in the first place
15:14:38 <stepcut> ndmitchell: in the current implementation, the only way I could detect function declarations, was to use multi-token look-behind, to see if the variable happened to be at the beginning of a line (which is why the bird notation breaks it)
15:14:50 <mmorrow> i love the fact that HsColour doesn't actually parse it's input because it's my general purpose "anything-that-is-text-and-i-want-to-have-color" filter
15:14:56 <stepcut> seemed a bit wacky :)
15:15:43 <mmorrow> cat /dev/urandom | hexdump | head -1000 | HsColour -tty | less -r
15:15:47 <stepcut> mmorrow: true. I do like that it does not require valid Haskell. Especially when used with -lit
15:16:12 <stepcut> mmorrow: I use it to mark-up just snippets of code in blog entries that way
15:17:11 <mmorrow> i just started using -css last week, and love it. hscolour.css is so great because it's so simple
15:17:23 <stepcut> so, I am reversing my position. It should not use GHC API or a full parser. But, it would be nice if there was a cleaner way to detect function declarations
15:17:26 <ndmitchell> do you like the colours in it?
15:17:43 * stepcut uses (and wrote) the emacs.css for hscolour
15:17:44 <ndmitchell> they (surprisingly) happen to match my text editor perfectly :)
15:17:59 <stepcut> ndmitchell: which editor ?
15:18:00 <mmorrow> i tweaked it a bit, but it do like the default
15:18:00 <ndmitchell> yeah, a nice way to detect declarations would be great
15:18:07 <ndmitchell> stepcut: textpad
15:18:10 <stepcut> ah
15:18:26 <stepcut> it matches my editor perfectly when I use emacs.css ;)
15:18:26 <augustss> neil, done with the contest already?
15:19:35 <ndmitchell> augustss: heading off on a train tomorrow morning, without a laptop, no computer again til monday morning
15:19:43 <mmorrow> @seen hpaste
15:19:43 <lambdabot> I saw hpaste leaving #haskell 58m 16s ago, and .
15:19:48 <ndmitchell> and then i have my viva monday lunchtime, so not really time to fit the contest in
15:20:13 <mmorrow> http://hpaste.org/8870
15:20:48 <osfameron> noecksit: i guess. it looks rather more than a weekend's work just to understand the spec though..
15:21:12 <mmorrow> "an hscolour.css"
15:21:38 <mmorrow> @botsmack
15:21:38 <lambdabot> :)
15:22:31 <dcoutts> dbueno: mmm?
15:22:31 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
15:22:57 <vixey> does anyone have a better way to write  foldr (:->:) t ts
15:23:01 <dbueno> dcoutts, hi.  I was having a weird cabal problem (still am), so I thought I'd ask if you were around.
15:23:08 <vixey> (that'll give ts[0] -> ts[1] -> ... -> t
15:23:29 <vixey> would you write  telescope ts t
15:23:36 <vixey> or something like that?
15:23:45 <ddarius> vixey: For Pete's sake, what's wrong with that?
15:24:01 <vixey> just using foldr is good?
15:24:18 <dbueno> dcoutts, I install bytestring with custom --prefix and --package-db arguments.  Then I try to install network-bytestring with the same arguments, and it says "ghc-6.8.2: unknown package: bytestring-0.9.1.0"
15:24:20 <ddarius> Yes.
15:24:29 <vixey> ok
15:24:49 <dcoutts> dbueno: hmm
15:25:14 <dbueno> the problem goes away with cabal 1.5.  This is with cabal 1.4.0.1.  I wondered if there was a workaround, but, I guess it doesn't matter since I have to get it to work with cabal-1.2.3.0, which doesn't even understand the --package-db argument.
15:25:23 <dcoutts> dbueno: I think that's a bug Igloo fixed in Cabal HEAD today
15:25:40 <dcoutts> dbueno: I should back-port it to 1.4.x
15:26:09 <dbueno> dcoutts: It must have been fixed earlier, or at least partly, since one of the 1.5s I had installed worked.
15:26:18 <dbueno> I haven't installed cabal 1.5 in weeks.
15:26:19 <dcoutts> dbueno: oh, that's odd
15:26:34 <dcoutts> I didn't think we'd made any change in that area
15:27:05 <dcoutts> dbueno: use -v, see if you can spot the difference, that should help us see what's going on
15:27:13 <dcoutts> if it's the fix I was thinking of or not
15:27:24 <dbueno> dcoutts: -v to ... configure or build?
15:27:28 <Igloo> I think I fixed that a week or two ago, if it's what I think it is
15:28:15 <dcoutts> Igloo: passing the -package-conf flag to ghc when Cabal is told to use a custom package db
15:28:48 <Igloo> Thu Jul  3 01:12:16 BST 2008  Ian Lynagh <igloo@earth.li> * Fix using specified package databases
15:31:25 <dbueno> dcoutts: Does GHC know to fall back on the global config if it doesn't find something in the -package-conf one?
15:31:35 <dbueno> er, in the explicitly specified one
15:33:48 <dbueno> dcoutts: Yeah, during the build it prints which package.conf's it's using.
15:33:52 <dbueno> And it's not using the one I told it to
15:40:08 <lilachaze> does "hSetBuffering h NoBuffering" on a Handle representing a network socket turn of Nagle's algorithm?
15:40:13 <lilachaze> *off
15:42:53 <dcoutts> dbueno: are you using Cabal-1.4.x darcs version? if so you can check if the patch fixes it
15:43:13 <dbueno> dcoutts: You just patched it?  I have the darcs version, but I tested the released version.
15:44:00 <dbueno> I'm pulling the changes....
15:44:02 <dcoutts> dbueno: I'm just moving the patch Igloo applied to head into the 1.4 branch
15:44:17 <dcoutts> wait a sec, it's not there yet...
15:44:39 <dbueno> dcoutts, k.  I'll pull when you give the word.
15:46:30 <dcoutts> dblog: ok, pull
15:46:34 <dcoutts> oops
15:46:39 <dcoutts> dbueno: ^^
15:46:50 <dbueno> heh, thanks.
15:49:16 <tibbe> how do I allocate memory for a Ptr Word8?
15:50:14 <tusho> a
15:50:25 <cinimod> dcoutts: do you know how I get an account on community.haskell.org?
15:50:44 <dcoutts> cinimod: http://community.haskell.org/admin/account_request.html
15:50:44 <lambdabot> Title: Account Request
15:50:50 <cinimod> dcoutts: I thought I submitted the form about 2 weeks ago
15:50:58 <dcoutts> oh right
15:51:03 * dcoutts checks
15:51:31 <dcoutts> cinimod: what username?
15:52:04 <cinimod> dcoutts: I can't remember: cinimod or dom or dominic
15:52:25 <dcoutts> cinimod: ah yes, 'dom'
15:52:35 <dbueno> dcoutts: Same error.
15:52:43 <dcoutts> dblog: hmm
15:52:46 <dcoutts> doh!
15:52:58 * dcoutts has a love hate relationship with tab completion
15:53:09 <dbueno> I see the patch in `darcs changes'
15:53:33 <dbueno> hah.  I unregistered the existing 1.4.0.1 before installing
15:53:39 <dcoutts> cinimod: usually it's someone else who handles the account requests and I do the project requests but he's on holiday
15:53:41 <dbueno> I cleaned both bytestring and network-bytestring
15:53:41 <tusho> dbueno: do you?
15:53:45 <tusho> OH I MEAN DCOUTTS
15:54:47 <dcoutts> cinimod: I'll process the account request backlog
15:54:57 <dcoutts> tusho: ?
15:55:00 <dbueno> dcoutts: -v3 shows the same package.conf being used.
15:55:09 <tusho> dcoutts: for <tusho> dbueno: do you?
15:55:09 <cinimod> dcoutts: great - it's not urgent - I just thought it had got lost somehow
15:55:10 <tusho> ;)
15:55:24 <dcoutts> dbueno: so what is the difference in how we're calling ghc then?
15:56:48 <dbueno> dcoutts: Oh, hmm, I didn't save the old output. =[
16:00:53 <dbueno> dcoutts: I'm installing both versions to compare.
16:06:45 <dbueno> dcoutts: I set Cabal-Version: = 1.4.0.1 (the released version) ... and now it works.  Hold on, let me delete the installed libs and try again.
16:06:51 <tibbe> is writing to a ForeignPtr slow?
16:08:54 <dbueno> dcoutts: (I installed the darcs version as Cabal-1.4.0.2)
16:09:08 <mwolak> eep... I just updated ghc, and now ghci doesn't work nicely with things like the backspace key... any ideas?
16:09:32 <jamii> mwolak: Where did you install it from?
16:09:36 <mwolak> source
16:09:50 <jamii> And before?
16:09:53 <mwolak> perhaps it couldn't find readline?
16:09:59 <mwolak> before was source as well
16:10:04 <mwolak> went from 6.8.1 to 6.8.3
16:10:48 <jamii> Maybe run the build again and see if it mentions readline anywhere? Failing that you can use rlwrap on linux
16:11:20 <thedward> I'm using a version of ghc that includes bytestring, but cabal cites it as a missing dependency when I am trying to build a package that needs it.
16:11:37 <mwolak> thanks, didn't know about rlwrap
16:12:20 <jamii> Its not as good as proper readline. Wont do tab-complete, for one thing
16:12:37 <thedward> should packages that need bytestring depend on "bytestring or ghc > blah" or is this a bug in my ghc install?
16:12:45 <Dybber> When does hGetContents return? When the handle is closed?
16:12:49 <dbueno> dcoutts: So appparently Cabal-Version: = <a version> doesn't work, because, I just unregistered and deleted Cabal-1.4.0.1, and the build works.
16:13:27 <dbueno> So I assume it's using the darcs cabal-1.4, which I've labeled 1.4.0.2
16:13:41 <jamii> Dybber: Its a bit complicated. If you close the handle before evaluating the contents you get an empty string
16:14:32 <jamii> You need to fully evaluate everything you need before closing the handle.
16:14:36 <ddarius> hGetContents returns immediately.
16:14:43 <Dybber> But it will never return before the handle is closed?
16:16:25 <ddarius> Dybber: It returns immediately putting the handle in a semi-closed state.
16:21:29 <reuben_> i have a list, and i want to get a list with the Nth and Mth positions swapped from the original
16:21:36 <reuben_> and my brain hurts :(
16:21:58 <vixey> reuben_: most problems are pretty hard sa they are
16:22:09 <vixey> reuben_: but can you think of a way to divide it up into simple problems?
16:22:10 <Igloo> You can do it with take and drop quite easily, but the real answe is probably not to have a list in the first place
16:23:00 <reuben_> hm, didn't know about take and drop
16:23:27 <vixey> you can do it easily with replace and (!!)
16:23:30 <ddarius> A quick zipWith and you're done, but it's still a bad idea (in general)
16:24:06 <reuben_> why is it a bad idea?
16:24:37 <vixey> it's a good idea to solve this in terms of subproblems to improve your own understanding
16:24:38 <Cale> reuben_: because you'll be reconstructing the entire max(m,n) first elements of the list
16:25:19 <Cale> reuben_: So it's a O(max(m,n)) time operation.
16:25:24 <reuben_> i'm not sure what you mean, vixey
16:26:07 <reuben_> i see why this approach sucks though
16:26:16 <vixey> let nth = list !! n ; mth = list !! m in replace (replace list n mth) m nth
16:29:02 <RayNbow> @seen hpaste
16:29:02 <lambdabot> I saw hpaste leaving #haskell 2h 7m 36s ago, and .
16:29:06 <RayNbow> http://hpaste.org/8871
16:29:18 <RayNbow> "Does this recursion scheme have a name?"
16:31:20 <ddarius> RayNbow: It looks like a variation on an apomorphism or alternatively a higher-order instance of an apomorphism.
16:32:59 <tromp> :t break
16:33:03 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
16:33:52 <tromp> > break False [0..9]
16:33:53 <RayNbow> ddarius: my knowledge of category theory is nearly zero
16:33:54 <lambdabot>  Couldn't match expected type `a -> Bool'
16:34:06 <tromp> > break odd [0..9]
16:34:08 <lambdabot>  ([0],[1,2,3,4,5,6,7,8,9])
16:34:13 <ddarius> RayNbow: This has little to do with category theory.
16:34:17 <tromp> > break (<0) [0..9]
16:34:18 <lambdabot>  ([0,1,2,3,4,5,6,7,8,9],[])
16:36:40 <tromp> @let listRec z f p l = let (nop,ps) = break p l in case ps of [] -> z; (x:xs) -> nop ++ (f x : xs)
16:36:42 <lambdabot> Defined.
16:37:17 <tromp> > listRec [] (+1) odd [0..9]
16:37:19 <lambdabot>  [0,2,2,3,4,5,6,7,8,9]
16:37:54 <RayNbow> hmm, ddarius, according to http://comonad.com/reader/2008/recursion-schemes/ an apomorphism is an unfold... but wouldn't it be more natural to express listRec --which slightly resembles map?-- as a fold?
16:37:56 <lambdabot> Title: The Comonad.Reader » Recursion Schemes: A Field Guide
16:38:12 <tromp> i'd call it applyAfterBreak:)
16:38:48 <tromp> listRec is not map like
16:38:52 <ddarius> You could probably also do it as a higher order paramorphism.
16:39:01 <tromp> cause it's order dependent
16:40:04 <tromp> oops, my version is not what you want
16:40:42 <tromp> @let listRec2 z f p l = let (nop,ps) = break p l in nop ++ case ps of [] -> z; (x:xs) -> f x:xs
16:40:43 <lambdabot> Defined.
16:42:15 <ddarius> :t let para c n [] = n; para c n (x:xs) = c x xs (para c n xs); listRec z f = para (\x xs xs' p -> if p x then x:xs else x : xs' p) (const z)
16:42:16 <lambdabot> <no location info>:
16:42:16 <lambdabot>     not an expression: `let para c n [] = n; para c n (x:xs) = c x xs (para c n xs); listRec z f = para (\x xs xs' p -> if p x then x:xs else x : xs' p) (const z)'
16:42:24 <ddarius> :t let para c n [] = n; para c n (x:xs) = c x xs (para c n xs); listRec z f = para (\x xs xs' p -> if p x then x:xs else x : xs' p) (const z) in listRec
16:42:26 <lambdabot> forall t t1. [t] -> t1 -> [t] -> (t -> Bool) -> [t]
16:43:04 <ddarius> :t let para c n [] = n; para c n (x:xs) = c x xs (para c n xs); listRec z f = para (\x xs xs' p -> if p x then f x:xs else x : xs' p) (const z) in listRec
16:43:05 <lambdabot> forall a. [a] -> (a -> a) -> [a] -> (a -> Bool) -> [a]
16:43:14 <RayNbow> let's say we want to modify listRec, such that it will now apply f to the elements of the list at most N times, and depending on the number of applications, it might replace [] with z
16:43:26 <RayNbow> the modification would entail using an accumulator, right?
16:43:44 <ddarius> :t let listRec z f p [] = z; listRec z f p (x:xs) | p x = f x : xs | otherwise = x : listRec z f p xs in listRec
16:43:46 <lambdabot> forall a. [a] -> (a -> a) -> (a -> Bool) -> [a] -> [a]
16:44:28 <ddarius> RayNbow: That's one way of doing it.
16:45:16 <RayNbow> ddarius: and that listRec would more or less be a generalized version of the original, right?
16:45:27 <RayNbow> as the original is a specific case where N=1
16:46:06 <ddarius> Sure.
16:47:56 <RayNbow> ddarius, could you see the modified listRec as a histomorphism?
16:48:10 <RayNbow> the accumulator basically represents the previously given answers
16:48:30 <ddarius> Yes.  It would probably be easily representable by a histomorphism.
16:49:07 <tibbe> when should I use a ForeignPtr vs a plain Ptr?
16:49:19 <ddarius> tibbe: Yes.
16:49:28 <tromp> when you're abroad
16:49:36 <ddarius> Er, I misread the question.
16:50:04 <RayNbow> ddarius: thanks :)  (not that I would be using the category-extra package, I'm not ready yet... but at least I've learnt something today :))
16:50:56 <ddarius> There's probably very little benefit in utilizing it in the vast majority of cases.  Perhaps that will change with time.
16:51:45 <RayNbow> ddarius: still, trying to understand new things is refreshing for my mind :)
16:51:57 <RayNbow> (more often mind blowing though ;))
16:53:14 <sms_> What would  be the result if I use Data.Map.lookup in the IO monad and the key is not in the Map?
16:54:02 <tromp> :t Data.Map.lookup
16:54:03 <lambdabot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> M.Map k a -> m a
16:54:11 <RayNbow> an exception, sms_
16:54:16 <RayNbow> :t fail
16:54:16 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
16:54:26 <RayNbow> > fail "test" :: IO ()
16:54:29 <lambdabot>  <IO ()>
16:54:45 <RayNbow> thank you lambdabot, for not behaving like my ghci instance :p
16:54:57 <sms_> so i have to catch the exception instead of using fromMaybe afterwards?
16:55:10 <RayNbow> hmm
16:55:28 <Mitar> how can I specify quaternions in Haskell?
16:55:38 <RayNbow> well, couldn't you perform the lookup in the Maybe monad, sms_?
16:55:45 <ddarius> Mitar: type Quaternion field = Complex (Complex field)
16:55:56 <Mitar> and how can I then define one?
16:56:24 <Mitar> 0 :+ 0 :+ 0 :+ 0 does not seem to work
16:56:31 <sms_> actually i dont know  because i am not to familiar with monads
16:56:39 <ddarius> a + bi + cj + dk = (a :+ b) :+ (c :+ d)
16:57:13 <Mitar> could i somehow define an operator which would work like that?
16:57:32 <Mitar> so that i could just write: a :+ b :+ c :+ d
16:57:33 <Mitar> ?
16:57:42 <RayNbow> sms_: what do you want to do when there is no key in your map?
16:57:51 <ddarius> sms_: You can always view lookup as returning a Maybe.
16:58:11 <sms_> RayNbow, I want to use a default value
16:58:23 <ddarius> Mitar: If you make values for i j and k, you can simply write a + b*i + c*j + d*k
16:58:44 <sms_> ddarius, sound good
16:58:55 * vixey wonders if that has multiplication defined correctly
16:59:02 <RayNbow> @hoogle findWithDefault
16:59:03 <lambdabot> Data.Map.findWithDefault :: Ord k => a -> k -> Map k a -> a
16:59:03 <lambdabot> Data.IntMap.findWithDefault :: a -> Key -> IntMap a -> a
16:59:35 <RayNbow> ^ sms_
16:59:48 <RayNbow> The expression (findWithDefault def k map) returns the value at key k or returns def when the key is not in the map.
16:59:50 <ddarius> vixey: Presumably you are verifying this right now.
16:59:59 <vixey> yes :P
17:00:06 <Mitar> ;-)
17:00:07 <Mitar> thanks :-)
17:00:14 <vixey> it'll be very neat if it works
17:00:21 <RayNbow> sms_, maybe it also helps to take a look at the source cod eof findWithDefault: http://haskell.org/ghc/docs/latest/html/libraries/containers/src/Data-Map.html#findWithDefault
17:00:22 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/2bjwxd
17:00:31 <sms_> stupid me kept searching for something like lookupWithDefault.
17:00:36 <sms_> maybe i should go to bed
17:00:40 <sms_> thank RayNbow
17:00:54 <vixey> @instances RealFloat
17:00:55 <Mitar> No instance for (RealFloat (Complex Float)) ??
17:00:55 <lambdabot> Double, Float
17:00:55 <sms_> +s
17:00:59 <RayNbow> sms_: well, I didn't know of the existence of findWithDefault either :p
17:01:01 <vixey> oh I have to define a RealFloat instance
17:01:06 <vixey> @src RealFloat
17:01:07 <lambdabot> Source not found. My brain just exploded
17:01:17 <sms_> RayNbow, lol, then there still might be hope for me
17:01:19 <RayNbow> it just happened to be listed below lookup in Data.Map's haddock
17:01:25 <rhz> Is there some reason why I can't seem to use the module "Network"? Is it part of the default GHC install?
17:01:26 <RayNbow> http://haskell.org/ghc/docs/latest/html/libraries/containers/Data-Map.html#v%3Alookup
17:01:27 <lambdabot> Title: Data.Map, http://tinyurl.com/2mpwee
17:01:39 <Mitar> so this type declaration is not really working?
17:01:58 <sms_> i prefix-searched the module and and i was so into lookup that i failed to look at the whole module
17:02:37 <dcoutts> cinimod: btw, did you get c2hs and cabal working?
17:04:21 <rwbarton> > let i = (0 :+: 1) :+: (0 :+: 0) ; j = (0 :+: 0) :+: (1 :+: 0) ; k = (0 :+: 0) :+: (0 :+: 1) in i * j
17:04:22 <lambdabot>   Not in scope: data constructor `:+:'
17:04:40 <rwbarton> > let i = (0 :+ 1) :+ (0 :+ 0) ; j = (0 :+ 0) :+ (1 :+ 0) ; k = (0 :+ 0) :+ (0 :+ 1) in i * j
17:04:41 <lambdabot>        add an instance declaration for (RealFloat (Complex t))
17:05:01 <rwbarton> I see... anyways, I'm pretty sure this won't work
17:05:25 <dcoutts> cinimod: afaik, there's no need to tell cabal about c2hs in a custom Setup.hs script, it should already know
17:06:06 <rwbarton> Complex (Complex Double) is certainly going to be commutative
17:06:18 <vixey> :t undefined :: Complex (Complex Double)
17:06:19 <lambdabot> Complex (Complex Double)
17:06:26 <vixey> ummm..
17:06:44 <vixey> > let x = undefined :: Complex (Complex Double) in 1
17:06:45 <lambdabot>  1
17:06:49 <rwbarton> :t undefined :: Ratio (Int -> Bool)
17:06:50 <lambdabot> Ratio (Int -> Bool)
17:06:57 <vixey> how odd
17:07:05 <vixey> > let x = undefined :+ undefined :: Complex (Complex Double) in 1
17:07:06 <lambdabot>        add an instance declaration for (RealFloat (Complex Double))
17:07:06 <lambdabot>     In th...
17:07:43 <rwbarton> It even works in ghci
17:08:34 <rwbarton> I guess there's no context on the data type declaration, just on the instances
17:09:19 <Mitar> http://sigfpe.blogspot.com/2006/08/geometric-algebra-for-free_30.html
17:09:21 <lambdabot> Title: A Neighborhood of Infinity: Geometric Algebra for Free!, http://tinyurl.com/5f644g
17:11:22 <ddarius> > let f a b c d = (a :+ b) :+ (c :+ d); i = f 0 (1 :: Double) 0 0; j = f 0 0 (1 :: Double); k = f 0 0 0 (1 :: Double) in (i*j,k)
17:11:23 <lambdabot>  Couldn't match expected type `Complex (Complex Double)'
17:14:15 <Mitar> ehm, so this Quaternion field = Complex (Complex field) does not really work?
17:14:21 <rwbarton> No
17:18:25 <vixey> Mitar: You have to define instances for it
17:18:49 <Mitar> so it is like i would do my one data type ...
17:23:16 <name> hey. are there any books you could recommend about haskell?
17:23:37 <EvilTerran> ?where realworldhaskell
17:23:38 <lambdabot> http://www.realworldhaskell.org/
17:24:16 <vixey> > let one2Three = (1,2,3) in one2Three
17:24:17 <lambdabot>  (1,2,3)
17:26:49 <Armored_Azrael> Hey, why is hackage so throttled for bandwidth
17:26:53 <Armored_Azrael> Do you not have any mirrors?
17:28:05 <name> 50 bucks :(
17:28:13 <name> EvilTerran: and it's not even out
17:28:31 <EvilTerran> name, er, what? it's free on the site
17:28:43 <EvilTerran> not a physical book, sure, but it's in book format
17:29:05 <name> EvilTerran: ah okay :)
17:29:16 <EvilTerran> http://book.realworldhaskell.org/beta/
17:29:18 <lambdabot> Title: Real World Haskell
17:29:35 <Armored_Azrael> I mostly ask because I use the service and have the resources to provide mirroring if that's the only reason the download is capped at 3 kb/s..
17:30:51 <vixey> I wish haskell would just put the right number of lift$'s in
17:33:19 <ddarius> The way it is setup, it usually does.
17:41:14 <bitrot> are you seeing ddoouubbllee??
17:41:36 * bitrot picks the right window..
17:53:05 <kscaldef> can someone explain to me why the "elegant" haskell quicksort is supposedly really O(n^2)?
17:53:46 <kscaldef> or are the people claiming so here just wrong? http://www.reddit.com/r/programming/info/6r7w0/comments/
17:53:46 <lambdabot> Title: programming: Three Beautiful Quicksorts
17:56:12 <seanl> I wonder if foldl and foldr could give different results for the same arithmetic operation..
17:57:42 <EvilTerran> (/)?
17:57:53 <seanl> especially for the commutative and associative operations
17:58:12 <EvilTerran> well, given that restruction, they can't
17:58:40 <seanl> so it could be safe for me to make that assumption. is that correct?
17:58:43 <EvilTerran> all you need is associativity and either commutativity or the initial element being a unit of the operation
17:59:22 <dons> hey seanl
17:59:26 <seanl> hey dons
17:59:28 <EvilTerran> "foldl f = foldr f if f is commutative and associative" wouldn't be an assumption, you can prove it
17:59:45 <seanl> hm... yeah... true...  :)
18:00:01 <dons> kscaldef: hmm, I don'tthink its O(n^2) is it? it's just not in-place.
18:00:55 <seanl> i was thinkging that if you want to implement a parallel foldl/foldr, then the operations must be associative and commutative, then again, there would be no reason to distinguish between foldl and foldr and general reduction.
18:01:01 <kscaldef> dons: well some people seem strongly convinced it is n^2... but no explanation given
18:01:34 <ddarius> @google algebra of scans
18:01:41 <ddarius> seanl: Read that.
18:01:45 <lambdabot> http://citeseer.ist.psu.edu/hinze04algebra.html
18:01:45 <lambdabot> Title: An Algebra of Scans (ResearchIndex)
18:02:00 <ddarius> kscaldef: Then say "Prove it"
18:02:47 <seanl> ddarius: thanks
18:06:00 <vixey> @undo do x <- f e ; g x
18:06:01 <lambdabot> f e >>= \ x -> g x
18:06:20 <vixey> can you write  f e >>= g  better ? like g . f or something
18:07:38 <ddarius> f >=> g
18:08:36 <vixey> cool thanks
18:19:09 <awesame> why does "maybe" take that (b -> a) argument?
18:19:20 <vixey> :t maybe
18:19:21 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
18:19:26 <vixey> @src Maybe
18:19:27 <lambdabot> data Maybe a = Nothing | Just a
18:19:33 <ddarius> @src maybe
18:19:33 <lambdabot> maybe n _ Nothing  = n
18:19:33 <lambdabot> maybe _ f (Just x) = f x
18:19:34 <vixey> maybe is made by looking at each constructor,
18:20:03 <awesame> I frequently find myself passing id into maybe
18:20:08 <vixey> Nothing is some constant object of type z, Just is a function from a -> z
18:20:15 <ddarius> Then use fromMaybe
18:20:19 <ddarius> @src fromMaybe
18:20:19 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
18:20:32 <awesame> oh, that's better
18:20:34 <vixey> so maybe (which turns Maybe a -> z) has type z -> (a -> z) -> Maybe a -> z
18:20:48 <EvilTerran> (where z = Maybe a in the constructors themselves)
18:20:51 <vixey> the same procss gives you either, if, foldr and so on
18:21:10 <EvilTerran> well, foldr's got the recursion in it
18:21:11 <awesame> vixey: thanks, that was a great explanation
18:21:19 <EvilTerran> the same would give you uncons or whatever it's usually called
18:21:29 <EvilTerran> (uncons f e [] = e; uncons f e (x:xs) = f x xs)
18:21:56 <vixey> good point EvilTerran, there's a choice what to do (which I didn't cover) when recursive types come in
18:22:18 <vixey> you either get uncons (the eliminator for list) or foldr depending
18:22:19 <Saizan> unless you think of Maybe as a catamorphism over Maybe' a f = Nothing | Just a
18:22:55 <EvilTerran> you can use mine, then apply some morphism to get the recursive one :P
18:23:37 <vixey> can uncons be written as a foldr?
18:23:49 <vixey> I don't think so
18:24:42 <awesame> ack, where do I get fromMaybe?
18:24:50 <ddarius> vixey: Of course it can.
18:24:51 <Saizan> Data.Maybe
18:24:52 <EvilTerran> vixey, only very cheekily, i think
18:24:52 <ddarius> @index fromMaybe
18:24:53 <lambdabot> Data.Maybe
18:25:10 <vixey> well not by me. ..
18:25:13 <vixey> how would you do it ?
18:25:46 <EvilTerran> ?type \f e -> fst . foldr (\x (y,xs) -> (f x y, x:xs)) (e,[])
18:25:47 <lambdabot> forall a a1. (a1 -> a -> a) -> a -> [a1] -> a
18:26:06 <EvilTerran> hm... no, that's not what i was after, is it
18:26:06 <ddarius> vixey: To put it cryptically, you use Lambek's lemma.
18:28:03 <chessguy> any #haskell-ers working on the contest?
18:28:25 <ddarius> We have, in general, if ÂµF is an initial algebra then FÂµF ~ ÂµF
18:28:49 <shapr> chessguy: I am
18:29:00 <chessguy> oh cool, how goes?
18:29:13 <shapr> I just got off work...
18:30:21 <chessguy> that's a good start...
18:39:42 <shapr> emacs' align-regexp is freakin awesome with Haskell!
18:41:45 * shapr boings furiously
18:42:01 <solrize> :t liftM
18:42:02 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
18:42:04 <solrize> :t fmap
18:42:05 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:42:19 <solrize> why use liftM instead of fmap?  all monads are functors, right?
18:43:01 <vixey> :t liftM2
18:43:03 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
18:43:14 <sm> shapr, what do you use it for ?
18:43:42 <sm> I use it python, but not yet in haskell..
18:45:40 <Saizan> solrize: i prefer fmap since it can be "optimized", but you use liftM if you don't want the Functor constraint
18:46:45 <vinicius> I can't have acessors, in record sintax, with the same name? Aren't they supposed to be polymorphic to each constructor?
18:47:39 <solrize> i just noticed fmap is in the prelude but to use liftm you have to import control.monad
18:47:43 <Saizan> data Record = Foo { accessor1 :: X } | Bar { accessor1 :: X } ?
18:48:00 <vinicius> Saizan: beyond that, in a different data
18:48:31 <ddarius> Records don't introduce a new namespace.
18:48:51 <Saizan> ah, no, you'd have to define the other datatype in a different module
18:49:06 <Saizan> since only modules defines namespaces
18:49:16 <Saizan> "define"
18:49:26 <mmorrow> one way is to make a type class HasFoo a where foo :: a -> Foo then make the datatypes instances of it
18:50:50 <mmorrow> (where the instance would be simple pattern matching to extract that partic item)
18:51:02 <mmorrow> instance*s*
18:54:08 <solrize> anyone ever use the profiler to find space leaks?  the manual recommends that but the output isn't useful as far as i can tell.
18:55:45 <mmorrow> ruhroh. what're you doing in the code where the leak could possibly/most likely is occurring?
18:56:45 <solrize> mmorrow, http://hpaste.org/8872
18:56:53 <solrize> worst is, i've done this problem several times in the past :)
18:56:53 * Saizan never really understood the output of the profiler
18:57:43 <solrize> i use -hr -p
19:00:25 <Armored_Azrael> So, who runs hackage?
19:00:29 <sm> that graphical profiler thing is pretty effective
19:00:39 <sm> easier to read sometimes
19:01:50 <solrize> sm ?
19:02:04 <solrize> what graphical profiler?
19:04:45 <dons> Armored_Azrael: the community.
19:05:01 <sm> solrize: I can no longer find it at http://www.haskell.org/ghc/docs/latest/html/users_guide/profiling.html , but there was an old graphical profile browser that worked well
19:05:02 <lambdabot> Title: Chapter 6. Profiling, http://tinyurl.com/kwh6c
19:06:06 <sm> http://people.reed.edu/~carlislp/ghc6-doc/users_guide/prof-xml-tool.html
19:06:07 <lambdabot> Title: Graphical time/allocation profile, http://tinyurl.com/6775pw
19:09:29 <sm> to help understand text profiles once, I trimmed and converted them to emacs org-mode outlines, depth-colour-coded (with highlight-lines-matching-regexp I think)
19:09:51 <sm> so you could expand/collapse parts
19:09:53 <sm> that helped a bit
19:10:05 <solrize> thanks, i read chapter 6, i'm not having trouble understanding the text profile, it just plain doesn't have enough info to find the leak
19:10:30 <pa-ching> If I'm debugging and hit an infinite loop in ghci, what can I do to break and get a backtrace? Ctrl-C doesn't give me one
19:10:40 <ddarius> solrize: Then add more SCCs
19:11:49 <solrize> what's an SCC?
19:11:49 <sm> http://hpaste.org/8873 <- simplifyprof.hs
19:12:09 <SamB> solrize: that would be your problem ;-)
19:13:05 <solrize> oh, i have to put annotations on individual terms to get them profiled
19:15:35 <solrize> i used -caf-all and that didn't help
19:18:07 <SamB_XP> @unpl (const id)
19:18:07 <lambdabot> (\ _ b -> b)
19:18:26 <Armored_Azrael> dons: Specifically, I'm curious about how one would go about using servers I have to possibly provide a mirroring service to make downloads of cabal packages faster--it seems to go at 3 kb/s, which can be rather annoying when cabal installing, etc.
19:18:49 <SamB_XP> so THAT's why the letters "KI" appear as a caption above the kite in "To Dissect a Mockingbird"
19:20:34 <SamB_XP> you know, I might find these diagrams more clear if they were flipped about the y axis ...
19:21:35 * SamB_XP compares with the alligator notation
19:21:37 <mmorrow> solrize: hah. i was about to give up when i realized there're those sneaky hidden tuples being passed to max
19:21:48 <mmorrow> so the foldl1' evals the max a b
19:21:53 <SamB_XP> everyone seen http://worrydream.com/AlligatorEggs/ ?
19:21:54 <lambdabot> Title: Alligator Eggs!
19:22:13 <mmorrow> but since a=(a1,a2), b=(b1,b2), it can reach down
19:22:18 <mmorrow> and the stack blows
19:23:00 <mmorrow> that was tricky
19:23:58 <mmorrow> solrize:  http://hpaste.org/8872#a1
19:24:04 <awesame> is there a no-op in the IO monad?
19:24:28 <awesame> I want to write "if x /= y then doStuff else --do nothing"
19:24:30 <mmorrow> solrize: i think it runs in const space now, i've had
19:24:39 <awesame> (maybe I shouldn't want to write that?)
19:24:41 <mmorrow> [m@ganon ~]$ ./solrize 100000000000   going for a couple minutes now
19:24:45 <edwardk> awesome return ()
19:24:51 <awesame> oh, duh
19:24:54 <awesame> thanks
19:25:20 <edwardk> or more appropriately use when or unless instead of if
19:25:23 <solrize> mmorrow, thanks, yeah, (id &&& clen) also got rid of the space leak, i was asking more generally how to locate the leak
19:25:29 <edwardk> @type when
19:25:30 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
19:25:58 <mmorrow> solrize: oh. that was my method ;)
19:26:07 <mmorrow> man, it was driving me crazy
19:26:13 <edwardk> when (x /= y) doStuff
19:26:13 <awesame> edwardk: even better
19:26:31 <edwardk> @src when
19:26:31 <lambdabot> when p s = if p then s else return ()
19:26:36 <edwardk> 0)
19:26:42 <edwardk> er =)
19:26:56 <awesame> @src unless
19:26:57 <lambdabot> unless p s = if p then return () else s
19:27:05 <awesame> handy
19:28:52 <solrize> i wish there was a runtime option that throws an exception if any evaluation goes more than n levels deep in thunks, e.g. n=100
19:29:31 <SamB_XP> what the heck is the * combinator???
19:33:15 <solrize> > 2 * 3
19:33:17 <lambdabot>  6
19:33:46 <SamB_XP> solrize: I was talking about this thing in "To Dissect a Mockingbird"
19:33:57 <SamB_XP> I haven't gotten to the numerical birds yet
19:35:29 <Armored_Azrael> Can one derive Ix (Ix a => (a, a)) ?
19:36:42 <solrize> which thing?  KI sounds like const and identity
19:36:57 <solrize> SKI = S, K, and I combinators
19:37:29 <solrize> in untyped lambda calculus those let you synthesize any function
19:37:49 <solrize> if i have that right
19:38:01 <atp> it's not lambda calculus
19:38:04 <atp> it's combinatory logic
19:38:09 <atp> but they're equivalent so i guess it doesn't matter :)
19:38:20 <solrize> http://users.bigpond.net.au/d.keenan/Lambda/
19:38:21 <lambdabot> Title: To Dissect a Mockingbird: A Graphical Notation for the Lambda Calculus with Anim ...
19:38:22 <solrize> neat
19:38:28 <Mr_Awesome> Armored_Azrael: if you mean Ix a => Ix (a, a), im pretty sure thats already in the Ix module
19:38:55 <Armored_Azrael> OK
19:38:57 <Armored_Azrael> Thanks
19:42:40 <edwardk> @seen dolio
19:42:41 <lambdabot> dolio is in #ghc, #haskell-blah and #haskell. I last heard dolio speak 4h 56m 9s ago.
19:42:52 <dolio> Yo.
19:43:43 <edwardk> dolio ok. its official that definition in terms of dup is messed up. but there doesn't appear to be a valid variation on it. it was also wrong in menendez's docs in the old category-extras
19:44:09 <edwardk> he had it there as an invalid definition in terms of refold
19:44:24 <dons> hehe, jdh awesomeness "Ilove the way you got down-modded for stating the blindingly obvious. Redditers are such a bunch of penniless freeloader commies..."
19:44:28 <dolio> Yeah, I played around with it and couldn't figure out how to make it work right with lists.
19:44:55 <dons> Armored_Azrael: yeah, we're looking at lifting the bandwidth limit. not sure why its so low
19:45:03 <edwardk> dolio i can kinda see where it was going but not how it intended to get there ,)
19:45:37 <dolio> Yeah. You need to get the stuff in the part of the functor you can see into the part you can't.
19:45:58 <edwardk> oh well
19:46:08 <edwardk> one fewer law in the field guide
19:47:45 <dolio> Yeah. It's a shame, too, because the idea of that one was to not copy the structure.
19:49:30 <solrize> :t rnf
19:49:31 <lambdabot> forall a. (NFData a) => a -> Done
19:51:00 <edwardk> hrmm i realized just now that a lot of my laws for para are backwards of the way i usually implement them
19:51:25 <edwardk> i tend to put the recursive form unmodified on the left so it can work in a product comonad with normal comonad distributive laws
19:55:58 <Armored_Azrael> dons: You should set up a place to sign up as mirrors and a syncing protocol--I'll bet alot of people would help out.
19:56:25 <bd_> Did the type signature of the runTests field of the UserHooks structure in cabal change recently? (from [...] -> IO () to [...] -> IO ExitCode)  I've got an email from someone who found a toy project of mine and was having problems building it because of such a typechange; however ghc-pkg shows the same cabal version as I have locally...
19:56:59 * sm would love hackage to default to the package list, not the about page
19:57:14 <SamB_XP> 3 kB/s ? that's about the speed I got on dialup!
19:57:23 <SamB_XP> (or maybe slightly faster)
19:58:08 * geezusfreeek got about 5 kB/s on dialup
19:58:32 <bd_> http://hpaste.org/8874 <-- the error and setup.lhs
19:59:03 <bd_> ghc and cabal are the same version on both machines, so I'm not sure what's wrong, and this person's contacted me via email, so I'd like to package up any suggestions to reduce RTT costs :)
20:02:37 <vixey> Inferred type is less polymorphic than expected :(
20:03:13 <ddarius> vixey: Do you want GHC to lower its expectations?
20:03:20 <vixey> hehe yes
20:03:26 <solrize> :t rnf
20:03:28 <lambdabot> forall a. (NFData a) => a -> Done
20:04:49 <solrize> f ($!!) x = (rnf x) `seq` (f x)   -- type error?
20:05:14 <ddarius> solrize: You're defining f there.
20:05:23 <solrize> oh i see
20:05:32 <solrize> thanks
20:09:44 <solrize> i just don't see any non-voodoo way to get rid of these space leaks
20:10:08 <ddarius> Use strict pairs.
20:11:38 <ddarius> You can always figure out the behaviour by evaluating by hand.
20:13:49 <ddarius> So, writing a Prolog interpreter in Javascript was a fun adventure in why I like types and purity.
20:14:22 <solrize> strictpair (!a,!b) = (a,b)
20:14:23 <solrize>  print $ foldl1' max $! map strictpair $ zip m [1..]
20:14:27 <solrize> that did it!  thanks
20:14:30 <TomMD> Was there a reason not to write it in haskell and generate javascript?
20:14:31 <chessguy> ddarius:  how so?
20:15:10 <vixey> ddarius: was this recently?
20:15:37 <solrize> ddarius maybe for a simple example like that, what i'm after is a systematic way to debug space leaks in more complicated programs
20:16:09 <ddarius> solrize: I more meant to use a strict pair data type.
20:16:34 <ddarius> solrize: And like logic bugs, the best way to debug them is not to make them in the first place.
20:16:44 <ddarius> vixey: Yes.
20:16:54 <vixey> ddarius: you should put it online!
20:17:09 <solrize> data StrictPair = StrictPair !x !y
20:17:20 <vixey> I tried an interpreter for a prolog like thing with o-
20:17:29 <solrize> oops
20:17:32 <vixey> it is neat you can write permute really easily
20:17:32 <ddarius> chessguy: A lot of using one identifier for another.  I spent hours debugging evaluation order issues (though admittedly I did sort of see that coming.)
20:17:51 <vixey> but I had a lot of distance from a real language
20:18:20 <ddarius> @hackage strict
20:18:20 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/strict
20:18:46 <solrize> oh, i didn't know about that
20:20:19 <vixey> oh
20:20:26 <vixey> my type checking algorithm is not correct
20:20:27 <dbueno> Is there a way to apply a parsec-3 parser directly to a bytestring, instead of giving it a filename?
20:20:35 <vixey> I'm glad I didn't implement it yet
20:20:41 <ddarius> runParserT
20:20:45 <vixey> looks like I reall do have to sort into SCCs
20:21:05 <ddarius> vixey: I said that that was necessary one way or another.
20:21:10 <ddarius> (as did Heffalump)
20:21:21 <vixey> :(
20:21:39 <dbueno> ddarius: Right, but you then have to feed that function an initial state, which requires an abstract datatype (SourcePos).
20:22:07 <dbueno> I couldn't find a way to create a SourcePos.
20:23:10 <pa-ching> Anyone know how I can detect where an infinite loop is occurring? I can't seem to get ghci to tell me
20:23:13 <vixey> I think I am going to borrow TAPL again before finishing this bit of code
20:23:39 <vixey> pa-ching: I just stare at the code until it's clear.. maybe that's impractical in your case though
20:23:52 <pa-ching> Yeah... a little direction would be nice :)
20:24:05 <ddarius> dbueno: ? runParserT :: Stream s m t => ParsecT s u m a -> u -> String -> s -> m (Either ParseError a)
20:24:37 <dbueno> ddarius: Ugh ... I was looking at runParsecT.
20:24:41 <pa-ching> Unfortunately I'm not very good with the whole laziness thing yet, might be a thunk being read too early, I dunno...
20:25:01 <pa-ching> But ghci won't tell me where the code stopped when I Ctrl-C it; any other interpreters that do?
20:25:11 <dbueno> ddarius: Yes, thank you.  I saw that function but missed the "input" parameter.
20:25:15 <dmwit> pa-ching: The usual debugging strategy applies.
20:25:39 <pa-ching> dmwit: Binary search with print statements? ;)
20:25:48 <dmwit> Start with your basic functions, verifying correctness as you move up the complexity chain.
20:26:14 <dmwit> Essentially binary search, yes.
20:26:46 <dbueno> Oh, hmm, that interface won't lazily find parse errors, will it: EIther ParseError a
20:26:51 <gwern> 'I cannot countenance charges of corruption or conspiracy, considering cowardice or cupidity can copcetically content concerned citicizens.' <-- hee hee
20:27:03 <pa-ching> Yeah... eek. So much state. :(
20:27:05 <dmwit> dbueno: no
20:27:08 <dmwit> =/
20:28:01 <ddarius> There was some talk of using the underlying monad to implement an incremental parser, but Parsec isn't incremental by default.
20:28:08 <dbueno> Is there a recommended approach for that?  i.e. lazy parsing where stuff may be consumed even if errors are found later?
20:28:23 <dbueno> Ah, I see.
20:28:35 <ddarius> dbueno: There are other parsing libraries that are incremental.
20:28:57 <dbueno> ddarius: Do you know any names?
20:29:45 <vixey> I am glad I decided to write this, actually it turned out harder than I first though
20:30:07 <vixey> my assumption about typechecking was wrong
20:30:10 <ddarius> http://haskell.org/haskellwiki/Applications_and_libraries/Compiler_tools#Lexers_and_parsers
20:30:11 <lambdabot> Title: Applications and libraries/Compiler tools - HaskellWiki, http://tinyurl.com/2p8tax
20:31:13 <ddarius> dbueno: Polyparse and the Utrecht parsing combinators are probably the best places to start looking.
20:31:21 <dbueno> ddarius: Thanks.
20:31:43 <ddarius> dbueno: If you are parsing a specific standard format, e.g. HTML there are other options as well, e.g. TagSoup.
20:34:35 <solrize> http://research.microsoft.com/~simonpj/papers/not-not-ml/index.htm
20:34:37 <lambdabot> Title: Haskell is not not ML, http://tinyurl.com/ffv6s
20:34:50 <edwardk> solrize: a very fun paper
20:34:58 <solrize> cool
20:35:13 <ddarius> And clearly reveals our despise of classical logic.
20:35:53 <edwardk> solrize: one of my major reasons for showing up at icfp 06 was to ask simon peyton jones about it, turned out it was pretty much entirely ben rudiak gould's brainchild
20:36:16 <edwardk> so i didn't get any of the incredibly deep insights i was seeking ;)
20:36:57 <solrize> edwark heh, ben r.g. hangs out on comp.lang.functional or used to, if that helps
20:37:03 <edwardk> i did probably spend about 6 months exploring variations on the theme though
20:38:15 <solrize> why can't the type system manage evaluation order just like any other effect?
20:39:34 <ddarius> solrize: How many type systems do you see managing any effects?
20:39:37 <edwardk> solrize: its a little tricky. i wanted that to be the case too but you usually try to encapsulate evaluation order through some cps transformation or other so that the youre oblivious to the order of reductions, and they tend to lead to contradictory handlings of intermediate objects the 'hand off' becomes a lot uglier
20:39:50 <Trinithis> anyone know how to do concurrency with Gtk2Hs?
20:39:54 <solrize> ddarius, haskell manages effects with monads
20:39:55 <ddarius> To the extent that Haskell manages effects via the type system, you can do what you want.
20:40:20 <edwardk> the not not ml encoding at least offers up a solution where you can treat a strictly evaluated object as a lazy one through autolifting and the rest of the encoding is just noise
20:41:16 <edwardk> they do kind of sweep under the rug the name vs. need stuff though
20:42:04 <ddarius> Algol is not not ML
20:42:30 <edwardk> well said
20:46:57 <vixey> http://citeseerx.ist.psu.edu/viewdoc/summary;jsessionid=E2774A9A0005FC9E89B387343CA808F0?cid=94209
20:46:59 <lambdabot> Title: A theory of type polymorphism in programming - CiteSeerX, http://tinyurl.com/6r7en5
20:47:45 <solrize> vixey, that's about ML?
20:48:04 <vixey> Type polymorphism
20:48:13 <vixey> it's by Milner
20:48:39 <solrize> yeah, from 1978, i wondered if it was the paper that introduced ML-ish parametric polymorphism
20:54:27 <edwardk> hrmm http://www.opendylan.org/~gabor/Thrist-draft-2008-07-11.pdf neat
20:54:29 <lambdabot> Title: cache:http://www.opendylan.org/~gabor/Thrist-draft-2008-07-11.pdf - Google Searc ...
21:06:36 <ddarius> There's nothing like algebraic topology for an introductory CT article.
21:06:59 <mmorrow> where the concept of "Functor" first originated.
21:08:29 <mmorrow> (and by "Functor" i mean both a variances)
21:08:41 <mmorrow> s/a//
21:09:58 <ddarius> The entirety of category theory came out of algebraic topology.
21:10:42 <mmorrow> if by that you mean "algebraic topology planted the seed" i wholeheartedly agree
21:11:27 <mmorrow> of course it's a jumbled knot of a feedback loop between everything, etc
21:20:10 <noecksit> sorry
21:20:12 <noecksit> is it possible to type match using lambda expressions?
21:20:50 <noecksit> > [Nothing] >>= (\(Just a) -> [a])
21:20:54 <lambdabot>   Non-exhaustive patterns in lambda
21:21:13 <bd_> > [Just 42] >>= (\(Just a) -> [a]) -- yes
21:21:14 <lambdabot>  [42]
21:21:16 <bd_> but you can only match one
21:21:20 <bd_> unless you use a case
21:21:37 <noecksit> bd_: yeah, thats what i mean
21:21:42 <bd_> > [Nothing, Just 42] >>= (\v -> case v of Nothing -> "Nothing"; Just n -> show n)
21:21:43 <lambdabot>  "Nothing42"
21:22:51 <noecksit> bd_: that could work, no way for a lambda to have two constructors though?
21:23:15 <bd_> two cases you mean, and no. that's what case is for :)
21:23:35 <noecksit> hmm, ok thanx
21:25:09 <aj> off topic, but is anyone here up to date on formal specification of programs and Z?
21:29:51 <dmwit> noecksit: If you're doing literally that example (or ones in the list monad), you can match one constructor and have the other call fail.
21:30:02 <dmwit> noecksit: via list comprehensions
21:30:22 <dmwit> > [x | Just x <- [Nothing, Just 42]]
21:30:23 <lambdabot>  [42]
21:30:42 <dmwit> But then, if you're doing literally that example, there's catMaybes. ;-)
21:31:25 <dmwit> heh, from ICFP description: "Your team name must be no longer that [sic] 63 ASCII characters."
21:31:36 <dmwit> I wonder if they're reading it into a length-64 array. =P
21:33:55 <edwardk> i still think \0<b>Hello World</b>'); DROP TABLE CONTESTANTS--
21:34:11 <edwardk> or something like that would be a good way to go ;)
21:35:07 * dmwit plans on including a scheme interpreter in his 64 bytes
21:39:18 <vixey> edwardk: cool!
21:39:28 <vixey> (thrist is super nifty)
21:39:44 <vixey> the Cat bit reminds me of the Epigram compiler pearl
21:39:51 <edwardk> vixey: yeah
21:40:19 <edwardk> vixey: the funny thing is i have an arrow implementation around here that is basically what they call a thrist i just never named it anything :)
21:40:59 <edwardk> though technically their thrist monad stuff fails the monad laws because by permitting inspection you lose the associativity of bind, etc
21:41:23 <edwardk> similarly their thrist arrow stuff has similar issues
21:42:22 <Armored_Azrael> Assuming I have: type A = StateT B IO
21:42:22 <Armored_Azrael> How do I execute IO actions inside the A monad?
21:42:33 <edwardk> liftIO or lift
21:42:38 <Armored_Azrael> thanks
21:42:50 <edwardk> @type liftIO
21:42:52 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
21:45:55 <Armored_Azrael> I assume that there's no way to automate the calling of lift, whenever someone tries to evaluate something of the inner monad?
21:46:15 <edwardk> Armored_Azrael: it does so for a lot of the misc monads, but not io
21:46:40 <edwardk> Armored_Azrael: i.e. if i  have a ReaderT Foo (StateT Bar IO) a or something like that
21:46:54 <geezusfreeek> oftentimes people make a class like MonadMyInnerMonad (such as MonadIO) which you can use to reach deeply into nested transformers
21:47:16 <edwardk> then 'get' and 'put' work on the State just find because those auto lift but the io monad stuff is generally typed with IO rather than MonadIO m => ...
21:47:17 <geezusfreeek> so long as each layer is an instance of that class
21:47:37 <geezusfreeek> yeah if only IO was an instance of MonadIO
21:47:53 <geezusfreeek> ;)
21:48:09 <edwardk> geezusfreeek: it is, they just didn't make all the IO methods that are in the libraries depend on MonadIO, just IO
21:48:20 <geezusfreeek> right
21:49:03 <geezusfreeek> i think type class hierarchies are hard to get right sometimes
21:49:21 <edwardk> especially once they have ack.. users...
21:50:21 <dmwit> I hope Haskell' makes some cripplingly non-backwards-compatible changes, and soon.
21:50:25 <dmwit> shake people up
21:50:39 * vixey will just continue using GHC
21:51:10 <geezusfreeek> i really wish haskell' was more of a revolution than evolution, but it seems to be the latter based on what i have seen so far
21:51:20 <edwardk> dmwit: i just hope someone actually pushes the haskell' folks to do something at all soon
21:51:27 <vixey> you can do better than haskell'
21:51:41 <edwardk> i understand there are real life inanities that got in the way it is just kinda frustrating
21:52:02 <geezusfreeek> screw real life
21:52:14 <geezusfreeek> i'm sick of it, personally
21:53:19 <geezusfreeek> well, that sounds depressing. i just mean i wish real life didn't have to interfere with this kind of stuff
21:53:39 <edwardk> yeah
21:53:44 <pantsd> so, would the only way to get cabal to run the tests would by setting a simple user hook to run the test program?
21:53:52 <geezusfreeek> which is basically saying nothing. i think i should go to bed
21:56:02 <pantsd> does anyone know of any cabal packages which have used the simple test hook?
21:58:19 <mmorrow> i know a bunch that have a dir "test" and a Makefile in it
21:58:33 <pantsd> hrms
21:58:45 <mmorrow> (self reliance never breaks)
22:01:40 <vixey> so how do you type check  f ... = ... g ... ; g ... = ... f ... ?
22:02:37 <vixey> I could assume f and g have variable types, infer each, then try again assuming they have the infered types .. but I don't know if I've finished, I could do it in a loop until the types don't change.. but would it ever terminate
22:02:45 <vixey> ever/always*
22:03:22 <dbueno> Does anyone know why using Network.socket.connect might fail ("connection refused") when telnetting to the same port does not? http://hpaste.org/8875
22:03:43 <dmwit> vixey: http://en.wikipedia.org/wiki/Type_inference#The_algorithm -- ?
22:03:44 <lambdabot> Title: Type inference - Wikipedia, the free encyclopedia
22:04:12 <mmorrow> but what does the "..." stand for? i think to infer a type, you need to know the context, and vice-versa. but neither??
22:04:17 <vixey> dmwit: it doesn't cover mutual recursion (or any recursion)
22:04:30 <geezusfreeek> mmorrow: i think his point is the mutual recursion
22:04:31 <mmorrow> s/and/or/
22:04:36 <geezusfreeek> *her, right?
22:04:46 <mmorrow> ohhhh.
22:04:47 <mmorrow> right.
22:04:51 <vixey> yes
22:05:01 <vixey> any two definitions that mutually recurse
22:05:30 <mmorrow> i remember reading an interesting comment in ghc about mutually recursive tyclass instances which "tie the knot"
22:05:50 <dmwit> dbueno: That code looks like it came straight out of the Network module, why don't you use the Network functions directly?
22:06:03 <dbueno> Hmm, let me rephrase: what is the proper way to turn a string number into a PortNum?
22:06:13 <dbueno> dmwit: The one line that's different is the setSocketOption line.
22:06:18 <vixey> mmorrow: that sounds terrifying
22:06:23 <dmwit> dbueno: mmm
22:06:37 <mmorrow> i can't remember the exact wording, but essentially it was equivalent to a blackhole
22:06:46 <dbueno> dmwit: I figured out I'm not turning the port into a Word16 properly.  But I don't know how to fix it.
22:06:55 * vixey doesn't implement typeclasses though
22:07:07 <dmwit> dbueno: fromIntegral . read?
22:07:11 <mmorrow>  but i believe it's entirely analogous
22:07:18 <dmwit> > fromIntegral (read "32") :: Word16
22:07:19 <lambdabot>  32
22:07:28 <dmwit> :t fromIntegral
22:07:29 <lambdabot> forall a b. (Num b, Integral a) => a -> b
22:07:51 <dmwit> PortNumber has a Num instance, so I say go for it.
22:07:53 <mmorrow> imagine a function which computes all reachable nodes from a node in a possibly cyclic graph
22:07:54 <dbueno> dmwit: wow, I never thought of fromIntegral.  But it makes sense.  Thanks.
22:08:44 <dbueno> dmwit: Err, failed.  I'm printing the (PortNum <Word16>) value and I don't get my port back.
22:09:28 <mmorrow> you need a way to determine if you're looping
22:09:45 <dbueno> > fromIntegral (read "17777") :: Word16
22:09:46 <mmorrow> if you're not looping, then progress is "still being made"
22:09:47 <lambdabot>  17777
22:10:06 <dbueno> > PortNum (fromIntegral (read "17777"))
22:10:08 <lambdabot>   Not in scope: data constructor `PortNum'
22:10:18 <dbueno> > Network.Socket.PortNum (fromIntegral (read "17777"))
22:10:19 <lambdabot>   Not in scope: data constructor `Network.Socket.PortNum'
22:10:26 <mmorrow> (bear in mind it's (as you know) possible to loop the typechecker)
22:10:31 <dmwit> > fromIntegral (read "17777") :: Network.Socket.PortNumber
22:10:32 <lambdabot>      Not in scope: type constructor or class `Network.Socket.PortNumber'
22:10:37 <vixey> it should not be
22:10:45 <dmwit> dbueno: You shouldn't need to manually wrap that type, it has a Num instance.
22:10:52 <dbueno> dmwit, good point.
22:10:53 <vixey> I mean you can loop with undecideable instances but other than that.. I hope not
22:11:03 <mmorrow> well, i think whose cases are refered to as bugs
22:11:11 <mmorrow> s/whose/those/
22:11:23 <mmorrow> (==> easy it is not)
22:11:33 <dbueno> dmwit, Brilliant!  It works.
22:11:46 <mmorrow> (it being typechecking)
22:12:42 <mmorrow> well, with newtypes i think it's trivial (or that's been fixed?)
22:12:42 <dbueno> dmwit, The source has some comment about the port needing to be in network byte order, but I didn't see any method for doing so ... and since there was a constructor for PortNum, I used it.
22:14:39 <mmorrow> vixey: ignore me, i'm beginning to think out loud
22:15:01 <vixey> mmorrow: your thoughts are worth listening to ..
22:15:18 <mmorrow> :)
22:27:15 <mmorrow> vixey: here's some miscellanea from ghc i've collected in my local hpaste2: http://hpaste.org/8876
22:27:42 <mmorrow> "and it'll even run!  The trick is to put the thing we are trying to prove
22:27:42 <mmorrow> (in this case Eq (D []) into the database before trying to prove its
22:27:42 <mmorrow> contributing clauses."
22:28:21 <mmorrow> that's the exact comment i was refering to earlier. how applicable that is to your situation i don't know..
22:33:31 <vixey> this is kind of cool http://citeseer.ist.psu.edu/446072.html
22:33:33 <lambdabot> Title: Principal Typing and Mutual Recursion (ResearchIndex)
22:34:02 <cinimod> @seen dcoutts
22:34:03 <lambdabot> dcoutts is in #gentoo-haskell, #haskell, #ghc, #haskell-overflow and #haskell-soc. I don't know when dcoutts last spoke.
22:36:51 <mmorrow> that is cool. ps saved on desktop. now.....sleeeeep
22:37:03 <mmorrow> asdefgjkl;
22:37:27 <vixey> :P
22:37:31 <vixey> night night
23:28:13 <dan> :t       *
23:28:14 <lambdabot> parse error on input `*'
23:28:44 <vixey> :t                                   (*)
23:28:46 <lambdabot> forall a. (Num a) => a -> a -> a
23:33:16 <cinimod> @hoogle State s a -> s -> (a,s)
23:33:17 <lambdabot> Control.Monad.State.Lazy.runState :: State s a -> s -> (a, s)
23:33:17 <lambdabot> Control.Monad.State.Strict.runState :: State s a -> s -> (a, s)
