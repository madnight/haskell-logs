00:04:30 <chrisdone> ah, I got it
00:04:31 <chrisdone> GOA> :pl (\x y -> x + y)
00:04:31 <chrisdone> (+)
00:04:32 <chrisdone> yay
00:07:07 <chrisdone> <3333
00:07:15 <mmorrow> Saizan_, gwern: fixed the RPGuard_ conflict with (|||) in the haskell-src-exts lexer and updated the darcs repo here: http://code.haskell.org/~morrow/code/haskell/haskell-src-exts-metaquote/
00:07:16 <lambdabot> Title: Index of /~morrow/code/haskell/haskell-src-exts-metaquote, http://tinyurl.com/5dupna
00:07:55 <gaze__> hmm... say you have an array of lists, what's the fastest way to find the shortest list in the array?
00:08:25 <chrisdone> O(n)
00:08:33 <O_4> Unless you cache that info.
00:09:42 <gaze__> eh, I meant how would the haskell gurus implement that?
00:10:21 <gaze__> not sure if a fold or map is applicable...
00:10:33 <TSC> minimumBy length
00:10:48 <TSC> (that would work for a list of lists)
00:11:35 <gaze__> how about for an array?
00:11:47 <TSC> Turn the array into a list (:
00:12:06 <gaze__> guh. that's gonna be so slow.
00:12:40 <TSC> Maybe; it doesn't change the complexity
00:12:52 <O_4> You can still just traverse it yourself.
00:13:04 <TSC> Yes, still with minimumBy
00:13:35 <TSC> e.g. minimumBy (length . (a!)) (indices a)
00:13:37 <gaze__> no no, I know it's o(n)
00:13:46 <TSC> (untested, but would probably work)
00:13:48 <gaze__> awesome :-D
00:14:11 <TSC> That effectively is the same as turning the array into a list
00:14:49 <Twey> @src Maybe =<<
00:14:49 <lambdabot> Source not found. You speak an infinite deal of nothing
00:14:56 * Twey grumbles.
00:15:12 <TSC> @src (=<<)
00:15:12 <lambdabot> f =<< x = x >>= f
00:15:22 <Twey> Oh, right.  *coughs*
00:15:23 <mmorrow> @src Maybe (>>=)
00:15:23 <lambdabot> (Just x) >>= k      = k x
00:15:23 <lambdabot> Nothing  >>= _      = Nothing
00:15:27 <Twey> Thanks :-)
00:15:36 <mmorrow> :)
00:15:50 <Twey> So (
00:15:59 <Twey> (=<<) = flip (>>=), then
00:16:06 <TSC> Yeah
00:16:19 <yitz> TSC: I'm not sure about that. ghc might compile that down to a tight loop without ever creating the list.
00:16:27 <O_4> Hmm, is there some trick to getting ghc binaries to actually write some data to their *.prof files?
00:17:05 <TSC> yitz: It might (I hope) do the same with elems anyway
00:17:22 <TSC> I'm not really familiar with all the fusion stuff
00:17:53 <chrisdone> TSC: why not?: minimumBy length (elems a)
00:18:06 <Saizan_> mmorrow: oh, nice hack, i was thinking of how to support \forall, simply reserving that operator means that we can't use it in expressions, while it's unambiguous overall, we probably have to handle this in the parser
00:18:07 <Cale> O_4: compile them with profiling, and run them with +RTS -p
00:18:08 <yitz> TSC: me neither
00:18:32 <Cale> O_4: -prof -auto-all are usable profiling options to start with
00:19:15 <chrisdone> does Data.Array.IArray.elems return a lazy list?
00:19:41 <yitz> TSC: because I've never really felt the need to. I just try my best to write beautiful Haskell, and it's always resulted in "fast enough for me".
00:19:54 <Cale> chrisdone: yes.
00:20:04 <mmorrow> Saizan_: yeah, i was thinking about that too and i think you're right
00:20:07 <TSC> yitz: Yeah, me too (:
00:20:13 <O_4> Cale: I'm using the command "ghc -O -prof -auto-all --make Main && ./Main +RTS -p -RTS"
00:20:23 <O_4> The prof file is created, there's just nothing in it.
00:20:27 <yitz> But it's nice to know that if I really need to optimize something, the low-level power is there.
00:20:41 <TSC> O_4: is the program terminating normally?
00:21:08 <chrisdone> then using minimumBy length (elems a) isn't going to be slow because each item in the list is generated and then collected on the fly as you're checking the lengths
00:21:10 <O_4> TSC: I'm not sure, it's a GLUT app and I don't know exactly how exiting is handled.
00:21:56 <mmorrow> Saizan_: then again, "forall" is in reserved_ids :: [(String,Token)] in Lexer.hs, so maybe just adding ("‚àÄ", KW_Forall) to that?
00:22:04 <chrisdone> gaze__: you see that?
00:22:13 <O_4> TSC: you're probably on the right track, though - I bet it doesn't exit in the "typical" manner.
00:23:14 <Cale> The only thing I can think of is what TSC mentioned. Try killing it with a Haskell exception.
00:25:13 <mmorrow> Saizan_: oh, that won't work because ghc allows something like (let forall x = x in forall 42) but haskell-src-exts doesn't, so i think how the lexer handles reserved words would have to be changed somehow, and maybe if this is changed smartly messing with the parser would be avoided
00:25:16 <Cale> If it's being killed with something like posix _exit, the runtime won't have time to write the profiling file.
00:26:11 <O_4> Cale: yeah, seems likely that that may be the case
00:27:39 <atp> hey folks
00:28:04 <gaze__> whoops, sorry. not specifically slow, but if I have to use an array for the whole thing then the other ops on the list will be slow.
00:28:12 <Saizan_> mmorrow: the lexer needs to know if it's scanning a type or an expression for that to work, using contexts
00:29:55 <chrisdone> hey atp
00:30:29 <mmorrow> Saizan_: hmm, i wonder how ghc does it
00:30:35 <Cale> gaze__: hm?
00:30:59 <chrisdone> yay I have Œªb on acid working fully!!
00:31:05 <chrisdone> productivity¬≤
00:31:11 <mmorrow> http://darcs.haskell.org/ghc/compiler/parser/Lexer.x
00:31:15 <mmorrow> http://darcs.haskell.org/ghc/compiler/parser/Parser.y.pp
00:33:36 <mmorrow> Saizan_: yeah totally, the parser would have to be involved no matter what
00:35:57 <atp> did you guys check out sigfpe's coalgebraic fibonacci article?  pretty neat
00:36:23 <atp> he has some nice stuff on his blog
00:42:50 <Saizan_> mmorrow: GHC does it in special_id and varid
00:43:08 <Saizan_> in the parser
00:49:17 <mmorrow> wow, after having messed with the haskell-src-exts lexer/parser, it's amazing how much more sense/readable the ghc lexer/parser makes/is
00:51:00 <yitz> @go sigfpe coalgebraic fibonacci
00:51:01 <lambdabot> No Result Found.
00:51:39 <yitz> wha? it works in regular google. what's with lambdabot?
00:52:00 <codacola> hes taking a break
00:52:28 <yitz> codacola: she, I think
00:52:53 <chrisdone> anthropomorphism!
00:52:53 <codacola> ah, well then, clearly changed her mind about how to do the task :P
00:53:21 <codacola> 5 exercises to go and im all done
00:53:27 <chrisdone> Tigge: yeah, it puts quotes around your text
00:53:34 <chrisdone> er, yitz
00:53:46 <chrisdone> so it googles "sigfpe coalgebraic fibonacci"
00:54:41 <atp> hey, does anyone have experience with template haskell?
00:54:49 * Heffalump has some
00:54:50 <chrisdone> nope
00:54:59 <yitz> chrisdone: I pasted that from my google tab, where I'm Feeling Lucky got me the right page.
00:55:02 <atp> specifically i'm looking for a good introduction to it
00:55:14 <dmwit> yitz: ?google is just plain broken
00:55:16 <atp> i don't have any experience with it, just with lisp macros
00:55:28 <atp> i understand TH provides similar metaprogramming capabilities?
00:55:46 <chrisdone> yitz: "sigfpe coalgebraic fibonacci" in google gives me no results
00:55:51 <yitz> dmwit: is that a new breakage? it used to be useful
00:55:54 <Heffalump> yes, it does, but because syntactic elements are typed it's a bit more cumbersome
00:56:19 <atp> can i use it to introduce completely new syntax?
00:56:23 <yitz> chrisdone: weird
00:56:37 <chrisdone> yitz: with quotes around the text...
00:56:40 <Heffalump> atp nope
00:56:55 <yitz> chrisdone: ah. is that the bug?
00:56:56 <atp> Heffalump: i figured not.
00:56:58 <chrisdone> yitz: http://www.google.com/search?hl=en&safe=off&q=%22sigfpe+coalgebraic+fibonacci%22&btnG=Search
00:56:58 <lambdabot> Title: "sigfpe coalgebraic fibonacci" - Google Search, http://tinyurl.com/6sbzte
00:57:10 <chrisdone> it's not a bug... Œªb just puts quotes around your search
00:57:14 <atp> Heffalump: still, is there a good intro somewhere?
00:57:22 <mmorrow> atp: there aren't really any good intros, but there's some stuff findable through the haskell wiki or google
00:57:24 <dmwit> yitz: It is pretty new; I don't know when it happened or why.
00:57:36 <Heffalump> atp: not really, as mmorrow says
00:57:43 <atp> mmorrow: i see the haskell wiki entry
00:57:49 <atp> it has some examples
00:57:50 <atp> hm
00:57:51 <dmwit> chrisdone: Oh, really?
00:57:52 <dmwit> =/
00:58:06 <atp> Heffalump, mmorrow: well, thanks anyway... i'll see if i can't figure it out
00:58:08 <mmorrow> atp: here's the realizations that got me over the initial knowing-nothing-and-not-being-able-to-get-anything-to-work to being able to mess around in ghci:
00:58:10 <yitz> dnwit: sounds like the "too many shows" bug. not too hard to fix.
00:58:19 <codacola>  (min b c) <= a && a <= (max b c) = a <- i love the look of that for some reason
00:58:30 <mmorrow> first, add ":set -XTemplateHaskell" to your .ghci
00:58:57 <chrisdone> dmwit: the evidence suggest so, anyway: google ‚Äúsigfpe coalgebraic fibonacci‚Äù and google ‚Äú"sigfpe coalgebraic fibonacci"‚Äù (thank god for curly quotes)
00:59:03 <mmorrow> possibly also :m + Language.Haskell.TH.{Syntax,Lib,Ppr} to your .ghci so it's always there
00:59:21 <mmorrow> actually, i'll paste a mini session somewhere real fast...
00:59:29 <atp> thanks mmorrow
01:01:40 <chrisdone> @go I'm going to demonstrate it with diagrams
01:01:46 <lambdabot> http://www.devshed.com/c/a/Practices/Pragmatic-Guidelines-Diagrams-That-Work/
01:01:46 <lambdabot> Title: Pragmatic Guidelines: Diagrams That Work
01:02:15 <atp> if this link is current, it's quite a good intro:
01:02:17 <atp> http://research.microsoft.com/~simonpj/papers/meta-haskell/meta-haskell.pdf
01:03:19 <chrisdone> gives different results than mine. dunno what's wrong with it then
01:05:13 <dmwit> chrisdone: I heard Google started tailoring the results they hand back based on your previous searches.
01:05:30 <dmwit> (What information they use to identify you is left to the imagination.)
01:06:01 <johnnowak> i've only noticed that while logged in
01:06:06 <atp> it's worth blocking google's cookies.
01:06:18 <dmwit> They probably also have data on what links you actually click in response to a search.
01:06:35 <dmwit> I've seen several times where a result had a time (and sometimes a count) of the last time I went there from Google.
01:06:57 <smtms> the links Google presents you in the search results are links to Google, that redirect you to the actual site
01:07:42 <johnnowak> smtms: they don't appear to be?
01:07:44 <TSC> Really?
01:07:48 <bd_> dmwit: you can disable search history
01:07:55 * dmwit doesn't mind it
01:08:09 <dmwit> I'm fine with Google having my search history, really.
01:08:24 <smtms> johnnowak, disable JavaScript and see for yourself
01:08:32 <atp> not me.  i spend too much time searching for mongolian vomit porn.
01:08:35 * atp grins.
01:08:49 <TSC> I have javascript disabled and they look like normal links
01:08:54 * dmwit doesn't mind Google knowing exactly what kind of porn he searches for
01:09:38 <dmwit> And now, it is time to experiment a bit.
01:09:48 <smtms> oh, seems they've changed it
01:10:08 <TSC> There's still onmousedown code to notice the clicking (if you have js enabled)
01:10:49 <smtms> whatever, Google Analytics gives them enough information what sites you visit
01:13:57 <mmorrow> atp: http://paste.lisp.org/display/64293
01:14:54 <mmorrow> atp: i think the best way to go about learning TH is to read Language.Haskell.TH.* and mess with it in ghci
01:15:19 <chrisdone> dmwit: yeah, google brings links that I click more often to the top of the result set. however, in this case it does indeed give the same results without quotes, so that implies Œªb does not add quotes, and some other oddness is occuring ¬∑_.
01:16:15 <chrisdone> smtms: no, you're correct
01:16:21 <chrisdone> smtms: it gives you redirect links when you're logged in
01:16:49 <chrisdone> my link to www.devshed.com/c/a/Practices/Pragmatic-Guidelines-Diagrams-That-Work/ is actually: http://www.google.com/url?sa=t&ct=res&cd=4&url=http%3A%2F%2Fwww.devshed.com%2Fc%2Fa%2FPractices%2FPragmatic-Guidelines-Diagrams-That-Work%2F&ei=DiyMSKu-DJSG0gSRxZD-Dw&usg=AFQjCNGLbj07pey5imUaO7px9PHaSHgiuQ&sig2=HYN3XUfSPgAT7tjSesdbUw
01:16:51 <lambdabot> Title: Pragmatic Guidelines: Diagrams That Work, http://tinyurl.com/6p7khv
01:17:32 <codacola> heh dont think im meant to be doing this. im editing the chapter code we're meant to import because it keeps conflicting with my code
01:17:51 <chrisdone> naughty codacola! ¬∑‚Äî¬∑
01:18:07 <codacola> im sure the lecturer has better things to do than check that :P
01:18:17 <mmorrow> atp: that paper that you linked to is somewhat dated syntax-wise, but i definitely have it along with every other scrap of template haskell info i could find printed out and in a folder :)
01:18:26 <codacola> i was just typing out the types that are defined in the book, but that got annoying quickly
01:19:17 <codacola> chrisdone: its hidden some of the prelude stuff, and then redefined them as examples. and now the 2 conflict in my assignment file. so im simply deleting them from the chapter code
01:19:52 <mmorrow> i think hpaste is having problems
01:19:52 <TSC> You can say "import Prelude hiding (xxx)" instead if you like
01:20:11 <chrisdone> mmorrow: verily so, yar!
01:20:15 <codacola> mmorrow: dunno what its doing now but i wasnt able to use it about 8 hours ago
01:21:04 <mmorrow> ruhroh. when i try to paste, it doesn't succeed in sending the paste info
01:21:08 <mmorrow> just churns away forever
01:21:16 <mmorrow> until i kill it
01:21:31 <chrisdone> could use http://paste.lisp.org/ and set highlighting mode to
01:21:33 <chrisdone> haskell
01:21:45 <mmorrow> i did, and i really like the highlighting
01:23:16 <mmorrow> http://paste.lisp.org/display/64293
01:26:46 <mmorrow> more specifically, the mouseover stuff
01:29:25 <codacola> finally, my code doesnt conflict
01:40:08 <gnut> if I have getCoord :: STUArray s Int a -> Int -> a; getCoord row r = runST lookup; where lookup = do readArray row r
01:40:20 <gnut> how do I reference s? isn't it implied in runST?
01:42:08 <ddarius> Why do you want to?
01:42:35 <yitz> gnut: first of all you want getCoord :: STUArray s Int a -> Int -> ST s a
01:43:06 <gnut> yitz: and then runST getCoord?
01:43:26 <gnut> sorry about these silly questions... I'm learning about monads and transformers right now
01:43:33 <Cale> gnut: well, pass the parameters to getCoord of course :)
01:43:48 <gnut> ddarius: maybe I don't :) it was because ghc complains about quantified s in environment
01:44:17 <Cale> gnut: and of course, you'll need to create an STUArray s Int a  first
01:44:27 <ddarius> gnut: You want to build up a complete ST computation that does everything you need to do with STArrays and STRefs and then run that ultimate computation with runST
01:44:38 <Cale> gnut: the STUArray must come from inside the same call to runST.
01:44:50 <ddarius> Usually, you have essentially only one use of runST
01:47:04 <gnut> ah... so you can't hold on to the STUArray and pass it around picking off values with each call... hmm...
01:47:20 <gnut> that makes sense
01:47:26 <gnut> let me think about this... slowly. thanks
01:48:32 <codacola> only 3 more haskell functions and then no more haskell for 2 months :D
01:49:21 <yitz> gnut: you can, as long as you stay within the ST monad, with that s always appearing as an unknown parameter.
01:52:45 <dmwit> codacola: You spelled it wrong, it should be "no more Haskell for two months D:"
01:52:47 <dmwit> ;-)
01:53:05 <gnut> yitz: okay... thanks.!
01:53:42 <codacola> dmwit: nope, pretty sure i spelt it right
01:53:56 <codacola> dmwit: theres no reasojn i couldnt do more haskell work if i wanted to :P
01:54:11 <dons> this is nice, http://www.reddit.com/comments/6tmwg/parser_combinators_are_so_cool/
01:54:12 <lambdabot> Title: Parser combinators are so cool : reddit.com, http://tinyurl.com/6mwwpl
01:54:49 <mmorrow> atp: here's some splicing: http://paste.lisp.org/display/64293#1
01:57:30 <mmorrow> uh, that foldl should be a foldr
01:58:44 <mmorrow> http://paste.lisp.org/display/64293#2
01:58:59 <gnut> woohoOO! it works!
01:59:19 <ddarius> dons: Parsec wins again.
01:59:58 <yitz> dons: "there doesn't seem to be anything here"
02:00:14 <dmwit> yitz: WFM
02:04:39 <chrisdone> hmm GOA behaves odd. it works, like hoogle works and etc. but after a while it says "No lambdabot process" and I have to restart it
02:04:44 <chrisdone> anyone else get this behaviour??
02:05:27 <TSC> I don't think it's renowned for reliability
02:05:37 <yitz> dmwit: you can tell I don't spend very much time on reddit.
02:06:42 <chrisdone> TSC: have you ever had this behaviour?
02:06:56 <TSC> I've never got it to run locally
02:07:12 <TSC> But lambdabot in here is occasionally unreliable
02:07:34 <yitz> lambdabot is much more reliable on #haskell. If something doesn't work, Cale fixes it promptly.
02:08:20 <Twey> Heh
02:09:41 <Saizan_> we should get lambdabot running on that OpenSPARC machine :>
02:11:22 <smtms> so it can serve 100 channels in parallel? or answer to queries 100 times faster?
02:12:29 <Saizan_> so it doesn't give "thread killed" so often
02:13:11 <sjanssen> Saizan_: yeah!
02:18:16 <chrisdone> ahh
02:18:28 <chrisdone> it's when I have a compile error when loading another file
02:18:40 <chrisdone> I get "Prelude GOA>" and it seems to lose the Œªb process
02:18:52 <chrisdone> I just need to find out the function to start the Œªb process again
02:19:10 <Cale> @bot
02:19:10 <lambdabot> :)
02:19:26 <chrisdone> though I guess I could run GOA in a separate ghci to my debugging ghci..
02:19:57 <chrisdone> bit lame though
02:22:34 <chrisdone> Prelude GOA> setLambdabotHome "/var/www/chrisdone/lambdabot-personal/"
02:22:35 <chrisdone> Prelude GOA> wakeup
02:22:39 <chrisdone> any way, to shorten that?
02:23:05 <chrisdone> maybe a ghci shortcut.. ":lb" or something.. let's see..
02:23:56 <mmorrow> atp: making template-haskell ASTs readable/pretty: http://paste.lisp.org/display/64293#3
02:25:09 <Taejo> I've got a program that runs in about 0.1 seconds with -O0, but 4 seconds with -O... what's going on?
02:25:19 <mmorrow> http://paste.lisp.org/display/64293#5
02:26:36 <mmorrow> Taejo: what about with -O2 ?
02:26:52 <Taejo> mmorrow: also much slower
02:26:59 <chrisdone> :def lb (\x -> do setLambdabotHome "/var/www/chrisdone/lambdabot-personal/"; wakeup; return "")
02:27:03 <chrisdone> this does the trick
02:27:15 <Taejo> I'm not sure how -O and -O2 compare, but both are slower than -O0
02:27:24 <mmorrow> Taejo: hmm, maybe paste some code somewhere?
02:28:35 <Cale> Taejo: It's definitely considered a bug for that to happen.
02:28:36 <dons> pretty much the only thing it could be is -fno-state-hack
02:29:22 <dons> what's that flag called now. hmm
02:30:41 <Taejo> is hpaste.org down?
02:30:54 <codacola> seems so
02:30:59 <dons> see this thread, Taejo http://www.nabble.com/GHC-lazy-eval-optimization-bug-td15257258.html
02:31:01 <lambdabot> Title: Nabble - Haskell - Glasgow-haskell-users - GHC lazy eval optimization bug, http://tinyurl.com/553a8b
02:31:04 <dons>  -fno-state-hack
02:31:45 <dons> http://hackage.haskell.org/trac/ghc/ticket/1168
02:31:48 <lambdabot> Title: #1168 (Optimisation sometimes decreases sharing in IO code) - GHC - Trac
02:32:06 <mmorrow> Taejo: http://paste.lisp.org has nice haskell synhighlighting + mesmerizing moueover effects
02:32:10 <Taejo> the code is at http://pastebin.com/m3503cf0d
02:32:17 <Taejo> mmorrow: too late
02:32:20 <mmorrow> heh
02:32:29 <dons> why has hpaste been down twice this week, anyone know?
02:32:35 <dons> maybe time to move over to hpaste2.
02:32:56 <chrisdone> yeeeeeaaaaaaaaah
02:32:59 <FordCortina> does darcs 2 not support ssh?
02:33:06 * mmorrow uses hpaste2 locally um like all the time
02:33:07 <dons> FordCortina: it does.
02:33:14 <dons> mmorrow: really? cool!
02:33:24 <dons> glguy would probably like to know that.
02:33:27 <chrisdone> I got lambdabot to automatically wakeup lambdabot if the process isn't already awake ^_______^
02:33:45 <mmorrow> yeah, i use it to save snippets i want to come back to, random notes, etc
02:33:56 <chrisdone> not entirely sure why that's not default but whatever
02:34:50 <FordCortina> dons: maybe im getting it wrong, but it keeps coming back with unsupported protocol
02:35:30 <Saizan_> where's hspate2?
02:35:42 <FordCortina> im doing "darcs get ssh://mylogin@myserver/pathreltomyhome"
02:36:13 <FordCortina> and "darcs get ssh://mylogin@myserver//pathreltoroot"
02:36:18 <chrisdone> wow GOA and ghci are really enhancing my haskelly productivity
02:36:29 <codacola> hahahaha
02:36:35 <codacola> i get over a month to do assignment 1
02:36:39 <Taejo> dons: -fno-state-hack seems to do it
02:36:39 <codacola> and 5 days to do assignment 2
02:36:40 <Saizan_> FordCortina: darcs get mylogin@myserver:pathreltoroot
02:36:57 <FordCortina> Saizan_: thanks ill try that
02:37:39 <Taejo> oh, it seems like (solve k) is being evaluated too many times
02:41:05 <mmorrow> Saizan_: http://code.haskell.org/hpaste.git/
02:41:25 <mmorrow> you need Takusen
02:41:27 <Taejo> dons: what is the "state hack"?
02:43:01 <Saizan_> mmorrow: gah, databases..
02:43:33 <chrisdone> Saizan_: I think even mspaint uses mysql
02:43:44 <mmorrow> Saizan_: lol
02:44:13 <mmorrow> Saizan_: at least hpaste2 uses sqlite3 via Takusen
02:45:05 <mmorrow> but takusen was a pain to get built for me (it's probably fixed now (maybe))
02:48:20 <FordCortina> Saizan_: darcs often seems to hang with "Identifying repository"
02:48:36 <FordCortina> and it doesnt print out the full path either
02:49:12 <FordCortina> :(
02:49:25 <FordCortina> might stick with hg for the moment
02:49:52 <olsner> @seen twanvl
02:49:52 <lambdabot> I saw twanvl leaving #haskell, #haskell.dut and #ghc 7h 35m 37s ago, and .
02:50:07 <Saizan_> FordCortina: for me it just works, however it's much faster at pulling via http than ssh
02:50:14 <chrisdone> mmorrow: heh, Building hpaste-2.0...  Could not find module `Database.Sqlite.Enumerator':
02:53:16 <FordCortina> Saizan_: yeh but what i really need is pushing via ssh
02:53:29 <FordCortina> which I havent tried yet
02:55:36 <FordCortina> darcs cloning works via fine via http for me, but i really need ssh to use it myself :(
02:55:46 <chrisdone> installing lambdabot.. errors when happy isn't installed
02:55:50 <chrisdone> doesn't happy be in the dependancies?
02:56:22 <chrisdone> er, shouldn't
02:56:29 * chrisdone need schleep
02:56:37 <Saizan_> FordCortina: i usually pull via http and push via ssh, and it works fine
03:04:02 <FordCortina> for some reason i have to authenticate twice
03:04:08 <chrisdone> I love errors. I can't get enough of it. http://paste.lisp.org/display/64296
03:05:32 <FordCortina> chrisdone: have you installed Takusen?
03:05:57 <chrisdone> FordCortina: I sure did, as you can see on the paste
03:06:26 <FordCortina> ah yeh sorry :S
03:06:31 <chrisdone> :P
03:07:03 <chrisdone> thanks anyway
03:09:47 <Saizan_> chrisdone: takusen uses a configure script to look for installed headers of database backends, if you don't have the ones for sqlite it doesn't build those modules
03:11:01 <FordCortina> Saizan_: do you need darcs installed remotely for darcs ssh to work?
03:11:27 <FordCortina> it shouldnt. it uses sftp and scp afterall
03:11:35 <FordCortina> ... :S
03:12:30 <Saizan_> i don't think it's necessary
03:16:25 <FordCortina> meh ill "adopt" darcs some other day
03:22:21 <maciek`> Hi! I saw interesting thing on reddit, Chipmunk bindings for Haskell
03:22:44 <maciek`> Can somebody give me a few hints how to use it?
03:23:43 <maciek`> And can it draw by itself? Or needs OpenGL for it?
03:23:46 <flux> I haven't taken a look, but have you? perhaps one of the example programs was also haskellified?
03:23:56 <flux> chipmunk doesn't have drawing
03:24:01 <flux> so yes, you want opengl or something else
03:24:17 <maciek`> i haven't found any examples
03:24:25 <dogbite> what's the lazy array
03:24:38 <dogbite> are they all lazy?
03:24:51 <flux> maciek`, perhaps you need to take a look at the original package then
03:25:13 <jpcooper> how do I darcs send to a file?
03:25:16 <maciek`> so I should use chipmunk for phisics only and HOpenGL to present results?
03:25:31 <wjt> jpcooper: -o
03:25:36 <jpcooper> thanks
03:25:45 <wjt> jpcooper: or, indeed, -O
03:25:56 <robreim> I'm looking for a bag implementation for haskell. I've got the edison library. Which data structures are suitable implementations of bags?
03:26:00 <wjt> (depending on whether you want to pick your own name for the file or not, respectively)
03:26:36 <jpcooper> wjt, aah, what's the default?
03:26:56 <jpcooper> oh, it just outputs to screen
03:28:10 <mmorrow> "chrisdone> mmorrow: heh, Building hpaste-2.0...  Could not find module `Database.Sqlite.Enumerator':"
03:28:41 <mmorrow> chrisdone: do you have Takusen installed (w/ sqlite support?)?
03:29:59 <mmorrow> heh, looks like this was already asked...
03:30:24 <chrisdone> mmorrow: ah, sorry, was on a different workspace. I'll try with the explicit configure command from the readme
03:30:42 <mmorrow> yeah, i had to mess with a bunch of stuff to get takusen built
03:30:57 <chrisdone> aye
03:32:09 <mmorrow> (commented out everything odbc in the exposed-modules: list, had to mess with the Setup.lhs because i had a newer version of cabal than it was written for, had problems with utf8-string, ...)
03:33:48 <chrisdone> hehe, wow :P
03:35:43 <julieet> ..../s hub.starfmradio.org is my server and i need staff local global and services admin for my server pLz come to our world register your favourtie chans tHkX
03:35:45 <julieet> ..../s hub.starfmradio.org is my server and i need staff local global and services admin for my server pLz come to our world register your favourtie chans tHkX
03:35:48 <julieet> ..../s hub.starfmradio.org is my server and i need staff local global and services admin for my server pLz come to our world register your favourtie chans tHkX
03:36:08 --- mode: ChanServ set +o Heffalump
03:36:13 --- kick: julieet was kicked by Heffalump (Heffalump)
03:36:31 <tusho> tHkX?
03:36:33 <tusho> what the hell is that
03:36:38 <Heffalump> thanks?
03:36:41 <Zao> I think the X signifies a kiss.
03:36:55 <Heffalump> thx is a fairly standard abbreviation for thanks
03:37:01 <Heffalump> dunno about thkx
03:37:24 <Zao> Where is the world going when people can't even spell lazyslang correctly?
03:37:42 <yitz> For those of us using colloquy - the X is the bullseye for the gunshot.
03:38:25 <mmorrow> or to mark the spot
03:38:46 <tusho> thanks
03:38:53 <tusho> t<shift>hk<shift>X
03:39:03 <RayNbow> X usually denotes a random variable :p
03:39:10 <tusho> it takes the same keypresses!
03:39:15 <tusho> and it's harder to hold shift than to just tap a key
03:45:44 <pozic> Is there a positive Double value type? (don't start about smart-constructors)
03:47:11 <tusho> pozic: Smart constr
03:47:53 <pozic> tusho: I asked for a ban for you, didn't I?
03:48:03 <tusho> pozic: I think so. :)
03:48:19 * Twey chuckles.
03:48:21 <tusho> Hmm.
03:48:25 <tusho> What about 'smart constructors'?
03:48:29 <tusho> That would be finishing it, not starting.
03:48:42 <mmorrow> pozic: maybe interpret (d::Double)<0 as (maxPosDouble + abs d) ?
03:48:55 <mmorrow> or something
03:49:15 <mmorrow> or d == abs d
03:49:16 <pozic> mmorrow: that's the same as using a smart-constructor.
03:49:25 <mmorrow> heh
03:49:30 <pozic> mmorrow: only now it's a smart-deconstructor.
03:49:50 <tusho> pozic: would you prefer ... magic?
03:50:08 <Heffalump> pozic: there's no built-in positive double type
03:50:20 <pozic> tusho: a type-level implementation of a Double could count as magic, possibly.
03:50:28 <tusho> pozic: verily.
03:51:25 <mmorrow> type level doubles seem to me at least two levels harder than type level integers. try it!
03:51:53 <pozic> mmorrow: it's just a lot of work for little to gain.
03:52:04 <mmorrow> very true
03:52:12 <mmorrow> ...about those smart constructors
03:52:14 * mmorrow ducks
03:52:40 <tusho> i request that mmorrow be banned!
03:52:52 <mmorrow> don't ban me, ban the ducks!
03:52:56 <pozic> Predicting whatever #haskell says turns into chaos, not predicting will result in the prediction. What can I do?
03:53:04 <tusho> pozic: Comment on the situation.
03:53:05 <tusho> Oh wait.
03:53:13 <pozic> tusho: you sound like the doctor.
03:53:21 <tusho> pozic: I can predict the past.
03:53:30 <tusho> That counts for something, right?
03:53:33 <pozic> tusho: no, you can't.
03:53:34 <Saizan_> any nicer way to express "takeWhile (\x -> case x of EndRuleAction{} -> False; _ -> True)"?
03:53:44 <tusho> pozic: I just predicted that you commented on the situation a few seconds earlier.
03:54:31 <pozic> tusho: how old is the universe? To the picosecond, please.
03:55:22 <tusho> pozic: It's infinite!
03:55:27 <tusho> ly old.
03:55:31 <pozic> Saizan_: introduce a function for the match with drift or by hand.
03:55:31 * tusho loves copouts
03:55:54 <pozic> Saizan_: Factor has <datatype>? for that.
03:55:56 <mmorrow> Saizan_: derive has a "Is" derivation
03:56:37 <pozic> Saizan_: which has less boilerplate and is consistent.
03:57:52 <mmorrow> for instance, if i'm in the dir that Syntax.hs is in, all i have to do is...
03:57:54 <mmorrow> derive -dIs Syntax.hs
03:57:54 <pozic> Or rather <tag>?
03:58:04 <mmorrow> then it dumps a bunch of these to stdout
03:58:09 <mmorrow> isHsPFieldPat (HsPFieldPat {}) = True
03:58:09 <mmorrow> isHsPFieldPat _ = False
03:58:09 <mmorrow> isHsGenerator (HsGenerator {}) = True
03:58:09 <mmorrow> isHsGenerator _ = False
03:58:09 <mmorrow> isHsQualifier (HsQualifier {}) = True
03:58:10 <mmorrow> isHsQualifier _ = False
03:58:12 <mmorrow> isHsLetStmt (HsLetStmt {}) = True
03:58:14 <mmorrow> isHsLetStmt _ = False
03:58:41 <pozic> mmorrow: you do understand that generating code and copying it is terrible?
03:58:58 * Twey laughs.
03:59:08 <mmorrow> then give the --module=NameOfModule --import="Blah.Blah" options to derive
03:59:09 <mmorrow> :)
03:59:21 <Twey> What is {}?
03:59:28 <mmorrow> i use this script to auto derive instance:
03:59:30 <pozic> mmorrow: and let your compile times sky-rocket.
03:59:56 <pozic> Twey: Match against the tag.
04:00:39 <Cale> Twey: It's stolen from the record syntax... you can have datatypes like  data Person = P { name :: String, age :: Integer }
04:00:45 <Twey> Yes
04:00:49 <Twey> I know that one
04:00:53 <mmorrow> pozic: then only derive the instances you want...anything can be accomodated
04:00:56 <Twey> 'tag'?
04:00:56 <Cale> and then pattern matches against that can pattern match only some of the fields
04:01:07 <Twey> Oh I see
04:01:12 <Twey> That's clever
04:01:14 <Cale> (or none of them)
04:01:31 <Cale> and the special case of matching none of them is permitted even if the type wasn't defined with record syntax
04:01:40 <pozic> Cale: what's your opinion on not having auto functions to match constructors?
04:01:51 <mmorrow> here:
04:01:52 <mmorrow> http://code.haskell.org/~morrow/code/haskell/misc/derive-all-hssyn.hs
04:01:53 <lambdabot> http://tinyurl.com/6zykxt
04:02:35 <Cale> pozic: I don't know... sometimes it's slightly annoying, but mostly it doesn't bother me too much.
04:02:36 <Twey> So, foo :: Person {name :: String} \n foo a = a -- a returns the name?
04:02:56 <Cale> er...
04:02:58 <Twey> s/- a /-/
04:03:07 <Twey> No?  *laughs*
04:03:09 <Cale> foo :: Person -> String
04:03:18 <pozic> Regarding cool record features, I really like record-puns and record wildcards.
04:03:22 <Cale> foo (P { name = a }) = a
04:03:32 <Deewiant> foo = name
04:03:33 <Twey> Aha
04:03:37 <Twey> Thanks :-)
04:03:40 <Cale> Or yeah,  foo = name  ;)
04:03:43 <Twey> Deewiant: Yeah, obviously :-P
04:03:48 <pozic> Too bad that the wildcards feature is slightly broken...
04:03:49 <Deewiant> :-)
04:04:24 <Twey> So I guess there's no real point in using {}?  It's just there for completeness?
04:04:34 <FordCortina> sorry if this is a bit off-topic... but does the *P*ascal language really call Floating point numbers "Reals". That just seems really stupid....
04:04:41 <Cale> {} allows you to avoid matching the fields
04:04:45 <tusho> FordCortina: *P*ascal?
04:04:56 <tusho> ___P!!!!___ascal?
04:04:58 <FordCortina> yes Pascal... i know
04:05:05 <tusho> why *P*ascal
04:05:08 <tusho> why not Pascal
04:05:10 <pozic> What's a dropWhile where I can communicate a sum between two different elements? Zip the sums?
04:05:21 <FordCortina> tusho: just to make it clear
04:05:30 <tusho> FordCortina: uhh, what?
04:05:31 <tusho> :s
04:05:36 <Cale> pozic: zipping first sounds like a good idea
04:05:38 <tusho> Haskell
04:05:38 <tusho> Pascal
04:05:42 <tusho> totally different
04:05:43 <hml> is there a good c parser written in haskell?
04:05:47 <tusho> hml: Language.C
04:05:51 <Cale> hml: One is being written
04:05:51 <hml>  or is it a totally trivial exercise using Parser?
04:06:03 <Twey> What's Parser?
04:06:09 <tusho> twey- Parsec
04:06:10 <tusho> I imagine
04:06:11 <Twey> From Parsec?
04:06:12 <Twey> Oh
04:06:12 <FordCortina> tusho: when you say "Haskell" out loud everyone thinks im saying "Pascal"
04:06:15 <tusho> but no, it's not trivial, hml
04:06:19 <tusho> try Language.C
04:06:21 <FordCortina> s/you/I
04:06:25 <Twey> FordCortina: I had that JUST YESTERDAY
04:06:34 <hml> Cale: is the one you're referring to also Language.C?
04:06:42 <Cale> hml: yeah
04:06:44 <Twey> 'What are you doing at the moment?' 'Oh, I'm looking into learning Haskell...' 'Ah, Pascal?'
04:06:56 <Deewiant> Haskell and Pascal have the stress on different syllables
04:06:58 <tusho> "I'm working with monads"
04:07:01 <tusho> "Ewww... tmi"
04:07:12 <Twey> Deewiant: To be fair, the guy was Tunisian
04:07:16 <Cale> http://code.haskell.org/language-c/
04:07:16 <lambdabot> Title: Index of /language-c
04:07:21 <FordCortina> Twey: yeh its really annoying
04:07:27 <Cale> is the alpha version :)
04:07:58 <hml> Cale, tusho: awesome; thanks
04:08:02 <tusho> np :)
04:08:29 <Cale> http://hsbene.blogspot.com/2008/07/first-things-first.html -- here's the blog of the guy who is working on it
04:08:30 <lambdabot> Title: Pointerfull Haskell: First things first ?
04:09:07 <Twey> Haskell + pointers?  What?!  O.O
04:09:47 <Cale> Prelude> :m + Foreign.Ptr
04:09:48 <Cale> Prelude Foreign.Ptr> :m + Foreign.Storable
04:09:48 <Cale> Prelude Foreign.Ptr Foreign.Storable> poke (intPtrToPtr 0xdeadbeef) 0
04:09:50 <Cale> Segmentation fault
04:10:08 <FordCortina> lol
04:10:47 <Benigno> 13:10:44 ï 27/07/2008 ï Sunday
04:10:51 <Benigno> ups
04:11:35 <Twey> Yow
04:11:43 <Twey> That doesn't seem very pure...
04:11:56 <Benigno> it is a blasphemy
04:12:01 <Cale> poke :: forall a. (Storable a) => GHC.Ptr.Ptr a -> a -> IO ()
04:12:08 <Twey> Oh it's in IO
04:12:11 <Twey> Hmmm.  :-)
04:14:15 <hml> hmm; is Language.C from darcs broken?
04:14:16 <hml> x@x:~/lc/language-c$ runhaskell Setup.hs build
04:14:16 <hml> Preprocessing library language-c-0.2.7...
04:14:16 <hml> Setup.hs: can't find source for Language.C.System.GCC in ["src"]
04:14:54 <pozic> hml: are you building a toy or something real?
04:15:26 <hml> pozic: i want to do static analysis on the linux kernel in haskell
04:15:41 <hml> pozic: should i bit the bullet and roll my own parser?
04:15:43 <pozic> hml: there already is a parser for the linux kernel.
04:15:49 <hml> byt it's called sparse
04:15:50 <hml> and ti's in c
04:15:54 <hml> i want to do things in haskell
04:16:16 <pozic> hml: so, parse it with that library and build an ast data type in haskell from that.
04:16:17 <Cale> hml: I don't know how operational Language.C is as of yet.
04:16:38 <pozic> hml: that's a practical way to get results.
04:16:39 <Cale> hml: You might try communicating with the author. Seems like your project would be a pretty excellent test case :)
04:16:56 <pozic> hml: using an untested library is going to give you headaches.
04:17:16 <pozic> hml: but it will improve the Haskell library, if you do.
04:18:08 <pozic> hml: one problem is that there is more than one C.
04:18:21 <pozic> hml: C89, C99, GCC and so on.
04:18:33 <hml> actually, at the momnet, i only care about the linux kernel
04:18:47 <hml> as for not using sparse and preferring haskell; i just want something more hackable
04:19:01 <hml> since it's likely i'll have to mod it here and there for weird things
04:19:22 <hml> it looks like Language.C is not what i want though;
04:19:35 <Cale> hml: you might want to rename the file that it's not finding :)
04:19:46 <Cale> hml: Looks like there's a case sensitivity issue there
04:20:09 <Cale> I'll get the darcs repo and see if I can get it to build :)
04:22:03 <hml> Cale: thanks for the ip
04:22:23 <hml> renaming Gcc.hs to GCC.hs seems to be working so far; complaints about newlines, looks like this was wrirtten on windows, lol
04:23:05 <hml> great, it built
04:23:13 <Cale> cool
04:24:42 <mmorrow> hml: i renamed GCC to Gcc in the exposed-modules: section of the cabal file
04:24:48 <mmorrow> seemed saner :)
04:24:54 <mmorrow> (more sane?)
04:25:04 <Cale> mmorrow: Inside the module itself, it's called GCC though...
04:25:10 <mmorrow> uhoh
04:25:23 <mmorrow> heh, my build just failed
04:26:40 <mmorrow> nice, building....
04:27:15 <mmorrow> can't wait til someone makes a C QuasiQuoter...
04:27:51 <Cale> Rewrite GCC in Haskell ;)
04:28:17 <Heffalump> is the SoC project making a C parser, or just fixing up the C abstract syntax?
04:28:39 <Heffalump> yes, it is a parser
04:28:47 <Heffalump> so making a quasiquoter from that should be trivial
04:28:52 <Saizan_> taking it from c2hs?
04:28:53 <mmorrow> from what i understand, it's overhauling and extracting the c2hs parser
04:29:09 <Heffalump> yeah
04:29:43 <mmorrow> the guy who wrote the quasiquote paper actually implemented one (a C qq)
04:29:52 <mmorrow> (so says the paper...)
04:29:57 <Heffalump> was it full C?
04:30:17 <mmorrow> Heffalump: i can't remember
04:30:22 * mmorrow gets the paper
04:30:30 <Heffalump> my vague recollection was that it wasn't
04:30:58 <Cale> http://www.sivity.net/projects/language.c/wiki/Cee
04:31:01 <lambdabot> Title: Cee - language.c - Trac
04:31:02 <mmorrow> i guess the fullness of the C if (mostly) a product of the fullness of the parser
04:31:08 <mmorrow> s/if/is/
04:31:58 <mmorrow> http://www.eecs.harvard.edu/~mainland/ghc-quasiquoting/mainland07quasiquoting.pdf
04:32:00 <lambdabot> Title: Why It‚Äôs Nice to be Quoted: Quasiquoting for Haskell, http://tinyurl.com/yo9sa3
04:33:15 <jpcooper> http://paste.lisp.org/display/64298 <-- Cale: could you tell us why we can't put the (Show a) bit at the ObjectCons declaration in the declaration of the Constructor type, please?
04:33:56 <hml> @hoogle mod
04:33:56 <lambdabot> Prelude.mod :: Integral a => a -> a -> a
04:33:56 <lambdabot> Prelude.module :: keyword
04:33:56 <lambdabot> Data.Fixed.mod' :: Real a => a -> a -> a
04:33:58 <mmorrow> hmm:
04:34:02 <mmorrow> "                            Although we do not present the full
04:34:03 <mmorrow> details here, we have built a quasiquoter for ANSI C (with GCC
04:34:03 <mmorrow> extensions), so we know that our approach scales to real lan-
04:34:03 <mmorrow> guages.
04:34:03 <mmorrow> "
04:34:49 <hml> @hoogle take
04:34:49 <lambdabot> Prelude.take :: Int -> [a] -> [a]
04:34:49 <lambdabot> Data.List.take :: Int -> [a] -> [a]
04:34:49 <lambdabot> Data.ByteString.take :: Int -> ByteString -> ByteString
04:35:04 <hml> what's the 'reverse' of take, i.e. it returns me everything except the first n elements
04:35:12 <Deewiant> drop
04:35:26 <Deewiant> > drop 3 [1..5]
04:35:28 <hml> :src drop
04:35:30 <lambdabot>  [4,5]
04:35:38 <hml> @src drop
04:35:38 <lambdabot> drop n xs     | n <= 0 =  xs
04:35:38 <lambdabot> drop _ []              =  []
04:35:38 <lambdabot> drop n (_:xs)          =  drop (n-1) xs
04:37:58 <chrisdone> Cale: (by "we" he means him and me; we're both writing this code in a shared emacs screen session :P)
04:38:14 <chrisdone> (and Skyping about it)
04:40:11 <hml> s
04:40:25 <chrisdone> ¬∑_¬∑
04:40:49 <hml> i'm trying to writ ehte fastest permutation  function i can think of; I came up with the following; can anyone else do better?
04:40:53 <hml> perm :: [a] -> Int -> [a]
04:40:55 <hml> perm [] _ = []
04:40:58 <hml> perm lst cnt = let offset = cnt `mod` length lst in reverse $ (reverse $ take offset lst) ++ (reverse $ drop offset lst)
04:43:59 <Saizan_> > let lst = [1..10]; offset = 4 in reverse $ (reverse $ take offset lst) ++ (reverse $ drop offset lst)
04:44:00 <lambdabot>  [5,6,7,8,9,10,1,2,3,4]
04:45:51 <Botje> > let perms [] = [[]]; perms (x:xs) = let p = perms xs = p ++ map (x:) p in perms [1..3]
04:45:51 <lambdabot>  Parse error at "=" (column 54)
04:45:59 <Botje> > let perms [] = [[]]; perms (x:xs) = let p = perms xs in p ++ map (x:) p in perms [1..3]
04:46:00 <lambdabot>  [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
04:46:04 <Botje> oh wait
04:46:07 <Botje> that's powerset O_o
04:46:07 <Cale> > let perm xs n = take m (drop (n `mod` m) (cycle xs)) where m = length xs in perm [1..10] 213
04:46:09 <lambdabot>  [4,5,6,7,8,9,10,1,2,3]
04:46:20 <Cale> Botje: and he's not really after perms
04:46:40 <Botje> oh yeah
04:46:45 <Botje> oops :)
04:47:00 <Cale> Just rotations
04:47:17 <hml> ah; sorry, my bad
04:47:20 <hml> permutation was misl3eading
04:47:25 <hml> @hoogle rotation
04:47:25 <lambdabot> No matches found
04:47:31 <hml> @hoogle rotate
04:47:31 <lambdabot> Data.Bits.rotate :: Bits a => a -> Int -> a
04:47:31 <lambdabot> Data.Bits.rotateL :: Bits a => a -> Int -> a
04:47:31 <lambdabot> Data.Bits.rotateR :: Bits a => a -> Int -> a
04:47:37 <Cale> cycle is a useful function here
04:47:40 <Cale> > cycle [1..10]
04:47:41 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,6,...
04:47:44 <hml> cycle creates an infinite l.ist though ...
04:47:47 <Cale> right
04:47:50 <hml> hmm, then i do a    bunch of tails'
04:47:56 <hml> and take the length of the original list
04:47:58 <Cale> so then you chop out the section of that infinite list that you want
04:48:06 <hml> @src cycle
04:48:06 <lambdabot> cycle [] = undefined
04:48:06 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
04:48:11 <painy> > zip [1..10]
04:48:12 <Cale> > let perm xs n = take m (drop (n `mod` m) (cycle xs)) where m = length xs in perm [1..10] 213
04:48:13 <lambdabot>  Add a type signature
04:48:13 <lambdabot> painy: You have 1 new message. '/msg lambdabot @messages' to read it.
04:48:13 <lambdabot>  [4,5,6,7,8,9,10,1,2,3]
04:48:15 <Cale> like that
04:48:54 <hml> man; infinite lists screws up my mental notions of running time
04:48:57 <chrisdone> Could not deduce (Show a) from the context ()
04:48:58 <Cale> or you could use zip
04:48:59 <chrisdone> what does ()mean?
04:49:03 <hml> 3especially big o notation
04:49:57 <Cale> > let perm xs n = zipWith (flip const) xs (drop n (cycle xs)) in perm [1..10] 213
04:49:58 <lambdabot>  [4,5,6,7,8,9,10,1,2,3]
04:50:14 <Cale> That avoids calculating the length of the list, but you'll end up doing more drops.
04:50:45 <Cale> (if the number to rotate by is larger than the length of the list)
04:51:39 <Cale> > let perm xs n = zipWith (flip const) xs (drop n (cycle xs)) in perm [1..10] 213000
04:51:40 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
04:51:43 <Cale> > let perm xs n = zipWith (flip const) xs (drop n (cycle xs)) in perm [1..10] 2130000
04:51:44 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
04:51:45 <Cale> > let perm xs n = zipWith (flip const) xs (drop n (cycle xs)) in perm [1..10] 21300000
04:51:47 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
04:51:49 <Cale> > let perm xs n = zipWith (flip const) xs (drop n (cycle xs)) in perm [1..10] 213000000
04:51:51 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
04:51:55 <Cale> hmm :)
04:51:57 <Cale> > let perm xs n = zipWith (flip const) xs (drop n (cycle xs)) in perm [1..10] 21300000000
04:51:57 <chrisdone> ._.
04:51:58 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
04:52:04 <Deewiant> @check \xs ys -> ys == zipWith (flip const) xs ys
04:52:04 <lambdabot>  Falsifiable, after 0 tests: [], [()]
04:52:09 <Cale> Pretty fast though :)
04:52:09 <Deewiant> oh, right
04:52:23 <hml> > let perm xs n = zipWith (flip const) xs (drop n (cycle xs)) in perm [1..10] 213000000000
04:52:24 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
04:52:27 <hml> > let perm xs n = zipWith (flip const) xs (drop n (cycle xs)) in perm [1..10] 2130000000000000
04:52:34 <lambdabot> Terminated
04:53:15 <Deewiant> > let perm xs n = take m (drop (n `mod` m) (cycle xs)) where m = length xs in perm [1..10] 2130000000000000
04:53:17 <lambdabot>  [7,8,9,10,1,2,3,4,5,6]
04:53:58 <hml> > let perm xs n = zipWith (flip const) xs (drop n (cycle xs)) in perm [] 2130000000000000
04:53:59 <lambdabot>  []
04:54:03 <Cale> oh, haha
04:54:05 <Cale> duh
04:54:08 <Cale> Int
04:54:13 <hml> > let perm xs n = take m (drop (n `mod` m) (cycle xs)) where m = length xs in perm [] 2130000000000000
04:54:15 <lambdabot>  []
04:54:20 <Cale> Stupid Int :)
04:54:21 <hml> how does that work?
04:54:30 <Cale> > 2130000000000000 :: Int
04:54:31 <lambdabot>  1163862016
04:54:33 <hml> isn't it diviginb by zero?
04:54:37 <olsner> > let perm xs n = take m (drop (n `mod` m) (cycle xs)) where m = fromIntegral length xs in perm [] 2130000000000000
04:54:41 <lambdabot>   add an instance declaration for (Num ([a1] -> Int))
04:54:48 <Deewiant> hml: take 0 _ = []
04:55:02 <Deewiant> it doesn't get as far as evaluating the drop, and therefore the mod
04:55:02 <Cale> drop, take, and length all use Int
04:55:05 <hml> oh wait; this is laziness to the rescue/
04:55:13 <hml> Deewiant: that is really cool; thanks
04:55:16 <hml> @src take
04:55:17 <lambdabot> take n _      | n <= 0 =  []
04:55:17 <lambdabot> take _ []              =  []
04:55:17 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
04:55:32 <hml> man, this is cool.
04:55:38 <Deewiant> :-)
04:55:51 <Cale> Outermost-first!
04:55:59 <hml> almost must be a bitch to be on the other side of this 'coolness' and debug such a byug
04:56:31 <Cale> It's just important to remember the order in which things are evaluated.
04:57:41 <Cale> heh, no wonder it was so fast...
04:57:50 <Cale> > 213000000000 :: Int
04:57:51 <lambdabot>  -1748364800
04:58:12 <Cale> I hate Int.
04:58:22 <Cale> I wish it wasn't in the Prelude.
04:58:51 <yitz> Cale: agreed, it's a premature optimization.
04:59:22 <paczesiowa> will ghc optimise (e.g. add) during compilation smth like this: two = 1+1 ?
04:59:24 <yitz> otoh, I wish Integer wasn't LGPL.
04:59:33 <hml> LGPL ?
04:59:40 <hml> as in the license?
04:59:43 <yitz> yeah
04:59:44 <Zao> libgmp, I assume.
04:59:49 <yitz> right
05:00:03 <yitz> that will soon change though
05:00:20 <hml> why is LGPL bad?
05:00:27 <smtms> yitz, which library will be used instead?
05:00:33 <baaba> it's evil
05:00:34 <Zao> hml: Incompatible with old-BSD.
05:00:42 <baaba> mit 4lyfe yo
05:01:05 <Zao> By the way, has there been any work to remove readline as a dependency for GHC?
05:01:07 <yitz> not evil imho, but not always appropriate.
05:01:16 <yitz> Zao: that's done.
05:01:23 <Zao> 6.9 or 6.10 then?
05:01:29 <hml> how do I fix the following? (Bad)
05:01:30 <hml> data Good a = Good [a]
05:01:30 <hml> data Bad a = Bad x:y:z:[]
05:02:00 <Cale> x:y:z:[] isn't a type
05:02:01 <yitz> hml: you can't use functions in a constructor
05:02:16 <paczesiowa> data Bad a = Bad (a,a,a) ?
05:02:39 <hml> got it; thanks
05:02:58 <hml> ?paste
05:02:59 <lambdabot> Haskell pastebin: http://hpaste.org/new
05:03:01 <yitz> smtms: so far, there are a few new mp implementations that are being tried, but yeah, we could also link to a different library.
05:04:19 <hml> why not implement it as [Int] ? is preformance all that important for this?
05:04:30 * hml has been happy with 32bit ints for a long long time ...
05:05:27 <yitz> hml: LGPL requires you to provide every end user with the means to replace the LGPL library with something else. Since GHC generally links statically when it compiles, that basically means you have to provide your users with the means to recompile it themselves. So very little difference remains between LGPL and GPL.
05:06:26 <yitz> hml: people are used to Haskell programs being fast :)
05:07:22 <tusho> yitz: uhh
05:07:23 <tusho> they are?
05:07:32 <tusho> coulda fooled me
05:07:50 <olsner> tusho: you must be doing it wrong :)
05:07:54 * yitz has been unhappy with 32-bit ints for a long long time
05:07:55 * Twey chuckles.
05:08:06 <tusho> olsner: I've seen tons of complaints about haskell speed
05:08:12 <tusho> Unless you mean unsafeHaskell#.
05:08:25 <Twey> Haskell's faster than Erlang at concurrency!
05:08:45 <tusho> Erlang isn't really about speed, is it?
05:08:50 <tusho> It's about being able to patch the server in realtime.
05:08:51 <yitz> tusho: Haskell competes with C in the shootout, without unsafe stuff.
05:08:54 <tusho> And extreme fault-tolerance.
05:09:18 <Deewiant> and being able to run stuff on multiple machines without any extra setup
05:09:19 <dmhouse> I think the real test is how fast idiomatic Haskell is.
05:09:26 <Twey> yitz: Link please :-)
05:09:26 <dmhouse> Of course, it depends how you define "idiomatic".
05:09:38 <dmhouse> ?where shootout
05:09:38 <lambdabot> http://shootout.alioth.debian.org/
05:09:56 <hml> hmm; hpaste.org is very slow
05:10:02 <hml> been  waiting 6 mins for this post
05:10:22 <hml> anyone eles having problems? (the link l.oads up fine; it's juyst the save button that  takes forever; and i'm only pasting 7 lines of code to it)
05:10:45 <Saizan_> hml: yeah, some problems on the server probably
05:10:56 <dmhouse> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=ghc&lang2=gcc - GHC verses GCC
05:10:57 <lambdabot> Title: Haskell GHC benchmarks | Gentoo : IntelÆ PentiumÆ 4 Computer Language Benchmarks ..., http://tinyurl.com/2vdkpl
05:11:25 <Saizan_> @get-shapr
05:11:26 <lambdabot> shapr!!
05:11:27 <tusho> dmhouse: I said "not unsafeHaskell#".
05:11:40 <tusho> @get-test
05:11:40 <lambdabot> Unknown command, try @list
05:11:42 <tusho> Hah.
05:11:45 <hml> to really win; we need haskell progrmas that call harpy :-)
05:12:35 <hml> how can i make this take up less horixontal space? (hpaste.org/new is very slow for me) http://rafb.net/p/Ex7SoR91.html
05:12:41 <hml> *horizontal*
05:12:47 <dmhouse> tusho: not many of the shootout programs use unsafe operations
05:13:03 <dmhouse> hml: put the let on a new line
05:13:21 <hml> dmhouse : how many white spaces do i need to ident the let if it's on a new line?
05:13:27 <Botje> more than zero
05:14:02 <hml> http://rafb.net/p/Z87qwc27.html
05:14:02 <lambdabot> Title: Nopaste - No description
05:14:05 <hml> looks better, can i do more?
05:14:13 <dmhouse> hml: two is conventional, http://rafb.net/p/itOpZ949.html
05:14:13 <lambdabot> Title: Nopaste - No description
05:14:34 <dmhouse> hml: you can put as many newlines in there as you like
05:14:47 <hml> ah; so whenever i put in a new line, i only have to ident it two, nice
05:14:49 <hml> thanks
05:16:06 <dmhouse> http://rafb.net/p/cLGDxH47.html or something
05:16:06 <lambdabot> Title: Nopaste - No description
05:18:23 <yitz> tusho: the messy explicit unboxing and memory poke-peeking is all old stuff. those are not needed in modern Haskell, and the shootout entries are being gradually replaced by more native stuff as people work on it. Of course, maximal optimization is the whole point here, so just as in C, not everything will be the neatest possible solution.
05:25:36 <mmorrow> heh, unsafeHaskell# is a perfect name for it
05:25:42 <hml> in list notation, can I generate an element twice, like if I have [1, 2, 3]; and I want to produce [2, 3, 4, 6, 6, 9]; basically, something like [ 2*x, 3*x | x <- [1, 2, 3]]
05:25:47 <tusho> mmorrow: it's up there with Caleskell
05:26:10 <mmorrow> it's true
05:26:41 <dmhouse> hml: no, but you could do [2*x | x <- [1..3]] ++ [3*x | x <- [1..3]], perhaps with a sort in there
05:26:57 <Saizan_> > concat [ [2*x, 3*x] | x <- [1, 2, 3]]
05:27:02 <lambdabot>  [2,3,4,6,6,9]
05:27:17 <hml> @src concat
05:27:17 <lambdabot> concat = foldr (++) []
05:27:32 <hml> Saizan_: thanks; taht's awesome
05:27:36 <dmhouse> Ooh, or that.
05:28:09 <Cale> > do x <- [1,2,3]; [2*x, 3*x]
05:28:12 <lambdabot>  [2,3,4,6,6,9]
05:28:12 <Shiruka> the operations with # in GHC gain their speed from the fact that they are executed on the newer and hence superior and faster .NET platform
05:28:25 <Cale> Shiruka: what?
05:28:36 <tusho> Shiruka: GHC 4.0 will include a special # option
05:28:39 <tusho> you can append # to any function
05:28:41 <Shiruka> just humor that occurred to me from the "unsafeHaskell#" :-)
05:28:45 <tusho> and it'll automatically translate it to C#
05:28:55 <Cale> Shiruka: oh, right
05:28:55 <hml> Cale: how does your code work, with the do?
05:28:58 <tusho> hmm, maybe a better name for unsafeHaskell# is !unsafeHaskell#
05:29:02 <_zenon_> hml, the list monad
05:29:04 <dmhouse> ?remember Shiruka the operations with # in GHC gain their speed from the fact that they are executed on the newer and hence superior and faster .NET platform
05:29:04 <lambdabot> Good to know.
05:29:09 <hml> Cale: ah, the >> of the list monad?
05:29:12 <_zenon_> however, foldl' would be faster
05:29:15 <Cale> hml: >>=
05:29:17 <dmhouse> Shiruka: although without context, that will make you look like an idiot.
05:29:23 <Cale> > [1,2,3] >>= \x -> [2*x, 3*x]
05:29:24 <lambdabot>  [2,3,4,6,6,9]
05:29:24 <Shiruka> haha :-)
05:29:33 <hml> Cale , _zenon_ : got it; thanks
05:29:36 <Cale> >>= is the same as concatMap
05:29:43 <Cale> (with args flipped)
05:29:52 <hml> btw, how do I get the src of >>= of the Listmonad from lambdabot?
05:29:54 <Cale> > concatMap (\x -> [2*x,3*x]) [1,2,3]
05:29:55 <lambdabot>  [2,3,4,6,6,9]
05:30:00 <Cale> @src [] >>=
05:30:00 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
05:30:06 <Cale> @src >>= []
05:30:06 <lambdabot> Source not found.
05:30:07 <Cale> hmm
05:30:13 <Cale> @src [] (>>=)
05:30:13 <lambdabot> xs >>= f     = concatMap f xs
05:30:13 <Saizan_> @src [] (>>=)
05:30:13 <lambdabot> xs >>= f     = concatMap f xs
05:30:18 <Cale> there it is :)
05:30:31 <_zenon_> hml, http://www.haskell.org/all_about_monads/html/listmonad.html
05:30:31 <lambdabot> Title: The List monad
05:30:34 <dmhouse> Hah, lambabot's quotes get better and better.
05:30:37 <hml> @src Maybe (>>=)
05:30:38 <lambdabot> (Just x) >>= k      = k x
05:30:38 <lambdabot> Nothing  >>= _      = Nothing
05:30:42 <hml> cool
05:30:49 <hml> I lovre @src
05:31:12 <dmhouse> It's not always the actual implementation in GHC.
05:31:40 <dmhouse> It pulls it in from the report's sample implementation, IIRC.
05:31:59 <Saizan_> not that it matters here
05:37:37 <zeta-> Has anyone seen www.haskell.org recently? It's been like that for a while.
05:38:13 <pozic> zeta-: and the problem is?
05:38:15 <hml> s
05:38:25 <hml> s
05:38:49 <zeta-> problem is it's corrupted
05:39:03 <Shiruka> example page?
05:39:03 <dmhouse> It is?
05:39:05 <Deewiant> looks good here?
05:39:12 * dmhouse sees no corruption
05:39:59 <Shiruka> maybe you have a broken cache? try shift+reload
05:40:09 <pozic> dmhouse: you are too corrupted to see the corruption.
05:40:39 <pozic> Maybe the Sun logo is the corruption?
05:40:52 <Shiruka> haha
05:40:55 * pozic has nothing against Sun
05:41:40 <zeta-> Ok thanks, it's back to its former glory :-)
05:41:41 <Shiruka> if that's corruption, then simon working with MS and talking about deals with the devil would surely have qualified ages ago, no? ;-)
05:43:56 <yitz> hey, www.haskell.org actually looks nice, they've improved it.
05:45:53 <Shiruka> :-O
05:46:09 <Shiruka> "iException 0.0.1 - Version of Control.Exception using InterleavableIO."
05:46:13 <Shiruka> sounds thoroughly evil
05:46:52 <yitz> Shiruka: !unsafeHaskell#
05:47:42 <Shiruka> besides, iException sounds like it requires a Mac
06:06:30 <FordCortina> does the SOEGraphics library work on linux?
06:07:19 <FordCortina> oops
06:07:59 <FordCortina> probably didnt read properly
06:09:13 <EvilTerran> there's a Graphics.OpenGL.SOE or something somewhere which def will work
06:09:44 <EvilTerran> a wrapper around OpenGL
06:10:46 <EvilTerran> ah, Graphics.SOE.Gtk - it wraps Gtk, not OpenGL
06:10:59 <EvilTerran> ?hackage soegtk
06:10:59 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/soegtk
06:12:21 <FordCortina> yeh i noticed a gtk version somewhere
06:12:33 <FordCortina> i must have missed the bit in the book where it talks about installing it
06:15:06 <FordCortina> EvilTerran: i think you're right on both counts, theirs and OpenGL one *and* a gtk one
06:15:31 <FordCortina> s/theirs/there's
06:18:54 <EvilTerran> i see
06:19:33 <FordCortina> meh... ill stop trying to find the point in the book where it tells you to install the library. I'll follow http://www.haskell.org/soe/software1.htm
06:19:34 <lambdabot> Title: Software
06:24:33 <drguildo> i think the versions that work under linux were released after the book
06:33:42 <sal23> hpaste working for anyone? hpaste.org doesn't seem to be saving new submissions....
06:36:12 <yitz> sal23: yeah, it's not feeling so well today. you can use paste.lisp.org in the meantime
06:38:04 <sal23> thx yitz
06:38:33 <yitz> @seen shapr
06:38:33 <lambdabot> I saw shapr leaving #haskell-blah and #haskell 14h 59m 22s ago, and .
06:39:21 <sal23> http://paste.lisp.org/display/64306 - output order is reverse of expected order which doesn
06:39:26 <sal23> 't make sense
06:40:25 <ziman> sal23, applyEachH fs x acc++[f x] parses as (applyEachH fs x acc) ++ [f x]
06:41:23 <ziman> and note that such appending to a list is O(n) for each step, thus O(n^2) for the algorithm
06:41:27 <sal23> hmm... what is the parsing order again?
06:41:40 <sal23> yeah, I know about O(n^2)
06:41:53 <sal23> just playing with it...
06:41:53 <ziman> function application binds the tightest
06:42:23 <ziman> you probably wanted applyEachH fs x (acc ++ [f x])
06:42:45 <sal23> so, basically rewrite it as: applyEachH fs x (acc ++ [f x])
06:43:08 <ziman> then it should be in the other order ;)
06:43:24 <sal23> yeah, thx ziman...
06:43:52 <ziman> yw
06:43:52 <sal23> btw, the good way to write it is: applyEach fs x = map (\f -> f x) fs
06:43:58 <sal23> well, one of the good ways....
06:44:07 <Deewiant> map ($x) fs
06:44:17 <sal23> yeah, that too
06:44:58 <Deewiant> flip (map . flip ($))
06:45:24 <jpcooper> is there a way to see if an MVar is taken, without actually taking the lock on it if it isn't?
06:46:17 <Deewiant> ?hoogle MVar a -> IO Bool
06:46:17 <lambdabot> GHC.Conc.isEmptyMVar :: MVar a -> IO Bool
06:46:17 <lambdabot> Control.Concurrent.MVar.isEmptyMVar :: MVar a -> IO Bool
06:46:17 <lambdabot> GHC.Conc.tryPutMVar :: MVar a -> a -> IO Bool
06:47:10 <ziman> > sequence [(+1), (*2), (+5)] 7
06:47:13 <lambdabot>  [8,14,12]
06:47:28 <jpcooper> okay
06:53:52 <jpcooper> Deewiant, are there any locks without values?
06:54:04 <Deewiant> MVar ()?
06:56:41 <jpcooper> Deewiant, then how can one make it block things or not?
06:57:07 <Botje> by taking the mvar? :)
06:57:09 <Deewiant> well, takeMVar still blocks...
06:57:32 <Botje> you could even put undefined in the mvar
06:57:38 <Botje> to assure nobody does evil things with your ()
06:58:56 <Saizan_> your precious ()?
06:59:47 <Saizan_> it does look like The One.. and it's also called 1..
07:00:16 <jpcooper> aah, I get it
07:10:31 <Botje> "this is my (). there are many others like it but this one is mine. I must cherish and protect this () like it was my own."
07:28:25 <__pao__> is the correct to say that "guards" are only syntactic sugar?
07:30:21 <kryptiskt> __pao__, well, yes, you can see what they can be translated into in the H98 report
07:30:43 <Shiruka> :-O googling about random floating point stuff, found an amusing article in theregister (which I don't normally read, except for the bofhs)
07:30:46 <__pao__> kryptiskt: thanks... I'll check
07:30:49 <Shiruka> "Then, the real voodoo suggestions start to arrive. People will talk of using doubles instead of floats, [...]"
07:31:06 <Shiruka> I thought it was the other way around, using floats being more voodoo than doubles..
07:31:14 <dmhouse> __pao__: guards as in |, or as in the guard function?
07:31:25 <__pao__> dmhouse: |
07:32:24 <dmhouse> Hmm, I'm not so sure they are simple sugar
07:33:00 <dmhouse> E.g. I don't think you can write them solely in terms of if, in case that's what anyone was thinking.
07:33:57 <kryptiskt> 3.17.3 in the H98 report has the semantics of case
07:34:25 <dmhouse> Yeah, they can be written in terms of case, in which case you consider them part of pattern matching
07:34:36 <dmhouse> (Top-level pattern matching, i.e., multiple equations.)
07:34:37 <vixey> oh
07:34:45 <vixey> f C D x y | bool = ...
07:35:00 <vixey> case ... of (C, D, x, y, True) -> ...
07:35:06 <vixey> like that ?
07:35:17 <dmhouse> That'd do it, yeah.
07:35:42 <dmhouse> Sometimes you can write it just with if. But sometimes not
07:36:49 -HarpyFiend(n=oxy@bl10-149-123.dsl.telepac.pt)- You have 1 new message. Type /server mail to read it.
07:37:05 <dmhouse> > let foo [()] | False = 'a'; foo [_] = 'b'; foo _ = 'c' in foo [()]
07:37:06 <lambdabot>  'b'
07:37:17 <dmhouse> -- That can't be written in terms of just ifs, I don't think.
07:37:36 <Botje> sigh
07:37:48 <Botje> silly /server pranks --
07:37:49 <vixey> > let foo x = if x == [()] && False then 'a' else 'b' in foo [()]
07:37:50 <lambdabot>  'b'
07:38:23 <vixey> if couldn't bind any variables
07:38:57 <vixey> oh
07:39:05 <dmhouse> Well, something that's not Eq.
07:43:34 <__pao___> dmhouse: can you provide a simple example for when they are not translatable to "if"?
07:43:42 * __pao___ has been disconnected... :-(
07:44:20 <dmhouse> I'm trying.
07:44:30 <dmhouse> > let foo [()] | False = 'a'; foo [_] = 'b'; foo _ = 'c' in foo [()] -- this would work if () wasn't in Eq.
07:44:31 <lambdabot>  'b'
07:45:40 <vixey> humf
07:45:43 <vixey> I don't think I can' use a monad
07:46:01 <vixey> I have,
07:46:12 <vixey>   y <- œï [1..10]
07:46:24 <vixey>  if y == 3 then cut else return ()
07:46:40 <__pao___> dmhouse: What False is check against?
07:46:41 <vixey> and I wanted cut to modify the value of œï [1..10]
07:46:45 <vixey> bbut that's impossible..
07:47:15 <vixey> so I guess that I have to use something else than a monad
07:49:25 <vixey> "Despite their generality, monads do not cater for every possible notion of impure function. In particular, monads do not cater for stream functions"
07:50:33 <dmhouse> __pao___: http://rafb.net/p/zHQJR028.html
07:50:34 <lambdabot> Title: Nopaste - No description
07:50:47 <dmhouse> vixey: what's a stream function, typewise?
07:51:08 <vixey> they've got data Stream a = a :< Stream a
07:51:28 <vixey> newtype SF a b = SF (Stream a -> Stream b)
07:51:33 <__pao___> dmhouse: thanks
07:51:34 <vixey> instance Arrow SF where
07:51:38 <__pao___> dmhouse: let me check it :-)
07:51:41 <vixey>   pure f = SF (mapS f)
07:51:51 <vixey>   SF k >>> SF l = SF (l . k)
07:52:08 <vixey>   first (SF k)  SF (uncurry zipS . (\ (as, ds) -> (k as, ds)) . unzipS)
07:52:22 <vixey>   first (SF k) =
07:52:50 <jeroenp> Build question: How to get readline support in ghci?
07:55:23 <__pao___> dmhouse: quoting from yaht "One thing to note about guards is that they are tested after pattern matching, not in
07:55:24 <__pao___> conjunction with pattern matching. This means that once a pattern matches, if none of
07:55:24 <__pao___> the guards succeed, further pattern matches will not be attempted. So, if we had instead
07:55:24 <__pao___> defined"....
07:55:55 <dmhouse> Err, really?
07:56:08 <__pao___> dmhouse: according to that explanation I would have expected your code to return an error... but it does not...
07:56:21 <__pao___> dmead: let me check yaht example
07:57:11 <Cale> __pao___: yaht is wrong then
07:57:24 <__pao___> Cale: yes... it is
07:57:57 <__pao___> Cale: I've tried the example that should give error but it didn't
07:58:27 <__pao___> it's a real pity that such a good book is unmaintained
07:58:30 <dmhouse> __pao___: see http://en.wikibooks.org/wiki/Haskell/YAHT/Language_advanced#Guards which is an imported version of YAHT, which contains a contradictory phrase.
07:58:31 <lambdabot> http://tinyurl.com/y4u7rv
07:58:37 <dmhouse> "Guards are applied in conjunction with pattern matching. When a pattern matches, all of its guards are tried, consecutively, until one matches. If none match, then pattern matching continues with the next pattern."
07:58:58 <dmhouse> Strange that such a popular tutorial would have such a glaring error...
07:59:01 <dmhouse> ?where yaht
07:59:01 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
07:59:07 <Cale> dmhouse: Which version has the error?
07:59:18 <dmhouse> __pao___: which version has the error?
07:59:21 <Cale> Many things on the wiki version have been corrected from the original PDF.
07:59:33 <EvilTerran> > case () of _ | False -> "..."; _ -> "ok"
07:59:34 <lambdabot>  "ok"
07:59:38 <EvilTerran> the first version's wrong
07:59:45 <__pao___> dmhouse: I suppouse I've the latest pdf...
07:59:45 <EvilTerran> that's what i thought
07:59:59 <__pao___> Copyright (c) Hal Daume III, 2002-2006
08:00:21 <vixey> OI comonad
08:00:29 <vixey> hGetChar' :: OI Hangle -> CHar
08:00:41 <vixey> hPutChar' :: OI Hangle -> OI Char -> ()
08:00:49 <__pao___> I suppouse that Daume got a compiler/interpreter bug...
08:00:55 <dmhouse> __pao___: ?where's version is correct.
08:00:58 <dmhouse> ?where yaht
08:00:58 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
08:01:03 <dmhouse> Use that version.
08:01:14 <__pao___> dmhouse: let me check
08:02:17 <dmhouse> Yeah, seems to have been changed at some point: http://en.wikibooks.org/w/index.php?title=Haskell%2FYAHT%2FLanguage_advanced&diff=1142406&oldid=620918 scroll down to "Line 623"
08:02:18 <lambdabot> http://tinyurl.com/67mxdq
08:03:33 <Cale> vixey: There are issues with comonadic IO
08:04:06 <vixey> what are they?
08:04:18 <Cale> vixey: One being that in order to make sense, you have to be prepared to split reality into arbitrarily many possible worlds.
08:05:52 <vixey> what
08:06:23 <Cale> (or just accept nondeterministic ordering of effects)
08:06:28 <wjt> Cale: got any recommended comonadic IO reading?
08:08:49 <Cale> Let me see if I can dig up some good mailing list threads...
08:08:53 <__pao___> dmhouse: what is then the lasted and greatest pdf version? :-)
08:09:06 <dmhouse> __pao___:
08:09:09 <dmhouse> ?where yaht
08:09:09 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
08:09:46 <__pao___> ... and the ?where version is guaranteed to be always the lastest? :-)
08:09:47 <Dynetrekk> hello everyone. anyone tell me how to access the numerator & denominator of a rational?
08:09:48 <Cale> wjt, vixey: the main problem is that you can duplicate the world that's given to you
08:09:56 <wjt> oh, rgiht
08:10:19 <Cale> So you have to remember every state you've ever had in the past, at the very least.
08:10:22 <dmhouse> __pao___: it's in a darcs repo, so it's probably up-to-date :)
08:10:43 <__pao___> dmhouse: thank you, I've been very helpful
08:10:53 <__pao___> you've...
08:10:54 <__pao___> :-)
08:10:56 <dmhouse> Heh.
08:11:17 <Cale> Hehe, "thank me, I'm welcome!"
08:11:37 <paczesiowa> > let third = 1%3 in (numerator third, denominator third)
08:11:38 <lambdabot>  (1,3)
08:11:55 <Cale>          comain :: OI a -> ()
08:11:55 <Cale>          comain w
08:11:55 <Cale>              = coeval (w .>> show (a,b) =>> stdPutStrLn)
08:11:55 <Cale>              where
08:11:55 <Cale>                  a = coeval (w .>> () =>> stdGetChar)
08:11:56 <Cale>                  b = coeval (w .>> () =>> stdGetChar)
08:12:18 <Dynetrekk> paczesiowa: thanks. but "let" is sin, right? (haskell newbie, unfortunately)
08:12:38 <vixey> oooo
08:12:39 <Cale> was one example, from Andrew Bromage http://www.mail-archive.com/haskell-cafe@haskell.org/msg02408.html
08:12:40 <lambdabot> Title: Re: comonads, io, http://tinyurl.com/5vy8ys
08:12:59 <baaba> Dynetrekk, why would it be?
08:13:14 <baaba> it just gives a name for an expression
08:13:17 <paczesiowa> Dynetrekk: absolutely no! it is just an expression let identifier = expression in otherExpressionInvolving identifier
08:13:24 <Cale> Dynetrekk: There's nothing wrong with let
08:13:35 <Dynetrekk> paczesiowa: sorry, my mistake then :-)
08:13:51 <vixey> Dynetrekk: Nothing is haskell is a sin :)
08:14:03 <Dynetrekk> paczesiowa: I'm basically trying to compare the denominator with the numerator, but it seems to be rather hard...
08:14:28 <vixey> > let x = 3%3 in numerator x == denominator x
08:14:29 <lambdabot>  True
08:14:34 <vixey> Dynetrekk: ^ here is one way,
08:14:52 <Dynetrekk> ah, okay
08:14:53 <baaba> vixey, unsafePerformIO is evil :P
08:15:01 <vixey> > let x = 3%3 in x == 1
08:15:03 <lambdabot>  True
08:15:07 <baaba> and using it a sin
08:15:08 <vixey> Dynetrekk: ^ and a shorter way to do the same thing ^
08:15:11 <dmhouse> > sin pi -- vixey, really?
08:15:12 <lambdabot>  1.2246063538223773e-16
08:15:40 <Deewiant> > sin pi :: CReal
08:15:42 <lambdabot>  0.0
08:16:34 <__pao___> it would be really helpful if some haskell guru could fill up the unwritten chapters in yaht...
08:17:01 <__pao___> it is like watching a movie without final :-)
08:17:29 <dmhouse> __pao___: there are many alternative resources for the more advanced topics.
08:17:31 <roconnor> @pl (\x -> compare (numerator x) (denominator x))
08:17:31 <lambdabot> liftM2 compare numerator denominator
08:17:39 <dmhouse> __pao___: what do you want to learn about? :)
08:17:41 <wjt> @ty pi
08:17:42 <lambdabot> forall a. (Floating a) => a
08:17:42 <b_jonas> couldn't you just compare to 1?
08:17:52 <vixey> b_jonas: I like that idea
08:17:53 <__pao___> dmhouse: exceptions... there is a chapter on the book...
08:18:00 <Dynetrekk> vixey: thanks, seems to work even like this though:
08:18:10 <wjt> > (0:+1) * pi
08:18:11 <__pao___> dmhouse: I've tried the wiki but I fear I'm not getting the whole picture...
08:18:11 <lambdabot>  0.0 :+ 3.141592653589793
08:18:21 <__pao___> dmhouse: error handling strategies in general
08:18:21 <roconnor> > iI compare numerator denominator Ii (3%3)
08:18:22 <lambdabot>   Not in scope: data constructor `Ii'
08:18:28 <roconnor> aww
08:18:32 <Dynetrekk> vixey: biggerDenom r = (numerator r) > (denominator r)
08:18:37 <roconnor> lambdabot should get idiom brackets
08:18:46 <roconnor> they would be fun to play with
08:18:49 <vixey> Dynetrekk: oh
08:19:02 <vixey> Dynetrekk: just a note, functions like numerator always bind tighter than operators
08:19:13 <vixey> Dynetrekk: so you may write,  biggerDenom r = numerator r > denominator r  here if you prefer
08:19:35 <b_jonas> > {-iI-} compare numerator denominator {-li-} (3%3)
08:19:36 <lambdabot>  Couldn't match expected type `Ratio t1 -> t'
08:19:36 <roconnor> > liftM2 compare numerator denominator (3%3)
08:19:37 <lambdabot>  EQ
08:19:44 <paczesiowa> and leave parens for lispers who really need them
08:20:13 <Dynetrekk> vixey: great, thanks
08:20:45 <wjt> roconnor: ugly :(
08:20:49 <b_jonas> oh, so by idiom brackets, you need fork brackets !
08:20:53 <Dynetrekk> paczesiowa: yep, I tried lisp. got tired of the parentheses... sheesh
08:35:49 <vixey> how do you use ListT (State Bool) a ?
08:36:23 <vixey> I don't know how to do x <- [1..10]
08:36:29 <vixey> like pick x from 1 .. 10
08:36:42 <__pao___> @ty ListT
08:36:42 <lambdabot> Not in scope: data constructor `ListT'
08:36:55 <vixey> :k ListT
08:36:56 <lambdabot> Not in scope: type constructor or class `ListT'
08:37:12 <vixey> *Main> :t ListT
08:37:12 <vixey> ListT :: m [a] -> ListT m a
08:37:12 <vixey> *Main> :k ListT
08:37:12 <vixey> ListT :: (* -> *) -> * -> *
08:39:19 <__pao___> vixey: x <- return [1...10]?
08:39:59 <__pao___> vixey: return is for the enclosed monad
08:40:09 <vixey> __pao___: that gives a type error
08:42:17 <paczesiowa> lift?
08:44:35 <__pao___> vixey: I really think x <- return [1...10] should be the solution... If you provide a self-enclosed code snippet I'll try to give a look...
08:45:02 <__pao___> Disclaimer: I'm a uber newbie
08:45:16 <mauke> __pao___: that's equivalent to 'let x = [1..10]'
08:45:16 <vixey> type M2 a = ListT (State Bool) a runM2 a = runState (runListT a) False foo' :: M2 Integer foo' = do x <- return [1..10]           return x
08:45:25 <vixey>     Couldn't match expected type `Integer' against inferred type `[t]'
08:45:26 <vixey>     In the first argument of `return', namely `x'
08:46:41 <joey_> map return?
08:46:50 <vixey> ugh
08:47:12 <__pao___> mauke: return is the return for the enclosed monad... not for the monad transformer
08:47:18 <mauke> __pao___: wrong
08:47:57 <__pao___> mauke: if you say so... I trust you :-)
08:48:18 <vixey> __pao___: ... and that it gives a type error
08:48:32 * gwern sighs. this SICP torrent is going to take forever, it seems
08:48:32 <__pao___> vixey: I trust the compiler as well :-)
08:49:14 <gwern> so, anyway. I've decided to take dons advice and start a split darcs repo/hackage package. does anyone have any split implementations or tests that'd be handy?
08:50:03 * vixey is sorry for asknig..
08:53:36 <masak> how do I use trace in GHCi?
08:56:30 <sebaseba_> @src trace
08:56:31 <lambdabot> trace string expr = unsafePerformIO $ do
08:56:31 <lambdabot>     hPutStrLn stderr string
08:56:31 <lambdabot>     return expr
08:57:46 <sebaseba_> masak: just import Debug.Trace, and use it like:  trace "some string" $ foo x y
08:57:49 <charles441> gwern: Have you tried the direct downloads for SICP? They were quicker for me than the torrent.
08:58:02 <gwern> charles441: the whats?
08:58:04 <masak> sebaseba_: thanks
08:58:16 <gwern> charles441: I thought they were bootleg, how could there be direct?
08:58:29 <vixey> gwern: they are on the MIT site
08:58:30 <dbbddbdb> Hi!  When I try to compile hsxmpp, I get
08:58:30 <dbbddbdb>     Could not find module `System.Random':
08:58:31 <dbbddbdb>       it is a member of package random-1.0.0.0, which is hidden
08:58:39 <dbbddbdb> But System.Random loads fine in GHCi
08:58:48 <gwern> dbbddbdb: you on 6.8?
08:58:49 <Heffalump> dbbddbdb: add random to the packages list in the .cabal file
08:58:53 <dbbddbdb> gwern: yeah
08:59:06 <gwern> dbbddbdb: where did you get hsxmpp from? I thought we had cleaned up alltthe spli-base
08:59:12 <dbbddbdb> gwern: Darcs repo
08:59:28 <dbbddbdb> gwern: http://www.dtek.chalmers.se/~henoch/darcs/hsxmpp/ to be exact
08:59:29 <lambdabot> Title: Index of /~henoch/darcs/hsxmpp
08:59:30 <gwern> (seriously, if the ghc or cabl folks do a breaking change like split-base anytime in the next few years, I will scream)
08:59:32 <gwern> dbbddbdb: ln pls
08:59:44 <gwern> thanks. that should really be patched
09:00:03 <dbbddbdb> gwern: ln?
09:01:03 <gwern> charles441: well, that explains why my torrent is so slow. I'm using an unofficial one which transcoded into ogg. so no one is on that torrent...
09:02:06 <gwern> dbbddbdb: man ln :)
09:02:15 <gwern> ooh, hsxmpp is not on hackage?
09:02:17 <charles441> gwern: not sure if the torrent I downloaded was transcoded into Ogg, but there was torrent link of the main MIT site that was very slow, much slower that the induvidual downloads anyway.
09:02:46 <dbbddbdb> gwern: but what should I ln?
09:03:32 <gwern> dbbddbdb: it was idiomatic, sheesh
09:03:58 <gwern> ln = link = hyperlink; pls = please, 'ln pls' = 'please tell me the hyperlink for the darcs repo'
09:04:12 <dbbddbdb> Ah.  Sorry, I didn't get it :)
09:04:29 <gwern> charles441: I don't mind torrenting as long as it will eventually complete; I am a charitable person and so am pleased to donate bandwidth
09:04:33 <gwern> even if it is MIT...
09:04:42 <charles441> I'm not.
09:05:29 <gwern> I mean, heck, it's not like I'm doing anything with most of it
09:07:38 <sal23> http://paste.lisp.org/display/64311
09:07:59 <vixey> twice twice twice twice (+1) 0
09:08:01 <sal23> the second output is confusing.....am trying to figure out how it evaluated to
09:08:10 <vixey> = ((((twice twice) twice) twice) (+1)) 0
09:08:16 <vixey> = (((fourtimes twice) twice) (+1)) 0
09:08:24 <sal23> so, basically normal evaluation
09:08:27 <vixey> = ((eighttimes twice) (+1)) 0
09:08:34 <vixey> hmm
09:08:41 <gwern> > let twice f = (\x -> f (f x))
09:08:42 <lambdabot>  Parse error at end of input
09:08:43 <vixey> that was wrong
09:08:52 <vixey> sa123: Evaluation order doesn't matter here
09:08:56 <gwern> @let twice f = (\x -> f (f x))
09:09:00 <lambdabot> Defined.
09:09:02 <vixey> sa123: Any order of evaluation of that will give the same result
09:09:08 <gwern> > twice twice twice twice (+1) 0
09:09:11 <lambdabot>  65536
09:09:28 <gwern> anyone remember how to do the printing of a function relfection stuff?
09:09:30 <sal23> yeah, that needs some explanation compared to twice (twice twice twice)
09:09:40 <vixey> > twice twice twice twice (+1) x
09:09:41 <lambdabot>  x + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + ...
09:10:05 <sal23> > twice (twice twice twice) (+1) x
09:10:07 <lambdabot>  x + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + ...
09:10:12 <vixey> sa123: they are different expressions, evaluation order isn't what matters here
09:10:22 <sal23> yeah, I know what you are saying....
09:10:23 <vixey> i.e.  1 + 2 * 3 is different to (1 + 2) * 3
09:10:34 <vixey> ok I thought you just asked for an explanation
09:11:10 <sal23> vixey: I did want an explanation but in second case....I think you explained it well
09:11:27 <ski> vixey : `x <- ListT (return [1...10])' should work .. but that's a bit ugly
09:12:14 <ski> vixey : what we'd want is `forall n a. Monad n => m a -> t n a' for a "base monad" `m' and corresponding monad transformer `t'
09:13:03 <ski> though, what should we call this operation ?
09:13:13 <vixey> ListT . return = msum . map return
09:13:32 <vixey> Cale called it option
09:13:43 <ski> (btw, cf. `mapListT' et.c.)
09:14:09 <sal23> vixey: (eighttime twice) should evaluate to sixteen, not 65536
09:14:10 <ski> Cale : why `option' ?
09:15:05 <vixey> sal23: That eighttimes was wrong
09:15:57 <sal23> hmm....so, still leaves the mystery of evaluation to 65536
09:16:17 <vixey> > 2^2
09:16:19 <Cale> ski: it's for picking one of a list of items
09:16:24 <ski> vixey : anyway .. the operation isn't really specific to `[]' and `ListT', so i would object to a name specific to those
09:16:29 <ski> Cale : ^
09:16:33 <lambdabot>  thread killed
09:16:37 <vixey> > (2^2)^2
09:16:52 <lambdabot>  thread killed
09:16:54 <Cale> :t msum . map return
09:16:58 <lambdabot> forall a (m :: * -> *). (MonadPlus m) => [a] -> m a
09:17:05 <Cale> It's specific to []
09:17:09 <ski> <ski> vixey : what we'd want is `forall n a. Monad n => m a -> t n a' for a "base monad" `m' and corresponding monad transformer `t'
09:17:13 <ski> Cale : ^
09:17:44 <vixey> it seems like StateT s [] a and ListT (State s) a are both useless to me at the moment
09:17:50 <ski> Cale : ok. your formulation is specific. my wasn't
09:18:06 <ski> vixey : what do you want to do ?
09:18:17 <Cale> ski: I'm not sure I have enough context in this conversation to understand what that function would be.
09:18:23 <vixey> test = do x <- œï [1..3]
09:18:23 <vixey>           y <- œï ['a','b','c','d','e','f']
09:18:24 <vixey>           if y == 'c' then cut else return ()
09:18:26 <vixey>           z <- œï $ words "red yellow blue"
09:18:28 <vixey>           return (x,y,z)
09:18:37 <vixey> I was trying to get that to work
09:18:47 <vixey> but I think it's maybe not something that makes sense in a monad
09:18:57 <ski> Cale : e.g. `forall s n a. Monad n => State s a -> StateT s n a' would be another example
09:19:07 <Cale> ski: oh
09:19:34 <ski> Cale : sortof the mirror image of `lift'
09:20:01 <Cale> That's not really a generalisation of msum . map return though, of course :)
09:20:14 * ski wonders what `œU' before `[1..3]' means ..
09:20:25 <olsner> ski: phi
09:20:32 <vixey> ski, I don't know what it means yet
09:20:42 <vixey> it's just that using lists directly wont be possible
09:20:42 <dmhouse> C'mon, get with the Unicode.
09:20:44 <ziman> that's capital phi here
09:20:50 <ski> Cale : well, it is a generalization of `ListT . return', which was equivalent to `msum . map return' ;)
09:21:01 <vixey> I could have called it 'f' or anything...
09:21:07 <ski> ok
09:21:30 <ski> (Cale : .. which was equivalent to ... *in*this*context*)
09:21:32 <gwern> dbbddbdb: ok, I've sent off patches to the author that should clean it up and make it hackage-ready
09:21:50 <dmhouse> ziman: are you sure? I don't think it ought to be. However lowercase and uppercase phi look pretty similar
09:22:04 <dbbddbdb> gwern: thanks!
09:22:35 <dmhouse> Hrm, I guess it could actually be uppercase phi, it's a little hard to tell with my font.
09:22:45 <Cale> ski: okay :)
09:23:02 <ski> vixey : what do you want to use the state for ? how should it be passed on wrt the nondeterminism ?
09:23:05 <ziman> dmhouse, ah yes, i'm used to \varphi (œÜ) as the lowercase phi
09:23:41 <gwern> dbbddbdb: how did you find hsxmpp anyway?
09:23:46 <ski> (Cale : this context being `[]' and `ListT' .. your `msum . map return' was overloaded)
09:23:50 <ziman> that might have been \phi
09:23:57 <dmhouse> vixey: does phi turn a list into a stream? I.e. is it essentially cycle?
09:24:00 <dbbddbdb> gwern: by googling for ¬´haskell xmpp¬ª
09:24:28 <gwern> huh. I'm getting 1.1m down for my sicp lectures. nice
09:24:36 <ski> dmhouse : presumably, it lifts the list nondeterminism into the nondeterminism part of the ambient monad
09:24:44 <gwern> dbbddbdb: oh. :) find anything else worthwhile? there's nothing on hackage right now
09:25:43 <gwern> http://www.mail-archive.com/haskell-cafe@haskell.org/msg22437.html <-- ah. 3 repos?
09:25:44 <lambdabot> Title: Re: [Haskell-cafe] ANN: XMPP 0.0.1, http://tinyurl.com/6g2v7c
09:25:49 <gwern> 'Congrats, you are (at least) the third person to do this.'
09:25:54 <gwern> see, this is why we need hackage!
09:26:17 <gwern> @seen sorear
09:26:17 <lambdabot> I haven't seen sorear.
09:26:33 <gwern> @seen stepcut
09:26:33 <lambdabot> I haven't seen stepcut.
09:26:53 <dbbddbdb> gwern: no, didn't find anything else XMPP or Jabber related
09:29:22 <mapreduce> :t par
09:29:27 <lambdabot> forall a b. a -> b -> b
09:29:44 <vixey> I don't know
09:29:50 <vixey> I just think it's impossibly
09:29:52 <mapreduce> How does par work?  I'd be expecting a monad for that.
09:29:54 <vixey> impossible*
09:31:14 <dolio> vixey: Just don't implement cut. Cut is clearly evil. :)
09:31:47 <roconnor> par works by having denotational semantics equivalent to const
09:32:03 <roconnor> @src par
09:32:03 <lambdabot> Source not found. I feel much better now.
09:32:32 <ski> vixey : you think *what* is impossible ?
09:32:44 <roconnor> par might spawn a thread to start normalizing it's first parameter, you never know.
09:32:50 * dmhouse draws pictures of continuations
09:32:50 <vixey> ski, to have a monadic cut
09:32:58 <roconnor> then again const might also spawn such a thread.
09:33:54 <ski> vixey : well, if you want cut's non-composotionality, then you need to add some construct for erecting a frame that cut could latch onto
09:34:23 <ski> since it can't know on its own where that "predicate clause" boundary is
09:34:53 <ski> s/if you want/if you want something alike/
09:35:02 <vixey> oh yeah
09:35:18 <ski> you didn't answer how you want to use the state
09:35:21 <vixey> maybe I should try with callcc
09:35:37 <vixey> I was trying to use it as a boolean whether or not there was a cut, it can't work though
09:35:42 <ski> depending on that, you might want to use the one- or two- continuation encoding of nondeterminism
09:36:08 <ski> (instead of `[]' or `ListT', i mean)
09:37:40 <ski> hm .. didn't sigfpe had a post with nice pictures of various ways of combining monad transformers ?
09:37:49 <ski> i can't seem to find it, atm :(
09:41:39 <dolio> It seems to me that if you implement cut by giving it something to attach to, you're back to essentially 'once' from logict.
09:42:07 <gwern> osfameron's split hurts my head :(
09:42:11 <dolio> Only you've split it into a delimiter, and something in the wrapped block that can abort to that delimiter.
09:42:16 <adiM> How do I remove old packages from ghc? ghc -v says http://hpaste.org/9185 which shows a lot of old packages
09:42:59 <adiM> It also says "wired-in package ndp not found." which I don't understand?
09:43:16 <ski> dolio> :t LogicT.once
09:43:35 <dolio> MonadLogic m => m a -> m a
09:44:07 <ski> i'm not sure .. maybe a "prompt and control" variant of cut would be more expressive ?
09:44:26 <Cale> adiM: ghc-pkg unregister bytestring-0.9.0.1
09:44:32 <dolio> Well, it would let you abort arbitrarily, instead of only succeeding once.
09:44:33 <Cale> adiM: and so on
09:44:37 <dolio> (I think.)
09:45:06 <adiM> Cale: does unregistering also remove the package (delete from hard disk)?
09:45:11 <Cale> adiM: no
09:45:22 <Cale> adiM: (You currently have to do that manually)
09:45:49 <Cale> Where'd you get that list?
09:46:05 <ski> dolio : cf. `promise_equivalent_solution_sets' and `arbitrary' in Mercury
09:46:12 <ski> <http://www.cs.mu.oz.au/research/mercury/information/doc-latest/mercury_ref/Goals.html#Goals>
09:46:13 <lambdabot> Title: Goals - The Mercury Language Reference Manual, http://www.cs.mu.oz.au/research/mercury/information/doc-latest/mercury_ref/Goals.html#Goals>
09:46:17 <adiM> Cale: This is the output of ghc -v
09:46:23 <Cale> adiM: ah, okay
09:46:38 <Cale> adiM: I don't think the old packages will actually cause any problem if you leave them there.
09:46:52 <Cale> (after all, it knows to hide them)
09:47:17 <Cale> It's interesting that your compiler is only stage 2 and not stage 3...
09:47:18 <adiM> Cale: Ok... Do you know anything about the "wired in package mdp not found"
09:47:37 <Cale> ndp would be nested data parallelism. I think it's not supposed to be there yet.
09:47:44 <Cale> (It's something being worked on)
09:48:07 <adiM> cale: I am using ghc from ubuntu... what does compiler stage 2 vs stage 3 mean?
09:48:46 <ski> > "mdp" == "ndp"
09:48:47 <Cale> adiM: Well, when building, the compiler compiles itself a number of times. I'm not 100% sure what the differences between Stage 2 and 3 are.
09:48:50 <lambdabot>  False
09:49:30 <allbery_b> ideally none
09:49:30 <thoughtpolice> there's a stage 3 now?
09:49:39 <allbery_b> stage 1: build wiht existing compiler
09:49:46 <allbery_b> stage2: rebuild with stateg1 compiler
09:50:30 <allbery_b> stage3: rebuild with stage2 compiler; the result should be the same as stage2 modulo timestamps, otherwise the compiler is generating bad code
09:50:36 <Cale> ah, okay
09:50:37 <adiM> thanks
09:50:50 <ski> so it's a fixpoint check
09:56:55 <mapreduce> roconnor: So par works because the thread an expression is evaluated on is unspecified in general, so par can specify it without breaking anything?
09:57:07 <adiM> Isn't cabal supposed to resolve dependencies on its own?
09:57:13 <mapreduce> So I'd guess par is compiler magic?
09:57:27 <adiM> I was installing Yi, and it said that package alex could not be found.
09:57:46 <adiM> I did "cabal install alex" and then installating of Yi worked fine.
09:57:57 <adiM> I thought that cabal did such things automatically
09:57:59 <thoughtpolice> adiM: alex isn't specified as a yi dependency
09:58:27 <thoughtpolice> cabal install will only pick up stuff listed under 'dependencies', and alex is an external program, not a library, so specifying a dependency on it is kinda hard
09:58:50 <adiM> ah
09:59:43 <dmhouse> If you can cabal install it doesn't it make it essentially a library?
09:59:47 <dmhouse> I.e. it's a cabal package.
09:59:53 <Cale> mapreduce: yes, par is primitive
10:00:14 <Cale> mapreduce: It's the primitive from which pure parallelism is currently specified.
10:00:46 <mapreduce> I suppose it gives you fork-join in the simplest possible interface.
10:01:00 <mapreduce> Does the implementation include work-stealing?
10:01:26 <mapreduce> @google doug lea fork join
10:01:28 <lambdabot> http://gee.cs.oswego.edu/dl/papers/fj.pdf
10:01:28 <lambdabot> Title: A Java Fork/Join Framework
10:01:37 <mapreduce> That's where I'm getting my terms from.
10:01:45 <Cale> If the expression is already evaluated by the time the spark gets around to evaluating, nothing happens.
10:01:57 <thoughtpolice> dmhouse: cabal install will register you installed it but if the program is just an executable, e.g. alex/happy, it doesn't really have a library. cabal install picks up dependencies from the 'dependencies' field of the .cabal files, which are libraries registered with ghc
10:02:11 <roconnor> par is for parallel compuation, not for concurrency.
10:02:29 <matthew-_> mapreduce: unless I've misunderstood you, work stealing is only necessary if you have work queues local to each OS thread such that you can end up with a thread without any work to do
10:02:45 <Cale> (I'm not really sure what you mean by work stealing)
10:02:50 <dmhouse> thoughtpolice: right, so "cabal install alex" just tells Cabal you've actually installed alex, it doesn't do any installation of its own?
10:02:53 <mapreduce> matthew-_: Yes.
10:03:11 <mapreduce> Cale: It's defined in that paper and can be inferred by what matthew-_ just said :)
10:03:40 <matthew-_> mapreduce: well, I would doubt it's implemented that way
10:03:43 <Cale> There's a single queue onto which sparks are put, and workers on the OS threads take things from that queue as they free up.
10:03:52 <Cale> At least, that's my understanding.
10:03:59 <mapreduce> Cale: Always from the same end of the queue?
10:04:08 <Cale> as far as I know
10:04:44 <matthew-_> mapreduce: simply because you typically run +RTS -N$c where $c is the number of cores. Well work stealing only starts making sense when you have lots of contention for the same given queue, and that would require lots of threads
10:04:51 <mapreduce> If you have a queue per thread and another thread can 'steal' things from the other end of that queue, then you can more efficiently distribute the work, afaict.
10:04:55 <matthew-_> where "lots of threads" is >> number of cores
10:05:00 <thoughtpolice> dmhouse: right, cabal-install registers the installation with cabal-install and ghc (in the case that the package exports a library,) but dependencies can only be specified on libraries
10:05:25 <matthew-_> seeing as the number of cores is low, contention is low, thus a single work queue will not impeed performance
10:05:30 <thoughtpolice> so if your package does depend on say alex/happy being installed, cabal install won't pick that up, because alex/happy have no libraries, so they can't be specified in the dependency field
10:05:43 <mapreduce> matthew-_:
10:05:49 <mapreduce> ..I see, makes sense.
10:06:34 <matthew-_> it's always just an engineering decision about contention. Sure, if you did +RTS -N1024, I'd expect problems.
10:06:44 <thoughtpolice> dmhouse: this is a minor annoyance, it might be worth mentioning to dcoutts if he isn't already aware
10:06:47 <matthew-_> but the work stealing code is MUCH more complex and tricky to get right
10:07:12 <matthew-_> but let me be clear, I'm guessing here. I don't actually know what the GHC RTS does
10:07:32 <Cale> You should never set an N which is larger than the number of your cores anyway
10:07:53 <matthew-_> Cale: and if you happen to own scary SGI hardware with 65536 cores...?
10:08:15 <Cale> Then I think everyone would be interested in knowing how things work :)
10:08:23 <matthew-_> :)
10:08:29 <Cale> GHC has only been tried on up to around 80 cores.
10:08:54 <pejo> matthew, things do typically not scale to enormous machines without having been tested/profiled on them first.
10:09:15 <Cale> par isn't really how we want to do massive parallelism anyway
10:09:26 <Cale> ndp is, and that's coming out in some form in 6.10
10:10:03 <mapreduce> @go ndp haskell
10:10:05 <lambdabot> http://www.haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
10:10:05 <lambdabot> Title: GHC/Data Parallel Haskell - HaskellWiki
10:10:06 <thoughtpolice> parallel strategies work too... although yes, ndp will be chock full of goodness hopefully.
10:11:13 <mapreduce> :t par
10:11:16 <lambdabot> forall a b. a -> b -> b
10:11:48 <mapreduce> par is interesting though, I might base something I'm doing in Java on it.
10:12:20 <Cale> par and strategies work to some extent, but you're usually left guessing a bit about the right number of things to spark
10:12:50 <thoughtpolice> yeah, and if the computation isn't big enough to outweigh the spark itself then it's worthless
10:13:23 <thoughtpolice> has anybody tested parallel strategies under lots of cores/high load anyway? i've never really seen benchmarks
10:13:31 <mapreduce> I have to implement something like a filter graph (yahoo pipes, directshow, OS X's automater, etc. are examples), and a filter might send data to the next in the chain synchronously or asynchronously, and might even change that based on incoming data.
10:13:45 <mapreduce> So I'm trying to leave the synchronicity as open-ended as I can.
10:14:11 <monochrom> <3
10:14:28 <mapreduce> I'm currently basing it on actors, but other ideas are welcome.
10:14:38 <roconnor> sounds like reactive programming
10:14:38 <bwr> is there a guide somewhere to using par and parMap?
10:14:45 <bwr> i don't get the Strategy part
10:14:53 <matthew-_> mapreduce: have you looked at the x10 clocks and the habanero phases stuff?
10:14:59 <Cale> bwr: there's a nice paper called Algorithm + Strategy = Parallelism
10:15:04 <bwr> Cale: thanks
10:15:27 <matthew-_> mapreduce: also, scala has a good actors implementation and now has join-calc/chords
10:15:30 <Cale> I think it's linked from the ghc documentation... yeah
10:15:48 <mapreduce> Scala's actors implementation has untyped messages.
10:15:50 <Cale> http://www.macs.hw.ac.uk/~dsg/gph/papers/abstracts/strategies.html
10:15:52 <lambdabot> Title: Algorithm + Strategy = Parallelism, http://tinyurl.com/22srxl
10:15:52 <thoughtpolice> bwr: the paper is really good and approachable, i blogged about the approach a while back too if you're interested
10:15:57 <bwr> yea, i found the ps version
10:16:07 <bwr> thoughtpolice: sure
10:16:27 <matthew-_> mapreduce: my apologies, I'd forgotten we'd chatted about this the other day :)
10:16:28 <thoughtpolice> bwr: http://empitsu-kami.livejournal.com/841.html
10:16:33 <mapreduce> matthew-_: heh
10:16:48 <bwr> thoughtpolice: thanks
10:16:58 <mapreduce> matthew-_: I can't find anything on habanero phases, any more keywords?
10:17:18 <olsner> habanero phases?
10:17:38 <mapreduce> <matthew-_> mapreduce: have you looked at the x10 clocks and the habanero phases stuff?
10:18:10 <matthew-_> mapreduce: I meant phasers, sorry
10:18:37 <mapreduce> And ditto for x10 clocks :)
10:19:58 <olsner> sounds like this is what matthew referred to: "X10 clocks: Motivation. Activity coordination using finish and force() is accomplished by checking for activity termination"
10:20:52 <matthew-_> yeah, it's a futures construct
10:21:00 <matthew-_> out of the IBM x10 language
10:21:26 <mapreduce> Got those now, thanks.
10:21:39 * mapreduce is storing up stuff to read when offline.
10:25:08 <bwr> i have a ton of papers to read thanks to this channel
10:25:27 <bwr> i think i am going to start with this strategies paper
10:26:47 <thoughtpolice> bwr: it's good and approachable. :)
10:26:54 <mapreduce> I have that one open too.
10:28:28 <mapreduce> It's nice in my filter graph implementation that I can compose a Pipe a b and a Pipe b c and get a Pipe a c, but I dislike that I need to use side effects to set that kind of thing up.
10:29:00 <mapreduce> I think emulating par will improve that.
10:30:24 <bwr> i also have the CSP book i need to read
10:31:53 <pejo> bwr, why CSP?
10:32:28 <bwr> pejo: why not? it seems interesting
10:34:41 <mapreduce> @go csp book
10:34:42 <lambdabot> http://www.usingcsp.com/
10:34:42 <lambdabot> Title: Communicating Sequential Processes (CSP), by C. A. R. Hoare (Electronic Version)
10:34:58 <bwr> ya, that's the one
10:38:21 <mapreduce> I think I studied it in watered-down fashion in my degree.
10:38:38 <mapreduce> I understood the concepts, I think, but never bothered to learn the language properly.
10:39:54 <Winterstream> Given that one can see a arrows construction as a data-flow network, I was wondering whether it's possible to build circularties into this network. I'm wondering about this for GUI programming. How does Fudgets handle such cases? Am I misguided by trying to shoe-horn MVC into this framework?
10:40:26 <dolio> @type loop
10:40:28 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowLoop a) => a (b, d) (c, d) -> a b c
10:40:40 <Winterstream> Eck. a -> an.
10:40:43 <Winterstream> (bad English :))
10:41:28 <Winterstream> Thanks dolio. I'm looking it up. I should actually just study Fudgets properly.
10:42:23 <dolio> It's been a while since I looked at Fudgets, but that's, in general, how you construct a circular arrow.
10:42:32 <dolio> The d output is hooked into the d input.
10:43:37 <Winterstream> I've been programming in PyGTK recently and it's painful to have to deal with dataflow explicitly. I'm curious to see how well arrows will work in Python.
10:44:13 <dolio> You might want to look at Flapjax. That's an FRP-like toolkit in JavaScript.
10:44:31 <bwr> Does haskell have arbitrary precision decimals?
10:44:43 <dolio> > pi :: CReal
10:44:44 <lambdabot>  3.1415926535897932384626433832795028841972
10:44:50 <vixey> Winterstream: haskell has gtk bindings
10:44:52 <Winterstream> Yeah. It's very cool indeed. Perhaps I should just translate it to Python. I must admit that, as cool as PyCells is, it just isn't the same as Flapjax.
10:45:09 <dolio> CReal is in the numbers package on Hackage.
10:45:19 <bwr> dolio: cool, thanks
10:45:35 <dolio> I think it's fairly arbitrary precision (computable reals).
10:45:35 <Winterstream> vixey, I would convert the entire Translate Toolkit (translate.sf.net) to Haskell if I had the opportunity, but I fear that my colleagues might not be too pleased :)
10:47:33 <edward1> Gah, Knol needs LaTeX support =)
10:48:44 <Winterstream> Google's knol?
10:48:56 <gwern> lol knol
10:49:36 <edward1> got bored and decided to see what one of the foo-morphism entries would look like on there
10:49:37 <edward1> http://knol.google.com/k/edward-kmett/catamorphisms/3qi7x2qrdushx/2#
10:49:38 <lambdabot> Title: Catamorphisms - a knol by Edward Kmett, http://tinyurl.com/5jms9n
10:49:47 <Winterstream> Ha ha :). Is Knol good? I'm curious to see how it compares to Wikipedia.
10:50:40 <edward1> well it has a few things that wikipedia lacks, accountability and it is not aiming to limit itself to be an encyclopedia. on the other hand it doesn't seem to have latex support, so so far its a wash ;)
10:51:10 <gwern> why not use the haskell wiki?
10:51:10 <gwern> no afd there
10:51:58 <Cale> afd?
10:52:22 <gwern> Cale: visit WP:AFD for a cracking good time some day
10:53:07 <edward1> things become a bit questionable when you publish text to a wiki format with common editorial control and later decide you'd like to write a book on a topic =)
10:53:08 <Cale> oh, articles for deletion
10:53:30 <gwern> edward1: how so? most pages on the haskell wiki are pretty unedited
10:53:44 <edward1> the question becomes who owns the revisions, etc.
10:54:03 <Heffalump> isn't the entire wiki under a pretty permissive licence now?
10:54:13 <edward1> having been burned pretty badly in the past over intellectual property issues, i've just decided to avoid them
10:54:29 <Cale> Yeah, the wiki is all under a simple permissive license.
10:54:32 <gwern> it's pretty clear who owns the copyright...
10:54:48 <Heffalump> gwern: not after a bunch of minor revisions
10:54:50 <Cale> So permissive that copyright issues shouldn't be a problem.
10:55:06 <Heffalump> however persuading a publisher of this might be harder
10:55:13 <Heffalump> especially since they'd want you to sign over copyright
10:55:45 <gwern> Heffalump: after a bunch of revisions: each contributor owns their respective changes
10:56:12 <Heffalump> not if the revision was minor enough not to have copyright protection
10:56:22 <Heffalump> and "minor enough" is not well-defined
10:56:48 <gwern> Heffalump: de minimis is a dead letter. even a spelling change has protection
10:56:58 <centrinia> Well, "well-defined" is not well-defined.
10:57:18 <Heffalump> gwern: in which jurisdictions?
10:57:52 <gwern> US has pretty strong protections for even minor changes
10:57:58 <gwern> dictionary precedents, iirc
10:58:15 <Heffalump> perhaps, but the US is not the world :-)
10:59:30 <centrinia> Some say that the US is the world. :(
10:59:35 <gwern> the haskell wiki is hosted in the US, I'd venture many haskellers are in the US, us sets many IP standards...
11:00:13 <edward1> anyways, this discussion right here pretty much establishes why i avoid publishing to wikis when i care about the content ;)
11:10:10 <dmwit> ?seen nominolo
11:10:10 <lambdabot> nominolo is in #haskell-soc, #ghc and #haskell. I last heard nominolo speak 7h 36m 4s ago.
11:16:30 <nominolo> dmwit: yes?
11:16:56 <dmwit> Just poking you about Cairo. =P
11:17:22 <nominolo> me? Cairo?
11:17:32 <dmwit> err...
11:17:34 <nominolo> for Yi?
11:17:35 * dmwit looks at his logs
11:18:21 <dmwit> sorry
11:18:24 <dmwit> ?seen nornagon
11:18:24 <lambdabot> nornagon is in #xmonad and #haskell. I last heard nornagon speak 7h 47m 13s ago.
11:18:50 <nominolo> :) np
11:32:18 <dmwit> Oh, it looks like it's out of his control for now, anyway.
11:47:05 <ahunter2> Hey, can someone take a look at http://hpaste.org/9186 and help me eliminate some of the ugliness?
11:47:06 <unenough> hi
11:48:46 <roconnor> ahunter2: why imperative?
11:49:35 <EvilTerran> eekk
11:49:56 <vixey> why is there mutable structures?
11:50:36 <roconnor> oh
11:50:38 <roconnor> UnionFind
11:50:41 <ahunter2> roconnor: efficient implementation of union-find requires mutation?
11:50:54 * roconnor leaves this to the Union Find experts
11:51:01 <ahunter2> well, technically there's a persistent version some OCaml folk cooked up, but I don't want to bother w/ that quite yet :)
11:51:28 <vixey> I think there was an optimal union find not using mutation..
11:51:54 <dons> cool stuff, http://www.reddit.com/comments/6toia/a_typepreserving_compiler_in_haskell_dependent/
11:51:55 <lambdabot> Title: A Type-Preserving Compiler in Haskell : "dependent typing is finally available i ..., http://tinyurl.com/5bsujd
11:52:04 <ahunter2> vixey: yeah, http://portal.acm.org/citation.cfm?id=1292535.1292541&coll=ACM&dl=ACM
11:52:06 <lambdabot> Title: A persistent union-find data structure, http://tinyurl.com/6n2rzu
11:52:17 <vixey> dons, so misleading.. will probably confuse people
11:52:18 <ahunter2> but...not quite the same thing, and I'm interested in having a (probably faster!) ST implementation
11:52:36 <vixey> dons, It's a really cool paper, shame the code is not available in .hs files
11:52:52 <ahunter2> I'm mostly interested in figuring out how to clean up the kind of messy uses of case and so on, that feels wrong
11:53:09 <vixey> ahunter2: I was thinking about the CHR one
11:53:28 <roconnor> ``
11:53:28 <roconnor> This allows type-based program verification and is
11:53:28 <roconnor> a promising compromise between plain old types and full blown
11:53:28 <roconnor> Hoare logic proofs.
11:53:34 <roconnor> Horray!
11:54:02 <ahunter2> vixey: ic, hadn't heard of that...
11:54:14 <roconnor> ahunter2: I get rid of almost all case statements by using helper functions in where clauses
11:54:26 <dons> vixey: i guess you can copy and paste the code from the html.
11:54:27 <roconnor> ahunter2: lately I've been trying to use pattern guards more as well
11:54:36 <dons> data Exp where
11:54:37 <dons> Cst :: Int -> Exp
11:54:37 <dons> App :: Exp -> Exp -> Exp
11:54:37 <vixey> dons, yeah it's not the whole thing though
11:54:41 <roconnor> but I'm not sure if they will help you here.
11:55:09 <ahunter2> roconnor: yeah, I'm unsure how to fix that here
11:55:34 <roconnor> helper functions in where clauses should work
11:55:43 <roconnor> They can even do what pattern guards do.
11:56:34 <sal23> any known issues with cabal install of lambdabot of mac OS 10.5 ? I am getting some errors with execution of ghc-asm failing during compilation of Plugin/Pl/Common.hs
11:56:49 <sal23> ghc-6.8.3: could not execute: /Library/Frameworks/GHC.framework/Versions/608/usr/lib/ghc-6.8.3/ghc-asm
11:57:17 <osfameron> gwern: yay! i don't usually sit that side of the head hurter/hurtee divide, at least not as regards haskell ,)
11:59:21 <Tener> does anyone know a good/any tutorial to SYB written in easier style than original papers?
11:59:24 <dons> anyone got a copy of "Transactional events"
11:59:31 <gwern> osfameron: have you thought of how to define not just words/lines but the variant splits using it?
11:59:44 <dons> "Fluet and Donnelly (2006) designed and implemented TE as a Haskell library"
11:59:57 <gwern> osfameron: I'm currently sticking your code into a module for my split repo, and it looks hard to use
12:00:26 <osfameron> gwern: i pretty much only got as far as what i blogged
12:01:17 <osfameron> if it's hard-to-use/inflexible, then it failed its spec...
12:01:48 <gwern> it looks flexible, but all the deeply nested stuff and HOFs and maybes make it a bit hard to follow
12:02:03 <dons> looks interesting, http://www.icfpconference.org/icfp2008/accepted/74.html
12:02:04 <lambdabot> Title: ICFP 2008 - Flask: Have Your Curry and Eat It Too
12:02:11 <dons> Flask, a domain specific language embedded in Haskell that brings the power of functional programming to sensor networks
12:03:24 <gwern> flask... I thought that was a security framework
12:03:50 <osfameron> gwern: yeah, i dunno if the approach is the sanest. of course it made sense to me at the time...
12:03:53 <dons> nice, http://www.icfpconference.org/icfp2008/accepted/27.html
12:03:53 <lambdabot> Title: ICFP 2008 - Experience Report: A Pure Shirt Fits Reflections on Haskell at Blues ...
12:03:59 <dons> "Based on Bluespec's experience, we conclude that pure programming languages can be the source of a competitive advantage for startup software companies."
12:04:14 <ddarius> dons: There are a few purely functional approaches to programming sensor networks.
12:04:39 <ddarius> Also, the abstract vaguely reminds me of Virgil.
12:04:40 <dons> there's lots of great new code in the ICFP papers this year, we need to do something to get more of it on hackage.
12:04:43 <dons>  http://www.icfpconference.org/icfp2008/accepted/accepted.html
12:04:44 <lambdabot> Title: ICFP 2008 Accepted Submissions
12:04:49 <vixey> ahunter2, oh interesting
12:04:52 <dons> e.g. where's the Transactional Events implementation.
12:04:53 <vixey> http://www.lri.fr/~filliatr/puf/index.en.html
12:04:54 <lambdabot> Title: Formalization of a persistent union-find data structure in Coq
12:05:03 <vixey> You can make Coq print out the haskell code
12:05:13 <vixey> at least I think you can ...
12:05:18 <roconnor> yep
12:05:29 <roconnor> although the resulting code will segfault in GHC
12:05:38 <vixey> it is suboptimal complexity?
12:05:50 <roconnor> well, might segfault GHC
12:05:57 * ddarius is curious what technical risks Haskell adds.
12:06:42 <dons> ddarius: i think hackage has in practice mitigated most risk. and ghc being rather robust helps a lot.
12:06:55 * dons ponders day to day use of ghc at work
12:07:20 <augustss> hi
12:07:20 <roconnor> what is technical risk?
12:07:32 <vixey> hello
12:07:44 <gwern> is it the 'bus number'?
12:07:49 <roconnor> I think the extraced code form Coq wouldn't segfault GHC if coercions were to and from GHC.Any
12:08:27 <vixey> we should compile coq code into TAL :))
12:08:40 <roconnor> @what TAL
12:08:40 <lambdabot> I know nothing about tal.
12:08:55 <osfameron> augustss: thanks, i think that scanl is what i was origingally after, then i got bogged down
12:09:35 <augustss> osfameron: sorry about the short comment.  I accidentally hit return.
12:11:15 <osfameron> augustss: ah, np. like me to delete? i didn't realise wordpress submitted comment on return
12:11:34 <augustss> No, you can leave it there
12:11:47 <osfameron> oki
12:12:58 <thetallguy> ?seen shapr
12:12:59 <lambdabot> I saw shapr leaving #haskell-blah and #haskell 20h 33m 47s ago, and .
12:17:57 <vixey> hmm..... Anomaly: uncaught exception Failure "TODO: Haskell extraction of modules not implemented yet". Please report.
12:18:13 <vixey> I guess the haskell side is not really mature yet
12:22:17 <_dolio> At least it didn't get your hopes up and then segfault like it did for roconnor. :)
12:22:35 <vixey> yeah
12:22:40 * vixey doesn't really except anything to work
12:23:06 <roconnor> I got that error too.  I removed the modules from the CoRN library
12:23:32 <vixey> is that progress? :S
12:24:01 <roconnor> I was using modules for namespacing
12:24:14 <vixey> oh so you can replace them with sections?
12:25:26 <roconnor> Well I just used ModuleNameFoo instead of ModuleName.Foo
12:39:06 <Peaker> unenough: hey!
12:39:40 <dmwit> > let isPower = all (=='0') . drop 1 . show; next n | isPower n = n * 5 `div` 2 | otherwise = n * 2 in unfoldr (Just . next) 10
12:39:46 <lambdabot>      Occurs check: cannot construct the infinite type: b = (a, b)
12:39:46 <lambdabot>       Expec...
12:39:49 <dmwit> :t unfoldr
12:39:50 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
12:39:58 <unenough> Peaker, hi!
12:40:14 <dmwit> > let isPower = all (=='0') . drop 1 . show; next n | isPower n = n * 5 `div` 2 | otherwise = n * 2 in iterate next 10
12:40:14 <Peaker> unenough: doing some Haskell?
12:40:15 <unenough> can you help in me with physics? :)
12:40:17 <lambdabot>  [10,25,50,125,250,500,1250,2500,5000,12500,25000,50000,125000,250000,500000,...
12:40:25 <dmwit> oops
12:40:30 <Peaker> unenough: I doubt :)
12:40:55 <unenough> so what's up?
12:40:55 <dmwit> > let isPower = liftM2 (&&) ((=='1') . head) (all (=='0') . drop 1) . show; next n | isPower n = n * 5 `div` 2 | otherwise = n * 2 in iterate next 10
12:40:56 <lambdabot>  [10,25,50,100,250,500,1000,2500,5000,10000,25000,50000,100000,250000,500000,...
12:41:29 <roconnor> [1,2,5,10,20,50,100..]
12:42:32 <Peaker> > take 10 $ map truncate $ scanl (*) 10 $ cycle [2.5,2,2]
12:42:33 <lambdabot>  [10,25,50,100,250,500,1000,2500,5000,10000]
12:43:15 <Peaker> unenough: not much.. IBM offered to take the "research" in so I can do full time job - but only if it can be turned into a product somehow
12:43:15 <dmwit> > concat . iterate (map (*10)) $ [10, 25, 50]
12:43:17 <lambdabot>  [10,25,50,100,250,500,1000,2500,5000,10000,25000,50000,100000,250000,500000,...
12:44:19 <Peaker> indeed simpler :)
12:44:35 <unenough> Peaker, really?! cool!
12:44:38 <unenough> when did this happen?
12:44:49 <sal23> > twice f = (\x -> (f . f) x)
12:44:50 <lambdabot>  Parse error at "=" (column 9)
12:45:26 <r3m0t> > twice f = f . f
12:45:26 <lambdabot>  Parse error at "=" (column 9)
12:45:36 <r3m0t> > let twice f = f . f in twice (*2) 100
12:45:37 <lambdabot>  400
12:45:44 <dmwit> > let twice f = \x -> (f . f) x in twice reverse "hello"
12:45:45 <lambdabot>  "hello"
12:45:52 <EvilTerran> or "twice f x = f (f x)"
12:46:02 <r3m0t> (hi EvilTerran)
12:46:03 <dmwit> > let twice = join (.) in twice reverse "hello"
12:46:04 <lambdabot>  "hello"
12:46:07 <sal23> > twice twice twice twice (+1) 0
12:46:08 <EvilTerran> hello r3m0t
12:46:08 <lambdabot>  65536
12:46:08 <johnnowak> ?pl \f x -> f (f x)
12:46:09 <lambdabot> join (.)
12:46:20 <sal23> twice (twice twice twice) (+1) 0
12:46:35 <sal23> > twice (twice twice twice) (+1) 0
12:46:39 <lambdabot>  256
12:46:40 <vixey> twice (twice twice twice) (+1) 0 = twice ((twice twice) twice) (+1) 0
12:46:40 <johnnowak> > (twice succ) 0
12:46:42 <lambdabot>  2
12:46:58 <vixey> sa123: If you write things fully parenthesised ti might help
12:47:07 <mauke> > twice f x
12:47:09 <lambdabot>  f (f x)
12:47:11 <r3m0t> EvilTerran: did I mention I'm one of 19 Haskell participants in round 2 of Code Jam? (for great justice)
12:47:21 <EvilTerran> you didn't - nice
12:48:18 <sal23> vixey: yes, but the fun is finding out how it evaluates differently for different parens
12:50:23 <vixey> sa123: evaluation order has nothing to do with it :(
12:51:01 <sal23> well, no it doesn't but the parens force different order of evaluation, and so, different results
12:51:16 <vixey> parens have nothing to do with order of evaluation
12:52:52 <mmorrow> i'd call it association
12:53:14 <sal23> then ((twice twice twice) twice) and  (twice (twice (twice (twice)))) should evaluate same but they don't
12:53:25 <vixey> sa123: look,
12:53:37 <vixey> ((twice twice twice) twice) = (((twice twice) twice) twice)
12:53:44 <vixey> (((twice twice) twice) twice)
12:53:53 <dmwit> sal23: It's not evaluation order, but application order that varies.
12:53:53 <vixey> is different to
12:53:54 <vixey> (twice (twice (twice (twice))))
12:53:57 <vixey> is the same way that,
12:54:05 <dmwit> sal23: You have the right idea, just the wrong word. =)
12:54:11 <vixey> 1 + (2 * 3)  is different to  (1 + 2) * 3
12:54:28 <sal23> dmwit: you got it  :)
12:54:29 <vixey> this is not evaluation order
12:54:41 <dmwit> But, I would argue (as long as we're being pedantic), that the application order really does affect the evaluation order, too.
12:54:44 <sal23> sorry, vixey: I meant application order
12:55:00 <vixey> ok nobody is listening to me
12:55:22 <sal23> well, I am listening :)
13:03:17 <Trinithis> twice makes me think of a comonad's duplicate function. Are functions comonads?
13:05:37 <mauke> signs point to yes
13:06:35 <mauke> hmm, or maybe not
13:06:38 <Trinithis> Oh wait, extract would give undefined unless you had something like Monoid e => Comonad ((->) e)
13:06:55 <Trinithis> then you could have: extract f = f mempty
13:07:30 <Trinithis> vs extract f = f undefined
13:08:09 <Trinithis> Guess it would work if all functions are not strict
13:08:25 <rwbarton> Yeah, Monoid e => Comonad ((->) e) seems legit
13:10:24 <Trinithis> Are you able to make instances like such that you have something like:  Comonad ((->) (e -> e))?
13:10:33 <Trinithis> Then you can have extract = join
13:11:03 <Trinithis> (extract == coreturn)
13:11:13 <vixey> why not extract = fix
13:11:24 <rwbarton> (e -> e) is a monoid (under composition), but then extract is evaluation on id
13:11:34 <Trinithis> @src fix
13:11:35 <lambdabot> fix f = let x = f x in x
13:12:30 <vixey> oh because the type is not right
13:12:52 <rwbarton> Trinithis: (e -> e) -> x /= e -> (e -> x)
13:13:26 <Trinithis> oh
13:13:41 <Trinithis> Well, then the latter then
13:24:55 <DuClare> Is there a function that tells whether a string is numeric or not?
13:25:04 <mauke> depends on your definition of "numeric"
13:25:12 <dmwit> all isDigit
13:25:19 <dcoutts> @seen dons
13:25:19 <lambdabot> dons is in #arch-haskell, #ghc, #xmonad and #haskell. I last heard dons speak 1h 18m 24s ago.
13:25:28 <dmwit> or:
13:25:39 <dmwit> :t reads
13:25:44 <lambdabot> forall a. (Read a) => String -> [(a, String)]
13:25:45 <dcoutts> dons: how's it going with the paper? can I get the latest version and get writing/editing?
13:26:08 <dmwit> > let isNumeric = null . (reads :: String -> [(Int, String)]) in isNumeric "32"
13:26:10 <lambdabot>  False
13:26:16 <dmwit> whoops, heh
13:26:19 <ddarius> not null
13:26:20 <dmwit> > let isNumeric = not . null . (reads :: String -> [(Int, String)]) in isNumeric "32"
13:26:21 <lambdabot>  True
13:26:27 <dmwit> > let isNumeric = not . null . (reads :: String -> [(Int, String)]) in isNumeric "0x32"
13:26:28 <lambdabot>  True
13:26:31 <glguy> maybeRead x = case reads x of [(y,z)] | all isSpace z -> Just y ; _ -> Nothing
13:27:08 <ddarius> > all isDigit "2345"
13:27:09 <lambdabot>  True
13:27:11 <glguy> DuClare: That's a function that is inexplicably not included in the standard libraries that might be what you are trying to do in the end
13:27:16 <chessguy> @pl \d -> a (v d - u)
13:27:16 <lambdabot> a . subtract u . v
13:27:41 <chessguy> @pl \d -> a (u - v d_
13:27:42 <lambdabot> (line 1, column 18):
13:27:42 <lambdabot> unexpected end of input
13:27:42 <lambdabot> expecting variable, "(", operator, "+", "-" or ")"
13:27:49 <chessguy> @pl \d -> a (u - v d)
13:27:49 <lambdabot> a . (-) u . v
13:27:59 <dmwit> glguy: Why convert to Maybe?
13:28:22 <dmwit> readWithSpaces x = [y | (y, z) <- reads x, all isSpace z]
13:28:53 <glguy> dmwit: because as in read, an ambiguous parse is not considered a success
13:29:15 <dmwit> hum
13:29:28 <dmwit> Okay, I can see reasons for wanting that.
13:29:38 <glguy> dmwit: and there isn't a point in mentioning the "withSpace" aspect since that is what read does anyway
13:29:43 <glguy> you'd only want to specify "without"
13:29:57 <dmwit> > read "32 " :: Int
13:29:59 <lambdabot>  32
13:30:03 <dmwit> Huh, I never knew that.
13:32:31 <r3m0t> :t reads
13:32:32 <lambdabot> forall a. (Read a) => String -> [(a, String)]
13:34:59 <r3m0t> @pl (\f -> f . f)
13:34:59 <lambdabot> join (.)
13:35:09 <ddarius> glguy: Will Int ever parse ambiguously?
13:35:42 <glguy> ddarius: not that I know of
13:36:11 <dmwit> > reads "032" :: [(Int, String)]
13:36:12 <lambdabot>  [(32,"")]
13:36:38 <r3m0t> what about an overflow?
13:36:50 <dmwit> That's wrong, but not ambiguous, I would guess.
13:37:01 <Trinithis> > reads "0o32" :: [(Int, String)]
13:37:03 <lambdabot>  [(26,"")]
13:37:06 <dmwit> > reads "123456789123456789123456789" :: [(Int,  String)]
13:37:07 <lambdabot>  [(2080661269,"")]
13:37:10 <r3m0t> yeah, you're right, it just returns the wrong thing
13:37:33 <Trinithis> > reads "0o10" :: [(Int, String)]
13:37:34 <lambdabot>  [(8,"")]
13:37:43 <Trinithis> > reads "0.1" :: [(Int, String)]
13:37:44 <lambdabot>  []
13:38:07 <dmwit> I would have expected [(0, ".1")] there.
13:38:25 <Trinithis> > reads "0 .1" :: [(Int, String)]
13:38:26 <lambdabot>  [(0," .1")]
13:38:45 <Deewiant> read isn't very useful unless you know exactly what the input looks like :-P
13:38:49 <dmwit> Oh, it's for lexing, is it?
13:38:53 <MyCatVerbs> Perhaps that's to stop Int's reads from eating strings that you actually want to be consumed by Float's reads.
13:39:02 <dmwit> yeah
13:41:24 <EvilTerran> does *anything* h98 parse ambiguously?
13:42:49 <Trinithis> > reads "undefined" :: [(String, String)]
13:42:50 <lambdabot>  []
13:43:20 <sal23> http://hpaste.org/9189 - the second fib version is faster than the first one on GHC 6.8.3... anyway to get C code from GHC? I didn't see any option in GHC documentation
13:44:34 <Trinithis> try : ghc --make Foo.hs -C
13:44:37 <Trinithis> or something
13:45:00 <vixey> can this be rewritten in do notation?
13:45:01 <vixey> test = [1,2,3]  >>- \x ->        "xyz"    >>- \y ->        (if y == 'y' then Cut else id)$        "rgb"    >>- \z -> Fruit (x,y,z)
13:45:16 <Deewiant> ?redo test = [1,2,3]  >>- \x ->        "xyz"    >>- \y ->        (if y == 'y' then Cut else id)$        "rgb"    >>- \z -> Fruit (x,y,z)
13:45:17 <lambdabot> test = [1, 2, 3] >>- \ x -> "xyz" >>- \ y -> (if y == 'y' then Cut else id) $ "rgb" >>- \ z -> Fruit (x, y, z)
13:45:28 <r3m0t> ermm... probably
13:45:29 <Deewiant> >>- ??
13:45:30 <mmorrow> > reads "\"undefined\"" :: [(String, String)]
13:45:31 <lambdabot>  [("undefined","")]
13:45:38 <Deewiant> not >>= ?
13:45:54 <Deewiant> ?redo test = [1,2,3]  >>= \x ->        "xyz"    >>= \y ->        (if y == 'y' then Cut else id)$        "rgb"    >>= \z -> Fruit (x,y,z)
13:45:54 <lambdabot> test = do { x <- [1, 2, 3]; y <- "xyz"; (if y == 'y' then Cut else id) $ do { z <- "rgb"; Fruit (x, y, z)}}
13:45:56 <Trinithis> sal23: actually I just tried it. Do: ghc Foo.hs -C
13:46:08 <Trinithis> sal23: The output is in a .hc file
13:46:30 <sal23> thx, Trinithis
13:46:56 <Trinithis> @src (>>-)
13:46:57 <lambdabot> Source not found. Where did you learn to type?
13:47:25 <jpcooper> Cale, what are your thoughts on existential types?
13:47:44 <jpcooper> I mean, by using them, would I be going against the general idea of haskell and functional programming?
13:48:15 <r3m0t> Trinithis: and a .hi file...?
13:48:43 <Trinithis> haskell interface file
13:48:46 <Trinithis> its for the compiler
13:49:02 <ddarius> jpcooper: Not in general.
13:49:05 <Cale> jpcooper: No, though I haven't had much use for them personally.
13:49:22 <Cale> jpcooper: They're just the thing for very specific kinds of problems.
13:49:25 <Trinithis> existential types the forall stuff?
13:49:31 <jpcooper> ddarius, was such a thing proposed on the standardisation of Haskell98?
13:49:37 <Cale> Trinithis: some of the forall stuff, yes
13:49:39 <vixey> test' = do x <- fromList [1,2,3]            y <- fromList "xyz"            (if y == 'y' then Cut else id)              (do z <- fromList . words $ "red green blue"                  return (x,y,z))
13:49:48 <vixey> can that be done with a single do block?
13:50:03 <Deewiant> probably not
13:50:06 <dons> jpcooper: aren't they the very essence of functional programming?
13:50:07 <nornagon> dmwit: heya
13:50:12 <jpcooper> I don't know
13:50:17 <dons> type-based precise compile time guarantees of behaviour.
13:50:31 <jpcooper> if I show some code, could you tell me if there's a better way to do what's being done, without anything non-standard?
13:50:31 <ddarius> jpcooper: There is nothing "unfunctional" about existential types.
13:50:48 <dons> what standard are you applying, btw, jpcooper ?
13:50:49 <Cale> Actually, in a sense, existential types are the essense of object oriented programming.
13:50:58 <dons> haskell' based?
13:51:11 <dons> (that's what we work in a galois, fwiw).
13:51:11 <jpcooper> dons, I just want to programme in the way that I'm meant to
13:51:15 <ddarius> Cale: I wouldn't say that.  Existential types are the essence of abstract data types.
13:51:17 <Cale> That is, ignoring the stuff about state :)
13:51:17 <chrisdone> http://hpaste.org/9190
13:51:23 <jpcooper> and don't have enough experience in functional programming to know the best way to do things
13:51:28 <dons> ah ok :)
13:51:31 <dons> i'm sure we can help.
13:51:31 <ddarius> Cale: And inheritance and method update and ...
13:51:51 <jpcooper> Cale, could you have a look at the ObjectCons data type in http://hpaste.org/9190, please?
13:52:16 <Cale> ddarius: yeah, all that stuff is inessential -- objects are things which you know that you can do a bunch of stuff with them, but you don't have any information about their internal structure
13:52:34 <ddarius> Cale: That's an abstract data type.
13:53:04 <Cale> sure
13:53:04 <chrisdone> a value is just an immutible object? and haskell is value oriented programming? :P
13:53:34 <jpcooper> also, why isn't it possible to have the (Show a) bit only in the definition of the Constructor datatype?
13:54:26 <Cale> jpcooper: It's a bit strange that the (Show a) bit is allowed in the type synonym at all :)
13:54:36 <jpcooper> oh?
13:54:41 <chrisdone> oh, good point
13:54:51 <jpcooper> I don't follow
13:54:58 <Cale> I'm pretty sure that's a GHC extension
13:55:04 <jpcooper> does that only work because we have the Glasgow extensions on?
13:55:48 <Cale> Yeah, in Haskell 98, class contexts aren't allowed in type synonym declarations.
13:55:54 <jpcooper> okay
13:56:08 <Cale> I'm a little confused about what that context even means, but I can make a reasonable guess.
13:56:31 <jpcooper> it means that it must output something which the server returns to the user's browser
13:56:51 <jpcooper> would you propose a different way to think about this ObjectCons type?
13:56:56 <chrisdone> the Show instance outputs some HTML
13:56:59 <Cale> (I would guess that when the type synonym is expanded, Show a is added to the class context of the type in which it's being expanded)
13:57:27 <Cale> So let me see what the deal is with this existential...
13:57:52 <ddarius> :t undefined :: (Read a) => ((Show a) => a -> Int) -> Int
13:57:53 <lambdabot> forall a. (Read a) => ((Show a) => a -> Int) -> Int
13:58:01 <Cale> If all you know about the type a is that it's possible to apply show to elements of that type, then why not just use String?
13:58:27 <Cale> That is,  type Constructor = [String] -> String
13:58:48 <Cale> and  data ObjectCons = ObjectCons {objectName :: String, constructor :: Constructor, arity :: Int}
13:59:01 <jpcooper> constructor returns an object
13:59:22 <Cale> Which at present, all you're allowed to do with that object is apply show
13:59:30 <Cale> which makes it into a string
13:59:45 <jpcooper> I mean, a Constructor is a function which takes a list of strings, and returns an object
13:59:53 <jpcooper> yes, I see
14:00:22 <Cale> Like, you can have...
14:00:24 <chrisdone> well, this is the setup I had before. Constructor was :: [String] -> String
14:00:41 <jpcooper> actually yeah, I don't see why I didn't see this before
14:00:50 <jpcooper> sorry chrisdone
14:01:12 <chrisdone> well I thought there might be other stuff you wanted to do with the object that required it to be so
14:01:21 <jpcooper> yeah
14:01:32 <jpcooper> one might want to post to the object
14:01:49 <jpcooper> as in change the object's representation in some kind of database
14:02:08 <Cale> Existentials are really only useful when the interface to the functionality you want is a bit too clunky to just specialise for your particular data and carry around explicitly.
14:02:22 <r3m0t> > let l :: [Bool] -> Int; l [] = 0; l (x:xs) = 1 + l xs in l [True, False]
14:02:23 <lambdabot>  2
14:02:31 <r3m0t> > let l :: [forall a. a] -> Int; l [] = 0; l (x:xs) = 1 + l xs in l [True, 3]
14:02:32 <lambdabot>  Parse error at "." (column 19)
14:03:24 <jpcooper> Cale, so say we actually do need a function which returns an object?
14:03:42 <jpcooper> we just need some way to get an object from string arguments
14:04:14 <chrisdone> it kinda just sounds like a closure waiting to be applied?
14:04:14 <jpcooper> and all of these constructors would need to be stored in one list
14:04:22 <Cale> Well, what are you allowed to do with the object?
14:04:33 <Cale> (apart from show it?)
14:04:41 <jpcooper> to output it, and to change its properties
14:05:23 <Cale> Properties?
14:05:35 <jpcooper> I don't know what the term is
14:05:38 <Cale> What does that look like?
14:05:47 <Cale> (what's the interface to that functionality)
14:05:49 <jpcooper> say we have Coordinate x y
14:05:55 <jpcooper> then x and y are its properties
14:06:00 <ddarius> chrisdone: Closures are typically represented by existential types.
14:06:24 <dons> ?go closures have existential type
14:06:25 <lambdabot> http://theory.stanford.edu/people/jcm/papers/mitch-plotkin-88.pdf
14:06:25 <lambdabot> Title: Abstract Types Have Existential Type
14:06:32 <jpcooper> or, that's what I meant by properties
14:07:09 <Cale> jpcooper: yeah, but you aren't going to know what type of thing this object is... you're just going to have some function you'll be able to apply to it...
14:07:22 <Cale> Maybe something like  String -> String -> a -> a ?
14:07:44 <ddarius> apply :: (exists env.(env, (env,a) -> b)) -> a -> b
14:07:45 <jpcooper> yes
14:07:57 <jpcooper> which would return an updated version
14:08:00 <Cale> yeah
14:08:23 <jpcooper> I think it would be better to have a list of strings to accommodate for different object types
14:08:26 <Cale> Okay, so maybe instead of the existential type, what you really want is  Map String String :)
14:08:33 <jpcooper> but then, it obviously wouldn't be possible to store those in on list
14:08:55 <jpcooper> hmm
14:09:00 <jpcooper> what would that be for?
14:09:09 <Cale> A mapping from keys to values.
14:09:34 <jpcooper> would a key be comma-separated or something?
14:09:42 <Cale> hm?
14:09:56 <Cale> Like, the names of your properties to their values.
14:09:58 <jpcooper> I'm just trying to understand how this map would apply to updating a stored object
14:10:04 <jpcooper> aah of course
14:10:29 <jpcooper> excellent
14:10:37 <ddarius> Map String String is just a different representation for String -> String
14:10:46 <jpcooper> yes
14:10:47 <ddarius> With some perks.
14:10:56 <dons> functions with benefits.
14:11:16 <chrisdone> then how do you show this object?
14:11:31 <Cale> chrisdone: well, Map String String already has a beautiful show instance
14:11:32 <jpcooper> map over the keys and values?
14:11:39 <jpcooper> oh
14:11:39 <gnut> is there a way to extract a subarray from an STUArray from indices i to j (i,j) ?
14:11:41 <SamB_XP_> chrisdone: well, it's a bit more than a function
14:11:43 <Cale> But yeah, you can do lots of nice things.
14:11:48 <SamB_XP_> (or possibly less?)
14:12:17 <chrisdone> > let obj = (\f -> f "map" "show") in (obj const,obj (flip const))
14:12:18 <lambdabot>  ("map","show")
14:12:23 <chrisdone> like that?
14:13:27 <chrisdone> cale: I think the idea is we show the object and it outputs HTML, or maybe not..
14:13:47 <Cale> > M.fromList [("greeting","hello"), ("day", "Sunday")]
14:13:48 <lambdabot>  fromList [("day","Sunday"),("greeting","hello")]
14:14:14 <paczesiowa> dons: I see that you did couple more csv parsers since last week, just out of curiosity - how much faster than python did you get?
14:14:20 <Cale> of course, if you want to convert that to XML or HTML or what-have-you, that's not so hard
14:15:00 <chrisdone> it would have to be dependant on the type of the ‚Äúobject‚Äù
14:15:28 <wjt> [OT] is it urlcatcher which keeps shoving logbots into this channel under different anonymous nicks?
14:15:46 <chrisdone> maybe just a tuple of the map and a function that knows how to show the map
14:17:10 <jpcooper> chrisdone, string -> string?
14:17:14 <jpcooper> no
14:17:21 <jpcooper> [string] -> string
14:17:26 <chrisdone> Map .. .. -> String
14:17:29 <jpcooper> yeah sorry
14:20:57 * gwern waits impatiently for Hint to be released today
14:22:24 <chrisdone> if you're using forkIO with runFastCGIConcurrent', is making HDBC.Sqlite3 calls inside them going to be thread safe?
14:22:31 <Cale> Having nice implementation-independent interfaces to functionality is nice, but when the interface you choose has a small number of sane implementations, it might be a good idea to just pick one :)
14:22:44 <chrisdone> or should an MVar be used to lock the database when in use?
14:23:12 <Cale> (especially if in your application, the differences between the possible implementations won't end up mattering)
14:23:12 <dcoutts> @seen dons
14:23:13 <lambdabot> dons is in #arch-haskell, #ghc, #xmonad and #haskell. I last heard dons speak 12m 16s ago.
14:23:31 <chrisdone> cale: yeah
14:24:14 <vixey> finally got my Prolog interpreter to work
14:24:59 <chrisdone> is there a definite advantage to (runFastCGIConcurrent' forkIO) over using one single thread? I imagine when one thread is waiting for a resource or IO, like sqlite3 or a file or something, the other threads can continue?
14:25:02 <dons> dcoutts: yo
14:29:25 <dcoutts> dons: so do we have a current state of the demo paper?
14:29:31 <chrisdone> mmk
14:29:37 <dcoutts> dons: did you get the initial outline I sent?
14:29:52 <dons> yep, moving it into .tex now
14:30:33 <dons> would help if i could find my demo .tex from last year.
14:31:22 <gwern> dcoutts: demo? what are you demoing?
14:31:36 <dcoutts> dons: great, anything I can darcs pull?
14:31:50 <dons> gimme a few minutes.
14:31:54 <dcoutts> gwern: we're going to demo some hackage stuff at the Haskell Symposium
14:31:55 <dcoutts> dons: np
14:32:17 <dons> dcoutts: what are your availabiities till this time tomorrow?
14:32:25 <dcoutts> dons: fully available
14:32:29 <dcoutts> gwern: and talk about ideas / proposal for the platform
14:32:36 <dons> ok. these shouldn't take more than an hour or two.
14:32:43 <dcoutts> @arr
14:32:43 <lambdabot> Aye
14:33:17 <gwern> dcoutts: oh, like dons's Haskell Platform thingie?
14:33:23 <gwern> and the make stuff?
14:33:34 <gwern> actually, how is the make stuff going? I don't remember any blogging
14:33:51 <dons> yeah, "my" Haskell Platform thingie :)
14:34:04 <dcoutts> gwern: help me to pester Saizan_ to blog about that more
14:34:21 <dcoutts> gwern: but no we'll not be talking about that really
14:34:35 <dcoutts> the platform and supporting infrastructure
14:34:52 <dcoutts> since we need buy-in from the community to make the platform work
14:34:57 <dcoutts> both users and maintainers
14:35:16 * dcoutts wants to do a live demo of the hackage-server during the talk
14:35:26 <gwern> dcoutts: heh. I'll just ask him next time I see him talking here 'Saizan_ what are you doing chatting here, you should be blogging about make. Saizan_ we really need make to speed up big cabal packages. Saizan_  Saizan_ Saizan_ how's progress?'
14:35:32 <dons> demos are good if they involve demonstrations.
14:35:33 <dcoutts> let people connect from their laptops during the talk
14:35:43 <dcoutts> dons: right :-)
14:35:44 <dafra> gwern: what's Hint ?
14:36:13 <dcoutts> gwern: yes, I think that'd help :-)
14:37:39 <gwern> dafra: the GHC API wrapper I depend on for mueval; I'm waiting on it to do a release and ANN
14:38:21 <dafra> gwern: you must be pretty excited then
14:38:39 <ddarius> Why the name "mueval"?
14:38:46 <gwern> dcoutts: I dunno, what is a live demo of hackage? 'here I do runhaskel Setup sdist; here I do cabal-upload dist/package.tar.gz; here I do cabal update; here I browse the webpage; and here I download a tarball and demonstrate cabal install'
14:38:57 <gwern> ddarius: well, it's supposed to be used in a hypothetical mubot
14:39:03 <gwern> and eval is what it does
14:39:07 <gwern> hence, mueval
14:39:15 <gwern> (also, I like it)
14:39:18 <vixey> @w80 mubot
14:39:18 <lambdabot> No match for "mubot".
14:39:51 <chessguy> @help w80
14:39:51 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:39:56 <vixey> so I gave up and don't implement cut
14:40:10 <vixey> I think it's not possibly in a monad
14:40:30 <vixey> you must use mutation with the monad approach or success/failure continuations (or any of a million other approaches)
14:40:37 <dcoutts> gwern: using the new server implementation, hosted on a laptop at the conference
14:40:39 <gwern> (mubot does not yet exist. I reasoned I'd better write the libraries and utilities first)
14:41:08 <dafra> gwern; the GHC API must be Haskell, why wrap them into something else
14:41:17 <gwern> dcoutts: I don't entirely understand, but I suppose that's why one goes to conferences
14:41:24 <ddarius> cut is evil anyway
14:41:50 <vixey> evil or not, I'm annoyed I couldn't get it to work
14:41:54 <dcoutts> gwern: hopefully there will also be some new hackage-server features by that time to demo, eg build reporting etc
14:41:55 <gwern> dafra: because the GHC API is pretty nasty, low-level, arbitrary, broken in places for mueval's purpose, and undocumented. I am deeply grateful to daniel for abstracting stuff out
14:42:02 <gwern> abstracting/layering over it
14:42:08 * vixey had no trouble with different implementations in scheme
14:43:00 <dafra> cool, Hint will help yi editor too
14:43:14 <dafra> btw, what's mueval ?
14:43:26 <yitz> after we use mubot for a while, it will get old. then we'll implement a nubot.
14:43:42 <mauke> .oO( rhobot )
14:44:09 <dafra> lol
14:44:14 <gwern> dafra: you know how lambdabot can safely evaluate expressions? mueval is a standalone program to do that
14:44:23 <ddarius> vixey: Of course it's possible.
14:44:36 <vixey> I don't believe you :p
14:44:40 <vixey> I spent 2 days trying
14:44:59 <vixey> if you give me a constructive proof i'll be happy
14:46:20 <ddarius> vixey: You could just store the state or the success/failure continuations in the monad
14:50:57 <chrisdone> I'm trying to load FastCGI.hsc but I get: <no location info>: module `Network.CGI' is a package module
14:51:03 <chrisdone> is it not possible to load .hsc files?
14:51:22 <chrisdone> or is it defaulting to the global package, I guess it is
14:51:38 <chrisdone> um
14:55:15 <paczesiowa> what's zipWith called in lisp?
14:55:25 <vixey> map
14:55:54 <mauke> mapcar
14:57:25 <paczesiowa> mauke: thanks
14:57:45 <dmhouse> Depends which lisp ;)
15:00:10 <Saizan_> chrisdone: ghci can't load .hsc files directly, they are preprocessed by hsc2hs, it's easier to just install the package though
15:13:16 <funktio> @pl \xs -> listArray (0, length xs - 1) xs
15:13:16 <lambdabot> listArray =<< (,) 0 . subtract 1 . length
15:14:17 <ddarius> How can you beat such clarity?
15:14:28 <mauke> WITH A STICK
15:14:52 <dmhouse> You're right. It's too easy to read. Let's insert random flips and spurious consts in there for fun.
15:15:44 <mmorrow> wow, i'm using that liner always from now on
15:17:51 <mmorrow> one of my "favorites" was:
15:17:57 <mmorrow> @pl zipWith (\(t,vs) (t',vs') -> ((t,t'),(vs\\vs',vs'\\vs)))
15:17:57 <lambdabot> (line 1, column 37):
15:17:57 <lambdabot> unexpected ","
15:17:57 <lambdabot> expecting variable, "(", operator or ")"
15:18:21 <mmorrow> @pl \t t' -> zipWith (\(t,vs) (t',vs') -> ((t,t'),(vs\\vs',vs'\\vs)))
15:18:21 <lambdabot> (line 1, column 46):
15:18:21 <lambdabot> unexpected ","
15:18:21 <lambdabot> expecting variable, "(", operator or ")"
15:18:26 <mmorrow> crap
15:18:37 <mmorrow> oh
15:19:02 <ddarius> Try without 's maybe?
15:19:07 <mmorrow> @pl \t t' -> zipWith (\(t,vs) (t',vs') -> ((t,t'),(vs + vs',vs' + vs)))
15:19:08 <lambdabot> const (const (zipWith ((. snd) . ap (ap . ((,) .) . (,)) (ap (ap . ((,) .) . (+)) (+)) . snd)))
15:19:21 <mmorrow> i remember having that problem too
15:19:36 <mmorrow> for some reason the \\s dont sit well
15:19:46 <ddarius> @pl xs \\\\ ys
15:19:46 <lambdabot> (line 1, column 4):
15:19:46 <lambdabot> unexpected "\\"
15:19:46 <lambdabot> expecting variable, "(", operator or end of input
15:20:44 <mmorrow> @pl xs \\\ ys
15:20:44 <lambdabot> (line 1, column 4):
15:20:44 <lambdabot> unexpected "\\"
15:20:44 <lambdabot> expecting variable, "(", operator or end of input
15:20:52 <dmhouse> const (const (zipWith ((. snd) . ap (ap . ((,) .) . (,)) (ap (ap . ((,) .) . (+)) (+)) . snd))) [1..10] [1..10]
15:20:55 <dmhouse> > const (const (zipWith ((. snd) . ap (ap . ((,) .) . (,)) (ap (ap . ((,) .) . (+)) (+)) . snd))) [1..10] [1..10]
15:20:56 <lambdabot>  Add a type signature
15:21:00 <mmorrow> haha
15:21:02 <r3m0t> @pl (\\\) xs ys
15:21:02 <lambdabot> (line 1, column 3):
15:21:02 <lambdabot> unexpected "\\"
15:21:02 <lambdabot> expecting pattern
15:21:13 <dmhouse> > const (const (zipWith ((. snd) . ap (ap . ((,) .) . (,)) (ap (ap . ((,) .) . (+)) (+)) . snd))) [1..10::Int] [1..10::Int]
15:21:14 <lambdabot>  Add a type signature
15:21:19 <dmhouse> Pfft.
15:21:21 <yitz> mmorrow: that suggests the following puzzle: find a string s such that @pl s == @unlambda s
15:21:32 <mmorrow> oh dear
15:21:36 <dmhouse> Right, bedtime.
15:21:49 <mmorrow> dmhouse: i thikn it has to do with the 'ap's
15:21:54 <funktio> what does @unlambda do?
15:22:08 <yitz> @go unlambda
15:22:08 <ddarius> @google unlambda
15:22:09 <mmorrow> i've never tried unlambda actually...
15:22:10 <lambdabot> http://www.madore.org/~david/programs/unlambda/
15:22:10 <lambdabot> Title: The Unlambda Programming Language
15:22:10 <lambdabot> http://www.madore.org/~david/programs/unlambda/
15:22:10 <lambdabot> Title: The Unlambda Programming Language
15:22:20 <mmorrow> @unlambda \x -> x
15:22:21 <lambdabot>  fd:29: hClose: resource vanished (Broken pipe)
15:22:26 <mmorrow> aw
15:22:32 <mmorrow> @pl \x -> x
15:22:32 <lambdabot> id
15:22:36 <mmorrow> phew
15:22:37 <funktio> yeah, I know the language
15:22:41 <yitz> @unlambda .a
15:22:41 <lambdabot>  fd:29: hClose: resource vanished (Broken pipe)
15:22:52 <yitz> @unlambda k
15:22:52 <lambdabot>  fd:29: hClose: resource vanished (Broken pipe)
15:23:00 <yitz> broken. too bad.
15:23:01 <osfameron> it's the functional equivalent of intercal isn't it?
15:23:18 <mmorrow> does @unlambda take a haskell expression and translate it to unlambda? or interpret unlambda exps?
15:23:28 <yitz> mmorrow: the latter
15:23:33 <mmorrow> cool
15:23:38 <ddarius> It's a mostly functional esoteric language but other than that it isn't at all like a "functional" intercal.
15:25:02 <mmorrow> sounds like (unlambda<->brainfuck)<->(haskell<->c)
15:25:24 <roconnor> <-> is associative
15:25:25 <mmorrow> or s/c/asm/ i guess might be better (but still crappy)
15:25:37 <roconnor> if and only if
15:25:43 <funktio> there's also Lazy K
15:26:06 <mmorrow> roconnor: the middle '<->' is supposed to be comparing the two inner '<->'s (i just used the same symbol out of lazyness)
15:26:07 <roconnor> @check \x y z -> ((x==y)==z) == (x==(y==z))
15:26:10 <lambdabot>  OK, passed 500 tests.
15:26:11 <funktio> http://homepages.cwi.nl/~tromp/cl/lazy-k.html
15:26:12 <lambdabot> Title: The Lazy K Programming Language
15:26:32 <mmorrow> like "unlambda is to brainfuck what haskell is to C"
15:26:36 <dmwit> roconnor:
15:26:40 <dmwit> ?check \x y -> x == y
15:26:41 <lambdabot>  OK, passed 500 tests.
15:26:59 <osfameron> is unlambda the "SKI calculus" ?
15:27:35 <olsner> SKI+in/output+call/cc iirc
15:29:21 <ddarius> mmorrow: A:B::C:D
15:29:43 <mauke> AÔºöB‚à∑CÔºöD
15:33:38 <mmorrow> ah, compact and straightforward
15:34:54 <roconnor> dmwit:
15:35:06 <roconnor> ?check \x y z -> (x == y) == z
15:35:08 <lambdabot>  Falsifiable, after 2 tests: (), (), False
15:35:26 <dmwit> Yeah, I noticed that a few seconds after writing.
15:35:34 <dmwit> dmwit--
15:35:38 <roconnor> :)
15:35:41 <roconnor> it's okay
15:36:01 <mmorrow> hehe
15:36:04 <mauke> @check (==)
15:36:05 <lambdabot>  OK, passed 500 tests.
15:36:09 <mmorrow> sweet!
15:36:19 <mmorrow> that was a nailbiter
15:36:27 <dmwit> ?check ((==) .) . (==)
15:36:28 <lambdabot>  Falsifiable, after 0 tests: (), (), False
15:38:52 <dmwit> > 32767 - (-32768)
15:38:54 <lambdabot>  65535
15:42:05 <mauke> nice problem: http://www.spoj.pl/problems/CERC07L/
15:42:08 <lambdabot> Title: Sphere Online Judge (SPOJ) - Problem CERC07L
15:43:16 <yitz> @pl \x y z -> ((x==y)==z) == (x==(y==z))
15:43:16 <lambdabot> ap (ap . ((ap . ((==) .) . (==)) .) . (==)) ((. (==)) . (.) . (==))
15:43:47 <yitz> @check ap (ap . ((ap . ((==) .) . (==)) .) . (==)) ((. (==)) . (.) . (==))
15:43:48 <lambdabot>  OK, passed 500 tests.
15:44:26 <ddarius> @check (==) :: Int -> Int -> Bool
15:44:27 <lambdabot>  Falsifiable, after 0 tests: -1, 1
15:44:44 <dmwit> ?check ap (==) reverse
15:44:45 <lambdabot>  OK, passed 500 tests.
15:45:03 <vixey> > map (\(x,y,z) -> ((x==y)==z) == (x==(y==z))) [(True,True,True),(True,True,False),(True,False,True),(True,False,False),(False,True,True),(False,True,False),(False,False,True),(False,False,False)]
15:45:05 <lambdabot>  [True,True,True,True,True,True,True,True]
15:45:12 <EvilTerran> ?pl \(x,(y,z)) -> ((x,y),z)
15:45:13 <lambdabot> uncurry ((`ap` snd) . (. fst) . ((,) .) . (,))
15:45:21 <vixey> \x y z -> ((x==y)==z) == (x==(y==z))
15:45:21 <vixey> =
15:45:25 <roconnor> @pl (\f -> ap (ap . ((ap . (f .) . f) .) . f) ((. f) . (.) . f)
15:45:25 <lambdabot> (line 1, column 60):
15:45:25 <lambdabot> unexpected end of input
15:45:25 <lambdabot> expecting variable, "(", operator or ")"
15:45:26 <vixey> \x y z -> True
15:45:27 <EvilTerran> ?pl \((x,y),z) -> (x,(y,z))
15:45:27 <lambdabot> uncurry (uncurry ((. (,)) . (.) . (,)))
15:45:40 <roconnor> @pl (\f -> ap (ap . ((ap . (f .) . f) .) . f) ((. f) . (.) . f))
15:45:40 <lambdabot> ap (ap . (ap .) . ((.) =<< (.) . (ap .) . ((.) =<< (.)))) (ap ((.) . flip (.)) ((.) .))
15:45:45 <ddarius> @scheck \x y z -> ((x==y)==z) == (x==(y==z))
15:45:46 <lambdabot>     Failed to load interface for `SmallCheck':
15:45:46 <lambdabot>       Use -v to see a list of ...
15:45:56 <roconnor> @check ap (ap . (ap .) . ((.) =<< (.) . (ap .) . ((.) =<< (.)))) (ap ((.) . flip (.)) ((.) .)) (==)
15:45:56 <EvilTerran> ?type (fst.fst &&& first snd)
15:45:57 <lambdabot>  OK, passed 500 tests.
15:45:58 <lambdabot> forall a b b1. ((a, b), b1) -> (a, (b, b1))
15:46:13 <roconnor> @unpl ap (ap . (ap .) . ((.) =<< (.) . (ap .) . ((.) =<< (.)))) (ap ((.) . flip (.)) ((.) .)) (==)
15:46:13 <lambdabot> ((\ aj ao -> (\ bx ay -> (((\ e f g -> e (f g)) >>= \ b c d -> b (c d)) (\ cd bk -> (((\ l m n -> l (m n)) >>= \ i j k -> i (j k)) aj cd) >>= \ bh -> bk >>= \ bg -> return (bh bg)) bx) >>= \ av ->
15:46:13 <lambdabot> ay >>= \ au -> return (av au)) >>= \ al -> ao >>= \ ak -> return (al ak)) >>= \ ac -> ((\ bu p q w -> p q (bu w)) >>= \ bn -> (\ aa cj y z -> aa cj (y z)) >>= \ bm -> return (bn bm)) >>= \ ab ->
15:46:13 <lambdabot> return (ac ab)) (==)
15:46:18 <O_4> Good lord
15:46:19 <EvilTerran> ?type (second fst &&& snd.snd)
15:46:20 <lambdabot> forall a b d. (d, (a, b)) -> ((d, a), b)
15:46:24 <EvilTerran> that's better
15:46:25 <O_4> What's all this, then :-p
15:46:33 <Trinithis> does lines work with various end of line formats?
15:46:47 <roconnor> @check ((\ aj ao -> (\ bx ay -> (((\ e f g -> e (f g)) >>= \ b c d -> b (c d)) (\ cd bk -> (((\ l m n -> l (m n)) >>= \ i j k -> i (j k)) aj cd) >>= \ bh -> bk >>= \ bg -> return (bh bg)) bx) >>= \ av ->ay >>= \ au -> return (av au)) >>= \ al -> ao >>= \ ak -> return (al ak)) >>= \ ac -> ((\ bu p q w -> p q (bu w)) >>= \ bn -> (\ aa cj y z -> aa cj (y z)) >>= \ bm -> return (bn bm)) >>= \ ab ->return (ac ab)) (==)
15:46:48 <lambdabot>      Occurs check: cannot construct the infinite type: b = a -> b     Probabl...
15:47:07 <Trinithis> > lines "a\r\nb"
15:47:08 <lambdabot>  ["a\r","b"]
15:47:11 <Trinithis> dang
15:47:58 <vixey> is that a bug in @pl ?
15:48:00 <vixey> or @unpl
15:48:02 <yitz> Trinithis: on windows, CR LF gets read in to Haskell as \n (I think)
15:48:38 <Trinithis> Well, it would be easy to handcraft a lines' function anyway
15:48:38 <roconnor> at least it should for handles in text mode
15:48:46 <dmwit> mauke: A parsing problem for which naive use of Parsec may be ill-suited?  Unthinkable!
15:49:47 <dmwit> I think I see a clever way to do this, though...
15:49:54 <ddarius> dmead: 2D parser combinators ho!
15:50:22 <mauke> dmwit: heh. my solution didn't use a parser
15:50:53 <dmwit> Yeah, well, your solution doesn't count, because it's in Perl.
15:51:01 <mauke> no, C
15:51:06 <yitz> there is openBinaryFile etc. for non-text files.
15:51:35 <roconnor> ddarius: parse combinators written in 2D, the language for discriminating hackers?
15:52:35 <mauke> I suppose I could do it the same way in Haskell, but it's full of arrays
15:54:23 <ddarius> You could find the sources and then "concurrently" march along the wires and pass through the gates.
15:55:00 <ddarius> There aren't any feedback loops in any of the examples I imagine.
15:55:17 <Saizan_> the spec says so
15:55:27 <yitz> @type ap (ap . (ap .) . ((.) =<< (.) . (ap .) . ((.) =<< (.)))) (ap ((.) . flip (.)) ((.) .))
15:55:28 <lambdabot> forall a. (a -> a -> a) -> a -> a -> a -> a
15:55:45 <ddarius> Saizan_: Indeed it does.
15:55:58 <mauke> there are gates with 0 inputs
15:56:06 <mauke> know your mempty
15:56:29 <memo_> please watch my emo: http://emogochi.eu/index.php?page=show&id=11347&lang=en thx:D
15:56:33 <lambdabot> Title: EMOgochi
15:57:22 <ddarius> mauke: That should cause no problems.
16:02:23 <dmwit> Probably easier to march backwards from named outputs, actually.
16:02:37 <dmwit> I think I'll attempt this. =)
16:05:21 <Saizan_> it looks like a comonad inside a zipper with tying-the-knot + something for gates
16:06:21 <ddarius> I don't think anyone has made a zipper based parser combinator library...
16:07:02 <atp> ddarius: do you think that would be possible?
16:07:41 <ddarius> atp: Why wouldn't it be possible?
16:08:53 <atp> ddarius: oh, i didn't mean to suggest it wouldn't be possible... i just couldn't think of how it would work.
16:08:54 <Trinithis> befunge fans: If all the IPs in the program have their move vector (0, 0), should the program terminate cleanly or with an error?
16:10:04 <atp> hm, fleetwood mac is good
16:11:04 <araujo> yeah
16:11:06 <araujo> :-]
16:11:35 <ddarius> atp: The main issue is that it may not be better or all that much different.
16:12:47 <atp> ddarius: oh, i don't care in the least if it's better or even useful in practice.  it sounds like it would be fun.  i just can't think of how it would work, that's all.
16:13:54 <atp> ddarius: are you thinking of zipper-ifying the parse tree?
16:14:00 * atp hmms.
16:14:41 <ddarius> I was thinking of just using a zipper for the input stream.  This would allow unlexing for one thing.
16:15:24 <atp> ah
16:15:49 <atp> i see, so we're talking about a list-based zipper then
16:16:24 <atp> hm
16:16:34 <ddarius> atp: You could probably take you idea and make a zipper for a data structure that parses input as you explore.
16:18:48 <atp> ddarius: yeah... but i guess i still wouldn't know how to incorporate the dynamic portion of the parsing
16:19:23 <atp> ddarius: i suppose the zipper navigation functions would have to have variations for different kinds of parsing, or something...
16:19:50 <atp> it's kind of intriguing, i guess i'd have to think about it for a little bit
16:19:55 <atp> thanks for the neat idea :)
16:21:23 <dmwit> :t lex
16:21:24 <lambdabot> String -> [(String, String)]
16:21:30 <mmorrow> atp: how's the template-haskell going?
16:21:31 * dmwit blinks
16:21:39 <dmwit> ?where prelude
16:21:39 <lambdabot> http://www.haskell.org/onlinereport/standard-prelude.html
16:21:57 <adu> hi
16:22:06 <atp> mmorrow: last night my gf wanted me to quit hacking and go to bed, but i played with it a bit this morning
16:22:12 <atp> mmorrow: it's not too difficult, actually
16:22:17 <mmorrow> cool
16:22:17 <adu> atp: bad
16:22:18 <dmwit> lex is... part of the Prelude??
16:22:20 <atp> mmorrow: thanks for the pointers yesterday, i appreciate that
16:22:23 <mmorrow> yeah totally, it's not bad at all
16:22:30 <mauke> @index lex
16:22:31 <lambdabot> Text.Read, Prelude, Text.Read.Lex
16:22:39 <adu> atp: next time go to bed
16:22:39 <atp> adu: bad?
16:22:52 <mmorrow> no problem. we totally need to add TH support to lambdabot
16:22:56 <atp> adu: hehe :)
16:23:16 <adu> :)
16:23:35 <Saizan_> TH was removed since it let you run IO
16:23:43 <Trinithis> > maxBound ::Int
16:23:45 <Saizan_> i think
16:23:45 <lambdabot>  2147483647
16:23:48 <Trinithis> > minBound ::Int
16:23:49 <lambdabot>  -2147483648
16:23:54 <atp> mmorrow: i found tim sheard & spj's paper on it to be quite easy to grok, it worked perfectly well as a tutorial
16:24:11 <adu> i'm thinking of giving a lecture on haskell...
16:24:15 <adu> any tips?
16:24:23 <atp> adu: for what class?
16:24:37 <adu> atp: for a LUG
16:24:41 <r3m0t> :t toAscList
16:24:42 <lambdabot> Not in scope: `toAscList'
16:24:49 <r3m0t> :t Data.Set.toAscList
16:24:49 <lambdabot> forall a. S.Set a -> [a]
16:25:00 <r3m0t> why not in the Ord context?
16:25:04 <mmorrow> atp: nice, i reread that paper also yesterday and was amazed at how much sense it made the second time around
16:25:28 <mmorrow> i hadn't even looked at it since i first started with TH
16:25:41 <atp> mmorrow: i'm actually surprised how clear the simons can be
16:25:54 <mauke> r3m0t: because a Set is already ordered internally
16:25:57 <mmorrow> atp: very true
16:26:23 <atp> adu: ah, cool.
16:26:44 <glguy> @seen dons
16:26:44 <lambdabot> dons is in #arch-haskell, #ghc, #xmonad and #haskell. I last heard dons speak 1h 49m 51s ago.
16:27:00 <mmorrow> atp: there's another th "update" or something paper from spj that explains some of the newer (as of 2003, but...) TH stuff
16:27:18 <atp> oh, there's new stuff?
16:27:21 <adu> I was thinking of focusing on 3 main points: (1) Haskell's "case" is picky, which prevents bugs (2) Haskell's parser library makes parsing easy, and code injection hard, which prevents bugs (3) Haskell has a nice GC and memory management, which prevents bugs
16:27:33 <mmorrow> i don't recall the link, but it's at    www..../~spj/.../tmp/_.pdf
16:27:43 <atp> i'll take a look, thanks
16:28:34 <mmorrow> atp: it's not so much new stuff, but explains the updates/changes from when that first paper was written
16:28:50 <atp> mmorrow: ah, i see.
16:29:15 <dons> glguy: ?
16:29:34 <mmorrow> quasiquotes seem to be the first new TH-related major thing that's been added since then
16:30:05 <mmorrow> [$ident| some lang |]
16:30:29 <atp> mmorrow: i thought the paper i was looking at discussed quasiquoting
16:30:48 <atp> yah, it does... i'm still looking at it
16:30:50 <thoughtpolice> adu: expressive types & purity rock!
16:31:03 <adu> thoughtpolice: that could be (4)
16:31:27 <adu> although I don't think "purity" goes with the bug-prevention theme
16:31:29 <atp> adu: if it's a lug be cogniscent of the fact that many audience members may not be programmers
16:31:45 <adu> ya, that's why I'm not going into monads
16:31:46 <mmorrow> yeah, when it's refered to in a TH-only context or pre-january 2008, it means [||],[d||], etc  , but in this context it is data QuasiQuoter (String -> ExpQ) (String -> PatQ)
16:31:54 <atp> oh i see
16:32:12 <atp> i'll have to look ta that.
16:32:30 <mmorrow> let idQQ = QuasiQuoter (litE . stringL) (litP . stringP) in [$idQQ| this splices as a String |] == " this splices as a String "
16:32:53 <mmorrow> (that wouldn't work though unless the definition of idQQ was in another module than the one it's used in)
16:33:23 <mmorrow> Language.Haskell.TH.Quote
16:33:30 <mmorrow> darcs get the newest th repo
16:33:51 <mmorrow> i think at  http://darcs.haskell.org/ghc/libraries/template-haskell
16:34:17 <mmorrow> (and you need ghc >= 6.9) for QuasiQuotes to exist)
16:34:36 <atp> hm, i think i'm still on 6.8.x
16:34:53 <atp> debian probably has the new one packaged but i haven't updated in a long while
16:35:10 <mmorrow> could always darcs get --partial http://darcs.haskell.org/ghc  ;)
16:35:14 <atp> the sun came out (a rarity here) so i think i'm going to go take a walk
16:35:14 <lambdabot> Title: Index of /ghc
16:35:19 <mmorrow> heh
16:35:24 <atp> mmorrow: yeah, i've actually been thinking about doing that
16:35:39 <atp> mmorrow: just using hackage and building ghc myself
16:35:52 <atp> mmorrow: debian tends to be a bit behind
16:36:08 <atp> ok
16:36:11 <atp> catch you later
16:36:14 <atp> thanks again mmorrow
16:40:34 <Saizan_> uhm category-extras lack a Control.Comonad.Zipper
16:40:52 <ddarius> Submit a patch
16:42:19 <Saizan_> it would be very similar to .Pointer though
16:43:43 <chrisdone> lovely: http://hpaste.org/9191
16:43:58 <dons> we really do have a chronic shortage of comonadic zippers (and monadic ones!)
16:44:00 <dons> what to do!
16:44:16 <dons> chrisdone: nice.
16:44:33 <dons> chrisdone: have you tried the forkIO version of fastcgi?
16:44:39 <chrisdone> had to hack on network.fastcgi. it's sooo easy to modify haskell code
16:44:55 <chrisdone> dons: yep! I was just pondering a way to save state without mvars, you know?
16:47:00 <ddarius> Haskell: Mutability Through Immutability
16:47:31 <chrisdone> hehe
16:49:43 <chrisdone> I guess you could actually define accessors to the State monad with VMars, so that say foo <- gets fooThingie would read from the VMar and apply fooThingie to it
16:49:51 <chrisdone> that how you guys do it?
16:51:46 <chrisdone> like import qualified Control.Monad.State.Lazy (get,put) as StateM \n gets f = var <- StateM.get; val <- readMVar var; return $ f va
16:51:49 <chrisdone> l
16:53:04 <chrisdone> people go quiet when I talk in here, am I saying stupid stuff?
16:53:53 <mauke> http://en.wikipedia.org/wiki/Warnocked
16:53:53 <lambdabot> Title: Warnock's Dilemma - Wikipedia, the free encyclopedia
16:54:03 <dmwit> Why are you using readMVar, if you want State without MVars?
16:54:07 <Saizan_> you don't need State if you're using an MVar
16:54:23 <dmwit> It seems kind of silly to use both State and MVar.
16:54:51 <Saizan_> you can use Reader (MVar s) to implement MonadState though
16:59:59 <gnut> are STUArrays stored contiguously in memory?
17:00:12 <mmorrow> atp: you should totally build ghc head from darcs :)
17:00:23 <gnut> if I wanted to add one more element into the array, does that mean I have to create a whole new STUArray with one size bigger?
17:00:57 <mauke> arrays are irresizable
17:01:13 <gnut> hrm....
17:01:19 <chrisdone> dmwit, Saizan_: don't you need to carry the MVar around, though?
17:01:35 <chrisdone> Saizan_: ah, yeah, I was just going to say. Reader would be good
17:01:46 <bla123> stdin and stdout are line buffered by default on windows with ghc 6.8.3 and hSetBuffering seems to have no effect. any ideas?
17:02:02 <dmwit> chrisdone: Aren't you trying to get rid of MVars?
17:02:18 <bla123> the same code works with ghc 6.6.1 on linux
17:02:30 <dmwit> <chrisdone> ...pondering a way to save state without mvars...
17:02:32 <chrisdone> dmwit: well, if I were to use threads I'd need MVars, so I was just considering how you'd do it
17:03:11 <dmwit> bla123: Care to paste? hSetBuffering works fine here on 6.8.2.
17:03:31 <dmwit> bla123: Also, is this in ghci or compiled code?
17:04:01 <chrisdone> dmwit: does using threads actually provide an advantage over using one single thread for the fastcgi? (let's assume I'm on a computer with one core)
17:04:30 <dons> well, you should be able to respond to more requests.
17:04:40 <bla123> dmwit: with ghci. i've narrowed it down to "forever (getChar >>= putChar" and trying out "hSetLineBuffering stdin NoBuffering" ...
17:04:41 <dons> since starting a forkIO'd thread is a lot cheaper than a new process
17:05:10 <dmwit> bla123: Don't forget to also hSetBuffering stdout NoBuffering. ;-)
17:05:31 <bla123> dmwit: i thought about that - later on ;-)
17:07:15 <chrisdone> dons: well I mean if you're using fastCGI still, but you're just processing one page at a time rather than forkIO'ing. it seems obvious that threads would let you handle more requests simultaneously, but I don't know if that's true and that's what I'm asking really; I'm running fastcgi with lighttpd which uses select() or some one-process thing, and so aren't the threads bottlenecked by that?
17:07:49 <dons> i think glguy did some benchmarks on this for hpaste2
17:07:52 <chrisdone> dons: so I don't know if concurrency would have an advantage over just doing it sequentially in that case, if you see what I mean
17:07:56 <chrisdone> ohhh yeah
17:08:04 <chrisdone> glguy: ping?
17:08:07 <dons> glguy: was that right, didn't we get some good scaling (or was that adding extra cores?)
17:08:16 <dons> this is the kind of thing that should be on a blog somewhere.
17:08:33 <chrisdone> hehe, yep
17:09:01 <bla123> dmwit: pasted it: http://hpaste.org/9192#a0
17:09:53 <bla123> dmwit: i also compiled it and it made no difference#
17:10:10 <chrisdone> dons: there's this one, but it's just comparing forkIO vs forkOS, probably taking for granted that threads are just going to be faster? http://mult.ifario.us/p/wiring-haskell-into-a-fastcgi-web-server
17:10:11 <lambdabot> Title: wiring-haskell-into-a-fastcgi-web-server
17:10:28 <dmwit> bla123: Works as expected here, what does it do for you?
17:11:10 <bla123> dmwit: when i enter characters, nothing happens until i hit return, then all characters are echoed
17:11:37 <dmwit> OS?
17:11:45 <bla123> dmwit: winxp
17:11:50 <dmwit> urk
17:12:03 <dmwit> Sorry, you'll have to ask somebody else, then. =/
17:12:06 <bla123> dmwit: on 6.6.1/linux it works as expected - every character is echoed immediately
17:12:37 <mmorrow> dons, chrisdone: if i hold down shift-ctrl-r in hpaste2 on lighttpd i can crash spawn-fcgi, but i just tried it with http://chrisdone.com/test2.fcgi and probably sent a few hundred requests at it in a few seconds and it (obviously being single threaded) only incremented twice
17:12:39 <chrisdone> dons: then again, I guess the overall point is you might as well use forkIO and VMars, it can't be /slower/ than one process can it? and if you one day run the web server on multiple cores you get a nice speed increase?
17:12:47 <bla123> dmwit: ok, if it also works with 6.8.2/linux, then maybe its the console
17:12:48 <mmorrow> (just a random observation)
17:13:18 <chrisdone> mmorrow: does that mean your browser keeps the same connection open when you hit shift-ctrl-r?
17:13:26 <dons> mmorrow: oh? crashed lighthttp'd ability to spawn?
17:13:41 <dons> chrisdone: that's the plan.
17:13:43 <mmorrow> chrisdone: it just keeps refreshing
17:14:42 <chrisdone> mmorrow: hmm
17:14:45 <mmorrow> dons: yeah it was weird. (crashed spawn-fcgi, "spawn-fcgi v1.4.19 - spawns fastcgi processes")
17:15:03 <mmorrow> it may have been my setting in lighttpd (i'm just learning it, always use apache)
17:15:24 <mmorrow> spawn-fcgi restarted itself though
17:15:38 <atp> hey dons, is there a reason that bytestring isn't polymorphic (i mean, an efficiency reason?)
17:16:18 <chrisdone> mmorrow: hmm. although lighty is only single threaded, it has poll or whatever it is, so I think it can accept incomming connection simultaneously
17:16:28 <chrisdone> mmorrow: otherwise one person downloading a movie from my site would stop everyone else using it
17:17:24 <mmorrow> chrisdone: yeah, but i shouldn't be able to crash the process in charge of spawning the fastcgi proc just by assaulting it with requests?!
17:17:56 <chrisdone> mmorrow: mine? I don't think so? it only spawns it once after all and then just talks to the existing process
17:17:56 <dons> http://www.reddit.com/comments/6tpia/haskell_as_a_concatenative_language/ cute for the concatenative crowd.
17:17:57 <lambdabot> Title: Haskell as a concatenative language : reddit.com, http://tinyurl.com/6kk55z
17:18:50 <chrisdone> mmorrow: the code is essentially, runFastCGI = do runOneFastCGI; runFastCGI, yeah?
17:19:01 <mmorrow> chrisdone: no, mine. yours increments twice if it gets 100 requests in a few seconds time
17:19:14 <mmorrow> (i tried)
17:19:26 <chrisdone> mmorrow: that's odd, are you definition sure it's doing 100 requests and not re-using existing connections?
17:19:32 <chrisdone> er.. "definitely"
17:21:11 <mmorrow> i think i've caused confusion. what i'm refering to in particular is i setup lighttpd (running as my user) to only serve hpaste.fcgi, which i pre-spawned with spawn-fcgi. in the config file i had it set to maybe 10 procs max. then i did the shift-ctrl-r thing, and both my cores went to 100%, then spawn-fcgi crashed.
17:21:18 <chrisdone> I'll try a bash script that launches 100 processes of curl
17:21:28 <chrisdone> mmorrow: ahhhhh
17:22:36 <mmorrow> i think it's either my choices in the config file or hpaste.fcgi or a spawn-fcgi bug (or more than one of those)
17:22:39 <chrisdone> mmorrow: wow, hmm. did you set the procs limit in lighttpd? I think it has something like that
17:22:49 <mmorrow> yeah, it was around 10
17:22:51 <dmwit> mauke: Augh, '1' is either a source or a gate. =((
17:23:20 <mauke> dmwit: it's only a source if it's followed by a '='
17:23:24 <chrisdone> mmorrow: I'll try this on mine
17:23:36 <chrisdone> mmorrow: I have a forkIO version
17:23:39 * mmorrow looks for the config file he used
17:23:40 <dmwit> mauke: No, it's only a gate if it's surrounded by a '#' rectangle.
17:23:50 <mauke> dmwit: yes, but that's harder to test
17:23:58 <dmwit> mauke: (i.e. as far as I can tell a 1 all alone, connected to nothing, is a valid source.)
17:24:11 <mauke> an unconnected 1 is irrelevant
17:24:24 <dmwit> mauke: It's not irrelevant if you're doing fast-and-loose parsing.
17:24:33 <mauke> pfft, parsing
17:24:51 <dmwit> I want to look at all "gate" characters and find the surrounding rectangles by going left, right, up, and down from them in the picture.
17:24:58 <dmwit> A lone '1' really throws that scheme off.
17:25:26 <dmwit> mauke: "parsing" might be a bit generous for what I'm doing. =P
17:25:50 <mauke> my algorithm does pretty much the opposite :-)
17:26:06 <dmwit> "The opposite" means find rectangles, then look inside for gate characters?
17:26:20 <dmwit> That seems too hard for me, then you have to find the boundaries of rectangles. =)
17:26:24 <mauke> when it finds a #, it looks for the four corners, then scans the inside
17:26:39 <mauke> huh?
17:27:07 <dmwit> I think I'm going to assume there's no pathological lone 1's for now. =P
17:27:39 <hml> @src lambdabot
17:27:39 <lambdabot> Source not found.
17:27:50 <mauke> what's hard about finding boundaries? when you hit a #, you go up/down until the #s stop
17:28:08 <adu> how do you use lambdabot to make points-free code?
17:28:11 <dmwit> "When you find a '#'" assumes you are scanning character-by-character.
17:28:19 <dmwit> ;-)
17:28:31 <dmwit> That's not a very functional approach, now, is it?
17:28:52 <dmwit> adu: ?pl
17:28:55 <rwbarton> dmwit: you could probably do some kind of line-by-line preprocessing pass
17:28:58 <dmwit> ?pl \x y -> f x + f y
17:28:58 <lambdabot> (. f) . (+) . f
17:29:38 <mauke> preflex: ? #11929
17:29:38 <preflex>  First ask yourself 'How would I do this without a computer?'  Then have the computer do it the same way.
17:29:48 <mauke> ^ my approach in a nutshell :-)
17:30:01 <adu> @pl (\ y -> not (eq x y))
17:30:02 <lambdabot> not . eq x
17:30:17 <dmwit> mauke: Mine too, it's just that you and I would do it different ways without a computer. =)
17:32:31 <mmorrow> chrisdone, dons: i can't reproduce the crash, so i'm chalking it up to user error
17:33:57 <chrisdone> mmorrow: good :P
17:34:17 <mmorrow> yeah.
17:34:23 <mmorrow> i really like lighttpd
17:34:39 <mmorrow> i wanna move to it exclusively
17:35:02 <chrisdone> aye, I really like it.
17:35:38 <dmwit> :t break
17:35:41 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
17:36:15 <chrisdone> I'm leaning towards a set of scripts to automate haskell + fastcgi + lighttpd
17:37:03 <mmorrow> i was reading somewhere on the lighttpd site, and the author of some blog post suggested generating lighttpd configs
17:37:17 <mmorrow> genious! and so "of course" after the fact
17:37:36 <chrisdone> hehe
17:37:44 <mmorrow> chrisdone: i use hsfastcgi+(now)lighttpd a lot
17:38:01 <mmorrow> i'd be very interested in anything having to do with those
17:38:08 <chrisdone> mmorrow: cool. I'm getting into it
17:38:16 <chrisdone> mmorrow: sure
17:38:22 <chrisdone> likewise
17:39:02 <mmorrow> cool, let me know of any ideas you have/useful things you do and i'll do likewise :)
17:39:18 <chrisdone> deal ^_^
17:39:32 <mmorrow> excellent
17:40:54 <chrisdone> yeah, I have something like this... http://hpaste.org/9193 that I run when I make changes
17:41:43 <chrisdone> it's kind of verbose and does pointless things but something general like that to work with any hfastcgi seems in order
17:45:15 <mmorrow> i have to nice little scripts that allow direct comparison if forkIO and forkOS use with fastcgi i got off a blog post (which you probably've seen (?))
17:45:22 * mmorrow pastes them
17:45:28 <mmorrow> s/to/two/
17:45:41 <mmorrow> s/if/of/
17:47:11 <chrisdone> cool :D
17:47:31 <dmwit> ?pl \x y -> (+x) *** (+y)
17:47:31 <lambdabot> (. (+)) . (***) . (+)
17:48:02 <dmwit> :t (***) `on` (+)
17:48:05 <lambdabot> forall a. (Num a) => a -> a -> (a, a) -> (a, a)
17:48:11 <dmwit> :t \x y -> (+x) *** (+y)
17:48:12 <lambdabot> forall b b'. (Num b', Num b) => b -> b' -> (b, b') -> (b, b')
17:49:12 <chrisdone> mmorrow: pasted?
17:49:31 <mmorrow> heh, trying to get to them...
17:49:37 <dmwit> ?djinn (c -> d -> e) -> (a -> c) -> (b -> d) -> a -> b -> e
17:49:37 <lambdabot> f a b c d e = a (b d) (c e)
17:49:56 <mmorrow> chrisdone: one min
17:50:21 <chrisdone> mmorrow: hm, just ran a script and it takes 1 second to do 100 requests
17:51:23 <chrisdone> that is, just a simple for ((i=1;i<=100;i+=1)); do curl $1 & done
17:51:37 <mmorrow> chrisdone: you should read the haskell web server paper by simon marlow, it's really relevant and i find it continually useful
17:51:47 <chrisdone> I'll find it
17:53:02 <chrisdone> http://www.haskell.org/~simonmar/papers/web-server-jfp.pdf
17:53:03 <chrisdone> this?
17:53:03 <lambdabot> Title: ¬ ¬¢¬°¬§¬£¬•¬°¬ß¬¶¬© 5176! ¬• 98@¬° A ¬°CBEDF¬°¬§17¬£¬•¬°¬§1G H I% P8¬§Q 171R¬°¬ ...
17:53:20 <chrisdone> oh dear
17:53:21 <mmorrow> yeah, exactly
17:53:32 <chrisdone> I think that's Œªb's double encoding of utf-8
17:53:57 <mmorrow> its current form is darcs get --partial http://code.haskell.org/mohws
17:54:01 <lambdabot> Title: Index of /mohws
17:54:03 <chrisdone> oki
17:55:19 <chrisdone> ohhh yeah. I've seen this. I think I've actually hacked on the code at one point, haha
17:55:32 <mmorrow> chrisdone: i dunno what i did with those files, but they're here (along with some good data/info): http://mult.ifario.us/p/wiring-haskell-into-a-fastcgi-web-server
17:55:33 <lambdabot> Title: wiring-haskell-into-a-fastcgi-web-server
17:57:08 <chrisdone> mmorrow: hm does he provide the httpd_load program?
17:57:45 <mmorrow> http://www.acme.com/software/http_load/
17:57:45 <lambdabot> Title: http_load
17:58:01 <chrisdone> ah, thanks
18:05:15 <koninkje> are there any haddock gurus in the house?
18:07:26 <dolio> What qualifies someone as a guru?
18:08:20 <vixey> It is also used for teacher or guide in the religious or sense, and is commonly used in Hinduism, Buddhism and Sikhism, as well as in some [[new religious movements]]
18:08:25 <koninkje> I'm building the documentation for a project and I'm trying to get it to resolve external references (Prelude, etc) to the versions already online
18:08:29 <vixey> new religious movements --> links to haskell (programming language)
18:08:49 <koninkje> passing cabal --html-location= doesn't seem to work
18:09:07 <dolio> Well, you've gone outside of my realm of expertise, unfortunately. :)
18:09:20 <dolio> Guess I'm not a guru.
18:09:22 <koninkje> alas :)
18:09:50 <koninkje> well my google fu failed to locate anything online beyond one lonely email a couple years back suggesting that flag
18:10:02 <koninkje> and yet somehow other folks do it...
18:11:21 <adu> dolio: all it takes is for one person to think you're a guru, and I think you're a guru, dolio
18:11:31 <dolio> Awesome.
18:19:56 <chrisdone> how come ghc needs to be told to run -threaded?
18:20:08 <chrisdone> can't it figure that out?
18:20:45 <mauke> based on what?
18:22:21 <chrisdone> use of forkIO/forkOS
18:22:31 <bd_> that's not what -threaded is for :)
18:22:40 <bd_> you can use forkIO in a non -threaded GHC
18:22:44 <thoughtpolice> -threaded links the threaded runtime into your program
18:22:51 <thoughtpolice> the reason being so you can run code on multiple cores
18:22:55 <bd_> the only thing is in a non-threaded runtime, you only have one thread running haskell code
18:22:57 <chrisdone> bd_: when I try to do that the program hangs
18:23:11 <thoughtpolice> also it is necessary when dealing with blocking FFI calls
18:23:30 <Saizan_> or blocking IO?
18:23:57 <thoughtpolice> those too :p
18:24:33 <mauke> no, blocking IO uses select(2) behind the scenes
18:24:43 <mauke> as long as it blocks on a file descriptor
18:34:00 <mmorrow> you can wire +RTS -N2 -RTS in to a program statically by putting:
18:34:01 <mmorrow> char *ghc_rts_opts = "-N2";
18:34:12 <mmorrow> in a .c file and linking that in with the executable
18:34:55 <mauke> is that just a default or will it override +RTS command line settings?
18:35:04 <mmorrow> i think it's just default
18:35:11 <mmorrow> (but don't quote me)
18:35:11 <MyCatVerbs> mmorrow: but if you do, all your users who bought four- or eight-way SMP machines will kick your door down and eat your puppies.
18:35:25 <mmorrow> puppies *are* delicious!
18:54:25 <TomMD> Funptr's are not fun.
18:54:51 <atp> it's false advertisement!
18:54:55 <O_4> How misleading.
18:55:33 <TomMD> Anyone know of a good reference library for callbacks.  I recall a couple being mentioned but foolishly never looked them up at the time.
18:55:57 <TomMD> s/\./\?/
18:57:39 <Korollary> What is a callback reference library?
18:58:16 <aslatter> so, I tried something that I thought should type-check, but it doesn't - here's a simpler version of it: http://hpaste.org/9194
18:58:22 <aslatter> am I just being silly, here?
18:58:55 <aslatter> I'm expecting the "Storable" contraint to propagate to the "dummy" variable
18:59:01 <aslatter> constraint, rather
18:59:08 <TomMD> Korollary: My poor choice of words. I am looking for a library that preforms FFI and one of the FFI calls should be a callback.
18:59:48 <TomMD> I assume I use a funptr for that (perhaps thats a wrong assumption).  The issue then is how do I turn a haskell function into a funptr.
19:01:53 <vixey> aslatter: that so weird
19:01:58 <vixey> aslatter: that is * so weird
19:02:09 <vixey> :t sizeOf
19:02:12 <lambdabot> Not in scope: `sizeOf'
19:02:28 <vixey> what's the type error?
19:04:48 <erikc> http://hpaste.org/9195
19:05:18 <erikc> can someone explain why this is type IO String and not IO (Handle, IO String) ?
19:05:31 <adu> maybe
19:06:15 <dmwit> erikc: Check the types of ioe_closedHandle/ioe_notReadable.
19:06:45 <TomMD> I love the addendum.  If in doubt, go to the source.  "wrapper" is a predefined foreign that the addendum expects you to write an import declaration for.  Why is that?
19:06:51 <aslatter> vixey:  with GHC 6.8.3 I get:  Test.hs:5:17:
19:06:51 <aslatter>     Ambiguous type variable `a' in the constraint:
19:06:51 <aslatter>       `Storable a' arising from a use of `sizeOf' at Test.hs:5:17-28
19:06:51 <aslatter>     Probable fix: add a type signature that fixes these type variable(s)
19:06:52 <dmwit> erikc: The _ case may have type IO (Handle, IO String), but it has to unify with the other cases.
19:08:14 <vixey> oh
19:08:15 <vixey> try this,
19:08:42 <vixey> test x = (\dummy -> let n = sizeOf dummy
19:08:42 <vixey>          in (x `asTypeOf` dummy, n)) undefined
19:08:46 <vixey> using lambda instead of let
19:08:50 <adu> erikc: is that from GHC 6.2?
19:08:57 <erikc> 6.8.3
19:09:24 <vixey> erikc: The typing rules of let are subtly different from those of lambda
19:09:36 <vixey> let generalizes the type to (i.e foralls what it can)
19:09:50 <vixey> s/to //
19:10:15 <aslatter> vixey:  that works.  hopefully I can pull of the same trick where I need it
19:10:20 <aslatter> vixey: thanks
19:10:23 <vixey> oops
19:10:29 <vixey> erikc: sorry.....
19:10:51 <erikc> ah sorry, i should have dug a bit deeper, i didnt see what withHandle was doing, n/m
19:10:53 <vixey> was talking to the wrong person
19:11:10 <adu> erikc: withHandle :: String -> Handle -> (Handle__ -> IO (Handle__, a)) -> IO a
19:34:56 <Trinithis> Is System.Cmd.system the same as C's system()?
19:35:39 <dons> duncan, SyntaxNinja and I are working on a demo for the haskell workshop. here's a draft abstract. what do people think, http://hpaste.org/9196 ?
19:35:59 <dons> its about cabal/hackage and generally how the community can sustain itself into the future
19:36:42 <Trinithis> ob-scurity?
19:36:44 <dmwit> There's some odd spacing/dash stuff there...
19:36:48 <Trinithis> oh
19:36:58 <dons> ps2ascii :)
19:37:05 <dmwit> ok =)
19:37:41 <Trinithis> their libraries; on their breadth -> s/;/:
19:38:48 <dmwit> I would make the second paragraph a bit more concise... maybe "...with more code produced and reused than ever before."
19:39:24 <dons> ok.
19:39:29 <dmwit> But even if you don't do that, for grammar you have to s/reuse/reused/. =)
19:39:57 <Shiruka> dons: this is aimed at people not too familiar with haskell, right?
19:40:26 <dons> the whole community. it'll be presented right at the end of the haskell workshop.
19:40:41 <dmwit> Otherwise, pretty good!  I guess you're playing on Python's "batteries included" motto on purpose?
19:40:49 <dons> right.
19:41:25 <Shiruka> oh, ok.. I thought that you might want to mention hoogle/hayoo/wiki, as it's sort of part of the documentation/collaboration infrastructure, but haskellers will already know about those :-)
19:41:26 <jeffwheeler> I'm with Trinithis; what's with "ob-scurity"?
19:41:42 <Trinithis> jeff: It was a conversion issue from ps to txt
19:41:43 <chrisdone> dons: will there be a video of this? ^_^
19:41:48 <dons> chrisdone: yes.
19:41:53 <dmwit> jfredett: In con-junction with a newline, it's just obscurity. ;-)
19:41:53 <chrisdone> dons: yay
19:41:56 <dmwit> err
19:41:58 <dons> Shiruka: yep. good idea about the wiki. and api search.
19:41:58 <jeffwheeler> Trinithis: oh, I thought that was the above source; sorry
19:42:02 <dmwit> *jeffwheeler
19:45:49 <ac> :src (.)
19:45:58 <chrisdone> I think I'm going to make a Rails for haskell+fastcgi+lighttpd. not a copy of rails (you might as well just use rails), but I mean the sense of easy to setup and work with in an automated way
19:46:00 <Trinithis> @src (.)
19:46:00 <lambdabot> (f . g) x = f (g x)
19:46:00 <lambdabot> -- In lambdabot, it's been generalised to:
19:46:00 <lambdabot> (.) = fmap
19:46:02 <chrisdone> @src (.)
19:46:02 <lambdabot> (f . g) x = f (g x)
19:46:02 <lambdabot> -- In lambdabot, it's been generalised to:
19:46:02 <lambdabot> (.) = fmap
19:46:06 <ac> ah that's the source command
19:46:28 <Shiruka> dons: most languages don't have the api searches, and one particular case where they are invaluable is when you're looking for an infix operator.. google is totally useless with those
19:46:35 <Trinithis> in the prelude, f . g = \x -> f (g x)
19:46:58 <Trinithis> oh, lambdabot got a display upgrade
19:47:01 <dons> Shiruka: yeah, i guess that's pretty advanced. hayoo let's you search by type matching over all published haskell code.
19:47:04 <dons> pretty radical.
19:47:35 <dons> chrisdone: awesome.
19:48:09 <Trinithis> what exactly is Rails?
19:48:53 <Shiruka> ruby on rails? it's a web app framework
19:48:57 <chrisdone> Trinithis: it's a web framework for Ruby. similar to Django, if you have heard of that
19:49:09 <dons> ruby? what's that.
19:49:13 <Trinithis> lol
19:49:14 <chrisdone> hehe
19:51:40 <chrisdone> yeah, I think I'm going to implement a few sites. a copy of reddit, a wiki-like site with upmodding, maybe a blog (mandatory?), and then more narrow things like a web interface for producing word clouds with my word cloud library
19:51:56 <chrisdone> because I think in doing that I will know what needs to be added, what works nicely, etc.
19:52:43 <ahunter2> question: I
19:52:55 <ahunter2> want to make a local array (immutable) of STRefs.
19:53:08 <ahunter2> Trying to do this with just listArray gets a weird error about not being able to infer the type;
19:53:11 <Shiruka> wasn't happs supposed to fill the role of rails for haskell? (I've never even looked at happs)
19:53:26 <vixey> ahunter2: huh...?
19:53:29 <ahunter2> annotating the type as Array Int (STRef s Int) gives problems with a rigid variable s
19:53:40 <jeffwheeler> Shiruka: it doesn't. :-/
19:53:40 <ahunter2> sorry, accidently hit enter in the middle of typing
19:53:42 <vixey> do you know about STArray?
19:53:46 <vixey> it the wrong thing to use?
19:54:00 <chrisdone> awww sweeeet. this hayoo is shibby
19:54:06 <ahunter2> vixey: I know of it, yes--I don't need mutability though, so I thought the "right thing" here would be a simple array
19:54:13 <dons> happs is one solution.
19:54:16 <vixey> what is the difference?
19:54:28 <vixey> I mean why have STRefs.. if you don't want mutability
19:54:38 <jeffwheeler> Shiruka: if I remember correctly, HAppS forces you into a lot of weird stuff; like XSLT and loading most of the content through JS
19:54:59 <Shiruka> oh, ic
19:55:01 <ahunter2> well, I don't want the array to be mutable...I just need an array (O(1)) indexing of ST objects
19:55:06 <vixey> does it work without the type annotation?
19:55:19 <ahunter2> (well, technically, they're not STRefs, they're other objects that are in the ST monad, I was just trying to simplify
19:56:19 <chrisdone> jeffwheeler: yeah, it's nice but not my cup of tea in that aspect
19:57:10 <jeffwheeler> chrisdone: I'm a huge fan of Django. It is similar to Rails, but doesn't have any of the horribly-ugly magic that Rails has (like model names automatically being pluralized).
19:57:23 <ahunter2> vixey: STArray, also, does not work without the type annotation
19:57:47 * Shiruka hasn't used rails, but likes django
19:57:47 <chrisdone> jeffwheeler: haha, yeah. I WTF'd at that when going through a guide
19:58:50 <dons> ?users
19:58:50 <lambdabot> Maximum users seen in #haskell: 471, currently: 434 (92.1%), active: 10 (2.3%)
19:59:31 <chrisdone> haskell web coding; correct/verifiable, FAST, and your favourite language. what could be better?
20:00:10 <jeffwheeler> I'd be interested in what solutions for state/sessions come out. I think HAppS might have something there.
20:01:11 <chrisdone> jeffwheeler: how do you mean?
20:02:11 <jeffwheeler> chrisdone: well, sessions aren't a very clean problem to solve in my opinion, and HTTP is inherently stateless. I wonder how a new web framework in Haskell might handle sessions (and thus state).
20:02:54 <dmwit> > do { x <- undefined; y <- ask; return (y + 3) } 32
20:02:55 <lambdabot>  Parse error at "32" (column 49)
20:03:00 <dmwit> > do { x <- undefined; y <- ask; return (y + 3) } $ 32
20:03:05 <Shiruka> with continuations? :-P
20:03:10 <chrisdone> jeffwheeler: I know of a few ways. maybe it's a case of choosing a monad for the kind of state you want
20:03:16 <lambdabot>  thread killed
20:07:10 <chrisdone> jeffwheeler: one interesting to me is validating inputs...
20:07:41 <jeffwheeler> chrisdone: Django does that well in Python, but I'm not sure how to do that in Haskell either.
20:07:52 <chrisdone> jeffwheeler: I've tried one way of simply having a list of validating functions which take a String and return an Either with an error or a value, which is probably the obvious way, right?
20:07:56 <jeffwheeler> Shiruka: I've never heard of doing that for web development. Reading Wikipedia, that's really neat.
20:08:19 <jeffwheeler> chrisdone: I'm not at all a Haskell expert, but that seems to correspond with what I've seen in other code.
20:08:28 <chrisdone> yeah, I've used continuation based web stuff with PLT Scheme's server
20:09:03 <gaze__> what's the proper way to inline j=[1..9]:j ?
20:09:14 <vixey> gaze__: huh ???
20:09:19 <chrisdone> jeffwheeler: yeah. then I was thinking maybe a little EDSL would do nicely, like a Parsec but with more descriptive errors that can be sent to the user
20:09:23 <vixey> > cycle [1..9]
20:09:26 <lambdabot>  [1,2,3,4,5,6,7,8,9,1,2,3,4,5,6,7,8,9,1,2,3,4,5,6,7,8,9,1,2,3,4,5,6,7,8,9,1,2...
20:09:39 <dmwit> gaze__: That doesn't type-check.  But you might like "cycle" or "repeat".
20:09:51 <gaze__> well, I want
20:10:06 <gaze__> [[1..9],[1..9],[1..9] ...]
20:10:11 <TSC> repeat
20:10:11 <dmwit> > repeat [1..9]
20:10:12 <lambdabot>  [[1,2,3,4,5,6,7,8,9],[1,2,3,4,5,6,7,8,9],[1,2,3,4,5,6,7,8,9],[1,2,3,4,5,6,7,...
20:10:21 <gaze__> yay thanks
20:10:23 <Shiruka> one important part in django-style web frameworks is the fast turnaround (including automatic detection of code changes and reload); you can do that with hs-plugins, right?
20:10:27 <TSC> repeat x = x : repeat x
20:10:29 <chrisdone> jeffwheeler: like age = number >>= inRange(18,120)
20:10:33 <vixey> > let j=[1..9]:j in j
20:10:34 <lambdabot>  [[1,2,3,4,5,6,7,8,9],[1,2,3,4,5,6,7,8,9],[1,2,3,4,5,6,7,8,9],[1,2,3,4,5,6,7,...
20:10:36 <dmwit> > let j = [1..9]:j in j
20:10:37 <lambdabot>  [[1,2,3,4,5,6,7,8,9],[1,2,3,4,5,6,7,8,9],[1,2,3,4,5,6,7,8,9],[1,2,3,4,5,6,7,...
20:10:45 <dmwit> Well, okay, so it *does* type-check. =P
20:10:58 <Trinithis> @pl peekAt n = (!! n) . toList
20:10:58 <lambdabot> peekAt = (. toList) . flip (!!)
20:11:09 <jeffwheeler> Shiruka: keep in mind that only applies to the built-in development server; the production servers don't support that
20:11:17 <jeffwheeler> (at least in Django)
20:11:23 <Shiruka> yeah, I meant development
20:12:19 <Shiruka> deployment to production has enough overhead that a manual compilation isn't going to matter at all :-)
20:13:05 <hml> cd
20:13:10 <hml> s
20:13:18 <chrisdone> Shiruka, jeffwheeler: yeah, right now I edit my haskell code, run my install script which compiles and then it restarts the fastcgi process. it could be possible for it to save state to file and restart it and re-load the state, or use the GHC API to actually compile and load files for newly updated functions... lots of ways
20:13:48 <Shiruka> it could even interpret the code :-)
20:13:56 <chrisdone> but that would kind of suck
20:14:01 <chrisdone> we want it to be fast
20:14:16 <chrisdone> well, I do
20:14:47 <jeffwheeler> chrisdone: Shiruka: on my Django server, I currently have it update the src and just restart the server, which recreates the pyc files as necessary; it works well, but doesn't really match the needs of Haskell
20:15:34 <mxc> good morning/evening
20:15:49 <chrisdone> jeffwheeler: how are inputs validated in django? can you show an example?
20:15:51 <hml> s
20:15:58 <chrisdone> hi msxc
20:16:13 <chrisdone> damn, hml, you made me write an 's'. get out of my head
20:17:29 <mxc> i'm pretty sure that the answer is no, but is there and function a -> a -> bool which returns true if both arguments have the same type constructor?
20:17:45 <vixey> maybe it does exist
20:17:51 <vixey> Data.Dynamic has stuff like this
20:18:08 <TSC> Isn't that the sort of thing that Uniplate (and the like) should do?
20:18:09 <chrisdone> you could define an Eq instance for that
20:18:22 <mxc> i've basically been doing that, with a giant pattern match
20:18:28 <jeffwheeler> chrisdone: give me a second and I can find you some info from the docs
20:18:40 <chrisdone> jeffwheeler: ah, cool ^_^
20:20:21 <dolio> > toConstr (Just 5)
20:20:22 <lambdabot>  Just
20:20:33 <dolio> @type (==) `on` toConstr
20:20:34 <lambdabot> forall a. (Data a) => a -> a -> Bool
20:20:37 <TSC> @index toConstr
20:20:38 <lambdabot> Data.Generics.Basics, Data.Generics
20:20:45 <mxc> ooh
20:20:47 <mxc> ty dolio
20:21:05 <dolio> > ((==) `on` toConstr) Nothing (Just 5)
20:21:06 <lambdabot>  False
20:21:12 <chrisdone> nice
20:21:13 <dolio> > ((==) `on` toConstr) (Just 4) (Just 5)
20:21:14 <lambdabot>  True
20:21:32 <mxc> thanks
20:21:43 <mxc> on looks useful too
20:21:47 <mxc> :t on
20:21:47 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
20:21:56 <dolio> Yeah, on is handy.
20:22:11 <cjs> I'm doing a bunch of processing of various things in the Error monad (returning Either String a) and I've got various things returning Maybe that I'd like to turn into a Left String if the thing returns Nothing. Is there a handy library function around for dealing with this kind of thing?
20:22:18 <jeffwheeler> chrisdone: It's very much integrated with the forms code, so it works with the form cleaning code: http://www.djangoproject.com/documentation/forms/#custom-form-and-field-validation; this contains all the default fields and their "clean" methods: http://code.djangoproject.com/browser/django/trunk/django/forms/fields.py
20:22:19 <lambdabot> Title: Django | The forms library | Django Documentation, http://tinyurl.com/2zt9eq
20:22:45 <jeffwheeler> Ha, lambdabot stops looking after the first long link.
20:23:04 <cjs> Like a Mabye a -> String -> Either String a, I guess.
20:23:06 <Draconx> @type maybe
20:23:06 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
20:23:14 <Draconx> like that?
20:23:24 <cjs> Oh, is that it? :-)
20:23:30 <dobblego> no
20:23:46 <dobblego> though you could use it
20:24:07 <vixey> ?djinn Mabye a -> String -> Either String a
20:24:08 <lambdabot> f _ a = Left a
20:24:17 <vixey> ?djinn Maybe a -> String -> Either String a
20:24:17 <lambdabot> f a b =
20:24:17 <lambdabot>     case a of
20:24:17 <lambdabot>     Nothing -> Left b
20:24:17 <lambdabot>     Just c -> Right c
20:24:19 <dobblego> @type \s -> maybe (Left s) Right
20:24:19 <lambdabot> forall a b. a -> Maybe b -> Either a b
20:24:44 <dolio> Well that's odd.
20:24:53 <dobblego> what? 3?
20:24:54 <chrisdone> jeffwheeler: yeah, that's kind of ish how I'd do it
20:25:24 <dolio> Does djinn pick at random, or does it remember recent queries?
20:26:31 <bd_> ?djinn Maybe a -> String -> Either a String
20:26:31 <lambdabot> f a b =
20:26:31 <lambdabot>     case a of
20:26:31 <lambdabot>     Nothing -> Right b
20:26:31 <lambdabot>     Just c -> Left c
20:26:44 <dobblego> ?djinn Maybe a -> b -> Either a b
20:26:44 <lambdabot> f a b =
20:26:44 <lambdabot>     case a of
20:26:44 <lambdabot>     Nothing -> Right b
20:26:44 <lambdabot>     Just c -> Left c
20:26:51 <bd_> dolio: I think it's deterministic - wasn't there a paper on it?
20:26:54 <vixey> ?djinn Either (Either (Either (Either (a) (a)) (a)) (Either (a) (a))) (Either (Either (a) (a)) (a)) -> a
20:26:54 <lambdabot> f a =
20:26:54 <lambdabot>     case a of
20:26:54 <lambdabot>     Left b -> case b of
20:26:54 <lambdabot>               Left c -> case c of
20:26:54 <lambdabot>                         Left d -> case d of
20:26:56 <lambdabot>                                   Left e -> e
20:26:58 <lambdabot>                                   Right f -> f
20:27:00 <lambdabot>                         Right g -> g
20:27:02 <lambdabot>               Right h -> case h of
20:27:04 <lambdabot>                          Left i -> i
20:27:06 <lambdabot>                          Right j -> j
20:27:08 <lambdabot>     Right k -> case k of
20:27:10 <lambdabot> Plugin `djinn' failed with: thread killed
20:27:20 <dolio> bd_: Well, when there are multiple options, lambdabot has to pick one to display.
20:27:28 <chrisdone> ¬∑‚Äî¬∑
20:27:44 <dolio> When you run djinn in the console, I think it'll show them all.
20:27:59 <bd_> ah
20:28:03 <bd_> maybe it takes the first? :)
20:28:18 <cjs> What is djinn?
20:28:18 <dmwit> :t runReaderT
20:28:19 <lambdabot> forall r (m :: * -> *) a. ReaderT r m a -> r -> m a
20:28:29 <dolio> But it just showed two different functions for the same type.
20:28:33 <vixey> cjs: Djinn means genie
20:28:35 <bd_> cjs: given a type, it makes a function with that type
20:28:39 <dolio> Oh, wait, one was misspelled.
20:28:40 <vixey> cjs: ask it a wish
20:28:43 <dmwit> :t runState
20:28:44 <lambdabot> forall s a. State s a -> s -> (a, s)
20:28:46 <dolio> My bad.
20:28:51 <cjs> Huh, interesting!
20:28:56 <dolio> Human foibles at work.
20:29:14 <dmwit> :t evalState
20:29:15 <lambdabot> forall s a. State s a -> s -> a
20:29:31 <cjs> bd_: BTW, you got the arguments to Either reversed.
20:29:55 <cjs> ?djinn Maybe val -> err -> Either err val
20:29:55 <lambdabot> f a b =
20:29:55 <lambdabot>     case a of
20:29:55 <lambdabot>     Nothing -> Left b
20:29:55 <lambdabot>     Just c -> Right c
20:30:21 <cjs> Which is right, but not quite as pretty as mine:
20:30:23 <cjs> maybeError Nothing err = Left err
20:30:23 <cjs> maybeError (Just x) _  = Right x
20:30:45 <chrisdone> hehe
20:31:17 <dobblego> @type \s -> maybe (Left s) Right
20:31:17 <lambdabot> forall a b. a -> Maybe b -> Either a b
20:31:31 <vixey> @pl \s -> maybe (Left s) Right
20:31:31 <lambdabot> flip maybe Right . Left
20:31:45 <dobblego> yeah that!
20:31:49 <jeffwheeler> Is the latest HOC (Haskell/Objective-C) the one on Sourceforge, last released in 2004? Yi seems to depend on it, but I can't even get it to compile on a recent Mac.
20:32:53 <jeffwheeler> (By "depends on", I mean "depends on for the Cocoa bindings"
20:32:54 <jeffwheeler> )
20:33:24 <gaze__> map (\x -> arr!(x,0) ) [1..3] <<< I don't grok what's wrong with this
20:33:59 <sjanssen> gaze__: that looks fine
20:34:11 <atp> gaze__: probably the surrounding code
20:36:20 <dmwit> Alright, everything but '+' is taken care of.
20:52:15 <dogbite> I'm getting a Prelude.read exception but I don't know what line is causing it.  what's
20:52:27 <dogbite> the best way to debug this?  i've tried doing :trace main
20:52:41 <dogbite> like in dons post, but it doesn't stop at the exception
20:54:21 <dolio> Use a safe read instead, and throw your own exceptions?
20:55:09 <dogbite> well i have several reads... is that the best option?  to go through and change them all?
20:55:32 <dogbite> i'd love it if i could get ghci to throw some sort of line number
20:55:58 <dolio> I think there's some option to get the profiler to tell you where an exception is happening.
20:56:11 <dolio> Potentially.
20:56:21 <dons> dogbite: did you -fset-break-on-exceptions or what it is.
20:56:27 <dons> break-on-error
20:56:39 <dogbite> dons: nope
20:57:00 <dogbite> dons: oh i see.. one sec
20:58:13 <gaze__> how would you go from [[1,2,3,4,5],[1,2,3,4,5]] to "12345\n12345\n"?
20:58:26 <dogbite> dons: okay it's working now.  i forgot ':set -fbreak-on-exception'
20:58:31 <dogbite> thank you
20:58:33 <dolio> -xc is the profiler option.
20:58:43 <dolio> +RTS -xc
20:58:44 <dmwit> gaze__: Take a look at map and unlines.
20:58:49 <dolio> To your program.
20:59:21 <dmwit> gaze__: See if you can go from [1..5] to "12345" as a first step.
20:59:56 <gaze__> oh! oh! show!!!
21:00:14 <gaze__> muahah, I think I got it
21:00:20 <dmwit> Great!
21:01:40 <gaze__> map (\x -> show x) [1,3,4,5]...aw, not it I guess. How do you flatten an array?
21:01:50 <gaze__> err... list
21:02:01 <dmwit> concat
21:02:15 <dmwit> gaze__: Also, (\x -> show x) === show
21:02:15 <dolio> @type intToDigit
21:02:27 <dmwit> > map show [1,3,4,5]
21:02:30 <lambdabot> thread killed
21:02:33 <dmwit> > map show [1,3,4,5]
21:02:38 <lambdabot>  ["1","3","4","5"]
21:02:38 <lambdabot>  ["1","3","4","5"]
21:02:43 <atp> gaze__: try concatMap
21:02:48 <sjanssen> dmwit: (\x -> show x) does not always equal show in Haskell :P
21:03:00 <dmwit> MR aside
21:03:06 <dmwit> > [1..5] >>= show
21:03:07 <lambdabot>  "12345"
21:03:10 <atp> seq can also break eta reduction i think
21:03:27 <dolio> Yes.
21:03:30 <sjanssen> dmwit: consider when show = _|_
21:03:32 <gaze__> concatMap show [1..4]
21:03:34 <gaze__> works
21:03:52 <rwbarton> But show /= _|_
21:04:08 <rwbarton> Oh, OK.
21:04:21 <dolio> Actually show is equivalent to \x -> show x as far as the monomorphism restriction is concerned.
21:04:40 <sjanssen> rwbarton: sometimes it can be
21:04:42 <dolio> "foo = \x -> show x" will still be monomorphized.
21:04:44 <rwbarton> @src show
21:04:44 <lambdabot> show x = shows x ""
21:04:52 <rwbarton> (I thought so too, but...)
21:04:56 <sjanssen> rwbarton: ah, very clever
21:05:15 <sjanssen> rwbarton: no, it can still be _|_
21:05:23 <sjanssen> it is a class method, that is merely the default definition
21:06:06 <rwbarton> sjanssen: ah, even more clever :)
21:22:11 <dmwit> How come ^D doesn't work as EOF in runhaskell?
21:23:04 <rwbarton> dmwit: I know!  I was wondering something similar (ghc -e "..." file.hs messes with the terminal state)
21:23:32 <dmwit> ^D is read as \NUL, actually.
21:23:44 <dmwit> That's *really* weird behavior, in my opinion.
21:24:06 <dmwit> err... even weirder than that
21:24:16 <dmwit> It's \NUL the first time, and \EOT every other time (?).
21:24:44 <rwbarton> It also disables line buffering of input
21:25:06 <dmwit> Yeah, it seems to set NoBuffering on stdin/stdout.
21:25:13 <rwbarton> And, if you kill it with ^C, it doesn't reset the terminal.
21:25:35 <dmwit> ^C doesn't kill until a newline here!
21:25:36 <rwbarton> I'm pretty sure the terminal ordinarily does buffering of input
21:25:48 <rwbarton> Yeah, same here
21:26:02 <dmwit> That is some really weird behavior.
21:26:35 <dmwit> ghc -e seems well-behaved, though.  You say the same things happen to you with -e?
21:27:17 <rwbarton> Only when I provide a .hs file to load
21:27:23 <dmwit> Oh well, "cat | runhaskell" is my new workaround for that. =P
21:27:53 <rwbarton> clever!
21:27:54 <rwbarton> dmwit++
21:28:16 <rwbarton> Now I can finish writing my "interact" shell script
21:28:41 <dmwit> heh
21:37:57 <dmwit> mauke: I tried to submit an answer to SPOJ, but it doesn't have Control.Monad.State. =/
21:38:44 <dmwit> ...not that you care, probably.  heh
21:40:40 <Trinithis> @src (Ord a, Ord b) => Ord (a, b)
21:40:40 <lambdabot> Source not found. Are you on drugs?
21:40:48 <sjanssen> hmm, SPOJ.  There's a site I haven't visited in a good long while
21:41:09 <dmwit> Trinithis: compare (a, b) (c, d) = compare a b `mappend` compare c d
21:41:11 <rwbarton> > (2, 3) > (1, 100)
21:41:21 <dmwit> err...
21:41:26 <lambdabot>  thread killed
21:41:29 <Trinithis> dmwit: thx
21:41:31 <dmwit> Trinithis: compare (a, b) (c, d) = compare a c `mappend` compare b d -- of course
21:41:57 <Trinithis> @src Ordering mappend
21:41:58 <lambdabot> Source not found. You untyped fool!
21:42:08 <Trinithis> @src mappend Ordering
21:42:09 <lambdabot> Source not found. Wrong!  You cheating scum!
21:42:32 <dmwit> EQ `mappend` x = x; y `mappend` _ = y
21:42:41 <dobblego> it will be ... what dmwit said
21:42:43 <Trinithis> alright
21:43:57 <gaze__> is there a nice built in function to change the nth item of a list to something?
21:44:03 <dmwit> no
21:44:16 <dmwit> If you're doing that, it's often a good idea to re-architect your solution.
21:44:52 <dons> yeah, you probably should be using an IntMap
21:45:24 <Trinithis> or Map
21:46:03 <hml> how do I fix the following?
21:46:05 <hml> update_array_entry :: (STArray a Int [Int]) -> Int -> ([Int] -> [Int]) -> IO ()
21:46:05 <hml> update_array_entry arr index func = do a <- readArray arr index writeArray arr index (func a)
21:46:14 <vixey> gaze__: You should ask gwern maybe
21:46:16 <hml> err, there is a \n after "readArray arr index"
21:46:18 <vixey> @seen gwern
21:46:18 <lambdabot> gwern is in #darcs, #xmonad and #haskell. I don't know when gwern last spoke.
21:46:40 <vixey> gaze__: although I can't really think of a good name for it, can you?
21:46:50 <gaze__> well, it's more like... I have an array [2,3] and the function needs to return "1..45"
21:47:00 <vixey> oh an array is something else
21:47:14 <vixey> I don't understand what you just said though
21:47:35 <vixey> hml: looks like you need a ;
21:47:37 <dmwit> gaze__: It's easy to change the nth element in an array, but I'm guessing "array" was just a slip of the tongue for "list". =P
21:47:42 <vixey> oh never mind
21:47:48 <rwbarton> Shouldn't IO () be ST a ()?
21:47:51 <vixey> \n would do
21:47:54 <gaze__> argh, sorry haha. Yeah I meant list
21:48:29 <hml> rwbarton: tha5t fixed it; thanks
21:51:01 <rwbarton> gaze__: if the numbers involved are small, I would just check for each number 1, ..., 5 whether it is in the list and concat the resulting "n" or "." strings
21:51:56 <arquebus> anyone know a simple free text editor like Scite that supports Haskell syntax?
21:52:18 <jeffwheeler> arquebus: Yi?
21:52:35 <vixey> arquebus: emacs
21:52:49 <vixey> actually I don't know if that's like scite or not
21:52:51 <arquebus> emacs is not simple
21:52:57 <vixey> arquebus: yes it is
21:53:11 <vixey> there are I think 3 commands you need to know
21:53:30 <jeffwheeler> vixey: As an emacs user, I can knowingly say emacs is not simple.
21:53:34 <bwr> there is gedit if you want really simple
21:53:38 <jeffwheeler> There's a friggan mail client builtin.
21:53:43 <gaze__> nedit maybe?
21:53:45 <arquebus> vixey- there are at least a hundred commands you have to know just to use the basics of emacs
21:53:46 <gaze__> vim + cream?
21:54:10 <arquebus> bwr- thx but Im not on linux
21:54:15 <vixey> arquebus: No that's not true at all
21:54:31 <jeffwheeler> arquebus: what OS are you on?
21:54:37 <arquebus> windows
21:54:45 <jeffwheeler> Yi is fairly beta, but can run on Windows with GTK or VTY.
21:55:05 <arquebus> ok, I'll look that up
21:55:06 <jeffwheeler> It supports Cua (Windows-style) keymaps.
21:55:15 * bitrot thinks emacs is simple...
21:55:27 <Facedown> is emacs simple compard to vim?
21:55:30 <Facedown> i use vim
21:55:32 <vixey> it's a complicated program
21:55:33 <Facedown> always wondered about emacs
21:55:39 <vixey> it's simple to use it for simple things though
21:55:42 <jeffwheeler> arquebus: http://haskell.org/haskellwiki/Yi
21:55:43 <vixey> like .. editing text files
21:55:43 <lambdabot> Title: Yi - HaskellWiki
21:55:44 * bitrot also thinks other insane things are fun
21:55:52 <cjs> I'd probably have a look at Yi before emacs, if you're a fairly serious Haskeller.
21:56:06 <jeffwheeler> 0.4 just came out.
21:56:15 <vixey> does anybody actually use Yi?
21:56:23 <cjs> As for the modal stuff, well, Emacs has lots of modes, too.
21:56:46 <arquebus> jeffwheeler- I think Yi is only ported for BSD
21:56:58 <jeffwheeler> arquebus: It runs on Windows.
21:57:28 <jeffwheeler> (Check the mailing-list for some help on using 0.4 with Windows, though; you might run into some problems with VTY, if I remember correctly.)
21:59:40 <dogbite> so i'm still stuck on this read parse error.  i'm doing a maybeRead, but i'm getting an exception inside of it
21:59:52 <dogbite> _exception :: e = GHC.IOBase.IOException (GHC.IOBase.IOError Nothing
22:00:05 <dogbite> when i use the ghci debugger set to break on exceptions
22:00:18 <dogbite> i step back one and do a listing and the variable it's pointing at looks fine
22:01:18 <dmwit> ?hackage mtl
22:01:19 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mtl
22:04:48 <arquebus> thanks
22:06:58 <dogbite> i tried running the program from outside of ghci and got no error
22:07:48 <dogbite> is that... normal?  i feel like way back when i learned c++ and had no clue about seg faults
22:11:02 <dogbite> and now i run it in ghci and it doesn't crash
22:11:42 <dogbite> oh well.  .. thanks for letting me ramble, ha
22:14:41 <Trinithis> is there a way to convert an Int to Integer without (show . read)?
22:15:01 <bd_> Trinithis: fromIntegral
22:15:13 <Trinithis> k
22:15:26 <vixey> ...
22:15:52 <bd_> which ought to be signifigantly faster :)
22:16:00 <novas0x2a> h
22:16:31 <Trinithis> i bet
22:18:44 <hackage> Uploaded to hackage: hint 0.2.4
22:19:23 <ddarius> There you go gwern
22:19:34 <gaze__> http://haskell.pastebin.com/m4627e802 why is this broken?
22:20:58 <dmwit> gaze__: What error do you get?
22:21:07 <gaze__> just a ton of 7s
22:21:20 <dmwit> gaze__: Try s/==/<=/ ;-)
22:21:43 <dmwit> gaze__: You may also be interested in replicate.
22:21:47 <dmwit> > replicate 10 7
22:21:54 <lambdabot>  [7,7,7,7,7,7,7,7,7,7]
22:22:56 <gaze__> wtf? why would "i" go below zero?
22:23:13 <dmwit> If 'i' is less than the length of the list to begin with?
22:23:33 <dmwit> > replicate (-3) 7
22:23:34 <lambdabot>  []
22:24:02 <gaze__> well, it's supposed to pad an array to a length with something.
22:24:27 <dmwit> Yep, but if the list is longer than that length already, by the time you get to the [] case, i is already negative.
22:26:44 <dmwit> > let pad xs n = xs ++ replicate (n - length xs) 7 in pad [5, 10] 4
22:26:45 <lambdabot>  [5,10,7,7]
22:27:49 <gaze__> hrm... okay
22:27:50 <gaze__> thanks
22:30:11 <arquebus> if anyone is wondering, notepad++ is a simple free text editor that supports Haskell syntax. Just thought Id let all you know for future reference  http://notepad-plus.sourceforge.net/uk/site.htm
22:30:11 <lambdabot> Title: .:: NOTEPAD++ ::.
22:33:01 <mauke> dmwit: you could just inline the definitions
22:45:02 <dmwit> mauke: ...true
22:51:42 <dobblego> is there a Cofunctor for Id?
22:54:21 <rwbarton> is there a map (a -> b) -> (b -> a)?
22:54:29 <rwbarton> Or maybe I misunderstand you
22:54:36 <dobblego> no, I'm just thinking dumb
22:59:41 <geezusfreeek> ain't gonna happen
22:59:42 <geezusfreeek> @djinn (a -> b) -> (b -> a)
22:59:42 <lambdabot> -- f cannot be realized.
23:00:12 <|Steve|> No limit on joins?
23:03:33 <jberryman> in 'next' in System.Random, is the Int in the tuple returned used if you would rather pass around a seed than a generator?
23:04:02 <_zenon_> netsplit?
23:04:25 <mauke> :t next
23:04:25 <TSC> @type System.Random.next
23:04:29 <lambdabot> forall g. (RandomGen g) => g -> (Int, g)
23:04:29 <lambdabot> forall g. (RandomGen g) => g -> (Int, g)
23:04:29 <|Steve|> netsplits don't usually start with a mass join and end with a mass part.
23:04:41 <TSC> The "Int" is the random value
23:04:45 <_zenon_> Oh, I missed the mass join part
23:11:22 <olsner> hmm, the names in that mass join came from like three hosts, and the nick names seemed very random :D
23:17:52 <chrisdone> botnet?
23:29:27 <Trinithis> Is it possible to use a TH splice in a case expression? aka: case x of
23:29:27 <Trinithis>   $(ord ' ') -> ...
23:30:21 <Trinithis> where ord generates an Integer from a Char
23:30:42 <|Steve|> What does $(ord ' ') do?
23:31:09 <Trinithis> ord c = [| fromIntegral $ C.ord c |]
23:31:22 <Trinithis> ord c = [| fromIntegral $ Data.Char.ord c |]
23:31:46 <|Steve|> Okay, what do [| and |] do?
23:32:07 <Trinithis> Its for Template Haskell
23:32:16 <|Steve|> Ah.
23:33:50 <dons> this is interesting, http://www.cuil.com/
23:33:52 <lambdabot> Title: Cuil
23:34:01 <dons> a new search engine by some ex-googlers.
23:34:08 <rwbarton> Trinithis: I don't think you can splice in patterns
23:34:24 <rwbarton> Trinithis: but try changing [|...|] to [p|...|]
23:34:27 <Trinithis> drat. How inconveinient
23:34:28 <dons> oh, didn't find xmonad. :/ knows all about haskell
23:34:30 <Trinithis> oh
23:34:39 <Trinithis> lemme try .. just a sec
23:35:25 <dolio> Splicing patterns was a notable addition to the new quasiquoting stuff in 6.9, I think.
23:36:18 <rwbarton> Yes, I think you can do it using quasiquotation.  I don't know much about TH though
23:36:19 <Trinithis> Guess I'll look at GHC specs
23:36:25 <lament> "We didn‚Äôt find any results for ‚Äúshostakovich sheet music‚Äù"
23:36:29 <Trinithis> What is quasiquotation?
23:36:42 <sjanssen> dons: hmm, that is a bit disappointing
23:36:57 <sjanssen> dons: perhaps we need to put some effort into search engine optimization :)
23:38:03 <Spark> i can't find anything on cuil at all
23:38:10 <Spark> it appears to be rubbish
23:38:11 <rwbarton> just cuil for it
23:38:16 <lament> yeah, it doesn't seem to be working very well
23:38:31 <lament> maybe these guys were fired from google for a reason :P
23:38:35 <johnnowak> Trinithis: a way of splicing together quoted and unquoted expressions.
23:38:37 <Spark> search for cuil
23:38:48 <Trinithis> k
23:39:06 <johnnowak> Trinithis: `(x y ,z)  ==  (append '(x y) z)
23:39:07 <Spark> ou have enabled Safe Search. Cuil will filter pornography or other objectionable material from your search results. However, Cuil can‚Äôt guarantee that all objectionable material will be filtered out.
23:39:11 <Spark> that may be why
23:39:26 <lament> cuil search engine (no quotes) gives one result -> searchengine.com
23:39:28 <sjanssen> I'm a bit frightened that the auto-complete suggests my name
23:39:31 <Spark> nah makes no difference
23:39:32 <rwbarton> It didn't seem to filter much out when I cuiled for "monomorphism restriction"
23:39:36 <Trinithis> huh
23:39:49 <johnnowak> Trinithis: (that's a lisp example)
23:39:59 <johnnowak> that one wasn't though.
23:40:21 <Spark> the results layout is quite irriating too
23:40:25 <Spark> like the register
23:41:03 <chrisdone> I like that layout
23:41:43 <rwbarton> I don't like the fact that you can't see the whole URL
23:42:09 <lament> web 3.0 won't have visible URLs
23:42:25 <chrisdone> lament: haha, it's funny because it's true
23:42:28 <Spark> they'll all be tinyurls
23:42:41 <glguy> lament: are you writing the spec?
23:42:59 <lament> it won't have a spec, either :)
23:43:23 <Spark> better than having a spec that everyone ignores
23:43:42 <rwbarton> Trinithis: http://www.haskell.org/haskellwiki/Quasiquotation
23:43:42 <chrisdone> yeah, instead of http://haskell.org/, you use tags and type "haskell homepage"
23:43:43 <lambdabot> Title: Quasiquotation - HaskellWiki
23:43:43 <lambdabot> Title: Haskell - HaskellWiki
23:43:44 <lament> it will just have lots of pretty square boxes with smoothed corners
23:43:50 <rwbarton> Trinithis: Skip to the bottom to see what it lets you do
23:43:53 <lament> and advanced animated 3d typography
23:43:55 <Trinithis> rwbarton: ok thx
23:43:56 <glguy> Web 2.0 is already undefined .... Seems like 3.0 could do better
23:44:01 <Cale> Web 3.0 will have 6 websites which will be run by only the largest media conglomerates.
23:44:11 <rwbarton> Trinithis: Note, it's only in GHC 6.9
23:44:17 <lament> yeah, you will use google to find stuff on amazon
23:44:20 <chrisdone> Cale: and one of them hosts the others'
23:44:33 <dolio> Trinithis: Template Haskell is essentially quasiquotation of Haskell code (maybe a bit beyond that). The new stuff in 6.9 lets you add your own parsers and produce your own datatypes.
23:44:40 <dolio> And splice in patterns. :)
23:45:07 <johnnowak> the only way web 3.0 will end up with massive corporate consolidation is if that gets regulated into existence
23:45:21 <Trinithis> I just want to have a convenient way of pattern matching the Integer value of an ASCII character
23:46:53 <chrisdone> I wrote the Web 3.0 spec, just e-mail me and I'll send you a copy: <you need Javascript to view this e-mail address>
23:47:32 <dolio> I suppose the [| |] part of TH is the quasiquoting part. The $ is something else (except when it's used to anti-quote).
23:47:44 <Cale> Why does the quasiquoter syntax require that odd-looking $ in the *first* part of the bracket? Is there any specific meaning to that?
23:47:49 <Trinithis> is QQ more generic than TH?
23:48:01 <Cale> As in [$expr| 2 * 3 |]
23:48:30 <Cale> Trinithis: It's a new part of TH
23:48:31 <lament> To view the remainder of this conversation, your need to install Adobe(R) Flash(TM) into your brain. Proceed with the installation? (Y/y)
23:48:40 <dolio> I thought it was : Did they change it since the paper?
23:48:59 <chrisdone> lament: Downloading... installing... the installation did not succeed. [Finish]
23:49:11 <Cale> dolio: apparently
23:49:29 <dolio> You're right, though, I'm not sure I see the need.
23:49:30 <Cale> TH has enough superfluous $'s
23:49:59 <dolio> Unless it's because [t| |] and such would be ambiguous if there were a t in scope.
23:50:04 <dolio> But that's kind of a lame reason.
23:51:12 <Cale> TH seems overcomplicated. There must be some way to simplify it.
23:52:05 <johnnowak> time for an s-expression syntax for haskell.
23:52:07 <dolio> It should all be rose trees and strings. :)
23:52:29 <chrisdone> johnnowak: liskell?
23:53:21 <Cale> Yeah, preferably a way which doesn't compromise the syntax of the language :)
23:56:15 <dolio> For some reason, I like : better than $.
23:56:35 <johnnowak> not an objectivist?
23:57:01 <dolio> As in Ayn Rand?
23:57:06 <johnnowak> aye.
23:57:12 <dolio> Can't say that I am.
23:58:02 * _zenon_ just got his haskell simulation seconded by a client-fix ...... *sigh*
