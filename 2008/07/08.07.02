00:00:55 <kiris> is there a channel I can test lambdabot in without spamming people? its title plugin doesn't work in privmsg
00:05:02 <kiris> ah, it was 11 characters over the title length limit ~_~
00:06:02 <vixey> @seen lambdabot
00:06:02 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
00:09:31 <koninkje> kiris: depending on what you want to do, you can always /msg lambdabot
00:09:55 <kiris> begreg = mkRegexWithOpts "<title> *" -- oh dear. I'd've recommended <title[^>]*>
00:10:00 <kiris> koninkje: yeah, I found @url-title
00:10:46 <sjanssen> tagsoup might be a better choice nowadays
00:11:05 <kiris> I was thinking that
00:11:21 <kiris> http://www.haskell.org/ghc/docs/latest/html/libraries/regex-compat/Text-Regex.html
00:11:22 <lambdabot> http://tinyurl.com/2ub2m7
00:11:37 <kiris> I don't think it can get the title of that because <TITLE> is split onto two lines
00:12:47 <kiris> tagsoup is delicious
00:19:58 <sjanssen> fmap (innerText . getTagContent "title" (const True) . canonicalizeTags . parseTags) $ openURL "http://haskell.org"
00:19:59 <lambdabot> Title: Haskell - HaskellWiki
00:20:22 <kiris> ah, excellente`. loaded up the URL module in ghci no problem
00:21:29 <kiris> sjanssen: good stuff
00:22:01 <sjanssen> kiris: yep, except it doesn't handle failure gracefully at all
00:22:12 <sjanssen> it returns an exception if the page has no title
00:25:23 <kiris> Loading package tagsoup-0.6 ... linking ... <interactive>: /usr/local/lib/tagsoup-0.6/ghc-6.8.2/HStagsoup-0.6.o: unknown symbol `containerszm0zi1zi0zi1_DataziIntMap_zdslookupN_info'
00:25:33 <kiris> 7_7
00:30:04 <kiris> ah, good. recompiling tagsoup fixed that strange issue. I suppose it must've been out of date with my ghc version
00:31:07 <sjanssen> fmap (innerText . takeWhile (not . tagCloseLit "title") . dropWhile (not . tagOpenLit "title" (const True)) . canonicalizeTags . parseTags) $ openURL "http://www.haskell.org" -- fails more gracefully
00:31:08 <lambdabot> Title: Haskell - HaskellWiki
00:31:28 <osfameron> @index openURL
00:31:28 <lambdabot> bzzt
00:31:40 <sjanssen> osfameron: also from the tagsoup package
00:31:45 <osfameron> ah
00:31:46 <sjanssen> ndm++ tagsoup is nice
00:32:05 <osfameron> I thought tagsoup was a parser library, didn't realise it also did network stuff
00:32:18 <kiris> Text.HTML.Download does the download stuff
00:32:20 <kiris> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/tagsoup
00:32:23 <lambdabot> http://tinyurl.com/6yh7v4
00:32:41 <osfameron> ah, thanks
00:32:58 <kiris> it would be better to be based on Network.URI, perhaps. don't you think, sjanssen?
00:33:05 <sjanssen> kiris: are you actually implementing this?
00:33:11 <kiris> yeah
00:33:45 <sjanssen> I would stick with whatever lambdabot currently uses to download -- it has length limits in place
00:33:57 <kiris> I won't use TagSoup's openURL--yes
00:34:04 <sjanssen> just in case somebody drops a link to a very large file
00:34:10 <kiris> lambdabot has proxy support and so forth
00:34:22 <sjanssen> oh yes, that's right
00:34:33 <kiris>   3 -- TODO: How do I avoid threading the 'proxy' argument to the various
00:34:36 <kiris>   4 -- functions in here?
00:34:37 <kiris> state monad?
00:34:47 <vixey> reader monad
00:34:59 <sjanssen> isn't there a standard environment variable to hold proxy settings?
00:35:18 <sjanssen> anyway, lambdabot really shouldn't have an entire HTTP library built-in, but it does
00:35:20 <kiris> it's just passed around as a function parameter at the moment. let me see..
00:35:33 <vixey> that is what Reader does
00:35:43 <kiris> I know
00:36:20 <vixey> I somehow thought you were asking whether you should use the state monad
00:38:29 <kiris> sure, I was answering sjanssen. hmm, yes. there is some config which seems to be provided by Plugin
00:39:00 <kiris> I think they pass it to the other url module because that module is written such that it could be used indepdenant of Lambdabot
00:39:18 <sjanssen> kiris: yeah
00:39:44 <sjanssen> I was just hoping that there was a way to get the proxy configuration without touching anything lambdabot-specific
00:39:58 <kiris> ah, I see
00:40:04 <sjanssen> I mean, you don't have to make proxy settings in every application, do you?
00:40:11 <kiris> true
00:40:21 <sjanssen> I've never run with a web proxy, so I don't really know
00:40:22 <kiris> well, kind of, but you shouldn't have to.. heh
00:45:25 <glguy> Can someone with permissions to please @flush lambdabot?
00:45:33 <glguy> It is still using the state from over 1 month ago
00:45:54 <kiris> nice
00:47:19 <sjanssen> @flush
00:47:35 <sjanssen> glguy: I'm sure we've @flushed since then
00:48:06 <glguy> hmm, wonder what broke...
00:48:21 <mjrosenb> does anyone know of a haskell implementation of an mp3 decoder?
00:48:29 <sjanssen> lambdabot is always broken
00:48:45 <sjanssen> glguy: how can you tell it is using month old state?
00:49:05 <glguy> it sends me a @tell that I've reread over and over
00:49:15 <glguy> each time it is restarted
00:49:19 <sjanssen> ah, that sucks
00:49:25 <sjanssen> @flush
00:49:28 <sjanssen> for good measure
00:49:36 <glguy> yeah.... now I'll get it twice
00:50:03 <sjanssen> @flush
00:50:04 <sjanssen> @flush
00:50:06 <sjanssen> @flush
00:50:23 <glguy> it's broken... so now I'll get it 4.6 times
00:51:05 <sjanssen> @vixen what do you think is wrong with your state persistence?
00:51:06 <lambdabot> let's don't talk about that
00:51:14 <sjanssen> there you have it, folks
00:52:01 <kiris> let's don't talk about that indeed
00:53:28 <kiris> wow, I did not know that was possible
00:53:39 <kiris>      | Just uri <- parseURI url  = do
00:54:03 <sjanssen> kiris: it is an extension called pattern guards
00:54:06 <yitz> mjrosen: dons wrote an mp3 player, it's on hackage. I don't know if it does its own decoding though.
00:54:13 <kiris> sjanssen: brilliant!
00:54:28 <kiris> I have actually wanted to write that once or twice
00:54:29 <yitz> mjrosenb: ^
00:54:52 <sjanssen> yitz: it calls to mpg123, IIRC
00:54:57 <mjrosenb> yitz: that's a frontend to mpeg123/321
00:55:17 <Japsu> @pl let f x = x >>= f x in f
00:55:17 <lambdabot> fix (ap (>>=))
00:55:19 <mjrosenb> afaik, decoded data never touches haskell code
00:55:35 <Japsu> @src ap
00:55:35 <lambdabot> ap = liftM2 id
00:57:50 <_zenon_> ?ty (liftM2 id)
00:57:51 <lambdabot> forall a2 r (m :: * -> *). (Monad m) => m (a2 -> r) -> m a2 -> m r
00:58:08 <kiris> @help ty
00:58:09 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
01:06:03 <kiris> do you guys always declare your types at the top of files?
01:06:15 <kiris> even if they are only used half way down?
01:06:33 <quicksilver> generally yes, kiris
01:06:36 <quicksilver> not universally
01:06:42 <mjrosenb> kiris: usually
01:06:46 <quicksilver> especially if they are conceptualy "local" types
01:06:52 <quicksilver> which only apply to a small fragment of code
01:06:58 <quicksilver> I might keep them loca.
01:06:59 <quicksilver> local.
01:07:12 <mjrosenb> quicksilver: does haskell support locally scoped type definitions?
01:07:14 <kiris> hm, I see
01:10:02 <quicksilver> mjrosenb: no
01:10:14 <quicksilver> mjrosenb: well, the only scope is module scope.
01:10:32 <quicksilver> mjrosenb: but I, as a personal convention, will put a locally-used data type close to the functions that use it.
01:10:53 * mjrosenb misses local ... in ... end
01:10:59 <quicksilver> it's certainly a nice idea to have locally scoped data types
01:11:13 <mjrosenb> quicksilver: it can be messed up
01:11:19 <mjrosenb> sml/nj does
01:11:23 <quicksilver> although in practice I often find that stuff I thought was local turns out to be more useful that I imagined.
01:11:33 <quicksilver> and I end up wanting to use it elsewhere.
01:12:46 <mjrosenb> - let type 'a foo = int in 5 : (int foo) list foo end
01:12:58 <mjrosenb> sml/nj says
01:13:00 <mjrosenb> val it = 5 : int int list int
01:16:32 <quicksilver> well that's just daft :)
01:16:38 <quicksilver> GHC does better than that.
01:16:45 <quicksilver> GHC already has out-of-scope types from the module system.
01:17:08 <Mitar> is there any build in function which takes two arguments and produces a pair?
01:17:19 <kiris> (,)
01:17:25 <kiris> > (,) 1 2
01:17:26 <lambdabot>  (1,2)
01:17:29 <Mitar> nice :-)
01:17:45 <kiris> :D
01:17:49 <quicksilver> @pl \x y -> (x,y)
01:17:49 <lambdabot> (,)
01:19:08 <Mitar> this bot is smart :-)
01:20:19 <Mitar> ok, this is not want i want ... I am maping a list with a function which produces a pair of (list element, func $ list element)
01:21:04 <Mitar> i would like to get rid of that in a function, so that I would move this logic to the level of map ... so that i would only have a normal function which process an element, but map would add this element in the pair ...
01:21:13 <ejt> zip
01:21:16 <Mitar> zip would probably do ...
01:21:26 <Mitar> yes ... but is it not ugly to use the same list twice?
01:21:36 <Mitar> zip list (map func list)
01:21:57 <osfameron> zipWith (\a -> (a, func c)) list   ?
01:22:09 <osfameron> er... func a even
01:22:11 <Mitar> nice :)
01:22:23 <hesselink> Mitar: why not [(el, func el) | el <- list]
01:22:25 <ejt> @pl \fn xs -> zip xs (map fn xs)
01:22:25 <lambdabot> ap zip . map
01:22:32 <osfameron> @pl \a -> (a, func a)
01:22:33 <lambdabot> ap (,) func
01:22:43 <kiris> hesselink: lovely jubbly
01:24:22 <osfameron> heh, comprehension syntax really is compact.  Still scares me though :-)
01:24:48 <hesselink> I always forget to use it, but it looks so clear to me once I have it
01:24:54 <kiris> aye
01:25:42 <ejt> does lambdabot still have djinn built in ?
01:25:49 <quicksilver> (id &&& func) is one way to write \a -> (a, func a)
01:26:13 <Mitar> yes, but then I need to specify a name for argument in a function if I use comprehension (to name list)
01:26:27 <Mitar> bla = zipWith (\a -> (a, func a)) is much nicer?
01:26:44 <osfameron> er, actually that should be map in fact, rather than zipWith
01:26:46 <hesselink> ah yes, if you don't have the list
01:27:02 <Mitar> true ...
01:27:07 <vixey> ?djinn a
01:27:08 <lambdabot> -- f cannot be realized.
01:27:16 <Mitar> so how would be that without lambda?
01:27:17 <kiris> (\l -> [(el, func el) | el <- l]), I suppose
01:27:46 <kiris> pity you can't write [(el, func el) | el <- ... ] or something to make it into a function >_>
01:27:54 <osfameron> Mitar: as quicksilver said, something like:  map (id &&& func) list
01:28:09 <Mitar> this is really readable :-)))
01:28:10 <vixey> everything is lambda whether you see it or not
01:28:20 <Mitar> vixey: true :-)
01:28:48 <kiris> "I know lambda-fu"
01:34:42 <kiris> > (>>= \e -> return (e,func e)) [1,2,3] where func = id
01:34:43 <lambdabot>  Parse error at "where" (column 39)
01:34:51 <kiris> > (>>= \e -> return (e,id e)) [1,2,3]
01:34:54 <lambdabot>  [(1,1),(2,2),(3,3)]
01:34:56 <kiris> hur hur
01:35:51 <vixey> > map (join (,)) [1..3]
01:35:52 <lambdabot>  [(1,1),(2,2),(3,3)]
01:38:10 <funktio> @pl \xs -> zipWith (+) (zipWith max xs (tail xs))
01:38:11 <lambdabot> zipWith (+) . ap (zipWith max) tail
01:38:26 <_zenon_> vixey: All function applications and functions are lambda
01:38:30 <kiris> :t xs
01:38:31 <lambdabot> Not in scope: `xs'
01:38:43 <_zenon_> vixey: Tuples, list and so are per say not lambda
01:38:46 <kiris> is `xs' this reflective thing?
01:39:10 <quicksilver> _zenon_: they could be in, say, a church encoding.
01:39:15 <quicksilver> kiris: it was a local variable
01:39:23 <quicksilver> kiris: bound by the lambda \xs ->
01:39:29 <kiris> oh, whoops
01:39:51 <_zenon_> quicksilver: they could, but they are not.
01:40:15 <vixey> _zenon_: They are :)
01:41:06 <kiris> @src (,)
01:41:06 <lambdabot> Source not found. The more you drive -- the dumber you get.
01:41:08 <quicksilver> _zenon_: they might be. THe compiler might compile by church encoding.
01:41:13 <quicksilver> supero does, IIRC.
01:41:31 <quicksilver> that's a compilation choice and quite compatible with haskell's semantics.
01:41:33 <vixey> what the compiler does isn't as important as your own conceptual framework
01:41:47 <quicksilver> what the compiler *might* do is quite interesting though.
01:41:55 <quicksilver> it sets boundaries on your conceptual framework.
01:43:00 <_zenon_> http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/TypeType
01:43:02 <lambdabot> Title: Commentary/Compiler/TypeType - GHC - Trac, http://tinyurl.com/2eztx4
01:48:48 <kiris> > map (join (flip (,).(+1))) [1..3]
01:48:50 <lambdabot>  [(1,2),(2,3),(3,4)]
01:49:51 <_zenon_> arguing whether the compiler represents everything in lambda notation , only  on the haskell #.  could be a topic line :)
01:50:36 <quicksilver> _zenon_: I know what GHC does. I was just talking about what a haskell compiler might do.
01:50:56 <_zenon_> quicksilver: Okay, theoretically speaking,
01:51:02 <_zenon_> sure, would be nice,
01:51:09 <hpaste>  dolio pasted "Too much boxing?" at http://hpaste.org/8666
01:51:12 <_zenon_> in a kind of CS-porn of way
01:54:22 <hesselink> :r
01:54:36 <mm_freak_work> :o
01:54:55 <hesselink> whoops
01:55:00 <mm_freak_work> :t
01:55:03 <mm_freak_work> :f
01:55:05 <mm_freak_work> :l
01:55:35 <kiris> λ_λ
01:56:04 <mmorrow> i just finished some code to derive Show for GADTs, until i clean it up and hackage it i made a little cgi frontend: http://morrow.jypsis.com/cgi-bin/gadtshow.cgi
01:56:14 <mmorrow> pretty fun
01:56:46 <dolio> What's it use?
01:57:42 <mmorrow> to derive show for GADT defs, then paste the derived code in your module so you can avoid the tedium of writing show instances :)
01:58:01 <vixey> that's cool
01:58:21 <ejt> useful, well done
01:58:27 <mmorrow> i've tested it for only a few gadt, but it seems to work
01:58:32 <mmorrow> ejt: :)
01:58:33 <dolio> Oh, so it's not using derive or drift or anything like that.
01:58:40 <mmorrow> oh no
01:59:15 <mmorrow> it parses the code to haskell-src-exts ast, extract the gadt decls, then derives show for each one
01:59:37 <mmorrow> i modelled how i derive show after how it's done in derive
02:00:08 <dolio> I suppose derive and drift may not support GADTs anyway.
02:00:12 <mmorrow> (hence the output code resemblance)
02:00:20 <mmorrow> dolio: yeah, they dont
02:00:31 <mmorrow> because template haskell's AST doesnt
02:00:53 <mmorrow> (well, i'm not sure if drift uses th...)
02:06:24 <dolio> Woo, finally got my clustered heapsort allocating at non-obscene levels.
02:06:58 <mmorrow> heh, allocation obscenity
02:08:00 <mjrosenb> @hoogle (monad m) => m a -> m b -> m (a,b)
02:08:01 <lambdabot> Prelude.asTypeOf :: a -> a -> a
02:08:01 <lambdabot> Prelude.const :: a -> b -> a
02:08:01 <lambdabot> Prelude.seq :: a -> b -> b
02:08:37 <yitz> @type liftM2 (,)
02:08:38 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
02:08:46 <mjrosenb> gah... djinn needs more bindings for good type-> function to be forribly useful
02:08:51 <mjrosenb> yitz: thank you
02:09:24 <mjrosenb> oh, lamdabot gives the explicit type for m, interesting
02:20:27 <quicksilver> mjrosenb: "kind"
02:21:11 <mjrosenb> quicksilver: yeah... i was thinking that, but for whatever reason didn't say it
02:21:31 <mjrosenb> at least haskell doesn't support the full kinding calculus.
02:22:02 <quicksilver> haskell has a very simple kind system, and technically has no syntax for it.
02:22:13 <quicksilver> GHC adds syntax for it for clarity.
02:22:21 <quicksilver> GHC also adds some wacky kinds.
02:23:49 <mjrosenb> such as?
02:25:25 <vixey> @src Int
02:25:26 <lambdabot> data Int = I# Int#
02:25:30 <vixey> :k Int
02:25:31 <lambdabot> *
02:25:35 <vixey> :k I#
02:25:35 <lambdabot> Not in scope: type constructor or class `I#'
02:25:39 <vixey> :k Int#
02:25:40 <lambdabot> Not in scope: type constructor or class `Int#'
02:26:56 <Mitar> i have code like this:
02:26:56 <Mitar>         when (oldX == newX && oldY == newY) $ return () -- nothing changed
02:26:56 <Mitar>         print (oldX, newX, oldY, newY, oldX == newX && oldY == newY)
02:27:06 <Mitar> which outputs:
02:27:07 <Mitar> (178,178,122,122,True)
02:27:11 <Mitar> how is this possible?
02:27:19 <Mitar> how can be True and go over return?
02:27:34 <vixey> Mitar: I guess you've programmed with C or Java or suchlike before?
02:27:39 <Mitar> yes :-)
02:27:48 <vixey> Mitar: return in haskell is not Java or C's return
02:28:08 <Mitar> ok, so how can i finish executing actions in a do block?
02:28:42 <vixey> use unless instead of when
02:29:40 <ejt> (and put the print ... after the unless)
02:32:56 <Mitar> hmm, example?
02:33:25 <ejt> Mitar: you might understand it more if you start with an old fashioned 'if'
02:33:52 <vixey> :t unless
02:33:53 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
02:33:56 <ejt> (if oldX == newX etc) then return () else do { print ... }
02:34:02 * osfameron would like to rename 'return' to 'unit'
02:34:02 <vixey> unless condition action
02:35:21 <kiris> @src unless
02:35:21 <lambdabot> unless p s = if p then return () else s
02:36:29 <codacola> hm
02:36:31 <kiris> I thought it might be `unless p = when (not p)'
02:36:36 <kiris> @src when
02:36:36 * codacola still isnt up to the chapter on monads yet
02:36:36 <lambdabot> when p s = if p then s else return ()
02:37:34 <codacola> havent seen the where keyword either yet
02:38:04 <quicksilver> osfameron: I would prefer 'skip'
02:38:09 <quicksilver> osfameron: unit has other implications.
02:38:36 <codacola> oh yes i have
02:38:40 <ejt> I'd prefer 'wrap'
02:38:44 <codacola> havent seen the "when" keyword yet
02:38:46 <Vq^> what about pure or embed?
02:38:54 <kiris> it's not a keyword, codacola, it is a function
02:38:55 <shachaf> codacola: It's not a keyword.
02:38:55 <osfameron> quicksilver: 'skip'?
02:38:57 <kiris> :t when
02:38:58 <dibblego> putItInASpaceSuit
02:38:58 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
02:39:03 <codacola> oh
02:39:03 <codacola> sorry
02:39:12 <dibblego> @src when
02:39:12 <lambdabot> when p s = if p then s else return ()
02:39:13 <ejt> Vq^: pure's good
02:39:25 <dibblego> @type pure
02:39:26 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
02:39:26 <osfameron> osfameron: 'wrap' I understand.  That might be clearer than 'unit' too?  Don't get 'skip' at all right now
02:39:32 <dibblego> woot! (pure = return)
02:39:41 <codacola> working my way through a chapter on folding
02:39:41 <kiris> codacola: lazy evluation enables you to write constrol constructs that rely on conditional evaluation, so lots of functions appear like keywords in other languages
02:40:29 <kiris> er, control
02:41:09 <codacola> curious, is functional programming actually getting more common in the "real world"?
02:41:28 <Vq^> maybe Monad, Applicative and Arrow should take return/pure from some common typeclass
02:41:34 <kiris> that depends how you measure it
02:41:44 <dibblego> Vq^, agreed (that's how I wrote it in Scala)
02:41:47 <Vq^> or is there some monad or arrow that shouldn't support return/arr?
02:42:19 <ejt> it wouldn't be a monad if it didn't support it
02:44:09 <quicksilver> osfameron: skip is a traditionally term for the imperative command which does nothing.
02:44:13 <mattam> Vq^: edwardk introduced the notion of Pointed functor for that (and Copointed as well).
02:44:24 <mattam> @scr Pointed
02:44:24 <lambdabot> Maybe you meant: arr rc src
02:44:25 <quicksilver> osfameron: e.g., in C, if (foo) {} else {}
02:44:29 <mattam> @src Pointed
02:44:29 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
02:44:45 <quicksilver> osfameron: if your language syntax doesn't permit 'empty block' like {}, the traditional name for {} is 'skip'
02:44:49 <mattam> Wee, it's in category-extras
02:45:13 <quicksilver> osfameron: oh, but I believe I completely misread your comment :)
02:45:15 <quicksilver> apologies.
02:45:21 <osfameron> ah, ok :-)
02:45:31 <quicksilver> I thought you said you'd renamed "return ()" to "unit".
02:45:38 <quicksilver> not "return" to "unit".
02:45:41 <quicksilver> ;)
02:45:53 <quicksilver> "return ()" should be called "skip".
02:46:05 <quicksilver> "unit" and "wrap" are both possible names for "return", I agree.
02:46:27 * quicksilver wishes the channel cabal had not chosen to disable color codes here.
02:47:32 <mattam> It's "point" in Pointed and "extract" in Copointed.
02:47:48 <kiris> quicksilver: so you could distinguish code from chatter in your messsages?
02:47:56 <quicksilver> kiris: exactly.
02:48:04 <kiris> me too
02:48:07 <quicksilver> kiris: would be nice to distinguish metasyntax and syntax.
02:48:14 <quicksilver> or, occasionally, type variables from value variables.
02:48:40 <kiris> indeed
02:52:45 <yitz> quicksilver: some have suggest naming "return ()" as "don't"
02:54:30 <quicksilver> yitz: ;)
02:54:56 <quicksilver> I go through occasional phases of using names with apostrophes in.
02:56:51 <flux> IMO apostrophes fit names like x'lo, x'hi etc
02:57:15 <osfameron> shouldn't you be using a dictionary type instead if you're doing that
02:57:19 <quicksilver> in one phase I used them as a kind of local module system.
02:58:29 <mux> d'oh is such a nice identifier name to have
03:03:10 <yitz> Then there are functions like "isn'tPrefixOf"
03:03:36 <yitz> or "quicksilver'sAlgorithm"
03:04:23 <mux> heh
03:05:08 <mapreduce> greatMisusedApostrophe'sSpreadToCode
03:05:26 <quicksilver> carrot'sForSale
03:05:36 <mapreduce> Is he?
03:05:45 <Mr_Awesome> who is carrot?
03:05:56 <mapreduce> Jasper Carrot, a comedian.
03:05:57 <kiris> ho ho ho
03:06:05 <Mr_Awesome> aha
03:06:09 <quicksilver> don't be daft.
03:06:12 <quicksilver> that would have been
03:06:15 <quicksilver> Carrot'sForSale
03:06:17 <quicksilver> obviously.
03:07:02 <masak> you guys have quirky humour :)
03:07:10 <mapreduce> Although I personally shun the notion of purchasing humans.
03:11:18 <quicksilver> quirky humour is the refuge of the bored.
03:11:20 <quicksilver> much like IRC.
03:13:35 * codacola would have thought all entertainment was
03:13:40 <codacola> including code :P
03:33:31 <Dae_> hi.. anyone know anything much about stream arrays (aka uvector)?
03:45:13 <Dae_> I take that as a "no"
03:45:16 <thoughtpolice> Dae_: as in their implementation?
03:47:34 <pjdelport> Dae_: it will probably help to ask a specific question :)
03:47:36 <Dae_> thoughtpolice: as in their use..... They don't have an API, they don't implement IArray, and I'm not even sure you can access them in constant time. I have a project that's highly dependent on array speeds, and I can't figure out if reimplementing it with uvectors would help
03:48:19 <Dae_> pjdelport: Ohh...right... sorry... Old java habbit. "Be vague"
03:49:01 <yitz> Dae_: what's the problem with UArray?
03:50:03 <hpaste>  Dae_ pasted "qr loop" at http://hpaste.org/8667
03:50:26 <Dae_> yitz: Incremental updates ;)
03:50:46 <thoughtpolice> Dae_: the API docs are currently broken
03:51:09 <thoughtpolice> because haddock can't quite parse them yet (it fails with an undefined error, iirc)
03:51:35 <Dae_> ok, well I'll have to do with the source then
03:51:37 <thoughtpolice> (reason being, uvector is derived directly from the NDP project, and it comes from that)
03:51:44 <thoughtpolice> Dae_: all you should really need,
03:51:50 <thoughtpolice> should be described in Data.Array.Vector
03:52:08 <thoughtpolice> it exports pretty much all the functions you need, and if you're familiar with, say, Data.List, you should find no immediate problems
03:52:51 <thoughtpolice> the only thing you might run into is certain functions (see: unfoldU) require an extra parameter which is the stack size but that's about it
03:53:01 <thoughtpolice> regardless you can get some very nice speed improvements with uvector :)
03:53:19 <hpaste>  Mr.Elendig pasted "xmonad.hs" at http://hpaste.org/8668
03:54:23 <Dae_> thoughtpolice: but only if I'm able to define the array in a single go, right? I couldn't define it in a fold for instance?
03:55:05 <thoughtpolice> Dae_: not sure I follow your question
03:55:33 <yitz> Dae_: this new vector stuff does look nice. I think you could do fine with STUArray though.
03:56:57 <Dae_> http://hpaste.org/8667 <- this. q and r are defined in a fold loop that (i hope) the compiler might be able to redo without copying the same array a gazillion times.
03:57:34 <Dae_> yitz: yeah, I know... it's just that... well MArrays have a horrible horrible syntax.
03:58:03 <quicksilver> Dae_: there are precisely zero circumstances in which GHC will use mutation to implement an immutable type.
03:58:10 <quicksilver> it doesn't matter as much as most people expect.
03:58:16 <Dae_> Right now it's fairly nice and smooth. I may have to redo it with ST, but....
04:00:00 <Dae_> quicksilver: actually the real problem is that it uses a ton of memory.
04:00:37 <Dae_> quicksilver: and I know it doesn't do it with normal arrays, but I thought perhaps it would be able to fuse it with uvectors
04:02:47 <quicksilver> fusion is the complete elimination of intermediate values
04:02:57 <quicksilver> not the reuse of old space by new values
04:03:04 <quicksilver> obviously they have similar goals ;)
04:06:07 <Dae_> hmm yeah ok...  so no go. So it's ST for me... I wonder if it's easier to just teach ghc how to fold arrays?
04:06:46 <vininim> :t fix
04:06:47 <lambdabot> forall a. (a -> a) -> a
04:07:17 <vininim> @let hungry = fix \ f x -> f
04:07:17 <lambdabot>  Parse error
04:07:37 <vininim> >let hungry = fix \ f x -> f in hungry 1
04:07:44 <quicksilver> Dae_: the code you pasted doesn't appear to constrain the array type.
04:08:01 <quicksilver> Dae_: does it help if you explicitly choose something efficient like UArray i Int ?
04:08:09 <vininim> :t fix \ f x -> f
04:08:10 <lambdabot> parse error on input `\'
04:08:39 <Dae_> quicksilver: it does, it has type Array (Int,Int) Double -> (Array (Int,Int) Double,Array(Int,Int) Double)
04:08:49 <quicksilver> Dae_: any improvement using UArray?
04:08:50 <kriomant> what is the better way to convert Word8 to Word32, than "fromInteger (toInteger word8) :: Word32"?
04:09:00 <quicksilver> kriomant: fromIntegral
04:09:04 <Dae_> quicksilver: actually it seemed to go slower when I used Uarrays?
04:09:12 <quicksilver> kriomant: (which is just defined as fromInteger . toInteger)
04:09:15 <quicksilver> Dae_: interesting.
04:09:19 <vininim> :t fix (\ f x -> f)
04:09:21 <lambdabot>     Occurs check: cannot construct the infinite type: t = t1 -> t
04:09:21 <lambdabot>     Probable cause: `f' is applied to too few arguments
04:09:21 <lambdabot>     In the expression: f
04:09:23 <quicksilver> quite surprised by that.
04:09:32 <vininim> D:
04:09:58 <vininim> @hoogle fix
04:09:58 <lambdabot> Data.Function.fix :: (a -> a) -> a
04:09:58 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
04:09:58 <lambdabot> Control.Monad.Fix :: module
04:10:01 <Dae_> quicksilver: but that might be some of the other algorithms in there. I haven't tested that on exclusively. It's part of a framework for doing quantum mechanics, so....
04:11:22 <quicksilver> performance of code is always rather suck-it-and-see
04:12:24 <Dae_> quicksilver: yeah, seems like it... is there a good technique for reducing memory usage btw? ust profile and try to fix it then?
04:12:38 <shapr> fusion?
04:13:24 * Dae_ wonders if quicksilver is the major deity of haskell, or just the foremost prophet
04:13:37 <sioraiocht> @src fix
04:13:38 <lambdabot> fix f = let x = f x in x
04:13:57 <quicksilver> many people were surprised by the tests that showed that GC is faster than manual memory management.
04:13:59 <Dae_> shapr: yeah...well.... most of the memory leaking is from intermediate values according to ghc....
04:14:16 <quicksilver> cache coherency and locality often give surprising effects.
04:14:23 <quicksilver> and to be fair, GHC is not great for locality.
04:14:29 <quicksilver> Dae_: I'm just a noisy prophet.
04:14:35 <quicksilver> particularly noisy, some would say.
04:14:49 <Dae_> heh, always helpful though
04:15:09 <ziman> :t liftM2 (||) isDigit isAlpha
04:15:10 <lambdabot> Char -> Bool
04:16:13 <Dae_> quicksilver: I was surprised as well... it seems like a lot of languages are getting good GC's though. I mean look at Eiffel
04:16:57 <quicksilver> cache issues will all be reinvented as we move to massively parallel machines, too.
04:17:12 <quicksilver> and presumably to asymmetric memory architecures.
04:17:16 <cjs> How does one wait for completion of a thread one has spawned with forkIO()?
04:17:16 <shapr> Haskell could handle a cache incoherent system just fine.
04:17:17 <quicksilver> speling--
04:17:27 <quicksilver> cjs: make it write to an MVar ()
04:17:28 <Botje> @hoogle wait
04:17:29 <lambdabot> System.Process.waitForProcess :: ProcessHandle -> IO ExitCode
04:17:29 <lambdabot> Control.Concurrent.QSem.waitQSem :: QSem -> IO ()
04:17:29 <lambdabot> Control.Concurrent.QSemN.waitQSemN :: QSemN -> Int -> IO ()
04:17:35 <Botje> ah, not that, then :)
04:17:46 <quicksilver> cjs: this is a rather common idiom and occasionally I think of wrapping it up.
04:18:29 <cjs> Huh. I see.
04:18:51 <cjs> Is there a reason there's no waitForThread or something like that? Just not considered necessary, since you can do it with MVars?
04:19:35 <quicksilver> exactly.
04:19:44 <quicksilver> what I meant by 'wrapping it up' is writing that.
04:20:14 <quicksilver> the point about MVars is they are a simple primitive which enables a wide range of behaviour and are easy to reason about.
04:20:27 <quicksilver> it's certainly not intended that you don't build higher-order constructs out of them.
04:20:52 <quicksilver> indeed, most of the pieces in the haskell toolkit are intended to be used by building higher-order constructs out of them, that's what haskell is good at.
04:21:02 * quicksilver blanches at the double-negatives and trailing prepositions.
04:26:06 <osfameron> hide the grammar, there are children about!
04:30:17 <Dae_> mm.rules for ghc are just put in the source code, right?
04:31:52 <int-e> Dae_: Yes. See http://www.haskell.org/ghc/docs/latest/html/users_guide/rewrite-rules.html
04:31:52 <lambdabot> Title: 8.13. Rewrite rules, http://tinyurl.com/y7rk9g
04:32:15 <Dae_> int-e: thanks :)
04:32:42 <yitz> quicksilver: asymmetric memory architectures - yes I believe  that is inevitable, and it will change everything
04:34:45 <ziman> assymetric in the sense that reads will be more efficient than writes (or vice versa)?
04:35:05 <quicksilver> ziman: in the sense that each core does not have access to the same memory.
04:35:20 <quicksilver> or not in a neutral way at least
04:35:30 <opqdonut> NUMA
04:35:38 <opqdonut> non-uniform memory access
04:36:00 <ziman> i see
04:36:08 <quicksilver> we have it already, but it's transparent
04:36:11 <quicksilver> (core-local caches)
04:36:27 <quicksilver> there is one address space though and the CPU is in charge of cache faults.
04:37:19 <quicksilver> at some point it becomes more efficient to enable the programmer to decide/control
04:39:48 <ziman> will haskell deal with that for us? :)
04:39:58 <quicksilver> GHC might, yes.
04:40:04 <quicksilver> when the problem exists.
04:40:10 <quicksilver> hard to solve problems that don't exist yet.
04:40:27 <ziman> sure ;)
04:40:42 <ejt> do people mix MVars and TVars in their programs, or tend to stick to one style or the other ?
04:41:27 <quicksilver> I tend to use the simplest thing that works.
04:41:34 <quicksilver> I.e. TVars when I need "rollback" semantics
04:41:43 <quicksilver> MVars when I just need, well, simple mvars :)
04:43:37 <ejt> thx
04:43:43 <Dae_> odd...ghc keeps giving arse erros when I try using rules
04:45:48 <Dae_> even when I copy examples from the user guide :s
04:47:02 <Dae_> nevermind.... indention...
04:57:30 * Dae_ tries to find out if his rules are actually being triggered
05:03:01 * Dae_ is saved by google
05:03:17 * ejt is beginning to look forward to the ICFP contest
05:04:38 <RayNbow> the ICFP contest's date is terrible :P
05:05:03 <ejt> does it clash with something ?
05:05:07 * RayNbow got a few birthdays in a row that weekend :p
05:05:11 <ejt> heh
05:05:20 <RayNbow> including my own :p
05:05:37 <ejt> I'm not sure I'll do a coding blitz this year, instead work through the problem over a couple of weeks
05:06:05 <ejt> I found last years a lot of work for a 1 man team
05:06:21 <RayNbow> I'll take a look at the problem anyway, might be a nice exercise :)
05:06:34 <therp> I'm just about to assemble a team for ICFP..however the date is the problem
05:18:39 <Rebooted> is there a way of providing an instance for Arbitrary String in Quickcheck, even though Arbitrary [a] is already given?
05:18:58 <Rebooted> i've tried using overlapping instances, which compiles, but gives a runtime error
05:19:30 <povman> Rebooted: can you use newtype MyString = MyString String?
05:20:40 <Rebooted> povman: i could do that, i was just wondering if there was another way since i'd be making that change to the code purely so it can be tested
05:22:33 <povman> if you need to test it differently, then perhaps it wouldn't be terrible to make a new type for it?
05:24:37 <ejt> Rebooted: I use new types a lot with quickCheck, mainly when I want a different distribution of generated values
05:25:23 <Rebooted> it wouldn't be a problem to use newtype
05:25:25 <povman> Rebooted: what i'm saying is that String might not be an expressive enough type for what you're using it for, if you can't test it as a String
05:27:48 <Rebooted> povman: possibly, i do have some requirements on the string.. that it should be non empty for example
05:28:10 <Rebooted> but newtype won't help me enforce those, i'm not going to be hiding the constructor
05:28:31 <Rebooted> i'm more confused about why overlapping instances doesn't let me give an instance for string
05:28:59 <Rebooted> are overlapping instances generally seen as best avoided (i'd only be using them in the test suite, not main code anyway)
05:29:22 <EvilTerran> Rebooted, overlapping instances are only ok if the instance can be unambiguously chosen eventually, i think
05:29:29 <EvilTerran> otherwise it's incoherent instances, which is bad
05:29:32 <quicksilver> best avoided unless you understand the resolution algorithm
05:29:35 <quicksilver> ;)
05:29:38 <EvilTerran> that too
05:29:49 <quicksilver> arguably quickcheck is buggy in only support Arbitrary
05:29:56 <lilachaze> Rebooted: looks like overlapping instances will probably be allowed in haskell', which is a reasonable indicator that they're not too bad
05:30:04 <quicksilver> in fact, arguably Arbitrary shouldn't be a typeclass at all
05:30:16 <quicksilver> but given that it is a typeclass, it should be overridable
05:30:26 <quicksilver> (you should be able to pass in a custom Gen when you want one)
05:30:41 <Rebooted> lilachaze: ok, thanks
05:31:08 <Rebooted> quicksilver: i think the problem is i don't understand the resolution algorithm :)
05:31:35 <quicksilver> typeclasses are a poor choice if you don't anticipate them being globally unique.
05:31:38 <Rebooted> i want to understand why an instance for String can't be selected over the instance for [a] though
05:31:51 <quicksilver> and since it's easy to imagine wanting Arbitrary not to be globally unique...
05:32:07 <quicksilver> Rebooted: breaks parametricity, it's quite unpleasant.
05:32:28 <quicksilver> suppose you had another function which just took a polymorphic parameter of type [a]
05:32:32 <quicksilver> and used this class on it.
05:32:36 <Rebooted> quicksilver: i agree wrt to typeclasses, i tend to avoid them anyway.. and i was doing, but i think if you want quickcheck to pass you data to your test cases you need to implement Arbitrarty
05:32:47 <quicksilver> of course it would choose the general instance, since all it has is [a]
05:33:04 <quicksilver> then imagine you happen to call that code from another module
05:33:09 <quicksilver> in the specific case of [Char]
05:33:18 <quicksilver> it's "too late" to select specific instance for [Char]
05:33:27 <quicksilver> it's already been picked as [a] when the function was compiled.
05:34:35 <Saizan_> ?type forAll
05:34:35 <quicksilver> parametricity is a nice thing. Quite how nice becomes clear when you try to break it.
05:34:36 <lambdabot> forall a b. (Testable b, Show a) => Gen a -> (a -> b) -> Property
05:34:45 <quicksilver> Saizan_: thank you.
05:34:50 <quicksilver> ^^ that's the answer then :)
05:35:04 <quicksilver> I thought it ought to be there, but I couldn't see it.
05:35:15 <Rebooted> quicksilver: i know what parametricity is, i didn't realise this would break it. it is a runtime error i'm getting though, not a compile time one
05:35:32 <gwern> @seen dcoutts
05:35:32 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
05:35:43 <gwern> preflex: seen dcoutts
05:35:43 <preflex>  dcoutts was last seen on #ghc 2 days, 13 hours, 1 minute and 37 seconds ago, saying: installing inplace doesn't feel like a good general solution
05:35:45 <dcoutts> @yarr!
05:35:45 <lambdabot> I'd like to drop me anchor in her lagoon
05:36:20 <gwern> dcoutts: I has some more link problems using cabal
05:36:26 <gwern> dcoutts: see darcs-cabalized. I can't get the bloody curl errors to go away
05:36:33 * gwern has tried all the tricks I know :(
05:36:54 <quicksilver> Rebooted: I was answering the general question about why it's undesirable to have a specific instance for [Char] in the place of a general instance for [a].
05:37:12 <quicksilver> Rebooted: when you turn on certain extensions, GHC defers some stuff to runtime.
05:37:19 <quicksilver> I don't know the details.
05:37:28 <quicksilver> I never use the foo-instances extensions.
05:38:05 <gwern> dcoutts: (darcs-cabalized is on hackage, in case I wasn't clear)
05:38:18 <Rebooted> quicksilver: ok, fair enough. i guess i'll just use newtype. i don't want to use those extensions really either, but i figured it didn't really matter in the testing code
05:38:20 <Rebooted> thanks
05:38:39 <lilachaze> Rebooted: either my memory sucks (probable) or the haskell' guys have changed their minds. the resolution on overlapping instances is currently "probably no"
05:38:48 <quicksilver> Rebooted: I don't think it does matter, as long as you understand how they work. Alas I am not the man who can explain them to you :)
05:40:26 <Rebooted> am i right that you need to provide an instance for Arbitrary if you want quickCheck to generate data for your test cases?
05:40:41 <quicksilver> I don't think so, no.
05:40:46 <quicksilver> Saizan_ pasted the other approach.
05:40:59 <quicksilver> the forall combinator lets you provide an explicit Gen in place of an Arbitrary instance.
05:41:40 <Rebooted> oh sorry Saizan_, i missed that
05:41:47 <Rebooted> i'll do that then
05:45:49 <dcoutts> gwern: hmm, should it really be using parsec-3 ?
05:45:50 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
05:46:35 <gwern> dcoutts: eh? I don't think it makes a difference, does it?
05:47:49 <dcoutts> gwern: in my experience anything that builds against parsec 3 fails because it generally expects parsec-2
05:48:08 <dcoutts> gwern: configure: error: Cannot find Control.Monad.Error; try installing package mtl?
05:48:35 <dcoutts> gwern: I suspect it's because I've got two packages that provide Control.Monad.Error
05:48:56 <dcoutts> gwern: mtl and mtl-tf
05:49:16 <gwern> dcoutts: that might be it. I doubt the m4 macro for testing compilation of mtl is expected to handle two providers of it
05:50:02 <dcoutts> gwern: still, that's an upstream bug (caused by not using Cabal)
05:50:43 <gwern> dcoutts: I have been seriously considering stripping out the autotools stuff, and hardwiring the CPP flags and extra-libraries...
05:50:55 <gwern> (it is painful integrating the two systems)
05:51:17 <gwern> dcoutts: actually, is one supposed to be able to have two different packages supplying the same module?
05:51:29 <dcoutts> gwern: sure
05:51:42 <dcoutts> gwern: you can't use them both at the same time of course
05:51:54 <gwern> but.. but how could ghc know which one you 'meant'?
05:52:49 <dcoutts> gwern: it doesn't. If you use ghci or --make without any -package flags then it complains.
05:53:10 <dcoutts> gwern: but if you're using cabal then it uses -hide-all-packages -package mtl and then there is no ambiguity.
05:54:26 * gwern wonders whether adding -hide-all-packages would fix the macros
05:57:46 <dcoutts> gwern: sure -hide-all-packages -package mtl
05:57:57 <gwern> dcoutts: so any idea what the curl link error is about? mentioning it in extra-libs doesn't make a difference, the CPP falgs are correctly set in darcs.buildinfo AFAIC, all the c sources and headers are included in the sdist, the relevant .c is mentioned in c-sources, there are no stale files to remove (like the darcs wiki says to do for that error), and so on
05:58:45 <dcoutts> gwern: I'm just building manually...
06:07:19 <dcoutts> gwern: I think there is confusion about the HAVE_CURL stuff
06:07:48 <dcoutts> gwern: HAVE_CURL is not defined while building src/hscurl.c afaiks
06:07:59 <dcoutts> but then we don't actually link with -lcurl
06:09:00 <gwern> but extra-libraries: curl would add -lcurl to the flags, and that didn't seem to help
06:09:44 <dcoutts> gwern: right, because the symbols are not from the curl C lib
06:09:54 <dcoutts> gwern: they're defined in src/hscurl.c
06:10:09 <dcoutts> but hscurl.o is empty, has no exported symbols
06:10:13 <dcoutts> because...
06:10:21 <dcoutts> $ head -n1 src/hscurl.c
06:10:21 <dcoutts> #ifdef HAVE_CURL
06:10:28 * gwern waits for the big reveal
06:10:44 <dcoutts> gwern: src/hscurl.c is conditionally empty depending on HAVE_CURL
06:10:58 <gwern> but - but darcs.buildinfo had -DHAVE_CURL in it
06:10:58 <gwern> how could it be empty then?
06:11:15 <dcoutts> gwern: it's not there
06:11:17 <gwern> unless... does it have to be darcs-cabalized.buildinfo?
06:11:20 <dcoutts> cc-options: -DPACKAGE_VERSION="2.0.2"
06:11:45 <gwern> could that be the issue? the autotools is correctly setting stuff in darcs.buildinfo, but cabal is snubbing it for having the wrong name
06:11:56 <dcoutts> gwern: it probably does need to be in darcs-cabalized.buildinfo and it must be in cc-options. cpp-options is for cpp'ing haskell code not C code.
06:13:02 <SamB> dcoutts: oh, confusing!
06:13:02 <gwern> -_-
06:13:09 * gwern feels a pain in the head
06:13:48 <dcoutts> SamB: what would you call them?
06:13:54 <SamB> maybe cpp-options should be options common to both, and haskell-cpp-options and c-cpp-options should be added?
06:13:59 <dcoutts> nooo
06:14:00 <dcoutts> not common
06:14:05 <SamB> for -Ds
06:14:09 <dcoutts> that way lies madness
06:14:17 <SamB> okay, fine
06:14:24 <SamB> remove cpp-options ;-P
06:14:46 <dcoutts> you end up with a big soup of defines and other junk
06:14:47 <gwern> I think we are well in the realm of rugose and nefandous blasphemies already by combinding build systems
06:15:29 <SamB> gwern: I think he doesn't want to encourage atrocities in more normal build systems
06:17:24 <gwern> ok, so I need to mv darcs.buildinfo and make cc-options take the CPP flags as well?
06:17:42 <dcoutts> gwern: probably
06:19:54 <dcoutts> gwern: yep, links for me now
06:20:03 <dcoutts> gwern: when I add -lcurl
06:20:21 <dcoutts> gwern: so really, each of those HAVE_FOO should be done by a flag foo
06:20:59 <dcoutts> gwern: oh and it seems that the .buildinfo does not have to be renamed
06:21:52 <dcoutts> gwern: another thing, it's clearer to factorise configuration stuff I think
06:21:57 <dcoutts> eg instead of: if flag(no_curses) { extra-libraries: z } else { extra-libraries: z, curses }
06:22:36 <dcoutts> use: extra-libraries: z; if flag(curses) { extra-libraries: curses }
06:22:40 <gwern> hm. I think that works
06:22:43 <gwern> it links now
06:23:06 <gwern> dcoutts: I think I tried that, but it didn't work then. I'll give it another shot
06:24:38 <Dybber> Isn't it a bug/problem that I can give a non-Int (i.e. it is to big) to a function only accepting Int's without ghci at least mentions it?
06:24:48 <Dybber> > let s x = (x::Int)*2 in s 2147483648
06:24:50 <lambdabot>  0
06:25:02 <mauke> > 9999999999999999999999 :: Int
06:25:04 <lambdabot>  -1304428545
06:25:08 <mauke> nothing to do with functions
06:25:14 <Dybber> When will that be usable?
06:25:27 <kpreid> Dybber: it's not a "non-Int", really
06:25:41 <kpreid> Dybber: types are not inherent in values
06:26:20 <kpreid> (not that a warning on overlarge literals wouldn't be nice)
06:26:48 <kpreid> I suppose adding bounds checking to fromInteger of Int would be not entirely crazy
06:30:07 <kpreid> but it's not a *bug*. the definition of Int is that it ...huh. I don't see where the H98 Report says that Int may silently wrap/overflow. anyone?
06:30:53 <kpreid> Ah.
06:30:57 <kpreid> "The results of exceptional conditions (such as overflow or underflow) on the fixed-precision numeric types are undefined; an implementation may choose error (_|_, semantically), a truncated value, or a special value such as infinity, indefinite, etc." (6.4)
06:32:53 <tomh> any UU people here?
06:33:54 <opqdonut> utrecht?
06:34:06 <chr1s> tomh: hi
06:34:24 <tomh> ye utrecht
06:34:27 <luite_> yeh
06:34:37 <tomh> any of you doing the master ST?
06:34:44 <luite_> nope master ACS
06:34:44 <chr1s> tomh: yes =)
06:34:57 <tomh> chr1s: how do you like it so far?
06:34:59 <opqdonut> (i'm not from UU, just checking)
06:35:05 <tomh> ok
06:35:06 <chr1s> tomh: it's seriously awesome.
06:35:18 <tomh> ye?
06:35:20 <carl> is haskells STM implementation suitabile for handling large data types such as a game state that needs to be accessed by multiple worker threads
06:35:29 <tomh> what was your previous school?
06:35:31 <chr1s> there's lots of Haskell, compiler methods, type systems, generic programming
06:35:56 <chr1s> tomh: also Utrecht, CS B.Sc.
06:36:08 <tomh> ok
06:36:22 <chr1s> tomh: the teachers are quite good, also.
06:36:28 <mm_freak_work> > length $ takeWhile (<1) [0.0, 0.1 ..]
06:36:29 <tomh> really?
06:36:30 <lambdabot>  11
06:36:33 <tomh> better than the bsc?
06:37:06 <chr1s> tomh: some of them also teach bachelor's courses, but at the Master level, they're great.
06:37:24 <tomh> im doing the bsc now
06:37:34 <tomh> need to pick my master very soon like now actually :)
06:37:34 <chr1s> tomh: did you do grammars & parsing?
06:37:38 <tomh> yes
06:37:44 <chr1s> tomh: did you like it?
06:37:55 <tomh> ye it was not bad
06:38:15 <tomh> the teacher there was only one of very few i actually found good
06:38:20 <tomh> bastiaan heeren or so
06:38:52 <chr1s> tomh: ah! yes, well, most of the master courses are thought with the same enthusiasm.
06:39:09 <tomh> ok sounds good
06:39:26 <chr1s> tomh: but I have to leave now, if you have any more questions, send me an e-mail
06:39:28 <hesselink> yes, do the ST master! :)
06:39:28 <tomh> because most other bsc courses are taught like they are getting shot if they dont teach them :P
06:39:38 <chr1s> cbeeidho@cs.uu
06:39:44 <tomh> ok cool
06:39:50 <chr1s> hahahaha, there's hesselink
06:40:07 <hesselink> always late to the party...
06:41:11 <carl> is haskells STM implementation suitabile for handling large data types such as a game state that needs to be accessed by multiple worker threads
06:41:21 <chr1s> tomh: I found AFP and TS the most interesting courses so far.
06:41:24 <chr1s> tomh: http://www.cs.uu.nl/docs/vakken/afp
06:41:31 <chr1s> tomh: http://www.cs.uu.nl/wiki/TS
06:41:47 <ejt> carl: probably, that's a bit of a vague question
06:42:29 <tomh> ok checking
06:43:06 <mar77a> woah this is weird
06:43:09 <mar77a> i don't have an ip address
06:43:13 <mar77a> yet i am sending this
06:43:24 <ejt> who said that ?!
06:43:26 <mar77a> i can't make any new connections
06:43:32 <mar77a> but the ones that are open work
06:43:42 <dmwit> Sounds like your DNS server is down.
06:43:44 <mar77a> nope
06:43:49 <tomh> hesselink: what year you in?
06:44:00 <hesselink> same as chr1s
06:44:03 <lilachaze> mar77a: i can ping scarecrow.u13.net. presumably you're nat'd?
06:44:03 <hesselink> first year of the ST master
06:44:16 <mar77a> it's just a bouncer
06:44:19 <luite_> any of you doing the PV course?
06:44:19 <mar77a> my router says
06:44:23 <mar77a> " IP Address:  0.0.0.0"
06:44:32 <mar77a> and i really can't open any connections
06:44:35 <mar77a> or get an IP address
06:44:47 <mar77a> must be the router bugged
06:44:52 <lilachaze> mar77a: makes some sense. your existing connections are probably routing via mac address
06:44:54 <hesselink> PV?
06:45:02 <mar77a> o_o
06:45:05 <luite_> hesselink: program verification
06:45:12 <luite_> by wishnu prasetya
06:45:17 <mar77a> i'm also downloading a torrent
06:45:19 <hesselink> ah, no, I didn't have the requisite
06:45:22 <mar77a> and it's going at 70 KBps
06:45:28 <tomh> you started in 2004 with your bsc too?
06:45:36 <luite_> hesselink: oh, I didn't either, but it was not really a problem
06:45:44 <mar77a> sweet now i got an ip
06:45:53 <mar77a> and the internets work
06:45:55 <mar77a> ha ha
06:46:13 <hesselink> luite_: also, I didn't want to miss either AFP or APA
06:46:20 <hesselink> tomh: me?
06:46:23 <tomh> ye
06:46:29 <hesselink> no, didn't do a bsc
06:46:35 <tomh> ok
06:46:41 <hesselink> I habe a masters in physics and chemistry, worked for a few years
06:46:45 <hesselink> and now ST master :)
06:46:48 <tomh> i see
06:47:07 <tomh> im still in doubt wether i should pick ST or MBI
06:47:55 <hesselink> tomh: depends on your interests, I guess
06:48:11 <hesselink> ST is about type systems, compilers, things like that
06:48:17 <tomh> well both are interesting, but both also do have some sucky courses i dont want
06:48:29 <hesselink> like what?
06:48:41 <carl> ejt: well all the examples i see are throwing an int or a simple tuple into the TVar, what im trying to ask is it efficient to use it with much larger data structures
06:48:49 <luite_> I'm not sure how many compulsory courses those have, but with ACS you are free to pick the ones you like, you don't have to do them all
06:48:53 <tomh> im mainly interested in creating usefull software :)
06:49:03 <hesselink> heh
06:49:04 <luite_> and you can replace some with a project
06:49:16 <tomh> so software architecture and engineering are the ones i think are most interesting for me
06:49:20 <tomh> maybe AOP
06:49:33 <hesselink> those first two weren't the most interesting courses
06:49:35 <gwern> ok, I've uploaded a darcs tarball with the suggested changes, dcoutts
06:49:36 <hesselink> swa and swe
06:49:44 <dcoutts> gwern: 'k
06:49:59 <tomh> hehe well if you are into compilers and haskell then i can understand :)
06:50:13 <hesselink> I don't think AOP will be given next year
06:50:27 <hesselink> if you're not into haskell, ST might be a bad choice
06:50:34 <hesselink> but then, what are you doing here?
06:50:37 <tomh> i like haskell
06:50:48 <tomh> i know here are lots of UU people :)
06:50:53 <hesselink> :)
06:51:06 <gwern> @tell shachaf you can try darcs-cabalized again, I've uploaded a version which looks like it fixed the curl problem
06:51:06 <lambdabot> Consider it noted.
06:51:08 <tomh> so best place to check the experiences from ST people
06:51:34 <tomh> i talked to MBI people too, but they mostly said it was so easy its almost not fun anymore
06:51:38 <hesselink> well, one positive experience here
06:51:46 <hesselink> ST can be hard
06:51:50 <tomh> they spend like 3-4 hours on it per week and pass everything
06:52:06 <tomh> ye well, maybe its time for me for some challenge
06:52:15 <hesselink> that's what some others told me
06:52:30 <hesselink> they thought the bsc was easy, and now they finally had to work (in ST)
06:52:32 <tromp> what is ST?
06:52:36 <tomh> ye
06:52:39 <tomh> the bsc is a joke
06:52:42 <hesselink> tromp: software technology
06:52:51 <luite_> tomh: software technology (master at utrecht university)
06:52:52 <hesselink> master at utrecht university
06:52:57 <tomh> on average i worked maybe 20 hours per week
06:53:02 <tomh> for the bsc
06:53:16 <hesselink> well, depending on how smart you are, that's ok I guess
06:53:31 <RayNbow> <tomh> i know here are lots of UU people :) <-- I wish there were more TUDelft people here :p
06:53:40 * gwern thought it was something to do with safe arrays, but alright
06:53:43 <tomh> i know some tudelft people
06:53:53 <tomh> but they are mainly MS infected ;)
06:54:04 <tomh> ms has lots of influence on delft i heard
06:54:38 <RayNbow> Microsoft? :p
06:54:52 <tomh> ye
06:55:18 * RayNbow is a Windows user... [but mainly because I need it for certain ga... I mean applications :p]
06:55:36 <tomh> well i mean more like .net infected :P
06:55:44 <RayNbow> is it?
06:56:15 <gwern> RayNbow: I am fortunate - all the windows games I play are so old that even wine will run them
06:56:33 <tomh> well thats what i heard from some peopl
06:56:33 <tomh> e
06:56:46 <tomh> ms hosts quite a lot events there
06:57:28 <gwern> ah, sponsorship money
06:57:32 <RayNbow> tomh: well, Erik Meijer had a talk 1 or 2 years ago in Delft about VB IsNot C#
06:57:54 <gwern> (teh wallet talks louder than common sense)
06:58:04 <tomh> ok
06:58:11 <tomh> erik meijer is ex uu btw :)
06:58:15 <RayNbow> gwern: I mainly play SubSpace [ http://en.wikipedia.org/wiki/SubSpace_(computer_game) ] and Windom [ http://mirrormoon.org/projects/windom ]
06:58:25 <RayNbow> tomh: I know :p
06:58:25 <chr1s> tomh: compared to the bachelor, I have to work a *lot* harder.
06:58:28 <chr1s> and that's a good thing
06:58:36 <tomh> how much harder?
06:58:39 <EvilTerran> cl.cam.ac.uk has a "William Gates building", i think they win wrt sponsorship money from MS :P
06:58:49 <opqdonut> wine doesn't run subspace without terrible kludging
06:58:50 <opqdonut> a shame
06:58:57 <tomh> i have a quite intensive job, i wanna keep that job :)
06:59:02 <gwern> EvilTerran: sr or III?
06:59:03 <chr1s> well, I think I spent about 10-15h a week doing my bachelor's (with average grades)
06:59:04 <RayNbow> opqdonut: I have never tried to run Linux on a box
06:59:11 <EvilTerran> gwern, pardon?
06:59:14 <hesselink> tomh: I work 2 days a week, and it's possible
06:59:20 <tomh> ok
06:59:20 <RayNbow> I still plan on buying a small server and install Linux on it
06:59:22 <EvilTerran> it doesn't specify
06:59:29 <RayNbow> but for my daily use, I don't need Linux
06:59:31 <chr1s> tomh: and now I spend about 30h, I guess
06:59:32 <EvilTerran> but it's right next to Microsoft Research Cambridge :)
06:59:33 <saml> > let (_) = (.)
06:59:33 <lambdabot>  Parse error at end of input
06:59:40 <paolino> mjrosenb: did you solve problem D of google code jam, the hexagons one , I'm having an incorrect answer
06:59:45 <chr1s> tomh: I've got a company, I work 2-3 days a week
06:59:46 <tomh> well if i cut down on sleep it should be doable
06:59:53 <RayNbow> saml: let a = b in c
06:59:53 <tomh> i got a company too
06:59:55 <saml> > let (_) = (.) in 1
06:59:56 <lambdabot>  Add a type signature
06:59:59 <gwern> EvilTerran: all the bill gates are pretty darn rich. was it bill gates sr (II; rich) or bill gates jr (III; even richer)?
07:00:05 <chr1s> tomh: haha
07:00:09 <tomh> chr1s: you started in 2004 too with your bsc or?
07:00:12 <EvilTerran> gwern, i don't recall
07:00:15 <chr1s> tomh: yes.
07:00:21 <tomh> then i should know you
07:00:26 <chr1s> actually in 2003, with a bsc of CKI
07:00:28 <tomh> but i cant recall anyone named chris
07:00:37 <EvilTerran> gwern, but it's a pretty new building, so it was probably paid for by Jr even if it's named after Sr
07:00:43 <RayNbow> opqdonut: btw, isn't there an alternative SubSpace client for Linux by now?
07:00:49 <chr1s> tomh: yeah, you'll probably recognize my face.
07:01:01 <paolino> @seen Cale
07:01:01 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
07:01:07 <tomh> ye maybe
07:01:14 <EvilTerran> preflex: seen cale
07:01:15 <preflex>  cale was last seen on #haskell 7 hours, 25 minutes and 47 seconds ago, saying: general: and feel free to ask lots of questions here :)
07:01:20 <chr1s> tomh: but I hardly ever feel I work too hard. it's always worth it, and I always have the feeling I learned a lot.
07:01:30 <tomh> are there other people from 2004 on the master?
07:01:34 <saml> @dujin  b -> a -> (a -> b -> c) -> c
07:01:35 <lambdabot> f a b c = c b a
07:02:02 <opqdonut> RayNbow: no
07:02:02 <chr1s> tomh: I guess so, don't know when everybody started. you could take a look at the subscriptions for afp and gp.
07:02:10 <paolino> anyone solved the hexagons problem of google code jam ?
07:02:23 <chr1s> anyway, I'm off now, have to catch a train
07:02:31 <tomh> ok
07:03:23 <roconnor> what's google code jam?
07:03:48 <gwern> 'The Continuum client is a Microsoft Windows-only program, due to its heavy reliance on DirectDraw. However, Continuum is compatible with an unofficial patched version of Wine [1] [2] [3]. A Linux version of the SubSpace client, called Snrrrubspace, created by user and notable programmer Snrrrub was under development, but has not been completed. Another client using the VIE protocol was successfully developed by Smong utilizing SDL, but it is not finished a
07:04:12 <paolino> roconnor: a contest coming in 15 days now
07:04:23 <saml> paolino: isn't it icfp2008 contest?
07:04:29 <saml> i mean on the same day?
07:05:19 <saml> never mind. i fail to count calendar.
07:06:00 <roconnor> paolino: how can we solve a problem if the contest isn't for 15 days?
07:06:48 <paolino> roconnor: the problem is part of a past one :)
07:07:02 <roconnor> oh
07:07:03 <roconnor> :)
07:07:27 <paolino> it wouldn't be nice to ask for a solution of a running contest :P
07:08:26 <EvilTerran> @. pl djinn b -> a -> (a -> b -> c) -> c
07:08:26 <lambdabot> f = flip (flip . flip id)
07:09:02 <paolino> the problem is badly formatted here also http://hpaste.org/8553
07:09:18 <paolino> if anyone would like to solve it
07:14:12 <saml> @. pl djinn b -> (a -> b -> c) -> (a -> c)
07:14:13 <lambdabot> f = flip flip
07:14:37 <paolino> I have the geometry part done (I hope right) , but my solution part is buggy in case, ideas on the road to take are welcome
07:17:18 <saml> would it be able to have a combinator foo  that can turn "f a b c d e ..."  to  "... `foo` e `foo` d `foo` b `foo` a `foo` f"   ?
07:18:33 <saml> it's prefix reversed
07:20:10 <EvilTerran> saml, you might be able to do something hairy with typeclasses
07:20:19 <EvilTerran> saml, altho i do not understand how your example generalises
07:20:53 <EvilTerran> did you forget c?
07:21:01 <saml> let infixr 0 +-; a +- f = f a; in 2 +- 1 +- (-)
07:21:06 <saml> > let infixr 0 +-; a +- f = f a; in 2 +- 1 +- (-)
07:21:09 <lambdabot>  -1
07:22:52 <saml> darn it doesn't work for 1 +- 2 +- (-) +- 3 (+)   where I want it to be 3 + (2 - 1)
07:23:19 <EvilTerran> saml, so you want it to work out how many parameters each operator needs automagically?
07:23:44 <EvilTerran> you'll definitely need typeclass hackery for that
07:23:50 <EvilTerran> probably at least one extension
07:24:00 <saml> EvilTerran: i'm just wondering if I can write prefix reversed.
07:24:15 <EvilTerran> yeah, i see
07:24:16 <saml> not really a postfix. but reversed prefix
07:24:37 <EvilTerran> er, ok, i don't really see
07:24:55 <EvilTerran> never mind, my brain isn't working today
07:25:01 <byorgey> just postfix, but with the parameters reversed
07:25:30 <byorgey> which I guess is the same as reversed prefix =)
07:25:36 <vixey> saml: You coudl write runReversedPrefix (...) where +- creates data
07:40:01 <Cale> paolin1: looking for me?
07:42:28 <paolin1> yes, for someone to help me with the hexagon game
07:42:58 <paolin1> to debug my idea :)
07:43:01 <Cale> What is the hexagon game?
07:43:56 <paolin1> http://hpaste.org/8553
07:45:50 <paolin1> I have polinomial complex strategy, but it looks wrong
08:00:56 * byorgey hands out boxes of crunchy vanilla almond lambda flakes
08:01:55 <vixey> yay
08:03:39 <hpaste>  saml pasted "(no title)" at http://hpaste.org/8669
08:03:46 <saml> vixey: did you mean something like that?
08:05:50 <vixey> yes
08:06:05 <vixey> you can make a function with typeclass dispatch so that you could write
08:06:11 <byorgey> saml: if you make runRP smarter you wouldn't even need the parentheses
08:06:26 <vixey> (3 +- (1 +- 2 +- Add) +- Add)
08:10:25 <saml> byorgey: I can't figure out how to make runRP smarter. I think smartness of a function is bound to the smartness of the programmer.
08:10:50 <byorgey> saml: hehe, sorry, I just meant basically to make runRP into a postfix evaluator.
08:11:02 <vixey> saml: Have you written an interpreter for a stack machine ?
08:11:05 <byorgey> saml: i.e. move the structure from the data type into the evaluator function.
08:11:40 <saml> vixey: no. i might as well do it
08:12:25 <byorgey> but I guess there's really no point since you can always just write a postfix evaluator, what you were trying to do is just be able to write expressions in reverse postfix, without needing a special evaluator function.
08:12:33 <vixey> evstack (ADD:insts) (x:y:store) = evstack insts (x+y:store)
08:12:56 <vixey> (maybe it type safe for bonus points :P)
08:22:20 * vixey complains about obvious theorems which turn out very hard to prove formally :/
08:27:11 <Spark> vixey: and then turn out to be not true
08:28:10 <mapreduce> Is http://en.wikipedia.org/wiki/Implicational_propositional_calculus the same as "implicational logic"?
08:28:54 <quicksilver> I'm not familiar with the phrase
08:28:59 <quicksilver> but I daresay it might include predicate/
08:29:29 <mapreduce> P ) Q ) P, where ) is more like a rotated logical or symbol.
08:29:40 <mauke> >
08:29:49 <mapreduce> I guess I should read it as 'implies' but it seems ungooglable.
08:29:57 <quicksilver> I expect you mean "superset of"
08:30:03 <quicksilver> which is, indeed, the old notation for implies
08:30:22 <mapreduce> Page 2 of http://www.cs.chalmers.se/~peterd/papers/DependentTypesAtWork.pdf
08:30:48 <mapreduce> I don't seem to be able to paste the symbol into IRC.
08:31:14 <quicksilver> yes.
08:31:26 <quicksilver> as I said, that is (most often) the superset symbo.
08:31:29 <quicksilver> these days.
08:31:42 <quicksilver> but back in curry's time it was the standard sign for implication.
08:32:00 <mapreduce> Ah.  So it translates to -> in that wikipedia article.
08:32:04 <mapreduce> Thanks.
08:32:23 <mapreduce> (well, →, which does seem pasteable)
08:32:28 <Spark> ⊂
08:32:32 <mauke> ⊃
08:32:41 <quicksilver> it was, essentially curry's critical observation
08:32:49 <quicksilver> that implication and function types were related
08:32:57 <quicksilver> which lead to the arrow becoming a symbol for implication
08:33:03 <quicksilver> as far as I know.
08:33:04 <mapreduce> My font doesn't contain the character that Spark and mauke just typed.
08:33:23 <quicksilver> yes, I'm 7bit-crippled too.
08:33:45 <Spark> fit wings and fly away
08:33:51 <Spark> 2008 is waiting for you
08:33:53 <mapreduce> I have £ signs, áccénts, etc.
08:34:16 <mauke> U+2282 (e2 8a 82): SUBSET OF [⊂]; U+2283 (e2 8a 83): SUPERSET OF [⊃]
08:34:18 <Spark> looks like you have utf8 support but just a rubbish font
08:34:57 <mauke> I don't have the characters for {OPEN,CLOSED,SUPERSET ABOVE} SUPERSET
08:35:12 <mauke> I do have DOUBLE SUPERSET
08:36:40 <Spark> i haven't bound keys for those
08:36:55 <Spark> in fact i'm not sure what they are
08:37:11 <Spark> double superset is presumably a ⊃ inside another ⊃
08:37:12 <mauke> me neither but I can look up unicode characters by name
08:37:20 <mauke> ⋑
08:37:23 <mapreduce> I don't see where to change the font in putty.
08:37:41 <Spark> inside settings somewhere
08:38:06 <Spark> code2000 is i think the only free usable unicode font on windows
08:38:09 <Spark> but it's a bit ugly
08:38:26 <mapreduce> got it, oops
08:38:42 <hesselink> there a free Unicode arial on the MS site
08:38:48 <hesselink> but of course it's not monospace
08:39:03 <Spark> is code2000 monospace actually
08:39:05 <Spark> i think it links to one
08:39:11 <Spark> http://www.code2000.net/code2000_page.htm
08:39:12 <lambdabot> Title: Download Code2000
08:39:26 <Spark> http://www.evertype.com/emono/
08:39:26 <lambdabot> Title: Evertype: Everson Mono
08:39:51 <Spark> i just use xterm in windows though
08:40:00 <Spark> misc.fixed i find far more readable than anything else
08:40:15 <Spark> most fonts/rendering engines are too buggy to display complex unicode properly
08:40:46 <hesselink> all characters so far worked fine on standard Gnome terminal
08:41:13 <mapreduce> NSimSun looks crap, but shows all those characters.
08:41:13 <Spark> what about this one: g̅
08:41:19 <Spark> or this one ġ
08:42:05 <Spark> these should all look roughly the same: ⊬ ⊦̸ ⊬
08:42:09 <hesselink> I see a g with an 'overscore' after it
08:42:17 <hesselink> and a g with a floating, very small dot
08:42:26 <hesselink> those are all different
08:42:34 <hesselink> slash is farther to the right in the middle one
08:42:40 <hesselink> and a little less in the right one
08:42:47 <mauke> U+22AC (e2 8a ac): DOES NOT PROVE [⊬]; U+22A6 (e2 8a a6): ASSERTION [⊦]; U+0338 (cc b8): COMBINING LONG SOLIDUS OVERLAY [̸]; U+22AC (e2 8a ac): DOES NOT PROVE [⊬]
08:42:53 <Spark> ║
08:42:54 <Spark> ║
08:43:02 <Spark> are the lines continuous?
08:43:06 <hesselink> yup
08:43:14 <Spark> it's improved since i last used it then
08:43:15 <hesselink> reminds me of old DOS guis
08:43:16 <Spark> what font are you using
08:43:28 <hesselink> I don't know, standard Ubuntu terminal font
08:43:29 * hesselink checks
08:43:38 <Spark> ⎧
08:43:39 <Spark> ⎪
08:43:43 <Spark> ⎨
08:43:44 <Spark> ⎪
08:43:47 <hesselink> it's just called monospace here
08:43:49 <Spark> ⎩
08:43:50 <Spark> damn
08:43:52 <Spark> do those line up?
08:44:02 <hesselink> yes, but they're not continuous
08:44:07 <Spark> there we go, a bug
08:44:07 <hesselink> very small gaps
08:44:07 <mapreduce> Those empty lines line up fine. :)
08:44:15 <hesselink> heh
08:44:29 <Spark> actually i think that was the bug that drove me away from gtk-based stuff previously
08:44:33 <Spark> it's probably the font though
08:44:56 <hesselink> I should probably mention that all this also passes through screen and ssh
08:44:59 <hesselink> in case that matters
08:45:23 <hesselink> but it's good enough for me
08:45:23 <Dewi> also eyeballs
08:45:28 <hesselink> yup :)
08:45:37 <Spark> screen and ssh sometimes break things if the LANG isn't set right
08:45:39 <hesselink> Spark: so what do you use now?
08:45:44 <Spark> actually ssh probably wouldn't
08:45:54 <Dewi> Spark: oddly screen can sometimes fix stuff
08:46:02 <Spark> at the moment, xterm -> ssh -> screen -> irssi
08:46:07 <Dewi> Spark: the corrollary of which is going to be that occasionally it breaks stuff
08:46:13 <hesselink> ah, same as me
08:46:16 <Spark> irssi fixes stuff
08:46:20 <Spark> hesselink: i thought you were using gnome terminal
08:46:24 <Dewi> nah irssi just does it right
08:46:27 <Dewi> to begin with
08:46:29 <hesselink> oh yes, sorry
08:46:33 <Spark> irssi will turn broken unicode into fixed unicode
08:46:38 <Spark> by guessing that it's probably latin1
08:46:40 <Spark> or something like that
08:46:41 <Dewi> Spark: really?
08:46:42 <hesselink> Spark: really?
08:46:45 <Spark> yeah
08:46:46 <hesselink> heh
08:46:49 <Spark> someone here using latin1? type a £
08:47:04 <Dewi> that's in latin1?
08:47:07 <Spark> no
08:47:11 <Spark> can lambdabot output raw bytes
08:47:27 <mauke> U+00A3 (c2 a3): POUND SIGN []
08:47:51 <Spark> decimal 0xa3 yeah
08:48:03 <roconnor> > \163
08:48:04 <lambdabot>  Parse error at end of input
08:48:11 <roconnor> > '\163'
08:48:14 <lambdabot>  '\163'
08:48:17 <Spark> > printf("%c\n",0xa3)
08:48:18 <lambdabot>  Couldn't match expected type `String'
08:48:19 <Spark> :)
08:48:27 <hpaste>  asdftimo pasted ". operator" at http://hpaste.org/8670
08:48:29 <asdftimo> hey i need some help understanding what is wrong with this program;  ghc tells me i need an instance declaration for (Num [a])
08:48:36 <asdftimo> read the hpaste please
08:48:37 <esteth> I'm working through some of the exercises in realworldhaskell's beta book, but i'm having particular trouble with a task. I'm to write a function that converts a String to an Int using a fold. I was thinking to use foldr with some kind of +x*len (xs) function, but I don't appear to be able to get at xs in the a -> b -> a accumulator function i need to supply to a fold
08:48:52 <cnwdup> Hum, I know it's pretty much OT but since I need really need help and I've tried other IRC channels before, I'll try it here again:
08:49:01 <mauke> asdftimo: reverse 123 is what's wrong
08:49:09 <mauke> asdftimo: reverse needs a list; 123 is a number
08:49:28 <asdftimo> ok i'll look into it; thanks mauke
08:49:33 <roconnor> > reverse "123"
08:49:34 <lambdabot>  "321"
08:49:38 <cnwdup> I am looking for an hosting service where I'd like to get a virtual server. I'd be using slicehost right now if I had a credit card. So can you recommend web hosters you know or you're using?
08:50:07 <clad|away> http://epicvps.com
08:50:07 <lambdabot> Title: EpicVPS Virtual Private Servers - OpenVZ VPS Hosting
08:50:11 <clad|away> I'm extremely happy with them
08:50:21 <esteth> I like linode for linux VPS. I'm very happy with it
08:51:30 <cnwdup> Thanks for those recommendations!
09:00:00 <mm_freak_work> > read . reverse . show $ 123
09:00:01 <lambdabot>  Exception: Prelude.read: no parse
09:00:08 <mm_freak_work> > read . reverse . show $ (123 :: Int)
09:00:11 <lambdabot>  Exception: Prelude.read: no parse
09:00:12 <nominolo`> @src fmap StateT
09:00:12 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
09:00:17 <Deewiant> > read . reverse . show $ 123 :: Int
09:00:19 <wjt> @src StateT fmap
09:00:19 <lambdabot> Source not found. Wrong!  You cheating scum!
09:00:19 <lambdabot>  321
09:00:29 <mm_freak_work> huh?!
09:00:38 <nominolo`> @src State fmap
09:00:39 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
09:00:49 <mm_freak_work> ah!
09:00:52 <Deewiant> mm_freak_work: the read probably defaults to () or something?
09:00:55 <mm_freak_work> > read . reverse . show $ (123 :: Int) :: Int
09:00:58 <lambdabot>  321
09:01:16 <mm_freak_work> 'read' doesn't know what to read to =)
09:01:31 <Deewiant> yes, I would have expected a type error complaining about that
09:01:34 <mm_freak_work> > read . reverse . show $ (321 :: Float) :: Int
09:01:36 <lambdabot>  Exception: Prelude.read: no parse
09:01:38 <Deewiant> evidently it just made the wrong choice instead :-)
09:02:08 <mm_freak_work> > show (321 :: Float)
09:02:09 <lambdabot>  "321.0"
09:02:14 <mauke> @check \x y -> mappend x y == mappend y x
09:02:16 <lambdabot>  OK, passed 500 tests.
09:02:20 <mm_freak_work> > read . reverse . show $ (321 :: Float) :: Double
09:02:22 <lambdabot>  0.123
09:02:24 <Saizan_> lb compiles with extendend defaulting, like ghci
09:02:24 <Deewiant> > read . reverse . show $ ()
09:02:26 <lambdabot>  Exception: Prelude.read: no parse
09:02:35 <mm_freak_work> > show ()
09:02:37 <lambdabot>  "()"
09:02:53 <mm_freak_work> > read . reverse . reverse . show $ () :: ()
09:02:55 <lambdabot>  ()
09:03:06 <Deewiant> I'd like to know what that 'read' defaults to
09:03:22 <mauke> ()
09:03:24 <Deewiant> evidently it's not Float, Double, Int, Integer, (), or String.
09:03:27 <Deewiant> > read "()"
09:03:29 <lambdabot>  ()
09:03:37 <Deewiant> oh, right.
09:03:38 <mm_freak_work> isn't it a class function?
09:03:39 <Deewiant> > reverse "()"
09:03:41 <lambdabot>  ")("
09:03:48 <Deewiant> that wouldn't read into () now would it.
09:04:01 <mm_freak_work> :t read
09:04:02 <lambdabot> forall a. (Read a) => String -> a
09:04:07 <mm_freak_work> it is =)
09:05:06 <esteth> @src read
09:05:06 <lambdabot> read s = either error id (readEither s)
09:14:49 <roconnor> Is the main purpose of Cairo to rasterize vector drawings?
09:15:53 <quicksilver> roconnor: I think it's main purpose is to be a DSL for vector drawings
09:16:13 <roconnor> hmm
09:16:25 <quicksilver> roconnor: and to make that useful it contains export formats, both non-raster (postcript/SVG) and also contains its own rasteriser
09:16:26 <quicksilver> for raster export like PNG.
09:17:44 <roconnor> It just strikes me that without a raserizer, the whole project seems almost trival
09:18:01 <roconnor> because postscript and SVG are already vector formats
09:18:26 <roconnor> granted Cairo might just be the right sort of trival needed.
09:20:41 <mjrosenb> roconnor: are you going to be writing a postscript evaluater?
09:20:43 <mjrosenb> tor
09:21:51 <roconnor> nope, why?
09:22:56 <mjrosenb> roconnor: just because i think that's the easiest way to get a ps -> svg translator
09:23:40 <roconnor> an svg -> ps translator is probably easier.
09:24:13 <cnwdup> clad|away: Can I question you regarding epicvps?
09:24:23 <clad|away> sure
09:24:51 <mjrosenb> roconnor: this is probably true
09:25:52 <quicksilver> roconnor: it is trivial, in a sense, yes.
09:25:55 <asdftimo> hey, i need help with my program: ghc says that i need an instance declaration for (Fractional Int) because I used '/'. how can i do this? (check the hpaste)
09:25:56 <hpaste>  asdftimo pasted "fractional int" at http://hpaste.org/8671
09:26:08 <quicksilver> roconnor: it was just filling a need for a decent consistent library for resolution independent 2D
09:26:16 <asdftimo> the division is on the last line
09:26:22 <EvilTerran> ?type (/)
09:26:22 <quicksilver> roconnor: not rocket science, but nothing suitable pre-existed.
09:26:23 <lambdabot> forall a. (Fractional a) => a -> a -> a
09:26:30 <vixey> how do I turn [[0,2],[1,4],[3,5]] into [0,1,2,3,4,5] ?
09:26:34 <EvilTerran> asdftimo, you don't use / on integers
09:26:36 <roconnor> quicksilver: so it is largely just providing a common interface.
09:26:37 <EvilTerran> ?type div
09:26:38 <lambdabot> forall a. (Integral a) => a -> a -> a
09:26:38 <quicksilver> roconnor: Apple saw a similar need and implemented something not entirely dissimilar themselves
09:26:41 <EvilTerran> asdftimo, did you want div?
09:26:54 <asdftimo> EvilTerran, yeah, i forgot about div. i'll try that: thanks
09:26:54 <quicksilver> roconnor: and a decent fast rasteriser for screen use
09:27:05 <tromp> :t concqat
09:27:06 <lambdabot> Not in scope: `concqat'
09:27:09 <tromp> :t concat
09:27:10 <lambdabot> forall a. [[a]] -> [a]
09:27:13 <roconnor> quicksilver: okay.  I've been just pondering reimplementing cairo in Haskell, and wondering what that would mean.
09:27:17 <Dybber> vixey: sort . concat
09:27:28 <tromp> > sort . concat $ [[0,2],[1,4],[3,5]]
09:27:30 <lambdabot>  [0,1,2,3,4,5]
09:27:32 <vixey> well I can't sort it
09:27:34 <quicksilver> roconnor: ghostscript is not powerful enough and SVG is too painful to use :)
09:27:37 <vixey> the actualy content isn't going to be numbers
09:27:38 <EvilTerran> concat . transpose?
09:28:04 <roconnor> quicksilver: the cairo API and SVG interface seem to be almost the same at first glance.
09:28:05 <vixey> maybe creating [[0,2],[1,4],[3,5]] in the first place is a bad idea and I should skip that step
09:28:16 <EvilTerran> vixey, concat.transpose?
09:28:18 <mauke> > concat . transpose $ [[0,2],[1,4],[3,5]]
09:28:19 <mauke> 02/18:27 <lambdabot>  [0,1,2,3,4,5]
09:28:20 <lambdabot>  [0,1,3,2,4,5]
09:28:22 <mauke> argh
09:28:48 <EvilTerran> ... that's not right
09:29:02 <Dybber> vixey: you wan't the result sorted but your data can't be sorted?
09:29:03 <quicksilver> roconnor: Yes. cairo heavily inspired by SVG.
09:29:06 <tromp> @src transpose
09:29:07 <lambdabot> transpose []             = []
09:29:07 <lambdabot> transpose ([]   : xss)   = transpose xss
09:29:07 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
09:29:18 <quicksilver> roconnor: what I meant was that using SVG directly (as in , the raw XML itself) is too painful.
09:29:49 <Dybber> vixey: maybe you wan't to look at Data.List.sortBy
09:29:54 <roconnor> quicksilver: yep.  loops are nice to have.
09:30:07 <EvilTerran> XML + that custom language they put in for point lists and whatnot
09:30:08 <byorgey> vixey: if the data can't be sorted, how do you know what order you wnt them in?
09:30:21 <vixey> [[0,2]
09:30:21 <vixey> ,[1,4]
09:30:21 <vixey> ,[3,5]]
09:30:27 <vixey> it's diagonal
09:30:35 <EvilTerran> oh, i see
09:30:42 <roconnor> quicksilver: A Haskell version of Cairo ought to be less stateful.
09:30:44 <Dybber> why do I suddenly put an apothrophe in want? :S
09:30:44 <vixey> I think making the list in this way is a roundabout and I'll skip it
09:30:53 <EvilTerran> i've done that, not sure how th
09:30:55 <vixey> Dybber: I do that too sometimes :(
09:31:00 <roconnor> quicksilver: although the more I read about Cairo, the less bad it seems.
09:31:01 <EvilTerran> o
09:31:08 <roconnor> a little less bad
09:31:36 <quicksilver> roconnor: why would you choose to reimplement cairo rather than layering a nice stateless DSL type thing on top of the existing cairo binding?
09:31:38 <clad|away> cnwdup: didn't see any questions
09:31:42 <dcoutts> roconnor: a cairo wrapper need not be stateful at all
09:31:47 <clad|away> cnwdup: you've only got me for a few more minutes but feel free to pm me.
09:32:22 <EvilTerran> > zipWith ($) (iterate (0:) []) (repeat [1..])
09:32:23 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `[t]'
09:32:25 <roconnor> quicksilver: to take full advantage of GHC's wonderful multicore magic, of course :P
09:32:48 <EvilTerran> > zipWith (++) (iterate (0:) []) (repeat [1..]) -- er
09:32:49 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
09:32:54 <EvilTerran> wait, i fail
09:32:56 <EvilTerran> > zipWith (++) (iterate (0:) []) (repeat [1]) -- er
09:32:57 <lambdabot>  [[1],[0,1],[0,0,1],[0,0,0,1],[0,0,0,0,1],[0,0,0,0,0,1],[0,0,0,0,0,0,1],[0,0,...
09:33:07 * EvilTerran wonders where he was going with this again
09:33:13 <roconnor> quicksilver: although a first step might be to make a stateless API on top of Cairo
09:33:21 <quicksilver> exactly what I was about to say
09:33:25 <quicksilver> step 1 : nice API
09:33:31 <quicksilver> step 2 : an alternative backend :)
09:33:35 <roconnor> quicksilver: Tim Docker has been doing a nice job of that already in Haskell Charts.
09:33:40 <Dybber> vixey: ok, I have the same experience when coding in functional languages. You don't always know how you want your intermediate data to be.
09:33:41 * quicksilver nods
09:34:22 <roconnor> He has been developing a stateless interface to Cairo as functions are needed.
09:34:50 <roconnor> That's probably a reasonably good way of figuring out what a pure API would look like.
09:36:19 <carl> how would i convert the Int from ord into an Integer needed by another function
09:36:28 <EvilTerran> ?type fromIntegral
09:36:29 <lambdabot> forall a b. (Num b, Integral a) => a -> b
09:36:32 <EvilTerran> ?type fromEnum
09:36:33 <lambdabot> forall a. (Enum a) => a -> Int
09:36:35 <EvilTerran> etc
09:36:40 <EvilTerran> take your pick :)
09:36:43 * vixey guesses zipping
09:36:44 <vixey> "ABCD" 3 4 -> A BA CBA DCB DC D
09:36:44 <vixey> "123"  3 4 -> 1 12 123 123 23 3
09:36:46 <carl> lol now that was fast
09:36:47 <EvilTerran> or, just use fromEnum in place of ord
09:36:47 <vixey> those is a good way
09:36:49 <carl> scaringly fast
09:37:01 <carl> thx
09:37:08 <EvilTerran> that's how i'd do it - skip the Int altogether :)
09:37:20 <EvilTerran> wait, that's still Int. wat?
09:37:25 * EvilTerran pokes the report
09:37:45 <EvilTerran> fromIntegral is what you want :P
09:38:06 <EvilTerran> ?type toInteger -- or you can use this, but that's needlessly specific
09:38:07 <lambdabot> forall a. (Integral a) => a -> Integer
09:38:41 <ddarius> Don't use toInteger.
09:38:50 <EvilTerran> no?
09:41:01 <carl> lol and just to clear anything up all im doing is converting a list of chars into a number for use with RSA but thx for all the examples neway :p
09:42:42 <EvilTerran> > let consZip hs [] = map return hs; consZip [] ts = ts; consZip (h:hs) (t:ts) = (h:t):consZip hs ts in concat . foldr (\hs ts -> []:consZip hs ts) $ [[0,2],[1,4],[3,5]]
09:42:43 <lambdabot>  Couldn't match expected type `[[a]]'
09:42:46 <EvilTerran> grr
09:45:25 <ddarius> foldr takes three arguments
09:46:11 <EvilTerran> > let consZip hs [] = map return hs; consZip [] ts = ts; consZip (h:hs) (t:ts) = (h:t):consZip hs ts in concat . foldr (\hs ts -> []:consZip hs ts) [] . transpose $ [[0,2],[1,4],[3,5]]
09:46:12 <lambdabot>  [0,1,2,3,4,5]
09:46:18 <EvilTerran> there we go
09:46:31 <EvilTerran> it'd need tweaked to work without the transpose, but that's the approach i used before
09:46:43 <ski> `consZip' being `zipWithDefault return id (:)' ?
09:46:43 <lambdabot> ski: You have 1 new message. '/msg lambdabot @messages' to read it.
09:46:55 <EvilTerran> ski, yeah, basically
09:47:02 <ski> @messages
09:47:02 <lambdabot> Kamina said 2m 4h 58m 45s ago: I don't agree: Having something of type Maybe (exists a. a) would be useful, you can typecast it to anything, because it can be every type. (Like you can convert read "
09:47:02 <lambdabot> 5" to every type being of the "Read" class)
09:47:06 <EvilTerran> i called it zipAllWith in the original :P
09:47:17 <mmorrow> derive show for GADT data decls then copy and paste: http://morrow.jypsis.com/cgi-bin/gadtshow.cgi
09:48:01 <byorgey> hi all, a few more hours until the HWN goes out, feel free to send any last-minute news items my way!
09:48:03 <EvilTerran> surely the only value you can typecast to anything is _|_?
09:48:11 <EvilTerran> so it's not really that useful :P
09:49:08 <ddarius> EvilTerran: Bool is useful.
09:49:16 <ski> EvilTerran : i don't agree with Kamina, yes
09:49:19 <PeakerWork> I think that the "Monads for Incremental Computing" should actually be converted to Arrows. Did anyone read that paper?
09:49:27 <EvilTerran> ddarius, well, yes, but there's a rather more direct way of doing that
09:49:43 <ddarius> EvilTerran: pshaw.  Directness is overrated.
09:49:57 <EvilTerran> isn't bool generally defined as "() + ()", not "() + _|_" ?
09:50:11 <ddarius> EvilTerran: exist a. a ~ ()
09:50:17 <ski> PeakerWork : *nod*
09:50:39 <quicksilver> right but that had a Maybe
09:50:46 <quicksilver> Maybe () ~ Bool
09:50:55 <EvilTerran> yes, i get that bit
09:50:55 <quicksilver> ignoring bottoms.
09:51:03 <EvilTerran> i thought (exist a. a) ~ _|_, not ()
09:51:09 <EvilTerran> (0, not 1)
09:51:12 <ski> no
09:51:24 <ski> forall a. a   ~=   0
09:51:25 <roconnor> (forall a. a) ~ _|_
09:51:26 <EvilTerran> what value does it contain?
09:51:37 <quicksilver> EvilTerran: it contains all values. But not in a useful way.
09:51:50 <quicksilver> "exists a . a" means "there is some type a, and I have a value of this type"
09:51:51 <EvilTerran> but you can distinguish them from _|_ somehow?
09:52:03 <EvilTerran> ah, "I have a value of that type". i see. cunning.
09:52:28 <ski> one can think of it as a an equivalence class of every value .. where you can't distinguish different representants of the same equivalence class
09:52:35 <Saizan_> PeakerWork: why arrows?
09:52:42 <quicksilver> functions of type (exist a . a) -> b are the same as functions of type () -> b
09:52:48 <quicksilver> it is in that sense that exist a . a is like ()
09:53:22 <quicksilver> because such functions can certainly take a value, but that value can't depend in any interesting way on the wrapped up value
09:53:27 <quicksilver> so they might as well be functions from ()
09:53:39 <BMeph> vixey: That looks like what I called a "diagonal join". :)
09:55:29 <PeakerWork> Saizan_, well, he's forced by monad's structure, to put computations that are dependent on the "reading" an observable/modifiable value, AND those that are not dependent, "after" that read.  This means that when the value changes, it will re-run the code "after" the read, instead of the computations that depend on that read
09:55:56 <EvilTerran> ... suddenly, i get insight into the point of arrows
09:56:04 <PeakerWork> Saizan_, forcing him to take a computational graph and serialize it into a sequence
09:56:53 <Saizan_> PeakerWork: well, after the read but still inside the newMod
09:58:07 <PeakerWork> EvilTerran, were you being serious or sarcastic? :)
09:58:13 <EvilTerran> serious :)
09:58:29 <Saizan_> PeakerWork: and arrows would limit the expressivity of the language, or you mean that you can have a finer control on the dependecies with an arrow+app?
09:58:43 <PeakerWork> Saizan_, I read it a while ago, so I don't remember the exact details, but I remember he had troubles with multiple sequential reads/etc.  I guess I ought to re-read it
09:59:04 <PeakerWork> Saizan_, why would arrows limit expressiveness? A monad is a strict sub-case of arrows?
09:59:05 <EvilTerran> you can tell which arrow computations depend on which with much more granularity - as a DAG rather than as just a list as for monads
09:59:35 <Saizan_> ?type app
09:59:36 <lambdabot> forall (a :: * -> * -> *) b c. (ArrowApply a) => a (a b c, b) c
09:59:54 <EvilTerran> (or just a directed graph if you're using ArrowFix)
10:00:13 <Saizan_> PeakerWork: without that primitive you can't generate a new arrow depending on the output of a previous one
10:00:39 <Saizan_> ?google arrows-idioms
10:00:39 <lambdabot> No Result Found.
10:00:56 <BMeph> ?go idiom arrow
10:00:57 <lambdabot> http://www.usingenglish.com/reference/idioms/arrow+in+the+quiver.html
10:00:57 <lambdabot> Title: Arrow in the quiver - UsingEnglish.com
10:01:05 <BMeph> Boo! >:(
10:01:21 <BMeph> ?where idiom-arrows
10:01:21 <lambdabot> I know nothing about idiom-arrows.
10:01:34 <PeakerWork> Saizan_, If I have (a b c), why can't I generate (a c d) ?
10:01:50 <Saizan_> http://homepages.inf.ed.ac.uk/wadler/papers/arrows-and-idioms/arrows-and-idioms.pdf
10:01:51 <lambdabot> http://tinyurl.com/6evopg
10:02:31 <BMeph> Yeah - thanks to that dumb Free Dictionary entry, the paper in now the second hit on Google. That's lame. :|
10:02:46 <BMeph> s/in now/is now/
10:02:55 <Saizan_> PeakerWork: you can't go from (a b (a b d)) to (a b d)
10:03:44 <BMeph> Saizan_: Wouldn't that be (a (a b d) d)? :)
10:04:06 <PeakerWork> Saizan_, why would I have (a b (a b d))?
10:04:19 <Dybber> I have a often recurring need for a function that applies a function to a value and returns a pair of the input and the result. Is there any functions in the Haskell libraries that does that kind of things?
10:04:20 <Saizan_> no, the point is that you've an arrow that produces another arrow, and you want that produced arrow to be composed with the others
10:04:20 <ski> s/a/(~>)/ please
10:04:43 * EvilTerran parses Saizan's as Arrow (~>) => (b ~> (b ~> d)) -> (b ~> d) - looks like join or something?
10:04:43 <PeakerWork> Saizan_, indeed it makes sense to be able to compose that
10:05:03 <PeakerWork> sort of a join
10:05:10 <Saizan_> PeakerWork: because it may happen that the next action to perform depends on a value produced at runtime
10:05:18 <Saizan_> EvilTerran: yes, a sort of join
10:06:57 <PeakerWork> Saizan_, sounds like join should be a basic arrow operation, I can't think of why it would ever make sense to disallow it
10:07:08 <PeakerWork> (what arrow type would be incapable of expressing it)
10:07:44 <Saizan_> well, with a "join" you get something isomorphic to monads again..
10:08:43 <ski> `Arrow (~>) => ((a,a) ~> b) -> (a ~> b)' shoudl be no problem
10:09:47 <Saizan_> that's just (arr dup >>>)
10:11:08 <PeakerWork> Saizan_, really? Why would join make it isomorphic to monads again?
10:11:51 <Saizan_> ?docs
10:11:51 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
10:13:27 <roconnor> > 1747-1179
10:13:28 <lambdabot>  568
10:13:43 <Saizan_> PeakerWork: http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Arrow.html#v%3AArrowMonad
10:13:44 <lambdabot> http://tinyurl.com/y6yt3s
10:18:59 <PeakerWork> Saizan_, does that mean that anything that can be done with ArrowApply can also be done with ordinary Monads?
10:19:11 <PeakerWork> Saizan_, that doesn't sound true
10:19:54 <Saizan_> why not?
10:19:56 <PeakerWork> (Not everything that can be done with Arrow can be done with Monad, so how is it possible that everything that can be done with a class that _extends_ Arrow can be done with Monad?)
10:20:18 <Saizan_> it depends on your definition of "can be done"
10:20:28 <Saizan_> monads can express more computations than arrows
10:20:43 <Saizan_> but it's harder to analyze a monadic expression
10:21:20 <PeakerWork> Saizan_, I see. By "can be done" I mean allow things like optimization-analysis on an arrow parser is possible, but on a monad parser is impossible
10:21:40 <PeakerWork> Saizan_, dependency analysis of an arrow's structure is possible, but not possible on the monadic structure..
10:21:49 <Saizan_> ArrowApply restores the expressivity that arrows lack, so it presumably also the complexity
10:22:10 <BMeph> Dybber: Still looking for that function? :)
10:22:16 <Saizan_> PeakerWork: yeah, you get that power of analysis paying in expressivity
10:22:25 <Mitar> has anyone done any 3D (4D...) fractal computing stuff in Haksell?
10:22:34 <PeakerWork> I thought the problem had to do with the opaqueness of Haskell functions. You have to "look through Haskell functions" to see the continuation of computations
10:22:46 <PeakerWork> Saizan_, whereas Arrows aren't necessarily opaque
10:22:54 <Mitar> I would like to do somethinh like http://local.wasp.uwa.edu.au/~pbourke/fractals/quatjulia/ but I would like to know if there is any source already avaiable
10:22:58 <lambdabot> Title: Quaternion Julia Fractals
10:23:18 <vixey> Mitar: POV Ray
10:23:27 <vixey> oh it's not in haskell thoughm
10:23:44 <Mitar> :-)
10:23:48 <Mitar> i have made a simple ray tracer
10:23:49 <PeakerWork> Saizan_, m a -> (a -> m b) -> m b   doesn't let you see "m a" and "m b" both ahead of time, in order to perform analysis.  Even with ArrowApply, I can still see the "insides" of (x :: (a b c)) >>> (y :: (a c d))
10:24:18 <Mitar> (which is realy really slow by the way ... i do not know why. a 600x400 scene it renders for about a minute on my macbook)
10:24:33 <Mitar> (if anybody want's to throw a look ...)
10:24:54 <Saizan_> PeakerWork: with ArrowApply you can generate arrows at runtime and make them execute among the others, so little chance of seeing those "ahead of time"
10:25:13 <Mitar> and would like to test in on some interesting stuff ... I would need a function which maps a point in space (three coordinates) to Maybe Color
10:25:20 <Mitar> any examples?
10:25:31 <Mitar> (except sphere and cube :-) )
10:25:33 <Saizan_> by runtime i mean after you've started to run the other arrows computations
10:28:19 <Dybber> BMeph: well yes, but I have my own, I was just wondering if there were some library for programming in that manner.
10:36:00 <sclv> oh frcrying out loud. hxt breaks with the normal parser on some files so I moved to tagsoup, and its tagsoup parser misses a bet with cdata.
10:36:09 <sclv> some days there's just no winning.
10:36:22 <dons_> haxml, xml-light, libxml??
10:36:53 <sclv> dons: I'm wishing I had. now I've locked myself in for the moment. if it gets bad enough I'll switch.
10:37:05 <PeakerWork> Saizan_, thanks! I understand now. Its pretty fascinating :)
10:37:05 <vixey> ?where report
10:37:06 <lambdabot> http://www.haskell.org/onlinereport/
10:37:11 <asdftimo> hi, can someone point me to the most optimized way to find prime factors?
10:37:29 <roconnor> asdftimo: how big are you numbers?
10:37:33 <asdftimo> 10^7
10:37:39 <vixey> @instances Bounded
10:37:39 <lambdabot> (), (a, b), (a, b, c), All, Any, Bool, Char, Dual a, Int, Ordering, Product a, Sum a
10:37:40 <roconnor> on
10:37:45 <sclv> I made the knowledge investment for hxt too, and it paid off pretty well, so its just another irritating thing.
10:37:46 <roconnor> they are tiny :)
10:38:14 <asdftimo> haha. yeah, but i have a slow comp and speed would be nice
10:38:36 <roconnor> asdftimo: Hmm, I'm not sure what is best for numbers that small
10:38:42 <vixey> @instances Enum
10:38:42 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
10:38:50 <roconnor> I'd be tempted to brute force it.
10:39:09 <Saizan_> PeakerWork: yeah :) this wadler's paper has a more formal comparison http://homepages.inf.ed.ac.uk/wadler/papers/arrows-and-idioms/arrows-and-idioms.pdf
10:39:09 <lambdabot> http://tinyurl.com/6evopg
10:39:09 <roconnor> try all prime numbers upto 10^3.5
10:39:26 <roconnor> there aren't all that many
10:39:31 <asdftimo> ok
10:39:55 <asdftimo> and then just test them all <= sqrt n?
10:40:06 <roconnor> asdftimo: all prime numbers
10:40:15 <roconnor> don't try the composite ones
10:40:25 <asdftimo> yes, i understand
10:40:46 <asdftimo> hmm ill try to work on that
10:40:48 <PeakerWork> Saizan_, I wish they just used Haskell syntax instead of fancy glyphs
10:40:55 <BMeph> Dybber: Not exactly, but it sounds like (id &&& f) would do what you were asking for.
10:42:25 <EvilTerran> BMeph, or (second f)
10:42:28 <EvilTerran> ?
10:42:31 <roconnor> ``ome people found error messages they couldn't ignore more annoying than wrong results, and, when judging the relative merits of programming languages, some still seem to equate "the ease of programming" with the ease of making undetected mistakes.
10:42:34 <EvilTerran> no, wait, that'd be id***f
10:42:48 <BMeph> sclv: Have you sent a nasty-ram to Janis directly? It might be something he may just change for you. :)
10:43:10 <roconnor> good ol Dijkstra
10:43:29 <BMeph> EvilTerran: I thought (***) needed a pair as input? :)
10:43:43 <PeakerWork> Saizan_, I think there might still be interesting things you can "statically" do to an ArrowApply that you can't do with Monads. Because I "intercept" the structuring of the arrow (via first/etc) whereas with Monad I can't do anything.. I'm a little confused by all this yet though :)
10:43:45 <EvilTerran> BMeph, i mean second f = id *** f
10:44:08 <EvilTerran> i got &&& confused with ***
10:44:24 <PeakerWork> I think using syntax to encode arrows is annoying. We need a code UI/fancy widgets!
10:44:27 <asdftimo> hey roconnor, what do you think about this function for determining if a given number is prime:
10:44:28 <asdftimo> isprime n=not (elem 0 $ map(\x -> mod n x) $ takeWhile(\x -> x^2 <= n)(2:[3,5..])
10:44:49 <roconnor> asdftimo: it'd be intresting to see if trying all factors number is as fast as trying to find all prime factors
10:45:07 <BMeph> EvilTerran: Ah, yes, that makes sense. Of course, aren't first and second explicitly mentioned in (***)'s definition? :)
10:45:08 <sclv> BMeph: yeah. if it gets to be enough of an issue I'll file a report or cook up a patch.
10:45:40 <roconnor> asdftimo: that's not a bad start
10:45:55 <asdftimo> then i can use :
10:45:55 <asdftimo> isprime n=not (elem 0 $ map(\x -> mod n x) $ takeWhile(\x -> x^2 <= n)(2:[3,5..])
10:46:00 <asdftimo> whoops
10:46:04 <roconnor> asdftimo: it would be better if you test only prime numbers instead of 2 and the odd numbers
10:46:17 <asdftimo> im using isprime to generate
10:46:18 <asdftimo> primelist = [x | x <- 2:[3,5..], isprime x]
10:46:41 <asdftimo> yeah, im going to then use this list to find prime factors
10:46:43 <lament> primes = [2,3,5,7,11..]
10:46:45 <sclv> Its funny getting more serious as a Haskell developer and realizing how much work still needs to be done to work out the corner cases in the libs. it really is a relative timesink in that dept. compared to python or whatever where at least more paths are more fully tested.
10:47:06 <roconnor> how about primelist = 2:[x | x<-[3,5..], isprime x]
10:47:30 <asdftimo> i don't understand why that is an improvement
10:47:31 <roconnor> and then use takeWhile (\x -> x^2 <= n) primelist  in your isprime
10:47:57 <BMeph> sclv: I think Janis is using it as a teaching project (I might be reading more into the site info than is given, but that was my impression), so mentioning it somewhere (besides here, anyway) may either provoke a change, or an explanation. Either way, some learning occurs. :)
10:48:23 <asdftimo> roconnor: that's kind of strange, since they both point to each other, but i guess i'll go try that...
10:48:32 <roconnor> :)
10:48:54 <roconnor> you need to pull the 2: out in front in order for the recursive definition to get going.
10:49:17 <roconnor> kinda like a starter motor on an engine
10:50:41 * roconnor is pleased to really take advantage of Haskell in this example
10:51:04 <asdftimo> roconnor: that is fucking cool
10:51:05 <asdftimo> it works
10:51:08 <BMeph> sclv: Then again, maybe it's just that people figure that Haskell should already have developed libraries, considering its age. :)
10:51:22 <asdftimo> i love haskell
10:52:02 <BMeph> Haskell: Where mutual recursion isn't just a good idea, it's THE LAW! ;)
10:52:28 <asdftimo> it is going to take me another good 5 mins to comprehend this, but i can tell it is pretty amazing
10:52:32 <roconnor> you can replace not (elem 0 $ map(\x -> mod n x)  with all (\x -> mod n x/=0)
10:52:43 <roconnor> but it won't make any essential difference
10:52:49 <roconnor> It's just a little shorter
10:52:57 <lilachaze> BMeph: Haskell: Where tail recursion isn't guaranteed to be optimized :)
10:53:03 <asdftimo> does all stop when it finds one?
10:53:07 <asdftimo> "all"
10:53:15 <roconnor> yep
10:53:16 <asdftimo> i guess it does; this is haskell
10:53:23 <roconnor> @src all
10:53:24 <lambdabot> all p =  and . map p
10:53:33 <roconnor> @src and
10:53:33 <lambdabot> and   =  foldr (&&) True
10:53:48 <lilachaze> asdftimo: the general rule is, it will do as much work as is required to get the answer to whatever question you ask, and no more.
10:53:48 <roconnor> && is short circuted
10:54:10 <tromp> @let primes = 2:[x|x<-[3..],all(\p->x`mod`p>0)(takeWhile(\p->p*p<=x)primes)]
10:54:11 <lambdabot> Defined.
10:54:24 <BMeph> lilachaze: Haskell: Where premature optimization cal finally receive treatment, and help... :)
10:54:26 <tromp> > primes
10:54:27 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
10:54:33 <BMeph> s/cal/can/
10:54:56 <Saizan_> PeakerWork: i think i agree that with ArrowApply you have more information about the "static" parts of the expression than what you'd have with just Monad, in my make-like system (that's inspired by this view) in fact i end up interleaving analysis with evaluation
10:54:59 <asdftimo> interesting tromp
10:55:13 <roconnor> tromp has more or less what you wrote
10:55:18 <PeakerWork> Saizan_, cool
10:55:25 <lilachaze> BMeph: Haskell: Where variables don't, and nor do operators (or at least, not yet)
10:55:25 <roconnor> except you have things nicely broken into two functions
10:55:54 <tromp> if you're willing to forego on the sqrt optimization, you can get a much shorter solution still
10:55:57 <roconnor> asdftimo: what you have done is usually quite hard to do in other languages. :)
10:56:05 <tromp> @let slowprimes = nubBy(\x y->y`mod`x==0)[2..]
10:56:06 <lambdabot> Defined.
10:56:47 <vixey> can you enumerat every function from a -> b? given you can enumerate a and enumerate b?
10:56:48 <tromp> > slowprimes
10:56:49 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
10:56:54 <roconnor> > nubBy(((>1).).gcd)[2..]
10:56:56 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
10:57:17 <tromp> nope, vicey
10:57:26 <tromp> vixey
10:57:37 <byorgey> vixey: if you can enumerate a and b, yes.
10:58:00 <tromp> functions from infinite domain are uncountable
10:58:10 <BMeph> tromp: I was going to go with byorgey's answer - do you know more to the problem? :)
10:58:23 <PeakerWork> Saizan_, What's the difference between a make-like system using ArrowApply than an ArrowApply-based "incremental computation" thing? I mean, can you generalize it to be an incremental-computation-arrow, and simply adapt file system change notifications to input change events?
10:58:34 <byorgey> oh, right, I see
10:58:35 <BMeph> tromp: The point being, both a and b are enumerable.
10:58:46 <vixey> infinite dimensional diagonalization
10:58:48 <PeakerWork> Saizan_, wow, I really messed up the grammar of that sentence :)
10:58:55 <vixey> doesn't solve the problem?
10:59:05 <BMeph> vixey: By "enumerable," you mean finite, right? :)
10:59:13 <vixey> no doesn't have to be finite
10:59:19 <tromp> no, enumerable doesn not imply finite
10:59:28 <BMeph> vixey: countable, then?
10:59:34 <tromp> > enumFrom 0
10:59:35 <vixey> of course countable
10:59:35 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
10:59:46 <lament> functions from a to b? Let a = number of digit after the decimal point. b = number from 0 to 9. These functions then describe all real numbers. Therefore, they're uncountable.
11:00:30 <byorgey> well done, lament
11:00:58 <BMeph> so the number of functions from a to b depends exponentially upon the "size" of a? :)
11:00:59 <Gilly> diagonalization argument works very well... that's isomorphic to functions from N -> N and clearly we could represent those functions as infinite strings of numbers
11:01:07 <vixey> x -> y = y^x
11:01:07 <tromp> just need b to have cardinality greater than 1
11:01:39 <BMeph> Or y, in vixey's latest formula. :)
11:02:10 <tromp> right; 2^inf is not countable
11:02:15 <byorgey> but if a is finite and b countable, then a -> b is countable, right?
11:02:28 <tromp> right
11:02:51 <lament> yes
11:02:55 <byorgey> e.g. 2 -> N  corresponds to the rationals
11:03:01 <lilachaze> if |a| = n, then |a -> b| is |b|^n
11:03:59 <lament> a->b where a is of finite cardinality A is like a A-tuple of b's
11:04:06 <lament> a vector of length A
11:04:37 <sylvan> Anyone know where "compilerPath" in Cabal went in newer releases? Trying to build WASH with ghc 6.8.2 and the Setup.lhs file fails because it can't find "compilerPath"
11:04:45 <BMeph> |{x->y}| = |{y}|^|{x}|, where |m| is set size, and {x->y} stands for a set isomorphic to functions from x to y. Man, it's been too long since I studied set theory.
11:07:55 <asdftimo> roconnor: so here is what i have so far:
11:07:56 <asdftimo> primefactors n = [ x | x<-takeWhile(<=(div n 2)) primelist, mod n x==0]
11:08:21 <asdftimo> roconnor: im not sure when to stop taking, though. i could go to sqrt n, but then i have to find the other pair for the factor
11:08:30 <lilachaze> alternatively, a -> b is { f <- { (x,y) | x <- a, y <- b } | forall x <- a. exist! y <- b. (x,y) in f }
11:09:36 <lilachaze> asdftimo: the smallest prime factor is <= the square root, unless the number is prime.
11:10:15 <asdftimo> not true
11:10:29 <lilachaze> yes it is. note "smallest".
11:10:38 <asdftimo> sorry misread
11:10:43 <roconnor> asdftimo: ideally you should find the smallest prime factor (less than sqrt n) and then recursively factorize the reamining term
11:11:04 <roconnor> asdftimo: bonus points if you continue checking for factors starting where you left off.
11:11:19 <asdftimo> thats what im trying to figure out how to do
11:11:28 <asdftimo> make one pass and find all less than sqrt n
11:11:28 <roconnor> asdftimo: you need a helper function
11:11:54 <asdftimo> can you show me an example of a helper function? (ive never heard of one before)
11:12:05 <roconnor> primefactors n = primefactorsHelper (takeWhile (\x -> x^2 <= n) primelist) n
11:12:15 <lilachaze> asdftimo: i suggest you start by writing a function to find the smallest divisor of n in a given list
11:12:23 <lilachaze> (sorted list)
11:13:15 <lilachaze> asdftimo: then the smallest factor is "smallestDivisor n primes", and by repeated application you can find all factors
11:13:21 <roconnor> primefactorsHelper list_of_primes_to_test n = .... (break (...) list_of_primes_to_test) ....
11:14:23 <asdftimo> so like test n -> [2] -> test (div n 2) -> [3] -> etc.?
11:14:44 <roconnor> hmm
11:14:57 <BMeph> ?wiki helper
11:14:58 <lambdabot> http://www.haskell.org/haskellwiki/helper
11:15:12 <roconnor> you can probably avoid using break
11:15:16 <BMeph> Grr, I thought we fixed that? :|
11:15:37 <roconnor> primefactorsHelper [] n = [n] -- n must be prime if we have run out of primes to test
11:16:14 <asdftimo> ok lemme think about this
11:16:23 <roconnor> primefactorsHelper (p:ps) n | does p divide n = p is a factor, continue testing with ps
11:16:36 <roconnor>                   | otherwise = primefactorsHelper ps n
11:16:55 <asdftimo> i dont understand that syntax (p:ps)
11:17:02 <roconnor> oh
11:17:05 <roconnor> that is very important
11:17:14 <roconnor> it is a pattern
11:17:22 <BMeph> asdftimo: Try reading www.haskell.org/haskellwiki/Worker_wrapper
11:17:40 <roconnor> it matches a list, p is assigned to the head of the list and ps is assigned to the tail of the list
11:18:19 <lilachaze> > smallestDivisor 123 slowprimes
11:18:20 <lambdabot>   Not in scope: `smallestDivisor'
11:18:44 <roconnor> let f (p:ps) = "head: "++show p++"; tail: "++show ps in f [1,2,3]
11:18:49 <roconnor> > let f (p:ps) = "head: "++show p++"; tail: "++show ps in f [1,2,3]
11:18:51 <lambdabot>  "head: 1; tail: [2,3]"
11:18:55 <lilachaze> > smallestDivisor 123 slowprimes
11:18:57 <lambdabot>  3
11:20:24 <luite_> is it possible in haskell to define types and operators for physical units? for example  m/s / 1/s -> m. units of the same type can be added and subtracted, the type system should prohibit operations on incompatible units. there would of course be an infinite number of types.
11:20:47 <lilachaze> luite_: i don't see why not
11:20:48 <roconnor> luite_: yes, but it is crazy
11:21:11 <lilachaze> roconnor: i'm not so sure. the type system would guarantee unit-correctness of your code
11:21:31 <roconnor> lilachaze: oh, it's not a crazy idea, it the implemenation in haskell that is crazy
11:21:33 <luite_> roconnor: I'm not going to actually do it ;) just wondering how it could be done, I'm still a haskell newbie :)
11:21:39 <lilachaze> roconnor: ah, fair enough :)
11:22:11 <lilachaze> roconnor: i've done it in c++ using templates; it's pretty crazy there, but possible.
11:22:25 <roconnor> lilachaze: it's probably similar crazy in haskell
11:22:35 <EvilTerran> i don't think it'd be *that* hard
11:22:42 <luite_> what haskell features would I need?
11:22:51 <EvilTerran> given sufficient restrictions on the units
11:22:58 <roconnor> there is already an implemenation somewhere
11:23:05 <lilachaze> luite_: one of the problems is canonicalization. you need some way of getting all representations of Time^2 Distance^-3 to be the same, or you won't be able to add them
11:23:16 <BMeph> Monads should cover it, but fundeps might make it easier.
11:23:25 <EvilTerran> (ie: units can only be products and fractions of units)
11:23:32 <EvilTerran> BMeph, er, monads?
11:23:36 <lilachaze> luite_: another is that haskell's typeclasses for numerical operations are homogenous, so Time * Distance isn't allowed; you'd need a different operator or a different prelude
11:24:31 <EvilTerran> i think this is the sort of thing that'd be easier with type families than fundeps
11:25:09 <EvilTerran> so you could have a "type family Canon a" or whatever that picks a canonical type somehow
11:25:09 <luite_> lilachaze: seems to me that you just need a specific ordering (but I don't know how to actually do that in haskell). you could always simplify to derived units when printing
11:25:25 <nominolo`> @seen dons
11:25:25 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
11:25:28 <roconnor> @go haskell physical units
11:25:30 <lambdabot> http://liftm.wordpress.com/2007/06/03/scientificdimension-type-arithmetic-and-physical-units-in-haskell/
11:25:30 <lambdabot> Title: Scientific.Dimension: Type Arithmetic and Physical Units in Haskell  Monad.lift ...
11:25:35 <EvilTerran> preflex: seen dons
11:25:35 <preflex>  dons was last seen on #haskell 15 hours, 43 minutes and 55 seconds ago, saying: megacz: yeah, mine too. something happened on the network
11:25:40 <BMeph> EvilTerran: Don't TF's subsume fundeps, or are they (thought of as) orthogonal? :)
11:25:53 <nominolo`> preflex: @info
11:25:57 <EvilTerran> BMeph, they're intersecting, but non-concentric
11:26:03 <EvilTerran> both can do things the other can't#
11:26:05 <EvilTerran> iirc
11:26:06 <lilachaze> luite_: the basics, though: you need to express numbers in the type system. then you probably want a type constructor which effectively acts as a tuple of such numbers, if you don't want an extensible set of base units
11:26:29 <EvilTerran> you can work from the SI units or something
11:26:31 <lilachaze> luite_: if you do want an extensible set of base units, that's harder (i imagine it's still possible, though)
11:26:33 <sclv> I could swear there was a fancy haskell lib for this already...
11:27:02 <luite_> roconnor: but he actually creates all units in advance
11:27:05 <roconnor> http://www.haskell.org/haskellwiki/Libraries_and_tools/Mathematics#Physical_units
11:27:07 <lambdabot> Title: Applications and libraries/Mathematics - HaskellWiki, http://tinyurl.com/hq4t3
11:27:14 * BMeph cringes at the "undecideable instances" declaration in the code at that link.
11:27:37 * BMeph meant the next-to-last link, 'cause he types S-L-O-W... ;)
11:27:57 <lilachaze> luite_: finally, you want a type class for each numerical operation, which will provide a mapping from units to, say products of those units.
11:28:19 <roconnor> http://www.buckwalter.se/~bjorn/darcsweb/darcsweb.cgi?r=dimensional;a=headblob;f=/Numeric/Units/Dimensional/Extensible.lhs
11:28:21 <lambdabot> Title: darcs - dimensional, http://tinyurl.com/6ywgfs
11:28:43 <roconnor> {-# LANGUAGE UndecidableInstances
11:28:47 <roconnor> 30 > , ScopedTypeVariables
11:28:47 <roconnor> 31 > , EmptyDataDecls
11:28:47 <roconnor> 32 > , MultiParamTypeClasses
11:28:47 <roconnor> 33 > , FunctionalDependencies
11:28:47 <roconnor> 34 > , FlexibleInstances
11:28:48 <roconnor> 35 > #-}
11:29:42 <lilachaze> of those extensions, only the first seems particularly smelly
11:29:59 <luite_> roconnor: hm, interesting
11:30:28 <luite_> but I actually hoped for a haskell one-liner ;)
11:31:02 <roconnor> if only we had dependent types
11:31:22 <vixey> noooo
11:31:23 * roconnor looks longingly at Epigram 2
11:31:39 * vixey wisher for Epigram 2 also...
11:33:28 <BMeph> It seems that a lot of what people want to do with Haskell runs into the lack of a simple means of making sub-types (i.e., value-dependent types).
11:35:02 <ski> er "i.e." ??
11:35:15 <roconnor> of course Haskell can do anything.  What people want is to get Haskell to not do things (this is where a type system comes in).  Not doing things like, reformating your hard drive, or setting your house on fire. :)
11:35:41 <mapreduce> The Haskell wikibook is really surprisingly good.  I'd feel confident using it to teach a complete novice.
11:35:43 <BMeph> ski: "i.e. == that is to say, or in other words"
11:35:43 <roconnor> or in luite_'s case, not adding meters and seconds.
11:35:49 <mapreduce> @faq can haskell have good docs?
11:35:50 <lambdabot> The answer is: Yes! Haskell can do that.
11:36:05 <ski> BMeph : i know .. i was questioning its use in that sentence
11:36:53 <BMeph> ski: Okay, so how would you define sub-types, because that's how I would do it (obviusly, since I would have typed something else, otherwise). :)
11:37:06 <BMeph> Er, *obviously
11:37:20 <ski> how would "sub-types" be the same as "value-dependent types" (unless you by the latter means something else than `dependent types' mentioned above)
11:37:47 <ski> ?
11:37:53 <BMeph> That's interesting, that I'd misspell that word in particular... ;)
11:38:18 <BMeph> ski: Can't types also depend on other types? :)
11:38:36 <ski> sure
11:39:40 <BMeph> But those types aren't usually called "dependent types"? :)
11:39:53 <ski> not ime
11:40:10 <mapreduce> H-M allows for parameterised types, but the parameters are always other types, not values.
11:40:17 <vixey> kinds *, sorts []
11:40:23 <vixey> hmmm
11:40:33 <vixey> type *, kinds []
11:40:43 <vixey> no that's not what I meant
11:40:53 <vixey> values *, types []
11:41:00 <EvilTerran> value :: type :: kind
11:41:10 <EvilTerran> types and kinds are both sorts
11:41:30 <vixey> in haskell you have values depending on values (*,*), types on types (*,[]) types on values on types (*,[])
11:41:48 <vixey> humf I got that totally wrong
11:42:59 <EvilTerran> er?
11:45:30 <asdftimo> roconnor: i've got that program working, but i've got some questions about optimization (it's already VERY fast)
11:45:38 <hpaste>  asdftimo pasted "primelist" at http://hpaste.org/8673
11:46:16 <asdftimo> i'm still not just testing primes <= sqrt n: should i be?
11:46:52 <asdftimo> also, im just using primelist, not "takeWhile(<=(div n 2)) primelist": is that ok?
11:48:55 <Peaker> maybe a "metatype" would be a better name?
11:48:57 <int-e> asdftimo: you are only testing primes up to sqrt(n).
11:49:07 <int-e> asdftimo: did you write that code yourself?
11:49:48 <BMeph> Peaker: Better name for what?
11:49:56 <Peaker> BMeph, for kinds
11:50:30 <asdftimo> int-e: crap you are right. i put the p^2 >n in there to stop it, i didn't realize that filtered the list, too.
11:52:52 <glguy> x
11:55:00 <BMeph> y
11:58:45 <int-e> asdftimo: you can generate primes quite a bit faster, with a bit of effort. see  http://www.haskell.org/haskellwiki/Prime_numbers#Bitwise_prime_sieve  for example
11:58:46 <lambdabot> Title: Prime numbers - HaskellWiki, http://tinyurl.com/2wtgwb
12:01:33 <asdftimo> thanks for the link int-e
12:02:18 <asdftimo> i wish i could understand that, i just started learning haskell the other day. i'll have to work up to it
12:07:39 <asdftimo> how can i count how many times a given number occurs in a list?
12:08:22 <paolino> length . filter
12:08:34 <asdftimo> great, thanks.
12:10:07 <gwern> `hey, if anyone with cabal-install has some spare time, try 'cabal update && cabal install darcs-cabalized' pls?
12:12:23 <asdftimo> can someone tell me what "encode" does and what i have to import to use it?
12:12:47 <Peaker> @hoogle encode
12:12:48 <lambdabot> Prelude.encodeFloat :: RealFloat a => Integer -> Int -> a
12:12:48 <lambdabot> Network.CGI.formEncode :: [(String, String)] -> String
12:12:48 <lambdabot> Network.CGI.urlEncode :: String -> String
12:13:07 <dmead> ?src take
12:13:07 <lambdabot> take n _      | n <= 0 =  []
12:13:07 <lambdabot> take _ []              =  []
12:13:07 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
12:13:11 <paolino> Binary.encode
12:13:11 <dmead> ?src takeWhile
12:13:11 <lambdabot> takeWhile _ []                 =  []
12:13:11 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
12:13:11 <lambdabot>                    | otherwise =  []
12:13:55 <paolino> gwern, hackage is slow !
12:14:24 <gwern> paolino: alas!
12:14:36 <gwern> we have always depended on the kindness of strangers
12:14:50 <paolino> 7 kb/s here
12:15:12 <gwern> `ouch
12:15:45 <paolino> now it's dead
12:16:57 <Peaker> gwern, its compiling it now
12:17:04 <paolino> gwern should I kill it ?
12:17:28 <Peaker> @type Binary.encode
12:17:29 <lambdabot> Couldn't find qualified module.
12:17:31 <gwern> paolino: personally, if your connection to hackage is that bad, I think I' copy the address and have wget grab it in the background
12:17:34 <gwern> (`or the browser)
12:17:41 <Peaker> @hoogle Binary.encode
12:17:42 <lambdabot> No matches, try a more general search
12:18:24 <paolino> Peaker: hoogle should be better at the end of hsoc, if I remember right
12:19:44 <Peaker> quite a compilation, darcs is
12:22:26 <paolino> http://code.haskell.org/binary/
12:22:26 <lambdabot> Title: Data.Binary - efficient, pure binary serialisation for Haskell
12:22:27 <gwern> oh yes
12:22:46 <gwern> `I consider darcs to be an excellent example of why you want to aggressively split stuff out to libraries
12:23:03 <gwern> `and how autotools is broken and discourages doing so, and encourages monolithic stuff
12:24:00 <nominolo`> ugh, "liftM3 OpE  get get get" we nowadays spell that OpE <$> get <*> get <*> get
12:24:16 <Peaker> why is Binary not declarative? :(
12:24:22 <Heffalump> get get get!
12:24:54 <paolino> ok, I suppose cabal install is broken, if it doesn't stand the slow connection to hackage, and dies in the mean
12:25:33 <nominolo`> Peaker: it just needs an Applicative instance
12:25:47 <Peaker> nominolo, I think it needs some combinators
12:25:51 <gwern> Peaker: what would declarative be? Data.Binary.have?
12:25:56 <Peaker> nominolo, Having to specify both get and put...
12:26:02 <Peaker> s/Having/Not having
12:26:37 <nominolo`> Peaker: right, something more like pickler combinators which ensure the bijective property would be nicer
12:26:42 <Peaker> for example, the example using a type-tag there, should declaratively specify it starts with a tag, and that the tag chooses amongst two options. the get/put should be derived from that
12:26:52 <Peaker> nominolo, yeah, that's what I mean
12:27:13 <nominolo`> i guess that could still be layered on top
12:27:20 <Peaker> gwern, it seems to compile OK so far (I am lacking libcurl-dev on Ubuntu, installing it now)
12:28:02 <nominolo`> though, ben pierce's language that has such property requires a really sophisticated type system, so he advocates contracts instead
12:28:03 <Peaker> oh, sadly "cabal install" doesn't cache failing builds.. its starting the huge build process from scratch :(
12:28:15 <nominolo`> Peaker: that's a good thing
12:28:22 <Peaker> nominolo, why?
12:28:35 <leoncamel> how can I get a cube root of a integer ?
12:28:37 <nominolo`> Peaker: you can never be sure what went wrong and what can be reused
12:28:37 <Peaker> nominolo, I'd like it to try and continue where it failed before
12:28:48 <Peaker> nominolo, oftentimes I'm just missing a header or a library
12:28:59 <nominolo`> yes, but hten you need to re-configure
12:29:06 <Peaker> nominolo, why?
12:29:09 <nominolo`> which changes pre-processor macros
12:29:22 <Peaker> nominolo, well, configure here didn't check for that library
12:29:30 <mauke> > 42 ** (1/3)
12:29:34 <lambdabot>  3.4760266448864496
12:29:40 <Peaker> gwern, the configure script may need to check for libcurl (it passed and later failed to link against curl)
12:29:50 <nominolo`> so, i'm not saying it can't be done, but it is very hard to get working reliably
12:29:56 <paolino> :t (**)
12:29:57 <lambdabot> forall a. (Floating a) => a -> a -> a
12:30:10 <nominolo`> pi ^ 2
12:30:12 <gwern> Peaker: how do you mean?
12:30:16 <saml> i think cube root is not closed under Integer
12:30:17 <nominolo`> > pi ^ 2
12:30:19 <lambdabot>  9.869604401089358
12:30:25 <saml> no, Integer is not closed under cube root
12:30:27 <leoncamel> mauke: Aha.. so beautiful ...
12:30:33 <Peaker> gwern, well, I think if I am lacking libcurl it should fail at the configure stage, but it failed at the linking stage instead
12:31:48 <nominolo`> Peaker: then the correct solution would be to check that before compiling
12:31:56 <gwern> Peaker: oh, yeah, I' not surprised
12:32:34 <Peaker> gwern, seems to install successfully now
12:33:14 <gwern> Peaker: currently the cabal file assumes you want to use libcurl
12:33:15 <Peaker> hmm, bash can't handle binaries disappearing from under its feet
12:33:27 <mauke> hash -r
12:33:35 <Peaker> mauke, thanks
12:33:37 <gwern> I don' really know how to get ./configure to tell configure that libcurl-finding failed
12:33:40 <Peaker> gwern, I don't mind, just that it failed in the wrong stage
12:33:44 <gwern> `in that case, you need to pass the flag
12:33:52 <gwern> `set the curl flag =false
12:34:01 <Peaker> gwern, ok, anyhow, if you wanted to know if it builds and installs, it does
12:34:11 * gwern forgets the CLI syntax to set flags like that tho
12:35:14 <gwern> Peaker: well, I also want to know if it works! :)
12:35:20 <Peaker> I hate configure scripts. How did a relatively simple problem get blown to such epic complexity proportions?
12:35:42 <Riastradh> When it became a problem that is not, in fact, relatively simple.
12:36:13 <gwern> yeah. I mean, what were they going to do, write it in C?
12:36:20 <Peaker> Riastradh, why not? what's so complicated about finding a bunch of dependencies?
12:36:59 <gwern> Peaker: the issue is about enabling disabling stuff
12:37:18 <asdftimo> how can you append an item to the end of a list?
12:37:25 <gwern> autotools is intended to run on every platform under the sun, and will compromise any principle to do so
12:37:32 <Riastradh> Peaker, `finding a bunch of dependencies'.  Consider a dozen different Unix variants that all have different conventions for placing libraries and different, incompatible compiler switches, and incompatible system library variants, &c.
12:37:35 <asdftimo> like [1,2,3]:4 except that doesnt work
12:37:50 <Peaker> asdftimo, ++ would work. maybe mappend is good too (though need to import a Monoid instance)
12:37:53 <gwern> asdftimo: ++ maybe?
12:38:01 <asdftimo> ok thanks guys ill try that
12:38:24 <gwern> asdftimo: of course, 1:2:3:4:[] would work
12:38:34 <Peaker> Riastradh, I don't see why abstracting all these differences behind a _simple_ layer is so difficult..
12:38:48 <Peaker> Riastradh, and why configure has to include all of the "abstraction" within it
12:39:07 <asdftimo> gwern, yes, but i have a definition for a list and i would like to append 1 in the def
12:39:43 <asdftimo> how is '++' used?
12:39:48 <asdftimo> i cant seem to figure it out
12:40:13 <Riastradh> Peaker, there are thousands of dimensions along which one can have differences, and they're not all independent.  There are n different Unix standards to choose from, and most Unices aren't really fully compliant with any of them.  I said a dozen different Unix variants -- if you support only a dozen Unix variants, then you will manage only a minuscule fragment of what autoconf deals with.  Throw Windows and two dozen more Unix va
12:40:14 <Peaker> Riastradh, or why 4-level-deep code generation is needed, rather than a simple declaration read by some fixed tool (package manager?) that is either preinstalled or shipped with it to avoid an extra dependency
12:40:26 <gwern> asdftimo: your [1,2,3,]:4 example doesn' work because of bad syntax
12:40:26 <gwern> > [1..3] ++ [4]
12:40:28 <lambdabot>  [1,2,3,4]
12:40:47 <gwern> > [1..3] : 4 : []
12:40:48 <lambdabot>   add an instance declaration for (Num [t])
12:41:05 <gwern> > 1:2:3 : 4 : []
12:41:05 <Peaker> Riastradh, Well, for example, setup.py builds Python modules (including C ones) on a lot of unixes successfully, without being a horrrible complex beast
12:41:07 <lambdabot>  [1,2,3,4]
12:41:30 <smtms> but it relies on Python, a luxury that autotools don't have
12:41:45 <Riastradh> Some fixed tool as complicated as a package manager?  You're optimistic!  Autoconf assumes a minimal sh, and maybe ls; good luck if you can manage anything beyond that.
12:42:40 <Peaker> smtms, well, relying on unix shells is better than relying on python? if so - implement Python on a Unix shell :) Or implement setup.py in shell scripting (not nice, but cannot be as horrible as configure)
12:43:04 <gwern> yeah, what Riastradh is saying. I hate autotools, but I do recognize its utility. fortunately, we generally don' need to run on 2 dozen different unixes as they'e done us the favor of dying off
12:43:05 <Peaker> Riastradh, I think that reading through configure scripts, I see bash-reliance
12:43:39 <gwern> (if it runs on Linuxes, Windows, Mac, and the 3 main BSDs, that is more than enough for me)
12:43:40 <Peaker> gwern, seems to work too
12:43:40 <Riastradh> Peaker, that is generally a mistake on the part of the authors of the corresponding configure.{ac,in} files.
12:43:47 <Peaker> gwern, (darcs)
12:43:56 <gwern> ah, good
12:44:02 <gwern> so has anyone else tried?
12:44:21 <gwern> preflex: seen dc-Ankan
12:44:21 <gwern> `er.
12:44:21 <Peaker> Riastradh, Even with all these restrictions, 4-level deep shell/shell-like code generation there is not justified..
12:44:22 <preflex>  Sorry, I haven't seen dc-Ankan
12:44:25 <gwern> preflex: seen dcoutts
12:44:26 <preflex>  dcoutts was last seen on #haskell 3 hours, 12 minutes and 43 seconds ago, saying: roconnor: a cairo wrapper need not be stateful at all
12:44:31 * BMeph works on a Windows machine, so won't be trying it...
12:44:58 <Riastradh> Peaker, why not?
12:45:13 <Peaker> Riastradh, Because its complicated, and without it, it would be far simpler
12:46:10 <gwern> @ask dcoutts you said .cabal/config supports profiling option? are you sure? last time I was looking through the source, library profiling seemed to be one of the omitted options
12:46:10 <lambdabot> Consider it noted.
12:46:17 <Peaker> Riastradh, since configure has to run on /bin/sh - you may want to generate that. It too would want to generate Makefiles because they're willing to rely on make for some reason.  That's 2 levels. But the code that generates the configure script has no restrictions and as such there's no point in adding another 2 layers of code generation
12:46:38 <Peaker> Riastradh, (not to mention that make is horribly broken and its use by configure is unfortunate too)
12:46:59 <Peaker> a myriad of crappy and limited scripting languages, yuck :(
12:47:25 <gwern> I still find reading the make guy' reminscence fascinating
12:47:47 <gwern> but by then I had 8 users and did not want to break their makefiles, so I left tab alone
12:47:49 <Riastradh> Peaker, what are the other two layers to which you refer?
12:47:52 <gwern> `to paraphrase
12:48:22 <Peaker> Riastradh, ac4, iirc.  Not sure if there's another one or if I'm just exaggarating :)
12:48:44 <Riastradh> ac4?
12:48:56 <Peaker> well, configure.ac -> configure.in -> configure
12:49:16 <Riastradh> Huh?
12:49:23 <Peaker> that's a setup I've seen used in various source packages
12:49:27 <gwern> @tell dons my upload of collections was hardly a fork given that it was jpb who made the new packages and accepted my patches into upstream darcs -_-
12:49:27 <lambdabot> Consider it noted.
12:49:38 <Riastradh> `.ac' and `.in' are just two alternate extensions for the input to autoconf whose output is the configure script.
12:49:49 <Riastradh> I think that `.ac' is the one that GNU currently recommends.
12:49:59 <Riastradh> I've never seen configure.ac -> configure.in -> configure.
12:51:28 <Peaker> Riastradh, I see. Maybe I was exaggarating then.  There are the Makefile templates too.  I think we should have a declarative DSL to specify the project, and have all derive from that
12:52:20 <Peaker> its kind of arbitrary that we're willing to depend on make and sh, but not on Python and bash, too
12:52:58 <Riastradh> make and sh are practically reliable.  Python and bash are not, unless you really want to limit the scope of your audience.
12:53:24 <Peaker> well, nowadays users are using .deb/.rpm and exe installers, thankfully
12:54:19 <Riastradh> I'm not using .deb or .rpm, and I don't know what an `exe installer' is.  Software prepared only as .deb or .rpm is not very useful to me.
12:54:35 <gwern> Riastradh: 'really'? python and bash work fine on the big 6, which is such a huge proportion of the market
12:54:55 <roconnor> asdftimo: I'm back. Did you get your questions answered?
12:54:59 <gwern> `geez, adding up linux/windows/mac/bsd must give you 99.9% of the non-embedded market surely
12:55:31 <Peaker> Riastradh, what system are you using?
12:55:36 <Riastradh> gwern, sure, and so can J. Random Other Scripting Language I can build and install on those operating systems.
12:55:48 <Riastradh> gwern, I can write my own scripting language that will work on those systems, too.
12:56:14 <gwern> Riastradh: I don' follow
12:56:27 <Riastradh> gwern, maybe we ought to use that one, then.  But someone else will want to use Ruby, and another person will want to use JavaScript, and yet another fellow wants to use Scheme, and another wants to use Haskell, and still another will write another one.
12:56:46 <Riastradh> Which ones do the Unix vendors actually distribute?  sh.
12:57:11 <mauke> and perl
12:57:22 <Riastradh> Sometimes Perl.
12:57:46 <gwern> Riastradh: that' not a bad thing. all those high level languages seek to provide similar facilities, and place similar demands on the lower levels to clean up their act
12:58:13 <gwern> `I suspect that anything python has been will be that much easier for perl and scehem and haskell to follow
13:00:51 <Riastradh> You can use whatever fancy tools you want in your software, and whatever fancy tools you want to generate the scripts that generate the configuration scripts, but if you want the installer to work easily, or report why it doesn't work, nearly everywhere, then autoconf has a decent chance of actually accomplishing that.
13:14:30 <heavensrevenge> hello
13:14:56 <heavensrevenge> whoever is maintaining the darcs-cabalized cabal package on hackage
13:15:34 <heavensrevenge> i thought its description of darcs was "David's Advanced Revision Control System" and not "David's Advanced Version Control System"
13:15:53 <heavensrevenge> to me its a bug and just wanted to point it out
13:17:14 <asdftimo> roconnor: hi. yes, i think i got all of my questions answered. the functions seem to fun reasonably efficiently. im going to update them later when i know more about haskell. im writing a larger program for a math project im doing and im running it right now. it seems to be doing fine. thanks for yoru help.
13:19:11 <gwern> heavensrevenge: I think I got that description from the original darcs paper
13:19:12 <gwern> `lemme check
13:19:35 <heavensrevenge> sounds good
13:20:13 <heavensrevenge> i have it in my rss which i follow quite diligently, and it stuck out with a sore thumb for some reason lol
13:20:24 <heavensrevenge> but i may be wrong aswell
13:24:18 <andyjgill> @seen conal
13:24:18 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
13:24:34 <EvilTerran> preflex: seen conal
13:24:35 <preflex>  conal was last seen on #haskell 3 days, 59 minutes and 50 seconds ago, saying: Peaker: have you implemented your idea?  if not, could you prototype it for lists?
13:24:43 <monochrom> <3 lambdabot
13:24:48 <monochrom> @botsnack
13:24:48 <lambdabot> :)
13:25:28 <monochrom> preflex knows famous last words. :)
13:25:28 <gwern> heavensrevenge: looks like you were right
13:25:31 <andyjgill> At least someone knows how to use the commands here.
13:25:37 <byorgey> davcs?
13:25:40 <gwern> `eh, revision, control, they'e so similar
13:25:49 <EvilTerran> andyjgill, @seen should work, but it's broken atm
13:26:24 <andyjgill> I thought that was the command.
13:29:12 <andyjgill> Do we have a good solution to pre-compiled arrays and other static data in Haskell> Or should I encode things in strings (like the old days)?
13:29:35 <chessguy> byorgey: dude, what are you doing?
13:29:39 <chessguy> it's only been, like, a week since HWN came out last!
13:29:46 <byorgey> hehe
13:29:52 <Peaker> andyjgill: you can either de-serialize them from files, or just generate Haskell code?
13:29:59 <Heffalump> andyjgill: I believe it's been discussed a bit and none exists at the moment.
13:30:03 <byorgey> chessguy: all part of my evil plan.
13:30:14 <chessguy> byorgey: seriously, well-done
13:31:02 <byorgey> step 1: publish HWN more and more frequently until everyone gets completely sick of it   step 2: ... (TBD)  step 3: profit
13:31:38 <chessguy> haha
13:31:43 <andyjgill> I've got some textures I want to pre-load, and was wondering if anyone had got fast, compiled in serialization working.
13:31:53 <chessguy> "pay $5/week to NOT get HWN! it's a great deal!
13:32:01 <byorgey> chessguy: ah, great idea!
13:32:17 <byorgey> sell unsubscriptions
13:33:14 <byorgey> chessguy: if you help me out by complaining loudly about how annoying the HWN is I'll give you a 20% cut
13:35:15 <gwern> byorgey: actually, for this/next HWN, I' be appreciative if you would omit darcs-cabalized
13:35:49 <byorgey> gwern: ah, hackage uploads aren't listed in the HWN anymore anyway
13:36:05 <byorgey> only if you actually announce it in a message to haskell@ or haskell-cafe@
13:36:17 <gwern> `oh, ok. jes'makin'sure
13:36:22 <byorgey> yep
13:39:01 * gwern wonders why cabal checks for greencard' presence when I have never seen any cabalized package ever used it
13:39:52 <gwern> *which
13:42:22 <gwern> `'ficials at HWN headquarters have released a statement reversing their previous position regarding the existence of Thomas, citing regrettably faulty information to explain their previous misapprehensions. Expect to hear more from Thomas soon, now that he has finished graduating and moving.'`
13:42:34 <Heffalump> lol
13:44:21 <vininim> OT: Does anybody know if "Pratical Foundations of Mathematics" online version is really supposed to have strange accented letters and simbols?
13:45:10 <gwern> `hee hee
13:45:21 <BMeph> isn't that a self-refuting name, "Pratical Foundations of Mathematics"? ;)
13:45:37 <nominolo`> gwern: someone's head is gonna roll for that at HWN HQ
13:45:51 <lament> practical foundations of mathematics, in one sentence: Shut up and calculate!!!
13:45:59 <gwern> `'does anyone know if mathematics is supposed to have strange accented leters and symbols?' <-- sorry, if you want non-strange symbols, you'll need to study someone like sussman who prefers PL notation
13:46:25 <Peaker> augustss: I opened your blog and the last entry is the Expr one from March 09, I demand some new material :)
13:46:46 <gwern> nominolo`: hey, I heard you didn' exist!
13:47:09 <joey_> It's a bot
13:47:09 <nominolo`> maybe i'm transparent
13:47:16 <nominolo`> yeah, or that
13:47:16 <joey_> A very convincing one
13:47:20 <Heffalump> nominolo`: you are quite thin
13:47:50 <nominolo`> Heffalump: right, this must have caused this
13:47:54 <vininim> gwern: haha no, I mean, I just want to know if it's not a technology problem. =)
13:48:17 <Heffalump> have you been eating properly? Perhaps you've faded away to nothing..
13:49:41 <monochrom> where do I find strange accented letters and symbols?
13:49:46 <nominolo`> maybe there was something in the food
13:49:56 <heatsink> monochrome: Europe?
13:50:01 <vinicius> Ú
13:50:13 <vinicius> or maybe it's really Ú
13:50:50 <monochrom> No, I mean the practical foundation of mathematics website.
13:51:32 <vinicius> http://www.cs.man.ac.uk/~pt/Practical_Foundations/
13:51:33 <lambdabot> Title: Practical Foundations of Mathematics
13:52:15 <monochrom> Oh, Paul Taylor is cool.
13:52:16 <jsnx> @seen Cale
13:52:17 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
13:52:25 <jsnx> !!
13:52:28 <gwern> Heffalump: that would be funny, except godel killed himself/died of that
13:52:33 * heatsink bookmarks it
13:52:51 <therp> Gödel killed himself?
13:53:02 <heatsink> He starved himself to death.
13:53:36 <gwern> `'inanition, as the laconic coroner's report put it'
13:53:36 <gwern> `
13:53:54 <monochrom> There are all these "=0pt" "=2pt" indicating a disturbingly buggy converter from LaTeX to HTML.
13:54:12 <therp> heatsink: strange.
13:54:34 <vinicius> yes, it's really cruel marketing to give us bad html and give a reasno to buy the deadwood paper =)
13:54:50 <vinicius> *version
13:56:55 <monochrom> The strange accented letters are due to the 19th Century habit of using things like <font face=symbol>ï</font> in an attempt to avoid living up to the 21st Century and knowing the difference between font and character set.
13:57:04 <Heffalump> gwern: I don't think that fact has any impact on the funniness or otherwise of my comment. Godel's death is hardly at the forefront of most people's minds.
13:57:14 <zem> g'day
13:57:18 <monochrom> (repeat) The strange accented letters are due to the 19th Century habit of using things like <font face=symbol>ï</font> in an attempt to avoid living up to the 21st Century and knowing the difference between font and character set.
13:59:08 <heatsink> Oh, I see what you mean.
13:59:31 <heatsink> How is browser support for unicode math characters nowadays?
14:00:23 <monochrom> Superb.
14:01:10 <monochrom> see http://www.vex.net/~trebla/u.html for example
14:01:11 <lambdabot> Title: Gödel ist Groß
14:02:26 <zem> how do i supply a foreign function a CInt?
14:03:05 <zem> e.g. from http://hackage.haskell.org/packages/archive/X11/1.4.2/doc/html/Graphics-X11-Xlib-Extras.html WMHints has wmh_initial_state :: CInt	
14:03:06 <lambdabot> http://tinyurl.com/59ctet
14:03:08 <heatsink> I can even read that in konqueror.  I didn't expect to have preinstalled fonts on linux.
14:03:22 <BMeph> zem: Why would you? Surely, it would be better able to supplu itself with a CInt? :)
14:04:08 <zem> not sure how ffi works exactly :) i'm just trying to use Xlib
14:04:21 <monochrom> Oh, that is not supplying a foreign function a CInt. That is a foreign function supplying a CInt.
14:04:26 <BMeph> heatsink: If you didn't expect pre-installed fonts on linux, how would you hope to be able to read...Anything? ;)
14:04:28 <zem> there's setWMHints :: Display -> Window -> WMHints -> IO Status which needs to be passed a WMHints
14:05:03 <zem> but i can't manage to construct a WMHints to pass it
14:06:52 <jsnx> yeah, i know a dude who killed himself
14:06:59 <jsnx> he just kept getting older and older
14:07:04 <jsnx> he wouldn't stop
14:07:11 <jsnx> and then, he died
14:07:31 <zem> and was garbage collected with the rest?
14:09:06 <jsnx> @msg lambdabot are you sick?
14:09:06 <lambdabot> Not enough privileges
14:10:47 <ddarius> The Haskell community is crazy.
14:11:00 <jsnx> ddarius: oh
14:11:04 <jsnx> that's what happened
14:11:17 <jsnx> i haven't been back in awhile
14:11:58 <jsnx> ddarius: do you know about adjoint functors? i am learning about them, but am confused.
14:12:06 <ddarius> Yes.
14:12:47 <jsnx> ddarius: so, consider ceiling :: Real -> Int and inclusion :: Int -> Real
14:13:14 <monochrom> Some expositions are confusing. Also the idea itself is a lot of stuff to tract.
14:13:21 <jsnx> ceiling is "left adjoint" to inclusion
14:13:55 <jsnx> what i can't figure out in this case is, could it be right adjoint, as well?
14:14:34 <jsnx> monochrom: i'm reading "category theory for computer scientists" and the treatment is brief
14:14:36 <ddarius> jsnx: You need to describe/think about what the categories are in more detail.  To answer your question though, floor is the right adjoint.
14:15:00 <ddarius> Also, this is a rather special case of an adjunction called a Galois connection.
14:15:41 <jsnx> okay, well the categories are Int which has Z in it with the partial order <= and Real which has R in it with the partial order <=
14:15:54 <jsnx> ddarius: yes, it is a galois connection
14:16:23 <monochrom> Oh! That is a short book, but a pretty clear one. You have to do all exercises to gain the most out of it.
14:16:42 <jsnx> monochrom: i do like 50% of exercizes
14:17:19 <jsnx> ddarius: so, floor is right adjoint to inclusion, or right adjoint to ceiling?
14:17:25 <ddarius> inclusion.
14:17:35 <jsnx> ddarius: okay, could you explain that?
14:18:11 <ddarius> jsnx: What definition of "adjunction" do you know or do you want to use?
14:18:12 <monochrom> Verify that the pair satisfies all the adjunction requirements.
14:18:22 <monochrom> (Some requirements become trivial.)
14:18:23 <jsnx> ddarius: hmm
14:20:15 <jsnx> in the ceiling case, let's apply the definition that would say "there is an exact correspondence between arrows ceiling(r) -> j and arrows r -> inclusion(i)"
14:20:37 <ddarius> Yep.  So spell that out.  What does that mean for the categories involved?
14:20:47 <ddarius> s/i/j
14:20:56 <jsnx> ddarius: yes
14:20:57 <jsnx> sorry
14:21:40 <jsnx> well, to be honest, it seems wrong to me
14:22:00 <ddarius> It's not.
14:22:12 <jsnx> there are far more arrows r <= inclusion(j) then there are ceiling(r) <= j
14:22:41 <ddarius> jsnx: There is at most one arrow in either of those cases.
14:22:55 <ddarius> What are the arrows of Real?
14:23:03 <monochrom> It is Benjamin Pierce's "cat theory for c s-ists" definition. It has functors F,G, nat trans η : Identity Functor over C -> G∘F, forall f:X->GY exists unique f# : FX->Y  with G(f#)∘η = f
14:23:07 <jsnx> for each r in (floor(r), ceiling(r)] there is one arrow on the right, but many on the left, yes no?
14:23:22 <jsnx> ddarius: the arrows of Real are also <=
14:23:41 <ddarius> jsnx: That sentence doesn't make sense.
14:23:46 <jsnx> monochrom: yes, that is one of his definition
14:23:54 <BMeph> jsnx: ddarius is Strong in Category-Fu. :)
14:23:54 <jsnx> ddarius: which sentence?
14:24:03 <monochrom> the arrows of Real are deriving from the partial order <=
14:24:08 <ddarius> [16:23] <jsnx> ddarius: the arrows of Real are also <=
14:24:13 <monochrom> s/deriving/derived/
14:24:19 <jsnx> ddarius: okay
14:24:24 <Mitar> is there any quaternions implementation in Haskell around?
14:24:41 <jsnx> the arrows of Int are <=Z and the arrows of Real are <=R
14:24:43 <ddarius> Mitar: Complex (Complex Real)
14:24:45 <jsnx> ddarius: how is that?
14:25:02 <jsnx> BMeph: yes, i am trying to receive his teaching
14:25:08 <monochrom> But to pin it down explicitly, you have to say "there exists unique arrow from X->Y iff X<=Y".
14:25:17 <ddarius> jsnx: Just as non-sensical.  Choose two objects and describe the arrow between them.
14:25:39 <jsnx> oh, i see
14:26:20 <jsnx> as monochrom has written, there is a unique arrow from r to s if r <= s
14:26:42 <jsnx> and similarly in Int, there is a unique arrow from i to j if i <= j
14:27:15 <ddarius> jsnx: He is correct.  One way to have that be more concrete is to say that an arrow i -> j is a proof that i <= j.  But, anyway, what does the adjunction definition then become now?
14:28:15 <jsnx> it says there is an exact correspondence between proofs of less-than-or-equal-to-ness in Int and those in Real
14:28:46 <jsnx> but that seems off to me, because there are so many more numbers in R, and there must be more proofs in consequence
14:28:59 <ddarius> jsnx: You don't have to worry about the "proofs" part, it's just a point of view that can be helpful sometimes.
14:29:00 <monochrom> That's a wording for the rough idea. Try to make it explicit.
14:29:19 <monochrom> (I'm referring to "exact correspondence")
14:29:38 <jsnx> well, exact correspondence means one-for-one correspondence
14:29:40 <ddarius> jsnx: Take the statement you had before: ceiling(r) -> i  ~ r -> inclusion(i) and write out what it means using the definition of -> monochrom gave.
14:30:47 <jsnx> ceiling(r) <= j ~ r <= inclusion(j)
14:31:05 <jsnx> oic
14:31:17 <jsnx> so it's not one-to-one correspondence
14:31:25 <jsnx> it's just, uhm, something else
14:31:34 <jsnx> equivalency
14:31:43 <monochrom> It is the next best thing when one-to-one correspondence is impossible.
14:32:09 <jsnx> okay, so i was misreading "exact correspondence" as one-to-one correspondence
14:32:14 <ddarius> jsnx: It works out to that.  It's still a natural bijection between homsets, but either the homset has an element or it does not.
14:32:23 <monochrom> That is why I categorized that as rough wording.
14:33:08 <ddarius> So Hom(a,b) is either {} or {*} and we can just view that as being a boolean.  So Hom(a,b) = true if a <= b, false otherwise
14:33:22 <jsnx> ddarius: it's a one to one correspondence between single element homsets in Int and multi-element homsets in Real?
14:33:39 <jsnx> oh, no
14:34:03 <monochrom> a homset on the Real side is also either {} or {*} since it comes from <= for reals.
14:34:38 <jsnx> yeah, but...there are whole bunch of reals that are going to get dumped onto the same int by ceiling
14:34:51 <jsnx> and they will consequently share an arrow in Int
14:35:18 <monochrom> The functors "inclusion", "ceiling" aren't bijections over the objects. But we settle for the next best thing, that is, # is a bijection over the homsets.
14:35:33 <jsnx> # ?
14:35:39 <monochrom> The # in "f#"
14:35:44 <jsnx> oic
14:35:58 <tomh> haskell doesn't have anything like a way to access class properties right?
14:36:12 <monochrom> What is class property?
14:36:22 <Rebooted> tomh: how do you mean?
14:36:31 <monochrom> BTW haskell can't launch class actions either :)
14:36:34 <tomh> like user.getLastName()
14:36:40 <jsnx> monochrom: okay, so, how do we have a bijection of the homsets? wouldn't here be way more homsets in Real then there are in Int?
14:36:57 <jsnx> tomh: those things go in modules
14:37:11 <jsnx> tomh: oh wait
14:37:16 <jsnx> tomh: those things go in records
14:37:26 <jsnx> tomh: you mean object properties
14:37:26 <tomh> are those records like erlang records?
14:37:29 <tomh> ye
14:37:35 <tomh> dunno the exact name
14:37:40 <jsnx> tomh: they can be
14:38:00 <jsnx> tomh: however, there are few different ways to accomplish structs in haskell
14:38:15 <jsnx> (that is how you should think of them: as structs)
14:38:19 <tomh> ok
14:38:32 <jsnx> (they do not have 'methods')
14:39:04 <jsnx> tomh: if you can come up with an example for us, you'll get much better help
14:39:05 <tomh> the thing i was looking for was actually to store for example a database record in a class or struct
14:39:34 <monochrom> Pick two objects X, Y.  There is homset(X,GY); there is also homset(FX,Y).  They are in bijection.
14:39:49 <tomh> like from the user table it has the fields: username, password, firstname, lastname
14:39:56 <jsnx> monochrom: okay, let me think about this
14:40:17 <monochrom> In the present example, this is boring, since it happens that either both are {} or both are {*}. So of course they are in bijection.
14:40:27 <monochrom> But there are interesting examples.
14:40:39 <tomh> i want to put those into a struct and be able to access each property seperatly without having to give them all as left hand side of a function
14:40:50 <tomh> (the only way im aware to access the properties)
14:40:59 <jsnx> tomh: then you need records
14:41:13 <monochrom> credo in recordus
14:41:16 <tomh> ok i will google records
14:41:24 <monochrom> non credo in objectus
14:41:48 <tomh> its quite new or ?
14:42:01 <tomh> first few google resutls show some debase
14:42:03 <tomh> *debate
14:43:18 <jsnx> monochrom: okay, that is interesting about the {} and {*} bit
14:43:42 <jsnx> tomh: it's not new, but it's been up for review and reform
14:44:17 <tomh> ah i see
14:44:31 <jsnx> it seems that what you really want is a generic class, DataBaseTableRow
14:44:42 <tomh> back in the days when i had haskell courses there were no such things yet :P
14:44:56 <tomh> jsnx: well i like the idea of an ORM
14:45:01 <jsnx> which will have accessor methods for each of the fields
14:45:03 <tomh> so map my data to structures
14:45:14 <jsnx> well, you can't have that
14:45:18 <tomh> or classes in OO languages :)
14:45:22 <jsnx> (generic classes)
14:45:34 <jsnx> you can't have duck typing
14:45:49 <tomh> with the record system i can map records to db records right or?
14:46:03 <jsnx> tomh: well, that is one way to do it
14:46:21 <jsnx> for each such record, you define a data structure that contains it
14:46:28 <jsnx> then you model a table as a list of records
14:46:35 <tomh> yup
14:46:39 <jsnx> then you write functions that handle each record type
14:46:50 <tomh> mm
14:47:00 <jsnx> or you put them all in a type class, but then you are going to less the specificities of each record
14:47:20 <jsnx> s/less/lose/
14:47:37 <jsnx> surprise, surprise
14:47:41 <jsnx> no duck-typing
14:47:54 <monochrom> monkey-typing
14:48:05 <jsnx> that's a ruby-only thing
14:48:28 <ddarius> It's certainly not ruby-only.
14:48:35 <ddarius> I'm pretty sure the term is older than ruby.
14:48:46 <jsnx> monkey-patching?
14:49:09 <tomh> is the records thing still experimental or?
14:49:21 <jsnx> tomh: no, it's been in use for awhile
14:49:35 <tomh> for how long, do you know?
14:49:39 <jsnx> tomh: but i think you are basically importing the wrong perspective
14:49:47 <jsnx> tomh: long time, don't know
14:49:53 <tomh> im a die hard OO programmer :P
14:49:59 <yitz> tomh: records are haskell 98
14:50:06 <tomh> ok
14:50:21 <jsnx> tomh: well, go back on the horse your rode in on -- it's not going to work here
14:50:25 <monochrom> I'm afraid haskell is a die hard anti-OO language.
14:50:40 <ddarius> @quote short.guide
14:50:40 <lambdabot> No quotes match. And you call yourself a Rocket Scientist!
14:50:55 <tomh> well the record thing seems to suite my needs
14:50:57 <tomh> partially
14:50:59 <Botje> OO users die very easily -- just put a design pattern and some shiny UML diagrams in a room and suck it vacuum
14:51:04 <jsnx> tomh: data does not have behaviour in haskell
14:51:24 <tomh> ye i know
14:51:39 <jsnx> tomh: anyways, let us know how far you get
14:51:51 <jsnx> we've all had to make the transition you're about to go through
14:52:00 <tomh> hehe
14:52:09 <ddarius> jsnx: Not everyone.
14:53:23 <tomh> its a long time ago since i last touched haskell
14:53:28 <tomh> maybe 3 years or so
14:54:13 <tomh> thought haskell might be a good way to do some datamining on my database
14:54:56 <tomh> so thats the reason i was looking for structs so i dont have to build functions with a parameter for each field in the record
14:55:26 <hpaste>  morrow pasted "foldlCnt" at http://hpaste.org/8674
14:55:27 <yitz> @faq Is haskell a good way to do some datamining on a database?
14:55:27 <lambdabot> The answer is: Yes! Haskell can do that.
14:55:50 <tomh> haskell can do anything as far as i know :P
14:56:03 <tomh> its just the matter of how
14:56:09 <ddarius> @faq Can Haskell do anything?
14:56:09 <lambdabot> The answer is: Yes! Haskell can do that.
14:56:33 <mjrosenb> @faq is there anything haskell can't do?
14:56:33 <lambdabot> The answer is: Yes! Haskell can do that.
14:56:58 <mjrosenb> @hoogle Bool -> Maybe ()
14:56:59 <lambdabot> No matches, try a more general search
14:57:07 <tomh> well thanks for the pointers guys
14:57:14 <mjrosenb> @dj a -> a
14:57:15 <lambdabot> Maybe you meant: djinn djinn-add djinn-clr djinn-del djinn-env djinn-names djinn-ver . ? @ bf ft id pl rc v wn
14:57:21 <mjrosenb> @djinn a -> a
14:57:21 <lambdabot> f a = a
14:57:26 <Saizan_> tomh: with recrod syntax you can defined data Row = Row { name :: String, age :: Int } and then write functions like foo Row{age=i} = ...
14:57:32 <mjrosenb> @djinn Bool -> Maybe ()
14:57:33 <lambdabot> f a =
14:57:33 <lambdabot>     case a of
14:57:33 <lambdabot>     False -> Nothing
14:57:33 <lambdabot>     True -> Just ()
14:57:36 <yitz> @type guard
14:57:37 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
14:57:47 <mjrosenb> yitz: gracias
14:58:15 <ddarius> :t guard . not
14:58:16 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
14:58:21 * mjrosenb anxiously awaits hoogle-0.4
14:58:36 <tomh> Saizan_: thats what im looking for ye :)
14:58:44 <mjrosenb> i've heard that it can replace yitz for type -> function
14:58:54 <yitz> :)
14:59:41 <tomh> there should be a reason though my teachers hide such functionality from us :P
15:00:08 <mjrosenb> tomh: usually they want you to learn how to do it the hard way
15:00:29 <monochrom> usually teachers can't teach you everything. not intentional hiding.
15:00:53 <tomh> if i knew this, all of my haskell assignments would look much more like imperative OO programs
15:01:07 <yitz> mjrosenb: learn the hard way how to do it, or learn how to the hard way of it?
15:01:23 <yitz> mjrosenb: learn the hard way how to do it, or learn how to do the hard way of it?
15:01:25 <ddarius> tomh: Not likely.
15:01:30 <jsnx> tomh: how can we help you after you say something like that?
15:02:02 <tomh> jsnx: i mean't if i knew that right from the beginning..
15:02:08 <tomh> like when i first saw haskell
15:03:27 <tomh> but we thaught haskell with a special edition called helium, so we were forced to learn everything the haskell way
15:03:33 <tomh> so no worries jsnx :)
15:04:28 <monochrom> http://www.cs.ru.nl/~bart/PAPERS/index.html  has lots of reading material for OO.
15:04:30 <lambdabot> Title: papers of Bart Jacobs
15:05:06 <tomh> monochrom: you mean for OO programmers to think haskell like or?
15:05:20 <jsnx> ddarius: so, early when you say, the hom sets are either {} or {*}, do you mean "the hom sets either have something in them or don't" ? and in that case, i can see how there is a bijection
15:05:21 <monochrom> Proper OO
15:05:35 <tomh> ok
15:07:23 * monochrom should write a long article "Every OO programmer should know this", bringing together material from Bart Jacobs's work, and basically offend or intimidate every OO programmer.
15:07:55 <jsnx> monochrom: what's the executive summary?
15:08:05 <monochrom> co-algebra
15:08:21 <tomh> well write it, thats the kind of stuff which gets popular on dzone etc :)
15:08:27 <monochrom> co-algebra, co-induction, simulation, all that scary stuff :)
15:08:35 <moonfart> whats dzone?
15:08:44 <tomh> a digg for programming
15:08:51 <moonfart> cool
15:08:53 <monochrom> probably dzone is a place that particularly welcomes Greek programming.
15:09:10 <jsnx> monochrom: okay, well, that's not exactly executive level
15:09:10 <moonfart> interesting i guess
15:09:29 <monochrom> executive summary for people in #haskell
15:10:01 <monochrom> executive summary for CEOs is as said, basically offend or intimidate people.
15:10:13 <EvilTerran> :D
15:10:25 <EvilTerran> executive summary for executives
15:10:30 <tomh> but why would the average OO programmer need to know about co-algebra, co-induction etc?
15:10:46 * EvilTerran notes the existence of the phrases "executive summary" and "summary execution"
15:10:48 <monochrom> That is why I said offend or intimidate, no?
15:11:02 <jsnx> tomh: maybe they just need to know it's there
15:11:09 <tomh> ok
15:11:17 <jsnx> i mean, the average OO programmer doesn't need to know any C
15:11:18 <slam28> In a language such as haskell, which is functions at its core, what does the compiler "do"? Isn't the program simply a collection of relationships?
15:11:30 <jsnx> but they'd better realize it's under the hood
15:11:41 * moonfart knows C and some haskell and alot of math, but what is co-algebra in the context of haskell/programming?
15:11:42 <slam28> im a complete noob so im sorry if im annoying you all
15:11:55 <jsnx> slam28: the compiler makes those functions into side-effecting mess
15:11:59 <monochrom> Like, you have been coding fine, and suddenly I come along and say "you have to know this math". That offends you or intimidates you, right?  And that is my sole purpose.
15:12:08 <jsnx> monochrom: haha
15:12:11 <tomh> monochrom: no, it only confuses
15:12:21 <jsnx> monochrom: you are not being constructive
15:12:30 <slam28> jsnx: could you explain that a bit more?
15:12:30 <monochrom> confuse ⊆ intimidate
15:12:41 <EvilTerran> jsnx, so is he being non-constructive?
15:12:43 <moonfart> kinky ascii codes
15:12:44 <monochrom> No, it is not to be constructive.
15:13:17 <EvilTerran> it's the most dangerous type of troll: a really cunning onw
15:13:32 <monochrom> The only contribution is the process itself: through writing it I learn the material better!
15:13:36 <jsnx> slam28: well, the compiler needs to turn the functions into a collection of assembly routines that decide when to run each other
15:13:46 <jsnx> slam28: much like any other compiler
15:14:09 <jsnx> there are an infinity of relationships available if we allow relations among relations
15:14:12 <slam28> well if its all just a collection of relationships when is anything "run"?
15:14:23 <jsnx> well, it's not just relationships
15:14:27 <EvilTerran> slam28, you can imagine you could have a functionally-pure RPN language, and the compiler translating it into a load of actions on a mutable stack
15:14:35 <EvilTerran> slam28, actions in the IO monad are run
15:14:38 <EvilTerran> main :: IO ()
15:14:39 <EvilTerran> is run
15:14:44 <jsnx> yes
15:14:58 <slam28> so without monads there would be nothing to run?
15:14:59 <jsnx> the one () that binds them all
15:15:08 <EvilTerran> slam28, and evaluation of the various expressions linked into main must be evaluated in order to work out what those actions are
15:15:09 <monochrom> The compiler turns every function definition into a callable procedure.
15:15:10 <jsnx> slam28: with the IO monad, there would be nothing to run
15:15:19 <slam28> ahha
15:15:22 <jsnx> s/with/without/
15:15:23 <lxuser> WTF is a co-algebra anyway?
15:15:24 <EvilTerran> slam28, with no IO actions, there would be bothing to run
15:15:44 <slam28> so we need monads to even have anything for the computer to do and run
15:15:44 <monochrom> http://en.wikipedia.org/wiki/F-Coalgebra
15:15:45 <yitz> slam28: the name main is magical, that is what is run. it happens to have a type in the IO monad
15:15:48 <tomh> monochrom: i would say mission accomplished :P
15:15:48 <slam28> is that true?
15:15:54 <monochrom> Haha
15:15:56 <EvilTerran> slam28, or, you could have a system (eg in a plugin system) where the end result required is a number
15:16:06 <jsnx> there is a great SPJ quote to the effect that a really pure language would still have one side effect -- it'd make the box get hot
15:16:07 <EvilTerran> slam28, then evaluation would need to happen to work out what that number is
15:16:37 <EvilTerran> slam28, but, in most haskell programs, the thing that is being worked out through all that evaluation is bits of the IO action called main
15:16:53 <slam28> okok slow down here a second
15:17:06 <slam28> im really really new at hthis
15:17:32 <EvilTerran> slam28, think of an IO action as being things like "print this"; "read a string off stdin and tell me what it is", that kinda thing
15:17:54 <slam28> jsnx, why would the box get hot in a really pure language
15:18:16 <EvilTerran> the execution of a normal haskell program involves evaluating the (pure) expressions in main until you get a sequence of these IO actions out
15:18:21 <yitz> slam28: for me the two common ways of getting things to run are: 1. write a program that has "main", compile it and run it. 2. type stuff at an interactive haskell command prompt (i use ghci).
15:18:31 <EvilTerran> the running of actions is, naturally, imperative
15:18:48 <EvilTerran> but so is the machine code which describes the evaluation of the pure code
15:19:11 <slam28> im really here to understand monads
15:19:17 <slam28> or take a hack at it
15:19:21 <monochrom> egads!
15:19:25 <EvilTerran> run for the hills!
15:19:26 <slam28> ive read about the spacesuits
15:19:32 <yitz> slam28: aha! the truth is out
15:19:34 <slam28> and the nuclear waste
15:19:41 <jsnx> slam28: then you should start with benjamin pierce's book
15:19:48 <EvilTerran> jsnx, which one?
15:19:49 <slam28> and im seeing the light at the end of the tunnel
15:19:50 <Saizan_> ?google you could have invented monads
15:19:50 <lambdabot> http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
15:19:51 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ...
15:19:58 * EvilTerran has TaPL, if that's what you mean
15:20:01 <jsnx> slam28: first you need to understand categories, functors and natural transformations
15:20:03 <slam28> ive read that also saizan
15:20:20 <jsnx> EvilTerran: basic category theory for computer scientists
15:20:31 <slam28> and im seeing the light at the end of the tunnel
15:20:33 <EvilTerran> ah, that one
15:20:38 <zachk> slam28: you can use monads without totally understanding them
15:20:40 <slam28> but the electricity bill hasnt been paid
15:20:40 <EvilTerran> i mean to get that sometime
15:20:44 <jsnx> slam28: do as many of the problems as you can stand
15:20:48 <monochrom> "is that the light at the end of the tunnel, or is that a Benjamin Pierce book ramming over?"
15:21:02 <slam28> and im afraid the light at the end of the tunnel is going to be shut off.....
15:21:09 <zachk> there is a decent video by beckman on them
15:21:26 <jsnx> once you get to the light, you'll be free
15:21:34 <zachk> jsnx: really?
15:21:39 <slam28> can i ask a few elementary questions, one by one?
15:21:52 <yitz> slam28: great idea!
15:21:59 <ddarius> zachk: Decent?  It's horrible?
15:22:03 <monochrom> once you get to the light, you see more tunnels
15:22:06 <zachk> that thing is really bad?
15:22:18 <ddarius> Er s/?$/.
15:22:24 <EvilTerran> the light is in the centre of a massive chamber covered in entrances to tunnelsa
15:22:26 <slam28> is it true that without monads the program would do nothing? because it would be a collection of facts?
15:22:34 <asdftimo> hey guys, speaking of books: what the one book i should read to help me get started with haskell? a book with a lot of examples and problems would be nice.
15:22:54 <slam28> and we need monads to get the program to do something?
15:23:02 <zachk> asdftimo: http://realworldhaskell.org/beta perhaps
15:23:03 <ddarius> zachk: There are people here who couldn't even stand to watch it through.
15:23:04 <kryptiskt> no, functional programming existed before monads
15:23:07 <monochrom> I think this one is safely yes.
15:23:33 <yitz> slam28: that is specifically IO not monads in general.
15:23:42 <slam28> yes io
15:23:49 <slam28> but without any monads
15:24:04 <slam28> there would be no "running"
15:24:16 <slam28> in the complete abscence of all monads
15:24:34 * slam28 waits breathlessly
15:25:02 <kryptiskt> http://research.microsoft.com/~simonpj/papers/marktoberdorf/
15:25:03 <lambdabot> Title: Simon Peyton Jones: papers
15:25:04 <yitz> slam28: as kryptiskt points out, there are other ways of doing that. but in modern Haskell, that's how we get things to run, using IO.
15:25:13 <slam28> ok
15:25:17 <slam28> question 2
15:25:19 <zachk> > do {x<-['a'..'d'];y<-[1..4];return (x,y)}
15:25:24 <lambdabot>  [('a',1),('a',2),('a',3),('a',4),('b',1),('b',2),('b',3),('b',4),('c',1),('c...
15:25:39 <zachk> slam28: thats using the list monad, nice cartesian product
15:25:52 <saadahmad> Hey guys, just to be sure, would data Bar a = Bar !a and data Bar a = Bar { foo :: !a } be identical in strictness?
15:26:02 <EvilTerran> saadahmad, yes
15:26:08 <saadahmad> Thank you :)
15:26:22 <slam28> ok so how do we get a function to pring something
15:26:25 <EvilTerran> slam28, the fundamental structure could be, say, the "IO Arrow"
15:26:28 <slam28> *print
15:26:43 <EvilTerran> or the "IO linearly-typed value"
15:26:44 <EvilTerran> or whatever
15:26:47 <slam28> can a function print or not
15:26:48 <monochrom> The print command has to use the IO monad.
15:26:49 <EvilTerran> but monads is what we use
15:26:59 <yitz> @type putStr
15:27:00 <lambdabot> String -> IO ()
15:27:03 <slam28> how does the monad make it print stuff
15:27:11 <EvilTerran> putStr "foo" :: IO ()
15:27:16 <slam28> im trying to understan dhow it works
15:27:31 <zachk> the main function in Haskell programs is of type IO, thats how youre program gets ran
15:27:34 <slam28> all i care about is the explanation
15:27:35 <EvilTerran> is an action which, when pulled out of the big IO action that is main by the runtime, prints the string "oo"
15:27:35 <kryptiskt> read the paper and the slides at my link
15:27:39 <EvilTerran> er, "foo"
15:28:05 <monochrom> The runtime system sees a print command and prints stuff.
15:28:12 <yitz> slam28: the monad doesn't "make it print". It returns a thing which prints something. When that thing is part of what is computed by main - it really prints.
15:28:44 <yitz> or when you type it at the ghci prompt
15:28:54 <vinicius> uh
15:29:05 <slam28> so a functional programming langauge has things that do stuff?
15:29:06 <vinicius> tapl introduces monads?
15:29:08 <mjrosenb> :t lift2M
15:29:09 <lambdabot> Not in scope: `lift2M'
15:29:18 <mjrosenb> :t liftM2
15:29:19 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
15:29:31 <yitz> slam28: yes - the runtime system, and ghci :)
15:29:52 <slam28> hmm
15:30:08 <slam28> so the problem then ecomes how i get a function to return that thing?
15:30:14 <slam28> *becomes
15:30:18 <dobblego> IO is an awful place to begin to understand monads; I can't think of anything worse
15:30:50 <monochrom> DelimitedContT IO is worse :)
15:30:54 <slam28> im trying to grasp why we need them, and how they work to get us what we need
15:30:57 <ddarius> dobblego: BackwardStateT Int (LogicT IO) a
15:31:01 <dobblego> ok ok
15:31:02 <slam28> the underlying theory
15:31:05 <monochrom> hahahahaha
15:31:11 <yitz> slam28: you just use functions that return IO thingies inside your definition of main
15:31:20 <kryptiskt> slam28: http://research.microsoft.com/~simonpj/papers/marktoberdorf/ <--- READ THIS
15:31:21 <lambdabot> Title: Simon Peyton Jones: papers
15:31:50 <yitz> monochrom: Identity is equally bad
15:31:53 <dobblego> slam28, I agree, which is why I recommend against using IO as the example
15:32:59 <monochrom> http://hpaste.org/5833  is my favorite :)
15:33:24 <slam28> so yitz, why is it all so hard? why a fancy name "monads" why not just write a funtion that returns an IO thing?
15:33:33 <yitz> slam28: "how do you get side effects in Haskell" and "What are monads" are really two different topics.
15:33:51 <slam28> my question is what are monads
15:34:00 <yitz> slam28: you're right, just for that you don't need to know much about monads.
15:34:08 <dobblego> a monad is any mathematical object satisfying bind/unit and three laws
15:34:10 * monochrom has the tendency to suggest scary reading material
15:34:13 <slam28> im sorry for being unclear
15:34:17 <roconnor> @what monad
15:34:17 <lambdabot> I know nothing about monad.
15:34:22 <roconnor> @what monads
15:34:22 <lambdabot> http://www.haskell.org/all_about_monads/html/
15:34:39 * vinicius is having a hard time finding anything related to monad in tapl (well, beside perhaps F<)
15:34:56 <slam28> dobblego can you continue.....?
15:35:11 <dobblego> slam28, I plan to blog it soon in fact (I recently did Functor)
15:35:16 <monochrom> Look for Andrew Gordon's PhD thesis, "functional programming and input/output".  It's listed on http://www.vex.net/~trebla/weblog/fpbooks.xhtml
15:35:48 <dobblego> ?type (>>=)
15:35:49 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
15:35:51 <dobblego> ?type return
15:35:51 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
15:35:56 <dobblego> that is bind/unit ^^^
15:36:05 <dobblego> the three laws are called left and right identity, associativity
15:36:19 <dobblego> IO happens to be one mathematical object that satisfies this
15:36:23 <dobblego> but there are many others
15:36:24 <yitz> slam28: monads are a way to describe algorithms that are most naturally specified in a step-by-step style. monads are also a way to describe a container whose elements you can iterate over. surprisingly those two are equivalent.
15:37:21 <tromp> not equivalent, but fitting in same framework
15:37:22 <slam28> yitz can you elaborate on "most naturally specified in a step-by-step style"?
15:37:42 <dobblego> slam28, can you read this code:
15:37:52 <dobblego> > [1..5] >>= (\a -> [1..a])
15:37:54 <lambdabot>  [1,1,2,1,2,3,1,2,3,4,1,2,3,4,5]
15:38:07 <slam28> no
15:38:19 <dobblego> mk, I won't continue on that then :)
15:38:20 * slam28 hides in shame
15:38:40 <dobblego> how about this:
15:38:42 <ski> a monad is an endofunctor `F' over a category `C', together with natural transformations `eta : Id_C >-> F' and `mu : F F >-> F' satisfying `mu . F eta = id_F',`mu . eta F = id_F' and `mu . F mu = mu . mu F'
15:38:43 <tromp> > [1..5] >>= enumFromTo 1
15:38:45 <lambdabot>  [1,1,2,1,2,3,1,2,3,4,1,2,3,4,5]
15:38:50 <dobblego> > concatMap (\a -> [1..a]) [1..5]
15:38:52 <lambdabot>  [1,1,2,1,2,3,1,2,3,4,1,2,3,4,5]
15:38:55 <monochrom> It's all Greek to me.
15:39:09 <ddarius> Bah, a monad is a lax functor from 1 to Cat.
15:39:11 <slam28> no
15:39:32 <kryptiskt> a monad is a programmable semicolon
15:39:43 <yitz> slam28: best is to give examples. 1. if you have an algorithm where you have to pass an extra parameter along from function to function, instead you can use the State monad and the parameter becomes invisible except when you actually need to mention it. That leads to step-by-step - set the parameter, do stuff, read the parameter, change the parameter, etc.
15:39:44 <dobblego> kryptiskt, that's where I was going :)
15:39:51 <ski> slam28 : but i don't think you will have much use of such a definition, at the moment ..
15:40:05 <kryptiskt> :-)
15:40:11 <yitz> slam28:of course, IO is another example of step-by-step because that's how things happen in the physical world.
15:40:46 <lament> things in the physical world don't happen step-by-step :)
15:40:59 <dobblego> slam28, what about this code: val x = foo(); bar(x);
15:41:00 <yitz> slam28: the list monad - as illustrated by tromp - is an example of a container. you can iterate over elements of a list.
15:41:24 <monochrom> things in programmer minds don't happen in the physical world.
15:41:35 <yitz> slam28: another simple example is the Maybe monad - iteration is pretty trivial, but it's there. And this turns out to be extremely useful
15:41:42 <ddarius> monochrom's mind exists on a different plane
15:41:52 <slam28> so yitz, a monad in your case is a "state" but using a monad we can treat it like a parameter?
15:42:02 <yitz> lament: ok, the newtonian physical world then
15:42:17 <ski> ddarius : maybe an orthogonal plane ?
15:42:20 <zachk> but newtonian doesnt include quantum and relativity
15:42:31 <slam28> dobblego: im embarrassed to say that im a complete newbie
15:42:42 <monochrom> No no, I mean, such as, programmer minds are full of objects, which don't exist; programmer minds are full of assumptions about sequentialization, which doesn't exist, etc.
15:42:51 <dobblego> slam28, it's typical C/Java like code; have you ever used an imperative language like that before?
15:43:03 <ddarius> slam28: Why do you care to know what a monad is?
15:43:13 <zachk> slam28: have you installed ghc and ran ghci yet?
15:43:16 <yitz> slam28: not exactly. when your function returns a value of type "State Int String", it is like you are returning a String, but there is a hidden parameter of type Int.
15:43:30 <jsnx> slam28: a monad is a datatype
15:43:39 <jsnx> there are special operations attached to it
15:43:53 <monochrom> http://groups.google.com/group/comp.lang.functional/msg/4c1cb17ded810ea0  another programmer imagination that doesn't exist.
15:43:54 <lambdabot> Title: But the real world has mutable state... - comp.lang.functional | Google Groups, http://tinyurl.com/6puxdo
15:43:57 <jsnx> these operations allow us to create the impression of lists, state, sequential IO
15:45:00 <jsnx> monads also have the feature that, in general, you can put a value, but you can't take it back out (though some monads are extended with the able to take a value back out)
15:45:01 <slam28> ddarius, cuz im a curious guy
15:45:25 <jsnx> s/you can put a value/you can put a value in/
15:45:37 <slam28> jsnx, why would all this be impossible without monads and how do monads do what they do
15:46:00 <slam28> without breaking all the rules
15:46:11 <jsnx> slam28: well, anything for which it is possible would be a monad of sorts
15:46:18 <yitz> slam28: nothing is impossible without monads. it's just a very useful and powerful tool.
15:46:35 <lament> i think monads are kinda overhyped
15:46:39 <dobblego> same
15:46:47 <jsnx> the essential feature for IO is the "you can't get back out" property
15:47:13 <ddarius> I think monads are repeatedly and continuously poorly/misdescribed.
15:47:29 <lament> that's true.
15:47:32 <dobblego> ddarius, what do you think is a good explanation?
15:47:35 <jsnx> ddarius: so you choose not to describe them?
15:47:42 <lament> but by those who describes them correctly, they're often overhyped
15:47:43 <yitz> jsnx: and that characterizes IO and friends. Every other monad does have a way of getting out the value - that is the usual case.
15:47:44 <saadahmad> I'm not sure if this might help you, but I found http://www.haskell.org/all_about_monads/html/meet.html was a good explanation for myself
15:47:44 <lambdabot> Title: Meet the Monads
15:47:45 <lament> *describe
15:47:57 <monochrom> I think "what is a monad" and generally "what is ____" is a poor question.
15:48:04 <jsnx> yitz: but it is not a property of monads qua monads
15:48:15 <dobblego> monochrom, exactly what I think; I think the problem is the question, not the answer
15:48:15 <dobblego> s
15:48:20 <jsnx> monadness guarantees you an operation that let's you in
15:48:22 <lament> don't ask what monads can do for you. Ask, what can you do for monads?
15:48:30 <yitz> jsnx: yeah
15:48:30 <jsnx> yitz: but it does not offer one to get out
15:48:49 <slam28> what the heck is the underlying "chap" behind monads
15:49:05 <slam28> the underlying new idea
15:49:06 <ddarius> dobblego: For the purposes of learning how to use monads in Haskell I recommend Wadler's paper.  In general, the definition is fine.
15:49:25 <yitz> lament: ok, can you restate that for comonads now? :)
15:49:32 <lament> haha
15:49:40 <lament> err...
15:50:01 <lament> comonads don't ask what can they do for you. They ask, what can you do for them? :)
15:50:06 <ddarius> jsnx: I actually did give a description (though facetiously and "poor" from a pedagogical point of view, let alone a "learn how monads work in Haskell" point of view.)  And yes, no description would be better than a misleading one.
15:50:17 <monochrom> Wadler's papers are at http://homepages.inf.ed.ac.uk/wadler/   Look for "monads for functional programming"
15:50:18 <lambdabot> Title: Philip Wadler's home page
15:50:35 * ddarius prefers "The essence of functional programming" but the two are very similar.
15:50:47 <jsnx> ddarius: unfortunately, i am only capable of misleading descriptions for the next 6 motnhs or so
15:50:57 <slam28> what couldnt be without monads, why not, and what is the "trick" that moands use to do those stuff
15:51:12 <slam28> that is my question
15:51:14 <yitz> slam28: I like Cale's wiki pages for the "chap":
15:51:18 <jsnx> slam28: well, that is a rather misdirected question
15:51:28 <yitz> @go monads as containers
15:51:30 <lambdabot> http://www.haskell.org/haskellwiki/Monads_as_Containers
15:51:30 <lambdabot> Title: Monads as containers - HaskellWiki
15:51:36 <jsnx> slam28: the "special sauce" in haskell is using monads for IO
15:51:38 <yitz> @go monads as computations
15:51:39 <lambdabot> http://en.wikibooks.org/wiki/Haskell/Advanced_monads
15:51:46 <yitz> no no
15:51:50 <yitz> @go monads as computation
15:51:51 <lambdabot> http://okmij.org/ftp/Computation/monads.html
15:51:51 <lambdabot> Title: Monads
15:51:58 <jsnx> slam28: the whole point of which is, we get a purely functional language that still has side effects
15:52:01 <Spark> strip away the syntax sugar and it's just a design pattern
15:52:01 <yitz> no not that either
15:52:18 <dobblego> jsnx, that's hardly the point of monads
15:52:18 <jsnx> slam28: but in a controlled way
15:52:24 <jsnx> dobblego: that's right
15:52:30 <jsnx> dobblego: that's not the point of monads
15:52:51 <Saizan_> Spark: it's better than that, it's a design patter that can be abstracted as a library :)
15:52:52 <ddarius> jsnx: There's nothing wrong with saying "A monad, in Haskell, is a type constructor m [of kind * -> *] that is an instance of the Monad class which means that you have a function return :: a -> m a and a function (>>=) :: m a -> (a -> m b) -> m b.  Examples of monads are ..."
15:52:56 <yitz> http://www.haskell.org/haskellwiki/Monads_as_computation
15:52:56 <lambdabot> Title: Monads as computation - HaskellWiki
15:53:00 <yitz> there
15:53:00 <Cale> slam28: The underlying idea behind monads is that they are one way to organise combinator libraries so that certain control-structure functions can be shared between them
15:53:03 <jsnx> ddarius: there's a lot wrong with that
15:53:13 <Cale> and save you the effort of redefining those in every such library
15:53:19 <slam28> cale: in english?
15:53:31 <Spark> Saizan_: that's not uncommon though, especially in a language with closures
15:53:33 <Botje> "read the damn papers and figure it out for yourself"
15:53:46 <Botje> you can _NOT_ be told what monads are
15:53:46 <yitz> Read Cale's wiki pages, they're in English :)
15:54:07 <Cale> Well, a combinator library in this sense is essentially just a library which has a rich enough API to be like a miniature programming language.
15:54:31 <kryptiskt> maybe there's a lack of monad tutorials? Cannot be more than a hundred or so out there :-)
15:54:34 <jsnx> slam28: as you can see, the haskell community is not strong on layman's explanations
15:54:46 <Cale> Such a library will define a bunch of basic operations or building blocks of some sort, and then various ways to glue those together into more complex programs.
15:55:09 <yitz> jsnx: not true. we may not be good at it, but we try hard enough to make up for it
15:55:14 <slam28> can someone answer this question directly please
15:55:16 <slam28> what couldnt be without monads, why not, and what is the "trick" that moands use to do those stuff
15:55:30 <jsnx> slam28: nothing, NULL, no trick
15:55:40 <ddarius> slam28: That question has already been answered twice.
15:55:42 <kryptiskt> slam28: there's no there there
15:56:07 <Botje> slam28: read the stuff people are pointing you to.
15:56:15 <Cale> slam28: Monads are just a way to recognise some common structure across various libraries that we've been writing, so in essence, they're just an abstraction to save us some effort of redefining similar things over and over.
15:56:35 <kryptiskt> it's a useful technique, like the round kick in international karate
15:57:18 <slam28> im reading, and all the stuff use examples of code, which i havent learned to read, and jargon that i dont understand
15:57:21 <dons> HWN on reddit, http://www.reddit.com/r/programming/info/6q0j8/comments/
15:57:22 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
15:57:22 <lambdabot> Title: programming: Haskell Weekly News: Jobs, Gtk2Hs released, Summer of Code updates
15:57:42 <slam28> and i apologize for being such a noob
15:57:59 <Spark> they basically just allow you to thread things through function calls without as much bureaucracy
15:58:02 <ski> no need to apologize
15:58:04 <Cale> slam28: It's not a problem, however, the only real way to answer your question is to simply use monads for a while.
15:58:10 <jsnx> slam28: indeed
15:58:11 <yitz> Cale: it's not just to save the typing. It makes programs much more clear.
15:58:20 <Cale> yitz: well, that's true :)
15:58:36 <slam28> cale i think i understand that without them it would be impossibe for functions to do anything
15:58:41 <Cale> yitz: It's good not to have 50 different names for 'sequence'
15:58:44 <slam28> and thats why we need them
15:58:49 <Cale> slam28: no, that's not true.
15:58:51 <jsnx> slam28: get ghc and follow the "write yourself a scheme in 48 hours" tutorial
15:59:02 <jsnx> slam28: no, there are other ways to do the same thing
15:59:06 <Cale> slam28: There's no reason we *need* monads, only reasons to want them.
15:59:17 <jsnx> slam28: monads just happen to be one way to get IO
15:59:42 <Spark> they make code prettier
15:59:45 <slam28> oy
15:59:49 <slam28> im dyin here
15:59:56 <slam28> i gotta learn how to ask
16:00:04 <jsnx> slam28: you are not ready
16:00:05 <slam28> im being really unclear
16:00:08 <dobblego> quit with the IO instance already
16:00:13 <slam28> and my wife is gonna kill me
16:00:18 <Cale> Really, the interesting thing about Haskell is not that IO actions form a monad, but that IO actions are values which are combined using various functions. Those functions happen to include those required to make it a monad, but that isn't the interesting bit :)
16:00:18 <slam28> cuz its 2 am
16:00:22 <jsnx> !!
16:00:25 <dobblego> follow what ddarius said and the given papers
16:00:25 <Riastradh> Ugh.  If you read the `Write yourself a Scheme in 48 hours' tutorial, perform a mental substitution of `not-Scheme' for `Scheme', and `poor Haskell code' for `good practice'.
16:00:32 <yitz> slam28: for example, you can always keep state by adding extra parameters to your functions, and return tuples sometimes. But then, in a complex system, someone reading it would have to figure out which are intended to be really significant input and output and which are just there to pass around intermediate results. By using a State monad, you vastly simplify things.
16:00:36 <dobblego> pretend monads have nothing at all to do with I/O or "doing anything"
16:00:39 <slam28> and im not even any smarted then i was an hour ago
16:00:55 <Cale> slam28: Let's have a look at a simple example of a monad.
16:01:21 <Cale> slam28: I take it you already know about how lists work in Haskell?
16:01:26 <slam28> no
16:01:30 <Cale> oh
16:01:32 <slam28> i know nothing
16:01:37 <Cale> Then don't worry about monads at all.
16:01:39 <slam28> complete newbie
16:01:40 <ddarius> Cale: He doesn't know, seemingly, how to program at all.
16:01:49 <jsnx> !!
16:01:49 <slam28> i know some pyhon
16:01:52 <slam28> very little
16:01:55 <Cale> okay
16:02:03 <Spark> slam28: have you used a language with exceptions?
16:02:06 <slam28> isnt monads a mathematical idea?
16:02:12 <Cale> slam28: originally, yes
16:02:12 <jsnx> slam28: yes
16:02:22 <Tomas> monads <3
16:02:23 <Cale> slam28: From category theory.
16:02:25 <slam28> spark i cant say i know what exceptionas are yet
16:02:30 * Botje kicks the "rename it to warm fuzzy thing" group a bit
16:02:35 <Cale> slam28: But you don't have to know or care about that to use them for programming.
16:02:52 <slam28> cale i only care about the theory
16:03:03 <Cale> slam28: ah, are you a mathematics student?
16:03:07 <slam28> i understand that there is a clever idea
16:03:13 <Spark> "and then it was discovered that foozles are the categorical dual of aspects, which got everyone very excited"
16:03:20 <ddarius> slam28: Do you know the language of category theory?
16:03:20 <jsnx> Botje: we should call them "canaries" or "kitty cats" or something
16:03:20 <slam28> and i want to know that clever idea
16:03:33 <yitz> jsnx: the cats thing is taken
16:03:44 <slam28> im a student of clever stuff
16:04:08 <ddarius> slam28: If you don't know the language, then, by definition, you can't talk about it.
16:04:11 <jsnx> slam28: it is very hard for us to know what context you bring to the table
16:04:26 <Spark> the name "monads" is a real propoganda success though
16:04:31 <slam28> i understand that they are a clever idea that do stuff that wouldnt be able to be done without them
16:04:38 <slam28> i want to know that problem
16:04:44 <joed> kinda like space ships.
16:04:46 <Spark> functional programmers like the idea that they've mastered something mathematical
16:04:50 <jsnx> slam28: well, that understanding is incorrect
16:04:52 <vinicius> comonads of IO
16:04:52 <slam28> and understand the cleverity behind the solution
16:04:53 <monochrom> "monad" itself doesn't give you magical I/O. But you can frame I/O inside monads. There are other options other languages pursue. Again, see Andrew Gordon's thesis "functional programming and input/output" for the full theory of I/O.
16:04:57 <vinicius> I want comonads of IO monad
16:05:00 <vinicius> plz
16:05:06 <ski> Kieburz
16:05:29 <Botje> quick people, vinicius needs his (co)monad fix :)
16:05:42 <yitz> @type cofix
16:05:43 <lambdabot> Not in scope: `cofix'
16:05:46 <Cale> slam28: Well, hmm... it's really hard to explain without being able to give you any Haskell code to look at.
16:05:50 <slam28> so jsnx even from a mathematical standpoint, why were monads invented
16:06:06 <Spark> they weren't invented
16:06:06 <Cale> slam28: They were invented to study adjunctions.
16:06:09 <slam28> cale could you explain it in a mathematical framework?
16:06:13 <Cale> slam28: Sure.
16:06:15 <Spark> someone just said "those things tend to turn up a lot, let's name them"
16:06:20 <Cale> slam28: Do you know what a natural transformation is?
16:06:22 <slam28> ok shoot
16:06:25 <monochrom> monads were invented to do algebraic topology with more organization.
16:06:25 <slam28> no
16:06:32 <Cale> slam28: Do you know what a functor is?
16:06:35 <slam28> no
16:06:42 <Cale> slam28: Do you know what a category is?
16:06:47 <ddarius> Cale: He doesn't know any category theory.
16:06:48 <ski> i guess "no"
16:06:52 <slam28> nope
16:06:58 <Cale> Okay.
16:07:08 <Spark> break out the hand puppets
16:07:09 <Cale> Uh... do you know about sets and functions?
16:07:09 <monochrom> try "do you know 'object'?"  :)  *duck*
16:07:11 * slam28 turns red
16:07:21 <slam28> no
16:07:26 <lament> "do you know what multiple inheritance is?"
16:07:30 <Cale> slam28: All right, this might take a while :)
16:07:30 <slam28> nope
16:07:39 <slam28> im sorry
16:07:48 <monochrom> onoes, Cale is going to replay a 3-hour lecture
16:07:54 <Cale> monochrom: heh
16:07:59 <Cale> monochrom: Try 4 years :)
16:08:05 <ddarius> Cale: It's unlikely you'll be able to explain everything necessary for him to know on IRC.
16:08:06 <slam28> if you have the patience i would be very grateful to you
16:08:13 <lament> i think cale can do this
16:08:20 <Botje> .oO(don't the catsters have some videos about that?)
16:08:23 <ddarius> Cale: If he is actually interested, he should be reading something.
16:08:35 <Cale> slam28: Well, I could take a shot at it, but...
16:08:38 <slam28> ddarius i read and read and read
16:08:38 <Spark> he's a long way off even knowing whether he's interested
16:08:40 <monochrom> ddarius: I have seen it done. I was shocked.
16:08:50 <slam28> and everything assumes some prior knowledge
16:09:00 <slam28> and i have none
16:09:05 <slam28> no backround
16:09:06 <glguy> Cale's been explaining Monads on IRC since before I first asked "What is a Monad?" in IRC
16:09:07 <ddarius> Spark: I agree which is why I asked him why he cared.
16:09:07 <Cale> slam28: First of all, try reading this wikipedia page: http://en.wikipedia.org/wiki/Category_(mathematics)
16:09:14 <Tomas> gogo buy "monads for dummues" ;)
16:09:40 <Cale> slam28: That's the very first definition essentially, in the branch of mathematics where monads arise.
16:09:49 <lament> Cale: if he doesn't know sets and objects, what use is that article
16:09:53 <slam28> ok
16:09:54 <Cale> slam28: It might be pretty hard...
16:10:05 <slam28> gimme a minute
16:10:12 <Cale> slam28: It's more directed at people who've had 4 years of undergrad mathematics or so :)
16:11:09 <slam28> thsi is the problem...
16:11:12 <slam28> sigh
16:11:14 <Cale> Category theory is usually considered graduate level material, so you might have trouble.
16:11:29 <yitz> http://en.wikipedia.org/wiki/Set
16:11:40 <Cale> If you don't have a strong mathematics background, approaching carefully from the programming side will be easier.
16:11:46 <Spark> i doubt he has any formal maths training
16:12:12 <monochrom> "you could have invented math too"
16:12:16 <yitz> http://en.wikipedia.org/wiki/Function_%28mathematics%29
16:12:31 <ski> monochrom :)
16:12:35 <ddarius> slam28: There are plenty of good introductions to set theory that can be understood by highschoolers online.
16:14:01 <lament> i think that explaining the foundations of math from scratch up to categories and functors is something Cale can do in less than an hour
16:14:16 <Cale> Really?
16:14:31 <lament> yeah, come on, how difficult is it
16:14:49 * dobblego tips $5 into the hat
16:14:49 <lament> there's not that much stuff there
16:15:01 <lament> considering you never need to talk about numbers
16:15:03 <bd_> Surely it's sufficient to just state the axioms and derivation rules.
16:15:05 <ddarius> lament: It is pretty easy to do, but not in a way that provides either intuition or skill in formal manipulation.
16:15:15 <bd_> ;)
16:15:46 <lament> ddarius: no explanation would do that, though
16:15:53 <ddarius> lament: Indeed.
16:15:59 <ddarius> lament: It would be a waste of his time.
16:16:00 <lament> that's why universities have homework
16:16:07 <ddarius> lament: Agreed.
16:16:11 <ddarius> And reading lists.
16:16:13 <ddarius> and textbooks.
16:16:32 <Spark> you don't need homework, you just need examples.  the homework is jsut to make people actaully think about the examples :)
16:16:46 <vinicius> @let chaitin_magic_number = 15328
16:16:47 <lambdabot> Defined.
16:17:06 <slam28> ok
16:18:15 <lament> but the intuition is kinda useless anyway
16:18:27 <Cale> lament: ?
16:18:38 <lament> mathematical intuition is at odds with programming intuition
16:18:54 <Cale> not true
16:19:01 <vinicius> > 1/(2**(1+15328)
16:19:01 <lambdabot> Unbalanced parentheses
16:19:04 <vinicius> > 1/(2**(1+15328))
16:19:06 <lambdabot>  0.0
16:19:11 <vinicius> > 1.0/(2**(1+15328))
16:19:13 <lambdabot>  0.0
16:19:17 <roconnor> > 1/(2^(1+15328))
16:19:20 <lambdabot>  0.0
16:19:21 <ddarius> You want :: Rational
16:19:33 <monochrom> Dear Cale: I am a 50-year-old from Africa. Since the age of 3 I have been forced to work as labour, that's right, I was a child labour, so I had absolutely no schooling, I can't even tell 21 from 22. (Thank God I can grok 1-20 with my fingers and toes.) Thankfully I know some plain English and there is this nice volunteer who set me up a computer and a speech recognizer so I can IRC with you here.  Anyway here is my question:
16:19:33 <slam28> cale
16:19:33 <monochrom>  could you teach me sheafification?
16:19:33 <lament> another battle with the type system :)
16:19:37 <vinicius> > 1/(2**(1+15328)) :: Rational
16:19:39 <lambdabot>   add an instance declaration for (Floating Rational)
16:19:59 <roconnor> > 1/(2^(1+15328)) :: Rational
16:19:59 <slam28> cale can we begin?
16:20:00 <Cale> monochrom: hahaha
16:20:01 <lambdabot>  1%30817934881919741533821436364491443307126700265103751276110379275585637220...
16:20:17 <vinicius> heh
16:20:17 <ddarius> monochrom: Well done.
16:20:40 <vinicius> > 1/(2**(1+15328)) :: Float
16:20:42 <lambdabot>  0.0
16:20:47 <vinicius> > 1/(2**(1+15328)) :: Real
16:20:48 <lambdabot>      Class `Real' used as a type
16:20:48 <lambdabot>     In the type `Real'
16:20:48 <lambdabot>     In an expression ...
16:21:00 <roconnor> > 1/(2**(1+15328)) :: CReal
16:21:00 <vinicius> I give up, it's not important anyway
16:21:00 <ddarius> vinicius: That underflows to 0
16:21:11 <lambdabot>  Exception: Time limit exceeded
16:21:12 <ski> @botsnack
16:21:13 <lambdabot> :)
16:21:21 <roconnor> > 1/(2^(1+15328)) :: CReal
16:21:32 <lambdabot>  Exception: Time limit exceeded
16:21:45 <ddarius> vinicius: If you want a decimal expansion, just write a Rational -> [Digit] function.
16:22:08 <ddarius> (uh, preferably using scientific notation...)
16:22:17 <fatalerrorx> why is freenode so laggy for me?
16:22:44 <Cale> slam28: I would recommend you start by just learning the basics of Haskell. Contrary to lament's comments I think learning the mathematics involved will take a good deal longer. It's not horribly complex in the end, but taking it in requires a certain amount of mathematical maturity, and is *extremely* difficult without knowing examples. Category theory is the game which mathematicians play with branches of mathematic
16:22:44 <Cale> s as the pieces.
16:23:31 <slam28> ok
16:23:39 <ddarius> Cale: Category theory could be (and I'm pretty certain has been) succesfully taught to high-schoolers, but, yes, most of the material available is aimed at a much higher level.
16:23:45 <lament> Cale: or, in the context of #haskell, with programming-related ideas
16:24:09 <Cale> Yeah, but if you're going to take the programming-specific route to it, might as well know some Haskell first :)
16:24:18 <yitz> slam28: it's almost 2:30am also for me. so i'm turning in. bye, have fun.
16:24:30 <slam28> night yitz
16:24:36 <slam28> you here in the land?
16:24:51 <Cale> If you know some Haskell, I can teach you about what monads are without all the category theoretic language.
16:24:53 <yitz> nachon
16:25:09 <slam28> aifoh?
16:25:21 <yitz> prozdor
16:25:21 <slam28> cale lets try that approach
16:25:31 <slam28> where is prozdor?
16:25:46 <yitz> prozdor yerushalayim
16:25:58 <ddarius> slam28: In that approach, you need to first learn Haskell.  Something that also can't reasonably be done in a single IRC session.
16:26:04 <slam28> its a neighborhood in yerushalayim?
16:26:18 <yitz> outside, on the way up.
16:26:26 <slam28> so i guess i bow out gracefully here....
16:26:45 <slam28> or not so gracefully
16:26:49 <Cale> slam28: If you have questions, don't hesitate to ask :)
16:26:49 <slam28> well im in yerushalayim
16:26:59 <slam28> in shaarei chessed
16:26:59 <ddarius> @where yaht
16:26:59 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
16:27:02 <lxuser> lament, IIRC, programming-specific applications of category theory only relate to _cartesian closed_ categories, which turn out to be isomorphic to some forms of lambda-calculus.  category theory itself is a much broader subject
16:27:15 <slam28> well cale do you think its possible to give it a shot?
16:27:25 <bd_> ddarius: Well, it all depends on what you consider an IRC session. By some measures, I might be in a 15 day long IRC session by now :)
16:27:33 <jsnx> slam28: earlier, you asked me about the mathematical motivation for monads
16:27:46 <jsnx> slam28: the truth is, i don't know anything about it
16:27:52 <slam28> yes jsnx
16:27:55 <Cale> slam28: To give what a shot? Explaining all the category theory you'd need in less than an hour? I could try, but I'm not sure how much you'd get from it...
16:28:02 <Cale> also, I'm half asleep :)
16:28:03 <lament> lxuser: i don't know the details but i suspected it's something like that. Hence my comment about mathematical vs. programmer's intuition - they would be rather different
16:28:05 <slam28> so lets try!
16:28:11 <Cale> Well, okay
16:28:19 <ddarius> lxuser: That's overly specific, but yes, programming-related applications of category theory only exercise some of CT.
16:28:22 <slam28> thanks!
16:28:22 * lament gets the popcorn
16:28:30 * mapreduce pulls up a stool.
16:28:42 * jsnx sticks a sharp stick in his eye
16:28:48 * yitz goes to bed
16:28:50 * jsnx tazes slam28 
16:29:01 <ddarius> lament: They are different, but not "at odds" with each other.  I've definitely used intuition about one for ideas in the other.
16:29:05 <lament> Cale: start with sets, i think :)
16:29:19 <Cale> Oh right, you don't know what sets are...
16:29:20 <yitz> http://en.wikipedia.org/wiki/Set
16:29:20 <slam28> jsnx the way you phrased my question is much better then i have hrased it myself
16:29:21 <jsnx> let's start with the real and natural numbers
16:29:39 <Cale> jsnx: Explaining the real numbers takes over 2 hours from scratch, so let's not.
16:29:43 <lament> no need to talk about numbers, numbers are unrelated
16:29:44 <slam28> i read sets on wikipedia and i understood it for the most part
16:29:57 <Cale> okay
16:30:14 <roconnor> oh god, sets
16:30:14 <lament> real numbers are something most people don't get even after a science degree :)
16:30:14 <slam28> tis a set of stuff
16:30:16 <roconnor> what a crappy place to start
16:30:27 <roconnor> *sigh*
16:30:31 <lament> roconnor: shhh, cale's about to start
16:30:33 <Cale> A category C is a collection (let's say set for now) of "objects" called Ob(C), and for any pair A, B of objects, a set Hom(A,B) of "arrows". The objects and arrows themselves can be whatever we like.
16:30:35 <ddarius> lament: Little reason to get them.  Especially if one has a science degree.
16:30:56 <Cale> If f is in the set of arrows Hom(A,B), we write f: A -> B
16:30:57 <yitz> let b>1, A={Z[[X]] | seq. of coeff. abs bdd. by a polynomial} Then the real numbers are A/(bX-1)
16:30:58 <dons> ?users
16:30:58 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
16:31:18 <yitz> there, that was pretty fast
16:31:35 <slam28> so f is an arrow?
16:31:41 <Cale> yeah
16:31:41 <lament> yitz: go to sleep :D
16:31:42 <ski> Cale : if you want to try this .. it might be better to go to e.g. #haskell-overflow ?
16:31:45 <bd_> yitz: I was following you until '[[', I think.
16:31:51 <Cale> Moreover, we require that whenever f: A -> B, and g: B -> C are arrows, we have an arrow called g.f, the composite of f and g, with g . f : A -> C
16:31:54 <yitz> gnight
16:32:02 <Cale> ski: good idea
16:32:03 <slam28> anf f: a->b means apply arrow f from a to b?
16:32:03 <mapreduce> ski: disagree
16:32:08 <jsnx> yitz: you had me at {
16:32:11 <Cale> slam28: no
16:32:19 <ddarius> yitz: A real number is a function Integer -> Bool.
16:32:19 <Cale> slam28: It simply means that f is an arrow from A to B
16:32:43 <ski> mapreduce : yes, there's cons to it too .. just that slam28 might not be able to follow very good with much noise in the background ..
16:32:43 <yitz> ddarius: :)
16:32:46 <Cale> Shall we move to #haskell-overflow, since this isn't directly Haskell-related?
16:33:05 <slam28> sure
16:33:30 <Saizan_> a cartesian closed category is also a closed monoidal category using the same product for both?
16:33:35 <dainanaki> anyone have time to help me with something
16:33:35 <mapreduce> ski: sure
16:33:36 <dainanaki> ?
16:33:51 <dobblego> dainanaki, please just ask your specific question
16:34:06 <hackage> Uploaded to hackage: GraphSCC 1.0
16:34:06 <hackage> Uploaded to hackage: hpodder 1.1.5
16:34:06 <hackage> Uploaded to hackage: darcs-cabalized 2.0.2.2
16:34:07 <hackage> Uploaded to hackage: uconv 0.0.2
16:34:09 <hackage> Uploaded to hackage: darcs-cabalized 2.0.2.1
16:34:23 <ski> Saizan_ : `monoidal closed', i think it's usually phrased
16:35:07 <Saizan_> ski: oh, i picked that from wikipedia
16:35:38 <ddarius> Saizan_: Yes.
16:36:27 <dainanaki> I can't get leksah to build because it says that the function parsePackageId is not in scope even though the Module Distribution.Package is imported
16:37:01 <dainanaki> what am I doing wrong?
16:39:22 <ddarius> dainanaki: Are you sure the version of Cabal it is expecting matches the version you have?
16:40:17 <dainanaki> I have Cabal-1.4.0.1 hidden and Cabal-1.2.4.0 exposed
16:41:04 <dainanaki> it says that it requires >= 1.1.6.2
16:41:24 <ddarius> It probably means essentially == 1.1.6.2
16:41:54 <dainanaki> at least as of 1.2.3 it still had that function though
16:42:03 <dainanaki> and i checked in ghci
16:42:07 <dainanaki> it still has that function
16:42:51 <dainanaki> plus it requires ghc 6.8 which comes with cabal 1.2 anyways
16:43:01 <dainanaki> but i guess I'll give that a shot
16:48:21 <dainanaki> now I'm building 1.1.6 and it is telling me that pretty-1.0.0.0 is hidden, although as far as I can tell it's not
16:49:07 <ddarius> dainanaki: When you build something with cabal, it hides all other packages except the ones that it needs.
16:51:19 <Saizan_> where "needs" means "listed in build-depends"
16:52:15 <Saizan_> dainanaki: have you tried compiling the Setup.hs script of leksah with ghc --make -package Cabal-1.2.4.0 Setup.hs ?
16:55:03 <dainanaki> Saizan_: I compiled the Setup.hs script with those arguments
16:55:11 <dainanaki> but now what?
16:55:24 <dainanaki> I just ran it as usual and got the same error
16:55:44 <dainanaki> thanks for the help though
16:57:23 <jsnx> @seen slam28
16:57:23 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
17:01:02 <Botje> damn you, catsters
17:01:10 <Botje> I wanted to go to sleep half an hour ago :(
17:02:11 <ddarius> Curse you, Botje, for getting my hopes up.
17:02:34 <Botje> I kind of forgot about them
17:02:47 <Botje> so now I get to watch all 49 episodes in two days :)
17:03:01 <Botje> if I watch enough of it , hopefully something sticks
17:03:46 <ddarius> Botje: Adjunction 3 is enjoyable.
17:04:04 <Botje> I've just finished adjunctions
17:04:13 <Botje> but I got lost somewhere around the start of 2
17:05:53 <monochrom> Perhaps I should watch catsers too.
17:06:27 <ddarius> monochrom: It's worth watching.  Not too time consuming and entertaining.
17:06:38 <monochrom> In those nights when I want to watch a movie on DVD, but find that I have already watched all of my DVDs.
17:07:11 <augustss> @seen Peaker
17:07:11 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
17:07:50 <augustss> is the bot sick again?
17:08:12 <monochrom> The bot's @seen has always been sick. But try this...
17:08:18 <monochrom> preflex: @seen Peaker
17:08:29 <xd_> no @
17:08:32 <monochrom> Eh? That is supposed to work.
17:08:32 <jre2> is there a hackage download log in addition to the upload one?
17:08:37 <monochrom> preflex: seen Peaker
17:08:37 <preflex>  Peaker was last seen on #haskell 3 hours, 22 minutes and 12 seconds ago, saying: augustss: I opened your blog and the last entry is the Expr one from March 09, I demand some new material :)
17:08:43 <monochrom> OK thanks xd_
17:09:05 * Pseudonym reminds himself to leave with something quotable
17:09:19 <Pseudonym> preflex == posterity
17:09:40 <monochrom> That is some adjunction.
17:09:55 <ddarius> preflex: seen Pseudonym
17:09:55 <preflex>  Pseudonym was last seen on #haskell 35 seconds ago, saying: preflex == posterity
17:10:57 <augustss> preflex: seen preflex
17:10:58 <preflex>  what
17:11:22 <monochrom> computer scientists always check out fixed points first. :)
17:11:32 <ddarius> preflex: seen
17:11:32 <preflex>  Sorry, I haven't seen
17:12:46 <heatsink> preflex: version
17:12:47 <preflex>  1.771
17:13:26 <augustss> preflex: boo
17:14:01 <augustss> i scared it
17:21:09 <Heffalump> perhaps it's still in recursion trying to answer your first question
17:21:39 <mauke> preflex: seen
17:21:39 <preflex>  what
17:21:43 <mauke> fixed
17:21:57 <monochrom> preflex: seen preflex
17:21:57 <preflex>  what
17:22:06 <monochrom> preflex: seen lambdabot
17:22:07 <preflex>  lambdabot was last seen on #haskell 14 minutes and 55 seconds ago, saying: Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
17:22:16 <Smokey`> > "preflex: seen mauke"
17:22:18 <lambdabot>  "preflex: seen mauke"
17:22:27 <monochrom> If preflex watches over lambdabot, who watches over preflex?
17:23:50 <preflex> I watch myself
17:23:55 <BMeph> Hey, guys, sorry I came in at the end of the "try to teach slam28 'Monads in a Soundbite'." Did anyone try to explain to him how his perspective towards his questions were a little overreaching? :)
17:24:52 * Smokey` hears the M word and runs away in fear
17:25:13 <mjrosenb> Smokey`: ohh :(
17:25:23 <Smokey`> I still don't grasp the concept of Monads :(
17:25:30 <jre2> BMeph: they're current in haskell-overflow
17:26:23 <mjrosenb> Smokey`: have you tried to use them at all?
17:26:58 <Smokey`> mjrosenb: no... which might be half the reason I don't understand them... (I haven't touched Haskell in over a year, I just idle here becaues I have this underlying feeling that I really should be using it)
17:27:03 <Peaker> augustss: here I am
17:27:14 <mauke> Smokey`: oh, that's normal then
17:29:38 <jre2> question, what do you usually call TODO,FIXME,XXX, etc? I've heard "tag" and "placard", but neither are satisfying descriptors.
17:30:45 <geezusfreeek> flag?
17:30:52 <mauke> I call it Todo
17:30:58 <BMeph> jre2: Ah, so the Battle Continues... thanks, I'll drop in. :)
17:31:29 <jre2> mauke: you call FIXME a Todo?
17:32:07 <mauke> vim agrees!
17:32:42 <heatsink> what does XXX mean?
17:33:07 <mauke> uɹod ǝǝɹɟ ɹoɟ ǝɹǝɥ ʞɔılɔ
17:33:07 <jre2> heatsink: sun uses it to mean "this is bogus, but works"
17:34:01 <heatsink> ah.
17:34:03 <lament> i use HACK for that
17:34:24 <heatsink> I don't do that often enough to use a three- or four-letter abbreviation for it :P
17:34:45 <lament> (even without a tag, if your comments have the word 'hack' in them somewhere that's a big warning sign) :)
17:35:04 * lament stares at his code
17:35:10 <lament>  // Observe how hacky the following is, and never do that again!
17:35:11 <jre2> true, I'm just curious what other people call that class of identifiers
17:35:43 <Spark> // Love shack is a little place where, we can get togetherrrr
17:35:54 <jre2> lament: I try to stick to using them explicitly so I can parse them easily with grep
17:36:37 <Spark> vim colours them in
17:36:38 <Spark> which is nice
17:36:43 <jre2> also what Spark said, except I have taste
17:36:56 <Pseudonym> Can you believe that Kate Pierson is 60 years old?
17:37:11 <monochrom> TPS report forward outlook objective category
17:37:13 <ddarius> Pseudonym: Yes.
17:37:23 <Pseudonym> Yeah, but it doesn't seem right, you know.
17:37:25 <Spark> jre2: use a colour scheme which is compatible with your tastes then
17:37:36 <Spark> i like inkpot
17:37:38 * ddarius has no idea who Kate Pierson is.
17:37:39 <Spark> very non-bright
17:37:46 <jre2> Spark: ...I meant the B52 song
17:37:49 <Pseudonym> ddarius: The B52s
17:38:00 <ddarius> Pseudonym: Ah.
17:38:01 <jre2> incidently I also use inkpot
17:38:06 <Pseudonym> Oh, and that one REM song.
17:38:21 <Spark> jre2: ah yes
17:38:26 <Spark> jre2: lol ok
17:38:30 <Spark> jre2:  also don't like that song
17:38:35 <Spark> *i also
17:38:54 <Associat0r> Smokey`
17:43:01 <dmwit> Is Haskell grammar context-free, assuming explicit {;} instead of layout?
17:43:06 <dmwit> Same question, but with layout?
17:43:21 <Pseudonym> dmwit: Yes.
17:43:31 <dmwit> lovely
17:43:49 <Pseudonym> Your're right, though, that the layout rule complicates things utterly.
17:44:02 <Heffalump> are you ignoring fixity declarations?
17:44:25 <dmwit> Yep, all I have to do now is figure out *why* the layout rule is context-free. ;-)
17:44:36 <Smokey`> Associat0r
17:44:50 <dmwit> Heffalump: yes
17:45:10 <dmwit> Heffalump: Imagine parsing exclusively for a syntax-highlighter, rather than for compilation.
17:45:22 <dmwit> (Since that's what I'm thinking about right now. =)
17:45:38 <Heffalump> I'd still hope for a syntax highlighter to be able to highlight subexpressions
17:45:58 <dmwit> Does fixity change the interpretation of subexpressions?
17:46:15 <Heffalump> it changes which sequences of tokens are subexpressions and which aren't
17:46:20 <dmwit> i.e. can fixity change some token from, say, identifier, to, say, constructor?
17:46:35 <dmwit> oh, hm
17:46:39 <Spark> i'm still divided about whether or not the meaningful whitespace is a good idea in programming languages
17:46:39 <dmwit> Can you tell me more, then?
17:46:41 <Heffalump> wait, are you just interested in the lexical syntax?
17:47:09 <Heffalump> I bet that's context-free without the layout rule.
17:47:09 <dmwit> I'm not sure.
17:47:21 <dmwit> Can you tell me more about the fixity problem or point me to some reading on it?
17:47:41 <Heffalump> dmwit: 5 <+> 3 <*> 2 parses differently based on the fixities of <+> and <*>
17:47:47 <dmwit> (I'm searching haskell.org right now.)
17:47:54 <Spark> is it possible to do a preprocessing step that converts layout code into non-layout code?
17:47:58 <Spark> then parse that
17:47:58 <Heffalump> which might make 5 <+> 3 a subexpression, or 3 <*> 2 a subexpression
17:48:00 <Heffalump> Spark: yes
17:48:03 <dmwit> Heffalump: Oh, yeah, that's fine.  5,3,2 would still parse as number constants.
17:48:13 <Spark> Heffalump: is that a sensible approach for implementation
17:48:18 <Heffalump> right, hence my point that you might just care about the lexical syntax
17:48:18 <Spark> Heffalump: does it generalise to any layout grammars
17:48:23 <Heffalump> Spark: I think it's what GHC does.
17:48:29 <Spark> then it must be right :p
17:48:35 <Spark> it seems sensible
17:48:36 <Heffalump> I don't think the layout rule as defined in the grammar is actually sanely implementable.
17:48:44 <dmwit> I'm not sure what lexical syntax means.  But I'm pretty sure I don't need very much information to do Pretty Good highlighting.
17:49:03 <monochrom> lexical syntax probably means tokens
17:49:14 <Heffalump> dmwit: tokenisation, basically. Making a string of tokens like "integer", "keyword", etc.
17:49:18 <dmwit> I'd like slightly more than that.
17:49:21 <Heffalump> As opposed to making a proper parse tree.
17:49:23 <Spark> most syntax hilighting is no more than hat
17:49:47 <Spark> and to be honest, as soon as you have more than that, the colours flash as you type, which gets quite irritating
17:49:57 <dmwit> That's what timeouts are for.
17:50:31 <monochrom> That's what <flash> </flash> are for.
18:01:44 <mofmog> so
18:01:58 <mofmog> a monad takes an astronaut and returns an astronaut in a spacesuit
18:02:41 <ddarius> mofmog: Yes, except the astronaut died of explosive decompression and so there was nothing to put in the spacesuit.
18:02:58 <mofmog> ah i see
18:03:09 <mofmog> there are no good tutorials are there
18:04:10 <ddarius> @where goodtutorial
18:04:10 <lambdabot> http://homepages.inf.ed.ac.uk/wadler/papers/essence/essence.ps
18:05:09 <mofmog> I meant, for those of us without PhDs in mathematics
18:05:24 <ddarius> mofmog: That doesn't require anything but basic knowledge of Haskell.
18:05:25 <BMeph> ddarius: The freaky thing, though, is that you can still "order around" the spacesuit, and it works as if there were a living astronaut in it.
18:05:52 <mofmog> ahh yes
18:06:03 <mofmog> i told the monad spacestation to be more efficient at moving just spacesuits
18:06:12 <mofmog> and it decided the best way was to extract the human inside
18:06:48 <BMeph> ddarius: Or, I guess the better way to say it, is that the spacesuit without an astronaut in it doesn't act differently from one with an astronaut in it, until you ask the astronaut specifically for something. :)
18:17:38 <dolio> Why are we talking about astronauts?
18:18:15 <dmwit> moands
18:18:20 <mjrosenb> :t liftM2
18:18:21 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
18:20:56 * dmwit has just had the pleasure of typing module Module(Module(Module)) where...
18:21:13 <dolio> Nice.
18:21:25 <Pseudonym> Remind me not to hire dmwit, he doesn't name his modules sensibly.
18:21:33 <dmwit> ;-)
18:22:00 <ddarius> Pseudonym: What are you supposed to do when generalizing vector spaces?
18:22:00 <Pseudonym> I call all my modules "Module", all my types "Type" and all my constructors "Constructor".
18:22:04 <Pseudonym> You got a problem with that?
18:22:21 <dmwit> But what if you are defining a data type to represent Haskell modules?
18:22:22 <Pseudonym> ddarius: You could distinguish between LModule and RModule.
18:22:29 <ddarius> Pseudonym: True.
18:22:53 <dmwit> Or, say, modules for an IRC bot? ;-)
18:22:58 <Pseudonym> dmwit: I think it's rare that you would put such a type in its own module.
18:23:11 * BMeph coughs, >IRCModule!<
18:23:19 <Pseudonym> Quite.
18:23:21 <dmwit> Nonsense, it's already in the IRCBot namespace.
18:25:04 <Peaker> I think its funny that its 2008 and we're still talking about programming language syntax issues like whitespace
18:25:18 <Pseudonym> Peaker: Wadler's law.
18:25:26 <Pseudonym> ?go wadler's law of language design
18:25:27 <lambdabot> http://www.haskell.org/haskellwiki/Wadlers_Law
18:25:27 <lambdabot> Title: Wadlers Law - HaskellWiki
18:26:02 <mjrosenb> Peaker: when there are languages like python, it matters
18:26:44 <Peaker> mjrosenb: I think using textual syntax to encode semantics in a file is a sad state of affairs for 2008. But, given that, at least force that text to look like it means
18:27:43 <ddarius> Yeah, people stopped putting their ideas into text a long... uh...
18:28:06 <Peaker> ddarius: There's a difference between putting ideas into text, and storing rich data structures as text
18:28:22 <Peaker> ddarius: code is a bit more well-formed than generic "ideas"..
18:29:21 <Peaker> the problem is, I think, that people conflate presentation (for which text might be a good idea, in this context) and serialization (for which text is a horrible medium)
18:30:02 <mjrosenb> Peaker: you want to treat sources as serialized programs?
18:30:11 <Peaker> how you serialize the program doesn't matter, except that because its being serialized as text, its harder to add more metadata to it. Having the editors work on the syntactic text, rather than semantic structure is also extremely limiting
18:30:54 <Peaker> mjrosenb: That's already the case - except I don't want to _see_ them exactly the way they're serialized. That's limiting
18:31:17 <Peaker> sources _are_ serialized programs. Syntax is a serialization format for semantic models (albeit a poor one)
18:31:40 <Peaker> in fact, syntax highlighting already changes the presentation a bit from the way they're serialized, but we should go way further than that
18:32:11 <mjrosenb> Peaker: i'd like to see a function executable -> haskell source that 'serializes' any given executable
18:33:17 <Peaker> mjrosenb: I didn't mention executables.  I am talking about the semantic model that's currently serialized AND presented in the same way - as Haskell syntax.  I believe we should serialize it to some arbitrary data structure (preferably one that enables easy and fast random-access for faster code browsing), and present it in any way we choose, at edit time
18:34:05 <Peaker> Also a serialization format that doesn't use names for generating links could be nice, freeing us to use names as more meaningful comments, without annoying lexical rules
18:34:24 <mjrosenb> Peaker: iirc, there's a wonderful program called gturtle.  you should check it out.
18:34:24 <ksandstr> ... forth?
18:34:48 <Peaker> ksandstr: afaik, Forth is also presented and serialized as a textual syntax?
18:34:58 <ksandstr> Peaker: with very few explicit variables.
18:35:00 <Peaker> mjrosenb: turtle graphics?
18:35:48 <Peaker> ksandstr: I don't want to "cancel names" altogether, I want to change their function from being comments AND lexical-references/links, to only being comments. The links can be stored in the rich format as real references or w/e
18:35:59 <mjrosenb> Peaker: turtle art... it ships with the olpc
18:36:16 <Peaker> mjrosenb: what does turtle art have to do with the way code is presented and stored?
18:36:25 <ksandstr> Peaker: is killing the conventional text editor worth it?
18:37:11 <Peaker> ksandstr: Definitely. The conventional text editor is a hideous limitation on our productivity as programmers. It could do so much more to help us edit programs, but because its interacting with "dumb text" its too difficult for it to do it
18:37:25 <mjrosenb> Peaker: you never see an ascii representation of your code.  you can browse it fast, you can get a good overview of what it does at a glance, etc.
18:37:37 <mjrosenb> Peaker: it seems to be the perfect language for you
18:38:04 <Peaker> mjrosenb: I do believe a textual (not necessarily ASCII, could be unicode :-) representation of code is a useful _presentation_. But it should not be bound to the way the program is internally represented
18:38:04 <ksandstr> Peaker: i remember there were these flowchart-based languages for microcomputers in the early to mid-nineties
18:38:16 <ksandstr> ... and of course ladder logic
18:39:13 <Peaker> ksandstr: Flow-charts are a horrible representation, IMO. I think this is where the problem lies.  People conflate presentation and internal-representation.  I am saying, lets KEEP the syntax as a presentation, but change the backend storage.  This will free us to tweak the syntax being presented in useful ways (show/hide static types at the stroke of a key, as a trivial example)
18:39:56 <Peaker> ksandstr: This will let us have useful features like having the program structurally coherent at all times. This enables things like showing the program running on a test case while you edit it, for example
18:39:58 <mjrosenb> Peaker: i think you need to get a better editor and just leave the concrete syntax be
18:40:06 <Peaker> mjrosenb: which editor would that be?
18:40:21 <ksandstr> Peaker: yes, that was mild ridicule. but TBH i'm kind of left wondering how editing haskell would feel if instead of <- the editor displayed an Unicode arrow-to-the-left
18:40:22 <mjrosenb> Peaker: well i use emacs, and it seems to do just fine
18:40:25 <Peaker> mjrosenb: No textual editor can do what I want - because they are all limited by the way they interact with the semantics -- via the textual encoding of it
18:40:34 <gwern> ksandstr: not much different, actually
18:40:37 <Peaker> mjrosenb: "just fine" is quite relative. It could do so much more
18:40:54 <gwern> ksandstr: if you want to see, turn on unicode symbols in emacs haskell-mode
18:41:00 <mjrosenb> Peaker: that's what your compiler does.  you can't do more than shoving the compiler into your editor
18:41:16 <mjrosenb> gwern: how do you do that?
18:41:17 <Peaker> ksandstr: well, again, it doesn't have to.   I think a simple point is that at the _worst-case_, it will look just like now but make editors much smarter and richer
18:41:18 <ksandstr> gwern: ah. figures there'd be such a thing for emacs already
18:41:29 <gwern> mjrosenb: set a variable, if course
18:41:30 <mjrosenb> gwern: i've done it for sml-mode, but not haskell-mode
18:41:39 <mjrosenb> gwern: right.  which one?
18:41:39 <Peaker> mjrosenb: shoving the compiler into the editor is significantly easier if it doesn't require parsing the code and handling incoherent syntax
18:41:53 <ksandstr> Peaker: ok. and why would you want to modify the _language_ to accomplish this?
18:41:58 <gwern> ksandstr: yeah. as I said, it doesn't make much different. it looks a little nicer, but that's all. now, I dunno about agda...
18:42:19 <gwern> mjrosenb:                                    (setq haskell-font-lock-symbols 'unicode)
18:42:31 <mjrosenb> Peaker: parsers have been a solved problem for decades.  i don't think so
18:43:04 <Peaker> ksandstr: The language becomes two things. A semantic model (and its serialization format), and its presentation.  I believe we can initially keep the latter, and definitely keep the semantics, but would probably change the serialization format as syntax..
18:43:23 <Peaker> mjrosenb: Why does emacs not let me do semantic auto-completions?
18:43:41 <ksandstr> Peaker: liskell? the C-like indentation-substitute syntax?
18:43:50 <mofmog> using x <- something is similar to how let statements are desugared in lisp right?
18:44:00 <Peaker> ksandstr: the what? I'm not familiar with that
18:44:01 <mofmog> (\x -> balbhalbhab) statement
18:44:14 <Peaker> ksandstr: consider the horrible hack of placing extra proof code inside comments
18:44:18 <mjrosenb> mofmog: not quite
18:44:22 <dobblego> mofmog, no, you're inside a monad at that point
18:44:22 <Peaker> ksandstr: the reason this is done is because syntax is not extensible
18:44:26 <Peaker> ksandstr: an arbitrary serialization format is
18:44:32 <EvilTerran> ksandstr, liskell is a lisp-like language with haskell-like semantics
18:44:34 <EvilTerran> ?where liskell
18:44:34 <lambdabot> http://clemens.endorphin.org/liskell
18:44:41 <EvilTerran> *lisp-like syntax
18:44:58 <mofmog> well it takes the something and passes it into x
18:44:59 <mofmog> somehow
18:45:00 <ksandstr> EvilTerran: yes, i know. i was trying to say that different representations of haskell-the-semantics already exists (sort of)
18:45:08 <Peaker> mjrosenb: the reason, if you have ever tried implementing elisp extensions, is that implementing _semantic_ features in a text editor is very difficult. Do you know why?
18:45:11 <EvilTerran> oh, i seeee. nvm.
18:45:47 <dobblego> mofmog, take a look at how <- desugars; it uses >>= and return, not a simple lambda
18:46:01 <mjrosenb> Peaker: because nobod's bothered to write a good parser generator/parser combinator for elisp
18:46:08 <Peaker> ksandstr: that's great, though I think a non-textual representation can have some benefits (faster random access/browsing/code searches in the editor)
18:46:14 <mjrosenb> dobblego: it also uses a lambda
18:46:24 <ksandstr> Peaker: faster browsing! what are you on, a 100mhz pentium one?
18:46:27 <Peaker> mjrosenb: so which editor can I use that makes semantic editing features easily possible?
18:46:47 <ksandstr> Peaker: sorry. aren't these things already solved?
18:46:48 <Peaker> ksandstr: No, but when you work on very large projects, grepping textual sources takes long times
18:46:57 <ksandstr> via ctags and such
18:47:12 <Peaker> ksandstr: ctags IS a non-textual representation that needs to be kept in sync with the code
18:47:25 <Peaker> ksandstr: just make the code itself be serialized to a searchable form instead of keeping things in sync
18:47:31 <ksandstr> Peaker: and thus the appropriate stanza in the toplevel Makefile is born.
18:47:56 <ksandstr> Peaker: that's really more of a question of IDE bloat
18:47:58 <Peaker> ksandstr: It could be nice if things just worked, without having to manually write kludges and activate them every time :-)
18:48:15 <lament> Peaker: You know the joke about russian austronauts and how they used a pencil?
18:48:22 <Peaker> lament: yeah
18:48:35 <lament> Peaker: what you're proposing is a really, really complicated and expensive pen
18:48:46 <lament> when excellent pencils are already available
18:48:59 <Peaker> ksandstr: this is a minor point though, its not very important. The important thing is disconnecting the presentation and constantly-structurally-coherent programs
18:49:15 <Peaker> lament: What I'm proposing is simpler, not more complicated than the current model
18:49:33 <lament> what can be simpler than plaintext representation?
18:49:36 <ksandstr> Peaker: we already disconnect the presentation and the representation, with a text editor. (unless some types who just "cat" to a file.)
18:49:38 <Peaker> lament: We already represent code as a rich data structure/semantic model in the compiler, in smart editors, etc. This is duplicated many times
18:50:05 <Peaker> ksandstr: not enough - editors still edit a string, instead of editing a semantic model. The keyboard shortcuts reflect this, and the limitations we still have do too
18:50:18 <Peaker> lament: but today's extra complexity is that we ALSO represent it as text, parse it, encode it, etc
18:50:47 <ksandstr> Peaker: and how would you edit the semantic model, if not in text? it's a qwerty keyboard because of its history as a typewriter component...
18:50:57 <Peaker> lament: if there was a rich datatype to represent the code as a semantic model (the same one used in compilers/editors/etc), and that datatype was stored in files, and edited directly, it would be simpler, not more complicated
18:51:11 <Peaker> ksandstr: I would edit it with 105 keys that happen to have textual letters written on them
18:51:12 <ddarius> Peaker: So stop talking about it and make it.
18:51:17 <lament> Peaker: editing is simplest with a text editor
18:51:40 <Peaker> lament: Do you edit music with a text editor, for example?
18:51:47 <ksandstr> Peaker: is this a bit like those 8-bit computers from the eighties where the keys had shortcuts on them? like "lI" was short for list.
18:51:59 <lament> Peaker: that's a very, very good point
18:52:04 <lament> Peaker: textual representation is not the most simple
18:52:16 <lament> Peaker: the simplest representation is what you get with a piece of paper and a pencil
18:52:20 <dmwit> Of course, there's not so many languages for representing music.
18:52:23 <Peaker> ddarius: I did create a prototype. But I decided I have more and more ambitious goals and currently I am a little stuck brainstorming at how to achieve all of those goals
18:52:25 <lament> Peaker: ...and that's how i edit my music
18:52:44 <ksandstr> and also the way that music is edited on a computer replicates the way that music is edited with pencil on paper
18:52:54 <ksandstr> same as the editor replicates the typewriter and ultimately pencil on paper.
18:52:55 <lament> when i needed to typeset some music, i did it in lilypond (which is plain text)
18:52:57 <asdftimo> hi, how can i do: $> product (take 5 "123456") ???
18:52:57 <ddarius> Peaker: Good luck.  There is a long line of people who have tried to make such things and failed to impress anyone.
18:53:10 <lxuser> Peaker, what's a semantic model? abstract syntax trees or what?
18:53:13 <asdftimo> do i need digitToInt?
18:53:15 <Peaker> ksandstr, lament: My point is that a text-editor is not necessarily the best way to edit a given piece of data. It probably rarely is
18:53:22 <Peaker> lxuser: A bit higher than an AST
18:53:27 <ksandstr> Peaker: well, sounds like research topic for sure.
18:53:28 <dmwit> > product . map digitToInt . take 5 $ "123456" -- why not try it, asdftimo?
18:53:30 <lambdabot>  120
18:53:33 <Peaker> ddarius: Are you not impressed by Subtextual?
18:53:39 <ddarius> Peaker: No.
18:54:07 <asdftimo> dmwit: i knew i could make it work, i was just looking for the best solution. thanks for your help.
18:54:11 <Peaker> ddarius: Well, I am very impressed with his ideas, and I believe they can be taken further. My little C editing prototype impressed a lot of random developers I showed it to
18:54:13 <ksandstr> now there's a funny idea: a programming language editor based on mouse gestures
18:54:20 <dmwit> asdftimo: Yes, you need digitToInt.
18:54:38 <lament> Peaker: I just bought an ergonomic mouse yesterday. It turns out to be less comfortable than a normal mouse, because it only works when you're sitting with perfect posture. A non-textual editor would be a lot like that mouse. Too specialized for its own good.
18:54:53 <lament> I'm returning the mouse tomorrow.
18:54:58 <ddarius> Peaker: By "impress", I mean, "get people to use".  The most successful thing on this route is probably, well, Excel, but for things typically viewed as programming languages, Smalltalk.
18:55:02 <Peaker> lament: that's a bit of a strawman don't you think? :)
18:55:09 <ksandstr> lament: that sounds a lot like pascal
18:55:10 <lament> Peaker: No. It's the exact same thing.
18:55:20 <lament> Peaker: Too specialized is worse than not specialized enough.
18:55:40 <lament> plain text is wonderfully non-specialized
18:55:47 <lament> (paper and pencil, even more so)
18:55:55 <Peaker> ddarius: well, unfortunately, I don't think people have tried yet to disconnect the presentation of the language from its serialization without also creating radical new presentations for the code (e.g flowcharts, subtext, etc) which repel adopters
18:56:16 <ddarius> Peaker: You've heard of the "Intentional Programming" project, no?
18:56:19 <ddarius> Or SCID?
18:56:24 <Peaker> lament: your mouse was specialized for something you don't really do (sit in perfect posture). Who says the editor will be the same?
18:56:34 <jsnx> ddarius: do you write code with tabs in it, or lines that are longer than 78 columns?
18:56:45 <ddarius> jsnx: No, yes.
18:56:47 <Peaker> ddarius: yes, I read the patent that Intentional Software applied, and it covers a lot of what I did in the C prototype
18:56:49 <jsnx> !!
18:57:00 <Peaker> ddarius: SCID, I am not sure
18:57:14 <lament> Peaker: well, the most difficult part is making the editor work with partially correct code
18:57:25 <lament> just like the mouse couldn't cope with my partially correct posture :)
18:57:30 <Peaker> lament: please distinguish partially-correct from structurally-incoherent, though
18:57:38 <ddarius> http://mindprod.com/project/scid.html
18:57:39 <lambdabot> Title: SCID
18:57:49 <Peaker> lament: you can have only-partially correct but structurally coherent programs just fine
18:57:53 <lament> partially incorrect, as in a complete mess that's completely meaningless to any parser
18:57:59 <lament> structurally incoherent as well
18:58:13 <lament> your programs are in that state quite often as you type them in
18:58:15 <Peaker> lament: the thing is - there really is no need to pass through syntactical incoherence
18:58:29 <Peaker> lament: logical/functional incompleteness - sure
18:58:51 <lament> int main(
18:58:58 <ksandstr> how would the programmer develop "code eyes" working with such an environment?
18:58:59 <lament> ...and that's where i stopped typing and went for lunch or something
18:59:42 <ksandstr> i.e. that thing where you go "oh, that's a data declaration" without reading one character
19:00:06 <lorne> then you can't elaborate that shed ;)
19:00:09 <lament> ksandstr: it would have extremely intelligent syntax highlighting, of course
19:00:27 <lament> since it's semantics-aware
19:00:47 <Peaker> lament: you either use the "create function" key, or you start typing a type-name and it creates a structurally-coherent declaration where you just need to "fill in" the details.  After int main, when you type ( it converts it to a function declaration, where you just need to fill in the args..
19:01:14 <lament> Peaker: some IDEs try to use that
19:01:17 <lament> s/use/do
19:01:24 <lxuser> Peaker, yes there is.  editing code in a way that respected its syntactical structure at all times would be a PITA.
19:01:28 <Peaker> lament: its trivial to keep it structurally coherent yet still associate the common operations with keys
19:01:32 <lament> it's far more painful than simply typing int main(  :)
19:01:33 <jsnx> Peaker: this has larger implications that are unsavory
19:01:34 <dolio> lorne: Been writing Epigram?
19:01:45 <lament> the only language where that can possibly work is Lisp
19:01:47 <jsnx> Peaker: for example, I can no longer search my code with grep
19:01:53 <lament> but that's because Lisp has no structure to speak of
19:01:58 <Peaker> lament: what usefulness does allowing the "int main(" intermediate stage is?  That you can accidentally leave that in and get cryptic compilation errors later?
19:02:04 <lorne> dolio: caught! yes.
19:02:05 <geezusfreeek> i just went back and started watching the subtext video again
19:02:15 <geezusfreeek> and now i am thinking these tables look a lot like monadic do notation
19:02:30 <ddarius> geezusfreeek: Don't let Haskell corrupt your mind!
19:02:33 <lament> Peaker: what usefulness is in sitting with incorrect posture? None. It's just something I do a lot.
19:02:44 <Peaker> jsnx: Not necessarily, you might have a   code2text  code.db | grep ...  Also, you will have really fast and much better code searches than the antiquated grep
19:02:56 <Peaker> lament: obviously it has usefulness then
19:03:01 <lxuser> lament, it can be done fairly easily for java, and of course Lisp.
19:03:03 <lament> Peaker: okay, then. It's more convenient.
19:03:08 <geezusfreeek> i still can't quite get the internals in my head right yet though
19:03:11 <geezusfreeek> working on it
19:03:18 <jsnx> Peaker: whether they are faster or better is not so important
19:03:19 <lament> Peaker: just as simply typing int main( is more convenient than whatever solution you're proposing
19:03:28 <Peaker> lament: Great. Why is it more convenient that the editor does not show the closer ) (note you do the exact same operations)
19:03:29 <dolio> I think epigram is about as far in that direction as I'd want to go. At least, that I've seen so far.
19:03:48 <Peaker> lament: my solution allows for the exact same keystrokes to do the same thing, except keep it structurally coherent
19:03:50 <jsnx> Peaker: the code2text thing makes a lot of sense though
19:04:06 <jsnx> Peaker: might as well have one canonical representation to search
19:04:11 <Peaker> jsnx: it could be useful for a few years until people get rid of silly old habits  :)
19:04:23 <jsnx> Peaker: why is pipelining a silly old habit?
19:04:27 <Peaker> jsnx: searching "who calls this?" and "who defines this?" is much more useful than a grep
19:04:33 <lxuser> Peaker, parse errors are _less_ cryptic than leaving out the semantics
19:04:37 <SamB> I hope epigram 2 has a decent editor
19:04:38 <Peaker> jsnx: pipelining isn't silly, "grep" is a horrible code search tool
19:04:50 <lament> "who calls this" and "who defines this" are things Visual Studio does really well.
19:04:52 <Peaker> lxuser: "leaving out the semantics"? what does that mean?
19:04:53 <jsnx> Peaker: the problem is IDEs
19:05:01 <lament> Visual Studio does quite a lot of semantic analysis of code
19:05:07 <Peaker> lament: Do you know how much effort needs to be done for Visual Studio to do those things well?
19:05:11 <lament> but it keeps it in textual representation anyway
19:05:18 <lament> Peaker: probably a ton.
19:05:19 <jsnx> Peaker: i suppose if this were framed in terms of a code format and then a collection of tools, i could live with it
19:05:21 <SamB> lament: I just wish it would parse headers from the include path...
19:05:22 <Peaker> lament: it obviously keeps a non-textual representation as well
19:05:29 <lament> Peaker: but it's already there and it already works
19:05:37 <Peaker> lament: no, its not really "there"
19:05:37 <lament> and you seem to be proposing something far more radical
19:05:43 <Peaker> lament: it can't do a ton of things I'd want it to do
19:05:56 <lament> like?
19:06:02 <ksandstr> imo, much too radical considering like fifty years of tradition
19:06:09 <jsnx> Peaker: but all the projects i've seen on this code-as-data stuff monolithic, take-it-or-leave it GUI apps
19:06:15 <lament> rum, sodomy and the lash
19:06:30 <Peaker> lament: Define the variable of the name I just typed as local in this function, with the right inferred type, and then use it
19:06:45 <jsnx> Peaker: how will i munge a critical application over SSH?
19:06:49 <Peaker> lament: Or: Find me a function that can convert this type to that, and apply it
19:07:07 <Peaker> lament: Or: Please factor the code that computes this variable to a method
19:07:07 <jsnx> Peaker: you guys would need to write a curses GUI or something
19:07:10 <ksandstr> jsnx: X tunneling.
19:07:18 <jsnx> ksandstr: not fast enough
19:07:29 <lament> Peaker: seems like those features would be quite easy to add to visual studio, given all the stuff already in it.
19:07:37 <lament> Peaker: in fact, you could even write such a plugin, and sell it.
19:07:39 <jsnx> ksandstr: that's why i had to learn VIM in the first place
19:07:52 <lxuser> lament, the textual representation of Java and probabli C# was deliberately simplified in order to make these things easier. this seems to be the best compromise
19:07:57 <ksandstr> jsnx: exactly.
19:08:08 <lament> lxuser: i believe so, too.
19:08:13 <Arnar_> @seen byorgey
19:08:13 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
19:08:19 <jsnx> ksandstr: please explain your point of view
19:08:20 <Peaker> lament: I doubt it.  Also, I'd like it if I was able to see the code with/without the static types.  Or if I didn't have to put semicolons everywhere correctly
19:08:23 <lxuser> *probably
19:08:40 <jsnx> Peaker: indentation based syntax okay?
19:08:53 <ksandstr> jsnx: i was just about to say something to the effect of how well would this new and groundbreaking user interface work e.g. remotely
19:08:58 <Peaker> jsnx: Its a little better, but also not perfect
19:09:04 <jsnx> Peaker: i grant that
19:09:55 <ksandstr> jsnx: but i have a sneaking suspicion that all code would go into a remote-access repository by default, so it works remotely over a custom protocol or something
19:10:18 <Peaker> lament: I have seen the horror plugins that try to add semantic features to emacs. They usually work 80% of the time and fail the rest. When something fails that often you just don't use it. The reason? They're horribly complicated because its just so damn difficult to implement semantic featuers at the text level
19:10:19 <jsnx> ksandstr: yes, and we need special editors for it
19:10:27 <ksandstr> jsnx: and everything will be Different.
19:10:31 <Peaker> lament: there's also this Haskell extension language that extends it by adding information inside comments
19:10:55 <jsnx> so, say every source file were a deductive database instead of plain text
19:11:11 <Peaker> lament: this is an example of where syntax is not extensible, and simply limited. It could be nice to be able to add arbitrary information to code that you don't always have to clutter your view when watching the code.  Strictness annotations, optimization hints, can all be assocaited with the code without cluttering it
19:11:15 <dolio> Which language?
19:11:29 <jsnx> then we could have a deductive database editor (a database client like sqlite) that would allow us to munge the raw stuff
19:11:50 <jsnx> and then languages would be stored by stuffing various facts into the deductive database
19:12:04 <ksandstr> ... prolog?
19:12:08 <jsnx> and people could write fancy editors for these languages, that knew the meaning of the facts
19:12:12 <lament> Peaker: re emacs: I know that emacs sucks.
19:12:16 <lament> no surprises there.
19:12:19 <jsnx> ksandstr: datalog -- prolog is not pure enough
19:12:23 <Peaker> also, silly syntactical debates as often appear in Haskell (whether or not we prefer () around sub-expressions, whether associativity should go left or right) would become a configuration option
19:12:28 <lament> Peaker: that's why i'm consistently using visual studio as an example.
19:12:55 <Peaker> "I want to see unnecessary ()" could be an option
19:12:56 <monochrom> <while strict="yes" style="cata,fuse"><test>x>0</test><body>x:=x+1</body></while>
19:13:00 <jsnx> however, we would still have a "base format" shared by all editors and languages -- the deductive database
19:13:03 <lament> anyway, later
19:13:11 <jsnx> it would be clean enough to derive semantic relations from
19:13:34 <jsnx> but it would not be a custom cut format that tied you to an editor
19:14:03 <SamB> what the heck?
19:14:16 <Peaker> jsnx: if you have an 'export' feature to any readable format (e.g ".hs" files) you are also not tied to an editor
19:14:19 <SamB> that sounds essentially impossible
19:14:25 <Nafai> So I read a comment on a blog by Ricky Clarkson where he said that Haskell has type erasure
19:14:26 <jsnx> SamB: ?
19:14:28 <Nafai> Does it?
19:14:46 <dolio> Yes, there are no types at runtime (essentially).
19:14:48 <jsnx> Peaker: M$askell will bork the .hs
19:14:48 <SamB> the part where you can derive "semantic relations" from a format shared by all languages
19:15:04 <jsnx> SamB: you can derive them from facts
19:15:08 <dolio> Well, depending on the implementation (jhc might keep them around at runtime, for instance).
19:15:13 <jsnx> SamB: in the same way that you can derive them from text
19:15:16 <ddarius> Nafai: Just ignore the term "type erasure" in these contexts.
19:15:20 <dolio> (Since that's how it does type-class dispatch.)
19:15:29 <jsnx> SamB: only with less parsing
19:15:49 <SamB> jsnx: in that case, you haven't actually said anything with th at statement?
19:15:54 <geezusfreeek> okay, not subtext is just looking like a rediscovery of pattern matching
19:15:56 <geezusfreeek> *now
19:16:20 <jsnx> SamB: there's no degeneracy in a deductive database
19:16:33 <jsnx> whereas text has lots of degeneracy, by design
19:16:49 <SamB> sounds ugly
19:16:59 <jsnx> SamB: check out datalog, which allows one to encode all of first-order logic
19:17:12 <jsnx> it can describe source code
19:17:28 <jsnx> SamB: it can't be uglier than storing the AST
19:17:43 <SamB> I mean it would probably look ugly on the screen
19:17:53 <SamB> also, what is FOL good for anyway?
19:17:56 <jsnx> SamB: yes, which is why you need a database editor
19:18:12 <SamB> how would the database editor make it not look ugly?
19:18:19 <jsnx> SamB: and if you can get a haskell editor for a database of haskell source, that would of course be the nicest
19:18:31 <andyjgill> Has anyone written a Haskell FFI-based interface to Libnetpbm? I could not find anything on hackage.
19:18:34 <jsnx> SamB: well, you would actually query and insert, not edit
19:18:49 <SamB> I'm talking about the appearence of the code on the screen
19:19:07 <jsnx> SamB: i am not an advocate of this approach
19:19:11 <SamB> oh
19:19:14 <jsnx> SamB: i much prefer plaintext
19:19:21 <SamB> why the heck are you talking so much about it then?
19:19:44 <jsnx> SamB: but if they are going to put code in a special format, i'm saying this is what you have to do, to preserve editor-neutrality
19:20:05 <jsnx> text has simple semantics that can encode most programming languages
19:20:22 <jsnx> a deductive database is a step up, and can also encode most programming languages
19:20:26 <SamB> text has semantics?
19:20:31 <jsnx> yes
19:20:36 <SamB> what are they?
19:20:39 <ksandstr> even fhaksdjhfkjqlhkjdvk?
19:20:45 <monochrom> Haha editor neutrality, plain text.  We lost them when we switched from the universal EBCDIC to the newfangled ASCII.
19:20:54 <jsnx> well, you put characters one after another to make strings
19:21:04 <jsnx> monochrom: UTF8 ftw
19:21:06 <SamB> monochrom: um, EBCDIC is a highly fragmented family of encodings iirc
19:21:16 <jsnx> SamB: and that is all the semantics it has
19:21:26 <SamB> perhaps something about newlines...
19:21:29 <jsnx> and ASCII has enough to encode most languages
19:21:42 <ksandstr> jsnx: not quite true. in SNUSP you can also put characters on top of one another
19:21:44 <jsnx> SamB: don't need those for C or M4, though
19:21:45 <SamB> ... too bad there are no less than 3 different ways to encode them ...
19:21:55 <ddarius> jsnx: What's a language that cannot be encoded by ASCII?
19:21:59 <jsnx> APL
19:22:08 <monochrom> Chinese.
19:22:13 <ddarius> I can easily encode that with ASCII.
19:22:22 <monochrom> Oh encode?
19:22:22 <SamB> yeah.
19:22:23 <SamB> me too
19:22:32 <jsnx> ddarius: i thought it had funny unicode code points it needed
19:22:39 <SamB> I could write out the names of the unicode characters between <>
19:22:45 <jsnx> sure
19:22:47 <ddarius> jsnx: I can easily encode funny unicode code points with ASCII.
19:22:51 <jsnx> sure
19:22:52 <ksandstr> or just base64 the utf-8 rep
19:22:57 <jsnx> yes, if you really want to...
19:23:05 <SamB> but my encoding is more faithful
19:23:13 <jsnx> ...my point being, it's a good fit for most languages
19:23:21 <jsnx> and i guess it can even fit APL
19:23:33 <monochrom> Gödel could encode ASCII into prime numbers...
19:23:33 <SamB> concatination would go over as concatenation, see?
19:23:35 <jsnx> so i have an editor for languages, not an editor for a languages
19:24:07 <ksandstr> yes, true, many people use the same editor for editing programs and makefiles and e-mails and latex and so forth
19:24:22 <jsnx> and this happy-shiny-code-as-data needs to pick something that is as flexible
19:24:45 <jsnx> because i am not going to have one editor for email and one for configuration files and one for Visual C++ (hahahahahahaha)
19:24:47 <ddarius> We should encode everything as Pascal programs.
19:24:54 <jsnx> ddarius: no, datalog!
19:25:13 <SamB> jsnx: how do you get there to be enough syntactic commonality between languages that this is in any way reasonable?
19:25:26 <ksandstr> begin trout('#haskell', 'ddarius'); end.
19:25:38 <jsnx> SamB: well, the syntactic commonality is not actually an issue
19:25:47 <SamB> jsnx: isn't it?
19:26:03 <SamB> if you don't have syntactic commonality, what has been gained?
19:26:27 <jsnx> SamB: what you would store in the database is things like function(<name>, <body>) and so forth
19:26:36 <jsnx> vague stuff
19:26:42 <dmwit> I guess you can't pattern match on ByteString's, eh?
19:26:51 <jsnx> dmwit: why not?
19:26:55 <dmwit> What's the most convenient way to declare a ByteString literal?
19:26:57 <SamB> jsnx: so why don't we just store all code as XML
19:27:01 <dmwit> jsnx: Err... I don't know, can you?
19:27:02 <ddarius> dmwit: "foo"
19:27:04 <SamB> that would get us about the same results
19:27:05 <mjrosenb> SamB: NO
19:27:07 <jsnx> SamB: because XML is teh evil?
19:27:08 <ddarius> dmwit: Or pack "foo"
19:27:20 <SamB> I'm just saying, I don't understand the difference
19:27:21 <jsnx> SamB: also, deductive databases allow the definition of rules or relations
19:27:24 <dmwit> ?hoogle pack
19:27:25 <lambdabot> Data.ByteString.pack :: [Word8] -> ByteString
19:27:25 <lambdabot> Data.ByteString.Char8.pack :: String -> ByteString
19:27:25 <lambdabot> Data.ByteString.Lazy.pack :: [Word8] -> ByteString
19:27:30 <jsnx> SamB: wherease XML is just data
19:27:34 <dmwit> Ah, the Char8 one.
19:27:36 <dmwit> ddarius: thanks
19:27:43 <SamB> RDF?
19:28:10 <jsnx> SamB: sort of, but RDF defines a representation as well as a semantics
19:28:38 <SamB> the representation is unimportant
19:28:38 <jsnx> which is probably inefficient for storing tables of floats, &c.
19:28:45 <jsnx> in RDF?
19:28:48 <jsnx> maybe so
19:28:49 <SamB> yes
19:28:54 <jsnx> i don't know that much about it
19:29:09 <SamB> I'm talking about data models anyway
19:29:10 <jsnx> it may be that deductive databases and RDF are very similar
19:29:19 <SamB> okay, next one:
19:29:21 <SamB> Prolog
19:29:37 <jsnx> prolog is a deductive database with side effects
19:29:47 <jsnx> throw away the side effects and you get datalog
19:29:56 <SamB> ah
19:30:00 <jsnx> (that's an oversimplification, but...)
19:30:13 <SamB> so that approach to syntax worked for Erlang ...
19:30:19 <jsnx> SamB: no, no
19:30:21 <SamB> ... originally
19:30:27 <jsnx> they don't have a logical language at all
19:30:35 <jsnx> it just looks like prolog
19:30:54 <jsnx> it doesn't have 'facts' or rules or any of that
19:30:59 <SamB> yes. I believe they used the prolog parser originally ;-P
19:31:00 <jsnx> semantically, it is quite different
19:31:03 <jsnx> heh
19:31:29 <jsnx> so, what i am saying is, we'll store all the code in an opaque database file that you have to edit with a database browser
19:31:41 <Korollary> You can't get datalog by throwing side effects from prolog
19:31:41 <jsnx> and then you can get language specific plugins
19:31:46 <SamB> but, what I mean is: what features does this actually give you if your editor does not know anything about your language?
19:31:57 <jsnx> Korollary: yes, it was an oversimplification, as i admitted
19:32:16 <jsnx> SamB: you still get the ability to find the function with a certain name, for example
19:32:36 <jsnx> and the database can come preloaded with helpful rules about the languages
19:32:40 <SamB> jsnx: what if your language doesn't have functions
19:33:02 <SamB> is there some code associated with all this talk?
19:33:03 <jsnx> SamB: then you find the 'things' that are called 'name' and have other properties
19:33:19 <jsnx> SamB: is there some code associated with all this talk?
19:34:02 <jsnx> i'm just saying, if you want to do code as opaque stuff (not that i do) you need to have a format that allows for a universal editor
19:34:14 * SamB has difficulty understanding why his position would need code
19:34:26 <jsnx> and the deductive database is the right choice for that
19:34:30 <jsnx> and that is silly
19:34:39 <jsnx> and that is because the whole idea is silly
19:34:45 <jsnx> text = good enough
19:35:12 <ksandstr> it wouldn't be as silly if they had some idea of what to plug on the other side of the database, something that couldn't be extracted from "just the plaintext ma'm"
19:35:14 <SamB> something a little bit more like this model of a universal editor might be a good idea...
19:35:22 <jsnx> long spaces, 78 columns, `less`, `vim`, `grep`, `more`
19:35:31 <SamB> ksandstr: there isn't anything like that
19:35:39 <jsnx> SamB: you need the data definition first and the editor later
19:35:47 <asdftimo>  could someone explain what the function "sequence" does? i can't find anything on it.
19:36:00 <ksandstr> SamB: bingo! and why is that? i'd say because text can serialize everything one could input by e.g. gestures or some other weird thing
19:36:01 <SamB> jsnx: I don't see how that could work
19:36:13 <ksandstr> serialize... i meant represent
19:36:18 <jsnx> SamB: well, just see it
19:36:28 <jsnx> squint
19:36:46 <SamB> jsnx: a format could not be reasonably designed without designing at least one editor in parallel
19:37:57 <jsnx> SamB: why not exactly? i don't think anyone made ascii with vim in mind -- and xml is hardly editor friendly -- all the editors came later.
19:38:25 <dmwit> asdftimo: It executes each of a series of monadic actions one at a time.
19:38:45 <asdftimo> dmwit: could you give me an example & its output?
19:38:54 <asdftimo> thanks for the response
19:39:02 <jsnx> SamB: the details of what to store and how to manage it will definitely be driven by the editor pilot
19:39:28 <dmwit> asdftimo: Try 'sequence [putStrLn "hello", putStrLn "world"]' at the ghci prompt.
19:39:32 <jsnx> SamB: but the fundamentals -- is it text or a tree or a deductive database -- these are decisions you don't want to make midstream
19:45:45 <dmwit> Yes!
19:46:48 <Korollary> Yes!!
19:47:14 <SamB> jsnx: well, I think trees will certainly play a critical role
19:47:49 <SamB> tree-less languages tend to be unsuited for large tasks ;-)
19:48:25 <jsnx> SamB: you are sort of missing the point, though
19:48:41 <jsnx> even if the language did not have trees, it's code could still form a tree
19:49:01 <jsnx> like this tree: (+ (- 2 1) 7)
19:49:38 <SamB> I actually meant that languages whose codes(?) do not form trees are unsuitable for large tasks
19:49:57 <jsnx> well, sure
19:50:12 <jsnx> but seem to get by with a code representation that does not form trees
19:50:20 <dolio> Be careful, the concatenative boys will get you.
19:50:25 <jsnx> text is just string
19:50:27 <SamB> what ever do you mean?
19:50:49 <SamB> jsnx: the AST is that which I'm speaking of
19:50:52 <roconnor> ICFP DNA language?
19:50:53 <jsnx> i mean, all our representation of code tells the compiler is one char follows another
19:51:09 <jsnx> there is a tree, and the parser has to find it
19:51:17 <SamB> jsnx: um, compilers read syntax trees into just about anything
19:51:33 <SamB> even BF compilers often use syntax trees
19:51:37 <SamB> believe it or not
19:51:42 <jsnx> yes, but the format in which our code is stored does not have a tree type
19:51:51 <SamB> true enough
19:51:51 <jsnx> the semantics of text do not include trees
19:52:13 <jsnx> so say we moved up just a notch, and said, now we'll put strings into trees
19:52:22 <SamB> eh?
19:52:27 <jsnx> and that is how we'll store teh codez
19:53:16 * SamB is reminded of how Self stores method code -- it stores both the source text and VM code
19:53:18 <jsnx> like, we had some bytes at the beginning of the file that were pointers to the first children
19:53:31 <jsnx> and each child has a string and a list of pointers to its children
19:53:37 <SamB> jsnx: wait, why are we starting with a binary representation?
19:53:52 <SamB> Why not use a textual one to start with, to ease debugging?
19:53:52 <jsnx> well, that is actually the idea of storing the AST
19:54:06 <jsnx> i'm not advocating the evil!
19:54:08 <jsnx> i am explaining it!
19:54:20 <jsnx> stop asking for advocacy/justification!
19:54:21 <SamB> the important part is the abstract structure, not the concrete representation
19:54:50 <jsnx> storing-the-ast people would disagree, of course
19:54:56 <jsnx> but i agree
19:55:19 <jsnx> no one asks the devil's advocate why he serves the devil
19:55:22 <jsnx> it's his job
19:55:33 <mmorrow> jsnx: do you have a link to something related to these "storing-the-ast" people?
19:55:52 <SamB> what I mean is that there can be multiple equavalent ways to store the same information, so why not use an easy-to-debug form initially?
19:56:02 <jsnx> mmorrow: there's subtext, &c. -- don't know where they are on the internets
19:56:12 <jsnx> SamB: that is a good question
19:56:45 <jsnx> SamB: the argument is that, if we force the data to have some structural validity, it makes it easy to transform
19:57:27 <mmorrow> jsnx: but do they exist, or are they hypothetical?
19:57:33 <SamB> clearly after the system was more developed, it would be important to develop an efficient storage format unless, by some miracle, the first one turned out to be efficient
19:57:36 <jsnx> mmorrow: they have been written
19:57:44 <jsnx> mmorrow: the evil spreads even as we speak
19:57:52 <SamB> and certainly I would be expecting structural validity to be enforced
19:58:01 <jsnx> SamB: well, i think that is not good for teh codez
19:58:11 <SamB> it's basically the difference between RawShow and Data.Binary
19:58:22 <jsnx> no
19:58:37 <SamB> that's what *I'm* talking about, though
19:58:40 <jsnx> it's the difference between untyped (plaintext) and strongly typed (database)
19:59:10 <jsnx> if we force all the code to sit in the database and only go in and out that way, it will likely be *bigger* than it's plain text representation
19:59:12 <SamB> what I'm saying is that "strongly typed" does not imply "in a binary format"
19:59:35 <jsnx> SamB: it does imply that you may not just move on or another character willy nilly
19:59:53 <SamB> a naive textual representation of the same structure may in fact be more efficient
20:00:04 <jsnx> SamB: yes, more efficient
20:00:13 <jsnx> SamB: but that is not really the point of storing the AST
20:00:28 <jsnx> SamB: the point is that the code only moves from one valid parse state to another
20:00:45 <jsnx> using database type operations to ensure that
20:00:51 <SamB> oh
20:00:56 <SamB> hmm.
20:01:03 <jsnx> you aren't able to put in half a function definition
20:01:15 <jsnx> you are either add a function definition or you don't
20:01:22 <mmorrow> jsnx: but what about the representation in our m1nds? where does it stop!? will we then be compelled to access our internal representations of our internal representations with SQL:?
20:01:34 <SamB> well, doesn't emacs already write files atomically?
20:01:45 <jsnx> mmorrow: i am not in favor of this
20:01:52 <jsnx> i am just explaining it
20:02:01 <mmorrow> whoos gonna ensure this SQL is stored typedly?
20:02:13 <SamB> I don't see how any of this implies a binary format necerssarily
20:02:17 <jsnx> mmorrow: the SQL standard or datalog standard or whatever
20:02:18 <SamB> hahahaha SQL
20:02:28 <SamB> yeah right suckers!
20:02:30 <mmorrow> jsnx: hehe "standard"
20:02:39 <jsnx> mmorrow: the libraries do a good job of that for other applications
20:02:46 <SamB> jsnx: there was an SQL standard????
20:03:01 <jsnx> or you come up with an appropriate standard and API
20:03:43 <mmorrow> stuff that chicken in the egg
20:04:01 <Pseudonym> There were several SQL standards.
20:04:04 <dmwit> ?unmtl MaybeT IO
20:04:06 <lambdabot> err: `MaybeT IO' is not applied to enough arguments, giving `/\A. IO (Maybe A)'
20:04:08 <dmwit> ?unmtl MaybeT IO a
20:04:09 <lambdabot> IO (Maybe a)
20:04:11 <Pseudonym> And nobody implements them.
20:06:03 <ddarius> Implementing standards is for suckers.
20:06:08 <SamB> now epigram could use a framework of this general nature (storing an AST-ish form) regardless of how "universal" it was...
20:06:18 <ddarius> I don't think there exist a single implementation of Haskell.
20:06:22 <SamB> since it's syntax does not support concatenation
20:06:33 <SamB> ddarius: we're working on that
20:06:48 <SamB> (not implementing -- getting the standard to be more realistic ;-)
20:07:01 <ddarius> SamB: Are we going to remove recursive modules?
20:07:09 <ddarius> +mutually
20:07:24 <SamB> well, those I'm hoping we figure out how to implement
20:07:30 <SamB> or get rid of
20:07:38 <ddarius> We know how.  We just don't
20:08:02 <SamB> well, why don't you show JohnMeacham how
20:08:14 <SamB> he has some that go really damn slow :-(
20:09:35 <ddarius> SamB: As simply a proof of feasibility, you could do it just like GHC does and simply add a .hi-boot generating pass.
20:09:57 <SamB> ddarius: that'd lose badly
20:10:04 <Pseudonym> There are some (e.g. me) who believe that this is a serious defect in Haskell.
20:10:12 <SamB> Pseudonym: what is?
20:10:15 <Pseudonym> That you need cross-module type inference in general.
20:10:15 <ddarius> Pseudonym: That mutually recursive modules are allowed?
20:10:35 <Pseudonym> And that mutually recursive modules arent supported.
20:11:17 <SamB> yes, we should either say that they aren't part of the base language OR implement them in a tolerable manner
20:11:29 <Pseudonym> Right.
20:11:35 <Pseudonym> And manual .hi-boot files are not an answer.
20:11:44 <SamB> JHC's implementation did not qualify when last I built it's library ;-)
20:11:48 <Pseudonym> You shouldn't need a language extension to support them.
20:12:05 <SamB> not unless they ARE a language extension, no ;-)
20:12:29 <Pseudonym> It seems to me that the "right" answer for Haskell is to be lazy.
20:13:04 <Pseudonym> In principle, it would make sense for all exported definitions from a module to need an explicit type signature.
20:13:10 <SamB> it's very tricky to figure out how to do it without eating all your RAM
20:13:11 <Pseudonym> However, Haskell is lazy.
20:13:54 <Pseudonym> So a good compromise would be to allow omitting type declarations if they don't cause a problem.
20:14:58 <SamB> have you tried JHC?
20:15:13 <Pseudonym> Nope.
20:15:29 <Pseudonym> I keep meaning to.
20:15:36 <SamB> it takes forever to compile the SCC in it's libraries dependancy graph containing Prelude :-(
20:17:05 <Pseudonym> Right.
20:17:07 <mmorrow> to be fair, JHC is doing *whole* program analysis as well
20:17:31 <mmorrow> which no other (real) haskell compiler does
20:17:33 <SamB> mmorrow: that doesn't come until later
20:17:41 <mmorrow> hmm
20:18:11 * mmorrow opens his "the big picture" pdf from jhc website
20:18:50 <SamB> not until it has compiled the entire dependancy graph of the program to E does it start "whole-program" in earnest
20:19:24 <mmorrow> what exactly is "grin"?
20:19:46 <jsnx> coffee shop -> home traversal
20:19:50 <Pseudonym> The intermediate form that JHC uses.
20:19:50 <jsnx> sorry to leave in the middle
20:19:52 <mmorrow> is that the name for this whole program analysis "thing"?
20:19:55 <mmorrow> ah
20:20:04 <SamB> it is involved in a lot of the whole-program stuff, yes
20:20:13 <Pseudonym> Graph Reduction something something
20:20:24 <SamB> Imperative?
20:20:28 <mmorrow> Pseudonym: it looks like there are quite a few intermediates
20:20:30 <Pseudonym> It's also a bit of a play on GRASP and GRIP.
20:20:37 <Pseudonym> I think.
20:20:37 <SamB> mmorrow: eh?
20:20:51 <SamB> The only IRs I know of in JHC are E and Grin
20:20:57 * mmorrow is finding link to pdf he's looking at
20:21:02 <SamB> there are several forms for E, of course
20:21:19 <mmorrow> http://repetae.net/computer/jhc/big-picture.pdf
20:21:42 <mmorrow> witness the machine!
20:22:07 <mmorrow> i love graphviz
20:22:52 <mmorrow> SamB: i may be using "intermediate rep" more loosely than you are
20:23:21 <SamB> I hope I never have to see a senior project poster with improperly-scaled graphviz graphs on it again :-(
20:23:33 <mmorrow> haha
20:24:14 <SamB> mmorrow: well, there's the HsSyn types, which I don't count as an IR, the E types, and the Grin types...
20:24:14 <mmorrow> managing to "improperly scale" a graph existing w/in an abstract space is quite a feat indeed
20:24:54 <SamB> by "improperly scaled", I mean they appear to have used the naive reduction algorithm on a rasterized graph image
20:25:20 <SamB> you know, the nearest-pixel one?
20:25:34 <mmorrow> SamB: hmm, i was considering each top level box to be an "intermediate rep" (although i'm sure this is abusing the term?)
20:25:58 <SamB> it's like ARG, STUPID SENIORS! SHOULD HAVE USED A VECTOR FORMAT, SHEESH!
20:26:00 <mmorrow> SamB: too well :)
20:26:26 <SamB> I hope they take that poster down soon
20:26:43 <SamB> I mean, they should have plenty of new senior project posters to replace it with...
20:27:13 <mmorrow> of midgets with tree-branch arms most likely
20:28:04 <SamB> anyway, the two "Core" boxes both deal in the language we usually call "E"
20:28:06 <mmorrow> um
20:28:11 <mmorrow> yeah, so jhc
20:28:46 <mmorrow> ah, just noticed the E prefix in both
20:29:09 <andyjgill> Hi!
20:30:05 <nolrai_East> hi
20:30:09 <SamB> and the ho files are just a serialized representation of E along with what JHC would put in an interface file ...
20:30:10 <andyjgill> Does anyone know how to get the right hand side of a Float? for example 12.3 => 0.3, 4.7 => 0.7? Is there a function for this?
20:30:39 <ddarius> @hoogle frac
20:30:39 <lambdabot> Prelude.Fractional :: class Num a => Fractional a
20:30:39 <lambdabot> Prelude.RealFrac :: class (Real a, Fractional a) => RealFrac a
20:30:39 <lambdabot> Prelude.realToFrac :: (Real a, Fractional b) => a -> b
20:30:44 <ddarius> @hoogle fract
20:30:45 <lambdabot> Prelude.Fractional :: class Num a => Fractional a
20:30:45 <lambdabot> Prelude.properFraction :: (RealFrac a, Integral b) => a -> (b, a)
20:30:45 <lambdabot> Data.Time.LocalTime.dayFractionToTimeOfDay :: Rational -> TimeOfDay
20:30:50 <carl> how would a create a list of 128 0's
20:31:02 <ddarius> > snd . properFraction $ 12.3
20:31:04 <lambdabot>  0.3000000000000007
20:31:16 <SamB> and each strongly connected component of the module dependency graph gets compiled into one .ho, which is arbitrarily named after one of the modules in the SCC and the rest get symlinks instead
20:31:30 <nolrai_East> Is there a type for one to one dictionaries?  i.e. bidirectional maps.
20:31:34 <andyjgill> Thanks ddarius
20:31:45 <ddarius> nolrai_East: Yes.  It's called Bimap I think.
20:31:47 <andyjgill> I know there was a function that did this.
20:31:50 <ddarius> @hackage bimap
20:31:50 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/bimap
20:31:58 <ddarius> @src RealFrac
20:31:59 <lambdabot> class  (Real a, Fractional a) => RealFrac a  where
20:31:59 <lambdabot>     properFraction                   :: (Integral b) => a -> (b,a)
20:31:59 <lambdabot>     truncate, round, ceiling, floor  :: (Integral b) => a -> b
20:32:17 <nolrai_East> carl: replicate
20:32:28 <nolrai_East> >replicate 0 125
20:32:31 <mmorrow> SamB: so around where exactly, wrt this diagram, would the recursive module sccs be grouped and compiled(/processed/translated whatever the term at that stage may be)?
20:32:36 <carl> thx
20:32:39 <nolrai_East> @bot
20:32:39 <lambdabot> :)
20:32:47 <nolrai_East> ﻿> replicate 0 125
20:32:57 <mmorrow> SamB: ah, just saw your comment re: my last
20:33:32 <SamB> mmorrow: does that tell you what you wanted to know?
20:34:05 <mmorrow> SamB: yes, although i'm not looking to find out anything in particular, just to gather knowledge
20:34:54 <SamB> the implementation of typeclasses is worse than ugly -- last I knew it generated ill-typed rules in E...
20:35:00 <mmorrow> at the very least, this diagram is now more familiar to me than it was 5 minutes ago
20:35:20 <mmorrow> i just looked in to jhc within the last week
20:36:40 <SamB> is it just me, or do all decent compilers have dependently typed IRs?
20:36:56 <mmorrow> initial impressions: seems to be fast, don't know how relative to anything so....    the code looks nice and clean (wrt organization and nonclutter) at first glance ...  there is a nice graphviz diagram(!!)
20:37:00 <ddarius> SamB: System F isn't dependently typed.
20:37:18 <ddarius> SamB: I doubt any of the IRs in GCC are dependently typed.
20:37:27 <SamB> ddarius: is GCC actually decent?
20:37:45 <ddarius> SamB: Not sure, but I doubt ICC is much different in that regard.
20:38:05 <SamB> okay, I guess it was just me then
20:38:21 <mmorrow> i briefly looked into gcc and it's irs/_ and was not "super psyched"
20:38:23 <povman> anyone know what this means? getNameInfo: does not exist (ai_family not supported)
20:38:42 <SamB> but you can understand how I might forget that system F wasn't dependently typed can't you?
20:38:55 <ddarius> SamB: Not really...
20:38:56 <SamB> povman: last time that happened I had left a colon where I needed a slash
20:39:03 <SamB> what address did you give?
20:39:09 <SamB> (are you using git?)
20:39:14 <povman> SamB: localhost
20:39:24 <SamB> povman: just localhost?
20:39:27 <povman> no, just a tiny demo network program
20:40:18 <SamB> what are you doing for ports?
20:40:22 <novas0x2a> how do i catch a read parse error? Control.Exception.catch doesn't seem to catch it (unless i'm doing something wrong)
20:40:24 <povman> 125
20:40:27 <povman> (12345)
20:40:39 <mmorrow> novas0x2a: use reads
20:40:44 <SamB> how are you trying to resolve the address?
20:41:12 <hpaste>  povman pasted "network app" at http://hpaste.org/8675
20:41:23 <ddarius> novas0x2a: What mmorrow said, but Control.Exception.catch would catch it, but, most likely, due to laziness, the actual exception isn't being thrown until after you've left the catch.
20:42:02 <SamB> yeah, reads is easier than seq ;-)
20:42:10 <mmorrow> heh
20:42:11 <chessguy> @pl \h -> hP h m
20:42:11 <lambdabot> flip hP m
20:42:38 <novas0x2a> i see how it'd work with reads. just for giggles, how would i do it with catch?
20:42:39 <SamB> mmorrow: what's this "fruit"?
20:42:42 <SamB> er.
20:42:44 <SamB> povman:
20:42:46 * SamB silly
20:43:06 <povman> client prints out "fruit" then dies
20:43:17 <SamB> oh yeah
20:43:28 <mmorrow> SamB: do you mean like bananas and peaches?
20:43:40 <SamB> mmorrow: heh
20:43:49 <mmorrow> ;)
20:43:55 <SamB> I don't know what those are ;-P
20:44:03 <mmorrow> blasphemy!
20:44:15 <SamB> actually I love bananas
20:44:37 <mmorrow> just a heretic then
20:44:59 <SamB> and peaches are cool too
20:45:14 <mmorrow> well then, you're simply a saint
20:45:31 <mofmog> monads are backwards function composition?
20:45:40 <mofmog> if they are then i've figured them out
20:45:44 <povman> er... no
20:45:44 <ddarius> No.  Read the paper I likned.
20:45:45 <Korollary> No
20:45:48 <SamB> mofmog: not quite
20:45:54 <mofmog> no but in thinking sorta
20:46:13 <mofmog> not exactly composition, but it let's you control the flow of computation
20:46:16 <SamB> they're similar enough that cale would like . to work on monads, though ;-)
20:46:16 <mofmog> in the same manner
20:46:30 <mofmog> for example if you do
20:46:35 <SamB> well, that's more liftM than bind though
20:46:54 <povman> er - so can anyone get http://hpaste.org/8675 to not crash?
20:47:34 <SamB> let me fire up hoogle
20:47:42 <mofmog> like, a monad function ships off a container that's filled with stuff that bind deals with and then it unloads the important stuff into the next function
20:47:50 <mofmog> in the same way the function composition sorta does
20:47:56 <mofmog> but -backwards-
20:48:09 <povman> mofmog: if you use (=<<) then it's forwards :D
20:48:10 <SamB> not quite ;-)
20:48:33 <povman> kinda looks like an angry alien smiley
20:49:24 <SamB> @doc Netword
20:49:25 <lambdabot> Netword not available
20:49:26 <SamB> @doc Network
20:49:26 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/network/Network.html
20:49:42 <povman> SamB: did you run the code?
20:49:49 <jsnx> Korollary: when chuck norris comes along, plastic packages have trouble with *him*
20:49:54 <SamB> povman: how would that help?
20:49:59 <jsnx> ack, wrong channel
20:50:05 <povman> it might just be my platform
20:51:39 <mmorrow> lol
20:51:43 <mmorrow> the only comment:
20:51:44 <mmorrow> -- BATTlE
20:51:55 <SamB> jsnx: I bet chuck norris cuts his fingers off with a chainsaw trying to open the plastic packages
20:52:00 <Liempt> IN SOVET RUSSIA, <bad joke>!!!!!!!!!!!!11111111!!!!!!!!!11
20:52:08 <povman> mmorrow: my original port number was 847713
20:52:15 <SamB> in soviet russia, you beat up chuck norris
20:52:32 <Liempt> Yes, that was a bad joke.  Thanks.
20:52:35 <Liempt> =P
20:53:07 <mmorrow> povman: nice, i'll remember that one. i always use for my wireless router's mac: 00:FA:DE:AF:AD:ED
20:53:18 <SamB> as you can see, the soviet russia joke form overrides the chuck norris joke form, causing chuck norris to lose
20:53:41 <jsnx> SamB: in soviet russia, chuck norris beats you!
20:53:42 <Korollary> I bet I can make 100 bad soviet russia jokes.
20:53:43 <SamB> povman: I get a different error
20:53:59 <SamB> jsnx: you can't re-reverse the russian reversal like that
20:54:30 <SamB> bind: resource busy (Address already in use)
20:54:37 <povman> what.
20:54:44 <jsnx> SamB: in soviet russia, reverse reverses you!
20:54:51 <povman> SamB: i get that if i run main twice
20:54:58 <povman> because i'm not closing the socket
20:55:46 <SamB> well, that was under ghci
20:55:47 <Liempt> In soviet russia, socket doesn't close YOU!!
20:55:48 <SamB> running once
20:56:04 <povman> Liempt: lol
20:56:21 <povman> how do you make lb remember quotes
20:56:39 <SamB> @remember Liempt In soviet russia, socket doesn't close YOU!!
20:56:40 <lambdabot> Okay.
20:56:45 <povman> SamB: aha, it worked when i changed it to 127.0.0.1
20:56:50 <SamB> then lambdabot forgets them later
20:57:01 <SamB> povman: does your hosts database have issues?
20:57:50 <hpaste>  povman annotated "network app" with "my hosts" at http://hpaste.org/8675#a1
20:57:59 <povman> i dont think so...
20:58:25 <SamB> that certainly looks okay to me
20:58:28 <povman> mmorrow: oofadeafaded?
20:58:38 <povman> i'm on a _mac_ so maybe it's screwt by default
20:58:49 <mmorrow> povman: three words, with sharing
20:59:06 <povman> ah
20:59:45 <SamB> FADE DEAF FADED?
21:00:02 <povman> technically there are 16 with sharing
21:00:54 <povman> (and duplicates)
21:01:15 <mmorrow> (fa[de)a{f]ade)ed}
21:01:17 <mmorrow> yeah,
21:01:22 <mmorrow> 16?!
21:01:43 <mmorrow> s/e//
21:02:12 <povman> o o of fad fade a ad ade deaf a fad fade faded a ad ade
21:02:19 <mmorrow> i thought there should've been another DEAF, but i guess that was just my eyes playing tricks on me
21:02:40 <ddarius> When did "o" become a word?
21:03:12 <SamB> when people stopped writing the "h"
21:03:16 <Cale> O Canada!
21:03:17 <SamB> ?
21:03:57 <Liempt> O has been a word since antiquity.
21:04:10 <mmorrow> oh, nice call on the 'fad'
21:04:35 <SamB> % sudo netstat --listen -n -p | grep 12345
21:04:35 <SamB> tcp        0      0 0.0.0.0:12345           0.0.0.0:*               LISTEN     8285/portsentry
21:04:50 <shrimpx> cool command
21:05:06 <mmorrow> i lilke
21:05:15 <mmorrow> sudo netstat -nap | grep ^
21:05:30 <dmwit> Why grep for ^?
21:05:38 <mmorrow> a place holder
21:05:38 <dmwit> Doesn't it match every line?
21:05:43 <SamB> shouldn't there be something that might not match?
21:05:44 <mmorrow> zactly
21:05:56 <mmorrow> only nothing
21:06:02 <mmorrow> but then...
21:06:06 <SamB> why would nothing not match?
21:06:07 <b7j0c> anyone what this means: "GHCi runtime linker: fatal error: I found a duplicate definition for symbol NetworkziCurlziEasy_dcjR whilst processing object file /home/brad/.cabal/lib/curl-1.3.2.1/ghc-6.8.2/HScurl-1.3.2.1.o" ????
21:06:10 <SamB> I think even that would match
21:06:19 <mmorrow> in the same way that it does match and is returned
21:06:21 <mmorrow> it is nothing
21:06:54 <SamB> maybe we should stop using english, it's getting a bit confusing
21:07:11 <mmorrow> yeah, i just pulled that out of nowhere ;)
21:07:28 <mmorrow> but really though, what are meaning by "nothing"
21:07:36 <SamB> well, there is ""
21:07:50 <dmwit> b7j0c: Sounds like it's trying to pull in two different versions of the same library... maybe?
21:07:59 <mmorrow> and what are the two possibly outcomes if ^ matched and doesnt?
21:08:00 <chowmeined> so am i right in thinking i want to push IO as far to the edge of my code as possible?
21:08:08 <SamB> and there is the Coq type False
21:08:21 <dmwit> chowmeined: That's one possibility.
21:08:27 <dmwit> chowmeined: It's also the most favored one. ;-)
21:08:47 <SamB> chowmeined: strange how we humans so often don't know what we want ;-)
21:08:54 <mmorrow> SamB: but specifically in the context of regexes
21:09:26 <mmorrow> (was that Coq type false @me?)
21:09:35 <b7j0c> hmm, i am using cabal to install this so i am not sure how two different versions of the lib could be there.....
21:09:51 <mmorrow> SamB: because I'm not familiar
21:09:57 <vinicius> @hoogle unfold
21:09:58 <lambdabot> Data.List.unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
21:09:58 <lambdabot> Data.ByteString.unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
21:09:58 <lambdabot> Data.ByteString.unfoldrN :: Int -> (a -> Maybe (Word8, a)) -> a -> (ByteString, Maybe a)
21:10:02 <chowmeined> SamB, sure.. its what i think i want, but i may be missing part of the picture, thats why im asking
21:10:16 <SamB> mmorrow: well, you could have meant "forall s, not (matches "^" s)"
21:10:41 <SamB> or you could have meant "forall s, matches "^" s -> s = """
21:10:51 <SamB> and don't bother me about the badly nested quotation marks
21:11:07 <mmorrow> heh
21:11:14 <mmorrow> im thinking
21:12:36 <SamB> the first one means "there is no string that matches", the second means "only the empty string matches"
21:12:37 <mmorrow> actually, i think i'm confused by the " marks
21:12:48 <SamB> forall s, not (matches "^" s)
21:12:52 <mmorrow> parse error: ambiguity
21:12:55 <SamB> forall s, matches "^" s -> s = ""
21:13:17 <mmorrow> it's the second one im stuck on
21:13:30 <mmorrow> i'm not sure how you mean that
21:13:32 <SamB> forall s, (matches "^" s -> (s = ""))
21:13:38 <mmorrow> ah
21:15:04 <mmorrow> for some reason i think that what you're saying implies that ^ matches (not anything) rather than (everything, including nothing) which i mean
21:15:31 <SamB> oh, oops
21:15:40 <mmorrow> but i
21:15:43 <SamB> I got it completely backwards ;-P
21:15:53 <SamB> forall s, not (matches "^" s) -> s = ""
21:15:58 <mmorrow> ok, i was so confused
21:15:59 <mmorrow> heh
21:16:22 <SamB> forall s, not (matches "^" s) -> (s = "")
21:16:38 <SamB> wait, that was the same one again
21:17:07 <SamB> forall s, matches "^" s
21:17:51 <mmorrow> it's like you turn left driving once by accident at a particular place, then *every* time your there again youre like crap right or left or!!
21:18:33 <SamB> mmorrow: I hope I don't leave you negating your logical statements for life ;-)
21:18:45 <mmorrow> heh
21:19:19 <mmorrow> if that does happen, possibly depending on the logic i'm embedded in, i can't double negate myself straight
21:19:24 <b7j0c> to answer my own previous question - a cabal update of curl does not remove the previous version!!
21:19:35 <b7j0c> have to do so manually with ghc-pkg...:(
21:19:41 <SamB> mmorrow: yeah, if you do that you'll be in the embedded classical logic
21:19:52 <SamB> and that certainly isn't a pretty place to be
21:20:05 <SamB> all non-constructive
21:20:18 <mmorrow> the truly hillarious thing is, i honestly meant to write "i *can* double negate myself straight"
21:20:27 <mmorrow> oh nos
21:21:59 <dons_> b7j0c: also, you might want to look at the new download and download-curl packages
21:22:10 <dons_> i've written them specifically to make the common cases easier and more efficient
21:22:23 <dons_> the 'download' package uses libdownload, rather than libcurl, so we've some choice.
21:22:57 <dons_> b7j0c: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/download-0.3 and http://hackage.haskell.org/cgi-bin/hackage-scripts/package/download-curl-0.0
21:23:10 <lambdabot> http://tinyurl.com/6bldmp
21:24:59 <b7j0c> dons - i think some of my problems are related to having packages in $HOME/local from the pre-cabal days...i guess i should nuke those...
21:25:11 <b7j0c> but i will definitely check out download! thanks!
21:25:26 <dons_> ah interesting. yes, i'd clean out any old libs. possibly libcurl itself was miscompiled/out of date
21:25:59 <nolrai_East> @unmtl ReaderT Program (StateT VMState (Error VMError)) ret
21:25:59 <lambdabot> Program -> VMState -> Error VMError (ret, VMState)
21:28:19 <nolrai_East> @unmlt ErrorT e [] r
21:28:20 <lambdabot> Maybe you meant: unmtl unpl
21:31:19 <nolrai_East> @unmlt ErrorT e (State s) r
21:31:19 <lambdabot> Maybe you meant: unmtl unpl
21:31:43 <nolrai_East> ﻿@unmtl ErrorT e (State s) r
21:31:47 <dancor> is there a way to encode multiline lines into a single line with only sequential replacements?  \n -> \,n then \ -> \,\ fails because \,\,n encodes to \,\,\,\,n which decodes to \,\n
21:32:23 <dancor> encode losslessly String to String
21:32:29 <dmwit> Man, these netsplits really are wonderful.
21:32:33 <dmwit> uh... what?
21:32:35 <dmwit> Can you ask again, but with different words? =P
21:32:42 <dancor> obviously you can do it with simultaneous replacements
21:32:58 <dancor> i'm using a,b instead of 'a':'b':[]
21:33:05 <dmwit> ah
21:33:25 <dancor> i thought it would be even more confusing otherwise..
21:33:52 <nolrai_East> @bot
21:33:52 <lambdabot> :)
21:33:55 <dancor> basically A -> AA and B -> AC where A is \ and B is \n and C is n
21:34:04 <nolrai_East> ﻿@unmlt ErrorT e (State s) r
21:34:18 <dancor> the encoded string must not contain B
21:35:06 <dmwit> How about \n -> \,n, \ -> \,m?
21:35:36 <dmwit> Then on the other side, you decode in the opposite order: \,n -> \n, \,m -> \
21:36:43 <vinicius> @pl \ x -> (== 0) . mod x
21:36:43 <lambdabot> ((0 ==) .) . mod
21:36:49 <vinicius> heh
21:37:15 <dmwit> on (==) . mod
21:37:24 <nolrai_East> ﻿@unmlt StateT s (Either e) r
21:37:27 <dmwit> not quite, actually
21:37:30 <povman_> :t on
21:37:31 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
21:37:56 <dmwit> :t on (==) . mod -- for comparing two numbers, mod a third
21:37:57 <lambdabot> forall a. (Integral a) => a -> a -> a -> Bool
21:38:03 <povman_> :t comparing
21:38:04 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
21:39:45 <nolrai_East> ﻿@pl f x y = x y (f x y)
21:40:00 <nolrai_East> @bot
21:40:01 <lambdabot> :)
21:40:17 <nolrai_East> @pl \x y -> y x
21:40:18 <lambdabot> flip id
21:40:56 <dmwit> ?pl f x y = x y (f x y)
21:40:56 <lambdabot> f = fix (ap ap)
21:41:02 <dmwit> yow
21:41:08 <dmwit> :t fix (ap ap)
21:41:08 <lambdabot> forall (m :: * -> *) b. (Monad m) => m (b -> b) -> m b
21:41:24 <povman_> :t fix (\f x y -> x y (f x y))
21:41:25 <lambdabot> forall t t1. (t -> t1 -> t1) -> t -> t1
21:41:58 <povman_> @pl fix (\f x y -> x y (f x y))
21:41:58 <lambdabot> fix (ap ap)
21:42:35 <povman_> weird :p
21:43:01 <dmwit> Not so weird, I think.
21:43:06 <dmwit> ?pl \f x y -> x y (f x y)
21:43:07 <lambdabot> ap ap
21:43:09 <dmwit> ;-)
21:43:28 <povman_> i mean how the type of fix (ap ap) is different to the type of fix (\f x y -> x y (f x y))
21:43:57 <dmwit> Oh, fix (ap ap) is a generalization of fix (\f x y -> x y (f x y)).
21:44:10 <nolrai_East> > let f x y = x y (f x y) in f (:) 2
21:44:12 <lambdabot>  [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2...
21:44:23 <povman_> ohhh monad is more general than functions, right.
21:44:27 <dmwit> In the (r ->) monad, fix (ap ap) :: (r -> b -> b) -> (r -> b)
21:44:35 <nolrai_East> :t fix (ap ap)
21:44:36 <lambdabot> forall (m :: * -> *) b. (Monad m) => m (b -> b) -> m b
21:44:38 <povman_> gotcha
21:49:17 <audreyt> @seen dcoutts_
21:49:17 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
21:49:19 <carl> how do you convert an integer into an int
21:49:36 <audreyt> @seen dcoutts
21:49:36 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
21:49:39 <Pseudonym> :t fromIntegral
21:49:40 <lambdabot> forall a b. (Num b, Integral a) => a -> b
21:49:58 <audreyt> @seen dcoutts -- more bytes for you, Data.Binary.Get
21:49:59 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
21:50:06 <povman_> audreyt:
21:51:19 <povman_> preflex: seen dcoutts
21:51:19 <preflex>  dcoutts was last seen on #haskell 12 hours, 19 minutes and 36 seconds ago, saying: roconnor: a cairo wrapper need not be stateful at all
21:51:35 <audreyt> thanks
21:51:55 <audreyt> preflex means "before flexible instances?"
21:53:38 <dobblego> ?type Prelude.(.)
21:53:39 <lambdabot> Not in scope: data constructor `Prelude'
21:55:40 <povman_> :t P.(.)
21:55:41 <lambdabot> Not in scope: data constructor `P'
21:55:52 * povman_ dieth
22:01:55 <vinicius> >and fmap isPrime [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103]
22:02:10 <Lemon> "Unfortunately, left-recursive grammars can not be specified directly in a combinator library. If you accidently write a left recursive program, the parser will go into an infinite loop!"
22:02:27 <vinicius> @bot
22:02:27 <lambdabot> :)
22:02:31 <Lemon> If I read this two hours ago, it might have saved me some work.
22:02:36 <Lemon> Arrrgh.
22:03:41 <Lemon> Kids, always read the WHOLE documentation before proceeding.
22:04:26 <Zao> Lemon: But then you would miss out on all the educational rediscoveries.
22:05:06 <wagle_home> i've wondered how the libraries kept you from writing ill-advised grammars
22:05:24 <dons_> seems like an interesting problem to encode in the type
22:05:36 <wagle_home> yeah...  nothing like touching the stove to really learn
22:05:45 <wagle_home> @seen dons
22:05:45 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
22:06:07 <wagle_home> or are you not the one?
22:09:57 <nolrai_East> what does "When trying to generalise the type inferred" mean?
22:17:55 <vinicius> > 1
22:17:57 <lambdabot>  1
22:18:06 <vinicius> > unfoldr Just (1,1)
22:18:07 <lambdabot>  [1,
22:18:18 <vinicius> ?
22:18:38 <dobblego> not tellin' :)
22:21:11 <vinicius> oh, it's segfaulting here
22:21:32 <dons> huh
22:21:50 <dons> that's funky
22:21:52 <dons> ?bug
22:21:53 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
22:22:04 <paolino> yes
22:22:08 <dons> SCARY
22:23:29 <sjanssen> wow
22:23:37 <sjanssen> what could be causing that?
22:23:46 <dons> http://hackage.haskell.org/trac/ghc/ticket/2414
22:23:48 <lambdabot> Title: #2414 (GHCi segfault) - GHC - Trac
22:24:45 <sjanssen> vinicius++ best GHC bug I've seen in a while :)
22:25:06 <dons> yeah, been a couple of years since we've seen one like that.
22:25:44 <dons> and in ghc
22:25:45 <TSC> @type unfoldr
22:25:46 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
22:26:03 <Smokey`> Haskell can segfault?
22:26:14 <dons> only if there's a compiler bug
22:26:21 <Smokey`> I see
22:26:23 <sjanssen> Smokey`: compilers can be broken, yes
22:26:47 <sjanssen> also, Haskell including the FFI addendum can easily segfault :)
22:26:57 <dons> #0  0x0000000000417a19 in s2C0_info ()
22:27:14 <sjanssen> that is helpful
22:27:34 <dons> well, its in the haskell code
22:27:39 <dons> not the runtime or libc
22:28:26 <TSC> @type Just
22:28:27 <lambdabot> forall a. a -> Maybe a
22:28:34 <TSC> How does it type check?
22:28:47 <paolino> it's also a ghc bug
22:28:56 <vinicius> infinite type?
22:29:00 <dons> hmm
22:29:07 <dons> :t unfoldr Just
22:29:07 <lambdabot> forall a b. (a, b) -> [a]
22:29:20 <dons> :t unfoldr Just (1,1)
22:29:21 <lambdabot> forall a. (Num a) => [a]
22:30:06 <sjanssen> defaults to [Integer]
22:30:36 <sjanssen> it still crashes when give a :: Int
22:30:38 <dons> looks like it'll be foldr-only day at work tomorrow
22:31:02 <sjanssen> dons: I get a much more interesting error with ((), ())
22:31:12 <sjanssen> foo: internal error: MUT_VAR_DIRTY object entered!
22:31:23 <dons> hmm
22:31:25 <dons> GC bug
22:31:26 <vinicius> Just, doesn't match the type of unfoldr. omg
22:31:42 <dons> :t Just
22:31:43 <lambdabot> forall a. a -> Maybe a
22:31:54 <vinicius> :t unfoldr
22:31:55 <sjanssen> @type unfoldr
22:31:55 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
22:31:56 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
22:31:57 <dolio> That's pretty weird.
22:32:07 <sjanssen> vinicius: yeah, why does it pass the compiler?
22:32:19 <dons> if its a type checker bug, that'd explain the crash
22:32:26 <sjanssen> it has to be
22:32:48 <dons> :t unfoldr (Just ?x) (1,1)
22:32:48 <paolino> it should give occurs
22:32:49 <lambdabot>     Couldn't match expected type `b -> Maybe (a, b)'
22:32:49 <lambdabot>            against inferred type `Maybe a1'
22:32:49 <lambdabot>     In the first argument of `unfoldr', namely `(Just ?x)'
22:33:13 <dons> :t unfoldr (\x -> Just x) (1,1)
22:33:14 <lambdabot>     Occurs check: cannot construct the infinite type: b = (a, b)
22:33:14 <lambdabot>       Expected type: (a, b)
22:33:14 <lambdabot>       Inferred type: b
22:33:17 <dons> like that.
22:33:26 <sjanssen> -dcore-lint catches it
22:33:35 <dons> cool
22:34:00 <geezusfreeek> wow
22:34:17 <dons> :t unfoldr Just (1,1)
22:34:18 <lambdabot> forall a. (Num a) => [a]
22:34:25 <audreyt> :t unfoldr Just ((),())
22:34:26 <geezusfreeek> that's a nuts bug
22:34:26 <lambdabot> [()]
22:34:30 <audreyt> > unfoldr Just ((),())
22:34:32 <lambdabot>  [(),
22:34:33 <vinicius> bug submited
22:34:39 <dons> already done.
22:34:46 <geezusfreeek> wha—?
22:34:55 <sjanssen> this bug is fantastic!
22:35:05 <sjanssen> anybody got ghc 6.6 or older?
22:35:17 <dons> http://hackage.haskell.org/trac/ghc/ticket/2414
22:35:19 <roconnor> sjanssen: I do
22:35:20 <lambdabot> Title: #2414 (GHCi / GHC segfault : type checker problem) - GHC - Trac
22:35:21 <dons> is the ticket
22:35:34 <misterbeebee> since galois is so close to portland, why isn't the galois gang co-organizing the icfp contest?
22:35:41 <audreyt> Prelude Data.List> unfoldr ((),())
22:35:41 <audreyt> <interactive>:1:8:
22:35:41 <audreyt>     Couldn't match `b -> Maybe (a, b)' against `(a1, b1)'
22:35:41 <audreyt>       Expected type: b -> Maybe (a, b)
22:35:41 <audreyt>       Inferred type: (a1, b1)
22:35:44 <audreyt>     In the first argument of `unfoldr', namely `((), ())'
22:35:46 <audreyt> (ghci-6.4.3)
22:35:57 <audreyt> er.
22:36:00 <dons> misterbeebee: we're busy making money :)
22:36:06 <audreyt> Prelude Data.List> unfoldr Just ((),())
22:36:06 <audreyt> <interactive>:1:8: Occurs check: cannot construct the infinite type: b = (a, b)
22:36:12 <dons> PSU is organising though, and we're good friends with them
22:36:20 <SamB_XP_> dons: I bet you also want to enter ?
22:36:41 <SamB_XP_> couldn't do that if you organized it could you ?
22:36:45 <dons> i'd suggest a PSU organised icfp contest will be haskell friendly, fwiw
22:36:53 <audreyt> ghc-6.6.1 accepts it, though.
22:37:06 <dons> hmm. that was around the impredicativity changes?
22:37:32 <dolio> That sounds right.
22:37:43 <misterbeebee> that's why i'm so happy 6.8.3 and cabal 1.4/cabal-install just came out... ghc + libraries is much more usable now
22:38:02 <paolino> Prelude Data.List> unfoldr (\x -> Just x) (1,1)
22:38:05 <misterbeebee> except for cairo/gtk, just about everything is easy to set up
22:38:11 <paolino> ﻿> unfoldr (\x -> Just x) (1,1)
22:38:16 <dons> misterbeebee: yeah, its game changing wrt. library resuse
22:38:24 <dons> i'm gluing together way more hackage libraries now
22:38:30 <paolino> > unfoldr (\x -> Just x) (1,1)
22:38:31 <lambdabot>      Occurs check: cannot construct the infinite type: b = (a, b)
22:38:31 <lambdabot>       Expec...
22:38:32 <roconnor> sjanssen: that's fucked up?
22:38:51 <sjanssen> roconnor: yeah, isn't it bizzare?
22:39:17 <paolino> the lambda catch it
22:39:34 <roconnor> sjanssen: how did that happen?
22:39:40 <roconnor> it's really really wrong
22:39:48 <roconnor> fail
22:40:10 <roconnor> undergraduate fail
22:40:20 <roconnor> well
22:40:27 <roconnor> I guess the type system has gotten pretty complex
22:40:36 <dons> System Fc implementation fail
22:40:41 <audreyt> > :t unfoldr (id Just) ((),())
22:40:42 <lambdabot>   parse error on input `:'
22:40:44 <roconnor> apparently simple things are sliping through
22:40:50 <audreyt> <interactive>:1:9: Occurs check: cannot construct the infinite type: a = (a1, a)
22:41:01 <dons> :t unfoldr (id Just) ((),())
22:41:02 <lambdabot>     Occurs check: cannot construct the infinite type: a = (a1, a)
22:41:02 <lambdabot>       Expected type: a -> Maybe (a1, a)
22:41:02 <lambdabot>       Inferred type: a -> Maybe a
22:41:06 <dons> cool
22:41:20 <roconnor> is it fixed in 6.8?
22:41:25 <vinicius> constructors are having special treatment =P
22:41:27 <audreyt> no, it is 6.8.3
22:41:43 <dons> :t unfoldr (Just . id) ((),())
22:41:44 <lambdabot>     Occurs check: cannot construct the infinite type: b = (a, b)
22:41:44 <lambdabot>       Expected type: b -> (a, b)
22:41:44 <lambdabot>       Inferred type: b -> b
22:41:56 <roconnor> well, even Coq was proving False two years ago...
22:43:33 <SamB_XP_> epic phail
22:45:00 <flux> roconnor, a bug in the coq kernel?
22:45:01 <audreyt> even this fails:
22:45:03 <audreyt> data F a = F a deriving Show
22:45:03 <audreyt> main = let unfoldr f b = case f b of F (a,new_b) -> a : unfoldr f new_b in print $ unfoldr F ((), ())
22:45:09 <roconnor> yes
22:45:13 <audreyt> so there's nothing Prelude (or Data.List) specific
22:45:21 <paolino> is it an optimization bug ?
22:45:36 <flux> hasn't the coq kernel been proven?-)
22:45:44 <roconnor> paolino: I hope the type checker runs before the optimiser
22:45:55 <SamB_XP_> flux: in what, Coq?
22:45:57 <roconnor> flux: ... sort of
22:46:12 <dolio> In math.
22:46:18 <SamB_XP_> that's even worse!
22:46:21 <roconnor> there is Coq in Coq
22:46:27 <audreyt> "type-directed compilation: where the typechecker is the optimiser"
22:46:52 <paolino> roconnor: I mean typechecker optimization bug
22:47:01 <roconnor> ah
22:47:05 <flux> must've been that pesky real-world machine that just didn't work up to its specification ;)
22:47:22 <SamB_XP_> math is notorious for being done on paper
22:48:44 <roconnor> and blackboards
22:49:03 <dolio> You could write it down in latex. Would that be better?
22:49:11 <dolio> More readable, probably.
22:49:24 <SamB_XP_> dolio: that's mostly what I meant by "on paper", actually
22:49:42 <SamB_XP_> I think of the output of LaTeX as properly being paper ;-)
22:50:09 <paolino> if Just . id is something with  more layers than  Just , then possibly typechecker took a shortcut
22:50:20 <lorne> I don't mean to alarm you, but you might have a printer in your brain.
22:50:28 <SamB_XP_> lorne: heh
22:50:30 <SamB_XP_> I wish
22:50:51 <SamB_XP_> (especially if it was a laser printer with a stack of paper ;-)
22:51:27 <dolio> paolino: The difference seems to be constructors vs. other functions.
22:51:43 <^Someone^> I have had a special dental surgery
22:51:55 <^Someone^> So that I now have a daisy-wheel printer in my mouth :D
22:52:29 <SamB_XP_> ^Someone^: too bad that's absolutely useless for printing .ps/.pdf!
22:53:38 <^Someone^> Yeah, I'm considering an upgrade
22:53:54 <wuxia> i'm about to write this big 3d modeler in opengl; i'm currently debating between using scheme and haskell; i was wondering if anyone here had experience or could point me at projects concerning haskell/opengl modeling? any insights would be helpful
22:56:43 <paolino> dolio : both id Just and Just . id got typechecked right, doesn't this contrast the importance of constructor in the bug ?
22:57:12 <dolio> paolino: 'id Just' and 'Just . id' aren't raw constructor applications.
22:57:58 <paolino> k
22:58:27 <^Someone^> wuxia: http://www.haskell.org/haskellwiki/Frag
22:58:28 <lambdabot> Title: Frag - HaskellWiki
22:58:45 <^Someone^> wuxia: http://www.cse.unsw.edu.au/~pls/thesis/munc-thesis.pdf
22:59:05 <carl> cd
22:59:27 <wuxia> ^Someone^: thanks
22:59:31 <^Someone^> Np
23:02:23 <dolio> > let f :: (b -> Maybe (a, b)) -> a ; f g = let Just (a, b) = g b in f Just
23:02:23 <lambdabot>  Parse error at end of input
23:03:26 <dolio> > let f :: (b -> Maybe (a, b)) -> a ; f g = let Just (a, b) = g b in a in f Just
23:03:41 <lambdabot>  thread killed
23:03:55 <hpaste>  nolrai_East pasted "what does this error even mean?" at http://hpaste.org/8676
23:03:59 <dons> good stuff, http://www.reddit.com/r/programming/info/6q274/comments/
23:04:00 <lambdabot> Title: programming: Recursion Schemes: A Field Guide (ever wonder what a zygomorphism i ...
23:04:06 <dons> go edwardk!
23:04:25 <roconnor> dolio: http://arcanux.org/lambdacats/type-woes.jpg
23:04:58 <dolio> :)
23:12:39 <roconnor> The GCoalgebra version of the para type doesn't match the given type
23:12:51 <roconnor> for para
23:13:23 <roconnor> @tell edwardk The GCoalgebra version of the para type doesn't match the expanded type
23:13:23 <lambdabot> Consider it noted.
23:14:46 <roconnor> I guess it should be a GAlbegra instead
23:15:08 <roconnor> (,) a is both a monad and a comonad, which is confusing.
23:15:36 <wuxia> non biased answer please: so if i write my code in chicken scheme, and it's slow, and i profile it, and i know which f7unction is slow, i know how i can rewrite it in c and make it faster; if I write my code in haskell and it's slow; and i profile it ... where do i go from there?
23:16:04 <roconnor> wuxia: you can rewrite it in C.
23:16:08 <dolio> Look at the core.
23:16:12 <dolio> Or, yeah, write it in C.
23:16:13 <sjanssen> wuxia: writing in C is an option, but usually you'd try to make it faster in pure Haskell
23:16:15 <SamB_XP_> roconnor: but would that make it faster?
23:16:18 <geezusfreeek> wuxia: well, first of all you can try to optimize the haskell. failing that, write it in c
23:16:31 <roconnor> SamB_XP_: nope, it would make it buggy :P
23:16:42 <SamB_XP_> probably slower too
23:16:43 <povman> @quote russia
23:16:43 <lambdabot> Liempt says: In soviet russia, socket doesn't close YOU!!
23:17:20 <roconnor> but if people feel that C is some sort of safty net, it is still there.
23:17:31 <geezusfreeek> an unsafety net
23:17:33 <wuxia> so in scheme, i have decent idea of how control flow runs through the prog; but since haskell is lazy, I don't know much about how stuff is running through it; doesn't this make rewriting parts of it in c really hard?
23:17:35 <roconnor> right
23:17:37 <dons> wuxia: foreign import ccall sin :: Double -> Double
23:18:06 <dons> no, it doesn't work like that, wuxia. control flow is still control flow
23:18:14 <SamB_XP_> a danger net, even
23:18:26 <geezusfreeek> "danger net" is my middle name
23:18:29 <roconnor> @tell edwardk catamorphism link on the paramorphism page is broken.
23:18:29 <lambdabot> Consider it noted.
23:18:43 <dolio> Use the FFI to call into JavaScript!
23:19:02 <dons> good idea if your code is too fast!
23:21:08 <roconnor> I think typically people would get their programs to run faster buy writing it in shootout-haskell
23:21:41 <sjanssen> at the extreme, yes
23:22:08 <SamB_XP_> dolio: where's the addendum for that?
23:22:09 <sjanssen> wuxia: in your chicken scheme projects, what sort of functions do you end up writing in C?
23:22:13 <dons> i'd argue in practice this is pretty much never needed. :)
23:22:16 <wuxia> what's shootout-haskell ?
23:22:40 <SamB_XP_> wuxia: the kind of code they write for the shootout ;-)
23:22:47 <SamB_XP_> you do know of the shootout, don't you?
23:22:58 <SamB_XP_> if you don't, I don't think you have much to worry about ;-P
23:23:08 <dons> anyway... if its chicken scheme we're comparing against ... .
23:23:09 <dolio> SamB_XP_: I don't know. I assume you'd have to be using the YHC JavaScript backend (if that still exists).
23:23:24 <wuxia> sjanssen: i'm about to write a ray tracedr; it's just that with chickn scheme, i'm comfortable with pulling out the ffi; where as with haskell, i guess i don't understand it yet and am wondering if laziness will bite me somewhere
23:23:30 <SamB_XP_> dolio: why the hell wouldn't it still exist?
23:24:03 <dons> wuxia: http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=ghc&lang2=chicken
23:24:04 <lambdabot> Title: Haskell GHC benchmarks | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lang ..., http://tinyurl.com/67mda8
23:24:05 <SamB_XP_> wuxia: if laziness bites, you can zap it
23:24:13 <dolio> Perhaps they deleted it out of spite?
23:24:15 <dons> this is why the questionnn is kind of meaningless :) ^^
23:24:24 <mmorrow> dolio: it still exists and works
23:24:42 <mmorrow> dolio: im slogging through the grok now
23:24:50 <dobblego> what's the typical way a mac user installs ghc? compile from source?
23:25:00 <dons> so what's that, 10x faster than chicken scheme on average? i wonder if that corresponds to 10x less code that needs to be rewritten in C?
23:25:01 <SamB_XP_> dobblego: that can't be it
23:25:05 <geezusfreeek> dobblego: i use macports, but it tend to take a while to get up to date
23:25:09 <SamB_XP_> because ghc is needed to compile GHC
23:25:26 <sjanssen> dobblego: there are mac installers now
23:25:27 <dobblego> right, so I assume you must bootstrap somehow
23:25:37 <SamB_XP_> well, perhaps they compile a newer version then, I dunno...
23:25:42 <sjanssen> dobblego: back when I used a mac, I used macports
23:25:50 <dobblego> ok cheers
23:25:51 <SamB_XP_> dobblego: the typical way is to install a binary version first ;-)
23:26:14 <wuxia> hmm okay; so the point is that haskell blows chiciken scheme away
23:26:18 <wuxia> and i shouldn't worry :-)
23:26:29 <dons> yeah. :)(
23:26:34 <roconnor> GHC blows chicken scheme away
23:26:42 <roconnor> I'm not sure I'd call that stuff Haskell :P
23:26:51 <geezusfreeek> macports downloads a ghc binary and uses it to compile a more up to date ghc, iirc
23:26:52 <geezusfreeek> wuxia: well, you may run into problems due to your inexperience with laziness, but it's nothing we can't help you with
23:27:14 <wuxia> inexpedrience with laziness, ha!
23:27:22 <wuxia> lol; sorry, pun was too funny
23:27:39 <dons> roconnor: a lot of them are h98 (binary-trees is a good example)
23:27:54 <dons> the remaining "shootout-haskell" ones use numerics, so should really use hmatrix or uvector
23:28:21 <dons> thread-ring's another h98 one, iirc. sum-file does great with only a bang pattern. nsieve-bits rocks out ST style
23:28:47 <geezusfreeek> yeah i kind of giggled at it too
23:28:47 <geezusfreeek> it has always ticked me off that binary-tree is required to have a strict spine
23:28:49 <dolio> At worst, most of the shootout stuff should be H', I imagine.
23:29:04 <dons> there's few language extensions specifically for performance
23:29:35 <wuxia> does ghc take advantage of multicore? i.e. will only one or all 4 of my quad cores be used?
23:29:48 <sjanssen> wuxia: GHC can use your cores
23:29:54 <dons> wuxia: ghc can produce programs that run on multiple cores, yes.
23:29:57 <sjanssen> that isn't automatic, of course
23:30:07 <wuxia> where do i read morea bout this?
23:30:07 <geezusfreeek> wuxia: it isn't completely automatic, but it makes it much easier to take advantage of your cores than you could with other compilers/languages
23:30:11 <wuxia> why is it not automatic?
23:30:13 <roconnor> wuxia: I think the haskell shootout programs would be faster if we didn't have to stick to their arbitrary rules.
23:30:25 <dons> wuxia: general automatic parallelisation is an unsolved problem.
23:30:26 <wuxia> roconnor: like what?
23:30:33 <SamB_XP_> wuxia: we gave up on that years ago
23:30:35 <SamB_XP_> more or less
23:30:46 <sjanssen> wuxia: this is generally recognized to be a Hard Problem (can you name many other systems that parallelize your program with no effort?)
23:30:50 <geezusfreeek> wuxia: look at forkIO, par, strategies, nested data parallelism, STM, and so on
23:30:51 <roconnor> -- an artificially strict tree.
23:30:51 <roconnor> --
23:30:51 <roconnor> -- normally you would ensure the branches are lazy, but this benchmark
23:30:51 <roconnor> -- requires strict allocation.
23:31:08 <SamB_XP_> wuxia: after years of failed attempts
23:31:10 <dolio> The binary trees one is meant to test garbage collection, so it makes some sense.
23:31:28 <SamB_XP_> NDP is about as close as it gets to automatic
23:31:31 <dons> wuxia: here's some references on multicore haskell,
23:31:35 <dons> http://haskell.org/haskellwiki/Applications_and_libraries/Concurrency_and_parallelism
23:31:36 <lambdabot> Title: Applications and libraries/Concurrency and parallelism - HaskellWiki, http://tinyurl.com/2u95za
23:31:55 <dons> yes, there are particular subsets of Haskell (namely those using parallel arrays) that are automatically parallel
23:32:10 <Gilly> weird, on shootout haskell is doing much worse on AMD Sempron
23:32:17 <dons> the AMD one is way way out of date.
23:32:25 <dons> note programs missing, or failing for no obvious reason
23:32:26 <Pseudonym> There are subsets of C that are automatically parallel, too!
23:32:28 <dolio> dons: By the way, I downloaded the ndp library, and didn't see any memcpy in there.
23:32:30 <Pseudonym> The pure subsets.
23:32:32 <Gilly> so they run different code on the processors, why?
23:32:50 <dons> the AMD guy just doesn't update very often, or keep the toolchain up to date
23:32:52 <dolio> dons: At least, not exposed as a general operation.
23:33:05 <dons> dolio: hmm. ok. well there's on in bytestring, so you could use that.
23:33:29 <sjanssen> Foreign.* doesn't provide memcpy?
23:33:34 <sjanssen> I could have sworn it does
23:33:37 <dolio> dons: Well, I had such a thing for uvector already. I just haven't settled on a good name for it yet.
23:33:38 <Gilly> ahh i see - the complier is 6.6.1 there
23:33:45 <SamB_XP_> @hoogle memcpy
23:33:45 <lambdabot> Data.ByteString.Internal.memcpy :: Ptr Word8 -> Ptr Word8 -> CSize -> IO ()
23:33:45 <lambdabot> Data.ByteString.Internal.memcpy_ptr_baoff :: Ptr a -> RawBuffer -> CInt -> CSize -> IO (Ptr ())
23:33:46 <Gilly> *compiler
23:33:56 <sjanssen> SamB_XP_: it has a different name, I'm sure
23:34:00 <SamB_XP_> @hoogle copy
23:34:01 <lambdabot> Data.ByteString.copy :: ByteString -> ByteString
23:34:01 <lambdabot> Data.ByteString.Char8.copy :: ByteString -> ByteString
23:34:01 <lambdabot> Data.ByteString.Lazy.copy :: ByteString -> ByteString
23:34:25 <sjanssen> dolio: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Foreign-Marshal-Array.html#v%3AcopyArray is a wrapper around memcpy
23:34:26 <lambdabot> http://tinyurl.com/6mhaa3
23:34:39 <dolio> I might just go with memcpyMU and so on, following mauke's diatribe on very different, arbitrary names recently.
23:34:59 * geezusfreeek is finally diving into HAppS seriously
23:35:12 <SamB_XP_> why can't we just call a memcpy a memcpy and be DONE with it?
23:35:19 <sjanssen> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Foreign-Marshal-Utils.html#v%3AcopyBytes is actually the more primitive one
23:35:20 <lambdabot> http://tinyurl.com/5hprwo
23:35:23 <dons> memcpy :: Ptr Word8 -> Ptr Word8 -> CSize -> IO () is called memcpy
23:35:24 <SamB_XP_> same with sockets
23:35:48 <sjanssen> dolio: why not use Foreign.Mashal.copyBytes -- it is already there for you to use
23:35:59 <SamB_XP_> dons: shouldn't those Ptrs be "Ptr a"
23:36:05 <dolio> sjanssen: It doesn't work with MutableByteArray#.
23:36:10 <sjanssen> ahh
23:36:27 <sjanssen> can you even use memcpy on those?
23:36:31 <dons> SamB_XP_: you should bee a Ptr a
23:36:32 <dolio> Yes.
23:36:34 <sjanssen> IIRC, the GC can move them around
23:36:49 <dolio> At least, ST arrays do internally.
23:36:56 <SamB_XP_> sjanssen: not when it isn't running
23:36:58 <Lemon> is (.) associative?
23:37:03 <SamB_XP_> Lemon: yes
23:38:14 <dolio> Anyhow, it's not so much what to do on the low-level end as to what to call the higher level 'MUArr e s -> MUArr e s -> Int -> Int -> ST s ()' operation.
23:38:28 <dolio> Since copyMU is already taken.
23:38:40 <dolio> Or, whatever I was going to use.
23:41:32 <povman> awesome, i just found a reason to use data X a = X String
23:41:38 <dons> http://www.reddit.com/info/6q2dw/comments/
23:41:38 <lambdabot> Title: reddit.com: "they should begin to use thousands of threads in their applications ...
23:43:18 <dons> i like how this followed just after ghc's million thread benchmark
23:43:38 <wuxia> how do i tell cabal: download src of HRay and compile it?
23:43:49 <dons> cabal install hray
23:43:55 <dobblego> dons, who is this guy?
23:44:11 <dons> dobblego: the guy commenting on the intel blog? i think his name's mentioned there somewhere.
23:44:30 <dons> pretty cool reaction/fear/panic :)
23:44:31 <dobblego> I mean, what's he talking about?
23:44:45 <misterbeebee_> what's the haskell version (or alternative to)   Erlang Actors / Java Kilim (lightweight multitudinous communicating  threads)
23:44:46 <dons> oh, that intel's scamming us all talking about 1000s of cores, since programmers can't use threads as it is.
23:44:53 <dons> misterbeebee_: forkIO
23:45:17 <dons> ghc's lightweight threads are fast, versatile, easy.
23:45:19 <dobblego> are we expecting the Intel guys to smile at his comments, then carry on?
23:45:38 <dons> dobblego: shrug, and spend more money on compiler research?
23:45:58 * dons wonders if we'll all know how to decompose programs into nested parallel array programs in a few years
23:47:17 <quicksilver> http://forum.lolcode.com/viewtopic.php?id=51
23:47:17 <lambdabot> Title: The LOLCODE forum / Proof that LOLCode is turing complete:BrainF*** interpreter  ...
23:47:18 <dolio> dons: That's that nutty guy that hates Erlang and functional programming.
23:47:20 <dolio> And algorithms.
23:47:56 <wuxia> given a HRayParser.y how do I create a HRayParser.hs out of it?
23:48:21 <dolio> Because his definition of algorithm excludes anything with parallelism, or something.
23:48:59 <roconnor> ugh, a deriviative is not a zipper
23:49:09 <dolio> Oh, and the Bible predicts particle physics, or something.
23:49:43 <dons> dolio: awesome. :)
23:49:58 <dolio> http://rebelscience.blogspot.com/
23:49:58 <lambdabot> Title: Rebel Science News
23:50:30 <dolio> And his software design system will save us all.
23:50:31 <dons> uh oh. he's a maverick
23:50:46 <vinicius> how does ghc deals with threads? m lib: n kernel?
23:50:48 <dolio> Except the vast academic conspiracy is trying to keep him down.
23:51:06 <dons> vinicius: N haskell threads mapped onto M OS threads
23:51:07 <wuxia> academic conspiracy?
23:51:09 <sjanssen> vinicius: yes, an m-to-n mapping
23:51:13 <wuxia> who is 'he' ?
23:51:19 <dons> dolio: wow, that's like 4 points on the crank scale already
23:51:27 <vinicius> nice
23:51:27 <jsnx> dolio: who is this, exactly?
23:52:02 <dons> crackpot index, i should say
23:52:05 <dolio> The guy dons was quoting in the comments of that Intel blog.
23:52:05 <dons> http://math.ucr.edu/home/baez/crackpot.html
23:52:06 <lambdabot> Title: Crackpot index
23:52:22 <jsnx> just returned to the channel
23:52:36 <jsnx> is this about "unwelcome advice" ?
23:52:47 <dons> 10 points for claiming that your work is on the cutting edge of a "paradigm shift".
23:53:07 <roconnor> http://arxiv.org/abs/0806.4631
23:53:23 <dons> 40 points for claiming that the "scientific establishment" is engaged in a "conspiracy" to prevent your work from gaining its well-deserved fame, or suchlike.
23:53:28 <roconnor> The Heap Lambda Machine
23:53:38 <dolio> I'm not even sure what the guy is ranting about on the intel blog.
23:53:54 <SamB_XP_> roconnor: what do you mean a derivative is not a zipper?
23:53:56 <dolio> Apparently he's offended that they recommended threading or something.
23:53:57 <wuxia> I havbe HRayParser.y but ghc wants HRayParser.hs -- how do I buuilt HRayParser.hs ?
23:54:00 <jsnx> aha
23:54:04 <wuxia> is there some haskell varikant of yacc?
23:54:08 <dons> dolio: threads dude. threads and nazis
23:54:17 <dons> wuxia: yeah, 'happy'
23:54:26 <dons> 'alex' is the lex variant.
23:54:36 <dons> small parsers people write using the parser library, parsec.
23:54:37 <dolio> Which, I mean, Intel makes chips. They're just telling people that you'll have to be able to make use of 1000s of cores.
23:54:55 <roconnor> SamB_XP_: a derivative does not give you constant time access to the neighbours, it gives you constant time access to the root.
23:55:18 <SamB_XP_> roconnor: hmm.
23:55:46 <SamB_XP_> there may be a lack of clarity in the literature on this point!
23:56:00 <roconnor> The wiki book describes it well, but I always refer to conor's paper: http://strictlypositive.org/CJ.pdf (which isn't his derivatives paper)
23:56:06 <jsnx> oh, this is interesting
23:56:42 <wuxia> oh wow, HRay.exe is taking up 100% of cpu, so it's using both co4res?
23:56:43 <roconnor> the derivative of a list is two lists, but both going in forward order
23:57:00 <jsnx> "non-algorithmic" processing with every computation taking a certain fixed amount of time
23:57:02 <SamB_XP_> roconnor: I never got how that worked
23:57:02 <roconnor> the zipper of a list is two lists, but one going in reverse.
23:57:06 <mmorrow> wuxia: for ghc, do     happy --ghc Asdf.y     alex --ghc Asdf.x
23:57:25 <dons> wuxia: i'm not sure if hray is parallelised, is it?
23:57:30 <wuxia> mmorrow: I did: 'happy HRayParser.y' and it just worked
23:57:31 <roconnor> hmm, this isn't that clowns and jokers paper I remember.
23:57:42 <SamB_XP_> roconnor: there are two versions
23:57:44 <wuxia> dons: I dunno; how do I check? i was just wa5tchint its cpu usage from top
23:57:45 <mmorrow> wuxia: the --ghc switch optimizes them somewhat
23:57:47 <SamB_XP_> a newer and an older one
23:58:04 <jsnx> the future of parallel programming is necessarily graphical!
23:58:08 <dons> wuxia: it might be, but they'd probably advertise it , if that was the case.
23:58:08 <jsnx> that's enough!
23:58:12 <mmorrow> wuxia: well, not optimizes, but uses faster primitives only available in ghc
23:58:37 <dolio> jsnx: That's the only way to write non-algorithmic programs!
23:58:45 <jsnx> dolio: hehe
23:58:48 <roconnor> SamB_XP_: http://strictlypositive.org/Dissect.pdf
23:58:55 <jsnx> they are "nonwritten" programs
23:58:57 <roconnor> Section 2.1 explains it pretty well
23:59:00 <vinicius> reddit's comments have a long way before reaching youtube's comments level.
23:59:18 <roconnor> (other than some minor type errors)
23:59:24 <wuxia> hray.exe is pegging cpu at 100% again; so i guess it's definitely using 2 cores; ... in linux, is there a way to force a prog to only use 1 core? (then i can see if thedre is an actual speedup)
23:59:34 <dons> +RTS -N1
23:59:36 <quicksilver> wuxia: both cores would be 200% surely
23:59:39 <dons> passed at runtime
23:59:42 <dons> quicksilver: it depends on the OS
23:59:58 <dons> linux tends to report it as a % of total resources
