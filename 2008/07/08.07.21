00:04:30 <_zenon_> you seemed "on the go"
00:05:06 <_zenon_> but that is my most personal non-scientific non-statistically secure opinion
00:11:20 <hml> if i map space to some key i hit with my pinky, am i begging for rsi?
00:16:31 <cjs> Not if that key is semicolon. :-)
00:27:04 <Pistahh> hi
00:27:08 <_zenon_> Hi
00:27:11 <Pistahh> when I see a definition like this:
00:27:17 <Pistahh> maternalGrandfather :: Sheep -> Maybe Sheep
00:27:18 <Pistahh> maternalGrandfather s = (return s) >>= mother >>= father
00:27:30 <Pistahh> how does 'return' know that it is for Maybe?
00:27:44 <_zenon_> It is inferred
00:27:56 <_zenon_> You are reading the "All about monads", good :)
00:28:09 <Pistahh> yeah, and actually I start understanding monads. :)
00:28:18 <_zenon_> Shee -> Maybe Sheep
00:28:32 <_zenon_> there it is: Maybe (Sheep)
00:29:02 <_zenon_> Pistahh, I can also recommend Wadlers paper on monads
00:29:28 <_zenon_> Pistahh, http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf
00:29:30 <lambdabot> Title: Monads for functional programming, http://tinyurl.com/zhxow
00:30:23 <Pistahh> _zenon_: so just because the end result must be a maybe, it knows that it can be only if the return belongs to Maybe?
00:31:14 <thoughtpolice> Pistahh: type inference tells it what instance of the Monad class to use (in this case, the Maybe instance)
00:31:44 <_zenon_> Pistahh, like thoughtpolice said.
00:32:22 <yitz> Pistahh: yes. return is a -> m a, and we know from context that the only way that makes sense here is if m = Maybe and a = Sheep.
00:32:24 <vixey> Pistahh: You know what's really neat
00:32:24 <lambdabot> vixey: You have 1 new message. '/msg lambdabot @messages' to read it.
00:32:39 <vixey> Pistahh: If you remove 'maternalGrandfather :: Sheep -> Maybe Sheep', it will still figure out the type
00:32:55 <dancor> hm what is the coolest way to store UTCTime in sqlite
00:32:57 <vixey> (I.e. you can load it up and go :t maternalGrandfather)
00:32:59 <vixey> @messages
00:32:59 <lambdabot> dolio said 9d 23h 36m 13s ago: I rewrote my more polished PTS type checker to use unification (and fixed up the unification algorithm a little). You can see it at http://code.haskell.org/~dolio/pts/
00:32:59 <lambdabot> (it's a darcs repo, it's got a little REPL, too).
00:33:16 <dolio> Man, that's old.
00:33:30 <vixey> uh oh ...
00:33:40 * ski 's gotten an old message several times, too ..
00:33:40 * Pistahh scratches his heads
00:34:03 <_zenon_> Pistahh, the automatic derivation without the function type signature follows from "mother::Maybe Sheep, father::Maybe Sheep"
00:34:17 <_zenon_> Pistahh, that which vixey said,
00:34:26 <dancor> maybe just a text or blob
00:34:29 <dancor> sigh
00:34:47 <ski>   mother,father :: Sheep -> Maybe Sheep
00:34:47 <yitz> lambdabot got reloaded not too long ago, maybe it picked up some old messages from old saved state.
00:35:41 <Pistahh> _zenon_: I'm reading about 4 papers on monads at the same time. It is always an other one that adds a new piece to the puzzle. :)
00:36:00 <_zenon_> Pistahh, good. keep it up :)
00:36:07 * _zenon_ must get back to work now
00:36:35 <shepheb> @quote violent.and.irreversible
00:36:36 <lambdabot> No quotes match. I am sorry.
00:36:45 <shepheb> @quote irreversible
00:36:45 <lambdabot> No quotes match. :(
00:36:49 <shepheb> bah
00:37:34 <shepheb> there was an old quote, "There's a time when your brain doesn't get the monads. Then something violent and irreversible happens, and you hate all other programming languages for not having monads" or similar.
00:37:52 <vixey> :(
00:38:05 <vixey> You can add monads to most
00:39:11 <shepheb> @quote vending
00:39:11 <lambdabot> JohnMeacham says: I liken learning haskell to tipping over a vending machine. you can't just push it, you gotta rock it back and forth a few times building up momentum until bam! suddenly the flash
00:39:11 <lambdabot> of insight hits and it all makes sense.
00:39:34 <vixey> @quote
00:39:35 <lambdabot> astrolabe says: calling variables things like ll,kk,tt and dd is a bit cryptic
00:39:39 <vixey> @quote
00:39:39 <lambdabot> fasta says: I think the @remember command is way overused.
00:40:38 <cjs> vixey: Yeah, but monads only really work well when your standard libraries use them all over the place.
00:43:00 <erikc> monads in c++ with template metaprogramming actually work out well once you build up a set of closure classes
00:43:15 <thoughtpolice> has anybody had any luck building ndp against a recent version of ghc?
00:47:25 <steven_ashley> Hey guys, I am trying to define a := operator in GHCi 6.8.2 but I'm getting some odd errors. the command is "let a := b = (a,b)". The error is "<interactive>:1:6: Not in scope: data constructor `:='". I only have the Prelude in scope. Defining other operators (=== for instance) seems to work.
00:49:29 <Deewiant> All operators which start with : are data constructors
00:50:04 <Deewiant> So you could do "data Foo a b = a := b", for instance
00:50:16 <Deewiant> But that's probably not what you want
00:50:43 <steven_ashley> Ahh, I see, thanks, I can do something with that :)
00:50:44 <Deewiant> But neither can you bypass the issue, so essentially you just need to pick a different name for your operator.
00:52:25 <thoughtpolice> hi conal. i was playing with reactive recently and i was wondering if you could give me some pointers?
00:53:00 <conal> thoughtpolice: i can try.  which version of reactive: c.h.o or d.h.o?
00:53:10 <thoughtpolice> conal: the one from hackage, 0.5
00:53:27 <thoughtpolice> conal: i'm still trying to wrap my head around the whole concept but i just had a basic question or two
00:53:36 <conal> thoughtpolice: fire away
00:53:55 <conal> i'm happy to help people grok frp
00:54:31 <thoughtpolice> http://hpaste.org/9062#a0
00:54:53 <thoughtpolice> in that example, we can make occurances of the event by sending stuff down the sink, but is there no way for example to say the sink is 'finished' and the event won't happen?
00:55:15 <thoughtpolice> in the example above, it'll never get to printing 'fin' since runE loops itself, so the thread will block indefinitely
00:55:32 <thoughtpolice> i suppose i could work around it using forkE or something and an MVar, but i was wondering if there was a cleaner solution?
00:57:40 <thoughtpolice> conal: aside from that I'm also wondering just exactly what the 'Reactive' type is and perhaps some good idioms to abide by? i've been looking through your blog posts but i only started earlier today
00:57:54 <thoughtpolice> s/abide by/utilize/
00:58:27 <conal> thoughtpolice: i had in mind that the library would be used functionally, rather than imperatively.  in a future release, i'll hide things like runE and mkEvent, and give just a functional interface.
00:59:11 <conal> thoughtpolice: the 'Reactive' type is a piecewise-constant function of time.
01:00:05 <conal> thoughtpolice: this library is in a lot of flux and should be in much better shape at the end of the summer.  to get a feel for the FRP style, you might want to look at early Fran/FRP papers.
01:00:27 <Quadrescence> If I have data Foo = Bar1 | Baz2 | BarBaz3; deriving(Enum, Show, Eq, Ord), is Bar1 == 0::Int?
01:00:55 <conal> thoughtpolice: see http://conal.net/papers and http://conal.net/Fran/tutorial.htm
01:00:56 <lambdabot> Title: Conal Elliottís Publications
01:01:51 <thoughtpolice> conal: appreciated
01:02:38 <thoughtpolice> conal: it's a very interesting piece of work so i'll keep myself posted. as a tip though, if you clean it up, have lots of good examples. :)
01:02:53 <thoughtpolice> i only found one example off of haskell-cafe which is basically how i threw together what I had above
01:03:23 <conal> thoughtpolice: will do.  thanks for the suggestion.
01:04:40 <thoughtpolice> Quadrescence: yes. fromEnum Bar1 == 0, fromEnum Baz2 == 1, etc. etc.
01:05:28 <Quadrescence> thoughtpolice: so, would this make any sense: [Bar1 .. BarBaz3] ?
01:05:33 <Quadrescence> Or would I need fromEnum?
01:06:03 <Quadrescence> since Bar1, etc aren't ACTUALLY storing values.
01:06:52 <Quadrescence> i.e., [fromEnum Bar1 .. fromEnum BarBaz3]
01:07:47 <yitz> Quadrescence: you don't need fromEnum
01:07:48 <thoughtpolice> Quadrescence: no, you can do that if you derive enum
01:08:01 <Quadrescence> mmmmmmmmmm
01:08:27 <yitz> that's the whole point of the Enum class, so you can use exactly that syntax for your type.
01:08:54 <Quadrescence> Lastly, if I use functions with such a list, can I say, for example, someFunction :: [Int] -> [Int]
01:09:05 <Quadrescence> Or do I need [Foo]?
01:09:09 <thoughtpolice> anything that can derive enum basically has an ordering, so [x..y] will make sense, because, well, you're creating a list of those ordered values
01:09:14 <thoughtpolice> you need [Foo]
01:09:40 <Quadrescence> This might get messy. :S
01:09:48 <thoughtpolice> [Bar1 .. BarBaz3] == [Bar1,Baz2,BarBaz3], so the type is [Foo]
01:09:58 <yitz> @type map fromEnum
01:10:02 <thoughtpolice> since you're deriving enum though, every constructor has an integer counterpart naturally
01:10:04 <thoughtpolice> yeah
01:10:07 <thoughtpolice> so just map fromenum
01:10:12 <lambdabot> forall a (f :: * -> *). (Functor f, Enum a) => f a -> f Int
01:10:25 <Quadrescence> mmm
01:10:38 <Quadrescence> And that just "converts" them, I see.
01:10:43 <codacola> hello all
01:10:47 <Quadrescence> type-wise, at least.
01:10:51 <thoughtpolice> someFunction :: [Int] -> [Int], someFunction = <your code here> . map fromEnum
01:10:57 <thoughtpolice> er
01:11:08 <Quadrescence> I gotchaaaaaaaaa thoughtpolice.
01:11:14 <thoughtpolice> someFunction :: [Foo] -> [..] in that case
01:11:14 <thoughtpolice> yeah
01:15:10 <dmwit> hay gais!
01:15:47 <yitz> hey
01:17:35 <dmwit> oop
01:17:46 <ski> fp
01:17:47 <dmwit> When did map become fmap?
01:17:56 <dmwit> :t (.) -- still fmap?
01:17:56 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
01:18:09 <ski> since Cale took over lambdabot, i think
01:18:22 <ski> @src (.)
01:18:22 <lambdabot> (f . g) x = f (g x)
01:18:22 <lambdabot> -- In lambdabot, it's been generalised to:
01:18:22 <lambdabot> (.) = fmap
01:18:34 <dmwit> Oh, surely the "map = fmap" one has been in the last week or so.
01:19:37 <Quadrescence> Do I just use someList::[SomeType] to specify type explicitely?
01:19:48 <Quadrescence> s/explicitely/explicitly/
01:20:00 <opqdonut> (.) = fmap requires Functor defaulting to (r->) imo
01:20:10 <Quadrescence> (in, for example, a where-block)
01:20:12 <ski> (dmwit : um, misinterpreted what you asked ..)
01:20:16 <vixey> opqdonut: No
01:20:23 <ski> Quadrescence : sure
01:20:35 <Quadrescence> Okie dokie
01:20:36 <opqdonut> vixey: I mean from a usability perspective
01:20:38 <vixey> when you write f . g, type class dispatch makes it use ->
01:20:39 <opqdonut> not type theory
01:21:17 <opqdonut> i've run into quite a few times when :t has thrown up something weird because of the (.) redefinition
01:21:21 <vixey> (.) = fmap requires turning off monomorphism
01:21:33 <codacola> got my first haskell assignment :D
01:21:50 <Quadrescence> codacola: :D
01:21:57 <ski> opqdonut : in what situations would you want that defaulting ?
01:22:02 <opqdonut> hmm, my lastlog doesn't reach far back enough
01:22:11 <opqdonut> but there was one just a few weeks ago
01:22:26 <opqdonut> I'll see if I can remember it
01:24:06 <vixey> opqdonut: It's the same as saying for >>= to work you want it to default to Reader
01:24:48 <dolio> dmwit: It's been that way for a while.
01:25:11 <dmwit> huh
01:25:12 <opqdonut> vixey: no it's not
01:27:26 <vixey> why not
01:28:36 <opqdonut> well okay it is, but people expect >>= to throw up monads in the typesig
01:28:48 <vixey> I don't
01:29:01 <hackage> Uploaded to hackage: line2pdf 0.0.7
01:29:01 <hackage> Uploaded to hackage: pugs-compat 0.0.5
01:29:01 <hackage> Uploaded to hackage: regex-pcre-builtin 0.94.2.0.7.7
01:29:02 <hackage> Uploaded to hackage: HsSVN 0.3.3
01:29:04 <hackage> Uploaded to hackage: bytestring-lexing 0.1.0.2
01:29:47 <opqdonut> I'm still trying to remember the example where (.) = fmap generalized the type "too much"
01:30:01 <vixey> there is no such case
01:30:47 <opqdonut> well too much depends one one's preferences
01:31:42 <opqdonut> *on
01:33:25 <opqdonut> anyway, the case went like this: some newbie came asking for help on simplifying a definition, I gave a pointfree definition, he did :t on it and was completely baffled by the type
01:34:16 <opqdonut> of course type inference would eliminate this when the defined function is used in context
01:34:30 <vixey> no it wouldn't
01:34:40 <vixey> if I write  f = ...
01:34:45 <vixey> then g = ... f ...
01:34:50 <opqdonut> yeah yeah, f still has the general type
01:34:57 <ToRA> @type ((+3) .)
01:34:57 <lambdabot> forall a (f :: * -> *). (Functor f, Num a) => f a -> f a
01:34:57 <vixey> the type of g doesn't affect the type of f, or does it ?
01:35:09 <mauke> vixey: welcome to the monomorphism restriction
01:35:11 <opqdonut> I mean there is no need for defaulting when f is used
01:35:14 <dolio> It might, it depends.
01:36:40 <opqdonut> hmm, now that I reconsider I should be really arguing against (.)=fmap and not for defaulting
01:36:50 <dolio> 'g = fmap (+3) ; f = g [1,2,3]' results in g :: [Integer] -> [Integer] under the monomorphism restriction.
01:37:05 <opqdonut> however I am pro (.)=fmap so I guess I'd better just vanish in a puff of logic
01:37:49 <vixey> :t let g = fmap (+3) ; f = g [1,2,3] in g
01:37:50 <lambdabot> forall (f :: * -> *) a. (Functor f, Num a) => f a -> f a
01:37:52 <vixey> :t let g = fmap (+3) in g
01:37:53 <lambdabot> forall (f :: * -> *) a. (Functor f, Num a) => f a -> f a
01:37:57 <opqdonut> (the problem all along was that "f (g x)" is no longer equal to "(f . g) x" in terms of type inference and stuff, but that's really the point of (.)=fmap)
01:38:02 <dolio> If there's no f you get complaints about ambiguity, since there's no default for Functor.
01:38:12 <dolio> Lambdabot has the monomorphism restriction switched off, I think.
01:38:37 <vixey>  :t let g = fmap (+3) ; f = g [1,2,3] in g
01:38:37 <vixey> let g = fmap (+3) ; f = g [1,2,3] in g :: (Num a) => [a] -> [a]
01:38:37 <vixey>  :t let g = fmap (+3) in g
01:38:37 <vixey> let g = fmap (+3) in g :: (Num a, Functor f) => f a -> f a
01:39:03 <vixey> that's pretty weird though
01:39:47 <dolio> If you instead do 'f = g [1,2,3] ; h = g id' you'll get complaints about not being able to match (->) r with [] and such.
01:39:58 <opqdonut> well the monomorphism restriction is kinda ill-founded anyways
01:40:47 <dolio> I'm not a huge fan, but it almost never actually hurts me.
01:40:51 <opqdonut> it's there because people assume that people assume that "global constants" should only be evaluated once
01:41:17 <mauke> people also assume "return ()" aborts the current function
01:41:18 <dolio> Since I annotate liberally.
01:41:27 <steven_ashley> only caught me once, and it disappeared with a refactor anyway :P
01:41:34 <opqdonut> mauke: mhmm.
01:41:45 <|Steve|> What is the monomorphism restriction?
01:41:56 <opqdonut> no reason to cripple the language so that people wouldn't have to relearn stuff
01:41:56 <mauke> ÔΩÑÔΩíÔΩÖÔΩÅÔΩÑÔΩÖÔΩÑ
01:42:18 <opqdonut> it's not like they're not already rewiring every other part of their brain when learning haskell
01:42:22 <vixey> you can just turn it off with a flag
01:42:36 <opqdonut> (wow, that turned out incomprehensible)
01:44:29 <dmwit> Par for the course, opqdonut.
01:44:34 <mauke> opqdonut: made sense to me :-)
01:45:01 <opqdonut> :)
01:45:33 <schme_> hmmm.
01:45:41 <schme_> I don't quite understand the rewiring bit. :S
01:45:55 <mauke> what, you don't have wires in your brain?
01:46:21 <schme_> Hehehehe.
01:46:35 <schme_> No I just don't see 'em getting so much rewired by learning haskell.
01:47:13 <dolio> |Steve|: The monomorphism restriction says that when you have a declaration of the form 'x = e', x is not allowed to have any type class constrained polymorphism inferred. Instead, a single monomorphic type must be chosen.
01:47:44 <dolio> Although if you give it an explicit signature, you can override it.
01:48:04 <schme_> (really my wires just seem to get bored and annoyed by haskell, oh well)
01:48:10 <opqdonut> |Steve|: it's intended to make things like "pi = 4*atan 1" evaluated only once
01:48:10 <|Steve|> Oh, that seems sort of dumb.
01:48:25 <|Steve|> That seems less dumb.
01:48:30 <opqdonut> yeah
01:48:32 <opqdonut> it's a tradeoff
01:48:49 <opqdonut> :t 4*atan 1
01:48:53 <lambdabot> forall t. (Floating t) => t
01:49:00 <dolio> Or 'fibs = 0 : 1 : zipWith (+) fibs (tail fibs)'.
01:49:05 <vixey> so ................ wait a sec
01:49:11 <opqdonut> dolio: yeah, better example
01:49:14 <vixey> pi :: Rational
01:49:15 <vixey> pi = 4*atan 1
01:49:15 <dolio> If you're a fan of the global 'list of fibonaccis' style of programming.
01:49:16 <|Steve|> See you haskell people like your CT so much that I thought you were talking about monomorphisms as in a monic morphism.
01:49:19 <vixey> will only evaluate it once
01:49:29 <opqdonut> vixey: yes
01:49:49 <opqdonut> or at most once actually ;)
01:49:49 <vixey> monomorphism is actually there to -let people not type type signatures-?
01:50:00 <opqdonut> vixey: if you put it that way, yes
01:50:17 <mauke> hehe
01:50:33 <mauke> hylomonomorphism
01:50:41 <dolio> It lets them not write some signatures while requiring them to write others.
01:50:44 <dolio> Instead of vice versa. :)
01:50:44 <opqdonut> or actually, **let people not type type explicit signatures for their TOP-LEVEL DEFINITIONS**
01:51:08 <opqdonut> hmm, permutate the words in that a bit
01:51:11 <roconnor> Do I need to do +RTS -N2 to run on more than core
01:51:12 <|Steve|> "type explicit type-signatures"
01:54:23 <conal> does anyone know of a QuickCheck helper library with properties of standard type classes?
01:55:26 <opqdonut> roconnor: yes, aiui
01:57:54 <thoughtpolice> roconnor: yes
01:58:19 <conal> it occured to me that most of Reactive could be QuickCheck'd with some generic properties on standard type classes.
01:59:46 <roconnor> ugh, I don't really get the difference between seq and pseq and why not fib n = r `par` (l `par` l+r)
02:02:20 <dolio> You need to ensure that l and r are finished being evaluated before evaluating l+r, or something like that.
02:04:03 <dolio> What's the 'right' way? r `par` l `pseq` l+r?
02:04:58 * vixey would rather write l+r ... I guess pH isn't progressing anymore though
02:05:07 <roconnor> wouldn't haskell automagically notice that r and l are already being evaluated
02:05:15 <roconnor> or would it try to evaluate them twice?
02:05:23 <codacola> god laptop batteries are expensive
02:05:26 <dolio> I don't know. Maybe.
02:05:45 <vixey> maybe the automagic bit takes times to detect, compared to being explicit with pseq
02:05:50 <vixey> (just guessing though...)
02:06:38 <|Steve|> @type sec
02:06:39 <lambdabot> Not in scope: `sec'
02:06:42 <|Steve|> @type seq
02:06:43 <lambdabot> forall a t. a -> t -> t
02:06:50 <vixey> @src seq
02:06:51 <lambdabot> Source not found. I feel much better now.
02:06:57 <|Steve|> @type pseq
02:06:58 <Quadrescence> noob question: I can run a haskell program with modules without having to compile, right?
02:06:58 <lambdabot> forall a b. a -> b -> b
02:07:06 <|Steve|> Quadrescence: runhaskell
02:07:19 <Quadrescence> Okie Dokie
02:07:46 <_Dae_> Do any of you guys have any experience with haskell and Vista? I can't use half the gcc optimizations without getting segfaults
02:07:48 <Quadrescence> This is going to be a nightmare in debugging.
02:07:54 <dolio> The docs for pseq says that the compiler doesn't do the same transformations on it as it does to seq.
02:08:04 <Quadrescence> _Dae_: wat.
02:08:06 <_Dae_> Quadrescence: ghci is your friend
02:08:25 <|Steve|> It worked quite well for grading my students' homework today. I stashed some HUnit tests into main and ran runhaskell -- -istudent_name -- PA4Tests.hs Worked great.
02:08:41 <vixey> haha
02:08:55 <codacola> _Dae_: well im using haskell and vista, but no idea about gcc :P
02:09:14 <_Dae_> codacola: gcc = -fvia-C :p
02:09:36 <Quadrescence> |Steve|: This is my first ever (partial) program in haskell, 300 lines in 4 modules. :<
02:10:12 <Quadrescence> But, here goes nothing.
02:10:12 * codacola had to write a small package thing for dealing with large numbers in haskell
02:10:31 <codacola> now its onto a video store database using tuples
02:11:06 <_Dae_> codacola: is that a good idea? shouldn't you be using the database system for that?
02:11:20 <codacola> _Dae_: its a small assignment for my class
02:11:27 <|Steve|> Quadrescence: The only thing I've ever written in haskell that was that long was a PRNG tester that incorporated some horrible algorithms that I got from a paper of DJB.
02:12:08 <_Dae_> codacola: heh, ok, I guess external libs are a bad idea then ;)
02:12:46 <codacola> _Dae_: gotta declare several types (eg a person is a string), and then declare a database type which contains each of the others, and then write a few functions like "findDVDs"
02:13:26 <codacola> im assuming we're using tuples, we're a week into the class and shes given us teh assignment a months early
02:13:30 <codacola> so i figured id get started
02:13:32 <_Dae_> codacola: be glad you're writing haskell then :)
02:14:14 <codacola> ill be glad when we move onto prolog :P
02:14:32 <_Dae_> heh, I doubt that :p
02:14:45 <codacola> whys that?
02:15:06 <vixey> codacola: normal people hate prolog
02:15:21 <codacola> why?
02:15:45 <_Dae_> well... it's main purpose is a language to do something which cannot be done (ie. AI). That has to give it a few personality problems
02:16:21 <codacola> but the concept sounds like fun
02:16:39 <thoughtpolice> hm, it seems that trying to understand the differences between seq and pseq lead me to a ghc bug :)
02:16:54 <erikc> prolog is great
02:17:16 <codacola> see, erikc likes it, and im sure hes quite normal
02:17:17 <yakov_> hey
02:17:43 <|Steve|> I've never actually learned prolog, but it's in the course syllabus, so I guess I'd better learn it if I want to teach it. =)
02:17:45 <_Dae_> codacola: he's on #haskell ... Normal is hardly the defining quality in here
02:17:55 <codacola> heh
02:18:06 <erikc> although prolog is sorta like logic programming's lisp
02:18:12 <codacola> well there ya go, that means im allowed to like it and be as normal as anyone else here :P
02:18:17 <erikc> mercury is logic programming's haskell
02:18:34 <erikc> well, i guess curry is more like logic programming's haskell
02:18:40 <codacola> |Steve|: CS lecturer?
02:18:52 <kryptiskt> how can I permanently change the default directory where cabal-install puts libs?
02:19:05 <erikc> either way, ive been trying to sell prolog as a rule language for a game engine unsuccessfully for the last 6 months
02:19:17 <kryptiskt> so i dont have to use --prefix
02:19:25 <erikc> people really dont like it :)
02:19:26 <|Steve|> codacola: Nah, just a lowly grad student TA.
02:19:37 <codacola> ah
02:19:49 <Quadrescence> Why would this be giving me a parse error? data ColIdx = UCol | RCol | FCol | DCol | LCol | BCol | XCol
02:20:00 <mauke> Quadrescence: because you're doing it in ghci
02:20:31 <Quadrescence> I am just doing runhaskell Main.hs
02:20:33 <Quadrescence> :<
02:20:41 <codacola> my evil lecturer called winhugs "dumb" :(
02:20:44 <_Dae_> codacola: perhaps I'm just inclined not to use old languages. They all seem to suffer from design desicision that I could do without
02:20:57 <_Dae_> codacola: well.... ghci -is- better....
02:21:04 <|Steve|> > let data ColIdx = UCol | RCol | FCol | DCol | LCol | BCol | XCol
02:21:05 <lambdabot>  Parse error at "data" (column 5)
02:21:43 <mauke> Quadrescence: then something else is wrong
02:22:00 <|Steve|> hugs is slow.
02:22:50 <vixey> erikc: What do you mean? You own a commercial implementation or something?
02:23:09 <erikc> oh, no, as a concept
02:23:13 <erikc> instead of lua
02:23:24 <vixey> erikc: oh.. I've tried that too in that case :)
02:25:34 <vixey> erikc: lua is not so bad
02:25:47 <vixey> erikc: You could probably embed any concepts from Prolog into lua
02:26:57 <erikc> lua's ok, but its been a bit of a mess getting the gc to behave on consoles
02:26:57 * vixey did this in haskell
02:27:09 <vixey> oh what consoles ?
02:27:13 <erikc> ps3 and psp
02:27:19 <vixey> ooh
02:27:37 <erikc> and in the ps3's case there isnt really a path to move lua code to the spus
02:27:40 <vixey> if you get Prolog on a PS3 that would be so cool :D
02:27:45 <ski> prolog is fun
02:27:58 <erikc> whereas prolog could maintain its fact predicates in contiguous memory tables
02:28:06 <erikc> which would stream nicely
02:28:56 <_Dae_> erikc: Doesn't the new Civilization game use lua and python on ps3?
02:29:02 <erikc> yea
02:29:17 <erikc> but it isnt a 60 fps action game :)
02:29:26 <codacola> i know civ iv uses prolog (though unsure what the newest civ is)
02:29:40 <vixey> really ? :o
02:29:46 <ejt> civ iv uses python
02:29:46 <_Dae_> codacola: civ4 uses lua.... it tells you so when you start it :p
02:29:52 <codacola> oops
02:29:55 <codacola> sorry, python
02:29:57 <ksandstr> why on earth would you want to run a language that's used to specify high-level game events etc. on an exotic SIMD processor
02:30:09 <codacola> and yeah, says python when its starting
02:30:18 <ksandstr> that's like... unix on a cray...
02:30:22 <_Dae_> erikc: Well... that depends on how you play it
02:30:23 <erikc> ksandstr: cause they sit idle a lot
02:30:44 <name> wow civ uses python? neat
02:31:02 <ksandstr> erikc: i'd bet the powerpc unit (which I think is a 2-thread SMT unit too) sits idle quite enough
02:31:18 <erikc> we are bottlenecked on the powerpc unit
02:31:22 <erikc> :\
02:31:40 <_Dae_> what game is it? :)
02:31:57 <ksandstr> i mean, an interpreted language on a SIMD unit sounds like the worst possible match ever
02:32:00 <erikc> socom confrontation
02:32:16 <ksandstr> given that the cell SPUs don't have branch prediction, at all
02:32:20 <codacola> The game uses boost.python to allow the Python programming language access to many parts of the game (including the style and content of all interface screens). Python can also be used to modify random map generation and to add complex scripted events.
02:32:23 <erikc> ksandstr: oh, agreed
02:32:25 <codacola> from wikipedia
02:33:03 <erikc> ive been working on a more limited prolog (no higher order goals)
02:33:09 <erikc> that is more like sql
02:33:15 <erikc> that would run there
02:33:35 <vixey> erikc: in C ?
02:33:38 <erikc> yea
02:34:11 <shepheb> Oblivion has some IronPython-based scripts and such, too. one reason why both Civ4 and Oblivion are modded like crazy
02:37:21 <Cale> shepheb: Is it really IronPython?
02:38:15 <shepheb> it has an IronPython.dll in. though there's a chance that's part of one of my absurd number of mods
02:40:55 <Cale> Oh, hmm...
02:45:47 <vixey> why do people write these brilliant papers about programming and not release them?
02:46:08 <erikc> which papers?
02:46:17 <ksandstr> stuffy publication culture?
02:46:30 <Cale> vixey: oh?
02:46:36 * vixey was sort of generalizing but mostly yokoyamas stuff
02:46:47 <Cale> vixey: He writes papers that he doesn't publish?
02:47:00 <vixey> well they are on ACM but normally people can't access that
02:47:23 <Cale> Anything in particular you'd like?
02:47:55 <vixey> well I am just wondering why this happens
02:48:09 <Cale> (I can access ACM articles)
02:48:28 <Cale> It happens because publishing companies are greedy and unchecked.
02:48:46 <hml> how do i get hosting at code.haskell.org?
02:48:47 <vixey> what does unchecked mean?
02:49:10 <_Dae_> yeah... most articles are not freely avaialbe. I only knew of a few journals that allow everyone access
02:49:14 <erikc> Cale, if you are feeling generous, can you grab me Francois Bancilhon, David Maier, Yehoshua Sagiv, Jeffrey D Ullman. Magic sets and other strange ways to implement logic programs (extended abstract). Proceedings of the fifth ACM SIGACT-SIGMOD symposium on Principles of database systems, March 24-26, 1986, Cambridge, Massachusetts. ? :)
02:49:15 <Cale> Means that there's nobody stopping them from doing whatever they like :)
02:49:26 <vixey> oh I see
02:49:49 <thoughtpolice> hml: check http://community.haskell.org
02:49:49 <lambdabot> Title: Haskell Community Server
02:50:10 <Cale> vixey: Really, by now the universities should do something about the problem of these annoying middlemen.
02:50:13 <ExplicitCall> hi, all.  are there any implementation of regular expressions in haskell, that support backreferences?
02:50:36 <Cale> vixey: But up until the internet existed, publishing and distribution required specialised resources.
02:50:46 <ejt> ExplicitCall: I think there's a pcre module
02:51:00 <vixey> Cale, oh that sort of makes sense, about how things are like this now
02:51:06 <vixey> inertia ... I guess
02:51:16 <Cale> Similar to the music industry, I suppose.
02:52:03 <Cale> erikc: http://cale.yi.org/autoshare/p1-bancilhon.pdf -- that what you're looking for?
02:52:04 <lambdabot> Title: cache:http://cale.yi.org/autoshare/p1-bancilhon.pdf - Google Search
02:52:26 <Cale> huh, interesting title :)
02:52:39 <ExplicitCall> ejt, yes, but while Text.Regex.PCRE is imported, "abab" =~ "([ab]+)\1" :: Bool still gives False.  maybe it is because of wrong format of backreference or of some other reason?
02:52:45 <erikc> yup, thats the one, thanks man :)
02:53:09 <_Dae_> is there any haskell editor which autocompletes? Like, I write z and it suggest zip, zipWith, etc?
02:53:29 <ExplicitCall> _Dae_, emacs.
02:54:05 <mauke> ExplicitCall: "\1" is [chr 1]
02:54:12 <_Dae_> ExplicitCall: Really? I'm using emacs....
02:54:16 <ExplicitCall> mauke, ah, thanks
02:54:41 <ExplicitCall> _Dae_, C-TAB gives me autocompletion, at least in GNU/Emacs.
02:55:42 <_Dae_> ExplicitCall: I'm using gnu/emacs, it claims c-tab is undefined.... maybe it's a nifty extension?
02:57:31 <elbar> _Dae_,  is that for you? http://www.haskell.org/haskell-mode/
02:57:31 <lambdabot> Title: Haskell Mode for Emacs
02:57:31 <quicksilver> C-tab isn't bound by any haskell emacs mode I know of.
02:57:45 <quicksilver> I use M-/ which is a pretty dumb completion mode but works OK.
02:58:44 <_Dae_> elbar: already using it :) Just wondered if there was something smarter. Once your projects grow big enough, it's annoying having to check the names all the time
02:59:57 <_zenon_> _Dae_, ghci can autocomplete for you as well :)
03:00:22 <_Dae_> _zenon_: heh, exactly, but you can't really use ghci as your editor ;)
03:00:32 <_zenon_> _Dae_, true.
03:00:49 <_Dae_> I guess extending yi to do it should be possible
03:01:13 <quicksilver> it's an explicit goal of yi to support things like that
03:02:28 <erikc> haskell intellisense would be really nice, the intellisense for f# in vstudio is absolutely sick
03:02:55 <quicksilver> it's harder than most people think
03:03:09 <quicksilver> unfinished lines of haskell code are much more difficult than unfinished lines of C++ code
03:03:21 <quicksilver> in terms of trying to guess the type at the cursor
03:03:32 <quicksilver> because of infix operators, basically.
03:04:14 <quicksilver> (I mean the same is true of C++ but infix use is C++ is typically much more limited and a special-case hack for << is not hard)
03:05:41 <ejt> take comfort in the fact that you have to write much leess code in Haskell than Java
03:05:59 <vixey> java ?
03:06:06 <_Dae_> quicksilver: well, even a dumb version, that didn't filter by types would be ok
03:06:06 <vixey> what
03:06:30 <vixey> I don't think anybody was comparing haskell to java
03:06:43 <ejt> oh, I thought intellisense was a java IDE
03:06:52 <_Dae_> ejt: I'm not sure that is -always- true, but mainly because of the giant java library
03:06:59 <erikc> yea, i think the thing i found most impressive in f#'s vstudio support  was writing a few screens of code with no types and then hovering over anything showed the right type
03:07:17 <_Dae_> ejt: intellisense is a visual studio thing, but Netbeans and eclipse have something similar
03:07:28 <dibblego> it is always true, mainly because of the pathetic Java library
03:07:32 <mauke> .oO( IntelliJ )
03:07:34 <ejt> y, I've seen it in eclipse and it's impresive
03:07:38 <vixey> erikc: I've not used that tool but with haskell I usually have a file with no types and then check things with :t in ghci
03:07:44 <_Dae_> erikc: but f# has explicit types, right?
03:08:10 <erikc> its an ML dialect, it type inferences
03:09:32 <_Dae_> dibblego: that's hardly fair nor true
03:09:48 <dibblego> it's fair and true
03:09:50 <vixey> yeah, Java has AWT!
03:10:37 <dibblego> I wrote part of java.security in the IBM implementation
03:11:04 <erikc> ottawa lab?
03:11:07 <dibblego> it's worse than AWT :)
03:11:12 <dibblego> no, Gold Coast, Australia
03:11:23 <erikc> ah
03:11:23 <dibblego> I no longer work for the filth
03:11:26 <erikc> hehe
03:11:28 <erikc> me neither :)
03:11:48 * ejt currently has a contract at IBM :(
03:12:35 <erikc> keeping their fortran compiler humming was a lost cause :)
03:12:35 <_Dae_> dibblego: I'm not saying the library is better for everything, but things like gui design is still easier in java.
03:12:41 <erikc> woo, fortran 2003, now with OBJECTS
03:12:50 <vixey> _Dae_: Than?
03:12:52 <dibblego> _Dae_, the Java GUI library is the worst GUI library I have seen in my life
03:13:04 <dibblego> please show me what it is easier than
03:13:23 <dibblego> (btw, I blame IBM for this repetition of myth, hence my disdain)
03:13:24 <ksandstr> every widget library that requires you to specify widget coordinates and shape explicitly
03:13:27 <_Dae_> haskell was the inferred comparison here
03:13:34 * dibblego lols
03:15:14 <_Dae_> *shrugs* to each their own I guess
03:15:33 <dibblego> I'm not prepared to put the energy into that argument, sorry :)
03:17:24 <Associat0r> didn't the haskell mode of VS have intellisense?
03:17:28 <_Dae_> dibblego: heh, that's ok. I'm not really either
03:17:38 <dolio> Worse than MFC?
03:17:52 <dibblego> dolio, yes it's even worse than that
03:17:58 <dolio> Man.
03:19:06 <quicksilver> _Dae_: you get dumb completion with M-/
03:19:09 <quicksilver> if you're not fussed about types
03:19:12 <quicksilver> I find it works fine.
03:20:10 <Quadrescence> Can a function "return" more than one type depending on the inputs?
03:20:32 <Quadrescence> (using guards)
03:20:42 <Associat0r> http://www.haskell.org/visualhaskell/
03:20:43 <lambdabot> Title: Visual Haskell
03:20:44 <conal> Quadrescence: the type of the result cannot depend on the value of the argument.
03:20:51 <dolio> If you give it a sum type as the return type.
03:20:57 <ksandstr> or Dynamic
03:21:36 <ndmitchell> Quadrescence: have you seen Either? It gives you some of what you want
03:21:59 <Quadrescence> I'll look.
03:22:34 <ndmitchell> although, most likely, if you want to return two different types you probably want to have two functions
03:23:01 <ndmitchell> if you hpaste the code as you would like to write it, even though it doesn't work, we may be able to suggest a better way
03:23:03 <Quadrescence> No, no. I want to return just one thing.
03:23:14 <ndmitchell> just of different types?
03:23:27 <ksandstr> it's not "just one thing" if it can have different types
03:23:31 <Quadrescence> Yes. Kind of like "Maybe", to avoid any mishaps.
03:29:03 <mjrosenb> Quadrescence: Either?
03:29:03 <dolio> Man, C++ is getting user-defined literals.
03:31:24 <conal> _Dae_: i think the reason gui programming is usually awkward in haskell is that guis are being conceptualized imperatively.
03:31:24 <titusg> I am trying to translate a perl script that posts a form to a webservice to Network.Curl, but the form isn't being sent in the same way
03:32:09 <titusg> http://hpaste.org/9063
03:32:21 <titusg> http://hpaste.org/9064
03:32:31 <conal> _Dae_: which is an old habit that can be hard to shake off
03:36:20 <dolio> conal: Your google talk was pretty interesting. The comment of (most?) visual programming languages being inherently first-order crystalized a problem I have with the limited experience I have with them.
03:37:00 <conal> dolio: glad to hear it :)
03:38:11 <mjrosenb> conal: is this talk publicly available?
03:38:13 <mjrosenb> i remember seeing a paper on visual type checking
03:38:23 <mjrosenb> it seemed like non-bullshit work
03:38:45 <conal> mjrosenb: yes. see http://conal.net/blog/posts/tangible-functional-programming-a-modern-marriage-of-usability-and-composability/
03:38:47 <lambdabot> Title: Conal Elliott ª Tangible Functional Programming: a modern marriage of usability  ..., http://tinyurl.com/5vrmhu
03:40:57 <conal> mjrosenb: if you think of the ref for that visual type checking paper, please let me know.
03:41:45 <mjrosenb> ttp://www.cee.hw.ac.uk/Staff/greg.htm
03:41:51 <quicksilver> conal: I thin it's incongruous to have 'in haskell' in that sentence.
03:41:59 <mjrosenb> the name of the paper is
03:42:02 <mjrosenb> A visualisation of polymorphic type checking
03:42:16 <quicksilver> conal: the GUI interfaces in haskell which people typically use are slightly sugared up versions of the C/C++ APis
03:42:27 <quicksilver> conal: so any awkward ness should be language independent awkwardness :)
03:43:45 <mjrosenb> hrmm, that page seems to not be working
03:43:51 <mjrosenb> guess he graduated
03:44:42 <mjrosenb> google says http://citeseer.ist.psu.edu/jun98visualisation.html
03:44:44 <lambdabot> Title: A Visualisation of Polymorphic Type Checking - Jun, Michaelson (ResearchIndex)
03:46:40 <conal> quicksilver: mostly awkward due to the imperative paradigm itself
03:46:57 <conal> quicksilver: though haskell's support for imperative programming is less direct than most.
03:48:15 <quicksilver> conal: I don't find a given imperative problem is ever harder in haskell than it would be in C++ or Java
03:48:22 <quicksilver> conal: whilst, very often, I find it's easier in haskell.
03:48:41 <quicksilver> (in particular reference to using imperative GUI libraries like opengl or wxwidgets)
03:49:16 <conal> quicksilver: off the point i was suggesting, which is that to make gui programming substantively more elegant, i'd suggest kicking the imperative habit (including in haskell)
03:49:59 <conal> quicksilver: and i agree: first class effectful computations are handy.
03:50:15 <conal> though not nearly as semantically simple as functional programming.
03:51:39 <conal> so the difference between imperative programming in haskell vs C/Java is in the noise, for me -- compared with the difference between imperative and functional programming.
03:52:12 <vixey> is there realy hope to program GUIs in an elegant way?
03:52:21 <conal> vixey: sure
03:53:10 <conal> vixey: it requires changing one's perspective on GUIs
03:56:45 <Cale> C/Java requires less noise? :P
03:56:49 <Cale> or more?
03:57:58 <mattr__> question for the hive mind - how do you access your Haskell documentation?
03:58:05 <Cale> mattr__: Firefox.
03:58:06 <mjrosenb> vixey: everything should be programmed in an elegant way.
03:58:11 <mattr__> ghc -e ":b"?
03:58:13 <dcoutts> kryptiskt: edit the ~/.cabal/config
03:58:13 <mattr__> hoogle?
03:58:19 <mjrosenb> mattr__: conkeror
03:58:31 <vixey> not everything should be programmed
03:58:42 <Cale> mattr__: I have a tree of bookmarks which mimics the GHC module tree.
03:58:51 <therp> is there anything more readable than Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire?
03:58:54 <mattr__> Cale: nice
03:59:00 <Cale> I wish there were an automated tool to construct it :)
03:59:06 <mattr__> so do I
03:59:10 <mattr__> can I have yours?
03:59:31 <mattr__> that sounds like a wonderful resource :)
03:59:36 <mjrosenb> therp: many things
03:59:51 <therp> mjrosenb: can you name a few?
03:59:52 <mjrosenb> therp: i've heard that harry potter is particularly readable
04:00:00 <therp> ah alright. next.
04:00:04 <mjrosenb> therp: do you want anything more specific?
04:00:04 <mattr__> do most cabal packages have documentation in them>
04:00:05 <mattr__> ?
04:00:09 <mattr__> I should check that out
04:00:37 <vixey> therp, The book Algebra of Programming
04:00:39 <_Dae_> vixey: are you suggesting flash is the answer to guis?
04:01:07 <mattr__> I need an offline version as well - perhaps I need to do some web-trawling if that is how others are doing it.
04:01:08 <vixey> _Dae_: yes and no
04:01:14 <dcoutts> mattr__: not contained inside the tarball, but hackage generates haddock docs and you can do that locally too.
04:01:36 <mauke> someone needs to make a toolkit called "Hay"
04:01:39 <mauke> then I can write Hay GUIs
04:01:51 <_Dae_> vixey: as in "yes to the idea" and "no to the implementation"?
04:02:27 <_Dae_> mauke: I presume that would mainly consist of straws?
04:02:52 <mattr__> nice
04:02:58 <mattr__> dcoutts: thanks
04:03:17 <therp> vixey: sounds interesting. thanks
04:03:24 <quicksilver> conal: agreed. I was objecting to your linking the inexpressiveness of GUIs and their use in haskell.
04:03:30 <quicksilver> conal: I think you really agree with me :)
04:03:56 <quicksilver> IMO there are two points: (1) standard imperative GUIs are frustrating. (2) Merely using haskell does not solve (1).
04:04:08 <quicksilver> but merely using haskell doesn't make (1) any worse either
04:05:08 <conal> quicksilver: really awkwardness rather than expressiveness.  and yes, i agree that throwing a more sophisticated imperative language (Haskell+IO) doesn't address the fundamental problem.
04:05:47 <conal> s/throwing/applying
04:05:52 <mjrosenb> so with a gui, there is a fundamental sense of time, and an ordering of events that you need to deal with
04:06:06 <vixey> is there a haskell library with a C AST -> String function?
04:06:16 <mjrosenb> which needs strict evaluation if not imperativeness
04:06:46 <mjrosenb> vixey: that sounds .... hard
04:06:47 <conal> mjrosenb: i hope you're not too sure about that conclusion since i doubt you'll find an elegant answer from there.
04:07:02 <_Dae_> mjrosenb: there is an order of events, surely. But a sense of time?
04:07:03 * robyonrails ... gli occhi sgranati a sentir quei si... tra il piacere e il terrore... l'odio e l'amore.. e termin√≤ troppo presto quel gioco crudele d'agosto..
04:07:18 <vixey> I meant, a library with some data type for C programs and a printer that outputs valid C code from it
04:07:32 <conal> vixey: i bet there is such a thing
04:07:43 <mjrosenb> conal: when you're as tired as i am, you can convince yourself that you wrote the haskell spec
04:08:07 <dolio> That's pretty tired.
04:08:12 <conal> mjrosenb: :)
04:09:01 <vixey> I guess it's not in GHC ?
04:09:03 <vixey> or hackage
04:09:22 <dolio> Someone's working on Language.C this summer.
04:09:35 <dolio> I imagine it will pretty print.
04:09:48 <conal> Language.C -- that's what i was trying to remember
04:10:11 <mattr__> dcoutts: cabal-install would be very helpful for getting cabal-install (look at all those dependencies!) :)
04:10:21 <vixey> it looks like it does http://bene.sivity.net/autodocs/language-c/
04:10:22 <lambdabot> Title: language-c-0.3: C99 Parser Library
04:10:25 <vixey> (have a pretty printer)
04:10:48 <dcoutts> mattr__: heh. Well there are only 2 deps really. You've got all the others installed already probably.
04:11:02 <vixey> I guess the code is not around ..
04:11:10 <mattr__> dcoutts: :)
04:11:31 <vixey> oh http://code.haskell.org/language-c/
04:11:32 <lambdabot> Title: Index of /language-c
04:16:51 <vixey> how do you use hierarchical modules?
04:17:01 <vixey> it says here
04:17:02 <vixey>     Could not find module `Language.C.Parser.Parser':
04:17:02 <vixey>       locations searched:
04:17:02 <vixey>         Language/C/Parser/Parser.hs
04:17:02 <vixey>         Language/C/Parser/Parser.lhs
04:17:13 <vixey> oh
04:17:34 <vixey> I think that I just didn't compile the Parser.y into a Parser.hs file
04:23:24 <FordCortina> can anybody give me some hints on writing a type-level `And` function?
04:23:25 <FordCortina> http://hpaste.org/9065
04:23:58 <FordCortina> i was just wondering if i it is possible to express it at that level of conciseness
04:24:08 <vixey> FordCortina: this doesn't make sense
04:24:14 <FordCortina> or do i have to treat every case?
04:24:47 <EvilTerran> i think you have to at least treat as many cases as the definition of (&&)
04:24:54 <EvilTerran> ?src (&&)
04:24:55 <lambdabot> True  && x = x
04:24:55 <lambdabot> False && _ = False
04:25:27 <FordCortina> yeh same number of cases
04:25:28 <EvilTerran> instance TAnd TTrue a a; instance TAnd TFalse a TFalse -- something like that might work
04:25:33 <FordCortina> just a different way
04:25:40 <FordCortina> ill try again
04:25:46 <EvilTerran> the thing is, yours overlap, i think
04:25:50 <FordCortina> yeh
04:25:55 <EvilTerran> yeah, on the fundep
04:26:08 <conal> on guis again, i'll go further and suggest that gui programming is difficult mainly because the imperative paradigm is such a mismatch with the problem.
04:26:11 <EvilTerran> mine don't, because of the TTrue/TFalse in the first positio
04:26:16 <vixey> FordCortina, http://hpaste.org/9065#a1
04:26:56 <vixey> FordCortina, Is there something more than this you are trying to express?
04:26:58 <FordCortina> vixey: yep. that's what i call "treating every case"
04:27:00 <EvilTerran> vixey, any particular reason for the "where"s? you can leave them off
04:27:02 <FordCortina> although
04:27:08 <FordCortina> its probably more concise haha
04:27:09 <EvilTerran> iiirc
04:27:40 <vixey> EvilTerran: cool
04:27:50 <vixey> I didn't know you could leave that out
04:28:36 <vixey> FordCortina: You want to give a partial specification and have GHC fill in the gaps based on something? (if so, what?)
04:28:52 <hackage> Uploaded to hackage: sphinx 0.2
04:29:19 <quicksilver> conal: yes, I still agree :)
04:29:27 <FordCortina> vixey: i reckon you can get ghc to make the inferences with constraints and fundeps
04:29:43 <quicksilver> conal: although after a few false starts I'm not sure your simple reactive paper is going to be a magic bullet :)
04:29:44 <vixey> FordCortina: what inferences?
04:29:53 <quicksilver> conal: it may just be I haven't grokked it  yet.
04:30:08 <conal> quicksilver: magic bullet for what?
04:30:09 <FordCortina> vixey: ill work this out....
04:30:23 <FordCortina> vixey: and let you know if it works
04:30:24 <vixey> FordCortina: OK.. since I don't really understand what it is you're trying to do
04:31:44 <conal> quicksilver: it's a pretty dense paper.  enough new ideas for 3 or 4 papers.  it didn't get into icfp, so i'll be reworking it.
04:32:13 <EvilTerran> FordCortina, vixey: http://hpaste.org/9065#a2
04:32:22 <quicksilver> conal: magic bullet for a better model of GUIs
04:32:42 <quicksilver> conal: I've tried to work some of your ideas into something I was writing but I got a bit burnt out and tangled up.
04:32:54 <quicksilver> I'll keep trying and let you know if I get something I'm happy with.
04:33:20 <conal> quicksilver: more a question about FRP than Reactive, perhaps.
04:33:22 <FordCortina> EvilTerran: ooh, thanks i didnt know about the TypeFamilies extension :D
04:33:36 <conal> quicksilver: i expect it'll get into a lot better shape this summer, with examples and performance.
04:33:44 <EvilTerran> FordCortina, yeah, type families are new wit h6.8
04:33:50 <EvilTerran> http://www.haskell.org/haskellwiki/GHC/Indexed_types
04:33:54 <lambdabot> Title: GHC/Type families - HaskellWiki
04:33:57 <vixey> FordCortina: Why are you using type families?
04:34:03 <vixey> instance And True e e -- -XFlexibleInstances
04:34:03 <vixey> instance And False x False
04:34:12 <mattr__> hooray for cabal upgrade :)
04:34:13 <EvilTerran> or indeed http://www.haskell.org/haskellwiki/GHC/Type_families
04:34:14 <lambdabot> Title: GHC/Type families - HaskellWiki
04:34:20 <vixey> (this definition is silly though, the longer one is better)
04:34:22 <EvilTerran> dunno why i ended up at the first link
04:34:33 <EvilTerran> vixey, er, i'm the one using type families
04:34:42 <quicksilver> conal: yes. Well I tried to copy your separation of the discrete events and the continuous behaviour
04:34:43 <vixey> EvilTerran: why?
04:34:50 <EvilTerran> why not?
04:34:54 <frevidar> I've got a function that recursively calls a function which as a result gives an array. I'm trying to get ghc to eliminate the intermediate arrays. See http://hpaste.org/9066 for an example
04:34:58 <EvilTerran> type families are almost exactly type-level functions
04:35:01 <vixey> well .. it seems pointless
04:35:02 <quicksilver> conal: but I ended up with some difficulty with all the different parts of my program which could 'send events'
04:35:04 <EvilTerran> which is exactly what type-level (&&) is
04:35:09 <quicksilver> conal: felt like I needed some kind of GUI event pump.
04:35:20 <vixey> why is a function better than a relation?
04:35:25 <vixey> it's got less uses
04:35:30 <conal> vixey: it's not better
04:35:31 <EvilTerran> it's easier on the eyes
04:36:07 <EvilTerran> often, using a more specific abstraction can make things clearer
04:36:09 <EvilTerran> i find
04:38:28 <EvilTerran> with the type family version, i think you get inference rules equivalent to the fundep "class (a :&&: b) c | a b -> c"
04:38:43 <vixey> that fundep just makes && less useful
04:38:57 <_Dae_> frevidar: what you're writing isn't tail recursive, which is your problem
04:38:59 <EvilTerran> how?
04:39:13 <EvilTerran> it expresses the restriction that :&&: is a function proper
04:39:25 <mattr__> dcoutts: why doesn't cabal haddock take a package name as a parameter?
04:39:26 <vixey> && is a relation between 3 booleans
04:39:46 <EvilTerran> it means that you can say (a :&&: b) and it'll actually be able to work out what the type of c is
04:39:50 <EvilTerran> *type c
04:39:57 <EvilTerran> i'd call that pretty darn useful
04:39:58 <dcoutts> mattr__: it applies to the local unpacked package
04:40:18 <mattr__> but when I am using cabal I am never in the local upacked package
04:40:20 <mattr__> am I?
04:40:27 <EvilTerran> or, rather, "(TRUE :&&: FALSE) c =>" or whatever
04:40:28 <frevidar> _Dae_: why does that matter?
04:40:40 <Philippa> vixey: you do realise that one of the constraints here is that there /must not be/ multiple valid solutions, right?
04:40:49 <EvilTerran> vixey, it's a relation that is also a function proper from (a,b) to c
04:40:50 <dcoutts> mattr__: developers can use it too for their source packages
04:40:52 <FordCortina> vixey: is your version of `And` a "relation"?
04:40:55 <frevidar> _Dae_: I'm only passing an integer each call
04:41:07 <_Dae_> frevidar: because when it's not tail recursive, it has to keep your arrays, all the way through
04:41:08 <EvilTerran> telling the compiler this means it can infer more than it could otherwise
04:41:12 <mattr__> cabal install has been squirrelling them all away somewhere for me, so I need to find out where I guess
04:41:13 <EvilTerran> which is somewhat helpful
04:41:13 <mattr__> off I go
04:41:14 <frevidar> _Dae_: and the call stack is only a few thousand deep
04:41:23 <frevidar> _Dae_: why does it keep the arrays?
04:41:35 <dcoutts> mattr__: you're looking for the #1 missing feature
04:41:47 <mattr__> nice
04:41:51 <frevidar> _Dae_: why not deallocate the array created from pascal 0 after pascal 1 is complete?
04:41:56 <dcoutts> mattr__: http://hackage.haskell.org/trac/hackage/ticket/206
04:41:58 <lambdabot> Title: #206 (cabal-install should be able to generate haddock docs) - Hackage - Trac
04:42:01 <mattr__> so I should help add it then I guess
04:42:05 <mattr__> :)
04:42:35 <mattr__> dcoutts: I see you already have it :)
04:42:42 <_Dae_> frevidar: haskell is lazy, it's not actually gonna calculate anything till the end
04:42:57 <Philippa> vixey: unless you can prove that two instances are equivalent - and haskell can't - allowing more than one valid solution gives you a complete mess at runtime. So the typeclass system is designed around that and that is why we have fundeps&co
04:42:57 <dcoutts> mattr__: we have the ticket but nobody has implemented it yet
04:43:17 <frevidar> _Dae_: How do I make it less lazy here?
04:44:36 <frevidar> and what do you mean by "til the end"?
04:45:08 <_Dae_> frevidar: change the line to otherwise = seq a ((a ! (i - 1)) + (a ! i))
04:45:19 <frevidar> _Dae_: whether it calculates at the start or the end doesn't stop the fact that it needs to complete pascal 0 before it completes pascal 1
04:45:57 <_Dae_> frevidar: frevidar, indeed it doesn't, but what it wil actually store is -how- to compute the whole thing
04:46:29 <vixey> so I change it to,
04:46:29 <vixey> data TRUE = T
04:46:29 <vixey> data FALSE = F
04:46:41 <_Dae_> frevidar: http://www.haskell.org/haskellwiki/Haskell/Lazy_evaluation
04:46:41 <vixey> but this,  t = T :: (TRUE :&&: FALSE)  doesn't typecheck
04:46:42 <lambdabot> Title: Haskell/Lazy evaluation - HaskellWiki
04:47:32 <vixey> what is the purpose of the type family?
04:49:47 <frevidar> _Dae_: that change doesn't seem to help
04:50:28 <frevidar> _Dae_: pascal 2500 +RTS -sstderr is still using 58megs of memory
04:51:19 <frevidar> _Dae_: (as in, maximum residency
04:51:37 <quicksilver> frevidar: where's your code?
04:52:01 <vixey> I don't understand it
04:53:09 <frevidar> quicksilver: my code is: http://hpaste.org/9066
04:53:19 <frevidar> with the changes _Dae_ suggested: http://hpaste.org/9067
04:53:42 <quicksilver> what kind of 'n' are you using?
04:53:49 <frevidar> 2500
04:54:10 <frevidar> it starts to thrash a bit using 3000
04:55:00 <quicksilver> well it is generating a *lot* of arrays
04:55:05 <quicksilver> and then gc'in them immediatley
04:55:10 <quicksilver> that's going to churn a lot.
04:55:14 <EvilTerran> vixey, that shouldn't typecheck, should it?
04:55:38 <frevidar> quicksilver: but it only ever needs to keep two
04:55:56 <frevidar> quicksilver: the one its working on, and the previous one
04:55:58 <quicksilver> frevidar: when yo generate pascal n
04:56:14 <quicksilver> you generate n-2 copies of pascal (n-1)
04:56:24 <quicksilver> and (n-2)(n-3) copies of pascal (n-2)
04:56:25 <quicksilver> etc.
04:56:30 <quicksilver> this is not very efficient algorithm :P
04:56:44 <FordCortina> i think this was the difinition i had in mind :) http://hpaste.org/9065#a3
04:56:46 <frevidar> quicksilver: how?
04:56:54 <EvilTerran> vixey, if you add in a class TypeBool a where reify :: a -> Bool; instance TypeBool TRUE where reify = True; instance TypeBool FALSE where reify = False
04:56:55 <FordCortina> i take prize for longest code :D
04:57:05 <quicksilver> frevidar: because each call to pascal (n) is generating it's own private copye of pascal (n-1)
04:57:27 <frevidar> quicksilver: yes
04:57:35 <frevidar> quicksilver: but only one copy
04:57:41 <quicksilver> oh.
04:57:53 <quicksilver> sorry, you're right.
04:57:58 * quicksilver thinks harder
04:58:11 <EvilTerran> then reify (undefined :: AND TRUE FALSE a => a) will give you an ambiguous type error with no fundep
04:58:19 <quicksilver> well the reason it doesn't only need 2 arrays at a time is because arrays are not value-strict
04:58:24 <quicksilver> they are lazily evaluated
04:58:56 <EvilTerran> but it'll work with the fundep, and (undefined :: TRUE :&&: FALSE) will also work with no added magic
05:00:02 <EvilTerran> without the added inference information provided by the fundep or type family, the type inferrer can't tell there'll never be, say, an "instance AND TRUE FALSE Integer"
05:01:30 <quicksilver> frevidar: you might try UArray since they are element-strict.
05:01:34 <_Dae_> quicksilver: a thought, would UArray fix that?
05:01:44 <_Dae_> quicksilver: nevermind... :p
05:01:46 * EvilTerran annotates with exactly what he would write if he were doing this himself - http://hpaste.org/9065#a4
05:03:05 <EvilTerran> you'd run into the same problem if you're using something at the type-level that expects a TRUE or FALSE, but you give it the result of your type-level &&
05:03:20 <quicksilver> frevidar: on my machine yours overflows Int at the 31s row anyway :P
05:03:23 <EvilTerran> you don't need that method to get the problem, it just illustrates it
05:03:29 <EvilTerran> *that class method
05:04:15 <frevidar> quicksilver: yeah, I know, thats not really the point. I could of used integers but it would complicate things I thought
05:04:38 <frevidar> quicksilver: in my real code, I'm actually using [: :] arrays
05:04:52 <frevidar> quicksilver: you know, parallel arrays
05:05:04 <quicksilver> frevidar: that code completes for me in about 1.3seconds, for the 2500'th row
05:05:09 <quicksilver> that seems quite reasonable to me.
05:06:16 <frevidar> quicksilver: I know ghc only supports the syntax at the moment, but I figured I might as well write it that way for the future
05:07:02 <quicksilver> frevidar: UArray speeds it up and drops memory usage for me.
05:07:19 <_Dae_> frevidar: you could very easily make this code parallel without par arrays
05:07:26 <quicksilver> memory usage drops from 200Mb to 59Mb
05:07:26 <roconnor> Ugh, I my coq extracted code segfaults in Haskell :(
05:07:29 <quicksilver> for 3500
05:08:05 <FordCortina> EvilTerran, vixey: thanks for your comments
05:08:11 <frevidar> quicksilver: is the memory usage bounded?
05:08:14 <Cale> roconnor: hehehe
05:08:22 <frevidar> quicksilver: like for 10000?
05:08:34 <quicksilver> well of course it won't be.
05:08:36 <dolio> So much for your precious theorem provers!
05:08:37 <frevidar> quicksilver: really, it should be ok to do 10000
05:08:46 <quicksilver> the 10000 array will be 3x the size of the 3500 one :P
05:09:09 <frevidar> quicksilver: how much does a boxed int take?
05:09:13 <vixey> roconnor, it runs fine inside Coq though?
05:09:21 <frevidar> quicksilver: maybe 20 bytes at most?
05:09:23 <roconnor> yes.
05:09:25 <roconnor> :(
05:09:41 <vixey> how many lines of code is the haskell?
05:09:44 <frevidar> quicksilver: the array should still be well less than a megabyte
05:09:51 <quicksilver> frevidar: 10,000 took 396Mb total.
05:10:25 <frevidar> quicksilver: that still looks like O(n^2) space
05:10:29 <quicksilver> sure
05:10:34 <quicksilver> it doesn't GC until it wants to
05:10:37 <_Dae_> frevidar: it should be possible to write the algorithm without the arrays, right?
05:10:39 <frevidar> quicksilver: is that maximum allocation?
05:10:49 <quicksilver> "total memory in  use"
05:10:55 <quicksilver> maximum residency was about half that.
05:11:03 <quicksilver> which is what you expect, given how GC works.
05:11:12 <frevidar> _Dae_: this algorithm, yes. But what I'm really doing is a trinomial probability tree.
05:11:26 <frevidar> _Dae_: this is just a simplistic example of my issue
05:11:31 <_Dae_> frevidar: Riiiight.... I have no idea what that is
05:11:41 <frevidar> _Dae_: thats why I made this example
05:12:18 <_Dae_> frevidar: ok.... but then it's gonna be hard to help you. The answer here is one of two things ST monad, or rewrite the algorithm
05:13:11 <quicksilver> _Dae_: I can't imagine why ST monad would help.
05:13:18 <quicksilver> _Dae_: what makes you think it will?
05:13:20 <roconnor> vixey: I'm not sure maybe 500 lines.  I can check in a moment
05:13:26 <_Dae_> quicksilver: you could do the whole thing in place?
05:13:35 <quicksilver> ah well, that's a different algorithm :)
05:13:41 <quicksilver> sure you could do that.
05:13:52 <_Dae_> not that different....
05:13:56 <quicksilver> but I'm not sure I see a "problem"
05:14:08 <quicksilver> 15 seconds to calculate the 10,000th row of pascal's triangle
05:14:10 <quicksilver> seems fine to me.
05:14:14 <cjs> What's a good way of logging some sort of warning from a pure function? I can recover without breaking, but I'd like to know that it happened, just on the off chance it ever does (it never should).
05:14:20 <quicksilver> for a naive algorithm.
05:15:57 <cjs> I guess Data.Trace.
05:15:57 <ndmitchell> cjs: unsafePerfrormIO
05:15:57 <ndmitchell> or trace
05:15:57 <_Dae_> well, the time is decent, but the memory use is horrible. But I agree, I'm pretty sure any language would use equal amounts of memory if written recursively
05:15:57 <frevidar> quicksilver: what _Dae_ said
05:15:57 <cjs> Yeah, that's better. This is really something I should come back and fix properly, anyway....
05:15:57 <quicksilver> run it in a capped heap, if you care about that.
05:16:04 <quicksilver> there's plenty more that could be GCed quicker than is.
05:16:18 <quicksilver> over-quick GC just slows things down.
05:16:23 <_Dae_> frevidar: or you could move to IO monad and use performGC every time....
05:16:51 <frevidar> _Dae_: I don't think its the garbage collecter collecting not often enough
05:17:12 <frevidar> _Dae_: I think the arrays aren't available to collect
05:17:49 <_Dae_> frevidar: With UArrays that sounds unlikely. But even then, rewrite the whole thing to be tail recursive and you'll be good to go
05:17:52 <frevidar> if the garbage collecter collected, say, every 1 second, there wouldn't be 350megs to collect
05:18:38 <roconnor> vixey: almost 7000 lines of haskell
05:18:38 <frevidar> _Dae_: how do I write it to be tail recursive?
05:18:38 <roconnor> so I was a bit off
05:18:38 <_Dae_> your example? hmm... gimme a second
05:18:45 <roconnor> It must be due to the unsafeCoerce... but they ought to all kinda safe
05:18:58 <quicksilver> I don't understand what tail recursion has to do with this.
05:18:58 <vixey> really :S
05:19:12 <vixey> roconnor: What about the ocaml extraction?
05:19:18 <vixey> It should use Obj.magic
05:19:26 <vixey> I am curious if that also crashes
05:19:48 <roconnor> vixey: ocaml works
05:20:15 <matthew-_> so is there a reason why you can't use back ticks to make a constructor infix?
05:20:15 <vixey> :(
05:20:29 <EvilTerran> er, you can, i think
05:20:33 <vixey> > (7 `Just`)
05:20:34 <dolio> Does the Haskell extractor not get used much?
05:20:48 <lambdabot>  thread killed
05:21:01 <vixey> @undef
05:21:01 <matthew-_> hmm. Maybe it's a GADT thing then
05:21:01 <vixey> > (7 `Just`)
05:21:01 <quicksilver> frevidar: Oh. One well-placed seq is all it takes.
05:21:06 <cjs> vixey: parse error (possibly incorrect indentation)
05:21:11 <lambdabot> Undefined.
05:21:17 <lambdabot>  thread killed
05:21:22 <frevidar> quicksilver: where?
05:21:26 <EvilTerran> ?bot
05:21:26 <lambdabot> :)
05:21:26 <mauke> > 2+2
05:21:38 <EvilTerran> ?vixen wakey wakey!
05:21:38 <lambdabot> Hahaha
05:21:38 <quicksilver> frevidar: 10,000th row in 3 seconds with 2Mb total memory
05:21:41 <lambdabot>  thread killed
05:21:52 <quicksilver> pascal n = a `seq` listArray (0, n) [ f i | i <- [0..n]]
05:21:57 <FordCortina> lamdabot looks a bit sick
05:22:06 * EvilTerran tries to think of a two-parameter alphanumeric constructor lambdabot will have
05:22:30 <matthew-_> > True `(,)` 5
05:22:30 <lambdabot>  Parse error at "(,)`" (column 7)
05:22:36 <mauke> > 2+2
05:22:37 <lambdabot>  4
05:22:38 <quicksilver> matthew-_: not alphanumeric ;P
05:22:45 <mauke> > (7 `Just`)
05:22:46 <EvilTerran> ``s have to contain an alphanumeric identifier only, sadly
05:22:46 <lambdabot>  Just 7
05:22:51 <EvilTerran> ah, there we go
05:22:51 <matthew-_> quicksilver: yeah, I'll wake up at some point ;)
05:22:55 <FordCortina> oh its working...
05:22:57 <EvilTerran> ?botsnack
05:22:57 <lambdabot> :)
05:23:13 <quicksilver> frevidar: 20,000th row in 15 seconds
05:23:18 <matthew-_> yeah, but I can't make it work for a constructor I'm using here, which is a GADT. Is it limited to non GADTs?
05:23:24 <EvilTerran> ?paste?
05:23:24 <lambdabot> Haskell pastebin: http://hpaste.org/new
05:23:38 <roconnor> dolio: I think the ocaml extraction gets more love
05:23:39 <quicksilver> frevidar: so just slightly worse than pure quadratic time. Not bad though.
05:23:52 <dolio> roconnor: Seems likely.
05:23:55 <frevidar> quicksilver: ah, that makes perfect sense!
05:24:05 <frevidar> the seq postion, that is
05:24:10 <quicksilver> frevidar: otherwise listarray gets called first
05:24:16 <frevidar> although, hindsight is 20/20
05:24:16 <quicksilver> frevidar: and "sets up" the array
05:24:25 <quicksilver> frevidar: before processing the recursive call
05:24:30 <quicksilver> which "sets up" the next array
05:24:32 <quicksilver> (and so on)
05:24:40 <quicksilver> frevidar: you *do* need UArrays though.
05:24:44 <cjs> matthew-_: This compiles for me:
05:24:46 <cjs> data Foo = Foo Int String deriving Show
05:24:46 <cjs> main = print $ 3 `Foo` "hello"
05:25:06 <frevidar> quicksilver: oh, ok
05:25:16 <matthew-_> ahh, no, it does work for GADTs. I'm just having a precedence issue
05:25:24 <quicksilver> frevidar: because standard arrays are value-lazy
05:25:33 <quicksilver> frevidar: i'll paste the exact code I used for your reference.
05:26:04 <quicksilver> frevidar:
05:26:04 <quicksilver> 13:25 < quicksilver> frevidar: becaus
05:26:06 <quicksilver> grr
05:26:11 <quicksilver> frevidar: http://hpaste.org/9066#a1
05:27:01 <quicksilver> to be more precise, memory usage is 220K for 10,000 and 430K for 20,000
05:27:09 <quicksilver> so linear space and quadratic time.
05:27:12 <quicksilver> which is the best you can do, I think.
05:27:49 <quicksilver> 6.8 might be a smidgen faster.
05:28:10 <frevidar> quicksilver: linear space, yes, most defiintely
05:28:52 <hackage> Uploaded to hackage: sphinx 0.2.1
05:30:09 <_Dae_> quicksilver: right.. you were right ofcourse.... I rewrote it as tail recursive and it changed almost nothing....
05:30:39 <frevidar> _Dae_: how did you write it as tail recursive out of interest by the way?
05:30:44 <EvilTerran> tail recursion is, if anything, usually a bad thing under lazy evaluation
05:30:49 <quicksilver> frevidar: to my great disappointment it's 25% slower if I switch to the much more elegant 'zipWith' version.
05:31:08 <frevidar> quicksilver: using lists, not arrays?
05:31:11 <EvilTerran> because it can cause massive thunk build-up if you don't force all the parameters before recursing
05:31:14 <_Dae_> quicksilver: coudln't you fix that by import stream fusion?
05:31:24 <quicksilver> listArray (0, n) (zipWith (+) (l ++ [0]) ([0] ++ l))
05:31:39 <frevidar> quicksilver: l ++ [0] is bad
05:31:39 <EvilTerran> see: thunk build-up in the accumulating parameter in foldl
05:31:40 <quicksilver> _Dae_: perhaps.
05:31:47 <quicksilver> frevidar: doesn't really matter.
05:32:35 <quicksilver> when zipWith and (++) have been inlined the [0] will just hang around
05:32:41 <quicksilver> it shouldn't add much to the cost of the inner loop
05:32:42 * quicksilver shrugs
05:33:10 <_Dae_> frevidar: http://hpaste.org/9066#a2
05:33:52 <geekagent> how do I ask lambdabot for a function based on its type?
05:34:04 <vixey> print $ sum $ elems $ pascal $ read $ head args
05:34:06 <mauke> hoogle
05:34:07 <vixey> might be rewritten as
05:34:09 <ndmitchell> ?dijinn (a,b) -> (b,a)
05:34:10 <lambdabot> f (a, b) = (b, a)
05:34:15 <vixey> print . sum . elems . pascal . read . head args
05:34:20 <vixey> print . sum . elems . pascal . read . head $ args -- oops
05:34:22 <ndmitchell> hoogle finds existing ones, dijinn creates new ones
05:35:20 <geekagent> ?hoogle (Monad m) => (a -> m b) -> m a -> m b
05:35:27 <lambdabot> Data.Generics.Schemes.everywhere :: (a -> a) -> a -> a
05:35:27 <lambdabot> Data.Generics.Schemes.everywhere' :: (a -> a) -> a -> a
05:35:27 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
05:35:33 <vixey> :t liftM
05:35:37 <frevidar> _Dae_: how is that tail recursive?
05:35:40 <mauke> sorry, the current hoogle sucks at classes
05:35:48 <lambdabot> thread killed
05:35:58 <mauke> :t (=<<)
05:36:10 <geekagent> ?hoogle (a -> m b) -> m a -> m b
05:36:10 <lambdabot> Data.Generics.Schemes.everywhere :: (a -> a) -> a -> a
05:36:10 <lambdabot> Data.Generics.Schemes.everywhere' :: (a -> a) -> a -> a
05:36:10 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
05:36:12 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
05:37:11 <_Dae_> frevidar: sorry... emacs and copying is still beyond me it would appear. This then: http://hpaste.org/9066#a3
05:37:21 <geekagent> :t (=<<))
05:37:22 <lambdabot> parse error on input `)'
05:37:26 <geekagent> :t (=<<)
05:37:27 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
05:37:52 <ndmitchell> geekagent: searching for monadic stuff sadly doesn't work too well :(
05:38:16 <geekagent> ndmitchell: that's ok, I found what I was looking for.
05:38:41 <geekagent> I need to write some monadic code in python, and I wanted a decorator that would just allow me to chain them all together
05:39:02 <frevidar> _Dae_: I saw that one... it looks exactly the same as my original one?
05:39:11 <geekagent> I didn't know what to call it, but now I know to call it reverse_bind in the hopes that someone will know monads
05:39:16 <_Dae_> frevidar: changing to totCount $! (listArray (0,count) [f i | i <- [0..count]]) makes it perform on par with quicksilvers
05:39:48 <_Dae_> frevidar: I just uloaded the right one?? try refreshing the page? it's there
05:39:48 <mauke> geekagent: call it dnib
06:14:33 <_zenon_> Reader monad is king.
06:17:08 <therp> has anyone a copy of funprogs with bananas, lenses, envelopes, and barb wire laying around? (and probably read)?
06:17:59 <vixey> what's funprogs ?
06:18:16 <therp> funprogs=functional programming + typo
06:18:26 <dolio> I have it somewhere.
06:18:42 <_zenon_> Link ?
06:18:46 <therp> I don't get it. is the author suddenly jumping to postfix notation on Page 8?
06:19:01 <therp> http://citeseer.ist.psu.edu/meijer91functional.html
06:19:02 <lambdabot> Title: Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire (Research ...
06:19:05 <vixey> oh right
06:20:07 <dolio> For functors, you mean?
06:20:13 <therp> in the section "Identity, Constants" with the underlined type name standing for a functor with these C _D_ = D property
06:20:23 <_zenon_> therp, thx.
06:20:32 <_zenon_> therp, thx surround.
06:20:37 <therp> dolio: yes for functors
06:20:51 <therp> or more precisely these "induced functors"
06:21:11 <dolio> Was he using prefix for functors before?
06:21:17 <EvilTerran> !yow
06:22:03 <dolio> Functors are postfix in that paper, mostly.
06:22:08 <dolio> Except bifunctors which are infix.
06:23:41 <therp> so this functor _D_ is something like (\_ -> D) or (const D)
06:23:43 <dolio> It matches lists, too. A* is lists of As, so * is the list functor.
06:23:49 <dolio> Yeah.
06:24:05 <dolio> newtype Const d a = Const d
06:24:31 <dolio> instance Functor (Const d) where fmap _ (Const d) = Const d
06:24:57 <dolio> fmap :: (a -> b) -> Const d a -> Const d b
06:25:28 <therp> dolio: thanks :) now these things are starting to make sense
06:25:38 <marcot> Toxaris: ping
06:25:38 <lambdabot> marcot: You have 2 new messages. '/msg lambdabot @messages' to read them.
06:26:48 <marcot> I'm receiving the same lambdabot messages for the second time...
06:27:43 <therp> dolio: may I ask for another hint? in the very next section "Lifting", the term "FG" does not stand for the application of the functor G to the function F, but rather the composition (F o G)
06:28:13 <dolio> Yeah.
06:28:28 <therp> dolio: thanks
06:28:33 <dolio> No problem.
06:28:53 <hackage> Uploaded to hackage: arrowp 0.5.0.1
06:30:03 <therp> dolio: ah, are they actually using the term "lifting" for what is called "composition" in category theory?
06:30:24 <therp> (arrow composition)
06:31:35 <dolio> Well, I guess they call it lifting because functors, which normally act on objects and morphisms, are also being defined as having actions on other functors.
06:32:06 <dolio> Using the same notation as their action on objects/morphisms.
06:32:49 <dolio> But, yeah, it's some kind of composition of functors.
06:34:05 <therp> dolio: so in the case of  œá(FG) = (œáF)G (first definition equation in the "Lifting" section), we can think of the first G as being lifted in the sense that it acts on the functor F?
06:34:11 <dolio> I think category theorists typically write things the same way, only prefix.
06:34:49 <dolio> therp: Right. And the bifunctor acts on the two mono-functors.
06:35:30 <therp> dolio: but only on the left sides of the equations, right?
06:35:55 <dolio> Right. The right sides are defining their meaning in terms of ordinary operations of functors.
06:36:00 <drguildo> can somebody see what i'm doing wrong here: http://hpaste.org/9068
06:36:05 <therp> dolio: thanks.
06:36:06 <drguildo> it's got me stumped
06:36:59 <therp> drguildo: trimTrailingSpace is probably a pure function, no?
06:37:09 <drguildo> yeah
06:37:15 <drguildo> but
06:37:27 <drguildo> i don't think that's the problem, unless i'm missing something
06:37:39 <DRMacIver> I'm starting to think I should ask to have my blog removed from planet haskell. I hardly ever write about haskell these days. Anyone have any strong opinions on the subject?
06:37:44 <drguildo> Couldn't match expected type `Char' against inferred type `[Char]'
06:37:46 <therp> I guess the strange error message comes from the fact that the list is also an instance of monad, hence the strange error message
06:38:00 <therp> drguildo: try "trimTrailingSpace dictResult"
06:38:08 <drguildo> even though dictResult is a String
06:38:34 <ToRA> trimTrailingWhiteSpace is expecting a [Char] as input, where you're using >>= at type ( [Char] >>= (Char -> [Char]))
06:38:48 * ToRA abuses notation painfully there
06:39:19 <ToRA> the >>= is basically acting as an infix concatMap
06:39:20 <drguildo> therp, would you mind explaining why that works?
06:39:39 <vixey> (>>=) = flip concatMap
06:40:10 <therp> drguildo: ToRA mostly gave the explanation :)
06:40:15 <therp> :t (>>=)
06:40:16 <drguildo> ToRA, so it's using the bind function from the list monad?
06:40:18 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
06:40:21 <ToRA> yup
06:40:55 <therp> drguildo: and as String = [Char] = an instance of Monad as any list is a monad, GHC tries to match against the type signature of >>=
06:40:58 <drguildo> i really need to learn about how ghc infers which context to use
06:41:14 <drguildo> it's always baffled me and now i'm making mistakes because of it
06:41:45 <drguildo> i guess it just looks at the type of the function on the right
06:41:48 <drguildo> in this case
06:41:51 <drguildo> left, sorry
06:42:13 <vixey> what is "context"?
06:42:38 <ToRA> well the return case ... has type IO String, so case must have type String, for (foo >>= bar) to have type String then foo is a string and bar is a (Char -> String) ...
06:42:44 <drguildo> but then dictResult should also be in the IO monad, so how does it choose one? i guess the right argument decides that
06:42:46 <ToRA> (at least that's how I interpreted it)
06:43:18 <drguildo> vixey, erm, that was probably a bad choice of word
06:43:38 <zx]treads> can Arrows be used for concurrency? r there any speed gain?
06:43:43 <drguildo> i just meant what i (tried) to explain
06:43:54 <zx]treads> is*
06:44:01 <drguildo> as in how it decides which monad it's dealing with, if that makes sense
06:44:19 <drguildo> say IO String
06:44:19 <drguildo> is it the IO or list monad
06:44:53 <vixey> drguildo: is what the IO or list monad?
06:45:02 <ToRA> IO String will be in the IO monad, but your case statement :: String, and so the >>= is in the list monad
06:45:11 <vixey> "IO String" is a type, not a monad
06:45:34 <ToRA> given that String is [Char] or [] Char
06:45:51 <Lemmih> dcoutts_: Saluton, how's life? Up for hacking this evening?
06:46:05 <dcoutts_> @yarr!
06:46:06 <lambdabot> Yo ho ho, and a bottle of rum!
06:46:09 <dcoutts_> Lemmih: sure!
06:46:19 <dcoutts_> Lemmih: and I just pushed the new tar working code
06:46:53 <drguildo> ToRA, ack, i totally overlooked that the result of the case was being returned
06:47:04 <drguildo> so i figured the result of that would be IO String
06:47:11 <drguildo> stupid mistake
06:48:40 <drguildo> i need some kind of haskell editor where i can hover over a bit of code and see what its type is
06:49:23 <vixey> drguildo, if you have an action of type  m a  for some monad m,
06:49:27 <vixey> say  foo :: m a
06:49:33 <vixey> do x <- foo
06:49:40 <vixey>    -- now 'x' has type a
06:49:41 <Lemmih> dcoutts_: What time would suit you?
06:49:57 <dcoutts_> Lemmih: any time after 6pm
06:50:03 <drguildo> vixey, sure
06:50:45 <drguildo> like i said, i overlooked the return and so thought dictResult was IO String when it was just String
06:51:15 <Lemmih> dcoutts_: Will you be at the university after that time?
06:51:37 <dcoutts_> Lemmih: yep, so ping me here on irc and I'll let you in
06:52:46 <Lemmih> dcoutts_: Wonderful. See you later.
06:52:51 <dcoutts_> @arr
06:52:52 <lambdabot> Swab the deck!
07:08:12 <roconnor> ugh, I've upgraded to ghc 6.8
07:08:24 <roconnor> that means all my packages are broken I suppose
07:08:34 <thoughtpolice> you just made the switch?
07:08:59 <roconnor> I upgraded ubuntu to 8.04 or whatever it is called
07:09:41 <frevidar> if f and x both use a bounded amount of memory, would "print $ iterate f x" ever run out of memory?
07:10:02 <frevidar> bounded as in, small relative to the amount of memory available?
07:10:35 <roconnor> @src iterate
07:10:35 <lambdabot> iterate f x =  x : iterate f (f x)
07:10:55 <ToRA> depends on the show instance that print uses
07:11:28 <roconnor> hmm, can we a assume that show forces x into normal form
07:12:46 <EvilTerran> probably, yes
07:12:48 <ToRA> > print $ iterate negate 1
07:13:00 <RayNbow> lambdabot doesn't do IO
07:13:03 <lambdabot>  thread killed
07:13:19 <ToRA> > iterate negate 1
07:13:21 <lambdabot>  [1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,...
07:13:34 <quicksilver> frevidar: that will be fine.
07:13:42 <thoughtpolice> i would imagine the GC would reclaim the memory
07:13:44 <quicksilver> print and putStrLn and friends don't hold on to the head of the list.
07:13:44 <thoughtpolice> as the list is printed out
07:13:47 <thoughtpolice> it'll just print forever
07:13:48 <quicksilver> they stream fine.
07:14:05 <cjs> Sheesh. It's 45 minutes until I'm 40, and I'm hanging out on #haskell.
07:14:13 <frevidar> ok, lets say we have g f i x | i == 0 = x | otherwise = g f (i - 1) (f x)?
07:14:14 <EvilTerran> roconnor, altho, if you really want to force into normal form, i think Control.Parallel.Strategies has something
07:14:34 <roconnor> EvilTerran: I'm thinking about frevidar's question
07:14:57 <Vq^> cjs: well, it's certainly no good excuse not to
07:15:12 <frevidar> basically, what I'm trying to get at is, if I make my recursive functions in a form that can be used by iterate, or my version of iterate with an 'i', will they be tail recursive?
07:15:32 <frevidar> as in, I make my recursive functions by combining a non-recursive function with iterate?
07:16:08 <frevidar> or even not even iterate, maybe just 'g'?
07:16:23 <sclv_> thinking in terms of "tail recursive" is not always the right thing to do in haskell...
07:16:24 <cjs> Ok. I'm going to go find a bank or something. See you guys later. (Do they have Internet in jail?)
07:16:31 <frevidar> I'm not sure if the g I described exists in the prelude
07:16:51 <yitz> @tell cjs Happy birthday!
07:16:51 <lambdabot> Consider it noted.
07:17:21 <frevidar> but g f i x = head $ drop i $ iterate f x
07:17:32 <frevidar> anyways
07:17:45 <frevidar> sclv_: what do you mean?
07:18:15 <sclv_> generally you're going to be relying on laziness more...
07:18:38 <frevidar> sclv_: how so?
07:19:16 <frevidar> so tail recursive sometimes isn't "a good thing"?
07:19:34 <quicksilver> it's totally irrelevant when you're producing lists.
07:19:38 <sclv_> frevidar: I'
07:19:50 <quicksilver> it still matters when you're folding a big list to a summary value
07:19:53 <quicksilver> as in foldl'
07:20:02 <EvilTerran> in general, it can even be a bad thing in lazy evaluation
07:20:13 <sclv_> erm, I'm googling to find the right article on this, but quicksilver gave the punchline.
07:20:25 <quicksilver> if you have a very deep function call chain which gets forced to a single atomic value, you do want it to be tail recursive or you'll get a stack overflow
07:20:42 <xif> would anyone like to comment on my code?
07:20:43 <xif> http://hpaste.org/9070
07:20:44 <quicksilver> if you have a very deep function call chain which produces a streaming value like a list of a tree
07:20:47 <quicksilver> then it doesn't matter
07:20:48 <thoughtpolice> laziness makes tail recursion awkward because basically, functions are not evaluated 'inside out'
07:20:56 <thoughtpolice> they are evaluated 'outside in'
07:20:56 <quicksilver> because the 'outside' of your stack chain gets garbage collected
07:20:57 <xif> it's a simple implementation of substring checker in Haskell.
07:20:57 <sclv_> naively one would expect foldl to be better than foldr because its tail recursive, but because of laziness its actually worse... however foldl' which is tail recursive and *strict* is better than both.
07:21:07 <vixey> xif, it's incorrect ....
07:21:08 <quicksilver> so your stack never actually gets deep
07:21:19 <thoughtpolice> so if you tail recurse and try to bring it to one big value - basically a fold - you will explode things
07:21:21 <xif> vixey: what's incorrect about it?
07:21:22 <thoughtpolice> badly
07:21:30 <vixey> xif, substring [] ys = False
07:21:35 <vixey> xif, should be substring [] ys = True
07:22:00 <EvilTerran> ?src isInfixOf
07:22:00 <lambdabot> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
07:22:07 <EvilTerran> ?src isPrefixOf
07:22:07 <lambdabot> isPrefixOf [] _          = True
07:22:07 <lambdabot> isPrefixOf _  []         = False
07:22:07 <lambdabot> isPrefixOf (x:xs) (y:ys) = x == y && isPrefixOf xs ys
07:22:32 <thoughtpolice> i.e. if you have 'f x y' in a strict language, x and y are evaluated, then f is called. otoh, with haskell, we just jump straight to 'f', so the values remain suspended. if you do a lot of tail recursion, all of those values will be suspended, so you have to be careful if you want to 'sum them up'
07:22:34 <sclv_> although yeah, if you're using foldr to produce a list, that you'll consume incrementally then its still better than foldl'...
07:22:50 <vixey> xif, once you fix that, it's looking good
07:23:15 <vixey> I would suggest removing the type signatures though
07:23:22 <thoughtpolice> basically, tail recursion + foldl + laziness can potentially == bad.
07:23:25 <xif> vixey: they're mostly for annotation...
07:23:33 <vixey> xif, they are annotations...
07:23:39 <vixey> xif, I'd suggest removing them
07:23:50 <xif> vixey: yeah, I get what you're saying, that "" should be a substring of "foo"
07:23:51 <vixey> you could not use this function on say, [Integer] only because of them
07:23:57 <vixey> but if you removed them, then you could
07:24:05 <xif> vixey: but other than that, what does it affect?
07:24:12 <xif> I mean, `substring [] ys = False`
07:24:26 <vixey> xif, other than that, nothing
07:24:26 <xif> does it affect anything beyond that specific case?
07:24:27 <frevidar> toughtpolice: are you saying kind off what you gain with the stack you lose with suspended values on the heap?
07:24:34 <xif> vixey: OK, cool.
07:24:38 <EvilTerran> xif, you should make them as general as possible, imo
07:24:47 <EvilTerran> if you want to leave them in
07:24:48 <xif> EvilTerran: right, I probably should.
07:24:49 <vixey> just erase them all
07:25:01 <xif> yeah, erasing them would seem to make sense.
07:25:07 <frevidar> thoughtpolice: I meant
07:39:02 <roconnor> If I write to a handle, seek backe, and read from the handle, do I always get what I wrote?
07:45:58 <Pistahh> roconnor: I think no if between the seek and the read something else has overwritten what you wrote.
07:48:14 <Jedai> roconnor: There was a funny presentation on that subject to show off a "quickcheck" in erlang if I remember right... The conclusion is that the rules are all but evident
07:54:05 <jorick> tsk tsk tsk
08:15:14 <_zenon_> The link to bananas lenses and wire?
08:16:14 <johnnowak> _zenon_: http://citeseer.ist.psu.edu/meijer91functional.html
08:16:15 <lambdabot> Title: Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire (Research ...
08:17:47 <_zenon_> johnnowak, Thanks. I'll digest it with a black coffee :)
08:18:01 <osfameron> @faq can haskell provide a competitive backend for http://cluecc.sourceforge.net/ ?
08:18:02 <lambdabot> The answer is: Yes! Haskell can do that.
08:18:05 <osfameron> ya!
08:18:07 <johnnowak> gave two cups, it's a great paper
08:18:10 <_zenon_> By the way, who is the target audience for the text?
08:18:11 <johnnowak> *have
08:22:07 <DRMacIver> osfameron: I wonder. When augustss was writing about his C DSL in Haskell it emerged that GHC did pretty badly on imperative looking code.
08:23:01 <osfameron> DRMacIver: interesting
08:23:33 <DRMacIver> I mean, I'm sure you could do it, but I don't know if you could reasonably expect to do much better than LuaJIT.
08:25:56 <osfameron> shame
08:26:20 <osfameron> damn, that would make a cute project though.  But I don't have the time/skillset
08:26:39 <osfameron> I should study compiler/vm writing though
08:30:47 <mar77a>  4 week HOLIDAYS YES YES YES
08:35:51 <vixey> An artist‚Äôs paintbrush doesn‚Äôt notify the artist of a mistake; the painter
08:35:51 <vixey> will be the judge of that. The chef ‚Äôs skillet and the composer‚Äôs piano remain
08:35:51 <vixey> simple and yielding. Why let a programming language try to out think you?
08:36:06 <__pao___> hi :-)
08:36:27 <__pao___> how do I convince ghc to link a C compiled object file?
08:36:45 <vixey> do you not just add it in the command line
08:36:55 <vixey>     % ghc-6.8.2 -o test Foo.o Bar.o Baz.o
08:38:02 <matthew-_> vixey: art forms typically aren't relied on for anything other than entertainment
08:38:18 <__pao___> vixey: I'd like to build a Module with statically linked C object files...
08:39:19 <__pao___> http://hpaste.org/9074
08:39:34 <__pao___> hypermac:ffi paolo$ ghc --make MySum.hs sum.o
08:39:45 <Beelsebob> __pao___: you're missing a -o
08:40:25 <__pao___> Beelsebob: let me try
08:41:32 <__pao___> Beelsebob: I think I'm wrong at using --make if a need to build a module, right?
08:41:40 <__pao___> hypermac:ffi paolo$ ghc --make MySum.hs -o MySum sum.o
08:41:41 <__pao___> Warning: output was redirected with -o, but no output will be generated
08:41:41 <__pao___> because there is no Main module.
08:41:59 <vixey> ghc -c MySum.hs
08:42:09 <Beelsebob> oh, then you need to inculde a Main module then
08:42:41 <__pao___> Beelsebob: I simply need to build a module that I can :load in ghci
08:43:58 <__pao___> hypermac:ffi paolo$ ghc -o Foo.o MySum.o sum.o
08:43:59 <__pao___> Undefined symbols:
08:43:59 <__pao___>   "_ZCMain_main_closure", referenced from:
08:44:00 <__pao___>       _ZCMain_main_closure$non_lazy_ptr in libHSrts.a(Main.o)
08:44:00 <__pao___>   "___stginit_ZCMain", referenced from:
08:44:00 <__pao___>       ___stginit_ZCMain$non_lazy_ptr in libHSrts.a(Main.o)
08:44:01 <__pao___> ld: symbol(s) not found
08:44:03 <__pao___> collect2: ld returned 1 exit status
08:44:25 <__pao___> MySum.o is obtained with vixey suggested "ghc -c MySum.hs"
08:44:39 <dcoutts_> __pao___: we generally prefer to use hpaste for longer examples
08:44:57 <__pao___> dcoutts_: sorry, I'll do use it
08:45:14 <dcoutts_> yo SyntaxNinja
08:50:46 <__pao___> I think I've got it
08:51:14 <__pao___> It is impossible to bundle C compiled and haskell compiled object code in a single file
08:51:30 <__pao___> is that correct?
08:52:06 <__pao___> I succeded i compiling a standalone executable linking my ffi hs code and C object file... it works
08:52:18 <SyntaxNinja> hi dcoutts_
08:52:56 <dcoutts_> __pao___: you can link .o files from C and Haskell code together
08:53:52 <__pao___> dcoutts_: how?
08:54:48 <dcoutts_> __pao___: ghc foo.o bar.o -o main
08:55:04 <dcoutts_> __pao___: same way you link .o files from haskell modules
08:55:14 <dcoutts_> doesn't matter if they came from .c files or .hs files
08:55:15 <__pao___> dcoutts_: that produces a standalone executable right?
08:55:18 <dcoutts_> yes
08:55:27 <dcoutts_> or you can do the same for a library archive
08:55:34 <__pao___> ok
08:55:36 <dcoutts_> cabal will do that for you for example
08:55:39 <RayNbow> dcoutts_: any requirements for the .o file?
08:55:46 <RayNbow> (specific gcc compiler?)
08:56:22 <__pao___> RayNbow: the "local" "standard" linker is used
08:56:27 <dcoutts_> RayNbow: if the .o files have functions that are expected to call each other then you'd better be sure that the compilers are using the same ABI
08:56:35 <dcoutts_> but the C ABI is pretty fixed these days
08:57:02 <dcoutts_> so if you're using your system C compiler you're pretty safe
08:57:04 <__pao___> dcoutts_: what about if I'd like to test my MySum.hs module + sum.o in ghci?
08:57:41 <dcoutts_> __pao___: ghci MySum.hs sum.o
08:57:43 <dcoutts_> easy :-)
08:58:06 <shapr> Good morning #haskell!
08:58:14 <dcoutts_> hia shapr
08:58:15 <__pao___> dcoutts_: ARGH! :-) I could have tried :-) Thank you all
08:58:37 <__pao___> I'll look at cabal doc for standard module "handling"...
08:58:47 <__pao___> hi shapr
09:01:54 <shapr> hai!
09:12:22 <dons> good stuff, http://www.reddit.com/info/6srgq/comments/
09:12:22 <lambdabot> Title: reddit.com: Simply reading and writing UTF-8 in Haskell
09:16:30 <Armored_Azrael> Is there a way to do UDP communication using Network (the high level interface) or do I need to just use sockets?
09:17:16 <Armored_Azrael> (sendTo and recvFrom look promising, but I can't really tell from the descriptioN)
09:17:35 <shapr> mmm, utf8!
09:20:03 <therp> _zenon_: fun. prog. with b.,l.,e. and b.w. is the most horrible thing I've read for a long time when it comes to syntax. In fact, I'm just about to throw it into trash despite it been so often praised. Section 3 is the most horrible one.
09:20:31 <_zenon_> therp, okay, thanks for the warning..
09:21:07 <therp> it's really sad. the other that was responsible for type setting should be banned from using TeX>
09:21:17 <therp> s/other/author/
09:21:39 <Valodim> haha, nice
09:23:49 <_zenon_> Well, I'll stick to recommending Wadlers paper on monads,  All about monads, Hughes paper on arrows and the Gentle introduction.
09:23:55 <_zenon_> not in that order though
09:24:22 <_zenon_> Which I hope is therp approved ;)
09:24:37 <therp> wadler's papers have always been nice to read
09:25:41 <_zenon_> that's a yes I guess :)
09:26:09 <therp> definitely
09:28:09 <_zenon_> Maybe there should be some voting of the best introductory papers / sites, and the most voted tutorials papers should be visible somewhere
09:28:15 <_zenon_> Maybe this already exists
09:29:34 <necrobious> I am using the sqlite-0.4.1 package from hackage, and when trying to compile the Main.hs file in the tests folder, I am getting 3 Ambiguous type error messages (http://hpaste.org/9075), I am probably just missing something simple, anyone mind having a quick look at the error, thanks.
09:30:31 <od_> does "f (x:xs) = x `seq` f xs" reduce all thunks in the list to NF?
09:30:47 <necrobious> the Main.hs file is: http://hpaste.org/9076
09:33:50 <monochrom> od_: Not necessarily, e.g., apply it to [Just undefined]
09:35:03 <_zenon_> Btw: If I read massive amounts of data from a file and process it, AND output the processed result to a file for later usage.
09:35:48 <_zenon_> Whats faster? 1) To output the processed data rawly with show and then input it with read (which is uggly!) XOR output in a format, and parse this format ?
09:36:16 <od_> par from Data.parallel is kinda confusing. the paper says sparked threads terminate whenever the expression is in WHNF
09:36:59 <_zenon_> od_, whats WHNF ?
09:37:06 <od_> weak head normal form
09:37:09 <_zenon_> ah...
09:37:15 <cjb> od_: it means that the result is known, basically.
09:37:15 <_zenon_> of course
09:37:27 <cjb> sorry, s/od_/_zenon_/
09:37:31 <monochrom> "Just undefined" is in WHNF.
09:37:43 <od_> yea
09:37:58 <_zenon_> Someone know the answer to my (Maybe Obvious) question ?
09:38:13 <od_> http://www.macs.hw.ac.uk/~dsg/gph/papers/html/Strategies/strategies_6.html is what im referring to specifically
09:38:15 <lambdabot> Title: Algorithm + Strategy = Parallelism -- Simple Divide-and-Conquer Functions, http://tinyurl.com/6gtj6u
09:38:25 <nominolo> hm, is there a trick for haddock to generate an enumerated list item with more than one paragraph?  indenting the second paragraph doesn't work
09:38:29 <od_> just seems confusing to know how much work is actually going to get done in parallel
09:39:39 <monochrom> You have to know it for sequential work too.
09:40:16 <_zenon_> http://www.cs.chalmers.se/~dubhashi/linne.pdf
09:40:18 <lambdabot> Title: Future Computing Technologies The Holy Grail of Parallelism
09:45:28 * byorgey makes lambdaroni pizza
09:47:34 <monochrom> lambdaroni and monadic cheese
09:47:46 <_zenon_> I should go with outputting the data in a parsable format?
09:47:47 <_zenon_> right?
09:47:53 <monochrom> err, monadella chese
09:48:11 <_zenon_> I guess show and read are MAGNITUDES slower than parsing ?
09:48:16 <_zenon_> hahah
09:48:20 <_zenon_> monadic cheese :)
09:48:59 <monochrom> put it on a multi-threading crust
09:49:12 * shepheb writes a blog post developing DairyT
09:52:02 * BMeph thinks that "monadic cheese' sounds like something you go to a doctor to cure...
09:53:24 <_zenon_> ewww
09:56:38 <nolrai_East> I need a container that lets me quickly insert, delete, and get a random element (random in the sense of unknow ahead of time, although random access would alow this, 'cause then i could just get a random Int)
09:57:01 <nolrai_East> Set does the first two. but not the last.
09:57:49 <nolrai_East> @bot
09:57:49 <lambdabot> :)
09:59:03 <RayNbow> does a type system exist that can type "mapN n f = foldr1 (.) (replicate n map) f"?
09:59:25 <RayNbow> (not that I need it, I'm just curious :p)
09:59:54 <RayNbow> nolrai_East: Data.Sequence.Seq?
10:01:04 <RayNbow> nolrai_East: http://haskell.org/ghc/docs/latest/html/libraries/containers/Data-Sequence.html
10:01:05 <lambdabot> Title: Data.Sequence, http://tinyurl.com/3arc5q
10:08:09 <mattam> @type [1 3]
10:08:13 <mattam> @type [1; 3]
10:08:13 <lambdabot>     Ambiguous type variable `t' in the constraint:
10:08:13 <lambdabot>       `Num t' arising from the literal `3' at <interactive>:1:3
10:08:13 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
10:08:14 <lambdabot> parse error on input `;'
10:08:29 <mattam> @type [1, 3]
10:08:29 <lambdabot> forall t. (Num t) => [t]
10:08:42 <mattam> @type [id, id]
10:08:43 <lambdabot> forall a. [a -> a]
10:09:47 <mattam> RayNbow: You need enough polymorphism to store polymorphic functions in lists, I think it's possible in Haskell.
10:10:06 <mattam> @type ([id, id] : [forall a. a -> a])
10:10:07 <lambdabot> parse error on input `->'
10:10:18 <RayNbow> mattam: the problem is that the type of (mapN n) depends on the value of n
10:10:54 <ski> RayNbow : dependent types
10:11:04 <mattam> RayNbow: first you need the (replicate n map) to work. For the dependency you need dependent types.
10:11:46 <mattam> Is it possible to get [id] : [forall a, a -> a] in Haskell with extensions?
10:12:07 <RayNbow> mattam: (replicate n map) has type [(a -> b) -> [a] -> [b]]
10:12:25 <mattam> Yes, for a and b fixed.
10:12:44 <ski> @type ([id,id] :: [forall a. a -> a])
10:12:45 <lambdabot> [forall a. a -> a]
10:12:48 <RayNbow> ski: fundeps?
10:12:58 <ski> RayNbow : no
10:13:02 <mattam> Ah right, ::
10:13:24 <ski> @type 0 :: Int -- testing, 1 2 3
10:13:24 <lambdabot> Int
10:13:49 <mattam> @type (replicate 4 map :: [forall a b. (a -> b) -> [a] -> [b]])
10:13:50 <lambdabot> [forall a b. (a -> b) -> [a] -> [b]]
10:14:21 <RayNbow> ski: which page/paper/etc about dependent types would you recommend?
10:14:32 <ski> RayNbow : dependent types, as in coq, agda or epigram, e.g.
10:14:54 * RayNbow doesn't know any of those... :p
10:15:09 <RayNbow> (except that I've seen their names before)
10:15:49 <ski> oh, i don't know what paper to recommend
10:16:05 <ski> maybe one of Conor McBride's
10:16:05 <mattam> "Why dependent types matter" may be a good first step.
10:18:45 <zx]treads> i try : let print' = putStrLn . show
10:18:47 <RayNbow> thanks :)
10:18:59 <zx]treads> but i get print' :: () -> IO ()
10:19:01 <FordCortina> RayNbow: i dont know how relevant this is, but your mapN kind reminds me of zipWithN in McBride's "Faking it" paper
10:19:11 <Botje> zx]treads: that's because of the monomorphism restriction
10:19:22 <zx]treads> eah that thing always :(
10:19:23 <RayNbow> FordCortina: I've just downloaded that paper
10:19:25 <Botje> ghci needs to have a proper type but that one is too general
10:19:34 <zx]treads> well i explicitly defined
10:19:37 <Botje> zx]treads: if you want it to work properly you have to supply the type yourself
10:19:41 <RayNbow> and also the "Why dependent types matter" paper
10:20:03 * RayNbow will send the papers to his print queue :p
10:20:10 <FordCortina> :)
10:20:10 <zx]treads> let print' = (putStrLn . show) :: (Show a) => a -> IO () but that doesn't work either
10:21:38 <Botje> needs an explicit forall somewhere
10:21:42 <Botje> but i wouldn't know where :(
10:22:50 <zx]treads> where can i find how forall works ?
10:23:07 <Botje> i think googling for "explicit forall haskell" will turn up something
10:23:16 <liquidcopy> !help
10:23:18 <zx]treads> :)
10:23:20 <liquidcopy> oh... no bot :(
10:23:25 <FordCortina> zx]treads: in the ghc manual?
10:23:46 <zx]treads> it is ghc-specific?
10:23:47 <FordCortina> rankN types
10:23:57 <FordCortina> i think so, not sure
10:24:05 <Botje> zx]treads: you could check the monomorphism restriction page on the haskell wiki
10:24:46 <zx]treads> Botje: done
10:25:20 <zx]treads> Botje: nothing about forall there
10:27:10 <dons> woot lads! languages used at the google code jam, sorted by popularity, http://www.go-hero.net/jam/lang
10:27:10 <lambdabot> Title: Code Jam 2008 Statistics
10:27:19 <dons> note a certain language starting with H high up the ranks..
10:27:50 <Valodim> haha, someone even used brainfuck
10:28:13 <FordCortina> twice as many ppl using Pascal! :-0
10:28:20 <RayNbow> Visual Basic?
10:28:20 <Botje> odd :(
10:28:36 <dons> i wouldn't even know where to find a pascal compiler, fwiw.
10:28:37 <RayNbow> I wonder if they mean VB6 or VB.NET?
10:29:14 <Botje> doesn't gcc have one?
10:29:22 <Valodim> more likely delphi
10:29:27 <ski> zx]treads : are you wanting to define it in GHCi ?
10:29:32 <Nafai> There is free pascal
10:29:35 <BMeph> Haskell: Officially more popular than Visual Basic!
10:29:58 <_zenon_> BMeph, really?
10:30:08 <_zenon_> BMeph, calls for a celebration then
10:30:22 <BMeph> _zenon_: Look at the link. :)
10:30:26 <zx]treads> ski: yeah
10:30:48 <lament> mm
10:30:49 <ski> let print' :: SHow a => a -> IO (); print' = putStrLn . show
10:30:50 <ski> try that
10:30:56 <ski> s/SHow/Show/
10:31:03 <_zenon_> BMeph, ohhh. okay, in Code Jam
10:31:04 <_zenon_> okay
10:31:32 <lament> So Pascal is two times more popular than Haskell? Truly joyous
10:31:51 <lament> "Brainfuck (used by 1 people)"
10:32:08 <ski> Happy Happy Joy Joy.
10:32:17 <dons> Haskell more popular than Lisp, Scheme, OCaml and SML put together!
10:32:53 <TuringTest> hooray
10:33:09 <TuringTest> Though the unclassified (Plain Text) is beating Haskell
10:33:10 <shepheb> I want to see score correlation
10:33:31 <BMeph> @remember dons  Haskell more popular than Lisp, Scheme, OCaml and SML put together!
10:33:31 <lambdabot> It is stored.
10:33:38 <BMeph> Heh-heh. >:)
10:34:10 <lament> popularity contests are suspect in general; popularity contests in which the first two places are occupied by C++ and Java are particularly suspect
10:34:40 <_zenon_> lament, It need we must let the word spread
10:34:43 <BMeph> ski, zx]treads: The earlier definition worked fine for me in GHCi. I'm using 6.8.3, if that makes a difference.
10:34:44 <dons> haskell has a bias towards competitions.
10:34:55 <dons> people might not use it for work, but they'll use it for puzzle solving.
10:35:03 <dons> see e.g. euler.
10:35:08 <RayNbow> which reminds me... I still got a puzzle to solve
10:35:13 <dcoutts_> dons: oh, can I ask about the hackathon? do we have any local organisers yet? we need to get moving with that.
10:35:16 <RayNbow> oh... Euler... I got many puzzles to solve then :p
10:35:18 <BMeph> lament: s/suspect/useless or irrelevant/ ;)
10:35:24 <lament> right, sorry
10:35:28 <dons> dcoutts_: we don't have organisers in victoria, no.
10:35:33 <dons> dcoutts_: i'm thinking we can do a more ad hoc thing.
10:35:37 <dons> unless you've an idea.
10:36:05 <dcoutts_> dons: perhaps we can ask the Vancouver Haskell programmers group to be local organisers
10:36:13 <dcoutts_> be/find whatever
10:36:25 <dons> dcoutts_: that's a good idea.
10:36:27 <BMeph> Which reminds me - did the PE folks have a party when they put out puzzle #200? :)
10:36:51 <dcoutts_> dons: and there's a NW FP interest group
10:37:23 <dcoutts_> dons: so we have no official space with icfp I take it. So we'll have to ask local organisers to find something.
10:38:11 <mauke> I have a non-Haskell question. I need an algorithm:
10:38:17 <dcoutts_> dons: so perhaps we should email those two groups and -cafe asking for volunteers (or maybe not -cafe yet)
10:38:40 <dcoutts_> dons: and pointing to the standing committee and the previous committee for advice
10:39:02 <mauke> I have an undirected acyclic graph. every edge has a weight. I want to find the path with the greatest possible weight
10:40:26 <mauke> are there any algorithms/papers/etc for this?
10:40:36 <RayNbow> mauke, hmm... can't you use a modified version of a max-flow algorithm?
10:40:50 <shepheb> .oO( u -> v -> u, I found a cycle. but okay.)
10:41:11 <_zenon_> seems like a longest path problem ?
10:41:26 <mauke> shepheb: I can't move backwards
10:41:59 <RayNbow> mauke, you could introduce something like a source and a sink node
10:42:06 <_zenon_> which is considered as a <hard> problem.
10:43:01 <RayNbow> ah wait... max flow works on directed graphs...
10:44:11 <_zenon_> http://www.csc.kth.se/~viggo/wwwcompendium/node114.html
10:44:13 <lambdabot> Title: LONGEST PATH
10:44:25 <mauke> let's see
10:52:27 <dcoutts_> yo Lemmih
10:52:51 <dcoutts_> Lemmih: "visitor-network.oxuni.org.uk" eh? that means you're outside then :-)
10:52:55 <Lemmih> dcoutts_: Greetings from the cold doorsteps of Oxford Computing Laboratory.
10:54:53 <dcoutts_> @arr!
10:54:54 <lambdabot> Ahoy mateys
10:55:13 <Quadrescence> What would be the easiest way to go about parsing a file (with rather simple rules...)?
10:56:28 <_zenon_> Quadrescence, how simple?
10:56:42 <_zenon_> I mean: how simple is the grammar ?
10:59:11 <Quadrescence> Well, it's kind of like a configuration file. There would be a few predefined 'sections,' and in each section, there would be definitions of certain things.
10:59:43 <_zenon_> Well, if you will scale it in the future, I would recommend BNFC
10:59:52 <Quadrescence> I am not parsing things like...individual characters.
10:59:53 <_zenon_> makes scaling and changing of the grammar easy
11:00:18 <_zenon_> Haven't used the Parsec library myself
11:00:21 <Quadrescence> _zenon_: Link me please?
11:00:24 <_zenon_> Quadrescence,
11:00:25 <_zenon_> sure
11:00:42 <_zenon_> Quadrescence, http://www.cs.chalmers.se/Cs/Research/Language-technology/BNFC/doc/BNF_Converter_Haskell_Mode.html
11:00:44 <lambdabot> Title: The BNF Converter: Haskell Mode, http://tinyurl.com/6qubxy
11:01:20 <_zenon_> Might be a little overhead learning to use it, but it produces a top notch Haskell-written parser module :)
11:01:30 <Arnar> zeno: you need Happy, Alex and Latex for this?
11:01:38 <_zenon_> Arnar, yes
11:01:49 <Arnar> I'd look at parsec then..
11:02:05 <_zenon_> Arnar, yes, I was going to suggest it
11:02:07 <Arnar> a parser for a simple config file would be a matter of a few lines
11:02:16 <Arnar> ah, ok :)
11:02:22 <_zenon_> As Arnar said, Parsec is probably simpler to learn.
11:02:27 <Quadrescence> 1 Parsec = 3.08568025 √ó 10^16 meters
11:02:45 <_zenon_> But you could look at BNFC annyway, it's great for larger things
11:03:06 <Quadrescence> _zenon_: I bookmarked it.
11:03:11 <_zenon_> :)
11:03:58 <Quadrescence> Is this the so-called Parsec? http://legacy.cs.uu.nl/daan/parsec.html
11:03:59 <lambdabot> Title: Parsec
11:04:22 <Arnar> Quadrescence: yes.. it should be already installed if you have a recent GHC
11:04:43 <_zenon_> http://haskell.org/ghc/docs/latest/html/libraries/parsec/Text-ParserCombinators-Parsec.html
11:04:44 <lambdabot> Title: Text.ParserCombinators.Parsec, http://tinyurl.com/yf3xje
11:05:13 <Arnar> the docs on daan's site are also quite good
11:05:32 <Quadrescence> Combinator is probably one of the best words I've ever heard.
11:05:49 <Arnar> especially take note of the "Lexical analysis" chapter, that part can make your life a lot easier..
11:06:06 <Arnar> Quadrescence: here's a quick example of a parsec parser by your's truly: http://www.hvergi.net/2008/06/parsing-json-with-haskell/
11:06:07 <lambdabot> Title: /dev/collective ª Blog Archive ª Parsing JSON with Haskell
11:07:29 <Arnar> Quadrescence: although.. this might be something for you also: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/ConfigFile
11:07:31 <lambdabot> Title: HackageDB: ConfigFile-1.0.4, http://tinyurl.com/64s2s6
11:08:00 <Quadrescence> That looks useful. :O
11:10:46 <_zenon_> Yeah, maybe I should throw a goat eye on Parsec 2
11:10:50 <_zenon_> seemed easy
11:14:22 <BMeph> So, does anyone use Attribute Grammars regularly? Or, heck, anyone here use them irregularly? :)
11:16:05 <_zenon_> Quadrescence, I like the word "transformer"
11:17:15 <Quadrescence> IIRC, English isn't your native language (maybe it is?). But that word is too common. :[ But combinator just sounds fucking sexy.
11:18:10 <bitrot> Quadrescence: but transformers are more than meets the eye..
11:18:39 <mauke> looks like Floyd-Warshall could work
11:19:30 <Quadrescence> bitrot: You're absolutely right.
11:19:37 <_zenon_> Quadrescence, no, you are right. English is not my native language. But still, a combinator needs 2 of something, the transformer does well with one!
11:19:48 <Quadrescence> :D
11:20:33 <mauke> how are combinators related to combs?
11:20:37 <_zenon_> I'll googlefight this
11:20:50 <_zenon_> Sorry Quadrescence , http://googlefight.com/index.php?lang=en_GB&word1=transformer&word2=combinator
11:20:52 <lambdabot> Title: Google Fight : Make this fight with googleFight transformer VS combinator, http://tinyurl.com/6knuz9
11:21:06 <lilachaze> _zenon_: how about identitator for a unary combinator?
11:21:11 <Philippa> _zenon_: actually not all combinators take two parameters
11:21:45 <_zenon_> I was maybe generalizing, but it was for the sake of the argument ;)
11:22:20 <_zenon_> But still. You can't argue with googlefight.
11:22:41 * RayNbow tries... http://googlefight.com/index.php?lang=en_GB&word1=transformer&word2=gundam
11:22:42 <lambdabot> Title: Google Fight : Make this fight with googleFight transformer VS gundam, http://tinyurl.com/6oqu9b
11:23:19 * BMeph goes to make popcorn before watching the fight...
11:23:46 <RayNbow> Google Fight needs more special effects :p
11:23:49 <_zenon_> RayNbow, clooose fight
11:23:54 <_zenon_> RayNbow, indeed
11:35:42 <bossy> how can you can automatically label, archive, delete, star, or forward your mail, based on any combination of keywords, sender, recipients, and more‚ÄΩ
11:36:07 <monochrom> I use bogofilter for that.
11:36:20 * bitrot imagines a comb-in-ator is something used by the govern-ator...
11:36:35 <Quadrescence> bitrot: Hahah.
11:37:00 <Quadrescence> monochrom: bogosort is win. I get O(n) time on my compy.
11:37:31 <tusho> bogosort is O(infinity)
11:37:35 <Quadrescence> But you get O(n!) on your worthless comp.
11:37:53 <monochrom> I somehow felt that bossy was advertising something. "and more" is kind of characteristic of that. But apparently I foiled it.
11:37:55 <Quadrescence> I just happen to have quantum mechanics at my disposal.
11:50:32 <Quadrescence> Could someone kind of get me started with this: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/ConfigFile
11:50:35 <lambdabot> Title: HackageDB: ConfigFile-1.0.4, http://tinyurl.com/64s2s6
11:51:00 <Quadrescence> Get me started, like, how do I access it, is it already installed with GHC, do I need to install it, etc.
11:51:06 <Quadrescence> Not actually /using/ it.
11:51:16 <Quadrescence> (which I can just read the documentation for)
11:51:28 <mauke> it doesn't come with ghc
11:51:41 <mauke> do you have cabal-install?
11:51:48 <Quadrescence> I don't think so.
11:52:10 <Quadrescence> (I just installed GHC, nothing explicitly)
11:52:17 <Quadrescence> nothing else*
11:52:44 <mauke> you may want to install cabal-install first; it'll automate everything else
11:52:51 <Quadrescence> Okay
11:53:05 <mauke> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/cabal-install
11:53:07 <lambdabot> Title: HackageDB: cabal-install-0.5.1, http://tinyurl.com/2sj7lw
11:53:15 <mauke> download the tarball
11:53:30 <RayNbow> @hoogle bogosort
11:53:31 <Quadrescence> Okay
11:53:45 <lambdabot> thread killed
11:53:54 <RayNbow> lambdabot can't handle bogosort
11:54:20 <mauke> unpack it and cd into it
11:54:36 <Quadrescence> Okay, done
11:54:44 <mauke> ghc --make Setup
11:54:58 <Arnar> what is a common upper-case greek letter to represent the free monoid?
11:55:54 <mauke> Quadrescence: did that work?
11:56:06 <Quadrescence> Yes
11:56:16 <Quadrescence> clickity-click the exe?
11:56:28 <mauke> oh, you're on windows?
11:56:39 <Quadrescence> Yes. :<
11:56:51 <ski> Arnar : often the free monoid on a set `A' is denoted `A^*'
11:56:56 <mauke> hmm, I don't know how --user/--global works there
11:57:15 <mauke> on linux it's ./Setup configure
11:57:19 <Arnar> ski: ah ok..
11:57:24 <mauke> followed by ./Setup build and ./Setup install
11:57:37 <Deewiant> by default, which I guess is --global, it puts stuff in %PROGRAMFILES%/Haskell
11:58:06 <Arnar> ski: I don't have a symbol for the underlying set.. but I'm thinking if Sigma would look out of place
11:58:20 <Arnar> i.e. Sigma for the monoid..
11:58:38 <ski> (Arnar : hm .. though i think sometimes `A^omega' have been used .. to contrast between finite and infinite lists ..)
11:59:09 <ski> Arnar : why do you need a majuscle greek letter ?
11:59:13 <mauke> so I heard you're closed under concatenation
11:59:46 <Quadrescence> Setup: At least the following dependencies are missing:
11:59:46 <Quadrescence>     Cabal >=1.4&&<1.5, HTTP >=3000&&<3002, zlib >=0.4
12:00:00 <pjdelport> mauke: geeky pickup line?
12:00:24 <_zenon_> Arnar, Sigma^{klein star} fares well as the monoid for the alphabet Sigma , at least when I studied Formal Languages and Finite Automata
12:00:37 <Deewiant> s/klein/kleene/
12:00:58 <_zenon_> kleene indeed
12:01:23 <_zenon_> kleine :)
12:02:02 <mauke> Quadrescence: looks like you'll have to install those manually
12:02:32 <mauke> Quadrescence: this is exactly what cabal-install would do for you if you already had it :-)
12:03:27 * BMeph imagines the fun of substituting a Kleene star for a Klein bottle...
12:03:56 <ski> Klein's four-group
12:04:19 <Zao> Is there anyone around that's reasonably familiar with the cabal-install source?
12:04:36 <dcoutts_> Zao: yep, are you writing patches for us? :-)
12:05:12 <Zao> dcoutts_: I'm trying to find where in the source I should apply violence to change the .cabal/ path.
12:05:47 <dcoutts_> Zao: you want to change the default install path/prefix or you want to change where it looks for its configuration info?
12:06:31 <Zao> Both, I suppose.
12:06:49 <Zao> My goal is separate sets of packages for my different architectures.
12:07:13 <dcoutts_> Zao: ah in that case you want $arch in the install prefix
12:07:46 <dcoutts_> Zao: it's probably ok to keep the config for all arches in ~/.cabal/config, and just change where packages get installed so it's per-arch
12:07:53 <dcoutts_> Zao: right?
12:08:04 <Zao> I thought that the cache-dir was something platform dependant, but it was apparently just downloaded tarballs.
12:08:21 <Zao> So yes, the config seems fine to share.
12:08:48 <dcoutts_> Zao: so you want to implement http://hackage.haskell.org/trac/hackage/ticket/312
12:08:49 <lambdabot> Title: #312 (Allow ${arch} var in install paths) - Hackage - Trac
12:09:38 <dcoutts_> Zao: and see what you think about the other existing comments
12:10:32 <Zao> I can't quite understand the resistance against changing the default path to something arch/os aware.
12:10:39 <Zao> Worked for xmonad, at least.
12:11:33 <Zao> System.Info has relevant 'arch' and 'os' Strings that could be used.
12:12:17 <dcoutts_> Zao: most people do not need or want arch/os in their install paths
12:12:52 <Zao> It's a dot-folder, I can't see most people caring.
12:13:00 <dcoutts_> Zao: we'd prefer to use Distribution.System which has buildArch :: Arch and buildOS :: OS
12:13:16 <dcoutts_> since they're more canonical than the System.Info strings
12:13:18 <Zao> Ah. I wasn't aware of those.
12:13:49 <dcoutts_> Zao: we translate the System.Info strings into these enums so that different haskell compilers agree on the same names
12:14:02 <dcoutts_> Zao: otherwise you'd get different names for ghc vs hugs vs etc etc
12:16:22 <Zao> I suppose I'll stick to --prefix then until I get time to dive into cabal.
12:16:44 <mauke> (you can set your --prefix in the cabal-install config file)
12:17:21 <Arnar> ski: sorry.. wasn't around to answer your question. I'm carrying this monad as a state in a SOS spec, and other state is represented by captial greeks
12:17:52 <Arnar> s/monad/monoid/
12:18:29 <monochrom> Greek city states? :)
12:19:13 <Arnar> Or Greek executioners of capital punishment..
12:19:35 <ski> Arnar : well, i don't see why you can't use a non-identifier state expression in this case .. but to each their own
12:20:08 <Arnar> ski: sorry.. non-identifier state expression?
12:20:17 <ski> e.g. `A^*'
12:20:24 <Arnar> ah
12:20:29 <Arnar> I surely can..
12:20:34 <ski> `A' is an identifier (i.e. variable)
12:21:25 <Arnar> anyways.. thanks, I'll think about it
12:24:30 <Zao> Hmm, Warning: Error parsing config file /home/z/zao/.cabal/config: On line 1: GHC
12:25:06 <mauke> what is line 1?
12:25:23 <Zao> compiler: GHC
12:25:58 <mauke> mine contains "compiler: ghc"
12:26:00 <Zao> Looking at my filesystem, .cabal is from february, so it may be some older defaults.
12:26:17 <Zao> See, this is what happens when you share a home between arches :)
12:28:57 <hackage> Uploaded to hackage: bytestring-csv 0.1.2
12:31:18 <Quadrescence> What might this be? progDirTemplate = "$libdir\\hugs\\programs"
12:31:32 <Quadrescence> More specifically, what /should/ it be?
12:34:16 * rainb hugs vixey 
12:37:24 <byorgey> Quadrescence: it seems to be assuming you have hugs.  no idea what it ought to be though.
12:37:47 <Quadrescence> Installing packages manually = :<
12:37:48 <byorgey> Quadrescence: ndm is our resident Haskell+Windows expert, so he might be able to help if you can catch him around
12:39:53 <Quadrescence> byorgey: I think I might have got it. :>>>>
12:40:49 <Quadrescence> Apparently I did get it, because I have one less dependency. :>
12:42:32 <vixey> 100%
12:42:43 <byorgey> Quadrescence: excellent!
12:43:30 <byorgey> Quadrescence: just remember, these are the last dependencies you will ever have to install manually. =)
12:43:53 <byorgey> (this is probably lie, but close enough =)
12:43:58 <Quadrescence> Is the typical line of commands: configure, build, install?
12:43:58 <shapr> @seen edwardk
12:43:59 <lambdabot> I saw edwardk leaving #haskell 4h 13m 42s ago, and .
12:44:03 <byorgey> Quadrescence: yes.
12:47:27 <Quadrescence> Aha, two dependencies down, one to go.
12:47:34 <byorgey> go go go!
12:48:37 <Quadrescence> Good thing Cabal 1.4.x doesn't require Cabal <1.4
12:48:37 <Quadrescence> :D
12:48:57 <Quadrescence> But...is there a safe way to uninstall a package?
12:49:10 <Quadrescence> Or should I just keep the lower version of cabal?
12:49:22 <Quadrescence> As well as installing the higher version
12:49:25 <shapr> @seen glguy
12:49:25 <lambdabot> glguy is in #haskell. I don't know when glguy last spoke.
12:50:11 <shapr> glguy: Hey, hpaste is collecting lots of useful example code, I wonder if it could be modified for improved google indexing?
12:50:47 <newsham> ?yow -- needs to be fixed
12:50:48 <lambdabot> Couldn't find fortune file
12:51:32 <byorgey> Quadrescence: it's fine to have multiple versions of a package installed
12:52:16 <byorgey> Quadrescence: there's no real way to uninstall packages, but you can unregister them with ghc.
12:52:31 <Quadrescence> Ah.
12:52:52 <byorgey> I think I have approximately 7 versions of Cabal installed
12:53:27 <byorgey> actually, 8
12:54:39 <Quadrescence> Hum, installing Cabal isn't to easy.
12:54:43 <Quadrescence> I got some weird error.
12:54:49 <byorgey> Quadrescence: what's the error?
12:55:01 <Quadrescence> During interactive linking, GHCi couldn't find the following symbol:
12:55:01 <Quadrescence>   SHGetFolderPathA@20
12:55:01 <byorgey> weirdness is a state of mind
12:55:08 <Quadrescence> (that's the start of it, at least)
12:55:20 <byorgey> oh, never mind, that IS weird ;)
12:55:37 <byorgey> Quadrescence: what exactly were you trying to do when you got that error?
12:55:40 <dogbite> yeah i was prepared to type an answer based off of the errors i got
12:55:44 <dogbite> but that is indeed a weird error
12:55:59 <Quadrescence> runhaskell Setup.hs configure
12:56:09 <byorgey> Quadrescence: for the Cabal package?
12:56:18 <Quadrescence> Yes. :3
12:56:19 <Zao> If you can't run interactive, there's always ghc --make Setup && ./Setup ...
12:56:27 <byorgey> yeah, good suggestions
12:56:38 <byorgey> compile Setup.hs first
12:57:25 <Quadrescence> [42 of 42]
12:57:29 <Quadrescence> success on that. :D
12:58:02 <byorgey> great, now you can just  ./Setup configure  and ./Setup build etc.
12:58:11 <byorgey> or whatever the corresponding incantation is on Windows.
12:58:18 <Quadrescence> Right, LET'S DO THIS.
12:58:51 <Quadrescence> Config'd :D
13:03:24 <Quadrescence> Is there a difference between building and compiling? orrrrrrr?
13:06:48 <_zenon_> I would say building is the whole process of "building" what you hae
13:06:50 <_zenon_> have*
13:07:06 <_zenon_> while compiling is one of the specific actions
13:07:11 <Quadrescence> Okay, guys, let's try to cabal-install something.
13:07:34 <Quadrescence> Someone want to tell me how to install http://hackage.haskell.org/cgi-bin/hackage-scripts/package/ConfigFile
13:07:35 <_zenon_> hoogle :)
13:07:37 <lambdabot> Title: HackageDB: ConfigFile-1.0.4, http://tinyurl.com/64s2s6
13:07:38 <Quadrescence> :>
13:08:07 <_zenon_> I would go for hoogle, great package.
13:08:46 <Quadrescence> _zenon_: I know what hoogle, the website, is. What would a package do? :O
13:09:09 <_zenon_> Quadrescence, You can do :hoogle from ghci if you have the hoogle package
13:09:20 <Quadrescence> Oh, that WOULD be nice.
13:09:44 <_zenon_> Quadrescence, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hoogle
13:09:44 <lambdabot> Title: HackageDB: hoogle-3.1
13:10:25 <Quadrescence> But how do I correctly use cabal to install it?
13:10:29 <byorgey> Quadrescence: you should be able to just  'cabal install foo'
13:10:32 <byorgey> to install package foo
13:10:45 <_zenon_> Also, if you are a pl fetish http://hackage.haskell.org/cgi-bin/hackage-scripts/package/pointfree
13:10:47 <Quadrescence> Okay, let's try
13:10:47 <lambdabot> Title: HackageDB: pointfree-1.0.1, http://tinyurl.com/6r2qvo
13:11:06 <Quadrescence> _zenon_: Hahaha, pointfree is interesting, but I don't have a fetish.
13:11:07 <Quadrescence> :D
13:11:18 <yakov> hey
13:11:29 <_zenon_> Quadrescence, bah, take it anyway :) Always good to have in hand
13:11:36 <Quadrescence> :) okat
13:11:37 <Quadrescence> y
13:11:40 <yakov> guys, I don't see prebuilt versions of latest GHC for SunOS/SPARC.. where can I find it?
13:12:22 <Quadrescence> Thanks guys for not telling me to update. :D
13:12:26 <Quadrescence> cabal update
13:13:05 <Quadrescence> Okay, blah, how do I change the default install directory?
13:13:17 <Quadrescence> I had to do it manually for all the manual installations too.
13:14:03 <Armored_Azrael> Quadrescence: Do you want to do a global install, a per-user install, or a prefix specific install
13:14:17 <Quadrescence> global I suppose.
13:17:16 <BMeph> _zenon_: Hm, I /am/ not a pl fetish, but I have a pl fetish. Does that qualify? :)
13:18:10 <_zenon_> BMeph, certainly :P  my bad
13:18:45 * byorgey IS a pl fetish
13:18:45 <Quadrescence> Come on, a configuration file has to be around here somewhere.
13:19:22 <byorgey> Quadrescence: there might not be one by default, on *nix systems I think it goes in ~/.cabal
13:19:50 <byorgey> not sure where it should go on Window$
13:20:29 <adekoba> is there a way to get lines/unlines to cooperate with windows and its line-feeds?
13:20:53 <Quadrescence> Well, I don't know what is telling Cabal to install at the certain directory. I don't think this is OS dependent.
13:21:05 <olsner> pl fetish = perl fetish?
13:21:17 <Baughn> Pointless, I think
13:21:21 <olsner> oh, @pl, I see
13:21:23 <Quadrescence> pointless fetish
13:21:23 <Quadrescence> :D
13:22:01 <jethr0> adekoba: i would have hoped it would work on a platform basis. as an ugly hack something like "filter (not . (=='\r'))" might work(?)
13:22:04 <Quadrescence> What is a .hi file?
13:22:08 * BMeph thinks a perl fetish sounds rather pointless
13:22:46 <vixey> jethr0: I would certainly not consider that an ugly hack
13:22:49 <olsner> aren't all fetishes pretty pointless anyway, beside their entertainment value?
13:22:52 <_zenon_> car fetish <--- lisp fetish?
13:22:56 <adekoba> jethr0: Yes, but the data I am reading contains '\n' characters which I do not want to be read as newlines
13:23:02 <byorgey> Quadrescence: those are interface files, generated by ghc
13:23:03 <vixey> jethr0: but I would use /= instead of not . ==
13:23:13 <jethr0> vixey: true, my bad
13:23:16 <byorgey> Quadrescence: i.e. each .hs file when compiled yields a .o file and a .hi file
13:23:23 <Quadrescence> Right.
13:23:36 <jethr0> adekoba: hmm, that's a complication.
13:23:42 <vixey> adekoba: you should write a new function
13:23:56 <adekoba> jethr0: yeah. I was hoping it wouldn't come to that.
13:24:09 <adekoba> err, rather to vixey
13:24:23 <olsner> _zenon_: lithp fetith?
13:24:25 * jethr0 never understood why '\n" is seemingly treated the same way as '\n\r' under windows. kinda destroys the purpose of having the carriage return in the first place
13:25:10 <Baughn> jethr0: Thirty years of backwards compatibility.
13:25:10 <_zenon_> olsner, :)
13:25:23 <jethr0> lines is rather messy to write because it doesn't easily conform to a fold or an unfold (or maybe I just wasn't trying hard enough ;)
13:25:36 <vixey> adekoba: Something you will have in FP a *lot*
13:25:38 <jethr0> Baughn: i know that, but still it's awkward that the
13:25:44 <vixey> adekoba: Infact all the time, you will do this thousands of times
13:25:48 <Baughn> Old applications would print \n\r to reset the /typewriter/ properly. Later OSs had to read it as newline, because the applications used them that way. LAter applications did it because the OS did..
13:25:49 <vixey> adekoba: is define new functions
13:25:52 <jethr0> '\r' seems to have no function beyond the '\n' anymore
13:26:08 <Zao> jethr0: Return cursor to the beginning of the line.
13:26:21 <Zao> Which lets you do progess updates without scrolling like a madman.
13:26:43 <vixey> You should never ever be afraid to define a new function
13:26:44 <chrisdone> hey, can someone read how what this means in plain english? http://upload.wikimedia.org/math/0/4/2/042d4c773138a1581f285f432d59db12.png
13:26:44 <lambdabot> http://tinyurl.com/5vmkza
13:26:52 <jethr0> zao: yes, but '\n' is doing this already in newer version. I guess I'm just rambling on about the annoyingness of such backward-compatibilities
13:27:02 <adekoba> jethr0: exactly. it's unnecessary. Damnit, windows.
13:27:15 <olsner> chrisdone: http://xkcd.com/184/
13:27:15 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
13:27:21 <vixey> don't damn windows, just write a new function
13:27:24 <jethr0> chrisdone: isn't that a rotation?
13:27:31 <Zao> jethr0: Just a return to column 0, not a new line as well.
13:27:38 <chrisdone> jethr0: yes it is, but I don't understand the notation
13:27:51 <jethr0> i'ts matrix notation
13:28:07 <jethr0> you multiplay each row of the matrix with the column vector
13:28:08 <adekoba> vixey: I will, but I shouldn't have to.
13:28:21 <vixey> chrisdone: What about it ?
13:28:21 <adekoba> (imho)
13:28:43 <jethr0> like (cos phi * x + (-sin phi) * y; sin phi * x + cos phi * y)
13:28:46 <Zao> chrisdone: http://en.wikipedia.org/wiki/Matrix_multiplication
13:28:46 <vixey> adekoba: If you don't, who will?
13:28:46 <lambdabot> Title: Matrix multiplication - Wikipedia, the free encyclopedia
13:29:43 <chrisdone> jethr0: oh right I get it
13:30:18 <vixey> chrisdone: it's a lot easier to remember: x' + iy' = (x + iy) * (cis theta), where cis theta = cos theta + i sin theta
13:30:30 <jethr0> vixey: hehe
13:30:33 <_zenon_> chrisdone, http://www.euclideanspace.com/maths/algebra/matrix/transforms/index.htm
13:30:35 <lambdabot> Title: Maths - Matrix Transforms - Martin Baker, http://tinyurl.com/5s9fgy
13:31:17 <chrisdone> cheers
13:31:19 <jethr0> "cos theta + i sin theta", wasn't that the "e^i*pi*theta" or some such?
13:31:38 <jethr0> sorry, missing parens
13:31:55 <Quadrescence> cis t = e^(i*t)
13:32:01 <opqdonut> vixey: even easier with quaternions ;)
13:32:17 <vixey> jethr0: cis theta = e^(i theta)... don't want to get into that though
13:32:24 <vixey> It's actuallly much harder with quaternions
13:32:36 <jethr0> transformation aren't easy no matter what notation. at least for me, thay make my head hurt nearly as badly as type theory ;)
13:33:13 * _zenon_ wonders... should I take a coffee ?
13:33:23 <jethr0> slurping is nice with quaternions, converting between quaternions, matrices and other representations that's the real b*tch
13:33:36 <olsner> nah, too late for coffee now
13:33:52 <jethr0> s/slurping/slerping/
13:34:05 <_zenon_> olsner, I don't know.
13:34:13 <_zenon_> olsner, I feel this.... craving
13:34:44 <dons> anyone else note that 3rd place in the Google Code Jam was by a Haskell user.
13:35:00 <dons> "Reid" i wonder if that was kpreid
13:35:03 <dons> http://www.go-hero.net/jam/name/Reid ..
13:35:03 <lambdabot> Title: Code Jam 2008 Statistics
13:35:12 <olsner> I have time for about half an hour of haskell hacking before bed time, what should I do?
13:35:31 <chrisdone> olsner: a solution to this problem: http://www.streamtech.nl/problemset/102.html
13:35:32 <lambdabot> Title: Ecological Bin Packing
13:35:44 <olsner> dons: woot, google code jam has haskell nowadays?
13:35:47 <kpreid> dons: no. you're the secon person to ask
13:36:09 <jethr0> olsner: what would you like to do?
13:36:12 <dons> olsner: seems so. 46 entries in it.
13:36:38 <jethr0> olsner: how about writing a solution for one of the so far unanswered haskell quizzes? can take more than half an hour, though
13:36:54 <olsner> unanswered haskell quizzes?
13:36:57 <chrisdone> how do we write a matrix on one line for when chatting on irc?
13:37:19 <_zenon_> [ v1  v2 v3 ] ?
13:37:33 <chrisdone> a 2,2 matrix?
13:37:38 <chrisdone> uh, 2x2
13:37:39 <_zenon_> [ [e1 ...eN ] [.... ] ]
13:37:40 <_zenon_> ?
13:37:40 <vixey> > [[x,y],[z,w]]
13:37:42 <jethr0> @wiki haskell quiz
13:37:42 <lambdabot> http://www.haskell.org/haskellwiki/haskell_quiz
13:37:50 <chrisdone> mmkay
13:37:54 <Zao> Any syntax with grouping tends to bring the meaning across.
13:37:55 <lambdabot>  thread killed
13:38:08 <jethr0> @wiki Haskell Quiz
13:38:08 <lambdabot> http://www.haskell.org/haskellwiki/Haskell_Quiz
13:39:06 <jethr0> damn, still need to submit the "text image" one. *so lazy sometimes*
13:39:13 <olsner> jethr0: nice, maybe I'll find something to chew on there
13:39:27 <Quadrescence> (bump) How do I change the default directory for cabal to install packages to?
13:39:40 <olsner> or I could take one of the existing solutions and go pointless on it :)
13:39:52 <Zao> Quadrescence: You can change it in the .cabal/config, I'm told.
13:39:53 <Zao> Somehow.
13:39:54 <chrisdone> olsner: what's the point?
13:40:04 * chrisdone shame
13:40:09 <olsner> chrisdone: no points, that's the point :)
13:40:25 <Quadrescence> Zao: So I'd have to rebuild it and everything?
13:41:04 <_zenon_> olsner, funny ( a little)
13:41:06 <Zao> Quadrescence: No.
13:41:16 <Zao> The config file in the .cabal dir, wherever that may be on non-unix.
13:41:37 <olsner> hmm, a negative-sleep monad maybe
13:42:33 <Quadrescence> Stupid windows, always hiding its files: C:\Documents and Settings\Admin\Application Data\cabal
13:43:56 <_zenon_> I have to get an answer to this coffee problem
13:44:00 <_zenon_> >let r = fst $ randomR (0,1) (mkStdGen 1231232345) in if r == 0 then putStrLn "YES! COFFEE!" else putStrLn "Leave it!"
13:44:11 <_zenon_> > let r = fst $ randomR (0,1) (mkStdGen 1231232345) in if r == 0 then putStrLn "YES! COFFEE!" else putStrLn "Leave it!"
13:44:18 <lambdabot>  <IO ()>
13:44:21 <_zenon_> lambdabot?
13:44:23 <_zenon_> noooo
13:44:25 <chrisdone> :t fst
13:44:28 <dmhouse> It can't do IO.
13:44:31 <lambdabot> forall a b. (a, b) -> a
13:44:32 <Deewiant> > 1+1
13:44:32 <chrisdone> :t liftM fst
13:44:34 <lambdabot> forall a b (m :: * -> *). (Monad m) => m (a, b) -> m a
13:44:34 <lambdabot>  2
13:44:37 <Deewiant> slow today
13:44:43 <_zenon_> I'll evaluate in ghci then
13:44:51 <Deewiant> > let r = fst $ randomR (0,1) (mkStdGen 1231232345) in if r == 0 then "YES! COFFEE!" else "Leave it!"
13:44:51 <_zenon_> YES! COFFEE!
13:44:52 <lambdabot>  "YES! COFFEE!"
13:45:07 <_zenon_> Nice
13:45:10 <vixey> @die 1d2
13:45:10 <lambdabot> 1d2 => 1
13:45:19 <Deewiant> @die 1d2+1
13:45:19 <lambdabot> 1d2+1 => 3
13:45:22 <Deewiant> oo
13:45:27 <Deewiant> @die 1d2*2
13:45:27 <lambdabot> unexpected "*": expecting digit, "+" or end
13:45:41 <Deewiant> meh
13:45:45 * _zenon_ dances away into the citchen, preparing that sweet black gold
13:47:07 <_zenon_> ehm... kitchen that is
13:49:37 <Armored_Azrael> Anyone know where I could find a good example of hsplugin use, or a tutorial explaining it?
13:50:01 <jethr0> Armored_Azrael: have you read the paper?
13:50:06 <dons> Armored_Azrael: hs-plugins isn't really maintained anymore. People are using ghc-apii instead.
13:50:10 <chrisdone> mathworld<3
13:50:17 <dons> what are you building that needs plugins, Armored_Azrael ?
13:51:09 <stepcut> hsplugins adds 12MB on the to size of my stripped binary :-/
13:51:20 <jethr0> http://www.cse.unsw.edu.au/~dons/papers/PSSC04.html
13:51:22 <lambdabot> Title: Plugging Haskell In
13:51:24 <Armored_Azrael> dons: It doesn't need plugins, it just sounded like an easy way of accomplishing it. I'm just making a network traffic generator that varies with time, and I want to have user specified functions to make things easier.
13:52:05 <stepcut> dons: is there any example of using ghc-api to do plugins ?
13:52:07 <dons> Armored_Azrael: ah. maybe you'd more want to follow the xmonad path, and load a config file of haskell functions.
13:52:18 <dons> stepcut: hmm. there's a SoC project this year for this.
13:52:34 <stepcut> dons: ah, so it is still a work in progress
13:52:43 <Armored_Azrael> dons: Slight issue--the main system this will be used on doesn't have a haskell compiler
13:53:04 <dons> so hs-plugins is also out, then, Armored_Azrael
13:53:07 <Armored_Azrael> OK
13:53:07 <dons> it needs ghc.
13:53:24 <dons> you could just load and interpret an EDSL describing the filtering functions
13:53:33 <stepcut> dons: I seem to remember that lambdabot/yi/etc, could be compiled with our without hsplugins? How did that work ? #ifdefs ?
13:54:51 <Armored_Azrael> dons: Yeah, but then I get into whether or not this or that EDSL is expressive enough, etc. (summer research job, this is one of the various things I'm making, people will likely be using it with me gone) and I end up overengineering things. Thanks anyway though.
13:56:09 * BCoppens eyes mornfall 
13:56:21 <mornfall> BCoppens: I am asleep! (almost)
13:56:26 <BCoppens> mornfall: crud =p
13:56:36 <BCoppens> mornfall: nighty night then, I guess =)
13:56:36 <mornfall> BCoppens: But good evening, nevertheless. :-)
13:56:59 <mornfall> That would be good, I am all broken. But I'll be around tomorrow, if that's of any help?
13:57:14 <BCoppens> mornfall: hmmmm, sure =)
13:57:41 <BCoppens> mornfall: oh, and I'm home all week -> freeciv, somehow, somewhen?
13:57:53 <mornfall> BCoppens: : - ]
13:57:59 <BCoppens> :)
13:58:15 <mornfall> BCoppens: Could be. I'm in Brno till Friday, with evenings and nights free.
13:58:34 <mornfall> So, goodnight and see ya tomorrow, hopefully. : - )
13:58:37 <BCoppens> mornfall: goodnight :)
13:58:54 <_zenon_> P(Silbersky tar fallet X ) ~ Mediaexponering(X)
13:59:01 <Armored_Azrael> dons: So while that option is out for this project, I have a personal project that will require some form of loadable program format, so if you have any good resources on the idea of loading precompiled haskell modules into a running program, that would be nice.
13:59:10 <Armored_Azrael> (so that I can read them later)
14:01:06 <Quadrescence> Zao: I think I figured out how to change default install directories.
14:02:30 <Quadrescence> .\Cabal-1.4.0.1\Distribution\Simple\InstallDirs.hs, line 211, there's all the default paths.
14:02:38 <Quadrescence> (for each OS)
14:11:34 <zachk> http://hpaste.org/9077 finds the center and radius of a circle from general form x^2+y^2+ax+by+c=0
14:11:47 <zachk> and read rational just doesnt seem to work right
14:12:05 <monochrom> > read "3%4" :: Rational
14:12:07 <vixey> zachk: You don't have to write 'in'
14:12:10 <lambdabot>  3%4
14:12:13 <vixey> You may write,
14:12:16 <vixey> do ...
14:12:19 <vixey>    let x = 1
14:12:21 <vixey>    let y = 2
14:12:25 <vixey>    ...
14:12:30 <vixey> if you wish
14:12:32 <zachk> it yelled at me for wrong indentation
14:12:56 <vixey> zachk: notice that I don't write 'in'
14:13:05 <monochrom> notice everything
14:13:09 <zachk> i also tried using where but since aNum and friends arent defined when the function is compiled i went to lets
14:13:26 <Quadrescence> What is the safest way to reinstall a(n already installed) package?
14:13:32 <zachk> vixey: i tried that but it didnt like it :D i like in makes me feel safe
14:13:54 <monochrom> Just install again.
14:14:02 <Zao> Heck, you don't even need let for lets directly following.
14:14:04 <Quadrescence> Don't delete anything?
14:14:07 <Quadrescence> Will it overwrite?
14:14:11 <Quadrescence> (good thing)
14:14:11 <Zao> You can just indent y to the x depth and it'll be correct.
14:14:14 <monochrom> It will overwrite fine.
14:15:56 <monochrom> Note also this syllogism.  Cabal hides all packages not depended upon.  A package does not depend on itself.  Therefore Cabal will hide the package you're re-installing.  Therefore there is no worry about "existence of X screws up compiling of X".
14:16:39 <dons> tibbe: why does the NIO data type use IORefs?
14:16:51 <dons> it looks almost identical to the Builder type in Data.Binary.
14:17:13 <dons> afaik, IORefs are only going to a) slow things down, and b) make them not threadsafe.
14:34:01 <dobblego> is there a funny cartoon of the Microsoft Research guys somewhere? I vaguely recall its existence; maybe it was a dream
14:34:24 <mar77a> http://xkcd.com/323/
14:34:24 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
14:37:06 <Quadrescence> oh my god, cabal install is fantastic
14:37:14 <mar77a> it's cabal
14:38:58 <Quadrescence> I don't know if that was a correction, or if that was "it's cabal[! Of course it's fantastic!]"
14:39:24 <zachk> mar77a: does cabal install yogurt work for you on windows?
14:39:38 <mar77a> never tested it
14:39:54 <mar77a> isn't cabal a word that is the opposite of lunatic
14:40:27 <mar77a> "# A small group of secret plotters, as against a government or person in authority."
14:40:31 <mar77a> ..okay
14:40:31 <dcoutts_> mar77a: no, cabal means a secret club
14:40:45 <dcoutts_> and inner circle
14:41:00 <dcoutts_> the first rule of the Haskell Cabal is that there is no Haskell Cabal
14:41:33 <mar77a> the first rule of #haskell is no quoting fight club
14:42:24 <Quadrescence> I am tempted to download every package
14:42:35 <Quadrescence> Just because I like the command line doing it's thing automatically. :D
14:42:59 <mmorrow> @seen dons
14:43:00 <lambdabot> dons is in #arch-haskell, #xmonad, #ghc and #haskell. I last heard dons speak 25m 46s ago.
14:43:12 <mar77a> i had the same problem but with food, Quadrescence
14:43:24 <mar77a> i was amazed at the body's biology and couldn't stop eating
14:43:37 <Quadrescence> :)))
14:43:49 <mmorrow> @tell dons hey, i don't have continual internet curently, so i gotta run, but check out http://hpaste.org/9078 and http://code.haskell.org/~morrow/code/haskell/csv-test.tar.gz :)
14:43:49 <lambdabot> Consider it noted.
14:44:12 <mar77a> @tell mar77a lol i quoted myself
14:44:12 <lambdabot> You can tell yourself!
14:44:18 <mar77a> sweet
14:44:51 <Quadrescence> @tell lambdabot I love you almost as much as mbot.
14:44:51 <lambdabot> Nice try ;)
14:45:00 <monochrom> haha
14:47:16 <nolrai_East> So what should a function that gets the nth element of a Set be called?
14:47:39 <vixey> that doesn't make sense
14:47:43 <vixey> a set doesn't have an ordering
14:48:36 <nolrai_East> but a Set has an implied ording because its elements must be a member of Ord.
14:48:45 <vixey> oh I see
14:48:51 <rainb> could be a partial ordening
14:48:55 <monochrom> You can try !, !!, !!!, ...
14:49:22 <vixey> so.. just wondering how do you calculate it?
14:49:27 <nolrai_East> !! is used by maps so isnt great, is !!! used anywhere?
14:49:43 <vixey> I mean would it make sense to instead just have a toList function?
14:51:31 <nolrai_East> vixey: this one would have O(log n) time (!! n) . tolist has O(n) time. (it would be a part of the Data.Set module because it uses hidden atributes)
14:52:05 <vixey> how do you calculate it ?
14:52:28 <nolrai_East> Data.Set.Set are size balinced trees so finding the nth element is easy.
14:52:40 <nolrai_East> (when you can see the size)
14:53:01 <nolrai_East> (and the sub trees)
14:53:31 <nolrai_East> src (!!!)
14:53:41 <nolrai_East> @src (!!!)
14:53:41 <lambdabot> Source not found. :(
14:53:49 <nolrai_East> @hoogle (!!!)
14:53:50 <lambdabot> No matches found
14:53:53 <vixey> oh cool
14:54:03 <shapr> hiya vixey
14:54:25 <vixey> hey
14:55:21 <vixey> shapr, I'm learning forth
15:03:47 <shapr> vixey: how do you like it so far?
15:04:36 <vixey> well it's not like any language I know
15:04:44 <lament> heh heh
15:04:47 <lament> it certainly is not
15:05:01 <lament> vixey: it's not really a language. It's a game.
15:05:03 <BMeph> vixey: Yes, do tell (I had a job programming in Forth about 25 years ago). :)
15:05:19 <vixey> I am having fun though, I'm impressed
15:05:21 <lament> languages have a syntax, semantics and stuff
15:05:40 <vovik> why learn forth?
15:06:03 <vixey> this compiler I'm writing in haskell.. it's going to output forth
15:06:10 <lament> vovik: A very interesting and refreshing point of view at how computers are supposed to work.
15:06:59 <vovik> lament: in the same sense as lisp?
15:07:06 <kryptiskt> also, forth is very compact, nice if you work with embedded systems
15:07:09 <lament> vovik: sure
15:07:22 <kryptiskt> where haskell will never go
15:07:23 <vixey> shapr, how are you ?
15:07:55 <Quadrescence> The package ConfigFile would be used for configuration files with, how do I say this, an unchanging number of "fields", right?
15:08:07 <Cale> kryptiskt: Though, Haskell is nice as a language in which to write a specialised compiler for embedded systems.
15:08:43 <lament> vovik: but forth is a little less academic - bare metal lisp only ran on lisp machines which are now extinct; bare metal forth can, and does, run on pretty much anything
15:08:44 <kryptiskt> yes, even compile to FPGA
15:08:54 <kryptiskt> that I liked
15:09:02 * dons works at a company that sells haskell systems for fpgas..
15:09:02 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
15:09:15 <vovik> lament: that's nice, but who runs bare metal lisp?
15:09:41 <lament> vovik: nobody; that's what i said
15:09:41 <dons> we also have some bare metal haskell systems too, fwiw.
15:10:25 <lament> vovik: nobody runs bare metal lisp, so in practical terms lisp is not much of a view of "how computers work". But Forth is.
15:10:27 <Cale> Yeah, there's some neat work on using FPGAs to provide graph reduction in hardware :)
15:10:49 <vovik> lament: well how does lisp being academic follow from bare metal lisp only running on lisp machines? maybe bare metal lisp is academic, but like i said, no one runs that anyway
15:11:04 <vovik> lol @ cale
15:11:30 <lament> vovik: I don't understand.
15:11:37 <shapr> vixey: I'm doing well, but I'm driving through a scary thunderstorm.
15:11:39 <BMeph> I like to point out how Forth's first implementation was not done in Fortran, similar names notwithstanding. Too bad Lisp can't say the same thing...
15:11:55 <vovik> lament: never mind :p
15:12:14 <dogbite> shapr: you're driving?
15:12:27 <vixey> shapr, mm .. I hope I get to see a tornado one day
15:12:28 <shapr> dogbite: No, my sister is driving, but I'm riding in the passenger seat next to her.
15:12:32 <vovik> driving through a thunderstorm while chatting on irc, the epitome of danger
15:12:35 <Cale> vovik: hm?
15:12:43 <dogbite> shapr: phew!
15:12:59 <vovik> Cale: i laughed at your graph reduction in hardware comment
15:13:03 <shapr> vovik: I'm using a cell modem, I think it's safe.
15:13:08 <Cale> vovik: why?
15:13:11 <dogbite> haskell hackers are scarce commodities
15:13:11 <Cale> http://www-users.cs.york.ac.uk/~mfn/reduceron/
15:13:12 <lambdabot> Title: The Reduceron (Old)
15:13:19 <Cale> http://www-users.cs.york.ac.uk/~mfn/reduceron2/
15:13:19 <lambdabot> Title: The Reduceron
15:13:20 <shapr> dogbite: But we're not magnetic!
15:13:27 <Cale> (rather)
15:13:28 <vovik> lol withdrawn.
15:13:33 <dons> dogbite: i'm not so sure. did you see the google code jam results?
15:13:36 <dogbite> shapr: no, but we're a bit polarized
15:13:43 <shapr> heh
15:13:47 <dogbite> dons: huh?
15:13:53 <dogbite> dons: i wrote my code in haskell for that
15:14:03 <dons> dogbite: well, i guess they're rare compared to java programmers
15:14:08 <dons> http://www.go-hero.net/jam/languages
15:14:08 <lambdabot> Title: Code Jam 2008 Statistics
15:14:28 <dogbite> who else did the code jam in here?
15:14:30 <dons> < 1% of submissions were in haskell, but 3rd place was a haskell hacker, and there were more haskell entries than the other FP languages combined.
15:14:46 <dogbite> i had a super short answer to their 1st question
15:14:53 <BMeph> vovik: Sorry to jump on a dead horse, but... did you thing Cale was joking? Because his jokes are much funnier than that... :)
15:14:57 <kryptiskt> wow, brainfuck
15:14:59 <dogbite> but this morning while walking my dogs i thought of an even shorter one
15:15:48 <vovik> BMeph: i did.
15:15:52 <dogbite> i feel sorry for any blokes who decided to write that stuff in c++
15:16:58 <dogbite> what is the (Plain Text) language?
15:17:16 <BMeph> vovik: Oh, okay. Pity - like I said, Cale's much funnier when he's doing it for real. :)
15:17:41 <vovik> i'm very sorry for the misunderstanding :x
15:17:59 * BMeph recalls a lambdabot with...much more personality than @vixen usually gives
15:20:39 <BMeph> vovik: Aw, don't worry about it. We're all learners on the road of life. #haskell just seems to have a few more loops in the road than usual. ;)
15:21:17 <vovik> damn, even the irc channel has a steep learning curve...
15:21:19 <BMeph> vovik: (This, from a guy not very far down that road, at all, BTW.)
15:23:29 <nolrai_East> ghc isnt likeing "#if __GLASGOW_HASKELL__" what do I need to do?
15:23:45 <nolrai_East> @vixen
15:23:45 <lambdabot> I like to pick everything up and smell it... Its a fetish of mine... And i mean everything! Is that cool with you?
15:23:59 <nolrai_East> hmm
15:24:46 <tusho> internet
15:24:47 <tusho> do you read me
15:24:54 <sjanssen> tusho: no
15:24:58 <tusho> good
15:25:07 <tusho> my dns is borken
15:25:09 <tusho> what is opendns
15:25:10 <tusho> :|
15:25:14 <tusho> ('s servers)
15:25:27 <sjanssen> nolrai_East: {-# LANGUAGE CPP #-} or pass the -cpp flag to ghc
15:25:49 <nolrai_East> sjanssen: thanks!
15:26:29 <Quadrescence> What is the fastest/least expensive way to store numbers in a list-like structure, and add/subtract list-like structures element wise? (I am asking what kind of structure would I use.)
15:26:44 <dons> what operations do you want?
15:26:46 <dons> delete/insert?
15:26:49 <tusho> :\
15:27:02 <kryptiskt> Data.IntSet maybe
15:27:07 <Quadrescence> dons: They are fixed length
15:27:28 <dons> can you describe the operations that you need, and what complexity they require?
15:27:31 * _zenon_ is going to bed now
15:27:34 <_zenon_> good night all
15:27:37 <_zenon_> cu tomorrow
15:28:02 <sjanssen> Quadrescence: lists are actually decent there
15:28:17 <nolrai_East> Quadrescence: is the structure like a list, or contains lists, or both?
15:28:23 <sjanssen> Quadrescence: though a UArray will use less space
15:28:25 <tusho> someone?
15:28:29 <tusho> i just want the opendns ips
15:28:30 <tusho> :P
15:29:15 <rwbarton> tusho: I guessed this name, is it what you want? ns1.opendns.net has address 66.116.109.44
15:29:38 <tusho> thanks
15:29:55 <Quadrescence> nolrai_East: Well, I'm sure I could change implementation, but originally I had [(SomeType,Int)], where SomeType is just what Int is refering to.
15:30:01 * tusho hopes for workage
15:30:07 <tusho> rwbarton: hum, what about ns2
15:30:15 <Quadrescence> But if I want to add, then I have to unzip that, etc.
15:30:20 <rwbarton> tusho: the same, it seems
15:30:54 <rwbarton> tusho: I guessed wrong, hang on
15:31:08 <sjanssen> Quadrescence: you don't have to unzip, just use zipWith (second (+))
15:32:31 <nolrai_East> Quadrescence: do you want a container of lists, of (SomeType,Int) pairs, or of 'Int's?
15:33:00 <rwbarton> tusho: try 208.67.222.222
15:33:30 <tusho> thanks rwbarton
15:33:31 <tusho> :)
15:34:04 * rwbarton wonders whether asking for DNS server IPs on IRC is necessarily a good idea :)
15:34:15 <Quadrescence> sjanssen: Hum, okay. Perhaps I'll just use lists then. I don't know if there is any package for moving elements of a list around.
15:34:16 <Quadrescence> nolrai_East: Actually, what I need to use most is [(Int,Int)].
15:34:37 <tusho> rwbarton: It's not like I could google them, is it?
15:34:52 <nolrai_East> tusho: now you could.
15:35:04 <nolrai_East> well maybe
15:35:05 <tusho> well yes but I just looked up an invalid domain
15:35:08 <tusho> and it gives the opendns page
15:35:18 <tusho> if someone faked this kudos to them
15:35:21 <tusho> they deserve it ;)
15:35:58 <nolrai_East> Quaadrescence: So you want a container to put lists of pairs in, right?
15:36:03 <kryptiskt> tusho: easy to fake, just passthru to OpenDNS; except when you're going to your bank :-)
15:36:38 <tusho> kryptiskt: I'm reading blogs. O noes ;)
15:36:48 <Quadrescence> nolrai_East: fst (Int,Int) represents the position of an object relative to others in a list, and snd (Int,Int) represents how that object is oriented (i.e. if it's upside down, rotated, etc)
15:37:07 <Quadrescence> nolrai_East: I gueeeeeesssssssss.
15:37:11 <Quadrescence> Maybe. :<
15:37:42 * BCoppens just keeps a file with root DNS server IPs, in case his own DNS goes down
15:37:43 <chrisdone> zipWith is so awesome
15:38:16 <Quadrescence> (I take that back, fst (Int, Int) refers to the actual object, the position in the list...refers to the position. :) )
15:38:53 <tusho> not that awesome ChanServ
15:38:54 <tusho> err
15:38:56 <nolrai_East> Quadrescece: or are you looking for somthing to use instead of list?
15:38:57 <tusho> chrisdone
15:38:57 <tusho> :P
15:39:16 <Quadrescence> nolrai_East: I was wondering if maybe there is something better than lists.
15:39:55 <Quadrescence> That can be compared for equality, particularly.
15:40:21 <Quadrescence> And maybe the ability to "natively" swap, or even permute, elements.
15:40:28 <nolrai_East> there are several. Sets, and Arrays (of several subtypes) for example,
15:40:38 <kryptiskt> Can you have duplicates on the first Int?
15:40:52 <kryptiskt> say (1,3) and (1,4)
15:41:43 <Quadrescence> Yes. And if so, the second int will be zero.
15:42:00 <Quadrescence> (or, no, ignoret that)
15:42:02 <kryptiskt> Then you cant use Data.IntMap
15:42:27 <Quadrescence> Hmm, actually, I need to think about that.
15:42:48 <nolrai_East> If you cant then Data.IntMap is very nice.
15:44:29 <nolrai_East> If you are only permuting ajacent(sp) elements then Data.Sequence's Seq type might work.
15:45:22 <nolrai_East> but if you are using the lists as a lookup list then Data.IntMap is mostlikely what you want.
15:45:38 <jethr0> what libary would i use for serialization/deserialization? i know there was one based on the "scrap your boilerplate" approach
15:46:01 <jethr0> or is there another way to write and read for example a Map to/from a file?
15:46:19 <Quadrescence> jethr0: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/BitSyntax >
15:46:22 <Quadrescence> ?*
15:46:22 <lambdabot> Title: HackageDB: BitSyntax-0.3.2, http://tinyurl.com/6gqjx7
15:46:22 <lambdabot> Maybe you meant: . ? @ v
15:46:33 <jethr0> hmm, anything i could use in the standard libs?
15:47:34 <nolrai_East> jethro0: if it doesnt need to be fast show and read work.
15:47:59 <jethr0> nolrai_East: i was just thinking that. i'll go and look what show does for an IntMap
15:48:17 <nolrai_East> IntMap (tolist x)
15:48:27 <nolrai_East> or rather
15:48:39 <nolrai_East> "IntMap" ++ show (tolist x)
15:49:05 <nolrai_East> I think
15:49:40 <vixey> "fromList " ++ show . toList $ x -- not more like this ?
15:50:41 <nolrai_East> vixey: that doesnt type check does it?
15:51:13 <nolrai_East> :t \x -> "fromList" ++ show . (Map.toList) $ x
15:51:14 <lambdabot> Couldn't find qualified module.
15:51:20 <jethr0> yes, but show is defined that way
15:51:55 <nolrai_East> :t \x -> "fromList" ++ show . toList $ x
15:51:56 <lambdabot> Not in scope: `toList'
15:52:05 <nolrai_East> :t \x -> "fromList" ++ show . Foldable.toList $ x
15:52:08 <vixey> "fromList " ++ (show . toList $ x) -- oh you need this
15:52:10 <lambdabot> Couldn't find qualified module.
15:52:27 <vixey> "fromList " ++ show (toList x) -- or that
15:52:55 <nolrai_East> Using $ isnt always better :P
15:55:57 <gwern> 'Ben Franklin summed it up well. In times of stress, the three best things to have are an old dog, an old wife and ready money.'
15:55:59 <gwern> er. mischan
15:56:10 <nolrai_East> hmm, is findNth a good name? for a function that looks up the Nth element in a Set using the Ord ordering?
15:56:40 <BMeph> gwern: I prefer Franklin's other well-known quote:
15:56:51 <kryptiskt> nolrai_East, sounds good
15:57:00 <BMeph> "Beer is proof that God loves us, and wants us to be happy." :)
15:57:16 <dobblego> nolrai_East, I'd use (!) or some such
15:57:24 <gwern> BMeph: 'God has an inordinate fondness for beetles.' J.B.S Haldane
15:58:00 <chrisdone> > let toLetters = first $ map fst . sortBy (comparing snd) . zip ['B','G','C'] in ([1,2,0],50)
15:58:01 <lambdabot>  ([1,2,0],50)
15:58:03 <chrisdone> I love that ^
15:58:10 <BMeph> gwern: Hm, sorry, don't know of any (other) Haldane quotes off-hand. :)
15:58:29 <chrisdone> wait
15:58:53 <chrisdone> > let toLetters = first $ map fst . sortBy (comparing snd) . zip ['B','G','C'] in toLetters ([1,2,0],50)
15:58:54 <lambdabot>  ("CBG",50)
15:58:57 <nolrai_East> dobblego: Im thinking of useing (!!!) for a slight variation that errors insted of failing.
15:59:04 <chrisdone> ^ _^
15:59:27 <dobblego> nolrai_East, just return Maybe then compose with fromMaybe
15:59:35 <BMeph> chrisdone: Well chris! ;p
15:59:35 <chrisdone> arrows++
15:59:51 <chrisdone> bmeph: did you mean to say "well done"?
16:00:03 <chrisdone> one must not hesitate when punning!
16:00:50 <BMeph> chrisdone: If I had, I would've! Besides, you must hear "well done" all the time; I wanted youto hear something a little less typical. :)
16:01:41 <chrisdone> bmeph: sure, sure ;D
16:01:46 <nolrai_East> dobblego: yeah. but fail works in Either and IO also, but "t !!! n = fromMaybe (error "errMsg") $ findNth n t"
16:02:38 <nolrai_East> what infix is (!!) and (!)?
16:06:43 <rwbarton> nolrai_East: is this for Data.Set?  Maybe you should imitate elemAt
16:06:45 <rwbarton> @hoogle elemAt
16:07:00 <lambdabot> Data.Map.elemAt :: Int -> Map k a -> (k, a)
16:07:43 <nolrai_East> @src elemAt
16:07:43 <lambdabot> Source not found. My mind is going. I can feel it.
16:08:02 <nolrai_East> rwbarton: thanks!
16:11:09 <gwern> BMeph: '# George Dyson points out that the possibility of evolving away from human intelligence is ‚Äúa risk,‚Äù citing J.B.S. Haldane, who pointed out in 1928 that ‚Äúthe ancestors of oysters and barnacles had heads. Snakes have lost their limbs and ostriches and penguins their power of flight. Man may just as easily lose his intelligence.‚Äù'
16:11:32 <nolrai_East> Is there a reason elemAt, and deleteAt aren't in Set?
16:12:05 <mjrosenb> :t elemAt
16:12:06 <lambdabot> Not in scope: `elemAt'
16:12:24 <nolrai_East> :t Data.Set.elemAt
16:12:25 <lambdabot> Not in scope: `Data.Set.elemAt'
16:12:34 <nolrai_East> :t Data.Map.elemAt
16:12:34 <lambdabot> forall k a. Int -> M.Map k a -> (k, a)
16:12:42 <mjrosenb> i see
16:12:52 <lament> gwern: i can't wait
16:13:20 <nolrai_East> for humans to lose are inteligence?
16:13:29 <nolrai_East> s/are/our
16:15:38 <nolrai_East> It be nicer to use fail instead of error, but I guess consitency is worth it.
16:17:18 <Adamant> gwern: a snake's limb isn't as crucial for it as our intelligence is for us
16:17:42 <Adamant> without intelligence we are naked easy to eat hairless apes
16:19:16 <pjdelport> BMeph: that's a misquote;  Franklin praised wine, not beer
16:19:20 <lament> Adamant: we won't need intelligence after we develop robots that can take care of us and fix themselves.
16:19:20 <kryptiskt> Snakes lost their limbs because they got something "better", just losing intelligence isn't exactly something that would be all that great for survival.
16:19:52 <Adamant> lament: that presumes that we're smart enough to do that, and that the robots would let us survive
16:20:28 <nolrai_East> well being slight unintelighent is mostlikely good for an individuals fitness, because it helps prevent education which really reduces the number of children.
16:20:31 <lament> Adamant: i'm not sure what do you mean by "let us". I wouldn't expect AI panic in a programming channel.
16:20:56 <nolrai_East> AI panic
16:20:58 <nolrai_East> ?
16:21:01 <kryptiskt> the robots would of course be haskell inside
16:22:46 <Adamant> lament:  it depends on how smart the AI's will be
16:23:38 <Adamant> obviously very few people are afraid of Roombas
16:23:45 <chrisdone> oh great. now _I_ need the function to split a list by a number [1,2,3,4,5,6,7,8,9] => [[1,2,3],[4,5,6],[7,8,9]]
16:23:52 <chrisdone> is there an agreed name for this?
16:24:11 <vixey> chunks
16:24:16 <chrisdone> @src chunks
16:24:17 <lambdabot> Source not found. Just try something else.
16:24:22 <chrisdone> thanks
16:24:30 <BMeph> blow chunks... ;p
16:24:39 <chrisdone> chunks :: Int -> [a] -> [[a]]?
16:25:11 <chrisdone> wonder if it's in a library
16:25:14 <chrisdone> @hoogle chunks
16:25:14 <lambdabot> Data.ByteString.Lazy.fromChunks :: [ByteString] -> ByteString
16:25:14 <lambdabot> Data.ByteString.Lazy.toChunks :: ByteString -> [ByteString]
16:25:14 <lambdabot> Data.ByteString.Lazy.Internal.foldrChunks :: (ByteString -> a -> a) -> a -> ByteString -> a
16:25:20 <chrisdone> nay lad
16:25:34 <vixey> gwern might know
16:26:07 <nolrai_East> I think people keep almost adding it to Data.List.
16:26:11 <lament> Adamant: Don't forget the birds who might suddenly all go crazy and peck us to death. And aliens, who land in their saucers and annihilate our cities.
16:26:49 <chrisdone> nolrai_East: cool
16:27:14 <Adamant> lament: we know more about birds than AI's at this point
16:27:58 <BMeph> chrisdone: It's easy enough to write, so it's "left as an exercise..." ;)
16:28:16 <byorgey> chrisdone: yeah, it's not in a library.  try chunks n = takeWhile (not . null) . map (take n) . iterate (drop n)
16:28:18 <pjdelport> "I've noticed lately that the paranoid fear of computers becoming intelligent and taking over the world has almost entirely disappeared from the common culture. Near as I can tell, this coincides with the release of MS-DOS."
16:28:24 <vixey> What's the most efficient implementation?
16:28:30 <chrisdone> BMeph: `forever' is easy to write but it's still in Control.Monad
16:28:36 <lament> pjdelport: apparently Adamant never used MS-DOS :)
16:28:44 <chrisdone> byorgey: yeah
16:28:45 <Adamant> lies
16:28:54 <Adamant> MS-DOS 3.0 for life
16:28:59 <hackage> Uploaded to hackage: darcs-graph 0.3.2
16:29:27 <byorgey> darcs-graph?
16:29:29 <chrisdone> vixey: tail recursive with (:) and then reverse?
16:29:30 * byorgey is curious
16:29:56 <vixey> chrisdone: no
16:30:05 <chrisdone> vixey: oh
16:30:33 <byorgey> most efficient implementation of chunks?
16:31:17 <thetallguy> oh, I did some work on that
16:31:22 <thetallguy> let me dig it up.
16:31:34 <byorgey> the one I gave is probably pretty fast, but at some level it just depends on how much is optimized away by the compiler I guess
16:33:08 <chrisdone> chunks thread!!1 http://hpaste.org/9079
16:35:21 <byorgey> http://hpaste.org/9079#a1
16:35:55 <byorgey> but I'm not sure that the accumulating-parameter version really buys you anything, does it?
16:35:58 <thetallguy> I added two iterations of a source file
16:36:13 <thetallguy> one has 4 implementations of chunks and a timing loop
16:36:30 <chrisdone> byorgey: well I figured tail recursive would make it better but maybe ghc optimises that anyway
16:36:58 <chrisdone> byorgey: and yeah I was about to paste a splitAt version
16:37:11 <vixey> tail recursive isn't good
16:37:14 <byorgey> chrisdone: tail recursion isn't the magic bullet in Haskell that it is in other languages, because of lazy evaluation
16:37:29 <byorgey> instead, you want guarded recursion
16:37:33 <chrisdone> byorgey: I figured it was because of dons's OMG TAIL RECURSION blog post
16:37:38 <nolrai_East> is there a name for the sort of transpose of chunks. i.e. f 3 [0..10] = [[0,3,6,9], [1,4,7,10], [2,5,8]]
16:37:39 <chrisdone> byorgey: what's that?
16:37:44 <byorgey> where the recursive calls are "guarded" behind a constructor
16:37:57 <byorgey> so the recursive calls won't actually be made until the value is demanded
16:38:05 <chrisdone> tail recursion modulo cons?
16:38:09 <byorgey> e.g.  f n = f (n+1) is bad
16:38:16 <byorgey> but f n =  n : f (n+1)  is great
16:38:18 <chrisdone> yeah
16:38:34 <byorgey> chrisdone: yeah, but it doesn't just have to be cons, it could be any data constructor
16:38:45 <chrisdone> byorgey: aye
16:39:08 <byorgey> don't get me wrong, it's not that tail recursion is bad per se.
16:39:11 <TSC> nolrai_East: I'd call the opposite of that "weave", so transpose+chunks would be "unweave" (:
16:39:35 <nolrai_East> I like that
16:39:41 <byorgey> I like that too =)
16:40:32 <byorgey> let chunks n = takeWhile (not . null) . map (take n) . iterate (drop n); unweave n = transpose . chunks n  in unweave 3 [1..10]
16:40:36 <byorgey> > let chunks n = takeWhile (not . null) . map (take n) . iterate (drop n); unweave n = transpose . chunks n  in unweave 3 [1..10]
16:40:51 <lambdabot>  thread killed
16:40:52 <byorgey> oh. no lambdabot? =(
16:41:03 <byorgey> > let chunks n = takeWhile (not . null) . map (take n) . iterate (drop n); unweave n = transpose . chunks n  in unweave 3 [1..10]
16:41:15 <chrisdone> byorgey: so just http://hpaste.org/9079#a2 ?
16:41:18 <lambdabot>  thread killed
16:41:25 <ertai> chrisdone: I can't find that "dons's OMG TAIL RECURSION" blog post
16:41:52 <vixey> > let unweave (x:y:z:s) = [x,y,z] : unweave s in unweave [1..]
16:41:55 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19,20,21],[22,23,...
16:42:02 <byorgey> chrisdone: right, that looks good to me
16:42:06 <dons> dcoutts: any thoughts why we just don't use a database for the package system?
16:42:09 <dons> sqlite or something.
16:42:20 <dcoutts_> dons: because haskell data types are better
16:42:32 <chrisdone> ertai: http://cgi.cse.unsw.edu.au/~dons/blog/2008/05/16#fast
16:42:39 <byorgey> vixey: that's chunks, not unweave
16:42:39 <dons> well, you can read and write those into sqlite.
16:42:42 <dcoutts_> eg it's easy to construct and cache an inverse dep graph index
16:42:44 <dons> the point would be fast extraction.
16:42:46 <mar77a> Database x = x : Database x
16:43:01 <dons> i guess we need to know what the key operations on the package db are.
16:43:05 <dcoutts_> dons: you can't beat in memory persistent Haskell data structures for speed :-)
16:43:31 <byorgey> dons: http://luqui.org/blog/archives/2008/07/18/semantic-design/  =)
16:43:33 <lambdabot> Title: Semantic Design @ The dreams that stuff is made of
16:43:40 <dons> byorgey: i liked that :)
16:43:44 <Armored_Azrael> dcoutts_: Unless they grow beyond memory size, but I suppose the package system is nowhere near that at the moment
16:43:45 <byorgey> me too
16:43:58 <dons> this luqui fellow has a clear head.
16:44:16 <byorgey> indeed he does.
16:44:19 <dcoutts_> dons: I've been converting a few of the existing hackage-scripts cgi pages to the new HAppS hackage-server. It's amazing how much simpler they become when you work with pure haskell types, no silly fiddling with multi-stage queries in IO
16:44:39 <dons> ok. nice.
16:44:54 <dons> that was the main benefit of happs
16:45:04 <dcoutts_> dons: eg the script to generate the package index html page has to do lots of IO, scan dirs, scan more dirs, pick highest versions and then read and parse .cabal files.
16:45:31 <dcoutts_> dons: the new version just keeps the PackageIndex as the server state so one query and a list comprehension and it's done.
16:45:47 <ertai> chrisdone: thx
16:45:51 <dcoutts_> dons: not only easier to write but also considerably faster. No parsing. All the data was cached.
16:46:05 <MyCatVerbs> dcoutts_: you can easily beat in-memory persistent data structures for speed.
16:46:06 <dons> that should really improve hackage, yes.
16:46:14 <dons> i was thinking about ghc's package index, btw, ghc.
16:46:21 <MyCatVerbs> dcoutts_: but only for those domains where in-register persistent data structures are feasible. ;P
16:46:22 <dcoutts_> dons: ohh
16:46:30 <dons> but yes, happs makes that kind of thing nice :)
16:46:36 <dcoutts_> MyCatVerbs: heh
16:46:57 <dcoutts_> dons: so yeah, that's a benefit of happs. That and never having to worry about data updates.
16:47:22 <dcoutts_> updating the server state does not affect any existing client conections that are working with older state snapshots
16:47:33 <dcoutts_> all because of Haskell persistent data structures
16:49:03 <dons> dcoutts is web 2.0 fiend.
16:49:05 <dcoutts_> Armored_Azrael: I'm not nearly worried about that yet. The entire archive currently fits in memory and that's including all the huge tarballs. Since we're only keeping the index/meta-data in memory, the requirements are currently only a few Mb.
16:49:11 <dcoutts_> dons: heh
16:49:59 <dcoutts_> dons: I think I'm being won over, the happs architecture is pretty slick and really shows off Haskell's strengths
16:50:13 <dcoutts_> I grumble about missing features though :-)
16:50:14 <MyCatVerbs> BTW, I have a program that allocates in a place where I -think- it shouldn't. Not sure why. http://hpaste.org/9083
16:50:25 <dcoutts_> like http caching hints
16:50:37 <dcoutts_> or support for more transparent caching
16:52:06 <dons> dcoutts_: i'm putting together an HLP plan, btw.
16:52:23 <dcoutts_> dons: ok, did you read the #ghc meeting irc log?
16:52:33 <dons> ah from last friday? missed that.
16:52:47 <dons> euro timezoen bias grumble
16:52:52 <dcoutts_> dons: you should probably read the log. We agreed to cut down the initial HLP release to the bare minimum.
16:52:56 <dons> ok.
16:52:57 <dons> yes,
16:53:02 <Armored_Azrael> dcoutts_: Yeah, that's kind of what I expected :P
16:53:09 <dons> just get the process in place.
16:53:16 <dcoutts_> dons: right, to make it easier and so we can put in some QA barriers for new packages
16:53:31 <nolrai_East> So I have added elemAt, findIndex, and lookupIndex to Data.Set any way to get this change to the standard library?
16:53:45 <dcoutts_> dons: joining the platform is the carrot we can use to get QA improvements out of packages
16:53:59 <dcoutts_> so we should not waste that opportunity by letting in too many initially
16:54:05 <Zao> Is there any particular reason there's both a Codec and Codecs section on hackage?
16:54:24 <dcoutts_> dons: http://haskell.org/~duncan/ghc/%23ghc-2008-07-16.log
16:54:36 <dcoutts_> Zao: distributed name choices
16:54:59 <Zao> Ah.
16:55:09 <osfameron> dammit, perl is insufficiently haskell-like (and vice versa)
16:55:10 <MyCatVerbs> dons: could you take a quick peek at that last hpaste, please? I have lots of memory being allocated in the "free" function and I'm not quite sure why.
16:55:42 <Armored_Azrael> nolrai_East: I'm no expert, but to the best of my knowledge, Sets are purposely considered as unordered from the interface perspective.
16:55:54 <gwern> Adamant: dunno, for lots of creatures limbs are really really important. things may not be as important as they seem. take consciousness, for example. I recently read a very interesting SF novel, _Blindsight_ by Peter Watts, which does a surprisingly persuasive job of arguing that consciousness isn't necessary for human levels of intelligence and beyond
16:56:07 <Armored_Azrael> nolrai_East: Err, I meant unindexed, not unordered
16:56:16 <byorgey> nolrai_East: http://haskell.org/haskellwiki/Library_submissions
16:56:17 <lambdabot> Title: Library submissions - HaskellWiki
16:57:00 <dcoutts_> dons: so andy was looking for speakers for the HS 10-min demo slots. I was thinking you and/or I could talk about the HLP concept since we need buy-in from maintainers and we need to change the expectations of users.
16:57:05 <MyCatVerbs> dons: I've tried manually altering it so that the number being iterated on is an Int# instead of an Int - no reduction in allocation. (from ghc-core's output, it looks like the compiler is doing that for me anyway)
16:57:19 <dcoutts_> dons: there's also the possibility that I might do a 10-min cabal-install demo
16:57:38 <nolrai_East> That very irritating because a type thats just like Set but with indexing is very useful.
16:57:45 <MyCatVerbs> dcoutts_: don't you mean a thirty-second cabal-install demo? ;P
16:57:53 <MyCatVerbs> dcoutts_: it's supposed to be that easy, isn't it? :D
16:57:57 <dcoutts_> MyCatVerbs: since it's sooo quick! :-)
16:58:01 <Adamant> gwern: you got a point, but humans are pretty much walking meat platters without intelligence and the socialization that flows from it
16:58:11 <dcoutts_> cabal install EVERYTHING!!!
16:58:12 <dcoutts_> demo over
16:58:25 <MyCatVerbs> gwern: hang on, how're you defining "consciousness" there?
17:00:09 <chrisdone> @all-dicts consciousness
17:00:10 <lambdabot> *** "Consciousness" gcide "The Collaborative International Dictionary of English v.0.48"
17:00:10 <lambdabot> Consciousness \Con"scious*ness\, n.
17:00:10 <lambdabot>    1. The state of being conscious; knowledge of one's own
17:00:10 <lambdabot>       existence, condition, sensations, mental operations, acts,
17:00:10 <lambdabot>       etc.
17:00:12 <lambdabot> [68 @more lines]
17:01:46 <gwern> MyCatVerbs: oh, don't start with an argument that intelligence and consciousness overlap too much to distinguish -_-
17:03:20 <gwern> man, I've been spending so much time playing Crawl lately, and so little on haskell
17:03:25 * gwern blames shachaf 
17:03:38 <bwr_> what's crawl?
17:03:40 <bwr_> or should i not ask
17:04:14 <gwern> bwr_: a Roguelike. more advanced and autoamted than nethack, with a lot of the bullshit stripped out
17:04:21 <bwr_> ah
17:04:22 <bwr_> cool
17:04:25 <gwern> (is my pithy summary)
17:04:44 <nolrai_East> where is it at?
17:05:34 <bwr_> i've never even gotten close to beating nethack yet
17:05:34 <gwern> ##crawl
17:05:57 <carl> is there a function like iterate but "iterate n times"
17:06:00 <chrisdone> is it written in haskell?
17:06:02 <gwern> nolrai_East: also, https://secure.wikimedia.org/wikipedia/en/wiki/Linley's_Dungeon_Crawl
17:06:04 <lambdabot> http://tinyurl.com/55h9y5
17:06:12 <gwern> chrisdone: alas...
17:06:22 <gwern> there are very few roguelikes at any stage in haskell
17:06:27 <gwern> iirc, there are 2 :)
17:06:40 <chrisdone> gwern: hehe
17:08:00 <bwr_> i've always wanted to make a fallout like roguelike
17:08:28 <chrisdone> > let fooble n f s = take n $ iterate f s in fooble 5 (+1) 0
17:08:29 <lambdabot>  [0,1,2,3,4]
17:09:22 <chrisdone> > let fooble n = (take n .) . iterate in fooble 5 (+1) 0
17:09:23 <lambdabot>  [0,1,2,3,4]
17:09:35 <chrisdone> @pl (\n -> (take n .) . iterate)
17:09:36 <lambdabot> (. iterate) . (.) . take
17:09:38 <chrisdone> ew
17:09:42 <the_edge> hi all, where can I get information on the $ operator? Google doesn't like the $ in my queries :/
17:09:49 <chrisdone> @src ($)
17:09:49 <lambdabot> f $ x = f x
17:09:50 <chrisdone> @hoogle ($)
17:09:51 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
17:09:51 <lambdabot> Data.Function.($) :: (a -> b) -> a -> b
17:09:51 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
17:10:05 <the_edge> nice
17:10:06 <chrisdone> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v%3A%24
17:10:07 <lambdabot> Title: Prelude, http://tinyurl.com/ovjef
17:10:20 <the_edge> chrisdone: thanks
17:10:26 <chrisdone> np
17:11:10 <carl> whoops i asked the wrong question i need to iterate until n is true
17:11:32 <chrisdone> takeWhile (not . p) ?
17:11:49 <carl> yea thatll probaly work
17:12:28 <chrisdone> > let fooble p = (takeWhile (not . p) .) . iterate in fooble (==25) (+1) 0
17:12:30 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24]
17:14:18 <nolrai_East> carl: until
17:14:25 <chrisdone> > first (join (*)) >>> second ((+1) *** (-1)) $ (12,(0,0))
17:14:26 <lambdabot>   add an instance declaration for (Num (b' -> c'))
17:14:32 <MyCatVerbs> gwern: I'm not going to _argue_ that, but... it's the first thing that pops into my head. The capability for abstract reasoning presumably gets you self-awareness (one's reasoning would be rather badly impaired without if one couldn't reason about systems that include oneself) too, and once you have that, what else is there?
17:15:38 <MyCatVerbs> gwern: I'm not arguing contrariwise, I'm asking for clarification, because I can't think of any workable system where you divorce intelligence and consciousness.
17:15:39 <gwern> MyCatVerbs: qualia!
17:15:47 * gwern is only half-kidding there
17:16:12 <MyCatVerbs> Damn yuoes for making me learn a new word.
17:17:14 <bwr_> huhu
17:17:23 <pjdelport> rigorous definitions of "consciousness" and "intelligence" pending
17:17:47 <MyCatVerbs> gwern: okay, but doesn't qualia alone get you... about the same level of intelligence as a stoned cow?
17:17:52 <chrisdone> :t (-1)
17:17:53 <lambdabot> forall a. (Num a) => a
17:18:07 <chrisdone> :t ((+1)***(-1))
17:18:08 <lambdabot> forall b b' c'. (Num (b' -> c'), Num b) => (b, b') -> (b, c')
17:18:16 <gwern> MyCatVerbs: but seriously, if you look at examples of AI systems which do in fact contain metadata about themselves and reason about how to improve themselves, like Eurisko, the reasoning doesn't seem to have much in common with consciousness. how much of your own consciousness is strictly devoted to optimization computations and hypothesis checking etc?
17:18:28 <chrisdone> :t ((+1)***(+1))
17:18:29 <lambdabot> forall b b'. (Num b', Num b) => (b, b') -> (b, b')
17:18:47 <chrisdone> (-) can be really annoying
17:18:57 <gwern> primitive examples, to be sure, but one wonders whether there's really going to be a difference in quality, not just kind, if they are scaled up to human intelligence levels
17:19:12 <kryptiskt> gwen: how do you know how it feels to be Eurisko?
17:19:41 <gwern> kryptiskt: ask that again, and I shall turn you into a bat
17:19:51 <kryptiskt> :-)
17:19:54 <bwr_> lol
17:20:07 <MyCatVerbs> gwern: *blinks*
17:20:12 <MyCatVerbs> gwern: do they, uh, work?
17:20:27 <chrisdone> yeah, but, dracula, what's it like to be a bat? umm, scratch that
17:20:48 <gwern> MyCatVerbs: what, eurisko and friends? about as well as you would expect of such primitive things
17:21:12 <MyCatVerbs> gwern: so, what, they fall into infinite loops all the time?
17:21:44 <nolrai_East> wow some of the arguments on wikipedia about qualia seem really bad. "I can imagine it there for it must be logicly consitant"!?
17:21:46 * chrisdone ponders whether my mind is in many infinite loops simultaneously right now
17:21:47 <MyCatVerbs> gwern: I mean, that's what *I* would expect them to do, because the whole idea sounds like a great way to repeatedly run head-first into Turing-complete problems.
17:23:09 <MyCatVerbs> #define EVAR (;;) \n for EVAR { fposition = find(food); fhandle = acquire(OBJECT_AT,fposition); hunger -= consume(fhandle); } // mine is. When's dinner?
17:23:22 <gwern> MyCatVerbs: iirc, what happened with eurisko and the most advanced automated mathematician systems was that they would, say, start coming up with basic arithmetic and devise any number of interesting and valid results, and then stall out at Goldbach's Conjecture
17:23:50 <chrisdone> I think right now I generally agree with Hume and Kant that what can be imagined is limited to what has been experienced; that is, that sensory input is like lego blocks, and you can use those lego blocks to build complex ideas, but not make new lego blocks from scratch. that's what I think right now, anyway, I'm open to new ideas
17:23:52 <gwern> kind of like evolutionary systems; you get interesting results, and then novelty peters out
17:24:09 <kryptiskt> humans stall out at Goldbach too, so they don't have to feel too bad
17:24:50 <MyCatVerbs> kryptiskt: yes, but you can smack a human and tell them to go concentrate their efforts elsewhere.
17:24:59 <MyCatVerbs> kryptiskt: they will even, no less, smack themselves.
17:25:16 <gwern> and there is some question about the validity of the results, alas. I've seen people point out that the source code for eurisko is conveniently lost, and hint that Lenat did a lot of the creative thinking eurisko was famous for
17:25:33 <lament> chrisdone: "what has been experienced" is vague. I'm sure every photosensory cell in my retina has been through the full range of its possible inputs by now.
17:25:33 <kryptiskt> MyCatVerb, easy enough to make a program that gets bored by repetition
17:25:51 <lament> chrisdone: likewise, my eardrums, etc.
17:25:58 <MyCatVerbs> Was Lenat the same guy who wrote ELIZA and then threw the sources away, or am I losing track of my mind here?
17:26:19 <gwern> MyCatVerbs: iirc, eliza's source is still around, as is shrdlu's
17:26:37 <MyCatVerbs> lament: nonsense. Why, you haven't even stood at the epicenter of even one hydrogen bomb's detonation, let alone enough to get a proper sampling. :D
17:26:41 <gwern> I think eliza was tanenbaum, but I wouldn't swear to't
17:26:42 <kryptiskt> nope eliza was weizbbaum
17:26:52 <MyCatVerbs> kryptiskt: ah, danke.
17:27:27 <kryptiskt> he wrote an AI (and computer) skeptic book later
17:27:29 <chrisdone> lament: yes. but I ponder whether the concept of a triangle can exist properly as a fundamental "building block" without seeing one before. we can talk about hypercubes but can't concieve of it because we can't perceieve it, so my hypothesis goes
17:27:30 <pjdelport> cue Feynman anecdote
17:27:30 <MyCatVerbs> I thought I remembered something about the person who wrote ELIZA deliberately throwing it away because his students kept playing with it instead of doing more serious research. ;)
17:27:51 <chrisdone> pjdelport: haha
17:28:06 <kryptiskt> weizenbaum it was
17:28:16 <gwern> kryptiskt: I got the name right if you accept rhymes! :)
17:29:12 <lament> chrisdone: still vague, i've never seen a blue snail but i can definitely imagine one
17:29:29 <chrisdone> lament: yes, that's a complex idea
17:29:30 <lament> or are blue snails somehow less fundamental than triangles?
17:29:45 <chrisdone> lament: can you imagine a puralia snail? (where puralia is a new colour)
17:29:58 <chrisdone> lament: I'd say so
17:30:29 <chrisdone> lament: or a five dimensional snail, etc.
17:31:14 <kryptiskt> I think the human mind is way more suited to contemplating snails (edible? non-edible?) than triangles
17:31:38 <nolrai_East> I aggree with kryptiskt
17:31:39 <lament> electrons are pretty fundamental and some people are quite good at imagining them
17:31:56 * byorgey perceives snails in terms of their fundamental hypercubes
17:31:56 <nolrai_East> chrisdone: sort of
17:32:15 <osfameron> mmm, hypercubes...
17:32:40 <chrisdone> lament: well my point is that that imagining is a complex idea built from more fundamental ones
17:33:35 <chrisdone> lament: I will say here that I am doubtful about how meaningful this is, or if it can be proven with evidence, and if it were how useful it would be. it seems the whole qualia issue is like that, to me
17:34:03 <lament> a bunch of math objects are fairly easily imagined by mathematicians
17:34:19 <kryptiskt> I think humans generally struggle with abstraction, I for one always need plenty of concrete examples to learn abstract ideas.
17:34:21 <lament> without any meaningful sensory connotations
17:34:36 <chrisdone> I don't think you are understanding my meaning
17:34:48 <kryptiskt> nope, too abstract :-)
17:35:45 <nolrai_East> when i do math its always on some set of symbols or something. err
17:35:48 <lament> i guess not :)
17:36:23 <kryptiskt> my point is that our brain isn't some logic machine, it's a jury-rigged contraption to help us get food, friends and sex. It's the Perl of intelligences.
17:36:43 <nolrai_East> heh
17:37:03 <nolrai_East> @help qoute
17:37:03 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:37:08 <nolrai_East> @help quote
17:37:08 <lambdabot> quote <nick>
17:37:08 <lambdabot> remember <nick> <quote>
17:37:08 <lambdabot> Quote somebody, a random person, or save a memorable quote
17:37:15 <lament> I don't think Perl is very good at finding friends and sex, and these days it's getting worse even for finding food ;)
17:37:21 <chrisdone> hehe
17:37:42 <nolrai_East> @remember kryptiskt my point is that our brain isn't some logic machine, it's a jury-rigged contraption to help us get food, friends and sex. It's the Perl of intelligences.
17:37:42 <lambdabot> Done.
17:39:47 <chrisdone> lament: I made an argument with someone about this idea; that person insisted that they could indeed imagine of a new colour, and gave it a name. I said ‚Äúbut you can't concieve of it‚Äù and they said ‚Äúhow do you know?‚Äù which made me ponder the futility of the subject matter
17:41:17 <gwern> two Taoists were standing on a bride on a hot summer day. 'Ah, it would be so nice to be one of those fishes swimming in the cool water', said one.
17:41:19 <chrisdone> lament: they said ‚Äúit's a blue-ish yellow-ish colour‚Äù, which sort of demonstrated my point of building complex ideas from fundamentals, but continued to disagree
17:41:40 <gwern> the other rebuked him: How do you know it would be so nice to be one of them? You are not a fish!
17:42:04 <gwern> he replied, And who are you to know that I do not know that it would be nice to be a fish today?
17:42:21 <chrisdone> gwern: haha, yes
17:43:48 <pjdelport> gwern: why were they standing on a bride?
17:44:20 <nolrai_East> because they were useing her as a bridge?
17:45:14 <gwern> *bridge
17:45:29 <gwern> dammit if you want correct spelling, go read the original in Chuan Tzu
17:45:52 <gwern> *Chuang, thus I prove my point
17:46:52 <chrisdone> (I thought a bride was archaic speak for some kind of garden furnature)
17:47:23 <bwr_> ...
17:47:32 <chrisdone> ;_;
17:47:48 <bwr_> <*))>=<
17:47:51 <nolrai_East> where is a/the darcs repository for the standard haskell libraries?
17:47:55 <chrisdone> piscus
17:48:26 <BMeph> pjdelport: Maybe she was accused to be a witch, so... :)
17:48:49 <nolrai_East> bwr_: now do a hot chines philosopher on a bridge (or a bride)
17:49:00 <bwr_> that one is hard
17:49:02 <chrisdone> BMeph: hehe
17:49:26 <pjdelport> BMeph: haha
17:49:49 <lament> chrisdone: firstly, how else would he describe the color to you? And secondly, I personally can't imagine a color I haven't seen, but I've read experiences of people on LSD who reported augmented senses such as panoramic vision
17:51:33 <dublpaws> he could tell you the wavelength
17:52:17 <nolrai_East> but thats the light not the color.
17:52:19 <chrisdone> lament: the point is he's not supposed to describe it because it's supposed to be fundamental. but it was not fundamental, it was complex, because he made it out of two other ideas. and yes, altering sensory input would cause new perceptions, I'd agree. the point is you can't make those purely through thought alone, you need outside input
17:52:56 <lament> chrisdone: No outside input is anything like panoramic vision.
17:53:34 <chrisdone> lament: I'm quite sure using drugs to physically change your brain's function is outside input
17:54:00 <chrisdone> s/function/functioning, perhaps
17:56:15 <byorgey> hmm, looks like xmonad is correctly installed
17:56:16 <chrisdone> lament: I don't know if that is analagous to the colour example, though
17:56:21 <byorgey> oops, mischan =P
17:57:17 <chrisdone> lament: keeping ontopic with the channel, my belief is something like Concept = Fundamental | Complex Concept Concept :P
17:57:55 <chrisdone> lament: well, I don't *believe* it, but it's a way of looking at it
17:58:25 <byorgey> chrisdone: there is only one Fundamental concept? ;)
17:59:02 <chrisdone> byorgey: you know what I meant :P
17:59:06 <gwern> byorgey: well, we only need one combinator
17:59:18 <byorgey> chrisdone: hehe, yes =)
18:00:08 * gwern pushes some more mueval changes. things are looking up - faster and more securer than the previous releases
18:00:17 <chrisdone> gwern: yay!!
18:00:46 * gwern wonders whether chrisdone actually uses mueval or is just being cheerful
18:00:47 <pjdelport> securer and securerer
18:01:05 <chrisdone> gwern: is that hackage or darcs (I am not aware of a darcs repo.)?
18:01:15 <gwern> chrisdone: darcs
18:01:28 <chrisdone> gwern: link plox?
18:01:42 <gwern> http://code.haskell.org/mubot/
18:01:43 <lambdabot> Title: Index of /mubot
18:02:24 <chrisdone> gwern: I've looked at mueval from seeing this post: http://groups.google.co.uk/group/fa.haskell/browse_thread/thread/c430f55bca25e9c6 but IIRC it wouldn't build or something. I'll try again
18:02:25 <lambdabot> Title: ANN: Mueval 0.21 - fa.haskell | Google Groups, http://tinyurl.com/68arq5
18:02:33 <nolrai_East> so the "Library submissions" wiki page says to use darcs but i cant find a darcs repo for the hirearcical libraries.
18:02:57 <gwern> also, the hackage page lists the code.haskell link
18:03:08 <chrisdone> gwern: oh, sorry ;_:
18:04:09 <gwern> nolrai_East: well, it depends. bytestring for example has its own setup, but the rest seem to live in repos on the haskell.org servers
18:04:31 <chrisdone> oh, that's it. ‚Äúcabal: cannot configure hint-0.2.2. It requires ghc -any‚Äù what the deuce? should I remove ghc from the dependancies?
18:04:31 <gwern> nolrai_East: I always just look at what addresses the darcs-all script in the ghc darcs repo pulls from
18:05:16 <gwern> hint is a wrapper around the GHC API, I should hope it needs ghc as a dep
18:05:45 <chrisdone> I have ghc 6.8.3 installed, maybe it's expecting <6.8.3
18:06:19 <gwern> I don't know if hint is supposed to work with 6.8.3
18:06:44 <nolrai_East> gwern: thanks.
18:06:51 <gwern> chrisdone: try the hint darcs repo, http://www.glyc.dc.uba.ar/daniel/repos/hint
18:06:54 <lambdabot> Title: Index of /daniel/repos/hint
18:06:55 <chrisdone> gwern: oh, okay
18:06:57 <chrisdone> gwern: ah, thanks
18:07:04 <gwern> nolrai_East: eg, it pulls from repos like http://darcs.haskell.org/packages/ALUT
18:07:08 <lambdabot> Title: Index of /packages/ALUT
18:09:49 <nolrai_East> do you know which one Data.Set is in?
18:10:22 <byorgey> nolrai_East: that should be in the containers package
18:10:26 <gwern> base, probably. http://darcs.haskell.org/packages/base
18:10:27 <lambdabot> Title: Index of /packages/base
18:10:46 <byorgey> well, it's in pre-3.0 base, or containers otherwise
18:10:48 <gwern> ah, containers? that makes sense as well
18:11:26 <gwern> http://darcs.haskell.org/packages/containers, obviously, since they follow the standard location scheme
18:11:27 <lambdabot> Title: Index of /packages/containers
18:11:29 <byorgey> with ghc 6.8.2 base got split out into a bunch of packages, containers being one of them
18:12:08 * gwern uploads mueval 0.4.5
18:12:20 <nolrai_East> thanks
18:13:22 <nolrai_East> copying patch one of 1822. hmm
18:13:53 <byorgey> nolrai_East: have fun with that =)
18:14:35 <gwern> I guess the lib maintainers don't believe in checkpointing
18:15:18 <gwern> or nolrai_East in --partial/--lazy. 'sall good
18:29:00 <hackage> Uploaded to hackage: mueval 0.4.5
18:32:07 <chung> hi
18:32:25 <chung> I am new to Haskell
18:32:33 <chung> but I love it
18:32:41 <chung> anybody here?
18:33:01 <Saizan_> we love it too :)
18:34:22 <chung> :)
18:39:46 <newsham> hi
19:00:44 <chrisdone> I am sooo buying a whiteboard tomorrow
19:01:26 <Spark> it's not like they cost much
19:01:47 <Spark> i find they look ugly on the wall theough
19:01:55 <chrisdone> yeah. my desk is full of pieces of paper with old notes
19:01:56 <Spark> i just use paper these days
19:02:19 <chrisdone> you mean, you have space to fit a whiteboard on your wall?
19:02:36 <Spark> yeah
19:02:37 <chrisdone> where do you fit your SICP and Peyton `Simon` Jones posters?
19:03:01 <Spark> whiteboards are more important
19:03:06 <Spark> but i don't like posters either now
19:03:21 <Spark> now it's just framed paintings/prints
19:03:30 <Spark> posters look ok to start with but then start looking crap
19:03:33 <chrisdone> good point. a sicp tattoo is probably better for showing loyalty
19:04:14 <chrisdone> paintings of what?
19:04:26 <chrisdone> (besides lambdas)
19:05:58 <Spark> anything i can get my hands on that isn't awful
19:06:01 <Spark> paintings are expensive
19:08:07 <chrisdone> yay my `concepts of modern mathematics' has arrived
19:10:15 <carl> how would you do something like this inside a do statement without getting out of scope errors
19:10:19 <carl> width <- hGetTWord8 datFile
19:10:21 <carl> hieght <- hGetTWord8 datFile
19:10:24 <carl> case (or [(getTWord8 width) > 1, (getTWord8 height) > 1]) of
19:10:36 <chrisdone> height is spelled incorrectly?
19:10:56 <carl> lol
19:11:01 <carl> i hate my life
19:11:04 <chrisdone> hahaha
19:11:37 <bwr_> lol
19:11:38 <chrisdone> easy mistake. I spent ages the other day trying to find out why ‚ÄúClonfig‚Äù (correct: Config) was wrong
19:12:07 <bwr_> chrisdone: who is the author?
19:12:15 <bwr_> (concepts of modern mathematics)
19:12:17 <chrisdone> bwr_: Ian Stewart
19:12:35 <chrisdone> bwr_: it's supposed to be approachable for the layman, which is what I am
19:12:41 <bwr_> ah
19:12:59 <bwr_> that's cool
19:13:03 <chrisdone> ^_^
19:13:05 <bwr_> i've been trying to learn more math
19:13:25 <bwr_> i am currently working on principles of math analysis by rudin
19:13:59 <bwr_> well, taking a break currently to participate and practice for google code jam
19:15:06 <chrisdone> fun
19:15:37 <chrisdone> I contacted a friend from college couple days ago; we're going to meet up tomorrow and work on some problems for fun :)
19:15:40 <bwr_> i'm participating in haskell, which i just started learning... but i have made great progress
19:15:55 <bwr_> cool
19:16:44 <bwr_> you are graduated? if so, what was your major? if you don't mind me asking
19:16:50 <chrisdone> what would you be using if you didn't know haskell?
19:17:43 <bwr_> hmm, good question. well i wouldn't really say i know haskell :P but i'd probably use one of the other languages i have some familarity with such as C, C++, Java, or Ruby
19:18:45 <chrisdone> no, I haven't majored in anything. I should have done a level maths, but I took some ‚Äúsoftware‚Äù course which turned out to be crap. I just read books and try to teach myself
19:19:12 <bwr_> ah
19:19:14 <bwr_> that's cool
19:19:32 <bwr_> i was pretty lazy in college and didn't learn too much
19:20:44 <chrisdone> it sucks but when learning is what you do for fun it's less of a pain than it would be, I guess
19:21:39 <bwr_> yea
19:21:50 <bwr_> there are some classes i enjoyed
19:22:34 <lispy> I think the type syntax in Haskell is too limiting for people that are doing typeful programming.
19:22:50 <lispy> But, I don't know what to change
19:23:03 <Saizan_> what do you miss? lambdas?
19:23:29 <lispy> Well, I'm hitting my head against an instance definition
19:23:55 <lispy> This ghc error message might help make the point:
19:23:56 <lispy>       `y' is a rigid type variable bound by
19:23:56 <lispy>           the type signature for `resolve_conflicts' at <no location info>
19:24:13 <lispy> The reason for <no location info> is because that location is at the class declaration
19:24:39 <lispy> Suppose I wanted to lexically scope over the type variables in the class declaration at the point of the instance location
19:24:43 <lispy> How would I do that?
19:24:50 <chrisdone> types are hard, let's go shopping!
19:24:59 <bwr_> shopping is fun
19:25:08 <lispy> Wow, Korollary really started something with his Barbie quoting :)
19:26:10 <lispy> Saizan_: I think what I want/need is a way to directly encode logical statments about the types.
19:26:48 <lispy> Saizan_: through various extensions, Haskell allows you to specify quite about the relationships of the types, but it's often in an indirect way
19:27:08 <chrisdone> :]
19:27:55 <lispy> And also, I don't have a type inference inspector.  Man that would be nice.
19:28:22 <Saizan_> lispy: right, typefamilies might be helpful there, however you can usually use asTypeOf somehow in place of ScopedTypeVariables
19:28:24 <lispy> "GHC, why did you infer x instead of y??"  "Oh, because of this line...which then lead me to the following conclusion." "Oh!  <changing the code>"
19:28:53 <Saizan_> yeah, a typechecking debugger would be neat :)
19:28:58 <nybyn> lispy, indeed, that would be nice!
19:29:27 <lispy> Not only would be it cool for users, it would be worth at least 2 research papers
19:29:47 <lispy> 1 paper explaining how it was done and 1 paper showing how it was improved based on a user study
19:30:30 * lispy points at the GHC source hoping someone will start working on it
19:31:49 <lispy> ?pl \x y -> foo (bar x y)
19:31:49 <lambdabot> (foo .) . bar
19:33:55 <lispy> heh
19:33:56 <lispy>     deps  not in scope because it has a wobbly type (solution: add a type annota
19:33:59 <lispy> tion)
19:34:09 <lispy> Silly wobbly type!
19:35:40 <Saizan_> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/TypeIlluminator <-- there's a precedent prototype at least :)
19:35:42 <lambdabot> Title: HackageDB: TypeIlluminator-0.0, http://tinyurl.com/5pvl5j
19:36:22 <nybyn> ?pl (\x y -> g (f x) (f y))
19:36:23 <lambdabot> (. f) . g . f
19:36:46 <lispy> Saizan_: oh that is cool.  Algorithmic debugging can be handy
19:37:42 <lispy> Saizan_: but if it's just a prototype I seriously doubt it will work correctly on the stuff I'm doing :(
19:37:48 <lispy> Still, I great starting place for someone
19:47:43 <dons> ?users
19:47:44 <lambdabot> Maximum users seen in #haskell: 479, currently: 423 (88.3%), active: 9 (2.1%)
19:59:20 <zachk1> @src flip
19:59:20 <lambdabot> flip f x y = f y x
19:59:45 <zachk1> flip div 4 $ 1
19:59:52 <zachk1> > flip div 4 $ 1
19:59:54 <lambdabot>  0
20:00:18 <zachk1> > flip (/) 4 $ 1
20:00:21 <lambdabot>  0.25
20:01:53 <gwern> 'Generally speaking, the errors in religion are dangerous; those in philosophy only ridiculous.' -Hume
20:03:20 <zachk1> alot of philosophy is just ridiculous
20:04:32 <dons> hume was the man.
20:04:37 <dmwit> > flip div 4 1 -- no ($) necessary here
20:04:38 <lambdabot>  0
20:19:01 <Trinithis> How does Parsec's try combinator work with state? Will it keep the old state?
20:35:28 <sebaseba> Trinithis: I just tested it, and it seems the state is restored if a parser fails.
20:35:55 <sebaseba> s/fails/fails in a try combinator/
20:37:57 <Trinithis> cool
20:38:34 <Trinithis> what does "s/fails/fails in a try combinator/" mean though?
20:39:05 <mxc> sort of random thought, but i've had to do some c# coding for work lately.  really enjoyed it
20:39:09 <pjdelport> Trinithis: s/foo/bar/ means "substitute foo with bar"
20:39:20 <mxc> but only insofar as much as it made me appreciate haskell and its ilk so much more
20:39:24 <pjdelport> vi/ed slang
20:40:06 <Trinithis> mm
20:40:12 <mxc> if only s/.cs/.hs worked as well
20:44:59 <sebaseba> if I have a Map String a, and I have a function f :: a -> IO b, how can I obtain a Map String b?
20:47:38 <Saizan_> ?type \f -> fmap M.fromAscList . mapM (\(x,y) -> (,) x <$> f y) . M.toAscList
20:47:39 <lambdabot> forall a (m :: * -> *) k a1. (Monad m, Functor m, Eq k) => (a1 -> m a) -> M.Map k a1 -> m (M.Map k a)
20:47:55 <Saizan_> O(n)
20:48:21 <sebaseba> Saiza: hmm, that's sort of what I'm doing, but in a more verbose way
20:48:36 <rwbarton> Or you can use Data.Traversable.mapM
20:48:52 <rwbarton> @hoogle mapM
20:48:53 <lambdabot> Prelude.mapM :: Monad m => (a -> m b) -> [a] -> m [b]
20:48:53 <lambdabot> Control.Monad.mapM :: Monad m => (a -> m b) -> [a] -> m [b]
20:48:53 <lambdabot> Data.Traversable.mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
20:49:03 <Saizan_> oh, Map is declared as Traversable?
20:49:11 <rwbarton> Map a, yes
20:49:44 <ivanm> has anyone managed to build the new version of fgl (5.4.2.1)? I keep getting a haddock parse error for the new Patricia Tree file :s
20:49:47 <sebaseba> rwbarton: cool
20:52:12 <Saizan_> ivanm: where is it?
20:57:35 <kig> @src (>>=)
20:57:35 <lambdabot> Source not found. I am sorry.
20:58:52 <pjdelport> @src [] (>>)
20:58:53 <lambdabot> xs >> ys      = concatMap (const xs) ys
20:58:57 <pjdelport> @src Maybe (>>)
20:58:57 <lambdabot> (Just _) >>  k      = k
20:58:57 <lambdabot> Nothing  >>  _      = Nothing
20:59:14 <pjdelport> err
20:59:16 <pjdelport> @src [] (>>=)
20:59:16 <lambdabot> xs >>= f     = concatMap f xs
20:59:28 <pjdelport> and so on
21:00:23 <mxc> @src concatMap
21:00:23 <lambdabot> concatMap f = foldr ((++) . f) []
21:00:52 <mxc> :t concatMap
21:00:53 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
21:01:01 <ivanm> Saizan_: http://web.engr.oregonstate.edu/~erwig/fgl/haskell/
21:01:07 <ivanm> site is rather slow though
21:01:08 <lambdabot> Title: Functional Graph Library/Haskell
21:01:24 <ivanm> http://web.engr.oregonstate.edu/~erwig/fgl/haskell/fgl-5.4.2.1.tar.gz for the actual tarball
21:01:26 <lambdabot> http://tinyurl.com/5j854y
21:01:48 * ivanm wonders if its a haddock 1 vs 2 problem...
21:03:30 <ivanm> (p, v, l, s) & (Gr g) = let !g1 = IM.insert v (fromAdj p, l, fromAdj s) g
21:03:44 <ivanm> ^^ what's that exclamation mark for? because that's why haddock is throwing a fit...
21:04:13 <dolio> Strictness.
21:04:26 <ivanm> thought so... ghc extension?
21:04:32 <dolio> Yes.
21:04:50 <ivanm> would that be why haddock doesn't like it?
21:05:00 <dolio> Haddock 1?
21:05:06 <ivanm> yes
21:05:10 <dolio> That'd do it.
21:05:15 <ivanm> *nod*
21:05:18 <dolio> Well, probably.
21:05:47 <dolio> I guess it probably has to parse the non-type code, even if it doesn't use it.
21:15:02 <dolio> I must say, most of the people responding to the 'my paper got rejected...' thing on reddit are baffling.
21:17:43 <glguy_> which is that?
21:18:38 <dolio> It was someone (who's on planet haskell) complaining that most of the reviews of his paper seem to indicate that the reviewers barely read the paper.
21:18:43 <Korollary> dolio: The proper reaction to such an incident by a true hacker is to call the referees a bunch of masturbating monkeys.
21:18:58 <dolio> Or do you want a link or something?
21:19:34 <dolio> Heh.
21:19:59 <dolio> http://www.reddit.com/r/programming/info/6spw9/comments/
21:20:00 <lambdabot> Title: programming: "Yesterday, I got a paper rejected from the Haskell Symposium 2008, ...
21:20:02 <jamii> I guess my test suite shouldnt be doing this:
21:20:03 <jamii> propO_assocsAsc : <interactive>: internal error: stg_ap_p_ret
21:20:03 <jamii>     (GHC version 6.8.3.20080611 for i386_unknown_linux)
21:20:03 <jamii>     Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
21:20:05 <lambdabot> Title: ReportABug - GHC - Trac
21:20:06 <dolio> Is the reddit comments.
21:20:35 <dolio> jamii: That looks bad.
21:21:05 <jamii> its not even a weird test. Theres some really hairy type stuff in there and it fails on a sort
21:21:22 <dolio> Probably a legitimate bug, then.
21:21:39 <glguy_> I had a experience report rejected... didn't occur to me to blog about it though
21:21:44 <jamii> Cool, now it segfaults.
21:21:55 <jamii> I should probably try with the newest GHC first?
21:21:56 <glguy_> maybe that could be the starting article to kick off a new site
21:23:53 <dolio> Half the reddit comments seem to be "I haven't read his paper, but I'm going to assume it's crap and he's in denial, and go from there..."
21:24:08 <dolio> +46
21:29:02 <hackage> Uploaded to hackage: list-extras 0.1.0
21:36:32 <_zenon_> Good morning
21:55:09 <dons> glguy_: yav had some pretty firm opinions about the process, iirc
21:55:24 <^Someone^> > let dec n = n-1
21:55:24 <lambdabot>  Parse error at end of input
21:55:37 <^Someone^> What was the syntax again?
21:56:31 <jamii> I cant persuade any of the recent 6.9 releases to install themselves. Looks like the configure script for the libraries is broken
21:58:52 <Saizan_> @let dec n = n -1
21:58:59 <lambdabot> Defined.
21:59:05 <^Someone^> OH
21:59:11 <^Someone^> Right, thanks :)
21:59:51 <^Someone^> @undefine
21:59:54 <lambdabot> Undefined.
22:04:04 <nolrai_East> I read all of the comments and yet have no urge to read his rant, strange.
22:04:33 <nybyn> nolrai_East: whose rant is that?
22:05:20 <nolrai_East> this one:  http://www.reddit.com/r/programming/info/6spw9/comments/
22:05:23 <lambdabot> Title: programming: "Yesterday, I got a paper rejected from the Haskell Symposium 2008, ...
22:06:10 <nolrai_East> I actuly did glance at it, and it looks like he basicly addmited that his paper is almost immposible to under stand.
22:06:18 <nolrai_East> err
22:06:31 <nolrai_East> that maybe my baises at work
22:09:40 <Saizan_> he says that it has a lot of content because of all the features of the library, so it's not a light read, but it's quite clear
22:10:38 <nolrai_East> ehh
22:13:24 <Trinithis> @faq Can Haskell be cooler than me?
22:13:24 <lambdabot> The answer is: Yes! Haskell can do that.
22:13:42 <nolrai_East> describing all of the features of a sounds like a good way to write a boring paper, and any thing with 10 line long type signatures sounds overly complicated to me. but what do I know im only 20 and have read like 5 academic papers.
22:14:08 <nolrai_East> s/of a/of a libraray/
22:16:56 <nolrai_East> is the paper availible for genral persual or is he thinking of submiting it somewhere else?
22:17:17 <Saizan_> it's linked from the blog post
22:19:38 <nolrai_East> err after reading the first page or so, i remove all objections i had and provisonaly agree with him
22:19:59 <^Someone^> @faq Can Haskell state without lying that I am the coolest (cooler than even Trinithis and Haskell)?
22:19:59 <lambdabot> The answer is: Yes! Haskell can do that.
22:20:06 <^Someone^> Yay
22:20:09 <dolio> I didn't think the paper was that hard to understand.
22:20:53 <nolrai_East> I think its better writen then most, and more interesting then most too!
22:21:03 <Trinithis> ^Someone^: I can turn lambdabot's answer into a paradox...
22:21:21 * ^Someone^ can do that too
22:21:24 <nolrai_East> (Feels more directly usable then most)
22:21:46 <^Someone^> But I can mathematically prove that I'm better than you :D
22:21:57 <Trinithis> I believe it!!!
22:33:39 <ajd2> @faq What does @faq do?
22:33:40 <lambdabot> The answer is: Yes! Haskell can do that.
22:34:09 <ajd2> @faq What can't Haskell do?
22:34:09 <lambdabot> The answer is: Yes! Haskell can do that.
22:35:28 <dmwit> ?faq Can Haskell be used to prove that Haskell cannot be used for proofs?
22:35:28 <lambdabot> The answer is: Yes! Haskell can do that.
22:36:11 <Trinithis> l?faq Can Haskell prove that lambdabot is lying?
22:36:14 <Trinithis> ?faq Can Haskell prove that lambdabot is lying?
22:36:14 <lambdabot> The answer is: Yes! Haskell can do that.
22:36:49 <frevidar> ?faq Can Haskell solve the halting problem?
22:36:49 <lambdabot> The answer is: Yes! Haskell can do that.
22:36:55 <frevidar> wow
22:37:02 <nybyn> ?faq can lambdabot make me a sandwich?
22:37:03 <lambdabot> The answer is: Yes! Haskell can do that.
22:37:11 <nybyn> that's not what i asked
22:37:51 <nolrai_East> sudo make me a sandwich
22:38:11 <Trinithis> frevidar: But he's dead!
22:39:12 <ajd2> $ sudo make me a sandwitch Password: make: *** No rule to make target `me'.  Stop.
23:04:26 <codacola> hello all
23:11:20 <nolrai_East> when I try to create a account on the haskell.org GHC Trac thingy it asks for a user name and a password. what should i do?
23:12:29 <|Steve|> Supply a user name and a password?
23:14:55 <nolrai_East> :P
23:15:23 <nolrai_East> err, i should go to sleep any way.
23:16:55 <glguy_> @seen dons
23:16:55 <lambdabot> dons is in #arch-haskell, #xmonad, #ghc and #haskell. I last heard dons speak 1h 21m 46s ago.
