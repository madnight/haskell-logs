00:00:03 <kiris> I think Functor is a "subclass" of Monad, but not written as such in Haskell 98?
00:00:14 <opqdonut> yeah
00:00:48 <chris_> @hoogle k -> Map k a -> a
00:00:49 <lambdabot> Data.Map.(!) :: Ord k => Map k a -> k -> a
00:00:49 <lambdabot> Data.Map.fold :: (a -> b -> b) -> b -> Map k a -> b
00:00:49 <lambdabot> Data.Map.foldWithKey :: (k -> a -> b -> b) -> b -> Map k a -> b
00:01:35 <solrize_> :t (.)
00:01:35 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
00:01:40 <solrize_> ?????
00:02:24 <_zenon_> is it not so that Functor is the class of all mappable's?
00:02:27 <povman> solrize_: that is the lambdabot version
00:02:29 <kiris> :t ((+1).Just)
00:02:30 <lambdabot> forall a. (Num (Maybe a)) => a -> Maybe a
00:02:46 <chris_> solrize: in lambdabot (.) = fmap
00:02:48 <kiris> > ((+1).Just) 9000
00:02:49 <lambdabot>   add an instance declaration for (Num (Maybe a))
00:02:55 <solrize_> :t sqrt . log
00:02:55 <lambdabot> forall a. (Floating a) => a -> a
00:02:57 <kiris> > ((+1).Just) (9000::Int)
00:02:57 <lambdabot>   add an instance declaration for (Num (Maybe Int))
00:03:04 <kiris> oh, whoops
00:03:06 <achilles14> how can write my own function to implement [1..11]? I have write the following function:
00:03:08 <achilles14> increaseList 1 = [1]
00:03:09 <achilles14> increaseList x = x : increaseList (x-1)
00:03:11 <achilles14> but It can only create a revesed list; [11..1], how to create the right list?
00:03:11 <kiris> > ((+1).Just) $ Just 9000
00:03:12 <lambdabot>        add an instance declaration for (Num (Maybe (Maybe t)))
00:03:25 <kiris> ah
00:04:21 <solrize_> achilles14 do something similar except counting upward
00:04:41 <povman> achilles14: increaseList shoud take another argument for the upper limit, then increase until the limit is reached
00:05:06 <solrize_> or, build the list right to left with the head decreasing
00:05:18 <_zenon_> that would be the nicest
00:06:05 <achilles14> I have tried many ways, I will try more.
00:06:26 <codacola> 7 days until my first haskell class :D
00:06:39 <solrize_> suppose the list you have so far is [8,9,10,11].  what do you want to do after that?
00:07:18 <kiris> codacola: where are you taking that?
00:07:44 <codacola> university
00:07:57 <kiris> mmmkay
00:08:12 <nolrai_East> which university?
00:08:24 <codacola> massey
00:08:40 <achilles14> solrize_: I want 7 : [8,9,10,11]
00:09:04 <nolrai_East> ((->) a) is an instance of MonadReader isn't it?
00:09:41 <codacola> nolrai_East, not a US university
00:10:02 <Trinithis> is there a console function that can detect if a use presses an arrow key (etc)?
00:10:32 <solrize_> achilles, correct.  what would you do to put the 7 there?
00:11:17 <syntaxfree> this simulation business is much harder than I thought.
00:12:42 <achilles14> solrize_: I can use x : increaseList (x + 1), but I don't know how to make it stop when x==1
00:13:04 <chr1s> syntaxfree: what are you simulating?
00:13:28 <mauke> why x+1? I thought you're counting down
00:14:04 <ddarius> subroutine threading is making a comebak
00:14:23 <achilles14> solrize_: and how shall I start? increaseList limit limit = [limit] ?
00:14:39 <kiris> "GOTO considered for comeback"
00:14:49 <mauke> COMEFROM
00:14:50 <_zenon_> Trinithis: I would look at http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html#20
00:14:50 <syntaxfree> chr1s: traffic flow, at first, but economic simulation is close to traffic flow from the way I'm approaching it.
00:14:51 <lambdabot> Title: System.IO
00:14:53 <kiris> :P
00:15:04 <Trinithis> zeon: ok
00:15:04 <syntaxfree> (I know my economics.)
00:15:32 <hpaste>  Euler_ pasted "composition of maps" at http://hpaste.org/8759
00:15:33 <_zenon_> Trinithis: Especially the getChar function, you could hack your way from there
00:15:37 <solrize_> achilles14 hmm the simplest way i see to do it involves writing 2 functions, maybe that's a little complicated
00:15:53 <chr1s> syntaxfree: that doesn't sound like an easy thing. but surely, there must be research on that.
00:15:57 <solrize_> basically you have 2 things to consider:
00:16:13 <achilles14> solrize_: go on
00:16:19 <Trinithis> _zenon_: but doesnt getChar require the user to hit enter?
00:16:20 <solrize_> 1) given something like [8,9,10,11]   how do you turn it into [7,8,9,10,11]  and so on down to 1
00:16:31 <solrize_> 2) how do you start?
00:16:49 <_zenon_> Trinithis: Hm..... '
00:16:57 <_zenon_> I believe you are right
00:17:45 <Trinithis> i think what i want would have to be defined as a primitive... and the ghc might not have it. I've never been able to do such a thing in c++, but i know how to in asm
00:18:39 <achilles14> solrize_: these two things beat down me, I have thought it is easy to implement [1..11] using recursive function :)
00:18:42 <mauke> Trinithis: how would you do it in asm?
00:19:08 <_zenon_> Trinithis, I know I have used HGL to handle pressed keys without 'enter'
00:19:14 <povman> let listIO = return ["1", "2", "3"] in (fmap.fmap) (isInfixOf "2") listIO
00:19:18 <Trinithis> int xx; (i forget the actuall xx value, but thats how its done)
00:19:22 <_zenon_> somehow, HGL is not in the standard libraries though =/
00:19:28 <povman> > let listIO = return ["1", "2", "3"] in (fmap.fmap) (isInfixOf "2") listIO
00:19:29 <lambdabot>   add an instance declaration for (Show (f [Bool]))
00:19:29 <solrize_> achilles14 yes it's easy but takes a little practice, like riding a bike
00:19:59 <achilles14> solrize_: can you give me the answer?
00:20:02 <mauke> Trinithis: no, it isn't
00:20:14 <solrize_> let's say you want to write a function that simply takes a list like [8,9,10,11] and extends it downward, can you do that?
00:20:20 <Trinithis> lemme look at some old ams code i have... mabye i can find it
00:20:23 <_zenon_> http://people.reed.edu/~carlislp/ghc6-doc/libraries/HGL/Graphics.HGL.html
00:20:24 <lambdabot> Title: Graphics.HGL
00:20:29 <mauke> Trinithis: linux only lets you use int $128 to do a system call
00:20:39 <solrize_> achielles14 this sounds like a homework problem, we usually give advice but not completed answers
00:20:52 <Trinithis> oh... right. I have windows :(
00:21:09 <kiris> haskell is a good reason to dump windows
00:21:12 <achilles14> solrize_: that means you have got the answer?
00:21:17 <_zenon_> Trinithis, There you have getKey
00:21:39 <Trinithis> cool
00:21:41 <povman> Euler_: you could use flip, but i'd prefer this:
00:21:41 <Trinithis> thanks
00:21:43 <povman> Euler_: foo x = fmap (fmap (isInfixOf x)) listIO
00:21:48 <_zenon_> Trinithis, and isUpKey and etc....
00:21:50 <ddarius> Trinithis: There are curses bindings and there are bindings to the windows API.
00:22:00 <solrize_> achilles14 yes i
00:22:01 <solrize_> yes
00:22:04 <Trinithis> curses?
00:22:19 <solrize_> it's not terribly hard, but best to break the problem into parts
00:22:37 <kiris> that's the POSIX terminal manipulation protocol or something so-called
00:22:46 <mauke> kiris: not really
00:22:57 <mauke> the POSIX terminal functions are in termios.h
00:23:11 <kiris> yeah
00:23:27 <kiris> but they send data to stdout, so I thought of it as a protocol. I guess it's not really
00:23:43 <achilles14> solrize_: admire you. is it still nice like normal recursive function definition?
00:24:58 <ddarius> Trinithis: Another approach would be SDL.
00:25:21 <Trinithis> SDL meaning?
00:25:28 <kiris> simple direct media layer
00:25:32 <hpaste>  povman annotated "composition of maps" with "this one" at http://hpaste.org/8759#a1
00:25:44 <povman> Euler_: ^^^
00:25:56 <solrize_> achilles14 maybe it's slightly tricky
00:26:37 <solrize_> but can you do one part of it?
00:26:49 <solrize_> from [8,9,10,11] get [7,8,9,10,11]
00:26:55 <_zenon_> http://www.libsdl.org/languages.php
00:26:56 <lambdabot> Title: Simple DirectMedia Layer
00:27:19 <Euler_> povman, which library is that from ?
00:27:28 <povman> which what?
00:27:34 <povman> that's function composition
00:28:04 <Euler_> which library contains the function (^^^)
00:28:09 <solrize_> the tricky part is i used a function with 2 args
00:28:10 <achilles14> solrize_: I can implement it use one function definition, and two or three if statement embeded.
00:28:10 <Trinithis> > return $ pure . "12"
00:28:11 <lambdabot>   add an instance declaration for (Show (m [f Char]))
00:28:12 <kiris> @hoogle (^^^)
00:28:12 <lambdabot> No matches found
00:28:22 <povman> Euler_: that was me pointing to the hpaste
00:28:24 <povman> :)
00:28:29 <solrize_> achilles14 use http://hpaste.org to show what you wrote
00:28:31 <povman> :t (fmap.fmap)
00:28:32 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
00:28:35 <Trinithis> > pure . "123"
00:28:36 <lambdabot>   add an instance declaration for (Show (f Char))
00:28:38 <Euler_> ohoh lol
00:28:43 <povman> @hoogle (a -> b) -> f (f1 a) -> f (f1 b)
00:28:43 <lambdabot> Did you mean: (a -> b) -> f (F1 a) -> f (F1 b)
00:28:43 <lambdabot> Control.Monad.Error.Class.catchError :: MonadError e m => m a -> (e -> m a) -> m a
00:28:43 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
00:29:03 <Trinithis> > pure . "123" :: [String]
00:29:04 <lambdabot>  ["1","2","3"]
00:29:15 <achilles14> sorlrize_: it looks like recursive function in other languages, such as C and perl.
00:29:45 <solrize_> lots of times in haskell you can use pattern matching and avoid if statements
00:29:47 <kiris> :t Just . (+1)
00:29:48 <lambdabot> forall a. (Num a) => a -> Maybe a
00:30:13 <syntaxfree> google is slow here.
00:30:22 <syntaxfree> other sites, including mine, will open fast.
00:30:34 <povman> (*2) <$> 3
00:30:36 <solrize_> tom disch just died???  :(
00:30:41 <povman> > (*2) <$> 3
00:30:42 <lambdabot>   add an instance declaration for (Num (f a))
00:30:53 <povman> > (*2) <$> Id 3
00:30:54 <lambdabot>   Not in scope: data constructor `Id'
00:31:04 <Trinithis> > Identity 3
00:31:04 <lambdabot>   add an instance declaration for (Show (Identity t))
00:31:28 <Trinithis> > Identity 3 :: Identity Int
00:31:29 <lambdabot>   add an instance declaration for (Show (Identity Int))
00:31:52 <povman> > (*2) <$> Identity 3
00:31:52 <lambdabot>   add an instance declaration for (Show (Identity a))
00:32:05 <Trinithis> does lambdabot need a tuneup for Identity show?
00:32:59 <povman> Trinithis: it doesn't even have Show in the standard lib
00:33:17 <Trinithis> O.o
00:33:32 <ddarius> > gshow ((*2) <$> Identity 3)
00:33:33 <lambdabot>   add an instance declaration for (Data (Identity a))
00:33:33 <lambdabot>     In the expression: ...
00:33:35 <povman> > runIdentity ((*2) <$> Identity 3)
00:33:36 <lambdabot>  6
00:33:38 <povman> aha!
00:33:46 <hpaste>  achilles14 pasted "[1..23]" at http://hpaste.org/8760
00:34:15 <achilles14> solrize_: look at http://hpaste.org/8760
00:35:42 <hpaste>  _zenon_ annotated "[1..23]" with "(no title)" at http://hpaste.org/8760#a1
00:36:04 <solrize_> achilles looks like it works
00:36:35 <solrize_> congrats
00:36:36 <solrize_> nice job
00:37:04 <povman> _zenon_: technically that's not the same function
00:37:35 <_zenon_> povman: I know, it doesn't handle negative numbers
00:37:46 <achilles14> solrize_: yes, but it is C or Perl style, lost the nice of two part recursive fuction definition.
00:37:48 <povman> the original had upper and lower limits
00:38:04 <_zenon_> But I believe it was a matter of [1.. N]
00:38:17 <solrize_> that has upper and lower limits
00:38:19 <solrize_> x is the lower limit
00:38:44 <achilles14> solrzie_: en
00:39:49 <solrize_> my version was like this:
00:39:57 <solrize_> > let aa x ys = if x==0 then ys else aa (x-1) (x:ys) in aa 11 []
00:39:58 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11]
00:40:25 <solrize_> > let aa 0 ys = ys; aa x ys = aa (x-1) (x:ys) in aa 11 []
00:40:26 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11]
00:40:38 <solrize_> pattern matching vs if/else, comes out about the same
00:40:56 <ddarius> You want a recursive as opposed to tail recursive definition here.
00:41:19 <nolrai_East> @src ask
00:41:20 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
00:41:28 <nolrai_East> ?
00:41:32 <solrize_> achilles14's version is like a foldr, actually nicer for lazy evaluation
00:41:34 <achilles14> solrize_: 11 is not parameter?
00:41:39 <ddarius> i.e. modulo syntax, achilles14's definition is the best.
00:41:39 <_zenon_> let increaseList x y = [x .. y]
00:41:42 <mauke> @src (->) ask
00:41:42 <lambdabot> ask = id
00:41:58 <nolrai_East> what file is that in?
00:42:08 <mauke> Control.Monad.Instances, I think
00:42:12 <solrize_> achilles14 yes 11 is a parameter and i added [] as an accumulator
00:42:34 <Baughn> zeno___: inreaseList = enumFromTo
00:43:00 <nolrai_East> mauke: nope. Thats what i thought too.
00:43:07 <nolrai_East> @hoogle ask
00:43:07 <lambdabot> Control.Monad.Reader.Class.ask :: MonadReader r m => m r
00:43:08 <lambdabot> Control.Monad.Reader.Class.asks :: MonadReader r m => (r -> a) -> m a
00:43:08 <lambdabot> Foreign.Ptr.freeHaskellFunPtr :: FunPtr a -> IO ()
00:43:26 <ddarius> _zenon_'s hpaste definition is the worst, combining poor performance with poor laziness
00:43:41 <hpaste>  solrize annotated "[1..23]" with "alternate syntax" at http://hpaste.org/8760#a2
00:44:28 <mauke> nolrai_East: http://haskell.org/ghc/docs/latest/html/libraries/mtl/src/Control-Monad-Reader.html
00:44:29 <lambdabot> Title: Haskell Code by HsColour
00:44:41 <achilles14> hi all, where can I find tutorials taking about exceptions? It is empty in "yet another haskell tutorial".
00:44:49 <ddarius> One improvement in behaviour would be to return [] for x > limit as this is the behaviour you want for [11..10]
00:44:53 <ddarius> > [11..10]
00:44:55 <lambdabot>  []
00:45:09 <solrize_> achilles14 haskell exceptions are complicated, it's not time to worry about them yet :)
00:45:30 <nolrai_East> mauke: thanks!
00:45:46 <solrize_> http://realworldhaskell.org  has something about them though
00:45:49 <lambdabot> Title: Real World Haskell
00:46:13 <Baughn> achilles14: In pure code, haskell would recommend return-value "exceptions" instead of actual exceptions for anything but program bugs. Try Maybe/Either
00:46:23 <Baughn> achilles14: (Mostly because you can't catch exceptions in pure code)
00:46:47 <achilles14> solrize_: how you do with: let num = read line; if num > 0 ....  ? if line is not a num, a exception will be throw out.
00:47:26 <Baughn> achilles14: Basically, don't use read
00:47:33 <Baughn> reads, maybe
00:47:36 <Baughn> @ty reads
00:47:37 <lambdabot> forall a. (Read a) => String -> [(a, String)]
00:47:50 <Baughn> > reads "42" :: [(Int,String)]
00:47:51 <lambdabot>  [(42,"")]
00:47:56 <Baughn> > reads "a42" :: [(Int,String)]
00:47:57 <lambdabot>  []
00:48:37 <kiris> <3
00:48:46 <achilles14> > read "dfdsf"
00:48:47 <lambdabot>  Exception: Prelude.read: no parse
00:49:00 <achilles14> > reads "dfdsf"
00:49:01 <Baughn> achilles14: Didn't tell it what type it should have, so it defaults to ()
00:49:01 <lambdabot>  []
00:49:26 <achilles14> but haskell will guess the type at complie time.
00:49:48 <Baughn> Sure, in normal programs. Not without information.
00:49:54 <solrize_> there's some way of using read in the Either monad to get that error as a Left, i thought
00:50:04 <Baughn> > read "42" :: Either Int
00:50:05 <lambdabot>      `Either Int' is not applied to enough type arguments
00:50:05 <lambdabot>     Expected kind `...
00:50:09 <Baughn> ..nope
00:50:18 <solrize_> > read "42" :: Either String Int
00:50:19 <lambdabot>  Exception: Prelude.read: no parse
00:50:33 <Baughn> > read "42" :: Maybe Int
00:50:34 <achilles14> solrize_: you mean control.exceptions's try?
00:50:34 <lambdabot>  Exception: Prelude.read: no parse
00:50:38 <kiris> > read "Right 42" :: Either String Int
00:50:38 <lambdabot>  Right 42
00:50:48 <solrize_> achilles14 i don't think so
00:51:38 <Baughn> @src Read
00:51:38 <lambdabot> class Read a where
00:51:38 <lambdabot>   readsPrec    :: Int -> ReadS a
00:51:38 <lambdabot>   readList     :: ReadS [a]
00:51:38 <lambdabot>   readPrec     :: ReadPrec a
00:51:38 <lambdabot>   readListPrec :: ReadPrec [a]
00:51:48 <Baughn> @ty readPRec
00:51:48 <lambdabot> Not in scope: `readPRec'
00:51:49 <solrize_> do { a <- read "42"; return a}
00:51:51 <achilles14> sorlrize and Baughn: what is your normal way to do with user input? when you want a integer?
00:51:54 <Baughn> @ty readPrec
00:51:55 <lambdabot> Not in scope: `readPrec'
00:51:56 <solrize_> do { a <- read "42"; return a} :: Either String Int
00:52:03 <solrize_> > do { a <- read "42"; return a} :: Either String Int
00:52:04 <lambdabot>  Exception: Prelude.read: no parse
00:52:16 <Baughn> achilles14: Feed it through reads
00:52:29 <Baughn> achilles14: Wrap reads in something that returns Maybe or Either, too
00:53:00 <ddarius> There is a library that, among other things, has such a wrapper on hackage.
00:53:19 <achilles14> Baughn: where can I find tutorial about Maybe and Either?
00:53:54 <Baughn> achilles14: One is scarcely needed. data Mayba a = Just a | Nothing; data Either a b = Left a | Right b
00:54:12 <Baughn> achilles14: By convention, errors are Left. Because non-errors are Right, see..
00:55:16 <kiris> mnemonic
00:55:56 <Baughn> That too
00:55:57 <osfameron> Though calling them "Good" and "Bad" would have been a little less subtle
00:56:24 <Baughn> Sure. It'd also make this binary tree look rather odd.
00:56:56 <Baughn> (Well, not the /tree/.. I'm using Either to store a path)
00:57:30 <achilles14> Baughn: then maybe the 'try' function in control.exception are a official wrapper that using Either to prevent exception from throwing out.
00:57:30 <kiris> type MyTree = Either String MyTree ?
00:58:01 <solrize_> :t error
00:58:02 <lambdabot> forall a. [Char] -> a
00:58:47 <Baughn> @ty try
00:58:48 <lambdabot> Not in scope: `try'
00:59:12 <mauke> do, or do not
00:59:17 <Baughn> achilles14: Oh yes. Sorry, there are fundamental problems with catching exceptions in pure code
00:59:24 <Baughn> achilles14: Outside-in evaluation order, for one
00:59:35 <Trinithis> :t Control.Exception.try
00:59:35 <lambdabot> forall a. IO a -> IO (Either GHC.IOBase.Exception a)
01:09:39 <hpaste>  _zenon_ annotated "[1..23]" with "Reading a number, are we still on that topic?" at http://hpaste.org/8760#a3
01:13:37 <achilles14> god! I have forgot ++ can use for list concation.
01:14:23 <_zenon_> achiless14: I hacked something up for reading a number and the list thingy, not "proper" LR parsing though :)
01:14:42 <_zenon_> achiles14: sorry, spelled wrong there.
01:15:06 <_zenon_> and yet again... hmm... must be tired.
01:15:39 <achilles14> _zenon_: but I can't understand your code, I shall look at more tutorial.
01:16:07 <_zenon_> achilles14: [correctly spelled this time] , okay.
01:21:48 <_zenon_> Hmm.. seems wrong to have typed "proper" on the same line as LR parsing, since LR parsing (imo) is proper indeed.
01:27:12 <_zenon_> achilles14: First, we read a line from the user (with readLn), then we apply a function that checks if a symbol is a digit; to each symbol in the string.
01:27:40 <_zenon_> achilles14: If indeed, all symbols are letters, we can reconstruct the number.
01:28:08 <achilles14> _zenon_:why and follows case? and what $ means?
01:28:34 <achilles14> _zenon_: oh, infix
01:28:41 <_zenon_> $ is used to skip parenthesis
01:29:35 <_zenon_> achilles14:  case .. of   True -> means that all the symbols in the string where digits
01:29:44 <Cale> Basically, f $ x = f x, but $ binds more weakly than any other operator symbols, so it's as if you've surrounded what's on the left and right of it in parens.
01:29:46 <_zenon_> you can try it in ghci or hugs,
01:30:11 <_zenon_> > and $ map isDigit "121231"
01:30:17 <achilles14> Cale: thanks
01:30:17 <lambdabot>  True
01:30:23 <Cale> case expressions are used to pattern match against a value
01:30:41 <_zenon_> > and $ map isDigit "110010B"
01:30:42 <lambdabot>  False
01:31:31 <ddarius> and . map p === all p
01:31:39 <Cale> case <expr> of <pat> -> <result>; ...
01:31:46 <achilles14> _zenon_ and Cale: thanks, I understand the code now.
01:32:05 <Cale> Though in this case, if ... then ... else ... is probably more appropriate :)
01:32:09 <_zenon_> achilles14: Nice, always a pleasure to expand the Haskell community :)
01:32:30 <Cale> also,  and . map p  is the same as  all p
01:32:32 <achilles14> :)
01:32:34 <_zenon_> Yeah, could have been nicer with a _ -> pattern instead
01:32:47 <Cale> So you can make that  if all isDigit s then ... else ...
01:33:20 <_zenon_>  actually that reads nicer.
01:33:32 <Cale> It's also possible to pull the 'return' out of each branch
01:33:40 <daf> people were badmouthing Haskell on the internet, so I tried to prove them wrong and didn't really succeed: http://arunchaganty.wordpress.com/2008/07/06/quicksort/#comment-227
01:33:56 <daf> perhaps I need to be using bytestrings or something instead?
01:34:00 <kiris> on the internet!!?
01:34:08 <daf> yeah
01:34:12 <daf> the cheek
01:34:21 <daf> oh, bah, my comment is still being moderated
01:35:16 <_zenon_> kiris: :D
01:36:30 <quicksilver> anyone here who groks automatic differentiation?
01:38:14 <daf> it boils down to: for my input, Haskell sorts were reliably 6-10 times slower than C, and naïve Haskell qsort seems to perform similarly to Data.List.sort
01:39:45 <dolio> What were you sorting in C?
01:40:02 <ddarius> daf: Comparing an in-place sort of an array with a persistent sort of a list isn't much of a comparison.
01:40:09 <Cale> quicksilver: sure
01:40:26 <quicksilver> Cale: I'm trying it understand why it's "different" from symbolic differentiation.
01:40:34 <conal> is there currently a problem with ssh and code.darcs.org?  i'm not being able to ssh in.
01:40:39 <quicksilver> Cale: is it merely that it substitutes in actual values as it goes along, which may save time?
01:41:08 <achilles14> _zenon_ and Cale: "map digitToInt s" , change each char to int makes the whole string become an integer?
01:41:11 <daf> ddarius: hmm, I suppose so
01:41:34 <_zenon_> achilles14: No you will receive a list of Int
01:41:45 <achilles14> _zenon_: oh
01:41:59 <Cale> quicksilver: basically.
01:42:03 <_zenon_> achilles14: That is why we  "reconstruct" the integer with the list comprehension
01:42:25 <daf> ddarius: I was hoping that it wouldn't make much difference
01:42:34 <quicksilver> Cale: because it seems to me that the basic complexity in (e.g.) the product or quotient rules isn't actually avoided. The complexity is there.
01:42:37 <daf> ddarius: at any rate, Hoogle isn't turning up any in-place sorts
01:42:39 <achilles14> _zenon_: got it.
01:42:52 <dolio> I have a library of them in the works.
01:42:55 <quicksilver> although parts of the expression collapse when you substitute values.
01:42:58 <ddarius> daf: There's an overly abstracted one on the wiki.
01:43:22 <dolio> So far I have quicksort, mergesort, heapsort and radix sort.
01:43:23 <ddarius> http://www.haskell.org/haskellwiki/Introduction/Direct_Translation
01:43:24 <lambdabot> Title: Introduction/Direct Translation - HaskellWiki
01:43:26 <dolio> For uvectors.
01:43:32 <daf> ddarius: if it's not in the standard library, I think we've already lost
01:43:35 <quicksilver> daf: there have been a large number of posts on haskell-cafe demonstrating naive haskell sorts within about 1.5x - 2x C sort speed, IIRC.
01:43:54 <daf> quicksilver: oh, interesting
01:44:01 <dolio> Mine are faster than the glibc qsort, at least.
01:44:14 <daf> perhaps I'm spending all time in lines/unlines
01:44:19 <dolio> Not as fast as the STL sorts (except for heapsort, which is faster).
01:44:41 <Cale> quicksilver: Well, I suppose the main difference is that rather than taking an expression tree and applying transformations to it to produce the derivative, you just change the type of numbers you're using to keep track of the first derivative as you go.
01:44:54 <daf> dolio: fun!
01:45:17 <dolio> Yeah. Took a lot of tuning to get them that way, though. :)
01:45:17 <quicksilver> Cale: well that's only a difference looked at from one angle.
01:45:33 <quicksilver> Cale: from another angle, the type of numbers you're using is doing the rules of symbolic differentiation under the hood.
01:45:47 <quicksilver> so it still "is" symbolic differentiation behind the scenes.
01:45:52 <dolio> There's a missed optimization that will probably make the quicksort faster if it gets into GHC, too.
01:46:03 <Cale> quicksilver: But at no point do you have a structure in memory which corresponds to the derivative of the expression you're working with.
01:46:19 <Cale> quicksilver: You just have a bunch of numbers that happen to correspond to derivatives.
01:46:44 <_zenon_> Heard of microbench?
01:46:45 <_zenon_> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/microbench-0.1
01:46:46 <lambdabot> Title: HackageDB: microbench-0.1
01:47:10 <quicksilver> Cale: *nod*
01:47:43 <quicksilver> Cale: so it's the *rules* of symbolic differentiation, but applied to numbers rather than symbols
01:47:49 <Cale> yes
01:48:01 <_zenon_> It would be nice if lambdabot output the first few lines from a hackage site.
01:48:14 <quicksilver> Cale: also, if you calculate the function and its derivative(s) in parallel you get some sharing
01:48:18 <quicksilver> of intermediate computations.
01:49:03 <Cale> quicksilver: The main trick to it is that you can determine the derivative of a product only knowing the value and first derivatives of the factors, without actually knowing what functions produced those.
01:49:28 <dolio> I must say, the hardest part of implementing a dependently typed language (or, pure type system at least) is parsing it. :)
01:49:45 <ddarius> I'd like to point out that there isn't a trick here.  Differentiation is what has rules, not symbolic/numeric differentiation.  They are going to be the same rules either way.
01:49:55 <ddarius> dolio: ?
01:50:24 <dolio> ddarius: I think I've been working on the parser a lot longer than the rest of the code.
01:50:25 <quicksilver> ddarius: yes, clearly. I'm really using the phrase 'symbolic' to indicate that we're using the rules, and not the f(x+d)-f(x) / d version
01:50:43 <quicksilver> ddarius: because the latter is what 'numeric differentiation' means in a lot of context.
01:50:46 <quicksilver> s
01:51:05 <quicksilver> Cale: and that similar statements apply to the chain rule
01:51:18 <ddarius> dolio: Sometimes that can happen for a rich syntax.
01:51:58 <Cale> quicksilver: right
01:52:28 <opqdonut> getting the syntax right takes a lot of work
01:52:46 <opqdonut> and the syntaxes in e.g. TAPL are pretty awful to write _and_ parse
01:53:07 <dolio> ddarius: Yeah. I'm not sure how rich it is. It just seems to have a lot of overlapping constructs that get me in trouble in parsec unless try is used.
01:53:24 <ddarius> dolio: Manipulate the BNF beforehand.
01:53:42 <opqdonut> dolio: yeah, write up the BNF and then use happy or something
01:55:20 <quicksilver> or use a parser which is symmetric by default?
01:55:23 <quicksilver> like polyparse.
01:58:31 <_zenon_> dolio: BNFC ?
01:59:27 <_zenon_> http://www.cs.chalmers.se/Cs/Research/Language-technology/BNFC/
01:59:31 <lambdabot> Title: The BNF Converter
02:00:43 <dolio> That looks pretty impressive.
02:03:24 <_zenon_> I used the BNFC once in our Programming Languages course, easy enough to create parsers. Just specify the BNF and it will create a complete system for parsing, which returns everything in a nice Abstract Syntax.
02:03:31 <_zenon_> http://www.cs.chalmers.se/Cs/Research/Language-technology/BNFC/doc/BNF_Converter_Haskell_Mode.html
02:03:32 <lambdabot> Title: The BNF Converter: Haskell Mode
02:03:40 <_zenon_> dolio: at the bottom of the page
02:04:42 <dolio> Anyhow, I think I'm close to having a solution with parsec.
02:05:02 <dolio> I just had to take my time and plan ahead of time.
02:17:55 <EvilTerran> morning folks
02:18:28 <EvilTerran> http://groups.google.com/group/alt.math/browse_thread/thread/011f11b3c7592342 <- any thoughts? the guy who wrote this sent me the link in another channel, but IANA abstract algabraist
02:18:29 <lambdabot> Title: Algebras for which 'mean' is well-defined. - alt.math | Google Groups
02:19:08 <EvilTerran> and it's too early in the morning for me to crib something together from what i know :P
02:23:52 <EvilTerran> heh... <dfranke> endo-hylo-cata-ana-expi-ali-docious.
02:24:08 <dfranke> EvilTerran: you're creating a circular reference.
02:24:19 <dfranke> EvilTerran: I stole that from the #haskell quotes archive :-)
02:24:23 <EvilTerran> whoa, dfranke's in here too?
02:24:27 * EvilTerran is confused
02:24:58 <EvilTerran> dfranke, let me have my coffee before you start talking to me in two channels at once, i can't keep up! O.o
02:25:47 * dfranke haunts EvilTerran across the far corners of the intertubes
02:26:13 * Baughn hunts down dfranke for saying "intertubes"
02:26:26 * EvilTerran flees into the big blue room, far away from the interwebbies
02:26:47 <dfranke> Baughn: /whois me and you'll see you'll have lots of tubes through which to hunt for me
02:27:14 <EvilTerran> Baughn, be glad it wasn't "internoobs" :P
02:27:34 <Baughn> A series of tubes.. in parallel
02:27:58 <EvilTerran> a directed graph of tubes?
02:28:25 <EvilTerran> (given ADSL andother asymmetric stuff, direction is necessary)
02:28:56 <Baughn> Graphs are so very handy. Nothing /isn't/ a graph, it seems..
02:30:03 <EvilTerran> even a category can be visualised as a directed multigraph
02:32:39 <quicksilver> visualised, perhaps, but not described.
02:32:41 <_zenon_> well. the term "graph" is pretty loose
02:32:55 <quicksilver> a category is a directed multigraph with an associative multiplication on the edges.
02:33:08 <quicksilver> that's a strictly more complex structure than a plain directed multigraph.
02:33:29 <EvilTerran> yeah, i forgot that bit
02:34:37 <EvilTerran> ... well, isn't it a composition between an edge to a point and an edge from that point?
02:35:07 <kiris> in #python they just talk about leah culver and shopping ;_;
02:35:34 <EvilTerran> handling un-constrained side-effects is hard, let's go shopping?
02:35:57 <kiris> :P
02:36:18 <ziman> is there a Functor that is not Applicative?
02:36:32 <EvilTerran> ... i think so
02:36:53 <dolio> Potentially.
02:37:07 <EvilTerran> think of ones that aren't monads, if they're a monad they must be an applicative too
02:37:40 <Baughn> @instances-all Applicative
02:37:40 <lambdabot> Unknown command, try @list
02:37:47 <EvilTerran> (Array i)?
02:38:18 <EvilTerran> ?instances Functor
02:38:18 <dfranke> erm?  That'd be a * -> * -> *
02:38:20 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
02:38:22 <dfranke> Applicative is * -> *
02:38:44 <dolio> Arrays could arguably work.
02:38:58 <dolio> Depending on whether or not you're willing to make up arbitrary indices for them.
02:39:03 <EvilTerran> dfranke, Array :: * -> * -> *; Array i :: * -> *
02:39:16 <opqdonut> ziman: there's more than one way to make [] applicative, for instance
02:39:20 <opqdonut> zip and "cross-product"
02:39:24 <EvilTerran> similarly, (Map i) might work
02:39:28 <achilles14> hi all, how to output a list of int?
02:39:38 <mauke> print
02:39:41 <opqdonut> of course cross-product is the more natural one, when we take into account the list monad
02:39:53 <EvilTerran> actually, (Map k) would work, 'cos there's insufficient constraint on k to be able to get an arbitrary element of it
02:39:57 <ziman> yes
02:39:57 <EvilTerran> so we can't write "pure"
02:41:09 <dfranke> EvilTerran: was thinking that Array took three parameters for some reason.
02:41:52 <opqdonut> for containerish functors pure = singleton, and then we just need to figure out sensible pairing semantics for <*>
02:43:07 <dfranke> I don't think there's one particular sensible choice.  You'd want wrappers like for Monoid.
02:43:44 <opqdonut> yes
02:49:41 <achilles14> how to print a list returned from a function?
02:49:53 <mauke> print
02:50:01 <quicksilver> print (f 3)
02:51:22 <achilles14> mauke and quicksilver: but I got No instance for (Show (IO [Int]))
02:51:24 <achilles14>   arising from a use of `print' at 36in7.hs:56:2-22
02:51:37 <mauke> that's because your function doesn't return a list
02:51:40 <dfranke> oh, you didn't say it was an IO function.
02:51:47 <dfranke> f 3 >>= print
02:52:58 <achilles14> sorry for not saying it is IO function.
02:53:09 <achilles14> dfranke: it works, thanks.
02:53:38 <mauke> a.k.a. do { x <- f 3; print x }
02:53:42 <dfranke> achilles14: in non-trivial cases you'd write that as do { x <- f 3; print x }
02:53:47 <dfranke> err, ditto.
02:54:08 <mauke> partymind
02:54:36 <ndmitchell> what is the "standard" tutorial recommendation? I know it used to be YAHT, but now is it the wikibooks?
02:54:50 <ndmitchell> assuming not buying a hard-copy book
02:55:24 <dfranke> I'm a Gentle Introduction holdout.
02:55:50 <dfranke> but the wikibook is pretty good.
02:56:12 <kiris> Real World Haskell!!11
02:56:27 <achilles14> thanks mauke and dfranke
02:56:41 <ndmitchell> i think i'd rather point at the wikibook if possible, its for a friend, and if they get confused i can just edit the wikibook
02:57:04 <dfranke> The Gentle Introduction ain't easy, but Haskell will break your brain early and often so you might as well get used to it :-)
02:57:42 <ndmitchell> she's got an MPhil in quantum gravity and theoretical maths, so is used to confusing weird stuff...
02:58:47 <Baughn> Mm. Haskell isn't /that/ confusing - we actually understand it, after all.
02:58:51 <Baughn> Well, some people do..
03:00:22 <ndmitchell> If you exclude the monads, Haskell is very understandable
03:02:34 <solrize_> engineers and scientists are usually comfortable with calculus-style math but for haskell you have to be comfortable with algebra-style thinking
03:02:47 <dfranke> meh, monads are just the first hurdle.  Plenty of bigger ones after that.
03:03:10 <dfranke> arrows, monad transformers, GADTs...
03:03:48 <ndmitchell> dfranke, but i've successfully got through a whole PhD in Haskell without hitting any of those - they really are optional
03:04:17 <opqdonut> monad transformers and GADTs are pretty simple
03:04:39 <opqdonut> there's some deep stuff in arrows but mostly you don't have to know about it
03:04:54 <dfranke> oh, and SYB
03:05:02 <opqdonut> SYB?
03:05:07 <ndmitchell> SYB is way too complex, learn Uniplate insteadd
03:05:26 <ndmitchell> Scrap Your Boilerplate - Data.Generics
03:05:58 <opqdonut> ah
03:06:11 <solrize_> understainding how those things operate is like understanding how the horsie moves in chess.  developing actual skill at the game takes a heck of a lot longer.
03:06:16 <ndmitchell> although learning SYB is very handy, i'd say much more so than the other things
03:07:06 <opqdonut> in terms of skill designing data structures and algorithms can be a bit challenging
03:07:16 <opqdonut> also choosing the right abstraction mechanisms
03:08:07 <achilles14> I found I'm writing  recursive functions all the time.
03:08:36 <solrize_> that's a phase you get over
03:09:10 <solrize_> ndm have you looked at the disciplined disciple compiler?
03:09:25 <solrize_> is it interesting?
03:09:32 <kiris> does that graph of activity in
03:09:59 <kiris> #haskell still exist? the one showing the strength of relationships between chatters
03:11:16 <solrize_> i saw it recently
03:12:41 <_Dae_> @bot
03:12:41 <lambdabot> :)
03:14:19 <ndmitchell> solrize_ i saw a talk about it, yeah, is interesting, but fairly confusing type stuff
03:14:40 <ndmitchell> solrize_: some very interesting bits, like abstracting over monad/no-monad-ness
03:14:58 <_Dae_> I guess the biggest problem with learning monads is that even when you've understood what they are and what they do, they seem unelegant compared to haskell in general.
03:16:35 <sieni> actually they are not that inelegant
03:17:08 <sieni> for example software transactional memory and monadic io fits together like a fist in ass
03:17:17 <opqdonut> and parsec is pretty sweet too
03:17:41 * quicksilver has successfully programmed haskell for some years without ever putting his fist in a donkey.
03:18:24 <kiris> quicksilver: you were lucky
03:18:24 <opqdonut> :>
03:20:08 <_Dae_> *shrugs* perhaps they're not. I've mainly used ST, and it always seemed like a poor substitute for an imperative language, which is a shame
03:20:29 <quicksilver> why is it a poor substitute?
03:20:38 <quicksilver> it *is* an imperative language, in a sense.
03:20:51 <quicksilver> which aspect of it seems poor compared to "your-favourite-imperative-language"
03:21:01 <quicksilver> ?
03:22:34 <_Dae_> syntax partially. I have to do loops in ST, and writing them is a pain compared to using "for" or "while" in any other language... Some of it is probably lack of experience, but I have yet to find a better solution.
03:22:50 <Cale> _Dae_: Look at the Control.Monad library
03:23:04 <Cale> _Dae_: In particular forM/forM_ might be what you're looking for.
03:23:49 <quicksilver> mapM/forM are good looping constructs.
03:23:58 <quicksilver> there is nothing quite like while but it's easy to write
03:24:09 <quicksilver> (there are a few sightly different versions you might imagine)
03:24:22 <_Dae_> Cale: Already using them where I can. But take a thing like matrix multiplication using ST....  how would you write that elegantly?
03:24:58 <Cale> _Dae_: hmm, I'd use a list comprehension.
03:25:04 <solrize_> dolio has a module with python-like generators
03:26:09 <_Dae_> Cale: Yes?
03:26:30 <Cale> _Dae_: sorry, talking to other people at the same time :P
03:26:36 <Cale> _Dae_: I'll give it a shot.
03:26:55 <Cale> _Dae_: It would look quite a lot like the one for immutable arrays.
03:27:12 <quicksilver> forM_ [1..m] $ \x -> forM_ [1..n] -> \y -> do col <- forM [1..m] $ \xx -> readArray a (xx,m); row <- forM [1..n] $ \yy -> readArray b (n,yy);
03:27:30 <quicksilver> writeArray c (n,m) (dotprod col row)
03:27:34 <quicksilver> something like that?
03:28:24 <Cale> mm, sure
03:28:34 <Cale> though you can combine the for loops
03:28:42 <quicksilver> dotprod is left to the reader but it's a pure function.
03:28:54 <quicksilver> in fact, it's zipWith (*), perhaps.
03:29:00 <quicksilver> sum $ zipWith (*)
03:29:33 <quicksilver> well yes, you don't need to keep re-reading the whole column
03:29:48 <quicksilver> since you use the same column over and over.
03:30:24 <_Dae_> heh...right.... I guess that is slightly nicer than my current version....
03:30:34 <quicksilver> and you could pre-process the arrays into lists of vectors
03:30:35 <quicksilver> if you chose
03:30:40 <Cale> since you're iterating over all pairs, you can use one forM to set both indices
03:30:46 * quicksilver nods
03:31:08 <quicksilver> yes the reason I used two forMs is I thought that might look more like the C code.
03:31:11 <hpaste>  _Dae_ pasted "Ugly matrix multiplication" at http://hpaste.org/8761
03:31:48 <quicksilver> _Dae_: ouch :-(
03:32:01 <quicksilver> _Dae_: using while-style-loops instead of for sure makes it ugly.
03:32:02 <_Dae_> I took most of that from a speedup guide for haskell
03:32:11 <Cale> ...
03:32:21 <Cale> Which guide?
03:32:58 <baaba> can i pass a data constructor "Foo bar" to a function "f ctor" and then somehow in f match "case baz of ctor quux -> True; otherwise False" ?
03:33:01 <_Dae_> I think it was in the beginning on one of the articles on stream fusions....
03:33:10 <Cale> baaba: nope
03:33:14 <baaba> :<
03:33:17 <quicksilver> _Dae_: I think you might have suffered from premature optimization which is making your code look uglier than it needs to.
03:33:32 <quicksilver> _Dae_: it is true that, under some circumstances, you can speed your code up at the cost of uglification.
03:33:34 <Baughn> baaba: You can pass a predicate in and use guards, though
03:33:37 <quicksilver> but that's not where you shoudl start :)
03:34:28 <baaba> Baughn, yeah i'm just trying to factor out a somewhat large repeated piece of syntax but since it relies on matching against a single data constructor it doesn't seem like i can
03:34:50 <quicksilver> baaba: yes, constructors are not first class values
03:34:50 <Baughn> baaba: Template haskell, maybe. Or paste the code; someone might have ideas.
03:34:59 <quicksilver> try using the related indicator function instead
03:35:10 <quicksilver> (that is, "isFoo :: X -> Bool")
03:36:15 <baaba> is that somehow predefined or do i write it myself?
03:36:42 <Cale> baaba: However, you can match a fixed constructor without having to mention the fields, like   case foo of Foo {} -> ...
03:37:02 <Cale> (which works even if the datatype isn't defined using record syntax)
03:37:32 <baaba> ah, that's cool though not related to my problem, but good to know :)
03:37:43 <quicksilver> the main places I hit day-to-day abstraction barriers in haskell are the facts that record selectors and constructors are not first-class.
03:37:46 <baaba> (i'm doing the write yourself a scheme in 48 hours thing)
03:37:51 <quicksilver> in any particular case there is always a workaround though.
03:37:54 <_Dae_> quicksilver: it started as a pure function, then I wanted to speed it up.... but I guess the compiler should more or less rewrite your function for me....
03:43:46 <Cale> baaba: Well, you can use that trick when writing your 'isFoo' function and prevent a small bit of future pain if the Foo constructor's fields need to be changed.
03:44:07 <baaba> yeah
04:13:03 <chr1s> anybody here compiled their own version of GHC 6.8.3 on a Mac?
04:13:19 <chr1s> my readline support is broken, and I'm not sure why. during ./configure, everything worked fine.
04:13:32 <chr1s> and configure even told me it had found readline.
04:13:35 <opqdonut> readline was due to be removed at some point
04:14:09 <chr1s> well, that's not a big problem, but currently I can't even usy my backspace button.
04:14:22 <chr1s> that's not really....convenient.
04:14:46 <Baughn> chr1s: Replaced, not just removed
04:14:55 <chr1s> ah
04:14:57 <opqdonut> yeah, that actually
04:15:00 <Baughn> chr1s: I have, and I did have a spot of trouble getting readline to work. Figured it out, though
04:15:09 <chr1s> Baughn: so what did you do?
04:15:20 <Baughn> chr1s: Well, that's..
04:15:49 <Baughn> chr1s: Passed --with-readline-includes and --with-readline-libraries to configure, both set to the fink-installed version
04:16:10 <chr1s> ah, I'll try that then. thanks!
04:16:57 <Baughn> chr1s: It gets passed down to the library in libraries/readline. You could try configuring that by hand to get quicker response, but while installing it on its own will get you readline /library/ support, it won't get you a working ghci
04:17:47 <chr1s> Baughn: I'll just try a complete compile.
04:18:38 <Baughn> chr1s: If configuring just the library works, so should the compile
04:18:49 <Baughn> (The other isn't quite as true - the library depends on ghc-6.8.3)
04:19:07 <Baughn> Or. Well. Maybe - actually, quite likely not.
04:19:42 <Kristoffer_> #haskell
04:20:03 <Vq^> välkommen Kristoffer_
04:20:22 <Baughn> Vær hilset
04:20:56 <_Dae_> Spændende....
04:24:21 <chr1s> Baughn: thanks! then I'll start with the library.
04:29:45 * Toxaris searchs for an icfp contest team to take him in
04:31:40 <kiris> there a function that inverts an Ordering?
04:32:12 <kiris> inverse LT = GT
04:32:12 <kiris> inverse GT = LT
04:32:12 <kiris> inverse k  = k
04:32:15 <kiris> something like that
04:32:28 <kiris> maybe there is an inverse class..
04:32:39 <Cale> kiris: Not that I'm aware of, but if you're using compare to make it, just flip compare.
04:32:46 <opqdonut> yeh
04:32:46 <_zenon_> Slow day on #haskell
04:33:07 <kiris> ah, good point
04:33:16 <kiris> I'm using `comparing'
04:34:08 <kiris> flip compare `on` snd ^_^
04:34:11 <Cale> So... flip (comparing f)
04:34:21 <Cale> or flip (comparing snd)
04:34:21 <kiris> oh
04:34:51 <Toxaris> newtype Reverse x = Reverse x; instance Ord x => Ord (Reverse x) where compare = flip compare;
04:35:53 <Toxaris> may be usable in some cases, but leads to newtype hell in most
04:46:35 <chr1s> Baughn: which directories did you provide for the readline support? I also installed readline from fink, but it still seems to fail.
04:51:29 <chr1s> Baughn: ah nevermind, think I got it.
04:52:56 <plutonas> i'm doing this book.realworldhaskell.org and in the adler32 function i'm stuck, i wrote the code in a file, i can lode the file but the function doesn't seem to exist. why could this be?
05:03:40 <_zenon_> plutonas: Which chapter is it in?
05:03:45 <plutonas> 5
05:03:56 <plutonas> _zenon_: ^^^
05:06:16 <joey_> plutonas: Sure you're spelling the name the same/loading the right file?
05:06:20 <_zenon_> plutonas: Have you tried calling it?
05:06:34 <_zenon_> plutonas: Are you using ghci?
05:07:00 <plutonas> yeap
05:07:12 <_zenon_> have you tried autocompleting?
05:07:13 <plutonas> yes to both of you, let me try again
05:07:26 <_zenon_> typing ad   and then tabbing
05:07:29 <plutonas> yes, autocompleting completes only the filename which is adler-32.hs
05:07:40 <plutonas> not the function whose name is adler32
05:07:49 <joey_> What error do you get when calling the function?
05:07:51 <_zenon_> will you hpaste your file?
05:08:06 <plutonas> yes sure
05:08:10 <plutonas> joey_: not in scope
05:08:12 <plutonas> wait i'm pasting
05:08:36 <plutonas> it's probably something stupid i can't see
05:08:53 <hpaste>  plutonas pasted "what's wrong?" at http://hpaste.org/8763
05:10:00 <joey_> Hmm, I don't see any problems
05:10:08 <_zenon_> plutonas: I get it to work perfectly.
05:10:11 <plutonas> it runs for you?
05:10:12 <plutonas> !!!
05:10:22 <joey_> You've not got two copes of Adler-32.hs or something, and :loading the wrong copy? :)
05:10:38 <plutonas> oh wait
05:10:53 <joey_> Is the prompt at GHCi "*Main>" ?
05:10:53 <plutonas> :S
05:11:06 * plutonas is damn stupid
05:11:17 <plutonas> sorry for taking your time on this
05:11:25 <_zenon_> hehehe
05:11:26 <joey_> Wrong file?
05:11:28 <plutonas> yes
05:11:32 <joey_> Heh, no problem
05:21:21 <smg> hello.
05:21:55 <smg> i struggled today in the exam.
05:22:27 <smg> i needed to calculate types of flip map and map flip with milner :) but i luckily solved it in the end. :)
05:23:30 <quicksilver> they let you take milner into the exam with you?
05:23:33 <quicksilver> that's generous of them.
05:23:33 <smtms> is that an introductory or advanced FP course?
05:23:38 <quicksilver> Where did you put him? How is he?
05:23:45 <smg> intro to programming smtms  :/
05:23:56 <smg> quicksilver: i need to solve with milner algorithm :)
05:23:58 <smg> quicksilver: sorry.
05:24:41 <kiris> bad jokes about word usage :P
05:25:15 <smg> hehe i'm just lucky i found out, i just thought about what "flip" does and so it came to my mind what the types should be :)
05:25:28 <smg> i even did not need milner algorithm, i just "knew" it without using it
05:26:19 <opqdonut> heh, milner into the exam
05:26:33 <opqdonut> smg: well the milner algorithm is quite intuitive
05:26:45 <opqdonut> but yeah, usually one just sees the type
05:26:50 <opqdonut> (or asks ghci for it)
05:26:54 <smg> opqdonut: yeah but we had bad examples for it
05:27:04 <smg> opqdonut: only very easy like map id or map const
05:27:21 <opqdonut> mhmm
05:27:49 <smg> opqdonut: :]
05:28:19 <smg> opqdonut: we had only one rule
05:28:51 <smg> expression :: ο -> ο_1 -> ο_n -> τ :: γ(τ) = γ(ο)
05:28:55 <smg> --------------------------------------------------------------------------------------
05:29:06 <smg> expression args :: γ(τ)
05:29:36 <smg> i know this rule is most general but it was kinda tricky because of the (a -> b -> c) and (a -> b) of map to unificate etc
05:29:37 <smg> :)
05:30:34 <quicksilver> trick 1 : choose disjoint sets of variables
05:30:45 <quicksilver> trick 2 : place parens explicitly
05:30:54 <smg> quicksilver: exactly that i figured out!!
05:30:55 <quicksilver> (a -> (b -> c)) and (d -> e) are easier to unify.
05:31:01 <smg> but we were never told that "tricks"
05:31:08 <smg> we only had map id; map const :)
05:31:13 <smg> only "easy" unifications you know? :)
05:33:58 <smg> quicksilver: but good that you are confirming this
05:34:03 <smg> quicksilver: now the points are mine, har har! :)
05:40:34 <jansz> @pl (\(a,b)-> a++[b])
05:40:34 <lambdabot> uncurry ((. return) . (++))
05:41:03 <smg> haskell is fascinating
05:54:26 <_zenon_> smg: indeed it is.
05:58:24 <PeakerWork> I skimmed through the examples in the paper "Why Dependent Types matter", where he demonstrated the implementation of a merge-sort. It does seem to prove that the sort will halt, but not extra items of interest (that the sort result will have ascending order and contain all of the input elements!)
05:58:31 <PeakerWork> did I just miss that, or is that not proven?
06:00:13 <enoksrd> @pl (\x -> x-1)
06:00:14 <lambdabot> subtract 1
06:00:44 <Syzygy|de> @tell yaxu I'll be in Stanford starting this autumn, and just realized that Ge Wang _teaches_ Livecoding there; AND that I will be eligible to take courses!!
06:00:44 <lambdabot> Consider it noted.
06:00:50 <smtms> it's left as an exercise for the reader :-)
06:05:51 <enoksrd> @pl ((\xxs -> xxs >>= id)::[[a]] -> [a])
06:05:52 <lambdabot> (line 1, column 30):
06:05:52 <lambdabot> unexpected ">"
06:05:52 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or ")"
06:06:08 <byorgey> Syzygy|de: cool! =)
06:06:24 <dolio> Proving sortedness is probably a lot more work.
06:06:40 <dolio> You get termination for free just for successfully writing mergesort in epigram.
06:07:00 <dolio> (If you don't cheat, that is.
06:07:08 <Syzygy|de> byorgey: Innit? :)
06:07:24 <_zenon_> PeakerWork: Did someone prove that a program will halt? Errr....
06:07:32 <Syzygy|de> In a year or so I might be playing in the Stanford Laptop Orchestra... :)
06:07:41 <quicksilver> _zenon_: I can prove that a thousand programs will halt.
06:07:58 <_zenon_> I mean decide
06:07:59 <quicksilver> _zenon_: what I can't do is give you a general algorithm that will, for any program P,...
06:08:15 <byorgey> Syzygy|de: one of these days I'm going to play around with computer music/livecoding more.  It seems kind of dumb that I'm a hacker and a musician but never have done much combining the two. =)
06:08:42 <quicksilver> in fact, the construction of the halting problem proof only shows that there is *one* program whose halting you can't decide.
06:08:53 <quicksilver> for all you can see from that proof, it may be that every other program is decidable.
06:08:57 <_zenon_> quicksilver; I know the halting problem.
06:08:59 <quicksilver> (this is not, in fact, the case though)
06:09:14 <_zenon_> I misread what he wrote, in the haste.
06:09:15 <byorgey> Syzygy|de: heh, I've never heard of the Stanford Laptop Orchestra, sounds cool
06:09:17 * byorgey googles
06:09:37 <Syzygy|de> byorgey: So far I've had hardware troubles getting seriously into the livecoding corner.
06:09:59 <Syzygy|de> But it seems as if my postdoc at Stanford will provide me with a macbook pro, under which all the commonly used platforms run comfortably.
06:10:11 <byorgey> awesome.
06:10:16 <Syzygy|de> Yup!
06:10:35 <vixey> > 37
06:10:39 <Syzygy|de> I just found out too: they'll happily order me one with swedish keyboard layout - ordering it from Sweden if need be.
06:10:41 <lambdabot>  37
06:10:42 <Syzygy|de> 37
06:11:47 <Baughn> Syzygy|de: And yet, an english layout is the One True Programming Layout
06:12:33 <Syzygy|de> Baughn: May be, but I always grow confused using an english layout. The swedish qwerty is hardwired by me.
06:12:40 <_zenon_> dvorak
06:13:02 <Syzygy|de> And I'm using åäöüßéè enough that the english layout grows annoying++.
06:13:20 * byorgey uses the 'brenty' layout instead of 'qwerty' so he can sign his name just by running an index finger across the top row
06:13:31 <Cale> @karma annoying
06:13:32 <lambdabot> annoying has a karma of 0
06:13:45 <Syzygy|de> _zenon_: The whole idea was to NOT rewire me. I know of the theoretical supremacy of dvorak (or svorak as it were) but I simply don't care.
06:13:48 <vixey> lol
06:13:58 <mar77a> @karma c
06:13:58 <lambdabot> c has a karma of 15
06:14:04 <Syzygy|de> @karma c++
06:14:04 <lambdabot> c++ has a karma of -8
06:14:05 <mar77a> :D
06:14:15 <dolio> Wow.
06:14:21 <dolio> @karma Java
06:14:21 <lambdabot> Java has a karma of -23
06:14:23 <Baughn> Syzygy|de: Theoretical is all it may be. There are serious problems with the tests that claim it's superior, so..
06:14:24 * quicksilver uses and optimus maximus and randomises the keyboard every morning to keep the challenge fresh.
06:14:25 <ziman> heh
06:14:32 <ziman> @karma cobol
06:14:32 <lambdabot> cobol has a karma of -3
06:14:37 <RayNbow> @karma logo
06:14:37 <lambdabot> logo has a karma of 0
06:14:38 <_zenon_> <Syzygy|de: I was not telling you :) I am swedish myself, but I was countering the "English ... One True..."
06:14:42 <RayNbow> logo++
06:14:52 <RayNbow> @karma logo
06:14:52 <ziman> @karma haskell
06:14:52 <lambdabot> logo has a karma of 1
06:14:52 <lambdabot> haskell has a karma of 23
06:14:57 <vixey> logo++
06:14:59 <Baughn> @karma @karma
06:15:00 <lambdabot>  @karma has a karma of 1
06:15:12 <Baughn> @karma--
06:15:12 <lambdabot> usage @karma(+|-) nick
06:15:22 <mar77a> @karma foldr
06:15:23 <lambdabot> foldr has a karma of 0
06:15:29 <enoksrd> @pl--
06:15:29 <lambdabot> (line 1, column 1):
06:15:29 <lambdabot> unexpected end of input
06:15:29 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
06:15:37 <Cale> @karma chameleon
06:15:37 <lambdabot> chameleon has a karma of 2
06:15:47 <mar77a>  @krama
06:15:49 <mar77a> ops
06:15:53 <_zenon_> Syzygy|de : :)
06:16:06 <RayNbow> @karma zygohistomorphic prepromorphisms
06:16:07 <lambdabot> zygohistomorphic has a karma of 0
06:16:31 <Syzygy|de> zeno___: Ah.
06:16:34 <Syzygy|de> Hrm.
06:16:36 <Syzygy|de> _zenon_: Ah.
06:16:55 <vixey> @karma (zygohistomorphic prepromorphisms)
06:16:56 <lambdabot> (zygohistomorphic has a karma of 0
06:17:15 <Syzygy|de> What on earth IS a zygohistomorphic prepromorphism?
06:18:20 <ziman> http://www.haskell.org/haskellwiki/Zygohistomorphic_prepromorphisms
06:18:22 <lambdabot> Title: Zygohistomorphic prepromorphisms - HaskellWiki, http://tinyurl.com/66ubol
06:19:50 <RayNbow> corresponding reddit thread: http://www.reddit.com/r/programming/info/6ml1y/comments/
06:19:51 <lambdabot> Title: programming: A pretty useful haskell snippet
06:22:48 <_zenon_> Suzugu|de : What do you do ?
06:23:05 <_zenon_> Syzygy|de: [well typed] , What is your position?
06:24:23 <Syzygy|de> _zenon_: I'm a mathematician. Currently phd student in Germany, but I'm defending in just over a week, and I'll start at Stanford as a postdoc.
06:25:01 <_zenon_> Syzygy|de: Okay, I'll have to congratulate you in advance then :), What is your topic?
06:25:27 <Syzygy|de> Thesis or postdoc?
06:27:03 <_zenon_> Syzygy|de: Thesis
06:27:18 <_zenon_> sorry (I am working :: a bit :)  )
06:27:26 <Syzygy|de> Computation of A-infinity algebra structures in group cohomology.
06:27:35 <Syzygy|de> http://mpc723.mati.uni-jena.de/~mik/thesis.pdf
06:29:25 <hpaste>  gwern pasted "broken defaults" at http://hpaste.org/8764
06:32:00 <_zenon_> Syzygy|de: Who would you recommend reading your Thesis?
06:33:41 <quicksilver> people who wish to compute A-infinity algebra structures, perhaps?
06:33:55 <Syzygy|de> _zenon_: People who want to compute or learn about A-infinity algebra structures.
06:34:01 <profmakx> whee group cohomology
06:34:11 <kiris> hehe, all words of July in #haskell: http://img384.imageshack.us/img384/7725/haskell3bf7.png
06:34:11 <Syzygy|de> A decent grounding in the basics of homological algebra is expected, group cohomology knowledge not.
06:34:18 <profmakx> and i know prof. green :)
06:34:34 <profmakx> Syzygy|de, did you ever meet Juergen Mueller in Jena?
06:35:08 <Syzygy|de> profmakx: No, but I met him in Aachen.
06:35:12 <Syzygy|de> profmakx: You know Green? Cooooool.
06:35:13 <_zenon_> kiris: Hehe :) What is the dependence of word size in the image?
06:35:20 <kiris> _zenon_: frequency
06:35:30 <profmakx> well "know" might be too much to say ;)
06:35:37 <_zenon_> kiris: Nice :) Nice indeed :)
06:35:47 <kiris> _zenon_: http://wordle.net/
06:35:48 <lambdabot> Title: Wordle - Beautiful Word Clouds
06:35:49 <profmakx> heh. i am in aachen just now
06:35:56 <Syzygy|de> :)
06:36:19 <quicksilver> kiris: hrm, very pretty.
06:36:47 <_zenon_> Interesting that "like" is so frequent
06:37:01 <kiris> "that's, like, your opinion, man"
06:37:10 <quicksilver> is Dae the only nick to make the list?
06:37:12 <shepheb> kiris: very cool. do we have a talk-the-most top 10 somewhere?
06:37:39 <quicksilver> shepheb: yes we do
06:38:18 <kiris> where is it?
06:38:20 <quicksilver> http://www.cse.unsw.edu.au/~dons/irc/haskell-08.html
06:38:21 <lambdabot> Title: #haskell @ freenode.org stats by dons
06:38:49 <kiris> thanks :)
06:38:54 <profmakx> Syzygy|de, what will you be researching on in stanford?
06:39:06 <shepheb> hahaha my top-4 estimate was right
06:39:19 <kiris> I like how on http://www.cse.unsw.edu.au/~dons/irc/ 2008 has already reached as high as 2006 and it's only July
06:39:20 <lambdabot> Title: Haskell IRC Activity
06:39:23 <Syzygy|de> profmakx: Automated topological data analysis
06:40:10 <profmakx> Syzygy|de  sounds quite different from A_infinity algebras :)
06:40:13 <Syzygy|de> It is.
06:40:23 <Syzygy|de> But then, changes of direction by the time you get to postdoc aren't common.
06:40:37 <Syzygy|de> And I'll end up looking at multiplicative structures on cohomology rings in both cases.
06:41:40 <profmakx> aren't common or aren
06:41:44 <profmakx> nt uncommon
06:41:48 <profmakx> damnit
06:41:55 <Syzygy|de> aren't uncommon, I meant to say.
06:42:04 <Syzygy|de> nothing surprising about them.
06:42:29 <profmakx> well, for me it's write PhD thesis first
06:42:39 <profmakx> and then decide whether i want a postdoc position ;)
06:44:34 * ndmitchell wants a postdoc in haskell
06:44:44 <_zenon_> Is there a year-wide top-words chart?
06:44:51 <Syzygy|de> ndmitchell: You can take almost any postdoc and MAKE it about haskell. :)
06:45:13 <ziman> wow, `monad' is the sixth most frequently used word
06:45:17 <quicksilver> _zenon_: yes, in the link I just pasted you.
06:45:26 <quicksilver> well, year-to-date
06:45:52 <profmakx> i will definitely be coding all my phd stuff in haskell
06:45:56 <ndmitchell> Syzygy|de: perhaps, but i'm kind of stuck to positions in Cambridge, which makes finding anything a bit harder
06:46:08 <Syzygy|de> Cambridge UK or Cambridge MA?
06:46:42 <ndmitchell> UK
06:46:47 <_zenon_> quicksilver, I mean like the one with the words printed out in proportion to eachother based on frequency.
06:47:58 <kiris> I'm thinking of writing one in haskell because wordle is closed source
06:48:40 <_zenon_> kiris: That would be nice.
06:49:11 <quicksilver> ah
06:49:15 * quicksilver nods
06:49:32 <kiris> ah, here's the piespy, as of 4th april: http://files.codersbase.com/haskell/haskell-current.png
06:49:58 <opqdonut> should be zoomable :)
06:50:14 <kiris> I agree
06:52:01 <luite_> it should be planar ;)
06:52:36 <ziman> quite.. dense :)
06:52:40 <opqdonut> luite_: I suspect there are numerous 5-cliques ;)
06:54:13 <Syzygy|de> opqdonut: As well as numerous embedded K33.
06:54:18 <quicksilver> looks like it needs the decay parameters tuning.
06:54:58 <Syzygy|de> I talk to both Cale and dcoutts_, they talk to each other, and we all talk to quicksilver, dons and byorgey, who all talk to each other. Shazam - nonplanarity!
06:55:21 <Syzygy|de> Though this K33 probably really is a K6, containing a K5....
06:55:30 <opqdonut> :)
07:02:59 <Axman6> > repeat "Axman6 "
07:03:02 <lambdabot>  ["Axman6 ","Axman6 ","Axman6 ","Axman6 ","Axman6 ","Axman6 ","Axman6 ","Axma...
07:03:08 <Axman6> that's better
07:03:32 <kiris> great, now you've manipulated the word frequency of Axman6 :P
07:03:35 <vixey> lol
07:03:53 <Axman6> oh no, you've seen through my evil plan!
07:04:15 <Axman6> i was going to boost my google page rank, but i have been thwarted!
07:04:26 <Axman6> also, no one else would say my name in another chan -_-
07:04:31 <kiris> you are clearly a zombie
07:04:33 <idnar> heh
07:04:52 <_zenon_> May I suppose an arc (x, y) => x used y's name || y used x's name ?
07:04:53 <Axman6> very much so
07:05:12 <quicksilver> slightly stronger than that
07:05:25 <quicksilver> it tries to deduce adjacency for non-addresses commments
07:05:26 <quicksilver> AIUI
07:05:28 <_zenon_> oohhh....which is the mechanism then? *intrigued*
07:05:42 <_zenon_> okay.
07:06:03 <_zenon_> Which are the present nodes?
07:06:12 <quicksilver> except mechanism is unknown
07:06:16 <quicksilver> except to people who read the soruce
07:06:21 <quicksilver> warning it's in java :P
07:06:21 <Axman6> i've forgotten, can haskell match something like f x y and f x x?
07:06:34 <Axman6> so, two arguments are the same
07:06:38 <kiris> java is hard, let's go haskelling
07:06:44 <ToRA> Axman6: nope
07:06:47 <Baughn> Axman6: Sure, "f x y | x == y"
07:07:11 <kiris> f = (==)
07:07:21 <Baughn> Axman6: You can stick arbitrary predicates in guards
07:07:55 <Axman6> just wondering because it's something that is quite useful in Erlang
07:08:01 <ToRA> but you can't unify two arguments to be the same
07:08:08 <Axman6> makes a for loop type thing pretty easy
07:08:15 <_zenon_> quicksilver.... hm.. I like this :) It's completely unnecessary but interesting :)
07:08:26 <quicksilver> _zenon_: :)
07:08:30 <Baughn> > let f x y | x == y = 2; f x y = x+y in (f 3 4, f 3 3)
07:08:31 <lambdabot>  (7,2)
07:09:28 <Baughn> Axman6: Oh, and most of the time you don't want to use explicit recursion
07:09:29 <Axman6> anyway, i got 95% in my comp course, which was mostly haskell :)
07:09:35 * Axman6 celebrates
07:09:44 <Baughn> There are /plenty/ of alternatives. fold, iterate, scan, map...
07:09:58 <Axman6> i know
07:11:28 <kiris> oh wows, libgd bindings on hackage. bringert<333
07:17:07 <quicksilver> kiris: would be more useful if it actually gave some acces to the Image data, IMO.
07:18:29 <kiris> I can see how that would be useful
07:20:50 <gwern> out of curisotiy, anyone know whether it is possible to pipe modules into ghc instead of making a file?
07:21:23 <earthy> gwern: that'd be tough
07:21:25 <Taejo> gwern: perhaps you could specify /dev/stdin as an input file
07:22:24 <gwern> I thought since we already have -e, it might be doable
07:22:30 <gwern> but of course -e wouldn
07:22:38 <gwern> `'t allow for stuff like imports
07:23:40 <earthy> macadamia:tmp arthurvl$ cat gencal.hs | ghc /dev/stdin -odir . -o test
07:23:40 <earthy> ghc-6.8.3: cannot compile this file to desired target: /dev/stdin
07:24:20 <gwern> maybe the -o needs to come before
07:25:26 <ToRA> earthy: doesn't work, ghc does a getfilesize
07:25:43 * ToRA tried symlinking StdIn.hs to /dev/fd/0
07:26:57 <JaffaCake> ToRA: -x hs?
07:27:30 <ToRA> >ls -la StdIn.hs
07:27:31 <ToRA> lrwxrwxrwx 1 tora tora 15 2008-07-07 15:24 StdIn.hs -> /proc/self/fd/0
07:27:35 <ToRA> >echo module Main where main = putStrLn "hello" | ghc -x hs -o Foo StdIn.hs
07:27:35 <ToRA> StdIn.hs: hFileSize: inappropriate type (not a regular file)
07:29:21 <jeffersonheard> Alright...  I'm trying to call withStorableArray on this object returned by Gtk.pixbufGetPixels
07:30:18 <ziman> mkfifo?
07:31:13 <dolio> "In fact, if you can't trivially prove your program halts when it should do that's probably a bug in its own right."
07:31:16 <gwern> ziman: my hope here was to avoid any file I/O
07:31:31 <jeffersonheard> gah.  coredumped.  how lovely
07:32:18 <jeffersonheard> I was going to ask.  I've got this PixbufData i e object which by the doc looks like a Storable MArray, but when I call withStorableArray, I get a type error
07:32:28 <laz0r> does anyone know if there is any good yampa stuff i could look at out there?besides the tutorials like yampa-arcade.pdf and frag.
07:32:34 <jeffersonheard> anybody know how this should really be done?
07:32:53 <laz0r> maybe something like frag, that is source code i could read, but a little bit more simple maybe?
07:32:56 <quicksilver> jeffersonheard: it's an instance of MArray
07:32:59 <quicksilver> jeffersonheard: use the instance.
07:33:51 <jeffersonheard> I thought so, but I've got this code:
07:33:55 <jeffersonheard> pixels <- Gtk.pixbufGetPixels pixbuf :: IO (Gtk.PixbufData Int Word8)
07:34:03 <jeffersonheard>  MArr.withStorableArray pixels $ \dat -> do...
07:34:39 <jeffersonheard> which says couldn't match expected type MArr.StorableArray i e against ingerred type Gtk.PixbufData Int Word8
07:35:16 <quicksilver> you shouldn't be using MArr
07:35:21 <quicksilver> or withStorableArray
07:35:33 <quicksilver> (I don't even know what they are? something from the new uvector stuff)
07:35:38 <quicksilver> this is just a plain basic MArray
07:35:58 <jeffersonheard> No, sorry...  MArr is aliased qualified import of Data.Array.Storable
07:36:12 <quicksilver> still that isn't what you want.
07:36:18 <quicksilver> you want MArray.
07:36:22 <jeffersonheard> okay.
07:36:41 <quicksilver> you'll see in the docs for PixbufData
07:36:49 <quicksilver> that it declares it is an instance of MArray
07:36:53 <quicksilver> that's the array I'm talking about :)
07:37:07 <jeffersonheard> Thanks :)...  maybe I'm approaching this wrong.  I'm trying to load a GtkPixbuf  into an OpenGL texture
07:38:15 <quicksilver> unfortunately this interface can't give you a zero-copy access to that.
07:38:32 <quicksilver> you're going to have to pull the elements out of that MArray and stuff them into something texImage2D can use.
07:38:32 <adekoba> anyone know how to get firefox-3 to display .hs files in the browser?
07:38:50 <quicksilver> adekoba: yes. Serve them as plain text.
07:39:05 <jeffersonheard> I'm seeing that now...   Do you know if there is an interface out there that'll do that?  If not I can handle the copy now that I see what's wrong, just irritating
07:39:22 <quicksilver> adekoba: preferably whilst swearing loudly and for a long period of time and cursing the mozilla developers for being unable to solve a bug which has been open for about 15 years
07:39:46 <adekoba> quicksilver: that would be possible if it were on my own website, but what about for other websites?
07:39:46 <quicksilver> adekoba: alternatively, there are some plugins out there. YOu could swear a bit whilst downloading them as a bonus.
07:39:56 <jeffersonheard> lol
07:40:01 <adekoba> ah, I will look for them. thanks.
07:41:26 <quicksilver> jeffersonheard: I don't know but it doesn't look like it from that doc you have just shown me.
07:41:38 <quicksilver> jeffersonheard: well, the doc I found by googling the function name you gave me, rather :)
07:41:39 <jeffersonheard> k.  Thanks.
07:41:44 <laz0r> @src reactInit
07:41:44 <jeffersonheard> I'll work around the copy
07:41:44 <lambdabot> Source not found.
07:41:55 <quicksilver> jeffersonheard: I'm sure they'd be sympathetic to a suggestion along those lines.
07:42:16 <quicksilver> dcoutts_: would be nice if pixbufs exposed a way to get access to an underlying Ptr for use with other C libraries.
07:42:17 <misterbeebee_> Can I use GHC to cross-compile from Mac OS X to a statically linked Linux binary? I've worked hard to install libraries on Mac, and don't want to repeat all the effort.  (Extra credit (1): If I use precompiled Haskell libraries on my dev machine, is my cross-compile in trouble? Extra credit (2): If I use Haskell bindings to C-libraries in my program, am I going to have trouble cross-compiling? I'd guess yes)
07:42:26 <quicksilver> misterbeebee_: No.
07:42:34 <quicksilver> misterbeebee_: GHC cannot cross compile at all.
07:42:48 <misterbeebee_> oh boy
07:43:29 <misterbeebee_> So I have to install all the needed libraries on the target platform and compile there...
07:43:36 <vixey> I don't understand cross compiling.. what' the point if you can't check what you built runs?
07:43:57 <quicksilver> misterbeebee_: fortunately on a well designed linux system it is just apt-get install foo; cabal install bar;
07:44:06 <quicksilver> misterbeebee_: should take you about 1000th of the time it did under OSX :P
07:44:29 <misterbeebee_> vixey: the point is that you can test when you're done, not every time you make a code change, (and ideally, there are no surprises)
07:45:15 <vixey> I don't understand
07:45:17 <opqdonut> vixey: well if the intended platform is too low-end to do the actual compilation for instance...
07:45:23 <opqdonut> you need crosscompiling
07:45:29 <opqdonut> no relevance to this case, of course
07:46:19 <misterbeebee_> quicksilver: ICFP contest in 4 days requires linux submissions, and they haven't published their liveCD yet, so I'm running out of time to set up a GHC environment on my target platform :-(
07:46:48 <vixey> oh I see.. that sucks
07:49:44 <Philippa> opqdonut: or if there isn't a compiler available on the target yet you might just want to, y'know, compile one
07:50:35 <vixey> I was thinking about robotics or somithng
07:55:27 <Baughn> misterbeebee_: Well, what os are you on now?
07:55:37 <misterbeebee_> Now I'm on Max OS X Leopard
07:55:58 <Baughn> It strikes me that /most/ haskel programs should run without modification on any supported platform
07:56:10 <Baughn> Certainly including the pure-computation sort you get in icfp
07:56:34 <misterbeebee_> Baughn: you mean you don't think I'd need tricky libraries?
07:57:01 <misterbeebee_> Baughn: because i'll definitely need an ELF executable, which Mac ghc won't give me. (right?)
07:57:20 <Baughn> misterbeebee_: Well, are you going to submit the /executable/ or the source?
07:57:28 <misterbeebee_> executable, grr
07:57:40 <misterbeebee_> rule change for this year, back to bad old rules
07:57:46 <Baughn> And I'd have to see the task, but I shouldn't /think/ you'd need any tricky library bindings
07:57:51 <Baughn> No real time to write them, for one
07:58:24 <misterbeebee_> probably. I'd feel better if I could test out some sample programs in advance...
07:58:25 <misterbeebee_> Are there any gotchas with respect to "Cross-compiling" between different versions of Linux? If I use RHEL3 on Intel Xeon to build my program, or Ubunto on a 5-year old Dell, (perhaps with precompiled libraries and bindings libraries I don't understand the details of), can I plop the resulting binary on something like  "Linux Kernel KNOPPIX 2.6.19 #7 SMP PREEMPT, and the libc version is libc6/libc6-dev 2.7."
07:59:05 <PeakerWork> dolio: a lot more work, but isn't it the whole point? :)
07:59:16 <Baughn> misterbeebee_: Linux apps built on new systems have a tendency not to work on old ones; forwards compatibility is lacking. Backwards compatibility works fine, though
07:59:25 <Baughn> misterbeebee_: And ghc links statically to all the haskell stuff
07:59:25 <PeakerWork> Also, does that mergesort in Epigram naively take O(N) to do ordering comparisons?
07:59:37 <Syzygy|de> misterbeebee_: If you compile it statically, there should be a minimum of gotchas; if you link to libraries, you need to make sure these are actually available.
08:00:01 <vixey> PeakerWork: link ?
08:00:18 <Syzygy|de> Watch out for changes in things like 32/64 bit (Xeon is 64, isn't it?) and possibly for ABI changes between kernel versions (shouldn't be many, should there?)
08:00:20 <Baughn> misterbeebee_: No, my point was that you can go ahead and write your program without worrying that it might not work on linux. It will, unless you do something very odd or standards-breaking; for haskell's purposes, os x and linux are practically the same thing
08:00:29 <PeakerWork> vixey: www.cs.nott.ac.uk/~txa/publ/ydtm.pdf
08:00:35 <quicksilver> haskell apps tend to be very cross platform
08:00:36 <Baughn> misterbeebee_: So you don't /need/ the live cd vastly in advance
08:00:51 <quicksilver> as long as you stay clear of platform-specific libs
08:00:53 <Baughn> misterbeebee_: I'd offer you a shell account on my computer, but I see they want 32-bit executables..
08:00:55 <quicksilver> (not to state the obvious too much!)
08:01:01 <PeakerWork> quicksilver: isn't that true of pretty much all non-MS languages?
08:01:24 <PeakerWork> (even MS languages, if MS failed to prevent cross-platformness)
08:01:28 <Baughn> PeakerWork: Takes a lot more work with something like C
08:01:30 <quicksilver> PeakerWork: to some limited extent, perhaps.
08:01:38 <vixey> and how come #epigram is empty!?
08:01:51 <PeakerWork> Baughn: why? C with SDL/etc is pretty much cross-platform
08:01:54 <quicksilver> C and C++ are not very cross platofmr in practice, since, in practice, interesting C and C++ programs bind to platform specific libs.
08:02:21 <Baughn> PeakerWork: If I had a cookie for each time I see someone assuming that a pointer fits in an int..
08:02:26 <Baughn> I'd have diabetes, probably
08:02:36 <vixey> yeah comparing two peano integers is O(n)
08:02:51 <misterbeebee_> Baugh, quicksilver: ok, so "ghc -static", which is the default anyway,   and I obtain the source for any non-base haskell libs,  and don't try anything like the gtk bindings that obviously required non-haskell c-libraries, I should have no problems building on one 32-bit linux and running on someone else's....
08:02:55 <vixey> that's why we use hardware accelerated numbers :P
08:03:11 <Baughn> misterbeebee_: Probably. Check to be sure.
08:03:12 <misterbeebee_> (Baughn: thanks for the shell offer.)
08:03:27 <Baughn> PeakerWork: Yes, it isn't very /hard/ to write cross-platform C, but it does take /some/ work, and lots of knowledge
08:03:32 <PeakerWork> vixey: does Epigram use hardware numbers?
08:03:39 <Baughn> Whereas with haskell, you really have to be /trying/ to write non-cross-platform stuff
08:03:43 <PeakerWork> vixey: we could have O(logN) numbers in software too :)
08:03:58 <qwr> quicksilver: is there a way to write portable server in haskell?
08:04:05 <mauke> Baughn: readSymbolicLink "/proc/self/exe"
08:04:16 <Syzygy|de> Baughn: I want my pointers to fit in short! AND I want 320G adressable RAM! And a PONY!
08:04:20 <qwr> quicksilver: last time i wrote one, i had to use posix apis to disable sigpipe
08:04:24 <PeakerWork> Baughn: Its easy to mis-use Int for CInt and such and make "cross platform" stuff pretty platform-specific
08:04:31 <Baughn> mauke: ..I'd like to think that anyone who knows that much about /proc also knows it isn't standard
08:04:31 <vixey> I think that Epigram 2 would ... I think I read about that on edwin bradys side
08:04:33 <vixey> site*
08:04:45 <qwr> quicksilver: (and the documentation suggests doing that...)
08:04:49 <PeakerWork> Baughn: those are ofcourse petty bugs :)
08:04:51 <misterbeebee_> baught: cool, I'll have faith now and check when the contest starts (and borrow a rebootable Intel machine for that purpose...)
08:04:55 <lxuser> PeakerWork, coq has only recently added support for hardware numbers on 31-bits
08:04:56 <PeakerWork> Baughn: but arguably so is trying to fit a pointer in an int
08:04:59 <vixey> it seemed like there's a bunch of optimizations you couldn't do before that you can now though
08:05:04 <Baughn> Syzygy|de: typedef intptr_t short; ;)
08:05:10 <mauke> <insert rand about argv[0] here>
08:05:12 <Syzygy|de> Baughn: Yeah? :)
08:05:18 <Syzygy|de> mauke: 6.
08:05:20 <smtms> Syzygy|de, ok, you get a 64-bit short, 320 GB virtual address space (backed by 320GB swap partition) and a pony
08:05:22 <quicksilver> qwr: yes, that's a good point, and considered a bug.
08:05:27 <mauke> Syzygy|de: what?
08:05:33 <mauke> oh
08:05:34 <Syzygy|de> mauke: You wanted a rand
08:05:36 <quicksilver> qwr: fortunately only the medically insane would expect to run a server on a non-POSIX platform.
08:05:36 <smtms> Syzygy|de, now, can you afford to feed your pony?
08:05:39 <Riastradh> Beware, Baughn.  `intptr_t' is an optional type.  You won't find it on the AS/400.
08:05:41 <quicksilver> qwr: so it's not a problem in practice.
08:05:49 <mauke> Syzygy|de: that's just what I wrote, not what I wanted :-)
08:05:56 <Baughn> Riastradh: Clean compilation failure, then. Vastly superior to crashes.
08:05:57 <Syzygy|de> smtms: No, and it'll make me stop breathing and break out in hives. All is your fault for listening to what I say!!!
08:06:00 <vixey> can you hardware accelerate lists though? or binary trees?
08:06:02 <qwr> quicksilver: yes, it wasn't problem to me either... but still not very portable ;)
08:06:14 <quicksilver> qwr: as I said, considered a bug.
08:06:33 <quicksilver> qwr: scheduled for fix in 6.10 I think.
08:06:42 <quicksilver> qwr: plan is to convert it to an exception, by default.
08:06:42 <qwr> ok, clear :)
08:07:19 * edwinb wakes up
08:07:38 <edwinb> ah, epigram and numbers in hardware
08:07:40 <Syzygy|de> mauke: I'm terribly sorry, btw. I used a flaw random numbers algorithm. Here's the real answer: 4
08:07:45 <vixey> :D
08:07:49 <edwinb> It is a Simple Matter Of Programming ;)
08:07:55 <mauke> srant();
08:08:13 <Syzygy|de> mauke: rants.seed(rms); rant();
08:08:28 <Baughn> Syzygy|de: root mean square? -_-
08:08:44 <mauke> RMS "Matthew" Stallman
08:08:47 * PeakerWork wants to see a real proof of a program in Epigram.  A sort that's proven to actually return the same items, and that those items are actually sorted
08:08:52 <Syzygy|de> Baughn: See mauke
08:09:00 <kiris> Mathew `RMS` Stallman
08:09:10 <edwinb> I wouldn't fancy doing that sort of proof in Epigram
08:09:24 <edwinb> it's quite tricky to get all the details
08:09:36 <PeakerWork> edwinb: hmm. what language allows me to prove that?
08:09:43 <edwinb> epigram certainly does
08:09:47 <edwinb> but you might need a server farm
08:09:56 <lxuser> PeakerWork, there's an easy to understand proof of insertion sort in Agda/Alfa
08:10:00 <PeakerWork> edwinb: really? It doesn't sound too terrible
08:10:03 <vixey> @go algebra of programming with dependent types
08:10:05 <lambdabot> http://lambda-the-ultimate.org/node/2771
08:10:05 <lambdabot> Title: Algebra of programming using dependent types | Lambda the Ultimate
08:10:13 <edwinb> I suspect Agda would cope quite happily
08:10:37 <PeakerWork> When I took a look at Alfa it seemed to be unmaintained, last updates from 2002 or so?
08:10:54 <lxuser> PeakerWork, http://www.cs.chalmers.se/~hallgren/Papers/insertion_sort.ps
08:10:59 <edwinb> http://appserv.cs.chalmers.se/users/ulfn/wiki/agda.php
08:11:00 <lambdabot> Title: 14 The Agda Wiki - Main 4b
08:11:15 <edwinb> that's actively developed
08:11:53 <smtms> when development stops, it may be that the software is complete...
08:12:13 <vixey> I bet you could prove the monad laws pretty easy in Epigram 2
08:12:16 <vixey> for Cont and such
08:12:55 <PeakerWork> lxuser: thanks
08:13:09 <PeakerWork> smtms: hah
08:13:14 <PeakerWork> smtms: any example of that? :)
08:14:16 <PeakerWork> I like reverse engineering the concepts from actual code examples.. That postscript file seems to only have text :)
08:15:40 <lxuser> PeakerWork, it shows the natural language features of Alfa.
08:15:41 <vixey> don't miss the AoP one Peaker
08:16:33 * Philippa really ought to play with Agda sometime
08:16:40 <lxuser> of course in a real production system you would mostly rely on code
08:16:52 <Philippa> edwinb: any chance of you showing at AngloHaskell this year?
08:17:00 <edwinb> Philippa: depends where and when it is
08:17:02 <PeakerWork> vixey: AoP?
08:17:05 <edwinb> I would like to go
08:17:08 <Philippa> edwinb: that's been finalised now
08:17:10 <lxuser> but the natural language translations substitute for comments somewhat
08:17:12 <edwinb> aha!
08:17:22 <PeakerWork> lxuser: Why would you want to use natural language when programming or proving?
08:17:33 <edwinb> oh, August 8th, I'll be away...
08:17:54 <Philippa> meh. Presumably the 9th as well? It sounds like the pace'll be different for that this year
08:17:59 <edwinb> hmm, actually, no I can do the 8th
08:18:00 <vixey> I linked it above
08:18:02 <Philippa> no punts
08:18:16 * edwinb pencils that in to his diary
08:18:35 <Philippa> cool. I'm going to do a somewhat more conventional talk this year, I think
08:18:36 <PeakerWork> vixey: oh, I see.  Missed the abbreviation
08:18:57 <edwinb> I might consider doing some kind of rant
08:19:03 <Philippa> heh, go for it
08:19:10 <Philippa> (likely subject(s)?)
08:19:25 <edwinb> no idea ;)
08:19:52 <Philippa> I'm half wondering whether to offer to do two like Neil effectively did last year - I've got some simple type system stuff I'd like some feedback on
08:20:07 <lxuser> PeakerWork, mostly, you can annotate functions, variables and the like with a "natural" name - what you'd normally put in a comment
08:20:20 <lxuser> it's a minimal form of literate programming
08:21:02 <PeakerWork> lxuser: I think "literate programming" is fancy-shmancy name-calling for something everybody does anyway :)
08:21:53 <PeakerWork> All decent programmers write code primarily for human readers..  The fact names have funny constraints on them is an artifact of textual encoding of programs, but not a huge one
08:22:17 <Philippa> PeakerWork: it's not. Proper literate programming has more text than code any time the code's got nontrivial stuff going on
08:22:44 <Philippa> it helps pin the code to the problem domain, and where necessary explains the problem domain to the user (something that comments rarely do)
08:22:52 <PeakerWork> Philippa: Code is pretty much text.. you encode the intention into the names..
08:23:12 <PeakerWork> (I am not sure natural language is a better language to explain these things)
08:23:13 <Philippa> PeakerWork: nobody uses identifiers that're a paragraph long
08:23:17 <Philippa> sometimes the intention is complicated
08:23:20 <quicksilver> PeakerWork: no, most well written programs are still FAR short of literate code.
08:23:35 <quicksilver> and frankly, most programs are not well written
08:23:38 <Philippa> sometimes bits of the intention are better stated via a mathematical snippet with explanatory text around it, too
08:23:42 <quicksilver> so most programs are even further short :)
08:23:44 <PeakerWork> Philippa: the paragraph simply uses the language's syntax instead of using natural language
08:23:52 <Philippa> PeakerWork: bullshit
08:24:01 <Philippa> the programming language only talks programming
08:24:19 <Philippa> you can't, for example, explain in a programming language that something's been done as part of a legal requirement
08:24:28 <Philippa> there's no notion of "legal requirement" to start with
08:25:43 <lxuser> Philippa: The answer is: Yes! Agda can do that!
08:25:45 <vixey> oh
08:25:51 <vixey> look at the Epigram compiler pearl
08:25:53 <idnar> hahaha
08:25:56 <vixey> that is one really neat proo
08:25:58 <vixey> proof*
08:26:21 <Philippa> lxuser: no, it can't. It can be used to prove that you've met it once you've encoded what said requirement actually is
08:26:30 <idnar> @faq foo
08:26:30 <lambdabot> The answer is: Yes! Haskell can do that.
08:26:33 <Philippa> which is a little difficult when the legal requirement is fuzzy, as many are
08:26:44 <Philippa> consider the legal meaning of "reasonable", for example
08:27:01 * Philippa doesn't fancy modelling the brain of the man on the clapham omnibus...
08:29:04 <vixey> all I know is it's -very- hard to prove things formally and it's also very hard to reason about programs
08:29:30 <byorgey> data Resonableness = IsReasonable | IsNotReasonable | WtfIGiveUp
08:29:50 <quicksilver> interpret_contract c = WtfIGiveUp
08:29:58 <quicksilver> ^^ full legalese interpreter in two lines!
08:36:33 <PeakerWork> Philippa: You can encode legal requirements via names (ignoring comments, even).  isLegal x = lawyerApproved x and ...
08:37:15 <Philippa> PeakerWork: which is fuck all use in explaining that that's why you did something in a particular place
08:38:19 <Philippa> and doubly so where it's actually a semi-complex argument about a number of fuzzy things
08:38:29 <Philippa> not everything is a simple predicate
08:38:57 <PeakerWork> Philippa: Ofcourse anything that cannot be expressed that way can and does go in a comment. Also, I'd say that having a fully fledged legal explanation next to reusable code that has legitimate existence in complete disconnect from the legal things is not necessarily a good idea
08:39:38 <Philippa> PeakerWork: in business code, OTOH...
08:40:02 <edwinb> part of the problem is that the predicate you have has to be an accurate representation of what you want to prove...
08:40:33 <edwinb> if that's hard to get and hard to udnerstand, your proof might not be useful to anyone...
08:40:40 <Philippa> right. It's not necessarily a good idea to try to re-encode the law
08:40:41 <quicksilver> PeakerWork: with respect you sound like someone who has never looked at proper literate code.
08:40:54 <quicksilver> PeakerWork: go at look at the literate code to TeX, for example
08:40:55 <Philippa> amongst other things, you then need a lawyer to help check your encoding was valid!
08:41:13 <quicksilver> and then come back and tell us that that could all have been sensibly encoded in variable names.
08:41:17 <Philippa> or any one of a number of papers written as literate code, or a certain percentage of Oleg's mailing list posts
08:41:23 <PeakerWork> quicksilver: I looked at some "literate programming" projects, and they were horrible.. you had to run documentation generators on the code to be able to read it, and you had to modify it in the horrible code-in-doc format
08:41:33 * vixey is reminded of http://jaguar.it.miami.edu/~chris/formal_methods_in_the_movies/TheWizardOfOz.html
08:41:35 <lambdabot> http://tinyurl.com/6grt9b
08:41:36 <Philippa> PeakerWork: boo hoo, you no like it
08:41:37 <quicksilver> horrible because you didn't know the tools.
08:41:49 <quicksilver> much like driving a car is horrible if you've never been taught to drive a car
08:41:59 <quicksilver> and someone drops you into one going at 100 miles an hour down the wrong side of a motorway
08:42:33 * Philippa can take a fair shot at reading chunks of raw LaTeX too, as can a fair number of people who've used it
08:42:35 <PeakerWork> quicksilver: Well, all the advantages literate code is supposed to have -- I already feel I have with code written to the right standards
08:42:51 <Syzygy|de> I can read non-horrible raw LaTeX rather comfortably.
08:43:06 <Philippa> PeakerWork: others disagree, and feel that your "code written to the right standards" doesn't go far enough
08:43:33 <quicksilver> PeakerWork: I'm serious, take a look at the correctly processed and formatted code for a Knuth project
08:43:39 <quicksilver> if Tex is too big (and it is)
08:43:40 <Philippa> and talking about using a limited creole of english and the programming language in question to communicate non-code stuff? *ouch*
08:43:47 <quicksilver> then try something smaller like one of the DVI tools.
08:44:02 <sclv_> Literate code is more a continuum than a boolean, no?
08:44:12 <quicksilver> it is on a different plane than well-commented source code.
08:44:12 <Philippa> sclv_: exactly
08:44:28 <PeakerWork> quicksilver: I think it was iwconfig or iwconfig-tools or something along those lines which I wanted to patch to fix some issue, but it was much harder..
08:44:33 <lxuser> PeakerWork, yes, code-in-doc is horrible, but it's not really what the Alfa plugin does
08:44:54 <sclv_> I mean I can write "literate" code with standard comments, its just that literate tools make it easier and more natural to do the same thing.
08:45:14 <Philippa> not to mention that they're often much better for cases where ASCII won't suffice
08:47:07 <PeakerWork> So, do you have any example of a good, small, literate programming example, and the set of tools to use to edit and view it?  The one I looked at seemed harder to read and harder to maintain
08:47:09 <Philippa> ironically, the comment-heavy style seems to work much better for asm than higher-level languages
08:47:31 <quicksilver> sclv_: Knuth felt the ability to re-order was important. But then again, he was working in a language which mandated order much more than haskell does.
08:47:40 <Si> Am I right in thinking that eventually Type Families in class instance heads will be rejected because they are undecidable if the family is open?
08:47:50 <quicksilver> sclv_: also, he added macro abstraction at the web level, which was a hack around pascal's lack of abstraction.
08:48:23 <Philippa> PeakerWork: edit with an ordinary text editor with smarter highlighting etc. For .lhs, you'd normally use lhs2tex and then a typical TeX/LaTeX toolchain
08:48:46 <Philippa> I'll let others think of programs and papers to use as examples, my brain doesn't do that kind of association so readily
08:48:54 <Philippa> but I can confirm that I've seen good examples
08:48:59 <kiris> ah, got gd working: http://chrisdone.com/wordfreq.cgi?words=hello+hello+la+la+la+la+beans+beans+bacon+bacon+bacon+bacon+bacon+cheese
08:49:01 <lambdabot> http://tinyurl.com/6e2fp4
08:49:21 <PeakerWork> Philippa: I really hate that "viewing" and "editing" are thus separated, though. When I am viewing I often find something I want to fix.. And when editing directly in that form, I'd rather be editing ordinary code
08:50:03 <Philippa> PeakerWork: it'd be nice to have better integration, certainly. But those of us working in areas where LaTeX's pretty much required are rather used to it by now
08:50:11 <Philippa> it's no worse than editing vs running
08:50:19 <PeakerWork> Philippa: that too should be fixed :-)
08:50:23 <PeakerWork> (and in an FP its pretty possible, too)
08:50:27 <Philippa> *nod*
08:50:44 <Philippa> hell, it's been done in lisps, smalltalk etc etc
08:50:52 <vixey> all untyped ..
08:51:07 <Philippa> in the meantime, an editor plugin to view PDF, postscript or DVI is a good start
08:51:13 <Zao> I ran some emacs hack once that rendered math-mode text right in the buffer, which I suppose could help a bit.
08:51:23 <Zao> But it was emacs, so I couldn't use it.
08:51:36 <quicksilver> preview-latex is pretty cool.
08:51:38 <Philippa> vixey: it's more or less known how to do it in a Haskell-like language now though. Reflection monad reachable from IO, lots of use of Dynamic where needed
08:51:52 <quicksilver> I used to use LyX for certain kinds of document
08:52:19 <lxuser> Zao, TeXmacs and LyX can definitely do that
08:52:40 <Philippa> PeakerWork: something worth remembering (which may well feel a bit alien) though is that coding isn't the most frequent "development" activity with a literate codebase
08:53:02 <Philippa> you'll actually spend more time on text than code, and that's intended
08:53:23 <Philippa> (OTOH, it often makes the coding easier - I produce stuff more readily when it's supposed to go in the middle of an article or blog post, for example)
08:53:49 <gwern> personally, I've always been more keen on haddock-style haskell code than literate style. but that's just because I feel everyting should be in libraries and any executable where literate style makes sense should be so short and obvious that literatacy is basically useless :)
08:54:08 <quicksilver> lxuser: TeXmacs, despite the name, isn't TeX or LaTeX
08:54:21 <Philippa> gwern: False dichotomy! Haddock's lousy for "internal" documentation
08:54:28 <Philippa> it's intended for interface-type stuff
08:55:08 <gwern> Philippa: we live in a world of false dichotomies! C or Haskell! Darcs or Git! GHC or Hugs! Cabal or Autotools!
08:55:10 <byorgey> hm, is it possible to use both Haddock and a literate style?  I forget
08:55:21 <gwern> byorgey: it is, but it can be difficult
08:55:26 <quicksilver> gwern: right, haddock is lousy for documenting your revolutionary new variation of Runge-Kutta
08:55:26 <lxuser> Philippa, but code is the payload.  i'd rather use haddock or doxygen or the agda thing to generate documentation automatically
08:55:41 <lxuser> and spend more time working on code
08:55:42 <quicksilver> gwern: which your library implements
08:55:42 * gwern ran into a problem with darcs's literate latex stuff which killed haddock generation
08:55:56 <quicksilver> lxuser: yes, but that's the same point. That's interface documentaiton, not code documentation.
08:56:07 <quicksilver> many people believe that all they need to document is the interface.
08:56:08 <quicksilver> fair enough.
08:56:17 <quicksilver> but sometimes it's actually good to document the code, not the interface.
08:56:20 <gwern> quicksilver: wait, what does my library implement?
08:56:49 <quicksilver> gwern: a revolutionary new algorithm which takes novel shortcuts and is profoundly non-obvious. You have a paper in a prestigious journal on it.
08:57:07 <gwern> quicksilver: oh. that's nice. did I win anything for it? tenure maybe?
08:57:37 <quicksilver> unfortunately your partner left you because you spent too long working on it, and you sunk into a bout of depression which means you lost your job.
08:58:51 <gwern> ack! well, as long as I haven't taken up substance abuse, I'm sure the joy of hacking will let me rebound at some point
08:59:33 <Philippa> lxuser: sometimes you've reached code by fairly non-obvious means (if only because it's been through so many transformations)...
09:03:23 * sclv_ prefers to think of literate style as "a debuggable paper"
09:14:33 <BONUS> how do you make a let across a list comprehension
09:14:36 <BONUS> like if you have
09:14:52 <BONUS> [a*b | a<-[1..10], b<-[1..10], a*b > 10]
09:15:01 <vixey> > [ x | x <- [1..10] , y = x , y == 3 ]
09:15:01 <lambdabot>  Parse error at "=" (column 24)
09:15:01 <BONUS> what do you do if you want to have, say, let c = a*b
09:15:06 <vixey> > [ x | x <- [1..10] , let y = x , y == 3 ]
09:15:10 <lambdabot>  [3]
09:15:33 <byorgey> > [ c | a <- [1..10], b <- [1..10], let c = a*b, c > 10 ]
09:15:33 <vixey> > [a*b | a<-[1..10], b<-[1..10] , let c = a*b, c > 10]
09:15:34 <lambdabot>  [12,14,16,18,20,12,15,18,21,24,27,30,12,16,20,24,28,32,36,40,15,20,25,30,35,...
09:15:34 <lambdabot>  [12,14,16,18,20,12,15,18,21,24,27,30,12,16,20,24,28,32,36,40,15,20,25,30,35,...
09:15:39 <BONUS> aha
09:15:48 <BONUS> you can use a let just like that
09:15:49 <BONUS> awesome
09:15:51 <BONUS> makes sense too
09:15:58 <BONUS> cause you can use it like that in do notation too
09:16:01 <byorgey> the 'let' scopes over whatever is before the | as well as everything after the let
09:16:14 <BONUS> aha
09:16:14 <tapas> lambdabot: 1
09:16:15 <BONUS> nice
09:16:40 <tapas> [1]
09:16:50 <tapas> oh well..
09:16:51 <tapas> ;)
09:17:04 <misterbeebee__> Anyone use Interlude (package to add better error-reporting to Prelude functions that can fail)? I had some trouble with it (inconsistent types between function definitions and their uses in the interlude.h), so I played around with and I think I fixed it. I guess I should email the maintainer.
09:17:07 <misterbeebee__> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/interlude
09:17:09 <vixey> > filter (>10) $ liftM2 (*) [1..10] [1..10]
09:17:09 <lambdabot>  [12,14,16,18,20,12,15,18,21,24,27,30,12,16,20,24,28,32,36,40,15,20,25,30,35,...
09:17:11 <kiris> @hoogle Int -> Double
09:17:11 <lambdabot> No matches, try a more general search
09:17:11 <lambdabot> Title: HackageDB: interlude-0.1.1, http://tinyurl.com/5qs4le
09:17:18 <laz0r> jo, tapas
09:17:20 <vixey> :t fromIntegral :: Int -> Double
09:17:21 <lambdabot> Int -> Double
09:17:44 <misterbeebee__> oh, gwern, you are here
09:17:55 <misterbeebee__> are you the same gwern as in the Interlude package?
09:18:02 <kiris> thanks, vixey
09:18:22 <gwern> misterbeebee__: I don't know of any others
09:18:55 <laz0r> mmh, can somebody enlighten me how i am supposed to use the reactInit and react functions in yampa to connect haskell and yampa?
09:19:43 <misterbeebee__> want to me to send you the changes I needed to make to get it to work?
09:19:47 <misterbeebee__> (gwern)
09:19:51 <gwern> http://hackage.haskell.org/trac/ghc/ticket/2427 <-- if anyone was curious about me and ghc stdin
09:19:53 <lambdabot> Title: #2427 (Allow compilation of source from stdin) - GHC - Trac
09:19:56 <gwern> misterbeebee__: it's broken?
09:20:01 <misterbeebee__> it was for me
09:20:19 <misterbeebee__> maybe new to 6.8.3, dunno,
09:20:37 <misterbeebee__> but I had problems (1) getting the files in te right place in the Mac OS X package,
09:20:53 <misterbeebee__> and (2) the type of report_bug  ( -> ()  vs -> a)
09:20:55 <gwern> misterbeebee__: well, keep in mind I don't maintain the darcs repo at http://malde.org/~ketil/interlude
09:20:59 <lambdabot> Title: Index of /~ketil/interlude
09:21:13 <gwern> ketil malde does; he comes here sometimes, but I can't remember the nick
09:21:47 <misterbeebee__> and (3) the #define uses a tuple (_C_, _M_, __FILE__, __LINE__), but the call site uses a curryable function
09:21:59 <misterbeebee__> Well, I'll email Ketil, the email is on the hackage page
09:22:04 <misterbeebee__> I just saw that you were the last Uploaded
09:22:07 <misterbeebee__> Uploader
09:22:20 <gwern> yes, I uploaded it for him
09:22:23 <zachk1> is Haskell `properly tail-recursive` ?
09:22:35 <gwern> if he isn't responding then I'd be happy to help you out
09:22:49 <gwern> zachk: short answer: no; long answer: complex topic given laziness
09:23:08 <misterbeebee__> ok thanks. It works for me now, but I'm happy to share with the rest of the world.
09:23:08 <LordBrain> Where can i find a good explanation of quickcheck's coarbitrary?
09:23:14 <zachk> gwern: how do I stop from blowing up my stack?
09:23:23 <gwern> longer answer: there is a long page on the haskell wiki dsicussing this topic
09:23:25 <byorgey> @wiki Stack_overflow
09:23:25 <lambdabot> http://www.haskell.org/haskellwiki/Stack_overflow
09:23:31 <byorgey> zachk: see that page =)
09:24:23 <gwern> LordBrain: cale had a good one on reddit somewhere
09:24:32 <gwern> LordBrain: but you know QC 2 removes coarbitrary, iirc
09:24:44 <Saizan> zachk: ghc does tail call optimization, but lazy accumulators built of strict functions can blow your stack even if the recursion is properly transformed in a loop
09:24:57 <LordBrain> oh
09:24:57 <LordBrain> i didn't know that
09:24:57 <gwern> misterbeebee__: you've darcs sent your patches?
09:25:50 <misterbeebee__> no, not yet. I've never used darc for anything but get before. Is it safe to darcs send before anyone code reviews?
09:25:52 <byorgey> gwern, LordBrain: IIRC QC2 just moves coarbitrary to a separate type class.
09:26:13 <LordBrain> ok
09:26:33 <gwern> byorgey: oh, I just noticed it needed co removed to compile
09:26:55 <gwern> misterbeebee__: yeah. all it does is send the specified address a nice email, it doesn't actually change the live server
09:27:15 <misterbeebee__> ok, i'll read how to do that and send it in.... probably next weekend. thanks!
09:27:24 <LordBrain> my understanding is i need coarbitrary to generate some random functions
09:27:30 <gwern> misterbeebee__: if you don't have an email-sender-program setup like sendmail or ssmtp, just use the -o option and manually attach it to an email to ketil
09:27:39 <zachk> well that was easy.... i was already in parameter accumulator form just put in a $! in front of the accumulator and BAM no stack overflow
09:28:04 <kiris> LordBrain: your nick cracked me up :)
09:28:09 <gwern> (performance problems are often exaggerated for haskell)
09:29:37 <LordBrain> that's good kiris. they say laughter is good medicine
09:30:12 <byorgey> zachk: excellent =)
09:30:14 <cinimod> I've been repackaging my haskell ping program but I can't get cabal to build it
09:30:41 <gwern> cinimod: hpaste errors and cabal file plskthnx
09:30:51 <cinimod> I posted to libraries but no-one has replied so far http://www.haskell.org/pipermail/libraries/2008-July/010112.html
09:30:52 <lambdabot> Title: Cabal and c2hs
09:30:57 <LordBrain> i dislike cabal because it has no standard uninstall
09:31:00 <hpaste>  Tobsan pasted "euler 17 (broken)" at http://hpaste.org/8765
09:31:21 <LordBrain> that offends the god or something
09:31:29 <Tobsan> i can't see why it does not work :/
09:33:40 <gwern> LordBrain: uninstall is on the list of things to do
09:33:50 <hpaste>  cinimod pasted "Cabal and c2hs" at http://hpaste.org/8766
09:35:04 <gwern> cinimod: offhand, "c-sources: ip_icmp.h"
09:35:06 <gwern> ?
09:35:37 <cinimod> Ok I'll give it a try
09:35:56 <atomb> has anyone here successfully built GHC 6.8.anything on Solaris 8?
09:36:48 <Axman6> hmm, just managed to crash ghci
09:37:09 <Axman6> it was running "length (show (fib 1000000000))" however... :o
09:37:11 * gwern files 3rd bug report of the day. amazing how every night I spend offline I turn up all these infelicities
09:37:23 <gwern> > length (show (fib 1000000000))
09:37:24 <lambdabot>   Not in scope: `fib'
09:37:31 <vixey> I thought it was lisp o_o
09:37:43 <vixey> > length . show . product $ [1..100]
09:37:44 <lambdabot>  158
09:38:16 <EvilTerran> > length . show . product $ [1::Integer ..1000]
09:38:17 <lambdabot>  2568
09:38:31 <vixey> :(((((((
09:38:49 <Axman6> > length . show . product $ [1::Integer ..1000000]
09:38:55 <lambdabot>  Exception: Time limit exceeded
09:38:59 <Axman6> lame
09:39:19 <vixey> defaulting to Int is a lot more lame
09:39:28 <cinimod> gwern: didn't help - cabal seems to be moving ICMP.chs to dist/build/ping/ping-tmp/IP_ICMP.chs.h
09:39:29 <enoksrd> > length . show $ ((1+sqrt(5))/2)^1000000000
09:39:30 <lambdabot>  8
09:39:48 <cinimod> and then of course ip_icmp.h isn't in that directory
09:39:51 <vixey> > ((1+sqrt(5))/2)^1000000000
09:39:52 <lambdabot>  Infinity
09:40:06 <vixey> what is this Perl ??
09:40:18 <enoksrd> haha
09:40:31 <vixey> the defaults should be Integer and CReal
09:40:49 <vixey> who would want wrong answers? :S
09:41:25 <gwern> vixey: c programmers. Fast and wrong, is their motto
09:41:35 <Syzygy|de> I just stumbled across http://augustss.blogspot.com/2008/07/lost-and-found-if-i-write-108-in.html and wanted to play along. However, my 6.8.1 installation doesn't find Debug.Traced.
09:41:38 <lambdabot> Title: Things that amuse me, http://tinyurl.com/57eqc2
09:41:39 <vixey> :)
09:41:43 <Syzygy|de> What do I need to do to get hold of the things he's doing?
09:41:44 <gwern> cinimod: where is it?
09:42:21 <cinimod> gwern: I'll push a patch and then put a link here in a few minutes
09:43:27 <gwern> `I'm going to take a break from the computer for a while, then. I'll look at the link and see whether I can fix it when I come back
09:43:54 <mnislaih> Syzygy|de: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/traced-2008.7.4
09:43:58 <lambdabot> Title: HackageDB: traced-2008.7.4, http://tinyurl.com/6g47r6
09:44:46 <Syzygy|de> mnislaih: Thanks
09:46:56 <cinimod> gwern: darcs get http://haskell.org/networktools/src/ping
09:47:05 <lambdabot> Title: Index of /networktools/src/ping
09:49:32 <sanar> afternoon
09:49:42 <fragmad> Afternoon.
09:51:47 <fragmad> Huzzar! I've found a way to get the sound working again without reboot.
09:58:21 <Apocalisp> Is function application the catamorphism for the Reader monad?
10:00:03 <byorgey> Apocalisp: only fixpoints of functors have catamorphisms.
10:03:03 <Apocalisp> byorgey: I'm not sure what that means. "Fixpoints of functors" are algebras, right?
10:06:02 <EvilTerran> as in, [a] is the fixedpoint of (Maybe `O` (,) a)
10:06:22 <byorgey> Apocalisp: no, an algebra (in Haskell) is a function  (Functor f) => f a -> a
10:06:30 <byorgey> well, for some particular a
10:06:46 <EvilTerran> data Tree a = Leaf a | Branch (Tree a) (Tree a) is the fixedpoint of data Tree t a = Leaf a | Branch (t a) (t a)
10:07:38 <opqdonut> byorgey: some examples of algebras?
10:08:28 <byorgey> er, sorry, an algebra is a function f a -> a where f is a particular functor and a is some particular type
10:08:34 <byorgey> i.e. there's no 'forall'
10:09:08 <byorgey> for example, hm, let's see
10:09:14 <lilachaze> head
10:09:18 <opqdonut> ah, yeah, no foralls
10:09:30 <opqdonut> lilachaze: except head is not total
10:09:35 <lilachaze> opqdonut: :(
10:10:07 <byorgey> take the functor  data N a = Zero | Succ a
10:10:16 <lilachaze> join . maybeHead :: [Maybe a] -> Maybe a ?
10:10:17 <byorgey> the fixpoint of that is the type of natural numbers
10:10:32 <Saizan> an F-algebra is a pair of (A,F A -> A) for some A, and (Fix f, InF) is the initial F-algebra
10:10:38 <byorgey> an algebra would be, for example,  alg (Zero) = 0; alg (Succ n) = n + 1
10:10:52 <cinimod> gwern: I looked again at the docs - it's simpler than I thought but I still get an error
10:11:04 <opqdonut> how does this relate to the concept of an algebra in abstract algebra?
10:13:30 <Saizan> opqdonut: i think it's like the functor describes the operations and the (F A -> A) function interprets them in the structure A
10:13:38 <lilachaze> What's InF?
10:14:22 <EvilTerran> ?src Mu
10:14:23 <lambdabot> Source not found. I am sorry.
10:14:23 <Saizan> i was assuming this definition newtype Fix f = InF { outF :: f (Fix f) }
10:14:31 <hpaste>  cinimod annotated "Cabal and c2hs" with "(no title)" at http://hpaste.org/8766#a1
10:14:34 <EvilTerran> ?src Fux
10:14:35 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
10:14:37 <EvilTerran> ?src Fix
10:14:37 <lambdabot> Source not found. You untyped fool!
10:14:55 <EvilTerran> -.-;;
10:14:56 <kiris> -- More polite insults
10:15:57 <EvilTerran> ?type In
10:15:58 <lambdabot> forall (f :: * -> *). f (Mu f) -> Mu f
10:16:00 <EvilTerran> ?type out
10:16:01 <lambdabot> forall (f :: * -> *). Mu f -> f (Mu f)
10:16:18 <EvilTerran> newtype Mu f = In { out :: f (Mu f) }
10:21:01 <chr1s>  /win 5
10:22:29 <Baughn> chr1s: This /is/ window 5
10:22:53 <idnar> Baughn: no, it's window 35
10:22:55 <smtms> Baughn, don't lie! this is window number 7
10:23:24 <Baughn> 5,7,5*7.. it's all the same to me
10:23:36 <idnar> oh nicrre
10:23:38 <idnar> *nice
10:23:38 <kiris> haha
10:27:59 <ziman> haha, i've #haskell in window #5, too :)
10:29:35 <kiris> @let histogram = foldr (flip (insertWith (const (+1))) 1) empty
10:29:35 <Zao> I've got it at 3. Does that say anything about my priorities?
10:29:35 <lambdabot> <local>:1:25: Not in scope: `insertWith'
10:29:42 <kiris> >:|
10:29:48 <kiris> anyway
10:29:49 <Zao> (out of 50-some)
10:30:04 <kiris> I've got this function above, it takes a list of Strings
10:30:15 <Deewiant> I've got it at 15 because that's where it started and now it's burned into my fingers
10:30:15 <kiris> would it improve in speed at all if I used ByteStrings?
10:30:32 <Baughn> kiris: Maybe
10:31:09 <Baughn> Probably not, though. That's not what they're for
10:31:19 <kiris> it takes around 7 seconds to do 56,000 words
10:31:26 <kiris> I didn't think so
10:32:01 <quicksilver> kiris: what does the function do? how long are the words?
10:32:14 <quicksilver> if they're ordinary english word length then it's unlikely bytestrings will be faster.
10:32:24 <quicksilver> they will be a bit more compact in memory though
10:32:31 <kiris> quicksilver: it's supposed to take a list and produce a map where the key is the word and the value is the number of occurances in the list
10:32:38 <kiris> ah, ok
10:32:43 <kiris> yes, ordinary length words
10:32:56 <quicksilver> also, bytestring isn't for strings
10:32:58 <quicksilver> its for bytes :)
10:33:11 <kiris> er, "occurence"*
10:33:20 <kiris> that is logical
10:33:29 <quicksilver> i.e. it woudl be using 8 bit
10:33:36 <quicksilver> where as Char is a proper unicode citizen
10:33:37 <kiris> ah
10:33:40 <kiris> right
10:33:49 <quicksilver> there are unicode layers over bytestring
10:33:56 <quicksilver> but now we're making things more complicated :)
10:33:59 <Baughn> I can't help but think there's some duplication of effort between bytestring and array, too
10:34:17 <quicksilver> there is.
10:34:33 <ndmitchell> Baughn: there isn't, there has been very little efforts on arrays, which is why they suck
10:34:53 <ndmitchell> bytestring should be based on array, but it isn't
10:35:45 <ziman> wouldn't that be less efficient than `chunky' bytestrings?
10:35:48 <quicksilver> I think there have been plenty of efforts on arrays
10:35:51 <kiris> first I read the words from a string, then I go over the list's elements to build the map, each of which is a O(log n) insertion, and each string element has to be compared too
10:35:52 <quicksilver> just not on Data.Array
10:35:53 <quicksilver> ;)
10:36:06 <quicksilver> there has been effort on the DPH arrays
10:36:08 <ndmitchell> ziman: you could still have chunks each of which is an array
10:36:08 <maltem> you mean, type Strict.Bytestring = Array Word8 ?
10:36:10 <quicksilver> and the uvector arrays
10:36:12 <kiris> I wonder if there is a faster algorithm without becoming OTT
10:36:17 <ndmitchell> yes :)
10:36:22 <ndmitchell> (at maltem)
10:36:26 <maltem> right
10:36:57 <quicksilver> well there is at least one argument against using Array for ByteString
10:37:07 <ndmitchell> quicksilver: which is?
10:37:12 <quicksilver> it is a stated goal of ByteString that it work over FFI with C
10:37:21 <quicksilver> so the data should be stored in a way compatible with a C void *
10:37:26 <ndmitchell> why shouldn't unpacked arrays word over FFI with C?
10:37:27 <quicksilver> that's not a stated goal of the general Array type.
10:37:32 <quicksilver> they might indeed.
10:37:36 <quicksilver> but it's not a stated goal of them :)
10:37:40 <quicksilver> whereas, it is for bytestring.
10:37:45 <ndmitchell> yeah, seems like you could put the best bits together and have a party
10:37:49 <quicksilver> definitely.
10:37:49 <maltem> isn't there an extra StorableArray?
10:38:09 <ndmitchell> maltem: and diffarrays, a million types of boxed array variants - it got a bit wacky
10:38:16 <quicksilver> yes indeed
10:38:25 <quicksilver> IArray and MArray are classes, not types
10:38:26 <kiris> Baughn: do you think I could split the work up somehow with threads? :))
10:38:32 <quicksilver> you can have as many instances as you want :)
10:38:47 <quicksilver> kiris: not in a very useful way, you'd need a Data.Map which supported useful concurrency.
10:38:58 <kiris> hmm
10:39:00 <quicksilver> kiris: otherwise your threads would spend all their time waiting for 'their turn' on the map.
10:39:05 <kiris> indeed
10:39:29 <Baughn> kiris: No problem
10:39:31 <kiris> if I used STM, it would do all that at the end?
10:39:37 <Baughn> kiris: You'd just have to have two maps, then merge them later
10:39:40 <Baughn> Well, or more
10:40:01 <kiris> well I thought that but how big of an operation is merging them?
10:40:09 <Baughn> O(n)
10:40:17 <Baughn> Obviously that wouldn't be a 100% speedup, but if there are a lot of duplicate keys it'd still be worth it
10:40:39 <Baughn> You'd have to adjust it to circumstances, though.. is there a call to tell how many threads the RTS has to play with?
10:40:41 <kiris> ahh, good point
10:41:19 <kiris> I'll see if Data.Map actually supports a merge
10:41:29 <Baughn> :t Data.Map.union
10:41:29 <lambdabot> forall k a. (Ord k) => Data.Map.Map k a -> Data.Map.Map k a -> Data.Map.Map k a
10:41:46 <Baughn> Although, that's not quite it
10:42:34 <Baughn> unionWith
10:42:47 <Baughn> unionsWith, more likely
10:43:18 <kiris> ahh, yes! :)
10:43:46 <kiris> thanks, I'll try this now
10:44:40 <Baughn> Also, filter ("-N" `isPrefixOf`) <$> GHC.Environment.getFullArgs to get the number of CPUs
10:46:43 <kiris> ah. if I only have one CPU, will it just have no real gain?
10:46:59 <Baughn> Well, no point in parallelism with no hardware to be parallel /on/
10:47:14 <Baughn> Using multiple maps then would just be a waste. Really, you want one map per cpu
10:47:26 <kiris> right
10:47:32 <Baughn> Or core, I guess. Whatever gets passed to -N, really.
10:47:35 <Trinithis> is there a way to force a recompile even if the appropriate exe is already existing?
10:47:44 <Baughn> Trinithis: -fforce-recomp
10:47:51 <Trinithis> ty
10:48:03 <ndmitchell> Trinithis: i just do "touch file.exe"
10:48:13 <Trinithis> ?
10:48:17 <Baughn> touch file.hs, you mean
10:48:26 <ndmitchell> Baughn: yep
10:48:32 <kiris> I have one of those P4 thingies with "hyperthreading" or whatever it is. I don't think linux supports it, it's a bit lame and esoteric I think
10:48:33 <Baughn> Perhaps, but if you're testing compiler options it's easier to just say -fforce-recomp
10:48:48 <Baughn> kiris: Linux supports it, if you turn it on in kernel config
10:49:04 <Baughn> kiris: But it won't help here. It only helps if you have two threads that do different sorts of things, on the machine level
10:49:06 <kiris> well I be damned
10:49:06 <Trinithis> i just made a bat file to compile haskell gui programs because they dont work with ghci
10:49:47 <ziman> you can just remove the .exe
10:49:48 <Baughn> kiris: P4 HT is a bit half-assed, really. It doesn't have enough control units to handle two threads, so you don't even get the advantage of avoiding stalls
10:50:06 <kiris> Baughn: oh, I see
10:50:20 <jansz> @pl (\t c -> c / (1 + i)**t)
10:50:20 <lambdabot> flip (/) . ((1 + i) **)
10:50:55 <vixey> @pl \i -> flip (/) . ((1 + i) **)
10:50:55 <lambdabot> (flip (/) .) . (**) . (1 +)
10:50:56 <Baughn> kiris: And I'd like to point out that a core 2 is something like $50 these days. You'd get the speed boost /for free/, from the per-core speedup; consider what your time optimizing this is worth.
10:51:30 <Baughn> (Plus, experience programming multi-threaded applications on multi-core hardware is going to be invaluable shortly)
10:51:56 <Baughn> The potential speedups are getting huge..
10:53:12 <kiris> well I think I'll consider it then
10:53:38 <dons> core 2's are sweet.
10:54:04 <dons> Baughn: you can get the value of N cores via Control.Concurrent now too
10:54:28 <Baughn> dons: I'm addicted already
10:55:07 <dons> numCapabilities :: Int
10:55:30 <Baughn> Oh, the /number/ of cores?
10:55:39 <Baughn> Wait, Int? IO Int, surely?
10:55:51 <dons> the value of N doesn't change during a program run
10:56:11 <Baughn> No, but I'd think the optimizer might.. oh, of course. No inlining information.
11:00:03 * monochrom looks at the topic and becomes a code zombie.
11:00:24 <shepheb> how does one see the edit history of a Trac page?
11:00:24 <lambdabot> shepheb: You have 1 new message. '/msg lambdabot @messages' to read it.
11:00:36 <skorpan`> lambdabot: how many do i have?
11:03:14 <saml> shepheb: click Revision log?
11:03:40 <BMeph> skorpan`: Apparently, not enough to notice. :)
11:03:46 <shepheb> saml: found the Latest Change link at the top.
11:04:30 <saml> mayb it's trac configuration. i'm not sure.. some projects have Revision Log link next to Lastest Change link
11:05:38 <dons> ?users
11:05:38 <lambdabot> Maximum users seen in #haskell: 464, currently: 455 (98.1%), active: 18 (4.0%)
11:05:46 <dons> espresso level : critical!
11:05:57 <idnar> heh
11:07:57 <kiris> uhhh. okay... I ran histogram function by itself and it takes 7ms so I'm guessing something else in my code must've been taking 7 seconds @____@
11:08:47 <Baughn> kiris: Profile it?
11:09:47 <hpaste>  dolio pasted "Existential state (doesn't work)?" at http://hpaste.org/8767
11:14:24 <kiris> Baughn: I found it. stupid mistake. I was filtering uninteresting words like "the" and "a" (250 of them), but doing it to the list before doing the Map stuff. instead I should've done it /after/ the Map was created with one of Data.Map's filter functions
11:17:08 <shepheb> kiris: mod+t
11:17:11 <shepheb> mischan
11:17:11 <vixey> what does unknown package lang mean? (If I just remove -package lang the error geos away)
11:18:04 <Baughn> vixey: That you have no package called "lang".
11:18:13 <Baughn> Eg. the things shown with ghc-pkg -l
11:18:23 <vixey> who has a package called lang ?
11:18:40 <dons> lang was an old name for what is now the haskell98 pkg
11:20:39 <hpaste>  dolio annotated "Existential state (doesn't work)?" with "Continuation passing." at http://hpaste.org/8767#a1
11:20:48 <dolio> Does that look CPSed right?
11:25:03 <dolio> Alternate question, why doesn't the original work? Should I be existentially quantifying at the tuple instead of the monad?
11:26:19 <dolio> (That would correspond more closely to the CPS/universal version.)
11:30:59 <koninkje> Well your definition of return has ::d == ::c for one (hence isn't :: exists d. forall.c c)
11:31:26 <koninkje> s/forall.c/forall c./
11:34:13 <dolio> Are you not allowed to lift a -> (exists b. b) to exists b. a -> b? I guess that'd explain it.
11:34:42 <dolio> I suppose that'd be dual to forall.
11:34:44 <koninkje> The lifting convertis it from exists to forall
11:35:02 <ddarius> dolio: In the first case your type is equivalent to ExistsState a = ES a and the latter ExistsState r a = ES ((a -> r) -> r)
11:35:18 <koninkje> That is, rank-2 forall, not the normal rank-1 forall
11:35:47 <dbbddbdb_> Hi!  What is the easiest way of running a helper program and grabbing it's stdout?
11:36:06 <Baughn> :t runInteractiveProcess
11:36:06 <lambdabot> Not in scope: `runInteractiveProcess'
11:36:10 <mar77a> @faq
11:36:10 <lambdabot> The answer is: Yes! Haskell can do that.
11:36:14 <Baughn> @hoogle runInteractiveProcess
11:36:14 <lambdabot> System.Process.runInteractiveProcess :: FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> IO (Handle, Handle, Handle, ProcessHandle)
11:37:01 <dolio> ddarius: Yes, well, pretend the cs and ds are used for something more interesting than totally hiding any information about the state.
11:38:17 <ddarius> dolio: Is there supposed to be a connection between d and c?
11:38:42 <dolio> It's allowed to change over the course of a computation.
11:39:29 <dbbddbdb_> Baughn: that's pretty complex, is there something really simple like Perl's ``?
11:39:59 <dolio> At least, that's what I was going for. Thinking about it some more, I'll probably just do 'State SomeExistential a'.
11:40:13 <dolio> Not sure why I didn't do that in the first place, but perhaps I wasn't thinking clearly.
11:41:20 <Baughn> dbbddbdb_: No, but it would be rather easy to build one that /is/ that simple.
11:41:35 <byorgey> I think there is one, actually
11:41:42 <byorgey> just a minute, let's see if I can find it
11:41:52 <ddarius> There's HSH
11:41:56 <ddarius> @hackage HSH
11:41:56 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HSH
11:42:39 <byorgey> there's also the 'pipe' library
11:42:41 <byorgey> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Pipe
11:42:44 <lambdabot> Title: HackageDB: Pipe-1.0
11:43:58 <dbbddbdb_> Yes, that's it, thanks!
11:44:18 <byorgey> wow, I didn't know about HSH
11:44:23 <byorgey> CosmicRay++
11:45:57 <CosmicRay> thanks :-)
11:46:00 <CosmicRay> hope you enjoy
11:46:33 <CosmicRay> api ref for HSH is at http://software.complete.org/static/hsh/doc//HSH/ if it doesn't build on hackage
11:46:33 <lambdabot> Title: HSH-1.2.6: Library to mix shell scripting with Haskell programs
11:47:01 <CosmicRay> oh good, looks like it does build there.
11:48:22 <chadz> i'm starting to dislike the usage of goofy little function aliases akin to :>, ##, +++, etc
11:48:31 <monochrom> :>
11:48:37 <chadz> cute :)
11:49:56 <chadz> they're convienient while writing, but, i think tehre's a longer term issue of polluting namespaces with a plethora of goofy functions and reading code later on
11:50:13 <vixey> chadz: I guess you're coming from lisp?
11:50:17 <chadz> of course you can just go look up the definition / type, but, there's still a market for meaningful names.
11:50:18 <monochrom> data Moods a b = a :*> b | a :-< b | a :^> b
11:50:19 <CosmicRay> byorgey: something is wrong with the generated docs of HSH on cabal.  they are missing the instances for ShellCommand (or the majority of them, anyhow)
11:50:27 <CosmicRay> best to use the docs on software.complete.org
11:50:40 <mapreduce> > let ($_) x y = x + y in 3 $_ 4
11:50:40 <lambdabot>  Parse error in pattern at "in" (column 22)
11:50:41 <byorgey> ok, good to know
11:50:56 <chadz> vixey: no -- just a 'real-world' user :)
11:51:14 <mapreduce> I used to use the real world.
11:51:23 <vixey> I don't know what that is
11:51:34 <chadz> mapreduce: did it drop you, or did you drop it?
11:52:11 <byorgey> I like using operator names (like :>, ##, etc.) in EDSLs, but providing an alternate 'long form' with a descriptive name as well
11:57:32 <vixey> xmonad totally screwed up
11:58:23 <vixey> that was odd
12:02:26 <cinimod> @seen gwern
12:02:27 <lambdabot> gwern is in #darcs, #xmonad and #haskell. I last heard gwern speak 2h 18m 59s ago.
12:02:35 <profmakx> a propos xmonad
12:06:58 <plutonas_> hm, what is fromIntegral doing?
12:07:48 <byorgey> fromIntegral is a method of the class Integral.
12:08:06 <byorgey> er, I mean, Num
12:08:22 <mauke> wat
12:08:25 <byorgey> so there is a different implementation of fromIntegral for each type which is an instance of Num.
12:08:27 <plutonas_> hm, i didn't learn about classes yet
12:08:32 <mauke> @src Integral
12:08:32 <lambdabot> class  (Real a, Enum a) => Integral a  where
12:08:32 <lambdabot>     quot, rem, div, mod :: a -> a -> a
12:08:32 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
12:08:32 <lambdabot>     toInteger           :: a -> Integer
12:08:40 <mauke> @src fromIntegral
12:08:40 <lambdabot> fromIntegral = fromInteger . toInteger
12:08:40 <byorgey> oh, actually, I guess it's not a member of any class
12:08:47 <Deewiant> @src Num
12:08:47 <lambdabot> class  (Eq a, Show a) => Num a  where
12:08:47 <lambdabot>     (+), (-), (*)           :: a -> a -> a
12:08:47 <lambdabot>     negate, abs, signum     :: a -> a
12:08:48 <lambdabot>     fromInteger             :: Integer -> a
12:08:53 <byorgey> fromInteger is a member of class Num.
12:09:17 <plutonas_> what exactly does it take as input and what does it give as output?
12:09:17 <chadz> vixey: i've only had xmonad crash twice, i think
12:09:21 <byorgey> plutonas_: type classes are easy.  they are sort of like interfaces in Java, if you know Java.
12:09:22 <mauke> :t fromIntegral
12:09:22 <plutonas_> ok it takes input from class num?
12:09:34 <lambdabot> forall a b. (Num b, Integral a) => a -> b
12:09:35 <plutonas_> byorgey: no idea of java
12:09:43 <byorgey> plutonas_: ok, ignore that then =)
12:09:59 <mauke> it takes any integral type and returns any numeric type
12:10:02 <byorgey> plutonas_: a type class says, 'any type which is an instance of this class must implement functions with these types'
12:10:13 <Baughn> byorgey: Right up until the point someone implements type-level arithmetic with them
12:10:44 <byorgey> plutonas_: then you can write functions which work generically for any member of a type class, by using only the functions they are guaranteed to provide an implementation for
12:10:47 <plutonas_> i see
12:10:52 <byorgey> Baughn: shhh ;)
12:11:09 <byorgey> plutonas_: for example, one of the functions in the Num class is (+)
12:11:25 <mauke> > 2 + 2
12:11:27 <lambdabot>  4
12:11:30 <mauke> > 2.5 + 1.5
12:11:31 <lambdabot>  4.0
12:11:34 <byorgey> plutonas_: so you can add two values of any type, as long as the type is an instance of Num
12:11:36 <plutonas_> yes i see
12:11:45 <Baughn> byorgey: And isn't it more that java interfaces are like crippled haskell classes?
12:11:48 <plutonas_> :)
12:11:53 <byorgey> Baughn: well, yes =)
12:11:54 <plutonas_> but the problem remains
12:12:03 <plutonas_> i still can't understand what fromIntegral does
12:12:05 <chadz> plutonas_: most sane people prefer this method over subtyping, etc where you have classes which themselves contain virtual methods, etc.
12:12:12 <byorgey> plutonas_: so, let's look at the source of fromIntegral
12:12:15 <byorgey> @src fromIntegral
12:12:15 <lambdabot> fromIntegral = fromInteger . toInteger
12:12:17 <mauke> plutonas_: understand fromInteger first
12:12:23 <mauke> it's simpler
12:12:26 <byorgey> it is the composition of fromInteger with toInteger
12:12:33 <plutonas_> actually it's in this books example-code again
12:12:37 <plutonas_> and it's not explained
12:13:05 <plutonas_> hm, perhaps an example would do better...
12:13:11 <chadz> plutonas_: what it does, or how it does it?
12:13:13 <byorgey> > fromInteger 6 :: Double
12:13:14 <lambdabot>  6.0
12:13:18 <byorgey> > fromInteger 6 :: Rational
12:13:19 <lambdabot>  6%1
12:13:21 <mauke> fromInteger takes a number of type Integer and returns any numeric type you want
12:13:28 <chadz> plutonas_: haskell is strongly-typed, even with math
12:13:29 <byorgey> > fromInteger 6 :: Int
12:13:30 <lambdabot>  6
12:13:34 <mauke> > fromInteger 6 :: Complex Double
12:13:35 <lambdabot>  6.0 :+ 0.0
12:13:37 <ddarius> There are definite benefits (and costs) to the way Java interfaces work v. type classes, but they just aren't doing the same thing; they are not comparable.
12:13:42 <plutonas_> oh i see
12:13:43 <vixey> haskell is well typed :D
12:14:03 <byorgey> plutonas_: since fromInteger is a member of the Num type class, each Num type must provide a way to convert an Integer to that type
12:14:05 <chadz> plutonas_: you can't mix improper types when you're doing math, fromIntegral will make the appropriate type out of an integral. ie, if you want to use (/) with an integer
12:14:13 <mauke> plutonas_: do you know any other programming languages?
12:14:15 <ddarius> It would make sense to have a language with both Java-style interfaces and Haskell-style type classes and in fact Scala comes close to this.
12:14:35 <mauke> ddarius: aren't java interfaces just existentials?
12:14:38 <chadz> > 1.2 / (fromIntegral (3::Integer))
12:14:39 <lambdabot>  0.39999999999999997
12:14:40 <ddarius> mauke: No.
12:14:47 <chadz> > 1.2 / (3::Integer)
12:14:47 <lambdabot>   add an instance declaration for (Fractional Integer)
12:14:54 <hukolele> @hoogle [[a]] -> (Int,Int) -> a-> [[a]]
12:14:55 <lambdabot> No matches, try a more general search
12:15:06 <plutonas_> mauke: Common Lisp, C, Fortran, shell scripting, and a little tiny bit of C++
12:15:11 <hukolele> how can i actualize a value in a list of lists([[a]])?
12:15:15 <byorgey> plutonas_: I should point out that there are really only two Integral types (this is a lie, but they're the only two important ones): Integer and Int.
12:15:17 <hukolele> in a simple way
12:15:19 <plutonas_> it's like type casting in some way
12:15:24 <plutonas_> right?
12:15:28 <Botje> hukolele: "actualize" ? you mean construct?
12:15:28 <mauke> hukolele: manually
12:15:32 <mauke> update
12:15:37 <Botje> ah
12:15:44 <byorgey> > [[3,4,5],[4,6,7]] !! 0 !! 2   -- like this?
12:15:45 <lambdabot>  5
12:15:47 <hukolele> Botje: yes, construct
12:15:50 <mauke> plutonas_: more like conversion
12:16:04 <byorgey> oh, no, that's not what you meant
12:16:29 <chadz> plutonas_: somewhat. haskell avoids any implicit behavior when typing is involved. you have to do the right thing.
12:16:44 <byorgey> plutonas_: so fromIntegral is only different than fromInteger by the fact that it may convert an Int to an Integer first, and then convert using fromInteger
12:16:50 <plutonas_> hm, ok, thanks all, let me have a try and experiment a bit... i'll come back if i still have trouble :)
12:16:53 <ziman> hukolele, you cannot modify values in haskell; they're immutable. you need to create a copy of the structure with the value changed
12:17:02 <mauke> fromInteger is like a virtual constructor
12:17:03 <Baughn> plutonas_: That is not true for ghci or LB, which will default types in some simple cases
12:17:21 <Baughn> plutonas_: (So if you type 2, it assumes it's an integer instead of requiring you to say 2::Integer)
12:17:24 <byorgey> ziman: the type of the function hukolele gave does exactly that.
12:17:50 <hukolele> ziman: i know, but how can i get a copy of a matrix with one velue changed?
12:17:55 <ziman> um, indeed.
12:18:13 <Botje> > let update n f l = let (a,x:b) = splitAt n l in a ++ f x : b in update 0 (update 2 (+1)) [[3,4,5],[4,6,7]] !! 0 !! 2
12:18:14 <lambdabot>  6
12:18:24 <ziman> i don't think there's any library function for that
12:18:24 <Baughn> plutonas_: ..bad example; ghc does the same. I'm positive there are some good ones, though. You'll notice, or most likely not.
12:18:31 <Botje> > let update n f l = let (a,x:b) = splitAt n l in a ++ f x : b in update 0 (update 2 (+1)) [[3,4,5],[4,6,7]]
12:18:32 <lambdabot>  [[3,4,6],[4,6,7]]
12:18:41 <Botje> hukolele: see! :p
12:19:05 <hukolele> ok, i see... thx Botje
12:19:22 <byorgey> hukolele: if I may ask, for what purpose do you need to update single entries in a list of lists?
12:19:25 <monochrom> It is, rather, create a new matrix inspired by the old.
12:19:37 <plutonas_> Baughn: yeap! I think i get it now
12:19:52 <plutonas_> i really love this channel :)
12:20:20 <hukolele> byorgey: bactraking in a puzzle-8 problem, its to generate next states...
12:20:44 <Baughn> hukolele: Why not use arrays instead? It might be nicer, possibly even faster
12:20:45 <byorgey> what's puzzle-8?
12:20:59 <Baughn> Or an IntMap
12:21:01 <byorgey> but also harder to write
12:21:11 <Baughn> Or Seq
12:21:13 <hukolele> just practicing
12:21:54 <hukolele> byorgey: puzzle 8 is a puzzle with numerated values and a hole, u can only move the pieces next to the hole
12:22:08 <byorgey> hukolele: oh, yes, I see
12:22:30 <ddarius> hukolele: Use a zipper!
12:23:01 <hukolele> ddarius: whats that?
12:23:39 <ddarius> http://en.wikibooks.org/wiki/Haskell/Zippers
12:23:46 <byorgey> gee whiz, the poor guy is just trying to practice writing some Haskell ;)
12:24:05 <Baughn> hukolele: If the phrase "derivate of a data structure" gives you hives... don't worry; it's very simple. ^_^
12:24:38 <byorgey> hukolele: if I were you I'd use lists-of-lists and Botje's updating code above first, and get it to work: THEN if you'd like to come back and try something more sophisticated/faster (arrays, zippers...) by all means do so
12:24:44 <byorgey> that's just my two cents though.
12:24:47 <ddarius> I was actually somewhat joking though it likely could apply well.
12:25:18 <byorgey> yes, it probably could, especially since there is quite literally a 'hole' in the puzzle =)
12:25:30 <ddarius> byorgey: But I was just about to expand into a comonadic interface to a zipper.
12:25:46 <byorgey> hehe
12:26:43 <hukolele> haha, ill follow your advice byorgey, thx
12:28:09 <schme_> Is there a unicode toUpper ?
12:28:20 <quicksilver> toUpper is the unicode toUpper
12:28:23 <quicksilver> as far as I know?
12:28:26 <Baughn> It is
12:28:35 <Baughn> Only problem is, "toUpper" isn't really /defined/ for unicode
12:28:35 <schme_> Doesn't seem like the one I am using is working correctly.
12:28:55 <schme_> Right. So where do I find one that is /defined/ for unicode?
12:29:11 <ddarius> schme_: Are you sure you're reading the input and producing the output properly encoded?
12:29:11 <Baughn> Um. What I meant was, it isn't obvious how it can be.
12:29:21 <mauke> > toUpper '\xe4'
12:29:29 <lambdabot>  '\196'
12:29:33 <Baughn> What is it supposed to do in alphabets with two alternate uppercases? Should it turn romanij into katakana? Etc.
12:29:37 <mauke> good enough
12:29:40 <chadz> is there a bytestring version of parsec yet?
12:29:47 <ddarius> chadz: Yes.
12:29:50 <schme_> toUpper 'â' gave me shit.
12:29:51 <Baughn> chadz: Yes, v3 has native support. Cabal-install it
12:29:55 <chadz> nice.
12:30:02 <mauke> > toUpper '\xe2'
12:30:03 <lambdabot>  '\194'
12:30:17 <mauke> schme_: where shit = Â
12:30:27 <schme_> No. It gave me 97
12:30:31 <mauke> no, it didn't
12:30:37 <profmakx> O.o
12:30:39 <schme_> Yes, it did.
12:30:52 <schme_> I'll just rebuild ghc and see if it works better.
12:30:55 <Baughn> schme_: What version of ghc are you on?
12:30:55 <mauke> testcase please!
12:31:05 <schme_> no idea.
12:31:08 <EvilTerran> also, how're you getting the character?
12:31:10 <quicksilver> schme_: that's not likely to make a difference.
12:31:23 <schme_> mauke: foo = toUpper 'â'    ghci> :l foo.hs     foo   97
12:31:32 <Baughn> schme_: Still, ghc -v please. It's sort of useful to know, too..
12:31:36 <EvilTerran> as, iirc, the Prelude IO functions read in bytes
12:31:52 <schme_> Baughn: Right. hang on a sec. building it now.
12:31:53 <quicksilver> schme_: what encoding is foo.hs saved in?
12:31:55 <Baughn> Oh yeah. Ouch.
12:32:21 <mauke> schme_: 97 is not a Char
12:32:21 <schme_> quicksilver: good question. utf-8 I assume.
12:32:26 <mauke> also, I get '\194'
12:32:35 <schme_> mauke: As I said, I got shit.
12:32:42 <mauke> define "shit"
12:32:46 <schme_> 97
12:32:51 <mauke> impossible
12:32:53 <EvilTerran> please, this is a family-friendly channel
12:33:03 <schme_> ...
12:33:10 <quicksilver> 6.6 ghci is not very unicode-comfortable.
12:33:15 <mauke> no matter how fucked up your characters are, they won't show up as numeric literals
12:33:17 <EvilTerran> we don't want to scare away any 10yo proto-Olegs with bad language
12:33:18 <quicksilver> but that's only ghc*I*
12:33:28 <quicksilver> doesn't mean ghc doesn't support it.
12:33:35 <schme_> Well I'm checking with ghci, ya.
12:33:47 <__pao__> does anyone know how to twik ghc installation in order to always add a certain path to libraries path? (-L/foo)
12:33:51 <quicksilver> ghci 6.6 certainly s
12:33:57 <quicksilver> doesn't support interactive unicode input
12:34:04 <quicksilver> and I'm not sure it supports output
12:34:09 <quicksilver> you could try 'show foo'
12:34:10 <EvilTerran> __pao__, if there's a way, it'll be an environment variable. check that bit of the manual.
12:34:17 <quicksilver> that wll wrap in it anotehr later of escaping
12:34:21 <schme_> Well I'm building now. I'll see later.
12:34:22 <quicksilver> so you can see what foo *really* is
12:34:38 * byorgey parsed that as "we don't want to scare away any (10yo proto-Olegs with bad language)"
12:35:24 <__pao__> EvilTerran: I've already RTFM :-( ... also searching for env-like keyword doesn't seem to help :-(
12:35:34 <ddarius> byorgey: That's the correct parse...
12:35:45 <mauke> __pao__: why do you need a custom library path?
12:37:10 <__pao__> mauke: I've installed ghc-6.8.3 for mac os x (it's pre-compiled distribution) ... while it requires to have gmp in /opt/local/lib... it doesn't default looking into that directory during linking phase
12:37:29 <__pao__> mauke: I usually solve it by adding -L/opt/local/lib to ghc invocations...
12:37:54 <mauke> ah, let me see how I did it
12:38:26 <__pao__> mauke: but I cannot make it work when I invoke "runhaskell Setup.hs build"
12:38:59 <quicksilver> __pao__: FYI this is not really a question about getting GHCs to find libraries.
12:39:13 <quicksilver> __pao__: this is a question about persuading your linker to find it.
12:39:25 <quicksilver> (and persauding GHC to send particular options to the linker)
12:39:28 <mauke> __pao__: I put the location in LD_LIBRARY_PATH and LIBRARY_PATH
12:39:47 <quicksilver> I thought you wanted a way to persaude GHC to find libraries, for which the answer is http://www.haskell.org/ghc/docs/latest/html/users_guide/packages.html
12:39:48 <lambdabot> Title: 5.8. Packages, http://tinyurl.com/2bpgem
12:39:50 <quicksilver> ;)
12:40:42 <__pao__> quicksilver: you're definitely right :-)
12:41:03 <__pao__> mauke: thanks! let me try it... are you on a mac as well?
12:41:07 <mauke> no
12:41:17 <mauke> linux system without gmp (or root access)
12:41:34 <LordBrain> if i have a purely functional function, f, and i apply it to a literal like 3 and get back 5... will ghc do it at compile time and optimize my code so that i have simply 5 instead of f 3 ?
12:41:45 <quicksilver> OSX's linker is not exactly the same as linux's linker. Still mauke's solution is worth trying.
12:41:59 <quicksilver> LordBrain: typically no. Occasionally yes.
12:42:03 <Baughn> __pao__: The funny thing is, if you build it without a gmp library it'll use its own. Might want to do that, avoid the aggravation
12:42:29 <LordBrain> why not typically?
12:42:37 <__pao__> quicksilver: in fact I'm looking at darwin ld docs....
12:42:56 <Baughn> __pao__: You'll want to say export LDFLAGS="-L wherever"; that works
12:42:56 <quicksilver> LordBrain: because GHC doesn't do much in the way of constant folding.
12:43:19 <quicksilver> LordBrain: however it does do inlining and I believe it folds constant 'case' expressions.
12:43:24 <LordBrain> not even if i boost up the -O switch?
12:43:25 <__pao__> Baughn: I've tried to compile ghc myself from src... I spent 2 hours without succeding in linking to readline :-(
12:43:50 <Baughn> __pao__: ./configure --disable-objectio --with-readline-includes=/sw/include/ --with-readline-libraries=/sw/lib/ --with-gmp-includes=/sw/include/ --with-gmp-libraries=/sw/lib <-- Here's the exact line I'm using
12:43:50 <quicksilver> LordBrain: do you really think I would have said 'no' if I mean 'yes if you turn on -O' :P
12:43:57 <LordBrain> no
12:44:18 <__pao__> Baughn: I'll retry it
12:44:29 <quicksilver> LordBrain: if you want a longer answer as to why, the deep answer is because f might not terminate.
12:44:35 <Baughn> __pao__: Read the configure output, make sure to watch for the lines about readline
12:44:42 <quicksilver> but as I say I think GHC will fold a constant case.
12:44:54 <__pao__> Baughn: --disable-objectio is the only difference from my original attempt
12:45:27 <Baughn> __pao__: That's actually the default, so it won't make a difference. Still, check the readline lines, see if they're all reasonable
12:46:21 <__pao__> Baughn: did you try it with 6.8.3 as well? the option --with-gmp-libraries doesn't seem to produce any difference in configure.log
12:47:00 <Baughn> __pao__: It produces a difference for me, but that's a local thing. And it's readline you were missing, right?
12:47:17 <Baughn> Pointing it at fink gmp won't help unless you /install/ fink gmp. ;)
12:48:02 <Baughn> ..come to think of it, the same goes for readline. Yes on all six lines, I hope?
12:49:37 <__pao__> Baughn: I fortunately know that :-) I've installed gmp from macports ;-) the strange thing is that if I provide your options and grep -r on the src dir I only find /opt/local/lib string in the log of my invocation to configure
12:50:20 <Baughn> __pao__: Macports? You did alter it from /sw to /opt/local then, right?
12:50:50 <__pao__> Baughn: no, /opt/local is the default for macports
12:51:02 <Baughn> __pao__: Yes, exactly, and my line says /sw
12:52:02 <__pao__> Baughn: ouch!
12:52:03 <__pao__> Baughn: is that reasonable even if I don't have a /sw dir?
12:52:51 <Baughn> __pao__: Asking ghc to look for readline in a nonexistend directory is unlikely to produce results. Some thoughts of /what/ the option means is recommended.
12:53:54 <__pao__> Baughn: I misunderstood your last messages...
12:54:12 <__pao__> Baughn: to make it clear
12:54:35 <__pao__> Baughn: I've installed gmp and readline with macports (/opt/local is the default root for macports)
12:55:15 <__pao__> Baughn: I've given exactly (except for disable-objectio) options to configure
12:55:31 <Baughn> __pao__: Exactly /what/? Paste it, please.
12:56:27 <__pao__> Baughn: yours with s/sw/opt\/local/
12:56:42 <__pao__> Baughn: example --with-gmp-libraries=/opt/local/lib
12:56:56 <MindChild> fags
12:57:06 <Baughn> __pao__: Alright. And there is, in fact, a file called /opt/local/include/readline/readline.h?
12:57:39 <Baughn> pantsd: There should be six lines relating to readline in the configure output, too. They should all be yes.
12:57:42 <Baughn> *pao
12:58:01 <__pao__> hypermac:~ paolo$ ls /opt/local/include/readline/
12:58:02 <__pao__> chardefs.h  keymaps.h   rlconf.h  rltypedefs.h
12:58:02 <__pao__> history.h   readline.h  rlstdc.h  tilde.h
12:58:29 <__pao__> I'll retry right now
13:00:40 <roconnor> @type getStdGen
13:00:53 <roconnor> @bot
13:00:55 <lambdabot> thread killed
13:00:56 <lambdabot> :)
13:01:07 <roconnor> @hoogle getStdGet
13:01:08 <lambdabot> No matches found
13:01:09 <roconnor> @hoogle getStdGen
13:01:09 <lambdabot> System.Random.getStdGen :: IO StdGen
13:01:18 <roconnor> @hoogle StdGen
13:01:18 <lambdabot> System.Random.StdGen :: data StdGen
13:01:18 <lambdabot> System.Random.mkStdGen :: Int -> StdGen
13:01:18 <lambdabot> System.Random.getStdGen :: IO StdGen
13:03:57 <LordBrain> I see there is Debug.QuickCheck and Test.QuickCheck... which is the newest?
13:04:20 <LordBrain> nvm its Test.QuickCheck
13:05:00 <Baughn> LordBrain: Um, they're both the same library
13:05:05 <Baughn> Just different interfaces
13:05:43 <LordBrain> but Test.QuickCheck is the newer interface right?
13:06:01 <Baughn> Actually, Debug.QuickCheck was renamed to Test.QuickCheck
13:06:04 <Baughn> They're the /same/ interface
13:06:17 <LordBrain> ok
13:06:27 <LordBrain> Test is what i should use in new code tho right?
13:07:41 <Baughn> Might as well
13:12:58 * __pao___ is waiting for its ghc-src download
13:14:28 <__pao___> while waiting for ghc source I can tell you that I didn't find any way to convince the linker to add my path to its search path via environment
13:18:46 <nolrai_East> @hoogle Int -> (a -> a) -> a -> a
13:18:46 <lambdabot> No matches, try a more general search
13:19:15 <nolrai_East> is there a function like fix but with a finite number of aplications?
13:19:39 <dons> :t iterate
13:19:43 <lambdabot> forall a. (a -> a) -> a -> [a]
13:19:49 <nolrai_East> dons++
13:19:51 <dons> :t replicate
13:19:52 <lambdabot> forall a. Int -> a -> [a]
13:19:56 <dons> :t repeat
13:19:57 <lambdabot> forall a. a -> [a]
13:20:00 <dons> :t until
13:20:01 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
13:20:07 <dons> a few kind of loopy things.
13:20:26 <dons> :t unfoldr
13:20:27 <lambdabot> Not in scope: `unfoldr'
13:20:39 <dons> curious. List not imported anymore?
13:20:40 <nolrai_East> :t unfold
13:20:41 <lambdabot> Not in scope: `unfold'
13:20:48 <dolio> That's weird.
13:20:54 <nolrai_East> :t List.unfoldr
13:21:01 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
13:21:01 <dolio> :t find
13:21:02 <lambdabot> Not in scope: `find'
13:21:12 <dolio> Yeah, Data.List must not be imported anymore.
13:21:16 <dolio> :t foldl'
13:21:16 <lambdabot> Not in scope: `foldl''
13:21:20 <dons> kids
13:21:28 <nolrai_East> ?
13:22:04 <nolrai_East> :t foldr
13:22:04 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
13:22:44 <nolrai_East> :t \f n -> foldr (.) $ replicate f n
13:22:45 <lambdabot>     Couldn't match expected type `a -> c' against inferred type `[a1]'
13:22:45 <lambdabot>     In the second argument of `($)', namely `replicate f n'
13:22:45 <lambdabot>     In the expression: foldr (.) $ replicate f n
13:23:01 <nolrai_East> :t \f n -> foldr (.) id $ replicate f n
13:23:01 <lambdabot> forall a. Int -> (a -> a) -> a -> a
13:24:50 <nominolo> @unmtl ErrorT e (State s) a
13:24:50 <lambdabot> s -> (Either e a, s)
13:25:07 <nominolo> @unmtl StateT s (Either e) a
13:25:07 <lambdabot> s -> Either e (a, s)
13:25:21 <nominolo> hmm...
13:25:46 * gwern grumbles. why is there no "breaks" in the base libraries?
13:26:28 <nominolo> @unmtl RWST s (Either e) a
13:26:28 <lambdabot> err: `RWST s (Either e) a' is not applied to enough arguments, giving `/\A B. s -> a -> A (B, a, Either e)'
13:26:41 <nominolo> @unmtl RWST  r w s (Either e) a
13:26:41 <lambdabot> r -> s -> Either e (a, s, w)
13:28:00 <nominolo> @unmtl Cont r a
13:28:01 <lambdabot> (a -> r) -> r
13:28:33 <nolrai_East> i find Cont so very confusing.
13:29:05 <BMeph> nolrai: Then that means that it's working... ;p
13:29:28 <nominolo> nolrai_East: it requires a bit of a different kind of thinking
13:30:04 <roconnor> why is Ruby in the topic?
13:30:31 <roconnor> that doesn't seem appropriate
13:31:25 <gwern> your mom didn't seem appropriate
13:31:34 <nolrai_East> umm
13:31:36 <nominolo> nolrai_East: programs in continuation passing style never return, they just call a function that performs the rest of the computation.  think message-passing
13:31:45 <mattam> It was set by dons... weird?
13:31:45 <gwern> in bed, I mean
13:32:48 <nolrai_East> gwen, somewere in the world it's too early for your mom jokes. (but not here)
13:33:01 <dibblego> 0632 here
13:33:32 <dolio> When you lose haskell, you're allowed to use faulty syllogisms.
13:33:37 <dolio> Use, haskell, even.
13:33:48 <dolio> My fingers have a mind of their own today.
13:34:17 <nominolo> nolrai_East: and if you keep a copy of that function that performs the rest of the computation you basically create a snapshot of your program (kind of like what the kernel does when a program performs a system call, in case of fork it actually calls the same function twice)
13:35:32 <nolrai_East> nominolo: Ok that seems almost sensible.
13:35:55 <roconnor> gwern: I don't think we should be disparaging in #haskell, and certainly not in the topic.
13:36:37 <roconnor> Is it possible to write type signatures for items in where clauses that refer to type variables from the signature of the top level function?
13:36:46 <mauke> not in H98
13:36:53 <mauke> yes in GHC
13:36:55 <dibblego> why us "Ruby is slow" disparaging?
13:36:57 <dibblego> *is
13:37:01 <dolio> You need ScopedTypeVariables
13:37:20 <roconnor> mauke: so for H98 code I should live without these signatures.
13:37:27 <mauke> right
13:37:38 <Baughn> dibblego: Hm. Depends; can you prove it's true?
13:37:44 <dolio> In H98 you might be able to finagle something with asTypeOf.
13:38:00 <roconnor> dibblego: because the statement tends to belittle Ruby
13:38:06 <nolrai_East> "is slow" is not a good thing to say about anything to do with computers.
13:38:09 <dibblego> Baughn, no, but that would be a more interesting question than "oh that proposition is inconvenient for me, regardless of its truth value, therefore, it is disparaging"
13:38:20 <roconnor> dolio: I don't need the signatures.  They are there for documenations purposes.
13:38:26 <dolio> Ah.
13:38:28 <dibblego> roconnor, and? belittling something that might be little is merely an observation
13:38:29 <nominolo> nolrai_East: the transformation is like this: every function now takes an extra parameter--the continuation--usually called k.  instead of returning, the function calls the continuation with what it would return, for example, add x y = primAdd x y becomes add' x y k = k (primAdd x y)
13:38:49 <dolio> roconnor: I guess asTypeOf wouldn't make it any clearer. :)
13:38:56 <nolrai_East> ahh
13:38:58 <roconnor> dibblego: it doesn't seem relevent to #haskell
13:39:11 <tromp> how'd you feel if #ruby said "haskell is slow" in its title?
13:39:13 <vixey> It's definitely not relevant to haskell
13:39:19 <roconnor> dolio: basically there were some type signatures in the where clauses, but then I generalized the function.
13:39:21 <dibblego> roconnor, then you are objecting to the relevance, not whether it is disparaging
13:39:27 <roconnor> dolio: now it seems I need to delete the type signatures.
13:39:35 <Baughn> roconnor: It's relevant because it's in the topic. ;)
13:39:40 <nolrai_East> dibblego: both
13:39:47 <Baughn> Now, one might question the sanity of that topic, but..
13:40:04 <vixey> I got Epigram 1 working
13:40:05 <vixey> :D
13:40:06 <roconnor> dibblego: perhaps you are right.
13:40:10 <dibblego> it's not disparaging, even if inconvenient for the "them" part of "us and them" (I hate how languages form memes)
13:40:11 <vixey> I don't know what to do with it
13:40:23 <nominolo> nolrai_East: when it comes to types, the 'r' stands for "the result of the overall computation", ie, the result of runCont
13:40:24 <roconnor> The topic should be changed because it is ... off-topic
13:40:31 <Baughn> dibblego: It can't be disparaging if it's true, which I suspect it is
13:40:36 <roconnor> fucking legal system
13:40:44 <vixey> dibblego: I dont like how there's only language specific channels, why is there #declarative #imperative etc. ?
13:40:57 <gwern> Baughn: truth is not a defense in some jurisdictions...
13:41:13 <gwern> vixey: too hard to learn one language, much less every language claiming a particular paradigm
13:41:14 <Baughn> gwern: When arguing dictionary definitions, it is. ;)
13:41:16 <dibblego> vixey, agreed, I think this mentality prevents progress
13:41:19 <vixey> @remember <roconnor> The topic should be changed because it is ... off-topic
13:41:20 <lambdabot> I will remember.
13:41:32 <roconnor> how can Ruby be slow.  It is a language.  Or it is one of those languages where it's semenatics are given by a reference implemenation.
13:41:34 <mauke> vixey: fail
13:41:35 <dolio> There's #concatenative
13:41:48 <vixey> dolio: yeah... but it's about concatenative languages :P
13:41:55 <dibblego> there is #programming
13:41:59 <gwern> well, with concatenative there's not a whole lot of languages to know...
13:41:59 <dolio> Heh.
13:42:24 * gwern ponders some list processing
13:42:41 <Baughn> roconnor: The latter. Plus, making it fast would require some breakthroughs in compilation techniques
13:42:45 <Baughn> ..granted, that worked for haskell
13:43:05 <mauke> preflex: quote bos
13:43:05 <preflex>  <bos> i'm very pleased by the recent progress of the C++ standard.  it's gradually eroding the performance advantage of C++ compilers over GHC, without the simons having to do anything.
13:44:59 <hpaste>  gwern pasted "breaks" at http://hpaste.org/8768
13:45:26 <gwern> yeah, I can't quite get the last bit right, even though I know it'll turn out to be a simple tweak
13:45:28 <tromp> "lambda calculus is slow"
13:45:44 <lament> upgrade to lambda calculus 2.0
13:45:56 <tromp> "turing machines are slow"
13:46:15 <gwern> upgrade to a multi-tape turing machine
13:46:27 <saml> upgrade to multi-head-tape turing machine
13:46:36 <dibblego> gwern, I wrote that function in Scala http://projects.workingmouse.com/public/scalaz/artifacts/latest/src/scalaz/LList.scala
13:46:38 <lambdabot> http://tinyurl.com/6b9w62
13:46:40 <dons> implementation-defined languages can be validly called slow, since the language and its implementation coincide.
13:46:56 <gwern> scala? I don't know scala >.<
13:47:11 <roconnor> dons: the topic is off-topic
13:47:19 <dons> blame dolio
13:47:21 <nolrai_East> :t (***)
13:47:22 <lambdabot> Not in scope: `***'
13:47:32 <dibblego> gwern, you can see it is a right-fold
13:47:33 <gwern> '(a :: (if(x) as.head else Nil)) :: (if(as.isEmpty) Nil else if(x) as.tail else as)'<-- wut
13:47:35 <kiris> the bit in the topic is just a joke that someone said earlier. it's not like that part of the topic stays there for long before it's replaced anyway. tl;dr relax
13:47:38 <nolrai_East> :t (&&&)
13:47:38 <lambdabot> Not in scope: `&&&'
13:47:53 <roconnor> dons: my logs blame you
13:47:55 <dolio> Is that a quote of me or something?
13:48:04 <dons> ah, ddarius
13:48:06 <kiris> I reckon so, I do!
13:48:07 <gwern> dibblego: well great, but I want a haskell version :)
13:48:16 --- mode: ChanServ set +o dons
13:48:22 <dibblego> gwern, case [] -> []; case ts'@(_ : ts) -> if(x) ts else ts'
13:48:27 --- topic: set to '["Haskell: precision engineering for programmers", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org ", "Logs: http://tunes.org/~nef/logs/haskell/"]' by dons
13:48:31 --- mode: ChanServ set -o dons
13:48:33 <roconnor> dons: thanks
13:48:34 <dons> since roconnor's so grumpy
13:48:47 <mauke> @vixen cheer up, emo kid
13:48:47 <lambdabot> i drive a pickup truck
13:48:49 * kiris gives roconnor a platonic man hug
13:48:49 <roconnor> I'm in a bad mood :)
13:49:22 <gwern> dibblego: that's some unpleasant syntax
13:49:22 <roconnor> kiris: thanks
13:49:26 <nolrai_East> :t (Arrow.&&&)
13:49:27 <lambdabot> Couldn't find qualified module.
13:49:36 <nolrai_East> :t (Control.Arrow.&&&)
13:49:37 <lambdabot> forall (a :: * -> * -> *) b c c'. (Control.Arrow.Arrow a) => a b c -> a b c' -> a b (c, c')
13:49:43 <dibblego> gwern, better than Java, worse than Haskell
13:49:51 <nolrai_East> :t (Control.Arrow.***)
13:49:52 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Control.Arrow.Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
13:50:02 <gwern> dunno. wonder if scala won't be like perl
13:50:02 <mauke> > (show &&& sqrt) 2
13:50:09 <kiris> dibblego: what are you trying to say? Java's syntax is slow?
13:50:18 <lambdabot>  thread killed
13:50:21 <mauke> > (show *** sqrt) (3, 2)
13:50:22 <lambdabot>  ("3",1.4142135623730951)
13:50:26 <mauke> > (show &&& sqrt) 2
13:50:27 <lambdabot>  ("2.0",1.4142135623730951)
13:50:32 <roconnor> dons: in more pleasent news, I I'm almost finished a patch to make Charts even more typey
13:51:03 <kiris> test: http://www.cs.umd.edu/~jfoster/arrows.pdf
13:51:07 <roconnor> the type system will force the independent axis of plots to all be the same if they appear in the same chart
13:51:20 <kiris> no one pulled my λb patch. oh well
13:51:23 <dons> roconnor: yay
13:51:42 <roconnor> and will force the dependent axis of the plots always be one of two types, a type for the left axis and a type for the right axis.
13:51:58 <roconnor> <3 types
13:52:03 <nolrai_East> mauke++
13:52:15 <nolrai_East> @karma mauke
13:52:15 <lambdabot> mauke has a karma of 11
13:52:22 <nolrai_East> not bad.
13:52:25 <mauke> preflex: karma mauke
13:52:25 <preflex>  karma for mauke: 46
13:52:27 <Botje> typiness is an attribute of code now? :)
13:52:29 <Botje> goodie :)
13:52:36 <zachk> @karma zachk
13:52:37 <lambdabot> You have a karma of 0
13:53:03 <roconnor> I have a newtype LogValue = LogValue Double.  The charts will plot LogValues on a logarithmic axis.
13:53:12 <zachk> how do i get negative karma?
13:53:26 <mauke> zachk--
13:53:31 <mauke> @karma zachk
13:53:32 <kiris> you do not talk about project karma
13:53:32 <lambdabot> zachk has a karma of -1
13:53:36 <araujo> If for example you say java is better than haskell
13:53:51 <zachk> can i say scheme is better then java?
13:53:57 <araujo> sure
13:53:59 <roconnor> @karma java
13:53:59 <lambdabot> java has a karma of -23
13:54:06 <zachk> what can I do with my karma
13:54:15 <kiris> @karma lambdabot
13:54:16 <lambdabot> lambdabot has a karma of 3
13:54:20 <gwern> hoard it
13:54:25 <roconnor> zachk: pick up people
13:54:34 <zachk> but im engaged
13:54:48 <mauke> zachk++
13:54:52 <vixey> that's too bad
13:55:10 <zachk> can i say Haskell's record syntax makes me cry?
13:55:19 <roconnor> zachk: yes
13:55:20 <kiris> why?
13:55:28 <dolio> Wow, I have more karma than lambdabot. How'd that happen?
13:55:34 <zachk> cause I like to mutate my records
13:55:45 <roconnor> zachk: no one will fault you for complaining about Haskell's record system.
13:55:49 <vixey> lambdabot started sucking
13:55:55 <gwern> @karma gwern
13:55:55 <lambdabot> You have a karma of 3
13:56:02 <dons> zachk: you can 'mutate' records though
13:56:08 <vixey> it doesn't do unicode
13:56:09 <dons>  r { field1 = 7 }
13:56:17 <zachk> well i can make new records and pass them around as if i had state
13:56:19 <Heffalump> if you didn't do anything convenient like use existentials inside them :-(
13:56:51 <dons> zachk: welcome to purely functional programming. we do updates, and sharing, not mutation.
13:57:04 <vixey> ghc can do unicode so I don't know why lambdabot is pretending haskell can't
13:57:05 <kiris> it's annoying trying to add unicode to any programs because ghci doesn't seem to support it (???)
13:57:13 <vixey> ghci supports it fine
13:57:28 <gwern> anyone know where the discussion(s) about adding breaks to Data.List are?`
13:57:33 <kiris> when I type a λ it shows :�
13:57:40 <dolio> vixey: GHC IO doesn't do unicode, does it? I thought that's a frequent complaint.
13:57:50 <Beelsebob> Cale: you about?
13:57:56 <vixey> System.IO.UTF8 seems to do it
13:57:57 <nolrai_East> but the haskell syntax is annoying. if it can make an accessor for free it should make an updater too.
13:58:02 <Saizan> GHC is happy with utf-8 sources
13:58:09 <vixey> at least I can parse files full of UTF8 text
13:58:24 <zachk> is there a really simple example of the state monad somewhere? the gentle introduction wasnt very gentle
13:58:42 <EvilTerran> ?go you-could-have-invented-monads
13:58:43 <lambdabot> http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
13:58:43 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ...
13:58:58 <dons> > runState (do x <- get ; put (x + 1) ; return "done") 7
13:58:59 <lambdabot>  ("done",8)
13:59:00 <kiris> I had β for a function name (as in “reduce”) but couldn't use it from GHCI :P
13:59:07 <dons> zachk: there's a simple example ^^
13:59:25 <vixey> I think must be your terminal wrong then
13:59:59 <kiris> well I can type it into emacs which runs in my terminal.. and irssi.. maybe it needs extra special configuration for ghci
14:01:28 <vixey> lambdabot started out in #dutchhack?
14:04:51 <Beelsebob> dons: is there any chance that \bot's title reporting behavior can be restricted to certain domains?  e.g. youtube, tinyurl and hugeurl
14:05:07 <nolrai_East> what is hugeurl?
14:05:09 <kiris> Prelude> "λ"
14:05:10 <kiris> <interactive>:1:1: lexical error in string/character literal at end of input
14:05:22 <Beelsebob> nolrai_East: go to hugeurl.com and find out
14:05:28 <Beelsebob> but I'm not gonna paste a hugeurl in here >.<
14:05:50 <dons> Beelsebob: yes.
14:06:10 <Beelsebob> dons: ohh, how does one go about doing that, and further to that, can it be tuned on a per-channel basis?
14:06:38 <Dzlk> hah, I almost made a joke about hugeurl.com but it really *is* what I'd have suggested it is.
14:06:48 <Beelsebob> Dzlk: hehe :D
14:07:33 <kiris> I suspect this will just be one of those things that will be fixed randomly one day after I've gone out of my way to get around it and don't care anymore
14:07:55 <Beelsebob> Dzlk: it's better than just generating a huge URL -- it generates one that's the maximum allowable length for URLs
14:08:07 <Dzlk> ooh.
14:08:13 <gwern> so? lambdabot only prints 1024 character, iirc
14:08:25 <gwern> (or was it less?)
14:09:08 <mauke> IRC is limited to 512 - protocol overhead
14:10:15 <kiris> Beelsebob: I thought in HTTP 1.0 and 1.1 URLs had no limit and servers had to account for any length they could. I remember it because I thought it odd. am I wrong?
14:10:17 <nolrai_East> :t untell
14:10:21 <lambdabot> Not in scope: `untell'
14:10:44 <mauke> it's called seek
14:10:54 <gwern> @pl breaks' x y = drop 1 . reverse . drop 1 . reverse $ breaks x y
14:10:55 <lambdabot> breaks' = ((drop 1 . reverse . drop 1 . reverse) .) . breaks
14:11:16 <mauke> good old (.).(.)
14:11:21 <nolrai_East> :t seek
14:11:23 <lambdabot> Not in scope: `seek'
14:11:23 <gwern> is there any better way of removing the first and last item?
14:11:32 <nolrai_East> :t while
14:11:34 <Baughn> kiris: You are correct. Various browsers impose limits, however.
14:11:34 <lambdabot> Not in scope: `while'
14:11:35 <gwern> `and extracting the steaming juicy guts of the list?
14:11:35 <Baughn> Mostly IE
14:11:40 <mauke> :t init . tail
14:11:41 <lambdabot> forall a. [a] -> [a]
14:11:51 <nolrai_East> :t untill
14:11:51 <lambdabot> Not in scope: `untill'
14:11:59 <gwern> > init . tail $ [1..10]
14:12:01 <lambdabot>  [2,3,4,5,6,7,8,9]
14:12:10 <gwern> `hum.
14:12:15 <Dzlk> kiris: it's a SHOULD in the RFC.
14:12:15 <nolrai_East> @hoogle a -> a
14:12:16 <lambdabot> Prelude.id :: a -> a
14:12:16 <lambdabot> Data.Function.id :: a -> a
14:12:16 <lambdabot> GHC.Exts.breakpoint :: a -> a
14:12:29 <vixey> > reverse.tail.reverse.tail$ [1..10]
14:12:30 <kiris> Baughn: ah.
14:12:30 <lambdabot>  [2,3,4,5,6,7,8,9]
14:12:34 <kiris> Dzlk: sure
14:12:55 <nolrai_East> @hoogle (a -> a) -> (a -> Bool) -> a -> a
14:12:55 <lambdabot> Prelude.until :: (a -> Bool) -> (a -> a) -> a -> a
14:13:24 <nolrai_East> why did i think it had 2 'l's?
14:13:31 <hpaste>  laz0r pasted "yampa + glfw + i-dont-know-what-i-am-doing-but-it-works" at http://hpaste.org/8770
14:13:36 <kiris> haha
14:14:01 <Baughn> kiris: http://www.boutell.com/newfaq/misc/urllength.html
14:14:08 <lambdabot> Title: WWW FAQs: What is the maximum length of a URL?
14:14:26 <kiris> Baughn: thanks. quite interesting
14:15:00 <vixey> what should I do with Epigram 1 ?
14:15:46 <Baughn> vixey: Write a haskell compiler!
14:15:59 <Dzlk> servers can limit the length and return 414 (request too long) if they want, the only requirement is that they must be able to handle the URI "of any resource they serve".
14:16:22 <dolio> No, no, write an Epigram 2 compiler.
14:16:24 <Dzlk> I'm not sure what to make of that. It sounds tautological.
14:16:27 <Baughn> Mmh. If they don't handle it, they aren't serving it, so.. -_-;
14:16:35 <dolio> And then port it to Epigram 2.
14:16:54 <vixey> that sounds a bit too hard at this stage..
14:16:59 <dolio> :)
14:17:16 <Baughn> vixey: A hello, world with an integrated mail reader?
14:17:52 <Dzlk> I guess it means don't generate an URI you can't accept in a request, maybe.
14:18:05 <Baughn> That's common sense..
14:18:43 <Dzlk> Sure, but common sense often isn't. :)
14:18:51 <shepheb> @seen edwardk
14:18:51 <lambdabot> I haven't seen edwardk.
14:19:01 <mauke> preflex: seen edwardk
14:19:01 <preflex>  edwardk was last seen on #haskell 3 days, 4 hours, 3 minutes and 15 seconds ago, saying: dmwit: now for your next trick make sure that no two of them will respond to the same message ;)
14:19:16 <kiris> Baughn: I find the limits problem interesting. I was once working with an undocumented protocol and wanted to impose a limit on usernames, seeing as all practical properties implied quite a short limit of, say, 32; similar to IRC. someone disagreed with me with that and on other limiting ideas that I should handle as much data as I could and fallback gracefully. I'd prefer to strictly define limits than be wishy washy about it
14:19:42 <gwern> kiris: not a fan of the 0/1/infinity principle, are you
14:20:05 <kiris> Baughn: (falling back gracefully as in, after allocating 2GB of a username, ignore the message--what's the point...)
14:20:12 <kiris> gwern: what's that?
14:20:46 <gwern> kiris: pretty self-explanatory. things generally should either be forbidden, allowed once, or unrestricted
14:21:14 <gwern> it's a development of the quip that computer scientists only know 3 numbers
14:21:14 <Baughn> kiris: You might set it to something insane like 1MB. Nobody would notice *that* limit, and you wouldn't have a potential memory leak
14:21:15 <kiris> oh I see
14:21:19 <gwern> 0, 1, and the rest
14:21:20 <Baughn> But 32 letters? Someone would run into it
14:21:32 <Baughn> ..in fact, I believe I have family with longer names than that
14:21:34 <gwern> because sooner or later...
14:22:07 <Baughn> (Yeah. Actually just fifteen, but 47 in utf-8)
14:22:15 <gwern> Baughn: sure. I know one fellow who last name was a good 13 or 14 characters, and that wasn't even a very odd dutch name
14:22:16 <esap> gwern: I would disagree with that principle. There are many resource limits where the maximum limit should not be infinite.
14:22:31 <gwern> esap: infinite in the same sense as a turing machine...
14:22:39 <gwern> indefinite isn't as punchy
14:23:06 <kiris> well, in this instance it was like IRC. people use short names and fit into short spaces and are easy to type
14:23:21 <kiris> s/and/that
14:23:50 <Baughn> kiris: You know that eventually someone will use it for p2p networking and want to embed ipv8 addresses in it
14:23:50 <esap> gwern: well I think turing machines don't work well for proving what your program does when you have out-of-memory exceptions :-)
14:24:05 <kiris> Baughn: haha
14:24:21 <Baughn> kiris: I'm not kidding. If not that, then something else equally silly.
14:24:40 <kiris> it's funny because it's true
14:26:22 <nolrai_East> @src (||)
14:26:22 <lambdabot> True  || _ =  True
14:26:22 <lambdabot> False || x =  x
14:27:25 <Baughn> One day, someone will implement an or that checks its right parameter first
14:27:39 <Baughn> And a new generation of space leaks will be born.
14:27:49 <mauke> die "wtf" or open my $fh, ...;
14:27:57 <mauke> someone should make a perl module
14:28:02 <vixey> _ || True = True
14:28:10 <vixey> x || False = x
14:29:49 <vixey> frag is taking forever to downlaod
14:30:11 <kiris> using darcs get?
14:30:11 <dons> it has lots of graphics, vie
14:30:13 <dons> it has lots of graphics, vixey
14:31:41 <fiddlerwoaroof> hello, is there a chennel where people can play with the lambdabot?
14:31:53 <xd_> you can msg it i think
14:31:56 <ziman> you can pm her
14:32:07 <mauke> #haskell-blah?
14:32:25 <vixey> #haskell.jp
14:32:46 <fiddlerwoaroof> thanks
14:33:58 <EvilTerran> Baughn, that wouldn't be compatible with the report, i think
14:34:15 <zachk> > runState (do x<-get; put x^2; return "not-done") 2
14:34:16 <lambdabot>   add an instance declaration for (Num (State s ()))
14:34:17 <EvilTerran> well, if it was still using lazy evaluation
14:34:35 * zachk scratches his head
14:34:51 <Baughn> EvilTerran: Might be using nondeterministic evaluation. That'd be fun.
14:34:56 <EvilTerran> zachk, you've written (put x)+2
14:35:02 <Baughn> Breadth-first evaluation?
14:35:11 <EvilTerran> Baughn, i imagine that particular space leak would be the least of your worries given nondet evaluation
14:35:46 <EvilTerran> if it was semantically nondeterministic, it may as well be semantically strict
14:35:50 <zachk> runState (do x<-get;put (x^2);return "hello") 5
14:35:58 <EvilTerran> >
14:36:20 <Baughn> EvilTerran: It'd still finish programs tthat would be infinite loops under strict evaluation, wouldn't it?
14:36:28 <EvilTerran> well. sometimes.
14:36:39 <zachk> > runState (do x<-get;put (x^2);return "evil") 5
14:36:40 <lambdabot>  ("evil",25)
14:36:40 <Baughn> Oh, fine. Breadth-first evaluation, then. :P
14:36:42 <ddarius> #haskell-overflow would be better or just privmsg the bot
14:37:03 <EvilTerran> Baughn, that sounds potentially interesting, but probably a nightmare in practice
14:38:37 <ddarius> EvilTerran: It wouldn't make any (semantic) difference for Haskell.
14:38:41 <Baughn> EvilTerran: Nondet. evaluation with each reduction chosen from a list of all possible breadth-first choices?
14:39:05 <Baughn> It /might/ make some monte-carlo algorithms simpler
14:39:35 <esap> just have a couple of threads evaluating the reductions, should provide sufficient nondeterminism...
14:39:37 <EvilTerran> ddarius, well, you could use it with lazy semantics, i guess
14:39:50 <EvilTerran> but, if we'r ekeeping lazy semantics, this is all a bit moot anyway
14:39:51 <Baughn> esap: No, I want specifically /randomness/. :D
14:39:58 <zachk> is there a way to mix monads?
14:40:05 <EvilTerran> zachk, monad transformers!
14:40:26 <Baughn> EvilTerran: I suppose threads would help, but threads are to nondet. evaluation as lambda is to lazy evalution
14:40:31 <Baughn> s/evil/esap/
14:40:37 <zachk> cant i just "lift" a function into them?
14:41:28 <EvilTerran> ?type do x <- ask; modify (+x)
14:41:29 <lambdabot> forall (t :: * -> *) s. (MonadState s t, Num s, MonadReader s t) => t ()
14:41:50 <EvilTerran> ?type runState (do x <- ask; modify (+x)) 5
14:41:50 <lambdabot> forall s. (MonadReader s (State s), Num s) => ((), s)
14:41:56 <EvilTerran> er
14:42:00 <vixey> :t lift
14:42:01 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Monad m, MonadTrans t) => m a -> t m a
14:42:05 <EvilTerran> ?type runReader (do x <- ask; modify (+x)) 5
14:42:05 <lambdabot>     No instance for (MonadState r (Reader r))
14:42:05 <lambdabot>       arising from a use of `modify' at <interactive>:1:24-34
14:42:05 <lambdabot>     Possible fix:
14:42:06 <vixey> zachk: yes
14:42:22 <EvilTerran> ... i've forgotten sometihng
14:42:26 <EvilTerran> ?type runReaderT (do x <- ask; modify (+x)) 5
14:42:26 <lambdabot> forall r (m :: * -> *). (MonadState r m, Num r) => m ()
14:42:32 <EvilTerran> ?type runStateT (do x <- ask; modify (+x)) 5
14:42:32 <lambdabot> forall s (m :: * -> *). (MonadReader s m, Num s) => m ((), s)
14:42:37 <EvilTerran> that's what i was after
14:42:43 <zachk> can I "lift" print (from the IO monad) into the State monad?
14:42:53 <EvilTerran> er... print?
14:42:59 <mauke> into StateT IO maybe
14:43:09 <EvilTerran> into?
14:44:22 <Baughn> zachk: What do you want it to do, exactly?
14:44:46 <zachk> I just want to print things in the middle of a State monad
14:45:26 <vixey> yes you can use StateT IO
14:45:48 <zachk> so that is the two monads I need `mixed together?
14:45:59 <vixey> :t print
14:46:00 <lambdabot> forall a. (Show a) => a -> IO ()
14:46:18 <chadz> you need to use monad transformers to layer monads
14:46:31 <chadz> so yes, StateT can layer the IO monad
14:46:42 <kiris> førall a b. StateT a IO b
14:47:25 <Baughn> zachk: If you want to print things as part of your program, you /need/ IO. If you want to do it for debugging purposes, the nondeterministic output of Debug.Trace.trace could prove useful
14:47:46 <zachk> I just want to mix it up
14:48:06 <zachk> but alas my gf is here and we are to go swimming, au revoir
14:48:14 <Baughn> StateT IO works. Though once you have IO, and you know you'll keep IO, and you don't intend to layer yet more monads, so would IORef or whatever
14:49:28 * Baughn implemented IOT yesterday, as a joke. The recipient didn't get it, and wanted a copy.
14:50:56 <sjanssen> how did you manage to write IOT?
14:51:12 <mauke> unsafePerformHax
14:51:27 <Baughn> Quite.
14:51:36 <chadz> what's the general opinion of disciple here?
14:52:11 <Botje> i like disciples but i couldn't eat a whole one :)
14:53:34 <vixey> I doubt everyone has the same opinion on it
14:53:47 <chadz> i thought the effectsystem was pretty cool.
14:57:00 <dons> research is interesting
15:05:24 <vixey> is Compiling Pattern Matching  anywhere other than acm?
15:07:10 <Botje> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.37.8487
15:07:11 <lambdabot> Title: 4 Compiling Pattern Matching by Term Decomposition - CiteSeerX
15:07:11 <Botje> this one?
15:08:06 <vixey> no
15:08:24 <vixey> by Lennart Augustsson
15:08:48 <Botje> could always ask augustss directly :)
15:10:59 <ddarius> Indeed, he'd likely give you a copy if it's not available other than via the ACM
15:11:15 <tusho> so are Zygohistomorphic Prepromorphisms actually real and useful
15:11:40 <ddarius> Yes they are real.  They are probably useful, but one doesn't usually recognize when one is using one.
15:11:50 <ddarius> Yay ambiguous "one"s
15:12:27 <tusho> ddarius: Example? :P
15:12:34 <lament> what's zygo in that context?
15:12:51 <Botje> MOVE ZYGO
15:12:59 <Botje> TAKE OFF EVERY ZYGO FOR GREAT JUSTICE
15:17:57 <schme_> I'm looking at listArray and I can't quite figure out how to create an array. Does anyone have an example?
15:18:35 <vixey> :t listArray
15:18:37 <lambdabot> forall i e. (Ix i) => (i, i) -> [e] -> Array i e
15:18:45 <vixey> > listArray (0,3) "xyz"
15:18:46 <lambdabot>  array (0,3) [(0,'x'),(1,'y'),(2,'z'),(3,Exception: (Array.!): undefined arra...
15:18:49 <dons> > listArray (1,10) [0..9]
15:18:50 <lambdabot>  array (1,10) [(1,0),(2,1),(3,2),(4,3),(5,4),(6,5),(7,6),(8,7),(9,8),(10,9)]
15:19:01 <schme_> I tried listArray [1,10] [1,2,3,4,5,6,7,8,9,0]
15:19:20 <schme_>     Couldn't match expected type `(i, i)' against inferred type `[a]'
15:19:20 <schme_>     In the first argument of `listArray', namely `[1, 10]'
15:19:20 <schme_>     In the expression: listArray [1, 10] [1, 2, 3, 4, ....]
15:19:20 <schme_>     In the definition of `it': it = listArray [1, 10] [1, 2, 3, ....]
15:19:23 <schme_> is what I get.
15:19:33 <Botje> schme_: (1,10)
15:19:34 <schme_> eeh
15:19:38 <schme_> (1,10)
15:19:38 <schme_> yeah
15:19:46 <schme_> listArray (1,5) [1,2,3,4,5]
15:19:51 <schme_>     Ambiguous type variables `t', `a' in the constraint:
15:19:52 <schme_>       `IArray a t'
15:19:52 <schme_>         arising from a use of `listArray' at <interactive>:1:0-26
15:19:52 <schme_>     Probable fix: add a type signature that fixes these type variable(s)
15:19:56 <schme_> that's what I get.
15:20:00 <dons> provide a type annotation
15:20:02 <Botje> schme_: you need to restrict it a bit
15:20:04 <dons> Array Int Int or so
15:20:21 <mauke> schme_: ah, you used the generic IArray version
15:20:42 <schme_> How do I do that?
15:20:53 <schme_> mauke: I think so, yes.
15:21:19 <mauke> which kind of array do you want to construct?
15:21:36 <schme_> An array of 26 pips
15:21:47 <schme_> But integers will work for now.
15:21:48 <schme_> or anything really.
15:21:52 <Botje> > let arr = listArray (1,5) [1,2,3,4,5] in (arr :: Array Int Int) ! 2
15:21:53 <lambdabot>  2
15:21:58 <mauke> there are several array types
15:22:05 <mauke> IArray provides a common interface for them
15:22:09 <vixey> > let arr = listArray (1,5) [1,2,3,4,5] in arr ! 2
15:22:10 <lambdabot>  2
15:22:11 <schme_> I see.
15:22:17 * vixey votes less annotations in haskell code
15:22:31 <mauke> schme_: you could just use Data.Array instead of Data.IArray
15:22:34 <schme_> I just want to use it to store 26 board positions.
15:22:37 * Botje puts annotations at top level
15:22:43 <vixey> why?
15:23:00 <schme_> So I really have no idea which type will be better or worse.
15:23:56 <Botje> schme_: stick with Data.Array, then
15:24:43 <dons> schme_: 26 board positions? how about an IntMap
15:24:46 <schme_> Problem there is that http://www.haskell.org/ghc/docs/latest/html/libraries/array/Data-Array.html gives just about no information.
15:24:48 <lambdabot> Title: Data.Array, http://tinyurl.com/5d8233
15:24:50 <schme_> dons: Huh?
15:24:52 <dons> simple, efficient, purely functional indexable structure
15:25:03 <dons> even Sequence.
15:25:10 <schme_> No idea what an IntMap is.
15:25:11 <mauke> schme_: yeah, that sucks
15:25:14 <dons> otherwise, use Data.Array
15:25:23 <schme_> as long as I can do random access it's all good.
15:25:27 <mauke> http://haskell.org/ghc/docs/latest/html/libraries/containers/Data-IntMap.html
15:25:28 <lambdabot> Title: Data.IntMap, http://tinyurl.com/6nq2ub
15:25:31 <schme_> doing it with lists was just ugly :)
15:25:39 <mauke> now with actual docs!
15:25:53 <dons> IntMap is a fast, flexible balanced tree type.
15:26:05 <dons> Data.Sequence is another choice ("random access" finger trees)
15:26:05 <schme_> I think I looked at that array first and was "what the heck? No docs?" and tried IArray.
15:26:21 <dons> Data.Array is your friend here. listArray and ! to index.
15:26:28 <schme_> Hmm.. right.. I don't quite need trees there :)
15:26:29 <schme_> Yeah.
15:26:45 <schme_> It's to represent the board. It has 26 positions where checkers can go.
15:27:00 <schme_> I'll looksie at Data.Array.
15:27:43 <mauke> Data.Array is good for immutable data
15:27:44 <schme_> Thought intmap looks nice.
15:27:51 <mauke> IntMap is better if you need to change stuff
15:27:58 <schme_> Well I figured I'd create a new array each move.
15:28:01 <dons> IntMap is good if you want a mutable-like structure.
15:28:08 <dons> oh, if you're updating, then use IntMap
15:28:11 <EvilTerran> or just Map
15:28:28 <schme_> Rightie o.
15:28:33 <dons> Array's are read only, essentially, and not as flexible by a long shot as IntMap (or Map)
15:28:33 <ddarius> "A mutable array is good if you want a mutable-like structure," whispers the serpent.
15:29:09 <schme_> Well yeah. I figured as much. It'd be generating new arrays.
15:29:29 <schme_> But IntMap seems much easier.
15:30:09 <kryptiskt> and be exiled from the garden of Haskell to the desert of Java
15:30:45 <schme_> Well I know even less java than I know haskell, so that would be interesting :)
15:31:11 <astrolabe> But doesn't a map (or an IntMap) have more pointers to follow to look something up than an array does?
15:32:49 <schme_> Doesn't really matter for me here. efficiency with the lookup is not important.
15:33:26 <astrolabe> schme_: What game has 26 locations?
15:34:09 <dons> astrolabe: O(log n) == O(1)
15:34:16 <Baughn> astrolabe: Of course. The point of using intmap is that updates are cheaper
15:34:53 <schme_> astrolabe: My bad. 28 actually. :)
15:35:20 <Baughn> dons: Constant factors are higher too. You know this. ;)
15:35:38 <dons> I challenge someone to benchmark Array vs IntMap
15:35:44 <astrolabe> dons: I think that's a bit strong.  I wouldn't want to use a map for my go board.  19^2 would require 9 indirections.
15:36:07 * ziman is writing the benchmark right now, just out of curiosity
15:36:13 <astrolabe> schme_: Alright.  What game has 28 points?
15:36:16 <dons> O(n) updates will kill the arrays though
15:36:40 <Baughn> astrolabe: All right, but how often do you create slightly altered copies of the board?
15:36:50 <dons> astrolabe: I'd imagine IntMap would be just fine for a go board.
15:36:52 <astrolabe> dons: Yeah.  Doesn't mutable array have a faster update?
15:36:53 <kryptiskt> dons: not if you need to keep a copy of the old board around anyway
15:37:01 <dons> astrolabe: well, if you're using mutable arrays, then sure.
15:37:06 <schme_> astrolabe: backgammon.
15:37:16 <dons> kryptiskt: ah, but IntMap still wins
15:37:22 <chadz> use quadtreez
15:37:25 <dons> since you get persistence with O(log n) update
15:37:31 <dons> instead of persistence with O(n) update
15:37:38 <dons> so space and time wins out
15:37:47 <Baughn> kryptiskt: You might want some sharing with that copy
15:37:50 <astrolabe> dons: At the moment, I'm just using Arrays, but if I get to the stage where speed counts, then I was thinking about mutable arrays.
15:37:57 <astrolabe> schme_: thanks.
15:38:00 <dons> if you want to keep history, purely functional structures rock uot
15:38:01 <kryptiskt> dons: oops, yes it does, the copies can share... sisn't think of that
15:38:19 <schme_> astrolabe: 24 + 2xbar + 2xhome . Atleast the way I model it :)
15:38:23 <dons> astrolabe: yeah, STUArrays are identical to C arrays, if you're chasing very fast space/time.
15:38:30 <dons> but of course, O(n) updates and space use
15:38:35 <vixey> trying to compile frag just makes my computer crash :(
15:38:51 <dons> vixey: there's binary pacages for Arch Linux, if that helps
15:39:15 <Baughn> vixey: It.. what?
15:39:29 <dons> kryptiskt: this is why purely functional structures are so cool. persistence, history and undo for free.
15:39:37 <Baughn> vixey: Compiling as root? Or perhaps broken computer?
15:40:04 <kryptiskt> dons: strange that I didn't get that, I was reading okasaki on the bus today :-)
15:40:26 <dons> :)
15:40:40 <dons> he wrote the bible on this :)
15:42:57 <vixey> ghc --make worked fine, but runhaskell Setup.hs build kept crashing
15:43:31 <schme_> Right. I totally don't understand how to use IntMaps. I will have to look at this tomorrow. Thanks though :)
15:43:41 <vixey> the thing still segfaults when you try to launch it though
15:43:41 <Baughn> vixey: Might runhaskell be using something other than ghc?
15:43:46 <vixey> well that sucks
15:43:55 <vixey> no
15:45:09 <Baughn> vixey: And other programs work, like cabal install Monadius?
15:45:22 <vixey> I don't have cabal
15:45:28 <vixey> epigram works
15:46:01 <dons> schme_: just check the api. it's insert/delete/empty
15:46:14 <dons> > I.empty :: I.IntMap Bool
15:46:15 <lambdabot>   Not in scope: type constructor or class `I.IntMap'
15:46:20 <dons> > empty :: IntMap Bool
15:46:20 <lambdabot>   Not in scope: type constructor or class `IntMap'
15:46:29 <dons> > IntMap.empty
15:46:29 <lambdabot>   Not in scope: `IntMap.empty'
15:46:33 <dons> > Data.IntMap.empty
15:46:33 <lambdabot>   Not in scope: `Data.IntMap.empty'
15:46:39 <dons> screw this, i'm going hoome.
15:47:02 <astrolabe> heh
15:47:03 <yitz> > IM.empty
15:47:04 <lambdabot>  fromList []
15:47:14 <glguy> dons: You can't go home, there's work to do!
15:47:27 <dons> IM? wacky.
15:47:28 <astrolabe> Let the poor guy go home!
15:47:34 <schme_> dons: Yes. it is also almost 1 am in the morning.
15:47:35 <schme_> dons: :)
15:47:37 <dons> I thought I'd implemented that as IntMap
15:47:43 <schme_> dons: I'll look at it tomorrow. thanks a bunch.
15:47:52 <yitz> dons: well, M is map, so IM is IntMap, right?
15:47:55 <Baughn> > home
15:47:55 <lambdabot>   Not in scope: `home'
15:48:03 <mauke> @go home
15:48:04 <lambdabot> http://www.homedepot.com/
15:48:08 <yitz> ha
15:48:08 <monochrom> haha
15:48:22 <monochrom> dons wants to hack his home!
15:48:49 <dons> yitz: i'm not sure this encoding system scales
15:49:09 <yitz> dons: he
15:50:17 <Baughn> dons: It's per-package. And once upon a time, long long ago, someone type "module #haskell() where" here.
15:50:30 <Baughn> *per-module
15:54:34 <vixey> you know 'mtl' ?
15:54:45 <vixey> that actually comes with GHC now doesn't it?
15:55:18 <mauke> depends
15:55:34 <Igloo> It's not part of official GHC releases, no
15:56:01 <Igloo> But it may come bundled in installers and binary distributions
15:56:17 <Baughn> Yep
15:56:49 <chadz> i ran lambdabot at work until people started doing pornography lookups with @go :)
15:57:17 <schme_> Right.. arrays seem nicer.
15:57:17 <dons> oops
15:57:32 <mauke> chadz: http://qdb.us/78374
15:57:33 <lambdabot> Title: QDB: Quote #78374
15:57:35 <schme_> (as in easier to use)
15:57:40 <schme_> now I go to bed. night :)
15:58:07 <chadz> mauke: lolz
15:58:22 <noecksit> can u reassign standard functions in lambdabot? is it possible to assign "+" to "-" and so on?
15:58:50 <yitz> @let (-) = (+0
15:58:50 <lambdabot>  Parse error
15:58:54 <yitz> @let (-) = (+)
15:58:54 <lambdabot> Defined.
15:59:00 <mauke> > 2 + 2
15:59:01 <lambdabot>  4
15:59:02 <yitz> > 5 - 2
15:59:03 <lambdabot> Terminated
15:59:07 <mauke> thank you for breaking lambdabot
15:59:20 <yitz> sorry
15:59:26 <noecksit> > 2 - 2
15:59:27 <lambdabot> Terminated
15:59:29 <mauke> @define
15:59:30 <lambdabot> Undefined.
15:59:30 <ziman> why is it broken?
15:59:36 <mauke> > let (-) = (+) in 2 - 3
15:59:37 <lambdabot>  5
15:59:54 <noecksit> thats why i asked first, i didnt want to break it
16:00:02 <noecksit> > 2 - 2
16:00:03 <lambdabot>  0
16:00:05 <mauke> it can be unbroken easily :-)
16:00:16 <yitz> @undef
16:00:16 <noecksit> why, what happened?
16:00:16 <lambdabot> Undefined.
16:00:22 <yitz> > 5 - 2
16:00:23 <lambdabot>  3
16:00:27 <yitz> whew
16:00:31 <ziman> i mean, why did it give the `terminated' error?
16:00:48 <vixey> because lambdabot is ill
16:00:48 <yitz> @botsnack
16:00:48 <lambdabot> :)
16:01:25 <dolio> Someone must come in here periodically and redefine arithmetic operators to nonterminating functions. :)
16:01:42 <noecksit> make a bot that redefines lambdabot
16:02:15 <yitz> dolio: or function composition to abstract nonsense
16:02:44 <vixey> @let f = x
16:02:44 <lambdabot> Defined.
16:02:47 <vixey> > f
16:02:48 <lambdabot> Terminated
16:02:55 <vixey> basically the thing is broken
16:03:01 <vixey> but it kind-of works mostly
16:03:05 <mauke> @undefine
16:03:06 <lambdabot> Undefined.
16:03:06 <vixey> so it remains broken
16:03:06 <povman> Mikael Johansson has kindly let me copy the opengl tutorials to the haskell wiki: http://haskell.org/haskellwiki/OpenGLTutorial1 http://haskell.org/haskellwiki/OpenGLTutorial2
16:03:07 <lambdabot> Title: OpenGLTutorial1 - HaskellWiki
16:03:12 <mauke> > succ . "HAL"
16:03:13 <lambdabot>  "IBM"
16:03:52 <solrize> :t succ
16:03:53 <lambdabot> forall a. (Enum a) => a -> a
16:04:06 <yitz> :t (.)
16:04:06 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:04:13 <yitz> sigh
16:04:17 <solrize> haha
16:04:19 <vixey> yitz: What ?
16:04:26 <solrize> :t (succ .)
16:04:27 <lambdabot> forall a (f :: * -> *). (Functor f, Enum a) => f a -> f a
16:04:46 <solrize> > liftM succ "HAL"
16:04:47 <lambdabot>  "IBM"
16:05:01 <yitz> Cale generalized (.) to fmap, and (++) to mappend.
16:05:20 <dolio> Good.
16:05:21 <vixey> yeah I knew
16:05:23 <Cale> I'm particularly happy with (++) as mappend :)
16:05:35 <mauke> > sortBy (comparing length ++ compare) $ words "so I herd u liek mudkips"
16:05:35 <yitz> hi Cale
16:05:36 <lambdabot>  ["I","u","so","herd","liek","mudkips"]
16:05:46 <ddarius> > getProduct (3 ++ 4)
16:05:47 <lambdabot>   add an instance declaration for (Num (Product a))
16:05:48 <Cale> Haha, mudkips :)
16:06:02 <Cale> > getProduct (Product 3 ++ Product 4)
16:06:03 <lambdabot>  12
16:06:04 <ziman> > (+1) . (Nothing ++ Just 3)
16:06:05 <lambdabot>  Add a type signature
16:06:06 <dolio> Shouldn't there be a 'z' in there?
16:06:09 <mauke> Product needs a Num instance
16:06:13 <ddarius> You'd expect Num instances for Sum and Product.
16:06:14 <vixey> > Nothing ++ Just [3]
16:06:15 <lambdabot>  Just [3]
16:06:18 <mauke> dolio: no
16:06:28 <mauke> mudkips is not gamerspeak
16:06:38 <vixey> how could you have a num instance for product ?
16:06:41 <vixey> I don't think it's possible
16:06:47 <mauke> @src Product
16:06:48 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
16:06:59 <vixey> Product is the actual product, not a list of factors isn't it?
16:07:14 <ddarius> vixey: Product is just a newtype around an Num
16:07:22 <Cale> vixey: It's a tag which selects the multiplicative monoid.
16:07:29 <ddarius> :t Product
16:07:30 <lambdabot> forall a. a -> Product a
16:08:02 <tusho> loeb
16:08:07 <vixey> if you had a num instance for Product what about Product 2 + Product 3 ?
16:08:12 <vixey> you couldn't calculate it
16:08:15 <mauke> vixey: Product 5
16:08:39 <vixey> why 5 and not 8 ?
16:08:45 <mauke> because + adds numbers
16:08:55 <dolio> Where would 8 come from?
16:08:58 <mauke> lern2arithmetic
16:09:18 <vixey> Product 2 means that the product of some numbers is two
16:09:21 <tusho> mauke: 'because + adds numbers' what
16:09:22 <tusho> :O
16:09:23 <vixey> it doesn't tell you what numbers
16:09:23 <dolio> Product a + Product b = Product (a^b)?
16:09:29 <vixey> you can't add numbers if you don't know them
16:09:32 <ddarius> vixey: That's not what it means.
16:09:34 <mauke> vixey: no, it doesn't
16:09:54 <vixey> oh I understand
16:10:55 <tusho> adding numbers ... zylographic hylomorphisisms...
16:10:57 <tusho> amazing stuff
16:11:06 <chadz> i hate math terms
16:11:29 <ddarius> chadz: "Product", "add" ?
16:11:32 <mauke> http://dis.4chan.org/read/prog/1215333169/1-40
16:11:33 <lambdabot> Title: 4chan BBS - ^^
16:11:36 <dolio> Product at least having a FromInteger instance would be nice.
16:11:38 <dobblego> ?type traverse
16:11:39 <lambdabot> Not in scope: `traverse'
16:11:45 <dolio> But it's not that split up.
16:11:46 <dobblego> ?type Data.Traversable.traverse
16:11:47 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Applicative f, Data.Traversable.Traversable t) => (a -> f b) -> t a -> f (t b)
16:12:37 <Cale> Ah, 4chan, the pinnacle of programming talent.
16:12:53 <chadz> ddarius: sure. those and anything that ends in orphism
16:13:01 <chadz> 'cept catamorphism, as those make for lol pics
16:13:09 <dolio> So, one if expression is sugar for another if expression in Python? How progressive.
16:13:54 <tusho> dolio: We should have RECURSIVE SUGAR.
16:13:56 <ddarius> chadz: No one has mentioned any (real) math term that ends in "orphism"
16:14:01 <tusho> LAZY recursive sugar. :3
16:14:08 <ddarius> catamorphism is also not a math term
16:14:37 <chadz> someone's getting defensive
16:14:53 <tusho> Someone's getting BOOOP
16:14:57 <chadz> :)
16:14:59 <dobblego> someone is putting forward an argument that refutes your claim
16:15:00 <dolio> Careful, you'll upset the computer scientists who think they're mathematicians here.
16:15:52 <roconnor> *L*
16:15:55 <roconnor> "Is the Haskell Wiki being trolled?
16:15:59 <roconnor> "They are trolling themselves.
16:16:07 <roconnor> :D
16:16:35 <tusho> roconnor: It's true!
16:16:40 <dolio> ddarius: I've been meaning to ask, and you seem like you'd know: do existential datatypes ala Haskell lead to an inconsistent type theory, due to being impredicative?
16:16:50 <tusho> roconnor: heh:
16:16:58 <tusho> "Would it be possible to write a program that trolled itself in Haskell?" "The answer is: Yes! Haskell can do that."
16:17:02 <roconnor> I'm so going to find a place to use Zygohistomorphic_prepromorphisms once edwardk describes what they are in his encyclopidia of morphisms
16:17:13 <sioraiocht_> zygo?!
16:17:31 <dolio> Or, ala GHC, I suppose.
16:17:48 <tusho> IO is a zygohistomorphic prepromorphism.
16:17:49 <tusho> I bet it.
16:17:53 <jsnx> i see no reason why they must have greek names
16:18:16 <jsnx> it just adds to the weirdness
16:18:22 <vixey> would you name them after species of birds?
16:18:38 <jsnx> vixey: that's an okay idea
16:18:57 <jsnx> but, given what they're doing, it might make more sense to study knot tying
16:18:59 <vixey> almost 1/4 of the gtk2hs examples worked for me
16:19:07 <jsnx> and then name it after various knots
16:19:07 <vixey> this is much better than expected
16:20:24 <roconnor> sioraiocht_: Zygo implements semi-mutual recursion ... aparently
16:20:45 <sioraiocht_> the professors here hate the "greek prefix" system to all thise morphisms
16:20:57 <sioraiocht_> i brought up hylomorphism once and it upset my supervisor a lot =p
16:21:18 <sioraiocht_> and he has quite a rant about how a fold is a damn fold, that's what everyone knows it as, and "catamorphism' is dumb
16:21:26 <sioraiocht_> ditto for anamorphism for unfolds, heh
16:21:59 <roconnor> wow
16:22:05 <roconnor> anger managment issues
16:22:10 <sioraiocht_> well
16:22:12 <sioraiocht_> i see his point
16:22:12 <sioraiocht_> hehe
16:22:22 <sioraiocht_> i would never call a fold a catamorphism =p
16:22:33 <vixey> I would never call a catamorphism a fold
16:22:36 <roconnor> ... I have in my paper
16:22:43 <lxuser> sioraiocht_, a catamorphism is more general than fold.
16:22:48 <lxuser> fold only applies to lists
16:23:01 <dobblego> many people use "fold" to apply to more than lists
16:23:04 <sioraiocht_> yeah
16:23:10 <sioraiocht_> i've seen folds apply to trees
16:23:13 <tusho> yeah why does fold have to be lists only..
16:23:17 <dobblego> it doesn't
16:23:25 <tusho> exactly
16:23:29 <dobblego> http://www.scala-lang.org/docu/files/api/scala/Either.html#fold((A)%3D%3EX%2C(B)%3D%3EX)
16:23:31 <lambdabot> Title: class Either in scala, http://tinyurl.com/5ozs3k
16:23:44 <dobblego> ?type either
16:23:45 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
16:23:50 <tusho> Eep. Scala. :)
16:23:55 * sioraiocht_ hates Scala.
16:23:57 <roconnor> "The inductive type for step functions has an associated catamorphism[2] which we call fold:
16:24:10 <tusho> sioraioc_: Why hate?
16:24:13 <vixey> yeah what's the point in scala ?
16:24:41 <dobblego> only that I personally had called a catamorphism a fold that wasn't for list (I wrote scala.Either)
16:24:41 <sioraiocht_> tusho: I've just had to use it, the type inferer drove me nuts, I found it's syntax hideous *shrugs* it's a solid language, but I don't have to like it personally, hehehe
16:25:35 <lxuser> some people call fold "accumulate" or "reduce"
16:25:48 <dolio> Or inject.
16:26:09 <roconnor> these 4chan comments are might actually be better than reddit comments.
16:26:30 <ddarius> dolio: Why do you say existentials in GHC Haskell are impredicative (or do you mean with the recent "extension"?)
16:27:18 <ddarius> sioraiocht_: What did he call a hylomorphism?
16:27:50 <tusho> roconnor: you know, you're right
16:27:52 <roconnor> reunfold?
16:27:52 <dolio> ddarius: Well, I was trying to get the same thing in agda, and 'data Existential : Set where exists : {s : Set} -> ...' fails. It needs to be 'Existential : Set1'.
16:27:53 <tusho> that's scary
16:27:59 <sioraiocht_> ddarius: I did.  in discussing deforestation
16:28:13 <tusho> roconnor: still, reddit does now consist of 4chan rejects
16:28:18 <tusho> so it's not that surprising
16:28:21 <ddarius> sioraiocht_: My question was "what is his name for that pattern?"
16:28:25 <sioraiocht_> ohhh
16:28:32 <roconnor> tusho: oh, is that what happend.
16:28:38 <tusho> roconnor: pretty sure, yes
16:28:39 <dolio> ddarius: So, I sort of assumed it was impredicative in GHC, since to get the same behavior you need the Set : Set option.
16:28:54 <sioraiocht_> he didn't really have one, he just said in my dissertation to always call it fusion, as my dissertation is using it in that context
16:28:57 <tusho> it would explain things
16:30:09 <dolio> I'll admit I'm a bit hazy on what all qualifies as impredicative.
16:30:23 <vixey> a set quantifying over itsself
16:30:36 <vixey> Prop in Coq is impredicative,
16:31:01 <vixey> forall x : Prop, x : Prop
16:31:11 <ddarius> dolio: Impredicativity in Haskell means being able to instantiate a quantified type variable and a polymorphic type.
16:31:24 <roconnor> I've never used Prop impredicativity.
16:31:43 <vixey> yes you have :P
16:31:49 <dolio> Well, yes, I know that bit. I meant as the word is used more generally.
16:31:49 <roconnor> I've seen it used once in a paper, but it's use could be removed.
16:31:52 <vixey> Inductive and (A B : Prop) : Prop :=  conj : A -> B -> A /\ B
16:31:57 <ddarius> roconnor: Well Thierry Coquand says Prop is impredicative so it probably is.
16:32:11 <roconnor> ddarius: oh it is impredicative, I just don't think it is useful.
16:32:21 <roconnor> vixey: that isn't an instance of impredicativity.
16:32:28 <vixey> ok
16:32:51 <roconnor> vixey: it's exactly the same as product types which are fine in Set/Type.
16:34:00 <ddarius> dolio: Since you can't instantiate a quantified type variable to a higher-rank type you essentially have that stratification.
16:36:04 <dolio> ddarius: Right, and that's necessary to prevent paradoxes, right?
16:37:45 <dolio> So a type system that allowed 'data Exists : Set = exists e. E ...' would be inconsistent.
16:37:56 <dolio> e : Set.
16:38:29 <lxuser> so what are you supposed to call hylomorphisms and metamorphisms? refold / reunfold ?
16:38:46 <ddarius> I believe you could make a paradox, but I'd have to work out the details.  You could try to construct one given that assumption.
16:38:50 <idnar> dereunfold
16:38:57 <dolio> That's what the original category-extras called them (the former, that is, it didn't have metamorphisms).
16:40:30 <ddarius> Clearly a "metamorphism" should be called "crease"
16:41:31 <jsnx> to have a really pure haskell style, we should call them >#%#@<, {$$%{{}}}}, &c.
16:41:59 <vixey> most names in haskell aren't operators
16:42:18 <jsnx> i am only teasing, i'm sorry if it wasn't funny
16:42:43 <EvilTerran> the second one isn't a valid operator name anyway
16:43:14 <jsnx> what about |}}}}{{{{| ?
16:43:26 <ddarius> Neither { nor } are valid operator characters
16:43:32 <jsnx> :(
16:43:34 <ddarius> jsnx: You've clearly never seen APL or J
16:43:42 <jsnx> hehe
16:43:48 <jsnx> i've never used them
16:43:53 <jsnx> but sure, i've seen them
16:44:12 <ddarius> Learn J, it's fun.
16:44:30 <jsnx> the interpreter is expensive, i thought
16:44:33 <jsnx> or is that K ?
16:44:41 <ddarius> That's K, though it has free versions as well.
16:50:17 <noecksit> @hoogle STM
16:50:17 <lambdabot> Control.Monad.STM :: module
16:50:17 <lambdabot> Control.Concurrent.STM :: module
16:50:17 <lambdabot> GHC.Conc.STM :: data STM a
16:52:47 <dmwit> Clearly a metamorphism should be called "roachify".
16:52:51 <yitz> to keep up with latest fashion, we should rename Haskell to H.
16:53:08 <mauke> /h/
16:53:16 <lament> H'
16:53:31 <mauke> H♯
16:53:33 <tusho> yitz: no, 'h' - uppercase is so old
16:53:37 <tusho> unfortunately, 'h' is kinda ugly
16:53:41 <vixey> that's what I was thinking about earlier http://www.labri.fr/perso/casteran/CoqArt/depprod/impred.html
16:53:43 <lambdabot> Title: Some impredicative definitions
16:53:43 <tusho> so 's'
16:53:51 <tusho> s hello.s -o hello
16:53:57 <tusho> http://s.org/
16:54:12 <yitz> ה
16:54:22 <jre2> anyone know how to get a large amount of spam (for playing with bayesian filters in haskell)
16:54:36 <Draconx> jre2, sign up for porn sites?
16:54:45 <mauke> tusho: .s is assembler code
16:54:53 <tusho> mauke: Shut up.
16:54:53 <tusho> :)
16:55:06 <tusho> ה is good though.
16:55:14 <tusho> ה hello.ה -o hello
16:55:20 <tusho> http://ה.org/
16:55:46 <mauke> can't type that
16:55:52 <tusho> mauke: copy and pasta, my friend
16:55:54 <dmwit> jre2:
16:55:55 <chadz> i say we need a mascot
16:55:58 <dmwit> ?google corpus spam
16:55:59 <lambdabot> http://plg.uwaterloo.ca/~gvcormac/treccorpus/
16:56:03 <chadz> a haskellisk or something
16:56:06 <jre2> Draconx: I was hoping someone here might have a large collection already (perhaps for a similiar purpose). Besides, that's a lot of manual effort
16:56:13 <dmwit> chadz: We have a dragon-thing.
16:56:13 <mauke> haskell the hedgehog
16:56:17 <tusho> mauke++
16:56:20 <chadz> dmwit: link?
16:56:22 <tusho> hedgehog would be win
16:56:27 <dmwit> chadz: hum...
16:56:33 <jre2> dmwit: cool
16:56:37 <yitz> don't we already have the lambda cats?
16:56:46 <dmwit> chadz: give me a sec
16:56:54 <chadz> haskell dragon doens't look very promising on the search
16:57:17 <jre2> dons has that bug thing
16:57:22 <dons> yeah
16:57:28 <dons> beetle, thank you.
16:57:37 <dmwit> chadz: Oh, it's not a Haskell logo, it's a GHC logo.
16:57:40 <chadz> lambda potato is winner imo
16:57:41 <dmwit> http://www.cse.unsw.edu.au/~dons/images/happy-dino.jpg
16:57:46 <chadz> but, i dont think a potato can be a mascot
16:57:53 <jre2> dons: still derives Bug
16:57:56 <dons> http://ecx.images-amazon.com/images/I/41LzlJntlZL._SS500_.jpg
16:58:04 <chadz> dmwit: that thing's ghetto
16:58:30 <dmwit> Is that a poo bug?!
16:59:05 <dons> jre2: Hemiptera don't derive Coleoptera
16:59:25 <chadz> what's the beetle got to do with haskell?
16:59:33 <dmwit> http://haskell.org/haskellwiki/Haskell_logos
16:59:34 <lambdabot> Title: Haskell logos - HaskellWiki
16:59:34 <dons> they both subclass Insecta though
16:59:45 <chadz> i've never understood how they pick their animals, dons -- any idea?
16:59:47 <dons> chadz: strongest animal for its size.
17:00:01 <dolio> What do any O'Reilly covers have to do with the language?
17:00:28 <dons> they have a dedicated graphic designer who picks them based on the blurb about the book, afaik.
17:00:58 <tusho> dons: awesome
17:01:00 <dolio> You mean they have an actual methodology?
17:01:17 <jre2> dons: That you know that either represents a creepy knowledge of insects or an amazing speed with wikipedia...
17:01:19 <dons> well, there's some reason in the madness
17:01:23 <monochrom> I wonder if they will pick Homo Sapiens for the haskell book.
17:02:07 <yitz> elephant, because Haskell has been called the "elephant in the room".
17:02:12 <dmwit> jre2: Either that, or he's writing the book, and asked why they chose that logo. ;-)
17:02:23 <chadz> yitz: oh, i agree
17:02:27 <chadz> that could be a sweet icon too
17:02:30 <lament> monochrom: preferrably somebody like angelina jolie, naked, on the cover
17:02:32 <chadz> some sort of boxed elephant
17:02:34 <dons> jre2: i lived on a farm in the australian bush, and used to be obsessed with insects for a couple of years around 8-9 years old
17:02:53 <monochrom> <3 Angelina Jolie
17:02:53 <lament> as a sample homo sapiens
17:02:57 <ahunter>  Can we not just use one of the better lambdacats?
17:03:27 <monochrom> "trapped in the IO monad"
17:03:50 <jre2> http://arcanux.org/lambdacats/dumb.jpg
17:04:07 <Pseudonym> The lesser known R. Kelly opera.
17:04:15 <dons> heh
17:04:28 <ahunter> How do we store a quote. anyway? that was awesome
17:04:38 <tusho> the haskell logo should be ITSELF
17:04:39 <dons> huh, amazon recommend's Neal Stephenson + RWH
17:04:42 <tusho> logo Haskell = logo Haskell
17:04:45 <dmwit> ahunter: ?remember nick quote
17:04:58 <dmwit> dons: EXCELLENT
17:05:03 <tusho> :D
17:05:08 <dmwit> amazon++
17:05:26 <dons> yeah, weird.
17:05:55 <dons> haskell: the language of oru post cyberpunk future
17:06:07 <monochrom> Remember to remove <>s.  E.g., wrong: ?remember <monochrom> haha
17:06:40 <dmwit> right: ?remember monochrom tee-hee! I'm a teapot! *giggle*
17:07:00 <monochrom> But I'm really a teapot.
17:07:06 <yitz> monochrom: we should teach lambdabot to accept it either way
17:07:24 <vixey> couldn't the loyal lambda powered robot do that ?
17:07:57 <ahunter> ?remember Pseudonym [<monochrom> "trapped in the IO monad"] The lesser known R. Kelly opera
17:07:57 <lambdabot> I will never forget.
17:08:36 <yitz> @quote Pseudonym
17:08:36 <lambdabot> Pseudonym says: Smart programmers naturally write monadic code, even if they don't realise it.
17:08:50 <lament> @quote smart
17:08:51 <lambdabot> Pseudonym says: Smart programmers naturally write monadic code, even if they don't realise it.
17:09:08 <yitz> @quote Kelly
17:09:08 <lambdabot> Pseudonym says: [<monochrom> "trapped in the IO monad"] The lesser known R. Kelly opera
17:09:14 <chadz> @quote lol
17:09:14 <lambdabot> qwe1234 says: lol, thanks for the pointless offtopic post
17:09:27 <mauke> preflex: quote
17:09:27 <preflex>  <ik> Watch your attitude, I might get myself banned again..
17:09:27 <dmwit> ?protontorpedo
17:09:28 <lambdabot> Im really only a bash person and even then Im tin
17:11:20 <yitz> preflex: help
17:11:20 <preflex>  try 'help help' or see 'list' for available commands
17:11:28 <yitz> preflex: list
17:11:28 <preflex>  Cdecl: [cdecl]; Factoid: [+, -, ., ?, delete, get, store]; Help: [help, list]; Karma: [++, --, karma]; Nickometer: [nickometer]; Seen: [seen]; Quote: [be, quote, remember]; WCalc: [calc, wcalc]; Version: [version]; ZCode: [zdec, zenc]
17:11:55 <ahunter> Erm, what's preflex?  Someone's \bot replacement?
17:12:08 <lament> i think it's mostly here for nickometer
17:12:08 <dmwit> mauke's, yes
17:12:56 <dmwit> It's nice that preflex's "seen" works, too.
17:13:07 <dmwit> Though I guess that's fixed now.
17:13:34 <kryptiskt> preflex: nickometer
17:13:35 <preflex>  kryptiskt is 0% lame
17:14:04 <yitz> preflex help calc
17:14:04 <preflex>  calc - evaluate arithmetic expressions
17:14:32 <yitz> preflex help cdecl
17:14:32 <preflex>  cdecl DECLARATION - explain a C declaration
17:14:57 <yitz> preflex calc "foo"
17:14:57 <preflex>  Lexical error
17:15:15 <yitz> preflex help wcalc
17:15:15 <preflex>  wcalc: alias of calc
17:15:22 <dmwit> ?where preflex
17:15:23 <lambdabot> I know nothing about preflex.
17:15:31 <yitz> preflex help zdec
17:15:31 <preflex>  zdec TEXT - z-decode some text
17:15:43 <yitz> preflex zenc foo
17:15:43 <preflex>  foo
17:15:48 <dmwit> preflex: zenc containers-1.0.0.1
17:15:48 <preflex>  containerszm1zi0zi0zi1
17:16:06 <yitz> preflex zenc z
17:16:07 <preflex>  zz
17:18:49 <noecksit> hello, im trying to do something awkward with monads and pure functions, and i want the else of an if statement to bind a couple pure functions that depend on "a <- m a" statement, im not sure how to do that
17:19:32 <dmwit> if False then undefined else do { a <- m; {- use a here -}; return () }
17:20:03 <dmwit> There's nothing special about the "else" clause of an if statement.
17:20:05 <dons> just hang a 'do' off the branches
17:20:14 <dons> if .. then do ... ; else do .. ; return ()
17:20:22 <byorgey> you do have to be careful about indentation, though
17:20:28 <dmwit> yeah
17:20:31 <noecksit> i tried to write "else do a <- m a; let maybeA = func a in case maybeA of Nothing -> smthing; Just a -> smthing else" but it doesnt work
17:20:55 <dmwit> Are smthing and smthing else monadic values?
17:20:55 <byorgey> noecksit: can you paste your code on hpaste.org?
17:21:19 <byorgey> also the a <- m a looks weird.  is that really what you wrote, or that's just the types?
17:21:21 <dmwit> (And is the "then" branch a compatible monadic value type?)
17:21:24 <yitz> preflex zenc one two
17:21:24 <preflex>  onez20Utwo
17:21:50 <noecksit> dmwit : yes it returns IO a
17:22:01 <dmwit> ?hpaste
17:22:01 <lambdabot> Haskell pastebin: http://hpaste.org/new
17:22:10 <noecksit> ill hpaste in one sec
17:22:39 <mauke> preflex: zdec zgz20U2zp2
17:22:39 <preflex>  > 2+2
17:23:13 <dmwit> preflex: zdec dmwitzpzp
17:23:13 <preflex>  dmwit++
17:23:17 <dmwit> Excellent.
17:24:10 * dmwit considers...
17:24:22 <dmwit> http://www.google.com
17:24:22 <lambdabot> Title: Google
17:24:31 <dmwit> Now, if only preflex' name were Title. ;-)
17:24:34 <hpaste>  noecksit pasted "let binding" at http://hpaste.org/8771
17:25:04 <yitz> preflex zenc http://www.google.com
17:25:04 <preflex>  httpZCzszswwwzigooglezicom
17:25:04 <lambdabot> Title: Google
17:25:21 <yitz> preflex zdec httpZCzszswwwzigooglezicom
17:25:21 <preflex>  http://www.google.com
17:25:21 <lambdabot> Title: Google
17:25:39 <dmwit> augh, literal tabs
17:25:43 <dmwit> noecksit: What error do you get?
17:25:51 * dmwit guesses it's indentation somehow
17:26:42 <noecksit> dmwit: "The last statement in a 'do' construct must be an expression
17:27:24 <dmwit> noecksit: You're mixing tabs and spaces in a fatal way.
17:27:34 <noecksit> i am using a let after the arrow for the monad, and the let bindings depend on s as well as the case statement
17:28:08 <dmwit> noecksit: Either convert your tabs to spaces, or learn what tabs really mean in the GHC lexer.
17:28:10 <noecksit> dmwit : oh really? i never thought that mattered i just make as much space as necessary in vim
17:28:25 <byorgey> vim should be able to convert tabs to spaces, no?
17:28:31 <dmwit> :retab
17:28:38 <byorgey> if not I will ridicule vim users
17:28:41 <dmwit> Make sure to :set expandtab first.
17:28:48 <byorgey> ah, good =)
17:28:51 <monochrom> vim is also able to let you fudge the semantics of tabs to non-standard ones.
17:28:59 <dmwit> yes =/
17:29:14 <fiddlerwoaroof> hello, what is InF here? http://comonad.com/reader/2008/anamorphism/
17:29:17 <lambdabot> Title: The Comonad.Reader  Anamorphism
17:29:26 <monochrom> OTOH, humans are unable to resist the temptation to abuse that fudge ability.
17:29:34 <byorgey> @src Mu
17:29:34 <lambdabot> Source not found. Maybe if you used more than just two fingers...
17:29:45 <shepheb> fiddlerwoaroof: see the main page of the Field Guide, it has a bit of groundwork
17:30:15 <byorgey> hm, I thought \bot had Mu now?
17:30:15 <noecksit> dmwit : is that supposed to fix my code or am i supposed to rewrite the code with the commands set?
17:30:19 <byorgey> @src Fix
17:30:19 <lambdabot> Source not found. You speak an infinite deal of nothing
17:30:23 * monochrom waits for some troll to post to the ghc mailing list: "every editor allows me to fudge the meaning of tabs. how do I get ghc to do the same?"
17:30:32 <noecksit> and what exactly does ghc do when it encounters tabs btw?
17:30:32 <Saizan_> byorgey: it has Mu but not in @src
17:30:39 <byorgey> ah, that's a shame
17:30:42 <dmwit> noecksit: If you ":set noet" then "retab", it should fix the code.  Though there may be other errors.
17:30:55 <mauke> noet‽
17:31:00 <Saizan_> fiddlerwoaroof: mewtype Fix f = InF { outF :: f (Fix f) }
17:31:08 <dmwit> mauke: It's short for "noexpandtab", which I mentioned above.
17:31:09 <Cale> fiddlerwoaroof: I suspect the answer can be found in Edward Kmett's category-extras library.
17:31:26 <mauke> I want et
17:31:33 <dmwit> mauke: Oh, right.
17:31:34 <roconnor> awwww mewtype.  We need a new lambdacat.
17:31:47 <dmwit> noecksit: As mauke said, ":set et", not ":set noet".
17:31:52 <Saizan_> :D
17:32:14 <Cale> Ah, InF is the constructor for FixF which is the standard construction for the fixed point of a functor
17:32:28 <noecksit> dmwit : well, i still get the same error and i tried it 3 times
17:32:29 <Cale> newtype FixF f = InF { outF :: f (FixF f) }
17:32:31 <shepheb> fiddlerwoaroof: http://comonad.com/reader/2008/recursion-schemes/  bottom of that page
17:32:33 <lambdabot> Title: The Comonad.Reader  Recursion Schemes: A Field Guide
17:32:38 <Cale> http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Functor-Fix.html#t%3AFixF
17:32:41 <lambdabot> Title: Control.Functor.Fix, http://tinyurl.com/6pes6j
17:32:53 <noecksit> in case u ask, i did use ":set et"
17:32:56 <dmwit> noecksit: Okay, will you repaste, along with the full error?  Sorry for the wild goose chase.
17:33:40 <noecksit> dmwit : do u want me to paste the whole file of source code? most of it shouldnt be relevant
17:33:42 <dmwit> (In answer to your previous question: I remember reading somewhere that GHC treats \t as 8 spaces... i.e. not as a motion to the next 8-space tabstop.)
17:34:03 <fiddlerwoaroof> thanks, it looks like I'm probably in over my head
17:34:06 <dmwit> noecksit: That's alright, just as much as you pasted last time should be fine.
17:34:41 <byorgey> fiddlerwoaroof: that's ok, we provide oxygen masks free of charge
17:35:14 <byorgey> noecksit: hm, maybe it's because Just (color,move) is indented less than the 'case'?
17:35:31 <byorgey> noecksit: by the way, you can use 'let' without 'in' in a do-block
17:35:45 <fiddlerwoaroof> I'm trying to get used to Haskell coming from python, etc and have just recently become comfortable with the idea of a monad and am now looking for some practical application of haskell
17:35:47 <monochrom> http://www.haskell.org/onlinereport/syntax-iso.html#layout
17:35:47 <lambdabot> Title: Haskell 98 Syntax
17:36:04 <hpaste>  (anonymous) annotated "let binding" with "(no title)" at http://hpaste.org/8771#a1
17:36:12 <monochrom> See the official words on tabs.
17:36:18 <yitz> fiddlerwoaroof: what would you like Haskell to be able to do?
17:36:21 <dmwit> Yep, the Report says tabstops.
17:36:24 <byorgey> fiddlerwoaroof: you mean you'd like a practical application for which you can use haskell? or you would like examples of practical applications of haskell?
17:36:28 <dmwit> Just found that section myself. =)
17:36:29 <fiddlerwoaroof> both
17:36:35 <hpaste>  (anonymous) annotated "let binding" with "(no title)" at http://hpaste.org/8771#a2
17:36:55 <fiddlerwoaroof> byorgey: the first one mainly, especially where it makes my life easier
17:37:26 <dons> fiddlerwoaroof: open source programs?
17:37:30 <yitz> fiddlerwoaroof: you can start by solving some project euler problems
17:37:32 <byorgey> fiddlerwoaroof: well, let's see.  for some high-profile 'real-world' uses of haskell, check out darcs, xmonad, happs
17:37:46 <byorgey> fiddlerwoaroof: well, what kinds of problems do you normally have to solve?
17:37:47 <fiddlerwoaroof> I've used the first two
17:37:55 <noecksit> byorgey : i tried shifting the Just and Nothing to the case but i still get the error...
17:38:00 <dons> you can see a set of haskell programs available for linux here, http://aur.archlinux.org/packages.php?SeB=m&K=arch-haskell
17:38:00 <lambdabot> Title: AUR (en) - Search: arch-haskell
17:38:07 <byorgey> @faq can haskell make my life easier?
17:38:08 <lambdabot> The answer is: Yes! Haskell can do that.
17:38:12 <monochrom> I find that ghc 6.8.2 also uses tabstops.
17:38:14 <dons> there's oh, 350 libs and 60 odd applications to browse.
17:38:36 <dons> fiddlerwoaroof: but in general, if you can do it in python, you can certainly do it in haskell. there's no limitation to what you do with the language.
17:38:40 <dons> just build whatever you're into.
17:38:54 <dmwit> noecksit: delete the "in" before "case"
17:39:03 <Apocalisp> @faq does Haskell have type-safe remote function calls?
17:39:03 <lambdabot> The answer is: Yes! Haskell can do that.
17:39:09 <fiddlerwoaroof> dons: the main problem for me is still the paradigm shift
17:39:12 <dons> though if say, python's bias is towards scripting, haskell's is towards translation and data manipulation
17:39:13 <dmwit> noecksit: (Or indent it differently from the "let" it corresponds to.)
17:39:32 <fiddlerwoaroof> but I love Algebraic data types and patternmatching
17:39:33 <byorgey> fiddlerwoaroof: yeah, that just takes time.  just pick an interesting project and start coding.  and ask lots of questions in here.
17:39:58 <shepheb> @quote day
17:39:58 <yitz> dons: once dynamic plugins gets easier, scripting will get easier.
17:39:59 <lambdabot> foot says: On a warm Saturday afternoon, sitting by the pool with a margarita, you casually sit up from your chaise lounge chair, reach over and pick up a gun, aim at your foot, and lazily pull the
17:39:59 <lambdabot> trigger.
17:40:02 <dons> yeah, that's a big shift from python. data structures are a first class langauge feature.
17:40:31 <dons> yitz: shrug, i don't think we need plugings for scripting. most of my scripts are just unix + parsing libs thrown together.
17:40:37 <noecksit> dmwit : oh yea, getting rid of the "in" seemed to get rid of the error
17:40:48 <byorgey> fiddlerwoaroof: if you like the idea of contributing some code to a project rather than coding your own from scratch, there are also lots of places to get involved
17:40:51 <shepheb> byorgey: hmm, I thought there was a quote about "Haskell day", the day when it all makes sense. and when you suddenly hate all other languages.
17:41:06 <dmwit> ?quote Haskell.*day
17:41:06 <lambdabot> sorear says: Haskell is amazing. I'm still working on my infinite-types unifier, and in a day I've added sums, products, and lambda abstractions, refactored the code until there was a net *decrease*
17:41:06 <lambdabot> in LOC, and helped man #haskell all at the same time. This'd take me a week in C, no doubt.
17:41:17 <yitz> dons: well for that stuff, yeah, but in general you need dynamic compilation
17:41:27 <byorgey> ?quote haskell.day
17:41:27 <lambdabot> No quotes match. I've seen penguins that can type better than that.
17:41:31 <byorgey> ?quote Haskell.day
17:41:31 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
17:41:34 <mauke> @quote unlearn
17:41:34 <lambdabot> DukeDave says: Haskell has the greatest unlearning curve
17:41:35 <noecksit> i guess the moral of the story is you shouldnt use let in when using monads
17:41:38 <yitz> e.g., as a couchDB view engine
17:41:43 <dmwit> ?quote Unlearn
17:41:43 <lambdabot> DukeDave says: Haskell has the greatest unlearning curve
17:41:51 <dmwit> Oh, good, it's insensitive.
17:41:58 <byorgey> shepheb: I've never heard that quote, but it sounds good.  why don't you just make it up, and I'll ?remember you? =)
17:42:09 <byorgey> dmwit: yeah, I wondered about that
17:42:19 <shepheb> byorgey: we were talking about it a while back, I guess neither of us quoted it.
17:42:23 <shepheb> <byorgey> and after that, everything changed
17:42:26 <shepheb> <shepheb> I can't even really comprehend the difference. I find it almost hard to believe that I was a _good_ programmer before. I understood so little.
17:42:29 <shepheb> <byorgey> hehe, I know exactly what you mean!
17:42:32 <fiddlerwoaroof> here is something I wrote recently, but it seems like I'm working to hard to get it to do what it does: http://pastebin.com/m1bb2aa4b
17:42:35 <shepheb> found it in my "misc_notes" file
17:42:44 <byorgey> shepheb: ah, yeah, I remember that now =)
17:43:09 <Armored_Azrael> Hey, does anyone know any way that I could load modules on the fly?
17:43:33 <dmwit> Armored_Azrael: It's not pretty, try not to go down that road.
17:43:33 <Armored_Azrael> i.e. Have a running program take a compiled haskell object file and load it, and be able to access its functions somehow?
17:43:34 <jfredett> hey paul.
17:43:36 <shepheb> fiddlerwoaroof: another quote: <John Meacham> I liken learning Haskell to tipping over a vending machine. You can't just push it, you gotta rock it back and forth a few times building up momentum until bam! suddenly the flash of insight hits and it all makes sense.
17:43:56 <Giblaz> sup joe
17:44:07 <fiddlerwoaroof> shepheb yeah I think i understand that
17:44:14 <Armored_Azrael> dmwit: How else can you share process specific data between a potentially arbitrary other haskell program (in this case I'm trying to pass off a GL context)
17:44:22 <byorgey> fiddlerwoaroof: well, let's see.  your 'helper' function in fmtFields should be a map
17:44:41 <shepheb> fiddlerwoaroof: most of us here came from imperative languages sometime, it takes time to change your way of thinking. you'll hate the old ways afterwards, though.
17:44:51 <dmwit> Armored_Azrael: I'm not saying it's always avoidable.  Just that it's usually desirable to try avoiding it.
17:44:56 <Armored_Azrael> dmwit: OK
17:45:09 <dmwit> Armored_Azrael: There's the GHC API, and there's hsplugins.
17:45:14 <Armored_Azrael> OK, Thanks
17:45:15 <dmwit> Choose the one that seems less painful to you.
17:45:17 <byorgey> > map (\(x,y) -> x ++ ":" ++ y ++ " ") [("foo","bar"), ("baz","quux")]  -- fiddlerwoaroof: like this
17:45:18 <lambdabot>  ["foo:bar ","baz:quux "]
17:45:27 <jre2> fiddlerwoaroof: is there a particular area you're interested in?
17:45:46 <fiddlerwoaroof> I like compiler/iinterpreter design and filesystems
17:45:57 <fiddlerwoaroof> and I have stumbled across parsec
17:46:01 <dmwit> fiddlerwoaroof: foldr (++) "" == concat
17:46:11 <dmwit> ?src concat
17:46:11 <lambdabot> concat = foldr (++) []
17:46:54 <byorgey> fiddlerwoaroof: so all together, you could just write  fmtFields = concatMap (\(x,y) -> x ++ ":" ++ y ++ " ")
17:47:20 <byorgey> there, 9 lines reduced to one!
17:47:26 <fiddlerwoaroof> wow, definitely easier to understand,
17:47:29 <Giblaz> haskell = epic win
17:47:44 <byorgey> right, not only is it shorter, it's easier to understand! =D
17:47:53 <fiddlerwoaroof> I have been trying for several years to incorporate a more functional style in all my programming
17:47:54 <byorgey> epic win indeed
17:47:55 <dmwit> fiddlerwoaroof: Do you really want a Node, rather than a Map String Node'?
17:48:23 <fiddlerwoaroof> dmwit: where?
17:48:26 <dmwit> fiddlerwoaroof: Where type Node' = [(String, String)]
17:48:41 <dons> yitz: why do we need dynamic compilation beyond ghci's bytecode for scripts?
17:48:44 <dmwit> fiddlerwoaroof: i.e. a Map is going to be faster than your home-brewed binary search tree.
17:48:48 <dons> or are you thinking of 'scripting' applications
17:49:06 <fiddlerwoaroof> dmwit: Im just trying to implement something from scratch to get a feel for the Application
17:49:20 <dmwit> Okay, that's fair.
17:49:30 <yitz> dons: well yeah that also. but how would you write a Haskell view engine for CouchDB?
17:49:32 <byorgey> fiddlerwoaroof: if you want my diagnosis, you seem to have a very good 'functional' sense, I think you are just not yet familiar enough with the standard libraries
17:49:32 <Euler_> how can I check if ((return [c]) >>= (zip3 [a] [a])) == (zip3 [a] [b] (unsafePerformIO $ return [c])) forall a b c
17:49:44 <fiddlerwoaroof> byorgey: thanks
17:49:44 <byorgey> fiddlerwoaroof: but of course, that's the easiest thing to remedy
17:50:03 <dmwit> Euler_: That doesn't type-check.
17:50:03 <dons> yitz: why would you need dynamic compilation? does it intimately require runtime metaprogramming?
17:50:07 <dons> that would be unusual
17:50:07 <lament> does that mean fiddler without a roof?
17:50:13 <fiddlerwoaroof> yes
17:50:39 <dmwit> Euler_: (zip3 doesn't return an IO type)
17:50:59 <yitz> dons: views are functions, represented as strings in your favorite programming language. Haskell is conspicuously missing there.
17:50:59 <Euler_> is there a zip function that does?
17:51:11 <dmwit> Euler_: But, once you've got it type-checking, you could look at HUnit, or QuickCheck if you can break it out of IO.
17:51:14 <dons> in haskell that'd be done via an ADT though
17:51:19 <byorgey> fiddlerwoaroof: also, your 'srchlist' is already in the standard libraries, it's called 'lookup'
17:51:20 <dons> we'd 'interpret' the structure
17:51:25 <byorgey> @type lookup
17:51:26 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
17:51:41 <fiddlerwoaroof> what does the forall mean?
17:51:43 <dons> rather than trying to eval a string to a function, we'd actually interpret it properly.
17:51:51 <dmwit> Euler_: You probably just want to use fmap (zip3 [a] [b]) rather than (>>= zip3 [a] [b]).
17:51:58 <mauke> fiddlerwoaroof: ∀
17:51:59 <dons> that'd doesn't need dynamic compilation, just enough reflection to implement an interpreter
17:52:05 <byorgey> fiddlerwoaroof: that means the type is polymorphic
17:52:05 <yitz> dons: that's rewriting the compiler
17:52:12 <fiddlerwoaroof> ok
17:52:14 <dmwit> fiddlerwoaroof: It just tells the scope of the type variable.
17:52:21 <dons> i guess if you really want to store Haskell functions
17:52:23 <byorgey> fiddlerwoaroof: lookup can be used with any types a and b (as long as a is an instance of Eq, i.e. can be compared for equality)
17:52:23 <dons> then sure.
17:52:24 <mauke> fiddlerwoaroof: ignore everything before the "."
17:52:26 <dons> we'd need ghc-api
17:52:36 <dons> eval to an HsValue chunk of bytecode
17:52:43 <byorgey> fiddlerwoaroof: but the forall a b. is implicit if you just write everything to the right of it
17:52:50 <dons> i thought views were only javascript though?
17:52:50 <yitz> dons: yeah. so I think after this GSOC project, that should be easier, no?
17:53:05 <yitz> dons: no, many languages are implemented
17:53:20 <yitz> dons: e.g., lisp
17:53:28 <dons> i imagine not all of them "dynamcially typed with metaprogramming" languages?
17:53:55 <dons> anyway, that's a different kind of scripting -- the runtime reflection problem
17:54:05 * yitz looks
17:54:42 <fiddlerwoaroof> is " flds == [] = Nothing " unnecessary?
17:54:47 <fiddlerwoaroof> in srchList
17:55:15 <dmwit> yes
17:55:39 <byorgey> it is necessary
17:55:41 <yitz> dons: yeah, so far JS, CL, PHP, ruby, python
17:55:42 <Cale> Uh, I don't have context, but you should generally not check for empty lists using ==
17:55:46 <dmwit> You might also benefit from "prompt s = putStr s >> getLine".
17:55:49 <dons> yitz: heh.
17:55:53 <dons> those with an `eval`
17:55:54 <byorgey> oh, wait, no it isn't
17:55:58 <dmwit> byorgey: Uh... no?  He has a srchlist key [] case.
17:56:04 <byorgey> sorry, I didn't see that line
17:56:07 <yitz> dons: but I think we could do it with the api
17:56:08 <Cale> The null function will do it without requiring an Eq instance.
17:56:22 <dons> yitz: certainly. ghc-api provides an eval :: String -> a
17:56:24 <yitz> dons: or maybe xmonad style :)
17:56:54 <dons> that'd be a weird database access model
17:57:11 <fiddlerwoaroof> dmwit: definitely
17:57:27 * dons home
17:57:34 <byorgey> the haskeller's mantra: abstract, abstract, abstract
17:57:40 <byorgey> bye dons
17:58:03 <dmwit> Especially since then you could do something like
17:58:14 <dmwit> liftM2 addData (prompt "key") (prompt "value")
17:58:18 <dmwit> beautiful!
17:58:33 <dmwit> Okay, I fudged it a little bit.  But hey, poetic license.
17:58:59 <yitz> byorgey: the haskeller's mantra: cycle "abstract, "
17:59:03 <fiddlerwoaroof> that us kool
17:59:16 <fiddlerwoaroof> oops, keyboard shift
17:59:20 <byorgey> liftM2 (addData . (,)) ...
17:59:33 <dmwit> byorgey: Yep, or rewrite addData.
17:59:41 <byorgey> that works too.
17:59:44 <Euler_> thanks dmwit, fmap (zip3 [a] [b]) was exactly what I needed
18:00:08 <byorgey> yitz: excellent, you abstracted my abstraction mantra!
18:00:16 <jre2> anyone know what the book.realworldhaskell.org/beta is written in?
18:00:25 <byorgey> english
18:00:32 <byorgey> ;)
18:00:59 <byorgey> jre2: seriously though, I think bos wrote about their toolchain on his blog
18:01:01 <dmwit> Quick, everybody write down completely unhelpful answers!  Mine is "ink".
18:01:15 <byorgey> let me see if I can find it for you
18:01:28 <cjb> Server: Apache/2.2.9 (Unix) mod_ssl/2.2.9 OpenSSL/0.9.8g DAV/2 SVN/1.5.0 PHP/5.2.6 mod_python/3.3.1 Python/2.5.2
18:01:38 <ooxwo> Hey all, I'm trying to sort out the dependencies for installing Happs, but I'm getting this 'cannot satisfy dependency pretty-any' and I can't find it in google for some reason.  It looks like it's referring to Language.Haskell.Pretty, which should already be installed, right?
18:02:06 <ooxwo> And it's just a pretty printer for ***sake
18:02:33 <dmwit> Maybe take a look at hackage?
18:03:08 <byorgey> jre2: looks like they use DocBook: http://www.realworldhaskell.org/blog/2007/07/02/a-brief-haskell-book-status-update/
18:03:09 <lambdabot> Title: Real World Haskell  Blog Archive  A brief Haskell book status update, http://tinyurl.com/24plrr
18:03:28 <jre2> byorgey: ah
18:03:36 <yitz> byorgey: makes sense, O'Reilley has been into DocBook for a while now
18:03:43 <byorgey> apparently so
18:04:14 <byorgey> ooxwo: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/pretty
18:04:16 <lambdabot> Title: HackageDB: pretty-1.0.0.0
18:04:31 <byorgey> ooxwo: the pretty module has Text.PrettyPrint and Text.PrettyPrint.HughesPJ
18:04:45 <byorgey> ooxwo: if you've got cabal-install you can just  'cabal install pretty'
18:05:07 <ooxwo> byorgey:  Thanks, no I haven't installed cabal yet, looks like it's about time
18:05:16 <byorgey> and if you haven't got cabal-install, you can just 'cabal install cabal-install' ;)
18:05:47 <nolrai_East> :P
18:05:48 <ooxwo> I always hear everyone speak about cabal with this mix of admiration and fear
18:06:46 <byorgey> cabal is like a benevolent ninja master.  it is freaking awesome but can also make your life miserable if it feels like it.
18:07:19 <byorgey> (which is fortunately becoming more and more rare)
18:07:24 <ooxwo> byorgey:  cabal install cabal-install didn't work, I guess that would be too good to be true.  I almost believed you for a second.  Some kind of haskelly bootstrapping like that would be awesome.
18:07:35 <byorgey> hehe, yes, I was kidding =)
18:07:48 <Cale> ooxwo: It does work if you already have cabal-install installed (to upgrade it)
18:08:02 <byorgey> yes, you only ever have to install it once
18:08:13 <ooxwo> This is not the first time I have wanted to handle bash 'command not found' errors with specialized methods
18:08:22 <ooxwo> But I have never been able to figure out how to do that
18:08:32 <ooxwo> Without editing and compiling my own bash, that is
18:08:51 <ooxwo> Thanks guys, cabal here we go
18:09:01 <byorgey> ubuntu does it now, it will suggest a package to install that will give you the command that wasn't found
18:09:04 <byorgey> not sure of the mechanism
18:09:12 <dmwit> manual labor
18:09:26 <byorgey> oh, the magic gnomes you mean?
18:09:28 <Saizan_> slowing you down on each typo!
18:09:49 <byorgey> Saizan_: well, I'm sure you can turn it off =)
18:09:56 <byorgey> personally I find it rather useful
18:13:05 <fiddlerwoaroof> why do I get this: http://pastebin.com/m405b48a7 when compiling this:  http://pastebin.com/m6b2a9209 on OSX ?
18:13:52 <fiddlerwoaroof> using ghc from ports
18:15:28 <dmwit> fiddlerwoaroof: ghc --make
18:15:38 <dmwit> fiddlerwoaroof: Oh, never mind.
18:16:01 <fiddlerwoaroof> dmwit: it worked here
18:16:08 <dmwit> Oh, good.
18:16:18 <fiddlerwoaroof> although I did not get an executable
18:16:28 <dmwit> Are you sure?
18:16:38 <dmwit> It will be named Nodes (or whatever your module is named).
18:17:01 <fiddlerwoaroof> my directory now contains Nodes.hi	Nodes.hs	Nodes.o
18:17:10 <dmwit> whoops
18:17:15 <dmwit> I've never seen that one.
18:17:18 <dmwit> It didn't report any errors?
18:17:24 <Cale> You must call your main module Main
18:17:30 <fiddlerwoaroof> nope, exit status 0
18:17:32 <Cale> Unless you use --main-is to set it
18:17:36 <byorgey> or else you have to say -main-is Foo
18:17:41 <Cale> er, -main-is
18:17:55 <byorgey> I've never understood why it is -main-is and not --main-is
18:18:14 <Cale> Compilers have bizarre flag conventions. I blame gcc.
18:18:16 <byorgey> but it's odd enough that I remember it.
18:18:18 <fiddlerwoaroof> Cale: I get the error again with -main-is
18:18:22 <dmwit> -fincoherent-flags
18:18:33 <Cale> fiddlerwoaroof: you're using -main-is Nodes.main ?
18:18:35 <byorgey> hm, so can you set -fno-incoherent-flags?
18:18:47 <dmwit> --fno-incoherent-flags
18:18:54 <dmwit> ;-)
18:18:54 <byorgey> hahaha
18:18:58 <fiddlerwoaroof> ghc --make -main-is Nodes Nodes.hs
18:19:09 <fiddlerwoaroof> http://pastebin.com/m405b48a7
18:19:15 <LordBrain> gcc uses the gnu standard which prefaces all flags which consist of more than one letter with two hyphens
18:19:37 <LordBrain> but that's just a gnu thing... bsd does not do that
18:19:38 <dmwit> LordBrain: Technically, so does GHC, with the one exception of -main-is.
18:20:02 <dmwit> LordBrain: Even -f<foo> follows the rules, as -f is the flag, and <foo> is the argument.
18:20:11 <LordBrain> yeah
18:20:23 <byorgey> -fffffi
18:20:38 <LordBrain> i wish everybody would just surrender to gnu and do the two hyphen thing
18:20:45 <dmwit> byorgey++
18:20:59 <fiddlerwoaroof> aha, changing module name to 'Main' and using ghc --make Nodes.hs worked
18:21:00 <mauke> -ﬃ
18:21:32 <LordBrain> maybe if somebody convinces posix to accept that rule...
18:21:33 <byorgey> wow, I got a ++ for saying -fffffi ?
18:21:48 <fiddlerwoaroof> how do I make sure the output buffer is flushed before trying to get a line?
18:21:48 <dmwit> First time I laughed out loud today. =)
18:21:58 <dmwit> hFlush stdout
18:22:10 <dmwit> But it really should be flushed before input, right?
18:22:16 <dmwit> (i.e. automatically)
18:22:21 <byorgey> dmwit: hehe, glad I could help =)
18:22:29 <fiddlerwoaroof> it is not when I compile my program
18:22:40 <dmwit> ?index hFlush
18:22:40 <lambdabot> System.IO
18:23:00 <byorgey> fiddlerwoaroof: it's probably easier to just turn off output buffering:  hSetBuffering stdout NoBuffering
18:23:11 <dmwit> good idea
18:23:46 <byorgey> I think it's line buffering by default, so if you print out a prompt with no newline after it, it won't actually get printed until after you type your input
18:24:09 <fiddlerwoaroof> thanks, that worked
18:24:14 <fiddlerwoaroof> I got to go
18:24:17 <fiddlerwoaroof> bye
18:24:29 <byorgey> bye fiddlerwoaroof
18:24:38 <fiddlerwoaroof> thanks for the hell all
18:24:43 <byorgey> hahaha
18:24:56 <fiddlerwoaroof> s/hell/help/
18:25:15 <byorgey> fiddlerwoaroof: we're happy to give you hell anytime. ;)
18:25:23 <mauke> disabling output buffering is a bad idea
18:25:24 <fiddlerwoaroof> bye
18:25:31 <byorgey> mauke: why's that?
18:25:49 <mauke> because that causes a write(2) call for every single byte
18:26:02 * byorgey beats mauke with the premature optimization stick
18:26:36 <byorgey> unless there's any reason other than performance why a write(2) call for every byte is bad
18:26:51 <mauke> it makes strace output very ugly
18:27:05 <dmwit> Who strace's Haskell binaries?
18:27:12 <dmwit> ...while learning Haskell?
18:27:18 <mauke> <-
18:27:22 <byorgey> well, I'm just guessing here, but I'm pretty sure fiddlerwoaroof doesn't care about that.
18:29:43 <nolrai_East> what does "When generalising the type" mean? i fixed the error but am still wondering.
18:30:01 * byorgey runs off to work on his TMR article
18:30:28 <Euler_> > let f x = case x of (_,b,c) -> (b,c) in f (1,2,3)  -- anything shorter?
18:30:29 <lambdabot>  (2,3)
18:30:37 <dmwit> nolrai_East: Sounds familiar, but I can't remember the whole error.  Care to remind me?
18:31:00 <dmwit> > let f (_, b, c) = (b, c) in f (1,2,3) -- Euler_, just this
18:31:01 <lambdabot>  (2,3)
18:31:13 <dmwit> :t uncurry3
18:31:14 <lambdabot> Not in scope: `uncurry3'
18:31:36 <chessguy> huh. so apparently C# has a Maybe type built in
18:31:46 <nolrai_East> Occurs check: cannot construct the infinite type: <some infinite type> When generalising the type(s) for <function nam>
18:31:58 <nolrai_East> 2/nam/name
18:32:11 <Euler_> no function defined for dropping the first element of a tuple ?
18:32:12 <dmwit> nolrai_East: The interesting bit of that error is "cannot construct the infinite type".
18:32:18 <dmwit> Euler_: no
18:32:43 <dmwit> nolrai_East: The "when generalising the types for" bit just tells you what variable would have an infinite type.
18:32:54 <dmwit> nolrai_East: Here's a really simple example:
18:33:06 <dmwit> > let f a = f [a] in 3
18:33:07 <lambdabot>      Occurs check: cannot construct the infinite type: t = [t]
18:33:07 <lambdabot>       Expected...
18:33:41 <dmwit> nolrai_East: Suppose that were well typed.
18:33:52 <dmwit> nolrai_East: We would have "f :: a -> b" to start with.
18:34:20 <dmwit> nolrai_East: Then, on the RHS, we would see that the first argument to "f" is actually a list type, so we'd get "f :: [a] -> b".
18:34:22 <yitz> > let f x = x : x in 5
18:34:23 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
18:34:23 <lambdabot>       Expected...
18:34:43 <dmwit> nolrai_East: Looking at the RHS again, we now see that "f" must take a type that is a list of lists.
18:34:59 <dmwit> nolrai_East: ...and so on, and so forth, until we get a type that is a list of lists of lists of lists...
18:36:24 <nolrai_East> and its turtles all the way down. Wich is bad because the type system cant handle infinetly recusive types.
18:36:58 <dmwit> Well, it can, but you have to be explicit about it.
18:37:03 <nolrai_East> (not that it would make much sense for it to given that I dont think you could build one could you?
18:37:14 <dmwit> Sure.
18:37:19 <dmwit> [] -- here's one
18:37:32 <nolrai_East> Oh right data Fun = Fun (Fun -> Fun) --like this
18:37:43 <dmwit> Something like that, yeah.
18:37:46 <mauke> valid lambda calculus!
18:38:24 <nolrai_East> well that Fun is rather useless given that there isnt any way to look at a element of it.
18:39:11 <mauke> there is: pattern matching
18:39:53 <nolrai_East> mauke: ?? dosomthing (Fun f) = what?
18:40:07 <bd_> mauke: Sure, but the only information that can be extracted is bottom or non-bottom - and the former will propagate throughout your program
18:40:28 <bd_> ie, there is no non-trivial transformation from Fun to any other type
18:40:46 <bd_> thus it's not actually useful :)
18:41:46 <nolrai_East> you need something like data Fun = Fun (Fun -> Fun) | Data Int
18:42:04 <yitz> bd_: actually, I think you can do quite a lot with Fun
18:42:10 <EvilTerran> or, if you take data Fun f = Fun (f -> f), and throw in some type-composition and type-level fix, you can roll your own
18:42:20 <bd_> yitz: How would you inspect it?
18:42:24 <geezusfreeek> well, there is always Fix
18:42:31 <bd_> all you can do is apply things to it until you hit bottom
18:42:33 <bd_> or don't.
18:42:37 <yitz> pattern matching as mauke said
18:42:43 <EvilTerran> Mu (Either Int `O` Fun) -- is like nolrai's definition of Fun there
18:42:59 <bd_> yitz: If you pattern match, all you'll get out is a (Fun -> Fun) - you can construct a Fun, but what do you do with the result?
18:43:10 <yitz> Fun id, or Fun (const (Fun id)), etc.
18:43:21 <bd_> yitz: You can build them, but they all look the same.
18:43:49 <EvilTerran> that original definition of Fun's a valid newtype
18:43:51 <bd_> ie, if we want to make some sort of decision based on the value of Fun
18:43:56 <bd_> how do we do it?
18:44:03 <EvilTerran> newtype Fun = Fun (Fun -> Fun)
18:44:09 <EvilTerran> both sides of a newtype are isomorphic
18:44:13 <EvilTerran> the RHS is abstract
18:44:21 <EvilTerran> as it's a function
18:44:33 <bd_> We can: Inspect the single constructor, pass it some element of Fun, and ... we get back a Fun! Or we loop forever.
18:44:47 <bd_> We can't prove which will happen, of course. So in fact we can't make a decision here.
18:44:54 <EvilTerran> but the same goes for any values you can get out of the RHS, as the LHS is just a function too
18:46:15 <yitz> you can construct the entire lambda calculus out of Fun, so you can compute any calculation. But you're right, the only thing you can observe about the outcome is whether or not it is bottom.
18:46:43 <yitz> I suppose you could measure the heat output of your CPU, or power fluctuations
18:46:45 <bd_> which would be enough, if we have a halting oracle, I suppose :)
18:47:04 <dmwit> You can construct the lambda-calculus, but then you get back only half a bit?
18:47:09 * dmwit boggles
18:47:39 <bd_> dmwit: well, in a turing machine, you get no information at all out of it
18:48:02 <bd_> You run it and... if it doesn't stop, it's either bottom or not-bottom.
18:48:14 <dmwit> You get a transformed tape.
18:48:26 <dmwit> Much like many modern computers.
18:48:34 <bd_> I suppose you could use it to verify a halting proof.
18:48:49 <yitz> bd_: reading what is written on the tape is kind of analogous to measuring CPU power fluctuations for Fun.
18:48:52 <bd_> Well, no, you're not allowed timeouts, I guess.
18:48:52 <EvilTerran> the definition of turing machines i was taught differentiated between acceptance and rejection when it halted
18:50:16 <dmwit> Yeah, same here.
18:51:07 <yitz> I always reject turing machines. give me a babbage analytical engine any day.
18:51:31 <EvilTerran> however, you *do* get nothing out of a lambda calculus expression as i was taught it
18:51:50 <EvilTerran> other than by reasoning about the properties of the resulting function
18:51:57 <dolio> You get a normal form, no?
18:52:10 <EvilTerran> yeah
18:52:15 <EvilTerran> but lambdas are abstract :P
18:52:30 <Draconx> you can arrange for the normal form to represent whatever you need it to.
18:53:43 <EvilTerran> yeah, you can devise an injection from values of the desired type to normal forms
18:54:03 <EvilTerran> but, going the other way, a different normal form with the same properties as a lambda should represent the same value
18:54:26 <EvilTerran> i think we generally implicitly reasoned about \T-calc rather than just \-calc, for some appropriate type T
18:55:21 <EvilTerran> ie, data Fun t = Fun { (?) :: Fun t -> Fun t } | Val { getVal :: t }
18:55:23 <EvilTerran> or whatever
18:56:13 <EvilTerran> (nice to use an infix operator as the record accessor for Fun, 'cos then you can use it like $)
18:57:06 <monochrom> By the same reasoning, you get nothing out of C code either, other than admiring its beautiful indentation.
18:57:48 <EvilTerran> er... i'm sure there's a counterargument to that, but it escapes me at the moment
18:57:58 <EvilTerran> something about side-effects
18:57:59 <monochrom> Oh I know two.
18:58:00 <dmwit> I have the counterargument.
18:58:06 <dmwit> It's indentation is ugly.
18:58:28 <monochrom> First you say "C can be executed". lambda expressions can be executed too.
18:58:42 <EvilTerran> then you say "C has side-effects"
18:59:08 <monochrom> Second you say "C can output". But whatever it outputs is an abstract representation as well, not the "real" thing.
18:59:43 <monochrom> For example some people write C programs to output "1" to represent true, "0" to represent false.
19:00:09 <monochrom> So whatever you say about lambda, I can say a similar thing about C.
19:00:58 <EvilTerran> that's all well-and-good theoretically, but, pragmatically, C is executable and has output, and lambda-calc is the opposite
19:00:59 <monochrom> A lambda interpreter outputs "lambda x. x" to represent true.
19:01:19 <EvilTerran> or a normal form with the same behaviour as id
19:01:20 <monochrom> That is prejudice.
19:01:30 <EvilTerran> so?
19:01:40 <lament> i'm with EvilTerran
19:01:47 <monochrom> So it is not a valid rational argument.
19:01:54 <EvilTerran> worrying about political correctness isn't being pragmatic
19:01:54 <lament> in theory, theory and practice are the same, but in practice, they are not
19:01:56 <EvilTerran> :P
19:01:58 <dolio> True is \x.\y.x, no?
19:02:06 <Draconx> dolio, true is whatever you want it to be.
19:02:07 <lament> dolio: what do you mean "is"
19:02:09 <dolio> And False is \x.\y.y
19:02:11 <EvilTerran> monochrom, i no longer have any idea what we're argiung about
19:02:20 <monochrom> I am not worrying about political correctness.
19:02:26 <lament> dolio: that's certainly _one_ convention out of an infinity of possible conventions.
19:02:28 <dolio> I mean, is the traditional encoding.
19:02:41 <lament> several encodings are in use.
19:03:02 <EvilTerran> your arguments have become increasingly abstract to the point where, while i have a vague grasp of why i disagree, i can't put it into words
19:03:16 <vixey> what dolio said makes sense if you take bool as
19:03:17 <vixey> @src Bool
19:03:17 <lambdabot> data Bool = False | True deriving (Eq, Ord)
19:03:19 <EvilTerran> so i should probably give up for the evening
19:03:23 <vixey> oh
19:03:27 <vixey> data Bool = True | False
19:03:38 <Draconx> EvilTerran, your original claim was that you get nothing when you reduce a lambda expression.
19:03:59 <EvilTerran> Draconx, ah, yes, now i remember
19:04:11 <dmwit> vixey: It's False | True so that fromEnum False = 0. ;-)
19:04:11 <monochrom> I don't even argue that you get nothing from lambda or C. I argue that you get the same things from both.
19:04:20 <vixey> yeah
19:04:23 <EvilTerran> it was a bad analogy with data Fun = Fun (Fun -> Fun)
19:04:46 <vixey> was the argument "untyped code is meaningless" ?
19:04:54 <EvilTerran> i didn't say you get nothing
19:05:05 <lament> monochrom: that's not true... C program can give you output in plain English!
19:05:07 <Draconx> <EvilTerran> however, you *do* get nothing out of a lambda calculus expression as i was taught it
19:05:21 <EvilTerran> ok, i phrased that badly :P
19:05:27 <EvilTerran> i mean, you get something that is meaningless on its own
19:05:36 <Draconx> everything is meaningless until you assign it meaning.
19:05:40 <EvilTerran> and remains meaningless if you stick to the untyped lambda calc with only abstractions
19:06:02 <EvilTerran> as any normal form with the same behaviour should suffice
19:06:23 <lament> puts("hello world"); prints "hello world" (an English sentence) - note that we didn't have to impose any extraneous conventions on the output and don't need to "decode it"
19:06:32 <lament> can't do that in LC
19:06:40 <EvilTerran> for representing the same thing, and that's an undecidable problem from looking at the shape of the normal form
19:06:56 <Draconx> lament, that's because you've assigned a meaning to that bunch of squiggles.
19:06:59 <vixey> you can check alpha convertability of normal forms
19:07:04 <vixey> that's a very very useful thing
19:07:19 <EvilTerran> vixey, yes, but it's not enough to check equivalence
19:07:25 <nus> ok, now when monism vs dualism was argued, what's next? <-;
19:07:29 <vixey> yes it is
19:07:36 <EvilTerran> *for the purposes of checking equivalence
19:07:42 <dolio> Your computer needs to decode the integers used to represent that string into (eventually) dots on your screen that mean something to you.
19:07:49 <vixey> if you have a normalizing calculus with church rosser
19:07:52 <monochrom> I'm satisfied that my opposition has agreed it is prejudice.
19:07:58 <lament> dolio: that's wrong.
19:08:10 <lament> dolio: puts("hello world") outputs "hello world", by definition :)
19:08:35 <EvilTerran> lament, because that's how your language is defined?
19:08:36 <vixey> "..." is a char[4] or whatever
19:08:39 <vixey> and a char is a number
19:08:39 <Draconx> lament, and (\x.\y.x)(\x.x) outputs \y.\x.x, by definition.
19:08:40 <geezusfreeek> this is looking like a straw man argument now
19:08:40 <EvilTerran> i think that's the distinction i was going for
19:08:49 <lament> Draconx: correct
19:08:52 <monochrom> It used to output "hello world" to punch cards using some encoding.
19:09:15 <EvilTerran> geezusfreeek, i think we've all been arguing at complete cross-purposes for some time now
19:09:21 <lament> now i'm also confused about what the argument is :)
19:09:25 <geezusfreeek> that is my impression as well
19:09:28 <EvilTerran> 'cos what monochrom's saying doesn't seem like a counterargument to what i was saying, for instance
19:10:04 <geezusfreeek> i think everybody is agreeing in their own ways that a program only has meaning that you have given it
19:10:16 <EvilTerran> monochrom seems to be arguing that "his opposition" is "prejudiced" (though i find that a somewhat distasteful use of weighted language)
19:10:33 <EvilTerran> i'm arguing that lambdacalc on its own is meaningless, without talking about other language
19:10:33 <EvilTerran> s
19:10:40 <EvilTerran> i don't know *what* the rest of you are talking about :P
19:10:51 <Draconx> EvilTerran, _everything_ is meaningless on its own.
19:11:00 <EvilTerran> Draconx, yes, you said that already
19:11:07 <Draconx> so it's not a very useful point.
19:11:11 <EvilTerran> repeating it doesn't make it truer
19:11:15 <EvilTerran> or falser, mind :P
19:11:32 <nolrai_East> no, yes. aughhh
19:11:44 <lament> Draconx: EvilTerran has previously mentioned the word "pragmatically", does it mean anything to you?
19:12:05 <lament> s/mentioned/used
19:12:05 <vixey> How should I implement pattern matching ?
19:12:29 <SamB> vixey: in what context?
19:12:29 <monochrom> use a lot of loops and tests.
19:12:34 <Draconx> lament, yes, that word has meaning to me.
19:12:48 <vixey> ao
19:12:52 <lament> Draconx: given that we're humans, some stuff does have more meaning to us than other stuff.
19:12:54 <EvilTerran> it's like talking about a monad "generating" an arrow - the idea of something "generating" something else is a pragmatic idea, not a rigorously expressed notion, as far as i know
19:12:56 <vixey> a lazy typed language like haskell
19:12:58 * SamB guesses "decompose into atomic cases"
19:13:15 <vixey> I was thinking for every data type create a function which eliminates them
19:13:28 <vixey> so, boolElim :: Bool -> a -> a -> a
19:13:41 <vixey> and so on.. turning pattern matches into nested calls of them
19:13:42 <Draconx> lament, however, if I was not fluent in English, I suspect that my view would differ.
19:13:47 <vixey> but then what is Bool ?
19:13:48 <SamB> that sounds hard to optimize :-(
19:13:54 <dolio> Use banana/lens notation like Charity.
19:13:58 <roconnor> foldBool
19:14:08 <roconnor> cataBool
19:14:12 <vixey> one option is that Bool = a -> a -> a, True = \x y -> x, False = \x y -> y
19:14:16 <geezusfreeek> "We're not actually saying this is the Earth calling you, Matilda." "Yeah. No, I got that. I understand you don't literally mean..." "Uh, no, I don't think you do. Listen. It's not like we think we're actually in a control tower trying to reach outer space aliens or something, okay?"
19:14:19 <lament> Draconx: a C program could draw a smiling face on the screen. That's universal :)
19:15:06 <geezusfreeek> ^ is what this conversation look like to me
19:15:10 <monochrom> I thought C output to punch cards.
19:15:20 <Draconx> lament, well, C doesn't specify a screen :P
19:15:21 <SamB> monochrom: you can do smileys on those too
19:15:27 <vixey> but yeah.. any other ideas or thoughts abuot it ?
19:15:39 <SamB> Draconx: doesn't really prevent the C program doing it
19:15:41 <monochrom> Yes, but someone said specifically "screen" and called it universal. :)
19:15:58 <SamB> you just need to run the program on a screen and take a photo
19:16:11 <lament> monochrom: you're not arguing in good faith, this is most inconvenient for me
19:16:24 <Draconx> by the same token, an output device could display lambda terms in smiley face shapes.
19:16:37 <ddarius> vixey: There's an entire section on compiling pattern matching in SPJ's book.
19:16:55 <nolrai_East> ???
19:16:55 <SamB> obviously, if you use the *same* program on an implementation that outputs to punched cards, you'll need to take the deck over to a printer
19:17:30 <monochrom> lament: I am speaking in two threads. One is punch cards blah blah; that one is joking. The other one is meaning blah blah, that one is serious.
19:17:49 * ddarius thinks monochrom is joking.
19:18:05 <nolrai_East> "by the same token, an output device could display lambda terms in smiley face shapes." -not with just the lambda calculus you cant.
19:18:22 <EvilTerran> anyway, this is all tangential to my point, which was that, in the untyped lambda calculus with only abstractions as values, as equivalence is undecidable, working out the meaning of the resulting normal form is undecidable
19:18:33 <lament> so, who in the channel hasn't read The Colour Of Bits? please go read it now.
19:18:59 <vixey> EvilTerran: no if you have a normal form it's equivalent to any other term which has the same normal form
19:19:03 <lament> ( http://ansuz.sooke.bc.ca/lawpoli/colour/2004061001.php )
19:19:03 <EvilTerran> so it helps to throw in some values with decidable equivalence
19:19:04 <lambdabot> Title: What Colour are your bits?
19:19:16 <vixey> EvilTerran: not every term has a normal form.. it's those that you can't tell apart
19:19:24 <lament> that article is extremely relevant to this discussion
19:19:53 <nus> EvilTerran, you've just paraphrased http://www.nhplace.com/kent/PS/EQUAL.html
19:19:54 <lambdabot> Title: P.S.: The Best of Intentions
19:20:15 <EvilTerran> vixey, (\x. (\y z. y) x x) and (\x. (\y z. z) x x) are distinct but equivalent normal forms
19:20:47 <monochrom> Indeed, I enjoy the girl pic very much. :)
19:20:49 <vixey> they are not normal forms
19:20:50 <EvilTerran> under evaluation rules that don't evaluate under a lambda, at least
19:20:50 <asdftimo> hey guys i need some help with some basic code. check the hpaste
19:20:51 <dolio> Those aren't normal forms.
19:20:52 <hpaste>  asdftimo pasted "pascal helper" at http://hpaste.org/8774
19:22:00 <dolio> They're weak head normal forms.
19:22:03 <dmwit> asdftimo: What do you think @ does?
19:22:10 <EvilTerran> vixey, dolio: doesn't whether or not they're normal forms depend on your evaluation rules?
19:22:27 <lament> one beautiful thing about programming is that the value 1 in your program (in a language that has numbers, unlike LC which does not) is really the number 1, and not a numeral. Numbers are elusive creatures and it's rare to deal with one.
19:22:35 <dmwit> asdftimo: Care to join me in #haskell-overflow?  It's getting noisy in here.
19:22:38 <asdftimo> i thought it labeled an expression so you could refer to it.
19:22:40 <asdftimo> yeah sure
19:22:48 <ddarius> EvilTerran: The typical usage of "normal form" in this context, is no redexes remaining anywhere.
19:23:05 <EvilTerran> ah, ok
19:23:11 <EvilTerran> i was working from the meaning of "no evaluation rules apply"
19:23:23 <EvilTerran> arguing at cross-purposes, as i said earlier
19:23:25 <EvilTerran> oh well
19:23:40 <SamB> isn't a redex just an expression to which an evaluation rule applies?
19:23:55 <SamB> (directly)
19:24:27 <monochrom> things are different between "no rule applies to the main expr" and "no rule applies to any subexpr".
19:25:22 <SamB> he didn't say "no rule applies directly"
19:25:26 <monochrom> asdftimo: helper [x] = [x]
19:27:17 <monochrom> I killed the conversation. :)
19:28:24 <ddarius> monochrom: Good job.
19:29:03 <monochrom> This is encouraging. I'm going to post more haskell stuff on my web page because of this!
19:29:28 <SamB> monochrom: wait, what?
19:29:37 * dolio has yet to find good examples of head normal form differing from normal form.
19:29:43 <SamB> you want people to stop sending you so many emails?
19:30:07 <SamB> Just (id ())
19:30:08 <dolio> Is \x.\y.(\z.z)x in head normal form?
19:30:40 <SamB> dolio: yes
19:30:49 <dolio> Okay.
19:30:49 <vixey> is that
19:30:53 <vixey> \x.(\y.(\z.z)x)
19:30:57 <vixey> or (\x.\y.(\z.z))x ?
19:30:58 <dolio> Right.
19:31:04 <dolio> The former.
19:31:47 <SamB> @pl \x->\y->(\z->z)x
19:31:48 <lambdabot> const
19:31:54 <SamB> @unpl \x->\y->(\z->z)x
19:31:55 <lambdabot>  Parse error at "->\y-..." (column 3)
19:32:08 <SamB> > \x->\y->(\z->z)x
19:32:08 <lambdabot>  Parse error at "->\y-..." (column 3)
19:32:29 <SamB> > \x -> \y -> (\z -> z) x
19:32:39 <lambdabot>  Add a type signature
19:32:47 <SamB> @unpl \x -> \y -> (\z -> z) x
19:32:47 <lambdabot> \ x y -> x
19:33:00 <dolio> About 99% of the descriptions of hnf google returns use the same explanation that \x.(\y. x+y) 2 is in whnf but not hnf, but don't give any examples of hnf but not nf.
19:33:00 <SamB> that's ... interesting ...
19:33:18 <SamB> oh.
19:33:24 <vixey> what do you mean ?
19:33:30 <SamB> hmm, I might be confused about hnf vs. whnf
19:33:58 <vixey> you want a term that's in WHNF but has no normal form?
19:34:20 <dolio> I want one that's in head normal form but not normal form.
19:34:35 <dolio> Or is head normal form the same as normal form?
19:34:40 <vixey> \x.\y.(\z.z)x
19:34:50 <vixey> that one you gave before is, surely?
19:35:04 <dolio> That's my guess. But I wasn't sure.
19:35:08 <vixey> it's in WHNF, it's got the normal form \x.\y.x
19:36:03 <dolio> Yeah, but is it in HNF?
19:36:17 <vixey> what's your definition of HNF?
19:36:28 <vixey> (I've never heard of that term(
19:36:58 <dolio> Google has a definition repeated plenty of times.
19:37:35 <Cale> Head normal form means the same as normal form except that you don't evaluate under a lambda.
19:38:15 <dolio> Wouldn't that mean that \x. (\y. x + y) 2 is in head normal form?
19:38:25 <Cale> yes
19:38:40 <Cale> (and it is)
19:38:59 <dolio> Then all these definitions of weak head normal form are wrong about head normal form.
19:38:59 <vixey> http://dictionary.reference.com/browse/weak%20head%20normal%20form says it's not in HNF
19:39:00 <lambdabot> Title: weak head normal form - Definitions from Dictionary.com, http://tinyurl.com/6ex9jz
19:39:07 <Cale> dolio: hmm..
19:39:51 <Cale> oh, right, I'm confused.
19:41:05 <Cale> HNF means that the top level is not a redex or a lambda expression whose body is reducible.
19:41:34 <dolio> So, if it's a lambda expression whose body is a lambda expresion whose body is reducible, that's acceptable?
19:42:02 <dolio> Or does that count as the outer body being reducible as well?
19:43:33 <dolio> Or is it that you can have 'builtin ((\x.x) 2)'?
19:43:46 <dolio> Where builtin has arity > 1.
19:43:53 <Cale> yeah, I think that's it
19:44:10 <Cale> You can have reducible expressions in argument positions so long as the top level can't yet be reduced.
19:45:02 <dolio> So it's kind of meaningless in a calculus without built-in functions.
19:45:09 <dolio> Or, identical to normal form at least.
19:45:10 <Cale> http://en.wikipedia.org/wiki/Beta_normal_form
19:45:11 <lambdabot> Title: Beta normal form - Wikipedia, the free encyclopedia
19:45:18 <SamB> dolio: or constructors
19:46:03 <dolio> Yeah, that'll do it, too, I suppose.
19:46:13 <dolio> Something other than pure lambda terms.
19:47:53 <SamB_XP> is there a wnf?
19:48:26 <ddarius> \x.x ((\y.y) x), for hnf you don't need built-ins.
19:48:56 <dolio> Ah, okay. Thanks.
19:51:05 <dons> sclv_: implementing soft heaps in .hs ?
19:51:31 <Draconx> SamB, yes - a term is in WNF if every redex is within the body of an abstraction.
19:56:28 <dons> werid, http://www.contextfreeart.org/ and weird, http://azarask.in/projects/algorithm-ink/#99fdc2df
19:56:29 <lambdabot> Title: Context Free Art
19:56:44 <dons> a JS graphics EDSL ?
19:57:40 <ddarius> Yet another L-system graphics thing.
19:58:11 <dons> ah, just L-systems. but is the EDSL in the later link standard?
19:58:15 <dons> DSL, i guess
19:58:36 <dons> rule start{ shapeA{ r 90 s 2} shapeA{ r 90 flip 90 s 2}
19:58:48 <dons> from the 'edit' link on http://azarask.in/projects/algorithm-ink/#8c7b9bf3
19:58:48 <lambdabot> Title: Algorithm Ink | Aza Raskin
20:02:00 <SamB_XP> dons: looks like an unusually readable language for lystems...
20:02:23 <dons> ah so he might have just come up with his own syntax
20:02:58 <shapr> I met Aza, he's a cool guy.
20:03:02 <SamB_XP> dons: easily
20:03:16 <SamB_XP> many don't have a whole lot of syntax ;-)
20:03:23 <shapr> I met his father too...
20:03:54 <dons> shapr: oh, interesting.
20:04:16 <shapr> Have you read Jef Raskin's The Humane Interface?
20:04:54 <dons> nope. sounds interesting
20:05:14 <shapr> dons: You'd like it, especially after doing xmonad hacking.
20:05:28 <dons> xmonad: an inhuman interface
20:05:32 <shapr> A bunch of my emacs keybindings are based on The Humane Interface.
20:05:33 <shapr> haha
20:07:32 <dons> type math is popular of late, http://www.reddit.com/info/6qpal/comments/
20:07:33 <lambdabot> Title: reddit.com: Finding the fixed point of a data type
20:11:37 <dons> so, what hot new libraries are on the horizon?
20:12:20 <dolio> There's uvector-algorithms if we get a version of uvector that it will build against. :)
20:12:29 <dons> oh, good point.
20:14:50 <dons> add haskell to facebook's supported languages? http://developers.facebook.com/thrift/
20:14:51 <lambdabot> Title: Incompatible Browser | Facebook
20:15:00 <dons> why should boring old ruby get the limelight
20:15:09 <dons> haha "Incompatible Browser"
20:15:13 <dons> they don't support lambdabot!!
20:16:36 <SamB_XP> shows what they know -- lambdabot isn't even a browser ;-P
20:24:50 <sw17ch> dons: as far as libraries... i'm *still* trying to learn c2hs better so i can finish bindings for libalsa
20:28:20 <jre2> does anyone have use for an OSCAR or TOC2 (aim protocol) library?
20:28:36 <TomMD> sw17ch: Not having used c2hs, I'm curious why people use c2hs rather than manually write and FFI with the help of hsc2hs.  Could you enlighten me?
20:29:17 <sw17ch> TomMD, i started using hsc2hs, but the fact c2hs will parse the Enumerations for me was what did it
20:29:44 <sw17ch> 14 lines of {# enum ... #} is turned into well over 500 lines of haskell
20:29:59 <sw17ch> which includes the enum data type and fromEnum/toEnum instances
20:30:12 <sw17ch> i don't *think* hsc2hs will do that for me
20:30:20 <sw17ch> it does it with #define's, but not enum's
20:37:41 <dons> TomMD: c2hs gets used for the big libs.
20:37:57 <dons> most of our libs are small though, so most bindings are hsc2hs, which is good enough.
20:38:07 <dons> sadly, X11 uses hsc2hs -- wrongly imo, since there's too much to go wrong.
20:40:31 <Armored_Azrael> How would one go about adding an IORef that can be referenced from outside the module
20:40:46 <chylli> when I run cabal install regex-tdfa, I got an error
20:41:00 <chylli> Text/Regex/TDFA/RunMutState.hs:13:32: parse error on input `#'
20:41:02 <vixey> same way you export anything across modules right?
20:42:54 <ddarius> "Locally global variables aren't enough for me, I need globally global variables."
20:43:08 <chessguy> @keal
20:43:08 <lambdabot> today's 24hour project was supposed to be logical overloading using plegm method
20:43:25 <dmwit> Mmm, the ol' phlegm method: spit at it until it works.
20:43:37 <dmwit> ?protontorpedo
20:43:37 <lambdabot> that dude is selling u  a book
20:43:43 <dmwit> no kidding
20:43:55 <chessguy> @quote sleep
20:43:56 <lambdabot> blackdog says: i think coding in your sleep should trigger an exception
20:44:04 <dmwit> heh
20:44:05 * chessguy goes off to try it
20:44:23 <dmwit> ?quote no.fair
20:44:23 <lambdabot> No quotes match. My brain just exploded
20:44:29 <dmwit> ?quote fair
20:44:29 <lambdabot> HamiltonRichards says: It's fair to say that functional programming requires a very different mind-set, but once you've made the "jump", programming in conventional languages feels like doing
20:44:29 <lambdabot> arithmetic in Roman numerals.
20:45:02 <dmwit> ?quote
20:45:02 <lambdabot> pkhuong says: you'll probably still want unsafeEquality or whatever, though
20:45:09 <dmwit> ?quote
20:45:10 <lambdabot> l33t_h4x0r says: maybe if uve had some professor teach u bullshit in uni yea \n i learned on my own.. k.. i dun give a shit bout terms :p i just code
20:45:29 <dmwit> preflex: nickometer l33t_h4x0r
20:45:29 <preflex>  l33t_h4x0r is 99.914452% lame
20:47:49 <dmwit> ?quoth Syzygy-
20:47:49 <lambdabot> Syzygy- says: Why do I get the feeling that the arrow code was written during "Speak like a pirate day"?
20:49:49 <dons> :t arr (!)
20:50:03 <lambdabot> forall i e (a :: * -> * -> *). (Arrow a, Ix i) => a (Array i e) (i -> e)
20:51:10 <dmwit> :t \ye -> arr ye pure
20:51:10 <lambdabot> forall c a (f :: * -> *). (Applicative f) => ((a -> f a) -> c) -> c
20:51:31 <dons> yarr!
20:55:05 <vixey> http://www.physics.ntua.gr/~mourmouras/euclid/index.html
20:55:07 <lambdabot> Title: Euclid's Elements, Home Page. The original Greek text, Books 13
20:55:14 <vixey> looks of lambdas in here :D
21:00:04 <nus> forallye
21:04:46 <yaru1022> haskell rocks
21:05:17 <vixey> ruby pebbles
21:06:43 <dmwit> I'll take a few ruby pebbles, as long as you're handing them out.
21:20:31 <vixey> I got a mental block
21:20:52 <dmwit> Ruby's the language for you, then, they love blocks.
21:21:17 <vixey> oh yeah {|i| ..} tsuff
21:21:29 <vixey> I wrote some plugins in ruby once it was unremarkable
21:21:47 <dmwit> unremarkable is pretty high praise
21:29:23 <sw17ch> what would the c2hs {#fun ... #} declaration look like for a function which takes a ptr to a variable, checks the content of the variable, and then alters it look like?
21:29:54 <sw17ch> int f(int * x) { if (*x > 5) *x = 10; else *x = 11; }
21:30:05 <sw17ch> void f(int * x) { if (*x > 5) *x = 10; else *x = 11; }
21:30:06 <sw17ch> woops
21:31:07 <sw17ch> does it just require that i define an inmarshaler and an outmarshaler?
21:40:03 <vixey> Q: What is sour, yellow, and equivalent to the axiom of choice...
21:40:03 <vixey> A: Zorn's lemon...
21:43:03 <dmwit> vixey: What do you call a grape that commutes?
21:43:13 <dmwit> An abelian grape!
21:43:25 * SamB_XP groans loadly
21:43:31 <ddarius> @slap dmwit
21:43:31 * lambdabot locks up dmwit in a Monad
21:43:39 <shepheb> that one hurt
21:43:40 <dmwit> And what do you call a grape that commutes and has a small following of monks?
21:43:46 * SamB_XP could only think of "commutative grape"
21:43:53 <dmwit> A finitely venerated abelian grape!
21:44:21 <SamB_XP> what about one with a large following?
21:44:35 <newsham> this might be useful to interop with:  http://code.google.com/apis/protocolbuffers/docs/overview.html
21:44:35 <lambdabot> Title: Developer Guide - Protocol Buffers - Google Code
21:44:39 <vixey> Q: Do you know any catchy anagram of Banach-Tarski?
21:44:39 <vixey> A: Banach-Tarski Banach-Tarski...
21:45:09 <SamB_XP> Tarski-Banach ?
21:45:34 <dmwit> BBaannaacchh--TTaarrsskkii
21:45:56 <SamB_XP> oh, is that the one where they double the sphere???
21:46:00 <SamB_XP> that is EVIL
21:46:02 <dmwit> > "Banach-Tarski" <* [(),()]
21:46:03 <lambdabot>  "BBaannaacchh--TTaarrsskkii"
21:46:17 <SamB_XP> It's a really good demonstration of how the reals are broken
21:46:18 <shepheb> :t (<*)
21:46:19 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
21:46:45 * shepheb runs off to play with this in GHCi
21:46:51 <vixey> SamB: I've not read the proof, any idea if it doesn't apply to constructive reals?
21:47:04 <dmwit> shepheb: roughly, a <* b = a >>= \x -> b >> return x
21:47:18 <SamB_XP> vixey: it depends critically sets with unmeasurable area
21:47:23 <vixey> (or computable?)
21:47:25 <SamB_XP> +on
21:47:29 <Axman6> > "Banach-Tarski" <* [(),(),()]
21:47:30 <lambdabot>  "BBBaaannnaaaccchhh---TTTaaarrrssskkkiii"
21:47:33 <kaol> just when I felt like I got really comfortable with monads, people came up with Applicative. I hate you.
21:47:45 <vixey> kaol: Applicative is simpler
21:47:57 <kaol> and that makes it all the more annoying to not get them
21:48:01 <dobblego> Monads give rise to Applicative
21:48:12 <dobblego> kaol, do you understand Monad's ap function?
21:48:13 <dobblego> ?type ap
21:48:13 <ddarius> vixey: It depends critically on the Axiom of Choice.
21:48:13 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
21:48:20 <dobblego> @src ap
21:48:20 <lambdabot> ap = liftM2 id
21:48:28 <vixey> oh of course, yes
21:48:36 <SamB_XP> oh, yes, that too
21:49:11 <SamB_XP> so you can't pull it off constructively
21:49:22 <kaol> I've never used ap. :-/
21:49:52 <vixey> Why did the chicken cross the Möbius strip?
21:50:01 <SamB_XP> and all those stupid pathalogical functions that don't work in calculus ??? they don't either.
21:50:04 <ddarius> kaol: Here's the one line guide to Applicative: liftM3 f x y z = liftA3 f x y z = f <$> x <*> y <*> z
21:50:17 <SamB_XP> mobius strips are fine though
21:50:52 <SamB_XP> insofar as anything with a surface or edges is ;-)
21:50:53 <dobblego> liftM3 f x y z = liftA3 f x y z = pure f <*> x <*> y <*> z =  liftA3 f x y z = f <$> x <*> y <*> z
21:51:01 <dmwit> vixey: To get to the same side!
21:51:28 <SamB_XP> but crossing the mobius strip gets you ... to somewhere else
21:51:44 <SamB_XP> you don't get from side to side of the mobius strip by crossing it
21:51:58 <SamB_XP> you get from not-on-strip to not-on-strip
21:52:01 <vixey> Mathematic puns are the first sine of madness
21:52:12 <SamB_XP> I've never heard of a second sine
21:52:14 <SamB_XP> have you ?
21:52:33 * Cale loves pathological functions :)
21:52:36 <dmwit> vixey: If you wrote that as a petition, I would co-sine it.
21:52:41 <SamB_XP> Cale: why the heck?
21:52:53 <SamB_XP> they don't actually exist
21:52:58 <SamB_XP> they are imaginary
21:53:08 <Cale> Like everything in mathematics.
21:53:10 <vixey> oh not the existence debate again ...
21:53:12 <ddarius> SamB_XP: Don't slur the imaginary numbers.
21:53:23 <SamB_XP> the imaginary numbers exist though
21:53:26 <dobblego> kaol, (<*>) and ap are the essence of Applicative and (<*>) = ap and pure = return (to relate it back to Monads)
21:53:28 <ddarius> vixey: If everyone could just agree not to exist, we wouldn't have these problems.
21:53:29 <Cale> SamB_XP: They illustrate concepts better than examples do.
21:53:36 <vixey> hehe
21:53:47 <vixey> what about reading Intuitionism SamB
21:53:49 <vixey> by heyting
21:53:51 <Cale> That is, you get a better idea of what continuous functions are by looking at discontinuous ones.
21:54:09 <SamB_XP> Cale: but all existant functions are continuous ;-P
21:54:21 <dobblego> existent
21:54:22 <Cale> SamB_XP: You have a strange definition of 'exist' then.
21:54:32 <Cale> SamB_XP: I'm using the standard one.
21:54:42 <ddarius> SamB_XP: You're not taking my Dirac impulses or Heaviside step functions from me!
21:54:51 <SamB_XP> ddarius: they are abstractions
21:54:57 <SamB_XP> they do not exist in the first place
21:55:05 <SamB_XP> we cannot make them
21:55:10 <Cale> Dirac delta isn't a function R -> R, but it is a measure on R :)
21:55:15 <SamB_XP> I've decided it would be silly to do so
21:55:23 <SamB_XP> since they would sound horrid anyway
21:55:25 <Cale> SamB_XP: So is the number 1
21:55:38 <SamB_XP> sure 1 exists
21:55:39 <Cale> SamB_XP: The number 1 is an abstraction, and doesn't "really exist" either.
21:55:47 <SamB_XP> I can have one of something
21:55:48 <Cale> Where is it then?
21:55:50 <Cale> Show it to me.
21:55:56 <SamB_XP> Here:
21:55:59 <SamB_XP> *
21:56:02 <SamB_XP> one asterisk
21:56:05 <Cale> I don't want to see one of something. I want to see 1.
21:56:09 <Axman6> our maths lecturer told us the definition of one
21:56:10 <dobblego> they are pixels on my screen, not 1
21:56:16 <Axman6> it was pretty rooted
21:56:33 <SamB_XP> well, okay, so one is the closest abstraction possible
21:56:37 <ddarius> Axman6: Obviously you should try some non-well-founded set theory.
21:56:42 <Axman6> had something to do with what all single things have in common
21:56:56 <Cale> Axman6: sure, and it's rooted in some axioms which are just as abstract and arbitrary
21:56:59 <Cale> But that's okay!
21:57:08 <Cale> Because abstract things can still be useful.
21:57:14 <Axman6> but yeah, there is no such thing as '1', it's an idea
21:57:21 <vixey> SamB: I don't understand your point at all
21:57:32 <dolio> SamB only programs in assembly language.
21:57:36 <Axman6> numbers aren't something that exist, they're something we've defined
21:57:48 <ddarius> dolio: Mnemonics are an abstraction.
21:57:52 <vixey> SamB: why are you deciding that one set of things exist and one doesn't? There is no one Logic you can do all of maths in
21:58:04 <dolio> Oh no!
21:58:22 <Cale> It would be quite funny if there was a standard 1 which was stored in a special vault in France.
21:58:34 <vixey> :D
21:58:53 <geezusfreeek> i came in for the right quote
21:58:59 <ddarius> How would we know there is only one of them?
21:59:03 <SamB_XP> well, what I mean is that functions that are used to implement our realm of existance seem to all be in one of two categories: continuous or quantized
21:59:24 <Cale> SamB_XP: That's just due to our personal choice.
21:59:26 <SamB_XP> none of that "uncomputable reals" crap
21:59:30 <dobblego> existence
21:59:39 <Cale> SamB_XP: Physics is a human invention.
21:59:51 <ddarius> Cale is a human invention.
21:59:55 <SamB_XP> Cale: oh, in that case how do you function?
22:00:13 <Cale> Hm?
22:00:17 <SamB_XP> I don't think human physiology is capable of functioning without physics
22:00:21 <Cale> Perfectly well regardless of physics.
22:00:35 <geezusfreeek> physics as an abstraction which represents observed phenomena, not reality
22:00:44 <SamB_XP> he's the one who said the word physics
22:00:45 <geezusfreeek> i believe that is what cale meant
22:00:53 <SamB_XP> I said "used to implement our realm of existance"
22:01:00 <ddarius> Reality is a human invention.
22:01:09 <geezusfreeek> ddarius: touche
22:01:13 <Cale> Physics is a system of statements which has been designed and fine tuned to help us try to predict our observations.
22:01:15 * vixey makes a note not to paste stupid math jokes in future...
22:01:23 <SamB_XP> vixey: we like it
22:01:35 <SamB_XP> but we also like to argue metaphysics too
22:01:36 <ddarius> vixey: That should have gone without saying, but thankfully you've at least learned your lesson.
22:02:36 <Cale> Anyway, in ZFC, there are plenty of functions which are, for instance, everywhere dense, and I like them :)
22:03:06 <SamB_XP> Cale: you must admit that ... well, there seem to be some REAL laws of physics underlying it all?
22:03:20 <SamB_XP> otherwise how would the models work at all?
22:03:31 <Cale> SamB_XP: Why should I have to assume that such statements would have to exist?
22:03:45 <SamB_XP> I never said anything about statements of those laws
22:03:54 <Cale> Laws are statements.
22:03:55 <geezusfreeek> SamB_XP: as ddarius said, reality is a human invention. then again, delving into such things is a very philosophical matter
22:04:25 <SamB_XP> I was assuming that ddarius was ... er, using reductio ad absurdium ...
22:04:36 <ddarius> Hah, fooled you both!
22:04:38 <SamB_XP> he doesn't honestly disbelieve in his own existance?
22:04:46 <geezusfreeek> some people don't
22:04:47 * Axman6 passed physics!
22:04:55 <Axman6> whoot, won't have to do any more of it again
22:04:56 <ddarius> You need to remember that this is the internets.
22:04:58 <dobblego> existence
22:05:18 <SamB_XP> dobblego: that's what I said ;-P
22:05:29 * ddarius is going to not do homework and then go to sleep before people take more of what he says seriously.
22:05:37 <dobblego> SamB_XP, I'll keep harping until you do :)
22:05:49 <SamB_XP> existence?
22:06:13 <SamB_XP> ther, r u hapy eye speled itt rite??
22:06:32 <mjrosenb> SamB_XP: you spelled the movie wrong
22:06:49 <SamB_XP> mjrosenb: what movie?
22:06:57 <geezusfreeek> "the world or state of things as they actually exist, as opposed to an idealistic or notional idea of them"
22:07:08 <mjrosenb> SamB_XP: the movie is spelled existenz
22:07:22 <mjrosenb> http://www.imdb.com/title/tt0120907/
22:07:23 <lambdabot> Title: eXistenZ (1999)
22:07:29 <SamB_XP> geezusfreeek: you don't think there is such a thing?
22:07:42 <SamB_XP> it's kind of preposterous to say that we invented such a thing
22:07:43 <Cale> I don't assume the existence of an objective reality, because it's superfluous. You don't need it in order for science to work nicely.
22:07:53 <SamB_XP> if we invented it, it does not exist
22:08:03 <Cale> And I see nothing about that assumption which is useful in any way.
22:08:08 <geezusfreeek> SamB_XP: i'm not going to say one way or another whether i believe in reality. i would rather pose the question "does it matter whether there is a 'reality' or not?"
22:08:23 <SamB_XP> geezusfreeek: there must be some
22:08:28 <SamB_XP> or we aren't having this conversation
22:08:31 <Cale> What conclusion could you possibly make by assuming that there's an objective, but fundamentally unknowable reality?
22:08:32 <geezusfreeek> SamB_XP: why is it important?
22:08:49 <SamB_XP> Cale: who said anything about unknowable?
22:08:52 <geezusfreeek> SamB_XP: this conversation could be in your head, or in my head
22:08:57 <geezusfreeek> this conversation might not exist
22:08:59 <SamB_XP> but our knowing it isn't what makes it be, is it?
22:09:11 <SamB_XP> geezusfreeek: in that case, whoever's head must exist
22:09:18 <geezusfreeek> must it?
22:09:29 <dmwit> I've seen eXistenZ
22:09:34 <Cale> SamB_XP: Well, okay... how do you propose to determine anything about this objective reality?
22:09:37 <dmwit> It is thoroughly blah.
22:09:44 <geezusfreeek> my point, regardless, it that it doesn't matter what exists and what doesn't
22:09:46 <SamB_XP> Cale: as a constructivist, I can't really say anything one way or the other on whether we can know it
22:10:06 <geezusfreeek> SamB_XP: you are a constructivist?
22:10:08 <Cale> All we appear to have are our subjective observations.
22:10:10 <SamB_XP> or know whether the reality we percieve is the real one
22:10:30 <Cale> (and they've served us quite nicely so far)
22:10:33 <SamB_XP> but empiracally it certainly seems that there is a reality in which we exist
22:10:46 <Cale> What does that statement mean?
22:10:50 <SamB_XP> I mean, it's a heck of a lot more consistant than my dreams ...
22:11:04 <dobblego> consistent
22:11:11 <Cale> That in most current physical models, there is a single mathematical object which is treated as the universe?
22:11:15 <SamB_XP> hmm, I'm going about this wrong
22:11:19 <geezusfreeek> SamB_XP: in what sense are you a constructivist? surely you don't mean in the philosophical sense. what you are saying doesn't really line up with that i don't think
22:11:22 <vixey> it's ridiculous to assume there's some equations of physics which model everything correctly
22:11:28 <geezusfreeek> you mean in the mathematical sense?
22:12:01 <vixey> it's much worse to assume there's one logic or foundation of mathematics you can do everything with
22:12:04 <Cale> SamB_XP: How would you go about testing empirically that there's a single objective universe?
22:12:13 <mjrosenb> vixey: why would you assume that?
22:12:23 <Cale> SamB_XP: I want to see your control :)
22:12:25 <SamB_XP> Cale: it'd be stupid to try
22:12:27 <geezusfreeek> hmm, "consistent" is an interesting word in the context of reality. would reality really be consistent, or would it be complete?
22:12:27 <vixey> I don't
22:12:39 <SamB_XP> Cale: we can't disprove others existance
22:12:46 <dobblego> existence
22:12:52 <Cale> SamB_XP: What can you conclude from the assumption that there is a single objective universe which is of practical use?
22:12:57 <dmwit> others'
22:13:00 <SamB_XP> it would be like trying to break out of the game of life
22:13:06 <Cale> SamB_XP: exactly.
22:13:11 <SamB_XP> and see the implementation of life
22:13:12 <geezusfreeek> dobblego: it took me a few goes to figure out what you are doing there ;)
22:13:14 <dobblego> dmwit, just working on -ant and -ent :)
22:13:18 <Cale> SamB_XP: So my take is not to talk about that object any further.
22:13:20 <SamB_XP> but we can still try to find some rules that explain it as well as possible
22:13:32 <geezusfreeek> SamB_XP: explain what?
22:13:41 <Cale> SamB_XP: and just go with what we seem to actually have, which are observations.
22:13:50 <SamB_XP> and it seems we've a heck of a lot more success with that than any organisms in "life" are likely to...
22:14:00 <SamB_XP> Cale: yeah. but there seem to be rules...
22:14:20 <Cale> SamB_XP: We have had lots of success in finding rules which fit our subjective observations.
22:14:23 <SamB_XP> I mean, it's not like we are the output of /dev/random or anything
22:14:32 <Cale> SamB_XP: and which continue to do so, and that's great
22:14:47 <Cale> SamB_XP: But it doesn't mean that there's an objective reality, just that we've found some rules that work
22:14:51 <dmwit> SamB_XP: Are you sure?  Quantum physics suggests otherwise. ;-)
22:15:12 <SamB_XP> dmwit: I didn't say randomness had no place
22:15:28 <SamB_XP> but /dev/random exhibits randomness with no structure to it
22:15:35 <_zenon_> What exactly are we debating / discussing ?
22:15:46 <SamB_XP> well, beyond the artifacts of it's imperfect implementation
22:15:49 <Cale> _zenon_: The existence of an objective reality.
22:15:50 <mjrosenb> SamB_XP: that hasn't been proven
22:15:52 <dmwit> _zenon_: The very meaning of life itself!
22:15:58 <SamB_XP> Cale: there could be more than one
22:16:11 <SamB_XP> we could be nested several deep
22:16:31 <_zenon_> dmwit: Oh no, luckily I am impervious to existential discussions. I say, live, fork yourself and die.
22:16:34 <Cale> SamB_XP: It's the same reason that I don't really like assuming the existence of a god.
22:17:04 <Cale> SamB_XP: You can't conclude anything really useful from it (which you couldn't already conclude without it), and there's no way to check.
22:17:05 <geezusfreeek> why can't randomness have structure?
22:17:18 <_zenon_> dmwit: The whole, "meaning of life" starts of wrong, you can't just assume as a start that there MUST be some kind of meaning, and then go off looking for it.
22:17:18 <SamB_XP> geezusfreeek: it can
22:17:26 <ixdy> debian thinks randomness can have structure
22:17:36 <geezusfreeek> we could just be in a portion of /dev/random which _appears_ to have structure :P
22:17:58 <Associat0r> I agree, randomness has structure
22:18:07 <_zenon_> geezusfreeek: Then someone is observing it, or else it would not appear to have structure.
22:18:23 <geezusfreeek> this is with the assumption of an observer, yes
22:18:33 <SamB_XP> anyway, pragmatically, there is a reality ;-P
22:18:44 <_zenon_> define reality ?
22:18:49 <geezusfreeek> how is it pragmatic to believe in a reality?
22:18:53 <_zenon_> Maybe you already made that .
22:19:25 <dmwit> "I have now had my coffee and instantly feel like I need another."
22:19:28 <SamB_XP> geezusfreeek: well, people who don't think that there is not a reality don't tend to talk about pragmatism much...
22:19:50 <SamB_XP> er.
22:19:51 <dobblego> people who talk about pragmatism, often don't realise what it entails
22:19:54 <SamB_XP> too many negations
22:19:59 <_zenon_> SamB_XP: Please define the term reality, it seems like an important cornerstone here.
22:20:27 <vixey> _zenon_: the usual meaning of the word
22:20:28 <SamB_XP> how about I just call it The Matrix
22:20:35 <SamB_XP> will that make things clearer?
22:20:41 <Cale> SamB_XP: Well, there is (or may be) the 'reality' which exists as part of the model of our observations.
22:21:00 <Cale> SamB_XP: Which is what I talk about when I talk about reality. :)
22:21:11 <_zenon_> vixey: Well, since this is a pholosophical "debate", why not structure it? Reality as far as I can see, seems to have many an interpretations.
22:21:14 <Cale> But it's a formality, just like 1 :)
22:21:25 <geezusfreeek> the only meaningful definition i can attribute to the word is "something which invisibly drives our observations," which i still think is rather useless
22:21:26 <vixey> SamB: I just don't understand how you can be a constructivist.. what does it mean? there are other logics to do maths in so what is naming one out of them about ?
22:21:47 <Cale> vixey is clearly a formalist like me :)
22:22:06 * vixey must look that up 
22:22:26 <Associat0r> this discussion is futile, there is no way to prove nor disprove any of all this
22:22:38 <_zenon_> No one has still defined reality
22:22:43 <vixey> this discussion is futile, surrender your weapons.
22:22:47 <Cale> Well, actually that term annoyingly disregards some subtlety in the way that I think about mathematics.
22:22:51 <geezusfreeek> _zenon_: i have given my contextual definition
22:23:02 <SamB_XP> classical disjunction makes my head hurt as badly as scheme's call/cc
22:23:20 <Cale> But largely, I'm a formalist -- that is, I think of mathematics as a set of formalisms, and not as something with any existence independent of our own.
22:23:37 <SamB_XP> mathematically, that's what mathematics is
22:23:50 <Cale> SamB_XP: Really, it's pretty simple. (Classical disjunction)
22:23:53 <_zenon_> geezusfreeek: true, but we have not seemed to reach an agreement.
22:24:04 <SamB_XP> Cale: maybe so is scheme's call/cc
22:24:06 <vixey> Classical disjunction is another name for LEM ?
22:24:13 <SamB_XP> but that doesn't stop it hurting my head
22:24:13 <geezusfreeek> _zenon_: i doubt we will. this seems to be a chaotic conversation
22:24:23 <Cale> It's much easier than call/cc
22:24:30 <vixey> well what happens if we convert all our maths into CPS :P
22:24:48 <SamB_XP> I once read an anecdote involving the devil and a million dollars
22:24:50 <nwf> Forgive me for interjecting something off-topic, but is it possible for me to force a {major,minor} GC collection pass while sitting at GHCi's prompt?
22:25:05 <vixey> @hoogle garbage
22:25:06 <lambdabot> No matches found
22:25:07 <geezusfreeek> nwf: that is far more on topic than what we are talking about :P
22:25:12 <Cale> nwf: That's more on topic than we are :)
22:25:16 <SamB_XP> nwf: I hope that was sarcasm
22:25:23 <vixey> I'm sure there's a way
22:25:27 <nwf> The first part may have been tongue-in-cheek. :)
22:25:35 <Cale> :t System.Mem.performGC
22:25:35 <lambdabot> IO ()
22:25:58 <SamB_XP> anyway, I better go to bed
22:26:07 <nwf> Thanks much. :)
22:26:09 <SamB_XP> because existance or not, I'm expected to be in class tomorrow
22:26:13 <_zenon_> SamB_XP maybe you will go to the reality now,
22:26:16 <vixey> nn
22:26:20 <geezusfreeek> existence
22:26:23 <SamB_XP> stop it
22:26:27 <_zenon_> SamB_XP: maybe the "awake" state is the dream ;)
22:26:30 <Cale> Clearly, we need to add some new features to Haskell before we all turn into philosophers.
22:26:34 <geezusfreeek> aw it's the first time i did it
22:26:36 <SamB_XP> _zenon_: I really don't think so
22:26:36 <_zenon_> Cale: indeed
22:26:43 <SamB_XP> because I never start dreaming with pins and needles
22:26:48 <SamB_XP> but often wake up with them
22:26:48 <_zenon_> SamB_XP : Not me either.
22:26:58 <SamB_XP> also my dreams make no sense
22:27:05 <SamB_XP> often
22:27:10 <geezusfreeek> i never wake up falling, but i sure dream about it
22:27:41 <SamB_XP> I should never have used that "hover with L" cheat in zelda -- it wrought havoc on my dream flying ...
22:27:44 <geezusfreeek> heh, my reality makes no sense
22:27:46 <Cale> SamB_XP: Heh, maybe that's just what 'reality' is like, and this is the dream world we go into when we just want everything to make sense again.
22:27:47 <SamB_XP> I'm completely serious
22:27:48 <dolio> Your (my) dreams often make sense at the time. They only don't make sense in hindsight.
22:27:57 <_zenon_> Cale: Precisely
22:28:06 <SamB_XP> I can't frickin READ in dreams
22:28:13 <geezusfreeek> SamB_XP: i can :P
22:28:21 <SamB_XP> I go back to re-read, and the words have changed
22:28:28 <_zenon_> SamB_XP: So, maybe you dream you can, because you wish it.
22:28:29 <Cale> SamB_XP: interestingly enough, I can still recognise Kanji in my dreams, even though I can't read.
22:28:40 <SamB_XP> I could recognize words
22:28:46 <_zenon_> SamB_XP: So, this is just a dream.
22:29:02 <SamB_XP> it's just that they never stay put after
22:29:11 <SamB_XP> so there are other words instead
22:29:16 * shepheb never remembers any dreams, ans feels like he's missing out
22:29:24 <dmwit> The best dreams are the ones where you know you're dreaming, and you can control everything about the dream.
22:29:26 <dmwit> Man, those rock.
22:29:33 <SamB_XP> actually, I don't think I actually read them, I think I just believe myself to be reading them when dreaming
22:29:38 <_zenon_> dmwit: Never had anny of those.
22:29:54 <dmwit> _zenon_: I only get them when I'm quite well-rested.
22:29:54 <SamB_XP> yeah, it's cool when you can stop a nightmare that way
22:30:12 <SamB_XP> I should try that next time I have trouble finding my way around a building
22:30:13 <dmwit> i.e. towards the end of weekends
22:30:29 <SamB_XP> or dream that I am simultaneously enrolled in multiple colleges
22:30:56 <_zenon_> SamB_XP : hhehee, that's a nice one.
22:30:59 <Cale> hehe
22:31:15 <_zenon_> SamB_XP: Do you have to attend multiple lectures then?
22:31:15 <SamB_XP> or have just started at a new school, possibly having missed a week or two of classes
22:31:22 <SamB_XP> _zenon_: no, worse!
22:31:30 <SamB_XP> I have to miss some
22:31:37 <SamB_XP> or just be wondering if I am
22:31:46 <dmwit> I hereby declare that all words containing only 'h' and 'e', and beginning with 'h', will signify some form of outbreak of laughter!
22:31:51 <dmwit> heeeeeeeeeeeeeeeeeeeeehehehehhhhhhhe
22:32:07 <SamB_XP> you wouldn't believe how often I dream about worrying that I am missing some class that somehow slipped my mind
22:32:20 <SamB_XP> hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh
22:32:25 <dmwit> You're lucky you just dream of it.
22:32:26 <dolio> That happens to me a lot, too.
22:32:32 <dmwit> I missed a midterm last quarter.
22:32:34 <dolio> And I haven't taken any classes in a while.
22:32:43 <_zenon_> SamB_XP: Sucks. But then you _know_ you are missing out, worse if you miss out and get that afterwards.
22:32:43 <Cale> heeheeeheeeeeheeeeeeeheeeeeeeeeeeheeeeeeeeeeeee...
22:32:50 <SamB_XP> well, it's not nearly as bad when I'm *actually* missing classes as just dreaming about worrying that I *might* be
22:33:09 <SamB_XP> in my dreams, I can even worry that I am missing an entire semester at a different school
22:33:17 <SamB_XP> I think it's because I'm on my third college now
22:33:28 <dmwit> heh
22:33:35 <_zenon_> SamB_XP: Moving around a lot?
22:33:41 <SamB_XP> (first Lehigh University, then Delaware County Community College, now Widener University)
22:33:59 <araujo> SamB, 3 careers?
22:34:01 <SamB_XP> _zenon_: hmm, I had ... issues at Lehigh
22:34:20 <_zenon_> SamB_XP: Okay.
22:34:27 <SamB_XP> I still have a lot of those issues but I'm doing a heckofa lot better in school
22:34:35 * vixey wonders what issues..
22:34:47 <SamB_XP> speaking of which, one of the issues is spending too much time on IRC when I should be sleeping or doing homework
22:34:50 <SamB_XP> so I'll go to bed now
22:34:53 <SamB_XP> ;-)
22:35:01 <_zenon_> SamB_XP: Have a nice waking up :)
22:35:11 <quicksilver> funny you should say that.
22:35:14 * araujo hates those dreams
22:35:14 <SamB_XP> (others are spending too much time reading webcomics or programming ;-)
22:35:22 <quicksilver> one of my issues is spending time sleeping when I should be on IRC>
22:35:29 <_zenon_> :D
22:35:53 <SamB_XP> how the heck is that possible?
22:36:19 <SamB_XP> spending time sleeping when you should be on IRC
22:36:54 <SamB_XP> okay if you don't answer real quick I'm really going to be gone to bed
22:37:05 <SamB_XP> did you go to sleep or something?
22:37:33 <vixey> lol
22:37:33 <_zenon_> SamB_XP: I am typing from my awake state.
22:37:47 <_zenon_> xkcd :=> dream typing,
22:38:00 <SamB_XP> ???
22:38:11 <SamB_XP> you think xkcd is made in the author's sleep?
22:38:54 <QtPlatypus> SamB_XP: In xkcd theer was an experment involving a person typing while they where asleep.
22:38:55 <_zenon_> http://xkcd.com/269/
22:38:56 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
22:39:05 <SamB_XP> oh, that
22:39:12 <SamB_XP> yeah, I'm sure I read that one ;-)
22:39:34 <_zenon_> TCMP = Trans-Consciousness Messaging Protocol
22:39:38 <_zenon_> ;)
22:40:02 <SamB_XP> what's the RFC number?
22:40:07 <SamB_XP> okay, seriously, bed...
22:40:45 <_zenon_> SamB_XP: Yeah, go to bed now.
22:44:24 <dobblego> think -ent while you're getting to sleep
22:55:07 <newsham> rfc1217 i believe
22:58:39 <newsham> > let add [] ys = ys; add (x:xs) ys = add xs (x:ys); mul [] ys = []; mul (x:xs) ys = add ys (mul xs ys) in mul "111" "1111x"
22:58:40 <lambdabot>  "x1111x1111x1111"
23:01:34 <_zenon_> http://www.faqs.org/rfcs/rfc1217.html
23:01:35 <lambdabot> Title: RFC 1217 (rfc1217) - Memo from the Consortium for Slow Commotion Research
23:02:00 <_zenon_> newsham: You lied.
23:02:07 * _zenon_ must learn php now.
23:02:54 <newsham> neutrinos, esp, wahtever.
23:09:15 <dobblego> ?type guard . not -- what is a good name for this function?
23:09:16 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
23:10:29 <vixey> why not write guard (not $ ...) ?
23:10:51 <dobblego> because I like composing functions
23:11:03 <dobblego> and sometimes naming those compositions
23:11:19 * vixey is really copping out because she can't think of a good name for it..
23:11:27 <dobblego> unguard :)
23:11:44 <_zenon_> enguarde
23:11:55 <_zenon_> engarde
23:12:15 <newsham> failIf = guard.not  ?
23:13:05 <_zenon_> newsham: Hm, that at least uses the name fail, which conforms better.
23:13:33 <_zenon_> at little lisp-ish:  failP
23:15:40 <newsham> unfoldWhile p f = unfoldr (\x -> guard (not (p x)) >> return (f x))
23:16:15 <newsham> err, i guess that would be unfoldUntil
23:16:41 <quicksilver> dobblego: inhibit
23:16:51 <quicksilver> inhibit (x > 5)
23:16:57 <dobblego> hmm thanks
23:17:06 <quicksilver> or prevent maybe
23:17:08 <vixey> @w80 inhibit
23:17:08 <lambdabot> *** "inhibit" wn "WordNet (r) 2.0"
23:17:08 <lambdabot> inhibit
23:17:08 <lambdabot>      v 1: to put down by force or authority; "suppress a nascent
23:17:08 <lambdabot>           uprising"; "stamp down on littering"; "conquer one's
23:17:08 <lambdabot>           desires" [syn: {suppress}, {stamp down}, {subdue}, {conquer},
23:17:10 <lambdabot> [3 @more lines]
23:17:10 <vixey> @w80 prohibit
23:17:12 <lambdabot> *** "prohibit" wn "WordNet (r) 2.0"
23:17:14 <lambdabot> prohibit
23:17:16 <lambdabot>      v : command against; "I forbid you to call me late at night";
23:17:18 <lambdabot>          "Mother vetoed the trip to the chocolate store" [syn: {forbid},
23:17:20 <lambdabot>           {interdict}, {proscribe}, {veto}, {disallow}] [ant: {permit},
23:17:22 <vixey> forbid!
23:17:22 <lambdabot>           {permit}]
23:17:48 <quicksilver> forbid would work but inhibit has a more mysteriously quality which I quite like :)
23:17:56 <vixey> hehe
23:17:57 <newsham> > let unfoldUntil p f = unfoldr (\x -> guard (not (p x)) >> return (f x)) in unfoldUntil (== 0) (\x -> (x `mod` 10, x `div` 10)) 1942
23:17:58 <lambdabot>  [2,4,9,1]
23:18:12 <quicksilver> "exclude" ?
23:18:14 <_zenon_> inhibit sounds more sci-fi also
23:18:36 <hpaste>  morrow pasted "(no title)" at http://hpaste.org/8775
23:18:37 <_zenon_> like::: inhibitory neurons
23:18:52 <newsham> forbid?
23:19:43 <newsham> ohNoYouDidnt = guard.not ?
23:19:47 <_zenon_> :D
23:19:50 <vixey> cool mmorrow!
23:37:59 <_zenon_> Do we have all the # history stored somewhere?
23:38:42 <hpaste>  (anonymous) annotated "example for don" with "also" at http://hpaste.org/8776#a1
23:38:58 <DarthShrine> _zenon_: http://tunes.org/~nef/logs/haskell/ ?
23:39:00 <lambdabot> Title: Index of /~nef/logs/haskell
23:39:25 <_zenon_> WOho
23:39:27 <_zenon_> Candy,
23:39:47 <_zenon_> Shall try to wip up something completely useless, but still fun.
23:40:25 <_zenon_> But those are the 2004-2005 ?
23:40:32 <_zenon_> Where are 2005 -> ?
23:41:10 <DarthShrine> Let it load more ;)
23:42:14 <_zenon_> Ah,, there we go
23:42:19 <_zenon_> Thanks
23:45:09 <_zenon_> I am thinking something along the lines... markov chain + channel history
23:57:00 <_zenon_> Sounds good?
23:57:31 <_zenon_> I know this will obviously involve a huge amount of fileinput, is there a good way to read from files without lazyness ?
23:58:47 <astrolabe> I often wonder that
23:59:59 <astrolabe> I think you might want lazyness in this case though.  The files might be too big to read in in one chunk.
