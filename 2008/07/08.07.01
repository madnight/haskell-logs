00:00:05 <dolio> @check \n -> let f n = n `div` 2 ; g n = n * 2 in f (g n) == (n :: Integer)
00:00:08 <lambdac>  OK, passed 500 tests.
00:00:17 <dolio> @check \n -> let f n = n `div` 2 ; g n = n * 2 in g (f n) == (n :: Integer)
00:00:18 <lambdac>  Falsifiable, after 3 tests: 3
00:01:33 <dons> new library binding, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/download-0.1
00:01:36 <lambdac> http://tinyurl.com/5xdzpv
00:01:59 <dons> libdownload (openURI "ftp://foo.org/bah" , parseURI "http://google.com" , openURIString "file:///tmp/x")
00:02:04 <lambdac> Title: Google
00:02:22 <mmorrow> sweetness
00:02:32 <dons> a bit like hpricot for ruby, I guess.
00:02:45 <dons> very new though, so feedback welcome.
00:04:17 <solrize> nice!!
00:07:22 <solrize> lumi i did euler 14 in haskell a while back, it wasn't hard
00:08:39 <dons> dcoutts_: my ghc-pkg is painfully slow with 450 packages installed
00:09:04 <lumi> solrize: Could you show me your version?
00:15:49 <wuxia> i'm on  ubuntu, when i try to import SOEGraphics, i get errors; yet I have hgl-dev installed on my ubuntu system
00:15:54 <wuxia> how do i debut this?
00:17:48 <wuxia> ah, it's immport Graphics.SOE
00:17:49 <solrize> sec
00:18:07 <wuxia> but now i get different comppile errors, as if i have the wrong -l options for gcc; waht is the equiv for ghc?
00:18:10 <hpaste>  solrize pasted "euler 14, done just now" at http://hpaste.org/8648
00:18:43 <solrize> hs$ time ./collatz
00:18:43 <solrize> (837799,524)
00:18:43 <solrize> real	0m8.619s
00:18:43 <solrize> user	0m8.613s
00:18:44 <solrize> sys	0m0.000s
00:18:46 <ziman> wuxia, i guess it's the -package flags, or use --make, which will link all needed packages automatically
00:19:10 <solrize> i doubt i did it in an especially efficient way
00:21:07 <wuxia> hey, i like --make, it's like blackmagic
00:21:36 <ziman> quite useful magic ;)
00:24:26 <solrize> lumi see hpaste
00:26:01 <lumi> solrize: Thanks, how long does it take to run?
00:26:08 <solrize> 8 sec
00:26:41 <solrize> i'm sure it could be made a lot faster
00:29:28 <solrize> @google goodstein sequence
00:29:31 <lambdac> http://en.wikipedia.org/wiki/Goodstein's_theorem
00:33:51 <augustss_> what about goodstein?
00:34:34 <solrize> well there's the collatz sequence, which is unproven to converge in a finite number of steps but in practice it always seems to do so pretty quickly
00:34:45 <solrize> and goodstein's sequence is the exact opposite
00:34:52 <solrize> it's known to always converge but takes an AWFUL long time
00:39:11 --- mode: irc.freenode.net set +o ChanServ
00:39:29 <Gilly> pretty easy, had done that long ago but in C i think (before I learned haskell :))
00:39:29 <solrize> i don't see your paste
00:39:29 <glguy> it can run in ~2.0 seconds on a core2duo 1.8ghz
00:39:29 <solrize> http://hpaste.org/8649
00:39:32 <Gilly> yea it's easy if you cache those lengths
00:39:36 <solrize> i didn't want to use int->int because haskell ints are unsafe
00:39:38 <Gilly> i think that's how i did it in the first place
00:39:46 <solrize> i dunno how big the intermediate numbers become
00:40:02 <solrize> > let m=(383^383::Integer) in (fromIntegral m :: Int)
00:40:04 <lambdac>  -1313866113
00:40:06 <Gilly> well that version in hpaste i posted uses integers too
00:40:16 <glguy> oh, you actually generate the sequence itself??
00:40:27 <Gilly> yes :) and it works because ghc optimises enough
00:40:28 <solrize> your version is nice
00:40:44 <glguy> oh, it manages to fuse?
00:40:44 <solrize> it has the lambda nature :)
00:41:28 <Gilly> works well enough :) and a few extra seconds don't bother me much since the code is such a short and nice piece :P
00:41:53 <glguy> in 6.8, `shiftR` 1  seemed faster than `div` 2
00:42:12 <solrize> well the compiler should optimize stuff like that
00:42:18 <glguy> should
00:43:28 <glguy> compare `on` is Data.Ord.comparing (if you were interested)
00:43:43 <solrize> data.function pulled that in?
00:44:30 <Gilly> oh, nice :) gonna use that from here on
00:46:42 <solrize> augustss_ is it possible to call agda code from haskell without a lot of contortions?
00:47:06 <solrize> can agda more or less export haskell after typechecking?
00:48:03 <solrize> the "power of pi" paper makes it look like some everyday coding tasks are actually easier in agda than haskell
01:30:10 <Dae> Hey...mmm.. I'm trying to profile an application using stream-fusion lists, but it keeps telling me to install the profiling libraries for stream fusion. Anyone know what I'm supposed to do?
01:30:46 <Dae> I installed stream-fusion using cabal-install if that's any help
01:30:51 <quicksilver> pass appropriate options to cabal-install
01:30:55 <quicksilver> to install the profiling version.
01:34:35 <Dae> yeah.... doesn't seem to hange anything when I try "cabal install stream-fusion -p" ... just tells me it's resolving dependencies.... sorry for being sucha  newb...
01:35:07 <quicksilver> unfortunately I know very ittle about cabal
01:35:18 <quicksilver> do the _p libraries appear to have been installed?
01:35:25 <quicksilver> you get _p versions of everything when profiling is on.
01:39:02 <Dae> now might be a good time to find out where it uts the compiled files....
01:39:07 <solrize> hey quicksilver, what happens if you do a memory lookup and there's a page fault?  are all of your forkIO threads stopped?
01:39:41 <quicksilver> well that's an OS level question, I guess.
01:39:54 <solrize> yeah, that's why i thought of you :)
01:39:56 <quicksilver> if your OS suspends the entire process on page fault then of course that's what will happen.
01:40:07 <quicksilver> if your OS suspends only the current thread, not the entire process
01:40:17 <quicksilver> then if you're using the threaded RTS with more than one real thread
01:40:21 <quicksilver> you should be fine.
01:40:45 <opqdonut> what does linux do?
01:40:59 <solrize> hmm, 1) i wonder what linux does; 2) the usual strategy for OS threads is to use the same # of them as you have cpu cores, but this sounds like a reason to use more
01:41:02 <solrize> opqdonut, jinx :)
01:41:09 <quicksilver> haskell threads are lock-free w.r.t. each other (Except when you lock explicitly with MVars)
01:41:14 <ejt> Linux will suspend only the OS thread associated with the forkIO thread
01:41:37 <quicksilver> tehre is a small danger of wasted work when two haskell threads evaluate the same thunk
01:41:42 <quicksilver> but no danger of lock.
01:41:52 <quicksilver> (this is another danger of unsafePerformIO :P thunks can be reduced twice)
01:42:01 <solrize> !@
01:42:14 <quicksilver> well the 'unsafe' in the name is a clue, after all.
01:43:21 <solrize> so it sounds like AIO can beat mmap if you're in a paging situation
01:43:56 <quicksilver> I think that's the accepted wisdom.
01:44:04 <quicksilver> AIO exists for a reason :)
01:44:07 <quicksilver> because it's better.
01:44:09 <quicksilver> in the most general case.
01:44:11 <solrize> wow :)
01:44:39 <quicksilver> although I believe some people hate the API itself.
01:45:26 <solrize> yeah i've also heard that the linux implementation currently doesn't work very well
01:47:17 <quicksilver> I've never really worked on a program which was bottlenecking on page faults
01:47:28 <quicksilver> so, therefore, I've never had the motivation to dig deep into this stuff.
01:47:33 <quicksilver> obviously such programs do exist :)
01:47:59 <solrize> yeah, i think linux doesn't handle the situation very well.  but in the pre-linux era it was completely the norm.  i bet bsd does a reasonable job unless they messed it up since then
01:48:01 <ejt> once you start paging you're in real trouble anyway
01:48:31 <solrize> what you really want is usermode page fault handlers like in mach
01:49:06 <quicksilver> ejt: paging != swapping
01:49:35 <quicksilver> ejt: paging just means using the VM system / MMU to help you manage memory, as in e.g. using mmap() for large files.
01:49:44 <quicksilver> it's not necessarily a bad sign.
01:50:07 <quicksilver> but as solrize says, the implementation doesn't let you cope as nicely with page faults as you might like.
01:50:19 <ejt> yes
01:50:41 <quicksilver> you might hope your OS's IO layer is in a better position to schedule reads than you are
01:50:53 <quicksilver> and that relying on page faults to trigger disk reads is a good choice.
01:51:05 <quicksilver> and, indeed, it *is* a good choice under some sets of conditions.
01:52:14 <solrize> if the file fits in the linux buffer cache then seeking randomly on it and reading a byte takes about 70 usec, presumably due to context switches, so mmap should be close to 2 OOM better.  but as soon as you start paging that means multi-millisecond pauses maybe killing any advantage
01:54:10 <solrize> sounds like a really serious program would implement both approaches, mmap when there's enough memory and aio when there's not
01:54:48 <quicksilver> well depends on the big picture of your program.
01:55:10 <quicksilver> in many cases you don't care about multimillisecond pauses as long as they're not *wasted8
01:55:21 <quicksilver> if I can spend those multi-milliseconds servicing a different request
01:55:22 <fons> @seen dcoutts_
01:55:23 <lambdac> dcoutts_ is in #haskell. I last heard dcoutts_ speak 5d 16h 58m 57s ago.
01:55:25 <quicksilver> then they're not wasted.
01:55:34 <quicksilver> that's the typically server view.
01:55:44 <quicksilver> on the other hand, the realtime view is obviously different.
01:55:52 <quicksilver> the realtime view definitely cares about those milliseconds.
01:55:56 <solrize> right, that's why i was asking if the forkio threads freeze if ther'es a page fault
01:56:05 <solrize> this is from the server point of view
01:59:44 <solrize> i guess if there's more OS threads, they can possibly keep busy
02:02:11 <quicksilver> I have also wondered if it's worth doing (n+1) RTS threads
02:02:14 <quicksilver> in some cases.
02:02:20 <solrize> n=# of cores?
02:02:35 <quicksilver> I think it's probably (n+k) where k is the number of threads likely to be simultaneously blocked in FFI calls.
02:02:47 <quicksilver> note that haskell's standard IO stuff doesn't block any threads at all.
02:02:53 <quicksilver> it's only blocking FFI that matters.
02:03:05 <quicksilver> JaffaCake would know best.
02:05:42 <solrize> hmm
02:07:27 <solrize> i may ask him sometime... i'm a long way from having to be concerned about this stuff in practice but it's good to keep eyes on the prize, if that makes any sense
02:08:30 <Dae> bugger.... the files are there, all the _p files are there, it is fully capable of compiling normally, but not with prof...
02:09:09 <solrize> anyway thanks, i better go to bed... nite all
02:13:15 <quicksilver> Dae: Odd. I think you need dcoutts_ .
02:16:52 <Dae> quicksilver: ok, I'll try contacting him when he gets on
02:21:05 <malini> hi, can someone how to solve this problem: Could not find module `Data.Array
02:21:12 <malini> it is a member of package array-0.1.0.0, which is hidden
02:21:37 <ejt> change your cabal file
02:21:47 <ejt> so that it's not hidden
02:21:59 <malini> ok, what line do i have to add
02:22:06 <ejt> just checking ...
02:22:51 <quicksilver> malini: what are you compiling when you see this error?
02:22:55 <quicksilver> maybe you have an old version of it
02:23:01 <quicksilver> and maybe there is a newer version with a corrected
02:23:04 <quicksilver> cabal
02:23:34 <ejt> Build-Depends: array
02:23:36 <malini> its a little project of my own
02:23:38 <ejt> only a guess ^^
02:24:10 <quicksilver> yeah, you need to add all the packages you use to the depends line
02:24:26 <malini> thank you, it works now
02:27:24 <Dae> quicksilver: I think I sorta figure it out... tunrs out cabal saves all it's stuff in 3-4 different locations, and once you've installed it's a pain to uninstall. You can manually add the needed files in ~/.cabal/lib though...
02:27:43 <quicksilver> Dae: Hmm. It shouldn't be 3-4 different locations.
02:27:51 <quicksilver> 2 locations depending if you install locally or glboaly
02:28:00 * BeelsebobWork ponders if Andy Gill ever populates this channel
02:28:21 <quicksilver> BeelsebobWork: yes, he does. Although one seldom sees him speak.
02:28:30 <BeelsebobWork> you know what his nick is?
02:28:33 <quicksilver> BeelsebobWork: IIRC the nickname was andyjgill
02:28:45 <BeelsebobWork> cool, cheers
02:57:21 <solrize_> @whereis on
02:57:22 <lambdac> Maybe you meant: where where+
02:57:26 <solrize_> @where on
02:57:27 <lambdac> I know nothing about on.
02:57:31 <solrize_> @hoogle on
02:57:31 <lambdac> A Hoogle error occured.
02:58:26 <solrize_> @hoogle comparing
02:58:27 <lambdac> A Hoogle error occured.
02:58:30 <solrize_> @src comparing
02:58:30 <lambdac> Source not found. Where did you learn to type?
02:59:34 <ejt> Data.Ord
02:59:34 <RayNbow> @index comparing
02:59:35 <lambdac> bzzt
03:01:30 <ziman> solrize_, on is in Data.Function
03:02:13 <quicksilver> and comparing, I though, was in Data.List
03:02:20 <quicksilver> I guess lambdac doesn't have the index files or something?
03:02:35 <solrize_> ziman, found it, thanks
03:03:38 <ziman> @where anything
03:03:39 <lambdac> I know nothing about anything.
03:03:42 <ziman> :)
03:07:18 <luqui> f (x,y) = (x,y)  -- this == id right?
03:07:29 <quicksilver> well id restricted to a type, yes
03:07:42 <quicksilver> id restricted to (a,b) -> (a,b)
03:07:57 <luqui> (as opposed to f ~(x,y) = (x,y)  which is not quite id)
03:08:03 <luqui> but yeah, that's what I thought
03:08:31 <quicksilver> whether or not f ~(x,y) = (x,y) is id
03:08:37 <quicksilver> depends on the details of your semantic model :P
03:08:40 <osfameron> what's ~ ?
03:08:45 <quicksilver> lazy pattern match
03:08:51 <luqui> quicksilver, well in Haskell's semantic model!
03:08:59 <BeelsebobWork> luqui: not quite -- f undefined = error, while id undefined = undefined
03:09:12 <quicksilver> luqui: with which equality?
03:09:21 <osfameron> ah I remember not understanding the section on lazy pattern matching in SOE, must reread
03:09:25 <quicksilver> (hint: haskell's semantic model doesn't mandate a choice of equality ;P )
03:09:44 <quicksilver> so when we ask "is f === id" we have to be careful what "===" means.
03:10:00 <luqui> ah.  the one where we're allowed to use seq.
03:10:08 <quicksilver> observational equality, probably.
03:10:39 <quicksilver> BeelsebobWork: undefined and error are both _|_ in the standard semantics
03:10:42 <luqui> yes, which is not(?) the same as f  == id  <=>  f x == id x for all x
03:10:52 <quicksilver> BeelsebobWork: so, your counterexmample doesn't separate the two.
03:11:10 <BeelsebobWork> quicksilver: true, so essentially "there is an equality where they are not equal"
03:11:17 <BeelsebobWork> but then that's pretty obvious
03:11:28 <BeelsebobWork> perhaps, "there is a sensible equality where they're not equal"
03:13:26 <quicksilver> Can you give a haskell expression which behaves different on "f (x,y) = (x,y)" and "id :: (a,b) -> (a,b)" ?
03:16:12 <BeelsebobWork> oh, that's interesting, I expected f undefined to give a pattern match failure
03:16:56 <RayNbow> BeelsebobWork: Haskell has to evaluate the argument before deconstructing it for the pattern match
03:17:06 <BeelsebobWork> ah, ofc
03:17:58 <quicksilver> however, one certainly can for the ~-version.
03:18:11 <ziman> wouldn't a pattern match failure be equivalent to undefined?
03:18:39 <quicksilver> ziman: yes. modulo GHC's referentially-broken catch.
03:18:51 <BeelsebobWork> ziman: depends what semantic model you look at -- they print different things on the screen
03:18:57 <BeelsebobWork> so at some level, they have different behaviours
03:19:06 <quicksilver> concealing exceptions inside "_|_" is a neat trick but it breaks the semantics.
03:19:19 <quicksilver> because it enables you to distinguish different kinds of _|_.
03:20:06 <BeelsebobWork> gah, what package do I need to hide here? http://hpaste.org/8650
03:20:07 <solrize_> my 2.4 ghz(?) core 2 is over 5x faster than my 1ghz pentium 3
03:20:19 <BeelsebobWork> solrize: this is a surprise why?
03:20:38 <solrize_> i expected about the same ipc
03:20:48 <solrize_> that was on one core
03:20:58 <quicksilver> cache size probably.
03:20:58 <BeelsebobWork> inter process communication?
03:21:05 <BeelsebobWork> also... newer CPU design
03:21:15 <solrize_> nah this is just on that silly collatz program from a few pastes ago
03:21:16 <BeelsebobWork> ever the Core was an upgraded design over the PIII
03:21:29 <solrize_> should run totally in cache
03:21:36 <BeelsebobWork> and the Core2 is a completely redisigned chip again
03:22:03 <solrize_> well color me impressed
03:22:25 <BeelsebobWork> hehe, I was impressed when I discovered how much faster a 1.8Ghz Core2 was than my 1.25Ghz G4
03:22:37 <BeelsebobWork> it encodes video about 15 times faster
03:22:47 <BeelsebobWork> and that's even meant to be the ground the G4 is strong on
03:23:21 <quicksilver> I daresay your encoder wasn't using altivec.
03:23:28 <BeelsebobWork> plausable
03:23:45 <quicksilver> Pretty sure a decent altivec algorithm on a G4 outperforms a single-core Core 2, Ghz for Ghz.
03:23:47 <BeelsebobWork> the G4 is still actually a bit faster than the Core2 at encoding audio
03:23:55 <solrize_> i think i didn't see anything like a 5x speedup for openssl
03:25:42 <solrize_> http://www.engadget.com/2007/06/03/intel-reveals-quad-core-laptop-chip-in-the-pipeline-for-2008/
03:25:42 <quicksilver> BeelsebobWork: that's more like I'd expect.
03:25:44 <solrize_> woo hoo
03:25:45 <lambdac> Title: Intel reveals quad-core laptop chip in the pipeline for 2008 - Engadget, http://tinyurl.com/382dmz
03:28:29 <BeelsebobWork> quicksilver: the point where the Core2 really outshines that G4 though is compiling
03:28:38 <quicksilver> overall it's much much faster.
03:28:38 <BeelsebobWork> it compiles hat in about 30 seconds, compared to 20 minutes
03:28:41 <quicksilver> No denying it.
03:28:56 * quicksilver went from G4 iBook to Core2 Duo MacBook Pro
03:28:59 <quicksilver> quite a revolution.
03:30:10 <lorne> quicksilver: hey, me too
03:31:27 <quicksilver> lorne: and you can even fry eggs on that little part near the screen
03:31:30 <quicksilver> if you're careful
03:31:39 <quicksilver> just above the F-keys.
03:37:46 <RayNbow> solrize_: when will we see octocore laptops? :p
03:38:19 <solrize_> not soon
03:38:30 <solrize_> after 4-core it looks like they're doing 6-core
03:38:32 <quicksilver> RayNbow: 6 months? 8?
03:38:56 <quicksilver> sun is bringing out somethign which is almost a 256-core chip
03:39:01 <quicksilver> 256 hyperthread really, of course.
03:39:08 <solrize_> yeah
03:39:24 <solrize_> what's the idea of hyperthreading?  to be able to keep processing on taking a cache miss?
03:39:41 <solrize_> cache miss today is like an old-time page fault
03:40:04 <zx]treads> is it really necesssary? i mean, i have two cores in my desktop and i can't find a way to fully utilize them
03:40:24 <ejt> zx]treads: that's more a problem with current software
03:40:31 <solrize_> send 'em here, i'll use 'em :)
03:40:48 <solrize_> ghc -rts -n +2  is it?
03:40:50 <zx]treads> ejt: but will it be a change in software soon?
03:41:02 <solrize_> zx yeah, just recompile :)
03:41:16 <ejt> zx]treads: nope, it's a huge problem - STM is the only nice approach I've seen
03:41:17 <quicksilver> zx]treads: tehre is plenty of CPU bound software out there
03:41:29 <quicksilver> I've been doing quite a lot of graphics stuff recently
03:41:34 <quicksilver> it's quite easy to make that CPU bound
03:41:37 * RayNbow currently has a single core laptop :/
03:41:43 <solrize_> i want machines that can take a heck of a lot more ram, i wonder why they don't make those
03:41:46 <quicksilver> you just keep adding layers of stuff until your program slows down :)
03:41:51 <quicksilver> in principle, more cores will allow more stuff.
03:41:53 <RayNbow> I want a multicore machine so I can fiddle around with parallel stuff :p
03:42:01 <zx]treads> hope so. because right now i'm just golfing with haskell parallelism
03:42:06 <quicksilver> zx]treads: however it is true that "typical" stuff
03:42:06 <ziman> parallel haskell! :)
03:42:14 <zx]treads> ftw!
03:42:17 <solrize_> singularity
03:42:18 <quicksilver> e.g. running a word process, a text editor, or a web browser
03:42:21 <quicksilver> is not CPU bound
03:42:28 <quicksilver> (stupid flash adverts are sometimes, though)
03:42:29 <ziman> that sped up my raytracer much much
03:42:37 <solrize_> erlang-like concurrency done completely in the type system
03:45:23 <yitz> @bots
03:45:24 <lambdac> :)
03:45:36 <yitz> lambdac?
03:59:11 <mbz> @yarr
03:59:11 <lambdac> I heard andersca is a pirate
04:15:39 <troelsarvin> How to document software written in functional languages? - I.e., to an software implementor using OO, I might ask for documentation of the "logical" data model including classes and attributes. What should I ask for from someone implementing a solution in Haskell/functional languages?
04:16:21 <quicksilver> similar to the extent it applies
04:16:24 <quicksilver> documentation of the data types
04:16:27 <quicksilver> their invariants
04:16:33 <quicksilver> and the functions manipulating them
04:17:02 <SamB> identities that should hold
04:17:22 <mapreduce> I think compulsory documentation is harmful, unless it's checked mechanically.
04:17:39 <mapreduce> E.g., by a typesystem or by quickcheck.
04:19:02 <troelsarvin> mapreduce: I basically agree, but for various reasons, I have to ask for documentation. So I'm trying to find a suitable level and a relevant set of terms to ask for.
04:21:28 <mapreduce> Ask for quickcheck tests for all properties not discernable from the types. :)
04:21:42 <PeakerWork> does implementing Typeable require language support or is it possible to implement MyTypeable with identical semantics (ofcourse requiring a lot of instance declarations)
04:22:06 <SamB> PeakerWork: you can implement Typeable without language support
04:22:09 <mauke> as long as you have unsafeCoerce
04:22:16 <quicksilver> unsafeCoerce is language support.
04:22:23 <PeakerWork> what's unsafeCoerce?
04:22:23 <quicksilver> however you don't need it.
04:22:30 <SamB> unsafeCoerce isn't needed for Typeable
04:22:33 <quicksilver> serialisation is enough.
04:22:35 <PeakerWork> @src Typeable
04:22:36 <lambdac> Source not found. :(
04:22:40 <quicksilver> Read/Show or Binary, correctly implemented.
04:22:57 <SamB> it is probably needed for the cast thing, though, and definately for Dynamic
04:23:02 <quicksilver> no, it's not.
04:23:21 <quicksilver> unsafeCoerce can be replaced by (correct) instances of Read/Show or Binary
04:23:32 <quicksilver> which gives you a way to impement Dynamic without language support.
04:23:38 <PeakerWork> quicksilver, thanks, interesting :)
04:23:39 <quicksilver> of course, requiring lots of instances.
04:23:50 <SamB> well, if you want to implement them at the types at which they are found in Data.Typeable and Data.Dynamic, yes it is ;-P
04:24:27 <SamB> it would be far easier to just use unsafePerformIO to implement unsafeCoerce ;-P
04:24:33 <quicksilver> SamB: no it's not
04:24:47 <quicksilver> SamB: you end up with your serialisation class as a superclass of Typeable
04:24:53 <quicksilver> but then you can get the same types
04:25:04 <quicksilver> PeakerWork: see also http://www.haskell.org/pipermail/haskell-cafe/2008-May/042809.html
04:25:04 <SamB> quicksilver: that isn't the same type ;-P
04:25:06 <lambdac> Title: [Haskell-cafe] Data.Dynamic over the wire, http://tinyurl.com/5hdut4
04:25:09 <quicksilver> PeakerWork: which discusses the issues
04:25:18 <SamB> changing the class changes the type too
04:25:27 <quicksilver> yes but we're reimplementing typeable.
04:25:33 <quicksilver> that was the problem we were given
04:25:40 <quicksilver> so we're allowed to change typeable :)
04:25:49 <SamB> yes, but then existing code will not work ;-P
04:25:55 <SamB> even if it doesn't use deriving
04:25:58 <quicksilver> PeakerWork: of course, it's hard to serialise functions.
04:26:08 <quicksilver> PeakerWork: whereas the unsafecoerce version can cope with functions.
04:26:14 <quicksilver> (and various other types like IO a)
04:26:19 <SamB> quicksilver: is it hard to serialize functions?
04:26:25 <quicksilver> yes.
04:26:44 <SamB> ... I suppose that depends on which implementation you be using...
04:27:00 <PeakerWork> its easy to serialize Pythonic functions :)
04:27:16 <SamB> Peaker: does it work on lambdas ?
04:27:23 <SamB> I knew it didn't
04:27:58 <mauke> why does gcc hate me
04:28:18 <PeakerWork> SamB, sure it does
04:28:32 <PeakerWork> SamB, just serialize the bytecode and the cell objects
04:28:47 <PeakerWork> SamB, in Python, a lambda is just shorthand syntax for "def"
04:29:16 <SamB> mauke: I think it hates everyone
04:29:58 <mauke> also, I could need help with http://www.spoj.pl/problems/EXPR2/
04:30:01 <lambdac> Title: 13 Sphere Online Judge 8 (SPOJ) 10 - Problem EXPR2 193
04:30:19 <yitz> troelsarvin: I am also very interested in your question about documenting fp systems.
04:31:08 <yitz> troelsarvin: Of course, API doc methodology is pretty mature, with haddock being around for quite a while.
04:31:18 <PeakerWork> SamB, the semantics of function serialization are ofcourse somewhat weird due to side effects and access to a global environment
04:32:29 <yitz> troelsarvin: If you want to document structure, uml is general enough for that, but there are several ways to map fp into class diagrams, I wonder which is/are most useful.
04:33:21 <yitz> troelsarvin: Other than class diags., all the other uml diagram types apply to fp systems just like any other, I think.
04:35:11 <SamB> yitz: heh
04:35:33 <SamB> some of those diagram types -- did they ever really make any sense ???
04:36:40 <yitz> SamB: well, sequence diags. are used a lot by hardware designers.
04:37:15 <troelsarvin> use cases (which I guess is par of UML) is pretty language-type agnostic
04:37:24 <yitz> SamB: use case diags. are usually pretty stupid, yet they can be really useful when interacting between tech people and management/marketing/sales.
04:38:21 <SamB> how are they more usefull than not ???
04:39:36 <yitz> mm, sometimes people will go glassy-eyed unless you can point at something visual that illustrates what you are trying to say. use case diags. give a nice standard formalism for such things that have a consistent semantics.
04:39:40 <SamB> of course obviously use case diagrams apply equally well regardless of programming langauge (though not, of course, regardless of application)
04:40:44 <yitz> Activity diagrams may be of limited usefulness - they describe "flow of control". So I guess we could call them "IO Monad Diagrams" :)
04:41:40 <SamB> the state machine diagrams probably won't see a great deal of use with Haskell code ;-)
04:41:41 <yitz> Component diagrams show dependencies - I think work on Cabal shows that they can be useful in Haskell :)
04:42:19 <SamB> I bet Haskell code uses less kinds of arrows in component diagrams than Java code does
04:42:21 <yitz> SamB: or any other language, for that matter :). But if you are writing a state machine, then I guess you can use it.
04:43:09 <yitz> SamB: well I don't know, it depends. functions can be both objects and arrows.
04:43:10 <SamB> yitz: well, it makes a bit more sense with langauges where the APIs actually have mutable state
04:43:17 <Real_Boy_Love> http://psp1.vndv.com/vote.php?id=901 Love test for you. Please visit :) mr. Smith :)
04:43:18 <lambdac> Title: Âçåìè ñâîÿòà íàãðàäà
04:44:04 <Botje> rea lboy love you say?
04:44:38 <SamB> who the heck is mr smith
04:44:47 <Botje> too bad that site doesn't have some kind of abuse link
04:44:54 <Botje> or if there is, too bad it's in bulgarian
04:45:04 <SamB> I know a mr jones, but not a mr smith
04:46:43 <yitz> SamB: State diagrams can be useful when you're trying to implement a state-oriented protocol. Like IMAP4, for example.
04:47:12 <quicksilver> Botje: merely by visiting it you have, I imagine, voted for him.
04:47:39 <SamB> lol @ title attribute on http://xkcd.com/441/
04:47:40 <lambdac> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
04:47:52 <yitz> Or any other system whose definition is based on some complex collection of states.
04:48:11 <Botje> quicksilver: i removed the id=... part
04:48:48 <quicksilver> Botje: ah, not as stupid as you look ;)
04:48:57 <Botje> :)
04:49:05 <peti> SamB: State is inherent to the _problem_, not to the language in which you expresse the solution. Haskell programs have exactly the same amount of state as any other.
04:49:07 <Botje> I managed to get at least two spammer's accounts deleted this way
04:49:15 <quicksilver> they probaby don't care about abuse because they're getting ad revenue?
04:49:18 <quicksilver> or something simlar
04:49:32 <Botje> well
04:49:35 <Botje> in case of that site
04:49:35 <SamB> peti: it ain't so
04:49:36 <quicksilver> or at least, they may act to delete an account if they think they have to but they still don't really care :)
04:49:46 <Botje> removing an account means they don't have to pay out whatever the spammer wants
04:49:47 <SamB> peti: we tend to eschew state that is not part of the problem
04:49:55 <quicksilver> peti: no, that's not true.
04:50:00 <Botje> so everybody wins
04:50:08 <quicksilver> peti: other programs tend to have excessive amounts of mutable state.
04:50:10 <SamB> it's rather hard to do that in C
04:50:11 <Botje> (nb: spammers are not included under "everybody")
04:50:32 <quicksilver> peti: I totaly agree there is a certain amount of necessary state which may be part of the problem
04:50:45 <quicksilver> although for a given problem there may be other approachs requiring less
04:50:54 <quicksilver> state is a property of the solution.
04:51:11 <peti> quicksilver: No. The state is inherent to the algorithm, not to the programm. Haskell code *might* hide the state in lazy evaluation, but even that is rare (and typically not a good idea, because it's less efficient than explicit state).
04:51:29 <quicksilver> peti: I agree that state is inherent in the algorithm.
04:51:38 <quicksilver> peti: I disagree with your second point.
04:51:42 <SamB> peti: we generally don't use the same algorithm
04:51:42 <quicksilver> hiding state is not rare
04:51:47 <quicksilver> it is not inefficient
04:51:51 <quicksilver> and it is *not* a bad idea.
04:51:56 <quicksilver> it's an *extremely* good idea
04:52:02 <quicksilver> because it makes programs less buggy.
04:52:08 <peti> quicksilver: Note: hiding state by *lazy evaluation*.
04:52:13 <quicksilver> hiding state prevents a whole class of bugs
04:52:14 <SamB> and laziness is a heck of a lot less tricky than general state
04:52:25 <quicksilver> where you get the state out of sync, or inconsistent, in some way
04:52:55 <quicksilver> samb is of course right that often there are different algorithms, too.
04:52:58 <yitz> peti: state is heavily overrated. there are certain cases where it is important to view a system that way. but most of the time, people think that way only because they have been forced to rethink every problem in terms of state.
04:53:39 <SamB> there are, I'm sure, cases where state is more a part of a good solution than of the problem per-se
04:54:01 <quicksilver> but there are many cases where a C programmer will tend to use, e.g., a mutable global addition to the state
04:54:07 <peti> yitz: State is heavily overrated? What is that supposed to mean? :-)
04:54:11 <quicksilver> which will in teh long run either make bugs more likely, or refactorings harder
04:54:18 <quicksilver> or code less composable
04:54:25 <SamB> peti: that state isn't as good as people tend to think?
04:54:30 <quicksilver> mutable and global are both bad things
04:54:34 <quicksilver> both at once is really bad :)
04:55:14 <peti> quicksilver: I find it not very useful to use terms like "C programmers". If you have to separate people in groups, I'd rather distinguish good and bad programmers. Many people tend to use many different languages, and some languages are better for some purposes than others.
04:55:15 <SamB> see GIL
04:55:18 <jinjing> i thought they are xor ed
04:55:31 <Maya-sama> agreed, peti :)
04:55:35 <quicksilver> peti: well it was a shorthand term.
04:55:42 <SamB> peti: let us define "C programmer" as "programmer who is writing his code in C"
04:55:45 <quicksilver> peti: of course I agree with your comments that people are differnt &c.
04:55:47 <SamB> for the purposes of this discussion
04:55:47 <Maya-sama> hi SamB :)
04:55:56 <quicksilver> however people who habitually program in C tend to acquire certain habits.
04:56:00 <SamB> what are you doing here????
04:56:01 <quicksilver> and it is to those habits which I allude.
04:56:10 <SamB> I last saw you in #reactos
04:56:16 <Maya-sama> :)
04:56:18 <mauke> hah, if you could see the program I'm writing right now ...
04:56:19 <yitz> peti: people who do OO design will almost always begin by analyzing things in terms of state. Because state is the "nails" of the OO "hammer". But it's really not the best approach in most cases.
04:56:20 <quicksilver> it is easy to take the 'easy solution' which a particular language provides.
04:56:21 <Maya-sama> I've been here for the past few days ^^
04:56:25 <Maya-sama> got lured here by a friend
04:56:26 <Maya-sama> :P
04:56:29 <SamB> ah
04:56:33 <quicksilver> and yet there may be reasons why that easy solution is a poor idea.
04:56:35 <peti> yitz: Why not?
04:57:01 <SamB> Maya-sama: are you here for learning Haskell or for the wacky conversations?
04:57:12 <yitz> peti: see quicksilver above
04:57:14 <Maya-sama> mostly the latter right now ^^
04:57:16 <peti> yitz: If you have to manipulate state in order to solve an algorithmical problem, analyzing the state changes sounds like a pretty damn good idea.
04:57:26 <Maya-sama> I know virtually nothing about haskell so far :P
04:57:31 <yitz> peti: you usually don't have to
04:57:40 <peti> yitz: Is that so?
04:57:44 <quicksilver> peti: definitely. If you have to.
04:57:55 <quicksilver> however very few mathematical descriptions of algorithms are couched in state.
04:57:59 <SamB> or if it is desirable to do so
04:58:00 <quicksilver> state may be one way to implement it.
04:58:05 <quicksilver> but it is often not the best way.
04:58:06 <peti> yitz: Do you know many programs that do useful things without manipulating state?
04:58:13 <quicksilver> of course, there are definitely some cases where it is the best way.
04:58:43 <mauke> @quote steep
04:58:43 <lambdac> joelr says: the learning curve is far steeper with Haskell but it is far more elegant and readable
04:58:49 <SamB> peti: manipulating state doesn't mean there is anything resembling an FSM
04:59:27 <peti> yitz: You agree that most programs manipulate state? I.e. my means of the IO monad?
04:59:54 <SamB> and most of the code in most programs doesn't manipulate state...
05:00:00 <quicksilver> I think we may be about to descend into definitional hell of what we all meant by "state".
05:00:09 <quicksilver> I think this would be a boring direction for this argument to take.
05:00:35 <peti> SamB: Can you refer me to a paper or same other publication that demonstrates this fact empirically?
05:00:39 <ejt> ooh, is there an interesting direction ?
05:00:48 * SamB also notes that his Z-machine interpreter, which uses state entirely more than he would like, doesn't seem like it would benefit much from state diagrams, except perhaps in the string-decoding code
05:00:50 <quicksilver> I think it's interesting to return to the original comment by yitz, which was about state diagrams.
05:01:14 <yitz> peti: computers do two different things: they transform information, and they control physical systems. Every non-trivial system does both. Most non-trivial systems do primarily information processing, and a little controlling. The controlling parts involve state. The information parts don't.
05:01:15 <SamB> peti: empiracally???
05:01:21 <quicksilver> it is "obvious" both that all programs involve state, and all programs do not involve state.
05:01:31 <quicksilver> neither of these obvious views really contribute much here :)
05:01:48 <SamB> peti: look at e.g. your average compiler...
05:02:39 <peti> So we go back to where we started: Most programs do manipulate state. That fact doesn't have much to do with the language in which they are written. So state diagrams may very well be a pretty good tool to analyze the problem, regardless of the language that you, eventually, choose to implement the algorithm.
05:02:41 <Philippa> SamB: to be fair, I suspect the majority of code out there's embedded controllers and CRUD. Which sure looks stateful to most people
05:03:04 <SamB> hmm
05:03:09 <SamB> well, true
05:03:17 <Philippa> peti: or they may equally be a crap tool for most problems on account of being utterly inappropriate
05:03:42 * peti likes Haskell because it makes state manipulation *elegant*, i.e. by use of StateT and other monadic transformers.
05:04:09 <Philippa> to put it another way, because it lets you minimise stateful interactions so you can pin them down to exactly what you want?
05:04:23 <SamB> state diagrams are usually only useful with sum-typed states
05:04:28 <Philippa> (I'd still hate to analyse most of the stateful code I write via state diagrams)
05:04:33 <ejt> so we don't like state in our code, because we have little heads at it gets very hard to reason with - yet somehow we can cope with large state diagrams ?
05:04:38 <yitz> SamB: why?
05:05:05 <Philippa> yitz: because that's the definition of "state" they use
05:05:09 <yitz> ejt: when state is unavoidable, you need tools to work with it
05:05:13 <SamB> yitz: well, what do you use for the nodes otherwise?
05:05:23 <Philippa> a lot of us build programs where the number of states is infinite though
05:05:37 <peti> Philippa: Well, not quite. I feel that monads allow me to hide state when it's not needed. It's a hidden parameter, pretty much like "this" in a C++ object method.
05:05:43 <quicksilver> peti: "most programs manipulate state" -> so let's use state diagrams.
05:05:56 <peti> quicksilver: That is not what I said.
05:05:59 <quicksilver> peti: "all programs are pure functions" -> let's not use state diagrams.
05:06:14 <quicksilver> it is, actually, what you said. almost word for word.
05:06:17 <SamB> peti: how is it not what you said?
05:06:27 <quicksilver> my point is there is no neutral truth to "all programs manipulate state"
05:06:30 <quicksilver> that's just ONE model
05:06:33 <quicksilver> it's not the only model.
05:06:39 <quicksilver> you can also model all programs as pure functions.
05:06:55 <SamB> and, you know, if we don't actually write a "main" we don't have to manipulate state ;-)
05:07:06 <quicksilver> so the question si "Which is the best model for the analysis we want"
05:07:15 <quicksilver> and of course, you get different answers to that question.
05:07:18 <peti> quicksilver: Hmm, and "World" is one of the arguments to that pure function, right?
05:07:28 <SamB> peti: not necessarily
05:07:30 <quicksilver> I concur with the bulk view here that state diagrams are not often the best analysis.
05:07:33 <SamB> depends on the problem
05:07:46 <quicksilver> they are certainly handy for certainly "very stateful" problems.
05:07:53 <Philippa> state diagrams're shite at analysing general IO, anyway
05:07:55 <quicksilver> Like interacting with an external state machine, say.
05:08:10 <yitz> peti: typically, the stateful part of a program will be, say the GUI. If the GUI is very complex, a state diagram could be useful. Most of the time that diagram would be pretty trivial - though I could see it being a requirement in some development methodology nonetheless.
05:08:12 <hukolele> @src sum
05:08:13 <lambdac> sum = foldl (+) 0
05:08:22 <SamB> state diagrams may be more useful for certain pure functions than for almost anything involving IO, in fact ;-)
05:08:37 <Philippa> yitz: if the GUI is very complex, you strongly want to avoid having to look at it in the way a state diagram does
05:08:41 <yitz> hukolele: yeah, that's a sore point.
05:08:54 <SamB> I don't like GUIs that have state diagrams
05:08:56 <peti> yitz: Client/Server protocols tend to be stateful, too. Generally, all interaction with the outside world tends to be stateful, hence the IO monad.
05:09:08 <SamB> I friggin HATE modal dialogs
05:09:08 <yitz> peti: yes, I agree.
05:09:25 <yitz> Philippa: it depends in what way the GUI is complex.
05:09:42 <SamB> I mean, modal SAVE dialogs I think I can handle
05:10:00 <SamB> (or Open dialogs)
05:10:25 <SamB> or, oh, fatal errors ;-)
05:10:29 <Philippa> even stateful protocols I tend to think're better off examined in fairly grammatical terms with state kept a secondary concern for the most part
05:10:37 <peti> Anyway, I think that diagrams are overrated, no matter what kind it is. Diagrams tend to be useful because making one helps you to get your thoughts organized, but once it's done, you might just as well throw it away, because the diagram doesn't help other people to understand your thoughts.
05:10:45 <SamB> (what's friggin wierd are fatal error dialogs that are NOT modal.)
05:10:51 <Philippa> which is to say: minimise the 'state' to context-sensitivity-type stuff
05:10:57 <yitz> Philippa: I guess GUIs are the same as everything else - if you can avoid state in the design - you design will be better. But if state is inherent, you had better understand it.
05:11:27 <SamB> well, again, usually the state isn't the easily-diagramable type
05:11:35 <peti> Of course, management tends to be very impressed by diagrams, so there is a reason to keep them around.
05:11:36 <SamB> or would be better modeled as a grammar
05:11:52 <yitz> peti :)
05:12:00 <SamB> well, you could autogenerate a state diagram form the grammar ;-P
05:12:11 <SamB> s/form/from/
05:12:21 <quicksilver> A diagram is only useful (especially for management) if it has ten boxes or fewer on it.
05:12:36 <quicksilver> so diagramming as a practical method of communication requires considerable hand tuning.
05:12:52 <PeakerWork> SamB, "open" dialogs are stupid, I don't know anybody who uses them
05:12:56 <peti> SamB: The SMC state compiler actually does that. It's a rather neat tool that translates a semi-abstract FSM specification into a dozen different programming languages. Quite nice.
05:12:58 <Philippa> mmm. Otherwise, at least tail-recursive function definitions make it easy to search for the state you jumped to
05:12:59 <quicksilver> Of course, with the correct approach/tuning it can be a good way to communicate.
05:13:04 <yitz> peti: but no, sometimes diagrams are really helpful to understand someone else's design much more quickly. if done well.
05:13:18 <SamB> peti: granted, I don't like open dialogs a great deal
05:13:44 <SamB> but they are an okay place to paste a path, no?
05:14:21 <yitz> quicksilver, yes, good diagrams do require a lot of work. so there is always that cost/benefit thing.
05:15:41 <yitz> my original question was - what is the best way (or ways) to represent Haskell in UML class and object diagrams? any ideas?
05:15:55 <Philippa> "don't"
05:16:01 * Maya-sama runs away screaming at the mentioning of UML
05:16:12 * SamB is having difficulty with the axiom of dependent choice
05:16:18 <int-e> @bot
05:16:19 <lambdac> :)
05:16:21 * SamB doesn't understand how it actually says anything
05:16:30 <Philippa> you're probably better off with much older standards - Haskell's in many ways surprisingly understandable to a 70s mainframe coder
05:16:31 <codacola> why is it most programmers ive spoken to never use uml, and yet its alwasy said to be the industry standard?
05:16:54 <Philippa> codacola: a) manglers like it b) most programmers don't want to muck about with diagrams in the first place
05:17:23 <SamB> codacola: because also the people who claim it is the industry standard are often selling something
05:17:35 <olsner> apparently it's not an industry standard for programmers, but for things like educational institutions that need to prove that they're teaching OOP
05:17:48 <olsner> and to UML tool peddlers who need to prove they're selling something useful :P
05:18:03 <jinjing> maybe uml is based on OO, so not suited for FP..
05:18:16 <Philippa> for UK and/or happy-to-reach-the-UK people: AngloHaskell 2008's just had an announce mail on both the usual lists
05:18:25 <Philippa> jinjing: thoroughly so, yep
05:18:30 <PeakerWork> The "open dialogs" running as part of the application are the anti-thesis of capability security
05:18:39 <PeakerWork> (and of a good UI, cooincidence? Nah)
05:18:58 <olsner> the Haskell code will be a better model than the UML ever would be
05:19:14 <Philippa> olsner: to be fair, it's harder to be intentionally fuzzy in haskell
05:19:20 <Philippa> though undefined is very much your friend for that
05:19:28 <yitz> codacola: "industry standard" is not the same as "programmer standard"
05:19:54 <SamB> Peaker: so ... do you think ALL file opening should happen as the direct result of the user selecting a file in some kind of external process???
05:19:58 <quicksilver> I don't think it's all taht hard to imagine ways to use UML for haskell
05:20:02 <quicksilver> I think that's yitz's point too.
05:20:14 <quicksilver> You can diagram abstract types - and - operations - on - them
05:20:15 <quicksilver> say
05:20:20 <quicksilver> in quite a UMLish way.
05:20:27 <Philippa> SamB: not necessarily process, and you can pass it in to the app. Think of it as doing a dependency injection on OS calls, only not
05:20:31 <quicksilver> or you can diagram modules-and-interactiosn
05:21:04 <Philippa> for "real" use you'd probably set default caps for most of your apps on install or first run...
05:21:11 <SamB> yeah
05:21:32 <SamB> they'd certainly tend to want to be able to access all of the data they were installed with ;-)
05:21:36 <PeakerWork> UML just defines graphic entities and graphic relationships between them, no?  All the arrow diagrams are also UML'ish then
05:22:16 <SamB> you mean arrow as in the algebraic structure?
05:22:43 <yitz> If you take types as objects and functions as arrow, you get a category-theory-diagram-like kind of thing. But that doesn't seem right somehow.
05:22:44 <Philippa> Peaker: UML - the Union of all Modelling Languages :-)
05:22:52 <quicksilver> I think he might mean commutative diagrams?
05:23:03 <SamB> oh, those ;-)
05:36:03 <ejt> it might be a fun coding exercise to find a haskell program that is improved with the use of  diagram, and see if you can rewrite it so it doesn't need the diagram anymore
05:37:01 <olsner> maybe dataflow diagrams would actually have some use
05:48:24 <ski> SamB : what about DC ?
05:50:03 <osfameron> dammit!  I can't make anglohaskell
05:50:16 <osfameron> hmm, at a pinch I could do the friday.  But tis the day before holidays so maybe not
05:52:15 <Philippa> if it helps any, normally the talks're on friday w/curry and pubbage after
05:52:36 <Philippa> well, curry or other food. It's FitA that's really staked out the curry-is-traditional thing
05:52:51 <osfameron> FitA?
05:53:33 <quicksilver> fun in the afternoon
05:53:41 <osfameron> ah no, my flights out are on friday anyway, maybe next year!
05:53:44 * osfameron googles
06:21:42 <ivanm> would anyone have any idea who first coined the term "information age" and when?
06:24:51 <MyCatVerbs> Philippa: how concrete are the plans for this year's AngloHaskell at the mo?
06:27:06 <Philippa> MyCatVerbs: take a look at the wiki page? There's room for some flexibility, but we're just over a month out and that means it's not as flexible as it would've been if the same stage of planning'd happened a month previously
06:27:12 <Philippa> also, #anglohaskell
06:28:25 <PeakerWork> In continuation of my question from yesterday: Is it a true observation that it is impossible (without ugly Typeable tricks), to make a user-extensible set of types that are all instances of some class, that are pattern-matchable? (e.g: Pattern-matching on whether it is one type or another)
06:29:00 <MyCatVerbs> Philippa: dankeschÃ¶n. Just so that I have some idea of where to look for transport to. :)
06:29:18 <Philippa> I figure it's a bit short notice to do anywhere other than ICL by now
06:30:28 <PeakerWork> useBestHandler :: SomeClass a => a -> (b -> r) -> (c -> r) -> (d -> r) -> r
06:30:44 <PeakerWork> oops, I should have used: SomeClass a, SomeClass b, SomeClass c, SomeClass d
06:31:16 <PeakerWork> and the idea is that a is actually b, c or d - but I don't know which
06:31:40 <lilachaze> PeakerWork: what's so ugly about using Typeable for this? it's what it's for, after all :)
06:31:41 <Saizan> that's what typeable is for..
06:31:58 <ski> why three branch arguments ?
06:32:22 <dmwit> PeakerWork: You could use data instead of class.
06:32:43 <dmwit> Stick the data in a publicly modifiable file, and you're good to go.
06:32:45 <lilachaze> dmwit: "user-extensible" is hard that way,isn't it?
06:32:49 <dmwit> No, why?
06:33:14 <lilachaze> well, it means you can't put your module into a library
06:33:30 <Saizan> what you really want is "extensible variants" i guess
06:34:02 <PeakerWork> lilachaze, I find Typeable ugly :)
06:34:44 <PeakerWork> another problem is that the above function is hard-coded to support 3 types - how can I generalize that?
06:35:18 <PeakerWork> a -> [(exists b. b->r)] -> r   is what I want, I think
06:38:40 <hpaste>  dmwit pasted "class v. data" at http://hpaste.org/8651
06:38:48 <ski> that would not be parametric
06:41:17 <ski> @free foo :: a -> Something
06:41:17 <lambdac> foo = foo . f
06:42:19 <EvilTerran> er?
06:42:28 <ski> (which is probably not what you want .. of course one can consider breaking parametricity .. but one would have to ask whether that is warranted for this)
06:42:59 <EvilTerran> i guess f has to be :: a -> a for that to typecheck, so must be id. not the most helpful output from @free :P
06:43:15 <ski> no
06:43:29 <ski> f :: a -> b
06:43:39 <ski> foo :: forall a. a -> Something
06:44:07 <dmwit> i.e. foo = const {- Something -} -- ?
06:44:35 <lilachaze> does it mean, foo = foo . (f :: forall a. a -> a), or does it mean foo = foo . (f :: a -> a for some specific a) ?
06:44:39 <lilachaze> both appear to be true
06:44:45 <ski> (`a' and `b' are not quantified over `f')
06:45:16 <lilachaze> ah
06:45:46 <lilachaze> PeakerWork: what's so ugly about Typeable? it does exactly what you want...
06:45:49 <ski> lilachaze : it means  forall (a :: *) (b :: *). forall (f :: a -> b). foo = foo . f
06:46:02 <lilachaze> ski: got it. that makes sense :)
06:46:07 <EvilTerran> ski, but that doesn't typecheck...
06:46:16 <ski> EvilTerran : which ?
06:46:20 <EvilTerran> foo :: a -> Something; foo.f :: b -> Something
06:46:36 <opqdonut> no
06:46:46 <lilachaze> EvilTerran: (foo :: a -> Sometihng) = (foo :: b -> Something) . (f :: a -> b)
06:46:53 <EvilTerran> ohhh, i get it
06:47:16 <EvilTerran> ... i guess foo has to ignore its parameter
06:47:18 <nominolo> @seen swiert
06:47:18 <lambdac> swiert is in #haskell. I don't know when swiert last spoke.
06:47:24 <lilachaze> EvilTerran: exactly :)
06:47:26 <ski> (lilachaze : swap one or the other pair of `a' and `b')
06:47:57 <ski> (lilachaze : er, no i'm reading you wrong .. you was right)
06:48:48 <lilachaze> (ski: i need to swap one or the other pair of 'h' and 'i' in 'Something', though :) )
06:49:14 * ski thinks it could potentially be nicer to use `<-' instead of `->' ..
06:49:38 <ski> lilachaze :)
06:49:51 <lilachaze> ski: won't somebody please think of the Curry-Howard isomorphism? :)
06:49:56 <yitz> ivanm: Information Age magazine has been around since the mid 1990s. It was already a buzz word then, but maybe they have some idea about where their name comes from. Maybe email them.
06:50:05 <ski> lilachaze : what about it ?
06:50:14 <lilachaze> ski: reversing the arrow makes it all ugly :)
06:50:17 <ivanm> yitz: apparently its from the 50s or 60s :s
06:50:36 <EvilTerran> lilachaze, actually, thinking about the type (a -> Something) in the context of curry-howard makes a lot of sense to me too
06:51:24 <ski> lilachaze : <whiny noise>noo</whiny noise> .. reversing the arrow makes more sense, in conjunction with the usual order of writing application and composition
06:51:54 <EvilTerran> given that you can prove Something from anything with the rule "foo", you can still prove it from anything given the rule "f" from which you can prove anything from anything :)
06:52:21 <lilachaze> ski: now if only haskell allowed you to define kind constructors... "kind (<-) a b = b -> a"
06:52:35 <EvilTerran> lilachaze, that's still just a type constructor
06:52:41 <EvilTerran> but it'd need to start with a :
06:52:44 <ski> EvilTerran : not quite .. `f' isn't proving anything from anything
06:52:57 <EvilTerran> type a :<- b = b -> a
06:53:24 <ski> EvilTerran : given a specific `a' and `b', and given a specific `f' with type `a -> b', `foo = foo . f' should hold
06:53:29 <EvilTerran> yes, i see
06:53:44 <lilachaze> EvilTerran: |- forall a. a -> Something => (forall a. a) |- Something => Something. Hence the existence of our function foo proves the existence of a constant Something
06:54:06 <PeakerWork> dmwit, That requires fixing everybody's pattern matches
06:54:12 <PeakerWork> dmwit, whenever you extend it
06:54:21 <dmwit> Why?
06:54:44 <PeakerWork> dmwit, Oh wait, I guess not
06:54:53 <dmwit> Anyway, you wouldn't use pattern matching.
06:54:55 <EvilTerran> lilachaze, is that (|- forall a. a -> Something) => ((forall a. a) |- Something) => Something, ?
06:54:55 <PeakerWork> dmwit, what about the duplication of the method list?
06:55:10 <dmwit> You'd just use "calculate" instead, which automatically extends its pattern matching as you extend the data type.
06:55:22 <dmwit> PeakerWork: What about it?
06:55:35 <dmwit> PeakerWork: You'd have to duplicate it if you were doing instances, too.
06:55:36 <lilachaze> EvilTerran: yes.
06:55:42 <EvilTerran> makes sense :)
06:56:05 <lilachaze> EvilTerran: that assumes of course that a is not free in Something
06:56:15 <EvilTerran> yes
06:56:24 * EvilTerran hates variable capture
06:56:36 <ski> lilachaze : hrm .. is `=>' there meant to bind weakest, syntactically ? .. if so, the first step looks weird
06:56:41 <lilachaze> EvilTerran: and also that your logic has any true statement (equivalently, your type system has any non-bottom value)
06:56:41 <EvilTerran> it makes everything so complicated, so full of little justifications like that
06:56:58 <PeakerWork> dmwit, I'll need to tinker around with both methods to see how they compare. Thanks for the idea. (Still dislike the notion of a central place you must be able to edit, though)
06:57:11 * ski notes EvilTerran also had problems parsing it ..
06:57:22 <EvilTerran> i got it right in the end, tho :)
06:58:11 <lilachaze> ski: this is the problem with making logical statements about logical statements -- you need to keep your inner and outer logics separate. i really should have used quotes or brackets or something :)
06:58:15 <EvilTerran> ... grr, i have too many windows open. if only the windows virtual desktop powertoy wasn't rubbish.
06:58:18 <ski> lilachaze : so i think your statement would be correct if you s/(forall a. a)/(exists a. a)/
06:58:54 <lilachaze> ski: the first statement is (forall a. (a -> Something)), not (forall a. a) -> Something.
06:59:05 <ski> lilachaze : indeed
06:59:33 <lilachaze> ok, yes, you're right. apologies :)
06:59:36 <ski> implication is contravariant in its antecedent argument
07:01:44 <swiert> nominolo: hiya
07:03:56 <pagenoare> hello
07:04:04 <pagenoare> i have problem with compiling ghc :/
07:05:00 <lilachaze> ski: just like a function :) yay for curry-howard
07:05:51 <pagenoare> make[1]: *** No rule to make target `Apply.o`, needed by `libHSrts.a`. Stop.
07:05:55 <pagenoare> any ideas? :)
07:07:44 <dmwit> EvilTerran: Try VirtuaDesk.
07:07:50 <dmwit> err... maybe VirtuaWin
07:08:48 <dmwit> Along with the plugin that lets you move/resize windows with a click anywhere in a window, you can have a pretty workable xmonad replacement. =)
07:09:28 <dmwit> (Not because of the big move/resize target; because of the other things the plugin does without advertising about them. =)
07:09:38 <byorgey> pagenoare: any particular reason you need to compile ghc?
07:09:57 <pagenoare> byorgey: i have broken pkg in my distro ?
07:10:11 <byorgey> pagenoare: and you can't just download a binary distribution from the ghc webpage?
07:10:40 <pagenoare> yay, i'll check now, wait
07:12:34 <adekoba> does anyone know of any haskell packages that can work with ID3 tags? hackage doesn't seem to have any
07:16:38 <psyklops> you've been wondering for a long time
07:20:10 <EvilTerran> adekoba, the one you're about to write, perhaps? :D
07:20:43 <adekoba> I don't know... I'm still an amateur
07:22:18 <adekoba> if I were to go about doing something like this, would you recommend making an interface to taglib, or making a native implementation in haskell?
07:22:47 <opqdonut> well id3v2 is pretty simple so  a native one would probably be as easy as using FFI
07:23:03 <EvilTerran> we like native ones :)
07:25:42 <adekoba> opqdonut: is that a nod towards a library interface, or native?
07:27:44 <adekoba> opqdonut: nevermind
07:49:09 <pagenoare> byorgey: ok, works, thx :)
07:59:48 <carl> what does the $ do i cant work it out :s
08:00:04 <Eelis> @src ($)
08:00:05 <lambdac> f $ x = f x
08:00:18 <saml> @type ($)
08:00:20 <lambdac> forall a b. (a -> b) -> a -> b
08:01:10 <EvilTerran> > (+1) . (*2) $ 3
08:01:11 <lambdac>  7
08:01:20 <saml> > (+) $ 1 $ 2
08:01:21 <lambdac>   add an instance declaration for (Num (a -> b))
08:01:30 <Saizan> ?seen dcoutts_
08:01:30 <lambdac> dcoutts_ is in #haskell. I last heard dcoutts_ speak 5d 23h 5m 3s ago.
08:01:42 <EvilTerran> it doesn't "do" anything, it just acts as really low-precedence function application
08:01:50 <EvilTerran> it's infixr 0
08:01:51 <Saizan> preflex: seen dcoutts_
08:01:52 <preflex>  dcoutts_ was last seen on #haskell 3 days, 20 hours, 25 minutes and 34 seconds ago, saying: using my current cabal-install dependency planner
08:02:22 <EvilTerran> (Cale (and some others) think it should be infixl 0, so stuff like what saml just wrote would work, but that's sadly not the case0
08:03:43 <EvilTerran> (it would make more sense, imo, as normal function application is left-associative)
08:04:01 <carl> thx
08:05:43 <Saizan> anyone familiar with yhc?
08:06:09 <EvilTerran> preflex: seen ndm
08:06:09 <preflex>  ndm was last seen on #haskell 11 days, 20 hours, 28 minutes and 51 seconds ago, saying: kosmikus: it says SaveRestoreHooks isn't a known command
08:06:15 <Armored_Azrael> Saizan: Not familiar that much, but I've used it in a project
08:06:21 <Armored_Azrael> Saizan: What do you want to know?
08:06:34 <PeakerWork> EvilTerran, I think it makes more sense that it is the opposite of normal function application, so you can choose which associativity you want
08:06:36 <saml> > let (<$) = ($); infixl 0 <$; in (+) <$ 1 <$ 2
08:06:37 <lambdac>  3
08:07:10 <EvilTerran> PeakerWork, eh... but you could still write (f . g . h $ x) where you'd write (f $ g $ h $ x)
08:07:24 <EvilTerran> and that looks nicer anyway, all those $s are noisy
08:07:38 <Saizan> Armored_Azrael: how do you install a package? you just copy the .hi and .hbc files in a directory under /usr/local/lib/yhc/packages ?
08:07:42 <saml> i think it would be nice/crazy to have <func to make func left associative
08:08:20 <saml> no i take it back. i'm confused.
08:08:32 <EvilTerran> saml, oo, oo, we should have a generalised sigil thingamabob
08:08:34 <Armored_Azrael> Saizan: Actually don't know. That would be my guess. However, the project I did was using an external source to manage packaging, so I didn't actually figure that part out :P
08:08:49 <quicksilver> ($) has more than one usage, unfortunately
08:08:59 <quicksilver> one usage is as "parenthesis extending all the way to the right"
08:09:02 <quicksilver> as in the "church dot"
08:09:17 <quicksilver> the other usage is just to give a name to function application.
08:09:19 <EvilTerran> as in the . in forall x.?
08:09:31 <quicksilver> that's an exampe of a church dot, yes.
08:09:47 <quicksilver> in \lambda x . verylongexpressionhere
08:09:56 <quicksilver> the scope of the lambda is "as far right as possible"
08:10:03 <quicksilver> that kind of scoping is called a church dot
08:10:08 <quicksilver> unless I have my memory wrong :)
08:11:19 <quicksilver> I did see an argument for not changing the associativity of $
08:11:22 <quicksilver> which is basically the idiom
08:11:46 <quicksilver> withFoo $ \n withBar $ \n withBaz $ \n  furble
08:11:55 <saml> 1 2 <add `add` add 3 4  == (2 + 1) + (3 + 4)
08:12:14 <quicksilver> for consistency with
08:12:31 <quicksilver> withFoo $ \a -> withBar $ \b -> withBaz $ \c -> furble
08:12:40 <quicksilver> (apologies for stupid overloading of backslash)
08:12:49 <quicksilver> the point being that the latter cannot be rewritten with (.)
08:13:13 <EvilTerran> but the latter would continue to work because of your "church dot" effect with the ->
08:13:17 <quicksilver> so if we rewrite the former with (.) and not the latter we have a strange inconsistency between "withFoos" which take parameters and those don't.
08:13:24 <EvilTerran> eh, i guess
08:13:25 <quicksilver> EvilTerran: yes, continue to work, but be inconsistent
08:13:26 <quicksilver> (that's all)
08:13:36 <EvilTerran> either way, there's inconsistencies
08:13:39 <quicksilver> agreed.
08:13:47 <quicksilver> however this is notable as being the first good counter-argumetn I've read.
08:13:58 <quicksilver> everything else I'd seen was uniformly in favour of the change
08:14:14 <asdftimo> hello, can you self reference a list in a takewhile condition like this: newlist = takeWhile((length newlist)<100)[1..]
08:14:28 <quicksilver> asdftimo: you are allowed to self reference.
08:14:34 <quicksilver> asdftimo: but that won't work the way you hope :)
08:14:45 <asdftimo> can you suggest a fix?
08:14:50 <quicksilver> take 100 [1...]
08:14:51 <quicksilver> ?
08:15:00 <asdftimo> ill try that, thanks.
08:15:05 <quicksilver> or take 99, if you meant the < to be "less than"
08:18:00 <pagenoare> i installed X11 (http://hackage.haskell.org/cgi-bin/hackage-scripts/package/X11) but i don't have it on ghc-pkg list?
08:18:40 <quicksilver> sounds like it failed to register
08:26:43 <asdftimo> hi, i need help making a type signature for this function:
08:26:43 <asdftimo> isprime n= (takeWhile(<1)$ map(\x -> mod n x) [2..floor(sqrt n)])==[]
08:26:52 <asdftimo> or fixing it so that it doesn't need one
08:27:25 <asdftimo> it should output a Bool determining if n is prime
08:27:25 <quicksilver> what type are you hoping 'n' has?
08:27:34 <asdftimo> Int
08:27:37 <asdftimo> non floating
08:27:42 <byorgey> @type sqrt
08:27:44 <lambdac> forall a. (Floating a) => a -> a
08:27:45 <quicksilver> sqrt doesn't work on Ints
08:27:52 <quicksilver> that's the root of your problem.
08:28:08 <quicksilver> try "sqrt (fromIntegral n)"
08:29:04 <hpaste>  chris pasted "happs migrations" at http://hpaste.org/8652
08:29:28 <tromp> looks like definition of odd numbers
08:29:38 <asdftimo> hah, i realized that
08:30:31 <EvilTerran> asdftimo, it'd probably be better to avoid floating-point math for that one
08:30:50 <EvilTerran> something like takeWhile ((<=n).(^2)) [2..] may be better
08:30:59 <ziman> that's the square root of the problem ;0
08:31:10 <EvilTerran> ((<=n).(^2) = (\i -> i^2 <= n)
08:31:22 <asdftimo> ok, thanks EvilTerran
08:32:27 <EvilTerran> but don't use it unless you know how it works :P
08:33:35 <yakov> hey
08:35:06 <byorgey> hi yakov
08:37:08 <yakov> ghci's ``let'' form is special one, isn't it? it does not require the ``in'' part? have I missed something?
08:37:32 <asdftimo> hi, i've got a list that may or may not have 0's in it, and i want to determine if it does, but if i find one, i want it to break so it doesn't check the whole list. how can i do this?
08:37:33 <Botje> not really
08:37:40 <Botje> yakov: it's the let you find in a do block
08:38:08 <tromp> > 0 1elem` [0..]
08:38:09 <lambdac>  Float with missing exponent at "1elem..." (column 3)
08:38:10 <Apocalisp> how does one show an Int in base-n?
08:38:12 <BONUS> you can think of the whole ghci session being inside one function
08:38:12 <tromp> > 0 `elem` [0..]
08:38:14 <lambdac>  True
08:38:22 <Botje> asdftimo: how about the find function?
08:38:28 <Botje> @hoogle find
08:38:28 <lambdac> A Hoogle error occured.
08:38:34 <Botje> cute
08:38:37 <Botje> Data.List.find :: (a -> Bool) -> [a] -> Maybe a
08:38:42 <asdftimo> Botje: looking it up
08:38:45 <byorgey> yakov: in a do block, you can use  'let foo = bar' with no 'in' part (the 'in' is just implicitly the rest of the do-block); the ghci prompt is essentially embedded within a do-block in the IO monad.
08:38:58 <Botje> i think elem does the same, too
08:39:35 <tromp> > 78558 `elem` [0..]
08:39:36 <lambdac>  True
08:39:54 <tromp> > -1 `elem` [0..]
08:40:38 <asdftimo> i dont want it to check the whole list if it finds one early on, though. it looks like that is what elem does. also, i'm getting "Not in scope: 'find'"
08:40:50 <BONUS> import Data.List
08:40:59 <BONUS> or if you're in ghci do :m + Data.List
08:41:00 <quicksilver> asdftimo: lazy evaluation means that elem will stop early when it finds one.
08:41:17 <quicksilver> asdftimo: and find as well
08:41:17 <BONUS> > find (> 5) [0..]
08:41:19 <lambdac>  Just 6
08:41:24 <asdftimo> ok thanks guys
08:41:44 <Apocalisp> > showIntAtBase 10 2
08:41:44 <tromp> succ (2147483647::Int)
08:41:45 <lambdac>   add an instance declaration for (Num (Int -> Char))
08:41:59 <quicksilver> "elem n" is actually the same as "find (==n)"
08:42:03 <tromp> > succ (2147483647::Int)
08:42:04 <lambdac>  Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
08:42:21 <Apocalisp> > (showIntAtBase 10 intToDigit) 2
08:42:22 <lambdac>  <[Char] -> [Char]>
08:42:33 <tromp> [2147483647..] :: [Int]
08:42:38 <tromp> > [2147483647..] :: [Int]
08:42:40 <lambdac>  [2147483647]
08:43:23 <tromp> elem n  is same as any (==n)
08:43:33 <quicksilver> ah, good point
08:43:39 <quicksilver> same idea ;)
08:44:41 <_zenon_> ?ty elem
08:44:43 <Baughn> @type showIntAtBase
08:44:45 <lambdac> forall a. (Eq a) => a -> [a] -> Bool
08:44:46 <lambdac> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
08:45:25 <Baughn> > showIntAtBase 3 chr 42 ""
08:45:26 <lambdac>  "\SOH\SOH\STX\NUL"
08:45:30 <Apocalisp> > showIntAtBase 2 intToDigit 10 ""
08:45:31 <lambdac>  "1010"
08:45:36 <Apocalisp> win
08:46:01 <Baughn> > showIntAtBase 3 (chr . (+ ord '0')) 42 "aa"
08:46:02 <lambdac>  "1120aa"
08:46:44 <Baughn> ..I don't see why the last parameter is there, though
08:47:01 <yakov> byorgey, Boney thx! I thought so..
08:47:11 <Apocalisp> > showIntAtBase 64 intToDigit 2^24 ""
08:47:13 <lambdac>   add an instance declaration for (Num ([Char] -> b))
08:47:19 <Apocalisp> > showIntAtBase 64 intToDigit (2^24) ""
08:47:20 <lambdac>  "10000"
08:47:31 <Apocalisp> handy that
08:47:36 <asdftimo> hi, when i try to generate this list, it won't stop working when it gets the last element:
08:47:37 <asdftimo> [y|y<-[1..], y^2<=9]
08:47:55 <EvilTerran> asdftimo, that's because it doesn't know if there's more elements
08:48:02 <EvilTerran> > filter (const false) [1..]
08:48:03 <lambdac>   Not in scope: `false'
08:48:08 <EvilTerran> > filter (const False) [1..] -- oops
08:48:21 <Baughn> EvilTerran: Ooops indeed.
08:48:28 <asdftimo> how can i write the equivalent so that it works?
08:48:37 <EvilTerran> ... where's the "Terminated."?
08:48:40 <lambdac>  thread killed
08:48:41 <Baughn> asdftimo: Try with.. break., I think
08:48:44 <EvilTerran> ah, there we go
08:48:48 <Baughn> @ty break
08:48:52 <EvilTerran> ?ty takeWhile
08:49:00 <asdftimo> takeWhile(\x -> x^2 <=9)[1..]?
08:49:05 <Baughn> takeWhile makes more sense, yep
08:49:08 <EvilTerran> ?bot
08:49:10 <asdftimo> alright thanks
08:49:32 <EvilTerran> takeWhile stops looking the first time it hits one where the predicate doesn't hold
08:49:35 <Baughn> > takeWhile (<= 9 . ^2) [1..]
08:49:44 <BONUS> what the heck
08:49:50 <BONUS> i just pressed ctrl + something in ghci
08:49:51 <EvilTerran> filter (which list comprehensions like that desugar into) doesn't
08:50:06 <BONUS> and i got a menu of previously executed functions
08:50:10 <BONUS> how do i get that back
08:50:21 <Baughn> EvilTerran: Desugars into guard, not filter. Then specializes to filter
08:50:24 <EvilTerran> BONUS, that's a feature of cmd.exe, i think
08:50:25 <asdftimo> Baughn: i don't understand your syntax, and that code doesn't work on my system, could you explain it?
08:50:30 <BONUS> oh yeah
08:50:41 <EvilTerran> Baughn, i thought list comprehensions desugared straight into filter and concatMap, according to the report
08:50:49 <BONUS> yeah im running cygwin
08:50:55 <BONUS> whats the key combination though
08:51:00 <lambdac> thread killed
08:51:01 <lambdac> :)
08:51:01 <lambdac>  Parse error at "^2)" (column 19)
08:51:01 <Botje> BONUS: probably ctrl-r
08:51:09 <EvilTerran> asdftimo, it should be takeWhile ((<= 9) . (^2)) [1..]
08:51:12 <Baughn> asdftimo: It's just the pointsfree version of yours, though it wouldn't work if . has higher presedence than.. ^2. Yeah.
08:51:19 <Baughn> Need parantheses.
08:51:26 <EvilTerran> you always need parentheses around operator sections
08:51:32 <EvilTerran> precedence doesn't come into it
08:51:55 <asdftimo> i'm not sure i understand what the period is, i thought it was function composition
08:51:59 <Baughn> It is
08:52:05 <Baughn> @type (^2)
08:52:28 <EvilTerran> BONUS, it seems to be f7 here
08:52:30 * Baughn pokes the bot with a stick
08:53:28 <BONUS> ah
08:53:28 <BONUS> nice
08:54:17 <Baughn> asdftimo: Anyhow. (^2) is a function of one parameter which, conveniently, squares what you pass to it.
08:54:40 <asdftimo> interesting, thanks.
08:55:20 <asdftimo> what is the symbol for negation in haskell?
08:55:27 <Baughn> "negate"
08:55:40 <Baughn> asdftimo: It's called operator slicing and, like currying, it's very convenient. You can even use it with "operators" like `filter`
08:55:54 <lambdac> forall a. (Num a) => a -> a
08:56:16 <EvilTerran> (`f` x) = flip f x
08:56:23 <asdftimo> Baughn: could you provide another example?
08:56:35 <Baughn> asdftimo: There is a bit of a problem with negation, in that (-2) could mean either "negative two" or "\x -> x-2", and it isn't always obvious which
08:57:05 <asdftimo> what about logical negation: ie !(true)=false
08:57:12 <Baughn> > (`filter` [1..10]) (< 5)
08:57:20 <Baughn> > not True
08:57:27 <lambdac>  thread killed
08:57:28 <lambdac>  False
08:57:35 <Baughn> > (`filter` [1..10]) (< 5)
08:57:37 <lambdac>  [1,2,3,4]
08:57:46 <asdftimo> thanks
08:58:09 <Baughn> EvilTerran: Lambdabot gets uncomfortably unstable when it has to kill threads, due to being on a way-too-weak machine mostly. Try not to. :/
08:58:31 <_zenon_> ?ty (-2)
08:58:32 <lambdac> forall a. (Num a) => a
08:58:34 <EvilTerran> oh right, ok
08:58:37 <Baughn> > flip filter [1..10] (5<)
08:58:38 <lambdac>  [6,7,8,9,10]
08:58:53 <Baughn> > negate 4
08:58:54 <lambdac>  -4
08:59:02 <Baughn> > (subtract 4) 5
08:59:03 <lambdac>  1
08:59:21 <jinjing> hmm is there a way to see the distribution of code in terms of bytes inside the main program?
08:59:37 <Baughn> jinjing: Of /code/? Not of runtime memory usage?
08:59:40 <jinjing> i meant the distribution of library code
09:00:20 <jinjing> Baughn: my main program grew to 26mb, i wonder what's in there
09:00:38 <Baughn> jinjing: Um... you mean it takes 26mb of memory  at runtime?
09:00:47 <Baughn> jinjing: Look at the profiling section of the user guide.
09:00:55 <jinjing> Baughn: no, i meant thse size of the bin :)
09:01:04 <Baughn> Ah. Well.
09:01:06 <jinjing> Baughn: cool, thanks
09:01:18 <Baughn> jinjing: Hang on
09:01:49 <Baughn> jinjing: GHC gets compiled with split objects, but for the /other/ libraries you might be using.. it'll basically include a verbatim copy of the entire library, regardless of how much you use
09:02:28 <Baughn> jinjing: Try passing --enable-split-objs to cabal when you install the library. Reinstall it if necessary. That should reduce size a lot, so..
09:02:41 <Baughn> It'll also increase compilation time (for the library) noticably
09:02:44 <asdftimo> how does the numbering in (list !! n) work? i'm taking the 6th element out with ( list !! 5)
09:02:58 <EvilTerran> list!!0 is the first one
09:03:04 <asdftimo> got it
09:03:06 <asdftimo> thanks
09:03:06 <jinjing> Baughn: thanks, i'll that now :)
09:03:42 <Baughn> asdftimo: Offset, as usual. It's "move 0 elements through the list, then get this one", not "get the 0th element"
09:04:32 <asdftimo> thanks Baughn
09:05:36 <Baughn> jinjing: Also, you might see a dramtic size reduction bys tripping the binary after you compile
09:06:38 <saadahmad> I'm wondering, is there a resource which talks about programming algorithms in haskell?
09:06:57 <Baughn> saadahmad: You mean, how to write algorithms for lazy, purely functional languages?
09:07:01 <saadahmad> Yes
09:07:02 <Baughn> Yes, aas a matter of fact
09:07:08 * Baughn tries to remember
09:07:12 <saadahmad> Awsome, could I get more info? :)
09:07:40 <Baughn> http://www.google.com/url?sa=t&ct=res&cd=3&url=http%3A%2F%2Fwww.cs.cmu.edu%2F~rwh%2Ftheses%2Fokasaki.pdf&ei=RlZqSMuKIIz40AXa5PSlDA&usg=AFQjCNGXKQqKJho73FE372EjGzUoeSJm1w&sig2=R_U8cbQa-lDCj7WvJdi94w
09:07:43 <lambdac> http://tinyurl.com/4znfu8
09:07:51 <brauwerm>   http://books.google.com/books?id=SxPzSTcTalAC&dq=purely+functional+data+structures&pg=PP1&ots=DEkW_xJk_R&sig=tBsnd-uj7Ko9GeXQzW5T3jlGUBk&hl=en&sa=X&oi=book_result&resnum=1&ct=result
09:07:54 <Baughn> Here you go. The actual book.. it's in book form too.
09:07:54 <lambdac> Title: Purely Functional Data Structures - Google Book Search, http://tinyurl.com/3vccmz
09:08:09 <saadahmad> Thanks :)
09:08:17 <Baughn> saadahmad: My link is a pdf. ;)
09:08:31 <saadahmad> I saw :)
09:08:42 <saadahmad> Are they both the same thing?
09:08:55 <Baughn> Well, the book is probably a bit more polished
09:09:04 <Baughn> It was originally a thesis, so..
09:09:11 <saadahmad> Ah
09:09:15 <Baughn> Read the pdf. Then get the book; you can't carry your laptop everywhere.
09:09:40 <saadahmad> Alright, thanks :)
09:09:44 <_zenon_> Baughn: That's not entirely true :)
09:10:03 <Baughn> And as it turns out, lazyness largely makes up for pureness as efficiency goes. You're in luck. ;)
09:11:00 <brauwerm> I found that Okasaki's book is more of a catalog of cool examples than a conceptual learning tool.
09:11:18 <Baughn> At that size, it has to be
09:11:25 <Baughn> It's a good start.
09:11:29 <saadahmad> brauwerm, any books that you would recommend?
09:11:33 <brauwerm> yeah
09:11:58 <brauwerm> No, I'm no good at functional data structures. my programs always explode :-)
09:12:12 <brauwerm> I stick to understanding how to use structures that other people write :)
09:12:22 <saadahmad> Haha
09:12:38 <brauwerm> http://www.haskell.org/ghc/docs/edison/index.html
09:12:39 <lambdac> Title: Edison User's Guide* (Haskell version)
09:12:58 <brauwerm> don't need to write my own until I figure out how to use these well ^^
09:14:35 <quicksilver> As far as I know okasaki's book/thesis/papers remain the best source
09:14:42 <quicksilver> even if they're more cookbook than guide.
09:17:48 <smg> hi.
09:17:55 <smg> (:) associated to the right, is that true?
09:18:34 <tromp> yes
09:18:56 <jinjing> Baughn: i couldn't get the --enable-split-objs works for cabal libs, even after reinstalling
09:18:59 <quicksilver> > []:[]:[]
09:19:01 <lambdac>  [[],[]]
09:19:03 <_zenon_> 1:[2]
09:19:07 <quicksilver> > ([]:[]):[]
09:19:08 <lambdac>  [[[]]]
09:19:11 <quicksilver> tada!
09:19:14 <_zenon_> > 1:[2]
09:19:15 <lambdac>  [1,2]
09:19:18 <_zenon_> > [1]:2
09:19:19 <lambdac>   add an instance declaration for (Num [[t]])
09:19:31 <jinjing> but did get my binary down to 2mb by removing some libs :)
09:19:55 <_zenon_> jinjing: What have you written?
09:20:39 <jinjing> did i misuse english again?
09:20:58 <quicksilver> real mean don't use --strip-objs to make small executables. They delete unreferenced symbols using ed and regexps.
09:21:26 <_zenon_> mean ? why not the median instead?
09:21:38 <quicksilver> ;P
09:22:02 <jinjing> _zenon_: i'm not following :)
09:22:20 <_zenon_> jinjing: What did you code? I am curious ;)
09:22:54 <jinjing> _zenon_: oh, just building a small toolkit, while solving euler problems
09:23:06 <Dae_> what exactly is a segmentation fault??
09:23:22 <Dae_> or vaguely.... vaguely is also good
09:23:52 <_zenon_> jinjing: Nice. Which modules did you use that exploded the size? Good to know what did it.
09:23:56 <quicksilver> dae: you tried to access memory which was not currently mapped
09:24:03 <quicksilver> i.e. it did not belong to your process
09:24:12 <quicksilver> or it was mapped read-only and you tried to write to it.
09:24:22 <quicksilver> most likely something dereferenced a null or dangling pointer.
09:24:36 <Dae_> quicksilver: That's... interresting.... I'm not using any unsafe operations....
09:25:00 <Dae_> could it happen if I was just running out of memory?
09:25:10 <jinjing> _zenon_: i used to have plugins included, and removing it freed about 24 mbs :/
09:25:17 <quicksilver> Dae_: No.
09:25:27 <quicksilver> Dae_: it must be the fault of one of the libraries you are using.
09:25:37 <quicksilver> haskell code itself "cannot" segfault.
09:25:49 <_zenon_> jinjing: Okay. Noted, I will remember it if I get the same problem. Thx. Oh, also, which plugins?
09:25:53 <quicksilver> but to the extent that you cheat by using unsafe ops, or link to FFI libraries...
09:26:00 <Dae_> stream fusion it is then....
09:26:08 <jinjing> _zenon_: the plugins cabal ..
09:26:08 <quicksilver> seems likely.
09:26:16 <quicksilver> I'm sure the authors would appreciate a bug report.
09:26:20 <quicksilver> is it reproducible?
09:26:23 <PeakerWork> Alan Kay supposedly said "Until real software engineering is developed, the next best practice is to develop with a dynamic system that has extreme late binding in all aspects."
09:26:35 <_zenon_> jinjing: Okay, thank you :)
09:26:55 <jinjing> _zenon_: you are welcome
09:27:13 <quicksilver> PeakerWork: "extreme late binding" means : I hope that, before this code is every actually run, someone will have debugged the the libraries it calls. And it.
09:27:33 <Dae_> quicksilver: in a controlled enviroment? It might be.... takes a while for it to run.
09:28:01 <PeakerWork> quicksilver, yeah, but its better than static type systems that don't yet work
09:28:02 <Dae_> actually.... I'm using  " -optc-funsafe-math-optimizations"....
09:28:20 <_zenon_> the dream would be a language, such that the grammar of it, makes it impossible  to make logical errors
09:28:58 <quicksilver> PeakerWork: but not as good as static type systems which do work :)
09:29:00 <ddarius> It's impossible to do that.  A logical error is when you write something different from what you intended.
09:29:06 <PeakerWork> quicksilver, ofcourse :)
09:29:18 <Dae_> ddarius: so, a mindreading compiler?
09:29:20 <mm_freak_work> _zenon_: haskell is quite good at preventing errors, but unfortunately logic is left to the programmer ;)
09:29:53 <_zenon_> mm_freak_work; Yeah, at least type errors :)
09:30:14 <mm_freak_work> not only type errorsâ¦  you'll find that a haskell program mostly either is correct or doesn't compile at all
09:30:15 <_zenon_> ddarius: Maybe not, just abstract it enough, in some way :)
09:31:15 <_zenon_> like ddarius said: If I intend to write a program that increases each item of a list by two and do reverse [....] instead, surely it's a logical error, but If you don't realise reverse reverses the list...
09:31:24 <_zenon_> I don't know how to protect you there :)
09:31:40 <_zenon_> okay, StarTrek time
09:31:43 <_zenon_> bye
09:32:34 <PeakerWork> even mind reading wouldn't work - some bugs are internal inconsistencies in what we want from the system :)
09:33:08 <Dae_> Sure it would. all you have to do is think of what you want the final result to be, the compiler does the rest
09:33:27 <EvilTerran> mind reading + predicate logic oracle would work
09:33:41 <PeakerWork> mm_freak_work, some Haskell programs deal with a lot of untyped things (serialized strings are just String, and untyped.. IO actions are not typed enough to prevent many kinds of bugs, etc)
09:33:44 <EvilTerran> so it can detect the internal consistencies and produce an error message
09:34:20 <PeakerWork> Dae_, the "final" result is probably to "be happy" or something :)
09:34:41 <Baughn> Dae_: The problem is, a sufficiently smart mind-reading compiler would probably have to instantiate you inside itself in order to figure out whether any given result would make you happy
09:35:02 <Dae_> ok, so we make it a quantum compiler?
09:35:07 <Baughn> Dae_: So, yeah, it'd get the right result. It'd also construct a trillion worlds where you were made unhappy and then promptly killed.
09:35:10 <Baughn> That.. wouldn't help
09:35:34 <Dae_> Actually, wouldn't it allow us to do just that?
09:35:48 <Baughn> It would
09:35:57 <Baughn> And I don't believe doing that is /desirable/
09:36:54 <Dae_> Well, ofcourse not
09:37:09 <PeakerWork> such a long fancy word for such a simple thing: "desirable"
09:37:37 <Dae_> yeah, I think the internet has renamed it "do want"
09:39:28 <hpaste>  ronwalf pasted "GHC 6.8.3 binary configure error" at http://hpaste.org/8653
09:39:49 <ronwalf> Anyone have a problem configuring the binary version of ghc 6.8.3 ?
09:39:53 <ronwalf> (for linux)
09:39:58 <ronwalf> (i386)
09:41:09 <BMeph> Dae_: I thought it was "can has"? ;p
09:41:31 <Dae_> BMeph: heh, you could be right
09:42:16 <Botje> "can has" is a request for acquisitioning stuff
09:42:29 <Botje> that's one step further than "want"
09:43:19 <Gwern-away> what about 'sauce'?
09:43:34 <Botje> ronwalf: what kind of cpu is that?
09:43:50 <ronwalf> model name	: Intel(R) Xeon(R) CPU            5140  @ 2.33GHz
09:44:44 <ronwalf> 2.6.9-55.ELsmp #1 SMP Fri Apr 20 17:03:35 EDT 2007 i686 i686 i386 GNU/Linux
09:45:18 <Botje> i think you'd better log a bug with GHC's bug tracker then
09:47:22 <Botje> do you get the same when you try to build from source?
09:48:05 <sieni> sb end
09:48:11 <sieni> eiku :-)
09:50:18 <dons> ?yow
09:50:18 <lambdac> Couldn't find fortune file
09:52:29 <asdftimo> hi, i need to find the the x and y values that correspond to 1000:
09:52:30 <asdftimo> elem 1000 [x^2-y^2+2*x*y+x^2+y^2|x<-[1..1000],y<-[1..1000]]
09:52:39 <asdftimo> it returns true, but how do i find the values?
09:53:57 <Saizan> :t lookup
09:53:58 <lambdac> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
09:54:11 <ziman> asdftimo, use [(x, y, x^2...)| .. ]
09:54:21 <ziman> for example
09:54:39 <asdftimo> oh, ok lemme try that
09:56:07 <asdftimo> that syntax didn't work for me, maybe i'm doing it wrong. also, how would i find the value 1000?
09:57:50 <asdftimo> ziman, could you elaborate, i can't get that to work
09:59:03 <EvilTerran> asdftimo, you could move that formula to a "where" clause in the list comprehension
09:59:15 <EvilTerran> asdftimo, and have (x,y) where the formula is now
09:59:21 <byorgey> > [ (x,y) | x <- [1..1000], y <- [1..1000], x^2 - y^2 = 15 ]  -- for example
09:59:21 <lambdac>  Parse error at "=" (column 53)
09:59:26 <byorgey> > [ (x,y) | x <- [1..1000], y <- [1..1000], x^2 - y^2 == 15 ]  -- for example
09:59:28 <lambdac>  [(4,1),(8,7)]
10:00:18 <asdftimo> works great, thanks EvilTerran, byorgey
10:00:40 <EvilTerran> asdftimo, also, you know you have a y^2 and a -y^2 in there?
10:00:56 <EvilTerran> all in all, that's a pretty odd algebraic expression
10:01:11 <asdftimo> i know i could've cancelled them, if that's what your saying
10:01:20 <EvilTerran> ... i think it's 2*x*(x+y)
10:01:54 <asdftimo> if you want to know, it is the sum of pythag triples
10:02:25 <asdftimo> a=2xy, b=x^2-y^2, c=x^2+y^2
10:02:27 <EvilTerran> ok
10:02:44 <ajay> I have a small question, I want to write a piece of code that takes a haskell array filled with numeric values and turns that into a PNG made up of color coded squares, each square corresponding to a value in the array
10:03:00 <ajay> does anyone know what libraries I should look at?
10:03:15 <EvilTerran> GD? imagemagick?
10:03:45 * ronwalf is sad: http://hackage.haskell.org/trac/ghc/ticket/2211
10:03:48 <lambdac> Title: #2211 (Installing latest GHC-6.8.2 stable: pwd with floating point exception) -  ...
10:05:15 <BMeph> ronwalf: I thought you were doing 6.8.3?
10:05:23 <ajay> hmm, are there any haskell libraries or libraries with a haskell wrapper?
10:05:27 <EvilTerran> ajay, probably http://hackage.haskell.org/cgi-bin/hackage-scripts/package/gd
10:05:29 <ronwalf> BMeph: Yeah, but it'll be the same issue
10:05:41 <ronwalf> 6.8.2 actually works on this machine (or did)
10:05:46 <ajay> ahh, thanks
10:06:44 <matthew-_> @where scheck
10:06:44 <lambdac> I know nothing about scheck.
10:06:55 <matthew-_> err, what's it called. small check?
10:07:16 <byorgey> @where smallcheck
10:07:16 <lambdac> http://www.cs.york.ac.uk/fp/smallcheck0.2.tar
10:07:20 <byorgey> apparently =)
10:07:20 <matthew-_> thanks
10:08:16 <lilachaze> asdftimo: x^2-y^2+2*x*y+x^2+y^2 = 2x^2 + 2xy = 1000 => x(x+y) = 500. So: [(x,(500/x)-x) | x <- [1,500], 500 `mod` x == 0]
10:08:23 <lilachaze> > [(x,(500 `div` x)-x) | x <- [1,500], 500 `mod` x == 0] :: [(Int,Int)]
10:08:24 <lambdac>  [(1,499),(500,-499)]
10:08:57 <dons> Igloo: is code.haskell.org down?
10:09:07 <dons> hmm
10:09:40 <ronwalf> dang it, 6.8.2 used to work
10:09:44 <dons> yeah, looks to be down.
10:09:46 <ronwalf> It doesn't anymore
10:09:47 <asdftimo> thanks lilachaze. i wasn't really going for efficiency, though, just brute force.
10:09:54 <Igloo> dons: One tick
10:11:35 * ronwalf sighs now that 6.8.1 works
10:12:05 <lilachaze> asdftimo: it's not the right answer anyway. should be [1..500] not [1,500] (or at least all the factors of 500)
10:12:11 <lilachaze> > [(x,(500 `div` x)-x) | x <- [1..500], 500 `mod` x == 0] :: [(Int,Int)]
10:12:13 <lambdac>  [(1,499),(2,248),(4,121),(5,95),(10,40),(20,5),(25,-5),(50,-40),(100,-95),(1...
10:12:48 <Igloo> dons: Hmm, logging into the control panel took an age, and in the mean time it seems to have reappeared on its own
10:12:50 <asdftimo> i just used this:
10:12:51 <asdftimo> [2*x*y,x^2-y^2,x^2+y^2]) [(x,y)|x<-[1..1000],y<-[1..1000],x^2+2*x*y+x^2==1000, x^2+y^2>0, 2*x*y>0, x^2-y^2>0]
10:13:08 <asdftimo> > print $ map (\(x,y) -> [2*x*y,x^2-y^2,x^2+y^2]) [(x,y)|x<-[1..1000],y<-[1..1000],x^2+2*x*y+x^2==1000, x^2+y^2>0, 2*x*y>0, x^2-y^2>0]
10:13:10 <lambdac>  <IO ()>
10:13:37 <saml> >  map (\(x,y) -> [2*x*y,x^2-y^2,x^2+y^2]) [(x,y)|x<-[1..1000],y<-[1..1000],x^2+2*x*y+x^2==1000, x^2+y^2>0, 2*x*y>0, x^2-y^2>0]
10:13:38 <lambdac>  [[200,375,425]]
10:13:57 <asdftimo> it returns the only pythagorean triple whose terms sum to 1000
10:13:57 <asdftimo> that was the purpose
10:14:02 <asdftimo> http://projecteuler.net/index.php?section=problems&id=9
10:14:04 <lambdac> Title: Problem 9 - Project Euler
10:14:09 <lilachaze> asdftimo: [(x,y) | x <- [-500..500], y <- [-500..500], 2*x*(x+y) == 1000]
10:14:19 <dons> Igloo: apache needs a restart?
10:14:30 <dons> yeah, it sure is slow to connect to
10:14:56 <dons> oh, i see a bunch of apaches
10:15:07 <dons> load average around 2?
10:15:41 <Igloo> It's restarting, just let it finish
10:15:46 <ronwalf> ouch, ghc 6.8.1 didn't work so hot....
10:15:46 <dons> yep
10:15:48 <dons> all good
10:16:39 <asdftimo> hey, how can you sum the elemnts of a list inside a list: [[1,2,3]]
10:17:00 <xerox> fmap sum
10:17:08 <byorgey> asdftimo: sum . sum, or sum . concat
10:17:17 <byorgey> er, not sum . sum
10:17:19 * ronwalf should figure out fmap at some point
10:17:24 <byorgey> sum . fmap sum
10:17:40 <asdftimo> fmap sum works great xerox
10:18:54 <_zenon_> ?ty fmap
10:18:56 <lambdac> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:20:08 <esteth> I've noticed while learning haskell that no-one's told me how to make a variable number of arguments function. Is this because it is impossible, or just so hackish that it's not worth it? I've noticed lots of functions in the standard library using names like Lift3 or Lift5 or whatever (not sure if lift is like this, but some functions are) for "variable" length arguments, but they only go up to so many arguments
10:20:09 <ronwalf> oh, 6.8.1 was sensitive to a trailing / in --prefix= argument
10:20:16 <ronwalf> (ie, it didn't like it very much)
10:20:30 <mauke> esteth: it's possible but usually not worth it
10:21:05 <mauke> e.g. liftM4 f x y z can also be written f <$> x <*> y <*> z for arbitrarily many arguments
10:21:47 <tromp> :t <$>
10:22:10 <lambdac> thread killed
10:22:11 <esteth> mauke, Ahh, ok, I havn't really noticed myself neading them anyway, but was curious. Thanks for the snippet there though, I'm sure it'll come in handy later
10:22:13 <mauke> er
10:22:23 <dblhelix> I probably best ask this on haskell-cafe, but let me first try it here: does anyone now of third-order functions (or functions of even higher order) to show up in practice (and "practice" may include academic papers, I don't mind ;-))?
10:23:05 <zeno> poor lambdac
10:23:12 <zeno> cant be all rough on it like lambdabot
10:23:18 * sclv sputters and curses at control.category's irritiating interplay with hxt
10:23:22 <mauke> :t (<$>)
10:24:03 <tromp> :t ""
10:24:14 <tromp> :t :t
10:24:24 <mauke> @bat
10:24:28 <mattam> dblhelix: It's pretty rare. You can get very high-order when playing with continuations for example. I don't have an example though.
10:24:45 <dblhelix> mattam: thanks anyway
10:25:11 <lambdac> Maybe you meant: bf bug fact faq ft let map part what
10:25:11 <lambdac> thread killed
10:25:28 <lambdac> thread killed
10:25:29 <lambdac> thread killed
10:26:09 <tromp> > ()
10:26:14 <sclv> also, it sort if occurs to me that hxt could *really* have used the concept of some arrow transformers.
10:26:19 <dons> is that hosted on code.haskell.org?
10:27:30 <mauke> I blame dibblego
10:28:51 <dons> dblhelix: generics
10:29:32 <dons> :t gunfold
10:29:35 <zeno> is there another bot on thats like nambdabot?
10:29:41 <dons> sigh.
10:29:50 <dons> this lambdabot situation is ridiculous.
10:29:52 <mauke> namblabot
10:30:37 <dblhelix> dons: yeah, but afik, only if you have type-indexed functions over higher-kinded types
10:31:03 <ziman> â-bot
10:31:33 <saml> > 1
10:31:45 <dblhelix> dons: so, then it reduces to "how often do you encounter type constructors with a higher-order kind?"
10:32:12 <dolio> @type callCC
10:32:45 <dolio> ((a -> m b) -> m a) -> m a
10:32:53 <dons> i want this bot situation sorted out.
10:34:07 <dblhelix> dolio: yeah, that would be the prototypical example, I guess
10:34:31 <dolio> Some functions are instantiated as third order in practice.
10:34:40 <dolio> fix :: ((a -> b) -> a -> b) -> a -> b
10:35:09 <dblhelix> dolio: also true, thanks!
10:35:19 <lambdac>  ()
10:35:19 <lambdac>  1
10:35:21 <lambdac> forall (c :: * -> *) a. (Data a) => (forall b r. (Data b) => c (b -> r) -> c r) -> (forall r. r -> c r) -> Constr -> c a
10:35:21 <lambdac> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
10:35:35 <fons> hi!
10:36:41 <mauke> :t (<$>)
10:37:32 <lambdac> thread killed
10:40:37 * ronwalf builds ghc 6.8.3 in /tmp to get around his quota
10:41:44 * gwern sighs. so hint was updated to try to get around the unrestricted import problem, but thanks a lot GHC API, it still lets in unsafePerformIO
10:43:53 <asdftimo> hello, i need help writing an instance declaration for the following function:
10:43:54 <asdftimo> isprime n=not (elem 0 $ map(\x -> mod n x) $ takeWhile(\x -> x^2 <= n)[2..])
10:44:26 <mauke> instance declarations are for classes/types, not functions
10:44:28 <byorgey> asdftimo: do you mean a type declaration?
10:44:47 <gwern>  isprime :: [Integer], I'd guess
10:44:48 <fons> @seen dcoutts_
10:44:57 <asdftimo> hm, well ghci says " No instance for (Integral (IO ()))"
10:45:06 <gwern> oh, n. so Integer -> [Integer]
10:45:25 <mauke> asdftimo: that means you forgot parens (probably)
10:45:26 <byorgey> should be  -> Bool, I think
10:45:39 <gwern> asdftimo: you are having ghci problem?
10:45:44 <gwern> try 'let isprime'...
10:45:49 <gwern> it works fine for me
10:45:56 <lambdac> dcoutts_ is in #haskell. I last heard dcoutts_ speak 6d 1h 49m 28s ago.
10:45:59 <gwern> isprime 10 ~> False
10:46:14 <asdftimo> it works in ghci, but i can't compile the program
10:46:17 <zeno> > isprime 10 ~> False
10:46:18 <lambdac>   Not in scope: `~>'
10:46:21 <fons> pour lambdac , what a lag
10:46:59 <saml> > let isprime n=not (elem 0 $ map(\x -> mod n x) $ takeWhile(\x-> x^2 <= n)[2..]) in isprime 2
10:47:00 <lambdac>  True
10:47:15 <asdftimo> i know it works, i just can't compile...
10:47:19 <mauke> asdftimo: then there's an error in your program
10:47:26 <gwern> asdftimo: need more details, srsly
10:47:32 <gwern> hpaste the module and error
10:47:34 <saml> asdftimo: how do you call isprime function?
10:47:47 <asdftimo> sorry, here is more info
10:47:48 <asdftimo> primelist = [x | x <- [2..], isprime x]
10:47:52 <saml> you probably need main IO action to compile
10:47:58 <gwern> the function definition you've shown us is just fine, so how could we possibly diagnos the larger problem when all we've seen is correct stuff
10:48:09 <mauke> primelist is also fine
10:48:23 <hpaste>  asdftimo pasted "primes" at http://hpaste.org/8654
10:48:36 <asdftimo> sorry im working on it
10:48:40 <asdftimo> check the link
10:48:44 <mauke> asdftimo: oh
10:48:48 <mauke> obvious error is obvious :-)
10:48:57 <person> main = print $ ...
10:49:00 <MyCatVerbs> asdftimo: you have main = sum $ ..., you want main = print . sum $ ...
10:49:03 <mauke> asdftimo: you've defined main as sum ...
10:49:10 <asdftimo> damnit. haha thanks guys
10:49:13 <mauke> that means main is a number when it should be an IO action
10:50:14 <person> @quote
10:50:15 <lambdac> VirginiaCurry says: "You know, Haskell actually never liked the name Haskell." -- Virgina Curry (Haskell B. Curry's widow)
11:02:16 <thetallguy> That's why it makes a good name for a language
11:02:39 <thetallguy> WIt should take the name out of circulation for real people, eh?
11:06:48 <newsham> ?bot
11:06:48 <lambdac> :)
11:13:57 <saml> > 1 `\x y -> x + y` 2
11:13:57 <lambdac>  Parse error at "\x" (column 4)
11:14:36 <Heffalump> saml: only identifiers can be backquoted
11:14:41 <EvilRanter> ``s can only have a name between them, unfortunately
11:15:02 <matthew-_> so is everyone preparing for the icfp prog contest coming up then?
11:15:26 <EvilTerran> however, you can define "infixl 1 <|, |>; (<|) = flip ($); (|>) = ($)"
11:15:39 <EvilTerran> and then write stuff like "xs <|zipWith (+)|> ys"
11:17:28 <saml> > let (<|) = flip ($); (|>) = ($); in 1 <|(\x y -> x + y)|> 2
11:17:30 <lambdac>  3
11:17:59 <_zenon_> sugarsugarsugar
11:20:25 <saml> this is so awesome
11:22:47 <gwern> wish I knew how to prepare for icfp
11:23:09 <gwern> stock up on drugs and make sure my setup is clean and prepared, I guess
11:23:44 <dolio> Consult your oracle as to what data structure will be necessary this year (which is already provided by the C++ STL).
11:24:27 <gwern> dolio: eh? last year used ropes, I thought, and I didn't think the stl provided it (or else I'm making up memories of reading c++ blog posts about writing them)
11:24:58 <dolio> I'm pretty sure I heard at least someone's implementation had them.
11:25:05 <dolio> GCC, I imagine.
11:25:37 <dolio> They may not be part of the standard, though.
11:26:27 <newsham> mmm, icfp contest next week.
11:27:03 <dolio> Speaking of that, where are all the rope libraries for Haskell? I thought we were going to have one since a bunch of people made them last year.
11:27:05 <newsham> i went and redid my last year dna engine using Data.Sequence for some practice
11:27:12 <newsham> (which I didnt know existed last year)
11:28:22 <newsham> dolio: data.sequence has efficient sequence data type based on finger trees
11:28:29 <newsham> http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-Sequence.html
11:28:31 <lambdac> http://tinyurl.com/3dzkp8
11:28:55 <gwern> dolio: good question. I don't see any ropes on hackage
11:28:59 <gwern> maybe people got bored
11:29:00 <roconnor> my rope efforts died
11:29:12 <newsham> i think writng a boyer-moore for Data.Sequence would be a useful exercise
11:29:23 <newsham> but havent gotten around to it
11:30:16 <dolio> I know. But Seq is not exactly a rope, though. At least, it's not an implementation of the particular data structure I saw in what was suppoed to be 'the original rope paper' or something.
11:30:44 <dolio> Seq might be better, for all I know, though.
11:30:56 <roconnor> A haskell rope is represented by a seq of strict bytestrings
11:31:10 <roconnor> but these strict bytestrings can be split on demand
11:31:20 <roconnor> obviously indexing needs to be changed
11:31:22 <asdftimo> what do i need to import to use "encode"?
11:31:30 <monochrom> Data.Binary
11:32:08 <roconnor> I think I got frusterated because my Ropes were never faster that Seq Char.
11:32:18 <roconnor> ... although they used 1/10 of the memory
11:32:27 <dolio> Huh.
11:32:38 <monochrom> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/binary  has Data.Binary
11:36:12 <blais> Hi all.
11:36:20 <blais> me: Haskell newbie trying to find his way.
11:36:31 <blais> Have question about HXT.
11:36:44 <blais> Does anyone know how to disable validation?
11:36:51 <blais> (DTD validation, that is.)
11:37:25 <blais> I get an error message, unless I remove the DOCTYPE from the file -- not practical-- or create an empty file as placeholder.
11:37:41 <Baughn> blais: Nope. I do know that haxml doesn't validate unless you ask it to
11:37:46 <blais> I looked at the source for HXT, and it looks like it's not meant to be disableable.
11:38:02 <Baughn> blais: Or you could do a little filtering of the string before you pass it to hxt to remove the doctype
11:38:10 <blais> (although my head still hurts from reading J. Hughes' Arrows paper, and I can't be quite sure of what I'm advancing.)
11:38:36 <blais> ah... great idea indeed.
11:38:38 <Baughn> blais: Hang on. How does it validate if there isn't a copy of the dtd on your machine?
11:38:50 <blais> it doesn't: it fails.
11:38:56 <Baughn> ..I see.
11:39:03 <Baughn> Well, removing the doctype shoudl wrk
11:39:04 <blais> fatal error: file "/home/blais/p/haskell/pdf2table/pdf2xml.dtd" not found
11:39:18 <Baughn> Anyway, failining is infinitely better than trying to /download/ the doctype
11:39:31 <Baughn> *dtd
11:39:36 <monochrom> blais: readDocument [ (a_validate, v_0) ] filename   suppresses validation, but the DTD is still read
11:39:49 <blais> indeed. But better would be to fix the code so that a_validate with "0" does what it seems like it should :-)
11:40:05 <blais> monochrom: that's the problem. I don't have the DTD.
11:40:22 <blais> What's the point of trying to read the DTD if validation is disabled?
11:40:33 <blais> Sounds like a bug to me.
11:40:43 <monochrom> Here is a reason for reading DTD anyway.  It may contain macro definitions you need, e.g., &myentity; should expand to ...
11:40:58 <Baughn> monochrom: Moreover, only document /creators/ should really worry abut validating. For readers, validation will either make it fail on something it might otherwise not, or do nothing but waste time
11:41:10 <hpaste>  LordBrain pasted "QuickCheck Question" at http://hpaste.org/8655
11:41:19 <Baughn> ..okay, macro definitions is a good one
11:41:28 <LordBrain> i'm trying to understand Test.QuickCheck.generate
11:41:38 <Baughn> Though I'd still recommend reading it /lazily/, when the first entity is encountered. :P
11:41:49 <blais> That's right: in the great majority of cases, you don't want to validate. IMHO there should be a way to disable having to read the DTD.
11:41:53 <monochrom> There is a chain of HXT calls that performs readDocument minus DTD reading. But I forgot how.
11:42:27 <LordBrain> the above post shows a simple little program i wrote to help me understand it... but i dont get the first parameter the int in generate
11:42:31 <LordBrain> @hoogle generate
11:42:32 <lambdac> A Hoogle error occured.
11:42:32 <monochrom> In an hour I may re-discover it. :)
11:43:31 <Baughn> blais: By the way, how's the performance of hxt? Any better than haxml?
11:44:04 <Baughn> I've been doing something horrible with text search/bytestring splitting to get decent performance out of a parser here, but I'd /like/ to do it the right way, so..
11:44:13 <LordBrain> if i use the default generator for int's those do not all come out the same
11:44:43 <LordBrain> but if i make my own generator, i get the same result for generate 0 as i do for generate 11
11:45:30 <Baughn> @src <$>
11:45:31 <lambdac> f <$> a = fmap f a
11:46:08 <Baughn> @src >$<
11:46:08 <lambdac> Source not found. Are you on drugs?
11:46:46 <LordBrain> @src generate
11:46:47 <lambdac> Source not found. I am sorry.
11:47:01 <Baughn> LordBrain: Hang on. What is the problem here, exactly?
11:47:15 <LordBrain> you looking at my post Baughn ?
11:47:17 <Baughn> ..oh, I see
11:47:25 <Baughn> LordBrain: x is the generator. You're using the same one in every call to generate.
11:47:37 <LordBrain> oh?
11:47:43 <Baughn> LordBrain: Haskell being a purely functional language, same parameters in = same parameters out
11:47:53 <Baughn> *values out
11:48:17 <_zenon_> Where is <$> defined?
11:48:27 <_zenon_> In the Standard prelude?
11:48:27 <Baughn> LordBrain: I don't know from where you got generate, but use split from file:///Users/svein/doc/haskell/ghc/libraries/random/System-Random.html instad
11:48:41 <Baughn> _zenon_: Control.Applicative
11:48:50 <_zenon_> Baughn: Roger
11:48:56 <roconnor> :index (<$>)
11:49:07 <roconnor> @index (<$>)
11:49:08 <lambdac> bzzt
11:49:17 <Baughn> LordBrain: ..funny url you got there. Well, System.Random anyhow..
11:49:27 <Apocalisp> How would you quickcheck something like (\x n -> (x::Int) .&. (2 ^ n::Int) /= 0) ?
11:49:28 <LordBrain> Baughn, well... actually the whole point is to help me understand this generate thing... i'm trying to learn the ins and outs of quick check
11:50:03 <Apocalisp> same here!
11:50:29 <vcs> I need to carry around a variable<->value table, what would you recommend I use for that?  ST?
11:50:36 <Baughn> LordBrain: In that case, use RandomGen.split to get more generators
11:50:45 <Baughn> LordBrain: Or replicateM newStdGen
11:51:17 <Baughn> vcs: That depends entirely on /why/. Data.Map is usually a good start.
11:51:19 <LordBrain> Baughn, if i dont define the arbitrary instance for myself, if i just use Int's instead of P's, i get very different results
11:51:23 <LordBrain> i want to understand why
11:51:25 <vcs> I'm using Data.Map
11:51:26 <Apocalisp> (\x n -> (x::Int) .&. (2 ^ n::Int) /= 0) -- true if the nth bit is set, false otherwise
11:51:38 <Baughn> LordBrain: Can't help you there, I'm afraid
11:51:48 <vcs> but I need to insert stuff and return a new table
11:51:51 <LordBrain> here i'll post the results from using ints
11:52:14 <vcs> I just wasn't sure if I should manually use a tuple or if ST is used for non-IO related stuff
11:52:15 <Baughn> vcs: So..look up the appropriate data.map function for that?
11:52:16 <vcs> I'm fairly new
11:52:52 <Baughn> vcs: ST is used when you want mutable state but /don't/ want IO, and lets you get "escape" from that mutable program back to pure haskell, unlike IO
11:53:04 * Baughn hastily plasters over unsafePerformIO
11:53:55 <Baughn> vcs: For "mutable" state in pure code, Data.Map has O(lg n) on just about every function, s it's very convenient. You can just pass one of those around.
11:54:08 <vcs> If I pass a map into something and it calls insert, I was under the assumption that creates a new map, am I wrong?
11:54:14 <Baughn> (Meaning, ST is used mostly on performance-critical code)
11:54:19 <Baughn> No, that's right
11:55:40 <hpaste>  LordBrain annotated "QuickCheck Question" with "QuickCheck, now using Int" at http://hpaste.org/8655#a1
11:55:59 <LordBrain> see my annotation Baughn
11:56:19 <vcs> I'm writing a tiny parser, so in read-eval-print I have something like "forever (get . eval)", should I just have eval return a tuple with the updated map?
11:56:30 <vcs> just not sure what the "clean" way of passing the updated map aruond is
11:56:30 <Baughn> LordBrain: The details would depend on how/why generate works. I can't help you there.
11:56:47 <LordBrain> yeah there is no documentation
11:56:49 <Baughn> LordBrain: The reason it /can/ be different is that you're passing different parameters to generate, but you knew that
11:56:51 <LordBrain> that i know of
11:56:58 <LordBrain> i guess i can dig into the source
11:57:10 <Baughn> What's the first parameter to generate /supposed/ to do?
11:57:15 <LordBrain> exactly my question
11:57:20 <LordBrain> that's what i'm trying to figure out
11:57:25 <LordBrain> what the heck is that thing
11:57:35 <Baughn> Well, you should probably ask someone who /uses/ quickcheck. :P
11:57:37 <LordBrain> maybe it's a size?
11:58:20 <Baughn> vcs: Well, depends on your algorithm. Inside State might fit well.. or it might not, in which case don't use State.
11:58:49 <Baughn> vcs: It's not really something I can tell you. Try several ways, see which fits best; you'll develop an intuition.
11:58:59 <vcs> okay, thanks
11:59:15 <Baughn> vcs: And be aware of STRef for when you really need speed
11:59:22 <Baughn> Along with STArray and such
11:59:36 <yakov> hey again!
11:59:50 <vcs> Is there something like: State s t = s -> (s, t)?
11:59:57 <vcs> that is standard in a base library?
12:00:06 <vcs> I've read about it in books, but they always roll their own
12:00:38 <Baughn> vcs: Yes, Data.State
12:00:38 <BMeph> @src State
12:00:39 <lambdac> Source not found. That's something I cannot allow to happen.
12:00:46 <vcs> okay, thanks for the help Baughn
12:00:46 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/8656
12:00:50 <Baughn> Er
12:00:57 <BMeph> @src return State
12:00:57 <lambdac> Source not found. Sorry about this, I know it's a bit silly.
12:01:00 <Baughn> vcs: Control.Monad.State
12:01:10 <yakov> hm.. haddoc from darcs seems to be b0rken.. http://hpaste.org/8656 using ghc 6.8.3..
12:01:12 <BMeph> @src State return
12:01:13 <lambdac> Source not found. Do you think like you type?
12:01:25 <jstanley> vcs: Contorl.Monad.State has something like newtype State s a = State { runState :: s -> (a,s) }
12:01:54 * BMeph mutters to himself and goes to get a sandwich...
12:02:00 <Baughn> vcs: Another thing.. when you know in advance how much you'll be computing (like most dynamic algorithms) and can map it to an array, take advantage of Data.Array's immutable arrays being lazy in their elements
12:02:01 <jstanley> yakov: yeah, it doesn't compile with 6.8.3.
12:02:15 <Baughn> vcs: Meaning you can tie the knot, getting really fast and very nice-looking code
12:02:52 <vcs> I'll look into that too
12:02:57 <vcs> thanks again :)
12:03:24 <yakov> jstanley, ok
12:05:02 <Baughn> > let arr = listArray (0,10) $ 0:1:[arr!n + arr!(n+1) | n <- [2..10]] in arr
12:05:04 <lambdac>  array (0,10) [(0,0),(1,1),(2,Exception: Error in array index
12:05:17 <Apocalisp>  @check (\z x -> (z > 0 && x > 0) ==> nthbit x z == nthbit (x `div` 2) (z-1))
12:05:24 <Apocalisp> @check (\z x -> (z > 0 && x > 0) ==> nthbit x z == nthbit (x `div` 2) (z-1))
12:05:25 <lambdac>  Arguments exhausted after 304 tests.
12:05:30 <Baughn> > let arr = listArray (0,10) $ 0:1:[arr!(n-1) + arr!(n-2) | n <- [2..10]] in arr
12:05:32 <lambdac>  array (0,10) [(0,0),(1,1),(2,1),(3,2),(4,3),(5,5),(6,8),(7,13),(8,21),(9,34)...
12:05:39 <Baughn> vcs: ^-- See? ;)
12:11:02 <LordBrain> In case anyone was wondering the first parameter to Test.QuickCheck.generate is indeed the 'size' parameter which is implicitely passed to generators to facilitate recursive generations terminating at some point.
12:11:17 <hpaste>  LordBrain annotated "QuickCheck Question" with "QuickCheck, It's the 'size' parameter." at http://hpaste.org/8655#a2
12:11:28 <LordBrain> ah.. there it is... slow announcement
12:11:55 <LordBrain> hi dons
12:11:55 <blais> Another newbie question:
12:12:03 <blais> I'm trying to filter out my DOCTYPE line.
12:12:10 <blais> (from the previously mentioned XML document.)
12:12:17 <matthew-_> how can I get ghci to look in a certain dir for a given module?
12:12:26 <blais> There are functions in the ByteString module to do matching on substrings. Convenient ones.
12:12:39 <blais> They are not available on normal strings ([Char]) it seems.
12:12:45 <blais> Is the usage of ByteString prevalent?
12:12:48 <matthew-_> say I have sources in foo bar and baz and I want to load Wibble.hs which is in foo, but imports stuff which is in bar and baz
12:13:07 <blais> for example, I'm having to write my own "lines" function  (using split).
12:13:10 <Baughn> blais: It is, but they are
12:13:31 <Baughn> blais: Look in Data.List - isPrefixOf exists just fine
12:13:45 <matthew-_> ahh, -i does work
12:13:49 <matthew-_> I'm being dumb. sorry
12:13:51 <blais> I guess in "real world" apps everyone uses ByteString, right?
12:14:10 <Baughn> blais: Depends on the app. :P
12:14:20 <LordBrain> i think ghc requires that the filename match the module name for modules other than Main
12:14:21 <blais> Why not make it the default?
12:14:32 <blais> That's how it is in most dynamic languages, strings are immutable vectors of chars.
12:14:39 <Baughn> blais: Um, because bytestrings have dramatic drawbacks?
12:14:40 <blais> Much faster than all these cons cells...
12:14:47 <blais> Which drawbacks?
12:15:07 <blais> It's a compromise, which wins in most usages for the ByteString side.
12:15:12 <blais> (AFAIK)
12:15:12 <Baughn> To begin with, they contain Word8s, not nicode Chars
12:15:28 <blais> Well, that could be fixed, with another encoding.
12:15:36 <Baughn> As for the compromise, that's why we have both. Nobody's forcing you to use just one.
12:15:38 <LordBrain> i think we do have bytestring literals
12:15:47 <LordBrain> i dont know how to turn t hem on
12:16:20 <blais> the issue of encoding is a separate issue; what I'm referring to is "vectors of chars" (as one object) vs. "lists of chars" (lots of cons cells)
12:16:41 <LordBrain> there is a ghc option -XOverloadedStrings
12:16:59 <blais> Baugh: I have to admit, coming from the outside, that the duplicity (or should I say n-plicity) of definitions of many functions with the same name is quite offputting to an outsider.
12:16:59 <gwern> blais: bytestrings often lose to String due to overhead. also, bytestrings have trouble with infinite datastructures, currently are terrible with unicode, have functions which work differently sometimes from the regular ones, and more importantly, it interacts poorly with code that works with the list of chars paradigm
12:17:17 <Baughn> blais: How would you disambiguate?
12:17:32 <Baughn> blais: isPrefixOf is a good name, so you just say "import qualified ByteString as B"...
12:18:10 <gwern> blais: yeah, it's something of a code smell. but renaming all the functions is even worse...
12:18:12 <blais> Namespaces? Or better: maybe there needs to be a Benevolent Dictator that decides on the best compromise (taht's the Python approach, and as a result the language is extremely simple and popular.)
12:18:29 <blais> Otherwise Haskell could end up like LISP...
12:18:32 <LordBrain> i agree with Baughn, overloading the functions makes a lot of sense to me
12:18:42 <Saizan> blais: modules ARE namespaces
12:18:47 <LordBrain> yes
12:19:20 <Baughn> blais: Anyway, we don't /want/ haskell to be too popular. It would interfere with the goal of being the perfect research language.
12:19:26 <blais> Saizan: unless you import everything explicitly, it's very much non-obvious where a symbol comes from (actually, frustrating for a beginner)
12:19:32 <Baughn> ..though it seems it has slipped a bit in that respect lately
12:19:34 <blais> Ah.
12:19:42 <EvilTerran> "import qualified"
12:19:50 <LordBrain> different people have different goals for haskell
12:20:11 <LordBrain> some of us do want it to be popular
12:20:35 <blais> I understand that, but it seems to me that with very few compromises you could make something really practical *and* great for explorations.
12:20:57 <Baughn> blais: So, what exactly would you change?
12:21:26 <blais> I don't know all that much about it (read 3 books and all the important papers, and its all recent) but it seems to me that these two forces aren't contradictory ( a -> making it practical, b -> leaving space for explorations)
12:21:46 <Baughn> blais: Bytestrings are /there/. So are arrays. And with utf8-string, you can even get unicode in bytestrings.. kinda
12:22:10 <blais> Baughn: I won't get started ... I have an entire file with beefs about my experience with it, but I won't foray into writing that until I have spent much more time fiddling with Haskell, it wouldn't be fair.
12:22:22 <Baughn> blais: But making it popular definitely /would/ interfere with research, as research involves making old-code-breaking changes on a relatively frequent basis
12:22:41 <LordBrain> They already seem very reluctant to break old code
12:22:48 <blais> Baughn: does *all* research code have to end up in the GHC release?
12:22:53 <blais> (I assume it already doesn't.)
12:23:16 <Baughn> blais: Mm. It's true, GHC/haskell is already veering off from that path.
12:23:17 <LordBrain> otherwise we'd probably have some new kind of records
12:23:17 <blais> Sounds like you're bound to have a schizm at some point btw people who want to get things done and the academics...
12:23:42 <Japsu> Omg, what, overloaded strings?
12:23:51 <Baughn> LordBrain: ..that makes me cry. I love writing in haskell, but plase give me new records.
12:23:52 <gwern> blais: no, ghc research often doesn't make it into production. iirc, sjanssen told me about smp GC for 6.6 or something which wasn't stable enough to get used, and then there are the weird GHC forks like distributed ghc which hasn't really made it back
12:23:59 <Japsu> Does that mean that you can use "foo" as a ByteString literal?
12:24:09 <Baughn> > pack "foo"
12:24:10 <lambdac>   Not in scope: `pack'
12:24:17 <LordBrain> i'm on the practical side  i guess, yet i want the new records too
12:24:22 <Japsu>  22:16   LordBrain : there is a ghc option -XOverloadedStrings
12:24:24 <blais> I would love that (ByteStrings by default)
12:24:36 <mauke> Japsu: yes
12:24:53 <Baughn> blais: What does "by default" mean here? Presumably it uses type inference to decide..
12:24:54 <Japsu> "foo" :: LiteralString a -- ^^
12:25:15 <Baughn> "foo" :: (Data.String.IsString t) => t
12:25:38 <blais> Actually, the amount of space that loading up a large XML file with [Char] must be ridiculous and impractical. I know I know, you're doing it lazy, but sometimes you need a DOM-like interface. I have a friend writing a server in Erlang recently, and he had this problem.
12:26:17 <gwern> I sometimes wonder how often string could be replaced by bytestring with no problem; maybe it's something ghc could be doing as an optimization
12:26:19 <Baughn> blais: Oh, that's definitely true. I *want* an xml parser that uses lazy bytestrings, please..
12:26:28 <Saizan> gwern: often is a bit unfair, there also many innovations that are promptly integrated
12:26:37 <Baughn> blais: Parsing some eight gigs of xml required me to write my own parser to get any sort of speed
12:26:58 <LordBrain> Japsu, http://www.haskell.org/pipermail/haskell-cafe/2008-January/037497.html
12:27:08 <Japsu> LordBrain: cool
12:27:21 <gwern> Saizan: until you show me statistical analysis of all the ghc research papers, I shall stand by it :)
12:27:30 <blais> Baughn: I mean that [Char] should have to be explicit, and the other approach be implicit. Not sure about all the details and implications in the Haskell language, but it seems to me that all string parsing should be done on vectors, taking advantage of low-level C functions with tight loops to much of the real work.
12:28:09 <blais> Actually, I don't know anyone coming from a background of C/Python/Perl, etc. who doesn't *cringe* at the idea of using [Char]...
12:28:12 <Baughn> blais: No need for that. You'd expand the Data.String.IsString class to support all the basic functions, write the others in terms of those, and type inference would pick the right one.
12:28:22 <mauke> blais: me!
12:28:23 <EvilTerran> blais, but lists are nicer to manipulate algebraically
12:28:32 <Saizan> gwern: i was asking you the same kind of proof for your claim :)
12:28:37 <gwern> Baughn: why hasn't that been done?
12:28:44 <blais> EvilTerrain: I know, but in practice you *dont* do that.
12:28:49 <roconnor> Dont we have rewrite rules that turn ByteString --> String --> String --> Bytestring processes into processes that purely use ByteString?
12:28:54 <matthew-_> Are there any make gurus in here?
12:28:59 <gwern> Saizan: no, no, I insist you bear the burden of proof...
12:29:09 <Baughn> gwern: For all I know, it's being done. I didn't know it /existed/ until just now.
12:29:20 <roconnor> maybe no
12:29:37 <blais> Part of it will be a cultural debate I believe-- It's a bit like me arguing with Guido about that absence of lists in Python, the Python community doesn't see a problem with that. (weird huh?!)
12:30:22 <LordBrain> you mean lazy lists?
12:30:24 <gwern> wait, how could python not have lists?
12:30:31 <blais> LordBrain: not even.
12:30:33 <blais> Just normal lists.
12:30:40 <blais> Cons cell. Doesn't exist in Python.
12:30:40 <asdftimo> hi, im using the following command to find the first Fibonacci number with 1000 digits, but i also need to know what term it is (1st, 2nd ,3rd) in the list. how can i do it?
12:30:41 <asdftimo> print $ last $ takeWhile(\x -> (length (map digitToInt (show x)))<=1000) $ fiblist
12:30:49 <blais> When asked, Guido replies: "What's your use case?"
12:31:04 <LordBrain> lol
12:31:07 <Gilly> asdftimo: you can zip [1..] with the list and carry that info around
12:31:19 <LordBrain> the vast cultural devide
12:31:31 <blais> No kidding. Pythonistas are really bent on practicality, to the extent that they recognize they can do everything with vectors, and it pretty much works, except that it's a bit wasteful.
12:31:48 <asdftimo> thanks Gilly
12:31:48 <asdftimo> looks like what i want
12:31:52 <Saizan> blais: the problem is that lists are a very nice structure to use, especially as a control structure, so it's just natural to reuse the general list machinery to deal with [Char], if you know that you need efficiency ByteString is there
12:32:03 <Gilly> asdftimo: have fun :)
12:32:09 <blais> I mean, they've got a point, in a way, memory is cheap.
12:32:13 <mauke> asdftimo: length (map f xs) better written as length xs
12:32:51 <LordBrain> i like that strings as lists exist
12:32:56 <blais> Saizon: you don't have to convince *me* about the value of lists, I'm a LISP devotee, but for strings I feel like the operations are for the most part done at a higher level.
12:33:29 <Gilly> mauke: i so love haskell for being able to do that kind of reasoning easily :)
12:34:45 <LordBrain> i like that they came first... if it hadn't happened that way we'd probably never have developed all this nice list interface for strings... makes learning easier too... fire up your interpreter and test your list functions on strings.
12:34:52 <blais> gwern: the Python "list" object is a contiguous array in memory, not a cons cell.
12:34:54 <asdftimo> mauke: thanks. good catch.
12:35:30 <blais> LordBrain: not arguing against their existence, but rather against their being the default.
12:36:07 <Saizan> blais: if you're using them at an higher level i don't see what kind of language support would help
12:36:18 <asdftimo> if i have a pair (x,y), how can i only print x? i think i could use print $ map(\(x,y) -> x) but that seems inefficient
12:36:51 <mauke> asdftimo: it isn't
12:36:52 <jstanley> asdftimo: use fst
12:36:57 <mauke> @src fst
12:36:58 <lambdac> fst (x,_) =  x
12:37:41 <asdftimo> great, it works. thanks guys.
12:38:02 <solrize> lisp has usually done strings as byte vectors.  also, clean has atomic strings.
12:38:31 <Mitar> hmm
12:39:07 <Mitar> how could I solve "Could not find module Graphics.UI.GLUT" error?
12:39:19 <Mitar> i have a source code I have been writing some year ago
12:39:26 <mauke> install Graphics.UI.GLUT
12:39:30 <Mitar> how?
12:39:42 <BMeph> Wasn't that one of paul Graham's "wishes," that people represent strings as lists of characters, with all of the same list-manipulating functions? I remember reading that, and thinking, 'Oh no, now he's going to declare Haskell is a Lisp.' ;)
12:39:54 <Mitar> it is not bundled into official ghc?
12:42:39 <matthew-_> making clean would be odd: "make" would make clean, whilst "make clean" would make clean. ;)
12:42:55 <LordBrain> lol
12:43:21 <gwern> amusing
12:44:08 <LordBrain> someone should add that to the quotes in lamddabot
12:45:08 <cinimod> @undo [ 3 | x <- [1..3]]
12:45:08 <lambdac> concatMap (\ x -> [3]) [1 .. 3]
12:45:40 <AlphaTiger> Hello everyone !
12:45:47 <maltem> @remember matthew-_ making clean would be odd: "make" would make clean, whilst "make clean" would make clean. ;)
12:45:47 <lambdac> I will never forget.
12:45:56 <mauke> @slush
12:45:57 <lambdac> Not enough privileges
12:46:14 <LordBrain> @quote matthew-_
12:46:14 <lambdac> matthew-_ says: making clean would be odd: "make" would make clean, whilst "make clean" would make clean. ;)
12:46:28 <LordBrain> cool thanks
12:47:03 <AlphaTiger> Does someone know how to get rid of the "Inferred type is less polymorphic than expected" error ?
12:47:07 <LordBrain> thunder..
12:47:14 <blais> Allright, filtering out Doctype worked, thx.
12:47:19 <sjanssen> @flush
12:47:19 <lambdac> Not enough privileges
12:47:29 <byorgey> hi AlphaTiger
12:47:31 <sjanssen> impostor!
12:47:31 <matthew-_> LordBrain: An unusual solution...
12:47:35 <mauke> AlphaTiger: fix your type signatures
12:47:57 <byorgey> AlphaTiger: it's a bit hard to tell without more context.  if you paste your code and error message(s) on hpaste.org someone can take a look
12:48:10 <AlphaTiger> byorgey: http://pastebin.com/d637b3f13
12:48:25 <mauke> oh, GADT
12:48:30 <LordBrain> matthew-_, what are you speaking in regard to?
12:48:46 <mauke> and existentials!
12:48:57 <AlphaTiger> the error :http://pastebin.com/m5f412a96
12:49:05 <matthew-_> LordBrain: AlphaTiger's question
12:49:05 <byorgey> ah, PADS =)
12:50:13 <Mitar> nevermind ... i read manual and installed everything successfully
12:50:42 <byorgey> hmm, tricky...
12:51:11 <mauke> AlphaTiger: I don't understand how that code is supposed to work
12:51:19 <mauke> oh wait
12:51:22 <mauke> b = a
12:51:30 <byorgey> AlphaTiger: ah, I think I see.  The problem is that according to the type of brancher, the *caller* of brancher should be able to choose the type b
12:51:44 <byorgey> that is, it should work for any type b the caller wishes to use
12:51:59 <byorgey> however, a value of type (Branch a) contains some *specific* type b
12:52:27 <byorgey> existential types are confusing. =P
12:52:31 <AlphaTiger> ^^
12:52:48 <byorgey> (disclaimer: take everything I said above with a small grain of salt...)
12:53:00 <AlphaTiger> byorgey: Is there a way to get rid of that ? Or to do it another way ?
12:53:13 <AlphaTiger> In fact, I have (for example) a printer function
12:53:32 <byorgey> AlphaTiger: why do you need the forall b.  in the definition of Branch?
12:53:40 <byorgey> why not just make b a parameter along with a?
12:54:32 <AlphaTiger> byorgey: I need to have all the objects have the same type
12:54:49 <byorgey> oh, I see, and they might have different types for b
12:54:54 <AlphaTiger> byorgey: yes
12:55:47 <AlphaTiger> In fact, it is to handle the case when we can have an Int or a Char (or whatever) in the data
12:55:48 <LordBrain> what is PADS?
12:55:52 <LordBrain> where is it defined?
12:56:25 <AlphaTiger> LordBrain: data PADS x where [...] Pdata:: [Branch a] -> PADS a
12:57:01 <AlphaTiger> Maybe there is another way to achieve what I want to do :
12:57:16 <AlphaTiger> I have, for example, a printer function
12:57:44 <AlphaTiger> that takes a description of the data (that is, something of the type PADS) and a data of this type
12:57:53 <AlphaTiger> for example, printer Pint 5
12:58:00 <AlphaTiger> (Pint :: PADS Int)
12:59:03 <byorgey> AlphaTiger: well, just some thoughts: first of all, the type  brancher :: [Branch a] -> a -> (PADS b, b)  is almost certainly wrong, since that means brancher should be able to return a (PADS b, b) for *any* type b.
12:59:12 <byorgey> which seems impossible.
12:59:28 <byorgey> also, in my experience, existential types are usually done in conjunction with some sort of type class
12:59:48 <byorgey> i.e. you don't just say "any type", you say "any type which is an instance of type class Foo"
13:00:07 <byorgey> since then you can do something useful with the values (use them with functions from that type class) even if you don't know exactly what type they are
13:00:42 <AlphaTiger> hmmm ...
13:00:52 <AlphaTiger> byorgey: thanks for the advice
13:00:55 <AlphaTiger> the problem is
13:01:00 <byorgey> I don't know if that's helpful, but without knowing a lot more about exactly what you're trying to accomplish it's hard to give more specific advice
13:01:10 <AlphaTiger> byorgey: yes, I'll try to explain
13:01:12 <byorgey> ok
13:01:15 <AlphaTiger> so, from the beginning
13:02:08 <AlphaTiger> PADS is a software that tries to help users handling data
13:02:18 <AlphaTiger> the user writes a description of the data
13:02:28 <AlphaTiger> (for example, web server logs)
13:02:41 <AlphaTiger> in the description
13:03:10 <AlphaTiger> we can have for example a type pair = int * int | char * char
13:03:12 <byorgey> ok, right
13:03:21 <AlphaTiger> I'm trying to handle this case
13:03:30 <byorgey> and it generates parsing/pretty printing tools?
13:03:36 <AlphaTiger> byorgey: yes
13:03:38 <byorgey> ok
13:03:50 <AlphaTiger> now, I'm writing (for instance) a "printer" function
13:04:12 <AlphaTiger> as I explained a bit before
13:04:53 <AlphaTiger> the printer function takes the description (that was parsed into something of the PADS type)
13:05:20 <AlphaTiger> and thus becomes a printer for data matching this description
13:05:28 <AlphaTiger> (I don't know if I'm really clear)
13:05:44 <byorgey> wait, so something like pair = int * int | char * char  could get parsed into a value of the PADS type?
13:05:56 <blais> HXT gurus, need a bit more help. I've been wading through the examples, and there are a lot of codes about validation and such things, there is a simple HelloWorld, but not all that much "real world" examples. I'm not sure how to go about this: I have as input an XML file, which I read via readString, and the file basically contains a list of similar tags, with attributes. I want to convert this into an IO [MyType], where MyType will
13:06:11 <AlphaTiger> byorgey: yes and no
13:06:15 <AlphaTiger> for this example
13:06:23 <blais> Can I get "out of the Arrows" and "into the IO monad" with HXT?
13:06:27 <blais> How do I do this?
13:06:47 <blais> I can't seem to wrap my head around this.
13:06:57 <AlphaTiger> I want to have the function "printer (Pdata [the branchs])" to accept both (Int,Int) and (Char,Char) types
13:07:07 <byorgey> AlphaTiger: I ask because I want to understand what the type parameter to PADS represents
13:07:21 <blais> all the examples read, do something, then write. I don't want to write, just to extract some stuff from the XML file, and then away with the monads.
13:07:28 <AlphaTiger> byorgey: printer :: PADS a -> a -> String
13:07:30 <blais> s/monads/arrows/ (sorry)
13:07:36 <mofmog> so i'm using getCPUTime
13:07:37 <mofmog> and
13:07:39 <blais> Can this be done?
13:07:40 <mofmog> mkStdGen
13:08:11 <mofmog> but getCPUTime :: Integer
13:08:16 <mofmog> mkStdGen takes an Int
13:08:21 <AlphaTiger> byorgey: the type parameter to PADS is the Haskell type of the data
13:08:21 <byorgey> AlphaTiger: oh, I think I understand now.
13:09:08 <byorgey> let me think about this for a minute
13:09:08 <c0dd3r5> anyone know what happened to http://book.realworldhaskell.org/beta/ ? I was totally reading that
13:09:39 <blais> c0dd3r5: was there a minute ago
13:09:53 <c0dd3r5> i've not been able to get to it for the last half hour
13:09:59 <LordBrain> is it hosted in florida?
13:10:07 <c0dd3r5> florida's gone?
13:10:09 <c0dd3r5> ?!
13:10:09 <lambdac> Maybe you meant: . ? @ v
13:10:37 <wjt> blais: you want to use runX i think
13:10:41 <wjt> @ty runX
13:10:44 <lambdac> Not in scope: `runX'
13:10:44 <LordBrain> lol c0dd3r5
13:10:59 <LordBrain> c0dd3r5, it was global warming.. the sea level took us
13:11:05 <blais> wjt: but how do I collect somethign from my run on the tree?
13:11:07 <c0dd3r5> so you can see it?
13:11:25 <iabal> Hi to all, someone could said me why this code causes a stack overflow when executed -function is tail recursive so should be transformed in a loop-?  http://rafb.net/p/6Wh0uz55.html (sorry, hpaste seems doesn't works)
13:12:15 <byorgey> AlphaTiger: the problem (at least, one problem) is that you have forall b. [Branch a] -> a -> (PADS b, b)   when what you actually want is [Branch a] -> a -> (exists b. (PADS b, b))
13:12:32 <blais> wjt: it appears to me as the prototypical case of doing something with an XML file: "read this XML file and grab something from it. Do'nt write it out.". There isn't an example that does just that.
13:12:42 <byorgey> AlphaTiger: one way around that would be to make a new type  data Value = forall b. (PADS b, b)
13:12:55 <AlphaTiger> byorgey: I try this
13:13:00 <wjt> blais: runX (readFile ... >>> yourArrowFunctionThatReturnsAFoo) :: IO Foo
13:13:13 <byorgey> er, sorry, needs a constructor :  data Value = forall B. Value (PADS b) b
13:13:26 <byorgey> and then make brancher return a Value
13:13:27 <blais> wjt: (funny, my cursor is at that very line in my code)
13:13:32 <wjt> blais: i ran around screaming for hours when i last tried to use hxt ;-)
13:13:32 <blais> >>> ...
13:13:44 <blais> wjt: it's good to know I'm not alone.
13:14:25 <blais> wjt: would you recommend somethign else?
13:14:38 <blais> wjt: I admit I wouldn't mind staying away from Arrows if I can...
13:14:39 <AlphaTiger> byorgey: waow, funny error now : "My brain just exploded." ; but it is later in the code
13:15:01 <byorgey> AlphaTiger: hehe, good work =)
13:15:02 <blais> wjt: I see "multi" and "deep", these may be what I'm looking for.
13:15:13 <c0dd3r5> hmm. maybe the internet's broken too.
13:15:13 <byorgey> AlphaTiger: I've gotten that error before
13:15:15 <mauke> AlphaTiger: that usually means you need to use case instead of let
13:15:15 <Peaker> AlphaTiger, I got that error, I think it has to do with existential types that are used on an expression that's not a let or a where
13:15:28 <Peaker> (or the other way around :-)
13:16:13 <byorgey> AlphaTiger: ah, right, you can't pattern-match on the Branch constructor like that since it's existential
13:16:38 <byorgey> you'll have to do 'brancher b = case b of (Branch (Pcons (....
13:16:46 <AlphaTiger> byorgey: thank you very much, it works now !
13:16:55 <byorgey> woohoo!
13:17:02 <LordBrain> iabal, this isn't why you get the stack overflow, but you should beware your pattern matching is not exhaustive
13:17:10 <AlphaTiger> I really like ghci errors ^^
13:17:22 <byorgey> AlphaTiger: by the way, in the interest of your general Haskell education, that's Simon Marlow's head that's exploding =)
13:17:47 <AlphaTiger> byorgey: hehe
13:18:07 <AlphaTiger> byorgey: thank you very much for your help and time
13:18:14 <byorgey> AlphaTiger: you're welcome
13:18:25 <iabal> LordBrain, why not? "dotake _ l _            = l" covers all cases?
13:18:44 <LordBrain> hmmm
13:18:59 <LordBrain> ok you're right
13:19:08 <byorgey> http://arcanux.org/lambdacats/brain.jpg
13:19:09 <LordBrain> i was thinkin gthe empty list was not caught
13:19:47 <LordBrain> iabal, x:xs is weak head normal form... so x is evaluated, you're evuating the whole list, and so it's not lazy
13:20:19 <LordBrain> at least i think that's it
13:20:28 <LordBrain> not a haskell expert here
13:21:02 <iabal> any case it must not cause an stack overflow
13:21:04 <iabal> no?
13:21:22 <_zenon_> (\(x:xs) -> () ) []
13:21:25 <_zenon_> > (\(x:xs) -> () ) []
13:21:27 <lambdac>   Non-exhaustive patterns in lambda
13:21:42 * Peaker always compiles with -Wall (gcc and ghc alike)
13:22:06 <Peaker> -Werror is nice too
13:22:07 <_zenon_> -Wall and pedantic :) If you wish to spice it up a little :)
13:22:30 <mauke> I don't think ghc has -pedantic
13:22:36 <byorgey> iabal: tail-recursion doesn't quite mean the same thing in a lazy language.
13:23:18 <iabal> byorgey, and can you said me what means in a lazy language? ;/ must be a way to do that ghc optimizes it to a loop!
13:23:26 <_zenon_> mauke: No it doesn't (I think). I was refering to gcc
13:23:50 <LordBrain> it's "can you tell me" btw.
13:24:28 <byorgey> iabal: instead of tail-recursive, you generally want to write functions which use 'guarded recursion'.
13:24:46 <byorgey> iabal: that is, the recursive call is hidden underneath a constructor.
13:25:11 <byorgey> iabal: in this case there's no reason to use an auxiliary function with an accumulating parameter.
13:25:12 <LordBrain> byorgey, in order to preserve laziness right?
13:25:19 <byorgey> LordBrain: right.
13:26:15 <iabal> uhm
13:26:17 <byorgey> oh, wait a second, you're trying to reverse the list that you take
13:26:43 <iabal> uhm yes, is the way to do it tail-recursive
13:26:47 <LordBrain> oh yeah he is
13:26:51 <LordBrain> i didn't see that either
13:27:26 <LordBrain> there's no way to preserve laziness in that case
13:27:44 <byorgey> right
13:28:01 <byorgey> but it should be possible to do it without causing a stack overflow I think
13:28:13 <byorgey> iabal: does  reverse (take n xs)  cause a stack overflow?
13:28:15 <iabal> yes, lazyness no, but in general a compiler transforms tail-recursive in loops
13:28:21 <iabal> no, take no
13:28:28 <iabal> take runs ok
13:28:33 <byorgey> iabal: ghc transforms tail-recursive functions into loops too.
13:28:57 <iabal> byorgey, but I don't know how, dotake is a very clear tail-recursive function
13:28:59 <byorgey> iabal: the thing is that you might still have loops which lazily build up huge unevaluated expressions which blow the stack when they are finally demanded to be computed.
13:29:42 <iabal> uhmm
13:29:48 <byorgey> iabal: if you get a stack overflow from a C program, it means there was too much recursion, right?
13:29:59 <iabal> yep
13:30:03 <byorgey> well, that is not the cause of stack overflows with ghc
13:30:07 <LordBrain> why doesn't ghc optimize that away tho..
13:30:22 <byorgey> LordBrain: it can in some cases.
13:30:28 <iabal> well, I know that have lot of things unevaluated could cause memory problems
13:30:34 <byorgey> iabal: right.
13:30:37 <iabal> but I thought that this only affects to the heap
13:30:40 <iabal> and not the stack
13:30:59 <byorgey> iabal: well, suppose you have an expression like (1+(1+(1+(1+(1+(1+ ....
13:31:05 <byorgey> and it is not yet evaluated
13:31:20 <byorgey> at this point it is just taking up a lot of memory on the heap like you said
13:31:50 <byorgey> however, as soon as it is evaluated, it will start pushing lots of stack frames (one for each call to +)
13:32:00 <LordBrain> hmm
13:32:14 <byorgey> iabal: does that make sense?
13:32:16 <LordBrain> in this case it is : instead of + ?
13:32:24 <byorgey> yes, it could be
13:32:35 <byorgey> I am actually not entirely clear on why iabal's code causes a stack overflow
13:32:38 <iabal> byorgey, I understand it now, could have sense
13:32:47 <byorgey> just trying to explain what the issues are in general =)
13:32:55 <iabal> altought like you I don't see whe reason of the stack overflow yet
13:33:30 <iabal> whe->the
13:34:25 <mmorrow> > foldr (+) 0 [0..10000000]
13:34:27 <lambdac>  Exception: stack overflow
13:34:30 <mmorrow> > foldl (+) 0 [0..10000000]
13:34:36 <lambdac>  50000005000000
13:35:12 <stulli> Did somebody install wxhaskell on 64bit ubuntu 8.04? It doesnt seem to work for me.
13:35:41 <stulli> I get a memory leak while compiling
13:37:05 <byorgey> @wiki Stack_overflow
13:37:05 <lambdac> http://www.haskell.org/haskellwiki/Stack_overflow
13:37:11 <byorgey> iabal: that page may be helpful
13:37:15 <iabal> byorgey, in fact, takeR was a proof because the code that I want to do was it http://rafb.net/p/X7MiyE35.html
13:37:17 <lambdac> Title: Nopaste - No description
13:37:17 <dons> stulli: i've not been able to build wxhaskell recently
13:37:23 <dons> which release di dd you use?
13:37:31 <iabal> I thought that perhaps the take function have the problem
13:37:34 <iabal> byorgey, thanks
13:37:55 <_zenon_> stulli: Wxhaskell bugs on most systems :)
13:38:06 <stulli> dons, i tried cabal install and also the darcs repository
13:38:57 <stulli> _zenon_, good to know im not the only one ;)
13:39:25 <_zenon_> stulli: I tried using WxHaskell once, but I left it for HGL instead, I only needed to do some plots
13:40:19 <_zenon_> stulli: http://haskell.cs.yale.edu/graphics/
13:40:27 <LordBrain> i got it
13:40:48 <LordBrain> hmmm
13:41:00 <monochrom> blais: have you seen http://www.vex.net/~trebla/haskell/hxt-arrow/ ?
13:41:35 <LordBrain> It no longer overflows if i use dotake n (x:xs) = x: dotake (n-1) xs
13:41:38 <LordBrain> but
13:41:43 <_zenon_> stulli: I also have some example code on using HGL, not very nice code, but working :)
13:41:47 <LordBrain> is it still tail recursive?
13:41:47 <stulli> _zenon_, thanks far the link, ill try it
13:41:57 <LordBrain> is it optimized into a loop?
13:42:15 <stulli> _zenon_, so HGL is not very good documentated?
13:42:39 <byorgey> LordBrain: it should be.
13:42:52 <_zenon_> stulli: reasonably well documented, what seems to be lacking is good example code
13:43:04 <byorgey> LordBrain: that is the standard definition of take.  but it doesn't reverse the result list.
13:43:04 <LordBrain> it must be... after all if it wasnt there would be a stack overflow right?
13:43:10 <byorgey> LordBrain: right. =)
13:43:11 <dons> dcoutts_, Igloo: any ideas why I can compile libdownload, but can't run it in ghci, due to:
13:43:14 <dons> dons@xen-host02:/tmp$ ghci A.hs
13:43:16 <_zenon_> stulli: http://alongi.se/Progs/Haskell/Automata.tar
13:43:17 <dons> Prelude Main> main
13:43:19 <dons> <interactive>: /home/dons/.cabal/lib/download-0.2/ghc-6.8.2/HSdownload-0.2.o: unknown symbol `stat64'
13:43:21 <LordBrain> oh
13:43:22 <dons> ghc-6.8.2: unable to load package `download-0.2'
13:43:27 <LordBrain> yeah the reverse
13:43:34 <_zenon_> stulli: http://alongi.se/Progs/Haskell/Gene.tar
13:44:29 <_zenon_> stulli: Hope it helps you get going
13:44:33 <stulli> _zenon_, many thanks, that will help a lot
13:44:41 <LordBrain> @src reverse
13:44:42 <lambdac> reverse = foldl (flip (:)) []
13:44:45 <LordBrain> hmm
13:45:11 <LordBrain> @src foldl
13:45:11 <lambdac> foldl f z []     = z
13:45:12 <lambdac> foldl f z (x:xs) = foldl f (f z x) xs
13:48:18 <iabal> byorgey, uhms
13:48:25 <zenon_> This is weird
13:48:26 <iabal> Prelude System.Random> foldl (+) 0 [1..iters]
13:48:26 <iabal> 446198416
13:48:33 <iabal> Prelude System.Random> foldl (\() x -> x `seq` ()) () xs
13:48:33 <iabal> *** Exception: stack overflow
13:48:34 <zenon_> I am logged in as both _zenon_ and zenon_
13:48:54 <mmorrow> @src foldl'
13:48:54 <lambdac> foldl' f a []     = a
13:48:55 <lambdac> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
13:49:10 <byorgey> iabal: hehe
13:49:21 <byorgey> iabal: try using foldl' instead of foldl
13:50:05 <iabal> ok, I see sorry
13:50:26 <byorgey> iabal: you pretty much never want to use foldl, because it isn't strict in the accumulating parameter
13:50:40 <byorgey> so it will just build up a big expression and then try to evaluate it all at the end
13:50:54 <byorgey> foldl', on the other hand, evaluates the accumulating parameter as it goes
13:52:00 <iabal> iep, ok, lot of thanks, I'm seeing the problem
13:52:07 <iabal> lazy is harder :P
13:52:17 <mmorrow> iabal: you can do "foldl (\() x -> x `seq` ()) () xs" but it would be something like
13:52:24 <Cale> However, if you compile things with -O or -O2, it'll catch a lot of that for you.
13:52:37 <zenon_> stulli: you can email me if you have some questions regarding the code, I am sure the email is somewhere in the source
13:52:39 <mmorrow> > let seqList [] = [] ; seqList (x:xs) = x `seq` seqList xs in seqList [0..9]
13:52:40 <lambdac>  []
13:52:53 <mmorrow> oops
13:52:59 <mmorrow> > let seqList [] = [] ; seqList (x:xs) = x `seq` x : seqList xs in seqList [0..9]
13:53:00 <lambdac>  [0,1,2,3,4,5,6,7,8,9]
13:53:39 <stulli> _zenon_, yeah it is, thanks for the offer!
13:53:46 <LordBrain> oops gtg
13:54:32 <mmorrow> yeah, what cale said, I always compile with -O2
13:54:38 <mmorrow> even ghc!
13:55:01 <iabal> Cale, ;/ no, I'm compiling with -O2
13:55:05 <iabal> except the last example
13:55:50 <Cale> Well, it's not so bad as long as you understand the way that lazy evaluation proceeds.
13:56:23 <zenon_> stulli: I forgot, I also have a simple 3d "engine" if you want it, it draws rotating cubes on the screen
13:56:55 <Cale> iabal: Are you familiar with the various evaluation strategies?
13:57:05 <iabal> yes
13:57:09 <iabal> rwhnf
13:57:11 <iabal> and rnf
13:57:13 <iabal> no?
13:57:36 <Cale> Oh, those are functions for inducing evaluation in Control.Strategies...
13:57:47 <Cale> Er, Control.Parallel.Strategies rather :)
13:58:19 <iabal> yes, I use sometimes this module
13:58:21 <iabal> I'm ceibe :P
13:58:23 <Cale> But I just mean the fact that lazy evaluation is innermost first + sharing
13:58:32 <Cale> er, outermost first
13:58:38 <mmorrow> hehe
13:58:39 <Cale> (I just woke up :)
13:58:42 <stulli> _zenon_, its ok, i need to play around first before i do even more advanced stuff. Im really new to Haskell.
13:58:44 <byorgey> heh, Cale's brain is going...
13:59:12 <zenon_> stulli: Okay, take your time
13:59:13 <Cale> Strict evaluation, which is what you'd be used to from most other languages, is innermost first
13:59:16 <iabal> I don't understand the last that you said very well, perhaps is cause by me English ;P
13:59:29 <Cale> So if you have a function like  double x = x + x
13:59:41 <EvilTerran> ah, the mighty "double" example
13:59:45 <Cale> and you evaluate the expression  double (double 5)
13:59:55 <Cale> Under strict evaluation, that goes:
13:59:58 <Cale> double (double 5)
14:00:04 <Cale> -> double (5 + 5)
14:00:09 <Cale> -> double 10
14:00:13 <Cale> -> 10 + 10
14:00:15 <Cale> -> 20
14:00:16 <iabal> yep
14:00:29 <iabal> and in lazy (double 5) + (double 5) ..
14:00:42 <Cale> with sharing, though
14:00:52 <EvilTerran> or (let x = double 5 in x + x)
14:03:54 <zenon_> finally he quit :P
14:04:02 <zenon_> hehe I am going to bed
14:04:18 <iabal> iep
14:04:23 <iabal> only eval (double 5) once
14:04:24 <iabal> ok
14:04:42 <iabal> I understand what do you mean with outermost first + sharing
14:04:47 <iabal> I didn't understand the sharing
14:04:47 <iabal> :P
14:05:10 <mmorrow> sharing is caring! (as they say)
14:05:37 <mar77a> > exp 1 :: CReal
14:05:38 <lambdac>  2.7182818284590452353602874713526624977572
14:06:07 <roconnor> in the expression (double 5) + (double 5), the (double 5)'s are really the same (because pointers are used in the implemenation), so when one gets evaluated, they all get evaluted.
14:06:51 <ddarius> roconnor: Are you taking up Cale's torch?
14:07:06 <roconnor> ddarius: Writing my paper is tedious
14:07:21 <roconnor> oh, tea is ready
14:07:31 <roconnor> c\_/
14:08:35 <djsiegel> Hey, I've installed a bunch of cabal packages locally (~/lib), and I'm having trouble configuring my search path.
14:09:20 <djsiegel> $ runhaskell -v -i$HOME/lib Main.hs fails to find Network/NewCGI.hs
14:09:22 <dons> djsiegel: hmm. did you just install them with cabal ?
14:09:37 <dons> djsiegel: they should be listed under ghc-pkg list --user
14:09:57 <djsiegel> yes, they're all there
14:10:03 <djsiegel> oh my, I'm talking to the man
14:10:05 <dons> no search path should be needed then.
14:10:08 <djsiegel> hmmm
14:10:15 <djsiegel> then I must just be missing the file
14:10:21 <dons> if the libraries are listed in ghc-pkg list --user
14:10:29 <dons> then runhaskell Foo.hs should be enough
14:10:54 <dons> maybe you could put your error on hpaste.org?
14:10:59 <djsiegel> sure
14:11:02 <djsiegel> one second
14:12:07 <djsiegel> dons: http://pastebin.com/m779d26b0
14:12:22 <tonfa> is it just me or book.realworldhaskell.org doesn't resolve ?
14:12:31 <djsiegel> Are you familiar with that NewCGI,hs file?
14:12:42 <djsiegel> tonfa, hpaste.org was down for me -- may be related
14:12:48 <solrize> its down for me too, dns failure
14:14:54 <djsiegel> dons, I'm thinking my import Network.NewCGI may just be a typo
14:15:23 <djsiegel> I think it's just Network.CGI -- I am following a CGI tutorial online, and I think the OP modified the cgi package
14:15:29 <djsiegel> creating a new module, NewCGI
14:15:38 <dibblego> @msg lambdac > 1
14:17:24 <Mitar> I would like to render an image in Haskell ... I can compute pixel colors independently from each other ... I wonder what would be the easiest way to do this in parallel ... the problem is also that I have to do this before writing it to output as writing is serial and if I leave to Haskell then it computes as it has to output it -> in serial
14:17:27 <djsiegel> How do I remove a package?
14:17:42 <djsiegel> something like $ runghc Setup.lhs uninstall
14:17:45 <shapr> yorr
14:18:32 <sjanssen> djsiegel: ghc-pkg unregister, but this only unregisters the package, the actual object files remain
14:19:10 <matthew-_> where does fromInteger magically get called?
14:19:39 <sjanssen> matthew-_: in the desugaring for num literals
14:20:10 <sjanssen> (0 :: Int) is translated to (fromInteger 0 :: Int)
14:20:27 <matthew-_> but 0 :: (Num t) => t
14:21:07 <sjanssen> okay, (fromInteger compilerSpecificValueOfTypeIntegerWhichIsZero :: Int)
14:21:18 <dons> Mitar: which graphics library are you using?
14:21:23 <dons> gtk2hs? gd?
14:21:30 <matthew-_> sjanssen: ok, I'm still confused
14:21:30 <Mitar> GLUT
14:21:36 <dons> djsiegel: yes, definitely Network.CGI
14:21:39 <dons> check on hackage.haskell.org
14:21:49 <dons> for the documentation for the 'cgi' package
14:22:00 <Mitar> but I could also change ... I only want a portable way of displaying a window for 2D image
14:22:12 <matthew-_> gah, is hpaste down?
14:22:15 <dons> well, there's a lot of gui libs now
14:22:17 <Mitar> and to catch mouse clicks in it
14:23:04 <Baughn> Mitar: OpenGL support is conveniently (almost) a core library. If that's wall you want, you could use that
14:23:21 <Mitar> i only draw pixels in a plane :-)
14:23:30 <sjanssen> matthew-_: which part are you confused about?
14:23:34 <Baughn> Opengl is capable of that. ;)
14:23:48 <Mitar> probably it is really too much ... but it is simple and I can use mouse :-)
14:24:29 <ahunter> Dumb Q: is darcs.haskell.org down again?
14:24:43 <dons> nope.
14:24:47 <Mitar> but the problem is that I do: defineList rendering Compile (draw . resize width height . followRays . castRays origin . moveViewport origin $ viewportDots)
14:24:52 <Baughn> ahunter: Yep
14:25:04 <mmorrow> ahunter: it's reachable from me
14:25:17 <Mitar> and this rendering part is serial ...
14:25:37 <ahunter> conflicting reports, I see...I'm getting unknown host darcs.haskell.org
14:25:46 <Baughn> Mitar: Control.Parallel.par should be enough - just use reasomably large chunks. Or don't, if you like.
14:26:02 <dons> ahunter: its IP address changed over the weekend, if that's relevant
14:26:03 <Baughn> Mitar: And of course conflict with -threaded, use +RTS -Nx, etc.
14:26:15 <Baughn> dons: Well, it's not responding to pings
14:26:17 <Mitar> conflict?
14:26:30 <dons> i just ssh'd in.
14:26:32 <Mitar> i have not yet done parrallel things ...
14:26:34 <dons> and via the web.
14:26:45 <sjanssen> http://darcs.haskell.org works for me
14:26:47 <lambdac> Title: Index of /
14:26:47 <dons> maybe your dns is not up to date yet
14:26:55 <sjanssen> and it works wherever lambdac is
14:27:05 <Mitar> so I am not sure about this "of course" :-)
14:28:10 <Mitar> but with what i have been playing it does not matter because calculating pixel colors is lazy and it is called only when it is needed - and this is when I wan to draw it - and I draw it in serial
14:28:26 <Baughn> Mitar: Yes, so use par
14:28:28 <Mitar> or am I understanding something wrong?
14:28:36 <Mitar> ok
14:28:45 <Baughn> Mitar: x `par` y -- when y is forced, the RTS starts evaluating x in parallel
14:29:03 <Baughn> whnf only, but that shouldbe enough
14:29:17 <Mitar> whnf?
14:29:23 <Baughn> Weak head normal form
14:29:28 <Apocalisp> @go weak head normal form
14:29:31 <lambdac> http://encyclopedia2.thefreedictionary.com/Weak+Head+Normal+Form
14:29:37 <Baughn> Well, basically it means the smallest amount of evaluation possible
14:29:41 <Mitar> and I have to rung with +RTS -N2 for example if I have two cores?
14:29:42 <Cale_> Well, when (x `par` y) is forced, put x in a queue of things to be evaluated in parallel and result in y immediately.
14:29:47 <Baughn> Mitar: Yes
14:29:51 <matthew-_> sjanssen: http://pastebin.com/d49cb2a28
14:29:54 <matthew-_> sjanssen: fromInteger is clearly being called. But I can't follow the typing derivation through to work out where
14:29:58 <Baughn> Mitar: And compile with -threaded
14:30:04 <Mitar> ok
14:30:13 <mmorrow> +RTS -N2 -RTS
14:30:31 <Mitar> yes, if I have also other command switches
14:30:31 <sjanssen> matthew-_: first step is to translate all literals into fromIntegers
14:30:39 <Mitar> thanks ...
14:31:14 <Baughn> matthew-_: The compiler translates 2 to fromInteger 2
14:31:22 <sjanssen> matthew-_: let f x y = (fromInteger 2) (x+y) in f (fromInteger 3) (fromInteger 6) -- at thist point all literals left are of type Integer
14:31:35 <matthew-_> sjanssen, Baughn: thanks, got it now
14:33:01 <Mitar> so if I have a list of pixel coordinates and now I do map over them to list of colors I could just use parMap?
14:33:20 <matthew-_> is there some simple reason for this peppering of fromInteger throughout?
14:33:20 <Baughn> Sure. Probably.
14:33:26 <Baughn> If that's a raytracer, certainly
14:33:34 <Mitar> yes, it is :-)
14:33:41 <Mitar> an exercise :-)
14:33:43 <Baughn> matthew-_: So things like (2:: Float) work
14:33:47 <matthew-_> ignore that question
14:33:49 <Mitar> but I would like that it is a littlle bit faster ...
14:33:54 <matthew-_> Baughn: yep, indeed
14:35:15 <Mitar> but does it fire a new thread for every element of a list or does it have simply two threads (when run with -N2) and delegates the work over them? so I am thinking about overhead .... if there would not be more of that then anything else ...
14:35:25 <Mitar> (maybe I could just go and try it ... :-) )
14:35:36 <Baughn> Mitar: It sparks a new spark for each element of the list
14:36:01 <Baughn> Mitar: Those are lightweight threads, though; conisderably less work than making an OS thread, of which there is a fixed number.
14:36:28 <Baughn> Mitar: If it's a raytracer and it does a considerable amount of work per pixel, it should be fine. OTherwise, you might want to try calling par fewer times.
14:38:07 <Mitar> the problem is that it depends ... on a scene complexity ...
14:38:07 <quicksilver> Baughn: par is supposed to be sufficiently lightweight that 10s of thousands of sparks are not a problem.
14:38:14 <quicksilver> even 100s of thousands, I think.
14:38:40 <quicksilver> sparks are not lightweight threads, btw.
14:38:43 <Mitar> maybe I could divide an image into two lists
14:38:45 <Mitar> and do
14:38:49 <quicksilver> a spark is something less than a forkIO
14:39:25 <Mitar> (map color pixels1) `par` (map color pixels2)
14:39:45 <Mitar> now I just have to get the result somehow at the end
14:40:20 <quicksilver> let a = map color pixels1; b = map color pixels2 in a `par` b `par` (expression which uses a and b)
14:40:43 <Baughn> Mitar: weak-head normal form, I'm afraid. The spark triggered by par there does as little work as at all possible, so..
14:41:19 <Baughn> Mitar: That amounts to evaluating only the /first/ pixel - and not even figuring out that it has a color, just that there is a first pixel
14:41:20 <Mitar> so there it will not do anything unless i will try to use the result
14:41:27 <Baughn> Mitar: Look at Control.Parallel.Strategies for more
14:41:38 <Baughn> Well, you probably want par.rnf or some such
14:41:40 <Mitar> http://www.haskell.org/ghc/docs/latest/html/users_guide/lang-parallel.html << I am reading thos
14:41:42 <lambdac> Title: 8.17. Concurrent and Parallel Haskell, http://tinyurl.com/25eyfl
14:43:56 <Baughn> Mitar: file:///Users/svein/doc/haskell/ghc/libraries/parallel/Control-Parallel-Strategies.html <-- You'll want this
14:44:04 <Baughn> Mitar: http://www.haskell.org/ghc/docs/latest/html/libraries/parallel/Control-Parallel-Strategies.html <-- This, rather
14:44:06 <lambdac> http://tinyurl.com/2acvow
14:44:26 <Mitar> yes, i am also chacking this but i am not sure how to use it ...
14:44:53 <Mitar> how to get the "Strategy a" value?
14:45:20 <quicksilver> you buid them up using the combinators
14:45:22 <quicksilver> e.q. rnf
14:47:34 <Mitar> ehm, example?
14:47:46 <Mitar> i am reading but i am a little bit lost ...
14:57:02 <Mitar> if I have a list of functions which return Maybe ... how can I get the first Just value of calling those functions on same parameter?
14:57:15 <Mitar> i know i could do it with fold ... but there is some monadic way?
14:57:28 <Mitar> hmm, monadPlus ...
14:57:47 <Mitar> i remember reading about that when I have been learning haskell :-)
14:59:00 <Mitar> msum?
14:59:27 <cjb> yeah, I remember reading about how to do this too, sorry I can't remember.
14:59:36 <cjb> (I think it was in YAHT.)
15:00:29 <tromp> :t sequence
15:00:31 <lambdac> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
15:01:28 <tromp> > sequence [Nothing, Just 0, Just 3, Nothing]
15:01:30 <lambdac>  Nothing
15:01:36 <olsner> :t fail
15:01:39 <lambdac> forall (m :: * -> *) a. (Monad m) => String -> m a
15:01:47 <olsner> :t fix fail
15:01:49 <lambdac> String
15:01:54 <tromp> > msum [Nothing, Just 0, Just 3, Nothing]
15:01:55 <lambdac>  Just 0
15:01:59 <olsner> > fix fail
15:02:01 <lambdac>  ""
15:02:10 <olsner> hmm, fail
15:02:15 <tromp> > msum [Nothing, Nothing]
15:02:17 <lambdac>  Nothing
15:02:22 <tromp> > msum []
15:02:23 <lambdac>   add an instance declaration for (Show (m a))
15:02:38 <dafra> is lambdac a new lambdabot ?
15:02:56 <tromp> > msum [] :: Maybe a
15:02:58 <lambdac>  Nothing
15:03:15 <Mitar> msum (map ($ dot) elements)
15:03:19 <olsner> usually, something is wrong with lambdabot's server when there's another lambdabot here
15:03:27 <Mitar> when elements is a list of functions which get dot
15:04:02 <olsner> :t ap :: [a -> b] -> a -> [b]
15:04:05 <lambdac>     Occurs check: cannot construct the infinite type: a = [a]
15:04:21 <olsner> nooo, I am wrong ... but there's some monad magic like that
15:04:36 <ez> :t ap
15:04:38 <lambdac> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
15:04:55 <olsner> :t ap :: [a -> b] -> [a] -> [b]
15:04:58 <lambdac> forall a b. [a -> b] -> [a] -> [b]
15:05:20 <olsner> :t flip ap (replicate dot)
15:05:22 <lambdac> Not in scope: `dot'
15:05:28 <olsner> :t flip ap (replicate ?dot)
15:05:30 <lambdac> forall b a. (?dot::Int) => (a -> [a] -> b) -> a -> b
15:05:32 <Mitar> so any nicer way to write msum (map ($ dot) elements)) ?
15:05:53 <shachaf> > msum (sequence elements dot)
15:05:54 <lambdac>   Not in scope: `dot'
15:05:59 <shachaf> @ty msum (sequence elements ?dot)
15:06:00 <lambdac>     Couldn't match expected type `[t -> m a]'
15:06:01 <lambdac>            against inferred type `[a1] -> Gen a1'
15:06:01 <lambdac>     In the first argument of `sequence', namely `elements'
15:06:07 <shachaf> @ty msum (sequence ?elements ?dot)
15:06:09 <lambdac> forall t (m :: * -> *) a. (MonadPlus m, Monad ((->) t), ?dot::t, ?elements::[t -> m a]) => m a
15:07:01 <Mitar> i am not sure if sequence is the same as map ($)
15:07:29 <Mitar> @ty sequence ?element ?dot
15:07:30 <lambdac> forall a t. (Monad ((->) t), ?dot::t, ?element::[t -> a]) => [a]
15:07:47 <Mitar> @ty map ($ ?dot) ?sequence
15:07:48 <lambdac> forall a b (f :: * -> *). (Functor f, ?sequence::f (a -> b), ?dot::a) => f b
15:08:01 <olsner> > sequence [add 3, subtract 7, (* 11)] 7
15:08:02 <lambdac>   Not in scope: `add'
15:08:12 <olsner> > sequence [(+ 3), subtract 7, (* 11)] 7
15:08:13 <lambdac>  [10,0,77]
15:08:43 <Mitar> > map ($ 7) [(+ 3), subtract 7, (* 11)]
15:08:45 <lambdac>  [10,0,77]
15:09:11 <shachaf> @ty sequence -- Just think of the type
15:09:12 <lambdac> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
15:09:31 <Mitar> but sequence take only one argument?
15:09:34 <shachaf> In the (r ->) monad, that's [r -> a] -> r -> [a]
15:09:47 <EvilTerran> Mitar, values in the (r ->) monad take an argument, too
15:10:59 <Mitar> > sequence_ [(+ 3), subtract 7, (* 11)] 7
15:11:00 <lambdac>  ()
15:12:05 <Mitar> if I change (map ($ dot) elements) to (sequence elements dot) i get a compiler error
15:12:26 <mauke> what is it?
15:12:40 <Mitar>     No instance for (Monad ((->) SpaceDot))
15:12:40 <Mitar>       arising from a use of `sequence' at World.hs:48:23-43
15:12:42 <mauke> import Control.Monad.Instances ()
15:13:06 <EvilTerran> you need that for the (r ->) monadinstance
15:13:07 <Mitar> ohh
15:13:07 <Mitar> true
15:13:25 <Mitar> why importing this module without anything works?
15:14:08 <EvilTerran> because instances are always imported
15:14:16 <EvilTerran> they must be global for the current semantics to make sense
15:15:00 <Mitar> hmm, true, because you never import them ...
15:16:26 <Mitar> ok, so this will evaluate a list (elements) only until some function will return Just ...
15:16:27 <Mitar> ?
15:19:35 <EvilTerran> what will?
15:21:52 <Mitar> msum
15:22:05 <osfameron> am I missing something, or does hackage not have documentation for each package?
15:23:01 <osfameron> the process so far seems to be to download each file in turn, read the README which points to a documentation page on a darcs repo that no longer exists... ;-)
15:23:28 <vixey> hmmmmm
15:23:34 <vixey> @quote
15:23:35 <lambdac> tessier says: After the last newbies head exploded trying to read everything on that monad link there was a lot of paperwork. We'd like to avoid doing that again.
15:23:56 <vixey> @qeal
15:23:56 <lambdac> just seeing how offtopic i could get everyone
15:27:12 <thoughtpolice> osfameron: well, not every package can be built (since it might be an ffi binding,) and not all of the packages have working haddock documentation, if any.
15:29:41 <dons> osfameron: hmm? are you using cabal install?
15:29:53 <dons> the idea is you say, e.g., cabal install xmonad
15:30:01 <dons> which goes and gathers, builds and installs all dependencies
15:30:13 <dons> chasing by hand is a little old school
15:30:25 <osfameron> dons: I'm really just browsing, so wanted to check the documentation
15:30:26 <osfameron> ah!
15:30:31 <osfameron> the docs are under "Exposed Modules"
15:30:35 <osfameron> that's a little obscure
15:30:39 <dons> most libraries have their docs listed,
15:30:42 <dons> oh
15:31:09 <osfameron> I'm looking at, say, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/FileManip
15:31:13 <lambdac> http://tinyurl.com/52ggl6
15:31:29 <dons> right. click on the links :)
15:31:47 <dons> the .tar.gz is the buildable source cabal-install will  use.
15:32:00 <MyCatVerbs> dons: hey, I chase by hand. ;P
15:32:18 <dons> that's scary. grab cabal and cabal-install from hackage first, before you do anything else.
15:32:24 <MyCatVerbs> dons: but then, so few modules have long dependency chains, it doesn't come up much.
15:32:26 <thoughtpolice> hah, cabal-install has been out for ~2 weeks and already hand-chasing is totally old-school. :)
15:32:26 <dons> it'll save you hours of pain
15:32:40 <MyCatVerbs> dons: "hours"? I have this down to minutes. :P
15:32:51 <dons> shrug.
15:32:59 <osfameron> dons: yeah, I just wanted to read the docs to check that it was a library I wanted to install.  I hadn't thought to look for documentation under the individual modules
15:33:22 <thoughtpolice> we need to get gtk2hs cabalised somehow for sure, then we can cabal-install even more.
15:33:37 <mmorrow> and get cairo by itself!
15:35:17 <BONUS_> hey guys anyone here up for a quick linear algebra question?
15:35:19 <BONUS_> (got disconnected
15:35:42 <mmorrow> maybe, shoot
15:35:51 <BONUS_> if we have a linear map A:R^3 -> R^4
15:35:51 <osfameron> :t (==?)
15:35:53 <lambdac> Not in scope: `==?'
15:35:53 <BONUS_> whats the maximum rank
15:35:57 <BONUS_> that this map can have
15:36:00 <BONUS_> is it 3 or 4
15:36:16 <mmorrow> um, gimme a sec
15:36:54 <vixey> column rank = row rank doesn't it ?
15:37:07 <vixey> so the max would be 3
15:37:08 <mmorrow> ok, so "the rank of an mxn matrix is at most min(m,n)"
15:37:09 <ziman> three; there's no way to have 4 linearly independent vectors in the matrix
15:37:14 <vixey> I may  have forgotten this stuff
15:37:20 <andyo> well... the rank is the dimension of the solution space
15:37:34 <BONUS_> hmmm yeah
15:37:59 <BONUS_> if we apply a matrix to a R^3 -> R^4 linear map the matrix will have 3 rows and 4 columns, right?
15:38:19 <BONUS_> so yeah i guess its 3 then :)
15:38:19 <andyo> mhm
15:38:22 <andyo> yup
15:38:27 <mmorrow> yes
15:38:33 <BONUS_> thanks guys
15:39:08 <mmorrow> well... at *most* 3
15:39:22 <BONUS_> yeah at most
15:39:33 <BONUS_> it might be smaller than that if the kernel is not 0
15:39:38 <mmorrow> exactly
15:39:42 <osfameron> can I haddock a module instead of a file?  e.g. "haddock Data.List" instead of having to point to the actual file ?
15:39:47 <vixey> hmm I read this
15:39:49 <vixey> "I want to be able to write gui code with just a data structure and telling it to represent itself."
15:40:07 <BONUS_> well thats what HTML is, isnt it?
15:40:18 <vixey> yes but in a way it's also haskell
15:41:25 <drguildo> how so?
15:41:53 <drguildo> you mean how it's declarative rather than imperative?
15:41:58 <vixey> well heavily imperative code you would not look at it this way
15:42:43 <drguildo> yeah
15:56:17 <saadahmad> Hey guys, is there an alternative to arrays of arrays for creating 2d arrays in haskell?
15:56:24 <mauke> yes
15:58:32 * saadahmad contiues waiting for the method :)
15:58:57 <mauke> use tuples as indices
15:59:10 <saadahmad> Ohh, I see
15:59:26 <saadahmad> Can't believe I didn't think of that, thanks :)
16:11:46 <BONUS_> also does anyone know btw
16:11:57 <BMeph> Yes.
16:12:14 <BONUS_> are eigenvalues and eigenvectors of a linear map just eigenvalues and eigenvectors of the matrix that describes the map
16:12:18 <BONUS_> :]
16:12:57 <lament> well
16:13:04 <lament> try to guess the answer, you have three attempts
16:13:33 <BONUS_> haha
16:13:34 <BONUS_> well
16:13:35 <BONUS_> my guess is
16:13:36 <BONUS_> yes
16:13:39 <BONUS_> :D
16:13:45 <lament> hehe
16:13:57 <lament> most people don't even distinguish between linear maps and matrices that describe them
16:14:30 <BONUS_> hehe
16:14:31 <BONUS_> cool
16:14:37 <BONUS_> thanks
16:21:21 <shapr> Anyone here going to neu.edu? I want to grab their course catalog for an optimization problem...
16:25:29 <shapr> looks like I get to do some screen scraping...
16:28:20 <kryptiskt> does cabal-install work on windows?
16:30:13 <BMeph> Yes! Haskell can do that! ;)
16:33:09 <dons> kryptiskt: yes.
16:35:27 <Peaker> just had an interesting idea that should be possible with Haskell but not with imperative languages..  Currently the OS swaps out/reloads pages to disks. In some cases, this sucks as recomputing those pages is cheaper.  Haskell's runtime could recompute things that are cheap - if the kernel communicated with the Haskell runtime about it
16:35:36 <kryptiskt> dons: alright! you never know when you run  such unpopular platforms :-)
16:36:12 <Peaker> consider a Web Browser implemented in Haskell.  You might want to save a split second by memoizing the rendered pages. But its cheaper to recompute the page render than swap it out/in (and only keep HTML in memory)
16:38:11 <dmwit> Excellent.  As if the memory management system wasn't complicated enough yet.
16:38:15 <ksandstr> doesn't sound like this would be smart to do on a per-page level in any sort of general case
16:38:19 <dmwit> right
16:38:25 <dmwit> Think about the implementation...
16:38:27 <Peaker> ksandstr, why not?
16:38:30 <ksandstr> for things like computed graphics, perhaps, like as in procedural texturing, but...
16:38:50 <Peaker> you could ofcourse use arbitrary granularity instead of per-page, but per-4K sounds reasonable to me
16:39:00 <ksandstr> Peaker: because you couldn't have such objects that straddled a page boundary for instance
16:39:23 <Peaker> ksandstr, then have large objects aligned to page boundaries, and only apply this to large objects
16:39:41 <dmwit> ?bot
16:39:47 <dmwit> bummer
16:39:54 <ksandstr> personally i think the operating system should rather query the process as to what memory can be reclaimed and won't be missed
16:40:18 <Peaker> ksandstr, that's one way to implement what I said, isn't it?
16:40:33 <Peaker> ksandstr, And indeed Haskell could do it, whereas other languages would require a lot of manual specifications
16:40:49 <Peaker> (Just throw that away, I can recompute it)
16:40:50 <ksandstr> Peaker: i've got a suspicion that simply compressing the to-be-swapped pages with LZF or something like that would be faster
16:41:17 <Peaker> ksandstr, then why aren't Linux distributions configuring a first swap device as a compressed RAM fs?
16:41:24 <ksandstr> also if only haskell could do it, then why would it make its way into a major operating system?
16:41:39 <Peaker> ksandstr, I mean only Haskell can do it without extra specifications
16:41:39 <ksandstr> Peaker: because usually swapping things _out_ isn't the performance problem
16:41:56 <Peaker> ksandstr, it could be an interesting experiement to add a kernel-userspace API to do this reclaiming, and have the Haskell runtime use it implicitly
16:42:10 <ksandstr> Peaker: and wouldn't time to produce those extra specs be better put towards doing manual webpage caching?
16:42:13 <Peaker> ksandstr, swapping them in is the other side of the same coin?
16:42:53 <Peaker> ksandstr, allowing a naive web browser to re-render a page instead of swapping it in
16:43:14 <ksandstr> Peaker: yes. but hmm I suspect that for Linux the answer is that kernel-space memory management tends to be hairy and variable-length results from a compression algorithm wouldn't be very fun to keep around cleanly
16:43:47 <ksandstr> Peaker: compression would be general to nearly all data and would not potentially require that other pages of the same process be swapped in
16:44:30 <kryptiskt> seems like modern browsers just gobble a gig of RAM and keep a supersized cache there
16:44:45 <Peaker> ksandstr, how fast is decompression? Would it be as fast as computing a graphic image from HTML, for example?
16:44:46 <Pseudonym> Firefox 3 doesn't.
16:44:51 <ksandstr> i like to think it's because they target windows, which is horrrrrible
16:45:05 <ksandstr> Peaker: decompression of LZF tends to be about copyspeed. compression is slightly slower.
16:45:32 <ksandstr> Peaker: so as far as rendering HTML goes, yes, definitely faster
16:45:33 <Peaker> ksandstr, that's interesting. Is LZF like LZW? Does it include Huffman?
16:45:51 <Pseudonym> LZW has a degenerate Huffman code.
16:46:01 <ksandstr> Peaker: most likely. http://www.goof.com/pcg/marc/liblzf.html
16:46:25 <Peaker> how well does it compress things?
16:46:43 <ksandstr> considering the rate, quite well
16:47:13 <ksandstr> i.e. perhaps a bit worse than compress? wouldn't matter anyhow, being as most data in an application's memory is zeroes
16:48:08 <Peaker> sounds great - weird that it isn't in use?
16:48:31 <Peaker> I think a lot of the slowness I encounter is due to (unnecessary?) swap-ins
16:48:53 <ksandstr> it's in use in the tuxonice project, previously known as suspend2
16:49:37 <ksandstr> Peaker: they usually get 30-50% savings on the amount of data written to a hard disk if it's compressed
16:50:08 <Peaker> compressing on the way to the disk is less interesting than just compressing in memory, imo
16:50:19 <Peaker> the disk slowness is mainly head movement and not the size of the I/O anyhow
16:50:54 <ksandstr> true, but given that you'll be copying things into a DMA buffer before turning it over to the hard disk controller hardware, I'd have thought it a no-brainer
16:51:27 <Peaker> if decompression is so damn cheap, maybe it makes sense to store _everything_ on disk compressed (and compress more aggressively to avoid real swapouts), as a way to lower seek times?
16:51:48 <ksandstr> not really. files are usually contiguous with modern file systems, fragmentation at write time permitting
16:51:49 <Peaker> if you need less space on disk, you need to move the head less
16:52:09 <Peaker> but jumping to the file is the problem I'm trying to help
16:52:09 <Pseudonym> Seek times usually dominate I/O times.
16:52:11 <ksandstr> but the byte-level, blocklevel, pagelevel difficulties compression-by-default would incur are much too large
16:52:24 <Peaker> ksandstr, how come?
16:52:47 <Peaker> If you only need to store 10GB instead of 50GB, then seeking to a specific file is going to take around 1/5th of the time on average?
16:53:01 <ksandstr> Peaker: think about it. one block of LZF'd data ends up being shorter than a block. how will you address such blocks? make a compressed-length directory somewhere? how will you store such blocks contiguously when the file changes?
16:53:01 <Peaker> (less space the head needs to move in)
16:53:24 <Pseudonym> BTW, ubiquitous compression also has the problem that compression sometimes expands.
16:53:26 <ksandstr> Peaker: besides, hard disk space is cheap now and most of the really large files one would store are already compressed
16:53:31 <Pseudonym> Encrypted files, for example.
16:53:40 <Peaker> ksandstr, well, I'm allowed to mangle the order of the blocks, and insert some "gaps" when I need them, that gives me a lot of leniency
16:53:59 <Peaker> Pseudonym, that's solvable with a single bit expansion :)
16:54:06 <Pseudonym> Yes. :-)
16:54:10 <Pseudonym> Which isn't so dumb.
16:54:19 <ksandstr> Peaker: at the cost of actual savings. perhaps at the cost of knowing the blocks are contiguous, which is basically required to get decent I/O performance
16:54:35 <Pseudonym> The problem is that you really don't want to do this at the disk level.
16:55:00 <Peaker> ksandstr, the blocks can remain "close enough" to contiguous, if you just read an entire area around a block and it contains a mis-ordering of everything you need
16:55:04 <Pseudonym> Because reads and writes from disk aren't slow compared with a) seeks, or b) I/O bus bandwidth.
16:55:20 <Peaker> Pseudonym, I'm trying to help seek times
16:55:31 <dons> byorgey: http://docs.codehaus.org/display/JPARSEC/Home
16:55:36 <Pseudonym> Adding a bit, of course, means that in general you need to compress first, see if it expanded, then write whatever.
16:55:38 <dons> hwn-note, perhaps
16:55:43 <ksandstr> Peaker: yeah, well, that should at least be an interesting problem to keep one busy over a rainy day :)
16:55:44 <Pseudonym> Which slows things down overall.
16:55:58 <Peaker> Another interesting idea I had -- which appearantly was already researched by the university of Chicago, was collecting seek/read statistics, and reorganizing the disk to optimize seek times
16:55:58 <Pseudonym> IMO, real-time compression would make more sense in network communication.
16:56:14 <Pseudonym> Especially if there are guarantees on worst-case expansion.
16:56:21 <Peaker> if you read a bunch of files together a lot, then it will place them together
16:56:31 <Peaker> (at disk-block level, so it can be fs-unaware)
16:56:41 <ksandstr> Peaker: yeah, offline optimization never seems to get out of academia
16:57:02 <Pseudonym> Or something like OS buffers.  Say, Unix pipes.
16:57:06 <Peaker> ksandstr, the actual software world outside of Academia is so lame :-(
16:57:11 <Pseudonym> I can imagine that storing in-memory stream data like that compressed...
16:57:23 <ksandstr> yeah, especially if it's at near copy speed
16:57:47 <Peaker> ksandstr, near-copy speed sounds dubious though
16:58:01 <Pseudonym> Peaker: That means something specific.
16:58:17 <Pseudonym> Essentially, you're trading off CPU usage for cache misses.
16:58:31 <Pseudonym> Copying a large block of memory is slow because of cache misses.
16:58:32 <Peaker> ksandstr, there are really fast copying instructions (e.g SIMD copies of 128-bit at a time), whereas decompression is going to need at least 2x or 3x the amount of work for each word
16:58:36 <Pseudonym> In general.
16:58:37 <Peaker> oh
16:58:50 <ksandstr> Peaker: but yet somewhat plausible given that a modern CPU can easily execute tens of instructions in the time a L2 cache miss takes to turn around
16:59:21 <Pseudonym> There's been some work in inverted file research which showed that compressed inverted files work faster than uncompressed indexes, even when the uncompressed index fits in RAM.
16:59:27 <Pseudonym> Because of the smaller working set.
16:59:33 <ksandstr> the key thing seems to be a speedy hashing function and a dictionary that mostly fits in a L1 data cache
16:59:36 <Peaker> "inverted files"?
16:59:45 <Pseudonym> Peaker: Think search engine.
16:59:57 <Peaker> Pseudonym, database indices?
17:00:08 <Pseudonym> Yes, but textual database.
17:00:11 <ksandstr> Peaker: and anyway the SSE copy loop hasn't really been relevant since the P3
17:00:11 <Pseudonym> Like a search engine.
17:00:24 <Peaker> can it be rephrased as: compressed inverted files work faster than uncompressed inverted files?
17:00:30 <Peaker> ksandstr, why not?
17:00:50 <ksandstr> Peaker: because of the way caches work, just copying 32-bit words one at a time will saturate the memory bus
17:01:11 <Peaker> I talked to someone who implemented a system to compress textures in video card memory - to allow more textures. "Surprisingly", it sped stuff up rather than slowing them down
17:01:12 <Pseudonym> Peaker: Yes, but the point is, that's not obviously true if the uncompressed inverted file would fit in RAM.
17:01:32 <Peaker> ksandstr, for small in-cache sections it's still probably faster?
17:01:35 <ksandstr> Peaker: vector quantization. makes texture sampling in software a bit quicker too
17:01:55 <ksandstr> Peaker: perhaps, if the first use of a SSE instruction doesn't cause a state reload trap into the kernel
17:02:02 <Peaker> Pseudonym, not obvious at all
17:02:10 <Peaker> Pseudonym, I'm still finding it hard to believe :)
17:02:29 <Peaker> Pseudonym, compressed index in RAM beats uncompressed index in RAM
17:02:38 <Peaker> these caches suck :)
17:02:48 <Pseudonym> Yes.
17:03:05 <ksandstr> well it makes sense, in that an uncompressed index will lead to more TLB misses due to its larger size
17:03:24 <Peaker> Shapiro (of EROS-OS) claimed that the move from C++ to C sped things up because C++ bloated code size and caused cache misses
17:03:43 <Peaker> (Later they gave up on C and decided to write a new language too)
17:04:02 <ksandstr> though I'd have thought that something like binary search from an array would already be optimized with prefetches so that the compress/uncompress thing wouldn't give that much of an improvement
17:04:11 <Pseudonym> Yeah, I'm not surprised.  EH and RTTI cost if you don't use them.
17:04:13 <Peaker> ksandstr, It "makes sense", but I can easily justify the converse too
17:04:38 <ksandstr> Peaker: yes. it's not that the caches suck, but these memory busses suck. too much latency basically
17:04:41 <Pseudonym> Mind you, it would be better if C++ compilers generated EH and RTTI information in different segments.
17:04:55 <ksandstr> Pseudonym: I thought they already did?
17:04:59 <Pseudonym> So at least in user space, if you didn't use them, you wouldn't page the info in.
17:05:05 <Pseudonym> Not all of them.
17:05:34 <Peaker> a cache miss fetches something like a whole 128 bytes block, right?
17:06:18 <Peaker> so it sounds like if you're cache-missing with a single word access each time, you're paying 128 / [8|4] overhead on the cache mechanism...
17:06:43 <ksandstr> a cacheline's worth usually, except in the case of the automatic prefetching mechanisms they have in athlon64 and core2
17:08:18 <mjrosenb> haskell does't seem to like using higher kind types
17:08:33 <vixey> yes it does
17:08:36 <mjrosenb> am i doing something wrong here
17:08:37 <vixey> :k RWST
17:09:03 <mjrosenb> type List a = [a]; type Foo k = k Int; type Bar = Foo List
17:09:05 <Peaker> ksandstr, how do they prefetch?
17:09:11 <mjrosenb> Type synonym `List' should have 1 argument, but has been given 0
17:09:36 <Peaker> I think #haskell is the first channel where I can rant about my crazy ideas and end up knowing more about them rather than having flame wars :)
17:09:46 <vixey> mjrosenb: I think you must use newtype not type for List
17:09:53 <vixey> as with Foo
17:09:56 <ksandstr> Peaker: according to one of several preprogrammed (at the factory) patterns. typical ones are "increasing virtual address" and "decreasing virtual address"
17:10:04 <mjrosenb> this seems silly, but ok
17:10:18 <Peaker> ksandstr, it can asynchronously fetch it while executing instructions?
17:10:25 <ksandstr> Peaker: absolutely.
17:10:38 <Peaker> ksandstr, sounds like that's a feature worth exposing when its "hung" waiting for a cache miss to load?
17:10:46 <ivanm> mjrosenb: I've done type aliases for lists before without that problem...
17:10:53 <Peaker> ksandstr, I mean - isn't the processor hung in that state, instead of letting another thread execute?
17:10:55 <ivanm> my guess is the type Bar line
17:10:57 <ksandstr> Peaker: which is what multiple cores and simultaneous multithreading are for.
17:10:58 <vixey> mjrosenb: yeah it does, I'm not sure if there's even a good reason for it
17:11:03 <ivanm> since you don't tell it what type of list it needs
17:11:09 <vixey> mjrosenb: it probably makes typechecking infinite loop or something I haven't thought about it much
17:11:37 <Peaker> ksandstr, why not have a processor-readable thread-table instead, and have it jump there upon cache misses?
17:11:38 <mjrosenb> ivanm: did you also attemt to use the List alias as an argument to something else?
17:11:45 <ivanm> no...
17:11:56 <ivanm> but having a type of types looks kinda dodgy (your Foo alias...)
17:11:57 <mjrosenb> ivanm: that's where i'm getting the error
17:12:02 <ivanm> *nod*
17:12:25 <ivanm> mjrosenb: does Foo work with say Maybe?
17:12:38 <ivanm> i.e. type IMaybe = Foo Maybe ?
17:12:42 <sbahra> Peaker, hi :)
17:12:48 <Peaker> hey sbahra
17:12:48 <ksandstr> Peaker: because a l2 cache miss is detected rather late in the memory access path (typically, i mean) and in any case would only eat up about 200 core cycles or some such. you'd have time to execute at best 600 cycles' worth of a thread in the same address space
17:12:52 <mjrosenb> maybe is a datatype, so there shouldn't be an issue
17:13:09 <mjrosenb> no problems
17:13:14 <sbahra> What is ksandstr working on?
17:13:14 <ivanm> hmmmm.....
17:13:16 <ksandstr> Peaker: thus unless it's true SMT like HyperThreading or what IBM's been doing for a while, or Sun's Niagara, it usually isn't worth going that far
17:13:30 <ivanm> mjrosenb: maybe because Maybe has constructors, which are after all functions?
17:13:31 <ksandstr> Peaker: tl;dr version -- the granularity is too low.
17:13:51 <mjrosenb> it seems to not like type synonyms
17:13:57 <Peaker> ksandstr, but a multi-core executes in parallel anyhow? Or is it only really parallel when some of the cores are in cache misses?
17:14:12 <mjrosenb> is there honestly no type constructor for lists?
17:14:26 <Peaker> mjrosenb, [] ?
17:14:35 <ksandstr> Peaker: it's parallel, but both cores share the I/O and memory busses. so they sort of split the bandwidth up when both need it, but one core can use it all if necessary.
17:14:48 <roconnor> > (:) 1 []
17:15:11 <mjrosenb> roconnor: that's not a type constructor
17:15:22 <ksandstr> Peaker: this is stuff that even c programmers don't actually need to know about. totally off topic here :D
17:15:27 <roconnor> mjrosenb: why not?
17:15:29 <Peaker> ksandstr, so even then - during a cache miss you're missing out on processing power (still using the memory pipe though)
17:15:41 <mjrosenb> Peaker: why on earth does that work
17:15:51 <roconnor> @src []
17:16:00 <Peaker> mjrosenb, I think [a] is just short-hand syntax for [] a
17:16:17 <mux> [] is both a type constructor and a data constructor
17:16:23 <mjrosenb> Peaker: so i've noticed
17:16:23 <roconnor> Peaker: shorthand for (:) a []
17:16:32 <ksandstr> Peaker: basically, yeah. then again, think of it as a situation where the processor cannot interleave ALU operations with memory access
17:16:33 <monochrom> If your cores are not contending for I/O or memory, they can work in parallel.
17:16:36 <roconnor> ah
17:16:37 <Peaker> roconnor, as a type - not a value
17:16:38 <roconnor> sorry!
17:16:44 <ksandstr> Peaker: because it used to be back in the eighties that memories were faster than CPUs
17:16:47 <roconnor> type/values
17:16:48 <roconnor> right
17:17:12 <mar77a> the first computers were big because they were actually cupboards with fast humans inside
17:17:22 <roconnor> @kind StateT []
17:17:29 <Peaker> ksandstr, I see. Thanks! I finally understand what multicores are really about :)
17:17:37 <SamB> mar77a: I don't think so
17:17:45 <Peaker> (as opposed to SMP/etc)
17:17:49 <ksandstr> Peaker: "SMP in a single socket", basically. and "bigger SMP with more sockets" too
17:18:02 <SamB> I'm fairly certain that the first computers were NOT required to work inside dark cupboards
17:18:04 <sbahra> Peaker, multicore is not CMT
17:18:11 <sbahra> Peaker, and it seems these 2 unique concepts are being confused here.
17:18:20 <SamB> CMT?
17:18:27 <sbahra> Chip multithreading
17:18:37 <SamB> what's that?
17:18:49 * mux waves at sbahra 
17:18:53 <Peaker> sbahra, well, multicore seems to be a way to utilize the CPU's power while it is stuck fetching cache windows upon misses?
17:18:56 <chessguy> SamB:  what's what?
17:18:58 <chessguy> sheesh, provide a little context
17:18:59 <sbahra> mux, :D
17:19:04 <sbahra> mux, bonjour
17:19:07 <sbahra> Peaker, no.
17:19:11 <Peaker> sbahra, (and ofcourse add some processing power, too)
17:19:12 <ksandstr> Peaker: that's SMT. multicore can also do that, inasmuch as the other thread is being run "in the same socket"
17:19:13 <sbahra> Peaker, this is chip multithreading, etc...
17:19:20 <SamB> chip multithreading
17:19:26 <ivanm> mar77a: I'd @remember that comment of yours, except that lambdabot is down :(
17:19:29 <sbahra> Peaker, multicore is simply "multiple cores on a single socket", nothing more, nothing less.
17:19:51 <sbahra> Peaker, the variance there is not so massive, the major difference in the market is how L2 cache is handled (dedicated versus shared).
17:19:54 <mar77a> ;(
17:20:09 <sbahra> ksandstr, SMT/CMT is a different concept altogether.
17:20:10 <Peaker> sbahra, I see. But I always knew that there was a lot they actually shared in a way that meant they were not really completely parallel/independent, and now I know more
17:20:22 * mux is thinking about buying a nehalem architecture for his next desktop as soon as it's out
17:20:33 <ksandstr> sbahra: ... running more than a single thread per core you mean? that's what i meant anyway
17:20:39 <sbahra> It depends, Peaker. In "multicore" you have different resources all together. On the sun4v's the FPs are shared.
17:20:58 <sbahra> Peaker, the difference is usually in how other resources are handled like memory, cache, etc...
17:21:17 <sbahra> mux, nehalem?
17:22:05 <mux> yes, next gen intel architecture, should be available Q4 this year
17:22:19 <sbahra> next generation?!
17:22:26 <mux> apparently the biggest architectural breakthrough since the ppro's
17:22:33 <ksandstr> more like intel's next iteration of core2
17:22:48 <mux> integrated memory controllers, new nice QuickPath bus
17:23:08 <mux> look it up on google/wikipedia :)
17:23:17 <sbahra> Interesting changes
17:23:38 <mux> if I were AMD I'd be really scared now
17:23:55 <ksandstr> this is assuming that intel's manufacturing process can deliver that design
17:24:14 <sbahra> mux, why?
17:24:24 <sbahra> mux, AMD makes enough money in high performance computing
17:24:29 <ksandstr> istr that intel was switching to a silicon-on-insulator process rather than the planned dielectrics thing
17:24:36 <mux> because they're closing gaps with where amd cpus are better still
17:24:45 <sbahra> All of Sun's offerings are Opteron-based when it comes to cluster/grid computing.
17:24:47 <ksandstr> wow. this is getting more and more off-topic for #haskell by the minute :D
17:24:58 <mux> indeed, but you're guilty too :-P
17:25:07 <kryptiskt> core2 is just a turbocharged pentium 3, nice conservative design usually wins big, the Itaniums and the P4's of the woorld flop.
17:25:23 <sbahra> Itanium rocks.
17:25:26 <sbahra> ma sox
17:25:39 <sbahra> Very novel, imho (atleast to my generation).
17:25:40 <monochrom> http://www.vex.net/~trebla/haskell/hxt-arrow/without-dtd.xhtml
17:25:41 <ksandstr> perhaps when we get to transistors and capacitors there'll be a huge POP and we'll be back in the usual 03:25 programming
17:25:44 * mux wants a clockless cpu anyways
17:26:00 <monochrom> Oh, I can do capacitors.
17:26:48 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/download-curl-0.0
17:26:58 <sbahra> mux, have you played around with IA64 before?
17:26:58 <dons> so there's two choices now, you can downlaod content via curl, or libdownload, and they have the same api
17:27:20 <mux> sbahra: not really, besides logging onto ia64 boxes
17:27:22 <dons> and you can get the result as strings, bytestrings, XML, [Tag] or RSS
17:27:27 <kryptiskt> hey, if they could build lisp machines, why not haskell machines?
17:27:28 <sbahra> mux, would you be?
17:27:36 <mux> probably not
17:27:40 <sbahra> ok ;p
17:27:50 <ksandstr> kryptiskt: because of UNIX
17:27:56 <sbahra> I should get it racked at some datacenter.
17:28:00 <sbahra> and use it.
17:28:59 <monochrom> dons: Funky!
17:29:24 <monochrom> "we put the funk in funktionalprogrammensch"? :)
17:29:30 <dmwit> [Tag]?
17:29:41 <monochrom> [Tag] is probably as in TagSoup.
17:29:41 <vixey> hehe
17:30:16 <dons> yep, tagsoup, xml-light or the atom/rss parser
17:30:22 <dons> or just bytestrings or strings.
17:30:35 <dons> http://hackage.haskell.org/packages/archive/download/0.3/doc/html/Network-Download.html
17:30:39 <dons> api details
17:30:52 <monochrom> nice nice
17:31:15 <mux> cute
17:31:51 <mux> no type-classed generic open function though?
17:32:12 <mux> or rather, generic openAs
17:32:16 <dons> not yet. we could be return-type funky i suppose
17:32:24 <dons> with types for XML, RSS, Atom, etc.
17:32:31 <mux> not sure if that's really useful anyways
17:32:33 <dons> but i figure this is a good start
17:32:42 <mux> that reminds me, is simonmar's new Process API in already?
17:32:43 <dons> already a hell of a lot better than using curl as it was
17:32:46 <mux> it looked *good*
17:33:12 <monochrom> haskell is converging to OS/2 or Windows GUI?  Everything is "open"?  "Open" is polymorphic?  :)
17:33:54 <mux> open :: a -> b -- :-)
17:34:10 <SamB> mux: you're getting confused with unsafeCoerce
17:34:12 * monochrom is scared!
17:34:19 <mux> part of the unreleased haskell bindings for Plan9 :D
17:34:42 <SamB> so does GHC now target 9C?
17:34:43 <monochrom> open :: (MonadIO m) => a -> m b   is probably better.
17:35:04 <SamB> (or otherwise work in plan9?)
17:35:22 <monochrom> open :: (MonadIO m, Openable a b) => a -> m b   is probably better.
17:35:25 <mux> people are actually using plan9?
17:35:40 <mux> monochrom: no fun, this is realizable :-P
17:35:47 <monochrom> Oh!
17:36:03 <dons> so i might write a little blog post about the new apis, and how to use them
17:36:39 <monochrom> It will be another spectacular event on reddit. :)
17:36:46 <mux> hahaha
17:37:17 <mux> with those reorganizations they made btw, I have to checkout 3 reddits now, programming, compsci and types
17:37:20 <mux> feh
17:37:33 <vixey> is there ever anything good on it ?
17:37:42 <mux> yeah there is
17:37:47 <vixey> huh..
17:37:49 <SamB> mux: what VCS do you use to do that?
17:38:17 <mux> I didn't mean checkout in that sense ;-)
17:39:29 <monochrom> Oh? There is compsci reddit? And there is types reddit too?
17:39:37 * mux nods
17:39:47 * monochrom goes subscribe subscribe subscribe. already has math reddit.
17:39:58 <ksandstr> just how mainstream is this stuff anyhow, when a digg-clone has a "types" category?
17:40:19 <vixey> ksandstr: Someone who comes on this IRC made the types reddit
17:41:15 <mux> the first article on the types reddit right now is "Parametric Higher-Order Abstract Syntax for Mechanized Semantics"
17:41:25 <mux> doesn't sound too much mainstream to me
17:41:49 <vixey> hey have your read the PHOAS hting?
17:41:51 <ksandstr> but looking out from a bubble like this channel, well...
17:42:00 <roconnor> I wonder if I should draw more figures for my paper.
17:42:12 <vixey> It's really cool I read conals HOAS first thoughh because it's pretty tough to get otherwise
17:44:52 <vixey> @bot
17:46:51 <dolio> _|_
17:47:02 <ksandstr> gah! don't do that.
17:48:12 <monochrom> â¤ â¥
17:50:43 <vixey> hum....
17:51:12 <monochrom> http://www.reddit.com/r/compsci/info/6ow1a/comments/   this is another "you'd have invented monads too" but a container version! :)
17:52:02 <vixey> I read some crazy thing about Containers
17:52:19 <vixey> proveing theorems about lists by some morphism into Fin (length list)
17:52:52 <vixey> it seems to make induction proofs simpler.. they reduce to just solving ring equations or something
17:53:44 <Peaker> given two Maybe's, how do I choose the "better" one (Just better than Nothing), with a bias towards one of them?
17:54:00 <vixey> mplus I guess
17:54:14 <vixey> I don't know if it's left or right biaseda
17:54:39 <vixey> @src Maybe mplus
17:54:45 <vixey> ...
17:54:48 <Peaker> :info Maybe doesn't show it as an instance of Monoid?
17:54:58 <ddarius> This is how non-academics try to look like academics: http://reductiotest.org/
17:55:21 <monochrom> You need to import the Monoid module to receive instances.
17:55:23 <SamB> what is a non-academic again? I forgot.
17:55:32 <ddarius> vixey: It's left-biased, though I don't believe it's documented.
17:55:32 <vixey> lol
17:55:39 <vixey> nice lettering
17:56:03 <Peaker> oh - why is Monoid responsible to make the instance, and not Maybe?
17:56:17 <Peaker> who decides who's on top of whom?
17:56:27 <ddarius> Peaker: mplus is a method of MonadPlus, not Monoid.
17:56:28 <monochrom> Historical accidents.
17:56:45 <kryptiskt> they got the 1997 vintage web design academics prefer correct, though
17:57:06 <monochrom> Let X be an instance of C.  If X is invented before C, the instance code is in C.  If C is invented before X, the instance code is in X.
17:57:16 <Peaker> oh
17:57:33 <dolio> Do academics use the word "utilises"?
17:57:40 <ddarius> kryptiskt: Thank God for 1997
17:58:01 * BMeph gathers a bowl of bran flakes, in case of attack by "hysterical raisins"
17:58:48 <ddarius> Little does BMeph know, the raisins have stolen his milk.
17:58:52 <roconnor> monochrom: that really makes our instance mechanism sound broken.
17:58:53 <ksandstr> how does one tell a hysterical raisin from an ordinary one?
17:59:23 <Peaker> It seems silly to have MonadPlus subclass Monad - and also silly that we have a bunch of identical classes with differing names/method-names just so we can have multiple instances of them of the same type
18:00:05 <dolio> What?
18:00:18 <vixey> there is no subclassing
18:00:23 <Peaker> doesn
18:00:27 <Peaker> 't MonadPlus subclass Monad?
18:00:32 <vixey> no
18:00:43 <dolio> It does, if you want to call it that.
18:00:47 <Peaker> :info MonadPlus => class (Monad m) => MonadPlus m where
18:01:02 <vixey> => doesn't mean subclass, ,to me at least
18:01:10 <Peaker> vixey, its how the tutorials/etc call it
18:01:18 <vixey> I did not retain that from tutorials
18:01:25 <dolio> What are the identical classes with different names?
18:01:45 <Peaker> dolio, well, the MonadPlus methods seem to be a special case of Monoid's methods
18:02:09 <Peaker> dolio, and I'm not sure why MonadPlus makes sense. when you define something to be MonadPlus you really want to say it can form a Monoid in another awy?
18:02:38 <dolio> That's true, I suppose. But you can't write the type that would let you eliminate the uses of MonadPlus in Haskell.
18:02:57 <Peaker> because it would conflict with Monoid instances?
18:03:11 <Peaker> (can't have two Monoid instances?)
18:03:20 <dolio> No, because you aren't allowed to introduce universally quantified variables in the middle of a context.
18:03:35 <ddarius> :t mappend
18:03:36 <Peaker> I don't know what that means
18:03:37 <ddarius> :t mplus
18:03:44 <dolio> To get rid of MonadPlus you need to be able to write: '(forall a. Monoid (m a)) => ...'
18:03:46 <Peaker> mplus :: (MonadPlus m) => m a -> m a -> m a
18:03:54 <ddarius> What is with the bot drought of late?
18:04:16 <Peaker> dolio, oh - so with the universal quantification extension, its no longer necessary?
18:04:56 <Peaker> (or not even then?)
18:05:28 <vixey> @cata data List a = Nil | Cons a (List a)
18:05:29 <catabot> cataList :: (z -> ((a -> (z -> z)) -> ((List a) -> z)))
18:05:29 <catabot> cataList a _ (Nil) = a
18:05:29 <catabot> cataList a g (Cons k yu) = g k (cataList a g yu)
18:05:35 <vixey> kk temporary bot
18:05:48 <ddarius> Peaker: Monoid and MonadPlus are different concepts.  It wouldn't make sense to conflate them.  Some people want to conceptually split MonadPlus into two classes due to differences in intended semantics.
18:06:10 <dabblego> three in fact
18:06:28 <Peaker> ddarius, If they differ in use-cases but are similar in structure, does that still warrant more classes?
18:06:33 <Peaker> s/similar/identical
18:06:49 <dolio> Peaker: I don't think there's an extension in GHC that allows it. It's specifically universal quantification inside a class context. I may be wrong, though.
18:07:45 <SamB> it's a shame that Haskell doesn't support including properties in classes
18:08:01 <vixey> properties? like strong specs?
18:08:08 <ddarius> Peaker: Yes.  They are intended to satisfy different laws, they give different guarantees.
18:08:13 <keseldude> Quick question: anyone know how to resolve this?
18:08:15 <hpaste>  keseldude pasted "'this'" at http://hpaste.org/8658
18:08:38 <dolio> Peaker: Yeah, even with -fglasgow-exts, that's not allowed.
18:08:40 <monochrom> Laws! I keep forgetting that.
18:09:18 <Peaker> ddarius, if the laws are the same, and the structure identical, but use-cases are different, then it should still share a class right?
18:09:18 <monochrom> Signatures aren't everything.
18:09:40 <vixey> I left the window open now I've got moths in my room
18:09:40 <ddarius> Peaker: If the laws are the same and the structure is identical, they are the same thing.
18:09:46 <dabblego> the proposed MonadOr and MonadPlus have different laws
18:09:47 <ddarius> Get mothballs.
18:09:53 <monochrom> If use-cases are different, it's unlikely laws stay the same.
18:10:02 <vixey> to feed moths?
18:10:02 <ksandstr> vixey: lucky you. I left my calendar open and now I've got months in my room
18:10:09 <vixey> hehe
18:10:18 <Peaker> I left my ghci open and I have monads in my room
18:10:26 <vixey> oh I don't mind them, they look nice
18:10:41 <mmorrow> anybody know of a good example travelling salesman implementation in haskell?
18:11:04 <monochrom> But suppose your question makes sense. You have two things with different use-cases but you swear they have the same laws. Then they should be the same abstraction.  For example there are a million different use-cases of queues, but you need just one queue.
18:12:04 <monochrom> There are also a million different use-cases of monads. Some people use them as containers, some people use them as controls. :)
18:12:30 <vixey> I thought containers were some new thing
18:12:48 <vixey> well the word probably has multiple meanings
18:13:15 <dolio> You're too wrapped up in badass type theory. :)
18:13:46 <SamB> vixey: collections, only some containers don't collect things (i.e. Maybe ;-)
18:14:31 <mauke> data No a = None
18:14:40 <mmorrow> ok, anyone know of a good example travelling saleman implem in *any* language?
18:14:54 <mmorrow> have to implement it in haskell for tomorrow
18:14:55 <mauke> instance Monad No where return _ = None; _ >>= _ = None
18:14:56 <vixey> mmorrow: I saw a neat neural network that solves it
18:15:05 <mmorrow> ooh, do you have a link?
18:15:09 <vixey> I'll try to find it
18:15:14 <mmorrow> thanks:)
18:15:21 <SamB> mmorrow: I thought the traveling salesman was an example of an intractible problem?
18:15:29 <vixey> NP complete
18:15:39 <mmorrow> <100 is easy enough
18:15:41 <Apocalisp> you can approximate it quite well
18:15:51 <mmorrow> and that's exactly as good as i need it to be
18:16:03 <LordBrain> mauke, what do you use No for?
18:16:06 <vixey> mmorrow: http://fbim.fh-regensburg.de/~saj39122/jfroehl/diplom/e-index.html
18:16:07 <catabot> Title: Neural Networks with Java, http://tinyurl.com/gzn6c
18:16:08 <ksandstr> mmorrow: perhaps your instructor is playing a joke on you?
18:16:09 <mmorrow> i need an *exact* solution for <100
18:16:11 <Apocalisp> simulated annealing is easy enough
18:16:12 <orzo> is there a way to maintain weak references to haskell objects on the heap?
18:16:14 <mauke> LordBrain: worst collection ever
18:16:19 <LordBrain> lol
18:16:25 <mmorrow> ksandstr: this isn't for a class :)
18:16:30 <keseldude> anyone?
18:16:32 <keseldude> (21:08:16) < hpaste>  keseldude pasted "'this'" at http://hpaste.org/8658
18:16:33 <vixey> mmorrow: I don't think that NNs will solve it exactly but it's still a cool thing
18:16:50 <Apocalisp> mmorrow: What's this for? Curious.
18:17:05 <mmorrow> vixey: yeah, i'm definitely not gonna write an nn implem just to solve it, but that link'll probably give me a start
18:17:36 <vixey> neural networks is something I've never sucessfully written
18:18:00 <mmorrow> it's so that an insurance company can schedule various people they have driving places so that cost of gas is minimized
18:18:15 <Apocalisp> mmorrow: I've solved that exact problem recently.
18:18:22 <mmorrow> sweet!
18:18:31 <Apocalisp> how much is it worth to you?
18:18:36 <mmorrow> Apocalisp: do you have any code somewhere?
18:18:38 <mmorrow> heh
18:18:42 <mmorrow> depends
18:18:52 <mmorrow> how much is it worth to you?
18:18:55 <monochrom> mmorrow: do you enjoy transforming TSP to SAT? If so you can use one of the haskell SAT libraries, e.g., funsat.
18:19:09 <Apocalisp> It's worth about two days of work to me.
18:19:16 <vixey> monochrom: mm I like the idea :)
18:20:09 <mmorrow> Apocalisp: hmm, I think'll I write my own then, but I appreciate the offer :)
18:20:09 <vixey> I wonder if it's possible to do that in a way that actually helps efficiencly..
18:20:43 <roconnor> The Heap Lambda Machine
18:20:55 <mmorrow> monochrom: well, i'm not familiar with the transformation procedure, but perhaps learning it and using a SAT lib is the way to go?
18:21:02 <monochrom> Some NPC problems are better off transformed to SAT, but some others aren't.
18:21:23 <monochrom> I forgot TSP falls under which one.
18:21:34 <mmorrow> interesting, thanks for the tip
18:22:27 <vixey> the thing is TSP has a bunch of measures and SAT is just binary, so I think you'd get an explosion in size of problem description
18:22:35 <vixey> measures, i.e. lengths
18:22:55 <roconnor> ``Having started from the idea of graph reduction, we designed the machine where the entire memory is a uniform collection of sequentially addressable blocks allocated on demand. We have also implemented a portable software emulator of this machine.
18:23:04 <roconnor> http://arxiv.org/abs/0806.4631
18:25:11 <mmorrow> Apocalisp: ah, just saw your mention of simulated annealing. i'll add that to the list :)
18:25:35 <mmorrow> vixey: interesting
18:26:02 <vixey> (this is my conjecture)
18:26:17 <Apocalisp> mmorrow: I'll get you started though. What you want to do is take a random permutation of your route and get its length. Then switch any two points at random and get the length of that route. If it is shorter, recurse with that route, otherwise try a different pair.
18:27:09 <Apocalisp> Use parFlatMap and parZipWith to make it go fast :)
18:27:38 <mmorrow> Apocalisp: awesome, thanks.
18:27:44 <mmorrow> i owe you one
18:28:31 <Trinithis> @pl (\g i m -> g ++ i ++ m)
18:28:31 <catabot> (. (++)) . (.) . (++)
18:28:44 <Trinithis> catabot?
18:28:54 <vixey> catabot.
18:29:04 <Trinithis> is he new?
18:29:08 <mauke> preflex: seen lambdabot
18:29:08 <preflex>  lambdabot was last seen on #haskell 22 hours, 40 minutes and 13 seconds ago, saying: Consider it noted.
18:29:55 <Trinithis> is catabot functionally the same as lambdabot?
18:30:06 <vixey> Trinithis: I added one feature:
18:30:10 <dolio> orzo: Look at System.Mem.Weak, maybe?
18:30:16 <vixey> @cata data Maybe e = Nothing | Just e
18:30:17 <catabot> cataMaybe :: (z -> ((e -> z) -> ((Maybe e) -> z)))
18:30:17 <catabot> cataMaybe a _ (Nothing) = a
18:30:17 <catabot> cataMaybe _ g (Just k) = g k
18:31:00 <Trinithis> livixey what does that feature do exactly?
18:31:14 <Trinithis> vixey*
18:31:20 <vixey> I don't know, it's supposed to generate catamorphisms but it probably doesn't always do that
18:31:26 <Trinithis> lol
18:31:44 <vixey> (I didn't follow any precise definiton when I wrote it, just my intuition)
18:31:51 <Trinithis> kind of like unfold?
18:32:14 <vixey> no it should be the fold
18:32:28 <mauke> @cats data List a = Nil | Cons a (List a)
18:32:28 <catabot> cataList :: (z -> ((a -> (z -> z)) -> ((List a) -> z)))
18:32:28 <catabot> cataList a _ (Nil) = a
18:32:28 <catabot> cataList a g (Cons k yu) = g k (cataList a g yu)
18:32:43 <mmorrow> Apocalisp: hmm, so is that guranteed to converge to the global minimum instead of some local min?
18:32:44 <Trinithis> o isee
18:33:03 <Trinithis> well i gtg and eat
18:33:03 <Trinithis> cya
18:33:39 <Apocalisp> mmorrow: Nothing guaranteed. But after a few thousand iterations it's very likely to be extremely close to the optimal route.
18:34:03 <mmorrow> Apocalisp: cool. that's good enough for me ;)
18:34:13 <ddarius> @cata data F a = F (a -> a)
18:34:13 <catabot> cataF :: (((a -> a) -> z) -> ((F a) -> z))
18:34:13 <catabot> cataF f (F k) = f k
18:34:19 <Apocalisp> of course, this isn't going to be "as the crow flies", is it?
18:34:33 <mmorrow> no, along roads
18:34:58 <Apocalisp> right, so you need to start with a library of distances between every point and every other
18:35:00 <mmorrow> so in addition i'll have to figure out someway to get distance info, but i'm just assuming that's solved for now
18:35:02 <mauke> @cata data F a = F (F a -> F a)
18:35:02 <catabot> cataF :: (((z -> z) -> z) -> ((F a) -> z))
18:35:02 <catabot> cataF f (F k) = f (cataF f k)
18:35:48 <mmorrow> Apocalisp: right.
18:35:50 <SamB> yes, finding the shortest path between two points is relatively easy compared to traveling salesman ;-)
18:36:49 <ddarius> @cata data D = D (D -> D)
18:36:49 <catabot> cataD :: (((z -> z) -> z) -> (D -> z))
18:36:49 <catabot> cataD f (D k) = f (cataD f k)
18:37:05 * vixey notices non strictly positive type ~> non structural recursion
18:37:10 <dolio> That one looks suspect.
18:37:25 <ddarius> @cate data F a = F (a -> F)
18:37:25 <catabot> cataF :: (((a -> F) -> z) -> ((F a) -> z))
18:37:25 <catabot> cataF f (F k) = f (cataF f k)
18:38:47 <ddarius> @google "Bananas in Space"
18:38:48 <catabot> http://citeseer.ist.psu.edu/293490.html
18:42:19 <gwern> Bananas - in Space!
18:42:26 <gwern> protecting the functional race!
18:45:24 <wagle> developmental psychologist i knew sent some norwegian rats up on the shuttle..  he replaced his windshield guard on his truck from "ontogeny recapitulates phylogeny" with "rats in space!"
18:46:45 <ddarius> @cata data H a b = H (a -> H b a)
18:46:46 <catabot> cataH :: (((a -> ((H b) a)) -> z) -> (((H a) b) -> z))
18:46:46 <catabot> cataH f (H k) = f (cataH f k)
18:47:23 <vixey> uh oh.. that's a type error
18:47:29 <mmorrow> orzo: "<orzo> is there a way to maintain weak references to haskell objects on the heap?"
18:47:35 <ddarius> @cata data Bush a = Leaf a | Branch (Bush (a,a)) (Bush (a,a))
18:47:35 <catabot> cataBush :: ((a -> z) -> (((Bush (a,a)) -> ((Bush (a,a)) -> z)) -> ((Bush a) -> z)))
18:47:35 <catabot> cataBush f _ (Leaf k) = f k
18:47:35 <catabot> cataBush f g (Branch k yu) = g (cataBush f g k) (cataBush f g yu)
18:48:05 <mmorrow> orzo: yes. and you can combine System.Mem.Weak with System.Mem.StableName to nice effect
18:48:12 <vixey> I wonder how to handle nested types
18:48:15 <mmorrow> orzo: i'll paste an example
18:48:15 <shapr> Any A* implementations in Haskell?
18:48:22 <ddarius> @google generalized folds
18:48:24 <catabot> http://citeseer.ist.psu.edu/hinze99efficient.html
18:48:33 <ddarius> @google Initial algebras are enough
18:48:35 <catabot> http://crab.rutgers.edu/~pjohann/tlca07-rev.pdf
18:48:48 <SamB> enough for what?
18:48:57 <SamB> algebras are not sufficient!
18:48:58 <vixey> cool ddarius, thanks
18:49:03 <vixey> I think I'll have a go with this now
18:49:15 <shapr> I found one in German... not that I can really read it.
18:51:03 <hpaste>  morrow pasted "StableName+Weak for orzo" at http://hpaste.org/8659
18:52:50 <shapr> Foo, how do I search google for A* ?
18:52:52 <gwern> bleh. why is uploading a 1.3m archive to hackage so slow
18:53:09 <dmwit> ?go "a*"
18:53:12 <catabot> http://www.apple.com/
18:53:12 <catabot> Title: Apple
18:53:43 <dmwit> shapr: ...or did you mean the actual algorithm?
18:53:49 <shapr> yes
18:54:04 <shapr> I was wondering about A* in Haskell even...
18:54:06 <dmwit> ?go "a star" algorithm
18:54:08 <catabot> http://en.wikipedia.org/wiki/A*_search_algorithm
18:54:15 <gwern> just visit wikipedia
18:54:16 <shapr> In fact, I worked on such a library once long ago...
18:54:23 <shapr> gwern: It has Haskell source for A* ?
18:54:55 <gwern> algorithms are independent of language!
18:55:06 <shapr> :-P
18:55:18 <shapr> My question was more.. do I need to write this, or is it already written?
18:55:20 <TSC> Is cvs.haskell.org broken?
18:55:28 <dmwit> gwern: I tried to argue that the other night, and I got crucified by my coworkers.
18:55:37 <shapr> And in fact, I know it's already written.. I worked on it with tmoertel long years ago.. but I can't find it!
18:55:58 <TSC> ... for anonymous checkout, that is -- the web-based part is working
18:56:44 <gwern> dmwit: ah, knuthians I take it?
18:57:20 <dmwit> They seemed to think that I was arguing that no language is better than any other.
18:57:21 <dmwit> =/
18:57:38 <dmwit> Despite my rampant Haskell evangelism... =P
18:57:58 <hpaste>  morrow annotated "StableName+Weak for orzo" with "cleaned up" at http://hpaste.org/8659#a1
18:57:59 <gwern> ok, anyone got some spare time? "cabal update && cabal install darcs-cabalized" pls
18:58:51 <shapr> dmwit: That's bizarre.
18:59:11 <shapr> Whoa, cabal update is slow.
19:00:00 <gwern> shapr: yeah, I've wondered about that myself. what is it *doing*?
19:00:19 <dmwit> Solving an NP-complete problem: 3-SAT.
19:00:29 <mmorrow> @tell orzo http://hpaste.org/8659#a1
19:00:30 <catabot> Consider it noted.
19:00:40 <dmwit> Well, it might just be SAT, rather than 3-SAT.  But you get the picture.
19:00:54 <gwern> dmwit: wouldn't that be cabal upgrade? cabal update was just downloading the index I thought
19:01:04 <dmwit> Oh, never mind then.
19:01:12 * dmwit has never actually used the new cabal tools
19:01:47 <gwern> but IIRC< it's 3-sat from what I remember of the relevant TMR article
19:02:58 <shachaf> checking if we're in a darcs repository... no
19:02:59 <shachaf> configure: error: cannot find install-sh or install.sh in "." "./.." "./../.."
19:03:11 <shachaf> cabal: Error: some packages failed to install:
19:03:19 <shachaf>   darcs-cabalized-2.0.2
19:03:43 <gwern> ah, you don't have autotools installed?
19:03:56 <gwern> eg, on my system install-sh is at /usr/share/automake-1.10/install-sh
19:03:57 <mar77a> off topic but does anyone know how do to integrate: e^((1/5)*ln(x)+c)?
19:04:11 <dmwit> yes
19:04:12 <shachaf> I thought I did.
19:04:29 <dmwit> But you're right, it is off-topic.  Maybe ask in ##math?
19:04:36 <mar77a> yeah nvm
19:04:38 <mar77a> sorry
19:05:01 <dmwit> That (e^) part is pretty gratuitous. =)
19:05:32 <mmorrow> mar77a: http://integrals.wolfram.com/index.jsp
19:05:33 <catabot> Title: Wolfram Mathematica Online Integrator
19:05:44 <mar77a> yeah i used that but i want to know how
19:05:49 <mmorrow> heh
19:05:52 <mar77a> 22:04 < v64> the website posted above gives (5/6) e^c x^(6/5)
19:05:52 <mar77a> 22:04 < v64> no idea how to get to the answer, that's just what the magical website says
19:05:56 <mar77a> :p
19:07:44 <gwern> shachaf: ok, try again
19:08:17 <shachaf> gwern: OK, trying.
19:08:28 <shachaf> (And I did have /usr/share/automake-1.10/install-sh.)
19:09:40 <glguy> e^((1/5)*ln(x)+c) = e^c * e^((1/5)*ln(x) = C * e^(ln(x^(1/5))) = C * x^(1/5) ?
19:09:54 <dmwit> yes
19:09:56 <mar77a> > 1/5 + 1
19:09:56 <catabot>  <no location info>: Warning: -Onot is deprecated: Use -O0 instead
19:09:57 <catabot> <command l...
19:10:01 <mar77a> whats
19:10:08 <mar77a> > (1/5) + 1
19:10:09 <catabot>  <no location info>: Warning: -Onot is deprecated: Use -O0 instead
19:10:09 <catabot> <command l...
19:10:12 <mar77a> okay!
19:10:14 <dmwit> vixey: catabot is broken
19:10:47 --- mode: ChanServ set +o glguy
19:10:47 --- mode: ChanServ set -o glguy
19:10:59 <gwern> boy, lambdabot replacements have become something of a cottage industry
19:11:13 <vixey> glguy: Do you have a replacement ..?
19:11:16 <mar77a> what's up with \bot?
19:11:20 <dmwit> gwern: catabot *is* lambdabot
19:11:21 <shachaf> gwern: I think this is causing a GHC bug.
19:11:28 * shachaf is using a darcs GHC, though.
19:11:32 <shachaf> I'll try it with 6.8.2.
19:11:53 <glguy> vixey: I don't
19:11:58 <shachaf> ghc-6.9.20080602: panic! (the 'impossible' happened)
19:11:58 <shachaf>   (GHC version 6.9.20080602 for i386-unknown-linux):
19:11:58 <shachaf> 	RegAllocLinear.getStackSlotFor: out of stack slots, try -fregs-graph
19:12:06 <shachaf> Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
19:12:23 <gwern> hum. now there's a darcs error I've never heard/seen before
19:12:49 <gwern> shachaf: if you are feeling particularly industrious tonight, could you try the regular darcs 2.0.2/darcs darcs?
19:13:11 <shachaf> gwern: Let me try darcs-cabalized with 6.8.2.
19:13:23 <dolio> SamB: Enough for a formal categorical semantics for non-regular datatypes.
19:13:52 <dolio> (Or, inductive datatypes, at least.)
19:14:04 <dons> gwern: you're going to fork the darcs  build system?
19:14:34 <gwern> dons: not really. this is an experiment
19:14:54 <dolio> dons: You busy?
19:14:54 <gwern> if it works for people, that will be an interesting result
19:15:06 <shachaf> Whoops, I need libcurl-dev, don't I?
19:15:14 <dons> i think its a risky move to put a fork on hackage, fwiw, if you screw up darcs you make darcs and hackage look bad. better name it darcs-gwern or something, like firefox/ iceweasel
19:15:29 <dons> dolio: yeah, dinner. on and off
19:15:31 <shachaf> Wait, I have that.
19:15:36 <gwern> shachaf: it should fallback to wget or libwww I think
19:15:53 <gwern> dons: eh, if it's totally broken I guess I'll ask roconnor to delete it
19:16:02 <gwern> dons: you'll notice I'm not publicizing it :)
19:16:21 <dons> alienating the darcs devs is also counter-productive too, i think.
19:16:22 <roconnor> delete what?
19:16:25 <dons> so i don't see much benefit here.
19:16:32 <hpaste>  (anonymous) pasted "darcs-cabalized errors" at http://hpaste.org/8660
19:16:40 <dolio> dons: Ah. Well, I was still wondering about that sorting stuff and uvector. It's fine if I keep it in a separate library, but I want to make sure the hierarchy gels with the one in uvector in any case.
19:16:42 <dons> though if david decides to accept cabalised  patches (i doubt it) that would be a win
19:16:43 <glguy> super-shady to put a fork up on hackage under the same name
19:16:52 <dons> dolio: may as well put it in uvector
19:16:54 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/darcs-cabalized-2.0.2.1
19:17:03 <dons> gwern: you're maintaining it?
19:17:17 <dons> ok, i like the disclaimer. good
19:17:23 <gwern> dons: if they're alienated, they were alienated a while ago...
19:17:27 <dons> oh, it has the bytestring patches?
19:17:37 <dons> yeah, true enough.
19:18:08 <dons> we have little sway over droundy :)
19:18:29 <gwern> shachaf: any luck with ghc6.9/standard-darcs or ghc6.8.2/darcs-cabalized?
19:18:32 <dons> oh, you're bumping minor revisions, interesting.
19:18:46 <shachaf> gwern: Sorry, did you see the paste?
19:18:52 <shachaf> http://hpaste.org/8660
19:19:19 <gwern> dons: should I not be?
19:19:39 <dons> well, there's no darcs 2.0.2.1 is there?
19:19:42 <shachaf> gwern: Hmm, http://wiki.darcs.net/index.html/BuildingUnderWindows talks about that error.
19:19:43 <dons> while there is a darcs 2.0.2
19:19:49 <gwern> shachaf: hm. I've seen those before...
19:19:51 <dons> so you're using a piece of the namespace
19:20:01 <dons> maybe just use a separate namepsace, e.g. darcs2-cabalised-0.1
19:20:14 * dons wonders how the firefox / swiftfox et al do it
19:21:02 <dolio> dons: All right. I can probably send you some patches eventually, but I'd need to know where to put the stuff, module name wise. No rush, though.
19:21:07 <saadahmad> I came across the function fix in the haskell docs, and I'm curious as to if anyone could help me understand it? :)
19:21:17 <dmwit> saadahmad: Sure!
19:21:21 <dmwit> saadahmad: Have you seen the source?
19:21:24 <dons> dolio: then again, a uvector-sort package is cheap enough
19:21:26 <saadahmad> Yes
19:21:37 <dmwit> saadahmad: Okay.  Have you heard of the Y combinator?
19:21:44 <saadahmad> No
19:21:54 <dmwit> ah!
19:21:58 <SamB> isn't that a program to fund startups?
19:21:59 <saadahmad> I'll look it up then :)
19:22:05 <dmwit> =)
19:22:08 * SamB kids
19:22:27 <shachaf> SamB: Clearly it is a program to fund programs to fund programs to fund...
19:23:49 <mjrosenb> shachaf: at least it'll be able to fund it's self
19:23:50 <saadahmad> dmwit, just to make sure, Y Combinator = Fixed point combinator?
19:23:57 <monochrom> haha
19:23:58 <mjrosenb> saadahmad: yes
19:24:09 <saadahmad> Alright, thanks
19:24:55 <shachaf> saadahmad: Remember both standard definitions of fix: "fix f = f (fix f)" and "fix f = let x = f x in x"
19:25:00 <shachaf> @src fix
19:25:17 <shachaf> Huh, no lambdabots at all now.
19:25:42 <SamB> lambdac: return and be ye silly!
19:26:34 <SamB> (last time I saw lambdac enter the channel, *it* restated the query that someone had just attemted to do before it had joined ...)
19:26:45 <SamB> (... but did not compute the answer)
19:27:26 <saadahmad> shachaf, I used this for the source http://haskell.org/ghc/docs/latest/html/libraries/base/src/Data-Function.html and I'm wondering where the first definition came from :)
19:29:14 <shachaf> saadahmad: Well, they're equivalent.
19:29:35 <saadahmad> Alright, thanks. This channel is great help
19:29:49 <dolio> dons: Well, it's up to you. I've started toying with a uvector-algorithms package, although I'm not sure I'm hapy with the module names (I'm already at Data.Array.Vector.Algorithms.Mutable.* for most of the stuff). I might send you some patches with stuff I'd want in uvector either way (memcpy for one, although I'm not sure about the names there, either).
19:31:14 <dons> yeah, i'd like to keep uvector to the list-like stuff. send me patches to help with exteranl algorithms (i'd imagine all sorts of numeric stuff on top evenetually)
19:31:29 <dons> and put your external stuff into its own packages
19:31:53 <gwern> shachaf: did you try adding 'curl' to extra-libraries:?
19:32:04 <gwern> that sometimes helps
19:32:19 <shachaf> No, I didn't mess with the insides of the .tar.gz.
19:32:26 <shachaf> Should I try that?
19:32:27 <gwern> ok, well try that
19:34:00 <megacz> Hello, all.  Has anybody else encountered "darcs get --partial http://darcs.haskell.org/ghc" simply sitting there doing nothing (0% CPU)?  This is happening to me with both 1.0.9 and 2.0.0 -- but only with the GHC repo (other repos work fine).
19:35:07 <dons> 0%? no.  let me try it now.
19:35:34 <megacz> Well, maybe 4%.  It isn't "patch misery" (100%), for sure.
19:36:00 <megacz> I've tried this from both on- and off- campus, so I can't see it being a network issue.
19:36:01 <mjrosenb> megacz: i thought that darcs-2.0 had fixed patch misery
19:36:36 <gwern> hum, it seems my system isn't exercising the curl stuff because curl isn't getting detected by the configure script
19:36:38 <jre2> mjrosenb: I thought that required a darcs-2 repo?
19:37:05 <gwern> it does, yeah. and it turns out it apparently is possible to get patch misery with 2.0
19:37:13 <mjrosenb> jre2: entirely possible
19:37:56 <dons> well, this is just a fresh checkout.
19:38:08 <dons> seems to be taking a while to get the inventory listing
19:39:36 <jre2> gwern: really? I already have a hard enough time convincing git users to let us use darcs on our current project.
19:40:35 <gwern> jre2: yeah, there's a bug report on it. at least it should be much less common on 2.0
19:40:43 <mmorrow> > 1
19:40:50 <mmorrow> is there a bot in here
19:40:51 <mmorrow> ?
19:40:53 <dons> i've not heard of any issues since 2.0 was released.
19:40:54 <dmwit> no
19:40:58 <mmorrow> eh
19:40:59 <dons> nor hit any, so i'm pretty happy
19:41:23 <megacz> dons, woah, darcs just woke up and started copying patches.  okay, I guess I'm just impatient.
19:41:40 <dons> megacz: yeah, mine too. something happened on the network
19:42:06 <megacz> ok, so perhaps something is funny with the http server where the ghc repo lives.  But not so funny that I can't get work done.  Thanks!
19:46:31 <gwern> /usr/bin/ld: cannot find -lcurl <-- now that's definitely not right
19:47:18 <LordBrain> what is "the bikeshed problem?"
19:47:56 <LordBrain> @seen sbronson
19:48:01 <cjb> LordBrain: context?
19:48:13 <LordBrain> http://www.haskell.org/pipermail/libraries/2006-November/006260.html
19:48:23 <dolio> @goog bikeshed
19:48:29 <cjb> LordBrain: http://www.freebsd.org/doc/en_US.ISO8859-1/books/faq/misc.html#BIKESHED-PAINTING
19:48:31 <dolio> Oh, right.
19:55:38 <gwern> shachaf: ok, I've reproduced your curl error. turns out my system didn't have the right curl package installed so the configure script wasn't even bothering to enabe curl
19:55:59 <hpaste>  shachaf pasted "How do I avoid typing (Show a, Show b, Show c, Show d) => everuwhere?" at http://hpaste.org/8661
19:59:00 <Cale> shachaf: Write an instance of show for Foo?
19:59:15 <shachaf> Cale: It has an instance of Show.
19:59:27 <Cale> okay
19:59:40 <shachaf> Cale: But a lot of functions show Foo in how they use it.
19:59:57 <shachaf> And it can get annoying to type (Show a, Show b, Show c, Show d) => on all of those.
20:00:26 <Cale> Well, you're not going to get away from needing Show instances. In GHC 6.8+ you can tell it to store the instances when constructing the data.
20:00:39 <Cale> data Foo a b c d where
20:00:57 <Cale>    Foo :: (Show a, Show b, Show c, Show d) => a -> b -> c -> d -> Foo a b c d
20:01:35 <Cale> That will include (pointers to) the instances in each Foo value.
20:01:57 <Cale> (so you won't need the constraints on functions that pattern match Foo values)
20:02:15 <ivanm> Cale: ooohhh, I didn't know about that!
20:02:20 <ivanm> is that an extension?
20:02:25 <Cale> yeah
20:02:38 <Cale> It's part of the GADT syntax.
20:02:56 <ivanm> *nod*
20:02:59 <shachaf> But then you can't derive Show?
20:03:10 <Cale> Even though that syntax is available in 6.6.x, it doesn't work correctly until 6.8.x
20:03:26 * shachaf remembered reading something about that.
20:03:30 <Cale> Uh, I'm not sure. Probably not.
20:03:37 <shachaf> I should look into GADTs more.
20:04:31 <shachaf> Cale: But then there's a lot of other boilerplate. :-)
20:05:56 <Cale> instance Show (Foo a b c d) where
20:05:56 <Cale>     show (Foo x y z w) = unwords ["Foo", show x, show y, show z, show w]
20:06:00 <Cale> Just that.
20:06:52 <shachaf> Cale: But then there's Eq and Ord and so on.
20:07:05 <Cale> Yeah, it can't be helped, I suppose.
20:07:38 <shachaf> No way to do it other than GADTs?
20:07:42 <Cale> Nope.
20:08:05 <mmorrow> it can if one were to write a deriver using haskell-src-exts ast for gadts
20:08:18 <mmorrow> it's been "on my list" for about a month
20:08:48 <mmorrow> so, if anyone's motivated.... :)
20:22:52 <mmorrow> (of course by "it can" i meant "Show et al can be derived for GADTs...")
20:33:22 <gwern> shachaf: I'm going to call it a night. this error isn't yieldin
20:37:17 <dolio> > 1
20:41:06 <dolio> preflex: seen lambdabot
20:41:07 <preflex>  lambdabot was last seen on #haskell 1 day, 52 minutes and 12 seconds ago, saying: Consider it noted.
20:49:23 <sjanssen> what happened to lambdabot?
20:51:44 <dolio> "The Haskell community make a huge amount of noise, a tiny amount of useful software and no profitable products at all."
20:52:38 <dabblego> haha
20:52:45 * dabblego runs around making noise
20:53:20 <wuxia> is there anything like wings3d, but written in haskell (i.e. a 3d modeler written in haskell) -- mainly  interested in it for (1) learning how 3d modelers are implemented and (2) how they are implemented using monads
20:56:15 <dolio> I imagine the answer to #2 is, potentially, "not much different than they're implemented in any other language."
20:57:20 <dolio> Although it's possible there is some vastly different way to do things.
21:08:18 <sjanssen> dolio: lemme guess, JDH quote?
21:09:42 <dolio> You must be a psychic or something.
21:14:33 <sjanssen> @google "The Haskell community make a huge amount of noise, a tiny amount of useful  software and no profitable products at all.
21:14:49 <sjanssen> oh, that won't work
21:14:51 <dons_> hah
21:30:07 <Associat0r> dons I want to study cat theory from the  Awodey book, but have no experience with abstract algebra, do you have any recomendations?
21:31:20 <masak> I'm fairly new at Haskell, and would like constructive comments on this way of implementing 'all permutations of a list': http://paste2.org/p/44147
21:32:04 <masak> anything from "you can use this function instead" to "don't do that, it's slow"
21:32:16 <Cale> masak: One criticism is that this requires an instance of Eq
21:32:28 <masak> Cale: I needed that for delete
21:32:34 <Cale> masak: Right.
21:32:39 <Cale> It's possible to write that function without comparing for equality anywhere.
21:33:00 <masak> I'd like to know how
21:33:50 <Cale> One useful function which I'd suggest starting with (as it's bafflingly not in the list library) is a function [a] -> [(a,[a])] which takes a list and gives a list of pairs consisting of an element of the list, together with a list of the remaining elements.
21:34:16 <Cale> For instance: select [1,2,3]  ->  [(1,[2,3]), (2,[1,3]), (3,[1,2])]
21:34:21 <masak> Cale: good idea
21:34:29 <masak> I can see how that might come in handy
21:34:34 <Cale> yeah :)
21:34:38 <masak> any suggestion of what to call it?
21:34:44 <Cale> I usually call it select
21:34:48 <masak> ok
21:35:15 <masak> and it can be implemented without relying on Eq?
21:35:18 <Cale> right
21:35:31 <Cale> Just plain recursion
21:36:19 <masak> ah -- I think I see it now
21:36:30 <masak> at least that it's possible
21:40:01 <Cale> List comprehensions help with the syntax. (In both this and permute)
21:41:24 <Cale> Associat0r: You want recommendations on abstract algebra books?
21:42:28 <masak> Cale: I'll try my hand at a new version using your suggestions
21:42:44 <Cale> masak: Yeah, give it a shot, and let me know if you get stuck :)
21:42:55 <masak> :) I will. thanks
21:47:05 <Associat0r> Cale yeah and if it is really needed for studying Cat Theory
21:47:38 <Cale> Associat0r: Well, I'm not sure that it's *necessary*, but it helps in that it provides some key examples of categories.
21:47:57 <jre2> there's something amusing yet mildly disturbing about replacing >5K lines of code with 6 lines of haskell in 10min of work (arguably 5, but I wasted time pretty printing)...
21:48:09 <Cale> :)
21:48:49 <kiris> what is ($) called?
21:48:49 <Associat0r> Cat Theory is the highest abstraction in math right?
21:48:56 <dobblego> function application
21:48:58 <Cale> kiris: application
21:49:03 <Associat0r> or is there anything higher?
21:49:09 <Cale> Associat0r: In a sense, yes.
21:49:12 <kiris> I suppose that will do
21:50:13 <sieni> It depends on what you mean by abstraction?
21:51:48 <Cale> Associat0r: There are alternate ways of looking at things, like model theory or universal algebra, which might also interest you if you're in search of the very-general.
21:52:49 <Cale> It's also possible to turn things around a bit and look at category as a low-level substrate on which to build things, which is a view put forward by Lawvere and a number of others.
21:53:09 <Cale> (In place of using set theory)
21:57:21 <Associat0r> thanks for the pointers
21:58:10 <kiris> where is lambdabot?
21:58:29 <Cale> good question.
21:58:50 <Cale> my screen on code is gone
21:59:00 <cjb> > 2 + 2
21:59:05 <cjb> > 2 + 2
21:59:10 <lambdabot>  4
21:59:15 <cjb> hurrah.
21:59:16 <lambdabot>  4
21:59:17 <kiris> hurrah
22:04:03 <kiris> is it possible to express things like map and foldr in Î»-calculus?
22:06:03 <hpaste>  jdrake pasted "problem with function, error included." at http://hpaste.org/8662
22:06:24 <jdrake> This function I am writing seems to have a problem with classes I think, but I am not sure how to fix it.
22:06:58 <jdrake> hmm, I think I forgot something...
22:07:22 <jdrake> yes, I forgot lists need a ,
22:07:47 <kiris> jdrake: are you a lisper?
22:08:43 <jdrake> kiris: Can't say I am. I have tried scheme in the past, but favoured not parenthesis languages
22:08:55 <jdrake> Any particular reason you ask?
22:09:04 <cjb> I think I'd like a lisp that used Haskell syntax
22:09:14 <cjb> (ie. "." and "$" instead of parens)
22:09:41 <kiris> yeah, probably accomplishable with reader macros
22:10:42 <jdrake> I was trying to get this function: where isfactor x = (n `mod` x) == 0   to work just inside the filter, but I couldn't figure out how to get it to work great
22:10:54 <kiris> jdrake: in the syntax of lisp spaces are used to separate list items
22:11:20 <jdrake> yes, that is my understanding
22:12:14 <jdrake> Now we see if my euler3 code works
22:12:21 <jdrake> a couple weeks in the making...
22:13:10 <hpaste>  jdrake pasted "euler3.lhs" at http://hpaste.org/8663
22:14:07 <mjrosenb> jdrake: that number appears to be far too large to compute with such a slow algorithm.
22:14:24 <jdrake> mjrosenb: I have no other algorithm
22:15:03 <jdrake> I am trying to figure things out myself, but the original primes there came from another here
22:15:21 <jdrake> I am looking into number theory a little bit more so I can get a better sieve going
22:15:30 <mjrosenb> jdrake: i know.  it's the standard one line definition; and also slow.
22:16:55 <jdrake> The general definition was something I was thinking about with regards to that basic sieve, which I am surprised it isn't described as such on wikipedia.
22:18:16 <kiris> :t ((==) 0)
22:18:17 <lambdabot> forall t. (Num t) => t -> Bool
22:18:21 <kiris> :t (==0)
22:18:22 <lambdabot> forall a. (Num a) => a -> Bool
22:18:33 <kiris> :t (mod 0)
22:18:35 <lambdabot> forall t. (Integral t) => t -> t
22:18:55 <kiris> :t ((mod 0) . (==0))
22:18:56 <lambdabot>     No instance for (Integral Bool)
22:18:56 <lambdabot>       arising from a use of `mod' at <interactive>:1:2-6
22:18:56 <lambdabot>     Possible fix: add an instance declaration for (Integral Bool)
22:19:03 <kiris> :t (.)
22:19:04 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
22:19:41 <mjrosenb> jdrake: my guess would it's just too basic, and eritostenes' sieve performs so much better, and is almost as simple, so there's no point
22:20:10 <mjrosenb> kiris: iirc, that's a non-standard definition of (.)
22:20:43 <jdrake> mjrosenb: This thing seems to describe the Sieve of Eratosthenes from my understanding.
22:21:10 <mjrosenb> jdrake: the sieve doesn't use 'mod' ever
22:21:30 <povman> @src (.)
22:21:30 <lambdabot> (f . g) x = f (g x)
22:21:30 <lambdabot> -- In lambdabot, it's been generalised to:
22:21:30 <lambdabot> (.) = fmap
22:21:51 <kiris> yes
22:22:17 <mjrosenb> > ((+1) . (+1)) 3
22:22:19 <lambdabot>  5
22:22:36 <mjrosenb> what functor is f being instantiated at for that?
22:22:46 <jdrake> mjrosenb: the way I am looking at the description in wikipedia, it would seem to me that generating a list that is tested on its previous members (who are already guaranteed to be prime) would fit the bill.
22:23:06 <povman> :t (.) (+1)
22:23:07 <lambdabot> forall a (f :: * -> *). (Functor f, Num a) => f a -> f a
22:23:52 <povman> mjrosenb: isn't it (->) ?
22:24:06 <jdrake> Now by strict definition, marking items in the future, it isn't, but it would seem to me to be the same sort of thing.
22:24:11 <mjrosenb> povman: i have no idea.  that's why i asked
22:25:28 <mjrosenb> jdrake: i wouldn't say your generalization of his sieve is correct
22:26:07 <hpaste>  ellisk pasted "Infinite type error, help?" at http://hpaste.org/8664
22:27:09 <jdrake> mjrosenb: I shall have to look into it on the morrow.
22:27:43 <vixey> ellisk:   c <- liftM cross get ; (offspring1,offspring2) <- c x y looks odd
22:27:56 <vixey> ellisk: maybe you should do let c = liftM cross get ; (offspring1,offspring2) <- c x y
22:28:42 <jdrake> Is there anything that provides a good instruction into O() timing notation and figuring out such for an algorithm?
22:29:42 <mjrosenb> jdrake: 4 years of undergrad CS?
22:30:07 <jdrake> mjrosenb: I doubt it requires that
22:30:27 <mjrosenb> jdrake: it's the only way i know of
22:31:07 <jre2> theres slides for most classes at my uni at http://www.cs.uiuc.edu/undergraduate/courses.php
22:31:08 <lambdabot> Title: Courses | Undergraduate Education | Computer Science | University of Illinois at ...
22:31:33 <jre2> CS225 (data structures) and CS473 (algorithms) should get you what you need
22:31:41 <SamB> hmm, am I going to get lynched if I mention TAOCP?
22:32:19 <mjrosenb> SamB: never
22:33:53 <jre2> sorry, didn't realized they removed some of those for the summer
22:33:58 <_zenon_> jdrake: An Algorithms course?
22:33:59 <jre2> http://www.cs.uiuc.edu/classarchive/sp08archive.php
22:33:59 <lambdabot> Title: Spring 2008 Archive | Class Listing | Computer Science | University of Illinois  ...
22:34:02 <solrize> cjb you might like dylan
22:36:14 <vixey> anyone know about this?
22:36:15 <vixey> "If you are using ghc-6.9 and have an empty
22:36:15 <vixey> user package database then this is probably due to ghc bug #2201. The
22:36:15 <vixey> workaround is to register at least one package in the user package db."
22:36:20 <vixey> How do I do that?
22:37:11 <vixey> I guess it's cabal register <something>, but I don't know what
22:37:27 <SamB> hmm.
22:37:32 <SamB> I don't remember...
22:38:13 <SamB> I think my solution was to alter my copy of cabal ;-)
22:38:39 <SamB> (or was it ghc-pkg?)
22:39:40 <SamB> oh, yeah, I think I semi-fixed the bug in ghc-pkg
22:41:31 <hpaste>  SamB pasted "ghc-pkg changes" at http://hpaste.org/8665
22:41:55 <masak> Cale: there, I made an implementation of select. http://paste2.org/p/44170
22:42:01 <masak> I'm sure it can be improved on
22:43:56 <SamB> vixey: I don't suppose that helps?
22:44:12 <vixey> SamB: I have no idea what to do with that
22:44:21 <Cale> masak: It's possible to avoid the helper too :)
22:44:28 * masak thought so
22:44:40 <povman> is there a remote object type library for haskell?
22:44:40 <masak> it seemed needlessly involved
22:44:45 <Cale> Would you like to see that?
22:44:46 <SamB> vixey: you apply it to the source of ghc-pkg and rebuild it ?
22:45:13 <masak> Cale: yes, please
22:45:24 <Cale> select []     = []
22:45:24 <Cale> select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs]
22:45:35 <masak> ah, cool
22:46:16 <Cale> You can also use a list comprehension to make perms pretty:
22:46:21 <Cale> permute [] = [[]]
22:46:21 <Cale> permute xs = [y:zs | (y,ys) <- select xs, zs <- permute ys]
22:46:34 <masak> I seriously doubt that I would have independently come up with that part after the | in select
22:46:44 <mjrosenb> :t select
22:46:45 <masak> Cale: thanks! that _does_ make perms prettier
22:46:46 <lambdabot> Not in scope: `select'
22:47:02 <mjrosenb> oh, you defined it there
22:47:59 <mjrosenb> select :: [a] -> [(a,[a])+]?
22:48:06 <Cale> So the idea is that all you have to do to go from select xs to select (x:xs) is to include the selection (x,xs) at the beginning, and extend the "rest of the list" part in all the others to include x.
22:48:16 <SamB> vixey: have you never applied a patch before?
22:48:26 <Cale> mjrosenb: what's that + ?
22:48:26 <masak> Cale: yes
22:48:27 <mjrosenb> it returns a tuple of an element and everything esle for each element?
22:48:32 <vixey> I didn't even know I had a program called ghc-pkg
22:48:37 <Cale> mjrosenb: yeah
22:48:38 <mjrosenb> Cale: it shouldn't be there
22:48:54 <masak> Cale: is there any sense in putting select in the where clause of permute in this case?
22:49:07 <Cale> > let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs] in select [1,2,3]
22:49:09 <lambdabot>  [(1,[2,3]),(2,[1,3]),(3,[1,2])]
22:49:26 <Cale> masak: You could, but I think it's a genuinely useful function on its own.
22:49:57 <masak> I'll take that as there being no incentice either way if I only use it once, as here
22:50:09 <Cale> yeah
22:50:16 <SamB_XP> masak: I'd probably put it at the toplevel
22:50:24 <SamB_XP> just because that makes it easier to play with
22:50:29 <masak> SamB_XP: ok :)
22:50:31 <Cale> masak: Generally, I'll pull something up into a where clause if I don't think it would be useful to anyone else.
22:50:43 <masak> ah
22:51:24 <masak> the comprehensions helped a lot in making the code compact and pretty
22:51:28 <Cale> yeah
22:51:41 <masak> for some reason, comprehensions look neater than lambdas
22:52:03 <Cale> Especially in the second case, where you have that concatMap
22:52:16 <masak> yes
22:52:20 <vixey> you may sometimes write =<< instead of concatMap
22:52:31 <Cale> (concatMap is what the comprehension desugars to anyway)
22:52:38 <masak> vixey: I'll remember that
22:56:04 <povman> is there a library that provides a networked version of IORef or something?
22:56:32 <Cale> hmm
22:56:37 <Cale> networked IORef?
22:56:59 <Cale> How would that work?
22:57:13 <vixey> sounds like a distributed reference cell in Oz
22:57:34 <vixey> everytime anyone sets it, the change can be broadcast
22:57:59 <povman> i imagine it would be difficult to generalise something like writeIORef
22:58:13 <quicksilver> you would need serialisation though
22:58:26 <quicksilver> preferably for all types including functions.
22:58:43 <Cale> and preferably without forcing evaluation ;)
22:58:52 <quicksilver> and you'd have to decide if you broadcast thunks or only NF values
22:58:54 <quicksilver> right.
22:58:55 <povman> it would be quite complex - i was wondering if anyone had made life easy before embarking
22:59:14 <vixey> povman: well this exists in Oz..
22:59:25 <quicksilver> for pure data it woud be fairly simple
22:59:25 <vixey> you might steal ideas from it
22:59:36 <povman> vixey: thanks
22:59:37 <quicksilver> you could piggyback on derving Binary
23:01:18 <cjs> Calling oneself "sama"?
23:01:53 <Cale> cjs: Yeah, I thought that a bit interesting as well :)
23:02:39 <Cale> I suppose it's an effective way to express arrogance :)
23:03:44 <vixey> what ?
23:03:48 <vixey> @w80 sama
23:03:49 <lambdabot> No match for "sama".
23:04:02 <vixey> who/where is sama
23:04:28 <Cale> sama is an honorific suffix in Japanese
23:04:49 <povman> o'sama
23:04:50 <Cale> I assume cjs is referring to Maya-sama
23:06:15 <kriomant> hello all. i'm trying to parse binary file in haskell, there is Data.Binary, but I can see how to detect end-of-file?
23:07:01 <Maya-sama> :o
23:08:37 <cjs> It's a level above "-san", which would be mister.
23:08:49 <Cale> kriomant: If you're writing something in the Get monad, use isEmpty to test if the input has been entirely consumed.
23:08:52 <cjs> I suppose you might translate it as "The Honourable ...".
23:09:48 <_zenon_> cjs: Honorable
23:10:28 <dobblego> no, Honourable
23:11:26 <_zenon_> http://www.merriam-webster.com/dictionary/honorable
23:11:26 <lambdabot> Title: honorable - Definition from the Merriam-Webster Online Dictionary
23:11:28 <Cale> Unless you're in a part of the world where words are consistently misspelled.
23:12:47 <dobblego> such as the United States, where it is misspelled "Honorable"
23:12:58 <cjs> Ah that great British dictionary, Merriam-Webster.
23:13:03 <sjanssen> are we actually arguing about this?
23:13:09 <cjs> It's a slow day. :-)
23:13:13 <kiris> misspelt :P
23:13:15 <kriomant> Cale: thanks. for some reason documentation for Data.Binary doesn't contain any reference to Data.Binary.Get package...
23:13:20 <dobblego> kiris, that's not right
23:13:30 <dobblego> sjanssen, no, just defending one's correct spelling :(
23:13:31 <dobblego> :)
23:13:41 <_zenon_> sjanssen: I hope not, that would imply the retard rate is increasing here....in the haskell channel.
23:13:58 <_zenon_> which would be quite sad.
23:15:00 <quicksilver> given that "The Honourable" is, as far as I know, a uniquely British title, it would be perverse to choose the american spelling in that context.
23:15:10 <kiris> dobblego: well, the dictionary finds it acceptable, but that was not the point
23:15:26 <dobblego> kiris, the dictionary should find both acceptable (I haven't looked it up)
23:15:41 <kiris> dobblego: yes
23:15:45 <_zenon_> dobblego: Both spellings are acceptable
23:15:55 <quicksilver> ah, no, it is apparently used by some federal officicals. How interesting.
23:15:55 <dobblego> I am referring to mispelt/misspelled here
23:15:57 <kiris> I should state clearly: it was a joke
23:16:18 <quicksilver> that's never cropped up in my watchings of such bastions of american culture as "24" ;)
23:16:20 <dobblego> *misspelt
23:17:17 <Cale> Interestingly the OED doesn't list honorable, even as an alternate spelling of honourable :)  It does however list both misspelt and misspelled.
23:18:00 <dobblego> one is a perversion; the other isn't
23:18:38 <_zenon_> Cale: That is just ..... sad.
23:18:41 <kiris> a lot of English is inane, including negatives lacking positives, like "inane"
23:19:11 <sjanssen> dobblego: it is not that simple
23:20:02 <dobblego> I didn't intend that as an explanation, just an observation
23:20:02 <Cale> actually, it does, sorry about that :)
23:20:14 <Cale> honorance, honorand, honorant, honorarily, honorarium, honorary, honorate, honorial, honorific, honorificabilitudinity, honorificence, honorify, honoris causa, honorous, honourous, honour/honor, honourability, honourable/honorable
23:20:23 <vixey> @w80 honorificabilitudinity
23:20:23 <lambdabot> No match for "honorificabilitudinity".
23:20:32 <vixey> I knew it wasn't a realy word...
23:20:44 <vixey> I can't even say that
23:20:46 <Cale> It's marked Obs. rare
23:21:19 <Cale> The last quoted instance they have of it is in 1800, and the first is in 1599.
23:23:44 <_zenon_> mapM_ putStrLn $ filter obscure_word dictionary
23:23:53 <_zenon_> there.
23:23:53 <_zenon_> done.
23:24:23 <Cale> I'd love to have a database version of the OED :)
23:25:06 <_zenon_> who wouldn't :)
23:25:15 <_zenon_> I am sorry, "Who would not?"
23:26:15 <kiris> who wood not
23:26:18 <_zenon_> @pl mapM_ putStrLn $ filter obscure_word dictionary
23:26:19 <lambdabot> mapM_ putStrLn (filter obscure_word dictionary)
23:26:32 <_zenon_> bleh
23:26:58 <sjanssen> is obscure_word a pure function?
23:27:23 <_zenon_> hmmm
23:27:31 <_zenon_> it's completely hypothetical
23:27:40 <_zenon_> so I guess it's in a state of flux :)
23:27:49 <_zenon_> it's all possible types that fit in
23:27:58 <mjrosenb> hrmm, should that be (==obscure_word)?
23:28:12 <Cale> Probably not :)
23:28:17 <sjanssen> mjrosenb: no, that would search for only one obscure word
23:28:21 <mjrosenb> oh
23:28:27 <kiris> for an interesting implementation of Eq
23:28:34 <Cale> What's more suspect is the putStrLn, I think
23:28:37 <kiris> and putStrLn, heh
23:28:40 <mjrosenb> obscure_word :: String -> bool
23:28:40 <sjanssen> (we've already established that the words are [Char], due to the use of putStrLn)
23:28:50 <Cale> I would expect the dictionary entries to have some structure to them :)
23:28:55 <vixey> hindly milner machines
23:29:02 * mjrosenb would have gone for the lisp-ish isObscureWord
23:29:16 <_zenon_> Hmm... indeed, but this is just a list of words
23:29:16 <vixey> lisp would be obscure-word-p
23:29:27 <kiris> you mean `obscure-word?'? :p
23:29:33 <_zenon_> :)
23:30:08 <kiris> haha, that cracked me up. that is in fact nothing like lisp
23:30:09 <mjrosenb> kiris: that would also work
23:30:20 <Cale> OBSCURE-WORD-P
23:30:26 <_zenon_> Cale: indeed
23:30:33 <mjrosenb> kiris: it's like some horrible dialect of lisp that i had to use
23:31:00 <Cale> isObscureWord is probably what I'd call the function in Haskell :)
23:31:03 <kiris> oh, my condolences
23:31:12 <Cale> I'm a fan of the camelCase :)
23:31:22 <_zenon_> obscure :: Entry -> Bool
23:31:44 <Cale> Or that :)
23:31:46 <kiris> I'm a fan of whatever format is standard in the language I use
23:31:56 <int-e> hmm, I'd expect obscure :: Entry -> Entry
23:31:56 <Cale> It might even be a field name :)
23:32:20 <int-e> (which would do something entirely different, of course.)
23:32:20 <Cale> int-e: Would it rot-13 the contents? :)
23:32:25 <sjanssen> that doesn't seem too similar to the way a dictionary is written
23:32:26 <kiris> int: why? you mean like "bacon" -> "beikun"?
23:32:26 <int-e> possibly
23:33:07 <cjs> Yeah, I used to be really keen on underscores in my C days, then CamelCase in my Java days, then underscores again in my Ruby days, and now, hell, who cares?
23:33:09 <int-e> kiris: yep. The point is, I'd read "obscure" as a verb and use "isObscure" for a test.
23:33:10 <Cale> bacon -> ç±³å
23:33:17 <sjanssen> I'd expect that it'd be something like: data Word = Word {word :: String, definitions :: [String], tags :: Set Tag, etc.}
23:33:22 <sjanssen> where obscurity is a tag
23:33:30 <cjs> But in ruby or scheme that would be (obscure? "foo").
23:33:51 <cjs> (Well, Ruby, maybe "foo".obscure? if you're into modifying String.)
23:34:06 <vixey> @xeal
23:34:06 <lambdabot> bot defective
23:34:11 <vixey> @qeal
23:34:11 <lambdabot> can you make a macro that builds the expression accoridng to a genetic algorithm where you decide what is good and what is bad?
23:34:13 <kiris> int: a good point. better than using obscurise later on
23:34:20 <general> How would a newbie (out of high school, knows C & Python) go about learning Haskell?
23:34:31 <kiris> read Real World Haskell?
23:34:40 <cjs> That would be a good way.
23:34:41 <Cale> general: Well, we could point you at some tutorials :)
23:34:45 <cjs> I like Graham Hutton's book, too.
23:34:53 <opqdonut> hudak is nice also
23:35:07 <cjs> If you've not done the recursive-higher-order-function thing before, _The Little Schemer_ is good.
23:35:08 <_zenon_> general: Haskell.org
23:35:17 <general> kiris: I already have Real World bookmarked. I just wanted some recommendations.
23:35:20 <sjanssen> @keal
23:35:20 <lambdabot> nsa prevent me from returning to math on efnet
23:35:28 <Cale> general: and feel free to ask lots of questions here :)
23:35:29 <_zenon_> general: There you will find loads of links to great tutorials / books
23:36:27 <kiris> general: I think Real World Haskell has a part at the start which says "people who will want to read this". maybe you could read it and say "that's me!! =o"
23:36:32 <_zenon_> kiris: I disagree, I would point general to the gentle
23:36:36 <general> I haven't done any functional programming, or any serious programming for that matter. After l learn Haskell, I'd like to study some CompSci.
23:37:29 <kiris> _zenon_: I think Gentle is quite dry. it's not difficult to understand but it is difficult to read, imho
23:37:30 <cjs> Ah! You can get a bit of both at the start, if you're willing to shell out a bit of money for a textbook.
23:37:42 <cjs> I'd highly recommend starting with Hutton.
23:37:42 <general> Heh. No cash :)
23:37:56 <_zenon_> kiris: Well I have to give you that, the overall layout of the Gentle is quite simplistic....
23:38:07 <cjs> "simplistic." Heh.
23:38:17 <_zenon_> http://en.wikibooks.org/wiki/Haskell
23:38:17 <kiris> ah, here it is: http://book.realworldhaskell.org/beta/whyfp.html#id318704
23:38:19 <lambdabot> Title: ChapterÂ 1.Â Why functional programming? Why Haskell?
23:38:27 <_zenon_> the haskell wikibook is all okay for the basics, really
23:38:31 <_zenon_> has a lot of nifty stuff
23:38:36 <general> lambdabot: Yeah, I read the first chapter.
23:39:04 <kiris> I like a book that specifies its target audience at the start
23:39:52 <general> I was just afraid that the RWH book might be incomplete. If real Haskell programmers find it okay, I guess I'd go with it ...
23:40:24 <_zenon_> and so they jump at him, like vultures at a soft carcass, handing out links and good tips :)
23:40:41 <general> No other choice. No cash + it's difficult to get good CompSci books in India. We only have Pearson Low Price editions here.
23:40:43 <kiris> well, it is not fully complete, but I personally recommend it over others regardless
23:41:04 <shachaf> general: Hutton is indeed nice, if a bit short.
23:41:30 <_zenon_> general: The union of all the texts will mostly do, and the haskell # will always be open
23:41:51 <general> shachaf: Is it an online tut?
23:41:56 <shachaf> general: No.
23:42:00 <shachaf> But cjs mentioned it before.
23:42:10 <shachaf> @go programming haskell hutton
23:42:11 <lambdabot> http://www.cs.nott.ac.uk/~gmh/book.html
23:42:11 <lambdabot> Title: Programming in Haskell
23:42:18 <_zenon_> general: I would also recommend Wadlers paper on monads, it's written in a .... simple way :)
23:42:48 <general> _zenon_: Googling it ...
23:43:16 <_zenon_> http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf
23:43:17 <lambdabot> http://tinyurl.com/zhxow
23:43:46 <kiris> what a baastad?
23:44:09 <general> _zenon_: You forget that I have no idea what a monad is (yet!). I'll save this for later reference.
23:44:18 <_zenon_> here is the link to the course homepage for "Advanced Functional Programming" on my TU for this year, http://www.cs.chalmers.se/Cs/Grundutb/Kurser/afp/
23:44:19 <lambdabot> Title: Advanced Functional Programming
23:44:29 <kiris> this paper is really nice. thanks, zenon
23:45:08 <kiris> I think I will print it off
23:45:22 <general> RWH it is then. I sign off. Thanks for the recommendations :)
23:45:24 <nburlett> what's this mean? ranlib: file: /opt/local/lib/ghc-6.8.3/libHSrts.a(Disassembler.o) has no symbols
23:45:25 <_zenon_> kiris: I also did that :)
23:45:43 <_zenon_> The lecture slides from the AFP are quite good
23:45:55 <_zenon_> Hmm.. will it convert it to tinyurl?
23:45:58 <_zenon_>  http://www.cs.chalmers.se/Cs/Grundutb/Kurser/afp/
23:45:58 <lambdabot> Title: Advanced Functional Programming
23:46:04 <_zenon_> nope, it didn't
23:46:14 <_zenon_> when does it convert?
23:50:34 <kiris> when it's quite long
23:50:52 <kiris> I believe it is meant for convencience for those who can't simply click the URLs
23:51:24 * mjrosenb has a terminal that does the hard work for him
23:52:30 <kiris> does lambdabot support entities in page titles yet? test:
23:52:31 <kiris> http://www.barnesandnoble.com/
23:52:43 <kiris> uh, no title
23:52:58 <kiris> lambdabot: ping
23:54:00 <kiris> > "hello?"
23:54:02 <lambdabot>  "hello?"
23:54:10 <kiris> I see
23:55:19 <kiris> why wasn't lambdabot able to obtain the title from barnesandnoble.com?
23:55:43 <kiris> I will look at the source
