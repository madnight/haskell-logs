00:23:44 <edmoore> If you had to elevator-pitch Haskell to an engineer who thinks c and octave would alone happily get him through life, what would you say?
00:24:17 <codacola> tell him he can drive himself mad with haskell, he'll love it
00:24:39 <kig> and give him the source to (-) and negate
00:25:30 <_zenon_> edmoore: Show him how to do a quicksort in haskell :)
00:26:21 <edmoore> I am that engineer, and I have an itch to get into it, but at the same time I don't have much time to learn a new language unless it's going to help me. I do all sorts, signal proccessing to monte carlo sims of planetary landers to parachute design, so I have quite a braod range of apps that I often program for. I wonder if haskell could help me do something I currently do much better, or let me do something I'd not thought of because of t
00:26:39 <Mr_Awesome_> @src negate
00:26:39 <lambdabot> negate x = 0 - x
00:26:43 <Mr_Awesome_> @src (-)
00:26:43 <lambdabot> x - y = x + negate y
00:27:06 <edmoore> lambdabot: you're doing a good job :)
00:27:18 <edmoore> Mr_Awesome_:  you, even.
00:28:33 <_zenon_> edmoore, If you wish to head-jump into haskell and see some code which can get you going... I would recommend...... this: http://en.wikibooks.org/wiki/Haskell
00:28:34 <lambdabot> Title: Haskell - Wikibooks, collection of open-content textbooks
00:28:54 <_zenon_> It has some right on examples and fair explanations
00:29:23 <_zenon_> edmoore, Why haskell? Purity
00:29:26 <baaba> i really enjoyed the write yourself a scheme in 48 hours tutorial (with the wikibook on the side)
00:30:04 <edmoore> _zenon_: I can imagine it would be good for my mind. If not immediately applicable to solving some problem I have, it'd turn me into a better programmer.
00:30:18 <edmoore> This is how I'm trying to justify it, anyway!
00:31:07 <_zenon_> edmoore, I think so 2, that's why you should always learn _more_, the more paradigms you can think in, the better you become as a problem solver, at least I think.
00:31:16 <edmoore> Second question - any other mac users? Can you give recommendations on the best way into this purity?
00:31:55 <edmoore> _zenon_: Thankyou. Just having a look around the wikibook, I'm sold. Should be a good way to learn more CS in general too.
00:32:11 <edmoore> _zenon_: Should i agnore my friend who is advocating ML instead?
00:32:11 <_zenon_> edmoore, No problem :) ghci and hugs should be available for mac without extra toppings.
00:32:22 <edmoore> ignore*
00:32:37 <_zenon_> edmoore, Yes, :) no, I don't know. try out both, #haskell is always open for questions and help
00:33:11 <edmoore> _zenon_: yes I was very impressed to see so many people here. I will give this a go and probably be back after work to really get my teeth into this!
00:33:24 <_zenon_> edmoore, Lovely to hear! :)
00:33:49 <edmoore> I have heard good things about 'The Haskell Road to Logic, Maths and Programming'. Do any of you guys rate it?
00:34:28 <_zenon_> haven't read it myself.
00:34:42 <edmoore> I always slightly resented the fact that we, as engineers, never got taught 'proof' in any formal way. I'd quite like to brush up on my maths, and was thinking 2 birds, one stone.
00:34:50 <dibblego> edmoore, yes, excellent book
00:34:50 <codacola> sounds interesting
00:35:03 <edmoore> dibblego: thanks. I'll give it a go.
00:35:21 <edmoore> Gosh, I'm quite excited about another brand new learning curve.
00:35:40 <edmoore> Right, thanks all very much for tipping me over the edge, and oall your other help. I'll be back!
00:35:58 <_zenon_> sure. c u round
00:36:58 <_zenon_> Great :) Another one converted :)
00:45:20 <codacola> _zenon_: thats a good thing?
00:45:26 <Cale> hmm...
00:45:38 <Cale> !paste
00:45:56 <_zenon_> codacola, How could it not be a good thing to expand the Haskell community ?
00:46:08 <Cale> http://hpaste.org/9088
00:46:23 <Cale> anyone have any idea what's going on with haddock/cabal there?
00:46:24 <codacola> more people using haskell :P
00:46:47 <_zenon_> codacola, I am shocked.
00:46:53 <Cale> _zenon_: Well, the more users that a language has, the harder it is to change the language.
00:47:00 <cjs> I have a copy of _Road_, though I've just lent it to someone else at the moment, so I've not read it yet.
00:47:00 <lambdabot> cjs: You have 1 new message. '/msg lambdabot @messages' to read it.
00:47:04 <cjs> (Not much of it.)
00:47:13 <Cale> _zenon_: The most popular languages are also the most stagnant ones.
00:47:20 <Cale> (generally)
00:47:58 <Cale> hmm, maybe my cabal-setup is out of date...
00:47:59 <codacola> well they do kinda. there was c, from there c++, from there java, while the language itself doesnt change new languages tend to come out of them
00:49:09 <Cale> ah, yeah, that was it, cabal-setup was old :)
00:49:57 <codacola> ?
00:50:13 <Cale> (my error message)
00:50:40 <Cale> codacola: That is true. We'll probably end up moving on once Haskell dies from overpopularity :)
00:51:28 <_zenon_> Cale, define stagnant. The set of Java libraries have grown quite a bit, and there is a lot of java library development going on everywhere. I would say it's not stagnant in that sense.
00:51:52 <Cale> _zenon_: not in the sense of libraries, but changes to basic language features
00:52:26 <Cale> The thing I like about Haskell is it's right on the line between being a research language and being a practical language.
00:52:33 <_zenon_> Well. Let go of mathematics then. That has definitively been stagnant :)
00:52:40 <Cale> Not at all.
00:53:35 <Cale> Mathematics has changed drastically over the last 50 years, in notation and foundations while growing out into new areas.
00:54:05 <_zenon_> Please explain how the basic mathematic features have changed drastically ?
00:55:57 <Cale> Well, for one, notation from category theory has made its way into almost every area. The notation f: X -> Y for a function whose domain is X and whose codomain is Y didn't exist 60 years ago.
00:57:11 <Cale> There's been a movement roughly in the direction of modularised separation of foundational layers over the last 50-100 years as well.
00:59:21 <Cale> The overall view has moved from a sort of Platonism, in which mathematical objects really exist in just one way, and our assumptions try to model that, to one where there isn't really just one way for mathematics to be.
01:00:56 <Cale> While most mathematicians still basically use set theory as a foundation, their reliance on the specifics of any one set theory is kept to a minimum, and it's made explicit when certain assumptions are needed that might not apply in all circumstances. (Like applications of the axiom of choice, for instance.)
01:01:25 <Cale> There's also been a movement to construct a foundation for mathematics in terms of category theory.
01:01:51 <Cale> Notation has changed a lot... if you open up a book that's 80 years old or so, it's very strange.
01:02:15 <Cale> I don't know, lots of things have changed, it's hard to summarize :)
01:02:32 <_zenon_> Still haven't changed the way the "end users" apply mathematics. I don't doubt you will find researchers performing small changes to C++ on a theoretical plane. But it's not seen. As for notation, I don't see the distinguish between syntax A, and syntax B is the semantic is the same.
01:02:48 <_zenon_> Maybe mathematics was a bad example.
01:03:16 <_zenon_> My point was that I don't regard syntax rigidity as stagnation.
01:03:40 <Cale> People even experiment with nonstandard logic to some extent. :)
01:03:56 <papermachine> non-monotonic logic++
01:04:15 <_zenon_> Back to the root of the discussion: I don't think it's a problem that _more_ people learn haskell
01:04:37 <Cale> _zenon_: well, perhaps not, but it's already hard to change the Prelude in ways that we very much want to.
01:04:50 <codacola> heh, still discussing it?
01:05:10 <Cale> Anyway, anyone know what would cause Haddock to elide parens from types of functions that it's documenting?
01:05:10 <Yoric[DT]> ugh
01:05:11 <|Steve|> What about Haskell'?
01:05:20 <Yoric[DT]> gasp, wrong channel
01:05:28 <_zenon_> Cale, like GNU/Linux, we'll have to create our own flavours :)
01:05:55 <Cale> |Steve|: There are some changes, but overall it's intended to document current practice.
01:06:09 <_zenon_> Haskell - Experimental , Haskell - Strict , and so on
01:06:19 <Cale> We should fragment the language a bit.
01:07:20 <Cale> (But in a neatly controlled fashion, hopefully :)
01:08:08 <_zenon_> However, the fragmentation in itself must not impose a "threshold" for someone to get going.
01:08:34 <_zenon_> Should still be as easy as getting your local coy of ghci and downloading the packages and getting it on.
01:08:47 <Cale> Haddock is turning:
01:08:48 <Cale> aStar :: (Ord a, Ord c, Num c) => (a -> Set a) -> (a -> a -> c) -> (a -> c) -> (a -> Bool) -> a -> Maybe [a]
01:08:52 <Cale> into:
01:08:56 <Cale> aStar :: (Ord a, Ord c, Num c) => a -> Set a -> a -> a -> c -> a -> c -> a -> Bool -> a -> Maybe [a]
01:10:45 <Cale> hmm...
01:11:18 * Cale tries installing the latest haddock 
01:13:03 <Cale> hmm... nope...
01:13:48 <glguy_> Cale: Does 0.9 work?
01:14:01 <glguy_> 2.0 seems really flakey
01:14:03 <Cale> Haddock 0.9?
01:14:06 <Cale> Ah, okay
01:14:17 <Cale> I've tried 2.0.0.0 and 2.1.0
01:14:56 * Cale builds 0.9
01:15:30 <glguy_> The new haddocks seem to go out of their way to encounter parse errors
01:17:44 <_Dae_> 'mornin'
01:18:50 <_zenon_> _Dae_, "good morning"
01:19:41 <edmoore> So I'm downloading ghc from MacPorts - do I need anything else? Is there an interpreter?
01:19:47 * _Dae_ is about to make a "is that a lambda in your pocket"-joke, but thinks the better of it
01:20:05 <_Dae_> edmoore: I think ghci is included in the ghc pack?
01:20:16 <Cale> edmoore: You shouldn't compile ghc yourself unless you absolutely have to.
01:20:18 <_zenon_> _Dae_, go for it!
01:20:33 <Cale> edmoore: Get the binary package from the GHC website.
01:20:45 <edmoore> Cale: ok
01:20:52 <Cale> edmoore: (It comes with an interactive environment called ghci)
01:21:18 <_Dae_> _zenon_: na, it's below even my standard
01:21:30 <_zenon_> Okay then.
01:22:54 <edmoore> Cale: ok thanks. I'll let macports finish porting readline over, then kill it
01:23:13 <Cale> glguy_: thanks, that fixed it :)
01:24:16 <kig> do you need heap allocations in a pure fp language? i.e. could you stuff everything on the stack and get rid of GC?
01:24:55 <|Steve|> edmoore: There's both a macports and a ghc trac ticket, it can't be compiled on leopard on powerpc right now, but the binary package works.
01:25:05 <|Steve|> There're*
01:25:28 <edmoore> |Steve|: good to know, thanks
01:25:37 <edmoore> I've switched over to d/l'ing the binary
01:26:07 <|Steve|> I wish 1. MP would use binaries and 2. ghc would compile.
01:26:23 <|Steve|> You  know, actually, it compiled just fine on my laptop, just not my desktop.
01:26:24 <Cale> kig: that would be a massive waste of memory, unless I'm missing something
01:26:49 <|Steve|> And you need closures to be in the heap.
01:29:04 <hackage> Uploaded to hackage: astar 0.0
01:33:30 <Cale> dons: Available on hackage as astar now :) http://cale.yi.org/AStar/dist/doc/html/astar/Data-Graph-AStar.html
01:33:31 <lambdabot> Title: Data.Graph.AStar, http://tinyurl.com/69kxsb
01:40:13 <edmoore> Hi |Steve|, build successful. That was suprisingly painless.
01:40:50 <edmoore> so what have I got? ghc and ghci?
01:41:03 <Cale> Oh, so you built ghc? That was fast...
01:41:35 <edmoore> well, make install
01:41:54 <Cale> oh, so perhaps it was pre-built :)
01:42:18 <Cale> Normally it takes hours :)
01:42:39 <edmoore> lol, yes sadly I don't have a cluster available for my own personal cross-compilation
01:42:43 <edmoore> If only.
01:44:26 <edmoore> lame question number1 - how do i exit ghci?
01:44:30 <|Steve|> edmoore: Good to hear.
01:44:36 <edmoore> :q
01:44:36 <_Dae_> edmoore: :q
01:44:37 <edmoore> gottit
01:45:00 <edmoore> i've been so un-vim since switching to textmate. tragic.
01:45:14 <_Dae_> edmoore: now the first thing you'll want to code is a forkbomb....
01:45:40 <edmoore> well the office is quite cold
01:46:04 <_Dae_> both vim and emacs are very valid choices for haskell. There's also an eclispe plugin, but I didn't have much luck with it
01:46:19 <_Dae_> edmoore: I'm not sure a forkbomb would fix that....
01:46:43 <Cale> edmoore: One thing to note is that you should always set your text editor to convert tabs into spaces when editing Haskell code.
01:46:43 <edmoore> _Dae_: using the cpu to warm the place up
01:46:57 <Cale> (almost every editor has such an option :)
01:48:04 <_Dae_> edmoore: heh, you must have an athlonXP then
01:48:17 <edmoore> _Dae_: macbook pro
01:48:32 <edmoore> hits 99 degrees C on any given compile
01:48:48 <_Dae_> edmoore: right... you've only said mac like 20 times... ofcourse you have an athlon *smacks forhead*
01:48:54 <b\6> are people finding vim haskell autoindent stuff ok? seems really bad to me.
01:49:05 <_Dae_> edmoore: that's gotta hurt!
01:49:23 <edmoore> _Dae_: it's not on my lap, thankfully!
01:49:50 <_Dae_> b\6: I am told it can be made to work as well as the emacs one, but I never got that part to work at all.
01:50:07 <_Dae_> edmoore: soo... what are you getting haskell for?
01:50:39 <b\6> editor poll. most people using emacs to edit haskell or what?
01:50:50 <edmoore> _Dae_: I popped on here out of interest this morning with the following q: "If you had to elevator-pitch Haskell to an engineer who thinks c and octave would alone happily get him through life, what would you say?"
01:51:26 <edmoore> And then - "I am that engineer, and I have an itch to get into it, but at the same time I don't have much time to learn a new language unless it's going to help me. I do all sorts, signal proccessing to monte carlo sims of planetary landers to parachute design, so I have quite a braod range of apps that I often program for. I wonder if haskell could help me do something I currently do much better, or let me do something I'd not thought of bec
01:52:03 <edmoore> I've been wanting to try it for some time and I think it'd be good for me. Learning to think in a different way can only be a good thing.
01:52:07 <edmoore> I hope...
01:52:18 <_Dae_> edmoore: hahaha! Awesome.I'm doing quantum mechanics in haskell right now. All I've written in it is numerical stuff :)
01:52:21 <codacola> it can?
01:52:27 <edmoore> So even if there is no immediate application, perhaps I'll think of something!
01:52:50 * codacola wonders if the head banging is part of the "good"
01:53:30 <_Dae_> edmoore: it'll grow on you. I've written haskell for less than 3 months, and I get stuff done much faster than I would in java or c# where I have a couple of years of experience
01:54:45 <edmoore> _Dae_: this is fascinating, exatly what I was hoping might be the case. Do you mind if I ask what sort of stuff precisely, algorithmically, it helps you with?
01:55:20 <edmoore> Or is it just that it lets you do the maths with fewer obstructions?
01:55:59 <_Dae_> edmoore: well, it lets you define what it is you really wanna do, rather than how you wanna do it, which becomes an advantage really quickly
01:56:42 <_Dae_> but that sounded a bit like a buzzwordcontest, so let me rephrase that
01:57:08 <b\6> that wasn't too buzzwordy.
01:57:15 <b\6> focusing on what instead of how.
01:57:18 <b\6> seems right.
01:57:31 <_Dae_> b\6: what instead of how seems like a marketing slogan
01:58:22 <edmoore> b\6: that's exactly what I'm after. It's the 'how' that I always find deeply annoying.
01:59:25 <b\6> edmoore: it's a different way of thinking that seems annoying at first if you're used to imperative programming. for example, i got annoyed at the idea of using recursion in place of loops.
01:59:29 <edmoore> A challenge up to a point, then just a hindrance to achievement.
01:59:38 <_Dae_> but haskell lets you define what you want much faster. Lists are a great example, though it shows almost everywhere
02:00:02 <audreyt> @seen dons
02:00:03 <lambdabot> dons is in #arch-haskell, #xmonad, #ghc and #haskell. I last heard dons speak 4h 4m 53s ago.
02:00:07 <_Dae_> b\6: I find that ofthen when I think I want a loop, what I really want is a list function
02:00:07 <cetin> hi all... is there a function in base libs that has this signature, f :: [a -> b] -> [a] -> [b]?
02:00:39 <_Dae_> cetin: no, pretty sure there isn't
02:00:50 <b\6> _Dae_: yeah, me too. now that i'm used to it.
02:00:58 <b\6> and now i think it's better. but there's a hump to get over.
02:01:21 <_zenon_> _Dae_, I think one of the Haskell flag ships  should be the ease of defining Algebraic datastructures
02:01:27 <_zenon_> and polymorphic types
02:01:30 <cetin> _Dae_: thanks
02:01:30 <_Dae_> cetin: I guess you could make one out of zipWith and a custom function?
02:02:02 <cetin> _Dae_: yep, I will go with that just didn't want to have a duplicate of something that might already exist
02:02:21 <_Dae_> _zenon_: that's not really that easy.... or isn't for me anyway. Prelude math isn't very good
02:02:39 <cetin> _Dae_: have to log off, in the middle of lecture... thanks again! *^o^*
02:03:32 <Lemmih> ?type zipWith ($)
02:03:33 <lambdabot> forall a b. [a -> b] -> [a] -> [b]
02:03:52 <_Dae_> ohhh phoey....
02:04:07 <_Dae_> what I said was -almost- true then
02:05:17 <_zenon_> _Dae_, http://en.wikipedia.org/wiki/Algebraic_data_types ?
02:05:18 <lambdabot> Title: Algebraic data type - Wikipedia, the free encyclopedia
02:05:33 <_zenon_> I meant type :)
02:06:56 <_Dae_> _zenon_: oohh.... right on. Seems like I need to take more CS courses. Haskell is brilliant at that
02:08:06 <_zenon_> _Dae_, In the name of the truth, I <did> say "Algebraic datastructure" although I am quite sure the correct name is "algebraic datatype", so I understand that I confused you.
02:08:36 <edmoore> _Dae_ : I'll stick with it. I have 'The Haskell Road to Logic, Math and Programming' open next to a ghci window. So I'll look forward to getting stuck in
02:09:00 <edmoore> Right now I've got to model some hideos rubbish for a mars lander.
02:09:14 <Feuerbach> I have strange autoreconf warnings and compile error while trying to build ghc, can somebody look please? http://hpaste.org/9089#a0
02:09:39 <_Dae_> edmoore: ohh? as in you're working for Nasa, or?
02:10:04 <edmoore> ExoMars (europe) for a subcontractor
02:10:08 <edmoore> vorticity systems
02:10:09 <_zenon_> edmoore, I recommended the Haskell Wiki book! Have you abandoned me? :)
02:10:16 <edmoore> it's summer work (I'm a student)
02:10:24 <edmoore> _zenon_: no I will read that too!
02:10:36 <edmoore> I'll go through that before bashing the maths
02:10:37 <_zenon_> okay :)
02:12:43 <bonobo> hi
02:12:47 <edmoore> Which is all c++ and netcdf. Dirty.
02:12:54 <_Dae_> edmoore: I think I know one of the geologists working on that...
02:12:54 <bonobo> a question about Monoid
02:13:13 <edmoore> _Dae_: I hope the thing lands in one peice then!
02:13:20 <bonobo> am I right that Monoid [a] instance has quadratic behaviour?
02:14:08 <_Dae_> edmoore: pft! I'm a physicist. If it crashes they should've use bigger thrusters
02:14:21 <_zenon_> :)
02:14:48 <edmoore> _Dae_: if it crashes they should have used a different prime subcontractor
02:15:02 <edmoore> but that's politics :P
02:15:40 <_Dae_> heh, true that. well, I'm sure the QA team will be taking the garbage anyway
02:15:45 <_zenon_> should have landed on a different rock.
02:16:29 <edmoore> _zenon_: heh, next to me Matt is working on sims of the airbag system landing on a catalogue of hundreds of different rocks.
02:17:11 <_zenon_> :)
02:18:17 <_Dae_> airbags? Really? I thought they would be doing a parchust + thruster combo
02:19:29 <edmoore> _Dae_: parachutes + thruster + airbags
02:19:31 <_Dae_> that was supposed to have been "parachute"
02:19:47 <edmoore> Oh no, that went out the window
02:19:51 <_Dae_> edmoore: ohh, ofcourse! So as not to injure the marsmen
02:19:57 <edmoore> Exactly
02:20:02 <edmoore> Think of the insurance
02:20:25 <edmoore> They're landing a bit higher than usual too, i think, so they need all the extra deltaV they can get
02:20:48 <_Dae_> yeah... and then they'll be sending their tripod-robots against us and we'd have to find a virus to kill 'em off
02:21:50 <edmoore> The airbags are untried in landers - they're vented rather than bouncy
02:21:55 <_Dae_> edmoore: probably smart to do it as a part of virgil: http://www.google.com/virgle/
02:21:56 <lambdabot> Title: Virgle: The Adventure of Many Lifetimes
02:22:18 <edmoore> so the values are controlled to blow by the flight computer to give it a level and soft touchdown
02:22:55 <edmoore> so the theory goes
02:23:04 <edmoore> anyway, this is probably a bit OT for a haskell channel
02:23:08 <edmoore> !
02:23:11 <_Dae_> naaah!
02:23:33 <_zenon_> :)
02:23:42 <edmoore> Unless someone's trying to re-write LS-DYNA in haskell
02:24:01 <edmoore> which would be the task of more lifetimes than virgle, I suspect
02:27:30 <_Dae_> well... looks like a solid weeks work
02:30:24 <edmoore> _Dae_: so what sort of research do you do?
02:30:33 <edmoore> Within the field of QM?
02:31:07 <_Dae_> well... I'm a student, so..... few boyd systems mainly
02:31:13 <_Dae_> *few-body
02:31:29 <taruti> Has anyone implemented parsec-like parser in the Data.Binary.Get monad?
02:31:35 <taruti> +a
02:32:04 <edmoore> _Dae_: ah student aswell. I'm reasonably happy that way.
02:32:43 <_Dae_> edmoore: being a student?
02:32:46 <edmoore> yeah
02:32:51 <edmoore> for the time being.
02:33:08 <_Dae_> taruti: not that I know of
02:33:25 <_Dae_> edmoore: well, you have to crawl before you can walk :p
02:33:57 <edmoore> This is true!
02:34:18 <edmoore> IRC + sims each taking 10 mins means a terribly productive/unproductive day.
02:34:22 <_zenon_> You have to lisp before you smalltalk :)
02:34:41 <_zenon_> haha, nope, just funny.
02:37:59 <edmoore> Taxi!
02:44:19 <_zenon_> edmoore, you should get back to work
02:44:23 <_zenon_> as should I
02:44:32 <edmoore> :p
02:45:02 <edmoore> Yes probably. Thanks for all your help, chaps.
02:45:16 <edmoore> (_zenon_, I was only teasing! )
02:49:43 <_zenon_> Wtf! Someone took my pencil
02:49:55 <^Someone^> No, I did not :|
02:50:29 <_zenon_> :P I was here on my desk. Now it's not there
02:51:01 <_zenon_> Of course the only conclusion I may draw is has been displaced from my desk.
02:59:33 <_Dae_> quantum pencil..... it's only there sometimes
03:00:16 <Axman6> sounds like something that'd fir right into haskell
03:00:51 <_Dae_> MabyeMonadPencil
03:00:59 <_Dae_> Maybe....
03:09:47 * _zenon_ goes for lunch
03:14:01 <jamii_> Haskell puzzle of the day:
03:14:27 <jamii_> How do you test the difference between foldl and foldl' without looking inside them?
03:15:53 <matthew-_> memory use should be static with foldl' but will be linear in the length of the list with foldl, I think
03:16:10 <jamii_> matthew: Kind of hard to test with QuickCheck...
03:16:31 <matthew-_> true
03:16:43 <jamii_> Im writing QuickCheck tests for a map class that has foldAsc and foldAsc'
03:16:43 <matthew-_> foldl' could well be faster
03:17:20 <_Dae_> jamii_: well, they should be the same,s houldn't they?
03:17:32 <jamii_> I cant work out how to test strictness for folds. For insert and insert' I insert bottom and then see where the exception pops up
03:17:34 <matthew-_> ahh!
03:17:36 <therp> probably with some ghc specific tricks
03:17:52 <therp> jamii_: there are some GHC tricks to catch "undefined"
03:17:58 <opqdonut> jamii_: yeah i'm thinking of a totalness solution
03:18:23 <jamii_> therp: Thats what Ive used for other tests but its difficult to create a test that works for fold
03:18:28 <matthew-_> if you foldl' where each elem of the list is infinite and the operation in the foldl' does a show then it shouldn't terminate
03:19:44 <matthew-_> foldl' (\acc e -> acc ++ (show e)) [] [repeat 'a']
03:20:10 <jamii_> matthew: foldl (++) vs foldl' (++). That would work for maps whose elements are lists. Unfortunately I need the tests to work for any element type which is way I was angling at bottoms
03:21:42 <jamii_> as a comparison this is what some of my other tests look like:
03:22:00 <jamii_> http://hpaste.org/9090
03:22:43 <jamii_> But folds are trickier. For a start I think lazy and strict folds are identical on empty or singleton lists
03:24:00 <jamii_> I need to be polymorphic in keys and elements so I cant even control what order the list goes in.
03:24:04 <jamii_> Damn tricky
03:24:57 <opqdonut> why do you even need to do this?
03:25:09 <opqdonut> ah, read the backlog
03:25:13 <jamii_> opqdonut: Writing a testsuite for a class
03:25:28 <jamii_> Big testsuite, because some of the instances are really hairy
03:25:38 <jamii_> 3000 lines of avl trees in one of them
03:26:06 <opqdonut> wow :O
03:26:19 <opqdonut> i did AA trees in sub-100 lines
03:26:36 <opqdonut> but that was a naive implementation
03:26:52 <jamii_> this is seriously optimised. trying to be faster than Data.Map
03:26:57 <jamii_> * Data.IntMap
03:27:05 <opqdonut> yeah
03:28:17 <jamii_> also, ~100 methods in the class. That never makes for small implementations
03:29:04 <hackage> Uploaded to hackage: hscolour 1.10
03:31:46 <lilachaze> jamii_:
03:31:50 <lilachaze> > foldl (flip const) 0 (undefined:[1..5])
03:31:51 <lambdabot>  5
03:31:53 <lilachaze> > foldl' (flip const) 0 (undefined:[1..5])
03:31:54 <lambdabot>  Exception: Prelude.undefined
03:35:33 <lilachaze> if you want it to work for empty lists too, you can change the last argument to (u1:u2:originalList), where u1 and u2 throw different exceptions. foldl' will always evaluate u1 first, whereas foldl will never evaluate u1.
03:37:11 <jamii_> lilachaze: I cant control what order the list elems are in, so I cant put undefined at the befinning
03:37:33 <jamii_> But I can modify your idea to foldl' (\ x y -> if isBottom x then 1 else if x == 0 then bottom else 1) 0 [1,2]
03:38:15 <jamii_> Which does roughly the same thing, for any list with more than one elem.
03:38:26 <jamii_> Thanks. Thats a neat solution.
03:38:28 <lilachaze> yep. you still have a problem for empty lists tho.
03:38:45 <jamii_> I can put things into the list first. I just cant put them in a specific place
03:38:56 <jamii_> So I stick 2 things in and then run the test
03:39:41 <lilachaze> glad i could help :)
03:42:27 <FordCortina> are there any other good papers on programming with multiparameter type classes, besides "Faking it" by McBride?
03:44:30 <FordCortina> i get the impression they werent put into haskell to simulate dependent types :)
03:47:04 <Philippa> FordCortina: the original papers introducing them, functional dependencies etc?
03:47:27 <Philippa> that's about the best you'll get though. The usual example is a 'container' class parameterised both on container and element type so that containers don't have to be polymorphic
03:48:21 <FordCortina> Philippa: thanks. maybe I'll take another look at them. maybe they'll be more helpful on a 2nd reading :)
03:59:11 <kriomant> I have tree "tree :: [Elem]" where "Elem { name: String; subElems: [Elem] }" and "path :: [String]" in this tree, what is the most haskell-ish method to get longest sequence of elements "[Elem]" corresponding to path? I coded http://hpaste.org/9091, but it seems too long.
04:01:52 <opqdonut> kriomant: use the list monad to keep track of choices
04:02:55 <opqdonut> somethign like "f (n:rest) choices = choices >>= filter something . subElems >>= f rest"
04:03:25 <opqdonut> where something checks that a subelement is valid
04:04:00 <opqdonut> then you need some way to decide when to stop
04:04:05 <kriomant> this is confusing, since there is only one element of given name in subElems
04:04:53 <opqdonut> perhaps you should use a map then?
04:05:56 <opqdonut> if there's maximally one choice then put that into the maybe monad by adding "listToMaybe ." before filter
04:05:57 <kriomant> perhaps, but then 'find ... subElems' will turn into 'Map.lookup ... subElems', no more
04:06:18 <Botje> look at unfoldr?
04:06:29 <opqdonut> yeah, this might be an unfold
04:06:31 <kriomant> @type unfoldr
04:06:31 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
04:06:34 <opqdonut> actually, it is
04:06:35 <opqdonut> yes
04:06:46 <opqdonut> you unfold a path into a list of elems
04:07:32 * kriomant is coding getElems4 using unfoldr...
04:10:07 <Botje> let f ([],_) = Nothing; f (x:xs,e) = find ((==x).name) (subElems e) >>= \e' -> return (e,(xs,e')) in unfoldr f ...
04:10:11 <Botje> i think
04:14:21 <kriomant> unfoldr (\(elems, n:rest) -> find ((==n) . name) elems >>= (\e -> return (e, (subElems e, rest)))) (tree, path)
04:15:06 <kriomant> good, tnx all
04:15:20 <Botje> you still need a case for when the second element is an empty list
04:15:22 <Botje> but okay :)
04:15:37 <kriomant> hmm... yes, of course :)
04:36:10 <kriomant> I have 'path :: [String]' and want to get full path for each path component 'paths :: [[String]]', say for ["a", "b", "c"] I want to get [["a"], ["a", "b"], ["a", "b", "c"]]. Now I use "map reverse $ tail $ scanl (flip (:)) [] path", is there better?
04:36:51 <roconnor> > inits ["a", "b", "c"]
04:36:52 <lambdabot>  [[],["a"],["a","b"],["a","b","c"]]
04:37:14 <roconnor> > (tail . inits) ["a", "b", "c"]
04:37:15 <lambdabot>  [["a"],["a","b"],["a","b","c"]]
04:37:18 <kriomant> :-) so simple
04:37:22 <kriomant> tnx
04:37:25 <roconnor> :)
04:41:57 <Botje> @src inits
04:41:57 <lambdabot> inits []     =  [[]]
04:41:57 <lambdabot> inits (x:xs) =  [[]] ++ map (x:) (inits xs)
04:42:10 <Botje> heheh
05:03:56 <macron> hi, anyone know where I can find the 'base' library for ghc-current? It's not included in the nightlies anymore.
05:06:09 <SamB> macron: that could be a bug...
05:06:16 <SamB> Igloo: do you know anything about this?
05:06:33 <SamB> (if he doesn't, it's probably a bug ;-)
05:07:57 <Igloo> What do you mean by "the nightlies"?
05:08:18 <macron> Igloo: i mean the snapshots on haskell.org
05:08:29 <Igloo> The source tarballs, or what?
05:08:50 <macron> Igloo: the binary tarballs, x86_64-linux and so on
05:09:20 <Igloo> OK, the bindists are broken at the moment
05:09:42 <Igloo> Although I'm a bit surprised that base is missing
05:10:49 <macron> Igloo: it's been missing since about the april snapshots, AFAICT. It's causing the install to fail actually.
05:11:17 <macron> Igloo: there is a message on ghc-users by Tom Cody where he sees the exact same install failure as me, which is due to base missing.
05:12:18 <macron> Igloo: any idea when the bindists will be working again?
05:12:31 <FordCortina> if you made a parser that used (>>=), return, mempty and mplus why would you need the functions from Applicative and Alternative?
05:13:08 <FordCortina> is it just a matter of have some nice infix operators or am i missing something?
05:13:28 <Igloo> macron: Within a week or two, I hope
05:13:53 <FordCortina> having*
05:14:08 <macron> Igloo: ok, thanks.
05:14:19 <macron> Igloo: should I log a bug about this to keep track?
05:14:39 <FordCortina> if you made a parser combinator library*
05:14:50 <Igloo> If you like
05:16:01 <Philippa> FordCortina: it'd let code that just wants to treat it as an Applicative work. In particular, you could newtype an applicative subset, and applicatives have different properties to monads - they're easier to analyse, for example
05:16:38 <Philippa> (the interesting part there is "chunk x of my parser is all Applicative")
05:16:52 <Philippa> aside from that, some people'll just want to work in an applicative manner and then it's convenient not to have to write the instance yourself
05:17:56 <FordCortina> Philippa: thanks
05:27:26 <BeelsebobWork> anyone know if it's possible to see the parts of a string that a parsec parser didn't consume?
05:27:43 <FordCortina> @src ap
05:27:43 <lambdabot> ap = liftM2 id
05:27:55 <FordCortina> @src liftM2 id
05:27:56 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
05:27:58 <FordCortina> @src liftM2
05:27:58 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
05:28:11 <vixey> :t liftM2 either ?p (many anyChar)
05:28:13 <lambdabot> Not in scope: `anyChar'
05:28:26 <vixey> hmmm
05:28:27 <FordCortina> :t liftM2
05:28:28 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
05:28:43 <vixey> Beelsebob: I'd make a parser that takes a parser and returns a tuple
05:28:55 <BeelsebobWork> vixey: oh, that's a nice idea
05:28:59 <BeelsebobWork> cheers
05:29:51 <vixey> something like \p -> liftM2 (,) p (many anyChar)
05:31:09 <byorgey> first-class functions and combinator libraries FTW!
05:31:36 <BeelsebobWork> indeed
05:34:45 <gianny> Hello. I am learning Haskell and I would like to know which Haskell IDE is the best one these days. I am on Mac OS X with ghc. I am currently using VIM. Thanks..
05:34:53 <Baughn> gianny: Oh, emacs
05:35:08 <Baughn> Don't worry. Vim works too. ^_^
05:35:31 <gianny> Baughn: thanks. Is it better than vim with the haskell plugin?
05:35:43 <Baughn> gianny: I don't use vim. I couldn't say.
05:35:59 <vixey> gianny: I use emacs & ghci..
05:36:18 <kryptiskt> gianny: there's eclipsefp if you like eclipse
05:36:25 <vixey> gianny: I don't use more than copy and paste .. so I don't think emacs is major advantage over vim
05:37:55 <ToRA> vim + claus' bindings i find works very nicely
05:38:13 <roconnor> what are take and drop called in Ocaml?
05:38:31 <gianny> I tried eclipsefp and at this stage I prefer vim. I will give a shot to emacs. Thanks all!
05:38:37 <ToRA> gianny: http://www.cs.kent.ac.uk/people/staff/cr3/toolbox/haskell/Vim/
05:38:38 <lambdabot> Title: Haskell mode for Vim
05:39:07 <vixey> take and drop.. once you write them :P
05:39:41 <roconnor> :)
05:39:56 <vixey> (don't think they are in the core library)
05:40:44 <roconnor> ok
05:44:48 <vixey> Is it wrong to use a typeclass just because I want to have several functions with the same name?
05:48:19 <roconnor> nope
05:48:28 <roconnor> that is the whole motivation for type classes. :)
05:49:00 <roconnor> I have a multi parameter typeclass for <*> :: a -> b -> c
05:49:10 <roconnor> in case I ever want to multiply anything
05:50:11 <Philippa> heh, so that's why you're pissed off by Applicatives grabbing the token :-)
05:50:51 <roconnor> screw applicative
05:50:59 <roconnor> and their crappy operator
05:51:02 <twanvl> vixey: it depends on what the functions do, if they do the 'same thing' for different types, then use a type class, but if they do different things you should use different names.  I.e.  show :: Int -> String, show :: Float -> String -- use a typeclass.  but  run :: Runner -> Track -> LapTime, run :: FilePath -> IO () -- use different names
05:51:31 <roconnor> well
05:51:35 <roconnor> their crappy operator name
05:53:58 * vixey wishes to name functions [[ • ]]
05:54:34 <EvilTerran> i think you can in one of the dependently typed languages
05:54:34 <BeelsebobWork> hehe, semantic brackets would be cool
05:55:04 * vixey maybe should be writing LaTeX instead of programs :p
05:55:09 <BeelsebobWork> if you could use [[ and ]] as infix operators you could actually do them
05:55:37 <BeelsebobWork> or actually, as prefix would work better
05:55:57 <kriomant> is there a more convenient way to update record fields than "record { field = func field}"? now I just create functions like "updateField :: (FieldT -> FieldT) -> RecordT -> RecordT", but it is boring. I can automate this using Template Haskell, but maybe there is a better way?
05:56:00 <vixey> I saw Ii .. iI
05:56:02 <BeelsebobWork> ]] would be id on semanticses, and [[ would be flip ($)
05:56:02 <vixey> somewhere
05:56:31 <roconnor> @wiki Idiom brackets
05:56:31 <lambdabot> http://www.haskell.org/haskellwiki/Idiom_brackets
05:57:17 <roconnor> iI f x y Ii = f <$> x <*> y
05:58:03 <EvilTerran> kriomant, sadly not
05:58:21 <EvilTerran> kriomant, that's one of the things no-one likes about the record system
05:58:38 <EvilTerran> but the design space of "record systems" is too big for us to come to an agreement about what to replace it with
05:58:46 <kriomant> EvilTerran: :-( I like to play with Haskell, but it's records are just Terrible!
05:58:47 <EvilTerran> there's no obvious local optimum
05:58:53 <BeelsebobWork> > let il = flip ($); li = id; m 1 = 5; m n = 6 in il 5 li m
05:58:55 <lambdabot>        add an instance declaration for (Num ((t -> t1) -> a))
05:58:56 <EvilTerran> ?go oleg hlist
05:58:56 <lambdabot> No Result Found.
05:59:01 <vixey> kriomat: yeah records are a bit rubbish
05:59:18 <BeelsebobWork> oh, I see why
05:59:19 <BeelsebobWork> that's lame
05:59:26 <BeelsebobWork> > let il = flip ($); li = id; m 1 = 5; m n = 6 in il 5 (li m)
05:59:27 <lambdabot>  6
05:59:29 <vixey> kriomat: I saw a funny trick you can do though,  f (Constructor {}) = True, instead of f (Constructor _ _ _ _ _ _) = True
05:59:44 <EvilTerran> kriomant, have a look at Oleg's heterogenous list paper -- he's implemented something kinda like extensible records in ghc
05:59:56 <EvilTerran> kriomant, it's very dense type wrangling, mind
06:00:09 <EvilTerran> vixey, you don't even need the parentheses around Constructor{}
06:00:17 <vixey> oh cool
06:00:32 <kriomant> EvilTerran: but are these extensible records compatible with Haskell's ones?
06:00:47 <EvilTerran> kriomant, no, you'd use them in place of the built-in ones
06:01:10 <kriomant> EvilTerran: than it isn't a case...
06:01:32 <kriomant> and are there any proposals for record system so I can read them and vote for some?
06:01:41 <EvilTerran> pardon?
06:02:20 <EvilTerran> there are proposals floating around, but i don't think any of them have made their way onto the haskell' thingamabob
06:03:25 <EvilTerran> kriomant, the point of oleg's type-indexed lists is that they provide what's effectively a record system with odd syntax by doing clever trickery with the type system as extended by ghc. it's fundamentally different to the {}-style records.
06:07:11 <kriomant> EvilTerran: I'll read about this, but now I have to work with old code which uses records
06:08:23 <EvilTerran> ok
06:08:34 <EvilTerran> HList's mostly a curiosity, really
06:08:38 <EvilTerran> to prove it can be done
06:12:34 <andun> http://twan.home.fmf.nl/blog/haskell/overloading-functional-references.details
06:12:36 <lambdabot> Title: Overloading functional references - 21 thoughts, http://tinyurl.com/2ustba
06:29:32 <Choko> how can i define (!) = neg so it's possible to write ! a instead of (!) a
06:30:30 <Toxaris> Choko: you cannot
06:30:30 <lambdabot> Toxaris: You have 1 new message. '/msg lambdabot @messages' to read it.
06:30:42 <|Steve|> I don't believe you can. I think Haskell considers all symbols to be infix operators.
06:30:56 <EvilTerran> indeed
06:32:53 <Toxaris> > let x = 5 in -x -- not that easy, |Steve|
06:32:57 <lambdabot>  -5
06:33:14 <Choko> thats sad :(
06:33:24 <EvilTerran> unary - does not exist to me
06:33:29 <EvilTerran> >:(
06:33:31 <Toxaris> but the unary - is beyond redefinition
06:33:56 <EvilTerran> Toxaris, well, with -XNoImplicitPrelude, i think it explicitly desugars to the definition of "negate" that's in scope
06:34:14 <Toxaris> EvilTerran: oh interesting.
06:34:36 <|Steve|> Toxaris: Good example.
06:35:03 <Toxaris> EvilTerran: so with class Negate a where negate :: a -> a, we could make -True = False work :)
06:35:22 <Toxaris> and -(-4) = 4 at the same time
06:35:25 <EvilTerran> yep
06:35:31 <EvilTerran> > -(-4)
06:35:32 <lambdabot>  4
06:35:58 <|Steve|> @type (-4)
06:35:58 <lambdabot> forall a. (Num a) => a
06:36:05 <EvilTerran> but, yes, I'm pretty sure you could have a generalised negation
06:36:20 <|Steve|> @type (+ negate 4)
06:36:21 <lambdabot> forall a. (Num a) => a -> a
06:36:29 <|Steve|> @type (+ -4)
06:36:30 <lambdabot>     The operator `+' [infixl 6] of a section
06:36:30 <lambdabot>         must have lower precedence than the operand prefix `-' [infixl 6]
06:36:30 <lambdabot>         in the section: `(+ - 4)'
06:36:43 <EvilTerran> @type (-4+)
06:36:43 <lambdabot> forall a. (Num a) => a -> a
06:36:54 <|Steve|> lame.
06:37:06 <idnar> heh
06:37:14 <Toxaris> > (-4+) 17
06:37:15 <lambdabot>  13
06:37:28 <Toxaris> cool workaround for (-4) 17
06:37:32 <EvilTerran> yeah
06:37:44 <EvilTerran> > (subtract 4) 17 -- is the "official" way
06:37:45 <lambdabot>  13
06:37:56 <EvilTerran> > subtract x y
06:37:58 <lambdabot>  y - x
06:38:14 <|Steve|> Why didn't it complain about unbound identifiers or something?
06:38:18 <Toxaris> In 99% of the use cases, one wants (- 1) and can use (pred)
06:38:30 <|Steve|> @type pred
06:38:31 <lambdabot> forall a. (Enum a) => a -> a
06:38:34 <EvilTerran> |Steve|, because lambdabot is using something called SimpleReflect
06:38:36 <Toxaris> |Steve|: deep magic in lambdabot
06:38:49 <EvilTerran> which involves having top-level bindings for all the letters
06:38:51 <EvilTerran> ?type x
06:38:52 <lambdabot> Expr
06:38:54 <EvilTerran> ?type f
06:38:54 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
06:39:01 <EvilTerran> > f x :: Expr
06:39:03 <lambdabot>  f x
06:39:13 <EvilTerran> > foldr f e [a,b,c,d] :: Expr
06:39:15 <lambdabot>  f a (f b (f c (f d e)))
06:39:25 <|Steve|> Neat.
06:39:26 <EvilTerran> ?where simplereflect
06:39:26 <lambdabot> http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
06:39:37 <EvilTerran> > foldl f e [a,b,c,d] :: Expr
06:39:38 <lambdabot>  f (f (f (f e a) b) c) d
06:39:59 <Toxaris> > [f, g] <*> [x, y]
06:40:00 <lambdabot>  Add a type signature
06:40:06 <Toxaris> :(
06:40:11 <|Steve|> What is <*>?
06:40:15 <Toxaris> why are my uses never working :(
06:40:23 <Axman6> @type <*>
06:40:24 <lambdabot> parse error on input `<*>'
06:40:28 <|Steve|> @type (<*>)
06:40:29 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
06:40:30 <Axman6> @type (<*>)
06:40:31 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
06:40:54 <Toxaris> > [succ, pred] <*> [10, 20, 30]
06:40:55 <lambdabot>  [11,21,31,9,19,29]
06:42:01 <Toxaris> <*> composes two actions by executing the left action to get a function, executing the right action to get an argument, and returning the result of applying the function to the argument
06:42:02 <|Steve|> Amazingly enough, I think I actually understand how that works.
06:42:23 <Toxaris> for the case of lists, that means applying every function from the left to every argument from the right
06:43:22 <Toxaris> one can write many uses of >>= with <*>, both more concise and more general (since <*> is supported by more types then >>=)
06:44:12 <Toxaris> > [f, g] <*> [x, y] :: [Expr]
06:44:13 <lambdabot>  [f x,f y,g x,g y]
06:44:46 <Toxaris> > ZipList [f, g] <*> ZipList [x, y] :: ZipList Expr
06:44:47 <lambdabot>   add an instance declaration for (Show (ZipList Expr))
06:45:06 <|Steve|> > [f, g] >>= [x, y] :: [Expr] -- Will this work?
06:45:07 <lambdabot>  Couldn't match expected type `a -> [Expr]'
06:45:26 <Toxaris> getZipList (ZipList [f, g] <*> ZipList [x, y]) :: [Expr]
06:45:28 <Toxaris> > getZipList (ZipList [f, g] <*> ZipList [x, y]) :: [Expr]
06:45:29 <lambdabot>  [f x,g y]
06:45:52 <Toxaris> |Steve|: note the type of >>=
06:46:35 <Toxaris> > [f, g] >>= \fun -> [x, y] -> \arg -> return (fun arg) :: [Expr]
06:46:35 <lambdabot>  Parse error at "->" (column 27)
06:46:48 <|Steve|> Ah right.
06:46:51 <Toxaris> > [f, g] >>= (\fun -> [x, y] -> (\arg -> return (fun arg))) :: [Expr]
06:46:51 <lambdabot>  Parse error at "->" (column 28)
06:47:05 * EvilTerran wonders why ZipList doesn't derive Show
06:47:34 <Toxaris> > [f, g] >>= (\fun -> [x, y] >>= (\arg ->return (fun arg))) :: [Expr]
06:47:36 <lambdabot>  [f x,f y,g x,g y]
06:47:39 <Toxaris> there it is
06:47:55 <|Steve|> Yeah, that makes sense.
06:47:58 <Toxaris> EvilTerran: Is ZipList intendend for real use?
06:48:07 <|Steve|> @kind ZipList
06:48:08 <lambdabot> * -> *
06:48:20 <Toxaris> EvilTerran: I see it as the witness for "there are more Applicative then Monad instances"
06:48:27 <EvilTerran> guess so
06:48:49 * EvilTerran wishes there was a better way of doing that
06:48:56 <|Steve|> Okay, I've gotta sleep. It's nearly 7 am and I've got a lot to do tomorrow.
06:49:01 <|Steve|> er, today
06:57:52 <ndmitchell> thorkilnaur: perhaps you could clear up the confusion on http://en.wikipedia.org/wiki/Talk:Peter_Naur
06:57:52 <lambdabot> Title: Talk:Peter Naur - Wikipedia, the free encyclopedia
06:58:05 <__pao___> anyone can suggest a good ffi/ hsc2hs tutorial?
06:58:42 <__pao___> ... or confirm, there is NO comprehensive FFI/hsc2hs tutorial ... :-)
07:00:15 <Jedai> @oeis 146, 32, 256, 31, 248, 24
07:00:21 <lambdabot> Sequence not found.
07:00:36 <Jedai> @oeis 1, 2, 4, 8
07:00:36 <lambdabot> Powers of 2: a(n) = 2^n.
07:00:36 <lambdabot> [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,26...
07:03:51 <dolio> Is the Real World Haskell sample chapter on the FFI out yet?
07:04:04 <__pao___> dolio: nope :-(
07:07:27 <yango> @oeis 1, 1, 2, 3, 5
07:07:28 <lambdabot> Fibonacci numbers: F(n) = F(n-1) + F(n-2), F(0) = 0, F(1) = 1, F(2) = 1, ...
07:07:28 <lambdabot> [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
07:11:27 <Svrog> __pao___: there isn't much to hsc2hs really, the documentation in the ghc user guide pretty much sums it up
07:12:02 <Svrog> http://www.haskell.org/ghc/docs/latest/html/users_guide/hsc2hs.html
07:12:03 <lambdabot> Title: 11.3. Writing Haskell interfaces to C code: hsc2hs, http://tinyurl.com/397xrd
07:12:05 <__pao___> Svrog: I gave a look but the ghc ffi seems more a reference than a tutorial...
07:12:19 <Svrog> yeah true
07:12:31 <Svrog> there are some tutorials on the wiki
07:12:37 <kalven> Is Real World Haskell going to include a chapter on how to efficiently generate the fibonachi sequence?
07:12:53 <Svrog> http://www.haskell.org/haskellwiki/FFICookBook
07:12:57 <lambdabot> Title: FFI cook book - HaskellWiki
07:12:58 <ndmitchell> kalven: me thinks it may have been covered sufficiently already
07:13:13 <kalven> I hear you
07:13:45 * ndmitchell still wants to revisit it with supercompilation
07:14:34 <__pao___> Svrog: thanks
07:14:42 <Svrog> np
07:20:05 <BeelsebobWork> quicksilver: do you happen to know how to use HOpenGL to set material properties?
07:31:57 <frevidar> whats a "prescan"?
07:32:07 <frevidar> as opposed to a normal scan?
07:32:29 <frevidar> "* Prescans are often more useful for array programming than scans."
07:32:39 <frevidar> - Parr library
07:33:53 <Philippa> frevidar: I imagine they're a generalisation of scans, in the same sense that preorders generalise orders
07:34:10 <Philippa> google's not being overly helpful in finding an actual definition though
07:34:48 <Axman6> is there an easy way of creating an Int out of a few other ints? (2,3,4 -> 234)
07:35:41 <Deewiant> > read (concatMap show [2,3,4]) :: Int
07:35:42 <lambdabot>  234
07:36:23 <EvilTerran> > foldl ((+).(10*)) 0 [2,3,4]
07:36:24 <lambdabot>  234
07:36:34 <frevidar> > zipWith (*) (iterate (*10) 1) [2,3,4]
07:36:35 <lambdabot>  [2,30,400]
07:36:42 <frevidar> > sum $ zipWith (*) (iterate (*10) 1) [2,3,4]
07:36:45 <lambdabot>  432
07:36:56 <frevidar> > sum $ zipWith (*) (iterate (*10) 1) $ reverse [2,3,4]
07:36:57 <lambdabot>  234
07:37:01 <frevidar> got there in the end
07:37:05 <BMeph> Hm, you'd think unfoldr would be a natural for this...but it's almost never used. Why is that?
07:37:19 <EvilTerran> BMeph, for what?
07:37:28 <Axman6> Deewiant: yours seems clearest to me
07:37:29 <EvilTerran> here we're folding a list, not unfolding
07:37:44 <EvilTerran> > foldl (\x d -> 10*x + d) 0 [2,3,4
07:37:45 <lambdabot>  Parse error at end of input
07:37:50 <EvilTerran> > foldl (\x d -> 10*x + d) 0 [2,3,4] -- is how i'd write it really
07:37:51 <lambdabot>  234
07:37:52 <Deewiant> Axman6: it's simplest, probably, but if you need performance at all I'd go with EvilTerran's
07:45:51 <shepheb> what would be the best GHC binary version to use to compile GHC 6.6? 6.6.1 itself?
07:46:16 <Jedai> shepheb: the HEAD probably, no ?
07:46:56 <pejo> shepheb, it rebuilds itself, so anything that passes stage1 should work
07:46:58 <Jedai> It shouldn't matter I think, there's a bootstrapping phase anyway, so at best you may hope to compile the stage1 compiler fester
07:47:10 <Jedai> s/fester/faster/
07:47:38 <shepheb> fair enough. I'll try with my stock 6.8.2 then
07:49:28 <seliopou> I love it when my stage1 compiler festers
07:50:00 <Jedai> seliopou: Me neither ! :P
07:51:27 <allbery_b> 6.4.2, 6.6, 6.6.1 should be well tested
07:51:33 <allbery_b> for rebuilding a 6.6 series
08:14:10 <shepheb> hmm. building 6.6.1 with 6.8.2 failed because it couldn't load System.Directory.Internals. is this because directory was split from base with the move from 6.6 to 6.8?
08:16:41 <Igloo> Building older versions with newer releases isn't supported
08:17:21 <shepheb> Igloo: see, that's what I'd have guessed, but asking produced no one saying otherwise.
08:17:34 <shepheb> no one saying it wasn't supported, I mean
08:18:02 <shepheb> I seem to recall running into trouble for having too new a gcc last time I tried building 6.6.1 with 6.6.1
08:24:52 <lispy> So what is the rule then?  Build new versions with older releases?
08:25:57 <tromp> > 0777
08:26:01 <lambdabot>  777
08:27:44 <lispy> > 007
08:27:45 <lambdabot>  7
08:27:56 <saml> > 0b111
08:27:57 <lambdabot>   Not in scope: `b111'
08:27:58 <lispy> I expected "Bond, James Bond"
08:28:11 <saml> > 0x111
08:28:12 <lambdabot>  273
08:28:19 <lispy> > O07
08:28:20 <lambdabot>   Not in scope: data constructor `O07'
08:29:02 <vixey> > let b = 2+2*2+2*2*2 in  b 111
08:29:03 <lambdabot>   add an instance declaration for (Num (t -> a))
08:29:08 <vixey> > let b = const$ 2+2*2+2*2*2 in  b 111
08:29:09 <lambdabot>  14
08:30:14 <lispy> ?vixey You have a twin!
08:30:14 <lambdabot> ?
08:30:29 <vixey> ?
08:30:40 <chrisdone> ?
08:30:53 <lispy> Is this Battletoads?
08:31:15 <lispy> ?vixey say hello to vixey
08:31:15 <lambdabot> hiya
08:55:09 <chrisdone> they're in the walls
08:56:16 <shepheb> does the GHC build process have somewhere I can set a different suffix (-3.4) for the gcc toolchain?
08:59:33 <lispy> shepheb: this channel is good for questions about using ghc, but #ghc might be better for questions about building it
08:59:49 <shepheb> fair point.
09:00:21 <lispy> #ghc is really for the ghc devs, but I'm guessing this level of question they wouldn't mind
09:00:32 <pejo> shepheb, --with-gcc=path
09:01:08 <pejo> shepheb, http://hackage.haskell.org/trac/ghc/wiki/Building has the build instructions
09:01:08 <lambdabot> Title: Building - GHC - Trac
09:01:09 <shepheb> pejo: hmm. what about the various other tools? or does it not use any others directly.
09:04:24 <monochrom> <3
09:05:03 <chrisdone> ·.·
09:12:30 <alesb> does there exist a mpfr binding for haskell?
09:13:12 <Botje> monad-powered fusion reactor?
09:13:53 <alesb> almost, http://www.mpfr.org/
09:13:54 <lambdabot> Title: The MPFR Library
09:20:10 <lispy> Why do they emphasize the /correct/ rounding?
09:20:28 <lispy> And how is it similar/different than, say, GMP?
09:21:31 <Spark> rounding is by definition incorrect, surely :)
09:22:04 <Spark> although financial systems have some kind of standard that i don't know in detail
09:22:19 <EvilTerran> lispy, Spark: presumably the rounding has simple, predictable semantics so you can reason about it easily
09:22:35 <Spark> that would be useful
09:22:36 <MyCatVerbs> lispy: if you use the floating point stuff in GMP, you often get higher precision than you asked for.
09:22:41 <Spark> but doesn't floor() have such semantics
09:22:44 <EvilTerran> unlike, say, IEEE floating-point, which can be pretty difficult to reason about in the edge cases
09:22:57 <Spark> ah i see
09:23:02 <MyCatVerbs> lispy: specifically, it rounds things up to either the nearest 32 or 64 bits (depending on your machine) for speed's sake.
09:23:30 <MyCatVerbs> lispy: by contrast, MFPR gives *exactly* the precision you ask for, with correct rounding in the last place.
09:23:46 <lispy> hmm
09:23:58 <MyCatVerbs> lispy: (rounding's awkward to deal with even when building hardware, and a lot of implementations get it wrong. The x87, famously so. :P)
09:25:04 <znutar> how did the x87 family get rounding wrong?
09:25:23 <lispy> znutar: do you remember the pentium fpu bug from the '90s?
09:25:29 <MyCatVerbs> znutar: well, specifically wrong by comparison to IEEE754.
09:25:30 <nolrai_East> @hoogle transpose
09:25:31 <lambdabot> Data.List.transpose :: [[a]] -> [[a]]
09:25:31 <lambdabot> Data.ByteString.transpose :: [ByteString] -> [ByteString]
09:25:31 <lambdabot> Data.ByteString.Char8.transpose :: [ByteString] -> [ByteString]
09:25:46 <Spark> but that was just some particular value in a division lookup table
09:25:50 <Spark> or some lookup table or other
09:25:55 * EvilTerran once saw a hand-coded assembly particles/gravity simulator (where each particle can have differing gravitational pull) that could cope with hundreds of particles - alledgedly, the author hand-coded around the errors in the x87 FP chip so symmetric patterns would always stay symmetric
09:25:58 <Spark> it wasn't really a bug in the algorithm
09:26:08 <MyCatVerbs> znutar: for IEE754 compatibility, you're supposed to do calculations with exactly 32 or 64 bits of precision, and then round them correctly.
09:26:29 <znutar> oh, they always do it at 8-? ick
09:26:33 <znutar> 80
09:26:50 <MyCatVerbs> znutar: what the x87 does instead (because at the time it was quicker to bodge it than do correct rounding) is do everything at 80 bits... with sucktastic rounding in the last place.
09:27:35 <Spark> you can change it on the x87
09:27:39 <Spark> there is a flag
09:27:51 <Spark> you can get unfun when using direct3d since it changes it for you
09:27:56 <Spark> and suddenly your doubles aren't doubles anymore
09:28:04 <lispy> One of the applications where I work uses fixed point instead of FP because they didn't like the differences between processors with FPUs
09:28:11 <Spark> you can turn it off of course but it's on by default and frequently catches people out
09:29:03 <MyCatVerbs> znutar: the results are, I guess, fine for a lot of situations, but this means that, while you can run exactly the same code on a SPARC, PowerPC, Alpha, etc, and get exactly the same results from all of them, your code will produce subtly or even completely (depending on numerical stability) different results when you run it on an x86.
09:29:17 <shapr> Does anyone have Matthew Sackman's email address?
09:30:59 <ndm> shapr: ms -AT- doc.ic.ac.uk
09:31:08 <shapr> thanks!
09:32:51 <shapr> ndm: Does he have an irc nick as well?
09:33:06 <ndm> shapr: matthew-_
09:33:10 <ndm> @seen matthew-_
09:33:10 <lambdabot> matthew-_ is in #haskell-blah, #haskell and #ghc. I don't know when matthew-_ last spoke.
09:33:11 <shapr> oh
09:33:14 <shapr> spiffy
09:33:23 <EvilTerran> preflex: seen matthew-_
09:33:23 <preflex>  matthew-_ was last seen on #haskell 6 hours, 13 minutes and 38 seconds ago, saying: foldl' (\acc e -> acc ++ (show e)) [] [repeat 'a']
09:33:34 <lispy> preflex: version
09:33:35 <preflex>  9.296
09:33:38 <ndm> is this about the Haskell reviews? or AngoHaskell?
09:33:55 <lispy> preflex: help
09:33:56 <preflex>  try 'help help' or see 'list' for available commands
09:33:58 <ndm> if its the latter, there is #anglohaskell
09:38:24 <MikeJonez>  spoiler from irc.trollin.org #arab: Batman is portrayed early in the movie as a nutcase and is saught to be arrested. Joker's clowns break joker out of jail.. theres a car chase.. batman and joker face off in batman's new BATPOD a motorcycle.. Harvey dent reveals the identity of batman as HIMSELF (untrue).. batman kills joker.. gordon uses a huge axe to smash the batman light symbol (the dark knight)
09:38:53 --- mode: ChanServ set +o Igloo
09:39:02 --- mode: Igloo set +b *!*@pool-71-255-157-239.cncdnh.east.verizon.net
09:39:07 --- kick: MikeJonez was kicked by Igloo (Igloo)
09:39:18 <shapr> Igloo: thanks
09:39:48 <shapr> ndm: About the Haskell reviews... I think one improvement to the academic review process would be for the papers to be anonymous, and the reviews and their reviews clearly identified.
09:40:02 <tusho> lol@mikejonez
09:40:07 <tusho> doesn't work if you mark it as a spoiler dude
09:40:20 <dublpaws> oddly polite of him
09:40:25 <ndm> @karma+ Igloo
09:40:25 <lambdabot> Igloo's karma raised to 1.
09:40:44 <Spark> i read it anyway
09:40:46 <shapr> @karma+ igloo
09:40:47 <lambdabot> igloo's karma raised to 2.
09:40:49 <Spark> just to spite myself
09:40:49 <tusho> dublpaws: 'By the way, I am about to reveal some secrets about the new movie "The Dark Knight". If you do not wish to read them, please stop now.'
09:40:59 <tusho> then rot13'
09:41:00 <ndm> shapr: writing an anonomous paper is hard
09:41:00 <tusho> d
09:41:01 <dublpaws> ack!
09:41:07 * dublpaws changes channels
09:41:09 <shapr> ndm: Yeah, but still..
09:41:13 <Spark> hell, writing an anonymous review is ahrd
09:41:26 <shapr> ndm: If reviews and reviewers were explicit, I think it'd work better.
09:41:31 <Spark> between my supervisors and me we usually work out who the reviewers are
09:41:35 <ndm> shapr: i have to say my Haskell Symposium reviews were of exceptionally high quality
09:41:35 <shapr> That wasn't my idea, I read it somewhere.
09:41:44 <shapr> ndm: excellent
09:41:50 <shapr> I've never had the chance to write a review myself.
09:41:57 <ndm> without a doubt some of the best reviews, in terms of quality and thought
09:42:11 <ndm> and I got 8 reviews between my 2 papers!
09:42:17 <shapr> cool!
09:42:17 <Spark> i think most reviews are just looking for an excuse to say yay or nay
09:42:17 <lispy> tusho: and even worse, what else would that movie be about...
09:42:36 <Spark> which is why you need to tick all the boxes as a high priority
09:42:48 <Spark> higher than actually having good content and well-written explanations
09:44:02 <shapr> and that sucks
09:44:12 <shapr> That's one reason I prefer blogs.
09:44:43 --- mode: Igloo set -o Igloo
09:45:10 <Spark> there are no quality standards in blogs though :)
09:45:23 <Spark> the academic review process is like democracy
09:45:31 <Spark> it doesn't work but i can't think of anything better
09:49:03 <shapr> There's google page rankings.
09:49:15 <shapr> That seems like the same idea to me.
09:49:18 <Philippa> *hah!*
09:49:22 <Philippa> no, it's really not
09:49:47 <Philippa> certainly not in the context of an academic subject
09:50:33 <Philippa> that's more like rating papers by the reference trail on citeseer
09:50:34 <Spark> let's all use ruby!
09:50:54 <Philippa> useful, but it won't tell you if there turned out to be something subtly wrong
09:51:23 <Spark> i'd take "peer review" over "peasant review" any day
09:51:54 <shapr> Yeah, reddit points aren't terribly accurate.
09:52:11 <shapr> I still wish there were some way to get more interested people to look at a paper.
09:52:33 <Spark> is there a freshmeat for tech reports?
09:52:42 <Spark> that would be good i think
09:52:50 <Spark> ideally you want to be writing the tech report before the actual paper
09:52:52 <Philippa> seconded
09:53:01 <Spark> but of course that never happens with deadlines and such
09:53:03 <dcoutts_> arxiv.org/
09:53:04 <Philippa> I guess LtU's forums get used sometimes
09:53:07 <dublpaws> slashdot sometimes references arxiv
09:53:23 <dcoutts_> the mathematicians all use arxiv.org
09:53:28 <Spark> some sort of centralised system would be better
09:53:32 <vixey> why does ghc say     Could not find module `Text.ParserCombinators.Parsec.Token':
09:53:36 <vixey> but ghci can find it
09:53:40 <dcoutts_> Spark: you're describing arxiv
09:54:11 <Quadrescence> A hash table can be loosely described as an array with it's own indexing system, right?
09:54:17 <Spark> http://arxiv.org/list/cs.PL/recent
09:54:18 <Spark> cool
09:54:22 <dcoutts_> the mathematicians stick pre-prints on arxiv and then update them as they go
09:54:35 <dcoutts_> they use it as a way of proving they did something first too
09:54:44 <Spark> i half did it first!
09:54:44 <nolrai_East> @src transpose
09:54:45 <lambdabot> transpose []             = []
09:54:45 <lambdabot> transpose ([]   : xss)   = transpose xss
09:54:45 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
09:55:04 <Spark> heh, nobuko is on that page
09:55:06 <dcoutts_> and many maths journals and conferences require submissions to be on arxiv first
09:55:11 <Spark> her office is 3 doors down from me
09:55:20 <Spark> i guess this is what i was looking for after all
09:55:30 <Spark> dcoutts_: now that is interesting
09:55:35 <dcoutts_> and arxiv has a tagging system and can email people about new papers in areas they're interested in
09:55:46 <dcoutts_> but for some reason computer scientists do not use it
09:55:48 <Spark> not just "anonymous reviewer" but "anonymous coward reviewer"
09:56:02 <nolrai_East> Spark:??
09:56:11 <dcoutts_> probably because we had personal web sites before the mathematicians and before arxiv was set up
09:56:12 <PeakerWork> can case pattern-matches have guards, or only function pattern matches?
09:56:46 <ndm> PeakerWork: most matchs can have guards
09:58:56 <therp> dcoutts_: it doesn't seem like it's not used by comp.sci. http://arxiv.org/list/cs/recent
10:00:14 <dcoutts_> therp: I've never seen any FP stuff referenced there.
10:00:33 <lispy> PeakerWork: you can have a pattern and a guard
10:00:35 <dcoutts_> therp: I'm not saying there's no CS or no FP, but I've never seen anyone in our community refer to FP papers posted there
10:00:43 <dcoutts_> therp: I think it would be great if we did
10:01:00 <therp> dcoutts_: haven't seen anything neither.. would be great yes
10:01:01 <lispy> PeakerWork: case foo of (blah, boo) | Boo <- isBoo boo -> ...
10:02:10 <PeakerWork> lispy: the arrows are confusing
10:02:29 <nolrai_East> lispy: I dont think the <- arrow makes sense there.
10:02:40 <lispy> It does, it's a pattern guard
10:02:50 <lispy> Which I thought is what Peaker wanted...
10:03:11 <lispy> I'm actually staring at some code that has that exact structure :)
10:03:30 * ndm is going to Haskell Symposium, yay!
10:03:34 <nolrai_East> ok, so <-  is overloaded then?
10:03:36 * shapr is not, boo!
10:03:49 <nolrai_East> where is the Haskell Symposium?
10:03:52 <ndm> I thought I wasn't, until about an hour ago
10:03:54 <ndm> Canada
10:04:03 <lispy> look at 8.3.2: http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html
10:04:04 <lambdabot> Title: 8.3. Syntactic extensions, http://tinyurl.com/y6v6by
10:04:09 <ndm> @google ICFP 2008
10:04:10 <lambdabot> http://www.icfpconference.org/icfp2008/
10:04:10 <lambdabot> Title: ICFP 2008 : The 13th ACM SIGPLAN International Conference on Functional Programm ...
10:04:31 <shapr> Ok, I might show up anyway.
10:05:00 <therp> are the Canadian border guard laptop searches as PITA as in theUS?
10:05:36 <nolrai_East> PITA
10:05:39 * ndm owns no computers, the problem is a little moot :(
10:05:40 <lispy> A co-worker recently took some VoIP equipment to our canadian office and spent the night at the border due to inspections
10:05:42 <shapr> Just use an external SATA drive for all your real data, and have a vanilla install of something on yer lappy.
10:05:47 <shapr> wow
10:05:58 <shapr> I thought voip was sposed to save time?
10:06:07 <therp> shapr: it's not a practical issue for me. I'm smart enough to circumvent that
10:06:30 <nolrai_East> what does PITA stand for?
10:06:35 <Deewiant> pain in the ass
10:06:37 <ndm> Pain In The Ass
10:06:38 <lispy> We were teasing him about canadian prision
10:07:29 <Leaves> Hey do you know how I can easily do     map f [[a, b, c], [d, e, f], etc]     where f works on the a, b and c, not on the [a, b, c], is there a standard function for this or should I use some code for it?
10:07:42 <vixey> map (map f) ..
10:07:47 <therp> shapr: to me the issue is a privacy violation, and not a little one. I'm not going to travel to a country that doesn't have any protection of basic civil rights. that of course takes any US based conference of my schedule
10:07:59 <nolrai_East> They try to inforce data restrictions on phisical importations? --baddly said
10:08:14 <EvilTerran> > (map.map) f [[a,b,c], [x,y,z]] :: [[Expr]]
10:08:20 <lambdabot>  [[f a,f b,f c],[f x,f y,f z]]
10:08:55 <shapr> therp: Yeah, I can understand that. But parts of Europe aren't any improvement.
10:09:01 <nolrai_East> thats just sad.
10:09:40 <nolrai_East> On so many levels.
10:10:03 <roconnor> > ((.).(.)) f [[a,b,c], [x,y,z]] :: [[Expr]]
10:10:04 <lambdabot>  [[f a,f b,f c],[f x,f y,f z]]
10:10:12 <therp> shapr: I've never seen violations of basic civil rights to that extend as reported in the US.. so I do definitely prefer Europe over anything else
10:10:46 <kryptiskt> therp, except sweden of course :-)
10:10:55 <therp> what's wrong with sweden?
10:11:06 <shapr> recent wiretapping laws?
10:11:13 <kryptiskt> yes
10:11:18 <taruti> like echelon...
10:11:24 <shapr> hei taruti
10:11:27 <taruti> hei
10:11:28 <therp> haven't heard about that.
10:11:30 <therp> links?
10:11:52 <taruti> the FRA law is basically "lets eavesdrop all communication passing through Sweden"
10:12:01 <shapr> yeah
10:12:22 <shapr> Rumor has it that's because they want to hear Russian network traffic, I have no idea myself.
10:12:23 <EvilTerran> they want to do the same here in the UK, iirc
10:12:36 <lispy> So, use encryption
10:12:56 <Leaves> thanks, vixey, I forgot that I can of course also send (map f) as an argument to another map, that's very nice :) EvilTerran, I didn't really get how your function works, I will try for a bit in ghci
10:13:08 <shapr> Seems to me like we should use encryption for everything. Otherwise we have no privacy.
10:13:13 <Philippa> EvilTerran: sure you're not thinking about the slightly more basic communication logs?
10:13:14 <vixey> (f.g) x = f (g x)
10:13:18 <Philippa> shapr: that's not good enough
10:13:23 <vixey> map (map f) xs = (map.map) f xs
10:13:23 <shepheb> therp: I'm Canadian and haven't heard anything about laptops being searched. Mine certainly wasn't searched after returning from the UK in April
10:13:27 <Philippa> "X connected to Y" is significant info
10:13:27 <shepheb> fwiw
10:13:35 <Philonous> the don't go to Germany either. The telecomunication data retentions are a real nuisance
10:13:49 <shapr> Philippa: true
10:14:01 <EvilTerran> ?type Prelude.map . Prelude.map
10:14:02 <lambdabot> forall a b. (a -> b) -> [[a]] -> [[b]]
10:14:13 <EvilTerran> (map.map) f = map (map f)
10:14:18 <nolrai_East> What really piss me off is those sort of things arn't that useful for enforce ment or security, its just a invitaion to drown in data.
10:14:19 <therp> shepheb: http://www.google.com/search?q=canadian+border+guard+laptop+search ? might be an exception
10:14:20 <lambdabot> Title: canadian border guard laptop search - Google Search, http://tinyurl.com/665vsu
10:15:30 <nolrai_East> Yeiks Police State tactics to enforce copyright.
10:15:53 <Leaves> EvilTerran: ah, I see like the small o in math :)
10:16:06 <lispy> Leaves: right
10:16:11 <EvilTerran> Leaves, exactly. (.) is function composition
10:16:14 <EvilTerran> ?src (.)
10:16:14 <lambdabot> (f . g) x = f (g x)
10:16:14 <lambdabot> -- In lambdabot, it's been generalised to:
10:16:14 <lambdabot> (.) = fmap
10:16:24 <Philonous> nolrai_East: IMO they where never meant to be. Considering that the responsible authorities change their justification for those measuress on a daily basis
10:16:43 <EvilTerran> Leaves, it's just another operator - as lambdabot says, one defined with the line "(f . g) x = f (g x)"
10:17:28 <edmoore> hi everyone - just read the paper of how haskell was used to prototype a naval geo-centre. written my mark jones. It was also a latex document. very cool. Does anyone know where there is a copy of the source/tex/pdf/anything? I'd love to have a look.
10:18:30 <kryptiskt> You certainly don't need wiretapping laws to get at piracy, file sharing is after all basically screaming to the world: "hey, there, here are all my copyright violations, come and get me"
10:18:54 <shapr> hiya edmoore, I've never seen the sources for that paper.
10:19:22 <nolrai_East> kryptiskt: true
10:19:35 <edmoore> shapr: beautiful idea though. I'm totally taken by it and would rather like to hand in my assignments in that form forever more. amen.
10:20:18 <shapr> edmoore: You're in the right place then :-)
10:20:34 <therp> I'm just waiting for the moment when encryption becomes a crime..
10:20:49 <edmoore> do you know if ghc has an option to just compile what it finds between \begin{code}....\end{code}?
10:20:56 <lament> encryption is already a crime in many places in the world
10:21:12 <kryptiskt> therp, in the UK you have to hand over the cryptokeys to the police on demand
10:21:22 <tusho_> lament: isn't it lovely?
10:21:29 <EvilTerran> edmoore, i think you have to use the extension .lhs
10:21:29 <edmoore> I see that it does. Gosh, wonderful.
10:21:31 <shapr> edmoore: Yeah, I think that's what it does by default.
10:21:32 <edmoore> yeah
10:21:41 <shapr> edmoore: literate programming is lots of fun.
10:21:53 <edmoore> shapr: it really appeals to my way of thinking
10:21:59 <therp> kryptiskt: ah great. So I just mail an excerpt of my /dev/random to a "friend", and then call the police claiming that he received encrypted terror plans..
10:22:07 <edmoore> like Doxygen for those with a pencahnt for typsetting
10:22:10 <lispy> YMMV, but I would discourage literate programming and suggest instead that you use haddock
10:22:17 <chsigi> edmoore: could you give me a link to the paper you were talking about. sounds pretty interesting.
10:22:19 <therp> kryptiskt: I wonder if that trick works with the prime minister?
10:22:25 <shapr> edmoore: If you ask google for filetype:lhs and \end you'll find lots of examples.
10:22:27 <edmoore> http://haskell.org/papers/NSWC/jfp.ps
10:22:44 <shapr> lispy: I wish we had a single web & latex format.
10:23:11 <chsigi> edmoore: thanks
10:23:13 <lispy> One problem I recall with latex literate haskell is how to get the code in to both the source and the documentation?
10:23:14 <edmoore> shapr: agreed
10:23:29 <edmoore> I'd happily wait for my pages to be typset.
10:24:42 <QuietPurple> can anyone help me? I'm very confused about how to handle different data types in Haskell.
10:25:35 <lispy> QuietPurple: we can probably help, but more information from you is needed
10:25:40 <QuietPurple> basically, for the program i'm writing i need 32-bit unsigned integers, so i'm using Word32
10:25:45 <QuietPurple> is that the right idea?
10:26:13 <lispy> Word32 is unsigned and Int32 is signed, so that sounds right
10:26:17 <QuietPurple> ok
10:26:45 <lispy> > (2^31 :: Word32, 2^31 :: Int32)
10:26:46 <lambdabot>  (2147483648,-2147483648)
10:28:09 <lilachaze> > abs (-2^31) :: Int32
10:28:10 <lambdabot>  -2147483648
10:28:41 <vixey> @check \(x::Int32) -> abs x > 0
10:28:41 <lambdabot>  Parse error in pattern at "->" (column 13)
10:28:49 <QuietPurple> so my basic problem is that I don't feel i understand how Haskell knows what type to make variables---when i write functions to handle different types the program always gets confused and i have to add ::'s and fromInteger's and toInteger's using trial and error until it works
10:28:50 <lilachaze> >=, surely?
10:28:51 <vixey> @check \x -> abs x > 0::Int32)
10:28:51 <lambdabot> Unbalanced parentheses
10:28:51 <vixey> @check \x -> abs x > 0::Int32
10:28:52 <lambdabot>  Couldn't match expected type `Int32' against inferred type `Bool'
10:28:58 <vixey> @check \x -> abs x > (0::Int32)
10:28:59 <lambdabot>   add an instance declaration for (Arbitrary Int32)     In the expression: le...
10:29:03 <Deewiant> @check \x -> abs x >= (0 :: Int)
10:29:04 <lambdabot>  OK, passed 500 tests.
10:29:31 <lilachaze> @check \x -> let x' = fromIntegral x :: Int32 in abs x' >= 0
10:29:32 <QuietPurple> k :: Int -> Word32
10:29:32 <lambdabot>  OK, passed 500 tests.
10:29:41 <QuietPurple> k n = floor (abs (sin (n + 1)))
10:29:47 <lispy> QuietPurple: Well, Haskell has a bit of disambiguation to deal with when working with numeric constants
10:29:51 <lispy> :t 1
10:29:52 <lambdabot> forall t. (Num t) => t
10:30:02 <QuietPurple> so what do i do with this to stop it from messing up?
10:30:05 <vixey> QuietPurple, I don't think so
10:30:06 <lispy> QuietPurple: see, that it doesn't know what type of number "1" is, just that it is a number
10:30:15 <vixey> :t floor . abs . sin . (+1)
10:30:16 <lambdabot> forall b a. (Floating a, Integral b, RealFrac a) => a -> b
10:30:22 <Deewiant> giving type signatures to top-level declarations is usually a good idea :-)
10:30:34 <vixey> :t floor . abs . sin . (+1) . fromIntegral :: Int -> Word32
10:30:34 <lambdabot> Int -> Word32
10:30:37 <Deewiant> and beyond that, a common trap for newbies is division
10:30:39 <Deewiant> ?ty (/)
10:30:40 <lambdabot> forall a. (Fractional a) => a -> a -> a
10:30:41 <Deewiant> ?ty siv
10:30:42 <lambdabot> Not in scope: `siv'
10:30:43 <Deewiant> ?ty div
10:30:44 <lambdabot> forall a. (Integral a) => a -> a -> a
10:30:51 <vixey> QuietPurple, There must be fromIntegral for the conversion
10:31:09 <QuietPurple> so, basically, i have no idea what data type haskell thinks i want at each stage
10:31:22 <QuietPurple> n + 1 is Int? right?
10:31:26 <vixey> QuietPuple, you can ask it
10:31:29 <lispy> :t \n -> n + 1
10:31:29 <Deewiant> if n is Int, yes
10:31:29 <lambdabot> forall a. (Num a) => a -> a
10:31:35 <QuietPurple> so what is sin (n + 1)?
10:31:36 <vixey> QuietPuple, no, n + 1 depends on the type of n
10:31:38 <vixey> :t 1
10:31:38 <EvilTerran> oh, hi QuietPurple
10:31:39 <lambdabot> forall t. (Num t) => t
10:31:42 <Deewiant> ?ty \n -> sin (n + 1)
10:31:42 <lambdabot> forall a. (Floating a) => a -> a
10:31:55 <QuietPurple> well, n is Int
10:32:01 <QuietPurple> so n+1 is then Int?
10:32:06 <EvilTerran> Int is not an instance of Floating
10:32:08 <EvilTerran> so that's a type error
10:32:09 <Deewiant> ?ty \n -> n + 1
10:32:10 <lambdabot> forall a. (Num a) => a -> a
10:32:10 <QuietPurple> hey, Evil
10:32:13 <Deewiant> two a's
10:32:15 <vixey> yes
10:32:16 <lispy> QuietPurple: To throw your mind for a loop, n could be anything that implements Num.  That is, it doesn't have to be a "number"
10:32:19 <Deewiant> so if you restrict one of the a's to INt
10:32:21 <EvilTerran> ?type \n -> sin ((n :: Int) + 1)
10:32:22 <lambdabot>     No instance for (Floating Int)
10:32:22 <lambdabot>       arising from a use of `sin' at <interactive>:1:6-25
10:32:22 <lambdabot>     Possible fix: add an instance declaration for (Floating Int)
10:32:23 <Deewiant> the other must be an Int as well
10:32:35 <lispy> :t \n -> (n::Expr) + 1
10:32:36 <lambdabot> Not in scope: type constructor or class `Expr'
10:32:50 <lispy> :t f + 1
10:32:51 <lambdabot> Not in scope: `f'
10:33:01 <lispy> Oh, was that feature removed from lambdabot?
10:33:07 <EvilTerran> > x + 1
10:33:09 <lambdabot>  x + 1
10:33:09 <vixey> :t ?f + 1
10:33:10 <lambdabot> forall a. (Num a, ?f::a) => a
10:33:10 <Deewiant> ?ty f + 1 :: Expr
10:33:11 <lambdabot> Not in scope: `f'
10:33:11 <lambdabot> Not in scope: type constructor or class `Expr'
10:33:38 <lispy> :t x + 1
10:33:39 <lambdabot> Not in scope: `x'
10:33:46 <vixey> :t ?x + 1
10:33:47 <lambdabot> forall a. (Num a, ?x::a) => a
10:34:00 <Deewiant> the type plugin evidently doesn't know about it
10:34:04 <EvilTerran> ?type x + 1
10:34:04 <lambdabot> Not in scope: `x'
10:35:20 <QuietPurple> ok, so this is what is confusing---why can't there just be clear way of defining "i want this variable to be a 32-bit float, this one a 16-bit Integer, etc..."
10:35:24 <QuietPurple> ?
10:35:33 <vixey> :t floor . abs . sin . (+1) . fromIntegral :: Int -> Word32
10:35:37 <lambdabot> Int -> Word32
10:35:37 <vixey> QuietPuple, ^
10:35:41 <Deewiant> there is, ::
10:35:53 <Deewiant> but you still can't declare conflicting types
10:36:02 <vixey> :t 7 + 3 :: String
10:36:03 <lambdabot>     No instance for (Num String)
10:36:03 <lambdabot>       arising from the literal `7' at <interactive>:1:0
10:36:03 <lambdabot>     Possible fix: add an instance declaration for (Num String)
10:36:05 <Deewiant> ?ty \n -> ((n :: Int) + 1) :: Float
10:36:06 <lambdabot>     Couldn't match expected type `Float' against inferred type `Int'
10:36:06 <lambdabot>     In the expression: ((n :: Int) + 1) :: Float
10:36:18 <QuietPurple> yes, so i pepper my functions with ::'s and often it still doesn't work
10:36:33 <vixey> QuietPuple, Can you see my example?
10:36:55 <QuietPurple> which, 7 + 3 :: String?
10:36:58 <Deewiant> or mine
10:37:08 <vixey> QuietPuple, No the other one
10:37:08 <Deewiant> which is probably what leads you to having to pepper fromIntegrals everywhere
10:38:17 <QuietPurple> so for example, what does Num String mean? is it a Num or is it a String?
10:38:36 <Deewiant> Num is a type class
10:38:39 <vixey> QuietPuple, No the *other* example
10:38:39 <Botje> it means String is a member of the type class Num
10:38:58 <QuietPurple> floor . abs . sin . (+1) . fromIntegral :: Int -> Word32 ?
10:39:04 <vixey> Yes
10:39:24 <lilachaze> :t sin
10:39:26 <lambdabot> forall a. (Floating a) => a -> a
10:39:32 <QuietPurple> ok, so that will work?
10:39:42 <vixey> well it type checks
10:39:42 <lilachaze> will defaulting pick Double for that?
10:39:46 <Botje> :t  floor . abs . sin . (+1) . fromIntegral
10:39:46 <Deewiant> the type checker didn't barf on it so of course it works :-)
10:39:46 <lambdabot> forall b a. (Integral a, Integral b) => a -> b
10:39:48 <vixey> it certainly doesn't do anything useful..
10:40:32 <QuietPurple> I still don't understand how to know the fromIntegral goes there.... surely its still an integral value until you do sin to it?
10:40:45 <Botje> yes
10:40:47 <vixey> fromIntegral converts an integral into a floating
10:40:49 <Botje> but sin is only defined on Floating
10:40:51 <Botje> not on Integral
10:40:57 <lilachaze> @check \a -> (const 0 :: Int -> Word32) a == (floor . abs . sin . (+1) . fromIntegral :: Int -> Word32) a
10:41:00 <lambdabot>  OK, passed 500 tests.
10:41:10 <Botje> type :i Floating and :i Integral in ghci
10:41:23 <Botje> to see which types belong to those classes
10:41:36 <Deewiant> ?instances Floating
10:41:36 <lambdabot> Double, Float
10:41:40 <Deewiant> ?instances Integral
10:41:40 <lambdabot> Int, Integer
10:41:42 <Botje> ah
10:41:45 <Botje> Deewiant++
10:41:53 <Deewiant> :-)
10:41:57 <Botje> I'm still clumsy with \bot
10:42:05 <Deewiant> but :i in GHCi is still more informative
10:42:36 <Botje> verily.
10:43:43 <lilachaze> QuietPurple: one important thing you need to know: haskell never guesses types, never makes them up, and never implicitly converts
10:44:03 <vixey> haskell always makes them up :)
10:44:05 <QuietPurple> but it guesses them all the time
10:44:42 <lilachaze> QuietPurple: no, it infers them. the only time it doesn't figure out a type from a type signature somewhere is when it does defaulting.
10:45:02 * lilachaze waits to be proven wrong by the people here who know haskell better
10:45:43 <QuietPurple> so what i need to do for my function is fromIntegral, then + 1, then sin, etc?
10:45:50 <roconnor> defaulting is very vaguely like guessing
10:46:22 <lilachaze> arguably, it's the haskell98 committee guessing rather than the haskell compiler guessing, though :)
10:46:32 <roconnor> :)
10:47:01 <Botje> QuietPurple: +1 is Num -> Num, so it doesn't matter if you do that before or after the fromIntegral
10:47:11 <Botje> but yes. if you want to sin an Integral number, you need to fromIntegral first
10:47:13 <QuietPurple> Did Deep Blue beat Gary Kasparov? or the programmers that wrote it?
10:47:28 <QuietPurple> ok
10:47:31 <vixey> Kasparov beat Deep Blue!
10:47:55 <QuietPurple> So fromIntegral takes an Int and returns a Float?
10:48:12 <Botje> it takes an Integral type and returns a Num type
10:48:21 <Deewiant> ?ty fromIntegral
10:48:22 <lambdabot> forall a b. (Num b, Integral a) => a -> b
10:48:23 <Botje> in this particular instance it takes an int and returns a float, yes
10:48:51 <roconnor> @check \ x -> (sin (fromIntegral (x+1))) == (sin (fromIntegral x + 1))
10:48:52 <lambdabot>  OK, passed 500 tests.
10:48:54 <QuietPurple> So one thing that really confuses me is what's the difference between Int Integral and Integer?
10:49:07 <QuietPurple> why have three different types
10:49:09 <QuietPurple> ?
10:49:09 <Deewiant> Integral is a type class
10:49:10 <vixey> Int is a fixed precision number
10:49:11 <Botje> Int and Integer are types
10:49:15 <roconnor> > maxBound Int
10:49:16 <vixey> Integer is unbounded in size
10:49:17 <lambdabot>   Not in scope: data constructor `Int'
10:49:22 <vixey> Integral is the typeclass which both are in
10:49:22 <Deewiant> > maxBound :: Int
10:49:23 <roconnor> > maxBound :: Int
10:49:27 <lambdabot>  2147483647
10:49:27 <lambdabot>  2147483647
10:49:30 <Botje> Integral is a type class, which encompasses types
10:49:30 <roconnor> > maxBound :: Integer
10:49:31 <lambdabot>   add an instance declaration for (Bounded Integer)
10:49:31 <lambdabot>     In the expression: ma...
10:49:32 <vixey> > maxBound :: Integer
10:49:32 <lambdabot>   add an instance declaration for (Bounded Integer)
10:49:32 <lambdabot>     In the expression: ma...
10:49:34 <Deewiant> all Integral numbers support some common operations
10:49:39 <vixey> @quote fugue
10:49:39 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
10:49:41 <Deewiant> ?src Integral
10:49:41 <lambdabot> class  (Real a, Enum a) => Integral a  where
10:49:43 <lambdabot>     quot, rem, div, mod :: a -> a -> a
10:49:45 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
10:49:47 <lambdabot>     toInteger           :: a -> Integer
10:49:51 <Botje> lol
10:50:10 <QuietPurple> good fugue! :-)
10:50:51 <Deewiant> 'x' being an Integral just means that the above functions, replacing 'a' with 'x', exist and can be applied
10:51:21 <QuietPurple> ok, so there are things called type classes, which contain types? and any variable has a type and then a type class?
10:51:43 <Deewiant> type classes do not contain anything
10:51:49 <QuietPurple> type classes are Num Integral Floating, etc?
10:52:06 <QuietPurple> classes usually contain things
10:52:09 <Deewiant> they just specify that if 'a' is in an instance of this type class, you can apply these class methods with that type in place of the class parameter
10:52:23 <lispy> QuietPurple: Haskell type classes are more like interfaces
10:52:24 <Deewiant> if classes 'contain' something, they contain the methods
10:52:27 <Deewiant> quot, rem, div, mod in the above
10:52:31 <rwbarton> variables have types.  A type may belong to any number of type classes
10:52:36 <QuietPurple> so classes are like types of type?
10:52:44 <Deewiant> and yes, Num Integral Floating are type classes
10:52:48 <Deewiant> and no, kinds are types of types. ;-)
10:52:55 <Deewiant> ?kind Num
10:52:56 <lambdabot> Class `Num' used as a type
10:53:03 <Lemmih> dcoutts: Hi.
10:53:03 <Deewiant> ?kind Int
10:53:03 <lambdabot> *
10:53:07 <lispy> ?kind (->)
10:53:07 <lambdabot> ?? -> ? -> *
10:53:10 <QuietPurple> sorry, so now we have kinds as well?
10:53:18 <Deewiant> yeah
10:53:22 <Deewiant> but they're not that important
10:53:26 <dcoutts_> hia Lemmih, come round to the side door, I'll let you in
10:53:27 <Deewiant> disregard that :-P
10:53:37 <shapr> That answers my question, Lemmih is still in the UK.
10:53:42 <Deewiant> once you get to monad transformers you might get kind errors
10:53:49 <Deewiant> and even then, you don't really need to think about them that much.
10:54:07 <QuietPurple> ok, so i can forget about kinds
10:54:13 <Deewiant> yeah, pretty much.
10:54:31 <QuietPurple> so does a variable in Haskell always have a type and a type class?
10:54:40 <Deewiant> as rwbarton said
10:54:43 <Deewiant> all variables have a type
10:54:43 <Botje> it has a type
10:54:48 <QuietPurple> ok
10:54:50 <Deewiant> a type may be an instance of any number of type classes
10:55:06 <QuietPurple> so variables don't explicitly have type classes?
10:55:31 <Botje> no
10:55:42 <QuietPurple> so i can say x is an Int, so I can use it like Integral or like Num?
10:55:43 <Deewiant> a variable only has a type, and what type it is determines what class methods you can apply on it
10:55:52 <lilachaze> QuietPurple: a type class is pretty much an extensible set of types
10:55:54 <opqdonut> "x :: Num a => a" says x has a type that belongs to the Num class
10:55:57 <Deewiant> yeah, or like Show, Read, Ord, Eq, many others...
10:56:30 <dons> CUFP program up, http://www.reddit.com/info/6sy76/comments/
10:56:31 <lambdabot> Title: reddit.com: F#, Erlang, OCaml, Haskell: Commercial Users of Functional Programmi ...
10:58:04 <QuietPurple> so, for example, how would i convert from an Int to a Word32?
10:58:06 <rwbarton> Note that there are a lot of ways to use type classes besides the type "Class a => a", e.g.,
10:58:11 <rwbarton> :t print
10:58:13 <lambdabot> forall a. (Show a) => a -> IO ()
10:58:31 <lispy> QuietPurple: a type class is a set of class that all implement a specific interface
10:58:36 <dons> QuietPurple: fromIntegral
10:58:41 <Deewiant> ?ty fromIntegral :: Int -> Word32
10:58:45 <lambdabot> Int -> Word32
10:58:50 <lilachaze> @type fromIntegral
10:58:51 <lambdabot> forall a b. (Num b, Integral a) => a -> b
10:58:56 <lispy> QuietPurple: sorry I meant, a set of types, not a set of class
10:59:10 <QuietPurple> Ok, so fromIntegral can turn Int into any Type that have instances in Num?
10:59:32 <Deewiant> Yes.
10:59:36 <cetin> anyone with some qtHaskell experience?
10:59:37 <Deewiant> ?ty fromIntegral
10:59:38 <lambdabot> forall a b. (Num b, Integral a) => a -> b
10:59:38 <dons> it'll turn anything in Num to anything in Integral
10:59:43 <lilachaze> QuietPurple: more generally, fromIntegral can turn any type in the Integral type class (including Int) to any type in the Num type class
10:59:44 <Deewiant> and more accurately, it can turn any Integral.
10:59:57 <Deewiant> dons: other way around
11:00:29 <QuietPurple> and how does Haskell know which of the Num types to turn my Int into?
11:00:54 <dons> Heffalump: I note Howard's giving an F# talk at CUFP this year. Is that a big change?
11:00:55 <Botje> it infers it
11:00:55 <lilachaze> in your case, it does it via defaulting.
11:01:00 <Deewiant> > fromIntegral 1
11:01:00 <dons> Deewiant: hah, yes.
11:01:01 <lambdabot>  1
11:01:09 <lilachaze> QuietPurple: it looks at how the value is used
11:01:25 <Deewiant> > let x = fromIntegral 1 in sin x
11:01:26 <lambdabot>  0.8414709848078965
11:01:31 <QuietPurple> ok, so sin.fromIntegral n
11:01:36 <QuietPurple> then it must be a float
11:01:38 <QuietPurple> ?
11:01:46 <lilachaze> well, in that case, it must be in typeclass Floating
11:01:48 <Deewiant> yes, it must be any type which is an instance of Floating
11:01:51 <Deewiant> and it defaults it to Double
11:02:02 <lilachaze> defaulting is a bit nasty
11:02:04 <Deewiant> just like it defaults Integrals to Int
11:02:10 <Deewiant> or Integer?
11:02:24 <Deewiant> well, whichever, anyway.
11:02:32 <lilachaze> haskell has a list of types it tries, in order, if it can't figure out which type was intended
11:02:33 <byorgey> Integer, I think
11:02:45 <lilachaze> but the rules are a little complicated
11:03:07 <lilachaze> > 2 ^^ 36
11:03:08 <lambdabot>  6.8719476736e10
11:03:11 <lilachaze> > 2 ^^ 100
11:03:13 <lambdabot>  1.2676506002282295e30
11:03:16 <lilachaze> Integer, then.
11:03:17 <lispy> What causes this?
11:03:18 <lispy>     Warning: No explicit method nor default method for `coarbitrary'
11:03:18 <lispy> 	     In the instance declaration for `Arbitrary Patch'
11:03:19 <byorgey> and it only applies in situations (like at the ghci prompt) where a concrete type is needed.
11:03:25 <Deewiant> ?ty (^^)
11:03:25 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
11:03:33 <lispy> I suspect my QuickCheck verson is wrong
11:03:34 <Deewiant> lilachaze: Integer ain't a Fractional. :-)
11:03:36 <lilachaze> > (toIntegral 2) ^^ 100
11:03:37 <lambdabot>   Not in scope: `toIntegral'
11:03:39 <Deewiant> > 2 ^ 32
11:03:41 <lambdabot>  4294967296
11:03:41 <Deewiant> > 2 ^ 33
11:03:43 <lambdabot>  8589934592
11:03:49 <QuietPurple> but if my function says Word32 then it will infer Word32?
11:03:51 <Deewiant> but yeah, Integer.
11:03:56 <Deewiant> QuietPurple: yeah.
11:03:59 <byorgey> lispy: the Arbitrary typeclass (in QC versions prior to v2)  has two methods, arbitrary and coarbitrary
11:04:11 <byorgey> lispy: in QC2, coarbitrary is split into a separate typeclass
11:04:32 <lilachaze> QuietPurple: yes, explicit type annotations always win. but they've got to be consistent with type inference.
11:05:01 <byorgey> > 2 ^ 33 :: Word32
11:05:03 <lambdabot>  0
11:05:06 <QuietPurple> ok, so i can have my function return anything which has an instance in Num?
11:05:18 <QuietPurple> if i use fromIntegral
11:05:21 <vixey> :t floor
11:05:22 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
11:05:35 <vixey> QuietPurple: Only Integrals
11:05:37 <Deewiant> if you end up taking the sin of something you have to return a Floating, or round it to an Integral
11:05:40 <byorgey> QuietPurple: sure, as long as you implement it with functions which themselves only require a Num instance
11:05:41 <lispy> byorgey: Since this code used to work, that essentially means my QC library is too new?
11:05:51 <byorgey> lispy: too old
11:06:06 <lispy> oh hrm
11:06:11 <byorgey> lispy: if you had QC2 you would not see that warning
11:06:23 <QuietPurple> ok, i think i understand it a lot better now
11:06:40 <lispy> Indeed, I have QC 1.0.1
11:07:19 <QuietPurple> but for my ease of mind, if a variable is defined as Word32, haskell won't decide it should be something else, unless i use fromIntegral?
11:07:38 <byorgey> 1.0.1? that's not even the latest version on Hackage
11:07:42 <Deewiant> if you give an explicit type the compiler won't change it.
11:07:48 <QuietPurple> ok
11:07:52 <Deewiant> byorgey: but it comes with GHC 6.8.2, right?
11:07:58 <lispy> byorgey: Where do I get QC 2+
11:08:02 <byorgey> Deewiant: oh, does it? maybe
11:08:04 <lispy> byorgey: hackage has 1.1
11:08:12 <QuietPurple> well, many thanks for all your help!
11:08:28 <lispy> Deewiant: my 6.8.2 has 1.1
11:08:29 <byorgey> lispy: there's a darcs repo somewhere, let me see if I can find it for you
11:08:39 <byorgey> @where QuickCheck
11:08:40 <lambdabot> http://www.cs.chalmers.se/~rjmh/QuickCheck/
11:08:40 <mainland> QC2: http://darcs.haskell.org/QuickCheck/
11:08:40 <Deewiant> lispy: meh, guess not then
11:08:42 <lambdabot> Title: Index of /QuickCheck
11:08:52 <shapr> I like qc2
11:08:55 <shapr> shrink is awesome
11:08:57 <byorgey> ah, thanks mainland
11:09:05 <shapr> oh, edwardk had a cool qc2 idea
11:09:12 <shapr> well, qc in general
11:09:15 <mainland> yes, shrink is really great...
11:09:33 <lispy> byorgey: http://darcs.haskell.org/QuickCheck/
11:09:34 <lambdabot> Title: Index of /QuickCheck
11:09:36 <shapr> mainland: Haskeller in Boston?
11:09:43 <mainland> maybe someday we'll get an updated QC in the base system
11:09:45 <byorgey> lispy: yup, that's it
11:09:48 <mainland> shapr: yup yup
11:09:55 <lispy> I googled quickcheck _darcs :)
11:09:57 <ndmitchell> anyone here formatted a HW or ICFP paper for US letter format?
11:09:58 <byorgey> shapr: what was edwardk's idea?
11:10:11 <ndmitchell> i'm having much issues, including not being entirely sure what to do!
11:10:23 <lilachaze> @hoogle Eq b => (a -> b) -> (a -> b) -> a -> Bool
11:10:23 <lambdabot> No matches, try a more general search
11:10:25 <shapr> byorgey: use qc to find both passing and failing test cases, and mix it with profiling to figure out which chunks of code are broken.
11:10:51 <shapr> passing cases would use particular code paths, failing cases would likely use others.
11:10:59 <byorgey> ah, I see
11:11:01 <byorgey> neat
11:11:20 <byorgey> so if there's some piece of code which is used by many failing tests but not by passing ones, it's likely broken?
11:11:28 <shapr> right
11:11:36 <mainland> ndmitchell: are you using sigplanconf.cls? it should default to US-Letter
11:11:46 <lispy> what does this mean:
11:11:47 <lispy> Setup.lhs: QuickCheck.cabal:14: 'Executable' stanza starting with field 'flag splitbase
11:11:48 <shapr> I looked into using hpc for that, but I didn't get very far, life is distracting.
11:11:50 <lispy> description'
11:11:53 <lispy> Is my cabal too old?
11:12:00 <dons> old cabal
11:12:11 <lispy> oy, I really hate this
11:12:26 <mfp> I'm trying to get performance out of the CSV processing snippet, only achieved so-so speed (less than 2X compared to Python), can anybody give it a look? http://hpaste.org/9098
11:12:39 <ndmitchell> mainland: i can't really tell what size .tex i get, but i think the pdf conversion mucks it up - i am using sigplanconf.cls
11:12:43 <lispy> I think one of the most frustrating things about cabal is the prepetual incompatibilities
11:12:50 <dons> mfp: is the python one written in C?
11:12:55 <shapr> mainland: interested in meeting other Haskellers in Boston? I live in Somerville.
11:13:11 <mfp> dons: nope, it's the naïve "CSV parsing"
11:13:21 <dogbite> mfp: glad to see you're working on it
11:13:27 <mfp> dons: but AFAICS parsing is no problem at all; it's processing that is slow
11:13:28 <shapr> byorgey: Do you know of a good way to implement that mix of profiling and qc?
11:13:29 <mainland> ndmitchell: how are you converting to PDF? not pdflatex?
11:13:29 <dons> mfp, i've suspected that [[Row]]
11:13:33 <dons> is inefficent
11:13:37 <mainland> shapr: sure, there are quite a few of us around actually
11:13:43 <ndmitchell> mainland: dvi2pdf
11:13:43 <dons> what data type is used in python?
11:13:44 <shapr> mainland: Who else do you know?
11:13:56 <mfp> dons: a hash, I think
11:14:06 <dons> a hash from string to ?
11:14:21 <mfp> let me see
11:14:31 <mainland> shapr: a number of people here at Harvard
11:14:42 <shapr> mainland: Cool, I only know some from MIT
11:14:47 <shapr> and some from neu.edu
11:14:48 <byorgey> shapr: no idea.
11:14:57 <dons> mfp, how are you compiling it, btw?
11:15:02 <ndmitchell> mainland: i think i've found a flag to dvi2pdf which seems to get it, thanks :)
11:15:18 <mfp> dons: -O2 -funbox-strict-fields
11:15:21 <dons> ok.
11:15:27 <dogbite> dons and mfp: the python code used itertools groupby
11:15:30 <dogbite> and lists
11:15:40 <mainland> ndmitchell: np :) you may also want to check out dvipdfm at some point. it does a better job of converting certain things.
11:15:43 <mfp> http://hpaste.org/9099 <- Python
11:16:15 <ndmitchell> mainland: i think my UI titles it dvi2pdf, but its secretly dvipdfm under the covers
11:16:19 <lilachaze> mfp: might be faster if you merge the 'high' and 'low' loops in makeResult. have you tried profiling it?
11:16:20 <mfp> I assumed that groupBy was creating some sort of hash
11:16:35 <mfp> lilachaze: the prof is in the hpaste
11:16:36 <dons> ./A ~/tmp/IG_US.csv out  0.70s user 0.04s system 76% cpu 0.961 total
11:16:36 <dons> ?
11:17:01 <mfp> dons: with the data generated by the attached Ruby script?
11:17:10 <dons> oh, using dogbit's 10M file.
11:17:25 <PeakerWork> @type runST
11:17:28 <mfp> lilachaze: the profile is attached in the same hpaste   http://hpaste.org/9098
11:17:31 <lambdabot> forall a. (forall s. ST s a) -> a
11:17:33 <sioraiocht> does a lot of copying take place when using Data.Sequence?
11:17:39 <PeakerWork> how come runST doesn't take an initial state?
11:18:03 <PeakerWork> there's no initial state?
11:18:03 <dons> mfp, change unsafePerformIO to inlinePerformIO :)
11:18:08 <dons> $ time ./A ~/tmp/IG_US.csv out
11:18:08 <dons> ./A ~/tmp/IG_US.csv out  0.63s user 0.05s system 99% cpu 0.674 total
11:18:08 <monochrom> What initial state would you like?
11:18:14 <lilachaze> mfp: looks like formatResult is where high and low get forced.
11:18:23 <Deewiant> PeakerWork: what's the initial state in a C function?
11:18:28 <dons> mfp: and ditch the noinline.
11:18:41 <PeakerWork> Deewiant: ok - given an ST that wants a specific initial state, how do I run it?
11:18:46 <dons> mfp: strtod bs = realToFrac . inlinePerformIO . unsafeUseAsCString bs $ \cs -> cstrtod cs nullPtr
11:18:48 <monochrom> What initial state would you like?
11:18:52 <mfp> ok
11:19:00 <PeakerWork> monochrom: a value I have "v"
11:19:30 <monochrom> Are you sure you're after ST? With all its STRef's and STArray's?
11:19:51 <dogbite> mfp: oh, are we trying to speed up the version that uses FFI?
11:20:00 <dons> mfp, its in import Data.ByteString.Internal
11:20:17 <mfp> dons: thanks, I was hoogle'ing for it :)
11:20:18 <dons> dogbite: yeah. down to 0.67s here. using a  Map rather than [[[Row]]]
11:20:36 <dogbite> dons: oh neat
11:20:44 <dons> you could get even better if you'd parse it without splitting into lines first
11:20:44 <monochrom> The "state" of ST is full of dynamically created STRef's.  The "state" is not a value.  How could you wish for a value to be an initial state of ST?
11:21:00 <dons> but  that's more work, of course.
11:21:13 <PeakerWork> monochrom: I want to avoid having to pass around a value -- the state is a set of visited things in the big recursion tree
11:21:27 <monochrom> State, not ST.
11:21:35 <Deewiant> PeakerWork: are you sure you don't want State?
11:21:50 <PeakerWork> I could use State - but isn't ST magically faster? ;-)
11:21:58 <mfp> dons: I changed strtod as you said, it's not faster here (actually a bit slower) :-|
11:22:09 <Deewiant> ST is more like IO than State from what I understand
11:22:10 <dons> got a lot faster here.
11:22:15 <dons> let me post the code.
11:22:19 <monochrom> RacingCar is magically faster too, but it doesn't fit your problem.
11:22:23 <Deewiant> :-D
11:22:29 <PeakerWork> Maybe I'll change to State, I am still wondering, given a value of type: ST (Set.Set s) a, how do I run it with Set.empty to get the "a"
11:22:38 <edmoore_> before I do this myself, have any mac osx users who use textMate made a literate haskell bundle? i.e. on the does tex syntax colouring etc in the latex bits and haskell colouring/spacing in the code bits?
11:22:39 <Deewiant> I don't think you can have a value of that type
11:22:43 <Deewiant> reading the ST docs
11:22:46 <monochrom> There is no ST (Set.Set s) a
11:23:00 <PeakerWork> oh, I thought ST was just a strict State
11:23:07 <monochrom> Oh I mean you can create one, but runST won't take it. It's a sitting duck.
11:23:09 <Deewiant> no, that's Control.Monad.State.Strict. :-P
11:23:19 <Deewiant> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad-ST.html#t%3AST
11:23:20 <dons> mfp: http://hpaste.org/9101
11:23:20 <lambdabot> Title: Control.Monad.ST, http://tinyurl.com/z6wqn
11:23:24 <mfp> http://hpaste.org/9100 -> 3.8s for the file generated by ruby make_csv.rb (from prev post)
11:23:25 <monochrom> In ST s a, s is not user-customizable.
11:23:43 <mattam> @type zipWith
11:23:44 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
11:23:51 <monochrom> s is there as some phantom type to ensure some safety condition.
11:24:10 <Deewiant> monochrom: why is it exposed to the user, though?
11:24:23 <Deewiant> can't it be hidden behind a type or newtype
11:24:27 <PeakerWork> so if I want a strict State monad, how do I get it?
11:24:38 <Deewiant> PeakerWork: Control.Monad.State.Strict, as I said above.
11:24:38 <Lamperi> En tajunnut.
11:24:45 <dons> mfp, anyway,, from here, do some profiling. the overhead of lots of small bytestrings might be the final bottleneck.
11:25:33 <PeakerWork> Deewiant: oh I missed that, thanks
11:25:35 <monochrom> The safety condition concerns every pair of user routines.
11:26:15 <mfp> dons: this is what the .prof is telling me from the beginning http://hpaste.org/9098#a1   don't see the ByteStrings there :-|
11:26:49 <mfp> ah you've made some foldls strict
11:26:54 <dons> oh interesting. grouping and formatting.
11:27:22 <mfp> oops mine were strict too but I changed that to see if there was a diff --- none perceptible
11:27:59 <monochrom> Suppose GHC provided BadST a.  You then write:  p1 :: BadST (BadSTRef Int); p1 = newBadSTRef 0; p2 :: BadSTRef Int -> BadST Int; p2 r = readBadSTRef r.
11:28:08 <sioraiocht> does the append on Data.Sequence cause a complete recopy of the original sequence?
11:28:33 <monochrom> Then you run: let r = runBadST p1 in runBadST (p2 r).
11:29:09 <hackage> Uploaded to hackage: uhexdump 0.1
11:29:19 <PeakerWork> I use "import Control.Monad(forM)" and do use forM, but I get "Warning: Module `Control.Monad' is imported, but nothing from it is used" -- weird
11:29:19 <monochrom> Hmm I cannot make this example break.  Please see the ST paper.  It has a counterexample.
11:29:30 <mfp> same ~3.7s with your version, dons  (again, with the data generated by  http://hpaste.org/9098#a2 )
11:29:40 <lilachaze> monochrom: try using writeBadSTRef also, and passing p1 to multiple such functions
11:29:41 <Deewiant> monochrom: heh, gotcha. :-)
11:30:08 <jethr0> sioraiocht: in haskell all copies are shared where possible
11:30:38 <jethr0> generally
11:30:49 <sioraiocht> jethr0: thanks! I assumed so, otherwise purely functional data structures wouldn't be very useful..
11:31:07 <marcot> Isn't it a good policy for modules to export all types that it's top-level functions uses, that are not in Prelude?
11:31:13 <lispy> Does anyone know why QC on hackage isn't version 2?
11:31:49 <jethr0> marcot: it's going to be hellish to keep up to date in view of code changes though
11:31:50 <dons> no maintainer, lispy.
11:31:57 <dons> lispy: but andyjgill's working on it.
11:32:06 <marcot> For instances, Control.Exception defines throwTo, which uses ThreadId, which is only exported by GHC.Conc or Control.Concurrent.
11:32:48 <Deewiant> I suppose you can only /get/ a ThreadId by importing one of the latter anyway, so there's no point in exporting it?
11:32:58 <marcot> When someone imports Control.Exception, and defined a function that calls throwTo and wants to add a type signature using ThreadId, it has to import Control.Concurrent just to get the type signature.
11:33:08 <lispy> dons: hmm...so it will end up there?
11:33:20 <lispy> dons: and I shouldn't go upload it now because that would conflate the issue?
11:33:35 <mfp> there's no alternative to Text.Printf if I want %.2f, is there? vixey told be about Text.PrettyPrint, but it doesn't seem to do what I want (I assume pretty-printing is even slower than printf too) :-S
11:33:41 <dons> lispy: yeah, i'd wait.
11:33:48 <dons> mfp: just for printing floats?
11:33:49 <marcot> Deewiant: but you can be doing in this module a function that will receive the ThreadId and send it to throwTo, but the ThreadId is not going to be generated in this module.
11:33:53 <Deewiant> mfp: what's wrong with printf? :-P
11:34:01 <dons> mfp: look in Numeric.hs
11:34:07 <Deewiant> marcot: yeah, I suppose.
11:34:08 <vixey> @src Printf
11:34:08 <lambdabot> Source not found. Sorry.
11:34:09 <marcot> Deewiant: so you'll have to import ThreadId just to make the type signature...
11:34:10 <mfp> just for printing   "%s,%0.2f,%0.2f,%0.2f,%0.2f,%s"
11:34:11 <dons> :t showFFloat
11:34:12 <lambdabot> forall a. (RealFloat a) => Maybe Int -> a -> String -> String
11:34:17 <vixey> @src printf
11:34:17 <lambdabot> Source not found. It can only be attributed to human error.
11:34:20 <dons> > showFFloat (Just 2) pi ""
11:34:23 <lambdabot>  "3.14"
11:34:26 <mfp> Deewiant: .prof says it's taking > 35% of the time
11:34:52 <mfp> would that be faster than printf with the above fmt?
11:34:54 <lispy> oh does it do roundin too?
11:34:57 <marcot> My point is that I'm doing a program which generates interleavableIO version of IO functions, module by module... It's working fine for generating modules without type signature, but when I want type signature I have to import some other things.
11:35:23 <lispy> > showFFloat (Just 2) 3.147 ""
11:35:24 <lambdabot>  "3.15"
11:35:52 <PeakerWork> I get "Warning: Module `Control.Monad' is imported, but nothing from it is used," for an import that is required
11:36:00 <PeakerWork> (not for instances)
11:36:06 <Deewiant> PeakerWork: if you remove it, does the code still compile?
11:36:17 <PeakerWork> Deewiant: no
11:36:24 <Deewiant> meh, that's a bug then
11:36:33 <PeakerWork> http://hpaste.org/9102
11:36:44 <PeakerWork> I import forM that way - and it is complaining
11:36:49 * bitrot is amazed by the usefulness of zipWith
11:37:50 <PeakerWork> if everything was an instance of DebugShow, I could get a more informative dump than "solve: Map.find: element not in the map" :-(
11:39:52 <byorgey> bitrot: =)
11:41:39 <MichaelGG> If I really wanted to understand Haskell, what prerequsites should I study?
11:42:15 <monochrom> highschool algebra
11:42:46 <MichaelGG> thats enough to start to get into everything else?
11:43:08 <monochrom> It is the spirit behind algebra I'm after.
11:43:17 <jethr0> MichaelGG: you might have a look at the book "structure and interpretation of computer programs", but the best way is to take one of the tutorials and just dive in head-first ;)
11:43:25 <dogbite> MichaelGG: very broad question
11:43:28 <mainland> if you really want to understand Haskell, write Haskell
11:43:33 <byorgey> MichaelGG: it depends what you mean by "really understand Haskell". =)
11:43:38 <monochrom> You know how some people look at "y = f (g (h x))" and say "OMG my head hurts".
11:43:38 <Deewiant> understanding category theory requires a bit more than that
11:43:39 <MichaelGG> SICP is a good book :)
11:43:46 <MichaelGG> Deewiant yes that kind of stufff
11:43:51 <Deewiant> but you don't need to understand category theory to understand haskell.
11:43:51 <MichaelGG> What I mean is understand the theory behind it
11:43:52 <byorgey> MichaelGG: you mean "be really good at writing Haskell programs"?  or "understand the formal foundations of Haskell"?
11:44:00 <MichaelGG> formal foundations
11:44:15 <monochrom> But if you write them "x1 = h x; x2 = g x1; y = f x2" they magically understand.
11:44:19 <MichaelGG> The Real World Haskell book seems pretty good at getting peopel going on 'programming'
11:44:21 <byorgey> ah, then you want formal logic, type theory, algebra, category theory...
11:44:39 <MichaelGG> Is that something feasible for self study?
11:44:40 <Deewiant> where algebra > highschool algebra
11:44:44 <Baughn> monochrom: We all agree that form is considerably harder to read, right?
11:44:51 <byorgey> yes, I mean like abstract algebra
11:44:54 <byorgey> MichaelGG: sure.
11:45:29 <idnar> Baughn: yes
11:45:30 <monochrom> They know long-winding sequences of state changing imperative commands but not y = f (g (h x)).  I think it points towards algebra skill.
11:45:45 <marcot> So shouldn't Control.Exceptions exports ThreadId?
11:45:50 <idnar> Baughn: unless x1 and x2 are highly meaningful in and of themselves
11:46:01 <jethr0> Michealgg: have you read TaPL?
11:46:14 <MichaelGG> no
11:46:16 <MichaelGG> I'll get that
11:46:26 <byorgey> yeah, that's a great place to start
11:46:27 <monochrom> So even highschool algebra is nice enough because it's full of y = f (g (h x)).  But you need an A+ on highschool algebra.  Just passing is not enough.  Due to grade inflation.
11:46:42 <MichaelGG> I dropped out of highschool to actually do software development (over 10 years ago). For C style dev this isn't much of a drawback
11:47:11 <MichaelGG> But I've been moving to F# and finding that some things end up a bit beyond me
11:47:11 <jethr0> MichaelGG: i'm not saying it's what you're looking for. it was a bit dense for me, but supposedly it's really good and should get you started on the typing background
11:47:58 <MichaelGG> monochrom yea the first time I saw function application and composition it threw me for a bit. then my eyes just opened wide :)
11:47:59 <mfp> > showFFloat (Just 2) pi "foo"
11:48:01 <lambdabot>  "3.14foo"
11:48:07 <jethr0> MichaelGG: seriously, theoretical background is important. but at least for me just writing advanced code helped me more than reading up on typing theory. plus it was more fun.
11:48:22 <jethr0> i'm not dissing theory, just saying that i can sometimes be slow to take it in
11:48:42 <MichaelGG> I'm interested in Haskell because it seems that it's going to be more rigorous than F#
11:49:04 <MichaelGG> I think someone put it as "it'll fuck with your brain and you'll like it"
11:49:11 <Armored_Azrae1> MichaelGG: Additionally, you may want to look at SML. It'll be more imperative like you're used to, while still having strict typing and functional programming
11:49:13 <jethr0> it's pretty hard to be more rigourous than haskell (at least that's how i feel sometimes)
11:49:28 <idnar> rigorous in what sense?
11:49:31 <MichaelGG> Armored_Azrae1 yea, F# is just a OCaml + .NET
11:49:36 <dublpaws> I've generated a moderately large source file with a list of ~1000 lists which contain about 1000 ints. GHC is taking a long time to compile it. any suggestions on speeding it up?
11:49:48 <MichaelGG> well being pure instead of having imperative shortcuts all around?
11:50:02 <jethr0> idnar: in a sense of not softening the theoretic underpinning for convenience
11:50:17 <Toxaris> jethr0: consider a language without type inference
11:50:28 <MichaelGG> ok, well not "just" but it can cross compile ML and most OCaml, but has .NET around so I can integrate it into my commercial work :)
11:50:29 <Botje> dublpaws: can you abstract all those ints to a different file?
11:50:38 <Deewiant> dublpaws: load the data at program startup instead? put the data in a C file and access it through there?
11:50:42 <Botje> then you only have to compile it once
11:51:09 <jethr0> Toxaris: true, but since it can be derived, that doesn't really count...
11:51:19 <shapr> y0 jethr0, long time no see!
11:51:23 * shapr hugs jethr0
11:51:24 <jethr0> @shapr
11:51:24 * lambdabot is overcome by a sudden desire to hurt
11:51:34 * jethr0 blushes
11:51:37 <idnar> @shapr jethr0
11:51:37 * lambdabot karate-chops jethr0 into two equally sized halves
11:51:38 <shapr> w00! I am violence!
11:51:41 <vixey> um..
11:51:42 <jethr0> shapr: how've you been
11:51:42 <Toxaris> jethr0: for interesting type systems, type inference is undedicable
11:51:44 <MichaelGG> Thanks for the recommendations guys
11:51:52 <dublpaws> I'm trying to avoid IO. yeah, I was thinking of putting it in a C file. Will look more into that.
11:51:56 <shapr> jethr0: life is exciting
11:52:00 <vixey> Toxaris: you're forgetting STLC and ML!
11:52:05 <jethr0> where are you at, currently?
11:52:12 <Toxaris> vixey: STLC?
11:52:21 <shapr> jethr0: living in Boston, but currently in alabama visiting family
11:52:34 <shapr> jethr0: speaking of which, I gotta drive off to north AL
11:52:35 <vixey> simple typed lambda calculus.. hmm maybe you can't infer types for it ... but type schemes
11:52:48 <shapr> jethr0: would like to chat with you more later :-)
11:52:52 <andyjgill> lispy: Yes, Koen and I are working on releasing QC2.
11:53:01 <monochrom> SML has a published formalized operational semantics. Haskell doesn't yet.
11:53:05 <Toxaris> vixey: yeah, my definition of "interesting" is somewhat driven by the desire to express existential types :)
11:53:06 <shapr> andyjgill: yay!
11:53:21 <vixey> mm I am not sure what existential are
11:53:23 <jethr0> shapr: sure, i'll be here some longer
11:53:28 <shapr> andyjgill: I'd like to add Test Driven Dev support
11:53:34 <shapr> jethr0: doubt I'll be back online today, sadly
11:53:38 <dons> shapr: did you see the ocaml job going in boston..
11:53:45 <shapr> dons: nah, tell me?
11:53:52 <vixey> but that's programming in the type system isn't it? So you wouldn't want it to be infered
11:53:56 <vixey> or is that false?
11:54:01 <dons> http://groups.google.com/group/cufp/browse_thread/thread/37ca54f6fdf9f9e8
11:54:03 <lambdabot> Title: Ocaml-related jobs, Boston area. - CUFP | Google Groups, http://tinyurl.com/63zvhv
11:54:23 <dons> i'll also mention the CUFP program is up,
11:54:25 <dons>   http://www.reddit.com/r/programming/info/6sy76/comments/
11:54:26 <lambdabot> Title: programming: F#, Erlang, OCaml, Haskell: Commercial Users of Functional Programm ...
11:54:27 <Toxaris> vixey: yeah in a sense, it can not be inferred because there is more then one option, meaning different things, so I "program" by choosing one of them
11:54:33 <shapr> dons: thanks!
11:54:40 <monochrom> Oh, of course you can say "but no need for operational for Haskell, it's just non-strict, denotational will do".  But Haskell doesn't have a published formalized denotational semantics either yet; and its I/O fragment certainly needs an operational semantics anyway.
11:54:43 <PeakerWork> what's an elegant way to remove all items that are smaller than previous items in a list?
11:55:00 <PeakerWork> I have an ugly big function to do it
11:55:14 <Toxaris> via stack overflow, operational semantics *is* important even ignoring IO
11:55:18 <rwbarton> :t nubBy
11:55:19 <lambdabot> Not in scope: `nubBy'
11:55:38 <ksandstr> PeakerWork: i assume a mapaccum and a concat aren't considered elegant?
11:55:46 <PeakerWork> rwbarton: nubBy is not the right solution, I think.. It will check a lot more than needs to be (given transitivity of (>))
11:55:57 <rwbarton> You said elegant :)
11:55:58 <MichaelGG> F# should make a huge impact. Just as easy as C# for imperative people, ships with VS....
11:56:00 <PeakerWork> ksandstr: I don't know what mapaccum is...
11:56:10 <PeakerWork> rwbarton: I think it doesn't work either -- I tried a few examples
11:56:28 <rwbarton> I was guessing... let's see
11:56:34 <monochrom> mapaccum is mapAccumL and mapAccumR in Data.List.  But I don't see how to use them either.
11:56:39 <rwbarton> > Data.List.nubBy (<) [1, 5, 2, 7, 3, 4]
11:56:40 <lambdabot>  [1]
11:56:48 <rwbarton> > Data.List.nubBy (>) [1, 5, 2, 7, 3, 4]
11:56:49 <lambdabot>  [1,5,7]
11:57:28 <Deewiant> > groupBy (<) [1,2,3,1,2,3,2,4]
11:57:29 <lambdabot>  [[1,2,3],[1,2,3,2,4]]
11:57:32 <Deewiant> hm
11:57:36 <Deewiant> that didn't quite work
11:57:45 <PeakerWork> > Data.List.nubBy (>) [1, 2, 2]
11:57:46 <lambdabot>  [1,2,2]
11:57:54 <PeakerWork> I don't want repetitions
11:58:02 <Toxaris> > Data.List.nubBy (>=) [1, 2, 2]
11:58:04 <lambdabot>  [1,2]
11:58:25 <PeakerWork> now (>=) seems to eliminate those, but I don't understand what (>=) has to do with anything :)  I want it to be (>)...
11:58:40 <PeakerWork> and (>=)'s relation to (>) here seems wrong
11:58:53 <Deewiant> if an element later is >= to any previous element, it is removed
11:58:56 <PeakerWork> I mean, when its (>) and when its (==) are differing cases
11:59:16 <PeakerWork> Deewiant: but that's not the case - if its > its kept, and if its == its removed
11:59:17 <Deewiant> if you want to be stubborn you can do nub . nubBy (>) :-P
11:59:34 <monochrom> > Data.List.nubBy (>) [1,2,2,1,0]
11:59:35 <lambdabot>  [1,2,2]
11:59:37 <Deewiant> @src nubBy
11:59:37 <monochrom> > Data.List.nubBy (>=) [1,2,2,1,0]
11:59:37 <lambdabot> nubBy eq []             =  []
11:59:37 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
11:59:37 <PeakerWork> Deewiant: Its not about stubborness at this point - I am really puzzled about how (>=) can be right, here
11:59:38 <lambdabot>  [1,2]
11:59:43 <rwbarton> At a guess I'd say there's a flip involved between the way nubBy works and the way you're thinking of your task
11:59:51 <rwbarton> i.e. flip (>=) = (<=)
12:00:03 <PeakerWork> rwbarton: ah!
12:00:35 <PeakerWork> ok, now is there an elegant way to use the transitivity of (>) so that it only compares (>) against the max, and not against all of the prevs?
12:00:39 <Toxaris> but nubBy clearly is the wrong thing to do operationally, so why are we proposing it?
12:00:43 <ksandstr> > concat $ snd $ mapAccumL (\a x -> if a >= x then (x, []) else (x, [x])) 0 [1, 5, 2, 7, 3, 4]
12:00:46 <lambdabot>  [1,5,7,4]
12:01:59 <ksandstr> though that removes items that are smaller than the immediately preceding item
12:02:32 <Toxaris> > scanr max [1, 5, 2, 7, 3, 4]
12:02:34 <lambdabot>  <[[Integer]] -> [[Integer]]>
12:02:44 <Toxaris> > scanr max 0 [1, 5, 2, 7, 3, 4]
12:02:45 <lambdabot>  [7,7,7,7,4,4,0]
12:02:53 <Toxaris> > scanl max 0 [1, 5, 2, 7, 3, 4]
12:02:54 <lambdabot>  [0,1,5,5,7,7,7]
12:02:54 <Deewiant> > scanl max 0 [1,5,2,7,3,4]
12:02:55 <lambdabot>  [0,1,5,5,7,7,7]
12:03:00 <PeakerWork> Toxaris: nice :)
12:04:45 <mfp> this sucks >_<   printf "%s,%0.2f,%0.2f,%0.2f,%0.2f,%s"  expands to 13 lines and I get no speed in exchange
12:04:50 <mfp> http://hpaste.org/9104
12:05:15 <Toxaris> > map snd . filter (uncurry (<)) . join (zip . scanl max 0) $ [1,5,2,7,3,4]
12:05:16 <lambdabot>  [1,5,7]
12:06:08 <Toxaris> but the l in scanl may be problem for large lists
12:06:25 <vixey> l for large ?
12:06:26 <Toxaris> but i'm not sure. scanl works like foldl, right?
12:06:28 <PeakerWork> Toxaris: isn't it the other way around?
12:06:42 <PeakerWork> > take 5 $ scanl max 0 [1,2..]
12:06:43 <lambdabot>  [0,1,2,3,4]
12:06:47 <PeakerWork> > take 5 $ scanr max 0 [1,2..]
12:06:48 <lambdabot>  [Exception: stack overflow
12:07:00 <Toxaris> great!
12:07:08 <dolio> Why would you expect that to be faster?
12:07:28 <PeakerWork> dolio: I don't - I was wondering which one is going to work on infinite lists
12:07:39 <dolio> No, mfp.
12:08:04 <monochrom> expect faster because bytestring, I guess. :)
12:08:21 <Toxaris> > take 3 . map snd . filter (uncurry (<)) . join (zip . scanl max 0) $ [1,5,2,7,3,4] ++ undefined
12:08:36 <lambdabot>  thread killed
12:08:40 <dolio> shows/show*Float uses String just like printf.
12:08:52 <mfp> dolio: well, I wanted to believe it'd be faster; I want to replace that printf "%s,%0.2f,%0.2f,%0.2f,%0.2f,%s"  since it's taking 1/3rd of the time
12:09:34 <mfp> at least it doesn't parse the fmt string at runtime
12:10:14 <monochrom> It's probably parsed fewer times than called.
12:10:35 <pozic> Is it wrong to write an instance for Eq for a type describing ranges and saying that a single point range equals a range that contains this point?
12:10:36 <PeakerWork> oh actually scanl max does keep equal elements...
12:10:41 <PeakerWork> oops. I need it not to :)
12:11:44 <monochrom> pozic: I wonder why you want to do it but you can do it but expect some surprises from library functions that use Eq.
12:11:46 <PeakerWork> Toxaris: nub . scanl may be good
12:12:18 <Toxaris> pozic: according to the docs, you can implement Eq however you like
12:12:18 <PeakerWork> but its again operationally wrong
12:12:44 <pozic> monochrom: it is to simplify some code. Thanks.
12:12:59 <Toxaris> PeakerWork: I guess a hand-made recursive function with an accumulator for the maximum so far is best for this job
12:13:12 <Toxaris> PeakerWork: why write something now which you will not understand tomorrow
12:13:15 <PeakerWork> Toxaris: That's the "ugly big function" I had. there's the ksandstr suggestion too
12:13:33 <Toxaris> Toxaris: what's your definition of "big"? more then one line?
12:14:39 <Toxaris> pozic: but I would expect (a == b) && (b == c) ==> (a == c) to hold, which your instance probably would violate
12:14:58 <Toxaris> pozic: (consider a and c singleton intervalls, and b containing both)
12:15:37 <pozic> Toxaris: yes, transitivity does not hold.
12:15:56 <pozic> Toxaris: I will not rape the normal semantics of Eq then, just for you :)
12:16:30 <Toxaris> pozic: maybe Ord would be better, with a < b if a is completely covered by b?
12:16:54 <Toxaris> pozic: but by all means, implement what fits your application
12:18:36 <mfp> .oO(I'll try to pack into some ByteStrings (I'm missing some writeFloat :: RealFloat a => a -> ByteString) and cons them, to finally hPut the thing at once)
12:19:13 <PeakerWork> words/unwords could be nice if they were just currying of something else with the ' ' delimiter..
12:20:33 <Toxaris> PeakerWork: ksandstr's version looks not so bad to me, but I would replace one of the x on the rhs by a to arrive at your semantic
12:20:47 <shepheb> I've often wished for a function split :: (a -> Bool) -> [a] -> [[a]], such that words = split isSpace
12:21:10 <Toxaris> PeakerWork: and I would use Maybe and catMaybes instead of [] and concat
12:21:31 <Toxaris> shepheb: but why not so that lines = split (== '\n')?
12:21:49 <shepheb> yeah, I recognize the problem.
12:22:19 <Toxaris> I think we need linesBy and wordsBy, so we have at least these special cases somewhat generalized
12:22:49 <Toxaris> (it's an arbitrary selection of special cases, of course, but every Haskell programmer could immediately understand the meaning of the functions)
12:23:02 <shepheb> wouldn't a wordsBy be my split, linesBy yours? I could run with those names. provides something of a mnemonic for which has which semantics
12:23:16 <PeakerWork> Toxaris: why is the above lines = split (== '\n') a problem?
12:23:20 <Deewiant> how are lines and words different?
12:23:29 <shepheb> doesn't lines leave [] in for blanks?
12:23:36 <Deewiant> er, out of context, that sounds like a quite stupid question ^_^
12:23:46 <shepheb> > lines "testing\n\nthis"
12:23:47 <lambdabot>  ["testing","","this"]
12:23:55 <Deewiant> > words "testing   this"
12:23:55 <shepheb> > words "testing   this"
12:23:56 <lambdabot>  ["testing","this"]
12:23:56 <lambdabot>  ["testing","this"]
12:24:07 <Deewiant> meh
12:24:29 <PeakerWork> oh, why isn't that simply   filter null . words, instead of words?
12:24:42 <PeakerWork> I mean, why does words already force the filtering upon its user?
12:25:05 <Deewiant> filter (not . all isSpace) rather than filter null, no?
12:25:08 <shepheb> I suppose its primary use case is parsing commands with arguments
12:25:16 <Deewiant> or, well
12:25:24 <Deewiant> > lines "testing\n\n\n\n\nthis"
12:25:26 <lambdabot>  ["testing","","","","","this"]
12:25:38 <Deewiant> yeah, that makes sense I guess
12:25:53 <Deewiant> but (not.null) instead of null, anyway ;-)
12:26:01 <shepheb> wordsBy = filter (not.null) . linesBy, then
12:26:08 <Toxaris> @check (\x -> lines x == words (map (\x -> if x == '\n' then ' ' else x) x))
12:26:09 <lambdabot>  OK, passed 500 tests.
12:26:12 <Toxaris> :(
12:26:22 <vixey> there's no way to do multiline strings is there?
12:26:32 <Toxaris> > words "trailing whitespace "
12:26:33 <lambdabot>  ["trailing","whitespace"]
12:26:36 <Deewiant> not on IRC, at least. :-P
12:26:46 <Toxaris> > lines "trailing\nnewline\n"
12:26:47 <lambdabot>  ["trailing","newline"]
12:26:56 <Toxaris> hmm no difference on this front
12:27:06 <Deewiant> how 'bout leading
12:27:21 <shepheb> > lines "\nleading and trailing\nnewlines\n\n"
12:27:22 <lambdabot>  ["","leading and trailing","newlines",""]
12:27:23 <Toxaris> vixey: IIRC "..." \\n "..."
12:27:48 <Toxaris> vixey: that is, finish the string, escape the newline, start a new string. but this may well be totally nonsense
12:27:59 <shepheb> > words "  x y     z    "
12:28:00 <lambdabot>  ["x","y","z"]
12:28:06 <shepheb> yeah, command parsing for sure.
12:28:20 <Deewiant> meh, words sucks :-P
12:28:26 <Toxaris> I think lines and words are for showcasing the interact construct
12:30:10 <Toxaris> vixey: http://book.realworldhaskell.org/beta/escapes.html#id421356
12:30:12 <lambdabot> Title: Appendix B. Characters, strings, and escaping rules
12:30:34 <vixey> thanks
12:34:31 <pozic> How can I express that a certain function has logical symmetrical semantics? That is, I defined one side of the symmetry, and the rest is inferenced in some way?
12:34:51 <nominolo> @seen swiert
12:34:52 <lambdabot> I haven't seen swiert.
12:35:02 <vixey> pozic: you mean like x `r` y == y `r` x ?
12:35:11 <pozic> vixey: right
12:35:20 <vixey> you can write
12:35:25 <vixey> Foo `r` Bar
12:35:29 <vixey> Bar `r` Bar
12:35:30 <vixey> ...
12:35:32 <vixey> y `r` x = x `r` y
12:35:49 <vixey> just ensure the pattern match fall through will be caught by the symmetry rule
12:36:02 <vixey> (that is, everything before and including the ...)
12:40:07 <Leaves> When I write a small script, should I use   module Main where   or is it also ok if I just directly write main = dasdas and the other functions below?
12:40:36 <mc__> Leaves: writing "module Main" probably wont hurt
12:40:57 <monochrom> it's fine both ways
12:41:18 <sjanssen> Leaves: if there is no explicit module at the top, 'module Main' is inserted implicitly
12:41:31 <Leaves> ok, by the standart also, not just ghc?
12:41:58 <monochrom> Yes.
12:42:00 <erikc> for all practical purposes, isnt ghc the standard at this point?
12:42:20 <mc__> I heard some prefer hugs for development
12:42:58 <Leaves> okay, thanks, about standard, I don't know but I only want to use _the_ standard since that one will be supported for a long time
12:43:00 <mc__> because it loads files fastere
12:43:02 <jethr0> erikc: at least in this channel, ghc seems to be used by a clear majority
12:43:28 <vixey> GHC has hackage, does hugs?
12:43:39 <erikc> ah, ghc just seems to me to have so many useful extensions (that will be in haskell' eventually) that it is effectively haskell'
12:44:17 <chrisdone> will haskell' have lenses?
12:44:24 <jethr0> or bananas
12:44:39 <chrisdone> bananas are an incomplete abstraction
12:44:45 <jethr0> hehe
12:45:08 <shepheb> we already have category-extras, what's missing from that?
12:45:40 <dolio> You won't get something into Haskell' if it's just in GHC.
12:45:53 <dolio> At least, you're not supposed to be able to do so.
12:46:13 <chrisdone> maybe just a ghc lenses extension
12:48:28 <jethr0> dolio: why not? can't you propose it theoretically and give one proof of concept (in this case ghc implementation)?
12:49:30 <dolio> Haskell' is supposed to be for widely implemented extensions.
12:50:05 <dolio> There may be exceptions.
12:50:38 <dolio> It's possible something type-families like would go in, rather than functional dependencies.
12:50:59 <dolio> Since that's one reason the standard's been held off for a long time, allegedly.
12:53:23 <shepheb> well, you can use another computer as a base station of sorts, with just the binary on your eeepc
12:53:26 <shepheb> mischan
12:54:27 <vixey> does this look right? http://hpaste.org/9106
12:54:38 <PeakerWork> hey, any idea why this is rapidly growing in memory consumption? http://hpaste.org/9105
12:55:48 <PeakerWork> this is the Board stuff, though I don't think it is responsible http://hpaste.org/9107
12:56:09 * vixey notices the mistake -_-
12:56:20 * vixey leaves it as a puzzle for very bored people :p
12:56:25 <PeakerWork> vixey: my mistake?
12:56:32 <PeakerWork> vixey: please do? :)
13:00:50 <Leaves> is it normal to use a lot of recursion in haskell scripts? I use it all the time but I have the idea that's just because I don't know enough 'functional haskell functions' :)
13:01:29 <monochrom> it's normal for beginner. don't worry. if you find something useful it the library that's cool.
13:02:16 <PeakerWork> what RTS flag do I use to print some memory information?
13:03:29 <jethr0> PeakerWork: that's funny, i was working on a tic tac toe game for the haskell quiz as well, just a few hours ago ;)
13:03:31 <Leaves> I can use the map function to find the triangles, triangles = map (\n -> sum [1..n]) [1..], but this is very inefficent ;), but then I have to fall back to using recursion: triangles = s 0 1 where s c n = (c+n):(s (c+n) (n+1)), could this also be efficiently be done without recursion?
13:03:42 <yitz> PeakerWork: just curious. why is solve' in a State monad when it apparently doesn't use the state at all?
13:03:42 <lambdabot> yitz: You have 1 new message. '/msg lambdabot @messages' to read it.
13:03:55 <PeakerWork> yitz: I cancelled it out for debugging, but the code is there
13:03:56 <Botje> Leaves: the scanl function can help.
13:04:15 <Botje> ask yourself what the difference is between row n and row n+1
13:04:22 <PeakerWork> jethr0: this isn't minimax though, because there are no opposing sides -- just a board to solve
13:04:55 <jethr0> PeakerWork: i wasn't doing minimax. i am currently trying to build a nice genetic algorithm to learn tic tac toe by selection.
13:04:58 <PeakerWork> yitz: see the commented code? Is there a nicer way to do this?
13:05:19 <PeakerWork> jethr0: ah, but I think these sorts of games are so easy to solve perfectly with alpha-beta or the more advanced stuff :)
13:05:35 <Leaves> Botje: aah, thanks, I think that's exactly what I'm looking for :)
13:06:00 <jethr0> but i'm having difficulties enumerating the canonical possible board positions. there are only 50 possible, canonized, non-finished board positions (if i made no mistakes), but i haven't yet found a way to map those bi-directionally to [1..50]
13:06:04 <zachk> tic tac toe is fun
13:06:31 <jethr0> PeakerWork: i agree. but the quiz said "without the algorithm having any knowledge of the game" and minimax assumes alternating moves, etc.
13:06:43 <zachk> jethr0: there is only about 300,000 boards period
13:06:49 <PeakerWork> jethr0: I use a simpler trick - I use: canonize board = minimum $ equivalents board ;   equivalents board = nub $ [equivalent | rotated <- rotations board, equivalent <- [rotated, mirror rotated]]
13:06:54 <jethr0> > 3^9
13:06:58 <lambdabot>  19683
13:07:02 <BMeph> I thinl this is the most fun thing about Haskell - usually, if there's an awkward way to do something, it's a sign that there's some "more advanced" function out there that you haven't learned yet.
13:07:21 <zachk> jethr0: factorial 9 for actual play
13:07:27 <PeakerWork> jethr0: yeah, just hide the fact you negate the result each turn behind a typeclass
13:07:41 <PeakerWork> zachk: factorial 9 is an upper bound, not the actual number
13:07:50 <jethr0> PeakerWork: i map boards into integers by "sum $ zipWith (*) boardPositions (iterate (*3) 1)"
13:08:01 <jethr0> zachk: no, that's sequences, i was talking about unique boards
13:08:04 <PeakerWork> zachk: because of unexpected wins, and equivalences between rotated/mirrored boards
13:08:24 <PeakerWork> jethr0: why?
13:08:30 <PeakerWork> jethr0: why not have a canonize like that?
13:08:46 <jethr0> PeakerWork: huh?
13:08:57 <PeakerWork> jethr0: why does it have to become a number, and not just another board?
13:09:41 <jethr0> PeakerWork: i wanted to do easy IntMap lookups, and also it seemed easier to work with numbers for genetic algorithms than with structured data types
13:10:45 <PeakerWork> jethr0: I think mapping it to a number mathematically might be more challenging. Programmatically, you can just keep a Data.Bimap of boards to numbers, and update it with unencountered canonized boards
13:11:26 <jethr0> since there seem only to be 50 unique possible canonized boards, a lookup of the kind "CanonizedBoard -> Coord" should be easy, with only 50 entries for the dictionary to play a perfect game
13:12:13 <jethr0> the problem with my genetic algorithm currently is that i have to cover all "possible" 19000 boards of my current int mapping, and it will probably never find the 50 valid ones by itself just by selection.
13:12:14 <PeakerWork> Control.Monad.State.Strict seems to be strict in its result, and not just the state (my result is not dependent on the state, but it still waits for the whole computation to complete)
13:12:19 <jethr0> at least it's gonna take a long time
13:13:09 <PeakerWork> jethr0: I still don't understand why not take the minimum of all the rotations/mirrorings possible as a key to the bimap to integers
13:13:13 <yitz> PeakerWork: ok. looks ok to me, though in monads I prefer when and until over if-then-else. or any other way to try to get rid of if-then-else. that's just style though.
13:13:28 <jethr0> PeakerWork: i don't understand that
13:13:38 <yitz> PeakerWork: in particular, I didn't notice what vixey noticed :)
13:14:17 <PeakerWork> jethr0: if your board-state has an Ord instance, you can use minimum on the list of possible rotations/mirrorings of the board, to get a "canonized" board form for it
13:14:34 <PeakerWork> jethr0: then you can use that canonized form as a key in a Bimap to integers to create the mapping to the 0..50 integers
13:14:36 <yitz> PeakerWork: at work late today, aren't you.
13:14:41 <PeakerWork> yitz: yeah :)
13:14:56 <PeakerWork> yitz: I am pretty much done, just wanted to finish this little game (which I wrote while waiting for some runs to complete :-)
13:15:13 <PeakerWork> yitz: I think vixey is lying, just like Fermet :)
13:15:17 <jethr0> PeakerWork: how do i know which integer to assign to a specific board in isolation?
13:15:34 <PeakerWork> jethr0: if you have never seen it before, assign it to 0. Then 1, ...
13:15:49 <yitz> PeakerWork: Fermat wasn't lying, he just didn't know the true reason behind what he said.
13:16:00 <PeakerWork> yitz: he said he had a proof
13:16:02 <PeakerWork> yitz: wrote, that is
13:16:05 * vixey was thinking about her own code ...
13:16:10 <vixey> (and hpaste)
13:16:14 <jethr0> PeakerWork: yes, i agree, but my genetic algorithm won't have that kind of knowledge. never mind, i'm making things difficult on purpose
13:16:18 <PeakerWork> vixey: oh, sorry :)
13:16:27 <Zao> Well, Fermat wrote down the proof, on the edge of the paper in a very small hand.
13:16:45 <jethr0> Zao: and ran out of space!
13:16:57 <yitz> Zao: so small that we just couldn't see the stuff about elliptic curves.
13:17:01 <Zao> jethr0: It continues along the bottom of the page :P
13:17:10 <PeakerWork> yitz: maybe there is a 10-line simple proof :)
13:17:18 <PeakerWork> did anyone try out all possible proofs <= some size? :)
13:17:33 <yitz> PeakerWork: of your memory leak, or of Fermat?
13:17:40 * vixey has done that with programs
13:17:55 <PeakerWork> yitz: both
13:18:07 <PeakerWork> vixey: is that approach useful?
13:18:12 <vixey> no
13:18:13 <yitz> Zao would say that Fermat's quickcheck properties must have been on the back of the page.
13:18:13 <opqdonut> :D
13:20:23 * bitrot wonders how hot his laptop can *really* get...80C was scary to see.
13:20:55 * bitrot curses primes
13:21:32 <zachk> this is one of the better explanations ive seen of monads (for people who are newbies) http://www.haskell.org/all_about_monads/html/analogy.html
13:21:33 <lambdabot> Title: A physical analogy for monads
13:22:33 * BMeph primes curses
13:22:41 <yitz> bitrot: once a piece of paper blocked the air vent on my macbook. my screen still looks a little funny to this day.
13:22:46 <jethr0> zachk: yes, the tutorial is quite cool. but no tutorial i've found so far beats just using monads
13:22:59 * jethr0 crimes purses
13:23:15 <bitrot> yitz: yikes!
13:23:28 <byorgey> 80C?!
13:23:28 <zachk> jethr0: they are really scary at first
13:30:07 <zachk> 80C=what?
13:30:07 <Zao> zachk: The manly temperature scale.
13:30:07 <jethr0> > 80*9/5+32
13:30:07 <yitz> 80C=smoke, and the smell of plastic
13:30:07 <lambdabot>  176.0
13:30:07 <vixey> :(
13:30:07 <vixey> the programming language changed and my bubble sort code broke
13:30:07 <zachk> thats kind of warm, i could manage with 0 humidity though, not sure about my enzymes though
13:30:07 <bitrot> byorgey: according to the sensors, yes.
13:30:07 <zachk> vixey: why are you using bubble sort ?
13:30:07 <yitz> vixey: which language?
13:30:07 <zachk> forth?
13:30:07 <vixey> the one I'm implementing
13:30:07 <jethr0> cobol?
13:30:07 <vixey> re-implementing*
13:30:07 <yitz> zachk: forth never changes
13:30:07 <shepheb> my laptop reached 78C the other day compiling something. it damaged my coffee table
13:30:07 <jethr0> so the sheet of paper induced indeterminism into your laptop
13:30:07 <shepheb> though it fortunately seems to be working fine
13:30:07 <jethr0> shepheb: coffee tables tend to be quite resilient
13:30:07 <jethr0> at least operation-wise
13:30:07 <shepheb> jethr0:  :P
13:30:07 <zachk> shepheb: have you considered using your laptop as a heating coaster on your coffee table? to keep drinks hot for you. just need to be compiling when you want your drinks warmed up
13:30:07 <jethr0> make coffee
13:30:07 <byorgey> and flip the laptop upside down for maximum heat transfer into the coffee
13:30:07 <jethr0> make coffee && ./drink
13:30:07 <jethr0> my laptop actually has the exhaust to the side. i can be quite annoyed when it melts my chocolate or heats my water to 30C
13:30:07 <vixey> yitz, if you are curious, this is the code: http://hpaste.org/9106#a1
13:30:09 <jethr0> vixey: that does look a little Forth-ish to me. what's special about the language?
13:32:17 <vixey> jethr0: It's reversibly universal
13:32:30 <monochrom> Haha, "Johan darcs-ate-our-ICFP-submission Tibell"
13:32:32 <yitz> vixey: ok, certainly looks proprietary. :)
13:32:42 <opqdonut> monochrom: :D
13:33:14 <jethr0> our dog ate my homework
13:33:17 <vixey> not sure what you mean
13:33:29 <jethr0> vixey: is that like univerally reversable? ;)
13:33:47 <yitz> jethr0: if your teachers knows about darcs, that would probably sound a lot more plausible than the one about the dog.
13:34:25 <jethr0> darcs never ate any of my code...
13:34:40 <Toxaris> but most teachers know about dogs, and still they tend not to accept the dog excuse
13:34:57 <jethr0> i trust in its elaborate patch-theory
13:35:54 <jethr0> vixey: would you say it's turing complete (certainly looks so)? if so, could backstep and forward step freely?
13:36:08 <yitz> jethr0: darcs eats things when you hit the exponential bug. (is that bug gone now? oops, wrong channel)
13:36:42 <opqdonut> yeah it is
13:36:52 <opqdonut> in 2.0, using the new repo layout
13:37:00 <jethr0> that's kinda annoying for a versioning system. at least you'd hopefully still have your working directory, from which darcs would hopefully only read on a commit
13:37:08 <vixey> jethr0: It's invertible.. so no program can destroy or create information, so it can't be turing complete.. but it can run reversible turing machines and self-interpret
13:37:39 <yitz> jethr0: you still had the data in that case, but it was a real pain to get it back out. glad to hear that's fixed.
13:52:20 <Peaker> what is State.Strict strict about, specifically?
13:53:19 <monochrom> > Control.Monad.State.Lazy.runState 0 ( undefined >> put 1 )
13:53:28 <monochrom> perhaps that's the wrong order
13:53:34 <monochrom> > Control.Monad.State.Lazy.runState ( undefined >> put 1 ) 0
13:53:35 <lambdabot>  thread killed
13:53:48 <Deewiant> > 1+1
13:53:50 <lambdabot>  thread killed
13:54:03 <lambdabot>  thread killed
13:54:04 <Deewiant> > 2
13:54:07 <monochrom> Anyway try that and try s/Lazy/Strict/
13:54:19 <lambdabot>  thread killed
13:54:20 <dons> dcoutts: around?
13:55:00 <Peaker> monochrom: I see. Why would it delay execution of something that does not at all touch state?
13:55:10 <Peaker> monochrom: s/delay execution/make it stricter
13:57:44 <monochrom> Some programs cause Control.Monad.State.Lazy to use a lot of memory. Some other programs cause Control.Monad.State.Strict to use a lot of time.
13:57:44 <Toxaris> Peaker: Lazy state may skip parts of the computation which touch state
13:58:01 <Peaker> Toxaris: but I'm not touching state anywhere, I commented all of the get/put calls out
13:58:35 <vixey> It's great when you write a program 10x smaller than it used to be
13:58:50 <vixey> and 10x faster, with more features
13:58:51 <Toxaris> Peaker: I think that >>= of State.Strict is strict in it
13:59:01 <Toxaris> Peaker: ... it's left argument
13:59:19 <Toxaris> Peaker: independent of state touched or not
13:59:34 <Peaker> This is memory thrashing with either Strict or Lazy state. With lazy state, I get the first few results http://hpaste.org/9108 and http://hpaste.org/9109
13:59:42 <dolio> It's not the left argument, exactly.
13:59:46 <dolio> It's the tuple that it generates.
14:00:00 <Peaker> vixey: Deleting/refactoring code successfully is great. You get the code-deleticin hormone released in the brain
14:00:09 <wbeene> It is depressing when you are refactoring java code and it just gets larger :P
14:00:10 <vixey> hehe
14:00:56 <Peaker> if something is thrasing memory in Python, I can ask the gc module for a histogram of object types in memory -- is there anything similar I can do with ghc?
14:01:00 <dolio> Lazy uses 'let (a,s) = runState ... in ...' and Strict uses 'case runState ... of (a,s) -> ...' essentially.
14:01:51 <Peaker> dolio: if I don't touch (get or put) the state component of the tuple, why does it still cause things to wait for further results?
14:02:01 <Peaker> (before yielding existing results)
14:02:51 <Toxaris> dolio: what's the difference between being strict in the result something generates, and in something itself?
14:03:27 <monochrom> State (\_ -> undefined) >> put 1
14:03:50 <dons> Peaker: yeah, heap profiling.
14:03:59 <dons> Peaker: check the profiling section of the ghc guidle.
14:04:06 <Peaker> dons: thanks
14:04:47 <monochrom> Is (\_ -> undefined) considered more defined than undefined?
14:04:59 <vixey> well it's in WHNF
14:05:22 <mauke> seq knows
14:05:25 <Toxaris> dolio: oh I misunderstood you. thanks monochrom, I know see what you mean.
14:05:43 <Toxaris> dolio: thanks for pointing out the let/case difference, I was looking at the code and didn't spot it
14:07:00 <dolio> I don't remember how it goes with StateT.
14:07:06 <Asgaroth> Which topic should I try to learn first? Monads or CPS? Does an understanding of CPS make understanding monads easier or vice versa?
14:07:10 <Toxaris> monochrom: interesting definition. (\_ -> undefined) is strict without evaluating its arguments.
14:07:30 <dolio> I guess it'd be '(a,s) <- runStateT ... ; ...' versus 'p <- runStateT ... ; let (a,s) = p ; ...'
14:07:43 <Toxaris> there is ~, isn't there?
14:07:49 <Saad_> Many times I read WHNF, but what exactly is weak head normal form?
14:07:56 <dolio> Oh, yeah, I guess they could do that.
14:08:36 <erikc> Asgaroth, they are orthogonal, understanding of one doesn't reply help the other
14:08:49 <erikc> s/reply/really/
14:09:24 <dolio> monochrom: I think, aside from seq, const undefined isn't distinguishable from undefined.
14:09:28 <Asgaroth> erikc: Ok, thanks.
14:09:56 <vixey> Saad_: an abstraction or constructor applied, so (\x -> <anything>) or Just <anything>
14:10:18 <sebaseba> Asgaroth: You can only go so far in Haskell without knowing how to use Monads.
14:10:29 <Saad_> vixey, could you show me some examples?
14:10:36 <Toxaris> Asgaroth: monads are more often used in Haskell then CPS, so the return on investment (for Haskell usage) may be higher for monads
14:10:44 <vixey> I just gave two examples
14:10:58 <Toxaris> Asgaroth: CPS may be easier, because it is not hidden by syntactic sugar or type classes in Haskell
14:11:04 <Asgaroth> Toxaris, sebaseba: Ok, thanks, I guess I'll start with monads then.
14:11:55 <dolio> I don't think learning about CPS will help you learn about monads, aside from the fact that continuation passing is a monad.
14:12:04 <dolio> But there are easier examples of monads to look at.
14:12:33 <dmhouse> CPS itself is easy to learn. The Cont monad is very hard.
14:12:59 <dmhouse> Well, more precisely, understanding how Cont works (i.e., why continuations are a monad) is hard.
14:13:00 <vixey> I wouldn't say CPS is easy.
14:13:08 <Peaker> according to -hc profiling, my program is using 400-500KB of memory, when in fact its using many megabytes
14:13:10 <Toxaris> Saad_: do you know beta reduction?
14:13:35 <Peaker> oh wait, I used bad options from the example..
14:14:01 <Saad_> Toxaris, no
14:15:17 <Toxaris> Saad_: you can change ((\x -> something) a) to (something_with_all_x_replaced_by_a) without changing the meaning
14:15:59 <Saad_> Toxaris, how would that relate to WHNF?
14:16:30 <Toxaris> Saad_: well, a term is in NF if you cannot apply beta reduction anywhere in it.
14:16:46 <Toxaris> Saad_: it is in HNF if you cannot apply beta reduction at the outside of the term
14:17:19 <Toxaris> Saad_: and it is in WHNF if it is in HNF or it starts with the application of a data constructor
14:17:29 <dmhouse> Saad_: have you seen http://en.wikibooks.org/wiki/Haskell/Laziness#Thunks_and_Weak_head_normal_form ?
14:17:29 <lambdabot> Title: Haskell/Laziness - Wikibooks, collection of open-content textbooks, http://tinyurl.com/ykch9p
14:17:30 <Saad_> I think I see
14:17:51 <Toxaris> Saad_: so application to WHNF/HNF/NF means to apply beta reduction until you reach to form you want
14:18:00 <vixey> something[x/a] (or is it something[x\a] ?)
14:18:09 <Peaker> is there anything more interactive to profile memory than a lot of ghc reruns with various -h options?
14:18:23 <Saad_> dmhouse, I can't believe I forgot to read that. Toxaris I tihnk I see, thanks :)
14:18:35 <Peaker> the output is quite cryptic, compared to what it could be (e.g: Showing memory usage next to source lines, or such)
14:21:26 <dolio> I'm not sure that description of HNF is entirely accurate (not that I've ever found a very good definition of HNF).
14:21:59 <dolio> But for instance, '\x -> (\y -> y) x' is not in HNF, but it is in WHNF.
14:22:29 <dolio> However, '\x -> x ((\y -> y) x)' is in HNF.
14:23:19 <dmhouse> "Weak Head Normal Form - (WHNF) A lambda expression is in weak head normal form (WHNF) if it is a head normal form (HNF) or any lambda abstraction. I.e. the top level is not a redex."
14:24:12 <dmhouse> ?google weak head normal form
14:24:15 <lambdabot> http://encyclopedia2.thefreedictionary.com/Weak+Head+Normal+Form
14:24:15 <lambdabot> Title: Weak Head Normal Form definition of Weak Head Normal Form in the Free Online Enc ...
14:25:38 <Peaker> what does (3)CAF mean in a memory profile output?
14:26:06 <dons> a top level binding with no arguments is a CAF.
14:26:09 <dons> so some big constant.
14:26:11 <dons> or small.
14:26:25 <dons> like '1 :: Integer' for example. or a top level data structure
14:26:30 <dons> or something that was floated out.
14:26:38 <Peaker> so a top-level structure is retaining all of the leaked data, somehow
14:26:58 <Peaker> when do things float out?
14:27:54 <Peaker> I don't think any of my argument-less top-level bindings could be holding the objects it says they're holding
14:28:47 <Peaker> See: http://hpaste.org/9108 and http://hpaste.org/9109  I don't think there's any CAF there holding Board objects (which are the only ones that have a Map, which is what's taking up the space)
14:29:59 <dolio> initial and target are Boards.
14:30:03 <Peaker> ok I'm pretty sure its the binding of x:xs in main, probably floating up to be on top
14:30:11 <Peaker> dolio: yeah, but they're just single objects
14:30:28 <Peaker> dolio: they can't be the source of 5 megabytes/sec increase in memory usage
14:30:34 <dolio> Heh.
14:30:53 <Peaker> (x:xs) and improvingResults  are probably being floated to the top-level, right?
14:30:57 <dolio> Oh, yeah, those things in main could be floated.
14:31:13 <dolio> Since they don't depend on anything else in main.
14:31:23 <Peaker> and maybe its not holding just the current value, but all of the previous results too, for some reason
14:31:24 <erikc> silly question, is there a common name / function for \x y z = (x - z) / (y - z)
14:31:42 <Peaker> @pl \x y z = (x - z) / (y - z)
14:31:42 <lambdabot> (line 1, column 8):
14:31:42 <lambdabot> unexpected "="
14:31:42 <lambdabot> expecting pattern or "->"
14:31:55 <Peaker> @pl \x y z -> (x - z) / (y - z)
14:31:56 <lambdabot> (. (-)) . ap . ((/) .) . (-)
14:32:13 <erikc> haha, wow
14:32:34 <Peaker> that's one name it has :)
14:32:43 <dolio> If you change the argument order: \z -> (/) `on` (subtract z)
14:32:53 <Peaker> @type on
14:32:56 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
14:33:02 <vixey> @src on
14:33:02 <lambdabot> (*) `on` f = \x y -> f x * f y
14:33:12 <dolio> Or 'on (/) . subtract' if you further eliminate points.
14:33:41 <jorick> yo yo yo
14:33:57 <Peaker> dolio: so any idea why the call to improvingBy will take more than O(1) memory?
14:34:06 <erikc> hehe, i just cant figure out what to name it, 'percentage in interval'
14:34:32 <jorick> erikc, call it a "tween" (it's BEtween stuff, no?)
14:34:44 <erikc> yea, its for: lerp from to $ clamp min max $ (x - z) / (y - z)
14:35:11 <erikc> tween is good
14:35:12 <bos> @seend ons
14:35:12 <dolio> Peaker: Top-level CAFs never get garbage collected, since they never go out of scope?
14:35:12 <lambdabot> I haven't seen ons.
14:35:16 <bos> @seen dons
14:35:16 <lambdabot> dons is in #arch-haskell, #xmonad, #ghc and #haskell. I last heard dons speak 8m 46s ago.
14:35:17 <dons> yo bos.
14:35:24 <dons> where you at?
14:35:26 <bos> dons: just got into the hotel. need shower and lunch.
14:35:32 <dons> awesome.
14:35:43 <dons> see you 4ish then?
14:35:51 <bos> probably 3:30 to 4, yes.
14:35:58 <dons> ok. you got a phone?
14:36:10 <Peaker> dolio: so:  let a = <big obj> in do { use a; <long computation> } -- will keep a in memory for <long computation> ?
14:36:12 <dons> our desk person might have gone home by then, so if you can't get in, give me a buzz
14:36:20 <jorick> dons, do you got his number?
14:36:21 <bos> will do.
14:36:38 <dons> jorick: i do got.
14:36:41 <Peaker> dolio: even if its only used in the beginning there?
14:36:50 <dolio> Peaker: I think so.
14:36:54 <jorick> hehehe :)
14:37:28 <dolio> Peaker: Or, if it gets floated to top level, it will never get freed for your entire program.
14:37:32 <Peaker> dolio: especially if "a" is a CAF?  that kinda sucks if that's true
14:37:52 <Peaker> dolio: this seems like an implementation detail that's easy to hide
14:38:20 <dolio> Peaker: For instance, if you have 'fibs = some-list-of-fibs-generator' and your main gets the 1-billionth fibonacci, and then doesn't need fibs anymore, it will nevertheless stay in memory.
14:38:44 <vixey> no it doesn't suck
14:38:49 <vixey> this is a useful technique
14:39:01 <Peaker> vixey: for the case that nobody will ever reference the list again?
14:39:08 <vixey> if you want to scope the thing, and have it GCd, then you can put it in a local definition
14:39:15 <vixey> i.e. a where, or passed as a parameter
14:39:26 <jorick> :p
14:39:39 <Toxaris_> vixey: dolio said that it may be floated to the top-level even if put in a let
14:40:06 <vixey> what are the exact conditions of that ?
14:40:25 <dolio> His definitions there are actually in scope for the entire run of the program.
14:40:40 <Peaker> vixey: the only expression that depended on that value is already fully computed?
14:40:47 <dolio> I don't know the conditions for floating like that. But if he's seeing that on the memory profile, ostensibly it's happening.
14:42:35 <Peaker> so:  main = do { let a = <big value> ; forM a $ \x -> do ... } will use more memory than: main = do { forM <big value> $ \x -> do ... }
14:42:45 <Peaker> because there's no "a" name that's keeping it memory?
14:43:11 <Peaker> s/forM/forM_
14:43:19 <dmhouse> Peaker: how can you GC there anyway? Surely all of main is using <big value> in both cases.
14:43:19 <dolio> Possibly. Try it. :)
14:43:54 <Peaker> dmhouse: why? After each of forM's iterations, you can throw away another value of <big value>
14:44:00 <Peaker> s/<big value>/<big list>
14:44:08 <dmhouse> Ah.
14:45:13 <Peaker> dmhouse: if <big list> is lazily generated - you use O(N) instead of O(1)
14:47:05 <Peaker> no, "a" is not keeping the whole list in memory
14:47:27 <dolio> solve may not be able to lazily generate the list.
14:47:51 <Peaker> dolio: but I am getting some results as it is computing
14:47:53 <dolio> Considering it's written with the state monad.
14:47:59 <Peaker> dolio: its just that something is appearantly keeping old results in memory
14:48:22 <Peaker> dolio: even if I just forM_ on the result of solve itself and print it to /dev/null
14:50:03 <Peaker> (only that in this configuration its eating up 50 MB/sec.. heh)
14:50:21 <Peaker> who says Haskell isn't fast? :)
14:51:17 <hml> Peaker: what r u doing in haskell that can process dat at 50MB/sec ?
14:51:45 <dons> Data.Binary does encoding at around 500M/s on my box...
14:52:03 <Peaker> hml: I am trying to solve a silly game - and instead of generating solutions consuming about O(1) memory, its consuming O(N) memory, where N is growing very fast :)
14:52:10 <dons> Peaker: btw, no one says it isn't fast in the 21st century :)
14:53:13 <hml> Peaker: ah; fast at consumign memory; that I can believe
14:53:24 <Peaker> dons: The benchmarks around the web indicate Haskell is great, and going to be even better at the next major ghc, yeah
14:53:40 <dons> hml: write much haskell code?
14:53:55 <hml> dons: only beginner level haskell code
14:54:03 <dons> ok.
14:54:07 <dons> got ghc installed?
14:54:12 <hml> of ocufse
14:54:13 <dons> ghc -O2 is your friend.
14:54:18 <hml> up to chapter 15 of haskell school of expression
14:54:33 <hml> does -O2 reduce memory usage?
14:54:46 <dons> it optimises the native code, so yes. that can be one result.
14:54:59 <zachk> dons: nice tutorial on irc bots
14:55:06 <dons> thanks!
14:55:55 <Peaker> is there a name for  flip map ?
14:55:56 <hml> is ocaml still the defacto language for doing static analysis research, or has haskell managed to climb into this area?
14:56:18 <jorick> uhm
14:56:25 <jorick> i'm not really good at the internets
14:56:31 <jorick> is there a girl here? :)
14:56:36 <Peaker> "climb" implies Haskell was beneath that :)
14:56:38 <monochrom> Yes.
14:56:48 <jethr0> Peaker: you can also use the infix idiom
14:56:58 <jethr0> > (+1) `map` [1,2,3]
14:57:00 <Peaker> jethr0: good idea
14:57:12 <vixey> > (+1) . [1,2,3]
14:57:13 <lambdabot>  thread killed
14:57:22 <vixey> @undef
14:57:26 <shepheb> or <$> from Control.Applicative
14:57:26 <jethr0> ah, you meant flip, not quite the same
14:57:28 <lambdabot>  thread killed
14:57:37 <lambdabot> thread killed
14:57:38 <jethr0> > map ($4) [(+1), (*2)]
14:57:39 <vixey> > (+1) . [1,2,3]
14:57:40 <vixey> @undef
14:57:43 <lambdabot> Undefined.
14:57:44 <vixey> @undefine
14:57:45 <lambdabot> Undefined.
14:57:45 <Peaker> jethr0: yeah I just realized that :)
14:57:48 <lambdabot>  [5,8]
14:57:48 <lambdabot>  [2,3,4]
14:57:49 <mfp> dons: are there any plans to add unparsing capabilities to ByteString?
14:57:50 <jorick> :)
14:58:09 <vixey> why doesn't somebody fix lambdabot ...
14:58:13 <jethr0> @type forM
14:58:14 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
14:58:18 <dons> mfp, pretty printing into bytestrings?
14:58:20 <mfp> (tell me if you're tired of my questions :)
14:58:32 <dons> that's provided by Data.Binary, fwiw.
14:58:35 <mfp> dons: like writeFloat and stuff
14:58:38 <jethr0> Peaker: forM is something like you're looking for, albeit for monads
14:58:41 <dons> yeah, Data.Binary.
14:58:51 <mfp> ah thx
14:58:53 <dons> handles all the efficient bit packing
14:58:53 <jethr0> > forM [1..5] Just
14:58:54 <lambdabot>  Just [1,2,3,4,5]
14:59:04 <Peaker> jethr0: exactly
14:59:15 <mfp> bit packing?
14:59:22 <dons> byte packing.
14:59:27 <jethr0> Peaker: what are you trying to do? you can always define "for = flip map"
14:59:30 <Peaker> jethr0: I know about forM, but there ain't a "for"
14:59:35 <mfp> I'm looking for a way to do stuff like  printf "%.2f"  ->  http://hpaste.org/9111
14:59:48 <jethr0> Peaker: depending on the data you're working with you can use forM
14:59:51 <Peaker> jethr0: just have a tiny lisp expression and large function, and would rather put the list expression before the big one
15:00:11 <mfp> tried a few approaches to avoid BS.pack/unpack & stuff, but no diff in speed
15:00:16 <Peaker> jethr0: using the list monad here is a little awkward :)
15:00:30 <jethr0> (`map` list) function
15:01:08 <jorick> all right
15:01:57 <jethr0> > (`map` [1,2,3]) (+1)
15:01:59 <lambdabot>  [2,3,4]
15:02:47 <jorick> > (`map` [1,2,3]) (+1
15:02:47 <lambdabot> Unbalanced parentheses
15:02:49 <jethr0> even though some people object to this infix trick for aesthetic reasons
15:02:58 <jorick> > (`map` [1,2,3] +1)
15:02:59 <lambdabot>      The operator `map' [infixl 9] of a section
15:02:59 <lambdabot>         must have lower prece...
15:03:00 <vixey> > flip map [1,2,3] (+1)
15:03:01 <lambdabot>  [2,3,4]
15:03:24 <mfp> ah hmm Data.Binary is for serialization; I just meant formatted textual output
15:03:40 <vixey> > let (-<<) = flip map in [1,2,3] -<< (+1)
15:03:41 <lambdabot>  [2,3,4]
15:03:43 <dons> right. so it gives the underlying primitives to efficiently fill bytestrings
15:03:50 <shepheb> you can just define pam = flip map and go?
15:03:55 <dons> you just need a class and instances to pack the bytes textually
15:04:14 <vixey> nicer name than pam is -<<
15:04:19 <monochrom> @bot
15:04:19 <lambdabot> :)
15:04:31 <jethr0> vixey: that's in the eye of the beholder
15:04:45 <monochrom> Hey, -<< is reserved keyword for arrow notation
15:04:45 <Peaker> I got rid of the use of the lazy State monad, and it got rid of the memory leak
15:04:48 <jethr0> at least to me "-<<" isn't obviously denoting a flipped map
15:04:57 <Peaker> even though my use o the state monad didn't use any state at all!
15:05:01 <vixey> =<< is concatMap
15:05:03 <vixey> -<< is map
15:05:24 <opqdonut> heh
15:05:32 <mfp> manual packing? ö so I get to rewrite the functions for formatted output :) ? I was just looking for  writeFloat :: RealFloat a => a -> ByteString or so
15:06:12 <jethr0> didn't someone mention a library for serialization yesterday?
15:06:22 <jethr0> mfp: or are you looking for something different than serialization?
15:06:28 <dons> class Binary a => Pretty a
15:06:30 <mfp> no, not serialization
15:06:49 <dons> instance Pretty Float where showit f = put (first byte f) >> put(second byte f)
15:06:58 <mfp> just wanted to replace this line by something faster:   printf "%s,%0.2f,%0.2f,%0.2f,%0.2f,%s" (BS.unpack ticker) open high low close (BS.unpack day)
15:07:05 <mfp> not rewrite half of printf :)
15:07:08 <dons> ah
15:07:26 <dons> check that that's really the problem.
15:07:28 <mfp> I tried a few things, none is much better ->  http://hpaste.org/9111
15:07:33 <dons> i.e. write a byte, and just seq the fields
15:07:41 <mfp> the .prof says it takes 30%, can't I trust it?
15:07:43 <dons> to confirm printf is the culprit (i'd be surprised)
15:07:52 <dons> well, it could be one of the *fields* of printf getting  evaluated.
15:08:11 <dons> so in that case, add some: printf "..." {-# SCC "this field" #-}x y z
15:08:17 <dons> to get precise numbers for subexprsesions
15:08:25 <jethr0> and something like "BS.unpack ticker ++ concat (map showFloat [open,high,low,close]) ++ BS.unpack day" is out of the question, i guess
15:08:29 <mfp> OK, trying
15:08:36 <jethr0> or probably slower ;(
15:09:59 <mfp> jethr0: I've tried to combine the showFFloat (Just 2) (it returns a ShowS), pack into ByteStrings and intercalate, hPutStr directly, etc., to no avail
15:10:01 <jethr0> i see you've tried that...
15:10:20 <jethr0> all too slow?
15:10:47 <mfp> none much faster, but it could be the fields being evaluated
15:10:48 <Peaker> Can anyone help me understand why this diff removes the leak?
15:10:50 <Peaker> http://hpaste.org/9112
15:11:05 <Cale> dons: I posted the A* package you wanted to Hackage as astar :)
15:11:13 <mfp> I thought the profiler was able to attribute exec. time to the original expression
15:11:29 <dons> Cale, yep, got it. its in Arch now.
15:11:35 <dons> mfp: the top level binding.
15:11:37 <Peaker> Its basically the same code -- one in the lazy state monad, and one isn't -- doing the same thing, but one is leaking and one isn't
15:11:42 <dons> mfp, but you can drill down.
15:11:53 <dons> btw, that's assuming you're using -prof -auto-all
15:12:00 <mfp> yes, -auto-all
15:12:17 <mfp> "the top level binding." > what do you mean, it gets attributed to that?
15:12:21 <vixey> :/
15:12:24 <vixey> haddock sucks
15:12:30 <vixey> http://hackage.haskell.org/packages/archive/astar/0.0/doc/html/Data-Graph-AStar.html
15:12:31 <lambdabot> Title: Data.Graph.AStar, http://tinyurl.com/6jwy4c
15:12:53 <Cale> vixey: I noticed that. Haddock 0.9 works though.
15:12:58 <vixey> oh
15:13:07 <vixey> I sent the author a bug report the other day about tis
15:13:12 <vixey> I didn't know it was fixed
15:13:15 <Cale> http://cale.yi.org/AStar/dist/doc/html/astar/Data-Graph-AStar.html
15:13:16 <lambdabot> Title: Data.Graph.AStar, http://tinyurl.com/69kxsb
15:13:20 <dons> mfp, so printf, for example.
15:13:34 <dons> but if you want subexpressions,  you need to annotate the exprs of interest
15:13:38 <Cale> vixey: 0.9 is old :)
15:13:44 <jethr0> what happened to the function parens?
15:13:47 <Cale> vixey: 2.0.0.0 and 2.1.0 both have that bug
15:13:58 <Cale> jethr0: eaten by haddock
15:14:20 <jethr0> all those trusty software packages eating data (darcs, haddock, ...)
15:14:25 <jethr0> all fixed, fortunately
15:14:27 <jethr0> ;)
15:14:44 <Cale> Haddock isn't fixed, really.
15:14:50 <vixey> why is there Ord on a ? :S
15:15:00 <Cale> vixey: because of Set
15:15:03 <jethr0> ;(
15:15:03 <vixey> is that just so you can put it in a Set
15:15:05 <vixey> ok
15:15:13 <Cale> (and PSQueue)
15:15:23 <Peaker> Can anyone explain why this diff affects memory usage so horribly?  http://hpaste.org/9112
15:15:25 <Cale> (and Map)
15:15:43 <Peaker> (State is State.Lazy, which seems to be the root of the problem)
15:15:56 <vixey> Cale, "Heuristic distance to the (nearest) goal." -- maybe it should mention the heuristic -must- be conservative
15:15:57 <vixey> ?
15:16:03 <vixey> otherwise it will not give a minimal path
15:16:08 <vixey> (will it ?)
15:16:49 <Cale> mmm... yeah, it probably should say that :)
15:19:05 <Cale> It'll still find some path, but perhaps not a minimal one.
15:31:37 <mfp> argh     BS.hPutStr h {-# SCC "ticker" #-} ticker  ->  parse error on input `{-# SCC'
15:32:15 <dons> did you change your layout formatting?
15:32:17 <mfp> read what the manual has got to say about pragmas, tried to put it in a separate line, change the indentation, etc. still parser error :-|
15:32:36 <Igloo> mfp: You need to put it in an expression, not a pattern
15:32:45 <mfp> I just prepended the pragmas to the expressions
15:32:50 <Igloo> Oh, wait. What's going on there?
15:33:17 <Igloo> Oh, I see - I misread the "->" as part of the syntax  :-)
15:33:44 <Igloo> Can you hpaste it with a bit more context please?
15:33:44 <dons> so its something context sensitive, as: f {-# SCC "foo" #-} expr ... works for me
15:34:13 <mfp> http://hpaste.org/9111#a2
15:35:03 <mfp> see something silly?
15:35:37 <dons> not yet.
15:35:44 <Igloo> Presumably it works if you put parens around    {-# SCC "ticker" #-} ticker   ?
15:36:06 <Igloo> I assume the maximal munch is interacting badly with the layout rule somehow, although I don't quite see why OTTOMH
15:36:11 <mfp> Igloo: didn't seem to work, I'll try again
15:36:16 <tusho_> oh hi mfp
15:36:32 <Igloo> Hmm, that's very odd then
15:37:42 <mfp> ah great, works now, must have forgotten to add some ( ) before
15:37:57 <mfp> Igloo: so I bumped into a parser oddity?
15:38:03 <mfp> tusho_: yes?
15:38:14 <tusho_> nothing, I just read eigenclass and noticed you here :p
15:38:30 <mfp> :)
15:38:43 <thetallgu1> question about ghci/emacs.  suddenlyusing C-c C-l to visit ghci is inserting :cd ~/.cabal/ at the beginning of my session.  I have no .ghci file.  anyone know where that got triggered?
15:38:51 <Igloo> Looks like it
15:38:56 <thetallgu1> doesn't happen from an xterm command line
15:39:06 <TSC> thetallgu1: Get the CVS version of Stefan Monnier's haskell-mode
15:39:17 <tusho_> :)
15:39:18 * mfp about to get the new .prof with manual cost centers, crosses fingers
15:39:40 <thetallgu1> TSC: so that's a bug that was fixed?
15:39:52 <thetallgu1> This behavior seems recent
15:41:03 <TSC> Yeah, it's recent
15:41:19 <TSC> The purpose is to change directory to the root of the project
15:41:27 <TSC> (using the cabal file to determine that location)
15:41:49 <TSC> But it doesn't work properly in some cases, I think
15:41:52 <halberd> I had an idea, suppose that when reading a document it is noted that a typical user frequently flips from page 37 to page 23, perhaps because page 23 includes information relevant to page 37
15:42:14 <thetallgu1> TSC: thanks.
15:42:18 <halberd> a computer program could note this pattern and add a link back to page 23 from page 37
15:42:21 <dcoutts_> thetallgu1, TSC: looks like it keeps looking upwards in dirs to find a *.cabal file
15:42:36 <mfp> ok, now this is interesting ->  http://hpaste.org/9111#a3  putResult (a few BS.putStr + hPutStr of a showFFloat) takes 35%, its expressions... 0% (i.e. already evaluated)
15:42:53 <stepcut> apparently ~/.cabal is a good enough match
15:42:54 <Cale> When does Hackage rebuild newly uploaded versions of packages?
15:43:02 <dcoutts_> thetallgu1, TSC: and if it doesn't find one, it eventually gets to your home dir which contains ~/.cabal/ and it get's misinterpreted as a .cabal file with no project name.
15:43:21 <dcoutts_> Cale: asynchronously but not too long after upload
15:43:38 <dcoutts_> hia CosmicRay, how's OSCon ?
15:43:43 <mfp> but some cost centers are missing :-/
15:44:20 <dcoutts_> Cale: or maybe I'm wrong and it only does it on a cron job every couple hours. I've never actually looked at that code.
15:44:40 <Cale> okay :)
15:47:50 <CosmicRay> hi dcoutts
15:48:09 <CosmicRay> dcoutts_: really good.  I've been here two days and I'm just now attending a session I had planned to.
15:48:14 <CosmicRay> that means it's great ;-)
15:48:18 <dcoutts_> :-)
15:48:34 <dcoutts_> lots of nice distractions then
15:48:42 <CosmicRay> I really wanted to go to web development in smalltalk yesterday, but missed out on it
15:48:48 <dons> yo CosmicRay!
15:48:50 <jethr0> best distraction of all is still #haskell ^_^
15:48:56 <CosmicRay> yeah.  there was an XMPP room that wasn't on the program.  I had to drop in
15:48:58 <CosmicRay> dons: hey!
15:49:20 <erikc> cosmicray: was that a avi bryant joint?
15:49:22 <CosmicRay> dons:  thanks for organizing things -- we'll be there
15:50:36 <thetallgu1> dcoutts_: thanks, we found that.  I created a .cabal file for my project and all is well.
15:50:50 <CosmicRay> erikc: hmm... let me check.
15:51:10 <dcoutts_> thetallgu1: lots of people have hit this, someone needs to kick the haskell-mode maintainers to do a release with the fix
15:51:17 <CosmicRay> erikc: http://en.oreilly.com/oscon2008/public/schedule/detail/4216
15:51:23 <CosmicRay> erikc: from Randal L. Schwartz of all people
15:51:40 <CosmicRay> I would have thought that the set of Perl experts that enjoy Web development in Smalltalk would be a rather small set
15:52:05 <thetallgu1> dcoutts_: I'm puzzled as to how I've missed it until now
15:52:27 <dcoutts_> thetallgu1: probably your other projects had a .cabal file already
15:53:53 <shepheb> does the CVS haskell-mode still lock up if you C-c C-l while it's debugging or running?
15:54:08 <shepheb> I hit that one all the time, have to kill the ghc --interactive from the terminal.
15:55:32 <marcot> shepheb: no.
15:55:35 <marcot> shepheb: the CVS is ok.
15:55:46 <marcot> AFAIK
15:55:46 <shepheb> awesome. I'll grab that soon then.
15:55:53 <thetallgu1> dcoutts_: I've got it, I've been avoiding the ghci because we've been using trhsx as a preprocessor and it tends to hang.
15:57:16 <dcoutts_> thetallgu1: one thing I'd like to do is get cabal and ghci to cooperate more. eg have cabal launch ghci with the right flags and redefine :l :r so that it calls back to cabal to run pre-processors to bring .hs files up to date.
15:57:32 <dcoutts_> and we should teach cabal about trhsx
16:03:08 <thetallgu1> dcoutts_: that would be nice, if only to prevent miscommunications like this one.
16:03:49 <halberd> I'm thinking about an algorithms problem
16:04:29 <halberd> suppose you have a list of distinct numbers, sorted in ascending order, and each number has a color associated with it
16:04:48 <moonfart> ?
16:04:49 <halberd> and you have another list of colors
16:05:11 <halberd> and you can perform three operations on the list of distinct numbers, to change it into a different list
16:05:40 <halberd> first, you can increase all numbers greater than or equal to a given one, by a fixed offset
16:05:53 <halberd> second, you can decrease all numbers greater than or equal to a given one, by a fixed offset
16:05:57 <halberd> and third,  you can delete a number
16:06:32 <halberd> all numbers are non-negative integers and the goal is to use the smallest number of operations to reach a state where each number in your list has a color that matches the color at that position in the list of colors
16:07:08 <moonfart> halberd, i applaud you for making things 100 times more complicated then they need be ;)
16:07:09 <vixey> is this the dutch flag problem ?
16:07:28 <halberd> i.e. for each number i in your final list of numbers N, then color(i) = X[i] where X is your list of colors
16:07:47 <halberd> no I came up with this thinking about preserving the break points in a file after the file has been changed
16:07:55 <halberd> I have no solution yet
16:09:04 <halberd> oh, also N must remain in ascending order after any operation
16:12:09 <halberd> the informal problem it's trying to solve is, you have an old file that was changed to a new file, and a set of breakpoints in the old file, and you want to find a good way to re-assign breakpoints so that they are reasonably placed in the new (edited) file
16:12:50 <iabal> hi! someone has problems with parallel-library in Debian Lenny with ghc 6.8 ?
16:13:25 <vixey> halberd: oh I would think about it differently, which lines have been modified, which lines have been inserted... if you can make an edit that does all the modifications and inserts from old -> new.. the breakpoints can come along for the ride
16:13:49 <moonfart> halberd, you should look to see how patch works
16:14:10 <halberd> yeah but patching has a different weighting because it takes 1 point per changed line
16:14:27 <halberd> whereas I want to count it still just 1 point if a whole contiguous segment of lines are changed in between breakpoints
16:15:02 <halberd> (add lines means increase all numbers greater than or equal to a given one, remove lines means decrease all numbers greater than or equal to a given one, remove or change a breakpoint line means delete the number)
16:16:02 <halberd> the color of the line = its text and the color of a breakpoint = its text in the old file
16:17:27 --- mode: irc.freenode.net set +o ChanServ
16:18:10 <halberd> the problem with diff/patch is that it doesn't think about "moving" lines, it just thinks about removing or adding them
16:18:54 <halberd> well, maybe that's not a serious complaint
16:19:11 <dcoutts> halberd: no it is, and it's restricted to a line based view of the structure
16:19:15 <vixey> halberd: What do you think about it ?
16:19:44 <halberd> dcoutts the line based view is no restriction for this problem since breakpoints are line numbers anyway
16:27:47 <Trinithis> @seen Tewy
16:27:48 <lambdabot> I haven't seen Tewy.
16:29:11 <hackage> Uploaded to hackage: astar 0.1
16:29:21 <halberd> I'm working my way through this paper http://people.cs.uu.nl/andres/LambdaPi/index.html and I am having difficulty grasping the difference between values that take a type as an input (checkable), and values that produce a type as an output (inferrable)
16:29:22 <lambdabot> Title: A Tutorial Implementation of a Dependently Typed Lambda Calculus
16:30:28 <halberd> the only concrete difference I have been able to discern is that the checkable values are handled by a type-checking function and the inferrable values are handled by a type-inferring function
16:30:38 <halberd> in their implementation of the interpreter
16:30:58 <vixey> halberd hello :S
16:31:16 <iabal> hi! someone has problems with parallel-library in Debian Lenny with ghc 6.8 ? (repeated :P)
16:31:23 <halberd> hello vixey
16:31:38 <halberd> but it looks like you could change the interpreter so that the checking function could also produce a type
16:31:47 <halberd> it could just return the type it was given couldn't it
16:32:21 <Saizan_> but it can't generate one like the inferring function does, no?
16:33:25 <halberd> but the inferring function also uses its environment to get its type
16:33:44 <halberd> the Context
16:33:57 <halberd> so it is being passed a type as well, for variables
16:34:49 <Saizan_> right, but not for the whole expression
16:36:39 <halberd> and in the specific case of an annotated expression nothing is being inferred, it is just checking that the annotation matches the value on the left
16:37:08 <Peaker> Pat Condell is great :)
16:37:39 <halberd> is it just the way they laid out their algorithm or is this a deeper concept that is generally used?
16:40:44 <Peaker> ghc -Wall warning bug:   import A(name) ; import B -- will yield a warning if "name" is accessible from both.  Worse yet, import A(name) ; import qualified B -- will yield a warning if both "name" and B.name exist
16:41:09 <Saizan_> halberd: in general we'd aim for full inference, like in the simply typed lambda calculus, HM, and the haskell98 type system, so that the user doesn't have to add any annotation
16:41:50 <Saizan_> halberd: but for dependent types this is impossible
16:43:05 <halberd> I'm actually talking about that paper's implementation of the simply typed lambda calculus
16:43:30 <vixey> by the way in simply typed lambda calculus do you infer types or type schemes?
16:44:40 <Saizan_> you infer principal types
16:44:45 <Saizan_> so yeah, type schemes
16:44:46 <halberd> you can infer the types of some expressions, I'm not sure what a type scheme is (you mean like a Haskell a-> b -> a thing?)
16:45:03 <halberd> that can be instantiated?
16:45:35 <Saizan_> halberd: they implemente the simply typed lambda calculus that way so it's similar to how they implement dependent types
16:46:33 <halberd> yes I see that Saizan_ I have gotten a little bit into the dependently typed part of the paper
16:47:37 <Saizan_> they could have chosen to perform just typechecking, but then you'd have to give more annotations
16:48:24 <halberd> ok so it was at least partially a design decision on their part what to call inferred and what to call checked
16:48:33 <halberd> because they do call annotated expressions inferred
16:49:11 <halberd> I'm wondering more along the lines of, does inferred expression represent a theorem, and a checked expression represent an axiom?
16:49:54 <halberd> actually I suppose they both represent theorems
16:51:29 <Saizan_> ah, no, i'm not aware of a distinction at that level, all expressions are a proof of their type
16:52:45 <Toxaris_> halberd: an axiom is something you use, but haven't proven, e.g. a library function for which you have no code
16:53:06 <Toxaris_> halberd: but you just assume it exists, even if it could not have been written in the language itself
16:53:34 <halberd> ok
16:53:36 <Toxaris_> halberd: e.g. fixed-point combinator in the simply-typed lambda calculus
16:54:34 <Toxaris_> type inference is figuring out from the proof what the theorem is
16:55:49 <halberd> alright so it looks like their distinction is more of a design decision than a fundamental law, thanks
16:56:42 <Toxaris_> that paper looks good, will read it tomorrow
17:12:59 <TomMD> @quote
17:13:00 <lambdabot> Runaro^BRS says: shapr: A plone replacement? Call it plwn.
17:17:18 <sebaseba> @quote
17:17:18 <lambdabot> BMeph says: <BMeph> Welcome to Haskell Adventure! You are in a maze of twisty imperative statements, all alike. There is a lambda here. <monochrom> Where can I find out more about Haskell Adventure?
17:17:45 <erikc> fg
17:44:12 <dobblego> was the original type-classes paper by Wadler? what was its name?
17:50:03 <dolio> How to make ad-hoc polymorphism less ad hoc?
17:51:07 <dolio> Looks like the original, at least.
17:51:21 <dobblego> yeah I think so too, thanks
17:55:33 <Cale> The name of that paper bothers me, because it fooled everyone into thinking that typeclasses implement ad-hoc polymorphism, while really typeclass polymorphism deserves its own name.
17:56:16 <dobblego> yes I agree
17:56:23 <dobblego> s/less/not?
17:56:31 <dolio> You can use it to get ad-hoc polymorphism with some extensions. :)
17:57:02 <Maciej> I want to read an UCS-2 encoded file, process the input with Parsec (as a simple string) and write the result as an UTF-8 encoded file. First of all, is it possible?
17:57:34 <codacola> yay, my haskell assignment is finally complete :D
17:57:35 <Cale> With plain ad-hoc polymorphism (at least as I see it), when you apply a polymorphic term, you always apply it at some particular monomorphic type which selects the instance.
17:57:52 <newsham> sure,  read in bytes, convert from ucs-2 to characters, call parsec parser on characters, generate result string, encode string as utf-8 and write out bytes
17:58:15 <Cale> (Whereas with typeclass polymorphism, the selection of the instance can wait.)
17:58:36 <codacola> http://hpaste.org/9113?lines=true <- isnt it pretty?
17:58:43 <Maciej> newsham: Ok, I meant are there packages to read UCS-2 and convert to String?
17:59:03 <newsham> maciej: I dont know about ucs-2 (probably less likely), but that one would be really easy to write yourself.
17:59:07 <newsham> the utf-8 parts exist
17:59:42 <newsham> ucs-2 is just 2-bytes, convert to a 16-bit quantity character, right?
18:00:17 <Maciej> I'm not sure.
18:00:33 <newsham> http://en.wikipedia.org/wiki/UTF-16  says ucs-2 is just fixed-width two-bytes per character.
18:00:33 <lambdabot> Title: UTF-16/UCS-2 - Wikipedia, the free encyclopedia
18:00:36 <newsham> in LE and BE variants
18:01:03 <dobblego> introducing higher-kinds to a noob; I could say Functor and he will focus on the scary word for the remainder of the discussion; any other examples? I considered: contains :: a -> c a -> Bool where c = List implies O(n) lookup, but c = Tree gives better lookup at the expense of insert
18:01:29 <newsham> oh, and a BOM variant where the first 2 bytes specify the endian
18:02:18 <vixey> dobblego: monads :p
18:02:43 <dobblego> vixey, I am convinced that Functor is a pre-requisite to Monad, after much experimentation
18:02:52 <newsham> why?
18:03:01 <dobblego> because the noob struggles significantly less
18:03:05 <newsham> i learned the functor after the monad
18:03:10 <Maciej> What package can handle the UTF-8 output?
18:03:38 <newsham> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/utf8-string
18:03:40 <lambdabot> Title: HackageDB: utf8-string-0.3.1.1, http://tinyurl.com/3cjhwj
18:07:05 <Toxaris_> dobblego: use Functor, but call it Mappable
18:08:19 <Cale> Toxaris_: heh
18:08:45 <codacola> alrighty, 2 things done, just 25 to go
18:09:04 <Toxaris_> Cale: yes?
18:09:45 <Cale> Toxaris_: I'm not sure that really helps any more than "Functor"... it's still a term that you have to define.
18:10:19 <newsham> except functor sounds mathy and scarey
18:10:24 <newsham> and mapper sounds like you already know what it does
18:10:30 <Cale> Really?
18:10:35 <Toxaris_> *not* Mapper
18:10:37 <Toxaris_> Mappable
18:10:40 <Toxaris_> :)
18:11:02 <monochrom> "monad is computation" also capitalizes on "computation" sounds like you already know what it does.
18:11:10 <codacola> hm, must learn what functor is
18:11:19 <vixey> @src Functor
18:11:19 <lambdabot> class  Functor f  where
18:11:19 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
18:11:25 <Philonous> Is the functor in haskel in any way related to the functor in category theory?
18:11:29 <monochrom> @quote computation
18:11:29 <lambdabot> qwe1234 says: it all boils down to standard first-year university-level computational theory.
18:11:31 <newsham> look,  (a -> b) -> [a] -> [b]!      (a -> b) -> Tree a -> Tree b!    what about abstracting?  we can do this.
18:12:14 <newsham> [15:00] < dobblego> introducing higher-kinds to a noob; I could say Functor and he will focus on the scary word for the remainder of the discussion;
18:12:17 <Toxaris_> codacola: oh that's easy. a functor (in Haskell) is a mappable polymorphic type, that is, something like list, where there is map to apply a function to the things inside the list
18:12:23 <Cale> monochrom: Actually, that was one of the main complications I had to overcome to understand monads -- I had no idea what 'computation' was supposed to mean :)
18:12:31 <vixey> I would not say 'mappable'
18:12:38 <vixey> it has fmap .. which is just a name
18:12:46 <vixey> the important thing to understand is the type
18:12:54 <Cale> Mappable sounds just as technical and potentially confusing to me as Functor :)
18:13:26 <Toxaris_> Cale: but you already have fmap, so calling it Mappable is at least consistent
18:13:27 <Cale> Except that it gives one the sense that it might have something to do with the traditional sense of the word "map"
18:13:36 <newsham> cale: except programmers already have a notion of what it means to map over a list or map over a tree
18:13:46 <monochrom> Evidently I do not believe "computation" to be a meaningful word.
18:13:50 <newsham> and less experience with getting functor on data
18:13:53 <Toxaris_> Cale: and List is an important Functor (in Haskell), and it is already known to newbies, and it's fmap is called map
18:13:54 <dobblego> I am going with an interace that has contains :: c a -> a -> Bool and insert :: a -> c a -> c a
18:13:56 <Cale> newsham: Well, those are examples of functors, and after you mention that, there's no problem :)
18:14:01 <vixey> newsham: only functional programmers
18:14:21 <newsham> vixey: i'm from imperative school,  i already was very comfortable with those concepts
18:15:42 <Cale> It's a simple enough concept that I don't think we should be afraid to use the proper term for it :)
18:15:48 <Toxaris_> Philonous: as I understand it, a Haskell functor is an endofunctor on the category of Haskell types with Haskell functions as morphisms. the object part is the type constructor, and the morphism part is the associated fmap
18:15:58 <dobblego> I am addressing Java programmers; I need to worry about using scary terms
18:16:18 <vixey> dobblego: If you use wrong names for things you will confuse people
18:16:23 <monochrom> Call them Angelina and Bratt.
18:16:30 <dobblego> vixey, there is no name for my example
18:16:44 <Toxaris_> for Java programmers, "Mappable" has the additional advantage that it sounds like the name of a Java interface, and interfaces are the closest Java has to typeclasses
18:17:12 <Toxaris_> while Functor sounds like a Java class name, and Java classes are less related to type classes then Java interfaces imho
18:17:31 <monochrom> Oh, Java programmers? Try "Liftable pattern" for functor and "Plumbable pattern".  The "pattern"s there are important.
18:17:33 <vixey> You can't second guess what people will or wont understand based on the language they use anyway
18:17:46 <Toxaris_> and Functor sounds like "something like a function, oh, maybe the Function pattern" which is, well, wrong
18:17:46 <dolio> And Java folk already use "functor" for something totally unrelated to category theory functors.
18:17:49 <monochrom> Hell, even "monad pattern" will pass.
18:17:53 <newsham> someone should rewrite "I'd like to teach the world to sing in perfect harmony" with words about teaching java programmers about decent programming languages
18:18:08 <vixey> java is a decent language though
18:18:14 <dobblego> monochrom, I've used the term monad pattern in documentation before :)
18:18:14 <chylli> is it a way to access external array like written by c by O(1) ?
18:18:25 <Cale> Can you even properly implement the Functor typeclass in Java? I was unaware that Java had any equivalent to constructor typeclasses.
18:18:33 <newsham> vixey: i just did icfp contest w/ java.  i have to disagree.
18:18:43 <dobblego> Cale, Java has no high-kinds so no, unless you resort to casting
18:18:49 <monochrom> I'd like to teach the world to code categorically
18:18:54 <Cale> So it's not an issue :)
18:19:07 <vixey> newsham: well at least you didn't try to use a hammer as a parachute
18:19:12 <dobblego> it's an issue that they elevate scary words and stop thinking when they see them
18:19:16 <Cale> chylli: yes
18:19:21 <Cale> chylli: you're using FFI?
18:20:03 <Cale> dobblego: Well, if you can't implement functors, what's the point of even referring to them?
18:20:09 <Philonous> Toxaris_: So do haskel-monads by any chance happen to be related to the categorial monads? That would somehow seem to make sense to me.
18:20:16 <Cale> Philonous: yes
18:20:18 <chylli> Cale: what is FFI ? I just want to know how to
18:20:25 <dobblego> Cale, I am introducing higher-kinds to Java programmers, not using Java
18:20:34 <newsham> new F<String,Unit>() { publc Unit call(String arg) { ... } }
18:20:35 <vixey> dobblego: I think it's a really harmful thing to assume that because people are used to programming in <X> they will think like <Y>
18:20:42 <EvilTerran> Philonous, yes, they are
18:20:43 <Cale> Philonous: Haskell monads are monads on the category whose objects are Haskell types and whose arrows are Haskell functions.
18:20:48 <newsham> is a lot to type for lambda arg : ...
18:20:51 <vixey> if you do assume this, you can be enforcing it by accident
18:20:59 <dobblego> Cale, I have introduced higher-kinds to my 7 year old son and my missus (who is a midwife) and they understand it in 5 or 6 minutes; but Java programmers take years
18:21:01 <Toxaris_> Philonous: well, you can extend the relation of Haskell functors to CT functors to monads, as I understand it. but I don't really understand it, because i do not understand CT monads
18:21:03 <newsham> http://www.thenewsh.com/%7Enewsham/x/j/
18:21:04 <lambdabot> Title: Directory /~newsham/x/j/
18:21:23 <dobblego> vixey, it is not harmful; it is just a fact
18:21:24 <Cale> dobblego: Ah, I recommend not using Java as the implementation language then. Just teach them Haskell or something first :)
18:21:51 <dobblego> Cale, I can't help that they have been taught Java; if they hadn't, my job would be easier and I wouldn't have asked the initial question
18:22:02 <monochrom> which one comes first, haskell or monad? chicken or egg? :)
18:22:11 <Cale> dobblego: Well, I mean, ignore the fact that they know Java at all.
18:22:13 <vixey> dobblego: why do you have so much contempt for java ?
18:22:16 <Toxaris_> Cale: you can use the "Mappable pattern" :) without expressing the concept "Mappable" in code
18:22:17 <Philonous> I begin to grasp why mathematicians tend to favour haskell.
18:22:25 <Toxaris_> Cale: Java programmers are used to this kind of design
18:22:26 <monochrom> (answer: egg omelette with chicken stuffing!)
18:22:56 <dobblego> vixey, I used to work on the implementation; it is a pathetic language supported by pathetic ideas; it teaches extremely bad programming habits that prevent progress; without Java, a person learns programming so much easier
18:23:11 <monochrom> (alternative answer: Japanese "parent-child" don, where don = rice, parent = chicken, child = egg)
18:23:13 <EvilTerran> (return :: a -> Omelette a) Chicken
18:23:17 <Cale> Toxaris_: Why not call it the Functor pattern then, and point out the relationship to category theory?
18:23:25 <dobblego> vixey, I believe what Dijsktra said is true, except Java is far worse than BASIC (though, I also have hope for regeneration, otherwise, why am I talking to them?)
18:23:35 <mm_freak> if eggs were before chickens, would the first chickens eat eggs without guilty conscience?
18:23:39 <Toxaris_> Cale: because dobblego thinks that would be too scary
18:23:39 <erikc> is there a way to prevent lifting into a monad? i am trying to establish a 'GPUMonad' where only operations amenable to execution on a GPU would be allowed
18:23:51 <Toxaris_> Cale: and since its his audience, he knows, I assume
18:23:54 <Cale> This has the advantage that when they inevitably move to using Haskell, they'll already know the name :)
18:24:04 <dobblego> trust me, Java ninnies hate scary words like Functor; Mappable is better, but then I am lying; that is why I am going to use the example I am
18:24:14 <EvilTerran> erikc, no
18:24:34 <monochrom> what is "lifting into a monad"?
18:24:42 <Cale> monochrom: liftM?
18:24:48 <vixey> dobblego: basically you seem to be assuming that people are idiots because they've programmed in Java. This is a terrible idea and is not going to be productive
18:25:00 <Cale> oh
18:25:00 <monochrom> I say if you only have GPUMonad and no GPUMonadT you're done.
18:25:07 <Cale> I missed the original use :)
18:25:10 <dobblego> vixey, they aren't idiots (that's Dijsktra's view); they are just severely misguided (that's my view)
18:25:20 <dobblego> vixey, and actually, it is incredibly productive
18:25:30 <Cale> erikc: You mean, you don't want an instance of MonadIO or MonadTrans?
18:25:38 <dobblego> vixey, after all, any other assumption is just self-delusion, which colours any decisions I make
18:25:46 <Cale> erikc: Just don't implement those, and hide the data constructors for your monad.
18:25:54 <Cale> (use a module)
18:26:10 <vixey> dobblego: No it's just arrogant
18:26:15 <dobblego> vixey, no, it is a fact
18:26:22 <vixey> it's not a "fact"
18:26:31 <monochrom> I believe dobblego.
18:26:42 <dobblego> vixey, it is one supported by my extensive experience; I'll happily yield to contrary evidence; I'll see you in a few years
18:26:52 <Toxaris_> vixey: If I want to communicate a message, I have to adapt to the language of the receivers. if the audience like math, I use mathy language. If the audience like simple adjectives, I use simple adjectives. I don't see how "liking math" or "liking simple adjectives" is related to being stupid.
18:27:08 <mm_freak> dobblego: perhaps replace "Java ninnies" by "most Java programmers"
18:27:11 <dobblego> vixey, actually I would *love* to believe you are right, but sadly, you are not
18:27:11 <Cale> I prefer just treating everyone as someone who is serious and would like to learn something. If they would really not like to learn something, then they can obviously do without.
18:27:30 <erikc> so i want to define the primitive operations and prevent anyone from lifting a pure function
18:27:35 <vixey> yeah.. I agree with Cale
18:27:47 <dobblego> so do I
18:28:14 <vixey> dobblego: No you dont ...
18:28:26 <dobblego> yes I do (that you think my position is exclusive is a problem)
18:28:31 <mm_freak> many people use java, because they're limited in choice
18:28:42 <Korollary> I wish I could use java.
18:28:58 <mm_freak> for example, i'm writing a blog CMS in PHP right now…  i'd love to switch to hAppS or WASH, but i can't
18:29:04 <dobblego> I use Java a lot, even voluntarily
18:29:11 <monochrom> You can criticize dobblego for overgeneralizing his statement to all Java programmers (including me) but you have to accept his statement about the exact people he has observed.
18:29:14 <dobblego> http://functionaljava.org/ for example
18:29:15 <newsham> java is worse than basic?
18:29:16 <lambdabot> Title: Functional Java
18:29:17 <Cale> The only concern is with terms or prerequisite concepts that they may be unfamiliar with. In those cases, I would either take it upon myself to explain those, or assume that they are sufficiently diligent to go and look them up.
18:29:29 <dobblego> newsham, in terms of "mental mutilation" (Dijsktra) yes
18:29:49 <newsham> java has a decent type system at least
18:29:54 <newsham> and structured programming
18:29:59 <newsham> no goto
18:30:02 <Cale> newsham: It does?
18:30:07 <dobblego> decent type system?
18:30:10 <dolio> Compared to basic.
18:30:20 <mm_freak> newsham: java doesn't even have an unsigned integer type
18:30:20 <newsham> you can do curry-howard in java type system
18:30:31 <newsham> mmfreak: and?
18:30:33 <Saizan_> erikc: that's not really possible given that a monad has return
18:31:03 <Cale> Saizan_: what?
18:31:08 <monochrom> what is wrong with lifting a function?
18:31:13 <dobblego> newsham, the Java guys jump ship to Ruby/Python because of its type system; what have they learned?
18:31:17 <newsham> disjunction: http://www.thenewsh.com/%7Enewsham/x/j/E.java,  conjunction: http://www.thenewsh.com/%7Enewsham/x/j/P.java ,  implication: http://www.thenewsh.com/%7Enewsham/x/j/F.java
18:31:20 <mm_freak> newsham: maybe it's just me, but IMO every language should feature signed and unsigned integer types
18:31:27 <Saizan_> Cale: prevent lifting a pure function
18:31:34 <dobblego> newsham, that is also available in functionaljava.org
18:31:37 <Toxaris_> erikc: I think a monadic interface is not appropriate for your DSL
18:31:37 <Cale> mm_freak: Can't you construct such a type?
18:31:42 <newsham> mmfreak: sure, i'd agree.  but i dont see what that has to do with comparisonto basic or the type system.
18:31:49 <dobblego> newsham, however, "decent type system" is quite a stretch
18:31:50 <mm_freak> Cale: you can, at the expense of performance
18:31:56 <Korollary> mm_freak: it's a minor issue
18:32:11 <Toxaris_> erikc: since I don't see how bind should work
18:32:12 <erikc> toxaris: yea, i guess not
18:32:37 <Korollary> dobblego: What's 'decent'?
18:32:42 <Toxaris_> erikc: bind would have to extract the current GPU result out of the GPU, perform arbitrary Haskell computation on the CPU, and transfer the result back to the GPU
18:32:46 <newsham> dobblego: how so?
18:33:03 <Toxaris_> erikc: which is probably not what you want :)
18:33:18 <Cale> Toxaris_: are you sure that the monad in question might not just build GPU computations to be performed later?
18:33:25 <erikc> yea
18:33:32 <dobblego> well, we have already observed that we cannot even model a Functor safely
18:33:33 <mm_freak> newsham: however, just because you "can" implement some sophisticated paradigm, it doesn't make your idea 'decent'
18:33:43 <mm_freak> you can implement a general number field sieve in brainfuck
18:33:52 <Korollary> dobblego: Is that a requirement to be 'decent'?
18:33:53 <mm_freak> that doesn't make brainfuck 'decent'
18:33:58 <Toxaris_> erikc: on the other hand, there are monadic assembler DSLs in Haskell, so maybe I'm thinking nonsense
18:34:08 <dobblego> Korollary, no, but it's just one case of hundreds
18:34:16 <Korollary> dobblego: I don't think it is.
18:34:23 <erikc> they must issue errors when you attempt to 'generate' code
18:34:27 <newsham> mmfreak: sure it does.  yu "cant" do it in python/ruby/lisp/perl/C
18:34:28 <erikc> so it wouldnt be static
18:34:29 <erikc> hrm
18:34:55 <dobblego> Korollary, then, I invite you to understand Java and present me with evidence about why I am wrong
18:34:57 <erikc> i guess i should be using a data type then for a shader dsl
18:34:58 <Cale> Toxaris_: right, you don't have things like  r3 <- add r1 r2, but instead add r1 r2 r3
18:35:02 <newsham> "just because you can implement a turing machine doesnt make it turing ocmplete!"
18:35:15 <Cale> Toxaris_: <- is only used to capture jump labels :)
18:35:22 <Korollary> dobblego: I can't do such a thing. You have an indescribable criterion for a type system to be decent.
18:35:51 <dcoutts> @tell Lemmih happs mis-reports it's version number. wget -S tells me "Server: HAppS/0.8.4" though I'm using the latest hackage release.
18:35:51 <lambdabot> Consider it noted.
18:35:51 <erikc> my other alternative is template haskell
18:35:54 <Toxaris_> Toxaris_: hmm ok, so you use mdo and bind for backpatching jumplabels, and >> for sequences, and a Writer monad for the output of assembler code
18:35:57 <dobblego> Korollary, even if you could give me something worse, I'd consider conceding
18:36:08 <mm_freak> newsham: my point is that there is no axiomatic idea of being 'decent'
18:36:10 <dcoutts> @tell Lemmih and what is the custom HUH header than hackage sends?
18:36:10 <lambdabot> Consider it noted.
18:36:12 <Cale> Toxaris_: talking to yourself? :)
18:36:23 <Korollary> dobblego: Java's is not the worst type system out there.
18:36:25 <erikc> i could do a template haskell func that, given a lambda, would only allow certain forms inside it
18:36:31 <newsham> mmfreak: the quality is higher than that of BASIC/c/python/ruby/perl/lisp/...
18:36:35 <monochrom> monochrom: I like Java type system :)
18:36:37 <Toxaris_> Cale: :)
18:36:43 <dobblego> http://tinyurl.com/65f268 (disjunction) http://tinyurl.com/683jrb (conjunction) http://tinyurl.com/5sgqq5 (implication)
18:36:47 <mm_freak> how much sense does it make to use curry-howard typing in java?
18:36:52 <monochrom> Toxaris_ is demonstrating mdo :)
18:37:07 <vixey> stop trying to write haskell in Java, write Java in Java
18:37:09 <dobblego> mm_freak, you need such concepts to help make Java usable
18:37:13 <monochrom> oops, it should be...
18:37:17 <monochrom> monochrom: Toxaris_ is demonstrating mdo :)
18:37:37 <dobblego>  nobody is writing Haskell; they are just representing simple programming concepts
18:37:45 <Pseudonym> The worst type system is probably one where types are meaningful, but the compiler gives you absolutely zero help in diagnosing type problems.
18:37:46 <newsham> mmfreak: it allows you to build abstract types while maintaining strong static typing
18:37:48 <Pseudonym> COBOL, probably.
18:38:07 <Toxaris_> erikc: ok, if you do it like I have told me, you can just allow arbitray computations, since they will be program generators, not programs
18:38:16 <newsham> as opposed to, say, C where you must bypass the type system to implement genericity
18:38:25 <Pseudonym> C has type errors.
18:38:28 <mm_freak> dobblego: well…  PHP's type system is simple and useless…  but it does its job for simple web applications
18:38:29 <dobblego> Java's parametric polymorphism is invariably invariant; don't bother with the borked attempt to introduce covariance and contravariance
18:38:30 <Pseudonym> That the compiler reports to you.
18:38:36 <Pseudonym> It's not great, but it's something.
18:38:40 <Korollary> I'd rate Java & C# type systems as 'decent' as that's where they're at. I'd rate Haskell as, say, excellent and C as poor. You shouldn't expect too much from a "decent" type system.
18:38:52 <newsham> i'm not interested in winning the special olympics today
18:39:29 * Pseudonym thinks about Korollary's argument there
18:39:55 <dobblego> Korollary, what you call decent, I call crap (though, C# is significantly improved in its type system over Java)
18:40:07 <dobblego> we're agreeing just using different definitions
18:40:15 <mm_freak> newsham: so it is ultimately 'decent'?  the type system of C++ is quite sophisticated, while maintaining original C's strong connection to memory…  it fulfills its task
18:40:16 <Korollary> So is C# decent?
18:40:33 <Pseudonym> "Decent" in the sense that you could introduce them to your mother.
18:40:35 <dobblego> Korollary, under your definition, prolly
18:40:38 <Pseudonym> I'll buy that.
18:40:46 <newsham> i'd say C++ is probably "decent" to slightly ad hoc and baroque
18:40:48 <mm_freak> Korollary: i don't think that C's type system is "poor"…  it's simple and memory-oriented
18:40:51 <Toxaris_> erikc: have you looked at one of the other assembler-monads? may be instructive
18:40:57 <Pseudonym> If Java is decent, then so is C++.
18:41:02 <monochrom> Oh, so decent means it doesn't use swear words? :)
18:41:16 <newsham> c++ is baroquen
18:41:25 <Pseudonym> C++'s type error messages leave a lot to be desired, certainly.
18:41:40 <newsham> ghc's type errors are a joy to work with!  ;-)
18:41:45 <Korollary> Pseudonym: It's an implementation issue
18:41:50 <Pseudonym> I agree.
18:41:51 <erikc> toxaris: which are those?
18:42:01 <newsham> use a preprocessor for coding and a post-processor for interpretting errors :)
18:42:05 <erikc> didnt know they existed
18:42:05 <newsham> thats the c++ philosophy
18:42:14 <erikc> when you say, assembler, you mean, assembly code?
18:42:24 <mm_freak> well…  GHC's type errors are funny sometimes
18:42:39 <mm_freak> especially when it comes to "unable to construct infinite type"
18:42:45 <Pseudonym> Actually, the C++ philosophy is to wrap your templates in multiple layers to finesse the compiler into giving you nice error messages.
18:42:51 <Toxaris_> erikc: yes, and I have no clue how they are called, just that they exist :)
18:43:02 <erikc> ah k, ill search around :)
18:43:07 <Korollary> The reason I rate Java & C# close is although Java's type system may have more 'inadequacies', I think their impact on software engineering practices is similar.
18:43:15 <newsham> anyway, I still maintain java > BASIC.  dijkstra would surely agree.
18:43:32 <Pseudonym> Java and C#'s type systems are essentually Modula-family type systems.
18:43:37 <Toxaris_> Pseudonym: Oleg uses similiar techniques with type instances, e.g. adding classes without instances for the sole purpose of generating slightly better error messages
18:43:50 <mm_freak> BASIC is old and shows its age
18:43:53 <Pseudonym> Which, like C's type system, is an offshoot of Algol.
18:43:57 <newsham> (BASIC is my first language and still holds a special place in my memories.. much more so than Java ever will)
18:44:02 <erikc> once c++ gets type inferencing with 'auto' and closures in C++0x it will actually be quite respectable
18:44:13 <mm_freak> making quality conclusions for a language based on comparison to BASIC is foolish
18:44:18 <Pseudonym> There's something to be said for sigil-based types.
18:44:23 <erikc> aside from trying to teach people how to do and understand template metaprogramming
18:44:26 <Korollary> newsham: Commodore 64 Basic 1.2 38k free
18:44:31 <newsham> sys 64738
18:44:46 <monochrom> I learned structured programming with BASIC.
18:44:49 <Pseudonym> mm_freak: That's like saying that I read Steinbeck, but I'll always have a soft spot for The Very Hungry Caterpillar.
18:45:04 <Pseudonym> It's a reasonable thing to say.
18:45:11 <newsham> poke 53281,0
18:45:25 <Korollary> Omg the cursor just went black
18:45:28 <newsham> of course all the fun stuff was at sys 49152
18:45:46 <Pseudonym> Incidentally, take the BASIC challenge:
18:45:48 <Pseudonym> http://andrew.bromage.org/blog/archive/2007/10/so-you-think-you-know.html
18:45:51 <lambdabot> Title: So you think you know BASIC? - The BWAIN, http://tinyurl.com/66tuu5
18:45:53 <mm_freak> i never liked that poking around in memory
18:45:58 * codacola hates debugging
18:46:08 <mm_freak> i'm glad that this idea is dead for all time
18:46:10 <newsham> then you dont like programming
18:46:12 * monochrom eliminates debugging
18:46:17 <newsham> there are two phases of programming:  bugging and debugging.
18:46:27 <Korollary> It's not dead for all time.
18:46:35 <monochrom> Yeah, welcome to proving.
18:46:40 <erikc> e.g. you can implement a list monad in c++ by overloading >>= and writing closure types, and g++ will inline it all, fold the gump away and turn it into a perfect loop nest
18:46:42 <mm_freak> newsham: i've done enough bugging with QBASIC and x86 assembler =)
18:46:51 <mm_freak> the debugging started with turbo pascal and borland C++
18:47:15 <erikc> i have that as a poor man's first order prolog
18:47:32 <mm_freak> Korollary: let's say you don't have to deal with it, unless you build hardware
18:48:06 <Korollary> mm_freak: or you need to produce assembly
18:49:38 <monochrom> BASIC is slow.
18:49:55 <vixey> Prolog is way way more than >>=
18:50:19 <erikc> vixey: of course
18:50:25 <vixey> well 2 things more than >>=
18:50:26 <mm_freak> Korollary: when do i _need_ to produce assembly?  even most device drivers can be written without assembly these days
18:51:01 <erikc> which 2?
18:52:03 <Korollary> mm_freak: you may be writing a compiler
18:52:11 <monochrom> cut, unification
18:52:13 <vixey> erikc: >>=, clause/2 and !/0 should do
18:52:41 <erikc> right
18:53:08 <vixey> would be nice to get rid of !/0...
18:53:11 <erikc> i dont support higher order stuff though, just fact table lookups, so clause/2 isnt needed
18:53:14 <monochrom> What is !/0? You can't divide by 0...
18:53:28 <erikc> and i implement cut
18:53:32 <byorgey> you can divide FACTORIAL by zero.
18:53:56 <byorgey> by definition, factorial divided by zero is sqrt(ln(pi))
18:53:57 <erikc> as a bail out of the 'map' in >>=
18:54:00 <mm_freak> Korollary: ah, you mean producing as in generating…  well, the code needs to poke around, but not to change the screen's color, if you know what i mean
18:54:30 <mm_freak> abstraction and encapsulation is the standard these days
18:55:05 <MyCatVerbs> byorgey: how the Hell does that work?
18:55:41 <MyCatVerbs> monochrom: why should BASIC be slow? It doesn't have any sufficiently interesting features to rule out compilation (no reflection, etc).
18:56:09 <monochrom> I'm paroding "___ is slow".
18:56:09 <byorgey> MyCatVerbs: it's very very complicated.  It has to do with normalized Ricci flows and this certain PDE in 28 dimensions.
18:56:20 <newsham> how fast do you need to be to print hello and goto 10?
18:56:21 <byorgey> I could explain it, but it would take a while.
18:56:28 <mm_freak> BASIC compilers produce slow code, because nobody cares to write a better compiler
18:56:40 <MyCatVerbs> byorgey: are you bullshitting me? Please be honest, because I can't tell.
18:56:46 <jcreigh> BASIC compilers are slow because they are written by people who like BASIC. :P
18:56:54 <mm_freak> hehe
18:56:59 <byorgey> hahaha, I have always been a good bullshitter =)
18:57:09 <byorgey> I always win at Balderdash
18:57:21 <MyCatVerbs> But you could trivially write a BASIC->C conversion. Just add code in to check array bounds and you're pretty much done.
18:57:34 <monochrom> I want to learn that skill! Perhaps category theory will help...
18:57:45 <jcreigh> ah, that's a good game. But IME most BASIC implementations are interpreters for some reason.
18:57:48 <newsham> > let fact 0 = 1; fact n = n * fact (n - 1) in fact / 0
18:57:56 <lambdabot>   add an instance declaration for (Fractional (t -> t))
18:58:15 <MyCatVerbs> byorgey: was wondering how the Hell you define division on a function so that the result is a constant...
18:58:41 <mm_freak> MyCatVerbs: that makes BASIC faster linearly by a neglible factor, because BASIC programmers write bad code…  they use an exponential time algorithm, where they could just have written a constant
18:59:05 <byorgey> MyCatVerbs: hehe
18:59:32 <mm_freak> (i remember implementing the atan2() function from C over and over again, which is a pain to implement in BASIC)
19:00:10 <MyCatVerbs> mm_freak: gah. What kind of perverse bastard would neglect to put atan2 in? oO
19:00:53 <mm_freak> microsoft
19:00:59 <codacola> hm, is it generally good style in haskell to write the functions that A uses after the defintiion of A rather than before?
19:01:16 <vixey> what's A ?
19:01:18 <mm_freak> because older BASICs never had to deal with mathematics, which go beyond vector addition
19:02:06 <mm_freak> A may be the predecessor of B, which is the predecessor of C
19:02:06 <byorgey> codacola: either way is fine, if you think it is clearer that way then go for it
19:02:08 <Saizan_> codacola: if they are not very important and the names are enough descriptive to let you understand the definition of A then yes
19:02:20 <newsham> bcpl is the predecessor of b
19:02:21 <codacola> ah
19:02:26 <MyCatVerbs> mm_freak: but surely someone *before* then would've come up with a need for it, then someone at MS would've had to have added it in order to keep up... argh.
19:03:08 <MyCatVerbs> mm_freak: forgive me for assuming nice things about the state of the universe and consequently being violently disillusioned.
19:03:34 <mm_freak> actually i needed atan2() when i was about 13 years old, because i didn't know about vectors at all =)
19:03:49 <Saizan_> MyCatVerbs: you can "put" a new state if you prefer
19:03:56 <mm_freak> i implemented the idea of a players "direction" is an angle
19:04:31 <mm_freak> hmm
19:04:34 <byorgey> mm_freak: hehe, awesome =)
19:04:37 <mm_freak> next try
19:04:44 <mm_freak> i implemented the idea of a player's "direction" as an angle
19:05:00 <newsham> 13year olds should not be exposed to trigonometry
19:05:07 <newsham> someon call child protective services
19:05:14 <mm_freak> newsham: i exposed myself =)
19:05:27 <MyCatVerbs> Saizan_: that'd require me to get >>= (put . makeNice), and I really don't want to risk evaluating a thunk that enormous - I might as well just bottom out where I stand and save time.
19:05:32 <newsham> clearly a failing on your parents part
19:05:56 <mm_freak> since i have the lowest educational grade in germany ("hauptschule" — "elementary school"), i wouldn't learn such things in school
19:06:11 <mm_freak> you don't learn about trigonometry at all there
19:06:49 <MyCatVerbs> Saizan_: I know using the lazy State Universe that'd be fine, because I'd be improving chunks of universe on-demand rather than all at once, but Murphy's Law says nineteen to the dozen, some bastard made the whole thing strict.
19:07:22 <monochrom> Lazy State University? Where is it? I want to join!
19:07:23 <Saizan_> eheh
19:09:31 <Toxaris_> I thing the universe is lazy in such a way, that everything lazily starts happening so that it has finished happening in the moment it is needed to make something else start happening and so on
19:09:47 <Toxaris_> the process is started by a supernatural being demanding the end-state of the universe
19:10:20 <newsham> so the world is demand driven by vishnu?
19:10:36 <monochrom> Or some curious cat opening a box to see whether the human inside is live or dead.
19:10:40 <newsham> how nihilistic
19:11:01 <Toxaris_> actually, that's not at all what I think, but it's a funny idea
19:11:32 <mm_freak> lol
19:13:39 <mm_freak> haskell would be a wonderful candidate for implementing quantum computer programs
19:14:14 <vixey> yeah people seem to be using it for that already
19:14:39 <mm_freak> do { x <- manyValues; return (x+1) }
19:15:09 <Toxaris_> quantum computing is not nondeterminism
19:15:28 <newsham> http://sigfpe.blogspot.com/2007/03/independence-entanglement-and.html
19:15:29 <lambdabot> Title: A Neighborhood of Infinity: Independence, entanglement and decoherence with the  ..., http://tinyurl.com/6mzexe
19:15:40 <mm_freak> true
19:16:07 <gwern> I would swear I've seen at least two quantum programming languages in haskell
19:16:14 <gwern> altho one was just a bunch of monads, iirc
19:16:25 <newsham> ?go Shor in Haskell
19:16:27 <lambdabot> http://www.cs.nott.ac.uk/~asg/pdfs/tfp08.pdf
19:16:27 <lambdabot> Title: Shor in Haskell The Quantum IO Monad
19:16:34 <monochrom> Haskell is a wonderful language for everything anyway.
19:17:18 <mm_freak> hmm
19:17:39 <Pseudonym> monochrom: Except writing Fortran in.
19:17:52 <Toxaris_> monochrom: We have had issues with encoding complex rank-n-types, we needed so many newtypes and a lot of copies of id with specific types
19:18:06 <monochrom> Oh, wonderful.
19:18:08 <Toxaris_> monochrom: that in the end, it was easier to write it in plain FOmega instead of Haskell
19:18:15 <monochrom> (See? It is wonderful :)
19:19:11 <Toxaris_> but currently I am writing a little bit of scheme, and that's horrible
19:19:29 <monochrom> What do you find horrible?
19:19:32 <Toxaris_> I get errors like "cannot apply 42 to 10 arguments" all the time :(
19:19:46 <Toxaris_> scheme is great, but I miss pattern matching and I miss a type system
19:20:00 <mm_freak> Toxaris_: well, there would be a collapseList function somewhere, which is equivalent to observing a result
19:20:09 <monochrom> Oh hahahahaha, you forgot it's '(42 10 10 10 10) you wrote (42 10 10 10 10)
19:20:25 <Toxaris_> not so easy...
19:20:27 <mm_freak> btw, i'm talking about writing quantum programs, not about writing quantum computer simulators
19:20:49 <Toxaris_> it's more like I write (my-eval '(my embedded language) 42)
19:20:56 <vixey> Toxaris_: You can add pattern matching to scheme quite easy
19:21:13 <Toxaris_> I contemplated learning syntax-rules and writing a simple pattern matcher
19:21:17 <newsham> 42 works better as an answer than an input
19:21:22 <vixey> Toxaris_: I have one
19:21:28 <Toxaris_> matching on s-expressing would be so convenient
19:21:39 <mm_freak> as far as i've understood, a quantum program is the same as a classical program, but it manipulates the probabilities of a value instead of the value itself
19:21:42 <Toxaris_> cool where?
19:21:58 <vixey> Toxaris_: hopefully this makes sense on it's own... http://muaddibspace.blogspot.com/2008/04/scheme-pattern-matching-with-syntax.html
19:22:00 <lambdabot> Title: Muad`Dib: Scheme Pattern Matching with syntax-rules, http://tinyurl.com/58yz9y
19:22:00 <Toxaris_> mm_freak: it manipulates the probabilities of all values at once
19:22:23 <vixey> thing to note is you must do CPS for macro subroutines
19:24:13 <mm_freak> interestingly the people here mostly talk about theoretic stuff, concepts, ideas, paradigms, …  in channels for other languages the topics are mostly "how can i do …?"
19:24:21 <Toxaris_> I have read a bit about scheme macros on the web, and ended up on olegs page :)
19:24:36 <mm_freak> i think the fact that there is no "doing" in haskell, but rather just a "being" shows its fruits =)
19:24:37 <Toxaris_> we handle this kind of questions with
19:24:38 <vixey> oleg used syntax-rules as a theorem prover :D
19:24:40 <monochrom> That's because we love newbies and we have eaten them all.
19:24:41 <Toxaris_> @faq
19:24:41 <lambdabot> The answer is: Yes! Haskell can do that.
19:26:04 <mm_freak> who's oleg and why does everybody make fun of him/her?
19:26:27 <vixey> mm_freak: no they actually did use syntax-rules as a theorem prover
19:26:28 <Zao> mm_freak: Oleg is some scary dude that is super awesome at programming.
19:26:34 <vixey> there is a video on google about it
19:26:40 <monochrom> More seriously, most haskell newbies learn haskell by self-motivation, more inclined to investigate independently before asking.
19:26:41 <Zao> And just about everything else.
19:27:18 <monochrom> Other language newbies learn other languages by boss order, professor order, market order... the motivation is low.
19:27:19 <mm_freak> monochrom: there's currently a newbie on usenet, who proves the opposite
19:28:00 <monochrom> Yes yes, there are exceptions. There are also professors like Bird and Hutton ordering victims to learn Haskell too, and we do get their "how do I"s.
19:29:04 <mm_freak> at least you can always answer: "there is no doing in haskell, dude"
19:29:30 <Toxaris_> mm_freak: Oleg writes very good short articles (e.g. mailing list postings) about advanced, very advanced and incredibly advanced programming tasks
19:29:42 <Toxaris_> mm_freak: sometimes even superhuman advanced
19:29:52 <mm_freak> Toxaris_: is that irony?
19:29:59 <vixey> Oleg also co-authored a wonderful book about logic programming
19:30:08 <Toxaris_> mm_freak: no
19:30:10 * vixey recommends it to everyone
19:30:17 <vixey> unless you hate books
19:30:27 <Toxaris_> mm_freak: well, it is meant to be funny, but it is not meant to mean the opposite from what it means, so it is not irony
19:30:57 <mm_freak> ok =)
19:31:20 <mm_freak> so just like bruce schneier for cryptography
19:31:36 <mm_freak> a guy, who folds monads with a roundhouse kick
19:31:56 <vixey> bruce schneier had an interesting article about generating exploits automatically from bugfixes
19:32:03 <monochrom> As in "Schneier writes paranoid, very paranoid, and ultra paranoid articles on security"? :)
19:33:09 <mm_freak> as in "bruce breaks your cryptosystem, before you invented it"
19:33:43 <mm_freak> oleg solves your problem, before it appeared to you
19:33:54 <gwern> > 90 / 7
19:33:55 <lambdabot>  12.857142857142858
19:34:32 <vixey> @quote
19:34:33 <lambdabot> bootslack says: Once, around the time of the discovery of fire, there was a large population of people that thought mastering fire would be too difficult so they didn't. The rest of us killed them,
19:34:33 <lambdabot> cooked them and ate them.
19:35:01 <Toxaris_> oleg shows that your problem involving dependent types and explicit phase control is easily solved in H98 by embedding a Haskell compiler in newtype instances
19:35:04 <monochrom> hehehehehe
19:35:20 <mm_freak> i get the idea =)
19:36:02 <Toxaris_> and the cool thing is that you can read his article and think, yes, that was indeed easy
19:36:08 <gwern> @quote oleg
19:36:08 <lambdabot> shapr says: [on Oleg:]  And ccshan and he would argue furiously for a minute or two and then SPJ would say "Why don't you send an email to the Haskell list about that so we can have time to understand
19:36:08 <lambdabot>  what you just said?"
19:36:14 <Toxaris_> vixey: is that your blog? can I use that code?
19:36:19 <monochrom> There was a lambdacat for that. Look for "Oleg cat saz: see, your type problem is not so difficult afterall"
19:36:23 <gwern> @quote oleg
19:36:23 <lambdabot> audreyt says: assembly would require metaolegs (or megaolegs)
19:36:35 <vixey> Toxaris_: yes, of course you can
19:36:59 <gwern> @quote oleg
19:37:00 <lambdabot> shapr says: [on Oleg:]  And ccshan and he would argue furiously for a minute or two and then SPJ would say "Why don't you send an email to the Haskell list about that so we can have time to understand
19:37:00 <lambdabot>  what you just said?"
19:37:36 <gwern> hm. what happened to the oleg facts?
19:37:38 <gwern> @olegfacts
19:37:39 <lambdabot> Unknown command, try @list
19:37:46 <gwern> @oleg
19:37:47 <vixey> http://video.google.com/videoplay?docid=-7990603720514207956
19:37:47 <lambdabot> Defined.
19:37:48 <lambdabot> Title: Oleg Kiselyov: Normal-order Syntax-Rules (Dan Friedman's 60th Birthday)
19:38:02 <mm_freak> @quote maybe
19:38:02 <lambdabot> gzl says: [on why monads are scary] maybe it's because people look up monad on wikipedia, find the category theory page, and crap themselves
19:38:04 <Toxaris_> vixey: great.
19:38:14 <gwern> dang it
19:39:16 <mm_freak> @quote ice tea
19:39:16 <lambdabot> No quotes for this person. You type like i drive.
19:40:34 <mm_freak> > 2 + 2
19:40:35 <lambdabot>  4
19:40:42 <mm_freak> > let 2 + 2 = 5 in 2 + 2
19:40:44 <lambdabot>  5
19:40:59 <vixey> @let 2 + 2 = 5
19:40:59 <lambdabot> Defined.
19:41:05 <mm_freak> > 2 + 2
19:41:07 <lambdabot> Terminated
19:41:13 <Toxaris_> :)
19:41:21 <mm_freak> > 2 + 3
19:41:22 <lambdabot> Terminated
19:41:30 <vixey> @break lambdabot
19:41:31 <lambdabot> Plugin `dummy' failed with: Prelude.read: no parse
19:41:43 <mm_freak> huh?  no exhausted patterns?
19:41:57 <Toxaris_> @let (2 :: Int) + (2 :: Int) = (5 :: Int)
19:41:58 <lambdabot>  Parse error in pattern
19:42:00 <Toxaris_> :(
19:42:32 <atp> there was an @olegfacts command?
19:42:36 <atp> that's great
19:43:18 <mm_freak> @let x + y = if (x::Int, y::Int) == (2, 2) then 5 else undefined
19:43:18 <lambdabot> Defined.
19:43:23 <mm_freak> > 2 + 2
19:43:24 <lambdabot> Terminated
19:43:43 <mm_freak> > 2 + 3
19:43:44 <lambdabot>  5
19:43:51 <mm_freak> huh?!
19:44:07 <mm_freak> > (2,2) == (2,2)
19:44:08 <lambdabot>  True
19:44:36 <codacola> omg
19:44:39 <mm_freak> > 2 + 4
19:44:40 <codacola> 2 hours spent debugging and it was something so simple
19:44:40 <lambdabot> Terminated
19:44:54 <mm_freak> @undef (+)
19:44:55 <lambdabot> Undefined.
19:45:00 <mm_freak> > 2 + 2
19:45:01 <lambdabot>  4
19:45:22 <vixey> codacola: what was it ?
19:45:39 <Toxaris_> mm_freak: try /msg lambdabot @def whatever. she will answer with an old error message
19:46:46 <Toxaris_> lambdabot has problems with multiline error messages sometimes, but sends more output when /msg'ed
19:47:00 <codacola> vixey: its a module to add 2 "long" numbers together, i was returning the same list from 2 functions, then adding those together. result was if the 2 lists were the same length, the first list gets added to itself
19:47:23 <vixey> codacola: what is a long?
19:47:51 <codacola> [Int]
19:47:59 <vixey> oh
19:48:04 <vixey> why not [Bit]
19:48:18 <codacola> addLong x y = normalize' (addColumns (fillSmaller x y) (larger x y)), thats where my problem was. if the smallest and largest were the same length, then the 2 functions returned the same list
19:48:29 <mm_freak> ah, ok
19:48:33 <Toxaris_> > length . show $ 124 ^ 43 -- whats wrong with Integer?
19:48:33 <codacola> so jsut changed it so by default larger will return y, solves the problem
19:48:34 <lambdabot>  91
19:48:53 <codacola> Toxaris_: its the assignment :P
19:48:56 <mm_freak> codacola: considered using Integer?
19:49:02 <mm_freak> or are you doing that for education?
19:49:04 <Toxaris_> codacola: oh ok :)
19:49:16 <mm_freak> ah ok, just answered =)
19:49:29 <codacola> the assignment task was to make such a package, we were told the steps to take, and just had to implemented the functions basicly
19:49:32 <vixey> :t map digitToInt . show . ((+)`on`(read . map (""0123456789!!)))
19:49:33 <lambdabot> Not in scope: `on'
19:49:36 <Toxaris_> mm_freak: see, there *are* people learning Haskell, but they just solve their problems at home, and then come hear for a break
19:49:40 <codacola> part 2 was to make a small tuple based database for a video store
19:49:42 <codacola> that was fun
19:50:02 <codacola> smoke time
19:50:10 <codacola> think ive deserved it after that
19:50:20 <erikc> haskell has ruined me, dealing with c++ nonsense at work is depressing now
19:50:35 <dogbite> erikc: i hear ya -- i don't use c++ at work but
19:50:53 <dogbite> every time i glance at a job posting and see "must be expert at c++" i immediately pass
19:51:26 <dogbite> erikc: i pity all the fools who did the google code jam in c++
19:51:35 <erikc> haha, there were a lot of them
19:51:53 <vixey> ((.) (map digitToInt) show .) . ((+)`on`(read . map ("0123456789"!!)))
19:51:54 <vixey> :/
19:52:05 * vixey cheats
19:56:50 <codacola> vixey: i also managed to worry my lecturer yesterday. asked her if it was ok to use list comprehensions in the assignment, she was already worried the class might be too slow (ive now finished the assignment a month before its due)
19:57:24 <Toxaris_> codacola: hehe do you have a Num instance?
19:57:41 <vixey> codacola: I know the feeling
19:58:19 <b\6> it's a waste of time and money. get them to give you something challenging.
19:59:11 <codacola> Toxaris_: as in "Num a =>....."?
19:59:47 <Toxaris_> codacola: yeah, you can make your own, so that people can use your [Int] as 'a' in such types
20:00:16 <Toxaris_> codacola: instance Num [Int] where a + b = ...; a * b = ...; ...
20:00:47 <codacola> never pondered that, but in anycase gotta get the lab work done for tomorrow
20:00:54 <codacola> cant be bothered sitting in the lab
20:03:39 <codacola> has anyone here used hsdl?
20:06:00 <dolio> I don't think 'instance Num [Int] ...' is valid Haskell98, if you're concerned about that.
20:06:45 <dolio> Although, amusingly enough, 'instance Num a => Num [a] ...' would be.
20:10:56 <codacola> hm, a guard could make this more elegant
20:17:11 <chrisdone> what's this sort of italics L that I see in my math book in such a way like triangle ACD and ABE are congruent hence LABE = LACD
20:17:24 <codacola> angle
20:17:39 <chrisdone> ah, thanks
20:17:43 <codacola> angle ABE is congruent to angle ACD
20:18:55 <codacola> chrisdone: now maybe you can help me. my book has a question "howManyOfFourEqual :: Int -> Int -> Int -> Int -> Int", where im meant to return how many are equal to each other. what would you do for the case a = b and c = d?
20:20:00 <chrisdone> howManyOfFourEqual 1 1 1 1 = 4, I'd expect?
20:20:16 <codacola> yup, and 1 1 1 3 would be 3
20:20:24 <codacola> but what about 2 2 3 3?
20:20:47 <chrisdone> hm
20:20:53 <TSC> Doesn't seem very well defined
20:21:00 <chrisdone> no, it doesn't
20:21:07 <codacola> its not, its a dumb book, but gotta do it for the assignment :P
20:21:26 <TSC> You'd better ask whoever gave you the assignment
20:21:35 <dogbite> TSC: seems well defined to me
20:21:51 <dogbite> 2 2 3 3 == 4
20:22:05 <dogbite> oh
20:22:12 <Zao> @type map length.Data.List.group.Data.List.sort
20:22:13 <lambdabot> forall a. (Ord a) => [a] -> [Int]
20:22:15 <codacola> equal to each other
20:22:21 <dogbite> just how many groups of length > 1
20:22:29 <chrisdone> dogbite: so that would be 2=2,2=2,3=3,3=3
20:22:41 <codacola> the howManyEqual :: Int -> Int -> Int -> Int is sane. can only be 3 2 or 1
20:22:46 <chrisdone> but is it necessary to say 2=2 and 2=2?
20:23:07 <dogbite> i guess "how many groups of length > 1" is not right
20:23:32 <codacola> i could just say "2" in that case, then complain that its a silly question if its wrong :P
20:24:31 <chrisdone> > sum . map length . group . sort $ [1,1,2,2,3,3]
20:24:31 <lambdabot>  6
20:24:33 <TSC> I would ask for clarification, but if you don't get any, state in the comments your assumption
20:24:54 <codacola> ill go backwards, ill add a comment then ill ask tomorrow
20:25:05 <TSC> i.e. "I interpret this stupid question as really meaning ..."
20:25:51 <codacola> asked a question about the assignment yesterday and she goes "oh you must be so bored in this class at the moment", then offered to give me more work :|
20:25:59 <dogbite> chrisdone: yeah, that's how interpret it
20:26:43 <codacola> heh fun way to define the "4" case. a + b + c + d == 4*a
20:27:32 <chrisdone> yeah, however you'd have to do that for all a,b,c,d, eh?
20:28:04 <codacola> could be used for the 3 case too. a + b + c + d == 4*a - d (then have an or for each of them)
20:28:21 <codacola> no, 3*a + d
20:29:22 <codacola> yesterday she was asking us to define nAnd, about 3 definitions were written on the board in the end
20:29:38 <codacola> still no one had considered not(a `and` b)
20:29:42 <codacola> oops, &&
20:29:46 * codacola needs a break
20:29:54 <chrisdone> not . (^
20:30:01 <chrisdone> (&&) wasn't considered?
20:30:09 <chrisdone> er, I meant (not . (&&))
20:30:52 <chrisdone> what others can there be? nAnd a b = (not a) && b?
20:34:36 <codacola> |(a && b) = False :P
20:35:09 <chrisdone> ·_.
20:37:28 <gwern> wouldn't not . and be the same as =\?
20:37:49 <chrisdone> :t (=\)
20:37:50 <lambdabot> Not in scope: `=\'
20:38:37 <chrisdone> > let a =\ b = a == not b in True =\ False -- ?
20:38:38 <lambdabot>  True
20:38:39 <gwern> er, /=
20:38:42 <chrisdone> oh
20:38:48 <gwern> I never can remember how to spell it
20:38:51 <chrisdone> heh
20:39:17 <gwern> well, it's true. there're 4 ways to spell it, and they all look the same
20:39:35 <chrisdone> and they all look like sad faces
20:44:30 <codacola> annoying. what would you call a 2x2 block of chess squares?
20:44:37 <codacola> eg black white, white black
20:45:06 <O_4> quad?
20:45:07 <jcreigh> I don't know if there's a special name for that.
20:45:13 <Saad_> Guys, how exactly would I get lamdabot to work offline?
20:45:32 <codacola> ive named it chess4 :P
20:45:33 <jcreigh> Saad_: get the source, compile it and run it?
20:45:43 <lispy> codacola: I missed part of the discussion, but found a stale scroll back.  Whoever said it's a waste of time and money is right.  If you have a uni class that isn't challenging, then something is wrong and the money paid for you to be in the class is not being spent correctly.  (in other words, you should try negotiating with the instructor for something more challenging)
20:45:48 <Saad_> jcreigh, Ah, alright I thought there would be another trick to it
20:45:54 <cjb> codacola: "2x2 checkerboard"?
20:46:08 <chrisdone> saad: it's quite difficult to get it to build and then it's hard to get it to run properly. good luck
20:46:42 <jcreigh> chrisdone: hmm. Perhaps my memory betrays me. I recall it being fairly easy to build and run.
20:47:23 <chrisdone> jcreigh: I am speaking from personal experience and what I have observed for others in this channel. maybe we're just unlucky ;)
20:49:18 <lispy> Saad_: once upon a time it was very easy to get lambdabot to build and run, offline or otherwise.  Then someone completely redid the initization/parametrization code and left out crucial functionaliity.
20:49:46 <lispy> Saad_: But, even taht was at least a year ago now, so who knows how hard it is :)
20:49:57 <Saad_> lispy, Hehe ;)
20:53:16 <codacola> lispy: the class would be a challenge if i hadnt of read my book for a month before classes even started
20:58:49 <hml> i'm  working on an open source constructive solid geomtry library; i want to write it in haskell; but the one thing that is stopping me right now is that I don't see the array type in haskell; which is something that ocaml, ruby, c/c++ all offer me out of the box
20:59:17 <jcreigh> http://haskell.org/ghc/docs/latest/html/libraries/array/Data-Array.html
20:59:18 <lambdabot> Title: Data.Array, http://tinyurl.com/2uoebz
20:59:44 <jcreigh> there's a couple of different types of arrays, depending on what you need.
21:00:03 <chessguy> just use drop, take, and !! :) (kidding)
21:00:11 * Korollary drops chessguy
21:00:21 * chessguy cries
21:00:29 * Korollary sends flowers
21:00:49 * chessguy gives them to his wife
21:01:03 <Korollary> edwardk: ping
21:01:07 <chrisdone> a fruitbasket is better than flowers
21:03:30 <lispy> hml: Haskell is enough different in design from those other languages that you may find Arrays are actually a bad way to implement it in Haskell, both in terms of efficiency and maintainability
21:04:01 <lispy> hml: On the other hand, if you do need traditional arrays, Haskell has them in a multitude of varieties.
21:06:28 <hml> lispy: i'm  storing a 3d mesh for constructive solid geometry; i need vertices to store refernces to edges; edges to store references to vertices; and faces to store references to both
21:06:40 <O_4> Hmm, so does ++ bind lower than normal function application?  I.e. a ++ map b xs = a ++ (map b xs)
21:06:43 <hml> anormally; i'd use pointers; but short of that, i can just index into an array instead
21:06:53 <Korollary> hml: You can also have references in Haskell
21:07:02 <hml> Korollary: oh, how?
21:07:20 <Korollary> @index IORef
21:07:20 <lambdabot> Data.IORef
21:07:20 <lispy> hml: values are shared as often as possible
21:07:21 <chrisdone> O_4: function application binds tightest more than anything
21:07:26 <Korollary> @index STRef
21:07:27 <lambdabot> Data.STRef, Data.STRef.Lazy, Data.STRef.Strict
21:07:44 <lispy> hml: So you could use the structure to do it, or as Korollary is pointing out, you can use the ST family
21:07:54 <chrisdone> O_4: (yes)
21:08:00 <hml> hmm ; okay; i will take the leap of faith and use haskell
21:08:00 <Korollary> hml: Do you grok monads yet?
21:08:07 <hml> what's a good place online to host haskell open source code?
21:08:10 <hml> will release it under gpl
21:08:18 <O_4> chrisdone: but it's confusing because nested function calls have lower binding than the outer ones, if that makes sense
21:08:18 <hml> Korollary: used it a bit ; b7ut only up to chapter 15 of haskell soe
21:08:23 <jsnx> hml: google code?
21:08:26 <chrisdone> hml: I tend to use github..
21:08:48 <edwardk> Korollary: pong
21:09:10 <chrisdone> O_4: I don't really know what you mean
21:09:28 <Saizan_> hml: you can ask for an account on community.haskell.org
21:09:40 <jganetsk_> hey, let's say i wanted to study the asm code that was generated by haskell
21:09:43 <jganetsk_> by ghc
21:09:55 <Korollary> edwardk: How did the 'formality' interview go?
21:09:58 <O_4> chrisdone: I mean that "a ++ map b xs" works, but "(++) a map b xs" probably doesn't.
21:09:58 <jganetsk_> what flags should i pass, besides -S, to get the easiest to read code
21:10:08 <chrisdone> O_4: I mean, sure, a b c = (((a) b) c)
21:10:25 <O_4> chrisdone: so do all infix operators have that property?
21:10:32 <lispy> jganetsk_: Well, no optimization is probably going to be easiest... so adding -O0 might help
21:10:33 <chrisdone> O_4: right. because (++) a map b xs is really: ((((++) a) map) xs)
21:10:42 <edwardk> Korollary: things went well, don't know if I can convince them to make it worth my while to leave defense though.
21:10:42 <O_4> chrisdone: yeah
21:10:51 <chrisdone> O_4: I think it's more of a result of the way function application is done
21:11:05 <Korollary> edwardk: you defensiev mofo. Good luck.
21:11:12 <codacola> hml: tell me how it goes when youve gotten some code written, id be quite interested to see it
21:11:33 <chrisdone> O_4: oh, well I think all bind more losely than function applicatiom
21:11:45 <O_4> chrisdone: ok
21:11:52 <jganetsk_> lispy: thanks
21:13:08 <O_4> chrisdone: it seems a little odd to have different semantics based on whether it's infix or not, but presumably that's a result of my lack of understanding.
21:13:11 <chrisdone> heh, that was weird for a moment. I had “package ghc-6.8.3 is broken due to missing package bytestring-0.9.0.1.1”, because I had ran cabal upgrade which installed bytestring-0.9.0.1.0 and seemingly removed bytestring-0.9.0.1.1 :)
21:14:41 <Saizan_> O_4: it's just that when you wrap an operator in parentheses it's treated like a normal function
21:15:09 <chrisdone> saizan: ah, I wasn't sure if O_4 knew that or not
21:15:21 <O_4> Saizan_: yeah, what I mean is it's odd that operators behave differently from functions in the first place.
21:15:42 <O_4> I would have expected their application to behave equivalently to normal function application.
21:15:50 <Saizan_> well if they didn't a lot of the utility of having operators would be lost
21:16:32 <chrisdone> gwern: yaaaaaay mueval builds ^_^. ghc 6.8.3, too! :)
21:16:32 <O_4> Well, you'd have to wrap some of the arguments in parentheses...  But you do for normal function application anyway, which nobody seems to mind.
21:17:27 <chrisdone> O_4: perhaps you could provide some examples of annoyingly parenthesised code. are you aware of ($), btw?
21:18:09 <Saizan_> well, if operators and functions should behave in the same way then a ++ b == "'a' applied to ++ and 'b'"
21:19:30 <O_4> chrisdone: I don't find it particularly annoying.  But I meant that I'd expect to have to type "l ++ (map b xs)", the same as if I'd done "(++) l (map b xs)"
21:20:21 <chrisdone> O_4: oh, okay
21:20:47 <chrisdone> how do I add "/home/chris/.cabal/bin" to my PATH in bash, so that it's persistent between sessions?
21:21:21 <jsnx> chrisdone: you put it in your BASHRC
21:21:23 <Zao> chrisdone: .bashrc, generally.
21:21:37 <chrisdone> hm, ok. thanks
21:21:37 <jsnx> export PATH=
21:21:40 <O_4> PATH=/hame/chris/.cabal/bin/:$PATH or something?
21:21:47 <Saizan_> it's just a matter of precedences, prefix application has the highest precedence, for operator you can define it in code with an infix statement
21:21:47 <jsnx> export PATH="<blah>:$PATH"
21:23:04 <chrisdone> that was right, thanks chaos
21:23:06 <chrisdone> er, chaps
21:23:16 <chrisdone> heh. "thanks, chaos theory!"
21:24:01 <Korollary> I knew it was useful for something.
21:24:25 <codacola> these exercises are annoying. define a function which returns the smallest root from  ax^2 + bx + c
21:24:35 <codacola> gotta do 25 of them
21:27:41 <carl> is there a way to export another module so that if one module is loaded the exported module is also loaded automatically
21:28:13 <chrisdone> yeah, I think it's called "re-exporting", I think you add the module name to the module exports. I am not sure of the syntax
21:28:17 <carl> im exporting a class which relies on bytestrings for examlpe
21:28:33 <codacola> wouldnt you just import A into B, then when B is imported A is imported too?
21:28:44 <chrisdone> http://www.haskell.org/onlinereport/modules.html#sect5.2
21:28:46 <lambdabot> Title: The Haskell 98 Report: Modules
21:29:15 <carl> thx
21:29:16 <chrisdone> carl: oh, well if your module which uses the class doesn't use the type in the code, you don't need to re-export it
21:29:54 <carl> well im exporting a class which is bascially my version of binary and inorder to use the put and get methods i need to also export binary
21:30:14 <codacola> what a semester. haskell, prolog and c# in 5 months
21:30:29 <chrisdone> carl: ah, then I guess that makes sense to re-export
21:30:55 <carl> yea thats what i was hoping to do
21:31:00 <chrisdone> codacola: sounds like a good course. where's this at?
21:32:17 <codacola> massey, new zealand. haskell and prolog in "declaritive programming" and also taking "computer science fundementals" which uses c#
21:32:39 <chrisdone> new zealand++
21:33:24 <Smokey`_> nice... I did 1 year at ANU (Australian National University) - I did Python, Haskell, and Java (+database crap + math) - I was relatively unimpressed though
21:33:53 <codacola> the amussing bit is haskell introduced me to recursion, but the haskell class is a 2nd year class, and recursion is used in the fundementals class (first year). seems kinda backwards
21:34:09 <Korollary> yes, you should have paid more attention.
21:34:23 <codacola> im hoping ill get to use python in a future class
21:34:39 <chrisdone> well, recursion is pretty simple and fundamental imho
21:34:45 <rumbleca> don't they just say use whatever you want?
21:34:59 <codacola> rumbleca: 3rd year it seems we use whatever we want
21:35:24 <codacola> she told us the other day she doesnt specify a language for her 3rd year students
21:37:27 <zachk> that would be nice
21:37:50 <rumbleca> we had different types of classes, but rarely was the language a focus
21:38:00 <chrisdone> codacola: by “recursion is used”, does that mean writing out explicit recursion? (because any kind of looping in haskell uses recursion, so it's fairly obvious to say “using recursion” in that sense)
21:38:14 <rumbleca> if it was, it was usually an investigation about how the language accmplished specific things
21:38:16 <chrisdone> hi, zenon
21:38:25 <_zenon_> hi
21:38:41 <rumbleca> because the language is replacable, in the end
21:38:42 <_zenon_> I must say, good morning
21:38:54 <_zenon_> chrisdone,
21:39:12 <codacola> chrisdone: well even the most basic of things with lists requires recursion, which makes it a good introduction for recursion. in the other class we have to use it for stuff like merge sort
21:39:15 <chrisdone> rumbleca: are you saying all languages are equal?
21:40:08 <rumbleca> chrisdone: are you saying they are not? :)
21:40:13 <chrisdone> rumbleca: yes
21:40:16 <rumbleca> that's a trick question
21:40:32 <_zenon_> I would say all touring complete languages are equal
21:40:39 <_zenon_> Not more than that
21:40:41 <chrisdone> please leave turing out of it
21:40:54 <rumbleca> chrisdone: I said all languages are replacable in the end
21:41:14 <chrisdone> rumbleca: right, replacable as in can be substituted with any other language?
21:41:39 <codacola> hm, should be interesting to see how many of the 3rd year classes allow us to use any language. theres moer "3rd year" class than the rest combined (in reality 3rd year doesnt mean 3rd year, means youve gotta take first and 2nd year classes first)
21:42:32 <dolio> Language choice got more free the higher up you got at my university.
21:42:33 <rumbleca> chrisdone: as in, understand the logic behind the design of a language
21:43:03 <_zenon_> I don't follow. How would a non turing complete language substitute a turing complete one?
21:43:21 <dolio> Although some higher-up courses did mandate things, when they were reading the code instead of looking at the results, I guess.
21:43:37 <Cale> _zenon_: if you're writing a program which doesn't require turing completeness...
21:44:26 <codacola> rumbleca: of course the problem with first year students is that many havent done any programming. so you have to introduce it with some programming, so you need to pick 1 language :P
21:44:32 <chrisdone> hey gwern: I think a good word to describe a thread that launches another and kills it after a period of time can be "custodian"
21:44:37 <_zenon_> Cale, I would say "all languages are equal" in some way must imply any program written in Language L must be able to be written in another Language L*
21:45:01 <_zenon_> Thus, I beli
21:45:32 <_zenon_> believe the discussion must be narrowed to some domain of languages
21:45:57 <chrisdone> gwern: but "watchdog" is cool too :P
21:46:48 <codacola> next semester ill be using assembly :D
21:48:46 <rumbleca> _zenon_: equality is stronger than that
21:48:49 <rumbleca> I think
21:50:26 <rumbleca> codacola: my first year, the language of instruction was more or less c++, however if you could do the assignments in another language, it was accepted to a point
21:51:18 <rumbleca> for the assembly course, it had to run on university computers so your choices were somewhat limited, however there were 2 or 3 options
21:51:54 <rumbleca> sparc, intel, and I think mips
21:51:54 <jsnx> s/them/then/
21:51:58 <jsnx> ack
21:52:22 <newsham> i think classes should mandate the language.
21:52:37 <jsnx> newsham: why?
21:53:22 <newsham> because usually in life your choices are mandated.  if you're studying to prepare yourself for work, you should be forced to comply with a particular environment.
21:53:42 <chrisdone> haskell identifiers are: [a-z][a-zA-Z0-9_]*, right?
21:53:51 <chrisdone> function names, that is
21:53:56 <rumbleca> newsham: I don't agree with that completely
21:53:59 <jsnx> newsham: well, exploration and experimentation are also important in education
21:54:20 <newsham> > let (+) = 5 in show (+)
21:54:26 <lambdabot>  "5"
21:54:28 <jsnx> newsham: i guess if the school made it sufficiently varied, though, it could work
21:54:32 <rumbleca> oh yeah, there was a pdp emulator as well
21:54:41 <newsham> pdp11?
21:54:43 <rumbleca> yes
21:54:47 <newsham> fun stuff
21:55:11 <Cale> _zenon_: Well, I wasn't really paying attention to the whole conversation...
21:55:12 <codacola> still cant believe i spent 2 hours debugging soemthing so simple
21:55:18 <newsham> jsnx: they are, and they should be encouraged to a degree.  but most classes should force you ot learn something specific and comply with it
21:55:29 <Cale> _zenon_: another definition of equality of languages might be that they contain exactly the same programs.
21:56:14 <Cale> (that is, two languages are equal if and only if any program written for one language is a program for the other and the programs have the same meaning in both languages)
21:56:17 <jsnx> newsham: well, i could live with that
21:56:25 * codacola just does whats required of him, and tries to get top marks
21:56:29 <rumbleca> I liked sparc, but the pdp was fun... all uppercase and old. but iirc, the language was somewhat logical, unlike i386 asm
21:56:39 <codacola> seems to work better than grumbling over lamguage  selection :P
21:56:41 <_zenon_> Cale, not me either :) I just got winded up on the statement of "all languages are equal", using your definition, the statement is still false I believe.
21:56:54 <Cale> Oh, it's very false :)
21:56:57 <_zenon_> Cale, I would say; Two programs are equal if given the same input, they produce the same output.
21:57:01 <newsham> yah, some consider vax assembly to be the pinacle of cisc
21:57:12 <newsham> which is very much like pdp11 assembler (but 32 bits)
21:57:14 <_zenon_> Cale, Then we agree.
21:57:24 <Cale> _zenon_: even if they accomplish that in a different way?
21:57:29 <rumbleca> Cale: is that based on inputs and outputs?
21:57:44 <newsham> rumbleca: have you played with any old systems on the emulator?  like 6th ed unix?
21:57:46 <jsnx> newsham: that way, your instructor could teach you to use the language well
21:57:49 <codacola> hm. my assignment wants me to complete a specified 25 exercises from the book. would a good layout be to have the "main" functions listed, and any that i need in the background listed down the bottom? (for the sake of clarity)
21:58:03 <Cale> I was suggesting that languages are equal if and only if they contain the same strings, and the strings have the same meanings :)
21:58:08 <_zenon_> Cale, then we must define "same way", when it gets down to it, it's all computations with the ALU ?
21:58:10 <rumbleca> newsham: no, I didn't. did you?
21:58:14 <rumbleca> that would be fun
21:58:33 <newsham> rumbleca: yah, its a hobby of mine.  you can find old unix versions that run on simh on the interwebs
21:58:38 <codacola> all languages are inferior to python. there, proven that they are not all equal
21:58:57 <newsham> http://homepages.fh-giessen.de/~hg53/pdp11-unix/ for example
21:59:00 <bitrot> therefore, python is inferior to itself?
21:59:03 <lambdabot> Title: UNIX 7th Edition on PDP-11 Simulator
21:59:42 <newsham> or even older:  http://code.google.com/p/unix-jun72/
21:59:43 <rumbleca> newsham: cool thanks!
21:59:44 <lambdabot> Title: unix-jun72 - Google Code
22:00:01 <_zenon_> I don't know. I regard it as: For all input, if P1 and P2 produce the same output, they are equal.
22:00:14 * _zenon_ should get back to work
22:00:16 <codacola> bitrot: stop with the logic :|
22:00:43 <rumbleca> you can't come into a channel about a functional programming language, and start making sweeping claims
22:01:08 <rumbleca> without serious consequences to your logic processor
22:01:09 <bitrot> rumbleca: some old BSD releases: ftp://ifctfvax.harhan.org/pub/UNIX/
22:01:09 <jsnx> unless that funcional programming language is ruby ;)
22:01:52 <newsham> bitrot: the TUHS archive is a bit larger.
22:02:15 <codacola> ok, given teh set A = [x | x = a language other than python] and a set B where B = [ x | x = python] then all languages in A are inferior to the languages in B
22:02:23 <newsham> http://mirror.cc.vt.edu/pub/projects/Ancient_Unix/
22:02:24 <lambdabot> Title: Index of /pub/projects/Ancient_Unix
22:02:45 <Cale> _zenon_: perhaps "equivalent" would be a better term for that :)
22:02:52 <_zenon_> Cale, yes,
22:03:03 <rumbleca> cool
22:03:27 <rumbleca> that's funny, I just downloaded rogomatic today, what a retro day
22:04:01 <bitrot> newsham: ah, yes.
22:04:11 <jsnx> codacola: okay, so you have finally stated it
22:04:17 <jsnx> codacola: can you demonstrate it?
22:05:01 <rumbleca> codacola: not true, and you can check norvig's page on python about that
22:05:09 <jsnx> conider `sed` -- is it not superior to python?
22:05:20 <sjanssen> we're attempting to prove that Python is superior to all other programming languages in #haskell?
22:05:23 <newsham> dont you mean:  [x for x in languages where x != python]   ?
22:05:32 <_zenon_> Is your muscle mass invertedly proportional to your academic degree ?
22:05:47 <sjanssen> [x | x <- languages, x /= python] -- use Haskell, damnit!
22:06:00 <newsham> filter (/= python) languages
22:07:08 <newsham> all (< python) $ filter (/= python) languages
22:07:26 <jsnx> sjanssen: if we succeed, will we not have saved ourselves a lot of trouble?
22:07:44 <sjanssen> jsnx: I suppose
22:07:49 * sjanssen would like to see the proof
22:07:54 <jsnx> so would i
22:07:54 <newsham> add an instance declaration for (Ord Langauge)
22:08:18 <newsham> sjanssen: i think the proof is in agda.
22:08:34 <_zenon_> This is such a weird discussion
22:08:35 <chrisdone> setInstalledModsAreInScopeQualified -- long function names are sweet
22:08:50 <_zenon_> chrisdone, this is not java!
22:08:57 <_zenon_> ;)
22:08:59 <chrisdone> addOneNumberToAnotherNumber
22:09:04 * luqui prefers "f"
22:09:08 <rumbleca> heh
22:09:31 <_zenon_> thisIsOneFunctionInJavaWhichDoesSomething
22:09:36 <chrisdone> setUseLanguageExtensions, setInstalledModsAreInScopeQualified, etc.
22:09:43 <_zenon_> geesh
22:09:43 <luqui> another good one:  processDataWithOperation()
22:09:46 <jsnx> so, consider that python is named after snakes -- and snakes are more fearsome than mathematicians, or coffee, or alphabet letters, or the moon, or even jewels -- and it is clear that the most fearsome thing is better, so python is better
22:10:05 <chrisdone> needs more “set UseLanguageExtensions True; set InstalledModsAreInScopeQualified True”
22:10:18 <newsham> setHasSideEffectsSoDontUseIttooMuch
22:10:32 <chrisdone> snakes are not the hardest metal
22:10:33 <dolio> Does that mean that Tiger is better than Python?
22:10:35 <_zenon_> jsnx, Python is named after snakes, which can't run, therefore any program in Python won't run on the computer. Useless.
22:10:40 <rumbleca> jsnx: don't pythons eat large mammals and then digest them over periods of months?
22:10:50 <bitrot> jsnx: but St. Padraick drove the snakes from Ireland...
22:10:51 <sjanssen> _zenon_++
22:11:12 <newsham> please submit your proofs to codepad
22:11:12 <rumbleca> they swallow them whole and alive
22:11:18 <jsnx> okay, let me try another, if that proof does not suit your tastes
22:11:53 <chrisdone> gwern ^_^
22:12:04 <newsham> http://codepad.org/yU6eTyB6
22:12:07 <sjanssen> oh no, gwern is here! Run away!
22:12:42 <chrisdone> a wild Gwern appeard!
22:12:57 * chrisdone uses harden
22:13:21 <jsnx> chrisdone: what metal is a programming language?
22:13:27 <jsnx> harden?
22:13:46 <newsham> heavy metal
22:13:47 <_zenon_> haskell is unuptainium
22:13:52 <jsnx> newsham: that proof would be complete with a nice yin-yang in it
22:14:11 <newsham> jsnx: know of a good (Float -> Float -> Int) function for yinyang?
22:14:19 <sjanssen> @remember _zenon_ Python is named after snakes, which can't run, therefore any program in Python won't run on the computer. Useless.
22:14:19 <lambdabot> Okay.
22:14:31 <_zenon_> :)
22:14:34 <sjanssen> byorgey: ^^^ HWN material?
22:14:52 <_zenon_> hehe, must be the one metal
22:14:55 <jsnx> sjanssen: well, this is where we have access to the ancient technique of equivocation
22:15:06 <jsnx> python is named after monty python...
22:15:12 <codacola> it is?
22:15:17 <codacola> i always thought after the snake
22:15:19 <jsnx> indeed
22:15:20 <codacola> given thats its logo
22:15:31 <jsnx> but that is not the truth
22:15:35 * bitrot queues the spam song...
22:15:53 <jsnx> else, why is the package site called the "cheeseshop" ?
22:16:11 <codacola> http://www.python.org/images/python-logo.gif
22:16:14 <codacola> oops
22:16:29 <codacola> http://www.python.org/images/python-logo.gif
22:16:32 <codacola> what the hell
22:16:32 <newsham> if perl was nailed to the perch it'd be pushing up the daisies?
22:16:36 <jsnx> codacola: oh, no, you killed lambdabot!
22:16:36 <newsham> wasnt
22:17:01 <codacola> tghis stupid thing keeps showing the picture instead of the link, dunno what you lot are seeing
22:17:22 <jsnx> codacola: we can not see the picture over here
22:17:23 <sjanssen> lambdabot: @botsnack
22:17:24 <lambdabot> :)
22:17:25 <newsham> [19:15] < codacola> http://www.python.org/images/python-logo.gif
22:17:26 <jsnx> just the link
22:17:30 <codacola> ah
22:17:35 <codacola> well there you go, 2 snakes :P
22:17:42 <chrisdone> @botsmack
22:17:42 <lambdabot> :)
22:17:55 <jsnx> that is only a pun
22:18:00 <bitrot> codacola: http://docs.python.org/tut/node3.html -- see "By the way..."
22:18:01 <lambdabot> Title: 1. Whetting Your Appetite
22:18:02 <jsnx> really, there's a PEP or something
22:18:28 <chrisdone> @src (&&&)
22:18:28 <lambdabot> f &&& g = arr (\b -> (b,b)) >>> f *** g
22:18:41 <codacola> hm, well there we go
22:18:42 <chrisdone> @src (***)
22:18:42 <lambdabot> f *** g = first f >>> second g
22:18:44 <codacola> its inferior to everything
22:18:52 <codacola> i liked it when it was named after snakes
22:19:04 <newsham> > (\x -> let y = map toUpper (filter isAlpha x) in (y, reverse y)) "dogma? I am god!"
22:19:20 <lambdabot>  thread killed
22:20:34 <jsnx> codacola: indeed
22:20:46 <jsnx> so i guess it is not the best langauge anymore?
22:21:01 <jsnx> i think the best language will have dependent types
22:21:03 <chrisdone> > let x = "illuminati" in (x,reverse x)
22:21:11 <lambdabot>  ("illuminati","itanimulli")
22:21:12 <sjanssen> personally, I don't see how a language named after snakes could be good.  Snakes are vile!
22:21:30 <newsham> > reverse "itanium"
22:21:30 <lambdabot>  "muinati"
22:21:44 <sjanssen> > reverse "esrever"
22:21:45 <lambdabot>  "reverse"
22:21:46 <jsnx> but my kids will think the best languages needs to have some arcane math in it, that was invented a few days ago but i will never hear of it
22:22:12 <newsham> ?check \s -> (reverse.reverse) s == id s
22:22:25 * luqui thinks the best language won't be a language...
22:22:25 <lambdabot>  OK, passed 500 tests.
22:22:25 <chrisdone> failed 97 tests
22:22:27 <jsnx> and i'll be like "pshah, what math is that? why in my day, we had type inference and we were *glad* to have it"
22:23:00 <chrisdone> luqui: sounds like a banal statement
22:23:01 <newsham> we had type inference, and we still declared all of our types!
22:23:22 <luqui> it's pretty much meaningless
22:23:35 <jsnx> we used to compile up hill, both ways, in the snow on computers with like two cores!
22:23:49 <newsham> sometimes we dumped a core and kept going
22:23:56 <jsnx> hehe
22:24:07 <codacola> curious, can anyone here recommend a book on graph theory?
22:24:12 <newsham> we computed when it was unsafe to perform io
22:24:20 <bitrot> and we liked it?
22:24:35 <newsham> you kids and your monads have it so easy
22:24:39 <chrisdone> newsham: chars=' abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXY') :
22:24:41 <jsnx> bitrot: "...it was good enough for your father!"
22:24:50 <chrisdone> newsham: doesn't python have ['a..'z'] syntax?
22:25:00 <jsnx> chrisdone: no
22:25:02 <sjanssen> chrisdone: hahaha, pwned!
22:25:05 <jsnx> it has the range function
22:25:16 <jsnx> sjanssen: lolz
22:25:25 <newsham> chrisdone: there's range() for integers, you can do  ''.join(chr(x) for x in range(65,98))
22:25:32 <jsnx> let's start #haskiddies
22:25:33 <sjanssen> ' ' : ['a' .. 'z] ++ ['A' .. 'Z']
22:26:15 <sjanssen> Python doesn't have Enum?!  Surely only idiots use it!
22:26:20 <newsham> also you can import string and use string.letters
22:26:43 <newsham> this is true, there is no Enum.
22:26:51 <newsham> you'd have to write your own
22:26:59 <luqui> Python doesn't have Functor?!
22:27:02 <chrisdone> I often wonder why python code always seems to stretch across my screen horizontally
22:27:07 <jsnx> sjanssen: or the employees of fearful people
22:27:08 <chrisdone> I'm not used to horizontal scrolling
22:27:10 <sjanssen> really, if typing the alphabet is the easiest way in your language -- complete fail
22:27:23 <newsham> chris: most python does not scroll across the screen horizontally
22:27:27 <jsnx> sjanssen: our bosses take solace in the fearsome snake
22:27:33 * Nafai wonders if he is in #python
22:27:35 <newsham> its very unidiomatic to have horizontal scroll in python code
22:27:41 <chrisdone> Python isn't Haskell‽
22:27:43 <jsnx> they want that snake on their side
22:27:55 <luqui> chrisdone, is that an interrobang character?
22:28:05 <jsnx> newsham: yeah, vertical scroll is more idiomatic
22:28:13 <chrisdone> luqui: that's right!
22:28:19 <sjanssen> chrisdone: is that an interrobang character‽
22:28:20 * chrisdone beams
22:28:21 <newsham> this is true.  languages w/ c-like syntax love vertical scroll
22:28:44 <newsham> you should see the windows DDK samples.
22:29:01 <hml> in developing languages like C, it's really usefu lfor me to look through *.h files of standard libraries, especially when i don't have them  memorized; how can i do the equiv in haskell?
22:29:14 <hackage> Uploaded to hackage: list-extras 0.1.1
22:29:21 <chrisdone> hml: look at the documentation of the standard libraries
22:29:24 <newsham> hml: go to the haskell ghc docs, and click on a package, and read the docs, or click on the source link
22:29:25 <sjanssen> hml: usually you'd look at the haddocks
22:29:25 <jsnx> hml: well, if you do not have sources, you are in trouble
22:29:35 <newsham> http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
22:29:36 <lambdabot> Title: Haskell Hierarchical Libraries
22:29:36 <hml> hmm; i prefer something that i can open up and view in vim
22:29:39 <hml> and can grep throlugh
22:29:46 <jsnx> hml: then read the sources?
22:29:54 <newsham> for example:  http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Either.html and http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Data-Either.html
22:29:55 <lambdabot> Title: Data.Either, http://tinyurl.com/wtlo6
22:29:55 <sjanssen> hml: or perhaps you'd use ghci's :type?
22:30:11 <sjanssen> also :info
22:30:22 <newsham> also lambdabot ?type and ?src
22:30:25 <jsnx> GHCi provides inspection tools like :browse <module> and :info <thingy>
22:30:40 <chrisdone> and there's always hoogle
22:30:52 <jsnx> anyways, i want you all to think about how successful windows has been
22:31:02 <jsnx> and why: comes from MicorSnake
22:31:12 <jsnx> without the snake, who would buy it?
22:31:24 <newsham> hml: you can download the sources, or download the documentation html and read them locally
22:31:48 <chrisdone> ☞ <- goto
22:32:01 <jsnx> chrisdone: what?
22:32:26 <newsham> http://en.wikipedia.org/wiki/%E2%98%9E
22:33:39 <chrisdone> “considered harmful”
22:33:58 <newsham> leads to speghetti
22:34:39 <jsnx> ah, okay, i can see it now
22:35:09 <chrisdone> the irony mark http://en.wikipedia.org/wiki/Irony_mark and interrobang should be adopted on internet speak
22:35:09 <lambdabot> Title: Irony mark - Wikipedia, the free encyclopedia
22:35:27 <chrisdone> the only way to make this happen is for xkcd to make a joke about it, and all the geeks will start using it to be cool
22:36:01 <jsnx> well, it would also help if someone had a smart way to type it
22:36:28 <jsnx> so, i think we are done with the python thing
22:36:31 <chrisdone> I just type Alt+? for interrobang, and Alt+Shift+? for irony mark
22:36:34 <jsnx> thank goodness
22:36:42 <chrisdone> xmodmap++
22:37:26 <_zenon_> ¿
22:37:28 <jsnx> ¿
22:37:33 <jsnx> ÷
22:38:20 <bitrot> que?
22:38:24 <chrisdone> that's upside down, not referse
22:38:28 <chrisdone> bitrot: hehe
22:44:34 <chrisdone> ؟‽
22:45:55 <jsnx> chrisdone: wow, that messed up my layout
22:46:01 <jsnx> \h\h\h\h\h\h
22:46:07 <jsnx> muhuhaha
22:49:18 <_zenon_> When does HWN come out?
22:51:21 <Pseudonym> Weekly.
22:51:36 <_zenon_> day of week ?
22:55:10 <bitrot> last one was 16 july, wed.
22:55:14 <Cale> _zenon_: I'm not sure there's any regularity to it at all. A while back it was more like monthly... it's been more regular lately.
22:55:54 <_zenon_> Cale, oh, ok.
23:02:53 <codacola> whats hwn?
23:03:14 <Cale> Haskell Weekly News
23:03:19 <codacola> ah
23:04:04 <codacola> wow, soem books on graph theory are bloody expensive
23:04:19 <Cale> Heh... which one in particular are you looking at?
23:04:58 <codacola> none, just looking at a bookstores results for "graph theory"
23:05:09 <codacola> just after a general introduction to the topic
23:05:53 <codacola> Graph Theory for Programmers: Algorithms for Processing Trees  <- $450 usd!
23:06:06 <Cale> http://www.math.uni-hamburg.de/home/diestel/books/graph.theory/
23:06:07 <lambdabot> Title: Graph Theory
23:07:36 <Cale> That one's pretty good, and it's free too :)
23:07:43 <codacola> ah, thanks
23:10:38 <codacola> my algorithms book has a small introduction, which just made me curious :P
23:14:59 <dons> wednesday, fwiw, _zenon_
23:15:39 <_zenon_> dons, k.
23:24:34 <lQg> i made hello world rpoku compiler!!! in haskell
23:24:52 <codacola> rpoku?
23:25:08 <lQg> human speakable programming language
23:25:26 <codacola> well now im confused
23:25:33 <lQg> compiler currently translates some rpoku code into assembly
23:26:03 <dons> oh right. can you show us the code?
23:26:16 <lQg> lojban got me pregnant .u i have been in labour for a while and gave birth to rpoku
23:26:23 <lQg> yep
23:26:34 <lQg> one sec
23:28:14 <erikc> is there anything inherent to cabal's design that prevents it from building in parallel, or does the work just need to get done?
23:28:55 <codacola> i think a 2 gig usb key was a tad overkill for my haskell work
23:29:00 <dons> erikc: work just needs to be done, dcoutts is almost there i think.
23:29:09 <lQg> okay http://tcana.info/rpoku/Tokenizer.hs and http://tcana.info/rpoku/BongCompiler.hs
23:29:25 <dons> cool!
23:29:35 <lament> just the name "rpoku" is already not very speakable
23:29:46 <dons> that's pretty crazy :)
23:30:05 <lQg> compiles http://tcana.info/rpoku/jxq-ki.bg.kb
23:30:18 <lQg> yep :)
23:30:20 <lQg> thanks
23:30:24 <dons> you should upload it to hackage.haskell.org ! :)
23:31:13 <lQg> :) probably will maybe when i get the full assembly language into the compiler .u i hear its only 80 basic commands
23:31:15 <lament> How do you pronounce "vigkq-bqka"?
23:31:30 <dons> hehe
23:31:32 <lQg> fikra-bara
23:31:36 <dons> oh!
23:31:43 <dons> now its clear
23:31:45 <lament> errrrr
23:31:53 <lQg> yea here is pronounciation key
23:32:06 <dons> i c.
23:32:13 <lament> why won't just spell it fikra-bara? not much added value in extra obfuscation
23:32:22 <dons> lament: http://lokadin.987mb.com/rpoku.html
23:32:23 <lambdabot> Title: Rpoku Language home-page
23:32:46 <dons> lament: its like phonetic.
23:32:49 <lQg> dons: yep :)
23:33:21 <lQg> yep its also the modded down version of lBQ-G! which has 94 phonemes and counting
23:33:41 <lQg> rpoku bong or ponk has only 14 phonemes
23:33:50 <lament> oh, i see
23:33:54 <codacola> is c# becoming one of the most popular languages for commerical development nowadays?
23:34:19 <O_4> It's definitely becoming more popular.
23:34:35 <dons> what's becoming less popular?
23:34:51 <O_4> C++?
23:34:52 <lQg> well eventually toddlers should be able to speak rpoku ponk
23:35:04 <dons> Perl?
23:35:08 <lQg> maybe in a generation or two
23:35:12 <O_4> I don't really know, but I'd sure like to see C++ fade away :-p
23:35:19 <dons> Lisp?
23:35:19 <O_4> (it seems to be at my uni)
23:35:37 <dolio> Yes. Carving out of that big lisp chunk.
23:35:41 <lQg> Java is really popular in canadian banks
23:36:01 <O_4> I don't really think C# and lisp are in direct competition...  They're mostly different groups of programmers :-
23:36:03 <O_4> :-p
23:36:06 <lament> i really like this idea
23:36:18 <dons> dolio: how big was lisp during the 80s AI/4th Gen boom?
23:36:30 <dons> did i ever reach 10% of the market?
23:36:34 <dons> s/it/
23:36:47 <dolio> I don't know. I'm not much of a history buff.
23:37:10 <erikc> c++ dominates game development
23:37:14 <lQg> my dad works as programmer for various charter banks and finance related software mainly java coupled with web development
23:37:17 <luqui> sigh... rpoku is imperative...
23:37:35 <lQg> well it will be functional .. eventually
23:37:57 <lQg> it just has to do with using different words it all
23:38:01 <dons> luqui: seems like the syntax could be retargetted...
23:38:07 <luqui> yeah true
23:38:14 <O_4> erikc: that's not entirely surprising though, there haven't been all that many decent alternatives until quite recently.
23:38:24 <dons> lambda lambda (lambda lambda ) lambda
23:38:39 <erikc> which alternatives?
23:38:55 <luqui> eg. c#
23:39:04 <erikc> ah yea
23:39:12 <lQg> dons: yea lambda would probably be ka-mda
23:39:15 <erikc> i think sony should be taking that threat seriously
23:39:24 <lQg> or kq-mdq
23:39:27 <O_4> Well D is in many ways a better C++, and computers are powerful enough now that languages like C# are a possibility too
23:39:29 <erikc> they still require all apps to be compiled with a specific version of gcc
23:39:42 <dons> http://www.reddit.com/comments/6t1i1/Rpoku_a_spoken_word_programming_language/ :)
23:39:43 <lambdabot> Title: Rpoku: a spoken word programming language ... : reddit.com, http://tinyurl.com/5s85df
23:39:52 <erikc> which is a bit of a bummer if you want to explore alternatives heh
23:39:57 <dons> oh, note the url tweaking on reddit. interesting.
23:40:03 * luqui sees D as having all the problems of C++ and giving them more power
23:40:09 <dons> hah
23:40:19 <dons> ?remember luqui sees D as having all the problems of C++ and giving them more power
23:40:19 <lambdabot> Done.
23:40:30 <O_4> luqui: yeah, but you only use C++ when you have to anyway
23:41:05 <O_4> I don't know why anyone would choose to use C++ unless they wanted boost or something.
23:41:12 <O_4> (or D, for that matter)
23:41:14 <lQg> dons: nice :) thanks
23:41:14 <lament> D seems a bit of a toy.
23:41:24 <O_4> lament: how so?
23:41:27 <lQg> its like a baby shower
23:41:49 <lament> (and C++ is still ridiculously useful for a lot of stuff despite being so utterly horrible) :)
23:41:52 <lQg> where i gave birth to language rpoku and get programming related presents
23:42:25 <dons> :)
23:42:26 <lQg> lol
23:42:26 <lament> O_4: does it have libraries that can can compete with Java, C++, C#?
23:42:59 <lQg> lament: well eventually rpoku will
23:43:01 <Trinithis> Assembly is more fun to code in than C
23:43:19 <lQg> agreed
23:43:31 <O_4> lament: the standard stdlib is a bit sparse, but there is a pretty decent alternative.
23:43:32 <luqui> machine code is more fun than assembly.  I prefer not to name anything ever.
23:43:40 <Trinithis> ;/
23:43:41 <O_4> lament: but no, it's not gonna take out C++ any time soon
23:43:52 <lament> right...
23:43:55 <luqui> (s/machine code/SK calculus/ si vous plait)
23:44:09 <erikc> D is ok, but the major benefits vs c++ are the garbage collection, and if im gonna pay the gc price, i might as well go haskell or c#
23:44:13 <Trinithis> luqui: are you serious about using machine code for fun?
23:44:27 <hml> is there any good haskell lib for directly constructing linux x86_64 binaries?
23:44:29 <O_4> lament: that doesn't make it a toy though IMO, it's still useful, and it's also much younger than C++
23:44:45 <luqui> Trinithis, haha no.  I am a firmly high-level person.  even assembly frightens me deeply.
23:44:52 <dons> hml: constructing them programmatically? an ELF header binding with asm generator?
23:45:01 <Pseudonym> Actually, binary compatibility with C++ is a big selling point.
23:45:06 <O_4> (younger being one of the reasons there aren't as many libs for it compared to C++)
23:45:09 <Pseudonym> D is binary compatible with C++, right?
23:45:09 <dons> hml: and not ghc itself... /
23:45:12 <erikc> its not
23:45:13 <Trinithis> Guess I'll have to dress up as a register for halloween for you
23:45:15 <Pseudonym> Oh.
23:45:18 <hml> dons: yep, not ghc itself
23:45:19 <Pseudonym> I thought it was for some reason.
23:45:20 <erikc> and that would be a huge selling point, absolutely
23:45:25 <lament> O_4: but if libraries are not a big concern... why not just use Haskell? :)
23:45:30 <olsner> Pseudonym: apparently, the next release will have that :D
23:45:33 <luqui> lol
23:45:34 <erikc> for games, all the high quality physics libraries are c++ only
23:45:35 <hml> dons: I write to write an assembler in  haskell
23:45:39 <lQg> yea i am going to start a freelancing programming company
23:45:41 <dons> ah, yes. harpy.
23:45:42 <erikc> and are big enough that wrapping it would be a major pain in the ass
23:45:47 <dons> see on hackage.haskell.org, hml
23:45:53 <O_4> lament: you don't need to convince me, I never use either of them by choice :-p
23:45:53 <dons> there's also a great llvm binding
23:45:59 <dons> so you can jit your code directly.
23:46:10 <lament> lQg: good luck, it's a tough business
23:46:20 <Pseudonym> olsner: That'd be great, then.
23:46:32 <O_4> lament: though Haskell seems to have a very nice collection of libs on hackage anyway.
23:46:36 <Pseudonym> The ability to reuse C++ (though some of the best C++ isn't binary-reusable) would be great in D.
23:46:42 <hml> dons: is there anything like llvm implemented in haskell? i.e. a vm w/ jit support?
23:46:52 <dons> yes, harpy
23:46:59 <olsner> "The D parser understands an extern (C++) calling convention for linking to C++ objects, but it is only implemented in the currently experimental D 2.0.", according to wikipedia
23:47:01 <dons> but not a vm.
23:47:11 <lQg> lament: really? how so? i mean can get bigger contracts once have stable development people
23:47:14 <lament> O_4: for some specific niches, definitely, and occasionally it might be great (parsing)
23:47:18 <erikc> olsner: ah, thats new, hadnt seen that
23:47:22 <dons> hml: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/harpy
23:47:24 <lambdabot> Title: HackageDB: harpy-0.4
23:47:30 <dons> hml: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/llvm
23:47:31 <hml> dons: yep, looking at the tutoriasl; thansk
23:47:36 <Trinithis> how are python and ruby? are they cool?
23:47:36 <erikc> i dont envy walter doing binary compat to c++ with d
23:47:37 <lambdabot> Title: HackageDB: llvm-0.0.2
23:47:42 <hml>  dons (for harpy, not so much llvm)
23:47:43 <erikc> what a hassle
23:47:49 <O_4> erikc: heh, neither :-p
23:47:57 <dons> Trinithis: they're not cool, no.
23:48:01 <dons> quite daggy.
23:48:06 <Trinithis> mm
23:48:22 <O_4> Trinithis: they *are* cool, but that doesn't mean they're good
23:48:35 <Trinithis> i sense a conflict arising
23:48:39 <O_4> Java was cool for quite some time, too :-p
23:48:44 <Trinithis> lol
23:48:45 <lament> O_4: you have to deal with a lot of administrational bullshit and competition from other companies
23:49:05 <lament> Trinithis: Python is wonderful :)
23:49:19 <lQg> well things are hot sometimes but then they cool down .u most things are cool especially if old
23:49:30 <lament> no other language got so many things right at the same time
23:50:16 <lament> it's almost completely devoid of mystique.
23:50:39 <lQg> lament: hmmm administration? i thought that was mainly handled by software
23:50:44 <Trinithis> I stilll want to learn befunge. That would be wicked
23:51:17 <lament> it is not hard to learn :)
23:51:30 <Trinithis> well... I mean actually find a compiler and use it
23:51:36 <lament> it's fun
23:51:50 <Trinithis> Perhaps Ill write my own compiler someday
23:51:52 <lament> i have lost my befunge masterpiece in a hard drive change... :(
23:51:55 <Trinithis> for it
23:52:15 <lQg> lament: what was your befunge masterpiece?
23:52:20 <lament> i have written a befunge "hello world" program that was at the same time a Z-machine "hello world" program
23:52:31 <Trinithis> z-machine?
23:52:33 <lament> Z-machine binary code
23:52:42 <lQg> ?
23:52:46 <Trinithis> thats cool
23:52:57 <Trinithis> Was that hard to do?
23:53:07 <lament> so you could run it in befunge interpreters and you could run it in interactive fiction interpreters
23:53:29 <lament> it was... pretty interesting :)
23:53:37 <lQg> Zork adventure game compiler
23:53:46 <Trinithis> How about Unlambda?
23:54:10 <lament> the spaces used by befunge program was at the same time the header file for the z5 virtual machine, the equivalent to an ELF header
23:54:51 <lQg> befunge certainly seems complicated
23:54:53 <lament> Trinithis: I learned call/cc from Unlambda, before scheme. My mind was blown :)
23:55:06 <Trinithis> haha
23:55:15 <Trinithis> did you know scheme at the time?
23:55:26 <lament> no
23:56:03 <lament> heh, i used to do so much esoteric stuff in high school
23:56:18 <lament> i wrote a lambda calculus interpreter on my TI-83
23:56:21 <lament> in TI-BASIC
23:56:37 <lament> it was horrifying :D
23:56:42 <Trinithis> O.o
23:57:01 <lament> then i wrote a brainfuck interpreter and some asshole TA erased the memory!
23:57:21 <_zenon_> lament, fuck, that's a fucking death sin.
23:57:41 <Trinithis> Sin 666 times over
23:57:48 <lQg> yea i'll have to learn unlambda some time .u to get its concepts into rpoku
23:58:05 <lament> oh haha have fun with call/cc
23:58:11 <Trinithis> rpoku?
23:58:13 <lament> should you wish to support it
23:58:56 <lQg> what does it do?
23:59:20 <lQg> Trinithis: http://www.reddit.com/comments/6t1i1/Rpoku_a_spoken_word_programming_language/
23:59:21 <lambdabot> Title: Rpoku: a spoken word programming language ... : reddit.com, http://tinyurl.com/5s85df
23:59:31 <Trinithis> haha
23:59:47 <lament> lQg: call/cc takes a function and calls it with the current continuation as the argument.
