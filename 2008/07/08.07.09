00:00:16 <vixey> @pl (\decl -> name' == name decl)
00:00:17 <lambdabot> (name' ==) . name
00:08:57 <vixey> what syntactic checks do you do to definitions before type checking?
00:09:16 <vixey> I think I will check that patterns are scoped well
00:33:29 <vixey> :t \x -> map ?f =<< map ?g x
00:33:30 <lambdabot> forall a b (f :: * -> *) a1. (Monad f, ?g::a1 -> f a, Functor f, ?f::a -> b) => f a1 -> f b
00:38:59 <ahunter> > (,) <$> [1,2,3,4,5]
00:39:00 <lambdabot>  Add a type signature
00:39:16 <ahunter> > (,) <$> [1,2,3,4,5] [True,False,True,False,True]
00:39:16 <lambdabot>  Couldn't match expected type `t -> f a'
00:39:32 <vixey> > liftM2 (,) [1,2,3,4,5] [True,False,True,False,True]
00:39:33 <lambdabot>  [(1,True),(1,False),(1,True),(1,False),(1,True),(2,True),(2,False),(2,True),...
00:39:39 <vixey> > (,) <$> [1,2,3,4,5] <*> [True,False,True,False,True]
00:39:40 <lambdabot>  [(1,True),(1,False),(1,True),(1,False),(1,True),(2,True),(2,False),(2,True),...
00:46:34 <_zenon_> :t <$>
00:46:35 <lambdabot> parse error on input `<$>'
00:46:49 <_zenon_> ?ty <$>
00:46:50 <lambdabot> parse error on input `<$>'
00:46:57 <_zenon_> ?ty "<$>"
00:46:58 <lambdabot> [Char]
00:47:01 <_zenon_> bleh
00:47:50 <vixey> :t (<$>)
00:47:54 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
00:54:23 <_zenon_> ahh
00:55:46 <_zenon_> :t (<*>)
00:55:47 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
00:55:55 <_zenon_> makes sense then
01:06:22 <chr1s> _zenon_: /win 2
01:06:26 <chr1s> argh.
01:06:32 <chr1s> I meant to say
01:07:00 <_zenon_> @seen kiris
01:07:01 <lambdabot> kiris is in #haskell. I don't know when kiris last spoke.
01:07:17 <chr1s> _zenon_: for me, the biggest insight was that (a <$> b <*>c <*> d) should be read as ((a <$> b) <*> c <*> d)
01:07:20 <_zenon_> kiris: How's your text-thingy going?
01:08:07 <_zenon_> chr1s: Ah, well, the path of enlightenment is harsh, but sweet as honey.
01:08:08 <_zenon_> :)
01:18:59 <BeelsebobWork_> is it only me that code.haskell.org seems dead to?
01:19:34 <dibblego> http://downforeveryoneorjustme.com/code.haskell.org
01:19:51 <BeelsebobWork_> oh, shiny
01:20:32 <BeelsebobWork_> is it only me that downforeveryoneorjustme.com seems dead to? :D
01:20:58 <osfameron> I think it blocks while trying to read the requested site
01:21:09 <osfameron> so if that site is down, it looks like dfeojm is downtoo
01:21:13 <awesame> there must be a better way to write this: flip $ catchJust ioErrors $ print $ do { ...stuff... }
01:21:14 <osfameron> which to be honest, is fairly moronic
01:21:28 <dibblego> @pl flip $ catchJust ioErrors $ print $ do { stuff }
01:21:28 <lambdabot> (line 1, column 40):
01:21:28 <lambdabot> unexpected "{"
01:21:28 <lambdabot> expecting variable, "(", operator, "$", "$!", "`seq`" or end of input
01:21:36 <dibblego> @pl flip $ catchJust ioErrors $ print $ do stuff
01:21:36 <lambdabot> flip (catchJust ioErrors (print (do stuff)))
01:21:38 <BeelsebobWork_> osfameron: yeh, that does seem pretty stupid
01:21:59 <dibblego> @pl flip $ catchJust ioErrors $ print $ stuff
01:22:00 <lambdabot> flip (catchJust ioErrors (print stuff))
01:22:06 <awesame> oh, that's not even what I was trying to write
01:22:12 <quicksilver> awesame: well, it might be annoying to say this. But don't catch ioErrors :P
01:22:17 <quicksilver> errors are not for catching!
01:22:40 <awesame> sorry, what should I be doing with them instead?
01:22:51 <quicksilver> not trying to stop them. They're errors.
01:22:54 <quicksilver> What are you using them for?
01:22:58 <osfameron> huh?
01:23:05 <quicksilver> exceptions are for catching. Errors are errors.
01:23:06 <_zenon_> how do you know that the requested site is not down for downforeveryoneorjustme ?
01:23:10 <_zenon_> hmm...
01:23:14 <vixey> does this already exist?
01:23:14 <vixey> append Nothing _ = Nothing
01:23:14 <vixey> append (Just x) y = Just (x ++ y)
01:23:20 <awesame> quicksilver: I'm trying to print them, rather than let them crash my server!
01:23:20 <quicksilver> http://www.haskell.org/haskellwiki/Error
01:23:21 <lambdabot> Title: Error - HaskellWiki
01:23:33 <quicksilver> awesame: well, that might be a good reason then.
01:24:01 <quicksilver> servers running "untrusted" code are one of the rare cases when catching errors seems appropriate.
01:24:12 <quicksilver> on the other hand, running untrusted code like that is dangerous :)
01:24:13 <awesame> what I'm trying to say is, do the stuff in this do block, but if it throws an ioError, just print that
01:24:52 <quicksilver> if you have some control over the nature of the code it would be better to change it to throw exceptions instead.
01:25:07 <awesame> else where I write: catchJust ioErrors doStuff print
01:25:33 <awesame> I'm trying to figure out how to insert a do block in place of doStuff
01:26:01 <quicksilver> catchJust ioErrors (do block in parentheses) print
01:26:06 <quicksilver> is the simplest way.
01:26:48 <awesame> can I avoid the parens somehow?  I was thinking of flipping (catchJust ioErrors) to get the do-block param last
01:26:51 <quicksilver> "printingErrors a = catchJust ioErrors a print"
01:26:58 <quicksilver> printingErrors $ do ....
01:27:21 <quicksilver> seems most attractive to me.
01:27:36 <quicksilver> flip (catchJust ioErrors) print $ do .... --- shouuld work too
01:27:48 <vixey> is this a readable bit of code or a confusing one?
01:27:49 <vixey> anyDuplicates = sum . map listToMaybe . filter (\group -> length group > 1) . group
01:28:27 <quicksilver> looks surprising to me. You've defined a num instance for a Maybe type?
01:28:37 <quicksilver> :t sum . map listToMaybe
01:28:38 <lambdabot> forall a. (Num (Maybe a)) => [[a]] -> Maybe a
01:28:48 <vixey> oh I don't use numbers much so I let sum = msum
01:29:47 <awesame> ah, that's what I was trying to write
01:29:53 <awesame> still not pretty, but at least it works
01:30:21 <awesame> maybe I should just name flip (catchJust ioErrors)
01:30:44 <quicksilver> awesame: well that's my printingErrors suggestion.
01:31:06 <awesame> anyway, the lecture on catching errors is way off here.  this is a very legitimate case of deciding what to do about errors at the top level of my program
01:31:35 <awesame> yeah, printingErrors may be the best idea
01:32:15 <quicksilver> if you have control of your program, there should be no errors.
01:32:17 <quicksilver> that's the point.
01:32:20 <quicksilver> errors are programming errors.
01:32:53 <quicksilver> the ability to catch errors from pure code breaks referential transparency and some people ven consider it a bug in haskell.
01:34:07 <awesame> so, the errors I'm catching in this case are all ones that I'm throwing
01:34:23 <_zenon_> vixey: k :: Maybe [a] -> [a] -> Maybe [a] ;;;   k x y = liftM2 (++) x  (return y)
01:35:00 <_zenon_> oohh sorry
01:35:10 <kiris> I dreamt about writing haskell expressions all night. woke up feeling tired. is this awesome (y/n)?
01:35:28 <awesame> if receiveHTTP returns a Left x rather than a Right x, I can't get the request, so I abort and show the contents of the Left x
01:36:01 <hpaste>  _zenon_ pasted "Vixey question" at http://hpaste.org/8797
01:36:15 <awesame> if my function to read the form returns Nothing instead of Just x, the form was invalid, so I abort and print a message about that
01:36:17 <vixey> I've proved some really hard theorems while sleeping actually :p
01:36:20 <_zenon_> pasting in channel == bad doggy
01:36:36 <vixey> *wake up* ~> resume proof hacking
01:36:58 <kiris> :P
01:37:06 <awesame> how should I be doing that instead?
01:37:09 <vixey> _zenon_: I don't know why you're pasting that
01:37:33 <quicksilver> awesame: OK that sounds excellent.
01:37:36 <_zenon_> vixey: You wondered if it existed, so I checked, and didn't find it, but wrote something .
01:37:39 <quicksilver> awesame: where do IO errors come into it?
01:37:48 <quicksilver> awesame: you should be using lefts and rights, or exceptions.
01:37:53 <quicksilver> awesame: and not IO errors ;)
01:38:08 <wuxia> if i want to do csg operations on meshes in haskell, what's my best option?
01:38:12 <awesame> I'm using ioErrors as exceptions, because I don't know the difference
01:38:17 <wuxia> there appears to be suprisingly little google results for haskell  mesh / haskell  geometry
01:38:31 <kiris> you'll have to make them
01:38:31 <awesame> I could use an Either return type, but I think it would make my code uglier
01:38:43 <quicksilver> awesame: right, well I'm trying to teach you the difference.
01:38:57 <quicksilver> awesame: I think using an Either return type would make your code cleaner.
01:39:01 <awesame> yeah, with you now
01:39:07 <quicksilver> but, failing that using throwDyn and catchDyn
01:39:10 <awesame> I thought you were saying don't catch exceptions!
01:39:18 <quicksilver> which let you define a new type all of your own for your exception.
01:39:29 <osfameron> awesame: it looks like quicksilver is making a distinction between "error" and "exception"
01:39:30 <quicksilver> (I was saying don't catch *errors*. Catcing exceptions is fine!)
01:39:34 <osfameron> which surprised me too...
01:39:38 <awesame> oh, hm
01:39:59 <quicksilver> http://www.haskell.org/haskellwiki/Error
01:40:00 <lambdabot> Title: Error - HaskellWiki
01:40:04 <quicksilver> http://www.haskell.org/haskellwiki/Exception
01:40:04 <lambdabot> Title: Exception - HaskellWiki
01:40:05 <awesame> except, I think I'm catching ioErrors anyway, because I don't want any possible io problem that could happen in this code to crash my server
01:40:30 <awesame> so, if the client drops the connection, for example, that should get caught
01:40:39 <quicksilver> definitely.
01:40:45 <quicksilver> that's not an error that's an expected condition :)
01:40:51 <_zenon_> does google index hpaste?
01:40:57 <quicksilver> _zenon_: yes.
01:41:02 <_zenon_> would be nice for all sorts of quick fixes :)
01:41:02 <awesame> I think those do get raised as ioErrors, though
01:41:25 <quicksilver> client drops connection is probably a SIGPIPE
01:41:38 <quicksilver> which you need to ignore
01:41:46 <awesame> yeah, I'm doing that
01:41:53 <quicksilver> once you ignore it you should get an exception on the thread that tries to read from / write to the handle
01:42:05 <quicksilver> I normally catch those "locally" to that thread.
01:42:13 <quicksilver> and then pass the message on in some way.
01:42:16 <awesame> catching ioErrors is something I started doing around when I noticed the SIGPIPE issue, to handle a similar expected condition that was crashing the server
01:43:03 <vixey> what should I target ?
01:45:06 <vixey> I need some kind of lazy lambda VM
01:54:46 <xkb> hi
01:54:59 <vixey> hi
01:55:15 <xkb> I'm trying to write a small Directory iterator program and I'm running into the following problem:
01:58:23 <xkb> how do you "and" 2 IO Bool values?
01:58:23 <xkb> I noticed doesDirectoryExist for example returns type IO Bool
01:58:23 <xkb> and I need to check for the existence of 3 specific directories
01:58:38 <vixey> you can only use && on Bools
01:58:40 <vixey> not IO Bools
01:58:47 <vixey> say f and g and IO Bool
01:58:50 <vixey> then you can go,
01:58:52 <vixey> do x <- f
01:58:55 <vixey>    y <- g
01:59:01 <vixey>    -- now x and y are Bool
01:59:08 <vixey>    return (x && y)
01:59:18 <vixey> <
01:59:21 <quicksilver> or liftM2 (&&) f g
01:59:21 <xkb> ah.. do the braces have meaning?
01:59:25 <quicksilver> which is the same thing.
01:59:36 <vixey> the <- thing will unbox the IO in the body of the do block
01:59:49 <xkb> portExist <- doesDirectoryExist( someDir ++ "/Portfolio" ) bronExist <- doesDirectoryExist( someDir ++ "/Bron") infoExist <- doesFileExist( someDir ++ "/info.txt") ret <- portExist && bronExist && infoExist return ret
01:59:53 <xkb> that was my attempt
01:59:57 <xkb> sry for the paste btw
02:00:03 <quicksilver> xkb: you were very close.
02:00:08 <xkb> meant to paste just the last 2 lines :)
02:00:11 <quicksilver> xkb: you didn't need to do "ret <-"
02:00:27 <quicksilver> xkb: because, portExist and bronExist and infoExist are plain Bool
02:00:44 <quicksilver> (the IO part was already unwrapped by the earlier <-s)
02:00:49 <xkb> aha
02:01:00 <quicksilver> you could just do return (portExist && bronExist && infoExist)
02:01:29 <xkb> just changed that
02:01:38 <xkb> cool works
02:03:01 <xkb> ok. the next problem will be to generate a templated html file
02:03:12 <xkb> I'll google for some libs :)
02:03:36 <vixey> once I parsed and typechecked this source code ... what should I do with it
02:03:39 <_zenon_> That's the spirit :)
02:03:53 <quicksilver> xkb: there is StringTemplate for haskell.
02:03:57 <quicksilver> I've not played with it myself.
02:06:19 <xkb> quicksilver: thanks
02:06:31 <xkb> I'm converting an old java program to haskell
02:06:55 <xkb> guess objects should map to datatypes?
02:06:58 <xkb> I*
02:08:15 <xkb> the java program scanned a bunch of directories and created a linked list of object from it
02:08:25 <vixey> > let tag t b = "<"+t+">"++b++"</"++t++">" ; [html,head,title,body] = map tag ["html","head","title","body"] in html( head( title( "my cool site" ) ) ++ body( "todo: add content" ) )
02:08:31 <lambdabot>   add an instance declaration for (Num [Char])
02:09:03 <vixey> > let tag t b = "<"++t++">"++b++"</"++t++">" ; [html,head,title,body] = map tag ["html","head","title","body"] in html( head( title( "my cool site" ) ) ++ body( "todo: add content" ) )
02:09:05 <lambdabot>  "<html><head><title>my cool site</title></head><body>todo: add content</body...
02:10:22 <osfameron> gah, that reminds me of CGI.pm's html regeneration, which is yuck
02:10:24 <osfameron> templates ftw
02:10:33 <BeelsebobWork> anyone here familiar with the subtleties of Happy?
02:10:46 <quicksilver> xkb: typically yes. class -> data type
02:17:57 <osfameron> @pl surround l r c = concat [l,c,r]
02:17:57 <lambdabot> surround = ((join .) .) . (. (flip (:) . return)) . (.) . (:)
02:18:01 <osfameron> eeeek
02:18:19 <vixey> @pl \l r -> (++r).(l++)
02:18:19 <lambdabot> flip ((.) . flip (++)) . (++)
02:19:20 <_zenon_> not verry eye-friendly :)
02:20:44 <quicksilver> I think (++r).(l++) is the best way to write it.
02:21:35 <vixey> :t left `surround` right = \middle -> left ++ middle ++ right
02:21:36 <lambdabot> parse error on input `='
02:22:28 <_Dae_> mornin'
02:23:48 <xkb> hmm say I have a Java class that looks like this: class foo { private String name; private List someList; } How would you define a haskell datatype for such a class?
02:24:20 <vixey> data Foo a = Foo String [a]
02:24:25 <xkb> ahhh
02:24:27 <xkb> repeat the Foo
02:24:33 <xkb> thats what I was doing wrong
02:24:35 <vixey> you don't have to repeat it
02:24:41 <xkb> so Foo is the typeconstructor here?
02:24:53 <vixey> one of the Foos is a type constructor
02:24:58 <vixey> the other Foo is a data constructor
02:25:01 <xkb> ok
02:25:03 <vixey> type Foo a = (String,[a]) also works
02:25:31 <xkb> the real object has a nr of collections, so I guess each of these will become a parameter to the type constructor?
02:25:42 <xkb> like Foo a b = Foo String [a] [b]
02:25:52 <vixey> that can work
02:26:03 <vixey> xkb: some important examples,
02:26:05 <vixey> @src Bool
02:26:05 <lambdabot> data Bool = False | True deriving (Eq, Ord)
02:26:07 <vixey> @src Maybe
02:26:07 <lambdabot> data Maybe a = Nothing | Just a
02:26:09 <vixey> @src Either
02:26:10 <lambdabot> Source not found. stty: unknown mode: doofus
02:26:19 <vixey> data Either a b = Left a | Right b
02:26:58 <_Dae_> are you sure you want them to be generic lists? It will probably be faster/easier to work with if you can define what you want to go into the list beforehand
02:28:22 <xkb_> bah disco
02:28:23 <vixey> I still don't know if I'm writing an interpreter or a compiler
02:28:32 <quicksilver> it's hard to tell :)
02:28:46 <xkb_> those lists contain paths to images.
02:28:47 <vixey> I wonder if there's a way to turn an untyped AST into HOAS
02:28:55 <vixey> without using unsafeCoercea
02:29:15 <vixey> xkb_: yeah you might have missed what Dae said
02:29:25 <osfameron> 8:
02:29:46 <osfameron> quicksilver: (++r).(l++) looks like an entry to an obfuscated C contest...
02:30:06 <vixey> osfameron: You've not seen sections before ?
02:30:17 <quicksilver> osfameron: true ;)
02:30:31 <_Dae_> xkb_: Right, so if they're string it would go like data Foo String [String] [String], which would make it easier to declare in the code..
02:30:54 <vixey> oh you can use FilePath
02:30:59 <vixey> it's a synonym for String
02:31:03 <quicksilver> yes, should probably use FilePath
02:31:16 <Baughn> osfameron: No, that's /normal, unobfuscated/ C. ;)
02:31:21 <osfameron> vixey: yes I've seen them, just saying that looks unpleasant
02:31:25 <_Dae_> What quicksilver and vixey said ;)
02:31:59 <xkb_> _Dae_: ok. Thanks for the pointers!
02:32:08 <profmakx> why the frack is Bool deriving Ord?
02:32:16 <Cale> > False < True
02:32:17 <lambdabot>  True
02:32:20 <vixey> > fromEnum True
02:32:21 <lambdabot>  1
02:32:29 <Cale> profmakx: Mostly just for completeness.
02:32:37 <_Dae_> 0xe51258df
02:32:41 <osfameron> vixey: I like "<" `surround` ">" $ tagname  :-)
02:32:47 <Baughn> profmakx: Why shouldn't it?
02:33:18 <osfameron> dunno if it reads any better though... tag = surround "<" ">"  vs tag = "<" `surround` ">"   ?
02:33:19 <quicksilver> profmakx: so you can use it as an index into a map.
02:33:23 <profmakx> why should false < true hold
02:33:32 <Cale> profmakx: Arbitrary decision.
02:33:37 <profmakx> (or vice versa)
02:33:44 <quicksilver> arbitrary orders are useful for efficient algorithms.
02:33:46 <Cale> profmakx: But if you like, it's the trivial lattice.
02:33:48 <vixey> False = 0
02:33:50 <vixey> True = 1
02:33:52 <quicksilver> tree-like stuff.
02:34:03 <yitz> profmakx: This comes in handy when you want to store some structure in a Data.Map that has a Bool in it somewhere. Then you can just derive an Ord instance.
02:34:03 <_Dae_> Sometimes I wonder if running haskell on a VM would be a blessing or simply invite people to think less
02:34:06 <Cale> Bool is a lattice, and so it inherits an ordering from that.
02:34:23 <vixey> Dae: what do you mean ?
02:34:30 <yitz> It's also useful for sorting
02:34:35 <Cale> Or a Data.Set
02:34:52 <Cale> Like, if Bool wasn't in Ord, then you couldn't have a Data.Set of (String,Bool) pairs.
02:35:04 <profmakx> the lattice explanation suits me fine ;)
02:35:16 <profmakx> hm
02:35:40 <_Dae_> vixey: Well, like the java VM is pretty intelligent from time to time, it saves computations for instance, so if you go "fib 2500" it goes "ooh wait, I've done this, got the answer saved right here"
02:35:56 <_zenon_> memoisation
02:36:02 <profmakx> perhaps i am thinking too much in math terms and not in practical terms (or i just did no think enough)
02:36:17 <Baughn> _Dae_: That can be a bad thing. How complex do results get before it stops storing them?
02:36:36 <Baughn> Moreover, sometimes I just want fib(1000000) once, and don't care to store either it or the intermediary results
02:36:39 <_zenon_> Baughn: Maybe just a memory-size thing
02:36:50 <vixey> oh that's not usual in VMs
02:36:51 <yitz> _Dae_: it would be very useful to have a Haskell compiler for the Java VM, and better support for .Net.
02:37:17 <Baughn> _zenon_: I'd proceed to call fib a million times, expecting constant memory use.
02:37:23 <Baughn> No, this makes little sense indeed
02:37:28 <vixey> maybe I should try to compile my little language into JVM
02:38:06 <osfameron> @pl tag name = uncurry surround $ "<" `surround` ">" &&& "</" `surround` ">" $ name
02:38:06 <lambdabot> tag = uncurry surround . ("<" `surround` ">" &&& "</" `surround` ">")
02:38:21 <_zenon_> Baughn: I don't follow. Using memoisation it would store the result after one round and present the memoised result.
02:38:48 <Baughn> _zenon_: Yes, so I'd call it with /different/ parameters, expecting constant memory use
02:38:56 <_Dae_> Baughn: there's obviously a limit to what it stores, it was just an example. I've seen a lot of arguments that VMs in theory should be faster than precompiled code and was wondering how that might effect haskell
02:38:59 <Baughn> Memoization is a powerful technique, but not if you can't turn it off
02:38:59 <_zenon_> Baughn: Are we disagreeing on something, or am I just off track here?
02:39:42 <Baughn> _zenon_: Well, my point is.. memoization is only a win if you /use/ the results again later. If you don't..
02:39:58 <_zenon_> Baughn: I totally agree :) No argument there.
02:40:11 <vixey> how do you compiler a higher order lazy language to JVM? :p
02:40:18 <kiris> Baughn: haha, isn't that the point? :P
02:40:19 <Baughn> If you don't it's a memory leak, and haskell has enough troubles with that already. :/
02:40:35 <kiris> it does? :(
02:40:36 <_Dae_> vixey: thought it had been done?
02:40:36 <_zenon_> Baughn: Just like you should try to fit your loops into the cache size for optimaility, reusing the memory efficiently, and so forth :)
02:40:44 <_Dae_> kiris: ohh yes
02:40:48 <vixey> done or not I don't know how to do it
02:41:22 <_zenon_> http://swtch.com/~rsc/regexp/regexp1.html
02:41:23 <lambdabot> Title: Regular Expression Matching Can Be Simple And Fast
02:41:32 <_Dae_> vixey: is it any different from compiling it into assembler? java bytecode is (if memory servers me right) very similarto assembler
02:41:52 <_zenon_> Using memoization contra _real_ efficient techniques ==> Memoization only gives you as much, but fails against wits.
02:41:56 <vixey> well they're both simple stack machines
02:42:03 <vixey> jvm does GC though
02:43:12 <_Dae_> so you wouldn't need one of your own...
02:43:13 <vixey> wait neither of them are simple
02:43:51 <_Dae_> you could write Joose(?) 1, it's a pretty simple subset
02:44:48 <plutonas> is it possible to define a function without explicitly defining an argument
02:44:59 <vixey> plutonas yes
02:45:03 <plutonas> i mean instead of saying function x = .... x to say function =
02:45:08 <vixey> uppercase = map toUpper
02:45:17 <Baughn> plutonas: It's called "points-free style", so yeah
02:45:17 <vixey> > let uppercase = map toUpper in uppercase "thaeuonthoue"
02:45:18 <lambdabot>  "THAEUONTHOUE"
02:45:22 <plutonas> vixey: and what's the rule for that?
02:45:31 <vixey> same as every haskell code
02:45:31 <mauke> what rule?
02:45:34 <vixey> just make sure it types
02:45:44 <plutonas> i mean when i want to write it, how do i think of it
02:46:00 <vixey> well there is really 2 things to think about
02:46:01 <plutonas> how do i know when to skip it and when not, and how it gets substituted by haskell
02:46:14 <vixey> if you have a function of type a -> b -> c
02:46:20 <_zenon_> I can _really_ recommend the Regexp site
02:46:25 <vixey> say it's called f, and you have x :: a,
02:46:27 <_zenon_> http://swtch.com/~rsc/regexp/regexp1.html
02:46:27 <lambdabot> Title: Regular Expression Matching Can Be Simple And Fast
02:46:37 <quicksilver> one of the thins a VM can do is defer optimisation
02:46:39 <_zenon_> (but is slow in Java, Perl, PHP, Python, Ruby, ...)
02:46:41 <vixey> you can use f x to get a function
02:46:49 <quicksilver> just-in-time optimisation can be very powerful
02:46:54 <vixey> and the other thing to think about is, if you have two functions f and g
02:46:54 <quicksilver> more information may be available then
02:47:01 <vixey> you can write f . g to get another function
02:48:11 <vixey> > let rle = map (head &&& length) . group in rle "nthaeousnthauethn"
02:48:12 <lambdabot>  [('n',1),('t',1),('h',1),('a',1),('e',1),('o',1),('u',1),('s',1),('n',1),('t...
02:48:33 <mauke> pfft, perl's regexes aren't slow
02:48:40 <_zenon_> mauke: obiously
02:48:50 <_zenon_> obviously*
02:49:52 <plutonas> vixey: i think i get it...
02:50:01 <plutonas> but it probably can't be done if the arguments are more than 1 right?
02:50:06 <_zenon_> It's (as stated in the text), due to Perl using backtracking + memoization
02:50:15 <_zenon_> Which is a popular but inefficient technique
02:50:19 <vixey> plutonas: it can be, it's a little awkward sometimes though
02:50:30 <vixey> you can use (x,y) as two args of course
02:50:35 <vixey> rather than p -> q -> ...
02:50:50 <_zenon_> Using a Brzozowski technique is more efficient
02:50:54 <_Dae_> quicksilver: Yeah, that's whatthe java an .Net crowd keeps claiming, but.... I don't know, they seem to lack evidence? The only thing java is faster than c++ or fortran in is object creation
02:51:20 <plutonas> vixey: yeap i see. thanks a lot
02:51:43 <vixey> plutonas: oh a very important one for this, foldr
02:51:56 <vixey> length = foldr (const (+1)) 0
02:52:04 <vixey> reverse = foldr (flip (:)) []
02:52:05 <vixey> ...
02:52:50 * _Dae_ wonders if a hybrid model is possible, or even desirable
02:53:12 <mauke> "In contrast, there are no regular expressions that are pathological for the Thompson NFA implementation." ... "an NFA or DFA-based implementation must expand the repetition: e{3} expands to eee; e{3,5} expands to eeee?e?, and e{3,} expands to eee+."
02:53:17 <mauke> what
02:53:27 <plutonas> vixey: oh not foldr again... i hate this function
02:53:36 <kiris> :O
02:53:38 <vixey> plutonas: foldr is awesome
02:53:43 <plutonas> took me 1 day to figure out the idea, and still am not sure i got it
02:53:46 <kiris> foldr ← awesome
02:53:47 <plutonas> although it sounds easy
02:53:55 <_zenon_> foldl'
02:53:56 <opqdonut> mauke: yeah, if the regex is translated into a standard DFA or NFA it has to be done that way
02:53:58 <plutonas> foldr = what foldl but from the right side
02:54:04 <vixey> plutonas: [1,2,3] = 1:(2:(3:[]))
02:54:40 <_zenon_> still lazy though.
02:54:46 <_zenon_> @ty foldl'
02:54:47 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
02:54:51 <mauke> so, "((X{1,999}){1,999}){1,999}"
02:54:51 <vixey> plutonas: foldr (&) e [1,2,3] = foldr (&) e (1:(2:(3:[]))) = 1&(2&(3&e))
02:55:19 <plutonas> vixey: hm, i like this example
02:55:33 <opqdonut> mauke: it's still linear wrt. the number of states
02:56:13 <mauke> it's HUEG
02:56:25 <_zenon_> indeed
02:57:56 <vixey> plutonas: if you had a data type like Exp = Number Integer | Add Exp Exp | ...
02:58:03 <kiris> @pl (\x y -> [x] ++ show y)
02:58:03 <lambdabot> (. show) . (:)
02:58:11 <vixey> you could write an evaluator for it using foldexp
02:58:21 <vixey> foldexp id (+) (*) (/) ...
02:58:32 <quicksilver> _Dae_: plenty of things are possible which have not yet been acheived :)
02:58:33 <xkb_> hmm I'm running in to another small problem. Say I want to filter all files ending at .jpg from a directory.
02:58:55 <xkb_> I now have the following: use getDirectoryContents to get an IO [FilePath] list
02:59:05 <xkb_> use filterM to get the right files
02:59:13 <vixey> xkb_: filter (`endsWith` ".jpg")
02:59:15 <_Dae_> quicksilver: Heh, yeah.... makes you want to become a computer scientist
02:59:25 <vixey> xkb_: I don't think endsWith exists though
02:59:29 <ziman> Data.List.isSuffixOf
02:59:37 <mauke> :t filterM
02:59:37 <kiris> let rle = concatMap (uncurry ((.show).(:)) . (head &&& length)) . group in rle "mississippi"
02:59:38 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
02:59:40 <vixey> endsWith = flip isSuffixOf
02:59:47 <xkb_> lol
02:59:49 <kiris> > concatMap (uncurry ((.show).(:)) . (head &&& length)) . group in rle "mississippi"
02:59:49 <lambdabot>  Parse error at "in" (column 63)
02:59:59 <kiris> > let rle= concatMap (uncurry ((.show).(:)) . (head &&& length)) . group in rle "mississippi"
03:00:00 <lambdabot>  "m1i1s2i1s2i1p2i1"
03:00:02 <plutonas> vixey: thank you
03:00:09 <vixey> rle = (head &&& length . group
03:00:11 <kiris> the uncurry function is lame
03:00:16 <vixey> unrle = concat . uncurry replicate
03:00:23 <kiris> @src replicate
03:00:24 <lambdabot> replicate n x = take n (repeat x)
03:00:36 <kiris> :)
03:00:43 <vixey> unrle = concat . map (uncurry replicate)
03:01:04 <_Dae_> @src repeat
03:01:04 <lambdabot> repeat x = xs where xs = x : xs
03:01:04 <vixey> rle . unrle = (head &&& length) . group . concat . map (uncurry replicate) = (head &&& length) . map (uncurry replicate) = id
03:01:17 <vixey> oh that's a lie
03:01:26 <vixey> gotta start with unrle . rle
03:01:53 <xkb_> hmm however filter returns [FilePath] while the function defines IO [FilePath]
03:02:05 <vixey> plutonas: (if you ignore my mistake), ^ is a example of how pointfree can help reasoning about programs
03:02:12 <kiris> filterM?
03:02:19 <kiris> no
03:02:27 <vixey> xkb_: remember before getting IO Bools unboxed?
03:02:30 <vixey> xkb_: using <-
03:02:32 <kiris> foo >>= return . filter (..)
03:02:44 <vixey> xkb_: you could hopefully do the same thing in this situation
03:02:57 <xkb_> :)
03:02:57 <vixey> (I think filterM is more complex than just that ..?)
03:03:03 <kiris> yeah it is
03:03:11 <kiris> @src filterM
03:03:11 <lambdabot> Source not found. You untyped fool!
03:03:15 <kiris> D:
03:03:20 <Baughn> files <- filter (`isSuffixOf` ".jpg") <$> getFiles, or some such?
03:03:23 <vixey> :t filterM
03:03:25 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
03:03:41 <vixey> > filterM (\x -> [True,False]) [1..7]
03:03:45 <lambdabot>  [[1,2,3,4,5,6,7],[1,2,3,4,5,6],[1,2,3,4,5,7],[1,2,3,4,5],[1,2,3,4,6,7],[1,2,...
03:03:51 <kiris> hehe
03:04:01 <vixey> oh
03:04:04 <vixey> that's the powerset
03:04:06 <kiris> is dat some powerset
03:04:08 <kiris> ja
03:04:29 <kiris> :t (<$>)
03:04:30 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
03:04:40 <kiris> this just infix fmap?
03:04:48 <ziman> it is
03:04:51 <vixey> :t (.)
03:04:52 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
03:04:53 <mauke> @src (<$>)
03:04:54 <lambdabot> f <$> a = fmap f a
03:05:01 <kiris> in before `fmap`
03:05:18 <mauke> `liftA`
03:06:54 <xkb_> hmm that unboxing thing is not quite clear to me
03:07:26 <Baughn> You usually don't need it. The optimizer does a good job.
03:09:05 <kiris> I think he's referring to vixey's metaphor of using bind to “unbox” a value from a monad? 6_6
03:09:11 <kiris> or not
03:10:57 <xkb_> correct
03:11:01 <xkb_> see this example
03:11:03 <xkb_> http://pastebin.com/m6c7921f2
03:11:14 <xkb_> Im having troubles getting from the FilePath to String
03:11:33 <xkb_> and using the filter or filterM to create the list of image FilePaths
03:11:33 <mauke> wtf?
03:11:39 <mauke> stop putting parens around variables
03:11:53 <kiris> you incompetent whept!
03:12:00 <vixey> createPortfolio ( someDir ) = do
03:12:00 <vixey> 	name <- ( someDir )
03:12:01 <vixey> should be
03:12:04 * xkb_ ducks n covers
03:12:06 <vixey> createPortfolio name = do
03:12:27 <mauke> also, filterM is wrong
03:12:30 <mauke> you want filter
03:13:08 <mauke> 'x <- foo; return x' better written as 'foo'
03:13:46 <mauke> getAllImages someDir = do { files <- getDirectoryContents someDir; return (filter isGraphics files) }
03:15:34 <xkb_> thanks for the help
03:15:35 <_Dae_> isGraphics = isSuffixOf  ".jpg"
03:15:47 <xkb_> this reduced the compiler errors to 1 :)
03:15:52 <mauke> _Dae_: that's harder to understand
03:16:04 <opqdonut> mhmm
03:16:07 <opqdonut> arguments are flipped
03:16:30 <opqdonut> no wait
03:16:43 <osfameron> it makes sense for ".jpg" `isPrefixOf` ...
03:16:44 <ziman> i'd prefer (".jpg" `isSuffixOf`)
03:16:48 <opqdonut> yeah
03:16:50 <osfameron> yeah
03:16:59 <osfameron> but very odd without the infix notation
03:17:00 <_Dae_> mauke: You think?
03:17:06 <vixey> endsWith = flip isSuffixOf
03:17:25 <mauke> createPortfolio someDir = do { images <- getAllImages (someDir ++ "/Bron"); let tags = getTags (someDir ++ "/info.txt"); return (Portfolio someDir images tags) }
03:19:59 <ndmitchell> osfameron: why not takeExtension?
03:20:09 <ndmitchell> do these things using the System.FilePath module
03:20:20 <ndmitchell> ((==) ".jpg" . takeExtension)
03:21:08 <osfameron> sounds sensible
03:22:05 <xkb_> takeExtension sounds ok
03:23:12 <xkb_> ok I have one question left.. Why can't I do name <- someDir in the createPortfolio function?
03:23:14 <beschmi> I just replaced a bunch of boilerplate with uniplate and i'm wondering how to get the fastest Uniplate instances. Manual traversals took 1:30, PlateData 5 min, using Data.Generics.Uniplate instances takes it back to 1:45.
03:23:34 <therp> I'm sorry for this horrible question, but is there anything that can extract data from .xls (excel 97/2000 format) probably available with Haskell bindings?
03:23:34 <vixey> xkb_: You can but it's like odd to..
03:24:09 <opqdonut> therp: you can probably find a script to convert that into csv
03:24:10 <beschmi> i saw the benchmarks in the darcs repo and just wondered what's the recommended way to write your own instances
03:24:12 <ndmitchell> beschmi, hello :)
03:24:18 <beschmi> hi ndmitchell ;)
03:24:29 <ndmitchell> beschmi, have you read my thesis chapter? which gives the benchmarks along with comparative scores?
03:24:42 <therp> opqdonut: found that already, but I was just wondering
03:25:07 <mauke> xkb_: because someDir is a string, not an IO action
03:25:17 <ndmitchell> beschmi, and what do you mean by Data.Generics.Uniplate? Hand written instances? The recommendation is to go for PlateDirect, if you want highest speed and easy instances
03:25:29 <beschmi> ndmitchell: only the 2007 paper, so the thesis chapter is more up to date wrt the new release
03:25:51 <ndmitchell> beschmi, yes, although most of the details are the same - only a few new bits
03:26:12 <beschmi> ndmitchell: yes, similar to the ones in your paper for the Expr type
03:27:03 <ndmitchell> beschmi: it now has higher performance instances based on a Str type, if you use Data.Generics.UniplateStr - although I recommend just using Data.Generics.PlateDirect, the combinators detailed in there, and it will give you performance within a few perfect of the manual stuff with a lot less work
03:27:07 <quicksilver> xkb_: you want to just do "let name = someDir"
03:27:13 <beschmi> ndmitchell: thanks, i'll try it with PlateDirect then. Made my code much clearer, so I don't care for a little speed.
03:27:13 <quicksilver> xkb_: <- is for unwrapping monads
03:27:20 <quicksilver> xkb_: if it's not wrapped you don't use <-
03:27:45 <ndmitchell> beschmi: yeah, that slow down is fairly minor, to be honest - have you upgraded to 1.2?
03:28:06 <ndmitchell> that should give a bit of speed up with PlateData, although it is still likely to be too painful
03:28:26 <beschmi> ndmitchell: yeah, i'm using 1.2
03:28:28 <ndmitchell> just be happy that if you used SYB directly you'd likely get 15mins :)
03:28:30 <xkb_> quicksilver: thanks for the explanation
03:31:50 <JaffaCake> quick poll: I'd like some feedback on http://hackage.haskell.org/trac/ghc/ticket/1205
03:31:53 <lambdabot> Title: #1205 (ghci reports functions not in scope after loading a .hs, if there is a .o ...
03:31:56 <kiris> @src and
03:31:56 <lambdabot> and   =  foldr (&&) True
03:32:20 <plutonas> when i get this error:  Couldn't match expected type `[a]'
03:32:20 <plutonas>            against inferred type `[[a]] -> [[a]] -> [[a]]' , does it mean that it expects [a] but it gets [[a]] -> [[a]] -> [[a]] ?
03:32:34 <JaffaCake> so I'm considering making ':load foo.hs' always load foo.hs as bytecode, which seems to be what most people would like to see
03:32:34 <mauke> plutonas: yes
03:32:39 <kiris> so and [t1,t2,t3] is as fast as writing out t1 && t2 && t3?
03:32:42 <plutonas> mauke: strange, but thank you :)
03:32:47 <vixey> fast ??
03:32:57 * ndmitchell waits on hackage
03:32:59 <kiris> well, imagine I'm executing it millions of times
03:33:15 <JaffaCake> the question is, what should ':l foo' do?  it currently means the same as ':l foo.hs'
03:33:16 <vixey> you could get GHC to rewrite the and using rules
03:33:34 <kiris> hmm
03:33:39 <kiris> is that in the docs?
03:33:45 <kiris> let me see
03:33:50 <Baughn> JaffaCake: It would be nice to have the option of compiling files without dropping to the cli, too
03:33:53 <Baughn> :lc, maybe
03:33:54 <conal> @seen dcoutts_
03:33:55 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell-overflow, #ghc and #haskell. I don't know when dcoutts_ last spoke.
03:34:08 <JaffaCake> Baughn: you have -fobject-code
03:34:10 <ndmitchell> JaffaCake: having :l foo /= :l foo.hs is very very confusing, especially to windows users, where the extension is often implicit
03:34:13 <mauke> preflex: seen dcoutts_
03:34:13 <preflex>  dcoutts_ was last seen on #ghc 6 days, 19 hours, 48 minutes and 47 seconds ago, saying: right, I'm off camping for a week, bye folks! :-)
03:34:35 <JaffaCake> ndmitchell: right, actually the easiest thing for me is to make them the same
03:34:38 <kiris> I'd kind of expect string literal folds like that to be inlined
03:34:46 <JaffaCake> I'm wondering whether *that* would be confusing at all
03:34:46 <kiris> uhh, s/string/list/
03:37:18 <quicksilver> JaffaCake: I would definitely like :l foo.hs to always interpret.
03:37:27 <quicksilver> JaffaCake: I have never in my life typed ":l foo"
03:37:35 <quicksilver> JaffaCake: I have no opinion on what that should do :)
03:37:39 <JaffaCake> quicksilver: thanks!
03:38:17 <kiris> vixey: ah, I think the intermediate list in `and' is eliminated: http://www.haskell.org/ghc/docs/latest/html/users_guide/rewrite-rules.html#id413287
03:38:18 <lambdabot> Title: 8.13. Rewrite rules, http://tinyurl.com/y7rk9g
03:39:24 <yitz> JaffaCake: I also think that the current behavior is confusing. I've been bitten by it several times. Glad to see that Simon M. has decided to do something about it.
03:41:50 <plutonas> when i use pattern matching does the order of the function definitions matter?
03:42:01 <mauke> yes
03:42:02 <plutonas> i mean the one defined first will try to be matched first etc?
03:42:05 <Cale> plutonas: Yes, they're matched top-down
03:42:16 <plutonas> so the empty list definition should always come last?
03:42:25 <plutonas> hm sorry stated wrong
03:42:26 <mauke> no
03:42:29 <mauke> I usually put it first
03:42:30 <Cale> I usually put it first.
03:42:36 <plutonas> the one with _'s
03:42:40 <Cale> ah, yes
03:42:43 <mauke> ｓｔｅｒｅｏ
03:43:05 <yitz> I usually put it last
03:43:21 <yitz> s u r r o u n d   s o u n d
03:44:02 <plutonas> yeap works now thanks again
03:44:43 <BeelsebobWork> @where parsec
03:44:43 <lambdabot> http://www.cs.ruu.nl/~daan/parsec.html
03:45:13 <ToRA> hey, is there some documentation for cabal install that i'm just not seeing.  Specifically something that explains how to build the documentation for a package you just cabal install 'd ?
03:45:34 <yitz> Usually the "empty list" case is an edge condition, so you don't want to focus attention on it. It's nice that Haskell's pattern matching syntax makes it easy to push edge conditions to the end in most cases.
03:50:22 <schme_> Unlike other language's pattern matching ... ?
03:50:51 <quicksilver> unlike other languages which dont' have pattern matching
03:50:53 <quicksilver> I imagine
03:50:57 <mauke> see C, 'switch'
03:51:26 <schme_> Well yeah.
03:51:40 <schme_> I was thinking more of prolog and other languages that actually *do* have pattern matching.
03:55:46 <_Dae_> @src forM_
03:55:46 <lambdabot> forM_ = flip mapM_
03:55:52 <_Dae_> ....
03:55:56 <vixey> !
03:55:57 <_Dae_> @src mapM_
03:55:57 <lambdabot> mapM_ f as = sequence_ (map f as)
03:56:44 <DRMacIver> If I want to do some slightly smart scraping of an html page (basically I want to extract its tables as [[String]]s), which libraries in particular should I be looking at? It looks a little more than Tagsoup would easily handle. HXT?
03:57:04 <ndmitchell> DRMacIver: sounds perfect for tagsoup :)
03:57:29 <DRMacIver> Really? It didn't seem obvious how to do it to me without some fairly nasty list manipulation.
03:57:35 <ndmitchell> I think the sections command will do most of it...
03:57:45 <DRMacIver> Ah. Thanks, I'll take a look.
03:58:12 <Baughn> DRMacIver: Tagsoup is for malformed html
03:58:27 <DRMacIver> I wasn't aware any other sort of html existed in the wild. :)
03:58:27 <Baughn> If it's at all likely to be well-formed, try HaXml's html module
03:58:30 <mauke> all html is malformed
03:58:34 <ndmitchell> Baughn: its for everything
03:58:42 <yitz> DRMacIver: other XML/HMTL libs are for more validation of the doc format. tagsoup is definitely what you want here.
03:58:42 <Baughn> ndmitchell: Hush
03:58:52 <Baughn> The html I write is well-formed. ;)
03:59:29 <_Dae_> Baughn: Isn't that like saying the "the fire i make is cold"? :p
03:59:43 <ndmitchell> DRMacIver: sections (~== "<table>"), then a sections on <tr> and <td> should do it
03:59:43 <quicksilver> tagsoup has a particular view of the data
03:59:53 <quicksilver> it's SAX-like in the sense that it's streaming
03:59:56 <Baughn> _Dae_: Meanies. Writing well-formed HTML isn't actually /impossible/
04:00:05 <quicksilver> and it's rather lightweight int he sense that it's mostly lists
04:00:09 <quicksilver> and you use standard list combinators
04:00:17 <quicksilver> plus a couple of useful ones which come with it.
04:00:19 <DRMacIver> ndmitchell: Do you mean partitions rather than sections? Sections seems to return suffixes, which looks like it does the wrong thing.
04:00:33 <mauke> what happened to ndm?
04:01:06 <ndmitchell> DRMacIver: no, sections is what you want, it will chop up the bits so that no tag is in two sections and they are delimited as you asked
04:01:18 <ndmitchell> mauke: different IRC client, no idea how to change nick automatically on this one!
04:01:24 <kiris> “what happened to the old ndm?” “HE'S GONE!!”
04:01:24 <mauke> heh
04:01:28 <_Dae_> Baughn: I know.... it's just very rarely seen
04:01:33 <DRMacIver> ndmitchell: That's not what the documentation says it does.
04:01:38 <ndmitchell> DRMacIver: you might want to try Text.HTML.TagSoup.Tree - that does trees
04:01:54 <yitz> DRMacIver: ndmitchell wrote it
04:01:59 <DRMacIver> yitz: Yes, I know that.
04:02:01 <ndmitchell> DRMacIver: you are right
04:02:06 <DRMacIver> But it's still not what the documentation says it does. :)
04:02:14 <ndmitchell> DRMacIver: i thought it did the other thing, but hey, i'm wrong :)
04:02:19 <DRMacIver> Ok. :)
04:02:48 <ndmitchell> I'm pretty sure i must have accepted a patch modifiying partitions, cause i don't understand the code!
04:03:37 <ndmitchell> kiris: ndm is likely to return in September, when I can get a real IRC client again, and not a web based one
04:03:47 <mauke> preflex: seen ndm
04:03:47 <preflex>  ndm was last seen on #haskell 5 days, 2 hours, 24 minutes and 18 seconds ago, saying: certainly Lava integrates with one of them
04:04:25 <ndmitchell> ndm poppped in before i managed to convince mibbit to auto-connect, now i've got it doing that, i don't want to take the hassle to change nick
04:04:25 <_Dae_> ndm = ndmitchell ?
04:04:32 <ndmitchell> _Dae_: yes
04:04:48 * shapr yawns
04:04:52 <_Dae_> but..you're right here?
04:12:31 <Baughn> _Dae_: Multiple personality syndrome. Don't poke it too much.
04:15:36 <ndmitchell> I think I'll be ndm on Monday, since i'm in York, but will be <n/a> over the weekend as I'll be internet-less
04:15:50 <ndmitchell> (for the 3rd ICFP programming contest in a row)
04:16:53 <_Dae_> ndmitchell: good luck?
04:17:46 <ndmitchell> I mean I can't compete it the ICFP contest, as no internet, as always seems to happen
04:18:14 <matthew-_> ndmitchell: thanks for the pointer to polyparse. It's fab.
04:18:35 <ndmitchell> matthew-_: cool :)
04:19:50 <matthew-_> ndmitchell: I like the hgetcontents and then feed that into a lazy parser and just carry around a list of parsed things
04:20:06 <matthew-_> it means you can escape from IO early on
04:32:45 <DRMacIver> Is making the boolean operations a typeclass one of the standard alternative prelude ideas bandied about?
04:35:11 <ndmitchell> DRMacIver: John Meacham had a boolean class library
04:35:29 <DRMacIver> Ah. Is it on hackage?
04:35:34 <DRMacIver> And/or what's it called?
04:36:24 <Syzygy|de> Yo DRMacIver
04:36:34 <DRMacIver> Hi Syzygy
04:37:01 <ndmitchell> @google john meacham boolean class
04:37:02 <lambdabot> http://repetae.net/recent/
04:37:02 <lambdabot> Title: John Meacham - Recent Updates
04:37:32 <ndmitchell> http://repetae.net/recent/out/Boolean.html
04:37:32 <lambdabot> Title: Boolean
04:37:52 <DRMacIver> Ah. Thanks. I was staring at his site and somehow completely missed the big label saying "Boolean" :)
04:42:24 <matthew-_> agh, I've often wanted that
04:43:31 <quicksilver> have you? why? ;)
04:43:46 <quicksilver> I mean I understand the notion of general boolean algebras
04:43:53 <quicksilver> but how is it useful in prgramming?
04:44:05 <DRMacIver> The particular instance I wanted this for (which no doubt someone will tell me is a horrible idea for) is the natural instance for a -> Bool
04:44:31 <ndmitchell> DRMacIver: which is?
04:44:40 <DRMacIver> Hm. What an incoherent sentence. I think I need more tea.
04:45:04 <matthew-_> quicksilver: you remember the 2004 icfp contest? The Ants? Well I want not Red = Black and not Black = Red
04:45:32 <DRMacIver> ndmitchell: basically just composing application with all the operations. e.g. f && g = \x -> f x && f g, etc.
04:45:45 <mauke> liftA2 (&&)
04:45:47 <ndmitchell> DRMacIver: ah, i want that often too
04:46:54 <DRMacIver> I just frequently find I want to combine predicates in boolean combinations, and there's currently not a nice way to do so without defining a new set of operations
04:48:21 <hpaste>  kiris pasted "list comprehension. how can I combine these two?" at http://hpaste.org/8799
04:48:56 <matthew-_> DRMacIver: let f x y = and $ sequence x $ y in f
04:49:08 <hpaste>  kiris annotated "list comprehension. how can I combine these two?" with "example data" at http://hpaste.org/8799#a1
04:49:21 <matthew-_> DRMacIver: f :: [a -> Bool] -> a -> Bool
04:49:49 <DRMacIver> matthew-_: ?
04:50:32 <matthew-_> DRMacIver: ahh, I misunderstood you. But I needed this sort of thing a lot yesterday, where you have a list of predicates and you want to combine them
04:50:45 <DRMacIver> Ah, right.
04:51:18 <DRMacIver> Yes, I know how to do it. I just wanted them to use the boolean algebra operators rather than having to define new ones.
04:51:24 <DRMacIver> It's not a big deal really. Just a minor annoyance.
04:51:29 <matthew-_> I see.
04:52:11 <quicksilver> matthew-_: Red/Black. Hmm. Yes, I see.
04:52:57 <quicksilver> matthew-_: next you'll be asking for  Heyting Algebra?
04:53:13 <matthew-_> quicksilver: I'd first have to learn what that is
04:53:36 <kiris> > let x1=1;y1=5;x2=4;y2=2 in [ (x,y) | y <- [min y1 y2..max y1 y2], x <- [x1,x2] ] ++ [ (x,y) | x <- [min x1 x2..max x1 x2], y <- [y1,y2] ]
04:53:37 <lambdabot>  [(1,2),(4,2),(1,3),(4,3),(1,4),(4,4),(1,5),(4,5),(1,5),(1,2),(2,5),(2,2),(3,...
04:53:54 <matthew-_> oh, λb's back
04:53:59 <quicksilver> matthew-_: it's the structure analagous to Boolean Algebras for intuitionistic rather than classic logic.
04:54:19 <matthew-_> quicksilver: is it useful? and is it decideable?
04:54:26 <kiris> if x1,y1 x2,x2 represent the top left and bottom right of a rectangle, I want to get all the points of its perimeter
04:54:36 <kiris> er, x2,y2
04:54:48 <Zao> There's an awful amount of points on a rectangle.
04:54:59 <matthew-_> presumeably discrete
04:54:59 <Zao> Unless you're restricting yourself to those on integral positions or something.
04:55:08 <SliMM> What is functional programming?
04:55:35 <kiris> above is the right points I want, but the code size is large
04:56:11 <kiris> ah, hum
04:56:14 <_Dae_> SliMM: A blessing upon mankind?
04:56:24 <oldsalt> hi guys, i am getting the error message Failed to load interface for `Data.ByteString':
04:56:24 <oldsalt>   no package matching bytestring-0.9.0.1.1 was found after updating to ghc-6.8.3 and i have no clue which package is causing the error. How can i efficiently track down this error?
04:56:52 <SliMM> _Dae_: Well, possibly, I don't really know
04:57:32 <matthew-_> > let f (x1,y1) (x2,y2) = concat [[(x,y1) | x <- [x1..x2]],[(x2,y) | y <- [y1..y2]],[(x,y2)|x<-[x2,(pred x2)..x1]],[(x1,y)|y<-[y2,(pred y2)..y1]]] in f (2,2) (5,4)
04:57:33 <lambdabot>  [(2,2),(3,2),(4,2),(5,2),(5,2),(5,3),(5,4),(5,4),(4,4),(3,4),(2,4),(2,4),(2,...
04:57:50 <_Dae_> SliMM: http://en.wikipedia.org/wiki/Functional_programming
04:57:51 <lambdabot> Title: Functional programming - Wikipedia, the free encyclopedia
04:57:59 <Zao> > let (x1,x2,y1,y2) = (1,5,2,6) in [(x,y) | x <- [x1..x2], y <- [y1..y2], x == x1 || x == x2 || y == y1 || y == y2]
04:58:00 <lambdabot>  [(1,2),(1,3),(1,4),(1,5),(1,6),(2,2),(2,6),(3,2),(3,6),(4,2),(4,6),(5,2),(5,...
04:58:23 <kiris> yeah, I just wrote that in ghci heh
04:58:28 <kiris> duhh
04:58:34 <Zao> I abused lambdabot in private :)
04:58:44 <kiris> ^_^
05:00:38 <int-e> > let (x1,x2,y1,y2) = (1,5,2,6) in [(x,y) | x <- [x1..x2], y <- if x == x1 || x == x2 then [y1..y2] else [y1, y2]]
05:00:39 <lambdabot>  [(1,2),(1,3),(1,4),(1,5),(1,6),(2,2),(2,6),(3,2),(3,6),(4,2),(4,6),(5,2),(5,...
05:01:27 <hpaste>  Orchid pasted "Why is this not in the Prelude?" at http://hpaste.org/8800
05:01:46 <kiris> int-e: nice :)
05:02:14 <matthew-_> whilst these are really clever, and in int-e's case, not actually doing unnecessary work, I would still argue my explicit treatment of each edge is more readable
05:02:37 <kiris> I thought Zao's was most clear
05:02:38 <int-e> yes, but quadratic runtime hurts.
05:03:21 <Zao> Doesn't list concatenation hurt a bit?
05:03:37 <int-e> not asymptotically
05:03:42 <kiris> O(n) where n is the length of the first list?
05:09:08 <yitz> int-e: you sound like a person. I thought you were a bot. Or am I confusing you with a different nick?
05:10:33 <_Dae_> yitz: quicksilver sounds like a person too, and he's a bot
05:10:36 <nornagon> uh, i'm pretty sure int-e is a person... if not, it wins the turing test :)
05:10:55 <mauke> I'm a bot too!
05:11:02 <mauke> preflex: are you a bot?
05:11:02 <preflex>  yes.
05:11:07 <rwbarton> @bot
05:11:07 <lambdabot> :)
05:11:14 <yitz> preflex @seen mauke
05:11:16 <matthew-_> :(
05:11:27 <ziman> preflex, am i a bot?
05:11:31 <yitz> preflex seen mauke
05:11:31 <preflex>  mauke was last seen on #haskell 28 seconds ago, saying: preflex: are you a bot?
05:13:08 <int-e> yitz, I don't know where you got the idea.
05:13:16 <matthew-_> heh, everyone is on here is a bot
05:13:25 <matthew-_> just with different levels of consciousness and/or denial
05:14:11 <matthew-_> some sort of cross between the matrix and tron
05:14:37 <kiris> and pokemon
05:14:52 <camio> I am not a bot!
05:14:55 <titusg> matthew-_: Can you elaborate on that?
05:14:57 <matthew-_> did you have to lower the tone? ;)
05:15:07 <yitz> int-e: sorry, no offense I hope :) there is some logging bot that has a nick similar to yours, I can't remember it. Not long ago it was broken and kept signing in and out of the channel every 9 minutes, annoyingly. Anyone remember it?
05:15:09 <matthew-_> pokemon? really?
05:15:52 <kiris> /ctcp catch matthew-_
05:16:08 <_Dae_> yeah.... there's a whole "gotta katch 'em all" thing going on with haskell programmers....
05:16:15 <yitz> @vixen are you a bot?
05:16:15 <lambdabot> no, how dare you ask if i'm a bot!
05:16:22 <mauke> ITYM /ctcp matthew-_ catch
05:16:35 <kiris> YIDMT
05:16:54 <matthew-_> @users
05:16:54 <lambdabot> Maximum users seen in #haskell: 428, currently: 427 (99.8%), active: 20 (4.7%)
05:17:17 <int-e> yitz: cmeme<some digit>. I asked about why it was banned a while ago. Maybe that's why.
05:17:28 <mauke> NYJMUA
05:17:50 <kiris> IHBT
05:18:31 <yitz> mm, yes that was it. I guess I mistakenly associated you with it then in my mind. my apologies.
05:18:35 <int-e> yitz: http://ircbrowse.com/channel/haskell/20080604
05:18:36 <lambdabot> Title: Meme haskell IRC Log 2008/06/04
05:21:07 <int-e> (you can see it joining over and over again there, starting at 05:42:52)
05:24:04 <xkb_> hi, my program runs fine in ghci, however building it with ghc I get a linker error (I think) undefined reference to 'filepathxxxxxx...'
05:24:18 <xkb_> any ideas what lib I need to link? (windows xp)
05:24:52 <yitz> int-e: yep, that's the one.
05:26:02 <Zao> xkb_: --make tends to help
05:26:16 <xkb_> Zao: thanks
05:26:19 <xkb_> did the trick
05:26:23 <Saizan_> anyone have used nhc?
05:26:46 <Zao> xkb_: Otherwise, --package Whatever  would have done the right thing if you knew which package it's in.
05:27:02 <Zao> xkb_: Which the hierarchial libraries thingie should tell you.
05:27:35 <_zenon_> god damn it with php and it's type juggling
05:27:38 <Zao> Seems like 'filepath', unsurprisingly.
05:27:47 <noecksit> is it possible in haskell to have some common body of code execute no matter of whether there was an if or else statement in the beginning?
05:27:51 <kiris> _zenon_: type juggling?
05:28:02 <_zenon_> yeah
05:28:16 <_zenon_> http://se.php.net/language.types.type-juggling
05:28:18 <lambdabot> Title: PHP: Type Juggling - Manual
05:28:27 <_zenon_> they even have a manual for it :P
05:28:41 <noecksit> like "if smthing then execsmthing else execsmthingelse; commonbody"
05:28:48 <quicksilver> noecksit: yes
05:28:50 <kiris> oh, that
05:28:53 <quicksilver> noecksit: what does 'execute' mean?
05:28:55 <quicksilver> ;)
05:29:08 <quicksilver> do (if foo then bar else baz); something else
05:29:21 <noecksit> quicksilver : it can be anything with monads, mainly writing to TChan
05:29:44 <quicksilver> noecksit: I found the phrasing of your question odd :)
05:29:51 <quicksilver> noecksit: you can put one statement after another, yes
05:29:59 <quicksilver> noecksit: ifs and elses are irrelevant to this ability.
05:30:08 <Zao> Your code snippet seems to imply side effects.
05:30:13 <quicksilver> do (anything in here, might be an if statment, might not); somethingelse
05:30:41 <noecksit> quicksilver : ok cool, would i have to have the parenthesis and the apostrophe at the end?
05:31:02 <kiris> Zao: “seems to imply”, hehe
05:31:16 <quicksilver> no, the parentheses were for emphasis.
05:31:24 <quicksilver> the semicolon is the non-layout alternative
05:31:33 <quicksilver> most people use newlines instead
05:32:00 <noecksit> quicksilver : k thanx
05:33:56 <marcot> Good morning.
05:34:00 <marcot> Is code.haskell.org down?
05:34:09 <yitz> quicksilver: i'm confused by non-layout without curly brackets that i've been seeing around here. doesn't the layout rule start with "if the first non-whitespace after the keyword is not '{'..."?
05:34:30 <mauke> there is no non-layout without curlies
05:34:54 <kiris> huh
05:35:02 <mauke> marcot: apparently
05:35:14 <yitz> > let x=1; y=2 in x+y
05:35:16 <lambdabot>  3
05:35:20 <titusg> zeno___:
05:35:26 <yitz> why isn't that a syntax error?
05:35:36 <yitz> > let {x=1; y=2} in x+y
05:35:37 <lambdabot>  3
05:35:45 <opqdonut> yitz: why should it?
05:36:02 <kiris> because mauke just said "no non-layout without curlies"
05:36:10 <mauke> that is layout
05:36:23 <mauke> lern2syllogism
05:36:42 <titusg> _zenon_: "$foo = 5 + "10 Little Piggies"; // $foo is integer (15)" :P
05:37:01 <kiris> just explaining why yitz was confused
05:37:08 * _zenon_ pulling his hair
05:37:22 <yitz> so the ; should be syntax error
05:37:29 <mauke> yitz: why?
05:37:40 <quicksilver> yitz: actually ; is permitted even in non-layou
05:37:40 <mauke> ; is perfectly fine in blocks
05:37:47 <quicksilver> so my explanation to noecksit was a bit confusing.
05:38:12 * yitz looks at the report again...
05:38:36 <mauke> layout is syntactic sugar for { } ;
05:39:27 <kiris> hi Lemmih
05:39:33 <noecksit> so the do someexpr would be equivalent to {someexpr};?
05:39:52 <mauke> no, {someexpr}; is a syntax error
05:39:54 <Lemmih> kiris: Hiya.
05:40:03 <noecksit> or rather "do {someexpr};"
05:40:16 <mauke> still an error
05:40:34 <mauke> unless the ';' belongs to an outer construct
05:41:23 <noecksit> > do { if 2 == 1 then print "foo" else print "boo" };
05:41:24 <lambdabot>  Parse error at ";" (column 51)
05:41:43 <Mitar> is there anything more optimal for squaring a float then ** 2.0 ?
05:41:45 <titusg> _zenon_: Another lovely quote from that page: "If you have a boolean, performing increments on it won't do anything
05:41:46 <titusg> despite it being 1." Thx for the lolz
05:41:51 <noecksit> > do { if 2 == 1 then print "foo" else print "boo";}
05:41:52 <lambdabot>  <IO ()>
05:42:21 <Mitar> ups, i mean faster :-)
05:42:24 <_zenon_> lambdabot would coredump on php
05:42:26 <noecksit> > do { if 2 == 1 then print "foo" else print "boo";} do print "hello"
05:42:26 <lambdabot>  Parse error at "do" (column 52)
05:42:28 <quicksilver> Mitar: ^2 should be faster.
05:42:31 <rwbarton> the php manual pages themselves are nothing compared to the comments. http://se.php.net/manual/en/language.types.string.php#80672
05:42:32 <lambdabot> Title: PHP: Strings - Manual
05:42:39 <_zenon_> Run!!! It's going to dump core!!!!!!
05:42:41 <Mitar> what is the difference?
05:42:52 <noecksit> > do { if 2 == 1 then print "foo" else print "boo";} do {print "hello";}
05:42:53 <lambdabot>  Parse error at "do" (column 52)
05:43:01 <quicksilver> Mitar: ** 2.0 does nasty floating point powr algorithm
05:43:05 <quicksilver> Mitar: which uses exponentials.
05:43:12 <noecksit> > do { if 2 == 1 then print "foo" else print "boo";}; do {print "hello";}
05:43:12 <lambdabot>  Parse error at ";" (column 51)
05:43:17 <ddarius> Um, why not just x*x
05:43:17 <quicksilver> noecksit: you can't just put two do expressions next to each other.
05:43:18 <ddarius> ?
05:43:23 <Mitar> Warning: Defaulting the following constraint(s) to type `Integer'
05:43:31 <_zenon_> map obfuscate phpManpages
05:43:42 <ddarius> _zenon_: == phpManpages
05:43:47 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/8801
05:43:53 <_zenon_> :)
05:43:54 <noecksit> quicksilver : i would like print "hello" to execute regardless of whether the then or else route is taken
05:44:07 <noecksit> > do { if 2 == 1 then print "foo" else print "boo";} do print "hello"
05:44:08 <lambdabot>  Parse error at "do" (column 52)
05:44:26 <noecksit> > do { if 2 == 1 then print "foo" else print "boo";} print "hello"
05:44:26 <lambdabot>  Parse error at "print" (column 52)
05:44:34 <mauke> > do if 2 == 1 then putStr "foo" else putStr "boo"; putStr "hello"
05:44:34 <lambdabot>  <IO ()>
05:44:41 <mauke> > do { if 2 == 1 then putStr "foo" else putStr "boo"; putStr "hello" }
05:44:42 <lambdabot>  <IO ()>
05:44:43 <quicksilver> noecksit: do { if 2==1 then print "foo" else print "boo"; putStr "hello" }
05:44:52 <quicksilver> noecksit: I'm not quite sure I understand the source of your confusion?
05:45:06 <quicksilver> noecksit: care to elaborate on your mental model and I'll try to explain...
05:45:30 <quicksilver> do { a ; b ; c } is just sugar for a >> b >> c
05:45:34 <mauke> http://php.net/manual/en/function.create-function.php
05:45:35 <lambdabot> Title: PHP: create_function - Manual
05:45:36 <quicksilver> do expressions are just expressions.
05:45:50 <noecksit> quicksilver : no think i got it, i just wasnt sure where the parenthesis are supposed to be
05:46:21 <quicksilver> noecksit: you don't need any ;)
05:46:24 <noecksit> *i mean the commas sorry
05:46:30 <quicksilver> semicolons?
05:46:31 <opqdonut> semicolons.
05:46:32 <mauke> semicola
05:46:36 <quicksilver> you don't need any of those either.
05:46:43 <quicksilver> normally you would write :
05:46:50 <quicksilver> if 2==1 then print "foo" else print "boo"
05:46:54 <quicksilver> putStr "hello"
05:47:10 <quicksilver> the only thing you *do* have to be careful of is, don't start a line in a do statement with 'else'
05:47:10 <mauke> putStr $ (if 2 == 1 then "foo" else "boo") ++ "hello"
05:47:20 <quicksilver> because else isn't the beginning of a statement.
05:47:35 <quicksilver> indent it a little so haskell can see it's a continuation line.
05:48:06 <ddarius> quicksilver: Still, it's the programmer being inconsistent in those cases, not Haskell.
05:48:08 <Mitar> ok, (2 :: Int) solves it but it is ugly ...
05:48:47 <noecksit> oh allright so i wouldn't have to have a second do statement in the "print hello" case
05:49:40 <idnar> sem e. coli
05:49:48 <mauke> "do" is for turning a { ; ; } block into an expression constructed from >> and >>=
05:50:02 <quicksilver> noecksit: the purpose of the do block is to let you write several actions in a row without messing with >> and >>= combinators directly.
05:50:04 <kiris> les semicolon
05:50:16 <quicksilver> in this case 2 actions
05:50:20 <ddarius> mauke: I wouldn't recommend that explanation.  { } aren't stand-alone.
05:50:21 <quicksilver> the first given by the if expression
05:50:34 <quicksilver> the second by a simple putstr
05:50:37 <mauke> sesquicolon
05:50:49 <yitz> hmm i see, this is actually quite flaky. A parse error abruptly terminates layout and immediately inserts a '}'.
05:51:12 <yitz> so what I wrote really is layout, mauke is not right.
05:51:31 <mauke> <mauke> that is layout
05:51:46 <yitz> s/not//
05:51:54 <mauke> \o/
05:52:06 <kiris> λ_λ
05:52:12 <mauke> ö_ö
05:52:23 <gwern> man. why are 'lines' and 'words' so very difficult to write in terms of a general 'split' or break function?
05:52:27 * gwern grumble
05:52:45 <kiris> I think they do use break..
05:53:10 <gwern> kiris: not a general break
05:53:14 <mauke> shouldn't be hard
05:53:17 <quicksilver> inconsistent handling of delimeters
05:53:21 <quicksilver> but since you ask, I assume you know that
05:53:22 <gwern> @src break
05:53:22 <lambdabot> break p =  span (not . p)
05:53:27 <gwern> what quicksilver said
05:53:40 <_zenon_> ?ty span
05:53:41 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
05:53:44 <mauke> lines s = removeTrailingNull (split (== '\n') s)
05:53:53 <mauke> words s = filter (not . null) (split isSpace s)
05:53:56 <yitz> also, layout inserts semicolons, but leaves in other semicolons that are already there.
05:54:04 <gwern> quicksilver: yeah. handling the 'drop 1 newline iff..." and other logic kept defeating me
05:54:27 <quicksilver> yitz: yes, that is a critical observation.
05:54:34 <yitz> those two things are confusing imho. best to write either layout or not.
05:55:01 <quicksilver> lambdabot proves their use :P
05:55:03 <zeno___> _zenon_: jeez one of us needs to change nick i keep getting your pings =p
05:55:08 <quicksilver> they are useful in ghci too
05:55:20 <Mitar> ?ty fromDouble
05:55:21 <lambdabot> Not in scope: `fromDouble'
05:55:22 <quicksilver> and occasionally it's nice to line up multiple statements in one line
05:55:23 <gwern> @help quickcheck
05:55:23 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
05:55:24 <kiris> and typing code to people
05:55:28 <mauke> removeTrailingNull y = case y of [""] -> []; x : xs -> x : removeTrailingNull xs; [] -> []
05:55:33 <quicksilver> a $= 2; b $= 2; c $= 2
05:55:48 <_zenon_> zeno__: what? Hahah :) Well, I have had "zenon" for years, but I guess the wirld is big enough for us both ;)
05:56:05 <_zenon_> world*
05:56:10 <kiris> oh, I thought _zenon_ was == zeno___
05:56:11 <quicksilver> is arguably easier to read than zipWith ($=) [a,b,c] [2,2,2]
05:56:22 <ddarius> Mitar: What's wrong with square x = x*x?
05:56:25 <quicksilver> zeno___: the reason it's hard to ping zenon is that he begins with _
05:56:31 <quicksilver> so I don't type the _
05:56:36 <quicksilver> and it completes to you instead.
05:56:42 <quicksilver> (sorry)
05:56:46 <mauke> zipWith ($=) [a,b,c] (repeat 2)
05:56:50 <Mitar> do not know :-)
05:57:01 <quicksilver> mauke: well yes, in a real example they'd presumably be different numbers :)
05:57:04 <Mitar> sometimes using builtin functions is fastre ...
05:57:06 <mauke> :t zipM
05:57:07 <lambdabot> Not in scope: `zipM'
05:57:09 <Mitar> @help
05:57:09 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
05:57:11 <gwern> mauke: how does your 'split' work?
05:57:15 <Mitar> @list
05:57:15 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
05:57:16 <ddarius> gwern: So make a split that is simply a direct generalization of lines.
05:57:27 <Mitar> this link does not work!
05:57:32 <Mitar> timeout
05:57:46 <Mitar> how can i find i function if i know the type?
05:58:01 <mauke> gwern: it returns a list of fields. fields are separated by delimiters. a delimiter is an element for which the predicate is true
05:58:01 <gwern> ddarius: I would, but there's no obvious way I can see. I've played around a lot
05:58:02 <vixey> hoogle sometimes tells you
05:58:11 <yitz> @djinn [a] -> Int
05:58:11 <lambdabot> -- f cannot be realized.
05:58:25 <vixey> length
05:58:29 <ddarius> gwern: Just take the source of lines and abstract out the (implicit) ('\n'==) part.
05:58:32 <mauke> @hoogle [a] -> Int
05:58:33 <lambdabot> Prelude.length :: [a] -> Int
05:58:33 <lambdabot> Data.List.length :: [a] -> Int
05:58:34 <gwern> mauke: so how does it handle a string with no delimieters? delimiters at the front and back?
05:58:39 <yitz> Mitar: ask vixey
05:58:44 <ddarius> gwern: So that lines = split ('\n'==)
05:58:47 <gwern> @src lines
05:58:48 <lambdabot> Source not found. Just what do you think you're doing Dave?
05:58:51 <Mitar> @hoohle Double -> Float
05:58:51 <lambdabot> No matches, try a more general search
05:58:54 <mauke> gwern: [x], ["", x, ""]
05:58:56 <quicksilver> Mitar: realToFrac
05:58:59 <Mitar> :-)
05:59:11 <Mitar> there is no fromDouble?
05:59:12 <quicksilver> Mitar: there are two main conversion functions, fromIntegral and realToFrac
05:59:12 <_zenon_> kiris: Nope, I am _zenon_  would like to be zenon, but, yeah, nick's taken
05:59:17 <gwern> > lines "x"
05:59:18 <lambdabot>  ["x"]
05:59:19 <quicksilver> there is no need for fromDouble
05:59:24 <quicksilver> realToFrac is more general.
05:59:28 <gwern> mauke: no preceding "" there
05:59:38 <gwern> > lines "\nx"
05:59:39 <lambdabot>  ["","x"]
05:59:45 <mauke> gwern: yes
05:59:52 <mauke> no delimiters, no empty fields
05:59:58 <gwern> we can't just strip preceeding or trailing ""s either...
06:00:11 <mauke> what's the problem?
06:00:19 <Mitar> but is not Float also a real?
06:00:47 <yitz> Mitar: yes, so it works the other way too
06:00:51 <gwern> well, a stripTrailingNull will mess up at somepoint. eg. "foo\n\n\n" - how many ""s does that make?
06:01:15 <mauke> split gives you ["foo", "", "", ""]
06:01:24 <kiris> @hoogle a -> (a -> a -> b) -> b
06:01:25 <lambdabot> Prelude.flip :: (a -> b -> c) -> b -> a -> c
06:01:25 <lambdabot> Data.Function.flip :: (a -> b -> c) -> b -> a -> c
06:01:25 <lambdabot> Data.Function.on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
06:01:34 <mauke> stripTrailingNull will remove the last one, giving you ["foo", "", ""]
06:01:41 <vixey> :t join
06:01:42 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
06:01:42 <ddarius> kiris: flip join
06:01:55 <ddarius> :t flip join
06:01:56 <lambdabot> forall a b. b -> (b -> b -> a) -> a
06:02:07 <vincenz> Cale: ping
06:02:29 <kiris> =o
06:03:03 <kiris> > let square = join (*) in square 666
06:03:04 <lambdabot>  443556
06:03:32 <kiris> Mitar: better than x*x? :p
06:03:45 <Mitar> :-))
06:05:19 <kiris> I find that a bit confusing
06:05:24 <kiris> :t flip $ flip join
06:05:24 <lambdabot> forall a a1. (a -> a -> a1) -> a -> a1
06:05:25 <kiris> :t join
06:05:26 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
06:05:38 <kiris> oh, it's a nicer type in λb than in my ghci
06:05:38 <mauke> :t flip id
06:05:39 <lambdabot> forall b c. b -> (b -> c) -> c
06:05:42 <vixey> :t flip id
06:05:43 <lambdabot> forall b c. b -> (b -> c) -> c
06:05:45 <kiris> doesn't show the kind in my ghci
06:05:45 <vixey> haha mauke
06:05:56 <gwern> mauke: did you write 'split' somewhere I didn't se? I'd like to quickcheck your version against lines- I'm still not convinced you're right
06:05:59 <mauke> oǝɹǝʇs
06:06:13 <kiris> killed the video star?
06:06:14 <mauke> gwern: no, I just have the semantics in my head
06:06:33 <mauke> let's see if I can do it in haskell
06:06:52 <gwern> because I could've sworn I wrote a split like that, and tried a droptrailingwhitespace analogue, and still ran into subtle differences from lines
06:07:47 <vincenz> @tell Cale Please get me your public ssh key
06:07:47 <lambdabot> Consider it noted.
06:09:44 <ddarius> > let split p [] = []; split p s = let (l,s') = break p s in l:case s' of [] -> []; (_:s'') -> split p s'' in split ('\n'==) "foo\n\bar\n\n\n"
06:09:45 <lambdabot>  ["foo","\bar","",""]
06:09:59 <ddarius> > let split p [] = []; split p s = let (l,s') = break p s in l:case s' of [] -> []; (_:s'') -> split p s'' in split isSpace "foo\n\bar\n\n\n"
06:09:59 <lambdabot> Unbalanced parentheses
06:10:09 <hpaste>  gwern pasted "notes from lines exploration" at http://hpaste.org/8802
06:10:26 <ddarius> wtf?
06:10:38 <kiris> haha, crazy indentation. #1 reason not to use tabs?
06:11:04 <ddarius> > let split p [] = []; split p s = let (l,s') = break p s in l:case s' of [] -> []; (_:s'') -> split p s'' in split (isSpace) "foo\n\bar\n\n\n"
06:11:04 <lambdabot> Unbalanced parentheses
06:11:19 <ddarius> lambdabot's on crack
06:11:35 <_zenon_> ddarius: Expensive crack?
06:11:38 <mauke> I blame '
06:11:56 <ddarius> > let split p [] = []; split p s = let (l,s') = break p s in l:case s' of [] -> []; (_:s'') -> split p s'' in split isSpace "foo\n\bar\n\n\n" -- '
06:11:57 <lambdabot> Unbalanced parentheses
06:12:01 <ddarius> > let split p [] = []; split p s = let (l,s') = break p s in l:case s' of [] -> []; (_:s'') -> split p s'' in split isSpace "foo\n\bar\n\n\n" -- ''
06:12:01 <lambdabot> Unbalanced parentheses
06:12:20 <kiris> > let split p [] = []; split p s = let (l,s') = break p s in l:case s' of [] -> []; (_:s'') -> split p s'' in split (isSpace) "foo\nbar\n\n\n"
06:12:20 <lambdabot> Unbalanced parentheses
06:12:24 <ddarius> > let split p [] = []; split p s = let (l,s' ) = break p s in l:case s' of [] -> []; (_:s'' ) -> split p s'' in split isSpace "foo\n\bar\n\n\n"
06:12:24 <lambdabot> Unbalanced parentheses
06:13:01 <rwbarton>  > let split p [] = []; split p s = let (l,s1) = break p s in l:case s1 of [] -> []; (_:s2) -> split p s2 in split (isSpace) "foo\nbar\n\n\n"
06:13:31 <ddarius> > let split p [] = []; split p s = let (l,s1) = break p s in l:case s1 of [] -> []; (_:s2) -> split p s2 in split isSpace "foo\n\bar\n\n\n"
06:13:33 <lambdabot>  ["foo","\bar","",""]
06:13:55 <ddarius> > let split p [] = []; split p s = let (l,s1) = break p s in l:case s1 of [] -> []; (_:s2) -> split p s2 in split (':'==) "foo:bar:baz:""
06:13:55 <lambdabot>  Improperly terminated string at """ (column 135)
06:13:57 <ddarius> > let split p [] = []; split p s = let (l,s1) = break p s in l:case s1 of [] -> []; (_:s2) -> split p s2 in split (':'==) "foo:bar:baz:"
06:13:58 <lambdabot>  ["foo","bar","baz"]
06:14:19 <ddarius> Voila.  A useful generalization of lines.
06:15:17 <xkb_> I almost finished my noobish haskell program, however one problem remains (http://pastebin.com/d1901143f)
06:15:24 <xkb_> I think due to laziness
06:15:34 <kiris> :(((
06:15:42 <kiris> > let split p [] = []; split p s = let (l,s1) = break p s in l:case s1 of [] -> []; (_:s2) -> split p s2 in split (':'==) ":::foo:bar:baz:"
06:15:43 <lambdabot>  ["","","","foo","bar","baz"]
06:15:48 <rwbarton> I guess words is  filter (/= []) . split isSpace  then?
06:15:49 <_Dae_> xkb_: you're familiar with hpaste.org?
06:15:50 <gwern> hm. so far quickcheck hasn't found any counterexamples when combinding ddarius's first split with mauke's stuff
06:16:00 <xkb_> _Dae_: not as of now
06:16:03 <vixey> I doubt lazyness is the problem...
06:16:04 <xkb_> hence the pastebin
06:16:09 <vixey> but I don't know hwat the problem is
06:16:09 <kiris> > lines "\n\n\nfoo\nbar\nbaz\n"
06:16:10 <lambdabot>  ["","","","foo","bar","baz"]
06:16:16 <gwern> rwbarton: let's find out!
06:16:27 <xkb_> problem is that the runUpdate function shows the tags list as empty
06:16:43 <_Dae_> xkb_: www.hpaste.org -> I find it easier to use than pastebin, and it's integrated iwth #haskell
06:16:43 <xkb_> unless I force a print of tags on the higlighted line
06:16:48 <kiris> > words "\n\n\nfoo\nbar\nbaz\n"
06:16:48 <lambdabot>  ["foo","bar","baz"]
06:16:52 <kiris> mmk
06:17:03 <vixey> xkb_: runUpdate takes a parameter
06:17:19 <xkb_> should rename that to portfolio
06:18:37 <_Dae_> xkb_: Looks like a laziness problem. You're closing the connection before the lines are evaluated
06:18:50 <_Dae_> xkb_: But I could be wrong
06:19:00 <xkb_> _Dae_: I had the same idea
06:19:11 <xkb_> now I was wondering how I should force evaluation
06:20:09 <rwbarton> xkb_: maybe you can just use readFile?
06:20:12 <quicksilver> hGetContents considered harmful.
06:20:19 <Baughn> xkb_: Control.Parallel.Strategies.rnf is probably safest
06:20:23 <gwern> rwbarton: well, it's 500 tests in and no counterexamples. thus far thus good, I suppose
06:20:38 * gwern feels sometimes like I'm the only person here who still likes lazy IO
06:20:47 <xkb_> ill check out readFile
06:20:51 <rwbarton> gwern: they're probably all strings like "\175\283" :)
06:20:54 <Baughn> xkb_: (For forcing evaluation. Reading it in strictly could be even better, or not; forcing evaluation /after/ applying filters to it has at least that done lazily)
06:21:05 <kiris> :t (>>>)
06:21:06 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
06:21:07 <quicksilver> gwern: it's a good thing. It shouldn't be default and it's poorly documented.
06:21:08 <gwern> hm. I wonder if there are any efficiency differences between the prelude versions and these?
06:21:27 <_zenon_> kiris: How's the Word-poster going?
06:21:29 <quicksilver> gwern: if I had a dollar for every newbie who has written a program which would work correct if the prelude didn't have broken IO constructs
06:21:32 <quicksilver> I'd be rich!
06:22:03 <Baughn> If you had a hundred thousand dollars for each, maybe..
06:22:11 <Baughn> Or an oil drum for each. They're getting rather dear.
06:22:27 <kiris> _zenon_: I'm thinking about a way to place words without overlapping but not slow as hell like Wordle
06:22:48 <_Dae_> Baughn: Has anyone who's writing haskell not made that mistake?
06:23:14 <Baughn> _Dae_: Even if they had, there aren't enough to make him rich at a dollar each
06:23:31 <xkb_> ok, that was more like what I expected
06:23:32 <Baughn> And, yes. I never made that mistake.. well, haven't made it /yet/. :P
06:23:45 <Mitar> http://code.haskell.org/vector-space/doc/html/ << does not work?
06:23:49 <xkb_> so what is the subltle difference between hgetcontents and readFile?
06:23:54 <kiris> :t (<<)
06:23:55 <lambdabot> Not in scope: `<<'
06:24:14 <vixey> @let modusPonens = ($)
06:24:16 <lambdabot> Defined.
06:24:23 <Baughn> xkb_: If you're talking the non-strict/non-bytestring versions, there isn'T one. They're both lazy
06:24:49 <Baughn> Although with hGetContents you risk messing up things by using the handle after calling it
06:24:55 <_Dae_> @source readFile
06:24:56 <lambdabot> readFile not available
06:25:04 <mauke> @src readFile
06:25:05 <lambdabot> readFile name = openFile name ReadMode >>= hGetContents
06:25:17 <xkb_> ah:)
06:25:32 <rwbarton> xkb_: you can also fix your program by just not closing the file handle
06:25:36 <quicksilver> mauke: is that really true? I thought there was a bracket around it?
06:25:51 <Baughn> @src often takes shortcuts
06:25:52 <lambdabot> Source not found.
06:26:08 <mauke> quicksilver: no
06:26:17 <mauke> that's literally the source in System.IO
06:27:00 <xkb_> what's the first refactoring an experienced haskell programmer would take, to improve my program?
06:27:06 <xkb_> dangerous question :)
06:27:11 <gwern> huh. looks like the redefined words/lines have a modest speed advantaged
06:27:13 <kiris> which?
06:27:29 <kiris> gwern: really? how much?
06:28:25 <gwern> kiris: well, catting in the ebooks of Frank and Brian Herbert and doing interact (unlines . lines), prelude takes about ~7.6s, and the redefined ones seem to be more like 7.2
06:28:59 <gwern> (obviously unlines isn't rewritten)
06:29:33 <Baughn> Both on -O2? Averaged over several runs?
06:29:43 <kiris> 400ms isn't bad at all if say that function is used lots of times over
06:29:54 <gwern> Baughn: yes
06:30:20 <gwern> although I'm not sure 30MB of text is enough, so I'm gonna retry with the full gigs contents of my doc/ folder
06:31:16 <yitz> There is a lot of room for improvement on Prelude functions. ndmitchell has done some work on that. I say, let's start with sum and product.
06:31:49 <_Dae_> yitz: I thought sum was just written as a foldr?
06:32:01 <opqdonut> _Dae_: should really be a foldr'
06:32:02 <_Dae_> @src sum
06:32:02 <lambdabot> sum = foldl (+) 0
06:32:09 <yitz> _Dae_:  when it should be a foldl'
06:32:28 <_Dae_> Right......
06:32:28 <opqdonut> yeah, l'
06:32:32 <opqdonut> what was i thinking
06:32:40 <_Dae_> why, btw?
06:32:47 <_Dae_> I'm just curious here
06:33:16 <yitz> _Dae_: prelude sum builds up thunks on a big list. it can blow the stack.
06:33:19 <opqdonut> yeah
06:33:27 <opqdonut> try "sum [1..1000000]" in ghci
06:33:39 <yitz> and it's certainly much slower.
06:33:40 <_Dae_> > sum [1..10000000000]
06:33:40 <opqdonut> then try "foldl' (+) 0 [1..1000000]"
06:33:42 <lambdabot>  Tried to use too much memory
06:34:03 <_Dae_> > foldl1' (+) [1..10000000000]
06:34:09 <lambdabot>  Exception: Time limit exceeded
06:34:10 <kiris> @src foldl
06:34:10 <lambdabot> foldl f z []     = z
06:34:10 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
06:34:38 <_Dae_> but I see the point....
06:34:38 * gwern sets up a run of 20 calls. I'll take a nap while they run...
06:35:13 <_zenon_> hahaha
06:35:18 <_zenon_> I realized it too late
06:35:27 <_zenon_> but the phpManualPages are fixpoint
06:35:40 <_zenon_> obfuscate phpManualPages == phpManualPages
06:35:41 <opqdonut> huh?
06:35:45 <opqdonut> ah
06:35:50 <_zenon_> :D
06:35:58 <mar77a> off topic q: is there software to turn off the psu fan(s)?
06:36:23 <yitz> @quote php
06:36:24 <lambdabot> dons says: keroppi: i was thinking of a similar thing recently, on a bus travelling between the hotel and the google summer of code summit, sitting next to guys from apache, python, freebsd, netbsd,
06:36:24 <lambdabot> perl, gentoo... the end of open source was a drunk driver away, with only php goons left to run the show
06:36:30 <rwbarton> just to play devil's advocate for a moment... sum and foldl' (+) 0 can have different semantics for an arbitrary Num instance
06:37:34 <yitz> rwbarton: absolutely. but should the default implementation work only for rare esoteric Num instances, instead of the ones we use every day?
06:37:35 <rwbarton> imagine data RealOrInfinity = Real Double | Infinity; instance Num RealOrInfinity where _ + Infinity = Infinity; ...; sum [undefined, undefined, Infinity]
06:37:55 <yitz> rwbarton: instance Num ... where (+) = (++)
06:38:04 <Toxaris> @src sum
06:38:04 <lambdabot> sum = foldl (+) 0
06:38:08 <tromp> > 1/0
06:38:09 <mauke> yitz: I'd like to see (-) for that
06:38:16 <lambdabot>  Infinity
06:38:28 <yitz> ha
06:38:31 <tromp> > 1/0 - 1/0
06:38:32 <lambdabot>  NaN
06:38:43 <tromp> > -1/0
06:38:44 <lambdabot>  -Infinity
06:38:47 <yitz> @quote php
06:38:47 <lambdabot> int-e says: PHP is a programming language like penguins are birds. And people try to make it fly.
06:39:01 <yitz> @quote php
06:39:01 <lambdabot> qwe1234 says: i'm still waiting for the list of differences between lisp and php that matter.
06:39:27 <Toxaris> > foldl f [x, y, z]
06:39:27 <lambdabot>        add an instance declaration for (SimpleReflect.FromExpr [Expr])
06:39:29 <mauke> penguins are the only fish that can fly
06:39:47 <kiris> dogs can't look up
06:39:47 <dmwit> > foldl f a [x, y, z]
06:39:48 <lambdabot>  f (f (f a x) y) z
06:39:53 <lilachaze> @hoogle [a -> a] -> a -> a
06:39:53 <lambdabot> No matches, try a more general search
06:39:56 <dmwit> Toxaris: Needs a base-case. ;-)
06:40:14 <dmwit> :t sequence :: [a -> a] -> a -> [a]
06:40:15 <lambdabot> forall a. [a -> a] -> a -> [a]
06:40:19 <dmwit> lilachaze: ?
06:40:20 <Toxaris> dmwit: what a helpful error message :)
06:40:21 <lilachaze> @type foldl1 (.)
06:40:22 <lambdabot> forall a. [a -> a] -> a -> a
06:40:23 <dmwit> lilachaze: Or this?
06:40:28 <dmwit> lilachaze: yeah,
06:40:29 <dmwit> fold
06:40:42 <_Dae_> mar77a: yes
06:40:56 <mar77a> nice
06:41:03 <mar77a> any guidelines or directives so i can google
06:41:03 <Toxaris> these are very esoteric data types, which opt for non-strictness in the second argument to (+)
06:41:19 <rwbarton> maybe the thing to do is define sum' = foldl' (+) 0 and then specialize sum to sum' at common types
06:41:38 <_Dae_> mar77a: but your psu and motherboard must support it..... Windows or Linux?
06:41:43 <mar77a> windows
06:42:08 <_Dae_> mar77a: speedfan
06:42:16 <mar77a> thanks
06:44:00 <Toxaris> the RTS compiled by ghc into my program outputs error messages like "pts: src/PTS/Core.hs:(40,15)-(55,1): Non-exhaustive patterns in case". Can I make it output the full path to Core.hs instead?
06:44:23 <Toxaris> (then my editor would automatically open Core.hs)
06:46:58 <mar77a> but _Dae_ , how can i change the speed?
06:47:12 <mar77a> all i see is a label that reads "Fan1:2312 RPM"
06:50:29 <hpaste>  xkb pasted "Portfolio printer" at http://hpaste.org/8803
07:04:23 <Eelis> parsec question: the result of    parse (notFollowedBy (char 'x') >> char 'a') "" "b"    is "unexpected 'b', expecting 'x' or 'a'". since 'x' is explicitly /not/ wanted, why does it show up in the expected list? is this a bug?
07:05:00 <mauke> notFollowedBy is completely broken IMHO
07:05:30 <Eelis> i tend to agree. i wrote my own replacement which fixes other problems, but it doesn't fix this one
07:05:32 <quicksilver> notFollowedBy probably doesn't mean what you think it means.
07:05:40 <Eelis> quicksilver: what does it mean?
07:05:41 <ndmitchell> Eelis: if you look at the implementation of notFollowedBy, you'll see why
07:05:57 <quicksilver> I think means "zero-width lookahead assertion 'x' is not here)
07:06:01 <quicksilver> I'm not 100% sure
07:06:04 <ndmitchell> try (do{ c <- p; unexpected (show [c]) } <|> return ())
07:06:06 <quicksilver> what langauge did you want to parse?
07:06:26 <Eelis> ndmitchell: ndmitchell i can see the implementation reason for the message, but do you not agree that it is an undesireable one?
07:07:02 <ndmitchell> Eelis: i've never used notFollowedBy, I think its designed to make error messages better, rather than to parse things
07:07:33 <ndmitchell> but yeah, the error message on failure of notFollowedBy is rather sucky!
07:07:46 <Eelis> quicksilver: i'm parsing a tiny subset of natural language for making textual edits (like "erase after second 2 until before 5")
07:08:04 <ndmitchell> Eelis: why would you want notFollowedBy then?
07:09:01 <ndmitchell> and just wondering if erase 2..5 isn't a much more obvious and explicit syntax for that
07:09:47 <Eelis> ndmitchell: because there are places in the grammar where certain keywords should be errored on, like in verbatim strings where the keyword is not expected to follow
07:10:08 <litb> he wants it like someone speaks to the system
07:10:12 <ndmitchell> Eelis: concrete example of the error condition?
07:10:36 <ndmitchell> litb: i understand the idea behind natural language, i've just never seen it not be a fairly bad idea
07:10:39 <Eelis> ndmitchell: it was only one example, see the series of tests near the bottom of http://www.xs4all.nl/~weegen/eelis/geordi/_darcs/pristine/src/EditCmds.hs
07:10:40 <lambdabot> http://tinyurl.com/5lmm9j
07:10:45 <litb> oh
07:11:27 <Eelis> ndmitchell: a concrete example is "move after bla", i want that to say "unexpected 'after'", because "after" makes no sense there
07:12:15 <ndmitchell> Eelis: surely the grammar is just something like cmd = move place, and the after errors out automatically?
07:12:48 <Eelis> ndmitchell: no, because after is parsed as a verbatim string, so i get something like "String 'after' does not occur"
07:13:26 <ndmitchell> Eelis: so your grammar is move <any-single-string>, and you want to exclude after from <any-single-string> ?
07:13:46 <Eelis> ndmitchell: the grammar is listed at the bottom of the file i linked to
07:14:36 <Eelis> ndmitchell: but essentially yes
07:14:42 <quicksilver> so you want to disallow appearances of keywords in incorrect places?
07:14:45 <vincenz> ndmitchell: you have internet!
07:14:46 <Eelis> quicksilver: yes
07:14:49 <litb> i wonder whether it is contextfree?
07:14:53 <mauke> lexer
07:14:58 <ndmitchell> Eelis: then write nonKeyword and make that verbatim
07:14:59 <quicksilver> normally you do that with two-stage parsing
07:15:04 <quicksilver> and you call the first stage a lexer
07:15:09 <ndmitchell> vincenz: yes, until Saturday morning, 10am
07:15:27 <Eelis> ndmitchell: how would i write it?
07:16:06 <Eelis> quicksilver: making the whole thing twice as complex just to improve one particular error does not seem like an attractive solution :)
07:16:06 <ndmitchell> Eelis: do xs <- many1 char; if xs `elem` keywords then fail "Expected verbatim but got a keyword" else return xs
07:16:38 <quicksilver> a separate lexing stage is hardly making the whole thing twice as complex
07:17:00 <Eelis> ndmitchell: hm, that could work. thanks!
07:17:01 <quicksilver> it's just one simple function to classify incoming strings as identifiers or keywords.
07:17:24 <ndmitchell> quicksilver: but it does make the parsec bit more complex, i can see his point, parsec isn't great in conjunction with a lexer
07:17:24 <quicksilver> in fact it's much liek what ndm wrote from a different angle
07:17:43 * ndmitchell intends to write a parser combinator library on the train this weekend, to fix all these issues
07:17:52 <quicksilver> do xs <- many1 char; if x `elem` keywords then return (Keyword x) else return (Literal x)
07:18:04 <quicksilver> how does it make parsec more complex?
07:18:09 <quicksilver> you just change the token type from Char
07:18:19 <ndmitchell> quicksilver: i've always found it strated to get harder
07:18:21 <quicksilver> about half the parsec parsers I've written have had non-Char tokens.
07:18:49 <ndmitchell> i guess i'm the more traditional lexer :: String -> [Token], then parse the token
07:19:07 <quicksilver> all lexers are is parsers :)
07:19:12 <quicksilver> and you can layer parsers if you want.
07:19:23 <quicksilver> it's only a conventional different of focus.
07:19:27 <ndmitchell> if you layer the parsers, it has got tricky in the past
07:19:37 <Philippa> ndmitchell: parsec could probably use a little more help in generating primitive token parsers, but otherwise it's been easy IME - just tedious
07:19:38 <litb> lexers are parsers without a stack i think
07:19:38 <ndmitchell> your approach sounds easier, i may try it in the future
07:19:51 <quicksilver> most of the time I end up needing things like quoted strings and then you're really in for pain if you don't have a lexing stage.
07:19:55 <Philippa> my main project actually uses a parsec-based lexer and a parsec-based parser, for example
07:20:09 <mauke> quicksilver: what's hard about quoted strings?
07:20:22 <ndmitchell> Philippa: my parser will be based on an entirely different concept from tradiditional parsers, so is more an experiment
07:20:29 <quicksilver> mauke: the non-locality of looking for the closing "
07:20:34 <quicksilver> mauke: forcing you down to Char level
07:20:40 <Philippa> ndmitchell: fair enough. If it's the same one you've been talking about a while, look into making it incremental too?
07:20:41 <quicksilver> when you don't really want to work at Char level the whole time.
07:21:11 * quicksilver has also read some of ndm's parsing notes and looks forward to results.
07:21:23 <Philippa> folding lexer into parser really stinks any time the lexing gets complicated - maximal munch lexing is a PITA to implement fused in, for example
07:21:38 <mauke> qstring = char '"' *> contents <* char '"' where contents = many ((char '\\' >> anyChar) <|> noneOf "\"\\")
07:21:57 <ndmitchell> Philippa: yeah, that one, i'm looking at making it slow (i.e. unoptimised) but getting the API out there so I can get feedback on it
07:22:08 <ndmitchell> and definately incremental
07:23:28 <vincenz> ndmitchell: doh
07:25:30 <ndmitchell> vincenz: yeah, i have to be in York monday morning, hence travelling and staying with my Gran at the weekend
07:25:43 <ndmitchell> i'll have internet again by Tuesday :)
07:25:52 <ndmitchell> so pretty much missing exactly the ICFP contest
07:29:06 <Philippa> ndmitchell: when you say slow, are you going to ignore potential asymptotic issues imposed by the supported grammars for now as well?
07:29:19 <Philippa> though I figure you've plenty of people to talk to about making it go fast again afterwards!
07:29:21 <ndmitchell> Philippa: yes
07:29:45 <ndmitchell> Philippa: i have the knowledge to make it O(n) in all circumstances
07:29:53 <ndmitchell> (where n = length of thing to parse)
07:30:09 <ndmitchell> I even have asymatotic improvements to maximal munch lexing :)
07:30:33 <ndmitchell> but a fast useless parser is still a useless parser
07:33:13 <monochrom> <3 #haskell
07:44:49 <xkb_> any tips on improving http://hpaste.org/8803#a0 to make it more "functional"?
07:45:28 <mauke> er
07:45:33 <xkb_> :)
07:45:42 <xkb_> twas so quiet in here :)
07:45:42 <mauke> isPortfolioItem and isPortfolioItemCheck are the same function
07:45:56 <litb> hmm
07:45:58 <xkb_> hmm yeah that was still in there
07:46:01 <mauke> convertDirectoryToPortfolio/createPortfolio
07:46:06 <xkb_> from the last refactoring :)
07:46:26 <litb> how is the thing called where you prove algorithms with haskell?
07:46:29 <mauke> you don't need exitWith there
07:46:32 <litb> ive seen guys in here who do that
07:46:40 <mauke> == True is redundant
07:47:34 <EvilTerran> litb, er, program derivation? equational reasoning?
07:47:38 <Zao> > (not . (==) '#' . head) []
07:47:41 <lambdabot>  Exception: Prelude.head: empty list
07:47:51 <quicksilver> quickcheck  litb maybe means.
07:47:57 <EvilTerran> (not . (==) '#' . head) = (/='#').head
07:48:09 <xkb_> ah I tried !=
07:48:20 <mauke> why is doesNotStartWithComment a separate function?
07:48:53 <ndmitchell> > not $ "#" `isPrefixOf`"test"
07:48:53 <lambdabot>  True
07:48:55 <mauke> return (filter (not . ("#" `isPrefixOf`)) tags)
07:48:56 <ndmitchell> > not $ "#" `isPrefixOf`"#test"
07:48:57 <lambdabot>  False
07:49:15 <quicksilver> xkb_: in getTags, a nicer way to write inp <- readFile tagsFile ; let tags = lines inp is just to do "tags <- liftM lines (readFile tagsFile)
07:49:26 <quicksilver> xkb_: liftM lets you elevate a pure function (lines) "into the monad"
07:49:39 <quicksilver> xkb_: actually personally I would write tags <- lines <$> readFile tagsFile
07:49:46 <mauke> getTags = liftM (filter (not . ("#" `isPrefixOf`)) . lines) . readFile
07:49:46 <quicksilver> xkb_: <$> is just an infix notation for liftM.
07:50:06 <EvilTerran> yeah, it's probably better to use ("#"`isPrefixOf`) than (=='#').head
07:50:13 <dmwit> xkb_: do { y <- m; return y } === m
07:50:16 <xkb_> quicksilver: thanks
07:50:39 <EvilTerran> yay monad laws
07:51:03 <dmwit> I would also suggest possibly
07:51:17 <EvilTerran> (do y <- m; return y) = (m >>= \y -> return y) = (m >>= return) = m -- to flesh that out a bit
07:51:27 <xkb_> <$> is in a library I guess/
07:51:31 <dmwit> createPortfolio someDir = liftM2 (Portfolio someDir) (getAllImages ...) (getTags ...)
07:51:40 <dmwit> xkb_: Control.Applicative
07:51:51 <mauke> liftM is in Control.Monad
07:52:05 <dmwit> :t (<$>)
07:52:05 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:52:29 <dmwit> :t (<*>)
07:52:30 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
07:52:47 <ndmitchell> @hoogle <$>
07:52:47 <lambdabot> Control.Applicative.(<$>) :: Functor f => (a -> b) -> f a -> f b
07:52:48 <dmwit> So you could also maybe do
07:52:54 <mauke> :t loeb
07:52:54 <lambdabot> Not in scope: `loeb'
07:53:06 <dmwit> createPortfolio someDir = Portfolio someDir <$> getAllImages ... <*> getTags ...
07:53:12 <dmwit> Though I'm not sure I did that right. =P
07:53:41 <kristo> I'm compiling gtk2hs-0.9.13 whith ghc-6.8.3 and get this error: Failed to load interface for `System.Glib.UTFString': ???
07:54:02 <Mitar> does anybody have any example code which uses VectorSpace library?
07:54:11 <Mitar> documentation is not really useful
07:54:22 <byorgey> dmwit: liftMn f a b c ...  === f <$> a <*> b <*> c ...
07:54:43 <quicksilver> Mitar: I'd never even heard of it until you mentioned it teaerlier
07:54:45 <dmwit> xkb_: On a slightly different note, code like (filename ++ "\\somethingtoappend") makes me cringe.
07:55:03 <ndmitchell> > "filename" </> "path"
07:55:03 <Mitar> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/vector-space-0.2.0
07:55:04 <lambdabot>   Not in scope: `</>'
07:55:04 <xkb_> dmwit: due to the concatenation?
07:55:04 <dmwit> xkb_: System.FilePath has functions for joining paths, and you should use them so that other platforms don't barf on the floor.
07:55:06 <lambdabot> Title: HackageDB: vector-space-0.2.0, http://tinyurl.com/6y6hv5
07:55:15 <Mitar> or is there any better?
07:55:22 <quicksilver> Mitar: what are you trying to do?
07:55:24 <ndmitchell> who is the lambdabot maintainer?
07:55:27 <dmwit> xkb_: No, because of the hard-coded '\\'.
07:55:36 <quicksilver> ndmitchell: mostly Cale these days.
07:55:39 <xkb_> dmwit: check, changing that to FilePath
07:55:47 <Mitar> rotate and translate vectors in 3D space
07:56:05 <ndmitchell> Cale: System.FilePath is not in the lambdabot prompt, it seem?
07:56:09 <dmwit> byorgey: That's pretty nice. =)
07:56:49 <byorgey> dmwit: yup. =)
07:57:29 <quicksilver> Mitar: I use openGL for that:) Or I do it by hand.
07:58:00 <quicksilver> Mitar: VectorSpace doesn't appear to have a convenient APi to matrices.
07:58:19 <Mitar> that's why i am asking if there is some general thing
07:58:34 <quicksilver> Mitar: maybe blas is more useful.
07:58:34 <Mitar> so i would not discover warm water ...
07:58:46 <quicksilver> although it's fairly heavyweight.
08:01:58 <edwardk> weird i was checking out google lively and it thinks i'm a spyware application
08:03:07 <quicksilver> 85% of browsers who uploaded category theory packages are spyware.
08:04:37 <Mitar> yes, they are getting more and more nasty every day
08:05:55 <xkb_> Ok thanks for all the pointers ppl! Really learned alot today!
08:09:19 <Giblaz> heyo
08:09:39 <Giblaz> I've been reading the book Algorithms: A Functional Programming Approach
08:10:01 <Giblaz> and it has a pretty good tutorial to haskell
08:10:11 <Giblaz> Anyone know of any other good books on Haskell?
08:10:29 <Giblaz> all of the online tutorials seems to jump around their subject areas and never explain anything in detail
08:10:59 <xkb_> I really liked The Haskell School of Expression: Learning Functional Programming through Multimedia
08:11:04 <mapreduce> Giblaz: Real world Haskell, in draft form, and the Haskell wikibook both seem better than average.
08:11:07 <dmwit> YAHT, The Gentle Introduction, Real-World Haskell are all recommended
08:11:21 <quicksilver> Giblaz: Hutton's book is recommended by many.
08:11:24 <quicksilver> (I haven't read it)
08:11:27 <Giblaz>  awesome, thanks guys
08:11:35 <Giblaz> I'll check out Huttons book
08:11:55 <Giblaz> I'm only learning Haskell since I want to have some functional programming experience
08:12:07 <mapreduce> Giblaz: You might also like SICP
08:12:07 <Giblaz> it lets me think differently :)
08:12:14 <quicksilver> you'll never look back :P
08:12:14 <Giblaz> SICP/
08:12:19 <Giblaz> ahahah
08:12:24 <Giblaz> Haskell is great
08:12:27 <Giblaz> I like it so far
08:12:31 <mapreduce> The barrier to entry for SICP is googling for what SICP means.
08:13:18 <Giblaz> Isn't that the book that's used in MITs CS intro course?
08:14:21 <dolio> Is it still? I thought they were switching to Python.
08:14:26 <mapreduce> Yes, or at least it was.
08:14:38 <mapreduce> dolio: I think they switched to Python but kept the same material.
08:14:44 <mapreduce> I never saw a Python edition though.
08:14:49 <dolio> Ah.
08:15:04 <dolio> The videos of the lectures by Sussman and Abelson are pretty good, too.
08:15:11 <mapreduce> Excellent, yes.
08:15:30 <dolio> If only for the ridiculous people in the course (but also for the content).
08:16:20 <mapreduce> Yeah, oh how frustrating that blonde/grey guy at the front was in questions.
08:16:31 <mapreduce> s/blonde/blond/
08:16:35 <dolio> And Sussman dressing up in full wizard regalia.
08:17:00 <mapreduce> I saw Stallman do that recently.
08:17:57 <mapreduce> I like how when Sussman and Steele had a paper together, Steele was "Research Fellow" and Sussman was "Jolly Good Fellow" or something.
08:22:43 <hpaste>  beelsebob pasted "quickcheck problem" at http://hpaste.org/8805
08:23:03 <BeelsebobWork> I'm having some problems with writing a QC Arbitrary instance
08:23:13 <BeelsebobWork> I need some lists within my ADT to always be non-empty
08:23:29 <BeelsebobWork> but I don't see any way to do that with the combinators QC provides
08:23:35 <ADEpt> it's easy
08:24:10 <mapreduce> Isn't there a guard feature?
08:24:10 <BeelsebobWork> oh?
08:24:24 <BeelsebobWork> only when you're writing the properties
08:24:25 <rwbarton> well, you could always write arbitrary:arbitrary
08:24:26 <ADEpt> ne gen = sized $ \n -> do res <- gen; if not (null res) then return res else resize (n+1) (ne gen)
08:24:34 <BeelsebobWork> rwbarton: yeh, that's really really obvious
08:24:47 <ADEpt> BeelsebobWork: and use "ne arbitrary" wherever necessary
08:24:51 <BeelsebobWork> well, liftM2 (:) arbitrary arbitrary
08:25:06 <rwbarton> ah yes
08:25:09 <BeelsebobWork> ADEpt: okay, yeh, that's pretty obvious
08:26:00 <rwbarton> it seems like there should be some kind of guard feature for arbitrary though
08:29:00 <carl> say ive got something like input <- getContents and i want to parse the input that comes in, then i do something like (take 4 input) and do something with the result, now lets say i want the next 4 things, whats the standard way to the next 4 bytes i mean i cant exactly say: input = drop 4 input
08:29:55 <dolio> let (stuff, rest) = splitAt 4 input in ... take 4 rest ...
08:30:44 <PeakerWork> is there anything like Twisted for Haskell? Do you think its a good idea to create one?
08:31:05 <monochrom> What is Twisted?
08:31:23 <monochrom> I think I heard of it as a candy .
08:31:24 <PeakerWork> Twisted is a reactor framework for Python
08:31:53 <noecksit> i think happs is similar, no?
08:31:59 * monochrom hesitates to ask "what is reactor"
08:32:10 <_Dae_> What is reactor?
08:32:46 <monochrom> . o O (Does it input uranium and outputs plutonium and power?)
08:32:57 <lilachaze> it's a framework for reacting to things :)
08:33:22 <EvilTerran> carl, in a do-block, as well as following dolio's suggestion, you can leave off the "in" on a "let"
08:33:50 <EvilTerran> carl, ie "do ...; input <- getContents; ...; let (stuff, rest) = splitAt 4; ..."
08:34:01 <EvilTerran> er, "= splitAt 4 input" even
08:34:18 <EvilTerran> > splitAt 4 (cycle "abracadabra ")
08:34:18 <lambdabot>  ("abra","cadabra abracadabra abracadabra abracadabra abracadabra abracadabra...
08:34:52 <quicksilver> PeakerWork: arguably a lot of the things which twisted offers are already easy with haskell threads.
08:35:09 <quicksilver> a framework for spawning threads in response to network events might be handy.
08:35:21 <quicksilver> disclaimer: I've not used twisted in anger.
08:35:48 <monochrom> anger? agile programming is not enough, you do anger programming?
08:36:02 <lilachaze> quicksilver: wouldn't that just be a case expression and forkIO?
08:36:29 <carl> k thx
08:36:30 <quicksilver> lilachaze: yes.
08:37:22 <PeakerWork> quicksilver: threads represent the current state as a call-stack/current-position, which is limited in non-trivial situations. It also requires awkward communication primitives
08:37:36 <byorgey> Extreme Anger Programming: you are paired with a really dumb partner and after twenty minutes of agony you rip the keyboard from their hands, delete everything they typed, and do it yourself
08:37:45 <quicksilver> PeakerWork: what you've just said makes no sense to me at all.
08:37:59 <quicksilver> PeakerWork: what is limited about representing current state as a group of haskell threads?
08:38:01 <monochrom> @remember byorgey Extreme Anger Programming: you are paired with a really dumb partner and after twenty minutes of agony you rip the keyboard from their hands, delete everything they typed, and do it yourself
08:38:01 <_zenon_> byorgey: hehehehe :)
08:38:01 <lambdabot> Done.
08:38:07 <quicksilver> and how is the twisted solution an improvment?
08:38:37 <PeakerWork> quicksilver: well, I'll create a paste comparing threads to non-threads in non-trivial things
08:38:52 <PeakerWork> quicksilver: hopefully I'll be able to materialize what I mean better
08:39:04 <quicksilver> PeakerWork: thank you.
08:41:23 <monochrom> I wish to see a problem solved by Twisted. Emphasis: problem. I am interested in the problem, not the solution. I intend #haskell to solve it in Haskell, and then we'll see what it means.
08:42:17 <PeakerWork> monochrom: example problem: you want to receive and store SMTP mails in boxes, and have a web server provide nice access to see them
08:43:32 <PeakerWork> quicksilver: how can I interrupt a thread to notify it of something? For example, its currently blocking on a read, but I want to tell it that the read is no longer useful, so it should do something else
08:43:43 <PeakerWork> quicksilver: is the only way to kill the thread?
08:43:44 <quicksilver> PeakerWork: send it an exception.
08:43:50 <quicksilver> no, it doesn't kill the thread.
08:43:56 <quicksilver> (only if the exception is unhandled)
08:44:07 <PeakerWork> quicksilver: I see. That is already a great source of awkwardness :)
08:44:10 <quicksilver> exceptions are the asynchronous message tool.
08:44:13 <quicksilver> why is that awkward?
08:44:16 <quicksilver> you don't like the name
08:44:18 <quicksilver> ?
08:44:25 <quicksilver> s/exception/asyncrhonous message/;
08:44:27 <quicksilver> is that nicer?
08:44:37 <PeakerWork> quicksilver: I think they're a horrible one - because they unwind your stack, when you often just want to do something with them and continue
08:44:50 <monochrom> Why should the thread go on to do something else? That idea itself is awkward.
08:44:52 <PeakerWork> also requiring handling them in many differing contexts, rewinding the stack each time
08:45:07 <quicksilver> they are no different from any other asynchronous message.
08:45:08 * BMeph thinks about making a blog titled "Extreme Anger Programming"
08:45:18 <PeakerWork> monochrom: well, killing the thread seems more reasonable, but a little awkward too
08:45:20 <quicksilver> how does your solution handle asynchronous messages, whilst blocked in a read?
08:45:35 <PeakerWork> quicksilver: Well, I don't "block".
08:45:42 <quicksilver> why not?
08:45:47 <PeakerWork> quicksilver: with Twisted, methods are invoked when events arrive
08:45:59 <PeakerWork> quicksilver: nothing ever blocks
08:46:03 <quicksilver> OK, that's fine.
08:46:15 <quicksilver> so you have a thread which blocks on read but (this is the clever bit) we agree not to talk about it
08:46:20 <quicksilver> we pretend it doesn't exist.
08:46:29 <quicksilver> when it gets things, it sends them off down a Chan
08:46:31 <PeakerWork> quicksilver: I am currently using a cooperative-thread environment in Python, and we're using exceptions as a communication mechanism, and its a great source of daily suffering :(
08:46:32 <quicksilver> and that's your events.
08:46:38 <monochrom> I have a feeling you are biased in that you call every non-Twisted ideas awkward.
08:46:42 * _zenon_ thinks BMeph should go on and Just "do it"
08:46:47 <PeakerWork> quicksilver: and I have to kill it if I want to abort the read
08:47:02 <quicksilver> PeakerWork: in your preferred solution, how do you abort the read?
08:47:17 <PeakerWork> quicksilver: sure I can create an adapter from threads to events
08:47:45 <PeakerWork> quicksilver: If I ask some entity to start doing something asynchronously, it will provide a way to cancel that ongoing process
08:47:51 <quicksilver> ok.
08:47:58 <quicksilver> well that's true with my blocked thread model.
08:48:00 <PeakerWork> "read" is not really a process though
08:48:03 <quicksilver> there is a way to cancel that process.
08:48:21 <quicksilver> I don't think you should worry about whether or not behind the hood it's really a blocked thread.
08:48:40 <quicksilver> (actualy haskell threads blocked on aren't really threads, and they're not really blocked!)
08:48:45 <quicksilver> but that's abstraction for you.
08:48:48 <quicksilver> that doesn't matter.
08:49:00 <quicksilver> what matters is if you can convenient write the programs you want to write.
08:49:39 <PeakerWork> Another awkward thing in the thread approach is that each thread has its own mainloop
08:49:50 <PeakerWork> lots and lots of loops
08:50:01 <quicksilver> I can't imagine why you think that matters?
08:50:06 <quicksilver> they're only loops from one perspective.
08:50:08 <lilachaze> is anyone working on the SMTP mail example in Haskell? do we have a reference Twisted implementation?
08:50:17 <monochrom> That is false for many threading schemes such as Haskell's and Linux's.
08:50:30 <quicksilver> would you be happier with calling them "agents waiting for events"?
08:50:38 <PeakerWork> quicksilver: I guess that's an artifact of how we're using the threads here, and not necessary
08:50:41 <monochrom> lilachaze: I'm thinking about it.
08:50:52 <quicksilver> as far as I can see "thread in mainloop blocking on IO" and "agent waiting for event" are just different ways to describe the same thing.
08:51:04 <quicksilver> I've read some more twisted manual pages.
08:51:08 <PeakerWork> quicksilver: we avoid creating a thread for every thing, so we have mini-reactors implemented in threads (sleep until the soonest thing, yucky stuff like that)
08:51:22 <quicksilver> It looks like it provides a library of common network protocols
08:51:30 <quicksilver> *that* part will be very useful in implementing your SMTP task
08:51:36 <quicksilver> haskell could definitely use something like that.
08:51:45 <PeakerWork> quicksilver: it also implements portable reactors
08:52:01 <PeakerWork> quicksilver: as well as a uniform way to handle asynchronously-available results with a "Deferred" object, which is really a sort of monad
08:52:03 <quicksilver> you say "we avoid creating a thread for every thing" as if that is a good thing.
08:52:09 <quicksilver> why do you believe that is a good thing?
08:52:14 <PeakerWork> quicksilver: I meant that as a bad thing
08:52:17 <quicksilver> ah.
08:52:26 <quicksilver> good :)
08:52:35 <PeakerWork> quicksilver: the cooperative threading library I'm using here with Python uses real threads under the hood and they're expensive
08:52:37 <monochrom> You should create a thread for everything. Or almost everything.
08:52:55 <lilachaze> quicksilver: HAppS provides a library of common network protocols, as does HaskellNet
08:53:05 <monochrom> Most threads should be short-lived. Each does one one-shot job and quits, or told to abort and quits.
08:53:27 <lilachaze> quicksilver: (from a quick googling, no experience with either)
08:53:38 <quicksilver> PeakerWork: *nod* many people who have worked in languages where threads are expensive, are scared of them.
08:53:51 <quicksilver> PeakerWork: haskell provides extremely cheap threads, which are a convenient abstraction.
08:53:55 <PeakerWork> quicksilver: determinism issues and stuff are also scary, probably even with MVars
08:54:09 <monochrom> There is a Mother Of All Threads, it is an infinite loop, it blocks for major events, for each event, it spawns a new thread for a one-shot job for that event, or tells an existing one-shot thread to abort.
08:54:09 <PeakerWork> quicksilver: also, throwing exceptions is awkward because of stack unwinding
08:54:14 <quicksilver> I don't find it particularly sacry in an immutable word.
08:54:34 <quicksilver> PeakerWork: how do you expect to handle an asychronous message without unwinding the stack?
08:54:43 <quicksilver> what do you expect it to do with the operation it is in the middle of?
08:55:18 <Baughn> So, which is more expensive - a forkIO, or a putMVar/takeMVar?
08:55:45 <Baughn> quicksilver: Have you seen the CL exception system?
08:56:01 <monochrom> Is nondeterminism scary? I think it doesn't matter. Is nondeterminism necessary? That matters.  Nondeterminism is necessary because order of events coming in is nondeterministic to begin with.
08:56:07 <Baughn> I'm not sure exactly how to implement it, but /something/ like that would be good
08:56:48 <carl> will having an infinite recursive loop such as mainLoop a b = mainLoop a b cause some sorta overflow or is ghc super smart
08:56:57 <Baughn> carl: GHC is super smart.
08:57:05 <carl> i like super smart
08:57:19 <byorgey> hm, planet haskell seems to be down?
08:57:23 <monochrom> Every haskell implementation I have seen is supersmart on that. In fact gcc -O2 is too.
08:57:34 <_Dae_> Baughn: isn't it only suer smart if you use -O ?
08:57:39 <Baughn> carl: More to the point, the lazy evaluation model uses heap-allocate thunks, not stack-allocated frames
08:58:00 <monochrom> ghc is supersmart on that without -O
08:58:32 <quicksilver> Baughn: interestingly it's not obvious to me that the haskell report necessarily implies that IO should be evaluated lazily
08:58:33 <byorgey> anyone know where planet haskell is hosted?
08:58:36 <Baughn> carl: You /can/ get stack overflows, but I think only from overly long chains of strict function calls. Such as using foldr on (+)
08:58:46 <quicksilver> Baughn: in the sense of, evaluation interleaved with execution.
08:59:06 <quicksilver> Baughn: so, it's not clearly to me that it mandates that foo = putStrLn "hi" >> foo is guaranteed to work.
08:59:09 <schme_> Hello #haskell. Going through real world haskell here, just hit chapter 9. I/O.   So first examples opens a file, reads lines, maps toUpper over 'em and stores off in a file. Yet it doesn't upcase everything in the file, ie. ç and others are not upcased. What function should I use for this to work?
08:59:13 <quicksilver> of course it does, in all implementations.
08:59:41 <Baughn> schme_: toUpper, actually. It might (might) work better in newer versions of ghc
08:59:58 <Baughn> schme_: I'm sure they'd accept patches to expand the upper-lower case map. ;)
09:00:01 <monochrom> If toUpper doesn't up ç, nobody does.
09:00:05 <schme_> Baughn: I'm running 6.8.2 here.
09:00:08 <laz0r> can someone help me with arrow syntax? in particular i am having the problem that i also come into situations where i want to use something on the left side of those '-<' things, but it is only in scope on the right side...
09:00:08 <Giblaz> GHC is an awesome compiler
09:00:20 <Giblaz> i wonder if there is a rating system
09:00:22 <Giblaz> for compilers
09:00:31 <Giblaz> like, the top compilers amongst all languages
09:00:33 <Japsu> Baughn: Native UTF-8 I/O is what we need, not some hacked-together upper-lower case map. :<
09:00:35 <Baughn> schme_: 6.8.3 upcases it
09:00:42 <schme_> Oh ok. I'll grab that then.
09:01:08 <schme_> (that's what one gets for running debian packages) :D
09:01:15 <asdftimo> hey, guys. i'm having trouble understanding how the functions 'topSort' and 'buildG' work, and how to use them. i can't find any documentation. could someone  help me out?
09:01:21 <Baughn> Japsu: How would having native utf-8 i/o help here?
09:01:46 <Baughn> asdftimo: Nope. We've never heard of them.
09:01:48 <Japsu> Baughn: Stuff like uppercasing letters is well-defined in Unicode
09:02:19 <Baughn> Japsu: And you'd implement it with a map, presumably. So implementing Unicode properly would involve writing that map, or at least importing it
09:02:22 <quicksilver> Japsu: and that "Well definition" is that GHC uses.
09:02:26 <Baughn> Japsu: By all means, go ahead
09:02:33 <quicksilver> Japsu: and it has absolutely nothing to do with UTF8.
09:02:39 <asdftimo> ok Baughn. all i know is that they are in Data.Graph
09:02:45 <monochrom> schme_: '\231' is ç, '\199' is Ç.  Watch this experiment:
09:02:53 <monochrom> > Data.Char.toUpper '\231'
09:02:54 <lambdabot>  '\199'
09:03:07 <quicksilver> UTF8 is entirely uninvolved in the process of up/low casing unicode characters.
09:03:09 <monochrom> It also works on ghc 6.8.2, I have tried.
09:03:12 <schme_> monochrom: Right. That is not why runghc is doing for me.
09:03:13 <Baughn> asdftimo: That's documented, then. Look in your documentation
09:03:15 <quicksilver> which GHC does correctly using towupper/towlower
09:03:22 <schme_> monochrom: why = what
09:03:42 <Baughn> asdftimo: Or look in the haskell.org ghc/library documentation if you don't find it
09:03:47 <asdftimo> Baughn: sorry, i'm new. what do you mean by that? just :t?
09:04:13 <Baughn> asdftimo: http://haskell.org/haskellwiki/GHC <-- Standard libraries/Data.Graph
09:04:13 <monochrom> You should blame getContents. It assumes ISO-8859-1, not UTF-8.  IOW it is not reading in ç, it is reading in some junk.
09:04:13 <lambdabot> Title: GHC - HaskellWiki
09:04:21 <asdftimo> ok, thanks baughn
09:04:26 <byorgey> @seen ibid
09:04:26 <lambdabot> ibid is in #haskell. I don't know when ibid last spoke.
09:04:48 <schme_> monochrom: I am using hGetLine
09:04:51 <Baughn> monochrom: Just getContents?
09:05:05 <monochrom> hGetLine has the same problem.
09:05:17 <schme_> But this is fixed in 6.8.3 ?
09:05:21 <monochrom> No.
09:05:23 <schme_> Ok.
09:05:26 <schme_> So how do I read 'em?
09:05:44 <monochrom> There are libraries on hackage for UTF8 and other encodings.
09:05:55 <Baughn> utf8-string, I guess
09:06:01 <monochrom> For the moment I suggest not worrying about it.
09:06:04 <ibid> byorgey: hm?
09:06:10 <Baughn> But doesn't the haskell'98 standard /specify/ utf-8?
09:06:14 <Saizan_> laz0r: if i understood you correctly your arrow must be an instance of ArrowApply fro that, and you need -<< instead of -<
09:06:17 <quicksilver> Baughn: no.
09:06:21 <byorgey> ibid: seems like maybe planet haskell is down?
09:06:23 <quicksilver> Baughn: it specifies unicode.
09:06:28 <quicksilver> Baughn: makes no mention of encodings.
09:06:31 <monochrom> You are just reading RWH and learning IO. Why insist on getting ç to work?
09:06:50 <byorgey> ibid: or at least very very slow, it just sits there loading forever
09:06:59 <Baughn> quicksilver: Hm, and hypothetically you could use latin-1 as a unicode encoding. Kinda. I see.
09:07:22 <quicksilver> it's generally accepted that not doign anything sensible with encodings is daft
09:07:28 <quicksilver> however the report didn't mandate anything better
09:07:36 <PeakerWork> quicksilver: was away. I might want to update some thread variable upon that message and just continue what I was doing
09:07:37 <monochrom> The Haskell 98 standard doesn't specify utf-8 for input and output.
09:07:40 <quicksilver> I think as of 6.10 we're going for UTF8 IO by default.
09:07:43 <schme_> monochrom: It was something that I ran into while following this book. I typed some stuff in a file named input.txt, ran the example code and bam! It did not upcase it. I was merely wondering why.
09:07:51 <quicksilver> PeakerWork: then no need to interrupt the thread at all. Just update the MVar
09:07:56 <PeakerWork> quicksilver: or maybe I want to always ignore the message. Or maybe I want to ignore it, except if I'm in some specific state
09:07:58 <monochrom> OK cool.
09:08:12 <quicksilver> of course UTF8 by default is going to present problems of its own
09:08:16 <quicksilver> let's hope they're not worse :P
09:08:18 <Baughn> schme_: Okay. You don't need it now, but when you feel like fixing it http://hackage.haskell.org/cgi-bin/hackage-scripts/package/utf8-string will do so
09:08:20 <PeakerWork> quicksilver: but that means the pieces of code are more tightly coupled
09:08:21 <schme_> monochrom: It is quite troublesome with it not working though. For later on when I actually use it to read stuff.
09:08:22 <lambdabot> Title: HackageDB: utf8-string-0.3.1.1, http://tinyurl.com/3cjhwj
09:08:28 <schme_> Baughn: Yeah. I've found it :)
09:08:33 <Deewiant> what happens on non-UTF8 (i.e. invalid) input then
09:08:38 <quicksilver> PeakerWork: then don't send the message to 'that' thread.
09:08:44 <monochrom> For later on you can use libraries "utf8-string" or "encoding".
09:08:47 <quicksilver> PeakerWork: send it to another thread which is responsible for message taking.
09:08:56 <Baughn> Deewiant: '\ffff', I believe
09:08:59 <quicksilver> PeakerWork: bundle up several threads into some kind of logical whole.
09:09:01 <PeakerWork> quicksilver: that gets awkward, and its extra work per-thread
09:09:03 <schme_> Well yes. I was mostly wondering if I had done something wrong or not.
09:09:10 <quicksilver> it doesn't get awkward.
09:09:12 <monochrom> You have done nothing wrong. :)
09:09:14 <quicksilver> it isn't extra work.
09:09:22 <quicksilver> it's just a case of deciding what you want to happen and making it happen.
09:09:28 <Deewiant> Baughn: so getContents won't be usable on non-UTF8 then...
09:09:34 <quicksilver> haskell gives good primitives in MVar/Chan/Exception
09:09:36 <monochrom> Alternatively, prepare a file in ISO-8859-1, and it will work for now. :)
09:09:44 <Baughn> Deewiant: True. It /is/ meant for text
09:09:55 <PeakerWork> quicksilver: well, I think there are very few cases where I actually want thread messages to unwind the stack
09:10:02 <PeakerWork> quicksilver: so I'm always going to need these adapting threads
09:10:20 <Baughn> Deewiant: And right now it doesn't work on non-latin1. I know which I prefer.
09:10:21 <RyanT5000> isn't Language.Haskell.TH.reify supposed to work on types?
09:10:27 <RyanT5000> it keeps saying my types are out of scope
09:10:31 <schme_> monochrom: That seems complicated.
09:10:39 <RyanT5000> what's in scope for the purposes of reify?
09:10:39 <quicksilver> PeakerWork: you're thinking of thread at the wrong level of abstraction.
09:10:44 <laz0r> Saizan_: mmh, ok, i'll take a look at ArrowApply
09:10:57 <quicksilver> PeakerWork: what you are doing (by analogy) is insisting that the only variable type you will ever use is Int
09:11:09 <quicksilver> PeakerWork: and then trying to make a whole system of data structures behind the scenes.
09:11:12 <monochrom> schme_: It is a largely historical problem.
09:11:16 <hpaste>  jstanley pasted "trying to understand orphan instance" at http://hpaste.org/8806
09:11:22 <quicksilver> PeakerWork: threads are lightweight, you can make hundreds of them.
09:11:34 <jstanley> Can someone explain that orphan instance to me?
09:11:38 <quicksilver> PeakerWork: if your concept of "Actor" or "Job" or "Agent" requires 5 threads to work, or 12, or 102, that's fine.
09:11:50 <monochrom> There is always resistance to UTF-whatever adoption.
09:11:57 <PeakerWork> quicksilver: sure - my problem is not the extra runtime thread, but extra work on an adapter thread that needs to take exceptions and modify MVars
09:12:06 <schme_> Also this with hClose.. is there nothing like CL's WITH-OPEN-FILE?
09:12:18 <PeakerWork> quicksilver: if I generalize that into some set of functions - it will end up being a different framework, probably
09:12:26 <PeakerWork> quicksilver: (than what people typically use with ordinary threads)
09:12:31 <Saizan_> ?hoogle withFile
09:12:32 <EvilTerran> ?hoogle withFile
09:12:32 <lambdabot> System.IO.withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
09:12:32 <lambdabot> System.IO.withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
09:12:40 <schme_> oh nice.
09:13:01 <quicksilver> PeakerWork: I disagree with everything you have said. I don't believe that what you think is a problem is indeed a problem.
09:13:13 <quicksilver> PeakerWork: we may need to get more concrete to resolve this.
09:13:15 <Saizan_> jstanley: an orphan instance is one that's not defined in the module where the type is defined nor the class
09:13:17 <EvilTerran> o.O
09:13:19 <quicksilver> it's hard to speak in such generalities.
09:13:46 <jstanley> Saizan_: So the problem here is that I am importing the Error type without its definition being present?
09:13:49 <monochrom> I am not sure why "unwind stack" is such a plague to be avoided.  Is it a performance concern?
09:13:50 <PeakerWork> quicksilver: my problem in using a concrete examples is that I don't know the Haskell threading primitives well enough.  I'll play some with Haskell threads and try to construct the example later
09:14:17 <quicksilver> PeakerWork: a concrete example in C or well explained python or pseudocode would be fine
09:14:24 <PeakerWork> monochrom: no, how do you re-wind the stack if you did not actually want to stop doing whatever you were doing?
09:14:27 <jstanley> Saizan_: oh, no it's saying that it doesn't have an instance for [Error], effectively. Right?
09:14:27 <quicksilver> PeakerWork: the syntax isn't the issue I don't think :)
09:14:42 <PeakerWork> quicksilver: I was going to put the threaded/non-threaded one next to another
09:14:44 <Saizan_> jstanley: it's just a warning, not an error, ghc has to check if a module defines orphan instances for typechecking purpouses
09:14:57 <jstanley> Saizan_: Right, but I need to get this to compile with -Werror.
09:14:57 <PeakerWork> quicksilver: I can use the event-based one, I'll do that soon then
09:15:08 * monochrom considers continuations.
09:15:29 <monochrom> (Ha! no continuation in python. that does limit your choice, doesn't it?)
09:15:55 <PeakerWork> monochrom: example?
09:16:11 <monochrom> (Whoever decided to ban continuation in python had his hidden agenda of promoting haskell. :) )
09:16:16 <jstanley> ...so what's the right way to get rid of the warning for http://hpaste.org/8806?
09:16:39 * PeakerWork has to get back to work, so I'll work on that example later
09:16:43 <monochrom> I am not yet sure how to use continuations to do it. I think it helps, but not sure.
09:18:18 <shepheb> does anyone have a favourite reference on continuations?
09:18:28 <monochrom> jstanley: Harmless. The warning is issued because orphaned instances means more work for the compiler.
09:18:52 <jstanley> monochrom: I understand that it's harmless.  I still want to make it go away =)
09:19:13 <rwbarton> jstanley: can you move the instance to Blah.Errors?
09:19:13 <monochrom> The GHC manual has the switch for turning it off. I'm too lazy to look it up.
09:19:31 <rwbarton> -fwarn-orphans turns it on
09:19:37 <jstanley> monochrom: ah, ok, cool.
09:19:41 <jstanley> rwbarton: that's a possibility, yeah.
09:19:50 <jstanley> just wanted to make sure. thanks :)
09:20:00 <quicksilver> PeakerWork: OK, I'm generally around. I would be interested to answer your initial question "Could haskell use something like twisted" but don't know enough about what twisted offers.
09:20:07 <quicksilver> PeakerWork: would be interesting to get to the bottom of this.
09:20:27 <quicksilver> It seems to me that haskell makes twisted's basic event architecture so trivial you don't need a framework for it.
09:20:38 <quicksilver> the library part (protocols etc) would be useful though.
09:21:52 <PeakerWork> quicksilver: if Haskell threads are not real threads, how does it implement a lot of blocking reads from many many sockets?
09:21:58 <quicksilver> PeakerWork: select()
09:22:08 <PeakerWork> quicksilver: select() is pretty horrible, can it use epoll?
09:22:20 <quicksilver> select() is nothing like as bad as the internet would have you believe.
09:22:29 <ibid> byorgey: i do not control the http server, can't do anything about it
09:22:30 <quicksilver> you need a phenomenally busy server for it to matter.
09:22:45 <quicksilver> but I know the GHC guys have considered moving away from select.
09:22:51 <byorgey> ibid: ah, that's too bad.  who does control it?  do you know where it's hosted?
09:23:37 <PeakerWork> quicksilver: well, twisted gracefully handles quite a bit of connections
09:23:51 <PeakerWork> quicksilver: select is also horrible on Windows, btw
09:23:56 <byorgey> ah, I'm guessing it's on the same server as code.haskell.org, it's really slow too
09:23:56 <ibid> byorgey: it's hosted on community.haskell.org (aka nun)
09:24:03 <byorgey> right, ok
09:24:19 <byorgey> ibid: thanks
09:24:25 <quicksilver> PeakerWork: I am somewhat aware of the select/epoll debate but it really doesn't matter as much as most people think.
09:25:05 <quicksilver> PeakerWork: you need a *phenomenally* busy webserver to have 10s of thousands of active TCP connections.
09:25:05 <PeakerWork> quicksilver: see the graphs: http://monkey.org/~provos/libevent/
09:25:08 <lambdabot> Title: libevent
09:25:11 <quicksilver> I doubt twisted scales that well.
09:25:28 <litb> arent haskell threads OS threads?
09:25:36 <quicksilver> litb: no.
09:25:39 <litb> so haskell threads dont run in parallel?
09:25:41 <litb> hmm
09:25:42 <litb> bad
09:25:49 <quicksilver> PeakerWork: yes, but that is delays in microseconds, fffs
09:25:52 <dolio> That's not true either.
09:25:56 <quicksilver> PeakerWork: python is a slow interpreter :P
09:26:06 <PeakerWork> quicksilver: its I/O bound
09:26:16 <dolio> Haskell threads can be farmed out to multiple OS threads.
09:26:26 <quicksilver> surely python can't exhibit microsecond latencies in a useful way?
09:27:00 <lilachaze> quicksilver: python with psyco isn't that slow
09:27:13 <quicksilver> and as I say, how many real programs have 2500 fds open simultaneously.
09:27:22 <quicksilver> I am not doubting that epoll is faster than select. This is well known.
09:27:33 <quicksilver> I'm saying that the problem is exagerrated by the magic of the internet.
09:27:59 <asdftimo> hey guys, im reading some code, and i dont understand why the (+0) is used in this statement:
09:28:00 <asdftimo>     (+0)$read . intersect graphWalk $ usedDigits
09:28:01 <quicksilver> and there are precious few real-world-situations where the select() delay is a bottleneck.
09:28:07 <asdftimo> code is here: http://www.haskell.org/haskellwiki/Euler_problems/71_to_80#Problem_79
09:28:08 <lambdabot> Title: Euler problems/71 to 80 - HaskellWiki, http://tinyurl.com/6fe2dg
09:28:14 <DRMacIver> The internet exaggerates things? Really? Well, that's my faith in humanity shattered.
09:28:17 <quicksilver> asdftimo: that's a really ugly way to force the type to Int, I think.
09:28:37 <asdftimo> i thought that is was 'read' did?
09:29:08 <quicksilver> read can return any type
09:29:15 <quicksilver> so the (+0) is an ugly way to resolve the ambiguity
09:29:17 <quicksilver> I'm guessing.
09:29:23 <quicksilver> I've never seen anyone use (+0)
09:29:34 <asdftimo> could you do read x::Int instead?
09:29:50 <byorgey> that would be the preferred way, yes.
09:29:50 <DRMacIver> I don't see how (+0) would force the type to be Int anyway
09:30:02 <quicksilver> DRMacIver: it would kick defaulting in.
09:30:04 <DRMacIver> It would force it to be (Num a) => a
09:30:05 <DRMacIver> Oh, right
09:30:09 <quicksilver> DRMacIver: probably to integer not int, in fact
09:30:09 <DRMacIver> Yuck
09:30:28 <DRMacIver> (To the defaulting bit, not to Integer vs. Int)
09:30:29 <quicksilver> I never rely on defaulting ;)
09:32:42 <edwardk> Hrmm. playing with lively trying to make a literal haskell cafe. http://www.lively.com/dr?rid=-4485567674160322075
09:32:43 <lambdabot> Title: Lively
09:33:28 <lxuser> ?unpl (+0)$read . intersect graphWalk $ usedDigits
09:33:29 <lambdabot> (((\ h -> read (intersect graphWalk h)) + 0) usedDigits)
09:33:45 <tusho> Say - QuickCheck is really neat, has anyone done BDD with it?
09:33:58 <tusho> (Write tests that describe the proposed behaviour of a system and its components, then write the components)
09:35:16 <tusho> Of course, with that beauty in the beast stuff for IO.
09:36:24 <geezusfreeek> tusho: i don't think bdd is a very good fit for what quickcheck does
09:36:32 <tusho> Hm. I don't see any real barriers to it.
09:36:37 <geezusfreeek> tusho: perhaps hunit, but even that seems wrong to me
09:36:38 <tusho> Describe how the functions will work, then write then.
09:36:42 <tusho> *them
09:36:53 <geezusfreeek> i always thought of bdd as a very OO-centric process
09:37:06 <PeakerWork> Gnome sucks :-(
09:37:16 <geezusfreeek> i think of quickcheck more as a specification language
09:37:47 <geezusfreeek> you don't state "behaviors," you state "properties"
09:37:52 <quicksilver> tusho: in haskell, once you've described how the functions work you have already written them :)
09:38:09 <PeakerWork> quicksilver: how do you deal with Windows select only accepting 64 sockets at a time?
09:38:11 <_zenon_> http://icanhascheezburger.files.wordpress.com/2008/07/funny-pictures-big-brother-helps-little-brother-kitten.jpg
09:38:12 <lambdabot> http://tinyurl.com/6dbv7u
09:38:12 <quicksilver> haskell is an executable specification language.
09:38:19 <quicksilver> PeakerWork: well obviously I never use windows.
09:38:27 <tusho> quicksilver: If that was true, there would be absolutely no need for quickcheck.
09:38:28 <quicksilver> PeakerWork: and certainly never for a server.
09:38:35 <tusho> Which is, frankly, _rubbish_
09:38:39 <quicksilver> tusho: well I was joking :P
09:38:47 <PeakerWork> quicksilver: its less portable, though
09:38:54 <quicksilver> PeakerWork: I would describe that as a bug in windows select()
09:38:55 <quicksilver> :P
09:39:04 <PeakerWork> I guess epoll isn't portable either :-)
09:39:05 <geezusfreeek> tusho: no that's the point. quickcheck doesn't specify what functions _do_. it just helps you make sure certain properties hold
09:39:09 <quicksilver> PeakerWork: quite.
09:39:24 <tusho> geezusfreeek: That's what I mean.
09:39:27 <quicksilver> anyhow I'm not opposed to GHC moving to a more sophisticatd IO loop.
09:39:33 <tusho> Describe the properties of the functions, then write them.
09:40:00 <quicksilver> I'm purely saying that most of this crap about select() is crap, written by people who don't understand about code benchmarking and bottlenecks :P
09:40:20 <geezusfreeek> tusho: it's not very meaningful to progressively add constraints to a haskell function. you usually end up just rewriting the whole thing each time
09:40:33 <tusho> geezusfreeek: OK, that part isn't part of what I was meaning.
09:41:01 <geezusfreeek> ah, then that is not BDD
09:41:17 <tusho> *shrug*
09:41:30 <quicksilver> PeakerWork: actually I think it doesn't use select() on windows.
09:41:37 <quicksilver> PeakerWork: I think it uses some windows stuff.
09:42:01 <geezusfreeek> i think most of us tend to write out quickcheck properties _after_ writing the function(s), but i could be wrong
09:42:14 <tusho> geezusfreeek: Yes - my idea was writing them beforehand
09:43:00 <geezusfreeek> tusho: i suppose many do write out some semantics before coding anything, which might be equivalent
09:43:10 <tusho> yes, but this is mechanical
09:43:36 <geezusfreeek> what's the benefit?
09:44:42 <PeakerWork> quicksilver: about Twisted scaling up: http://blog.bluendo.com/ff/mina-and-twisted-matrix-benchmarks
09:44:44 <lambdabot> Title: ff
09:46:02 <quicksilver> PeakerWork: yes, impressive. I don't dispute the raw facts.
09:46:07 <quicksilver> I dispute their relevance :P
09:46:16 <quicksilver> PeakerWork: http://hackage.haskell.org/trac/ghc/ticket/635
09:46:19 <lambdabot> Title: #635 (Replace use of select() in the I/O manager with epoll/kqueue/etc.) - GHC - ...
09:47:18 <PeakerWork> the use of _|_ is funny
09:49:32 <quicksilver> somebody is also working on aio bindings
09:49:36 <quicksilver> perhaps that has some bearing.
09:49:50 <quicksilver> but as I keep repeating monotonously, the applications where this is relevant are very few indeed :)
09:49:59 <Baughn> Not really. AIO isn't /implemented/ on any OS I have access to
09:50:26 <Baughn> Linux does it partially.. on a few filesystems.. if the phase of the moon is right
09:50:49 <sbahra> What do you mean by "implemented"?
09:50:58 <Baughn> "Actually asynchronous"
09:51:05 <sbahra> I thought most of the Linux I/O API (in-kernel) is asynchronous now, edge-triggered (2.6).
09:51:11 <quicksilver> Baughn: does it have no relevance to sockets?
09:51:24 <Baughn> quicksilver: Oh yes. Nope, doesn't work with sockets either.
09:51:25 <sbahra> Solaris supports for raw disks. All others I know of, yeah, they just usually have kthreads.
09:51:29 <Baughn> Let's see if I find the page..
09:51:43 <Baughn> http://lse.sourceforge.net/io/aio.html
09:51:44 <lambdabot> Title: Kernel Asynchronous I/O (AIO) Support for Linux
09:52:07 <sbahra> http://kxr.bitcanvas.net/ is up for people who are interested.
09:52:12 <noecksit> hello, im thinking of using a newtype but I
09:52:18 <Baughn> I'm inclined to think that async I/O would be good, but should be implemented using threads
09:52:29 <noecksit> *i'm not sure why i shouldn't just use the "Data" keyword
09:52:55 <quicksilver> noecksit: guideline is just use data
09:52:57 <noecksit> what is the main difference, except that newtype takes only one parameter?
09:53:03 <quicksilver> newtype is mostly a subtle efficiency tweak
09:53:07 <sbahra> Baughn, that is generally lighterweight. However, most operating systems that completely lack AIO usually have a librt/libaio with multithreading.
09:53:08 <geezusfreeek> noecksit: do you understand the difference?
09:53:16 <sbahra> Baughn, Solaris is one example when you're not writing to a raw device.
09:53:18 <geezusfreeek> ah, nope
09:53:31 <geezusfreeek> there is a page i'm looking for
09:53:34 <Baughn> sbahra: That's at least got the same behaviour
09:53:40 <Baughn> sbahra: This line from linux makes me freak: "these do not return an explicit error, but quietly default to synchronous or rather non-AIO behaviour"
09:53:50 <sbahra> Baughn, yes :-/
09:54:09 <sbahra> I spent a good amount of time benchmarking some AIO things for some scientific applications.
09:54:15 <sbahra> Was a real disappointment.
09:54:20 <geezusfreeek> noecksit: http://www.haskell.org/haskellwiki/Newtype
09:54:20 <noecksit> apparently there's some kind of indirection which i wasn't able to read up on since the page is not found:
09:54:20 <lambdabot> Title: Newtype - HaskellWiki
09:54:42 <_Dae_> lambdabot Could you give me a list of overcomplete function sets please?
09:54:45 <geezusfreeek> ^ compares newtype to data with lazy and strict fields
09:55:34 <lilachaze> noecksit: in brief, any time when both data and newtype are legal, they are completely equivalent semantically, except that the 'data' form has one additional value which is a top-level _|_.
09:55:34 <Baughn> noecksit: If I've got this right now (could be wrong.. again), a newtype exists solely in the mind of the type system, and is otherwise treated as the underlying type
09:56:14 <lilachaze> noecksit: at least, that's how i understand it. the missing top-level _|_ allows a more compact representation.
09:56:30 <Philippa> noecksit: newtype expresses an isomorphism - that's useful for efficiency purposes, and can be additional documentation for a reader
09:56:39 <noecksit> lilachaze : yeah i remember reading about _|_ in yaht which was completely over my head
09:57:31 <geezusfreeek> i think of newtype as saying "this is a foo" and data as saying "this contains a foo"
09:57:34 <Baughn> noecksit: If you've got some understanding of the underlying machinery, data adds a thunk and newtype doesn't
09:57:43 <Philippa> noecksit: basically it means that case mynewtype of MyNewType parm -> ... always terminates if the ... does
09:59:22 <noecksit> Philippa : oh, so it doesnt look for "_" keyword?
09:59:31 <lilachaze> noecksit: _|_ is essentially an error condition. for many purposes, it doesn't matter.
10:00:39 <lilachaze> noecksit: but: if "f = f" then "case f of Foo _ -> True" returns True if you have "newtype Foo = Foo Int" but does not terminate if you have "data Foo = Foo Int". Not sure if that helps your understanding...
10:02:14 <Philippa> noecksit: compare and contrast with case (let omega = 1 + omega in omega) of 1 ...
10:02:31 <Philippa> which (for a typical numeric type) won't terminate because it'll try to evaluate infinity
10:03:32 <ziman> lilachaze, i'd think the `newtype' version wouldn't terminate
10:04:13 <Baughn> lilachaze: Both the data and newtype versions should terminate
10:04:36 <Baughn> Although.. hmm
10:04:42 <lilachaze> Baughn: really? the data version should force f to WHNF, shouldn't it?
10:04:45 <ahunter> Philippa: is there a Num type for which that *will* terminate?
10:04:53 <Baughn> lilachaze: I was mixing my examples. :/
10:05:04 <dolio> Lazy naturals will terminate.
10:05:21 <dolio> Most numeric types will 'terminate' in an exception if you compile with optimization.
10:05:32 <basvandijk> Hello, is there a function like 'run :: String -> IO String' where 'run "command"' runs the command and returns the result of that? I'm now using HSH.run which does exactly what I want but I was wondering if there's a more standard function.
10:05:35 <Baughn> Or with -threaded
10:05:54 <Baughn> basvandijk: runProcess
10:05:56 <Baughn> More or less
10:06:01 <lilachaze> can user-defined Num instances be used in a 'case' with a numeric pattern? eg, case 1 :: MyNum of 1 -> ...
10:06:21 <dolio> But terminating in an exception is semantically identical to non-termination.
10:06:40 <rwbarton> lilachaze: sure
10:06:43 <lilachaze> basvandijk: you mean run in a shell?
10:06:47 <rwbarton> :t (\x -> case x of 1 -> True)
10:06:48 <lambdabot> forall t. (Num t) => t -> Bool
10:06:54 <Baughn> lilachaze: 1 is syntactic sugar for fromInteger 1
10:07:08 <basvandijk> lilachaze: yes. I want to run the command "aspell dump master -l en"
10:07:16 <lilachaze> Baughn: sure, but normally you can't put expressions in case patterns.
10:07:53 <Baughn> lilachaze: That particular pattern is okay
10:08:42 <basvandijk> Baughn: the problem with 'runProcess' is that it works with 'Handles'. I could build my own function around it though. But I think I stick with HSH.run.
10:09:14 <lilachaze> Baughn: ok, so it has special magic for that. presumably using the Eq instance?
10:09:35 <geezusfreeek> lilachaze: there are also n+k patterns
10:09:45 <Baughn> lilachaze: Okay. With data, arguments lazy by default (but can be stricted); with newtype, the type really just exists only in the type-checker's imagination and they behave exactly like the wrapped type except for instance selection and such
10:10:19 <lilachaze> Baughn: was that supposed to be @noecksit?
10:10:51 <Baughn> Possibly
10:10:52 <lilachaze> geezusfreeek: good point. presumably they desugar to use of the Ord instance? i never realised how messy these patterns are :)
10:11:14 <rwbarton> there's no Ord in Num
10:11:29 <rwbarton> @ty (\x -> case x of (n+1) -> n)
10:11:30 <lilachaze> so how do (n+k) work then?
10:11:30 <lambdabot> forall t. (Integral t) => t -> t
10:11:32 <geezusfreeek> i imagine it just uses addition/subraction
10:11:34 <lilachaze> ah :)
10:12:04 <rwbarton> And yes, matching against integer literals does use the Eq superclass of Num
10:12:10 <lilachaze> Ord => Real => Integral
10:12:17 <ziman> :t (\x -> case x of (n+1.0) -> n)
10:12:17 <lambdabot> Parse error in pattern
10:13:11 <lilachaze> i think i now understand why some people dislike (n+k) patterns so much
10:13:37 <noecksit> what would be the function to insert data at the end of a list?
10:13:50 <kiris> append? (++)
10:13:53 <dolio> n+k patterns convert to Integer (I think) and use operations on it.
10:13:59 <kiris> > [1,2,3] ++ [4,5,6]
10:14:01 <lambdabot>  [1,2,3,4,5,6]
10:14:12 <noecksit> @hoogle append
10:14:13 <lambdabot> Data.ByteString.append :: ByteString -> ByteString -> ByteString
10:14:13 <lambdabot> Data.ByteString.Char8.append :: ByteString -> ByteString -> ByteString
10:14:13 <lambdabot> Data.ByteString.Lazy.append :: ByteString -> ByteString -> ByteString
10:14:23 <kiris> append is in the Prelude
10:14:39 <dolio> So it doesn't use (+) or (-) for your type.
10:14:52 <noecksit> @type Prelude.append
10:14:52 <lambdabot> Not in scope: `Prelude.append'
10:15:26 <lilachaze> dolio: that sounds even uglier than using the Ord instance :)
10:15:28 <kiris> @type append
10:15:28 <lambdabot> Not in scope: `append'
10:15:34 <kiris> haha, what
10:15:37 <kiris> @type (++)
10:15:37 <lambdabot> forall m. (Monoid m) => m -> m -> m
10:15:41 <noecksit> something like (:) except at the end rather than beginning
10:15:58 <kiris> uh, ignore that for now
10:16:02 <Deewiant> @type mappend
10:16:03 <lambdabot> forall a. (Monoid a) => a -> a -> a
10:16:03 <kiris> (++) :: [a] -> [a] -> [a]
10:16:19 <Deewiant> @type (Prelude.++)
10:16:20 <lambdabot> forall a. [a] -> [a] -> [a]
10:16:21 <geezusfreeek> it's caleskell again
10:16:21 <dolio> lilachaze: It's pretty bad. :)
10:16:30 <kiris> hascale
10:16:31 <lilachaze> noecksit: if you're going to be doing it a lot, you could construct your list in reverse using (:) then reverse it.
10:16:53 <Deewiant> or just use Data.Sequence
10:18:20 <noecksit> lilachaze : true, do u think thats faster than using ++?
10:18:34 <lilachaze> how can i get ghci to not print the result of "a <- b" ?
10:19:01 <lilachaze> noecksit: for one-element appends, it should be. n uses of (++) is O(n^2).
10:19:12 <mar77a> > let a = putStrLn "hi"
10:19:13 <lambdabot>  Parse error at end of input
10:19:27 <geezusfreeek> don't forget diff lists!
10:20:10 <geezusfreeek> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/dlist
10:20:14 <lambdabot> Title: HackageDB: dlist-0.4.1
10:20:24 <smg> mar77a: ? :P
10:20:24 <noecksit> @hoogle Data.Sequence
10:20:25 <lambdabot> No matches, try a more general search
10:20:39 <mar77a> oops
10:20:39 <Deewiant> @hoogle Seq
10:20:40 <lambdabot> Data.Sequence.Seq :: data Seq a
10:20:40 <lambdabot> Prelude.seq :: a -> b -> b
10:20:40 <lambdabot> Data.Sequence :: module
10:20:56 <Deewiant> http://haskell.org/ghc/docs/latest/html/libraries/containers/Data-Sequence.html
10:20:57 <lambdabot> Title: Data.Sequence, http://tinyurl.com/3arc5q
10:21:03 <lilachaze> my question another way, how can I get a String (not IO String) in ghci containing a file's contents without printing it out?
10:21:25 <geezusfreeek> not IO String?
10:21:52 <geezusfreeek> oh ghci
10:22:23 <noecksit> lilachaze : do u want to use a non-monadic function on it?
10:22:41 <Baughn> lilachaze: :set -fno-print-bind-result, I think
10:22:42 <lilachaze> noecksit: i want it in a variable in ghci for further playing with
10:23:06 <xerox> do what Baughn said, and then cntnts <- readFile "foo.txt"
10:23:07 <lilachaze> Baughn: perfect, thanks :)
10:24:15 <noecksit> thats pretty cool, i didnt know that was possible
10:24:55 <roconnor> $ cat .ghci
10:24:55 <roconnor> :set -fno-print-bind-result
10:25:03 <roconnor> Put that in your .ghci file
10:25:09 <roconnor> everyone should do it. :)
10:25:31 <smg> roconnor: what does it do?
10:25:56 <roconnor> smg: it prevents printing of the bind result whenever you run ghci
10:26:05 <smg> bind?
10:26:22 <roconnor> It stops cntnts <- readFile "foo.txt" from printing the whole file in ghci
10:26:28 <smg> ah
10:26:39 <smg> ah i understand :)
10:26:55 <smg> :s -fno-print-bind-result
10:27:15 <smg> is that good or bad, i don't know :)
10:27:54 <lilachaze> seems like that should be ghci's default to me :)
10:28:22 <byorgey> who is an admin for community.haskell.org?  dons? Igloo? SyntaxNinja?
10:28:42 <dons> and dcoutts
10:28:56 <SyntaxNinja> hi byorgey
10:29:14 <byorgey> ah, and dcoutts
10:29:18 <byorgey> hi dons, SyntaxNinja =)
10:29:32 <Igloo> byorgey: support [AT] community.haskell.org
10:29:51 <byorgey> nun seems to be down, or very slow... planet.haskell.org and code.haskell.org do not seem to respond
10:30:10 <byorgey> Igloo: indeed, but if it's down, you wouldn't get my mail, would you =)
10:30:47 <Igloo> I think it's only apache that is being slow
10:30:54 <Mitar> who can i profile a program with Graphics.UI.GLUT?
10:31:08 <byorgey> ah, could be
10:31:08 <Mitar> i get an error that i do not have a profiling version of a library
10:36:48 <noecksit> is it possible to overload a function to take "a" parameter as well as "[a]"?
10:37:13 <noecksit> or would that be GADT
10:37:14 <mar77a> is it possible to overload at all in haskell
10:37:26 <SyntaxNinja> Igloo, dons: are either of you looking into that?
10:37:37 <dons> hmm
10:37:41 <sclv_> edwardk: comonads around the household :-) -- http://www.reddit.com/r/programming/info/6qz4x/comments/
10:37:42 <lambdabot> Title: programming: Comonads in day-to-day web programming.
10:37:52 <byorgey> noecksit: you could do something like that using a type class.
10:37:54 <rwbarton> noecksit: You could make it take an Either a [a] -- that's an ordinary algebraic datatype
10:38:01 <Igloo> SyntaxNinja: I'm not
10:38:21 <dons> mar77a: to overload at all? type classes.
10:38:30 <sclv_> I hope I didn't screw anything up in my explanations too badly. On the other hand, I avoided that by not explaining that much.
10:38:31 <dons> code.h.o seems very slow
10:39:18 <edwardk> sclv: nice =)
10:39:23 <maltem> byorgey: That would probably go wrong if that a is the usual forall a. a
10:39:26 <mar77a> so it's pseudo-overloading?
10:39:39 <byorgey> maltem: yes, I suppose you're right.
10:39:40 <SyntaxNinja> is anyone able to get community.h.o to respond?
10:39:44 * glguy can download from c.h.o at 250kb/s
10:39:44 <SyntaxNinja> should I restart apache?
10:39:49 <glguy> via ssh
10:39:49 <LordBrain> I have a question about strictness analysis.
10:40:04 <glguy> sqlite-amalgamation-3.5.8.tar.gz              100% 1108KB 276.9KB/s   00:04
10:40:11 <maltem> mar77a: Non-pseudo overloading is more appropriately called ad-hoc overloading ;)
10:40:13 * SyntaxNinja doesn't see why it's being slow
10:40:23 <mar77a> hmm
10:40:27 <LordBrain> this quote is from wikipedia "Note that a function f is said to diverge if it returns \{\bot\}: operationally, that would mean that f either causes abnormal termination of the enclosing program (e.g., failure with an error message) or that it loops infinitely."
10:40:35 <sclv_> Hmm... should probably have mentioned the clowns to the left paper too...
10:40:36 <noecksit> byorgey : so u can have a class that has two functions with identical names but different paramters, right?
10:41:00 <LordBrain>  \{\bot\} is bottom
10:41:07 <byorgey> SyntaxNinja, glguy: yeah, c.h.o itself seems to be fine (I can log in via ssh too), it's just apache
10:41:26 <LordBrain> My question is about this abnormal termination via an error message
10:41:31 <byorgey> noecksit: no, have a class with one function, and two instances of the class for different types
10:41:51 <LordBrain> if that error message only happens on computers due to limitations in their resources, does that count?
10:41:53 <byorgey> noecksit: you can't have a class with two functions that have identical names.
10:42:16 <mar77a> is it unpure or something that violates the haskell laws to push nothing onto a list
10:42:41 <maltem> LordBrain: "only happens on computers"?
10:42:49 <byorgey> mar77a: I don't understand what you are asking.
10:43:10 <LordBrain> maltem, i mean like a stack overflow
10:43:32 <mar77a> well, i've come across functions which could've been written nicely using a conditional which pushed something or pushed nothing
10:43:34 <LordBrain> maltem, if i had a large enough stack the program would terminate successfully
10:43:41 <maltem> ah I see
10:43:45 <mar77a> now that i think about it
10:43:51 <noecksit> byorgey : the function has two different parameters though, say something like "func a" and "func [a]", how could i let the class take a generic one?
10:43:54 <mar77a> i could use a list of Justs and then filter the Nothings
10:44:10 <SyntaxNinja> OK I'll restart apache in a minute if I don't hear any objections....
10:44:18 <dons> go for it.
10:44:23 <LordBrain> maltem, on the other hand... one could argue that by changing the value of the parameter given to the function i can always get it large enough to cause an overflow.
10:44:39 <maltem> LordBrain: No, I would consider that a side effect that doesn't change the semantics of the program
10:44:41 <LordBrain> maltem, after all, there are no computers with infinite stacks...
10:45:09 <rwbarton> LordBrain: that wikipedia page is probably talking about an idealized model of computation such as a turing machine with an infinite tape
10:45:33 <rwbarton> LordBrain: Similarly, we can't distinguish a program that terminates in 10^(10^10) years from one that loops indefinitely
10:45:45 <rwbarton> LordBrain: in that sense an actual computer is a kind of approximation
10:45:55 <plutonas> how do you run ghci in emacs? is there some special mode, (that i couldn't find in haskell-mode.el), or just open a shell or terminal inside emacs and run it there?
10:45:58 <byorgey> noecksit: right, you have 'class Foo a where func :: a -> Bar', then 'instance Foo a where ...  and 'instance Foo [a] where ...'
10:46:17 <byorgey> noecksit: although that will run into some problems with overlapping instances
10:46:23 <dolio> You can distinguish them given the right language.
10:46:23 <byorgey> but I think it could be made to work
10:46:24 <maltem> LordBrain: Still the stack is not the domain of functional definitions, the stack shouldn't determine evaluation semantics
10:46:34 <LordBrain> maltem, ok, good
10:47:03 <maltem> LordBrain: it's more like, perhaps, an IO exception that kills the program
10:47:09 <dolio> You can, in theory, write a program that terminates in 10^(10^10) years in Agda, but not write one that loops indefinitely (at least, not one that passes the termination checker).
10:47:43 <noecksit> byorgey : oh i got u, two different instances, i dont think i can do that though, since i need the same instance to use [a] as parameter and a as parameter sometimes
10:47:47 <plutonas> seems that nobody runs ghci in emacs :S
10:47:58 <rwbarton> plutonas: try C-c C-l ?
10:48:29 <kriomant> 'Data.Binary.Get.getBytes' and 'getByteString' return 'Data.ByteString.Internal.ByteString'. Why not normal ByteString? How to convert this to normal ByteString?
10:48:34 <byorgey> noecksit: in that case, you probably want to use an algebraic data type like rwbarton suggested.
10:48:49 <plutonas> rwbarton: in what kind of buffer do i hit this sequence?
10:49:00 <byorgey> noecksit: have your function take a parameter of type 'Either a [a]', then you can pattern-match on whether it is 'Left x' or 'Right xs'
10:49:07 <LordBrain> in terms of the semantics, as maltem says, a program that terminates in 10^(10^10) years from now is quite diverent from one that loops indefinitely, as the latter would be considered to diverge. Right?
10:49:24 <rwbarton> your haskell-mode buffer containing a .hs file
10:49:49 <rwbarton> But I had to add the following line to my .emacs to make it work:
10:49:49 <rwbarton> (load-file "/usr/share/emacs/site-lisp/haskell-mode/inf-haskell.el") ; Is the fact that I have to do this a bug?
10:49:49 <maltem> kriomant: Those are the same type
10:50:18 <kriomant> maltem: Hm... but I got type mismatch errors...
10:50:33 <maltem> kriomant: Maybe you're mixing Lazy and Strict ByteStrings?
10:50:35 <kriomant>     Couldn't match expected type `B.ByteString'
10:50:36 <kriomant>            against inferred type `Data.ByteString.Internal.ByteString'
10:50:36 <kriomant>  
10:51:02 <maltem> kriomant: Now, if B = Data.ByteString.Lazy, you have your mismatch
10:51:50 <maltem> kriomant: Though if B = Data.Bytestring, it should work
10:52:10 <maltem> LordBrain: Sounds right to me
10:52:51 <plutonas> rwbarton: thanks, if i except the fact that some part of the code i had working seems to not work now, it's perfect
10:54:11 <plutonas> ok everything working now, also auto-completion :)
10:54:44 <kriomant> maltem: does Data.Binary.Get use lazy bytestrings?
10:55:03 <rwbarton> kriomant: Yes, it does
10:56:22 <LordBrain> In cases where we have a lazy calling convention and it causes a stack overflow due to a building-up of a chain of unevaluated thunks (eg, 1+1+1+1+1+1...). There is possibly some  hope that a strictness analysis algorithm exists to recognize that the program could be made strict in that argument and so not cause the overflow?
10:57:47 <edwardk> lordbrain in a lot of cases, yes -O2 does that in GHC just fine
10:58:11 <maltem> LordBrain: right, e. g. ghc -O2 should optimize  foldl (+) 0  into  foldl' (+) 0
10:58:24 <LordBrain> i see
10:58:35 <LordBrain> O2 is not the default tho?
10:58:56 <edwardk> correct
10:58:58 <byorgey> sclv_: neat post.
10:59:05 <maltem> -O2 is industry standard :)
10:59:09 <Baughn> LordBrain: It is probably a good idea to try writing your programs so they don't depend on optimization to avoid crashing
11:01:09 <hpaste>  kriomant pasted "type errorData.Binary.Get and ByteString" at http://hpaste.org/8807
11:01:11 <roconnor> will ghc -O2 optimize foldr (+) 0 into fold' (+) 0 ?
11:01:21 <LordBrain> Baughn, yes... but i am only human after all. Perhaps if the algorithm exists anyway, we can use it to give a warning/suggestion to the programmer so that they no longer depend on optimization.
11:02:07 <Baughn> LordBrain: Too noisy. Most of the time when that optimization triggers, it's for lists short enough that it /wouldn't/ have crashed
11:02:22 <Baughn> Or call chains, anyway
11:02:29 <roconnor> foldl (+) 0 won't crash on an ideal machine
11:02:55 <LordBrain> hmmmm... well we could have a switch --very-noisy-warnings
11:03:33 <kriomant> maltem: http://hpaste.org/8807#a1 - here is minimal code reproducing my error
11:03:34 <maltem> Baughn: It would be handy as an analysis tool though (but perhaps there is already a way to find out where strictness analysis shoot?)
11:04:02 <Baughn> maltem: Several, ranging from reading the .hi files to the -ddump-foo flags
11:04:27 <Baughn> maltem: Reading the .his is the easy way; they specifically annotate functions as being strict in certain arguments, or not
11:04:30 <LordBrain> Baughn, this could apply to optimizations in general... so that rather than optimizing the compiler gives you feed back which teaches you how to optimize...
11:04:49 <rwbarton> kriomant: it seems getBytes returns a non-lazy bytestream
11:05:04 <maltem> Baughn: Sounds like the part of Haskell activity I don't specifcally enjoy doing. Oh wait, the .his explicitly annotate? Sounds fine
11:05:22 <LordBrain> What's that expression? "Give someone a fish.. they eat for a day... Teach them to fish..."
11:05:24 <kriomant> rwbarton: but changing ByteString.Lazy to ByteString in import doesn't help
11:05:28 <plutonas> what does the Eq a => at the beginning of some types mean? You could give me a link to read as well :)
11:05:29 <SyntaxNinja> ﻿restarted community.haskell.org server - that working for folks?
11:05:35 <Baughn> maltem: ghc --show-iface Foo.hi|less
11:05:45 <rwbarton> kriomant: Right, because runGet requires a lazy bytestream :)
11:05:58 <Baughn> maltem: Shows overloading and things too.. well, basically everything the optimizer needs, which happens to also be everything you need
11:06:11 <Baughn> maltem: file:///Users/svein/doc/haskell/ghc/users_guide/faster.html
11:06:32 <Baughn> maltem: ..okay, no good url. Verbatim: "Look for your function in the interface file, then for the third field in the pragma; it should say __S <string>. The <string> gives the strictness of the function's arguments. L is lazy (bad), S and E are strict (good), P is “primitive” (good), U(...)  is strict and “unpackable” (very good), and A is absent (very good)."
11:06:39 <rwbarton> if you mouse over the occurrences of ByteStream in the haddock documentation, you can see which are lazy and which are not
11:06:41 <kriomant> rwbarton: so I need to provide lazy bytestring, but read strict ones?
11:07:06 <rwbarton> kriomant: you can use getLazyByteString if you prefer
11:07:11 <Baughn> maltem: (-ddump-simpl does the same, even for functions that aren't exported)
11:07:25 <Baughn> maltem: Or just read ghc documentation section 7.2. :P
11:07:27 <kriomant> rwbarton: ok, using L.getContents with B.getBytes resolved problem
11:09:09 <maltem> Baughn: I'm reading, I'm reading :)
11:09:27 <kiris> will someone explain what hierarchical bounding boxes are?
11:12:45 <asdftimo> all: does anyone know how i could display a 2D representation of a graph?
11:12:46 <kiris> n/m, I think I get it
11:13:07 <Baughn> asdftimo: graphviz
11:13:15 <asdftimo> @hoggle graphviz
11:13:15 <kiris> asdftimo: do you want to output an image, show it in a program, or in a web page, or print it out, or what?
11:13:15 <lambdabot> No matches found
11:13:31 <asdftimo> kiris: no preference. just a visualization.
11:13:34 <Baughn> @google graphviz
11:13:35 <lambdabot> http://www.graphviz.org/
11:13:35 <lambdabot> Title: Graphviz
11:14:23 <asdftimo> Baughn: i have  a graph in haskell that i would ilke to output as an image (whatever).
11:15:02 <dons> asdftimo: the Charts library
11:15:02 <asdftimo> can i do that with graphviz? haskell -> graphviz?
11:15:24 <dons> or the googlecharts library.
11:15:33 <dons> go to hackage.haskell.org and look at the graph visualisation libs
11:15:36 <monochrom> I think "graph" in graphviz is different from "graph" in "graph plots".
11:15:45 <Baughn> asdftimo: graphviz uses a relatively simple input scheme. You can certainly have haskell write an input file for it without any problems, and it'll do the heavy lifting
11:16:20 <mar77a> > 360*3
11:16:22 <lambdabot>  1080
11:17:01 <asdftimo> Baughn: ok. it looks pretty. the only problem is that i just started learning about graphs in haskell this morning so it will take me a while to write the code
11:17:01 <asdftimo> meh
11:19:06 <frankblack> hi guys
11:19:21 <frankblack> hope somebody can cure my headache ;-)
11:19:58 <frankblack> I started learning haskell today, too, and accomplished this masterpiece: http://rafb.net/p/MmHkzm27.html
11:19:59 <lambdabot> Title: Nopaste - No description
11:20:32 <dons> dcoutts_: around?
11:20:45 <mauke> frankblack: readLn
11:20:49 <frankblack> now I want to display the numbers I have entered but I can't wrap my head around it
11:21:09 <kiris> is that some YAHT?
11:21:20 <byorgey> frankblack: welcome!
11:22:03 <byorgey> frankblack: just do something like  main = do hSetBuffering ...  \n  nums <- askForNumbers  \n  print nums
11:22:04 <monochrom> Heh it won't do much unless your main somehow calls askForNumbers.
11:22:08 <Baughn> frankblack: Easiest way is to pass them to print
11:22:20 <frankblack> yeah I am following that tutorial and I am currently failing at excercise 3.10
11:22:35 <byorgey> frankblack: what you have so far looks good.
11:22:47 <PeakerWork> frankblack: cool. I think I have a "takeWhileM" that might fit that exact kind of recursion
11:23:05 <PeakerWork> frankblack: (a monadic takeWhile)
11:23:38 <vincenz> @seen Cale
11:23:38 <lambdabot> Cale is in #ghc, #haskell-overflow and #haskell. I last heard Cale speak 7h 40m 58s ago.
11:23:54 <frankblack> okay but I do not understand what askForNumber *is*
11:24:15 <frankblack> It's not correct to think of it as a function
11:24:20 <rwbarton> Well, you can ask ghci by loading in your file and typing  :t askForNumbers
11:24:24 <mauke> frankblack: it's a constant; a value.
11:24:24 <monochrom> ooooh, that's a philosophical question. :)
11:24:45 <monochrom> try "procedure", "action", "code".
11:24:50 <byorgey> frankblack: askForNumber has type  IO [Int], which means it is an IO computation which, when run, will produce a list of Ints
11:24:55 <Baughn> "Action that, when/if called, returns a list of ints"
11:24:59 <frankblack> IO [Integer] - that's because it has a do block?
11:25:11 <mauke> frankblack: no, because it uses getLine
11:25:16 <frankblack> ok
11:25:23 <byorgey> frankblack: well, you can use do blocks for things other than IO
11:25:30 <byorgey> frankblack: but that's the right idea
11:25:32 <Baughn> Although I notice you're not constraining the return type of read here, except by comparing to 0. It could equally well return doubles or rationals
11:25:32 <hpaste>  LordBrain pasted "Understanding GHC's hi file annotation" at http://hpaste.org/8808
11:26:21 <mauke> my take on IO: http://mauke.ath.cx/stuff/haskell/how-to-io.html
11:26:23 <lambdabot> Title: Haskell: How To IO
11:26:54 <LordBrain> Baughn, in the hpaste i just put up, I see there is in fact some annotation there, but I do not understand it.  How do i interpret " {- Arity: 2 HasNoCafRefs Strictness: LSm ..." ?
11:27:33 <_zenon_> @quote Extreme Anger Programming
11:27:33 <lambdabot> No quotes for this person. Wrong!  You cheating scum!
11:27:46 <_zenon_> how do you access it?
11:27:47 <Mitar> i have a question about profiling, if I do let list = unfold 0 complexComputation in dosomething list ... does it count computing this elementis of a list inside of dosomething or outside? so asked otherwise: if I prepare complex values outside the function and then call the function, where i will see those entries in a profiling output?
11:28:03 <Baughn> LordBrain: "Takes two arguments, is lazy in the first and strict in the second"
11:28:04 <byorgey> _zenon_: use . instead of spaces
11:28:26 <_zenon_> @quote Extreme.Anger.Programming
11:28:26 <lambdabot> byorgey says: Extreme Anger Programming: you are paired with a really dumb partner and after twenty minutes of agony you rip the keyboard from their hands, delete everything they typed, and do it
11:28:26 <lambdabot> yourself
11:28:37 <_zenon_> :D
11:28:54 <LordBrain> Baughn, LSm = lazy in the first, strict in the second?  What does the m mean?  If i had 3 arguments all lazy it would be LLLm ?
11:29:26 <Mitar> and another question: total alloc = 127,862,296,380 bytes <<< is this a lot for a short 2 minute long computation?
11:29:46 <Baughn> Mitar: Depends on the computation, but it might be
11:29:49 <Baughn> LordBrain: I'm not sure, actualy. the documentation seems a bit aged
11:29:53 <Mitar> raytracing ...
11:30:09 <Baughn> LordBrain: The m is /probably/ some sort of comment on the return value
11:32:10 <hpaste>  frankblack pasted "(no title)" at http://hpaste.org/8809
11:32:23 <frankblack> hooray
11:32:51 <mauke> foldl? wtf
11:33:02 <frankblack> why not?
11:33:11 <mauke> why not just 'print buf'?
11:33:17 <mauke> or at least use 'concat'
11:33:29 <frankblack> didn't officially learn it yet ;)
11:36:03 <LordBrain> Baughn, do you happen to know what HasNoCafRefs means?
11:36:23 <ptolomy2> >_<  I just figured out that one of the fundamental types in my 3k+ line haskell program needs to be [Foo], not Foo. My "Minor Change -> Send to GHC -> Fix type errors -> repeat" cycle is going to take a while.
11:36:59 <Baughn> LordBrain: Not for certain, but I imagine it means the function has no references to global data - constant applicative forms, that is
11:37:49 <kiris> ptolomy2: should have used a type alias??
11:37:55 <ptolomy2> kiris: For sure.
11:37:58 <Baughn> LordBrain: "fib = 0:1:zipWith(+)fib(tail fib)" is a CAF; if you call a function that uses, say, fib!!1000, memory use will jump then and there even if you proceed to GC the function's result values
11:38:06 <kiris> ptolomy2: lesson learned I guess :P
11:38:26 <Baughn> LordBrain: So this is just a guess, but.. yeah, basically, if it has that wording that might not be possible
11:38:55 <roconnor> ※
11:39:00 <Baughn> LordBrain: (I should say, GC the return values /and the arguments/, which can also expand)
11:39:02 * ptolomy2 looks forward to the days when he learns less things the hard way.
11:39:09 <kiris> roconnor: tetravex?
11:39:13 <maltem> ptolomy2: Rename Foo to Bar, type Foo = [Bar]?
11:39:15 <kiris> ptolomy2: hehe
11:39:37 <roconnor> japanese "rice" star
11:39:57 <kiris> roconnor: ah, I'm eating an english egg custard tart
11:40:21 <roconnor> I'm considering using it to replace my asterisk
11:40:31 <_zenon_> I keep getting this error " No instance for (Show (t -> IO ())) "
11:40:41 <roconnor> and using it for the one contructor of the one element type.
11:40:58 <roconnor> _zenon_: in what context
11:40:59 <LordBrain> _zenon_, in the interpretter?
11:41:04 <ptolomy2> maltem: Most of the work will be changing lots of 'map's to 'concatMap' type things, since things now become potentially 1-many.
11:41:06 <_zenon_> It surely means that there is some function  (a -> IO ()) which is returned?
11:41:07 <Baughn> _zenon_: So you're trying to show something that (a) is a function, and (b) a function that does IO, no less
11:41:10 <LordBrain> _zenon_, it may be you are missing a parameter...
11:41:20 <LordBrain> _zenon_, yes
11:41:48 <LordBrain> _zenon_, if you leave off the last parameter of some IO action, then it is a partial application and returns a function t -> IO ()
11:41:48 <_zenon_> I'll paste it
11:42:01 <roconnor> ✥
11:42:04 <_zenon_> LordBrain: Yeah, I figured it, but can't see it myself =/
11:42:09 <roconnor> woah
11:42:21 <hpaste>  _zenon_ pasted "Partial ? Where?" at http://hpaste.org/8810
11:43:09 <_zenon_> It loads fine in ghci, just that last damned thing
11:43:17 <byorgey> HWN posted!  get it while it's hot! =)
11:43:22 <monochrom> main d ?
11:43:38 <_zenon_> monochrom: RIght!
11:43:51 <_zenon_> Hahahah, I rewrote this some times, totally forgot it!
11:43:58 * _zenon_ slams hand in head
11:44:02 <monochrom> congrats
11:44:09 <LordBrain> lol
11:45:32 <LordBrain> i guess had you written an explicit type signature you would have noticed that.. or the compiler would have at least told you a type mismatch.
11:45:50 <_zenon_> LordBrain: Indeed
11:45:51 <monochrom> No one typesigs main. :)
11:45:52 <Mitar> how can I interpret this?
11:45:53 <Mitar> http://mitar.tnode.com/Temp/Main.ps
11:45:56 <_zenon_> heheh
11:46:13 <Mitar> because viewportDots is: viewportDots = [ViewportDot x y | x <- [0.0..maxX], y <- [0.0..maxY]] :: [ViewportDot]
11:46:14 <_zenon_> Stands to show why you shouldn't be lazy with typesigs on main
11:46:59 <kiris> byorgey: HWN?
11:47:06 <monochrom> Here is why not to typesig main: for a long while you may be changing between "IO ()", "IO Int", "IO haha", "IO String", ...  until it has stabilized there is no point pinning it.
11:47:10 <LordBrain> well chances are if you take the time to write a type sig for main, you already see that it has the right type before you attempt to compile... i suppose we could have a warning for when main isn't the expected IO () type...
11:47:41 <LordBrain> hmmm
11:47:45 <monochrom> main is allowed to be IO (anything you like)
11:47:52 <_zenon_> monochrom: true indeed.... hmmm
11:48:00 <LordBrain> apparently it's even allowed to be t -> IO ()
11:48:11 <PeakerWork> LordBrain: what happens then?
11:48:34 <monochrom> I guess you can always pin it as IO () and always keep a "return ()" at the end.
11:49:55 <PeakerWork> or use main = letMeReturnAnything $ do ...
11:50:00 <LordBrain> PeakerWork, I guess it calls main and evaluates it to t -> IO () and none of your desired side-effects are performed...
11:50:31 <PeakerWork> LordBrain: But it would try to extract the IO operations to do from the IO value and fail to do that...
11:50:42 <PeakerWork> LordBrain: I mean, it should break on type validity
11:51:06 <LordBrain> well it didn't break for _zenon_ ...
11:51:09 <rwbarton> ghc won't let me have main :: t -> IO ().
11:51:21 <rwbarton> _zenon_ was probably just typing main into ghci
11:51:29 <maltem> main  is not neccesarily equal to  Main.main
11:51:35 <_zenon_> rwbarton: Indeed I was.
11:51:37 <byorgey> kiris: Haskell Weekly News
11:51:47 <byorgey> http://sequence.complete.org/hwn/20080709
11:51:48 <lambdabot> Title: Haskell Weekly News: July 9, 2008 | The Haskell Sequence
11:52:29 <LordBrain> _zenon_, you typed it in manually in interactive mode? Or you loaded an hs file into the interpretter which had the definition of main in it?
11:52:31 <esap> It's not completely clear why the type of main needs to be anything else than IO ().
11:52:59 <PeakerWork> esap: it should probably be IO Int for unix return values or such?
11:53:18 <_zenon_> LordBrain: Interactive mode, ghci
11:53:23 <PeakerWork> or do unix-y quirks have no place in Haskell reports?
11:53:27 <lament> main :: [String] -> IO Int
11:53:28 <esap> PeakerWork: Not necessarily. We have 'exitWith' which can be used for that.
11:53:48 <LordBrain> esap, well in dos and unix style operating systems programs can return a number which is an "error-level" available to the shell. so I can see main :: IO Int  making sense...
11:54:13 <kiris> byorgey: ooo
11:54:49 <LordBrain> dos-and-unix-style OS's is pretty much all the major ones in use now...
11:54:56 <esap> Lord: the Haskell report says the value returned from main is ignored :-)
11:55:00 <_zenon_> I love HWN :)
11:55:12 <Zao> @type System.Exit.exitWith
11:55:13 <lambdabot> forall a. GHC.IOBase.ExitCode -> IO a
11:55:34 <Zao> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Exit.html
11:55:35 <lambdabot> Title: System.Exit, http://tinyurl.com/34e7ph
11:55:50 <_zenon_> IST AND UNDERSCORES MAYBE SOME DUTCH AND SPACES ACTUALLY RUN ON THE LOWER CASE HAS APPARENTLY EXISTENTIAL BUT IT SEEMS
11:56:02 <_zenon_> Some output from the logreading program :)
11:56:26 <_zenon_> still needs some tuning, and should do a toLowerCase on it
11:56:32 <magnus_> Is there any hash table that doesn't lock you into the IO monad?
11:56:51 <magnus_> Data.Map is too slow
12:00:31 <byorgey> magnus_: I don't think there is.  what do you mean, Data.Map is too slow?
12:00:33 <LordBrain> magnus_,  i don't know... maybe Data.IntMap is more efficient?
12:00:45 <asdftimo> hey guys, i need help outputting the string "x -> y" to a file, where x<-[1..n] and y=f x. i would like a new line after each print. can someone help?
12:01:32 <byorgey> asdftimo: sure.  first, write a function that takes x as input and outputs the string "x -> y".
12:01:36 <PeakerWork> asdftimo: use show on x and y, and putStrLn to print it?
12:01:54 <byorgey> asdftimo: then, map that function over [1..n] to get a [String]
12:01:59 <_zenon_> which method lists all the files in a filepath?? hmmm
12:02:05 <magnus_> byorgey: comparing it to using hash tables in other languages, it is slow
12:02:06 <byorgey> then output it with  putStr . unlines
12:02:14 <asdftimo> g x = x ++ " -> " ++ (f x)
12:02:28 <byorgey> asdftimo: what type is x ?
12:02:35 <asdftimo> integer
12:02:40 <asdftimo> i mean show x
12:02:43 <byorgey> asdftimo: then you need to do (show x)
12:02:44 <byorgey> right
12:02:53 <byorgey> and maybe  show (f x) too
12:02:56 <PeakerWork> asdftimo: you also probably need to show (f x)
12:03:00 <asdftimo> yeah
12:03:06 <byorgey> asdftimo: ok, looks good
12:03:12 <asdftimo> i just want to know how i can do that for multiple x's
12:03:15 <byorgey> asdftimo: then  map g [1..n]
12:03:21 <byorgey> will give you a list of Strings
12:03:28 <asdftimo> ok
12:03:48 <_zenon_> getDirectoryContents :: FilePath -> IO [FilePath]
12:03:49 <byorgey> then call unlines on that to make one big String with newlines in between all of them, and then putStr that
12:03:52 <_zenon_> there we go :)
12:03:55 <magnus_> LordBrain: using hash keys in an IntMap?
12:04:07 <asdftimo> thanks byorgey.
12:04:19 <byorgey> asdftimo: you're welcome =)
12:05:06 <kiris> anyone know of a graphics library that draws text and returns coordinates of the letters it renders -- or -- a graphics library that gives you access to the image data? the colour of the pixels and whatnot?
12:05:45 <_zenon_> kiris: HGL?
12:06:08 * roconnor reads the SamB quote in HWN
12:06:08 <_zenon_> http://www.haskell.org/graphics/
12:06:08 <lambdabot> Title: HGL: Home
12:06:13 <roconnor> *LOL*
12:06:43 <kiris> I'll see
12:07:32 <LordBrain> magnus_, I see there is a Data.HashTable
12:08:14 <magnus_> LordBrain: yes, but it forces you into the IO monad
12:08:21 <LordBrain> magnus_, i think it's impersistant data, which might allow it to be more efficient tho less convenient for functional programming
12:09:18 <PeakerWork> yuck its in the IO monad :)
12:09:39 <PeakerWork> why not like the MArray thing where you can choose ST or IO or any other instance of something monad?
12:09:53 <magnus_> indeed
12:10:01 <kiris> _zenon_: doesn't look like it will do either of those things
12:10:36 <roconnor> ``A very powerful language such as OCAML allows you to write very short code (they call it "expressive" code) but requires a lot of thought and concentration to write that code so that it works at all.
12:10:39 <LordBrain> well it's concievable to me that data persistence imposes theoretical limitations on the performance of a dictionary...
12:10:56 <magnus_> I don't need data persistence
12:10:59 <LordBrain> not sure if that is true or not...
12:11:15 <_zenon_> kiris: Hm
12:12:45 <PeakerWork> roconnor: Heh
12:12:50 <LordBrain> magnus_, yeah i know... but since haskell is a purely functional language, the only way i know to have impersistence is to put it in IO... right?  or use unsafePerformIO or something crazy...
12:12:57 <kiris> _zenon_: libgd gives you the rectangle around the text drawn, which is good, but I want the actual outline of the glyphs so that I can fit words together more snugly
12:13:05 <PeakerWork> LordBrain: there's the ST monad too
12:13:16 <PeakerWork> LordBrain: not only the IO monad can do destructive writes
12:13:27 <LordBrain> ok..
12:13:44 <kiris> _zenon_: either that, or I would draw the text and the analyse the image's pixels for whitespace
12:13:44 <magnus_> Lunchy: using ST you can have a pure interface and use mutable state internally
12:13:46 <_zenon_> kiris: ahh. ookay, then HGL wont'd do, as you said. no idea =/
12:14:02 <_zenon_> kiris: Yeah, that doesn't sound verry neat :)
12:14:15 <kiris> _zenon_: agreed
12:14:41 <stepcut> LordBrain: clean is also purely functional, but uses uniqueness types to allow for destructive updates to occur (by proving that the old value can never be needed again)
12:14:57 <LordBrain> yeah i know
12:15:18 <LordBrain> i dont know how you would define a uniqueness type in haskell
12:15:22 <augustss> howdy
12:15:39 <LordBrain> Data.HashTable probably predates ST
12:16:03 <stepcut> LordBrain: is that the HashTable that has been deprecated ?
12:16:06 <Philippa> augustss: hi - how goes?
12:16:27 <mar77a> can someone tell me how to read binary data
12:16:32 <augustss> Philippa: singing in the rain.  or something...
12:16:33 <mar77a> how to 'cast' it
12:17:04 <stepcut> mar77a: from an existing format (like PNG), or do you want to serialize / deserialize Haskell expressions?
12:17:11 <kiris> _zenon_: well I'll just play about with libgd for now
12:17:13 <Philippa> augustss: I gather it's been a bit wet out, yeah
12:17:14 <stepcut> well, haskell values
12:17:20 <LordBrain> stepcut, FiniteMap has been depricated, not sure about HashTable
12:17:30 <mar77a> from an existing format which i have the structure
12:17:30 <Philippa> I seem to've settled for writing slides under a roof instead
12:17:41 <_zenon_> kiris: Let me now how it goes! Maybe mail your result to the list. I am sure more people woule like to know how to play with it
12:18:00 <augustss> Philippa: slides are best written inside
12:18:01 <stepcut> LordBrain: ah, maybe I just think it should be depricated :)
12:18:23 <augustss> HashTable should be
12:18:28 <Mitar> any idea where could i find any scene files for http://trappist.elis.ugent.be/~kehoste/Haskell/HRay/ ?
12:18:29 <lambdabot> Title: :: HRay - a Haskell ray tracer ::
12:19:01 <_zenon_> @pl filter (\x -> head x /= '.') x
12:19:01 <lambdabot> filter (('.' /=) . head) x
12:19:22 <matthew-_> how do I go [a,b,c,d,e,f] to [[a,b],[c,d],[e,f]] ?
12:19:23 <kiris> _zenon_: sure ;) I've got a simple page I'm playing with atm: http://chrisdone.com/wordfreq.cgi if you check out the GD docs, it's actually really simple and easy to use: http://hackage.haskell.org/packages/archive/gd/3000.4.0/doc/html/Graphics-GD.html
12:19:29 <LordBrain> if HashTable outperforms Data.Map, then i'm not entirely convinced about deprecating it
12:19:37 <Philippa> augustss: yeah, if you're gonna be miserable then may as well do it properly :-) Besides, trains seem to leak slightly
12:19:57 <LordBrain> i mean... yeah it has it's cons...
12:20:53 <augustss> LordBrain: Data.HashTable has an ugly API.  I'm sure it can be redone in a nicer way
12:20:59 <LordBrain> yeah i agree
12:21:32 <PeakerWork> Data.Hashtable seems to predate type-classes too!
12:21:56 <LordBrain> wow that's old
12:22:00 <LordBrain> heh
12:22:11 <augustss> No, it's not that old
12:22:24 <PeakerWork> I mean that it doesn't use Hash/Eq classes, but instead takes hash/eq functions!  I doubt its really older than classes :)
12:22:31 <gwern> augustss: did you get my question about djinn?
12:22:58 <augustss> gwern: yes, and I answered.  I think my darcs repo is the place to get it.
12:23:06 <stepcut> PeakerWork: taking functions seems better, since you might want to hash the same data-type different ways in different programs ?
12:23:18 <byorgey> mar77a: maybe you want Data.Binary?
12:23:19 <stepcut> PeakerWork: or, even different ways in the same program
12:23:23 <PeakerWork> stepcut: newtype?
12:23:43 <gwern> augustss: but they seem to be different, where are the changes?
12:24:00 <augustss> I don't know
12:24:03 <Mitar> !seen boegel
12:24:19 <augustss> gwern: nobody gave me any patches
12:24:29 <LordBrain> I think generally when someone is programming with a Data.Map, they don't need persistence.. yet do want a functional interface. I guess that's sort of the point of ST.. right?
12:24:34 <byorgey> > takeWhile (not . null) . map (take 2) . iterate (drop 2) $ [a,b,c,d,e,f]
12:24:36 <stepcut> PeakerWork: right. So now I have to define a newtype, wrap and unwrap my data, and define a new class instance, instead of just passing in a different hash function. It would work, but seems annoying.
12:24:36 <lambdabot>  [[a,b],[c,d],[e,f]]
12:24:43 <mar77a> can't find that module byorgey
12:24:44 <gwern> 'Version: 2005.12.14'
12:24:45 <byorgey> matthew-_: ^^^
12:24:56 <Mitar> @seen boegel
12:24:56 <lambdabot> boegel is in #haskell-blah. I don't know when boegel last spoke.
12:24:59 <augustss> gwern: Let me check
12:25:14 <Philippa> augustss: any likelihood you'll drop in at AngloHaskell, btw?
12:25:42 <augustss> Philippa: None.  I'll be in Mongolia.
12:25:49 <gwern> augustss: but that's the problem, you were the one who uploaded http://hackage.haskell.org/cgi-bin/hackage-scripts/package/djinn 'The djinn package (version 2008.1.18)'
12:25:52 <lambdabot> Title: HackageDB: djinn-2008.1.18
12:25:55 <byorgey> mar77a: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/binary
12:25:58 <lambdabot> Title: HackageDB: binary-0.4.2
12:26:00 <mar77a> argh
12:26:09 <mar77a> why isn't this standard
12:26:21 <Philippa> augustss: oh well. Doing anything fun there?
12:26:29 <augustss> gwern: Ah, you're right.  The one on augustsson.net is not up-to-date
12:26:45 <augustss> Philippa: Watching a total eclipse
12:26:45 <byorgey> mar77a: you mean why isn't it bundled with GHC?
12:26:54 <byorgey> mar77a: it's quite standard
12:27:08 <mar77a> okay
12:27:26 <_zenon_> filter (doesFileExist) files
12:27:37 <_zenon_> however... doesFileExist  is   FilePath -> IO Bool
12:27:38 <kiris> filterM
12:27:42 <_zenon_> ah. thx kiris ;)
12:27:45 <kiris> ;)
12:27:50 <byorgey> hm, has no one ever proposed adding a function like 'chunk'  (e.g. chunk 2 [1,2,3,4,5] --> [[1,2],[3,4],[5]]) to the standard libraries?
12:27:57 <_zenon_> don't know why it didn't pass my head ?
12:28:02 <stepcut> byorgey: yes
12:28:02 <byorgey> it's got to be the most frequently asked-for function that isn't there
12:28:13 <augustss> gwern: I'll update the one on augustsson.net
12:28:15 <byorgey> stepcut: ah, do you know if/why it didn't get included?
12:28:18 <stepcut> byorgey: though, maybe not formally
12:28:23 <gwern> augustss: alright
12:28:27 <byorgey> well, formally is what I mean
12:28:33 <byorgey> I know it gets talked about a lot
12:28:34 <augustss> byorgey: It should be added.  I use it all the time
12:28:50 <stepcut> byorgey: check trac, it the process may have been start ~1 month ago
12:29:08 <byorgey> stepcut: ok, I'll check
12:29:08 <Philippa> augustss: cool, have fun!
12:29:21 <stepcut> byorgey: if not, you can have the honor
12:29:26 <byorgey> if it isn't there maybe I will code it up and submit a proposal.
12:29:29 <byorgey> yeah, ok =)
12:29:59 <stepcut> byorgey: it has also been called, inGroupsOf, or similar
12:30:08 <byorgey> yeah, that's also a good name
12:30:12 <stepcut> http://tuukka.iki.fi/tmp/haskell-2008-05-17.html
12:30:13 <lambdabot> Title: haskell-2008-05-17
12:30:39 <LordBrain> is the "real world haskell" beta going to remain online even after the book is published? it is handy sometimes to have a internet reference
12:31:12 <cjb> LordBrain: yes, afaik.
12:31:21 <byorgey> stepcut: what's that?
12:32:20 <augustss> Philippa: I'm sure it will be.  At least if the sky is clear.  About 50% chance.
12:32:30 <augustss> gwern: I've updated it
12:33:05 <stepcut> byorgey: a link to a recent discussion of inGroupsOf, but I think it's not the best link
12:33:33 <mar77a> why can i do something like (\(Just x) -> x) and not (\(IO String x) -> x) ?
12:33:50 <byorgey> mar77a: IO is not a data constructor, it's a type constructor
12:34:11 <mar77a> ah
12:34:24 <mar77a> i guess Maybe isn't a monad :*
12:34:28 <byorgey> mar77a: (\(IO String x) -> ... makes just as much sense as (\(Maybe x) -> ...
12:34:35 <byorgey> Maybe is a monad.
12:34:42 <mar77a> but...
12:34:47 <gwern> augustss: hey, does 'configure' fail for you?
12:34:53 <Philippa> but IO is held abstract - there's nothing to pattern-match on
12:34:58 <mar77a> ouch
12:35:01 <augustss> gwern: no
12:35:12 <Philippa> mar77a: also, Maybe isn't a data constructor. Again, nothing to match on
12:35:21 <Philippa> you'd match on Just or Nothing
12:35:32 <augustss> gwern: how does it fail?
12:35:58 <byorgey> mar77a: does that make sense, or are you still confused?
12:36:00 <augustss> gwern: oh, I know.  It's the new cabal
12:36:02 <mar77a> i got it
12:36:08 <mar77a> but why
12:36:12 <mar77a> can't you pattern match against IO
12:36:15 <augustss> gwern: it doesn't like my kind of version numbers
12:36:19 <RayNbow> data Maybe a {- <-- type constructor -} = Just a | Nothing {- <-- value constructors -}
12:36:43 <RayNbow> data IO a {- <-- type constructor -} = ... {- <-- no value constructors made public -}
12:36:44 <mar77a> you have to use >>= yes or yes
12:37:27 <byorgey> mar77a: right, >>= is the only tool that is given for dealing with IO
12:37:35 <gwern> augustss: your money's no good here?
12:37:44 <mar77a> is it possible to use >>= with the Maybe monad
12:37:47 <byorgey> mar77a: you can't pattern-match against it since none of its data constructors are exported, as RayNbow says
12:37:56 <byorgey> mar77a: yes, it's possible to use >>= with any Monad
12:38:06 <mar77a> how would that work
12:38:10 <augustss> gwern: they decided that 01 is not valid in a version number
12:38:12 <mar77a> > Just 2 >>= id
12:38:13 <lambdabot>   add an instance declaration for (Num (Maybe b))
12:38:17 <Philippa> because every monad has its own >>=
12:38:21 <byorgey> > Just 4 >>= (return . (+1))
12:38:22 <lambdabot>  Just 5
12:38:27 <byorgey> > Nothing >>= (return . (+1))
12:38:28 <lambdabot>  Nothing
12:38:30 <mar77a> confused now
12:38:39 <mar77a> why do you have to inject it into the monad
12:38:44 <mar77a> doesn't >>= "pull it out"
12:38:50 <gwern> augustss: I see. are you going to edit it?
12:38:55 <mar77a> i guess this only applies to IO..
12:38:59 <byorgey> mar77a: but the function on the rhs of (>>=) has to have type  (a -> m b)
12:39:03 <augustss> gwern: yes.  one sec
12:39:08 <byorgey> so it needs to result in a monadic value.
12:39:14 <mar77a> ah
12:39:31 <tromp> > return . (+1) $ 4 :: Maybe Int
12:39:32 <lambdabot>  Just 5
12:39:34 <augustss> gwern: try again
12:39:43 <byorgey> mar77a: since >>= is the only way to get at values computed in the IO monad, it means there's no way to 'escape' the IO monad
12:39:49 <RayNbow> mar77a, are you familiar with OO languages?
12:39:57 <mar77a> yeah i know C++
12:40:00 <byorgey> although for most other monads there is a way to do so (pattern matching, etc.)
12:40:17 <mar77a> i'm guessing it's on purpose byorgey , to make it very strict when seperating pure from impure code
12:40:23 <byorgey> mar77a: exactly.
12:40:36 <frankblack> is there an "easier" functional language that I could learn before haskell?
12:41:01 <cjb> frankblack: lisp
12:41:03 <lament> frankblack: Scheme/SICP could help.
12:41:16 <frankblack> ok
12:41:18 <mar77a> haskell is hard among the functional programming languages?
12:41:19 <lament> (I mean SICP specifically, not just learning Scheme)
12:41:21 <byorgey> I was going to suggest Scheme as well.
12:41:25 <cjb> mar77a: yes.
12:41:40 <rwbarton> frankblack: ML has a large intersection of features with Haskell, while still being strict
12:41:40 <lament> haskell is hard, let's go shopping among the functional programming languages
12:41:57 <_zenon_> mapM fromLog $ filterM doesFileExist files
12:41:57 <mar77a> okay..not surprised really i always take the hardest path
12:42:04 <_zenon_> I don't get it to go properly
12:42:12 <_zenon_> files <- getDirectoryContents "."
12:42:20 <byorgey> @type filterM
12:42:21 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
12:42:31 <frankblack> well if I look ad lisp code it has much less arrows and points and stuff ;)
12:42:57 <byorgey> _zenon_: try  mapM fromLog =<< filterM ...
12:43:10 <RayNbow> mar77a, are you familiar with the concept of encapsulation? Like making certain fields private of a class?
12:43:13 <_zenon_> reverse >>= ... oh, first time for me there :)
12:43:34 <_zenon_> =<< virgin :)
12:43:34 <Mitar> is there any other way to write a Int number in a Haskell code than (1 :: Int)?
12:43:37 <byorgey> _zenon_: well, you could also write it the other way around,  filterM ... >>= mapM fromLog  of course =)
12:43:52 <gwern> augustss: ok, looks good so far, though cabal check is v. unhappy and haddock fails
12:43:58 <_zenon_> byorgey: Compiled :) thx! You even helped me use =<< for the first time!
12:44:06 <byorgey> _zenon_: hehe =)
12:44:11 <byorgey> glad I could help! =)
12:44:22 <_zenon_> hehe, yeah, me 2!
12:44:26 <byorgey> _zenon_: now, do you understand *why* you needed =<< instead of $ ?
12:44:27 <Baughn> Mitar: Only context. Stick it in a function that /wants/ an int..
12:44:43 <Baughn> Mitar: Or define "i = id :: Int -> Int" and say i 1
12:44:47 <Mitar> ^ does not want anything more than int
12:44:57 <Mitar> Float ^ Something
12:45:10 <byorgey> _zenon_: hint: look at the types of filterM and mapM
12:45:19 <Baughn> Mitar: Why do you want to?
12:45:19 <_zenon_> yeah, I am looking at the equations
12:45:36 <Mitar> i would like to quare a floating point :-)
12:45:47 <Mitar> and I find: number ^ (2 :: Int) ugly
12:46:03 <Baughn> So use "number ^ 2", why don't you?
12:46:03 <RayNbow> square x = x * x
12:46:29 <gwern> I say GHC should default to the most specific type when it's a constant... it's not like 2 is going to overflow Int
12:46:43 <Heffalump> @src (^)
12:46:43 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
12:46:44 <Saad_> Isn't (**) for floating point?
12:46:53 <Heffalump> Saad_: it's for floating point exponents
12:47:06 <Saad_> Ah
12:47:09 <Heffalump> if the exponent is integral you can use (^) to avoid stuff with logarithms
12:47:20 <Saad_> I see
12:47:23 <Heffalump> positive integral that is
12:47:28 <byorgey> @type (^)
12:47:29 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
12:47:34 <gwern> augustss: so what is MLJT.hs anyway? (seems broken)
12:47:38 <hpaste>  _zenon_ pasted "Why is file locked?" at http://hpaste.org/8812
12:47:56 <augustss> gwern: there's extra stuff in the repo
12:48:00 <_zenon_> byorgey: Can you throw a goat eye at my paste?
12:48:09 <byorgey> sure, looking at it now
12:48:25 <rwbarton> _zenon_: are you on windows?
12:48:30 <gwern> I mean, Data.Queue? where's that?
12:48:46 <Mitar> Warning: Defaulting the following constraint(s) to type `Integer'
12:48:46 <Mitar>              `Integral t' arising from a use of `^'
12:48:49 <_zenon_> byorgey: Is it because is tries to write sequentially? for each element in a list?
12:48:55 <_zenon_> rwbarton: no, linux.
12:49:04 <Heffalump> Mitar: the compiler may well inline and constant fold it anyway
12:49:06 <byorgey> _zenon_: what does fromLog do?  does it open the files?
12:49:24 <rwbarton> _zenon_: huh. crazy
12:49:25 <_zenon_> byorgey: yes it does.... ahhhhhhhhhh!!!!
12:49:30 <byorgey> _zenon_: hehehe
12:49:38 <_zenon_> byorgey: Bullzeye!
12:49:46 <Mitar> yes, but i do not like warnings :-)
12:49:46 <_zenon_> hehe, you helped me out twice today!
12:49:53 <_zenon_> byorgey++
12:49:57 <byorgey> all in a day's work =)
12:49:58 <Nafai> byorgey tends to be helpful like that
12:50:02 <Saad_> ++?
12:50:05 <_zenon_> @karma byorgey++
12:50:05 <lambdabot> byorgey++ has a karma of 0
12:50:14 <_zenon_> no, how do I ++?
12:50:16 <vixey> byorgey++
12:50:22 <Dzlk> frankblack: I'd suggest getting a copy of The Little MLer and learn ML, get comfortable with things like types, type inference and pattern matching, then come back and learn the bits of Haskell that are specific to Haskell, instead of trying to absorb everything all at once.
12:50:28 <_zenon_> byorgey++
12:50:35 <Nafai> @karma byorgey
12:50:35 <lambdabot> byorgey has a karma of 3
12:50:38 <_zenon_> :)
12:50:54 <_zenon_> You will be reborn as a dolphin soon :)
12:50:56 <_zenon_> :P
12:51:01 <byorgey> oh, sad, my previous karma was erased
12:51:08 <_zenon_> I was reading from the wrong dir
12:51:53 <byorgey> _zenon_: hehe, that would do it
12:51:53 <_zenon_> byorgey: sad
12:52:37 <byorgey> @tell dmwit get your #haskell log analyzer/canonical lambdabot state utility working soon, I need my karma back!!! ;)
12:52:37 <lambdabot> Consider it noted.
12:53:24 <dolio> Woo, code.haskell.org is back.
12:53:48 <rwbarton> I'm curious how you can get "file is locked" on linux unless you're explicitly asking for locking... there is no mandatory file locking AFAIK
12:54:31 <Zao> strace it and see what the runtime does?
12:54:53 <ptolomy2> Hm.. how close does unboxed-type ForeignPtr malloc-using Haskell code compile to the C equivalent?
12:55:37 <MarcWeber> How to temporarely unapply a patch using stgit?
12:56:00 <dolio> ptolomy2: It's slower, I think.
12:56:11 * MarcWeber hides wrong channel
12:56:16 <_zenon_> hmm... I need some lazy file opening
12:56:29 <dolio> ptolomy2: Couldn't tell you why, though.
12:56:38 <_zenon_> *** Exception: ./Logs/08.03.05: openFile: resource exhausted (Too many open files)
12:56:50 <ptolomy2> I find myself wondering just how much control one can get from haskell code using the dirty low-level stuff.
12:57:49 <mar77a> after taking a look at the low level lib
12:57:54 <mar77a> it looks like you can code C with haskell
12:58:01 <dolio> ptolomy2: The current fannkuch benchmark on the shootout uses malloc/foreign pointers/etc. and it runs in 16.6 seconds to C's 5.6, for instance.
12:58:42 <vincenz> Cale: ping
12:58:44 <vincenz> @seen Cale
12:58:44 <lambdabot> Cale is in #ghc, #haskell-overflow and #haskell. I last heard Cale speak 9h 16m 4s ago.
12:58:54 <dolio> It's in even worse shape on the sempron, apparently.
13:00:54 <mauke> hey, I just wrote a select()
13:02:24 <_zenon_> Annyone know how to open several files lazily using mapM and openFile ?
13:02:42 <mauke> I don't think you can open files lazily
13:02:44 <gwern> interleaveIO?
13:02:50 <_zenon_> darnit.
13:03:06 <dolio> ptolomy2: fannkuch is mainly array reads/writes and unboxed arithmetic. I'm not really sure why it's a factor of 3 slower than C.
13:03:09 <rwbarton> ptolomy2: on the other hand the nsieve benchmark also uses foreign pointers and it's at 2.12 seconds versus C's 2.06
13:03:11 <mar77a> okay
13:03:16 <mar77a> time to take a break from haskell
13:03:21 <mar77a> a long one again :p
13:03:24 <mar77a> cya everyone
13:03:25 <byorgey> ok, later mar77a =)
13:03:28 <_zenon_> cya
13:04:28 <vixey> when you have STRef s a what is s?
13:04:39 <Heffalump> a phantom type parameter
13:04:42 <mauke> magic
13:04:52 <vixey> it only exists to make things difficult for me then
13:04:56 <Heffalump> it has to be the same as the s parameter in ST s b
13:05:05 <Heffalump> it exists to stop you doing impure things with runST
13:05:16 <byorgey> vixey: it doesn't actually represent a value.  It just makes sure that you can only use ST in a consistent way.
13:05:27 <_zenon_> okay, so if I can't open files lazily, can I open a file, read it, close it and take the next, strictly?
13:05:38 <vixey> it is stopping me completely -_-
13:05:38 <mauke> sure
13:05:39 <Zao> bracket things, maybe?
13:05:40 <byorgey> _zenon_: yes, that you can do
13:06:02 <Heffalump> vixey: can you hpaste some code?
13:06:04 <byorgey> I forget what the canonical best way to do that is though
13:06:09 <_zenon_> time for a clean recursion then
13:06:11 <byorgey> maybe use Data.Strict?
13:06:22 <byorgey> or some such library
13:06:27 <vixey> Heffalump: I've just got this one line, data Type a = Mutable (STRef s (Maybe (Type a))) | Type a :->: Type a
13:06:30 <byorgey> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/strict
13:06:33 <lambdabot> Title: HackageDB: strict-0.3.2
13:06:42 <Heffalump> vixey: make s a parameter of Type
13:06:43 <vixey> I can't choose an s for it though
13:06:55 <Heffalump> data Type s a = ...
13:07:05 <vixey> but then what do I write for the :->: case?
13:07:11 <Heffalump> just leave out s in that case
13:07:17 <Heffalump> i.e. leave it as it is
13:07:18 <_zenon_> Strict IO operations :) nice
13:07:19 <rwbarton> I'm not necessarily endorsing this... but unsafeInterleaveIO (readFile filename) doesn't work?
13:07:20 <Heffalump> oh, sorry
13:07:27 <Heffalump> Type s a :->: Type s a
13:07:41 <Heffalump> and likewise for the left-hand case where you now have Type a
13:08:05 <byorgey> @slap rwbarton
13:08:05 <lambdabot> why on earth would I slap rwbarton?
13:08:13 <Heffalump> @slap byorgey
13:08:13 * lambdabot will count to five...
13:08:21 <Heffalump> @slap Heffalump
13:08:21 * lambdabot moulds Heffalump into a delicous cookie, and places it in her oven
13:08:28 <byorgey> hm, guess lambdabot likes unsafeInterleaveIO =)
13:08:29 <_zenon_> rwbarton, as little unsafe as possible
13:08:54 <byorgey> heh, moulds
13:08:58 <_zenon_> none at all
13:09:10 <byorgey> I'm used to the 's' in 'ise' but 'moulds' still looks hilarious to me ;)
13:09:15 <_zenon_> @slap rwbarton
13:09:15 * lambdabot beats up rwbarton
13:09:54 <Heffalump> 'lo
13:09:59 <byorgey> rwbarton: anyway, unsafeInterleaveIO (readFile filename) *might* work, but you would also probably end up shooting yourself in the foot
13:10:12 <rwbarton> byorgey: Yes, quite likely
13:10:13 <TomMD> That always feels nice....
13:10:19 <ndmitchell> ho Heffalump
13:10:22 <vixey> oh!
13:10:27 <vixey> I understand now
13:10:29 <ndmitchell> @seen dcoutts
13:10:30 <lambdabot> I haven't seen dcoutts.
13:10:32 <_zenon_> I've never used stuff from hackage
13:10:37 <ndmitchell> @seen dcoutts_
13:10:38 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell-overflow, #ghc and #haskell. I don't know when dcoutts_ last spoke.
13:10:43 <Heffalump> if you see him tell him to come to AngloHaskell :-)
13:10:50 <ndmitchell> will do :)
13:10:50 <vixey> you may not have any value escape from ST which has an 's' in its type
13:10:55 <ndmitchell> think i am very likely coming myself
13:10:56 <Heffalump> vixey: exactly.
13:10:58 <Baughn> rwbarton: Well, the real problem is a greater chance of getting an exception in pure code. If the file doesn't exist..
13:11:12 <byorgey> _zenon_: need help installing something?  or just making an observation?
13:11:16 <vixey> so I need a frozen version
13:11:34 <_zenon_> byorgey: pretty mutch from scratch -> usable :)
13:11:39 <Heffalump> vixey: a frozen version in what sense?
13:11:44 <_zenon_> I usually just apt-get the libs
13:11:49 <kiris> I am so using Data.MarkovChain for a λb “random #haskell person” generator
13:11:49 <ndmitchell> i'm just about to implement hoogling on multiple packages at once, and was going to ask duncan advice first...
13:12:15 <vixey> like this data Type' = Var' Ident | Type' :~>: Type'
13:12:17 <ndmitchell> it seems hoogle will need to be given the dependencies of a package to generate a database, if it wants a robust package
13:12:44 <vixey> and Type' s a -> Type'
13:12:45 <mauke> does no one need select(2) in haskell? :/
13:12:58 <ndmitchell> was wondering how cabal would want to deal with that - anyone any obvious thoughts? (package management style cabal stuff is still too confusing for me)
13:13:12 <Heffalump> mauke: I think the RTS uses it under the hood. You just need to use threads appropriately and you'll get the right effect.
13:13:22 <mauke> Heffalump: oh, I did
13:13:26 <Heffalump> vixey: I don't follow
13:13:35 <Mitar> why I cannot do: data 2 = (2 :: Int)
13:13:41 <mauke> Heffalump: it's implemented using Control.Concurrent
13:13:49 <Heffalump> mauke: I'm not 100% certain of this but I think I looked at the source some time ago and concluded that it would do the right thing
13:13:53 <byorgey> _zenon_: well, usually you can just download the .tar.gz file, unpack it, and then do:  runhaskell Setup configure && runhaskell Setup build && sudo runhaskell Setup install
13:14:09 <vixey> if I want to create a Type but I can't return it, I have to freeze a version into a type Type' that doesn't have s
13:14:14 <vixey> in it's type...
13:14:19 <_zenon_> byorgey: I'll go from there then
13:14:35 <Heffalump> vixey: if you hide the s using existential types, then the STRefs will become useless.
13:14:40 <vixey> Mitar: 2 is not a constructor name
13:14:41 <byorgey> _zenon_: even better, if you install the cabal-install package in that way (you may also need to install zlib and maybe one other thing ?), then after that you can install packages by simply typing 'cabal install foo'
13:14:50 <Mitar> how is 2 then defined?
13:14:50 <dons_> http://www.reddit.com/info/6r08p/comments/
13:14:51 <byorgey> _zenon_: cabal-install is like apt-get for hackage
13:14:52 <lambdabot> Title: reddit.com: Haskell Weekly News: ICFP contest, HCSound, Language.C parsing in Ha ...
13:15:01 <_zenon_> byorgey: ahh,, okay
13:15:07 <Mitar> @ty (^)
13:15:08 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
13:15:11 <byorgey> _zenon_: i.e. it will download packages, chase dependencies, etc. automatically
13:15:17 <Heffalump> Mitar: internally to the compiler
13:16:51 <rwbarton> Mitar: '2' in a Haskell program is syntactic sugar for 'fromInteger 2#' where '2#' is my made-up syntax for 2 :: Integer
13:17:20 <Mitar> so I could do 2$ :: Int?
13:17:27 <rwbarton> > 2 :: Int
13:17:28 <lambdabot>  2
13:17:31 <vixey> 2$ is not a constructor name
13:17:36 <vixey> Mitar: try 'Two'
13:17:40 <_zenon_> byorgey: No error produced,
13:17:47 <rwbarton> (I didn't really understand your question about 'data 2...')
13:17:47 <Mitar> 2$ = 2 :: Int
13:17:49 <_zenon_> byorgey: Just import?
13:17:58 <rwbarton> two = 2 :: Int  is fine
13:18:05 <byorgey> _zenon_: sorry?
13:18:16 <_zenon_> byorgey: It went fine, no errors. nothing
13:18:40 <zachk> is it silly to use haskell source code as a save file for a haskell app?
13:18:48 <byorgey> _zenon_: oh, great.  then yes, you should be able to just import any of the modules exported by that package
13:19:06 <misterbeebee_> has anyone written a tutorial on using the ghc heap profiler and understanding program memory usage? I've read the ghc docs and I can generate and view a profile, but I tend to get in situations like "OS reports 500MB use, heap profiler diagram shows 50 MB in detail, and names the worst-offending top-level function, but I don't know quite what that memory is (is it a deep unevaluated chain of expressions, a tree of 
13:19:17 <byorgey> zachk: no.
13:19:18 <Heffalump> zachk: not really, read/show is very convenient
13:19:22 <stepcut> is there a way to something like, {-# OPTIONS_GHC -ipages #-} that actually works ?
13:19:25 <Mitar> how ugly
13:19:26 <Mitar> x' ^ (2 :: Int) + y' ^ (2 :: Int) + z' ^ (2 :: Int) <= r ^ (2 :: Int)
13:19:48 <Heffalump> Mitar: why are you insisting on Int?
13:19:48 <vixey> instaed of that write
13:19:55 <vixey> x' ^ 2 + y' ^ 2 + z' ^ 2 <= r ^ 2
13:19:55 <Heffalump> and anyway, why not just say default Int in your module?
13:19:56 <byorgey> misterbeebee_: have you read the pages about profiling on the wiki?
13:20:00 <_zenon_> byorgey: module main:Data.Strict is not loaded
13:20:06 <Mitar> but then i get a warning
13:20:10 <Mitar> about Integer type of 2
13:20:23 <gwern> > let forkbomb n = forkbomb (2*n) `par` forkbomb (2*n+1)  in forkbomb 1
13:20:25 <lambdabot>  Tried to use too much memory
13:20:30 <Mitar> i would really like to write only 2
13:20:49 <misterbeebee_> byorgey: haha yes: http://haskell.org/haskellwiki/How_to_profile_a_Haskell_program#Determine_what_is_wrong
13:20:51 <lambdabot> Title: How to profile a Haskell program - HaskellWiki, http://tinyurl.com/2ozzyz
13:20:52 <vixey> Mitar,
13:20:54 <vixey> x' ^ 2 + y' ^ 2 + z' ^ 2 <= r ^ 2
13:20:55 <byorgey> Mitar: and why can't you?
13:20:58 <misterbeebee_> [edit] 4.2 Determine what is wrong [edit] 4.3 Fix your code
13:21:08 <vixey>  where (^) :: Int -> Int -> Int
13:21:10 <misterbeebee_> not much detail in the ciritical part there :(
13:21:10 <byorgey> misterbeebee_: ah, hehe
13:21:18 <Mitar> Warning: Defaulting the following constraint(s) to type `Integer'
13:21:20 <vixey>        (^) = (Prelude.^)
13:21:25 <rwbarton> You could import Prelude hiding ((^)) and define (^) with a restricted type
13:21:29 <Mitar> `Integral t' arising from a use of `^'
13:21:31 <_zenon_> byorgey: I try to load the modules, but I get an error saying "module not loaded"
13:21:39 <byorgey> _zenon_: hum
13:21:42 <vixey> Mitar, what about that idea ?
13:21:48 <Mitar> interesting ...
13:21:51 <byorgey> _zenon_: if you do 'ghc-pkg list' at the prompt, is 'strict' listed?
13:22:04 <Mitar> ok, but is x ^ 2 faster then x * x ?
13:22:26 <vixey> x^2 takes the same time as x*x
13:22:26 <rwbarton> No, it's slower
13:22:35 <rwbarton> (possibly, I don't really know for sure)
13:22:50 <_zenon_> strict-0.3.2
13:22:55 <_zenon_> byorgey: seems so
13:23:30 <tromp> :t (^)
13:23:31 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
13:23:35 <dolio> What's with the "functional programming is almost dead" article in HWN? :)
13:23:39 <Mitar> vixey, why?
13:23:47 <mauke> > x ^ 2
13:23:47 <lambdabot>  x * x
13:23:49 <misterbeebee_> my programs could have one stupid foldl instead of foldl', or the equivalent in a hand-written loop, but I just can't see where they are....
13:24:05 <byorgey> _zenon_: when you say you try to load the modules, what do you mean?  do you mean in ghci, or did you put an 'import' line at the top of your source file?
13:24:08 <tromp> @src (^)
13:24:08 <lambdabot> Source not found. Maybe you made a typo?
13:24:17 <tromp> @src Int (^)
13:24:17 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
13:24:24 <vixey> Mitar: any measurable differences are so negligible they will fluctuate
13:24:40 <byorgey> _zenon_: note that ghci does weird things if you run it from a directory with source code of a module which is also installed, and try to load that module
13:24:53 <_zenon_> byorgey: It works now...... I did it manually with :m
13:24:57 <byorgey> somehow, finding the module installed AND finding the source code confuses it
13:25:04 <byorgey> _zenon_: ok, good =)
13:25:17 <byorgey> _zenon_: oh, did you do :load before?
13:25:47 <_zenon_> byorgey: No. No load.      However, now I just use the stricts as normal?
13:26:39 <byorgey> _zenon_: I don't know, look at the docs: http://hackage.haskell.org/packages/archive/strict/0.3.2/doc/html/System-IO-Strict.html
13:26:42 <lambdabot> Title: System.IO.Strict, http://tinyurl.com/58xunw
13:26:49 <byorgey> looks like you should import System.IO.Strict instead of System.IO
13:26:52 <_zenon_> byorgey: ok, thx!
13:26:55 <_zenon_> byorgey++
13:28:41 <_zenon_> okay
13:33:05 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/8813#a2
13:33:06 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/8813#a3
13:35:31 <monochrom> Dear anonymous, the recursive call to getline should not be so early. At present you are asking for an infinite loop.
13:36:00 <monochrom> Oh sorry, misread.
13:36:09 <monochrom> But do change getline to getLine
13:36:32 <stepcut> Does cpp have something like #include, except it will insert the file verbatim, without attempting to preprocess it ?
13:36:33 <vixey> is it silly to use StateT ST ?
13:37:08 <monochrom> Unlike C, "return" is not a keyword. It is a function.  Therefore, "return x + y" is parsed as "(return x) + y", clearly the opposite of your intention.
13:38:04 <mauke> stepcut: the preprocessor is C's lexer. it outputs a stream of tokens
13:38:05 <_zenon_> uuuuhhh...tired.
13:38:09 <_zenon_> soon bed
13:38:09 <kiris> monochrom: yeah, I told him those things ;), and not to announce the pastes
13:38:17 <quicksilver> vixey: not necessarily silly.
13:38:34 <quicksilver> vixey: I use StateT IO quite often in preference to IORefs
13:38:42 <monochrom> Oh announce is fine.  Just bloody damn sign them!  Don't say "anonymous".
13:39:39 <gwern> @pl replace a b c = map (\x -> if x == a then b else x) c
13:39:39 <lambdabot> replace = (map .) . flip flip id . (ap .) . flip . (if' .) . (==)
13:39:47 <gwern> eek
13:40:02 <gwern> monochrom: what, Anonymous doesn't code haskell?
13:40:08 <kiris> monochrom: well, I don't want someone not even in this channel to announce pastes when (s)he is not asking for feedback \_o_/
13:40:37 <gwern> any shorter way of writing replace, btw?
13:40:43 <monochrom> Ooops.  Don't you love unsolicited advice. :)
13:41:20 <kiris> monochrom: only when nobody can hear it :P
13:41:51 * monochrom goes to a forest and continue lecturing.
13:42:34 <kiris> hehe. hmm, reminds me of a dilbert post about people giving their criticisms but not helping or when it's unwanted
13:42:35 <byte-> ok, quick parsec question
13:42:38 <kiris> anyone remember the title of that?
13:42:48 <monochrom> Oh these days there is an alternative to forest. It is called "blog".
13:43:20 <kiris> quite so
13:43:25 <gwern> monochrom: does your lecture contain any noble truths we should know?
13:44:08 <monochrom> Hahaha great name for a blog site: "If I blog in a forest, does it make a sound? does it take up bandwidth?"
13:44:32 <monochrom> I don't know whether it contains noble truths yet.
13:44:51 <gwern> hm. I want a QC proprety for replace, but i can't do (id z == replace y x $ replace x y z) because replace is lossy...
13:44:52 <kiris> does it get comments?
13:45:02 <kiris> and spam?
13:45:14 <byte-> between using a 'try' block within 'many', or wrapping up the return value in a container and concat'ing the result, which would be "preferred"?
13:45:16 <kiris> do I need a CAPTCHA? ok, enough
13:45:32 <byte-> if i used try i would essentially be wrapping most of the grammar in it
13:45:35 <gwern> I wish i had a blog popular enough to need a captcha
13:45:46 <ndmitchell> byte-: second, always
13:45:55 <byte-> but using bogus lists to sort out 'null' values seems a bit odd
13:46:12 <ndmitchell> byte-: data Maybe a = Just a | Nothing
13:46:22 <byte-> but then i can't just concat the results ;)
13:46:34 <mauke> :t catMaybes
13:46:35 <lambdabot> forall a. [Maybe a] -> [a]
13:46:36 <byte-> i suppose i could filter (/=Nothing)
13:46:42 <ndmitchell> @hoogle [Maybe a] -> [a]
13:46:43 <lambdabot> Data.Maybe.catMaybes :: [Maybe a] -> [a]
13:46:52 <byte-> or i could use that
13:47:04 <ndmitchell> :t mayMaybe
13:47:04 <lambdabot> Not in scope: `mayMaybe'
13:47:06 <byte-> is try really that expensive?
13:47:26 <ndmitchell> byte-: think of it as free (its certainly cheaper than concat)
13:47:40 <byte-> so why shouldn't i use it?
13:47:52 <ndmitchell> :t mayMaybes
13:47:52 <lambdabot> Not in scope: `mayMaybes'
13:48:03 <ndmitchell> byte-: you should use it :)
13:48:12 <gwern> :t motherMayI
13:48:12 <lambdabot> Not in scope: `motherMayI'
13:48:25 <mauke> :t mapMaybe
13:48:25 <lambdabot> forall a b. (a -> Maybe b) -> [a] -> [b]
13:48:26 <ndmitchell> :t mapMaybes
13:48:27 <lambdabot> Not in scope: `mapMaybes'
13:48:43 <byte-> ndmitchell: ok then
13:48:44 <byte-> thanks
13:48:45 <ndmitchell> if you want catMaybes, often you may also want mapMaybe at some point
13:48:57 <ndmitchell> i'd recommend reading the whole Data.Maybe module, its fairly short and has a lot of good stuff in it
13:50:07 <gwern> aha, if I filter out anything with the target item in it, then replace is non-lossy
13:50:17 <gwern> partialIdemPotentProp x y z = if y `elem` z then True else (id z == (replace y x $ replace x y z))
13:51:30 <mauke> ==>
13:51:32 * gwern wonders what other properties a good replace should have
13:51:51 <_zenon_> Maybe monad
13:51:55 <_zenon_> maybe?
13:51:58 <_zenon_> ;)
13:52:10 <gwern> I find this is actually a problem for me when doing QC stuff. if I don't have a model to test against, what sorts of properties should I be checking for?
13:52:15 <byte-> hmm
13:52:24 <dons> idempotency
13:52:30 <dons> all good things are idempotent
13:52:48 <_zenon_> really?
13:52:50 <_zenon_> hehe
13:52:59 <gwern> I mean, prop x = oldLines x == newLines x is basically the only proprety you need in that situation, but everything else I find myself unsure in
13:53:13 <gwern> dons: alas, replace isn't totally idempotent, just for a subset
13:53:17 <kiris> monochrom: found it http://web.archive.org/web/20060417131125/http://dilbertblog.typepad.com/the_dilbert_blog/2006/04/helpful_critica.html
13:53:19 <lambdabot> Title: The Dilbert Blog: Helpful Critical Guy Syndrome, http://tinyurl.com/5s4ym6
13:53:20 <gwern> replace 'a'
13:53:27 <gwern> '\n "foo a a \n"
13:53:33 <gwern> if you follow
13:54:12 <hpaste>  laz0r pasted "moar yampa..." at http://hpaste.org/8814
13:54:33 <laz0r> ^ if someone has any suggestions, i would be very happy
13:54:33 <_zenon_> gnite
13:54:38 <gwern> that is, replace x y z - if y is already in z, then all the xs become y, and to undo it, you need to turn all the ys back into x, but then you no longer have the original z
13:54:50 <laz0r> this yampa is definatly making my head hurt in bad ways
13:55:08 <rwbarton> idempotent means something else: f is idempotent if f . f == f
13:55:28 <laz0r> but it's cool, i think if would understand it, it could be really usefull
13:55:38 <rwbarton> (which is true for f = replace a b)
13:55:39 <gwern> rwbarton: oh, does it? I thought it mean you could undo something
13:55:49 <rwbarton> That's invertible
13:56:29 <gwern> well, nm. replace is eminently idempotent then if I follow
13:58:57 <byte-> is there a library function that does ">> return ()" ?
13:59:04 <byte-> or do i have to name it myself?
13:59:24 <monochrom> Not in library.
13:59:31 <vixey> StateT [String] (ST s) (Type ())
14:01:03 <vixey> thatis my monad
14:01:44 <plutonas> how do i write a frac in haskell?
14:01:51 <vixey> but how come I can't type runST . withGensyms typs ?
14:01:53 <byte-> frac = fraction?
14:01:58 <xd_> > 1%2
14:02:04 <lambdabot>  1%2
14:02:13 <byte-> > 1%2 * 3%4
14:02:14 <lambdabot>   add an instance declaration for (Integral (Ratio t))
14:02:18 <byte-> bah
14:02:22 <vixey> Inferred type is less polymorphic than expected
14:02:30 <vixey> what do you do about this ?
14:02:35 <byte-> > 1%2 + 3%4
14:02:36 <lambdabot>  5%4
14:02:50 <plutonas> why do i get not in scope: `%'
14:02:51 <plutonas> ?
14:02:59 <byorgey> plutonas: import Data.Ratio
14:03:04 <plutonas> oh
14:03:15 <ddarius> vixey: impredicativity, or the lack thereof
14:04:35 <vixey> isn't this odd though ?
14:04:38 <vixey> *Main> :t runST (withGensyms typs test)
14:04:39 <vixey> runST (withGensyms typs test) :: Type ()
14:04:39 <vixey> *Main> :t \x -> runST (withGensyms typs x)
14:04:39 <vixey> <interactive>:1:6: Inferred type is less polymorphic than expected
14:05:35 <rwbarton> vixey: Try putting a type annotation on x?
14:06:44 <Saizan> vixey: that's because lambda-bound variables are monomorphic unless annotated, i.e. predicative by default
14:08:46 <vixey> @hoogle unsafeCoerce
14:08:46 <lambdabot> Unsafe.Coerce.unsafeCoerce :: a -> b
14:09:40 <zachk> mmmm that sounds just unsafe
14:10:03 <monochrom> Hehe
14:10:14 <Japsu> segfault cat is watching you unsafeCoerce
14:10:23 <monochrom> There are a few prudent usages.
14:10:36 <monochrom> @remember Japsu segfault cat is watching you unsafeCoerce
14:10:36 <lambdabot> Good to know.
14:10:39 <vixey> runInfer :: StateT [[Char]] (ST s) (Type ()) -> Type ()
14:10:39 <vixey> runInfer action = runST (unsafeCoerce (withGensyms typs action) :: ST s (Type ()))
14:10:46 <vixey> any ideas how to better write this?
14:10:58 <Japsu> lol
14:11:06 <Heffalump> vixey: umm. Ewww.
14:11:18 <Baughn> vixey: ..what types are you coercing here?
14:11:19 <Heffalump> you need to stop hiding your s parameter.
14:11:28 <Heffalump> and t stop trying to let STRefs escape your runST.
14:12:01 <vixey> Baughn: I have no idea, when I get type problems I just put unsafeCoerce in the cracks and it works again
14:12:03 <Heffalump> Baughn: I suspect the 's' parameters to STRefs
14:12:12 <Heffalump> vixey: at the cost of runtime safety..
14:12:40 <vixey> Heffalump: what runtime safety?
14:12:40 <vixey> is it possible for a use of runInfer to crash ?
14:12:43 <Baughn> vixey: ..even if you are kidding, that statement makes me queasy
14:13:15 <Heffalump> vixey: I'm not sure, it depends if runST can recycle heap cells after its finished even if there are still references to them.
14:13:25 <vixey> oh I see what you mean
14:13:27 <Heffalump> But even if it can't, you are violating functional semantics by allowing the references to leak.
14:13:45 <Heffalump> The whole point of the type of runST is that it stops STRefs from leaking out, as you said earlier.
14:13:58 <vixey> yeah it's a very awkward thing
14:13:59 <Heffalump> And that's crucial because otherwise runST something isn't a pure computation.
14:14:01 <monochrom> runInfer:: (forall s. StateT [[Char]] (ST s) (Type ())) -> Type ().  Cf. the 2nd rank type of runST
14:14:32 <Heffalump> monochrom: Type should have an 's' in it. Vixey was talking about hiding them earlier.
14:14:41 <Heffalump> In particular Type embeds STRefs
14:14:49 <vixey> omg
14:15:03 <vixey> monochrom wow. ..
14:15:03 <vixey> that works
14:15:15 <vixey> you know I had tried that but without the ()'s
14:15:17 <profmakx> @hoogle runWebReq
14:15:18 <lambdabot> No matches found
14:15:18 <monochrom> What are the details of Type?
14:15:19 <Heffalump> really? What's the definition of Type now?
14:15:35 <vixey> runInfer:: (forall s. StateT [[Char]] (ST s) (Type ())) -> Type ()
14:15:35 <vixey> runInfer action = runST (withGensyms typs action)
14:15:35 <vixey> thank you
14:15:36 <vixey> this is great
14:15:54 <monochrom> Perhaps Type doesn't contain STRef anymore. :)
14:16:04 <Heffalump> I hope not!
14:16:29 <Saizan> well
14:16:38 <monochrom> It may contain STRef but protected by another level of forall s, legitimate and fine.
14:16:47 <Saizan> it contains them, but that type doesn't let you use those STRef
14:16:54 <Heffalump> sure, but then Type () will be usless later on.
14:17:04 <Heffalump> at least the STRefs in it will be unusable.
14:17:52 <Saizan> that's fine though, you can still use values of Type with STRefs inside action, but at the end strip them away
14:19:04 <Trinithis> how can i create an infinite random list? or would it be easier to use a stream instead of a list?
14:19:18 <monochrom> stream = list.
14:19:22 <dons> > randomRs (1,5) :: [Integer]
14:19:22 <lambdabot>  Couldn't match expected type `[Integer]'
14:19:22 <monochrom> @type randoms
14:19:23 <lambdabot> forall g a. (RandomGen g, Random a) => g -> [a]
14:19:33 <Trinithis> ah
14:19:36 <dons> > randomRs (mkStdGen 42) (1,5) :: [Integer]
14:19:37 <lambdabot>  Couldn't match expected type `(Integer, Integer)'
14:19:40 <monochrom> http://www.vex.net/~trebla/haskell/random.xhtml  :)
14:19:41 <dons> :t randomRs
14:19:41 <lambdabot> forall a g. (RandomGen g, Random a) => (a, a) -> g -> [a]
14:19:49 <dons> > randomRs (1,3) (mkStdGen 42)  :: [Integer]
14:19:50 <Trinithis> randoms is what i want
14:19:53 <lambdabot>  [3,1,2,2,3,2,1,3,1,1,1,1,1,3,3,2,3,2,1,1,3,1,1,2,2,2,1,3,3,1,2,3,1,3,2,1,1,3...
14:20:00 <Trinithis> thanks
14:20:38 <mm_freak> i wonder whether IO works at all in lambdabot
14:20:46 <mm_freak> > 3
14:20:47 <lambdabot>  3
14:20:58 <mm_freak> :t threadDelay
14:20:59 <monochrom> IO is banned in lambdabot for security.
14:20:59 <lambdabot> Not in scope: `threadDelay'
14:21:04 <mm_freak> hmm
14:21:06 <kiris> just realised I haven't had any caffeine for more than 5 months. if I had some now I'd be buzzing
14:22:17 <Baughn> > deleteFile "/etc/passwd"
14:22:18 <lambdabot>   Not in scope: `deleteFile'
14:22:22 <Baughn> ..aww
14:26:37 <profmakx> anyone got an idea what Module contains runWebReq?
14:27:09 <profmakx> building lambdabot becomes increasingly painful because noone seems to check whether it builds from a fresh darcs checkout
14:27:09 <Baughn> profmakx: Nope. Where did you get the idea that such a function exists?
14:27:23 <profmakx> lambdabot -> plugin Url.hs
14:27:30 <kiris> profmakx: Url.hs
14:27:31 <Baughn> To the contrary. I always build from a fresh checkout - and it does
14:27:42 <kiris> profmakx: lambdabot-utils/Url.hs
14:27:49 <profmakx> oh well
14:27:56 <profmakx> should have thought of that
14:28:02 <profmakx> but i wonder why grep didnt spit it out
14:28:52 <profmakx> is there a particular reason why lambdabot-utils has been separated from lambdabot?
14:29:31 <kiris> profmakx: for that reason I have two repos. one which is the fresh repo and one with all my personal crap
14:29:36 <oldsalt> if i instantiate Binary, how can i use the IO monad in the get function?
14:30:12 <profmakx> kiris, i do it the same way
14:30:32 <plutonas> i have a recursive function when that in the final cases returns Nothing, in some of the cases before it returns (Just 'character here')
14:30:46 <kiris> profmakx: I made the runWebReq function so I apologise profusely :P
14:31:05 <plutonas> i want in the end to return a concatenation of the characters when Just is returned, but Nothing in the end makes all Nothing
14:31:13 <profmakx> kiris, its okay i have just f*** up the build here i suppose
14:31:25 <plutonas> i don't know how well i explained it, but any ideas how to solve that?
14:31:25 <shadadelic> 4+6
14:31:42 <kiris> > 4+6
14:31:43 <lambdabot>  10
14:32:08 <kiris> plutonas: perhaps `maybe'?
14:32:11 <kiris> :t maybe
14:32:12 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
14:32:13 <kiris> @src maybe
14:32:14 <lambdabot> maybe n _ Nothing  = n
14:32:14 <lambdabot> maybe _ f (Just x) = f x
14:32:40 <Baughn> plutonas: map fromJust . filter (/= Nothing), perhaps?
14:32:50 <profmakx> hm
14:32:51 <Baughn> I'm not quite sure what you're starting with here
14:32:59 <profmakx> gna. who moved the --global option around
14:33:04 <plutonas> hm, let me check both and think about them thanks
14:33:15 <ddarius> :t concat . catMaybes
14:33:15 <lambdabot> forall a. [Maybe [a]] -> [a]
14:33:16 <kiris> Baughn: catMaybes does that
14:33:28 <Baughn> kiris: Probably without requiring an Eq instance, too
14:33:59 <kiris> Data.Maybe<33
14:34:45 <dolio> @type mconcat . mconcat
14:34:46 <lambdabot> forall a. (Monoid a) => [[a]] -> a
14:35:01 <rwbarton> I wonder if sequence is what's wanted?
14:35:08 <rwbarton> > sequence [Just 3, Just 4, Just 5]
14:35:09 <lambdabot>  Just [3,4,5]
14:35:15 <rwbarton> > sequence [Just 3, Nothing, Just 5]
14:35:16 <lambdabot>  Nothing
14:35:25 <kiris> > mconcat . moncat $ ["hello"]
14:35:26 <lambdabot>   Not in scope: `moncat'
14:35:32 <kiris> > mconcat . mconcat $ ["hello"]
14:35:33 <lambdabot>   add an instance declaration for (Monoid Char)
14:35:48 <kiris> > mconcat . mconcat $ [[1..4]]
14:35:48 <lambdabot>  Add a type signature
14:35:52 <kiris> sod it
14:36:07 <dolio> > mconcat . mconcat . map (map Product) $ [[1..4]]
14:36:08 <lambdabot>  Product {getProduct = 24}
14:36:11 <Japsu> mcon-cat haz a type
14:36:41 <qwr> does ghc runtime ever shrinks its memory usage?
14:36:48 <plutonas> kiris: actually my function returns type [Maybe a]
14:37:06 <kiris> plutonas: mmkay?
14:37:26 <Baughn> plutonas: So, do you want catMaybes or sequence?
14:37:45 <gwern> qwr: I vaguely recall some OS-related problem which doesn't let it
14:37:57 <ziman> > sequence [Just 3, Nothing, Just 4]
14:37:58 <lambdabot>  Nothing
14:38:50 <Baughn> qwr: I'm not much less vague, but I think the problem is that it's hard to tell (most) OSs to /shrink/ an mmap
14:39:33 <qwr> yes. i guessed it could do multiple mmaps for memory blocks.
14:39:55 <plutonas> Baughn: no idea
14:40:29 <qwr> of course the real problem is that i have stupid code ;)
14:40:32 <Baughn> qwr: I may be mistaken. mremap seems to allow shrinking.
14:40:40 <Baughn> Oh, but it's GNU only
14:40:42 <Baughn> There we go, then
14:41:17 <Baughn> plutonas: Well, what behaviour do you want?
14:41:28 <Baughn> > catMaybes [Just 1, Nothing, Just 3]
14:41:29 <lambdabot>  [1,3]
14:41:38 <Baughn> > sequence [Just 1, Nothing, Just 3]
14:41:38 <qwr> but i hoped, that the temporaryle wasted memory could eventually get free ;)
14:41:39 <lambdabot>  Nothing
14:41:43 <Ben`> is it possible to change the user-agent Text.HTML.Download.openURL uses?
14:41:52 <Baughn> qwr: Well, it'll get swapped out eventually if that helps
14:42:07 <dons> Ben`: hmm. not without hacking the code.
14:42:32 <Ben`> ok, it's just that it doesn't seem to work with Google
14:42:36 <Ben`> is that a known problem?
14:43:04 <dons> hmm. really?
14:43:07 <dons> oh, it redirects?
14:43:15 <kiris> depends if openURL deals with redirects which I expect your use of Google might do? what URL are you using?
14:43:28 <dons> tagsoup's download is considered a toy, afaik. if it works, that's nice, but neil's only put it in there for convenience.
14:43:39 <dons> you might want to use the download or download-curl bindings , for a more thorough soution
14:44:13 <kiris> indeed.. Network.HTTP or Network.Curl
14:44:54 <kiris> Network.Curl is actually really easy to use, I was pleasantly surprised ^_^
14:45:04 <Ben`> oh sorry, I have it working now. i thought it would automaticly follow redirections
14:45:38 <kiris> ah
14:46:09 <kiris> =]
14:46:54 <ndmitchell> Ben`: Text.HTML.Download.openURL won't even work against all web servers, its incredibly fragile!
14:47:14 <ndmitchell> I may move it to Text.HTML.Download.BadIdea.openURL for the next release...
14:47:55 <Ben`> heh, well it now seems to be working fine for me :)
14:48:42 <draft> hi
14:49:38 <draft> i'm beginning to learn haskell following this http://www.haskell.org/~pairwise/intro/intro.html with ghc. however when i do "a = 5", i get from ghc(i) : <interactive>:1:2: parse error on input `=', why please ?
14:49:39 <lambdabot> Title: Haskell for C Programmers
14:50:01 <Baughn> draft: It's "let a = 5"
14:50:02 <tromp> try let a=5
14:50:16 <tromp> as in a monad
14:50:31 <dons> ?let a = 5
14:50:31 <lambdabot> Defined.
14:50:33 <dons> > a
14:50:34 <lambdabot> Terminated
14:50:37 <dons> > a + a
14:50:37 <lambdabot> Terminated
14:50:43 * Baughn whacks dons
14:50:45 <dons> > 1 + 2
14:50:46 <lambdabot>  3
14:50:50 <dons> > 1 + a
14:50:50 <lambdabot> Terminated
14:50:53 <dons> ?undefine
14:50:54 <lambdabot> Undefined.
14:50:57 <dons> ?let a = 42
14:50:57 <lambdabot> Defined.
14:50:59 <dons> > a + 1
14:51:00 <lambdabot> Terminated
14:51:02 <dons> ?undefine
14:51:03 <lambdabot> Undefined.
14:51:04 <dons> weird.
14:51:05 <Baughn> ?undefine
14:51:06 <lambdabot> Undefined.
14:51:06 <vixey> > let a' = 43
14:51:06 <lambdabot>  Parse error at end of input
14:51:09 <vixey> @let a' = 43
14:51:09 <lambdabot> Defined.
14:51:11 <vixey> > a'
14:51:11 <Baughn> ?undefine
14:51:12 <lambdabot>  43
14:51:12 <lambdabot> Undefined.
14:51:12 <Saizan> dons: a is already defined as an Expr
14:51:16 <Baughn> > 1 + a
14:51:18 <lambdabot>  1 + a
14:51:20 <dons> ah, then @let should fail.
14:51:27 <dons> so someone's broken that property
14:51:29 <Baughn> That would be a good idea
14:51:29 <dons> sigh.
14:51:42 <dons> it used to work that way. you can't @define things that wouldn't run.
14:51:43 <plutonas> Baughn: i'd like actually something like catmaybes (Just [something])
14:51:46 <Baughn> What I'd like to know is how it gets into a /loop/, of all things
14:51:59 <ddarius> Us crazies have finally done it: "And in fact, as any fule kno, The dual of (monadic) substitution is (comonadic) redecoration. Oh, and it gets better! Behind every zipper is a comonad. And better yet! We also know that a rose tree is a cofree comonad over the list functor, which should somewhat help to tie this all together in terms of why and how a zipper is a comonad."
14:52:08 <plutonas> Baughn: but wait a sec i just remember i might have this
14:53:11 <Saizan> ?let a = 31
14:53:12 <lambdabot> Defined.
14:53:14 <Saizan> > L.a
14:53:14 <draft> ok thanks
14:53:15 <lambdabot>  31
14:53:22 <Saizan> disambiguate :)
14:53:42 <Saizan> weird error message though
14:53:50 <Saizan> ?undefine
14:53:50 <lambdabot> Undefined.
14:54:52 <plutonas> i think i want maybe
14:57:01 <kiris> haha
14:57:08 <kiris> plutonas: have you decided? :p
14:58:12 <plutonas> kiris: not yet, have to make it work before, but maybe's documentation looks like it's the one
14:58:31 <vixey> :t maybe
14:58:32 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
14:58:34 <kiris> plutonas: good luck
14:59:04 <plutonas> i think i got something wrong with the general idea of the function
14:59:06 <vixey> > map (maybe 0 (+3)) [Nothing,Just 6,Just 2,Nothing]
14:59:07 <lambdabot>  [0,9,5,0]
14:59:12 <plutonas> so have to clear this first
14:59:51 <ddarius> > (concat . catMaybes) [Nothing Just "Hello", Just " World", Nothing]
14:59:52 <lambdabot>  Couldn't match expected type `(a1 -> Maybe a1)
15:00:03 <ddarius> > (concat . catMaybes) [Nothing, Just "Hello", Just " World", Nothing]
15:00:04 <lambdabot>  "Hello World"
15:09:24 <roconnor> @quote forkbomb
15:09:24 <lambdabot> No quotes match. :(
15:12:52 <vixey> @src on
15:12:52 <lambdabot> (*) `on` f = \x y -> f x * f y
15:16:00 <tromp> @src in
15:16:00 <lambdabot> Source not found. stty: unknown mode: doofus
15:17:47 <ahunter> On a long shot, does anyone have experience getting GHC running on CentOS?
15:18:02 <ahunter> Well, more accurately, the Rocks cluster distribution, which is CentOS-based
15:25:45 <vixey> how did they possibly forget to add MaybeT to haskell?
15:26:06 <vixey> you are supposed to use Error () ?
15:26:14 <b_jonas> vixey: or write your own
15:26:17 <b_jonas> or maybe google for one
15:26:27 <vixey> that's not what I mean
15:28:03 <b_jonas> I mean, I don't think it's too hard to write it actually
15:28:25 <vixey> yeah I'm not worried about that
15:28:36 <b_jonas> especially if you look at ErrorT's source or even use a wrapper over it
15:35:25 <sclv_> I just discovered that #haskell has been lying to me all along!
15:35:51 <sclv_> Everyone said there was no way to get out of IO, but I just found this: http://www.spywareremove.com/removeMonad.html
15:35:51 <lambdabot> Title: Monad :: Monad Removal Instructions
15:39:55 <tromp> sclv_: that only works on Windoze though:(
15:45:52 <kiris> @activity
15:45:52 <lambdabot> 8*total 8*private
15:46:06 <kiris> that's nice
15:46:27 <vixey> @activity
15:46:28 <lambdabot> 11*total 10*private 1*#haskell
15:46:38 <vixey> cool
15:49:54 <vixey> > runST (do x <- newSTRef () ; y <- newSTRef () ; return (x==x,x==y))
15:49:55 <lambdabot>   Not in scope: `newSTRef'
15:51:17 <Ben`> how can I put something of type IO String into a function whos argument has to be of type String?
15:51:47 <kiris> :t (>>=)
15:51:48 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
15:51:58 <vixey> Ben`: inside of a do block, you can have  x <- ioStr ; ...
15:52:05 <dobblego> Ben`, you use >>= (pronounced bind)
15:52:08 <vixey> Ben`: for the whole scope of the do block x will have type String
15:52:10 <dobblego> or you use do-notation
15:52:37 <Ben`> ok thanks, I'll try that
15:53:09 <dobblego> do x <- theIOString; y <- theFunction x; return y -- for example
16:00:09 <telemach> hello!
16:00:34 <kiris> hi :)
16:00:35 <Ben`> does >>= work when the functions return values of different types? I have something of type IO String and want to use it as an argument to a function of type String -> Net ()
16:01:13 <telemach> of course
16:01:33 <telemach> otherwise monads would be a real pain to use.
16:01:33 <kiris> consider the type of (>>=)
16:01:36 <kiris> :t (>>=)
16:01:37 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
16:01:50 <Ben`> hmm, I'm getting an error "Couldn't match expected type `ReaderT Bot IO a' against inferred type `IO String'", what does that mean?
16:01:55 <kiris> your `m a' value, `IO String'
16:01:59 <kiris> yeah
16:02:24 <kiris> because the (a -> m b) should return `IO something'
16:02:45 <rwbarton> Ben`: The monads have to match; what is Net?
16:03:03 <kiris> rwbarton: `ReaderT Bot IO a', of course
16:03:38 <rwbarton> Ah right, I forgot the kind of ReaderT
16:03:41 <kiris> Ben`: so the arguments to (>>=) should be the same monad
16:03:47 <Ben`> ah
16:03:59 <Ben`> so what do I do if they are different monads?
16:04:07 <rwbarton> You probably need 'lift' or 'liftIO'
16:04:19 <Saizan> you trasform one in the other, using lift or liftIO in this case
16:04:30 <Ben`> ok, thanks
16:05:15 <kiris> :t liftIO
16:05:15 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
16:05:19 <telemach> though it's generally a good idea not to mix monads.
16:05:27 <telemach> lifting can be ugly :).
16:05:50 <oldsalt>     Couldn't match expected type `Data.ByteString.Lazy.Internal.ByteString'
16:05:50 <oldsalt>            against inferred type `ByteString'
16:05:55 <oldsalt> what am i doing wrong?
16:06:23 <kiris> presumably they are different types
16:06:28 <Saizan> oldsalt: you're mixing Data.ByteString with Data.ByteString.Lazy
16:07:04 <Saizan> there are functions to convert between the two if you really want
16:07:16 <kiris> anyone know how to remove blank lines with sed or other pipable utility?
16:07:17 <oldsalt> no, it is all unintentionally
16:08:09 <oldsalt> i am trying to decode a value
16:08:16 <kiris> ah, n/m. ^$
16:08:27 <vixey> filter (not.null) . lines . readFile "file"
16:08:44 <pejo> kiris, ^ is start of line, $ is end of line
16:08:52 <kiris> pejo: correct
16:08:59 <pejo> Doh, you beat me to it.
16:09:09 <kiris> thanks anyway
16:09:37 <telemach> so, sed '/^$/d' input.txt > output.txt ?
16:09:45 <oldsalt> Saizan: which are the functions to convert?
16:09:59 <kiris> telemach: right
16:11:02 <Saizan> oldsalt: you've to compose a couple of them, see toChunks/fromChunks and concat
16:11:43 <nus> telemach, grep -v works too
16:11:49 <oldsalt> Saizan: thanks, i will try to figure it out
16:12:44 <telemach> what does grep -v do?
16:13:06 <pejo> telemach, invert match.
16:13:18 <kiris> shows lines that don't match instead of ones that do
16:13:50 <telemach> ah, i see
16:14:29 <oldsalt> Saizan: you made my night
16:17:05 <Igloo> augustss_: Was http://hackage.haskell.org/trac/ghc/ticket/1548#comment:4 you?
16:17:07 <lambdabot> Title: #1548 (printf bugs) - GHC - Trac
16:17:18 <augustss_> yes
16:17:26 <Igloo> OK, thanks!
16:17:32 <augustss_> Sorry, forgot to sign it.
16:17:43 <Igloo> np, I'll add a note
16:19:49 <RayNbow> @src (->) fmap
16:19:50 <lambdabot> fmap = (.)
16:27:49 <kiris> *Markov Control.Monad> generate "08.07.09.stripped" "Haskell " 6
16:27:51 <kiris> Haskell howdy can someone tell me how to rewrite this ok then i get an error lambdabot becomes incremental doh
16:28:51 * tusho wonders what quickchecks for a lambda calculus interp might b
16:28:51 <tusho> e
16:28:55 <tusho> test
16:28:56 <gwern> ... lines and unlines are not inverses?
16:28:57 <tusho> er
16:29:04 <tusho> gwern: nope
16:29:14 <tusho> @qc (\x -> x == unlines (lines x))
16:29:14 <lambdabot> Not enough privileges
16:29:17 <vixey> gwern: no
16:29:18 <gwern> and neither are words and unwords
16:29:18 <tusho> @check (\x -> x == unlines (lines x))
16:29:21 <gwern> wtf
16:29:26 <tusho> uh
16:29:28 <tusho> @check, lambdabot
16:29:31 <tusho> @check (\x -> x == unlines (lines x))
16:29:34 <lambdabot>  thread killed
16:29:35 <lambdabot>   Not in scope: `lambdabot'
16:29:36 <lambdabot>  Falsifiable, after 0 tests: "\130361"
16:29:36 <tusho> :|
16:29:45 <vixey> > unwords . words $ "    o      o "
16:29:46 <lambdabot>  "o o"
16:29:47 <tusho> > lines "\130361"
16:29:47 <gwern> > unlines $ lines "\r"
16:29:49 <lambdabot>  ["\130361"]
16:29:49 <lambdabot>  "\r\n"
16:29:53 <tusho> > unlines $ lines "\130361"
16:29:54 <lambdabot>  "\130361\n"
16:30:20 <gwern> -_- whose idea was it to define lines and words these ways...
16:30:30 <tusho> gwern: mine
16:30:32 <tusho> I hate you
16:30:33 <tusho> and your puppies
16:30:42 <vixey> gwern: you only want them to be inverses so you can make test? :p
16:31:01 * gwern needs someone to blame!
16:31:11 <vixey> automated tests
16:31:25 <kiris> *Markov Control.Monad> generate "08.07.09.stripped" "gwern " 6 => "gwern I think of quicksilver said they will have to kill it if I want to say I think"
16:31:25 <vixey> why should they be inverses ?
16:31:35 <gwern> vixey: well, it also is odd. I mean, wouldn't you expect lines and unlines to be inverses?
16:31:40 <tusho> kiris: hey. Writing a markov c hain is _MY_ job!!!
16:31:45 <tusho> *chain
16:31:45 <vixey> no
16:31:53 <tusho> does yours do multiple Ns though?
16:31:55 <tusho> and letter-based?
16:32:09 <kiris> this is Data.MarkovChain, yes it's letter based and multiple N
16:32:09 <vixey> I don't except compress . decompress  to be id
16:32:40 <kiris> tusho: http://hackage.haskell.org/packages/archive/markov-chain/0.0.2/doc/html/Data-MarkovChain.html
16:32:43 <lambdabot> Title: Data.MarkovChain, http://tinyurl.com/55cwrh
16:32:47 <gwern> you would decompress . compress, I hope...
16:33:00 <vixey> yes
16:34:03 <tusho> kiris: well, mine is obviously better
16:34:04 <tusho> :)
16:34:11 <gwern> but lines maps onto a bigger area, so it should be able to losslessly shrink back into the original, imo
16:34:14 <kiris> "lambdabot would be a good idea but wait a sec i just remember i might have missed what Dae said"
16:34:20 <kiris> hehe. this is fun
16:35:01 <kiris> tusho: can I see the code?
16:35:08 <tusho> I keep rewriting it
16:35:08 <tusho> :p
16:36:32 <kiris> I want to write a plugin for λb that spews marketting speak about Haskell. COMBINATORS TAILORED TO YOUR NEEDS
16:39:24 <tusho> kiris: INFINITE COMBINATORIAL EXPLOSION PROBLEMS: Haskell kills 'em dead. Improve your code experience with HASKELL 4.01
16:39:47 <kiris> haha, right
16:40:14 <kiris> return on investment with monadic software engineering
16:41:45 <tusho> GHC ... because 'COMPILING!' doesn't work if it goes fast.
16:41:52 <tusho> OH SNAP
16:42:34 <vixey> Is this more complicated that necessary?
16:42:38 <vixey> type Infer s a = StateT ([(Variable s (Type s),String)],[String]) (ST s) a
16:43:02 <kiris> I wonder how many YouTube comments I've read that were actually generated by markov chains
16:43:42 <EvilTerran> kiris, all of them
16:43:44 <EvilTerran> same goes for people talking in #haskell
16:44:30 <tusho> we are all markov chains
16:44:31 <tusho> [deep]
16:44:34 <shepheb> that map of the most common word in #haskell implies that you could do pretty well with a Markov chain Haskell-help bot.
16:45:29 <gwern> #haskell got you me weary? pump up YOUR MANHOooD with special cat supplies of meowviagra! JUST NOW
16:46:53 <vixey> Monads is sooo cheating, I love it
16:47:50 <tusho> vixey: ?
16:48:39 <vixey> > do x @ Nothing <- Nothing ; return ()
16:48:47 <lambdabot>  Nothing
16:48:53 <EvilTerran> what
16:49:02 <EvilTerran> > do _ <- Nothing; return ()
16:49:03 <lambdabot>  Nothing
16:49:22 <EvilTerran> > do Nothing; return () -- even
16:49:23 <lambdabot>  Nothing
16:49:51 <tusho> <vixey> > do x @ Nothing <- Nothing ; return ()
16:49:55 <tusho> how the hell is that cheating
16:51:37 <catface> join #lisp
16:51:54 <tusho> no
16:53:36 <adekoba> what is the best package for working with mysql?
16:54:13 <tusho> don't know, but i'd like to say 'a gun'
16:57:38 <vixey> @instances MonadTrans
16:57:39 <lambdabot> ContT r, ErrorT e, RWST r w s, ReaderT r, StateT s, WriterT w
16:58:13 <vixey> :t lift
16:58:14 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Monad m, MonadTrans t) => m a -> t m a
16:58:17 <vixey> :t runErrorT
16:58:17 <lambdabot> forall e (m :: * -> *) a. ErrorT e m a -> m (Either e a)
16:58:30 <vixey> oh these are inverse
16:59:54 <glith> > pl \x y -> x y
16:59:54 <lambdabot>  Parse error at "\x" (column 4)
17:00:17 <tusho> glith: ($)
17:00:28 <vixey> \x y -> x y = ($)
17:00:28 <tusho> @pl \x y -> x y
17:00:29 <lambdabot> id
17:00:32 <tusho> or id
17:00:36 <glith> ahh
17:00:43 <vixey> ($) = modus ponens
17:01:01 <glith> @pl \x y -> f x == f y
17:01:01 <lambdabot> (. f) . (==) . f
17:01:03 <tusho> ($) = id
17:01:07 <vixey> (==)`on`f
17:01:12 <vixey> @src on
17:01:13 <lambdabot> (*) `on` f = \x y -> f x * f y
17:01:14 <tusho> really, though .. the operator is ()
17:01:16 <tusho> :)
17:01:32 <dolio> Someone should add that to pl. It gets asked a lot.
17:02:05 <tusho> add what
17:02:31 <tusho> also...
17:02:31 <tusho> (*) `on` f = \x y -> f x * f y
17:02:35 <tusho> i like the overloading of *
17:02:41 <tusho> executable examples
17:09:49 <EvilTerran> gesundheit
17:10:03 <shapr> ACHOO!
17:10:27 * araujo throws a sugar lambda at shapr 
17:10:34 <telemach> krankheit. gesundheit kommt von alleine.
17:10:40 * shapr sneezes on the sugar lambda
17:10:46 <shapr> prosit!
17:10:54 <araujo> :-]
17:15:08 <shapr> @seen ndm
17:15:08 <lambdabot> I haven't seen ndm.
17:15:10 <shapr> aww
17:15:15 * shapr grins at ndmitchell
17:15:17 <ndmitchell> hi shapr
17:15:22 <shapr> hiya!
17:15:30 <ndmitchell> shapr, different IRC client, web based one, which defaults my username to something else
17:15:32 <shapr> ndmitchell: I had something to tell you, but I forgot :-(
17:15:52 <ndmitchell> shapr: will be around for anohter half hour, ifyou remember...
17:15:58 <shapr> It was either about yhc on javascript or supero...
17:16:05 <shapr> Nah, I forgot it about three weeks ago.
17:16:09 <shapr> I don't think it's coming back
17:19:59 <RayNbow> hmm, there's no Haskell module that defines fmap for (->)?
17:20:15 <RayNbow> (or at least, I can't find it with Hoogle)
17:20:24 <EvilTerran> Control.Monad.Instances
17:21:11 <RayNbow> thanks :)
17:21:30 <ndmitchell> RayNbow: the fact you can't find it with hoogle doesn't surprise me, what did you try searching for?
17:21:55 <RayNbow> I searched for fmap
17:22:40 <ndmitchell> as in "fmap" the string? why did you think hoogle would show you the instance for (->) ? - just wondering where hoogle is not matching peoples expectations/guesses
17:23:58 <RayNbow> ndmitchell: well, what should be the correct search query?
17:24:27 <cetin> hi what is the package name of the module Text.Regex.Posix? how can find out the package name of a given module in general? (need this for the -package parameter of ghc)
17:24:35 <ndmitchell> RayNbow: i don't think there is one that would tell you that information, but that could well be that hoogle is wrong, rather than you
17:25:18 <Ben`> is there a function to convert between number bases?
17:27:05 <ndmitchell> cetin: pass --make and it will do it for you
17:27:14 <twanvl> Ben`: do you mean for strings?
17:27:32 <vixey> :t showIntAtBase
17:27:33 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
17:27:57 <cetin> @ndmitchell: it was regex-posix ^_^ thank you I will also try --make
17:27:57 <lambdabot> Unknown command, try @list
17:27:58 <Ben`> twanvl: yes
17:27:58 <noecksit> does anyone how to get rid of circular dependancies in ghc?
17:28:06 <shapr> hs-boot?
17:28:07 <cetin> :ndmitchell: it was regex-posix ^_^ thank you I will also try --make
17:28:36 <noecksit> like if I have one module and I am using another module's functions, but in the other module I am using functions from the current module
17:28:56 <dobblego> dependencies
17:29:24 <twanvl> > showIntAtBase 16 intToDigit 255 ""
17:29:25 <lambdabot>  "ff"
17:29:53 <Ben`> ah thanks
17:30:18 <EvilTerran> ?hoogle hex
17:30:21 <lambdabot> Text.ParserCombinators.Parsec.Char.hexDigit :: CharParser st Char
17:30:21 <lambdabot> Text.ParserCombinators.Parsec.Token.hexadecimal :: TokenParser st -> CharParser st Integer
17:30:21 <lambdabot> Numeric.showHex :: Integral a => a -> ShowS
17:31:07 <EvilTerran> > showHex 12648430 " and a suffix for fancy efficiency reasons"
17:31:08 <lambdabot>  "c0ffee and a suffix for fancy efficiency reasons"
17:31:18 <EvilTerran> :)
17:31:42 <EvilTerran> Ben`, there's some convenience functions like that in the Numeric module
17:31:52 <EvilTerran> that're just partial applications of showIntAtBase, probably
17:32:20 <Ben`> ok :)
17:37:37 <hpaste>  ronwalf pasted "Extensible records compilation issue" at http://hpaste.org/8816
17:38:04 <ronwalf> Anyone know why ghc can't find a (Data String) instance?
17:39:41 <ndmitchell> ronwalf: import Data.Generics?
17:39:49 <ndmitchell> and it would be a Char and a [] instance
17:40:38 <ronwalf> Huh, indeed.  Why didn't 'import Data.Generic.Basics' work?
17:42:19 <ndmitchell> the instances are in Data.Generics.Instances, i think
17:46:20 <noecksit> ndmitchell : do u know if there is a firefox add-on for hoogle?
17:46:51 <shepheb> noecksit: you can make your own.
17:47:08 <dolio> What is there to add on? Can't you just add it to the list of search engines or something?
17:47:22 <noecksit> shepheb : yeah probably, i just wanted to know if there was one already
17:47:41 <shepheb> hell, just run a search, bookmark it, add a keyword name ("h", say), and replace the search term with %2
17:47:44 <shepheb> %s rather
17:48:09 <shepheb> then typing "h prefixOf" into the address bar searches for prefixOf, as desired
17:48:14 <noecksit> https://addons.mozilla.org/en-US/firefox/browse/type:4/cat:all?sort=name
17:48:15 <lambdabot> http://tinyurl.com/546zkb
17:48:24 <dolio> Yeah, I'm not sure how firefox works, but in konqueror I just have 'hoogle:' set up to construct the right search url.
17:48:45 <shepheb> I have like 30 of those custom searches. Hoogle, acronymfinder, urban dictionary, etc. etc.
17:50:24 <ndmitchell> noecksit: if you visit it with firefox, you get a "Firefox plugin" link in the top right corner, if you right click in teh search field go to "Add a keyword for this search..."
17:50:38 <ndmitchell> i have the keyword search set up for it, in opera too
17:51:25 <noecksit> ndmitchell : oh thanx, i didnt notice that, instead i searched the firefox add-ons
17:58:16 <hpaste>  Mitar pasted "Profiling" at http://hpaste.org/8817
17:58:31 <Mitar> any suggestion how to optimize?
17:59:11 <Mitar> if I understand correctly world function by itself take 46 % of time ...
18:02:02 <ndmitchell> Mitar: no, sphere takes up 11% three times, ~33%, so i'd optimise that
18:02:41 <dolio> world does take up 46 itself, though. Inherited it takes up 84%.
18:03:05 <dolio> But that may be due to it forcing stuff that's left lazy in the stuff it calls (I think?).
18:03:10 <Mitar> and how can such simple function that so much by itself?
18:04:17 <dolio> That is, elements = list-of-expensive-computations, and then sequence evaluates them.
18:04:32 <dolio> For instance.
18:05:19 <Mitar> but then everyhing would be in world ...
18:05:25 <Mitar> because spheres are lazy ...
18:05:47 <ndmitchell> Mitar: if you just want to optimise, i'd look a spheres
18:05:49 <Mitar> so then all computation would be done in world ... when sequence evaluates them
18:06:06 <dolio> sphere probably does actual work, too.
18:06:16 <dolio> Or, obviously it does.
18:06:28 <hpaste>  Mitar annotated "Profiling" with "Spheres" at http://hpaste.org/8817#a1
18:07:15 <ronwalf> Hm, it's hard to get recursive types to derive 'Data', isn't it?
18:07:53 <ndmitchell> ronwalf: no... - its fairly easy, surely?
18:08:00 <hpaste>  ronwalf pasted "(no title)" at http://hpaste.org/8818
18:08:26 <ronwalf> There's probably something I'm missing
18:08:30 <ndmitchell> ronwalf: oh, you mean crazy types - yeah, no idea on that - you can give instances for concrete f's
18:09:04 * ronwalf sighs for his crazy types
18:09:04 <ndmitchell> ronwalf: that has nothing to do with the deriving Data, remove it and you'll still get an error
18:09:10 <ndmitchell> (i think)
18:09:24 <dolio> You're missing part of the declaration.
18:09:43 <ronwalf> oh, yeah, been playing with it, let me repost...
18:09:44 <dolio> data Expr f = In (f (Expr f))
18:09:58 <ronwalf> or rather: data Expr f = In (f (Expr f)) deriving Data
18:10:15 <ronwalf> dolio: Yes, that was the original line
18:10:21 <hpaste>  Mitar annotated "Profiling" with "Reduction" at http://hpaste.org/8817#a2
18:11:03 <Mitar> anyone for an explanation?
18:12:01 <dolio> Easier to optimize?
18:12:02 <ndmitchell> ronwalf: just derive concrete instances is my suggestion, instance Data (Expr []) where ..., then it becomes easy again
18:12:21 <Saizan> did you compile with -O2 in both cases?
18:12:55 <ronwalf> ndmitchell: Unfortunate - there are about a bazillion instances of it
18:13:04 <ronwalf> ndmitchell: It's from Wouter's Datatypes ala Carte
18:13:41 <Mitar> when i was compiling i have not, but when i was measuring this overall time (50 s versus 15 s) i have
18:13:45 <ndmitchell> Mitar: GHC sucks at optimising recursive functions, i.e. sequence, and deals poorly with literal lists which are reduced directly
18:13:48 <Mitar> ehm, s/compiling/profiling/
18:13:49 <ndmitchell> ronwalf: doh...
18:14:03 <ndmitchell> ronwalf: CPP and #define?
18:14:50 <Mitar> currently i hardcoded sequence ..
18:15:01 <Mitar> but I would like to build it dinamicaly ...
18:15:16 <Mitar> so ... i cannot use this case ... of trick i used now ...
18:15:23 <Mitar> any other alternatives?
18:20:00 <dolio> Try downloading the stream-fusion package and use the functions in Control.Monad.Stream
18:20:27 <dolio> It's on hackage.
18:20:36 <cetin> Hi how can I split "Cell 1 a b Cell 2 c d" :: String to ["Cell 1 a b", "Cell 2 c d"] :: [String] using regex in Haskell?
18:21:53 <ndmitchell> let (lhs,rhs) = splitAt 4 $ words "Cell 1 a b Cell 2 c d" in [unwords lhs, unwords rhs]
18:21:58 <ndmitchell> > let (lhs,rhs) = splitAt 4 $ words "Cell 1 a b Cell 2 c d" in [unwords lhs, unwords rhs]
18:22:00 <lambdabot>  ["Cell 1 a b","Cell 2 c d"]
18:22:09 <ndmitchell> cetin: ^^^
18:22:59 <cetin> uhmm
18:23:33 <ronwalf> ndmitchell: Hm, maybe Typeable1 is a start?
18:23:34 <EvilTerran> ?where agda
18:23:34 <lambdabot> http://tinyurl.com/yp6zsr
18:24:08 <cetin> ndmitchell: thanks ^^ but I want to split the output of iwlist wlan0 scan and I don't think splitAt with a fixed number can handle its output
18:24:47 <ndmitchell> ronwalf: yes, for Typeable, but i don't think it deals with Data at all, you'd need Data1, or some such, which doesn't exist
18:24:54 <ndmitchell> cetin: just thinking...
18:24:57 <electronx> ndmitchell: are you still activly developing supero?
18:25:28 <ndmitchell> electronx: currently I am 100% time on Hoogle, i would love a research position developing Supero though
18:26:11 <electronx> you should apply for google summer of code for supero next summer
18:27:18 <electronx> maybe apply to microsoft :)
18:27:28 <ndmitchell> > map unwords $ groupBy (const $ (/=) "Cell") $ words "Cell 1 a b Cell 2 c d"
18:27:28 <lambdabot>  ["Cell 1 a b","Cell 2 c d"]
18:27:35 <ndmitchell> cetin: ^^^
18:28:04 <ndmitchell> electronx: its entirely the wrong thing to do for summer of code, plus i won't be a student. I have already emailed microsoft, and may try further down that route
18:28:34 <cetin> ndmitchell: the funny bit is that I can't control greediness of a regex from Text.Regex.Posix otherwise I would try sth like: "Cell 1 a b Cell 2 c d" =~ "(Cell.*?)(Cell|$)" :: (String,String,String,[String])
18:28:45 <cetin> ndmitchell: oh thanks, I will try this ^^
18:29:02 <cetin> ndmitchell: I mean what you just suggested, I will try that ^_^
18:29:06 * ndmitchell has never used a Haskell regular expression
18:29:23 <ndmitchell> cool :)
18:29:51 <ndmitchell> electronx: but i am actively looking at getting ways to fund 3 years of Supero development starting January
18:30:22 <ndmitchell> (if anyone has some money sitting around...)
18:30:42 <electronx> :)
18:30:56 <electronx> Simon should hire you
18:31:00 <electronx> seriously
18:31:24 <ndmitchell> i am going to ask, but i've no idea what is possible
18:31:37 <electronx> you could scrap yhc and work on ghc
18:32:01 <noecksit> > (("7 [##] test" =~ "^7 \[##\]") :: Bool)
18:32:01 <lambdabot>  Illegal escape sequence at ""^7" (column 20)
18:32:08 <ndmitchell> i do intend to do future supero development within GHC, rather than Yhc
18:32:29 <ndmitchell> although a fair chunk of Supero is already GHC, the entire back end, but i want to make the front-end GHC as well
18:32:54 <noecksit> > (("7 [##] test" =~ "^7 ") :: Bool)
18:32:55 <lambdabot>   Not in scope: `=~'
18:35:34 <atp> ndmitchell: supero didn't require yhc core?
18:35:49 <atp> ndmitchell: or was i thinking of your crash analysis utility, what was it called again
18:36:11 <ndmitchell> atp: they both require Yhc.Core, you are thinking of Catch
18:36:24 <noecksit> how would i be able to match the literal [ character in Posix?
18:36:40 <dmwit> [[]
18:36:41 <lambdabot> dmwit: You have 1 new message. '/msg lambdabot @messages' to read it.
18:36:41 <ndmitchell> but they require Yhc.Core, a portable Core language, which Yhc happens to generate - we are very close to having Hugs generate Yhc.Core as well
18:36:49 <dmwit> noecksit: Or \[
18:37:12 <atp> ndmitchell: what are the benefits of Yhc.Core over GHC.Core?
18:37:36 <noecksit> dmwit : i dont think \[ works, that was my first guess
18:37:39 <dmwit> ?ask byorgey How the deuce did you know I was working on that?
18:37:39 <lambdabot> Consider it noted.
18:38:00 <dmwit> ?tell byorgey Anyway, not gonna happen soon, for personal reasons.  Next week at the soonest. =/
18:38:00 <lambdabot> Consider it noted.
18:38:01 <noecksit> dmwit : [[] seems to work however
18:38:05 <electronx> ndmitchell: i thought you stopped working on hugs
18:38:42 <dmwit> noecksit: According to the standard, you can match ] with []], too, though I'm not sure how compliant all the various matchers are.
18:39:38 <atp> Pseudonym: ha, that quote of yours on HWN is priceless... "trapped in the IO Monad: the lesser known R. Kelly opera"
18:39:43 <atp> i loves
18:40:02 <noecksit> yeah, its a little weird that \ is not used for literals in posix
18:40:13 <dobblego> @users
18:40:13 <lambdabot> Maximum users seen in #haskell: 460, currently: 398 (86.5%), active: 16 (4.0%)
18:40:21 <Saizan> are there known users of haskell-src besides lambdabot?
18:41:05 <dmwit> noecksit: It is, though your implementation might be wrong.
18:43:07 <ndmitchell> atp: Yhc.Core exists, GHC.Core has no external format, there is a really nice Yhc.Core library (which I wrote), it is type free so is a lot longer lasting and easier to experiment with
18:43:24 <ndmitchell> electronx: no, still do some hugs stuff, but I'm not actually doing the Yhc.Core Hugs work, its Dimitry
18:44:16 <atp> ndmitchell: good reasons
18:44:44 <dmwit> noecksit: Oh, PS:
18:44:47 <dmwit> > "\["
18:44:48 <lambdabot>  Illegal escape sequence at ""\["" (column 1)
18:44:49 <ndmitchell> atp: but there are lots of reasons not too, and with some work on the GHC.Core (particularly external Core), you could easily use GHC.Core instead
18:44:55 <dmwit> > "\\[" -- more different
18:44:56 <lambdabot>  "\\["
18:45:08 <dmwit> noecksit: Did you properly escape your escape character? =P
18:45:22 <ndmitchell> You can even convert GHC.Core -> Yhc.Core, which we have the code to do, if we could generate GHC.Core reliably
18:45:42 <ndmitchell> so keep the same supero stuff, and make GHC the front and back end transparently
18:46:17 <atp> yeah, i heard about that project
18:46:30 <atp> the supero stuff is pretty neat, it would be cool to see it migrate into ghc one way or another
18:46:33 <ronwalf> Where are some Typeable1 instances to look at?
18:46:33 <atp> likewise with catch
18:47:23 <atp> i looked into verifying some of my code with catch a while ago but at the time i pretty much had to get my code to compile with yhc (it wouldn't) and the setup was non-trivial... but it was a while ago, around the time you verified xmonad
18:48:03 <dobblego> what's the flag to GHC to create the executable?
18:48:05 <ndmitchell> atp: yeah, its not easy to do, the Hugs front end to Catch should be rather good
18:48:21 <ndmitchell> dobblego: --make ?
18:48:25 <dobblego> of course, thanks
18:48:29 <dobblego> (I was stuck on --main)
18:48:42 <ndmitchell> a Hugs front end to Supero has some disadvantages, so won't work as well
18:50:03 <atp> and while getting code to compile on hugs is definitely easier than yhc, a lot of non-trivial programs still end up relying on ghc-only extensions unfortunately
18:50:18 <mmorrow> Saizan: haskell-src-exts is where the goods are :)
18:50:40 <atp> i think catch is one of those tools that would become a mainstay in the haskell world if it were easy to setup
18:50:49 <atp> most of us are safety-freaks after all
18:50:50 <ndmitchell> yep, Yhc.Core should be neutral to this, as soon as external GHC Core works it should be easy
18:51:16 <ndmitchell> once there is a realistic front end to Catch (Hugs or GHC), I'm going to rework the entire toolchain to be a lot more robust
18:51:34 <ndmitchell> at the moment its relatively pointless making Catch better when in reality Yhc is the thing letting it all fall to pieces
18:51:52 <atp> how do you mean?
18:52:23 <ndmitchell> Catch is only as good as Yhc, and in the Catch/Yhc chain Yhc is the weak link
18:52:24 <Armored_Azrael> Anyone know offhand how to do text output in haskell GLUT?
18:52:41 <ndmitchell> once Catch has a GHC/Hugs front end, then i'll improve Catch to make it easier to set up/develop/run etc
18:52:48 <dolio> ronwalf: I'm not sure you'll get a Typeable1 instance for Expr. It seems to want the arguments to have kind *.
18:53:37 <cetin> is there a way to import a module from a haskell source file in the current directory while using ghci?
18:53:49 <mmorrow> :l File.hs
18:53:54 <cetin> o_O
18:54:06 <mmorrow> :load File.hs
18:54:14 <cetin> thanks... somehow I am very bad with help files... thank you thank you ^_^
18:54:15 <dolio> ronwalf: A manual definition would be something like 'instance Typeable1 Expr where typeOf1 _ = mkTyConApp (mkTyCon "Expr") []' though.
18:54:19 <Saad_> Armored_Azrael, do you mean output to the console or window?
18:54:20 <dobblego> hello skippycostin :)
18:54:43 <atp> ndmitchell: thanks a lot for working on this stuff.  obviously you do it because you enjoy it, but a lot of the stuff you hack has the potential to be extremely useful to the community, imho.  keep up the great work.
18:54:50 <mmorrow> cetin: heh. unfortunately when you :load a module all your current vars/etc are zapped
18:54:55 <mmorrow> (fyi)
18:55:22 <ndmitchell> atp: thanks, i'm now finishing off my phd so will try and find something continuing - otherwise may be a lot slower progress
18:55:25 <Armored_Azrael> Saad_: Window. I'm trying to draw text in the GL Context
18:55:51 <atp> ndmitchell: finishing it off, huh?  do you mind if i ask the dreaded question?
18:55:56 <atp> ndmitchell: (when do you defend?)
18:56:39 <ndmitchell> atp: its not a dreaded question, looking forward to it, Monday afternoon
18:57:17 <Saad_> Armored_Azrael, http://haskell.org/ghc/docs/latest/html/libraries/GLUT/Graphics-UI-GLUT-Fonts.html
18:57:19 <lambdabot> Title: Graphics.UI.GLUT.Fonts, http://tinyurl.com/65nrx5
18:57:39 <atp> ndmitchell: oh wow, that is soon
18:57:43 <atp> ndmitchell: good luck!
18:58:01 <ndmitchell> thanks :)
19:01:09 <jaj> hmm, what does it mean when you have code enclosed by {# #} ? is this FFI stuff?
19:02:14 <jaj> for example {#import Graphics.UI.Gtk.Abstract.Object#}
19:03:51 <koninkje> has anyone tried combining quickcheck and hunit into a single test harness (rather than just doing them side by side)?
19:04:57 <hackage> Uploaded to hackage: graphviz 2008.7.10
19:04:57 <hackage> Uploaded to hackage: highlighting-kate 0.2.3
19:04:57 <hackage> Uploaded to hackage: protocol-buffers 0.0.2
19:04:58 <hackage> Uploaded to hackage: line2pdf 0.0.5
19:05:00 <hackage> Uploaded to hackage: line2pdf 0.0.4
19:05:09 <matthew-_> agh! there's a hackage bot!
19:05:26 <geezusfreeek> oh no
19:05:33 <Saizan> jaj: that's c2hs syntax
19:07:06 <jaj> Saizan: thanks!
19:11:23 <Armored_Azrael> Saad_: Immediately after attempting to render any text like that, the entire gl context goes black
19:16:08 <Saad_> Armored_Azrael, are you using the default projection matrix?
19:17:07 <Saad_> Armored_Azrael, ie the coordinate system is (-1, -1) to (1, 1)?
19:22:14 <shapr> hiya Adamant
19:22:20 <shapr> dang, missed ADEpt
19:22:36 <Adamant> hi?
19:22:49 <Adamant> or were you trying to get ADEpt?
19:23:45 <dmwit> <3 tab-completion
19:27:37 * dolio doesn't get people who complain about new programming languages being written.
19:28:11 <vixey> which language ?
19:28:25 <dolio> I forget the name.
19:28:35 <dolio> Some lisp-alike language that uses maps instead of lists.
19:28:40 <vixey> I can understand people complaining about arc or R6RS
19:29:01 <Nafai> dolio: MISC?
19:29:10 <dolio> That's the one.
19:29:17 <jre2> vixey: because they don't agree with the changes, or simply the fact it's a new language?
19:29:32 <vixey> for not agreeing
19:29:35 <dolio> I understand arc complaints, because it's hyped to death and it's lame.
19:29:49 <dolio> I mean people who go "A new language? Don't we have enough already?"
19:30:03 <vixey> what's this Misc ?
19:30:05 <jre2> I think dolio meant hostility towards new langauges for the very fact of being a new language
19:30:29 <vixey> jre2: oh well that I don't get
19:30:51 <dolio> As if there's nothing new to be done in programming languages.
19:31:03 <dolio> We've got it all figured out already.
19:32:39 <Korollary> dolio: I don't complain that it was written. I just don't find it newsworthy.
19:32:50 <dolio> No, I don't think it is, either.
19:33:24 <dolio> I don't salivate over 'homoiconicity' though.
19:33:28 <mightybyte> Does haskell have a linked list in the standard library?
19:33:34 <vixey> yes []
19:33:41 <dolio> Heh.
19:34:08 <mightybyte> vixey: Oh, the built-in lists are implemented as linked lists?
19:34:09 <dolio> Linked lists are the most used data structure in haskell, I'd say.
19:34:52 <dolio> Strictly speaking, they're more like stacks if you want to compare them to how you'd write things in C or something.
19:35:24 <dolio> Since in such a language, you'd probably keep a pointer to the end of a linked list for tail insertion.
19:35:37 <dolio> Although you might call that a queue.
19:35:47 <mightybyte> dolio: Yeah, I guess that's why I didn't think of them as being a linked list.
19:36:23 <koninkje> in that case: dlists
19:36:27 <Korollary> Data.Sequence ?
19:36:36 <koninkje> or that
19:36:47 <mightybyte> Yeah, I'm familiar with sequence.
19:37:17 <mightybyte> But I didn't see an operation to insert into the middle of a sequence in constant time.
19:37:50 <koninkje> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/dlist (still can't insert into the middle though)
19:37:53 <lambdabot> Title: HackageDB: dlist-0.4.1
19:38:00 <dolio> Then you want a zipper.
19:38:12 <mightybyte> dolio: Ahhh
19:38:33 <vixey> > let toDlist = (++) ; fromDlist = [] ;  fromDlist (toDlist "foo" ++ toDlist "bar")
19:38:34 <lambdabot>  Parse error at end of input
19:38:38 <vixey> > let toDlist = (++) ; fromDlist = [] in fromDlist (toDlist "foo" ++ toDlist "bar")
19:38:39 <lambdabot>  Couldn't match expected type `([Char] -> [Char]) -> t'
19:38:45 <vixey> > let toDlist x = (x++) ; fromDlist = [] in fromDlist (toDlist "foo" ++ toDlist "bar")
19:38:45 <lambdabot>  Couldn't match expected type `([Char] -> [Char]) -> t'
19:38:49 <vixey> hrmm
19:39:06 <vixey> > let toDlist x = (x++) ; fromDlist x = x [] in fromDlist (toDlist "foo" ++ toDlist "bar")
19:39:07 <lambdabot>  "foobar"
19:39:08 <dolio> You won't be inserting into the middle of any linked list, mutable or not, in constant time, really.
19:39:22 <dolio> Unless you already have a pointer to the appropriate node.
19:39:38 <dolio> (Which is, roughly, what a zipper is.)
19:39:48 <nus> a triple?
19:39:59 <mightybyte> dolio: Ok.  I guess I'm still thinking imperatively instead of functionally.
19:40:00 <vixey> I don't think a zipper has to be a triple
19:40:18 <koninkje> zippers over lists happen to be though
19:40:32 <koninkje> (or just a pair of lists, if you leave the hole empty)
19:42:21 <koninkje> mightybyte: a zipper will help if you've already traversed to where you'll be inserting (otherwise it's O(i) to traverse to the insertion site). You could probably get faster insertion with something like catenable deques, or a zipper for them
19:42:26 <koninkje> http://www.eecs.usma.edu/webs/people/okasaki/pubs.html#icfp97
19:42:26 <lambdabot> Title: Chris Okasaki's Publications
19:42:28 <mightybyte> I guess I'm just looking for some list-like structure that I will maintain in sorted form.
19:42:40 <koninkje> Data.Set?
19:42:51 <koninkje> or is it a multiset/bag?
19:43:29 <solrize> mightybite sounds like you want IntMap?
19:43:41 <solrize> or data.map ?
19:43:53 <koninkje> i.e. if "sorting" is involved, you'll want some sort of tree structure in order to make it fast. Any linear representation will have horrific performance
19:43:54 <solrize> then you can iterate over it in sorted order
19:44:08 <solrize> and insert stuff in O(log n) operations
19:44:29 <mightybyte> solrize: But a map would behave like a list.  I'd have to re-key every element when I insert something in the middle.
19:44:32 <koninkje> solrize: or O(1) if you have the right kind of map :)
19:44:46 <solrize> re-key every element?  what do you mean?
19:45:07 <mightybyte> solrize: Well, in an IntMap, all the keys would be ints.
19:45:30 <solrize> yeah data.map makes more sense if the sorting is on the values
19:45:45 <mightybyte> Inserting at m into a 1...n map would require changing the keys of all n-m elements > m.
19:45:59 <solrize> what do you mean by keys?
19:46:10 <solrize> i'm saying just use data.map where the keys are the things you're sorting on
19:46:18 <solrize> i guess that's data.set really, sigh :)
19:47:05 <solrize> hmm fold is in unspecified order for data.set
19:47:27 <mightybyte> solrize: Yeah, it doesn't look like set is ordered.
19:47:28 <koninkje> isn't fold always unspecified?
19:47:41 <koninkje> consider foldr or foldl
19:48:14 <solrize> data.map elems and keys use ascending order
19:48:23 <mightybyte> I guess Data.Sequence looks as good as anything.
19:48:39 <SamB> Data.Sequence?
19:48:42 <koninkje> ...defined for Data.Set in Data.Foldable
19:48:46 <SamB> oh, you said that already
19:49:29 <mightybyte> And an insert in the middle is just a split, append, and concatenate
19:49:56 <koninkje> > Data.Foldable.foldr (:) [] $ Data.Set.fromList [1,5,3,8,2,6,9]
19:49:57 <lambdabot>   Not in scope: `Data.Set.fromList'
19:50:10 <koninkje> lambdabot--
19:50:11 <SamB> I'm pretty sure that you don't need to do all that explicitly
19:51:02 <mightybyte> SamB: I don't see any built-in function that does that.
19:51:47 <SamB> damn DNS!
19:52:13 <koninkje> mightybyte: what exactly is your goal? I'm pretty sure Data.Set + Data.Foldable/Data.Traversable will give you what you're looking for
19:52:14 <SamB> I type "Data.Sequence" and it shows me some search engine branded with my ISP's logo etc...
19:52:24 <dons> anyone else want to help this guy, http://hoostus.blogspot.com/2008/07/random-programming.html
19:52:24 <lambdabot> Title: we wish to inform you: random programming
19:53:16 <mightybyte> koninkje: I just want to keep a list of things in sorted order.  And items can be added in the middle.
19:53:56 <koninkje> mightybyte: but why a "list" is it not enough to be able to see whether an item is in the collection and to iterate over all the elements in sorted order?
19:54:45 <SamB> koninkje: well, inserting in the middle is O(i)...
19:54:54 <mightybyte> koninkje: Well, the number of items could get large.
19:54:59 <SamB> mightybyte: why don't you just use Data.Set ?
19:55:02 <koninkje> mightybyte: if you're keeping things sorted then a "list" is one of the worst datastructures for the task, and in a tree structure such as Data.Set (or Data.Map, or Data.IntMap,...) "the middle" doesn't really mean anything
19:55:06 <SamB> mightybyte: it does essentially that
19:55:26 <SamB> assuming by "sorted order", you mean the order implemented by Ord
19:55:38 <koninkje> mightybyte: so? the more items there are the more a solution like Data.Set will outperform a list
19:55:43 <nus> oh, so a zipper is a tuple (cursor, path), right?
19:56:43 <jre2> anyone know how to get happs to run an external cgi script?
19:56:50 <SamB> nus: eh?
19:57:05 <SamB> nus: no ... a zipper is the data structure turned inside-out
19:57:06 <noecksit> hello, does anyone know what the big O of the function "reverse" is, is it O(n)?
19:57:29 <vixey> noecksit: what is your definition of reverse?
19:57:40 <noecksit> > reverse [1,2,3]
19:57:41 <lambdabot>  [3,2,1]
19:57:55 <vixey> noecksit: reverse = ... ?
19:58:16 <mightybyte> koninkje: But it doesn't look like sets are ordered.
19:58:46 <noecksit> vixey : reverse will usually be a data structure I made by myself consisting of (Int,Int) and another data structure called Color
19:59:16 <SamB> mightybyte: sure they are
19:59:20 <vixey> that doesn't make any sense at all
19:59:30 <SamB> mightybyte: what do you want the order for anyway?
19:59:47 <noecksit> but im just asking in general form, if the argument was [a]
20:00:27 <noecksit> sorry, i mean "reverse will usually take a data structure ..."
20:00:46 <koninkje> mightybyte: I guarantee you that sets will provide you with an ordered traversal of the elements contained in it.
20:00:48 <SamB> noecksit: the type of the list items is irrelevant to reverse ;-)
20:01:24 <noecksit> SamB: yeah, thats what i think
20:01:41 <cetin> I need a quick and dirty debug function, can use unsafePerformIO for sth like debug :: Show a => a -> a \\ debug = unsafePerformIO . print
20:02:02 <cetin> but then the type is () -> () -_-"
20:02:34 <cetin> so how can I do things like (debug x) + 209129 for example?
20:02:36 <vixey> reverse [] = []
20:02:42 <vixey> reverse (x:xs) = reverse xs ++ [x]
20:02:46 <vixey> is O(n^2)
20:02:49 <SamB> noecksit: look, I'll prove it to you
20:02:50 <vixey> reverse = revappend
20:03:00 <vixey>  where revappend (x:xs) ys = revappend xs (x:ys)
20:03:02 <SamB> @type reverse
20:03:03 <lambdabot> forall a. [a] -> [a]
20:03:07 <vixey>        revappend [] ys = ys
20:03:09 <vixey> is O(n)
20:03:39 <noecksit> @hoogle revappend
20:03:39 <lambdabot> No matches found
20:03:49 <SamB> noecksit: reverse has no information regarding the type of the list items, so can't change behaviour based on this
20:03:50 <vixey> noecksit: I just gave a definition of revappend
20:03:57 <mightybyte> koninkje: But I want to control exactly where an item is inserted.
20:04:03 <noecksit> oh
20:04:13 <SamB> mightybyte: what kind of order are you using?
20:04:40 <SamB> (how do you calculate the indices?)
20:04:43 <mightybyte> SamB: I want an integer order.
20:04:58 <SamB> an ... integer order?
20:04:59 <mightybyte> SamB: Some function of the elements.
20:05:10 <mmorrow> cetin: let debug x = unsafePerformIO (print x >> return x)
20:05:24 <SamB> mightybyte: show me the function
20:05:25 <mightybyte> i.e. a list of baseball players where the list is sorted by which one has the best batting average.
20:05:32 <mightybyte> ...or a host of other possibilities.
20:05:35 <SamB> oh
20:05:38 <koninkje> mightybyte: you've said you want to keep a sorted collection of elements. The only "exactly where" to insert into such an object is in the proper sorted position.
20:05:58 <mightybyte> some might be more complex than a simple batting average, so it's useful to generate an integer.
20:06:05 <SamB> mightybyte: clearly, you must write your program in Agda or Epigram and use a dependantly typed Set implementation ;-)
20:06:24 <mightybyte> koninkje: Ok, then how do I specify what the sorted order is?  I guess I'm just not seeing that.
20:07:05 <dolio> newtype MySortOrder = MSO (whatever) ; instance Ord (MySortOrder) where ...
20:07:16 <SamB> well, okay, that is also possible
20:07:21 <SamB> but looks ugly :-(
20:07:27 <dolio> Is the standard (though unfortunate) technique.
20:07:32 <SamB> oh, btw, by Epigram I meant Epigram 2
20:07:46 <koninkje> mightybyte: if you mean an *ordered* collection rather than a sorted collection, that's a bit different. In which case I suggest the catenable deques again (not in the standard libraries so far as I know)
20:07:50 <dolio> Yeah, use the one that doesn't exist yet. :)
20:08:11 <vixey> SamB: why not Coq?
20:08:21 <SamB> vixey: okay, fine, or Coq.
20:08:23 <dolio> Coq is ugly.
20:08:31 <vixey> Coq is not ugly
20:08:44 <vixey> you can make your own notation
20:08:46 <SamB> actually it is in a lot of ways
20:09:12 <mightybyte> koninkje: Ok, I guess ordered collection is probably what I'm looking for.
20:09:14 <SamB> more the vernacular than the gallina...
20:10:09 <koninkje> mightybyte: "sorted" means all values of the type have some (total) ordering; whereas "ordered" means you have many values in some particular sequence :)
20:10:25 <SamB> vixey: saying that there are dozens of syntaxes to define a function might not be much of an exaggeration
20:10:25 <mightybyte> koninkje: Ok, I want ordered.
20:11:01 <vixey> different names with different meanings, even thought they have the same semantics
20:11:13 <SamB> I meant besides those
20:11:14 <vixey> I do this in haskell a lot.. splitFile = sieve
20:12:30 <mightybyte> koninkje: And the ordering could change...i.e. if a batter gets 3 hits in a game and raises his batting average relative to the other players.
20:13:26 <koninkje> mightybyte: in that case you probably want a variation on a priority queue
20:13:27 <SamB> I was thinking more about Definition, Fixpoint, Function, Theorem, Instance, Program Definition, Program Fixpoint, Program Instance...
20:14:01 <vixey> well I was referring to Definition vs Theorem
20:14:54 <SamB> I'm not even complaining about the fact that Definition also doubles as an alias for Lemma/Theorem ...
20:15:14 <mightybyte> koninkje: Looks like sequence will do the trick...just with a little complication for removing and inserting from the middle.
20:15:17 <vixey> good, it wouldn't make sense to complain about that :p
20:15:33 <SamB> and I realize all of these have different semantics, but man ... it's a bit hairy!
20:16:05 <koninkje> mightybyte: unfortunately there isn't one in the standard libraries (probably because there are too many variants for different circumstances). Okasaki has written extensively on them and has some implementations here though:
20:16:09 <koninkje> http://www.eecs.usma.edu/webs/people/okasaki/pubs.html#cup98
20:16:10 <lambdabot> Title: Chris Okasaki's Publications
20:16:12 <SamB> oh, I guess you can also use Class to define functions ;-)
20:16:24 <mightybyte> koninkje: Ok, thanks
20:17:37 <SamB> now, despite all this, Coq *is* the only one of the three that even claims to have typeclasses
20:17:38 <koninkje> mightybyte: I don't recall if those implementations are "min heaps" i.e. fast access to the element with the smallest weight/priority, or "max heaps". But it's trivial to switch from one to the other
20:17:49 <SamB> and they are progressing fairly well ;-)
20:18:00 <mightybyte> koninkje: Yeah
20:18:07 <SamB> also, Epigram isn't available in usable form
20:18:13 <vixey> hey SamB, I haven't looked at typeclasses yet
20:18:23 <SamB> Epigram 1 is buggy as anything, Epigram 2 is vapourware ;-)
20:18:24 <dolio> Isabelle has type classes.
20:18:27 <vixey> but can you model e.g. a category and put a category inside it ?
20:18:36 <dolio> According to the paper I read on the Coq version.
20:18:40 <SamB> dolio: yes but doesn't it have undecidable typechecking?
20:18:44 <vixey> (without giving two separate definitions of category)
20:18:56 <vixey> Epigram 2 is not vaporware
20:19:02 <dolio> Isabelle in general?
20:19:12 <SamB> vixey: I don't know much category theory
20:19:30 <vixey> You can download it here http://www.e-pig.org/darcsweb?r=epigram
20:19:33 <lambdabot> Title: darcs - epigram
20:19:57 <SamB> dolio: btw, Coq's typeclass resolution does not seem to involve the typechecker
20:20:09 <dolio> Yeah, and two weeks ago they commited "I am doolally". That's progress.
20:20:16 <vixey> haha
20:20:22 <SamB> dolio: what?
20:20:35 <dolio> I'm looking at that commit log for epigram.
20:20:41 <SamB> vixey: what?
20:20:53 <SamB> how did I miss this ...
20:20:59 <dolio> SamB: Coq's type classes desugar to dependent records and then it does proof search, no?
20:21:01 <SamB> I have an RSS subscription and everything
20:21:40 <SamB> dolio: and an apparantly-new variant of implicit arguments, yes
20:23:09 <SamB> and you can change the proof-search tactics, too
20:25:48 <wuxia> is the following correct?: operators are just 'infix functions' and that functions have higher precendence than operators?
20:26:00 <vixey> that's exactly correct
20:27:30 <bd_> You can even define new ones :)
20:27:35 <mmorrow> i guess you could be like,     infixl 1 `asdf`       infixl 9 (!@#$)    though
20:27:48 <SamB> bd_: that's pretty much what the "just" means ;-)
20:27:55 <mmorrow> (operator *are* function)
20:28:13 <bd_> > let x +: y = x + y + y in 1 +: 2
20:28:14 <lambdabot>  5
20:28:18 <bd_> > let (+:) x y = x + y + y in 1 +: 2
20:28:18 <lambdabot>  5
20:28:29 <bd_> let foo x y = x + y + y in 1 `foo` 2
20:28:42 <bd_> ...hm
20:28:44 <bd_> oh
20:28:45 <bd_> > let foo x y = x + y + y in 1 `foo` 2
20:28:46 <lambdabot>  5
20:32:34 <mmorrow> correction....   infixl 9 !@#$
20:34:42 <mmorrow> being able to make data decls in lets would be the best thing since sliced bread
20:34:52 <vixey> really ?
20:34:58 <vixey> what would you do with it
20:35:13 <nolrai_East> :t liftM const $ get
20:35:14 <lambdabot> forall a1 b (m :: * -> *). (MonadState a1 m) => m (b -> a1)
20:35:16 <bd_> vixey: Define a lexically scoped instance, perhaps.
20:35:25 <bd_> (complete with variable bindings)
20:35:33 <vixey> oh closing over variables, I see
20:35:36 <mmorrow> vixey: i thought i could just whip out a bunch of examples, then i tried and i
20:35:40 <mmorrow> 'm like uhhh
20:35:43 <nolrai_East> :t const get
20:35:44 <lambdabot> forall (m :: * -> *) s b. (MonadState s m) => b -> m s
20:37:29 <TomMD> tommd
20:37:34 <TomMD> doh
20:38:42 <mmorrow> let T a = Tip a | Fork (T a) (T a) ; t = Fork (Fork (T 0) (Fork (T 1) (T 2))) (T 3) ; flatten t k = case t of {T a -> k [a] ; Fork l r -> flatten l (: flatten r k)} in flatten t
20:39:08 <mmorrow> (ok, a little contrived, but think how good sliced bread is)
20:39:13 <vixey> hehe
20:39:18 <mmorrow> ;)
20:45:43 <vixey> import qualified Raw
20:45:43 <vixey> import Raw (Ident,Name,parseFile,splitFile,Definition(..),definitionName)
20:45:47 <vixey> writing that sucks..
20:46:09 <vixey> is this really the way ? I only wanted to qualify two things frow Raw
20:46:39 <dolio> You can reverse it. import Raw hiding (one, two)
20:47:18 <shapr> YOW!
20:47:21 <shapr> @quote
20:47:21 <lambdabot> ricky_clarkson says: Sorry, I only use Haskell as a posh calculator.
20:47:22 <vixey> ah!
20:47:22 <vixey> import Raw hiding (Term(..),Type(..))
20:47:22 <vixey> import qualified Raw
20:47:28 <vixey> ok thanks
20:47:31 * shapr boings quietly
20:47:43 <dolio> I know how to do SPECIAL EFFECTS!!
20:48:06 * shapr cheers
20:48:08 <shapr> @yow
20:48:08 <lambdabot> Couldn't find fortune file
20:48:18 <shapr> dolio: You do a good job of being a bot!
20:48:23 <dolio> Thanks.
20:48:41 <dolio> Didn't you say you're an admin on code.haskell.org? Isn't that where lambdabot is run?
20:54:33 <sileni> wow
20:55:22 <shapr> dolio: I don't know where lambdabot is running.
20:55:23 <shapr> @seen dons
20:55:24 <lambdabot> dons is in #arch-haskell, #haskell, #ghc and #xmonad. I last heard dons speak 1h 2m 59s ago.
20:55:37 <sileni> anyone good at physics in here?
20:55:57 <shapr> Gravity works for me?
20:56:04 <vixey> haha
20:56:08 <SamB_XP> sileni: uh, anyone bad at physics in here?
20:56:32 <vixey> I'm probably bad at physics, I haven't thought about it in 2 years
20:57:05 <solrize> @seen ndmitchell
20:57:05 <lambdabot> I saw ndmitchell leaving #haskell-soc, #ghc and #haskell 1h 50m 47s ago, and .
20:57:35 --- mode: ChanServ set +o shapr
20:57:39 --- kick: shapr was kicked by shapr (wheee! Kicked by shapr)
20:57:50 <nolrai_East> how many bits is an Int?
20:57:54 <shapr> Ok, that wasn't very exciting after all.
20:58:04 <dolio> Depends where you're running.
20:58:18 <dolio> The report mandates at least... 30?
20:58:28 <SamB_XP> shapr: have you noticed any funny bussiness with your DNS lately?
20:58:35 <dolio> GHC does 32 on 32-bit architectures and 64 on 64-bit architectures.
20:58:36 <koninkje> > maxBound :: Int
20:58:37 <lambdabot>  2147483647
20:58:40 <shapr> SamB_XP: Why, do I need to upgrade it?
20:58:51 <shapr> SamB_XP: Have you been poisoning my cache?
20:58:58 <SamB_XP> shapr: not that kind of wierd
20:59:01 <nolrai_East> dolio: thanks!
20:59:05 <SamB_XP> not that DNS
20:59:14 <shapr> SamB_XP: Oh, what kind of DNS?
20:59:15 <SamB_XP> I noticed you're coming from rcn.com
20:59:24 <shapr> Yeh, for the last six months...
20:59:29 <shapr> Since I moved to Boston.
20:59:35 <SamB_XP> they've been interfering with DNS failures lately
20:59:43 <SamB_XP> some kind of search engine thing ...
21:00:02 <shapr> Oh, I have seen random rcn DNS lookup failures that had no good reason, yes.
21:00:15 <shapr> But I run my own DNS server, so I generally just use that.
21:00:16 <SamB_XP> wait you get actual failures?
21:00:30 * SamB_XP just gets false successes
21:00:43 <shapr> Yes, I get total and complete failures sometimes.
21:01:54 <sileni> haskell is cool
21:01:59 <shapr> Yes!
21:02:05 <SamB_XP> no it isn't
21:02:10 <shapr> It isn't?
21:02:18 <vixey> yeah it is :P
21:02:19 <sileni> what is the mass of sun when you put it inside a box filled with antimatter
21:02:20 * SamB_XP is just being contrary
21:02:32 <SamB_XP> (and/or devil's advocate)
21:02:41 <dolio> What color is the box?
21:02:45 <shapr> sileni: Wouldn't that imply that the sun (being part of the filling) is also antimatter?
21:02:51 <sileni> no i dont need to know that physics question
21:02:56 <shapr> In which case, the mass of the sun would be the same?
21:02:58 <nolrai_East> the docs say that StdGen will give me atleast 30 bits, can i sortof safely asume that GHC' StdGen will give me atlest 32 bits of randomness? im trying to figure out how many "getRandom :: Int"s i need in my getRandom
21:03:06 <sileni> wow shapr you actually thought about it
21:03:12 <SamB_XP> sileni: the mass of the sun is the same as before
21:03:16 <nolrai_East> s/GHC'/GHC's
21:03:18 <SamB_XP> assuming the sun is still there
21:03:30 <shapr> sileni: Aw, I was going for a low brain cell count joke :-(
21:03:42 <sileni> HUAHA
21:03:47 <sileni> you are awesome shapr
21:03:51 <SamB_XP> well, that is... the question is badly worded
21:03:58 <shapr> Why thank you!
21:04:02 <shapr> Flattery will get you everywhere!
21:04:10 <dolio> Don't give him a big head.
21:04:15 <sileni> hope so .. im coming out with a big question
21:04:17 <SamB_XP> and probably requires more info
21:05:03 <shapr> I already have a big head. You should see my hat size.
21:05:57 <shapr> Now if only my collection of published Haskell code were as large as my ego...
21:07:57 <Pseudonym> We could accomplish that by reducing your ego.
21:08:06 <shapr> ooh
21:16:22 <nolrai_East> is there a way to find out the number of constructors a type has other than just reading the souce and making a constant?
21:16:53 <cjs> you could make it enumerable.
21:17:13 <ddarius> :t getConstr
21:17:14 <lambdabot> Not in scope: `getConstr'
21:18:00 <ddarius> :t datatypeConstrs
21:18:01 <lambdabot> Not in scope: `datatypeConstrs'
21:18:09 <ddarius> :t Data.Generics.Basic.datatypeConstrs
21:18:10 <lambdabot> Couldn't find qualified module.
21:18:20 <ddarius> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Generics-Basics.html
21:18:21 <lambdabot> Title: Data.Generics.Basics, http://tinyurl.com/y6cr6c
21:18:32 <nolrai_East> ddarius++
21:18:57 <cjs> If it's convenient to derive Enum (which can be derived automatically), length.enumFromTo might do the trick.
21:19:16 <cjs> (E.g., if it's a type with only argless constructors.)
21:19:31 <cjs> If you're looking to do it generically for some reason, you've got to go outside standard Haskell.
21:19:34 <cjs> (I think.)
21:20:29 <nolrai_East> I just dont like relying on my counting skills the first two times i counted, i got differnt numbers.
21:20:38 <cjs> Oh, hmm...generics. Don't you have to be typable?
21:21:13 <cjs> Oh, is that it? maybe you just need to use a slightly different style. What were you doing, and what bug did you encounter that you needed to count the number of constructors?
21:24:20 <nolrai_East> It's for randomly generating a Instruction type i've made.  hmm i might want to leave it in hard coded so that i dont think that i dont have to change my code. If that makes sense.
21:24:37 <nolrai_East> Random isn't derivable is it?
21:26:39 <nolrai_East> I mean that wouldnt always give the distribution you'd like but then the Show isnt allways right either.
21:26:57 <ddarius> @src Random
21:26:57 <lambdabot> class Random a where
21:26:57 <lambdabot>   random    :: RandomGen g => g -> (a, g)
21:26:57 <lambdabot>   randoms   :: RandomGen g => g -> [a]
21:26:57 <lambdabot>   randomR   :: RandomGen g => (a,a) -> g -> (a,g)
21:26:57 <lambdabot>   randomRs  :: RandomGen g => (a,a) -> g -> [a]
21:26:59 <Cale> nolrai_East: No, but it's generally pretty easy to define.
21:26:59 <lambdabot>   randomRIO :: (a,a) -> IO a
21:27:01 <lambdabot>   randomIO  :: IO a
21:27:20 <Cale> nolrai_East: You can derive it using newtype-deriving for newtypes of course.
21:28:13 <nolrai_East> hmm.
21:28:27 <ddarius> @src Arbitrary
21:28:28 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
21:28:53 <nolrai_East> who's BOB?
21:30:02 <vixey> how do you typecheck two functions f and g if they are mutually recursive ?
21:30:55 <gvdm> fix points?
21:31:20 <gvdm> just a guess
21:31:23 <nolrai_East> how do you typecheck a recusive function in general?
21:31:29 <cjs> Hmmm. Some of your constructors are paramterized?
21:31:44 <cjs> (That was to nolrai_East.)
21:31:44 <nolrai_East> cjs: most of them.
21:32:13 <cjs> Hm. But some not. Hm.
21:32:15 <dolio> vixey: If you can typecheck self-recursive functions, you type check (f,g) = (def-f,def-g).
21:32:38 <nolrai_East> I gues i could sort them by what args they take. they fall in too only ~4 groups that way.
21:32:42 <vixey> ok so I assume f has type X, g has type Y
21:32:49 <nolrai_East> s/in too/into
21:32:50 <cjs> Are you using this for testing? You might want to look into QuickCheck.
21:33:08 <vixey> then I find the type of f, say it's A -> B, then I find the type of g maybe it's P -> Q
21:33:37 <vixey> I don't know if that takes everything into account
21:34:00 <vixey> like when you checked f, you didn't know g was P -> Q, just 'Y'
21:34:15 <vixey> so at the end if I unify X with A -> B, and Y with P -> Q..
21:34:26 <vixey> would that unification be the very last stage
21:35:06 <nolrai_East> vixey: how does it work for normal recursive functions?
21:35:39 <vixey> maybe I wanted to check fix f = f (fix f)
21:35:56 <vixey> then I assume fix has type X, and the typecheck f (fix f)
21:36:09 <vixey> say that results in P -> Q, you try to unify X = P -> Q
21:37:42 <timbod> I need to throw some praise in the direction of cabal-install. It's excellent.
21:38:10 <vixey> but if you have  f = ... g ..., g = ... f ..., then I suppose the best thing to do is... when you typecheck g, you've partially inferred a type for g
21:38:27 <vixey> since g is free in f, it should be added to the context for when you check g
21:38:35 <vixey> is that sound ?
21:39:18 <nolrai_East> sounds right to me.
21:39:44 <nolrai_East> I'd write that up and test its if it were me.
21:39:53 <nolrai_East> s/its/it
21:40:35 <nolrai_East> Do you think you can get away with not looking at f again after checking g?
21:40:35 <ddarius> vixey: You should just be able to associate the function(s) type(s) with a logic var and typecheck.
21:41:35 <Heffalump> vixey: that description with unification sounds about right to me
21:41:42 <ddarius> vixey: If you need to instantiate one of the function types to different types then things do get trickier (even in the self-recursive case)
21:42:05 <Heffalump> the crucial thing is that you generalise the types of f and g together.
21:42:16 <Heffalump> where generalise = inserting the implicit forall
21:42:24 <vixey> oh
21:42:32 <vixey> I don't know how to handle that
21:42:37 <vixey> f = g True ; g x = x would give g :: Bool -> Bool
21:42:50 <ddarius> vixey: Are you worrying about a polymorphic type system yet?
21:43:12 <vixey> yes
21:43:18 <nolrai_East> is there a quick way to find the lowest element not in a IntMap's keys?
21:43:49 <ddarius> :t Data.Map.IntMap.toAscList
21:43:49 <dmwit> -minBound is almost sure to be it. ;-)
21:43:49 <lambdabot> Couldn't find qualified module.
21:44:09 <Heffalump> vixey: it doesn't need to in that case, because f and g aren't mutually recursive
21:44:11 <vixey> this is hard :)
21:44:16 <Heffalump> typecheck g first, then generalise it, then typecheck f.
21:44:19 <nolrai_East> dmwit: not with wrap around. err
21:44:41 <vixey> so when you typecheck polymorphic lambda calculus, you have to generalise
21:44:46 <dmwit> errr... yeah, just plain minBound, obviously
21:44:59 <vixey> and generalise ... what is that ?
21:45:09 <Heffalump> vixey: that's inserting the forall
21:45:09 <vixey> it is turning the type Bool -> Bool into a -> b ?
21:45:25 <Heffalump> no, it's turning the type a -> b where a and b are free type variables, into forall a b . a -> b
21:45:43 <vixey> oh
21:45:50 <dmwit> nolrai_East: But yeah, IntMap does have the "keys" function.
21:45:55 <vixey> so in my example, f = g True ; g x = x
21:46:05 <Heffalump> once yu've done that, you can instantiate the type of g repeatedly at different use sites
21:46:22 <Heffalump> but until you generalise, any use of g will constrain a and b.
21:46:24 <vixey> could I typecheck f, and that will infer g :: True -> True, so I store [g :: True  -> True] as something which must be checked eventually
21:46:42 <dmwit> nolrai_East: and toAscList, which might be better if you're paranoid about new implementations returning the keys in a non-ascending list
21:46:43 <vixey> once I have type checked g, then I must try to unify its type with that, just to check
21:46:51 <ddarius> vixey: It's helpful to "preprocess" let bindings into SCCs.
21:47:33 <Heffalump> vixey: umm, probably, yeah. But as ddarius says, the standard way is to build a topologically sorted list of SCCs and do them in dependency order, i.e. g first then f.
21:47:42 <vixey> I don't really have let, but sort of everything on the LHS is let
21:47:45 <Heffalump> where SCC = strongly connected component, i.e. a mutually recursive group
21:47:53 <Heffalump> vixey: indeed
21:48:28 <vixey> ordering them into SCC is for efficiency right?
21:48:40 <ddarius> vixey: It's for simplicity
21:48:51 <ddarius> Though it probably does help efficiency.
21:48:59 <vixey> I don't understand how it makes things simpler
21:49:15 <vixey> since mutually recursive functions may exist
21:49:32 <ddarius> vixey: It doesn't change that.
21:49:39 <ddarius> vixey: It just makes it clearer what depends on what.
21:50:01 <Heffalump> it's not just for efficiency, it gets you more general types
21:50:17 <Heffalump> if you typecheck f and g as a group, you get g :: Bool -> Bool. If you generalise g before you typecheck f, you get g :: a -> a
21:50:22 <ddarius> So you can take an SCC and postpone generalization for the group instead of having to figure out what things could be generalized.
21:50:39 <vixey> well I was thinking of this algorithm,
21:51:58 <nolrai_East> dmwit: hmm but thats not very fast, would keeping track of the holes in the map as i add and delelet elems be worth the memory? (i.e. using a Map of (Maybe Int)) I just dont want to run up against the maxBound of Int. whats one day divided by (maxBound :: Int)?
21:52:21 <ddarius> head . toAscList should be reasonably fast
21:52:37 <dmwit> nolrai_East: ...what?
21:55:12 <vixey> why don't you use Integer instead of Int then
21:55:26 <vixey> I wonder if my algorithm is correct
21:56:39 <nolrai_East> ddarius: thats not what i want, I want to fill in the gaps on in a map, because the map never contains more than 2^16 elements, but is geting elements removes and inserted all the time, and dont want to run up against max bound, but using Integer seems silly because of the size limit.
21:57:01 <vixey> Integer has no size limit
21:57:36 <nolrai_East> vixey: I know but speed is needed. (maybe)
21:57:53 <vixey> Integer is fast
21:58:26 <nolrai_East> > (fromInteger $ 24 * 60 * 60) / (fromInteger (maxBound :: Int))
21:58:27 <lambdabot>  Couldn't match expected type `Integer' against inferred type `Int'
21:58:43 <nolrai_East> > (fromInteger $ 24 * 60 * 60) / (fromIntegral (maxBound :: Int))
21:58:45 <lambdabot>  4.0233135242123685e-5
21:58:51 <vixey> > 24 * 60 * 60 `div` (maxBound :: Int)
21:58:52 <lambdabot>  0
21:59:03 <ddarius> nolrai_East: You've seem to have changed your requirements from what you originally said.
21:59:19 <nolrai_East> then i baddly expressed my self.
22:00:00 <ddarius> nolrai_East: I would have to agree.  I have no idea what you mean by "filling in the gaps".  What are "the gaps" and why do they need to be "filled in" and with what?
22:00:49 <nolrai_East> I want the smallist key *not* in the map --the part you seem to have missed
22:02:01 <nolrai_East> ddarius: say I add three elements (My keys are generated sequenchaly(spelling?)) then delete the middle one.
22:02:13 <ddarius> sequentially
22:03:21 <nolrai_East> now when i add another element i want to use the key of the element that i deleted?
22:05:26 <nolrai_East> allthough given that 4e-5 result i dont think i have to wory about this.  I dont think ill be adding keys fast enough, and dont plan on runing this for days at a time.
22:06:43 <nolrai_East> hmm i could keep a set of keys avalible from deletion, that would be rather fast.
22:07:34 <nolrai_East> s/from/because of
22:08:49 <bd_> Use an Int64 and be happy :)
22:09:33 <ddarius> It's probably fast enough in practice (unless you expect the pathological case to be common) to simply keep track of the lowest free element and go through the output of toAscList when that element is inserted to find the next minimum.
22:10:13 <nolrai_East> ddarius: what is the path. case in this case?
22:10:28 <bd_> Data.Map has a findMin and findMax
22:11:05 <ddarius> 2^16-1 elements from minBound+1 up are inserted and then minBound is inserted.
22:11:21 <ddarius> That would involve iterating over a list of 65535 elements.
22:11:29 <nolrai_East> Yeah that works.
22:12:06 <nolrai_East> and the original elements would still have to be there. This case is going to happen for a long long time.
22:14:38 <_zenon_> nolrai_East: May I ask you about your nickname?
22:15:56 <nolrai_East> lost the password to nolrai, and to nolrai_ and was at my Dads house which is east of my Moms.
22:16:52 <ddarius> nolrai_East: Another pathological case that may be more serious is if you insert X elements starting from minBound going up, delete the first, and insert a new one at minBound, and repeatedly do that, then you have an O(X) cost each insert.
22:17:05 <nolrai_East> nolrai is lojban for king (or queen) glosed. highest class. (as in social class).
22:17:35 <bd_> nolrai_East: I'd seriously suggest just using an incrementing Int64... it's unlikely that you'd use it for long enough for it to wrap around
22:18:13 <nolrai_East> hmm its a good thing i chcked this i was incrementing my keys at all!
22:18:13 <_zenon_> nolrai_East: Interesting story :)
22:19:37 <nolrai_East> s/was/wasn't
22:20:47 <nolrai_East> ddarius: that case can't happen because of the size limit.
22:20:54 <nolrai_East> (the second one)
22:21:06 <ddarius> nolrai_East: Essentially (maybe explicitly?) what you are doing is treating the IntMap as a linear block of memory and performing a (manual) memory management algorithm on it.  If you want a robust, efficient algorithm, lookup memory management algorithms.
22:21:47 <nolrai_East> ddarius: Thaks haddn't thought of it that way!
22:21:58 <nolrai_East> s/thaks/thanks
22:22:09 <nolrai_East> ddarius++
22:22:58 <_zenon_> @karma ddarius
22:22:58 <lambdabot> ddarius has a karma of 2
22:23:19 <ddarius> People must have gotten angry at me.
22:23:28 <ddarius> @karma Cale
22:23:28 <lambdabot> Cale has a karma of 0
22:24:45 <nolrai_East> preflex: karma Cale
22:24:58 <nolrai_East> hmm who was that
22:25:20 <Cale> huh
22:25:24 <Cale> I wonder how that happened.
22:25:34 <Cale> hmm...
22:25:46 <nolrai_East> I think the karmas got wiped resently.
22:25:52 <nolrai_East> @yow
22:25:53 <lambdabot> Couldn't find fortune file
22:25:53 <shapr> @karma shapr
22:25:53 <lambdabot> You have a karma of 0
22:26:10 <dmwit> ?karma
22:26:11 <lambdabot> You have a karma of 0
22:26:19 <dmwit> Everybody's reset.
22:26:19 <nolrai_East> maby related to yow failing?
22:26:22 <Cale> I'm not sure where I'm supposed to get/put the fortune file for lambdabot to find it.
22:26:24 <dmwit> Level playing ground. =)
22:26:35 <ddarius> nolrai_East: Perhaps another approach would be to store Either Int Value.  Then, when you can store a "free list" in the IntMap itself.
22:26:40 <shapr> vixey++
22:26:46 <Cale> No, @yow's been broken ever since I started running lambdabot.
22:26:55 <Cale> I don't have fortune in my user account on code.h.o
22:27:05 <shapr> oh, you're running lambdabot now?
22:27:09 <Cale> (and code.h.o doesn't seem to have that program)
22:27:13 <Cale> Yeah.
22:32:24 <_zenon_> How much does ByteString improve performance when reading huge files?
22:34:08 <dmwit> I've heard reports of an order-of-magnitude improvement.
22:34:19 <Cale> _zenon_: Yeah, quite a lot.
22:34:42 <_zenon_> Cale: Maybe I should take the time to explore ByteString
22:35:17 <Cale> _zenon_: Some simple bytestring programs can rival or beat naive C programs.
22:36:09 <_zenon_> Cale: Are there some good examples around for using ByteString or is it as good as intiutive?
22:36:24 <dmwit> Just read the docs, you'll see how to use it instantly.
22:36:48 <Cale> It's pretty simple. The library sort of mimics the List library.
22:36:57 <_zenon_> Cale: Okay
22:37:00 <_zenon_> dmwit: Sure.
22:37:07 <Cale> However, I noticed some strange omissions.
22:37:40 <Cale> Like, I think isSuffixOf was missing from one of the ByteString libraries and not the others.
22:38:51 <Cale> :t Data.ByteString.Lazy.isSuffixOf
22:38:52 <lambdabot> BSLC.ByteString -> BSLC.ByteString -> Bool
22:38:58 <Cale> :t Data.ByteString.Lazy.Char8.isSuffixOf
22:38:58 <lambdabot>     Not in scope: `Data.ByteString.Lazy.Char8.isSuffixOf'
22:38:59 <ddarius> data Mem v = Mem { freeListHead :: !Int, mem :: !(IntMap (Either Int v)) }; emptyMem = Mem minBound IntMap.empty; insertMem v (Mem hd mem) = case lookup hd mem of { Nothing -> Mem (hd+1) (insert hd (Right v) mem); Just (Left hd') -> Mem hd' (insert hd (Right v) mem) }; deleteMem k (Mem hd mem) = Mem k (insert k (Left hd) mem)
22:39:23 <Cale> :t Data.ByteString.Lazy.Char8.isPrefixOf
22:39:24 <lambdabot> BSLC.ByteString -> BSLC.ByteString -> Bool
22:40:15 <_zenon_> Hm... Word8, never seen that before
22:40:29 <Cale> Word8 is just an 8 bit positive integer.
22:40:34 <_zenon_> check
22:41:15 <_zenon_> I have a lot of file reading and writing going on in my program, so I figure ByteString should be a fresh air.
22:43:03 <z0MB13> who can say hello to me as a md5 or decipher what kind of technique can be used to remove the password
22:43:13 <shapr> What?
22:43:32 <z0MB13> I want to get the pass admin
22:43:40 <shapr> You want to get admin for what?
22:43:40 <geezusfreeek> ...
22:43:59 <geezusfreeek> i love the internet
22:44:00 <shapr> admin for #haskell?
22:44:05 <dmwit> We are hackers, not crackers.
22:44:46 <_zenon_> it's okay! z0MB13 is from the internet!
22:44:47 <shapr> z0MB13: I don't understand.
22:44:48 <z0MB13> newbie
22:44:54 <shapr> z0MB13: Where?
22:45:22 <shapr> z0MB13: You're failing your turing test at the moment. Can you convince me that you're a human?
22:45:49 <_zenon_> hahaha
22:45:50 <_zenon_> :)
22:45:52 <geezusfreeek> @faq Can Haskell tell the difference between a bot and a human?
22:45:52 <lambdabot> The answer is: Yes! Haskell can do that.
22:46:04 <_zenon_> That reminds me of the turing test extra credit from xkcd :)
22:46:32 <_zenon_> http://imgs.xkcd.com/comics/turing_test.png
22:46:41 <_zenon_> Hillarious!
22:46:42 <geezusfreeek> extra credit for convincing the tester he's a bot?
22:46:50 <geezusfreeek> ah yes
22:46:54 <_zenon_> geezusfreek: yes :)
22:47:18 <shapr> z0MB13: Do you want to learn Haskell?
22:47:40 * geezusfreeek bets on bot
22:48:05 * dobblego stands next to geezusfreeek 
22:48:23 * shapr stands over there somewhere.
22:48:24 <z0MB13> good
22:48:28 <vininim> z0MB13: part
22:48:56 <vininim> @bot
22:48:57 <lambdabot> :)
22:49:14 <lament> z0MB13: hablas español?
22:49:33 <_zenon_> kick ?
22:49:46 <z0MB13> soy argentino
22:49:58 <shapr> z0MB13: Talar du svenska? spraakt u nederlands? spreichen sie Deutsch? parlez vous francais? puhutko suomea?
22:50:05 <shapr> aha
22:50:09 <dmwit> portuguese?
22:50:23 <shapr> oi, como vai?
22:50:26 <kaol> shapr: what's up with http://hackage.haskell.org/cgi-bin/hackage-scripts/package/generic-xml ? Is that what became HAppS-Data?
22:50:26 <vininim> spanish
22:50:29 <lambdabot> Title: HackageDB: generic-xml-0.1, http://tinyurl.com/57fhou
22:50:49 <shapr> ola, como est as?
22:50:57 <lament> z0MB13: aqui hablamos de haskell, un lenguaje de programacion
22:51:03 <shapr> lament: yay
22:51:23 <z0MB13> si algo estoy leyendo de eso
22:51:46 <lament> z0MB13: hackers estan por otros canales
22:51:54 <dons> z0MB13: 8dd6b6560c760ceeccf7a7e52e1fd362
22:51:58 <shapr> jo, Haskell är för programmering! mjukvaru utveckling!
22:51:59 <z0MB13> si peo me gusta la rpogramacion
22:51:59 <vininim> or not
22:52:07 <shapr> dons: Ooh, what's that one?
22:52:09 <z0MB13> yo programo en C
22:52:13 <lament> dons: you win
22:52:17 <z0MB13> perl
22:52:19 <shapr> dons: aha!
22:52:26 <shapr> dons: You did an md5 hash of hello!
22:52:31 <dons> hehe
22:52:38 <z0MB13> a y tambien programo algo de java
22:52:39 <shapr> @quote z0MB13
22:52:39 <lambdabot> z0MB13 says: who can say hello to me as a md5 or decipher what kind of technique can be used to remove the password
22:52:47 <shapr> That's really nifty surreal humor.
22:53:39 <lament> z0MB13: pero aqui se habla el ingles, si quieres hablar en espanol, tambien tenemos #haskell.es
22:54:06 * quicksilver peers into #haskell, observes apparent madness.
22:54:10 <quicksilver> business as usual then.
22:54:22 <shapr> heh
22:54:29 * lament eats quicksilver's ear
22:54:31 <z0MB13> por ultimo sabes del alguna sala que hablen de sobre hack
22:54:35 * shapr throws thermometers at quicksilver 
22:54:38 <geezusfreeek> yeah i think my turing meter just broke
22:54:40 <lament> z0MB13: no
22:54:51 <shapr> ok then
22:54:51 * ddarius writes a Prolog interpreter in Javascript.
22:54:52 <lament> aww
22:54:55 <shapr> lament: What did he say?
22:55:01 <_zenon_> shapr: mjukvaruutveckling torde det väll vara? inte två ord. :P
22:55:14 <shapr> oops
22:55:28 <lament> shapr: he asked if i knew of a hacking channel, i said no and he left
22:55:30 <dons> ?babel en es z0MB13 are you the zombie turing? do you like infinite tapes?
22:55:30 <lambdabot> Plugin `babel' failed with: Prelude.head: empty list
22:55:42 <dons> oh that's sad
22:55:56 <geezusfreeek> lambdabot's turing meter broke as badly as mine, apparently
22:55:59 <shapr> _zenon_: I admit, my Swedish skills never were than great, but they're going downhill now that I don't have a chance to speak Swedish to anyone.
22:56:15 <shapr> I should really hook up with the nordboistan people.
22:56:29 <_zenon_> shapr: Sad... you'll have to brush it up by writing a swedish chat-bot then :)
22:56:39 <shapr> I have recently wondered whether the name Boston was originally 'Bo stan'
22:56:40 <quicksilver> ingen mana!
22:57:05 * quicksilver 's only experience of swedish is online gaming with swedes.
22:57:09 <shapr> Har du ingen mana? How will you cast spells withouth that?
22:57:13 * shapr grins
22:58:05 <shapr> lament: I guess the word Haskell is vaguely like Hack?
22:58:06 <shapr> or not?
22:58:18 <lament> maybe
22:58:20 <_zenon_> quicksilver: hehehe ingen mana!
22:58:35 <_zenon_> @remember ingen.mana!
22:58:36 <lambdabot> Incorrect arguments to quote
22:58:41 <_zenon_> noooooo
22:58:45 <lament> shapr: i used to be a regular in #nethack, imagine all the fun visitors we got
22:58:51 <shapr> Yeah, I can guess.
22:59:03 <dmwit> lament: Aw, it's not *that* common.
22:59:07 <_zenon_> Ask hell
22:59:12 <_zenon_> Has kell?
22:59:17 <lament> dmwit: no, unfortunately :)
22:59:17 * shapr dunno
22:59:26 <ddarius> Sell Hak
22:59:27 <lament> it's very entertaining whenever it happens
23:00:30 <lament> we'd throw a bunch of undecypherable nethacker jargon at the newcomer, who'd think we're all complete idiots and leave.
23:00:34 <quicksilver> "How do I hack into my bank's server?" "Just say 'Croesus' to the guards and take the gold." ?
23:00:44 <lament> yes.
23:00:58 <_zenon_> ddarius: That could have been from star trek :)
23:02:30 <shapr> It's late, I should be sleeping.
23:06:00 <nolrai_East> @hoogle minBound
23:06:01 <lambdabot> Prelude.minBound :: Bounded a => a
23:07:01 <cjs> @hoogle enumFromTo
23:07:02 <lambdabot> Prelude.enumFromTo :: Enum a => a -> a -> [a]
23:07:02 <lambdabot> Language.Haskell.Syntax.HsEnumFromTo :: HsExp -> HsExp -> HsExp
23:07:42 <nolrai_East> @src (+)
23:07:42 <lambdabot> Source not found. Maybe if you used more than just two fingers...
23:07:48 <nolrai_East> ??
23:07:58 <cjs> lambdabot gets a bit snarky sometimes.
23:08:28 <nolrai_East> I am just wondering why it cant find source thats in the prelude.
23:08:52 <cjs> Is it? I thought it was some sort of weird built-in thing.
23:08:57 <nolrai_East> @src fromIntegral
23:08:58 <lambdabot> fromIntegral = fromInteger . toInteger
23:09:41 <nolrai_East> @hoogle (+)
23:09:41 <lambdabot> Prelude.(+) :: Num a => a -> a -> a
23:09:41 <lambdabot> Prelude.(++) :: [a] -> [a] -> [a]
23:09:41 <lambdabot> Data.List.(++) :: [a] -> [a] -> [a]
23:10:00 <nolrai_East> thats what i was looking for.
23:10:42 <nolrai_East> cjs: it might be.
23:10:59 <cjs> You asked for src, not for hoogle.
23:11:18 <cjs> No, it's not in GHC's source for Prelude; it comes from elsewhere....
23:12:01 <cjs> It's probably implemented as a built-in primitive that compiles down to an instruction or two, in the Int case.
23:12:24 <cjs> It's Prelude that officially exports it, though.
23:12:36 <cjs> @src length
23:12:36 <lambdabot> Source not found. Are you on drugs?
23:12:42 <cjs> @src foldl
23:12:42 <lambdabot> foldl f z []     = z
23:12:42 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
23:13:03 <mjrosenb> no source for length?
23:13:15 <cjs> Again, probably a primitive.
23:13:58 <_zenon_> Just out of pure lazyness
23:14:00 <mjrosenb> how on earth is that a primitive?
23:14:12 <cjs> It doesn't have to be, but might be implemented that way for speed.
23:14:13 <_zenon_> how do I put the list "hello" into a ByteString?
23:14:30 <solrize> has anyone ever implemented something like serialized functional maps?  i.e. something like Data.Map where on every update or deletion you can append something to a disk file, and then another program can locate any key/value in the file with O(log n) disk operations
23:14:40 <cjs> _zenon_: pack "Hello"
23:16:11 <_zenon_> are you sure?
23:16:19 <nolrai_East> is there a LANGUAGE pragma equivalent to -fallow-undecidable-instances and if not why not?
23:16:38 <solrize> nolrai_east i think you can do that
23:16:50 <dolio> UndecidableInstances
23:16:51 <sjanssen> mjrosenb: the @src database is rather incomplete
23:16:59 <ddarius> (+) doesn't have source, it is a method not a function
23:17:10 <_zenon_> cjs: That doesn't seem to work
23:17:10 <mjrosenb> sjanssen: fair enough
23:17:19 <ddarius> cjs: length is not primitive.
23:17:21 <nolrai_East> ok then.
23:17:25 <cjs> ddarius: (+) is a function like any other, except that it's not written in Haskell.
23:17:32 <ddarius> @src Num
23:17:33 <lambdabot> class  (Eq a, Show a) => Num a  where
23:17:33 <lambdabot>     (+), (-), (*)           :: a -> a -> a
23:17:33 <lambdabot>     negate, abs, signum     :: a -> a
23:17:33 <lambdabot>     fromInteger             :: Integer -> a
23:17:34 <cjs> _zenon_: which ByteString are you using?
23:17:34 <sjanssen> mjrosenb: if you want to see the real source of something, I recommend using ghci's :info command combined with a checkout of the library source
23:17:53 <sjanssen> cjs: which (+)?
23:17:53 <_zenon_> cjs: Data.ByteString
23:17:57 * mjrosenb wishes djinn supported recursive datatypes
23:17:59 <_zenon_> http://hackage.haskell.org/packages/archive/bytestring/0.9.1.0/doc/html/Data-ByteString.html#2
23:18:00 <ddarius> cjs: (+) is a method of Num.  The value of (+) at Int is something else.
23:18:02 <lambdabot> Title: Data.ByteString, http://tinyurl.com/5uw43o
23:18:04 <mjrosenb> halting problem be damned
23:18:04 <ddarius> @src Int (+)
23:18:05 <lambdabot> Source not found. My mind is going. I can feel it.
23:18:35 <cjs> Oh, I see what you mean. True, but it has functions that implement it.
23:18:40 <Trinithis> with MVar: if I takeMVar ... do something ... putMVar ---- is that basically the same as withMVar?
23:18:44 <ddarius> mjrosenb: Supporting inductive types, such as (finite) lists, should not be too too hard.
23:18:51 <sjanssen> instance  Num Int  where (+)    = plusInt
23:18:53 <ddarius> It is certainly possible.
23:19:17 <sjanssen> (I# x) `plusInt`  (I# y) = I# (x +# y)
23:20:07 <nolrai_East> where +# is a primitive?
23:20:20 <_zenon_> damnit, I can't even make a small example using ByteString
23:20:24 <quicksilver> cjs: right, but @src will not show the source of any method, unadorned.
23:20:35 <quicksilver> cjs: you have to tell it which instance you want (and then it only has some)
23:20:35 <cjs> nolrai_East: Sounds like you want the '{-# OPTIONS_GHC #-}' stuff. It's in the ghc manual under "pragmas"  somewhere.
23:20:49 <Trinithis> oh, and should I use Control.Concurrent.* instead of GHC.Conc?
23:20:59 <cjs> E.g., "{-# OPTIONS_GHC -XBangPatterns #-}"
23:21:03 <quicksilver> nolrai_East: UndecidableInstances if I'm not mistaken.
23:21:22 <nolrai_East> thanks all!
23:21:26 <quicksilver> cjs: nolrai_East asked for a LANGUAGE pragma not an OPTIONS_GHC though ;)
23:21:40 <quicksilver> Trinithis: yes, in general.
23:21:41 <cjs> quicksilver: True! You get the pedant award!
23:21:46 <Trinithis> k
23:22:04 <cjs> The question is, nolrai_East a pedant too. :-)
23:22:11 <quicksilver> the GHC.X modules are really internal although there are occasional cases.
23:22:15 <cjs> (If so, I get flamed now.)
23:22:36 <nolrai_East> today i feel like one, but am to hot to flame.
23:22:40 <quicksilver> cjs: well he already knew the option name, which he already had, and was asking for the LANGUAGE equivalent. or that's how I read it.
23:22:57 <cjs> I just assumed he wanted to embed it in a source file.
23:23:03 <cjs> I could be wrong.
23:23:05 <_zenon_> someone has some Data.ByteString examples?
23:23:44 <nolrai_East> cjs: YOU ARE WRONG! YOU FAIL AT LIFE! :P --that good?
23:25:00 <quicksilver> _zenon_: where are you getting stuck?
23:25:02 <cjs> Hardly! A single exclamation point at the end of each sentence? lAME!!!111!! :-)
23:25:28 <quicksilver> _zenon_: remember there are four bytestrings: strict/lazy x Char8/Word8
23:25:33 <quicksilver> pick the one you want :)
23:25:56 <_zenon_> quicksilver: I can't even create a bytestring with something I want, like the list "hello world"
23:26:14 <quicksilver> pack "hello world"
23:26:21 <quicksilver> with the appropriate version of pack in scope.
23:26:40 <_zenon_> pack :: [GHC.Word.Word8] -> ByteString
23:26:44 <quicksilver> right.
23:26:51 <quicksilver> that's where I point back at my previous comment
23:26:57 <quicksilver> about Char8 versions of bytestring?
23:27:00 <_zenon_> Couldn't match expected type `GHC.Word.Word8'
23:27:02 <quicksilver> and "remember there are four" ?
23:27:31 <quicksilver> change your import statement to import Data.Bytestring.Char8
23:27:49 <mwc> Hahahahahah: http://ib-krajewski.blogspot.com/2008/07/c-pocket-lambda-library-last.html
23:27:51 <lambdabot> Title: On Software and Languages: C++ pocket lambda library, the last, http://tinyurl.com/5jzhv8
23:27:51 <_zenon_> quicksilver: there we go
23:27:51 <nolrai_East> @hoogle random
23:27:51 <lambdabot> System.Random.random :: (Random a, RandomGen g) => g -> (a, g)
23:27:51 <lambdabot> System.Random :: module
23:27:51 <lambdabot> System.Random.Random :: class Random a
23:27:58 <cjs> _zenon_: In ghci, try: ":m + Data.ByteString.Lazy.Char8" followed by "pack "Hello""
23:27:58 <mwc> Note spelling of 'polymorfic'
23:29:32 <mwc> C++ programmers can't even spell polymorphic :)
23:29:47 <nolrai_East> rimshot
23:30:19 <nolrai_East> @hoogle runState
23:30:20 <lambdabot> Control.Arrow.Transformer.State.runState :: Arrow a => StateArrow s a e b -> a (e, s) (b, s)
23:30:20 <lambdabot> Control.Monad.State.Lazy.runState :: State s a -> s -> (a, s)
23:30:20 <lambdabot> Control.Monad.State.Strict.runState :: State s a -> s -> (a, s)
23:30:55 <quicksilver> _zenon_: working now?
23:31:01 <_zenon_> The different versions of ByteString seem not to be mentioned in hoogle?
23:31:11 <_zenon_> quicksilver: yeah, one step in the right direction :)
23:31:53 <quicksilver> _zenon_: http://www.haskell.org/hoogle/?q=pack for me shows the four variants as the first four answers?
23:31:54 <lambdabot> Title: pack - Hoogle
23:32:24 <quicksilver> _zenon_: I also advise always having this page open : http://www.haskell.org/ghc/docs/latest/html/libraries/
23:32:25 <lambdabot> Title: Haskell Hierarchical Libraries
23:33:16 <_zenon_> quicksilver: Yeah, the hierarch... that's a great one :) however, when pressing the modules link in hoogle, I thought it would show the versions of ByteString available?
23:34:06 <quicksilver> _zenon_: which is the module link? I don't use hoogle very often...
23:34:24 <_zenon_> http://haskell.org/ghc/docs/latest/html/libraries/bytestring/Data-ByteString.html
23:34:25 <lambdabot> Title: Data.ByteString, http://tinyurl.com/39be59
23:34:43 <quicksilver> ah well, that package is the strict/word8 version
23:34:52 <_zenon_> quicksilver: k
23:34:57 <quicksilver> it might be nice if it mentioned in its intro that there are other versions, certainly.
23:35:11 <_zenon_> quicksilver: precisely :)
23:35:15 <_zenon_> quicksilver++
23:40:41 <nolrai_East> @src Word8 Random
23:40:41 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
23:40:52 <nolrai_East> @src Word8 getRandom
23:40:52 <lambdabot> Source not found. I've seen penguins that can type better than that.
23:40:59 <Baughn> It's the other way around
23:40:59 <nolrai_East> @src Word8 (+)
23:40:59 <lambdabot> Source not found. Wrong!  You cheating scum!
23:41:02 <Baughn> @src Random Word8
23:41:02 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
23:41:13 <nolrai_East> @src (+) Word8
23:41:14 <lambdabot> Source not found. My mind is going. I can feel it.
23:41:17 <Baughn> ..granted, the source might not be registered, but it /is/ the other way around
23:41:31 <nolrai_East> hmm
23:41:53 <Baughn> @src Show []
23:41:54 <lambdabot> Source not found.
23:41:57 <Baughn> @src show []
23:41:57 <lambdabot> Source not found. :(
23:42:06 <_zenon_> @src src
23:42:07 <lambdabot> Source not found. :(
23:42:11 <_zenon_> hehe
23:42:14 <nolrai_East> Are instances of Random for Word8 and 16 anywhare?
23:42:34 <Baughn> Don't need one. Use the one for Int
23:42:43 <nolrai_East> ?
23:42:44 <Baughn> And randomRs
23:43:22 <nolrai_East> so no then.
23:43:43 <nolrai_East> but there easy to write.
23:43:58 <nolrai_East> s/there/they're
23:44:19 <Baughn> > randomRs (minBound :: Word8,maxBound::Word8) (mkStdGen 42)
23:44:20 <lambdabot>  [207,79,133,250,236,55,126,31,18,179,37,19,20,6,184,97,183,39,129,200,94,88,...
23:44:47 <Baughn> > randomRs (minBound :: Word16,maxBound::Word16) (mkStdGen 42)
23:44:48 <lambdabot>   add an instance declaration for (Random Word16)
23:44:48 <lambdabot>     In the expression:
23:44:48 <lambdabot>     ...
23:45:01 <nolrai_East> see!
23:45:14 <Baughn> > randomRs (fromInteger (minBound :: Word16)::Int,fromInteger (maxBound::Word16)::Int) (mkStdGen 42)
23:45:15 <lambdabot>  Couldn't match expected type `Integer'
23:45:30 <Baughn> > randomRs (fromIntegral (minBound :: Word16)::Int,fromIntegral (maxBound::Word16)::Int) (mkStdGen 42)
23:45:30 <nolrai_East> although thats odd that Word8 worked.
23:45:31 <lambdabot>  [41423,40783,10117,30458,62444,46135,15230,17439,52498,31155,38437,32787,606...
23:46:00 <nolrai_East> :t randomRs (fromIntegral (minBound :: Word16)::Int,fromIntegral (maxBound::Word16)::Int) (mkStdGen 42)
23:46:01 <lambdabot> [Int]
23:46:28 <nolrai_East> @hoogle Word8 -> Int
23:46:28 <lambdabot> Data.ByteString.count :: Word8 -> ByteString -> Int
23:46:33 <Baughn> > map (fromIntegral :: Int -> Word16) $ randomRs (fromIntegral (minBound :: Word16)::Int,fromIntegral (maxBound::Word16)::Int) (mkStdGen 42)
23:46:34 <lambdabot>  [41423,40783,10117,30458,62444,46135,15230,17439,52498,31155,38437,32787,606...
23:47:17 <Baughn> Mind you, you should probably just instance Random
23:47:26 <Baughn> (This shows you how)
23:49:06 <nolrai_East> Baughn++
23:50:44 <carl> im trying to make an IO function to connect to a server and "return" the connected socket right now im trying this
23:51:27 <carl> doLogin :: Socket -> IO ()
23:51:27 <carl> doLogin = do
23:51:27 <carl> 	serverSock <- getServerSock "login01.tibia.com" 7171
23:51:27 <carl> 	putStrLn "yay"
23:51:27 <carl> getServerSock :: String -> PortNumber -> IO Socket
23:51:30 <carl> getServerSock hostStr port = do
23:51:32 <carl> 	host <- inet_addr hostStr
23:51:34 <carl> 	let hostAddr = AddrInfo {
23:51:37 <carl> 		addrFlags = [AI_PASSIVE],
23:51:40 <carl> 		addrFamily = AF_INET,
23:51:42 <carl> 		addrSocketType = Stream,
23:51:44 <carl> 		addrProtocol = 6,
23:51:47 <carl> 		addrAddress = (SockAddrInet port host),
23:51:49 <carl> 		addrCanonName = Nothing
23:51:52 <carl> 	}
23:51:55 <carl> 	serverSock <- socket (addrFamily hostAddr) (addrSocketType hostAddr) (addrProtocol hostAddr)
23:51:58 <carl> 	connect serverSock (addrAddress hostAddr)
23:52:00 <carl> 	return serverSock
23:52:03 <carl> and im getting     Couldn't match expected type `Socket -> t' against inferred type `IO Socket'
23:52:33 <nolrai_East> carl: in the future use hpast if your code is more then 4 lines or so.
23:52:44 <nolrai_East> s/hpast/hpaste
23:52:45 <carl> whats hpaste?
23:52:48 <electronx> carl: bad boy is hpast.org
23:52:52 <electronx> use*
23:53:25 <carl> k
23:53:37 <electronx> hpaste.org*
23:54:50 <_zenon_> @pastebin
23:54:50 <lambdabot> Unknown command, try @list
23:54:54 <_zenon_> ~pastebin
23:55:17 <_zenon_> hm,,, doesn't lambabot have a pastebin command?
23:55:19 <nolrai_East> carl: where does the error say that it is occouring?
23:55:46 <ski> @paste
23:55:47 <lambdabot> Haskell pastebin: http://hpaste.org/new
23:56:00 <carl> lol ill hpaste the whole thing
23:57:15 <_zenon_> carl: better that way
23:58:49 <hpaste>  carl pasted "socketerror" at http://hpaste.org/8820
23:59:05 <carl> http://hpaste.org/8820
23:59:14 <carl> lol check that out it tells u neway
