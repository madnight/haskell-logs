00:00:17 <visof> > sum &&& length [1,2,3]
00:00:32 <lambdabot>  thread killed
00:00:55 <visof> > sum &&& length [1,2,3]
00:00:56 <lambdabot>  Couldn't match expected type `[a] -> c''
00:01:06 <allbery_b> $ or parens
00:01:10 <visof> > (sum &&& length) [1,2,3]
00:01:26 <lambdabot>  thread killed
00:01:36 <allbery_b> oy
00:01:38 <visof> > (sum &&& length) $ [1,2,3]
00:01:54 <lambdabot>  thread killed
00:02:19 <|Steve|> > (sum &&& length) [1..3]
00:02:20 <lambdabot>  (6,3)
00:03:04 <|Steve|> Just a stab in the dark but, (&&&) f g x = (f x,g x)?
00:03:09 <|Steve|> @src (&&&)
00:03:09 <lambdabot> f &&& g = arr (\b -> (b,b)) >>> f *** g
00:19:05 <mdmkolbe> @type (&&&)
00:19:20 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
00:19:53 <mdmkolbe> |Steve|: yeah, you seem to be right
00:31:01 <misterbeebee__> dolio: yes, sum and lengtg
00:33:03 <misterbeebee__> but interleaved and strict, so it doesn't overflow stack
01:07:20 <ArtVandalae> Hi, I'm trying to learn functional programming. Are there any books that you can recommend? Would Haskell be the ideal language to start functional programming in? (I know this may be a strange place to ask, considering it's a Haskell channel)
01:09:32 <johnnowak> ArtVandalae: some will say haskell is a good place to start. i think there are better places, namely scheme.
01:09:43 <Jedai> ArtVandalae: Haskell is pretty interesting to learn functionnal programming since you can't use any other style in Haskell (whereas Scheme, List or OCaml can be used pretty much like imperative languages if you don't make an effort to forget the imperative paradigm).
01:10:03 <Jedai> It's quite brutal though ! ;-)
01:10:13 <johnnowak> depending on your programming background, scheme and the "how to design programs" book may be a nice way to learn the FP basics.
01:10:14 <vixey> johnnowak: hey
01:10:22 <johnnowak> lo vixey.
01:10:52 <vixey> you know how map might be written
01:11:02 <vixey> map f [] = [] ; map f (x:xs) = f x : map f xs
01:11:22 <vixey> have you thought about, in a linear ML, how the (x:xs) cons cell might be reused?
01:11:47 <vixey> it seems like you could do it with peephole optimizing, I'm not sure if that's reasonable/effective in general though
01:12:37 <johnnowak> the point of linearity in my mind is that you can reason about the space usage of your program. depending on optimizations for reuse doesn't seem ideal. to reuse it, i think you'd need to name the cell.
01:13:08 <johnnowak> map f [] = [] ; map f a=(x:xs) = (a (f x) (map f xs))
01:13:18 <johnnowak> albeit with a syntax that isn't god-awful
01:13:35 <vixey> interesting idea
01:14:54 <johnnowak> i think linear languages are better suited to arrays though.
01:17:25 <johnnowak> i also think you need a nice set of primitives. doing everything in terms of pattern matching probably won't be much fun (if it is fun to begin with)
01:48:04 <vixey> Text.PrettyPrint really can't do unicode?
01:48:23 <vixey> *PrettyPrint System.IO.UTF8> "≥"
01:48:23 <vixey> "\8805"
01:48:23 <vixey> *PrettyPrint System.IO.UTF8> text "≥"
01:48:23 <vixey> e
01:48:27 <vixey> is that supposed to happen?
01:48:42 <Baughn> vixey: Yes, if you pass it through show it'll get escaped
01:48:46 <Baughn> Try putStrLn instead
01:49:02 * Baughn blinks
01:49:18 <vixey> oh great thanks
01:49:20 <vixey> so it's just a bug in ghci
01:49:21 <Baughn> Wait a minute. What's the type of text there?
01:49:46 <vixey> String -> Doc, System.IO.UTF8.putStrLn . show $ text "≥" did the right thing
01:49:57 <vixey> it's just rubbish that show doesn't ....
01:50:16 <Baughn> show doesn't because read might have problems, I imagine
01:50:29 <vixey> well Read is broken -too- then
01:50:31 <johnnowak> Prelude> putStrLn "λ"
01:50:31 <johnnowak> ?
01:52:53 <Baughn> vixey: Why, yes. YEs it is.
01:53:06 <vixey> Prelude> :m System.IO.UTF8
01:53:06 <vixey> Prelude System.IO.UTF8> System.IO.UTF8.putStrLn "λ"
01:53:06 <vixey> Loading package bytestring-0.9.1.0 ... linking ... done.
01:53:06 <vixey> Loading package utf8-string-0.3.1 ... linking ... done.
01:53:06 <vixey> λ
01:53:11 <Baughn> putStr doesn't work properly for me either; I have to pull in the utf8-string version
01:53:28 <vixey> ghc does support unicode perfectly well, it just doesn't want anyone to know
01:53:57 <Baughn> WHat's your evidence for that?
01:54:15 <vixey> what johnnowak just pasted and the issue with pretty print
01:54:37 <Baughn> No, that's evidence for it /not/ supporting unicode. ;)
02:03:52 <Cale> The UTF8 IO stuff should be default.
02:04:27 <taruti> that would break lots of code
02:04:32 <vixey> good
02:04:46 <Baughn> What sort of code would be broken by /that/?
02:05:53 <roconnor_> broken code would be broken.
02:06:10 <taruti> Baughn: lots of code trying to do binary io.
02:06:39 <Baughn> taruti: Without using the binary i/o functions that /do/ work properly and have been in for forever.
02:06:49 <Baughn> I have no sympathy.
02:07:08 <vixey> Text.PrettyPrint.HughesPJ is nice
02:07:14 <taruti> yes, they should call hSetBinaryMode probably
02:07:46 <Baughn> They should use hGetBuf
02:08:00 <taruti> hGetBuf means dirty pointer things
02:08:12 <taruti> Data.ByteString.Char8 is nicer
02:08:14 <Baughn> I never said the interface was nice, but it /does/ work
02:08:35 <Baughn> ..or just Data.ByteString. D.BS.Char8 never really made sense to me.
02:12:29 <hackage> Uploaded to hackage: pugs-compat 0.0.5
02:12:29 <hackage> Uploaded to hackage: regex-pcre-builtin 0.94.2.0.7.7
02:39:29 <leoncamel> <- is a special operator in Haskell ?
02:40:16 <vixey> no
02:40:42 <roconnor> yes ?
02:40:58 <vixey> actually I don't know, I have no idea what a special operator is
02:41:07 <vixey> <- isn't an operator though
02:41:10 <roconnor> <- is a special token in haskell
02:41:45 <roconnor> whatever it is, it is special
02:41:50 <roconnor> ... just like everyone else
02:41:57 <leoncamel> OK. that is why I can' override this operator.
02:42:26 <vixey> > let (x <-- y) = y in 3 <-- 7
02:42:27 <lambdabot>  Parse error in pattern at "in" (column 19)
02:43:10 <vixey> > let x <-- y = y in 3 <-- 7
02:43:21 <lambdabot>  7
02:43:57 <leoncamel> vixey: what is (<--) ?
02:47:17 <Baughn> leoncamel: Yep. It's syntax, not an operator
02:47:26 <Baughn> @undo do foo <- bar; return bar
02:47:27 <lambdabot> bar >>= \ foo -> return bar
02:48:06 <leoncamel> Baughn: Oh. thanks, that is my question.. I got it.
02:49:58 <_zenon_> leoncamel, I would recommend "All about monads".
02:50:25 <_zenon_> leoncamel, http://www.haskell.org/all_about_monads/html/index.html , all the equations are there :)
02:50:26 <lambdabot> Title: All About Monads
02:50:54 <Baughn> leoncamel: You /can/ "overrride" it, in a sense, by making your own monad
02:51:05 <Baughn> It'll still have the same general sort of meaning, though
02:52:19 <leoncamel> Baughn: so, for example ? how can I do it ?
02:58:12 <Baughn> leoncamel: ..you probably can't. Read a monad tutorial or three first.
02:58:35 <Baughn> You first need to understand what a monad /is/
02:59:11 <leoncamel> Baughn: Ok. thanks ..
02:59:26 <_zenon_> leoncamel, As I said. All about monads is really great
02:59:36 <_zenon_>  http://www.haskell.org/all_about_monads/html/index.html
02:59:37 <lambdabot> Title: All About Monads
03:02:14 <|Steve|> Is the convention in Haskell to put the comma on the next line for lists written on multiple lines?
03:04:32 <_zenon_> I don't know, I usually put in on the same line , at the end, before the last
03:04:54 <|Steve|> yaht likes to put it on the next line.
03:05:01 <vixey> module Foo where
03:05:07 <|Steve|> > [1,2,3,]
03:05:07 <lambdabot>  Parse error at "]" (column 8)
03:05:08 <vixey>   ( bar
03:05:10 <vixey>   , baz
03:05:13 <vixey> is common
03:05:16 <_zenon_> :) I think it's okay to do as you wish :)
03:05:23 <|Steve|> Lame, you can't have trailing commas.
03:05:38 <vixey> > 1: 2: 3: []
03:05:41 <lambdabot>  [1,2,3]
03:05:52 <|Steve|> vixey: That's very strange looking to me. I've never seen anything written that way (apart from Haskell).
03:06:12 <vixey> it matches up with,
03:06:16 <vixey> data Foo = Bar
03:06:21 <vixey>           
03:06:23 <vixey>           | Baz
03:06:28 <vixey>          | etc..
03:07:06 <|Steve|> Of course data constructor syntax doesn't even match guard syntax because of the =.
03:08:10 <|Steve|> What are :+: and :*:?
03:08:24 <vixey> data or type constructors
03:08:36 <vixey> (like anything that starts with a :)
03:09:14 <|Steve|> Oh, I see. Interesting.
03:16:03 <|Steve|> Any idea if Hal Daumé III is planning to finish YAHT?
03:16:26 <_zenon_> No idea.
03:18:31 <|Steve|> The first 8 chapters are pretty good if in a strange order (e.g., deferring foldr to chapter 7). 9 is a significant departure in terms of readability and complexity. 10 is nonexistent.
03:24:07 <_zenon_> |Steve|, Yeah, mostly therefore I liked the combo "A gentle introduction to haskell" + "All about monads" better.
03:26:38 <|Steve|> I seem to recall a gentle introduction being anything but.
03:27:43 <Baughn> |Steve|: Not to worry. Read it again, and you'll be frustrated by its slowness.
03:29:24 <|Steve|> I'm probably conflating it with something else. I haven't read it for years.
03:29:50 <Baughn> No, I don't think so
03:29:59 <Baughn> It's just that now you /understand/ what it's saying. :P
03:31:48 <|Steve|> I was initially _really_ put off by Haskell when I realized that all of the claims about Haskell's IO were lies.
03:32:04 <Baughn> What lies?
03:32:11 <dolio> That it's hard?
03:32:47 <|Steve|> It's always described as being wrapped up so that the rest of the code doesn't have to worry about it, but it's really the opposite.
03:33:19 <osfameron> interesting
03:33:21 <Baughn> The rest of the code can at least worry /less/ about it than in other languages
03:33:26 <|Steve|> You don't have little packages of IO, you have little packages of code that don't use IO all surrounded by the IO.
03:33:29 <Baughn> At least with sufficient use of unsafeInterleaveIO
03:34:01 <maltem> Steve, well that will depend much on the program I guess
03:34:14 <|Steve|> maltem: No, not really. Look at the type of main.
03:34:16 <Baughn> |Steve|: Your perspective on that will depend on how much you have of each kind of code
03:34:38 <maltem> Steve, main has an IO type because otherwise your program wouldn't do anything
03:34:44 <|Steve|> Indeed.
03:34:57 <maltem> how would you remedy this?
03:35:18 <Baughn> What were you /expecting/?
03:36:03 <maltem> Or do you mean that main "surrounds" even all pure code?
03:36:11 <|Steve|> I do, yes.
03:36:19 <|Steve|> It's difficult to articulate how I'd remedy it.
03:36:30 <vixey> you do not need to remedy it, this is the solution
03:37:02 <|Steve|> Baughn: I'm not really sure what I was expecting, to be honest. It was a while ago when I first learned (some) Haskell.
03:37:13 <|Steve|> vixey: The description needs to be fixed.
03:37:36 <vixey> can anybody edit it?
03:37:49 <EvilTerran> |Steve|, the description seems correct to me
03:37:55 <|Steve|> "It"?
03:38:09 <vixey> it = the description
03:38:13 <maltem> what description, btw?
03:38:31 <EvilTerran> ignoring "main" for a minute, you can write all the code that does the actual work without using the IO monad
03:38:36 <EvilTerran> in many cases
03:38:48 <|Steve|> It's just the general impression I got when I was first reading about IO in Haskell and talking with people in here.
03:38:49 <EvilTerran> thus, that code doesn't have to worry about IO
03:39:04 <mgdtgd> Hi, I got I problem compiling a program. It works fine in ghci, so I think I miss some magic switch. It uses StringTemplate, HDBC and CGI. ld says it can't find -lgmp.
03:39:11 <|Steve|> EvilTerran: True. But it's not that the IO is wrapped up, it's that the pure stuff is wrapped up.
03:39:15 <EvilTerran> then you write a thin layer (called "main") that glues the pure code and the IO monad together
03:39:27 <Baughn> mgdtgd: ghci is probably statically linked against gmp. Did you download a binary?
03:39:33 <Baughn> mgdtgd: ..anyhow, you need to install libgmp
03:39:38 <EvilTerran> i don't remember anything ever saying IO was "wrapped up"
03:39:50 <EvilTerran> the point is it's restricted
03:40:09 <Baughn> Haskell hackers wrap IO up using unsafePerformIO. ^_^
03:40:24 <EvilTerran> haskell programmers, OTOH, don't
03:40:25 <EvilTerran> :P
03:40:25 <PeakerWork> only the evil ones
03:40:38 <|Steve|> I've never used unsafePerformIO.
03:40:46 <mgdtgd> Baughn: aptitude says libgmp3c2 is installed
03:40:48 <vixey> there aren't many uses for it
03:40:55 <Baughn> mgdtgd: "32c2"?
03:40:57 <Botje> mgdtgd: do you have -dev too?
03:41:02 <maltem> Viewn from the language, everything in Haskell code is pure, regardless of e. g. man having an IO type
03:41:04 <PeakerWork> treating file contents as an immutable global is one
03:41:07 <Botje> libgmp3-dev - Multiprecision arithmetic library developers tools
03:41:10 <maltem> s/man/main
03:41:17 <Baughn> mgdtgd: What os/distribution are you on?
03:41:22 <vixey> there's no reason you'd ever want to do that
03:41:33 <mgdtgd> Baughn: dev is installing right now. Debian
03:41:48 <PeakerWork> vixey: reading a configuration file and making it available globally is supposedly easier that way than passing it around, or putting everything in the reader monad
03:42:07 <Baughn> PeakerWork: *Easier*, sure
03:42:18 <mgdtgd> Baughn: that worked. Thanks!
03:42:31 <PeakerWork> I don't have enough Haskell mojo to be making that call though :)
03:42:48 <Botje> @vixen cookie?
03:42:48 <lambdabot> let me answer that later, okay?
03:42:58 <Baughn> PeakerWork: Generally you'd curry functions that care about the config /with/ the config, and then pass the functions in. Or some such.
03:42:59 <|Steve|> EvilTerran: I'm not sure if that was something I read in a tutorial or something someone said here when I asked about it.
03:43:27 <Baughn> PeakerWork: Anyhow, treating config files as global is a bad idea - for one thing, you might want to handle SIGHUP (in its reread-config-file sense) later
03:43:42 <EvilTerran> |Steve|, that's hardly "all of the claims about Haskell's IO"
03:43:59 <|Steve|> Fair enough, but it was the impression I got.
03:44:03 <Baughn> |Steve|: Oh, and unsafePerformIO is quite handy.. if you're writing FFI code, and calling C functions that are in fact pure
03:44:24 <Baughn> There's a reason it's in Foreign. ;)
03:44:47 <dolio> It's the reason it exists. :)
03:45:14 <Baughn> That, and to implement things like STArray
03:45:55 <Baughn> It's really nothing to be afraid of, if you treat it right. Much like lions are quite safe if you feed them first.. and stay away from their kids.
03:46:05 <dolio> I don't think STArray uses unsafePerformIO.
03:46:47 <dolio> Although I'm not quite sure about that.
03:46:50 <Baughn> Maybe. Maybe not. If it doesn't, that's because someone took the time to write a more limited primitive that does the same job.
03:46:52 <dolio> STUArray doesn't, though.
03:48:11 <dolio> The GHC primitive byte arrays are written in terms of a state parameter, so they're essentially primitively in the ST monad (or, its building blocks).
03:48:29 <dolio> And then IO is specialized to the RealWorld state.
03:49:32 <|Steve|> "An experienced functional programmer should be able to minimize the imperative component of the program, only using the I/O monad for a minimal amount of top-level sequencing. The monad cleanly separates the functional and imperative program components." And if you want more than just "top-level sequencing"?
03:50:02 <Baughn> |Steve|: Never happens
03:50:22 <Baughn> One can write entire GUIs with "top-level sequencing" - witness FRP
03:50:22 <|Steve|> You never want IO deeper in your programs than in main?
03:50:52 <|Steve|> I don't know what frp is and google gives many results.
03:50:54 <Baughn> Well, of course I don't do all my IO with one function. That'd be silly
03:50:59 <Baughn> Functional reactive programming
03:51:10 <mgdtgd> It's the whole point of a declarative language not to need explicit sequencing
03:51:47 <mgdtgd> separating IO and pure functions greatly reduces the troubles one can have, because there are no sideeffects
03:51:56 <dolio> xmonad is a fairly interaction heavy program that's written with a skin of IO around a largely pure core.
03:52:03 <dolio> At least, from the descriptions I've heard.
03:52:21 <|Steve|> mgdtgd: I don't disagree with that. That wasn't my point at all.
03:53:01 <thoughtpolice> |Steve|: look into the 'reactive' package on hackage
03:54:07 <|Steve|> thoughtpolice: Looking.
04:07:05 <|Steve|> thoughtpolice: I'm not sure I follow here. data Future a = Future IO a | Never. Seems like it uses IO to me.
04:07:31 <vixey> shouldn't be (IO a) ?
04:07:44 <vixey> I think Future IO a should be a kind error
04:08:02 <|Steve|> http://darcs.haskell.org/packages/reactive/doc/html/Data-Future.html Look for yourself.
04:08:03 <lambdabot> Title: Data.Future, http://tinyurl.com/69crws
04:08:24 <vixey> right
04:08:32 <vixey> Bug in whatever creates the documentation
04:08:37 <|Steve|> Okay.
04:08:59 <vixey> who wrote haddock?
04:09:17 <vixey> I guess Simon Marlow isn't on #haskell
04:09:25 <|Steve|> Presumably a kind error because Future should have kind * -> * and not (* -> *) -> *, right?
04:09:44 <vixey> data Future a = Future IO a | Never -- is a kind error, since IO :: * -> *
04:09:52 <vixey> data Future a = Future (IO a) | Never -- is fine though
04:10:09 <|Steve|> So, yes.
04:10:17 * vixey sends a bug report
04:11:38 <|Steve|> Is it possible to have kind variables like: Foo :: k -> k so that something like Foo IO would have kind * -> *?
04:13:01 <vixey> data Foo m = Foo (m Integer)
04:13:05 <vixey> oops
04:13:08 <vixey> data Foo m a = Foo (m a)
04:13:15 <vixey> that's one sort of thing like that
04:14:16 <|Steve|> That would have kind (* -> *) -> * -> *, no?
04:14:24 <vixey> yes
04:14:27 <vixey> Foo IO :: * -> *
04:14:49 <|Steve|> But Foo Int wouldn't make sense, for example.
04:15:56 <vixey> it's exactly like type checking
04:16:06 <vixey> you have  data :: types,  types :: kinds
04:16:34 <|Steve|> And kinds :: sorts, I understand. I'm just asking if you can have kind variables analogous to type variables.
04:16:45 <vixey> sorts don't exist in haskell
04:17:18 <|Steve|> Probably for the best, I'm asking if kind variables exist in Haskell.
04:18:09 <dolio> No.
04:18:12 <|Steve|> Okay.
04:20:30 <Baughn> Kinds :: sorts, sorts :: thingies, thingies :: stuff
04:20:45 <Botje> stuff :: atoms
04:20:48 <Botje> obviusly.
04:21:22 <|Steve|> I'm unaware of anything that actually uses sorts. I asked my PL/type theory friend and he was unaware of anything.
04:21:54 <vixey> most type theories make the distinction between the Set and Prop sorts
04:22:11 <|Steve|> Of course, he may have just not wanted to discuss it since the POPL deadline was fewer than 12 hours away and he wanted me to finish reading his paper.
04:22:54 <dolio> Pure type systems just refer to all the type+ levels as sorts, I believe.
04:23:04 <dolio> So Type is a sort and Kind is a sort.
04:23:21 <dolio> And then some languages have infinite hierarchies of sorts.
04:25:10 <dolio> The languages I know of without such a hierarchy don't really let you talk about levels above kinds from within the language, though.
04:25:58 <|Steve|> Oh yikes, nearly 4:30. It's been nice talking to you guys, but I need to sleep if I plan to attend the seminar in a few hours.
04:26:02 <dolio> Since there's no sort above it, so being able to ask for its sort would cause an error.
04:26:06 <Botje> isn't this the same as object -> class -> metaclass -> metametaclass -> ... ?
04:27:10 <vixey> well other than OO being ad-hoc and type theories doing this for logical consistency..
04:27:20 <Botje> :p
04:27:21 <dolio> :)
04:27:35 <dolio> Some throw consistency to the wind, though.
04:27:36 <vixey> usually metaclass -> metaclass though, at last in any prototype OO languages
04:27:45 <dolio> And go with the evil Type : Type.
04:28:38 <vixey> (infact I meant metaclasses are classes)
04:30:49 <dolio> In many, classes are objects.
04:31:25 <dolio> Just not in... Java and C++?
04:32:05 <Botje> java has a Class object
04:32:09 <Botje> but you can't alter it much :)
04:32:24 <dolio> Yeah, that's not really the same thing.
04:32:41 <mgdtgd> The only use for class objects I know of is synchronisation
04:32:43 <dolio> That's like how Haskell has a TypeRep type.
04:33:41 <vixey> what about ocaml
04:33:56 <dolio> I don't know much about OCaml.
04:34:30 <dolio> I imagine its classes aren't objects, either.
04:34:38 <dolio> I'm not sure about, say Eiffel, either.
04:34:50 <dolio> It's mainly the smalltalk line where classes are objects, I suppose.
04:36:25 <dolio> Although perhaps in pure prototype IO systems objects are the only information you have about 'classes'.
04:36:39 <dolio> I've not used those much, though.
04:37:12 <dolio> OO, even.
05:06:04 <baaba> how does the GenParser type work in parsec? it seems to me like it's defined in terms of itself through Parser and would expand infinitely?
05:06:20 <mauke> huh?
05:06:24 <jethr0> good morning, haskell
05:06:41 <baaba> type Parser a = GenParser Char () a
05:06:42 <baaba> newtype GenParser tok st a = Parser (State tok st -> Consumed (Reply tok st a))
05:06:54 <mauke> baaba: the Parser on the right is not a type
05:07:07 <mauke> it's a data constructor
05:07:07 <baaba> oh
05:09:28 <jethr0> i must admit, that IS confusing *scratches his head*
05:10:18 <mauke> @src Maybe
05:10:18 <lambdabot> data Maybe a = Nothing | Just a
05:10:29 <mauke> 'Nothing' and 'Just' aren't types either
05:10:51 <baaba> where's the data Foo a = Parser a definition then?
05:11:29 <baaba> or data Parser a i guess
05:11:30 <mauke> er, that was it
05:11:35 <pozic> Is there documentation for the dimensional library?
05:11:47 <baaba> a type synonym is a data constructor?
05:11:54 <mauke> what? no
05:12:08 <baaba> oh right, it's the data constructor of genparser
05:12:43 <pozic> baaba: that's no data constructor.
05:12:46 <kriomant> how to convert Data.ByteString to String?
05:13:02 <baaba> where's the data then?
05:13:04 <pozic> baaba: read a Haskell book first, then ask further questions.
05:13:13 <baaba> okay
05:13:21 <Philippa> pozic: it is indeed a data constructor, and telling people to read a book isn't helpful
05:13:22 <mauke> what data?
05:13:39 <Philippa> (the data constructor is trivial and strict, sure...)
05:13:50 <pozic> Philippa: data a b c = ZFoobar a b c
05:13:56 <pozic> Philippa: data A a b c = ZFoobar a b c
05:14:04 <pozic> Philippa: what's the data constructor here?
05:14:34 <Philippa> pozic: I am no newbie. The code above has both type and data constructors named Parser.
05:14:47 <pozic> Philippa: the code above was only a type constructor.
05:14:51 <pozic> Philippa: since I just joined.
05:15:12 <baaba> pozic, i'm confused about the definition of Parser and GenParser in parsec
05:15:12 <Philippa> pozic: so drop it
05:15:25 <baaba> since there is no data declaration; only a type and newtype
05:15:28 <jethr0> ;)
05:15:33 <mauke> baaba: newtype is data
05:16:25 <baaba> ah, i had the impression it was just like 'type' except it creates a separate (but equivalent) type in the type system
05:16:25 <Philippa> pozic: when you walk in with minimal context, you are in /no/ position to tell people to go away and read a book. It's not a helpful statement at the best of times - you should at least tell people what to read up on
05:16:40 <mauke> baaba: how is that different from data?
05:16:44 <Philippa> baaba: right, but in doing that it needs to create a data constructor to separate out the two
05:16:54 <Philippa> mauke: it doesn't allow multiple data constructors, for one
05:16:57 <baaba> right, of course
05:16:59 <mauke> yeah, ok
05:17:04 <baaba> okay that makes sense then thanks
05:17:06 <mauke> but in this case there's only one constructor
05:18:03 <baaba> admittedly the advice to read a book isn't off and that's what i'm going to do next; i've been following the scheme-in-48-hours tutorial thing
05:18:17 <Philippa> baaba: one way of looking at it is that the single constructor and pattern-matching on it provide an isomorphism between the newtype and the type it wraps
05:19:17 <mauke> newtype New = OldToNew Old; newToOld (New x) = x
05:19:38 <Philippa> or better yet, abuse records :-)
05:19:53 <Philippa> newtype New = New {toOld :: Old}
05:19:54 <mauke> newtype New = OldToNew {newToOld :: Old}
05:20:10 <mauke> expert record abuser
05:22:59 <kriomant> how to convert Data.ByteString to String?
05:23:22 <taruti> unpack
05:23:30 <byorgey> @hoogle ByteString -> String
05:23:32 <lambdabot> No matches, try a more general search
05:23:37 <taruti> @type Data.ByteString.Char8.unpack
05:23:44 <lambdabot> BSC.ByteString -> [Char]
05:24:23 <kriomant> I have Data.ByteString, not Data.ByteString.Char
05:24:35 <taruti> they are the same datatype
05:24:59 <taruti> Char8 = use 8bit characters for the byte<->Char conversion
05:25:00 <kriomant> @type Data.ByteString.unpack
05:25:02 <lambdabot> BSC.ByteString -> [Word8]
05:25:48 <kriomant> ok, thx, I'll try...
05:30:56 <pozic> Can I use cabal to build me the documentation for dimensional?
05:35:09 <plutonas> why can't i map print [String] ?
05:35:49 <pozic> > :t map print ["hi"]
05:35:51 <lambdabot>   parse error on input `:'
05:35:57 <Baughn> plutonas: You can. It's just that you get a list of IO actions.
05:36:00 <vixey> you can
05:36:00 <pozic>  >:t map print ["hi"]
05:36:10 <vixey> pozic, please..
05:36:10 <Baughn> :t map print "foo"
05:36:11 <lambdabot> [IO ()]
05:36:20 <plutonas> hm
05:36:26 <pozic> vixey: please what?
05:36:26 <maltem> pozic: In theory that should be no problem, but there can be parsing problems due to a recent (?) backend change in Haddock
05:36:37 <Baughn> :t sequence $ map print "foo"
05:36:38 <lambdabot> IO [()]
05:36:46 <Baughn> :t mapM (map print "foo")
05:36:47 <lambdabot>     Couldn't match expected type `a -> a1'
05:36:47 <lambdabot>            against inferred type `[Char]'
05:36:47 <lambdabot>     In the second argument of `map', namely `"foo"'
05:36:51 <pozic> vixey: yes?
05:36:52 <plutonas> actually what i get is  No instance for (Show (IO ()))
05:36:52 <plutonas>       arising from a use of `print' at <interactive>:1:0-27
05:36:55 <Baughn> :t mapM print "foo" -- ^^;
05:36:56 <lambdabot> IO [()]
05:37:08 <plutonas> what i want to do is print each string, and the next one below etc
05:37:09 <Baughn> plutonas: RIght. It's trying to print a list of IO actions.
05:37:26 <pozic> plutonas: you need to execute those actions, not just build a list of them.
05:37:27 <Baughn> plutonas: Instead of running the IO actions that would print your list
05:37:39 <pozic> plutonas: any beginners book would also explain that.
05:37:43 <Baughn> plutonas: Incidentally, sequence will run a list of IO actions
05:37:44 <maltem> :t sequence
05:37:45 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
05:37:48 <EvilTerran> :t mapM_ print (words "print each word on its own line")
05:37:52 <lambdabot> IO ()
05:38:38 <plutonas> sequence?
05:38:45 <Baughn> @src sequence
05:38:45 <lambdabot> sequence []     = return []
05:38:45 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
05:38:45 <lambdabot> --OR
05:38:45 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
05:39:10 <plutonas> i see
05:39:21 <maltem> plutonas: sequence sequences actions, for instance: sequence (map print ["foo","bar"])
05:39:33 <Baughn> @src mapM
05:39:33 <lambdabot> mapM f as = sequence (map f as)
05:39:43 <Baughn> mapM, obviously, just combines sequence and map
05:40:21 <plutonas> if i could get rid of [(),()] at the end of the printing it would be perfect
05:40:22 <plutonas> :D
05:40:26 <maltem> plutonas: since print doesn't return anything useful, it's even more convenient to use sequence_ (or mapM_)
05:40:34 <vixey> that's what the _ is for
05:41:06 <plutonas> thanks a lot!!!
05:42:09 <pozic> Isn't there anyone that can just say how to build the documentation for package X with one command?
05:42:43 <thoughtpolice> cabal install can't build docs yet, but if you're in the source tree after configuring you can do 'runghc Setup.hs haddock'
05:43:08 <maltem> (or even 'cabal haddock', yet only from the source tree)
05:43:08 <pozic> Thank you
05:43:18 <Baughn> That's "runghc Setup.*hs haddock" - for some reason people use literate style for setup.hs, even without any actual comments
05:43:58 <Botje> mkcabal generates a lhs by default
05:44:30 <pozic> haddock: parse error in doc string: [TokPara]
05:44:52 <pozic> That's what cabal haddock returns.
05:44:54 <maltem> Baughn: I suggest runghc Setup
05:45:11 <pozic> The normal command generates some warnings, but no output.
05:46:14 <maltem> pozic: looks like the problem I mentioned
05:46:28 <povman> @hoogle (a -> (b, Maybe a)) -> a -> [b]
05:46:38 <povman> . . .
05:46:43 <lambdabot> thread killed
05:46:54 <vixey> :t unfoldr
05:47:04 <povman> vixey: not quite
05:47:10 <lambdabot> thread killed
05:47:17 <vixey> @undef
05:47:18 <vixey> :t unfoldr
05:47:30 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
05:47:30 <lambdabot> Undefined.
05:48:04 <pozic> maltem: I also tried it without cabal.
05:48:37 <povman> vixey: i need the function to give a value on the last iteration
05:48:39 <pozic> maltem: you meant the back-end change.
05:50:09 <maltem> pozic: right, and that one does not relate to cabal
05:50:24 <maltem> pozic: a backend change in Haddock, that is
05:50:42 <maltem> pozic: even though that's more of a speculation from my part
05:51:20 <povman> > unfoldr' f x = let (a, ma) = f x in maybe [a] ((a:) . unfoldr' f) ma
05:51:20 <lambdabot>  Parse error at "=" (column 14)
05:51:25 <thoughtpolice> Baughn: afaik it's so people can have shebang's at the top of the .lhs since # isn't a haskell comment
05:52:13 <thoughtpolice> i normally don't use literate style for my setup's, though.
05:52:37 <pozic> Can I reload ghci so that it picks up more libraries?
05:52:37 <Baughn> thoughtpolice: I find it easier just to type "cabal install" in the directory anyhow
05:52:51 <Baughn> pozic: You can certainly restart it
05:53:09 <pozic> Baughn: but that will loose all context.
05:53:11 <Baughn> You're not supposed to keep lots of state in the interpreter. That's what .hs files and :reload are for. ;)
05:53:14 <maltem> thoughtpolice: ghc does ignore a shebang line in *.hs files
05:53:23 <thoughtpolice> maltem: ah, good to know.
05:53:44 <thoughtpolice> Baughn: i find it easier to just type 'cabal install' period.
05:54:18 <povman> @pl \f x -> (\(a, ma) -> maybe [a] ((a:) . unfoldr' f) ma) (f x)
05:54:18 <lambdabot> (.) =<< (`ap` snd) . (. fst) . liftM2 maybe return . flip ((.) . (:)) . unfoldr'
05:54:26 <_zenon_> povman, .... readable
05:54:28 <povman> lovely
05:55:24 <povman> _zenon_: which?
05:55:56 <_zenon_> povman, hehe, the second . not . At least not for me :)
05:55:57 <jethr0> does anyone know how the different definitions of trees relate? are they equivalent and transformable? (data Tree a = Leaf a | Branch (Tree a) (Tree a), data Tree a = Nothing | Branch (Tree a) a (Tree a))
05:56:11 <povman> i was hoping it would come out shorter than the original def
05:56:22 <_zenon_> povman, yeah, worth a try :)
05:56:37 <_zenon_> is there an inverse to @pl ?
05:56:48 <povman> @unpl (.) =<< (`ap` snd) . (. fst) . liftM2 maybe return . flip ((.) . (:)) . unfoldr'
05:56:48 <lambdabot> (\ r -> ((\ d -> d >>= \ al -> snd >>= \ ak -> return (al ak)) >>= \ a b c -> a (b c)) (\ aj -> (return >>= \ g -> (\ m p -> ((:)) m (unfoldr' r p)) >>= \ h -> return (maybe g maybe)) (fst aj)))
05:56:51 <povman> :)
05:56:55 <vixey> jethr0: They aren't really isomorphic
05:57:09 <_zenon_> povman, :) hahahah.
05:57:16 <vixey> jethr0: let's name them differently so we can be a bit clearer, data LeafyTree a = Leaf a | LeafyBranch (Tree a) (Tree a)
05:57:17 <povman> jethr0: with the second version you can have an empty tree
05:57:22 <vixey> jethr0: data MaybeTree a = Nothing | JustyBranch (Tree a) a (Tree a))
05:57:36 <vixey> jethr0: There is no LeafyTree corresponding to Nothing :: MaybeTree
05:57:47 <jethr0> hmm, what I was trying to do was make an instance of Monad for tree
05:57:56 <jethr0> and joining the MaybeTree is pretty evil
05:58:29 <jethr0> whereas for the leafytree, it's more difficult to write a foldr
05:58:53 <jethr0> at least for my mangled brain ;)
06:01:33 <EvilTerran> well, let's see... data Leafy a = Branch (Leafy a) (Leafy a) | Leaf a, right?
06:01:58 <EvilTerran> say you're folding a (Leafy a) and want to return a (b)
06:02:21 <vixey> jethr0: I can write a join for the MaybeTree
06:02:33 <EvilTerran> you've got Branch :: Leafy a -> Leafy a -> Leafy a and Leaf :: a -> Leafy a
06:02:50 <jethr0> vixey: i didn't say it was impossible, just brain-damaging ;)
06:02:51 <EvilTerran> replace "Leafy a" with "b" everywhere to get the types of the parameters to the fold function
06:03:03 <vixey> join Nothing = Nothing
06:03:06 <vixey> join (JustyBranch l e r) = join l ++ e ++ join r
06:03:06 <vixey>  where Nothing ++ ys = ys
06:03:06 <vixey>        JustyBranch l x r ++ ys = JustyBranch l x (r ++ ys)
06:03:10 <EvilTerran> so foldLeafy :: (b -> b -> b) -> (a -> b) -> Leafy a -> b
06:03:25 <EvilTerran> and then the definitions fall out easily
06:03:43 <vixey> no idea if this a correct join given whatever fmap and return you have
06:03:57 <EvilTerran> foldLeafy f g (Branch l r) = f (foldLeafy l) (foldLeafy r); foldLeafy f g (Leaf x) = g x
06:04:30 <jethr0> ah, you're using two functions. that's the step i didn't make.
06:04:47 <EvilTerran> when making a catamorphism, you need one parameter function for each constructor
06:05:17 <jethr0> vixey: hmm, might work. as i said, i wasn't in prime coding condition when i tried, but somehow I was always left with a branch value.
06:05:25 <jethr0> vixey: at first glance your solution seems to work
06:05:39 <EvilTerran> the general form is "one parameter function for each constructor; that function has the same type as the constructor, except with (Foo a) replaced with b"
06:05:41 <vixey> is it a monad though?
06:05:47 <jethr0> EvilTerran: thx, i didn't know that, i'll have to read up on my morphisms again, then
06:05:52 <vixey> can you prove the monad laws for it
06:06:00 <povman> can someone show me a paramorphism for lists?
06:06:00 <EvilTerran> i just remember that, then it's dead easy :)
06:06:21 <jethr0> vixey: from my limited understanding, with "correct" join and fmap, the monad laws should hold
06:06:42 <jethr0> fmap is easy, and join you seem to have just written
06:06:42 <vixey> yeah they should, I don't know if they do or not
06:07:02 <vixey> just having instance Monad with the right types isn't quite enough
06:07:14 <jethr0> vixey: i am aware of that ;)
06:07:27 <Baughn> EvilTerran: Catamorphism? Uh, you mean a fold?
06:07:33 * EvilTerran looks up paramorphisms, ends up on the Comonad.Reader, and his brain implodes
06:07:41 <vixey> Baughn: same thing
06:07:43 <jethr0> EvilTerran: that's how it often goes
06:07:49 <Baughn> It's "Data.Foldable", not "Data.Catamorphisms", though
06:07:51 <povman> EvilTerran: i'm kinda looking for a concrete example :p
06:08:21 <EvilTerran> povman, i'm afraid i can't help you just now, i need to find a tyre pump and re-inflate my brain :P
06:08:41 <povman> EvilTerran: well - the same thing happened to me from the same site
06:08:46 <povman> :D
06:08:53 <int-e> jethr0: you still need `return'
06:09:05 <EvilTerran> Baughn, or it's Control.Morphism.Cata in category-extras :P
06:09:14 <EvilTerran> altho that's using FixF
06:09:37 <EvilTerran> so the data decl would be "data Leafy leafy a = Leaf a | Branch (leafy a) (leafy a)
06:10:00 <jethr0> int-e: i am aware of that too, but return is often easy. return x = LeafyBranch Nil x Nil; return x = MaybeLeaf x
06:10:04 <povman> EvilTerran: http://hpaste.org/1991
06:10:23 <EvilTerran> dear lord
06:11:28 <EvilTerran> ?hoogle Control.Morphism.Cata.cata
06:11:29 <lambdabot> No matches, try a more general search
06:11:36 <EvilTerran> cata :: Functor f => Algebra f a -> FixF f -> a
06:11:44 <jethr0> i really wish i could get myself to read and understand the "bananas, lenses, envelopes and barbed wire" paper and its cousins.
06:11:46 <EvilTerran> where Algebra f a = f a -> a
06:11:54 <jethr0> seems like so much brain-exploding fun
06:12:01 <vixey> print it out
06:12:26 <EvilTerran> i guess that kinda makes sense, altho it does mean the end result needs the same type as the functor parameter
06:12:49 <povman> I still can't read my cool 'non-recursive' functions easier than the recursive versions
06:13:07 <povman> i guess the schemes aren't quite locked-in yet
06:13:29 <vixey> I'm not sure they're supposed to be easier to read ...
06:13:31 <vixey> a
06:13:49 <vixey> the use is more program derivation isn't it?
06:14:22 <povman> what?
06:14:26 <EvilTerran> it's theoretical elegance, sometimes at the expense of practical elegance
06:14:51 <jethr0> ok, i am lagging behind on reading the comonad.reader article, but my head just exploded as well ^_^
06:15:10 <povman> jethr0: that's worse than EvilTerran, his brain only imploded
06:15:33 <ski> data Leafy a leafy_a = Leaf a | Branch leafy_a leafy_a  -- you can use `FixF' on this one
06:15:41 <jethr0> povman: i think it comes with experience. i am just on the verge of writing foldr's, etc directly without the intermediate direct recursion functions.
06:16:21 <jethr0> at least you can screw up much less badly by using the ready-made recursion schemes, which leads to less error-checking and paper-simulation for recursive functions
06:16:51 <vixey> hi ski
06:16:55 <ski> EvilTerran : with your `Leafy' you'd need a `FixF2 :: ((* -> *) -> (* -> *)) -> (* -> *)'
06:16:55 <jethr0> ski, where does this FixF come from? is that a type fixpoint???
06:17:01 <vixey> I put up my language on google code
06:17:04 <jethr0> aaahhh
06:17:04 <vixey> it's not very good
06:17:10 <ski> jethr0 : yes, least fix-point, in this case
06:17:14 <ski> vixey : hiya
06:17:23 <EvilTerran> ski, ah, yes, i was a bit confused about the ordering and types of the parameters
06:17:24 <vixey> it is here http://code.google.com/p/rascal-haskell
06:17:26 <lambdabot> Title: rascal-haskell - Google Code
06:17:31 <jethr0> ski, i guess that only works for recursive types, right
06:17:45 <ski> jethr0 : "that" being ?
06:17:57 <povman> my toothbrush smells like vinegar
06:18:01 <jethr0> least fix-point finding
06:18:32 <ski> jethr0 : why ?
06:18:48 <ski> FixF (Const a)  ~=  a
06:18:55 <jethr0> ok
06:19:13 <jethr0> could you give a really simple example of using FixF?
06:19:42 <EvilTerran> FixF (Maybe `O` (,) a)  ~~  [a]
06:19:56 <ski> say you have a datatype for some syntactic class in a language .. for concreteness, say expressions
06:19:56 <povman> vixey: there appears to be very little syntax in your language
06:20:16 <jethr0> i guess before reading comonad.reader i should take a look at "category theory for computer scientists"
06:20:23 <vixey> yes it is a a very small fragment of haskell
06:20:26 <ski>   data Expr = Call Identifier [Expr] | Var Identifier | ...
06:20:46 <jethr0> uhu
06:21:02 <jethr0> EvilTerran: that was indeed very terse, but didn't immediately enlighten me *g*
06:21:03 <EvilTerran> FixF (Maybe `O` (,) a)  ~~  FixF (\f -> Maybe (a,f)), if that makes it clearer
06:21:07 <ski> now, you want to type-check these expressions, to get typed expressions (each subexpression will have a type annotation), possibly you will use this later in the compilation
06:21:16 <ski> so, you could define
06:21:18 <jethr0> ok
06:21:19 <EvilTerran> `O` is type composition
06:21:43 <ski>   data TypedExpr = TCall Type Identifier [TypedExpr] | TVar Type Identifier | ...
06:21:49 <jethr0> EvilTerran: and what does it do?
06:21:49 <EvilTerran> newtype (f `O` g) a = O { unO :: f (g a) }
06:22:04 <EvilTerran> it's like (.), only for types instead of values
06:22:15 <jethr0> ski, ok
06:22:25 <ski> however, it is tedious to repeat more or less the same data declaration once again .. and you can't reuse utility functions you've defined on the earlier type
06:22:31 <EvilTerran> (Maybe `O` (,) a) f  ~~  Maybe ((,) a f)  ~~  Maybe (a,f)
06:22:40 <ski> so one simple idea is to instead define
06:23:04 <ski>   data AnnotatedExpr a = Call a Identifier [TypedExpr] | Var a Identifier | ...
06:23:12 <EvilTerran> and the fixed-point of (\f -> Maybe (a,f)) is lists of a
06:23:16 <ski> so instead of `Expr' you use `AnnotatedExpr ()'
06:23:29 <ski> and instead of `TypedExpr' you use `AnnotatedExpr Type'
06:23:34 <vixey> ski, hehe that's exactly what I've done
06:23:36 <EvilTerran> because you can either have Nothing, or Just (_::a, f)
06:23:56 <ski> however, for some purposes, even this is not enough
06:24:00 <EvilTerran> which are like [] and (:)
06:24:10 <vixey> :k Mu (Maybe ((,) Integer))
06:24:16 <lambdabot>     `(,) Integer' is not applied to enough type arguments
06:24:16 <lambdabot>     Expected kind `*', but `(,) Integer' has kind `* -> *'
06:24:16 <lambdabot>     In the type `Maybe ((,) Integer)'
06:24:31 <vixey> hm
06:24:56 <ski> consider that you're going to make an interpreter for an imperative language, like Common Lisp, where you can mutate the tree datastructures you pass around
06:25:30 * ski ponders whether this is a good example
06:25:51 <EvilTerran> :k Mu (Maybe `O` (,) Integer)
06:25:52 <lambdabot> Not in scope: type constructor or class `O'
06:25:55 <EvilTerran> bah
06:26:18 <vixey> without `O` we are kind of stuck
06:26:19 <jethr0> EvilTerran: i didn't quite get it. seeing my slow learning speed for anything type-related or category theoretic, i'll just read it again and see if it means anything to me
06:26:24 <EvilTerran> :k Mu (Maybe :. (,) Integer)
06:26:26 <lambdabot> Not in scope: type constructor or class `:.'
06:26:29 <EvilTerran> grrrr
06:26:46 <ski> no, i don't think this example will afford the flexibility i want
06:26:54 <EvilTerran> jethr0, did you follow my explanation of the fix of (\f -> Maybe (a,f))?
06:27:00 <jethr0> ski: so the above was the motivation and now you're getting to the usage of FixF, right?
06:27:04 <EvilTerran> (ignoring that type-level lambdas aren't haskell for the time being)
06:27:08 <jethr0> EvilTerran: yes
06:27:23 <ski> jethr0 : yes .. i'm trying to think of some more relevant example
06:27:26 <vixey> EvilTerran: why not /\f -> Maybe (a,f)
06:27:35 <povman> hpaste bot is gone? http://hpaste.org/9047
06:27:45 <EvilTerran> the point is that category-extras expresses catamorphisms (which deal with recursive types) in terms of the fixed-point of a non-recursive type
06:28:03 <jethr0> category-extras?
06:28:11 <ski> (s/non/(usually) non/)
06:28:26 <EvilTerran> vixey, eh, no real reason. i figured mine would be easier on folks familiar with haskell lambdas
06:28:40 <EvilTerran> ?hackage category-extras
06:28:41 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/category-extras
06:29:21 <ski> jethr0 : ok, maybe this is a slightly better example
06:29:38 <EvilTerran> jethr0, it's a package with loads of category-theory-based stuff
06:29:45 <ski> you're making a kind of structural editor, editing a tree type of some kind
06:30:01 <jethr0> EvilTerran: i don't get the last step where you say "and the fixed-point of (\f -> Maybe (a,f)) is lists of a". I honestly don't see that step
06:30:06 <jethr0> k
06:30:12 <ski> however, you want to be able to represent partial trees, i.e. trees with holes in them, that haven't been defined yet
06:30:30 <jethr0> yes
06:30:55 <ski> but, you want to be able to check that a specific tree possibly now has no holes, converting it to a type that manifests this, passing it on to some kind of evaluation
06:31:01 <ski> so you have
06:31:34 <EvilTerran> jethr0, well, either a value in the fix of that type is Nothing, which is like []
06:31:43 <ski>   data Tree = Foo X Tree Tree Tree | Bar Tree Y Tree | ...
06:31:49 <EvilTerran> or it's Just (a, <the whole type>)
06:31:54 <EvilTerran> which is like a : [a]
06:32:24 <vixey> @type let x = In [x] in x
06:32:25 <lambdabot> Mu []
06:32:34 <jethr0> ah, now i see. you are fix-pointing over a type.
06:32:38 <ski> so, the point is now to make a type that also includes an extra `Hole' constructor, without having to duplicate most of the type and utility functions
06:32:38 <EvilTerran> exactly!
06:32:43 <EvilTerran> that's what FixF does
06:32:44 <vixey> :t fix (In . return)
06:32:46 <lambdabot> forall (f :: * -> *). (Monad f) => Mu f
06:33:10 <ski> so, what we do, is rewrite the type into its generating functor
06:33:29 <ski>   data TreeF tree = Foo x tree tree tree | Bar tree y tree | ...
06:33:48 <ski> so `FixF TreeF' is iso to `Tree'
06:33:56 <jethr0> EvilTerran: but how do you correlate the type fix-point with the functions handling it? and how do define a non-infinte fix-point type when you don't have "if" or similar to interrupt the recursion?
06:33:56 <ski> but now we can also define
06:34:21 <jethr0> hmm
06:34:24 <ski>   data HoleTreeF this = Hole | TreeF this
06:34:59 <EvilTerran> you interrupt the recursion with laziness
06:35:11 <EvilTerran> note that, instead of FixF, lambdabot has
06:35:19 <ski> so now `FixF HoleTreeF' is just like `FixF TreeF', except at every node, there can also be a `Hole' (also having an extra mediating `TreeF' constructor for non-trees)
06:35:22 <EvilTerran> newtype Mu f = In { out :: f (Mu f) }
06:35:35 <ski> jethr0 : i'm not sure if this was coherent ..
06:35:37 <EvilTerran> wait, ignore what i said about laziness
06:35:48 <EvilTerran> you use a newtype to stop the type being infinite
06:35:55 <jethr0> ski, i guess it was. it's just rather abstract (which i guess comes naturally with FixF).
06:36:01 <EvilTerran> at the expense of having to wrap/unwrap with In and out
06:36:31 <jethr0> ski: what would you say was the difference between "FixF TreeF" and "Tree"?
06:36:34 <ski> jethr0 : basically, you can use `FixF' for expressing variants of the same type in an economic way
06:36:58 <vixey> :t fix $ flip . const $ In
06:37:00 <lambdabot> forall a. a -> Mu ((->) a)
06:37:26 <jethr0> ski: so the "Hole" constructor is the possibility to stop the recusion on the tree. and FixF inserts this possibility in the data type?
06:37:26 <ski> jethr0 : structurally, `FixF TreeF' and `Tree' are the same .. but the former is structured in such a way so that you can reuse the `TreeF' part to form useful variants of the type
06:37:49 <jethr0> ski: cool, on a very high-level i kinda understand this
06:38:07 <jethr0> but low-level, application-wise i'm still far from it
06:38:28 <ski> jethr0 : well, `HoleTreeF' inserts the possibility .. `FixF' is the "instantiation" part that decides that enough is enough, no more features can be added here
06:39:29 <povman> it'd be nice if (,) had an infix constructor for pattern matching with the Arrow functions
06:39:33 <jethr0> could you do this with: "data MaybeF a = Just a; data Maybe = Nothing | FixF MaybeF", or does that make no sense at all?
06:39:59 <vixey> jethr0: That makes no sense
06:40:06 <jethr0> povman: isn't "(a,b)" kinda an infix constructor?
06:40:12 <jethr0> vixey: hehe
06:40:26 <ski> jethr0 : in way, this is similar to classes in many OO-languages .. each class describes a co-Tree type, that can be extended by adding more methods .. when you instantiate a class, you do two things : first you "close the recursion" like `FixF' so that you get a concrete class type (and not a subclass), secondly, you construct a value of this type
06:40:51 <andun> > let c = (,) in 1 `c` 2
06:40:55 <lambdabot>  (1,2)
06:41:07 <povman> jethr0: let (a, (b, (c, d))) = (w &&& x &&& y &&& z) i in ...
06:41:26 <vixey> > let (&) = (,) in (1 & 2 & 3 & 4 & 5 & 6)
06:41:29 <lambdabot>  (((((1,2),3),4),5),6)
06:41:33 <povman> ooooo
06:41:37 <jethr0> povman: i would have thought that is valid haskell
06:41:52 <povman> jethr0: it is, but you have to nest all those (,)'s
06:42:06 <ski> vixey : unfortunately, that doesn't work for the pattern, though
06:42:32 <jethr0> ah, i see your point. you don't want to care about those pesky two-tuples and instead treat the result as an n-tuple which it isn't for arrows
06:43:04 <jethr0> ski: thx again. that was very helpful. any idea where i could read up on that some more? is there anything on the wiki?
06:43:18 <povman> kinda ... something like let (a & b & c & d) = (w &&& x &&& y &&& z) i in ...
06:43:30 <ski> jethr0 : not sure .. i've collected this from many places, i think
06:43:49 <vixey> povman: probably do something with quasiquotes
06:44:06 * povman waves the quasiquote flag
06:44:16 <ski> haskell should have an associative tuple type, with `(#)' result kind
06:44:25 <jethr0> template haskell is evil ;)
06:44:43 <jethr0> i'm sure scrap your boilerplate could help as well
06:44:53 <jethr0> well, not sure, but hopeful
06:44:55 <vixey> I don't think so
06:45:32 <povman> jethr0: sif: let [AWESOME|a & b & c & d] = w &&& x &&& y &&& z) i in ...
06:46:56 <vixey> nobody had any comments in my code I guessa
06:49:53 * ski attempts figuring out how to browse google code
06:50:03 <jethr0> povman: the problem with those infix constructors would be that they would not match sth like (a, ((b,c), d)), which i guess could easily come out of the arrow library
06:50:06 <povman> ski: there's a link at the top of the code page
06:50:46 <vixey> oh right, http://rascal-haskell.googlecode.com/svn/trunk/
06:50:48 <lambdabot> Title: Revision 2: /trunk
06:51:17 <povman> jethr0: that wouldn't happen by accident, you'd have to apply parens on both sides
06:51:45 <ski> (and, there's a `Browse' under `Source' ..)
06:51:57 <jethr0> povman: just talking here, but depending on the order and nesting of arrow-operations, i thought any combination of nested tuples could be the outcome
06:52:34 <povman> jethr0: they're only associative one direction :)
06:52:37 <jethr0> that's kinda the point of arrows, that you can mix and match operations and parallelize/unite streams freely
06:52:55 <povman> yeh i'm just nitpicking
06:53:20 <povman> i kinda doubt i should even be pattern matching them
06:53:24 <jethr0> some kind of easier matching and handling tuples in general would be nice though
06:54:07 <__pao__> hi all
06:54:23 <__pao__> I've gone through the daume' tutorial (excellent)...
06:55:04 <__pao__> What are the main haskell non standard extensions that it would be useful to be aware of (gadt, phantom types, existential...)?
06:55:19 <thoughtpolice> phantom types aren't an extension
06:55:22 <thoughtpolice> they're more of an idiom
06:55:31 <PeakerWork> __pao__: fundeps, deriving Typeable
06:55:35 <thoughtpolice> oh
06:55:41 <thoughtpolice> and multi-param type classes
06:55:44 <povman> __pao__: i've used existentials a few times
06:55:50 <ski> newtype deriving
06:55:54 <jethr0> newtype monad derivation
06:56:08 <povman> __pao__: template haskell
06:56:14 <PeakerWork> __pao__: gadt/existentials you mentioned are indeed useful.  newtype deriving lots of interesting stuff as mentioned above
06:56:28 <__pao__> let me sum up... :-)
06:56:33 <thoughtpolice> newtype deriving is incredibly useful I've found for things like monad transformers
06:56:36 <PeakerWork> does newtype derive anything more than Typeable/Monad/Functor/etc?
06:56:57 <PeakerWork> thoughtpolice: does it just "forward" everything to the unpacked and re-pack results accordingly?
06:57:15 <thoughtpolice> PeakerWork: I use the approach cale described
06:59:02 <thoughtpolice> basically all it is, is just 'newtype NewMonad a = NewMonad { runNew :: ... } deriving (Monad,MonadIO,...)'
06:59:13 <pozic> How do I convert a dimensionless number (c.f. dimensional library) to a Haskell number?
06:59:51 <thoughtpolice> the main usage for it was when I was writing an IRC bot; plugins were specified with a typeclass and the execution function required functions to execute inside that monad so they couldn't do arbitrary things, and it made it easier to get bot info naturally
07:00:06 <thoughtpolice> PeakerWork: so if you want to put it that way sure I guess, maybe i'm just too stupid to see what you mean
07:00:38 <__pao__> PeakerWork: by deriving Typeable you mean http://www.haskell.org/haskellwiki/Extensible_datatypes? what do you mean by fundeps?
07:00:39 <lambdabot> Title: Extensible datatypes - HaskellWiki
07:00:51 <thoughtpolice> __pao__: fundeps == functional dependencies
07:00:54 <PeakerWork> thoughtpolice: I am wondering how it knows to make the instances for the newtype - I am guessing it just unpacks/packs whenever the type appears?
07:01:16 <povman> thoughtpolice: afaict if instance C A, then you can newtype B = B A deriving C
07:01:17 <thoughtpolice> PeakerWork: I've come to the conclusion cunning newtype deriving is just that - cunning.
07:02:04 <jethr0> thoughtpolice: do you mean that in the slightly negative connotation of "cunning"?
07:02:11 <thoughtpolice> __pao__: on the same note, although they don't fully work in ghc 6.8.x, associated types are quite interesting. and useful.
07:02:35 <povman> pozic: which library?
07:02:46 <pozic> povman: dimensional
07:02:55 <povman> pozic: you mean http://code.google.com/p/dimensional/?
07:02:55 <lambdabot> Title: dimensional - Google Code
07:03:00 <masak> @slap nonexistent
07:03:01 <lambdabot> why on earth would I slap nonexistent?
07:03:06 <masak> @slap nonexistent
07:03:07 <lambdabot> *SMACK*, *SLAM*, take that nonexistent!
07:03:09 <pozic> povman: yes, I used the one from hackage, but they are the same.
07:03:16 <thoughtpolice> jethr0: i didn't mean it in a bad way, no
07:03:22 <__pao__> argh
07:03:23 <__pao__> is quite difficult to follow you being a newbie :-)
07:03:49 <__pao__> could you provide a link to the haskell wiki (or anything else) for the "advanced" features you're mentioning?
07:04:16 <thoughtpolice> __pao__: to sum up, some really useful non standard extensions are: functional dependencies, multi-parameter type classes, GADTs, template haskell, existential types and probably a few others I'm forgetting
07:04:30 <thoughtpolice> __pao__: they are all described in the GHC users manual, although that might not prove to be the most 'fitting' intro
07:04:33 <povman> __pao__: a better approach might be to try implementing something with no extensions and wait until you think you might need one
07:05:08 <jethr0> povman: which has the drawback that not knowing which extensions there are your only way to finally use them is through this channel ^_^
07:05:31 <thoughtpolice> __pao__: oh, and one you can never forget - the foreign function interface.
07:05:39 <povman> ok - so also leave #haskell open so you can absorb knowledge through osmosis
07:05:40 <thoughtpolice> arguably one of the most important, these days.
07:06:01 <__pao__> povman: I agree... but I'd like to have a "surface" idea of the basic "tools"... in order to be able to say "hmmm ... maybe gatd are a good fit for this problem... let's study..."
07:06:24 <thoughtpolice> __pao__: here are a few links,
07:06:35 <thoughtpolice> http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types
07:06:38 <lambdabot> Title: Haskell/Existentially quantified types - Wikibooks, collection of open-content t ..., http://tinyurl.com/f9umb
07:06:50 <thoughtpolice> http://en.wikibooks.org/wiki/Haskell/GADT
07:06:51 <lambdabot> Title: Haskell/GADT - Wikibooks, collection of open-content textbooks
07:07:13 <__pao__> thoughtpolice: yep
07:07:17 <thoughtpolice> http://haskell.org/haskellwiki/GHC/Type_families
07:07:19 <lambdabot> Title: GHC/Type families - HaskellWiki
07:07:27 <thoughtpolice> (big note, like I said, type families are unstable in ghc 6.8.3)
07:08:05 <thoughtpolice> http://haskell.org/haskellwiki/Functional_dependencies
07:08:06 <lambdabot> Title: Functional dependencies - HaskellWiki
07:08:07 <thoughtpolice> http://haskell.org/haskellwiki/Template_Haskell
07:08:08 <lambdabot> Title: Template Haskell - HaskellWiki
07:08:26 <__pao__> thoughtpolice: thanks a lot... do phantom types is a useful tecnique?
07:08:34 <thoughtpolice> http://haskell.org/haskellwiki/GHC/Using_the_FFI
07:08:35 <lambdabot> Title: GHC/Using the FFI - HaskellWiki
07:08:44 <thoughtpolice> those are some of the most useful extensions I've found
07:09:04 <thoughtpolice> __pao__: they're useful in some instances, like I said, phantom types are an idiom - it's basically a way to hijack the type system
07:09:07 <povman> __pao__: i've found that it becomes obvious when i need to use an extension because haskell suddenly isn't expressive enough
07:10:06 <jethr0> and of course "unsafe*" for low-level hackery and "scrap you boilerplate" generics which imho use the "cast" function based on "unsafe*" and are thus also kinda an extension
07:10:11 <jethr0> to haskell98
07:10:40 <povman> __pao__: also, if you put some code on hpaste.org, people here might tell you better ways of doing stuff
07:10:44 <thoughtpolice> __pao__: for phantom types, I really liked this post:
07:10:45 <thoughtpolice> http://augustss.blogspot.com/2007/06/representing-dsl-expressions-in-haskell.html
07:10:47 <lambdabot> Title: Things that amuse me, http://tinyurl.com/35u5ec
07:10:50 <thoughtpolice> it also covers GADTs a little too
07:10:54 <thoughtpolice> but shows a good example of phantom types
07:11:28 <__pao__> povman: thanks :-)
07:11:29 <thoughtpolice> __pao__: on the note of functional dependencies I've for the most part found the literature to be poor - I still don't even know how the hell they really work, and I only know that sometimes I need them in my class and sometimes I don't
07:11:40 <thoughtpolice> (does that make me a bad programmer? :( )
07:12:12 <thoughtpolice> __pao__: luckily, type families should be able to replace fundeps and they are significantly easier to grok and reason about from the user standpoint
07:12:23 <thoughtpolice> i've found, anyway
07:12:27 <povman> thoughtpolice: if you have class A a b | a -> b
07:12:48 <povman> thoughtpolice: and instance A B C
07:13:10 <__pao__> thoughtpolice: are you the author of a vmware ubuntu image? :-)
07:13:23 <thoughtpolice> yes, it is a way of stating that B uniquely determines the second param of the type class, in this case C
07:13:29 <povman> thoughtpolice: then you can't have instance A D C
07:13:37 <thoughtpolice> but what are the real implications of that? i don't understand it much beyond that
07:13:54 <thoughtpolice> __pao__: i've seen the website but no, i'm not. :)
07:14:32 <maltem> povman: A B D, you mean?
07:14:47 <povman> maltem: er yeah :)
07:15:11 <povman> i found that http://www.haskell.org/haskellwiki/Type_arithmetic was slightly enlightening
07:15:11 <lambdabot> Title: Type arithmetic - HaskellWiki
07:19:11 <__pao__> I'm done for the next 25 years :-)
07:19:47 <thoughtpolice> __pao__: there are other extensions like OverloadedStrings and stuff too, although they don't see the most use they can still naturally be useful
07:19:48 <mc__> is there a pattern which matches any list?(even the empty list)
07:19:50 <thoughtpolice> check the GHC manual
07:19:52 <thoughtpolice> it covers them all
07:20:03 <vixey> mc__: yes
07:20:05 <ski> mc__ : `_'
07:20:24 <vixey> > case yes of [1,2,3] -> yes
07:20:26 <lambdabot>   Not in scope: `yes'
07:20:35 <ski> mc__ : also, every variable pattern
07:20:37 <vixey> :S
07:21:02 <mc__> ski: is there a pattern which only matches against every list?
07:21:17 <vixey> mc__: Do you understand about the type system?
07:21:23 <maltem> only every?
07:21:38 <mc__> vixey: probably not, just grabbed a tutorial yesterday :)
07:21:47 <mc__> type system is the nex topic
07:21:51 <vixey> mc__: well if you write something like  f x = ...
07:22:09 <vixey> mc__: if the type of 'x' there is a list type, it will never ever match against anything that isn't a list
07:22:25 <ski> mc__ : you can't decide at run-time if an argument of generic type is e.g. a list type
07:23:10 <mc__> ah, I think I understand, thank you!
07:24:20 <ski> mc__ : either something is of list type, or it is of a non-list type, or it is generic (you don't know) .. in the first case, only lists can come into question, in the second case, lists can't come into question, in the third case, you cannot determine what kind of value you're deling with, it's abstract (this is called parametricity)
07:25:08 <povman> ski: what's this generic thing?
07:26:27 <ski> mc__ : an example of the third case is `foo :: a -> ....', without knowing the definition of `foo', i can tell you that the only things `foo' can do with the argument of type `a' is pass it around, possibly discarding or duplicating the "reference"
07:26:50 <ski> povman : a universally quantified type variable
07:27:03 <ski>   foo :: forall a. a -> ...
07:27:04 <povman> oh, duh
07:27:37 <ski> the type variable is in this case also known as a skolem, or as rigid
07:27:39 <__pao__> thanks everyone :-)
07:29:14 <ski> @type let f :: a -> b; f x = x in f
07:29:15 <lambdabot>     Couldn't match expected type `b' against inferred type `a'
07:29:15 <lambdabot>       `b' is a rigid type variable bound by
07:29:15 <lambdabot>           the type signature for `f' at <interactive>:1:14
07:30:10 <ski> both `a' and `b' here are "arbitrary" "unknown" types, not known to be the same (could possibly be different in a use of `f'), so trying to match them fails
07:30:52 <ski> @type let f :: (forall a. a) -> b; f x = x in f
07:30:53 <lambdabot> forall b. (forall a. a) -> b
07:31:57 <ski> this however works, since `b' still is an unknown rigid skolem type, `forall a. a' can be matched against any type, including unknown (at this point) types
07:32:13 <ski> (s/since/even since/)
07:33:44 * ski would like a better example of this latter case .. hrm
07:36:29 <BrushThyTeeth> ski: ... i think he just started learning haskell yesterday, probably will die from type theory overload
07:41:46 <ski> povman : well, you're the one who asked about `generic' .. oh, already left :/
07:44:08 <mc__> Is it possible to specify a default value for an argument?
07:44:21 <kpreid> no
07:45:14 <mc__> kpreid: thank you
07:45:53 <kpreid> you can of course write another function applying the default
07:46:22 <kpreid> see e.g. sort / sortBy in the standard libs
07:47:41 <ski> in some cases, it might be useful to use `Maybe'
07:47:55 <ski> foo :: Maybe X -> ...
07:48:06 <mc__> Is there a reason why haskell does not support default values?
07:48:08 <ski> foo Nothing ... = foo (Just defaultX) ...
07:48:14 <ski> foo (Just x) ... = ..x..
07:48:47 <ski> mc__ : what would the type of the function be ?  how would it interact with currying
07:48:47 <mar77a> partial application and the Maybe monad are common solutions :)
07:48:47 <vixey> mc__: It isn't an often useful thing in fp
07:48:50 <ski> ?
07:48:55 <Armored_Azrael> mc__: Type signature issues--think about it. If we allowed you not to specify things, it would not typecheck.
07:48:56 <mar77a> hello vixey :D
07:49:14 <ski> however, that said, O'Caml allows default values for named arguments
07:49:16 <vixey> maybe as a Monad doesn't solve this
07:49:25 <mar77a> there's no solution for it
07:49:35 <mar77a> it just isn't supported by the language
07:49:38 <Armored_Azrael> mc__: When I want something like a default argument, I'll frequently do something like:
07:49:38 <Armored_Azrael> foo x y z = --Some stuff here
07:49:38 <Armored_Azrael> bar = foo defaultX
07:49:48 <Armored_Azrael> Then use bar
07:49:52 <vixey> mar77a: yes it is
07:50:05 <mar77a> okay
07:50:25 <mc__> Armored_Azrael: alright
07:58:38 <ski> # let f ?(a=10) x = a + x;;
07:58:38 <ski> val f : ?a:int -> int -> int = <fun>
07:58:38 <ski> # f 5;;
07:58:38 <ski> - : int = 15
07:58:38 <ski> # f ~a:100 5;;
07:58:41 <ski> - : int = 105
07:58:42 <od_> whats the difference between doing: foldr (f . g) [] [1..10] and using ghc rewrite rules to fuse?
07:58:54 <ski> (that was optional arguments in O'Caml)
08:01:01 <ski> od_ : you don't have to manually use rewrite rules, but it is not as clear when/if rules are applied ?
08:02:22 <thoughtpolice> rewrite rules make the fusion of two functions implicit, i.e. you don't have to fuse the two functions yourself by hand, because the rules cover that case and GHC will do it for you
08:02:51 <mc__> I have this 2 tiny functions http://haskell.pastebin.com/m4251fc73. Is there a way I could save me from passing the 2nd argument without introducing additional functions?
08:03:11 <thoughtpolice> for example if you do map f (map g xs), chances are GHC will fuse it into map (f . g) xs although you may not 'see it'
08:03:15 <thoughtpolice> although if you have ghc-core
08:03:19 <thoughtpolice> you can examine what rewrite rules fired
08:03:51 <od_> hmm i thought it could do some magic that manually fusing couldnt or something haha
08:04:28 <roconnor> > sum [1..5]
08:04:35 <lambdabot>  15
08:04:40 <roconnor> > product [1..5]
08:04:41 <lambdabot>  120
08:04:45 <pejo> od, the big picture is that programmers can write clear and concise programs, and the compiler makes them "efficient".
08:04:49 <roconnor> mc__: you could use sum and product.
08:05:50 <ski> or  foldl
08:06:15 <thoughtpolice> od_: no, rewrite rules are really just specified in the form lhs = rhs, where the rhs replaces occurences of the lhs, i.e. a simple one is like the above
08:06:27 <thoughtpolice> map f (map g xs) = map (f . g) xs
08:06:51 <mc__> roconnor: im wrting those for practice so I dont want to use interal functions
08:06:55 <od_> ok thanks
08:07:00 <mc__> ski: thank you I'll go with that
08:07:31 <thoughtpolice> od_: the manual has more info, but no, strictly speaking rewrite rules can't do anything you couldn't do by hand. it's just a lot more convenient to use them than fuse by hand
08:08:06 <ski> mc__ : if you're handling strict numbers,  foldl'  might be better, though
08:08:24 <mc__> ski: what is the difference?
08:09:12 <ski> calcSum [10,20,30,40] 0 = calcSum [20,30,40] (0 + 10)
08:09:28 <ski>                         = calcSum [30,40] ((0 + 10) + 20)
08:09:51 <ski>                         = calcSum [40] (((0 + 10) + 20) + 30)
08:09:51 <ski>                         = calcSum [] ((((0 + 10) + 20) + 30) + 40)
08:09:53 <ski>                         = (((0 + 10) + 20) + 30) + 40
08:09:59 <ski>                         = ((10 + 20) + 30) + 40
08:10:00 <od_> http://www.haskell.org/haskellwiki/Fold
08:10:01 <lambdabot> Title: Fold - HaskellWiki
08:10:05 <ski>                         = (30 + 30) + 40
08:10:10 <ski>                         = 60 + 40
08:10:13 <ski>                         = 100
08:10:30 <ski> using  foldl'  or  seq  or $!  it will be as
08:10:47 <ski> calcSum' [10,20,30,40] 0 = calcSum' [20,30,40] (0 + 10)
08:11:06 <ski>                          =' calcSum [20,30,40] 10
08:11:23 <ski> (er, move the prime a word to the right)
08:11:32 <ski>                          = calcSum' [30,40] (10 + 20)
08:11:36 <ski>                          = calcSum' [30,40] 30
08:11:44 <ski>                          = calcSum' [40] (30 + 30)
08:11:46 <ski>                          = calcSum' [40] 60
08:11:52 <ski>                          = calcSum' [] (60 + 40)
08:11:55 <ski>                          = calcSum' [] 100
08:11:58 <ski>                          = 100
08:12:01 <ski> instead
08:12:34 <ski> point being that, the first variant will possibly defer performing the arithmetic, until then end .. so ends up using more memory
08:12:46 <roconnor> when summing a list of functions pointwise, should foldr, foldl or foldl' be used?
08:13:28 <mc__> ski:  so what advantage does the first variant have?
08:13:32 <ski> however, ghc's strictness analyzer might be smart enough in this case to figure out that the iterated sum will be demanded, and so not defer the computation to the end, instead doing it incrementally like we want in this case
08:14:47 <ski> mc__ : in the case we're working with strict numbers like `Int', `Integer', `Double' .. not much, more memory is used (barring SSC) .. however the code is slightly simpler and clearer
08:15:12 <ski> roconnor : finite list ?
08:15:19 <roconnor> yes
08:15:28 <ski> hm
08:15:46 <roconnor> I used foldr because the list was short and it didn't really matter
08:15:56 <roconnor> but academically speaking ...
08:18:57 <ski> foldr (\f g x -> f x + g x) (\_ -> 0) [f0,f1,f2] = \x -> f0 x + (f1 x + (f2 x + 0))
08:19:19 <roconnor> ... const 0 x
08:19:55 <vixey> I thought (\f partialsum -> f x + partialsum)
08:20:05 <ski> hmhm
08:20:34 <roconnor> (\f g x -> f x + g x) is the operation I was folding.  Is that a mistake?
08:21:01 <ski> `(\f g x -> f x + g x)' here is the `(+)' operation on numbers-in-environment
08:21:50 <ski> vixey : with your variant, you must have `x' free .. where is it bound ?
08:22:27 <roconnor> ... = \x -> f0 x + (foldr ... [f1 f2] x) -- Isn't this the WHNF?
08:22:51 <roconnor> hmm
08:22:52 <ski> i.e. what i did was to start with `foldr (+) 0 [f0,f1,f2]', then expand the overloaded parts, then unfolding a bit
08:23:15 <roconnor> I suppose we want to evaluate `foldr (+) 0 [f0,f1,f2] x'
08:23:36 <ski> roconnor : you still need to bind `x' somewhere
08:23:48 <roconnor> x0 then
08:23:52 <roconnor> same thing that f0 is
08:24:02 <ski> oh, a use
08:24:31 <roconnor> I presume the sum fold will not be expanded until it is applied somewhere
08:24:56 <Leaves> hello, I'm trying to use an association list and understand the lookup function, but how do I insert and element to an association list, I though something like    insert key value store  would work but it doesn't?
08:25:30 <ski> insert key value store = (key,value) : store
08:25:33 <roconnor> insert (a,x) assocList = (a,x):assocList
08:25:43 <olsner> ... if you don't care about already existing associations
08:25:51 <mc__> Whats the best way to concat a String and a number? The ++ operator does not work.
08:26:03 <ski> mc__ : the answer is no
08:26:04 <roconnor> > show 5
08:26:04 <Zao> mc__: show  the number or use printf.
08:26:19 <lambdabot>  thread killed
08:26:26 <ski> mc__ : however, possibly you want to use `show' to convert the number into a numeral string representation
08:26:32 <roconnor> > show (5::Integer)
08:26:34 <lambdabot>  "5"
08:26:37 <ski> > show 42 ++ "!"
08:26:39 <lambdabot>  "42!"
08:27:11 <Zao> > printf "%s - %f" "omg" 3.14 :: String
08:27:13 <Leaves> ski, ok and can I also efficiently replace the alue of a certain key with another value?
08:27:14 <lambdabot>  "omg - 3.14"
08:27:25 <mc__> Zao: suggested using printf, do I have to import it?
08:27:29 <roconnor> > fix printf
08:27:44 <mc__> Prelude> printf "%s - %f" "omg" 3.14 :: String
08:27:44 <lambdabot>  thread killed
08:27:54 <mc__> <interactive>:1:0: Not in scope: `printf'
08:28:12 <Leaves> ski, ok should I use Data.Map for that?
08:28:17 <Zao> mc__: Text.Printf.printf
08:28:20 <Leaves> s/ok/or
08:28:39 <mc__> Zao: ty
08:28:41 <ski> Leaves : if you want to do many replacements, you might want to look at `Map' or arrays
08:29:31 <Leaves> ski, ok, thanks
08:29:57 <Quadrescence> data Node a = Leaf | {value :: Leaf, branches :: [Node a]} (suppose Leaf = Int, then is this a correct way to make a (non-binary) tree?)
08:31:02 <ski> (using `Leaf' for those two different purposes there is a bit confusing, imho)
08:31:34 <ski> also, you need a data constructor for the branching case
08:31:35 <Quadrescence> Well, the tree either ends up as a leaf, or is a node + branches
08:31:55 <ski>   data Node a = Leaf | Node {value :: Leaf, branches :: [Node a]}  -- e.g.
08:32:10 <Quadrescence> mmmm
08:32:32 <ski> (though, i'd rename the type to `Tree a' or something like that .. but keeping `Node' as the data constructor name)
08:33:05 <Quadrescence> Okay. So it would still 'recurse' itself that way?
08:33:14 <ski> sorry ?
08:33:30 <ski> (to clarify, i meant
08:33:52 <ski>    data Tree a = Leaf | Node {value :: Int, branches :: [Tree a]}
08:33:52 <ski> )
08:33:58 <Quadrescence> Oooh, okay. :D
08:34:46 <Quadrescence> Maybe I should make the second part a tuple. :(
08:35:12 <ski> at least until you're sure of the difference between type constructors and data constructors .. both the ideas, and where in the syntax they are used .. i'd suggest you not name any type and data constructor the same
08:35:45 <ski> Quadrescence : well, you can also just make them two separate arguments of `Node'
08:36:01 <Quadrescence> ski: What would YOU do? :D
08:36:09 <ski>   data Tree a = Leaf | Node (Int, [Tree a])  -- single tuple argument
08:36:21 <ski>   data Tree a = Leaf | Node Int [Tree a]  -- two separate arguments
08:36:27 <Quadrescence> Right, right.
08:36:48 <ski> Quadrescence : depends on the application :-P
08:36:48 <Saad_> What would the point of using a be if your not using it?
08:37:06 <Quadrescence> But maybe using the {} version is better since I would need to have accessor functions anyway
08:37:21 <ski> Saad_ : good question .. let's see Quadrescence's answer :)
08:37:48 <Quadrescence> Saad_: "a be"?
08:37:48 <ski> Quadrescence : would you ?
08:37:56 <ski> .. `a' be ..
08:38:02 <Quadrescence> Oh, haha
08:38:10 <ski> `a' as in `Tree a'
08:38:27 <Quadrescence> Well, doesn't that allow the "recursion"?
08:38:28 <Saad_> :)
08:38:36 <ski> @vixen do you know abe?
08:38:36 <lambdabot> i think i know
08:38:55 <ski> Quadrescence : what recursion ?
08:39:10 <ski> Quadrescence : do you want to use a `FixF' thing ?
08:39:55 <Quadrescence> Well, hopefully I don't say this incorrectly, but data Node a = [Node a] is isomorphic to [[[[[[[[Node a]]]]]]], right?
08:40:06 <Quadrescence> Maybe the `a' isn't necessary. :D
08:40:45 <ski> well, if you only use an argument to pass recursively back to yourself, then you're not actually using it, no
08:41:36 <ski> usually, one'd use a parameter `a' here as the type of the `value' part .. i.e. if you want this genericity
08:41:49 <ski>   data Tree a = Leaf | Node a [Tree a]
08:42:31 <Quadrescence> How about this? data Tree = Leaf {value :: Int} | Node {value :: Int, branches :: [Tree]}
08:42:56 <Quadrescence> Or is the first part a bit unnecessary?
08:43:00 <ski> i'd use
08:43:10 <ski>   data Tree = Node {value :: Int, branches :: [Tree]}
08:43:12 <ski> instead, yes
08:43:29 <ski> (it's a leaf if there's zero branches, no ?)
08:43:36 <Quadrescence> Correct
08:45:33 <Quadrescence> Well, I will want to write a function to access (a) the branches at a node (which the accessor function can do), (b) all values of a node at a certain depth of the tree.
08:46:42 <Quadrescence> The only thing I don't quite understand with your example is how the tree would end up with leaves and no branches.
08:47:54 <xif> hey, which characters are allowed in function names?
08:47:57 <ski>   Node 6 [Node 284 [],Node 8128 [Node 945 [],Node 220 [],Node 496 []]] :: Tree Int
08:47:57 <Quadrescence> s/all the values of a node/all the values at all nodes/ (two lines up)
08:49:14 <Quadrescence> ski: But then wouldn't we have to use `maybe' or something?
08:49:32 <xif> from the Haskell report: "An identifier consists of a letter followed by zero or more letters, digits, underscores, and single quotes."
08:49:45 <xif> does that ally to all Haskell systems?
08:51:24 <ski> Quadrescence : hm .. for what ?
08:51:47 <Quadrescence> Well, I don't see how Tree can be "null" or an empty list.
08:51:57 <ski> Node 42 []
08:52:15 <ski> the tree must contain at least one `Int' as the type is defined
08:53:14 <ski> this applies to your `data Tree = Leaf {value :: Int} | Node {value :: Int, branches :: [Tree]}' too, of course .. but not to `data Tree a = Leaf | Node Int [Tree a]' and previous versions
08:54:05 <vixey> xif, yes
08:54:10 <ski> xif : well, at least GHC has some extension that allows `#' to be used in identifiers .. this is then typically used for low-level GHC-primitive stuff
08:54:34 <ski> @type 42#
08:54:35 <lambdabot> GHC.Prim.Int#
08:54:42 <ski> is an unboxed int
08:55:07 <ski> @type (GHC.Prim.+#)
08:55:07 <Quadrescence> I really need to learn the explicit difference between data and type. D:
08:55:08 <lambdabot> GHC.Prim.Int# -> GHC.Prim.Int# -> GHC.Prim.Int#
08:55:38 <ski> Quadrescence : `type' just gives a new name to an existing type .. `data' (and `newtype') constructs new types
08:56:04 <Quadrescence> So data COULD be used in place of type, technically? Or no?
08:56:15 <ski> no, differing syntax
08:56:39 <ski> `newtype' can be replaced with `data' (albeit with slightly differing semantics)
08:57:12 <Quadrescence> data Foo = Foo Int , type Foo = Int
08:57:46 <vixey> why not use different names
08:57:58 <Quadrescence> vixey: That was for the purpose of example
08:58:05 <vixey> it's a bit hard to talk about things when everything is called Foo
08:58:22 <Quadrescence> I know, I know, I was just wondering if those were equivalent in some way
08:58:26 * ski prefers adding `Mk' when there's no more natural naming
08:58:35 <Leaves> In a Data.Map I only want to update a value for a certain key when the new value if bigger then the value already in the store (or when this key isn't yet in the store), do you know if there exists a function for that?
08:59:16 <Leaves> Something like conditionalInsert key val (>3) map
08:59:58 <taruti> Leaves: insertWith
09:00:05 <vixey> :t updateMaxWithKey
09:00:05 <Leaves> or in this case actually conditionalInsert key val (<val) map
09:00:07 <lambdabot> Not in scope: `updateMaxWithKey'
09:00:14 <vixey> :t M.updateMaxWithKey
09:00:15 <lambdabot> forall k a. (k -> a -> Maybe a) -> M.Map k a -> M.Map k a
09:00:33 <vixey> :t M.updateMin
09:00:35 <lambdabot> forall a k. (a -> Maybe a) -> M.Map k a -> M.Map k a
09:00:43 <vixey> neither of them does what you said
09:00:55 <xif> ski, vixey: interesting, thanks.
09:01:28 <ski> (xif : also note the part in the report about identifiers starting with `_')
09:01:38 * xif nods
09:01:56 <taruti> insertWith (\old new -> if old > 3 then old else new) key newValue theMap
09:02:42 <Leaves> thanks, it works! the code looks much nicer now, I use  now insertWith max key val map
09:02:44 <taruti> make that \new old
09:08:43 <Quadrescence> If I have a bunch of type constructions of the form: type Foo = [(FooBar,[Baz])], would I just use, for simplicity, data Foo a b = MkFoo [(a,[b])] ?
09:09:16 <ski> you can have parameters with `type' too
09:10:10 <kpreid> type MM a b = [(a, [b])]
09:10:11 <ski> also, if you just want to make an "alias" type, but where you have to use explicit structors to convert, i'd usually use `newtype'
09:10:17 <kpreid> type Foo = MM FooBar Baz
09:13:57 <Quadrescence> ski, kpreid: Thanks. :)
09:15:58 <misterbeebee> is there a standard syntax/style for setters? For example:  data Foo = { unBar, unBaz }
09:16:24 <misterbeebee> I'd like to write  setBar bar' foo --->   {bar' baz}
09:16:32 <misterbeebee> (you get the gist)
09:16:50 * vixey does not understand that
09:16:55 <ski> @google functional references
09:16:56 <lambdabot> http://twan.home.fmf.nl/blog/haskell/overloading-functional-references.details
09:16:56 <lambdabot> Title: Overloading functional references - 21 thoughts
09:17:04 <ski> is one attempt
09:17:11 <kpreid> misterbeebee: do you know about record update syntax?
09:17:21 <misterbeebee> no, that's what I'm missing.
09:17:35 <misterbeebee> I know about the automatic syntax for getter, but not setter
09:17:45 <kpreid> if you write an actual record, data Foo = Foo { bar :: Bar, baz :: Baz } then given a value foo, you can write: foo { bar = bar' }
09:18:00 <kpreid> and the result is a record with all fields the same but bar
09:18:12 <misterbeebee> oh, I didn't know that worked for just one field. that's all i wanted. thanks!
09:18:13 <ski> let foo = MkFoo {unBar = 5,unBaz = ()} in foo {unBar = 10}
09:19:10 <kpreid> misterbeebee: note this is different from the record construction syntax; you put the old value instead of the constructor name
09:19:41 <misterbeebee> I had this horribly ugly code with a record full of IORefs and lots of do code, now I'm rewriting it more cleanly and with less premature optimization
09:20:01 <ski> (misterbeebee : also note that nested replacing is a pain in the ass)
09:23:20 <stevan> hi, could someone explain to me how come the following runs fine in ghci, but won't typecheck (even if i use the exact same type as :t outputs) if i put it into a file and try to load it? everywhereM (mkM (\x -> (+x) <$> read <$> getLine)) [('a', 1), ('b', 2)]. thanks.
09:26:20 <Saizan_> stevan: (Data t, Num t) => IO [(Char,t)] ?
09:26:24 <vixey> stevan: maybe different modules loaded
09:26:41 <int-e> @index everywhereM
09:26:42 <lambdabot> Data.Generics.Schemes, Data.Generics
09:27:43 <ToRA> i think it's a combination of defaulting and the monomorphism restriction that means it works in ghci but not in ghc
09:30:02 <stevan> http://hpaste.org/9051
09:30:06 <int-e> stevan: there's no way for the compiler to fix the type for 'x' in the argument for mkM - try mkM (\x -> (+(x :: Int)) <$> read <$> getLine)
09:30:24 <int-e> stevan: or Integer if your tuples contain Integer values
09:33:10 <Quadrescence> Modules are used for splitting types/datas/functions and such into a separate file, right?
09:33:21 <atp> yep
09:33:26 <atp> and a separate namespace
09:33:48 <t0c> Hi all, if someone feels bored and likes Haskell FFI, maybe this person can have a look at http://hpaste.org/9050?lines=true which is a first attempt to interface with libevent. It compiles and runs, but notifications don't work. In fact there is no output at all. For sure I do things wrong.
09:33:59 <stevan> int-e: that typechecks, however running the function outputs [('a',1),('b',2)] without doing the IO (getLine)... both in the file and in ghci.
09:34:47 <stevan> ah, Integer worked
09:35:44 <Quadrescence> hum, if module foo imports module bar, then if I use module foo in a main program, do I need to import module bar to use _in the main program_ too?
09:36:04 <Quadrescence> (i.e. is module bar only local to foo?)
09:36:07 <atp> Quadrescence: it depends, does module foo export module bar?
09:36:09 <dmhouse> Yes, unless Foo re-exports Bar.
09:36:36 <xif> does lambdabot provide any special pastebin features?
09:36:47 <dmhouse> xif: it'll pick up pastes from hpaste.org
09:36:57 <xif> in fact, what's the way to get a list of lambdabot's commands?
09:37:01 <atp> Quadrescence: in practice lots of libraries meant for public consumption are split into several modules internally and those are exported by the "main" library
09:37:02 <dmhouse> ?list
09:37:02 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
09:37:07 <xif> dmhouse: thanks
09:37:33 <atp> Quadrescence: so that the user need only import one module and can be blissfully unaware of the internal structure
09:37:39 <xif> OK, how do I get help about a specific command?  read the source? :)
09:37:46 <Quadrescence> atp: Haha, :D
09:37:53 <atp> xif: use the source, luke.
09:37:53 <dmhouse> ?help tell
09:37:53 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
09:37:57 <vixey> @help pl
09:37:58 <lambdabot> pointless <expr>. Play with pointfree code.
09:38:12 <xif> cool, thanks.
09:38:24 <xif> my awesome paste is almost ready, hold your breath.
09:38:24 <dmhouse> Hrm, where's the hpaste bot these days?
09:38:36 * dmhouse just sent something to hpaste, and it's not been announced.
09:38:43 <vixey> gone for weeks
09:38:43 <atp> xif: you can privmsg lambdabot if you want to screw around with it without spamming the channel
09:39:03 <ndmitchell> matthew-_: have you put your paper up somewhere? might allow others to take a look at it
09:39:08 <roconnor> @see hpaste
09:39:09 <lambdabot> Last time I saw hpaste was when I left ##logic, #arch-haskell, #darcs, #dreamlinux-es, #friendly-coders, #gentoo-haskell, #gentoo-uy, #ghc, #haskell, #haskell-blah, #haskell-books, #haskell-hac07, #
09:39:09 <lambdabot> haskell-hac4, #haskell-overflow, #haskell-soc, #haskell.cz, #haskell.de, #haskell.dut, #haskell.es, #haskell.fi, #haskell.fr, #haskell.hr, #haskell.it, #haskell.jp, #haskell.no, #haskell.ru, #
09:39:09 <lambdabot> haskell.se, #haskell_ru, #japanese, #jhc, #jtiger, #macosx, #parrot, #perl6, #rosettacode, #scala, #scannedinavian, #thunks, #unicycling and #xmonad 3d 19h 41m 47s ago, and .
09:39:17 <bwr> why does something like "words <$> getLine >>= mapM (liftM read)" not work
09:39:21 <ndmitchell> matthew-_: and if it makes you feel any better, i've had 3 rejected papers so far this year :)
09:39:24 <xif> atp: actually, I want it to be announced
09:39:25 <dmhouse> ?ask glguy where the hpase bot is
09:39:25 <lambdabot> Consider it noted.
09:39:42 <atp> bwr: the type of liftM read is wrong?
09:39:43 <xif> OK, here's my [String] sorter. any comments welcome: http://hpaste.org/9053
09:39:49 <atp> :t mapM
09:39:51 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
09:39:55 <atp> :t liftM
09:39:57 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
09:40:02 <atp> :t read
09:40:04 <lambdabot> forall a. (Read a) => String -> a
09:40:14 <atp> so liftM read is m String -> m a
09:40:15 <bwr> i guess i don't quite understand the type stuff yet :
09:40:20 <atp> but mapM wants a -> m b
09:40:24 <bwr> ah
09:40:30 <atp> bwr: that's ok, it'll come :)
09:40:49 <dmhouse> xif: if those are local functions to sort, you should put them in a 'where' clause so as to avoid polluting the global namespace.
09:41:03 <Quadrescence> How do I export? Same way I import but just with `export'? :)
09:41:12 <atp> bwr: you probably want return instead of liftM
09:41:27 <vixey> xif, I think the sort'' should be renamed as insert
09:41:29 <xif> dmhouse: good point (feel free to pastebin a refactored version if you like )
09:41:36 <therp> does anyone know code that makes use of the category-extra library?
09:41:37 <dmhouse> Quadrescence: no, the same way you export functions.
09:41:46 <dmhouse> module Foo (foo, module Bar) where -- IIRC
09:41:51 <bwr> atp: ok i'll look at return
09:41:56 <Toxaris> bwr: why not (map read . words) <$> getLine?
09:41:57 <atp> :t return
09:41:58 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
09:41:59 <xif> vixey: yeah, the names there are basically foo, foo1 and foo2 :)
09:42:13 <atp> bwr: and Toxaris is right
09:42:17 <Toxaris> bwr: rule of thumb for the use of >>=: don't use it
09:42:27 <Toxaris> bwr: (unless you must, of course)
09:42:33 <dmhouse> xif: is this insert sort? Any particular reason you chose that, or just for practice? Quicksort is dead easy to write in Haskell, and is probably faster than an insertion sort.
09:42:37 <atp> i don't know, i actually like >>=
09:42:48 <xif> dmhouse: this is practice.
09:42:53 <bwr> hah
09:43:01 <Toxaris> dmhouse: dead-easy quicksort is fast in Haskell?
09:43:02 <vixey> dmhouse: I kind of doubt it
09:43:05 <atp> i think explicitly using >>= when you're a beginner helps you divorce yourself from the idea that do style block programming is magical
09:43:09 <xif> I don't know much sorting theory, if you say this is "insert sort" I believe you :)
09:43:09 <dmhouse> xif: also, it seems there is no need to limit to just Strings, it ought to be able to sort lists of anything in Ord.
09:43:11 <vixey> xifs way looks faster than quicksort
09:43:14 * xif nods
09:43:35 <Toxaris> atp: I agree. my rule of thumb for the use of do is: never ever use it :)
09:43:49 <atp> Toxaris: ah, i see.
09:43:52 <dmhouse> Good practice there is just to leave the types off and see what the compiler suggests.
09:44:09 <vixey> yeah I don't really ever annotate types in haskell
09:44:10 <xif> nice idea. where would the "where" go, btw?
09:44:24 <vixey> unless it's ST or something that needs it
09:44:26 <Toxaris> atp: but I know quite a number of people who strongly disagree with that policy. my supervisor keeps asking my why I run obfuscators over the code I show him.
09:44:27 <dmhouse> Ah, I'd put the types back in afterwards, for documentation.
09:44:35 <vixey> no
09:44:41 <vixey> they aren't good documentation
09:44:46 <atp> Toxaris: ooo, you get to code haskell at work?  nice
09:45:00 <dmhouse> vixey, they're better than no types :P
09:45:42 <Quadrescence> This is a very fast algorithm in haskell, by the way: http://en.wikipedia.org/wiki/Bogosort
09:45:44 <lambdabot> Title: Bogosort - Wikipedia, the free encyclopedia
09:45:47 <Quadrescence> :>
09:45:57 <Toxaris> atp: if you call a phd work... there is a lot of work, but the payment is somewhat substandard compared with what other people call work :)
09:45:59 <atp> yeah, i have to say that i agree with dmhouse, vixey
09:46:31 <atp> Toxaris: ah, i see.  no, a phd is definitely work, in the same way motherhood is work -- hard as heck with little or no financial reward whatsoever
09:48:42 <Toxaris> vixey: why are types not good documentation?
09:49:20 <shepheb> attached to which line?
09:49:23 <shepheb> mischan
09:49:30 <vixey> they aren't good or bad documentation, they are just not documentation
09:50:41 <therp> I'm looking at the moment at the types of category-extras.. no they are not documentation..
09:51:08 <Toxaris> therp: consider looking at the functions in category-extras without seeing their type. would it be better or worse
09:51:12 <dmhouse> vixey: well, semantics. They help a reader understand what the function is supposed to do. Whether you call that documentation or not I don't care, they're still useful.
09:51:27 <therp> Toxaris: worse.
09:51:36 <vixey> dmhouse: I know types are useful
09:52:01 <xif> could anyone say where I should put the "where" clause in the function I pasted ( http://hpaste.org/9053 )?
09:52:08 <Toxaris> vixey: what about e.g. the name of type variables chosen in types, or additional parentheses, or the use of type synonyms to highlight similiarites between types of different things
09:52:29 <vixey> xif, you shouldn't use where, you should just name things better
09:53:11 <dmhouse> xif: http://hpaste.org/9053#a1
09:53:26 <Toxaris> xif: regarding your sorting, two ideas: (1) can you use a more general type instead of String? (2) can you give a better name to sort''?
09:53:28 <xif> vixey: well, actually, I sort of agree with dmhouse's comments:  sort' and sort'' are just helper functions for sort, they shouldn't pollute the global namespace.
09:53:45 <vixey> @src sort
09:53:45 <johnnowak> xif: so don't export them
09:53:45 <lambdabot> sort = sortBy compare
09:53:51 <vixey> @src sortBy
09:53:52 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
09:53:57 <xif> Toxaris: 2) vixey suggested "insert",  1) yes :)
09:53:57 <vixey> @src insertBy
09:53:58 <lambdabot> insertBy _   x [] = [x]
09:53:58 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
09:53:58 <lambdabot>                                  GT -> y : insertBy cmp x ys'
09:53:58 <lambdabot>                                  _  -> x : ys
09:54:13 <Toxaris> xif: oh ok. note that insert is even defined in the Prelude :)
09:54:18 <vixey> xif, look at these examples
09:54:19 <xif> dmhouse: thanks a bunch.
09:54:27 <Toxaris> xif: but probably I'm somewhat late with these ideas...
09:54:29 <xif> vixey: I will, thanks.
09:54:36 <vixey> xif, You can generally accept what lambdabot says as good style
09:54:46 <vixey> xif, And appending ''s all over the place as bad style
09:54:56 <xif> yeah, lambdabot is hardcore.
09:55:06 <vixey> what
09:55:10 <atp> xif: although, when you discover @pl, go easy with it.
09:55:14 <atp> hehe
09:55:28 <xif> ?pl
09:55:29 <lambdabot> (line 1, column 1):
09:55:29 <lambdabot> unexpected end of input
09:55:29 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
09:55:43 <xif> @help pl
09:55:43 <lambdabot> pointless <expr>. Play with pointfree code.
09:55:50 <xif> ah, kewlness
09:55:53 <johnnowak> ?pl \x y z -> x * (x + y + z)
09:55:53 <lambdabot> ap ((.) . (.) . (*)) (((+) .) . (+))
09:56:29 <johnnowak> erugh
09:57:30 <Baughn> @pl \x y z -> x*x + y*x + z*x
09:57:31 <lambdabot> ap (flip . (((.) . (+)) .) . ap ((.) . (+) . join (*)) (*)) (*)
09:57:39 <Baughn> johnnowak: ..there, that's better
09:58:03 <johnnowak> dup tri[*]
09:58:32 <Quadrescence> atp: When you (i think it was you) said that modules make their own namespace, how do I refer to functions in those modules then? If I have module foo, with function baz, then do I just use foo.baz or sumpin?
09:58:35 <mc__> What to write into an else clause in case I dont want to do anything?
09:58:52 <Baughn> mc__: *do*? Are we talking IO here?
09:58:55 <Baughn> "return ()" usually works
09:59:17 <Baughn> johnnowak: It seems to me that, if you use a parameter twice or more, there's rarely any point in even /trying/ to use pointsfree style
09:59:27 <Baughn> @pl \x y z -> x+y+z
09:59:28 <lambdabot> ((+) .) . (+)
09:59:29 <Toxaris> Quadrescence: there are several flavors of import
09:59:42 <mc__> Baughn:  yeah we are talking IO
09:59:52 <atp> Quadrescence: if a module is named Foo, then a function in Foo is named Foo.function
10:00:01 <PeakerWork> Baughn: that's because instead of a nice dup function to spread a parameter across multiple functions, we have use of the (->) Monad instance, which is crazy
10:00:04 <Quadrescence> mmMmMMMmMMMm
10:00:25 <Toxaris> Quadrescence: same allow to access imported stuff unqualified, some enforce qualified access, some allow to give a new name to the imported namespace
10:00:31 <Baughn> mc__: As I said, "return ()". Though better yet would be to avoid needing the clause at all; there are combinators like when/unless that implicitly handle it.. though of course that's not case
10:00:32 <johnnowak> Baughn: in haskell. in a concatenative language, this stuff is trivial.
10:00:35 <atp> Quadrescence: in order to improve readability, it is considered good style to not leave spaces between the module name, the period, and the function name -- and then when writing function composition, to always leave spaces.
10:00:57 <Quadrescence> Wait, Toxaris, wasn't it you whom I was annoying before my foot accidentally unplugged my power strip? (you probably didn't know the second part)
10:01:38 <Toxaris> Quadrescence: hmm, something about solving the rubiks cube by storing all states to disk?
10:01:44 <Quadrescence> (and thanks atp and Toxaris)
10:01:47 <Quadrescence> Toxaris: Indeed!
10:01:48 <Quadrescence> :D
10:02:01 <atp> johnnowak: to be fair though, concatenative languages are basically point-free by default.
10:02:05 <Toxaris> Quadrescence: I have all of my power strips ducktaped to where they belong. sounds crazy, but works fine
10:02:16 <johnnowak> atp: aye. they're optimized for it essentially.
10:02:19 <mc__> Baughn: I'll try when, thank you
10:02:31 <Quadrescence> Toxaris: It's a long story as to why that happened.
10:02:32 <atp> johnnowak: do you use factor at all?  i've only done forth.
10:02:32 <xif> cool, when I removed the type declarations from the sort above, I got:
10:02:33 <xif> sort :: (Ord t) => [t] -> [t]
10:02:51 <johnnowak> atp: yes
10:02:58 <atp> johnnowak: how is it?
10:03:14 <johnnowak> atp: it's very nice.
10:03:30 <atp> johnnowak: i've been thinking i should look into it one of these days.
10:03:49 <johnnowak> i prefer typed languages, but if you can get on without that, it's worth a shot.
10:04:48 <Quadrescence> Is there some sort of IDE for Windows? (All I really want is keyword highlighting, and maybe something to easily see what functions/types/etc I've defined)
10:04:58 <mc__> Baughn: well when/unless are not in scope, and return () does not work in my case. the function: http://haskell.pastebin.com/m422a032d
10:05:07 <Quadrescence> (I've been using notepad++ for keyword highlighting)
10:05:08 <xif> Quadrescence: Vim, probably...
10:05:25 <dmhouse> Emacs and Vim are the best Haskell editors available.
10:05:42 <mc__> Quadrescence: there is leksah
10:05:44 <johnnowak> Quadrescence: the creatively named http://www.e-texteditor.com/ didn't look terrible
10:05:44 <lambdabot> Title: E - TextEditor | The power of TextMate on Windows
10:05:51 <johnnowak> if you're willing to pay...
10:05:53 <dmhouse> There's also a plugin for Visual Studio I believe, not sure how good that is.
10:06:08 <Baughn> mc__: Oh, that's awful style
10:06:31 <Toxaris> Quadrescence: I'm using jedit. If your are as afraid of learning emacs as I am, maybe that's a choice. It's basically poor man's emacs written in Java.
10:06:31 <Baughn> mc__: You do not need to (in fact, it could break things) add parantheses around parameters
10:06:34 <Quadrescence> dmhouse: Yes, I saw that. I don't know if I want to run a rull visual studio...suite just to write some haskell code
10:06:48 <johnnowak> Baughn: break things?
10:06:48 <Baughn> mc__: And "do foo" is perfectly equivalent to just "foo"
10:06:53 <Toxaris> Quadrescence: there is an eclipse plugin, even partly written in Haskell (!), but it is not exactly good
10:07:06 <Baughn> johnnowak: Well, if you decide typing "map (foo bar)" is a good idea instead of "map foo bar"..
10:07:30 <johnnowak> ah, sure
10:07:34 <vixey> bar foo map
10:07:40 <mc__> Baughn: where should I add parentheses ?
10:07:47 <Baughn> mc__: You shouldn't.
10:07:56 <Quadrescence> Toxaris: Yeah. Again, I don't need a full blown IDE, unless a full blown IDE = syntactic highlighting and the ability to recognize things that are defined. :\
10:08:05 <johnnowak> vixey: so you'll be using factor soon as well then? :)
10:08:06 <mc__> Baughn: ah sorry I misread you sentence
10:08:07 <Baughn> mc__: Only add parantheses when you have to
10:08:27 <xif> Quadrescence: http://www.haskell.org/haskellwiki/Tags explains how to "recognize things that are defined"
10:08:27 <lambdabot> Title: Tags - HaskellWiki
10:08:36 <Baughn> mc__: So, for example "putStrLn (show x ++ "facto.." ++ show (calcProd [1..x]))" is fine
10:08:44 <vixey> no
10:08:45 <dmhouse> Quadrescence: nearly everything does syntax highlighting. The second is a bit harder to do.
10:08:48 <xif> though I'm not sure how well c/etags are supported on win32 sans cygwin.
10:08:50 <Toxaris> Quadrescence: well, jedit has syntax highlighting and very simple identifier completion (completes everything which is either in the syntax definition or in the current file), but it doesn't actually parse your code
10:09:02 <Baughn> mc__: So is "putStrLn $ show x ++ "facto.." ++ show (calcProd [1..x])"
10:09:24 <Baughn> mc__: "do calcFacs(xs)" should always be just "calcFacs xs"
10:09:28 <mc__> what does the dollar sign mean Baughn ?
10:09:43 <vixey> f $ x = f x
10:09:44 <xif> mc__: application
10:09:45 <Quadrescence> dmhouse: Right. I already have syntax highlighting. It would just be easier to organize if ... yeah, i don't need to explain why I would want this. :P
10:09:59 <vixey> putStrLn $ show x = putStrLn (show x)
10:10:14 <mc__> Baughn:  what is the difference without "do" ? The tutorial I grabbed always uses do
10:10:14 <Toxaris> Quadrescence: a state of the art "full blown Haskell IDE" includes features like "give me the type of the identifier at the cursor" or "reload the current file"
10:10:27 <Baughn> mc__: It's a lowest-priority application operator.. the effect is that "foo $ bar" becomes "(foo) (bar)", which is useful when the expressions on either side is more complex
10:10:39 <Toxaris> Quadrescence: afaik there are no real state of the art IDEs for Haskell with refactoring support etc.
10:10:42 <Baughn> mc__: There is no difference. do-syntax is syntactic sugar, and "do foo" desugars to just "foo"
10:10:47 <vixey> foo $ bar becomes foo bar
10:10:57 <Quadrescence> Toxaris: I didn't think so. I looked around, but didn't see much.
10:11:19 <Toxaris> Quadrescence: but I managed to tweak ghc's output with a awk script :) so that compile errors get correctly annotated in my source code  la Eclipse & Co
10:11:21 <Baughn> mc__: The same is, of course, not true if there's more than one command in the do. You'll find out exactly why when you read a monad tutorial.
10:11:32 <mc__> Baughn: alright
10:12:23 <Baughn> mc__: Oh,a nd "not null xs" becomes "(not null) xs", which has not attempting to work on a /function/ instead of the Bool it expects. You want "not (null xs)", "not $ null xs" or even "(not . null) xs"
10:12:26 <Quadrescence> Toxaris: I'd say `au' as opposed to `a la', but that's just me. :)
10:12:55 <Baughn> mc__: Or, in this case, "when (not (null xs)) (calcFacs xs)", or an equivalent
10:13:25 <Toxaris> Quadrescence: I do not want to pretend that I have any clue of french
10:13:26 <mc__> now I'm starting to get a headache xD
10:13:30 <Baughn> mc__: "when" is, by the way, in Control.Monad
10:13:42 <mc__> Baughn: thank you for the hin
10:13:49 * Quadrescence huggles Toxaris.
10:13:51 <Quadrescence> It's okay. :>
10:13:56 <Toxaris> :)
10:14:02 <Baughn> mc__: Lastly, one last thing - the function you've written mixes IO output with computation. This is generally a bad idea.
10:14:14 <dmhouse> Quadrescence: I would recommend http://haskell.org/haskellwiki/Haskell_mode_for_Emacs. It parses GHCi output and highlights errors, has commands for looking up the type/info about identifer under the cursor, as well as a few bonus features like Hoogle integration.
10:14:15 <lambdabot> Title: Haskell mode for Emacs - HaskellWiki
10:14:41 <Baughn> mc__: Make it a pure function instead, have it /return/ what you want to print (a list of "factorial is.. " lines, apparently), then print /that/
10:14:59 <dmhouse> If you don't already know Emacs, then 1) you should, take this as an opportunity to learn it, count it as a life skill, but 2) it will take some time (say, a few days' usage) before you start to become productive at using it.
10:15:29 <mc__> Baughn: Ill do so, you were very helpfull thank you
10:16:15 <Baughn> mc__: http://haskell.pastebin.com/m7f44763a <-- Here's how I would do it, with explicit recursion
10:16:34 <Quadrescence> ftp.gnu.org = fast server D:
10:16:54 <Quadrescence> 1MB/s, I never get that. D: D: D:
10:17:44 <Baughn> mc__: http://haskell.pastebin.com/m697749a7 <-- A better way. Oh, but of course you want it to return a /string/, not just the bare product.. don't worry, that's just as easy here, use ++ and all..
10:19:05 <Baughn> mc__: I'll leave you alone to chew on it now. ;)
10:19:13 <johnnowak> mc__: use 'map'
10:20:28 <mfp> is there anything faster than Text.Printf.printf for formatted output? (in particular, if some arguments are ByteStrings)
10:23:21 <vixey> Why are there no articles about how to get huge boosts in correctness/ironing out bugs using types, all the tutorials seem to only talk about keeping your head above water
10:24:04 <nolrai_East> @ty \a b -> (a : b : []) : a
10:24:07 <lambdabot>     Occurs check: cannot construct the infinite type: a = [[a]]
10:24:07 <lambdabot>       Expected type: [[a]]
10:24:07 <lambdabot>       Inferred type: a
10:24:38 <nolrai_East> vixey: good question.
10:24:55 <johnnowak> vixey: perhaps because the benefits are considered self-evident?
10:25:13 * johnnowak is half-joking
10:25:28 <mfp> vixey: maybe because the benefits are more perceptible when you're enforcing invariants in large codebases? blogposts, small tutorials & such only carry small snippets
10:26:37 <johnnowak> there are quite a few articles on how phantom types can be used to get some additional guarantees
10:27:07 <PeakerWork> I think large projects should have unit tests. With unit tests, types' aid to correctness is diminished.  However, they can hugely reduce debug cycles, and save a lot of unit tests from having to be written -- saving time
10:27:43 <johnnowak> diminished or not, i'll take all the "correctness" i can get
10:28:01 <PeakerWork> sure, types have disadvantages too, though. Especially without inference
10:28:28 <nolrai_East> @ty let f = [f] in f
10:28:29 <lambdabot>     Occurs check: cannot construct the infinite type: t = [t]
10:28:29 <lambdabot>       Expected type: t
10:28:29 <lambdabot>       Inferred type: [t]
10:28:36 <mfp> speaking of correctness, is there some standard, functional unparsing module (akin to Text.Printf but without runtime errors)? And something faster ;) (see above)
10:28:51 <vixey> @ty fix (\x -> In . [x])
10:28:53 <lambdabot> [Mu []]
10:28:55 <vixey> @ty fix (\x -> In [x])
10:28:56 <lambdabot> Mu []
10:28:57 <Quadrescence> You can delete the last character you typed by typing <Delback>. <Delback> is a key on the keyboard--the same one you normally use, outside Emacs, for deleting the last character you typed.  It is normally a large key a couple of lines up from the <Return> key, and it is usually labeled "Delete", "Del" or "Backspace".
10:29:05 <Quadrescence> lol @ gnu dev
10:29:36 <gwern> you can't say they don't provide documentation...
10:29:37 <vixey> mfp: Text.PrettyPrint exists
10:29:38 <johnnowak> depressing
10:29:49 <Toxaris> gwern: they probide keybindings wich need documentation
10:29:50 <Quadrescence> gwern: Haha :D :D
10:30:06 <Toxaris> gwern: instead of providing a GUI which allows to learn keybindings while using the software
10:30:40 <johnnowak> Toxaris: it's 1976, an intuitive gui is out of the question!
10:31:22 <gwern> emacs has a gui, and the splash screen immediately tells you you want the nice tutorial
10:32:06 <mfp> vixey: PrettyPrint does word-wrapping and such? If so, I'd expect it to be slower than Printf. It's type-safe at least :)
10:32:18 <johnnowak> yes, it has "a gui", and you can read the manual.
10:32:19 <vixey> I don't know if it does word wrap
10:32:35 <vixey> the delimited continuation based printf is type safe
10:32:36 <Quadrescence> johnnowak: :))
10:33:00 * roconnor never got backspace and help working at the same time in Emacs when he was younger
10:33:57 <gwern> roconnor: I feel blessed I never ran into that weird terminal problem, except on SDF's netbsd shell accounts
10:34:53 <Quadrescence> Are most of these keybindings for people who might lack a mouse? D:
10:35:18 <johnnowak> Quadrescence: they're for people with two keyboards
10:35:38 <Quadrescence> Oh. Two keyboards.
10:36:44 <Quadrescence> Oh my god I clicked something and emacs is now split. D:
10:37:03 <johnnowak> time to read the manual!
10:37:11 <gwern> splitting is fun
10:37:29 <mc__> Quadrescence: if you are on Mac I can recommend TextMate btw
10:37:36 <Quadrescence> AHahah, I right clicked something and it disappeared.
10:38:15 <Baughn> Quadrescence: I don't think you're meant to use emacs. It clearly hates you.
10:38:22 <johnnowak> i wish there were a haskell equivalent to DrScheme
10:38:29 <Quadrescence> Baughn: That was a good thing that it closed! :D
10:38:30 <Baughn> Quadrescence: Type alt-x doctor
10:38:33 <pozic> Quadrescence: M-x doctor
10:38:47 <xif> is there a shorter form to write the following: ["abc", "bcf", "ayfcb", "ba", "aa"]
10:39:01 <PeakerWork> xif: hey.  use words?
10:39:14 <Quadrescence> Yesssss, a doctorrrrrr.
10:39:14 <xif> PeakerWork: hey, plz explain :>
10:39:19 <Quadrescence> Let's talk to him.
10:39:39 <PeakerWork> @type words
10:39:39 <lambdabot> String -> [String]
10:39:48 <PeakerWork> > words "abc bcf ayfcb ba aa"
10:39:51 <lambdabot>  ["abc","bcf","ayfcb","ba","aa"]
10:40:02 <xif> PeakerWork: awesome, thx
10:40:08 <Baughn> Quadrescence: It's worth noting that Emacs comes with a built-in psychotherapist for people who go insane from the keybindings.
10:40:17 <PeakerWork> Baughn: and tetris!
10:40:22 <PeakerWork> and gomuko
10:40:36 <xif> PeakerWork: (btw, hah, in America we don't work on Sunday ;)
10:41:03 <PeakerWork> xif: in Israel we don't work on Fridays :)
10:41:09 <xif> :(
10:43:03 <atp> PeakerWork: you're in israel?
10:43:08 <PeakerWork> atp: Yeah
10:43:14 <atp> where?
10:43:15 <pozic> Where did Control.Parallel.Strategies go?
10:43:18 <PeakerWork> atp: Tel Aviv
10:43:26 <pozic> It's not installed in 6.8.2 here.
10:43:28 <atp> PeakerWork: nice
10:43:32 <thoughtpolice> pozic: it's in 'parallel' I believe
10:43:35 <PeakerWork> atp: Where are you?
10:43:44 <atp> PeakerWork: alaska.  i bet the weather there is better
10:43:46 <thoughtpolice> (the package, that is)
10:43:57 <pozic> thoughtpolice: yes, but shouldn't it just work in ghci?
10:44:15 <xif> atp: why are you in Alaska?
10:44:18 <PeakerWork> atp: I wish I had the weather of Alaska. Our summer is terrible. 100% humidity with 30C degrees in the shadow
10:44:31 <atp> PeakerWork: when i first moved up here i thought i would have to go forever without falafel, etc, but thank goodness for palestinian immigrants :)
10:44:45 <johnnowak> i also wish i was in alaska. this weather sucks.
10:44:48 <pozic> thoughtpolice: no, it's on hackage.
10:44:48 <atp> PeakerWork: i like humidity and 30 C
10:44:50 <pozic> thoughtpolice: thanks.
10:44:58 <johnnowak> atp: you're insane
10:45:01 <atp> PeakerWork: the average high here has been like 12 C all july
10:45:05 <PeakerWork> atp: Heh cool - when were you in Israel?
10:45:24 <PeakerWork> atp: Humidity + 30C == Lots and lots of sweat, really fast
10:45:25 <xif> PeakerWork: amazingly enough, here in SoCal it's 68.0 ℉ today, cloudy.
10:45:32 <atp> PeakerWork: i actually have never been.  my first serious girlfriend was israeli and my family is jewish though, so...
10:45:44 <PeakerWork> xif: what's that in Celsius?
10:45:46 <atp> PeakerWork: in fact my mom & stepdad will be in tel aviv in september for a wedding
10:45:49 <johnnowak> it's 92F and humid in new york..
10:45:59 <Quadrescence> My experience with psychotherapy: http://rafb.net/p/kI6Dpd50.html
10:46:00 <lambdabot> Title: Nopaste - No description
10:46:02 <atp> PeakerWork: that's 20 C
10:46:09 <johnnowak> 92F = 33C
10:46:18 <thoughtpolice> pozic: the parallel package comes with ghc 6.8, if you want it in ghci you can just start it up and do 'import Control.Parallel.Strategies' or you can start ghci a la 'ghci -package parallel'
10:46:29 <xif> PeakerWork: 20.
10:46:41 * atp hates cold.
10:46:47 <PeakerWork> atp: cool -- if you visit and want to catch falafel and/or beer, feel free to make contact :)
10:47:01 <atp> PeakerWork: beseder! hehe
10:47:23 <pozic> thoughtpolice: what about Control.Category?
10:47:42 <xif> atp: cold is awesome. CA is better than Israel in that regard, but Canada may be even better ;)
10:47:53 <atp> PeakerWork: i was actually going to go in september but it was just too expensive
10:47:57 <xif> Alaska is even harsher than (at least southern) Canada, iirc.
10:48:08 <atp> i'm originally from the sf bay area
10:48:13 <atp> i'm not built for this weather
10:48:17 * octal is away: 
10:48:27 <xif> atp: why did you move then?
10:48:30 <atp> xif: work
10:48:35 * xif nods
10:48:44 <xif> at least, awesome Haskell work?
10:49:11 <atp> xif: no, unfortunately not.  quantitative finance.  and i thought i'd be able to deal with the weather better before i moved here
10:49:33 <atp> xif: i probably would have been one of you shmucks saying "i wish i were in alaska, 92F is tooo hot" a year and a half ago :)
10:49:40 <atp> now i know better ugh
10:49:43 <xif> atp: hehe
10:50:05 <atp> xif: where in socal?  i was born in whittier
10:50:07 <PeakerWork> atp: the flight was too expensive?
10:50:17 <atp> PeakerWork: yeah!  it was almost 2000 dollars
10:50:17 <xif> atp: LA. I'm originally from Israel as well, so SoCal was a big improvement (a bit cooler, and _much_ less humidity and more breezy near the coast).
10:50:40 <thoughtpolice> pozic: if any of the modules comes with the ghc distribution just do 'import <module>' in ghci and it'll be available
10:50:51 <atp> i don't know ... i like hot and humid and i have such a weakness for mediterranean food
10:51:13 <xif> atp: you might like Israel then, though I don't know of _anyone_ who likes 100% humidity
10:51:22 <xif> which is Israel in July-Sept
10:51:24 <atp> xif: isn't 100% just rain?
10:51:26 <thoughtpolice> pozic: you can do that with any package that ghc can see, but by default ghci does not just import everything so you have to
10:51:59 <atp> xif: there's this restaurant here in anchorage that was opened by some arab-israelis and i swear i go there once a week
10:52:02 <xif> atp: uhm, I'm no expert, it might be 90% or so. it's the worst possibly humidity you can imagine, in any case :)
10:52:14 <atp> xif: i used to live in beijing, i'm sure i can handle it :)
10:52:41 <xif> Humus here in LA is mostly terrible... even in "Mediterranean" restaurants
10:53:00 <atp> xif: yeah... my stepdad always makes his own
10:53:07 <atp> xif: luckily it doesn't seem to be that hard to make
10:53:14 <atp> xif: also, olives are not as good
10:53:14 <xif> atp: how bad is Alaska, really?  I mean, can't you go out for most of the year or something?
10:53:35 <atp> xif: alaska is about 1/3 the size of the contiguous US, so it's really really big and how bad varies accordingly
10:53:44 <xif> (it's not, it's curious how those restaurants manage to screw it up so bad)
10:53:46 <atp> xif: where i'm at it's actually not too bad (anchorage)
10:54:01 <vixey> :S
10:54:10 <atp> xif: this summer has been rearly mild, with highs around 15
10:54:18 <xif> 15 F?!
10:54:20 <atp> xif: winter can be very cold though, for more than a month it was around -30 C
10:54:22 <xif> that's "mild"
10:54:25 <atp> no, i'm talking C
10:54:26 <vixey> maybe talk about weather in #haskell-blah ?
10:54:26 <xif> oh, ok.
10:54:38 <atp> vixey: sorry, were you talking about haskell?
10:55:00 <xif> kk, let's move this :)
10:57:00 <PeakerWork> xif: 100% humidity is Tel Aviv. Plenty of Israel is very dry :)
10:59:47 <tibbe> what sounds better `saitsfyMany' or `manySatisfy' or a combination of a primitive parser `satisfy' and a combinator `many' where the combination exists for performance reasons?
10:59:55 <tibbe> or some third alternative
11:00:03 * tibbe is not a native English speaker.
11:00:10 <tibbe> manyThatSatisfy
11:01:20 <roconnor> tibbe: what's the type
11:02:34 <tibbe> roconnor: (Word8 -> Bool) -> Parser ByteString
11:03:12 <vixey> tibbe: it seems to be spanning
11:03:52 <tibbe> vixey: is there such a combinator already in one of the parser libraries?
11:04:10 <vixey> no I don't think so
11:04:41 <vixey> it's a little bit like, span though
11:04:41 <vixey> :t span
11:04:42 <roconnor> manySatisfying ?
11:04:42 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
11:04:58 <vixey> if you think of a parser as [a] -> ([a], [a])
11:05:47 <tibbe> roconnor: I though about manySatisfying but should the simple one be named satisfying rather than satisfy then? I feel current APIs are a little inconsistent in that they sometimes have imperative sounding names and sometimes not
11:06:41 <tibbe> I think I would like my names to sound "functional" (e.g. sorted vs sort) as my interface is based on Applicative and Alternative
11:06:49 <tibbe> vixey: interesting thought
11:21:00 <pozic> How can I have TEST.Cool,  TEST.A.B and load TEST.Cool from TEST.A.B without specifying the path, since it is completely obvious where TEST.Cool can be found given the location of TEST.A.B?
11:22:09 <zachk> why not just put them all in one directory
11:22:47 <pozic> zachk: tell that to the persons who thought of the ".-extension" for module names.
11:23:07 <zachk> >?
11:28:33 <pozic> The only solution is to write a cabal file. Can I generate these files somehow?
11:28:51 <dcoutts> pozic: they're designed to be written by humans
11:29:23 <pozic> dcoutts: do you know a work around for the above problem?
11:29:31 <pozic> dcoutts: again, without specifying paths.
11:30:01 <dcoutts> pozic: sure, just use the right names and they'll be found
11:30:25 <dcoutts> TEST/Cool.hs TEST/A/B.hs
11:30:31 <Baughn> pozic: If writing a cabal file would fix it, by all means do so. Cabal is handy.
11:30:53 <pozic> dcoutts: yes, and I wanted to load Test/Cool.hs from Test/A/B.hs
11:30:55 <pozic> dcoutts: that
11:30:55 <Baughn> pozic: Although, you might try ghc --make
11:30:55 <dcoutts> pozic: then use ghci TEST/Cool.hs and it'll find the import of TEST.A.B no problem.
11:31:14 <JakeP> i want to run haskell code on an embedded system (no OS) that is already supported by GCC. if i ported the rts from ghc, and made ghc cross-compile to the other architecture, would that be enough?
11:31:35 <dcoutts> pozic: you have to be in the ./ directory not ./Test/
11:31:42 <JakeP> (excluding the part of ghc that optimizes tail-recursion and junk by modifying the assembly code)
11:31:50 <dons> JakeP: hmm.
11:31:59 <dons> JakeP: you can certainly port the runtime to run without an OS
11:32:11 <dons> and then have it load haskell objects that were cross compiled
11:32:13 <dcoutts> JakeP: though ghc is not set up from cross-compiling
11:32:20 <dons> its non trivial though
11:32:20 <dcoutts> form/for
11:32:22 <Baughn> JakeP: Of course, that would imply implementing parts of the OS - but not the whole thing
11:32:36 <Baughn> JakeP: Does the controller have an MMU?
11:32:41 <dons> we need to get the haskell on bare metal code released..
11:33:01 <JakeP> hm, ok. it is more of a thought experiment at the moment, trying to get an idea of the difficulty
11:33:02 <JakeP> no it doesnt
11:33:08 <dcoutts> pozic: got it working?
11:33:11 <JakeP> (avr atmega8)
11:33:34 <pozic> dcoutts: no
11:33:50 <pozic> dcoutts: the problem is loading a module higher up in the hierarchy.
11:34:12 <dcoutts> pozic: you must launch ghci from the root of your build tree, not a subdir
11:34:27 <dcoutts> pozic: ghc maps module names to file names like A.B.C  -->  A/B/C.hs
11:34:53 <Baughn> JakeP: Okay. I can't find any evidence that ghc actually /requires/ an MMU, but most GCed languages seem to.. ymmv
11:35:45 <dcoutts> pozic: so if you follow that module naming convention and launch ghci / ghc --make from the root of your build tree then it can find all modules and you do not need to specify any search paths
11:35:47 <pozic> dcoutts: when I have TEST in ~, and run it from ~, it works.
11:36:14 <pozic> dcoutts: but... then the problem is that Emacs doesn't load the right file then.
11:36:22 <Baughn> JakeP: Wait a minute, how much memory does it have?
11:36:28 <dcoutts> pozic: I've no idea about emacs
11:36:29 <JakeP> Baughn, oh, yea, good point, i forgot about gc
11:36:33 <JakeP> haha, in the kb
11:36:45 * JakeP is stupid :P
11:36:50 <dcoutts> pozic: but other emacs users manage to make it work, so perhaps ask an emacs user
11:36:55 <pozic> dcoutts: how do you load load modules then?
11:37:02 <pozic> dcoutts: just ghci in vim?
11:37:05 <dcoutts> pozic: I use ghci from the command line
11:37:13 <dcoutts> or cabal or ghc --make
11:37:17 <Baughn> JakeP: I sure wouldn't want to run haskell on a /kilobyte/ of memory. If you don't want to be stuck with C, may I suggest forth?
11:37:56 <JakeP> mmm, c is fine, im just having a haskell obsession since i started a week ago :P
11:38:46 <Zao> JakeP: Quite common, that.
11:40:12 <JakeP> haskell reminds of scheme, but i can actually use it for stuff (ive used scheme a lot)
11:40:32 <vixey> haha
11:40:41 <vixey> You can't use scheme for real programs?
11:41:03 <JakeP> meh, i don't like it... i never liked set! and all the io stuff
11:41:07 <xif> vixey: everyone knows Real Programs are written in C.
11:41:32 <vixey> oh right if you restrict yourself to the pure fragment of R5RS.. I'm not so surprised anymore
11:41:54 <JakeP> yea :(
11:42:27 <Baughn> JakeP: I bet you don't restrict yourself to pure haskell'98, though. ;)
11:42:42 <xif> but seriously for a second, is Haskell in any way more useful than Scheme?
11:42:46 <Baughn> There are some advantages to having a language that's /effectively/ defined by an implementation
11:42:53 <JakeP> nah, but i sleep easier with the whole monad thing helps me sleep better
11:43:04 <Baughn> xif: Uh. Yeah.. there's really no comparison
11:43:19 <xif> Baughn: interesting, why is that?
11:43:23 <JakeP> er, redundant sentance..
11:43:32 * xif never did anything practical with either yet
11:43:35 <vixey> xif, On that note, Prolog's only good for toy search problems
11:43:37 <dons> xif, go to hackage.haskell.org, look at the range of libraries and programs being written. clearly people are getting things done.
11:44:16 <dons> to write something useful, pick two libraries, and glue them together.
11:44:17 <chessguy> @get-slap
11:44:17 <lambdabot> shapr!!
11:44:18 <Baughn> xif: More useful standard library, larger selection of basic paradigms..
11:44:35 <chessguy> @seen shapr
11:44:36 <lambdabot> I saw shapr leaving #haskell-blah and #haskell 4h 48m 30s ago, and .
11:44:43 <dons> multicore concurrency that works. data structures of interest.
11:44:50 <Baughn> Laziness is an enormous win. So is purity. Neither would work without the other
11:44:59 <JakeP> it is compiled, which is great
11:45:05 <vixey> Baughn: more paradaigms in haskell than scheme?
11:45:12 <Baughn> JakeP: That's "it has a compiler"
11:45:23 <JakeP> ok, true
11:45:39 <xif> dons, Baughn: interesting, I didn't know Haskell had more libraries than Scheme, being that Scheme is much older
11:45:41 <Baughn> vixey: Sure, I'd say so. Monadic DSLs, laziness, stream io..
11:45:57 <vixey> Baughn: You can do any of that in Scheme ...
11:45:59 <xif> but sure, if it does, it goes a long way towards making it more practical.
11:46:04 <Baughn> vixey: Of course scheme's syntax works better for macros than template haskell
11:46:05 <JakeP> haskell has the ffi, it can mesh with C libraries... havent used it yet
11:46:11 <Baughn> vixey: Yes, but /it's not part of the standard library/
11:46:13 <vixey> Baughn: The only problem with Scheme is you have to understand it *before* you do it
11:46:21 <JakeP> scheme/r5rs probably has soemthing similar though.
11:46:22 <dons> the FFI is a driver of new code, and a key way to mitigate risk
11:46:25 <Baughn> vixey: And if you /did/ do it in scheme, performance would go through the floor
11:46:31 <Baughn> JakeP: Isn't it r6rs by now?
11:46:44 <vixey> Baughn: not at all, just write a compiler
11:46:53 <Baughn> vixey: Laziness does need compiler support, yes
11:46:57 <JakeP> er, yea, that sounds right
11:47:20 <Baughn> vixey: Once you say /that/, you might as well call all languages equivalent. ;)
11:47:31 <Baughn> The advantage of haskell is that you don't have to write your own compiler to use it
11:47:58 <vixey> Most programs are compilers
11:48:24 <Baughn> Not in the "write a good strictness analyzer" sense
11:48:59 <vixey> why would you want a strictness analyzer when you could just write stict code in the first place?
11:49:07 <JakeP> with the non-strict typing in scheme, i'd imagine it would be impossible for a compiled scheme to ever be as fast as haskell
11:49:37 <dons> they've ad hoc static declarations, these days, no?
11:49:52 <dons> but in general, there's a range of type based transformations that will be inaccessible
11:49:52 <Baughn> JakeP: I figure it'd be as fast as haskell on harddware designed to run scheme, if nothing else
11:50:05 <Baughn> JakeP: See how fast C is on modern chips for an example of /that/. ;)
11:50:09 <vixey> regardless of types, I think there's just so many more optimizations you can do on haskell code, isn't there?
11:50:21 <JakeP> yea, the lisp machines, but they are hard to come by now :P
11:50:31 <Baughn> Purity buys you a lot. Laziness costs you CSE, but I don't think that's a major loss.
11:51:02 <Baughn> I mean, you're supposed to avoid code duplication, aren't you?
11:51:02 <PeakerWork> Baughn: CSE?
11:51:18 <dons> laziness is useful for data structures. trees et al, tend to have nicer characterisitics when spine lazy
11:51:22 <Baughn> PeakerWork: Common subexpression elimination. Not quite always a product of copy-and-paste coding.
11:52:40 <shepheb> how would I use Parsec to parse expressions where juxtaposition is application, as in Haskell? it seems to go into an infinite loop, which makes me suspect it's left-recursive as written
11:52:45 <PeakerWork> Baughn: what do you mean by that? You can still do CSE with laziness?
11:53:06 <vixey> shepheb: chainl1
11:53:13 <Baughn> PeakerWork: No. Consider this expression:
11:53:24 <vixey> shepheb: I've got an example if you like
11:53:41 <shepheb> vixey: please, yes
11:53:43 <Baughn> PeakerWork: let x = expensive foo; y = expensive foo; dostuff with x; return y
11:54:02 <vixey> shepheb: http://rascal-haskell.googlecode.com/svn/trunk/Parse.hs parses http://rascal-haskell.googlecode.com/svn/trunk/examples.hx
11:54:05 <Baughn> PeakerWork: No, with CSE that would become something like "let #1 = expensive foo; x = #1; y = #1 in...
11:54:25 <vixey> term = chainl1 term' .. is the relevant bit
11:54:45 <Baughn> PeakerWork: The /problem/ is that, due to laziness, the programmer would assume that the memory cost of creating x/y is not paid until it is actually used
11:55:12 <byorgey> vixey: oh, is rascal-haskell yours?
11:55:22 <PeakerWork> Baughn: memory use becomes max(use of x, use of y) ?
11:55:27 <Baughn> PeakerWork: Here, they'd assume it created x, throws it away, and then at some later point creates y. With CSE, it'll spend memory sstoring y between the uses, possibly for weeks.
11:55:32 <vixey> byorgey, yes
11:55:37 <byorgey> my automated google search found it but I didn't know who had made it =)
11:55:42 <byorgey> vixey, cool
11:55:50 <shepheb> vixey: I see, thanks much
11:55:54 <vixey> automated google search?!
11:57:29 <PeakerWork> Baughn: that's indeed a problem. I think runtime profiling, statistics about frequency of access, size of memory objects and scarcity of resources should be used to decide what to keep and what to throw away
11:57:37 <Baughn> Actually, it can get worse. Consider "let x = fibonaccis () !! 2000; y = fibonaccis () !! 0 in ..."; this one is somewhat contrived, but assume passing in the () makes the otherwise global fibonacci llist get regenerated each time
11:57:44 <PeakerWork> Baughn: that could be much better than arbitrary pre-compile-time decisions by the programmer
11:57:54 <JakeP> vixey, direct neural interface most likely
11:58:08 <vixey> heh
11:58:33 <Baughn> PeakerWork: But with CSE, there, the program's maximum memory use /increases/. Dramatically.
11:58:41 <PeakerWork> Baughn: I know that GHC is pretty conservative in what it's willing to reuse (basically lets you control its behavior with "let"s) -- and with the runtime profiling thing, it could aggressively do CSE smartly
11:59:05 <Baughn> PeakerWork: Yes, runtime optimization is the holy grail. ;)
11:59:09 <Baughn> Feel free to implement it. :P
11:59:12 <PeakerWork> Baughn: Laziness and purity means that the runtime environment has enough information to actually make informed choices about what to keep and what to throw away
11:59:48 <PeakerWork> It knows exactly who can access it, at what frequency it actually accesses it, how much it costs to keep it in memory, etc
12:01:03 <olsner> Baughn: implement llvmCodeGen >>= undefined >>= profit :P
12:01:24 <PeakerWork> Baughn: this kind of optimization is probably not possible without purity.  I think perhaps people's biases and ideas are influenced by pre-purity ideas :)
12:03:35 <PeakerWork> Need to have the compiler help the GC see more information (each GC sweep should also know how many times it was accessed. Perhaps hints about future access times), then using some arbitrary memory VS cpu-time value (which can be affected by OS information about their scarcity), it can choose whether to waste bytes (keep stuff in memory) or CPU cycles (throw them for later regeneration)
12:04:34 <PeakerWork> Each (non-tiny) value in memory should be associated with the amount of time it took to compute it for this, too
12:05:03 <byorgey> vixey: yes, every morning when I wake up, Jane, er, Google informs me of the latest Haskell-related goings-on on the interwebs
12:05:17 <vixey> hehe
12:05:18 <Baughn> PeakerWork: I see overhead in your future.
12:05:49 <byorgey> seriously though, it's so I can put blog posts about Haskell in the HWN even if they're not syndicated on Planet Haskell
12:05:52 <olsner> hmm, was that an Ender's Game reference?
12:06:05 <PeakerWork> Baughn: the overhead can be lower-bounded by an extra bit of space, and an extra bit check for access or so.  Thus you can pay the real overheads only when its worth it..
12:06:09 <byorgey> olsner: well spotted =)
12:06:38 * olsner wants a Jane too
12:13:34 --- mode: irc.freenode.net set +o ChanServ
12:13:43 <Quadrescence> ay!
12:13:56 <dons> here's   an idea,
12:13:56 <dons>   http://anarchogeek.com/2008/7/20/does-genuine-tech-innovation-happen-better-in-a-recession
12:13:56 <lambdabot> Title: Anarchogeek: Does genuine tech innovation happen better in a recession?, http://tinyurl.com/68v58o
12:13:56 <chrisdone> “factory workers on strike for arrows”
12:13:56 <dons> is about how people invest time in non-core technology ideas during a recession.
12:13:56 <dons> maybe these less-than-fully-employed hackers will be taking time to learn haskell/FP
12:14:11 <dons> like a new generation of part-time PhD students, underemployed geeks can help drive haskell
12:14:35 <jethr0> http://hpaste.org/9057
12:14:50 <jethr0> could somebody give me a hint about the functinal dependency in the paste?
12:15:06 <dons> a hint?
12:15:17 <jethr0> what is the significance of the order "e m" or "m e", and why don't i need "(Monad m) =>"
12:15:20 <PeakerWork> dons: During economic lows, seed money is more expensive, firms that are founded during those periods are generally much more successfully than in economic good times
12:15:54 <dons> PeakerWork: as they had to already survive getting seed funding in a skeptical climate.
12:16:00 <PeakerWork> jethr0: in the type "a b" a is a type constructor and b is a type argument -- that's not symmetrical
12:16:16 <dons> so i wonder about people spending their underutilised time looking at new tech, like haskell.
12:16:19 <jethr0> i would contend whether seed money is more expensive. investors still have their money and are maybe less likely to invest it in the general stock market, and more likely to go to VCs
12:16:21 <dons> and how we could encourage that investment.
12:16:30 <olsner> hmm, so the geeky stuff will be played around with during the regression, and in the upswing following it, will be used to build all the new stuff ... makes sense
12:17:00 <dons> this is what happens during a phd , basically. you have a lot of free time when you're not writing papers to think and hack.
12:17:10 <dons> and then you get to use that to build new stuff once you finish.
12:17:18 * dons found that anyway
12:17:28 <PeakerWork> jethr0: oh I misunderstood your question
12:17:36 <jethr0> according to taleb (author of 'the black swan'), venture capital investment is more robust during crashes and downturns
12:17:37 <PeakerWork> jethr0: in the class, I don't think the type arg order matters, it just has to be consistent
12:17:40 <dons> so, if we have idle hackers leaving places like yahoo or amazon, can we get them to spend a bit of time tooling up haskell libs.
12:17:43 * ndmitchell agrees with dons
12:18:14 <PeakerWork> jethr0: I don't know why (Monad m)=>  is missing there. I think maybe its not mandatory (but IMO maybe a good idea to mention anyhow)
12:18:24 <dons> ndmitchell: coming over for ICFP?
12:18:38 <olsner> I believe there's an upswing of academics during recessions, like people getting fired and going to school or getting a PhD when they can't get work
12:18:51 <jethr0> PeakerWork: so, when i write "class MonadReader e m" and "instance Monadreader (Reader e)", what does the "(Reader e)" bind to?
12:18:53 <PeakerWork> jethr0: as for the fundeps, the one is "m -> e", specifying that you cannot have two instances that have the same "m" argument and differing "e" arguments
12:19:11 <ndmitchell> dons: no, will be working
12:19:14 <PeakerWork> jethr0: your instance is missing an argument -- it would bind to e but you still need to bind the m
12:19:33 <dons> ndmitchell: btw, how complicated is tagsoup's parser? is it just lexing?
12:19:46 <dons> ndmitchell: and if so, could i roll an equivalent in alex, for lexing bytestrings
12:19:46 <jethr0> yes, that's what i wanted to ask next. how could i solve this?
12:20:09 <ndmitchell> dons: more complicated than that, but not by a huge amount
12:20:11 <jethr0> the example is from "all about the monads", and i just don't seem to find a solution to make it compile/type check
12:20:20 <ndmitchell> dons: i have a todo to roll a bytestring version, it will be in teh next release
12:20:54 <ndmitchell> dons: rewriting the lexer in alex may be an option, will have to think...
12:21:15 <PeakerWork> jethr0: you could give the instance its env type as well as the reader monad type
12:21:39 * jethr0 was wondering if it could be possible to parallelize standard lists. do you think splitting the list into even and odd elements and then executing those sublists on different processors might be a possibility?
12:21:58 <olsner> do alex and happy parse bytestrings now?
12:22:13 <dons> ndmitchell: well, i hacked alex to support lexing from strict bytestrings now
12:22:17 <dons> olsner: yeah.
12:22:19 <PeakerWork> jethr0: It could be a little easier with an array, but its certainly possible
12:22:21 <jethr0> PeakerWork: sorry to be a bit daft. so you were saying that the "e" currently binds to "(Reader e)" and the "m" is currently unbound?
12:22:21 <dons> strict and lazy ones.
12:22:32 <dons> the csv lexer i uploaded yesterday uses alex.
12:22:37 <olsner> cool
12:22:46 <dons> to lex straight from strict bytestrings. cheaper and as good as doing it by hand.
12:22:50 <PeakerWork> jethr0: I don't think (Reader e) is the env, I think its the "m", I think you may have deleted the first argument, and not the latter argument?
12:23:08 <ndmitchell> dons: http://code.google.com/p/ndmitchell/issues/detail?id=28 and http://code.google.com/p/ndmitchell/issues/detail?id=29, i've got them noted down
12:23:09 <lambdabot> Title: Issue 28 - ndmitchell - Google Code
12:23:10 <olsner> how does alex/happy compare to bytestring-parsec?
12:23:15 <jethr0> yes, i agree. maybe i miscopied, but as far as i could see it's the exact code from "all about monads"
12:23:16 <jethr0> i'll try that
12:23:17 <PeakerWork> dons: supports all the csv nuances, escaping, etc?
12:23:33 <ndmitchell> dons: and if you want to hack it in, patches welcome :)
12:23:34 <PeakerWork> jethr0: I suppose "e" here is the same "e" given to (Reader e)
12:23:35 <jethr0> so you'd say "instance MonadReader e (Reader e)"?
12:23:39 <dons> PeakerWork: not yet.
12:23:42 <PeakerWork> jethr0: Sounds good
12:23:48 <jethr0> i'll try that, thx
12:23:50 <dons> PeakerWork: enough to parse csv files generated by excel
12:24:28 <jethr0> and then i'll try my even/odd list splitting for parallelization. would be nice to have automatic parallelization for list monad, etc.
12:24:51 <jethr0> how high would you say the overhead would be to execute every list member parallely in lack of knowledge of the exact number of processors?
12:25:09 <dons> jethr0: there are list parallel strategies in Control.Parallel
12:25:24 <dons> and you can ge the exact number of processors from the capabilities variable
12:25:27 <jethr0> dons: but weren't they based on vectors/arrays or some such?
12:25:30 <dons> so no need to guess!
12:25:32 <dons> nope. lists.
12:25:36 <jethr0> oh
12:25:43 <jethr0> i thought they were special, non-infinite lists
12:25:48 <dons> numCapabilities -- :: Int
12:25:56 <dons> tells you the number of cores.
12:25:56 <jethr0> cool, thx
12:26:50 <PeakerWork> dons: even when those have commas, strings, strings with " in them, etc?
12:27:39 <jethr0> dons, if it is so unproblematic, why aren't list functions (filter, map, ...) and list monad in general not automatically paralellized?
12:28:00 <ndm> jethr0: its not always the right thing to do
12:28:20 <jethr0> ndm: you mean for caching/sharing purposes?
12:28:30 <dons> PeakerWork: it just follows the unnested part of the CVS RFC.
12:28:37 <dons> adding support for nesting is further work.
12:28:46 <dons> jethr0: the ones in Control.Parallel are the auto-parallel verrsions
12:29:08 <ndm> jethr0: i mean for parallel purposes
12:29:08 <jethr0> k
12:29:28 <jethr0> ;)
12:30:16 <jethr0> ndm: i meant, when would you not want to have the opportunity to parallelize list operations? what i don't know is the overhead for cache misses, state sharing, etc.
12:30:53 <ndm> jethr0: i think it would rarely be the right choice, just a gut feeling though
12:31:12 <jethr0> k
12:31:42 <jethr0> ndm: without considering overhead i don't agree, but then that is probably a stupid assumption
12:33:01 <ndm> jethr0: you may be right, but you'd need evidence to back you up - and there is spark overhead, from starting and running a thread
12:36:57 <tibbe_> dons: I've been thinking a lot about streams lately and there's something that bothers me. It seems like that if we want to use streams to efficiently process large amounts of data we must always resort to lazy I/O. How else could you create a large stream? I think I'm now convinced that folds and/or primitive C like functions like read are the way to go for all I/O interfaces. Any thoughts? It seems like all examples of high performance I/O code we show peop
12:37:26 <dons> well, lazy bytestrings also work nicely.
12:37:32 <dons> you just don't want to suspend too often
12:39:50 <tibbe_> dons: but you need to create the using lazy I/O too no?
12:40:16 <dons> right. it would be interesting to see a general left-fold based IO suite.
12:40:23 <tibbe_> yes
12:40:29 <dons> we've fine grained lazy IO, coarse grained lazy IO, and strict IO currently
12:40:33 <tibbe_> but I feel like I'm the only one sometimes :/
12:40:52 <ndm> what is wrong with lazy IO?
12:40:53 <dons> oleg's giving a tutorial on left-fold based web apps at DEFUN
12:41:00 <dons> tibbe: so you're not the only one :)
12:41:04 <tibbe> ndm: what's wrong with arbitrary side effects?
12:41:13 <dons> but you've probably got to put a library on hackage to get any traction
12:41:15 <ndm> tibbe: they harm reasoning
12:41:20 <tibbe> dons: yeah, I've been chatting quite a lot with Oleg lately
12:41:27 <ndm> and reasoning about correctness
12:41:42 <dons> lazy io is a bit awkward in long running apps that need some resource guarantees.
12:41:43 <ndm> but lazy IO does not have that issue
12:41:53 <dons> we tend to be very very careful with lazy IO in our systems at galois.
12:42:05 <olsner> dons: hmm, that sounds interesting but what does it mean for a web app to be "left-fold based"? :P
12:42:13 <ndm> true, i guess Haskell is still more set up for one-shot programs
12:42:20 <dons> olsner: just  the way data is consumed.
12:42:34 <dons> ndm, yeah, there's a bias towards one-shot transformations
12:42:43 <tibbe> ndm: there you go, therefore we should not use lazy I/O! the corresponding resource allocations and side effects are observable and we can't handle errors properly. I've been trying to write a web server lately and been painfully made aware of how much Haskell code assumes lazy I/O.
12:42:46 <dons> stateful, interactive systems usually need more boilerplate and care.
12:43:10 <dons> right, something like a web server is *not* a one-shot system. so lazy IO is inappropriate.
12:43:11 <thetallguy> it niggles at me that the memory management is not suited for long running programs, either
12:43:19 <dons> thetallguy: oh?
12:43:26 <tibbe> dons: from were I'm sitting it seems that most Haskell libraries depend on the caller using lazy I/O for larger inputs
12:43:38 <thetallguy> as I understand it, the memory never shrinks
12:43:42 <dons> that's not something i'd have though of (being responsible for some of the longer running haskell apps out there).
12:43:45 <ndm> ok, i agree - lazy IO is great for one-shot and sucks for long running
12:44:01 <dons> thetallguy: hmm. is that true? ghc does release allocated memory back to the OS now.
12:44:05 <PeakerWork> galois.com is so poor on information. Does it primarily do classified projects?
12:44:06 <thetallguy> so if you write a little server that handles a big chunk of data every once in a while
12:44:13 <olsner> hmm, so is that something like having the program be a left fold over a list of commands producing results rather than a program performing I/O?
12:44:16 <dons> PeakerWork: you're looking at the new website?
12:44:22 <tibbe> dons: my problem is that I can't use most libraries that pop up since they take a "pure" stream as input
12:44:36 <thetallguy> dons: if that's true, then that's good.  I remember SimonM saying it was still sticky at ICFP last year
12:45:08 <dons> PeakerWork: note we have a blog now, so galois is becoming less of a black box.
12:45:17 <dons> thetallguy: let me find the ticket.
12:45:41 <jethr0> i once wrote a server for the robber-and-police ICFP contest post-mortem with lazy IO. after some time it would always break in the lazy IO input, and was impossible at the time for me to diagnose/debug
12:45:44 <thetallguy> it's not too much of a problem if the OS is doing the work for you
12:45:47 <PeakerWork> dons: was there generally little information so far because there's no reason to dissiminate, or because it is secret?
12:45:58 <ndm> dons: a blog that is "coming soon"
12:45:58 <dons> ndm, well the site only went up on tuesday :)
12:46:13 <dons> PeakerWork: a lot of the work is classified, yes.
12:46:36 <ndm> dons: half the internet is coming soon/under construction pages that never get finished :)
12:46:40 <tibbe> dons: would you be interested in patches for a more generally useful ByteString I/O interface?
12:46:52 <thetallguy> dons: I haven't actually run into the problem yet, but I expect I will be in a position to test it soon
12:47:04 <dons> tibbe: i think it should just be a separate library
12:47:29 * dons thinks tibbe should upload more libraries :)
12:47:36 <tibbe> dons: I feel like I see a bunch of questions along the lines of "after I'm done with hGetContents I want to do XYZ" followed by a discussion on half closed handles
12:47:46 <dons> yep.
12:48:07 * tibbe tibbe is rewriting half of all Haskell libraries so they are useful in his web server so he's quite busy.
12:48:19 <Asgaroth> how do I convert a number of type Integral to a Double?
12:48:26 <dons> realToFrac
12:48:28 <dons> fromIntegral
12:48:30 <byorgey> @quote fromIntegral
12:48:30 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
12:48:33 <jethr0> control.parallel.strategies are really awesome!
12:48:35 <Asgaroth> thanks
12:48:37 <ndm> @hoogle Integral a => a -> Double
12:48:38 <lambdabot> No matches, try a more general search
12:49:00 <ndm> web based hoolge gets it
12:49:03 <byorgey> @hoogle (Integral a, Num b) => a -> b
12:49:04 <lambdabot> Prelude.fromIntegral :: (Integral a, Num b) => a -> b
12:49:04 <lambdabot> Unsafe.Coerce.unsafeCoerce :: a -> b
12:49:04 <lambdabot> Data.Generics.Aliases.unGM :: GenericM' m -> Data a => a -> m a
12:49:22 <olsner> tibbe: make sure to put it all on hackage if it works out!
12:49:23 <jethr0> tibbe: that half-closed handle issue is what i had problems with as well. and as i said, these things tend to be a real problem to debug
12:49:26 <tibbe> dons: I want a low level I/O library that closely mimics the standard C API with read, write, etc
12:49:36 <dons> tibbe: that'd be generally useful.
12:50:20 <tibbe> jethr0: now when I'm more aware of the issues I see more problems related to lazy I/O. People doing hGetContents on sockets, etc
12:50:23 <jethr0> tibbe: is that a problem to write such a library
12:50:50 <tibbe> jethr0: a basic I/O library? No except it needs to work on a bunch of different compilers and platforms
12:51:08 <jethr0> hmm, but couldn't you basically wrap the c calls via ffi?
12:51:14 <dons> how about just filling strict bytestrings via ffi C calls?
12:51:17 <bwr> @hoogle String -> Double
12:51:17 <lambdabot> No matches, try a more general search
12:51:17 <tibbe> jethr0: I'm planning to rewrite all of network in terms of byte strings but if you look at the code it's full of #ifdefs
12:51:28 <jethr0> hehe
12:51:29 <tibbe> dons: ^^
12:51:34 <ndm> bwr: read
12:51:42 <olsner> jethr0: yes, but *which* c calls? they differ between platforms :P
12:51:50 <bwr> ndm: thanks.. i didn't know it worked for doubles as well
12:52:07 <ndm> bwr: works for most things :) - the web based hoogle would have got that too
12:52:11 <matthew-_> tibbe: I did hGetContents on the socket in the ICFP contest this year. I never had a problem there. So long as your parser is lazy (use polyparse, not parsec), it seems fine. What issues do you come across?
12:52:23 <jethr0> hmm, but wouldn't you have pretty similar read, write, seek, open, close, ... calls across platforms? but i see the problem
12:52:35 <tibbe> getting the wrappers correct for all platforms is kinda tricky. it would be feasible if someone except me thought we currently had a problem. I can't find the motivation to rewrite it all myself
12:52:36 <aBeing> If I have a function of type Maybe Choice -> Choice, how can I do proper pattern-matching on that?  I'm getting an error trying to match type Choice against inferred type Maybe Choice?
12:53:00 <dons> case mb of Nothing -> error "whoa" ; Just s -> s
12:53:14 <jethr0> tibbe: how many primitives are we talking about? wouldn't it be just 20 calls across 4 major platforms?
12:53:16 <dons> aBeing: you'll have to think about what Nothing means here
12:53:30 * olsner figures he knows more than he wants to about cross-platform I/O
12:53:30 <tibbe> matthew-_: the problem is generally that it is brittle. what if your socket throws an exception. what if you want many connections and the GC doesn't collect your handles, what if you want to interleave some locking or HTTP connections to backend servers, etc.
12:53:42 <ndm> aBeing: you can do fromJust if you always know the answer is Just
12:53:48 <jethr0> aBeing: could you paste your code?
12:53:49 <jethr0> @hpaste
12:53:49 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:53:50 <tibbe> jethr0: something like 20 sounds about right
12:53:57 <aBeing> @hpaste
12:53:57 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:54:07 <dons> matthew-_: thinking of resubmitting the sessions paper to PADL?
12:54:17 <matthew-_> tibbe: yep, ok. The error situation is horrible, certainly
12:54:25 <tibbe> al right, I'm conviced
12:54:32 <matthew-_> dons: thinking more about quitting the PhD tbh
12:54:38 <dons> :(
12:54:40 * tibbe creates a nio directory in ~/src. New I/O ftw!
12:54:42 <ndm> matthew-_: :(
12:54:42 <jethr0> tibbe: maybe i could help you with this, depending on how much work i'll have next week (probably a lot).
12:55:00 <tibbe> jethr0: that would be cool
12:55:01 <ndm> matthew-_: if it makes you feel any better, i think most people feel that way at some point - if not nearly all
12:55:02 <dons> at least put the paper aside for a week or two, and hack something fun.
12:55:04 <jethr0> tibbe: what exactly would you be using it for? long-running, strict data consumption in servers?
12:55:08 <tibbe> jethr0: I'll set up a repository on github
12:55:14 <ndm> (my girlfriend assures me i'm the exception in enjoying mine)
12:55:34 <bwr> so ndm, i can use "map read . words <$> getLine" to get a line of Int... but if i do Double this doesn't work because it seems i need to do 'read "12.1" :: Double' to get it to work
12:55:53 <tibbe> jethr0: I work at Google. I want to write server side software and currently that is quite painful in Haskell
12:55:57 <jethr0> tibbe: i'm not promising anything, but naively it doesn't sound like that much work.
12:55:58 <dons> matthew-_: another idea might be to try to chase up collaboration partners.
12:56:04 <matthew-_> dons, ndm: the problem is that the "perfect" system, with which everyone would be happy, basically can never exist.
12:56:05 <dons> this works well for guys like oleg and conal.
12:56:12 <tibbe> jethr0: sure, we're all doing this in our spare time :)
12:56:15 <ndm> bwr: if you use it as a Double, it will be a double
12:56:20 <dons> matthew-_: yeah, its all incremental steps.
12:56:24 <bwr> i get an error
12:56:32 <bwr> when running it in ghci
12:56:35 <ndm> matthew-_: you can always submit somewhere like IFL or TFP, post-refereed
12:56:41 <ndm> bwr: expression?
12:56:50 <bwr> map read . words <$> getLine
12:56:51 <dons> matthew-_: fwiw, its probably a good time to stick at the phd , given the economic downturn.
12:56:56 <bwr> and then i type in some doubles
12:57:00 <bwr> seperated by spaces
12:57:09 <matthew-_> dons: game industry is booming
12:57:22 <ndm> bwr: GHCi defaults things to Integer, in teh absence of a note telling it to default to Double
12:57:28 <bwr> ah
12:57:31 <ndm> matthew-_: how far through are you?
12:57:42 <matthew-_> ndm: about to start 3rd year
12:57:59 <dons> is your advisor much help with getting things published?
12:58:20 <ndm> matthew-_: thats plenty of time to do loads of things exciting, i only got to Uniplate and Supero in my 3rd year
12:58:47 <dons> honestly, i think there's a lot of potential here, and lots of applications, so i'd stick with it. hunt for more collaboration opportunties, more practical applications
12:58:48 <ndm> but if you are going to quit, wait a month, and if you still want to you should - i've had a few friends quit at the end of their 4th year, which is a bigger waste
12:58:58 <olsner> hmm, ubuntu has gtk2hs-doc but not gtk2hs?
12:59:38 <dons> matthew-_: and diversify. have several projects on the go, some of them bubble up into great papers and apps.
12:59:53 * Elly is contemplating going to grad school
12:59:59 <dons> ndm, dcoutts and I were all of that model. lots of (too many?) projects on the go. keeps life interesting :)
13:00:31 <thoughtpolice> tibbe: since you seem to be pretty into the subject, what's the problem with lazy i/o in general? (i'm not quite following the discussion and if you could outline it that would be neat.)
13:00:49 <aBeing> For those that were trying to help me, I've pasted a snippet at http://hpaste.org/9058
13:00:55 <dons> thoughtpolice: for some apps, lack of precision of finalisation and error handling
13:01:07 <Elly> I guess I have another year and change to decide whether I want to go to grad school
13:01:09 <Asgaroth> If I'm searching with hoogle for some types like "Char -> Integer", I get tons of results without these types at all. How do I run a search for exactly this type?
13:01:19 <ndm> aBeing: http://hpaste.org/9058#a1
13:01:27 <tibbe> dons: not to mention the problems with side effects in general?
13:01:29 <dons> Asgaroth: fromIntegral . ord
13:01:30 <ndm> Asgaroth: you can't
13:01:32 <Deewiant> Asgaroth: it should return matching results at the top
13:01:48 <dons> tibbe: well, that's something less of a problem in my experience.
13:01:49 <Asgaroth> Deewiant: Ah, thanks
13:01:52 <Deewiant> and less exactly matching ones further down
13:02:04 <tibbe> thoughtpolice: read the intro here: http://okmij.org/ftp/papers/LL3-collections-enumerators.txt
13:02:04 <thoughtpolice> dons: example? like if you are getting input lazily from a handle and something happens, can the GC not recollect the handle?
13:02:05 <byorgey> Elly: are you currently an undergrad?
13:02:11 <thoughtpolice> tibbe: thanks
13:02:12 <ndm> the problem in this case is you want Char -> Int, and could never know that
13:02:15 <Deewiant> with some weirder types it doesn't but I suppose that's a bug. :-)
13:02:30 <tibbe> dons: I think we see fewer problems because most people are still writing script like programs
13:02:34 <ndm> Hoogle 4 will know that Int/Integer are virtually the same, and will give you ord first
13:02:39 <matthew-_> ndm, dons: many thanks for your advice and input
13:02:47 <Elly> byorgey: yep; about to be a junior
13:02:57 <ndm> matthew-_: are you presenting this stuff at AngloHaskell?
13:03:09 <tibbe> dons: also the efficiency bar has only recently been raised
13:03:09 <Asgaroth> dons: that type was just an example
13:03:14 <matthew-_> ndm: nah, I was going to talk about something slightly simpler
13:03:15 <ndm> conferences like AngloHaskell are perfect places to gain new enthusiasum
13:03:18 <dons> thoughtpolice: no, of course it can still collect it. just that its imprecise when that happens.
13:03:23 <dons> tibbe: yeah, true.
13:03:27 <ndm> matthew-_: same sort of stuff?
13:03:31 <dons> the high perf systems i've worked on all need explicit control
13:04:10 <tibbe> dons: typical example, I want to create an HTTP response for the first 1/3 of the web page I'm rendering at the same time as I ask my backend servers to do some processing. I find putting such side-effects in a pure structure to be tricky to say the least
13:04:14 <dons> we need peple to build more and new kinds of apps.
13:04:15 <matthew-_> ndm: in the sense that it's doing slightly crazy type level computation, yes
13:04:19 <dons> in general, to push things further.
13:04:21 <byorgey> Elly: cool
13:04:22 <matthew-_> ndm: but not concurrency related
13:04:58 <byorgey> Elly: personally I recommend not going to grad school straight out of undergrad
13:05:00 <newsham> "C# exposes more than 10 integer-like data types, none of which are those defined by (Pythagoras, 500BC)"
13:05:00 <matthew-_> ndm: though Neil Brown (CHP) is coming so I guess I could change it as the concurrency and message passing thing is obviously related
13:05:02 <dons> matthew-_: you could revisit SimonM's type system for erlang :)
13:05:09 <newsham> best Integer quote ever
13:05:09 <byorgey> Elly: not that there's anything wrong with it if you really want to =)
13:05:12 <Elly> byorgey: hrm, maybe
13:05:14 <tibbe> dons: but the biggest problem for me right now isn't that people are using lazy I/O -- they can of course do whatever they want -- but that all new libraries have APIs that only works if you're willing to break referential transparency!
13:05:17 <dons> matthew-_: yeah, that's another option. work on a combined system.
13:05:29 <cjb> byorgey: on the other hand, I think people who go into industry rarely find time to take a paycut and go into grad school after that..
13:05:29 <ndm> Asgaroth: http://code.google.com/p/ndmitchell/issues/detail?id=30 - a bug report for your issue, to make sure it get fixed
13:05:30 <lambdabot> Title: Issue 30 - ndmitchell - Google Code
13:05:32 <jethr0> tibbe: does it have to be inside a pure structure? having your low-level I/O library will make it only slightly less tricky in a pure structure, won't it?
13:05:36 <dons> tibbe: are you overstating the "impurity" issues of lazy IO?
13:05:42 <byorgey> Elly: I'm about to start a PhD after four years out of undergrad, and I'm very very glad I didn't go straight away
13:05:53 <Elly> byorgey: because now you have money? :P
13:05:58 <dons> tibbe: and do you mean that they take lazy lists, which implies lazy IO, usually?
13:06:08 <newsham> cjb: perhaps thats the best argument for industry.
13:06:19 <byorgey> Elly: no, because now I know exactly what I want out of grad school and am not burned out
13:06:21 <ndm> Elly: i did PhD straight after undergrad and it was great
13:06:26 <dons> me too!
13:06:33 <byorgey> Elly: hah!  all the money went to pay for my wife's master's degree =)
13:06:35 <Elly> yeah, a lot of my older friends did that
13:06:48 <Elly> (PhD straight out of undergrad)
13:06:48 <dons> and a phd before industry makes the phd pay rates more bearable :)
13:06:57 <tibbe> jethr0: what I had in mind is e.g. sending my data through a library like zlib that expects a pure stream. the issues is that either (1) I have to use lazy I/O too which I can't or (2) I have to write another zlib wrapper. repeat for every stream based library that I use
13:06:57 <Elly> I wonder if I could get back into CMU for grad school
13:07:00 <Asgaroth> ndm: Hmm, my problem was way more stupid, I just failed to see that the results are sorted and only saw the more general stuff of the 72 lines
13:07:15 <byorgey> yeah, of course I am way overgeneralizing, I'm just saying it would have been a horrible idea for me personally to go straight into grad school
13:07:19 <ndm> plus you can just sit around and get drunk for another 4 years :)
13:07:19 <byorgey> but everyone is different
13:07:25 <ndm> Asgaroth: hehe
13:07:38 <tibbe> dons: my server crashes in less than 1 second with lazy I/O as it uses very little memory and handles 1500 reqs/sec (compare to 1024 file handles)
13:07:41 <jethr0> tibbe: and how do you propose to solve this?
13:07:50 <newsham> there is a reason people dont generally want to leave industry after they join it.
13:07:54 <dons> tibbe: ok. that's good to know. and strict IO is unacceptable?
13:08:05 <newsham> despite the freedom and possibility of 4 drunken years
13:08:12 <dons> tibbe: and its just the open filehandles that are the isuse?
13:08:20 <tibbe> jethr0: two steps: 1. A very basic, low-level I/O API to build on top of. 2. A left fold based I/O library for higher level I/O
13:08:33 <tibbe> dons: I send 1G files sometimes
13:09:12 <tibbe> dons: no, I need to do lots of things "mid stream" send HTTP requests asynchronously to backend servers (think a search backend), locking between threads, etc
13:09:55 <tibbe> dons: here lies one of the problems, the only resource that e.g. hGetContents frees is file handles (and in an unpredictable manner) but I might need to allocated arbitrary resources
13:09:58 <dons> tibbe: its the kind of thing that would be worth discussing with SionM.
13:11:02 <tibbe> dons: I guess my point is that 1. You can't have the GC trigger a new GC as soon as any user defined resource runs out (locks, etc) and 2. Generating a stream might require doing much more in terms of I/O than reading a file
13:11:54 <tibbe> dons: I'm trying to write an email about it but have given up twice. It's hard to discuss when so few people think we have a problem. Probably because few people write bigger pieces of software in Haskell
13:13:38 <dons> you might be surprised, tibbe. there's quite a few big things being written. and unless you put out the code, and talk to the experts, no progress will be made.
13:13:38 <Apocalisp> ?hoogle (a -> b) -> a -> (a, b)
13:13:45 <lambdabot> No matches, try a more general search
13:13:48 <dons> simon marlow's the goto guy here.
13:13:50 <dons> and putting up code.
13:14:08 <tibbe> dons: OK. I'll try
13:14:13 <newsham> tibbe: hGetContents allocates locks?
13:14:15 <tibbe> dons: starting about getting that email together
13:14:39 <Apocalisp> ?djinn (a -> b) -> a -> (a, b)
13:14:40 <lambdabot> f a b = (b, a b)
13:14:42 <ndm> > (id *** not) True
13:14:54 <lambdabot>  Couldn't match expected type `(a, Bool)'
13:14:59 <dons> tibbe: i'd encourage you to put up working code too, so we can test, run it and think
13:15:04 <ndm> > (id &&& not) True
13:15:08 <lambdabot>  (True,False)
13:15:19 <ndm> Apocalisp: ^^
13:15:20 <dons> tibbe: i'd like a nice standalone haskell web server for my .hs web apps. :)
13:15:35 <dons> tibbe: the erlang guys can't have all the fun.
13:15:41 <tibbe> newsham: No. The issue is that generating data for sending over e.g. the network might require a lot of I/O while most libraries use either String or lazy bytestrings in their API. This creates a problem because I need to perform lazy I/O to create that "pure" input which I can't/don't want to
13:15:45 <dons> tibbe: btw, have you looked at how yaws is written?
13:15:52 <Apocalisp> thanks, ndm
13:16:09 <tibbe> dons: I'm working on it, I have network/http parsing code working using a left fold interface
13:16:17 <tibbe> dons: yes but not recently
13:16:36 <tibbe> dons: we have some web servers with good performance at work I can look at ;)
13:16:43 * ndm wonders if hoogle should have some prebuilt-in compound functions
13:16:51 <dons> seriously, if the erlang guys, with all the erlang inefficiencies, can write a decent web server in an fairly pure language, haskell should be able to manage it..
13:16:59 <jethr0> i don't get the left-fold thingey. wouldn't I/O have to be left-oriented anyways to execute anything before the action list is finalized?
13:17:11 <ndm> dons: they have a pretty good compiler
13:17:16 <newsham> tibbe: I'm afraid I dont get it :(
13:17:30 <ndm> and their lint-like tool is rather good, even if their lack of types are the main use for it
13:17:38 <jethr0> tibbe: don't look, post! ^_^
13:17:49 <dons> ndm, sure, not as good as ghc. and with inefficient data types for strings et al. so i don't see why ghc couldn't compete here.
13:18:14 <dons> they just have a culture of building network systems
13:18:21 <jethr0> btw, how does erlang do parallelity/locking?
13:18:25 <dons> while we have a culture of building parsers, compilers and data structures
13:18:47 <tibbe> newsham: let me try with an example. How could you create input for the zlib library which takes a lazy bytestring if you input was say 4Gb (i.e. something that wouldn't fit in RAM)?
13:18:53 <ndm> jethr0: generally copy don't lock
13:18:56 <dons> ndm: but even hipe looks pretty sad compared to ghc, http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=ghc&lang2=hipe
13:18:57 <lambdabot> Title: Haskell GHC benchmarks | Gentoo : Intel Pentium 4 Computer Language Benchmarks ..., http://tinyurl.com/28d6h2
13:19:24 <jethr0>  ndm yes, but for things like mnesia, they would have to lock the shared data, no?
13:19:26 <newsham> tibbe: by lazy io
13:19:28 <ndm> dons: a big portion of that is that GHC can get very fast if people take the time, and people have taken the time - its not a fair benchmark
13:19:40 <tibbe> jethr0: left folds are basically an inversion of control thing. It's the difference between iterators (embodied by lists in Haskell) and enumerators (e.g. map, fold*, etc)
13:19:43 <dons> its a pretty reasonable indication of what'll happen in a high perf scenario..
13:20:00 <ndm> it is a great advert for the Haskell community and the high-end GHC features though
13:20:24 <tibbe> newsham: right. and if you couldn't use lazy I/O because of correctness problems?
13:20:31 <dons> it shows the lower bounds for time and space to aim at. which are much lower in haskell than erlang.
13:21:18 <jethr0> in the meantime the shootout entries have gotten less ugly again (thanks not least to regexps and bytestring). but in many cases the solutions are still very low-level, c-like and giving up many of the core advantages of haskell. but at least they prove that it is possible to optimize micro-benchmarks *g*
13:21:19 * tibbe is also writing a library for terrabyte sized maps in Haskell
13:21:27 <newsham> tibbe: i imagine some IO code which does a bunch of strict chunks and links the chunks together lazily?
13:21:29 <olsner> hmm, how do you best install loads of hackage packages on ubuntu? manual install from source of cabal-instal + dependencies?
13:21:48 <tibbe> newsham: that's not possible though
13:21:49 <dons> olsner: cabal install everything
13:21:52 <dons> tibbe: bring it on!
13:22:07 <olsner> dons: yes, but cabal-install can't install itself until after you've already installed it :P
13:22:15 <tibbe> newsham: either you read everything strictly resulting in running out of memory or you do lazy I/O
13:22:26 <dcoutts> olsner: so install cabal-install manually and then use it for everything else
13:22:44 <dons> tibbe: aim to put one library on hackage per week :)
13:22:47 <dons> we need to see the code!
13:22:52 <tibbe> newsham: on possibility would be to use iterators with explicit close (see Java's InputStream) but ByteString doesn't/and should have that.
13:22:55 <newsham> i cant read a chunk, force evaluation of the entire buffer, put it into a list of chunks (ie. lazy bytestring) ?
13:23:06 <tibbe> dons: I'm trying :)
13:23:22 <tibbe> dons: the next release will probably be a resumeable bytestring parser
13:23:29 <dons> tibbe: that'd be great.
13:23:35 <newsham> I dont see why you cant manage the laziness in a way appropriate for your situation
13:23:35 <olsner> hmm, there should be an debian/ubuntu-repository for everything of hackage that compiles
13:23:41 <tibbe> dons: because current parsers *also* depend on lazy I/O for their input :p
13:23:48 <jethr0> *argh*, i still haven't finished or published my image library bindings for reading and writing image file formats. stupid work stealing all my time...
13:23:50 <dons> some of them.
13:23:59 <dons> tibbe: i sent a patch in to alex to work on strict bytestrings
13:24:05 <dcoutts> tibbe: I'm arriving late here but if you're trying to server 1000's of files simultaneously then you've not got much choice, increase the number of file handles you're allowed or keep some of the small files in memory
13:24:15 <dons> i wonder if we should publish a list of who's writing and uploading what libraries
13:24:24 <dons> get some healthy competition going
13:24:35 <dcoutts> dons: it's clear after they're uploaded since that's in the hackage upload log
13:24:57 <dcoutts> dons: but don't trade quality for quantity
13:24:58 <dons> dcoutts: yes, but over the long term, who's winning :)
13:24:59 <dons> and do they get appropriate kudos for the work.
13:25:01 <jethr0> and people like me would screw up the list by starting to write the library and never upload it ;(
13:25:19 <dons> well, i just want to award 1 point to each library that gets released.
13:25:26 <dons> maybe more points if something then depeneds on it.
13:25:31 <jethr0> dcoutts: true, and also bad libraries might get fixed more easily than written. or not.
13:25:34 <dons> and publish current stats for the authors
13:25:41 <dons> to get a bit of competition/kudos going.
13:26:17 <dcoutts> dons: well you can help us with the new hackage-server :-)
13:26:31 <jethr0> i think it's also a need to have question. for example i started the image library after trying one of the ruby quizes which required image handling.
13:26:33 <tibbe> newsham: here's concretely what I need to do. Imagine the Google web page. If you look at the HTTP communication you'll see that they use chunked encoding to send you the first half of the page before the backends have generated the search results. Further more they use compression to send the page. If I would use e.g. Haskell's zlib bindings I would have to have my lazy ByteString perform HTTP I/O as they are evaluated. That's pretty heavy side effects! Of co
13:26:36 <dons> yeah, we've a meeting on monday about the final status
13:26:37 <dcoutts> I hope it'll be the platform for those kinds of new features
13:26:49 <dcoutts> dons: final status?
13:27:00 <jethr0> so, if people would see the need for libraries and get active support from "tiger teams" or some such on here, then we might get the most requested libraries pretty quickly
13:27:11 <dons> dcoutts: of the project server, for use internally
13:27:13 <tibbe> dcoutts: the problem is that the GC doesn't collect often enough
13:27:16 <dons> its 90% finished now.
13:27:26 <jethr0> right now, for example, i'm thinking of writing a kd-tree implementation since there doesn't seem to exist one yet. at least none i could find
13:27:31 <dons> that's the same thing we could start running over hackage.
13:27:35 <tibbe> dcoutts: guarding a scare resource (file handles) behind a plentiful (memory) seems like a bad idea to me
13:27:40 <dcoutts> tibbe: if you read the whole of a file then it gets closed synchronously, it does not wait for GC
13:28:01 <dcoutts> tibbe: file handles are not really scarce
13:28:06 <newsham> I dont understand "perform HTTP I/O as they are evaluated".
13:28:12 <aBeing> Okay, so I have a new question about how to print the return value of a function: http://hpaste.org/9059
13:28:38 <newsham> also the end of your msg got cut off
13:28:43 <dons> aBeing: alwaysDefect takes an argument
13:28:50 <dcoutts> tibbe: they only cost memory allocated in the kernel, the fact that some OSs give you initially a low number is just like them initially giving you a small stack.
13:28:52 <dons> aBeing: you forgot to pass it whatever argument it needs
13:28:59 <jethr0> aBeing: you should learn to read the compiler replies. in this case you're missing one function argument
13:29:18 <jethr0> which ghc tells you by saying that it has no way to show/visualize a function
13:29:24 <tibbe> newsham: so here's the scenario, you want to send data over the socket but first pass it through zlib, you want to send one chunk through before you're done with all your I/O
13:29:50 <aBeing> Thanks dons and jethr0.
13:29:51 <newsham> are you saying that zlib will only produce output after consuming all of its input?
13:30:02 <dcoutts> tibbe: yes, that requires more control over the zlib state, to be able to flush now
13:30:13 <jethr0> aBeing: and also, your function declaration seems to lack one argument
13:30:16 <tibbe> dcoutts: I could solve the file handles issue. It doesn't solve the general problem of resource allocation though. How about database cursors? Locks? Sockets for HTTP to backend servers?
13:30:41 <jethr0> aBeing: shouldn't that be "alwaysDefect :: Prisoner -> Choice"?
13:30:54 <newsham> it sounds like you want zlib ot be more lazy
13:30:57 <newsham> not your porgram to be less lazy
13:31:11 <tibbe> dcoutts: this is what I need from zlib :: withZlib, write
13:31:13 <dcoutts> tibbe: my only point was in this case it doesn't matter if you use left folds or gc, the problem with serving 1000s of clients simultaneously requires 1000's of open file handles
13:31:33 <tibbe> dcoutts: yes
13:32:03 <newsham> i think having a zlib API for doing reads and writes is reasonable, but I dont think its necessarily your only option
13:32:08 <tibbe> dcoutts: how about timed out requests? the GC will only get to them much later
13:32:35 <tibbe> dcoutts: the GC can't manage all my resources for me in general
13:32:35 <dcoutts> tibbe: true. Using bounded resource control makes perfect sense for a server.
13:32:54 <dcoutts> tibbe: indeed, some resources are expensive and need more precise control.
13:33:47 <tibbe> why avoid side effects at all?
13:33:56 <tibbe> we just have to be careful
13:34:06 <tibbe> xD
13:34:13 <jethr0> tibbe, you mean unsafe* side effects?
13:34:28 <dcoutts> tibbe: so you want a lower level zlib interface. I'll think about it.
13:34:30 * edwardk waves hello,
13:34:35 <tibbe> jethr0: why is lazy I/O not unsafe?
13:34:38 <edwardk> Is anyone here in the Seattle area?
13:34:47 <tibbe> dcoutts: yes that would be nice thanks
13:34:48 <newsham> i think he's advocating a more IO-oriented API to some libs like zlib.
13:34:58 <jethr0> just asking i you meant using side effects in pure functions or in IO functions
13:35:07 <newsham> lazy IO is kinda nice, too.  and avoiding side effects is really useful often.
13:35:15 <newsham> i buy your argument that not everyone wants to do that all the time
13:35:15 <tibbe> dcoutts: but more importantly I want people to understand the problems in writing their APIs in terms of String or lazy ByteString
13:35:55 <dcoutts> tibbe: aye, though I don't think we've really agreed on what the better general interface is. I rather suspect it's a continuation model.
13:36:06 <tibbe> dcoutts: here's another example, Python, Java and Ruby all GC file handles but their stream interfaces all allow for closing the stream. how come?
13:36:15 <dcoutts> tibbe: so does Haskells
13:36:23 <dcoutts> well, Handle
13:36:40 <tibbe> dcoutts: I've done lots with an enumerator interface. written a whole web server, parser, etc that uses it
13:36:55 <tibbe> dcoutts: out iterator protocol does (i.e. list)
13:37:07 <dcoutts> tibbe: I know, I'm not sure I like the enumerator interfaces I've seen
13:37:08 <tibbe> dcoutts: so you can't abstract over the resource
13:37:12 <flux> however python's gc is deterministic, isn't it? as I suspect so is ruby's
13:37:24 <flux> which can help when dealing with resources
13:38:07 <dcoutts> tibbe: I'd appreciate your suggestion on a zlib api btw, email me if you have any suggestion.
13:38:11 <tibbe> dcoutts: you can return a StreamReader from a Java function without exposing from which resource it was created because it has a close method. You can't do the same in Haskell (by returning a [] or a lazy bytestring)
13:38:17 <tibbe> dcoutts: sure
13:38:36 <tibbe> sorry if I come a cross as to whiny :/
13:39:16 <dcoutts> tibbe: I do appreciate the problem, and I know you're trying to be precise while we're all enjoying getting away with being sloppy ;-)
13:39:17 <dons> let's just get some code up then, tibbe
13:39:24 <tibbe> a left fold interface is very much like a continuation interface (it's basically a callback interface)
13:39:24 <dons> if it works, people will use it.
13:39:31 <newsham> tibbe: sounds like you want  zopen -> IO zhandle,  zclose -> zhandle -> IO (),  zread -> zhandle -> IO String  etc..
13:39:39 <dcoutts> newsham: nooo!
13:39:44 <dcoutts> no IO
13:39:46 <dcoutts> zlib is pure
13:40:01 <dcoutts> whatever api we have it must be pure
13:40:06 <newsham> s/IO//
13:40:10 <dcoutts> and be able to layer it over whatever IO you're doing
13:40:36 <olsner> gtk2hs doesn'
13:40:40 <olsner> t parallellise well
13:40:40 <newsham> will,  at least some state type thing
13:40:44 <tibbe> dcoutts: zlib should be able to be pure, the problem is that information is lost passing through it, in particular since the output is a lazy bytestring the caller can close it
13:41:04 <newsham> s/will/well/
13:41:24 <olsner> +compiling +makefile (and context, grammar, and everything else that I'll need to add for you to understand what I'm saying :P)
13:41:50 <dcoutts> tibbe: right. Internally it's a kind of writer/cont monad. Something like that is what we probably want to provide. And write the pure stream based version in terms of that.
13:42:05 <tibbe> dcoutts: i.e. the server handler function must look something like this handle :: Request -> (Lazy.ByteString, Resource) because the caller needs to free the resource and can't do so through the stream
13:42:56 <tibbe> dcoutts: resource allocation really messes with composability :/
13:43:30 <tibbe> dcoutts: left folds are the cleanest solution I've seen so far for collections that perform I/O or any other side effect
13:43:50 <tibbe> the problem is that left folds need lower level API
13:44:49 <PeakerWork> newsham: Maybe zlib should be a comonad?
13:45:02 <Cale> That reminds me that I probably should write a small article at some point detailing how to translate imperative programs into purely functional ones.
13:45:45 <PeakerWork> Cale: isn't it more of an art than a systematic practice?
13:45:52 <Cale> PeakerWork: It's a bit of both.
13:46:06 <Cale> PeakerWork: You can do it very systematically and end up with something that looks a bit rough.
13:46:09 <tibbe> dcoutts: I use a combination of a fold and unfold to process data
13:46:10 <Cale> (but works)
13:46:38 <dons> tibbe: yaws is 20k lines of erlang. surely we can turn out a decent, threaded, smp-ready web server for 5k or so?
13:47:05 <olsner> don't we have HWS?
13:47:13 <dons> most of that is exxtras too
13:47:20 <Cale> The better that you understand the process you're translating, and reflect that understanding into your code, the nicer the result will be though.
13:47:38 <tibbe> dons: I think so, the only issues I have right now is that I can't daemonize my process when using the multithreaded RTS
13:47:40 <dons> my eyes are burning just a bit now, after looking at all that .erl
13:47:47 <dons> tibbe: oh/
13:47:48 <dons> ?
13:48:14 <tibbe> dons: and that while forkIO gives a nice performance boost it seems more difficult to get better control over the threading yourself
13:48:29 <tibbe> GHC implements threading using async I/O and select I believe
13:48:32 <tibbe> I want epoll
13:48:33 <dons> yes.
13:48:36 <dons> oh.
13:48:37 <PeakerWork> Cale: its nice if the rough pure code is easier to translate into nice pure code than the imperative code
13:48:45 <dons> well, there's a ghc experiment fork based on epoll.
13:48:58 <dons> but probably its more important to get something released now
13:49:00 <tibbe> dons: and very few threads working on different parts of the pipeline for better instruction cache locality
13:49:01 <dons> than worry about epoll
13:49:03 <Cale> PeakerWork: well... that's possible, but not always the case :)
13:49:10 <dons> select is already beating everything else for thread benchmarks :)
13:49:19 <tibbe> dons: but I will release something soon
13:49:21 <Cale> PeakerWork: Sometimes to get a nice result you really have to understand what's going on :)
13:49:22 <dons> any code is better than optimal code!
13:49:29 <tibbe> dons: it's not doing 5k reqs/sec yet :p
13:49:48 <dons> 5k would be a good 0.1 release target!
13:49:53 <tibbe> dons: I agree, I was hoping for some more feedback on my web server interface
13:50:03 <dons> the happs guys were happy with 2.5k/s iirc
13:50:10 <dons> based on musasabi's web server
13:50:20 <dons> and hpaste is surely happy enough :)
13:50:30 <tibbe> dons: got some good initial feedback but once I got back with the pros and cons of different solutions noone wanted to discuss anymore
13:51:08 <dons> tibbe: remember the ruby guys are happy with 200 r/s, so its far more about getting things out soon, than getting them out fast.
13:51:21 <tibbe> dons: it's easy to say, "I want more types". It's hard to take the difficult design decisions and I mostly saw interest in doing the former. Probably because few people actually write web apps
13:51:49 <tibbe> it's unfortunate that all web dev people are using python and ruby
13:52:10 <tibbe> deciding on a good interface generally needs a few eyeballs
13:52:23 <tibbe> if I take all decisions myself I probably will make some bad ones
13:52:27 <dons> if we have some code out there, we can hope to pull in more web people.
13:53:00 <dons> right, that's why its important to get code out. have a web site, documentation, examples
13:53:06 <dons> and then start integrating feedback.
13:53:07 <drguildo> sorry about how simple i'm sure this is (don't know where else to look) but how do i deal with a function that returns a value of one monadic type in a do block that deals with another monadic type?
13:53:10 <drguildo> i hope that makes sense
13:53:17 <Cale> PeakerWork: For example, during the ICFP contest, I translated the imperative pseudocode on wikipedia for the A* algorithm, and ended up with something that worked reasonably well, but was fairly difficult to read. Now that I've had a few days to think about it, I'm pretty sure that I could replace that with something much shorter. :)
13:53:31 <Cale> drguildo: Which monads?
13:53:33 <dons> Cale: can you release a general A* to hackage?
13:53:59 <drguildo> Cale, the do block is XMPP and the function i'm using within it is IO
13:54:01 <vixey> hey dons maybe it could be easier to get a hackage acconut ?
13:54:11 <tibbe> dons: alright, I'll try to get a first release soon and that might spark some discussions
13:54:17 <Cale> dons: I could, I suppose :)
13:54:32 <Cale> drguildo: Is XMPP an instance of MonadIO?
13:54:32 <dons> vixey: i think its pretty easy. ask ross, and you get an account.
13:54:59 <Cale> drguildo: You can try applying the liftIO function to the IO action, to see if that will turn it into an XMPP action.
13:55:01 <drguildo> Cale, i don't think so, :i only lists Monad
13:55:16 * vixey had a long email conversation and no account :p
13:55:30 <Cale> drguildo: Hang on while I figure out where the XMPP documentation is :)
13:55:35 <vixey> well it was a lot easier for -me- to sign up on google code
13:55:48 <drguildo> http://www.dtek.chalmers.se/~henoch/hsxmpp-doc/XMPP.html is what i'm using
13:55:49 <lambdabot> Title: XMPP
13:55:59 <Cale> ah, okay :)
13:56:09 <dons> vixey: why didn't you get an account?
13:56:14 <Cale> Yes, it is an instance of MonadIO
13:56:16 <dons> did you refuse to provide some information?
13:56:18 <Cale> (according to that)
13:56:38 <drguildo> great
13:56:38 <Cale> So you can turn any IO action into an XMPP action by applying the liftIO action to it.
13:56:46 <Cale> er, function* :)
13:56:53 <vixey> dons well I guess my code doesn't make much sense for hackage since it's not a library
13:57:01 <dons> is it cabalised?
13:57:18 <vixey> no I didn't do that since I don't have a hackage account
13:57:22 <dons> vixey: note its for released packages. not code hosting (try code.haskell.org)
13:57:36 <vixey> yeah I could not make an account on code.haskell.org
13:57:40 <drguildo> Cale, liftIO $ functionThatReturnsIO?
13:57:43 <dons> vixey: why?
13:57:44 <vixey> it says there is a newline in ssh key, but there wasn't
13:57:52 <dons> oh, so a technical reason.
13:57:56 <vixey> I hope this is a bug in the website and not some stupid mistake I made ...
13:57:58 <dons> vixey: submit again. dcoutts can check.
13:58:05 <Cale> drguildo: Well, you can imagine that  liftIO :: IO a -> XMPP a
13:58:25 <Cale> It's really  liftIO :: (MonadIO m) => IO a -> m a
13:59:26 <drguildo> Cale, i think i'm doing something wrong because i get another error
13:59:43 <dcoutts> vixey: check your browser is only wrapping the key when you paste it and isn't breaking it into lines.
13:59:47 <drguildo>     Ambiguous type variable `m' in the constraint:
13:59:47 <drguildo>       `Control.Monad.Trans.MonadIO m'
13:59:57 <Cale> drguildo: Interesting...
14:00:34 <Cale> drguildo: The only way you could get that is if there wasn't enough other stuff in that do-block to pin down what liftIO should be transforming the IO action into.
14:00:57 <Cale> drguildo: Maybe try adding a type signature for the definition you're making?
14:00:57 <PeakerWork> I think liftX sucks. If you have a big monad transformer, just newtype it, and implement a bunch of specific lifters for each layer in the transformer
14:01:10 <Cale> PeakerWork: liftIO is a solution like that
14:01:50 <PeakerWork> Cale: But liftIO is trying to be cute, and find its way "all the way up".  Requiring each monad type to know each other monad type and write a lifter for it
14:02:01 <Cale> Huh?
14:02:09 <PeakerWork> Cale: if you want to be able to lift things that are not IO too
14:02:26 <Cale> You only need one instance of liftIO for any monad/transformer you write
14:02:42 <PeakerWork> Cale: But then I can only liftIO, and not liftReader/etc
14:02:48 <Cale> Well, sure.
14:03:04 <Cale> Other liftings are potentially more complicated.
14:03:06 <drguildo> Cale, "liftIO reply >>= sendMessage sender" seems to work
14:03:23 <drguildo> before it was in my "where" section at the beginning of the do block
14:03:23 <Cale> drguildo: That sounds reasonable :)
14:03:58 <drguildo> where all the non-monad stuff goes
14:04:10 <drguildo> so i guess that's why it had trouble inferring what i meant
14:04:18 <Cale> PeakerWork: There's lift which works in general, but you should basically never design an interface that forces users to use lift explicitly.
14:04:22 <drguildo> a big guess
14:04:43 <Cale> drguildo: Well, if you just wrote something like  reply' = liftIO reply
14:04:46 <PeakerWork> Cale: I tried a bunch of approaches in a small example and I think the simple approach of just defining liftA = id, liftReader = lift, liftState = lift . lift, liftAll = lift . lift . lift -- is the simplest. Then if you layer IO on the transformer, just use liftAll to access it, rather than having a MonadIO instance
14:05:11 <Cale> drguildo: And didn't proceed to use reply' yet, then it would have no way to know which monad reply' was in.
14:05:47 * vixey imagines a MS Word style "Monad Transformer Wizard" that prints out all the lifting things for you
14:06:04 <tibbe> time to good to bed
14:06:05 <opqdonut> :D
14:06:07 <tibbe> good night all
14:06:10 <Cale> PeakerWork: I almost never write special cases for other liftings.
14:06:41 <yitz> PeakerWork: I would go even further, and give more meaning to the lifts. Like "liftInitialData", "liftUserState", or whatever.
14:06:46 <Cale> PeakerWork: Generally, when I write something that uses monad transformers, I have specific uses in mind for each of the features that the transformers add.
14:07:00 <PeakerWork> yitz: yeah - I did that, especially since I had two state monads in the transformer
14:07:12 <Cale> PeakerWork: I write primitive computations using those features, and then hide the basic functionality that the transformer provides altogether.
14:07:37 <yitz> PeakerWork: not only that. It allows you to change your monad stack later without having to change every function.
14:07:38 <Cale> (so it's impossible to know that I used MonadState, for instance, without looking inside the module)
14:08:41 <PeakerWork> Cale: Except for IO which you expose via a MonadIO instance?
14:08:46 <yitz> Cale: so when possible it isn't even visible as a lift - even the operations themselves have meaning in terms of the particular program.
14:09:08 <drguildo> Cale, works great. now i have a jabber bot doing dictionary lookups. :-)
14:09:30 <PeakerWork> yitz: One of the problems I disliked was that they could use lift and access "hidden" layers.  e.g: liftGUIState (lift $ someAction)
14:09:32 <MrMeanie> I recall a while ago that a system was developed in Haskell that compiled code written in a DSL that was designed specifically for mathematics, such as matrix math. It generated code that was much better than hand rolled code. I am trying to find the name of this system. Does it ring any bells with anyone here?
14:10:12 <atp> MrMeanie: it produces machine language?
14:10:34 <MrMeanie> atp: Yes, it generates x86 SSE code I think
14:11:08 <atp> MrMeanie: there's coconut, which generates super-efficient SIMD code, but it wasn't specifically for math
14:11:08 <MrMeanie> I seem to remember that it was 4x faster than the equiv C code, perhaps even 4x faster than hand-rolled asm.
14:11:24 <atp> MrMeanie: yah, coconut is like that
14:11:32 <Zao> MrMeanie: If it's equivalent, it can't be slower, can't it? :)
14:12:10 <MrMeanie> atp: Thanks! Thats it!
14:12:10 <PeakerWork> MrMeanie: what is "hand rolled ASM"?
14:12:27 <atp> MrMeanie: np
14:12:29 <dons> we don't hear much about coconut
14:12:31 <dons> i wonder why.
14:12:41 <atp> is the code open, dons?
14:13:05 <MrMeanie> peakerWork: Hand coded asm.
14:13:17 <PeakerWork> MrMeanie: hand-coded ASM can be at least as good as anything else..
14:13:54 <atp> MrMeanie: the dude's homepage is here: http://www.cas.mcmaster.ca/~anand/
14:13:55 <lambdabot> Title: home page of Christopher Anand
14:14:20 <yitz> PeakerWork: well, hiding things is a different matter. you do that with module exports. that's pretty much orthogonal to monad stack design, i think.
14:14:20 <atp> doesn't mention coconut though, it seems.
14:14:54 <dons> http://www.cs.utk.edu/~dongarra/cell2006/cell-slides/09-Christopher-Anand.pdf
14:14:55 <lambdabot> Title: COde CONstructing User Tool, http://tinyurl.com/56th4d
14:15:18 <PeakerWork> yitz: even by hiding module exports - you expose liftGUI - how do you make liftGUI . lift not work? (only allow code in liftGUI talk about the specific monad transformer layer you want it to be within)?
14:15:23 <yitz> atp, MrMeanie: Why isn't coconut here: http://haskell.org/haskellwiki/Applications_and_libraries/Mathematics
14:15:24 <dons> the video is  everywhere.
14:15:25 <lambdabot> Title: Applications and libraries/Mathematics - HaskellWiki, http://tinyurl.com/2rt3uv
14:15:33 <atp> yitz: because it's not mathematics
14:15:45 <dons> i think we'd have to write to the author to find out about the code. :/
14:15:57 <dons> we've got friends at mcmaster.
14:15:57 <atp> dons: yeah :(
14:16:22 <atp> dons: if it's not too much hassle you should do that; this is one of those "wow" applications that impresses the low-level crowd
14:16:23 <yitz> atp: MrMeanie said: " designed specifically for mathematics, such as matrix math"
14:16:31 <atp> yitz: yes, but he remembered incorrectly
14:16:59 <Cale> PeakerWork: Yeah, possibly, if I think that arbitrary IO is appropriate.
14:17:01 <yitz> ah, so it's just a low-level tool for generating SSE then/
14:17:05 <dons> http://www.cas.mcmaster.ca/~anand/papers/preprints.html
14:17:06 <lambdabot> Title: Preprints
14:17:29 <Cale> yitz: Yeah, I hide the fact that I'm using monad transformers altogether.
14:17:45 <dons> http://www.cas.mcmaster.ca/~kahl/Publications/TR/Anand-Kahl-2007a_DSL/
14:17:46 <lambdabot> Title: A DSL for SIMD-Parallel Code Generation --- SQRL Report No. 43, McMaster Univ.,  ..., http://tinyurl.com/6k8z4z
14:18:21 <atp> dons: this guy does a lot of impressively cool stuff.
14:18:26 <dons> Cale, you know Dr. Kahl, no?
14:18:26 <yitz> Cale: well you can't do that completely if you want your monad to be composable with other things later on.
14:18:31 <dons> or Anand?
14:18:33 <Cale> yitz: yeah
14:18:38 <Cale> dons: I know both of them.
14:19:05 <dons> there's also an SPU simulator written in Haskell
14:19:07 <atp> yitz: nevermind, it was i who remembered incorrectly, as dons' last link shows, math is involved
14:19:17 <Cale> One of the nice things about not exposing the operations that the transformer gives you directly is that it gives you a chance to ensure consistency of the operations. For example, you can ensure that operations that affect your state only make valid state transitions.
14:19:48 <Cale> dons: Someone really needs to bug Dr. Kahl to put things on the web or on Hackage. :)
14:20:04 <dons> yes.
14:20:04 <Cale> dons: I prodded him last time I saw him a few years back.
14:20:21 <dons> there's a bunch of things here, http://www.cas.mcmaster.ca/~anand/papers/preprints.html
14:20:22 <lambdabot> Title: Preprints
14:20:23 <Cale> dons: He has a *beautiful* library for relations.
14:20:55 <atp> Cale: you're making us salivate, you'd better go "prod" him again :)
14:21:09 <Cale> atp: I'm not working there anymore.
14:21:12 <dons> this would fit well with some similar things, e.g. harpy, which are on hackage.
14:21:18 <atp> Cale: ah
14:21:19 <dons> and have a much hiigher visibility as a result.
14:22:13 <yitz> atp: seems to lead to rational approximations for "special functions". Not clear from the abstract which functions are "special".
14:22:43 <MrMeanie> atp: Thanks a lot for your help.
14:22:58 <Quadrescence> yitz: There's a class of functions called 'special functions'
14:23:02 <yitz> atp: also - not clear from the abstract that this is usable yet, or just a concept.
14:23:21 <Quadrescence> (mathematical functions)
14:23:22 <atp> MrMeanie: no problem
14:23:23 <yitz> Quadrescence: there are actually many such classes.
14:23:41 <atp> yitz: coconut apparently is quite usable
14:23:45 <yitz> Quadrescence: depends on your domain.
14:23:49 <Quadrescence> I suppose.
14:23:54 <atp> yitz: but i suppose we're taking their word for it.
14:24:04 <shepheb> I'm getting stuck on how to parse (with Parsec) function application as juxtaposition still
14:24:05 <Quadrescence> But I think there is a general consensus.
14:24:27 <dons> mcmaster must be the lowest profile hardcore haskell research lab out there.
14:24:30 <Cale> shepheb: iirc, chainl is the solution
14:24:36 <dons> a lot of talent, and hardly any code in the public
14:24:36 <Cale> dons: yeah :)
14:24:39 <koninkje> I have a collection of list functions I'm preparing to cabalize/hackageize and I'm interested in thoughts on where I should put it. Most of the functions are simple but perhaps not simple enough to throw into Data.List (e.g. argmax/argmin variants of maximum/minimum, variants of zip which fail (Nothing) on uneven lists, etc). I was thinking Data.List.Extras but I wouldn't want to squat on prime realestate if there's already work on a list library 
14:24:59 <dons> koninkje: hmm.
14:25:07 * koninkje would be willing to throw other folks' functions in there too, fwiw
14:25:08 <Cale> dons: It seems like almost everyone there is using Haskell now, and nobody seems to be releasing code :)
14:25:11 <dons> Data.List.Koninjke?
14:25:21 <dons> Cale: :(
14:25:55 <koninkje> dons: is that not too abstreuse? :)
14:25:58 <yitz> @go special functions
14:25:59 <lambdabot> http://en.wikipedia.org/wiki/Special_functions
14:25:59 <lambdabot> Title: Special functions - Wikipedia, the free encyclopedia
14:26:36 <yitz> ^ that says that there is no consensus at all. so it would be interesting to know what coconut does.
14:26:52 <atp> yitz: perhaps you should watch the talk they gave on it then
14:28:07 <yitz> atp: it would be interesting. but basically, i'm just thinking about adding a link to the wiki page. so i just need to know those two additional details - does it actually already do something, and if so, what does it do.
14:29:08 <atp> yitz: well, you have several options.  one is to watch the video because they explain a lot of it there.  the other is to e-mail the authors and ask.  the other is to not add anything to the wiki, because really, there's not much information (or code) available.
14:29:18 <atp> but it's up to you.
14:30:24 <thaldyron> k
14:30:47 <byorgey> koninkje: fwiw, I think Data.List.Extras is fine
14:32:15 <koninkje> byorgey: cool. I think I'll stick with that for now then; just wanted to see if someone else had stuff in the works
14:32:59 <Cale> I should perhaps fix a couple strictness problems in the PSQueue package. It seems to have a stack overflow or two with some operations that eat lists.
14:33:23 <Cale> I'm so happy to have that data structure though :)
14:35:56 <yitz> dons: the last abstract on that page states that coconut is intended for use in domains "such as medical imaging". let's just say that an open source mentality hasn't caught on very much there. and there is often a lot of $$$ at stake in the long run. so don't expect to see much code I'm afraid
14:36:20 <dcoutts> tibbe_: one issue to note in your NIO stuff is that some higher layers impose some restrictions on the lower. Eg getChar is impossible if we only have getByte since getChar needs to atomically get 1-3 bytes (depending on encoding)
14:36:36 <tibbe_> dcoutts: yes
14:36:55 <tibbe_> dcoutts: I intend to cover Unicode text I/O
14:37:05 <dcoutts> tibbe_: good good :-)
14:37:21 <yitz> Cale: any progress on lambdabot's memory leak?
14:37:27 <tibbe_> dcoutts: I don't intend to have getByte, doesn't sound very useful and can be written in terms of read
14:37:36 <tibbe_> dcoutts: but I will think about buffered I/O
14:37:40 <dcoutts> tibbe_: I'm interested in this topic so keep me posted.
14:37:46 <tibbe_> dcoutts: sure
14:38:03 <tibbe_> dcoutts: there's a nice whole there for your students work if he finishes it :)
14:38:14 <tibbe_> dcoutts: cause we need that packed Unicode type
14:38:17 <dcoutts> tibbe_: and bear in mind the new unicode bytestring type, it might be the right type for some of your IO stuff
14:38:21 <dcoutts> tibbe_: right :-)
14:38:34 <tibbe_> dcoutts: I intend to start with some research on what they're doing for JDK 7 and Python 3
14:38:34 <yitz> shepheb: what are you stuck on?
14:38:48 <dcoutts> tibbe_: right the java nio is not too bad
14:39:04 <atp> i don't see why we don't just make an ffi interface to ICU
14:39:11 <tibbe_> dcoutts: yes, lots of though went into it. It's both fast and very multiplatform
14:39:11 <yitz> tibbe_: there's something like that in python 3? I didn't hear.
14:39:16 <atp> based on top of a WordStrings library or similar
14:39:28 <tibbe_> yitz: they're revamping unicode handling and some I/O stuff
14:39:45 <chessguy> @pl \p -> a p x
14:39:45 <lambdabot> flip a x
14:39:52 <shepheb> yitz: partly the fault of a badly formatted grammar. I think I've got it now.
14:40:00 <shepheb> badly formed grammar, rather
14:40:15 <yitz> tibbe_: interesting. I didn't think it was too bad in 2. except that I know they're unifying string and unicode, but that's an obvious one.
14:40:38 <tibbe_> http://www.python.org/dev/peps/pep-3116/
14:40:39 <lambdabot> Title: PEP 3116 -- New I/O
14:40:52 <yitz> shepheb: yeah, i don't write no good grammer either sometimes.
14:40:53 <tibbe_> yitz: yeah, unifying is the biggy, the rest kinda falls out from that
14:41:16 <yitz> tibbe_: ok
14:41:27 <tibbe_> I need to think how I can make the lib extensible
14:41:35 <tibbe_> yitz: Java is doing more
14:41:45 <tibbe_> yitz: they have all their channels going
14:41:59 <tibbe_> yitz: but they're heavily based on a mutable interface
14:42:11 <yitz> tibbe_: just like them
14:44:07 <jberryman> koninkje: I just put together a function that takes a list of ordered lists and returns a list of the values that are common to all of them. if you think that would be a good addition, you're welcome to use it
14:44:52 <yitz> tibbe_: thanks for the pep link. ok, really all they're doing is standardizing where to put the boundary between high-level and low-level IO, unlike the current file-like objects which confuse that. good idea, nothing too earth-shattering.
14:45:26 <tibbe_> yitz: no, just nice clean-ups. finally getting a firm byte/unicode separation
14:45:29 <nolrai_East> @ty maybe
14:45:31 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
14:46:10 <koninkje> jberryman: for taking an intersection of many "sets"?
14:46:21 <Zao> @type unions
14:46:22 <lambdabot> Not in scope: `unions'
14:46:36 <Zao> @type Data.Set.unions
14:46:37 <lambdabot> forall a. (Ord a) => [S.Set a] -> S.Set a
14:46:39 <Zao> Silly imports :
14:46:52 <Deewiant> @ty foldr union []
14:46:53 <lambdabot> forall a. (Eq a) => [[a]] -> [a]
14:47:08 <jberryman> koninkje: hmmm, perhaps... :)
14:47:18 <tibbe_> I want a clean way of extending the library, currently Handle is opaque
14:47:34 <Zao> Hmm, union favors elements from the left hand side, doesn't it?
14:47:39 <tibbe_> mybe a .Internal module that exposes the file descriptor or something similar
14:48:30 <Deewiant> ?src union
14:48:31 <lambdabot> union = unionBy (==)
14:48:34 <Deewiant> ?src unionBy
14:48:34 <lambdabot> unionBy eq xs ys = xs ++ foldl (flip (deleteBy eq)) (nubBy eq ys) xs
14:48:47 <Deewiant> Zao: so evidently yes
14:49:42 <Cale> yitz: Yeah, Baughn found at least one of the problems. Apparently there are still some left though.
14:50:41 <yitz> Cale: urgh. did you get my message the other day?
14:50:55 <Cale> yitz: I'm not sure... what was it?
14:51:59 <yitz> Cale: I noticed that in the seen plugin, every place the map is rebuilt has the form "Right $ M.insert ...", so if you change each of those $ to $! I think that should do it.
14:52:22 <Cale> I'll give it a shot.
14:52:30 <yitz> (except one other place, but that is already seq'ed)
14:54:25 <chessguy> @pl \(x,y) p -> p (snd x)
14:54:25 <lambdabot> flip id . snd . fst
14:54:50 <chessguy> eh?
14:54:57 <chessguy> @type flip id . snd . fst
14:54:58 <lambdabot> forall c a b b1. ((a, b), b1) -> (b -> c) -> c
14:55:29 <chessguy> ...
14:55:35 <chessguy> that's not what i asked for
14:55:41 * Cale rebuilds with the changes applied...
14:55:41 <Deewiant> yes it is
14:56:07 <Deewiant> or did you want p x, or p y, instead of p (snd x) :-P
14:56:26 <chessguy> oh sheesh
14:56:32 <byorgey> @pl \x p -> p (snd x)
14:56:32 <lambdabot> flip id . snd
14:56:33 <Deewiant> @ty \((_,x),_) p -> p x
14:56:33 <lambdabot> forall t t1 t2 t3. ((t, t1), t2) -> (t1 -> t3) -> t3
14:56:48 <byorgey> @type flip second
14:56:49 <lambdabot> forall b c d. (d, b) -> (b -> c) -> (d, c)
14:57:00 <Deewiant> @ty \x p -> p (snd x)
14:57:01 <lambdabot> forall a b t. (a, b) -> (b -> t) -> t
14:57:05 <Deewiant> not the same
14:57:11 <byorgey> indeed, not quite
14:57:22 <Deewiant> second doesn't clobber the tuple
14:57:29 <byorgey> @type (snd .) . flip second
14:57:30 <lambdabot> forall b c d. (d, b) -> (b -> c) -> c
14:57:38 <Deewiant> :-)
14:58:14 <yitz> Deewiant: she'll be back in a moment
14:58:17 <chessguy> @pl \x -> p (snd x)
14:58:35 <chessguy> @bot
14:58:36 <lambdabot> p . snd
14:58:46 <lambdabot> :)
14:59:01 <Cale> It's always slow when it's first starting up. Probably because of the flood of joins :)
14:59:15 <chessguy> oh, i didn't even see it leave and come back
14:59:42 <olsner> @seen lambdabot
14:59:54 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
15:00:01 <byorgey> doh
15:00:11 <yitz> urgh
15:00:19 <Cale> oh, duh
15:00:20 <olsner> hasn't anyone fixed that bug yet?
15:00:26 <chessguy> that mischeivous old byte position 8 :)
15:01:10 <Cale> It's really dumb that it fails if there's an empty seen file... which it creates every time it's run.
15:01:55 <yitz> @vixen don't act dumb when you have an empty seen file
15:02:02 <lambdabot> when? now? later?
15:02:07 <Cale> @seen Cale
15:02:12 <lambdabot> You are in #haskell-overflow, #ghc and #haskell. I last heard you speak just now.
15:02:15 <olsner> Cale: hmm, so the first seen always fails?
15:02:36 <Cale> olsner: No, all @seens fail if there's a State/seen file which is empty.
15:02:38 <yitz> olsner: not anymore, hopefully
15:03:27 <Cale> olsner: The solution is to kill the bot, and delete that file... which it promptly recreates when it runs again (but that doesn't cause problems until the next time the bot is started)
15:03:33 <Cale> Perhaps I should look at it.
15:03:56 <mauke> @seen mauke
15:03:59 <chessguy> @pl \p -> h . f (p . s) . q
15:04:00 <olsner> Perhaps :)
15:04:00 <lambdabot> You are in #xmonad and #haskell. I last heard you speak just now.
15:04:06 <lambdabot> (h .) . (. q) . f . (. s)
15:04:21 <yitz> Cale: maybe we need a @bug command for tracking lambdabot bugs.
15:04:27 <chessguy> @bug
15:04:27 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
15:04:32 * chessguy giggles
15:04:34 <chessguy> @todo
15:04:34 <lambdabot> 0. SamB: A way to get multiple results from a google search
15:04:34 <lambdabot> 1. dons: improve formatting of @dict
15:04:34 <lambdabot> 2. dons: write Haskell Manifesto
15:04:34 <lambdabot> 3. lispy: don't let lambdabot's prettyprinter split the sequence @foo across lines
15:04:34 <lambdabot> 4. TheHunter: priviledged users should get priviledged listcommands.
15:04:36 <lambdabot> [29 @more lines]
15:05:06 <yitz> chessguy: great! how do add one?
15:05:12 <yitz> @more
15:05:12 <lambdabot> 5. TheHunter: @type 1 :: Int
15:05:12 <lambdabot> 6. lispy: haddock gives a link from a type signature to the types.  It would be nice if it also let you find functions in the given module that use a type.
15:05:12 <lambdabot> 7. dons: Implement @whatis
15:05:12 <lambdabot> 8. dcoutts: implement @cool list, as a clone of the @todo(-add) commands
15:05:12 <lambdabot> 9. dons: there's some bug in the 'when i left' code of @seen
15:05:14 <lambdabot> [24 @more lines]
15:05:21 <chessguy> yitz:  i don't think you can. that's the fun part
15:05:42 <Cale> I wonder when the last time anyone touched that list was.
15:06:11 <Cale> @help todo
15:06:11 <lambdabot> todo. List todo entries
15:06:14 <Cale> @help todo-add
15:06:14 <lambdabot> todo-add <idea>. Add a todo entry
15:06:20 <mauke> someone should fix this "privileged users" stuff
15:06:35 <chessguy> @type 1 :: Int
15:06:39 <allbery_b> @list todo
15:06:43 <yitz> @help todo-delete
15:06:45 <lambdabot> Int
15:06:45 <lambdabot> todo provides: todo todo-add
15:06:45 <lambdabot> todo-delete <n>. Delete a todo entry (for admins)
15:06:52 <mauke> chessguy: that one was fixed
15:06:54 * olsner converts himself into a lazy thunk not expecting to be forced until morning
15:06:59 <chessguy> mauke:  apparenty so
15:07:07 <mauke> it used to say Int :: Int
15:07:15 <chessguy> heh, nice
15:08:21 <Cale> Well, I could remove state storage for the @seen module altogether.
15:08:30 <yitz> Cale: one bug is that lambdabot should preface *all* of its responses with a space. there are currently some cross-bot DOS attack opportunities...
15:08:42 <Cale> yitz: yeah.
15:09:17 <Cale> If I was designing lambdabot, it would look a bit different. :)
15:09:22 <yitz> (please strike that from the public log)
15:09:28 <Cale> heh
15:09:43 <mauke> @help quit
15:09:43 <lambdabot> quit [msg], have the bot exit with msg
15:09:48 <mauke> anyone can kill the bot anyway
15:09:52 <Cale> oh?
15:09:55 <Cale> :q
15:10:02 <Cale> whoops :)
15:10:06 <nolrai_East> @bot
15:10:06 <lambdabot> :)
15:10:23 <nolrai_East> hmm
15:10:45 <Cale> mauke: try it
15:11:08 <yitz> mauke: it will cause the bot to gain op priviledge and ban you
15:11:18 <mauke> @quit
15:11:19 <lambdabot> Not enough privileges
15:11:50 <yitz> (i was close)
15:11:59 <mauke> @quit
15:12:07 <mauke> ta da
15:12:15 <Cale> What was the difference there?
15:12:22 <mauke> I @admin +'d myself
15:12:27 <Cale> heh
15:12:46 <mauke> now you're probably saying "but @admin is a privileged command!"
15:13:01 <Cale> It probably should be, anyway :)
15:13:06 <mauke> well, that doesn't matter because the privilege system is purely nick based
15:13:23 <mauke> I can simply connect on a second client, change my nick to one of the admins, and bam
15:13:43 <Cale> Ah, it should check that the user is identified as well.
15:13:57 <chessguy> @pl \sq b -> a (m s (p b)) sq b
15:14:01 <yitz> mauke: so Cale should make sure that all admins have password protected nicks.
15:14:05 <lambdabot> join . flip (a . m s . p)
15:14:25 <Baughn> Cale: According to this profile, about half the plugins leak memory
15:14:29 <Cale> Well, the bot could just check that the admins are identified with nickserv.
15:14:53 <Baughn> Some more than others, of course. Anything that hooks contextual is nasty.
15:14:58 <yitz> Cale isn't that freenode specific?
15:15:03 <Cale> yitz: maybe.
15:15:06 <Baughn> yitz: No
15:15:18 <mauke> yitz: yes
15:15:22 <Baughn> Sure it's not in the original irc spec, but in practice most networks implement it
15:15:27 <Cale> yitz: It's not *that* FreeNode specific. There are lots of networks with NickServs.
15:15:42 <mauke> I'm connected to three networks
15:15:47 <mauke> two of them don't have nickserv
15:16:00 <yitz> is checking the nick mode more portable that the specific name "NickServ"?
15:16:02 <Cale> Another option is to make admin+ unavailable from anywhere but the .rc file.
15:16:24 <chessguy> @pl \a -> at a t b
15:16:25 <lambdabot> flip (flip at t) b
15:16:25 <Baughn> Cale: I'd veto that
15:16:39 <Cale> Baughn: why?
15:16:42 <yitz> Cale: or only allow current admins to do it
15:16:53 <Cale> yitz: hm?
15:16:55 <Baughn> yitz: That's how it already works
15:17:13 <yitz> so what's the problem then?
15:17:14 <Baughn> Cale: It's convenient to be able to give channel admins get-rid-of-the-bot privileges if you're going for a walk
15:17:25 <Baughn> Cale: Though a more graduated privilege system would be good
15:17:40 <|Steve|> @type liftM
15:17:42 <Cale> yitz: The problem is that people can impersonate the admins registered with the bot.
15:17:43 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
15:17:59 <yitz> ah, right.
15:18:12 <Cale> Actually, only allowing admin+ from the .rc file isn't strong enough.
15:18:34 <Cale> Because they can still be impersonated and admin commands issued from there.
15:19:14 <lispy> can't you check that they are identified though?
15:19:25 <Cale> Yes, I'm pretty sure that I can :)
15:19:30 <idnar> < yitz> Cale: one bug is that lambdabot should preface *all* of its responses with a space. there are currently some cross-bot DOS attack opportunities...
15:19:37 <lispy> security is never 100%, it's just good enough :)
15:19:39 <idnar> no, it should respond by NOTICE instead of PRIVMSG
15:19:42 <idnar> like the RFC says ;)
15:19:46 <Cale> Yeah, it should.
15:19:58 <dobblego> @src filterM
15:19:58 <lambdabot> Source not found. I feel much better now.
15:20:00 <dobblego> wtf?
15:20:04 <Cale> However, we tried that, and had dozens of people with shitty IRC clients complain about it.
15:20:24 <yitz> require admin commands to have an md5 token argument :)
15:20:51 <Cale> In practice, it seems, many IRC clients don't really support NOTICE properly.
15:20:55 <mauke> yitz: have you been reading the preflex source?
15:21:10 <yitz> mauke: heh. no.
15:21:29 <Cale> How close is preflex to being usable as a lambdabot?
15:21:52 <mauke> good question
15:22:08 <mauke> I don't know how @run and @type work
15:22:25 <Cale> Ah, you may not have to worry about that much longer :)
15:22:36 <mauke> and there's a bug somewhere that causes it to hang
15:22:54 <yitz> mauke: perfect, just like lambdabot :)
15:22:59 <mauke> it happens when the connection drops during initialization, but I have no idea why
15:23:00 <Cale> There's a package called mueval that gwern is working on that does that.
15:23:25 <Cale> It doesn't quite do it the same way, so you'd have to work a bit to get something like @let
15:23:30 <mauke> I'm now trying to keep a strace log but it doesn't die anymore :-)
15:23:33 <Cale> But it covers most of it.
15:23:50 <Cale> hmm... I wonder if it does :t as well.
15:24:40 <yitz> "@let" has its problem. it needs a name-specific @undef, for example.
15:25:25 <Peaker> why is preflex replacing lambdabot ?
15:25:36 <mauke> heh. it isn't
15:25:36 <dobblego> lambdabot sucks
15:25:50 <yitz> @vixen lambdabot sucks
15:25:51 <lambdabot> When i get kinky, i have been known to engage in watersports... Does that turn you on as well?
15:26:07 <lispy> lambdabot could use some collaborative editing features
15:26:07 <Cale> Peaker: It's something to consider because lambdabot has lots of architectural problems on account of being old and going through lots of not-thorougly-planned-out revisions.
15:26:16 <lispy> I think that was the point of @let
15:26:43 <lispy> what is preflex?
15:26:54 <Cale> lispy: It's another IRC bot written in Haskell.
15:27:13 <dons> i think collaborative editing is what lambdabot to its current situation :)
15:27:31 <yitz> lispy: one difficulty is that even in ghci, if you change the definition of a symbol used in a let, you have to redo the second let also. that makes collaboration harder.
15:27:36 <dons> sorear did a big rewrite of the core networking, and disappeared. that probably wasn't a great idea.
15:28:01 <dobblego> @seen sorear
15:28:01 <lambdabot> I haven't seen sorear.
15:28:01 <dons> we should rewrite it based on that erlang jabber server. lots of fall over/fault tolerance and lots of threads.
15:29:01 <lispy> dons: heh, I meant collaborative in-channel editing :)
15:29:06 <lispy> not at the source level
15:29:09 <dons> we need more hands writing more code!
15:29:24 <dons> where's the next big haskell app? come on peoples!
15:29:29 <dons> more components, more systems. more fun!
15:29:56 <lispy> Hmm...I thought the sweet spot was more hands, and more re-writing :)
15:30:13 <dons> we have a lot of hands, and not enough writing, imo.
15:30:13 <yitz> dons: chris' protobufs is a first step that has a lot of potential.
15:30:25 <dons> yitz: yeah, sigbjorn also wrote an implementation
15:30:42 <yitz> dons: are they both on hackage?
15:30:48 <dons> siggy's isn't yet. the other is.
15:30:48 <lispy> FWIW, I don't think rewriting lambdabot from scratch is a good idea, but refactoring it with the goal of archetectural improvements based on what we know now is good.
15:31:06 <chessguy> what's a good indicator that you should probably start using a state monad in your code?
15:31:17 <chessguy> dons:  so sorry we don't meet up to your standards
15:31:19 <dons> chessguy: when you realise that you're passing some state around?
15:31:33 <chessguy> dons:  wow, brilliant, i never would have thought of that
15:31:40 <dons> chessguy: released any libraries this week?
15:31:43 <dons> the revolution doesn't write itself.
15:32:08 <chessguy> i'm open to suggestions
15:32:11 <dons> we can all stuff around doing amateurish stuff, and never getting passed toys, or we can actually try to build some things.
15:32:17 <lispy> I want to make iphone apps, but I don't think Haskell will work.  how would we fix that?
15:32:18 <yitz> chessguy: when your functions have arguments or output tuple types that don't really mean anything, they're just there to make it work.
15:32:34 <chessguy> lispy:  you could start by reading the long -cafe about it
15:32:35 <dons> lispy: get hugs running on the arm?
15:32:45 <Peaker> why not ghc?
15:32:45 <chessguy> s/cafe/cafe thread/
15:32:48 <dons> make it easy to install. then do some FFI bindings to the development kit.
15:32:53 <dons> or .. cross compile .
15:32:59 <lispy> chessguy: ah, I stopped reading -cafe.  too much noise.  I'll go look for it though
15:33:07 <dons> there's a huge thread on the iphone. and lots of interest.
15:33:21 <chessguy> lispy:  search ARM, not iphone
15:33:25 <yitz> dons: more Integer implementations for ghc
15:33:28 <Peaker> is the Haskell FFI stuff implemented per ABI?
15:33:50 <dons> yitz: what benefit would that have?
15:34:02 <dons> Peaker: yeah.
15:34:09 <dobblego> what was the subject of the iphone thread?
15:34:10 <dons> its portable to different calling conventions.
15:34:33 <yitz> dons: allow apps to be written that can run in non-gpl environments
15:34:34 <byorgey> different... calling conventions?
15:34:35 <lispy> ANN: Topkata ?
15:34:36 <chessguy> dons:  anyway, until i see better security/policies on hackage, i don't see why we should upload stuff there
15:34:49 <dons> yitz: gmp is lgpl though, so i don't see a problem.
15:35:03 <dons> chessguy: well feel free to have your work ignored.
15:35:10 <dons> are you proposing to help with security?
15:35:29 <chessguy> feel free to not get code from people who you treat like crap
15:35:31 <dons> or actually stating that you're refusing to contribute code till unspecified policies change?
15:35:36 <yitz> dons: no, it's a problem. less of a problem once dynamic linking is better, but that's not always a practical solution depending on specific deployment requirements.
15:35:41 * dons doesn't know what chessguy's problem is.
15:35:53 <dons> yitz: how do things like python deal with this, do we know?
15:35:59 <chessguy> blowing off a security problem is never a good idea
15:36:14 <mauke> what is the security problem?
15:36:18 <dons> chessguy: what is your concern, and why haven't you raised it in the appropriate forum?
15:36:23 <chessguy> people uploading other peoples code
15:36:26 <yitz> dons: python has their own mp implementation that seems to work well. i was actually thinking of porting it. it's pretty simple.
15:36:34 <mauke> how is that a security problem?
15:36:34 <dons> chessguy: have you followed the libraries@ thread on this topic?
15:36:41 <dons> yitz: hmm!
15:37:02 <chessguy> i saw the thread, but it doesn't seem like anything's actually been done about it
15:37:09 <dons> yes, that policy is now in place.
15:37:14 <dons> packages have been removed.
15:37:24 <dons> and maintainers are now required to be listed, or as "none".
15:37:38 <dons> so its easy to work out if it was a non-maintainer upload.
15:37:52 <dons> and policy breaches result in reverts.
15:37:59 <chessguy> how do we get a particular package removed?
15:38:16 <yitz> dons: it would be easy to port as ffi. question is - can it be made haskell using your fusion stuff at the low level it needs to be at for an Integer implementation?
15:38:16 <dons> you raise it with the libraries@ admins.
15:38:27 <RayNbow> hmm... http://lambda-the-ultimate.org/node/2905
15:38:28 <lambdabot> Title: Partial vectorisation of Haskell programs | Lambda the Ultimate
15:38:30 <dons> yitz: how would stream fusion help with integers?
15:38:42 <RayNbow> oh wait, January 2008...
15:38:47 <dons> combining multi-byte operations to avoid allocations. hmm
15:38:51 <yitz> dons: lots of tight loops in C that need to be really fast
15:38:53 <dons> yeah
15:38:56 <dons> interesting.
15:39:23 <dons> chessguy: does that answer your questions? and you're ok to upload wonderful new libraries now?
15:39:49 <lispy> I don't think targeting arm is sufficient for doing iphone dev
15:39:59 <dons> and what was the use case you were worries about -- someone uploading a fork of your code as you?
15:40:01 <chessguy> anyway mauke , maybe security isn't the right word, but i don't appreciate somebody putting my code up there and saying i'll take any bug reports on it
15:40:13 <dons> chessguy: right. that's not allowed.
15:40:18 <chessguy> if i wanted that, i'd upload it myself
15:40:22 <dons> has it happened , and why would it happen?
15:40:22 <mauke> .oO( tuomov )
15:40:50 <chessguy> dons:  yes, my GPLib code. it's nowhere near ready for primetime
15:41:04 <chessguy> but gwern apparently uploaded it under my name
15:41:14 <dons> oh, he listed you as maintainer?
15:41:22 <dons> did you raise this with ross? he'll happily remove it.
15:41:31 <lispy> interesting, gwern asked for permission before even cabalizing code I had
15:41:35 <chessguy> who's ross?
15:41:50 <dons> Ross Paterson, hackage admin. listed on the site.
15:41:56 <dons> chessguy: just ask him to remove it, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/GPLib
15:41:57 <lambdabot> Title: HackageDB: GPLib-0.0
15:42:07 <dons> on the grounds that it breaches policy. as you are not maintainer.
15:42:18 <dons> chessguy: info here http://hackage.haskell.org/packages/accounts.html
15:42:19 <lambdabot> Title: HackageDB: User accounts
15:42:20 <dons> its easy.
15:43:05 <chessguy> ok, i've heard the issue talked about several times, but never heard that anything was done about it
15:43:18 <dons> this has been done several times. just ask ross.
15:43:57 <dons> seriously, this is a solved issue. you can choose to have the package removed, or have maintained changed to "none"
15:44:00 <dons> your call.
15:44:47 <chessguy> ok, fine
15:45:15 <chessguy> as for new packages...i don't know that my haskell-foo is strong enough for stuff like that, though i'm open to suggestions
15:46:26 <dons> any code is better than none.
15:46:28 <chessguy> a mentor program would do wonders for newbies writing packages, in my opinion. something else i've suggested multiple times, and has been ignored
15:46:48 <dons> where did you suggest it?
15:47:00 <dons> sounds like something for libraries@ .. we 've a good mentor system in place for SoC
15:47:06 <dons> i see no reason why that couldn't be extended.
15:47:06 <chessguy> dons:  "any code is better than none" is a terrible strategy. bad code is much worse than no code
15:47:19 <dons> works for CPAN and ruby.
15:47:29 <chessguy> for some definition of "works"
15:47:32 <dons> best case someone fixes the code and uess it.
15:47:46 <dons> worst case, it is ignored. same as not uploading in the first place.
15:48:04 <schme_> worse is better ;)
15:48:22 <yitz> dons: not quite the same as not uploading. it spams the index.
15:48:40 <dons> well, if its really bad, yeah.
15:48:47 <shepheb> argh my parser parses "f x y z" fine, but chokes on "f (g x) y z", it never mentions y or z at all
15:48:52 <dons> but plenty of things are "good enough"
15:49:21 <mauke> when the index becomes unusable, that's when you've won :-)
15:49:36 <dons> time is short. code now is worth a lot more than code in some unspecified future, while we're trying to increase the viability of the system.
15:50:18 <dons> and for one, if you release it on hackage, you'll get two forms of feedback. 1) the system will try to build it. 2) i will try to build it.
15:50:24 <dons> if it fails, you'll get email and maybe a patch.
15:50:29 <dons> so a good incentive to dive in.
15:50:29 <lispy> For each library it would be nice to have 6-7 alternatives if choice theory has anything to say :)
15:51:03 <Peaker> lispy: did you see the google tech talk: "The Paradox of Choice"?
15:51:13 <lispy> Peaker: yeah, that's where I got that number
15:51:26 <yitz> lispy: but let's hope we don't approach ZFC choice asymptotically. :)
15:51:46 <Peaker> if _each_ library had so many, we'd be perplexed by way too many choices in a non-trivial piece of software
15:52:12 <dons> hands up if you were building a big haskell system, and got paralysed by library choice?
15:52:17 <dons> anyone? no. ok. more libraries then.
15:52:25 <thetallguy> Hmm..
15:52:26 <lambdabot> thetallguy: You have 1 new message. '/msg lambdabot @messages' to read it.
15:52:29 <thetallguy> Nope.
15:52:36 <lispy> Usually paralized by the lack of library
15:52:53 <Peaker> dons: I was a bit paralyzed by the proliferation of FRP alternate libraries :)
15:52:55 <dons> we are *not* in the position to have the luxury of sitting on code.
15:52:58 <thetallguy> well, we did have to sift through a bunch of xml/html libraries and frameworks
15:52:59 <Zao> dons: The plethora of different Array variants confuse me occasionally.
15:53:01 <Philippa> dons: took me a short while to work out what to do re web apps back when I wrote Flippi, but that was largely because things were more experimental and less reliably able to get stuff done at the time
15:53:14 <mauke> maybe I should upload a few more printf implementations :-)
15:53:19 <yitz> or by library not good enough yet
15:53:20 <Zao> And I haven't bothered to look at all the XML/HTML generating libs after investing time in WASH.
15:53:21 <Philippa> and yeah, the XML libs/frameworks're mildly offputting but I figure it's an area where I'll end up wanting the choice
15:53:40 <Philippa> mmm, WASH really needs to come with a big "not really suitable for serious use" warning
15:53:41 <thetallguy> Bbut that's because xml/html sucks and all the solutions have warts inherited...
15:53:52 <Philippa> nice idea, but didn't quite work out
15:54:00 <Zao> I haven't seen anything resembling the WASH/HTML ## combinators, so the newer ones may have some redeeming qualities.
15:54:00 <dons> when we've more libs than python for a topic, then people can work on something else.
15:54:15 <thetallguy> stepcut just released a tutorial on happs/hsp, which should help
15:54:15 <Zao> Philippa: The HTML generating part Works For Me.
15:54:16 <yitz> Philippa: so far the XML choice is healthy, each covers more or less different sweet spots.
15:54:26 <Philippa> yitz: I figured as much, yeah
15:54:34 <Zao> Philippa: What's wrong with it?
15:54:34 <yitz> The database situation is another matter though.
15:54:56 <Philippa> Zao: fair enough, though tbh I was happy just using what was Text.Html at the time
15:54:59 <thetallguy> so, yes, more libraries.  More libraries.
15:55:25 <kryptiskt> better libraries
15:55:29 <thetallguy> both
15:55:48 <Philippa> Zao: put it this way - there was no sane way to write even a trivial wiki with WASH when I last touched it
15:56:56 <dons> Philippa: braintreehemp.com.au is written in wash.
15:57:06 <dons> so if you can make money from it, its probably ok for some things.
15:57:08 <yitz> you know, the thing about haskell is that if there are enough good libraries doing the same thing in different ways, soon their'll be a higher level abstraction library. so in principle there can't be too many libraries - except that i still think we're going to need a better way to wade through the index.
15:57:20 <dons> Philippa: the author got a job at an investment bank after that.
15:57:48 <Philippa> dons: it's been a few years and I forget quite what smelled, but I'd hate to use it for anything expected to grow unless it's changed significantly
15:57:52 <dons> ><!-- generated by WASH/HTML 0.11
15:58:11 <Philippa> and technically that just tells you it uses WASH's HTML lib :-)
15:58:21 <dons> yitz: we need some kind of index abstraction
15:58:37 <Philippa> still, if you want me to do the archeology tomorrow so you can filter it for bitchiness and put up an explanation of limitations I can have a go in the evening?
15:58:52 <dons> i'd prefer to have wash uploaded to hackage.
15:59:29 <Philippa> hrmm, really it's WASH/CGI I had issues with
16:03:01 <chessguy> by the way, what is the relationship between code.haskell.org and hackage intended to be?
16:03:42 <dons> project hosting vs distribution of stable releases.
16:03:46 <yitz> chessguy: hackage is an index. code is a place to host your code.
16:03:49 <zachk> does cabal work nicely with cygwin on windows?
16:04:02 <dons> zachk: yeah, and natively on windows.
16:04:08 <chessguy> ah, so you would host it on code until it was ready to bundle up and distribute
16:04:14 <dons> yep
16:04:16 <dcoutts> zachk: no, cabal is a native application so it does not grok cygwin paths
16:04:21 <lispy> zachk: well, cabal works nicely on windows, but does cygwin?
16:04:45 <dons> this new haddocked ghc is nice.
16:04:48 <dcoutts> zachk: so it works fine with mingwin and the native command shell
16:05:02 <zachk> i hate cygwin tbh, but cabal install readline||haskeline isnt working so i need to find some, ive had mingwin problems in the past
16:05:03 <yitz> chessguy: you can keep hosting it on code as development continues, releasing often on hackage.
16:05:15 <chessguy> yeah
16:05:31 <RayNbow> dons, whom do I contact if a homepage URL on hackage is wrong?
16:05:43 <dcoutts> RayNbow: the package author/maintainer
16:06:15 <RayNbow> ah ok
16:06:37 <RayNbow> dcoutts: so not the person who uploaded it?
16:06:56 <dons> no, the maintainer. its a problem with the original .cabal file.
16:06:57 <dcoutts> RayNbow: usually the uploader is the maintainer
16:07:13 <RayNbow> ok
16:07:50 <RayNbow> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hscurses <-- btw, this is the package with a wrong homepage URL
16:07:51 <lambdabot> Title: HackageDB: hscurses-1.3, http://tinyurl.com/67bkbj
16:09:12 <dons> that is an unmaintained package unfortunately.
16:09:44 <RayNbow> oh
16:10:14 <lispy> well, not entirely unfortunate, because now RayNbow can upload a fix
16:11:03 * RayNbow does not have a hackage account :p
16:11:31 <lispy> dons: it lists a maintainer
16:11:38 <dons> as?
16:11:42 <dons> not Stefan I hope..
16:11:58 <RayNbow> it does
16:12:01 <dons> otherwise that's gwern taking liberties again.
16:12:06 <lispy> MaintainerStefan Wehr <http://www.informatik.uni-freiburg.de/~wehr/>
16:12:12 <dons> isn't the maintainer.
16:12:22 <lispy> it is a gwern upload
16:12:32 <dons> so, what could be done now is to patch the package, upload it with no maintainer
16:12:35 <dons> then both problems would be fixed.
16:12:49 <lispy> yes
16:13:09 <RayNbow> the correct homepage URL is http://www.informatik.uni-freiburg.de/~wehr/software/haskell/ btw (so the current listed URL is missing the /software/ part)
16:13:11 <lambdabot> Title: Haskell Software
16:13:14 <erikc> hrm, how would i go about debugging a readMVar that blocks indefinitely?
16:13:14 <lispy> dons: hackage planed to received comments with up and down modding, ala slashdot/reddit?
16:13:36 <dons> at some point in the future.
16:13:55 <dons> erikc: hmm. think hard about threads that take and never put.
16:14:15 <RayNbow> lispy: I don't really like reddit's mod system
16:14:18 <lispy> I think that would be nice, give people a way to comment and rate packages and a way for readers to judge the comments (so, for example, when they no longer apply they can be ignored)
16:15:19 <lispy> RayNbow: I don't like or use slashdot or reddit, but they are popular
16:16:18 <RayNbow> the problem I have with reddit's mod system is that some articles/comments get so many upmods that downmodding them is more or less useless
16:16:48 * RayNbow likes the slashdot style mod system (the Dutch tech site Tweakers.net uses something similar)
16:17:07 <yitz> RayNbow: slashdot has the opposite problem - unstylish ideas get buried
16:18:20 <RayNbow> yitz: well, I don't actually visit slashdot... I can only base my experience on what I've seen on Tweakers.net
16:19:47 <RayNbow> but probably the right mod system heavily depends on the content and the community
16:20:09 <lispy> unfortunately for me, I don't read Dutch
16:20:25 <chessguy> hm, i think the GSoC pattern could work nicely for general projects
16:22:59 <dons> i agree.
16:23:09 <dons> a clear list of mentors and a way to assign them
16:23:22 <dons> open source getting organised
16:23:35 <lispy> what is your reward/incentive system?
16:23:42 <dons> i'll write some more about in the morning, but i think this could work, chessguy
16:24:07 <dons> lispy: open source, its for the beer and lulz
16:26:34 <chessguy> dons:  and don't forget, eternal glory
16:28:54 <mar77a> http://www.supermegacomics.com/index.php?i=167
16:28:55 <lambdabot> Title: SUPER MEGA -- Updates Wednesdays and Sundays!
16:29:07 <mar77a> oops
16:35:18 <shepheb> argh I still can't parse "f (g x) y", it says unexpected y. is someone willing to have a look at this (probably terrible newbie) Parsec code?
16:35:46 <chessguy> paste it and you'll find out :)
16:36:00 <shepheb> fair enough, I guess that was a marginal ask-to-ask.
16:36:22 * shepheb double-checks the language in the comments first
16:39:56 <chessguy> wow, must be a lot of omments
16:40:00 <chessguy> +c
16:40:28 <shepheb> nah, I'm trimming a lot of commented stuff, bringing a few other bits up to date, etc.
16:41:10 <shepheb> now hpaste seems to be down?
16:41:28 <mauke> rafb.net/paste
16:42:39 <shepheb> http://rafb.net/p/1gLIUU37.html
16:42:40 <lambdabot> Title: Nopaste - Haskell Parsec problem
16:43:02 <shepheb> the interpreter part seems to be solid from my hand-constructed syntax trees
16:43:11 <shepheb> the parsers near the bottom are where I get stuck
16:43:38 <shepheb> it parses "f x y z" fine, but on "f (g x) y" it dies with "unexpected 'y'"
16:45:08 <chessguy> shepheb:  so that would be App ( Expr) Expr in your grammar?
16:45:58 <shepheb> in the grammar maybe. I think the implementation wants to read it as app (apExpr) expr
16:46:27 <yitz> shepheb: between (char '(') (char ')') expr <|> ident -- modulo spaces
16:46:29 <chessguy> hm, because it doesn't look like it could be constructed with the original grammar
16:46:37 <shepheb> the grammar and (intended correct) implementation have diverged
16:47:04 <yitz> shepheb: looks like you have spaces in too many places
16:47:16 <shepheb> should that matter?
16:47:53 <shepheb> I've been pretty cavalier about spaces. can it make the parse ambiguous?
16:48:23 <yitz> shepheb: it might mean things are less composable.
16:48:33 <shepheb> oh, hm. I guess the post-) spaces could eat up the spaces expected to separate the arguments
16:48:49 <yitz> is that why you didn't use "between" for "parens"?
16:48:59 <shepheb> no, that's because I'm new to Parsec.
16:49:01 <chessguy> shepheb:  this is for FogBuzz ?
16:49:24 <EvilTerran> shepheb, i would suggest lexing as a seperate parse, if whitespace is giving you grief
16:49:28 <shepheb> chessguy: oh, you caught the name? Joel Spolsky defined this language on the fly for my job interview with him a few weeks ago
16:49:33 <chessguy> nice
16:49:34 <EvilTerran> parsec works pretty well for lexing, too
16:49:48 <shepheb> I'm doing a co-op term/internship Sept-Dec with Fog Creek
16:49:48 <yitz> EvilTerran: good idea
16:49:57 <chessguy> shepheb:  that's awesome
16:50:00 <chessguy> congrats
16:50:02 <EvilTerran> zomg you had an interview with Joel Spolsky?
16:50:10 <shepheb> yeah, I'm super excited.
16:50:11 <EvilTerran> shepheb++
16:50:15 <EvilTerran> :)
16:50:18 <shepheb> I was shocked, too
16:50:19 <chessguy> shepheb++
16:50:26 <chessguy> we bow down :)
16:50:28 <shepheb> but they take hiring extremely seriously
16:50:48 <shepheb> I was really intimidated before the interview, but he's really approachable
16:51:06 <chessguy> i've been reading a lot of Spolsky lately, and i'm quite impressed
16:51:35 <shepheb> dmwit is actually interning there this summer
16:52:07 <chessguy> nice. are they doing haskell work up there?
16:52:30 <shepheb> okay, I'll reimplement as a two-phase lexing and parsing scheme and see how it goes.
16:53:17 <shepheb> no, they use a custom language for their internal stuff, that has back-ends for all kinds of platforms and other languages. I'm curious how functional it is
16:53:44 <chessguy> heh. cool
16:53:46 <shepheb> I'll be running xmonad (dual monitors practically demands it) and spreading the word
16:54:31 <chessguy> so i take it you're just writing this parser now for fun
16:54:51 <shepheb> oh, yeah. education and fun.
16:55:08 <shepheb> see what I can do with a super-minimal language
16:55:21 <Steve|Office> How do I tell ghc where to look for a particular module?
16:55:25 <Steve|Office> In this case, HUnit.
16:55:47 <dons> shepheb: awesome.
16:55:57 <shepheb> I intend to learn from writing the interpreter and playing with the result
16:56:05 <dons> get joel using some haskell :)
16:56:25 <chessguy> dons:  my thoughts exactly. it would awesome to see some haskell posts on joelonsoftware :)
16:56:28 <shepheb> dmwit and I were saying we were surprised how functional this mini-language he gave me in the interview was
16:56:35 <lispy> Steve|Office: use cabal :)
16:56:49 <shepheb> it was basically untyped LC with Peano numbers
16:56:59 <Steve|Office> lispy: Any other way?
16:57:18 <dons> shepheb: hehe. haskell experience is a secret weapon for interviews
16:57:31 <lispy> Steve|Office: does ghc-pkg --list show it?
16:57:44 <Steve|Office> "it" being what?
16:57:53 <lispy> er sorry, ghc-pkg list
16:57:59 <chessguy> dons:  it got me a Microsoft interview, and serious consideration
16:58:04 <lispy> Steve|Office: HUnit
16:58:04 <shepheb> yeah, I don't know how well I'd've done on that question a year ago. now it was effortless, plenty of experience with simple LC-style stuff, closures, partial application.
16:58:17 <Steve|Office> lispy: No, but I've downloaded HUnit.
16:58:47 <lispy> Steve|Office: the first step then is to [compile and] install it
16:58:54 <chessguy> shepheb:  yeah, it's interesting, that question definitely doesn't fit with his most recent writing on how to conduct an intervew
16:59:26 <shepheb> Haskell experience shows a high minimum on your powers of abstract thought, I think.
16:59:45 <Steve|Office> lispy: The user's guide gives no indication of how to do that.
17:00:14 <chessguy> shepheb:  and initiative to learn on your own, too, since you won't learn it in most schools
17:00:16 <shepheb> I had my work on xmonad on the resume, talked to Spolsky and the two other Fog Creek interviewers about it a bit. there was intrigue at the concept.
17:01:02 <dons> at which concept in particular? :)
17:01:08 <lispy> Steve|Office: is there a .cabal file?
17:01:19 <Steve|Office> I'm afraid not.
17:01:28 <shepheb> well, tiling in general.
17:01:38 <lispy> Steve|Office: a make file?
17:01:42 <Steve|Office> No, nothing.
17:02:14 <shepheb> cynically, asking about it is just one part of the good interview trifecta: they want to see your eyes light up talking about a project, they want to see you think, and they want to see you write some code.
17:02:15 <Steve|Office> Just some literate haskell files, a user's guide, a worthless README, a LIcense, and an Example.hs.
17:02:39 <Steve|Office> Surely there's a flag to tell ghc to just look in a particular directory as well, no?
17:03:20 <chessguy> i thought HUnit was in the standard libraries
17:03:22 * shepheb fails miserably at interviews with only personal and character questions
17:03:24 <Saizan_> Steve|Office: -i
17:03:44 <Steve|Office> Prelude> :m +HUnit
17:03:44 <Steve|Office> Could not find module `HUnit':
17:03:58 <chessguy> @hoogle HUnit
17:03:59 <lambdabot> Test.HUnit :: module
17:04:19 <Steve|Office> Ah, excellent.
17:04:23 * chessguy giggles 
17:04:38 <Steve|Office> It'd have been handy if the documentation had said Test.HUnit rather than just HUnit.
17:05:24 <Saizan_> which documentation? you might be looking at an old package
17:06:48 <Steve|Office> http://hunit.sourceforge.net/HUnit-1.0/Guide.html
17:06:49 <lambdabot> Title: HUnit 1.0 User's Guide
17:09:01 <Saizan_> [$Revision: 1.1 $ $Date: 2002/02/21 19:09:27 $] -- yeah, pretty old
17:09:44 <Steve|Office> Thanks for the help. I'm sure I'll be back with more shortly.
17:16:49 <chessguy> i was just looking at some (very) old code of mine, and it looks re-factorable, but i'm not sure. thoughts? http://rafb.net/p/NWL02M38.html
17:16:50 <lambdabot> Title: Nopaste - Seems re-factorable
17:17:30 <chessguy> @src join
17:17:30 <lambdabot> join x =  x >>= id
17:19:36 <chessguy> > join (,) 3
17:19:42 <lambdabot>  (3,3)
17:19:58 <sioraiocht> :t join
17:20:00 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
17:20:03 <sioraiocht> hrm
17:20:05 <sioraiocht> :t (,)
17:20:06 <lambdabot> forall a b. a -> b -> (a, b)
17:20:10 <sioraiocht> ?
17:20:22 <EvilTerran> it's using join in the (e->) monad
17:20:43 <chessguy> yeah, someone generalized (i.e., made unreadable) the @src for join
17:20:52 <mauke> er, what?
17:20:56 <chessguy> join f x = f x x
17:21:03 <mauke> join has always been a monad operation
17:21:07 <EvilTerran> join :: (e ->) ((e ->) a) -> (e ->) a
17:21:16 <EvilTerran> ie join :: (e -> e -> a) -> e -> a
17:21:34 * EvilTerran concurs with mauke. it's one of the fundamental operations of monads under some formulations, after all
17:21:56 <mauke> > runReader (join (Reader (,)) 3
17:21:57 <lambdabot> Unbalanced parentheses
17:22:03 <mauke> > runReader (join (Reader (,))) 3
17:22:04 <chessguy> hm, i could've sworn i saw a @src for it that was readable
17:22:04 <lambdabot>  Couldn't match expected type `Reader r a'
17:22:23 <chessguy> that definition should at least be mentioned
17:22:35 <EvilTerran> chessguy, join m = (do x <- m; x), perhaps?
17:23:05 <chessguy> without a type signature, i wouldn't consider that readable
17:23:17 <chessguy> certainly not for newbies
17:23:20 <EvilTerran> well, it's a pretty abstract operation
17:23:31 <chessguy> but it has a very simple concrete usage
17:23:43 <EvilTerran> i can see the use for a restricted version - maybe put it in Data.Function?
17:23:57 <EvilTerran> (along with restricted versions of &&&, ***, first, and second)
17:23:58 <chessguy> oh i'm not saying we should change the library
17:24:07 <chessguy> just saying a note in @src would be nice
17:24:13 <chessguy> a la
17:24:15 <chessguy> @src (.)
17:24:15 <lambdabot> (f . g) x = f (g x)
17:24:15 <lambdabot> -- In lambdabot, it's been generalised to:
17:24:15 <lambdabot> (.) = fmap
17:24:34 <EvilTerran> well, yes, but that's two definitions that're actually in use
17:24:51 <chessguy> hm?
17:25:12 <EvilTerran> the first is what h98 uses, the second is what caleskell uses
17:25:19 <johnnowak> @type (.) (.) (.)
17:25:20 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
17:25:23 <EvilTerran> no big haskell thing uses "join f x = f x x"
17:25:42 <chessguy> hm, ok
17:25:59 <chessguy> i thought @src was more for conceptual descriptions
17:26:24 <EvilTerran> well, yes, but conceptual descriptions of things actually in use, i guess
17:26:41 <EvilTerran> "?src (->) join" or something would be good
17:26:54 <EvilTerran> likewise "?src (->) (***)" and so forth
17:27:23 <EvilTerran> i know that's abusing the two-parameter ?src notation, but it'd be a sensible place to put those restricted pseudo-definitions, imo
17:41:18 <lispy> so if (.) can be generalized to fmap, doesn't that imply functions
17:41:25 <lispy> are functors?
17:41:29 <dobblego> yes
17:41:49 <allbery_b> @instances Functor
17:41:50 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
17:41:54 <mauke> functions are containers
17:42:02 <allbery_b> the second one is the function functor
17:42:04 <mauke> a function is its own lookup operation
17:42:41 <lispy> ?instances Monad
17:42:41 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
17:42:53 <dobblego> "functions with the first type argument applied" are functors
17:42:55 <dons> ?src fmap (->)
17:42:55 <lambdabot> Source not found. Just what do you think you're doing Dave?
17:43:04 <dobblego> @src fmap ((->) e)
17:43:04 <lambdabot> Source not found. You type like i drive.
17:43:10 <lispy> I never knew functions were Monads/Functors before
17:43:25 <mauke> @src (->) fmap
17:43:26 <lambdabot> fmap = (.)
17:43:32 <mauke> @src (->) return
17:43:32 <lambdabot> return = const
17:43:38 <dobblego> they are also Applicative! I'm using that quite heavily right now
17:43:41 <geezusfreeek> i haven't really figured out much use for the monad yet
17:43:48 <mauke> what! you can apply functions?!
17:43:49 <dobblego> (well they are monad, therefore, Applciative)
17:44:11 <johnnowak> all this time i've just been smashing them together!
17:44:16 <geezusfreeek> lol
17:44:19 <lispy> I knew about the monad instance of (->), so I do feel silly
17:45:12 <lispy> isn't it also true that all values in Haskell are functions?  just some are constant functions?
17:45:15 <geezusfreeek> hmm. now that i think about it, i guess it's a reader monad
17:45:17 <mauke> lispy: no
17:45:40 <lispy> mauke: counter example?
17:45:40 <mauke> Reader is just a newtype over (->)
17:45:47 <mauke> lispy: () is not a function
17:46:11 <geezusfreeek> ah yes. i guess i just never paid the reader definition much attention
17:46:19 <dons> though perhaps he means, functions and values have a uniform representation.
17:46:28 <lispy> mauke: please explain
17:46:31 <mauke> someone should make a http://perlmonks.org/?node_id=302287 for Haskell
17:46:38 <lambdabot> Title: How's your Perl?
17:46:46 <mauke> shepheb: see ^
17:47:26 <mauke> lispy: () doesn't have a function type and it can't be applied
17:47:40 * geezusfreeek is not arrogant enough to make one of those
17:48:10 <dancor> what regexery does lbot have in scope
17:48:24 <geezusfreeek> don't think i'm knowledgeable enough yet either
17:48:54 <dons> hmm.
17:49:09 <lispy> mauke: I just thouht it was an arity
17:49:12 <lispy> gah
17:49:15 * shepheb used to be pretty active on PerlMonks. they're good people, among the politest online communities, same as Haskell's
17:49:25 <lispy> mauke: I just thouht it was an arity-0 function that always gives ()
17:50:00 <geezusfreeek> shepheb: hope you weren't taking my "arrogant" remark as an insult to whoever made that
17:50:13 <geezusfreeek> because it was really just a joke
17:50:25 <mauke> lispy: all functions have arity 1
17:50:34 <dancor> > splitRegex (mkRegex "-") "a-b"
17:50:38 <lambdabot>   Not in scope: `mkRegex'
17:51:05 <shepheb> geezusfreeek: oh, no, certainly not. I was just commenting on PM.
17:51:15 <geezusfreeek> mmkya
17:51:55 <shepheb> geezusfreeek: I understand what you meant. I wouldn't want to write a "are you pro enough at Haskell to solve these?" because it invites retaliation and I'd be stumped easily.
17:52:13 <geezusfreeek> amen to that
17:52:30 <zachk> geezusfreeek: and Amen-Ra to that
17:53:05 <mauke> it's not necessarily about being "pro enough"
17:53:10 <dons> "are you lambda skillz mad enough" ?
17:53:19 <mauke> I don't know if you can read Perl but these exercises are completely insane
17:53:25 <mauke> especially part II
17:53:27 <geezusfreeek> needs more capital letters and numerals
17:54:01 <dons> Is you a l33t haxoring haxkeller? Solve this and show us your mad skillz1
17:54:11 <dons> ?elite Is you a l33t haxoring haxkeller? Solve this and show us your mad skillz1
17:54:11 <lambdabot> i5 joo a 1337 haXoriN9 |-|AXK3L|3R? 50L\/3 +hiz 4nD 5how u$ yOuR m4d sKI|lz1
17:54:21 <dons> m4d sKI|lz!1
17:54:57 <lispy> dump core is 6 chars?
17:55:46 <mauke> yes
17:55:46 <dons> coerce :: Float# -> Int# -- that'll do it.
17:56:21 <shepheb> hpaste isn't responding for me, is this known to be so?
17:56:25 <stepcut> Do I need to explicitly enable split-objs, or does that happen by default?
17:56:28 <dolio> > unfoldr Just ()
17:56:30 <lambdabot>  Couldn't match expected type `(a, b)' against inferred type `()'
17:56:41 <dolio> > unfoldr Just ((),())
17:56:42 <mauke> dons: too long :-)
17:56:47 <lambdabot>  [(),
17:57:03 <lispy> > iterate Just
17:57:04 <lambdabot>      Occurs check: cannot construct the infinite type: a = Maybe a
17:57:04 <lambdabot>       Expe...
17:57:06 <dolio> > length "unfoldr Just ((),())"
17:57:07 <lambdabot>  20
17:57:10 <Cale> m4d sKI|lz!!!!!1111ONEONEONEintegral from 1 to infinity of dx/x^2
17:57:37 <Quadrescence> Cale: I see what you did there...
17:57:41 * lispy takes away Cale's caffine privs
17:57:52 * osfameron wonders whether the guy that posted about the "Northwest FP group" realises that other countries also have a Northwest :-)
17:58:09 <lispy> osfameron: what other countries?
17:58:35 <osfameron> lispy: most of them actually.  I think there's a Doctor Who quote in there somewhere too...
17:58:55 <idnar> surely every country has a Northwest?
17:58:59 <idnar> by definition? :P
17:59:13 <mauke> Cale: http://www.thebestpageintheuniverse.net/images/holy_shit_iphone2.gif
17:59:15 <lambdabot> http://tinyurl.com/3y5spg
17:59:25 <dons> $ ghc --make A.hs -fvia-C -optc-O2 -O2 -no-recomp -fglasgow-exts
17:59:25 <dons> [1 of 1] Compiling Main             ( A.hs, A.o )
17:59:25 <dons> Linking A ...
17:59:25 <dons> $ ./A
17:59:25 <dons> zsh: segmentation fault  ./A
17:59:28 <dons> $ wc -c A.hs
17:59:30 <dons> 51 A.hs
17:59:35 <dons> anyone beat 51 chars?
17:59:38 <osfameron> idnar: well yeah :-)  though I suppose not all countries have a region they'll *call* northwest
17:59:52 <dolio> I met a guy once who was from 'Northeast' or something of that sort, where the town was actually named that.
17:59:52 <dons> without using the FFI, i should say.
17:59:55 <Cale> mauke: heh, fundamental trig limit :)
18:00:10 <Cale> mauke: yeah, maddox is a mathie too.
18:00:28 <idnar> we (South Africa) have a North-West Province
18:00:34 * heatsink can't connect to hpaste.org
18:01:11 <osfameron> UK has a northwest (Liverpool/Manchester/Lake District)
18:01:54 <dons> should probably file a bug report. :)
18:01:55 <dons> ?bug
18:01:55 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
18:02:03 <dolio> I think he had to answer a lot of questions about that.
18:02:33 <dolio> "Where are you from?" "Northeast, Pennsylvania." "Yeah, but where exactly." "Northeast. That's the name."
18:02:35 <mauke> dons: % wc -c try.hs
18:02:35 <mauke> 44 try.hs
18:03:19 <mauke> % ghc try.hs && ./a.out
18:03:20 <mauke> zsh: illegal hardware instruction  ./a.out
18:03:23 <dons> ah ha
18:04:07 <dons> $ ./A
18:04:07 <dons> zsh: segmentation fault  ./A
18:04:07 <dons> $ wc -c A.hs
18:04:08 <dons> 39 A.h
18:04:25 <shepheb> even better are the areas within the town. "I live in west Northeast"
18:04:45 <mauke> % cat try.hs
18:04:45 <mauke> import System.Posix;main=raiseSignal sigILL
18:04:49 <lispy> dons, mauke: but can you do it in h98
18:05:05 <dons> $ ./A
18:05:05 <dons> zsh: segmentation fault  ./A
18:05:05 <dons> $ wc -c A.hs
18:05:06 <dons> 37 A.hs
18:05:20 <dons> ah posix. that's cheating.
18:05:26 <dons> you gotta do it in pure haskell
18:05:30 <mauke> not really
18:05:37 <mauke> do you know what the perl solution is?
18:05:57 <dons> import GHC.Base
18:05:58 <dons> main=unsafeCoerce#1#
18:06:00 <dons> btw.
18:06:18 <geezusfreeek> i'm trying to decide which is less fair
18:06:24 <dons> heh
18:07:19 <lispy> I want to see it done using only things in the H98 report and excluding implementation bugs and the FFI (it would be cheating to write your own haskell compiler that always segfaults)
18:07:20 <geezusfreeek> does this require Haskell98? ;)
18:07:32 <dons> if it requires H98 then it'll be *hard*
18:07:39 <dons> you'll only be able to do it via implementation bugs.
18:07:50 <dolio> Does the FFI count has Haskell 98?
18:07:53 <dons> nope
18:07:54 <geezusfreeek> has the h98 spec been formally verified?
18:07:55 <dons> that's 2001.
18:08:02 <dons> geezusfreeek: large parts of it, yes.
18:08:09 <dons> the core language, in particular, several times.
18:08:37 <lispy> would a heap exauhstion that leads to segfault be a implementation bug?
18:08:59 <dons> hmm. yeah. it shouldn't segfault
18:09:03 <dolio> I don't know if you'll find anything in the H98 report that causes segfaults.
18:09:05 <geezusfreeek> any segfault should be
18:09:29 <dolio> Legitimately, at least.
18:10:03 <mauke> I have a possible 36 char solution
18:10:08 <mauke> anyone on 6.6? :-)
18:11:17 <ronwalf> Is hpaste down?
18:11:35 <heatsink> ronwalf: I can't reach it either.
18:12:24 * ronwalf is befuddled by: FATAL:Symbol _XJv_srt already defined.
18:12:53 <ronwalf> Only happen with ghc, not ghci
18:13:03 <ronwalf> Seems to come from a 'deriving' clause
18:13:18 <lispy> ronwalf: how are you building?
18:13:27 <ronwalf> ghc --make
18:14:07 <lispy> ronwalf: Well, that's odd.  Usually --make is pretty good I thought.  But, maybe you can still delete the intermdiate files and cause a full rebuild?
18:14:11 <lispy> That's the usual solution
18:14:42 <lispy> actually, I think the usual problem I'm thinking of is undefined symbol
18:14:44 <ronwalf> Fresh clean doesn't work
18:14:48 <lispy> So, hrm...not familiar with this problem
18:19:02 <ronwalf> Great, nondeterministic.
18:19:14 <dons> linker errors are like that.
18:19:25 <Quadrescence> Can I do arithmetic with different Word types?
18:20:01 <heatsink> Quadrescence, you can convert between word types with fromIntegral
18:20:34 <Quadrescence> :t fromIntegral
18:20:49 <lambdabot> thread killed
18:20:54 <Quadrescence> D:
18:21:02 <lispy> :t fromIntegral
18:21:06 <lambdabot> forall a b. (Num b, Integral a) => a -> b
18:21:10 <lispy> :)
18:21:35 <heatsink> In profiling, one particular function takes up much more execution time than it should.  The function has exactly one call and its callees have their own cost centers.  I'd like to reduce the execution time if possible.  How might I figure out where this execution time is going?
18:22:29 <lispy> heatsink: you can add custom cost centers
18:22:56 <lispy> heatsink: something like {-# scc: foo #-}, but that's probably not the riht syntax.
18:23:05 <lispy> heatsink: and you can add those inside expressions
18:23:27 <heatsink> I don't think there's anywhere to add a cost center.  The function is ``intersect'', here: http://rafb.net/p/R8D4GK26.html
18:23:27 <lambdabot> Title: Nopaste - Why does this take so long?
18:23:51 <heatsink> And I'm using -auto so the ``intersect'' function has a cost center.
18:24:57 <lispy> maybe it's because you use so many strict data structures?
18:25:09 * ronwalf mails the problem file off to the list
18:25:28 <heatsink> lispy: Doesn't that move the execution time to the code that creates the data structures?
18:26:52 <heatsink> Since this function isn't creating any data structures, I expect that using strict fields couldn't make its execution time longer.
18:27:02 <Quadrescence> How do I use fromIntegral to change from a Word8 to a Word16? :<
18:27:16 <heatsink> > fromIntegral (7 :: Word8) :: Word16
18:27:19 <lispy> > fromIntegral (1::Word8) :: Word16
18:27:19 <lambdabot>  7
18:27:20 <lambdabot>  1
18:27:40 <Quadrescence> Jeez, you guys are NeRds, right?
18:27:58 <EvilTerran> well, it's the obvious answer
18:28:01 <heatsink> Why?  Shouldn't everyone know how to convert a Word8 to a Word16?
18:28:13 <Quadrescence> Haha, :). Yes, everyone should know how.
18:28:14 <lispy> heatsink: what happens if you remove the strictness on the datastructres and profile it?
18:28:20 * heatsink tries it
18:28:48 <lispy> heatsink: if this changes it and you still need some strictness, you could try adding it to the function definition instead
18:29:03 <EvilTerran> betweEnum (= toEnum.fromEnum) would also work, but it's not standard
18:29:58 <lispy> Quadrescence: the long answer is that learning to use fromFoo functions in Haskell is important
18:30:33 <Quadrescence> lispy: :) Thanks. You too heatsink.
18:31:04 <lispy> Quadrescence: you're welcome, but do you understand why the solution is needed and how it works?
18:31:16 <Quadrescence> Yes, I understand perfectly now.
18:31:33 <lispy> cool
18:31:38 <Quadrescence> I understood the type, I just didn't know how to incorporate the types in the function.
18:32:48 <chessguy> > map read . split " " $ "01 02 03 04 05 06""
18:32:49 <lambdabot>  Improperly terminated string at """ (column 43)
18:33:04 <chessguy> > map read . split " " $ "01 02 03 04 05 06"
18:33:10 <lambdabot>  Couldn't match expected type `a -> f String'
18:33:12 <EvilTerran> ?type split
18:33:13 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
18:33:22 <Quadrescence> And, also, can integer tuples be compared? e.g., (1,2,3) == (1,2,3) is True.
18:33:26 <chessguy> oh, wrong function
18:33:31 <EvilTerran> there's no n-ary string splitter in the stdlib
18:33:35 <lispy> > (1,2,3) == (1, 2, 3)
18:33:37 <lambdabot>  True
18:33:40 <EvilTerran> Quadrescence, try it and see
18:33:46 <lispy> ?instances Eq
18:33:49 <Quadrescence> Haha, /me is dumb.
18:33:49 <Quadrescence> :P
18:33:53 <lambdabot> (), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
18:33:53 <shepheb> > (1,2) < (1, 4)
18:33:54 <lambdabot>  True
18:33:58 <shepheb> they're also Ord
18:34:02 <heatsink> lispy: Changing the strictness of Object and ObjectMethods has no significant effect on the % execution time.
18:34:23 <EvilTerran> and Ix, so you can use them as array indices and get effectively multi-dimensional arrays
18:34:27 <shepheb> > (1,1000) < (2,1)
18:34:28 <lambdabot>  True
18:34:28 <lispy> heatsink: then I would say thta it's a problem with the way the profiler reports the cost centers
18:34:52 <lispy> heatsink: I mean, I can't think of an excuse for that function to be so expensive
18:35:19 <chessguy_> @hoogle [a] -> [[a]]
18:35:19 <lambdabot> Data.List.inits :: [a] -> [[a]]
18:35:19 <lambdabot> Data.List.tails :: [a] -> [[a]]
18:35:19 <lambdabot> Data.List.group :: Eq a => [a] -> [[a]]
18:35:21 <chessguy_> @bot
18:35:21 <lambdabot> :)
18:35:27 <heatsink> Yeah.  I guess I'll try to make an example small enough for a bug report.
18:35:43 <chessguy_> @type break
18:35:43 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
18:36:26 <heatsink> Thanks lispy.
18:36:27 <chessguy_> @type groupBy
18:36:27 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
18:36:41 <chessguy_> oh, i'm an idiot
18:36:49 <lispy> ?hoogle [a] -> [[a]] -> ([[a]], [[a]])
18:36:50 <lambdabot> No matches, try a more general search
18:37:08 <chessguy_> > map read . words $ "01 02 03 04 05 06"
18:37:10 <lambdabot>  [Exception: Prelude.read: no parse
18:37:21 <lispy> > groupBy " " "01 02 03 04 05 06"
18:37:22 <lambdabot>  Couldn't match expected type `a -> a -> Bool'
18:37:28 <chessguy_> > read "01"
18:37:29 <lambdabot>  Exception: Prelude.read: no parse
18:37:30 <EvilTerran> > groupBy ((==) `on` (==' ')) "01 02 03 04 05 06"
18:37:31 <lispy> > groupBy (==" ") "01 02 03 04 05 06"
18:37:31 <lambdabot>  ["01"," ","02"," ","03"," ","04"," ","05"," ","06"]
18:37:32 <lambdabot>  Couldn't match expected type `[Char] -> Bool'
18:37:43 <lispy> > filter (==" ") $ groupBy (==" ") "01 02 03 04 05 06"
18:37:43 <lambdabot>  Couldn't match expected type `[Char] -> Bool'
18:37:50 <EvilTerran> chessguy_, defaulting to () :P
18:38:04 <chessguy_> lispy, EvilTerran, words is exactly what i wanted :)
18:38:17 <EvilTerran> lispy, groupBy wants an (a -> a -> Bool)
18:38:17 <chessguy_> > read "01" :: Int
18:38:18 <lambdabot>  1
18:38:19 <lispy> chessguy_: heh, oh right
18:41:40 <lispy> > filter (==) $ groupBy (==" ") "01 02 03 04 05 06"
18:41:41 <lambdabot>  Couldn't match expected type `Bool'
18:41:54 <lispy> EvilTerran: the group by works fine, it's my filter
18:41:55 <lispy> :t filter
18:41:56 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
18:42:06 <lispy> > filter (==" ") $ groupBy (==" ") "01 02 03 04 05 06"
18:42:07 <lambdabot>  Couldn't match expected type `[Char] -> Bool'
18:42:10 * chessguy__ sighs
18:42:14 <lispy> > groupBy (==" ") "01 02 03 04 05 06"
18:42:15 <lambdabot>  Couldn't match expected type `[Char] -> Bool'
18:42:15 <lispy> hmm
18:42:18 <lispy> Oh, I misread the log
18:42:27 <lispy> > groupBy (==) "01 02 03 04 05 06"
18:42:28 <lambdabot>  ["0","1"," ","0","2"," ","0","3"," ","0","4"," ","0","5"," ","0","6"]
18:42:31 <lispy> ugh
18:42:35 <lispy> Okay, words is best :)
18:42:41 <chessguy> by far :)
18:43:13 <lispy> ?src words
18:43:14 <lambdabot> words s = case dropWhile isSpace s of
18:43:14 <lambdabot>     "" -> []
18:43:14 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
18:43:17 <Quadrescence> > groupBy (/=" ") "01 02 03 04 05 06"
18:43:18 <lambdabot>  Couldn't match expected type `[Char] -> Bool'
18:43:23 <Quadrescence> :S
18:43:58 <lispy> > groupBy (\x y == x /= "") "01 02 03 04 05 06"
18:43:58 <lambdabot>  Parse error at "==" (column 15)
18:43:58 <dcoutts> dons: "Rather than generating the bytes as a list and packing them, could you instead fill a bytestring directly?"
18:44:07 <lispy> > groupBy (\x y -> x /= "") "01 02 03 04 05 06"
18:44:07 <dcoutts> dons: you know that's easier said than done.
18:44:13 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
18:44:35 <lispy> > groupBy (\x y -> x /= ' ') "01 02 03 04 05 06"
18:44:36 <lambdabot>  ["01 02 03 04 05 06"]
18:44:41 <dcoutts> dons: how do we do that? the only way I know of is the tricks we play in binary using the builder monoid. Not exactly easy.
18:45:03 <heatsink> > groupBy (\x y -> isSpace x == isSpace y) "01 02 03 04 05 06"
18:45:05 <lambdabot>  ["01"," ","02"," ","03"," ","04"," ","05"," ","06"]
18:45:19 <dcoutts> dons: perhaps the builder monoid should be in the bytestring lib
18:45:32 <heatsink> > filter (not . isSpace . head) $ groupBy (\x y -> isSpace x == isSpace y) "01 02 03 04 05 06"
18:45:33 <lambdabot>  ["01","02","03","04","05","06"]
18:46:23 <Quadrescence> heatsink: Good work. :D
18:46:30 <heatsink> :)
18:47:11 <mauke> > groupBy ((==) `on` isSpace) "01 02 03 04 05 06"
18:47:13 <lambdabot>  ["01"," ","02"," ","03"," ","04"," ","05"," ","06"]
18:47:38 <heatsink> @src on
18:47:39 <lambdabot> (*) `on` f = \x y -> f x * f y
18:47:52 <EvilTerran> it's in Data.Function in ghc 6.8
18:47:58 <heatsink> Ah.
18:48:04 <EvilTerran> (f `on` g) x y = f (g x) (g y)
18:48:18 <heatsink> Also, I didn't know you could use operator names in patterns like that.  That's cool.
18:48:26 <lispy> I find I have a mental block on `on`
18:48:37 <EvilTerran> heatsink, yup, it is
18:48:45 <dons> dcoutts: unfold or create.
18:48:51 <mauke> heatsink: operators are just variables
18:48:56 <dons> or yeah, use Data.Binary. he's generating bits, after all.
18:48:56 <EvilTerran> on f g x y = f (g x) (g y) -- lispy, is that any clearer?
18:48:58 <heatsink> mauke: Yeah, but with weird syntax.
18:49:09 <dcoutts> dons: unfold is ok for things that are relatively uniform
18:49:09 <mauke> yeah, infix instead of prefix
18:49:18 <dcoutts> dons: and create is really getting pretty low level
18:49:24 <mauke> but they're interconvertible with ` ` and ( )
18:49:36 <dons> Data.Binary does make sense here, doesn't it.
18:50:10 <dons> an arbitrarily sized , binary writing output buffer
18:50:38 <Quadrescence> > words "01 02 03 04 05 06"
18:50:39 <lambdabot>  ["01","02","03","04","05","06"]
18:50:52 <dcoutts> dons: right. Though it also seems a bit heavyweight
18:51:23 <dcoutts> dons: eg adding binary as a dep of cabal-install seems overkill and yet it's the obvious thing to use for writing out tar file entry headers.
18:51:31 <Quadrescence> > words "01           02    03  \t    04  05          \n \n \n 06"
18:51:32 <lambdabot>  ["01","02","03","04","05","06"]
18:51:37 <Quadrescence> ))))
18:52:15 <dcoutts> dons: I want to look at binary again some time. tar is a good example actually and it shows that the lack of error handling is really not good
18:52:35 <dcoutts> I need to read 512 byte packed tar headers
18:52:49 <dons> the strict, and error friendly variant seems useful.
18:53:30 <dcoutts> dons: right. I think we can steal the error handling based on continuations. Dunno about the strict though, there doesn't seem to be much point.
18:53:59 <dcoutts> for input, a lazy bytestring is a generalisation since one can pass in a single chunk
18:54:13 <dcoutts> if you really want a strict bytestring input
19:02:20 <Quadrescence> How are variables passed between modules? Can they be? Or should that just be avoided as much as possible and just keep functions in modules?
19:02:36 <Zao> Variables?
19:03:02 <dons> constants you mena?
19:03:03 <EvilTerran> we don't have no steenkin variables
19:03:18 <EvilTerran> well, we do, but we don't have globals. in h98 at least.
19:03:22 <Zao> If you mean functions without arguments, those are functions without arguments.
19:03:22 <heatsink> Quadrescence, by default all top-level variable definitions are exported from a module and can be used in other modules.
19:03:48 <EvilTerran> outside h98, you *can* "thisGlobal = unsafePerformIO (newIORef whatever)", but really shouldn't
19:04:20 <lispy> You also need to no-lineline it
19:04:33 <Quadrescence> Zao EvilTerran dons: stfu gtfo. sowwie, I know they are not VARIABLES. but you understood me I hope. :<
19:04:41 <EvilTerran> what
19:04:57 <dons> Quadrescence: no. we don't understand. that's the point.
19:04:57 <EvilTerran> there's no need for that tone
19:04:57 <dons> what do you mean.
19:05:10 <dons> do you mean mutable variables? or just constants?
19:05:15 <Quadrescence> EvilTerran: That was sarcastic, so I said sorry. :<
19:05:40 <Quadrescence> dons: I meant constants. Names assigned to [usually] numbers.
19:05:55 <EvilTerran> you export those like you export any other top-level decleration
19:05:56 <mauke> Quadrescence: "functions" are constants
19:05:59 <dons> they're normal values, so you just define an export them, if they're significant.
19:06:04 <EvilTerran> the most similar being functions with parameters
19:06:07 <dons> > pi -- for example, is significant.
19:06:14 <lambdabot>  3.141592653589793
19:06:34 <lispy> hey now mauke told me earlier that pi was not a function
19:06:40 <mauke> right
19:06:41 <lispy> So, I hope you're not trying to say otherwise
19:06:45 <mauke> well, it can be
19:06:57 <mauke> you just need an instance Floating (e -> a)
19:07:16 <EvilTerran> or you can relax your definition of functions to allow parameterless ones
19:07:23 <EvilTerran> *definition of "function"
19:07:27 <mauke> EvilTerran: then everything is a function
19:07:31 <dons> Quadrescence: so did that answer your question? export your constants freely.
19:07:33 <mauke> and the term becomes useless
19:07:36 <EvilTerran> pi is isomorphic to (\() -> pi)
19:07:39 <Quadrescence> dons: Yes. :>
19:07:58 <lispy> :t >
19:07:59 <lambdabot> parse error on input `>'
19:08:00 <lispy> :t :>
19:08:01 <lambdabot> parse error on input `:>'
19:08:03 <EvilTerran> mauke, well, it would make all bound values be functions, yes
19:08:05 <lispy> :t (:>)
19:08:06 <lambdabot> Not in scope: data constructor `:>'
19:08:41 <mauke> *> (sin + pi) 0.5
19:08:41 <mauke> 3.621018192193996
19:08:44 <lispy> EvilTerran: which if that's the case, then all bound values are monads
19:08:48 <Quadrescence> As for using functions from other modules, do I have to somehow explicitly say I want to refer to them ONLY by ModuleName.fuctionName (or maybe it's the other way around)?
19:08:52 <EvilTerran> lispy, fnord
19:09:04 <lispy> EvilTerran: fnord?
19:09:13 <EvilTerran> import qualified ModuleName -- means you have to use the prefix
19:09:14 <mauke> Quadrescence: are you talking about "import qualified ModuleName"?
19:09:21 <Quadrescence> qualified, yes, okay.
19:09:26 <EvilTerran> http://en.wikipedia.org/wiki/Fnord
19:09:27 <lambdabot> Title: Fnord - Wikipedia, the free encyclopedia
19:09:32 <mauke> import qualified Data.Map as M
19:09:32 <lispy> also, import qualified ModuleName as M
19:09:34 <mauke> > M.empty
19:09:35 <lambdabot>  fromList []
19:10:46 <Quadrescence> lispy: ah, so `as Foo' just "renames" the prefix?
19:11:04 <lispy> Quadrescence: correct
19:11:27 <lispy> Quadrescence: you can also do, import Foo(MyFoo)
19:11:40 <lispy> or any combination of the above
19:12:08 <lispy> Quadrescence: you can even do this with the Prelude suprisingly
19:12:20 <lispy> Quadrescence: and you can import an entire module and just hide some parts
19:13:12 <Quadrescence> :) Thanks.
19:13:23 <lispy> Personally, and my opinion on this is not popular, I wish Haskell modules were replaced by standard OO ad-hoc class, possible minus inheritance
19:14:08 <Pseudonym> By which you mean something like a modern ML?
19:14:18 <Quadrescence> Just as long as haskell doesn't turn OO on me. :(
19:14:25 <Pseudonym> Only with a nicer syntax?
19:14:35 <lispy> Pseudonym: I'm too ignorant to answer your question, but possibly
19:14:56 <mauke> Quadrescence: http://homepages.cwi.nl/~ralf/OOHaskell/
19:14:58 <lambdabot> Title: Haskell's overlooked object system
19:15:09 <Pseudonym> I do agree that Haskell's module system is the absolute bare minimum required to be useful.
19:15:18 <Pseudonym> And we could do a lot better.
19:15:23 <lispy> Quadrescence: it's already been demonstrated that OO, in many variations, can already be encoded in Haskell.  And depending on which features you want you can use a library to get all of them
19:16:47 <shepheb> hm. when I'm writing a chainl1 for left-associative juxtaposition application, what's the stop condition?
19:16:52 <lispy> Pseudonym: I haven't tried it, but I think the issue with top level mutable values could be solved if modules had constructors and multiple instances of the module could exist.  I also think it would give a nicer mechanism to talk about which functions in the module should be exposed at what granularity
19:17:25 <shepheb> using tokens and not Chars this time
19:17:26 <Pseudonym> I think you're identifying the right problems, but not necessarily the right solutions.
19:17:28 <Quadrescence> lispy: I more meant, as long as haskell doesn't turn java on me. :/
19:17:45 <Pseudonym> I suspect that the "right" answer is something that can implement OO, but doesn't necessarily look like OO.
19:18:20 <Pseudonym> Yes, what you descriube (i.e. instantiable modules) is part of the feature set that we'd like.
19:18:51 <lispy> I'm not sure how inheretance would be genuinely useful for the module system and hence I don't see a reason to add it
19:19:11 <lispy> Nor does message passing seem like such a great idea
19:20:18 <lispy> On the other hand, a book I read in college about OO suggested that the parameterizable, instantiable module system was an important step on the way to modern OO
19:20:25 <pejo> lispy, why not? The erlang people are doing it and loving it.
19:20:33 <lispy> So, I have a hunch if we added those features, OO might be inevitable :)
19:21:04 <mauke> it didn't look like it in OCaml
19:21:31 <lispy> pejo: It seems to me that Haskell could do erlang style message passing without a single modification.  I meant more of the small talk idiom, where all function calls require an object and they send it a message
19:21:54 <mauke> functions are objects
19:21:59 <mauke> messages are arguments
19:22:11 <od> well alot of Erlang is the OTP lib
19:22:24 <od> would prob be nicer if they just switched to haskell for their core lang haha
19:22:58 <lispy> Then, maybe someone should port OTP to Haskell as a proof of the concept :)
19:23:08 <lispy> od: I nominate you :)
19:23:09 <pejo> od, well, John Hughes commented on quickcheck for erlang - the good part was that they had no pesky type system, and the bad part was that they didn't have a type system.
19:26:18 <lispy> languages without static type checking strike me as good for short periods of code where you're prototyping
19:26:38 <lispy> But, I find that for anything more substantial, I begin to miss the type system
19:27:19 <Pseudonym> lispy: Actually, Haskell couldn't do Erlang-style message passing.
19:27:29 <Pseudonym> The thing about Erlang is that each thread has its own heap.
19:27:44 <Pseudonym> Haskell, on the other hand, depends crucially on data sharing.
19:28:04 <lispy> has it's own heap eh?  I didn't realize that
19:28:10 <Pseudonym> Yes.
19:28:18 <lispy> So, the threads are pretty isolated?
19:28:22 <Pseudonym> That's one way it achieves real-timeness.  You can garbage collect threads separately.
19:28:31 <Pseudonym> It's also how it achieves distributedness.
19:29:15 <pejo> What mechanisms for real-time does Erlang have?
19:29:53 <Pseudonym> Note that "real-time" in this case means soft real-time.
19:30:09 <Pseudonym> But that's the main feature: No GCs in odd places.
19:30:18 <Pseudonym> The rest is more or less up to you.
19:30:26 <Pseudonym> IIRC
19:31:01 <Quadrescence> If I have `data Tree = Node {value :: CubeEnc, branches :: [Tree]}', do you guys think it would be at all necessary to add a depth number to that?
19:31:18 <pejo> Soft real-time seems even harder, you need plenty of analysis to know that it will complete a task before a deadline in x % of the time. But it seems real-time in the same way C is then.
19:32:43 <Pseudonym> You have to remember that Erlang was designed for telephony.
19:33:02 <heatsink> Quadrescence, will it be useful for any of the functions you're going to write?
19:33:21 <Pseudonym> It has just enough real-timeness to support ATM routing.
19:34:00 <Quadrescence> heatsink: Well, I want to search the trees breadth first.
19:34:10 <Quadrescence> I am not quite sure how I will yet. :/
19:35:19 <syscrash> i have a function that uses 'head' on a list. i was wondering how to best return False when the list is empty (head throws an exception). the code is at http://pastebin.ca/1078027 , the function is 'ambiguous'
19:35:31 <heatsink> Quadrescence, You don't need to store a depth value in the tree to do breadth-first search.
19:36:17 <mauke> syscrash: don't use head on a possibly empty list
19:36:19 <Quadrescence> heatsink: I didn't think so. I don't think it would be advantageous... I am really going to be generating the tree, and probably analyzing it at the same time.
19:36:20 <heatsink> syscrash, use case to deconstruct the list.
19:36:46 <syscrash> alright, thanks
19:39:03 <Quadrescence> heatsink: However... I need to do this: (1) Generate a new node, (2) check if the value at that node has been generated in the tree at a _lower depth_, and if (i) it has, don't create more branches at that node, and (ii) it hasn't, create branches, (3) repeat for the rest of the nodes at that depth, (4) go to next depth until tree is complete.
19:39:20 <Quadrescence> I just don't know how I will do all this. :S
19:40:08 <heatsink> Quadrescence: Is it a functionally defined tree?  Can you define the entire tree (lazily) before you start?
19:41:32 <Quadrescence> Maybe you can tell me. There are an equal number of branches at each node (except the root node), and each branch does the same operation on the node to the new node.
19:42:21 <heatsink> It sounds like you can define the entire tree at the outset.
19:42:46 <heatsink> mkTreeNode x = TreeNode (f1 x) (mkTreeNode (f2 x)) (mkTreeNode (f3 x))
19:44:11 <Quadrescence> And that would be lazily evaluated, right?
19:44:36 <heatsink> yea
19:45:24 <Quadrescence> Hum. Would I account for the termination of the creation of branches at a node in mkTreeNode?
19:45:48 <heatsink> what?
19:46:49 <Quadrescence> heatsink: from above: ...(2) check if the value at that node has been generated in the tree at a _lower depth_, and if (i) it has, don't create more branches at that node...
19:48:02 <Quadrescence> And I am saying, in the function mkTreeNode that you just stated (as an example above), would I account for this?
19:49:02 <heatsink> Wait.  By "lower depth", do you mean closer to the root, or farther from the root?
19:49:20 <Quadrescence> closer to the root. Numerically. Not...graphically
19:49:27 <Quadrescence> Sorry 'bout that.
19:49:53 <heatsink> Okay.  Could it be closer to the root, but along some other path?
19:50:37 <Quadrescence> Yes. The nodes are _NOT_ unique.
19:51:18 <Quadrescence> Which is why I have to terminate branching at nodes so the tree doesn't grow infinitely.
19:51:55 <heatsink> Okay.  Well, you can still build it lazily.  Instead of terminating the tree at those nodes, you terminate the _evaluation_ of the tree at those nodes by not visiting their children.
19:52:12 <Quadrescence> Right, yes.
19:56:20 <dcoutts> woot!
19:56:48 * dcoutts manages to get his tar code to do byte for byte round trip in ustar and gnu tar formats for the hackage index tarball
19:58:46 <heatsink> Quadrescence: So that means you have your tree data structure.  For (4) you will need a way to find the nodes at depth D+1 given the nodes at depth D.  For (2) you will need a way to find all nodes at depth <= D, given the nodes at depth D and all nodes at depth less than D.
20:00:14 <heatsink> I think that covers everything.
20:00:36 <dons> dcoutts: you're trying to drop the tar dep?
20:00:39 <Quadrescence> Eek. D:
20:01:27 <dcoutts> dons: there is no tar dep at the moment, but I now want to generate the tar index too, not just read an extract it. So it's important we do it reliably.
20:01:37 <heatsink> Quadrescence: If there are two identical nodes at the same depth, do you want to visit them both?
20:01:45 <Quadrescence> heatsink: Yes.
20:02:14 <heatsink> ok
20:02:19 <dcoutts> dons: currently hackage uses gnu tar and the .cabal files are kept on disk. For the happs based server the .cabal files are kept in memory as is the tar index. So we generate it all in memory.
20:02:28 <dons> ah ok.
20:02:56 <dcoutts> dons: having decent tar code will also let us check the tar files people upload. Sanity and format check them.
20:03:10 <dcoutts> eg check for non-portable stuff
20:04:34 <shepheb> if I can ask for more Parsec help, there's an error message included here that I can't figure out: http://rafb.net/p/F5m94n10.html
20:04:35 <lambdabot> Title: Nopaste - Parsec error message
20:04:59 <swalters> *LOL*
20:05:24 <swalters> dang... wrong window...
20:05:57 * shepheb thought his n00bness wrt Parsec was being ridiculed there
20:12:25 <lispy> http://haskell.pastebin.com/f33c91b2d
20:14:05 <lispy> Any thought?  I'm dying on something that changed in the type checker in ghc-6.8, but I don't understand my error message
20:16:47 <Saizan_> lispy: try rewriting the case expression as an helper function and give a type signature to it
20:17:37 <Saizan_> lispy: that error comes when it can't/doesn't bother to decide a type for the argument
20:19:16 <lispy> hmm...but 6.6 could/did...
20:19:28 <Saizan_> a type annotation on the expression between case .. of should work too
20:20:14 <heatsink> shepheb, you will probably get a more useful error message if you give an explicit type signature to mytoken.
20:20:27 <Saizan_> i don't know the details, but that's how i usually manage that error
20:20:40 <shepheb> heatsink: argh, it's complicaed. I'll give it a try in a moment.
20:20:51 <dogbite> is pastebin the new hpaste? :-)
20:21:19 <dogbite> hpaste is down, right?
20:21:26 <gwern> lispy: are you banging your head against darcs agin?
20:21:39 <lispy> Saizan_: hmm. my new type is rejected for other reasons
20:22:07 <lispy> gwern: basically.  I figure it will be useful to understand why you can't compile darcs with 6.8
20:22:33 <gwern> lispy: I could compile fine if roundy would stop being an ass about the whole 'we should be broken by default'
20:22:47 <gwern> srsly, I don't think I've ever seen such a situation elsewhere
20:22:50 <lispy> gwern: not with type witnesses you can't
20:23:39 <gwern> (if they only need to compile once to be a proof everywhere, then you would think that would be an argument for them not being default, but somehow with him it's the other way around)
20:24:08 <lispy> type witnesses are not the default
20:24:49 <gwern> lispy: you know I'm complaining about the record hook here
20:27:55 <Saizan_> lispy: that compiles -> http://haskell.pastebin.com/mcbabd55
20:28:11 <Quadrescence> If I have data Sex = Sex {tex :: USAState, mex :: NACountry}, and it just so happens USAState and NACountry = [(Int,Int)]'s, then I can do: (let) tRex = Sex {tex = [blablabla], mex = [blablabla]}, RIGHT? Or is something syntactically incorrect?
20:28:54 <Quadrescence> assume blablabla is something like (1,2). :P
20:28:57 <lispy> Saizan_: interesting, that's quite different than the fix I did
20:29:47 <shepheb> heatsink: didn't help, error is the same
20:30:01 <heatsink> Quadrescence: yea
20:30:16 <Quadrescence> Good work, team. (heatsink)
20:31:21 <lispy> Saizan_: thanks
20:31:38 <Saizan_> lispy: np
20:33:28 <lispy> oy, I think we have to get rid of all our case expressions :(
20:36:34 <Quadrescence> What would haskell recommend I use (list or tuple): The 'set' of items will be used to cycle another set. (i.e. it's a permutation).
20:38:00 <dublpaws> minimum [(1, someDataType), (0, someDataType)] where someDataType is of no consequence in the comparison.  Is there a way for the minimum func to disregard the second item of the tuple?
20:39:06 <heatsink> dublpaws, minimumBy
20:39:11 <dublpaws> ah, thanks
20:40:16 <heatsink> Quadrescence, probably a list.  If they're all the same type, usually the solution is a list.
20:40:31 <Quadrescence> THat's what I thought. :}
20:40:53 <Quadrescence> I'm sure it could be done with a tuple, but lists are more...workable sometimes. :}
20:41:14 <Saizan_> lispy: http://haskell.pastebin.com/m2f5ec948 <-- this also works, using case
20:41:58 <lispy> Saizan_: ah, so it's not the argument type after all but the expression type
20:41:59 <heatsink> shepheb: notFollowedBy requires a parameter that returns a token.  You can't use the parser (notFollowedBy eof) for example.
20:43:07 <Saizan_> lispy: i'm not sure, since it can infer the type of the expression by itself
20:43:09 <shepheb> heatsink: I suspected something like that was wrong. I'm not sure how to represent juxtaposition in a chainl operator condition, then. should it just be "return A"?
20:44:36 <shepheb> using return A makes sense on one level, but on another it doesn't seem like it should ever stop.
20:45:58 <heatsink> :me doesn't know what chainl1 does
20:46:02 * heatsink doesn't know what chainl1 does
20:47:00 <shepheb> it's a left-recursive grammar: app ::= something app
20:47:32 <shepheb> but every example I've seen expects * or + or something to be between the values, where here they're just juxtaposed
20:50:27 <lispy> Saizan_: adding a type sig between case ... of doesn't always ork
20:50:30 <lispy> +w
20:51:29 <monochrom> You can use "many1 something" to obtain a list, then build your app term.
20:52:12 <heatsink> shepheb: It appears to work with just (return A), but the many1 would be more readable.
20:52:56 <shepheb> many1 what, though?
20:53:09 <heatsink> many1 func
20:53:20 <monochrom> Example.  many1 something >>= foldl1 App   this will parse "s0 s1 s2" into App (App s0 s1) s2
20:53:28 <shepheb> hmm
20:53:51 <shepheb> and then I guess I can foldr them into my structure
20:53:53 <monochrom> You said your grammar is " app ::= something app".  I'm using the same "something".
20:54:26 <shepheb> and then the associativity is determined by which fold I use
20:55:53 <shepheb> ugh that makes so much more sense
20:56:11 <shepheb> I've been beating my brain against chain* for hours
20:59:27 <T-Cell_> What are the advantages of using the HAppS.Server over Network.CGI?
21:02:06 <thetallguy> T-Cell_: primarily, all is done in the main process.  The CGI forks an external program.
21:02:55 <thetallguy> T-Cell_: and then you can use the HAppS in memory database and transactions
21:06:59 <shepheb> is there a way to get Parsec to output the "parser stack", meaning the sequence of combinators that parsed the output?
21:14:46 <shepheb> victory! lexer part was broken
21:15:09 <shepheb> fixed that and bam. need to check some more cases, but promising; it's never parsed that one correctly before
21:20:27 <shepheb> heatsink, monochrom: thanks much for your help
21:21:06 <T-Cell_> thetallguy, hmm.. well, I've never dealt with memory database and transactions, but it seems to me Network.CGI works just fine for developing Haskell web applications.
21:21:12 <T-Cell_> After web programming in Haskell for almost a year now, I've concluded that there is almost nothing that can't be done using Network.CGI
21:22:37 <T-Cell_> HAppS seems a bit complex, and CGI so simple..
21:35:12 <thetallguy> T-Cell_: no question, HAppS has a steeper learning curve
21:36:07 <thetallguy> T-Cell_: but it is designed to scale better, providing both more speed and reliability
21:40:29 <Quadrescence> Are there any "swap" functions for lists? Or cycling functions (for permuting elements)
21:40:31 <Quadrescence> ?
21:41:33 <thetallguy> by swap, you mean  [1,2,3,4] -> [2,1,4,3]?
21:41:38 <Quadrescence> Yes
21:41:48 <TSC> Not in the Prelude, but they're not hard to write
21:41:54 <TSC> Typically O(N)-ish, though
21:42:05 <thetallguy> I think cycle is around someplace
21:42:27 <Steve|Office> > take 15 $ cycle [1..4]
21:42:27 <Quadrescence> cycle just takes a finite list and basically cons's it to itself however many times
21:42:42 <lambdabot>  thread killed
21:42:43 <Steve|Office> > take 15 $ cycle [1..4]
21:42:47 <lambdabot>  [1,2,3,4,1,2,3,4,1,2,3,4,1,2,3]
21:42:52 <Steve|Office> lambdabot is giving me no love.
21:43:02 <Quadrescence> It did that correctly.
21:43:18 <thetallguy> she just wants more attention
21:43:22 <Steve|Office> It took two tries though.
21:43:39 <Quadrescence> @botsnack
21:43:39 <lambdabot> :)
21:43:49 * Quadrescence pets lambdabot.
21:43:59 <Steve|Office> @botsmack
21:43:59 <lambdabot> :)
21:44:07 <Quadrescence> Hahah
21:44:38 <thetallguy> > let f (x:y:ys) = y:x:(f ys) in f [1,2,3,4]
21:44:39 <lambdabot>   Non-exhaustive patterns in function f
21:44:51 <thetallguy> Yes, dear, I know.
21:45:19 <thetallguy> > chunk 5 (replicate 10 10)
21:45:20 <lambdabot>   Not in scope: `chunk'
21:45:24 <Quadrescence> > let f (x:y:ys) = y:x:ys in f [1,2,3,4]
21:45:25 <lambdabot>  [2,1,3,4]
21:45:34 <thetallguy> Oh, right, I forgot to submin that
21:46:18 <Quadrescence> :< But I want something like f :: Int -> Int -> [a] -> [a]
21:46:20 <Quadrescence> :/
21:46:21 <thetallguy> Quadrescence: is that what you wanted, just the first two swapped?
21:46:38 <thetallguy> oh, like an array swap?
21:46:45 <Quadrescence> Yeah.
21:47:16 <Quadrescence> Any two elements. Or even more preferably, if I have a list defining a permutation, the elements of another list will be permuted like so.
21:47:26 <thetallguy> Oh
21:47:36 <thetallguy> Define your permutation as a function.
21:47:56 <thetallguy> after all, permutations *are* functions, they aren't really lists
21:48:24 <thetallguy> I wrote that code once.  Wonder where it is...
21:48:54 <Quadrescence> For example: permutation = [3,1,2,4], exList = [a,b,d,c], permute permutation list = [b,d,a,c]
21:49:36 <Quadrescence> (first element goes to 3, second goes to 1, third goes to 2, fourth stays in 4)
21:50:16 <zachk> whats the type for a ratio integer?
21:50:20 <Quadrescence> Or even better, it'd be nice if the number IN 3 went to 1, the element IN 1 goes to 2, etc
21:51:01 <Quadrescence> zachk: Ratio?
21:51:14 <Quadrescence> :t (%)
21:51:18 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
21:51:26 <shepheb> :t Rational
21:51:27 <lambdabot> Not in scope: data constructor `Rational'
21:51:30 <shepheb> :i Rational
21:51:36 <shepheb> @info Rational
21:51:36 <lambdabot> Rational
21:51:44 <shepheb> yeah thanks
21:52:04 <shepheb> GHCi gets it right: Rational = Ratio Integer
21:52:44 <thetallguy> Quadrescence: http://hpaste.org/9060
21:54:12 <Quadrescence> thetallguy: :O :O :O
21:55:01 <thetallguy> Quadrescence: I'm not familiar with that expression...but I trust that heads in the correct direction?
21:55:47 <Quadrescence> It looooooks like it. :OOOO
21:56:28 * zachk refrains from nsfw ascii ~art 
21:56:45 <Quadrescence> thetallguy: Are you Mr. C. Beshers?
21:58:06 <zachk> can haskell, using read, "read" strings like "-15/2"
21:59:08 <thetallguy> Quadrescence: Yes
21:59:34 <thetallguy> sorry, I should have said:  Who wants to know?
21:59:36 <thetallguy> lol
21:59:56 <Quadrescence> Is the BSD3 license essentially "use but don't sell"?
22:00:01 <thetallguy> no
22:00:07 <Quadrescence> D:
22:00:13 <thetallguy> it's pretty much do whatever you like
22:00:34 <thetallguy> If you make money off that code, more power to you
22:00:48 <Quadrescence> thetallguy: Then I recommend http://en.wikipedia.org/wiki/WTFPL
22:00:49 <lambdabot> Title: WTFPL - Wikipedia, the free encyclopedia
22:00:50 <thetallguy> tithe 10% to a Haskell scholarship
22:01:10 <thetallguy> BSD3 is standard in the Haskell community
22:01:16 <Quadrescence> Ah
22:01:16 <Quadrescence> :D
22:01:57 <zachk> > read "15/2"::Rational
22:02:03 <lambdabot>  Exception: Prelude.read: no parse
22:02:09 <stepcut> BSD3 == do whatever you want, but don't blame me if it does not work. do give me credit for the code I wrote, but don't claim that I endorse your product.
22:02:36 <Quadrescence> lambdabot: True
22:02:38 <Quadrescence> :D
22:03:06 <jbapple> > read "15%2" :: Rational
22:03:08 <lambdabot>  15%2
22:03:40 <zachk> oh <expletive deleted>
22:04:01 <jbapple> it's ok, you can curse here.
22:04:15 <jbapple> <expletive inserted>
22:04:26 <zachk> s/<expletive deleted>/wtf/
22:04:38 <Quadrescence> What is a license that is generally looked down upon? :)
22:05:37 <zachk> the one thats goes if you run this code your children are now my bond servants until they die
22:05:51 <Quadrescence> No srsly.
22:06:21 <Quadrescence> thetallguy: If this works, you get a very special place in my code. :D
22:06:30 <zachk> per seat+computer licensing fee's with active auditing
22:06:35 <thetallguy> Quadrescence: woohoo!
22:06:54 <thetallguy> I'm tired of my apartment anyway
22:07:06 <Steve|Office> Quadrescence: Most EULA.
22:07:32 <dublpaws> I hear Spore's license only allow 3 installs or some small number
22:07:36 <Quadrescence> thetallguy: :D
22:08:00 <thetallguy> just so long as you're not writing a Tron simulator
22:08:01 <Quadrescence> I don't mind people trying to make money through their software, but...some things are ridiculous.
22:08:27 <Steve|Office> The GPL for claiming that it's free when it is in fact the most restrictive open source license.
22:09:09 <thetallguy> speech, not beer
22:09:16 <thetallguy> Hehe
22:09:26 <Quadrescence> THIS is stupid: http://www.abacre.com/afr/purchase.htm
22:09:26 <lambdabot> Title: Advanced Find and Replace - Purchase Page
22:09:29 <zachk> my read dont parse "15%2" :-(
22:09:29 <Quadrescence> And outrageous.
22:09:33 <Steve|Office> Also GPL because Stallman is insane.
22:11:02 <od> lol 2k$ to replace text in files
22:11:19 <Quadrescence> od: Hahaha, I know.
22:11:41 <TSC> It's ADVANCED replacing, mind
22:11:49 <Quadrescence> Oh shi-
22:11:55 <Quadrescence> ADVANCED.
22:12:41 <thetallguy> How much you want to bet you buy food products that a chef considers ridiculous?  Or car service.  Or plumbing...
22:13:13 <od> yea wouldnt surprise me
22:15:30 <shepheb> there are endless businesses whose success relies on the ignorance, laziness or poor decisions of others
22:16:13 <Quadrescence> Especially when people want the BestBuy.
22:16:19 <Quadrescence> Oops, camel case on accident.
22:16:25 <Quadrescence> And I forgot a space. :\
22:22:09 <dobblego> which paper talks about pure programming leads to composing larger blocks from smaller ones? I thought it was WhyFP
22:23:23 <andyjgill> Why FP certainly talks about this.
22:23:43 <dobblego> yeah I was just looking in the wrong place, cheers
22:24:42 <thetallguy> andyjgill: any tornadoes?
22:24:49 <shepheb> asks is how one extracts a field from a (runtime-immutable) Reader, gets retrieves a field from the runtime-mutable State.
22:24:52 <shepheb> mischan
22:25:00 <andyjgill> Not so far
22:26:51 <andyjgill> I did have a moment a few weeks ago that it occurred to me that my car might get blown over as I turned a corner in high, localized winds, with sideways rain.
22:28:36 <thetallguy> wow
22:28:52 <thetallguy> The midwest weather is always exciting
22:28:59 <thetallguy> often
22:32:10 <andyjgill> Its not that bad, really.
22:41:42 <thetallguy> andyjgill: I love it actually.  I miss the thunderstorms.
22:42:26 <thetallguy> andyjgill: San Diego has very calm weather, mostly.  I was just in MN and the clouds were amazing.
22:42:27 <Trinithis> what does the "exp" function in the Floating class do?
22:42:46 <Trinithis> Fractional class*
22:42:59 <Trinithis> err... floating :)
22:43:07 <Trinithis> > exp 4
22:43:09 <thetallguy> computes e^x
22:43:13 <Trinithis> ok
22:43:14 <lambdabot>  54.598150033144236
22:43:21 <thetallguy> >exp 1
22:43:33 <thetallguy> > exp 1
22:43:35 <lambdabot>  2.718281828459045
22:43:42 <Trinithis> > exp $ log 1
22:43:43 <lambdabot>  1.0
22:45:39 <dobblego> @type concatMap
22:45:40 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
22:46:18 <andyjgill> Because its my first year, I'm never sure what weather to expect next month :-)
22:50:34 <dobblego> are the dynamic pure languages?
22:50:39 <dobblego> *are there
22:50:47 <dobblego> *dynamically-typed
22:51:43 <mattr__> none that I know of
22:51:45 <cjs> I've never heard of one.
22:52:16 <QtPlatypus> The simply typed lambda calculis.
22:52:34 <QtPlatypus> Pure lisp.
22:53:10 <olsner> I guess you could code in the pure subset of any dynamically-typed language, if that counts as being pure
22:53:47 <QtPlatypus> http://en.wikipedia.org/wiki/Lispkit_Lisp
22:54:15 <olsner> dobblego: build a pure python dialect
22:56:00 <koninkje> Is there a preferred place to put modules for different numeric representations? I see Data.*, Data.Number.*, and Numeric.* with similar frequencies
22:57:40 <mattr__> QtPlatypus: nice find - that looks like fun
22:58:24 <QtPlatypus> mattr__: Thanks, yay half recalled fortune text.
23:28:40 <ski> Do push-ups
23:28:44 <ski> Then a sauce
23:28:46 <ski> Evade
23:31:07 <jekor> Is there a way to create a Parsec parser that acts as a preprocessor? I'd like to parse a LaTeX file for specific environments (\begin{something}...\end{something}) and just pass through the rest unchanged.
23:31:30 <jekor> I have a parser that uses a couple hacks, but it's turning into a nightmare.
23:34:01 <jekor> http://hpaste.org/9061
23:35:00 <thoughtpolice> holy crap it's a miracle. darcs actually managed to get the latest GHC sources.
23:44:29 <_zenon_> ski, you lost me there.
23:46:09 <_zenon_> jekor, your problem seems like a normal parsing problem. I'd recommend BNFC (but I always recommend BNFC) :)
23:46:39 <_zenon_> jekor http://www.cs.chalmers.se/Cs/Research/Language-technology/BNFC/doc/BNF_Converter_Haskell_Mode.html
23:46:42 <lambdabot> Title: The BNF Converter: Haskell Mode, http://tinyurl.com/6qubxy
23:48:00 <jekor> _zenon_: Thanks, I'll check it out.
23:48:53 <_zenon_> jekor, BNFC is really nifty, you could define things like  InBegin ::= "\begin{" Env "}" Body "\end{" Env "}"
23:51:24 <jekor>  It looks like it would make the parsing easier, but I'm trying to figure out how to use it to create nodes of "not interesting, but need it in the parse tree".
23:53:37 * ski evades _zenon_'s perplexed stares
23:54:31 <_zenon_> ski, have you been playing FPS lately?
23:55:00 <ski> `FPS' being what ? .. "frames per second" ?
23:55:19 <_zenon_> First Person Shooter
23:55:25 <ski> oh
23:55:57 <ski> not very lately, no
23:56:36 <_zenon_> okay
23:57:31 <ski> (i assume the most recent would be playing "Blue Shift")
23:57:51 <ski> (why ?)
