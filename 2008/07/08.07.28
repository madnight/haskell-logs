00:00:33 <vincenz> @seen twanvl
00:00:34 <lambdabot> I saw twanvl leaving #haskell, #haskell.dut and #ghc 6h 4m 34s ago, and .
00:00:42 <|Steve|> and .
00:00:55 <|Steve|> @botsmack
00:00:55 <lambdabot> :)
00:01:04 <vincenz> @botcrack
00:01:04 <lambdabot> :)
00:01:18 <|Steve|> @botwhack?
00:01:19 <lambdabot> Unknown command, try @list
00:06:46 <_zenon_> oh no. level is critical
00:07:02 <_zenon_> 8 users from hullbreach
00:08:05 <chrisdone> hm
00:09:22 <mmorrow> apparently, QuasiQuotes use [$qq||] rather than [:qq||] (as it originally was in the paper) because the semicolon conflicts with parallel list syntax
00:09:45 <dolio> Oh, right.
00:10:37 <mmorrow> that never would of occured to me had i not read it somewhere
00:11:49 <mmorrow> with parlists being used so much they're in danger of wearing out and all
00:13:35 <Cale> I can't express how frustrating to me it is that so many people abuse the term 'closure' to mean 'first class function'
00:14:01 <dolio> :)
00:14:02 <Cale> Closures are not functions, they are pairs! >_<
00:14:15 <|Steve|> Pair of environments and functions?
00:14:23 <|Steve|> er, pairs*
00:14:50 <Cale> Pairs of environments and code for functions which still has free variables in it.
00:15:15 <Cale> That is, usually a map, and some kind of abstract syntax tree.
00:15:19 <|Steve|> It need not have any free variables and any that it does have had better be in the environment.
00:15:25 <Cale> Right.
00:15:26 <ziman> cannot closures be considered functions having the free variables as parameters?
00:15:51 <Cale> ziman: not really...
00:16:08 <Trinithis> would it be faster to pattern match against 100 Integer cases or to do a lookup in a Map?
00:16:17 <Cale> Trinithis: I bet the lookup.
00:16:33 <Trinithis> Plus, it would solve my splice delimma
00:16:53 <Cale> ziman: Though I suppose the 'code' part of a closure could be seen that way.
00:17:39 <Cale> Usually the code part of a closure is still syntax, and not directly a function in the language, though that might be appropriate in an interpreter.
00:18:05 <krassik> Did anyone used libcurl binding in Windows?
00:18:06 <Cale> Or I suppose it could be a function from the free variables to abstract syntax.
00:18:41 <krassik> Prelude Network.Curl> curlGetString  "http://www.google.com" [] Loading package array-0.1.0.0 ... linking ... done. Loading package containers-0.1.0.2 ... linking ... done. Loading package curl-1.3.2.1 ... can't load .so/.DLL for: curl (addDLL: unknown error)
00:18:42 <lambdabot> Title: Google
00:18:44 <hackage> Uploaded to hackage: cedict 0.2.1
00:18:55 <Cale> But in any event, closures much more resemble pairs than functions, and it's important not to confuse the two.
00:19:22 <rwbarton> Cale: Isn't it even worse to abuse 'function' to mean 'code with arbitrary side effects that returns a value'?
00:19:36 <Cale> rwbarton: yes
00:19:44 <Cale> rwbarton: Procedure is a better term for that
00:20:00 <krassik> I tried placing this (libcurl.dll) in almost any location I could think of. Same result :(
00:20:22 <Cale> So yeah, in a lot of languages, it would be first class procedures.
00:20:27 <Cale> In any event, it's not closures :)
00:22:35 <Twey> Don't be silly, Cale
00:22:46 <Twey> A procedure is a function that doesn' return a value!
00:22:49 <Twey> doesn't**
00:23:02 <Twey> VB says so!
00:23:05 <Trinithis> haha
00:23:29 <lament> Pascal, too, iirc
00:23:34 <dublpaws> yeah
00:23:42 * Twey shudders.
00:23:50 <Twey> 's as bad as Ruby's blocks
00:24:03 <lament> what's wrong with blocks?
00:24:04 <Twey> A.K.A. not-lambdas-honest
00:24:09 <lament> 'block' is a good term
00:24:18 <Twey> But... they're functions
00:24:25 <lament> they're blocks
00:24:37 <Twey> They're functions
00:24:39 <lament> they're obviously not functions since they have side effects, right? :)
00:24:44 <Twey> Gah
00:24:45 <Twey> Haha
00:24:58 * Twey blinks at lament.
00:25:05 <Twey> Oh it's you
00:25:36 <lament> oh it's you
00:27:29 <Cale> Treating procedures that don't result in an interesting value as special doesn't seem to have much point to me. They can be treated as having the equivalent of Haskell's () as a return value.
00:27:40 <Twey> Cale: Yes.
00:27:45 <Twey> It's particularly stupid.
00:28:35 <chrisdone> Twey: in common lisp (in scheme they don't do this) they call procedures functions. enjoy
00:28:51 <bos> @seen dons
00:28:51 <lambdabot> dons is in #arch-haskell, #ghc, #xmonad and #haskell. I last heard dons speak 54m 23s ago.
00:29:58 <Trinithis> I forget the mathematical term for a "non-function".... is it relation?
00:30:52 <chrisdone> I thought a function was a relation
00:31:01 <Cale> Trinithis: a relation is similar to a function except that for any given input there could be multiple 'results'
00:31:11 <Trinithis> A function is a relation such that x,y1)∈F and (x,y2)∈F together imply y1 = y2
00:31:26 <Trinithis> So my memory did hold
00:31:29 <Cale> or no 'result' at all
00:31:46 <Trinithis> so there... Twey: It's a Relation!
00:32:19 <Twey> Mm-hm
00:32:43 <Cale> If you want, a relation A -> B is a subset of A x B
00:32:58 <Cale> (where x here is the Cartesian product)
00:33:36 <Trinithis> Would it be cool to have a language that uses cartesian products rather than functions?
00:33:43 <chrisdone> I was supposed to go to sleep tonight but I've ended up staying up to define a monad
00:33:44 <Cale> A function f: A -> B is a relation such that for every a in A, there is *exactly one* b in B for which (a,b) is in f
00:34:38 <Cale> Trinithis: You might consider that to be what Prolog is.
00:34:58 <Trinithis> :D . Well, explicitly then
00:36:08 <Cale> It might be an interesting idea, but note that you can also treat a relation from A to B as a function from A to the powerset of B.
00:36:31 <Cale> Or as a function from A x B to Bool.
00:39:36 <mmorrow> chrisdone: good show
00:44:18 <mmorrow> i on the other hand must crash
00:48:25 <chrisdone> hmm. you guys see what I'm trying to do here? http://hpaste.org/9198 not sure if there might be another way
00:55:10 <chrisdone> oh wait
00:55:12 <chrisdone> I got it :)
01:00:23 <mapreduce> > par 3+4
01:00:29 <lambdabot>   add an instance declaration for (Num (b -> b))
01:01:04 <mapreduce> > par (+1)
01:01:05 <lambdabot>  Add a type signature
01:01:19 <mapreduce> > par (+1) :: Integer
01:01:20 <lambdabot>  Couldn't match expected type `Integer'
01:01:27 <chrisdone> :t par
01:01:28 <lambdabot> forall a b. a -> b -> b
01:01:41 <chrisdone> > par 1 2
01:01:43 <lambdabot>  2
01:01:47 <mapreduce> Give it an a, give it a b and it gives you a b - what's the a for?
01:01:55 <chrisdone> to ignore it
01:01:58 <chrisdone> I think it's flip const
01:02:00 <chrisdone> @src par
01:02:01 <lambdabot> Source not found. You type like i drive.
01:02:02 <chrisdone> @src const
01:02:02 <lambdabot> const x _ = x
01:02:13 <mapreduce> It's not flip const, but it probably looks like that.
01:02:24 <chrisdone> it might as well be flip const
01:02:38 <mapreduce> Except it does the evaluation on a separate thread.
01:02:47 <chrisdone> oh
01:03:56 <TSC> It's a parallel version of seq, if I understand correctly
01:04:02 <mapreduce> :t seq
01:04:02 <lambdabot> forall a t. a -> t -> t
01:04:11 <mapreduce> @src seq
01:04:11 <lambdabot> Source not found. That's something I cannot allow to happen.
01:04:18 <mapreduce> What's seq for?
01:04:29 <Trinithis> strictness
01:04:52 <Trinithis> evalMe `seq` x
01:05:30 <Trinithis> f $! x == evalMe `seq` f evalMe
01:05:35 <mapreduce> So I guess thanks to lazy evaluation par 1 expensiveOp + par 1 anotherExpensiveOp takes in the order of the maximum of those to run, rather than in the order of the sum of them.
01:05:42 <Trinithis> but it isn't a deep strict evaluation
01:06:22 <mapreduce> My equivalent Scala version needs you to store the promises up then force them all explicitly, because Scala is a strict language.  Hrm.
01:08:01 <conal> 'par a b' evaluates a speculatively and in parallel.  then if b turns out to use a, a will have been at least partially evaluated by then.  syntactically, a is typically a variable so it gets evaluated just once.
01:08:20 <conal> (parallel with b)
01:09:03 <conal> let a = expensive in a `par` f a
01:10:32 <osfameron> ah!
01:10:57 <osfameron> and that's how you could do stuff in a document in parallel with editing part of it (with a zipper) ?
01:11:24 <osfameron> the upward branch would be calculated in parallel, with as much of it as possible returned by the time the zipper needs to move into it ?
01:13:01 <conal> osfameron: yes, for example.
01:17:30 <_Dae_> morning...
01:17:35 <conal> eager evaluation and lazy evaluation are both sequential evaluation strategies.  'par' is a completely operational construct that allows one to add of explicit concurrency.
01:18:44 <hackage> Uploaded to hackage: SDL-mpeg 0.0.1
01:22:19 <Cale> conal: parallelism
01:23:06 <conal> Cale: right
02:02:01 <FordCortina> @src sin
02:02:01 <lambdabot> Source not found. I've seen penguins that can type better than that.
02:02:50 <FordCortina> ah i see, class method...
02:03:52 <_Dae_> @src originalSin
02:03:52 <lambdabot> Source not found.
02:04:02 <FordCortina> lol
02:04:13 <mapreduce> What is WHNF in this?  "Unfortunately quicksortN has almost no parallelism because threads in GpH terminate when the sparked expression is in WHNF."
02:04:22 <_Dae_> I had hoped that I would get a link to apple.com.....
02:04:48 <FordCortina> :D
02:04:53 <Saizan_> mapreduce: weak head normal form, i.e. you've determined the outermost constructor
02:05:05 <chrisdone> down with successful companies!
02:05:26 <_Dae_> chrisdone: originalSin....apple... come on, it was funny!
02:06:04 <mapreduce> Saizan_: Thanks.
02:07:39 <Japsu> @quote Snake
02:07:39 <lambdabot> emertens says: screw ruby on rails, I'm using snakes on a plane
02:07:42 <Japsu> @quote Snake
02:07:43 <lambdabot> Philippa says: < ihope> data Badger = Badger Badger Badger | Mushroom < Philippa> Pattern match failure: Snake!
02:08:27 <_Dae_> -_O
02:17:45 <|Steve|> heh
02:33:03 <matthew-_> @seen Heffalump
02:33:04 <lambdabot> Heffalump is in #darcs and #haskell. I last heard Heffalump speak 15h 34m 49s ago.
02:35:18 <cjs> Man, I have functions producing functions producing functions.....
02:35:51 <mauke> you mean a function with three arguments?
02:37:19 <hml> is there a good wiki implemented in  haskell?
02:38:24 <cjs> Well, some are. But basically I call a function to return another function which then gets passed somewhere else to someone who calls it to get yet another function which eventually gets used.
02:38:44 <cjs> It feels like a lot of indirection....
02:39:24 * mapreduce wonders how many languages hml just asked that about (at least here and #erlang).
02:39:44 <cjs> hml: Probably not. If there were, I expect we'd be using it.
02:40:00 <cjs> However, I should have a good mailing list manager implemented in a few months.
02:40:33 <BeelsebobWork_> @hoogle (a -> Bool) -> a -> Bool
02:40:35 <lambdabot> Data.Foldable.any :: Foldable t => (a -> Bool) -> t a -> Bool
02:40:35 <lambdabot> Data.Foldable.all :: Foldable t => (a -> Bool) -> t a -> Bool
02:40:45 <BeelsebobWork_> @hoogle [a -> Bool] -> a -> Bool
02:40:45 <lambdabot> No matches, try a more general search
02:41:07 <geezusfreeek> :t ($)
02:41:22 <lambdabot> forall a b. (a -> b) -> a -> b
02:41:37 <Pistahh> :t forall
02:41:38 <lambdabot> Not in scope: `forall'
02:41:44 <BeelsebobWork_> > foldr (liftA2 (||)) (const False) [(==5),(==6),(==9)] 5
02:41:59 <lambdabot>  thread killed
02:42:06 <BeelsebobWork_> o.O
02:42:17 <johnnowak> > foldr (liftA2 (||)) (const False) [(==5),(==6),(==9)] 5
02:42:19 <lambdabot>  True
02:42:28 <geezusfreeek> lambdabot does that sometimes :(
02:42:34 <BeelsebobWork_> I see
02:46:09 <_Dae_> $src sqrt
02:46:15 <_Dae_> @src sqrt
02:46:15 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
02:47:01 <hml> cjs: got it; thanks
02:58:18 <chrisdone> is having an EDSL based directly on Parsec a bad idea?
02:58:24 <chrisdone> erm
02:58:33 <chrisdone> an EDSL to validate web page GET/POST inputs ^
03:00:18 <chrisdone> it's just really nice and composable, and it has choice etc. you could give really descriptive validation errors
03:00:40 <chrisdone> it would be nice to produce Javascript as well from a validation component
03:00:46 <chrisdone> to validate form inputs
03:37:44 <O_4> I'm hoping monads turn out to be like pointers.
03:37:54 <O_4> Really intuitive once you understand them.
03:39:39 <Cale> O_4: That's pretty much true, though there are some surprises. :)
03:39:46 <O_4> The basic concept seems simple enough, but I still don't really feel that I get them.
03:40:05 <Cale> They're simpler than you'd think, given the fanfare.
03:40:12 <O_4> But it's late and I'm tired, so I guess it's not surprising that I can't think about them clearly.
03:40:50 <Cale> The reason I think many people get confused is not the idea of monads themselves, but the way in which particular monads are built using functions.
03:40:58 <O_4> Yeah
03:41:25 <O_4> The concept seems straight forward, but I don't really understand how state monads work
03:42:34 <Cale> Perhaps I can help... if you're staying awake :)
03:42:46 <ibid> i believe it's the same with any abstraction, as the point of an abstraction is to hide all the complexity under the mattress
03:43:30 <O_4> I'll be heading to bed soon, but if I'm still confused tomorrow I may have to ask a few questions :-p
03:43:37 <osfameron> the problem is that monads allow you to write something that looks like a chain, but behaves like a magic onion (with completely different semantics to all the other kinds of magic onions you could have used, even though they look similar)
03:43:51 <osfameron> well, /a/ problem, anyway
03:43:55 <O_4> Heh
03:44:40 <Cale> heh, magic onion?
03:45:01 <idnar> monads are closures!#%!#%
03:45:16 <Cale> idnar: uhh.. :)
03:45:22 <idnar> (at least, that's what someone informed me yesterday :P)
03:45:34 <idnar> (rather dismissively, I might add)
03:45:36 <Cale> Wow. That person was fairly wrong.
03:45:46 <O_4> Did they include all the punctuation too, or was that your addition? :-p
03:46:05 <idnar> I added most of it
03:46:22 <osfameron> Cale: well, monadic actions nest (like layers of an onion) rather than chain.
03:46:57 <idnar> ogres^Wmonads are like onions
03:47:13 <Cale> osfameron: ah, hehe
03:47:47 <Cale> I suppose that's somewhat true... it's in a similar way that lists nest though :)
04:06:24 <pozic> Is there anyone who used HTF?
04:07:50 <Eelis> i'm getting an "Ambiguous type variable" error that i don't understand. testcase: http://rafb.net/p/EnBJZ879.html
04:07:51 <lambdabot> Title: Nopaste - No description
04:08:18 <Eelis> i thought having (Phantom :: Phantom a) would be enough to disambiguate
04:13:13 <ToRA> Eelis: you probably need to turn on ScopedTypeVariables
04:13:43 <Eelis> ToRA: that did the trick. thanks :)
04:14:28 <ToRA> np
04:15:22 <ToRA> btw, not that it makes any difference but RankNTypes is preferred to Rank2Types
04:15:48 <Eelis> noted
04:18:07 <chrisdone> Cale: a magic onion is rolling down a road and turns into a field
04:28:16 <pozic> Is there a test library without boiler plate that actually works?
04:29:04 <Cale> pozic: Quickcheck?
04:30:57 <Cale> pozic: Or... what do you mean "without boiler plate"?
04:31:01 <pozic> Cale: yes, that works for some tests. The nice thing about HTF is the goal (it wraps all testing libraries).
04:31:10 <Cale> pozic: HTF?
04:31:16 <pozic> Cale: it's on hackage.
04:31:25 <pozic> Cale: version 0.1 :/
04:32:37 <Cale> ah, okay
04:35:08 <pozic> Cale: I am also not sure of what's the best way to distribute the tests. They can be in the modules themselves, or all in one file, or ...
04:36:48 <Cale> That's mostly a matter of taste, as I see it.
04:37:45 <Cale> Putting the tests close to the code they're for is useful documentation, but tests in separate files can be easier to manage for testing all at once.
04:43:13 <mapreduce> I think it depends on whether your tests are an order of magnitude larger than the code they test.
04:43:37 <mapreduce> If they are, I think it's useful to have them separate.
04:50:30 <pozic> Cale: ... I found what's wrong.
04:50:50 <pozic> Cale: he uses cpphs in his configuration, but... it only works with normal cpp.
04:51:12 <pozic> Cale: very misleading information, but I spotted it since he used the -w option.
04:58:55 <naxeji> hello, is there an easy way to collect all group-regex-matches as [String] in haskell like ruby's String#scan method does?
05:00:14 <Cale> naxeji: yes... let me just see if I can properly recall it :) It's been a while since I used the Regex library (I usually stick to parsec)
05:01:36 <benpicco> Hi, is it possible to overload a function?
05:02:27 <Baughn> benpicco: In a sense, that's what typeclasses are for. Overloading the way C++ does it? No; nor will you need to.
05:02:30 <Cale> benpicco: effectively, yes, through typeclasses
05:03:13 <benpicco> typeclasses? I lust want a function with the same name to be called with different parameters
05:03:49 <benpicco> like areEqual::Int->Int->Int and areEqual::Bool->Bool->Int
05:04:07 <mattam> benpicco: that's exactly what typeclasses where designed for.
05:04:17 <benpicco> ah, ok, how do they work?
05:04:28 <benpicco> or where should i look for them?
05:04:30 <Shiruka> Eq typeclass defines (==) : a -> a -> Bool
05:04:49 <benpicco> is this the syntax=
05:04:52 <benpicco> ?
05:05:07 <Shiruka> see e.g. http://www.haskell.org/tutorial/classes.html
05:05:07 <lambdabot> Title: A Gentle Introduction to Haskell: Classes
05:05:13 <benpicco> thx
05:05:32 <Cale> Prelude Text.Regex.Posix> "aba4378" =~ "([abc]*)([0-9]*)" :: [[String]]
05:05:32 <Cale> [["aba4378","aba","4378"],["","",""]]
05:05:51 <naxeji> Cale: thanks :)
05:06:27 <pozic> stringGap = "hello \ \world!"
05:06:38 <pozic> Isn't this illegal Haskell?
05:06:46 <Cale> pozic: no?
05:06:50 <pozic> There is a newline between the two \ \
05:06:58 <Cale> > "hello \ \world"
05:07:01 <lambdabot>  "hello world"
05:07:08 <Cale> pozic: yeah, that's what string gaps are for
05:07:26 <pozic> Cale: it doesn't compile, let me check more.
05:07:29 <Cale> pozic: all the whitespace between the first \ and the second is deleted
05:08:09 <pozic> Cale: maybe it's cpp that's interfering.
05:08:53 <Cale> pozic: oh, yes
05:08:58 <Cale> pozic: it might.
05:09:56 <pozic> > "hello             \world!"
05:09:57 <lambdabot>  Illegal escape sequence at ""hell..." (column 1)
05:11:15 <Cale> naxeji: oh, another thing you can do which might be nicer
05:11:26 <Cale> naxeji: mrSubs ("aba4378" =~ "([abc]*)([0-9]*)") :: Array Int String
05:11:31 <Cale> array (0,2) [(0,"aba4378"),(1,"aba"),(2,"4378")]
05:11:59 <charles441> why doesn't this work, average ns = sum ns / length ns
05:12:14 <Cale> charles441: because length gives an Int, and / can't be used with Ints
05:12:56 <Shiruka> use `div` instead
05:13:09 <lomeo> fromIntegral
05:13:10 <Cale> Or fromIntegral to convert from Int to something else.
05:13:31 <Shiruka> depends on what you want :-)
05:13:41 <Cale> It's really very unfortunate that we don't have  length :: (Num b) => [a] -> b
05:14:02 <charles441> ok, thank you for the help.
05:14:09 <Cale> There's no good reason that it's restricted to Int.
05:14:24 <Shiruka> there's genericLength
05:14:25 <pozic> Where is the cpphs.compat script installed when one installs cpphs?
05:15:20 <naxeji> Cale: thanks again =)
05:15:22 <Cale> Shiruka: this is true
05:15:27 <Cale> naxeji: no problem :)
05:16:03 <Cale> naxeji: You can look in http://hackage.haskell.org/packages/archive/regex-base/0.93.1/doc/html/Text-Regex-Base-Context.html to see all the different types which x =~ y can result in.
05:16:04 <lambdabot> Title: Text.Regex.Base.Context, http://tinyurl.com/6ersla
05:16:36 <Cale> naxeji: It's more contextual than perl :)
05:16:53 <Cale> er, actually...
05:17:01 <Cale> Wrong version of the documentation there...
05:17:06 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/regex-base/Text-Regex-Base-Context.html
05:17:07 <lambdabot> Title: Text.Regex.Base.Context, http://tinyurl.com/yovda9
05:20:55 <malcolmw> pozic: you should not need the cpphs.compat script any more.  the cmdline flag -cpp does it all now
05:22:29 <pozic> malcolmw: yes, it's HTF that's a bit old, I guess.
05:22:51 <pozic> malcolmw: I just removed the -w option now and call real cpphs and it seems to work now.
05:29:18 <DuClare> Hi, what would you call a type which is a list of tuples where each tuple tells that fst is associated with snd :o  Like "+" means Sum, "/" means Div
05:29:37 <DuClare> So far I've just called it a table…  Is there anything more specific?
05:30:05 <Zao> Some kind of Map then?
05:30:07 <Twey> Ehm, a map?
05:30:11 <Baughn> A Data.Map.Map
05:30:14 <DuClare> Hmm
05:30:17 <Cale> Association list.
05:30:25 <Cale> But you probably should use Data.Map :)
05:30:27 <Twey> We have a lisper.
05:30:34 <Twey> Heh
05:30:38 <DuClare> I guess … :]
05:31:16 <Cale> Association lists are comparatively hard to search through.
05:31:50 <Philippa> isn't there a function in Data.List?
05:31:55 <Philippa> slow to search, sure
05:32:45 <Twey> Is there a better option if you need multiple possible values per key?  A Map only allows unique keys, yes?
05:33:36 <Shiruka> yeah, there is a function in Data.List
05:33:46 <r3m0t> :t assocs
05:33:47 <Shiruka> > (fromJust $ lookup "+" [("+", (+)), ("/", div)]) 2 3
05:33:49 <lambdabot> forall i e. (Ix i) => Array i e -> [(i, e)]
05:33:50 <lambdabot>  5
05:34:11 <Baughn> Twey: Instead of a Map a b, a Map a [b]?
05:34:28 <Twey> Ah, I suppose that could work
05:34:30 <Baughn> Though of course that doesn't maintain invariants such as [b] being non-null
05:34:36 * Twey nods.
05:34:49 <Twey> How about ordered?
05:35:05 <Baughn> Not unless you make it. It would be pretty easy to write a wrapper, but..
05:35:23 <Saizan_> Map a (Set b)
05:35:45 <Twey> Hmmm?
05:35:48 <Baughn> Only if the values are supposed to be unique. :P
05:35:52 <Twey> Yes
05:36:05 <Twey> Oh, that was for the non-unique one
05:36:18 <Twey> Heh, thought that was meant to allow ordered keys somehow
05:36:31 <pozic> j #xmonad
05:38:09 <Saizan_> too bad we don't have a Bag :)
05:38:27 <Twey> Heh
05:38:33 <pozic> There is multi-set
05:38:47 <_Dae_> well.. why would you want an ordered map? I'm not sure I see the purpose=
05:38:49 <pozic> Implemented in Edison, IIRC.
05:39:12 <pozic> _Dae_: map != Map
05:39:22 <FordCortina> having real difficulty making an "idea" in types decidable :'(
05:40:12 <_Dae_> pozic: Map then....
05:41:58 <Saizan_> FordCortina: decidable?
05:42:33 <Shiruka> multiple values in an assoc list.. hm
05:43:02 <Shiruka> I haven't used assoc lists for much of anything, so maybe there are functions for that I don't know.. but you could define such :-)
05:43:10 <Shiruka> > filter ((=="+") . fst) [("+", (+)), ("+", (*))] >>= return . ($3) . ($2) . snd
05:43:11 <lambdabot>  [5,6]
05:43:21 <Shiruka> pretty ugly without any
05:45:00 * Shiruka claims a pointless use of pointlessness badge
05:45:44 <FordCortina> Siazan_: ive built some type-level values using singleton types, type classes and multi parameter type classes for type functions. Now I just want the cross product of two of the types and define a couple of operations on those products. Now all of a sudden its completely impossible to do with have undecidable instances
05:46:10 <FordCortina> s/to do/to do so/
05:46:23 <FordCortina> s/with/without/
05:46:36 <mapreduce> @pl \x y z -> x+y+y+z
05:46:36 <lambdabot> ((+) .) . join . ((+) .) . (+)
05:47:11 <mapreduce> I have this feeling @pl might not be optimal :)
05:48:08 <FordCortina> s/Siazan_/Saizan_/
05:48:35 <Shiruka> trying to optimize kolmogorov complexity doesn't sound like a sane idea :-)
05:48:42 <Baughn> mapreduce: Mentioning a parameter more than once on the right-hand side seems to /guarantee/ @pl won't come out well, so.. yah.
05:48:56 <pozic> Shiruka: you cannot optimize that.
05:49:11 <Baughn> You can certainly try
05:49:18 <Baughn> Start by running your code through paq8.
05:49:30 <pozic> No, Kolmogorov complexity has already been defined.
05:49:53 <Shiruka> sigh, it's missing a "for"
05:50:13 <conal> perhaps @pl would handle multi-occurrences better if it knew (<*>)
05:50:38 <Shiruka> I mean, optimizing the size until it hits the kolmogorov limit
05:50:40 <Saizan_> conal: it often uses ap
05:50:48 <pozic> Shiruka: then he should use a completely different programming language.
05:50:56 <pozic> Shiruka: it's defined per programming language.
05:51:00 <conal> Saizan_: oh, thx.  then never mind.
05:51:07 <Saizan_> @pl \xs -> zip xs (tails xs)
05:51:07 <lambdabot> ap zip tails
05:51:26 <Shiruka> pozic: sure, in this case the language would be "the subset of pointless expressions in haskell"
05:53:43 <Botje> @quote tail
05:53:43 <lambdabot> sjanssen says: your mom has a thunk for a tail
05:54:05 <Botje> hmm
05:54:09 <Botje> @quote `ap`
05:54:09 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
05:54:52 <ziman> :t zip `ap` tail
05:54:55 <lambdabot> forall b. [b] -> [(b, b)]
05:55:16 <lomeo> bah!
05:55:21 <ziman> > (zip `ap` tail) [1..10]
05:55:23 <lambdabot>  [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10)]
05:56:18 <ziman> @pl \xs -> zip xs (tail xs)
05:56:18 <lambdabot> ap zip tail
05:56:48 <lomeo> ap is an S combinator, so zip `ap` tail is \x -> zip x (tail x)
06:05:29 <ddarius> cf. Bekenstein for a recent treatment
06:15:00 <pozic> @instance (->) ap
06:15:00 <lambdabot> Maybe you meant: instances instances-importing
06:15:04 <pozic> @instances (->) ap
06:15:14 <lambdabot> Couldn't find class `(->) ap'. Try @instances-importing
06:18:27 <Dynetrekk> anyone know an easy way of finding out if, say, the number 5 is in a list of [Integer] ? and, the list could be infinite...
06:18:55 <ToRA> > 5 `elem` [1,2..]
06:18:58 <lambdabot>  True
06:19:05 <Cale> Dynetrekk: well, anything that checks in an infinite list will take forever if it's not there
06:19:14 <Shiruka> unless you know something about the list
06:19:15 <Cale> but yes, elem
06:19:18 <Cale> right
06:19:19 <Shiruka> such as that it is sorted
06:19:25 <Dynetrekk> Cale: sounds worrying
06:19:27 <Shiruka> in that case takeWhile will terminate
06:19:58 <Cale> > takeWhile (<= 5) [0,2..]
06:19:59 <Philippa> takeWhile /may/ terminate
06:19:59 <lambdabot>  [0,2,4]
06:20:12 <Cale> > elem 5 (takeWhile (<= 5) [0,2..])
06:20:15 <lambdabot>  False
06:20:23 <Philippa> > let ones = 1 : ones in takeWhile (<= 5) ones
06:20:24 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
06:21:08 <Cale> > elem 1 (takeWhile (<= 1) [1 - 1/n | n <- [1..]])
06:21:12 <Shiruka> philippa: heh, I was implicitly not counting that case :-)
06:21:16 <lambdabot>  Tried to use too much memory
06:21:20 <Cale> :)
06:21:23 <Cale> > takeWhile (<= 1) [1 - 1/n | n <- [1..]]
06:21:24 <lambdabot>  [0.0,0.5,0.6666666666666666,0.75,0.8,0.8333333333333334,0.8571428571428571,0...
06:21:35 <Shiruka> but actually, it's a situation that can happen realistically
06:21:40 <Shiruka> it did happen to me once :-)
06:21:57 <Cale> I've had the unfortunate case of wanting to evaluate  product [1,1..]
06:22:05 <Philippa> *wince*
06:22:17 <Dynetrekk> Cale: you shouldn't :-)
06:22:21 <Shiruka> I wrote a function which takes an infinite 2d matrix (list of lists) where every column and row is sorted, and then returns unique elements in order
06:22:31 <Philippa> Shiruka: the trick to optimising Haskell is to play it extremely dumb on a low level, and clever as you like on a higher one
06:22:38 <Cale> Dynetrekk: Well, it ought to evaluate to 1, if this were mathematics :)
06:22:46 <Shiruka> then I tried it on the simples such matrix that came to mind at the moment, which was a^b
06:22:59 <Shiruka> which didn't terminate, as a started at 1 :-)
06:23:00 <Philippa> that is: don't do anything low level that you couldn't convince a monkey of its correctness
06:23:19 <Shiruka> (refactored out the nub of the resulting list though)
06:24:11 <Dynetrekk> sounds like it is easier to write your own method
06:24:46 <gwern> woot, hint got uploaded!
06:24:47 <Dynetrekk> given the fact that I know the "data set"
06:24:56 <gwern> now I can release mueval. just as soon as I take a nap
06:25:22 <yitz> > [(1+1/n)**n | n<-[1..]]
06:25:23 <lambdabot>  [2.0,2.25,2.37037037037037,2.44140625,2.4883199999999994,2.5216263717421135,...
06:25:46 <yitz> > drop 100 [(1+1/n)**n | n<-[1..]]
06:25:47 <lambdabot>  [2.7049459774851603,2.705075557463504,2.7052026434963605,2.7053273068967987,...
06:26:20 <yitz> > drop 1000 [(1+1/n)**n | n<-[1..]]
06:26:21 <lambdabot>  [2.716925287534764,2.7169266401302705,2.716927990032086,2.7169293372465217,2...
06:26:41 <Shiruka> >  take 10 [(1+1%n)^n | n <- [1..]]
06:26:43 <lambdabot>  [2%1,9%4,64%27,625%256,7776%3125,117649%46656,2097152%823543,43046721%167772...
06:26:52 <Dynetrekk> yitz: that shit converges too slow
06:26:59 <yitz> sure does
06:27:19 <Dynetrekk> yitz: % is fractional type?
06:27:32 <yitz> yes. Rational.
06:27:52 <Cale> > showCReal 100 (exp 1)
06:27:53 <lambdabot>  "2.7182818284590452353602874713526624977572470936999595749669676277240766303...
06:28:23 <Shiruka> too bad there's no nicely derogatory term for floats :-<
06:28:30 <Shiruka> irrational and surreal number terms are already taken
06:28:37 <yitz> Cale: is exp really that accurate?
06:28:52 <Cale> yitz: On CReal it is.
06:28:57 <ziman> > last . showCReal 10000 $ pi
06:29:03 <lambdabot>  Exception: Time limit exceeded
06:29:05 <Shiruka> !
06:29:08 <Shiruka> CReal is computable real?
06:29:11 <Cale> yeah
06:29:22 <Shiruka> whoa, I didn't know that was built-in
06:29:25 <Cale> It's not
06:29:33 <Cale> It's in the numbers library available on hackage.
06:29:38 <Shiruka> oh..
06:30:18 <yitz> Cale is that jerzy's stuff?
06:30:31 <Cale> Lennart's
06:30:31 <SamB_XP_> > 0 :: CReal == 0
06:30:31 <lambdabot>  Parse error at "==" (column 12)
06:30:38 <SamB_XP_> > (0 :: CReal) == 0
06:30:39 <lambdabot>  True
06:30:47 <SamB_XP_> wierd!
06:30:52 <yitz> ah ok. nice.
06:30:57 <Cale> > showCReal 50 (exp 1 - sum [1 / product [1..n] | n <- [1..100]])
06:30:58 <Twey> Wired.
06:31:03 <SamB_XP_> > (0 :: CReal) == pi - pi
06:31:04 <lambdabot>  "Exception: Time limit exceeded
06:31:05 <lambdabot>  True
06:31:10 <Cale> > showCReal 50 (exp 1 - sum [1 / product [1..n] | n <- [1..50]])
06:31:12 <lambdabot>  "1.0"
06:31:20 <Cale> oh, duh :)
06:31:22 <Cale> > showCReal 50 (exp 1 - sum [1 / product [1..n] | n <- [0..50]])
06:31:26 <lambdabot>  "0.0"
06:31:34 <Cale> > showCReal 100 (exp 1 - sum [1 / product [1..n] | n <- [0..50]])
06:31:37 <lambdabot>  "0.0000000000000000000000000000000000000000000000000000000000000000006573322...
06:32:17 <Twey> Minor style question: how do you decide when to use $?
06:32:23 <Shiruka> hmh, could be faster though..
06:32:32 <SamB_XP_> Cale: so can you demo the undecidability of equality?
06:32:41 <Twey> I tend to do it whenever I have a bracketed expression on the end, i.e. I'd've written that as showCReal 50 % ...
06:32:45 <Shiruka> computing 10 kilodigits of pi takes a while with it
06:32:46 <Twey> Er
06:32:50 <Twey> showCReal 50 $ ...
06:32:54 <Twey> Is that bad style?
06:33:01 <Cale> It's fine :)
06:33:10 <pozic> How is ap defined for (->)?
06:33:12 <Twey> And is it better to a $ b $ c $ d or a . b . c $ d?  And why?
06:33:27 <Cale> The latter, because (.) has the nice property of being an associative operator
06:33:28 <yitz> Twey: that one is more controversial.
06:33:31 <SamB_XP_> Twey: the latter, because $ has the wrong associativity
06:33:44 <Cale> and so b . c is going to be meaningful
06:33:50 <Cale> while b $ c is not
06:33:54 <SamB_XP_> as you would know if you'd ever tried to use $! on a non-last argument
06:34:12 <Botje> pozic: f `ap` g = \x -> f x (g x)
06:34:15 <Twey> Hmmmn
06:34:17 <Twey> I see, thanks
06:34:23 <Cale> Yeah, and we want to change the direction that $ associates in at some point, so it's nice to try to convince people not to chain it :)
06:34:37 * Twey nodnods.
06:34:47 * Shiruka chains it sometimes
06:34:59 <Botje> me chains it all the time
06:35:16 <Shiruka> what's the point of having its associativity be the wrong way around if you're then not even going to use it :-(
06:35:49 <Cale> Shiruka: well, if it was the right way around, chaining it would be more interesting
06:36:01 <Cale> (and wouldn't just be replaceable with uses of (.))
06:36:16 <Asgaroth> If a is an instance of Ord, then it's automatically an instance of Eq, right?
06:36:25 <Cale> For example, if you want to write  f (g x) (h y) (k z) without parens...
06:36:28 <Shiruka> yes, I often would like its associativity to be the other way around
06:36:29 <Cale> Asgaroth: yep
06:36:37 <Twey> I see I see
06:36:50 <SamB_XP_> Asgaroth: well, not automatically, but it is guarenteed to be an instance of Eq yes
06:37:04 <Asgaroth> Ok, thanks
06:39:26 <yitz> Asgaroth: it's *required* to be an instance of Eq. So if someone else defined the instance for you, it's guaranteed. But if you are defining, you have to provide it yourself or it won't work.
06:39:53 <Asgaroth> yitz: I see, thanks
06:40:35 <SamB_XP_> Asgaroth: as the compiler will no doubt inform you if you forget ;-)
06:40:53 <Asgaroth> that's one of the great about haskell, isn't it ;)
06:40:58 <Asgaroth> *great things
06:41:07 <SamB_XP_> yeah ;-)
06:42:41 <yitz> Cale: no prob. let gx = g x; hy = h y in f gx hy $ k z -- :)
06:42:53 <Cale> yitz: heh
06:42:57 <yitz> oops I used a paren in the smiley
06:43:32 <Cale> and that's effectively what you end up doing with $!
06:43:44 <Cale> er, actually, it's worse
06:44:21 <yitz> what you end up doing with $! is using it in simple cases, otherwise just forget it and use seq manually.
06:44:45 <Shiruka> or bang patterns
06:44:51 <ziman> @src ($!)
06:44:51 <lambdabot> f $! x = x `seq` f x
06:45:37 <mar77a> > length "xandal stop being a faggot"
06:45:39 <lambdabot>  26
06:46:08 <yitz> infixr 0 $! (just like $)
06:49:18 <Axman6> is haskell.org down?
06:49:45 <Cale> no
06:50:06 <Axman6> hmm, not loading for me :\
06:50:13 <Cale> http://www.haskell.org/
06:50:14 <lambdabot> Title: Haskell - HaskellWiki
06:50:20 <Cale> that isn't?
06:50:37 <Axman6> nope
06:50:43 <Cale> huh
06:51:25 <Saizan_> ooh, bind and extend are fmap over the respective Kleisli and coKleisli categories, never realized that..
06:52:46 * ToRA longs for the day when he could realize that...
06:53:46 <Dynetrekk> anyone care to explain to me how to read a file and then call a function on its contents?
06:53:55 <sioraiocht> Dynetrekk: readFile
06:53:59 <sioraiocht> :t readFile
06:53:59 <lambdabot> FilePath -> IO String
06:54:22 <Dynetrekk> sioraiocht: I got that far. now, what is an IO String and why can't I print it?
06:54:43 <lilachaze> Dynetrekk: do you know anything about monads, or the IO monad specifically?
06:54:44 <lomeo> :t readFile >>= print
06:54:45 <lambdabot>     Couldn't match expected type `FilePath -> b'
06:54:45 <lambdabot>            against inferred type `IO ()'
06:54:45 <lambdabot>     Probable cause: `print' is applied to too many arguments
06:54:46 <sioraiocht> Dynetrekk: IO in haskell is monadic.  the easisest way is do notation
06:54:52 <lomeo> :t readFile "" >>= print
06:54:53 <lambdabot> IO ()
06:55:08 <sioraiocht> readFile "myFile" >>= print works, as well
06:55:21 <Cale> Saizan_: are you sure?
06:55:28 <sioraiocht> you can use "do {str <- readFile "myFile"; print str
06:55:29 <sioraiocht> ]
06:55:30 <Dynetrekk> sioraiocht: okay, I guess that's my real problem then. monadic in the sense that there is an order for your actons?
06:55:30 <sioraiocht> }
06:55:38 <sioraiocht> Dynetrekk: yes, and IO is a monad
06:55:56 <sioraiocht> and there are specific ways you have to deal with monads, it's not hard, though
06:56:05 * Twey twitches.
06:56:22 <Twey> sioraiocht: 'Not hard' as in 'has only taken Twey six months to grasp so far'
06:56:40 <sioraiocht> Twey, I'll agree the CONCEPTS are not easy
06:56:45 <sioraiocht> but if you just say "use this notation"
06:56:46 <lomeo> @@goo IO inside
06:56:48 <sioraiocht> it's survivabl
06:56:50 <sioraiocht> :)
06:56:50 <lomeo> @goo IO inside
06:56:51 <lambdabot> http://www.haskell.org/haskellwiki/IO_inside
06:56:51 <lambdabot> Title: IO inside - HaskellWiki
06:57:00 <Twey> Hmmm.  :-)
06:57:02 <Cale> Saizan_: bind :: (a -> T b) -> (T a -> T b). If we write ~> for an arrow in the Kleisli category, then that's (a ~> b) -> (T a ~> b), isn't it?
06:57:22 <Dynetrekk> Twey: and that's only because you have been trying for 6 months?
06:57:36 <Saizan_> Cale: ah, right
06:57:41 <Axman6> @src reverse
06:57:42 <lambdabot> reverse = foldl (flip (:)) []
06:57:52 <sioraiocht> Dynetrekk: It also depends on your background, it took me a while, too, a lot of more abstract maths people seem to be comfortable with it from the start
06:57:58 <SamB_XP_> actually the concept is extremely easy -- once you stop trying to figure out what it is and just use it ;-)
06:58:00 <Saizan_> Cale: i can't transform only one arrow..
06:58:04 <Twey> Dynetrekk: Every time I read one of the hundred odd tutorials all the way through, I get a little further before thinking 'wait what?'
06:58:11 <Twey> I consider this progress
06:58:18 <sioraiocht> ARROWS, otoh, I still don't understand, but I never need to use them
06:58:25 * Twey laughs.
06:58:50 <Twey> Deep dark secrets of Haskell...
06:58:54 <Dynetrekk> sioraiocht: okay, well, hopefully good news. I'm a physicist, not a computer whatever
06:59:08 <SamB_XP_> sioraiocht: I especially don't recommend trying to figureo out what arrows are before using them
06:59:10 <ToRA> anybody involve in yi development about?
06:59:13 <SamB_XP_> it's even less productive
06:59:20 <sioraiocht> Dynetrekk: you should be fine
06:59:33 <Twey> I can use monads... kind of...
06:59:52 <Dynetrekk> sioraiocht: I'm fine, thanks, it's just my programming skills who're not :)
07:00:00 <lomeo> :)
07:00:02 <sioraiocht> hahaha
07:00:32 <lilachaze> sioraiocht: i didn't get arrows until i wanted to make a parsec-style parser combinator which built parse tables at compile time.
07:00:54 * lilachaze thinks that a good way to understand arrows and monads is to try to solve a problem which leads you to invent them.
07:02:02 <sioraiocht> Dynetrekk: http://hpaste.org/9199
07:02:26 <sioraiocht> lilachaze: I agree, like I said, i don't really end up needing arrows
07:02:28 <Twey> Uh, sioraiocht
07:02:35 <Twey> 'str' is undefined in the latter
07:02:37 <sioraiocht> yeah
07:02:38 <sioraiocht> oops
07:02:45 <Twey> That should just be readFile foo >>= print
07:02:46 <sioraiocht> there
07:02:46 <Dynetrekk> sioraiocht: thanks!
07:02:47 <sioraiocht> done and done
07:02:54 <Twey> Heh
07:03:05 <Saizan_> Cale: might this correspond to anything? (<@>) :: Applicative f, Comonad f => f (f a -> a) -> f a -> f b; f <@> v = f <*> duplicate v
07:03:29 <Twey> It's the rose operator.
07:04:39 <Saizan_> i use it sort of like <*>, f `extend` a <@> b <@> c ..
07:05:19 <childe> Hi. Is there a way to "lift" normal functions so that they can operate on Exp? For example, to "lift" the head function so that it can get the first element of a ListE?
07:05:32 <Saizan_> where f :: Comonad w => w a -> w b -> w c -> d
07:05:43 <Cale> Saizan_: hmm....
07:05:49 <sioraiocht> comonads...*cries*
07:06:23 <Saizan_> they are not that scary!
07:06:46 <Cale> f (f a -> b) -> f a -> f b  you mean?
07:07:14 <Saizan_> Cale: yes, sorry
07:07:27 <lilachaze> childe: instead of lifting head, why not reify the list? like "head $(list)" (warning: measuring my knowledge of TH is a good way of approximating zero)
07:08:11 <childe> Well actually I want to get an Exp for the head element, not the element itself.
07:08:33 <childe> So that I can use this Exp element to build other Exp.
07:08:47 <lilachaze> can you do something like [|head $(list)|] ?
07:09:15 <childe> Maybe I can, but that means two times of $() to use it.
07:09:31 <SamB_XP_> @hoogle ListE
07:09:31 <lambdabot> Language.Haskell.TH.ListE :: [Exp] -> Exp
07:09:32 <lambdabot> Language.Haskell.TH.Syntax.ListE :: [Exp] -> Exp
07:09:32 <lambdabot> Language.Haskell.TH.listE :: [ExpQ] -> ExpQ
07:09:59 <SamB_XP_> hmm, ListE seems to be a constructor, not a type
07:10:33 <SamB_XP_> childe: how do you know you have a ListE ?
07:10:41 <childe> Yes...I think I can use pattern matching to extract the element, but that is very tiresome.
07:11:07 <Cale> Most things about TH are pretty tiresome ;)
07:11:17 <SamB_XP_> indeed
07:11:44 <childe> Indeed...that's why I wonder if someone has made some cool libraries to ease the TH works.
07:11:46 <SamB_XP_> it's basically only non-tiresome to write trivial macros that don't examine code ;-)
07:12:03 <childe> TH is cool, but too difficult to use compared to Lisp's macro system.
07:12:27 <Saizan_> that's mostly because haskell has more syntax
07:12:34 <SamB_XP_> maybe someone will make some once they discover some things that would be nice to have IN them
07:13:35 <SamB_XP_> it's possible that derive has some things that would be nice?
07:13:37 <SamB_XP_> dunno.
07:13:44 <Saizan_> yes
07:13:55 <childe> You know, thinking that Haskell has TH is a way to convince me that Haskell is almost as powerful as Common Lisp...
07:13:55 <Saizan_> there's a quite handy module in there
07:14:02 <SamB_XP_> there seem to be many more things that derive does NOT have
07:14:17 <SamB_XP_> childe: oh, it is as powerful
07:14:31 <Cale> childe: There are nice things that Haskell can do which common lisp has trouble with too :)
07:14:49 <SamB_XP_> in Common Lisp, your macros would have to parse CL s-expressions!
07:14:55 <childe> Cale: Like pattern matching?
07:15:02 <Cale> Like expressing constraints on what functions are allowed to do.
07:15:06 <childe> SamB_XP_: Yes.
07:15:13 <Axman6> is there a function that'll find the max element in a list, based on a function i give it?
07:15:30 <Shiruka> try writing dons's stream fusion library in CL :-)
07:15:31 <SamB_XP_> even though it can't possibly be expected to deal with independantly-developed macros
07:15:40 <mar77a> > reverse "Snaus, how the fuck do you do that?"
07:15:47 <lambdabot>  "?taht od uoy od kcuf eht woh ,suanS"
07:15:52 <childe> But in Lisp we can write some macro to check the constraints at compile time.
07:15:53 <Cale> childe: In Haskell, I can write   map :: (a -> b) -> [a] -> [b], and then map is not allowed to inspect the elements of the list it gets, because it's supposed to be completely polymorphic.
07:15:57 <Axman6> so, a function that compares a list [(a,b)], and i want to find the max by b
07:16:08 <SamB_XP_> surely having to parse s-expressions as code is at least as cumbersome as having to deal with TH's Es?
07:16:16 <Cale> childe: It's really hard to express that kind of constraint in lisp
07:16:17 <lilachaze> childe: liftTH f v  = [| $(f) $(v) |]
07:16:19 <childe> While in Haskell we can not even make some syntax sugar to support Co-monad (whatever it is).
07:16:23 <Saizan_> ?typer maximumBy
07:16:24 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
07:16:37 <Cale> childe: It's unclear what kind of syntax sugar we'd want :)
07:16:38 <Axman6> sounds like it. where is that Saizan_ ?
07:16:46 <Saizan_> Data.List
07:16:49 <childe> I mean, although we have the "do" syntax to support Monad, we have nothing like that for co-monads.
07:16:50 <lilachaze> childe: followed by "main = print $( liftTH [|head|] [| [1,2,3] |] )"
07:17:08 <SamB_XP_> childe: is there some similar syntax that would be appropriate?
07:17:20 <Shiruka> you can implement do-like syntax in TH
07:17:20 <lilachaze> childe: you get all sorts of problems with things needing to be in different modules, though... :(
07:17:21 <SamB_XP_> I'm content to use infix ops
07:17:27 <Cale> childe: Right, but were are also not so many comonads in common use to help us understand what kind of syntax we'd want to have.
07:17:31 <childe> lilachaze: But isn't the first $() in liftTH inefficient?
07:17:52 <childe> Shiruka: But not without a $() to use it.
07:17:53 <Shiruka> although it isn't quite as pretty :-(
07:18:02 <Shiruka> yeah, that's the not-as-pretty part..
07:18:03 <childe> I find the $() syntax so ugly.
07:18:04 <SamB_XP_> childe: I would call it not inefficient but wrong, probably
07:18:50 * SamB_XP_ wonders if TH can lift functions, though
07:19:17 <Shiruka> but it's just 3 characters though, so a little ugliness aside, it's not all _that_ bad
07:19:20 <SamB_XP_> 'twould be a really cool ability
07:19:48 <SamB_XP_> ... 'twould require a lot of help from the compiler, though
07:19:53 <childe> Yeah, $() is still much better than no TH at all.
07:20:11 <lilachaze> childe: i have no feel for how much it'll affect your compile time, but my guess is that it'll be evaluated in a maximally lazy fashion, so it should be fine.
07:20:19 <Shiruka> I recall seeing someone actually hacking $() for do together, with a little googling I found it again:
07:20:19 <SamB_XP_> what syntax should it be?
07:20:22 <Shiruka> http://www.randomhacks.net/articles/2007/03/15/data-set-monad-haskell-macros
07:20:23 <Cale> I haven't seen many really good use cases for macros in Haskell.
07:20:26 <lambdabot> Title: How to make Data.Set a monad, http://tinyurl.com/22rhsc
07:20:34 <SamB_XP_> yeah, not many
07:20:40 <SamB_XP_> HOC is one I guess
07:21:08 <Cale> It seems like there should be good opportunities for automatic FFI construction.
07:21:37 <SamB_XP_> isn't that basically what HoC uses it for?
07:21:42 <childe> Cale: Or maybe when I want to create a lot of symbols with a clear structure.
07:21:52 <Cale> hm?
07:22:05 <childe> For example, data D = AA | BB | CC | ...
07:22:06 <SamB_XP_> interfacing with ObjC doesn't count as FFI ?
07:22:34 <SamB_XP_> childe: why would you name constructors so stupidly?
07:23:22 <Shiruka> just to give a generic example instead of making anything silly up?
07:23:30 <childe> SamB_XP_: I don't know a good way to express the idea "identifiers of two letters".
07:23:40 <Cale> (Char, Char) ?
07:24:08 <SamB_XP_> childe: that didn't seem to be what you were making there ...
07:24:34 <Shiruka> everything can be solved with yet another layer of indirection
07:24:41 <childe> OK...
07:24:55 <SamB_XP_> and anyway why would you want to blow all the two-cap constructor names on that?
07:24:58 <Shiruka> which in this case is moving the stuff from the language into objects (AA => ('A', 'A'))
07:25:11 <Shiruka> but whether it makes any sense depends on the specific use case
07:25:26 <Shiruka> so talking in the abstract may not produce anything useful here..
07:25:32 <Cale> However, usually something more structured like that is way more convenient :)
07:25:47 <Cale> After all, imagine writing a case expression for childe's type :)
07:25:59 <childe> Hmmm...I'll think about it...this use case is stupid, indeed.
07:26:07 <Cale> anything which needs to deal with more than a handful of cases will be annoying :)
07:26:23 <Cale> (unless you use macros to generate it as well!)
07:27:13 <SamB_XP_> yeah, if there is some conceptual structure to your data, it had better be reflected in the way you store it too
07:27:18 <pozic> How can I call ghci so that it runs main? runhaskell is not working for some reason with lots of argument.
07:27:21 <pozic> +s
07:27:33 <SamB_XP_> runghc?
07:27:40 <pozic> SamB_XP_: that is runhaskell
07:27:47 <Cale> ghc -e main ?
07:27:52 <pozic> SamB_XP_: at least with my setup
07:28:07 <pozic> Cale: thanks
07:28:57 <Shiruka> the problem with abstract discussions is that everyone is in the end thinking about some concrete things, it's just that when the discussion is abstract then everyone is thinking of _different_ concrete things..
07:29:20 <childe> So how to do this easily: f (0,_,_) = "first is 0"; f (_,0,_) = "second is 0"; ...
07:29:55 <childe> Sometimes I have to enumerate a lot of cases of a pattern.
07:31:37 <Twey> childe: Uuuuusually sign of a bad design
07:31:38 <Shiruka> (1) for 2-tuples, use fst and snd, (2) for slightly longer tuples, use a few accessor functions you define, (3) for longer stuff, use a list or a struct <-- this way?
07:32:09 <Shiruka> where struct = record (sigh, I use so many languages that I can't keep the terminology straight for similar concepts :-)
07:32:33 <childe> But if I use list for longer stuff, there is no standard way to specify the length of the list, right?
07:32:43 <baaba> f (x0, x1, x2) = let lst = [x0, x1, x2] in
07:32:57 <Botje> childe: When i had to handle triples, I wrote fst3, snd3, trd3
07:33:07 <Botje> baaba: that can't always work.
07:33:21 <baaba> yeah xn will have to be same type of course
07:33:30 <Shiruka> childe: if the length is fixed, then you can use a record
07:33:32 <Shiruka> it's a different use case
07:34:28 <childe> Then I have to enumerate the cases for each record field has a 0 value.
07:35:02 <childe> Sorry for my bad English...
07:36:01 <Cale> childe: There are libraries with type-level naturals for specifying fixed-length vectors, but it's more awkward in Haskell than it is with a dependently typed language.
07:36:50 <Cale> childe: Somehow it's unusual to see tuples larger than pairs in Haskell code.
07:36:50 <childe> Cale: Yeah, I think I read it somewhere that the dependent type extension for Haskell can do fixed length vectors well.
07:37:27 <Cale> Typically, if you have a bunch of differently-typed things to store together, you create a new datatype that conveys their combined meaning.
07:37:28 <Twey> Why doesn't Haskell have dependent types?
07:37:55 <Twey> I'm always seeing 'this can only be done with dependent types so it's kind of clumsy in Haskell' here
07:37:56 <Cale> Twey: I think mostly because most of the research on dependent types that makes them practical is relatively new.
07:37:59 <Shiruka> if the processing has lots of regularity, then yeah, it's easier to do it using structures which have a dynamic component, such as lists (where length is dynamic)
07:38:02 <Twey> Ah
07:38:35 <byorgey> yeah, adding dependent types to Haskell would be a HUGE undertaking, both from a coding perspective and a theoretical perspective
07:38:35 <lambdabot> byorgey: You have 1 new message. '/msg lambdabot @messages' to read it.
07:39:15 <byorgey> my impression is that if you want a language to have dependent types, you really have to design it from the ground up with that in mind.
07:39:33 <Cale> One issue with dependent types is that type inference in the presence of dependent typing is hard.
07:40:03 <childe> I spent a whole afternoon reading an article about implementing Curry-Howard correspondence in Haskell...sigh. Dependent types are used there :-(
07:40:26 <Cale> Making types more and more powerful while largely preserving type inference is a pretty good way to summarise the current direction that Haskell is going.
07:40:29 <childe> That article brought a serious headache to me, though...
07:41:08 <childe> Cale: Maybe Haskell will adopt some good stuff from Agda? Is that possible?
07:42:18 <Cale> Well, yeah, all these languages like Agda, Coq, Epigram, are sort of progressive things that are designed with less practical uses in mind, but Haskell can take ideas from.
07:42:35 <Cale> and they might become more and more practical as they go too
07:43:11 <Philippa> Coq is very much designed with practical uses in mind, they're just different uses
07:43:17 <Shiruka> it would be fun to have a haskell program where at the end you go "lemma f_is_type_correct: [...]; lemma g_is_type_correct: [...]; theorem h_is_type_correct using f_is_type_correct, g_is_type_correct by blast;" -- prove theorems or your programs won't compile! :-P
07:43:18 <Cale> Well, okay :)
07:43:28 <childe> In the mean time, I'm still struggling to install GHC on my Mac OS X sytstem...
07:43:28 * DrSyzygy thanks the HWN for mentioning me.
07:43:33 <DrSyzygy> But the name was wrong. :-P
07:43:44 <Cale> DrSyzygy: haha
07:43:55 <Cale> DrSyzygy: what happened?
07:44:06 <DrSyzygy> I got renamed to Dr Johansson instead of Dr Vejdemo Johansson
07:44:19 <childe> It seems I have to download XCode before installing GHC. That's about 1GB of download.
07:44:36 <Cale> childe: ow
07:44:37 <childe> Why can't GHC on OS X just use a plain GCC?
07:44:39 <nominolo_> childe: why?
07:45:01 <childe> I don't know. It's required according to the official download page.
07:45:14 <BeelsebobWork> childe: eh? I compiled it with OS X's gcc last week
07:45:17 <nominolo_> there's really only one supported gcc version
07:45:25 <Cale> BeelsebobWork: he's talking about Manuel's package
07:45:25 <nominolo_> and it's better to use that one
07:45:32 <thoughtpolice> childe: if you have your installer disks, xcode comes on them
07:45:55 <childe> thoughtpolice: Yes :-) That's my last hope.
07:45:55 <BeelsebobWork> oh hang on -- childe Xcode is required for *anything* to do with development work
07:46:05 <nominolo_> childe: which osx, what does gcc --version say?
07:46:08 <BeelsebobWork> if you don't have Xcode installed, you don't have gcc at all
07:46:19 <thoughtpolice> childe: if you have leopard installer disks then you should be fine. I was pretty dismayed myself, but luckily that saved me lots of time
07:46:49 <childe> Yes I do have that disk. It seems I have no choice but install that huge beast.
07:47:02 <nominolo_> childe: i think you can disable some things
07:47:20 <nominolo_> also, things like macports will need that, too
07:47:25 <childe> Maybe I can compile my own GHC binaries but I have to install GHC first to compile it.
07:47:31 <thoughtpolice> heh, i've only had this macbook for about 2 months and have come to the conclusion that if you're going to be developing stuff, you want xcode installed period. no telling how much stuff might 'need it'
07:47:33 <Cale> 1GB doesn't sound like too much... that's like a movie and a TV show ;)
07:47:47 <BeelsebobWork> childe: you don't need to install ghc to compile ghc -- you just need to do a bootstrap
07:47:49 <BeelsebobWork> which is hard work
07:47:49 <nominolo_> Cale: only 40min in HD!
07:47:58 <Cale> nominolo_: indeed
07:48:18 <nominolo_> childe: the ghc binary needs gcc at runtime
07:48:41 <childe> I'm too new to OS X...some friend told me to install Linux on this Mac (I'm a long time Linux user) but I still want to give OS X a try.
07:49:03 <nominolo_> childe: then check out macports or fink
07:49:05 <childe> It seems OS X is not so friendly for development after all.
07:49:07 <BeelsebobWork> childe: essentially, if you don't install the dev tools, you don't have gcc (or any other compilers/linkers)
07:49:21 <BeelsebobWork> childe: it's very friendly for development -- just install the development tools
07:49:23 <childe> nominolo_: I checked Fink and it's GHC package requires XCode, too.
07:49:30 <nominolo_> childe: sure, just install gcc & co. which comes with xcode
07:49:43 <childe> OK. Let just do it. Thank you all!
07:49:59 <nominolo_> childe: it's like Ubuntu in that regard :)
07:50:00 <BeelsebobWork> childe: the development tools are on your install DVD (for all versions of OS X), or on connect.apple.com
07:50:04 <childe> I'm going to get the install disk...have a nice day everyone!
07:52:59 <Gast09> Hey Traube wo bekommt man sone Linklisten her wo man man seine Spendenlinks eintragen kann und wo die nich aktiviert werden mssen?? haste da sone seite??
07:54:45 <jeffwheeler> I wonder what he said . . .
07:56:12 <byorgey__> DrSyzygy: sorry about that =(
07:56:56 <DrSyzygy> byorgey__: Not a big deal. But it's something I'm trying to push through as my academic persona - and I'm discovering, step by step, how much my real name screws people up nowadays...
07:57:06 <DrSyzygy> Which reminds me - who was it again who runs the aggregator?
07:58:23 <byorgey__> DrSyzygy: the Planet Haskell aggregator?  Antti-Juhani Kaijanaho, aka ibid
07:58:48 <DrSyzygy> Thanks
07:59:18 <DrSyzygy> @tell ibid Would you please change my name in the planet.haskell.org display - since about a year back, it's "Mikael Vejdemo-Johansson" not "Mikael Johansson"
07:59:19 <lambdabot> Consider it noted.
07:59:22 <DrSyzygy> There we go.
07:59:52 <byorgey> yeah, I think that's probably where I got the name, so that would help =)
07:59:58 <DrSyzygy> Yeah
08:00:16 <DrSyzygy> I realized when noting it in the HWN that the planet also had the wrong name.
08:00:21 <masak> DrSyzygy: congratulations on the longer name.
08:00:35 <DrSyzygy> masak: Thanks. But it's about a year back. :-)
08:00:42 <masak> still :)
08:00:48 <DrSyzygy> 11 months, +- a week, to be exacter.
08:00:49 <DrSyzygy> Thanks.
08:01:48 <Shiruka> that's not more exact, but maybe more accurate ;-)
08:02:27 <DrSyzygy> Shiruka: Saying "a year back" either means that today is the anniversary, or has an error sweep of something like +- 1-2 months.
08:02:41 <DrSyzygy> So how is it not more exact?
08:03:59 <Shiruka> by assuming that "about a year back" has more significant digits than "+- week" :-)
08:04:22 <DrSyzygy> Shiruka: What a weird assumption. :-P
08:04:24 <Shiruka> not a realistic assumption though, hence the ";-)"
08:04:29 <DrSyzygy> Heh
08:09:15 <zachk> does anyone know the quality of this book http://www.amazon.com/exec/obidos/tg/detail/-/0954300696/qid=
08:09:46 <zachk> its titled "the haskell road to logic, maths and programming"
08:10:55 <Twey> zachk: It seems quite nice
08:11:13 <Twey> Doesn't cover Haskell in great depth, but a nice introduction, especially if you care about the other topics too
08:12:50 <zachk> ive yet to read through my text on discrete mathematics, and im also looking for an intro to programming book for my brother, it seems like this book might be a decent fit
08:13:48 <Twey> Well, an intro to Haskell programming
08:13:59 <Twey> Most other languages are a little different
08:15:04 <zachk> they are quite different, containing looping keywords builtin to the language, and you can do x=x+1 in most other languages
08:15:52 <Cale> You can do it in Haskell, it just doesn't mean the same thing ;)
08:16:19 <zachk> > let x=x+1 in x
08:16:34 <lambdabot>  thread killed
08:16:46 <vixey> > letu x = 3 in do x <- return [x+1] ; return x
08:16:46 <lambdabot>  Parse error at "=" (column 8)
08:16:49 <vixey> > let x = 3 in do x <- return [x+1] ; return x
08:16:50 <lambdabot>   add an instance declaration for (Show (t [a]))
08:16:52 <Cale> Infinite loop :)
08:17:22 <mm_freak> > iterate (+1) 3
08:17:23 <lambdabot>  [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,3...
08:17:30 <zachk> > let x=3 in do x<-return(x+1)
08:17:30 <lambdabot>  Parse error at end of input
08:17:32 <lilachaze> > do { let {x = 3}; x <- return (x + 1); return x }
08:17:33 <lambdabot>   add an instance declaration for (Show (t a))
08:17:33 <vixey> > let x = 3 in do x <- return (x+1) ; return x
08:17:34 <lambdabot>   add an instance declaration for (Show (t a))
08:17:54 <vixey> > let x = (3::Integer) in (do x <- return (x+1) ; return x)
08:17:55 <lambdabot>   add an instance declaration for (Show (t Integer))
08:18:03 <mm_freak> what are you guys trying?
08:18:04 <lilachaze> > runIdentity $ do { let {x = 3}; x <- return (x + 1); return x }
08:18:05 <lambdabot>  4
08:18:35 <zachk> finally :-D
08:20:02 <osfameron> @pl \a init -> (f a) `Cons` init
08:20:02 <lambdabot> Cons . f
08:20:48 <Cale> > runST (do x <- newSTRef 0; modifySTRef (+1) x; readSTRef x)
08:20:49 <lambdabot>   Not in scope: `readSTRef'
08:21:16 <osfameron> @pl \f -> foldRight (Cons . f) Nil
08:21:16 <lambdabot> flip foldRight Nil . (Cons .)
08:21:20 <osfameron> meh
08:23:15 <byorgey> @pl \f -> foldr ((:) . f) []
08:23:15 <lambdabot> flip foldr [] . ((:) .)
08:23:30 <byorgey> it's just 'map' but I guess @pl doesn't know that one
08:24:07 <osfameron> heh
08:25:04 <Cale> > runST (do x <- newSTRef 0; modifySTRef x (+1); readSTRef x)
08:25:05 <lambdabot>  1
08:25:31 <lilachaze> Cale: botfix?
08:25:45 <Cale> lilachaze: yeah, it didn't have Data.STRef in its import list.
08:25:59 <Deewiant> > (`execState` 0) (do x <- get; put (x+1))
08:26:01 <lambdabot>  1
08:27:39 <osfameron> @pl (\a init -> if f a then (a `Cons` init) else init)
08:27:39 <lambdabot> join . ap ((.) . if' . f) Cons
08:27:48 * osfameron hugs his points
08:28:25 <EvilTerran> @pl \a -> if f a then Cons a else id
08:28:25 <lambdabot> flip (liftM2 if' f Cons) id
08:28:31 <EvilTerran> well, that's a mote better
08:28:52 <osfameron> ah, shiny
08:28:55 <Deewiant> ?ty \f -> flip f id
08:28:56 <lambdabot> forall a c a1. (a -> (a1 -> a1) -> c) -> a -> c
08:29:10 <EvilTerran> i still prefer "bool :: a -> a -> Bool -> a" to "if' :: Bool -> a -> a -> a"
08:29:52 <osfameron> what do they do?
08:30:00 <EvilTerran> same thing, different order of parameters
08:30:10 <osfameron> @index bool
08:30:11 <lambdabot> bzzt
08:30:11 <EvilTerran> if' p t e = if p then t else e
08:30:18 <EvilTerran> neither are in any library
08:30:21 <osfameron> ah
08:30:21 <EvilTerran> AFAIK
08:30:26 <osfameron> I like
08:30:31 <osfameron> (??), (!!)
08:30:35 <EvilTerran> if' takes its parameter order from if/then/else
08:30:47 <EvilTerran> (??)?
08:30:47 <mar77a> > (,) 1 2
08:30:48 <dons> feedback on our proposal/demo for the HW about hackage/cabal/platform would be welcome, particular the through to section 2. http://galois.com/~dons/tmp/batteries.pdf
08:30:48 <lambdabot> Title: cache:http://galois.com/~dons/tmp/batteries.pdf - Google Search
08:30:48 <lambdabot>  (1,2)
08:31:02 <EvilTerran> "bool" uses similar parameter order to "either" and "maybe"
08:31:14 <EvilTerran> a function for each possible constructor, then the value to deconstruct
08:31:21 <osfameron> EvilTerran: http://greenokapi.net/blog/2007/08/28/more-on-maybes-and-haskell-ternary/  oh, actually I used (?) and (!)
08:31:22 <lambdabot> Title: More on Maybes and Haskell Ternary - Just another lambdabananacamel,, http://tinyurl.com/5bbpsq
08:32:56 <EvilTerran> (?) looks really useful, actually
08:33:02 <EvilTerran> and makes a good operator
08:33:12 <osfameron> shame that (!) is already taken though
08:33:27 <EvilTerran> i think i had something similar called ?? and ?:
08:33:37 <EvilTerran> vaguely referencing the C ternary operator
08:33:49 <osfameron> yeah
08:34:29 <EvilTerran> (?!) and (!?)? :P
08:34:53 <Deewiant> I've used ? and ??
08:35:34 <EvilTerran> actually, a ! in the first one would be bad, because it usually implies indexing in haskell
08:35:37 <EvilTerran> (or in either)
08:37:18 <twanvl> > let (?) True = fst; (?) False = snd; infix 0 ?   in   1+1==2 ? ("good", "bad")
08:37:19 <lambdabot>  "good"
08:37:37 <DuClare> Is there somewhere a simple example of state monad in use?
08:38:12 <osfameron> twanvl: heh, cute
08:38:37 <Dynetrekk> how does a poor soul fix this: Couldn't match expected type `Int' against inferred type `Maybe t' ?
08:38:51 <Deewiant> depends on the poor soul's code
08:38:54 <Saizan_> > let (?) a b = if a then const b else id in even 2 ? "even" $ "odd"
08:38:55 <lambdabot>  "even"
08:39:09 <Deewiant> oo, cute
08:39:35 <ToRA> > runState (modify succ) 0
08:39:36 <lambdabot>  ((),1)
08:39:43 <osfameron> Saizan_: evil
08:39:49 <Dynetrekk> Deewiant: indeed... I want to use lookup in an "assosiation list", and then I get an int back (I know) but of course Haskell says it's maybe an int
08:39:51 <Deewiant> > let (?) a = if a then const else flip const in even 2 ? "even" $ "odd"
08:39:53 <lambdabot>  "even"
08:40:03 <Deewiant> Dynetrekk: if you're feeling confident, use fromJust :-)
08:40:10 <Deewiant> if not, handle the Nothing case somehow
08:40:23 <Dynetrekk> Deewiant: I figured this would do it:
08:40:29 <Dynetrekk>     let result = (lookup x charVals) in
08:40:29 <Dynetrekk>     if isJust x
08:40:30 <Dynetrekk>         then 0
08:40:30 <Dynetrekk>         else fromMaybe x
08:40:30 <Cale> Dynetrekk: case lookup ... of Nothing -> ...; Just x -> ...
08:40:36 <Deewiant> ?ty fromMaybe
08:40:37 <lambdabot> forall a. a -> Maybe a -> a
08:40:45 <Cale> Dynetrekk: you want case
08:40:50 <Deewiant> Dynetrekk: you want fromJust, not fromMaybe
08:40:55 <Cale> case lookup x charVals of
08:40:56 <Deewiant> case would be cleaner though :-)
08:40:58 <Cale>    Nothing -> 0
08:40:58 <byorgey> Dynetrekk: and in any case I think you mean 'if isJust result'
08:41:05 <Cale>    Just k -> k
08:41:06 <Dynetrekk> Deewiant: okay, case and then fromJust
08:41:12 <Deewiant> just case, rather
08:41:23 <Cale> Or,  maybe 0 id (lookup x charVals)
08:41:27 <Cale> :t maybe
08:41:27 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
08:41:37 <Dynetrekk> byorgey: my bad
08:41:37 <Deewiant> or, fromMaybe 0 (lookup x charVals)
08:41:46 <byorgey> Cale: even better, fromMaybe 0 (lookup x charVals)
08:41:57 <Cale> indeed
08:43:05 * EvilTerran notes that "p ? x = guard p >> return x" would be a more versatile definition of the former of the two
08:43:15 <EvilTerran> ?type \p x -> guard p >> return x
08:43:15 <lambdabot> forall (m :: * -> *) b. (MonadPlus m) => Bool -> b -> m b
08:44:13 <ToRA> @type curry . ([fst,snd] !!) . fromEnum
08:44:13 <EvilTerran> ?type \p x -> if p then empty else pure x -- or this
08:44:13 <lambdabot> forall b a. (Enum a) => a -> b -> b -> b
08:44:14 <lambdabot> forall (f :: * -> *) a. (Alternative f) => Bool -> a -> f a
08:44:30 <osfameron> EvilTerran: for the original one via Maybe?  Yeah
08:44:33 <osfameron> pure?
08:44:42 <EvilTerran> Control.Applicative.pure
08:44:50 <EvilTerran> (not to be confused with Control.Arrow.pure)
08:44:52 <EvilTerran> ?hoogle pure
08:44:53 <lambdabot> Control.Arrow.pure :: Arrow a => (b -> c) -> a b c
08:44:53 <lambdabot> Control.Applicative.pure :: Applicative f => a -> f a
08:45:11 <Cale> There should be a website called "Static Equilibrium or Not" where you rate pictures according to whether you think the depicted objects are in static equilibrium.
08:45:14 <EvilTerran> for Monads, pure = return
08:45:36 * Cale plays with the Hipmunk demo.
08:45:45 <osfameron> EvilTerran: I thought "return" was return for Monads? ;-)
08:46:13 <mauke> preflex: remember Cale There should be a website called "Static Equilibrium or Not" where you rate pictures according to whether you think the depicted objects are in static equilibrium.
08:46:51 <Twey> Hahaha
08:47:54 <ayianus> Kch.
08:48:08 <Twey> Oh it's an ayianus
08:48:16 * Twey welcomes.
08:48:23 * ayianus salutes.
08:49:07 <ayianus> Cale was kind enough to advise me to hang out here, Twey.
08:49:19 <Dynetrekk> Deewiant: what's the problem there? http://hpaste.org/9201
08:49:52 <Twey> Huh.  Cale is everywhere, isn't he?  :-P
08:49:54 <Deewiant> Dynetrekk: the type of "Just x" is Maybe <type of x>
08:50:05 <Twey> Oh, from #math I presume.
08:50:10 <Deewiant> ?ty fromJust
08:50:11 <lambdabot> forall a. Maybe a -> a
08:50:19 <Deewiant> Dynetrekk: the type of fromJust is the above
08:50:25 <Twey> @src fromJust
08:50:25 <lambdabot> fromJust Nothing  = undefined
08:50:25 <lambdabot> fromJust (Just x) = x
08:50:30 <Deewiant> Dynetrekk: you're applying fromJust to what the Maybe contains
08:50:39 <ayianus> Twey, Cale is omnipresent, yes. I suppose there's a tendency of him to be omnipotent, too. But that'd be presumptuous to claim.
08:50:41 <Dynetrekk> Deewiant: hm...
08:50:45 <Deewiant> what you want is just "Just result -> result"
08:50:52 <zachk> try this http://hpaste.org/9201#a1
08:51:11 * Twey laughs.
08:51:17 <zachk> wont work?
08:51:18 <Dynetrekk> Deewiant: that made perfect sense
08:51:23 <Deewiant> :-)
08:51:42 <Dynetrekk> zachk: thanks, I already thought of that. good idea, but I wanted to learn WHY OH WHY
08:51:47 <Dynetrekk> (and so on)
08:51:57 <zachk> Dynetrekk: i usually just want it to work
08:52:30 <Deewiant> until you notice, much later, that it doesn't work, /and/ you don't understand why ;-)
08:52:45 <Dynetrekk> zachk: but then how the f*** am I supposed to get it to work next time, when I need the Just result -> result thingy? ;)
08:52:50 <Twey> Dynetrekk: Your indenting is dodgy
08:52:55 <Dynetrekk> Deewiant: exactly
08:53:03 <Twey> The case needs to be indented one more level
08:53:06 <Dynetrekk> Twey: I'm not surprised, but what in particular?
08:53:13 <zachk> well its either Nothing or Just a
08:53:14 <Twey> So that it's within the 'let'
08:53:34 <Dynetrekk> Twey: aha, the case is _inside_ the 'let'? didn't think of that
08:53:46 <Twey> Dynetrekk: Yes, let isn't like an =
08:53:47 <Deewiant> Dynetrekk: hence, let .. *in* :-)
08:53:50 <Twey> It's more like Lisp let
08:53:52 * Twey nods.
08:54:00 <zachk> lambda lambda lambda
08:54:06 <Dynetrekk> Twey: don't know too much Lisp
08:54:11 <Dynetrekk> zachk: mushroom mushroom?
08:54:19 <pozic> dons: distribut spelling error
08:54:31 <byorgey> are we talking about http://hpaste.org/9201 ?
08:54:44 <Dynetrekk> byorgey: yep
08:54:44 <Twey> Dynetrekk: Also, that's not quite how it works
08:54:45 <zachk> we are/were
08:55:02 <Dynetrekk> Twey: enlighten me :)
08:55:03 <Twey> Dynetrekk: If (Just result) matches, then a new binding is made that goes over the old result
08:55:05 <byorgey> the main problem there is the line 'Just result -> fromJust result', did someone already say that?
08:55:08 <Twey> Which is the value inside the result
08:55:13 <byorgey> oh, ok, Twey is explaining that
08:55:14 <Twey> byorgey: Just getting to it :-)
08:55:30 <Twey> So, the whole thing can be: valueOf x = case (lookup x charVals) of Nothing -> 0; Just result -> result
08:55:35 <Deewiant> and I already got to it :-P
08:55:36 <zachk> is that type matching or monad matching?
08:55:37 <byorgey> ok, never mind, I only say people talking about indentation =)
08:55:41 <Dynetrekk> Twey: but refresh the page, zachk made an update...
08:55:41 <byorgey> *saw
08:55:44 <Deewiant> pattern matching ;-)
08:55:46 <Twey> Oh, did you, sorry Deewiant
08:55:50 <Twey> Was having a shower :-)
08:55:52 <dons> pozic: fixed.
08:55:52 <Twey> Dynetrekk: Aye, I know
08:56:03 <pozic> dons: also in your TODO there is a spelling error
08:56:08 <pozic> dons: but that's not important.
08:56:11 <Twey> Dynetrekk: zachk's is correct (but a little dodgy)
08:56:27 <Twey> He says 'match anything except Nothing and then call fromJust on the whole thing'
08:56:29 <pozic> dons: what's the target audience?
08:56:29 <Dynetrekk> Twey: but with correct indentation it is Pure and So On Haskell?
08:56:35 <Twey> Yepyep
08:56:38 <christastrophe> this might be an obvious question, but how come haskell doesn't have a Hashable typeclass (in the same line as Eq and Ord)?
08:56:53 <pozic> dons: bbl
08:56:53 <Twey> But the only thing other than Nothing it could possibly be is a Just, so if you're extracting it anyway you might as well do so in the pattern tehre
08:56:56 <Twey> there**
08:56:58 <Dynetrekk> Twey: but then I did 'Just result -> result' in the end
08:57:01 <zachk> Data.Map was suggested to me instead of using hashes
08:57:49 <byorgey> christastrophe: probably because no one's ever needed it.  hash tables are difficult to implement in haskell.
08:58:13 <Twey> Dynetrekk: Refresh, annotated
08:58:15 <lilachaze> christastrophe: it has been claimed that Data.HashTable shouldn't be used.
08:58:16 <byorgey> there is a hash table implementation, but it's sort of ugly and deprecated, IIUC.
08:58:40 <Dynetrekk> Twey: I see. but now you don't catch the "Nothing" case?
08:58:45 <Twey> Dynetrekk: I do
08:58:49 <Twey> Nothing -> 0
08:58:54 <Twey> You see?
08:58:54 <Dynetrekk> Twey: that's the 0? oh, OK.
08:58:58 <byorgey> zachk: yup, for most applications, a Data.Map is pretty much just as good as a hash table, despite the extra O(lg n) factor
08:59:00 <Dynetrekk> Twey: makes sense
08:59:07 <Twey> Good :-)
08:59:14 <christastrophe> i was just looking at Set, and noticed that it needs values that have Ord, but a Set only needs to garuntee Eq over its elements
08:59:26 <christastrophe> so you have the implementation leaking through
08:59:30 <mauke> christastrophe: not if you want it to be efficient
08:59:32 <byorgey> christastrophe: yeah, that's somewhat unfortunate
08:59:45 <Dynetrekk> Twey: would it look nicer with $ instead of (lookup.. ) ?
08:59:48 <zachk> the extra O(log n) factor you can almost assume to be constant if you are working with sufficiently small n
09:00:02 <Twey> Dynetrekk: No, although I think the brackets may be superfluous there *checks*
09:00:10 <byorgey> zachk: exactly.
09:00:22 <christastrophe> if you had a Hashable typeclass that returned say an Int32, and made that the requirement for Set, wouldn't that hide the fact that the underlying imp. uses a tree?
09:00:41 <Twey> Dynetrekk: Yes, superfluous
09:00:46 <christastrophe> err, the typeclass doesn't return an Int32, but the single funtion in the typeclass 'hash' would :)
09:01:02 <Twey> Dynetrekk: You can't use $ because case isn't a function
09:01:20 <Twey> But on the flipside of that, you don't need to use $, because case isn't a function :-)
09:01:24 <byorgey> christastrophe: I don't understand what you are proposing.
09:01:26 <Cale> christastrophe: Uh, isn't "there exists a function to Int32" a much heavier constraint than Ord?
09:01:47 <Dynetrekk> Twey: I've gone with the lilac solution
09:02:02 <Dynetrekk> Twey: so I guess we're discussing two different things
09:02:03 <Twey> Dynetrekk: Oh who did that?  *laughs*
09:02:04 <Deewiant> ?ty const (0 :: Int32)
09:02:05 <lambdabot> forall b. b -> Int32
09:02:08 <Twey> I forgot about the fromMaybe
09:02:13 <Deewiant> Cale: doesn't seem that heavy a constraint to me ;-)
09:02:14 <Twey> Dynetrekk: Yes, I would use $ there
09:02:17 <Twey> Matter of style, though.
09:02:26 <Cale> Deewiant: well, a useful function for hashing
09:02:58 <Dynetrekk> Twey: right. lisp-style or hip-jop
09:03:41 <EvilTerran> hehe. "Scaling Everest was, by far, the most amazing and transformative experience of my life. Unfortunately, this is a thesis on context-free grammars."
09:04:01 <Twey> Hahahaha
09:04:03 <Deewiant> :-D
09:04:40 <christastrophe> byorgey: im just musing on how Set could lift the Ord requirement, and still use a tree underneath... if everything inserted could be hashed (and since Int32 is orderable) underneath you could still use a tree, but now Set doesn't restrict you to types of Ord (of course now it would restrict you to types of Hashable :) )
09:05:23 <byorgey> christastrophe: well, but practically speaking that wouldn't work if you had any hash collisions.
09:05:29 <EvilTerran> christastrophe, you could write an Ord instance for anything with a Hashable instance, anyway
09:05:58 <christastrophe> EvilTerran: true, which makes the point moot I suppose...
09:06:53 <christastrophe> byorgey: you could chain a list off the tree, and drop back to Eq comparisons -- since its a Set you still need Eq ...
09:07:01 <Cale> Well, you could write a crappy Ord instance...
09:07:06 <byorgey> oh, if you still require Eq, then sure
09:07:21 <Zao> Without a sane Eq, you couldn't enforce uniqueness.
09:07:34 <Cale> christastrophe: But then you have to worry about hash collisions.
09:07:42 <christastrophe> yeah, I guess now you'd need Eq and Hashable... which just makes it more complex than just having Ord.
09:08:28 <christastrophe> Cale: you'd have to resolve the collisions in a seperate step...
09:08:51 <EvilTerran> Ord implies Eq anyway, doesn't it?
09:08:55 <Cale> christastrophe: I mean, you'd end up with O(n) behaviour in bad cases.
09:09:48 <christastrophe> Cale: true, but don't you get O(n) with Ord as well (if the input is degenerate?)
09:11:13 <Cale> christastrophe: no
09:12:01 <Cale> It's always log(n) insertion, because the trees are kept balanced.
09:13:45 <christastrophe> hmm, perhaps a Hashable would need to provide 'hash' and 'hash2' :) not that this would solve the degenerate case you mentioned Cale.
09:14:06 <christastrophe> it seems Ord is a reasonable trade off for the Set
09:16:35 <Cale> christastrophe: yeah... especially since any total ordering will do, and it's usually easy enough to provide one of those, at least for the types where you can do equality testing, anyway.
09:17:20 <Cale> It's much easier to come up with a total ordering (and check that it's good) than it is to come up with an acceptable hash function.
09:17:55 <vixey> there's no deriving Ord..
09:17:56 <christastrophe> Cale: although, if you used the hash value as the key in a balanced tree (using the Set implementation, but changing the Ord requirement to Hashable) then the O(n) goes away just as it does now ; but your point about total order over a good hash remains true...
09:17:58 <vixey> but it could be derived
09:18:04 <vixey> or is there
09:18:08 <Cale> vixey: there is
09:19:57 <Cale> christastrophe: well, generally it's hard to ensure that you don't have any hash collisions, unless you're "hashing" to something like Integer rather than Int32
09:20:20 <Cale> (collisions are what cause the O(n) worst case behaviour)
09:21:42 <christastrophe> Cale: ugh yes (i type faster than I think sometimes), then you
09:22:02 <christastrophe> Cale: have the second and third order hash functions, and thats just a mess...
09:22:40 <Cale> Hashtables are overrated :)
09:22:52 <lilachaze> Cale: isn't good hashing essentially a solved problem? ie, it's trivial, for the right trivia :)
09:23:07 <Cale> lilachaze: for arbitrary datastructures?
09:23:26 <mauke> ... deriving (Hashable)
09:23:38 <Cale> lilachaze: I think the construction of hash functions is still more art than science.
09:23:43 <lilachaze> for arbitrary data structures which are the product of a reasonable set of primitive types, at least
09:23:45 <christastrophe> this post about improving nub is what sent me (and now you) down this rabbit hole:  http://rant.blackapache.net/2008/07/28/a-better-nub/
09:23:46 <lambdabot> Title: A Better nub " OJs rants
09:24:44 <vixey> christastrophe: that post makes no sense..., it's not a better nub it's a totally different function
09:24:47 <lilachaze> Cale: i seem to recall that there's a method of combining hash values which provably lifts good hash functions from types to their products (for some defintiion of good)
09:26:07 <christastrophe> vixey: nub is supposed to collapse adjacent Eq elements from a list, correct?
09:26:19 <vixey> no
09:26:20 <lilachaze> come to think of it, MD5'ing the concatenation of the values is probably pretty reasonable
09:26:28 <vixey> > nub [1,8,1]
09:26:32 <lambdabot>  [1,8]
09:26:41 <mar77a> ?hoogle md5
09:26:42 <lambdabot> No matches found
09:26:45 <mar77a> ?hoogle MD5
09:26:46 <lambdabot> No matches found
09:26:47 <christastrophe> oh, so it does return a list of uniqe elements
09:26:47 <zachk> how do i give a type signature in ghcI
09:26:50 <mauke> > nub [0..]
09:26:52 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
09:27:11 <mauke> zachk: with ::
09:27:14 <vixey> christastrophe, the biggest problem with the definition in that post is the type
09:27:23 <mar77a> > [0..] \\ [1..10]
09:27:24 <lambdabot>  [0,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,3...
09:27:28 <Cale> > map head . group $ [1,1,1,2,2,1,1]
09:27:32 <lambdabot>  [1,2,1]
09:27:34 <zachk> mauke: where do i put that in the let definition
09:27:37 <Cale> > map head . group . sort $ [1,1,1,2,2,1,1]
09:27:38 <lambdabot>  [1,2]
09:27:49 <mauke> zachk: let whatever :: Type; whatever = definition
09:27:59 <zachk> oh ok thank you mauke
09:28:06 * Twey frowns.
09:28:09 <christastrophe> vixey: because he changes the Eq requirement to an Ord?
09:28:15 <Twey> > group [1, 1, 2, 2, 1]
09:28:16 <lambdabot>  [[1,1],[2,2],[1]]
09:28:19 <Twey> Ah
09:28:51 <mauke> > nubBy(((>1).).gcd)[2..]
09:28:52 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
09:30:04 <zachk> holy smokes sieves of erastothenes in about one line...wow go haskell
09:30:14 <lispy> > let primes = nubBy(((>1).).gcd)[2..]
09:30:14 <lambdabot>  Parse error at end of input
09:30:29 <lispy> ?let primes = nubBy(((>1).).gcd)[2..]
09:30:30 <lambdabot> Defined.
09:30:35 <lispy> > primes
09:30:36 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
09:30:42 <mauke> > drop 1000 primes
09:30:44 <EvilTerran> zachk, it's not a sieve of eratothsenes, it's just a naive filter
09:30:44 <lambdabot>  [7927,7933,7937,7949,7951,7963,7993,8009,8011,8017,8039,8053,8059,8069,8081,...
09:30:52 <EvilTerran> worse O() class
09:31:07 <Baughn> > last primes
09:31:12 <zachk> EvilTerran: does it actually give me primes though?
09:31:13 <lambdabot>  Exception: Time limit exceeded
09:31:17 <Cale> zachk: yes
09:31:23 <EvilTerran> zachk, yes, it really gives you the primes. just not in the most efficient way.
09:31:25 <vixey> prove it
09:31:29 <Cale> zachk: but more slowly than a real sieve would
09:31:31 <mauke> @check primes
09:31:35 <lambdabot>   add an instance declaration for (Testable [Integer])     In the expression:...
09:31:35 <r3m0t> :t nubBy
09:31:36 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
09:31:50 <EvilTerran> vixey, prove what? that it's not the most efficient approach, or that it really produces the primes?
09:32:01 <vixey> that it produces all the primes
09:32:19 <scodil> prove that it doesn't
09:32:19 <Cale> zachk: the key point about the sieve of Eratosthenes is that it doesn't have to recompute mod/gcd for each pair, once it's found a prime
09:32:24 <zachk> Cale: but a real sieve i need a max value
09:32:29 <EvilTerran> well, it's the same as "nubBy (\x y -> gcd x y > 1) [2..]"
09:32:39 <Cale> zachk: not necessarily, but it's more complicated
09:32:40 <EvilTerran> ?src nubBy
09:32:40 <lambdabot> nubBy eq []             =  []
09:32:40 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
09:32:41 <lilachaze> are there any extensions for user-defined "deriving"?
09:32:58 <Cale> zachk: there's still a real-sieve way to do the infinite list of primes
09:33:09 <zachk> Cale: is it painful?
09:33:18 <Cale> zachk: It's more than one line ;)
09:33:25 <Cale> But from what I recall, not too bad
09:33:34 <zachk> yea my scheme sieve interpreted had all the primes under a million under a minute, this thing hasnt gotten past 70,000 yet
09:33:38 <EvilTerran> which is "let f [] = []; f (x:xs) = x : f (filter (\y -> not (gcd x y > 1)) xs) in f [2..]"
09:34:08 <EvilTerran> f (x:xs) simplifies to "= x : filter (\y -> gcd x y <= 1) xs"
09:34:24 <EvilTerran> we can drop the f [] case, as our input list is infinite
09:34:40 <EvilTerran> so no amount of filtering will get us to [] - it can only get us to a (:) or to _|_
09:34:40 <vixey> you left out the f
09:34:45 <EvilTerran> yes
09:36:11 <ddarius> There aren't too many channels where one is (non rhetorically) challenged to formally prove something.
09:36:20 <EvilTerran> i'm not entirely familiar with the inductive step required at this point, as it's only kinda co-recursive
09:36:23 <EvilTerran> but i can outline it
09:36:33 <vixey> well I don't understand that step,
09:36:47 <vixey> shouldn't "= x : filter (\y -> gcd x y <= 1) xs" be "= x : f (filter (\y -> gcd x y <= 1) xs)" ?
09:36:58 <EvilTerran> <vixey> you left out the f <EvilTerran> yes
09:37:06 <vixey> I still don't understand why ...
09:37:15 <zachk> using 60 to 86% of my processor but only about 2.4 megs of ram
09:37:53 <EvilTerran> > let f (x:xs) = x : f (filter (\y -> y `mod` x /= 0) xs) in f [2..] -- i'll switch to this one, actually. easier.
09:37:54 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
09:38:10 <EvilTerran> comes to the same thing, but there's less wrangling about in that lambda
09:38:26 <vixey> > let f (x:xs) = x : filter (\y -> y `mod` x /= 0) xs in f [2..]
09:38:27 <lambdabot>  [2,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
09:38:41 <ddarius> There's a "big step" way of understanding it.  It collapses equivalence classes of numbers that are not coprime to each other.
09:39:18 <EvilTerran> vixey, i know, i forgot the f. that's what i meant by "yes". sorry if that wasn't clear.
09:39:25 <vixey> ohhh
09:39:31 <vixey> ok I understand
09:39:35 <zachk> > let sieve (n:xs)=n:filter(\m->(rem m n)/=0)xs) in sieve[2..]
09:39:35 <lambdabot> Unbalanced parentheses
09:39:37 <Cale> and the least element of each equivalence class is chosen as the representative
09:40:40 <EvilTerran> then, looking at that new formulation, we'll use the predicate "in the body of f (x:xs), no values in x:xs divide by any prime (<x)"
09:40:59 <EvilTerran> clearly, in the initial case (f [2..]), that's true, as there are no primes <2
09:41:41 <EvilTerran> assuming it's true for the parameter to f(x:xs), it clearly remains true for the recursive step
09:41:47 <vixey> hmmm
09:41:49 <EvilTerran> as the only prime (< head xs) is x
09:41:54 <EvilTerran> and we filter out all multiples of that
09:42:33 <twobitwork> :t rem
09:42:34 <lambdabot> forall a. (Integral a) => a -> a -> a
09:42:43 <twobitwork> @src rem
09:42:44 <lambdabot> Source not found. There are some things that I just don't know.
09:42:52 <twobitwork> ?src list rem
09:42:52 <lambdabot> Source not found. Are you on drugs?
09:43:03 <lispy> I recall in a PL class I took, having to write a formal proof that an imperative GCD was correct and a formal proof that a Haskell GCD was correct.
09:43:08 <twobitwork> where is that?
09:43:26 <vixey> lispy, how did the two compare?
09:43:28 <mauke> probably in a typeclass
09:43:31 <lispy> You can guess how much shorter the Haskell proof was given that we could use equational reasoning
09:44:10 <lispy> vixey: the Haskell proof was essentially a short inductive proof like you would expect in math.  The other proof was long and involved looking at the cases and how values were updated.  I forget even how to start that proof.
09:44:52 <ddarius> lispy: You start with the loop invariant.
09:47:26 <lispy> ddarius: oh, that does sound familiar, and then work backwards or something from the last iteration?
09:47:39 <lispy> Sort of like induction or is my memory faulty?
09:47:48 <EvilTerran> we prove iterative algorithms by picking an invariant and a variant
09:47:53 <vixey> actually there's a video of dijkstra proving this online
09:48:18 <EvilTerran> then proving that, assuming the invariant and the guard (in the case of a "while", anyway), the invariant is true at the end of the body
09:48:40 <EvilTerran> and also that the variant has decreased
09:48:45 <vixey> hmm
09:48:49 <EvilTerran> (the invariant is a predicate, and the variant a natural number)
09:48:54 <vixey> what I am interested in is which methods of proof are valid
09:49:01 <EvilTerran> as the variant is >=0, if it must decrease every iteration, that proves termination
09:49:02 <vixey> like how do you derive these methods?
09:49:32 <EvilTerran> vixey, i think by transformation of your iteration into a recursive functional form with immutable values
09:51:15 <EvilTerran> while (p(x0..xN)) { x0..xN := f(x0..xN) }  -->  let loop(x0..xN) | p(x0..xN) = loop $ f(x0..xN) | otherwise = (x0..xN)  -- that kinda thing
09:51:27 <EvilTerran> not sure how you deal with side-effects
09:51:38 <EvilTerran> other than assignment to local variables
09:52:38 <Saizan_> use a monad :)
09:52:54 <Dynetrekk> anyone know why this crashes? http://hpaste.org/9203
09:53:36 <osfameron> @pl \l f = foldRight (\a init -> append (f a) init) Nil l
09:53:36 <lambdabot> (line 1, column 6):
09:53:36 <lambdabot> unexpected "="
09:53:36 <lambdabot> expecting pattern or "->"
09:53:45 <osfameron> @pl \l f -> foldRight (\a init -> append (f a) init) Nil l
09:53:45 <lambdabot> flip (flip foldRight Nil . (append .))
09:53:58 <vixey> > let string = "\"A\",\"List\",\"of\",\"words\"" ; listify string = (read ("[" ++ string ++ "]") :: [String]) in listify string
09:54:00 <lambdabot>  ["A","List","of","words"]
09:54:24 <EvilTerran> > read . ("["++) . (++"]") $ "\"a\",\"list\",\"of\",\"words\"" :: [String]
09:54:25 <lambdabot>  ["a","list","of","words"]
09:54:30 <EvilTerran> doh, beaten to the punch
09:54:44 <EvilTerran> Dynetrekk, what exactly happens?
09:55:02 <Dynetrekk> EvilTerran:  P42.hs:24:33:
09:55:02 <Dynetrekk>     Couldn't match expected type `[Char]'
09:55:02 <Dynetrekk>            against inferred type `[Char] -> [Char]'
09:55:02 <Dynetrekk>     In the first argument of `listify', namely `rest'
09:55:04 <Dynetrekk>     In the second argument of `(:)', namely `(listify rest)'
09:55:04 <Dynetrekk>     In the expression:
09:55:04 <Dynetrekk>         let suf = dropWhile ((/= '"')) str in
09:55:06 <Dynetrekk>         let
09:55:08 <Dynetrekk>           word = takeWhile ((/= '"')) $ tail suf
09:55:10 <EvilTerran> whoa, whoa
09:55:10 <Dynetrekk>           rest = dropWhile ((/= ','))
09:55:12 <Dynetrekk>         in (word : (listify rest))
09:55:14 <Dynetrekk> Failed, modules loaded: none.
09:55:17 <EvilTerran> annotate your error to the paste, please
09:55:21 <Dynetrekk> EvilTerran: eh, sorry, but that's what I get in ghci. should've pasted it I guess
09:55:24 <EvilTerran> if it's more than one or two lines
09:55:32 <EvilTerran> that's not a crash, anyway
09:55:36 <EvilTerran> it's a type-checking error
09:56:01 <EvilTerran> and it tells you what the problem is
09:56:11 <Dynetrekk> EvilTerran: okay, that's true. but, I don't catch the problem...
09:56:15 <EvilTerran> namely, that it's inferres "rest" to have type "[Char] -> [Char]"
09:56:29 <EvilTerran> "rest = dropWhile (/= ',')
09:56:29 <EvilTerran> "
09:56:32 <EvilTerran> ?type dropWhile
09:56:33 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
09:56:37 <EvilTerran> dropWhile takes two parameters
09:57:04 <EvilTerran> you're only giving it the first, so rest is a function expecting the second
09:57:12 <Dynetrekk> EvilTerran: wow. how did you read that from the error message?
09:57:15 <Dynetrekk> aaah.
09:57:43 <EvilTerran> "Couldn't match expected type `[Char]'" refers to the same place in code as "In the first argument of `listify'"
09:57:59 <EvilTerran> that tells you that listify wants a String (= [Char]) as its first parameter, but hasn't recieved one
09:58:02 <jeffwheeler> Dynetrekk: the first bit of the error tells you it's getting a function that accepts and returns [Char], while you're using it as just [Char]
09:58:17 <jeffwheeler> Err, other way around.
09:58:26 <EvilTerran> and "inferred type `[Char] -> [Char]'" and "namely `rest'" tell you the inferred type of the parameter, and what the parameter expression actually was
09:58:31 <Dynetrekk> jeffwheeler: no, it says expects [Char] but gets [Char]-Z[Char]
09:58:41 <Dynetrekk> jeffwheeler: where Z is >
09:58:44 <jeffwheeler> Yeah; I had it backwards, but same idea.
09:59:02 <Dynetrekk> jeffwheeler: indeed!
09:59:50 <Dynetrekk> weee, it works now...
10:02:02 <zachk> the simple prime sieve starts to slow down around 265000
10:02:16 <osfameron> @pl \init a -> a `Cons` init
10:02:16 <lambdabot> flip Cons
10:02:52 <vixey> what's the fastest prime number generator?
10:03:58 <DuClare> Eep.
10:04:01 <zachk> i forget the name of it but writing and implementation of it is usually sufficient for a master thesis
10:04:44 <Twey> zachk: The Sieve of Atkin?
10:04:52 <zachk> thats not the fastest
10:04:56 <Dynetrekk> zachk: is there A fastest prime generator?
10:05:10 <Elly> special number field sieve?
10:05:16 <zachk> like provably fastest? i dont believe so
10:05:30 <Dynetrekk> zachk: I would guess it can depend heavily on whether you're allowed to come up with any prime, or all the N smallest ones, or similar
10:05:58 <Dynetrekk> zachk: no, provably would probably mean  a nobel price in litterature or something
10:06:09 <zachk> fields medal
10:06:32 <Elly> nobel prize in literature for a provably fastest prime number generator would mean you had one hell of a well-written paper
10:06:33 <lilachaze> good ol' mathematician-hating nobel
10:06:34 <Dynetrekk> zachk: assuming you're not too old
10:06:48 <zachk> how old do you have to be to get the field's
10:06:50 <vixey> Elly lol
10:07:04 <Dynetrekk> Elly: but you would deserve a nobel, and there isn't one in math, so...
10:07:18 <Dynetrekk> Elly: meaning, most likely, you invented the whole thing -> a good story
10:07:21 <Elly> Dynetrekk: you could steal the chemistry one; those guys aren't using it :)
10:08:01 <Dynetrekk> Elly: well, physics and chemistry are more confined than litterature, so... I just went for litterature while I was at it
10:08:33 <twobitwork> literature
10:08:39 <FordCortina> is a nested type a type which has a type variable that runs through the whole type. i.e. Nested a = Foo a | Bar (Foo a) (Foo a), UnNested a = Cheese | Ham (UnNested a) (UnNested a) ?
10:08:52 <Dynetrekk> twobitwork: sorry, I'm not litterate :)
10:08:58 <twobitwork> Dynetrekk: :)
10:09:14 <vixey> FordCortina: I thought it was like  data Foo x = Bar (Foo (x,x)) i.e. recursion but not with the same variable
10:09:32 <FordCortina> vixey: ah
10:10:41 <trinisoftinc> anyone home
10:10:47 <twobitwork> nope
10:10:54 <Elly> nobody at all
10:11:01 <Elly> I'm at work though :P
10:11:02 <Twey> Not a soul
10:11:04 <jeffwheeler> I think everybody's at work. ;)
10:11:19 <trinisoftinc> cool..coz i was just wondering
10:11:20 <Elly> that person speaks the truth
10:11:35 <twobitwork> well.. I'm at my place of employment, as for being "at work", that's questionable :)
10:11:49 <Elly> I'm sitting in the chair I usually sit in when doing work
10:11:54 <Elly> except instead I am IRCing and reading news
10:12:00 <twobitwork> heh
10:12:02 <jeffwheeler> No news, but yes IRC.
10:12:05 <Elly> but it's monday morning and nobody else is here yet :P
10:12:27 <twobitwork> I'm trying to avoid looking at more perl code for a little while
10:12:37 <twobitwork> perl hurts my head
10:12:48 <jeffwheeler> Perl 5 or 6?
10:12:51 <twobitwork> 5
10:12:52 <trinisoftinc> i am a green horn....was at d website and follwd some instructns and i find myself here
10:13:03 <jeffwheeler> Ah, then you have no excuse to play with Pugs. :-/
10:13:08 <Elly> trinisoftinc: you should use whole words
10:13:09 <Zao> trinisoftinc: Welcome to the internets.
10:13:14 <mmorrow> > runST (do x <- newSTRef 0; modifySTRef x (+1); readSTRef x)
10:13:16 <lambdabot>  1
10:13:21 <twobitwork> jeffwheeler: heh, nope...
10:13:22 <Dynetrekk> twobitwork: I only heard bad things about perl. are they all true?
10:13:25 <mmorrow> whoa, S
10:13:26 <mmorrow> T
10:13:55 <Elly> that's funny...I could swear I was failing a whole raft of unit tests on friday, but now they are all passing...
10:13:59 <twobitwork> Dynetrekk: I suppose it depends on what those bad things woere
10:14:08 <Elly> maybe someone snuck in over the weekend and debugged my code
10:14:21 <Dynetrekk> twobitwork: that it's all a mess and unreadable and so on
10:14:24 <jeffwheeler> Elly: a vcs should make that obvious :)
10:14:27 <twobitwork> Elly: your computer just needed to sleep on it for a bit :P
10:14:43 <Elly> jeffwheeler: I svn up'd, and a bunch of files were changed, some of them indeed in my component
10:14:46 <Dynetrekk> twobitwork: bit or byte?
10:14:50 <twobitwork> Dynetrekk: it definately can be.. and it is much easier to write spaghetti code in perl than to not
10:15:00 <jeffwheeler> Elly: your computer couldn't sleep, so it found something to do
10:15:02 <trinisoftinc> i hear good things about perl...like perl golf
10:15:02 <trinisoftinc> Elly:thanks
10:15:04 <Zao> Elly: It's the code fairy, which fixes your code if you have been nice.
10:15:08 <Dynetrekk> twobitwork: I see. duly noted.
10:15:25 <Elly> Zao: but it's C++! I thought the code fairy wouldn't touch it
10:15:38 <mmorrow> :t undefined::RealWorld
10:15:39 <lambdabot> RealWorld
10:16:07 <Zao> Elly: The code fairy is closely related to the garden gnomes, which will rewrite your code into template metaprogramming.
10:16:36 <twobitwork> well... I suppose things could be worse... I could be stuck debugging template metaprogramming C++ :P
10:16:38 <trinisoftinc> Elly:maybe you sleep-work,
10:16:56 <Elly> Zao: if my code is now template metaprogramming, I'm so fucked :P
10:17:09 <Zao> Elly: It could be worse, it could be Boost.Preprocessor code.
10:17:12 <Elly> trinisoftinc: it's possible, but would be strange
10:17:35 <twobitwork> Elly: even stranger that you code better in your sleep... :P
10:17:50 <mmorrow> > runST . unsafeIOToST $ return()
10:17:52 <Elly> twobitwork: that *would* be weird
10:17:54 <lambdabot>      Inferred type is less polymorphic than expected
10:17:54 <lambdabot>       Quantified type va...
10:17:55 <Elly> twobitwork: possible I guess
10:18:22 <lilachaze> > let merge (a:as) bs = a:merge bs as in head $ foldr1 merge $ [1..]:undefined
10:18:24 <lambdabot>  Exception: Prelude.undefined
10:18:26 <twobitwork> I mean, I've dreamed about programming before, but its usually full of syntax errors, even if the algorithm is sound
10:18:31 <mmorrow> > runST (unsafeIOToST return())
10:18:32 <lambdabot>  Couldn't match expected type `IO a'
10:18:32 <lilachaze> @src foldr1
10:18:33 <lambdabot> foldr1 _ [x]    = x
10:18:33 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
10:18:33 <lambdabot> foldr1 _ []     = undefined
10:18:46 <mmorrow> > runST (unsafeIOToST (return()))
10:18:47 <lambdabot>  ()
10:18:47 <trinisoftinc> u do stuffs better while u are sleeping
10:18:50 <hackage> Uploaded to hackage: HXQ 0.8.5.1
10:18:52 <mmorrow> uh
10:18:58 <trinisoftinc> like u will be able to fold a car into ur pockect and walk past the check point
10:18:59 <dolio> That's bad.
10:19:06 <mmorrow> > runST (unsafeIOToST (print 42))
10:19:07 <lambdabot>  ()
10:19:11 <mmorrow> uhoh
10:19:38 <mmorrow> Cale: ^^^
10:19:40 <twanvl> > runST (unsafeIOToST (getCurrentDirectory))
10:19:41 <lambdabot>   Not in scope: `getCurrentDirectory'
10:19:45 <lilachaze> > -- runST (unsafeIOToST (readFile "/etc/passwd"))
10:19:46 <lambdabot>   parse error on input `}'
10:20:07 <Cale> mmorrow: ah, heh
10:20:11 <mmorrow> hehe
10:20:29 <lilachaze> does \bot run chrooted?
10:20:45 <trinisoftinc> there are no = in lisp
10:20:54 <twobitwork> trinisoftinc: sure there is
10:21:09 <trinisoftinc> u sure?
10:21:24 <trinisoftinc> i av not seen any...b
10:21:27 <twobitwork> well... I'm not sure about CL, but scheme sure has an = function
10:21:32 <Cale> > unsafeIOToST (print 0)
10:21:32 <lambdabot>   Not in scope: `unsafeIOToST'
10:21:37 <Cale> okay, good :)
10:21:57 <trinisoftinc> oh
10:22:08 <trinisoftinc> twobitwork:example pls
10:22:26 <twobitwork> (= 4 4)
10:22:47 <twobitwork> ?
10:23:26 <lilachaze> why does "head . foldr1 f" force the second element of the list?
10:23:32 <trinisoftinc> does dt really work like (= fred smith)
10:23:34 <lilachaze> or rather, the second cons cell
10:23:56 <twobitwork> trinisoftinc: http://paste.lisp.org/submit
10:23:58 <hml> are the code examples from  ahskell soe available online anywhere?
10:24:10 <Elly> > (= 4 4)
10:24:10 <Elly> #t
10:24:10 <lambdabot>  Parse error at "=" (column 2)
10:24:11 <lispy> hml: I thought so
10:24:17 <lispy> hml: but, I don't know where :(
10:24:19 <Elly> er, silly lambdabot
10:24:24 <DrSyzygy> Elly: ...
10:24:30 <DrSyzygy> > (==) 4 4
10:24:31 <Elly> I have failed at REPL
10:24:31 <lambdabot>  True
10:24:46 <Elly> DrSyzygy: that was intended to be an example of scheme's = function, for trinisoftinc
10:24:50 <DrSyzygy> Ah.
10:25:48 <trinisoftinc> sincerely i will love to stay with c++, but my boss suddenly wants me to implement some scheme
10:26:09 <Elly> scheme is much nicer than C++ :)
10:26:18 <Elly> you may prefer #scheme to here though
10:26:33 <twobitwork> trinisoftinc: it can be intimidating at first, but its well worth it... then again, anything is better than C++...
10:26:43 <trinisoftinc> i want to do some voice stuff...
10:26:52 <trinisoftinc> with festival
10:26:55 <twobitwork> and, yes... #scheme really is a better place to talk about scheme :)
10:27:10 <trinisoftinc> and festival = scheme :D
10:27:29 <Elly> on my system festival is a program that anything can pipe input to
10:27:36 <trinisoftinc> but nah, i have my own ideas...haskell
10:27:49 <trinisoftinc> i will do it with haskell instead
10:28:12 <Elly> I've never tried linking haskell to scheme
10:28:21 <trinisoftinc> Elly:I think so too until last week
10:28:32 <Elly> until last week?
10:29:16 <trinisoftinc> yap, when i have to build a custom voice that will speak zuluandus
10:29:29 <Elly> ah
10:29:36 <jeffwheeler> Does festival do speech recognition or output?
10:29:40 <Elly> output
10:29:44 <trinisoftinc> but hey.... lets talk haskell
10:29:47 <jeffwheeler> Oh; that's much lamer. :(
10:29:50 <trinisoftinc> where do I start
10:29:59 <Elly> if you have it installed, try 'echo foo | festival'
10:30:00 <Deewiant> > 1+1
10:30:03 <lambdabot>  2
10:30:08 <trinisoftinc> festival tts
10:30:12 <Elly> trinisoftinc: there are many excellent Haskell tutorials around
10:30:18 <Elly> oh, yeah, `festival tts`
10:30:32 <trinisoftinc> festival is basocally a text to speech engine
10:30:47 <sms__> how can i find out the maximum memory usage of a program with profiling?
10:31:10 <trinisoftinc> and d inner core is scheme....i wonder why dy didnt use c/c++
10:31:29 <trinisoftinc> sms_:netbeans profiling
10:31:41 <jeffwheeler> trinisoftinc: what are you trying to say when you say "d" and "dy"?
10:31:49 <Baughn> sms__: +RTS -sstderr, look for maximum residency
10:32:04 <Deewiant> I don't think you even need profiling for that
10:32:10 <jeffwheeler> trinisoftinc: "the"/"they"?
10:32:12 <DuClare> http://haskell.pastebin.com/m7b668aba  Two implementations of the same thing.  Which one is cleaner?  Is there a yet better way?
10:32:16 <Deewiant> yeah, what Baughn said
10:32:44 <trinisoftinc> sorry i am used to dese shortcuts
10:32:49 <trinisoftinc> dy == they
10:32:49 <sms__> Baughn, Deewiant: Thank you, that is perfect
10:33:04 <twobitwork> trinisoftinc: why not just spell it out?
10:33:05 <trinisoftinc> d == the
10:33:13 <trinisoftinc> :D
10:33:25 <twobitwork> it makes you look illiterate
10:33:44 <trinisoftinc> twobitwork:i will try
10:33:46 <jeffwheeler> trinisoftinc: please, at least in this channel, write the full words; it makes it much easier to read
10:34:17 <trinisoftinc> jeffwheeler:ok
10:34:47 <trinisoftinc> so where are we? i need to learn haskell and i need to learn it like yesterday
10:35:17 <mmorrow> omg
10:35:17 <Elly> trinisoftinc: do you have any prior experience with functional programming?
10:35:19 <mmorrow> ghc --help | festival --tts
10:35:29 <Elly> mmorrow: oops...
10:35:29 <mmorrow> hillarious
10:35:38 <jeffwheeler> There was a pretty good introductory book somebody linked in here a few days ago; I don't remember what it was called, but I bet somebody else knows.
10:35:45 <Elly> for a while my IRC client piped stuff people said through festival :)
10:35:48 <Deewiant> realworldhaskell.org
10:35:50 <jeffwheeler> It was free and online, with about 20 chapters, with comments allowed on each.
10:35:56 <mmorrow> i can't believe i didn't know about festival
10:36:01 <Cale> http://book.realworldhaskell.org/beta/
10:36:05 <lambdabot> Title: Real World Haskell
10:36:16 <jeffwheeler> Cale: Deewiant: exactly; thanks
10:36:36 <trinisoftinc> Cale:Thank you(I was tempted to type tx u)
10:36:40 <mmorrow> festival will be perfect for road-trip single-driver reading
10:36:51 <lispy> I don't seem to have festival installed
10:36:59 <trinisoftinc> mmrrow:u are correct
10:37:16 <Cale> mmorrow: just the thing to take your mind off the tedium of driving safely
10:37:21 <Elly> festival's "BUGS" section in its manpage: "More than you can imagine."
10:37:21 <lispy> oh cool, festival i text to speeche?
10:37:30 <mmorrow> Cale: exactly!
10:37:41 <trinisoftinc> mmrrow:I translate all my books to wav format using text2wav...converts to mp3 and reads on my iPod
10:37:45 <lispy> Elly: heh, reminds me of the BUGS section of bash
10:38:11 <Elly> mutt's BUGS section is good too :)
10:38:20 <trinisoftinc> Elly:which version of festival are you talking about
10:38:25 <mmorrow> trinisoftinc: ooh, good idea
10:38:33 * mmorrow takes festival todo notes
10:39:21 * mmorrow does sudo yum install *text2wav*
10:39:57 <thoughtpolice> heh, that's kind of the reason I love OS X's automator :)
10:40:10 <trinisoftinc> so guys I am out...gonna get to read that real world haskell...i will be back 2morro to giv u my feedbacks....thanks all
10:40:11 <FordCortina> !hpaste
10:40:33 <mmorrow> trinisoftinc: thanks for the text2wav tip
10:40:38 <Elly> trinisoftinc: I have 1.96 beta
10:41:11 <FordCortina> heh sry was to lazy to google it, nevermind
10:41:31 <jeffwheeler> FordCortina: @google works too
10:41:35 <mmorrow> um, text2wav wasn't found, but seems to me like a oneline shellscript involving festival
10:41:39 <FordCortina> :)
10:41:53 <jeffwheeler> (As in, the command for lambdabot, given arguments.)
10:42:08 <trinisoftinc> ok cool...u are utd
10:42:15 <trinisoftinc> oh sorry...up to date
10:42:15 <jeffwheeler> "utd"?
10:42:17 <jeffwheeler> oh
10:42:41 <trinisoftinc> mmrow:u are welcome
10:42:48 <Asgaroth> Is there already a function to split lists by a given delimiter?
10:42:59 <EvilTerran> no
10:43:09 <FordCortina> more type value stuff... im trying to write NatPlus http://hpaste.org/9204
10:43:17 <trinisoftinc> i love abbreviations, it will take a while to change me
10:43:18 <FordCortina> im not sure what to use for the type
10:43:27 <EvilTerran> > break (=='|') "well, this does | but only | splits once"
10:43:28 <lambdabot>  ("well, this does ","| but only | splits once")
10:43:46 <FordCortina> the return type for natPlus (Suc n1) n2
10:43:46 <vixey> FordCortina: why doing this ?
10:43:48 <EvilTerran> you can use break (or span) recursively to get the result you want
10:43:58 <FordCortina> vixey: im a masochist
10:44:10 <FordCortina> vixey: this for a project im doing
10:44:11 <EvilTerran> FordCortina, alternatively, the most common use cases are covered by "words" and "lines"
10:44:19 <lilachaze> @src words
10:44:19 <vixey> FordCortina: what is the project?
10:44:19 <lambdabot> words s = case dropWhile isSpace s of
10:44:19 <lambdabot>     "" -> []
10:44:19 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
10:44:22 <FordCortina> it involves type-level values
10:44:23 <EvilTerran> FordCortina, you could look at their types and source code for inspiration
10:44:36 <vixey> FordCortina: (I'm curious, not trying to stop you :p)
10:45:00 <vixey> you can't have values at type level.. only types..
10:45:11 <byorgey> didn't someone just upload a whole package to hacking implementing a bunch of type-level value stuff?
10:45:38 <FordCortina> vixey: Im trying to write a parser combinator library that sort-of isolates but does not exclude left-recursive parsers
10:45:39 <thoughtpolice> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/type-level
10:45:40 <lambdabot> Title: HackageDB: type-level-0.2, http://tinyurl.com/6edvhp
10:45:56 <byorgey> yeah, that's it.  FordCortina, no need to reinvent the wheel =)
10:45:59 <vixey> FordCortina: oh I see
10:46:15 <lilachaze> FordCortina: instance (NatPlus n1 n2 nr) => NatPlus (Suc n1) n2 (Suc nr)
10:46:25 <vixey> FordCortina: And you want to have GHC do the checks instead of your own code?
10:46:47 <FordCortina> vixey: yes sort of, my types will drive the checks
10:47:09 <FordCortina> vixey: in fact it will drive the checks on parsers written with the library im proposing
10:47:58 <sms__> Baughn, Deewiant: the maximum residency is only about 1/3 of what i see with ps aux
10:48:07 <esap> Is it possible that the unique arrow [f,f] : X + X -> Y defined by the universal property of the coproduct is a monomorphism?
10:48:23 <vixey> FordCortina: There is work on this sort of stuff in Agda (you've probably seen it), why are you using haskell?
10:48:24 <Deewiant> sms__: ps aux includes shared libraries and stuff like that
10:48:38 <Deewiant> might not account for all of the difference but at least some of it
10:48:46 <sms__> blind me, there is also one "total memory in use" value
10:49:01 <sms__> that is pretty close to ps aux
10:49:18 <sms__> maybe i should get glasses
10:49:32 <FordCortina> vixey: yeh ive seen Danielsson's and Norell's work on excluding Left-Recursion... I had a feeling it could be hacked in haskell
10:49:55 <vixey> cool
10:51:41 <FordCortina> lilachaze: i dont think that works for me? at least its not decidable... and thats what i need
10:52:10 <vixey> You can still have decideable instances just that GHC doesn't know that they are decideable
10:52:46 <FordCortina> vixey: i had a feel that their undecidable instances were somewhat... decidable
10:52:48 <FordCortina> :D
10:53:02 <vixey> they may or may not be
10:54:06 <FordCortina> vixey: well... corrected me if im wrong, but the coverage condition does _not_ cover all decidable instance, right?
10:54:08 <FordCortina> s/instance/instances/
10:54:40 <lilachaze> FordCortina: does ghc report that as undecidable?
10:54:59 <FordCortina> lilachaze: yeh
10:55:28 * FordCortina looks hard to see if he didnt make a typo
10:55:28 <lilachaze> that's a pity
10:57:45 <mmorrow> has anyone successfully set up a blackberry (or whatever) as a modem over bluetooth for a laptop running linux?
10:58:07 <dolio> instance (NatPlus n1 n2 nr) => NatPlus (Suc n1) n2 (Suc nr)
10:58:34 <dolio> If that's undecidable, use type families.
10:58:52 <lilachaze> dolio: that was my suggestion, and apparently ghc says it's undecidable
10:58:55 <dolio> Their termination conditions are more useful.
10:59:19 <lilachaze> it looks pretty simple to prove that it's decidable. i guess either i'm wrong or ghc doesn't try very hard :)
11:00:26 <dolio> I don't know what the exact rules are for fundeps, but they aren't very nice in that respect.
11:01:03 <mmorrow> (in case anyone also is wanting todo this) i just found http://www.gentoo-wiki.com/HOWTO_mobile_phone%2C_Bluetooth_and_GNOME
11:01:04 <lambdabot> Title: HOWTO mobile phone, Bluetooth and GNOME - Gentoo Linux Wiki, http://tinyurl.com/633oas
11:01:06 <mmorrow> looks promising
11:01:15 <mmorrow> </offtopic>
11:01:16 <dolio> I think the fact that n2 appears raw in both the constraint and the instance is what does it.
11:01:31 <FordCortina> dolio: i suppose if i could prove my instances are decidable that would be enough for my purposes
11:01:51 <jpcooper> hello
11:02:22 * EvilTerran wants a -XAcyclicInstances
11:03:01 <EvilTerran> so things like "instance Monad m => Functor m where fmap = liftM" would work, provided there was no chain of instances going the other way
11:03:05 <EvilTerran> (and ignoring the overlap)
11:03:36 <jpcooper> say I have a type-class Drawable which dictates that any type which is drawable must have a method drawable defined on it such that it takes a ray, and maybe returns an intersection coordinate. That's a function, but is it good practice to also put a function colour in the which takes an object and returns its colour?
11:03:47 <mmorrow> this is the link i meant:
11:03:48 <mmorrow> http://www.gentoo-wiki.com/HOWTO_Access_the_internet_with_your_cellphone_and_bluetooth_%28UMTS/GPRS%29
11:03:49 <lambdabot> Title: HOWTO Access the internet with your cellphone and bluetooth (UMTS/GPRS) - Gentoo ..., http://tinyurl.com/6y4wvx
11:03:58 <EvilTerran> altho that would require whole-program analysis, rather than the per-instance-decleration analysis -XFlexibleInstances uses
11:04:16 <lilachaze> EvilTerran: i think it might be worse than that.
11:04:42 <EvilTerran> -XRecursiveInstances would be nice, too, for when you're doing structural recursion on the types involved :P
11:05:09 <EvilTerran> lilachaze, in what way?
11:05:54 <lilachaze> suppose you have "instance B x => A x" and "instance C x => A x", and "instance B X" and "instance C X", and then you have "f :: B x => x -> ()" and "g :: C x => x -> ()"
11:06:06 <jpcooper> anyone? Took me quite a while to write that :)
11:06:11 <lilachaze> suppose f and g are applied to the same value, they can use different A X instances
11:06:49 <EvilTerran> lilachaze, those instances overlap
11:07:12 <lilachaze> you said "ignoring the overlap"
11:07:16 <EvilTerran> the same would apply for "instance B x => A (Foo x)" and "instance C x => A (Foo x)"
11:07:30 <EvilTerran> i meant ignoring the overlap with the existing instances of Functor for things that're instances of Monad
11:07:33 <lilachaze> and i took that as meaning the -XAcyclicInstances would disable the overlap warning
11:07:39 <gwern> anyone have spare time? I've uploaded mueval 0.5
11:07:42 <gwern> to use pls!
11:07:45 <EvilTerran> well, that was'nt wat i meant
11:07:51 <EvilTerran> er, typing fail
11:07:52 <mmorrow> jbcooper: maybe have another class HasColor a where colorOf :: a -> Color
11:08:26 <EvilTerran> lilachaze, i meant "ignoring the overlap for the sake of this example"
11:08:29 <jpcooper> right
11:08:35 <mmorrow> s/HasColor/Coloured/ sounds better and is properly localised :)
11:08:37 <hml> @src ++
11:08:37 <lambdabot> []     ++ ys = ys
11:08:37 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
11:08:37 <lambdabot> -- OR
11:08:37 <lambdabot> xs ++ ys = foldr (:) ys xs
11:08:37 <lambdabot> -- In lambdabot, this is generalised to:
11:08:39 <lambdabot> (++) = mappend
11:08:47 <EvilTerran> if you wanted overlaps, you'd still need -XOverlappingInstances
11:09:26 <lilachaze> EvilTerran: then I think i'm missing what -XAcyclicInstances would actually do :)
11:09:52 <jpcooper> mmorrow, is it normal to do such a thing?
11:10:00 <EvilTerran> lilachaze, "instance B x => A x" counts as undecidable under h98
11:10:08 <mmorrow> jbcooper: which thing?
11:10:33 <mmorrow> jbcooper: splitting the functionality among two diff classes as oppossed to one big one?
11:10:43 <EvilTerran> however, if the graph of instances is acyclic, it's *not* undecidable
11:11:00 <jpcooper> I mean creating classes whose only methods are functions which return a property of an object
11:11:03 <EvilTerran> so -XUndecidableInstances is a bit of a sledgehammer
11:11:15 <jpcooper> it seems like OOP to me. I'm wondering if I need to start thinking in a different way
11:11:30 <vixey> don't define any typeclasses
11:11:31 <EvilTerran> reducing the safety of your code, when a more sophisticated instance decidability checker would also work
11:11:33 <mmorrow> jbcooper: class Typeable a where typeOf :: a -> TypeRep
11:11:40 <mmorrow> Data.Typeable, etc
11:11:41 <vixey> instead define,
11:11:50 <vixey> data Object = Ray ... | Sphere .. | ...
11:11:54 <vixey> and the functions operating on those
11:12:11 <Japsu> ooh, someone building a raytracer? :o
11:12:11 <EvilTerran> lilachaze, do you follow now?
11:12:40 <lilachaze> EvilTerran: yes, got it :) thanks.
11:12:53 <EvilTerran> lilachaze, that's why i said i also wanted -XRecursiveInstances for doing safe recursion on the structure of the type expressions in the instance head
11:14:01 <EvilTerran> which'd allow a superset of the instances allowed by -XAcyclicInstances, which'd allow more instances than -XFlexibleInstances, whicd allows more than h98
11:14:12 <jpcooper> vixey, right
11:14:43 <mmorrow> jbcooper: but the Typeable is somewhat different than your case, since Color i take it is an actual field in your data. i find that this "method" occasionally convenient/useful in this case also
11:14:51 <EvilTerran> -XUndecidableInstances would not allow a superset of -XRecursiveInstances, though, unless you allowed an unbounded stack in the recursion
11:15:38 <EvilTerran> s/recursion/instance checker/
11:15:51 <hml> @hoogle sort
11:15:51 <lambdabot> Data.List.sort :: Ord a => [a] -> [a]
11:15:51 <lambdabot> Data.ByteString.sort :: ByteString -> ByteString
11:15:51 <lambdabot> Data.ByteString.Char8.sort :: ByteString -> ByteString
11:15:52 <mmorrow> jbcooper: yeah, vixey has a good point. i really only use class Has_ ... when i have to pull out a common thing from a bunch of otherwise unrelated datatypes
11:15:54 <hml> @hoogle unique
11:15:55 <lambdabot> Data.Unique :: module
11:15:55 <lambdabot> Data.Unique.Unique :: data Unique
11:15:55 <lambdabot> Data.Unique.newUnique :: IO Unique
11:16:00 <hml> @src unique
11:16:00 <lambdabot> Source not found. Sorry.
11:16:05 <hml> @src sort
11:16:05 <lambdabot> sort = sortBy compare
11:16:15 <jpcooper> mmorrow, I don't quite understand what I should be doing with Typeable. Are there any guides?
11:16:17 <hml> does haskell have built in to take a list and remove all duplciates?
11:16:39 <sjanssen> hml: Data.List.nub
11:16:53 <mmorrow> jbcooper: oh, i just gave Typeable as an example of a class which does something somewhat similar in principle to what we're talking about
11:17:17 <vixey> what
11:17:21 <vixey> you don't want to use typeable
11:17:29 <jpcooper> okay
11:17:32 <hml> @src nub
11:17:32 <lambdabot> nub = nubBy (==)
11:17:57 <hml> :t nub
11:18:00 <lambdabot> forall a. (Eq a) => [a] -> [a]
11:18:06 <mmorrow> yeah, i wasn't suggesting *using* Typeable, but as an alalogy where (TypeRep -> Color , a -> Colored)
11:18:14 <mmorrow> s/alalogy/analogy/
11:18:25 <hml> sjanssen: hmm, i didn't givbe enough  info; i can do a bit better;sinxe i'm doing this on an order; i can sort it, and remove dups in linear time after sorting
11:18:38 <vixey> hml: sort it then
11:18:40 <jpcooper> aah, okay
11:18:42 <vixey> map head . group . sort it
11:18:50 <hackage> Uploaded to hackage: mueval 0.5
11:18:50 <hackage> Uploaded to hackage: show 0.2
11:21:07 <EvilTerran> vixey, well, map head . group . sort $ it
11:21:08 <EvilTerran> :P
11:21:31 <jpcooper> EvilTerran, why?
11:21:43 <jpcooper> oh yeah
11:21:47 <hml> why do I get a conflicting definition for 'x' on this line:       remove_hlpr front (x:x:y) = remove_hlpr front (x:y)
11:21:59 <hml> i'm trying to patterhn match 9on the second list having the first two elements be equal
11:22:09 <jpcooper> hml, is your keyboard broken?
11:22:13 <vixey> hml: Haskell doesn't allow that sort of thing
11:22:19 <hml> jpcooper: getting used to kinesis ergo
11:22:20 <EvilTerran> hml, you can't use the  same name twice in a pattern
11:22:21 <vixey> hml: you must write (x:x':y) | x == x'
11:22:36 <jpcooper> aah, nice
11:23:02 <EvilTerran> remove_hlpr front (x:xs@(x':_)) | x == x' = remove_hlpr front xs -- if you're a premature-optimisation weenie, write this :P
11:23:16 <hml> jpcooper: been almost a month now; still not quiet used to it
11:23:53 <EvilTerran> name@(pattern) in place of just (pattern) means the same thing as just (pattern), but also binds "name" to the whole value matched
11:24:07 <|Steve|> EvilTerran: Is that ever more efficient?
11:24:10 <hml> and it does pattern laxily
11:24:14 <hml> *lazily*
11:24:22 <EvilTerran> hml, what, name@pattern? don't think so...
11:24:37 <vixey> I thought it was pattern@pattern
11:24:40 <EvilTerran> > case undefined of foo@() -> "this doesn't work, iirc"
11:24:43 <Toxaris> |Steve|: you avoid recreating (x:xs) on the right side this way
11:24:44 <lambdabot>  "Exception: Prelude.undefined
11:24:54 <EvilTerran> > case undefined of foo@(~()) -> "but this should"
11:24:55 <lambdabot>  "but this should"
11:24:57 <hml> the compiler can't optimize that out?
11:25:01 <vixey> > let ((x:xs)@(y:ys)) = [1,2,3] in (x,y,xs,ys)
11:25:01 <lambdabot>  Parse error at "@(y:y..." (column 12)
11:25:04 <|Steve|> Toxaris: Sure, but won't CSE handle that?
11:25:08 <jpcooper> hml, did you not touch-type before?
11:25:09 <mmorrow> > let hist = foldl' (\m x -> M.insertWith (+) x 1 m) mempty in hist (take 100000 . randomRs ('a','e') . mkStdGen $ 0)
11:25:10 <vixey> amm
11:25:10 <lambdabot>  fromList [('a',19842),('b',20021),('c',19999),('d',20169),('e',19969)]
11:25:12 <vixey> aww
11:25:22 <Toxaris> |Steve|: no clue
11:25:35 <EvilTerran> hml, |Steve| - common subexpression elimination doesn't happen as standard, because it can cause massive structures to hang in memory unexpectedly
11:25:56 <dolio> @ doesn't make the pattern irrefutible.
11:26:00 <hml> EvilTerran: can you give a concrete example?
11:26:11 <hml> (I  don't doubt you; it'd just see it more clearly with a  concrete example)
11:26:33 <Toxaris> hml: sum [1..100000] + [1..100000]
11:26:52 --- mode: ChanServ set -o Heffalump
11:26:54 <hml> > sum [1..100000] + [1..100000]
11:26:55 <lambdabot>   add an instance declaration for (Enum [t], Num [t])
11:27:04 <EvilTerran> er
11:27:09 <Toxaris> > sum [1..100000] : [1..100000]
11:27:10 <lambdabot>  [5000050000,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,2...
11:27:14 <Toxaris> sorry, meant this one
11:27:26 <Toxaris> > let x = [1..100000] in sum x : x
11:27:27 <lambdabot>  [5000050000,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,2...
11:27:30 <dolio> > let p [] = [[]] ; p (x:xs) = let pxs = p xs in map (x:) pxs ++ pxs in p [1..10000]
11:27:31 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
11:27:34 <hml> @src :
11:27:34 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
11:27:40 <Toxaris> ok no difference :)
11:27:42 <vixey> @src []
11:27:42 <lambdabot> data [] a = [] | a : [a]
11:27:59 <rwbarton> > (sum [1..1000000]) `div` (length [1..1000000])
11:28:01 <lambdabot>  1784
11:28:09 <hml> > let x = [1..100000] in x : x
11:28:10 <lambdabot>   add an instance declaration for (Enum [t], Num [t])
11:28:15 <rwbarton> > let x = [1..1000000] in (sum x) `div` (length x)
11:28:17 <lambdabot>  1784
11:28:20 <rwbarton> oh well
11:28:46 <mmorrow> heh
11:28:50 <hml> is there a more idiomatic way to write; concat [ [(x, y), (y, x)]  | (x, y) <- lst] ?
11:28:59 <Toxaris> hml: my idea was that in (let x = [1..100000] in sum x : x), x is forced by sum, so a fully evaluated list of 100k elements is returned, while in (sum [1..100000] : [1..100000]), both occurences of [1..100000] are traversed on the fly, and a simple thunk is returned
11:29:02 <EvilTerran> hml, the point is, in "let xs = [...] in (sum xs, length xs)", say, the whole of xs sticks around in memory
11:29:11 <vixey> hml:  list `interleave` map swap list
11:29:53 <EvilTerran> hml, while, in "(sum [...], length [...])", the initial portion of [...] can be GCd during the traversal for "sum", and then generated again for the traversal for "length"
11:30:20 <EvilTerran> what'd be really helpful here would be support for weak pointers in the GC
11:30:30 <Toxaris> > [fst &&& snd, snd &&& fst] <*> [('A', 'a'), ('B', 'b')]
11:30:31 <lambdabot>  [('A','a'),('B','b'),('a','A'),('b','B')]
11:30:41 <Toxaris> > [fst &&& snd, snd &&& fst] <**> [('A', 'a'), ('B', 'b')]
11:30:42 <lambdabot>  Couldn't match expected type `((b1, b1) -> (b1, b1)) -> b'
11:30:45 <hml> why is it that in: "let xs = [...] in (sum xs, length xs)" , the whole of xs sticks around in memory: why can't ghci optimize that out?
11:30:50 <Dynetrekk> why can't haskell convert Int -> Integer? (Couldn't match expected type `Int' against inferred type `Integer')
11:30:51 <hml> vixey: thanks
11:30:54 <Toxaris> > [('A', 'a'), ('B', 'b')] <**> [fst &&& snd, snd &&& fst]
11:30:55 <lambdabot>  [('A','a'),('a','A'),('B','b'),('b','B')]
11:31:31 <dolio> Haskell doesn't automatically convert numeric types.
11:31:31 <gwern> Dynetrekk: because maybe you actually want the overflow behaivour?
11:31:33 <dolio> That's evil.
11:31:37 <gwern> Dynetrekk: you can do a coercion, tho
11:31:39 <EvilTerran> so the compiler could do CSE, making the new links in the dataflow graph with weak pointers, then structures that got held in memory unexpectedly could be GCd
11:31:43 <Toxaris> hml: sometimes it's good to keep already evaluated stuff in memory, sometimes its bad. how should ghc know?
11:31:47 <EvilTerran> hml, how would it do that?
11:31:57 <Dynetrekk> gwern: evile. well, I just want length xs to give me an Integer...
11:32:06 <Toxaris> Dynetrekk: use genericLength
11:32:06 <EvilTerran> > genericLength xs :: Integer
11:32:07 <lambdabot>   Not in scope: `xs'
11:32:09 <EvilTerran> er
11:32:11 <EvilTerran> flail
11:32:15 <hml> EvilTerran: it looooks at the let; it infers where xs goes out of scope; then after that, why does it need to keep it in memory?
11:32:35 <EvilTerran> hml, oh, no, it won't keep it in memory after it's gone out of scope
11:32:38 <gwern> :t fromIntegral
11:32:39 <lambdabot> forall a b. (Num b, Integral a) => a -> b
11:32:42 <Toxaris> hml: in a lazy language, things are used outside of their scope?
11:32:54 <Dynetrekk> Toxaris: not in scope: genericLength
11:33:05 <Toxaris> @hoogle genericLength
11:33:05 <lambdabot> Data.List.genericLength :: Num i => [b] -> i
11:33:11 <Toxaris> Dynetrekk: import Data.List
11:33:20 <Dynetrekk> Toxaris: ah. of course. Thanks!
11:33:25 <EvilTerran> hml, if you said "let xs = [1..2^20] in print (sum xs, length xs)" at the ghci prompt, say
11:33:42 <mmorrow> > let mean = fst . foldl' (\(m,n) x -> (m+(x-m)/(n+1),n+1)) (0,0) in mean (take 100000 (randomRs (0,9) (mkStdGen 0)))
11:33:44 <lambdabot>  4.491391880492075
11:33:46 <hml> > let xs = [1..2^20] in print (sum xs, length xs)
11:33:47 <EvilTerran> hml, then the evaluation needs to convert (sum xs, length xs) to a string
11:33:47 <lambdabot>  <IO ()>
11:33:50 <rwbarton> hml: it's going to compute one of sum xs and length xs first, let's say sum xs.  Then length xs still has a reference to xs, so the whole thing has to stay in memory
11:33:56 <EvilTerran> ?src (,) show
11:33:56 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
11:33:58 <EvilTerran> hm
11:34:12 <EvilTerran> show (x, y) = "(" ++ show x ++ ", " ++ show y ++ ")", basically
11:34:15 <EvilTerran> so it shows a (
11:34:22 <EvilTerran> then calculates (sum xs) so it can show it
11:34:26 <EvilTerran> in doing so, xs is traversed
11:34:27 <hml> rwbarton: okay; I  can accept that; thanks
11:34:53 <hml> this is very counterintuitive, that naming things wastes memory
11:34:54 <EvilTerran> but because the variable "xs" is pointing to the head of the list, all of the list cells are still in scope, so don't get GCd
11:35:11 <EvilTerran> this would get optimised away if you only used xs once
11:35:30 <hml> (\x (sum x, length x)) [1...100000000000000]
11:35:36 <EvilTerran> you can also write a manual recursion that only traverses the list once to get the same end result
11:35:37 <hml> does the list have to stay in memory too?
11:35:52 <EvilTerran> hml, yes, in (\x -> (sum x, length x)) [1...100000000000000], it would stay in memory
11:35:58 <EvilTerran> you've still given it a name you've used more than once
11:36:07 <EvilTerran> which is pretty much exactly what CSE is the compiler doing
11:36:49 <EvilTerran> hml, it's often possible to devise some more explicit function that does all the traversals in one go, mind
11:37:03 <Toxaris> how to write (\x -> (sum x, length x)) so that the evaluation of one of the components forces the evaluation of the other? something with an inner let and seq?
11:37:21 <mmorrow> > foldl' (\(!acc,!cnt) a -> (acc+a,cnt+1)) (0,0) [0..999]
11:37:22 <lambdabot>  Parse error at ",!cnt..." (column 15)
11:37:24 <rwbarton> hml: By that logic, it's counterintuitive that sum [1..n] runs in O(1) space :)
11:37:31 <EvilTerran> in this case, it'd be something like foldl' (\(s,l) x -> (s+x,l+1)) (0,0)
11:37:51 <EvilTerran> er, yes, you'd need to force the parameters of the pair manually if you wanted that to work
11:37:58 <mmorrow> > foldl' (\(acc,cnt) a -> let acc' = acc+a ; cnt' = cnt+1 in acc' `seq` cnt' `seq` (acc',cnt')) (0,0) [0..999]
11:38:00 <lambdabot>  (499500,1000)
11:38:08 <EvilTerran> ?type foldl' (\(s,l) x -> s `seq` l `seq` (s+x,l+1)) (0,0)
11:38:08 <lambdabot> forall t b. (Num t, Num b) => [b] -> (b, t)
11:38:19 <EvilTerran> would work
11:38:45 <EvilTerran> and we are now in the muddy, muddy ground of strictness annotations, so i'm gonna bow out :P
11:39:00 <hml> rwbarton: how does the O(1) sapce follow?
11:39:40 <EvilTerran> hml, [1..n] is a "good producer (of a list)", and sum is a "good consumer"
11:39:52 <EvilTerran> with the result that the list never actually gets allocated when you compile with optimisations, iirc
11:39:56 <mmorrow> it's pretty straightforward imo, foldl' ensure that the pair (acc,cnt) is eval'ed at each step, but it can't get at the acc and cnt to eval them, so you have to do it yourself
11:39:57 <EvilTerran> it's optimised away to a loop
11:40:09 <EvilTerran> don't ask me to define what makes a list producer or consumer "good", mind :P
11:40:30 <dolio> It doesn't really have anything to do with fusion.
11:40:32 <rwbarton> hml: But even without good producer/consumer optimizations, the cons cells are consumed by sum as they are produced by [1..n]
11:40:50 <dolio> It's just that [1..n] produces elements incrementally, and sum consumes them incrementally.
11:41:00 <EvilTerran> dolio, oh, does it GC every element as it no longer needs them?
11:41:08 <EvilTerran> i thought they would sit around 'til the next GC pass
11:41:14 <hml> rwbarton: I don't understand why my "naming is counterintuitive" results in "sum ... O(1) space counter intuitie"
11:41:35 <dolio> Well, it waits around, of course. GCing every time would be too much overhead.
11:41:41 <EvilTerran> quite
11:41:47 <dolio> But GC 'wastes' memory in general.
11:41:51 <bd_> EvilTerran: they do sit around until the next GC pass. Note that sum is not atomic wrt GC :)
11:41:55 <rwbarton> hml: Oh, I just meant that trying to think about how much "space" a value takes doesn't really make sense.
11:42:02 <dolio> It's O(1) memory in use.
11:42:09 <hml> also, in (sum x, length x); there's no reason ghci has to keep it in memory right? since it could in theory interleave the clculations and have both sum/length consume as the list is produced
11:42:15 <mmorrow> sum actually is defined as foldl (+) 0, whereas it really *should* be foldl' (+) 0
11:42:28 <mmorrow> so sum as presently defined is not O(1) space :(
11:42:29 <bd_> hml: it could but it doesn't, because that's a very difficult transformation to actually make
11:42:39 <glguy> mmorrow: where *should* applies to Int?
11:42:40 <EvilTerran> mmorrow, i wouldn't change it, TBH
11:42:50 <mmorrow> glguy: yes, very true
11:42:50 <EvilTerran> i'd call the strict one sum'
11:42:52 <glguy> mmorrow: since it is defined over all Num instances
11:43:03 <hml> bd_: what's the intuition behind this? if all functions are labeled whether they're 'good consyumers' ...
11:43:22 <EvilTerran> can one write {-# RULES ... #-} to replace sum with a foldl' for appropriate types?
11:43:44 <bd_> hml: well, how would you write the appropriate transformation rules? I mean, you'd have to somehow lift (,) into them
11:43:44 <EvilTerran> hml, the word dolio used, "incremental", is probably better than "good"
11:44:09 <mmorrow> glguy: hmm, that makes me think... maybe a class Num' (whatever one chooses to call it) that provides sum and product would be useful in the same way that Monoid having mconcat is useful
11:44:35 <mmorrow> (of course newtypes and Monoid instances can bum that functionality off of Monoid)
11:44:48 <sjanssen> EvilTerran: yes, GHC actually does that
11:44:51 <glguy> mmorrow: why a new class rather than just defining sum' in terms of Num?
11:45:19 <mmorrow> glguy: yeah, i think i write sum' at least 20 times daily :)
11:45:35 * glguy doesn't like the idea of custom RULES hiding deep inside libraries
11:45:51 <glguy> I like to know how things are going to behave without having to scour the code for all of the special cases
11:46:01 <glguy> its a shame we have to fall back on them
11:46:09 <sjanssen> glguy: yes, same here
11:46:15 <sjanssen> IMO, sum should just be strict
11:46:35 <mmorrow> (me too)
11:46:36 <sjanssen> it is defined via foldl, so a lazy Num instance won't get much use out of sum anyway
11:46:49 <glguy> its not called "sumOftenStrict"
11:46:54 <bd_> glguy: RULES theoretically shouldn't change the semantics of code
11:47:36 <sjanssen> glguy: strictness properties are very rarely included in the function name
11:47:55 <sjanssen> eg. we don't write "mapLazyInTheFirstArgumentStrictInTheSecond"
11:47:56 <glguy> sjanssen: more magic
11:48:35 <glguy> often the strictness is the difference between the program exiting from stack overflow or not
11:48:36 <sjanssen> glguy: I challenge you to come up with one useful example of lazy sum
11:48:38 <sjanssen> (using foldl)
11:48:48 <glguy> sjanssen: I'm not arguing against strict sum
11:48:56 <glguy> sjanssen: I'm arguing against sometimesStrictSum
11:49:04 <sjanssen> glguy: oh yes.  That sucks
11:49:26 <sjanssen> though GHC's strictness analyzer means that any function is potentially strict or not
11:49:57 <solrize> it would be useful to have a profiler option that tracked how many unevaluated thunks were pending at any moment, or even signalled an exception if any evaluation caused more than N deferred evaluations for some parameter N
11:50:03 <glguy> There are too many situations where you can't cross your fingers and hope that the analyzer worked that time
11:50:45 <dolio> We already have that. Stack overflow. :)
11:51:02 <solrize> heh
11:51:37 <glguy> the strictness analyzer is only useful in cases where the code would have worked without it anyway
11:51:42 <glguy> but got faster with it
11:53:49 <ClimDan> Cool Euro Jobs site => new-gen employment eu
11:54:14 --- mode: ChanServ set +o glguy
11:54:14 --- mode: ChanServ set -o glguy
11:55:04 <lelf> f
11:57:07 <hml> i'm looking at: http://www.haskell.org/ghc/docs/latest/html/libraries/array/Data-Array-ST.html and see no obvious way 5to convert a STArray to an Array without going through an intermediate list; is there no faster way?
11:57:08 <lambdabot> Title: Data.Array.ST, http://tinyurl.com/6xt7am
11:57:51 <bd_> hml: you could use runSTArray
11:58:08 <Heffalump> which is designed for precisely that
11:58:13 <bd_> or http://www.haskell.org/ghc/docs/latest/html/libraries/array/Data-Array-MArray.html#v%3Afreeze
11:58:14 <lambdabot> Title: Data.Array.MArray, http://tinyurl.com/2rsgh5
11:59:42 -ChanServ(ChanServ@services.)- glguy added climdan!*@* to the AKICK list.
12:00:21 <hml> grea; thanks
12:06:54 <sioraiocht> could someone give me an example of correctly calling newByteArray# ?
12:11:16 <mmorrow> sioraiocht: there a call to it in http://darcs.haskell.org/libraries/base/GHC/Pack.lhs
12:11:25 <sioraiocht> thanks@
12:12:05 <dolio> case newByteArray# i# s# of { (# s'#, mb #) -> ... }
12:14:29 <sioraiocht> and s# can be realWorld#, right?
12:14:29 <mmorrow> imo one *monstrous* advantage darcs repos have over git repos in a webaccessible dir is that you can browse the actual directory as if darcs wasn't even there
12:14:38 <sioraiocht> mmorrow: agreed
12:14:56 <dolio> It can be State# RealWorld, if that's what you mean.
12:15:15 <sioraiocht> dolio: isn't the only value of that type realWorld#, though?
12:15:29 <vixey> yeah that is really annoying about git
12:15:31 <gwern> well, darcs doesn't even have to be there. you could be keeping darcs locally and rsyncing or ftping the _darcs files to the server :)
12:15:46 <dolio> Oh. Well, I wasn't aware that there was a top-level value of it somewhere.
12:16:03 <dolio> Usually you'd get it by it being passed in.
12:16:12 <dolio> \s# -> ...
12:16:29 <dolio> As in IO (\s# -> ...) or ST (\s# -> ...)
12:16:58 <dolio> And, of course, the thing you get back from newByteArray# and such is also that type.
12:18:06 <dolio> That sort of thing is how you establish the proper data dependencies in IO and ST.
12:18:15 <sioraiocht> *is confused*
12:18:49 <mmorrow> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
12:18:53 <mmorrow> @src IO
12:18:54 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
12:19:01 <mmorrow> @src ST
12:19:02 <lambdabot> newtype ST s a = ST (STRep s a)
12:19:04 <sioraiocht> oh
12:19:05 <mmorrow> @src STRep
12:19:05 <lambdabot> type STRep s a = State# s -> (# State# s, a #)
12:19:29 <mmorrow> IO == ST RealWord
12:19:39 <mmorrow> +l
12:19:43 <mmorrow> RealWorld
12:19:44 <sioraiocht> thanks makes sense
12:20:20 <sioraiocht> is there anywhere i can find the source to Data.Array.Base?
12:20:50 <ayianus> sioraiocht, perhaps you didn't notice - you have a private message waiting.
12:20:52 <bd_> sioraiocht: in the ghc source distribution?
12:20:52 <mmorrow> sioraiocht: you should do   darcs get --partial http://darcs.haskell.org/ghc/
12:20:53 <lambdabot> Title: Index of /ghc
12:21:00 <sioraiocht> thaks!
12:21:21 <mmorrow> sioraiocht: then    sh darcs-all get
12:21:35 <mmorrow> in ghc/ to get all the lib sources
12:21:42 <dolio> Don't do that. Downloading a tarball from the GHC website will be much faster.
12:22:01 <mmorrow> true, but then you can't darcs pull on a daily basis ;)
12:22:07 <dolio> :)
12:22:47 <dolio> When did you last build 6.9? I'd been having trouble a week or two ago.
12:23:00 <sioraiocht> meh, whatevs, I have all day...am going to spa in 20 minutes anyway
12:23:37 <mmorrow> dolio: not since 6.9.20080504, but it's on my list for asap (today sounds good)
12:23:51 <mmorrow> dolio: what happened?
12:23:52 <dolio> Let me know if it works.
12:23:58 <mmorrow> will do
12:24:06 <dolio> Oh, I was getting linker errors during 'make install' I think.
12:24:18 <dolio> I'm not sure if it's just me, though.
12:24:56 <mmorrow> ok, i'm gonna try now...
12:25:39 <rwbarton> dolio: is it the same error as this? http://www.haskell.org/pipermail/haskell-cafe/2008-June/044735.html
12:25:39 <lambdabot> Title: [Haskell-cafe] ghc-HEAD: build succeeds, but install fails with linker errors?, http://tinyurl.com/6f44xd
12:26:02 <dolio> rwbarton: Looks like it.
12:26:12 <dolio> Lots of undefined symbols and such.
12:27:57 <dolio> Evidently Cale's position on the term "closure" is unpopular.
12:29:29 <vixey> what evidence?
12:30:04 <Cale> dolio: Evidently so is intelligence :P
12:30:21 <dolio> vixey: He's being modded down on reddit.
12:30:26 <mmorrow> rwbarton: maybe try getting a 6.9 snaphshot binary dist, then build 6.9 src with that (don't know if this will matter)
12:30:41 <mmorrow> http://www.haskell.org/ghc/dist/current/dist/ghc-6.9.20080614-i386-unknown-linux.tar.bz2
12:30:42 <lambdabot> http://tinyurl.com/5b53jv
12:30:51 <osfameron> where on reddit?
12:31:15 <dolio> The article about 'closures in Pascal' or whatever.
12:31:53 <Twey> Closures in Pascal?  What?
12:32:24 <vixey> how about recursion in pascal...
12:32:28 <vixey> before closures
12:32:57 <rwbarton> mmorrow: That's a good suggestion, however it was over a month ago that I was trying to build ghc :)
12:35:18 <dino-> I've got a function that I need to pass four strings to. I have the values in a list and am having a kind of silly time coming up with a nice way to hook these two things together.
12:35:38 <dino-> I'm reluctant to use (!!)
12:35:57 <Cale> pattern match them out?
12:36:03 <mmorrow> rwbarton: heh, that's right. my memory is failing me
12:36:12 <dino-> mm, like a wrapper
12:36:40 <rwbarton> f [foo, bar, baz, quux] = ...
12:36:45 <dino-> foo' (w:x:y:z:[]) = foo w x y z
12:36:50 <Twey> dino-: If they're always going to be four strings, you could better use a tuple...
12:37:05 <vixey> dino-' altenate notation
12:37:08 <dino-> mm
12:37:16 <vixey> foo' [w,x,y,z] = foo w x y z
12:37:27 <Twey> f (foo, bar, baz, quux) = ...
12:37:39 <dino-> You know I didn't know for sure if I could match with [,] on the left
12:37:52 <Twey> You can :-)
12:37:56 <mmorrow> rwbarton: have you been messing around with quasiquotes any recently?
12:38:18 <Twey> > let foo [w, x, y, z] = w + x + y + z in foo 1 2 3 4
12:38:20 <lambdabot>        add an instance declaration for
12:38:20 <lambdabot>       (Num [t -> t1 -> t2 -> a], Num (...
12:38:25 * Twey twitches.
12:38:27 <vixey> does 6.9 have QQ?
12:38:28 <dino-> Ok, Cale, rwbarton, Twey, vix, thank you very much.
12:38:42 <thoughtpolice> vixey: yeah, QQ is solid in HEAD
12:38:43 <dino-> I know, sort of a silly simple thing to ask.
12:38:47 <mmorrow> rwbarton: i have a haskell quasiquoter + other misc in a darcs repo at http://code.haskell.org/~morrow/code/haskell/metaquote/
12:38:48 <lambdabot> Title: Index of /~morrow/code/haskell/metaquote
12:38:56 <Twey> > let foo :: [Int] -> Int; foo [w, x, y, z] = w + x + y + z in foo 1 2 3 4
12:38:56 <thoughtpolice> there's also a patch to add QQ to ghc 6.8.3 somewhere
12:38:57 <lambdabot>  Couldn't match expected type `t1 -> t2 -> t3 -> t'
12:38:59 <vixey> and can you make your own deriving's?
12:39:07 <mmorrow> i intend to put it on hackage soon
12:39:07 <Twey> What's wrong with that, then?
12:39:14 <dino-> BTW, this is work for my real job. That I'm insideously infiltating with the big H.
12:39:33 <vixey> > let foo :: [Int] -> Int; foo [w, x, y, z] = w + x + y + z in foo [1, 2, 3, 4]
12:39:34 <lambdabot>  10
12:40:19 <vixey> or is deriving totally unrelated to QQ?
12:40:25 <mmorrow> thoughtpolice: yeah, audreyt made it. i added pattern splices to it and it's at http://code.haskell.org/~audreyt/qq-6.8.3.diff
12:40:28 <vixey> I thought it was a TH thing
12:40:30 <Twey> Oh.
12:40:36 <dino-> I've been left here as the last person who didn't quit on this team, during a hiring freeze, to inherit a lot of really bad stuff. So, whatever I want to do here to get these tasks done goes.
12:40:36 <Twey> vixey: I'm an idiot, huh.  :-)
12:40:58 <Zao> dino-: Awesome.
12:40:59 <vixey> I didn't say that ...
12:41:34 <mmorrow> vixey: not really related to QQ, but related in the sense that a haskell QQ and deriving code both have to manipulate haskell ASTs
12:42:00 <vixey> so can you actually give new deriving methods to haskell now?
12:42:22 <mmorrow> vixey: you could derive things by (currently) two routes => TH abstract syn or haskell-src-exts absyn
12:43:01 <mmorrow> haskell-src-exts has (for the most part) up-to-date haskell syntax rep, while TH doesn't
12:43:37 <mmorrow> so if you need to manipulate GADT/TH abstract syntax, haskell-src-exts is the only option
12:44:04 <mmorrow> (save using ghc's HsSyn or something)
12:44:23 <jpcooper> is it possible to make haskell-mode always :cd to the result of the pwd command in emacs?
12:45:20 <mmorrow> thoughtpolice: there's a tarball of ghc-6.8.3 with that patch already applied at http://code.haskell.org/~morrow/quasiquotes/ghc-6.8.3_QQ-0.2.tar.bz2
12:45:21 <lambdabot> http://tinyurl.com/5m2grk
12:45:38 <hexpuem> has Yampa bit rotted
12:47:07 <mmorrow> dino-: ha, nice. send out a "everything is being moved to haskell" memo asap!
12:47:18 <gwern> I haven't heard of it being used recently, so sounds likely
12:47:47 <gwern> mmorrow: 'Subject: Ensuring my job security'
12:48:14 <dmead> guys?
12:48:23 <dmead> where do i find math stuff in the standard lib?
12:48:39 <mmorrow> dmead: what kind of math stuff in particular?
12:48:46 <mmorrow> gwern: a surefire route
12:49:00 <dmead> mmorrow, log, e, ln etc
12:49:00 <dmead> sin cos
12:49:01 <dmead> etc
12:49:07 <jpcooper> anyone?
12:49:09 <dmead> like java's java.math
12:49:22 <dino-> :D  Seriously though, I'm trying to not freak people out.
12:49:29 <dmead> > :t log
12:49:30 <lambdabot>   parse error on input `:'
12:49:32 <Baughn> dino-: In the prelude, mostly
12:49:33 <mmorrow> most of that stuff is in the Prelude
12:49:36 <Baughn> *dmead
12:49:40 <dmead> > e^1
12:49:43 <lambdabot>  e
12:49:45 <dmead> > e
12:49:47 <lambdabot>  e
12:49:50 <dmead> hmm
12:49:52 <Baughn> Ah, no. No e.
12:49:55 <dmead> > e^2
12:49:56 <lambdabot>  e * e
12:49:59 <dmead> boo
12:50:03 <mmorrow> > exp 1
12:50:04 <lambdabot>  2.718281828459045
12:50:07 <dmead> ah
12:50:09 <dmead> there we go
12:50:12 <mmorrow> ;)
12:50:19 <dmead> > log(exp1)
12:50:20 <lambdabot>   Not in scope: `exp1'
12:50:24 <dmead> > log(exp 1)
12:50:27 <lambdabot>  1.0
12:50:35 <dmead> very good lambdabot
12:50:37 <dmead> you get a coockie
12:50:38 <gwern> well, there's the numeric prelude and a few other numeric packages for heavyduty math
12:50:41 <dmead> lambdabot++
12:50:47 <mmorrow> botsmack
12:50:52 <mmorrow> @botsmack
12:50:52 <lambdabot> :)
12:50:59 <dmead> regular old log and exp is all i need
12:50:59 <Baughn> ..botsmack?
12:51:08 <Deewiant> @botsnack
12:51:08 <lambdabot> :)
12:51:20 <olsner> @botslap
12:51:21 <lambdabot> Unknown command, try @list
12:51:25 <Baughn> @dotclack
12:51:25 <lambdabot> Unknown command, try @list
12:51:37 <Baughn> @scotsnack
12:51:37 <lambdabot> :)
12:51:54 <olsner> @snotsnack
12:51:54 <lambdabot> :)
12:51:58 <olsner> @snotsmack
12:51:58 <lambdabot> Unknown command, try @list
12:52:06 <Elly> lambdabot is not picky about snacks apparently
12:52:07 <mmorrow> Baughn: lambdabot loves her smack
12:52:17 <Elly> lambdabot is gendered?
12:52:23 <mmorrow> @scoobysnack
12:52:24 <lambdabot> Unknown command, try @list
12:52:35 <olsner> Elly: of course she is!
12:52:36 <Elly> @wotsnack
12:52:36 <lambdabot> :)
12:52:44 <mmorrow> Elly: female
12:52:46 <Elly> @reallylongotsnack
12:52:47 <lambdabot> Unknown command, try @list
12:52:51 <Elly> mmorrow: ahh
12:52:59 <Elly> it all makes sense now
12:53:03 <olsner> @lambdabotsnack
12:53:04 <lambdabot> Unknown command, try @list
12:53:26 <Baughn> Yes, PMS is a real issue. Poor memory size, that is
12:54:02 <Botje> @remember Baughn (about \bot) Yes, PMS is a real issue. Poor memory size, that is
12:54:02 <lambdabot> I will never forget.
12:55:46 <hexpuem> isn't Arrows all you need for reactive programming in haskell
12:57:31 <Cale> hexpuem: Well, some reactive programming libraries happen to be arrows...
12:57:59 <dmead> whats the difference between div and /
12:58:01 <dmead> anyone?
12:58:07 <dmead> > div 5 3
12:58:09 <lambdabot>  1
12:58:11 <Zao> One does integers properly.
12:58:12 <hexpuem> i guess i just dont see what the point of stuff like Fran and Yampa is. Arent all the tools you need already there without them?
12:58:12 <dmead> oh
12:58:13 <dmead> integer
12:58:14 <dmead> k
12:58:48 <dmead> #haskell is the best interactive compiler known to human kind =)
12:59:20 <olsner> @quote meditation
12:59:20 <lambdabot> jamesbritt says: Writing Haskell, for example, involves an hour of meditation followed by the emission of a fold expression.
12:59:57 <dmead> :t log
12:59:58 <lambdabot> forall a. (Floating a) => a -> a
13:00:04 <dmead> :t ln
13:01:04 <vixey> dmead,
13:01:06 <vixey> :t div
13:01:07 <lambdabot> forall a. (Integral a) => a -> a -> a
13:01:10 <vixey> :t (/)
13:01:11 <lambdabot> forall a. (Fractional a) => a -> a -> a
13:01:16 <vixey> and
13:01:19 <vixey> @instances Integral
13:01:20 <lambdabot> Int, Integer
13:01:23 <vixey> @instances Fractional
13:01:23 <lambdabot> Double, Float
13:01:30 <dmead> ah
13:01:33 <mmorrow> haha, the first slide on page four made me lol: http://www.research.scea.com/gdc2003/fast-math-functions_p1.pdf
13:01:34 <lambdabot> Title: Microsoft PowerPoint - fast-math-functions_p1.ppt
13:02:00 <dmead> i find it odd that theres no ln by default
13:02:03 <dmead> or a value for e
13:03:06 <vixey> dmead,
13:03:09 <vixey> > exp 1
13:03:10 <lambdabot>  2.718281828459045
13:03:16 <dmead> right
13:03:16 <dmead> > e
13:03:18 <lambdabot>  e
13:03:20 <vixey> @let e = exp 1
13:03:21 <lambdabot> Defined.
13:03:22 <Baughn> dmead: The standard log /is/ ln
13:03:24 <dmead> :P
13:03:33 <vixey> lol
13:03:33 <dmead> > ln e
13:03:34 <lambdabot> Terminated
13:03:34 <mmorrow> dmead: probably because e would be too much to take, and e = exp 1 is easy to define
13:03:41 <mmorrow> > i
13:03:42 <lambdabot>  i
13:03:49 <Baughn> > i^2
13:03:50 <dmead> i suppose
13:03:51 <lambdabot>  i * i
13:04:02 <dmead> but java takes a shortened version
13:04:16 <vixey> e ^ (i * pi)
13:04:23 <mmorrow> -1
13:05:01 <Toxaris> > (0 :+ 1) ^ 2
13:05:04 <lambdabot>  (-1.0) :+ 0.0
13:05:10 <Deewiant> > exp ((0 :+ 1) * (3.14 :+ 0))
13:05:11 <lambdabot>  (-0.9999987317275395) :+ 1.5926529164868282e-3
13:05:27 <dmead> hold on
13:05:33 <dmead> writing a LIST COMPREHENSION
13:05:36 <dmead> for win and awesome
13:05:42 <Toxaris> > pi :: Complex
13:05:43 <lambdabot>      `Complex' is not applied to enough type arguments
13:05:43 <lambdabot>     Expected kind `?',...
13:05:44 <Toxaris> :t pi :: Complex
13:05:48 <Deewiant> > pi
13:05:49 <lambdabot>  3.141592653589793
13:05:49 <Cale> dmead: log is the natural log, as it should be
13:05:53 <Deewiant> > exp ((0 :+ 1) * (pi :+ 0))
13:05:54 <lambdabot>  (-1.0) :+ 1.2246063538223773e-16
13:06:02 <vixey> oo
13:06:03 <Cale> > log 2.71828
13:06:04 <lambdabot>  0.999999327347282
13:06:35 <Cale> > log 2.718281828459045
13:06:37 <lambdabot>  1.0
13:06:46 <Toxaris> > pi :: Complex Float -- that's what I meant
13:06:47 <tromp> > exp (0 :+ pi)
13:06:49 <lambdabot>  3.1415927 :+ 0.0
13:06:50 <lambdabot>  (-1.0) :+ 1.2246063538223773e-16
13:07:56 <vixey> > let fact n = product [1..n] in sum . take 100 $ [ 1 / fact i | i <- [0..] ]
13:07:57 <lambdabot>  2.7182818284590455
13:08:23 <Cale> I personally find the 'ln' notation distasteful, and I'm happy that Haskell decided not to go along with it :)
13:08:31 <Deewiant> distasteful? why?
13:09:04 <dmead> i just expected math stuff in haskell to try and be like regular math
13:09:06 <dmead> thats all
13:09:14 <Cale> dmead: It is like regular math :)
13:09:43 <Cale> Mathematicians don't use ln for the natural logarithm, because the natural logarithm is essentially the only one they're concerned with, so that's log :)
13:09:54 <dmead> gotcha
13:09:59 <Deewiant> I use ln because it's quicker to write :-P
13:10:06 <dmead> me too xD
13:10:14 <Deewiant> and because log has 3 meanings depending on who's reading
13:10:17 <vixey> how is ln quicker to write than log?
13:10:23 <qebab> let lg x = log x / log 2
13:10:29 <unenough> Deewiant, yet you write "because", "meanings", and "depending"
13:10:33 <Cale> Deewiant: but harder to tell apart from 1n ;)
13:10:35 <qebab> er, right ): you can have all your logs!
13:10:41 <Cale> and harder to pronounce
13:10:55 <Deewiant> unenough: well, I try to write /correctly/. :-)
13:11:07 <Deewiant> and I meant in handwriting, anyway.
13:11:29 <Deewiant> Cale: when would you write 1n? :-)
13:11:38 <Deewiant> and "lin"/"lon" is fine.
13:11:45 <unenough> Deewiant, affirmative - absolutely comprehensible approach.
13:11:53 <Cale> oy, at least pronounce it 'ell enn'
13:12:07 <unenough> err, i meant acknowledged
13:12:16 <dmead> well the solution would be to force everyone to use two parameters
13:12:22 <dmead> as in logBase
13:12:33 <dmead> so it's explict
13:12:45 <Cale> Or just abolish the idea of a base, and let the natural logarithm be the only one.
13:12:47 <vixey> that solves nothing
13:12:58 <Cale> log_10 x = log x / log 10 anyway
13:13:05 <Cale> So it's just a way of writing a constant.
13:13:21 <dmead> ?src sum
13:13:21 <lambdabot> sum = foldl (+) 0
13:13:26 <Twey> I pronounce it ln
13:13:33 <Twey> With a schwa for pronuncability :-)
13:13:47 <unenough> how does a schwa sound?
13:13:50 <unenough> oh
13:13:56 <unenough> i should know :)
13:14:05 <ayianus> Haha.
13:14:18 <unenough> i was parsing a different language
13:14:21 <Twey> Heh
13:14:54 <dmead> schwa?
13:14:55 <dmead> like
13:14:59 <dmead> schwwinnng?
13:14:59 <unenough> round here people use a makaf (or kamatz of you must)
13:15:13 <dmead> scwa-ing?
13:15:39 <Twey> In Lojban we write it 'y'
13:16:19 <unenough> is the jacobian just a shortcut for metric relations in volumes?
13:16:31 <unenough> sorry, that was impulsive
13:16:35 <dmead> ?sum
13:16:35 <lambdabot> Maybe you meant: bug run src
13:16:38 <dmead> err
13:16:39 <Deewiant> schwa is the most common sound in English and it doesn't even have a letter of its own in the Latin alphabet :-/
13:16:40 <dmead> ?src sum
13:16:40 <lambdabot> sum = foldl (+) 0
13:16:42 <vixey> unenough: mad!
13:16:44 <dmead> 3 hours sleep lambdabot
13:16:47 <dmead> give me a break
13:16:58 <dmead> > :t sum
13:16:59 <lambdabot>   parse error on input `:'
13:17:01 <dmead> :t sum
13:17:02 <lambdabot> forall a. (Num a) => [a] -> a
13:17:23 <dmead> hmm
13:17:30 <dmead> sum won't let me sum a bunch of floats
13:17:38 <dmead> it always infers Int because of the declaration of sum
13:17:40 <dmead> ?src sum
13:17:41 <lambdabot> sum = foldl (+) 0
13:17:42 <dolio> I seem to recall most of my calculus courses in college (and high school) using ln and not log.
13:17:43 <rwbarton> > sum [1.2, 5.7]
13:17:44 <lambdabot>  6.9
13:17:51 <dolio> Perhaps they weren't mathematician approved, though.
13:17:55 <Twey> > sum [1, 1.2]
13:17:56 <lambdabot>  2.2
13:18:01 <Twey> Looks OK to me
13:18:03 <dmead> all my classes used ln for natural log
13:18:07 <vixey> ln is pretty common notation
13:18:10 <dmead> indeed
13:18:22 <vixey> and I think most calculators have log as log base 10
13:18:32 <dolio> Yeah.
13:18:35 <vixey> I don't know why though, seems odd to me
13:18:39 <Toxaris> but what do you need the decimal log for?
13:18:50 <vixey> Toxaris: well telling how many digits something will be
13:18:51 <Toxaris> ln for logarithmus naturalis seems fine for me
13:19:06 <unenough> log 2 is also useful in computers
13:19:06 <dolio> I don't know, but decimal logs were the first I remember being taught in school.
13:19:12 <Heffalump> does anyone where to put the SCC annotations for statements inside do expressions? (assuming you want to profile what happens when the statement "runs")?
13:19:29 <Toxaris> vixey: when is that important? why not just use length . show? :)
13:20:42 <dolio> length . show is slow?
13:21:24 <thoughtpolice> Heffalump: I don't think you can just put them on arbitrary statements, but I think you can if you use a where clause to define it
13:21:28 <thoughtpolice> you'd have to check the manual though
13:21:42 <Heffalump> I did, it just talks about putting them on expressions
13:22:11 <Heffalump> I think I probably need to make nested dos for each new statement
13:22:23 <vixey> I was talking about calculuators not haskell
13:22:26 <dmead> yea
13:22:33 <dmead> yeaaaaaaaaaa
13:22:46 <dmead> > sum [exp (1) (x / y) | x <- [1 .. 10], y <- [11 .. 20]]
13:22:47 <lambdabot>   add an instance declaration for (Floating (t -> a))
13:22:48 <Toxaris> vixey: so with calculators, why do you want to know in advance how many digits there will be?
13:22:54 <dmead> argh
13:23:08 <vixey> I've never been in that situation
13:23:24 <dmead> > foldr (+)  [exp (1) (x / y) | x <- [1 .. 10], y <- [11 .. 20]]
13:23:32 <lambdabot>        add an instance declaration for (Floating (t -> t1), Num [t1])
13:23:40 <dmead> can someone clue me in
13:23:41 <Toxaris> Heffalump: maybe it is easier if you manually desugar the do to nested >>= and >>? then you have a expressions
13:23:43 <dmead> i seem to be clueless
13:23:50 <rwbarton> dmead: I have no idea what you intend by exp (1) (x / y)
13:24:02 <dmead> e^(x/y)
13:24:07 <rwbarton> That's exp (x/y)
13:24:13 <dmead> oh
13:24:14 <Heffalump> Toxaris: yeah, I did consider that. I'm still not quite sure what subexpression to put the SCC on though :-(
13:24:17 <dmead> ah ah
13:24:20 <Toxaris> @type foldr
13:24:21 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
13:24:24 <Heffalump> I think I just need to make a nest of them, one per statement.
13:24:34 <Toxaris> dmdead: don't forget the base case
13:24:49 <Toxaris> dmead: sorry for "killing" you
13:25:05 <dmead> it's cool
13:25:42 <rwbarton> dmead: Alternatively, you could define e = exp 1 and then write e**(x/y)
13:26:03 <dmead> right right
13:26:04 <dmead> also
13:26:11 <dmead> i'm trying to divide a float by an int
13:26:22 <dmead> and it's of course not typechecking
13:26:38 <dmead> > 10/10.00
13:26:42 <lambdabot>  1.0
13:26:46 <dmead> yargh
13:26:52 <glguy> how is: exp 1 ** x     different than exp x
13:27:15 <yitz> @src exp
13:27:15 <lambdabot> Source not found. Wrong!  You cheating scum!
13:27:20 <dmead> i'd rater just make e a constant
13:27:22 <dmead> ?src exp
13:27:22 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
13:27:26 <dmead> wot
13:27:26 <dmead> .
13:27:30 <rwbarton> It's not (well, it may be slower).  But it might look more like the original math
13:27:55 <glguy> @check (\x -> exp x == exp 1 ** x)
13:28:04 <lambdabot>  Falsifiable, after 1 tests: -1.5
13:28:24 <yitz> > exp (-1.5)
13:28:26 <lambdabot>  0.22313016014842982
13:28:35 <yitz> > exp 1 ** (-1.5)
13:28:36 <lambdabot>  0.22313016014842985
13:28:39 <dmead> hmm
13:28:53 <dmead> > foldr (+)  [exp (1) (x / y) | x <- [1 .. 10], y <- [11 .. 20]]
13:28:54 <lambdabot>        add an instance declaration for (Floating (t -> t1), Num [t1])
13:28:58 <dmead> > foldr (+)  [exp (x / y) | x <- [1 .. 10], y <- [11 .. 20]]
13:28:59 <lambdabot>   add an instance declaration for (Num [t])
13:29:11 <dmead> > sum  [exp (x / y) | x <- [1 .. 10], y <- [11 .. 20]]
13:29:14 <lambdabot>  147.69671840310423
13:29:18 <dmead> kay and...
13:29:26 <dmead> > (sum  [exp (x / y) | x <- [1 .. 10], y <- [11 .. 20]]) / 10
13:29:28 <lambdabot>  14.769671840310423
13:29:30 <dmead> jesus..
13:29:42 <dmead> > let n = 10; in (sum  [exp (x / y) | x <- [1 .. 10], y <- [11 .. 20]]) / n
13:29:43 <lambdabot>  14.769671840310423
13:29:57 <rwbarton> Numeric constants like 10 are overloaded
13:29:57 <dmead> > let n = 10; in log((sum  [exp (x / y) | x <- [1 .. 10], y <- [11 .. 20]]) / n)
13:29:58 <lambdabot>  2.692575878308004
13:30:11 <dmead> to what
13:30:16 <rwbarton> :t 10
13:30:17 <lambdabot> forall t. (Num t) => t
13:30:24 <yitz> > sum  [exp (x / y) | (x,y) <- zip [1 .. 10] [11 .. 20]]
13:30:25 <rwbarton> Int, Integer, Double, ...
13:30:25 <lambdabot>  14.041138198103127
13:30:39 <vixey> :t let f 1 = 'x' in f
13:30:40 <lambdabot> forall t. (Num t) => t -> Char
13:31:06 <vixey> :t let f (Just 1) = 'x' in f
13:31:09 <lambdabot> forall t. (Num t) => Maybe t -> Char
13:31:11 <dmead> > let foo  = let n = 10; in log((sum  [exp (x / y) | x <- [1 .. 10], y <- [11 .. 20]]) / n) in foo
13:31:12 <lambdabot>  2.692575878308004
13:31:26 <vixey> :t let f y = case y of Just 1 -> 'x' in f
13:31:27 <lambdabot> forall t. (Num t) => Maybe t -> Char
13:31:45 <yitz> dmead: you realize that there are 100 terms in that sum, not 10?
13:31:46 <dmead> > let foo (q:qs)  = let n = (length q:qs); in log((sum  [exp (x / y) | x <- [1 .. 10], y <- [11 .. 20]]) / n) in foo
13:31:47 <lambdabot>  Couldn't match expected type `Int' against inferred type `[a]'
13:31:57 <dmead> finally
13:32:20 <dmead> yitz, no i didn't actually
13:32:25 <dmead> but you seem to be right, i need to have a tuple
13:32:31 <mmorrow> dmead: http://hpaste.org/9206
13:33:04 <dmead> cool
13:33:09 <mmorrow> (just some random useful things i had in various places + your e/log thing) :)
13:33:12 <dmead> whats foldlcnt?
13:33:24 <dmead> whats it for i mean
13:33:35 <mmorrow> it gives you the list length and the result of the fold
13:33:43 <dmead> ah
13:33:47 <mmorrow> i don't really like that name, but can't think of anything better
13:34:04 <dmead> foldcount makes sense
13:34:09 <mmorrow> foldCnt is good for where you do..
13:34:10 <mmorrow> yeah
13:34:22 <mmorrow> oh, you mean the name
13:34:26 <vixey> runhaskell Setup.lhs install
13:34:27 <vixey> Setup.lhs: /usr/local/share/happy-1.17: createDirectory: permission denied (Permission denied)
13:34:31 <rwbarton> mmorrow: > minmax [1..100000000] -- heap overflow
13:34:35 <mmorrow> crap
13:34:40 <vixey> you know that.... can you make it install somewhere else?
13:34:55 <mmorrow> i wrote it differently, but in ghci that one way better, hold on
13:35:00 <rwbarton> figured I'd point it out since you went to the trouble with mean
13:35:20 <mmorrow> http://hpaste.org/9206#a1
13:35:28 <dmead> http://hpaste.org/9207
13:35:40 <vixey> lol
13:35:40 <vixey> crazy_perl_regexp =
13:35:40 <vixey>  "s/^#\\s+(\\d+)\\s+(\"[^\"]*\")/{-# LINE \\1 \\2 #-}/g;s/\\$(Id:.*)\\$/\\1/g"
13:35:40 <dmead> if i eliminate /n it typechecks
13:35:44 <mmorrow> rwbarton: that minmax is slower than the other in ghci, but shouldn't blow the stack
13:35:49 <Guest90052> Hello
13:36:02 <vixey> @let crazy_perl_regexp = "s/^#\\s+(\\d+)\\s+(\"[^\"]*\")/{-# LINE \\1 \\2 #-}/g;s/\\$(Id:.*)\\$/\\1/g"
13:36:02 <lambdabot> Defined.
13:36:06 <Guest90052> can you pattetrn match on lists &
13:36:10 <mmorrow> rwbarton: (re: http://hpaste.org/9206#a1)
13:36:19 <dmead> mmorrow, http://hpaste.org/9207
13:36:21 <vixey> @remember crazy_perl_regexp = "s/^#\\s+(\\d+)\\s+(\"[^\"]*\")/{-# LINE \\1 \\2 #-}/g;s/\\$(Id:.*)\\$/\\1/g"
13:36:22 <lambdabot> Nice!
13:36:25 <vixey> @undef
13:36:25 <lambdabot> Undefined.
13:36:41 <Guest90052> \help
13:37:03 <vixey> hi tigres
13:37:04 <tristes_tigres> :-)
13:37:15 <tristes_tigres> hello, vixey
13:37:17 <rwbarton> @unpl \x xs -> flip (flip foldl' (x,x)) xs
13:37:17 <lambdabot> \ x xs c -> foldl' c (x, x) xs
13:37:18 <mar77a> tres tristes tigres
13:37:24 <yitz> hi Guest90052.
13:37:30 <tristes_tigres> mar : exactly
13:38:26 <rwbarton> dmead: right, length returns an Int.  you can use fromIntegral to turn it into another type
13:38:36 <tristes_tigres> I have a quick question: can one pattern match on list ? Using regexp or parsec seems overkill
13:38:38 <Zao> Or genericLenght.
13:38:40 <yitz> tristes_tigres: pourquoi on est tristes aujourd'hui?
13:38:41 <vixey> to be honest I would not even do that
13:38:42 <Zao> *Length.
13:38:47 <vixey> tristes_tigres: yes you can
13:38:48 <dmead> ?src fromIntegral
13:38:48 <lambdabot> fromIntegral = fromInteger . toInteger
13:38:51 <vixey> but I go
13:38:54 <Toxaris> tristes_tigres: you can pattern match on everything :)
13:38:55 <vixey> import Prelude hiding (length)
13:39:01 <tristes_tigres> yitz: Sorry, english and russian only ^-)
13:39:04 <vixey> length = foldr (const (1+)) 0
13:39:05 <dmead> > fromIntegral 1
13:39:05 <Cale> Toxaris: except function applications :)
13:39:06 <vixey> or something ilke thta
13:39:08 <lambdabot>  1
13:39:11 <Zao> @type genericLength
13:39:12 <lambdabot> forall b i. (Num i) => [b] -> i
13:39:17 <dmead> how do i change it to float?
13:39:25 <yitz> > let [x, y] = [2,4] in (x, y)
13:39:30 <vixey> tristtes_tigres: You can do f [x,y,z] = ... or f (x:3:y:zs) = ...
13:39:38 <lambdabot>  (2,4)
13:39:53 <Zao> > genericLength [42, 3, 5] :: Float
13:39:54 <lambdabot>  3.0
13:39:54 <rwbarton> dmead: it'll infer what you need to change it to.
13:39:58 <dmead> ah
13:40:11 <rwbarton> or, you can tell it like Zao did
13:40:21 <Toxaris> Cale: yeah unfortunatly
13:40:22 <dmead> i haven't looked closesly at the semantics of Integral/Fractional in haskell yet
13:40:23 <mar77a> comen trigo en un trigal
13:40:36 <mmorrow> dmead: http://hpaste.org/9207#a1
13:40:47 <Cale> Toxaris: somewhat... that would let you break referential transparency though
13:41:22 <tristes_tigres> but can I do this ?  myfunc '<':str1++"><"++str2++">" = str1++str2
13:41:39 <Cale> tristes_tigres: no
13:41:42 <vixey> no you can't do that
13:41:51 <vixey> hmm
13:41:55 <Toxaris> tristes_tigres: no, because you cannot use ++ in patterns, unfortunately :(
13:42:11 * rwbarton doesn't think that's unfortunate either
13:42:14 <Cale> Well, it would make pattern matching nondeterministic.
13:42:18 <yitz> ++ is a function. But : is a constructor, so you can use that.
13:42:29 <Cale> (at the very least)
13:42:45 <dmead> mmorrow, why did you use .
13:42:57 <Toxaris> Cale: I'm thinking of a syntactic sugar solution, e.g. defining (match-++) :: Pattern a -> Pattern [a] -> Pattern [a], and then ++ in a pattern calls match-++
13:43:07 <dmead> why not "fromIntegral (length (x:xs))
13:43:08 <dmead> "
13:43:23 <Toxaris> Cale: approximately :)
13:43:24 <tristes_tigres> So to make this sort of pattern match I do need Regex.Posix ?
13:43:47 <mmorrow> dmead: just a matter of preference
13:43:54 <Toxaris> dmead: what's wrong with genericLength?
13:44:05 <dmead> Toxaris, didn't realize it existed
13:44:19 <Cale> Also, the fact that you must import it from Data.List ;)
13:44:24 <dmead> ah
13:44:29 <Cale> (not that that's too much of a problem)
13:44:33 <dolio> What's wrong is that it should be called length. :)
13:44:37 <Cale> dolio: right
13:44:42 <r3m0t> > (0::Integer) * undefined
13:44:44 <lambdabot>  Exception: Prelude.undefined
13:45:27 <yitz> Toxaris: then you could say match-++ x y = join ackerman (length x) (length y), for example.
13:45:46 <mmorrow> dmead: so,   (l . k . j . i . h . g . f $ x) === (l $ k $ j $ i $ h $ g $ f $ x) === (l . k . j . i . h . g . f ) x  /= (l $ k $ j $ i $ h $ g $ f ) x
13:46:46 <Toxaris> yitz: I do not see how that would typecheck, but I think you mean that one could hide computational complexity or even bottom in the pattern
13:47:18 <yitz> Toxaris: yes. pattern matching would get pretty out of control. i think that was Cale's point.
13:47:48 <mmorrow> @pl \l k j i h g f x -> l $ k $ j $ i $ h $ g $ f $ x
13:47:49 <lambdabot> (. ((. ((. ((. ((. (.)) . (.) . (.))) . (.) . (.) . (.))) . (.) . (.) . (.) . (.))) . (.) . (.) . (.) . (.) . (.))) . (.) . (.) . (.) . (.) . (.) . (.)
13:48:01 <tristes_tigres> \me wishes Perl regexps be allowed in pattern matching
13:48:04 <Toxaris> Cale: how would pattern matching get non-deterministic?
13:48:14 * rwbarton dares mmorrow to write @. ty pl ...
13:48:30 <r3m0t> @. ty pl
13:48:30 <lambdabot> Plugin `compose' failed with: Unknown command: "ty"
13:48:36 <mmorrow> awww
13:48:52 <rwbarton> type then
13:49:02 <r3m0t> @. :t
13:49:02 <lambdabot> Not enough arguments to @.
13:49:04 <rwbarton> @. type pl (\f g x -> f (g x))
13:49:05 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:49:09 <mmorrow> : \l k j i h g f x -> l $ k $ j $ i $ h $ g $ f $ x
13:49:15 <mmorrow> :t \l k j i h g f x -> l $ k $ j $ i $ h $ g $ f $ x
13:49:19 <lambdabot> forall b b1 b2 b3 b4 b5 a b6. (b1 -> b) -> (b2 -> b1) -> (b3 -> b2) -> (b4 -> b3) -> (b5 -> b4) -> (b6 -> b5) -> (a -> b6) -> a -> b
13:49:22 <mmorrow> hehe
13:49:36 <rwbarton> yeah but
13:49:43 <rwbarton> :t (. ((. ((. ((. ((. (.)) . (.) . (.))) . (.) . (.) . (.))) . (.) . (.) . (.) . (.))) . (.) . (.) . (.) . (.) . (.))) . (.) . (.) . (.) . (.) . (.) . (.)
13:49:45 <lambdabot> forall a (f :: * -> *) a1 a2 a3 a4 a5 b. (Functor f) => (a5 -> b) -> (a4 -> a5) -> (a3 -> a4) -> (a2 -> a3) -> (a1 -> a2) -> (a -> a1) -> f a -> f b
13:49:50 <rwbarton> Oh, not so bad
13:49:56 <mmorrow> ahh, monomorphism
13:50:15 <rwbarton> I was hoping for a pile of Functors
13:50:33 <mmorrow> heh, a "pile"
13:51:01 <mmorrow> @remember rwbarton I was hoping for a pile of Functors
13:51:01 <lambdabot> Nice!
13:51:22 <yitz> @. unpl pl \l k j i h g f x -> l $ k $ j $ i $ h $ g $ f $ x
13:51:23 <lambdabot> (\ bt eb bb be bh bk bn bq -> bt (eb (bb (be (bh (bk (bn bq)))))))
13:52:01 <vixey> tristes_tigres: ok I had a go at it
13:52:08 <mmorrow> :t foldl' (.) id
13:52:08 <lambdabot> forall a. [a -> a] -> a -> a
13:52:45 <Cale> Toxaris: Consider  f (xs ++ ys) = length xs
13:52:53 <dmead> mmorrow, how is functionc composition the same as application?
13:53:10 <Cale> mmorrow: ew, why not foldr there?
13:53:12 <vixey> f (x ++ "-" ++ y) = (x,y) -- another example
13:53:13 <mmorrow> > foldl' (.) id (replicate 20 (*2)) 2
13:53:14 <lambdabot>  2097152
13:53:18 <mmorrow> > foldr (.) id (replicate 20 (*2)) 2
13:53:19 <lambdabot>  2097152
13:53:37 <dons> http://www.cse.unsw.edu.au/~dons/papers/CPJS08.html all done.
13:53:37 <mmorrow> Cale: i can never decide which is more appropriate
13:53:39 <lambdabot> Title: Haskell: Batteries Included
13:53:51 <dmead> whats ' do?
13:54:01 <mmorrow> @src foldl
13:54:02 <lambdabot> foldl f z []     = z
13:54:02 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
13:54:03 <mmorrow> @src foldl'
13:54:03 <lambdabot> foldl' f a []     = a
13:54:03 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
13:54:11 <Cale> dmead: It's just part of the identifier, foldl' is the strict version of foldl
13:54:17 <vixey> tristes_tigres: If you like I pasted it http://hpaste.org/9208
13:54:22 <mmorrow> dmead: ' is a valid identifier character, so you can have x, x'', x''', etc
13:54:38 <dmead> ah
13:54:40 * tristes_tigres last was on irc in 2000
13:54:51 <vixey> so like
13:54:54 <tristes_tigres> vixey: thnks
13:54:55 <dmead> @seen tristes_tigres
13:54:55 <lambdabot> tristes_tigres is in #haskell. I last heard tristes_tigres speak 1s ago.
13:55:02 <vixey> foo string = let [l,r] = match [S"<",V,S"><",V,S">"] string in ...
13:55:05 <Cale> mmorrow: Since function application is outermost first, you want to give the first functions in the list to get a shot at evaluating and possibly saving you the trouble of evaluating the rest of the list.
13:55:12 * tristes_tigres was not called tristes_tigres then
13:56:04 <vixey> better syntax would be nice..
13:56:09 <vixey> I don't know how to do that though
13:56:11 <dolio> > foldr (.) id [const 5, undefined] 7
13:56:16 <vixey> oh and actually it returns all matches
13:56:19 <Cale> foldr (.) id [f,g,h] x  --->  (f . foldr (.) id [g,h]) x  --->  f (foldr (.) id [g,h] x)
13:56:23 <vixey> ([l,r]:_)
13:56:26 <lambdabot>  thread killed
13:56:30 <mmorrow> Cale: ahhh, i see
13:56:58 <vixey> going to try it with QQ ... once GHC has built..
13:57:24 <Cale> foldr (.) id (repeat (const 0)) 1
13:57:25 <Cale> > foldr (.) id (repeat (const 0)) 1
13:57:26 <lambdabot>  0
13:57:27 <mmorrow> vixey: cool!
13:57:30 <Cale> > foldl' (.) id (repeat (const 0)) 1
13:57:32 <lambdabot>  Tried to use too much memory
13:58:09 <mmorrow> great, that's my "standard" example now
13:59:56 <mmorrow> > foldr (.) id (repeat read) $ fix show
14:00:11 <lambdabot>  thread killed
14:00:13 <mmorrow> > foldl (.) id (repeat read) $ fix show
14:00:16 <lambdabot>  "
14:00:23 <mmorrow> hmm
14:00:52 <mmorrow> Cale: what should be taken from that? that's exactly the case that confuses me
14:01:20 <dolio> read uses its argument.
14:01:37 <Cale> neither of them works
14:01:45 <vixey> :t foldl (.) id (repeat read)
14:01:55 <Cale> (and it's only chance, seemingly, that you got a slightly different result here)
14:01:56 <mmorrow> dolio, Cale: ah
14:02:00 <lambdabot> thread killed
14:02:40 <mmorrow> Cale: yeah, since show always produces a leading '"' no matter what
14:02:51 <Cale> yeah
14:02:55 <Toxaris> vixey: you probably can make (match "<" V "><" V ">") work with Text.PrintF like tricks
14:03:38 <vixey> where is the quasi quotes documentation?
14:03:40 <mmorrow> :t 1
14:03:41 <lambdabot> forall t. (Num t) => t
14:03:47 <mmorrow> :t foldl (.) id (repeat read)
14:03:47 <lambdabot> String -> String
14:03:54 <mmorrow> hmm
14:04:08 <mmorrow> what happened here:
14:04:09 <mmorrow> <vixey> :t foldl (.) id (repeat read)
14:04:13 <mmorrow> lambdabot> thread killed
14:04:31 <Cale> I'm not sure... if you do it in ghci, the results are similar.
14:04:53 <vixey> :t foldl (.) id (repeat read)
14:04:56 <lambdabot> String -> String
14:05:05 <Cale> er...
14:05:05 <vixey> mmorrow: just lambdabroken
14:05:09 <Cale> that was a :t
14:05:15 <mmorrow> heh
14:05:20 <Cale> So probably just server hiccup
14:05:24 <mmorrow> ah
14:05:27 <Cale> code.h.o is often busy
14:05:48 <vixey> am I right in thinking the only documentation is a wiki page and the source code?
14:06:00 <Cale> vixey: documentation for what?
14:06:03 <mmorrow> oh, vixey i have it up, hold on
14:06:10 <vixey> quasiquotes
14:06:15 <Cale> There's a paper too
14:06:18 <chrisdone> how does one tell inferior-haskell-mode which directory to cd to for loading a file?
14:06:33 <chrisdone> it changes to "~/.cabal", and so importing local files fails
14:07:05 <Cale> I wonder why lambdabot inevitably creates dozens of zombie runplugs processes
14:07:06 <dcoutts> chrisdone: you get the updated emacs mode, the current one is busted
14:07:10 <mmorrow> vixey: oh, do you mean beyond the haddock docs and that wiki? if so, none. TH head haddock darcs are here fwiw http://code.haskell.org/~morrow/quasiquotes/template-haskell_docs_HEAD_080623/
14:07:15 <lambdabot> Title: template-haskell-2.2, http://tinyurl.com/6xdh6w
14:07:15 <chrisdone> dcoutts: oh, sweet
14:07:39 <chrisdone> dcoutts: here? http://www.iro.umontreal.ca/~monnier/elisp/#haskell-mode
14:07:39 <lambdabot> Title: Emacs Lisp packages
14:08:02 <Cale> mmorrow: There's a whole paper on the quasiquotes for Haskell feature.
14:08:02 <mmorrow> in particular, Language.Haskell.TH.Quote   http://code.haskell.org/~morrow/quasiquotes/template-haskell_docs_HEAD_080623/Language-Haskell-TH-Quote.html
14:08:03 <lambdabot> Title: Language.Haskell.TH.Quote, http://tinyurl.com/5wmqsp
14:08:04 <dcoutts> chrisdone: not that I know where to get the update from or anything, I don't use emacs, but I hear that bug is fixed (it crops up here very frequently)
14:08:04 <chrisdone> dcoutts: from the CVS?
14:08:15 <chrisdone> dcoutts: oh I see
14:08:15 <mmorrow> Cale: yeah, i thought she meant the haddock docs
14:08:34 <dcoutts> chrisdone: try and get advice from someone who uses emacs
14:08:37 <mmorrow> Cale: (I've read that paper many a time :))
14:10:05 <hexpuem> @src (<*>)
14:10:05 <lambdabot> Source not found. I feel much better now.
14:11:45 <mmorrow> Cale: oh, i see. i didn't mention the paper because it's linked to you-can't-miss-it-ly on the wiki
14:12:13 <Cale> ah
14:12:15 <chrisdone> any emacs users...?
14:12:25 <hexpuem> yea i use it
14:13:41 <chrisdone> hexpuem: can you load a file which imports another file in the same directory, with C-c C-l?
14:13:56 <mmorrow> vixey: regexqq is a short read and is an example of a quasiquoter: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/regexqq
14:13:57 <lambdabot> Title: HackageDB: regexqq-0.6, http://tinyurl.com/6jskro
14:14:06 <vixey> thank you
14:14:13 <hexpuem> never tried, sorry
14:14:28 <mmorrow> maybe [] tail $ [$rx|^([+-])?([0-9]+)\.([0-9]+)|] (show $ negate pi)
14:14:29 <mmorrow> ["-","3","141592653589793"]
14:14:45 * ayianus salutes and leaves. 
14:14:48 <vixey> cool
14:14:48 <mmorrow> ghci> [$rx|^([+-])?([0-9]+)\.([0-9]+)|] (show $ negate pi)
14:14:48 <mmorrow> Just ["-3.141592653589793","-","3","141592653589793"]
14:15:37 <mmorrow> and it checks at compile time to ensure the regexes are valid (valid being defined as compile via the pcre compilation method without error)
14:16:15 <vixey> aww
14:16:20 <vixey> I can't really do exactly what I wanted
14:16:31 <mmorrow> ghci> :t [$rx|^([+-])?([0-9]+)\.([0-9]+)|]
14:16:31 <mmorrow> [$rx|^([+-])?([0-9]+)\.([0-9]+)|] :: String -> Maybe [String]
14:17:43 <mmorrow> vixey: yeah, the TH pattern syntax being restictive is sucky
14:17:54 * vixey was hoping for  f [$match|x++y|] = (x,y)  --->  f fresh = <something I constructed>
14:18:06 <vixey> huh
14:18:06 <chrisdone> dcoutts: nevermind, I fixed it in the source by removing its attempts at figuring out the right directory
14:18:38 <dcoutts> chrisdone: what it's trying to do is find the .cabal project file and cd to the root of your build tree
14:19:10 <dcoutts> chrisdone: but if you don't have one then it keeps going, up to your home dir and then mistakes the ~/.cabal directory for a .cabal file with no package name.
14:19:13 <mmorrow> vixey: http://hackage.haskell.org/trac/ghc/ticket/2399
14:19:14 <chrisdone> dcoutts: yeah, and when there's no .cabal file it assumes .cabal
14:19:14 <lambdabot> Title: #2399 (Template Haskell: support for view patterns) - GHC - Trac
14:19:31 <mmorrow> i need to add myself to that CC list....
14:19:40 <dcoutts> chrisdone: so with your hack you'll not get any clever cabal stuff
14:19:57 <chrisdone> dcoutts: well I can just fix it not to cd if it can't find the .cabal then
14:20:07 <chrisdone> dcoutts: there's no reason for it to cd to .cabal when I'm inside ~/
14:20:35 <mmorrow> vixey: oh, i've been trying to figure out how to do essentially that. i think i've found a solution that involves using hs-plugins
14:20:42 <mmorrow> but i haven't worked it out yet
14:20:48 <vixey> mmorrow: Does GHC have view patterns?
14:21:00 <vixey> mmorrow: i.e. would one only have to add the support to TH to get this?
14:21:09 <mmorrow> i think ghc >= 6.9
14:21:16 <mmorrow> vixey: yes
14:21:36 <vixey> ok good
14:22:51 <mmorrow> vixey: ah, actually a better seeming solution is described in the last comment here http://hackage.haskell.org/trac/ghc/ticket/2399
14:22:52 <lambdabot> Title: #2399 (Template Haskell: support for view patterns) - GHC - Trac
14:23:11 <mmorrow> "That would push pattern guards into the syntax of patterns. Now view patterns are syntactic sugar:"
14:24:39 <pgavin> @hoogle liftIO
14:24:39 <lambdabot> Control.Monad.Trans.liftIO :: MonadIO m => IO a -> m a
14:27:58 <chrisdone> dcoutts: oki doki. it has clever cabal stuff and doesn't cd to ~/.cabal anymore. yay, I am satisfied
14:28:08 <chrisdone> dcoutts: thanks for your help
14:28:17 <yitz> > take 16 . map length . filter ((=='\\') . head) . group $ fix show
14:28:19 <lambdabot>  [1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535]
14:31:53 <vixey> > map (length . ('!':)) . filter ((=='\\') . head) . group $ fix show
14:31:57 <lambdabot>  [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262...
14:33:38 <tromp> :t fix show
14:33:39 <lambdabot> String
14:33:51 <vixey> > show ""
14:33:51 <vixey> > show . show $ ""
14:33:53 <lambdabot>  "\"\\\"\\\"\""
14:33:53 <lambdabot>  "\"\""
14:33:55 <vixey> > show . show . show $ ""
14:33:56 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\"\\\"\""
14:33:59 <vixey> > fix show
14:34:00 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
14:34:28 <vixey> what does "Package contains no library to register: ghc-bin-6.9..." mean?
14:34:49 <Cale> > map length . filter ((=='\\') . head) . group $ fix show
14:34:54 <lambdabot>  [1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535,131071,262...
14:35:56 <hexpuem> are all members of Functor part of Applicative?
14:36:16 <Toxaris> hexpuem: yes, because Functor is a superclass of Applicative
14:36:37 <hexpuem> thanks
14:36:59 <mmorrow> > fmap ($ []) $ scanl (.) id (repeat show)
14:37:02 <lambdabot>  ["","\"\"","\"\\\"\\\"\"","\"\\\"\\\\\\\"\\\\\\\"\\\"\"","\"\\\"\\\\\\\"\\\\...
14:37:14 <mmorrow> > fmap ($ []) $ scanr (.) id (repeat show)
14:37:16 <lambdabot>  ["\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
14:37:16 <Toxaris> hexpuem: so Applicative instances support all Functor methods, i.e., fmap
14:37:26 <Toxaris> hexpuem: (fmap is the only Functor method)
14:37:44 <Toxaris> hexpuem: and every Applicative instance is a Functor instance
14:37:45 <mmorrow> (scanr is the better to use there)
14:37:58 <Toxaris> hexpuem: but not every Functor instance is a Applicative instance
14:38:02 <mmorrow> oh, oops
14:38:13 <mmorrow> > fmap ($ []) $ scanr (.) id (take 4 . repeat $ show)
14:38:14 <lambdabot>  ["\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\"\\\"\"","\"\\\"\\\\\...
14:38:22 <hexpuem> well im trying to see how fmap (+) (Just 1) <*> (Just 2)
14:38:33 <mmorrow> oh wait, scanl *needs* to be used there:
14:38:39 <hexpuem> but saw Maybe only had an instance for functor
14:38:39 <mmorrow> > fmap ($ []) $ scanl (.) id (repeat show)
14:38:41 <lambdabot>  ["","\"\"","\"\\\"\\\"\"","\"\\\"\\\\\\\"\\\\\\\"\\\"\"","\"\\\"\\\\\\\"\\\\...
14:39:01 <hexpuem> *to see how <*> works
14:39:01 <Toxaris> hexpuem: Maybe has an instance for Applicative, and that one has to be in scope for that code to work
14:39:10 <hexpuem> hmm
14:39:17 <mmorrow> > fmap ($ x) $ scanl (.) id (repeat f)
14:39:20 <lambdabot>  [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (f...
14:39:28 <mmorrow> > fmap ($ x) $ scanr (.) id (repeat f)
14:39:29 <lambdabot>  [f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (...
14:39:55 <vixey> > iterate show ""
14:39:56 <lambdabot>  ["","\"\"","\"\\\"\\\"\"","\"\\\"\\\\\\\"\\\\\\\"\\\"\"","\"\\\"\\\\\\\"\\\\...
14:39:59 * Twey wonders whether it would be feasible to implement backtracking constraint-oriented programming in Haskell using a monad.
14:39:59 <mmorrow> > iterate f x
14:40:00 <lambdabot>  [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (f...
14:40:06 <vixey> > length . iterate show $ ""
14:40:07 <hexpuem> guess i shouldnt look at 4 year old cvs entries off the web
14:40:08 <lambdabot>  Tried to use too much memory
14:40:08 <hexpuem> haha
14:40:19 <Toxaris> hexpuem: http://haskell.org/ghc/docs/latest/html/libraries/base/src/Control-Applicative.html#(line92)
14:40:20 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/5avvxt
14:41:02 <hexpuem> thanks
14:42:45 <Philippa> Twey: generally I've not bothered with the backtracking. But probably not too awful
14:43:03 <Philippa> Twey: you might find it helps to ask "what would this look like if I designed the language from scratch?"
14:43:46 <Saizan_> http://overtond.blogspot.com/2008/07/pre.html <- this might be relevant
14:43:46 <lambdabot> Title: David's Blog: Constraint Programming in Haskell
14:43:47 <mmorrow> > map ((+1) . length) . filter ((=='\\') . head) . group $ fix show
14:43:56 <lambdabot>  [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262...
14:44:11 <Twey> Philippa: Mm, I was just looking at http://www.randomhacks.net/articles/2007/03/12/monads-in-15-minutes (which is a pretty nasty implementation, obviously not very scaleable)
14:44:12 <lambdabot> Title: Monads in 15 minutes: Backtracking and Maybe, http://tinyurl.com/2xlyze
14:44:36 <Twey> Ooh, thanks Saizan_
14:46:01 <yitz> Twey: StateT [] does that.
14:47:29 <Twey> Eh what?
14:47:33 <Twey> Backtracking?
14:47:36 <yitz> yes
14:47:41 * Twey blinks.
14:47:44 <Twey> It *does*?
14:48:00 <chrisdone> mmkay so I have a validator so this works: age = notEmpty & numeric & number & larger 18 & less 120. I can probably make it a monad so it would be notEmpty >>= numeric >>= number, etc
14:48:16 <ddarius> @unmtl StateT s [] a
14:48:17 <lambdabot> s -> [(a, s)]
14:48:19 <yitz> it means, iterate over lists, and reset the state to its previous value when you hit an mzero.
14:48:19 <vixey> ?
14:49:05 <ddarius> vixey is upset for all the dodecagenerians.
14:50:47 <chrisdone> hmm choice in monads
14:51:04 <yitz> Twey: take a look at the sudoku page on the wiki. look at Cale's solution and my solution.
14:51:12 <chrisdone> mplus?
14:51:12 <yitz> @go haskell wiki sudoku
14:51:17 <lambdabot> http://web.math.unifi.it/users/maggesi/haskell_sudoku_solver.html
14:51:20 <vixey> what is Twey wondering about?
14:51:22 <mmorrow> chrisdone: age = allValid [notEmpty,numeric,number,larger 18,less 120] where allValid = foldr (&) anything
14:51:23 <yitz> no no
14:51:28 <vixey> something to do with search?
14:51:51 <mmorrow> chrisdone: (assuming some function anything which always answers valid)
14:52:00 <Twey> Backtracking constraint programming, vixey
14:52:02 <chrisdone> mmorrow: yeah
14:52:12 <vixey> what about it?
14:52:13 <chrisdone> mmorrow: saying I shouldn't make it a monad?
14:52:13 <yitz> http://www.haskell.org/haskellwiki/Sudoku
14:52:14 <lambdabot> Title: Sudoku - HaskellWiki
14:52:17 <Twey> I had no idea it was so useful
14:52:21 <Twey> Er
14:52:23 <Twey> Easy
14:52:30 <vixey> I don't think it's very easy
14:52:43 <Twey> Yes, unfortunately my Internet appears to be somewhat, er, incapacitated *prods*
14:52:46 <mmorrow> chrisdone: not knowing about what's happening behind the scenes, i dunno
14:53:00 <Twey> I'll look when it settles down :-\
14:53:17 <vixey> easy to use but the theory is involved...
14:53:41 <chrisdone> mmorrow: (x & k) v = case x k of Valid k' -> y (Valid k'); Invalid e -> Invalid e
14:53:54 <chrisdone> mmorrow: i.'e if the first fails, don't try the second
14:54:11 <vixey> Twey, http://www.vex.net/~trebla/haskell/forwardconstraint/ForwardConstraint.hs
14:54:13 <lambdabot> http://tinyurl.com/26xt9x
14:54:27 <chrisdone> mmorrow: er, that definition is wrong. n/m
14:54:31 <Twey> Cannot access just yet, vixey :-\
14:54:44 <Twey> Thanks for adding to my neat little line of 'Loading...' tabs, though :-P
14:55:24 <chrisdone> mmorrow: http://hpaste.org/9209 :)
14:55:25 <mmorrow> chrisdone: look at the Maybe or Either err monads, that seems similar
14:55:32 * mmorrow looks
14:55:52 <chrisdone> elias`: yeah. seems I can substitude Valid for Either
14:55:59 <chrisdone> er, mmorrow
14:57:49 <chrisdone> brb
15:03:21 <mmorrow> chrisdone: heh, i started messing around with it and got carried away. i'm gonna play with it because this would be useful to me also. but right now, i'm not sure how best to put the idea into code.
15:03:37 <chrisdone> mmorrow: cools :)
15:03:54 <chrisdone> mmorrow: what idea?
15:04:45 <mmorrow> i think it would be best to deal with something like
15:04:46 <mmorrow> newtype Validate v a = Validate (a -> Valid v)
15:04:49 <mmorrow> or something
15:05:10 <chrisdone> similar to the state monad?
15:05:53 <chrisdone> I was actually trying something like that all night last night >_<
15:05:57 <chrisdone> couldn't do it
15:06:18 <mmorrow> then have a class Validation v a where validate :: Validate v a
15:06:29 <chrisdone> ah?
15:06:34 <mmorrow> chrisdone: i remember that code you pasted
15:07:31 <mmorrow> chrisdone: yeah, the class is just so different types can be associated automatically to their respective validating functions so you can just use on function validate to refer to it
15:07:47 <mmorrow> (this is off the top of my head though...)
15:07:59 <chrisdone> how is an invalid value handled?
15:08:05 <dons> http://www.reddit.com/comments/6tuzp/tangible_functional_programming_a_modern_marriage/
15:08:06 <lambdabot> Title: Tangible Functional Programming: a modern marriage of usability and composabilit ..., http://tinyurl.com/6laqoj
15:08:07 <dons> go conal!
15:08:33 <chrisdone> awesome^_^^!!
15:08:55 <mmorrow> chrisdone: i'm gonna mess with it
15:09:01 <chrisdone> mmorrow: cool :)
15:09:08 <halberd> does anybody know of an information theory approach to software engineering, along the following lines:
15:09:56 <halberd> assume that there is an ideal source of a program, which is entirely perfect, and this is sent through a channel with noise added by the programmer's mistakes
15:10:03 <chrisdone> > Right "good" `mplus` Right "whup"
15:10:14 <lambdabot>  Add a type signature
15:10:17 <halberd> is there an analysis of this situation from a coding theory perspective?
15:10:28 <chrisdone> > Right "good" `mplus` Right "whup" :: Either String Int
15:10:29 <lambdabot>  Couldn't match expected type `Int' against inferred type `[Char]'
15:10:43 <chrisdone> sorry for spamming
15:11:20 <halberd> i.e. is there an analysis of "error correcting codes" for the program, and a maximum channel capacity based on how fast the programmer works and how many errors he makes
15:11:41 <chrisdone> dons: ahhh I've seen this before, I think. GUI components are composed like functions (or as functions)?
15:11:51 <halberd> is this a good idea?  has it been worked before?
15:12:45 <vixey> it doesn't sound like a good idea
15:13:38 <halberd> why do you think so vixey
15:15:21 <halberd> type checking could be viewed as error checking codes, like checksums, in this context
15:15:25 <Cale> halberd: well, in a sense, types give a kind of 'error detecting code' for programs, by encoding some information about the program separately.
15:15:34 <Cale> yeah
15:17:54 <halberd> of course the main problem with this analysis would be that a programmer isn't likely to make single-bit mistakes
15:18:03 <Cale> Well, yes
15:18:31 <halberd> but perhaps you could adapt it to a situation where he is likely to make mistakes at some branch of an expression tree that invalidate everything below that in the branch
15:19:01 <halberd> the data passed through the channel being modeled as a tree instead of a linear sequence of symbols
15:19:16 <Cale> In order to be able to correct mistakes, my feeling is that you'd need to have a lot more redundancy than programmers are willing to add to their programs
15:19:29 <Cale> We already complain about boilerplate quite a bit. :)
15:19:56 <halberd> well if you're not willing to add that you could instead talk about exactly how much type checking you need to get the probability of undetected errors sufficiently low
15:20:10 <halberd> talk about detecting errors rather than correcting them
15:20:20 <Cale> well, yeah, that's sort of what types are all about
15:20:25 <vixey> doesn't sound like progress
15:21:05 <Cale> Haskell has taken the approach that type inference is preserved whenever you're working in a large subset of the language, while allowing fancier features to locally demand that you give type signatures.
15:21:06 <halberd> yes but if you performed the analysis from an information theory perspective you could specifically say how much type checking information is necessary, given the programmer's propensity for error (as could be measured empirically)
15:21:36 <Cale> Some other languages with even stronger type systems lose type inference almost completely.
15:21:55 <halberd> a perfect programmer would need no type checking information to perfectly transcribe a program, a bad programmer would require more
15:22:07 <vixey> that's not why we have types
15:22:17 <dolio> What do you mean "how much type checking"?
15:22:30 <Cale> Of course, this ignores all the other reasons for types.
15:22:33 <dons> heh
15:22:36 <chrisdone> @hoogle b -> (a -> Bool) -> Either b a
15:22:37 <lambdabot> No matches, try a more general search
15:22:39 <halberd> well dolio there's a sliding scale in types
15:22:43 <dons> yeah, types: because we all suck.
15:22:53 <vixey> lol
15:22:53 <dons> only bad programmers use haskell
15:22:54 <dolio> Is Hindley-Milner 5 and Calculus of Constructions 10?
15:23:05 <Cale> One only has to look as far as typeclasses to see that types have other nice uses :)
15:23:07 <dons> and those theorem proving guys, don't get me started on how stupid they are.
15:23:08 <halberd> for example you could express, using dependent types, the fact that the square of the square root of something is the original value
15:23:11 <vixey> calculus of constructions is 11 :p
15:23:22 <Cale> dons: Well, in some sense, yes :)
15:23:24 <dolio> Bah, it doesn't even have strong sums. :)
15:23:25 <halberd> and that's adding extra type checking information beyond that required even by haskell
15:23:44 <halberd> so it's not just a binary decision between to use type checking or not to, you can also decide how much type information you want
15:23:52 <Cale> dons: There's nothing wrong with admitting that we'll inevitably make mistakes, and that's why we need to check or even prove that programs are correct :)
15:23:58 <vixey> halberd: it's not a continuum
15:24:20 <halberd> true it's not a continuum but it's not an either-or scenario, either
15:24:34 <vixey> I don't know what either-or means
15:24:41 <chrisdone> anyone got a name for this (a is default)? a -> (b -> Bool) -> Either a b
15:24:42 <dolio> dons: That's why all good programmers use C++.
15:24:45 <halberd> either-or means a binary decision, one choice or the other
15:24:46 <Cale> dons: you got me excited, I thought there was a *new* video about tangible values :)
15:25:39 <halberd> the evidence is that people CAN'T program without a high chance of errors, when they use languages with insufficient type information
15:25:50 <vixey> no
15:26:07 <vixey> most people just hack
15:26:13 <dolio> Yeah. Was that video not already on reddit?
15:26:16 <vixey> problems get fixed as they are encountered
15:26:25 <vixey> that's why there's bugs, it's not that people can't help it
15:26:37 <halberd> well alright
15:26:49 <vixey> there's no reason there should be any bugs in your code if we took a different approach to programming
15:26:56 <halberd> I'm going to make an article about it
15:27:02 <byorgey> chrisdone: do you mean  a -> b -> (b -> Bool) -> Either a b ?
15:27:07 <vixey> it's "harder" though, to do things right, because you can't just hack
15:27:15 <halberd> yes vixey
15:27:26 <vixey> that is, it seems harder
15:27:27 <chrisdone> byorgey: yeah I meant  a -> (b -> Bool) -> b -> Either a b
15:27:27 <byorgey> chrisdone: the way you have it doesn't make much sense, the only thing you could do would be to just apply Left to the first argument and ignore the second
15:27:38 <byorgey> ah, ok
15:27:49 <chrisdone> byorgey: sorry about that. got a name for it?
15:28:11 <dolio> I just don't know how you can quantify numerically how much information a type system has.
15:28:18 <chrisdone> byorgey: maybe “check”
15:28:20 <dolio> Or allows you to express.
15:28:23 <holmak> As a haskell newbie, I have to say haskell _feels_ a lot less productive when you sit and think about a foldl for 20 minutes before you write any code...
15:28:44 <vixey> dolio, well ... you can encode more functions in system F than STLC and more still in CoC
15:28:44 <dolio> Eventually you won't have to think about that.
15:28:54 <vixey> so we can probably say STLC < System F < CoC ?
15:29:04 <chrisdone> holmak: I don't think about foldl for more than a second
15:29:07 <dolio> Yeah, I understand you can order them in some ways.
15:29:49 <BMeph> holmak: Maybe you're...underestimating the value of thinking about what you're doing? ;)
15:30:08 <byorgey> holmak: you do also get faster at it the more you practice =)
15:30:22 <vixey> holmak: It really feels like you get a lot of work done typing out the same getter/setter patterns in java when you do it for the 60th time :p
15:30:38 <holmak> i agree that one line is haskell is as valuable as many lines of another language, but not typing instictively feels unproductive :p
15:30:40 <vixey> or writing out the same linked list implementation in C again
15:30:56 <vixey> you can tap out 100 lines without stopping in those languages
15:31:00 <vixey> 1000*
15:31:00 <chrisdone> I feel more productive in haskell (that's probably obvious or I wouldn't use it)
15:31:05 <mmorrow> holmak: like an instrument, once you don't have to think about your fingers or the notes/chords then you can play what you're thinking
15:31:08 <byorgey> chrisdone: yeah, I don't know of a name for that, or a nice way to write it with other combinators
15:31:51 <byorgey> chrisdone: 'check' sounds like a fine name
15:32:00 <chrisdone> byorgey: cool :)
15:32:06 <mmorrow> holmak: (to make that analogy work best, assume your improvising on that instrument)
15:32:17 <solrize> halberd, there have been some studies where bugs were introduced into a program intentionally in order to find out how effective testing was at finding them.  the answer was not very encouraging.
15:32:27 <byorgey> @type \a p b -> if (p b) then Right b else Left a
15:32:30 <lambdabot> forall b a. a -> (b -> Bool) -> b -> Either a b
15:32:36 <byorgey> @pl \a p b -> if (p b) then Right b else Left a
15:32:36 <lambdabot> flip (flip . (`ap` Right) . (if' .)) . Left
15:32:44 <holmak> i was actually thinking of something i was working on today: I couldn't find a standard function to split a string into a list of strings around a character and I was trying to figure out how to write one
15:32:51 <byorgey> as usual, @pl is useless here =)
15:32:56 <chrisdone> hehe, not so nice
15:32:58 <vixey> :t \b x y -> if b then Left x else Right y
15:32:58 <lambdabot> forall a b. Bool -> a -> b -> Either a b
15:33:21 <holmak> I had a feeling unfoldr might work, somehow, but i was stumped
15:33:27 <vixey> holmak: you should ask gwern about it :p
15:33:39 <byorgey> holmak: heh, that is probably the #1 most requested function that isn't in the standard libraries =)
15:34:03 <holmak> must be my python history showing
15:34:12 <Peaker> it could be cool if an automatic tool could find matches between code and stdlib functions - and use those functions instead of the isomorphic code
15:34:13 <vixey> hmmm
15:34:15 <Shiruka> solrize: any references?-) sounds interesting
15:34:18 <byorgey> holmak: the most straightforward way to implement it is using 'break' or 'span' with recursion
15:34:50 <byorgey> Peaker: IIRC, Helium (I think it was Helium?) does something like that
15:35:20 <vixey> Does anybody know what this indicates "Package contains no library to register: ghc-bin-6.9..."? I get it when doing make trying to build GHC
15:35:23 <byorgey> at any rate it was a teaching tool that had a big database of common patterns that could be simplified
15:35:29 <dons> Cale, i'd not realised conal had been to google to talk about it.
15:35:32 <holmak> i did find span, and im pretty sure i could do it with that, but from what i know about haskell, explicit recursion usually means you should be using map or fold or something - I was trying to figure out the fancy way
15:35:40 <solrize> shiruka i'd have to google around.  the purpose of the bug injection was mainly to figure out the effectiveness of the testing process on unknown bugs (i.e. if testing found 50% of intentional bugs and 143 untintentional bugs, that suggests that another 143 unintentional bugs remain in the program)
15:35:50 <byorgey> holmak: ah, fair enough =)
15:35:53 <chrisdone> byorgey: I can now express numeric :: Validator String -> Validator String as numeric = either Left (check "Not a number!" (all isDigit)), which is nice :)
15:35:57 <vixey> holmak: explicit recursion is fine
15:36:20 <holmak> I'm trying to work toward the whole "idiomatic haskell" thing
15:36:22 <vixey> holmak: operators like map and folds are only there to make it easier
15:36:59 <vixey> you don't want to rewrite zipWith as a fold just because it's possible
15:37:03 <byorgey> holmak: well, in that case, hm, I'd look at things like unfoldr and iterate
15:37:36 <holmak> i think i ran across a definition of python-style split with unfoldr on the interwebs, but it blew my mind
15:38:01 <chrisdone> dons: conal reminds me of kevin spacey :P
15:39:20 <vixey> :t unfoldr
15:39:21 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
15:39:33 <vixey> :t unfoldr ?f :: String -> [String]
15:39:37 <lambdabot> (?f::String -> Maybe (String, String)) => String -> [String]
15:39:48 <dons> chrisdone: hehe. weird.
15:40:21 <BMeph> I think a lot of the "hacker" appeal of dynamic languages, is that you substitute "playing around and seeing what works" for "carefully considering what you actually are trying to do, then write it out". :)
15:40:38 <hnoob> @src ($)
15:40:38 <lambdabot> f $ x = f x
15:40:42 <hnoob> @src (.)
15:40:42 <lambdabot> (f . g) x = f (g x)
15:40:42 <lambdabot> -- In lambdabot, it's been generalised to:
15:40:42 <lambdabot> (.) = fmap
15:40:58 <vixey> BMeph: You can do this in haskell too of course, types don't get in the way
15:41:07 <mmorrow> BMeph: i think you still "play around and see what works" the same, but without crashes :)
15:41:28 <Shiruka> um, dynamic languages don't really crash much..
15:41:41 <mmorrow> error: invalid argument to sum
15:41:50 <vixey> they do if you write programs that crash
15:41:51 <mmorrow> sum("asdf",9.2)
15:41:52 <chrisdone> yeah, you're playing with what is correct, rather than what happens not to error at the time I run it
15:41:55 <Shiruka> that's not a crash, a sigsegv or sigbus is a crash -)
15:42:06 <mmorrow> s/crash/runtime error/
15:42:10 <Shiruka> this isn't a crash either:
15:42:12 <Shiruka> > head []
15:42:13 <mmorrow> i consider them synonymous
15:42:14 <lambdabot>  Exception: Prelude.head: empty list
15:42:21 <mmorrow> don't use head
15:42:29 <mmorrow> :)
15:42:40 <BMeph> vixey: I imagine you CAN do it in any language with a short enough compile-run-type cycle. It's just that Haskell seems to reward direct thinking about what you want.
15:42:45 <Shiruka> avoiding all cases where you could get exceptions is too ascetic for me :-)
15:42:48 <sebaseba> don't use sum(string,...) :)
15:42:54 <vixey> :[
15:42:57 <vixey> I couldn't get GHC to work
15:43:01 <vixey> I mean compile
15:43:06 * vixey wonders what to do...
15:43:16 <chrisdone> where is Either's instance of Monad?
15:43:40 <vixey> TH in 6.8.2 works..
15:43:40 <yitz> chrisdone: Control.Monad.Error
15:43:43 <vixey> I think
15:43:44 <thoughtpolice> Control.Monad.Error?
15:43:46 <chrisdone> yitz: ah thanks
15:43:46 <mmorrow> Shiruka: ok ok, you got me, *but* all runtime errors in haskell (not caused by unsafeHaskell# functions) are caused by explicitly calling error "asdf"
15:44:09 <mmorrow> and if you ever call error, then you do so knowing that you're ending the program
15:44:16 <Shiruka> haskell does reduce the amount of runtime errors a lot, true
15:44:28 <dons> the risk of runtime error, too.
15:44:30 <mmorrow> @src head
15:44:30 <lambdabot> head (x:_) = x
15:44:30 <lambdabot> head []    = undefined
15:44:35 <mmorrow> @src undefined
15:44:35 <lambdabot> undefined =  error "Prelude.undefined"
15:44:38 <dons> since you can ensure particular classes of runtime error are ruled out.
15:44:39 <yitz> > fail "oops" :: [Int]
15:44:41 <lambdabot>  []
15:44:47 <dons> great for deploying code
15:44:51 <Shiruka> otoh you don't get tracebacks when you do get an exception :-(
15:44:56 <yitz> > fail "oops" :: IO Int
15:44:57 <lambdabot>  <IO Int>
15:45:16 <chrisdone> in the rare cases I've personally had exceptions, I know what line it's on and it's been easy to fix
15:45:47 <vixey> haha
15:45:53 <vixey>     Couldn't match expected type `[Pat]' against inferred type `Pat'
15:46:01 <vixey> I just pasted the code from a tutorial ...
15:46:10 <yitz> > fail "oops" :: State Int Int
15:46:20 <lambdabot>        add an instance declaration for (Show (State Int Int))
15:46:20 <BMeph> Would it really break things irreparably, if the GHC guys went ahead and reversed the order of certain definitions that are constantly complained about as being backwards (i.e., that Monads are not automatically Functors)? :)
15:46:22 <vixey> who wrote this http://www.haskell.org/bz/thdoc.htm ?
15:46:22 <lambdabot> Title: Template Haskell Documentation-
15:46:24 <Shiruka> > fail "epic"
15:46:26 <lambdabot>   add an instance declaration for (Show (m a))
15:46:53 <dons> BMeph: yes.
15:47:17 <mmorrow> Shiruka: and a key distinction is, haskell runtime errors are explicitly triggered by the programmer calling error, not by the runtime system realizing a type incompatibility then throwing an exception
15:47:34 <BMeph> dons: Has there been some effort to see whose programs break, and why specifically? :)
15:48:25 <Peaker> mmorrow: it may be triggered by the runtime system realizing a pattern match is missing, or by an "error" call embedded in a library function. So just one kind of runtime error (out of multiple) was eliminated?
15:48:27 <rwbarton> BMeph: Are you talking about class Functor m => Monad m where...?
15:48:44 <chrisdone> ghc encounters compile error -> uploads error to haskell.org -> haskell.org makes some statistics about common compile errors
15:48:47 <BMeph> rwbarton: That should be reversed, shouldn't it? :)
15:48:57 <rwbarton> I mean, that's what you're suggesting?
15:49:10 <rwbarton> That would break every program that tries to define an instance of Monad
15:49:11 <mmorrow> Peaker: that's true, but the compiler warns you about that possibility during compilation
15:49:24 <rwbarton> I agree that it's quite unfortunate :)
15:49:29 <Shiruka> mmorrow: I don't consider using "head" or incomplete patterns as explicitly calling error :-\
15:49:35 <mmorrow> Peaker: i'm counting error call embedded in a lib as "explicitly programmer triggered"
15:49:53 <Peaker> rwbarton: wouldn't it only break broken programs which don't have a Functor instance as well?
15:50:22 <Peaker> mmorrow: you could say that the various operators in a dynamic language are just library calls with embedded "isinstance" checks that explicitly call error?
15:50:34 <Peaker> mmorrow: and at least in Python, that's truly the case
15:51:02 <Peaker> (well, for some things)
15:51:05 <Shiruka> yeah, I don't like such a slippery slope definition of "explicit"..
15:51:11 <mmorrow> i see a big distinction between library code and code-which-implements-the-language-itself
15:51:39 <vixey> much more interesting things about types than avoiding crashes and bugs
15:51:44 <BMeph> rwbarton: The relationship goes the other way, though - if it's a Monad, then it's a Functor, but not necessarily the other way - and the same with comonads. (Comonads?)
15:51:44 <mmorrow> Peaker: in haskell you can simply change their definition if they don't suit you :)
15:51:58 <Peaker> mmorrow: the flat namespace of Haskell is awesome :)
15:52:13 <rwbarton> BMeph: That's true, but since Monad is in Haskell 98 and Functor is not, there are likely haskell programs out there that don't define the functor instance.
15:52:14 <Peaker> mmorrow: except for records, where everyone prefixes the record name into each field. That's horrible :)
15:52:32 <mmorrow> Peaker: heh
15:52:47 <rwbarton> BMeph: Right, hence class Functor m => Monad m (not instance Functor m => Monad m)
15:54:53 <sms__> can i hide an instance declaration when i import a module?
15:55:05 <mmorrow> sms__: unfirtunately not :(
15:55:09 <mmorrow> s/i/o/
15:55:28 <sms__> :-(
15:56:16 <BMeph> rwbarton: Maybe that's a problem with the class system: adding constraints to one class to place it in another doesn't automatically place the more constrained class' instances as instances of the "laxer" class.
15:57:10 <Peaker> BMeph: Class adapters (class instances of classes) could solve the problem.  People say overlapping instances are a problem, as they might have differing behavior, but I am not sure why that would ever be the case
15:57:13 <EvilTerran> sms__, you have to use a newtype or something for your new instance, unfortunately
15:57:40 <sms__> ok, i will try
15:57:49 <BMeph> rwbarton: And to be clear, I'm talking about (class Monad f => Functor f), not (class Functor m => class Monad m). :)
15:59:41 <rwbarton> I thought class Monad f => Functor f meant "in order to even think about making f a Functor, f must first be a Monad"
16:00:05 <chrisdone> when I use @let with λb it just terminates
16:00:07 <chrisdone> > check "Not a number." (all isDigit) $ "9"
16:00:07 <Peaker> BMeph: I think:  instance Functor Monad where fmap = liftM
16:00:08 <lambdabot> Terminated
16:03:33 <BMeph> rwbarton: I thought it was S(ufficient) => N(ecessary). I could be wrong in this case, as I am in so many others... :)
16:04:51 <BMeph> Peaker: So, is that how a Class adapter works - using a class as if it were a type of another class?
16:05:32 <Peaker> BMeph: That's how I'd have it work (a class as an instance of another class) :) I am not sure if there are insoluble problems with it though..
16:06:24 <shepheb> S =/> N: "is odd" suffices for a number to not be divisible by 8, but it is not necessary (see 2, 4)
16:06:49 <BMeph> Peaker: I'm not sure why, but it reminds me more of a type family, although I also don't think it fits that way.
16:06:50 <shepheb> er, dur
16:06:51 <shepheb> 10
16:07:00 <shepheb> wow, never mind me
16:07:16 <Cale> 2, 4 :)
16:07:30 <shepheb> well, yes, someewhat vacuously.
16:07:48 <Cale> 6 :)
16:08:50 <vixey> Can you derive lift :: t -> Q Exp for a custom type?
16:09:50 <Botje> simon(s) can!
16:10:37 <BMeph> (For shepheb's benefit): Er, how about (items on this side can be treated as something on the other side, and I'll tell you how...) => (items on this side work as if they were a subtype of tose on the other side, in this way...) where ...
16:10:51 <BMeph> s/tose/those/
16:11:24 <mmorrow> i really enjoyed conal's talk
16:11:28 <mmorrow> http://www.youtube.com/watch?v=faJ8N0giqzw
16:11:28 <lambdabot> Title: YouTube - Tangible Functional Programming
16:11:32 <mmorrow> just finished
16:12:39 <chrisdone> me too
16:12:56 <vixey> oh! You just derive Eq
16:13:24 <vixey> actually not quite
16:18:51 <mmorrow> at first i thought it worked this way, and i think it'd be cool, if  eg   instance (A a) => B a where ...  meant that  if type C a in an instance of A, then you get that it's an instance of B for free ("for free" by means of the previously defined instance (A a) => B a ...)
16:19:06 <EvilTerran> ... it doesn't work that way?
16:19:27 <mmorrow> ok, then i said it incorrectly
16:19:48 <mmorrow> because what i'm thinking of definitely isn't how it works
16:20:03 <mmorrow> rephrasing...
16:20:35 <mmorrow> EvilTerran: oh, of course. you're right
16:21:11 <mmorrow> class (A a) => B a where ...      means that    if type C a is an instance of A, then it's *automatically* also an instance of B
16:21:23 <EvilTerran> class Foo a where foo :: a -> Int; class Bar a where bar :: a -> String; instance Foo Char where foo = ord; instance Foo a => Bar a where bar = show.foo; main = bar 'A' -- this should work
16:21:25 <mmorrow> ie, the => mean implication
16:21:33 <EvilTerran> given -XUndecidableInstances
16:21:51 <EvilTerran> mmorrow, yes, the => in "class" declerations points the wrong way
16:21:54 <mmorrow> basically, what i'm trying to say..
16:21:58 <mmorrow> yes! exactly
16:22:06 <mmorrow> that's what i'm trying to say
16:22:29 <mmorrow> at first i thought it worked that way, and was confused for a while until i realized my mistake
16:23:02 <Peaker> I read "class Functor m => Monad m where ..." as: "given a type 'm' which is a Functor, it is also a Monad if it has..."
16:23:54 <mmorrow> whereas it really says "if m is an instance of Monad, then it must also be an instance of Functor"
16:24:13 <Peaker> that too
16:24:41 <mmorrow> hmm, are you saying they're equiv? if so, i misunderstood you
16:24:57 <BMeph> I.e., "=>" means "when", rather than "if". A-ha. :)
16:25:02 <mmorrow> because i read the above two statements as opposites
16:25:49 <mmorrow> (read as in the the present tense)
16:26:33 <BMeph> mmorrow: Hm? Converse, not opposite, surely? ;)
16:26:39 <mmorrow> yeah
16:27:01 <mmorrow> good catch
16:28:42 <vixey> hmf :|
16:29:42 <BMeph> I think that is why I <3 #haskell; as wrong as I am, I am occasionally right, but people still check to see if this is one of those times... ;)
16:32:16 <vixey> mmorrow: view patterns wouldn't allow you to bind variables though
16:32:29 <vixey> oh um, I meant guard |'s
16:32:41 <mmorrow> vixey: i don't really know anything about view patterns, but...
16:32:50 <vixey> I didn't mean view patterns
16:32:51 <mmorrow> oh, hmm i dunno about that
16:34:10 <vixey> Prelude> :t [d| f (x ++ y) = 1 |]
16:34:10 <vixey> <interactive>:1:7: Parse error in pattern
16:34:13 <vixey> :/
16:34:19 <vixey> I can't really do anything with TH
16:34:36 <mmorrow> i have to reconstruct/remember how i planned on using guards to do the regexqq pattern quotes, gimme a sec
16:35:36 <mmorrow> vixey: hmm, are you saying [d| f (x ++ y) = 1 |] should work?
16:35:37 * BMeph feels strangely sad when he hears about QQ discussions...
16:35:43 <vixey> no it shouldn't work
16:35:53 <vixey> it's just that I can't really do anything I wanted without QQ
16:36:01 <mmorrow> heh, i know!
16:36:10 <mmorrow> BMeph: hmm?
16:36:40 <BMeph> mmorrow: "QQ" is used to represent crying.
16:36:43 <EvilTerran> vixey, i'm guessing you want to make that work "by magic"?
16:37:07 <EvilTerran> even tho ++ isn't a constructor?
16:37:08 <mmorrow> BMeph: oh, i had no idea.
16:37:22 <mmorrow> ha, i just realized why
16:37:57 <mmorrow> (why as in how QQ is meant to rep that)
16:40:37 <lispy> Once upon a time I thought it was great when software would automatically find updates for you.  Now that every 3rd program on my computer does that and asks about it annoyingly and asks to restart, it sucks.
16:41:02 <lispy> ?vixen will the situation improve when haskell becomes mainstream?
16:41:03 <lambdabot> church is my favourite computer scientist.
16:41:19 <lispy> ?vixen yes, he was wonderul, but I feel like you're dodging my question
16:41:20 <lambdabot> you agree?
16:41:31 <mmorrow> vixey: yeah, you're right in the sense that you can't bind vars, *unless* you somehow provide a way to do so yourself via your quasiquoted lang's syntax
16:42:34 <lispy> vixey: TH is pretty cool.  But, what did you want to do?
16:43:09 <lispy> I'd show you my canonical cool example of TH but my blog is down.  I once used it plus the H98 parser to read some source code, modify it and then use it
16:43:14 <vixey> I'm trying to extend pattern matching a bit
16:43:25 <lispy> This was so that my test suite was one step closer to fully automated
16:43:35 <lispy> vixey: ah, interesting
16:43:55 <lispy> vixey: the approach taken by liskell might be more approriate
16:44:02 <lispy> vixey: what did you have in mind for your extension?
16:44:20 <lispy> vixey: liskell: http://clemens.endorphin.org/liskell
16:44:21 <lambdabot> Title: 28 Liskell - clemens.endorphin.org
16:44:22 <EvilTerran> f ("foo"++x) or whatever, wasn't it?
16:44:26 <EvilTerran> as a pattern
16:44:43 <lispy> So you want to add (++) as a valid pattern?
16:45:05 <EvilTerran> that was the impression i got from vixey
16:45:23 <lispy> This is contrasted with, I presume, f (['f', 'o', 'o']:x) ?
16:45:36 <EvilTerran> ('f':'o':'o':x), you mean
16:45:53 <lispy> > let f ("foo":x) = "bar" in f "foobar"
16:45:56 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
16:46:05 <lispy> oh right
16:46:10 <EvilTerran> or, the other way round, (x0:x1:x2:x3:"foo") ... where x = [x0,x1,x2,x3]
16:46:15 <lispy> I see why : instead of (++)
16:46:22 <vixey> lispy, (with different syntax), something like f (x ++ y) = (x,y) .. f "xyz" --> [("xyz",""),("xy","z"),("x","yz"),("","xyz")]
16:46:26 <BMeph> lispy: Do/did you use UUAGs? :)
16:46:45 <vixey> lispy, unless I get a better idea, then i'll try that instead
16:46:48 <EvilTerran> hm... built-in nondeterminism
16:46:53 <EvilTerran> we need monadic view patterns!
16:46:53 <lispy> BMeph: UUAG sounds familiar, what I don't recall using it...what are they again?
16:47:00 * vixey is just trying out QQ though
16:47:43 <BMeph> I think it's Utecht's enging to do Attribute Grammars, but I'm not completely sure about it.
16:48:03 <mmorrow> vixey: here's what i want to figure out how to do then do : http://hpaste.org/9211
16:48:17 <lispy> oh dear, f (x ++ y) = (x,y) seems problematic indeed.  Yes, non-determinism seems like the solution.
16:48:46 <lispy> BMeph: that sounds right.  No I didn't play with UUAGs.  Why did you ask?
16:48:56 <lispy> Was I curious about them at some point?
16:49:16 <EvilTerran> i could imagine some kind of invertibility thing you could write
16:50:14 <BMeph> lispy: I was just trying to find someone that had enough experience to say if they helped with any problems. Now, I'm just trying to find anyone that's ever dabbled with them. :)
16:50:28 <vixey> mmorrow: for the meta QQ thing you posted?
16:50:38 <vixey> mmorrow: actually I'm not sure what you mean
16:50:47 <lispy> BMeph: for some reason, I think Pseudonym would know about them or maybe Philippa...
16:51:01 <mmorrow> vixey: yeah, for that
16:51:16 <BMeph> lispy: Hmm, I'll try asking earlier in the day, then... :)
16:51:21 <mmorrow> vixey: i'll elaborate in a paste...
16:51:27 <lispy> BMeph: You need someone with advanced obscure knowledge/skills :)
16:51:56 <BMeph> lispy: On that note, maybe I'll ask ddarius... >;)
16:52:20 <vixey> (will be back in a min..)
16:53:57 <mmorrow> vixey: does this make it clearer? http://hpaste.org/9211#a2
16:54:13 <mmorrow> vixey: if not, then what part of it should i explain more?
16:54:15 <lispy> BMeph: oh, good bet actually
16:54:25 <mmorrow> oops, forgot a $ in the first paste..
16:54:31 <lispy> BMeph: and I wouldn't be surprised if dons and Cale both know a think or two about it
16:54:36 <BMeph> lispy: Heh-heh. :)
16:55:17 <mmorrow> vixey: correction to initial paste: http://hpaste.org/9211#a3
16:57:53 * EvilTerran envisages something like "[] ++ ys = ys; (x:xs) ++ ys = x : (xs ++ yS); invert zs = xs ++ ys where xs = {- can't be bothered to work this out -}; ys = fromJust (stripPrefix xs zs)
16:58:23 <ulfdoz> so, Gute Nacht
16:58:42 <ulfdoz> ECHAN, sorry but however Good Night.
16:59:32 <dons> rock out, http://www.reddit.com/comments/6tvec/haskell_batteries_included/
16:59:33 <lambdabot> Title: Haskell: Batteries Included : reddit.com
17:01:12 <mmorrow> dons: exciting
17:01:20 <dons> let's do this!
17:01:23 <lispy> dons: is there more detailed information yet about the HP?
17:01:35 <lispy> oh, I'm silly
17:01:36 * mmorrow begins to read
17:01:38 <dons> there's more in the proposal. and   we've got a prototype working
17:01:38 <lispy> just click the words
17:01:53 <dons> the plan is to build and demo some code live using the system during the HW
17:03:09 <lispy> dons: will you address the issue with Haskell on debian, eg., They build each library so that it's in a seperate package.  So to build, say darcs, you have to download what seems like extra packages but are things that are included with ghc if you install ghc from the main ghc website.
17:03:39 <dons> right.
17:03:59 <lispy> (debian could be smarter by having a meta package that grabs the HP collection of packages)
17:04:05 <dons> that's the idea.
17:04:36 <dons> good reason to use Arch, btw, http://aur.archlinux.org/packages.php?O=0&L=0&C=0&K=arch-haskell&SB=v&SO=d&PP=100&SeB=m&do_Orphans=
17:04:37 <lambdabot> Title: AUR (en) - Search: arch-haskell, http://tinyurl.com/5a3rtx
17:04:39 <dons> if you're into native packages.
17:04:45 <dons> developers don't care though
17:04:53 <dons> since we just use cabal-install
17:05:15 <lispy> Ahem, cabal-install is not easy to get going with yet
17:05:25 <dons> well, for developers it is.
17:05:29 <dons> for end  users distro packages
17:05:57 <lispy> I certainly love cabal-install, once it's deps are met and it's installed
17:06:05 <lispy> But, I recall not liking that part at all :)
17:06:16 <Shiruka> heh, installing it is the hardest part indeed :-)
17:06:21 <Shiruka> though not spectacularly hard
17:06:26 <Shiruka> (at least on ubuntu)
17:06:59 <dons> so that's one of the core tools in the platform.
17:07:00 <lispy> dons: how will HP work with windows?
17:07:09 <dons> you'll get an installer and a source bundle
17:07:14 <dons> maybe an install and a binary
17:07:47 <lispy> This will be interesting.
17:07:56 <dons> yeah. let's take over the freaking world already!
17:08:01 <dcoutts> @yarr!
17:08:01 <lambdabot> Gangway!
17:08:13 <lispy> I wish we could get this kind of steam behind darcs, sadly I thnk more and more people are switching away from darcs these days.
17:08:52 <bos> a windows and mac installer for cabal-install will be majorly FTW.
17:09:09 <dcoutts> the windows installer I can do
17:09:22 <dcoutts> though I'd prefer it if cabal-install could upgrade itself on windows
17:09:23 <dons> there's this mkbndl program for the mac on hackage
17:09:30 <dons> i wonder if it creates those .dmg files
17:09:53 <lispy> dons: I haven't tried it, but I think it does
17:09:58 <dcoutts> sadly, exes cannot overwrite their own .exe file very easily on windows
17:10:21 <lispy> dcoutts: and likely any code that does gets marked as a virus these days?
17:10:54 <hexpuem> virus scanners dont detect stuff too good usually
17:11:03 <dcoutts> lispy: heh, no I don't think so, some progs (like virus scanners) need to upgrade themselves
17:11:08 <hexpuem> for .dlls you can just unlink the entry from the process environment block
17:11:13 <hexpuem> and the lock goes away
17:11:18 <hexpuem> not sure what the side effects are though
17:11:37 * BMeph always thinks of "damage" when .dmg files are discusssed...
17:12:26 <lispy> dons: oh wait, app bundles are different
17:12:39 <lispy> dons: mkbndl is not what I was thinking of
17:13:22 <lispy> dons: a .dmg is really like a .iso or similar...just a mac filesystem in one file
17:13:44 <dons> dcoutts: i'd love the HP to be the next "standard", following the hier libs, FFI and cabal/library proposal.
17:13:50 <lispy> dons: but an app bundle is an abstraction that makes a directory structure appear to be an "executable" file
17:14:11 <dcoutts> dons: I'm not sure what there is to standardise, it's a process not a thing
17:14:27 <lispy> app bundles are a nice way to distribute your application as "one file"
17:14:29 <dons> hence "standard" in the sense of "let's do this"
17:14:44 <dons> i like those kind of standards :)
17:15:01 <dcoutts> heh
17:25:31 <lispy> Has anyone here seen academic papers using phantom types in mainstream languages like C++/Java/C# or used them that way personally?
17:25:56 <mauke> where is my alexandrescu
17:26:36 <lispy> I would be interested in discussions of what you need, (or are generics/parametric polymorphism enough) to have useful phantom types?
17:26:53 <lispy> mauke: the advanced modern C++ book?
17:27:15 <lispy> I have that in hand :)
17:27:35 <lispy> actually I guess the title is just "modern C++ design"
17:28:15 <lispy> I don't recall that author discussing phantom types
17:28:24 <sarehu> lispy I've used it personally...
17:28:34 <mauke> "Policy-based design"
17:28:55 <mauke> hmm, not really phantom though
17:28:56 <lispy> mauke: Oh hrm...I should reread the chapter it's been a while
17:29:07 <dolio> In C++ you'd probably write an enum and use its 'dependent typing', no?
17:29:22 <lispy> sarehu: was it worthwhile?  I know in Haskell it's useful, but I wonder about the pragmatics of it outside of Haskell
17:29:44 <lispy> dolio: please explain.
17:30:08 <EvilTerran> C++ templates can be parameterised by values as wel las types
17:30:12 <EvilTerran> so you don't need dependent types
17:30:18 <ptolomy2> Oh.
17:30:18 <EvilTerran> ish
17:30:29 <ptolomy2> I've used phantom types in C++ for work.
17:30:37 <dolio> lispy: Instead of making new types 'data Foo ; data Bar ; data Baz ...' you'd do something like 'enum { foo, bar, baz } phantom' (forget actual syntax) and then do 'template <phantom T> ...'
17:30:39 <EvilTerran> er, phantom types, rather
17:30:39 <sarehu> lispy: yes... pretty much the only mainstream language I can do good software design is C++
17:30:46 <EvilTerran> because you do kinda have dependent types
17:31:03 <lispy> my motivation: I want to explain to my dev group at work, why phantom types are useful for us when hosting dsls in another language while we work
17:31:42 <Pseudonym> I've also used phantom types in C++.
17:31:45 <lispy> dolio: okay
17:31:48 <Pseudonym> It's how you do newtype.
17:31:56 <Pseudonym> For example.
17:32:15 <Pseudonym> It'd be nice if C++ had the same performance guarantees as Haskell's newtype.
17:32:25 <lispy> dolio: that's one way to implement policies, right?
17:32:36 <hml> what performange guarantees does haskell's newtype provice?
17:32:55 <lispy> Pseudonym: can you make this a bit more concrete, not sure I follow
17:32:56 <Pseudonym> hml: newtype Foo = Foo Int has the same representation internally as Int.
17:33:07 <dolio> lispy: I'm not enough of a C++ man to know what that means.
17:33:22 <Pseudonym> Consider this in C++:
17:33:26 <hml> Pseudonym: so the 'performange guarantee' is just one of 'no  overhead' ?
17:33:27 <Pseudonym> struct tag_type;
17:33:32 <Pseudonym> Yes.
17:33:34 <erikc> evilterran: unfortunately, you can only use integer types as template parameters in c++
17:33:46 <Pseudonym> template<typename Tag> wrapped_int { int m_value; }
17:33:59 <Pseudonym> It'd be nice if you could guarantee that this is passed, say, in a register.
17:34:01 <Eelis> erikc: and pointers and references (to objects with extern linkage)
17:34:14 <Eelis> (or functions)
17:34:22 <pejo> lispy, are you looking for papers using phantom types, or do you want papers that specifically use them for C++/Java/etc?
17:34:24 <ptolomy2> Last time I checked in GCC, a simple class that wrapped an int compiled down to just an int.
17:34:43 <ptolomy2> but I only checked some basic uses.
17:34:45 <Pseudonym> ptolomy: That's nice if you're using GCC.
17:35:05 <Pseudonym> And it's not guaranteed, IIRC, if you nest the wrapping.
17:37:04 <erikc> its not guaranteed
17:37:05 <lispy> pejo: Well, I have some non-C++/Java examples, so I was looking for more mainstream examlpse
17:37:26 <Pseudonym> Incidentally, this is one of the nicest things about Haskell.  Abstraction is cheap.
17:37:29 <erikc> it makes a huge different for SSE/VMX/SPU wrapper types too, cause people typically want to wrap those in a Vector/Dir/Point class
17:37:34 <Pseudonym> Both for the programmer and at run-time.
17:37:43 <dolio> lispy: In wikipedia's example of policy-based design, the type parameters don't appear to be phantom.
17:37:45 <Pseudonym> erikc: Yeah, I can imagine that.
17:37:55 <Pseudonym> The only solution would be template specialisation hell.
17:38:06 <hml> so 'phantom' type means that it existsx at compile time but not run time?
17:38:24 <Pseudonym> hml: A phantom type is one that doesn't have a value associated with it.
17:38:36 <pejo> Pseudynym, so Intel needs to employ ndm?
17:38:37 <Pseudonym> More or less.
17:39:02 <Pseudonym> What is ndm doing these days?
17:39:17 <Pseudonym> Wasn't he responsible for "explicit"?
17:39:19 <pejo> Pseudo, gsoc on hoogle.
17:39:26 <Pseudonym> Oh, right.
17:39:28 <Pseudonym> Different ndm.
17:39:38 <Pseudonym> There's a Haskell ndm and a C++ ndm.
17:39:48 <erikc> gcc on darwin had extensions so you can put an attribute flag on a struct so it would be passed in registers
17:39:53 <erikc> which was great for tuple structs
17:39:55 <pejo> Oh, heh, sorry about that. I meant the supero one, since you mentioned specialization.
17:40:03 <Eelis> Pseudonym: i'm reading that List.genericLength is less efficient than length. is that an example of abstraction being _not_ cheap in Haskell?
17:40:49 <Pseudonym> Eelis: Generalisation isn't cheap necessarily.
17:40:56 <Pseudonym> Though you have the SPECIALIZE pragma.
17:41:13 <ptolomy2> Abstraction is cheap in haskell, but concretion can be tricky.
17:41:26 <chrisdone> :t if'
17:41:28 <gwern> :t Data.Set.toList . Data.Set.fromList
17:41:29 <lambdabot> forall a. (Ord a) => [a] -> [a]
17:41:31 <Eelis> Pseudonym: in C++, a generic version is not slower than a specialized version, because the former are simply instantiated to yield the latter
17:41:36 <lispy> dolio: okay, then maybe that's not a good example.  I think you could use the phantom + template specializion to do policies, but not in the way that policies are meant to be done
17:42:03 <Pseudonym> Oh< i was thinking of ncm.
17:42:07 <vixey> what time does typeclass dispatch happen?
17:42:10 <vixey> I thought it was compile time
17:42:13 <Pseudonym> Eelis: But in C++, you pay for it in flexibility.
17:42:17 <gwern> :t nub
17:42:18 <lambdabot> forall a. (Eq a) => [a] -> [a]
17:42:51 <Pseudonym> Essentially, C++ templates are Haskell parametric polymorphism where you _require_ a SPECIALIZE.
17:42:54 <mmorrow> Eelis: anytime the abstraction still exists at runtime :)
17:42:57 <ptolomy2> vixey: Compile-time when possible, runtime for rest.
17:43:07 <Pseudonym> The C++ guy I was thinking of was ncm.
17:43:10 <Pseudonym> Nathan Myers.
17:43:12 <vixey> when is it not possible?
17:43:22 <mauke> vixey: separate compilation
17:43:32 <EvilTerran> also existentials and such can cause it, iirc
17:43:39 <mauke> polymorphic recursion
17:44:36 <erikc> D's typedef is haskell's newtype, D's alias is haskell's type/C++'s typedef
17:44:58 <ptolomy2> Hm. Good for D. That's a nice way.
17:45:07 <chrisdone> > let bool p c e val = if p val then c val else e val; f = bool (==2) (+3) (*3) in (f 2,f 3)
17:45:08 <lambdabot>  (5,9)
17:45:11 <mmorrow> polymorphic recursion is always ftw
17:45:15 <mauke> yes, let's change the meaning of "typedef"
17:45:22 <chrisdone> :t \p c e val = if p val then c val else e val
17:46:22 <chrisdone> @vixen lambdabot you are rubbish at the stuff
17:46:22 <lambdabot> So, tell me your biggest and darkest secret. Something that no one knows of you.
17:46:46 <lispy> I think the example I will present to my dev group is one of generating SQL queries (something we do a lot of) or excel formulas in one language, say C#, and I'll use phantom types to show that you can lift some compile time constraints, like type checks, into the host language via phantom types ala http://citeseer.ist.psu.edu/leijen99domain.html
17:46:47 <lambdabot> Title: Domain Specific Embedded Compilers - Leijen, Meijer (ResearchIndex)
17:49:50 <lispy> I think I can basically just mimic the leijen paper in C#, but I thought I'd check if other people have success stories and the like
17:50:00 <lispy> thanks guys
17:51:12 <chrisdone> byorgey: bool = \p c e val -> if p val then c val else e val => check a p = bool p Right (Left . a)
17:51:19 <Trinithis> is there an 'until' for monads?
17:51:20 <Eelis> lispy: in a way, Boost.MPL is one big orgy of phantom types
17:51:37 <chrisdone> @hoogle untilM
17:51:37 <lambdabot> No matches found
17:54:18 <chrisdone> can we add if' and bool to Data.Bool?
17:55:03 <mmorrow> vixey: http://hpaste.org/9211#a4
17:55:58 <lispy> chrisdone: I think Data.Function might be a better place for if'
17:56:13 <lispy> chrisdone: BTW, there is a standard procedure these days for sumbissions like this
17:56:13 <vixey> Data.Bool
17:56:28 <chrisdone> but if' specifically deals with Bool
17:56:45 <dolio> I'd just drop if'.
17:57:22 <chrisdone> @pl \p c e -> if p then c else e
17:57:23 <lambdabot> if'
17:57:24 <lispy> chrisdone: I forget the gist, but I think it involves sending in a patch and waiting 1 week for objections then having someone apply it (roughly)
17:58:09 <chrisdone> I see
17:58:18 <lispy> chrisdone: Another cool option would be to create operators such that, foo = blah ? (a,b), works like it does in C
17:58:41 <lispy> well, foo = blah ? a : b; is C syntax, and I'll leave the operator names up to you
17:58:42 <chrisdone> oh, good point
17:58:52 <jeffwheeler> lispy: I think there's an example like that in the if' proposal on the wiki
18:00:04 <lispy> > let (?) b (c, e) = if b then c else e in True ? (1, 2)
18:00:06 <lambdabot>  1
18:00:06 <chrisdone> > let a ? b = (\p -> if p then a else b) in (1 ? 2) False
18:00:07 <lambdabot>  2
18:00:16 <jeffwheeler> Yeah: http://www.haskell.org/haskellwiki/If-then-else
18:00:17 <jeffwheeler> 2.2
18:00:18 <lambdabot> Title: If-then-else - HaskellWiki
18:00:18 <chrisdone> hehe
18:00:26 <Trinithis> if' would be nice in the Prelude imo
18:00:29 <vixey> data Syntax a b = a :|: b
18:00:29 <vixey> infix 8 ?
18:00:29 <vixey> True ? x :|: _ = x
18:00:29 <vixey> False ? _ :|: x = x
18:00:36 <vixey> *Main> True ? 1 :|: 2
18:00:37 <vixey> 1
18:00:48 <lispy> Trinithis: yes, and Data.Bool would be the next best thing
18:00:58 <vixey> :t maybe
18:00:58 <lispy> vixey: ah, that's nice
18:00:58 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
18:00:58 <vixey> :t either
18:00:58 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
18:01:06 <vixey> bool :: a -> a -> Bool -> a
18:01:43 <lispy> IMO the ternery operator in C is both one of the coolest C operators and also one of the most obfuscating :)
18:02:07 * vixey likes •[•] because it doesn't matter which way around you put them
18:02:30 <Spark> ?: is just an if expression
18:02:30 <lambdabot> Maybe you meant: . ? @ v
18:02:35 <lispy> vixey: ah yeah, that one is interesting.  I've often wondered what inspired them to end up with that
18:02:36 <Spark> i don't see what the big deal is
18:02:48 <dolio> I think one guy has insitgated like 90% of the traffic on comp.lang.haskell for the past month. :)
18:03:25 <vixey> lispy: my guess is it's a coindicidence, but I couldn't be sure
18:03:37 <EvilTerran> i prefer the form "True <? x = return x; False <? x = mzero; Nothing ?> y = y; Just x ?> y = x"
18:03:51 <Spark> array[index] is a legacy syntax i think
18:04:02 <EvilTerran> there may be a more general way of writing ?> there
18:04:12 <Spark> since they wanted pointer arithmetic it made sense to desugar [] into that
18:04:12 <Trinithis> lispy: ?: or if'?
18:04:19 <lispy> vixey: Well, I think it has to do with the name of the array being equivalent (more or less) to the starting address, so *[*] really just means add the two together to get the address
18:04:21 <EvilTerran> to go with using any Monad for <?
18:05:03 <mauke> lispy: it's not the name of the array :-(
18:05:04 <lispy> Trinithis: sorry, what is the question?
18:05:27 <Trinithis> C ternary operator syntax vs if' syntax
18:05:28 <Spark> i wonder if the [] desugaring is applied before or after type checking
18:05:44 <EvilTerran> Spark, in C? usually after, i think
18:05:47 <mauke> Spark: does it matter?
18:05:49 <Spark> because you could easily cook up a special type rule for [] that required the lhs to be an array and the rhs to bea n int
18:06:00 <Spark> ...to be an int
18:06:02 <EvilTerran> in that you get a warning with -Wall about swapping a pointer and an integer type
18:06:13 <Spark> right
18:06:22 <Spark> you get a warning for 10+ptr but not ptr+10 ?
18:06:32 <mauke> EvilTerran: I do?
18:06:41 <mauke> since when?
18:06:49 <EvilTerran> i mean you get a warning for 10[ptr] but not for ptr[10] with -Wall
18:07:00 <EvilTerran> at least on the compiler i used most recently
18:07:10 <EvilTerran> (well, did that on mostrecently)
18:07:22 <mauke> not gcc
18:07:27 <Trinithis> is it possible to do something equivalent to a pattern match on mzero?
18:07:39 <Spark> EvilTerran: what if you desugar it manually
18:07:42 <EvilTerran> Trinithis, kinda
18:07:59 <Trinithis> with Eq? or something better?
18:08:00 <EvilTerran> Spark, then *(10+p) and *(p+10) should both work, i think
18:08:16 <Spark> ah right so it does treat the [] specially
18:08:28 * Spark goes to check
18:08:30 <lispy> Trinithis: I think if' would be handy, and I suppose that if we add if' people will later ask if we have a ternary operator equivalent.  so might as well add both :)
18:08:45 <EvilTerran> Trinithis, something like "\mightBeMzero ifItsNot ifItIs -> (mightBeMzero >> ifItsNot) <|> ifItIs"
18:08:54 <Trinithis> lispy: is there a difference? They seem equivalent
18:08:57 <EvilTerran> but you can't get out of the monad doing that
18:09:09 <chrisdone> coming from lisp with (if p c e) I was really surprised that haskell didn't just have a function (if p c e) instead of the, imho, OTT `if then else crap'. reminds me of `define f' in other langs. (what's the point in having the “define” word?)
18:09:29 <Spark> hmm i don't get any warnings at all
18:09:31 <dobblego> if' allows better composition, for example, partial application
18:09:43 <lispy> > let if' b c e = if b then c else c in True `if'` {- what goes here? -} 1 2
18:09:44 <lambdabot>   add an instance declaration for (Num (t -> t1))
18:09:48 <Spark> with "gcc -g -Wall -Wextra -std=c99 -pedantic"
18:09:59 <EvilTerran> but ternary ops, appropriately defined, are useful in other ways
18:10:10 <EvilTerran> Spark, oh well, it might just've been a quirk of my compiler
18:10:27 <jeffwheeler> if' makes a lot more sense, but it loses the simple verbosity of if-then-else, which is always clear where each branch is
18:10:27 <Spark> there may be a -W flag for it
18:10:53 <dobblego> jeffwheeler, write then/else functions then
18:11:07 <EvilTerran> for instance, the operators in "True <? x = Just x; False <? x = Nothing; Just x ?> y = x; Nothing ?> y = y", with appropriate fixities, are useful elsewhere
18:11:23 <lispy> I don't think the beauty of if' is in writing it into a function definition.  No, I think it's useful has a function param instead of constructing it as a lambda from if-then-else whenever you need it
18:11:36 <augustss> Hello from Ulaan Bataar!
18:11:47 <lispy> Hello augustss
18:11:53 <EvilTerran> i frequently want something like <? without faffing around with guard and >>
18:11:57 <dobblego> > let if' b c e = if b then c else c; then' = id; else' = id in if' True then' 7 else' 8
18:11:58 <lambdabot>  8
18:12:02 <Spark> the "if", "then" and "else" are essentially just special parentheses
18:12:07 <EvilTerran> and (?>) = flip fromMaybe
18:12:09 <chrisdone> imho “if b c e = case b of True -> c; _ -> e” and “bool p c e v = case b v of True -> c v; _ -> e v” would've been better
18:12:12 <jeffwheeler> dobblego: that could be done, although it seems weird -- two unnecessary functions that just are id
18:12:16 <lispy> dobblego: hah, cute
18:12:28 <dobblego> jeffwheeler, exactly my point; it doesn't make it clearer at all - quite the opposite
18:12:50 <dobblego> jeffwheeler, (though if you insist on "making it clearer", you can always "make it clearer" by adding redundant (?) functions)
18:12:54 <chrisdone> lispy: right
18:13:01 <EvilTerran> and fromMaybe is frequently useful
18:13:17 <chrisdone> heh, fromMaybe = flip maybe id
18:13:19 <jeffwheeler> dobblego: exactly; I just worry about it becoming significantly harder to read without them
18:13:32 <Trinithis> lispy: "True `if'` {- what goes here? -} 1 2" thx for the example
18:13:34 <chrisdone> `maybe id' is nearly as short as `fromMaybe'
18:13:34 <jeffwheeler> dobblego: I don't know if that would occur or not; we could only tell with experience
18:13:49 <chrisdone> whoops, ignore that
18:14:14 <dobblego> jeffwheeler, then, you're also worrying that not having redundant functions equivalent to id would hinder readability
18:14:26 <lispy> What we really need is branch :: Bool -> (a -> b) -> (a -> b) -> a -> b
18:14:40 <vixey> :t liftM2 if'
18:14:43 <jeffwheeler> dobblego: exactly --- I'm not sure what the best solution is
18:14:51 <vixey> hm
18:14:52 <lispy> (I was being sarcastic BTW)
18:15:02 <chrisdone> lispy: pretty I defined something similar above
18:15:24 <dobblego> jeffwheeler, let people who insist on redundant functions to keep writing them so that others - like myself - don't have to incur a cost
18:15:27 <chrisdone> vixey: if' doesn't seem to be in scope in λb for some reason (even though it is in @pl)
18:15:53 <chrisdone> or maybe it's just the @type function being weird
18:15:56 <jeffwheeler> dobblego: that very well may be the solution Haskell goes with
18:16:55 <Trinithis> should MonadZero/MonadPlus class have a fromMzero function?
18:17:38 <lispy> There is certainly a limit to the usefulness of redundant functions, but likewise, having a minimal set is not good.  So, this is the part where we do the heuristics and try to find a happy point where it works for most people
18:18:39 <lispy> But, I think when many people arrive at almost identical functions it's safe to make a canonical version and put it in the standard libs
18:18:49 <Trinithis> nvm anyway. Not all monads can extract values
18:19:34 <chrisdone> I brought this up because I have either Left (\x -> if p x then Right x else Left (e x)), with my definition above it could be either Left (bool p Right (Left . e)). I guess it's not that much shorter
18:20:17 <dobblego> chrisdone, I have functions that do that for Scala; if Haskell lacks them, I'd write them
18:20:17 <chrisdone> lispy: like chunks
18:20:25 <lispy> Yeah, and it's a bit harder to think about that second one, IMO
18:20:39 <lispy> chrisdone: what is chunks?
18:20:43 <lispy> :src chunks
18:20:48 <lispy> ?src chunks
18:20:48 <lambdabot> Source not found.
18:20:57 <chrisdone> lispy: I guess it is. it came very naturally to me that I just started writing bool straight-away, but I guess it could be needlessly confusing
18:20:58 <lispy> chrisdone: or is that words?
18:21:17 <chrisdone> it's like words but where you specify what character to split at
18:21:23 <vixey> where is ghci?
18:21:31 <lispy> chrisdone: passing (Left . e) is actually the worst part to me.  I know what it means, but it takes me a second
18:21:33 <chrisdone> or
18:21:35 <vixey> I just did make but I can't find it
18:21:47 <chrisdone> sorry, chunks :: Int -> [a] -> [[a]], IIRC
18:22:40 <lispy> chunks :: Eq a => a -> [a] -> [[a]], chunkBy :: (a -> Bool) -> [a] -> [[a]], those are roughly what I would expect in Haskell
18:22:55 <lispy> chunk = chunkBy (==)
18:23:07 <vixey> chunks :: Integer -> [a] -> [[a]]
18:23:11 <chrisdone> splitWith, perhaps
18:23:24 <lispy> ?hoogle splitWith
18:23:25 <lambdabot> Data.ByteString.splitWith :: (Word8 -> Bool) -> ByteString -> [ByteString]
18:23:25 <lambdabot> Data.ByteString.Char8.splitWith :: (Char -> Bool) -> ByteString -> [ByteString]
18:23:25 <lambdabot> Data.ByteString.Lazy.splitWith :: (Word8 -> Bool) -> ByteString -> [ByteString]
18:23:31 <lispy> Oh, and look, BS has it :)
18:23:37 <lispy> neat
18:23:40 <chrisdone> but list doesn't ;_;
18:23:53 <gwern> the split functions are like bad pennies; they just keep showing up
18:23:56 <lispy> Time to improve Data.List then :)
18:24:03 <chrisdone> gwern: heh, yeah. all kinds
18:24:19 <lispy> gwern: if I had more time I'd ask why you don't like split functions
18:24:41 <chrisdone> gwern: other day like three people had asked for fairly similar ones that day. I was like "pfft" and then later on I needed one :<
18:24:41 <lispy> gwern: or does your statement not mean to imply dislike?
18:24:51 <gwern> lispy: frustration trying to get them into data.list
18:25:06 <lispy> gwern: you need a PR person for your patches....
18:25:11 <dobblego> they should be in Traversable
18:25:19 <chrisdone> why?
18:25:37 <gwern> see! that's why I mean
18:25:39 <lispy> gwern: You're doing good work, but I've seen some of it get rejected when it could have worked :)
18:25:41 <gwern> everyone has different ideas
18:25:52 <dobblego> my idea is not different, just a superset :)
18:25:55 <lispy> and now I'm gone
18:26:06 <chrisdone> bye lispy
18:26:18 <gwern> dobblego: that's some fine painting there on that dogshed :)
18:26:50 <dolio> What should be in Traversable?
18:26:55 <gwern> I mean, what would traversable even gain us?
18:27:04 <chrisdone> dolio: split functions
18:27:10 <vixey> ugh
18:27:14 <dolio> How is that even supposed to work?
18:27:21 <chrisdone> dolio: no idea
18:28:09 <chrisdone> my GOA works ace. who else is using GOA?
18:29:58 <chrisdone> C-l C-c and C-c C-t, and GOA, so sweet. I don't miss SLIME anymore
18:35:56 <vixey> @quote no.place
18:35:56 <lambdabot> No quotes match. Do you think like you type?
18:39:10 <chrisdone> (&) :: Validation a b -> Validation b c -> Validation a c
18:39:11 <chrisdone> x & y = either Left (y . Right) . x
18:39:15 <chrisdone> kind looks like an arrow
18:39:36 <chrisdone> & == >>>
18:39:36 <chrisdone> hmm
18:39:37 <bd_> It's a category, isn't it?
18:39:44 <chrisdone> is it?
18:39:53 <dolio> Is there an identity?
18:40:28 <chrisdone> type Validation a b = Validate a -> Validate b
18:40:28 <chrisdone> type Validate a = Either String a
18:40:32 <chrisdone> is there?
18:40:47 <dolio> Hmm...
18:40:47 <bd_> it looks like there ought to be
18:41:02 <bd_> id :: Validation a a
18:41:12 <vixey> how do you run ghci?
18:41:29 <bd_> vixey: like this:
18:41:30 <bd_> ghci
18:41:31 <bd_> :)
18:41:37 <dolio> id = id? :)
18:41:38 <chrisdone> vixey: was it a local or global install
18:41:49 <chrisdone> dolio: I think it probably would be?
18:41:52 <vixey> I didboot ./configure make
18:41:55 <vixey> so I compiled it
18:42:02 <vixey> now ho w do you run it without installing/
18:42:04 <vixey> ?
18:42:07 <chrisdone> is it in dist?
18:42:50 <dolio> id . f = f . id = f is trivially true, since id is the identity on functions (which is what a Validation is).
18:43:44 <dolio> It's probably an arrow, too...
18:43:51 <dolio> arr = fmap
18:43:54 <chrisdone> dolio: so if there is f :: Validation a b, is that arr f = f?
18:44:32 <chrisdone> hm
18:44:40 <bd_> :t arr
18:44:42 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
18:45:02 <chrisdone> I've only seen arrows for (->) so I'm hazy on how arr works for anything else
18:45:09 <dolio> first f = fmap (f *** id)
18:45:26 <vixey> ./compiler/ghc-inplace
18:45:26 <vixey> works
18:45:27 <chrisdone> isn't *** defined in terms of first? :P
18:45:28 <TomMD> So i'm currently looking at uniplate thinking it can provide a Haskell equivalent to __func__ in C.  Am I on the right track?
18:45:30 <vixey> but where is ghci?
18:45:41 <dolio> chrisdone: It's a different ***.
18:45:46 <chrisdone> dolio: oh I see
18:45:59 <dolio> It's defining first on Validations, but using (***) on functions.
18:46:11 <dolio> Actually, that's just fmap first.
18:46:24 <dolio> Er, fmap . first.
18:47:24 <chrisdone> so in what way could I use it as an arrow? “(someValidation >>> anotherValidation) value”?
18:47:35 <dolio> Anyhow, those are type correct, anyway. I don't know if they satisfy all the arrow laws.
18:48:02 <chrisdone> I don't see the arrow laws on the docs page. let me pull up the original paper
18:49:46 <chrisdone> dolio: is mine equvilant to the Stream arrow?
18:50:25 <dolio> I don't think so. That has streams underneath.
18:51:24 <dolio> Yours is some kind of error propagation arrow.
18:51:57 <dolio> It might actually be equivalent (in a roundabout way) to the Kleisli arrow for Either String.
18:53:15 <dolio> type Validation a b = a -> Validate b
18:53:25 <dolio> x & y = either Left y . x
18:53:36 <chrisdone> right, the point of mine is on a validation, pass it along to the next one if it validates, if it doesn't, it returns a Left error and doesn't continue
18:53:38 <twanvl> I think it is Static (Either String) (->)
18:54:00 <chrisdone> twanvl: Static?
18:54:03 <twanvl> from the Applicative paper
18:55:21 <twanvl> no, it is not
18:55:23 <chrisdone> dolio: hm, I see that. looks basically like a monad with (>>=)
18:55:33 <dolio> Yes, it's a monad.
18:55:55 <chrisdone> I've been having awful trouble defining this & as a monad, though. :\
18:56:07 <dolio> It's in Control.Monad.Error.
18:56:18 <dolio> For library reasons.
18:56:36 <dolio> Well, the one I gave is.
19:04:50 <chrisdone> dolio: I see how this Control.Monad.Error has a monad transformer for exceptions, but what if I'm not inside a monad? should I just use Reader or something with the string inside?
19:05:17 <dolio> Control.Monad.Error has the monad instance for Either e, too.
19:05:27 <dolio> Where e is required to be in the Error type class (which String is).
19:07:38 <dolio> It's there because without the Error class, or something like it, you can't implement fail nicely for Monad (not that it should be there, but that's another story).
19:07:40 <chrisdone> dolio: actually, I do need to carry the string around (the one subjected to validation), so.. Reader would be good
19:08:31 <dolio> Isn't the string for error messages in your Validate type?
19:09:22 <chrisdone> dolio: oh, well, yes. I meant the value, sorry. it's just that typically it will start off as a string and be analysed and maybe turned into other types like numbers and booleans etc. it's for validating web page inputs
19:09:52 <chrisdone> dolio: oh, I guess if the type changes then Reader doesn't suffice. I am confusing myself
19:10:22 <dolio> The fully applied type is Either e a, which in your case is specialized to Either String a.
19:10:48 <dolio> Either String is the monad, but there's still a value that gets potentially passed along in the monad.
19:11:48 <dolio> But it propagates Lefts.
19:12:00 <chrisdone> right. the type of the value "passed" along should be able to change
19:12:10 <dolio> Right.
19:13:03 <chrisdone> yes, let's say you have some combinators; notEmpty, numeric, and number. the first looks at a string to see if it's not "", the second checks it's numeric, the third reads it as an instance of Num
19:13:28 <chrisdone> if “numeric” fails, then number never sees the value and the whole thing evaluates to Left "Not a number"
19:14:23 <dolio> Right.
19:14:49 <chrisdone> so how would you do that?
19:15:38 <dolio> Do notEmpty and so on just return the string in the successful case/
19:15:43 <chrisdone> I was actually considering using Parsec and defining some combinators with user-friendly error messages... but hought it might be OTT to use parsec
19:15:58 <chrisdone> dolio: right
19:16:14 <dolio> Then you could do notEmpty >=> numeric >=> number
19:16:32 <chrisdone> dolio: it's so when producing a web page, it can say, if it's Right, just put it back in the form, otherwise show the Left error in red next to the form input
19:16:36 <chrisdone> woah
19:16:36 <chrisdone> :t (>=>)
19:16:38 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
19:17:25 <chrisdone> let me try it in here
19:18:22 <chrisdone> > let notEmpty (Right v) = if null v then Left "Empty!" else (Right v) in (const $ Right "") >=> notEmpty
19:18:24 <lambdabot>  Couldn't match expected type `[Char]'
19:18:51 <hackage> Uploaded to hackage: RandomDotOrg 0.1
19:19:04 <chrisdone> > let notEmpty (Right v) = if null v then Left "Empty!"; notEmpty e = e else (Right v) in (const $ Right "") >=> notEmpty
19:19:04 <lambdabot>  Parse error at ";" (column 54)
19:19:07 <dolio> No, it'd be like this:
19:19:11 <chrisdone> hm?
19:19:55 <dolio> > let notEmpty "" = Left "Empty" ; notEmpty s = Right s ; numeric s | all isDigit s = Right s | otherwise = Left "Not numeric" in (notEmpty >=> numeric) ""
19:19:56 <lambdabot>  Left "Empty"
19:20:02 <dolio> > let notEmpty "" = Left "Empty" ; notEmpty s = Right s ; numeric s | all isDigit s = Right s | otherwise = Left "Not numeric" in (notEmpty >=> numeric) "asdf"
19:20:03 <lambdabot>  Left "Not numeric"
19:20:07 <dolio> > let notEmpty "" = Left "Empty" ; notEmpty s = Right s ; numeric s | all isDigit s = Right s | otherwise = Left "Not numeric" in (notEmpty >=> numeric) "1234"
19:20:09 <lambdabot>  Right "1234"
19:20:40 <chrisdone> ahhh
19:20:50 <chrisdone> duhh, of course
19:20:52 <dolio> > let notEmpty "" = Left "Empty" ; notEmpty s = Right s ; numeric s | all isDigit s = Right s | otherwise = Left "Not numeric" in return "1234" >>= notEmpty >>= numeric
19:20:53 <lambdabot>  Right "1234"
19:22:21 <chrisdone> > let notEmpty "" = Left "Empty" ; notEmpty s = Right s ; numeric s | all isDigit s = Right s | otherwise = Left "Not numeric"; number = return . read in (notEmpty >=> numeric >=> number) "9"
19:22:22 <lambdabot>  Right Exception: Prelude.read: no parse
19:22:56 <chrisdone> > let notEmpty "" = Left "Empty" ; notEmpty s = Right s ; numeric s | all isDigit s = Right s | otherwise = Left "Not numeric"; number n = Right ((read n) :: Num a => a) in (notEmpty >=> numeric >=> number) "9"
19:22:57 <lambdabot>        add (Read a) to the context of
19:22:57 <lambdabot>         the polymorphic type `forall a....
19:23:09 <chrisdone> > let notEmpty "" = Left "Empty" ; notEmpty s = Right s ; numeric s | all isDigit s = Right s | otherwise = Left "Not numeric"; number n = Right ((read n) :: (Num a, Read a) => a) in (notEmpty >=> numeric >=> number) "9"
19:23:10 <lambdabot>  Right 9
19:23:14 <chrisdone> mmk
19:23:29 <chrisdone> dolio: this is pretty nice
19:23:35 <dons> very cool, http://www.reddit.com/comments/6tvwk/randomdotorg_an_interface_to_random_numbers/
19:23:36 <lambdabot> Title: randomdotorg - an interface to random numbers produced by atmospheric noise for  ..., http://tinyurl.com/5ug7e2
19:23:48 <dons> i'm loving the diverse range of libs being generated now.
19:23:57 <chrisdone> dolio: shame I can't use pretty “do notEmpty; numeric; number” notation, hehe
19:24:00 <dons> 2D physics, atmospheric randoms
19:24:06 <dolio> chrisdone: Note, your original type Validate a -> Validate b is slightly different.
19:24:09 <dons> people are starting to do some pretty cool things on hackage.
19:24:16 <ddarius> There was a time when the libraries weren't diverse?
19:24:30 <dolio> It says (essentially) that your functions can still yield a b when an error is fed in.
19:24:40 <dons> ddarius: right.
19:24:50 <sw17ch> Something :: IO (Int) => Invalid type signature. ... ?
19:24:58 <dons> i guess you remember the time when there were no libraries, ddarius
19:25:06 <chrisdone> dolio: right, so a validator now is “a -> Validate b”? where Validate = Error String?
19:25:14 <dolio> Yeah.
19:25:19 <chrisdone> dolio: ^_^!
19:25:35 <chrisdone> dolio: thanks for going through this with me, btw. I really appreciate it
19:25:41 <dolio> No problem.
19:25:42 <dons> ddarius: what do you think of the direction of the haskell platform discussion?
19:26:07 <ddarius> dons: I haven't look at the Haskell Platform discussion at all yet.
19:26:34 <ddarius> I do remember a time when there were no hackage libraries, but then there was no hackage either.
19:27:08 <dons> you remember a time when none of our code used anything other than base?
19:27:23 * sw17ch smacks his head as he realizes that he's using a capital letter as something that's not a type...
19:27:25 * dons recalls dark days of makefiles as we scratched out the first reusable libraries
19:27:48 <chrisdone> dons: hehe
19:28:21 <dons> and now, i just hit a command, and the freshest code on hackage is immediately packaged for my distro.
19:30:54 <chrisdone> dolio: sweet, I changed one function “predicate” (to expect a instead of Either a b) that all my other combinators use and the code recompiled no problem :)
19:32:57 <chrisdone> dolio: ^_____^ http://hpaste.org/9213
19:33:38 <dolio> Congratulations. :)
19:33:53 <chrisdone> danke :P
19:41:25 <chrisdone> so (>=>) is called fish, right?
19:41:50 <dolio> Sure.
19:42:05 <bd_> :t (>=>)
19:42:05 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
19:42:10 <heatsink> @src (>=>)
19:42:10 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
19:42:50 <heatsink> oh hey, that's the monadic (.).
19:43:18 <dmwit> quite
19:43:39 <dmwit> flip (.), I think
19:43:42 <dmwit> :t flip (.)
19:43:42 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> (a -> b) -> f b
19:43:47 <dmwit> bah
19:43:51 <dmwit> :t flip (Prelude..)
19:43:52 <lambdabot> forall b c a. (a -> b) -> (b -> c) -> a -> c
19:44:03 <sioraio__> is thre any decent route for getting an Int# to a Char?
19:44:04 <chrisdone> :T (<=<)
19:44:08 <chrisdone> :t (<=<)
19:44:08 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
19:44:16 <sioraio__> since neither chr nor chr# can do the job?
19:44:36 <chrisdone> hi glguy
19:44:46 <glguy> hi
19:44:48 <dons> interesting reproducing this if someone's interested, http://www.diveintopython.org/toc/index.html
19:44:48 <lambdabot> Title: Dive Into Python
19:44:58 <dons> basically, a haskell for web programmers emphasis
19:45:04 * heatsink has wanted (<=<) before, but not enough to actually write it.
19:45:06 <dons> glguy and chrisdone could write it.
19:45:35 <chrisdone> heatsink: that exists, btw, you know that right?
19:46:08 <dmwit> sioraiocht: Well, if you can get Int# to Int... ;-)
19:46:09 <chrisdone> dons: sure
19:46:20 <sioraiocht> dmwit: fair enough, how do you do that? =p
19:46:24 <heatsink> chrisdone, yeh, but I didn't know about it until it was mentioned here.
19:46:35 <dmwit> sioraiocht: box :: a# -> a ;-)
19:46:40 <sioraiocht> cheers!
19:46:52 <dmwit> ...I'm pretty sure that doesn't exist.
19:47:15 <dons> i notice not much discussion is happening about the haskell platform, on http://www.reddit.com/r/programming/comments/6tvec/haskell_batteries_included/ . is it basically "yeah, just do it" or "i don't care"
19:47:17 <lambdabot> Title: Haskell: Batteries Included : programming, http://tinyurl.com/5ol4so
19:47:28 <sioraiocht> err...damn
19:47:31 <sioraiocht> you're right
19:47:31 <sioraiocht> hehe
19:47:37 <sioraiocht> thre has to be a way, though!
19:47:52 <sioraiocht> (besides unsafeCoerce)
19:48:54 <dmwit> dons: It would be "just do it" from my perspective.
19:49:22 <dmwit> Having to apt-get libraries all the time is so droll.
19:49:55 <sioraiocht> ah
19:50:02 <sioraiocht> I# :: Int# -> Int
19:50:04 <dmwit> s/droll/dross/
19:50:35 <heatsink> heh
19:51:25 <dons> droll is good, right.
19:51:33 <dons> as in, that was very droll.
19:51:36 <chrisdone> droll is humour?
19:51:40 <dmwit> yeah
19:51:48 <dons> just checking.
19:52:07 <dons> yeah, i guess the impact on developers is not obvious.
19:52:21 <dons> it just means end users who aren't on cabal-install can write and use things without worry
19:52:41 <chrisdone> I love cabal install. latest libraries, installed easily
19:53:25 <sw17ch> any one have time to do some hand holding with c2hs and structs?
19:53:34 <sioraiocht> what is faster, do we think, converting an Int# to a Char# to a Char, or an Int# to an Int to a Char?
19:53:50 <heatsink> siroaiochat: Probably the former
19:54:05 <dmwit> Why not test them both?
19:54:10 <dons> identity.
19:54:19 <dons> look at the core :)
19:54:43 * chrisdone opens core in notepad
19:54:59 <heatsink> Welcome to GHC, where core dumps are a good thing.
19:55:00 <dmwit> I hacked the Master Control Program!  We're FREE!!!
19:55:14 <sioraiocht> dmwit: I probably will, anyway
19:55:22 <sioraiocht> but I would suspect the former as well
19:56:33 <dons> i2c2c
19:56:33 <dons>   leaq        16(%r12), %rax
19:56:34 <dons>   cmpq        %r15, %rax
19:56:34 <dons>   movq        %rax, %r12
19:56:34 <dons>   ja  .L2
19:56:47 <dons> the, i2c2c i# = C# (chr# i#)
19:56:48 <dons>  impl
19:57:00 <dons> now, the other one was to chr (I# i#) ?
19:57:25 <SamB_XP_> heatsink: wait what?
19:57:36 <dons> same core, A.i2c2c = \ (i#_a5F :: Int#) -> C# (chr# i#_a5F)
19:57:43 <dons>   leaq        16(%r12), %rax
19:57:43 <dons>   cmpq        %r15, %rax
19:57:43 <dons>   movq        %rax, %r12
19:57:43 <dons>   ja  .L2
19:57:47 <dons> same asm.
19:57:49 <heatsink> SamB_XP_, looking at core is useful for GHC optimization.
19:57:57 <dons> sioraiocht: i2c2c :: Int# -> Char
19:57:57 <dons> i2c2c i# = unsafeChr (I# i#)
19:58:01 <dons> would be my impl.
19:58:08 <dons> if you don't want bounds checking
19:58:08 * SamB_XP_ groans
19:58:18 <SamB_XP_> heatsink: that was a horrible pun
19:58:22 <sioraiocht> i don't! i didn't know thre WAS an "unsafe" version
19:58:26 <sioraiocht> thanks!
19:58:35 <heatsink> ... :(
19:58:36 <dons> sioraiocht: well, chr checks against maxBound :: Char
19:58:39 <sioraiocht> lame
19:59:00 <sioraiocht> I already have to do ridiculous validation, not going to let haskell do any more of it =p
19:59:04 <ddarius> > maxBound :: Char
19:59:05 <lambdabot>  '\1114111'
19:59:08 <SamB_XP_> my parser interpreted "core dumps" as SIGSEGVs
19:59:48 <dons> sioraiocht: hehe, ok.
20:03:31 <chrisdone> would it be possible to define an instance for Eq for two different types I wonder. like "foo" < 5 = length "foo" < 5
20:03:42 <chrisdone> uh, Ord
20:04:15 <chrisdone> oh, no.
20:04:34 <dons> you can define an instance of Num for strings though
20:04:44 <chrisdone> ooo! good point!
20:04:51 <dons> or a generic compare that converts and compares
20:05:42 <chrisdone> presumably a Num instance for String hasn't cropped up because the length of the string is just one of lots of possibilities... or it hasn't been useful
20:05:58 <thoughtpolice> dons: re: random.org note, I don't think that random.org provides an interface to pull data directly out of the air
20:06:15 <thoughtpolice> also, how could we expose it as a PRNG for System.Random?
20:06:18 <dons> ah, i was also wondering how the data is transferred?
20:06:29 <dons> well, wouldn't it be much like the current IO random gen?
20:06:34 <SamB_XP_> thoughtpolice: can't
20:06:36 <dons> or would we just use it as a seed?
20:06:49 <dons> i mean, its a pure function right? :)
20:06:54 <dons> well, a pure generator.
20:07:04 <dons> just a state token will do to keep it sorted.
20:07:07 <thoughtpolice> dons: it pulls the data using HTTP-Simple
20:07:22 <dons> how much data is typically transferred, was what i was wondering.
20:07:29 <dons> is String IO inefficient?
20:08:27 <dons> oh, the other question, this should be under System.Random.Atmospher
20:08:29 <dons> or something
20:08:39 <SamB_XP_> I thought random.org was exactly the opposite of a pure function?
20:08:40 <thoughtpolice> dons: noted
20:09:07 <dons> SamB_XP_: its a magic state thread.
20:09:24 <thoughtpolice> i don't think that the efficiency is all that good right now; as of current it maps read over the returned string
20:09:46 <thoughtpolice> pulling 1,000 random numbers can take about 5-8 seconds when I last checked
20:09:50 <dons> ah interesting.
20:10:01 <dons> you get a bunch of bits, or numbers?
20:10:31 <thoughtpolice> you get straight numbers
20:10:36 <dons> fun library.
20:10:56 <thoughtpolice> text is outputted in plain text, but to be simple I have the output to 1 number per line
20:10:57 <dons> this is exactly the kind of new "glue" library i like to see :)
20:11:14 <thoughtpolice> so it's just 'map read (lines s)'
20:11:23 <dons> we could wrap it up like the mersenne-random package to provide random Doubles, Words Ints etc, next, I suppose? or do you do that already
20:12:11 <thoughtpolice> it doesn't provide support to generate floating points
20:12:41 <thoughtpolice> right now it can randomize a list of input, generate random strings, random integers and random sequences (which is the exact same thing as the integers only there is no repetition)
20:12:58 <thoughtpolice> there're other things there though that might be worth exploiting, for example a sound generator
20:13:54 <thoughtpolice> also a random bitmap generator
20:15:12 <thoughtpolice> but it seems right now the only thing provided via an 'official' api on the site is just the sequence/integer/string generator
20:17:02 <thoughtpolice> also there is a quota that needs to be abided by or random.org might ban your IP
20:18:36 <ddarius> dons: Remembering the LIP and before, it's mildly amusing to see (new) people blissfully using and complaining about Cabal and Hackage without even thinking that it was ever different.
20:20:18 <dons> ddarius: :D
20:20:38 <dons> "dude,  I could only build 517 Haskell packages. what's up with that?"
20:21:30 <dons> that's a good point, actually, new users have an entirely different experience.
20:21:47 <Stinger_> "back in my day..."
20:21:48 <dons> in a year or two, they'll not even think twice about assuming ghc and the core libs are all there ready to go on their box.
20:22:03 <SamB_XP_> dons: hmm?
20:22:19 <SamB_XP_> you mean they won't even begin to suppose that ???
20:22:19 <dons> SamB_XP_: hmm!
20:22:27 <dons> s/even //
20:22:32 <dons> s/about/before/
20:23:33 <mmorrow> chrisdone: what i have so far: http://code.haskell.org/~morrow/code/haskell/misc/Test.hs
20:23:38 <mmorrow> bbl
20:34:21 <sw17ch> is there a smallish package that uses c2hs in hackage?
20:34:42 <ddarius> Probably.
20:34:47 <sw17ch> preferably something which marshals structs across the c/haskell boundary ?
20:35:02 <sw17ch> :)
20:35:22 * sw17ch is having a hard time finding in the documentation the correct way to marshal structs...
20:35:25 <ddarius> @google site:haskell.org inurl:pipermail c2hs struct hackage
20:35:26 <lambdabot> http://www.haskell.org/pipermail/c2hs/2007-August.txt
20:35:41 <ddarius> @google site:haskell.org inurl:pipermail c2hs struct
20:35:42 <lambdabot> No Result Found.
20:39:48 <holmak> So, I'm trying to implement a function that returns a random element from a list
20:40:14 <holmak> http://hpaste.org/9214
20:40:26 <chrisdone> woah, loud thunder and lightening at 4:40 in the morning :)
20:40:32 <vixey> :t getStdRandom
20:40:34 <lambdabot> forall a. (StdGen -> (a, StdGen)) -> IO a
20:40:36 <chrisdone> mmorrow: cool
20:40:46 <vixey> :t randomR
20:40:46 <lambdabot> forall a g. (RandomGen g, Random a) => (a, a) -> g -> (a, g)
20:40:48 <sw17ch> :t randoms
20:40:48 <lambdabot> forall g a. (RandomGen g, Random a) => g -> [a]
20:40:50 <thoughtpolice> sw17ch: the c2hs source code has a bunch of examples iirc, including marshalling...
20:41:10 <holmak> i am frankly puzzled by all the random stuff
20:41:11 <vixey> holmak: your code looks wrong
20:41:21 <holmak> GHC agrees
20:41:33 <vixey> holmak: randomR takes a RandomGen parameter
20:41:39 <vixey> holmak: but you didn't pass one in
20:41:52 <sw17ch> thoughtpolice, i'll look harder... i found the tests, but those don't help much
20:42:15 <heatsink> holmak: Maybe it would help to know what RandomGen and random are?  A RandomGen is a source of randomness.  A Random is a type for which random values can be created.
20:42:39 <holmak> its actually complaining about randomIndex being type IO Int
20:42:46 <thoughtpolice> sw17ch: ah yeah it is in c2hs/tests, I found them to be fairly explanatory
20:42:48 <chrisdone> mmorrow: here's what I have as a monad: http://hpaste.org/9215
20:43:02 <thoughtpolice> sw17ch: there's the hsgnutls package which uses c2hs iirc, although I don't know if it'd qualify as 'small' by your standards
20:43:41 <heatsink> holmak: Have you written much IO code?  Are you comfortable with the distinction between monadic and pure code?
20:44:18 <holmak> i have a loose understanding of monads, and the whole pure/nonpure thing
20:44:32 <holmak> im a little hazy on getting between the two
20:44:33 <sw17ch> thoughtpolice, i'm really looking for something very basic
20:44:50 <ddarius> chrisdone: Shouldn't lenRange use len and should number not use read?
20:44:55 <sw17ch> define a struct with a few fields, access the fields, set the fields, and pass a pointer to the struct to a c function
20:45:46 <chrisdone> ddarius: good point, I've only just written lenRange, so I probably would've made that change
20:45:47 <heatsink> holmak: It looks like you're close to the right answer.  You need to run randomIndex in the IO monad though, then use its result as the argument to (!!).
20:46:06 <chrisdone> ddarius: number should definitely use read, it's for converting from string to number, and numeric is used to validate it before hand
20:46:34 <chrisdone> ddarius: though maybe number should use numeric?
20:48:08 <ddarius> I don't see why they are split apart.  You could easily accidentally use number without checking if it is numeric first and get an uncatchable exception rather than Left "errormsg"
20:48:12 <chrisdone> ddarius: well, number ought to handle failure, anyway. I wonder if there's a read which returns Either instead of throwing an exception..
20:48:20 <thoughtpolice> sw17ch: how bout this? http://darcs.haskell.org/c2hs/examples/libghttpHS/
20:48:21 <lambdabot> Title: Index of /c2hs/examples/libghttpHS
20:48:30 <thoughtpolice> seems real simple and there's marshalling happening it seems
20:48:42 <ddarius> chrisdone: The standard solution is reads, but there is also ndm's safe library that has some convenient wrappers.
20:48:44 <chrisdone> ddarius: indeed. numeric by itself is useful for other things, I'd think, where a string with a number in it is wanted, wouldn't you say?
20:48:56 <chrisdone> ddarius: ah, thanks. is that on hackage?
20:49:02 <ddarius> @hackage safe
20:49:03 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/safe
20:49:17 <holmak> so i need something like http://hpaste.org/9216 ?
20:49:28 <chrisdone> ddarius: very cool. thanks!
20:49:44 <sw17ch> thoughtpolice, that's a lot better for me... thanks :)
20:50:16 <heatsink> holmak: Yes.  And your randomIndex function will give you the random number.
20:50:45 <holmak> ok, ill have to dig through those random functions to figure out why it works later
20:50:57 <thoughtpolice> sw17ch: and still I found the stuff here instructive, particularly Marsh.chs http://darcs.haskell.org/c2hs/tests/system/
20:50:57 <lambdabot> Title: Index of /c2hs/tests/system
20:51:33 <thoughtpolice> hm. oleg's left-fold stuff is dangerously interesting.
20:51:59 <ddarius> thoughtpolice: That's the problem with Haskell.
20:52:01 <sw17ch> thoughtpolice, there we go, examples of {#get
20:52:17 <ddarius> "Haskell: Dangerously Interesting"
20:52:24 <thoughtpolice> catchy. :)
20:52:45 <ddarius> I expect dons to make a logo around it momentarily.
20:53:20 <thoughtpolice> hell, I'd make a logo for it. that's an attention-getter, right there...
20:54:38 <mmorrow> chrisdone: simplified/better and renamed: http://code.haskell.org/~morrow/code/haskell/misc/Validate.hs
20:54:50 * mmorrow looks at http://hpaste.org/9215
20:56:20 <mmorrow> chrisdone: nice, we wrote it essentially identically :)
20:56:44 <ddarius> As a related but different theme, we could fashion a pill bottle or something with perhaps a Surgeon General's warning and/or a "Side Effects" listing.  There is however a tension between having Side Effects be "Increased research paper reading" and Side Effects being "None"
20:57:02 <holmak> hahaha
20:57:21 <Elly> I've read many more research papers since I started learning haskell
20:57:24 <chrisdone> k number uses readMay now: http://hpaste.org/9215#a2
20:57:35 <Elly> slightly confounded by my having started university just before that too :P
20:57:40 <chrisdone> mmorrow: yeah :P
20:57:46 <mmorrow> ddarius: i like the slogan
20:58:18 <chrisdone> brb, suddenly feel very hungry
20:58:25 <mmorrow> chrisdone: the Ok monad i defined is essentially a cross between Maybe and Either String
20:59:22 <mmorrow> chrisdone: as a Monad, it's like Maybe (short circuits on the first NotOk), but has the Left [String] equivalent for errors
20:59:29 <thoughtpolice> ddarius: haskell is the reason I started reading research papers. :)
20:59:41 <mmorrow> so kinda like       data Maybe a = Nothing [String] | Just a
21:00:26 <O_4> In the Maybe example on http://www.haskell.org/all_about_monads/html/class.html , how come bind with Nothing returns a Maybe, but bind with Just doesn't?
21:00:26 <lambdabot> Title: Doing it with class
21:01:18 <mmorrow> O_4: the type of f there is       f :: a -> Maybe a
21:01:39 <Twey> O_4: Bind unpacks the value from the monad before passing it to the next function
21:01:42 <mmorrow> and the Maybe monad instance is somewhat more complicated than that one
21:01:55 <mmorrow> @src Maybe (>>=)
21:01:55 <lambdabot> (Just x) >>= k      = k x
21:01:55 <lambdabot> Nothing  >>= _      = Nothing
21:02:01 <mmorrow> uh, hold on
21:02:08 <Twey> It would do that with Nothing, but that no function is ever called if it's binding with Nothing
21:02:13 <O_4> Oh, so f is guaranteed to re-pack it into a Maybe
21:02:19 <Twey> Aye
21:02:29 <Twey> And then the next bind unpacks it again
21:02:31 <Twey> And so on
21:02:39 <O_4> Now why didn't I see that myself :-p
21:02:43 <Twey> Hehe
21:02:50 <lispy> it's also a monad law
21:02:51 <mmorrow> instance  Monad Maybe  where
21:02:51 <mmorrow>     (Just x) >>= k      = k x
21:02:51 <mmorrow>     Nothing  >>= _      = Nothing
21:02:51 <mmorrow>     (Just _) >>  k      = k
21:02:51 <mmorrow>     Nothing  >>  _      = Nothing
21:02:52 <mmorrow>     return              = Just
21:02:54 <mmorrow>     fail _              = Nothing
21:03:01 <lispy> (if you recall the monad laws)
21:03:40 <chrisdone> mmorrow: how come it's a list of strings?
21:04:13 <mmorrow> to accommodate more than one error
21:04:27 <chrisdone> I mean, in what case would there be more than one?
21:05:15 <Twey> chrisdone: HTML form validation?
21:05:20 <Saizan_> mmorrow: but if you abort on the first one how do you accumulate them?
21:05:20 <mmorrow> so eg you could define a function :: [Test a] -> a -> Ok()   that *doesn't* short circuit on the first NotOk, and returns all the errors that occured
21:05:40 <mmorrow> i haven't written it yet though
21:05:58 <chrisdone> Twey: that's what we're working on, yep
21:06:23 <Twey> Well, that's the first instance that sprang to mind where you could have a whole bunch of errors
21:06:36 <mmorrow> Twey: that's the initial motivation, but it's general so can be used for anything that is validation-like
21:06:39 <chrisdone> twey: well, this is just for validating one particular input
21:07:16 <chrisdone> mmorrow: why wouldn't you short circuit?
21:07:16 <mmorrow> chrisdone: but with combinators, it could probably be easily extended to handle that
21:07:38 <mmorrow> chrisdone: if possibly you'd like to know *all* the things that are invalid instead of just the first thing
21:09:27 <mmorrow> Twey, chrisdone: so an instance of multiple errors would be...
21:09:34 <chrisdone> I guess.. like ["Must not be null","Must be numeric","Must be within 18-120"]
21:11:03 <mmorrow> runTests [allDigits,noSevensOrSemicolons] "29387"
21:11:10 <Twey> IMO a Map would be more useful for that particular instance
21:11:33 <Twey> [(name, error), (name, error)]
21:11:37 <mmorrow> (that's example is contrived, but not ridiculous)
21:12:16 <mmorrow> oh, that example i just gave probably wouldn't even return multiple errors, heh
21:12:26 <chrisdone> allDigits makes the other unnecessary
21:12:52 <mmorrow> yeah, i'm trying to think up an example that would occur in practice but struggling to contrive one
21:14:02 <chrisdone> I guess it would be useful to display all the errors next to a form input, like if you enter some letters into a number field, it might say
21:14:25 <chrisdone> [       ] * Must not be empty * Must be a number * Must be between 18-120
21:14:39 <mmorrow> runTests [lengthIs4,headIsLessThan12,lastIsGreaterThan9] [12,0,0,1,8]
21:15:14 <mmorrow> NotOk ["head isn't less than 12","last isn't greater than 9]
21:15:34 <mmorrow> oops
21:15:37 <mmorrow> runTests [lengthIs4,headIsLessThan12,lastIsGreaterThan9] [12,0,1,8]
21:15:52 <mmorrow> NotOk ["head isn't less than 12","last isn't greater than 9]
21:16:02 <chrisdone> aye
21:16:37 <Trinithis> When languages have procedures like "getInt", and the user inputs a non-int, does it signal an error or does it default to a value?
21:16:46 <Trinithis> in general*
21:16:52 <mmorrow> (probably should of called runTests there runTests', but the meaning is obvious)
21:16:55 <chrisdone> it should signal an error
21:17:23 <chrisdone> if I accidentally typed some crap into a form input and it picks a default value for me, I would be annoyed
21:17:29 <Trinithis> k
21:17:39 <chrisdone> imho
21:18:11 <Trinithis> I was thinking around those lines. Im implementing Funge98 in haskell, and it doesn't specify what happens on Integer input
21:18:15 <mmorrow> Trinithis: i think the haskell equivalent to your getInt would be     (getLine >>= return . (read::String->Int))
21:18:31 <mmorrow> which would call error "read: no parse" on failure
21:18:52 <hackage> Uploaded to hackage: cedict 0.2.2
21:19:01 <Trinithis> The only problem is that the funge language doesnt support error handling...
21:19:07 <mmorrow> so the getting and the parsing are separate
21:19:19 <chrisdone> (getLine >>= return . (maybe (Left "Give me an integer, damnit!!") Right) . (readMay :: String -> Int))
21:19:28 <Trinithis> :D
21:19:42 <Trinithis> read . getLine
21:19:54 <chrisdone> :t read . getLine
21:19:57 <mmorrow> Trinithis: hmm, in that case i guess the choice is between defaulting or killing the program
21:19:57 <lambdabot> forall a. (Read a) => IO a
21:19:57 <ddarius> chrisdone: ... >>= return . f == liftM f ...
21:20:10 <mmorrow> (error "something" is equivalent to killing the program)
21:20:14 <chrisdone> ddarius: yeah, I was just editing mmorrow's
21:20:16 <ddarius> or fmap or <$> or some others
21:20:46 <Trinithis> mmorrow: perhaps I can come up with a clever solution or have an extension for errors
21:20:49 <mmorrow> ddarius: heh, i never use liftM due to personal preference/neurosis
21:21:01 <chrisdone> mmorrow: we need a repo. that we can write to for this validation business
21:21:20 <chrisdone> mmorrow: or a hpaste “thread”
21:21:41 <mmorrow> chrisdone: good idea, i'll set one up
21:21:44 <chrisdone> or some Gobby :P
21:21:48 <chrisdone> cool
21:21:53 <mmorrow> chrisdone: we should have an hpaste thread too
21:21:59 <chrisdone> yeah
21:22:03 <chrisdone> can you paste your latest version?
21:22:29 <mmorrow> http://hpaste.org/9217
21:22:57 <mmorrow> (that's identical to the one at http://code.haskell.org/~morrow/code/haskell/misc/Validate.hs)
21:24:50 <Saizan_> mmorrow: btw, Test is a monad too, and (&) becomes (>>)
21:25:25 <mmorrow> Saizan_: yeah, i gotta write that instance
21:25:31 <Saizan_> oh, no, sorry
21:25:44 <mmorrow> "something like that"
21:26:05 <Saizan_> you use Ok () instead of Test a b = (a -> Ok b) would be
21:26:21 <chrisdone> mmorrow: your spacing is a little weird?
21:26:22 <Saizan_> s/you use Ok ()//
21:26:31 <chrisdone> like “runTests :: [Test a] -> a -> Ok()
21:26:36 <chrisdone> true  = test[](const True)
21:26:39 <chrisdone> editor problems?
21:26:42 <mmorrow> chrisdone: yeah, i need to consistentize it
21:26:52 <chrisdone> ah
21:27:25 <chrisdone> & makes them composable which is nice
21:28:19 <Trinithis> > reads "   23   "
21:28:25 <lambdabot>  []
21:28:43 <mmorrow> chrisdone: spacing fixed: http://hpaste.org/9217#a1
21:28:46 <chrisdone> > reads " 23 " :: (String -> [Int])
21:28:46 <lambdabot>  Couldn't match expected type `String -> [Int]'
21:29:07 <ddarius> > reads " 23 " :: [(Int,String)]
21:29:08 <lambdabot>  [(23," ")]
21:29:14 <Trinithis> ah
21:29:41 <chrisdone> mmorrow: oki
21:30:09 <Trinithis> > read " 123 " :: Integer
21:30:13 <lambdabot>  123
21:30:24 <chrisdone> mmorrow: I can probably just paste in the combinators I have so far, “test” is equivalent to my “predicate” function
21:30:28 <Trinithis> :t readIO
21:30:38 <lambdabot> forall a. (Read a) => String -> IO a
21:30:50 <Trinithis> @src readIO
21:30:51 <lambdabot> Source not found. You untyped fool!
21:31:58 <mmorrow> chrisdone: cool, i'm gonna make a list of (_ :: Test String)s to-write
21:32:19 <chrisdone> mmorrow: oh, hang on
21:32:49 <mmorrow> (off the top of my head...ints,floats,dates,?)
21:32:51 <chrisdone> mmorrow: can tests convert to different types? then again I guess it can't because it's in a list
21:33:03 <chrisdone> yeah
21:33:47 <chrisdone> mmorrow: it's just that functions like “less” would have to read in the number and then do the check..
21:33:58 <chrisdone> I don't suppose it's slow, though
21:34:27 <sw17ch> alright, here's a cool one... in c2hs, what happens when a struct field name is "type"
21:34:52 <sw17ch> apiType <- liftM cToEnum $ {# get PaHostApiInfo.type #} ptr
21:35:03 <mmorrow> chrisdone: yeah, maybe Test a should be  Test b a = Test (a -> Ok b) so the parsing work isn't done just to check validity then thrown away (just to have to be done all over again)
21:35:12 <sw17ch> it tells me "phrase 'type' is not allowed here"
21:35:22 <sw17ch> is this considered a bug? or is there a way around this?
21:36:28 <mmorrow> chrisdone: but then it essentially become parsing and not validation...
21:36:30 <chrisdone> mmorrow: yeah. perhaps a test should return either a value or a list of errors. although... differing types might make it difficult to put into lists or maps or whatever
21:37:08 <chrisdone> mmorrow: hmm
21:37:14 <Trinithis> type is a keyword
21:37:37 <mmorrow> chrisdone: yeah that's true, i think one solution would be to expect the input to the test to already be parsed or whatever, then to verify somestuff about it
21:37:42 <Saizan_> sw17ch: i think there's a way to quote it
21:38:40 <mmorrow> and different types could be handled by just wrapping them in a data, eg     data MyForm = MyForm { date :: Date, amount :: Double, name :: String, dept :: Department }
21:39:00 <chrisdone> mmorrow: oh wait. what if the validation result just returns the original string?
21:39:22 <chrisdone> mmorrow: like, in the validation stage it can convert the result to anything it wants, and at the end all that's tested for is errors, really?
21:39:41 <mmorrow> you could always have a function runTest' :: Test a -> a -> (Ok (),a) though
21:40:02 <sw17ch> Saizan_, you're right, single quotes
21:40:06 <chrisdone> like let myString = "foo"; test = test myString in case test of Just errors -> oh noes!; _ -> use myString
21:40:30 <chrisdone> mmorrow: yeah!
21:40:45 <mmorrow> chrisdone: oh i like that, so it would take a continuation
21:41:29 <chrisdone> mmorrow: hm?
21:42:12 <mmorrow> like type Validated r a = Validated (Test a -> (a -> r) -> r)
21:42:15 <adu> omg
21:42:23 <mmorrow> (or something)
21:42:29 <chrisdone> I mean say you had Test b a = Test (a -> Ok b), then you can convert it to a number and not have to use “read” more than once, but the validation doesn't return a value, it just says if there ar eerrors
21:42:54 <adu> I just learned about "deriving (Read, Show)" and it gave new meaning to my life
21:42:56 <sw17ch> Saizan_: actually, that doesn't seem to be working either
21:43:33 <chrisdone> mmorrow: not sure where you mean with the continuation?
21:43:36 <mmorrow> or better,  type Validated r a = Validated (Test a -> (a -> r) -> Ok r)
21:44:12 <sw17ch> when i quote the keyword, it includes the quotes in the field name
21:44:25 <chrisdone> mmorrow: but that's parsing!
21:44:25 <mmorrow> chrisdone: i'm not entirely sure yet either, i'm gonna set that repo up and think about it
21:44:50 * sw17ch feels like he's hitting every possible problem concerning FFI
21:45:01 <mmorrow> chrisdone: heh, yeah. i think the crux of designing this'll be where to draw the line
21:45:02 <chrisdone> mmorrow: I think a validation should just return Maybe Errors, you know?
21:46:08 <mmorrow> chrisdone: Ok () is isomorphic to Maybe [Err], but the nice thing about Ok a is that it can also be used to return a value as well
21:46:42 <mmorrow> chrisdone: but if Ok a where a/= () is never used, then Maybe [Err] is probably a better idea
21:46:53 <chrisdone> mmorrow: but that's what I'm saying, I don't think a validation should return a new value, otherwise we get into the problems of having a list of validation and things like that
21:47:29 <mmorrow> chrisdone: yeah i agree, keep it simple. so let's s/Ok ()/Maybe [Err]/
21:47:53 <chrisdone> mmorrow: righto!
21:48:04 <mmorrow> and Nothing corresponds to Ok ()
21:48:10 <chrisdone> aye
21:48:32 <chrisdone> meaning “no problems”
21:49:39 <chrisdone> where will the repo. be? I've got a web server so I can set one up for myself so you can pull from me and I can pull from you
21:49:44 <mmorrow> oh, actually that causes a problem, since then it'll short circuit on the first *valid* test
21:50:01 <chrisdone> mmorrow: I don't see why it has to?
21:50:11 <chrisdone> mmorrow: you mean like
21:50:20 <chrisdone> isNumeric . convertToNumber
21:50:31 <mmorrow> because shortcircuiting on Nothing is baked into the Maybe monad
21:51:24 <chrisdone> but this Maybe [Err] is just for returning the validation of a string
21:51:41 <chrisdone> I don't follow?
21:51:48 <mmorrow> hmm, maybe i have it flipped, have to think about it. i'll put a repo somewhere and get back to you
21:52:08 <chrisdone> okay
21:52:12 <chrisdone> I'll “get” yours
21:52:20 <chrisdone> darcs, right?
21:52:36 <mmorrow> yeah, we should each have our own repos so we can pull from each others
21:52:48 <mmorrow> darcs
21:53:01 <chrisdone> oki
21:54:32 * chrisdone moves irssi over to his emacs workspace
21:55:51 <chrisdone> yeah, 'cause I use XMonad. you may have heard of it. this window manager that is tiny and configurable.
21:56:46 * chrisdone /advertisementvoice
21:57:15 <bitrot> gee guys, maybe if I use XMonad, the senior engineers won't be able to kick sand in my face anymore!
21:57:54 <chrisdone> I-saved-money-with-XMonad
21:58:35 <Pseudonym> It carries the Charles Atlas Seal of Approval.
21:58:59 <ddarius> @hackage xmonad
21:59:00 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/xmonad
21:59:50 * ddarius would upgrade from 0.3 but then he'd have to rewrite his configuration.
22:00:22 <chrisdone> “I‘m Joe Bloggs and I‘m dead now, because I didn't use Haskell.”
22:01:18 <chrisdone> mmorrow: are you setting the repo. up right now or later? I'm kind of sat waiting
22:03:41 <chrisdone> evening _zenononon_
22:05:21 <thoughtpolice> heh, reminds me I need to get a linux box back up somehow. i'd love to use xmonad on this macbook, but i'm not willing to go through the effort of building a bunch of stuff I already have against X11 just for it
22:05:57 <chrisdone> bbl
22:09:24 <_zenon_> Good mornin'
22:09:56 <_zenon_> All doing well chrisdone ?
22:10:21 <_zenon_> You are in which country ?
22:13:24 <mmorrow> chrisdone: ok, the base dir is http://code.haskell.org/~morrow/code/haskell/web/
22:13:24 <lambdabot> Title: Index of /~morrow/code/haskell/web
22:13:34 <mmorrow> haddock docs: http://code.haskell.org/~morrow/code/haskell/web/docs/
22:13:35 <lambdabot> Title: validate-0.0: Validate
22:13:42 <mmorrow> darcs repo: http://code.haskell.org/~morrow/code/haskell/web/validate/
22:13:42 <lambdabot> Title: Index of /~morrow/code/haskell/web/validate
22:14:03 <mmorrow> and the repo is cabalified so can be installed nicely
22:18:31 <sw17ch> thoughtpolice, i finally got it. thanks for your help
22:18:33 <sw17ch> thoughtpolice++
22:18:45 <thoughtpolice> sw17ch: np. what're you working on, a binding to something?
22:19:06 <sw17ch> bindings for PortAudio. there aren't any good audio bindings for haskell at all... :(
22:19:24 <sw17ch> i was doing alsa, but there's about 500 too many functions for me to want to do that
22:19:36 <johnnowak> sw17ch: portaudio is a better way to go
22:19:38 <sw17ch> portaudio consists of a single header file, is cross platform, and only has about 30 things that need porting
22:19:44 <thoughtpolice> sw17ch: I was thinking of writing a portaudio binding a while back, it seemed to be a nice simple lib.
22:19:56 <sw17ch> yeah, it's not bad
22:20:04 <sw17ch> i wasn't sure how to go about the callback stuff... so i'm skipping it for now
22:20:12 <sw17ch> i may request help on that part later
22:20:27 <sw17ch> (i'm not sure if the callback part even makes sense for haskell)
22:20:54 <sw17ch> since it's a continuous callback, rather than a one time asynchronous deal... and that just sounds scary
22:23:33 <sw17ch> i do have one problem yet though, and it's a grammar issue with c2hs... is there a way to escape a field if it clashes with a c2hs symbol?
22:23:49 <sw17ch> (Sorry for the repeat question)
22:31:13 <Trinithis> What's the syntax for record pattern matching?
22:32:40 <Saizan_> Constr{field1=var,field2=var'}
22:33:04 <Trinithis> k
22:35:49 <help_me_please> please help me http://www.meine-nackte-ex.net/?uid=50702
22:35:50 <lambdabot> Title: Meine-nackte-Ex.net - Hammerfrau!!!
22:36:39 --- mode: ChanServ set +o dibblego
22:36:42 --- kick: help_me_please was kicked by dibblego (dibblego)
22:36:53 --- mode: dibblego set -o dibblego
22:42:24 <Saizan_> sw17ch: just a guess from skimming the lexer: tried with `type' ?
22:42:52 <sw17ch> yes :(
22:43:11 <sw17ch> The phrase ``type'' is not allowed here.
22:43:29 <sw17ch> called like this: {# get PaHostApiInfo . `type' #}
22:44:13 <Saizan_> i see
22:45:12 <sw17ch> i'm not quite sure what's going on
22:45:27 <sw17ch> i've tried '',`',``,""
22:47:21 <hml> @hoogle runSTArray
22:47:22 <lambdabot> Data.Array.ST.runSTArray :: Ix i => ST s (STArray s i e) -> Array i e
22:47:27 <hml> @hoogle runST
22:47:27 <lambdabot> Control.Monad.ST.runST :: ST s a -> a
22:47:27 <lambdabot> Control.Monad.ST.Lazy.runST :: ST s a -> a
22:47:27 <lambdabot> Data.Array.ST.runSTArray :: Ix i => ST s (STArray s i e) -> Array i e
22:47:51 <vixey> @hoogle Array i e -> ST s (STArray s i e)
22:47:52 <lambdabot> No matches, try a more general search
22:48:02 <hml> i can't figure out how to use runSTArray
22:48:27 <vixey> hml: what are you using it  for?
22:49:19 <hml> h/m; i think i got it
22:49:39 <vixey> I'm still interested in what you're using it for
22:50:13 <hml> okay; it doesn't work
22:50:21 <hml> if you help me debug this; i';ll tell you :-)
22:51:19 <hml> wait; let me debug one more thing
22:53:25 <hml>  http://hpaste.org/9219
22:54:15 <hml> n/m, got it :-)
22:54:23 <hml> vixey: i'm buiding a constructive solid geometry mesh library in haskell
23:01:21 * vixey laughs http://www.vex.net/~trebla/humour/book_for_sale.html
23:01:21 <lambdabot> Title: Book For Sale
23:08:39 <_lidlpenner93_> ICH WEIS WO MAN VIDEOS GUCKEN KANN UND WENN MAN WILL KANN MAN DANN DIE VIDEOS KOSTENLOS AUF SEIN HANDY SCHICKEN LASSEN WENN IHR WOLLT GEHT DA DRAUF www.extrem-geile-videos.de.vu
23:09:35 --- mode: ChanServ set +o bos
23:09:45 --- mode: bos set +b *!*@*.hsi.ish.de
23:09:54 --- kick: _lidlpenner93_ was kicked by bos (bos)
23:10:08 --- mode: bos set -o bos
23:10:08 <chrisdone> I don't listen to Rammstein
23:10:42 <chrisdone> hey can we get lambdabot to join #webhaskell?
23:15:07 <vixey> well I found that very funny
23:16:47 <hml> in an already ruhning ghci session, how can I load Cube.hs ?
23:17:07 <chrisdone> :l Cube.hs
23:17:19 <chrisdone> or just :l Cube
23:17:36 <Korollary> or :m + Cube
23:17:50 <chrisdone> does that work? never tried that
23:18:52 <hackage> Uploaded to hackage: cedict 0.2.3
23:19:12 <chrisdone> cool
23:20:06 <hml> chrisdone: great; thanks
23:20:08 * glguy wonders how much resistance there would be to using the +r flag to calm the spammers
23:20:36 <chrisdone> +r == must be registered?
23:20:38 <sjanssen> glguy: +r requires registration?
23:20:43 <glguy> to speak
23:20:46 <glguy> but not to join
23:20:56 <chrisdone> yeah, I know of a few chans who have that
23:21:02 <glguy> works well in #archlinux
23:21:11 <sjanssen> I'd rather not do that.  You have to consider new IRC users
23:21:13 <hml> if I know that a value can on ly take on values 0 to 7, is there anyway to tell haskell to store an list of it in 3 bits?
23:21:21 <hml> 3 bits per elem
23:21:28 <glguy> sjanssen: they adapt very quickly
23:21:47 <geezusfreeek> we don't get _that_ many spammers in here
23:23:28 <Trinithis> > fromInteger 9999999999999999999 :: Int
23:23:31 <lambdabot>  -1981284353
23:23:59 <chrisdone> > 9999999999999999999 :: Int
23:24:00 <lambdabot>  -1981284353
23:24:17 <Trinithis> Chars are 64 bits right?
23:24:48 <Trinithis> > maxBound :: Char
23:24:49 <lambdabot>  '\1114111'
23:25:07 <Trinithis> > 0x1114111
23:25:08 <lambdabot>  17907985
23:25:25 <sjanssen> Trinithis: the domain is much smaller than that
23:25:37 <twanvl> > logBase 2 1114111
23:25:38 <lambdabot>  20.087461546321563
23:25:42 <dolio> That's not hex.
23:25:50 <Trinithis> is the domain still bigger than Int
23:25:58 <sjanssen> Trinithis: it is smaller
23:25:59 <dolio> > showHex 1114111 ""
23:26:00 <lambdabot>  "10ffff"
23:26:09 <Trinithis> ok
23:26:42 <johnnowak> Trinithis: 10ffff is the max for unicode
23:27:30 <Trinithis> But Haskell doesnt go very high into unicode i gather (from here)
23:28:22 <Trinithis> > ord maxBound
23:28:23 <lambdabot>  1114111
23:28:32 <hml> @src zip
23:28:33 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
23:28:33 <lambdabot> zip _      _      = []
23:28:34 <hml> @src zipWith
23:28:35 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
23:28:35 <lambdabot> zipWith _ _      _      = []
23:28:56 <hml> is ther a way to make the following shorter; i.e. kill the let?
23:28:57 <hml>        let (lower, upper) = bounds points
23:28:57 <hml>        sequence_ [update_array_entry arr x Util.remove_dup | x <- [lower .. upper]]
23:28:58 <sjanssen> Trinithis: Char supports the entire Unicode range, but the IO implementations ignore everything but the lowest 8 bits
23:29:07 <Trinithis> thx
23:29:24 <cjs> Hm. So say I have a list of functions, each of which is to process a particular message I receive (passing it on to someone else or whatever).
23:29:33 <twanvl> ?type range
23:29:34 <lambdabot> forall a. (Ix a) => (a, a) -> [a]
23:29:43 <cjs> They need to keep some state. If each one returns a new version of the function to use next time, it can just return itself, right?
23:29:58 <Trinithis> Out of curiosity, I'm getting a new computer in a few days and want to install Linux on it. Any suggestions for the linux type?
23:30:00 <cjs> But will that produce a deep, deep nesting of closures after I've processed a zillion messages?
23:30:17 <humasect> hml: so .. x <- range $ bounds points
23:30:19 <cjs> Or will the compiler note that the variables from previous closures are shadowed, and GC them?
23:30:24 <Twey> Trinithis: *votes Gentoo*
23:30:49 <Trinithis> Does Xmonad work on any Linux distro?
23:30:53 <sjanssen> Trinithis: if you're new to Linux, you can't get much easier than Ubuntu
23:30:57 <Twey> Pretty much
23:31:09 <humasect> cjs: can you make a small test to inquire on its behavior ?
23:31:23 <Trinithis> sjanssen: I'm willing to duke out 'harder' distros for the long run
23:31:33 <cjs> I suppose I could, but I'm not sure that doing things this way is all that sensible anyway.
23:31:50 <Pseudonym> Trinithis: If it's got X11 and it's got GHC, then it's got XMonad in principle.
23:31:56 <cjs> Oh, wait, it probably is,because different functions might want to maintain different things as state.
23:32:03 <humasect> cjs: often that is found while trying to code it, too=)
23:32:13 <cjs> But rather than making a test, I'd rather someone just told me. :-)
23:33:01 <humasect> updating state by returning a new version of itself is very common
23:33:15 <cjs> Right. But updating state by returning a function within a closure?
23:33:40 * Trinithis will have to do a little research...
23:33:44 <humasect> whats a closure ?
23:33:49 <Saizan_> cjs: the State monad pretty much works like that, so i'd guess it works reasonably
23:33:54 <Trinithis> humasect: awesomeness
23:34:04 <Saizan_> ?src State
23:34:04 <lambdabot> Source not found. You speak an infinite deal of nothing
23:34:13 <Trinithis> @faq closure
23:34:14 <lambdabot> The answer is: Yes! Haskell can do that.
23:34:16 <Saizan_> ?unmtl State s a
23:34:16 <lambdabot> s -> (a, s)
23:34:19 <humasect> Trinithis: i know of smalltalk closures, but haskell ?
23:34:26 <Trinithis> same deal i suspect
23:34:49 <cjs> Oh, darn, that's a recursive type. How do I declare that?
23:34:51 <dons> > let f = (+) 2 in map f [1..10]
23:34:52 <cjs> Same deal.
23:34:52 <lambdabot>  [3,4,5,6,7,8,9,10,11,12]
23:34:53 <humasect> perhaps it was so common that it bypassed realisation of being closures at all
23:34:58 <Trinithis> variables binding to function through lexical scoping in smalltalk?
23:35:07 <cjs> Well, I'm thinking more of partial application, really.
23:35:25 <humasect> Trinithis: oh, yes i see. of course awesomeness =)
23:35:38 <sjanssen> cjs: use newtype?
23:35:49 <Trinithis> humasect: closures in haskell are imo are rather transparent due to the fact that everything is immutable
23:35:52 <humasect> cjs: you may not need State at all.
23:36:08 <hml> hucool; thanks
23:36:10 <Trinithis> humasect: but still useful of course!
23:36:11 <humasect> Trinithis: hm yes i think so too
23:36:29 <humasect> highly =) as well, difficult to live without for certain modes of thinking
23:36:33 <cjs> "Occurs check: cannot construct the infinite type: t = IO t"
23:36:37 <Trinithis> currying further makes their use even more transparent...
23:36:46 <sjanssen> newtype F = F (MyInput -> (MyOutput, F))
23:37:37 <humasect> i may also not know what specific functionality to call currying or not currying
23:37:50 <ketil> Isn't closures in Haskell and e.g. Lisp different beasts, due to (im)mutability?
23:38:22 <ketil> @type curry
23:38:23 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
23:38:26 <ketil> @type uncurry
23:38:27 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
23:38:28 <Trinithis> humasect: Are you saying you aren't exactly sure what currying means? (even if you know the idea)
23:38:35 <Saizan_> ketil: you can close over IORef's in IO if you want
23:38:47 <humasect> Trinithis: yes, that's right. informally learnt=)
23:39:42 <humasect> ok, i have never had to use those curry or uncurry
23:40:03 <ketil> Saizan_, oh, right.  It's just that immutable closures seem so trivial...don't understand what the fuss is about :-)
23:40:07 <Trinithis> humasect: my take on explaining currying: http://www.codingforums.com/showpost.php?p=684648&postcount=3
23:40:07 <lambdabot> Title: CodingForums.com - View Single Post - Heavy-duty curry function
23:40:19 <ketil> humasect, or see my @type statements above.
23:40:44 <Saizan_> ketil: the conversation started asking about possibile performance problems
23:40:51 <humasect> ketil: i was looking at them for some moments ~
23:41:21 <ketil> Saizan_, sorry - I just dropped by.  My apologies for gatecrashing the party.
23:41:24 <ketil> :-)
23:41:38 <Saizan_> np, just explaining :)
23:42:14 <hml> is there a three way zip?
23:42:21 <ketil> @type zip3
23:42:22 <lambdabot> forall a b c. [a] -> [b] -> [c] -> [(a, b, c)]
23:42:36 <hml> ketil: thanks
23:42:53 <hml> @src repeat
23:42:53 <lambdabot> repeat x = xs where xs = x : xs
23:42:58 <humasect> Trinithis: interesting, thanks. pondering ..
23:43:21 <Trinithis> if you want, you can view the whole thread for it's context
23:44:11 <ketil> humasect, perhaps if you add parentheses?  curry: ((a,b)->c)  ->  (a -> (b -> c))
23:44:41 <humasect> oh, that is quite simple. =)
23:45:06 <ketil> Hmm.. is that my irony detector going off?
23:45:13 <humasect> isn't this slightly different than the @type ?
23:45:34 <humasect> combined with Trinithis it all makes sense now. but the @type seems somehow not quite fitting
23:45:49 <ptolomy> Hm. "=~" and "=~~" are pretty awesomely overloaded for the uses I might want, but how do I handle the situation in which the regular expression isn't valid? My current use just kills my program.
23:46:18 <humasect> to have (a -> (b -> c)) from (a -> b -> c) , does it not become against the idea of currying for curry:: to take so many args?
23:46:20 <Trinithis> humasect: try this http://www.haskell.org/haskellwiki/Currying
23:46:21 <lambdabot> Title: Currying - HaskellWiki
23:46:32 <humasect> ok, thanks =)
23:47:18 <Trinithis> just dont get confused with the fact that the function is called 'curry', yet ALL functions in Haskell are curried to begin wiht
23:48:23 <humasect> ok, it may be that all of my functions are also curried then. !
23:49:00 <ketil> humasect, the main idea is that f :: (x,y) -> z and g :: x -> (y -> z) are equivalent.  The latter is the Haskell default, and it allows partial application.
23:49:26 <humasect> ah yes, right; this makes a lot of sense now
23:49:33 <dibblego> s/equivalent/isomorphic
23:50:09 <ketil> dibblego, okay.  I tried to avoid being to precise here :-)
23:51:03 <humasect> now i can see also why i may personally not come across its requirement. say, for algorithms implemented in an outside source ?
23:51:15 <Trinithis> > isomorphic f g
23:51:16 <lambdabot>   Not in scope: `isomorphic'
23:51:27 <sjanssen> (x, y) -> z and x -> (y -> z) are not isomorphic in Haskell :P
23:51:37 <Trinithis> really?
23:51:56 <dibblego> Trinithis, remember that bottom inhabits types
23:51:58 <humasect> is it possible for someone to add deriving() to an existing data ?
23:52:22 <humasect> isn't it x -> y -> z == x - > (y -> z) ?
23:52:30 <dibblego> humasect, yes
23:52:36 <Trinithis> yes... for all cases
23:53:54 <humasect> ah so one could indeed apply the magic of deriving onto externally defined types (data) ?
23:54:19 <Trinithis> I dont think so
23:54:29 <humasect> the alternative being to instance to it
23:54:39 <Trinithis> yo can always add instances tho
23:54:41 <humasect> ah ... even as a new type based on the existing type ?
23:54:42 <cjs> sjanssen: So the newtype seems to work for me, but I can't figure out how to get that next argument out: http://hpaste.org/9220
23:55:02 <humasect> Trinithis: but for example with Read and Show, they will have to be implemented manually in that case of adding (instance)
23:55:18 <Trinithis> Yes.... unless I'm mistaken
23:55:35 <Trinithis> I would think so because of information hiding
23:55:36 <cjs> Well, that type is actually wrong for what I want, isn't it.
23:56:07 <humasect> it feels like something is missing there; what information is hidden ? especially when .hs files are used directly
23:56:19 <cjs> So basically, for my little experiment here, I want to have a function that takes a string, prints it, prefixed by a number, and returns a version of itself that will print a string prefixed by the next number.
23:56:26 <sjanssen> cjs: see my annotation, does that make sense?
23:56:47 <Trinithis> Well, if you import a lib, and you dont have a constructor in scope, then deriving could very well break hiding
23:56:49 <cjs> Gha! The damn value constructor! I do this all the time.
23:56:54 <cjs> Yes, it makes perfect sense.
23:57:09 <cjs> I get as far as the lambda and then forget the value constructor.
23:57:26 <humasect> cjs =)
23:57:42 <cjs> It kills you when you're making a monadic parser, I'll tell you.
23:58:03 <Trinithis> value constructor?
23:58:27 <humasect> Trinithis: but if the type were to be extended into a different constructor, so the deriving would only apply to that newly added type. i am sorry for not having the vocabulary
23:59:08 <Trinithis> as long as you can see data or newtype... you're gold
23:59:21 <cjs> Trinithis: See my code and the annotation; it's obvious what I forgot.
23:59:55 <humasect> hm, maybe i do not know what newtype is 'for'
