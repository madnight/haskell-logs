00:01:27 <Trinithis> regardless of implementation, are you trying to achieve "parallel maps"?
00:02:23 <mdmkolbe> Trinithis: I'm trying to achive priority queues with separate keys and priorities
00:04:16 <Trinithis> well, i can't be of much help. in any case, I'm quitting the night. cya
00:04:41 <mdmkolbe> Trinithis: formally it is a set of tuples {(p,k,v)} and two operations: getMin takes the queue and returns removes the tuple with smallest p, insertWith takes a p, k, and v and a queue, and replaces the tuple with k with the new p,k, and v
00:04:53 <mdmkolbe> oh, too late
00:07:00 <Quadrescence> haskell's so inefficient yo, it duznt even hav a GOTO or GOSUB command fug dis bad language
00:07:05 <joed> ¬°u çop «ùpƒ±sdn  áƒ± p É«ù…• I u«ù…• ç  é…π…π«ùq û…î…ê Éq  é…Ø …Øo…π…ü  áu«ùS
00:07:22 <roconnor> @type callCC
00:07:26 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
00:07:46 <roconnor> @type control
00:07:49 <lambdabot> Not in scope: `control'
00:08:42 <mdmkolbe> joed: how did you do that? some of the letters I see are "fake" upside down (e.g. lambda for upside down y) but the upside down "w"?
00:09:31 <joed> mdmkolbe: http://www.fileformat.info/convert/text/upside-down.htm
00:09:31 <lambdabot> Title: Unicode Upside-Down Converter
00:09:40 <Quadrescence> Too bad joed forgets that some people encode differently. So I just see that as a clusterfuck of Cyrilic characters.
00:10:06 <mdmkolbe> cool
00:10:07 <joed> Quadrescence: A welter?
00:10:26 <Quadrescence> Welter? :|
00:10:42 <joed> mdmkolbe: Entertaining enough to send to american mid-level managers.... No, you hold it upside down.
00:11:01 <Quadrescence> :))0
00:11:25 <joed> Quadrescence: http://radiganneuhalfen.blogspot.com/2008/01/synonym.html
00:11:25 <lambdabot> Title: Radigan Neuhalfen's Web Log: a synonym
00:11:31 <dolio> @type \f k -> f k id
00:11:32 <lambdabot> forall t a t1. (t -> (a -> a) -> t1) -> t -> t1
00:11:39 <jsnx> Quadrescence: what encoding are you using?
00:13:07 <Quadrescence> I just made it UTF-8. It was on some auto-determine.
00:13:32 <Quadrescence> (since I visit other channels that don't speak English. D:)
00:14:41 <Quadrescence> ÚÂÒÚ ÚÂÒÚ ÚÂÒÚ
00:14:43 <Quadrescence> Okay.
00:15:02 <jsnx> mdmkolbe: so I honestly have no idea how to do your structure
00:15:42 <mdmkolbe> jsnx: so I think I have a solution (though I'm shaking out the performance from it)...I can hpaste it
00:15:42 <jsnx> removing the key due to the priority...
00:15:49 <jsnx> okay
00:16:05 <dolio> @type \f -> Cont (\k -> runCont (f (\a -> Cont (\_ -> k a))) id)
00:16:07 <lambdabot> forall a a1 a2. ((a -> Cont a2 a1) -> Cont a2 a2) -> Cont a2 a
00:16:07 <jsnx> you could have three maps
00:16:34 <jsnx> or six, really
00:17:18 <mdmkolbe> http://hpaste.org/9024
00:17:34 <mdmkolbe> jsnx: two maps (though one is a map of pairs)
00:17:51 <mdmkolbe> performance of insertWith may be suboptimal
00:21:22 <mbz> what is the simplest way to do 2d graphics in Haskell?
00:21:47 <mbz> what library should I use?
00:21:50 * Quadrescence is interested in this question too.
00:22:17 <Quadrescence> (I would be using basic graphics primitives, hopefully with the ability to fill)
00:22:18 <mdmkolbe> mbz: do you want a toy to play around with or something to build a real program with or a futuristic research library
00:22:24 <mdmkolbe> ?
00:22:38 <mbz> mdmkolbe, I just need a simple toy
00:22:43 <jsnx> mdmkolbe: so, this structure has performance problems?
00:23:19 <roconnor> http://sites.google.com/site/haskell/
00:23:22 <jsnx> mdmkolbe: or memory usage?
00:24:18 <mdmkolbe> mbz: the "Haskell School of Expression" library used to have a nice small graphics package (designed as a pedigogical library for students to use, but I never used it myself)
00:26:29 <mdmkolbe> jsnx: well, my program isn't performing as well as I would like, but I'm still trying to track where the time (and allocation) is going.  SCC seems to indicate insertWith, but sometimes SCCs are wrong
00:26:46 <mbz> mdmkolbe, thanks a lot, I'll check it. by the way what library do you use for doing graphics?
00:27:06 <mdmkolbe> mbz: Graphics.OpenGL
00:27:39 <mdmkolbe> mbz: but unless you already know OpenGL it's not for beginers
00:27:58 <majestic> mbz: If you just want 2D vector graphics, check out: http://code.google.com/p/anuplot/ designed for 1st year CS students.
00:27:59 <lambdabot> Title: anuplot - Google Code
00:28:00 <mbz> I used to play with opengl a few years ago
00:28:31 <Quadrescence> No IORefs required in user code! 6 coats of gloss!
00:28:32 <Quadrescence> :)))))
00:29:01 <majestic> :)
00:29:17 <ksandstr> so... is there a turtle graphics library for haskell yet? ;)
00:29:47 <roconnor> somethimes I think I should write one
00:29:58 <mdmkolbe> @faq is there a turtle graphics library for haskell yet?
00:29:58 <lambdabot> The answer is: Yes! Haskell can do that.
00:32:00 <Elly> parser combinators look a lot uglier in prefix than infix
00:32:23 <Quadrescence> @faq Can haskell do my taxes?
00:32:23 <lambdabot> The answer is: Yes! Haskell can do that.
00:32:42 <Quadrescence> @faq Can haskell score me a chick, too?
00:32:42 <lambdabot> The answer is: Yes! Haskell can do that.
00:32:44 <Quadrescence> :D
00:34:23 <roconnor> @vixey do you think Quadrescence is hot?
00:34:24 <lambdabot> me? hot? naw, it's a nice comfortable 73 degrees in here
00:34:54 <Quadrescence> :))
00:35:10 <Quadrescence> roconnor: I am hot. :D
00:35:15 <mdmkolbe> jsnx: yeah, there is definately a performance problem. my program operating on a set of 100,000 is allocating 2.4GB though only 21MB is ever used at the same time.  thus GC is about half my run time
00:35:18 <Quadrescence> In the figurative sense. :D
00:37:01 <mdmkolbe> jsnx: I have a suspision that the list [k] and the pair (p,v) in the structure are at fault, but it is way to early to tell yet
00:41:48 <jsnx> mdmkolbe: http://en.literateprograms.org/Priority_Queue_(Haskell)
00:41:51 <lambdabot> Title: Priority Queue (Haskell - LiteratePrograms
00:42:41 <jsnx> they suggest a binary tree
00:44:12 <mdmkolbe> jsnx: well, I'm basing my work on the assumption that Data.Map does a decent finite map.  What the link you posted fails to do however (data.map also fails to do this) is allow me to access the same data structure from two different keys (one is the priority, p, and the other is the key, k)
00:46:01 <jsnx> mdmkolbe: you need to be able to remove an object of any prority?
00:46:31 <mdmkolbe> jsnx: I only need the object with lowest priority, but the object of any key must be able to be updated
00:47:18 <jsnx> hmmm
00:47:20 <mdmkolbe> (for my application priority and key are two different things)
00:47:51 <ksandstr> mdmkolbe: is your priority value by any chance the result of an error function?
00:48:23 <mdmkolbe> ksandstr: no, it's the huristic of an A*/Dijkstra search
00:48:33 <ikeda_> mdmkolbe, have you looked at Edison?
00:49:01 <mdmkolbe> ikeda_: I have not, but that would be a good idea
00:49:24 <ksandstr> mdmkolbe: ah. it just sounded a lot like the data structure required by a 3d mesh simplification algorithm
00:50:19 <Quadrescence> ksandstr: That just made me want to program such an algorithm. :D
00:50:37 <ksandstr> (i solved this updatability requirement by just sticking the nodes in an Array, and storing the indexes in the priority queue. the C programmer always finds a way to use pointers...)
00:50:39 <mdmkolbe> ksandstr: well if 3d mesh simplification uses dynamic programing techniques (aka shortest path, aka least weight subsequence problem) there maybe a connection
00:50:39 <Quadrescence> I'll put it in my list of ideas (the list has nothing on it yet. :D)
00:51:37 <mdmkolbe> ksandstr: well, you still have to update the priority queue when one of the nodes gets updated (at least in my application)
00:51:42 <ksandstr> Quadrescence: well in that case I may have spoiled it for you
00:52:57 <Quadrescence> ksandstr: Well I'm sure I would be reinventing the wheel.
00:53:06 <Quadrescence> But it would be fun to make, I think.
00:53:41 <ksandstr> Quadrescence: sure. coming up with a nicer error metric than hoppe et al. (i think it was) is also amusing
00:57:31 <mdmkolbe> it looks like edison just implements the standard "key and value" priority queue similar to data.map
00:57:54 <mdmkolbe> anyway good night all
00:57:59 <mdmkolbe> thx for all the help
00:59:34 <jsnx> mdmkolbe: have a priority queue with indices
00:59:44 <jsnx> the indices point into a map
00:59:55 <jsnx> the map's values are modified
01:00:32 <jsnx> PriorityQueue Int
01:00:47 <jsnx> or rather
01:00:51 <jsnx> PriorityQueue Key
01:01:02 <jsnx> oh, bah
01:01:30 <jsnx> PriorityQueue key  ,  Map key (maybe val)
01:01:41 <jsnx> to 'delete' a key set it to Nothing
01:02:19 <jsnx> if it is discovered in the queue, you look it up and ignore the result
01:02:28 <jsnx> i'm pretty stoned, damn
01:03:57 <ksandstr> that'll work unless you want the priority queue to not contain nodes that go nowhere... so... periodical garbage collection of the priority queue then? ;)
01:04:51 <Quadrescence> If I have an integer that will always have the values 0, 1, or 2, and I will have a million of these integers, what's the best option to save memory? :>
01:04:55 <jsnx> ksandstr: sure
01:05:09 <jsnx> once you pop the garbage node, it's gone
01:05:27 <jsnx> Quadrescence: Char
01:05:35 <ksandstr> jsnx: plus you'd have to produce a new identity key for each node whose priority has changed
01:05:35 <jsnx> Quadrescence: Word8
01:05:48 <ksandstr> Quadrescence: bit twiddling!
01:06:35 <Quadrescence> ksandstr: Maybe if the values were 0 and 1, bit twiddling would be nice. :> Or maybe I don't understand bit twiddling
01:06:58 <ksandstr> Quadrescence: just use two bits instead of one?
01:07:09 <jsnx> ksandstr: well, actually i have to wonder what sense there is in this data structure, actually
01:07:25 <jsnx> Quadrescence: twiddle bits two at a time?
01:07:30 <Quadrescence> ksandstr: But then I have a wasted bit!
01:07:31 <Quadrescence> :D
01:07:49 <jsnx> Quadrescence: no, you've wasted half a bit
01:07:59 <Quadrescence> That's what I meant. :D
01:08:04 <ksandstr> jsnx: it provides an alter priority operation, which looks like a difficult thing to do without pointers
01:08:06 <nybyn> a wasted state :)
01:08:22 <ksandstr> Quadrescence: well you could say that it's "reserved for future expansion"
01:08:37 <Quadrescence> ksandstr: GOOD IDEA.
01:08:40 <ski> no, you've wasted
01:08:42 <ski> > 2 - logBase 2 3
01:08:43 <lambdabot>  0.4150374992788437
01:08:43 <jsnx> half a bit is no bit at all!
01:08:44 <ski> bit
01:09:34 <Quadrescence> ski: explain
01:09:43 <jsnx> ski: thank you for your teaching
01:09:49 <Cale> ksandstr: alter priority is easy if insertions and deletions are both cheap :)
01:10:53 <ksandstr> Cale: but the problem as i see it comes from identifying the node that's to be altered
01:11:26 <ski> Quadrescence : a variable that can take 3 possible outcomes, and each of those being equally likely .. the information / amount of surprise you get when you know the actual value it is the logarithm of 3, to the base of 2 (since we're measuring the information in bits)
01:11:49 <ski> s/value it/value of it/
01:12:46 <Quadrescence> Looks like SOMEONE has to go back to basic math.
01:13:03 <Cale> ksandstr: well, I suppose it depends on what you use for an underlying data structure.
01:13:52 <ski> e.g., if you have a variable with 8 possible values, each equally likely, then the information you get when you learn the value is 3 bits, note that this is the logarithm of 8 to the base of 2
01:14:48 <Quadrescence> I see.
01:15:06 <ski> one way to waste less storage bits is to pack several bits together .. e.g. BCD codes 10 possible values in 4 bits
01:15:22 <Quadrescence> Wait, if I am bit twiddlinnnnnnnn, am I just basically storing, for example, four (2 bit) values in a single 8 bit integer/whatever?
01:15:29 <Quadrescence> ski: I think you answered that just now.
01:15:41 <ski> 3*3*3 = 27 <= 32, so you could pack 3 of these 3-valued values in five bits
01:15:56 <ksandstr> Quadrescence: yes. but you might want to not use Word8 for this...
01:16:14 <Quadrescence> ksandstr: Well, that question was conceptual.
01:16:24 <Quadrescence> What do you think I would use if I go with that technique?
01:17:07 <Quadrescence> an Int?
01:17:38 <ksandstr> i'd use something that doesn't involve a boxed integer type, but i'd rather not do that sort of thing in haskell anyhow
01:18:05 <Quadrescence> Ah. :\
01:19:12 <Quadrescence> ksandstr: I hope that wasn't a suggestion to change languages, but rather a suggestion to change methodology.
01:19:35 <jsnx> I wondef if using an enumeration type would be any good?
01:19:35 * ski remembers reading about media-processing in an ML variant with partial evaluation which unrolled bit loops nicely into word-chunks
01:20:01 <jsnx> wow, computer science is just endless
01:20:10 <jsnx> http://en.wikipedia.org/wiki/Fibonacci_heap
01:20:44 <ksandstr> Quadrescence: no, more of a statement of personal preference. i mostly dip into haskell to get away from low-level representation-twiddling things
01:21:22 <Quadrescence> Ah. I see.
01:21:35 <Quadrescence> But, nonetheless, it CAN be done. :>
01:22:26 <jsnx> i've found pointer arithmetic in haskell to be quite workable, too
01:23:29 <Quadrescence> Someone yesterday (maybe 2 days ago, however the logistics of time work out) told me to not use pointers, and if it was necessary, be careful. :O
01:25:32 <ksandstr> it is a bit weird how pointers in Haskell turn out to be nearly exactly the bogeymen that everyone seems to say they are in C...
01:27:06 <Quadrescence> ksandstr: Hahahah, I get it, a BIT weird
01:27:07 <Quadrescence> :}
01:28:57 <Quadrescence> I need to learn about data structures.
01:29:18 <Quadrescence> So I know which kind is the best to implement. D:
01:32:23 <Quadrescence> Anyone know of a page with a comparison of different datastructures (like trees, for example, or linear data structures)?
01:32:44 <Quadrescence> (a comparison of time complexities of various actions and stuff, maybe)
01:33:02 <nybyn> Quadrescence: i'm sure wikipedia has something like that
01:33:13 <Quadrescence> nybyn: I'm lookin around on it
01:33:24 <Quadrescence> I found http://en.wikipedia.org/wiki/List_of_data_structures so far
01:33:25 <lambdabot> Title: List of data structures - Wikipedia, the free encyclopedia
01:34:28 <hml> @src =<<
01:34:29 <lambdabot> f =<< x = x >>= f
01:34:38 <Quadrescence> (in fact, I just care about trees)
01:36:38 <Cale> ksandstr: Usually if an algorithm would involve pointers in C, I use a Data.Map in Haskell.
01:37:56 <Cale> (Well, if it's something which isn't covered by Haskell's usual data structures.)
01:38:28 <ksandstr> Cale: indeed. pointers are, in a way, just another way of uniquely identifying some data item
01:42:37 <jsnx> ksandstr: though they also provide a way to peek into the guts of other data items :)
01:43:39 <Quadrescence> PEEK
01:43:40 <Quadrescence> POKE
01:47:00 <Cale> http://hackage.haskell.org/packages/archive/PSQueue/1.0/doc/html/Data-PSQueue.html
01:47:01 <Quadrescence> Does someone want to tell me a little about bitboards? (I just looked at the wikipedia article)
01:47:02 <lambdabot> Title: Data.PSQueue, http://tinyurl.com/6zm7fe
01:47:18 <Cale> by the way... there's a priority queue with fast insert and delete on keys :)
01:48:31 <Cale> I wonder if a similar structure can be constructed using Data.FingerTree.
01:49:29 <Cale> (and an appropriate choice of monoid)
01:52:14 <dolio> What's the monoid for priority queues? I was wondering that earlier? Min/Max?
01:53:24 <Cale> Well, you can do ordered sequences using the very simple "select the second parameter" monoid
01:53:59 <Cale> (the paper describes how to do that)
01:54:11 <dolio> Yeah, I should probably go re-read the paper. :)
01:54:19 <Cale> data Key a = NoKey | Key a deriving (Eq, Ord)
01:54:55 <dolio> Right now I'm forced to read abou p-adic numbers due to sigfpe's comment on "What Every Computer Scientist Should Know about Floating Point Numbers."
01:54:57 <Cale> and then make that an instance of Monoid with k ++ NoKey = k, _ ++ k = k
01:56:02 <Cale> If you use that monoid, then each subtree is annotated with the last key it contains
01:56:10 <Cale> So all you have to do then is keep them in order.
01:56:55 <Cale> (and once you have an ordered sequence like this, a priority queue is easy because you just make your elements pairs which are compared only by priority)
01:58:38 <Cale> But priority search queues seem a bit harder because they're (at least seemingly) doubly indexed.
01:58:51 <dolio> Yeah.
01:58:53 <Cale> I haven't yet read the paper on how Hinze's PSQ's work though.
01:59:25 <dolio> It's simple, evidently.
01:59:34 <Cale> I'm glad that there's a Hackage package which we can point to whenever people ask for a priority queue now though :)
02:06:45 <Cale> oh, this was added just on the 7th, interesting :)
02:12:14 <hackage> Uploaded to hackage: HsHyperEstraier 0.2.1
02:17:05 <dolio> "Compilers, browsers, word processors, kernels, drivers, instant messengers, p2p software, banking software etc.etc. don't really need a single floating point number."
02:18:22 <Quadrescence> :O
02:18:53 <MyCatVerbs> dolio: correction: nothing needs floating point numbers.
02:19:07 <Quadrescence> I don't need an electric lawn mower either.
02:19:07 <MyCatVerbs> dolio: we're just all too lazy to work in fixed-point arithmetic. ;)
02:19:24 <Quadrescence> Waitaminute
02:19:26 <Cale> Well, fixed point arithmetic has a few other limitations.
02:19:30 <Quadrescence> My lawn mower isn't electric!
02:19:45 <Quadrescence> Wait, yeah it is.
02:19:46 <MyCatVerbs> Quadrescence: are you sure? What about the spark plugs et al?
02:19:48 * Quadrescence will shut up
02:21:03 <dolio> :)
02:21:07 <Quadrescence> "Everything is computed by the "Fast Fourier Transform." This is the greatest algorithm since Newton's method."
02:21:12 <Quadrescence> Tru dat.
02:21:15 <Cale> I'm quite happy with how well the computable reals in the numbers library work
02:22:37 <dolio> Oh, that's what CReal is.
02:22:44 <dolio> I'll have to install that.
02:23:03 <Cale> showCReal 50 pi
02:23:05 <Cale> > showCReal 50 pi
02:23:06 <dolio> Man, I've been wondering for like a month why the "C real" type has so much more precision than Double.
02:23:12 <lambdabot>  "3.14159265358979323846264338327950288419716939937511"
02:23:33 <hml> @src .
02:23:34 <lambdabot> (f . g) x = f (g x)
02:23:34 <lambdabot> -- In lambdabot, it's been generalised to:
02:23:34 <lambdabot> (.) = fmap
02:23:52 <Cale> > showCReal 100 pi
02:23:54 <lambdabot>  "3.1415926535897932384626433832795028841971693993751058209749445923078164062...
02:24:40 <Quadrescence> That is (100 - 27) digits by inspection.
02:24:54 <Cale> Well, lambdabot cuts it off.
02:24:58 <Quadrescence> I know.
02:25:01 <Quadrescence> I am just saying. :>
02:25:12 <Quadrescence> I was supposed to amaze you.
02:25:21 <dolio> > length $ showCReal 100 pi
02:25:22 <lambdabot>  101
02:25:32 <hml> @src >>=
02:25:32 <lambdabot> Source not found. I am sorry.
02:26:04 <Quadrescence> > showCReal (100-27)
02:26:05 <lambdabot>   add an instance declaration for (Typeable CReal)
02:26:09 <Cale> It takes about a minute or so to do 10000, so it's not the most efficient implementation of pi, but it's reasonably fast.
02:26:10 <Quadrescence> > showCReal (100-27) pi
02:26:11 <lambdabot>  "3.1415926535897932384626433832795028841971693993751058209749445923078164063"
02:26:18 <Cale> (for sane uses anyway :)
02:26:18 <Quadrescence> :)
02:26:34 <Quadrescence> I should rewrite the implementation for pi
02:26:35 <Quadrescence> :D
02:27:14 <hml> @src snd
02:27:15 <lambdabot> snd (_,y) =  y
02:27:24 <Quadrescence> Using Chudnovskys' formula. :D
02:27:39 <dolio> > showCReal 10000 pi
02:27:46 <lambdabot>  "Exception: Time limit exceeded
02:27:59 <dolio> Not lazily computing the digits, eh? :)
02:28:11 <Quadrescence> http://en.wikipedia.org/wiki/Chudnovsky_algorithm
02:28:22 <Quadrescence> :}
02:28:24 <Cale> > showCReal 100 (pi^2/6)
02:28:26 <lambdabot>  "1.6449340668482264364724151666460251892189499012067984377355582293700074704...
02:29:24 <Cale> I wonder how it performs relative to plain boxed Doubles :)
02:29:29 <hml> @src x
02:29:30 <lambdabot> Source not found. My brain just exploded
02:29:31 <hml> @src .
02:29:32 <lambdabot> (f . g) x = f (g x)
02:29:32 <lambdabot> -- In lambdabot, it's been generalised to:
02:29:32 <lambdabot> (.) = fmap
02:30:07 <dolio> > x + pi
02:30:09 <lambdabot>  x + pi
02:30:26 * Quadrescence loves the numbers 13591409 545140134 640320
02:30:32 <Quadrescence> They sound so poetic-ish.
02:34:51 <hml> how can I  rewrite f. g
02:34:55 <hml> in lambdata notation?
02:34:57 <hml> *lambda*
02:37:54 <Cale> (\x -> f (g x))
02:40:03 <roconnor> @unpl f . g
02:40:04 <lambdabot> (\ c -> f (g c))
02:41:33 <hml> what if g takes more than 1 argument?
02:41:56 <xerox> ?unpl ((.) . (.)) f g
02:41:56 <lambdabot> (\ c h -> f (g c h))
02:42:02 <roconnor> @unpl (f .) . g
02:42:02 <lambdabot> (\ d i -> f (g d i))
02:42:36 <roconnor> @unpl ((f .) .) . g
02:42:37 <lambdabot> (\ e j m -> f (g e j m))
02:42:44 <mbz> what is the difference between ?unpl and @unpl?
02:42:54 <roconnor> same
04:10:46 <Quadrescence> Goddamn you Haskell. I went to bed just now intending to sleep (it's 6:10 AM), and I got back to program more out of excitement.
04:11:23 <MyCatVerbs> I don't count that as a fault. ;P
04:12:04 <xci> I think that's just the way to go :)
04:13:53 <EvilTerran> eh, haskell's a dream to program in. close enough
04:14:07 <EvilTerran> it's like meditation - you can get just as much relaxation in less time
04:14:51 <Quadrescence> EvilTerran: That wasn't the case when I did an all-nighter last night (well, night before last >:O)
04:15:03 <EvilTerran> whee
04:15:06 <Quadrescence> I went to sleep because I felt delusional when looking at my haskell code
04:15:19 <EvilTerran> did you dream in haskell? i've done that a few times
04:15:44 <Quadrescence> Well, no. But when I was awake and looking at the haskell, the type definitions were...animated... :/
04:16:53 <EvilTerran> yay
04:17:21 <Quadrescence> Then when I looked away from the screen, the haskell code moved with where my eyes went.
04:17:25 <Quadrescence> It was very, very weird.
04:17:49 <_zenon_> uhm, sound weird all right
04:17:54 <Quadrescence> I looked down at my keyboard and I saw
04:17:57 <Quadrescence> data Symm = S_URF3 | S_F2 | S_U4 | S_LR2
04:17:57 <Quadrescence>             deriving(Show, Eq, Ord, Enum)
04:18:06 <Quadrescence> laying on the keys like a cloth
04:18:45 <_zenon_> sounds like it was time for a nap all right
04:18:46 <Quadrescence> s/laying/lying/
04:18:54 <Quadrescence> _zenon_: Hahah, yes, it was.
04:19:14 <Quadrescence> And I woke up an hour before midnight. >:O
04:21:54 <Baughn> Quadrescence: So, which time zone are you in now?
04:22:07 <_zenon_> Quadrescence, got a good idea for a small programming excercise using the State monad?
04:22:21 <Quadrescence> Central time
04:22:32 <Quadrescence> _zenon_: Do I? No.
04:22:39 <Baughn> Central? So you live in china or so/
04:23:03 <_zenon_> Baughn, you then?
04:23:20 <Quadrescence> No. I live in the middle of the US
04:23:21 <Baughn> _zenon_: Hm. Mid-atlantic, I'd say.
04:23:50 <Quadrescence> It's 6:23 am now.
04:23:59 <Baughn> Ah. And you just got up?
04:27:01 <Quadrescence> Baughn: No, I've been up since I last woke up
04:27:03 <Quadrescence> :<
04:27:06 <_zenon_> I live in Sweden
04:27:12 <Quadrescence> I TRIED to get to sleep.
04:27:31 <_zenon_> Luckily, we have the same time all over Sweden
04:27:38 <_zenon_> Hear me out on this Idea:::
04:28:14 <_zenon_> Would it not be great if ALL watches had radio receivers, and each town had it's own time-tower, so that everyone inside the town has the same time on their clock?
04:28:41 <_zenon_> The same for the university, so that all lecturers and students had the same time
04:29:40 <Baughn> Quadrescence: THen your timezone isn't us central
04:29:53 <_zenon_> So, whenever you get to a new town / country etc. You are guaranteed to have a perfect time.
04:29:55 <Quadrescence> Yes it is...?
04:30:10 <Baughn> Quadrescence: http://xkcd.com/448/
04:30:10 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
04:30:33 <Quadrescence> AHhahaha
04:30:36 <Quadrescence> OH.
04:30:54 <Quadrescence> MYYYYYYY time zone right now is...
04:31:03 <EvilTerran> i use that kinda thing - i seem to end up in the east coast of america pretty often
04:31:08 <EvilTerran> (i'm really in britain)
04:31:36 <_zenon_> EvilTerran, then you eat fish and chips!
04:31:43 <EvilTerran> yes
04:31:49 <EvilTerran> <_<  >_>
04:32:30 <EvilTerran> i also drink ale, smoke a pipe, and complain incessantly about the weather :P
04:32:40 <Baughn> I'm about six hours west of where I'm supposed to be now. It's justified, though; the sun never sets here.
04:32:58 <_zenon_> And take afternoon tea with a little bear wearing a red hat, and eat marmelade covered scones
04:33:19 <_zenon_> And hunt foxes, riding on a trusty steed.
04:33:51 <_zenon_> EvilTerran, Well, the pipe part would be nice.
04:34:32 <_zenon_> Where are you from Baughn?
04:34:54 <Baughn> .no
04:34:58 <EvilTerran> _zenon_, actually, everything i said was true :P
04:35:38 <_zenon_> EvilTerran, hmmm.... I'll have to take your word for it. @weather:: I will leave Sweden as soon as I'm done.
04:35:46 <Baughn> Quadrescence: Oh, one thing.. after your hallucinative haskell-coding fest, did you have to delete/rewrite most of the code you wrote?
04:36:13 <EvilTerran> (incidentally, it's far too hot here at the moment)
04:36:17 <Quadrescence> Baughn: Actually, no. Because I didn't write much in the first place. :D
04:36:20 <Quadrescence> :D though.
04:36:26 <Quadrescence> I suck at haskell
04:36:32 <Quadrescence> and my cat just barfed on the carpet
04:36:49 <Quadrescence> ah, there she barfed again
04:37:03 <_zenon_> She unsafePerformIO:d on your carpet :)
04:37:06 <Baughn> Quadrescence: Good luck with that. Be sure to inspect the barf for worms.
04:37:12 <Quadrescence> 3 times
04:37:16 <Quadrescence> WHAT DID SHE EAT
04:37:23 <Baughn> Mice.
04:37:27 <_zenon_> Grass?
04:37:29 <Quadrescence> >:(
04:37:33 <Quadrescence> She doesn't go outside
04:37:38 <_zenon_> Our dog constantly eats grass, and barfs.
04:37:38 <EvilTerran> unsafeInvertFunction# (cat :: Food -> IO Poop)
04:37:44 <Baughn> ..that's not a real cat, then
04:37:47 <_zenon_> EvilTerran, :)
04:38:05 <_zenon_> Baughn, define real.
04:38:27 <Valodim> real = more than integer
04:38:28 <Valodim> hehe
04:38:39 <Baughn> _zenon_: Tiny psychopath that would do anything to get her way, enjoys torturing smaller animals to death, and goes out of her way to find more to torture.
04:38:44 <EvilTerran> it's an imaginary cat?
04:38:52 <Baughn> We have three cats.
04:38:52 <_zenon_> Baughn, hehe, sounds like a real cat :)
04:38:55 <Baughn> EvilTerran: It's an uncat
04:39:02 <EvilTerran> cocat?
04:39:11 <_zenon_> caT
04:39:19 <Quadrescence> After calculating my timezone
04:39:27 <Quadrescence> I'm in the middle east right now
04:39:28 <Baughn> (Which took a while)
04:39:38 <Quadrescence> Baughn: I get confused with arithmetic
04:39:39 <Baughn> Ooh, that's impressive
04:39:56 <Baughn> Quadrescence: So you have nearly a 24-hour offset?
04:40:08 <Quadrescence> Yeahpppppp
04:40:14 <_zenon_> Why does the US use  am   pm ?
04:40:26 <Quadrescence> Because we like modulo arithmetic. D:
04:40:29 <Baughn> For the same reason they don't use metric
04:40:49 <Baughn> The *entire* rest of the world has adopted metric. You'd think..
04:41:02 <_zenon_> Baughn, yes, it's tragic.
04:41:21 <Baughn> Oh, wait. Not the entire world.
04:41:31 <Baughn> The USA, Liberia and Myanmar. Good company there. ^_^
04:41:51 <_zenon_> : (fix "D")
04:43:25 <_zenon_> I heard there was some proposal in the 90's to use SI units.
04:43:56 <bremner> _zenon_: also to have health care :-)
04:44:13 * bremner is sorry for getting even further off topic
04:44:14 <Quadrescence> Some Americans really hate metric.
04:44:55 <_zenon_> http://en.wikipedia.org/wiki/United_States_customary_units
04:44:56 <lambdabot> Title: United States customary units - Wikipedia, the free encyclopedia
04:45:08 <_zenon_> Quadrescence, why?
04:45:18 <Quadrescence> I gave someone a measurement in meters, and they're like "I don't use that metric crap"
04:45:28 <Quadrescence> I don't know why. :<
04:46:03 <_zenon_> hehe.. hilarious
04:48:26 <_zenon_> @remember Quadrescence "I gave someone a measurement in meters, and they're like "I don't use that metric crap""
04:48:26 <lambdabot> It is stored.
04:48:39 <Quadrescence> Ahahah
04:49:14 <_zenon_> I have to remember that "I don't use that metric crap", it says so much, and yet so little.
04:50:09 <_zenon_> I saw Hancock yesterday
04:50:35 <_zenon_> Is "hancock" slang for something?
04:51:08 <Deewiant> http://www.urbandictionary.com/define.php?term=hancock
04:51:08 <lambdabot> Title: Urban Dictionary: hancock
04:51:59 <_zenon_> hmmm....
04:52:26 <Quadrescence> It's not a common word here at all...
04:52:58 <Deewiant> never heard it myself
04:53:19 <_zenon_> Maybe there was no special meaning to it then.
04:54:48 <_zenon_> Damn it
05:03:02 <aBeing> Hello.
05:04:09 <aBeing> I have a newbie syntax question.  I'm trying to define a type for functions which is a list onto a list onto a value....
05:04:37 <aBeing> It goes "type Prisoner = [Choice] => [Choice] => Choice"
05:04:46 <kpreid> aBeing: you want ->, not =>
05:04:48 <Deewiant> -> not =>
05:04:49 <_zenon_> http://hpaste.org/9027
05:05:00 <_zenon_> I have a State monad problem
05:05:00 <aBeing> Ah!
05:05:11 <Deewiant> ?ty (head .) . (++)
05:05:12 <lambdabot> forall a. [a] -> [a] -> a
05:06:06 <aBeing> kpreid, Deewiant: Thanks.
05:06:26 <kpreid> _zenon_: why do pf and add return the CommandType?
05:06:38 <_Dae_> _zenon_: what problem?
05:07:12 <kpreid> _zenon_: also, since you don't use the return value perhaps you should use execState instead of runState; that drops the 'snd'
05:07:18 <_zenon_> kpreid, well, initially I thought it could be nice to know the last command. However, I thought there maybe existed some function doing what runRobotS does
05:07:29 <kpreid> oh...
05:07:31 <kpreid> mapM_
05:07:41 <kpreid> mapM_ pf commands
05:08:06 <_zenon_> kpreid, mhmm... I never reasoned that mapM_ would behave like that for State. Thanks :)
05:08:08 <kpreid> (I saw what you were asking for, but it took a bit for me to think of the answer)
05:08:29 <kpreid> _zenon_: well, at this level, which monad it is is irrelevant
05:08:42 <kpreid> you have an action function, pf, and you want to sequence its action given a list of parameters...
05:09:57 <kpreid> _zenon_: btw, even if mapM_ weren't right here, the original code smells funny in that it repeatedly "enters" and "exits" the state monad (via runRobot). Which isn't to say that that isn't the right thing for some purposes; just that it's to be suspicious of
05:10:19 <Baughn> > execState (do put 5; mapM_ (modify (+1)) [1..5]; return 42) 400
05:10:23 <lambdabot>  Couldn't match expected type `State s b' against inferred type `()'
05:11:04 <Baughn> ..what did I do?
05:11:11 * kpreid can't see it either
05:11:22 <kpreid> @type (do put 5; mapM_ (modify (+1)) [1..5]; return 42)
05:11:22 <lambdabot>     Couldn't match expected type `t b' against inferred type `()'
05:11:22 <lambdabot>       Expected type: a -> t b
05:11:22 <lambdabot>       Inferred type: a -> ()
05:11:37 <kpreid> @type mapM_ (modify (+1)) [1..5]
05:11:38 <lambdabot>     Couldn't match expected type `m b' against inferred type `()'
05:11:38 <lambdabot>       Expected type: a -> m b
05:11:38 <lambdabot>       Inferred type: a -> ()
05:11:43 <kpreid> @type mmodify (+1)
05:11:43 <lambdabot> Not in scope: `mmodify'
05:11:45 <kpreid> @type modify (+1)
05:11:46 <lambdabot> forall s (m :: * -> *). (MonadState s m, Num s) => m ()
05:11:54 <kpreid> ah, that has no parameter
05:12:07 <Baughn> Ooh, right
05:12:23 <Baughn> > execState (do put 5; mapM_ (\n -> modify (+n)) [1..5]; return 42) 400
05:12:28 <lambdabot>  20
05:12:51 <kpreid> @pl (\n -> modify (n+))
05:12:51 <lambdabot> modify . (+)
05:13:08 <_zenon_> kpreid, yeah, I'll rewrite this.
05:17:23 <_Dae_> @src sum
05:17:24 <lambdabot> sum = foldl (+) 0
05:17:55 <Baughn> foldl', more like
05:18:27 <Baughn> (If foldl' is tail-recursive, am I allowed to call foldr head-recursive?)
05:22:31 <_Dae_> Baughn: No... you could call it tongue recursive though...
05:23:00 <Baughn> fmap's the one with the forked tongue, not foldr
05:23:47 <_Dae_> I thought that was forkIO?
05:24:06 <Baughn> forkIO's more like a.. bacteria, I guess
05:24:56 <_zenon_> kpreid, I rewrote it now, I skipped the "entering" and "exiting"
05:25:00 <_zenon_> kpreid, thanks
05:26:08 <_Dae_> Baughn: only if you make it recursive, ie like the forkbomb that took down lambdabot
05:26:32 <Baughn> _Dae_: No forkbomb took down lambdabot. That was simple memory exhaustion.
05:26:41 <Baughn> Which has since been impossibilified
05:27:10 <Baughn> > let x = [1..] in (tail x, head x)
05:27:12 <lambdabot>  ([2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
05:27:18 <_Dae_> Baughn: well... forbomb...ish....
05:27:19 <Baughn> > let x = [1..] in (last x, head x) -- Oops
05:27:24 <lambdabot>  (
05:27:42 <zachk> i went into ##c++ and i asked if there was an eval bot for c++, there is, it is called geordi, but it is written in haskell :-D
05:27:53 <_Dae_> rofl!
05:27:56 <_zenon_> Nice.
05:27:56 <_Dae_> @bot
05:27:57 <lambdabot> :)
05:27:59 <_zenon_> Nice indeed
05:28:18 <Baughn> Something's broken the error printing but good. :/
05:28:23 <_Dae_> Well, writing one in c++ would be.....
05:28:33 <zachk> a pain
05:28:46 <_Dae_> putting it mildly, yes
05:29:18 <zachk> i wish libpurple had telnet in it too
05:29:41 <zachk> then i would only need like 3 programs, firefox, vim, pidgin, and ghc well thats 4
05:30:43 <_zenon_> I have some key binding I am unaware of that logs me out... just happens sometime.. have to fix this
05:30:59 <_zenon_> zachk, what syntax highlight do you have for Haskell?
05:31:28 <zachk> standard vim 7.
05:31:38 <zachk> under windows
05:31:53 <zachk> my ide is three command prompts, vim , ghci, a place to run binaries
05:32:20 <_zenon_> oh. okay, I'm also using std vim syntax high. looking for something better though
05:32:33 * _zenon_ must go to the men's room
05:33:27 <_Dae_> _zenon_: emacs.....
05:33:43 <_zenon_> _Dae_, I don't like emacs.
05:33:49 <_zenon_> 2weird keybindings
05:34:10 <_zenon_> weirdify :: Editor -> Emacs
05:34:15 <_Dae_> well... you get used to it....
05:34:23 <_zenon_> which also happens to be fixpoint
05:34:26 <_Dae_> and it's not like vim is a lot better
05:35:32 <_zenon_> maybe not, but at least you type the commands into vim, emacs "in my own unscientific opinion" is all Ctrl+X+^  X+^M and so forth
05:35:41 <_zenon_> So, we all have our likings :)
05:36:45 <thoughtpolice> M-x viper-mode
05:36:47 <thoughtpolice> there you go
05:36:59 <thoughtpolice> because yes, haskell-mode for emacs is one of the best things ever.
05:37:01 <schme> eh.
05:37:08 <schme> Just run vim inside emacs.
05:37:19 <schme> thoughtpolice: What's so good about haskell-mode?
05:37:26 <thoughtpolice> yeah, M-x ansi-term works pretty well
05:37:41 <Baughn> _zenon_: emacs :: code -> editor
05:37:55 <thoughtpolice> schme: lots of auto-completion features, and inf-haskell has a lot of little nicities
05:38:03 <Mitar> why i get an occur check error with this rule: {-# RULES "qMagnitudeSquared" forall q. q * q = qMagnitudeSquared q #-}
05:38:16 <schme> thoughtpolice: I see. I can't even get it working, so I don't know there.
05:38:19 <thoughtpolice> http://haskell.org/haskellwiki/Haskell_mode_for_Emacs
05:38:20 <lambdabot> Title: Haskell mode for Emacs - HaskellWiki
05:38:35 <thoughtpolice> schme: why? it's real simple to install
05:38:36 <_Dae_> there's an rpm for it somewhere
05:39:05 <_Dae_> also, compiling with Ctrl+c i really neat
05:39:20 <zachk> i have tried emacs, quite a few times its key bindings never stick, yes i know they are configurable in elisp
05:39:48 <schme> thoughtpolice: Yes, it does seem easy to install. But it also seems not to be working. I M-x run-haskell, and whatever I type at the ghci repl results in absolutely nothing 'cept a message in the mini-buffer saying "No errors yet."
05:40:01 <schme> "No more errors yet." even.
05:40:02 <_Dae_> that being said, I would still prefer something more akin to netbeans....
05:40:03 <Mitar> i would like to add a rule that multyplying the value with itself uses specialized function for this cas
05:40:04 <Mitar> case
05:40:39 <aBeing> Is there a way to limit the values that a Int variable can take.  For example something like: data Payoff = 0 | 1 | 3 | 5  ?
05:41:07 <thoughtpolice> schme: quite weird
05:41:07 <mauke> data Payoff = P0 | P1 | P3 | P5
05:41:13 <thoughtpolice> schme: tbh, the author doesn't make releases that often
05:41:19 <thoughtpolice> and the CVS is supposed to have a lot of bugs fixed
05:41:20 <schme> thoughtpolice: Indeed.
05:41:23 <mauke>   deriving (Read, Show, Eq, Ord, Enum, Bounded)
05:41:48 <schme> thoughtpolice: I only use emacs for C and CL nowadays. slime works like a charm, if haskell-mode is anything like it then I'm quite sure it's great.
05:41:53 <schme> But really.. vim is a nicer editor ;)
05:42:15 <thoughtpolice> schme: well from my limited experience with CL a year or two ago, slime is pretty boss. i don't quite know if haskell-mode is up there yet, but it's definitely nice
05:42:23 <_Dae_> Mitar: I think maybe you need to remove the spases in q * q?
05:42:41 <Mitar> nop
05:42:48 <schme> thoughtpolice: cools. Well I'll try and get it working again sometime. :)
05:42:56 <thoughtpolice> schme: well I'm biased, when I first installed linux emacs was recommended to me so I just learned it.
05:43:02 <_Dae_> Mitar: but what is the error exactly?
05:43:09 <Mitar>     Occurs check: cannot construct the infinite type: a = Quaternion a
05:43:10 <Mitar>       Expected type: Quaternion a
05:43:10 <Mitar>       Inferred type: a
05:43:25 <schme> thoughtpolice: I see.
05:43:29 <thoughtpolice> ever since, whenever I try to use vim I feel as if I'm just mentally torturing myself, or vim os torturing me
05:43:33 <thoughtpolice> or something
05:43:36 <Mitar> ohh
05:43:37 <schme> thoughtpolice: Well I'm a bit biased too, being an emacsen developer and all ;)
05:43:38 <kpreid> Mitar: are you sure qMagnitudeSquared has the right type?
05:43:39 <Mitar> my mistake
05:43:40 <Mitar> ups
05:43:43 <Mitar> :-)
05:43:51 <Mitar> i should use qSquared
05:43:52 <Mitar> :-)
05:44:18 <zachk> _Dae_: net-beans is dope for writing java code that compiles correct the first time
05:44:26 <thoughtpolice> I get frusterated when something has the default editor set to vim and I try C-x C-s to save my stuff
05:44:43 <thoughtpolice> because then all hell breaks loose and ^X mode or whatever confuses me. :(
05:44:52 <zachk> i like alf+f s myself
05:44:52 <schme> hahahaha.
05:44:59 <mauke> C-x C-s doesn't do anything in my vim
05:45:01 <zachk> then hit esc a few times
05:45:08 <schme> the emacsen sure are a nicer desktop environment, vim.. much nicer editor :)
05:45:09 <_Dae_> zachk: Yeah...I just ahpen to like true-autocomplete.... and IDE's.... but nothing like that is really available for haskell
05:45:17 <mauke> C-x decrements the number under the cursor and C-s is unbound
05:45:23 <thoughtpolice> mauke: in insert-mode
05:45:47 <_zenon_> vim is nice
05:45:58 <mauke> oh, that's "find spelling suggestions for word under cursor"
05:46:07 <_Dae_> still needs an auto-indent feature though....
05:46:08 <zachk> i just use w! q! and wq!
05:47:01 <zachk> does darcs handle cabal depedencies?
05:47:02 <mauke> and it's cancellable with <esc>
05:47:12 <thoughtpolice> tbh I should seriously invest time into learning elisp
05:47:28 <thoughtpolice> zachk: what do you mean?
05:48:27 <zachk> there is a mud client in haskell, called yogurt, ive started mudding again using just telnet, it would be nice to run a client written in a language i like, it has multiple package depedencies and comes as a cabal package, will cabal download and install the dependencies, or do i need darcs to do that
05:48:46 <thoughtpolice> cabal can do it
05:48:50 <thoughtpolice> just do 'cabal install yogurt'
05:49:00 <thoughtpolice> (providing you have cabal-install, well, installed)
05:49:16 <schme> Is there anything in Haskell for distributed computing?
05:49:16 <zachk> which i dont :D does cabal work on m$ window$?
05:49:26 <thoughtpolice> zachk: yeah
05:49:26 <dcoutts> zachk: yes it does work on windows
05:49:38 <thoughtpolice> zachk: but it can't upgrade itself cleanly as of right now
05:49:53 <thoughtpolice> because you can't overwrite executables while they're running
05:50:01 <schme> thoughtpolice: elisp is not half bad :)
05:50:04 <zachk> do i need to upgrade it once i install it?
05:50:05 <_zenon_> _Dae_, vim has autoindent
05:50:10 <thoughtpolice> zachk: just install cabal-1.4.0.1 and cabal-instal 0.5 from http://haskell.org/cabal
05:50:11 <lambdabot> Title: The Haskell Cabal
05:50:27 <thoughtpolice> schme: I've looked into several guides, just never invested the time to read them seriously
05:51:02 <Mitar> why does {-# RULES "q*q/qSquared" forall (q :: (RealFloat a) => Quaternion a). q * q = qSquared q #-} not fire for qn * qn where qn is of type Quaternion?
05:51:15 <zachk> so under windows i just need to manually update cabal?
05:51:20 <dcoutts> @tell golubovsky Cabal data-files is exactly what you want Neil's blog post explains it
05:51:20 <lambdabot> Consider it noted.
05:51:41 <thoughtpolice> zachk: cabal-1.4.0.1 and cabal-install 0.5 are the latest
05:51:45 <thoughtpolice> if a new version comes out
05:51:55 <thoughtpolice> you'll have to rename cabal.exe to something like, say, cabal2.exe
05:52:00 <schme> thoughtpolice: I think there is some half decent tutorial built in if you're using gnu emacs. With exercises and shit.   Best thing is of course to learn the basics, then write some apps with help of the elisp reference :)
05:52:04 <thoughtpolice> then do 'cabal2 upgrade Cabal cabal-install'
05:52:28 <dcoutts> zachk: on windows the trick to using cabal-install to update itself is to rename the existing cabal.exe to cabal-foo.exe and run that. Problem is it cannot overwrite it's own exe file so the workaround is to rename it.
05:52:30 <thoughtpolice> schme: I actually think I turned to yegge's elisp guide for those who are clueless but thanks, I'll look into it.
05:55:37 <thoughtpolice> schme: if you're an emacsen developer, what'd you work on btw?
05:56:47 <zachk> hugs turned me off to haskell, then i found out about ghc and ghci
05:57:02 <zachk> why is hugs recommended for "beginners" over ghc?
05:57:46 <_zenon_> zachk, uhm. no idea
05:57:53 <_zenon_> zachk, nice error messages?
05:57:54 <thoughtpolice> friendlier err messages?
05:58:06 <zachk> ghc's arent that bad, ive seen error messages before
05:58:22 <mauke> zachk: hugs isn't recommended for beginners
05:58:43 <zachk> mauke: no??
05:58:44 <thoughtpolice> ghc once told me I made its brain explode.
05:58:48 <mauke> no.
05:58:48 <thoughtpolice> don't quite remember the circumstances.
05:59:07 <mauke> thoughtpolice: existential types
05:59:28 <zachk> what the heck are existential types
05:59:29 <eipi-1> hello, I'm new to haskell and was wondering if there is a specific framework/modules that would be best appropriate for building distributed application (several agents, locating on different computers and communicating via messages)
05:59:55 <mauke> data T = forall a. T a
06:00:12 <mauke> f x = let T y = x in ()
06:00:44 <zachk> T a looks like a monad to me, but it probably doesnt follow the rules for monads...
06:00:47 <schme> thoughtpolice: At the moment I'm working on some ffi stuff for libusb and libxmlrpc.  Main plan is to later use 'em for writing an elisp UI for my mp3 player, and an elisp UI for rtorrent.  And as some side projects I'm adding magellan 3d mouse support, and FB-dev support.
06:00:51 <zachk> and that will implode ghc mauke?
06:01:13 <mauke> zachk: try it
06:01:50 <mauke> (T can't be a monad because its kind is *)
06:01:53 <schme> thoughtpolice: I do imagine I'll have to add some libgpod support.. For the ipod fuckers :)
06:02:12 <thoughtpolice> schme: adventurous. :)
06:04:01 <schme> thoughtpolice: And I guess I'm supposed to fix some other stuff I got assigned to me, but those are just.. less.. fun.. like varargs for the ffi. :S
06:04:09 <zachk> mauke: not a constructor: forall
06:04:14 <schme> thoughtpolice: All good fun anyway.
06:04:20 <mauke> zachk: -fglasgow-exts
06:04:25 <thoughtpolice> zachk: -XExistentialTypes
06:04:25 <schme> well smoke time
06:04:31 <zachk> both of those?
06:04:38 <thoughtpolice> zachk: either one
06:05:10 <thoughtpolice> -fglasgow-exts stopped implying just about every extension to the system so I normally just use the specific option
06:06:05 <zachk> -XexistentialTypes didnt work, unrecognized flag, but -fglasgow-exts did explode ghc's brain
06:06:21 <Deewiant> s/Xe/XE/
06:06:33 <thoughtpolice> yeah, it has to be exactly '-XExistentialTypes'
06:07:13 <zachk> i type it correct the first time, still not working, though i have 6.8.2
06:08:15 <thoughtpolice> oh wait duh
06:08:21 <thoughtpolice> it's actuall -XExistentialQuantification
06:08:27 <thoughtpolice> s/actuall/actually/
06:08:34 <thoughtpolice> my bad
06:09:02 <Japsu> If it walks like a monad and quacks like monad, then it must be a ...
06:09:05 <zachk> brain blew up again
06:09:43 <zachk> so haskell'
06:09:51 <zachk> type system isnt strong enough?
06:09:53 <_zenon_> Japsu, monads don't quack
06:09:58 <thoughtpolice> but yeah existential types can get you sometimes. when I was writing my IRC bot I used them so I could specify a list of plugins where each plugin was of a different type
06:10:09 <thoughtpolice> i had to go through several revisions of some code before I could ever get anything to typecheck
06:10:18 <thoughtpolice> they're pretty useful, though.
06:10:23 <zachk> kind of like <god-forbid> generics from java?
06:10:26 <Japsu> _zenon_: I'm sure one can construct a monad that does!
06:10:33 <Japsu> mmmh, generics
06:10:35 <_zenon_> Japsu, monads go "muuuuuu"
06:11:50 <_zenon_> http://pixhost.eu/avaxhome/avaxhome/2007-12-25/Monad_132.jpg
06:12:03 <_zenon_> It's a real book
06:12:23 <Japsu> Heh
06:12:36 <thoughtpolice> zachk: with some extensions you can do anything you want at the type level (literally)
06:13:00 <mauke> thoughtpolice: I'd like to fork() at the type level
06:13:01 <thoughtpolice> of course then you aren't in haskell98 land anymore, but haskell' will add a lot of useful extensions
06:13:32 <thoughtpolice> some of which I wonder how we'd get by without them, i.e. multi parameter type classes
06:13:39 <zachk> ok, i compiled cabal install, do i run setup for it like i did with cabal?
06:14:10 <thoughtpolice> zachk: if it's installed, all you should need to do is 'cabal update' and then 'cabal install <pkgname>'
06:14:29 <thoughtpolice> cabal update will update the list of known packages from hackage.haskell.org, install, well, installs.
06:14:38 <thoughtpolice> mauke: well okay, the type system becomes turing complete.
06:14:40 <RayNbow> @djinn (e -> e -> a) -> (e -> a)
06:14:41 <lambdabot> f a b = a b b
06:15:11 <mauke> @. pl djinn (e -> e -> a) -> (e -> a)
06:15:11 <lambdabot> f = join
06:16:07 <zachk> does cabal out of the box have an install feature?
06:16:42 <dcoutts> zachk: yes, see cabal --help for the full list of commands
06:17:15 <thoughtpolice> btw I've been meaning to ask this,
06:17:40 <thoughtpolice> cabal install hsgnutls fails, because it determines the latest version os 0.2.3.1, but on hackage you can see the full version string is actually '0.2.3.1-barracuda'
06:17:45 <zachk> i have no cabal under windows :-( must go find it
06:17:53 <zachk> though i just installed it
06:17:54 <zachk> mmm
06:18:13 <dcoutts> zachk: where did you install it? perhaps it's not on your %PATH%
06:18:19 <zachk> its probably not
06:18:29 <zachk> how do i modify my path under ms?
06:18:37 <thoughtpolice> should hsgnutls be reuploaded without the '-barracuda' on the end? or should cabal-install take into account the fact it has the tag at the end?
06:18:41 <dcoutts> thoughtpolice: yeah, the version tags mess things up, we don't know how to compare them
06:18:59 <mar77a> you can append to it doing something like set %PATH% = %PATH%;more stuff
06:19:00 <thoughtpolice> i take it cabal-install just constructs the url in the form pkgname-pkgver and only uses numeric IDs
06:19:00 <mar77a> iirc
06:19:22 <zachk> mar77a: yes but will that stick between reboots?
06:19:22 <dcoutts> thoughtpolice: no, it's a more pervasive problem
06:19:49 <dcoutts> thoughtpolice: tags are not taken into account in the Ord instance, so when then end up in maps, etc who knows what happens.
06:19:57 <dcoutts> then/they
06:20:09 <thoughtpolice> ah
06:20:15 <dcoutts> indeed it's not at all clear how we should compare versions with tags
06:20:31 <dcoutts> 0.2.3.1-barracuda > 0.2.3.1  ??
06:20:47 <dcoutts> our solution is to ban them
06:20:57 <thoughtpolice> dcoutts: the easiest fix would be just to say that the version specification in cabal can only be a numeric entity
06:20:58 <dcoutts> packages with version tags cannot be uploaded anymore
06:21:03 <thoughtpolice> yeah
06:21:15 <dcoutts> thoughtpolice: we currently use Data.Version which allows tags.
06:21:24 <dcoutts> I'm going to propose that we remove the tags from Data.Version
06:21:29 <thoughtpolice> hm.
06:21:51 <thoughtpolice> dcoutts: well for the time being I think I might just reupload hsgnutls as 0.2.3.2 and without the -barracuda tag since it breaks cabal-install
06:22:00 <dcoutts> thoughtpolice: that would be good
06:22:06 <thoughtpolice> having it fail because of corner cases like this isn't something anyone likes
06:22:12 <dcoutts> indeed
06:22:20 <dcoutts> and it's not going to be fixed
06:22:24 <dcoutts> only ignored
06:22:42 <dcoutts> I mean the improvement I can make to cabal-install is for it to completely ignore packages with tags
06:22:47 <dcoutts> as if they do not exist on hackage
06:23:29 <thoughtpolice> i'd have to say the easiest solution would just be to simply ban them, yeah.
06:23:45 <thoughtpolice> if anything tags like that can be specified as apart of the package name
06:24:17 <zachk> ok cabal says it installed, but i am not finding a cabal.exe anywhere
06:24:25 <mar77a> zachk: use autoexec.bat for that
06:25:17 <zachk> ty
06:25:32 <zachk> mar77a: you on windows?
06:25:37 <mar77a> XP, yeah
06:27:09 <dcoutts> zachk: if you did a global install then it ends up in Program Files/Haskell/bin/
06:27:46 <zachk> mar77a: what do i need to do to get cabal working? i did all the setup commands, it installed somewhere, dcoutts: i did a --user install, mar77a: is there a cabal.exe?
06:28:37 <mar77a> sorry i have no experience with that
06:28:42 <mar77a> isn't there a .msi?
06:28:50 <zachk> !
06:29:01 <dcoutts> zachk: what version of the Cabal lib are you using? ghc-pkg list Cabal
06:29:06 <zachk> i just had a tar.gz
06:29:21 <dcoutts> the default install location for --user changed between 1.2 and 1.4
06:29:50 <zachk> im using 1.4.0.1 i just downloaded it compiled it configured it built it and installed it
06:30:04 <mauke> wait, what
06:30:16 <mauke> are we talking about Cabal or cabal-install here?
06:30:50 <zachk> im talking about cabal
06:31:51 <mauke> what is "cabal"?
06:32:02 <zachk> ok Cabal, under ms windows
06:32:13 <mauke> Cabal is a library
06:32:14 <dcoutts> zachk: there are two packages "Cabal" the library and "cabal-install" the command line .exe tool
06:32:16 <zachk> i am looking for the binary so i can add it to my path
06:32:17 <zachk> ohhh
06:32:37 <dcoutts> zachk: you already have some version of the Cabal library installed
06:32:56 <zachk> the install library says i need some version of HTTP and zlib greater then 0.4
06:33:01 <dcoutts> since one comes with ghc and you probably installed a newer version too
06:33:26 <dcoutts> zachk: so my question was, what version of the Cabal lib are you using?
06:33:26 <dcoutts> ghc-pkg list Cabal
06:33:26 <dcoutts> will say
06:34:30 <Toxaris> zachk: to install cabal the .exe you have to install cabal-install the Cabal package + it's dependencies using Cabal the library, your webbrowser and a third-party tar extract tool
06:34:50 <thoughtpolice> dcoutts: okay I reuploaded it and changed the version so cabal-install should handle it correctly. but yeah I think it needs to be addressed because if people keep adding tags then more stuff won't be cabal-installable
06:34:57 <Saad_> Hey guys, is there a package which supports getting webcam feed in haskell?
06:35:38 <Toxaris> zachk: then you have to find out where "cabal.exe" was placed. on my system, and *not* using --user, it is C:\Program Files\Haskell\bin
06:36:28 <Toxaris> zachk: which is in my path. so after the quite tedious first install of cabal-install, i can just use cabal-install whatever to get whatever.exe in my path :)
06:37:33 <Toxaris> (which is totally insecure since I trust the cabal packages I download to not place bad exe files on my path)
06:37:39 <Toxaris> but I don't care
06:38:03 <thoughtpolice> viral haskell? never!
06:40:29 <zachk> how do i get the HTTP and zlib dependencies i need for cabal-install
06:40:45 <thoughtpolice> zachk: those you do have to download and install manually.
06:40:47 <mauke> download them from hackage
06:40:58 <dcoutts> thoughtpolice: new packages using tags cannot be uploaded. hackage now rejects them.
06:41:14 <dcoutts> zachk: they're available from hackage, just download and install them.
06:41:17 <Saad_> I guess no-one here knows :(
06:41:47 <povman> http://hpaste.org/9028
06:42:47 <zachk> Saad_: knows what?
06:43:24 <zachk> povman: nice
06:43:29 <povman> is there a nicer way of defining CShow? I pretty much want to redefine Show for String and leave it for everything else?
06:43:44 <Saad_> zachk, I tried searching for a webcam feed library in haskell with no luck, so I was hoping maybe someone here might know of a library that allows for me to get a webcam feed in haskell
06:44:16 <zachk> Saad_: i know nothing about webcam feeds, im sort of new to haskell, but i have not heard of any webcam feed packages for haskell
06:44:31 <Saad_> zachk, Alright. Thanks anyway :)
06:44:39 <Saad_> I'll do a bit more looking around
06:44:40 <zachk> @faq can Haskell do webcam feeds?
06:44:43 <Toxaris> zachk: I used this script for installing cabal packages in the pre-cabal-install times: http://hpaste.org/9029
06:44:47 <lambdabot> The answer is: Yes! Haskell can do that.
06:45:04 <Toxaris> zachk: but it needs tar and wget :) and you have to add --user if you want it
06:45:09 <atp> povman: you can make types instances of classes with an extension
06:45:12 <dcoutts> Toxaris: maybe it'd be easier if I made a cabal.exe available
06:45:20 <atp> povman: that's most commonly used to make String instances
06:46:29 <Toxaris> dcoutts: yeah, the current situation kind of sucks: you have to learn about manual dependency management to set up a automatic dependency management tool to allow you to forget about manual dependency management
06:46:38 <zachk> would i want the latest package from hackage, or just the highest version number, or are those both the same?
06:47:00 <povman> atp: hmm. i'm being nutty, but i just want a function that does exactly the same as Show on all types except [Char] and Char (want to remove quotes)
06:47:23 <maltem> zachk: Would be funny if those weren't the same
06:47:31 <Toxaris> zachk: for dependencies? "runhaskell Setup.hs configure" should tell you which version range cabal-install wants. pick any of these. (e.g., the highest available, why not use the latest improvements?)
06:48:05 <povman> @faq Why is a duck?
06:48:06 <lambdabot> The answer is: Yes! Haskell can do that.
06:48:26 <zachk> this isnt nearly as bad as older gentoo installs
06:48:35 <Toxaris> dcoutts: imho cabal-install should be boundled with the windows binary ghc installer in the future
06:48:55 <Toxaris> dcoutts: as long as that is not the case, there should be a either a binary download or a windows-style installer for cabal-install
06:49:03 * zachk agrees 110% with Toxaris
06:49:23 <dcoutts> @arr
06:49:24 <lambdabot> Swab the deck!
06:49:26 <zachk> i doubt alot of window users can even open tar.gz, im using winRAR
06:49:29 <zachk> @arr
06:49:29 <lambdabot> Keelhaul the swabs!
06:49:38 <zachk> @arr
06:49:38 <dcoutts> I'll make an installer when I'm next near a windows computer
06:49:38 <lambdabot> Drink up, me 'earties
06:49:52 <dcoutts> though I'd like to be able to have cabal.exe upgrade itself
06:50:00 <dcoutts> it's pretty annoying otherwise
06:50:02 <zachk> whereIs walkThePlank?
06:50:08 <dcoutts> @yarr!
06:50:09 <lambdabot> Eat maggoty hardtack, ye unkempt, jenny frequentin', son of a gun.
06:50:19 <Toxaris> dcoutts: is that connected to having an installer or not?
06:50:35 <zachk> its connected to windows being lame with locks
06:50:38 <dcoutts> Toxaris: having an installer makes it look more slick and raises peoples expectations
06:52:07 <zachk> forWindowUsersIn#haskell: windowsKey+d minimizes all your windows
06:52:19 <Toxaris> dcoutts: you could bundle something like my *.bat with http://gnuwin32.sourceforge.net/packages/gtar.htm and http://gnuwin32.sourceforge.net/packages/wget.htm to produce a unix-style installer script, so that people realize they are doing something scary
06:52:20 <lambdabot> Title: Tar for Windows
06:52:41 <dcoutts> Toxaris: heh
06:53:01 <dcoutts> of course cabal-install has it's own built-in tar gz and http code
06:53:04 <zachk> this isnt too scary
06:53:13 <dcoutts> precisely because windows doesn't have gnutar
06:53:15 <thoughtpolice> if you ask me if we want to start getting tools like haddock 2 and cabal-install more wide spread they need to be bundled with GHC
06:53:27 <Toxaris> dcoutts: you call it built-in, I have to manually download, configure, build and install it to install cabal-install :)
06:53:41 <dcoutts> thoughtpolice: I'd rather wait 'til haddock2 works :-)
06:53:44 <thoughtpolice> in the least case, haddock 2 does I feel. cabal-install is arguable since it'll require http and zlib to join the base packages
06:53:59 <dcoutts> thoughtpolice: but yes, the next platform bundle will include cabal-install
06:54:18 <thoughtpolice> dcoutts: yeah it didn't build with 6.8.3 last time I tried
06:54:20 <dcoutts> thoughtpolice: right they'll not be core packages
06:55:09 <zachk> what do i do with Setup.lhs, thats literate haskell right?
06:55:17 <Toxaris> zachk: runhaskell can run it
06:55:36 <Toxaris> and ghc compile it etc. you can treat it like *.hs
06:55:48 <thoughtpolice> but really, i think bundling tools like cabal-install and haddock would be a nice addition.
06:55:53 <zachk> really? sweetness...
06:55:55 <thoughtpolice> guess we'll just have to wait and see where it goes
06:56:13 <Toxaris> bundling cabal-install is the important step, then you can just cabal-install haddock
06:56:20 <dcoutts> thoughtpolice: right, that's what the haskell platform is for, but we don't want to bundle more with ghc, rather we want less.
06:56:24 <povman> why do some people make Setup.lhs instead of .hs?
06:56:36 <Toxaris> actually, you need to distribute *only* cabal-install, and provide package ghc on hackage :)
06:56:37 <dcoutts> thoughtpolice: it's the haskell platform that's the "batteries included" thing
06:56:43 <thoughtpolice> dcoutts: indeed, it adds extra stress to the GHC maintainers.
06:56:47 <gwern> hm. so I have a somewhat algorithmic problem. I want to apply a function to all possible halves of a list. that is, for f and [1,2], I'd get back [[f 1, 2], [1, f 2]]; for f [1,2,3,4], I'd get [[f 1, f 2, 3, 4], [1, 2, f 3, f 4], [f 1, 2, f 3, 4], [1, f 2, 3, f 4]], and so on. is this something the list monad can do?
06:56:49 <thoughtpolice> dcoutts: yeah I think I saw something about that on the wiki
06:57:15 <dcoutts> Toxaris: you joke but I'd like to do that for yhc/nhc/hugs
06:57:17 <Toxaris> povman: so they can include a shebang line (#! runhaskell) even if # doesnt start a haskell comment, I guess
06:57:28 <zachk> gwern: check out Data.List splitAt, not sure if it would work all beautifully monadically though
06:57:29 <Toxaris> dcoutts: I'm serious
06:57:42 <dcoutts> Toxaris: for ghc it's a tad harder
06:57:42 <povman> Toxaris: of course!
06:57:50 <vixey`> gwern: what if the list has length 3?
06:58:08 <Toxaris> dcoutts: I have no clue whether it would be doable. (can cabal packages be binary only?)
06:58:10 <Saad_> Aha, I found one :)
06:58:24 <dcoutts> Toxaris: no
06:58:29 <chessguy> err, if you have data List a = Nil | Cons a (List a), how would you represent [[]]? Cons Nil Nil or something?
06:58:30 <dcoutts> Toxaris: but that's not necessary
06:58:32 <gwern> vixey`: I think in that case it'd be best to round down 1, so [f 1, 2, 3], [1, f 2, 3], and [1, 2, f 3]
06:58:45 <_Dae_> vixey`: then for [1,3,4] it would be [f 1, f 1.5, 3], etc
06:59:00 <_Dae_> sorry, [f 1, f 1.5, 4]
06:59:08 <xif> is there a way to get the source definition of a Prelude function in GHCI?
06:59:09 <Deewiant> > [] : []
06:59:14 <lambdabot>  [[]]
06:59:18 <Deewiant> chessguy: so yes :-)
06:59:29 <gwern> _Dae_: actually, this is going to be specifically applied to a [String]
06:59:41 <chessguy> hmm. why does that seem strange to me
07:00:04 <Deewiant> probably because the two Nils have different types?
07:00:16 <thoughtpolice> binary packages of regular libraries is tough because of interface files; probably plenty of other things too. ghc being pretty hard-wired onto the system it's built against probably doesn't help either
07:00:22 <chessguy> i guess
07:00:23 <_Dae_> gwern: heh, ok... conver har to int, and go on? :p
07:00:26 <gwern> _Dae_: I just use ints there to make the example short. it seems to explode combinatorily
07:00:56 <gwern> (the actual application is generating test questions for people trying to memorize blocks of text)
07:01:32 <gwern> (the 'f' function is just going to convert the string into an equal length of ____s or xxxxs or whatever)
07:01:47 <_Dae_> gwern: it's not so bad. O(n^2) I think. roughly
07:02:23 <zachk> gwern: so you want all splits of a list<call it [a]> , there will be (- 1) $ length [a] possible splittings
07:02:36 <Saul__> Can somebody give me some pointers on persistent storage?
07:02:49 <zachk> gwern: are you recursing with that function though?
07:02:55 <mauke> more C++ in Haskell: http://hpaste.org/9028#a1
07:03:10 <gwern> zachk: yes, that seems reasonable to me. otherwise you'd unfairly be giving the questioner one line out of three, for example, and expecting him to remember the other 2
07:03:11 <Saul__> I need a structure that is like Data.Map, but persistent (so in a (binary?) file)
07:03:15 <chessguy_> hm
07:03:21 <chessguy> sorry, no pointers in haskell
07:03:24 <gwern> zachk: no, it'll be like \x -> repeat (length x) '_'
07:03:32 <xif> guys, what's the best way to get the source definition of a Prelude function?  I'm using GHC and GHCi here
07:03:38 <_Dae_> chessguy: don't we have foreign pointers?
07:03:45 <Saul__> I just don't know what to consider in regards to speed
07:03:46 <thoughtpolice> xif: normally, you can't.
07:03:48 <chessguy> @src concat
07:03:49 <lambdabot> concat = foldr (++) []
07:03:51 <Deewiant> xif: look at the documentation, which generally has the source.
07:03:52 <zachk> Saul_: use show read and writeFile
07:03:54 <thoughtpolice> xif: if you install lambdabot though as well as the 'goa' package
07:03:59 <gwern> xif: I'd just use @src here
07:04:02 <gwern> @src length
07:04:02 <lambdabot> Source not found.
07:04:03 <thoughtpolice> you can use lambdabot from GHCi and hoogle among other things
07:04:05 <_Dae_> xif: Hoogle?
07:04:06 <EvilTerran> xif, i tend to look them up in the report
07:04:10 <thoughtpolice> lambdabot is finnicky though
07:04:11 <xif> gwern: how does @src work?
07:04:13 <thoughtpolice> so hoogle might just be easier
07:04:20 <mauke> xif: manually
07:04:24 <gwern> thoughtpolice: shh! goa has been unusable for years, hush up
07:04:33 <xif> mauke: i.e., someone pre-fed it the definitions?
07:04:36 <Saul__> zachk: But wouldn't that be rather slow?
07:04:37 <EvilTerran> xif, ie http://haskell.org/onlinereport/standard-prelude.html
07:04:38 <mauke> yep
07:04:38 <lambdabot> Title: The Haskell 98 Report: Standard Prelude
07:04:41 <Toxaris> xif: @src looks in text file manually edited, I think
07:04:43 <xif> OK, thanks a lot.
07:05:01 <thoughtpolice> gwern: heh, I actually had it working pretty nicely on my linux box before getting this mbp
07:05:05 <zachk> Saul_: dont know but it works for a wannabe mud im writing, and its human readable
07:05:12 <Saul__> zachk: Things like Binary and ByteStrings might speed this up a lot
07:05:14 <thoughtpolice> truth be told I didn't use it a whole lot
07:05:33 <zachk> Saul_: are you in the "need for speed" or want something that works?
07:05:42 <thoughtpolice> and having it break after loading a module made it worthless
07:05:42 <vixey`> @let onNths 0 f list = return list ; onNths n f (x:xs) = liftM (f x :) (onNths (n-1) f xs) ++ map (x :) (onNths n f xs) ; onNths _ _ [] = []
07:05:43 <vixey`> @let onHalves f list = onNths (length list `div` 2) f list
07:05:44 <thoughtpolice> but it's an alternative
07:05:46 <Saul__> zachk: The problem is I'm using CGI, so I need to read all the data all the time, which seems inefficient
07:05:47 <Toxaris> xif: @src doesn't return the source actually used for e.g. ghc's Prelude, but something in-between the official H98 Report definitions and ghc's Prelude and newbie-friendly code and lambdabot-specific extensions
07:05:47 <lambdabot> Defined.
07:05:48 <lambdabot> Defined.
07:05:52 <xif> thoughtpolice: is @src lambdabot + goa?
07:06:00 <vixey`> > let f = ("f"++) in onHalves f ["x","y","z","w"]
07:06:01 <gwern> I don't understand, aren't there Data.Binary instances for Data.Map? wouldn't that be fast?
07:06:02 <lambdabot>  [["fx","fy","z","w"],["fx","y","fz","w"],["fx","y","z","fw"],["x","fy","fz",...
07:06:03 <thoughtpolice> xif: goa embeds lambdabot into GHCi
07:06:17 <EvilTerran> xif, also, more recent haddock HTML pages have a "source" link to the right of each definition, which you can click on to get at the *real* source code
07:06:29 <zachk> Saul_: are you modifying the Data.Map via the CGI?
07:06:32 <EvilTerran> xif, but, if a function's defined in the report, that definition will usually be nicer than the one GHC uses
07:06:32 <thoughtpolice> xif: you can use all of lambdabot's commands from GHCi such as 'hoogle' and 'src' and just about anything.
07:06:41 <xif> thoughtpolice: right, but according to the answers above, GHCi itself has no way of automatically retrieving the source.
07:06:56 <xif> hm, let's see.
07:06:58 <Toxaris> ohh regarding IDE integeration of Haskell stuff, can I make ghc output machine-parsable error messages?
07:07:04 <Saul__> gwern: I think that would work, but wouldn't it be slow to read in these files everytime a request is made, and how is the update behaviour
07:07:05 <Saul__> ?
07:07:17 <thoughtpolice> xif: no, it doesn't.
07:07:28 <Saul__> zachk: Not always, but some will add or modify elements of the map
07:07:29 <EvilTerran> xif, compare http://haskell.org/onlinereport/standard-prelude.html#$vfoldr and http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-Base.html#foldr for a demo of what i mean :)
07:07:30 <lambdabot> Title: The Haskell 98 Report: Standard Prelude
07:07:31 <thoughtpolice> it just invokes the lambdabot process externally and returns the response
07:08:02 <thoughtpolice> xif: like I said though lambdabot can be pretty finnicky sometimes, it really is probably easier just to use haskell.org/hoogle, search the function and looking at the source from there
07:08:18 <chessguy> @pl \xs f -> fl (m f xs)
07:08:18 * xif nods
07:08:18 <lambdabot> (fl .) . flip m
07:08:23 <xif> Hoogle it is.
07:08:27 <zachk> Saul_: you might want to use a database, or even try happs if you can run your own webserver, though i really have no idea, these are just suggestions, also if you dont have 8billion users connecting to your CGI, is speed really that important?
07:08:34 <gwern> vixey`: ...how on earth did you write that onHalves stuff?
07:08:43 <Saul__> gwern: and I think I will also need to make sure that data remains consistent (which would mean locking or something)
07:09:01 <vixey`> list monad :p
07:09:09 <vixey`> what do you mean?
07:09:39 * gwern just doesn't see how it works, is all
07:09:48 <Saul__> zachk: I just tried a database which I didn't like, and happs is too poorly documented and it's API seems unstable
07:10:02 <xif> EvilTerran: yeah, it's pretty clear that the Report version was written to be readable :)
07:10:16 <vixey`> this is the problem with translating prolog into haskell
07:10:17 <Toxaris> another question regarding IDE integration: is there a tool which adds type signature to all top-level functions?
07:11:17 <thoughtpolice> Toxaris: inf-haskell can get type signature of a function for you but that's about as far as I know
07:11:57 <thoughtpolice> (which is apart of haskell-mode for emacs)
07:12:00 <Toxaris> thoughtpolice: well, ghc -Wall outputs line number and type signature of every function missing a type signature, so I'm short before writing an awk script to produce a patch file from that
07:12:18 <Toxaris> which would probably work, but is so extremely crazy that I hesitate to start doing it
07:12:26 <EvilTerran> that sounds pretty good, actually
07:12:26 <hackage> Uploaded to hackage: stemmer 0.2
07:12:26 <hackage> Uploaded to hackage: hsgnutls 0.2.3.2
07:12:26 <hackage> Uploaded to hackage: HsHyperEstraier 0.2.1
07:12:27 <hackage> Uploaded to hackage: Pugs 6.2.13.8
07:12:29 <hackage> Uploaded to hackage: iconv 0.4.0.2
07:12:42 <EvilTerran> depending on how sed-friendly the warnings are
07:12:47 <zachk> Toxaris: perl scripts arent too bad, you could do it in Perl 6 and use PUGS so you wouldnt even need to leave HaskellWorld
07:13:03 <zachk> but that is just idol speculation
07:13:15 <Toxaris> EvilTerran: the warnings are absolutely un-machine-readable
07:13:25 <Toxaris> EvilTerran: e.g., pretty printed for 80 columns
07:13:37 * EvilTerran wonders if hackage bot could be trained to group uploads that come close together
07:13:54 <EvilTerran> Toxaris, ouch... patch ghc to add a flag to produce the diff directly?
07:14:33 <EvilTerran> it'd be more elegant (but not necessarily easier) than munging not-for-computer-consumption text
07:14:40 <Toxaris> EvilTerran: well, that sounds like the real thing, but much harder :)
07:15:31 <Toxaris> I have looked into using the ghc API, but I feel that I have to look at ghc source anyway to understand the ghc api
07:16:28 <Toxaris> zachk: haha, Perl 6 considered as a scripting language to be used in Haskell applications :)
07:16:29 <thoughtpolice> i'm not even sure the API can do things like really look at module content
07:16:35 <thoughtpolice> much less specific function signatures
07:16:36 <gwern> Toxaris: you would
07:17:34 <thoughtpolice> well, on second thought I actually think everything under ./compiler/main is exposed in the API
07:17:58 <zachk> Toxaris: my personal philosophy for computer languages is, short of assembly which im taking next semester, if i dont understand a language, learn it, code a bit in it, and reinvent some wheels, then learn another language, haskell seems like a decent stopping point cause it actually compiles
07:18:04 <chessguy> fun stuff, though pretty simple if you know how the prelude functions are written: http://blog.tmorris.net/haskell-exercises-for-beginners/
07:18:06 <lambdabot> Title: Œª Tonys blog Œª ª Blog Archive ª Haskell exercises for beginners
07:19:09 <thoughtpolice> and so if you're going to wade through compiler/main for stuff like that, you'll be looking at about 16,000 lines of source (according to wc -l)
07:19:22 <thoughtpolice> not excluding whitespace/comments, mind you
07:20:06 <Toxaris> maybe it would be easier to implement awk in haskell to have that "I'm not leaving Haskell land"-excuse
07:20:58 <gwern> vixey`: oy, your definition seems subtly wrong. onHalves hide ["foo", "bar", "baz"] ~> [["___","bar","baz"],["foo","___","baz"]] <-- missing one
07:21:10 * EvilTerran still isn't sure why exactly someone hasn't translated the Evil Perl Mangler into even highly imperative haskell
07:21:14 <gwern> onHalves hide ["foo", "bar"] ~> [["___","bar"]]
07:21:26 <vixey`> > let f = ("f"++) in onHalves f ["foo","bar"]
07:21:27 <zachk> Toxaris: perl isnt too hard to learn, its awk+sed+bash+someotherstuff
07:21:28 <lambdabot>  [["ffoo","bar"],["foo","fbar"]]
07:21:44 <EvilTerran> > onHalves f [x,y] :: [[Expr]]
07:21:45 <pozic> I install ghc-6.8.2, I got the cabal-install tarball unpacked. How do I install it?
07:21:46 <lambdabot>  [[f x,y],[x,f y]]
07:22:00 <pozic> installed*
07:22:03 <EvilTerran> > onHalves f [x,y,z] :: [[Expr]] -- "halves" don't really apply to odd-length lists
07:22:04 <lambdabot>  [[f x,y,z],[x,f y,z],[x,y,f z]]
07:22:06 <gwern> oh, wait, I see what I did wrong
07:22:13 <EvilTerran> *doesn't
07:22:20 <vixey`> @seen ski
07:22:21 <lambdabot> ski is in #haskell.hr, ##logic, #haskell-overflow and #haskell. I last heard ski speak 6h 7s ago.
07:22:22 <gwern> vixey`: I moved up the [] clause in the onHalves def
07:22:23 <mauke> zachk: where someotherstuff includes C, BASIC and Lisp
07:22:24 <Toxaris> zachk: I know some perl, but I'm currently fascinated with awk, so I'm doing my simple-test-processing stuff with it
07:22:37 <gwern> I'm a little surprised that that made a difference, tho
07:22:43 <dcoutts> pozic: http://haskell.org/haskellwiki/Cabal/How_to_install_a_Cabal_package
07:22:45 <lambdabot> Title: Cabal/How to install a Cabal package - HaskellWiki, http://tinyurl.com/39kra4
07:22:46 <Toxaris> zachk: I really like the idea of a regexp-driven case statement
07:22:53 <zachk> mauke: and blessable references
07:23:01 <dcoutts> pozic: you'll need the deps too
07:23:02 <mauke> zachk: that's pretty lispy
07:23:25 <vixey`> gwern,
07:23:26 <vixey`> onNths(0,List,List).
07:23:26 <vixey`> onNths(s(N),[X|Xs],[f(X),Ys]) :- onNths(N,Xs,Ys).
07:23:26 <vixey`> onNths(s(N),[X|Xs],[Y|Ys]) :- onNths(s(N),Xs,Ys).
07:23:26 <zachk> mauke: is it worth getting lispy, if im already a lil schemey?
07:23:42 <vixey`> reordering that version wont break it
07:24:07 <gwern> vixey`: ? that isn't haskell is it?
07:24:08 * _Dae_ needs a generator for positive definite matrices.....
07:24:11 <vixey`> no it's not haskell
07:24:19 <thoughtpolice> prolog!
07:24:22 <EvilTerran> that's pr- yeah
07:24:40 <gwern> ack, another language I should learn? bleh
07:25:22 <Toxaris> oh, so late already. have to hurry to buy some food :)
07:25:29 <Toxaris> gwern: prolog is great, learn it.
07:25:55 <pozic> Isn't Prolog only great for toy search problems?
07:26:08 <zachk> toys are fun
07:26:10 <vixey`> pozic: correct
07:26:23 <pozic> AFAIK, anything that requires evaluation of billions of nodes in a search graph is implemented in C++.
07:26:34 * vixey` smirks
07:26:44 <EvilTerran> ++? ha! raw assembly, surely?
07:26:52 <Toxaris> pozic: its great to learn, not great to use
07:27:12 <_Dae_> EvilTerran: the ONLY way to program
07:27:40 * Peaker always prefers C with X-Macros to C++ :-)
07:27:53 <zachk> Peaker: what are X-macros?
07:28:26 <Peaker> zachk: a nice way to (ab?)use the C preprocessor -- you evaluate a set of macros multiple time under different macro definition 'environments'
07:28:41 <zachk> sounds brutal
07:28:44 <Peaker> zachk: very powerful stuff - you can even get a sort of "reflection" in C
07:29:09 <Zao> Sounds about as fun as Boost.Preprocessor's include recursion.
07:29:46 <Peaker> zachk: for example, you often need to keep a protocol enum, a string list, and a function table in sync. You can do that via:  #define ALL_COMMANDS DEF_CMD(CMD_A) DEF_CMD(CMD_B) DEF_CMD(CMD_C) ... etc  and then evaluate ALL_COMMANDS multiple time, each time DEF_CMD defines soemthing else
07:29:46 <zachk> sounds about as fun as macros in scheme, you can change anything you want, just not the god awful syntax
07:30:08 <zachk> oh sweet i actually understand what you are saying Peaker ;-)
07:30:32 <Peaker> zachk: I love X-macro abuse :-)
07:30:59 <Peaker> You can even define your data structures declaratively:  DEFINE_STRUCT(a) DEFINE_FIELD(int, b) ...   and then have it expand to struct definitions, serializers, deserializers, etc
07:31:12 <Peaker> (from the same macro)
07:31:21 <xif> OK, I'm not getting this
07:31:25 <zachk> didnt totally grok that one Peaker
07:31:32 <xif> according to the definition of Prelude's take:
07:31:33 <xif> http://www.haskell.org/onlinereport/standard-prelude.html#$vtake
07:31:34 <lambdabot> Title: The Haskell 98 Report: Standard Prelude
07:31:45 <xif> shouldn't `take 2 [1]` be [1, 1]?
07:31:56 <vixey`> xif, no
07:32:01 <vixey`> > take 2 [1,2,3]
07:32:02 <vixey`> > take 2 [1,2]
07:32:04 <vixey`> > take 2 [1]
07:32:05 <Peaker> zachk: you can have DEFINE_STRUCT, and then DEFINE_FIELD  expand once to a simple struct declaration ("struct name { ..")  and another time to a function definition of a serializer
07:32:05 <vixey`> > take 2 []
07:32:16 <lambdabot>  []
07:32:16 <lambdabot>  [1]
07:32:16 <lambdabot>  [1,2]
07:32:16 <lambdabot>  [1,2]
07:32:24 <xif> vixey`: kk
07:32:27 <Peaker> zachk: yet another time they can expand to a de-serializer
07:32:44 <Peaker> did lambdabot just reverse the evaluation order?
07:32:51 <zachk> Peaker: wait so it makes c macros really useful then?
07:32:58 <zachk> > take 2 [1]
07:33:00 <lambdabot>  [1]
07:33:20 <Peaker> zachk: yeah -- some people don't like it -- as they discover there are a few tricks in the C box they don't yet know (and it CAN become pretty messy :-)
07:34:00 <Peaker> I wrote an example of a declarative-structure/serialize/deserialize library in C, and lost it. I could reimplement it, its a couple-hours worth of work
07:34:26 <chessguy> @src Functor
07:34:27 <lambdabot> class  Functor f  where
07:34:27 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
07:38:44 <pozic> Dependency hell :(
07:39:28 <pozic> Where do I get hsc2hs?
07:39:41 <mauke> doesn't it come with ghc?
07:39:52 <pozic> Debian renamed it to hsc2hs6
07:39:57 <pozic> Never mind.
07:40:42 <ibid> pozic: i have hsc2hs too, on debian
07:41:29 <Axman6> @src fmap
07:41:30 <lambdabot> Source not found. Just try something else.
07:41:44 <profmakx> hm
07:42:02 <ibid> pozic: which release of debian?
07:43:45 <pozic> ibid: Unstable, I checked the file listing.
07:44:22 <zachk> vim to the rescue....mmmm
07:45:00 <lispy> Next, the adventures of Super Vim and Sed Boy!
07:45:05 <ibid> pozic: it's an alternative
07:45:32 <zachk> oh wtf is this, i run a batch program to modify my path and it doesnt modify my real path, arrrrrrrr
07:45:38 <zachk> maybe i should just reboot
07:45:54 <ibid> zachk: on windows?
07:46:01 <zachk> ibid: yea
07:46:11 <ibid> ok, then i won't know :)
07:46:36 <ibid> pozic: it's not in the file listing, it's generated at install
07:47:26 <chrisdone> hi
07:48:08 <ibid> pozic: at least i have:
07:48:09 <ibid> lrwxrwxrwx 1 root root 24  7.5. 13:25 /usr/bin/hsc2hs -> /etc/alternatives/hsc2hs
07:48:16 <ibid> lrwxrwxrwx 1 root root 29  7.5. 13:25 /etc/alternatives/hsc2hs -> /usr/lib/ghc-6.8.2/bin/hsc2hs
07:48:54 <ibid> pozic: and /usr/lib/ghc-6.8.2/bin/hsc2hs is in ghc6
07:49:01 <shapr> hi chrisdone
07:49:01 <lambdabot> shapr: You have 1 new message. '/msg lambdabot @messages' to read it.
07:49:46 <shapr> Are there directions for installing cabal on win32?
07:49:52 <ibid> pozic: the links are generated by ghc6's postinst
07:50:06 <zachk> yay cabal-install finally works, now the first thing i should do is update cabal right?
07:50:07 <dcoutts> shapr: no because they're the same on all platforms really
07:50:25 <dcoutts> shapr: the default paths are different I guess
07:50:37 <Toxaris> hehe installing cabal seems to be the hot topic today
07:50:42 <dcoutts> shapr: see the INSTALL file in Cabal
07:50:51 <dcoutts> Toxaris: aye
07:51:01 <zachk> i just wanted some yogurt!
07:51:40 <Toxaris> zachk: I don't think you can update your PATH from a *.bat, or can you?
07:52:00 <zachk> you used to be able to, you cant even have batch files change directories for you anymore
07:52:24 <pozic> ibid: I made some links myself and cabal-install seems to work.
07:52:37 <Toxaris> zachk: I use WIN+PAUSE to open system settings, and then click to that highly unusable environment variable setting dialog
07:53:14 <ibid> pozic: you shouldn't have to do them yourself
07:53:24 <Toxaris> zachk: but I guess you could write a *.reg file from a bat, and install it, if you find out where in the registry the path is stored
07:53:24 <zachk> yea i did that but it didnt take effect,think i need to reboot or something for it to take effect :-/ and i dont like rebooting
07:53:45 <Toxaris> zachk: on my vista, changed paths take effect for running cmd-windows
07:53:53 <Toxaris> zachk: but not for running semi-shells e.g. in my editor
07:54:01 <zachk> :-/
07:54:15 <zachk> this is my mom's comp or id have a *nix on it
07:54:16 <Toxaris> zachk: probably because my editor is not clever enough to react to WM_CHANGED_WHATEVER
07:54:37 <Toxaris> zachk: but it is enough to restart the editor!
07:54:59 <xif> not sure I understand the definition of repeat:
07:54:59 <xif> file:///home/adam/doc/haskell98-report-html/standard-prelude.html#$vrepeat
07:55:14 <zachk> > @src repeat
07:55:15 <lambdabot>  Parse error at "@src" (column 1)
07:55:19 <zachk> @src repeat
07:55:19 <lambdabot> repeat x = xs where xs = x : xs
07:55:29 <vixey`> > repeat 'W'
07:55:31 <lambdabot>  "WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW...
07:55:45 <xif> yeah, but why define it like this?
07:55:48 <zachk> > take 5 repeat 1
07:55:50 <lambdabot>  Couldn't match expected type `[a]'
07:55:51 <Toxaris> xif: how else?
07:55:59 <xif> repeat x = x
07:56:00 <zachk> > take 5 $ repeat 1
07:56:04 <lambdabot>  [1,1,1,1,1]
07:56:06 <vixey`> repeat x = x : repeat x
07:56:21 <zachk> it makes a nice infinite list for ya
07:56:36 <vixey`> xs x = x : xs x
07:56:40 <Toxaris> > let repeat x = x in repeat 'W' -- that's different, xif
07:56:42 <lambdabot>  'W'
07:56:46 <vixey`> repeat x = xs where xs x = x : xs x
07:56:49 <xif> Toxaris: hm, right
07:56:58 <vixey`> xif, see the transformation?
07:57:16 <vixey`> xif, the function application 'repeat x' is replaced with a variable 'xs'
07:57:38 <xif> I think I see it now
07:57:55 <vixey`> so instead of (x : x : x : x : ...), you get #1=(x : #1#)
07:58:02 <zachk> now to clean up my 20 windows i have
07:58:05 <vixey`> which are exactly the same from the point of view of a haskell program
07:58:16 <vixey`> but the second uses less computation and memory
07:58:25 <Toxaris> > let repeat = fix . (:) in repeat 'W' -- the real thing
07:58:27 <lambdabot>  "WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW...
07:58:45 <vixey`> xif, does that make sense?
07:58:51 <Toxaris> (just to confuse people)
07:59:38 <xif> vixey`: what you said does, I'm not sure I understand what Toxaris just pasted
07:59:44 <Axman6> Toxaris: any chanve you could explain that to me?
07:59:51 <Baughn> let repeat x = let c = repeat () in replicate c x -- Just to confuse people more
07:59:54 <vixey`> let repeat = fix . (:) in repeat 'W'
08:00:00 <vixey`> fix . (:) $ 'W'
08:00:08 <vixey`> fix ('W':)
08:00:15 <Toxaris> Axman6, xif: do you know fix, (.), (:)? no problem if not, I just don't know what part to explain?
08:00:22 <vixey`> ('W':'W':'W':'W':'W':...)
08:00:34 <Toxaris> hmm, or listen to vixey` :)
08:00:40 <Axman6> i don't know fix, i thow . though
08:00:48 <Toxaris> @src fix
08:00:49 <lambdabot> fix f = let x = f x in x
08:00:53 <vixey`> you can think, fix f = f (fix f)
08:00:59 <xif> OK, starting to get it...
08:01:10 <xif> thanks.
08:01:17 <Baughn> > fix (const 42)
08:01:18 <lambdabot>  42
08:01:19 <vixey`> the 'let x =' ... is here for the same reason as in the repeat definition
08:01:49 <Toxaris> Axman6: fix f = f (f (f (f (f (f (f (f (f ...))))))
08:01:55 <Axman6> yeah...
08:02:07 <Axman6> so, fix . (:) = ...?
08:02:17 <vixey`> fix . (:) = fix . (:)
08:02:17 <chessguy> @type fix . (:)
08:02:21 <vixey`> as a first approximation
08:02:21 <lambdabot> forall a. a -> [a]
08:02:43 <Axman6> vixey`: could you narrow that approximation a little? :)
08:02:43 <vixey`> fix . (:) = repeat
08:02:46 <Toxaris> Axman6: so fix ('W' :) = 'W' : 'W' : 'W' : ...
08:02:50 <Toxaris> Axman6: do you see that?
08:02:59 <Axman6> yeah
08:03:37 <Toxaris> Axman6: so repeat x = fix (x :)
08:03:46 <Toxaris> Axman6: which can be written as repeat = fix . (:)
08:03:46 <Axman6> i take it fix (2*) 2 would be infinite?
08:03:56 <Toxaris> Axman6: without the last 2
08:03:59 <Axman6> ok
08:04:02 <Axman6> righto
08:04:02 <Toxaris> @type fix (2 *)
08:04:03 <lambdabot> forall t. (Num t) => t
08:04:14 <Axman6> > fix (2*)
08:04:15 <Toxaris> Axman6: the cool thing about fix is that it *doesn't* need a base case
08:04:24 <Axman6> yeah :)
08:04:30 <lambdabot>  thread killed
08:04:34 <gwern> > 950 / 4
08:04:35 <Axman6> huzzah
08:04:36 <lambdabot>  237.5
08:04:38 * shapr boings quietly
08:04:46 <Baughn> And if it turns out it /did/ need a base case, you get bottom instead. Neat, yes. &&;
08:04:48 <Toxaris> Axman6: but that does only work for some functions, of course. they have to be lazy enough to produce some result without needing all of the inout
08:04:51 <zachk> all that work and readline package fails to install on windows using cabal install yogurt :-(
08:05:09 <chrisdone> in-out, in-out
08:05:29 <Toxaris> Axman6: for some Num instances, fix (2*) could return something
08:05:41 <Toxaris> Axman6: consider data Nat = Zero | Succ Nat
08:05:43 <Axman6> > fix (0*)
08:05:55 <Baughn> Axman6: Not /that/ Num instance
08:05:58 <lambdabot>  thread killed
08:06:00 <Toxaris> Axman6: so that e.g. 3 = Succ (Succ (Succ Zero))
08:06:11 <Axman6> ah ha
08:06:12 <Baughn> > fix ((2::[()])*)
08:06:14 <lambdabot>   add an instance declaration for (Num [()])
08:06:23 <vixey`> :k Mu
08:06:25 <lambdabot> (* -> *) -> *
08:06:35 <Toxaris> Axman6: than fix (2 *) = Succ (Succ (Succ ...))
08:06:37 <vixey`> :t fix
08:06:39 <lambdabot> forall a. (a -> a) -> a
08:06:55 <Toxaris> Axman6: because his Num instance can actually express infinity
08:07:11 <Axman6> righto
08:07:19 <chrisdone> in kinds, when you have * -> *, how do you read that aloud?
08:07:29 <Toxaris> "star to star" or "type to type"
08:07:32 <Baughn> chrisdone: "Type constructor of one argument"
08:07:51 <chrisdone> okay
08:08:01 <vixey`> > let infinity = fix (In . Right) :: Mu (Either ()) in infinity
08:08:03 <lambdabot>        add an instance declaration for (Show (Mu (Either ())))
08:08:08 <vixey`> :t let infinity = fix (In . Right) :: Mu (Either ()) in infinity
08:08:09 <lambdabot> Mu (Either ())
08:08:22 <Toxaris> lambdabot has Mu?
08:08:26 <vixey`> Mu
08:08:48 <vixey`> N ~ Mu (Either ())
08:09:08 <vixey`> Z = In (Left ()) ; S = In . Right
08:09:12 <shapr> gwern: Where did you find FLM sources?
08:09:24 <chrisdone> :k Mu (Either ())
08:09:24 <lambdabot> *
08:09:29 * Toxaris votes for adding type a :+: b = Either a b and hacking 1 = () into it
08:09:30 <chrisdone> :t Mu (Either ())
08:09:31 <lambdabot> Not in scope: data constructor `Mu'
08:09:31 <lambdabot> Not in scope: data constructor `Either'
08:09:32 <gwern> shapr: probably scannedavian
08:09:40 <Toxaris> so you can write N ~ Mu (1 :+:)
08:09:52 <vixey`> Toxaris: also add  a <- b = b -> a   please
08:10:08 * vixey` misses this
08:10:13 <shapr> gwern: Just curious, I can't find it now, and thought I'd work on it during my vacation.
08:10:33 <Toxaris> type b :<- a = b -> a should work, shouldn't it?
08:10:44 <Toxaris> s/b -> a/a -> b
08:10:44 <vixey`> yes, it's a shame that :<- is horrible
08:10:46 <gbacon> if I have several XML trees catenated into a single file, does hxt provide a straightforward way to pull out the individual documents?
08:11:25 <Toxaris> yeah, the general concept of lexically distinguishing type and value level is horrible
08:11:36 <Baughn> gbacon: parse ("<docs>"++docs++"</docs") ?
08:11:43 <vixey`> you want to fold the type and value syntax into one??
08:12:06 <Toxaris> vixey`: exactly. it should be clear from the context what is what
08:12:20 <gwern> shapr: the darcs repo for FLM seems to be up for me: http://www.scannedinavian.com/~shae/flm
08:12:21 <lambdabot> Title: Index of /~shae/flm
08:12:32 <gwern> hm. my patches didn't get applied
08:12:33 <shapr> Is there a single top level package to get all of happs from hackage?
08:12:42 <chrisdone> gwern: RAGE
08:12:55 <Toxaris> vixey`: it's what we already have for built-in stuff (e.g. "->", "[]", (,)) and it works fine
08:13:13 <gwern> chrisdone: for the dying of the light?
08:13:15 * RayNbow wonders why he has created a \x->x avatar for GTalk...
08:13:41 <chrisdone> RayNbow: needs more Œªx.x
08:13:48 <shapr> crap, how do I install curl or wget on cygwin?
08:13:50 <chrisdone> RayNbow: uh, Œªx¬∑x
08:13:50 <Baughn> gbacon: *Against*
08:14:02 <Baughn> *gwern
08:14:17 <paczesiowa> shapr: cygwin installer has those packages, just enable them
08:14:20 <RayNbow> <chrisdone> RayNbow: needs more Œªx.x <-- yes, my avatar contains that... but I was too lazy to type the lambda here :p
08:14:35 <RayNbow> so I typed the Haskell equivalent :p
08:14:51 <Toxaris> shapr: start cygwins setup.exe again, search for curl and wget, enable them, click proceed, wait for download
08:15:00 <gwern> Baughn: ah, very true.
08:15:09 <gbacon> Baughn: fair enough, thanks
08:15:14 <shapr> gwern: thanks, I'll try to hack on FLM during my week long vacation.
08:15:24 <shapr> Toxaris: thanks, I'll try it.
08:15:41 <chrisdone> wasn't there going to be a haskell logo competition? I need to practise GIMP and Inkscape
08:15:42 <gwern> shapr: good luck. if you see shae, bug'im about my patches
08:15:50 <Toxaris> shapr: unfortunately, cygwin's setup.exe has no search feature :(
08:16:43 <gabbs> hi, quick question, what does in a parser: "do dddd <- many (do digit) mean?
08:16:56 <gabbs> is it basically (in regex terms) \d{4} ?
08:17:04 <mauke> \d*
08:17:09 <pozic> gabbs: the same as do dddd<-many digit
08:17:12 <Baughn> gwern: One of my favorite poems there, though unlike poor Dylan I actually have a chance of succeeding
08:17:30 <gabbs> hmm, does dddd have a meaning or is it just a label then?
08:17:43 <Baughn> Just a label
08:17:45 <vixey`> gabbs: like everything, it's just a label
08:17:59 <mauke> it's a variable
08:18:00 <Baughn> gabbs: It could be "bandersnatch", for all haskell cares
08:18:22 <gabbs> so its basically a greedy quantifier? \d{0,} ?
08:18:32 <Baughn> Yes.
08:18:39 <gabbs> ah ok, cheers! „ÉÑ
08:18:46 <Baughn> gabbs: That's how many works, indeed. As the reference says. ;)
08:18:48 <pozic> gabbs: greedy/non-greedy is decided on a different level.
08:19:05 <Baughn> gabbs: Well, everything is greedy unless wrapped in try
08:19:17 <vixey`> hi shapr
08:19:20 * Baughn blinks
08:19:42 <gabbs> thanks guys - you've been quite helpful :D
08:19:58 <Baughn> gabbs: Disregard that one. Everything /doesn't backtrack/ unless it consumes no elements on failure. Try stores them so it can make it do so.
08:20:08 <shapr> hiya vixey`
08:20:12 <shapr> how's code?
08:20:17 <vixey`> too late, he'll never know
08:20:19 <Baughn> Greediness is, indeed, on a different level; as a zeroth approximation, everything is greedy period
08:20:24 <Baughn> Oh drat
08:20:24 <shapr> gwern: I am shae last I checked!
08:20:27 <gwern> ok everyone, any style suggestions for my little program? I've cleaned it up as much as I could see fit: http://hpaste.org/9031
08:20:37 <gwern> shapr: oh my!
08:20:39 <shapr> but I'm getting on a plane now...
08:20:47 <shapr> bbl
08:20:51 <vixey`> bye
08:21:00 <gwern> shapr: wait, if it's your program/repo, then how did you not know where it was? o.0
08:21:11 <Baughn> gwern: split was submitted to the base libraries recently as, I believe, splitBy'
08:21:53 <vixey`> hmm
08:21:59 <vixey`> > liftM f [x,y,z] :: [Expr]
08:22:01 <lambdabot>  [f x,f y,f z]
08:22:12 <vixey`> gwern, I guess onNths n f (x:xs) = liftM (f x :) (onNths (n-1) f xs) ++ map (x :) (onNths n f xs)
08:22:14 <Baughn> gwern: With this amount of comments, you might as well use the .lhs file extension and literal programming
08:22:18 <Baughn> *literate
08:22:18 <vixey`> should be onNths n f (x:xs) = map (f x :) (onNths (n-1) f xs) ++ map (x :) (onNths n f xs)
08:22:33 <gwern> Baughn: I saw a submission for split/splitWith, but I don't think I saw a splitBy'
08:22:55 <Baughn> gwern: Probably just renamed
08:23:16 <gwern> Baughn: I don't really like literate. doesn't interact well with haddock AFAIK
08:23:27 <Baughn> gwern: See, that's something you can fix. ;)
08:24:22 <gwern> vixey`: what should be that?
08:24:30 <gabbs> hm, one question remains: what does init(myLabel ++ "p") do?
08:25:18 <gwern> Baughn: wait, what can I fix?
08:25:18 <vixey`> gabbs: init(myLabel ++ "p") = myLabel
08:25:29 <gwern> split? I'm already working on that, as discouraging a pursuit as it is
08:25:36 <Baughn> gwern: Haddock
08:25:37 <vixey`> gwern: I used liftM but should have used map (they are the same in this case but it's silly to write liftM)
08:25:43 <gabbs> vixey`, hmm .. so its basically useless?
08:25:54 <vixey`> gabbs: I wouldn't say that
08:26:13 <gabbs> myLabel = a line from a file I read in
08:27:18 <monochrom> <3
08:36:18 <chrisdone> heh, in XMonad the font list in InkScape appears in another frame. <3
08:49:14 <_Dae_> @src unsafeRead
08:49:15 <lambdabot> Source not found.
08:49:19 <_Dae_> ....
08:49:47 <Baughn> unsafeRead = read
08:51:53 <_Dae_> well, it could be unsafeAt I'm looking for.... I can't find any documentation for the unsafe array reads 'n' writes
08:52:55 <Baughn> It's unsafeAt, yes
08:53:19 <Baughn> (Which isn't exported, I believe)
08:53:28 * gwern watches emacs play Conway's Game of Life. strangely enthralling
08:54:22 <Baughn> gwern: Try Golly
08:54:58 * EvilTerran likes watching MilkDrop2 playing game of life
08:55:27 <_Dae_> Baughn: meaning that you have to use a custom version of the array library??
08:55:36 <gwern> what is golly?
08:55:44 <Baughn> _Dae_: I imagine
08:55:56 <_Dae_> phey.....
08:55:59 <Baughn> gwern: A fast life GUI with an integral hashlife algorithm
08:56:08 <monochrom> I invented a great idea along this vein. Treat the text buffer as a bignum. Apply the Collatz function to it.
08:56:10 <gwern> ooh, hashlife
08:56:15 <gwern> one of my favorite algos
08:56:40 <Baughn> Well, it's very, very good anyhow. Try it
08:57:01 <vixey`> yeah the hashlife algorithm is incredible
08:57:20 <Saizan_> ?hoogle unsafeAt
08:57:21 <lambdabot> No matches found
08:57:30 <vixey`> unsafeAt = (!!) -- ?
08:58:04 <_Dae_> isn't !! the list index function?
08:58:17 <_Dae_> @src (!!)
08:58:18 <lambdabot> xs     !! n | n < 0 = undefined
08:58:18 <lambdabot> []     !! _         = undefined
08:58:18 <lambdabot> (x:_)  !! 0         = x
08:58:18 <lambdabot> (_:xs) !! n         = xs !! (n-1)
08:58:47 <gabbs> when hugs tells me it can't find a module I've loaded - how to troubleshoot?
08:58:59 <Saizan_> ?type Data.Array.Base.unsafeAt -- hard to find, but it's there :)
08:59:00 <lambdabot> forall (a :: * -> * -> *) i e. (Ix i, Data.Array.Base.IArray a e) => a i e -> Int -> e
09:00:35 <_Dae_> Saizan_: weird... it's not n the haskell doc
09:00:38 <Baughn> "Generation: 6.9985e+09. Population: 1.34383e+16."
09:00:46 <_Dae_> Saizan_: but thanks :)
09:04:06 <roconnor> Do you think that a "strict" implemenation of getContents would be a valid implemenation?
09:05:03 <monochrom> It exists already. Somewhere on hackage. Along some name like "strict i/o".
09:05:19 <roconnor> monochrom: but if I were implementing Haskell
09:05:27 <roconnor> and I made my getContents strict
09:05:32 <roconnor> would I still be Haskell 98?
09:05:37 <monochrom> Let me try to read Haskell 98.
09:05:46 <roconnor> I was thinking today that getContents has concurrent semantics, which is why its behaviour seemed so odd to me
09:06:05 <roconnor> if I am right, then a strict implemenation of getContents would be valid
09:06:19 <monochrom> It says "The getContents operation returns all user input as a single string, which is read lazily as it is needed."
09:06:32 <roconnor> :(
09:06:47 <roconnor> screw the haskell report then.
09:06:53 <monochrom> Heh
09:07:21 <roconnor> monochrom: does that statement prove that Haskell is in fact a lazy language?
09:07:27 <roconnor> and not a non-strict language?
09:07:37 <monochrom> No.
09:08:07 <_Dae_> haskell isn't lazy, it just doesn't get bored as easily as other languages
09:08:24 <monochrom> One single library function has been found to do lazy I/O. You can even have that in SML or C or ...
09:08:42 <roconnor> Maybe I can get the haskell prime people to change the definition of getContents ]:D
09:09:01 * vixey suggests not caring about Haskell' and doing your own thing
09:09:18 <roconnor> vixey: you've said that before.
09:09:23 <roconnor> It's an interesting idea
09:09:29 <monochrom> To prove Haskell lazy, you have to find a statement that says function application is evaluated lazily.
09:09:36 <roconnor> Can you convince me?
09:10:04 <monochrom> The report only says function application is evaluated non-strict.
09:10:04 <vixey> I wrote (badly) a fragment of a haskell like language http://code.google.com/p/rascal-haskell/
09:10:06 <lambdabot> Title: rascal-haskell - Google Code
09:11:33 <roconnor> but what about haskel prime?
09:11:44 <gabbs> +++ between parsers will basically concat them?
09:12:04 <monochrom> No. will choose between them.
09:12:21 <gabbs> ah, so either must be true
09:12:23 <monochrom> To concat, use >> or >>= or the do-notation.
09:12:30 <gabbs> erm, one of them
09:12:32 <gabbs> k
09:13:46 <vixey> I put it on google because code.haskell and hackage were too much troubel
09:14:20 <vixey> anyway it is a HOAS interpreter for a small typed lazy language (basically 2% it's like of haskell)
09:14:23 <gwern> hackage is too much trouble? heresey!
09:14:39 <roconnor> vixey: that sounds cool
09:14:50 <gwern> @check \x y -> (x == x) && (y == y)
09:14:52 <lambdabot>  OK, passed 500 tests.
09:15:00 <monochrom> google is too much trouble too. I would put it on my own home page. It allows me to tune the last bit of xhtml. :)
09:15:02 <vixey> @check \x y -> (x == y) && (y == x)
09:15:04 <lambdabot>  OK, passed 500 tests.
09:15:13 <EvilTerran> @check (==) -- defaulting, oh my!
09:15:15 <lambdabot>  OK, passed 500 tests.
09:15:36 <roconnor> @scheck (==)
09:15:37 <lambdabot>     Failed to load interface for `SmallCheck':
09:15:37 <lambdabot>       Use -v to see a list of ...
09:15:54 <gwern> I'm just wondering how check works, so I can reimplement it with my mueval
09:16:02 <EvilTerran> > [minBound]
09:16:03 <roconnor> @where QuickCheck
09:16:04 <lambdabot> http://www.cs.chalmers.se/~rjmh/QuickCheck/
09:16:06 <lambdabot>  [()]
09:16:17 <EvilTerran> gwern, it uses quickcheck, iirc
09:16:38 <EvilTerran> which involves a typeclass used to generate lists of random values to test
09:16:38 <gwern> EvilTerran: yeah, I know
09:17:42 <Baughn> @scheck (==) :: Int -> Int -> Bool
09:17:43 <lambdabot>     Failed to load interface for `SmallCheck':
09:17:43 <lambdabot>       Use -v to see a list of ...
09:17:51 <Baughn> @check (==) :: Int -> Int -> Bool
09:17:53 <lambdabot>  Falsifiable, after 1 tests: 2, 0
09:18:45 <vixey> @check \doesntfind bugs -> doesntfind*bugs \= 11*13
09:18:46 <lambdabot>   Not in scope: `\='
09:18:50 <vixey> @check \doesntfind bugs -> doesntfind*bugs /= 11*13
09:18:52 <lambdabot>  OK, passed 500 tests.
09:19:43 <vixey> it seems completely insane to me that unit testing is used in industry
09:20:00 <roconnor> as opposed to?
09:20:10 <EvilTerran> proofs of correctness!
09:20:17 <EvilTerran> total languages!
09:20:23 <Baughn> Correctness? As defined how?
09:20:25 <roconnor> unit testing is cheaper thatn proofs of correctness
09:20:35 <EvilTerran> dijkstra standing over your shoulder holding a ruler!
09:20:39 <roconnor> Baughn: by dependent types. :D
09:20:43 <Peaker> I have a dream is that some day we will be replacing all unit tests with more general proofs of correctness
09:21:12 <monochrom> Yeah, I want to know what vixey has in mind instead.
09:22:05 <gwern> we need a lambdacat looking at a screen of C code: 'ur doing it wrong'
09:22:16 <roconnor> :D
09:22:19 <monochrom> Anyway, if you ask "correctness as defined how?", the answer is you have to write a specification too, then it is program against specification.
09:23:19 <Baughn> So, ideally you'd just have the specification, and compile that
09:23:23 <roconnor> unit testing is simply a Delta_0 specification.
09:23:39 <roconnor> ... maybe Sigma_1
09:24:31 <monochrom> Yeah, specification is lim n->oo (n test cases).
09:24:47 <roconnor> QuickCheck properties are Pi_1 specifications
09:24:50 <roconnor> ... maybe Pi_2
09:25:04 <roconnor> Of course, QuickCheck doesn't prove these specs.
09:25:22 <roconnor> but it is nice to have them written down.
09:25:59 <monochrom> If you write them down, you are not restricted to applying QuickCheck to them.
09:26:43 <roconnor> yep
09:26:49 <Peaker> Baughn: a specification for sort could be:  sort :: [a] -> [a], forall i. count input!!i==count output!!i, output!!i <= output!!(i+1)  (with some extra pedantry about index correctness, etc) -- how do you execute that?
09:26:54 <SamB> too bad there isn't a common library of specification combinators that all *Check can use
09:27:08 <SamB> or something like that
09:27:12 <Peaker> Baughn: do you try all possible lists until one fits?
09:27:36 <Peaker> then you might want to prove things about performance too
09:27:52 <Baughn> Peaker: Ideally, a sufficiently smart compiler would compile that down to mergesort or some such
09:27:55 <roconnor> haskell doesn't have operational semantics
09:28:02 <Peaker> Baughn: that's undecidable
09:28:03 <monochrom> I execute that by recognizing the specification as "I have seen it before" and pulling out a sorting algorithm from my memory.
09:28:19 <Peaker> roconnor: you could restrict the proof to a certain implementation
09:28:23 <Baughn> In practice you'll have to suggest that to it, but then it should still be more correctness by construction than correctness by proof
09:28:24 <SamB> Baughn: what did we tell you about that whole "sufficiently smart compiler" thing?
09:28:25 <roconnor> who said that specifications where executable?
09:28:56 <Baughn> SamB: You didn't.
09:29:03 <Peaker> Baughn: sure, correctness by construction is the way to go - you still want the construction proven correct by the compiler :)
09:29:06 <SamB> Baughn: it's a fantasy
09:29:23 <Baughn> SamB: Okay, then how about a sufficiently smart programmer?
09:29:36 <SamB> whoa
09:29:40 <Peaker> mostly fantasy :)
09:29:45 <Baughn> You could have ghc call into amazon turk
09:29:47 <monochrom> There is no distinction between "sufficiently smart programmer" and "sufficiently smart compiler".
09:29:52 <SamB> you mean they come in varieties other than "idiot" and "collosal idiot"?
09:30:08 <Baughn> There's also "schizophrenic idiot"
09:30:16 <SamB> oh, yeah, true
09:31:02 <Peaker> Baughn: anyhow, if you use "suggestions" like you said - you'd probably want the compilation to fail if it fails to use the suggestions - so they're more of a proof
09:31:16 <shepheb> is there a list-monad-like monad that short-circuits out of a whole subtree when some condition fails?
09:31:19 <mauke> Baughn: are you referring to EFnet/suravad?
09:31:29 <monochrom> Heh, perhaps the compiler doesn't use your suggestion and finds a better one. :)
09:31:52 <shepheb> ie. one like the list monad, but when a guard fails, it doesn't just skip the entry, but stops the whole recursion and returns what it had so far?
09:31:58 <Baughn> mauke: Amazon's "mechanical turk" program. Funny thing. It has a large variety of idiots to choose from.
09:32:04 <EvilTerran> shepheb, LogicT might do that
09:32:08 <EvilTerran> ?hackage logict
09:32:09 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/logict
09:33:13 <EvilTerran> shepheb, not sure if it does, tho
09:33:50 <vixey> it sounds like CallCC
09:34:06 <SamB> roconnor: oh, I was wondering if you could provide a list of CoRN repositories you pull from
09:34:06 <monochrom> sounds like cut
09:34:13 <vixey> also, actually using LogicT is -impossible-
09:34:32 <monochrom> ?  impossible to use?
09:34:42 <SamB> vixey: so if I give you a use, you will give me whatever I want?
09:34:48 <monochrom> Haha
09:34:51 <Peaker> shepheb: if you use takeWhile on the result of a list monad computation, wouldn't that do? (I'm assuming the list monad itself is lazily computed)
09:34:57 <EvilTerran> monochrom, that's what i was thinking
09:35:31 <shepheb> Peaker: perhaps. I'll investigate Logic(T), but I may just end up implementing something like that by hand
09:35:36 <EvilTerran> shepheb, alternatively, you could use something like (EitherT []), and then (takeWhile isJust) on the result
09:35:53 <vixey> I don't think anybody has ever used LogicT (Except the authors)
09:35:54 <monochrom> isRight?  MaybeT?
09:36:01 <EvilTerran> er, i mean MaybeT
09:36:07 <vixey> (in any real program)
09:36:26 <EvilTerran> EitherT's called ErrorT anyway, isn't it?
09:36:48 <monochrom> Alright, that's only because I'm a bore and I haven't found a use yet.
09:36:54 <Peaker> hmm.. takeUntilMark = snd . takeWhile fst -- along with adding that bool to the list comp. sound like it could do the trick?
09:37:40 <monochrom> 300 years ago some author would write books about matrices and you would be right in saying "there is no use except by the author".
09:38:04 <Peaker> that should map snd . takeWhile fst, ofcourse
09:38:22 <Deewiant> ?ty map snd . takeWhile fst
09:38:22 <lambdabot> forall b. [(Bool, b)] -> [b]
09:39:17 <shepheb> well, bundling the Bool in isn't helpful, the predicate is a simple numerical test.
09:39:48 <zachk> couldnt you do that with a comonad <i have no idea but it looks like w a->a>
09:39:52 <Peaker> is it possible to implement a purely functional tree that is reasonably traversable in any direction, from a given node?
09:40:06 <zachk> zippered tree's?
09:40:08 <vixey> Peaker: simpler example to get the feel of it
09:40:19 <vixey> Peaker: It is possible to define a doubly linked list?
09:40:22 <zachk> peaker: zippers
09:40:28 <Peaker> zachk: I don't know what that is
09:40:34 <zachk> i barely do myself
09:40:36 <Peaker> vixey: Doesn't sound possible - I don't know
09:40:48 <zachk> its just ([a],[a])
09:40:57 <vixey> Peaker: oh it can be
09:41:10 <zachk> and you treat the [a]'s as stack though ive never used one, seconhand knowledge
09:41:51 <Baughn> vixey: Sure, but of course you have to define it all at once, and you can't alter it..
09:42:06 <vixey> You can't alter anything in haskell, so that's not a problem
09:42:07 <EvilTerran> it is possible, but what Baughn says is the main problem once you've got one
09:42:27 <EvilTerran> vixey, but, if you replace/remove/add a single element in a doubly-linked list, you'd have to copy all the other cells
09:42:38 <zachk> i alter lots of things in haskell just by passing them around in a big "state" variable
09:42:38 <Baughn> With lists, at least altering the Nth element of an M-element list is O(n)
09:42:46 <Baughn> with double-linked ones it's O(m). So..
09:42:46 <EvilTerran> instead of sharing tails
09:42:52 <Baughn> Might as well use an array
09:43:03 <zachk> just cons to the front
09:43:16 <zachk> will probably eat memory though
09:43:20 <EvilTerran> zachk, but that'd break the datatype invariant of the doubly-linked list
09:43:34 <Peaker> so its not possible?
09:43:35 <zachk> EvilTerran: i dont think peaker wants a doubly linked list
09:43:42 <vixey> Peaker: it is possible
09:43:47 <EvilTerran> namely, the requirement that each cell (including the second one) has a link to the previous one
09:43:48 <zachk> @faw is Peaker's idea possible in haskell
09:43:48 <lambdabot> The answer is: Yes! Haskell can do that.
09:43:49 <vixey> data Double a = Nil (Double a) | Cons a (Double a) (Double a)
09:43:49 <vixey> double = Cons 1 ? (Cons 2 ? (Cons 3 ? (Nil ?)))
09:43:52 <EvilTerran> zachk, i agree
09:44:12 <paolino> how trace is used?
09:44:16 <Peaker> I want to have a revision-tree that I can add revisions to, and traverse in any direction (a revision to its parent revisions or to its children, etc)
09:44:20 <paolino> :t trace
09:44:22 <lambdabot> Not in scope: `trace'
09:44:35 <vixey> Peaker: You definitely don't want the kind of structure I was talking about then
09:44:36 <zachk> Peaker: sounds complicated
09:44:46 <paolino> @hoogle trace
09:44:49 <Peaker> I guess I could use a unique "identity" for each element, and use a bidirectional map for the doubly linked lists
09:44:51 <lambdabot> Debug.Trace.trace :: String -> a -> a
09:44:51 <lambdabot> Debug.Trace :: module
09:44:51 <lambdabot> Debug.Trace.putTraceMsg :: String -> IO ()
09:45:07 <zachk> Peaker: dont use a doubly linked lists, they are evil
09:45:08 <Cale> Do revisions really form a tree?
09:45:11 <Peaker> zachk: why?
09:45:21 <Cale> Or is it more of a DAG?
09:45:28 <Peaker> Cale: If you are willing to say that a merge is just a new child revision of the LCA
09:45:37 <Peaker> Cale: (and not of the two merged ones)
09:45:38 <Cale> mm... okay :)
09:45:44 <zachk> Peaker: because i have no easy way of defining one for you, and you could probably just do it with singly linked lists in a novel way
09:46:16 <Peaker> zachk: a singly linked list makes it difficult to traverse in arbitrary directions, though.. I think my bidirectional map works though
09:46:35 <EvilTerran> Peaker, that's what zippers are for
09:46:39 <zachk> peaker: go list then stack, then do two stacks held together in a tuple
09:46:43 <Peaker> EvilTerran: what's a zipper?
09:46:50 <zachk> Peaker: i just told you
09:47:12 <EvilTerran> store the elements before where you are in reverse order in one list, and the ones after where you are in another list
09:47:17 <Peaker> zachk: how do I modify it though?
09:47:23 <zachk> Peaker: 2-tuple (list-of-type-whatever,list-of-type-whatever)
09:47:36 <Baughn> Peaker: A doubly-linked list in haskell has no benefits whatsoever over, say, an array
09:47:38 <Cale> Peaker: That structure makes it cheap to modify the zipper around the point where it's split.
09:47:39 <EvilTerran> and you can shuffle back-and-forth between nearby elements as fast as you could with a doubly-linked list
09:47:43 <zachk> using push and pop on the stacks (you treat the two lists like stakcs)
09:47:52 <EvilTerran> and modify at the current point in constant time
09:47:53 <Peaker> Baughn: cheap insertion in the middle?
09:47:58 <EvilTerran> (unlike a doubly-linked list)
09:48:03 <Cale> Peaker: nope
09:48:06 <EvilTerran> Peaker, most definitely not!
09:48:11 <Peaker> why not?
09:48:12 <zachk> like O(1) cheap peaker
09:48:13 <Cale> Peaker: Haskell values are immutable.
09:48:14 <Baughn> Peaker: You'd have to copy the entire list to alter /anything/
09:48:22 <EvilTerran> as i mentioned earlier, you'd have to copy every cell to make any changes
09:48:31 <atp> yah just use a zipper
09:48:34 <Peaker> Cale: I know - I can use two Data.Maps for the 2 links of the linked lists, then I get O(logN) to fix each side when inserting the middle
09:48:35 <Baughn> Peaker: Might as well just store (index,array) if you want traversal
09:48:36 <EvilTerran> because you can access any cell from any other
09:48:51 <EvilTerran> Peaker, the zipper solution is much easier
09:48:55 <Cale> Oh, in that sense, yeah, you could do that :)
09:48:59 <Baughn> Peaker: That's no longer a doubly-linked list
09:49:04 <Peaker> Baughn: why not?
09:49:23 <Cale> Baughn: It's a doubly-linked list using a Data.Map as the memory :)
09:49:30 <Peaker> Baughn: sure the links are associated through a Data.Map instead of inside the node, but that's a technicality :)
09:49:46 <Baughn> Peaker: ..maybe.
09:49:48 <Peaker> where can I read about zippers?
09:49:49 <Cale> In fact, you can use a single Data.Map
09:49:56 <Baughn> Peaker: Why don't you use Data.Sequence instead?
09:50:00 <Peaker> because I didn't really understand much of all that was said about them here? :)
09:50:03 <EvilTerran> ?where zipper
09:50:04 <lambdabot> I know nothing about zipper.
09:50:05 <EvilTerran> ?where zippers
09:50:05 <Cale> with (index, value, index) triples as the elements
09:50:06 <lambdabot> I know nothing about zippers.
09:50:10 <Baughn> Peaker: Or a zipper'd list, yeah
09:50:10 <EvilTerran> ?go haskell zipper
09:50:12 <lambdabot> http://en.wikibooks.org/wiki/Haskell/Zippers
09:50:14 <Peaker> Baughn: does Sequence let me traverse in arbitrary orders?
09:50:15 <atp> Peaker: a zipper is a general datastructure that can be constructed for pretty much any algebraic data type, but you only care about lists in this case
09:50:20 <Cale> Peaker: yeah
09:50:27 <Cale> Data.Sequence is a lovely structure
09:50:44 <Baughn> Peaker: No, for traversal you want a zipper. Data.Sequence just lets you index cheaply, which sidesteps the issue
09:50:52 <zachk> he kind of wants a tree like structure though
09:50:59 <chrisdone> @hoogle isLeft
09:50:59 <lambdabot> No matches found
09:51:15 <vixey> :t either (const True) (const False)
09:51:17 <lambdabot> forall a b. Either a b -> Bool
09:51:17 <Baughn> @hoogle Either a -> Bool
09:51:18 <lambdabot> No matches, try a more general search
09:51:20 <atp> Peaker: basically you say type Zipper a = ([a], [a])
09:51:21 <Cale> Peaker: you can split it at an arbitrary point in O(min(log k, log (n-k))) time... that is, logarithmic in the distance to the closest end
09:51:25 <Baughn> @hoogle Either a b -> Bool
09:51:25 <lambdabot> No matches, try a more general search
09:51:31 <_zenon_> The zipper tutorial is great
09:51:35 <vixey> atp, that's only the zipper for a specific type though
09:51:41 <_zenon_> and funny :)
09:51:45 <atp> vixey: yes, but he only cares about lists
09:51:50 <atp> vixey: as i said to him a second ago
09:51:51 <_zenon_> but has a tiny bit too much of bloat text
09:51:51 <Cale> Peaker: and you can merge in log time as well
09:51:56 <vixey> atp: I don't think he cares about lists at alla
09:52:05 <Cale> What is the actual goal here?
09:52:06 <atp> vixey: he said he wants a doubly linked list?
09:52:19 <Peaker> Cale: these operations on top of the normal list operations?
09:52:19 <Baughn> atp: That was no doubt a mistake
09:52:28 <Cale> Peaker: yeah
09:52:29 <vixey> atp: no, I mentioned doubly linked lists and everything went haywire
09:52:31 <Peaker> I want a revision-tree that I can add children to revisions, and traverse revisions up/down easily
09:52:34 <Peaker> Cale: cool
09:53:03 <Cale> Peaker: Adding/removing to either end is constant time of course (which is implied by the above two operations)
09:53:05 <atp> Peaker: what you should do is design the data type you want without worrying about traversal
09:53:08 <Peaker> though maybe I don't need persistence of the revision-tree structure itself, I am not sure.. (If not, I can use a non-functional structure)
09:53:10 <Baughn> Peaker: The data.sequence reference is conveniently full of algorithmic complexity
09:53:18 <atp> Peaker: then, once you've designed that, we can turn it into a zipper for you
09:53:20 <Peaker> Cale: yeah, ofcourse
09:53:30 <Peaker> Cale: and logN to add anywhere inside
09:53:33 <Cale> right
09:53:34 * zachk thinks atp is wise 
09:54:08 <Baughn> Peaker: Zippers are neat. Applying derivation to types works great. :P
09:54:19 <atp> Peaker: a zipper takes any old data structure and allows you to specify a focus that you can move around in amortized O(1) time
09:54:21 <Peaker> atp: okay (hey, is your nick related to energy currency in biology? :-)
09:54:25 <Cale> Peaker: There's also a nice implementation of priority search queues you might be interested in.
09:54:29 <atp> Peaker: no, my initials :)
09:55:04 <Peaker> Cale: sure -- what's that?
09:55:06 <atp> Peaker: and actually in many cases real O(1) time
09:55:27 <Baughn> Now that I think about it, that old purely-functional queue implementation I heard about all those months ago was, in fact.. a zipper
09:55:34 <Peaker> atp: Why aren't these ideas neatly packaged in existing data structures? :)
09:56:05 <Cale> Peaker: It's a structure which is simultaneously a priority queue, so you can efficiently get/split on the least element.
09:56:09 <Cale> and*
09:56:11 <zachk> Peaker: because it seems you can make a zipper on anything you want
09:56:14 <Cale> a finite map
09:56:23 <atp> Peaker: well, actually, as Baughn noted, for an algebraic data type T the zipper type associated with it is DT where D is the derivative from calculus
09:56:25 <Cale> So you can efficiently look things up by key.
09:56:43 <atp> Peaker: it's hard to do that automatically at the moment.
09:56:51 <atp> Peaker: it's easy to do with a pencil and paper however :)
09:56:58 <Peaker> Cale: so you can look up the lowest value[s], or by key (in a key to value mapping)?
09:57:21 <zachk> how do i get hackage package readline working on winXP? or is that not very probable
09:57:22 <Cale> yeah
09:57:51 <Peaker> atp: I got a riddle about how to have a double-ended functional queue - and I think I solved it with a zipper (holding the list and reversed list, and rebuilding the reversed list when necessary), but I'm just guessing. They said it was possible in O(1) but I could only get O(1) amortized
09:57:57 <Peaker> Cale: cool - where is it useful?
09:58:01 <Cale> Peaker: so it's like a doubly indexed structure, but it's implemented in an efficient way given those tasks
09:58:31 <kayess> I've convinced a friend to try Haskell, but he grabbed hugs rather than ghci. It seems to give all sorts of odd errors "let a = 1" gives an error as does "a=1" (unexpected end of input and unexpected = respectively)
09:58:36 <Cale> It's useful for nice purely functional implementations of things like Dijkstra's all-pairs-shortest-paths.
09:58:58 <Cale> kayess: hugs doesn't allow let bindings at the prompt
09:59:01 <JakeP> can someone tell me why this is causing an error? :( http://pastebin.com/m4837181d
09:59:02 <atp> Peaker: use finger trees
09:59:07 <atp> Peaker: actually that's also amortized
09:59:11 <Cale> kayess: Your friend should just put definitions in a file anyway
09:59:16 <atp> Peaker: i'm not sure it's possible in O(1) time
09:59:25 <atp> Peaker: i think it needs to be amortized
09:59:31 <mauke> JakeP: what error?
09:59:32 <kayess> Ah, ok thanks
09:59:40 <Baughn> Peaker: As an exercise, turn the amortized-if-you-never-reuse-values O(1) time into really-amortized O(1) time by applying lazy evaluation
09:59:43 <JakeP> "possibly incorrect indentaiton"
09:59:48 <JakeP> on line 17
09:59:52 <Cale> JakeP: I'll look
09:59:58 <Peaker> Cale: interactive shells are great for learners.. the UI of editing/saving/running/.. cycle is not fun
10:00:03 <JakeP> thank you :) its been killing me
10:00:08 <Cale> JakeP: there are tabs in your file
10:00:09 <atp> Peaker: interactive shells are great for experts too
10:00:26 <Cale> JakeP: replace them with spaces, and tell your editor to expand tabs automatically
10:00:27 <atp> Peaker: those of us that are refugees from lisp will never deal well with languages that don't have REPLs :)
10:00:38 <Peaker> atp: I'm a Python refugee :)
10:00:48 <JakeP> oh, ok, thanks, i suck :P
10:00:49 <atp> Peaker: i won't hold it against you :P
10:00:56 <atp> Peaker: (just kidding, python is great)
10:01:05 <Cale> JakeP: at least, that's the first thing
10:01:12 <JakeP> a gui like DrScheme for haskell would be awesome
10:01:15 <zachk> im a schemer that wanted an actual compiler and some libraries
10:01:28 <kayess> Thanks Cale, he's compiling ghci on his mac, but it's taking ages. I guess he'll have to wait :)
10:01:30 <atp> zachk: have you seen stalin scheme?
10:01:30 <Cale> JakeP: There's also the problem that the guards in getNextState are missing = signs after them
10:01:37 <atp> zachk: on the compiler part i mean
10:01:39 <Cale> kayess: Don't compile it!
10:01:46 <Baughn> atp: gdb makes a good repl for C.. kinda...
10:01:50 * Baughn breaks down in tears
10:02:01 <Cale> kayess: The only excuse for compiling GHC is if you're hacking on it, or if there isn't a binary for your platform.
10:02:08 <zachk> atp: i recently looked at it again, it was offline like a year ago though and seemed dead, now it seems to be maintained again
10:02:11 <Peaker> Baughn: cinvoke makes for a good REPL for C!
10:02:11 <atp> Baughn: i know how you feel, i coded C professionally for almost ten years
10:02:11 <Cale> kayess: There's a nice mac OS X package.
10:02:28 <Peaker> atp, Baughn: I wrote CInvoke which lets you control C processes from the Python prompt remotly, via a pipe :)
10:02:38 <Peaker> sort of like ctypes-over-a-pipe
10:02:43 <kayess> Thanks again Cale :) I'll get him to grab one. He was using port install
10:02:44 <atp> that's pretty cool
10:02:47 <mjrosenb> hey, anyone know if ghc works on opensolaris?
10:02:51 <Cale> http://www.haskell.org/ghc/download_ghc_683.html#macosxppc
10:02:51 <lambdabot> Title: GHC: Download version 6.8.3
10:02:55 <Baughn> Peaker: Yes, you mentioned that
10:03:04 <atp> i hate to say this, but i'll always have a soft spot in my heart for C
10:03:24 <atp> i almost never write anything in it anymore
10:03:30 <atp> but one rarely forgets a first love
10:03:33 * atp grins.
10:03:51 <zachk> i had strings as datatypes pre 90's ive never liked C for its lack of strings
10:03:55 <Peaker> there's augustss's implementation of C as a Haskell DSL :)
10:04:01 <JakeP> Cale, thanks, the tabs fixed it, and yea whoops forgot the = on the otherwise guard
10:04:18 <Cale> JakeP: no problem :)
10:04:19 <Peaker> Well, not quite C, but close :)
10:04:32 <Cale> Peaker: Oh, also, have you read about finger trees?
10:04:38 <atp> the main benefit of C is that it forces you to confront the metal
10:04:41 <atp> that's also the downside
10:04:52 <atp> Cale: finger trees are so awesome
10:04:54 <Cale> Peaker: Lots of nice efficient structures are special cases of finger trees :)
10:05:00 <Cale> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/fingertree
10:05:01 <lambdabot> Title: HackageDB: fingertree-0.0, http://tinyurl.com/35pz7w
10:05:04 <atp> Cale: i thought Data.Sequence was implemented as a 2-3 finger tree?
10:05:09 <Cale> atp: it is
10:05:15 <Peaker> Cale: nope, I have soo much on my to-read list :)
10:05:20 <atp> Peaker: move this up
10:05:24 <atp> Peaker: it'll blow your mind
10:05:32 <Peaker> atp, Cale: Thanks, I will :)
10:06:33 <Peaker> atp: I think C could have been so much more elegant without losing much without its ugly idea of arrays-degradation, and simpler pointer syntax (postfix instead of prefix)
10:07:15 <pozic> cabal install cpphs succeeded. Where can I find the binary?
10:07:37 <MyCatVerbs> pozic: PREFIX/bin/. If you're using csh, rehash. :)
10:07:40 <vixey> http://hpaste.org/9033
10:07:56 <atp> Peaker: it has warts to be sure
10:08:12 <MyCatVerbs> pozic: by default, PREFIX is usually... /usr/local, I think? Not entirely certain on that one.
10:08:35 <atp> Peaker: its chief benefit i think is that it is very simple while maintaining enough complexity to be easy to understand (unlike, say, assembly, which is simple but not easy to understand)
10:08:44 <Peaker> say, is it true that COBOL functions cannot call other COBOL functions?
10:08:58 <dcoutts> MyCatVerbs, pozic: cabal-install's default is --user not --global, user installs are to ~/.cabal/ by default.
10:09:12 <Peaker> atp: I think its probably easier to teach assembly than C -- probably depends on which kind though
10:09:19 <dcoutts> pozic: so check ~/.cabal/bin/
10:09:27 <MyCatVerbs> dcoutts: oh, is it? D'okay. I'm just going off what the default install path is if you don't use cabal-install at all.
10:09:28 <Peaker> Did COBOL have a call stack limit of.. one?
10:09:36 <dcoutts> pozic: it's a bug really that we don't install to somewhere on the $PATH
10:09:45 <MyCatVerbs> dcoutts: hang on, that's crazy. Who puts a dotfile-directory in $PATH? :)
10:09:45 <zachk> To compile and use Stalin, you must have a C compiler installed.
10:09:56 <atp> Peaker: it is easier to teach... assembly is extremely, extremely simple.  it's the lack of control structures that makes it hard to read afterwards.
10:09:59 <dcoutts> MyCatVerbs: right, we changed it to --user installs by default for cabal-install
10:10:00 <JakeP> cs at waterloo had scheme the first semester and C the next, that was a painful transition for people with scheme as the first language and a boring one for people with c as their first language
10:10:01 <MyCatVerbs> zachk: /compile and use Stalin/be a worthwhile human being/
10:10:13 <MyCatVerbs> dcoutts: what's wrong with just $HOME?
10:10:14 <JakeP> the teacher couldnt think of a good way to transition scheme into c
10:10:19 <dcoutts> MyCatVerbs: the reason is that people objected to us writing to ~/bin/ by default. We're still working something out.
10:10:43 <dcoutts> MyCatVerbs: I'd object to installing to $HOME :-) I don't have and don't want a ~/lib/ dir
10:10:51 <zachk> MyCatVerbs: im on windows and i hate cygwin
10:11:03 <vixey> I pasted a doubly linked list
10:11:11 <vixey> I don't know if it can be done better
10:11:20 <dcoutts> MyCatVerbs: our solution is to install to ~/.cabal/ but to symlink into ~/bin and be careful not to overwrite things that we did not install. That latter feature is not yet implemented.
10:11:36 <mauke> leave my ~/bin alone :-(
10:11:41 <dcoutts> mauke: why?
10:11:50 <mauke> because I don't want a bin/ in my ~
10:11:58 <Cale> JakeP: It's better than what they were doing when I was there, which was using Java as an implementation language and only briefly touching on scheme.
10:12:02 <dcoutts> mauke: so where would we put it?
10:12:03 <Baughn> How about ~/sw/?
10:12:11 <mauke> ~/usr/local/bin
10:12:13 <MyCatVerbs> zachk: "I'm on Windows" <-- says it all, really. ;)
10:12:19 <dcoutts> mauke: erm no :-)
10:12:20 <Cale> JakeP: Of course, you'd hope that by the later years, the implementation language doesn't matter :)
10:12:22 <atp> dcoutts: i would stick with bin and make it overridable with an env variable
10:12:28 <MyCatVerbs> zachk: (no, I'm kidding. But at least get yourself Borland or MSVC or something. :D)
10:12:32 <mauke> dcoutts: that's where my local executables are
10:12:38 <Baughn> ~/Program Files?
10:12:38 <dcoutts> mauke: you can configure that in your ~/.cabal/config but it's a bonkers default :-)
10:12:41 <atp> dcoutts: or maybe not an env variable, but a commandline option
10:12:46 <vixey> programming languages are so rubbish today that it does matter what you use
10:12:49 <Deewiant> Baughn: :-D
10:12:49 <dcoutts> atp: we use the ~/.cabal/config
10:12:51 <MyCatVerbs> dcoutts: that's pretty civilised, I guess.
10:12:54 <atp> dcoutts: good enough
10:13:03 <MyCatVerbs> dcoutts: personally, $HOME/stuff. ^_^
10:13:07 <int-e> dcoutts: oh is the symlinking turned on or off by default?
10:13:07 <atp> vixey: today?
10:13:09 <Cale> JakeP: I was in pure mathematics though, so I'm not altogether sure how things went after 2nd year in CS :)
10:13:13 <atp> vixey: you mean they were better yesteryear?
10:13:25 <atp> Cale: pure math ftw
10:13:25 <vixey> atp: No I do not mean that
10:13:26 <dcoutts> int-e: I would have it turned on by default. It's not yet implemented. Want to implement it?
10:13:49 <MyCatVerbs> atp: if by "yesteryear" you mean "the day before Stroustrup envisioned C++", maybe on average... ;)
10:13:54 <int-e> dcoutts: no, but it sounds potentially dangerous as a default.
10:14:01 <dcoutts> int-e: how so?
10:14:02 <Cale> atp: Yeah, no worrying about what programming language you're going to use there :)
10:14:04 <JakeP> Cale, yea, the intro with scheme was pretty awesome, defiantly better than starting off with java.. people new to cs were ok and the experienced weren't bored.. the transition to c in the second semester was the first time theyve done it, so i guess they still have to iron out the kinks
10:14:13 <dcoutts> int-e: if we're careful not to overwrite anything we did not install
10:14:17 <atp> MyCatVerbs: C++ is an abomination, to be sure, but there bad languages before him that were just as popular (or more), like COBOL
10:14:23 <zachk> MyCatVerbs: im not on windows by choice, its my mom's computer, my machine upstairs has a skeleton version of openbsd running, but it lacks internet access so its mostly useless
10:14:23 <MyCatVerbs> atp: (but of course not, because yesteryear they still had PL/I, whereas now it's... if not dead, at least comatose.)
10:14:24 <Saad_> Hey guys, is there a package which supports getting webcam feed in haskell?
10:14:27 <Cale> JakeP: I think they should transition to Haskell instead ;)
10:14:38 <dcoutts> int-e: which of course we can tell because if we installed it it'll be a symlink pointing into ~/.cabal/bin
10:14:49 <JakeP> Cale, , i wish :)
10:14:58 <int-e> dcoutts: hmm, I think I parsed "latter feature" incorrectly. Ok, then it's no less dangerous than installing untrusted packages is anyway.
10:14:59 <atp> Cale: i thought momentarily about going into CS my freshman year and then realized that CS ceased to be rigorous and interesting pretty much as soon as it became its own department separate from math
10:15:01 <dcoutts> int-e: if it was installed by someone else then we give a warning telling the user about it
10:15:06 <Cale> JakeP: though I suppose C does tie in perhaps somewhat better with low level architectural details
10:15:10 <MyCatVerbs> zachk: no router? Pity.
10:15:17 <int-e> dcoutts: s/no less/no more/
10:15:30 <MyCatVerbs> zachk: OpenBSD is nice, in an odd way. Don't see so many people using it these days, though.
10:15:36 <dcoutts> int-e: so I'm hoping someone will implement this for us :-)
10:15:46 <Cale> atp: mm... at Waterloo? It's still technically part of the Mathematics faculty isn't it?
10:15:52 <atp> Cale: i wasn't at waterloo
10:15:55 <Cale> ah
10:15:59 <atp> Cale: i meant in general
10:16:12 <atp> Cale: CS as a discipline grew out of the math departments at, for example, stanford
10:16:17 <dcoutts> int-e: as everyone says, not installing to somewhere on the $PATH by default is bonkers and confuses all the noobs
10:16:27 <atp> Cale: back in those days it was fringe enough that it didn't warrant its own department
10:16:38 <atp> Cale: and in those days people, you know, proved things.
10:16:39 <int-e> (I'm not a cabal-install user at the moment, my setup involves /opt/ghc-<version> prefixes and I haven't bothered to figure out how to teach cabal-install about that)
10:16:40 <JakeP> Cale, yeah, thats true a lot of our classes later (operating systems etc) need c and assembly
10:16:56 <zachk> MyCatVerbs: guess i need to get  c++ compiler to get hackage readline working :-9
10:16:58 <pozic> dcoutts: while saving the n00bs, how about using one command to install cabal install?
10:17:00 <Cale> Yeah. One thing that I really liked about Waterloo was the fact that it had a mathematics faculty at all. Mathematics doesn't really fit under science or arts.
10:17:02 <dcoutts> int-e: easy (I think) we can set the ghc path in the ~/.cabal/config
10:17:12 <atp> Cale: judging by the few CS students that ventured into my algebra classes, they couldn't do proofs worth squat.
10:17:21 <Cale> And CS makes a natural department of a mathematics faculty :)
10:17:25 <dcoutts> pozic: if you've got cabal-install installed then it is one command! ;-)
10:17:29 <atp> Cale: which is a shame, because CS fits with math really well.
10:17:30 <monochrom> If you join formal methods or computability+complexity you will still prove lots of things.
10:17:47 <dcoutts> pozic: obviously the solution is for it to be included in the haskell platform bundle
10:17:49 <int-e> dcoutts: yes, except that I switch between versions by setting environment variables ... I'd like to have one for changing the .cabal directory, I think.
10:17:52 <atp> monochrom: where "lots of things" is vanishingly small relative to pretty much any upper division math course.
10:18:08 <JakeP> apt, i guess it depends on the person.. there are rigorous/theoretical cs classes, and there is the BMath/CS degree option... but a lot come because they want to make video games/etc
10:18:10 <atp> monochrom: let's face it, most CS departments don't emphasize rigorous proof at the undergraduate level.
10:18:13 <dcoutts> int-e: it'll use whatever is on the path by default, would that not be enough?
10:18:30 <vixey> are there prerequisites for doing a formal methods course?
10:18:31 <monochrom> Ah, I'm speaking of grad research. :)
10:18:33 <pozic> atp: how can you tell? Did you visit >50% of them?
10:18:33 <Peaker> Can someone download something from the ACM portal for me? (http://portal.acm.org/ft_gateway.cfm?id=581482&type=pdf&coll=GUIDE&dl=GUIDE&CFID=78559934&CFTOKEN=88275807)
10:18:42 <JakeP> atp, we did a bit of program proving via induction in our first year
10:18:48 <Peaker> its in ICFP paper - which became unavailable in all other methods
10:18:50 <dcoutts> int-e: or one can use versioned ghc's like I do, then I say cabal install foo -w ghc-6.6.1
10:18:51 <atp> pozic: nope.  but i've been exposed to a lot of CS majors in my life time.
10:18:59 <MyCatVerbs> atp: I'm a CS student, and I'm both too lazy and too incapable to do proofs. :)
10:19:03 <pozic> atp: how do you do that?
10:19:09 <shepheb> my last algorithms (Cale: CS341) assignment is all proofs of things to do with NP and P.
10:19:11 <Cale> atp: There are still some really good hardcore courses at waterloo. :) My CS friends could mostly handle proofs... not quite as well as us in pure mathematics, but they were fairly capable. There was a really nice 4th year CS course on the theory of formal languages that was essentially monoid theory :)
10:19:11 <int-e> dcoutts: I'll have to look at what cabal-install currently does exactly before I can answer that question, so let's postpone this discussion.
10:19:15 <monochrom> vixey: there may be a logic prerequisite, or some formal method courses give you a logic crash course at the beginning.
10:19:15 <dcoutts> int-e: I've got on my path 'ghc' 'ghc-6.6.1' 'ghc-6.4.2'
10:19:35 <atp> MyCatVerbs: i'm lazy too.  the difference is that in a math program, you don't have a choice, it's pretty much the raison-d'etre of the curriculum.
10:20:01 <dcoutts> int-e: ok, and there are options which currently are not in the config file which we fully intend to add. Basically anything you can set on the command line should be able to be set in the config file.
10:20:05 <atp> Cale: sounds pretty good, too bad i didn't go there :).  At my school, CS had become java school.
10:20:13 <MyCatVerbs> atp: good thing I didn't take a pure mathematics course, then. ;)
10:20:24 <atp> MyCatVerbs: you should!
10:20:48 <Cale> atp: Strangely enough, when I was there, there was a good lot of Java in the early courses too, because Waterloo has a big coop program, and they allow themselves to be influenced by that a little too much at times.
10:20:48 <atp> MyCatVerbs: proofs are really nice once you have some practice doing them.  you start wondering "i wonder if i could prove that" about everything you come across.
10:20:49 <MyCatVerbs> atp: admittedly maths courses are pretty resistant to the tendency towards spontaneously turning into Javaschools than CS departments are...
10:21:00 <atp> MyCatVerbs: true.
10:21:12 <monochrom> I wonder if I can implement that.
10:21:13 <MyCatVerbs> atp: nononono, not true.
10:21:22 <MyCatVerbs> atp: maybe true, maybe not.
10:21:25 <Cale> But by the sounds of it, they're in the process of cleaning up that mess :)
10:21:30 <MyCatVerbs> atp: for the moment, just conjecture. ;D
10:21:32 <vixey> implement what?
10:21:47 <atp> Cale: i don't actually have anything against Java, it's just that i like rigour and CS depts don't seem to provide much of it anymore.
10:21:50 <monochrom> implement everything I come across. :)
10:21:53 <Cale> Another good thing is that CS students for the first year and a half take the same courses as mathematics students. :)
10:22:04 <atp> Cale: i'd consider doing a phd in CS, that could be fun, at the right school with the right advisor.
10:22:11 <atp> Cale: but undergrad?  waste of time.
10:22:12 <MyCatVerbs> vixey: a response to atp's statement that learning to construct proofs makes you think "I wonder if I can prove that".
10:22:19 <JakeP> our cs classes (which everyone in math has to take 2 of) are now scheme for the first semester, scheme/c for the second, with the option  of combining both into an advanced one semester version
10:22:21 <JakeP> no java
10:22:32 <atp> JakeP: nice, what school?
10:22:33 <chrisdone> @hoogle io
10:22:33 <lambdabot> System.IO :: module
10:22:33 <lambdabot> Data.Array.IO :: module
10:22:33 <lambdabot> Prelude.IO :: data IO a
10:22:37 <JakeP> waterloo
10:22:42 <shepheb> JakeP: you're a UW undergrad?
10:22:51 <JakeP> they started changing things up a couple of years ago
10:22:51 <MyCatVerbs> vixey: monochrom's point seems to be that CS education has the analogous effect of making people think "I wonder if I can implement that", etc.
10:22:54 <JakeP> yea
10:23:17 <shepheb> I, as well. 3A.
10:23:25 <monochrom> I wonder if I can implement that and prove it correct. :)
10:23:27 <shepheb> sucks to have missed out on the Scheme intro courses
10:23:44 <atp> monochrom: nice :p
10:24:04 <atp> shepheb: SICP is available on-line, you know :)
10:24:10 <MyCatVerbs> monochrom: or, heh, make like the automatic formal verification people and ask, "I wonder if I can implement that in a way that carries a proof of correctness for itself?" :)
10:24:10 <monochrom> (I have long unified "programming" and "proving".  They are the same brain activity for me.)
10:24:32 <shepheb> atp: I'm (re-)reading it right now, in fact.
10:24:32 <JakeP> it was good to have scheme to start because it takes like 10 minutes to learn most of the language and syntax... the rest of the time is spent thinking and doing algorithms
10:24:48 <MyCatVerbs> monochrom: hrmn, interesting perspective. I haven't picked that up at all.
10:24:53 <JakeP> going back to c was a reminder of how much a pain in the ass it can be
10:24:55 <shepheb> JakeP: oh, are you new enough to have taken the new ones?
10:25:00 <JakeP> yupp
10:25:01 <Deewiant> and how much fun it can be
10:25:02 <JakeP> 2A
10:25:09 <atp> C & asm can be lots of fun
10:25:16 <atp> they're low-level, it's a different mindset
10:25:18 <Cale> JakeP: Yeah, I think I remember Prabhakar Ragde talking about changing the curriculum just as I was leaving.
10:25:24 <atp> but not for large projects, ugh
10:25:26 <JakeP> atp, completely true
10:25:52 <MyCatVerbs> atp: ugh. C is irritating after hacking on Haskell for long enough.
10:26:02 <MyCatVerbs> atp: just that everything you want to do always takes so bloody long.
10:26:14 <atp> MyCatVerbs: that's true, but there's something fun about it.
10:26:14 <JakeP> cale, yea it looks like he wrestled control of the first year curriculum.. his classes are the only ones.. (CS135->CS136, or CS145 which is both)
10:26:22 <atp> i kind of like low-level stuff
10:26:42 <atp> at my work they won't let me have a compiler, which really bugs me
10:26:52 <Deewiant> a C interpreter then? ;-)
10:26:54 <MyCatVerbs> atp: huh. Where'd'you work?
10:26:55 <atp> so i wrote one in machine language (not asm)
10:27:00 <Deewiant> :-D
10:27:04 <Nafai> atp: They won't let you have a compiler?
10:27:13 <JakeP> atp, that's hardcore :P
10:27:14 <atp> well, not a compiler, an interpreter... for forth
10:27:20 <atp> JakeP: it actually wasn't that hard
10:27:27 <MyCatVerbs> Ah, good idea.
10:27:28 <Deewiant> ah, well forth is relatively simple to implement, no?
10:27:36 <atp> JakeP: the biggest difficulty was figuring out how to write Windows PEs
10:27:48 <atp> Deewiant: yeah, and much of the work was done for me... google for "jones forth"
10:27:53 <MyCatVerbs> Deewiant: Yes, but it's also fantastically high-level. Well, can be. :)
10:28:04 <atp> forth is awesome.
10:28:09 <atp> forth is the dual of lisp :)
10:28:10 <Deewiant> yep, forth is a funny in-between-level language
10:28:18 <pozic> The Forth books are fairly nice too.
10:28:28 <atp> but this is how you boostrap onto an architecture when you don't have dev tools
10:28:37 <pozic> Full of cartoons.
10:28:38 <atp> if you can output arbitrary binary data into a file,
10:28:43 <atp> you can write a forth interpreter
10:28:47 <atp> and then! whammo!
10:28:57 <atp> there's a scheme interpreter written in forth that i use at work now :)
10:29:00 <atp> hahaha
10:29:04 <atp> suck that, IT!
10:29:11 <shepheb> I wonder how much difference learning FP thinking two years earlier would have made. certainly significant.
10:29:52 <vixey> "Arithmetical hierarchy" makes no sense
10:30:06 <bwr> i'm running an entirely different OS at work that i'm not supposed to be using :P
10:30:21 <atp> bwr: i did that at my last job, it actually got me in a fair amount of trouble
10:30:26 <atp> bwr: be careful :)
10:30:40 <bwr> atp: yea, i will be
10:30:51 <bwr> people in my office know and don't care
10:30:57 <atp> bwr: and actually if IT ever finds my forth/scheme project they'll probably really have a cow
10:30:59 <SamB> shepheb: you would have had two years less of research to catch up with
10:31:01 <bwr> it is just the IT dept of the larger copr
10:31:02 <bwr> corp
10:31:11 <JakeP> in first semester cs about 3/4 of the way one assignment was really cool.. we had to write a small scheme interpeter in scheme, a function to take the derivative of other functions, and a few other thinghs like that (all of which id done already by luck)
10:31:11 <atp> they already yelled at me big time when they found ghc on my machine some months ago
10:31:15 <bwr> lol
10:31:20 <bwr> do you work as a programmer?
10:31:23 <atp> no
10:31:24 <bwr> oh ok
10:31:26 <atp> i work in finance
10:31:29 <shapr> I tried to use IronPython.NET at work thursday, but my boss wasn't happy. So I ported working Python code to C#
10:31:42 <atp> they expect me to use visual basic or sas if i want to program, ugh
10:31:47 <shapr> ouch
10:31:49 * atp barfs.
10:31:53 <shapr> @yow !
10:31:53 <lambdabot> Couldn't find fortune file
10:31:57 <JakeP> we had the guy who does the highschool programming contests for canada and another who liked really theoretical stuff making our assignments, it was neat
10:31:57 <bwr> we are actually allowed to use just about anything as long as our team approves it
10:32:02 <shapr> @quote fortune
10:32:02 <lambdabot> No quotes match. Are you on drugs?
10:32:09 <bwr> we have teams using ruby and groovy
10:32:12 <shapr> @quote shapr
10:32:12 <atp> bwr: nice
10:32:12 <lambdabot> shapr says: Programming is the Magic Executable Fridge Poetry, it is machines made of thought, fueled by ideas.
10:32:23 <bwr> our team is using mostly flex and java
10:32:23 <pozic> atp: but that's the industry standard! That's the best humanity can make! You infidel!
10:32:35 <shapr> My team uses C#
10:32:37 <SamB> shapr: give me some more magnets, I ran out of "maps"
10:32:41 <atp> the main issue at my firm is that i'm not a developer, i'm a quantitative analyst... so SAS70 requirements won't let me have dev tools without them changing my title
10:32:47 <shapr> SamB: hah
10:33:02 <Peaker> atp: doesn't sound like a great workplace
10:33:03 <bwr> atp: that's ridiculous
10:33:12 <shapr> SamB: I do wish for a magnetic surface that can figure out which magnets are on a board and where.
10:33:12 <atp> Peaker: it is when your aspiration is not to be a programmer
10:33:16 <shapr> And then turn it into real code!
10:33:31 <pozic> atp: do you also have nano operators? (People with the permission to run nano)
10:33:37 <Peaker> atp: what do you aspire to do at the workplace?
10:33:38 <SamB> shapr: idea: set up a digital camera to see the board
10:33:49 <shapr> SamB: yeah, probably the best bet.
10:33:53 <atp> Peaker: develop risk models so that we have more alpha with less risk
10:34:00 <atp> Peaker: i'm a math guy, CS is a hobby
10:34:02 <shepheb> JakeP: I'm jealous, btw.
10:34:14 <SamB> atp: but they won't let you write programs to do it for you?
10:34:18 <Elly> are there actually haskell fridge magnets?
10:34:20 <atp> SamB: sure they do, just not in haskell
10:34:24 <Peaker> atp: to do maths effectively, you often need to write software..
10:34:32 <shepheb> JakeP: my first-year assignments were things like "implement doubly-linked lists in Java. This is your brain on OO Kool-Aid"
10:34:42 <monochrom> G√∂del says that you can pay lip service to your boss when he says "you must use ___language_here___".
10:34:54 <pozic> shepheb: did you already do that in Haskell?
10:35:04 <monochrom> Note I say G√∂del, not Turing.   *sinister snicker*
10:35:08 <atp> Peaker: the ironic thing is part of their stated reason for hiring me was my extensive programming background, but the IT dept is very nervous about giving me real dev tools
10:35:19 <shepheb> pozic: no, we're talking about introductory programming classes.
10:35:20 <atp> Peaker: it's a battle i'm still fighting :p
10:35:26 <Peaker> atp: what are the worst-case consequences, in their view?
10:35:31 <byte-> atp, well, to be fair
10:35:35 <atp> Peaker: failing a SAS70 audit?
10:35:35 <SamB> monochrom: is this some subtle joke about goedel numbering?
10:35:39 <JakeP> shepheb, ah that stinks :(
10:35:39 <byte-> atp, they don't know if you'll hack into a tanker ship and sink it or something
10:35:39 <Peaker> atp: what's that?
10:35:41 <monochrom> Yes! :)
10:35:47 <SamB> atp: what is SAS70?
10:35:58 <atp> Peaker: when you manage 20 billion dollars, you get regulated
10:36:03 <SamB> byte-: you can't do that in VB?
10:36:07 <shepheb> JakeP: the horrifying part was that, although the class wasn't exactly exciting, I didn't realize how horrific the language was.
10:36:10 <atp> Peaker: they don't want a SocGen fiasco
10:36:10 <monochrom> Any language with enough arithmetic operators and arrays will do. :)
10:36:13 <byte-> SamB, is that what they used in the movie?
10:36:21 <Peaker> atp: what's the purpose of a regulation that verifies people don't have certain pieces of software installed?
10:36:29 <JakeP> we were doing things like graph searching algorithms almost right away... and there would always be bonus questions on cool things like continuations
10:36:33 <SamB> byte-: they probably used Flash
10:36:38 <monochrom> In fact I highly recommend doing that as a punishment to your boss. :)
10:36:44 <shepheb> when recently I wrote some Java for a CS341 assignment, and was pleasantly surprised that it only hurt a bit.
10:36:46 <atp> Peaker: no, that's just the tip of the iceberg.  the real issue is making sure that there's separation of powers and responsibilities and that one person can't sink the whole ship
10:36:54 <JakeP> shepheb, haha
10:37:02 <mjrosenb> is there any sort of a .rc file for ghci?
10:37:02 <atp> Peaker: it's actually not stupid, it's just annoying
10:37:20 <Deewiant> mjrosenb: .ghci
10:37:26 <monochrom> Basically it is "you made me write VB, I'll write you obfuscated VB" taken to the extreme. :)
10:37:36 <SamB> atp: I still don't understand how that justifies your use of VB
10:37:44 <byte-> find a haskell -> vb compiler
10:37:47 <atp> monochrom: i should write a brainfuck interpreter in VB
10:37:50 <Deewiant> mjrosenb: in %USERPROFILE% on Windows and presumably $HOME on *nix
10:37:53 <atp> monochrom: and write all my code in brainfuck
10:37:56 <bwr> haha
10:37:58 <bwr> that would be great
10:37:59 <monochrom> Yes, that works too. :)
10:38:00 <byte-> or a c -> vb compiler and use ghc to output c
10:38:02 <atp> monochrom: in Excel!  just to make it worse!
10:38:13 <byte-> but i think that last one might be a little mean
10:38:19 <bwr> byte-: can ghc output plain c? i thought it was c-- or something?
10:38:24 <Peaker> atp: sorry to press it, but I'm really curious: why does the software that's installed in various computers make one person's sinking of the ship more possible?
10:38:25 <monochrom> If your boss is mean to you, get even.
10:38:27 <mjrosenb> Deewiant: awesome.  it should just act like cat .ghci - | ghci?
10:38:35 <SamB> GHC output is entirely unreadable
10:38:36 <byte-> bwr, i'm not sure
10:38:42 <byte-> i know ddc outputs c99
10:38:46 <atp> Peaker: well, it's a security issue for IT
10:38:47 <mjrosenb> SamB: ?
10:38:48 <SamB> monochrom: I was under the impression it was the IT department, not his boss
10:38:48 <byte-> not sure about ghc, but you'd think it would
10:38:51 <Deewiant> mjrosenb: I think so... if not, it'll be in the docs ;-)
10:38:51 <byte-> it's not that hard to write a c backend
10:38:53 <atp> Peaker: they want to know who has what and who does what
10:39:04 <monochrom> Or the IT department.
10:39:30 <atp> i actually get along well with the IT dept most times, but they are afraid of me
10:39:37 <atp> or so i've heard, through the grapevine
10:39:39 <atp> :(
10:39:50 <Peaker> atp: short fuse? :)
10:39:53 <SamB> probably you think to much and don't eat enough for their taste
10:39:59 <SamB> s/to/too/
10:40:18 <monochrom> "Methinks thou doth think too much"?
10:40:23 <atp> Peaker: well, no, we had this process that we run on weekends that was failing regularly and necessitated us coming in to fix it
10:40:36 <atp> Peaker: basically the vendor's application that ran the process was flaky
10:40:52 <monochrom> They feel sorry for calling you in?
10:41:01 <atp> Peaker: i wrote a network server in haskell that would launch the process and monitor it, and if it crashed or started hanging it would kill it and restart it automatically
10:41:10 <vixey> any new fp papers worth reading?
10:41:19 <monochrom> They feel you're a genius?
10:41:35 <atp> Peaker: then i used win32 bindings in visual basic to talk to the haskell server from an excel spreadsheet, which autoformatted the output and put it where it needed to be
10:41:46 <atp> so suddenly everything worked for a while
10:41:56 <SamB> "such men are dangerous, they think too much"
10:41:58 <atp> until IT noticed that there was all this network traffic on the LAN
10:42:01 <atp> and looked into it
10:42:07 <atp> they freaked the fuck out
10:42:15 <Peaker> atp: hehe
10:42:23 <atp> those reports are used to make investment decisions and we manage billions of dollars
10:42:23 <shapr> Elly: Seems that cafepress does not allow people to write their own fridge magnets. I wonder if there are mafiaa reasons for that?
10:42:35 <atp> so i got in a lot of trouble
10:42:36 <monochrom> Is it a lot of traffic? congestion?
10:42:37 <atp> :(
10:42:41 <atp> no, no
10:42:45 <chrisdone> sensitive data
10:42:45 <SamB> and ... having to send people in was more reliable?
10:42:45 <Saul__> @seen Lemmih
10:42:46 <lambdabot> I saw Lemmih leaving #haskell 1d 4h 38m 55s ago, and .
10:42:47 <atp> just on a random port > 1024
10:42:51 <atp> they'd never seen it before
10:42:56 <monochrom> They don't like non-human writing the reports?
10:43:04 <Elly> shapr: I would love a set of haskell fridge magnets
10:43:07 <shapr> Sadly, cafepress also does not let people print out magnets on plastic that could be cut at home.
10:43:11 <shapr> Elly: So would I!
10:43:18 <atp> well, a non-human was writing the reports already, they get output by our process
10:43:20 <Peaker> I wanna read "Monads for incremental computing" again (ICFP paper) but only an ACM copy exists now :-(  the other links broke..
10:43:25 <Peaker> Does anyone here have an ACM subscription ready?
10:43:39 <SamB> shapr: find another vendor?
10:43:47 <bitrot> Peaker: yes
10:43:48 <Elly> Peaker: I think my school does
10:43:50 <shapr> SamB: Any suggestions?
10:43:56 <Elly> I can proxy through one of their boxen
10:44:15 <SamB> shapr: buy blank sheets and feed them through a plotter?
10:44:43 <int-e> Peaker: hmm. http://citeseer.ist.psu.edu/619122.html - is that the right one?
10:44:43 <Peaker> bitrot: http://portal.acm.org/ft_gateway.cfm?id=581482&type=pdf&coll=GUIDE&dl=GUIDE&CFID=37289220&CFTOKEN=13389801 -- can you download that?
10:44:43 <lambdabot> Title: Monads for Incremental Computing - Functional Pearl (ResearchIndex)
10:44:54 * EvilTerran could probably ssh into the uni comlab and get it that way, too
10:45:00 <vixey> while hoarding ACM stuff ... get Principles of a Reversible Programming Language ? :p
10:45:01 <Peaker> int-e: yeah - the PDF link is broken
10:45:09 <Peaker> hey the PS one works
10:45:10 <int-e> Peaker: works for me. hmm.
10:45:22 <EvilTerran> may just be a server hiccup
10:45:31 <vixey> http://portal.acm.org/citation.cfm?doid=1366230.1366239
10:45:33 <lambdabot> Title: Principles of a reversible programming language
10:45:44 <Peaker> int-e: weird! It failed for a few times, then it started working. Maybe browser cache
10:45:50 <atp> can anyone explain why people prefer PDF to ps.gz
10:45:52 <monochrom> the cached pdf link works
10:45:54 <atp> the latter is smaller and nicer
10:46:01 <monochrom> The former is searchable.
10:46:04 <Peaker> atp: I think gnome's PDF reader is better than the PS reader
10:46:16 <atp> i use gv
10:46:21 <bitrot> Peaker: http://shsu.edu/~stdsmd15/monads.pdf
10:46:22 <Peaker> bitrot: thanks - it ended up ok
10:46:22 <lambdabot> Title: cache:http://shsu.edu/~stdsmd15/monads.pdf - Google Search
10:46:24 <atp> what do you use?
10:46:26 <EvilTerran> atp, because loads of people are on windows, and that doesn't come with a PS reader but usually comes with adobe reader?
10:46:33 <Elly> vixey: http://portal.acm.org/ft_gateway.cfm?id=1366239&type=pdf&coll=ACM&dl=ACM&CFID=78561871&CFTOKEN=93130194
10:46:33 <bitrot> ok
10:46:38 <Peaker> atp: the default gnome "document reader" -- it has search for PDF but not for PS
10:46:41 <Elly> is Principles of a Reversible Programming Language
10:46:50 <atp> Peaker: hm.
10:46:54 <SamB> atp: PDF can have table of contents, you can copy+paste from well-made ones, it isn't hard to open them on windows, etc...
10:47:12 <atp> PDF is hard to open on windows if you don't have adobe reader installed
10:47:15 <monochrom> Two reasons I prefer pdf over ps.  Its text is searchable.  It is more popular among kids.
10:47:16 <atp> ok, i have to go
10:47:18 <vixey> Elly, thank you !
10:47:24 <SamB> atp: well that would be silly of you
10:47:24 <atp> going to go see batman!
10:47:27 <monochrom> Oh, and what SamB says.
10:47:28 <Elly> atp: it's good
10:47:32 <SamB> or your stupid IT department
10:47:42 * atp laughs at SamB.
10:47:43 <shapr> Elly: Looks like it's not too expensive to print Haskell magnets. But, what to put on them?
10:47:48 <monochrom> Oh, and pdf has hyperlinks (both to www and to same document)
10:47:52 <sclv_> Mu
10:48:05 <sclv_> fib functions
10:48:14 <shapr> We need a tokenizer, a frequency analyzer and the entire contents of Hackage.
10:48:15 <EvilTerran> pdfs have forms, too!
10:48:22 <Elly> yeah, that's a good plan
10:48:23 <EvilTerran> bloody awful forms, but some folks still think that's a good idea
10:48:24 <shapr> Then we'd know what to put on the fridge magnets.
10:48:25 <sclv_> on a magnet?
10:48:29 <Elly> I was going to say just a bunch of higher-order functions
10:48:38 <EvilTerran> ooh, haskell magnetic poetry
10:48:38 <vixey> PDF and PS are suboptimal
10:48:39 <EvilTerran> DO WANT
10:48:45 <shapr> sclv_: I don't think all of hackage would fit on a magnet, not even at 2pt size.
10:48:46 <vixey> no point choosing between them, make something better
10:48:49 <atp> SamB: a part of me can't wait until they find my forth program.  "I thought we told you not to have a compiler!" "It's an interpreter!" "Where did you get it?"  "I wrote it!"  "With what?"  "Uhhh... Notepad?"
10:48:51 <Cale> Postscript is pretty cool though
10:49:01 <monochrom> ps is a nice and concise language for vector graphics. are your documents essentially vector graphics? If so, you'll benefit much from ps.
10:49:16 <Elly> svg!
10:49:17 <bwr> atp: lol
10:49:18 * Elly hides
10:49:40 <monochrom> my documents are linguistic text, not visual graphics.
10:49:46 <chrisdone> eh makes vector graphics and doesn't afraid of anything
10:49:51 <bwr> i kind of like xslt... /me hides
10:49:56 <bwr> atleast when working with xml
10:49:57 <monochrom> I like xslt too.
10:50:47 <Cale> My documents are sequences of carefully-positioned character outlines ;)
10:51:09 <monochrom> I now use xslt for the boilerplate of my http://www.vex.net/~trebla/haskell/hxt-arrow/
10:51:17 <EvilTerran> i like xslt in the context of working with xml
10:51:26 <EvilTerran> but i don't like that precondition much :P
10:51:30 <Cale> Everything to do with XML is suboptimal.
10:52:03 <monochrom> Cale: The problem with carefully-positioned character outline is that it isn't quite searchable.
10:52:29 <Cale> That's true
10:53:50 <SamB> so ... PDF are polyglotic?
10:54:15 <SamB> atp: do you have debug.exe?
10:58:51 <dons> http://www.reddit.com/info/6sjrd/comments/
10:58:53 <lambdabot> Title: reddit.com: Stemming with Haskell
10:59:07 <vixey> hi dons
10:59:26 <bwr> is that your article?
10:59:42 <bwr> if so what color scheme is that for the code?
11:04:18 <Peaker> Default method implementations are not allowed to return a type that is more specific than their signature?
11:04:45 <Igloo> No, because they have to be usable if you don't give an implementation
11:06:12 <Peaker> I think I need the method's signature to allow specific types. Something like: forall a. exists b. method :: (a -> b)
11:06:20 <Peaker> (without actually specifying b)
11:06:59 <Peaker> scratch that, I misunderstood my problem
11:08:36 <Peaker> I have a multi-type class (class Blah a b c) -- and I have a method in there that depends on the other methods and can be implemented for all instances where the c type is some known type -- how can I avoid reimplementing it each of those times?
11:08:38 <mikael__> how do I access the ! operator in Map, imported qualified?
11:08:41 <chrisdone> let's say I'm accepting a load of inputs and I want unique identifiers for all of them, could I use a checksum concatenated with the length of that input?
11:08:49 <chrisdone> mikael__: M.! ?
11:08:50 <Peaker> mikael__: Data.Map.!
11:09:11 <mikael__> that's a parse error
11:09:21 <vixey> chrisdone: A checksum is certainly not going to be unique
11:09:24 <Deewiant> ?ty (Prelude..)
11:09:25 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
11:09:26 <Peaker> chrisdone: that sounds like a hash, not a necessarily unique identifier
11:09:29 <chrisdone> import qualifed Data.Map as M; fii M.! bar
11:09:30 <vixey> mixael__:
11:09:39 <vixey> > "foo" P.++ "bar"
11:09:42 <lambdabot>  "foobar"
11:09:46 <mikael__> oh it's an infix operator, thanks
11:09:49 <chrisdone> ah ok
11:09:51 <Deewiant> operators all are
11:12:50 <zachk> does frag come with levels?
11:13:42 <Peaker> I have some friends who would really have an easier time approaching Haskell if class/instance  were called interface/implements
11:14:06 <SamB> but that would bring on too many Java flashbacks
11:14:26 <Peaker> heh - it is pretty well-established terminology everywhere else
11:14:43 <chrisdone> peaker: your friends can't handle new terminology? god help them with the rest of haskell
11:15:01 <Peaker> chrisdone: they can - but the little differences, that seem unnecessary, create antagonism
11:15:28 <chrisdone> that is a pity
11:17:54 <Deewiant> Peaker: just tell them to write {-# LANGUAGE CPP #-}\n#define interface class\n#define implements instance at the top of every file
11:18:03 <SamB> Peaker: what about the BIG differences?
11:18:21 <SamB> Deewiant: that doesn't work for reading or anything
11:18:33 <Peaker> SamB: one of my friends I am teaching some Haskell to loves the big differences and hates the small unnecessary ones
11:19:12 <chrisdone> peaker: I think ‚Äúunnecessary‚Äù is subjective in this case
11:19:20 <Zao> Deewiant: I bet that you're one of those people who would  #define BEGIN {  too.
11:19:25 <kpreid> sure, it's what you know already
11:19:45 <SamB> Peaker: well, call it an accident or whatever
11:19:54 <Cale> I think the language is sufficiently different that a little unfamiliarity of syntax is appropriate.
11:20:11 <kpreid> all would be better off if these differences didn't exist -- if these, yes, 'accidental' choices required no thought on the part of readers
11:20:13 <SamB> perhaps the problem is that "class" is used in OO also
11:20:38 <SamB> however personally I like that, because it gives us free names for related things ;-)
11:20:56 * SamB a lover of horrible puns
11:22:08 <Peaker> I was thinking of writing a two-way automatic Haskell "skin" - that lets you modify presentation aspects you don't like - like various function names, terminology like the above, etc
11:22:25 <Cale> I could complain that Java doesn't use 'data' for defining datatypes.
11:22:29 <Zao> DSLs can get you far.
11:22:29 <Peaker> then you can apply that convertor upon editor's load/save, or maybe upon compilation
11:22:49 <chrisdone> peaker: lisp without parentheses!!1
11:23:01 <Peaker> chrisdone: Dylan does have some popularity..
11:23:10 <chrisdone> peaker: python without forced indentation!
11:23:48 <Peaker> chrisdone: heh. I never got that part. Does anyone write unindented code?
11:24:05 * bitrot read that as "un-intended" code
11:24:06 <chrisdone> these kind of issues people ‚Äúsolve‚Äù seem pretty superficial and juvenile, imho
11:24:24 <Deewiant> Zao: the only such thing I've done is #define EVER (;;), and that phase didn't last long :-)
11:24:38 <Cale> Deewiant: I did the same without caps :)
11:24:50 <kpreid> chrisdone: I think if there really were *good tools* that did that sort of remapping, they would be put to better uses
11:24:51 <chrisdone> peaker: I've heard someone say ‚ÄúPython is good, but the syntax makes me not want to use it‚Äù
11:24:51 <Peaker> chrisdone: they are merely presentational issues and indeed less important, but still important.  I wonder if there is scientific data about human capacity to read infix vs prefix notation of complex expressions, for example
11:24:57 <Deewiant> Cale: I learned that macros should be all-caps ;-)
11:25:11 <Peaker> chrisdone: I think Python is bad, but the syntax is so great that I like to use it :-)
11:25:13 <kpreid> chrisdone: people would be able to experiment with notation for best *personal* readability etc. etc.
11:25:28 <Peaker> my favorite thing about Python is its syntax
11:25:33 <kpreid> chrisdone: one of the problems is nobody does comment-preserving ASTs and so on...
11:25:39 <zachk> Peaker: it is probably how we are "conditioned" since we are small, or it may have somethiing to do with linquistics
11:25:50 <Philippa> Peaker: is that a backhanded compliment though?
11:26:50 <chrisdone> kpreid: true, otherwise it could be re-arranged as suited, yes. provided everyone had their `otherpeople -> mine' converters, for their editors, patch viewers, IRC, mailing list, web browser, PDF viewer, they could all read code just how they liked
11:27:11 <kpreid> chrisdone: not 'otherpeople' but 'common-underlying-format'
11:27:16 <Peaker> Philippa: After a few years of using a great language, I take its positives for granted, and develop hatred of its negatives.. So now I think Python sucks, and am working to transition to Haskell :)
11:27:20 <chrisdone> kpreid: sure
11:28:07 <marcot> Toxaris: are you there?
11:28:21 <Toxaris> marcot: yes
11:28:46 * Toxaris is testing his tool to add type signatures to top-level definitions in haskell files
11:29:28 <marcot> Toxaris: I made that work, with your suggestion of changing buffer to something like (buffer, innerBuffer).
11:29:44 <marcot> Toxaris: I'd like to thank you in the changelog, can you give me your name/e-mail?
11:30:03 <chrisdone> kpreid: this is personally why I like Python and Haskell's indentation based syntax, because of the issues like ‚Äúhouse style‚Äù for indentation in other languages like C, Java, etc. it seems like a good solution until we have what you propose there
11:30:17 <Toxaris> marcot: *thinks* oh the monadic tunneling? cool!
11:30:36 <marcot> Toxaris: do you know about dons' typeof?
11:30:45 <Philippa> chrisdone: there're still different indentation styles in Haskell. I'm fairly sure mine's somewhat idiosyncratic, for example
11:31:09 <Toxaris> marcot: http://person.au.dk/rendel@daimi
11:31:12 <lambdabot> Title: AU: Tillmann Rendel
11:31:43 <Toxaris> marcot: no, I don't. what's it?
11:31:57 <chrisdone> philippa: well, I'm not saying there are no possibilities of variation. I'm sure you could always write "x   *   y" instead of "x*y", but I think the problem is more restricted in haskell
11:32:01 <marcot> Toxaris: ok, thanks... It's a tool to add type signatures to top-level definitions in haskell files. =P
11:32:11 <marcot> http://www.cse.unsw.edu.au/~dons/code/typeof/
11:32:13 <lambdabot> Title: Index of /~dons/code/typeof
11:32:13 <Peaker> Philippa: Haskell lets you place a newline in places that Python won't, and has optional indentation for some things (like the where clause of modules). I don't think there are many more differences
11:32:37 <Toxaris> marcot: oh nice to know I just spend the evening for nothing
11:32:39 <Peaker> does it also maintain existing type declarations?
11:33:39 <Toxaris> hehe it's approximately as ugly as my version :)
11:33:45 <Peaker> how do you run typeof?
11:33:57 <Toxaris> (i.e.: no real interaction with ghc, but just parsing strings)
11:34:24 <Toxaris> but my version parses the output of ghc -Wall which gives all the information you need, while dons' seems to call ghci specifically
11:34:45 <zachk> anyone know what the frag level is called?
11:34:50 <Peaker> oh-- I thought it could add type signatures to a file for -Wall! that would be useful
11:34:55 <marcot> Toxaris: maybe with HSH it could be prettier.
11:35:35 <marcot> Peaker: it used to have a README file in it...
11:35:41 <Toxaris> hmm, looking again at dons' code. that doesn't actually change my *.hs files, it's just an interface which returns the type, is it?
11:35:56 <marcot> Peaker: but it get's nice when integrated with emacs or vi.
11:35:57 <Peaker> Toxaris: seems to answer single @type lambda request
11:36:01 <Peaker> lambdabot requests, that is
11:36:16 <marcot> Toxaris: yes, it doesn't change a whole haskell file.
11:36:22 <marcot> That would be cool to have.
11:36:31 <Peaker> marcot: I really really want to write a non-syntactic Haskell editor, but I want to write it with FRP, and I don't know enough to use FRP yet :(
11:36:39 <Toxaris> my prog is intended to be run as   ghc -Wall --make Main.hs | makeTypePatch | patch
11:36:47 <chrisdone> last time I used -Wall it gave me odd errors. for example, `add1 = myadd 1; myadd = (+)' would say ‚Äúmyadd undeclared‚Äù or some such. I like to write my code top down, so this is a problem
11:37:20 <marcot> Peaker: what's a non-syntactic editor?
11:37:35 <Toxaris> well, so I will continue testing and release soon
11:38:27 <Peaker> marcot: syntax/presentation is disconnected from the semantic value you are editing. So you can configure the way things are viewed on-the-fly, and implement nice editing features more easily (without need for parsing/pretty-printing code)
11:38:58 <zachk> where do i get a level for frag? quake3???
11:39:17 <Peaker> marcot: "names" that currently serve both as comments and as the way to create links between entities become only comments - which can be changed easily to add clarity without breaking the program
11:39:32 <zachk> oh it does come with one tucked neatly out of the way
11:39:46 <marcot> Peaker: this seems to be a nice concept.  Do you have an example?
11:39:50 <Peaker> zachk: the level the comes with frag seems to have nothing interesting in it - there are no monsters or anything..
11:39:57 <chrisdone> peaker: what happens when you want to read an existing codebase which is normal haskell syntax?
11:40:10 <Peaker> marcot: I have created a Python prototype editor for C, and Jonathan Edwards created a nice editor for his own language (www.subtextual.org)
11:40:17 <zachk> im just dying to move around with a mouse and keyboard again
11:40:23 <Peaker> chrisdone: I think I'll "import" it to whatever backend format I'll be using
11:40:49 <chrisdone> peaker: and there will be an export?
11:40:57 <Peaker> marcot: actually my prototype is not yet an editor, its very very initial/limited (and abandoned as I realized I want to both edit Haskell and write the editor in Haskell)
11:41:25 <Peaker> chrisdone: probably - but the new features made possible by the non-textual storage format will not be exportable simply because text cannot easily encode them
11:41:38 <marcot> nice, I'll take a look.
11:42:01 <chrisdone> peaker: ‚Äúnew features‚Äù?
11:42:38 <zachk> frag isnt that bad
11:42:42 <Peaker> chrisdone: for example, you can associate optimization hints with pieces of code (that don't have to be in your face while you're editing), naming schemes/translations (each object in the program can have multiple names, for various "name schemes", to support translations, etc)
11:42:53 <zachk> not much too it but not bad at all
11:43:06 <Peaker> chrisdone: with a textual encoding, you can't view a subset of the code that currently interests you (for example, don't show me optimization hints now)
11:43:23 <Peaker> chrisdone: also, multi-dimensional decision tables as presented in the Subtext 2 demo will be hard to encode as text
11:44:06 <Peaker> chrisdone: so if you encode it back to text, you might have a lot of {- yucky -} comments in your face with lots of the extra information
11:44:26 <chrisdone> peaker: I'm not sure I understand what you mean by viewing a subset of the code. with textual encoding, it's possible to access specific functions, do you mean specific components of expressions?
11:45:34 <Peaker> chrisdone: the latter, yeah. Consider the optimization hints as an example. Currently Haskell has them in the form of "strictness" qualifiers. There are many more possible such hints. When encoded in the syntax, there's a tradeoff between clutter and the amount of hinting
11:46:08 <Peaker> chrisdone: if the editor can show/hide these things easily as a presentation feature, then the tradeoff moves, and you can add more interesting information to the code
11:46:23 <Peaker> chrisdone: that information will be quite cluttered when translated back to text
11:46:48 <zachk> ok i can use cabal to install a 3d first person shooter using opengl on windows, but i cant get it install a mud client cause of gnu readline
11:47:05 <Peaker> zachk: haha :)
11:47:28 <chrisdone> peaker: it seems to me that with a sufficiently clever editor you could do something like that with textual encoding
11:47:29 <zachk> i want to kick RMS in his nut's if he hasnt already cut them off and donated them to the FSF
11:47:30 <Toxaris> wasn't there something on -cafe about an Haskell readline?
11:47:46 <zachk> i just want some yogurt :-(
11:48:05 <rey_> doesn't bsd have "editline" or something like that?
11:48:39 <zachk> ok so ghc uses Gnu multiprecision, does it use Gnu readline, or anything else Gnu?
11:48:42 <Peaker> chrisdone: yes, but its very very difficult. The editor would probably not want to expose you to editing the structure of that extra information, cause you could easily mess it up. In that case the editor will serialize/deserialize from text, but actually let you edit something else. I think the natural progression of that -- is to not limit the serialization backend to syntax/text
11:49:22 <Peaker> chrisdone: already we are not really editing the direct text of the program - take it a few steps forward, and there is no reason to tie the format the code is stored on disk at - and the way its presented
11:50:57 <Peaker> chrisdone: The current architecture of editors still exposes the [Char] underneath - which means each of the editing features/plugins has to go through hell parsing/building the substrings, and dealing with intermediate incorrect programs, etc
11:51:05 <Toxaris> which language extension enables explicit forall?
11:51:53 <vixey> several including -XRankNTypes
11:52:09 <Toxaris> or can I make ghc -Wall output type signatures without explicit forall
11:53:01 <chrisdone> peaker: I can see it being a problem when editing someone else's code because you propose it imports it rather than edits it, so the formatting would be changed. it would be fine if everybody used this kind of thing, but I can't see that happening. writing down bits of code on IRC or on paper or whatnot and you revert back to text
11:53:25 <Peaker> chrisdone: Unless you also replace IRC/etc :-)
11:53:58 <vixey> It's about time to do that
11:54:00 <chrisdone> peaker: well that doesn't sound very realistic
11:54:15 <gregwebs> I am trying to write a chess pairing algorithm and need to use graphs.  Does anyone have recommendations as to which Haskell library to use, or pointers to some examples.
11:54:51 <Peaker> chrisdone: also, if it is really much much better - then the "import only" quality will at worst put these projects in a "ghetto" -- and when there's enough code in there, people will start importing/forking code that's outside the ghetto until it outgrows the rest of the code
11:55:03 <Cale> gregwebs: Well, how sophisticated are you going to get with the graphs? I've found that a Data.Map from vertices to adjacency lists/sets is often quite a handy representation.
11:55:05 <zachk> gregwebs: what are you trying to pair up?
11:55:30 <Peaker> chrisdone: I mean, a new programming language is even worse - you cannot import anything! and yet new languages that are good succeed
11:55:40 <Cale> gregwebs: But there are libraries with specialised graph structures and algorithms.
11:55:59 <Peaker> chrisdone: this is in a sense a new programming language
11:56:54 <chrisdone> peaker: yeah, if every program you used to write/talk about code in supported a little pop-up AST editor/displayer, then I could see it working. convincing other people to use it, I have doubts
11:57:05 <Peaker> what can one do with a TypeRep value?
11:57:09 <Toxaris> :(
11:57:30 <Peaker> chrisdone: I think the many advantages it could offer will win out many many people
11:57:31 <Toxaris> my add-typesig-tool works now, *BUT* ghc doesn't actually output syntactic correct type signatures
11:57:47 <Peaker> chrisdone: with or without the ability to easily move traditional code in/out of it
11:57:56 <pozic> Toxaris: what do you mean? Something like that should already be in ghc?
11:57:58 <Cale> Peaker: see Data.Typeable's documentation. At the very least, you can compare them for equality, which is the most common use, I suspect.
11:57:59 <gregwebs> I am trying to pair players like a roomates pairing algorithm, but using the pareto optimality- It will require finding graph blocks and an alternating cycle
11:58:00 <chrisdone> peaker: I think some ‚Äúscreencasts‚Äù of you using something like this in your day to day coding would be interesting
11:58:10 <Cale> (along with very hackish casting operators)
11:58:23 <Peaker> chrisdone: Excel is the "most popular functional programming language" -- and it sucks. The only thing going for it is that it is "live".  This could be a live programming language too
11:58:31 <vixey> any guess regarding the chances of something becoming popular has the possibilty of being completely wrong
11:58:37 <gregwebs> I am pairing chess players against each other
11:58:51 <Toxaris> pozic: I have written a script which parses the output of ghc -Wall for "Definition but no type signature for ..." and inserts the suggested type signature into the .hs file
11:58:52 <vixey> p.
11:59:04 <chrisdone> vixey: I think the meaning of ‚Äúguess‚Äù presupposes that one might be completely wrong
11:59:10 <Toxaris> pozic: which works fine *except* that the suggested type signature is not always correct
11:59:15 <Peaker> Cale: thanks. What returns a TypeRep value for a given value?
11:59:18 <pozic> Toxaris: why not just insert all type signatures?
11:59:24 <Toxaris> pozic: i.e. the parentheses for operators are missing
11:59:27 <Toxaris> pozic: how?
11:59:37 <Cale> Peaker: typeOf
11:59:40 <pozic> Toxaris: I don't know by heart, but there is an option to do so.
11:59:50 <Peaker> chrisdone: There are screencasts of Jonathan Edwards using Subtext - I find them very nice :)
11:59:51 <zachk> how is excel functional, it has mutable state :(
11:59:55 <marcot> Peaker: I've seen the video about subtextual.. very nice.
12:00:00 <Toxaris> pozic: option to ghc?
12:00:04 <pozic> Toxaris: yes
12:00:15 <marcot> Peaker: I'd like to see that in haskell.. are you doing a free software?
12:00:17 <Toxaris> pozic: I was not aware that there ghc changes the input files in any situation
12:00:23 <Toxaris> pozic: are you sure?
12:00:24 <Peaker> zachk: The program you edit in Excel is mutable, much like an .hs file, but the program expressed in it has no mutable state
12:00:29 <chrisdone> peaker: I've seen them, but he doesn't do anything interesting or compelling
12:00:41 <pozic> Toxaris: it doesn't change the input files, but it can list all the types.
12:00:45 <Peaker> marcot: Yes, but my problem is lack of Haskell expertise (and a full time job) means very very slow progress..
12:00:52 <mdmkolbe> @hoogle Int -> Double
12:00:53 <lambdabot> No matches, try a more general search
12:01:08 <chrisdone> peaker: if he, say, wrote a game or a web server or something less trivial, it would be more interesting
12:01:20 <Toxaris> pozic: well, (1) I clearly want to insert only these that are missing and (2) are the listed types syntactically correct?
12:01:29 <Peaker> chrisdone: I think the Melee attack stuff is pretty compelling, and his "hypothetical futures" I think is a great visualization of the IO monad
12:01:53 <Peaker> chrisdone: well, when developing something completely new, you have to cover basics before you get to the advanced stuff
12:02:09 <Peaker> chrisdone: I think he doesn't realize that he reinvented a lot of the FP wheels
12:02:55 <Peaker> chrisdone: he says "Monads are a reductio ad absurdum" ("Programmers dont undertsand them") -- and then goes about to invent the IO monad and call it an "Action" in Subtext 1 :)
12:02:58 <johnnowak> reinventing is a good way of understanding your problem
12:03:01 <chrisdone> I'm saying his videos seem like the equivalent of showing factorial in Haskell. it's different to $MYLANGUAGE but so what?
12:03:17 <roconnor> who are we talking about?
12:03:34 <chrisdone> www.subtextual.org
12:03:37 <marcot> Peaker: do you have a darcs repository?
12:03:44 <Peaker> chrisdone: you also see it running as you edit it. You see some kinds of unit tests are extremely easy to create and add.  You see debugging is easier. You see laziness in action.  With some imagination, I can see many more features becoming possible
12:03:53 <vixey> jonathon edwards, hop skip jumper
12:04:04 <Peaker> marcot: I don't have anything to show for in Haskell, only some Python work (which I abandoned as I think it should be done in Haskell)
12:04:07 <chrisdone> vixey: what does that mean?
12:04:09 <zachk> yay flash
12:04:23 <zachk> Peaker: learning haskell isnt much faster with no job either
12:04:25 <marcot> hum... Hope it gets done..
12:05:12 <chrisdone> zachk: lies :P
12:05:46 <vixey> chrisdone: http://www.olympics.org.uk/images/athlete/Edwards_Jonathan_Action_1.jpg
12:05:48 <lambdabot> http://tinyurl.com/58dzhl
12:06:14 <chrisdone> oh
12:07:00 <johnnowak> i think the subtext work with automatic dataflow layout is a nice improvement on his initial steps
12:07:16 <johnnowak> although i'm rather partial to dataflow representations
12:07:41 <Peaker> johnnowak: one of the beautiful aspects is that you don't need a "one size fits all syntax" -- you can switch between a 2d table and another representation easily
12:08:28 <Peaker> johnnowak: two different people can edit the same code with two different representations, if they prefer
12:09:16 <johnnowak> aye. that said, i think having a single (possibly textual) representation that is manipulated, and then having that visualized in many ways (optionally hiding irrelevant details or viewing things on different levels), is probably a better solution
12:09:23 <Peaker> hey, I knew people who did not like my style of dividing everything into really tiny functions that call each other.  They liked inlining everything that could be inlined without duplication. With this kind of editor - we can both have our cakes
12:09:38 <chrisdone> johnnowak: that is what I suspect
12:10:07 <Peaker> johnnowak, chrisdone: surely there is one "backend" representation that you're editing. I don't think that should be text, as text is a limited serialization format (and the data is not serial)
12:10:56 <johnnowak> Peaker: subtext isn't your work, is it?
12:11:09 <Peaker> johnnowak: heh, I wish :-)  Its Jonathan Edwards'
12:11:16 <johnnowak> ah.
12:11:26 <Peaker> I am merely inspired by him, and believe his ideas can be taken even further
12:11:28 * roconnor watches the subtext video
12:11:56 <roconnor> reminds me of epigram so far
12:12:07 <chrisdone> peaker: (I think that should be ‚ÄúEdwards's‚Äù, the ‚Äòs' is ommited for plurals)
12:12:10 <roconnor> by-with nodes
12:12:23 <Peaker> I also think his clickety-clickety UI's make a bad name for the whole deal. Programmers who watch that think "I could have written it faster in my text editor". Its easily possible to have such a smart editor require fewer key strokes for any programming task
12:12:34 <Peaker> chrisdone: you're probably right
12:12:46 <johnnowak> automatic layout is essential
12:12:58 <johnnowak> provided it is done in real-time of course
12:13:43 <chrisdone> peaker: well, I agree there is an underlining syntax. I'm saying text is ubiquitous, so it's more realistic as a candidate for adoption, imho. but I am interested in work you might do in this
12:14:12 <vixey> Peaker: Have you used paredit?
12:14:27 <johnnowak> my thinking is similar. to get a system accepted, a textual representation helps. even if the visuals can be directly edited, you need to be able to output (readable) text.
12:14:29 <chrisdone> peaker: sure, I can see myself using key combinations manipulating graphical things just like in emacs
12:14:36 <Peaker> Does this signature make sense: (Data.Map TypeRep (b -> c)) -> a -> c  ? (I want it to use the proper function for the given type)
12:14:53 <pozic> TeXMacs has basically implemented what you are talking about.
12:14:54 <Peaker> vixey: nope, what's that?
12:15:12 <Peaker> johnnowak: you could use XML or so for the backend format (Yuck, but "human readable")
12:15:15 <vixey> Peaker: An emacs mode, you might be able to steal ideas from it
12:15:16 <pozic> It just needs a year of work to adopt it to $PROGRAMMINGLANGUAGE.
12:15:30 <Peaker> vixey: ah, cool. What does it do?
12:15:30 <johnnowak> i'm just beginning work on a system now that translates function-level programs to graphical dataflow-style representations. the idea is to make the pointfree programming style much easier, at least for beginners.
12:15:56 <johnnowak> Peaker: if you used s-expressions, it might even be human-editable :)
12:15:57 <chrisdone> peaker: it's a mode that's aware of parentheses, great for editing lisp because it balances and manipulations s-expressions for you in few key strokes
12:15:59 <Peaker> johnnowak: sounds neat! how do you represent the graphical representation?
12:16:37 <roconnor> this subtext video really reminds me of epigram
12:16:47 <chrisdone> peaker: http://mumble.net/~campbell/emacs/paredit.html
12:16:54 <johnnowak> Peaker: i don't have a good example handy. however, it would be something like the version on the right (albeit with most of that information hidden): http://johnnowak.com/heap/stackless-dataflow.png
12:17:11 <Peaker> johnnowak: sexp's will too be cluttered with weird information if used. For example, once links between nodes in the program's graph are not done by names, but by UUID's or such, it won't be very readable. (each UUID has comments associated with it, so you can present them in place of a "name". This allows easy renaming/etc that even survive source control mergers)
12:17:20 <johnnowak> the idea would be to use color or lines to show the "flow" of values through pointfree code, and to show the incremental typing of the function
12:18:06 <Peaker> johnnowak: what do you think of arrow-do notation for points-free style?
12:18:19 <johnnowak> Peaker: it depends on your language. you can form a graph without explicitly encoding connections. take that example I just posted... the program is just 'swap dup dip[call] swap' (which is an absolutely useless program, but regardless)
12:18:39 <johnnowak> first order concatenative languages map directly to a dataflow representation
12:18:43 <Peaker> johnnowak: what's dup?
12:19:00 <johnnowak> Peaker: a "fork" of sorts...  5 dup +  ==  10
12:19:36 <Peaker> johnnowak: ah. Yeah, you can represent a graph this way -- but it loses interesting information, I think. If you @pl a Haskell program to store it, you cannot later get it back :)
12:19:37 <chrisdone> johnnowak: hm, I have quite a visual notion of function composition. in `(foo .) . bar' I sort of imagine an arrow that goes into a tube, bar, and then that tube goes inside foo which creates a new tube taking something else. I'd be interested to see how you represent them
12:19:37 <johnnowak> the name is taken from forth -- it may not be the best when dealing with such a representation. ideally, you'd not even show 'dup' at lal.
12:20:11 <johnnowak> Peaker: pointfree in this language is much less painful than it is in haskell... you don't need to get it back later. :)
12:20:57 <johnnowak> @pl \x y z -> succ (x * x + 2 * x)
12:20:57 <lambdabot> const . const . succ . ap ((+) . join (*)) (2 *)
12:21:02 <chrisdone> > join (+) 5
12:21:03 <lambdabot>  10
12:21:03 <johnnowak> that would just be 'bi[sqr, 2 *] + succ'
12:21:16 <johnnowak> where 'bi' is a way of doing two things to one value.
12:21:33 <johnnowak> so you can see... not nearly so bad as the haskell version (which is unusable)
12:21:41 <Peaker> I think whenever @pl uses the reader monad, I need like 5 minutes to figure out what's going on :-)
12:22:06 <johnnowak> chrisdone: i'm not convinced it'll be useful yet. we'll see.
12:22:46 <Peaker> johnnowak: that's cool.. can it be encoded via (&&&) and (***) instead of the above @pl in Haskell?
12:22:57 <pozic> johnnowak: the challenge is to convince text-trained persons to use whatever you are making.
12:23:00 <johnnowak> it just causes me pain when people see the pointfree version of a function in haskell and assume it's *pointfree programming* itself to blame, not haskell
12:23:30 <pozic> johnnowak: in other words: you should bring a lot of tool-support to the table.
12:24:04 <pozic> johnnowak: it's fairly practical to compete with the "tools" in for example Haskell. There aren't any good tools.
12:24:07 <johnnowak> pozic: the language is designed to be useful without the visualization. it would be a shame if it weren't. if they don't want to use it, that's certainly fine. but yes... the tools will have to be very good if anyone is to consider using them for real work (rather than just pedagogical purposes)
12:24:37 <johnnowak> Peaker: possibly, but I'd be the wrong person to ask
12:25:00 <chrisdone> > let sqr = join (*) in sqr &&& (*2) >>> uncurry (+) $ 10
12:25:02 <lambdabot>  120
12:25:35 <Peaker> johnnowak: what about the "z" argument in the example you brought above?
12:25:36 <johnnowak> a bit rough still.
12:25:56 <Peaker> johnnowak: shouldn't you have a const piped in after all those?
12:26:01 <johnnowak> the trouble with pointfree programming in haskell is that you can't return multiple values and use them easily
12:26:13 <johnnowak> Peaker: sorry -- which example?
12:26:30 <chrisdone> johnnowak: arrows is a nice good in the right direction, imo
12:26:33 <pozic> johnnowak: will it also have a return stack?
12:26:38 <Peaker> johnnowak:  bi[sqr, 2 *] + succ   doesn't seem to take the "z" into account (it was  \x y z -> succ (x * x + 2 * x)  )
12:26:40 <chrisdone> johnnowak: uh, nice step
12:27:05 <pozic> johnnowak: and are you going to skip a float stack? ^^
12:27:07 <johnnowak> Peaker: ... i have no idea why I wrote 'y' an 'z'. ignore that. :)
12:27:19 <johnnowak> @pl \x -> succ (x * x + 2 * x)
12:27:19 <lambdabot> succ . ap ((+) . join (*)) (2 *)
12:27:23 <Peaker> johnnowak: that's why const . const . were added to the Haskell pl :-)
12:27:45 <Peaker> I hate @pl's with the reader monad. Unreadable :)
12:27:50 <johnnowak> Peaker: ah. well, if you /did/ have have y and z, it's just this: 'drop2 bi[sqr, 2*] + succ'
12:27:53 <Toxaris> @pl \x -> succ (x ^ 2 + 2 * x)
12:27:54 <lambdabot> succ . liftM2 (+) (^ 2) (2 *)
12:28:02 <Toxaris> thats the fair comparision
12:28:44 <Peaker> I think @pl should have used something like "dup" instead of the reader monad
12:28:46 <johnnowak> Toxaris: that would be '2 bi[^, *] + succ'
12:28:51 <Kyslik> ahoj
12:29:23 <Toxaris> johnnowak: I mean, it's unfair to use sqr in your code, but 2 * 2 in the Haskell code
12:29:38 <Toxaris> @let sqr = (2 ^)
12:29:40 <lambdabot> Defined.
12:29:50 <Toxaris> @pl \x -> succ (sqr x + 2 * x)
12:29:51 <lambdabot> succ . liftM2 (+) sqr (2 *)
12:29:53 <johnnowak> ah, right. fair enough.
12:30:05 <Toxaris> hmm no need to @let it :)
12:30:32 <johnnowak> pozic: no user-accessible return stack, no
12:31:01 <Toxaris> johnnowak: but "factoring out" the 2 is quite cool of course
12:31:03 <johnnowak> the similarity to forth is rather superficial
12:31:46 <johnnowak> Toxaris: aye. 'bi' has the type 'a b bi[a b -> c, a b -> d] -> c b' ... you might have to squint to see how that makes sense if you had a stack.
12:31:58 <johnnowak> sorry, '-> c d'
12:33:49 <johnnowak> pozic: and yes, there will be floating point. :)
12:33:54 <Toxaris> I have more issues with the types ghc outputs. The are fully qualified to their definition modules, but I want the identifiers to be usable in the current module
12:34:09 <Toxaris> is this handled by other tools e.g. dons' typeof?
12:34:36 <pozic> johnnowak: I was talking about a separate stack. Something that was "new" for me. Although, it makes sense if you want to program close to the hardware.
12:34:47 <Peaker> How can I define a Data.Map that maps functions of _differing_ input types to the same type.  e.g:  Data.Map TypeRep (exists a. a->b)
12:35:04 <pozic> johnnowak: programming languages should model generic hardware devices.
12:35:05 <Peaker> (where the TypeRep value actually describes "a")
12:35:27 <Peaker> pozic: why?
12:35:40 <pozic> Peaker: because everything else can be build on top of that.
12:36:06 <johnnowak> pozic: sure. no, just a single stack. there are, however, polymorphic typed "channels" that allow modules to pass data to each other. if you put a stack (stacks are first class) onto such a channel, you'd have an additional stack.
12:36:07 <Toxaris> Peaker: I guess you need data FunctionTo b = forall a . FunctionTo (a -> b)
12:36:13 <Peaker> pozic: but it sounds like you said  forall programmingLanguage. shouldModelHardware programmingLanguage
12:36:15 <Cale> Programming languages should be as close as possible to the mathematical semantics you use to reason about them.
12:36:22 <Toxaris> Peaker: and then you can use Data.Map.Map TypeRep (FunctionTo b)
12:36:37 <Peaker> Toxaris: But my functions are not that polymorphic
12:36:38 <Cale> Who gives a damn about physical hardware? ;)
12:36:42 <Peaker> Toxaris: they are just from specific types
12:37:10 <RayNbow> bos31337, http://www.reddit.com/r/programming/info/6sjeq/comments/ <-- nice find :)
12:37:10 <lambdabot> Title: programming: Near-optimal Character Animation with Continuous Control
12:37:19 <Peaker> Toxaris: for example, I have (Int -> Bool), and (Char -> Bool), and I have a value of type "a", which might be Int or Char, and I want to map it through the right function
12:37:21 <Toxaris> Peaker: note that the forall in FunctionTo's definition is a hidden exists, because it occurs in a contravariant position
12:37:26 <Peaker> Toxaris: I have the TypeRep each function can handle
12:37:43 <Peaker> Toxaris: what's a contravariant?
12:37:56 <pozic> Peaker: 1) A programming language should have a semanitics 2) The programming language should be usable to write efficient programs 3) What Cale said.
12:37:57 <Toxaris> Peaker: positions where forall change into exists
12:38:00 <Toxaris> Peaker: :)
12:38:01 <pozic> semantics*
12:38:05 <quicksilver> Peaker: you want Data.Map TypeRep Dynamic
12:38:15 <quicksilver> Peaker: where you know that the dynamic is the right type.
12:38:21 <Peaker> Toxaris: that actually clears up some previous confusions I had. Thanks :)
12:38:30 <quicksilver> then you can safely cast it.
12:38:32 <johnnowak> a programming language, though, should make it easy for the program to reason about how the code will be executed (on a level that's sufficient for the problem at hand)
12:38:36 <Peaker> quicksilver: Is "Dynamic" a type constructor?
12:38:39 <johnnowak> easier for the programmer, rather
12:38:40 <quicksilver> Peaker: it's a type.
12:38:59 <pozic> johnnowak: Dijkstra's calculus only has 5 rules.
12:39:00 <quicksilver> Peaker: it is in fact an existential which can hold any type, and you cast it back to the type you want
12:39:03 <quicksilver> it's type-safe
12:39:09 <quicksilver> if you get it wrong, you get "Nothing" out.
12:39:12 <quicksilver> :t cast
12:39:12 <lambdabot> forall a b. (Typeable b, Typeable a) => a -> Maybe b
12:39:16 <quicksilver> hmm
12:39:18 <quicksilver> :t fromDynamic
12:39:19 <lambdabot> forall a. (Typeable a) => Dynamic -> Maybe a
12:39:22 <quicksilver> that's what I meant :)
12:39:31 <pozic> johnnowak: you don't get it much more simple then that. No?
12:39:34 <Peaker> quicksilver: ah, thanks
12:39:53 <Peaker> quicksilver: will it also work to use existentials as above?
12:39:56 <pozic> than*
12:40:28 <jcreigh> Is there some function in parsec like notChar c = satisfy (/=c)?
12:40:30 <Cale> Peaker: There is no exists in GHC.
12:40:48 <Toxaris> Peaker: sorry, I cannot really explain variance :) The general idea is that you use variables in a structure, and you know something about the variables, and depending on where the variable is, your knowledge "flips around" to the exact opposite.
12:40:54 <Peaker> quicksilver, Cale: as Toxaris mentioned above: data FunctionTo a = forall a . FunctionTo (a -> b)
12:41:16 <mjrosenb> is there any easy way to overwrite the default Show instantiation for a prelude defined type?
12:41:26 <Peaker> mjrosenb: other than a newtype?
12:41:32 <Cale> Peaker: ah, yeah. That will work if you use an explicit unsafe cast.
12:41:44 <Peaker> Cale: unsafe as in - perhaps a Nothing?
12:41:50 <Toxaris> Peaker: so for example, (forall a . a) -> b corresponds to exists a . (a -> b) because the left site of -> is contravariant
12:41:52 <SamB> mjrosenb: dopends on what you call easy ;-)
12:41:53 <dons> mjrosenb: use a newtype
12:41:56 <Cale> Peaker: unsafe as in perhaps a crash :)
12:42:10 <ph00ng> Hello. I am trying do write some haskell code, and need to get random integers. I have searched the web for over an hour but I can't find a way to generate a random int with the type Integer only. Can this really be so hard?
12:42:11 <Peaker> Cale: heh, doesn't cast return Nothing instead of crashing? :)
12:42:15 <mjrosenb> Peaker: yeah.  i'm dealing with large amounts of Bools, so i'd like them to be displayed as 1 and 0 rather than True and False
12:42:21 <SamB> mjrosenb: I think most of them involve a hex editor
12:42:25 <Toxaris> Peaker: but if you really care, here should be people who can explain this :)
12:42:28 <vixey> ph00ng: it's not hard
12:42:30 <dons> mjrosenb: introduce a new Bit type?
12:42:44 <ph00ng> vixey: could you show me an example?
12:42:45 <dons> data Bit = O | I
12:42:46 <Cale> That's the safe cast. I don't think that will work here.
12:42:57 <mjrosenb> dons:  this was mostly a hack because my eyes are getting tired
12:43:02 <Peaker> Toxaris: I think I understand
12:43:06 <vixey> ph00ng: Do you understand monads?
12:43:07 <dons> its a type-rich language, so use the types :)
12:43:13 <ph00ng> vixey: no
12:43:26 <mjrosenb> dons: if i were to rewrite all of that code, then i'd have to wait unitl i was no longer tired
12:43:27 <Cale> That FunctionTo type is kind of useless without low-level hackery.
12:43:51 <vixey> ph00ng: The first thing I guess, that you should do is get an understanding of what is happening in monadic code
12:44:13 <Cale> Peaker: because there's no way to know statically, if I have a value of type (FunctionTo t), whether it can be applied to a given value.
12:45:01 <Peaker> Cale: but I'm using a dynamic "cast", not statically?
12:45:10 <ph00ng> vixey: Then it'll have to wait until the next time I get some spare time for programming.. isn't there a function that just returns a random integer?
12:46:18 <Toxaris> ph00ng: no, because functions in Haskell return the same thing everytime they are called, and that's not what you want with randoms
12:46:23 <Peaker> ph00ng: functions in Haskell return the exact same thing every time they're called. But you can return something that represents a "give me a random number" operation that you can put together with other operations that are then allowed to use that random number
12:46:23 <xif> OK, let's see if I understood the following expression: [ x | (n,y) <- zip [1..] xs , x <- take n (repeat y)]
12:46:38 <Cale> Peaker: well, Data.Dynamic solves your problem reasonably well...
12:46:43 <vixey> take n (repeat y) = replicate n y
12:46:57 <xif> right
12:47:17 <roconnor> @src replicate
12:47:18 <lambdabot> replicate n x = take n (repeat x)
12:47:25 <xif> hehe, awesome.
12:47:35 <Peaker> Cale: I'm not sure I understand the difference between cast and fromDynamic
12:47:38 <vixey> oops, I mixed the x's and y's up
12:48:14 <roconnor> vixey: I don't think you did
12:48:20 <xif> me neither.
12:48:26 <vixey> Peaker: hey, why are you using cast? (I've never had an occasion to)
12:48:40 <Cale> Peaker: cast gives Nothing if the two type parameters in its type give different TypeReps.
12:49:05 <vixey> dynamic sounds like JMeq
12:49:16 <Cale> Peaker: So it only gives you a non-Nothing value if the two things have the same static type.
12:49:21 <ph00ng> Toxaris, Peaker: What do you mean? If I write a function and then pass different arguments to it, it does return different values right?
12:49:38 <xif> OK, this is a list of all X's, where (n,y) is assigned zip(N, xs), and then y is replicated n times.
12:49:38 <Toxaris> ph00ng: You can do something like   main = do {rands <- getStdRandom (randomRs (0, 10)); return (yourFunctionHere rands)} as a main program to create an infinite lists of random numbers between 0 and 10, and then apply a function to it
12:49:44 <vixey> ph00ing:  randomNumber :: Integer
12:49:48 <vixey> ph00ing:  randomNumber = 7
12:49:50 <xif> think I got it, it's pretty awesome.
12:49:52 <Toxaris> ph00ng: yes thats true, but if you apply it to the same argument twice, you get the same result back
12:50:05 <Cale> Peaker: When you apply the FunctionTo constructor to a function, you forget the type of the parameter which it accepts.
12:50:06 <xif> like Python's itertools on ultra-steroids.
12:50:08 <Peaker> Cale: once the static type was lost (into an existential type) you cannot get it back via "cast" again, then?
12:50:13 <Cale> Right.
12:50:19 <Peaker> Cale: yeah, but you can still remember its a "Typeable"
12:50:19 <Cale> You can never get it back.
12:50:30 <Peaker> Cale: so you can get the TypeRep still
12:50:41 <Toxaris> @type randomR
12:50:42 <lambdabot> forall a g. (RandomGen g, Random a) => (a, a) -> g -> (a, g)
12:50:55 <Cale> You can use Typeable to justify using a low-level hack like unsafeCoerce
12:51:02 <Peaker> Toxaris: exists a. (a -> b)  means that there's just some unknown type for which this function exists, right? how is that equivalent to (forall a. a->b) where there are infinite types for which the function exists?
12:51:04 <vixey> I don't understand the point of this dynamic stuff, I mostly use haskell like a dynamic language anyway.. it just notices more mistakes I make
12:51:10 <Cale> You can get the TypeRep *before* you throw away the type.
12:51:34 <Toxaris> Peaker: hmm maybe I told you nonsense
12:52:04 <ph00ng> vixey, Toxaris, Peaker: thanks for your time, seems like I've got some reading to do...
12:52:04 <Cale> Peaker: There are not many things of type (forall a. a)
12:52:07 <Toxaris> Peaker: no I didnt
12:52:12 <pozic> vixey: Most dynamic stuff is not easy in Haskell and that's why nobody uses it.
12:52:26 <Cale> exists a. a -> b  is the same as (forall a. a) -> b
12:52:32 <vixey> on that note, are there articles about using types to ensure/assert code is correct?
12:52:35 <Toxaris> Peaker: If you have a function of type (exists a. (a -> b)), you cannot do anything with it, because you don't know what type it wants
12:52:52 <Cale> You can apply it to undefined
12:52:57 <Cale> And that's it.
12:53:05 <Toxaris> Peaker: If you have a function of type (forall a. a) -> b, you cannot do anything with it, because you cannot create (forall a. a)
12:53:11 <Cale> Which is the same thing you can do with a function of type (forall a. a) -> b
12:53:13 <Cale> :t undefined
12:53:14 <lambdabot> forall a. a
12:53:17 <Toxaris> Cale: :)
12:53:19 <vixey> pozic: to be honest I just completely ignore the type system, it's never got in the way but it has noticed silly errors in code
12:53:23 <Cale> There's exactly one value of type (forall a. a)
12:53:26 <Peaker> Toxaris: Aha
12:54:29 <Cale> For example...  suppose we have  f :: FunctionTo Integer; f = FunctionTo (const 5)
12:54:47 <Cale> Then we can  case f of FunctionTo f' -> f' undefined
12:54:51 <Cale> and that'll be 5
12:55:00 <Cale> But that's all we can do with the extracted function.
12:56:35 <Peaker> TypeRep isn't Ord so cannot be a map key :(
12:56:46 <Cale> There's that too.
12:57:15 <Peaker> So I can't have type-specific code for an "extensible" type world
12:57:18 <Cale> In order for existential types to be really useful, it's best to put more than one function involving the existential type in a bundle representing the abstract interface of things you can do with the value.
12:57:38 <Cale> For instance, we can have something like...
12:58:30 <Cale> data Counter = forall a. Ctr { inc :: a -> a, display :: a -> IO () }
12:58:47 <Cale> or...
12:58:53 <Cale> data Counter = forall a. Ctr { inc' :: a -> a, display' :: a -> IO () }
12:59:42 <Cale> and then write functions inc and display which act on Counter values by applying the appropriate functions :)
13:00:05 <Peaker> those record names are already those functions?
13:00:11 <kpreid> Cale: that's essentially the same as a typeclass dictionary, right?
13:00:17 <Cale> kpreid: yeah
13:00:48 <Cale> A nice thing is that you can then, say, store a bunch of Counter values in a list, for different types 'a'
13:00:49 <EvilTerran> Peaker, i think he means as in "inc :: Counter -> Counter; inc (Ctr x) = Ctr (inc' x)"
13:00:51 <Peaker> vixey: about your question: I am trying to describe object differentials (Delta values).  I want for example, to have array deltas like: Set (simple set the entire array), Permute and Sort (Permute is a special case of Set, and Sort is a special case of Permute). I want code to be able to have optimized handlers that have smarter code running for Permute than Set, and smarter code still for Sort than Permute
13:01:02 <Peaker> EvilTerran: oh
13:01:19 <EvilTerran> and display (Ctr x) = display' x
13:01:32 <Cale> oh, it's a little nicer to have a 'this' field
13:01:51 <vixey> Peaker: oh it sounds exactly like the kind of thing you might use a typeclass for, is that not possible in this case?
13:02:03 <Peaker> For example, if I have a smart "sum" function that can take in such array deltas and produce Int deltas on the sum - it would know that Permute (and thus, Sort too) does not change the sum at all, and not produce any delta
13:02:10 <Cale> data Counter = forall a. Ctr { this :: a, inc :: a -> a, display :: a -> IO () }
13:02:28 <Cale> data Counter = forall a. Ctr { this :: a, inc' :: a -> a, display' :: a -> IO () }
13:02:33 <Cale> and then...
13:02:38 <Peaker> vixey: I do have a Delta typeclass - but there are those that want to know which specific instance it is - the exact delta type is what interests them
13:02:56 <Peaker> vixey: for example, I could have a "deltaType :: String" in that class, and the smart sum could compare that to "Sort" but that's ugly
13:02:57 <kpreid> Cale: doesn't that mean that you have to allocate a record with every function, for each value?
13:03:00 <Cale> inc (Ctr x i d) = Ctr { this = i x; inc = i; display = d }
13:03:20 <kpreid> (whereas the dictionary-or-equivalent only needs exist once)
13:03:36 <EvilTerran> Cale, er, yes, of course
13:03:55 <EvilTerran> well, apart from s/;/,/
13:04:52 <Toxaris> kpreid: maybe you can do both and have a Object type which consists of a this-pointer and a pointer to the method table, just as in OO?
13:04:57 <Peaker> vixey: part of the delta concept is that there are infinite possible delta types (anyone can add a new array delta, and describe how it can "transform" to the more primitive array deltas like Permute or Set). And then anyone else can "match" against specific delta types
13:05:19 <kpreid> Toxaris: sure
13:05:52 <Peaker> I don't want to use TypeRep/Dynamic/cast/etc -- I find them ugly :) But I am not sure I can do all this less uglily
13:07:31 <vixey> I don't really understand it
13:07:35 <Toxaris> Peaker: let's say I want to add a new array delta, how do I do that in a perfect world? How do I get a "name" for it, an identifier or whatever? do I have to register it with some central registry, at runtime or by calling you via phone and asking for a number?
13:08:13 <Peaker> Toxaris: you could generate a random UUID large enough, or use a hierarchy (get a big range once by phone)
13:08:23 <EvilTerran> Peaker, you can only "match against types" in typeclass methods
13:08:36 <kaspyanand> hi
13:08:44 <vixey> hi kaspy
13:08:47 <Peaker> EvilTerran: I can use Dynamic too?
13:09:08 <Toxaris> Peaker: ok, so by some offline-method independent of Haskell I get a unique number, which I can represent as type DeltaID in Haskell
13:09:08 <vixey> how is Dynamic implemented? (typeclasses)
13:09:37 <kaspyanand> add ::<font size="3"> Int -> Int -> Int </font>
13:09:41 <kaspyanand> add x y = x + y
13:10:11 <kaspyanand> what this statements means" --><font size="3"> operator is right associative, and function application is left associative"</font>
13:10:15 <Peaker> Toxaris: Yeah -- but I don't have the luxury of having my own code run at compile-time, so I cannot generate ID's at that time. I can use the unique identities of the types themselves, though
13:10:30 <kaspyanand>  meaning the type signature of add actually looks like this:
13:10:30 <kaspyanand> add :: Int -> (Int -> Int)
13:10:41 <Toxaris> Peaker: the programmer could enter the Id by hand?
13:11:08 <vixey> kaspyanand: f x y z = (((f x) y) z)
13:11:47 <Toxaris> Peaker: that cannot be statically type safe, of course, since the type system does not know the mapping from IDs to Delta implementations
13:11:56 <Peaker> Toxaris: yeah, that's what I meant by the String above. I could have the Permute and Sort delta implement a deltaType classmethod that returns "Sort" or "Permute", but that is ugly :)   Then I'd also need something like: deltaParams that also returns serialized extra data (for example, which indices to permute)
13:12:28 <EvilTerran> Peaker, yes, but that only works because the Dynamic typelcass is doing the aforementioned "matching against types"
13:12:32 <hackage> Uploaded to hackage: vector-space 0.3
13:12:32 <hackage> Uploaded to hackage: MemoTrie 0.0
13:12:45 <Cale> Why doesn't the hackage bot link to the pages?
13:12:54 <Peaker> Toxaris: I could revert back to a non-extensible world (data ArrayDelta a = Set [a] | Permute [Int] | Sort | .. )
13:13:02 <SamB> hackage: about
13:13:02 <Cale> Who runs the hackage bot?
13:13:06 <marcot> http://www.haskell.org/cabal/release/latest/doc/users-guide/authors.html
13:13:09 <lambdabot> Title: Creating a package, http://tinyurl.com/5bk455
13:13:14 <marcot> This links to http://www.haskell.org/cabal/release/latest/doc/libraries/Cabal/Distribution-License.html#t:License
13:13:16 <lambdabot> http://tinyurl.com/5jbebm
13:13:21 <marcot> Which is broken...
13:13:40 <marcot> http://www.haskell.org/cabal/release/latest/doc/API/Cabal/Distribution-License.html
13:13:41 <lambdabot> Title: Distribution.License, http://tinyurl.com/5euhvh
13:13:43 <marcot> This is the right link.
13:13:45 <Peaker> EvilTerran: is it possible to have a set of functions that work on different input types and match the right one to some value of an unknown type (via Dynamic)?
13:13:57 <marcot> Where should this be reported?
13:14:16 <Peaker> I guess I could do it with an assoc-list
13:14:20 <EvilTerran> Peaker, yes, i think so - if the un-known type is in Typeable, anyway
13:14:24 <vixey> ArrayDelta a => a x -> a x ....
13:14:28 <vixey> ?
13:14:30 <Peaker> (given that Data.Map is not possible)
13:14:38 <Toxaris> Peaker:
13:15:02 <EvilTerran> i think you could do something with a [forall a. Typeable a => (a -> whatever)]
13:15:07 <marcot> How can I get an account at code.haskell.org?
13:15:15 <EvilTerran> that'd be effectively "matching against types"
13:15:54 <Peaker> vixey: no -   a x -> a x   is opaque. I want the delta to be non-opaque
13:16:21 <dons> so i modified alex to generate lexers that parse directly from strict bytestrings
13:16:39 <dons> i think we could produce a whole bunch of interesting, efficient lexer/parsers libraries for common formats this way
13:16:42 <dons> by just generating them from alex.
13:16:49 <Peaker> vixey: in fact, I don't really need the ability to apply that delta to any other array except the one it was applied to (so I can just store the "a x" result), but I do need to have extra information about WHAT happened so that a processor of that information can use that information
13:16:54 <Toxaris> Peaker: class Delta a where get :: forall d . a -> DeltaID -> Maybe d
13:17:29 <Peaker> Toxaris: interesting. :)
13:17:38 <andyjgill> Afternoon Haskellers.
13:17:40 <Toxaris> Peaker: with some Typeable and cast magic so that you get Just x only if (1) the delta supports DeltaID and d matches DeltaID
13:17:54 <noeckist> hello, i have a question about performance in ghc, there is an IORef that I am currently storing all my data in, but it takes a while to get the contents out of it
13:17:54 <Toxaris> s/d/(2) d
13:17:56 <Peaker> vixey: the example from above: a sumArray function that has a "mutable" input array -- and updates the sum when that array changes
13:18:14 <Peaker> vixey: I don't want it to have to go through the entire array again - if only the elements' order changed
13:18:21 <Peaker> vixey: as the order does not affect the sum
13:18:28 <dons> yo andyjgill in the house!
13:18:41 <dons> anyone else notice that ghc quietly was cabalised this week?
13:18:46 <andyjgill> Hi dons
13:18:51 <noeckist> and i am writing a GUI app so everytime the screen needs to be refreshed because it went out of focus, the IORef needs to be reread again, but the thing is that the IORef hasn't changed during that time
13:18:56 <Toxaris> Peaker: every delta would support "basic.inbuilt.very.important.SetCompletely"
13:19:01 <marcot> Where should I mail to get an account?
13:19:02 <Peaker> vixey: so I want the sumArray processor to get a "Permute" delta and know that it can leave the sum as it is. If SetArrayItems happened, though, it knows that it needs to sub/add the deltas of those specific elements
13:19:16 <Peaker> Toxaris: yeah
13:19:25 <Toxaris> Peaker: and clients would just ask the list of their favorite deltas until they find a Just. every client would find at least SetComplete.
13:19:52 <Toxaris> Peaker: of course, that would be ugly as in "uses cast or something similiar", but it would be somewhat hidden
13:19:53 <noeckist> would it be faster to construct a value out of the IORef and then when I need to refresh the screen compare the IORef value to the constructed one?
13:20:15 <Peaker> Toxaris: yeah, that seems to work, when I have the cast-thing in my own typeclass
13:21:19 <Toxaris> Peaker: you would basically copying part of Dynamic to get DynamicDelta :)
13:21:25 <Peaker> Toxaris: generating delta-id's still isn't nice
13:21:41 <EvilTerran> you should be able to do it with just Dynamic
13:21:44 <Peaker> Toxaris: I'm surprised I couldn't find any combinator library around differential computing before
13:21:54 <noeckist> mainly will it cost more to compare two lists, one acquired from an IORef, or just map through the list extracted from the IORef itself?
13:21:58 <EvilTerran> TypeRep has an Eq instance
13:22:08 <Peaker> EvilTerran: If it had Ord... :)
13:22:50 <Toxaris> Peaker: hmm, is that your main problem with Typeable & Co?
13:23:07 <Peaker> Toxaris: So far
13:23:13 <EvilTerran> or something like \fs x -> head [fx | Just fx <- map (<$> fromDynamic x) fs]
13:23:35 <EvilTerran> i don't think [forall a. Typeable a => a -> IO ()] is a valid type, unfortunately
13:23:39 <EvilTerran> but something similar to that
13:23:56 <vixey> I don't know what this is at all actuall
13:23:59 <vixey> y
13:24:24 <Peaker> vixey: did you understand the "sumArray" example I used?
13:24:25 <Toxaris> Peaker: maybe you can hack TypeRep -> TypeRepWithOrd using unsafePerformIO?
13:24:31 <vixey> no
13:24:36 <noeckist> actually, i just realized that won't work since I need to save that constructor to a State of some kind and it would probably be the same as using IORef
13:24:42 <andyjgill> Hey, I'm trying to compile a list of QuickCheck variants. Has anyone hacked up a personal quickCheck, or QC driver, etc?
13:25:14 <Peaker> vixey: Was there anything specific not clear about it?
13:26:18 <MyCatVerbs> noeckist: reading an IORef isn't particularly expensive.
13:26:22 <Peaker> vixey: The basic building block is that I have a "changing value". I want to create another "changing value" that is a computation of the first "changing value".  If the first "changing value" is an array, and the second one is the sum of that array's elements - I want the sum to "update" its value when the array does
13:27:19 <Peaker> vixey: There are certain changes possible on the array that do not at all affect the sum, so I want the sum processor to be smart enough to recognize these and optimize them out
13:27:38 <MyCatVerbs> noeckist: we're talking on the order of microseconds - maybe at the very worst two or three indirect memory accesses. Certainly not a noticable cost if you're doing so every time your GUI app comes into focus.
13:28:02 <marcot> How should I use UnknownLicense in the license field of cabal?  I'm using it license: UnknownLicense "X11"
13:28:05 <MyCatVerbs> noeckist: what's more liable to kill performance is if you're doing something complicated with the contents, but aside from that, don't apnic.
13:28:07 <vixey> ok now I understand
13:28:16 <marcot> But I'm getting: Setup.hs: interleaveIO.cabal:3: Parse of field 'license' failed:
13:28:26 <conal> andyjgill: i just emailed you a collection of QC helpers i've used
13:28:42 <andyjgill> Thanks conal.
13:28:51 <Peaker> vixey: I can have a big "data ArrayDelta = ..." with all possible descriptions of a modification of an array.  But that's not extensible
13:29:06 <gwern> marcot: wouldn't X11 be OtherLicenses?
13:29:11 <gwern> or OtherLicense, whatever
13:29:15 <andyjgill> I am specifically wondering who has modified it for things like novel reporting, or measuring time, etc.
13:29:24 <noeckist> MyCatVerbs : well, im drawing images with Cairo using the info but sometimes it becomes almost unbearable
13:29:50 <vixey> I think you can set this up just by typeclass interactions
13:29:54 <marcot> gwern: I just saw that I was looking at a newer documentation of Cabal.  In this newer one, there's this UnknownLicense possibility.
13:30:12 <noeckist> like when i try to resize the window, it just freezes for a few seconds until it has read everything
13:30:22 <quicksilver> Peaker: you can define an ord instance for typerep
13:30:31 <MyCatVerbs> noeckist: Eeek! Forget about the IORef for the moment - drawing images with Cairo invokes network traffic. That's -really- expensive. :)
13:30:39 <gwern> marcot: oh, that's interesting. but from the sound of it, if you know the license then by definition UnknownLicense would not be appropriate, no?
13:30:39 <quicksilver> Peaker: (sorry I haven't been following properly, but is that the problem?)
13:30:44 <Peaker> quicksilver: how? wouldn't I be tightly coupled with its internal respresentation?
13:30:54 <quicksilver> Peaker: instance Ord TypeRep where compare = compare `on` show
13:30:57 <Peaker> quicksilver: that helps (Data.Map instead of an assoc list)
13:31:06 <quicksilver> cheat and use the string mapping given by show
13:31:22 <Peaker> quicksilver: can't different types be equal according to their show?
13:31:23 <MyCatVerbs> netj: would -strongly- advise carefully keeping track of whether or not you need to redraw.
13:32:01 <quicksilver> Peaker: hopefully not very often.
13:32:08 <marcot> gwern: I think this unknown is for cabal, not for the author.
13:32:10 <quicksilver> do you often define two types with the same name? :)
13:32:13 <noeckist> MyCatVerbs : needs network traffic? is it because its calling the X server?
13:32:18 <MyCatVerbs> noeckist: yup.
13:32:32 <gwern> marcot: in that case, why does OtherLicenses exist?
13:32:43 <MyCatVerbs> noeckist: plus the marshalling and demarshalling over the socket for it (even on localhost) costs something.
13:32:58 <Peaker> quicksilver: I was just whining. I don't need the performance of Data.Map, probably.
13:33:06 <Peaker> quicksilver: also, I could use a Hashtable or something
13:33:36 <Toxaris> quicksilver: well, Peaker talks about a system extendible by third-party components
13:33:43 <MyCatVerbs> noeckist: if someone's using X11 forwarding, that kind of issue can make your app totally unusable - imagine issuing all those dozens or hundreds of drawing calls, and each one taking about a tenth of a second to complete because of network latency back and forth.
13:34:36 <noeckist> MyCatVerbs : itd be awesome if I don't have to redraw something, but is it possible to do that if, for example, something has obscured it and it needs to go back into focus?
13:35:47 <MyCatVerbs> noeckist: don't know. You'll have to read up on X11 for that, I guess. (Or maybe Cairo or GTK documentation explain it).
13:36:19 <noeckist> maybe i need to somehow the state of the widget or smthing
13:36:33 <noeckist> *somehow save the state
13:37:07 <noeckist> MyCatVerbs : but thanx, that means that I don't have to worry about IORef being a bottleneck
13:37:19 <MyCatVerbs> noeckist: what I'm trying to get across is that it makes almost no difference whether your cache is passed around as a value or an IORef, because the network traffic involved is likely to be between about ten thousand and a hundred million times as expensive as reading an IORef. ;)
13:37:50 <noeckist> true
13:39:06 <marcot> gwern: backwards compability, I guess.
13:39:35 <MyCatVerbs> Worst case scenario, accessing the IORef involves touching RAM twice. The DIMMs are a few centimetres away from the CPU. The machine you're talking to via the network could be on the other side of the planet. :)
13:41:37 <shapr> jiihaa
13:41:54 <MyCatVerbs> shapr: jiiwhat?
13:42:04 <shapr> It's finnish for yeehaa!
13:45:13 <|Steve|> ghc-inplace segfaults on Adjustor.o when I try to build ghc. Is there any known work around?
13:56:41 <mjrosenb> i belive that i've seen this in here before
13:57:30 <mjrosenb> is there anything for tracing? mostly i just want to print out a message whenever the evaluation of a thunk is forced
13:58:36 <kpreid> @type Debug.Trace.trace
13:58:37 <lambdabot> forall a. String -> a -> a
13:58:56 <mjrosenb> oohhh, that seems like it will work.
13:58:58 <mjrosenb> thanks.
14:02:01 <gwern> ack, ghc fails to compile again
14:02:11 * mjrosenb is very slowly coming to terms with the ghci debugger
14:02:14 <gwern> (stupid directory, why does it always screw up)
14:02:44 <mjrosenb> hrmm, :back doesn't take arguments
14:02:46 <gwern> try try again, I suppose
14:03:01 <mjrosenb> is there a way to step back to the N'th item in the history?
14:04:08 <pozic> mjrosenb: you can implement a ghci command if you want.
14:04:22 <mjrosenb> with :def?
14:04:49 <pozic> There is some .ghci file where you can define that stuff. See manual.
14:05:02 <Mitar> why I get a kind mismatch with:
14:05:02 <Mitar> type VoxelColorMonad = Either VoxelColor BasicReal
14:05:03 <Mitar> instance MonadError VoxelColor VoxelColorMonad where
14:07:06 <pozic> Mitar: it's not a monad.
14:07:41 <pozic> Mitar: monads always are parameterised.
14:08:02 <pozic> Mitar: you just have a concrete type. If Either is a monad, it already works.
14:08:07 <Mitar> how can I make an error monad which uses throwError and catchError but is not an instance of Error? (because string errors make little sense)
14:08:22 <roconnor> use monadlib?
14:09:20 <mdmkolbe> @type throwError
14:09:21 <lambdabot> forall e (m :: * -> *) a. (MonadError e m) => e -> m a
14:09:25 <mdmkolbe> @type MonadError
14:09:27 <lambdabot> Not in scope: data constructor `MonadError'
14:09:33 <mdmkolbe> @info MonadError
14:09:34 <lambdabot> MonadError
14:09:46 <Mitar> i tried to do
14:09:46 <Mitar> returnColor :: VoxelColor -> Either VoxelColor BasicReal
14:09:46 <Mitar> returnColor = throwError
14:09:55 <Mitar> but I get
14:09:55 <Mitar>    No instance for (Error VoxelColor)
14:09:56 <Mitar>       arising from a use of `throwError'
14:10:37 <Mitar> why would it need to be an instance of Error? it makes no sense to use string errors I want that an error be represented by VoxelColor
14:10:56 <mdmkolbe> Mitar: it's the Either that is causing your problem, it's Monad instance has a pre-req of Error
14:11:28 <mdmkolbe> Mitar: run an :info Either and look at the lines for instance Monad and instance MonadError
14:11:51 <Mitar> hm
14:11:52 <monochrom> If you want (Either MyType) to be a Monad, MyType needs to be an Error.
14:12:14 <monochrom> For example (Either String) is OK because String is already an Error.
14:12:14 <mdmkolbe> Data types other than either, you should be able to make MonadError instances without needing Error just fine
14:12:21 <hackage> Uploaded to hackage: Pipe 2.0
14:12:47 <monochrom> Oh, yes, rolling your own MonadError is also cool.
14:15:29 <Mitar> i am trying to do this: http://www.haskell.org/pipermail/haskell-cafe/2008-July/045366.html
14:15:31 <lambdabot> Title: [Haskell-cafe] Re: Profiling nested case, http://tinyurl.com/5f9gt8
14:16:00 <Mitar> and I was thinking of misusing the errormonad so that I return color as an error
14:16:35 <Mitar> or there is no color to the end of list of objects then i return non-error as a minimal value
14:16:55 <Mitar> i will need to switch left and right though
14:20:05 <Peaker> Cale: http://hpaste.org/9036 works (Typeable on existentials)
14:23:32 <hml> does haskell have anything like erlang's bit syntax?
14:23:49 <hml> i.e. something like: M = <<X:3, Y:7, Z:6>>
14:28:11 <_zenon_> hml, I don't even know what Erlangs bit syntax means
14:29:17 <Zao> _zenon_: A wild guess would be something along the lines of the C++ bitfields.
14:29:35 <Zao> That's to say, X is a 3-bit integer, Y is a 7-bit integer, and so on.
14:29:41 <_zenon_> Zao, okay.
14:30:16 <Mitar> how can I get floating infinity value?
14:31:12 <roconnor> > 1/0
14:31:14 <lambdabot>  Infinity
14:31:17 <roconnor> > -1/0
14:31:19 <lambdabot>  -Infinity
14:31:29 <Mitar> is this the portable way?
14:31:49 <roconnor> Infinity isn't guarenteed to exist I don't think
14:32:04 <Mitar> is not infinity IEEE?
14:32:16 <roconnor> double may not be ieee
14:32:25 <roconnor> > isIEEE 0
14:32:27 <lambdabot>  True
14:32:40 <roconnor> > isIEEE (0::Fixed)
14:32:41 <lambdabot> Terminated
14:33:04 <roconnor> @type isIEEE
14:33:05 <lambdabot> forall a. (RealFloat a) => a -> Bool
14:33:14 <roconnor> @instance RealFloat
14:33:14 <lambdabot> Maybe you meant: instances instances-importing
14:33:19 <roconnor> @instances RealFloat
14:33:20 <lambdabot> Double, Float
14:33:40 <roconnor> well, Doubles are IEEE in lambdabot
14:44:18 * _zenon_ is turning in.
15:03:43 <yitz> hi
15:06:28 <mdmkolbe> hi
15:12:22 <hackage> Uploaded to hackage: bytestring-lexing 0.1.0.1
15:12:22 <hackage> Uploaded to hackage: bytestring-lexing 0.1
15:12:39 <vixey> great
15:12:48 <vixey> thank you hackage
15:15:41 <Botje> mjrosenb: experimenting with the quantum lifestyle, eh? :)
15:16:08 <vixey> oh hey Botje
15:16:18 <Botje> hello, vixey
15:16:22 <vixey> did you decide on an algorithm for type inference?
15:16:22 <monochrom> de Botje wave?
15:16:39 <Botje> i'm feeling rather particley today :p
15:16:44 <vixey> /checking
15:17:21 <Botje> vixey: would I be at a disadvantage if I just put together a straightforward constraint solver?
15:18:49 <Botje> I'm going to read up on hindley-milner tomorrow, anyway :)
15:18:53 <vixey> that's what they do in ATTAPL, it must be a good idea
15:19:27 <Botje> :)
15:19:52 <vixey> I haven't understood how it's more efficient than naive traversal with first order unification yet
15:20:00 <vixey> pretty sure that it is though
15:20:54 <Botje> i'll see
15:20:59 <SamB> probably related to the lack of "naive" in the name?
15:21:19 <vixey> SamB: No..
15:21:40 <Botje> as far as I can see my limited subset of ML doesn't allow for undecidability, so I should be fine :)
15:21:41 <SamB> well, if it were inefficient it would be more likely to have a "naive" in the name ...
15:21:59 <vixey> oh you have side effects?
15:22:30 <Botje> nope
15:22:44 <vixey> oh well you don't have to worry about value restriction then
15:22:56 <Botje> I have main : () -> Int
15:23:05 <Botje> and the result of that gets printed
15:23:37 <mjrosenb> Botje: hrmm?
15:23:47 <Botje> 00:06 -!- mjrosenb is now known as not_mjrosenb
15:23:48 <Botje> ;)
15:24:08 <mjrosenb> Botje: ahh, discussion in another channel
15:24:10 <Toxaris> Botje: your main type looks like you should consider constant folding :)
15:24:21 <mjrosenb> Botje: someone said you couldn't be anonymous on the internet
15:24:27 <Botje> Toxaris: I already do that
15:24:34 <Botje> Toxaris: it's pretty cool so far
15:24:39 <mjrosenb> Botje: that was me making sure nobody knew who i was
15:24:49 <monochrom> Ha
15:25:07 <Botje> heh :)
15:26:04 <vixey> I am wondering if you could implement ST in Haskell if you have linear types
15:26:18 <monochrom> Yes.
15:26:49 <EvilTerran> you could implement ST in haskell even without linear types, i believe
15:26:50 <monochrom> I mean I bet yes.
15:27:07 <EvilTerran> unless you mean with the same use of mutable state
15:27:11 <vixey> EvilTerran: and have it comparably efficient?
15:27:48 <EvilTerran> well... i guess linear types would work out to pretty much the same thing as ST
15:28:33 <monochrom> Phil Wadler has "linear types can change the world!".  May be inspiring.
15:38:27 <vixey> I hope there aren't any practical reasons that linear types aren't around in MLs today
15:39:57 <vixey> hmm does haskell mind being called an ML?
15:41:06 <mdmkolbe> ML?
15:41:15 <mdmkolbe> as in the "ML"?
15:41:24 <dons> Lazy ML was one of the parents of Haskell.
15:42:11 <mdmkolbe> @karma+ dolio
15:42:12 <lambdabot> dolio's karma raised to 1.
15:42:43 <vixey> oh it says, "it is not clear whether it can be extended to the more common HMD inference system"
15:42:56 <vixey> so I guess nobody has figured out how to do type inference for linear MLs yet
15:44:59 <MyCatVerbs> vixey: I hope not.
15:45:18 <MyCatVerbs> vixey: I refer to Haskell as an ML-descendant (ML-a-like, even) all the time.
15:45:27 <mjrosenb> vixey: you have a link for linear type systems?
15:46:03 <MyCatVerbs> There's wiki, but it's short. :) http://en.wikipedia.org/wiki/Linear_type
15:46:04 <lambdabot> Title: Linear type system - Wikipedia, the free encyclopedia
15:46:38 <MyCatVerbs> mjrosenb: also look into "linear logic" (which I do not know of good references on) because that's where, AFAIK, the concept comes from.
15:46:59 <MyCatVerbs> mjrosenb: effectively, uniqueness typing. (You maybe have heard of this due to Clean?)
15:46:59 <vixey> http://www.cs.cmu.edu/~fp/courses/linear/
15:47:01 <lambdabot> Title: 15-816 Linear Logic
15:47:29 <MyCatVerbs> vixey: tell me, is that your favourite reference, or is that just one of the first few results on Google? ;)
15:48:18 <MyCatVerbs> vixey: the former is useful, the latter... well, saves bothering to type ^Lgoogle.com/search?q=...
15:48:20 <vixey> MyCatVerbs: both
15:48:55 * mjrosenb does'nt remember seeing that last time i went to pfenning's page
15:49:03 <FunctorSalad> is there something like a "Tagged" monad already? (thinking about facetted classification, to be specific)
15:52:20 <FunctorSalad> say, Tagged Foobar would be a tagged collection of Foobars
15:57:42 <Baughn> FunctorSalad: As a monad? How would that be monadic?
15:58:18 <Baughn> You could express it as a map of sets, maybe.. or map of maps, or something
15:59:16 * FunctorSalad ponders how "join" could work
15:59:54 <vixey> FunctorSalad: maybe it's an Idiom instead of a Monad
15:59:55 <Baughn> FunctorSalad: ..why a monad?
16:00:19 <FunctorSalad> well, if we have Tagged (Tagged Foo), we could flatten the tag hierachy by making new facets
16:00:40 <FunctorSalad> Baughn: you're right, I didn't think it through. but looks like it might work
16:00:58 <FunctorSalad> vixey: Idiom? is that a technical term?
16:01:08 <vixey> haskell term
16:01:12 <Baughn> FunctorSalad: I suppose, I just don't quite see how the sequencing part of having monads would help
16:01:20 <Baughn> Sure, you /can/, but /why/?
16:01:24 <FunctorSalad> Baughn: yeah
16:01:27 <Baughn> A simple combinator library might be better
16:02:14 <FunctorSalad> it should be a functor at least, though ;)
16:02:53 <Baughn> ..perhaps. I really don't see what you're trying to accomplish here, but you would.
16:03:53 <FunctorSalad> Baughn: right, it's a bit irrelevant. I guess what I really wanted is just an existing lib to manage classifications
16:04:10 <FunctorSalad> sorry, need to think a bit more before writing ;)
16:04:14 <vixey> monochrom: hmmm that paper put me off a bit
16:04:25 <Baughn> I mean, to be able to map a function over every datum matching a set of tags, sure a functor would work.. but so would returning a list directly, or some other structure for which there already is a functor instance
16:05:27 <vixey> I don't know much about peephole optimizing so I don't know if a good performance would require JIT  or not
16:05:53 <Baughn> Not. gcc certainly gets good performance
16:06:16 <Baughn> It's just, doing static /and/ dynamic optimizations is the holy grail. I'm not aware of any compiler that does both, yet
16:06:47 <vixey> Baughn: yes but gcc isn't compiling a ilnear typed ML :p
16:07:24 <Baughn> vixey: When I read "peephole optimizer" I think assembly level, at which point that hardly matters
16:08:01 <vixey> the actual example was,
16:08:15 <vixey> case xs of [] -> [] ; (x:xs) -> x : foo xs
16:08:24 <Baughn> Things like reordering operations to take advantage of wait states, or keeping execution unit loads balanced.. not something that's very useful on x86, happily
16:08:53 <MyCatVerbs> vixey: cool, thanks for the link, then. :)
16:09:10 <vixey> the [] or Cons gets destroyed by pattern matching, so the compiler needs to notice that (x :) appears over there.. to actually mutate the thing instead of freeing it and allocating a new ceel
16:09:13 <vixey> cell*
16:09:45 <Baughn> Mm. My definition may be unusual, but I wouldn't call that peephole optimization
16:10:11 <FunctorSalad> embarassing question: say I have some huge value x; if I add x as a value in two different Data.Maps, is this optimized to use references to x rather than two deep copies?
16:10:21 <Baughn> (Because the "peephole" wouldn't be O(1)-sized)
16:10:28 <vixey> well I was thinking.. compile to naive assembly.. and then optimize away any destruction followed by allocation
16:10:47 <vixey> (assuming the typed assemby matches up)
16:10:52 <Baughn> FunctorSalad: Yes.
16:11:33 <FunctorSalad> ok, then I can just use a bunch of maps I suppose
16:11:36 <Baughn> FunctorSalad: (Everything is)
16:11:44 <FunctorSalad> :)
16:12:09 <MyCatVerbs> FunctorSalad: provided it's something like let x = buildHugeStructure args in continue (insert map k1 x) (insert map k2 x), then yes. Everything is, that's what sharing gets you.
16:12:13 <vixey> but I have no idea how that sort of thing would work in practice and whether or not it would be insignificant
16:12:31 <Baughn> FunctorSalad: Well, it does have the downside that it takes a pointer to store a Word8, instead of just 8 bits
16:12:43 <MyCatVerbs> FunctorSalad: don't do: continue (insert map k1 (buildHugeStructure args)) (insert map k2 (buildHugeStructure args)), though. ;)
16:12:45 <Baughn> Except when ghc can prove it's safe to stack-allocate it, I guess
16:13:02 <Baughn> (And the strictness analyzer agrees it won't mess up laziness)
16:14:09 <FunctorSalad> MyCatVerbs: I see. in that simple case I presume ghc might recognize this, though. due to purity this can safely be simplified, no?
16:14:43 <MyCatVerbs> FunctorSalad: I thought so too, but often not.
16:15:01 <Baughn> FunctorSalad: GHC doesn't /like/ floating expressions. There are issues - it can, in fact, lead to memory leaks
16:15:36 <Baughn> FunctorSalad: Like if you have structures x1 and x2 that both contain the expression e. Now, assume e takes a lot of memory - it is, of course, calculated lazily
16:15:38 <MyCatVerbs> FunctorSalad: eliminating common subexpressions is surprisingly hard for GHC to do, because it has to take care not to accidentally cause loss of laziness.
16:16:02 <Baughn> FunctorSalad: So if you force the version in x1 and then drop all references to x1, it really shouldn't keep taking memory due to a reference in x2
16:16:13 <Baughn> In practice, you have to explicitly add a let to get sharing
16:17:00 <FunctorSalad> ok thanks, I think I understand it a bit better now
16:17:00 <MyCatVerbs> (Or a case or a where or even (\x -> continue x) (buildHugeStructure args), but these are all related anyway.)
16:17:48 <Baughn> It gets compiled down to lets at one point, I believe. Anyhow..
16:18:11 <FunctorSalad> I haven't given any thought to the interplay of lazyness and optimization yet, so this is all very new to me...
16:18:19 <Baughn> FunctorSalad: Once you assign a name to something, it's shared. That's what it all boils down to.
16:18:33 <Baughn> Just keep using the same name, and you'll get the same structure.
16:19:11 <FunctorSalad> Baughn: ok, it's not like I would reasonably build two equal HugeStructures anyway, I think
16:19:38 <FunctorSalad> (two seperate ones, without let)
16:20:00 <Baughn> Sometimes rebuilding a structure is faster than having it take memory while it isn't useful
16:22:04 <FunctorSalad> ghc starts to look like a whole science on its own ;)
16:22:30 <Baughn> (It would be nice to have an unsafeReplicateThunk call somewhere, though.)
16:22:47 <Baughn> FunctorSalad: Ooh, yes. Here, hang on..
16:23:30 <Baughn> FunctorSalad: www.cs.cmu.edu/~rwh/theses/okasaki.pdf  <-- Here's the seminal work on said science
16:23:59 <FunctorSalad> thanks
16:25:06 <Baughn> @go okasaki
16:25:07 <lambdabot> http://www.eecs.usma.edu/webs/people/okasaki/pubs.html
16:25:07 <lambdabot> Title: Chris Okasaki's Publications
16:25:29 <MyCatVerbs> FunctorSalad: oh and if you get the chance, pick up a copy of Okasaki's book, too. Very educational and fun.
16:25:40 <vixey> FunctorSalad: fun thing (related) to think about, http://hpaste.org/9033
16:29:35 <t0c> Greetings, I want to write a FFI to libevent (http://monkey.org/~provos/libevent/). Typical usage of that library means allocating a struct on the stack whose address is passed to functions, e.g. http://monkey.org/~provos/libevent/event-test.c . My question is: Do I need to declare the struct as a corresponding data type in haskell?
16:31:23 <bd_> You don't have to. It might be convenient to write a corresponding type and Storable instance for access, but if the struct is opaque this is probably not necessary.
16:32:07 <t0c> Its not an opaque struct, otherwise it could not be stack allocated.
16:32:23 <bd_> anyway, you can just use Foreign.Marshal.Alloc.malloc
16:32:31 <dons> looks at the PCRE library for an example of how to avoid defining the struct on the Haskell side.
16:32:33 <bd_> t0c: It's opaque if the user is not meant to mess with its fields :)
16:32:45 <dons> if the allocation happens on the libevent side you can pretty much keep it opaque to haskell
16:33:22 <Apocalisp> is there a function (a -> b) -> (a, a) -> (a, b) ?
16:33:26 <dons> note there's something of a libevent binding here, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/codec-libevent
16:33:26 <Apocalisp> gah
16:33:27 <lambdabot> Title: HackageDB: codec-libevent-0.1.2, http://tinyurl.com/5b5frj
16:33:29 <dons> not sure how much is does.
16:33:34 <Apocalisp> (a -> b) -> (a, a) -> (b, b)
16:33:34 <dons> ah, just hte data.
16:33:44 <vixey> :t second :: (a -> b) -> (a, a) -> (b, b)
16:33:49 <lambdabot>     Couldn't match expected type `a' against inferred type `b'
16:33:49 <lambdabot>       `a' is a rigid type variable bound by
16:33:49 <lambdabot>           the polymorphic type `forall a b. (a -> b) -> (a, a) -> (b, b)'
16:33:52 <vixey> oh
16:33:55 <bd_> dons: libevent requires the user to allocate an appropriate event structure, but initializing it is handled by the accessor functions in the library I believe (ie, the user is not expected to access its members)
16:33:59 <mauke> Apocalisp: join (***)
16:34:08 <Apocalisp> :type join (***)
16:34:33 <t0c> Thanks. Will look at PCRE. As bd_ said allocation is users responsibility.
16:34:50 <bd_> t0c: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Foreign-ForeignPtr.html#v%3AmallocForeignPtr - you'd need to declare a Storable, but you could just implement sizeOf and alignment and leave the other members undefined
16:34:52 <lambdabot> Title: Foreign.ForeignPtr, http://tinyurl.com/6fh8gk
16:35:31 <Apocalisp> nice. Thanks, mauke.
16:43:50 <Jessehk> I'm unsure of the syntax for deriving an instance of a class (Show) for data that has a type constraint (like Num). Any help would be very appreciated. http://hpaste.org/9037 :)
16:44:22 <mauke> step 1: don't put class constraints on data
16:44:27 <EvilTerran> Jessehk, datas with class constraints don't do what you want
16:44:49 <vixey> instance Num a => Show (Token a) where
16:45:16 <EvilTerran> they just enforce the class constraint on every relevant type sig
16:45:43 <Jessehk> EvilTerran mauke vixey: Oops. Thanks for the help. :)
16:46:07 <EvilTerran> i think they kinda do what you want everywhere you don't need explicit type sigs, but you need to add the Num constraint to the context in the instance head here
16:49:42 <Jessehk> thanks again. Great help as usual. :)
16:51:35 <Apocalisp> Any functions in the libraries, besides Numerics, to show an integer in any base?
16:52:12 <mauke> what's wrong with Numeric?
16:52:33 <Apocalisp> just a bit verbose
16:52:34 <vixey> @index showIntAtBase
16:52:35 <lambdabot> Numeric
16:52:46 <vixey> "verbose" ?
16:53:02 <mauke> :t showIntAtBase
16:53:02 <Apocalisp> maybe I'm using it wrong
16:53:02 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
16:53:17 <vixey> Apocalisp: You should define a new function
16:53:19 <Apocalisp> Oh wait... String?
16:53:32 <mauke> > showIntAtBase 9 intToDigit 42 ""
16:53:34 <lambdabot>  "46"
16:53:44 <Apocalisp> hey, no fair
16:53:47 <EvilTerran> > showIntAtBase 16 intToDigit 12648430 ""
16:53:48 <Apocalisp> :)
16:53:52 <lambdabot>  "c0ffee"
16:53:55 <Quadrescence> :)))))
16:53:56 <vixey> mySuperShortNameForThisPreviouslyVerboseFunction number base = showIntAtBase base intToDigit number ""
16:54:18 <mauke> > showIntAtBase 36 intToDigit 1510751846200559 ""
16:54:20 <lambdabot>  "Exception: Char.intToDigit: not a digit 23
16:54:24 <EvilTerran> it returns a (String -> String) instead of a String for performance reasons when concatenating
16:54:25 <mauke> :-(
16:54:43 <vixey> they should really name that String -> String type
16:54:51 <Apocalisp> I had Integral a => a -> (Int -> Char) -> a -> ShowS
16:54:53 <mauke> > showIntAtBase 36 ((['0' .. '9'] ++ ['a' .. 'z']) !!) 1510751846200559 ""
16:54:54 <lambdabot>  "evilterran"
16:55:01 <Quadrescence> > showIntAtBase 42 intToDigit 151075184620
16:55:03 <EvilTerran> vixey, they did, it's called ShowS
16:55:03 <lambdabot>  <[Char] -> [Char]>
16:55:13 <Baughn> > showIntAtBase 13 (6*9) ""
16:55:13 <lambdabot>   add an instance declaration for (Num (Int -> Char))
16:55:20 <vixey> EvilTerran,
16:55:21 <vixey> :t showIntAtBase
16:55:22 <EvilTerran> because composing prepend functions together and then running them has better complexities than just (++)ing if you do it from the left
16:55:25 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
16:55:44 <Baughn> > showIntAtBase 13 intToDigit (6*9) ""
16:55:45 <EvilTerran> vixey, yeah, type aliases don't show up in extracted type sigs in ghc (and so lambdabot)
16:55:45 <lambdabot>  "42"
16:55:59 <vixey> oh.. I consider that a bug
16:56:27 <Apocalisp> ok, thanks. Just got confused with that bit.
16:56:51 <Quadrescence> What is the difference between a tree and a database?
16:57:18 <Quadrescence> That's a weird question.
16:57:57 <Quadrescence> Can trees be stored to the disk and loaded into a program?
16:58:20 <Apocalisp> "database" is more general
16:58:33 <Quadrescence> Right, hence it being a little bit of a weird question.
16:58:39 <Apocalisp> a bit
16:58:53 <dibblego> many databases use trees, they are called b-trees (of which there are variants)
16:59:37 <schme_> Hello DarthShrine
16:59:55 <Apocalisp> You'd normally store a database as a set of relations, a transitive closure of which is a tree.
17:00:27 * Apocalisp is totally punning on normally, and thinks nobody notices
17:00:54 <dibblego> I just thought it was normal
17:01:16 <Apocalisp> better than non-totally punning
17:02:48 <gwern> @pl printInterpreterError e = error $ take 1024 $ "Oops... " ++ (show e)
17:02:49 <lambdabot> printInterpreterError = error . take 1024 . ("Oops... " ++) . show
17:05:41 <Quadrescence> Okay. What type of data structure might I use here? I will have a tree, and, all except the root and leaves will have the same number of branches (>2). At each node, there is a value, and each branch does a certain operation on that node making a new child node.
17:07:28 <Quadrescence> Different routes through the tree, starting at the root (say the root has value 0000), will/can lead us to non-unique values
17:08:04 <Baughn> ..A tree?
17:08:10 <Quadrescence> which can be located elsewhere on the tree. And this is fine, because they're unique in the sense of the path.
17:08:19 <Baughn> Didn't you just describe the data structure you want?
17:08:34 <Quadrescence> Baughn: Sorry, yes I did. But there are millions of trees.
17:08:43 <dibblego> sounds like a BTree to me
17:08:44 <Quadrescence> and algorithms, I guess.
17:08:58 <dibblego> almost
17:09:20 <Toxaris> Quadrescence: you can just use an algebraic data type in Haskell to represent your tree
17:09:37 <Toxaris> Quadrescence: e.g. data Tree = MkTree Value Tree Tree Tree Tree
17:09:47 <Baughn> Quadrescence: When the data you're storing /is/ a tree, it usually isn't useful to store it /in/ a tree
17:09:52 <Toxaris>    | Leaf Value
17:10:21 <Toxaris> and data Root = MkRoot Tree Tree  -- since you said the root has a different number of branches
17:10:24 <Quadrescence> Baughn: If I interpret you correctly, of course.
17:10:36 <Baughn> Quadrescence: Of course, you could use a Map Path Value or some such.. that would have O(lg n) updates, which - if yours isn't necessarily balanced - your wouldn't
17:11:03 <Quadrescence> Toxaris: (I am noting what you're saying)
17:11:35 <Baughn> Quadrescence: If I read that right, what you want is a map (of some sort) from paths (consisting of a bunch of binary choices) to (some sort of, probably parametrized) values
17:11:54 <Quadrescence> The tree would be perfectly symmetrical, obviously. And I am not putting data into a tree. I am generating the tree, and then I will want to store it for later use.
17:12:16 <Toxaris> Quadrescence: "putting data into it" means that there are values, not only the tree structure
17:12:37 <Baughn> Quadrescence: How /large/ is it? Will you be taking advantage of laziness?
17:12:38 <Toxaris> Quadrescence: why would the tree be balanced? from your description, the leaves may be on different heights?
17:13:22 <Baughn> Quadrescence: If the tree is generated from inputs considerably smaller than said tree, you should probably be storing the inputs and not the tree
17:13:24 <Quadrescence> Baughn: Maybe millions.
17:13:28 <Quadrescence> (of nodes)
17:13:52 <Baughn> Quadrescence: Memory usage would be an issue, then. Also, you said it's "perfectly balanced".. dense?
17:13:53 <Toxaris> Baughn: depends obviously on the time needed for the computation
17:14:01 <Baughn> Quadrescence: All leaves at the same level?
17:14:06 <Baughn> Quadrescence: (All paths of the same length?)
17:14:45 <Quadrescence> Baughn: Well, really, the tree can be infinite. I take back what I say about symmetry.
17:14:52 <Baughn> Quadrescence: Might want to store it as an array instead, make the path simply the index.. of course, you'd lose O(lg n) updates, which you haven't said you need
17:14:53 <Quadrescence> All leaves are not at the same depth
17:14:59 <Baughn> Then not an array. Well..
17:15:08 <Baughn> Quadrescence: Storing an infinite tree to disk is an issue. ;)
17:15:23 <Toxaris> infinite trees are fine in Haskell *as long as you don't store it to disk*
17:15:39 <Baughn> Quadrescence: That's why I suggested storing the finite data instead. There's no sane way to ask haskell /whether a branch has been evaluated or not/
17:15:46 <Baughn> *finite input data
17:16:10 <Baughn> Not yet, at least
17:16:22 <Toxaris> maybe you know it yourself, since you know which operations you have performed so far
17:16:45 <Quadrescence> Hum, let me state a couple clarifying things.
17:16:49 <Quadrescence> and important. :P
17:16:55 <Maddas> Baughn: Well, if you store the infinite tree slowly enough, you'll never exceed the hard disk growth rate... ;-)
17:17:17 <Baughn> Or you could insert some unsafeInterleaveIO and concurrency to have the leaves streamed to disk as they're evaluated
17:17:28 <Quadrescence> The tree can be GENERATED infinitely. But then there would be an infinite number of non-unique nodes.
17:17:50 <Baughn> Quadrescence: Yeah, well..
17:18:24 <Baughn> Quadrescence: Unless you give us access to the same problem you're trying to solve here, I dont think we can help much. It's just too complex for irc; too much to ask about.
17:18:42 <Quadrescence> Baughn, okay.
17:19:03 <Quadrescence> Think of a rubik's cube. Suppose you encode the state of the cube in an integer
17:19:06 <gwern> 'Of course! I always wondered about the second step. I was still on:
17:19:06 <gwern> 1. Write down type signature 2. ??? 3. Write down 1 line -morphism solution
17:19:19 <Baughn> Quadrescence: You might store an infinite structure in finite space by having cycles, but I should mention that it's hard to detect those.. actually, I don't know /how/, without an object-identity predicate (which would break purity..)
17:19:23 <Quadrescence> The solved cube is the root node, having a value of 0000.
17:19:26 <povman> gwern: heh
17:19:27 <MyCatVerbs> Toxaris: storing it to disk is easy.
17:20:02 <Toxaris> Quadrescence: are we talking about state space exploration?
17:20:07 <Quadrescence> Every time I turn the side on the left, I add 1 to the integer, every time I turn it the opposite way, I -1
17:20:23 <Baughn> Quadrescence: I.. /really/ don't think you want to store /that/ tree to disk
17:20:29 <Baughn> It'll be beyond huge
17:20:33 <Quadrescence> Baughn: This is just an example
17:20:37 <Quadrescence> Of course not in this case
17:20:42 <Quadrescence> But this is easy to conceptualize
17:20:48 <Baughn> Quadrescence: Let's go back a bit. Why do you want to store anything to disk?
17:20:55 <Quadrescence> For future use
17:21:06 <Baughn> What future use?
17:21:15 <Quadrescence> Solving a puzzle optimally.
17:21:18 <Baughn> Will you be re-using nodes you've already visited, or visiting all new ones?
17:21:19 <MyCatVerbs> Toxaris: storing infinite data structures on disk, I mean. Just interrupt the program in it appears abd serialize it's registers, stack and memory mappings. If that's too much trouble just use an off-the-shelf virtualization product with migration, and abuse the migration code to serialize the whole OS state. :)
17:21:30 <MyCatVerbs> s/abd/and/
17:21:35 <MyCatVerbs> Toxaris: easy! See? :D
17:21:44 <Baughn> MyCatVerbs: Stop it!
17:21:57 <Toxaris> MyCatVerbs: this is not lisp.
17:21:57 <Baughn> MyCatVerbs: I'm working on a /limited/ version of that. THeoretically; I'm not getting far.
17:22:05 <Baughn> Just serializing thunks /at all/ is insanity
17:22:19 <Baughn> And here you go calling it "easy"..
17:22:27 <MyCatVerbs> Baughn: but it is.
17:22:40 <Baughn> MyCatVerbs: Sure, just wrap up the state of the world along with your program
17:22:43 <MyCatVerbs> Baughn: it's just that we can't interpret them in any meaningful way other than to "resume" them.
17:22:46 <MyCatVerbs> Baughn:
17:22:49 <Quadrescence> Baughn: Initially, when I create a node at depth p, and I create a node at depth q > p, I want to ignore that node at q. In fact, erase it.
17:22:57 <MyCatVerbs> Baughn: precisely! That is exactly the solution. :)
17:23:04 <Quadrescence> (oh, both nodes have the same value)
17:23:25 <Baughn> MyCatVerbs: I'd like to serializ thunks to a bit less than five gigabytes, if you don't mind. ;_;
17:23:45 <Baughn> Quadrescence: Laziness.
17:23:55 <MyCatVerbs> Baughn: oh, it isn't that bad.
17:24:24 <MyCatVerbs> Baughn: you only have to serialize the mapped pages, (if you're doing it on a per-process basis) not the whole address space.
17:24:32 <Baughn> MyCatVerbs: If I can't get a thunk down to the size of its paramters, a function pointer and a symbol table (transferred once), I'm doing something wrong
17:24:53 <MyCatVerbs> Baughn: pffff. You're just jonesing after an O(1) factor anyway.
17:25:03 <Baughn> I'm talking "eight-sixteen bytes" here, not even kilobytes
17:25:18 <MyCatVerbs> Baughn: yeah, and? My method is still bounded by the size of the universe :D
17:25:35 <Baughn> MyCatVerbs: I'll be sure to tell that to my cellphone vendor when they try to bill me for excessive data use
17:25:44 <Toxaris> my understanding so far is: we have some data type T, and a bunch of functions which modify T, i.e. a list [T -> T]. Now we generate the tree resulting of applying these functions iteratively, similiar to iterate does for a single function, e.g. data Tree a = Tree a [Tree a] and tree root fs = Tree root (map (tree . ($ root)) fs).
17:26:23 <MyCatVerbs> Baughn: don't. Just apply asymptotic analysis to your finances and watch your worries all fade into insignificance. :D
17:28:01 <Toxaris> Quadrescence: correct so far?
17:28:23 <Quadrescence> Toxaris: Yes. I know I want to do this breadth first. And if I come to a matching value from a lower depth, I want to stop at that node and not continue it.
17:28:32 <Quadrescence> (not continue THAT node)
17:28:44 <Quadrescence> And keep doing that until there are no more nodes to continue.
17:28:51 <mar77a> > null $ filter (>10) [5,6,7]
17:28:53 <lambdabot>  True
17:29:00 <mar77a> > not null $ filter (>10) [5,6,7]
17:29:01 <lambdabot>  Couldn't match expected type `Bool'
17:29:06 <mar77a> > not $ null $ filter (>10) [5,6,7]
17:29:08 <lambdabot>  False
17:29:11 <mar77a> > not $ null $ filter (>10) [5,6,7,15]
17:29:13 <lambdabot>  True
17:29:24 <Baughn> > any (>10) [1..5]
17:29:28 <lambdabot>  False
17:29:41 <Baughn> > any (>10) [1..]
17:29:43 <lambdabot>  True
17:29:51 <Toxaris> Quadrescence: sounds for me like you want a function prune :: Tree a -> Tree a which cuts away some subtrees so that afterwards all stored a's are unique
17:30:01 <newsham> > all (>10) [30..]
17:30:11 <lambdabot>  Exception: Time limit exceeded
17:30:24 <Quadrescence> Toxaris: But the tree can be infinite if not terminated. :<
17:30:46 <Toxaris> Quadrescence: because T is infinite?
17:31:09 <Toxaris> Quadrescence: the infinite size of the tree is no problem because of laziness, as long as you never actually traverse it
17:31:33 <Quadrescence> No. Think of a cube again. If we turn one side, we could create a "tree" with one branch per node.
17:31:59 <mar77a> > filter (>10) [1..25]
17:32:01 <lambdabot>  [11,12,13,14,15,16,17,18,19,20,21,22,23,24,25]
17:32:20 <Toxaris> Quadrescence: such trees are called list :)
17:32:26 <Quadrescence> It would look like 000->001->002->003->000->001->002->....
17:32:31 <Quadrescence> I know I know.
17:33:15 <Quadrescence> And we see 001, so if we see it again, we stop the tree.
17:33:30 <Quadrescence> So it would then look like 000->001->002->003->000.
17:33:43 <Quadrescence> same with 000 too
17:33:48 <Quadrescence> So it would then look like 000->001->002->003.
17:33:53 <mar77a> > [x, x <- [1..25], (>10)]
17:33:54 <lambdabot>  Parse error at "<-" (column 7)
17:34:01 <mar77a> > [x, x <- [1..25] | (>10)]
17:34:01 <Quadrescence> And then the program stops making the tree.
17:34:02 <lambdabot>  Parse error at "<-" (column 7)
17:34:04 <mar77a> errrrr
17:34:14 <mar77a> > [x | x <- [1..25] , (>10)]
17:34:16 <lambdabot>      The section `(> 10)' takes one argument,
17:34:16 <lambdabot>     but its type `Bool' has non...
17:34:17 <thoughtpolice> > [ x | x <- [1..25], x > 10 ]
17:34:18 <lambdabot>  [11,12,13,14,15,16,17,18,19,20,21,22,23,24,25]
17:34:34 <mar77a> > [x|x<-[1..25],x>10]
17:34:34 <Quadrescence> thoughtpolice: That was doubleplusgood
17:34:36 <lambdabot>  [11,12,13,14,15,16,17,18,19,20,21,22,23,24,25]
17:34:45 <Toxaris> Quadrescence: obviously, *before* prune, the tree will be infinite (there will be no leaves at all!), but after prune, the tree is smaller. wether it will be finite or not depends on which node values are in the tree. if T (the type of node values) is finite, there can only be finitely many nodes, so the tree will be always finite
17:34:46 <thoughtpolice> Quadrescence: I'm aware. :)
17:35:25 <Quadrescence> Toxaris: Not if we have modular arithmetic
17:35:34 <Quadrescence> or subtraction, or whatever
17:35:47 <Toxaris> Quadrescence: ?
17:35:58 <Quadrescence> The values at the nodes will never grow past a certain value.
17:36:01 <Quadrescence> Look at my example above
17:36:16 <Quadrescence> 000->001->002->003->000->001->002->....
17:36:22 <Quadrescence> So it would then look like 000->001->002->003->000.
17:36:26 <Quadrescence> So it would then look like 000->001->002->003.
17:36:29 <Toxaris> Quadrescence: look at my abstract description :)
17:36:53 <dons> dcoutts: that's annoying, i generated my alex files offline, but cabal on hackages tries to run alex anyway, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/bytestring-lexing
17:36:54 <Toxaris> Quadrescence: if we have modular arithmetic, we have less values, so the tree is even smaller, so it is even more likely to be finite.
17:36:54 <lambdabot> Title: HackageDB: bytestring-lexing-0.1.0.1, http://tinyurl.com/5ppmod
17:36:56 <Quadrescence> Well, you said if T is finite, there will be a finite number of nodes
17:37:21 <Toxaris> Quadrescence: *after prune*
17:37:56 <Quadrescence> Ahhh, okay
17:39:07 <Toxaris> so you want to generate the whole pruned tree and store it to disk, so that at some later point in time, another program can read it in and use it for whatever. i.e., you want to cache it.
17:39:47 <Quadrescence> Well, it will all be in the same program. But yeah.
17:40:41 <Toxaris> for prune, you basically need a fast "set of T" implementation.
17:41:04 <Toxaris> and some breadth-first-traversal, there is a nice trick with lists of nodes on the same level
17:41:53 <Quadrescence> When you say "set of T"
17:41:55 <Toxaris> and for storing, you may need a binary format, since storing millions of elements as text may be too slow
17:42:05 <Quadrescence> Do you mean all the values to 'search' for?
17:42:19 <Toxaris> all the values you have already seen
17:42:21 <Quadrescence> I am storing them as integers.
17:43:10 <Toxaris> in the end, do you need this tree, or do you need a mapping T -> path?
17:43:20 <Quadrescence> The path.
17:43:36 <Quadrescence> Well, the paths.
17:43:45 <Toxaris> so the idea is the answer questions of the form "given this integer, find the shortest path from the root to a node containing it"?
17:44:16 <Quadrescence> Exactly. Or shortest paths, based on depth.
17:45:04 <mfp> I was playing with the na√Øve CSV parser; profiling says that 66% of the time is spent here ->  http://hpaste.org/9039  am I doing something silly?
17:45:17 <Toxaris> so maybe you should store this mapping, as a hash-table or fingertree or whatever, instead of the actual tree
17:45:33 <Toxaris> then you avoid searching the pruned tree again and agai
17:47:19 <Toxaris> why is there no package for such basic searching stuff?
17:47:25 <Toxaris> maybe there is, I have no clue
17:47:31 <Quadrescence> I have some tabs open.
17:47:42 <Quadrescence> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/heap
17:47:43 <lambdabot> Title: HackageDB: heap-0.3
17:47:48 <Quadrescence> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/bktrees
17:47:49 <lambdabot> Title: HackageDB: bktrees-0.2.1, http://tinyurl.com/5fhdbl
17:47:56 <Quadrescence> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/multiset
17:47:57 <lambdabot> Title: HackageDB: multiset-0.1, http://tinyurl.com/6y34r9
17:48:09 <Quadrescence> That's all I thought might be useful.
17:48:24 <Quadrescence> (actually I had more, but I didn't think they would be exactly what's needed)
17:49:24 <mfp> is  insert k (v : findWithDefault [] k m) m  in a Map supposed to be slow?
17:49:53 <Toxaris> mfp: I guess it searchs the k two times
17:50:43 <schme> good night
17:50:45 <mfp> hmm yeah insertWithKey might be faster /me tries
17:51:01 <Toxaris> mfp: maybe you want insertLookupWithKey?
17:51:53 <Toxaris> mfp: no, you want alter
17:52:09 <Toxaris> mfp: that's the "all-at-once" function
17:52:19 <Toxaris> or whatever :)
17:52:40 <mfp> all-in-one heh  thanks
17:53:49 <Toxaris> Quadrescence: a nice trick in tree processing is to write levels :: Tree a -> [[Tree a]] so that levels root !! n contains all subtrees on level n
17:54:33 <Quadrescence> Not baaaaaaaaadddddddddddddddd
17:55:44 <Toxaris> Quadrescence: I guess you could generalize this idea to scanLevelsFilter :: (acc -> a -> (acc, Bool)) -> whatever
17:56:25 <Toxaris> Quadrescence: i.e., thread an acc through (your integer-to-path mapping) and return False in case you don't want to include this subtree
17:56:39 <Toxaris> but I have no clue how good that scales
17:56:45 <mfp> Toxaris: much faster indeed, thanks again
18:05:05 <Quadrescence> Toxaris: http://rafb.net/p/kbBkd283.txt
18:05:30 <Quadrescence> That's the general outline of what I want to implement, I guess, if that makes anything easier/more clear.
18:05:53 <dogbite> hi, newbie question, but why is it that some packages such as
18:05:55 <dogbite> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/bytestring-lexing
18:05:56 <lambdabot> Title: HackageDB: bytestring-lexing-0.1.0.1, http://tinyurl.com/5ppmod
18:06:04 <dogbite> don't link to an API
18:06:10 <dogbite> from the exposed modules
18:06:49 <Toxaris> dogbite: API documentation is lazily created at some later point after upload, and bytestring-lexing is quite new
18:07:06 <dolio> That was just posted today.
18:07:16 <dogbite> Toxaris: okay, i will be patient, heh
18:07:26 <dolio> Oh, and there's a build failure.
18:07:49 <dolio> That'll probably cause the docs not to be generated.
18:07:50 <Toxaris> hehe probably a more serious reason :)
18:08:35 <Toxaris> dogbite: you can always download it and build the docs. but maybe you should wait until dons does something about the build failure
18:08:36 <dons> dolio: it looks like hackage used a version of cabal that caused alex to fail.
18:08:47 <dons> dogbite: so just cabal install it yourself. i'll post the docs..
18:09:42 <Toxaris> Quadrescence: is this homework, toy or serious?
18:09:50 <Quadrescence> Toy
18:10:00 <Quadrescence> I did not write that above.
18:10:01 <dons> dogbite: http://code.haskell.org/~dons/docs/bytestring-lexing/
18:10:02 <lambdabot> Title: bytestring-lexing-0.1.0.1: Parse literals efficiently from bytestrings
18:10:15 <Quadrescence> (I did change words to make it more understandable)
18:10:26 <Toxaris> Quadrescence: the text doesn't tell about storing on disk
18:10:47 <Saad_> I guess I might aswell ask again since last time noone replied, my question would be is there a library to get webcam feed for haskell? :)
18:10:49 <dons> dogbite: note, i don't have your 160k test file, so i've been using a 50M file of doubles, and a 250k .csv file
18:10:53 <Quadrescence> I know, that's just...about the creation of the database if you want to call it that
18:11:17 <Toxaris> Quadrescence: Database == bunch of data, somewhat structured
18:11:26 <Quadrescence> Again, it's not like I have specific instructions.
18:11:29 <Toxaris> Quadrescence: no reason to store it on a rotating metallic cylinder
18:11:31 <Quadrescence> This isn't an exercise
18:12:03 <Quadrescence> Toxaris: Again, that's just kind of what it's about, I guess. :/
18:12:21 <Toxaris> hehe yeah it just sounds so strange to store huge amount of data which can be easily regenerated
18:12:22 <hackage> Uploaded to hackage: bytestring-csv 0.1
18:12:43 <dcoutts> dons: aye, hackage has an older version of alex without the bytestring wrapper
18:12:53 <Quadrescence> Toxaris: Let me get some numbers for you.
18:12:58 <Toxaris> but maybe it is not so easily :)
18:12:58 <dons> well, that's fine. its just that cabal tries to run alex, even if i've included the .hs already.
18:13:03 <dons> dcoutts: but it works locally.
18:13:48 <dcoutts> dons: hmm
18:14:07 <dcoutts> dons: did you use cabal sdist to make the tarball? it should put the .hs in the right place.
18:14:38 <dogbite> dons: thanks for posting the new packages
18:14:41 <dons> oh. no, darcs dist.
18:14:52 <dcoutts> dons: well there you go :-)
18:14:55 <dons> dogbite: note the csv parser doesn't do nested quotes yet, but it does seem to be fast.
18:14:58 <dogbite> dons: could you please link me to the csv parsing code too?
18:15:02 <dons> yep.
18:15:15 <dons> dogbite: if you could give me a test file, that'd help a lot too :)
18:15:22 <dcoutts> dons: it does not look in src/blah.hs for the pre-processed version, it looks in dist/build/blah.hs
18:15:31 <dons> ah
18:15:33 <dogbite> dons: okay i can send you a file off-line
18:15:40 <dons> dcoutts: i was hoping it would ignore the .x file
18:15:40 <dcoutts> dons: cabal sdist ftw!
18:15:59 <dons> would cabal sdist put the preprocessed .hs ready for all to use?
18:16:05 <dcoutts> dons: it can't ignore it because that's the source version and the pre-processed version does not exist
18:16:16 <dcoutts> dons: yes it does
18:16:31 <dcoutts> dons: if you configure first at least
18:16:34 <dons> ok.
18:16:48 <O_4> Hmm.  So why is '<-' used to bind values from actions, rather than '='?
18:17:13 <O_4> The compiler will know what functions are actually actions, so it seems unnecessary
18:17:29 <O_4> Except to make it clearer to the programmer
18:17:51 <dons> it makes it clearer for the programmer :)
18:17:59 <O_4> That's the only reason?
18:18:07 <dolio> Is that a bad reason?
18:18:18 <O_4> Probably not
18:19:40 <dons> dogbite: http://code.haskell.org/~dons/docs/bytestring-csv/
18:19:41 <lambdabot> Title: bytestring-csv-0.1.1: Parse CSV formatted data efficiently
18:19:45 <dons> new version also uploaded to hackage.
18:19:53 <monochrom> <- makes much more sense than = for that purpose.
18:20:02 <O_4> So then is there a difference in behaviour between executing a function and an action?  (I'm talking about from outside the function is question)
18:20:17 <dons> dogbite: there's examples in the docs for both libraries. see examples/Test.hs for .csv files
18:21:38 <dogbite> dons: okay, i sent you the file
18:22:01 <dons> thanks
18:22:44 <dons> ok, so about 10M. let's see...
18:22:59 <O_4> Aside from the fact that the action might return different values each time it executes, I mean.
18:23:07 <dolio> With 'x = e' x is a name for the expression/value e. With 'x <- e' x is the name for the value produced by running the computation e.
18:24:10 <dons> dogbite: cool, 2.03s to process the file here (just uniq'ing the first field of the whole file)
18:24:48 <dons> i used this little program, http://hpaste.org/9040
18:25:19 <dons> now, your benchmark needed a custom data type for  the rows, and some readDouble parsing.
18:25:29 <dons> I don't think that'll add significant overhead, hopefully
18:25:31 <dogbite> dons: the best i did on my machine was 1s
18:25:34 <O_4> dolio: ok, so all the '<-' is really warning you of is that the value might differ between each evaluation.
18:26:17 <dolio> I guess. <- is just part of do syntax, which is not the same as declaration syntax.
18:26:17 * dons goes back to remember what the problem was again.
18:26:29 <dogbite> dons: i will check out your program in a bit.  can't do it tonight but really lookin forward to it.
18:26:38 <dons> dogbite: what fields did you need, again?
18:26:57 <dons> the first (title), then 2nd and 3rd as Double?
18:27:23 * dons tries just pulling out 2 and 3, parsing 
18:27:38 <dogbite> dons: also need the time stamps
18:27:43 <dolio> I wouldn't even think in terms of 'x <- e' because that's not defined on its own.
18:27:48 <dogbite> dons: i just sort those in byte order at the moment -- which is fortunate because of their format
18:27:48 <dons> dogbite: just as strings?
18:27:53 <dons> ok.
18:28:15 <dolio> What's defined is "do x <- e ; e'", which is desugared to "e >>= \x -> e'".
18:28:30 * monochrom does not like how C has inspired everyone to abuse and hijack =
18:28:30 <dolio> Assuming x is just a variable.
18:28:50 <cjb> monochrom: how did C do that?
18:28:57 <monochrom> x = x + 1;
18:29:15 <cjb> Oh.  That's a pretty fundamental hijacking.  I thought you meant operator polymorphism.  :)
18:29:28 <dolio> That'd be C++.
18:29:32 <cjb> Right.
18:31:19 <dolio> I suppose strictly speaking it desugars to "e >>= \x -> do e'", since e' might contain do-syntax-specific stuff.
18:31:44 <dolio> And then you recursively desugar "do e'"
18:31:49 <monochrom> Many calculus students do a related thing.  They write like "(x + 1)^2 = 2*(x+1) -> 2x+2".  Do you see what they mean?  Where they mean equal, they deliberately avoid =; where they mean anything other than equal, they deliberately say =.
18:32:25 <monochrom> It seems universal for mediocre people to completely negate the use of =.
18:33:13 <dons> dogbite: yeah, results seem good. with the 10M file I'm getting about 2 seconds to parse the full file, and convert all the fields to Double.
18:33:17 <dons> in 4 lines of code :)
18:33:29 <dolio> monochrom: Wait, what is that quote supposed to mean?
18:33:49 <monochrom> The derivative of (x+1)^2 is 2*(x+1); the latter equals 2x+2.
18:33:58 <dons> dogbite: there you go, http://hpaste.org/9041
18:34:02 <dolio> Oh.
18:34:04 <dons> i'm pretty happy with performance/conciseness.
18:35:14 <mfp> dons: would that be faster than the ad-hoc parsing done before (barring the strtod FFI overhead)?
18:35:54 <dons> i'd imagine it would be about the same.
18:36:20 <dons> though now we're using an alex-generated csv parser, and a correct strtod double parser from libraries. so 10x less code :)
18:36:30 <dons> e.g.
18:36:31 <dons> mapM_ ppr [ T (parse a) (parse b) c d | [_,a,b,_,c,d] <- csv ]
18:36:31 <dons>  where
18:36:31 <dons>     parse = fst . fromJust . readDouble
18:36:35 <dons> *much* nicer.
18:38:38 <mfp> well  parseRow :: BS.ByteString -> Maybe Row  took 7 lines, is the new code a fraction of a line? ;)
18:40:53 <dons> r <- parseCSV `fmap` S.readFile f
18:40:53 <dons>  ?
18:41:06 <dons> http://hpaste.org/9041
18:41:42 <mfp> doesn't this one count too?  Just csv -> mapM_ ppr [ T (parse a) (parse b) c d | [_,a,b,_,c,d] <- csv ]
18:42:24 <dolio> It also counts as code that parses the entire file into lines, too.
18:43:50 <dolio> The row code is more like the list comprehension.
18:44:00 <dons> i'm not sure what your point is , mfp?
18:44:18 <dons> isn't it clearly shorter, now that readDouble and csv are both bytestring-ready and in libs...
18:44:21 <dolio> Although it doesn't do the exact same thing as the original. You could get there with the Maybe applicative functor, though.
18:44:33 <mfp> dons: ignore the above, it was just a just a ;)
18:45:18 <dons> the other nice thing is that alex can now generate lexers for strict bytestrings
18:47:22 <mfp> going through parseCSV is slower than defining the parser in terms of the new strtod parser and other BS functions directly, right? (because you first get the bytestring list and then operate on it)
18:48:55 <dolio> That depends on whether the alex-based parser is slower than 'map BS.split ',' . BS.lines'.
18:49:40 <dolio> Does the CSV parser properly handle quoted fields and such?
18:54:44 <mfp> dolio: even given the extra allocation for the intermediate strings? Note that I'm not comparing it to BS.split ',', but to a parser defined with functions like readInt.
18:56:00 <noecksit> is there a function like python's strip() that strips whitespace from strings?
18:56:26 <dolio> Well, I don't know how the parser works, but if it's not doing quoted fields, then intermediate strings are probably just substrings, which is just two ints, not copying entire strings.
18:58:30 <noecksit> @info stripPrefix
18:58:31 <lambdabot> stripPrefix
18:58:40 <noecksit> @src stripPrefix
18:58:41 <lambdabot> Source not found. Just try something else.
19:00:19 <dolio> It's probably faster if you hand-code it specifically for whatever format you expect, but that will also be more work.
19:00:29 <noecksit> hmm, it seems that I don't have stripPrefix, probably needs ghc greater than 6.6.1
19:01:26 <dons> mfp: yeah, you might want to register some action with the parser
19:01:33 <dons> at least it takes substrings without copying
19:02:01 <dons> but it's still: ByteString -> Item ByteString -> ByteString -> Double, i.e. a couple of constructors in the way
19:02:13 <dons> the underlying ByteStrings aren't copied though, which is good.
19:03:08 <dolio> Of course, you'll instead get complaints that you aren't "really parsing CSV." :)
19:03:32 <mfp> the original python code wasn't either
19:03:58 <dolio> Their CSV library does, though, I assume.
19:05:01 <mfp> yeah, but it's not the code that was timed. As for the CSV parser, I suppose it's implemented in a C extension for speed. (?)
19:05:41 <dolio> I think that was said, yes. It's a binding to a C CSV library.
19:09:10 <dons> well, we're pretty close to parsing CSV... there's a lexer and a parser involved.
19:09:25 <dons> all that remains is un-doublequote fields.
19:10:12 <dolio> It already parses "foo, bar" as a single field?
19:10:54 <dolio> And "foo\nbar"?
19:12:23 <hackage> Uploaded to hackage: bytestring-lexing 0.1.0.2
19:12:23 <hackage> Uploaded to hackage: bytestring-csv 0.1.1
19:18:13 <Cale> dons: Are you running the hackage bot?
19:18:41 <Cale> dons: I think it would be cool if it linked to the new packages when it announced them.
19:22:42 <dons> i'll have to tweak it. by default is just is configured from the command line
19:33:17 <atp> sigh
19:33:22 <atp> bytestrings can really be a pain in the ass
19:33:30 <atp> i mean working with them
19:35:22 <atp> it's a brilliant library, don't get me wrong
19:35:35 <atp> but i think we really need to do some work to get it integrated properly
19:39:14 <dolio> Like what?
19:40:32 <dons> atp, maybe you're missing the usual idioms?
19:51:34 <Trinithis> I'm having a difficult time compiling the code from https://www.cs.indiana.edu/~adamsmd/papers/scrap_your_zippers/ScrapYourZippers.pdf ... Has anyone read this pdf?
19:51:35 <lambdabot> Title: Functional Pearl: Scrap Your Zippers, http://tinyurl.com/5wu97v
19:53:06 <Trinithis> I'm getting a "GADT pattern match in non-rigid context error" in http://hpaste.org/9042
19:54:52 <dolio> Some function that uses GADTs needs a type signature.
19:56:28 <Trinithis> oh
20:00:46 <zachk> @src map
20:00:46 <lambdabot> map _ []     = []
20:00:46 <lambdabot> map f (x:xs) = f x : map f xs
20:01:28 <zachk> @src fmap
20:01:29 <lambdabot> Source not found. Do you think like you type?
20:02:36 <Cale> zachk: fmap is a typeclass method, it's implemented in each instance
20:02:48 <Cale> @src (->) fmap
20:02:49 <lambdabot> fmap = (.)
20:02:55 <Cale> @src Either fmap
20:02:56 <lambdabot> fmap _ (Left x) = Left x
20:02:56 <lambdabot> fmap f (Right y) = Right (f y)
20:03:09 <Cale> @src [] fmap
20:03:09 <lambdabot> fmap = map
20:03:15 <Cale> @src Maybe fmap
20:03:16 <lambdabot> fmap _ Nothing       = Nothing
20:03:16 <lambdabot> fmap f (Just a)      = Just (f a)
20:03:26 <Cale> @src (,) fmap
20:03:27 <lambdabot> fmap f (x,y) = (x, f y)
20:04:44 <zachk> @src (+) fmap
20:04:44 <lambdabot> Source not found. You type like i drive.
20:05:57 <Cale> The @src plugin indexes the instances by the type constructor.
20:08:20 <pcapriotti> why Monad is not a subclass of Functor?
20:09:06 <MyCatVerbs> pcapriotti: don't know. Can't think of any particularly brilliant reason, personally.
20:09:20 <Cale> pcapriotti: yeah, no good reason
20:09:55 <MyCatVerbs> pcapriotti: basically the same reason as why the numerical stuff is laid out the way it is, specifically: very nearly totally by accident. ;)
20:10:16 <pcapriotti> I see
20:10:37 <pcapriotti> thanks
20:11:37 <MyCatVerbs> pcapriotti: it's just that it was done that way a long time ago, and to change it now would break loads of code. Ah well.
20:13:04 <pcapriotti> of course
20:21:10 <zachk> is there a $ going the other way, the direction of the unix pipe | ?
20:22:01 <Trinithis> you can try sectioning it : ($ x)
20:22:16 <Trinithis> err... rather (x $)
20:22:33 <Cale> zachk: I don't recommend chaining multiple $'s by the way. You can always use . in place of all but the last one, to compose functions instead. The advantage of this is that function composition is an associative operation, and so it makes code a little easier to work with.
20:22:55 <Cale> In Control.Arrow, there's >>> which is function composition, but in the other order.
20:23:04 <Cale> (when using the (->) arrow)
20:23:50 <Trinithis> is there an easy way to bypass a type request when using GADTs?
20:24:09 <Cale> Type request?
20:24:39 <Trinithis> I can't for the life of me get this code to compile. I'm stuck on the error it gens in this code: http://hpaste.org/9042
20:26:01 <atp> argh
20:26:12 <atp> why does ghci not properly deal with OverloadedStrings?!
20:29:58 <TomMD> atp: A complete hack job, but I usually define 'pk'.  I guess I should just put it in my .ghci config file.
20:29:58 <TomMD> pk :: String -> ByteString = L.pack . map (fromIntegral . fromEnum)
20:30:48 <atp> TomMD: i already have fromString
20:31:10 <atp> TomMD: also, you might consider using Data.ByteString.Internal.c2w instead of fromIntegral . fromEnum
20:31:21 <atp> TomMD: it's faster :)
20:31:57 <TomMD> atp: If what I do takes too long I try to avoid using GHCi and go for compiled tests, but my uses probably aren't normal.
20:32:35 <TomMD> but thanks for the pointer, btw.
20:32:40 <atp> TomMD: i like my repl :p
20:33:16 <dolio> @type BSLC.pack
20:33:16 <lambdabot> [Char] -> BSLC.ByteString
20:33:28 <TomMD> @where BSLC
20:33:29 <lambdabot> I know nothing about bslc.
20:33:31 <TomMD> bslc?
20:33:43 <dolio> Data.ByteString.Lazy.Char8
20:35:37 <atp> is there a reason that ByteStrings was not written polymorphically and then specialized?  i'd really like to have wordstrings
20:49:15 <zachk> whats Integer exponenation its not ^ its not ** its...
20:50:04 <Quadrescence> ^^
20:50:09 <Quadrescence> (^^)
21:00:38 <|Steve|> @type (^^)
21:00:53 <lambdabot> thread killed
21:00:58 <|Steve|> ...
21:01:29 <dons> @type (^^)
21:01:31 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
21:01:58 <|Steve|> @type (^)
21:02:01 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
21:02:41 <|Steve|> So in one the base is any type of Num and in the other it's restricted to a fractional?
21:06:53 <dons> yeah
21:07:02 <|Steve|> Seems odd.
21:07:34 <|Steve|> @src (^^)
21:07:34 <lambdabot> x ^^ n      =  if n >= 0 then x^n else recip (x^(negate n))
21:07:38 <|Steve|> Especially in light of that.
21:07:50 <dons> (^) is the machine level one.
21:08:26 <dolio> > 2^(-5)
21:08:41 <lambdabot>  thread killed
21:08:59 <dolio> (^) doesn't do negative exponents.
21:09:25 <zachk> > 2^^(negate 5)
21:09:27 <|Steve|> Ah, so I see.
21:09:27 <lambdabot>  3.125e-2
21:09:39 <dolio> Since nums don't necessarily have division/multiplicative inverses.
21:09:45 <zachk> thats kind of icky
21:10:54 <dolio> It'd probably be better if it were (Num a) => a -> Natural -> a or something, but there's no natural in the libraries.
21:15:26 <zachk> why would they still this word from category theory "Windows PowerShell, formerly code-named Monad, is an interactive command-line"
21:15:30 <|Steve|> Since Haskell people seem to like CT so much, maybe there should be some class hierarchy containing magmas, semigroups, monoids, groups, rings, fields.
21:15:42 <Zao> zachk: Because it's remotely functional or something?
21:16:19 <dolio> Isn't that more algebra than category theory?
21:16:27 <dolio> Not that the two are unrelated.
21:16:59 <|Steve|> I suppose it is, but I tend to think of CT as part of algebra.
21:17:26 <dolio> There is a "numeric prelude" with a much finer grained hierarchy of that type of stuff.
21:17:38 <dons> yeah, most of those are in  the numeric-prelude or numeric-quest, iirc
21:17:58 <dons> and category-extras has a bunch of concepts
21:19:29 <dolio> Although I'm not wild about the Foo.Bar.T and Foo.Bar.C way the numeric prelude does things.
21:19:34 <|Steve|> I see.
21:21:55 <zachk> would it be legal for microsfot to clean room engineer Gnu readline and just give it away under a bsd style license?
21:22:06 <Trinithis> I simplified a problem I had earlier, and I was wondering if someone could figure out the type signature of a very simple function in http://hpaste.org/9043
21:22:19 <|Steve|> zachk: You mean like libedit?
21:22:22 <Zao> zachk: I can't quite see the Haskell relevance.
21:22:36 <zachk> cabal install yogurt doesnt work
21:22:50 <dolio> Aren't there multiple non-GPL line editing libraries?
21:22:58 <dolio> Someone announced a pure-Haskell one not too long ago.
21:23:25 <^Someone^> :)
21:23:35 <|Steve|> And there he is.
21:23:49 <^Someone^> Wasn't me, must've been an imposter
21:23:55 <dolio> Heh.
21:24:12 <dolio> @hackage haskeline
21:24:12 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/haskeline
21:27:31 <Trinithis> nevermind. I just got it
21:30:34 <Toxaris> Trinithis: fromLeftCons :: Left (c -> b) a -> (Left c (b -> a), b)
21:30:48 <Trinithis> Toxaris: thx
21:30:59 <Toxaris> hmm too late?
21:31:14 <Trinithis> by a little, but thx anyway
21:36:13 <atp> can anyone think of a way to write a function that replaces consecutive ints with the first one in the series, lazily, on a list of ints, *without* resorting to direct recursion?
21:36:27 <atp> ie, [5, 6, 8, 10, 11, 13] -> [5, 8, 10, 13]
21:36:45 <atp> does this need to be a paramorphism?
21:37:36 <atp> at first i thought something using zip `ap` tail might work, but it has wacky edge cases with finite lists
21:39:01 <atp> obviously one using direct recursion is trivial to implement
21:39:22 <zachk> so [5,6,7,8,10,11,13,14]->[5,10,13]
21:39:29 <atp> right
21:39:43 <atp> so i thought you could do something with
21:39:54 <atp> > zip `ap` tail $ [5,6,7,8,10,11,13,14]
21:40:05 * atp pokes lambdabot.
21:40:10 <lambdabot>  thread killed
21:40:21 <atp> > zip `ap` tail $ [5,6,7,8,10,11,13,14]
21:40:28 <lambdabot>  [(5,6),(6,7),(7,8),(8,10),(10,11),(11,13),(13,14)]
21:42:41 <jbapple> I miss buddha.
21:42:48 <jbapple> @google buddha haskell
21:42:48 <lambdabot> http://www.cs.mu.oz.au/~bjpop/buddha/
21:42:48 <lambdabot> Title: A declarative debugger for Haskell 98
21:43:11 <jbapple> The GHCi debugger is sometimes godawful confusing
21:47:16 <jbapple> Buddha was so simple -- like going to the optometrist: "Which is buggy: A or B? A or B?"
21:49:27 <dons> port buddha to ghci?
21:53:47 <jbapple> A wonderful idea.
21:54:05 <jbapple> had I only the time  . . .
21:54:38 <atp> zachk: i think i've got it!
21:54:41 <atp> > let ct = map snd . dropWhile (\(x,y) -> x + 1 == y) . (zip `ap` tail) ; sc = unfoldr (\b -> if null b then Nothing else Just (head b, ct b)) in sc [5,6,7,8,10,11,13,14]
21:54:50 * atp waits for lambdabot
21:54:57 <lambdabot>  thread killed
21:55:03 <atp> what's up with lambdabot today
21:55:06 <atp> > let ct = map snd . dropWhile (\(x,y) -> x + 1 == y) . (zip `ap` tail) ; sc = unfoldr (\b -> if null b then Nothing else Just (head b, ct b)) in sc [5,6,7,8,10,11,13,14]
21:55:22 <lambdabot>  thread killed
21:55:49 <atp> is there a way to get lambdabot to restart or something, something seems to be wrong with her
21:56:07 <dibblego> > 1
21:56:15 <lambdabot>  1
21:56:21 <chrisdone> @uptime
21:56:21 <lambdabot> uptime: 3d 5h 45m, longest uptime: 1m 10d 23h 44m 29s
21:56:30 <atp> > let ct = map snd . dropWhile (\(x,y) -> x + 1 == y) . (zip `ap` tail) ; sc = unfoldr (\b -> if null b then Nothing else Just (head b, ct b)) in sc [5,6,7,8,10,11,13,14]
21:56:31 <lambdabot>  [5,10,13]
21:56:35 <atp> woohoo!
21:56:46 <atp> look at that higher-order point-free goodness
21:57:02 <chrisdone> are those called triangle numbers or whatnot?
21:57:24 <atp> chrisdone: no, it just strips the consecutive numbers out, replacing each consecutive subsequence with its head
21:57:47 <chrisdone> oh, so it does
21:57:48 <atp> i had written a version using direct-recursion
21:58:09 <atp> and couldn't see how to write it in terms of higher-order recursion schemes
21:58:15 <atp> i guess it's an anamorphim
21:58:19 <atp> anamorphism
21:58:32 <atp> well
21:58:36 <atp> hm
21:58:46 <atp> i guess map snd . dropWhile ... is a catamorphism
21:58:58 <atp> so it's a hylomorphism within an anamorphism?
21:59:03 <atp> where's edwardk when you need him
22:00:55 <atp> this actually has something of a real use... i want to use ByteString.findIndices to find all the spaces in a very big bytestring lazily, but i want to glob consecutive whitespace
22:01:38 * atp hugs haskell.
22:10:21 <atp> :e
22:10:35 <Trinithis> what
22:11:20 * Trinithis ghc haskell
22:11:33 <johnnowak> > (map snd . filter fst . (zip =<< map (uncurry (flip flip 1 . ((/=) .) . subtract)) . (zip `ap` tail) . ((:) =<< head))) [5,6,7,8,10,11,13,14]
22:11:35 <lambdabot>  [5,10,13]
22:11:54 <johnnowak> ...
22:12:02 <atp> hehe
22:12:11 <atp> nice, johnnowak
22:12:39 <atp> obviously i was wrong about zip `ap` tail not being useful in this context, eh?
22:13:18 <atp> i like your use of bind.  groovy.
22:14:07 <johnnowak> > (\xs -> map snd $ filter fst (zip (map (\(x,y) -> y - x /= 1) (zip `ap` tail $ (head xs : xs))) xs)) [5,6,7,8,10,11,13,14]
22:14:08 <lambdabot>  [5,10,13]
22:14:50 <geezusfreeek> :t zip `ap` tail
22:15:03 <lambdabot> forall b. [b] -> [(b, b)]
22:15:16 <geezusfreeek> aha
22:15:16 <atp> zip `ap` tail is just zip xs (tail xs)
22:15:22 <atp> ap is the s combinator
22:15:28 <atp> check this out:
22:15:37 <geezusfreeek> right, i was just being lazy
22:15:47 <atp> > fix $ (zipWith (+)) `ap` tail
22:16:03 <lambdabot>  thread killed
22:16:29 <atp> sigh
22:16:33 <atp> all these threads being killed
22:17:07 <atp> > fix $ (0:) . (1:) . (zipWith (+)) `ap` tail
22:17:09 <lambdabot>      precedence parsing error
22:17:09 <lambdabot>         cannot mix `(.)' [infixr 9] and `ap' [i...
22:17:27 <atp> > fix $ (0:) . (1:) . ((zipWith (+)) `ap` tail)
22:17:28 <atp> is what i meant actually
22:17:29 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
22:17:41 <atp> nice eh!
22:18:28 <HunterXHunter> fib?
22:18:37 <atp> yah
22:18:43 <atp> you like?
22:18:50 * atp hugs fix.
22:18:55 <HunterXHunter> looks good
22:19:17 <atp> i think i spend way too much time going into contortions to avoid direct recursion these days
22:19:18 <atp> hehe
22:19:28 <atp> although i guess fix is pretty much as direct as you can get
22:20:46 <atp> > unfoldr (\(x,y) -> Just (x + y, (y, x + y))) (0, 1)
22:20:47 <lambdabot>  [1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1771...
22:23:26 <atp> > unfoldr (\(x,y) -> Just (x, (y, x + y))) (0, 1)
22:23:28 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
22:23:31 <atp> that's better
22:42:18 <Trinithis> > f(oldr (\(x, y) zs -> if x+1 == y then zs else y : zs) [] . ap zip tail . (\xs -> if null xs then [] else head xs : xs)) [5,6,7,8,10,11,13,14]
22:42:26 <lambdabot>   Not in scope: `oldr'
22:42:28 <Trinithis> > (foldr (\(x, y) zs -> if x+1 == y then zs else y : zs) [] . ap zip tail . (\xs -> if null xs then [] else head xs : xs)) [5,6,7,8,10,11,13,14]
22:42:29 <lambdabot>  [5,10,13]
22:42:52 <Elly> :t ap
22:42:59 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
22:43:18 <Elly> apply for monads?
22:43:24 <Trinithis> yes
22:43:36 <Trinithis> its the same as Applicative's <*>
22:43:38 <geezusfreeek> Elly: also the same as (<*>)
22:43:53 <geezusfreeek> :P
22:45:14 <Trinithis> @pl (foldr (\(x, y) zs -> if x+1 == y then zs else y : zs) [] . ap zip tail . (\xs -> if null xs then [] else head xs : xs))
22:45:15 <lambdabot> foldr (uncurry ((`ap` (:)) . ((ap . if') .) . (==) . (1 +))) [] . ap zip tail . ap (flip if' [] . null) ((:) =<< head)
22:45:54 <johnnowak> @type (:) =<< head
22:45:55 <lambdabot> forall a. [a] -> [a]
22:46:07 <mjrosenb> :t transpose
22:46:08 <lambdabot> forall a. [[a]] -> [[a]]
22:46:16 <Trinithis> > ((:) =<< head) "aasd"
22:46:17 <lambdabot>  "aaasd"
22:46:47 <Trinithis> the function monad rocks
22:47:19 <mjrosenb> wait, what now?
22:47:51 <Trinithis> > transpose ["ab", "cd"]
22:47:52 <lambdabot>  ["ac","bd"]
22:48:11 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
22:48:13 <lambdabot>  ("hello","olleh","HELLO")
22:48:18 <mjrosenb> i know what transpose does, i was just verifying the name
22:48:56 <mjrosenb> now that's pretty sweet
22:49:05 <geezusfreeek> cata (\(x,xs) -> x:xs) $ ana (\(x,y) -> (x, (y, x + y))) (0, 1)
22:49:14 <geezusfreeek> ^ fibonacci
22:49:20 <geezusfreeek> with category-extras
22:49:23 <Trinithis> :t cata
22:49:25 <lambdabot> Not in scope: `cata'
22:49:28 <Trinithis> o
22:49:31 <geezusfreeek> i don't know what a cata composed with ana is
22:49:36 <geezusfreeek> it probably already exists
22:49:38 <mjrosenb> does function MonadPlus, with composition?
22:49:40 <dolio> hylo
22:49:45 <geezusfreeek> thought so
22:50:12 * geezusfreeek looks at that next
22:50:14 <Trinithis> :t (+) `mappend` (*)
22:50:15 <lambdabot> forall a. (Monoid a, Num a) => a -> a -> a
22:50:33 <dolio> But that cata just injects from infinite streams into lists.
22:50:45 <geezusfreeek> right
22:50:49 <mjrosenb> wow, my statement made NO SENSE
22:50:55 <Trinithis> mappend for functions is just composition right?
22:51:07 * mjrosenb wanders off to bed
22:51:08 <geezusfreeek> i'm only just beginning to learn these things
22:51:17 <dolio> No.
22:51:30 <dolio> f `mappend` g = \x -> f x `mappend` g x
22:51:40 <Trinithis> ((+) `mappend` (*)) 3
22:51:43 <Trinithis> > ((+) `mappend` (*)) 3
22:51:44 <lambdabot>  Add a type signature
22:51:49 <dolio> If you want composition, it needs to be wrapped with Endo.
22:51:56 <Trinithis> k
22:53:53 <geezusfreeek> hylo (\(x,xs) -> x:xs) id (\(x,y) -> (x, (y, x + y))) (0, 1)
23:00:28 <geezusfreeek> ah i guess that first function can be replaced with just uncurry (:)
23:09:53 <Apocalisp> can you ask ghci to print back the source of a let binding?
23:11:53 <Apocalisp> gasp!
23:11:56 <Apocalisp>  panic! (the 'impossible' happened)"
23:12:25 <hackage> Uploaded to hackage: HsSVN 0.3.3
23:23:12 <bwr> anyone know how to run the current vim buffer through ghci without replacing the text in the buffer
23:23:23 <bwr> basically i just want a real quick way of loading the code into ghci
23:24:33 <Cale> bwr: hm? Just :load MyFile.hs
23:24:50 <Cale> bwr: Or if the file is already loaded, :r will reload
23:25:35 <bwr> yea, that works
23:25:56 <bwr> i was looking for a way to run it from vim with the contents of the buffer already loaded
23:26:17 <bwr> but it isn't so bad to have another window open :P
23:29:39 <sutats> Why does yi require GUI libraries? Can't it act like vim and run in the terminal?
23:29:53 <bwr> ah, ":!ghci %" works
23:29:59 <bwr> just requires file to be saved
23:30:02 <bwr> which is fine
23:39:42 <misterbeebee__> http://hpaste.org/9045
23:40:38 <misterbeebee__> foldl2' ((+),0) (count,0) --  -- Is there a nicer way to write this, using Monoids or MonadPlus or something?
23:57:24 <dolio> What does that compute? sum &&& length?
23:58:03 <visof> what is "&&&" ?
23:58:17 <dolio> f &&& g = \x -> (f x, g x)
23:58:36 <dolio> Although, strictly speaking, it's an arrow combinator.
