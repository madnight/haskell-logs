00:03:17 <Cale> carl: The problem is that doLogin apparently takes a Socket as a parameter, yet the definition has no such parameter
00:04:07 <carl> yea i know i just worked that out i hate these moments thx neway
00:04:21 <carl> ::smacks head against keyboard::
00:06:43 <kaspyanand> hi all
00:07:30 <kaspyanand> in ghci mode to know type of ++ i have to :type (++) why the parenthesis?
00:11:06 <Cale> kaspyanand: The parentheses turn infix operators into ordinary functions syntactically.
00:11:14 <Cale> > (++) "hello" "world"
00:11:15 <lambdabot>  "helloworld"
00:11:42 <Cale> > zipWith (++) ["a","b","c"] ["1","2","3"]
00:11:43 <lambdabot>  ["a1","b2","c3"]
00:11:54 <xkb> > "hello" '++' "world"
00:11:54 <lambdabot>  Improperly terminated character constant at "'++'" (column 9)
00:11:59 <xkb> ah lol
00:12:14 <Cale> > "hello" ++ "world"
00:12:15 <lambdabot>  "helloworld"
00:12:27 <xkb> used the wrong ticks
00:12:28 <xkb> :)
00:12:44 <Cale> You can go the other way, turning normal function names into infix operators using ` backticks.
00:12:55 <Cale> > 'e' `elem` "hello"
00:12:56 <lambdabot>  True
00:13:05 <Cale> > elem 'e' "hello"
00:13:06 <lambdabot>  True
00:13:19 <xkb> that's what I wanted to show :)
00:19:05 <ski> > (`elem`) 'e' "goodbye"
00:19:05 <lambdabot>  Parse error at ")" (column 8)
00:19:05 <lambdabot> ski: You have 1 new message. '/msg lambdabot @messages' to read it.
00:19:37 <ski> @vixen might i wager that this is the same message you've delivered 2-3 times already ?
00:19:37 <lambdabot> i just turned 19
00:19:45 <ski> good for you
00:19:48 <ski> @messages
00:19:48 <lambdabot> Kamina said 2m 7d 19h 31m 31s ago: I don't agree: Having something of type Maybe (exists a. a) would be useful, you can typecast it to anything, because it can be every type. (Like you can convert
00:19:48 <lambdabot> read "5" to every type being of the "Read" class)
00:20:41 * ski nods very slowly
00:20:48 <dmwit> > ('e' `elem`) "goodbye"
00:20:49 <lambdabot>  True
00:21:04 <dmwit> But more usefully:
00:21:11 <dmwit> > (`elem` "goodbye") 'e'
00:21:12 <lambdabot>  True
00:22:27 <carl> does anyone know how to convert an internet address (www.blah.com) to inet_addr
00:22:47 <dmwit> Do a DNS lookup?
00:22:50 <dmwit> Why are you asking?
00:22:51 <xkb> are there any haskell based "virtual worlds"? Like Croquet for smalltalk or Active Worlds for C(++)?
00:23:43 <carl> yes and because im writing a client and i want it to be able to connect to an given website rather than an ip addr
00:25:16 <dmwit> carl: There's almost no functions in Haskell that demand an IP address.
00:26:24 <glguy> :t Network.connectTo
00:26:25 <lambdabot> Network.Socket.HostName -> Network.PortID -> IO GHC.IOBase.Handle
00:28:31 <carl> well im getting this exception and ive looked at the source and i see that any failure causes this one exception and i just assumed it wanted a decimal formatted address *** Exception: user error (inet_addr: Malformed address: www.login01.tibia.com)
00:28:56 <kaspyanand> thks i understood
00:29:21 <dmwit> carl: Did you have a try looking at that address?  It's not a valid one (from here).
00:29:40 <carl> one sec ill try using www.google.com
00:29:54 <dmwit> Perhaps you meant just plain old "login01.tibia.com" (no www).
00:30:42 <carl> google.com and www.google.com both give the same error
00:30:49 <dmwit> ?hpaste
00:30:50 <lambdabot> Haskell pastebin: http://hpaste.org/new
00:31:15 <dons> carl, which http library are you using?
00:31:23 <carl> 127.0.0.1 works
00:31:25 <dons> HTTP, curl, libdownload?
00:31:37 <carl> im not using a http library im just using Network.Socket
00:31:46 <dons> ah i c.
00:32:40 <dmwit> I recommend pasting the code (on hpaste.org).
00:32:45 <hpaste>  carl pasted "tryingtolookup" at http://hpaste.org/8821
00:33:05 <carl> http://hpaste.org/8821 yep uploaded
00:33:10 <dmwit> Oh, sorry, I prodded to soon. =)
00:33:37 <quicksilver> Network is preferred to Network.Socket, isn't it?
00:33:47 <quicksilver> isn't Network.Socket the low-level interface?
00:33:51 <quicksilver> been a while since I looked at that.
00:35:58 <dmwit> Okay.
00:36:14 <dmwit> If you are, indeed, calling "inet_addr" manually, then yes, you need to send it a dotted quad.
00:36:29 <dmwit> But WHY would you do all of that manually?
00:36:48 <carl> because this is a game protocal not a web protocol
00:37:21 <carl> how would u connect to a given server?
00:37:48 <dmwit> http://www.haskell.org/ghc/docs/latest/html/libraries/network/Network.html
00:37:50 <lambdabot> Title: Network, http://tinyurl.com/2znny8
00:38:17 <dmwit> In particular, connectTo doesn't require dotted quads.
00:38:18 <carl> lol yea i knew that was coming as soon as i said it
00:38:54 <carl> ok thx
00:39:14 <quicksilver> yeah, most of the time you can use Network.
00:39:25 <quicksilver> Network.Socket is only needed for certin under-the-hood tricks.
00:39:54 <quicksilver> useful hint: don't use the PortNumber constructor directly, use its Num instance.
00:40:07 <quicksilver> otherwise you're writing endian-dependent code.
00:40:28 <dmwit> quicksilver++
00:41:34 <carl> quicksilver: thx
00:48:31 <carl> if ur still interested looking at the source i found getHostByName in Network.BSD
01:04:39 <_zenon_> _zenon_++
01:04:41 <_zenon_> :)
01:04:45 <_zenon_> @karma _zenon_
01:04:45 <lambdabot> You have a karma of 0
01:04:50 <_zenon_> oh noes,
01:04:54 <_zenon_> it's safe
01:05:10 <_zenon_> lambdabot++
01:05:17 <_zenon_> @karma lambdabot
01:05:17 <lambdabot> lambdabot has a karma of 0
01:10:26 <ski> @karma @karma
01:10:27 <lambdabot>  @karma has a karma of 0
01:10:48 <ski> @karma--
01:10:48 <lambdabot> usage @karma(+|-) nick
01:11:33 <_zenon_> lambdabot++
01:11:35 <_zenon_> lambdabot++
01:11:35 <_zenon_> lambdabot++
01:11:36 <_zenon_> lambdabot++
01:11:40 <_zenon_> @karma lambdabot
01:11:41 <lambdabot> lambdabot has a karma of 4
01:11:57 <_zenon_> what function does karma fill?
01:12:06 <ski> no function
01:12:20 <ski> it's all just a game
01:12:20 <_zenon_> karma :: ()
01:12:32 <_zenon_> karma :: _|_
01:16:23 <_zenon_> Soo. ski, what's cooking?
01:17:00 <_zenon_> ski: You at work ?
01:17:43 <ski> no
01:18:19 <ski> hm .. though cooking might not be a bad idea
01:19:00 <_zenon_> ski: :)
01:20:11 * ski thinks he'll gobble up just a few more soft brown cake with coconut pieces first, though
01:22:20 <_zenon_> _zenon_: Is going chinese today
01:25:20 <_zenon_> ski: cookies ain't good for your blood sugar
01:26:04 <_zenon_> @faq can Haskell bake cake with coconut pieces?
01:26:04 <lambdabot> The answer is: Yes! Haskell can do that.
01:26:28 <ski> ooh
01:26:35 <ski> i didn't know haskell could do that
01:27:39 <ski> (.. "going chinese" ? are you transplanting your gene material ??)
01:29:21 <_zenon_> ski: hehe :) No, I'm dining Chinese.
01:29:31 <ski> ah
01:29:33 <_zenon_> ski: at lunch, around 12.30 ish
01:29:51 <ski> (well, at least if you refer to cuisine)
01:30:22 <_zenon_> data Stomach = FULL | EMPTY
01:31:06 <_zenon_> I'm binary, one moment i'm empty, then suddenly, it's full, and I can't eat more :P
01:31:20 <ski> have you tried ?
01:31:36 <_zenon_> hehe, no :)
01:32:09 <_zenon_> data Stomach = Stomach {percent_full::Double}
01:32:10 <kaspyanand> how type of [(True, []), (False,  [['a']])] is [(Bool, [[Char]])] ? i dont get it
01:32:28 <_zenon_> True , False are Bool
01:32:39 <_zenon_> ['a'] = String
01:32:42 <ski> kaspyanand : well, first it's a list, a list of pairs, first part of pairs are booleans
01:32:43 <_zenon_> [Char] = String
01:32:50 <ski> second part are some kind of list
01:32:58 <ski> `[]' could be any kind of list
01:33:21 <ski> `[['a']]' tells us this is a list of list of characters
01:33:21 <kaspyanand> ok
01:33:22 <Baughn> _zenon_: Given that a stomach is a real object, it should be Rational. No doubles in nature. ;)
01:33:35 <ski> _zenon_ : s/=/::/
01:33:40 <kaspyanand> ski:thanks
01:33:42 <_zenon_> Baughn: Hm... youre right
01:33:56 <kaspyanand> i thought for each element type willbe written
01:34:08 <ski> Baughn : but are all real stomachs rational ?
01:34:12 <kaspyanand>  i thought for each element, type will be written
01:34:21 <Baughn> ski: Yes, though the logic sometimes escapes me.
01:34:29 <ski> kaspyanand : written where ?
01:34:42 <ski> kaspyanand : every element of the list must have the same type
01:34:47 <_zenon_> data Stomach = Stomach [Intestines] [Food]
01:34:49 <kaspyanand> i mean on interpreter
01:34:51 <_zenon_> there
01:35:22 <kaspyanand> its a pair of tuples,rite?
01:35:54 <ski> it is a *list* of pairs
01:36:01 <ski> a pair is a two-tuple
01:36:05 <kaspyanand> k
01:36:23 <ski> :t [(True, []), (False,  [['a']])]
01:36:25 <lambdabot> [(Bool, [[Char]])]
01:37:03 <kaspyanand> so type info says that its a list of [(Bool, [[Char]])]
01:37:16 * ski ponders making some soup for breakfast
01:37:33 <ski> kaspyanand : no .. that type is itself alread a list of somethings
01:37:35 <kaspyanand> so each pair must be having element of same type and same order
01:37:58 <ski> kaspyanand : the type says it's a list of things of type `(Bool,[[Char]])', i.e. some kind of pairs
01:38:12 <kaspyanand> hmm ok
01:39:03 <ski> kaspyanand : yes, tuples in some tuple type all have the same number of "tuple-elements" of corresponding types, in order
01:40:23 <ski> _zenon_ : hm .. what kind of chinese food ?
01:40:52 <_zenon_> ski: I don't know, the beef with bamboo was on tuesday,...
01:41:00 <_zenon_> ski: Near korsv√§gen
01:41:34 <ski> oh .. might i be talking to a fellow gˆteborgare ?
01:41:56 <_zenon_> ski: indeed :)
01:42:13 * _zenon_ made a whois days ago :)
01:42:35 <Vq^> now that shapr has moved im starting to think that im the only non-g√∂teborgare swede here :/
01:44:22 <_zenon_> Vq^: Maybe youare
01:44:56 <swiert> Vq^: they are the g√∂te-Borg. Resistance is futile.
01:45:05 <Vq^> :D
01:45:37 <_zenon_> hahaha :D
01:45:46 <Baughn> *groan*
01:46:20 <kalven_> herring stranglers
01:47:28 <_zenon_> kalven_: More like shrimp monglers
01:48:17 <_zenon_> shrimp creamers
01:48:28 <_zenon_> hm, that sounded bad.
01:48:57 <_zenon_> But, for the lambda, we are all equal.
01:49:37 <cetin> any qtHaskell users here?
01:50:27 <quicksilver> I didn't even know there was a qtHaskell!
01:50:29 <quicksilver> is it any good?
01:50:40 <cetin> yep... pretty usable
01:50:59 <cetin> and it *builds* fine without any errors unlike -_-" gtk2hs
01:51:16 <_zenon_> good documentation?
01:51:28 <cetin> http://qthaskell.sourceforge.net/
01:51:29 <lambdabot> Title: qtHaskell
01:51:36 <opqdonut> i keep being amazed by how qt bindings in any other language than C++ can work
01:51:40 <cetin> you have to build the dock yourself as well
01:51:48 <opqdonut> i somehow think of it as a programming language and not a library
01:51:58 <cetin> but not much to expect other than type signatures
01:52:34 <_zenon_> cetin: I figured
01:53:00 <cetin> I keep checking c++ books but code easily translates to qtHaskell once you get used how things map between the c++ and haskell worlds
01:53:35 <cetin> Actually I was going to ask how I can create a progress bar...
01:53:52 <cetin> anyone has exp. at least in qtc++ ^_^?
01:54:50 <koninkje> :t (***)
01:54:50 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
01:56:32 <koninkje> @pl (\(a,l) x -> (a+x, l+1))
01:56:32 <lambdabot> uncurry ((. (1 +)) . flip . ((,) .) . (+))
01:57:36 <quicksilver> cetin: yuck. a library with *no* documentation online at all? not even a hint of an example or anything?
01:57:40 <quicksilver> that's horrid.
01:57:51 <opqdonut> mhmm
01:58:39 * quicksilver will stick to wx and gtk for now.
01:59:00 <kaspyanand> is there a command by which i can find all the functions applicable on a type using ghci
01:59:15 <kaspyanand> say i want to find all functions which i can use with lists
01:59:29 <quicksilver> no, sadly not.
01:59:29 <opqdonut> use hoogle
01:59:30 <quicksilver> :b Data.List
01:59:30 <quicksilver> though
01:59:31 <opqdonut> ?hoogle [a]
01:59:31 <lambdabot> Prelude.repeat :: a -> [a]
01:59:31 <lambdabot> Data.List.repeat :: a -> [a]
01:59:31 <lambdabot> Prelude.tail :: [a] -> [a]
01:59:32 <quicksilver> will give you most of the important ones :)
01:59:36 <opqdonut> and so on
01:59:49 <quicksilver> note : hoogle is a website, not a lambdabot command!
01:59:52 <quicksilver> @where hoogle
01:59:52 <lambdabot> http://haskell.org/hoogle
02:01:19 <kaspyanand> cool :)
02:02:13 <kaspyanand> quicksilver: what :b stands for?
02:02:18 <quicksilver> :browse
02:02:22 <kaspyanand> :)
02:02:43 <quicksilver> when I'm looking through a library, say OpenGL, and trying to find stuff I use a mixture of :i and :b
02:03:00 <quicksilver> :i will tell you what module something is defined in and something about the types it uses.
02:03:06 <quicksilver> then :b will show you other stuff from that module
02:04:55 <kaspyanand> quicksilver:thks
02:06:39 <_Dae_> morning
02:09:34 <_zenon_> _Dae_ morning
02:12:54 <BeelsebobWork> is there a built in function that will print a float without ever using exponent notation?
02:13:13 <mauke> printf
02:13:22 <mauke> > show 1e99
02:13:37 <lambdabot>  thread killed
02:13:41 <mauke> what
02:13:44 <BeelsebobWork> o.O
02:13:48 <mauke> > show 1e99
02:13:49 <lambdabot>  "1.0e99"
02:14:09 <mauke> > showFFloat Nothing 1e99 ""
02:14:10 <lambdabot>  "100000000000000000000000000000000000000000000000000000000000000000000000000...
02:14:12 <BeelsebobWork> printf ".7f" 1e-5
02:14:20 <BeelsebobWork> > printf ".7f" 1e-5
02:14:20 <lambdabot>  Add a type signature
02:14:25 <mauke> > ""++ printf "%f" 1e99
02:14:28 <lambdabot>  "100000000000000000000000000000000000000000000000000000000000000000000000000...
02:14:38 <BeelsebobWork> > printf "%.7f" 1e(-5)
02:14:38 <lambdabot>  Float with missing exponent at "1e(-5..." (column 15)
02:14:47 <BeelsebobWork> > printf "%.7f" 1e-5
02:14:48 <lambdabot>  Add a type signature
02:14:52 <mauke> > ""++ printf "%f" 1e-5
02:14:53 <quicksilver> e is lexical syntax not real syntax.
02:14:53 <lambdabot>  "0.00001"
02:14:57 <quicksilver> sucks, doesn't it?
02:14:58 <quicksilver> ;)
02:15:00 <BeelsebobWork> cool
02:15:05 <BeelsebobWork> quicksilver: yes
02:15:10 <mauke> > showFFloat Nothing 1e-5 ""
02:15:11 <quicksilver> but not very much
02:15:11 <lambdabot>  "0.00001"
02:15:18 <BeelsebobWork> it makes - even more inconsistant that it already is
02:15:20 <quicksilver> there is always 1 * 10 ^^ (-5)
02:16:17 <_Dae_> isn't that slower?
02:16:32 <_Dae_> I thought the compiler removed the e?
02:16:45 <quicksilver> there is no e.
02:17:07 <quicksilver> 1e-5 is a literal, not a computation, true.
02:17:19 <quicksilver> but 1 * 10 ^^ (-5) is not exactly slow ;P
02:17:52 * _Dae_ thinks the 2 floating operations make a huge difference
02:18:45 <_Dae_> Ohh, wait.... 2008...not 1948.... you're right
02:19:05 <opqdonut> :D
02:19:36 <Mitar>     Kind mis-match
02:19:36 <Mitar>     Expected kind `??', but `SpacePoint' has kind `(#)'
02:19:36 <Mitar>     In the type synonym declaration for `WorldElement'
02:19:44 <vincenz> @seen cale
02:19:44 <lambdabot> cale is in #japanese, #ghc, #haskell-overflow and #haskell. I last heard cale speak 2m 24s ago.
02:19:49 <Mitar> type SpacePoint = (# X,Y,Z #)
02:19:51 <vincenz> Cale: ping
02:20:08 <Cale> vincenz: hello!
02:20:10 <vincenz> Cale: Hey
02:20:16 <vincenz> Cale: can you send me your public ssh key?
02:20:19 <Cale> okay
02:20:52 <_Dae_> #haskell-overflow ??
02:21:18 <BeelsebobWork> thanks again #haskell :)
02:21:22 <mauke> > maxBound * 2 :: Int
02:21:31 <lambdabot>  -2
02:21:33 <Cale> _Dae_: It's a channel to move discussions and tutorials when #haskell is too busy.
02:22:13 <_Dae_> Cale: Ahh, right..... thought it was a channel to discuss overflow problems in haskell, which seemed a bit excessive....
02:23:57 <Cale> vincenz: sent to your gmail acct.
02:24:30 <vincenz> Cale: thanks
02:25:22 <kaspyanand> i was just reading about about lazy evaluation in Haskell,how expression is not evaluated till not required
02:25:50 <Mitar> I cannot use unboxed tuples as a input arguments to a function?
02:25:51 <BeelsebobWork> hmm, I want to see that evaluation scheme
02:25:56 <kaspyanand> what are its implications? does knowing this leads to taking different decisions while coding in haskell?
02:25:58 <quicksilver> _Dae_: well the point is that it's a one-off cost.
02:25:58 <BeelsebobWork> only evaluate when you no longer need something
02:26:05 <Baughn> kaspyanand: Oh yes.
02:26:05 <BeelsebobWork> kaspyanand: it does
02:26:09 <Mitar> type Vector = (# Float,Foat,Float #)
02:26:11 <Mitar> ?
02:26:16 <BeelsebobWork> for one, you can happily deal with infinite data structures kaspyanand
02:26:16 <vincenz> Cale: done
02:26:19 <quicksilver> _Dae_: two FP calculations one-off doesn't meant anything. two FP calculations added to every iteration of an inner loop might do.
02:26:31 <vincenz> Cale: come to #lazybottoms?
02:26:47 <kaspyanand> BeelsebobWork:rite
02:26:51 <quicksilver> _Dae_: but if you're comparing to 1e-5 then it's presumably one-off.
02:26:58 <kaspyanand> BeelsebobWork: i read that
02:26:59 <Baughn> kaspyanand: Affects everything you do, I'd say, from tail recursion on up. (Which doesn't always work right here..)
02:27:43 <Axman6> can you use something like ae-b, where a = some Float, b= some Float?
02:27:44 <_Dae_> quicksilver: Right.... I was trying to think of an example where the difference between 1e-5 and 10^^(-5) would be important, but all I could think of was runtime ghci calls, so....
02:27:55 <Baughn> kaspyanand: For example, laziness allows you to replace some limited kinds of mutation with pure, lazy computations - usually works fine
02:28:31 <Baughn> kaspyanand: (Without losing performance, that is. And gaining persistence.)
02:29:09 <kaspyanand> Baughn:ok,but i dont understand that now(mutation...),may be when i know more of haskell
02:31:16 <_Dae_> kaspyanand: in layman's terms defining something you might need is not a problem, it doesn't cost you anything til you use it
02:32:12 <Baughn> kaspyanand: Unfortunately this means that simply using data can be quite costly, requiring you to think about the consequences more. Though it's more than made up for by the benefits
02:32:35 <Baughn> It also means there's no distinction between values and nullary functions. ;)
02:32:58 <_Dae_> Baughn: What do you mean? using data is costly? not quite sure I follow?
02:33:30 <Baughn> _Dae_: It can be. fibs !! 1e10, for example, will take a lot more time than just an array lookup might
02:33:49 <Baughn> (Never mind the memory use from that thing if you don't discard fibs as well)
02:35:06 <_Dae_> Baughn: right, ok yeah. using data might trigger a computation which you obviously have to pay for.  sure
02:35:47 <quicksilver> the downside of computation-on-demand is computation-on-demand
02:35:50 <Baughn> _Dae_: Pay for in memory leaks, half the time. I find that a lot of libraries have insufficient documentation on exactly what data is retained by which structures
02:36:04 <quicksilver> that is, the downside is that when you demand something it may be computed.
02:36:04 <ac> could anybody recommend a text book for learning about HMMs and bayesian networks?
02:36:12 <Baughn> Although that's nto a direct consequence of laziness, it's certainly encourage
02:36:12 <Baughn> d
02:36:48 <Baughn> quicksilver: Wonderful. Almost as good as the definition of evolution that states "The things that survive, survive. The others don't." ;)
02:37:28 * quicksilver nods
02:37:37 <wuxia_> given two Integer's how do I constructt a rational? x / y is not working
02:37:41 <_Dae_> Baughn: Tautologi is the only answer to tautologi
02:37:43 <quicksilver> x % y
02:37:53 <mauke> fromInteger x / fromInteger y
02:38:00 <quicksilver> or, if you like (fromIntegral x) / (fromIntegral y)
02:38:12 <mauke> @src (%)
02:38:12 <lambdabot> x % y = reduce (x * signum y) (abs y)
02:40:40 <_Dae_> @src reduce
02:40:40 <lambdabot> reduce _ 0 = undefined
02:40:40 <lambdabot> reduce x y = (x `quot` d) :% (y `quot` d)
02:40:40 <lambdabot>     where d = gcd x y
02:46:45 <b_jonas> is :% in that defn public?
02:47:30 <Baughn> Nope, but % does the same. More or less.
02:47:50 <Baughn> ..okay, % would probably call reduce. Still.
02:51:31 <mjrosenb> anyone know what tokens haskell-mode can translate to unicode?
02:51:53 <Baughn> Just <- and ., I'm pretty sure
02:52:21 <wuxia_> given the following, how do i create value of type side and value of type radius? : type Radius = Float
02:52:25 <wuxia_> type Side = Float
02:52:32 <carl> are actions in a do statement guaranteed to be executed in order?
02:52:37 <Baughn> mjrosenb: OKay, -> too
02:53:08 <Baughn> carl: ..not exactly. It depends on the particular monad.
02:53:35 <Baughn> carl: They're passed to the monad interpreter (or whatever) in order, sure, but it can reorder them at need. Thus you get backtracking monads and such.
02:53:42 <Baughn> carl: But for the IO monad, yes, it's in order
02:54:34 <_Dae_> carl: Notice that this only holds for the atual actions. Let's and where's are exeuted as needed, as always
02:55:01 <ski> wuxia_ : same way you create values of type `Float'
02:55:19 <Baughn> carl: Indeed, /anything/ that isn't explicitly an IO action is executed lazily
02:55:21 <ski> (wuxia_ : hint : `Float',`Radius',`Side' are all the same type)
02:55:38 <carl> how do you explicitly make something happen
02:55:50 <Baughn> What?
02:55:57 <wuxia_> so can i assign a "Radius" to "Side"?
02:56:04 <_zenon_> I think he means "action execution" or something
02:56:05 <Baughn> carl: ..what do you want to happen, exactly?
02:56:08 <quicksilver> carl: the "effects" are guaranteed to be in order.
02:56:08 <ski> wuxia_ : sure, no problem
02:56:14 <quicksilver> where what "effect" means varies from monad to monad.
02:56:15 <wuxia_> this is bad for typing, no?
02:56:19 <quicksilver> wuxia_: yes.
02:56:26 <quicksilver> wuxia_: type synonyms are just a trivial convenience
02:56:26 <wuxia_> how do i prevent from assigning one othe other?
02:56:30 <quicksilver> they don't aid type safety.
02:56:32 <ski> main = do launchNuclearMissiles
02:56:37 <quicksilver> if you want type safety you use newtypes
02:56:37 <carl> i have some handles created from sockets and im having this strange problem that if i only recv and send once it works, but if i do it any more nothing happens, not even the first lot
02:56:45 <wuxia_> so I have to create new 'data ...' ? to ensurehat radius/side can not assign toachther?
02:56:57 <quicksilver> wuxia_: yes or a newtyp
02:57:31 <ski> quicksilver : this can be a case where something like restricted type-synonyms would be nice
02:58:32 <ski> wuxia_ : `newtype' is better than `data', in your case
02:58:35 <quicksilver> carl: without more details it's hard to be sure, but maybe you're misunderstanding something about blocking or buffering.
02:58:46 * _Dae_ would love to have a newishType thingy, allowing him to define new methods using only the newishType, but still use all the old.
02:59:09 <quicksilver> implicit coercions :)
02:59:23 <quicksilver> _Dae_ is plotting to bring one of the most maligned features of C and C++ to haskell :P
02:59:59 <ski> type Stack a = [a] in empty,push,pull
03:00:05 <ski> empty :: Stack a
03:00:08 <ski> empty = []
03:00:10 <ski> ...
03:00:14 <hpaste>  carl pasted "networkproblem" at http://hpaste.org/8822
03:00:27 <conal> dcoutts_: ping
03:00:33 <ski> Stack> empty ++ "foo"
03:00:35 <ski> type error
03:00:49 <_Dae_> quicksilver: Yes, I know :p I find it usefull from time to time, though I've mainly used it in java
03:00:53 <ski> (that's restricted type-synonyms for you)
03:01:15 <quicksilver> ski: *nod*
03:02:00 <ski> is there any reason why adding something like this to GHC would be hard .. (relative to how type-checking is done, et.c.) ?
03:02:28 <quicksilver> I wouldn't think so
03:02:40 <quicksilver> I think specifying the syntax scoping might be fiddly
03:02:53 <ski> even just being able to abstractly export a type synonym would be useful
03:03:11 <quicksilver> if you can abstractly export it it's not a synonym any more
03:03:17 <ski> right
03:03:19 <quicksilver> (as far as the current terminology is concerned)
03:03:31 <quicksilver> synonyms don't exist for teh type checker
03:03:31 <ski> but it would be a synonym inside the module
03:03:36 <quicksilver> they're just used in some error messages
03:04:31 <kaspyanand> anyone here who has come to functional world from imperative world?
03:05:05 <quicksilver> most of us, probably
03:05:06 <quicksilver> although some of us longer ago than we care to remember
03:05:07 <therp> kaspyanand: no one is born in wonderland.
03:05:10 <ski> kaspyanand : maybe better to ask if there's anyone here who hasn't
03:05:18 <kaspyanand> ok
03:05:22 <kaspyanand> :)
03:05:49 <nominolo> @seen swiert
03:05:49 <lambdabot> swiert is in #haskell. I last heard swiert speak 1h 20m 53s ago.
03:05:58 <swiert> hi nominolo
03:06:41 <kaspyanand> i am c#/vb6 programmer at work
03:07:00 <_Dae_> kaspyanand: I feel your pain
03:07:00 <kaspyanand> learned ruby n used it to automate some stuff at work
03:07:08 <kaspyanand> now haskell
03:07:27 <kaspyanand> but now we have F#
03:07:45 <kaspyanand> so probably learning haskell will give better understanding of functional concepts
03:07:58 <cjs> I did years of Ruby before Haskell, and years of Java before that.
03:08:28 <cjs> Haskell seems to me dangerous if you're going to do F#. You'll spend the rest of your life in F# wishing it had all sorts of cool things that Haskell does.
03:08:36 <kaspyanand> :)
03:09:03 <cjs> It's kinda true of Haskell versus any language, really....
03:09:07 <_Dae_> cjs: But that's true of every programming language vs haskell, no?
03:09:14 <kaspyanand> well wht about lisp
03:09:25 <kaspyanand> isn't it the best language?
03:09:28 <cjs> Nowhere near.
03:09:36 <kaspyanand> n all other languages are copying ideas from it?
03:09:45 <ski> (fyi, lisp isn't one language)
03:09:48 <EvilTerran> kaspyanand, hahaha, no
03:10:01 <kaspyanand> evilterran:y?
03:10:03 <EvilTerran> #haskell is the wrong place to hask if lisp is the best programming language :P
03:10:09 <kaspyanand> :)
03:10:18 <EvilTerran> no implicit laziness, no strict typing, no pattern matching
03:10:19 <_Dae_> kaspyanand: Lisp is the oldest language still alive, let it die in peace....
03:10:20 <mauke> ÔΩàÔΩÅÔΩìÔΩã
03:10:29 <Cale> kaspyanand: There's lots of new research that's not going into lisp.
03:10:34 <EvilTerran> no algebraic data types, no typeclasses
03:10:56 <kaspyanand> hmm so lisp is no good>
03:10:57 <kaspyanand> ?
03:11:04 <EvilTerran> sure, you can implment some or all of these as macros, but your macros will be different to everyone else's
03:11:08 <Vq^> kaspyanand: no one said that
03:11:17 <EvilTerran> and implementing strict typing as a macro sounds like quite a mission
03:11:27 <Cale> kaspyanand: It's okay, it's just not the most progressive language these days.
03:11:32 <quicksilver> lisp is a very interesting language
03:11:34 <EvilTerran> (when I talk about "lisp", i mean "common lisp and/or scheme")
03:11:42 <cjs> It's not that LISP is no good, it's just that Haskell is the only language with a number of truly modern features.
03:11:49 <EvilTerran> some would argue that liskell is a LISP, mind
03:11:49 <quicksilver> its main criticisms vs haskell are lack of types
03:11:51 <EvilTerran> ?where liskell
03:11:51 <lambdabot> http://clemens.endorphin.org/liskell
03:11:55 <Vq^> one of the interesting things about lisp is the syntax (or lack thereof)
03:12:01 <quicksilver> and all higher-order abstractons being via macros
03:12:08 <quicksilver> macros have their disadvantages.
03:12:21 <mauke> @where qi
03:12:22 <lambdabot> I know nothing about qi.
03:12:46 <mapreduce> Macros are probably hard to use with static typing, because you can't really type a macro parameter.
03:12:59 <quicksilver> well TH is sort of typed macros
03:13:08 <quicksilver> and meta-ocaml is also sort of typed macros
03:13:25 <quicksilver> but there are lots of respects in which they are different to lisp macros of course
03:13:28 <mauke> @where+ qi http://www.lambdassociates.org/aboutqi.htm
03:13:29 <lambdabot> I will remember.
03:13:34 * EvilTerran heard that lisp macros don't have the same "compilation stages" distinction that TH has
03:15:08 <b_jonas> cjs: I'm not trying to argue, but what do you mean by truly modern features/
03:15:08 <cjs> A really good type-checker.
03:16:33 <cjs> The common use of and libraries that well support heavy abstraction of control structures.
03:18:05 <cjs> A compiler and runtime that can support and is getting some of the most modern performance features, such as multi-threaded GC.
03:18:45 <kiris> I come from Scheme and CL to Haskell. I haven't experienced that syntactic abstraction is so useful. quotation and quaisquotation is for DSLs but one can achieve the same kind of thing with combinators so it makes me suspect how useful macros are. but I haven't worked on any huge projects so my view is skewed.
03:18:50 <cjs> (Part of the win of Haskell, admittedly, is not Haskell itself, but ghc, and of course some of the research coming out of yhc.)
03:19:18 <cjs> I've not done a lot with macros, but combinators rock, if you build your life around them.
03:22:39 <mapreduce> kiris: Macros let you choose syntax.
03:23:22 <kiris> mapreduce: pretty sure I just said ‚Äúsyntactic abstraction‚Äù
03:23:24 <mapreduce> kiris: E.g., in lisp I can write (roman mcmxcviii) and it is expanded at compile-time to 1998.
03:23:38 <therp> EvilTerran: what do you mean by >strict< typing?
03:23:39 <quicksilver> on the other handle, you can do "syntax-light" with lists of tuples.
03:23:57 <quicksilver> which I often find useful with haskell combinator setups
03:24:40 <quicksilver> mapreduce: well that you can indeed do in TH.
03:25:06 <Cale> Of course, it looks ugly as sin when you do it, because that's what TH is like :P
03:26:20 <quicksilver> that's true enough but it's also a matter of taste / familiarity
03:26:25 <kiris> mapreduce: I'm not sure how large an advantage that has over: roman "mcmxcviii"
03:26:34 <quicksilver> frankly I find many of the tricks that lisp programmers use to be ugly as sin.
03:26:42 <Cale> quicksilver: this is true
03:26:53 <quicksilver> I daresay that would wear off somewhat if I programmed those tricks for a while.
03:27:06 <b_jonas> quicksilver: some of them yeah, but not all macros are like tha
03:27:07 <mauke> <insert standard rant about "special" variables and how perl got it almost right>
03:27:07 <b_jonas> t
03:27:11 <therp> well, most of macros can be captured by higher order functions (see the paper "Closing the Stage" which pretty much proofs that). the difference that remains is the compile-time vs. runtime difference (which is not interesting from the point of expressiveness of syntax but only for performance). however, there are is a pretty useful class of macros (schemers would call them unhygenic) that is not expressible as higher order functi
03:27:12 <therp> ons. that's where the fun starts for a lisp programmer.
03:27:43 <b_jonas> mauke: I don't get what everyone thinks is wrong with global variables in a library
03:28:02 <b_jonas> it's only a problem if it harms re-entrancy
03:28:08 <b_jonas> but not just because the variable is global
03:28:18 <mauke> that's an unrelated issue
03:28:19 <b_jonas> so I think it's quite ok to have some variables global
03:28:26 <quicksilver> is it not true that even the unhygenic ones can be typed, just maybe it's quite hard to get the type right?
03:28:56 <quicksilver> and that the schemers might sneer at the slight syntactic overhead we need to help the type-system through the hoops
03:28:59 <b_jonas> mauke: unrelated or did you just say "special" to mean those that do cause a problem
03:29:52 <mauke> http://www.lisp.org/HyperSpec/Body/dec_special.html
03:29:52 <lambdabot> Title: CLHS: Declaration SPECIAL
03:29:53 <b_jonas> quicksilver: typed in which type system?
03:29:56 <eu-prleu-peupeu> hello haskell people
03:30:32 <quicksilver> b_jonas: well, e.g. the haskell one.
03:30:34 <b_jonas> I mean, some macros can't be typed in c or even c++
03:30:44 <therp> quicksilver: actually that's what my Ph.D. thesis should be (partially) about. whether a type system can capture safety-properties of code that produces code.
03:30:53 <b_jonas> some useful c or c++ macros even that you can write in cpp
03:31:03 <b_jonas> not just syntactical hack ones
03:31:13 <b_jonas> therp: wow, nice
03:31:21 <quicksilver> therp: well if you restrict the produced code to a DSL (for which you embed an interpreter) than surely the answer is yes?
03:31:32 <b_jonas> why are there so many theses these days about type systems used for (yet) unusual things?
03:31:42 <quicksilver> therp: and whilst that probably isn't what your thesis is about, from an expressiveness point of view isn't that enough to answer the schemers?
03:31:47 <b_jonas> I think it implies that type systems are useful and ahve lots of possibilities in them.
03:33:11 <ski> eu-prleu-peupeu : hello back
03:33:49 <eu-prleu-peupeu> hi ski
03:34:21 <eu-prleu-peupeu> i have a feeling that is going to be in this vacances that im going to dominate haskell
03:34:39 <kiris> therp: http://okmij.org/ftp/Computation/Generative.html#metafx is this the one you meant?
03:34:39 <lambdabot> Title: Generative Programming
03:37:21 <ziman> quite ambitious :)
03:39:34 <Mitar> any example of using nmergeIO ?
03:41:28 <Mitar> i have a function which processes a list and I would like to run in chunks in threads
03:41:40 <Mitar> so half a list one thread, half a list the other one
03:41:58 <Mitar> list splitting is simple
03:46:27 <mjrosenb> for those interested
03:46:36 <kiris> hi ndmitchell
03:46:48 <ndmitchell> hi kiris
03:47:17 <mjrosenb> haskell-mode supports not -> <- => ~> -< :: . forall and \
03:47:46 * mjrosenb should add in >>= as well
03:49:34 <therp> quicksilver: correct. there are several papers about how to write DSLs in MetaML that are implemented as an interpreter turned into staged code. this is a scenario where you could type code fragments of staged code and at the end (if all code fragments are assembled) guarantee that the code produced is type error free. See http://www.cs.rice.edu/~taha/publications/journal/dspg04b.pdf (this also mentions Template Haskell)
03:49:35 <lambdabot> Title: DSL Implementation in MetaOCaml, Template Haskell, and C++
03:50:35 <eu-prleu-peupeu> DSL is a code generator ?
03:50:41 <therp> b_jonas: I'm heading for dependent types (although not sure of the outcome). I presume the answer to your question lies in the fact the dependent-types are so useful for software verification in general and much research is heading in the direction of verification, at least I have that impression
03:50:51 <quicksilver> therp: right, that was my gut feeling.
03:51:02 <therp> eu-prleu-peupeu: can be, yes
03:51:04 <quicksilver> therp: I have seen some papers on multi-stage stuff by the metaocaml guys
03:51:14 <quicksilver> well, seen them presented. But it was a few years agol
03:51:22 <therp> kiris: yes, that's what I meant
03:51:35 <eu-prleu-peupeu> is a DSL like a generic code generator ?
03:51:42 <eu-prleu-peupeu> can a DSL generate ansi C code ?
03:52:19 <quicksilver> a DSL is just a language
03:52:24 <quicksilver> what you do with it is up to you.
03:52:35 <ski> Dicalcic Sackamaker Lexicology
03:52:46 <ski> aka Domain Specific Language
03:52:49 <cjs> Anybody here familiar with SockAddrInet etc.?
03:53:11 <therp> quicksilver: I'm not so interested in this spirit of meta-programming. many interesting things can't be done with that approach. Usually in the cases where you want to generate some second class language citizen (in Haskell my favorite example is one involving patterns)
03:53:27 <quicksilver> therp: yes.
03:53:42 <cjs> WTF is with PortNumber, PortNo, and network versus machine byte order?
03:53:57 <eu-prleu-peupeu> ah ok, domain specific language
03:54:19 <quicksilver> cjs: use the Num instance
03:54:28 <quicksilver> cjs: the constructor shouldn't really be exported, I guess
03:55:02 <quicksilver> (the data type stores internally in network order but the user of the library should not have to worry about that)
03:57:14 <hpaste>  Mitar pasted "How to make concurrent?" at http://hpaste.org/8823
03:57:24 <Mitar> can please anybody look at this?
03:57:41 <Mitar> i believe it is a trivial thing ... but cannot find any good reference how to use forkIO
03:58:00 <quicksilver> mapM_ (forkIO drawDot)
03:58:06 <Cale> Mitar: you pass an IO action that you want to run concurrently to forkIO and it runs concurrently
03:58:12 <quicksilver> however if you try that it will crash disastrously
03:58:17 <quicksilver> openGL is not thread safe
03:58:21 <Mitar> no no
03:58:31 <Mitar> this is why I prepare a list of actions
03:58:42 <Mitar> so I make a list of IO actions (and this takes a long time)
03:59:15 <Mitar> then I put it together (the order of that is nor importatn as every action is drawing a pixel on a screen - it is not important in which order I do that)
03:59:23 <Mitar> and then compile it ... and execute it
03:59:50 <Mitar> but preparing the data for "defineList rendering Compile" takes time
03:59:54 <Mitar> so I would like to split it
04:00:01 <Mitar> (and that part is completely pure)
04:00:05 <Cale> I think quicksilver is right... you don't want to do opengl calls from multiple threads.
04:00:20 <Mitar> i do not do opengl calls from multiple threads
04:00:31 <Cale> You might want to parallelise the computation of the pixel colours
04:00:47 <Cale> You can do that using parMap, perhaps.
04:00:52 <Mitar> I am trying but Haskell is not smart enough
04:00:55 <Mitar> I tryed parMap
04:01:02 <Cale> (what you want is parallelism, not concurrency)
04:01:07 <Mitar> but the list is still serial ...
04:01:08 * quicksilver laughs at Mitar
04:01:18 <Mitar> so it does not improve anything ...
04:01:22 <quicksilver> "haskell is not smart enough"
04:01:22 <Mitar> quicksilver ... why?
04:01:25 <quicksilver> haskell doesn't have a brain.
04:01:26 <Mitar> :-)
04:01:27 <Cale> Mitar: hm?
04:01:29 <quicksilver> it's a programming language.
04:01:33 <Mitar> :-))
04:01:35 <quicksilver> it's the programmer than has to be smart.
04:01:47 <quicksilver> parMap is the right way to do pure computations in parallel.
04:02:00 <Mitar> that's reason why I am asking here .... asking smart people smart question to get smart answers :-)
04:02:15 <Cale> Mitar: or perhaps parListChunk n rnf
04:02:25 <quicksilver> is there any need to chunk it?
04:02:39 <Cale> Where n is some appropriate number.
04:02:42 <Cale> quicksilver: Well, if you spark too many things, the scheduling will kill you.
04:02:48 <cjs> quicksilver: Actually, I don't get how that constructor takes a PortNumber, but will accept an Int. It's because it does an automatic fromInteger on any bare number, and PortNumber is an instance of Num?
04:02:54 <Cale> (which is unfortunate, but true)
04:03:37 <quicksilver> Cale: I thought sparking was fairly lightweight.
04:03:38 <Mitar> Cale: I will only need to parallel in to N parts ...
04:03:44 <quicksilver> Cale: and 10s of thousands of sparks was safe.
04:03:53 <Mitar> do not need to spark for any of those list elements
04:03:54 <quicksilver> at least, I thought that was the party line.
04:03:57 <cjs> Anyway, if PortNum takes a number in network byte order, shouldn't we be providing hton and ntoh?
04:03:59 <Cale> quicksilver: Safe, but you lose performance.
04:04:02 <Mitar> parChunkMap does not exist?
04:04:15 <quicksilver> cjs: the construct doesn't accept an Int
04:04:20 <Cale> Mitar: just use normal map
04:04:37 <quicksilver> cjs: and yes, you are right, it's the Num instance
04:04:45 <quicksilver> cjs: that's how numerical literals work in haskell
04:04:52 <quicksilver> cjs: (they're all automatic fromIntegers)
04:04:57 <cjs> I get it. I just have to remember that!
04:05:10 <Cale> Mitar: map f xs `using` parListChunk n rnf
04:05:13 <quicksilver> cjs: I think that constructor should not be exported. and the docs should be better.
04:05:32 <Cale> Mitar: parMap strat f xs = map f xs `using` parList strat -- anyway
04:05:32 <cjs> The PortNum constructor? Yeah, I think I'd agree.
04:05:39 <cjs> And I definitely do about the docs.
04:05:55 <quicksilver> Mitar: why do you say "do not need to spark for any of those list elements" ?
04:06:41 <Mitar> s/any/every/
04:07:03 <Mitar> so I could split the list in half - so in two chunks
04:07:07 <carl> can someone please have a look at this and see if anything is wrong the bit in question is heavily commented http://hpaste.org/8824
04:07:28 <hpaste>  Saul__ pasted "Type family troubles" at http://hpaste.org/8825
04:07:38 <Saul> Can anyone help me with this?
04:07:54 <quicksilver> Mitar: it's better to trust the sparks
04:07:56 <Cale> Mitar: right... what would really be better is a strategy to stripe the list into n parts
04:08:07 <quicksilver> Mitar: then it will work in future on a computer which has more cores than yours does.
04:08:09 <Mitar> i can do that ..
04:09:07 <Cale> quicksilver: It's really unfortunate that the scheduler for sparks isn't better than it is. I always see people getting killed on parallelism because they spark evaluations which are too small.
04:09:29 <hpaste>  carl pasted "net" at http://hpaste.org/8826
04:09:58 <carl> sorry if anyones looking at that thing theres a slight fix at http://hpaste.org/8826
04:10:17 <Mitar> Cale: but with chunking I do not spark too big things?
04:10:18 <quicksilver> Cale: well I assume Mitar's ray calculation is fairl expensive or we woudln't be doing this.
04:10:31 <quicksilver> Cale: ray calculation is typically a moderately expensive operation.
04:11:06 <Cale> quicksilver: Well, he's complaining that parMap isn't speeding things up.
04:11:21 <Saul> Can anyone explain why associated types don't inherit class instances (http://hpaste.org/8825)?
04:11:22 <Mitar> maybe i was using it the wrong way
04:11:51 <Mitar> castRay function is called 614400 times and everything takes 15 seconds
04:11:55 <Mitar> (on one thread)
04:12:04 <Cale> Saul: Type families are broken in 6.8.2
04:12:12 <quicksilver> Mitar: did you pass -RTS -N2 when you tried parmap?
04:12:14 <Cale> Saul: wait for 6.10
04:12:15 <Mitar> @source mapM_
04:12:15 <lambdabot> mapM_ not available
04:12:17 <Mitar> yes
04:12:17 <quicksilver> (or >2)
04:12:30 <quicksilver> was it slower? the same? slightly faster?
04:12:42 <Saul> Cale: Is it wise to switch to head for now?
04:12:58 <Cale> Saul: If you're adventurous... I know some people use it.
04:13:02 <Mitar> i was reading http://www.haskell.org/ghc/docs/latest/html/users_guide/using-smp.html
04:13:03 <quicksilver> carl: why are you using all this low-level stuff instead of the bits in Network?
04:13:03 <lambdabot> Title: 5.12. Using SMP parallelism, http://tinyurl.com/ytnnbg
04:13:21 <Mitar> and there is written to check -sstderr
04:13:25 <Cale> Saul: You could also just use functional dependencies for the most part
04:13:30 <Mitar> so calculations took around the same
04:13:42 <Mitar> and there was no significant increase in user time
04:14:00 <quicksilver> carl: is this supposed to be UDP or TCP?
04:14:10 <Saul> Cale: Yeah I had that before, this is my attempt to clean up the code a bit
04:14:28 <Mitar> what is source of mapM_?
04:14:37 <carl> its tcp
04:14:39 <Cale> @src mapM_
04:14:39 <lambdabot> mapM_ f as = sequence_ (map f as)
04:14:56 <Mitar> so I have to change this map to parMap?
04:15:05 <Mitar> chunked parmap
04:15:09 <Mitar> i tried this :-)
04:15:13 <quicksilver> Mitar: I don't think so, no.
04:15:13 <Cale> In the mapM?
04:15:15 <Cale> No.
04:15:20 <Saul> Cale: I think I'll go back to that, and then use some existentials to eliminate the second parameter for types that have the patch embedded in them
04:15:21 <quicksilver> your mapM isn't the bit you want to parallelise
04:15:22 <Cale> That won't do any good.
04:15:30 <Saul> Cale: Thanks
04:15:34 <Cale> Saul: np
04:15:44 <quicksilver> carl: OK, then you want to use accept.
04:15:50 <quicksilver> carl: and the high level interface in Network.
04:17:05 <carl> ill change it quickly but i dont think its gonna make much difference the problem is occuring after the sockets been changed into a handle
04:17:21 <Mitar> which part it is ?
04:17:31 <Mitar> so draw dots = sequence_ (parMap rwhnf drawDot dots) does not help
04:17:33 <Mitar> still 15 s :-)
04:17:43 <esap> Is there a simple way of proving that coproduct injections need not be mono?
04:17:51 <quicksilver> carl: I think that's part of your problem, and part of your problem is you don't understand about blocking IO
04:17:52 <Cale> Mitar: of course.
04:18:03 <Cale> Mitar: that map only builds actions
04:18:07 <quicksilver> carl: but I can't help you in detail with that low-level API because I've never used it.
04:18:12 <Mitar> yes
04:18:19 <Mitar> and why it cannot build it parallel?
04:18:21 <carl> k ill get back to u in a seck
04:18:23 <carl> sec
04:18:24 <Cale> Mitar: you want to change the map which is doing the computation
04:18:30 <quicksilver> Mitar: it can but it's pointless because it does no work.
04:18:32 <quicksilver> Mitar: it's trivial.
04:18:39 <quicksilver> the hard work is in building 'dots' in the first place.
04:18:55 <Mitar> rayCast view = parMap rwhnf (castRay . moveRay view) initialViewport
04:19:16 <Saul> Cale: crap, now I still can't derive Read and Show because I use existentials :(
04:19:35 <Cale> Mitar: that looks more correct :)
04:20:12 <Mitar> no, 15 s :-)
04:20:29 <Mitar> is it possible that it is memory bound? so that all this memory read/writes take so much time?
04:20:33 <quicksilver> is rwhnf enough?
04:20:38 <Mitar> ehm, forget ..
04:20:44 <quicksilver> that is, does whnf do enough for your data type?
04:20:50 <quicksilver> is it strict in all its components?
04:21:01 <Cale> Use rnf regardless, if you can.
04:21:09 <ziman> i parallelized my raytracer at the output-writing point
04:21:18 <Mitar> so rayCast :: View -> [ViewportDotColor]
04:21:21 <Mitar> this is the type
04:21:29 <Mitar> data ViewportDotColor = ViewportDotColor !ViewportDot !VoxelColor
04:21:33 <Mitar> it is like this
04:22:41 <Cale> mm... okay
04:22:48 <Cale> and what's ViewportDot?
04:22:54 <Cale> (and VoxelColor)
04:23:12 <Cale> are they strict as well?
04:23:13 <Mitar> I added
04:23:13 <Mitar> instance NFData ViewportDotColor
04:23:22 <Mitar> type ViewportDot = (X,Y)
04:23:28 <Mitar> data VoxelColor = VoxelColor !Red !Green !Blue !Alpha
04:23:33 <Mitar> colors are Floats
04:24:03 <Mitar> is it enough just to write "instance NFData ViewportDotColor"
04:24:08 <Mitar> compiler eats it ..
04:24:22 <quicksilver> that sets the methods to undefined
04:24:23 <Mitar> and I can use rnf now
04:24:27 <quicksilver> your program will crash :P
04:24:31 <Mitar> no?
04:24:32 <Cale> no, you'd need to provide a definition of rnf for it to work.
04:24:32 <Mitar> it works :-)
04:24:38 <Mitar> ???
04:24:40 <quicksilver> if it works, then that rnf isn't being called.
04:24:44 <quicksilver> which suggests something is wrong!
04:24:50 <quicksilver> because it should crash.
04:24:51 <Mitar> it works and it is the same
04:25:00 <Mitar> ok
04:25:02 <Mitar> so i have
04:25:03 <Mitar> rayCast view = parMap rnf (castRay . moveRay view) initialViewport
04:25:20 <Mitar> and this works the same as simple map
04:25:21 <quicksilver> "rnf" must never be being called.
04:25:29 <Mitar> how and why?
04:25:30 <quicksilver> which means there is something badly wrong, no? Cale?
04:25:37 <Cale> quicksilver: I agree.
04:25:53 <Cale> I have no idea what it would be though...
04:26:00 <Mitar> ok
04:26:19 <Mitar> and how can i instance necessary things for NFData?
04:26:52 <Mitar> maybe the defaults are smart enough to do nothing?
04:26:58 <Mitar> so they are not undefined
04:28:28 <eu-prleu-peupeu1> haskell is the right default, right ?
04:28:32 <Mitar>   rnf (ViewportDotColor dot color) = rnf dot `seq` rnf color
04:29:51 <Mitar> instance NFData ViewportDotColor where
04:29:51 <Mitar>   rnf (ViewportDotColor dot color) = rnf dot `seq` rnf color
04:29:51 <Mitar> instance NFData VoxelColor where
04:29:51 <Mitar>   rnf (VoxelColor red green blue alpha) = rnf red `seq` rnf green `seq` rnf blue `seq` rnf alpha
04:29:53 <Mitar> i did this
04:29:59 <Mitar> and it stil takes 15 seconds :-(
04:30:39 <Cale> Mitar: define them all to error
04:30:48 <Vq^> eu-prleu-peupeu1: what do you mean by that?
04:30:51 <Cale> Mitar: then you'll really know if they're not getting called
04:30:51 <carl> quicksilver: lol exact same thing happend o well im outta steam ill figure this out tomorrow
04:31:16 <Cale> Mitar: because the program should really die then if your rnf is called.
04:31:32 <Mitar> instance NFData ViewportDotColor where
04:31:33 <Mitar>   rnf (ViewportDotColor dot color) = error "undefined"
04:31:36 <Mitar> it works :-)
04:31:41 <Mitar> (ehm, it does not die)
04:31:59 <Cale> Then the bug isn't here :)
04:32:08 <Mitar> ghc -O2 -threaded --make Main.hs
04:32:13 <Mitar> i am compiling like this
04:32:17 <Cale> you're using  parMap rnf ?
04:32:25 <Cale> Let's see that line again?
04:32:25 <Mitar> and running like this: ./Main +RTS -N2
04:32:33 <Mitar> rayCast view = parMap rnf (castRay . moveRay view) initialViewport
04:32:56 <Mitar> and i checked that i am compiling the right thing :-)
04:33:03 <Mitar> i can put source somewhere on the web ...
04:34:22 <Cale> Mitar: try replacing that entire parMap with an error call and try again :)
04:34:45 <Mitar> http://mitar.tnode.com/Temp/Voxel.zip
04:35:28 <Mitar> it throws an error now :-)
04:35:32 <Mitar> rayCast view = error "undefined"
04:35:50 <Cale> Mitar: interesting
04:36:00 <Mitar> is it possible that this is not implemented on Mac?
04:36:09 <Mitar> so it is = id :-)
04:36:28 <Mitar> parMap _ = id
04:36:30 <Mitar> :-)
04:36:58 <Mitar> it looks like that :-)
04:36:58 <Cale> mmm
04:36:58 <Mitar> rayCast view = parMap undefined (castRay . moveRay view) initialViewport
04:37:01 <Mitar> that works :-)
04:37:06 <Cale> gah
04:37:12 <Cale> That's brutal.
04:37:17 <Mitar> very :-)
04:37:25 <Mitar> i spend two days and three rewrites of code
04:37:28 <quicksilver> carl: well the problem is the way you're expecting network IO to work
04:37:30 <Mitar> to make it parallel
04:37:39 <Mitar> and nothing worked ...
04:37:50 <Mitar> that's why i though of going to concurrency
04:37:57 <quicksilver> Mitar: you compile with -threaded?
04:38:13 <Mitar> i compile with:
04:38:13 <Mitar> rm *.hi *.o ; ghc -O2 -threaded --make Main.hs
04:38:25 <Mitar> and in files i have
04:38:26 <Mitar> {-# OPTIONS_GHC -funbox-strict-fields -fexcess-precision #-}
04:38:31 <quicksilver> carl: network IO is asynchronous and potentially buffered, just sequencing reads and writes is not guaranteed to be useful.
04:38:35 <Mitar> The Glorious Glasgow Haskell Compilation System, version 6.8.3
04:38:45 <Mitar> Mac OS X 10.5.3
04:38:56 <eu-prleu-peupeu1> has anyone tried to mix adobe flex with haskell ?
04:39:09 <eu-prleu-peupeu1> i have to try it :D
04:39:15 <eu-prleu-peupeu1> with that mxml thing of them
04:39:23 <mapreduce> Flaskell!
04:39:49 <eu-prleu-peupeu1> flaskell exists ? :D
04:39:52 <eu-prleu-peupeu1> it sounds great heheh
04:39:55 <draft> hi
04:40:07 <mapreduce> If it does, I'd be surprised as I just made it up.
04:40:15 <eu-prleu-peupeu1> actionscript for the front-end, and haskell for the back-end
04:40:42 <eu-prleu-peupeu1> seems the perfect web 3.0 sensation :D
04:40:45 <kiris> moer liek haskell for the front-end, haskell for the back-end amirite
04:40:58 <byorgey> hi draft
04:40:58 <lambdabot> byorgey: You have 2 new messages. '/msg lambdabot @messages' to read them.
04:41:17 <byorgey> ?clear-messages
04:41:18 <lambdabot> Messages cleared.
04:41:38 <kiris> : 1
04:41:43 <Mitar> Cale: so, any suggestions?
04:41:45 <mjrosenb> @pl \ f -> g f x
04:41:45 <lambdabot> flip g x
04:41:57 <mjrosenb> oh god
04:42:03 <kiris> haha
04:42:32 <quicksilver> Cale: JaffaCake informs me that exceptions inside pars get discarded
04:42:38 <draft> i'm learning haskell (using ghci) following "A gentle introduction to haskell". However instructions like "length :: [a] -> Integer" do not work, do you know why please ?
04:42:40 <quicksilver> Cale: so parMap undefined not throwing an error is expected.
04:42:41 <Cale> oh!
04:42:56 <mjrosenb> draft: you can't enter those directly
04:42:57 <mauke> draft: define "do not work"
04:43:00 <Cale> draft: Where are you putting them?
04:43:09 <mjrosenb> draft: the type signatures usually don't matter
04:43:15 <draft> in ghci interactiv prompt
04:43:18 <Cale> draft: The interpreter expects expressions only.
04:43:24 <mjrosenb> draft: for other things you need to prefix most statements with let
04:43:32 <Cale> draft: All declarations go into a file, which you load into ghci
04:43:39 <mjrosenb> draft: multi-line statements are harder
04:43:46 <mjrosenb> draft: a file is recommended
04:43:47 <Cale> Don't bother with let in ghci for the most part :)
04:44:06 <mjrosenb> Cale: it's useful to test things
04:44:12 <draft> how to use ghc with a file so please ?
04:44:23 <Cale> Just keep two terminal windows open, one with your editor, and one with ghci, and whenever you save your file, :re will reload the file.
04:44:25 <mjrosenb> also, ghci seems to be stuck inside of an IO monad....
04:44:27 <mapreduce> :load YourFile.hs
04:44:42 <Cale> (or even just a single  :  on a line by itself)
04:44:57 <mauke> : will repeat the last : command
04:45:04 <draft> ok trhanks
04:45:06 <draft> thanks
04:45:14 <mjrosenb> or if you're in emacs, just type C-c C-l in your source window, and it'll compile in another buffer
04:45:58 <quicksilver> Mitar: Ok, exceptions are concealed by being inside pars, so that was a red herring.
04:46:04 <Mitar> ok
04:46:04 * mjrosenb thinks he's going to leave this statement as map ($curSide) foo
04:46:06 <Mitar> but still
04:46:14 <Mitar> then when i make an instance
04:46:15 <mjrosenb> and add in another line to the let-binding
04:46:18 <Mitar> instance NFData ViewportDotColor where
04:46:18 <Mitar>   rnf (ViewportDotColor dot color) = rnf dot `seq` rnf color
04:46:19 <Mitar> instance NFData VoxelColor where
04:46:19 <Mitar>   rnf (VoxelColor red green blue alpha) = rnf red `seq` rnf green `seq` rnf blue `seq` rnf alpha
04:46:23 <Mitar> this should work?
04:46:38 <Cale> Mitar: the strictness annotations should be taking care of that for you, even
04:46:44 <Mitar> dot is a tuple, colors are float
04:46:57 <Mitar> can you check the source?
04:47:03 <Cale> Mitar: That is, given the way your types are defined, rwhnf is doing the same thing.
04:47:06 <Mitar> http://mitar.tnode.com/Temp/Voxel.zip
04:47:16 <Mitar> so tuples are strict?
04:47:20 <quicksilver> Cale: well, not inside the tuple, I don't think.
04:47:23 <quicksilver> onl inside the colour.
04:47:32 <quicksilver> so 'rnf dot' should be useful.
04:47:33 <Cale> oh....
04:47:52 <Cale> ah, yes, I missed that
04:47:55 <Mitar> who is JaffaCake?
04:47:56 <Mitar> :-)
04:48:07 <Cale> Mitar: Simon Marlow, iirc.
04:48:53 <Cale> Mitar: who is one of the core people responsible for Haskell and GHC :)
04:49:05 <Mitar> nice to have him around :-)
04:49:34 <draft> well i tried to load stuff into a file as you said, but : http://pastie.org/231429  do you know what's happening please ?
04:49:34 <lambdabot> Title: #231429 - Pastie
04:50:20 <rwbarton> draft: You tried to define a function with the same name as one in the basic standard library ("Prelude")
04:50:43 <hpaste>  Mitar annotated "How to make concurrent?" with "Types" at http://hpaste.org/8823#a1
04:51:02 <Mitar> so I have such types now ... is this ok?
04:51:20 <Mitar> but ... why is there `seq` ... why not `par` ?
04:51:59 <draft> rwbarton, thanks
04:52:08 <quicksilver> Mitar: there is `par`
04:52:17 <quicksilver> Mitar: and, all the parMap stuff is constructed using `par`
04:52:19 <mjrosenb> is it bad that I've switched to using . rather than $ simply because i get a cool unicode symbol for it?
04:52:29 <quicksilver> mjrosenb: bad reason but good result.
04:52:37 <quicksilver> mjrosenb: . is nicer than $ where possible.
04:52:45 <b_jonas> why is . nicer?
04:52:51 <quicksilver> because it's associative
04:52:55 <quicksilver> we like associative operators
04:52:56 <b_jonas> I've heared you guys say . is nicer but I don't get it
04:53:00 <Mitar> but does not `seq` not enforce that rnf is set in a sequence to this data elements?
04:53:04 <mjrosenb> quicksilver: particularly if they ever decide to change the associativity of $
04:53:06 <quicksilver> they yield expressions which have more valid subexpressions.
04:53:19 <quicksilver> and they make it easier to refactor code.
04:53:20 <b_jonas> mjrosenb: in the _prelude_?
04:53:25 <rwbarton> b_jonas: I'd say because you might want to turn f . g . h $ x into just f . g . h
04:53:30 <Mitar> still: why this works: rayCast view = parMap undefined (castRay . moveRay view) initialViewport
04:53:34 <quicksilver> in the expression "a . b . c . d . e"
04:53:40 <quicksilver> Mitar: because exceptions are ignored in the parallel part.
04:53:43 <rwbarton> b_jonas: but if you start with f $ g $ h $ x, you have to change all the $s to .s
04:53:45 <Mitar> yes
04:53:52 <b_jonas> rwbarton: now that might be a better reason, yeah
04:53:52 <quicksilver> "b . c" and "c . d" are both valid subexpressions.
04:53:56 <Mitar> but checkinf for strategy is not parallel part?
04:53:59 <Mitar> or it is?
04:54:09 <quicksilver> that's because . is associative
04:54:12 <b_jonas> I'm not sure I buy the associativity though
04:54:18 <b_jonas> $ has nice properties as well
04:54:20 <quicksilver> and it gives you more ways to refactor/rearrange/think about your code.
04:54:28 <mjrosenb> @pl (.f)
04:54:29 <lambdabot> (. f)
04:54:32 <quicksilver> what nice property does $ have?
04:54:35 <mjrosenb> err
04:54:39 <mjrosenb> thanks lambdabot
04:54:45 <quicksilver> Mitar: yes, it's in the parallel part.
04:54:46 <rwbarton> "being the identity"
04:54:51 <rwbarton> that's usually pretty nice :)
04:54:55 <b_jonas> yeah
04:55:02 <mjrosenb> strangely enough
04:55:03 <b_jonas> it's one of the simplest functions besides undefined
04:55:07 <quicksilver> well it's not the identity viewed as a binary operators, really.
04:55:09 <mjrosenb> that told me exactly what i wanted
04:55:14 <quicksilver> a b $ c $ d
04:55:17 <quicksilver> is not the same as a b c d
04:55:29 <quicksilver> it's only the identity viewed as a prefix operator
04:55:46 <Mitar> nice, it works
04:55:54 <Mitar> rayCast view = map (castRay . moveRay view) initialViewport `using` parListChunk 1000000 rnf
04:55:57 <Mitar> takes 20 seconds!
04:55:58 <b_jonas> yep, whatever you mean by the identity binary op
04:56:00 <Mitar> so there is a change!
04:56:03 <quicksilver> Mitar: what was it before?
04:56:06 <ziman> (.) is more `functional' as it expresses function manipulation (composition) instead of data manipulation
04:56:09 <b_jonas> (which I think is one of left and right identity)
04:56:11 <Mitar> but just in wrong direction ..
04:56:16 <Mitar> what what was before?
04:56:17 <quicksilver> heh
04:56:19 <quicksilver> the time.
04:56:24 <Mitar> 15 seconds
04:56:43 <quicksilver> b_jonas: well the point I'm making is that it's not obvious what "the identiy as a binary operator" should mean
04:56:54 <quicksilver> so I'm not sure that "being id" counts as a "nice property" of $
04:56:58 <b_jonas> ziman: no way, $ is so general it applies to anything, including functions
04:56:59 <quicksilver> when we discuss $ as a binary operator.
04:57:03 <Mitar> rayCast view = map (castRay . moveRay view) initialViewport -- 15 seconds
04:57:12 <quicksilver> Mitar: try changing that chunk size.
04:57:21 <quicksilver> (I've no idea what to, just experiment :P)
04:57:25 <Mitar> rayCast view = parMap rnf (castRay . moveRay view) initialViewport -- 15 seconds
04:57:26 <b_jonas> quicksilver: well, yep, as a binary operator it has no nice properties
04:57:28 <b_jonas> that's true
04:57:32 * quicksilver nods
04:57:33 <Mitar> rayCast view = map (castRay . moveRay view) initialViewport `using` parListChunk 1000000 rnf -- 20 seconds
04:57:41 <quicksilver> surely it's as a binary operator we are having that discussion?
04:57:45 <quicksilver> since we're comparing . to $
04:57:56 <Choko> isn't there some function which applies a input to a list of functions? signature: a -> [a->b] -> [b]
04:58:02 <ziman> b_jonas, if the input data for the expression is a function, then yes :)
04:58:05 <Cale> $ has the (in my view annoying) property that it associates the wrong way relative to ordinary function application, which allows it to be used as a poor-man's composition operator
04:58:59 <mjrosenb> so there's concatMay = concat . map
04:59:19 <mjrosenb> is there anything for concat . zipWith?
04:59:26 <Cale> I really recommend that people don't do that though, since composition is a much nicer operation to think about -- if you write f $ g $ h $ x, then g $ h is (very likely) meaningless, while in f . g . h $ x, the g . h is going to be a valid function on its own.
04:59:27 <quicksilver> Choko: map ($x)
05:00:04 <quicksilver> [... and f . g and f . g . h as well. It's the fact they are *all* sensible subexpressions that I like]
05:00:09 <mauke> Choko: sequence
05:00:18 <Choko> quicksilver: nice thanks
05:00:29 <plutonas> hello, i'm doing exrcises from book.reallworldhaskell.org, and got stuck in one that says i should implement groupBy using a fold, any hints?
05:00:44 <mauke> > sequence [id, id, id] ()
05:00:48 <lambdabot>  [(),(),()]
05:00:49 <b_jonas> Cale, quicksilver, rwbarton: thanks for the comments
05:01:27 <mjrosenb> plutonas: what have you thought of so far?
05:02:46 <b_jonas> mjrosenb: dunno, good question. you can probably use concatMap and zip, but I don't know if that's better
05:02:54 <b_jonas> and you can probably write by hand
05:02:54 <quicksilver> plutonas: have a look at the source of groupBy, have a look at the source of foldr.
05:03:00 <quicksilver> plutonas: see if you can see any common shape.
05:03:01 <b_jonas> but otherwise I've no idea
05:03:09 <plutonas> mjrosenb: myGroupBy f xs = foldr step [] xs
05:03:10 <plutonas>     where step x (y:ys) | f x y = x:(y: my
05:03:19 <quicksilver> mjrosenb: you don't really mean "."
05:03:25 <plutonas> but there i get stuck, don't know how to group the next in the same list etc
05:03:27 <quicksilver> mjrosenb: because zipwith has too many parameters.
05:03:43 <quicksilver> mjrosenb: I just call use concat as needed, in that case, anyway :)
05:03:46 <mjrosenb> quicksilver: so i noticed
05:03:50 <mjrosenb>  (concat ‚óã zipWith replicate sections) lengths
05:03:54 <mjrosenb> seems to work
05:03:55 * quicksilver nods
05:03:56 <mjrosenb> oops
05:04:04 <mauke> U+25CB (e2 97 8b): WHITE CIRCLE [‚óã]
05:04:08 <mauke> blasphemy!
05:04:10 <mjrosenb> right, irc does'nt like unicode
05:04:15 <quicksilver> well yes, the . works if you have one parameter inside and one outside
05:04:23 <quicksilver> myself I think that style is normally a bit odd
05:04:24 <mauke> U+2218 (e2 88 98): RING OPERATOR [‚àò]
05:04:33 <quicksilver> because normally "sections" and "lengths" are "at the same level"
05:04:35 <plutonas> my problem is mainly that i need to place into new list sometimes, and into the previous one sometimes etc
05:04:55 <mjrosenb> mauke: how did you do that?
05:05:04 <mauke> do what exactly?
05:05:39 <mjrosenb> get U+2218 so quickly
05:05:48 <quicksilver> mauke only looks like a human. He's actually a unicode dictionary in disguise.
05:05:53 <mauke> I typed /sunip `uni{ring operator}
05:06:43 <mjrosenb> i see
05:06:53 <mjrosenb> wow, got a whole lot quieter in here
05:07:00 <mauke> I have a script that expands `commands{} inline
05:07:14 <mauke> "uni" does by-name lookup of unicode characters
05:07:41 <mauke> this results in ‚àò
05:10:01 <draft> I don't understand something in A gentle introduction to haskell about user defined type : after doing "data Point a = Point a a", how can i create a variable of type Point / print it ?
05:10:29 <mauke> Point 1 2 is a value of type Point Integer
05:10:43 <kaspyanand> hi
05:10:52 <mauke> you could e.g. say: main = let foo = Point 1 2 in print foo
05:10:52 <kaspyanand> in what language is haskell written?
05:11:04 <mauke> kaspyanand: English
05:11:16 <mjrosenb> kaspyanand: math
05:11:17 <BeelsebobWork> kaspyanand: the haskell compilers are written in Haskell
05:11:25 <BeelsebobWork> the semantics is written in maths
05:11:28 <mauke> hugs is written in C
05:11:36 <BeelsebobWork> oh, so it is
05:11:43 <BeelsebobWork> well, hugs obviously sucks then :P
05:11:58 <draft> mauke, thanks
05:11:58 <mjrosenb> hugs sounds painful to write
05:12:12 <chr1s> hey everyone.
05:12:27 <chr1s> in php/perl/python, there's this function unpack, that decodes a binary string
05:12:38 <mauke> Data.Binary
05:12:45 <BeelsebobWork> data.ByteString
05:13:00 <chr1s> is that compatible with the php/perl version?
05:13:05 <mauke> no
05:13:21 <chr1s> hm, that's what I actually need. But thanks anyway =)
05:13:22 <BeelsebobWork> are the types you're trying to pack/unpack the same?
05:13:26 <BeelsebobWork> the answer is likely to be no
05:13:34 <BeelsebobWork> you will need a good amount of martialling
05:13:35 <mauke> why do you need unpack?
05:13:44 <chr1s> well, I'm unpacking unsigned floats
05:13:54 <mauke> there are no unsigned floats
05:14:02 <chr1s> in python, it's an unpack ">N", in php "N*".
05:14:05 <FordCortina> anybody know how to to define the iI Ii constructor, in McBride's applicative functor paper? so that you can have a function \ iI f v1... vn Ii  -> pure f <*> v1 <*> ... <*> vn ?
05:14:11 <chr1s> yeah, that's what I thought :D
05:14:14 <mauke> that's not a float
05:14:25 <mauke> N   An unsigned long (32-bit) in "network" (big-endian) orde
05:14:26 <mauke> r.
05:14:28 <chr1s> oh, shoot.
05:14:37 <chr1s> I meant an unsigned long
05:14:58 <ertai> Hi, is there a combinator to apply binary function on 2 pairs given 2 binary functions?
05:15:05 <draft> mauke, after having defined my Point type, how to access to the first value stored in my point please ? e.g if i have "foo = Point 1 2", how to get the 1 from foo ? in C i would write foo.var1, but how to do in haskell  please ?
05:15:05 <chr1s> so there are no libraries for that? then I'll just figure out a way to do it myself.
05:15:13 <mauke> draft: pattern matching
05:15:23 <mauke> draft: case foo of Point x y -> ... use x and y
05:15:36 <draft> ah ok thanks
05:15:52 <ertai> something like (a->b->c) -> (d->e->f) -> (a,d) -> (b,e) -> (c,f)
05:15:58 <FordCortina> this is the paper http://www.soi.city.ac.uk/~ross/papers/Applicative.html
05:15:59 <lambdabot> Title: Applicative Programming with Effects
05:16:00 <mauke> chr1s: you'd use getWord32be
05:16:29 <ertai> or like ((a->b->c), (d->e->f)) -> ((a,d), (b,e)) -> (c,f)
05:16:37 <chr1s> mauke: thanks, I'll look into it.
05:16:47 <mauke> @djinn  (a->b->c) -> (d->e->f) -> (a,d) -> (b,e) -> (c,f)
05:16:48 <lambdabot> f a b (c, d) (e, f) = (a c e, b d f)
05:16:58 <mauke> @. pl djinn  (a->b->c) -> (d->e->f) -> (a,d) -> (b,e) -> (c,f)
05:16:59 <lambdabot> f = flip flip snd . (ap .) . flip flip fst . ((.) .) . flip flip snd . ((flip . ((flip . (ap .)) .)) .) . flip flip fst . ((flip . ((flip . ((.) .)) .)) .) . flip . (((.) . flip . (((.) . (,)) .)) .)
05:17:04 <ertai> :)
05:17:29 <rwbarton> :t flip flip
05:17:44 <rwbarton> @ty flip flip
05:17:44 <lambdabot> thread killed
05:17:50 <Mitar> there is also
05:17:50 <Mitar> class NFData a where
05:17:50 <Mitar>   -- | Reduces its argument to (head) normal form.
05:17:51 <Mitar>   rnf :: Strategy a
05:17:51 <Mitar>   -- Default method. Useful for base types. A specific method is necessay for
05:17:51 <Mitar>   -- constructed types
05:17:53 <Mitar>   rnf = rwhnf
05:17:59 <lambdabot> thread killed
05:18:11 <ertai> @djin (a->a->a) -> (b->b->b) -> (a,b) -> (a,b) -> (a,b)
05:18:12 <lambdabot> Maybe you meant: djinn djinn-add djinn-clr djinn-del djinn-env djinn-names djinn-ver
05:18:12 <Mitar> Cale, so this is why there was no error
05:18:26 <ertai> @djinn (a->a->a) -> (b->b->b) -> (a,b) -> (a,b) -> (a,b)
05:18:26 <lambdabot> f a b (c, d) (e, f) = (a c e, b d f)
05:18:36 <ertai> @. pl djinn (a->a->a) -> (b->b->b) -> (a,b) -> (a,b) -> (a,b)
05:18:37 <lambdabot> f = flip flip snd . (ap .) . flip flip fst . ((.) .) . flip flip snd . ((flip . ((flip . (ap .)) .)) .) . flip flip fst . ((flip . ((flip . ((.) .)) .)) .) . flip . (((.) . flip . (((.) . (,)) .)) .)
05:18:42 <Cale> Mitar: aha
05:18:46 <conal> are there any code.haskell.org administrators here?  i'd like to get a new project set up
05:18:49 <Cale> Mitar: But also, par eats errors.
05:18:54 <ertai> @djinn (a->a->a) -> (a->a->a) -> (a,a) -> (a,a) -> (a,a)
05:18:54 <lambdabot> f a b (c, d) _ = (d, a c (b c c))
05:18:54 <Mitar> yes :-)
05:19:06 <quicksilver> FordCortina: yes.
05:19:13 <mauke> @. unpl . pl djinn  (a->b->c) -> (d->e->f) -> (a,d) -> (b,e) -> (c,f)
05:19:14 <lambdabot> f bp f = (\ p ac -> (\ av bk -> ((,)) (bp (fst p) (fst av)) (f ac bk)) >>= \ cs -> snd >>= \ cr -> return (cs cr)) >>= \ bu -> snd >>= \ bt -> return (bu bt)
05:19:17 <Mitar> so how could i use forkio to compute this?
05:19:24 <ertai> @djinn (a->a->a) -> (b->b->b) -> ((a,b), (a,b) -> (a,b))
05:19:24 <lambdabot> -- f cannot be realized.
05:19:28 <Mitar> i would split the list in half and compute that :-0
05:19:34 <ertai> @djinn (a->a->a) -> (b->b->b) -> ((a,b), (a,b)) -> (a,b)
05:19:35 <lambdabot> f a b ((c, d), (e, f)) = (a c e, b d f)
05:19:35 <quicksilver> FordCortina: put iI in a typeclass
05:19:52 <ertai> @. pl djinn (a->a->a) -> (b->b->b) -> ((a,b), (a,b) -> (a,b))
05:19:52 <lambdabot> (line 1, column 1):
05:19:52 <lambdabot> unexpected "-"
05:19:52 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
05:19:56 <ertai> @. pl djinn (a->a->a) -> (b->b->b) -> ((a,b), (a,b)) -> (a,b)
05:19:59 <lambdabot> f = flip flip snd . (ap .) . flip flip fst . ((.) .) . flip flip snd . (ap .) . flip flip fst . ((.) .) . flip flip snd . ((flip . ((flip . (ap .)) .)) .) . flip flip fst . ((flip . ((flip . ((.) .))
05:19:59 <lambdabot>  .)) .) . flip . (((.) . flip . (((.) . (,)) .)) .)
05:20:00 <quicksilver> Mitar: forkIO is for doing IO actions in parallel rather than computations.
05:20:17 <Mitar> yes, but I cannot make it compute the list?
05:20:31 <Mitar> and stores it somewhere
05:20:31 <ertai> does @pl knows about ***, &&& ?
05:20:37 <mauke> ertai: no
05:20:50 <Mitar> and after both threads finishes
05:20:55 <Mitar> i would collect the parts
05:22:15 <ertai> @ty (+) *** (-)
05:22:16 <lambdabot> forall a b'. (Num b', Num a) => (a, b') -> (a -> a, b' -> b')
05:22:24 <rwbarton> Mitar: I had reasonable success using forkIO to spawn a thread which just seq'd a bunch of values in a list I had already constructed
05:22:29 <rwbarton> Mitar: if you see what I mean
05:23:08 <ertai> @ty ((+) *** (-)) . (($) *** ($))
05:23:09 <lambdabot> forall a b a1 b1. (Num (a1 -> b1), Num (a -> b)) => (a -> b, a1 -> b1) -> ((a -> b) -> a -> b, (a1 -> b1) -> a1 -> b1)
05:23:22 <Mitar> yes ... so you were forcing evaluation?
05:23:23 <ertai> @ty (($) *** ($)) . ((+) *** (-))
05:23:23 <lambdabot> forall a b'. (Num b', Num a) => (a, b') -> (a -> a, b' -> b')
05:23:35 <rwbarton> let me see if I can find the code
05:23:56 <ertai> @ty ((.).(.)) (($) *** ($)) ((+) *** (-))
05:23:56 <lambdabot>     Couldn't match expected type `(a -> b, a1 -> b1)'
05:23:56 <lambdabot>            against inferred type `b' -> b''
05:23:56 <lambdabot>       Expected type: (a2, b') -> (a2 -> a2, (a -> b, a1 -> b1))
05:24:07 <ertai> @ty (+) *** (-)
05:24:08 <lambdabot> forall a b'. (Num b', Num a) => (a, b') -> (a -> a, b' -> b')
05:25:04 <rwbarton> Mitar: yeah, so something like  forkIO (mapM_ (\x -> x `seq` return ()) listToCompute)
05:25:22 <ertai> @ty (\c (x,y) -> (($x) *** ($y)) (((+) *** (-)) c))
05:25:23 <lambdabot> forall a b'. (Num b', Num a) => (a, b') -> (a, b') -> (a, b')
05:25:36 <Mitar> so I would make two lists
05:25:38 <ertai> @ty (\(x,y) -> (($x) *** ($y)) . (((+) *** (-))))
05:25:39 <lambdabot> forall a b'. (Num b', Num a) => (a, b') -> (a, b') -> (a, b')
05:25:44 <Mitar> then call thredIO twice ...
05:25:49 <Mitar> and wait for both of them to finish
05:26:00 <Mitar> and i will have the lists evaluated
05:26:14 <ertai> @pl (\(x,y) -> (($x) *** ($y)) . (((+) *** (-))))
05:26:15 <lambdabot> uncurry (flip flip ((+) *** (-)) . ((.) .) . (. flip id) . (***) . flip id)
05:26:18 <Mitar> how can i split the list into list of chunks of lists, where every chunk would be of some size?
05:26:19 <rwbarton> you could use splitAt rather than keep track of two lists
05:26:29 <Mitar> @hoogle
05:26:29 <lambdabot> HOOGLE - Haskell API Search
05:26:29 <lambdabot> (C) Neil Mitchell 2004-2008, York University, UK
05:26:29 <lambdabot>  
05:26:44 <ertai> @pl (((.) *** (.)) . (((+) *** (-))))
05:26:44 <lambdabot> ((.) *** (.)) . ((+) *** (-))
05:26:50 <ertai> @ty (((.) *** (.)) . (((+) *** (-))))
05:26:51 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b'. (Num b', Num a, Functor f1, Functor f) => (a, b') -> (f a -> f a, f1 b' -> f1 b')
05:27:18 <ertai> > (((.) *** (.)) . (((+) *** (-)))) (1,2) (3,4)
05:27:20 <lambdabot>  Couldn't match expected type `t1 -> t'
05:27:25 <ertai> > (((.) *** (.)) . (((+) *** (-)))) (1,2) 3 4
05:27:26 <lambdabot>  Couldn't match expected type `t1 -> t2 -> t'
05:27:34 <ertai> @ty (((.) *** (.)) . (((+) *** (-)))) (1,2)
05:27:35 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b'. (Num b', Num a, Functor f1, Functor f) => (f a -> f a, f1 b' -> f1 b')
05:27:36 <rwbarton> There's no library function for it yet
05:27:46 <Mitar> Int -> [a] -> [[a]]
05:27:49 <EvilTerran> <therp> EvilTerran: what do you mean by >strict< typing? <- I mean types enforced at compile time
05:28:11 * ertai I give-up on this :)
05:28:11 <SamB_XP> EvilTerran: like in C?
05:28:48 <EvilTerran> SamB_XP, that'll do, given that the point i was going for was that enforcing types at compile-time with macros in clisp/scheme would be very awkward
05:30:11 <EvilTerran> altho i am interested in the prospect of taking a minimalist lisp and trying to implement various haskell features as macros
05:30:17 <Mitar> let split n = takeWhile (not . null) . unfoldr (Just . splitAt n)
05:30:23 <EvilTerran> (pattern-matching seems fairly straightforward, for instance)
05:30:24 <adekoba> does anybody recommend a particular package for working with mysql?
05:30:56 <EvilTerran> ugh, takeWhile . unfoldr
05:31:10 <SamB_XP> EvilTerran: why a minimalist lisp?
05:31:21 <EvilTerran> split n = unfoldr ((>>) <$> guard.not.null <*> splitAt n)
05:31:34 <EvilTerran> er, return.splitAt n, rather
05:32:00 <EvilTerran> SamB_XP, because such things would tend not to mesh nicely with a lisp with an extensive standard library
05:32:23 <schme> EvilTerran: What haskell features?
05:32:25 <EvilTerran> also because it feels cleaner
05:32:33 <EvilTerran> schme, well, as i said, pattern-matching is one
05:32:40 <schme> EvilTerran: Maybe you should check Qi out.
05:32:42 * SamB_XP wonders how to express contempt for mysql in the form of a package name
05:32:49 <EvilTerran> something algebraic data type-esque would be interesting
05:33:16 <schme> EvilTerran: Qi is built on top of common lisp. Pattern matches, and has a way more advanced type system than haskell.
05:33:26 <EvilTerran> interesting
05:33:38 <EvilTerran> i was mostly thinking about this kinda thing as a personal learning experience, tho
05:33:39 <schme> EvilTerran: Otherwise for minimal lisp scheme pre R6 is always a good bet ;)'
05:33:49 <SamB_XP> schme: what do you mean by "way more advanced"?
05:34:07 <EvilTerran> "roll a minimal lisp system; implement language features in it; ???; PROFIT!"
05:34:19 <schme> SamB_XP: As in it the types are defined in a turing complete language in itself.
05:34:37 <SamB_XP> eek
05:34:48 <funktio> does Qi have dependent types, or do I remember wrong?
05:35:24 <SamB_XP> I'm specifically going eek about the "turing complete" bit, since it means typechecking is undecidable...
05:35:40 <schme> funktio: ho. what's that?
05:35:43 <schme> SamB_XP: Why?
05:35:50 <SamB_XP> schme: halting problem!
05:35:56 <schme> SamB_XP: I mean sure you can make the typechecking loop infinitely or crash ;)
05:36:02 <EvilTerran> SamB_XP, that doesn't bother me, really
05:36:18 <schme> EvilTerran: I say go with scheme anyway. If you want a minimal lisp. or maybe arc :)
05:36:24 <SamB_XP> okay okay, probably not a REAL problem
05:36:32 <EvilTerran> SamB_XP, i'd rather have a sufficiently expressive type system to prove that my code won't crash at runtime, even if it means it might crash at compile-time ;)
05:37:03 <EvilTerran> at compile-time, there's a programmer nearby to fix it. that won't always be the case at run-time
05:37:17 <schme> I'm a bit bugged out by the haskell type system actually. I want to define a type that is a subtype of Int.. like [1..28] but I can't seem to do that :)
05:37:38 <EvilTerran> well, we don't really have subtypes...
05:37:42 <EvilTerran> i imagine that doesn't help
05:37:43 <schme> Exactly.
05:37:54 <EvilTerran> the closest we have is subclasses
05:38:03 <EvilTerran> but you can't subclass a type (like Int)
05:38:08 <schme> Exactly.
05:38:36 <schme> So issa bit of a pain there. Not very much of a real problem, but still :)
05:38:51 <schme> Oh. food time. Have a good one #haskell (: and good luck with your lisping there, EvilTerran :)
05:39:04 <EvilTerran> however, you could create a newtype of Int with a number to work modulo encoded in the type :P
05:39:14 <opqdonut> :)
05:39:31 <EvilTerran> or you could go to oleg's site, 'cos he's probably already done it three different ways
05:39:36 <Mitar> is this good statistics:   Productivity  98.3% of total user, 173.3% of total elapsed
05:40:02 <povman> I get: Not in scope: `autoconfUserHooks'  -- when cabal installing SDL-image
05:40:40 <dcoutts> povman: looks like it got updated to depend on Cabal-1.4
05:40:40 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
05:40:50 <dcoutts> which is unnecessary really
05:40:57 <dcoutts> ping lemmih about it
05:40:59 <SamB_XP> dcoutts: shouldn't that be mentioned in the cabal file?
05:41:15 <dcoutts> SamB_XP: indeed, but as I say it's not necessary anyway
05:41:25 <SamB_XP> yes, you did say that
05:41:45 <povman> dcoutts: I'm using cabal 1.4.0.1
05:42:41 <BeelsebobWork> does anyone know, does the section in lambdabot's readme saying "Note: If you want lambdabot to be able to evaluate expressions (e.g., "> 1 + 1" evaluates to 2) then you'll need hs-plugins and also before './Setup.hs configure --bindir=`pwd`' you need to copy lambdabot.cabal.plugins to lambdabot.cabal." apply to both build methods?
05:43:40 <SamB_XP> BeelsebobWork: what's the other build method?
05:44:10 <dcoutts> povman: aye, it works for me with Cabal-1.4
05:44:12 <BeelsebobWork> one build method involves running ./build and being done, the other involves a standard cabal build
05:44:27 <BeelsebobWork> thing is -- there is no lambdabot.cabal.plugins file
05:44:33 <BeelsebobWork> and I don't have working evaluation
05:45:28 <dcoutts> povman: you must be using a Setup.hs compiled with Cabal-1.2 or older
05:45:50 <povman> quite possible, i'm still on 6.8.1
05:46:11 <dcoutts> povman: are you using cabal-install or compiling Setup.hs manually?
05:46:22 <povman> was cabal-installing, but about to manually try
05:46:30 <dcoutts> povman: hmm, odd.
05:46:50 <dcoutts> povman: you can use -v and see what version of the Cabal lib it is using to compile Setup.hs
05:47:17 <dcoutts> povman: but by default it will try to use the same version or a similar version to the one it was built with, which means 1.4.x
05:47:25 <povman> ibook:~/src/SDL-image-0.5.2 lukeworth$ runhaskell Setup.lhs -v configure
05:47:25 <povman> Setup.lhs:4:30: Not in scope: `autoconfUserHooks'
05:47:43 <dcoutts> so perhaps you're using a different version of ghc to the one you expect
05:47:49 <dcoutts> see what ghc-pkg list Cabal says
05:48:03 <povman> aha, 1.2.2
05:48:29 <povman> but if i cabal upgrade cabal, it gives me Module `GHC.Conc' does not export `signalHandlerLock'
05:49:36 <dcoutts> povman: I'll need more detail. signalHandlerLock is not used in Cabal
05:49:43 <hpaste>  Mitar pasted "Execution statistics" at http://hpaste.org/8827
05:49:49 <Mitar> how is this possible?
05:49:53 <povman> sorry - this is in unix-2.3.0.0, a dep
05:49:58 <Mitar>  Total time   16.06s  (  9.29s elapsed)
05:50:14 <povman> is cabal 1.4 meant to work with ghc 6.8.1?
05:50:17 <rwbarton> You're running on two processors
05:50:27 <dcoutts> povman: yes it does work with 6.8.1
05:50:37 <dcoutts> povman: it works all the way back to 6.4.2
05:50:53 <Mitar> real	0m9.661s
05:50:53 <Mitar> user	0m16.160s
05:50:53 <Mitar> sys	0m0.237s
05:50:56 <BeelsebobWork> so has anyone here successfully got \bot building with support for evaluating things?
05:51:09 <Mitar> so something is blocking it
05:51:10 <Mitar> ?
05:51:15 <rwbarton> No
05:51:16 <povman> ah, if i just cabal install cabal it is not upgrading the deps
05:51:27 <rwbarton> Your program is doing 16 seconds worth of computation in just 9 seconds of wall-clock time
05:51:34 <rwbarton> Hence, both processors must be in use
05:51:37 <dcoutts> povman: right, if you want to upgrade deps too then use cabal upgrade foobar
05:51:55 <povman> dcoutts: but i can't upgrade _them_ because they depend on a better ghc
05:52:03 <Mitar> yes
05:52:05 <povman> thanks for your help
05:52:11 <Mitar> but the overall running time is still 16 s :-)
05:52:15 <dcoutts> povman: afaik, there's no need to update the unix package
05:52:20 <Mitar> no?
05:52:27 <rwbarton> No, 'time' told you it was 9.661 s
05:52:34 <Mitar> ohhh
05:52:39 <rwbarton> You can use your watch if you're not sure :)
05:52:41 <Mitar> so getCPUTime does not return realt time?
05:53:02 <povman> dcoutts: yup, it's installing 1.4 now ;D
05:53:10 <rwbarton> I don't know anything about getCPUTime but I'd guess from the name that it's the amount of total processor time your process has used
05:53:55 <rwbarton> which can be more than wall clock time if you're running on two processors, or less if your process is blocking
05:54:24 <EvilTerran> or getting switched out frequently, i imagine
05:54:27 <Mitar> http://haskell.org/ghc/docs/latest/html/libraries/base/System-CPUTime.html
05:54:28 <lambdabot> Title: System.CPUTime, http://tinyurl.com/5fd9go
05:54:31 <rwbarton> Yes
05:55:30 <povman> Mitar: are you looking for System.Time?
05:55:38 <Mitar> true ..
05:55:40 <Mitar> probably :-)
05:55:48 <quicksilver> Mitar: it's good, it means you are definitely using two cards :)
05:55:51 <quicksilver> cores.
05:55:58 <Mitar> yes ..
05:55:59 <povman> they come on cards now?
05:56:13 <Mitar> so i have a problem in measuring all along :-)
05:56:15 <RayNbow> > unfoldr (uncurry ((Just .) . liftM2 (.) (,) (ap (,) . (+)))) (0,1)
05:56:16 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
05:56:16 <Baughn> povman: Always have
05:56:19 <Mitar> i have been measuring cpu time ...
05:56:24 <Mitar> and this stayed the same :-)
05:56:38 <EvilTerran> RayNbow, yeesh
05:56:41 <RayNbow> :D
05:56:43 <Baughn> RayNbow: Evil
05:56:44 <povman> RayNbow: holy crap
05:56:59 <RayNbow> http://www.reddit.com/r/programming/info/6r0r7/comments/c04n3l2 <-- just applying @pl to a part of this unfoldr ;)
05:56:59 <lambdabot> Title: programming: Recursion Fail (or, use higher order functions)
05:57:06 <povman> @unpl unfoldr (uncurry ((Just .) . liftM2 (.) (,) (ap (,) . (+)))) (0,1)
05:57:06 <lambdabot> unfoldr (uncurry (\ l x -> (Just) (((,) >>= \ c -> (\ o -> (,) >>= \ q -> ((+) o) >>= \ p -> return (q p)) >>= \ b -> return (\ i -> c (b i))) l x))) (0, 1)
05:57:15 <povman> lambdabot: you suck
05:57:25 <RayNbow> @pl unfoldr (uncurry (\ l x -> (Just) (((,) >>= \ c -> (\ o -> (,) >>= \ q -> ((+) o) >>= \ p -> return (q p)) >>= \ b -> return (\ i -> c (b i))) l x))) (0, 1)
05:57:25 <lambdabot> unfoldr (uncurry ((Just .) . ((`fmap` (((,) >>=) . (. (return .)) . (>>=) . (+))) . (.) =<< (,)))) (0, 1)
05:57:41 <povman> lol
05:58:13 <EvilTerran> > unfoldr (Just . (fst &&& (snd &&& uncurry (+))) (1,1)
05:58:17 <lambdabot> Unbalanced parentheses
05:58:22 <EvilTerran> > unfoldr (Just . (fst &&& (snd &&& uncurry (+)))) (1,1) -- bah
05:58:23 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
05:58:40 <RayNbow> EvilTerran: arrows :)
05:59:00 <EvilTerran> RayNbow, yep. clearly the way forward. :)
06:00:13 <Mitar> so parMap with rwhnf or rnf does not help at all, but chunked parmap (chunked to half) helps really a lot, 60 % more CPU, but it does not matter if it is rwhnf or rnf
06:00:26 <carl> quicksilver: if u care the problem was with buffering all i had to do was hFlush thx neway
06:00:47 <Mitar> is there a way to get +RTS -N2 parameter in a program?
06:00:53 <RayNbow> EvilTerran: the only problem is (like every new concept), you need to rewire your brain and start recognizing certain patterns :)
06:02:13 <Baughn> @hoogle Int
06:02:14 <lambdabot> Data.Int :: module
06:02:14 <lambdabot> Prelude.Int :: data Int
06:02:14 <lambdabot> Data.Int.Int :: data Int
06:02:49 <EvilTerran> RayNbow, eh, true. the pattern i noticed there was "lots of faffing with pairs", which is one of Control.Arrow's strong points
06:03:34 <quicksilver> carl: good :)
06:03:54 <quicksilver> Mitar: yes.
06:03:54 <FordCortina> @src ap
06:03:54 <lambdabot> ap = liftM2 id
06:04:04 <povman> EvilTerran: http://comonad.com/reader/2008/recursion-schemes/ if your brain needs more mangling
06:04:06 <EvilTerran> liftM2 ($), if you prefer
06:04:09 <FordCortina> @src liftM2
06:04:09 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
06:04:09 <lambdabot> Title: The Comonad.Reader ª Recursion Schemes: A Field Guide
06:04:20 <RayNbow> povman: my brain is not ready for that :p
06:04:23 <quicksilver> Mitar: http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html
06:04:24 <lambdabot> Title: 5.14. Running a compiled program, http://tinyurl.com/d7dj4
06:04:28 <quicksilver> Mitar: 5.14.6
06:04:41 <povman> RayNbow: me either :p
06:04:41 <EvilTerran> povman, indeed it does *click*
06:05:02 <EvilTerran> ah... yeah, i already tried to mangle my brain on that one
06:05:20 <Mitar> thanks
06:05:38 <FordCortina> :t liftM2
06:05:38 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
06:05:45 <FordCortina> :t id
06:05:46 <lambdabot> forall a. a -> a
06:06:04 <BeelsebobWork> @seen Cale
06:06:04 <lambdabot> Cale is in #japanese, #ghc, #haskell-overflow and #haskell. I last heard Cale speak 47m 15s ago.
06:06:09 <FordCortina> :t liftM2 id
06:06:09 <povman> it doesn't help that the code's written in terms of his own library
06:06:10 <lambdabot> forall a2 r (m :: * -> *). (Monad m) => m (a2 -> r) -> m a2 -> m r
06:06:30 <EvilTerran> FordCortina, note that ((a -> b) -> a -> b) is a specialisation of the type for id
06:06:54 <Mitar> quicksilver: this is possible from a haskell program??
06:07:30 <FordCortina> EvilTerran: thanks
06:07:35 <Mitar> 5.14.6 is not this ..
06:08:02 <EvilTerran> :t ($)
06:08:02 <lambdabot> forall a b. (a -> b) -> a -> b
06:08:08 <EvilTerran> ?src ($)
06:08:08 <lambdabot> f $ x = f x
06:08:10 <Mitar> so i would like that i would chunk list according to how many threads will be running this program
06:08:16 <EvilTerran> ($) = id, only with a more specific type
06:08:22 <Mitar> so if there is -N2 that i can read this 2 in haskell program
06:08:46 <povman> :t id
06:08:46 <lambdabot> forall a. a -> a
06:09:03 <povman> EvilTerran: that's not quite right
06:09:23 <povman> or i'm now
06:09:25 <povman> *not
06:10:13 <povman> > head `id` [1,2,3]
06:10:14 <lambdabot>  1
06:10:15 <EvilTerran> povman, ($) f x = f $ x = f x = id f x
06:10:20 <povman> yeh
06:10:26 <FordCortina> ic :)
06:10:44 <EvilTerran> ($) f x = id f x  =>  ($) f = id f  =>  ($) = id
06:11:13 <Baughn> > 2 $ -- Still not quite id
06:11:13 <lambdabot>   parse error on input `}'
06:11:24 <Baughn> ..why was that a parse error?
06:11:27 <Baughn> > ($) 2
06:11:28 <lambdabot>   add an instance declaration for (Num (a -> b))
06:11:38 <Baughn> > id 2
06:11:39 <lambdabot>  2
06:11:53 <marcot> Good morning.
06:12:13 <povman> > sort "marcot: Good morning."
06:12:15 <lambdabot>  "  .:Gacdgimmnnoooorrt"
06:12:32 <quicksilver> Mitar: sorry, I understood your question backwards.
06:12:34 <marcot> dcoutts: Have you seen my mail about installed-pkg-config or gtk.package.conf in the gtk2hs installation?
06:12:42 <Mitar> how can i get number of running threads?
06:12:44 <quicksilver> Mitar: to find out the -N parameter is something like getNumCapabilities.
06:12:54 <quicksilver> in GHC.Conc or something
06:13:07 <quicksilver> marcot: I believe dcoutts is temporarily awa from the internet :)
06:13:08 <Mitar> have just checked there ... no
06:13:16 <Mitar> will go for an index
06:13:17 <dcoutts> quicksilver: I'm back! :-)
06:13:32 <dcoutts> marcot: not yet, catching up on a week of email
06:13:33 <Baughn> Mitar: GHC.Conc.numCapabilities
06:13:42 <quicksilver> \o/
06:13:56 <Mitar> http://cvs.haskell.org/Hugs/pages/libraries/base/GHC-Conc.html << ok, i was checking the wrong thing ...
06:14:00 <lambdabot> Title: GHC.Conc
06:15:13 <Mitar> thanks
06:15:19 <EvilTerran> Baughn, i said "with a more specific type", tho
06:15:43 <Baughn> EvilTerran: Yeah, that was aimed towards povman
06:15:51 <EvilTerran> oright
06:16:03 <marcot> dcoutts: ok, I asked here cause nobody answered, and I thought that maybe it got lost somewhere...
06:16:04 <quicksilver> Mitar: try this one : http://www.haskell.org/ghc/docs/latest/html/libraries/base/GHC-Conc.html
06:16:04 <lambdabot> Title: GHC.Conc, http://tinyurl.com/ytm69k
06:16:13 <Mitar> yes, i found ..
06:16:13 <Mitar> thanks
06:16:15 <quicksilver> ;)
06:16:29 <Mitar> now i have a parallel raytracer :-)
06:24:25 <_Dae_> dark/msg NickServ identify
06:24:39 <_Dae_> ....
06:26:13 <PHO_> haha
06:29:43 * _Dae_ curses numlock
06:30:01 <Mitar> how can i get time elapsed in pico seconds/
06:30:02 <Mitar> ?
06:30:11 <Mitar> system.time supports it
06:30:15 <Mitar> but printing the string does not
06:30:55 <quicksilver> Mitar: it is unlikely your machine has a picosecond timer.
06:31:00 <Mitar> i know ..
06:31:07 <Mitar> but i would like to have miliseconds :-)
06:31:09 <quicksilver> Mitar: System.Time supports that in case future machines might do, one day.
06:31:20 <quicksilver> you're not even getting milliseconds?
06:31:27 <quicksilver> what are you printing exactly/how?
06:31:28 <Mitar> i do not know
06:31:40 <Mitar> i am looking on how to print the difference
06:31:52 <Mitar> formatTimeDiff does not seem to support pico
06:32:11 <quicksilver> diffUTCTime prints in microsecond accuracy to me
06:32:18 <quicksilver> just using the show instance
06:32:23 <quicksilver> TriMesh:0.001428s
06:32:28 <quicksilver> ^^ copy paste from one of my timing tests
06:32:32 <PHO_> TOD Integer Integer
06:32:52 <Mitar> and where is diffUTCTime defined?
06:33:15 <Mitar> ok, found
06:35:26 <PHO_> um, System.Time seems to call gettimeofday(2), which returns the time in microseconds
06:35:47 <quicksilver> PHO_: right, but the point of the picosecond contract is that a future System.Time
06:35:53 <quicksilver> PHO_: or a System.Time on a different OS
06:36:00 <PHO_> quicksilver: I see
06:36:00 <quicksilver> might conceivable return a higher accuracy.
06:36:01 <Baughn> It doesn't practically have even microsecond accuracy
06:36:29 <quicksilver> Baughn: well it's certainly submillisecond
06:36:37 <quicksilver> Baughn: and I consider anything submillisecond to be microsecond :)
06:36:39 <quicksilver> in a sense.
06:36:50 <quicksilver> when discussing timing accuracies.
06:37:12 <quicksilver> I've never entirely understood why computers don't have picosecond timers, surely it's the most natural thing in the world to link your clock pulse to a timer?
06:37:33 <Baughn> Performance counters do just that, but..
06:37:40 <Baughn> What happens when the clock frequency changes?
06:38:01 <BONUS> i finally figuerd out the state monad!!!!!!!
06:38:02 <BONUS> yessss
06:38:04 <quicksilver> hmm. the firmware which changes the clock frequency compensates somehow?
06:38:10 <quicksilver> it doesn't sound liek ti should be insoluble
06:38:30 <quicksilver> after all, similar concerns relating to the changing PCI or memory bus ratios, when CPU clock changes, are solved problems.
06:38:43 <quicksilver> I"m sure these things are fairly simple to a chipset engineer.
06:39:01 <PHO_> Is the CPU clock really oscillating constantly in picosec order?
06:39:14 <quicksilver> on a faster than 1GHz machine
06:39:24 <quicksilver> it's 'picosecond order' in the loose sense of 'sub nanosecond'
06:39:40 <quicksilver> not very much sub nanosecond, admittedly :)
06:40:49 <_Dae_> quicksilver: I suspect that the precision of the frequency isn't good enough
06:41:29 <_Dae_> quicksilver: It might be off by say 1% and noone would really care, but the clock certainly would
06:41:31 <tromp> maybe go with zepto second to be on the safe side...
06:41:45 <quicksilver> _Dae_: well I'm not suggesting it should replace the realtime clock.
06:41:56 <quicksilver> _Dae_: just add resolution to the realtime clock.
06:43:03 <_Dae_> tromp: You really don't wanna go there, Heisenbergs uncertainty principle is gonna kick you in the behind....
06:45:49 <_Dae_> quicksilver: Well, I think it would be hard to implement.... besides who really needs that kind of accuracy in a computer program?
06:48:30 <quicksilver> _Dae_: I have very frequently wanted slightly better accuracy
06:48:45 <quicksilver> it's really annoying, many architextures have accuracy 4 or 5 orders of magnitude worse than system clock
06:48:48 <quicksilver> that seems odd.
06:53:35 <_Dae_> Well, you're able to to manufactor 10khz crystals with great precision, they're used almost everywhere. If you wanted nanosecond precision you'd probably have to move on to something lightbased....
06:55:32 * Philippa wonders what the preferred method of getting the time in games is these days, anyway
06:55:59 <Baughn> Philippa: I've never yet seen a game that /needs/ better than gettimeofday resolution
06:56:04 <Philippa> used to be RDTSC
06:56:40 <Philippa> Baughn: that used to be pretty dire on windows
06:57:47 <Philippa> it might use milliseconds as the unit, but that didn't mean it was measured that precisely
07:01:45 * _Dae_ notices wikipedia's article on RDTSC explains exactly why it's a bad idea to use the cpu for timing
07:02:24 <lilachaze> Philippa: I only know of a couple of games that use RDTSC, and I only know they use it because they don't work on my dual-core machine :)
07:05:26 <JaffaCak1> lilachaze: if that's an AMD machine, AMD have a patch for that
07:05:58 <Philippa> beat me to it :-)
07:06:20 <Philippa> the alternative was the windows multimedia timers, IIRC
07:06:31 <Philippa> also, laptops were infamous for screwing up RDTSC-based timing too
07:07:13 <hpaste>  gwern pasted "lines/words rewrites" at http://hpaste.org/8828
07:07:53 <gwern> so I was thinking of sending this rewrite to libraries - any comments?
07:08:50 <Baughn> gwern: Please. It never made sense to me why split wasn't already in the library.
07:09:08 <Baughn> ..oh, you'll have to export that one too. It's rather useful.
07:09:21 <gwern> Baughn: which split do you like, the one which consumes or not?
07:09:49 * gwern is also going to suggest a 'replace' and a 'dropLast' (analogue to 'tail')
07:10:13 <Baughn> gwern: The one that consumes. I'll put them back with intersperse if I want, which is rarely.
07:10:17 <rwbarton> > init [1,2,3,4]
07:10:32 <lambdabot>  thread killed
07:10:48 <rwbarton> why does lambdabot hate me today?
07:10:50 <rwbarton> > init [1,2,3,4]
07:10:57 <lambdabot>  [1,2,3]
07:11:53 <_Dae_> she's moody.... been a hard day, and I heard she broke a nail, which always changes her mood for the worse
07:12:06 <rwbarton> Sorry to hear that
07:12:12 <rwbarton> @bot
07:12:12 <lambdabot> :)
07:12:17 <gwern> Baughn: I don't think intersperse would work, at least not with this split' definition
07:12:37 <gwern> Baughn: ie, you expect "concat $ intersperse "a" $ split' 'a' "foobaraaa"" == "foobaraaa"?
07:12:53 <Baughn> gwern: No, I wouldn't expect that
07:13:10 <Baughn> If it bothers you, add both, but I'd only use split'. ;)
07:13:27 <gwern> good, since the result of that is foobaraa, not foobaraaa
07:16:47 <Mitar> how can main function have in profiling 2150402 entries?
07:16:58 <Mitar> does this mean that it is callled so many times?
07:18:28 <gwern> so no one has any problems with the actual functioning of split/split' and the lines/words redefition? no tests or other propreties I overlooked?
07:19:20 <gwern> right now, I'm just doing some timings before I send off to libraries, so feel free to comemnt
07:20:02 <Baughn> gwern: Well, it would be nice if you'd make lines convert latin-1 octet-read strings to unicode
07:20:04 * gwern has a theory that the redefitions are 5-10% faster, but it's too hard to tell on small/fast input
07:20:21 <gwern> Baughn: er. what does that mean, and how would I do that?
07:20:36 <oldsalt> anyone here who can help me with monad transformations?
07:20:57 <Baughn> gwern: It was a joke. Mostly.
07:21:49 * gwern cocks my eye sceptically
07:21:57 <rwbarton> I wonder whether it is possible to check strictness properties with quickcheck?
07:22:49 <EvilTerran> rwbarton, don't think so - ISTR it can't cope with _|_ results
07:22:52 <randomity> rwbarton: no. see the halting problem.
07:23:07 <EvilTerran> randomity, quickcheck doesn't prove anything anyway
07:23:15 <Cale> There is lazy quickcheck though.
07:23:22 <_Dae_> gwern: now you're at it, could you make lines translate the text to english as well? Would be great.....
07:23:31 <rwbarton> randomity: huh?  I can test by hand by typing  lines ("\n\nabc\n" ++ undefined)  into ghci and seeing how much it prints before the error...
07:24:06 <gwern> EvilTerran: QC proves tons of thing. for example, quickcheck recently proved that lines' "" = [] for me :)
07:24:17 <randomity> rwbarton: that's because undefined is an error, not a bottom
07:24:28 <EvilTerran> gwern, well, you know what i mean
07:24:32 <randomity> rwbarton: try let undef = undef in "abc"++undef
07:24:37 <EvilTerran> randomity, an error _is_ a bottom
07:24:49 <randomity> only in theory, not in ghc
07:24:50 <EvilTerran> so is non-termination, but it comes to the same thing wrt what value you get out
07:24:52 <EvilTerran> (ie none)
07:24:59 <povman> @seen lemmih
07:24:59 <lambdabot> I saw lemmih leaving #haskell 1d 52m 14s ago, and .
07:24:59 <randomity> yeah, but non-termination can't be detected
07:25:04 <EvilTerran> provided you aren't catching exceptions, which ISTR you need IO for
07:25:06 <_Dae_> oldsalt: probably.... state your problem and surely someone capable will help you.
07:25:18 <EvilTerran> randomity, you can still compare two functions' strictness behaviour with errors
07:25:25 <EvilTerran> in that regard, they're still bottoms
07:25:26 <randomity> EvilTerran: errors and non-termination are different
07:25:35 <randomity> error can be detected
07:25:44 <EvilTerran> randomity, so?
07:25:46 <randomity> i.e. when ghc tries to evaluate Prelude.error "foo"
07:25:49 <oldsalt> well, i am making my datatype an instance of binary. and in the get-method i need io
07:25:54 <EvilTerran> you can still use errors to verify strictness behaviours, as i said
07:25:55 <randomity> non-termination can't be detected without solving the halting problem
07:26:00 <EvilTerran> that's not relevant
07:26:14 <Baughn> randomity: On that note, how di I catch (only) bounds-checking exceptions from bytestring?
07:26:55 <randomity> hmm, we may be thinking of different things. I thought the original question was "can quickcheck tell me if my function is, e.g. strict on all inputs"
07:27:10 <_Dae_> oldsalt: well, you can't get out of IO, so that might be a problem
07:27:11 <rwbarton> Well, it's true that I can't distinguish a program that loops forever from one that loops for a long time and then demands its input.
07:27:24 <EvilTerran> randomity, well, it can't do that, clearly, if the input type is infinite
07:27:27 <gwern> randomity: I think ghc core may be able to tell you
07:27:30 <rwbarton> But I also can't distinguish a very slow correct program from a very fast correct program.
07:27:39 <EvilTerran> quickcheck does randomised testing, not proof
07:27:40 <rwbarton> *a very slow incorrect program, obviously
07:27:44 <oldsalt> so, if i call an io action i am trapped in io?
07:27:48 <Baughn> gwern: No, it can be mistaken
07:27:53 <Baughn> oldsalt: Yes.
07:27:59 <Cale> oldsalt: 'trapped'
07:28:16 <gwern> Baughn: it's buggy? I never said it would be perfect strictness analysis
07:28:26 <povman> @tell lemmih When I 'cabal install SDL-image', i get this: http://hpaste.org/8829
07:28:26 <lambdabot> Consider it noted.
07:28:27 <randomity> gwern: really, no it can't. Not in all cases
07:28:37 <Cale> oldsalt: You might be thinking of this in the wrong way though given the way that you worded that :) IO actions are allowed to use pure code.
07:28:38 <Baughn> gwern: No, just sometimes mistaken. It's not perfect
07:28:38 <oldsalt> Cale: so, if i call an io action, i am lucky to be in io?
07:29:10 <randomity> if you ask quickcheck to try and test whether a function is strict or not, it will in many cases hang
07:29:14 <Cale> oldsalt: So you can write the rest of the program outside the IO monad, and simply call it.
07:29:28 <EvilTerran> randomity, well, that depends on how you do it
07:29:31 <gwern> rwbarton: what about the cases where the infinite loop function keeps repeating state? could you then say it will loop forever (let's assume there is no hidden state)
07:29:54 <dcoutts_> povman: hmm, I'm not sure that's something lemmih can fix for you. It's not obviously a problem with his package.
07:30:13 <povman> dcoutts_: oer - that is a pretty weird error though
07:30:15 <_Dae_> oldsalt: http://arcanux.org/lambdacats/io-monad.jpg
07:30:21 <ronwalf> Any Generics experts here?
07:30:33 <dcoutts_> povman: narrow it down. It looks like the call to hsc2hs that's failing.
07:30:45 <EvilTerran> randomity, if you wrote a variant on Arbitrary that included results with undefineds in them, and the checker caught these errors, you could use this to check whether two functions have the same strictness
07:30:45 <povman> oh no, not hsc2hs
07:30:54 <oldsalt> _Dae_ *G*
07:30:56 <EvilTerran> (well, for the points that you tested, at least)
07:31:18 <povman> dcoutts_: fortunately there is a file called MACOSX in the distribution
07:31:37 <hpaste>  Mitar pasted "main called so many times?" at http://hpaste.org/8830
07:31:46 <rwbarton> gwern: Sure, in some cases you can detect nontermination, but not in general
07:31:59 <oldsalt> Cale: I am not sure if i can do that. I have to instantiate binary and for my datatype to be complete i need an io action
07:32:14 <_Dae_> oldsalt: One of the first things that made me scared of monads was being trapped in IO. I assumed all monads were like that.
07:32:21 <Mitar> why is main function called so many times/
07:32:23 <Mitar> ?
07:32:25 <Mitar> how is this possible?
07:32:30 <rwbarton> EvilTerran: maybe you could also write a variant on Arbitrary that used unsafePerformIO to detect what values were being forced
07:32:40 <Mitar> i cannot find any place where it takes so much time ...
07:32:45 <Baughn> oldsalt: In what sense does it need an IO action? What does it do? Why?
07:33:03 <povman> Mitar: is main recursive?
07:33:03 <Mitar> and i have been placing CAFs all around
07:33:24 <oldsalt> i have to read and write data from an database and i want to keep the connection
07:33:26 <EvilTerran> rwbarton, yeah, that would work
07:33:38 <EvilTerran> rwbarton, that's deeply arcane, actually... i'm quite tempted to try that, now.
07:33:51 <oldsalt> so, if i read my datatype with get i need to establish the connection
07:34:07 <Mitar> not that i would know :-)
07:34:12 <Mitar> i use glut ...
07:34:16 <Mitar> opengl ..
07:34:20 <Baughn> oldsalt: Well, that sounds like it belongs in IO, sure enough. And Binary is for things you can send over a network or store to a file, really; it doesn't really make sense to put a connection in it
07:34:33 <Baughn> oldsalt: Also, you want to avoid lazy I/O for the time being
07:34:45 <Mitar> (by pustrln output i would say that it is called only once)
07:35:37 <oldsalt> does it mean i am mistaken to instantiate binary to save and load?
07:36:12 <Baughn> oldsalt: Not necessarily, but it means you should make the IO explicit
07:36:25 <Cale> oldsalt: IO actions aren't observable, so you can't write a Binary instance for them. They're like bunches of code that you can't look at.
07:36:34 <marcot> What's ~?
07:36:41 <Baughn> oldsalt: You can't restart a connection with get, since it's pure. You /can/ have the structure contain a restarter that you can call afterwards.
07:36:42 <marcot> ~(Just nbc_) <- initColor dpy $ normalBorderColor Default.defaultConfig
07:36:47 <marcot> In XMonad's code..
07:37:29 <Cale> marcot: The ~ makes the pattern always match immediately, without looking at the value
07:37:37 <Baughn> oldsalt: Though as cale says, you can't serialize an IO action, you can certainly serialize a description of it that your get function later produces a new call frm
07:37:38 <oldsalt> Baughn: But the restarter would have to called explicitly so i guess i am mistaken to use binary for serialization and i should write my own get/put-stuff
07:37:46 <Cale> marcot: There will be an error later if it didn't really match and you use the matched value.
07:37:57 <Baughn> oldsalt: Perhaps. I don't know enough to be sure.
07:38:06 <oldsalt> Baughn/Cale: That is what i am trying to do
07:38:16 <Baughn> oldsalt: You could have get return IO Struct or some such
07:38:22 <Cale> oldsalt: Maybe instead of storing an IO action, store a description of the IO that you need to do.
07:38:34 <oldsalt> it is an sqlite db. on put i save the path, in get i load the path and then want to open the connection
07:38:40 <marcot> Cale: but what's the difference of not using it, like Just nbc_ <-
07:39:10 <Cale> marcot: Matching against a lazy pattern won't evaluate the thing being scrutinized by the case expression.
07:39:15 <marcot> hum..
07:39:19 <marcot> Cale: thanks.
07:39:40 <povman> dcoutts_: would lemmih be the person to tell if I did get it working?
07:39:41 <Cale> marcot: It's a subtle point, I'm not sure if it actually matters in that case.
07:39:50 <mcnster> good morning.  can i simplify this:  concatMap (\f -> map f [0..15]) $ map foo [0..15]
07:39:56 <oldsalt> Baughn: So i can change the signature of get?
07:40:11 <Baughn> oldsalt: No
07:40:15 <Cale> marcot: I think it's mostly there to highlight the fact that the Nothing case isn't being handled correctly.
07:40:23 <dcoutts_> povman: probably not. If you discover it's a problem with ghc or hsc2hs on mac then report it to the ghc people
07:40:47 <Baughn> oldsalt: To be honest, if all you"re storing is a path, I don't think Binary is a good match at all.
07:41:07 <PeakerWork> anyone here had experience teaching Haskell to someone as his first programming language?
07:41:14 <PeakerWork> do people get Haskell as a first language?
07:41:19 <oldsalt> Baughn: no, it's more than the path, but the path/connection thing is what gives me trouble
07:42:16 <Cale> mcnster: [f x y | x <- [0..15], y <- [0..15]]
07:42:33 <Cale> mcnster: Or liftM2 foo [0..15] [0..15]
07:42:44 <Cale> er, oops
07:42:56 <PeakerWork> would "foo <$> [0..15] <*> [0..15]" work?
07:42:57 <Cale> no, that's right
07:43:05 <Lemmih> povman: Get what working?
07:43:05 <lambdabot> Lemmih: You have 1 new message. '/msg lambdabot @messages' to read it.
07:43:16 <Baughn> oldsalt: As I've said, get can return a structure containing IO just fine. It just can't /do/ IO, but you as the caller can.
07:43:17 <povman> Lemmih: uh ^^ :)
07:43:37 <Cale> PeakerWork: yeah
07:43:45 <povman> Lemmih: I have a mac, and it's being a pest - slowly getting there though
07:43:54 <mcnster> @hoogle <$>
07:43:54 <lambdabot> Control.Applicative.(<$>) :: Functor f => (a -> b) -> f a -> f b
07:44:13 <PeakerWork> > (show . uncurry)  <$> [0..2] <*> [0..2]
07:44:15 <lambdabot>  Couldn't match expected type `a -> b'
07:44:18 <_Dae_> PeakerWork: HAven't tried myself, but people usually claim it's a good first, as long as it's not your only
07:44:20 <oldsalt> Baughn: Ok, thank you, i will try that and if i keep failing i will write my own stuff instead of using binary
07:44:20 <Lemmih> povman: Ah, mac is problematic.
07:44:31 <PeakerWork> _Dae_: it will for a time be an "only" :)
07:44:36 <PeakerWork> _Dae_: if its the first
07:44:58 <mcnster> @hoogle liftM2
07:44:59 <lambdabot> Control.Monad.liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
07:45:27 <monochrom> <3 monads
07:45:31 <_Dae_> PeakerWork: Yes, ofcourse it will, and that's not a problem.The problem is if the students -never- learn anything else. HAskell does little to prepare you for the cruel world that is java, c++ and Vb
07:45:42 <Cale> mcnster: That's the list monad specifically.
07:45:48 <_Dae_> monochrom: Really?
07:45:58 <PeakerWork> > (,)  <$> [0..2] <*> [0..2]
07:45:59 <lambdabot>  [(0,0),(0,1),(0,2),(1,0),(1,1),(1,2),(2,0),(2,1),(2,2)]
07:46:17 <idnar> monochrom: lies, there are far more than 3 monads
07:46:18 <idnar> *duck*
07:46:18 <PeakerWork> why not use this form instead of 0..N lifters?
07:46:19 <mcnster> thanks Cale :)
07:46:23 <Baughn> @type <*>
07:46:23 <lambdabot> parse error on input `<*>'
07:46:25 <Baughn> @type (<*>)
07:46:26 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
07:46:29 <monochrom> haha
07:46:32 <_Dae_> PeakerWork: Who're you planning to teach?
07:46:45 <PeakerWork> _Dae_: some people I know - I am wondering whether to teach Python or Haskell as a first
07:46:55 <Baughn> @type (<$>)
07:46:55 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:47:18 <monochrom> I vote for concurrently teaching both.
07:48:06 <_Dae_> PeakerWork: I'd go with haskell then.  Python is too confusing to be a good language asfaik
07:48:18 <Cale> mcnster: no problem
07:48:31 <rwbarton> Python is hard! http://web.mit.edu/rwbarton/www/python.html
07:48:31 <lambdabot> Title: Reid's Python Quiz
07:49:06 <mcnster> @hoogle <*>
07:49:06 <lambdabot> Control.Applicative.(<*>) :: Applicative f => f (a -> b) -> f a -> f b
07:52:30 <hpaste>  Abraxas pasted "greates common divisor - problem with max on list" at http://hpaste.org/8831
07:52:58 <PeakerWork> rwbarton: Python has its quirks, but it takes a long while before a beginner hits them
07:53:04 <PeakerWork> rwbarton: so I wouldn't say that makes Python hard
07:53:08 <Abraxas189> hi
07:53:35 <Abraxas189> i'd like to know why list_max is not working
07:53:42 <Toxaris> Abraxas189: look at the base case
07:53:48 <rwbarton> PeakerWork: That's probably true.  Python becomes harder when you're used to pure functional languages like Haskell
07:53:55 <Toxaris> Abraxas189: and try to work out the types
07:54:26 <PeakerWork> rwbarton: I love Haskell but I am still more productive with Python - I have many years of intensive experience with Python and just barely weeks of actual work with Haskell.. so it ofcourse works bothways :)
07:54:37 <Abraxas189> lol, sorry
07:54:53 <Abraxas189> that was easy
07:55:32 <Abraxas189> because of the error message i was focusing on the recursion...
07:55:32 <byorgey> Abraxas189: by the way, if you have  list_max list = blah,  that case will match *any* argument and it will never reach the other cases
07:55:37 <povman> can i force cabal-install to recompile something?
07:55:48 <gwern> Baughn: are you on libraries? I'm sending the email now
07:55:52 <Baughn> rwbarton: Lambda is /that/ broken? Ugh
07:55:56 <dcoutts_> povman: unregister it first
07:55:57 <Baughn> gwern: Me? Nope
07:55:57 <Abraxas189> yes i changed it to list_max [e] = e
07:55:59 <rwbarton> Abraxas189: If you put in type signatures for your functions, you'll generally get better error messages
07:56:02 <gwern> povman: ghc-pkg --user unregister then cabal-install?
07:56:09 <rwbarton> Baughn: Nope, lambda isn't broken
07:56:12 <Abraxas189> working, of course
07:56:15 <Abraxas189> :D
07:56:28 <Baughn> rwbarton: ..then why 142?
07:56:36 <rwbarton> Baughn: Just the scoping rules aren't what you're expecting
07:56:42 <Toxaris> Abraxas189: yeah, I would use three cases: [], [e], and (e:es), that's the clearest solution
07:56:59 <Baughn> rwbarton: OKay, then what does the correct code look like?
07:57:09 <PeakerWork> Baughn: Python uses the "i" variable in the function from the outer lexical scope, and not the actual value of i in that point
07:57:14 <Toxaris> Abraxas189: or maybe [], [e], (e1:e2:es) to make them order-independent
07:57:17 <PeakerWork> Baughn: you can use:  lambda blah, i=i: ...
07:57:40 <rwbarton> Baughn: Yes, or (lambda i0: (lambda blah: ...)) (i)
07:57:40 <Baughn> PeakerWork: *wince*
07:57:55 <PeakerWork> rwbarton: using an extra default argument "i=i" is the common trick
07:58:07 <Abraxas189> can i delete the paste, that is embarassing :p
07:58:27 <Baughn> rwbarton: This would never be an issue if python was pure. ;)
07:58:30 <PeakerWork> Abraxas189: it would be unfunctional of hpaste to not be a persistent data structure! :)
07:58:41 <povman> ugh, horrible command: sudo cabal build SDL-image --hsc2hs-options="-v --lflag=\"-lSDLmain\" --lflag=\"SDL\" --lflag=\"-framework\" --lflag=\"AppKit\" --lflag=\"-framework\""
07:59:03 <Baughn> povman: Huh, you actually got it to /work/?
07:59:04 <rwbarton> I'd be very happy with Python if its scoping rules were like those of almost every other language
07:59:05 <povman> AND i've got SDL installed as a framework and as a port (doesn't work without either of them)
07:59:10 <povman> Baughn: YES!
07:59:26 <Baughn> povman: Makes you long for the simplicity of linux, don't it?
07:59:29 <Toxaris> Abraxas189: and finally, why the error was what it was: from the first line, hugs figured out that the type of list_max is something like [Int] -> [Int], now, in the third line, this type is used to make sense of the recursive call, which doesn't work out. so the error is in the base case, but the inconsistency is in the recursive case
07:59:42 <povman> Baughn: pff, it's just packaged wrong
08:00:16 <Toxaris> Abraxas189: of couse, that's probably not how type inference really works, but it helps me to imagine the type inferencer to reason like this
08:00:53 <povman> what's the weirdest part about the whole thing is that --hsc2hs-options is read in reverse
08:00:59 <PeakerWork> rwbarton: most other languages that do not have mandatory declarations are global-by-default
08:01:02 <povman> hence why -framework comes after AppKit
08:01:06 <PeakerWork> rwbarton: and Python wanted to encourage local-by-default
08:01:16 <Abraxas189> mh yes, the issue was with the first, should have seen that
08:01:21 <PeakerWork> rwbarton: so it preferred to have some quirks over having either explicit declarations or globals-by-default
08:01:33 <rwbarton> PeakerWork: I'm thinking of perl with 'use strict;'
08:01:57 <PeakerWork> rwbarton: doesn't it have everything global by default in that case?
08:02:01 <PeakerWork> rwbarton: unless you use "my" ?
08:02:11 <rwbarton> PeakerWork: No, it has compile error by default :)
08:02:28 <rwbarton> PeakerWork: Unless you use either my or $main::foo
08:02:44 <PeakerWork> rwbarton: well, that is requiring explicit declarations
08:02:48 <PeakerWork> rwbarton: for locals (requiring "my")
08:02:50 <rwbarton> PeakerWork: You're right in that what I really want is mandatory variable declarations
08:03:05 <rwbarton> PeakerWork: Or optional mandatory variable declarations at least
08:07:55 <_Dae_> this is so odd... is there a known problem with haskell's random function?
08:08:54 <_zenon_> _Dae_: What is the problem?
08:10:29 <_Dae_> _zenon_:  Well... the numbers don't feel very random is all..... like the distribution is gaussian rather than truely random
08:10:55 <Zao> _Dae_: Have you've measured the randomness?
08:11:10 <gbacon> I just did a darcs pull from the lambdabot repo, and one core has been pegged for about a minute.. does this mean I've hit the quadratic conflict problem with darcs?
08:11:15 <Zao> Chi-square and all those other fancy statistical thingies :)
08:11:16 <_zenon_> _Dae_: Well, truly random,, hm.... that's pretty hard. But yeah, as Zao sais, do a measure
08:11:30 <_zenon_> Or just the information entropy.
08:11:46 * _zenon_ is wooking
08:11:50 <rwbarton> how exactly are you using the random number generator?
08:11:51 <Zao> What's behind the library random functions by the way?
08:12:02 <Zao> rand() is known to have crappy lower bits on most systems.
08:13:32 <_Dae_> rwbarton: randr (0,1) gen ?
08:13:46 <_Dae_> Zao: Nope, havent
08:13:51 <_zenon_> This implementation uses the Portable Combined Generator of L'Ecuyer [System.Random#LEcuyer] for 32-bit computers, transliterated by Lennart Augustsson. It has a period of roughly 2.30584e18.
08:16:54 <ronwalf> How do you get a previously defined datatype to derive something post definition?
08:17:17 <ronwalf> say: data Name = Name String
08:17:39 <ronwalf> Is it possible?
08:17:44 <rwbarton> I don't think you can make the compiler do it, but look at the 'derive' package on hackage
08:19:23 <Saizan> yes, GHC has standalone deriving
08:20:10 <EvilTerran> it's a recent extension, tho
08:20:14 <EvilTerran> only arrived in 6.8, iirc
08:20:25 <_zenon_> _Dae_: Have your tried randomRs ?
08:20:40 <_zenon_> The given sequence should be good
08:20:54 <_zenon_> "pretty good"
08:21:23 <_zenon_> > randomRs (0,1) (mkStdGen 2312)
08:21:25 <lambdabot>  [1,1,1,1,0,0,0,0,1,0,0,1,0,1,0,1,0,0,1,1,1,1,0,0,0,1,1,0,0,0,1,0,0,1,1,0,1,0...
08:22:07 <_zenon_> > drop 100 $ randomRs (0,1) (mkStdGen 2312)
08:22:08 <lambdabot>  [0,0,0,0,1,1,0,0,0,0,0,1,1,1,1,1,0,0,0,1,1,0,0,1,0,1,1,0,0,0,0,0,1,1,0,0,0,0...
08:22:15 <_Dae_> @src randomRs
08:22:16 <lambdabot> Source not found. Are you on drugs?
08:22:20 <oklopol> binary looks fun
08:22:21 <ronwalf> EvilTerran: I'm on 6.8.3
08:22:45 <_zenon_> http://www.haskell.org/ghc/docs/latest/html/libraries/random/src/System-Random.html#randomRs
08:22:47 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/67r3dq
08:22:48 <ronwalf> EvilTerran: What's the extension called?
08:22:59 <EvilTerran> -XStandaloneDeriving, i think
08:23:08 <_zenon_> randomRs ival g = x : randomRs ival g' where (x,g') = randomR ival g
08:23:30 <EvilTerran> http://www.haskell.org/ghc/docs/latest/html/users_guide/deriving.html#stand-alone-deriving
08:23:31 <lambdabot> Title: 8.5. Extensions to the "deriving" mechanism, http://tinyurl.com/2ts9ot
08:23:59 <_Dae_> _zenon_: Exactly, uses randomR internally, so no difference.....
08:24:19 <Toxaris> > maximum [1, 4, 2, 6, 42, 2, 5] -- Abraxas189
08:24:20 <lambdabot>  42
08:24:45 <_zenon_> _Dae_: Yes indeed, I am not quite sure I understand your initial concern of randomR being too bad of a random source.
08:25:12 <_zenon_> I would surely not use it for high-security concerns, but I think it's enough for the casual hack :)
08:25:13 <EvilTerran> didn't someone make bindings for the mersenne twister C lib?
08:25:49 <ronwalf> boo, typeable doesn't like my *->* kinds
08:25:54 <ronwalf> (at least for derivation)
08:26:05 <_zenon_> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mersenne-random-0.1
08:26:08 <lambdabot> Title: HackageDB: mersenne-random-0.1, http://tinyurl.com/29j38a
08:26:13 <EvilTerran> yeah, typeable struggles with fancy kinds
08:26:22 <ronwalf> EvilTerran: Is it hopeless?
08:26:24 <elzurk> any german speaker here willing to help me translate a phrase?
08:26:32 <Toxaris> elzurk: sure.
08:26:34 <EvilTerran> ronwalf, i think that's what Typeable1 thru Typeable7 are for
08:26:35 <_zenon_> By default the period of the function is 2^19937-1
08:26:50 <elzurk> Toxaris: cool, "your awesome brother"
08:27:37 <elzurk> Toxaris: no need for literal transaltion, idiomatic would be best
08:27:53 <_Dae_> _zenon_:  yeah I know.... just a pitty it doesn't implement split, but I can fake that I suppose
08:27:57 <ronwalf> EvilTerran: I haven't been able to find an example of a Typeable1 instance
08:28:09 <ronwalf> (at least not with grep foo)
08:28:10 <_Dae_> _zenon_: wait.... actually I can't....
08:28:24 * ronwalf should go read the Generics paper, or something
08:28:31 <EvilTerran> ronwalf, can't ghc derive typeable1?
08:28:38 <ronwalf> oh, hm
08:28:59 <EvilTerran> (i may be wrong)
08:29:04 <_zenon_> _Dae_: Test the mersenne random then =/
08:29:39 <EvilTerran> -XDeriveDataTypeable is needed
08:29:49 <EvilTerran> "An instance of Typeable can only be derived if the data type has seven or fewer type parameters, all of kind *."
08:30:03 <EvilTerran> do you have a higher-kinded parameter or something?
08:30:08 <ronwalf> Yes
08:30:14 <_Dae_> _zenon_: IO only I believe? I know, I'm being annoying..... Ill figure something out
08:30:18 <ronwalf> EvilTerran: data Expr f = In (f (Expr f))
08:30:24 <ronwalf> That's the main kicker
08:30:29 <EvilTerran> ronwalf, eh... that looks tricky to Typeableise
08:30:46 * ronwalf dove in way over his head
08:30:55 <Toxaris> elzurk: formal language would be "Dein beeindruckender Bruder" or "Dein auﬂergewˆhnlicher Bruder" less formal adjectives maybe "stark", "toll", "super", "cool", "besonders". that's very much context dependent
08:31:11 <ronwalf> EvilTerran: It's from Wouter's Datatypes ala Carte
08:31:22 <EvilTerran> ronwalf, i recognise it - it's typelevel fix
08:31:44 <EvilTerran> ronwalf, but i don't know enough about Typeable to know how to get an instance for it
08:32:58 <elzurk> Toxaris: it is for me sister, she is out in Germany learning the lang, so, very very informal
08:33:16 <elzurk> elzurk: and I was using it as a closing to a note
08:34:11 <_zenon_> > random newMTGen
08:34:11 <lambdabot>   Not in scope: `newMTGen'
08:34:24 <Toxaris> elzurk: oh, so you are the brother the phrase is talking about, as in "I have secured funds for you to stay another year abroad, good whishes, your awesome brother"
08:36:40 <elzurk> Toxaris: yes
08:39:35 <Saul> Is there a function to convert a lazy bytestring to a string?
08:40:52 <Zao> map chr.unpack ?
08:41:44 <Zao> @type map (chr.fromIntegral).Data.ByteString.Lazy.unpack
08:41:44 <lambdabot> BSLC.ByteString -> [Char]
08:42:46 <Saul> Zao: Thanks
08:43:35 <rwbarton> (How does the compiler know that Data.ByteString.Lazy is a module name, rather than a composition of data constructors?)
08:44:47 <saml> probably name resolve is done first
08:44:48 <Zao> rwbarton: Because constructors cannot be composed?
08:44:53 <Zao> Or can they?
08:45:01 <rwbarton> :t Just.Just
08:45:02 <Toxaris> Zao: why not?
08:45:06 <lambdabot> Couldn't find qualified module.
08:45:11 <rwbarton> :t Just . Just
08:45:11 <lambdabot> forall a. a -> Maybe (Maybe a)
08:45:16 <rwbarton> interesting
08:45:22 <Zao> Ooh, they can.
08:45:30 <saml> :t Just.Just
08:45:31 <lambdabot> Couldn't find qualified module.
08:46:10 <Toxaris> > let Data = const "interesting" in Data . Data.Maybe.Just $ Data Data.Maybe.Nothing
08:46:11 <lambdabot>   Not in scope: data constructor `Data'
08:46:11 <saml> so i guess you should put spaces in between for ThisKindOfNames
08:46:25 <Toxaris> hmm ok should use data ... = Data, but cannot :(
08:46:52 * Toxaris votes for someone else adding data to lambdabot
08:47:04 <rwbarton> :t Ratio.numerator
08:47:05 <lambdabot> forall a. (Integral a) => Ratio a -> a
08:47:08 <rwbarton> :t Ratio . numerator
08:47:09 <lambdabot> Not in scope: data constructor `Ratio'
08:47:19 <rwbarton> right
08:47:33 <saml> however,  func.func.func  will probably work
08:47:40 <saml> > (id.id.id) 1
08:47:42 <lambdabot>  1
08:47:52 <saml> it's about leading capital letter
08:48:42 <saml> > (Just.id.id) 1
08:48:43 <lambdabot>   Not in scope: `Just.id'
08:48:47 <saml> > (Just .id.id) 1
08:48:48 <lambdabot>  Just 1
08:49:28 <rwbarton> > (Maybe.Just.id) 1
08:49:29 <lambdabot>   Not in scope: `Maybe.Just.id'
08:49:31 <rwbarton> > (Maybe.Just. id) 1
08:49:32 <lambdabot>   Not in scope: data constructor `Maybe.Just'
08:49:56 <saml> after ThisKindOfName, you should put space
08:50:14 <saml> i mean, if ThisKindOfName.* happens, it thinks it's module
08:50:33 <Toxaris> what a bad design. totally breaks sane parsing.
08:50:40 <rwbarton> saml: Right
08:50:48 <saml> > (id.Just .id) 1
08:50:49 <lambdabot>  Just 1
08:50:52 <saml> > (id.Just.id) 1
08:50:53 <lambdabot>   Not in scope: `Just.id'
08:51:16 <Toxaris> fortunately no prob for me, since I seperate non-interpunctuation tokens by spaces anyway
08:51:30 <saml> i want to let ( ) = .
08:51:39 * _zenon_ will start to rewrite his code using ByteString
08:51:50 <saml> and it breaks all programs. one let to break them all
08:51:57 <_zenon_> a lot of readFile and printFile
09:05:31 <hackage> Uploaded to hackage: Takusen 0.8.2
09:05:31 <hackage> Uploaded to hackage: stemmer 0.1
09:07:41 <Toxaris> we have an upload tracker? cool!
09:07:46 <Toxaris> hackage++
09:07:54 <_zenon_> lamdbabot++
09:08:09 <_zenon_> @quote lambdabot
09:08:09 <lambdabot> lambdabot says: @quote lambdabot
09:08:56 <monochrom> hahahah that's funny
09:11:10 <denq> hi everyone. i'm noob. totally. can anybody give me a hint to $ operator? i already lookup in docs, and haskell.org and can't understund it. thanks.
09:11:43 <Deewiant> @src ($)
09:11:43 <lambdabot> f $ x = f x
09:12:08 <_zenon_> denq: It's used to avoid parenthesis
09:12:29 <_zenon_> denq:  f (x i) can be rewritten as  f $ x i
09:13:00 <denq> oh! somthing bing in my brain :)
09:13:10 <schme> bing bing!
09:13:22 <_zenon_> denq: It's close and yet far away, but still similar to (.)
09:13:29 <_zenon_> @src (.)
09:13:29 <lambdabot> (f . g) x = f (g x)
09:13:29 <lambdabot> -- In lambdabot, it's been generalised to:
09:13:29 <lambdabot> (.) = fmap
09:18:58 * denq just got how stupid he is. bang!
09:19:08 <denq> thanks all!
09:19:20 <dcoutts_> @uptime
09:19:21 <lambdabot> uptime: 1d 14h 7m 14s, longest uptime: 1m 10d 23h 44m 29s
09:19:25 <_zenon_> denq: No problem. Everyone must take a first step
09:19:37 <_zenon_> denq: Except lambdabot :)
09:20:31 <dcoutts_> byorgey: was it you who was looking at lambdabot's memory consumption?
09:23:04 <quicksilver> @remember denq oh! something bing in my brain :)
09:23:04 <lambdabot> Okay.
09:39:33 <marcot> Is it a known bug that GHC doesn't know how to count lines with {-# OPTIONS_GHC -cpp #-}
09:39:36 <marcot> ?
09:41:05 <_zenon_> no idea
09:45:27 <_zenon_> this transition to using ByteString was tough
09:45:36 <_zenon_> still some error messages
09:46:12 <BMeph> marcot: Yes, it is known, and being worked on.
09:47:50 <marcot> BMeph: ok.
09:48:19 <leadnose>  /wc
09:53:12 <ddarius> :t msum
09:53:13 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
09:54:38 <Baughn> @instances MonadPlus
09:54:38 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
09:54:48 <FordCortina> is "(-> Int)" the same as "a -> Int"?
09:55:03 <quicksilver> they are related.
09:55:16 <quicksilver> (-> Int) is not real haskell notation
09:55:26 <FordCortina> i mean "(->) Int" the same as "a -> Int"
09:55:29 <quicksilver> kahwas i
09:55:35 <quicksilver> subtly differently.
09:55:36 <_zenon_> ?ty (->)
09:55:36 <quicksilver> no :)
09:55:37 <lambdabot> parse error on input `->'
09:55:42 <quicksilver> (->) Int is the same as
09:55:45 <quicksilver> Int -> ...
09:55:51 <quicksilver> where the ... has not been filled in.
09:55:54 <_zenon_> data (->) a b   -- Defined in GHC.Prim
09:56:05 <Toxaris> :t (undefined :: (-> Int))
09:56:05 <lambdabot> parse error on input `Int'
09:56:06 <quicksilver> (->) Int b is the same as Int -> b
09:56:16 <Toxaris> why is that not real haskel notation?
09:56:22 <_zenon_> just prefix / infix
09:56:27 <quicksilver> Toxaris: haskell doesn't support type-level sections.
09:56:29 <FordCortina> ic...
09:57:29 <FordCortina> > class Foo a where
09:57:30 <lambdabot>  Parse error at "class" (column 1)
09:57:32 <Toxaris> thinking about it, probably because there is no type-level flip, because there are no type-level functions (ignoring newtypes)
09:57:39 <FordCortina> > class Foo a
09:57:39 <lambdabot>  Parse error at "class" (column 1)
09:57:51 <Toxaris> FordCortina: lambdabot understands expressions only
09:58:15 <quicksilver> Toxaris: there are type-level functions. What there aren't is *general* type level functions.
09:58:38 <quicksilver> Toxaris: Maybe is a type-level function. And fundeps give rise to another sort of type level function.
09:58:47 <Abraxas189> let x=[1..9] and y=[9..1], i don't understand the result of query [z| z<-x, z<-y]
09:59:05 <Abraxas189> y 9 times in a row
09:59:08 <vixey> > let x=[1..9] and y=[9..1], [z| z<-x, z<-y]
09:59:08 <lambdabot>  Parse error at "=[9....." (column 19)
09:59:16 <vixey> > let x=[1..9] ; y=[9..1] in [z| z<-x, z<-y]
09:59:19 <lambdabot>  []
09:59:29 <Toxaris> quicksilver: yeah, I mean non-free / restricted / defined / whatever functions, e.g. not data constructors
09:59:35 * quicksilver nods
09:59:54 <Toxaris> ehm, not data type constructors
09:59:57 <Abraxas189> wasn't supposed to be haskell syntax, hehe
10:00:12 <quicksilver> Toxaris: well the contrast is that haskell supports arbitrary value-level functions, so sections make sense, but not arbitrary type-level ones :)
10:00:13 <Baughn> Abraxas189: Then what was it supposed to be?
10:00:17 <vixey> ok, why don't you use haskell syntax
10:00:29 <Abraxas189> let was just english :p
10:00:47 <vixey> alright but I still have no idea what expression you were thinking about
10:01:08 <dbueno> > let x=[1..9] ; y=[9,8..1] in [z| z<-x, z<-y]
10:01:09 <lambdabot>  [9,8,7,6,5,4,3,2,1,9,8,7,6,5,4,3,2,1,9,8,7,6,5,4,3,2,1,9,8,7,6,5,4,3,2,1,9,8...
10:01:30 <Abraxas189> yup
10:02:02 <Abraxas189> i see, i can directly check it here
10:02:05 <Baughn> @src [] >>=
10:02:05 <lambdabot> Source not found. Wrong!  You cheating scum!
10:02:08 <Abraxas189> sweet
10:02:11 <Baughn> @src [] (>>=)
10:02:11 <lambdabot> xs >>= f     = concatMap f xs
10:02:20 <FordCortina> @hoogle (->) Int
10:02:21 <lambdabot> Prelude.undefined :: a
10:02:21 <lambdabot> Test.QuickCheck.Batch.bottom :: a
10:02:21 <lambdabot> Prelude.id :: a -> a
10:02:22 <ddarius> Abraxas189: The latter z shadows the first.
10:02:26 <Toxaris> quicksilver: could (`A` b) be translated to (forall a' . Flip A a' => a' b)?
10:02:44 <Baughn> @undo do z <- [1..9]; z <- [9,8..1]; return z
10:02:44 <lambdabot> [1 .. 9] >>= \ z -> [9, 8 .. 1] >>= \ z -> return z
10:02:47 <Abraxas189> ah
10:02:51 <ddarius> Maybe you want [z | z <- x, z' <- y, z == z'] ?
10:02:59 <dbueno> > let x=[1..9] ; y=[9,8..1] in [z| z<-x, a<-y, a == z]
10:03:01 <lambdabot>  [1,2,3,4,5,6,7,8,9]
10:03:03 <quicksilver> Toxaris: you can make a Flip newtype
10:03:12 <Abraxas189> no, it's a task
10:03:16 <quicksilver> Toxaris: but because it's a different type, it's not quite general.
10:03:16 <Abraxas189> just like that
10:03:39 <FordCortina> im still confused :( . "(->) a" is a valid haskell type, right?
10:03:44 <quicksilver> Toxaris: you don't quite get true Flip which would lead to type level lambda which would lead to undecidable type inference.
10:03:50 <Abraxas189> because of x it's executed 9 times and then y is just running through each time, right?
10:03:54 <quicksilver> FordCortina: not in the strict sense of the word type, no
10:04:03 <quicksilver> FordCortina: it's a partial type, an unfinished type
10:04:05 <rwbarton> :k (->) Int
10:04:05 <lambdabot> ? -> *
10:04:06 <Baughn> FordCortina: It's a type cnstructor, at best
10:04:09 <quicksilver> "a partially applied type constructor"
10:04:23 <quicksilver> FordCortina: it needs one more parameter before it's a "proper" type.
10:04:27 <rwbarton> FordCortina: It's just like Maybe, say
10:04:29 <Toxaris> quicksilver: well, I want (`A` X) Y === A Y X, of course, with === denoting "the very same thing"
10:04:39 <Abraxas189> i was thinking it would end up being y, because y is not running all the way into z each time
10:04:40 <quicksilver> Toxaris: right, and that's what you can't get.
10:04:53 <quicksilver> Toxaris: you can only get an isomorphism with named edges.
10:04:55 <FordCortina> quicksilver: ah ic
10:05:03 <quicksilver> Toxaris: any close than that and your type system goes undecidable as I understand it.
10:05:27 <Baughn> Abraxas189: No, it's positionaql
10:05:38 <Toxaris> quicksilver: well, that proves that you need -XUndedicableInstances to emulate it with typeclasses, but nothing more :)
10:05:58 <FordCortina> so (->) a, i like "Maybe". which is why you can have "instance Applicative ((->) a)", just as well as "instance Applicative Maybe"
10:06:03 <FordCortina> is*
10:06:09 <dbueno> Abraxas189: List comprehensions desugar into more other haskell functions, as described in the report: http://haskell.org/onlinereport/exps.html#list-comprehensions
10:06:09 <lambdabot> Title: The Haskell 98 Report: Expressions
10:06:12 <quicksilver> Toxaris: right, but that still hides the undecidability off in the class system, not the type system proper.
10:06:22 <quicksilver> Toxaris: you still have a principle type for a term.
10:06:26 <dbueno> Abraxas189: If you understand the desugaring, you can understand the result.
10:06:36 <quicksilver> Toxaris: what you don't have is a decidable algorithm to decide if a given principle type is a member of a class.
10:07:31 <FordCortina> so, ((->) a) is the type constructor of the "type of functions that go to a"?
10:07:42 <Baughn> FordCortina: From a
10:07:44 <quicksilver> from a
10:07:45 <Toxaris> FordCortina: that come from a
10:07:51 <Abraxas189> but you came up with desugaring, it's not in the report?
10:07:56 <FordCortina> ah
10:08:36 <dbueno> Abraxas189: I'm not sure I understand ... I linked to the section of the report where the desugaring is mandated and described as a set of equations.
10:08:48 <Toxaris> FordCortina: thats exactly the point of my discussion with quicksilver, that you cannot write the "type of functions that go to a" directly in Haskell, because you can only abstract over the last parameters of type constructors, not the first parameters
10:09:09 <vixey> yes you can
10:09:16 <vixey> type a :<-: b = a -> b
10:09:17 <Abraxas189> i couldn't find the term mentioned
10:09:24 <vixey> this isn't haskell 98 though..
10:09:31 <vixey> oh wait you can't partially apply it ?
10:09:39 <vixey> oops
10:09:42 <dbueno> Abraxas189: If you go here: http://haskell.org/onlinereport/
10:09:43 <lambdabot> Title: The Haskell 98 Language Report
10:09:43 <vixey> I meant b :<-: a
10:09:55 <dbueno> Abraxas189: Then go to section 3.11
10:10:10 <vixey> *Main> :k ((:<-:) Integer)
10:10:11 <vixey> ((:<-:) Integer) :: * -> *
10:10:13 <vixey> seems to work
10:10:15 <FordCortina> right to (a (->)) doesnt mean anything in Haskell then? or does that still mean "from a"?
10:10:28 <vixey> FordCortina: what's a ?
10:10:48 <FordCortina> a is any type
10:10:51 <Toxaris> vixey: that's not a type constructors, it's a macro evaluated at read-time
10:10:57 <Toxaris> vixey: as I undestand type
10:11:14 <vixey> FordCortina: it will be a kind error for example if a = Integer
10:11:28 <FordCortina> vixey: i started getting confused when i saw, "instance Applicative ((->) a) where ..."
10:11:33 <Toxaris> vixey: so you cannot define, e.g., instance Cofunctor (:<-: a) where ...
10:12:17 <Toxaris> vixey: otherwise, you could define type K a b = b; type S f g x = f (g x); and your type system would be turing complete, I guess.
10:13:08 <quicksilver> FordCortina: (a (->)) means "the type constructor "a" applied to (->)
10:13:24 <quicksilver> FordCortina: which would be permissible if a was a slightly exotic higher kinded constructor, yes.
10:13:53 <dons> ?yow
10:13:53 <lambdabot> Couldn't find fortune file
10:13:53 <quicksilver> FordCortina: if you want a value equivalent, compare it to "zipWith (+)"
10:13:58 <djsiegel> I'm writing a wikipedia crawler, and I need to send a useragent string so that wp doesn't deny access. Text.HTML.Download doesn't seem to provide any features for this. Does anyone know where I can find useragent stuff?
10:14:03 <quicksilver> FordCortina: which is "zipWith" applied to the function (+)
10:14:10 <FordCortina> right
10:14:10 <dons> djsiegel: use the curl binding.
10:14:18 <dons> djsiegel: Text.HTML.Download is just a toy
10:14:24 <djsiegel> thanks, dons -
10:14:30 <dons> there's a nice interface to curl provided by download-curl
10:14:41 <dons> much the same as Text.HTML.Download, but you can get at the internals of curl
10:14:48 <djsiegel> dons, will cabal install now
10:16:06 <Abraxas189> ah, alright, got it (i think): this is equivalent: [z|x<-x, z<-y]...although x<-x is nonsense
10:16:13 <Toxaris> @type (undefined :: ArrowMonad (->) ())
10:16:14 <lambdabot> ArrowMonad (->) ()
10:16:28 <vixey> > [ x | x <- x ]
10:16:29 <lambdabot>  Couldn't match expected type `[t]' against inferred type `Expr'
10:16:32 <vixey> > [ x | x <- 1 : x ]
10:16:33 <lambdabot>  Couldn't match expected type `[t]' against inferred type `Expr'
10:16:47 <vixey> > let x = [()] in [ x | x <- x ]
10:16:48 <lambdabot>  [()]
10:17:03 <quicksilver> Toxaris: good example :)
10:18:21 <FordCortina> !paste
10:18:21 <hpaste> Haskell paste bin: http://hpaste.org/
10:18:26 <Abraxas189> first one doesn't matter except for that z will be (length x) times concatenation of y?
10:19:10 <djsiegel> dons, I can't build curl package -- it says I'm missing curl libraries. I have libcurl and curl installed, do I need libcurl-dev or something?
10:19:25 <dons> hmm. no, just libcurl. check that its in your path.
10:20:27 <zenon__> @pl filter (\x -> head x /= '.')
10:20:27 <lambdabot> filter (('.' /=) . head)
10:21:04 <vixey> not . startsWith "."
10:21:43 <zenon__> vixey: which module?
10:21:51 <geezusfreeek> @hoogle startsWith
10:21:52 <lambdabot> No matches found
10:21:54 <Abraxas189> did i get it?
10:22:34 <vixey> @ty flip isPrefixOf
10:22:34 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
10:22:38 <hpaste>  FordCortina pasted "kind error?" at http://hpaste.org/8833
10:23:02 <FordCortina> im still a bit confused about this (->) a stuff
10:23:18 <FordCortina> why does i cant a i make it an instance of my dummy class Foo?
10:23:18 <zenon__> vixey: Where did you find that startsWith ?
10:23:28 <FordCortina> why cant*
10:23:35 <vixey> I just made up the name
10:23:40 <zenon__> ahhhh
10:23:46 <dcoutts_> @hoogle [a -> a] -> (a -> a)
10:23:46 <vixey> this is common practice
10:23:46 <lambdabot> No matches, try a more general search
10:23:53 <FordCortina> why cant* i make it an instance...
10:23:57 <vixey> :t foldr (.) id
10:23:58 <lambdabot> forall a. [a -> a] -> a -> a
10:25:21 <FordCortina> @kind Maybe
10:25:22 <lambdabot> * -> *
10:25:32 <FordCortina> @kind ((->) a)
10:25:33 <lambdabot> Not in scope: type variable `a'
10:25:38 <FordCortina> @kind ((->) Int)
10:25:39 <lambdabot> ? -> *
10:27:09 <vixey> FordCortina: the kind of a is assumed *
10:27:31 <kig> @hoogle a -> (a -> b) -> b
10:27:31 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
10:27:31 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
10:27:31 <lambdabot> Data.Function.($) :: (a -> b) -> a -> b
10:27:45 <FordCortina> vixey: i think im understanding now
10:28:10 <vixey> Toxaris: hey here's a thought
10:28:16 <Abraxas189> ok, one more time on this: [z| z<-x, z<-y]...the first z is replaced by sth else, is that it?
10:28:48 <FordCortina> "a" in Foo has to be Functor
10:28:51 <Abraxas189> i'd expect it to be other way around, but no
10:29:02 <Toxaris> quicksilver: I guess I would end up with wrapping everything in newtypes, including newtype Apply t x = Apply (t x). then I could write class Normalize t t' | t -> t' and enable every extensions ghc knows about, and would end up with an untyped lambda calculus as type system.
10:29:02 <vixey> Toxaris: Oh nevermind, I was going to say since simply typed calculus is normalizing maybe we could use that as types, but then giving names to them would make it TC so nevermind that..
10:29:09 <FordCortina> for anything with kind *->* to be an instance of Foo
10:29:58 <hpaste>  marcot pasted "xmonad Read" at http://hpaste.org/8834
10:30:33 <marcot> Sorry, this is for #xmonad, I should have unchecked announce.
10:30:52 * vixey gives up on haskell-indentation mode
10:31:21 <Toxaris> vixey: well, you can easily extend FOmega to have unlimited levels / universes. Lets call that one FOmegaOmega, since it is unlimited in another dimension. Now, you have FOmegaOmega typed in FOmegaOmega. If you avoid to include fix, both the value and all of the type levels are normalizing. unfortunately, neither of them is TC, of course.
10:32:04 <vixey> Toxaris: If you made the value level TC would the type and kind and ... levels remain normalizing ?
10:32:39 <Toxaris> vixey: I guess so, since they would remain, well, the same? (assumed we don't add dependent typing or something crazy like it)
10:33:02 <Toxaris> vixey: but I have no intuition which types you could express with that type system
10:33:26 <Toxaris> clearly, you want some kind of type-level fixed point combinator to express real-world types, like, say, lists
10:37:12 <dons> http://www.reddit.com/info/6r64b/comments/ just cause its cool
10:37:12 <lambdabot> Title: reddit.com: Parallel map-reduce in one line of Haskell : "bump all your cores to ...
10:41:29 <ronwalf> How would 'Either' derive Typeable1
10:43:35 <sjanssen> dons: "a . f = f a
10:43:38 <sjanssen> yuck
10:43:50 <lilachaze> sjanssen: i thought it was pretty neat :)
10:43:56 <sjanssen> NOOOOO!
10:43:58 <sjanssen> :)
10:44:17 <vixey> that's bizarre
10:44:30 <dons> sjanssen: hehe
10:44:41 <sjanssen> some people like composition in that order, which is okay.  Just use an operator other than (.) to do it
10:45:03 <vixey> sjanssen: no the problem isn't using (.) it's writing: xs.split_to(n).map(m).p_reduce'(r)
10:45:09 <dons> "warning: i'm using a very annoying coding style, by redefining the (.)
10:45:09 <dons> operater to be reverse application. Please forgive me and metally transform
10:45:10 <dons> the order, or just pretend you are reading Java / Python / Ruby"
10:45:20 <lilachaze> sjanssen: but the poor OO types! they can only cope with "." "->" or "::" -- and . is the only one which is user-definable
10:45:24 <hpaste>  marcot annotated "xmonad Read" with "Problem generalized" at http://hpaste.org/8834#a2
10:45:27 <sjanssen> vixey: yeah, that is also annoying
10:45:37 <vixey> It's not annoying .. just so weird
10:45:47 <vixey> oh
10:45:48 <vixey> parseFromFile parser filename = readFile filename >>= return . parse parser filename
10:45:49 <marcot> What's the problem with this code?  How can I unbox a generalized data type?
10:45:57 <vixey> can that be written better ?
10:46:02 <sjanssen> lilachaze: they're not stupid -- it isn't that they can't learn something else, it's just that they haven't
10:46:19 <sjanssen> vixey: fmap (parse parser filename) $ readFile filename
10:46:41 <lilachaze> sjanssen: that last comment was intended to be somewhat tongue-in-cheek; i'm primarily an OO guy myself :)
10:46:41 <vixey> oh cool
10:46:47 <RayNbow> <dons> http://www.reddit.com/info/6r64b/comments/ just cause its cool <-- shouldn't sum in "p_map_reduce sum (+) xs" be replaced by "id"?
10:46:48 <lambdabot> Title: reddit.com: Parallel map-reduce in one line of Haskell : "bump all your cores to ...
10:47:44 <Abraxas189> let x=[1..9] ; a=9 in ([a| a `mod` 2 == 0, a<-x], [a| a `mod` 2 == 1, a<-x])
10:47:52 <lilachaze> "... in one line of haskell (but it needs to be the *right* line)" :)
10:48:07 <sjanssen> this isn't one line of Haskell either
10:48:16 <dons> i've a theory that every problem can be solved in one line of haskell.
10:48:21 <dons> the issue is indeed finding that line.
10:48:28 <dons> hint: its in category-extras somewhere
10:48:30 <lilachaze> dons: got a line length limit? :)
10:48:53 <sjanssen> that's it, I'm refactoring this to prove that true Haskell style is beautiful
10:49:29 <lilachaze> dons: i have a theory that every meaningful text transformation is possible in fewer than 100 bytes of perl.
10:50:01 <lilachaze> and that's only about 50% joke
10:50:24 <Valodim> so 200 bytes?
10:50:32 <EvilTerran> "translate from english to french"... go!
10:50:36 <dolio> @seen edwardk
10:50:37 <lambdabot> I saw edwardk leaving #haskell-blah and #haskell 17h 41m 36s ago, and .
10:51:03 <RayNbow> http://www.youtube.com/watch?v=xaoLbKWMwoU <-- this is something I didn't expect to find on YouTube :p
10:51:04 <lambdabot> Title: YouTube - Haskell music 2
10:51:27 <kiris> raynbow: yes, that's quite spiffy
10:52:10 <hpaste>  _zenon_ pasted "Can't get this error straight" at http://hpaste.org/8835
10:52:44 <Abraxas189> doesn't work because of linebreak?
10:52:46 <Abraxas189> let x=[1..9] ; a=9 in ([a| a `mod` 2 == 0, a<-x], [a| a `mod` 2 == 1, a<-x])
10:53:00 <pejo> lilachaze, haven't you ever tried to "convert" some freetext-format with an unclear specification to a more structured one?
10:53:15 <zenon__> Been trying to migrate to ByteString, but it won't get smooth
10:53:26 <zenon__> Still some wrinkles, someone care to look at the paste?
10:54:54 <dolio> Which line is 37?
10:55:18 <zenon__> $ L.map BS.words                  -- ["hello","there","A"]
10:56:08 <dolio> Okay. That turns it into something like [["hello"],["there"],["A"]]
10:56:12 <kiris> that would produce a list of lists
10:56:24 <zenon__> I just concat'
10:56:30 <zenon__> found that now :)
10:56:36 <zenon__> however, still some type error
10:56:41 <Toxaris> lilachaze: add a constant header to the text of size 100 byte (e.g., a legal disclaimer).
10:57:02 <zenon__> thanks .
10:57:18 <zenon__> Sometimes just need to show the code to find it myself :/ weird
10:57:44 <dolio> :)
10:58:29 <kiris> why not BS.readFile ("./files/"++f) >>= liftM $ L.map (BS.map toLower) . L.filter (\x -> L.length x > 1) etc.?
10:59:49 <kiris> :t liftM
10:59:49 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
11:00:12 <zenon__> kiris: I find this layout nicer
11:00:38 <zenon__> why the other layout?
11:01:02 <kiris> it's pointless
11:01:17 <zenon__> :)
11:03:34 <lilachaze> Toxaris: almost any meaningful text is compressible :)
11:04:15 <Toxaris> lilachaze: interesting. show me a perl-compress for text "hello" :)
11:04:33 <kiris> the smiley means ‚Äúhappiness‚Äù
11:04:58 <Toxaris> my :) sometimes mean ;)
11:05:25 <lilachaze> Toxaris: that compresses down to the empty string, using a new compression algorithm i just developed called 'hellocompress'. hellocompress "hello" = ""; hellocompress "" = "hello"; hellocompress x = x
11:05:43 <lilachaze> Toxaris: translation into perl is left as an exercise to the reader :)
11:06:04 <Toxaris> lilachaze: I want to sea the reader who does it in less then length("hello") bytes of perl.
11:06:49 <EvilTerran> shoot, "use Acme::Bleach;" is too long
11:07:07 * lilachaze considers running all 4-byte perl programs to see what happens :)
11:07:37 <zenon__> 4-byte perl code or 4-byte machine code?
11:07:47 <monochrom> 4-byte perl code
11:08:01 <kiris> a byte as in an octet?
11:08:16 <monochrom> Yes. Probably meant to be an ASCII character.
11:08:29 <zenon__> :/, means really nothing then. You can device a language which uses just 1 byte but that translates to 1 GB machine code,
11:08:41 <monochrom> > replicateM 4 [' '..'|']
11:08:42 <lambdabot>  ["    ","   !","   \"","   #","   $","   %","   &","   '","   (","   )","   ...
11:08:59 <kiris> valid perl code
11:09:01 <monochrom> pump that through perl :)
11:09:01 <gbacon> gwern: have you run lambdabot with plugins-1.2?
11:09:06 <lilachaze> well, ASCII unless certain bytes cause the perl interpreter to crash in such a way that it prints "hello"
11:09:21 <monochrom> too lazy to check validity. let the perl interepreter deal with it :)
11:09:24 <gwern> gbacon: no. I never can link lambdabot
11:09:29 <zenon__> eeeeewwwwwwwww
11:09:36 <zenon__> this apple I am eating smells like pee
11:09:46 <gbacon> gwern: oh, I'm linking fine, but runplugs isn't happy
11:09:46 * zenon__ spits out apple piece
11:09:47 <monochrom> congrats
11:09:47 <byorgey> dcoutts_: nope, wasn't me looking at \bot memory usage
11:09:56 <lilachaze> zenon__: "all natural pesticides"
11:09:59 <dcoutts_> byorgey: oh, right'o
11:10:22 * zenon__ should have washed the apple, damn it!
11:10:44 <kiris> never eat yellow apples
11:10:51 <zenon__> snow
11:10:53 <zenon__> it's snow
11:11:06 <zenon__> remember, yellow kokaine == pee
11:11:11 <gwern> all natural pesticides are better than artificial ones. at least with the natural pre-existing ones, there's a chance we have tolerance
11:12:06 <sjanssen> gwern: it takes gobs of memory to link lambdabot
11:12:15 <zenon__> Yeah, I sincerely hope it's not pee
11:12:17 <zenon__> honestly
11:12:49 <zenon__> I don't want to put something into my mouth that passed through a mans / womans weewee
11:12:51 <kiris> we have two apple trees and a pear tree in our garden. the pear tree fights pests by simply not producing any pears. it's very effective
11:16:33 * monochrom teases zenon__ with the nitrogen cycle, the carbon cycle, the water cycle, ... :)
11:16:50 <Abraxas189> how does the lambdabot work?
11:17:08 <kiris> please be more specific
11:17:24 <int-e> @faq
11:17:25 <lambdabot> The answer is: Yes! Haskell can do that.
11:17:28 <gbacon> newsham: did you find the fix for your runplugs problem?
11:17:38 <vixey> Abraxas189: it doesn't
11:17:49 <kiris> yes, it does not even support unicode
11:18:09 <Abraxas189> that's mean
11:18:15 <newsham> gba: yes.  i had stale .o and .hi files laying around.
11:18:27 <Abraxas189> you say the lambdabot is lazy?
11:18:29 <newsham> removed all .hi and .o and rebuilt
11:20:32 <zenon__> Still having ByteString issues
11:21:18 <gbacon> newsham: any insight on why it was causing the unresolved symbol?
11:21:58 <hpaste>  _zenon_ pasted "ByteString problems" at http://hpaste.org/8837
11:22:33 <newsham> i had some local modifications, that may have contributed
11:23:05 <newsham> gba: did you clean out your .hi's and .o's and build clean?
11:23:11 <newsham> does your runplugs still complain?
11:23:44 <Saul> I have a function of type :: (a -> IO b) -> a -> IO [b], how can I lift this to (MonadIO m) => (a -> m b) -> a -> m [b]?
11:24:13 <gbacon> newsham: I did, and yes
11:24:25 <dolio> zenon__: I think it's L.length. Shouldn't it be BS.length?
11:24:26 <gbacon> newsham: and this is with a mostly clean lambdabot repo
11:24:35 <zenon__> dolio: I'll try
11:24:54 <newsham> which error do you get?
11:24:56 <zenon__> dolio:I'll be damned, you got it
11:24:59 <zenon__> dolio++
11:25:03 <zenon__> @karma dolio
11:25:03 <lambdabot> dolio has a karma of 1
11:25:05 <Saizan> gbacon: have you run @undefine ?
11:25:05 <zenon__> :)
11:25:10 <dolio> What?
11:25:12 <dolio> @karma
11:25:12 <lambdabot> You have a karma of 1
11:25:13 <gbacon> same as you:  /tmp/MOquC26046.o: unknown symbol `__stginit_L_'
11:25:25 <zenon__> dolio: thanks
11:25:31 <gbacon> Saizan: no, what will that do?
11:25:40 <dolio> Someone removed all my karma! :)
11:25:56 <dolio> @karma dons
11:25:56 <lambdabot> dons has a karma of 0
11:26:03 <dolio> Oh well, I'm higher than dons. :)
11:26:07 <Saizan> gbacon: refresh/generate L.hi and L.o
11:26:09 <zenon__> dolio: I think they where all reset
11:26:11 <gbacon> Saizan: whatever it was, that did it
11:26:11 <lilachaze> dons++
11:26:12 <lilachaze> dons++
11:26:17 <lilachaze> @karma dons
11:26:17 <lambdabot> dons has a karma of 2
11:26:19 <dolio> No!
11:26:35 <Saul> dolio--
11:26:37 <Saul> :)
11:26:37 <gbacon> newsham, Saizan: thanks!
11:26:44 <Saul> @karma dolio
11:26:44 <lambdabot> dolio has a karma of 0
11:27:15 <newsham> err.. yah, i forgot about the L.o thing
11:27:44 <dons> cool
11:27:47 <dons> all my karmas
11:28:00 <dons> man , i was going to cash those in this week too
11:28:01 <gbacon> are belong to us!!!1!
11:28:13 <dolio> dons: Not to pester, but is there something wrong with my uvector patches? :)
11:28:13 <Saul> Speaking of karma:
11:28:16 <Saul> I have a function of type :: (a -> IO b) -> a -> IO [b], how can I lift this to (MonadIO m) => (a -> m b) -> a -> m [b]?
11:28:35 <dons> dolio: i've a full time job :)
11:29:07 <dolio> Okay. So you just haven't gotten to them yet.
11:29:31 <Saizan> Saul: you've to rewrite it
11:29:50 <dolio> Yeah, you'd need unliftIO for that.
11:29:54 <Saul> Saizan: I can't it's in a library
11:30:11 <therp> interesting, I just crafted a 65kb file that kills haskell-mode.
11:30:45 <kiris> what is interesting about it?
11:30:46 <therp> ah almost. 1 minute processing time, for 3 lists of lists containing tuples..
11:30:49 <Saul> Well thanks
11:30:56 <zenon__> It's not possible to use both System.IO.Strict and Data.ByteString   ?
11:31:05 <zenon__> I'm trying to speed up my code
11:31:07 <dons> of course its possible :)
11:31:20 <dons> but just using strictness doesn't make things fast :)
11:31:27 <zenon__> hmmm..... I'm thinking wrong then
11:31:28 <dons> esp. since System.IO.Strict is for string IO
11:31:30 <kiris> @faq
11:31:31 <lambdabot> The answer is: Yes! Haskell can do that.
11:31:44 <zenon__> exactly, my point String /= ByteString
11:31:54 <dons> choose one :)
11:32:36 <zenon__> I'll go for bytestring, already rewritten it to use it
11:32:42 <dolio> What's in System.IO.Strict that's appealing?
11:32:58 <frankblack> by the way - why is the unequal comparator != ?
11:32:59 <dons> a string readFile that doesn't need rnf
11:33:04 <zenon__> I thought it would let me open more files
11:33:04 <dons>  /=
11:33:07 <frankblack> aeh - not - !=
11:33:12 <dons> zenon__: use Data.ByteString for lots of files
11:33:39 <frankblack> is there some deep reason I will understand sometime in the future?
11:33:54 <dolio> Oh, is that all? You can do that with readFile into a strict bytestring.
11:34:08 <dcoutts_> dons: btw, I'm back, we should work on the announcement stuff
11:34:15 <kiris> dolio: what if you want it into a String?
11:34:19 <monochrom> ‚â† and /= look alike, for example the /
11:34:21 <dons> dolio: right.
11:34:27 <dons> dcoutts_: great
11:34:27 <frankblack> ah
11:34:30 <dolio> kiris: Why would you want that? :)
11:34:49 <vixey> @pl Left . declaration <|> Right . definition
11:34:50 <lambdabot> Left . declaration <|> Right . definition
11:34:58 <vixey> @pl \declaration definition -> Left . declaration <|> Right . definition
11:34:58 <lambdabot> (. (Right .)) . (<|>) . (Left .)
11:35:53 <kiris> dolio: it has been faster than using ByteString for me in one instance, perhaps I would want it for speed
11:36:55 <zenon__> thing is, I am reading a lot from file -- processing and the writing to file
11:36:57 <zenon__> a lot
11:37:11 <dolio> I find it hard to believe that doing the exact same operations (including strictness) on a String and a ByteString would result in the String being faster.
11:37:13 <zenon__> So I went for ByteString
11:37:16 <kiris> dolio: maybe the question should be why is lazy IO the default and not the other way round?
11:37:29 <dolio> And if it does happen, dons would probably want to know about it.
11:37:36 <kiris> dolio: well, maybe I can provide you with some code to test
11:39:34 <dolio> I'll look at it if you provide it.
11:45:00 <vixey> file = many line <* eof
11:46:11 <dons> well, there's strictness v laziness issue. but i've not seen String faster in the wild.
11:47:56 <kiris> dolio: in my example I wanted a String in both instances. maybe you meant either working with a String or a ByteString exclusively
11:48:06 <DRMacIver> Doesn't String have better complexity than strict ByteStrings in some cases?
11:48:53 <dolio> kiris: Yeah, I meant working with ByteString exclusively. If you're reading a bytestring, unpacking to a string, doing stuff, repacking to a bytestring, and writing, I could see that being slower than just using String.
11:49:04 <kiris> dolio: indeed
11:49:37 <dons> yeah, don't unpack. otherwise it's String that is killing you, not bytestring
11:49:49 <Mitar> this is not possible: [(x,y) | y <- [4..0], x <- [5..0]]
11:49:51 <Mitar> @pl [(x,y) | y <- [4..0], x <- [5..0]]
11:49:51 <lambdabot> [(x, y) | y <- [4..0], x <- [5..0]]
11:50:05 <dolio> DRMacIver: I doubt it will have better complexity than if you stick rnf on all your string operations to make the strings strict.
11:50:26 <dolio> Unless you're talking, like, single character strings, where bytestring might have slightly more overhead.
11:50:37 <kiris> in this instance using ByteString exclusively was slower than String. I suspect because I was allocating lots of new ones
11:51:47 <Mitar> [(x,y) | y <- reverse [0..4], x <- reverse [0..5]]
11:52:18 <vixey> > [4,3..0]
11:52:19 <lambdabot>  [4,3,2,1,0]
11:53:21 <DRMacIver> dolio: I was thinking in terms of concatenate and prepend operations. Strict bytestrings are packed arrays aren't they? If so, smallString ++ largeString should be faster than smallByteString ++ largeByteString
11:53:44 <DRMacIver> oh, ByteSTring doesn't have ++. But whatever the concat operation is for bytestrings
11:53:55 <dolio> Yeah, that's true.
11:54:13 <DRMacIver> But lazy ByteString shouldn't have this problem I think
11:54:46 <dolio> Although if I wanted to get out on a technicality, rnf would re-force the entire list. :) But that's just extra work for a no-op.
11:55:12 <DRMacIver> True. :)
11:55:44 <Mitar> > let a = 4 in [(x,y) | y <- [a,(a-1)..0], x <- [5..0]]
11:55:45 <lambdabot>  []
11:56:47 <Mitar> why empty?
11:57:07 <vixey> > let a = 4 in [a,(a-1)..0]
11:57:08 <lambdabot>  [4,3,2,1,0]
11:57:13 <vixey> > [5..0]
11:57:14 <lambdabot>  []
11:57:35 <vixey> > [(x,y) | y <- [4,3,2,1,0], x <- []]
11:57:36 <lambdabot>  []
11:57:36 <Mitar> ahh, yes :-)
11:57:37 <DRMacIver> In unrelated news, the coding style from that map reduce thread makes me weep.
11:57:54 <Mitar> anything nicer than (a-1) there?
11:58:08 <dons> DRMacIver: let's petition Cale to redefine (.) like this in lambdabot for a day
11:58:10 <vixey> downFrom a
11:58:16 <DRMacIver> Egads. The horror!
11:58:27 <vixey> downFrom x = [x,x-1..0]
11:58:47 <RayNbow> Mitar, you probably don't need the parentheses around a-1
11:59:04 <Mitar> true
11:59:18 <vixey> Mitar: You can define a new function
11:59:23 <vixey> @let downFrom x = [x,x-1..0]
11:59:23 <lambdabot> Defined.
11:59:25 <kiris> dolio: if you're interested here's the program with String and ByteString comparison: http://hpaste.org/8838
11:59:25 <vixey> > downFrom 100
11:59:26 <lambdabot>  [100,99,98,97,96,95,94,93,92,91,90,89,88,87,86,85,84,83,82,81,80,79,78,77,76...
12:01:03 <RayNbow> @pl downFrom x = [x,x-1..0]
12:01:03 <lambdabot> downFrom = flip (ap enumFromThenTo (subtract 1)) 0
12:01:11 <kiris> dolio: foo.txt is all of #haskell's IRC logs from June and July, if I recall correctly, with parts/joins and nicknames removed
12:01:26 <RayNbow> @pl downFrom x = [x,pred x..0]
12:01:26 <lambdabot> downFrom = flip (ap enumFromThenTo pred) 0
12:02:48 <dolio> kiris: You're using lazy IO for Strings and strict IO for ByteStrings?
12:03:28 <kiris> dolio: yes
12:03:49 <dolio> I don't think that's surprising, then.
12:04:31 <dolio> You're allocating way more memory all at once with the strict IO.
12:05:30 <kiris> dolio: with `return $! length contents' to strictly evaluate it, it takes the same amount of time save around 100ms improvement
12:05:56 <kiris> dolio: what is the strict IO module called? I want to try it with proper strict IO
12:06:15 <dolio> It's on hackage. I think it's just a package called "strict".
12:06:41 <ronwalf> Huh, Data.Derive doesn't compile from darcs, and doesn't seem to install the executable from hackage
12:07:24 <dolio> I don't understand why you wouldn't use lazy bytestrings for this, though.
12:07:36 <dolio> This is clearly a case where you don't want strict IO.
12:08:21 <zenon__> Is lazy bytestring to prefer in most cases?
12:08:22 <hpaste>  kiris annotated "String faster than ByteString for certain operation" with "Strict IO" at http://hpaste.org/8838#a3
12:08:41 <dolio> histogram might be better with foldl', too, I'm not sure.
12:08:47 <dolio> Or fromListWith' if that exists.
12:08:53 <kiris> dolio: I'll try that
12:10:14 <kiris> dolio: yes, it's nearly double the speed with foldl'
12:10:50 <dolio> Thought that'd help.
12:11:02 <kiris> dolio: thanks
12:13:00 <hpaste>  kiris annotated "String faster than ByteString for certain operation" with "very fast" at http://hpaste.org/8838#a4
12:13:27 <dolio> :) Boom.
12:13:38 <kiris> dolio: I don't know why the lazy version is faster. can you explain please?
12:13:49 <dolio> kiris: It runs in constant space overhead.
12:13:58 <dolio> Instead of O(n) where n is the length of your file.
12:14:47 <kiris> dolio: because only what is needed is allocated and then garbage collected immediately?
12:14:57 <dolio> That's the idea.
12:15:09 <dolio> Although, with lazy byte strings, it's actually stricter than that.
12:15:22 <kiris> dolio: well, I didn't know that ^_^
12:15:36 * ronwalf is so out of his league with Typeable
12:15:59 <kiris> dolio: in what way is it stricter?
12:16:19 <dolio> They allocate/read in chunk sizes that they've tuned via performance tests.
12:17:22 <dolio> So when you do a readFile with a lazy bytestring, you get (internally), something like a lazy list of strict byte strings of the performance tuned size.
12:18:29 <kiris> dolio: I'm very impressed
12:18:32 <dolio> More or less, the chunks are supposed to fit nicely in the CPU cache.
12:18:47 <dolio> So you read a chunk into the cache, do your stuff with it, and then read in the next one.
12:19:33 <kiris> dolio: I see!
12:21:29 <kiris> dolio: thankyou for explaining it
12:21:36 <dolio> No problem.
12:23:20 <kiris> is ‚ÄúL‚Äù a de facto standard way of qualifying Data.ByteString.Lazy?
12:23:32 <stepcut> L or B
12:23:37 <stepcut> usually L though
12:23:48 <kiris> stepcut: is there a way to discern which to use?
12:24:24 <stepcut> I would use L unless you are using a project that already uses B, that way you could import the non-lazy version later as B and not have conflicts
12:27:22 <Deewiant> I usually use BS for ByteString, if I use both strict and lazy in the same one they're BS and BL
12:27:37 <zenon__> me 2
12:27:43 <zenon__> now, that is
12:28:06 <zenon__> What is the lambdabot @pl package named in hackage?
12:28:49 <quicksilver> as far as I know it only exists as part of lambabot
12:28:57 <quicksilver> not as a selfcontained bit of code
12:29:16 <zenon__> darn
12:29:21 <zenon__> would be nice to have
12:29:28 <quicksilver> you can download lambdabot and run it locally :)
12:29:41 <quicksilver> it used to be possible to run lambdabot in ghci, although I think that's bitrotted.
12:32:26 <newsham> has anyone fetched the full icfp livecd and mirrored it yet?
12:32:57 <earthy> not me. starts tomorrow, innit?
12:33:34 <BMeph> zeno___: It's called pointfree. :)
12:33:38 <Saul> I want to make Data.Time.Clock.UTCTime an instance of Binary, but DiffTime doesn't expose it's constructor, any suggestions?
12:33:46 <_zenon_> BMeph : THanks!
12:34:01 <BMeph> Ah, good, still here. :)
12:36:02 <BMeph> _zenon_: Specifically, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/pointfree
12:36:03 <EvilTerran> Saul, it's an instance of Enum, you could use that
12:36:07 <lambdabot> Title: HackageDB: pointfree-1.0.1, http://tinyurl.com/6r2qvo
12:36:19 <waern> Saul: do you really need a constructor?
12:36:39 <waern> Saul: there is probably some other way of constructing that type
12:36:53 <EvilTerran> show x = "(toEnum " ++ show (fromEnum x) ++ ")"
12:37:01 <BMeph> Now if only unpl were offered as a standalone, or unmtl... :)
12:37:11 <chr1s> @seen dcoutts
12:37:12 <lambdabot> dcoutts is in #haskell-soc, #haskell-overflow, #ghc, #haskell and #gentoo-haskell. I last heard dcoutts speak 6h 15m 47s ago.
12:37:15 <Saul> I see it actually has Num
12:37:16 <_zenon_> I am using a huge Map , is there some other hash structure which is faster?
12:37:22 <EvilTerran> stick a ":: DiffTime" in there if you like
12:37:25 <chr1s> @seen dons
12:37:25 <lambdabot> dons is in #arch-haskell, #haskell, #ghc and #xmonad. I last heard dons speak 39m 18s ago.
12:37:31 <gwern> sjanssen: I doubt memoray lacking is the problem in linking lambdabot. 4 gigs I'm sure is enough
12:37:39 <EvilTerran> _zenon_, if your keys are dense, you can use an array
12:37:56 <_zenon_> EvilTerran: Unfortunately no, they are pretty ...random
12:38:05 <Saul> EvilTerran: I'll give that and the Num version a try, thanks
12:38:11 <_zenon_> HashTable then
12:38:43 <EvilTerran> I think (IntMap v) is faster than (Map Int v), if your keys are Ints
12:39:26 <dolio> That's why it exists.
12:39:33 <EvilTerran> quite
12:40:09 <Mitar> how can i output a byte?
12:40:12 <Mitar> not a character?
12:40:21 <Valodim> ord
12:40:22 <vixey> print . ord $ 'x'
12:40:35 <_zenon_> My map is Map String (Map String Double)
12:40:36 <vixey> :t showHex
12:40:37 <lambdabot> forall a. (Integral a) => a -> String -> String
12:40:39 <Mitar> ehm, will this output a byte value?
12:40:47 <vixey> Mitar: I have no idea what that is
12:40:48 <Mitar> like binary
12:40:54 <Mitar> not ascii
12:40:56 <Mitar> not text
12:40:56 <vixey> Mitar: if you want it in binary showAtBase2
12:41:18 <vixey> not ascii?
12:41:27 <vixey> it's probably UTF-8
12:41:35 <Mitar> ehm ... i would like to output a value 0xXY and that this would ouput byte with value 0xXY
12:41:52 <vixey> > ord '\xXY'
12:41:53 <lambdabot>  Illegal escape sequence at "'\xXY..." (column 5)
12:41:55 <mmorrow> Mitar: so you want a Word8 then?
12:42:04 <dolio> @type showHex
12:42:05 <lambdabot> forall a. (Integral a) => a -> String -> String
12:42:11 <Mitar> yes :-)
12:42:19 <Mitar> obviously
12:42:23 <_zenon_> got to take a shower
12:42:24 <dolio> > showHex (16 :: Word8) ""
12:42:38 <lambdabot>  "10"
12:42:44 <mmorrow> Data.ByteString.Internal has c2w and w2c. you could just steal those defs :)
12:42:52 <mmorrow> (i do all the time)
12:42:59 <Mitar> ups :-)
12:43:12 <Saul> EvilTerran: That Enum instance seems broken
12:43:26 <mmorrow> Mitar: http://haskell.org/ghc/docs/latest/html/libraries/bytestring/src/Data-ByteString-Internal.html
12:43:27 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/5o8t3d
12:43:28 <EvilTerran> er
12:43:29 <EvilTerran> weird
12:43:39 <Saul> EvilTerran: dt == (toEnum $ fromEnum dt :: DiffTime) evaluates to false
12:43:45 <Mitar> i have a list of float numbers and I would like to output them like x * 255 ... I am using B.pack but this looks quite slov
12:43:53 <EvilTerran> oh dear
12:43:54 <Mitar> (ehm, it uses a lot of memory)
12:44:06 <EvilTerran> Saul, actually, could you use the show/read instances?
12:44:41 <Saul> I might, but it would be more difficult
12:44:47 <hpaste>  marcot annotated "darcs whatsnew (xmonad)" with "The complete patch" at http://hpaste.org/8839#a1
12:44:47 <EvilTerran> it wouldn't be as pretty
12:45:02 <Saul> It prints a number appended with an s
12:45:04 <quicksilver> EvilTerran,saul: no more broken than the double instance then :P
12:45:19 <quicksilver> Saul: what are you trying to do, and is the answer realToFrac?
12:45:24 <Schmallon> I'm rather new to haskell and functional programming in general and I've got a question: Is there any way to specify a type for the function "twice f x = f (f x)" so that I could do e.g. "twice (map (\x -> [x])) [1,2,3]"
12:45:46 <vixey> :t let twice f x = f (f x) in twice
12:45:46 <lambdabot> forall t. (t -> t) -> t -> t
12:45:50 <Saul> quicksilver: I need to make a Binary instance for DiffTime, so that I can make one for UTCTime
12:45:52 <EvilTerran> Schmallon, sadly not
12:45:57 <mmorrow> Mitar: ah, so you're working with pixels? if you don't mind using ghc lowlevel stuff and manual unboxing you could make it fast with GHC.Prim and float2_#
12:45:58 <EvilTerran> Schmallon, not without using language extensions
12:46:00 <_zenon_> \f x -> f f x
12:46:15 <EvilTerran> ?hoogle Prelude.map
12:46:16 <lambdabot> No matches, try a more general search
12:46:19 <EvilTerran> ...
12:46:22 <EvilTerran> ?type Prelude.map
12:46:23 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
12:46:44 <vixey> > let twice f x = f (f x) ; units = map (\x -> [x]) in twice units [1,2,3]
12:46:44 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
12:46:45 <lambdabot>       Expected...
12:46:45 <EvilTerran> actually, hang on, this one might work...
12:46:54 <vixey> > let twice f x = f (f x) ; units = map (\x -> [x]) in units (units [1,2,3])
12:46:54 <Mitar> yes, pixels )
12:46:55 <lambdabot>  [[[1]],[[2]],[[3]]]
12:46:57 <EvilTerran> oh, maybe not
12:47:01 <Beelsebob> Schmallon: yes -- you need rank-2 polymorphism though
12:47:19 <EvilTerran> ?type map (\x -> [x])
12:47:20 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> f [a]
12:47:35 <EvilTerran> ?type \f x -> f (f x)
12:47:35 <lambdabot> forall t. (t -> t) -> t -> t
12:47:44 <EvilTerran> ?type \f -> f . f -- incidentally
12:47:45 <lambdabot> forall b. (b -> b) -> b -> b
12:47:47 <quicksilver> Saul: going via toRational is probably simplest/safest
12:47:59 <mmorrow> Mitar: i have a Pixel module from a little bit ago that might help, i'll paste it (it uses manual unboxing)
12:48:16 <Mitar> so if i write pixels to the screen it total alloc = 172,289,256 bytes
12:48:17 <plutonas> where can i find source code of haskell functions? i am maynly interested in groupBy
12:48:17 <EvilTerran> ?type (.)
12:48:18 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:48:24 <quicksilver> Saul: well realToFrac if you want a 2-way conversion. But using Rational as the type for binary.
12:48:25 <vixey> @src groupBy
12:48:25 <dolio> > let twice :: (forall b. b -> f b) -> a -> f (f a) ; twice f x = f (f x) in twice (map (\x -> [x])) [1,2,3]
12:48:26 <lambdabot> groupBy _  []       =  []
12:48:26 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
12:48:26 <lambdabot>     where (ys,zs) = span (eq x) xs
12:48:26 <lambdabot>  Parse error at "." (column 23)
12:48:30 <Mitar> if i go and store it to to ppm format, it has total alloc = 707,082,760 bytes
12:48:36 <EvilTerran> ...
12:48:41 <EvilTerran> ?type (Prelude..)
12:48:42 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
12:48:42 <Mitar> and all this memory work can be seen on performance
12:49:06 <stepcut> ugh, HsColour needs to use the GHC API I think :)
12:49:07 <Mitar> 78% of all allocations is in function which save image ...
12:49:17 <Saul> quicksilver: I'll play around with those a little
12:49:23 <EvilTerran> Schmallon, the problem comes from the fact that the return type of the first parameter to (\f x -> f (f x)) has to be the same as its parameter type
12:49:44 <EvilTerran> Schmallon, directly because the return value is, er, passed as its parameter :)
12:49:45 <quicksilver> Mitar: are you compiling with full optimisation?
12:49:48 <hpaste>  Mitar pasted "save image" at http://hpaste.org/8841
12:49:51 <Mitar> yes
12:50:21 <EvilTerran> ?type (\f x -> (f :: forall a. a -> [a]) (f x))
12:50:21 <lambdabot>     Inferred type is less polymorphic than expected
12:50:21 <lambdabot>       Quantified type variable `a' is mentioned in the environment:
12:50:21 <lambdabot>         f :: a -> [a] (bound at <interactive>:1:2)
12:50:31 <EvilTerran> harumph
12:50:47 <Schmallon> ÔªøEvilTerran, I see your point
12:50:48 <dolio> Man, it's even worse than I thought.
12:50:50 <Mitar> if i go over the same list of pixels and draw them on screen it is 600 MB less work
12:50:51 <EvilTerran> ?type (\f x -> f (f x)) :: (forall a. a -> [a]) -> a -> [[a]]
12:50:52 <lambdabot> forall a. (forall a1. a1 -> [a1]) -> a -> [[a]]
12:50:54 <hpaste>  morrow pasted "Pixel" at http://hpaste.org/8842
12:50:58 <EvilTerran> that was a mission
12:51:15 <dolio> Because map (\x -> [x]) :: forall a. [a] -> [[a]] /= forall b. b -> [b]
12:51:17 <EvilTerran> Schmallon, there is something you can do, like what i just did above, but it's an extension
12:51:18 <quicksilver> Mitar: allocations don't really matter.
12:51:25 <EvilTerran> Schmallon, and really not as useful as you'd hope, sadly
12:51:27 <quicksilver> Mitar: the GC is very fast at picking off local memory
12:51:32 <quicksilver> Mitar: is it actually slow?
12:51:49 <Schmallon> Not useful, why?
12:52:10 <EvilTerran> Schmallon, well, as you can see in that one, i somewhat restricted the form of the function to those of type (a -> [a])
12:52:27 <Mitar> to the screen takes 10 s, to file 11 s :-)
12:53:10 <EvilTerran> in order for the parameter function to be useful, there's got to be information available to it about the type it's getting and returning - it can't just be (a -> b) or whatever
12:53:13 <quicksilver> doesn't sound like a reliable measurement.
12:53:18 <quicksilver> how big is the image?
12:53:29 <EvilTerran> but you have to specify this explicitly in the type
12:53:29 <quicksilver> it can't possibly take 1 second to write a reasonable size file to disk
12:54:26 <Mitar> 921615 bytes
12:54:27 <gwern> huh. how did 3rd place in the 2006 ICFP go to a team using *assembler*?
12:54:32 <EvilTerran> which means, say, that, in order to write "twice f x = f (f x)", you'd have to give it a type like "twice :: (forall a. a -> [a]) -> a -> [[a]]" instead of something more general
12:54:37 <Mitar> yes, that's why i am saying that this second is too long
12:54:42 <EvilTerran> in order for it to be useful
12:55:22 <Toxaris> EvilTerran: what about (twice :: forall f . (forall a . a -> f a) -> a -> f (f a))?
12:55:42 <dolio> Allocation can matter. At least, significantly higher allocation can correllate with decreased performance.
12:56:08 <Mitar> yes, it trashes cache
12:56:16 <EvilTerran> Toxaris, that'd be barely more useful, wouldn't it?
12:56:33 <EvilTerran> you don't know anything about f, so you can't actually make a value of type (f a) from one of type a
12:56:52 <Toxaris> EvilTerran: ?
12:57:04 <Mitar> i made many measurements and it is always around second longer when i want to store it to the disc
12:57:50 <Toxaris> EvilTerran: the caller of twice selects both f and a function (a -> f a)
12:58:17 <Toxaris> EvilTerran: so she can select [] and (: []), or [] and cycle, or Maybe and Just, or ...
12:58:19 <Saul> quicksilver. EvilTerran: I now have a Binary instance using toRational and fromRational and that seems to work properly, thanks both
12:58:24 <dolio> Toxaris: That type won't work for 'twice (map return) [1..3]'
12:58:52 <dolio> Because map return does not have type forall a. a -> [a].
12:58:54 <Mitar> ok, forget, after more experiments it seems it just fluctuate ...
12:59:02 <Mitar> but a lot +- 2 seconds
12:59:38 <Toxaris> @type map return
12:59:39 <lambdabot> forall a (m :: * -> *) (f :: * -> *). (Functor f, Monad m) => f a -> f (m a)
13:00:14 <Toxaris> dolio: so maybe map (twice return) [1..3] is an alternative?
13:00:20 <Toxaris> I'm not aware of the original question
13:00:31 <dolio> Yes, that's what you'd have to do.
13:00:41 <dolio> And prove that they're the same, I suppose.
13:01:03 <dolio> Which isn't particularly hard, I guess.
13:01:34 <Toxaris> the trick seams to be that we have f (m a) but want m (f a)
13:01:46 <Toxaris> looking at the type of map return
13:02:47 <Toxaris> @type Data.Traversable.sequence
13:02:47 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Monad m, Data.Traversable.Traversable t) => t (m a) -> m (t a)
13:02:55 <Toxaris> so we need this guy?
13:03:14 <dolio> The original question is 'twice (map (\x -> [x])) [1,2,3]'.
13:03:25 <dolio> map being the list map.
13:03:59 <mmorrow> i don't think i've ever used Data.Traversable
13:04:12 <dolio> The problem is that if you use 'forall b. b -> f b' in twice, that's too polymorphic for map return, which is 'forall b. [b] -> [[b]]'.
13:04:15 <Toxaris> mmorrow: you should, it's great :)
13:04:30 <vixey> @src Maybe msum
13:04:31 <lambdabot> Source not found. Wrong!  You cheating scum!
13:04:34 <mmorrow> Toxaris: hmm, i'll check it out.
13:04:34 <vixey> @src msum Maybe
13:04:34 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
13:04:37 <vixey> :(
13:04:37 <EvilTerran> Toxaris, ah, i see
13:04:46 <mmorrow> haha
13:05:11 <mmorrow> my two favorite response to Source not found
13:05:13 <EvilTerran> ?src Maybe msum
13:05:14 <lambdabot> Source not found. I feel much better now.
13:06:05 <byorgey> > msum [Just 3, Nothing, Just 5]
13:06:06 <lambdabot>  Just 3
13:06:13 <byorgey> > msum [Nothing, Nothing, Just 5]
13:06:14 <lambdabot>  Just 5
13:06:21 <byorgey> it just picks the leftmost non-Nothing
13:07:19 <byorgey> this is in contrast to mconcat, which recursively applies mconcat to everything in a Just
13:07:31 <byorgey> > mconcat [Just (Sum 3), Nothing, Just (Sum 5)]
13:07:32 <lambdabot>  Just (Sum {getSum = 8})
13:07:37 <vixey> when you go, msum [Just 3, Nothing, Just 5]
13:07:42 <vixey> will it always be Just 3 ?
13:08:15 <byorgey> vixey: as opposed to being nondeterministic??
13:08:25 <vixey> I don't know
13:08:35 <byorgey> yes, it will always be Just 3 =)
13:11:42 <Beelsebob> it can't be non deterministic
13:11:47 <Beelsebob> it would have to be reflected in the type
13:11:59 <mmorrow> quicksilver: how is your mesh stuff coming?
13:12:02 <Beelsebob> either that or be unsafe (because it would violate referential transparency)
13:14:28 <hpaste>  dolio pasted "twice" at http://hpaste.org/8843
14:00:45 <wuxia> any vim users here? what scripts do you use when developing in vim?
14:00:45 <lambdabot> wuxia: You have 1 new message. '/msg lambdabot @messages' to read it.
14:02:42 <wuxia> here's a more general queation; I'm at line N-1, at char M of that line. I want to open up a new line (like with O), but I want to be auto indented to char M of the line
14:02:56 <wuxia> wrong channel, sorry
14:04:12 <quicksilver> mmorrow: been a bit busy. I almost have subdivision working though.
14:04:28 <mdmkolbe|work> Is there a variant of Data.Map that provides a function like "findNext :: k -> Map k a -> Maybe a" function which finds the value with the smallest key greater or equal to "k"?  (I don't see it in Data.Map but perhaps I'm overlooking something.)
14:04:32 <mdmkolbe|work> subdivision?
14:05:50 <vixey> :t M.fromList
14:05:50 <lambdabot> forall k a. (Ord k) => [(k, a)] -> M.Map k a
14:05:58 <vixey> :t M.toList
14:05:58 <lambdabot> forall k a. M.Map k a -> [(k, a)]
14:06:02 <mmorrow> quicksilver: cool. I'd love to see some haskell mesh stuff if you end up putting some code on the internet somewhere :)
14:06:47 <titto> does anyone know how to use cabal install to compile both normal and profiling versions of the hackage packages?
14:07:09 <ahunter> :t \x -> dropWhile (< x) . M.toList
14:07:10 <lambdabot> forall k a. (Ord a, Ord k) => (k, a) -> M.Map k a -> [(k, a)]
14:08:13 <mmorrow> :t M.split
14:08:14 <lambdabot> forall k a. (Ord k) => k -> M.Map k a -> (M.Map k a, M.Map k a)
14:08:45 <mmorrow> :t fst . M.split
14:08:46 <lambdabot>     Couldn't match expected type `(a, b)'
14:08:46 <lambdabot>            against inferred type `M.Map k a1 -> (M.Map k a1, M.Map k a1)'
14:08:46 <lambdabot>     Probable cause: `M.split' is applied to too few arguments
14:08:47 <titto> any cabal expert around :-) ?
14:08:54 <mmorrow> :t (fst .) . M.split
14:08:55 <lambdabot> forall k a. (Ord k) => k -> M.Map k a -> M.Map k a
14:09:05 <vixey> are there any languages that are like haskell data = ... but more involved?
14:09:14 <mdmkolbe|work> ahunter: something like that would implement the semantics of what I want (once you add "snd . head"), but I should have also said I want O(log n) time or maybe O(log log n) time
14:09:28 <mmorrow> vixey: how do you mean exactly?
14:09:35 <EvilTerran> mdmkolbe|work, i think M.split's what you want, then
14:09:54 <ahunter> mdmkobe|work: reasonable, yes.  O(log log n) seems possibly difficult, though
14:10:21 <mdmkolbe|work> EvilTerran: now that you mention it that makes sence, thanks
14:10:37 <mdmkolbe|work> ahunter: see http://en.wikipedia.org/wiki/Van_Emde_Boas_tree
14:10:39 <lambdabot> Title: van Emde Boas tree - Wikipedia, the free encyclopedia
14:10:52 <kiris> @src join
14:10:52 <lambdabot> join x =  x >>= id
14:10:56 <mdmkolbe|work> provides O(log log n) time operations (at a space cost)
14:11:16 <ahunter> mdmkolbe|work: true, though only for certain keys, yes?
14:11:49 <ahunter> key types, that is
14:11:50 <vixey> mmorrow: oh I guess I was describing twelf
14:12:02 <vixey> mmorrow: It's kind of like executable GADTs.. I think
14:12:15 <mmorrow> vixey: interesting, i'll have to check it out
14:12:27 <mdmkolbe|work> ahunter: it might only be integer keys (b/c it's based on bit splitting, but there might be a way to hack it on floats, etc)
14:12:56 <ahunter> right.  I want to say we've got an implementation of this
14:13:09 <mdmkolbe|work> ahunter: oh? where?
14:14:15 <ahunter> mdmkolbe|work: not sure, think that this is the same basic idea http://haskell.org/ghc/docs/latest/html/libraries/containers/Data-IntSet.html
14:14:16 <lambdabot> Title: Data.IntSet, http://tinyurl.com/5w58ma
14:14:30 <ahunter> sets, but the idea is there
14:14:40 <vixey> mmorrow: oh there's an example http://www.rosettacode.org/w/index.php?title=Evens_Sum_To_Even&oldid=11669
14:14:42 <lambdabot> Title: Evens Sum To Even - Rosetta Code, http://tinyurl.com/5vaeuo
14:14:58 <vixey> mmorrow: I wonder if there are things like it which are a bit different to twelf though
14:16:37 <mdmkolbe|work> ahunter: those are tries IIRC which are technically O(log n) b/c each step branches 2^k instead of 2^(m/2) where m is number of bits in key and nested trees used an m that is half as small as oposed to k is just being some fixed value
14:16:51 <mmorrow> vixey: ooh, nice side-by-side there. i've been meaning to learn agda and coq. maybe i'll add twelf to the list.
14:17:04 <mmorrow> vixey: i'm currently reading http://en.wikipedia.org/wiki/Twelf
14:17:05 <lambdabot> Title: Twelf - Wikipedia, the free encyclopedia
14:17:13 <ahunter> possibly, I didn't look in great detail, the idea just looked similar
14:17:38 <mmorrow> vixey: ah, this is much better http://twelf.plparty.org/wiki/Main_Page
14:17:39 <lambdabot> Title: Main Page - The Twelf Project
14:18:21 <mmorrow> "vixey> mmorrow: I wonder if there are things like it which are a bit different to twelf though"
14:18:29 <mmorrow> vixey: how do you mean?
14:18:47 <mmorrow> (bearing in mind i don't know the specifics of twelf)
14:19:26 <vixey> just wondering if there are any languages based on describing relationships between data instead of e.g. functions like in haskell
14:19:28 <mdmkolbe|work> ahunter: they are very similar and the differences are in choosing a fixed vs a variable fan-out.  Which makes tries asymtotically slower (though in practice tries may be faster as the code might be better optimized and log MaxInt vs log log MaxInt isn't that much speed up)
14:19:50 <vixey> maybe there's no difference between the two actually
14:19:55 <ahunter> right.  I was particularly noting that since we're always considering 32-bit ints, it's a constant either way
14:20:53 <mmorrow> vixey: heh, i was just thinking that, but i'm not so sure. either way, that's interesting to think about.
14:21:44 <vixey> I am thinking if you have a bunch of datadecls, you could derive the folds. etc. for them all.. and have some APL style notation to work with them
14:22:38 <kiris> I thought the idea of a language without formal parameters, just composition, would be nice. Joy kind of achieves this but it's kind of ugly
14:23:04 <mmorrow> vixey: saying that'd be cool would be an understatement ;)
14:24:08 <dolio> Charity is based around automatically having catamorphisms for inductive types, and anamorphisms for coinductive types.
14:24:09 <mdmkolbe|work> kiris: you mean like point-free style?
14:24:14 <kiris> mdmkolbe|work: yeah
14:24:17 <farhan__> what.
14:24:31 <mdmkolbe|work> @src length
14:24:31 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
14:24:34 <dolio> It doesn't automatically have any more complex schemes to my knowledge, though.
14:25:05 <mdmkolbe|work> @source length
14:25:05 <lambdabot> length not available
14:25:40 <farhan__> what are J and APL like?
14:26:12 <vixey> they aren't really like anything
14:26:20 <vixey> (except each other)
14:26:30 <dolio> It isn't too much different in practice than writing with pattern matching and structural recursion/guarded corecursion, though. You just never make recursive calls.
14:26:37 <Philippa> farhan__: concatenative/point-free style meets ubiquitous functors
14:26:52 <mdmkolbe|work> farhan__: APL program to count numbers from 1 to 1000 "ri1000" where "r" is greek rho (sum function) and "i" is greek "iota" (make list from 1 to n function)
14:27:01 <quicksilver> mmorrow: yeah, I'm collecting together some bits and pieces of opengl haskell stuff which I will upload
14:27:06 <farhan__> concise.
14:27:09 <mdmkolbe|work> farhan__: in APL everything is a matrix
14:27:10 <farhan__> thanks
14:27:13 <kiris> why is Monad not a subclass of Functor?
14:27:26 <Philippa> kiris: Because.
14:27:33 <dolio> Historical accident.
14:27:34 <farhan__> so that's what they mean by "specialised array processing"
14:27:56 <_zenon_> Yi.hs:56:7:
14:27:57 <_zenon_>     Could not find module `System.Posix.Signals':
14:27:57 <_zenon_>       it is a member of package unix-2.3.0.0, which is hidden
14:28:00 <_zenon_> damn it
14:28:06 <mmorrow> quicksilver: awesome. i wait eagerly :)
14:28:11 <_zenon_> Trying to install Yi
14:28:19 <mdmkolbe|work> farhan: and you need an APL keyboard to type any of your programs which makes it kind of write-only code (think perl squared)
14:28:36 <farhan> wow
14:28:44 <kiris> dolio: is it purely historical? are there no practical reasons?
14:28:50 <vixey> J is like an ASCII APL
14:28:54 <farhan> hmm
14:28:58 <farhan> maybe I'll revisit them after my degree. maybe not.
14:29:32 <dolio> kiris: It, theoretically, allows you to omit small bits of code, as well. But that's an amazingly lazy reason to not have it.
14:29:51 <jpcooper> is a functor say from Just x to Just x + 2 also a monad?
14:29:53 <mmorrow> _zenon_: just add "unix" to the "build-depends:" field in the .cabal file
14:29:56 <dolio> In my opinion, at least.
14:30:16 <ddarius> J is fun.
14:30:17 <vixey> Just (x + 2) isn't a type error
14:30:25 <kiris> dolio: ah, I see
14:30:40 <dolio> I doubt much actual time gets saved by not writing "instance Functor F where fmap = liftM".
14:30:44 <_zenon_> mmorrow: How do I do that?
14:30:56 <quicksilver> jpcooper: Just x |-----> Just x+2 is a function, not a functor.
14:31:06 <jpcooper> quicksilver, so what is a functor?
14:31:08 <mdmkolbe|work> Isn't the mathematical Monad a sub-class of the mathematical Functor?  I wouldn't call that a historical acident
14:31:09 <vixey> > let x = 3 in Just x+2
14:31:09 <lambdabot>   add an instance declaration for (Num (Maybe a))
14:31:12 <vixey> > let x = 3 in Just (x+2)
14:31:13 <lambdabot>  Just 5
14:31:19 <quicksilver> jpcooper: a functor is a map on types.
14:31:26 <quicksilver> jpcooper: like a |----> Maybe a
14:31:33 <quicksilver> or, in short "Maybe is a functor"
14:31:50 <vixey> @instances Functor
14:31:50 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
14:32:09 <jpcooper> aah
14:32:11 <quicksilver> mdmkolbe|work: the historical accident is that the haskell fails to match the mathematics.
14:32:21 <quicksilver> mdmkolbe|work: not the mathematics itself :)
14:32:22 <mmorrow> _zenon_: edit the yi.cabal file in a text editor :)
14:32:41 <quicksilver> jpcooper: of course, not all functions on types are Functors. Certain well behaved ones are.
14:32:48 <quicksilver> jpcooper: like Maybe, [], Tree, and so on.
14:33:00 <mdmkolbe|work> quicksilver: oh, I missed the "not" in the origial question
14:34:48 <kiris> quicksilver: so the implementation of fmap for some type is the functor?
14:35:09 <quicksilver> kiris: no, the implementation of fmap is the proof that it is a functor
14:35:16 <quicksilver> (if it satifies a certain law)
14:35:31 <kiris> quicksilver: "it"?
14:35:43 <quicksilver> the implementation.
14:35:57 <kiris> quicksilver: the implementation is the proof that the implementation is a functor?
14:36:00 <quicksilver> ;)
14:36:06 <hpaste>  sm pasted "waitForProcess doesn't come back" at http://hpaste.org/8846
14:36:07 <mattam> quicksilver: what are the simplest examples of unary Haskell type constructors that are not functors?
14:36:10 <vixey> it's not really a proof ..
14:36:14 <vixey> it's a kind of suggestion
14:36:21 <quicksilver> the implementation of fmap, if it satisfies a certain laws, is the proof that it is a function.
14:36:28 <quicksilver> functor.
14:36:31 <sm> strange.. the above hangs with a larger number of files
14:36:35 <quicksilver> "evidence" if you prefer that word to "proof"
14:36:42 <vixey> the "it satisfies certain laws" bit is the proof
14:36:43 <dolio> newtype Flip a b = Flip (b -> a)
14:36:49 <quicksilver> mattam: data Foo a = (a -> Int)
14:36:56 <quicksilver> mattam: data Foo a = MkFoo (a -> Int)
14:36:58 <quicksilver> I should say.
14:37:03 <_zenon_> mmorrow: I'll do
14:37:42 <quicksilver> sm: your grep subprocess is blocked on output
14:37:45 <quicksilver> sm: so it never ends
14:37:49 <quicksilver> so the wait hangs.
14:37:58 <jpcooper> quicksilver, is Just a functor?
14:38:00 <kiris> quicksilver: functions on types which satisfy certain laws are functors?
14:38:10 <vixey> Just is not a type constructor
14:38:11 <quicksilver> jpcooper: no, Just is a function. Maybe is a functor.
14:38:12 <sm> thanks quicksilver.. why is it blocked ?
14:38:17 <jpcooper> fmap (+2) Just (2) didn't seem to work
14:38:17 <vixey> it doesn't make sense to ask if it's a functor
14:38:17 <mdmkolbe|work> jpcooper: Maybe is a functor
14:38:18 <quicksilver> kiris: right.
14:38:20 <jpcooper> okay
14:38:20 <_zenon_> mmorrow: How must I format it? I get a parse error
14:38:22 <jpcooper> aah of course
14:38:32 <vixey> > fmap (+2) (Just 2)
14:38:33 <lambdabot>  Just 4
14:38:39 <vixey> > fmap (+2) Nothing
14:38:40 <lambdabot>  Nothing
14:38:54 <_zenon_> Yi.hs:46:17:
14:38:54 <_zenon_>     Could not find module `Data.Map':
14:38:57 <kiris> quicksilver: you just said that Maybe is a functor. I'm confused as to what you are saying is a functor, a type or a function, or something else?
14:38:57 <mattam> Yeah exponentials. Are there others? I guess with recursive types it's just as easy to find. But I wonder what useful datatypes aren't functors.
14:39:10 <quicksilver> kiris: we deliberately confuse terminology.
14:39:15 <kiris> quicksilver: why?
14:39:23 <quicksilver> because mathematician like doing that.
14:39:29 <mdmkolbe|work> kiris: IIUC, Functors (and Monads) are examples of algebraic structures and every such structure has a type (e.g. Maybe), some operations (e.g. fmap) and some laws that the implemention of those operations for that type must satisfy
14:39:31 <quicksilver> sometimes we say the type-function is the functor.
14:39:37 <quicksilver> sometimes we say 'fmap' is the functor.
14:39:37 * sm thinks about "GHC Note: in order to call waitForProcess without blocking all the other threads in the system, you must compile the program with -threaded. "
14:39:44 <quicksilver> technically the functor is both.
14:39:49 <quicksilver> sm: that's not your problem.
14:39:55 <kiris> quicksilver: is type-function a type constructor?
14:40:05 <quicksilver> A functor is a map on types and functions, in fact.
14:40:10 <quicksilver> it must take types to new types
14:40:16 <quicksilver> and functions to new functions
14:40:21 <quicksilver> such that a certain law holds.
14:40:30 <jpcooper> is it not a map between types?
14:40:36 <mmorrow> _zenon_: paste yi.cabal on hpaste
14:40:37 <jpcooper> such that a certain law holds
14:40:39 <jpcooper> yes
14:40:41 <quicksilver> the 'type-map' part, in haskell, is the type constructor.
14:40:41 <kiris> quicksilver: well, that's more straight-forward
14:40:49 <quicksilver> and the function-map part, in haskell, is always called 'fmap'
14:40:52 <mdmkolbe|work> quicksilver: in other words, Maybe and the implementation of "fmap" for maybe *together* form the functor
14:41:00 <jpcooper> yes
14:41:00 <dons> some haskell fans might be interested in galois' new website, http://galois.com/
14:41:01 <quicksilver> exactly as mdmkolbe|work says.
14:41:01 <lambdabot> Title: Galois: Welcome
14:41:16 <dons> we hope to have the galois tech talks and blogging up there soon.
14:41:49 <vixey> galois sounds awesome
14:41:55 <kiris> quicksilver: I think I understand the theory a little better now. thankyou
14:42:22 <jpcooper> dons, what is Galois about?
14:42:31 <jpcooper> do they use Haskell or something?
14:42:39 <dons> jpcooper: yep.
14:42:54 <jpcooper> aah, great
14:43:03 <dolio> It's one of those companies that isn't using Haskell to make money.
14:43:06 <jpcooper> is it yours? I've found a grammatical error
14:43:23 <dons> jpcooper: i'm an employee. i can forward patches to the web guys.
14:43:41 <dons> dolio: well, we do use it to make money :) indirectly.
14:43:54 <jpcooper> ways that -> ways which
14:43:56 <jpcooper> on the front page
14:44:03 <jpcooper> sounds fun
14:44:14 <jpcooper> I'm doing a Lisp job at the moment
14:44:23 <jpcooper> web 2.0 kind of stuff
14:44:57 <jpcooper> I think I'd prefer a Haskell job, if I got to learn the language more. It seems like a lot of code is allowed to be badly written, in lisp
14:44:59 <kiris> dons: will you be in any of the tech talks? ;)
14:45:13 <tusho> jpcooper: Reality check: You are complaining about a lisp job.
14:45:15 <dolio> dons: Are you sure you're not using F#?
14:45:18 <tusho> o_o
14:45:21 <jpcooper> tusho, :D
14:45:27 <dons> dolio: we're certainly not using F#
14:45:31 <dolio> :)
14:45:45 <dons> kiris: i've given some, but we usually have invited speakers (e.g. SPJ, Wadler et al)
14:45:45 <jpcooper> tusho, it's not as glamourous as you'd hope
14:45:59 <tusho> jpcooper: Better than most stuff.
14:46:13 <sm> dons: nice site. typo in your name at http://galois.com/company/people/ , you probably know
14:46:14 <lambdabot> Title: Galois : Company : People
14:46:51 <sm> quicksilver: could you say a little more about how to unblock my process ? it seems I'm making a newbie error
14:46:56 <dons> sm, oh heh
14:46:59 <dons> cheers.
14:47:03 <sm> np
14:47:52 <quicksilver> sm: well you have to understand this isn't a haskell issue, it's just about unix semantics, first of all.
14:47:59 <quicksilver> sm: you fork grep. It produces some output.
14:48:03 <sm> right
14:48:05 <quicksilver> After a while that output fills a buffer.
14:48:16 <quicksilver> and then, the grep process "blocks on writing"
14:48:24 <quicksilver> it won't wake up until you read from that buffer.
14:48:41 <sm> not shown in the paste, I do grepoutput <- hGetContents out  right after waitForProcess
14:48:41 <quicksilver> so you have to finish reading the grep's output
14:48:42 <quicksilver> before you "waitForProcess" it.
14:48:51 <sm> so maybe I should switch those lines
14:48:52 <quicksilver> (a) after is too late.
14:49:00 <quicksilver> (b) hGetContents is a LIE and BROKEN
14:49:02 <mauke> (b) before is too late
14:49:03 <quicksilver> and WRITTEN to HURT YOU
14:49:09 <sm> darn :)
14:49:40 <quicksilver> hGetContents does sneaky lazy IO beneath the hood
14:49:45 <quicksilver> and doesn't read when you ask it to
14:49:50 <quicksilver> you either need a strict read primitive
14:49:59 <quicksilver> or you need to finish working with the contents
14:50:00 <kiris> dons: wow, cool :D
14:50:02 <jpcooper> dons, http://galois.com/client_services/language_and_tools_design/ <-- DSL's to DSLs
14:50:03 <lambdabot> Title: Galois : Client Services : Language and Tools Design
14:50:03 <quicksilver> before you waitForProcess
14:50:13 <jpcooper> Galois' to Galois's
14:50:33 <kiris> jpcooper: I think the apostrophe for plurals is ‚Äúokay‚Äù in the US
14:51:39 <jpcooper> yes, with the widespread use of "Jesus'"
14:52:06 <kiris> dons: will the talks be about Haskell or other things too?
14:52:18 <sm> ok, this is helpful. Still wondering how to do that, mastering laziness seems to be a price of haskell's power
14:52:30 <dons> kiris: all sorts of things. they're very much like google's tech talks.
14:52:35 <kiris> dons: sometimes I just put A Taste of Haskell on my other screen while coding haskell, (after reciting my SICP, of course)
14:52:37 <mdmkolbe|work> jpcooper: "Jesus'" meaning posesive is right in the US, but but for plural I'm not sure
14:52:45 <kiris> dons: ahh, I really like Google Tech Talks
14:52:54 <jpcooper> mdmkolbe|work, It should actually be Jesus's
14:53:15 <jpcooper> ' only comes at the end of a plural which uses an s
14:53:15 <mdmkolbe|work> jpcooper: citation?
14:53:17 <hpaste>  morrow annotated "waitForProcess doesn't come back" with "Process" at http://hpaste.org/8846#a1
14:53:33 <jpcooper> mdmkolbe|work, Eats, Shoots and Leaves explains this, I think
14:53:52 <hpaste>  morrow annotated "waitForProcess doesn't come back" with "e.g." at http://hpaste.org/8846#a2
14:54:04 <quicksilver> sm: in my opinion, which grows stronger every month I spend on #haskell, it is a grave bug in the prelude that the lazy IO is the default.
14:54:25 <quicksilver> sm: one worrying symptom is that people come to equate "laziness" with "lazy IO" when really they are quite different.
14:54:26 <mmorrow> sm: the code in that paste works nicely (squirt is *awesome*)
14:54:35 <quicksilver> the the problems of the latter are much more serious than the former.
14:54:44 <sm> thanks mmorrow
14:54:53 <mmorrow> sm: :)
14:54:54 <sm> quicksilver: I think I agree
14:55:17 <osfameron> jpcooper: eats/shoots/leaves isn't a serious grammar book
14:55:19 <sm> mmorrow: I just sort of hoped to do this with less custom code :)
14:55:23 <quicksilver> of course lazy IO is a powerful tool, I don't disagree with its existence although I almost never use it.
14:55:27 <mmorrow> that squirt function from mohws is afaik the fastest way to "squirt" data between handles in haskell
14:55:48 <ddarius> kiris: Apostrophes for plurals is not okay in the US.
14:55:50 * sm just wants to run a command and read the output, even if it's long
14:55:57 <mmorrow> (and squirt runs in *constant* space and is strict)
14:56:19 <kiris> quicksilver: I found a great use for it today with lazy ByteStrings. that histogram program improved to less than a second in execution time (as opposed to 2 seconds), using all ByteStrings, of the Lazy kind! :)
14:56:22 <quicksilver> sm: there is a new version of System.Process which will have that as a primitive operation.
14:56:30 <kiris> ddarius: ah, well, my sources are unreliable (americans)
14:56:35 <quicksilver> kiris: definitely. It's useful. It just shouldn't be a default.
14:56:52 <kiris> quicksilver: indeedy
14:57:14 <quicksilver> sm: so your opinion is in common with one of the Simons'. That's about the highest level of vindication ;)
14:57:17 <jpcooper> osfameron, define serious :)
14:57:20 <mmorrow> sm: i've wanted that function for 6 months + and only yesterday did i figure out how to do it
14:57:27 * sm cheers
14:57:42 <jpcooper> bah, let's not get into a linguistics flamewar
14:57:43 * sm <- another simon
14:57:50 * mmorrow cheers +10
14:59:16 <mdmkolbe|work> jpcooper: I've come to the conclusion that you are right.  It should be "my boss's temper" not "my boss' temper".  (It's a bit obscure and I had to look at half a dozen pages on plural possesive before I found one on singular possesive with ending "s".)
14:59:31 <Beelsebob> atsampson: Yorkshire Haskell ftw - awesome idea
15:00:04 * atsampson grins at Beelsebob
15:02:16 <sm> well for now, it's back to sh for this task (summarizing darcs source code)
15:02:21 <sm> thanks for the help/insight/code
15:02:47 <lament> mdmkolbe|work: Strunk and White begins with that very topic
15:03:01 <jpcooper> mdmkolbe|work, okay
15:03:42 <sm> no! it's easy, I just moved the waitProcess further down and stop worrying
15:03:42 <lament> as in, covers it in the first actual sentence of the book :)
15:03:49 <mdmkolbe|work> lament: yeah just found it http://www.bartleby.com/141/strunk.html#1 but odly it says "Jesus'" is correct even though we use "Charles's"
15:03:50 <lambdabot> Title: Rules of Usage. Strunk, William, Jr. 1918. Elements of Style
15:03:53 * sm cheers, haskell prints
15:04:24 <lament> exceptions for historical reasons
15:04:28 <kiris> mdmkolbe|work: IIRC ‚ÄúJesus'‚Äù is correct for historical reasons, not for logical reasons
15:04:39 <sm> I don't think I even need to waitForProcess
15:04:41 <osfameron> I think the Jesus' thing is quite old-fashioned, yeah
15:04:54 <Beelsebob> @seen cale
15:04:54 <lambdabot> cale is in #japanese, #ghc, #haskell-overflow and #haskell. I last heard cale speak 7h 16m 36s ago.
15:05:05 <osfameron> I also hate the spelling "Descartes'" as it suggests that the final "s" isn't silent...
15:05:12 <mdmkolbe|work> kiris: yeah, "Exceptions are the possessives of ancient proper names in -es and -is, the possessive Jesus', and such forms as for conscience' sake, for righteousness' sake."
15:05:44 <lament> of course strunk and white, awesome as it is, is American
15:05:53 <hackage> Uploaded to hackage: graphviz 2008.7.11
15:05:54 <osfameron> you should see the language log savaging strunk and white...
15:06:11 <dcoutts> chr1s: pong
15:06:11 <osfameron> @faq can Haskell get the English language right, all of the time?
15:06:11 <lambdabot> The answer is: Yes! Haskell can do that.
15:06:14 <osfameron> yay!
15:07:08 <lament> osfameron: for the suggestion to use the epicene 'he', no doubt?
15:07:39 <osfameron> lament: "it is not just that Strunk & White offer crappy usage advice; it's that they demonstrate that their advice is crappy whenever they write, because they are utterly unable to follow their own rules, even on a bet" for example http://itre.cis.upenn.edu/~myl/languagelog/archives/001905.html
15:07:39 <lambdabot> Title: Language Log: The blowing of Strunk and White's rules off
15:08:15 <lament> haha awesome
15:08:48 <lament> osfameron: oh, that's just Mark being retarded as usual
15:09:03 <hpaste>  frankblack pasted "(no title)" at http://hpaste.org/8847
15:09:35 <frankblack> am I still under the influence of evil procedural ideas?
15:09:48 <osfameron> lament: mmm?
15:10:03 <orzo> http://haskell.org/ghc/docs/latest/html/libraries/bytestring/Data-ByteString-Unsafe.html#v%3AunsafeFinalize
15:10:04 <lambdabot> Title: Data.ByteString.Unsafe, http://tinyurl.com/5n65lm
15:10:24 <orzo> it says "if the underying Addr# is later modified, this change will be reflected..."
15:10:32 <orzo> are Addr# types mutable?
15:10:40 <orzo> what does it mean?
15:11:01 <mdmkolbe|work> orzo: chagned by the garbage collector maybe?
15:11:05 <lament> osfameron: sorry, Geoffrey, not Mark
15:11:29 <osfameron> lament: heh, I'm not on first name terms with the languagelog crew :-)
15:11:31 <kiris> frankblack: why do you ask?
15:11:34 <lament> osfameron: he's just writing out of his ass on that one
15:11:39 <orzo> i think maybe it means if the data pointed to by Addr# is changed
15:11:48 <quicksilver> orzo: well Addr# is just a pointer, ... what you said.
15:12:17 <frankblack> first working piece of code > 10 lines ;)
15:12:22 <lament> osfameron: i mean, how stupid do you have to be to interpret advice on not overdoing adjectives and adverbs as a suggestion to not use them at all?
15:12:23 <orzo> i have a situation where i'd like to change the Addr# associated with ByteStrings already in the heap
15:12:36 <kiris> frankblack: ah, probably ;)
15:12:37 <osfameron> lament: I've not read strunk and white (being ukian, where I don't think anyone has even heard of them) but I did remember various LL guys savaging their pronouncements.  I think they have a downer on prescriptivism in general and like to mock overuse of it)
15:12:38 <dons> orzo: take apart the ForeignPtr, and its Ptr
15:12:40 <frankblack> and I think I could have written it shorter
15:13:27 <ddarius> lament: You have to be completely, sillily, ridiculously and utterly stupid.
15:13:56 <osfameron> lament: oh?  Is "Write with nouns and verbs, not with adjectives and adverbs" very much taken out of context? i.e. does the original source merely suggest it as something not to overuse?
15:14:38 <lament> osfameron: just consider, it's a book on the usage of english, do you actually expect a rational author to suggest never using adjectives and adverbs?
15:14:40 <ddarius> It's hard to believe anyone would seriously suggest not using adjectives and adverbs at all.
15:15:25 <kiris> It's hard to believe anyone would suggest not using adverbs and adjectives, and be serious about it.
15:15:39 <lament> osfameron: people would just see that, realize he's a nut, and forget about the book.
15:15:53 <frankblack> my old english teacher was one of those types
15:16:02 <kiris> frankblack: a prescriptivist?
15:16:14 <osfameron> lament: though people do insist on all kinds of nutty rules about language (which of course they don't follow)
15:16:26 <orzo> dons, the situation is that i am intermittently entering a haskell thread from a C function that passes a buffer that i use to create bytestrings.  I want to minimize my copying, so i don't copy the whole buffer even though it will be void when i return to C.  Instead, i try to copy only the portions I need to remember accross calls.  But doing that by hand can be dangerous.  I'd like to automate it somehow using weak pointers to byt
15:16:29 <frankblack> I don't know his political opinion ;)
15:17:39 <frankblack> he would write down a sentece and make it "better" by removing all unnecassary words
15:17:58 <lament> osfameron: not to mention that "write with nouns and verbs, not with adjectives and adverbs" is very different from "don't use adjectives and adverbs"
15:18:24 <orzo> The problem is that ForeignPtr and ByteString aren't mutable, so i would need some way to replace the pointers to objects already allocated on the heap
15:18:28 <lament> even out of context, i can't honestly interpret it that way other than if i were trying to troll
15:19:19 <osfameron> lament: well, it is ambiguous whethre it means "when writing use this, not that" or "convey the bulk of meaning in your written communication using these words rather than those"
15:19:25 <orzo> I want to replace the pointers associated with live bytestrings without other portions of the code that use the bytestrings being aware that anything changed.
15:19:40 <osfameron> lament: but yeah, I'd agree it's satire of the slightly trolly kind
15:20:19 <osfameron> they had a whole series of articles on s&w though, dunno if it's more convincing if taken as a whole
15:20:23 <kiris> orzo: you want mutation?
15:20:42 <mdmkolbe|work> heh, "prescriptivism is bad for linguistics, but good for writing"
15:21:03 <orzo> kiris: yes, but it is mutation hidden behind the bytestring interface.  There already is such.  I want to add more
15:21:37 <dons> changing the Addr# sounds very dangerous
15:22:07 <orzo> well I'd need to modify ByteString or ForegienPtr to use an IORef Addr#
15:22:29 <orzo> its less dangerous than what i'm currently doing
15:23:36 <orzo> don't you agree?
15:23:43 <dcoutts> @seen Saizan
15:23:43 <lambdabot> Saizan is in #haskell-soc, #haskell-blah, #haskell-overflow, #haskell.it and #haskell. I last heard Saizan speak 3h 54m 13s ago.
15:24:02 <lament> osfameron: all i can say is it's a great book :)
15:24:19 <kiris> lament: have you read Eats, Shoots and Leaves?
15:24:19 <yakov> hey
15:24:27 <dcoutts> Saizan: I'm back! :-) we should talk about your project. I note there's been no updates in the HWN. The people want to know! ;-)
15:24:47 <orzo> I'm curringly using bytestrings constructed with ByteString.Internal that point into a temperary buffer
15:25:00 <lament> kiris: no
15:25:04 <orzo> I just want some way to keep track of those and copy only the live ones just before the buffer disapears
15:25:30 <lament> osfameron: and i'm not sure if it has a British equivalent. The coolest thing about it is that it's really short.
15:25:41 <orzo> a copy that i would like to be invisible to the rest of the program, analagous to the garbage collector moving objects
15:26:06 <yakov> does anybody know if there's something like --mk-dll on linux? should I get latests sources from darcs?
15:26:37 <frankblack> should I learn ocaml if I'm too stupid for haskell yet?
15:27:15 <vixey> no
15:27:18 <osfameron> lament: George Orwell's 5 rules? ;-)
15:27:28 <mauke> "In HASKELL, we would create a button class, give it the necessary methods, create a loop that would make enough instances of the class and write a recursive factorial."
15:28:14 <frankblack> from my perspective we would make an infix button operator or something
15:28:54 <lament> osfameron: well, that one doesn't say how to form the possessive
15:29:53 <kiris> lament: I've read it and I think it has a good attitude. it has a bit of history, indulgence of poking fun at grammar and spelling mistakes, and then admittance that, well, language evolves, the rules are becoming relaxed, and just try to write clearly and try not to be ambiguous. I think that's all you can do
15:31:00 <mmorrow> orzo: this may not be applicable to your situation, but have you looked in to System.Mem.{Weak,StableName} ?
15:31:29 <lament> kiris: sounds like S&W might have been one of their influences :)
15:32:03 <orzo> mmorrow, yes, it is applicable.  But I would still need to rewrite either ByteString or ForeignPtr to allow mutable Addr# fields
15:32:58 <orzo> I think i would do ForeignPtr because I think it would be less work
15:33:13 <mmorrow> orzo: hmm, maybe you need to roll-your-own datatype then
15:33:20 <sm> what's the current simplest way to split a string at ':' ?
15:33:27 <mmorrow> orzo: probably
15:33:35 <kiris> sm: into what type? a list or a pair
15:33:35 <vixey> split ':'
15:33:38 <mauke> sm: use perl instead
15:33:38 <sm> a pair
15:33:51 <mauke> oh, span/break
15:33:58 <Nafai> Hi sm!
15:34:11 <sm> hey Nafai
15:34:17 <mauke> :t fmap (drop 1) . break (':' ==)
15:34:17 <lambdabot> [Char] -> ([Char], [Char])
15:34:32 <Nafai> What are you working on?
15:34:45 <mdmkolbe|work> @type split
15:34:46 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
15:34:50 <mdmkolbe|work> @type splitAt
15:34:51 <lambdabot> forall a. Int -> [a] -> ([a], [a])
15:34:52 <Saizan> dcoutts: right, i'm almost there in getting basic yhc support implemented with my make, but there's the "little" problem that yhc doesn't keep track of installed libraries
15:34:58 <mdmkolbe|work> @type splitWhen
15:34:59 <lambdabot> Not in scope: `splitWhen'
15:35:06 <EvilTerran> mdmkolbe|work, it's called break
15:35:16 <sm> vixey: that's with a bytestring, right ?
15:35:49 <sm> Nafai: trying to update my script for summarizing a haskell code tree
15:36:22 <dcoutts> Saizan: oh cool!
15:36:49 <dcoutts> Saizan: right, though we could make it do so without too much trouble I suppose by installing the package registration files
15:36:49 <mmorrow> sm: heh, i happen to be working on a file that has a split function in it as we speak
15:36:57 <mauke> > fmap (drop 1) . break (':' ==) $ "http://google.com:80/"
15:36:58 <lambdabot>  ("http","//google.com:80/")
15:36:59 <lambdabot> Title: Google
15:37:02 <hpaste>  morrow pasted "split" at http://hpaste.org/8848
15:37:05 <sm> > break (==':') "aa:bb"
15:37:07 <lambdabot>  ("aa",":bb")
15:37:07 <Nafai> sm: Sounds handy!
15:37:42 <sm> it is! it will be! did a  python summarizer  last night
15:37:54 <Nafai> I'd like to see that :)
15:37:57 <Nafai> sm: Both!
15:38:03 <sm> ideally emacs speedbar should be enough, but it doesn't work
15:38:26 <mdmkolbe|work> > fmap (drop 1) . break (':' ==) $ "aa:bb"
15:38:27 <lambdabot>  ("aa","bb")
15:38:38 <mdmkolbe|work> > break (':' ==) $ "aa:bb"
15:38:39 <lambdabot>  ("aa",":bb")
15:38:56 <sm> mdmkolbe|work, all: thanks
15:39:03 <orzo> mmorrow & dons, maybe it would be more generall useful if the ghc garbage collector could be told about foreign buffers and follow pointers into them as appropriate and copy out of them when it is told the foreign buffer is going kaput
15:39:12 <sm> Nafai: http://joyful.com/darcsweb/darcsweb.cgi?r=summarize;a=headblob;f=/summarize
15:39:13 <lambdabot> Title: darcs - summarize, http://tinyurl.com/5bwper
15:39:16 <Saizan> dcoutts: using the same layout as for ghc? $package-$version/yhc-$version/<files> ?
15:39:26 <dons> orzo: isn't that what ForeignPtrs are for?
15:40:25 <orzo> dons, if so, then shouldn't the ForeignPtr Addr# fields be mutable?  How will the data be transparently copied out?
15:40:33 <Nafai> sm: Nice!  I've grown quite attached to my IDE for Java programming because it gives me such things
15:40:46 <dons> orzo: the finaliser associated with the ForeignPtr would be used, I guess.
15:41:13 <dons> i'm not quite sure what you're doing, but with ForeignPtrs you associated an arbitrary IO action to run when the resource is no longer used on the haskell side.
15:41:25 <orzo> my understanding is that the finalizer is called when the garbage collector decides the ForeignPtr object is dead
15:41:35 <orzo> that is not good
15:42:22 <mmorrow> orzo: but before it reclaims it, so couldn't you do all your copying with the finalizer?
15:42:24 <orzo> i need something where I can tell the garbage collecter that the ForeignPtr's data is going dead, but if the ForeignPtr isnt dead, then I would liek the garbage collector to simply copy the data out and change the Addr# associated with it
15:42:38 <ronwalf> Anyone have a way to see the instance code generated by deriving Typeable from Either ?
15:42:39 <orzo> no
15:42:47 <mmorrow> hmm
15:42:54 <orzo> The garbage collector has no way of knowing when my external buffer is kaput
15:43:00 <orzo> it cannot trigger the copy itself
15:43:01 <mmorrow> ahh, i see
15:43:12 <orzo> I want to tell it
15:43:29 <mmorrow> what code know when such a thing should be triggered?
15:44:33 <mmorrow> if it's c code or something, maybe you could wrap a haskell callback which'll notify the haskell side as a FunPtr and give that to the foreign code to call
15:45:05 <orzo> well, in my case, I enter haskell from C with a pointer, i put that in an mvar and wait on an mvar before returning to C so that the thread processing the data can finish with that buffer.  Before I return to C though, i know that the external buffer is kaput and any left over bytestrings should be copied out of it
15:47:58 <mmorrow> orzo: maybe put a function that does the copying in the mvar, then call it right before you return to c?
15:48:18 <orzo> yes, sure
15:48:39 <orzo> the problem is how do you update all the other references to the objects you are copying?
15:48:53 <orzo> thats why we'd need mutable Addr# fields
15:49:44 <mmorrow> heh
15:50:15 <mmorrow> without knowing any more particulars, i think i'm out of suggestions
15:51:14 <orzo> the code to ForeignPtr says Addr# were kept immutable in order for withForiegnPtr to be efficient
15:52:15 <orzo> if I add another representation to ForeignPtr, while keeping the 2 current ones, would I be making withForeignPtr universally less efficient or would it only apply if people used my special representation for external temperorary buffers?
15:53:23 <mmorrow> wait, why don't you have all the references to the objects you will eventually end up copying not be refs to the to-be-copied objects themselves, but refs to {IO,ST}Refs containing those objects? then you could just update the _Refs
15:53:33 <osfameron> @index mempty
15:53:34 <lambdabot> Data.Monoid, Control.Monad.Writer, Control.Monad.RWS
15:54:06 <sm> Finally: split x xs = (as, drop 1 bs) where (as,bs) = break (== x) xs
15:54:26 <sm> into snippets.hs it goes
15:54:28 <mmorrow> orzo: (or something along those lines, ie "another level of indirection")
15:54:32 <orzo> mmorrow, it seems elegant to me if the other code is unaware of he details of the data.  I could just have it processing a giant lazy bytestring
15:56:11 <orzo> i'm looking at streams that arrive in chunks
15:56:46 <orzo> the chunks are not broken in any logical way, and I'm parsing and interpretting the data as a stream
15:56:47 <mmorrow> hmm, i dunno
15:56:51 <pchiusano> hello
15:57:09 <vixey> hi
15:57:14 <ronwalf> How do you force cabal to reinstall a package?
15:57:41 <dcoutts> ronwalf: can't yet without unregistering first, it's a frequently requested feature atm
15:58:25 <ronwalf> How can you unregister?
15:58:54 <mauke> ghc-pkg unregister $PKG
15:59:19 <ronwalf> thanks
16:02:22 <ronwalf> Is hackage 'derive' broken?
16:02:30 <orzo> I think the best solution is to add a 3rd representation to ForeignPtr that allows mutable Array# fields and use weak pointers to track bytestrings
16:02:35 <pchiusano> I was using a java xml api - xstream - recently, and it has a very "statefull" api - you call moveUp() and moveDown() to move the cursor around in the document... it's very fast and consumes very little memory because it is entirely streaming..
16:02:40 <orzo> er mutable Addr# fields i mean
16:03:07 <pchiusano> but I was thinking it would be possible to present a pure interface, use laziness, and also have it consume very little memory
16:03:16 <pchiusano> has anyone done anything like that in haskell?
16:03:36 <pchiusano> here is core parsing api - http://xstream.codehaus.org/javadoc/com/thoughtworks/xstream/io/HierarchicalStreamReader.html
16:03:37 <lambdabot> Title: HierarchicalStreamReader (XStream Core 1.3 API), http://tinyurl.com/57ff7y
16:03:58 <orzo> this would make a solution taht would be a lot simpler and more elegant and probably faster than C code that tries to buffer up chunks into logical blocks before it processes them which is what we currently do here
16:04:08 <enoksrd> anybody remember the site used to make the fancy tag clouds someone was talking about a few days ago?
16:05:18 <orzo> And thats not an uncommon situation, is it?
16:05:33 <pchiusano> like I think of it as the difference between iterators and lazy lists - you can still compute functions on lazy lists that consume only constant space
16:05:49 <orzo> buffering up sensless chunks of a stream in order to process it sensibly
16:05:57 <hackage> Uploaded to hackage: protocol-buffers 0.0.5
16:06:13 <orzo> we could have a very nice demonstration of the power of haskell over C
16:06:42 <orzo> the buffering would be driven become all implicit in the logic of the processing
16:09:03 <kiris> http://chrisdone.com/wordfreq.cgi
16:09:04 <kiris> hehe
16:09:31 <sm> I'm having trouble figuring out how to: convert [(a,b)], where multiple entries have the same a, to a map where each value is a list of 0 or more bs for that a
16:10:04 <dibblego> sm, a Map a [b] ?
16:10:08 <sm> right
16:10:11 <dibblego> a (Map a [b])
16:10:15 <vixey> sm: first turn [(a,b)] into [(a,[b])]
16:10:31 <vixey> with the invarient that no a appears twice
16:10:40 <sm> right
16:10:43 <mauke> insertWith
16:10:47 <sm> hmm
16:10:49 <EvilTerran> > groupBy fst $ zip "abracadabra" [0..]
16:10:50 <enoksrd> @help
16:10:50 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:10:50 <lambdabot>      Occurs check: cannot construct the infinite type:
16:10:50 <lambdabot>       a = (a, b) -> Bo...
16:10:58 <EvilTerran> > groupBy ((==)`on`fst) $ zip "abracadabra" [0..]
16:10:59 <lambdabot>  [[('a',0)],[('b',1)],[('r',2)],[('a',3)],[('c',4)],[('a',5)],[('d',6)],[('a'...
16:11:05 <EvilTerran> err
16:11:07 <vixey> :t comparing fst
16:11:08 <lambdabot> forall a b. (Ord a) => (a, b) -> (a, b) -> Ordering
16:11:13 <EvilTerran> > groupBy ((==)`on`fst) . sort $ zip "abracadabra" [0..]
16:11:14 <lambdabot>  [[('a',0),('a',3),('a',5),('a',7),('a',10)],[('b',1),('b',8)],[('c',4)],[('d...
16:11:35 <osfameron> @pl reverse . snd . foldl' (\(m,l) k -> case M.lookup k m of { Nothing -> (M.insert k 1 m, k:l); Just _  -> (m,l) }) (M.empty, [])
16:11:36 <lambdabot> (line 1, column 58):
16:11:36 <lambdabot> unexpected "{"
16:11:36 <lambdabot> expecting variable, "(", operator or ")"
16:11:37 <EvilTerran> ?type M.fromlist . groupBy ((==)`on`fst) . sortBy (comparing fst) $ zip "abracadabra" [0..]
16:11:38 <lambdabot> Couldn't find qualified module.
16:11:48 <sm> thanks for the hints.. I made the mistake of thinking fromList would do it
16:11:51 <EvilTerran> ?type Data.Map.fromlist . groupBy ((==)`on`fst) . sortBy (comparing fst) $ zip "abracadabra" [0..]
16:11:51 <lambdabot> Not in scope: `Data.Map.fromlist'
16:11:58 <EvilTerran> ?type fromListWith
16:11:58 <lambdabot> Not in scope: `fromListWith'
16:12:22 <EvilTerran> sm, you want fromListWith, actually
16:12:46 <mauke> :t foldr (uncurry (M.insertWith (++))) M.empty . map (fmap return)
16:12:47 <lambdabot> forall a a1 (m :: * -> *). (Monad m, Ord a, Monoid (m a1)) => [(a, a1)] -> M.Map a (m a1)
16:13:04 <FunctorSalad> ?type Data.Map.fromList
16:13:04 <sm> aha.. so I was on the right track. I'm looking at fromAscListWith but didn't understand the combining function needed
16:13:05 <lambdabot> forall k a. (Ord k) => [(k, a)] -> M.Map k a
16:13:07 <EvilTerran> > M.fromListWith (++) . map (second return) $ zip "abracadabra" [0..]
16:13:08 <lambdabot>   add an instance declaration for (Monoid (m b))
16:13:18 <EvilTerran> > M.fromListWith (++) . map (second (:[])) $ zip "abracadabra" [0..]
16:13:19 <lambdabot>  fromList [('a',[10,7,5,3,0]),('b',[8,1]),('c',[4]),('d',[6]),('r',[9,2])]
16:13:32 <sm> lovely
16:13:35 <EvilTerran> ... backwards, but that seems to work
16:13:41 <ndmitchell> ?type Data.Map.fromAscListWith
16:13:41 <lambdabot> forall a k. (Eq k) => (a -> a -> a) -> [(k, a)] -> M.Map k a
16:13:46 <orzo> In ocaml, ByteString could be parameterized by ForeignPtr and i could import it and substitute my own ForeignPtr module.  I don't suppose haskell has any such convenience?
16:13:49 <EvilTerran> just make that fromListWith (flip (++))
16:15:02 <orzo> Maybe there should be a way to alter the imports of a module when you import it
16:15:49 <osfameron> ooo! mempty++
16:16:03 <osfameron> it correctly figures out I want the tuple (M.empty, [])  !
16:16:47 <orzo> something like "import Data.ByteString with (MyForeignPtr as Foreign.ForeignPtr)"
16:17:17 <hpaste>  osfameron pasted "implementation of uniq :: (Ord b) => [b] -> [b]" at http://hpaste.org/8849
16:17:40 <osfameron> how's that for a uniq?  Is there something neater for the case statement and Just/Nothing matching, for example?
16:18:07 <ndmitchell> orzo: nope, that can't be done
16:18:16 * osfameron hugs sub uniq { my %seen; grep !($seen{$_}++) }
16:18:34 <mauke> > S.toList . S.fromList $ words "1 1 2 1 2 3 1 2 3 4 "
16:18:35 <lambdabot>  ["1","2","3","4"]
16:19:22 * clkao grins at osfameron
16:19:24 <osfameron> mauke: heh!  Is that always in order of seen elements?
16:19:35 <osfameron> hey clkao :-)
16:19:45 <mauke> > S.toList . S.fromList $ words "5 10 22 what 1 1 2 1 2 3 1 2 3 4 "
16:19:46 <lambdabot>  ["1","10","2","22","3","4","5","what"]
16:19:52 <mauke> it's sorted
16:19:59 <osfameron> ok
16:20:05 <augustss> > nub $ words  "5 10 22 what 1 1 2 1 2 3 1 2 3 4 "
16:20:06 <lambdabot>  ["5","10","22","what","1","2","3","4"]
16:20:09 <vixey> what does that uniq do ?
16:20:10 <mauke> since Set is a balanced tree
16:20:22 <vixey> the perl
16:20:39 <osfameron> vixey: the perl one has each unique element in the order it was seen
16:20:41 <mauke> it's a syntax error
16:20:44 <ndmitchell> if you want a O(n log n) nub the best way to do it is with a Set to keep track of what you've seen, and dump out the results as you hit them
16:20:51 <mauke> because perl doesn't autocurry
16:20:53 <ndmitchell> that way its lazy and fast :)
16:20:59 <vixey> mauke: ah
16:21:07 <osfameron> mauke: yeah, I'm missing @_ from that
16:21:18 <mauke> etawned
16:21:19 <FunctorSalad> if you want stable uniq, I suppose you could zip with the original index and use that as ordering after comparing the original value ;)
16:21:23 <augustss> ndmitchell: assuming you have Ord
16:21:25 <osfameron> serves me right for not copy/pasting from where I just wrote that an hour ago...
16:22:07 <mauke> use List::MoreUtils qw(uniq);
16:22:12 <osfameron> ndmitchell: isn't that more or less what I'm doing?
16:22:35 <osfameron> oh except I'm using a Data.Map instead of a Data.Set
16:22:46 <osfameron> having programmed with Perl for too long I still believe everything is a hash :-)
16:23:31 <mauke> that sounds more like PHP
16:23:40 <ndmitchell> osfameron: i guess i'm just getting confused with a Data.Map a 1
16:23:42 <vixey> > let phu (x:xs) = if x`elem`xs then [] else [x] in unwords $ (phu.reverse =<<) . tail . inits $ words "1 1 2 1 2 3 1 2 3 4"
16:23:43 <lambdabot>  "1 2 3 4"
16:24:32 <osfameron> :t (=<<)
16:24:32 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
16:24:34 * sm keeps puzzling out that combining function, since solutions so far don't *quite* do it
16:24:36 <ndmitchell> augustss: most things have both Eq and Ord, http://neilmitchell.blogspot.com/2007/03/eq-but-not-ord.html
16:24:36 <lambdabot> Title: Neil Mitchell's Haskell Blog: Eq but not Ord
16:24:58 <ndmitchell> and you can't get O(n log n) without an Ord
16:25:47 <augustss> ndmitchell: yes, most things have Eq and Ord
16:25:59 <ndmitchell> hackage seems awfully slow, i had cabal update time out on me loads of times this afternoon
16:26:08 <ndmitchell> is that some bug, or just general slowness?
16:26:23 <dcoutts> ndmitchell: it's still rate throttled for some reason
16:26:42 <FunctorSalad> speaking of Maps, wouldn't it make more sense if mapKeys was (k1 -> k2) -> Map k2 a -> Map k1 a
16:26:43 <FunctorSalad> ?
16:26:50 <sm> EvilTerran: your second-last solution looks good here, but I can't make it work in my code. Is "(++) . map (second (:[]))" the combining fn ?
16:27:22 <mmorrow> orzo: that sounds cool. i'd love to see some of the code once you figure it out
16:27:25 <EvilTerran> it's (M.fromListWith (++)) . (map (second (:[])))
16:27:34 <EvilTerran> remember, function application binds tighter than any operator
16:27:41 <EvilTerran> the problem will be "second"
16:27:48 <EvilTerran> ?hoogle second
16:27:48 <lambdabot> Control.Arrow.second :: Arrow a => a b c -> a (d, b) (d, c)
16:27:48 <lambdabot> Data.Time.Clock.secondsToDiffTime :: Integer -> DiffTime
16:27:48 <lambdabot> Distribution.Configuration.parseCondition :: ReadP r (Condition ConfVar)
16:27:48 <ndmitchell> dcoutts, i just totally couldn't get an update to go through, which was depressing since i wanted to cabal install ghc-paths, which is new
16:28:01 <EvilTerran> ?src (->) second
16:28:01 <lambdabot> second f = id *** f
16:28:03 <sm> I made a second
16:28:07 <EvilTerran> ...
16:28:17 * sm boggles at that one
16:28:26 <mauke> @src (->) (***)
16:28:27 <lambdabot> (f *** g) ~(x,y) = (f x, g y)
16:28:31 <EvilTerran> with second f (x,y) = (x, f y) ?
16:28:54 <EvilTerran> sm, Arrow is a class which generalises functions
16:29:01 <sm> ok, cool
16:29:07 <sm> but what exactly the "combining function" argument being passed to fromListWith ? sorry for being slow
16:29:07 <dcoutts> ndmitchell: if it helps, you can manually download the tarball and gunzip it put it in the right place
16:29:21 <dcoutts> ndmitchell: if it's the cabal http code that's making things worse
16:29:27 <EvilTerran> that type could be written second :: Arrow (~>) => (b ~> c) -> (d,b) ~> (d,c)
16:29:34 <EvilTerran> with instance Arrow (->), (~>) = (->)
16:29:45 <EvilTerran> so substitute that in, and you get
16:29:49 <sm> seriously, I don't want to get into arrows now :)
16:29:50 <EvilTerran> ?djinn (b -> c) -> (d,b) -> (d,c)
16:29:50 <lambdabot> f a (b, c) = (b, a c)
16:29:59 <EvilTerran> simple :)
16:30:03 <vixey> sm: why nto
16:30:08 <EvilTerran> the parameter to fromListWith is (++)
16:30:16 <ndmitchell> dcoutts, i did in the end - it was the cabal update (downloading the new database) that was too slow, not downloading the package with cabal
16:30:33 <EvilTerran> the function you give it is passed the value you're trying to insert and the value that's already there
16:30:38 <sm> vixey: I'm already 10 levels deep into trying to do a simple task.. one of the goals is to become able to use haskell for quick scripts
16:30:44 <EvilTerran> and returns the value to actually put in
16:30:59 <vixey> sm: what if knowing about arrows makes it  easier
16:31:24 <BMeph> sm: Remember: "easy to describe" /= "easy to do" :)
16:31:32 <sm> vixey I hear you, but there has to be a some kind of progression so one doesn't have to learn the world to tie shoelaces :)
16:31:51 <EvilTerran> > M.fromListWith (+) [(y,x) | x <- [0..20], y <- cycle [0,1,2]]
16:31:55 <lambdabot>  fromList
16:32:00 <EvilTerran> er, that's not right
16:32:05 <EvilTerran> > M.fromListWith (+) [(y,x) | x <- [0..20], y <- [0,1,2]]
16:32:06 <lambdabot>  fromList [(0,210),(1,210),(2,210)]
16:32:18 <EvilTerran> well, rubbish example, but you get the idea
16:32:34 <EvilTerran> > M.fromListWith (+) $ zip [0..20] (cycle [0,1,2]) -- is what i was thinking of
16:32:35 <lambdabot>  fromList [(0,0),(1,1),(2,2),(3,0),(4,1),(5,2),(6,0),(7,1),(8,2),(9,0),(10,1)...
16:32:49 <EvilTerran> no it wasn't. i give up, i'm too tired for this
16:33:08 <EvilTerran> > M.fromListWith (+) $ zip (cycle [0,1,2]) [0..20] -- ...
16:33:09 <lambdabot>  fromList [(0,63),(1,70),(2,77)]
16:34:55 <EvilTerran> sm, anyway, do you follow?
16:35:40 <sm> EvilTerran: not yet, still digesting..
16:36:57 <hpaste>  osfameron annotated "implementation of uniq :: (Ord b) => [b] -> [b]" with "With Data.Set" at http://hpaste.org/8849#a1
16:37:25 <sm> side note: I always struggle to keep up with answers on this channel, and I note part of that is just the difficulty of testing things out interactively
16:37:26 <EvilTerran> > M.fromListWith (++) $ [(0,"a"),(1,"b"),(2,"c"),(1,"d"),(1,"e"),(0,"f"),(3,"d")]
16:37:27 <lambdabot>  fromList [(0,"fa"),(1,"edb"),(2,"c"),(3,"d")]
16:38:05 * sm considers erc for easier cut-paste in emacs
16:38:22 <EvilTerran> the function given to fromListWith tells it how to combine values when there are duplicate keys
16:38:24 <hpaste>  (anonymous) annotated "implementation of uniq :: (Ord b) => [b] -> [b]" with "(no title)" at http://hpaste.org/8849#a2
16:38:25 <newsham> everone ready for icfp?
16:38:34 <ndmitchell> osfameron: faster and lazy as well
16:38:38 * BMeph likes erc... but needs to re-learn emacs now :)
16:39:05 <osfameron> ndmitchell: I don't like having to reverse it though -- that breaks laziness doesn't it?
16:39:10 <sm-emacs> that was easy..
16:39:13 <EvilTerran> sm, it starts with the empty map, then goes through the list left-to-right, putting a value straight in if there isn't a value there already
16:39:25 * BMeph likes anything fast and lazy - especially himself! ;)
16:39:26 <EvilTerran> and giving the new value and the existing value to your combining function
16:40:17 <vixey> @seen Botje
16:40:18 <lambdabot> Botje is in #haskell and #haskell.dut. I don't know when Botje last spoke.
16:40:20 <sm-emacs> great, this where I'm hazy.. so if I want to keep both values, I return a list
16:40:45 <FunctorSalad> for some reason the emacs haskell mode uses that enormous circle rather than \circ for prettifying composition
16:40:54 <FunctorSalad> :)
16:40:56 <ndmitchell> osfameron: i pasted a better one, which doesn't haev the reverse, so is lazy
16:40:59 <osfameron> ndmitchell: ah I see, yes, I hadn't seen the annotation... so using explicit recursion rather than the fold avoids having to replace it
16:41:07 <osfameron> er, *reverse* it
16:41:07 <vixey> FunctorSalad: huh I just get a .
16:41:10 <EvilTerran> M.fromListWith f = foldl (\m (k,v) -> M.insert m k (if k `M.elem` m then (f v (m!v)) else v)) M.empty
16:41:13 <ndmitchell> osfameron: you can still use folds, i just didn't
16:41:23 <Jai`Lemon> Anyone ever heard of ChaCha? (chacha.com) - I work for them from home making $15/hour, google it, it's reputable. Just thought I'd share it. I have invites if anyone wants. It's hard to get hired without one. You get paid via a refillable debit card anytime you want. It's linked a real checking account. It's a real company, you work as an indepent contractor. The job and money is real. Want an invite or to know more? PM me.
16:41:41 <FunctorSalad> vixey: I enabled something in the options, know I get lamda x for \x and so on :)
16:41:44 <EvilTerran> sm-emacs, indeed, you want to keep all values
16:41:46 <FunctorSalad> *lambda
16:41:51 <sm-emacs> EvilTerran: what I don't get is the type signature o the combining fn (a -> a -> a) - as multiple values accumulate, how does that work ?
16:42:03 <EvilTerran> so first you put each one in a singleton list for simplicity
16:42:05 <FunctorSalad> *s/know/now/
16:42:26 <FunctorSalad> vixey: also pretty arrows instead of -> ;)
16:42:50 * monochrom considers writing haskell code from home to earn $15/hour.
16:43:30 <EvilTerran> sm-emacs, the parameter to fromListWith tells it what to do if it finds duplicate keys
16:43:32 <FunctorSalad> monochrom: sounds pleasant
16:43:54 <mauke> sm-emacs: how can you compute the sum of many number with just (+) :: Integer -> Integer -> Integer?
16:43:55 <EvilTerran> sm-emacs, it gives that parameter the value it just hit in the list, and the value already in the map, and replaces the value in the map with the return value of that function
16:44:10 <monochrom> Except there is no employer offering that. :)
16:44:47 <FunctorSalad> how to I flip a *pair* (don't tell me about doing it with flip, curry, uncurry, and unit ;))
16:44:53 <vixey> swap
16:45:05 <FunctorSalad> ?t swap
16:45:05 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
16:45:06 <vixey> swap (x,y) = (y,x)
16:45:14 <EvilTerran> FunctorSalad, with flip, curry, uncurry, &&&, ...
16:45:16 <EvilTerran> :P
16:45:17 <vixey> FunctorSalad: it may or may not already exist
16:45:21 <FunctorSalad> not in scope on my system for some reason
16:45:21 <EvilTerran> or by pattern-matching
16:45:28 <vixey> FunctorSalad: "swap" is a good name for it
16:45:33 <EvilTerran> it's not in the standard libraries anywhere
16:45:35 <vixey> and it's trivial to define
16:45:47 <EvilTerran> but, if it was, it'd probably be swap ~(x,y) = (y,x)
16:45:51 <vixey> why?
16:46:07 <vixey> swap tup = (snd tup, fst tup)
16:46:16 <sm-emacs> EvilTerran: right, I'm with you - I get that - so that's fine when combining the first and second a. Now when it combines the third a, doesn't it need to provide the list of [a1,a2] ?
16:46:22 <EvilTerran> that'll probably compile to almost exactly the same thing
16:46:25 <EvilTerran> but mine is shorter :P
16:46:31 <vixey> swap (x,y) = (y,x)
16:46:34 <vixey> is shorter still
16:46:39 <mauke> swap = snd &&& fst
16:46:41 <dolio> That's semantically different.
16:46:44 <EvilTerran> but not as lazy
16:46:45 <monochrom> shorter and stricter
16:46:49 <vixey> is that a problem ?
16:46:53 <monochrom> sometimes
16:46:55 <EvilTerran> sm-emacs, yes, that's what it does
16:47:10 <sm-emacs> so in my mind the combining function can't be a -> a -> a then
16:47:14 <mauke> sm-emacs: no
16:47:32 <mauke> sm-emacs: it has already combined a1 and a2 into b1
16:47:32 <EvilTerran> bear in mind that, in my example, a = [Char]
16:47:41 <mauke> sm-emacs: so it just calls f a3 b1
16:47:51 <sm-emacs> ok
16:48:00 <sm-emacs> I think I'm with you, finally
16:48:02 <EvilTerran> initially, it puts, say, "a" (ie ['a']) into the map
16:48:16 <EvilTerran> then, if it finds a duplicate key, it does (++) "a" "b"
16:48:23 <EvilTerran> and updates with the value "ab"
16:48:46 <EvilTerran> (except it's the other way round, according to my testing)
16:48:50 <EvilTerran> (so you'd get "ba")
16:49:33 <sm-emacs> low blood sugar + haskell not good!
16:49:55 <sm-emacs> now that I have the basic idea straight, I can fix this remaining glitch. Thanks a lot
16:50:37 <FunctorSalad> *me is still trying to to it via flip*
16:50:46 <FunctorSalad> sm-emacs: agreed
16:51:27 <BMeph> swap is a helper function in Control.Arrow, but I think it should be top-level. It's asked for too much. :)
16:51:46 <wuxia> ?paste
16:51:46 <lambdabot> Haskell pastebin: http://hpaste.org/new
16:52:05 <EvilTerran> BMeph, indeed
16:52:26 * EvilTerran has an evil thought involving overlapping instances
16:52:32 <mauke> :t uncurry (flip (,))
16:52:32 <lambdabot> forall b a. (a, b) -> (b, a)
16:52:33 <hpaste>  wuxia pasted "ghci complains of compile error on line 19, char 4 ... i don't know why" at http://hpaste.org/8850
16:53:06 <mauke> wuxia: your indentation is wrong
16:53:10 <FunctorSalad> :t flip
16:53:10 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
16:53:13 <LearningToFall-M> +e
16:53:16 <BMeph>  > M.fromListWith (flip (++)) $
16:53:16 <BMeph> 	     [(0,"a"),(1,"b"),(2,"c"),(1,"d"),(1,"e"),(0,"f"),(3,"d")]
16:53:16 <BMeph> <lambdabot>  fromList [(0,"fa"),(1,"edb"),(2,"c"),(3,"d")]
16:53:28 <wuxia> mauke: please explain, it looks fine to me
16:53:34 <EvilTerran> "{-# LANGUAGE MultiParamTypeClasses, OverlappingInstances #-}; class Get a t where get :: t -> a; instance Get a (a,b) where get = fst; instance Get b (a,b) where get = snd"
16:53:39 <wuxia> mauke: on, the polyArea's should be aligned; thanks
16:53:47 <BMeph> M.fromListWith (flip (++)) $ [(0,"a"),(1,"b"),(2,"c"),(1,"d"),(1,"e"),(0,"f"),(3,"d")]
16:53:49 <FunctorSalad> yes mauke, that was masterful ;)
16:53:55 <EvilTerran> use get instead of fst/snd or pattern-matching, and it doesn't matter which way round your tuples are :P
16:54:07 <BMeph> > M.fromListWith (flip (++)) $ [(0,"a"),(1,"b"),(2,"c"),(1,"d"),(1,"e"),(0,"f"),(3,"d")]
16:54:08 <lambdabot>  fromList [(0,"af"),(1,"bde"),(2,"c"),(3,"d")]
16:54:14 <EvilTerran> (well, your hetereogenous pairs, anyway)
16:54:20 <FunctorSalad> EvilTerran: I'm preparing an AscList for Mappification
16:54:30 <sm-emacs> > fromListWith (\a b -> a ++ b) [("a","1"),("b","2"),("a","3")]
16:54:31 <lambdabot>   Not in scope: `fromListWith'
16:54:48 <sm-emacs> > M.fromListWith (\a b -> a ++ b) [("a","1"),("b","2"),("a","3")]
16:54:49 <lambdabot>  fromList [("a","31"),("b","2")]
16:55:19 <FunctorSalad> abstractly what I'm doing is just the axiom of coice. maybe that should be in the lib for Data.Map ;)
16:55:27 <sm-emacs> and what I'm ultimately wanting is [("a",["1","3"]),("b",["2"])]
16:55:39 <EvilTerran> er... okay
16:55:51 <EvilTerran> sm-emacs, what, as a list, not a map?
16:56:11 <sm-emacs> sorry, I meant fromList [("a",["1","3"]),("b",["2"])] - a map
16:56:15 <EvilTerran> sm-emacs, are you sure you want ["1","3"] and not ['1','3']?
16:56:19 <sm-emacs> yup
16:56:23 <vixey> why not [1,3]
16:56:37 <sm-emacs> I'll paste what this is.. it's a "simple" thing
16:56:55 <EvilTerran> ok, well then you'll need to wrap the second value in the tuple in (\x -> [x])
16:57:00 <FunctorSalad> that is, from a "m :: Map k a" produce a "n :: Map a k" such that for all x in image m: "m ! (n ! x) = x"
16:57:19 <FunctorSalad> (choose a preimage for every dude in the image)
16:57:20 <EvilTerran> so the bare insert fromListWith does if the cell is presently empty is well-typed
17:00:19 <vixey> should I abstract ?
17:00:36 <FunctorSalad> definitely vixey! err, what? :)
17:01:00 <hpaste>  sm pasted "what I'm trying to do" at http://hpaste.org/8851
17:01:05 <vixey> I'll have some code doing first order unification on a data type
17:01:46 <vixey> I'm not sure if it would be best to implement for my data type, or abstract it (with typeclasses) so that it will work for any datatype
17:02:25 <hpaste>  sm annotated "what I'm trying to do" with "code so far (+ some cruft)" at http://hpaste.org/8851#a1
17:02:36 <vixey> the question is, if I abstract in this dimension would it make the actual code I'm writing simpler or not
17:02:45 <monochrom> No.
17:02:51 <EvilTerran> sm-emacs, i see
17:03:29 <vixey> then I suppose I shouldn't do it
17:04:21 <chessguy> @undo do { x <- f; y <- g $ h x }
17:04:21 <lambdabot>  Parse error at "}" (column 27)
17:04:37 <vixey> @undo do { x <- f; y <- g $ h x ; return () }
17:04:38 <lambdabot> f >>= \ x -> g $ h x >>= \ y -> return ()
17:05:31 <vixey> sm: second = (!!1)
17:05:41 <chessguy> f >>= g.h >> return (); -- yes?
17:05:41 <sm-emacs> much better, thanks
17:05:59 <sm-emacs> so my naive new combining function is (\a b -> [b] ++ [a]) but this says cannot construct the infinite type: a = [a]. ack!
17:06:09 <sm-emacs> not clear on this one
17:06:15 <vixey> why not write this in sh ?
17:06:21 <EvilTerran> > map (first head.unzip) . groupBy ((==)`on`fst) . sortBy (comparing fst) $ [("a","1"),("b","2"),("a","3")]
17:06:22 <lambdabot>  [("a",["1","3"]),("b",["2"])]
17:06:34 <EvilTerran> sm-emacs, a and b are already lists
17:06:39 <EvilTerran> you don't need to wrap them in [_] again
17:06:58 <sm-emacs> thought I'd make a list of lists (strings, here)
17:07:23 <mauke> :t (\a b -> [b] ++ [a])
17:07:24 <lambdabot> forall t. t -> t -> [t]
17:07:32 <EvilTerran> you need to wrap the snds (the values) in the lists in [_] before you give them to fromListWith
17:07:34 <mauke> clearly t is not [t]
17:07:45 <EvilTerran> because fromListWith has to return the same type as it takes
17:08:15 * EvilTerran would think it would make more sense to have an initial value ::b and a combining function ::b -> a -> b, but oh well
17:08:46 <EvilTerran> (as in, fromListWith :: (b -> a -> b) -> b -> [(k,a)] -> Map k b)
17:08:48 <sm-emacs> I'll do anything sensible, aside from stop using haskell for this :)
17:08:52 <pgavin> newtypes are strict, right?
17:09:02 <EvilTerran> pgavin, yes
17:09:08 <pgavin> k
17:09:16 <EvilTerran> well, no, not exactly
17:09:18 * sm-emacs should trake a break
17:09:58 <pgavin> how newtype Foo x different from data Foo !x?
17:10:05 <pgavin> s/how/how is/
17:10:07 <EvilTerran> given newtype Id x = Id x, the expression "case Id x of Id x -> ()" would fail in exactly the same cases as if the Id type and value constructor weren't there
17:10:51 <EvilTerran> ?wiki newtype
17:10:52 <lambdabot> http://www.haskell.org/haskellwiki/newtype
17:10:54 <EvilTerran> explains
17:11:09 <pgavin> because undefined :: Id x is what fails
17:11:28 <pgavin> e.g.
17:11:39 <pgavin> > let Id x = undefined in 0
17:11:39 <lambdabot>   Not in scope: data constructor `Id'
17:11:44 <pgavin> err
17:11:48 <EvilTerran> newtype Id x = Id x; case undefined of Id _ -> () -- this works
17:11:58 <pgavin> right
17:12:09 <EvilTerran> data Id x = Id !x; case Id undefined of Id _ -> () -- this fails
17:12:17 <pgavin> Id x doesn't get forced unless x is used
17:12:36 <EvilTerran> not really
17:12:39 * sm-emacs catches up with that last advice
17:12:44 <sm-emacs> > M.fromListWith (flip (++)) [("a",["1"]),("b",["2"]),("a",["3"])]
17:12:45 <lambdabot>  fromList [("a",["1","3"]),("b",["2"])]
17:12:49 <EvilTerran> in the strict data case, forcing the constructor forces its parameter
17:12:51 <pgavin> that one should work
17:13:19 <EvilTerran> in the newtype case, it doesn't, as the constructor doesn't exist at run-time, it's merely an illusion maintained by the typechecker
17:14:06 <EvilTerran> in that regard, a newtype is more like a normal data than a strict data is like a normal data
17:14:23 <EvilTerran> pgavin, as i said, have a look at http://www.haskell.org/haskellwiki/newtype
17:14:25 <lambdabot> Title: Newtype - HaskellWiki
17:14:34 <pgavin> k :)
17:14:36 <chessguy> sm-emacs: what's your code look like now? i can't get it to type
17:14:40 <pgavin> EvilTerran++
17:14:47 <pgavin> @karma+ EvilTerran
17:14:47 <lambdabot> EvilTerran's karma raised to 2.
17:14:50 <sm-emacs> coming up
17:14:56 <EvilTerran> :)
17:15:42 <FunctorSalad> yay, I did the "choose preimage" function: Map.fromList $ nubBy (\a b -> fst a == fst b) $ map swap $ Map.toList input
17:15:57 <hpaste>  sm annotated "what I'm trying to do" with "better" at http://hpaste.org/8851#a2
17:16:05 <pgavin> ok, I get it
17:16:08 <BMeph> EvilTerran: Maybe we should have fromListWith :: (a -> b -> b) -> [(k, a)] -> b -> Map k b, eh? ;p
17:16:12 <vixey> FunctorSalad: if you like you could drop the input and change $'s to .'s
17:16:28 <pgavin> you can't put undefined in a strict data, but you can in a newtype
17:16:30 <FunctorSalad> vixey: true
17:16:37 <vixey> :t M.fromList . nubBy ((==)`on`fst) . map swap . M.toList
17:16:40 <lambdabot> Not in scope: `swap'
17:16:52 <vixey> lambdabot needs to trawl #haskell for definitions
17:16:59 <EvilTerran> BMeph, you mean like foldr instead of foldl?
17:17:07 <FunctorSalad> wait, I thought lambdabot had it
17:17:17 <vixey> @let swap (x,y) = (y,x)
17:17:17 <lambdabot> Defined.
17:17:18 <vixey> lambdabot needs to trawl #haskell for definitions
17:17:20 <vixey> oops
17:17:21 <vixey> :t M.fromList . nubBy ((==)`on`fst) . map swap . M.toList
17:17:22 <lambdabot> forall k a. (Ord a) => M.Map k a -> M.Map a k
17:18:28 <BMeph> EvilTerran: Rather, more like the arrangement of fold discussed on -cafe a few days (weeks?) ago.
17:18:40 <FunctorSalad> hmm, k must be ord too
17:18:54 <BMeph> Of course, that paired list for a messes things up.
17:18:55 <EvilTerran> BMeph, ah, i see. with the initial value after the list.
17:19:24 <FunctorSalad> BMeph: but shouldn't it still complain?
17:20:37 <joekarma> is Haskell Lisp?  Or could Haskell in any way be called a Lisp?
17:20:50 <monochrom> No.
17:20:50 <EvilTerran> haskell has syntax
17:20:53 <EvilTerran> .'. no
17:21:08 <monochrom> ‚à¥ no
17:21:14 <vixey> . no
17:21:22 <pgavin> it's a lambda calculus
17:21:25 <FunctorSalad> ‚äó no
17:21:26 <pgavin> as is scheme
17:21:31 <EvilTerran> we're pretty much diametrically opposite lisp in many respects
17:21:36 <pgavin> which is also a lambda calculus
17:21:40 <EvilTerran> lisp has side-effects
17:21:40 <pgavin> and also a lisp
17:21:51 <FunctorSalad> haskell is also kinda sorta lambda-calculus (typed, though)
17:22:03 <FunctorSalad> I'd say the static typing is the largest diff
17:22:10 <EvilTerran> pgavin, if clisp is a lambda calculus, anything with closures is
17:22:27 <EvilTerran> python, perl, ruby, javascript...
17:22:28 <pgavin> I said it was *a* lambda calc, not a good one :)
17:22:40 <chessguy> @pl \x -> s ++ (c $ i " " $ l x)
17:22:40 <lambdabot> (s ++) . c . i " " . l
17:22:51 <monochrom> Algol is a lambda calculus.
17:23:01 <FunctorSalad> lisp also has much better code-as-data support
17:23:05 <monochrom> Landin said so. I rest my case. :)
17:23:06 <joekarma> good.  I'm arguing with someone in JavaScript who insists that Haskell and Lisp are the same thing.  I said they are not, but that Haskell was influence in some ways by Lisp.  He claims that since I don't think Lisp and Haskell are the same thing I am *clearly* ignorant of both languages.
17:23:08 <glguy> > M.fromList [(1,1),(1,2)]
17:23:09 <lambdabot>  fromList [(1,2)]
17:23:27 <joekarma> but from the looks of this "appeal to authority" I was correct
17:23:37 <vixey> Haskell has stronger influence from ML
17:23:38 <vixey> joe
17:23:45 <lament> joekarma: tell him he is an idiot, as evidenced by the fact that he's in a javascript channel.... oh wait...
17:23:57 <joekarma> the people in #lisp don't think they're the same thing either ;)
17:24:12 <monochrom> When I was a kid, I thought $1000 and $1000000 were the same thing.  You know, "huge amount of money".  Same thing.
17:24:13 <ndmitchell> joekarma: you mean someone on the internet is wrong?
17:24:14 <joekarma> hey, javascript supports closures and first class fnctions
17:24:15 <glguy> tell him that javascript is the same thing as java
17:24:17 <joekarma> it's not *THAT* bad
17:24:34 <joekarma> ndmitchell: heh.  nice xkcd reference ;)
17:24:45 <glguy> 386
17:24:51 <monochrom> Anyway, VBscript and Javascript are the same thing.
17:25:05 <FunctorSalad> monochrom: I'm afraid people still don't distinguish upwards of 1E6 or so, well with money up to 1E12
17:25:18 <monochrom> Yes indeed, FunctorSalad.
17:25:20 <pgavin> the progression of functional languages is like this: lisp -> scheme -> ml -> miranda -> haskell
17:25:22 <pgavin> sorta
17:25:42 <monochrom> You don't see any difference from afar. You have to get there, then oh boy, were you wrong.
17:25:46 <pgavin> so lisp and haskell are remotely related
17:25:51 <joekarma> ah right.. another thing.  I also asked this in #lisp.  Is lisp functional?
17:25:59 <FunctorSalad> I liked how McCarthy (?) calculated that nuclear power would be either useless or utopian if you shift the magnitudes down/up to still huge sounding numbers
17:26:00 <pgavin> joekarma: barely
17:26:05 <vixey> joekarma: absolutely
17:26:07 <ndmitchell> joekarma: yes
17:26:10 <EvilTerran> joekarma, it has unrestricted side-effects
17:26:10 <lament> vixey: not at all
17:26:17 <lament> err
17:26:19 <lament> joekarma: not at all :)
17:26:20 <idnar> haha
17:26:30 <ndmitchell> unrestrcited side-effects = impure
17:26:34 <EvilTerran> and a distinct lack of function combinators, eg composition
17:26:36 <pgavin> joekarma: scheme is more what I would call a functional language
17:26:42 <EvilTerran> so it's not purely functional, but you could argue that closures => functional
17:26:48 <joekarma> tail recursion in scheme
17:26:51 <monochrom> joekarma you're better off asking "does God exist".
17:26:57 <joekarma> hehe
17:26:57 <FunctorSalad> lisp has a functional subset, I'm not sure how hard it is to stay inside there though
17:27:00 <pgavin> joekarma: it allows side effects, but incourages functional style
17:27:06 <EvilTerran> but, when i say "functional", i usually mean "with enforced functional purity"
17:27:10 <vixey> joekarma: Don't read wikipedia if you want to understand programming
17:27:23 <pgavin> EvilTerran: is ml functional?
17:27:32 <EvilTerran> not by that metric, iirc
17:27:33 <joekarma> yeah, at first I told the same guy who insisted haskell was lisp that they were both functional
17:27:46 <joekarma> but then I saw the wiki page on Functional Programming....
17:27:50 <lament> joekarma: Nobody is really sure of what "functional" means, just like nobody is really sure what "object-oriented" means. Such terms are best not argued about
17:27:55 <EvilTerran> pretty much restricts me to very close relatives of Haskell and various dependently-typed languages and whatnot :P
17:28:04 <vixey> joekarma: wikipedia is nonsense when it comes to programming languages
17:28:08 <pgavin> EvilTerran: there are relatively few pure functional languages, so I think its better to be more inclusive
17:28:09 <EvilTerran> "functional" means whatever you've defined it to mean in any particular context
17:28:16 <monochrom> Does object exist?
17:28:19 <vixey> it's ok for algorithms except everything is in python
17:28:20 <FunctorSalad> unsafePerformDesecrationOfShrineOfReferentialTransparency
17:28:23 <EvilTerran> you could use it to mean "functions are first-class values"
17:28:29 <Apocalisp> "functional programming is programming with functions"
17:28:38 <pgavin> EvilTerran: that's the definition I usually take, along with closures
17:28:46 <EvilTerran> you could also require lexical closure
17:29:06 <EvilTerran> but you could also use it to mean "these things called functions actually *are* functions in the mathematical sense"
17:29:06 <pgavin> I think that's pretty much necessary and sufficient
17:29:10 <lament> you could require a bunch of things, that's not the point
17:29:12 <QtPlatypus> I normally think of "functional" as being a style of programing rather then a property of language.
17:29:16 <vixey> I define functional language as, the primary means of composition are function composition and lambda
17:29:24 <vixey> this rules out e.g. java is not functional
17:29:26 <dons> that rules out lisp :)
17:29:27 <joekarma> the "has side effects so therefore is not functional" thing is like losing match on a technicality
17:29:32 <EvilTerran> people use it to mean different things when useing it to describe a language
17:29:34 <lament> the point is that since there's no definition that everybody agrees upon, it's best to avoid using the term
17:29:39 <Apocalisp> EvilTerran: I like that definition. Programming with mathematical functions = functional programming.
17:29:40 <lament> instead of bothering to define it
17:29:40 <FunctorSalad> I think being able to do algebra with programs without hidden strings is a pretty good definition
17:29:49 <lament> because a definition will still just be -your- definition
17:29:50 <EvilTerran> lament, exactly
17:29:52 <joekarma> kind of annoying because it's like he's almost, but not quite entirely wrong
17:30:05 <vixey> joekarma: teach them haskell
17:30:07 <ndmitchell> QtPlatypus: i would say a functional language is one that promotes a functional style
17:30:11 <dons> but yes, an emphasis on composition, application, function abstraction and first class functions
17:30:19 <EvilTerran> i say "purely functional" or "with first-class functions" or whatever
17:30:30 <ndmitchell> its kind of a spectrum
17:30:32 <QtPlatypus> ndmitchell: Seems fair enought.
17:30:44 <dons> extending that further, functions should be pure, closures should be supported, evaluation strategies should be easily manipulable
17:30:49 <joekarma> EvilTerran: yes I probably should have said "they both have first class functions" when comparing haskell to lisp
17:30:55 <joekarma> instead of "they're both functional"
17:30:59 <dons> higher order functions should certainly be ubiquitous
17:31:02 <Apocalisp> I'd say functional programming applies to the programming and not to the languages in which programming is done.
17:31:03 <joekarma> the latter really opens me up to cheap shots
17:31:14 <lament> joekarma: right, so both lisp and haskell are just like javascript
17:31:25 <joekarma> in that regard yes
17:31:33 <FunctorSalad> in a way, they're also like a desk.
17:31:37 <monochrom> PHP is the same as BF.
17:31:38 <lament> right
17:31:38 <dons> but haskell would have to be more functional than lisp. you don't see things like category-extras emerging from the lisp community. there's something about typing and purity that encourages more functional exploration.
17:31:41 <joekarma> and god
17:31:52 <joekarma> in that they both have fictional aspects to them
17:32:30 <monochrom> Have you taken a look at Epigram and Agda?
17:32:43 <dons> why did category-extras appear in the haskell community? no other fp language comes close in the generalised evaluation strategies and recursion schemes that seem to be the epitome of hard core fp.
17:33:01 <FunctorSalad> dons: didn't haskell originate with ppl close to CT?
17:33:03 <EvilTerran> i blame the ghc-extended type system
17:33:10 <FunctorSalad> (not that I really know)
17:33:13 <EvilTerran> we all wish we were programming in agda
17:33:17 <dons> no, we have basically no professional category theorists.
17:33:20 <dons> but lots of language designers.
17:33:21 <vixey> EvilTerran: no we don't :P
17:33:32 <lament> isn't category theory all about static typing
17:33:39 <EvilTerran> vixey, ok, "a generally-usable version of agda"
17:33:43 <QtPlatypus> All the "Higher order foo" articals highlight the functional aspects that are exist in languages that we consider procedural.
17:33:44 <dons> but these kind of abstractions just don't exist anywhere else, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/category-extras-0.53.4
17:33:48 <lambdabot> Title: HackageDB: category-extras-0.53.4, http://tinyurl.com/5je3ho
17:33:55 <vixey> EvilTerran: Coq exists..
17:33:58 <dolio> You couldn't do most of category extras in Agda.
17:34:03 <ndmitchell> dons: we do have quite a few professional category theorists - Conor McBride springs to mind
17:34:15 <dolio> Or, you'd have to take a significantly different approach, at least.
17:34:16 <EvilTerran> haskell has by far the best utility:type system complexity ratio of a programming language, IMO
17:34:19 <ndmitchell> the Nottingham people have a lot of it
17:34:20 <monochrom> Yeah, you don't see OCaml people getting crazy about category-extras.
17:34:33 <EvilTerran> coq's too awkward and slow to really catch on
17:34:40 <ndmitchell> monochrom: without type classes its a little difficult
17:34:49 <FunctorSalad> yeah, I nearly went insane trying to rewrite type parameters in coq ;)
17:34:52 <EvilTerran> and, for anything with unconstrained side-effects, fancy traversal schemes feel a bit moot
17:34:55 <vixey> EvilTerran: I don't see anybody proving the four color theorem in Agda
17:34:58 <dons> maybe you need purity to make it possible to explore this chunk of the design space
17:35:04 <dons> without purity too much isn't feasible?
17:35:15 <EvilTerran> vixey, er, what?
17:35:22 <ndmitchell> dons: definately, purity gives much design space
17:35:27 <Pseudonym> It seems to me that coq is like TeX, and we need an equivalent of LaTeX.
17:35:30 <vixey> EvilTerran: re, awkward and slow
17:35:43 <Pseudonym> It's great, but interacting with it is at a too-low level.
17:35:45 <EvilTerran> um. ok, i think i follow.
17:35:46 <dons> you need purity and the type system to guide you towards these things.
17:35:54 <lament> Pseudonym: "we need latex for coq"?
17:35:56 <Pseudonym> The slowness is just a SMOP.
17:36:25 <dons> the rich new suite of purely functional data structures are another case.
17:36:26 <monochrom> He means TeX : LaTeX :: Coq : _____
17:36:32 <Pseudonym> Yes.
17:36:37 <dons> you just don't look behind that door if you're mutating things by default
17:36:47 <dons> so who knows that finger trees were hiding back there.
17:36:47 <Pseudonym> I'm saying you'd like a nicer interface built on top of coq.
17:36:49 <vixey> TeX : LaTeX :: Coq : Russel ?
17:37:04 <monochrom> All hail logic languages :)
17:37:09 <idnar> why is Haskell like a writing desk?
17:37:26 <vixey> idnar: take some more tea :)
17:37:27 <FunctorSalad> cats are involved in both?
17:38:10 <FunctorSalad> (lambdacats resp. cats sitting on desk)
17:38:13 * Pseudonym doesn't need logic languages any more, now that dmo has implemented CLP(FD) in Haskell.
17:38:19 <Pseudonym> (More or less.)
17:38:38 <FunctorSalad> huh?
17:38:47 <dolio> I'm not sure how much of category extras you could do in coq, either. Data must be strictly positive, right?
17:39:13 <FunctorSalad> I ran into problems with universes when I did the yoneda embedding
17:39:19 <vixey> Pseudonym: oh? is this online anywhere?
17:39:20 <dons> maybe category-extras is a good test for the expressive power of a language
17:39:34 <Pseudonym> vixey: It's in the latest HWN.
17:39:40 <FunctorSalad> haven't looked into category-extras
17:39:58 <dons> i bet most languages can get a couple of the abstractions out, but the whole suite is going to hammer a language's power.
17:40:05 <Pseudonym> Search for "David Overton".
17:40:10 * shepheb imagines implement category-extras in Java, and feels the bowels of the earth shudder as an ancient god awakens, bringing madness.
17:40:14 <dolio> For languages like that you need to go back to Menendez' old version an have a Fixedpoint class (module), I think, only you can't define Mu and Nu.
17:41:15 <joekarma> Okay guys, I have another really broadly-scoped question: Why do you guys think Haskell is the "language of choice for discriminating hackers?"  What inherent advantages, if any, do you think the language has that caused it to be the tool of choice for so many winners of the functional programming contest?
17:41:23 <hpaste>  sm annotated "what I'm trying to do" with "victory!" at http://hpaste.org/8851#a3
17:41:45 <dons> joekarma: basically, you have 3 days, so productivity matters, and bugs that happen after submission lead to immediate disqualification
17:41:59 <vixey> oh....
17:42:05 <vixey> that sudoku thing
17:42:07 <dons> so you need machine support for construction of correct code, + productivity of a high level langauge
17:42:10 <vixey> I don't think that could replace Prolog
17:42:13 <dolio> Of course, they give you the opportunity to model categories with objects other than types, but there again, you need universe polymorphism to make that nice. Agda doesn't have that. I'm not sure about Coq.
17:42:29 <Pseudonym> vixey: Bear in mind that Dave Overton is yet another ex-Mercury person.
17:42:32 <mrsolo> joekarma: nature of the contest plays well into haskell's hand
17:42:34 <joekarma> dons: okay, so you'd say it's easier to write "correct" code in Haskell?
17:42:47 <lament> no
17:42:51 <lament> it's harder to write incorrect code
17:42:59 <FunctorSalad> dolio: Coq has it, but it's tricky to avoid having the Type of the Ob / Hom set fixed once and for all
17:43:05 <joekarma> hehe fair enough
17:43:07 <shepheb> and much much harder to get incorrect code to compile.
17:43:09 <dolio> Ah.
17:43:11 <ndmitchell> joekarma: partly, i think it has to do with ICFP being an FP event
17:43:11 <chessguy> more like, harder to try to run incorrect code
17:43:16 <Pseudonym> In fact, I know of only one serious ex-Mercury person who hasn't taken up Haskell.
17:43:28 <Pseudonym> And he works for Microsoft, so he doesn't count.
17:43:29 <ndmitchell> plus higher-level etc, but the FP event thing probably has a big impact
17:43:53 <joekarma> ndmitchell: yeah, it definitely seems to be one of the most functional languages in town
17:43:54 <vixey> Mercury is basically half way from Prolog it Haskell
17:44:05 <Pseudonym> Kinda, yeah.
17:44:06 <vixey> they added types, functions.. yuck
17:44:23 <Pseudonym> At the time, we thought Mercury : Prolog :: Clean : Lisp
17:44:26 <vixey> complete wrong axis to extend Prolog on
17:44:30 <dons> the haskell side of things came up a lot in the refactoring contest 3 years ago.
17:44:43 <FunctorSalad> we did prolog at secondary school. I basically shoehorned it into imperative style ;)
17:44:45 <dons> when after a week you had one day to resubmit a working program based on the original submission
17:44:45 <Pseudonym> And actually, that's not a bad comparison.
17:45:10 <dons> any language that encouraged semantics-preserving refactoring had an advantage
17:45:44 <dons> the C programs did terribly after refactoring, segfaulting out of the contest. similar with the dynamically typed languages, which had runtiem bugs they didnt' have time to chase down.
17:45:46 <vixey> FunctorSalad: that's a shame
17:46:02 <vixey> FunctorSalad: It's so easy to embed a real imperative language
17:46:09 <vixey> no shoehorning is needed
17:46:33 <FunctorSalad> vixey: remember, I was young ;) was some kind of graph search where the backtracking didn't do exactly what I want
17:46:55 <Pseudonym> Yeah, Prolog actually is imperative programming.
17:46:57 <Pseudonym> In fact...
17:47:20 <Pseudonym> Some clever person proved it by showing just how few extensions you need to an imperative langauge to make Prolog.
17:47:33 <Pseudonym> They used Modula-2, IIRC.
17:47:40 <FunctorSalad> vixey?
17:47:46 <vixey> yes
17:48:04 <FunctorSalad> I was asking Pseudonym whether he was referring to you since you mentioned it a few secs ago ;)
17:48:25 <FunctorSalad> oops, you were talking about opposite things
17:48:43 <wagle__> i've been wondering why my brain gets confused when trying to reason about prolog non-imperatively
17:49:00 <vixey> You have to think about Prolog programs in two different ways at the same time
17:49:49 <hpaste>  (anonymous) annotated "ghci complains of compile error on line 19, char 4 ... i don't know why" with "(no title)" at http://hpaste.org/8850#a1
17:50:43 <vixey> anonymous: perhaps it's a layout problem, like indent the + a bit more
17:51:24 <Cale> It's the fact that polyArea isn't indented enough, I think
17:51:30 <Cale> It's not inside the where clause
17:51:38 <wagle__> yeah, i vote indentation too
17:51:44 <vixey> umm.
17:51:45 <vixey> [1 of 1] Compiling Shape            ( foo.hs, interpreted )
17:51:45 <vixey> Ok, modules loaded: Shape.
17:51:58 <Cale> You possibly need the definition of polyArea to line up with the type signature.
17:52:08 <wagle__> even though i wondered if rendering it to hpaste moved things around
17:52:29 <vixey> hpaste++ fixes haskell code automatically
17:52:54 <dolio> @seen edwardk
17:52:54 <lambdabot> I saw edwardk leaving #haskell-blah and #haskell 1d 43m 54s ago, and .
17:54:12 <sm> summary.hs output for the darcs codebase: http://joyful.com/SUMMARY.html
17:54:13 <lambdabot> Title: SUMMARY
17:54:46 <vixey> sm: how did you syntax color it ?
17:54:50 <sm> summary.hs + emacs, I mean
17:55:38 <sm> I write a text file with an emacs footer configuring haskell mode, orgstruct mode and highlight-lines-matching-regexp for the headings
17:55:47 <sm> and export as html
17:57:03 <sm> I haven't found a way to have both haskell-mode colouring and full org-mode navigation.. that would be better
17:58:32 <sm> and to have mouse-click on names jump to that tag. Then speedbar can bite my..
17:58:36 <BMeph> I still stand by my original impression of Lisp (although Scheme isn't quite so bad): it's a great language, for writing the language you'd rather be working in... :)
17:59:48 <vixey> http://edwinb.wordpress.com/2007/02/19/how-to-write-programs-in-two-easy-steps/
17:59:49 <lambdabot> Title: How to write programs in two easy steps ´ Types, Programming, etc., http://tinyurl.com/2cucxg
18:12:09 <vixey> is it possible for GHC to do the right thing with unicode
18:12:10 <vixey> ghci
18:12:19 <cjb> vixey: thought it already did
18:12:26 <vixey> > "œÜ"
18:12:26 <vixey> "\966"
18:12:27 <lambdabot>  "\966"
18:12:35 <vixey> I would like it to print "œÜ"
18:12:39 * sm commits http://joyful.com/Summarize and seeks food.. thanks for the help, all
18:12:39 <lambdabot> Title: summarize
18:13:24 <vixey> oh http://hackage.haskell.org/trac/ghc/ticket/2302
18:13:28 <lambdabot> Title: #2302 (error messages mangle unicode characters) - GHC - Trac
18:13:38 <vixey> maybe I should fix this ?
18:14:24 <vixey> actually 6.9 is a bit broken for me
18:14:33 <vixey> so I have to use 6.8.3
18:18:14 <agnokapathetic> hello all ::)
18:19:37 <agnokapathetic> im just starting out with haskell and had a quick question
18:20:41 <vixey> hi
18:20:45 <vixey> what ?
18:20:55 <vixey> is it about haskell
18:22:04 <agnokapathetic> yes :)
18:22:17 <agnokapathetic> im not sure if haskell is the proper language for the problem domain
18:22:35 <agnokapathetic> but. ive been working on frequency analysis of text http://hpaste.org/8852
18:22:58 <agnokapathetic> (runtime profile  as annotation)
18:23:01 <shepheb> what was that hpaste plugin for emacs called?
18:23:11 <agnokapathetic> and am wondering if theres anything i can do to speed it up?
18:23:17 <Nafai> shepheb:shim?
18:23:29 <agnokapathetic> its maxing out 1 core of my 4 available, and the major bottleneck is the sort
18:23:45 <agnokapathetic> is there an relatively easy way to get a parallel sort?
18:24:17 <cjb> agnokapathetic: what kind of sort?
18:24:22 * shapr hugs cjb
18:24:35 <cjb> (doing any operation in parallel is pretty easy, thanks to `par`)
18:24:38 <cjb> shapr: ello
18:24:47 <cjb> shapr: my openmoko just shipped, woo
18:25:03 <dolio> shapr: What have you done with edwardk?
18:25:13 <agnokapathetic> cjb: the sort is whatever is included in the standard library or Data.List
18:25:31 <agnokapathetic> cjb: but i think the group call might be the expensive part too
18:25:37 <cjb> dolio: that's a pretty personal question
18:25:39 <agnokapathetic> cjb: code here http://hpaste.org/8852
18:25:59 <dolio> Is he locked in your basement in a giant glass jar like Brocktoon?
18:26:08 <cjb> agnokapathetic: do you mean parallel as in multi-core?
18:26:19 <agnokapathetic> cjb: yes
18:29:24 <shapr> cjb: cool!
18:29:57 <shapr> j√§ttekul!
18:34:19 <gwern> icfp is tomorrow. I wonder what it'll be like this year?
18:34:53 <gwern> 'What are the minimum recommended hardware specs? ¬∂
18:34:55 <gwern> Answer (1): We recommend solving the problem on a computer. '
18:35:38 <wbaety> agnokapathetic: Sounds like you should throw in a -N2, 3 or 4 in there somewhere... :)
18:35:52 <agnokapathetic> when compiling?
18:36:21 * shepheb wishes he didn't have a ton of work to do before Wednesday, and could look at the ICFP stuff.
18:36:37 <agnokapathetic> wbaety: ahh i vaguely remember seeing something about the number of cores as a compile time directive
18:36:55 <shepheb> agnokapathetic: runtime. ./myProg +RTS -N2
18:37:08 <shepheb> where -Nn runs on n cores.
18:37:29 <wbaety> agnokapathetic: Better yet, -N4... er, what shepheb said. :)
18:38:10 <gwern> shepheb: actually, I'm lucky. my two days off start tomorrow
18:38:15 <shepheb> oh, and you'll have to compile with --threaded for that to work
18:38:33 <gwern> the timing is perfect for me - I come home from work and then in a few hours the lightning round starts
18:39:05 <dolio> I'm not sure that will do anything, since his program doesn't have any parallelism annotations or threads.
18:39:07 <gwern> (I just wish I knew how to prepare)
18:39:44 <dolio> Might make garbage collection faster.
18:39:52 <agnokapathetic> shepheb/wbaety: can i call the profiler and set -N4 at the same time? ( +RTS -N4 -p -RTS [args] doesnt work)
18:40:31 <wbaety> agnokapathetic: re-compile, as shepheb mentions. :)
18:40:59 <agnokapathetic> "ghc: combination not supported: Threaded/Profiling"
18:41:15 <agnokapathetic> i guess i could manually time it to see if theres a significant difference
18:41:47 <agnokapathetic> but like dolio said, there isnt anything explicitly parallel in there :-/
18:41:51 <gwern> didn't that get fixed in 6.8.3?
18:42:33 <shapr> agnokapathetic: Do you know Acapnotic?
18:42:58 <agnokapathetic> shapr: nope, i'm not really an IRC'r though if he's from around here
18:43:55 <shapr> agnokapathetic: No worries
18:44:20 <agnokapathetic> shapr: desktop search has his name on the header of the twisted matrix python libraries, same guy?
18:44:27 <shapr> Yeah, that's him.
18:44:32 <agnokapathetic> neat
18:44:37 <agnokapathetic> but yeah, no i don't know him
18:44:44 <shapr> Ok, just curious.
19:12:20 <adu> so confused
19:13:51 <adu> line 81 complains I need -XFlexibleInstances, so when I enable it, then 47 complains I need a type signature
19:14:25 <adu> and when I add a type signature it complains that I can't redefine type signatures in an instance declaration...
19:14:28 <adu> so confused
19:15:06 <adu> wb codetoad
19:29:51 <vixey> *Infer> runInfer (infer [] (Lam () "x" (Lam () "y" (Var () "y"))))
19:29:51 <vixey> Right (FVar "a" :~>: (FVar "e" :~>: FVar "e"))
19:33:42 <ddarius> That's an easy example.
19:39:04 <dons> this guy wants some help,
19:39:05 <dons>   http://www.reddit.com/r/programming/info/6r8m7/comments/
19:39:05 <lambdabot> Title: programming: I'd like some bitesize Haskell exercises
19:41:39 <bd_> looks like a job for project euler?
19:41:47 * vixey finally a working typechecker in haskell.. and I only had to implement 80% of Prolog
19:43:38 <SamB_XP> vixey: the rest will come when you implement undecidable instances
19:45:24 <ddarius> vixey: There's not much to Prolog.
19:45:33 <ddarius> Pure Prolog is a -tiny- language.
19:45:48 <vixey> yes
19:46:05 <vixey> I have copy_term/2 though
19:46:23 <vixey> for generalizing types
19:46:25 <ddarius> But yes, it's not at all surprising that you did as type checking is theorem proving for a rather simple theory and that's what Prolog is as well.
19:52:13 <dolio> What are the ()s for?
19:52:29 <vixey> when the real thing runs, they're SourcePos's from my parser
19:52:30 <adu> dolio: for holding things, obviously
19:52:41 <dolio> Ah.
19:52:59 <dolio> What's your type system like?
19:53:29 <dolio> Hindley-Milner, I guess?
19:53:44 <vixey> it's really really simple, basically it's simple types but with polymorphism and atomic types (like Bool, [Integer] etc..)
19:55:03 <mmorrow> vixey: awesome! darcs repo?
19:55:16 <vixey> not yet
19:55:22 <mmorrow> :)
19:56:13 <dolio> I've still been looking for information on checking dependent types without having to annotate every formal parameter.
19:56:57 <vixey> have you found much?
19:57:12 <dolio> Everything I find seems to either 1) have every lambda term annotated (same thing) or 2) bomb out on stuff like '(\a x -> (\y -> y) x) : (a : *) -> a -> a'
19:57:13 <mmorrow> dolio: so then you mean type *inference*
19:57:15 <mmorrow> ?
19:57:38 <dolio> The only promising thing I found was a paper on, essentially, Agda.
19:57:39 <SamB_XP> dolio: well, tried playing coq yet?
19:57:58 <vixey> ?where Ivor
19:57:58 <lambdabot> I know nothing about ivor.
19:58:00 <dolio> SamB_XP: Does Coq do it correctly?
19:58:02 <vixey> you should
19:58:13 <vixey> I don't think there is a "correct" here
19:58:30 <vixey> it's like proving programs terminate, you can always do better than the current best implementation
19:58:31 <SamB_XP> dolio: it doesn't do it incorrectly
19:58:47 <mmorrow> vixey: does you type checker both type inference *and* type checking?
19:58:49 <vixey> but it definitily does a good job
19:58:59 <vixey> mmorrow: only inference, I have to do checking now
19:59:02 <dolio> I hacked up my own little thing the other day, but I don't know how well it works.
19:59:36 <vixey> dolio, is it online ?
19:59:48 <mmorrow> vixey: cool. having done inference for expressions, will checking be easy or hard to add w/in you system?
20:00:02 <mmorrow> geez, i can't seem to type youR
20:00:10 <vixey> mmorrow: very easy, the language is so simple
20:00:13 <dolio> I don't think so. It was kind of a quick hack combining the pure type system and Hindley-Milner stuff I'd written earlier.
20:01:21 <vixey> dolio, you might look at Idris and Ivor, I know at least Idris (which uses Ivor) does some inference
20:01:22 <mmorrow> vixey: i guess what made me really appreciate the difference and be curious about it was reading some spj/gadt paper and in the case of gadts the *checking* is hard and the inference is easy
20:01:42 <mmorrow> i found that interesting
20:01:46 <mmorrow> find
20:02:01 <vixey> mmorrom: yeah GADTs must be tricky, because you can infer multiple possible types sometimes
20:02:36 <mmorrow> but apparently the inference is easy. it's the checking that's hard (or is that what you meant)
20:04:22 <vixey> mmorrow: I don't think type inference is the right name (for what dolio is talking about)
20:04:52 <mmorrow> so if you have an expression e, then an e' that's exactly the same syntactically as e, but has a programmer annotation on a GADT-related subexp, verifying that e' is correct is much harder than infering the type of that part of e'
20:04:59 <mmorrow> (^^ how i meant it)
20:05:09 <vixey> It's hard to tell if you are doing term or type inference, I think both are really mixed up together
20:05:41 <mmorrow> hmm, aren't they the same?
20:05:45 <vixey> oh I see
20:05:52 <dolio> It is inference, really.
20:06:18 <dolio> Inference is trivial if you annotate all the formal parameters of a lambda.
20:06:45 <mmorrow> oh, correction "verifying that e' is correct is much harder than infering the type of that part of e" NOT "...of that part of e'"
20:07:02 <dolio> For '\(x : a) -> e' you check a, and then infer e, and then the result is '(x : a) -> e'
20:07:16 <vixey> there's two types of problem, \(S:_) (a:_) -> a : (x:*) -> x   and   \(S:*) (a:S) -> a : _
20:07:41 <mmorrow> dolio: yes, i think checking only really become nontrivial when polymorphism is somehow involved
20:07:48 <mmorrow> (or something)
20:08:25 <dolio> The problem is that when you have just '\x -> e' you have to make up an a, and do some kind of unification.
20:09:13 <dolio> Or, you can easily *check* that some type '(x : a) -> b' is valid for '\x -> e'
20:10:13 <dolio> Whereas all the other terms are still easily inferred.
20:10:35 <dolio> Well, more or less.
20:11:05 <dolio> So the procedure for checking them becomes: infer their type, and test for equality against the specified type.
20:11:34 <dolio> But when you go to infer 'f x', either f or x may be a lambda term, which you can't infer.
20:11:50 <vixey> dolio: do you have an example term that you don't yet have an algorithm that can infer the gaps in?
20:11:52 <dolio> So most algorithms I've found just fail at that point.
20:12:44 <vixey> (oh where is the Agda paper about this?)
20:12:51 <dolio> vixey: My algorithm using unification seems to work for all the stuff I've tried, but I just threw that together myself, so it's not rigorous.
20:13:19 <vixey> oh you should put it online, it'd be great to see
20:14:17 <mmorrow> my understanding is that checking is only nontrivial in cases regarding polymorphism where inference can't succeed, so then the programmer has to supply an annotation which has to be checked for correctness (and there may be multiple interdependent annotation w/in an exp, etc.)
20:15:25 <mmorrow> but i can't remember or think of what could make the gadt checking harder than inference
20:15:29 <dolio> http://www.cs.chalmers.se/~ulfn/papers/meta-variables.pdf
20:15:31 <lambdabot> Title: Type checking in the presence of meta-variables
20:16:02 <dolio> That paper's not about agda, but it's about meta-variables, which I think is how agda does its type checking.
20:16:14 <mmorrow> ooh, nice
20:16:22 <dolio> And Ulf Norell is one of the authors.
20:18:26 <mmorrow> i guess my previous statement about checking and polymorphism really is just saying => the checker has to determine the correct class instance to use to particular functions given the programmer annotation
20:18:37 <hpaste>  dolio annotated "Dependent Type Checking with Unification" with "the rest" at http://hpaste.org/8854#a1
20:18:39 <mmorrow> s/to/for/
20:18:53 <SamB_XP> mmorrow: why does the type checker need to do that???
20:19:19 <SamB_XP> isn't that what proof search is for???
20:19:25 <mmorrow> hmm
20:19:33 <vixey> term inferrence = proof search
20:19:38 <SamB_XP> try Coq ;-)
20:19:54 <dolio> There's the stuff I threw together. But like I said, it may approve ill-typed terms and such.
20:19:59 <SamB_XP> (trunk, to be specific)
20:20:33 <vixey> isLam (Lam {}) = True
20:20:34 <mmorrow> SamB: i'm confused since i think the answer to that is "well of course it has to", so i think we're using a different definition for something
20:20:39 <vixey> cool! I didn't know about this
20:20:47 <vixey> the {} syntax
20:21:19 * ronwalf is having fits with Typeable and Data
20:21:25 <dolio> I'll see if I can port it to my stuff that has, for instance, a parser. :)
20:21:33 <ddarius> vixey: Yes.  Haskell has a tendency to handle corner cases you haven't even thought of.
20:21:38 <dolio> Since typing in abstract syntax is a pain.
20:22:55 <ronwalf> Anyone have thoughts on my last post to haskell-cafe?  (ie, why typeOf ([] :: [TermExpr]) returns undefined?)
20:23:20 <ddarius> dolio: Hasn't Lisp cast that thought from your mind?
20:23:26 <SamB_XP> {} syntax?
20:23:34 * gwern continues discussing paint color on libraries@
20:23:37 <ddarius> SamB_XP: Abusing record matching syntax.
20:23:41 <SamB_XP> oh, the empty record thing
20:23:42 <SamB_XP> yeah
20:23:54 <SamB_XP> I didn't realize we were talking about Haskell again
20:23:55 <gwern> I think split should have a nice puce color with purple trim, don't you? :)
20:24:01 <SamB_XP> I was just about to ask what language that was in
20:24:02 <SamB_XP> ;-)
20:24:31 <SamB_XP> gwern: what???
20:24:55 * SamB_XP checks the libraries mail
20:24:58 <dolio> ddarius: Heh.
20:25:29 <gwern> SamB_XP: you've never read the dogshed painting email?
20:25:49 <SamB_XP> gwern: library got to be so high-traffic I had to stop following it
20:26:17 <dolio> ddarius: Lisp doesn't make you write 'Cons (Atom "a") (Cons (Atom "b") (Const Nil))' for abstract syntax.
20:26:21 <gwern> SamB_XP: library isn't high-traffic compared to -cafe, not at all
20:26:34 <vixey> that's interesting dolio
20:26:37 <vixey> (the method)
20:26:54 <wuxia> is there a wya to define a type/data type that says : this is a list, but it has atleast 3 elements in it?
20:26:56 <SamB_XP> gweiqi: I had stopped following that before
20:26:59 <SamB_XP> er.
20:27:00 <SamB_XP> gwern:
20:27:06 <SamB_XP> I'm not even subscribed to that ;-)
20:27:20 <gwern> you poor out of touch person
20:27:23 <vixey> wuxia: no, you could use (a,a,a,[a]) or [a]
20:27:58 <vixey> dolio: have you seen Conor McBrides thesis ?
20:28:26 <dolio> No, I don't think so. That may be a good place to look, I suppose.
20:28:35 <dolio> I can't remember if Epigram makes you annotate lambdas.
20:29:19 <dolio> I did see a paper that he co-authored, I think, and all the lambdas had to be like '(\x -> e) : type' essentially.
20:29:34 <dolio> Which is no better than \(x : type) -> e, really.
20:30:05 <ddarius> gwern: I never get "Your useful generalization isn't the same as my useful generalization so we should uselessly do nothing."
20:30:52 <gwern> ddarius: no, I understand it. it's a fear of inertia and backwards compatibility and cruft
20:30:55 <ddarius> I also don't get why everyone seems to think that you need to make one split function to rule them all is the solution.
20:31:04 <gwern> once something makes it into the standard lib, hard to take it out
20:31:42 <ddarius> gwern: lines and words are far more "massive" and crufty.
20:31:46 <gwern> ddarius: hey, my split function does rule them all :) and if it doesn't, you can invert it to get the original and run your custom one in its stead
20:33:11 <gwern> anyhoo, I have to get going. I'm sure the discussion on libraries shall prove further enlightening...
20:33:16 <vixey> dolio: by the way there is a quite striking example of term/type infererence in http://edwinb.wordpress.com/2008/03/09/idris-a-language-with-dependent-types/
20:33:17 <lambdabot> Title: Idris, a language with dependent types ´ Types, Programming, etc., http://tinyurl.com/2dettx
20:33:44 <vixey> I don't know the mechanics behind it though
20:35:03 <vixey> it must be doing some proof search to figure things out
20:35:38 <dolio> Where exactly?
20:36:09 <vixey> starting from  fPlus : Term VNil (TyFun TyNat (TyFun TyNat TyNat));   on that page
20:37:29 <dolio> I'm pretty sure Agda will do that.
20:38:09 <dolio> You don't have to give a top-level annotation for things of the form 'foo = ...'
20:38:50 <dolio> Let me pull out my Agda translation of his interpreter.
20:48:56 <mmorrow> ooh, interesting two posts:
20:48:59 <mmorrow> http://www.haskell.org/pipermail/haskell-cafe/2007-January/021564.html
20:49:00 <lambdabot> Title: [Haskell-cafe] IO is not a monad, http://tinyurl.com/59bpma
20:49:05 <mmorrow> http://www.haskell.org/pipermail/haskell-cafe/2007-January/021627.html
20:49:06 <lambdabot> Title: [Haskell-cafe] IO is not a monad, http://tinyurl.com/6o3d5v
20:53:47 * ddarius didn't have a computer during that time.
20:55:48 <mmorrow> heh
21:01:47 <hpaste>  dolio pasted "Agda interpreter" at http://hpaste.org/8855
21:01:55 <dolio> vixey: ^^
21:02:08 <dolio> Crap, I forgot it has unicode...
21:02:33 <vixey> raw works
21:02:41 <vixey> hpaste--
21:03:07 <vixey> you'd think with all these great tools we could have more than 7 bit symbols..
21:03:10 <ronwalf> Well, at least I can compile my code.
21:03:17 * ronwalf hopes someone can help him fix it by morning
21:04:22 <vixey> dolio: I've read through bits of the Agda type checker but I don't really know if my vauge idea of how it does inference is actually true or not
21:04:35 <vixey> I should look over it again
21:05:11 <vixey> that's a cool program though
21:05:37 <dolio> Well, it's a pretty direct translation of the Idris. Nothing too complex.
21:05:56 <mmorrow> dolio: awesome (both)! i missed your paste before this one somehow
21:06:02 <vixey> yeah just the ‚Üë is neat
21:06:34 <mmorrow> dolio: what does "PTS" stand for?
21:06:42 <mmorrow> pure type system?
21:06:44 <dolio> Pure type system.
21:06:59 <mmorrow> cool
21:11:01 <dobblego> has anyone written a co-functor library? I looked in category-extras (hackage) but could not find it
21:11:14 <dolio> Contravariant functor?
21:11:19 <dobblego> yes
21:11:27 <dolio> There's a class for it in TypeCompose.
21:11:36 <kiris> great, another tiring night's sleep of dreaming about haskell, except with random ludicrous meta semantics. *rubs eyes*
21:11:39 <dobblego> is that a hackage library?
21:11:49 <dolio> Yeah. One of Conal's.
21:11:55 <dobblego> great thanks
21:12:38 <mmorrow> so, if someone were to say {Using "Term" instead of "Exp" is a convention deriving from (a@_) used when (b@_)} what would a and b be (if anything)?
21:12:45 <ddarius> I'm sure there's something in category-extras
21:13:25 <dolio> I think edwardk's moving away from covariant/contravariant functor classes.
21:13:25 <ddarius> mmorrow: I have no idea what you just said.
21:13:30 <vixey> me neither
21:13:39 <mmorrow> ok, rephrasing...
21:13:46 <dolio> Towards a multi-parameter functor class with associated categories.
21:14:38 <mmorrow> What implicit connotation(s) does using 'Term' instead of 'Exp' have for a datatype?
21:15:01 <dobblego> a contra-variant functor must still satisfy identity and composition, right?
21:16:18 <ddarius> dobblego: Except that cofmap (f . g) = cofmap g . cofmap f, yes.
21:16:29 <dobblego> right, cheers
21:16:39 <rwbarton> what does "multi-parameter functor class with associated categories" mean?
21:17:31 <vixey> mmorrow: I think Expression is something in a language like haskell, but Term is used to mean an Expression or a Type when you have a dependent typed language i.e. when Expressions and Terms are at the same level
21:18:34 <vixey> oops
21:18:38 <mmorrow> vixey: cool. that was somewhat my suspicion, but i didn't know how to phrase it.
21:18:41 <vixey> I meant when Expressions and Types
21:18:48 <mmorrow> heh, yeah i figured
21:20:11 <cetin> hi, can any one point me to a statemonad instance which simply increments an integer each time a bind occurs?
21:21:33 <vixey> cetin: http://uebb.cs.tu-berlin.de/~magr/pub/Transformers.en.html
21:21:34 <lambdabot> Title: Monad Transformers Step by Step
21:22:39 <cetin> vixey: thank u very much ^_^ reading it now...
21:24:41 <mmorrow> rwbarton: i think dolio meant "associated types"
21:25:12 <dolio> I don't think he uses actual associated types, but that's the idea.
21:25:34 <mmorrow> oh i see, associated category but in "quotes"
21:27:01 <mmorrow> (or something)
21:28:09 <dolio> class Category a where { id :: a b b ; comp :: a c d -> a b c -> a b d } ; class (Category c, Category d) => Functor f c d | f c -> d, f d -> c where map :: c a b -> d (f a) (f b)
21:28:12 <dolio> Something like that.
21:29:07 <mmorrow> heh.
21:29:55 <rwbarton> I see.
21:30:12 <rwbarton> So there's a category Hask = (->) and also a category HaskOp = "flip (->)"?
21:30:24 <mmorrow> me too, i had a totally different picture of what you meant
21:30:54 <dolio> Right.
21:32:10 <dolio> When you do that, you can go on to define adjunctions between categories other than just Hask.
21:32:29 <dolio> Which, at the least, gets you the adjunction that gives rise to the Cont monad.
21:32:38 <shepheb> dolio: that improved my understanding of category theory from "nearly nil" to "bit of an idea", thanks
21:34:26 <shepheb> is there an intro to Category theory written in a Haskell-like way like that? I imagine it would fit my brain bettre.
21:35:52 <hpaste>  dobblego pasted "Contra-variant Functor" at http://hpaste.org/8857
21:37:03 <dobblego> I thought there'd be an instance Cofunctor for (e (->)) but not in TypeCompose and I can't seem to get one myself; am I mistaken?
21:37:18 <rwbarton> there's no such thing as (e (->))
21:37:34 <rwbarton> (Well, unless e has some weird kind)
21:37:50 <dobblego> I'm trying to apply the type argument of the codomain of a function
21:37:59 <dobblego> ?kind (->)
21:38:10 <lambdabot> ?? -> ? -> *
21:38:25 <dobblego> is this not possible?
21:38:34 <mmorrow> dobblego: i've tried something along those lines only to realize it's impossible
21:38:48 <mmorrow> (or at least how i phrased it it was)
21:38:52 <rwbarton> I think you need a newtype
21:39:02 <mmorrow> i tried a newtype Flip
21:39:11 <mmorrow> and such, but eventually quit
21:39:13 <dobblego> mmorrow, and you still failed? I haven't even tried!
21:39:25 <mmorrow> i didn't try very hard though :)(
21:39:28 <dobblego> please let me try and fail :)
21:39:30 <mmorrow> s/(//
21:39:46 <dobblego> newtype Flip a b = Flip b -> a -- you used this?
21:39:52 <mmorrow> dobblego: i did qualify that with (or at least with my phrasing of it)
21:39:56 <slava> hi dobblego
21:40:00 <dobblego> hello slava
21:40:03 <atp> that's pretty interesting
21:40:11 <atp> (e (->)) i mean
21:40:12 <atp> hm
21:40:13 <mmorrow> dobblego: i think, lemme find that code
21:40:24 <dolio> Flip is the right way to go.
21:40:26 <dobblego> mmorrow, in the meantime, I'll stab around in the dark
21:40:30 <mmorrow> haha
21:40:36 <atp> you'd expect that to be a cofunctor, why wouldn't it be?
21:40:47 <dolio> Should I post the answer or not?
21:41:01 <dobblego> dolio, at least tell me if my newtype is correct
21:41:18 <dobblego> i.e. is that what you mean by a Flip?
21:41:28 <dolio> Yeah, although you need parentheses around b -> a
21:41:29 <rwbarton> atp: warning, ((->) e) is already "maps from e"
21:41:34 <dobblego> yeah got that :)
21:42:03 <atp> rwbarton: oh yeah, sorry, i mistyped... been up for a while :)
21:42:17 <rwbarton> atp: and you can't write sections of a type constructor
21:42:32 <dolio> slava: Why are you wasting our time with obscure lisp-like languages. Are you some kind of egomaniac? :)
21:42:45 <atp> factor isn't exactly lisp-like...
21:42:53 <slava> he's talking about MISC :)
21:42:53 <atp> i'd describe it as more forth like
21:42:55 <atp> oh
21:43:05 <atp> right, the map language
21:43:21 <atp> i knew that
21:43:38 <slava> factor has data types, unlike forth
21:43:48 <slava> and compile-time syntax tree transformations
21:44:21 <atp> factor seems pretty neat, but i confess i've never written anything in it
21:44:28 <atp> forth on the other hand...
21:44:32 * atp hugs forth.
21:44:45 <atp> rpn is the win
21:45:31 <vixey> where's info about MISC?
21:45:33 <dobblego> dolio, got an answer there?
21:45:46 <atp> vixey: slava posted something on reddit a bit ago
21:45:53 <vixey> ok..
21:45:56 <dolio> Yeah, you want it? I didn't know if you wanted me spoiling it.
21:46:02 <dobblego> dolio, yes please
21:46:07 <dolio> newtype Flip (~>) a b = Flip { unFlip :: b ~> a } ; instance Cofunctor (Flip (->) r) where comap f (Flip g) = Flip (g . f)
21:46:50 <elaforge> does anyone know if there's a way to get ghc --make to parallelize?  like -j in make
21:46:53 <dobblego> thanks
21:46:56 <dolio> Type checked in my head, not ghc, but I think it should work.
21:47:11 <dobblego> yeah it should
21:47:45 <vixey> so there's no actual information about it ?
21:48:07 <atp> misc?
21:48:36 <atp> http://will.thimbleby.net/misc/
21:48:37 <lambdabot> Title: MISC
21:48:59 <elaforge> oh, oops, I see it's a trac ticket already, milestone _|_ :(
21:49:14 <atp> haha, they have a bottom milestone?
21:49:16 <atp> that's awesome.
21:49:51 <elaforge> yes, most feature requests have that
21:50:27 <vixey> that interpreter doesn't work
21:50:34 <atp> i haven't tried it.
21:50:48 <atp> i just read through the bottom stuff
21:50:49 <hpaste>  morrow pasted "Yoneda catastrophe" at http://hpaste.org/8858
21:51:03 <atp> long enough to realize that map was not fmap :)
21:52:40 <mmorrow> dobblego: pasted. i think what i was trying to do is impossible, but i'm sure it's very possible to somehow express the situation in haskell
21:53:18 <hpaste>  (anonymous) annotated "Contra-variant Functor" with "(no title)" at http://hpaste.org/8857#a1
21:53:32 <dobblego> mmorrow, that's what I ended up with ^
21:55:09 <mmorrow> yeah, my problem was i was trying to make Flip/CoHom an instance of *Functor*, and i don't believe that's possible given the definition of functor
21:55:21 <atp> no, it shouldn't be
21:55:24 <dobblego> oh definitely not
21:55:28 <mmorrow> hehe
21:55:35 <atp> functors are explicitly covariant in haskell i think
21:55:41 <dobblego> that must have been painful for you :)
21:55:52 <mmorrow> haha, it was/is
21:55:55 <rwbarton> fmap is precisely covariance
21:57:34 <mmorrow> i think there should be a class CovFunctor, class ConFunctor , and class Functor , then instance Functor {Cov,Con}Functor (imagine this is done in a way that makes sense)
21:57:43 <mmorrow> or something
21:58:03 <atp> doesn't category extras have a cofunctor class?
21:58:05 <atp> or similar?
21:58:17 <dobblego> I thought so, but my feeble attempts to find it failed
21:58:33 <mmorrow> atp: probably, i need to finally check it out in detail
21:58:59 <atp> i think he has like pfunctor and qfunctor which he uses to define bifunctors
21:59:04 <atp> i can't remember exactly
21:59:19 <dolio> http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Functor.html
21:59:21 <atp> there was some limitation in haskell's type system that prevented him from doing it simply
21:59:23 <lambdabot> Title: Control.Functor, http://tinyurl.com/65gqxt
21:59:56 <mmorrow> atp: i hate when that happens!
22:00:44 <atp> still, it's pretty awesome how cleanly category theoretic notions can be expressed in haskell's type system
22:01:18 <mmorrow> atp: oh yes.
22:03:09 <cetin> Can I paste a piece of code somewhere and ask a related question here in the channel?
22:03:17 <atp> i don't like implicit bottom i've decided
22:03:24 <dobblego> cetin, sure, http://hpaste.org
22:03:25 <atp> cetin: hpaste
22:03:49 <vixey> atp: You want to program in a total language ?
22:04:01 <cetin> dobblegom,atp: thanks
22:04:06 <atp> vixey: no, just one that has clean separation
22:04:31 <vixey> like a total language
22:04:41 <atp> vixey: well, no, because only a subset would be total
22:05:23 <atp> vixey: but an explicitly defined subset... clean separation of data and codata, that sort of thing.
22:05:59 <atp> bottom breaks too much stuff
22:06:16 <adu> whats a total language?
22:06:19 <dolio> Like something with 'generalToIO :: D a -> IO a'.
22:06:35 <lament> a language where all functions are total? :)
22:06:35 <vixey> adu: every function is total
22:06:35 <atp> adu one that will always halt
22:06:51 <lament> hm
22:06:58 <lament> oh right.
22:07:04 <adu> how does D a -> IO a ensure halting?
22:07:23 <dolio> It doesn't. That's how you get non-halting.
22:07:32 <dolio> Or, non-productive halting.
22:07:40 <dolio> Non-productive non-halting, that is.
22:07:56 <adu> so total == halting?
22:07:57 <atp> it's more complex than all that though... you also need clean separation of finite and infinite data structures and such...
22:08:09 <vixey> adu: simply typed lambda calculus is an example
22:08:23 <hpaste>  Cetin Sert pasted "StateMonad" at http://hpaste.org/8859
22:08:44 <dolio> Not necessarily. You can have non-terminating programs in a total language, but they must be productive.
22:08:52 <rwbarton> cetin: put (n+1)
22:08:54 <adu> atp: like lazy vs strict?
22:08:55 <vixey> adu: no undefined values
22:09:03 <atp> adu: no difference in a total language
22:09:10 <vixey> adu: all total functions <=> no partial functions
22:18:39 --- mode: irc.freenode.net set +o ChanServ
22:18:56 <dolio> However, to get general recursion back in the language, you need some top-level thing that will run your monadic, general recursive computation (in a total language, you can only do things like "see if it completes within N steps").
22:19:01 <dolio> Which is why I suggested some operation D a -> IO a, D being the general recursion monad.
22:19:11 <rwbarton> cetin: "| m -> s" is a "functional dependency".  It means m "determines" s
22:19:51 <dons> jre2: its ok for syntax highlighting.
22:20:06 <dons> jre2: hpaste2 uses it
22:20:25 <dolio> Coinductive types are essentially potentially infinite data structures.
22:20:54 <adu> hmm
22:21:06 <dolio> Inductive types are what most people are probably used to.
22:21:14 <rwbarton> dolio: Is D a = Now a | Later (D a)?
22:21:16 <dolio> Inductive types you build with constructors, and tear down with folds.
22:21:18 <adu> like bigarrays
22:21:21 <dolio> rwbarton: Yes.
22:21:40 <dolio> Coinductive types you build with unfolds, and tear down with destructors/observers.
22:22:37 <adu> where Array t = A Integer t ; Integer = Array Bit
22:23:17 <adu> something like that, is that coinductive?
22:23:39 <dolio> In Haskell, coinductive and inductive types are the same, but in (most?) total languages, they're different.
22:23:45 <vixey> every data type in haskell is coinductive
22:24:47 <vixey> data Ourbourous = Chew Ourbourous
22:25:01 <adu> creepy
22:25:06 <vixey> (if you forget _|_) is only inhabited by a coinductive value
22:25:14 <vixey> which is Chew (Chew (Chew (Chew (...
22:25:18 <adu> lolol
22:25:20 <vixey> @src []
22:25:20 <lambdabot> data [] a = [] | a : [a]
22:25:35 <vixey> You can think about [1,2,3,4] and such inductively
22:25:44 <vixey> but [] is still coinductive since fix (1:) is valid
22:25:59 <adu> > fix (1:)
22:26:00 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
22:26:20 <vixey> if you have an inductive value,
22:26:24 <adu> > fix undefined
22:26:25 <vixey> f [] = k
22:26:25 <lambdabot>  Exception: Prelude.undefined
22:26:30 <vixey> f (x:xs) = ... f xs ...
22:26:55 <vixey> definitions like that will always terminate since the size of the parameter always decreases
22:27:11 <vixey> obviously this doesn't prove termination of a corecursive function
22:28:09 <adu> so many co's
22:28:28 <Trinithis> is mapReader the same as fmap?
22:28:33 <vixey> by corecursive I mean recursion on a coinductive object
22:29:09 <ddarius> Every datatype in Haskell is inductive.
22:29:46 <vixey> huh?
22:29:54 <adu> the only co I COmpletely understand is the reversing arrows kind
22:30:43 <ddarius> Okay.  Probably the accurate statement is every data type in Haskell is neither coinductive nor inductive.
22:30:59 <hpaste>  Cetin pasted "StateMonad bind" at http://hpaste.org/8861
22:31:00 <vixey> why is not accurate to say that they are all coinductive?
22:31:52 <ddarius> vixey: Well they certainly aren't all coinductive, but as dolio said coinductive and inductive are the same in Haskell.
22:32:10 <ddarius> So it's no less accurate to say every type is inductive.
22:32:30 <adu> i'm so confused
22:32:52 <adu> how can they be equal and opposite at the same time?
22:33:11 <ddarius> adu: They happen to be the same in the case of Haskell.  Haskell isn't the only language.
22:35:24 <ddarius> Anyway, I need to sleep.
22:35:30 <adu> ddarius: ok
22:37:07 <adu> hmm, this article on Coinduction refers to "A Hidden Agenda", but I can't find it, it must be really hidden
22:41:52 <adu> found it http://citeseer.ist.psu.edu/62277.html
22:41:53 <lambdabot> Title: A Hidden Agenda - Goguen, Malcolm (ResearchIndex)
22:42:22 <tunaka> I apologize if this is dumb (it probably is), but why does this code produce the attached error message: http://pastebin.com/d1f79e15d
22:42:35 <codetoad> Cetin: I didn't look at the compile error, but I believe you want to do the sequencing of the state functions *before* you runState.  so, like runState (s0 >> s1).  also, it looks like you might be confusing things - tick is used as both a value (m a) and a binding function (a -> m b)
22:42:36 <wuxia> how do I fix the following? (I get a typing error): data Shape = Polygon [Vertex]
22:42:39 <wuxia> convex (Polygon []) = True
22:42:41 <wuxia> convex (Polygon v1:[]) = True
22:44:44 <sjanssen> wuxia: more parens are needed
22:44:49 <adu> tunaka: because you're trying to take 5 elements from a 3 element list
22:45:12 <sjanssen> convex (Polygon (v1:[])) = True
22:45:21 <adu> tunaka: and because you're calling testcombine incorrectly
22:45:30 <sjanssen> or just: convex (Polygon [v1])
22:45:47 <Trinithis> why does liftIO exist when lift exists?
22:45:56 <adu> tunaka: testcombine [1,2,3] [1,2,3,4,5] should work
22:46:00 <wuxia> sjanssen: thanks
22:46:04 <sjanssen> Trinithis: liftIO can lift through many transformers, lift only lifts one level
22:46:12 <Trinithis> ok
22:47:05 <tunaka> adu: k, that seems to have fixed it. I don't quite understand the significance of () v.  straight params..
22:47:37 <vixey> wuxia ()'s
22:47:42 <vixey> tunaka: You write testcombine ([1,2,3,4,5],[1,2,3])
22:47:46 <vixey> tunaka: which is a tuple of two lists, you should write testcombine [1,2,3,4,5] [1,2,3]
22:47:48 <adu> tunaka: when you call with (a, b) you're not calling the function with those parameters, you're calling the function with a single parameter, the _tuple_ (a,b)
22:47:52 <vixey> tunaka: in general write f x y z not f(x,y,z), f x y z = ((f x) y) z
22:48:08 <vixey> tunaka: in haskell, rather than a function taking two parameters and returning a value, it takes one parameter and returns a function that takes one parameter then returns a value
22:48:13 <vixey> tunaka: That's currying
22:49:50 <tunaka> k, thanks. I read that but it didn't sink in.
22:50:21 <tunaka> the compiler error was completely unintelligible! :-)
22:50:37 <vixey> > let add x y = x + y in let stageOne = add 3 in stageOne 4
22:50:39 <lambdabot>  7
22:50:46 <vixey> > let add x y = x + y in add 3 4
22:50:48 <lambdabot>  7
22:50:59 <adu> tunaka: all you need to know is that f in "f a b" is a function of 2 args and g in "g (a, b)" is a function of 1 arg
22:51:21 <vixey> adu: No you need to know a lot more than just that to program in haskell
22:51:33 <vixey> You wont learn a programming language by reading compiler errors by the way
22:51:40 <wuxia> for a 2d closed polygon (may be self intersecting), what is the most efficient way to determine if it's convex?
22:53:03 <Trinithis> does the "local" functionin MonadReader permanently change the environemnt? Or does it only last for one computation?
22:53:14 <wuxia> okay; figured it out
22:53:39 <wuxia> i have a list ... i either want to insert the first two elemnts at the end of the lsit, or i want to insert the last two elements at the front of the list ... what is the most efficient way to do this? (don't know how this interacts with laxiness)
22:53:49 <mwc> Trinithis: it's in effect for the action it's given
22:53:55 <mwc> :t local
22:53:58 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
22:54:09 <Trinithis> ok
22:54:11 <vixey> wuxia: You can do this in O(0) time
22:54:17 <wuxia> oh
22:54:18 <wuxia> how?
22:54:23 <wuxia> O(1) ?
22:54:27 <vixey> wuxia: O(0)
22:54:46 <wuxia> how do I do this ?
22:54:47 <vixey> wuxia: say your list has elements [x,y,z]
22:54:48 <wuxia> show me the code
22:55:01 <adu> vixey: but honestly currying isn't all that hard, but I really don't like the classic "returning a function each time" approach, I perfer the "returning a function with the unused args" approach
22:55:09 <vixey> wuxia: I let mine = (3,[x,y,z,x,y,z,x,y,z,...])
22:55:12 <vixey> oops
22:56:07 <wuxia> err, this creates me a tuple, not a list
22:56:18 <wuxia> oh wait
22:56:19 <adu> vixey: plus its usually when people walk away from me when I tell them why I like Haskell...
22:56:27 <wuxia> i think i misphrased my question
22:56:37 <adu> :P
22:56:57 <wuxia> i want to either insert the first two elements into the end of the list; or I wnat to insert the last two elemnts of a list into the front ... you code seems to assume that my list only has 3 argyuments
22:57:02 <wuxia> i don't know before hand how many argyuments my code has
22:57:09 <wuxia> err, how many elements my list has
22:57:17 <vixey> wuxia: if you have n elements (n,...)
22:57:28 <wuxia> ? i do not  understa
22:57:36 <wuxia> can you post code that takes an list of arbitrary length?
22:57:55 <vixey> wuxia: actually it depends on if you're cycling through the list or permuting it
22:59:00 <wuxia> i don't care ... if my list is of form a:b:...:x:y:[] i just wnat either x:y:a:b:...:x:y:[] or a:b:...:x:y:a:b:[]
22:59:22 <Trinithis> > uncurry take (3, [1..])
22:59:23 <lambdabot>  [1,2,3]
22:59:56 <adu> wuxia: f x = last x ++ init x
23:00:30 <vixey> :t let f x = last x ++ init x in f
23:00:32 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
23:00:32 <lambdabot>       Expected type: a
23:00:32 <lambdabot>       Inferred type: [a]
23:00:33 <adu> or g x = tail x ++ head x
23:00:34 <wuxia> what is the running time of last x ?
23:00:41 <wuxia> is it O(n) or O(1)
23:00:50 <vixey> last is O(n)
23:00:53 <vixey> ++ is O(n)
23:00:59 <vixey> init is O(n)
23:01:03 <wuxia> so how is this algorithm O(0) ?
23:01:04 <vixey> tail is O(1)
23:01:20 <vixey> wuxia: because I didn't use any of those
23:01:32 <wuxia> okay ... how does your code work again?
23:01:55 <vixey> wuxia: You want to cycle through a finite list
23:02:18 <vixey> wuxia: Rather than that you could just walk a cyclic list
23:02:25 <vixey> you will have to pair up the elements though
23:02:42 <vixey> since a:b:...:x:y:[] ~> x:y:a:b:...:x:y:[] is permuting
23:03:03 <vixey> oh actually it's not, that's fine
23:03:50 * adu sleeps
23:04:33 <wuxia> i don't know bfore hand how long the list is
23:04:45 <vixey> :t length
23:04:46 <lambdabot> forall a. [a] -> Int
23:04:55 <wuxia> and length is O(1)
23:04:56 <wuxia> ?
23:05:04 <wuxia> orf rather O(0) ?
23:05:31 <wuxia> actually, n/m this doens't amtter; i'll just use a dumb implemendtation and worry if it's my bottleneck
23:05:36 <vixey> wuxia: what do you mean bfore hand?
23:10:07 <_zenon_> What is faster?  show (somedatatype) or creating my own show routine for it? If outputting to file
23:11:01 <sjanssen> _zenon_: Show is not exactly known for speed
23:11:24 <sjanssen> _zenon_: does it need to be human readable?  If not, I'd recommend the binary library
23:11:34 <_zenon_> sjassen: Maybe that is what's killing my time, will take a look at it when I come home then
23:11:47 <_zenon_> sjassen: Binary library?
23:11:54 <sjanssen> @hackage binary
23:11:55 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/binary
23:12:17 <sjanssen> that library provides efficient binary serialization
23:12:39 <_zenon_> sjassen: No, doesn't need to be human readable, just want to output a lot of processed data for later use
23:18:45 <FunctorSalad> "cabal: Unresolved dependencies: sourceview >=0.9.12", but sourceview doesn't exist?
23:49:28 <novas0x2a> I'm new to haskell, and I think my implementation is working against me. Could someone possibly do a bit of a code review for me, and help me with how a Proper Haskeller would do this? I'd <3 you forever! http://hpaste.org/8862
23:51:42 <sjanssen> novas0x2a: first thing, I probably wouldn't use a Board class
23:53:38 <novas0x2a> mostly, the reason i did that is at some point i'd like to make it so i can re-use the implementation for othello (though, at this point, it has c4-specific stuff)
23:54:23 <novas0x2a> playCol, colIsFull, and fullColls are definitely c4-specific
23:54:29 <sjanssen> Othello and Connect 4 can use the same data structure, IIRC
23:54:51 <lament> a strange observation
23:54:51 <sjanssen> both are grids where a space is either color A, color B, or empty
23:55:12 <sjanssen> where they really differ is where one can insert a token, and what happens when you do
23:55:33 <novas0x2a> true
23:56:03 <sjanssen> so one thing we usually do in Haskell is separate the data structure from the operations (which is opposite from OO programming)
23:58:43 <novas0x2a> so, with that, i'd have a data Board and board operations in a module, and then something like Board.C4 with functions like c4PlayToken?
23:58:59 <sjanssen> well, they might be in the same module
