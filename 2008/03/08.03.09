00:13:25 <hpaste>  JRX pasted "GHCi bug?" at http://hpaste.org/6231
00:14:02 <jrx> hi, what do you think, about ghci type inference in the example I have pasted?
00:14:06 <jrx> is it ok?
00:14:24 <jrx> when I give lmax explicit type signature, everything works fine
00:14:52 <jrx> but without, it inferes pretty useless type [()] -> ()
00:15:09 <jrx> I thought that always the most general type should be inferred
00:15:14 <jrx> is it a bug in ghci?
00:15:59 <Cale> jrx: Monomorphism restriction
00:16:10 <Cale> jrx: It's not a bug, it's just a misfeature of Haskell 98.
00:16:31 <Cale> Pattern bindings without explicit type signatures must have monomorphic types.
00:17:01 <Cale> In GHCi, rather than giving you a type error, it just defaults those to ().
00:17:41 <Cale> You can turn off this misfeature by the flag -XNoMonomorphismRestriction
00:18:41 <Cale> (The upside of the MR is that it prevents certain bits of code which look like they should run in linear time, but actually run in exponential time, because polymorphic things don't get memoised like monomorphic ones.)
00:19:23 <Cale> *specifically* when typeclasses are present, since they actually turn values into functions
00:19:30 <desegnis> jrx, or you may circumvent the monomorphism restriction by making the list an explicit argument, i.e., let lmax xs = foldl1 mmax xs
00:19:34 <dolio> Was the MR not in pre-98 Haskell?
00:21:05 <Cale> I'm pretty sure it was '98 that introduced it, but I might be wrong.
00:21:22 <dolio> Huh.
00:21:33 <Cale> I'll check
00:21:35 <dolio> I guess that would be on the evil, anti-polymorphism agenda. :)
00:23:13 <Cale> Yeah, '98 was a step backwards in many ways.
00:23:18 <dolio> 1.0 had mutually recursive modules.
00:24:40 <Cale> oh, 1.4 did have the MR
00:24:50 <JohnMeacham> gwern: Hmm.. that seems odd. 'sed' is pretty straightforward. you can comment out that line if you want in the makefile.
00:24:52 <Cale> '98 has mutually recursive modules
00:25:06 <Cale> It's just that all the implementations suck at implementing them.
00:25:24 <dolio> Oh, huh.
00:26:20 <dolio> I don't see anything about the MR in the 1.3 contents.
00:26:58 <Cale> It's at 4.5.4
00:27:59 <glguy> anyone remember what ticket number "compiler warning for exporting functions whose types aren't exported" was?
00:28:20 <dolio> Ah, so it is. They just added it to the contents in 98.
00:30:06 <paolino> is it possible to calculate the memory used by a fully evaluated array ?
00:31:23 <dolio> Cale: Added in 1.1?
00:31:33 <paolino> the elements are (((Integer,Integer),Double),(Integer,Integer,Double)))
00:31:41 <dolio> I don't see it in 1.0...
00:31:56 <Cale> 1.0 has some confusing restrictions instead.
00:32:09 <dolio> Ah.
00:32:32 <Cale> They're somewhat more permissive than the MR, but perhaps even stranger.
00:32:41 <Cale> er...
00:33:00 <Cale> yeah
00:33:13 <dolio> 'variables not bound directly to lambda abstractions must not be used at more than one distinct overloading.'
00:33:33 <Cale> right
00:34:12 <Cale> So that has the same effect as the MR, but allows the variables to actually have a polymorphic type.
00:34:50 <Lemmih> paolino: Not really.
00:34:56 <dolio> Oh, I see.
00:35:22 <paolino> Lemmih: only runtime speculations then ?
00:35:32 <Cale> (if they occur in a where clause, and are not top-level)
00:35:42 <paolino> observing the program running
00:36:31 <Cale> But there doesn't appear to be a way to circumvent the rule using explicit type signatures either. You have to explicitly turn such variables into functions.
00:37:01 <dolio> It seems to type 'foo = \x -> e' the same as 'foo x = e' too, no?
00:37:24 <Cale> yeah
00:37:46 <Cale> But that's a variable bound to a lambda abstraction, so the restriction won't apply.
00:38:08 <dolio> Right. But the monomorphism restriction does.
00:38:13 <Cale> yeah
00:38:35 <paolino> Lemmih: np, I will use my failable experimental observer side for this also :]
00:39:02 <Cale> I really think that how many times something is going to be evaluated isn't something which the report should be worrying about.
00:39:20 <Cale> The entire rest of the report doesn't say anything about how anything gets evaluated.
00:39:26 <paolino> in the end only complexity shold matter to serious programmers, I suppose
00:39:38 <dolio> Although, those rules don't seem to allow for adding a type signature to make actual polymorphic 'constants'.
00:39:43 * Heffalump agrees with Cale
00:40:43 <Cale> dolio: right
00:40:50 <jrx> @where Monomorphism Restriction
00:40:51 <lambdabot> I know nothing about monomorphism.
00:40:55 <Cale> dolio: You have to turn those into functions of ()
00:40:58 <Cale> (or something)
00:41:07 <dolio> Yeah. That's kind of a pain.
00:41:50 <Cale> Honestly, I think it should just be removed. Let programmers who care about the number of times such and such is getting evaluated add monomorphic type signatures.
00:42:00 <jrx> "The monomorphism restriction is probably the most annoying and controversial feature of Haskell's type system. All seem to agree that it is evil, but whether or not it is considered a necessary evil depends on who you ask." ;)
00:42:33 <Cale> It would make a *lot* more sense as the "monomorphism warning message"
00:43:27 <dolio> I can't say I've been bitten by it much lately, since top level signatures usually do the trick.
00:43:49 <Cale> yes, but forget one, and you can be bitten very hard :)
00:44:32 <Cale> Back before forM was in the libraries I spent half an hour trying to figure out why my program using the ST monad didn't work. I'd written  forM = flip mapM
00:44:41 <dolio> Although one could argue that explaining to newbies why their (rare case) code is running exponentially is easier than explaining why their (common case) code doesn't compile.
00:44:46 * Heffalump has started using NoMonomorphismRestriction whenever he remembers
00:44:52 <Cale> I only used forM in the ST monad, however, the 's' type variable gets set to ()
00:45:10 <Heffalump> or GHC could always specialise CAFs
00:45:10 <Syzygy-> :t forM
00:45:12 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
00:45:16 <Syzygy-> :t flip mapM
00:45:16 <Cale> Which is incredibly confusing until you work out what's going on.
00:45:17 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
00:45:32 <Heffalump> Cale: I didn't know () was an allowable default.
00:45:50 <Cale> Heffalump: Seems so in GHC.
00:46:20 <dolio> That is pretty obscure.
00:46:23 * desegnis supposes there should be a -Wmonomorphism warning flag, then
00:46:24 <Heffalump> without ExtendedDefaultRules?
00:46:36 <paolino> I think it's a good habit writing all signatures before one implementation then
00:47:02 <Cale> Heffalump: I might have been using -fglasgow-exts, I don't know whether it implies that. This is pre-LANGUAGE-pragmas.
00:47:03 <Heffalump> I write top-level type signatures, but I dislike them in some senses, it makes refactoring harder sometimes (and easier other times)
00:47:12 <Heffalump> Cale: ah, it may well do
00:48:56 <Heffalump> yeah, in H98 the default default is Integer, Double; and anything you put in a default declaration must be an instance of Num
00:50:22 <paolino> Heffalump: I'm using all those Flexible extension and have one generic constraint implying the real one , that helps me a lot in refactoring
00:50:57 <paolino> if the problem was with rewriting constraints on refactoring
00:51:23 <paolino> *real ones
00:52:10 <paolino> hoping that's not too much oop :P
00:54:53 <Heffalump> I usually find its the types I need to refactor, not the constraints, but I agree that can be a useful thing to do
00:55:16 <Heffalump> and sometimes having the type sigs helps me find the place to change when I refactor code quicker, so it's not all bad
01:00:09 <Heffalump> hi bringert
01:02:14 <paolino> I'm finding helpful the type renaming, I probably underrated it at the beginning, and overrate the hairy features
01:02:59 <paolino> of existentials
01:03:00 <bringert> hi Heffalump
01:03:30 <Heffalump> I noticed something in the haskelldb commit log about getting rid of the automatic DISTINCT
01:04:54 * Heffalump would be pleased to see it go, but thought it was an essential part of the design in some way
01:05:23 <paolino> if I will ever teach someone haskell, I start with write a lot of type renaming and a lot of signatures of functions playing with them
01:06:48 <paolino> is that what lambda calculus is about ?
01:07:18 <paolino> tuples and functions on them ?
01:09:33 <paolino> anyway, I stop spamming, what is the english for a group of straight lines described parametrically ?
01:09:50 <paolino> bunch, bundle ...
01:10:46 <Heffalump> I don't think it's well defined.
01:10:51 <paolino> beam ..
01:10:53 <paolino> ah
01:11:00 <Heffalump> group, bunch or bundle all sound fine to me depending on context
01:11:25 <paolino> we have a word for it
01:12:07 <Heffalump> In mathematical terms I have a vague feeling that "sheaf" might be used, but I'm not certain.
01:12:49 <paolino> like x + y + k*d for k in [1..10]
01:17:06 <yitz> bundle in alg. and diff. topology, sheaf in alg. geometry (back in my old days)
01:18:04 <yitz> sheaf was kind of a more algebraic thing. Don't remember the exact definitions anymore...
01:19:34 <bringert> Heffalump: it's theorectically important, but in practice I don't think it matters
01:22:00 <paolino> @hoogle range
01:22:00 <lambdabot> Data.Ix.range :: Ix a => (a, a) -> [a]
01:22:00 <lambdabot> Language.Haskell.TH.Range :: data Range
01:22:00 <lambdabot> Language.Haskell.TH.Syntax.Range :: data Range
01:38:50 <yitz> dcoutts ahoy.
03:16:53 <yitz> The #haskell social network graph is interesting. You know you're really geeks when one of the most popular personalities in your social network is lambdabot.
03:18:17 <Heffalump> there's a graph?
03:28:34 <byorgey> Heffalump: it's in the topic, http://tinyurl.com/ytzeab
03:29:03 <smg> yitz: :)
03:29:06 <smg> Heffalump: /topic
03:29:29 <Heffalump> ta
03:29:39 <smg> i can't find lambdabot on the graph *g*
03:29:55 <smg> is he excluded?
03:29:59 <dolio> It's pretty busy these days.
03:30:11 <Heffalump> how are the connections determined?
03:30:34 <byorgey> smg: near the bottom center, next to Heffalump, Cale, and roconnor
03:30:36 <TSC> smg: I think lambdabot is in the middle, under Heffalump
03:30:39 <smg> ah
03:31:00 <Heffalump> ah yes, under me and to the right and up a bit,
03:31:09 <smg> ah i see it, thank you! :)
03:31:28 <byorgey> Heffalump: it tries to deduce social connections, based on direct address (like this) but also temporal proximity
03:31:46 <Heffalump> right
03:31:53 <Heffalump> not exactly social, though; just conversational
03:32:00 <byorgey> well, right
03:32:23 <byorgey> Heffalump: there's a URL at the very bottom of the image
03:32:35 <Heffalump> it stopped loading 3/4 of the way down :-) I'll reload
03:32:59 <Heffalump> ah, right, I've seen PieSpy stuff before
03:33:48 <smg> java? :|
03:45:46 <augustss> I'm very peripheral...
03:52:15 <dolio> You're closer to the center when you don't have an underscore in your name.
03:53:07 <dolio> To the bottom-left of the cluster, between hpaste and gwern.
03:53:38 <Jomyoot> What's a good way to write a concurrent restful web app in haskell?
03:54:16 <augustss> dolio: it should ignore trailing underscores :)
03:56:51 <Jomyoot> How do I write A concurrent RESTful web application in Haskell?
03:57:50 <dolio> What's REST refer to?
03:57:54 * dolio isn't up on the web lingo.
03:59:14 <Jomyoot> RESTFUL
03:59:18 <Jomyoot> not sure either
03:59:29 <Jomyoot> but anyway is there a concurrent web server for haskell?
03:59:55 <dolio> Don't know. I'm also not up on the Haskell web technologies.
04:00:38 <desegnis> Jomyoot, Haskell land doesn't really excel at web server technology. The closest we have is happs
04:01:12 <Peaker> Hi, in http://www.haskell.org/tutorial/stdclasses.html  after "Using the lexical analyzer, our tree parser now looks like this: " -- what prevents it trying to parse each Branch as a leaf as well?
04:01:12 <lambdabot> Title: A Gentle Introduction to Haskell: Standard Classes
04:03:31 <Peaker> oh never mind, I understand now
04:03:34 <dolio> Peaker: Nothing. It tries both, and returns all the successes.
04:03:42 <Peaker> dolio, thanks
04:03:54 <Peaker> how does it know to use reads for the type a, though?
04:04:16 <augustss> the type checker knows :)
04:05:00 <Peaker> following the unpacking of each list element of the result of reads, and then the placement of that in a Leaf, which must fit a type of Tree a, it infers the type of reads?
04:05:03 <augustss> or if it doesn't, it'll complain
04:05:37 <augustss> Peaker: yes, it infers the type of reads
04:05:42 <Peaker> augustss, thanks
04:07:28 <desegnis> Peaker, note that the resulting tree will hold elements of some (readable) type a (to be determined by the caller), but every element of the tree is of the same type a.
04:09:07 <Peaker> desegnis, yep, I did.
04:09:22 <Peaker> I would like to try it all out, but frankly, Haskell's distribution/package system sucks :)
04:09:34 <Peaker> I feel back in the 90's with all the dependency hell
04:10:07 <augustss> Peaker: what platform are you using?
04:10:17 <Peaker> augustss, Ubuntu gutsy
04:10:40 <augustss> ok, I have no idea how that one works
04:10:57 <augustss> I've install on NetBSD, windows, and macos, and they are all easy
04:12:06 <Peaker> well, with Ubuntu I expect to be able to apt-get install my packages.. works for C, Python, and generally everything else. With Haskell, I have to manually install it, and then there are issues of multiple compiler versions, the Cabal package system which requires me to manually download and install dependencies. Some of which are already pre-installed (and I have no idea which), and so on
04:12:45 <paolino> there is cabal-install
04:12:57 <Peaker> paolino, which I cannot install without starting a Haskell install from scratch
04:13:01 <Peaker> paolino, in Gutsy
04:13:19 <desegnis> Peaker, there is the cabal-install package that will fetch and install packages from Hackage in a similar way to apt-get
04:13:24 <Peaker> so in order to use any Haskell stuff, I have to: A) Learn how to run distributed Haskell code  B) Learn how to use the Setup.hs system  C) Download and install tons of dependencies manually
04:13:29 <Peaker> This is a _huge_ barrier to entry for beginners
04:13:53 <Peaker> desegnis, I tried installing it in gutsy, its very very difficult, and basically requires that I ditch all the Ubuntu packages and install Haskell from scratch
04:13:57 <telexicon> Peaker, not all the python packages are available
04:14:02 <paolino> and you are supposed to keep a user copy of the Libraries, which exclude you have to be super user
04:14:09 <desegnis> Peaker, you may keep already installed packages
04:14:13 <pejo> Peaker, it's a matter of time before Ubunty has ghc 6.8, and then it's a simple apt-get for that part.
04:14:16 <telexicon> Peaker, to get most of them from the cheese shop you use easy-install
04:14:22 <desegnis> Peaker, or is it because of a bad ghc version?
04:14:29 <Peaker> telexicon, easy-install is easily installable
04:14:33 <dolio> gutsy is stuck on 6.6
04:14:36 <Peaker> desegnis, I don't know why its failing
04:14:58 <Peaker> desegnis, If I try to install cabal-install, its missing dependencies. If I try to install those dependencies, I get that .cabal file is unparsable
04:15:02 <paolino> you must install 6.8.2
04:15:15 <desegnis> ah ok. the ghc 6.6 bit is probably a problem. time for Herdy... however they'll call the next Ubuntu release
04:15:33 <moobax> does anyone know why my Ubuntu version of ghc can't find Control.Monad.Error? It works fine on windows...
04:15:51 <paolino> or hackagedb becomes a cul de sac
04:15:54 <Peaker> But why, in 2008, years after installation became easy, Haskell is still waiting on that?
04:16:13 <paolino> I told you one very good reason
04:16:28 <paolino> apt-get is for super user
04:16:30 <Peaker> paolino, will it break again when a new ghc is out, and nobody creates new Ubuntu packages for it?
04:16:30 <desegnis> moobax, they tend to split large programs up into smaller *.debs. Perhaps you are missing some ghc-something packages
04:16:47 <Peaker> paolino, I don't want to manually install things, I expect better from my package manager
04:16:51 <pejo> moobax, you're probably missing some package. They are named "libghc6-*" iirc.
04:16:56 <Baughn> desegnis: Hardy Heron
04:17:04 <desegnis> right
04:17:08 <moobax> ok, thanks, I'll try that
04:17:21 <Peaker> Maybe cabal-install ought to have a "statically linked" version
04:17:25 <Peaker> that _just works_
04:17:41 <paolino> Peaker: cabal is and will be for long time the way for haskell programs to be distributed
04:17:58 <paolino> ehm libraries
04:17:59 <dolio> Switch to debian unstable. They update ghc there in a timely manner. :)
04:18:14 <Peaker> paolino, when will cabal-install be ready? When will it be installable in a reasonable manner?
04:18:37 <desegnis> Peaker, it is ready, only Ubuntu Gutsy is not ;)
04:18:55 <Peaker> dolio, its not just the ghc - I find it disappointing that in this day and age, to use Haskell I have to manually run the equivalent of (configure;make) when every other piece of software has nice auto installers that work for me
04:19:06 <paolino> that 6.8.2 deb package goes on ubuntu here at least
04:19:06 <Peaker> desegnis, I thought it was pre-release
04:19:33 <Baughn> dolio: Yes, but I had unresolvable dependency issues with unstable. Maybe that's changed.. it was a curl thing, not a ghc thing, it's just that some haskell libraries depended on curl
04:19:37 <desegnis> Peaker, that's an Ubuntu problem, not a Haskell one, that you have to compile yourself
04:19:59 <desegnis> Peaker, ideally everything up-to-date would be on the Ubuntu servers
04:20:03 <dolio> Baughn: I don't actually use debian unstable. I just run ubuntu and install the latest Haskell stuff manually.
04:20:13 <Baughn> Peaker: Ubuntu doesn't have the strongest focus on development
04:20:15 <Peaker> desegnis, Ubuntu is said to be the most popular Linux system, i.e: the most popular free software systems.. that makes it also a Haskell problem....
04:20:23 <Baughn> dolio: That does seem to work best, yes
04:20:38 <paolino> ubuntu packagers are what they can be :), they can't package every will
04:20:50 <Peaker> Baughn, Does debian-stable/testing have it easier?
04:20:58 <Baughn> Peaker: Not in my experience
04:21:08 <Peaker> paolino, But Haskell developers can make a 3rd party apt repository like many other projects...
04:21:18 <Baughn> Peaker: Ubuntu releases every six months, though; 6.8.2 is considerably newer than that. There's nothing that /can/ be done
04:21:19 <dolio> testing is still on 6.6, according to their package search.
04:21:23 <Peaker> paolino, I want a newer "bzr" than the one in Ubuntu? No problem, I search google and find a .list file to use for apt
04:21:31 <Baughn> Peaker: If you want a distribution that always has the newest software, look at Gentoo
04:21:33 <Peaker> Baughn, 3rd party apt repo.
04:22:09 <moobax> groovy, I got it (not sure which libghc6 though, I just installed loads)
04:22:11 <Peaker> Baughn, I can use the newest released bzr on Ubuntu by creating a 2-line file in /etc/apt/source.list.d..  its _much_ harder to use the newest released ghc/cabal-packages
04:22:15 <moobax> thanks :)
04:22:26 <moobax> ls
04:22:37 <pejo> Peaker, we would love if you did such a thing. Make sure you get it listed on the ghc pages at haskell.org too!
04:22:38 <moobax> wrong windows ;)
04:23:18 <Peaker> pejo, I am no Ubuntu packaging guru
04:23:28 <Peaker> pejo, nor a ghc guru
04:23:54 <desegnis> Peaker, you don't have to be a ghc guru for that. (Ghc gurus are really smart people)
04:24:00 <pejo> Peaker, so what you're suggessting is to take a ghc guru and have them stop doing what they do, and instead package software?
04:24:01 <paolino> Peaker: I don't think the ideas behind cabal and darcs share something with ubuntu
04:24:25 <Baughn> Peaker: It wouldn't work as well as gentoo, probably. ;)
04:24:27 <Peaker> s/ghc guru/ghc-package guru/
04:24:48 <Baughn> Peaker: Modern multicore computers really fly through the compilation, so that isn't really an issue these days
04:24:49 <Peaker> Baughn, gentoo forces me to compile stuff that were compiled millions of times around the world already
04:25:01 <Peaker> Baughn, My computer isn't multicore, multicore is more expensive
04:25:02 <dolio> Can't you get the latest ghc by downloading a tarball and unzipping to /usr/local?
04:25:08 <Baughn> Peaker: That's the price you have to pay for being able to use /any/ combination of software
04:25:16 <Peaker> dolio, I could, but I'd have to do this for tons of cabal packages too
04:25:31 <Baughn> Peaker: These days, you can't /get/ a single-core system, but point taken. My server isn't multicore either.
04:25:35 <Peaker> Baughn, what do you mean? apt lets me use combinations of software without doing that
04:25:36 <dolio> You have to do it for like 3 cabal packages to get cabal-install working.
04:25:37 <Baughn> Peaker: Still, after your next upgrade..
04:25:43 <desegnis> Peaker, once you have ghc 6.8.2, you may install cabal-install and use that
04:25:43 <paolino> cabal-install automates it
04:25:51 <Baughn> Peaker: Well, not quite
04:25:55 <Peaker> cabal-install itself requires tedious manual installation
04:26:18 <Baughn> cabal-install doesn't need the libraries at /runtime/. YOu'd think they'd provide binaries.
04:26:19 <paolino> well we don't sell ghc
04:26:44 <paolino> (resell)
04:26:59 <Peaker> paolino, Python people don't sell Python but they make sure the barrier of entry to using Python and distributing Python code is very low - which makes it very popular.  I suspect Haskellers want Haskell to be popular too?
04:27:01 <Baughn> Peaker: You can choose which packages to install, but ghc-6.8.2 will still be dependent on the exact version of curl (or whatever; I think that was another haskell library) it was compiled against. You can often get away with slight library changes, but nothing large.
04:27:14 <paolino> they are a lot of people
04:27:34 <Baughn> Peaker: Whereas with gentoo, it'll be compiled against the exact version of curl you /have/, whatever that is; you get a lot more freedom
04:27:58 <Peaker> Baughn, assuming source-level compatibility exists and binary-level does not
04:28:15 <Baughn> Peaker: Thus gentoo has dependencies as well, but yes. And it usually does.
04:28:36 <pejo> Peaker, each person in the Haskell community work on what they find important. I think you have a great idea, but someone needs to do it.
04:29:07 <Baughn> Peaker: The main result is that gentoo gets packages out /much faster/ than the other distributions, while still maintaining reasonable stability
04:29:22 <Baughn> Of course, then you have to wait four hours while it compiles
04:29:26 <Peaker> pejo, well, I am still at the stage of wanting to try Haskell out, before I can become part of the Haskell community...
04:29:31 <mattam> swiert: ping
04:29:31 <paolino> like freebsd
04:29:50 <Peaker> Baughn, well, I don't mind being a few months behind the times
04:29:53 <Peaker> Baughn, for extra stability
04:29:58 <Peaker> Baughn, and saving my time
04:29:59 <Baughn> pejo: Someone is /already/ packaging haskell for debian, though. Wouldn't they already have such a repo?
04:30:16 <augustss> wow, they weren't kidding about darcs.haskell.org being slow!
04:30:33 <Peaker> Baughn, does being a few months behind the times in this case mean being able to use Haskell reasonably? Is that such a new feature? :)
04:30:46 <Baughn> Peaker: Well, yes. ^^;
04:31:06 <Baughn> Peaker: Your woes sound /tame/ in comparison to what I went through, one year ago
04:31:12 <Peaker> Is there any bug tracker where people can vote on this?
04:31:40 <Baughn> Peaker: There are bug trackers, but not votes. If you want to fix something, either do it yourself or hope someone else does.
04:31:44 <yitz> augustss: just did darcs get on cabal and cabal-install. 800 patches in about 15 min.
04:32:03 <Baughn> Peaker: Oh, I suppose there's also the "pay someone else" option. Microsoft seems to be very interested in Haskell; they might be of help.
04:32:30 <augustss> yitz: I did a darcs pull on ghc 5 minutes ago and it hasn't started pulling the patches yet
04:32:46 <Peaker> Baughn, they are? How come? Microsoft is incompetent :)
04:32:49 <Baughn> Peaker: Anyway, in this case the price of using ubuntu is that you're stuck on 6.6 until april or so
04:32:50 <yitz> augustss: oh, ghc. different league.
04:33:09 <Peaker> Baughn, well, I'll see if I can toy with Haskell with what I've got
04:33:16 <Baughn> Peaker: Microsoft research. Microsoft as a whole might be somewhat.. well, incompetent describes it well, but their research department is anything but
04:33:52 <pejo> Baughn, I suspect that the someone (Igloo?) uses the official debian repos. I have to run though, sorry.
04:33:54 <Baughn> Peaker: Oh, but you /could/ install your own ghc. Remove ubuntu's, unpack the binary version of 6.8.2, install.. things will pretty much work
04:34:07 <Peaker> Baughn, I am toying with the idea of creating a non-textual programming editor, btw, and I think Haskell is an awsome model to edit non-textually
04:34:31 <Baughn> Peaker: As for cabal-install, this conversation has inspired me to provide precompiled versions of it
04:34:38 <Peaker> Baughn, that'd be great!
04:34:40 <yitz> Baughn: Eric Meijer is not incompetent. He likes Haksell - but he won't fix anything for you, he'll tell you to use F#.
04:34:58 <Baughn> yitz: ..when did I claim he was?
04:35:03 <augustss> yitz: he'll tell you to use VB
04:35:41 <yitz> augustss: did you see his recent video? he was pretty honest, I think,
04:35:45 <Baughn> Peaker: Hm. Are you on x86 or amd64?
04:35:50 <Peaker> Baughn, amd64
04:36:24 <Peaker> would the parser from the Haskell tutorial (using reads, not read) be of the correct time complexity O(N) N=input string length,  or would it do "backtracking" and be of exponential complexity?
04:36:25 <Baughn> Peaker: Right. Just give me a moment..
04:36:33 <augustss> yitz: I've not seen any recent video, but I know him very well personally. :)  But I've not seen him in person for a while either.
04:37:09 <Baughn> Peaker: The use of reads in itself doesn't cause backtracking. The rest of the code does that. Link?
04:37:16 <augustss> I can very well imagine him pushing F# at the moment
04:37:28 <Peaker> Baughn, http://www.haskell.org/tutorial/stdclasses.html
04:37:28 <lambdabot> Title: A Gentle Introduction to Haskell: Standard Classes
04:37:59 <Peaker> Baughn, so Haskell compilers wouldn't be smart enough to convert the back-tracking pattern matcher to an optimized FSM?
04:38:05 <augustss> Peaker: the kind of parser shown in the tutorial can easily go exponential
04:38:18 <Baughn> Peaker: I seriously doubt it
04:38:18 <Peaker> augustss, how do you make an optimized FSM elegantly?
04:38:23 <yitz> augustss: http://channel9.msdn.com/ShowPost.aspx?PostID=374141
04:38:25 <lambdabot> Title: Erik Meijer: Functional Programming
04:38:36 <Baughn> Peaker: There is a great parser library bundled with ghc, though. Try Parsec
04:38:50 <augustss> Peaker: use happy
04:39:09 <yitz> The moderator's post says: "(there are very good reasons why people don't program Windows applications in, say, Haskell...)" but Eric doesn't say that in the video.
04:39:13 <Peaker> Baughn, augustss : Isn't it possible in theory, to use LL(k) for pattern matching, instead of back-tracking?
04:39:18 <augustss> Peaker: but you don't want a FSM, they are too limited
04:39:51 <Peaker> augustss, but they have great time complexity - it could be nice to optimize anything you can into an FSM, wouldn't it?
04:39:52 <Adamant> does Haskell have Win32 bindings?
04:40:04 <Baughn> Peaker: Sometimes. Depends on the language you're trying to parse.
04:40:27 <augustss> Peaker: yeah, but I want to parse other things than regular languages
04:40:37 <Baughn> Peaker: Where it /is/ possible, note that parsec does LL(n) parsing
04:40:50 <augustss> Peaker: you can implement Earley's algorithm and get O(n^3)
04:41:01 <augustss> And parse any context-free language
04:41:12 <Baughn> Peaker: The problem is that pattern-matching in itself is an expensive operation
04:41:22 <Peaker> augustss, FSM's with some extensions (stack FSM's?) can remain in same time complexity but parse context-free, not just regular
04:41:32 <oerjan> Adamant: Graphics.Win32.*  and System.Win32.*  are listed at http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
04:41:40 <augustss> Peaker: sure
04:41:58 <oerjan> Adamant: there may be more on hackage, and you can use the ffi
04:42:07 <augustss> Peaker: there is no need for parsing to be exponential
04:42:12 <yitz> Baughn: sorry, I didn't mean to accuse you of saying anything about Eric. You contrasted MSR with regular MS - I was just pointing out that Eric is part of latter, so they're not _all_ incompetent.
04:42:23 <augustss> Peaker: I'd never use the way of parsing shown in the tutorial
04:42:24 <Peaker> Baughn, augustss : Wouldn't it be elegant if parsing could be done as its done in the tutorial, and automatically be optimized into an LL(n) -> FSM, rather than requiring a parse library?
04:42:32 <Heffalump> regular MS has a lot of very good programmers
04:42:43 <Peaker> Heffalump, they sure hide them well! :-)
04:42:46 <Baughn> yitz: Nothing that large could be entirely incompetent. No, I was thinking more of the overall impression, not single developers.
04:42:47 <Heffalump> organisationally one might argue that they are incompetent, but I don't think I'd agree with that either
04:43:20 <augustss> Peaker: maybe, I'm not worried about parsing
04:43:20 <paolino> Heffalump: how could it be different ?
04:43:20 <yitz> Heffalump: right, they are very intentional about what they do, and they do it well.
04:43:21 <Peaker> Heffalump, There's not a single MS product I would have been proud with if I released it. There's a nice feature here and there.. But not a single product is done well
04:43:43 <Heffalump> win2k and winxp are pretty solid operating systems
04:44:00 <Peaker> Heffalump, Win2K and WinXP are only good, when you compare them with the previous joke OS's from MS
04:44:00 <Baughn> By what standard?
04:44:22 <paolino> they bought areas of the planet to hire the programmers there
04:44:24 * Twey used WinME for three years.
04:44:27 <Heffalump> by the standard of hardly ever crashing if you don't use bad drivers
04:44:31 <yitz> Peaker: it depends what you mean by a good product. If you think about the economic theory of monopolistic behavior, they've done extremely well.
04:44:34 * Twey still has the scars.
04:44:37 <Baughn> Heffalump: That is not sufficient
04:44:42 <Peaker> yitz, I'm referring to the programmers/technical side
04:44:48 <augustss> urk!  darcs leaks file handles
04:44:57 <Heffalump> augustss: oops...
04:44:57 <yitz> Peaker: of course, that's part of it, too.
04:45:11 <Baughn> Heffalump: After years of using linux, my standard is "Never crashing, with very high performance, and posix semantics"
04:45:11 <augustss> darcs: getCurrentDirectory: resource exhausted (Too many open files)
04:45:18 <Baughn> augustss: OS X?
04:45:21 <Peaker> Heffalump, not crashing is the first requirement of not totally sucking.  It may still totally suck though if it doesn't crash, but it may not suck less than totally if it does crash
04:45:26 <augustss> Baughn: yes
04:45:37 <Baughn> augustss: It's not a /leak/, it's just that it likes to open every file in the repo simultaneously
04:45:46 <Heffalump> well, it works ok too
04:45:50 <Twey> Hahahahaha
04:45:54 <augustss> Baughn: ok, a misfeature then
04:46:12 <paolino> OS X is bsd based ?
04:46:17 <Baughn> augustss: Not really
04:46:25 <augustss> paolino: yes, kinda
04:46:41 <Baughn> augustss: Stick "ulimit -n 8192" or something in ~/.bash_profile
04:46:43 <paolino> you have man sysctl to solve that
04:47:00 <augustss> Baughn: i've already increased the number of FDs and I'm pulling again
04:47:03 <augustss> Baughn: it
04:47:04 <yitz> paolino: yes. Darwin is based on bsd (FreeBSD I think)
04:47:15 <augustss> Baughn: it's still a misfeature
04:47:18 <Baughn> augustss: You have to admit that 256 is a tad low
04:47:36 <Baughn> augustss: And no, it isn't. Why /shouldn't/ it open every file?
04:47:37 <augustss> Baughn: no, 256 open files should be enough for anyone
04:47:46 <Baughn> augustss: A file descriptor is just a few bytes of memory
04:47:54 <Baughn> augustss: ..okay, now I know you're kidding
04:48:02 <augustss> Baughn: it used to be 10 open files max
04:48:38 <Twey> What's the conventional meaning of a function that starts with a lower-case letter but is otherwise all capital?
04:49:00 <Baughn> Twey: "The programmer wanted it to be all-capital but ran into haskell limitations"
04:49:10 <Twey> I'm looking  System.Win32.DLL.lOAD_LIBRARY_AS_DATAFILE
04:49:10 <Baughn> Twey: Probably an FFI function.
04:49:13 <Twey> Oh :-D
04:49:14 <augustss> seriously, I don't think it matters much what darcs does in this case.  but for a serious program to be gobbling up what is known to be a scarce resource is not friendly
04:49:15 <yitz> Twey: usually a former C programmer wanted to define some kind of constant.
04:49:26 <Twey> Mmkay.  Heh.  Thanks
04:49:48 <swiert> mattam: hiya.
04:49:51 <Twey> Why doesn't Haskell allow a capital letter at the start of a function name?
04:50:25 <Baughn> Twey: Bad design?
04:50:34 <yitz> Twey: real Haskell programmer use names like: it'sMyConstantAndI'veTheRightToNameItWhateverIWant
04:50:48 <Baughn> Twey: Yes, it's reserved for constructors (that can be pattern-matched against), but those should just be normal functions..
04:50:48 <desegnis> Twey, data constructors are distinguished from ordinary functions by the case of the first letter
04:50:48 <paolino> it has stylish choices
04:50:49 <augustss> Twey: because capital letters are for constructors.  it makes pattern matching easier to parse
04:51:08 <oerjan> Twey: in pattern matches, variables are bound but you don't want that to happen to constructors.
04:51:21 <oerjan> so capitalization is used to distinguish them
04:51:37 <Twey> Aha.  Thanks.
04:51:40 <augustss> there are other ways of solving that problem, but Haskell picked this one (copying Miranda)
04:51:45 <Baughn> augustss: Yes, I do get the impression that they cut a few corners in the syntax
04:51:53 <Twey> yitz: Hehe
04:51:54 * Baughn pokes -
04:52:21 <Twey> Well, it seems fair enough really.
04:52:32 <augustss> it can be annoying
04:52:47 <augustss> it's also the reverse of the convention used in logic
04:52:49 <yitz> The same distinction is used for types vs. type variables.
04:52:52 <augustss> (and Prolog)
04:53:53 <paolino> Capital letters hides operators in expressions ?
04:54:02 <yitz> For infix operator names, the corresponding distinction is whether or not it begins with ':'.
04:54:41 <augustss> yitz: which is really yucky
04:54:43 <mattam> swiert: I'm looking at your file, and it triggered at least two big bugs in the code for coercion of products. The inference problem comes from the fact that get and put have "reduced" types instead of the one you gave (this is also corrected now). Also, bindST is maybe not dependent enough, you may want to have Q2 of type A -> Post B and c2 of type forall x : A, HState P2 B (Q2 x).
04:54:48 <paolino> is Miranda readable as haskell ?
04:55:01 <Heffalump> it's bad OS design that it is a scarce resource, but unfortunately we're stuck with that
04:55:09 <augustss> paolino: similar
04:55:22 * Heffalump adds some unsafeCoerces to his code and feels dirty
04:55:25 <yitz> augustss: it's yucky, but I don't really like abolishing it either. Can you think of an alternative?
04:55:42 <Baughn> Heffalump: Yikes. What is it good for?
04:56:05 <swiert> mattam: yes. I know bindST can be made a bit more general. The simply typed version was enough for this problem though.
04:56:06 <augustss> yitz: sure.  Cayenne had no such restrictions
04:56:19 <dolio> Agda does without it.
04:56:19 <paolino> prolog is not as readable
04:56:27 <Heffalump> working round flaws that exist either in the current GHC HEAD typechecker of associated types, or my understanding of said typechecker
04:56:43 <mattam> swiert: not sure, it seemed like the post has to talk about the return value of the first computation.
04:56:46 <swiert> mattam: Thanks for looking into the file though.
04:57:21 <yitz> dolio: just without it entirely? I don't like that. I meant some other syntactic distinction that is neater.
04:57:44 <augustss> yitz: but the alternatives have some other cost, of course.  there's no free lunch
04:57:47 <dolio> Yeah. Any character can appear in any type of identifier.
04:58:04 <swiert> mattam: You could be right. Let me have a look.
04:58:29 * Heffalump had free lunch a week and a bit ago. "free" as in paid for by augustss :-)
04:58:30 <yitz> dolio: no capitalization distinction in regular identifiers?
04:58:50 <augustss> yitz: that's right
04:58:59 <dolio> Oh, except _. _ is used to define operators.
04:59:05 <mattam> swiert: I still have to correct one de Bruijn bug before accepting the definition :)
04:59:20 <dolio> _identifier_ is a binary operator, for instance.
04:59:27 <augustss> dolio: Agda forces you to use spaces in some places where I normally wouldn't
04:59:33 <yitz> Heffalump: yes, that was my plan. augustss will find a solution for all of Haskell's syntax problems, and we won't have to do any work.
04:59:35 <dolio> With the arguments going where the _s are.
04:59:36 <swiert> mattam: Glad I could help by finding your bugs :)
04:59:41 <dolio> augustss: Yeah, I know. That is kind of a pain.
05:00:40 <augustss> yitz: as far as constructors go, I likes my solution in Cayenne.  All constructor patterns had to have parenthesis around them, and that was it
05:01:11 <Heffalump> I quite like the small initial letter = variable, big initial letter = constant distinction
05:01:19 <augustss> -p0000000[[p]=========
05:01:27 <augustss> oops, cat on keyboard
05:02:02 <yitz> augustss: hmm, yes, that could work. Kind of like layout - you do it anyway, so might as well use it for real syntax. It's efficient.
05:02:28 <swiert> mattam: how's your proof-irrelevant version of Coq coming?
05:02:44 <augustss> It's only a little odd for 'f Foo = ...' which has to be written 'f (Foo) = ...'
05:03:47 <mattam> swiert: it's next on my TODO list.
05:03:57 <yitz> augustss: not so odd actually. There's something intuitive about it, in my opinion.
05:04:14 <augustss> I often do it anyway
05:04:19 <swiert> mattam: cool. Is that before or after you fix the de Bruijn bugs?
05:04:41 <yitz> augustss: the only problem I can see is with the cat.
05:06:00 <desegnis> I kind of like the 'a notation for type variables in ML. You can easily typeset those as greek letters
05:08:47 <Heffalump> :r
05:08:50 <Heffalump> sorry
05:16:23 <shag> @pl (\a -> (fst a) == k)
05:16:23 <lambdabot> (k ==) . fst
05:21:00 <augustss> that's wrong
05:21:27 <augustss> (== k) . fst
05:22:08 <mattam> swiert: after :) Bugs bug me.
05:22:38 <mattam> I got it already BTW
05:23:08 <swiert> mattam: great. when's the next Coq release scheduled? (i.e. when will I get the fix)
05:23:30 <mattam> Now it should be by the end of march
05:23:57 <mattam> It was already reported twice so I guess it's a better estimate than before
05:28:55 <dolio> @pl \n -> n * m
05:28:55 <lambdabot> (m *)
05:29:13 <Botje> heh
05:29:25 <dolio> @pl (*m)
05:29:25 <lambdabot> (m *)
05:29:50 <Botje> pl does commutativity?
05:30:00 <augustss> when it shouldn't
05:30:22 <dolio> Yeah, there's no guarantee that n * m is the same as m * n.
05:30:29 <dolio> Same with (==), for that matter.
05:30:34 <augustss> indeed
05:30:54 <oerjan> with (==) at least it's a class law
05:34:01 <dolio> I suppose with (==) the main difference you'd expect to see is with strictness.
05:35:50 <dolio> > (0/0) == undefined
05:35:51 <lambdabot>  Undefined
05:36:11 <paolino> (mmhh  constructors should start low letter)
05:36:16 <Baughn> > 0/0
05:36:17 <lambdabot>  NaN
05:37:36 <paolino> it's strange to write (r,l) = (Right,Left)
05:38:53 <paolino> but then they are nice on pattern matching, can't say
05:40:17 <paolino> I suppose there should be a Const keyword for renaming constructors
05:41:21 <paolino> I suppose I shouldn't suppose on the channel :)
05:44:24 <paolino> is it possible to do data XorY = X Double | Y Double and make it be Either Double Double ?
05:44:54 <paolino> so that X map to Left =
05:45:13 <Baughn> paolino: No. If you want either, use either.
05:46:32 <paolino> that's a limitation
05:46:53 <dolio> That'd require some sort of structural typing.
05:48:40 <paolino> type XorY = Either Double Double
05:48:48 <paolino> const X = Left
05:49:38 <paolino> nm
05:51:49 <paolino> as it's so nice to use type for making signature meaningful then const could make pattern matching better ?
05:53:43 <paolino> no, knowing an ADT means knowing the semantic of its constructors, I wouldn't want to change their names
06:23:49 <olsner> hmm, ghci 6.8.2 has memory management trouble... ran a test program that diverged and allocated about 700 megs of memory, so I aborted and run :q (since ghci doesn't seem to ever garbage-collect, which is another thing) ... and ghci goes and allocates 400 megs more, just to execute my quit command!
06:25:48 <Saizan> and that doesn't happen with other versions?
06:25:51 <Lemmih> Can you reproduce it?
06:27:05 <olsner> Saizan: hmm, I don't really have other versions to compare with, so I don't know
06:28:23 <paolino> @pl \x -> a x. b x
06:28:23 <lambdabot> liftM2 (.) a b
06:36:05 * olsner is swapping...
06:38:52 <Jomyoot> When is Real World Haskell going to finish?
07:12:09 <asmanian> Jomyoot: what do you mean with "real world". Ah, wait. Thats the stuff thats hidden in these monads, isnt it? ;)
07:38:05 <idnar> @oeis 12 18 20 24
07:38:05 <lambdabot> Abundant numbers (sum of divisors of n exceeds 2n).
07:38:05 <lambdabot> [12,18,20,24,30,36,40,42,48,54,56,60,66,70,72,78,80,84,88,90,96,100,102,104,1...
07:48:47 <opqdonut> @oeis 1 1 3 5
07:48:48 <lambdabot> Jacobsthal sequence: a(n) = a(n-1) + 2a(n-2), with a(0) = 0, a(1) = 1.
07:48:48 <lambdabot> [0,1,1,3,5,11,21,43,85,171,341,683,1365,2731,5461,10923,21845,43691,87381,174...
07:50:36 <idnar> hmm, is there a function to test whether a value is in a sorted list or not?
07:50:53 <idnar> (like notElem, but taking advantage of the sorted nature of the list)
07:52:05 <desegnis> @hoogle Ord a => a -> [a] -> Bool
07:52:05 <lambdabot> Prelude.elem :: Eq a => a -> [a] -> Bool
07:52:05 <lambdabot> Prelude.notElem :: Eq a => a -> [a] -> Bool
07:52:05 <lambdabot> Data.List.elem :: Eq a => a -> [a] -> Bool
07:52:13 <desegnis> @hoogle+
07:52:13 <lambdabot> Data.List.notElem :: Eq a => a -> [a] -> Bool
07:52:23 <desegnis> looks bad
07:52:49 <Twey> idnar: How about: myValue `notElem' (takeUntil someCondition mySortedList)
07:53:11 <idnar> I guess that should work
07:53:19 <idnar> with someCondition = (>= myValue)
07:53:44 <ZimaN> i guess you could make an Array out of the list and then binary search the array; this might be logarithmic if Haskell is lazy enough :)
07:53:47 <Twey> Something like that, yes.
07:53:54 <idnar> or, perhaps just
07:55:25 <idnar> (head $ dropWhile (< n) sortedList) == n
07:57:01 <desegnis> null . takeWhile (==x) . dropWhile (<x)
07:57:29 <desegnis> idnar: yours fails if head encounters the empty list
07:57:36 <idnar> the list is infinite in my case
07:58:19 <desegnis> ok
08:00:59 <idnar> ergh, except it's not sorted properly
08:01:05 <idnar> my diagonalization must be wrong
08:05:43 <idnar> hrm, I'm not sure how to write this
08:12:26 <hpaste>  idnar pasted "Diagonalisation" at http://hpaste.org/6233
08:12:36 <idnar> anyone have any suggestions?
08:14:39 <Botje> hpaste: pick b first, take a from takeWhile (<b) xs, construct tuples
08:14:40 <Deewiant> > let diag xs = filter (uncurry (<=)) [(a,b) | a <- xs, b <- xs] in take 10 $ diag [1..]
08:14:40 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10)]
08:15:11 <Botje> ehm.
08:15:11 <Saizan> nah, filter is a waste
08:15:14 <Botje> that should be idnar :)
08:15:18 <idnar> heh
08:15:28 <idnar> hmm, actually, I'm not sure that gets me what I want, anyway
08:15:44 <Botje> > [(a,b) | b <- [1..], a <- takeWhile (<=b) [1..]]
08:15:44 <Deewiant> Saizan: hmm, list comprehensions have predicates built-in, good point.
08:15:44 <lambdabot>  [(1,1),(1,2),(2,2),(1,3),(2,3),(3,3),(1,4),(2,4),(3,4),(4,4),(1,5),(2,5),(3,...
08:16:20 <idnar> I want to take a + b for every a and b from aSortedList, in increasing order
08:16:27 <Saizan> > let diag xs = [ (a,b) | (a,bs) <-zip xs (tails xs) , b <- bs ] in diag [1..]
08:16:28 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(1,11),(1,12),...
08:16:55 <idnar> my diagonalisation there is going to have local "unsortedness" even after avoiding swapped pairs
08:28:36 <pkazmier> question: what does this mean?  "The one-line summary for folds: if the binary operation is strict use foldl' otherwise use foldr."  How do I know if the binary operation is strict?
08:29:00 <Botje> if it inspects both arguments before returning, it's strict
08:29:39 <pkazmier> I don't understand.
08:29:42 <Botje> (well, it only needs to be strict in the first argument)
08:29:57 <pkazmier> So is '1 + 5' strict?
08:30:00 <Botje> no
08:30:08 <Botje> because it just creates a thunk
08:30:20 <Botje> > foldl1 (+) [1..1000]
08:30:21 <lambdabot>  500500
08:30:24 <Botje> > foldl1 (+) [1..100000]
08:30:25 <lambdabot>  5000050000
08:30:30 <Botje> okay, that's funky
08:30:35 <Botje> why is foldl1 strict all of a sudden?
08:30:40 <desegnis> eh, addition is certainly strict
08:31:13 <Botje> > foldl (+) [1..1000000000]
08:31:13 <lambdabot>   add an instance declaration for (Num [t])
08:31:18 <Botje> > foldl (+) 0 [1..1000000000]
08:31:23 <lambdabot>  Terminated
08:31:25 <Botje> which should stack overflow
08:31:41 <desegnis> you missed the 1 in foldl1 this time
08:31:44 <Botje> :)
08:31:52 <Botje> > foldl1 (+)  [1..1000000000]
08:31:54 <desegnis> too late :)
08:31:57 <lambdabot> Terminated
08:32:21 <Botje> haskell just accumulates a huge three of thunks which, when evaluated, add those numbers
08:33:02 <idnar> that's because foldl isn't strict, not because (+) isn't strict
08:33:17 <desegnis> pkazmier: Basically, a function f is strict in its argument x if it's necessary to evaluate x in order to evaluate f x. More formally, f is strict if f _|_ = _|_
08:33:26 <Botje> blah
08:33:30 * Botje reads some more, then
08:33:44 <kpreid> desegnis: const undefined is strict?
08:34:26 <idnar> haha
08:34:42 <desegnis> kpreid: By that definition, yes. I call that "uselessly strict" :)
08:35:27 <kpreid> desegnis: well, it is by your 'formal' definition but not by your 'basic' one
08:35:41 <desegnis> kpreid: I agree that it's strange to say that a function is strict even though it doesn't inspect its argument
08:36:23 <desegnis> kpreid, iirc, the "formal" one is right
08:37:04 <pkazmier> so back to the one line summary rule, "The one-line summary for folds: if the binary operation is strict use foldl' otherwise use foldr", it seems that foldl' is the correct fold for (+), does that mean (+) is strict?  I thought you guys indicated it was not.
08:37:28 <desegnis> pkazmier: yes, (+) is strict
08:37:59 <pkazmier> so how do I know that?
08:38:24 <pkazmier> the writer of that page assumes the reader understands the difference.
08:38:31 <desegnis> pkazmier: e. g. 3 + _|_ = _|_
08:38:49 <pkazmier> can I type that in ghci?
08:38:59 <idnar> > 3 + undefined
08:39:00 <lambdabot>  Undefined
08:39:05 <desegnis> That's because adding 3 to an undefined number doesn't yield a number, but only an undefined value
08:39:10 <idnar> > const 5 undefined
08:39:10 <lambdabot>  5
08:39:27 <pkazmier> but if I don't use the result, then that thunk is not evaluated?
08:40:39 <pkazmier> > let x = 4 + undefined
08:40:40 <lambdabot>  Parse error at end of input
08:40:50 <Deewiant> > let x = 4 + undefined in x
08:40:51 <lambdabot>  Undefined
08:41:01 <Deewiant> > let x = 4 + undefined in 1
08:41:01 <desegnis> pkazmier, you can of course write a non-strict function that, given (3 + _|_) as input, will discard its input and do give a result. (just as idnar did above)
08:41:02 <lambdabot>  1
08:41:09 <pkazmier> yeah, but that's because you are evaluatieng it right?
08:41:16 <MyCatVerbs> > length (replicate 3 undefined ++ replicate 5 undefined)
08:41:16 <lambdabot>  8
08:41:22 <MyCatVerbs> > length (replicate 3 undefined ++ undefined)
08:41:22 <lambdabot>  Undefined
08:41:29 <MyCatVerbs> Wheeeee~~~
08:41:50 <smg> hehe
08:43:46 <pkazmier> I believe I understand now.  Thankns.
08:54:25 <smg> is there the haskell syntax in EBNF or something?
08:54:29 <smg> i don't find it
08:54:56 <Deewiant> @where report
08:54:56 <lambdabot> http://www.haskell.org/onlinereport/
08:55:11 <Deewiant> smg: should be there.
08:55:52 <niihl> http://www.hck.sk/users/peter/HaskellEx.htm
08:55:52 <smg> ok
08:56:34 <smg> nice thank you Deewiant and niihl
08:56:47 <Myriad__> hello everyone
09:00:11 <Myriad__> hopefully a simple question... how can I tell ghci where to look for dynamic lbraries (equiv to ghc -L/opt/local/lib)
09:01:20 <Slarba> umm... ghci is ghc running in interactive mode, right? just ghci -L/opt/local/lib
09:01:28 <Slarba> (wild guess)
09:01:38 <Deewiant> according to http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-invocation.html -L should work
09:01:41 <lambdabot> Title: 3.6. Invoking GHCi, http://tinyurl.com/3bunos
09:01:41 <Myriad__> unfortunatly not... it was my wild guess too :)
09:01:53 <Myriad__> I'll check again
09:02:20 <Slarba> Myriad__: LD_LIBRARY_PATH then
09:03:10 <Myriad__> Slarba: DYLIB_LIBRARY_PAH in my case (OS X) but that too isn't doing it
09:04:39 <Myriad__> the good thing is, that I can compile the program just fine with ghc _L... -l... (libodbc is the library I'm trying to use btw)
09:06:33 <Myriad__> oh... LD_LIBRARY_PATH does it
09:07:01 <Myriad__> now that is strange... it obviously doesn't use the system dlopen, because that would look into DYLIB_LIBRARY_PATH
09:08:10 <Myriad__> thanks for the pointers
09:17:42 <smg> @src (++)
09:17:42 <lambdabot> (++) []     ys = ys
09:17:42 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
09:19:44 <Jaak> > (foldr (\x f -> (x:) . f) id [1,2,3]) [4,5]
09:19:45 <lambdabot>  [1,2,3,4,5]
09:20:25 <smg> Jaak: hehe
09:21:42 <Jaak> @type foldr ((.).(:)) id
09:21:42 <lambdabot> forall a. [a] -> [a] -> [a]
09:22:08 <Jaak> aaah, daily haskell fix
09:22:27 <conal> @type foldr ((fmap.fmap)(:)) id
09:22:28 <lambdabot> forall a. [(([a] -> [a]) -> [a] -> [a]) -> ([a] -> [a]) -> a] -> ([a] -> [a]) -> [a] -> [a]
09:22:37 <conal> yow!
09:24:51 <Jaak> @type \f -> foldr (fmap `fmap` f) id
09:24:52 <lambdabot> forall a a1. (a -> a1 -> a1) -> [a] -> a1 -> a1
09:34:20 <dolio> @type foldr ((.)(.)(.)(:)) id
09:34:21 <lambdabot> forall a. [(([a] -> [a]) -> [a] -> [a]) -> ([a] -> [a]) -> a] -> ([a] -> [a]) -> [a] -> [a]
09:43:55 <roconnor> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Control-Exception.html#ioErrors
09:43:57 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/3al3yh
09:44:11 <roconnor> how come most of these predicates are const Nothing?
09:45:33 <roconnor> oh I see, it is in a ifdef block
09:46:53 <desegnis> funny to see what the preprocessor condition for ghc is called
09:50:38 <smg> pattern matching++
09:50:49 <smg> desegnis: how it'S called? :]
09:51:29 <desegnis> __GLASGOW_HASKELL__
09:51:37 <desegnis> I guess __GHC__ would have been too easy
09:51:56 <smg> hehe
09:54:20 <roconnor> oh wow, catch is in the Prelude.  That sucks.
09:54:53 <smg> roconnor: why would this suck?
09:54:57 <roconnor> I figured it would be in IO
09:55:12 <smg> hehe
09:55:15 <roconnor> smg: it sucks because you have to do import Prelude hiding (catch) all the time
09:55:19 <Deewiant> smg: conflicts with Control.Exception.catch
09:55:19 <smg> roconnor: bracket is in IO
09:55:25 <roconnor> if you want to import Control.Exception.catch.
09:55:27 <smg> hehe okay
09:55:32 <smg> yeah hehe
09:56:00 <roconnor> okay, that definitely ought to be fixed in Haskell prime.
09:56:03 <roconnor> is there a trac?
09:56:24 <Deewiant> @where haskell-prime
09:56:24 <lambdabot> http://hackage.haskell.org/trac/haskell-prime
09:58:09 <roconnor> it's listed as an example in http://hackage.haskell.org/trac/haskell-prime/wiki/Prelude
09:58:13 <lambdabot> Title: Prelude - Haskell Prime - Trac
09:58:41 <SamB> another thing that sucks is that the MonadError instance for IO uses IOError, not Exception
09:59:13 <roconnor> SamB: the MTL is soooo last year.
09:59:27 <SamB> roconnor: oh. what are we using this year?
09:59:40 <roconnor> monadlib I believe
09:59:51 <SamB> I didn't get the memo. Why?
10:00:12 <roconnor> because the mtl has several issues
10:00:17 <roconnor> I guess
10:00:28 <SamB> ... why didn't I get the memo?
10:00:44 <Deewiant> because the issues aren't that bad? :-P
10:02:46 <desegnis> @where monadlib
10:02:46 <lambdabot> http://purely-functional.net/monadLib/
10:02:57 <roconnor> Instances
10:02:57 <roconnor> ExceptionM IO Exception
10:03:16 <roconnor> that looks good
10:04:01 <roconnor> What a type of exception is ``connect: timeout (Connection timed out)''?
10:10:48 <SamB> roconnor: probably an IOError...
10:12:33 <tibbe> @src words
10:12:33 <lambdabot> words s = case dropWhile isSpace s of
10:12:33 <lambdabot>     "" -> []
10:12:33 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
10:13:34 <ZimaN> @src (+)
10:13:34 <lambdabot> Source not found.
10:17:12 <olsner> hmm, running ghci with limited heap space interferes with the compiler, it seems
10:19:42 <Peaker_> Are map/filter redundant to list comprehensions, or do they not overlap?
10:20:03 --- mode: irc.freenode.net set +o ChanServ
10:20:07 <SamB> Peaker: map and filter are used in the desugaring, I think...
10:20:30 <Peaker_> SamB, Well, is there any reason to prefer map/filter to list comprehensions?
10:20:43 <Peaker_> Can I not treat them as an implementation detail?
10:20:52 <SamB> you may and should
10:21:14 <Peaker_> great. now if I could remember my other question... :)
10:21:36 <SamB> truth be told, I tend to forget that list comprehensions exist for large periods of time...
10:21:56 <SamB> (or, at least, not actually think about them)
10:22:02 <olsner> SamB: don't list comprehensions desugar into the monad comprehension, but artificially limited to the list monad?
10:22:15 <Peaker_> I really like the infix/prefix convertors ( () and `` ) stuff in Haskell, very innovative, but I find the rest of the syntax confusing/daunting
10:22:27 <SamB> olsner: I'm a bit hazy on the details
10:22:39 <SamB> olsner: I don't think I've even read the Haskell 1.4 report
10:23:03 <SamB> Peaker: rest of the syntax?
10:23:05 <Peaker_> how does the "deriving" clause work?
10:23:24 <mrd> structural induction on the algebraic datatype
10:23:35 <Peaker_> SamB, I think Haskell's syntax is harder than it ought to be..  Python's list comprehensions are much easier/clearer, for example IMO
10:23:48 <SamB> sometimes, deriving does a dirty hack on newtypes...
10:23:53 <Peaker_> mrd, is it hardcoded for those specific classes that can be derived?
10:23:56 <olsner> I can't remember which version of the report I read that in, but I've definitely read some definition of list comprehensions that defined then as monad comprehensions on the list monad
10:24:07 <mrd> yes, in the standard.  no, there are libraries now to do it.
10:24:12 <SamB> Peaker: for => |
10:24:18 <SamB> in => <-
10:24:29 <Jomyoot> should haskell yield better productivy than ruby?
10:24:30 <SamB> is there any other difference?
10:24:53 <roconnor> ahhhh it has IOErrorType timeout
10:24:53 <mrd> ?faq should haskell yield better productivy than ruby?
10:24:53 <lambdabot> The answer is: Yes! Haskell can do that.
10:24:54 <Peaker_> SamB, | is not really for, its a "start comprehension" (consider commas later)
10:24:57 <SamB> how do you do a cross product in Python?
10:25:02 <roconnor> but how do I test that!!!!
10:25:03 <Peaker_> SamB, and there's the if's/guards which are prefixed with "if" in Python
10:25:12 <Heffalump> SIGSTOP your process?
10:25:14 <SamB> Peaker: oh, is that so?
10:25:18 * Heffalump is guessing
10:25:18 <roconnor> oh the insanity
10:25:28 <SamB> Heffalump: what???
10:25:31 <roconnor> @hoogle timeoutErrorType
10:25:32 <lambdabot> No matches found
10:25:43 <SamB> oh, for testing
10:25:55 <Peaker_> SamB, consider [x*2 for x in y if c(x) for bleh in x]
10:26:13 <SamB> Peaker: hmm.
10:26:19 <mrd> Peaker_: feel free to write list comprehensions like this: do { x <- list; guard (pred x); return (x+1) }
10:26:21 <solrize_> which leaks the symbol x to the outside of the listcomp, a bug in its own right :)
10:26:43 <roconnor> Heffalump: I want to use catchJust like a good person.
10:26:55 <SamB> solrize_: we aren't considering stupidity of that sort here!
10:26:58 <Peaker_> solrize_, yeah, that's irrelevant though :) And probably fixed in 3
10:27:12 <Heffalump> what are you trying to test?
10:27:15 <Peaker_> solrize_, I could use genexp instead
10:27:16 <solrize_>  [x*2 for x in y if c(x) for bleh in x]  i'm having trouble understanding this
10:27:19 <roconnor> network timeout
10:27:41 <Heffalump> that's why I suggested SIGSTOP, to simulate that
10:27:46 <Heffalump> though firewalling might be better
10:27:53 <solrize_> same as [(x*2 for x in y if c(x)) for bleh in x]   ?
10:27:58 <roconnor> oh, I can get timeouts
10:28:06 <Peaker_> solrize_, it iterates y, and for each item that c(x) says True, it iterates x, and then you have (x, bleh) with bleh faster-moving than x
10:28:17 <roconnor> I just don't know how to write code to test if an Exception is network timeout or not.
10:28:28 <roconnor> .. other than printing it and checking the string
10:28:34 <roconnor> which seems pretty wrong.
10:28:40 <Heffalump> ah, right
10:28:49 <Peaker_> solrize_, it may make more sense to use "bleh" in the expression rather than x*2,  bleh*2
10:29:01 <SamB> roconnor: well, I'd suggest looking at the type Exception and the type IOError
10:29:08 <mrd> Peaker_: i'm having difficulty reading it as well, can you rewrite it in haskell notation?
10:29:13 <SamB> and in particular their Show instances
10:29:29 <solrize_> [bleh*2 for x in y if c(x) for bleh in x]
10:29:41 <SamB> mrd: hah
10:29:43 <Peaker_> I suppose it could be equivalent to: (bleh*2 for bleh in (x for x in y if c(x)))
10:29:44 <mrd> is the "for bleh" parallel or cartesian product?
10:29:54 <Peaker_> mrd, cartesian, zip is used for parallel
10:29:58 <SamB> mrd: Peaker was just complaining about not being able to understand the Haskell notation ;-P
10:30:15 <mrd> well, I know haskell a lot better than python
10:30:19 <Heffalump> list comprehensions are implemented in terms of map and filter
10:30:21 <Heffalump> (and concat)
10:30:31 <solrize_> [bleh*2 | bleh<-[x|x<-y, c x]]
10:30:34 <Riastradh> [x*2 | x <- y, c x, bleh <- x]
10:30:41 <tibbe> > foldl (+) 0 [1,2,3] : Exp
10:30:41 <solrize_> [bleh*2 | bleh<-filter c x]
10:30:41 <lambdabot>   Not in scope: data constructor `Exp'
10:30:44 <mrd> (x*2, bleh) ?
10:30:52 <SamB> http://www.haskell.org/onlinereport/exps.html#list-comprehensions
10:30:52 <lambdabot> Title: The Haskell 98 Report: Expressions
10:30:52 <tibbe> > foldl (+) 0 [1,2,3] : Expr
10:30:53 <lambdabot>   Not in scope: data constructor `Expr'
10:31:23 <solrize_> [bleh*2 | bleh<-filter c x]      is this correct?  if yes, it looks much clearer than the python version
10:31:49 <Peaker_> mrd, Riastradh has the right one
10:31:56 <solrize_> oh mine is wrong
10:31:56 <Peaker_> (the most similar conversion)
10:32:11 <Riastradh> Peaker_, I'm curious what you find especially different between Python and Haskell.
10:32:17 <Riastradh> ...in their notation for list comprehensions.
10:32:21 <solrize_> [bleh*2 | bleh<-map(filter c) y]      is this correct?  if yes, it looks much clearer than the python version
10:32:22 <Riastradh> Is it just the noise words?
10:32:23 <mrd> well besides the type error
10:32:28 <Peaker_> Riastradh, the explicit "if" helps, I think
10:32:37 <mrd> x*2 and bleh <- x?
10:32:40 <Peaker_> Riastradh, and explicit "for" instead of just a comma separate list
10:32:47 <Riastradh> mrd, yeah, probably he meant something else.
10:32:48 <mrd> no instance for Num []
10:32:49 <solrize_> can you have nested listcomps in haskell?
10:33:00 <mrd> sure
10:33:01 <Riastradh> mrd, probably `bleh * 2'.
10:33:15 <solrize_> > [(a,b) | a <- [1..4] | b<-[5..8]]
10:33:15 <lambdabot>  Parse error at "|" (column 22)
10:33:26 <SamB> Peaker: haskell was designed for maths people ;-)
10:33:28 <solrize_> > [(a,b) | a <- [1..4], b<-[5..8]]
10:33:29 <lambdabot>  [(1,5),(1,6),(1,7),(1,8),(2,5),(2,6),(2,7),(2,8),(3,5),(3,6),(3,7),(3,8),(4,...
10:33:31 <mrd> if you want cartesian product, just p[ut ,
10:33:38 <SamB> our notation looks like set comprehensions
10:33:40 <Peaker_> Haskell may be just as easy to read after the learning curve, but the explicit "if" and "for" keywords don't make it harder to read later, so they ease the learning curve without any penalty
10:34:07 <mrd> "learning curve" you're talking to people accustomed to { (x,y) | x \in A, y \in B }
10:34:28 <Saizan> yeah
10:34:30 <Peaker_> mrd, I'm not accustomed to that :)
10:34:30 <solrize_> i think haskell listcomps originally worked on arbitrary monads rather than just lists
10:34:37 <mrd> or { (x,y) : x in A, y in B } which is what NESL uses, oddly
10:34:41 <paolino> well haskell is more readable , no points
10:34:46 <solrize_> <- doesn't seem worse than for
10:34:56 <Saizan> i find python notation just confusing, how does for nest?!
10:35:04 <Peaker_> paolino, I think Python's learning curve is less steep
10:35:11 <paolino> sure it is
10:35:18 <SamB> Saizan: I seem to find it that way as well
10:35:21 <Peaker_> Saizan, for nest?
10:35:25 <mrd> the view is also less spectacular at the top
10:35:29 <Peaker_> Saizan, list comprehension for?
10:35:31 <SamB> I think I found it that way when I originally learned it as well
10:35:39 <paolino> much less steep, the point is anyway where you arrive
10:35:57 <Peaker_> paolino, I don't know that yet, I've only gone through the tutorial :)
10:36:06 <Saizan> Peaker_: yeah, if you have multiple for-s in a list comp. it's not so clear how they nest
10:36:13 <solrize_> peaker, python is a very easy language and haskell is one of the hardest
10:36:19 <SamB> see, what's needed is more readilly available ropes and harnesses
10:36:28 <solrize_> python has weird corner cases that you can usually ignore
10:36:30 <Peaker_> paolino, It does seem very very interesting and promising so far, love the type system and inference.. But I just mention that for comprehensions where equivalence is easy to find, the Python syntax seems better overall, as it is just as readable but has easier appeal to beginners
10:36:31 <mrd> haskell isn't hard, just different
10:36:42 <Peaker_> Saizan, left-to-right, just like Haskell's?
10:36:55 <paolino> I mean I arrived far with metaclasses in python but my code exploded in a can of worms
10:36:55 <mrd> you'll get over the syntax
10:37:01 <SamB> solrize_: I believe I learned many of those ;-)
10:37:02 <Peaker_> solrize_, if the language is "hard" then its not a good language
10:37:03 <Saizan> Peaker_: with haskell notation it's just visually obvious
10:37:20 <Peaker_> I think Haskell needs a good editor UI rather than a text editor, but that's just a first impression :)
10:37:21 <solrize_> peaker that's like saying if quantum physics is hard it's not a good theory
10:37:30 <Peaker_> Saizan, how so? its left-to-right in both cases
10:37:55 <Peaker_> Saizan, [(x,y) for x in xs for y in ys]  vs.  ((x,y) | x<-xs, y<-ys)
10:38:09 <SamB> Peaker_: keep in mind that Haskell was made by researchers... for research...
10:38:41 <mrd> also it predates Python
10:38:41 <Peaker_> SamB, I do want a high-level general-purpose programming language ... for general-purpose programming...
10:38:43 <paolino> my point is I will never come back and think I need OOP to describe a program
10:38:47 <mrd> and the syntax was taken largely from Miranda
10:38:58 <SamB> Peaker: the learning curve for researchers was lower this way
10:38:58 <Saizan> Peaker_: mostly for .. in adds too much noise
10:39:06 <mrd> since they already knew Miranda =)
10:39:27 <Peaker_> paolino, Your code probably adheres to OOP's principles.. OOP is a good thing :)  (Putting the data declarations and related functions together, etc)
10:39:38 <solrize_> peaker, haskell style generally seems to prefer using map/filter explicitly rather than listcomps.  with python it's the other way around and there was an effort to actually eliminate map and filter from the stdlib.
10:39:39 <SamB> Peaker: also, if people also learn higher math, they will learn basically the same notation anyway
10:39:40 <conal> Peaker_: i agree that Haskell is hard for the reason that any paradigm shift is hard: it requires some initial deprogramming of your mental habits to make room for new ones.
10:39:58 <Peaker_> Saizan, Its not really noise, its just one more token, that makes it visually easy to discern a guard from an iteration
10:40:21 <SamB> who said that about a language not being worth learning if it didn't change the way you think?
10:40:24 <paolino> Peaker_ I disagree, OOP is good until you have to make it work
10:40:32 <Peaker_> paolino, define OOP
10:40:48 <mrd> OOP = mostly hype
10:40:50 <SamB> paolino: oop is off-topic
10:40:55 <SamB> we aren't talking about OOP
10:40:56 * mrd chuckles
10:40:57 <paolino> right
10:41:06 <mrd> FP here
10:41:16 <SamB> Python's list comprehensions have essentially nothing to do with OOP
10:41:18 <olsner> objectionable programming!
10:41:19 <conal> SamB: i like that saying.  though it depends on whether one wants enlightenment or not.
10:41:42 <olsner> "I, object."
10:41:53 <SamB> conal: well, if it doesn't change the way you think, or at least let you spend more time on that and less on typing...
10:41:55 <Peaker> OOP means: 1) Grouping of data and code related to the same concepts together, rather than various other ways to group code.  2) Allow extending interfaces  3) Allow polymorphism, or function selection for a method.    As far as I understand it, Haskell supports OOP
10:42:03 <mrd> i had a quote about objectionable somewhere
10:42:12 <olsner> @quote objectionable
10:42:12 <lambdabot> paczesiowa says: my friends (evil, imperative and objectionable) from university laugh at me that I love haskell and I wont find any job as haskell programmer. I get sad when I start to believe them.
10:42:12 <lambdabot>  but then I look at some java code and I'm all happy again
10:42:15 <SamB> conal: why bother?
10:42:17 <conal> SamB: and miss out on all that good carpal tunnel syndrome?!
10:42:19 <olsner> @quote objectionable
10:42:19 <lambdabot> mrd says: if it has functions, it's functional.  if it has objects, it's objectionable.
10:42:20 <Peaker> SamB, I was answering paolino's claim that he will "never think he needs OOP"
10:42:53 <SamB> what are oop's principles anyway?
10:42:59 <SamB> besides method calls
10:43:00 <mrd> most people disagree
10:43:02 <gwern> @where shim
10:43:02 <lambdabot> http://shim.haskellco.de/trac/
10:43:14 <dogbite> hi, if i want to extract items from tripples
10:43:18 <mrd> and what OOPers call "polymorphism" is not what we call "polymorphism"
10:43:19 <dogbite> do i need to define
10:43:19 <dogbite> tfst  (a, _, _) = a
10:43:26 <conal> SamB: personally i'm in it for enlightenment.  but i've not found that goal to be universally shared.
10:43:29 <gwern> lol dead link
10:43:42 <atp> dogbite: you can
10:43:55 <atp> dogbite: or you can pattern match directly if you're not doing it much
10:44:04 <SamB> conal: well, I SUPPOSE a programming language could also be worth learning if it has a really neat library or something...
10:44:04 <Peaker> SamB, The definition I know is: 1) Encapsulation 2) Inheritence 3) Polymorphism.  1 refers to grouping based on concepts, putting data and code relating to same concept together.    2 refers to extensibility of interfaces.   3 refers to polymorphism, method -> func selection
10:44:06 <paolino> Python list comp has been taken around here
10:44:07 <conal> mrd: in that we usually mean *parametric* polymorphism?
10:44:12 <mrd> ya
10:44:37 <solrize_> i've found haskell is harder than python because: 1) much more complex type system (i couldn't understand monads without reading up on category theory and can't read an XML file right now because i don't understand arrows); 2) pervasive use of HOF's takes a lot of head scratching to get used to; 3) need to organize programs somewhat "inside out" to put all the monadic i/o in one place; 4) no separate namespaces for member functions on different type
10:44:37 <solrize_> s; 5) bizarre divergence and performance surprises resulting from lazy evaluation
10:44:39 <hpaste>  MigMit pasted "John Hughes failed to make CGI programs arrows; that's it" at http://hpaste.org/6236
10:44:40 <dogbite> atp: okay, just wondered if one was pre-defined
10:44:50 <Peaker> mrd, polymorphism in the OOP sense is quite different, but it shares the idea of converting a chosen method to a chosen function based on type
10:44:57 <atp> dogbite: not that i know of.
10:45:02 <dogbite> atp: thanks
10:45:25 <gwern> @where+ shim http://code.haskell.org/shim/
10:45:25 <lambdabot> Done.
10:45:28 <SamB> solrize_: HaXml uses arrows?
10:45:32 <atp> dogbite: although, if you're looking at a type like (a, b, c) you might be better off making your own data structure
10:45:36 <solrize_> HXT uses arrows
10:45:39 <Peaker> what are HOF's?
10:45:41 <atp> dogbite: it'll be clearer
10:45:46 <solrize_> HOF = higher order function
10:45:47 <conal> Peaker: higher-order functions
10:45:49 <SamB> solrize_: if you learn HaXml, I think you'll be in a good position to grok HXT's arrow
10:45:53 <Peaker> oh
10:46:05 <solrize_> hmm i guess i should check out haxml then, i had the impression hxt was better
10:46:18 <Peaker> so, wouldn't you agree Haskell is actually mostly adhering to OOP principles as I outlined above?
10:46:21 <mrd> Peaker: in OOP that happens at runtime (C++'s broken system notwithstanding)
10:46:28 <paolino> no
10:46:30 <mrd> so it's not really part of the static semantics
10:46:36 <solrize_> peaker i don't think haskell is in the OO spirit at all
10:46:45 <SamB> solrize_: HXT seems to have too much exported with too little documentation about what you should use when...
10:46:47 <Peaker> mrd, yeah, polymorphism is the main difference, but the basic idea is similar
10:46:50 <mrd> no, and I find most people who try to write OO in Haskell get themselves very confused
10:46:51 <solrize_> OO usually means mutable objects that can encapsulate things like network connections
10:47:06 <solrize_> you run some method on the object and it's invisible to you whether it's doing i/o or not
10:47:08 <Peaker> solrize_, Mutability is not part of what OO is about
10:47:08 <SamB> solrize_: I do like the idea of it's arrow though
10:47:10 <conal> solrize_: i think alan kay would say the same for python, c++, c#, java, etc
10:47:14 <solrize_> the exact opposite of what haskell's monadic io requires
10:47:34 <mrd> ?wiki HXT/Practical
10:47:34 <lambdabot> http://www.haskell.org/haskellwiki/HXT/Practical
10:47:40 <conal> solrize_: (i.e., not in the OO spirit)
10:47:44 <mrd> ?go wikibook hxt haskell
10:47:45 <lambdabot> http://en.wikibooks.org/wiki/Haskell/XML
10:47:54 <solrize_> conal hmm
10:47:57 <Peaker> solrize_, OO is most often used for mutable-object-based designs, but OO itself is about how to organize the code conceptually, rather than semantically or chronologically
10:48:29 <Peaker> for example, before OO's prevalence, people would group code according to when and where it is used, rather than according to which concepts it was related to
10:48:30 <paolino> which is not how I see haskell programs now
10:48:32 <SamB> mrd: yes, the most OO things I've seen in Haskell are probably gtk2hs and wxHaskell...
10:48:45 <SamB> and the objects are all implemented in C!
10:48:52 <SamB> or C++
10:48:55 <solrize_> peaker i mean the way OO programs are usually actually written, not so much whether haskell can do similar things
10:48:57 <mrd> heh, well, that's GTK+'s design
10:49:08 <SamB> and wxWidget's
10:49:16 <mrd> GTK is in C, yea
10:49:16 <SamB> or is that wxWidgets'
10:49:36 <paolino> still there are functional GUIs
10:49:38 <solrize_> i.e. i'm always using python classes for network sockets, database connections, etc.  (plus gui widgets)
10:49:39 <Peaker> solrize_, ok.  I find the OO spirit a universally good thing, and find it weird that people see it as contradicting FP
10:49:52 <SamB> paolino: yes, but I notice they don't seem to use the usual OO design...
10:49:54 <atp> Peaker: as i see it, the main thing about OOP is that it implements a generic message passing interface between objects that hide their internals, and many people new to haskell from OOP languages think they can use the type system to simulate this sort of thing... but in reality, message passing is more inherently dynamic and some type checking needs to be done at runtime
10:49:56 <desegnis> Peaker, I don't agree on your last point. Haskell had modules like List, Monad, IO, ... before OO
10:50:27 <mrd> I think OOP claims to be a lot of things because no one has really nailed it down
10:50:56 <Peaker> atp, its indeed about data hiding, but "message passing" is a very lenient term that can just mean "function call to perform a computation"
10:51:00 <paolino> for me OP is same arg type on all methods
10:51:09 <SamB> Haskell doesn't really support that whole inheritance/overriding thing
10:51:10 <paolino> and data there
10:51:19 <desegnis> I always understood OOP as encapsulating internal representation and state via an object model
10:51:37 <SamB> then again, I'm hearing that that's not really considered a particularly good thing to do much of?
10:51:39 <mrd> plenty of OO languages don't encapsulate
10:51:47 <Peaker> SamB, it supports the most important aspect of OO: Encapsulation and data hiding (You expose an API to work with your data type without exposing implementation details)
10:51:50 <desegnis> But people tend to have different ideas of what are the integral concepts of OOP
10:51:58 <atp> Peaker: the problem with a trans-object function call is, what is the return value of the function call?  If i have a generic object obj, and I call obj.foo, what does foo return?
10:52:11 <SamB> mrd: well, even if the guts are all in plain sight, you generally try to avoid using this fact...
10:52:16 <mrd> Peaker: sounds more like modularity, which is wider than OO
10:52:20 <Peaker> atp, obj can be typed and return the appropriate type
10:52:22 <SamB> since it introduces overly-tight coupling...
10:52:22 <mrd> er, not limited to OO
10:52:33 <atp> Peaker: you necessarily need generic types (you can simulate them with Data.Generic in haskell) but some runtime checking is required
10:52:46 <Peaker> mrd, modularity does not specify what criterion to divide into modules .. even chronological division into modules is considered modular
10:53:00 <mrd> what OO introduces is the idea of "identity" to objects
10:53:08 <mrd> and this is anathema to FP
10:53:13 <paolino> right
10:53:20 <conal> has anyone mentioned that objects are tuples of functions (closures)?  simple data hiding.
10:53:22 <Peaker> mrd, modules divided by semantics (This module contains all the enums, this one all the filenames) are also modular
10:53:29 <SamB> Lava uses identity though ;-P
10:53:36 <conal> s/tuples/records
10:53:43 <SamB> at least, Lava 2000 does
10:53:58 <mrd> for example, having two strings "abc" be equal but not identical is something that occurs in an OOP language
10:54:08 <conal> mrd: is "object identity" somehow essential/central to OO?
10:54:14 <mrd> but that is undetectable to FP
10:54:19 <mrd> conal: I would argue so
10:54:22 <Peaker> mrd, I don't think its part of OO's definition, though it is indeed commonplace.  "OOP" just means so many things...
10:54:24 <conal> mrd: please do
10:54:27 <mrd> I think it is the one principle which is common to all OO languages
10:54:48 <conal> mrd: by definition (of OO)?
10:54:49 <Peaker> mrd, What about OCAML?
10:54:52 <mrd> sometimes it's called "reference semantics"
10:55:06 <SamB> mrd: well, using is to compare "value objects" is a definate no-no in Python...
10:55:28 <SamB> (is being the pointer identity operator)
10:56:31 <SamB> (well, in particular, immutable objects)
10:56:43 <mrd> conal: OO languages have all sorts of features like encapsulation, class or prototype, inheritance or delegation, etc.  they all seem to have this notion of creating "objects" though, and that each creation of object produces a unique one in some fashion.
10:56:47 <conal> OO isn't any one thing or one combination of things.  it's more nebulous.  a term used in many different, contradictory ways.
10:56:47 <paolino> and objects can hold state , or this is only for a part of the languages ?
10:56:52 <SamB> hmm... there's an idea...
10:57:06 <SamB> I wonder if it would be usefull to add a way to "freeze" an object in Python?
10:57:36 <paolino> ruby has it IIRC
10:57:38 <conal> mrd: sounds more like imperative languages than OO languages to me.
10:57:41 <mrd> SamB: because "value" objects may have the same value but different identity
10:57:41 <solrize_> samb, python has a "consenting adults" philosophy that says to not lock up anything
10:58:12 <solrize_> that's one reason i got interested in haskell, i figure that the inside of a program should be more like a workplace than a bedroom :)
10:58:17 <SamB> solrize_: I was thinking it might be able to improve performance
10:58:19 <mrd> conal: well my example with the strings does happen without any mutation
10:58:38 <solrize_> i've been wanting to write something like Data.Map (frozen dictionaries) for python
10:58:50 <mrd> conal: it's one of the reasons I consider OO to be irreconcilable with FP
10:58:56 <conal> mrd: let's take that example.  without mutation, what's the value of object identity, i.e., distinguishing between equal strings?
10:59:00 <solrize_> but that's in order to get the functional data structure benefits
10:59:34 <SamB> conal: none. though it can save you a string comparison if you check the pointers first...
11:00:08 <solrize_> conal, the value of object identity is when the objects are things like file descriptors, not strings
11:00:08 <SamB> but that should clearly be part of the equality implementation...
11:00:34 <conal> SamB: sure, and a functional language implementation could use the same trick.  so again, the central point seems imperative/mutability, not OO.
11:00:43 <conal> solrize_: right -- statefulness.
11:00:53 <solrize_> also, if type(x)==int is a standard python idiom
11:00:54 <conal> that's why i see the tension as imperative vs functional, not OO vs functional.
11:01:03 <paolino> but what are objects without state ?
11:01:16 <SamB> paolino: well, a heck of a lot less messy...
11:01:44 <paolino> I think they are not any useful without
11:02:12 <paolino> see what mess is functional graphing
11:02:22 <SamB> FGL?
11:02:36 <paolino> not the interface
11:02:46 <SamB> what sort of graphing?
11:02:49 <paolino> the implementation
11:02:53 <SamB> you mean like plots?
11:02:57 <paolino> of mutable graphs
11:03:04 <solrize_> can someone tell me if the existence of Scrap Your Boilerplate is evidence that haskell's type system is dysfunctional?
11:03:10 <SamB> ah, directed graphs...
11:03:14 <paolino> right
11:03:18 <conal> paolino: objects w/o state is debatable.  setting aside that debate for now, my point is that statefulness is the source of the conflict between typical OO and functional.
11:03:21 <SamB> solrize_: it isn't
11:03:39 <solrize_> i mean it effectively turns haskell untyped...
11:03:47 <SamB> does it now?
11:03:53 <conal> paolino: so the the OO-ness is neither necessary nor sufficient for the tension.
11:04:08 <solrize_> samb i think so.  it lets you take a program fragment and reassign all the types
11:04:09 <mrd> pierce has a chapter on functional OO, but I really don't see the point
11:04:21 <SamB> solrize_: how so?
11:04:29 <paolino> conal it depends on the knowledge of this principle
11:04:44 <solrize_> samb you probably understand it a lot better than i do
11:04:52 <conal> paolino: which principle?
11:05:06 <paolino> coming from normal languages objects are stateful
11:05:12 <solrize_> am i thinking of template haskell?
11:05:22 <SamB> solrize_: oh, probably
11:05:24 <paolino> if you talk with me we can agree easily
11:05:34 <conal> paolino: sure, and so people confuse OO with statefulness.
11:05:37 <paolino> (now :) )
11:05:39 <SamB> ;-)
11:05:49 <conal> btw -- haskell does have object identity inasmuch as it supports imperative programming.
11:05:50 <solrize_> right SYB was something different but also confusing
11:06:02 <conal> e.g., the Eq instance of Data.IORef
11:06:23 <swidgy> i think a big point of OO is that in languages such as Java/C++, it's not just about state, but it's also the primary vehicle for type inheritance and polymorphism
11:06:52 <SamB> clearly the only type of equality that makes sense for IORef is "if I change one, will the other change too?"
11:06:57 <mrd> well in Java and C++ it's modules, datatypes, and polymorphism all squeezed into one squirmy package
11:07:16 <Saizan> solrize_: TH is at compile time, and code generated by it must typechecks in the end
11:07:16 <paolino> swidgy, that's my point against OPP, you describe the world so nicely but then you havo to make it move all together
11:07:42 <conal> SamB: I can make sure two unequal IORefs have their values always agree
11:07:46 <paolino> that's the time you strat not liking your descrpition
11:07:56 <SamB> conal: can't!
11:08:08 <SamB> 'tis impossible
11:09:09 <paolino> swidgy: functional analysis is always the right one, probably implementation is debatable
11:09:40 <paolino> a program is a function , not a database
11:10:07 <conal> paolino: program == function ??
11:10:28 <swidgy> paolino: that's a purist's perspective. the good folks at Java believe a program is a combination of code and data
11:10:39 <solrize_> in haskell, a program is a value :)
11:10:46 <SamB> swidgy: isn't that just what a function is?
11:10:47 <solrize_> main :: IO ()
11:10:48 <monochrom> A program is a morphism.
11:10:50 <conal> i'd say a program is syntax, not a function or a value
11:11:00 <conal> on the other hand, the semantics of a program ...
11:11:07 <monochrom> is a morphism
11:11:24 <conal> monochrom: why a morphism?
11:11:31 <swidgy> SamB: "a function" doesn't imply the concept of a mutable memory
11:11:48 <monochrom> So as not to prematurely commit to a particular category.
11:11:51 <conal> swidgy: maybe mutable memory isn't essential
11:11:53 <SamB> swidgy: neither did what you say the java people think a program is
11:12:05 <monochrom> Premature definition is the root of all evil.
11:12:45 <conal> monochrom: sounds like a guy perspective.
11:12:50 <conal> ;)
11:13:03 <swidgy> SamB: that's where i was headed.  forgive my phrasing
11:13:28 <paolino> Java makes programmers slaves of the classes
11:13:28 <solrize_> i think it's hard to program effectively in haskell without understanding graph reduction and gc, which is mutable memory under the covers
11:13:28 <swidgy> conal: perhaps not.  i'm not in the Java camp... just trying to understand
11:13:38 <SamB> now, I realize the java people probably think it goes without saying that the data is mutable...
11:13:51 <solrize_> i mean there's a big difference between expressing a function mathematically, and writing actual software with reasonable performance
11:14:07 <paolino> this is totally true
11:14:13 <SamB> solrize_: yes, clearly we don't want to use PROM ;-)
11:14:20 <solrize_> PROM?
11:14:28 <SamB> that would be extremely wasteful and we'd go through stacks of it ;-)
11:14:31 <solrize_> oh
11:14:46 <monochrom> If you read Bird (FP) or Hoare (IP), a program is a relation, not restricted to a function.  They know and they use the extra flexibility.
11:14:46 <SamB> or Write Once Memory
11:14:57 <conal> on imperative programming an assumption of mutability: once upon a time, people programmed computers.  the roles reversed, and most people haven't noticed.
11:15:09 <solrize_> samb, even with prom you still have to understand call-by-need to know if something will be evaluated once or multiple times
11:15:28 <SamB> another reason we don't want to use PROM
11:15:31 <SamB> you can't update thunks
11:15:42 <SamB> in addition to it's being bad for the environment
11:16:20 <paolino> solrize_: I don't think it's the main point of programming, performance
11:16:44 <SamB> performance is fairly important
11:16:45 <solrize_> hah, that explains a lot of things :)
11:16:56 <monochrom> If you want performance, you use even more mathematics, not less.
11:17:03 <solrize_> i mean we spend all that time studying algorithms for a reason...
11:17:04 <SamB> but clearly secondary to at least some semblance of correctness
11:17:07 <sclv> correctness should come first, is all.
11:17:13 <swidgy> it'd say performance is ancillary to obtaining a correct and useful result
11:17:13 <conal> monochrom: even morphisms is restrictive, isn't it?  more general than functional (or relations) but less general than values?
11:17:30 <monochrom> I don't know values.
11:17:48 <solrize_> swidgy, nah, we use floating point arithmetic all the time even though it's incorrect compared with exact arithmetic
11:17:51 <solrize_> it's because of performance
11:17:54 <sclv> conal: is that like defining a program as "something that typechecks" ?
11:18:21 <swidgy> solrize_: depends on your expectations of the output.  correct can be within a reasonal bound if that's all the requirements call for
11:18:21 <paolino> solrize_: and there is my time and my head to respect also if we want to measure all time dependent variables
11:18:34 <swidgy> s/reasonal/reasonable/
11:18:34 <sclv> "an object in the category hask"
11:18:35 <conal> sclv: more mundane.  e.g., "3" is a program, though its meaning isn't a function or a relation.
11:18:55 <olsner> *** Exception: Numeric.showInt: can't show negative numbers
11:18:59 <conal> sclv: or i might have a pair of functions, or a function and a list of pairs of functions over lists, etc.
11:19:44 * conal would rename "functional programming" to "value-oriented programming" for clarity
11:20:00 <monochrom> I include timeliness as part of correctness.  "This program must deliver '1' in 2 steps."  You can relax "2 steps" to "O(1) steps" or restrict to "2 milliseconds" etc.  The point is "deliver '1' " alone is unfalsifiable; a scientific correctness specification must include time in order to be falsifiable.
11:20:16 <shag> *paff*
11:20:47 <monochrom> Oh well, bad timing.
11:20:51 <paolino> solrize_: also, many programs don't   benefit on performance
11:21:09 <swidgy> monochrom: that's an interesting point.  i would have to agree that some bound is required
11:21:11 <SamB> monochrom: eh?
11:21:19 <SamB> I can write a program that delivers 2
11:21:31 <solrize_> paolino, the set of programs for which performance doesn't matter isn't very interesting.  that's why so much work went into ghc ;)
11:21:59 <swidgy> samb: but what if it takes infinitely long to do so?  can you prove that program correct?
11:22:17 <SamB> swidgy: this program is not supposed to be correct
11:22:18 <olsner> tail (repeat 1 ++ [2])
11:22:26 <SamB> monochrom's spec involved delivering 1
11:22:35 <SamB> he claimed that it was unfalsifiable!
11:22:41 <paolino> solrize_: for that I just thanks
11:22:42 <RayNbow> @faq Can Haskell solve HALT_TM?
11:22:42 <lambdabot> The answer is: Yes! Haskell can do that.
11:22:58 <RayNbow> hmm, should have used *decide instead of solve
11:23:18 <monochrom> SamB is just picking on my wording.
11:23:19 <RayNbow> someone keeps tripping over network cables
11:23:50 <olsner> freenode is trying to find out which one's the Europe cable, apparently
11:23:51 <swidgy> you know, in talking to Java guys, I never had to actually think while forming sentences
11:23:56 <SamB> olsner: heh
11:24:10 <SamB> swidgy: that is what makes Haskell so much fun
11:24:15 <swidgy> ;)
11:25:56 <conal> "thinking is hard.  let's write some more curly braces."
11:26:12 <conal> and semicolons
11:26:18 <Vq^> conal++
11:27:41 <conal> Vq^: thx!! :)
11:28:52 <Vq^> conal: i actually find the C-syntax very awkward for a "high-level" language like Java
11:29:10 <solrize_> java just seems monstrously bureaucratic
11:29:15 <Vq^> i don't quite understand why they adopted it so straight off
11:29:20 <swidgy> it is
11:29:27 <solrize_> is ada any better?
11:29:46 <swidgy> the gov would certainly say so
11:29:54 <SamB> VHDL syntax seems reasonable... but then VHDL is an extremely low-level language...
11:29:56 <conal> Vq^: how about the verbose, angle-brackety, necessarily-explicit type annotations?
11:30:10 <conal> SamB: what does VHDL stand for?
11:30:15 <Vq^> conal: they're quite terrible
11:30:22 <SamB> VHSIC Hardware Description Language
11:30:27 <Vq^> conal: seen the C# type for foldl?
11:30:58 <conal> Vq^: gah!  no, but i've seen & written some scary ones, for Pajama's RTS (http://conal.net/Pajama)
11:30:59 <lambdabot> Title: Pajama
11:31:09 <swidgy> Vq^: foldl in c#?  got a link?
11:31:45 <solrize_> why does ghc say "compilation IS NOT required" even though i changed the source file?
11:31:56 <Vq^> public static TAccumulate Aggregate<TSource, TAccumulate>(this IEnumerable<TSource> source, TAccumulate seed, Func<TAccumulate, TSource, TAccumulate> func)
11:31:57 <SamB> VHDL is the complicated HDL
11:32:06 <Vq^> http://msdn2.microsoft.com/en-us/library/bb549218.aspx
11:32:07 <lambdabot> Title: 500 Internal Server Error
11:32:12 <Vq^> ops
11:32:45 <Vq^> what the, why does lambdabot receive 500?
11:32:47 <solrize_> hmm the haskell equivalent would have a bunch of similar typeclass annotations
11:33:11 <Vq^> solrize_: absolutely
11:33:41 <monochrom> All programming language discussions degenerate to syntax discussions.
11:33:45 <swidgy> solrize_: but it probably would use the template engine as a vehicle ;)
11:33:47 <sclv> on the other hand, it could maybe infer much more about them...
11:33:48 <Cheery> unfortunately
11:33:52 <swidgy> s/would/wouldn't/
11:34:09 <Vq^> @type foldl
11:34:10 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
11:34:13 <Cheery> monochrom: even worse, most programming language discussions degenerate to the arguing of syntax.
11:34:32 <Vq^> i find the HM-type easier to reason about, thats all
11:34:50 <monochrom> Hehe.
11:35:03 <swidgy> cheery: are you saying there's more to the expression of a program than syntax?
11:35:04 <sclv> http://www.haskell.org/haskellwiki/Wadlers_Law
11:35:05 <lambdabot> Title: Wadlers Law - HaskellWiki
11:35:13 <Cheery> and some degenerate to speaking about superfluous standards and conventions, and (anti)patterns and such superfluous stuff which has nothing to do with programming itself
11:35:15 <solrize_> i think that c# type might be more general, folding over an arbitrary fmap instead of just a list
11:35:18 <conal> Cheery: while ultimately, syntax/programs are just a means to an end.
11:35:42 <Vq^> solrize_: in a way no
11:36:01 <solrize_> "
11:36:01 <solrize_> since feeling is first
11:36:01 <solrize_> who pays any attention
11:36:01 <solrize_> to the syntax of things
11:36:01 <solrize_> will never wholly kiss you;
11:36:02 <solrize_> wholly to be a fool
11:36:04 <solrize_> while Spring is in the world"
11:36:07 <Vq^> solrize_: Enumerators are practically haskell-lists when they are used as streams
11:36:19 <Cheery> swidgy: that's sarcasm right? There is bunch of stuff that affect the program more than it's syntax!
11:36:19 <solrize_> hmm ok
11:36:29 <Vq^> solrize_: and that IEnumerable interface just specifies the method to receive that Enumerator
11:36:34 <swidgy> cheery: of course!  i've been lurking in #haskell way too long to mean that ;)
11:36:36 <olsner> VHDL sounds exciting: it has 9-valued logic (U,X,0,1,Z,W,H,L,-)
11:36:50 <Cheery> swidgy: for instance, compare lisp, prolog and haskell
11:37:01 <monochrom> There is an anti-Godwin law at work.  Usually, Godwin law applies, and when a discussion generates to talking about the Nazis, it ends.  But in programming language discussions, there is a dual: when it degenerates to {} vs indentation, that's when the real heat begins.
11:37:47 <sclv> / vs -- vs /* */ more like.
11:37:47 <conal> monochrom: then we get to add emacs-vs-vi for manipulating the braces & indentation
11:37:47 <swidgy> did someone say indentation?  because i just happen to have an opinion on that....
11:38:02 <sclv> oh dear, tabs and spaces!
11:38:52 <roconnor> @quote law
11:38:52 <lambdabot> newsham says: Newsham's Law: the more powerful the abstraction, the more unclear it is until you understand it :)
11:38:56 <roconnor> @quote law
11:38:56 <lambdabot> lament says: three laws of robotics: 1) don't do anything unless you ABSOLUTELY HAVE TO 2) ...other laws to be written as they become required
11:39:00 <roconnor> @quote law
11:39:01 <lambdabot> monochrom says: The Three Laws of Types. (1) Must protect programmer. (2) Must obey programmer, when not in conflict with (1). (3) Must protect computer, when not in conflict with (1) or (2).
11:39:13 <roconnor> @quote hetrogenous
11:39:13 <lambdabot> No quotes match. BOB says:  You seem to have forgotten your passwd, enter another!
11:39:13 <monochrom> hehe
11:39:19 <SamB> why are there so many apache2 processes on darcs.haskell.org?
11:39:26 <monochrom> typo. heterogenous.
11:39:32 <conal> monochrom: awesome quote.  monochrom++
11:39:36 <monochrom> err. heterogeneous
11:39:39 <roconnor> @quote heterogenous
11:39:39 <lambdabot> No quotes match. My brain just exploded
11:39:43 <roconnor> @quote heterogeneous
11:39:43 <lambdabot> No quotes match. I've seen penguins that can type better than that.
11:39:48 <roconnor> damn es
11:40:30 <Cheery> how does one do proofs about mathematical discoveries he has first produced?
11:40:38 <monochrom> lament's law is a nice one about lazy evaluation :)
11:40:59 <monochrom> What is a mathematical discovery?
11:41:24 <Cheery> ie. if I have discovered something that works for some things, how do I find out where it does break?
11:41:48 <roconnor> roconnor :: As an online discussion of static types vs dynamic types grows longer, the
11:41:48 <roconnor>             probability of mentioning heterogenous lists approaches 1.
11:42:15 <monochrom> How do you know that your "something" works for some things?  Whatever your answer to that is, that answer is your proof.
11:42:45 <Cheery> isn't it very hard to prove things true?
11:42:58 <roconnor> Cheery: proving is like programming
11:43:03 <Twey> Cheery: If the principles on which it's built are sound, then so is the theorem... you can prove it without testing (there are even automated theorem-provers)
11:43:05 <roconnor> actually proving is programming.
11:43:14 <monochrom> Yes.  So don't say "I know X works on Y" until you really know.
11:43:16 <olsner> The One Law of C Types: (1) Anything goes.
11:43:24 <Twey> Heheh
11:43:36 <solrize_> what about proving the nonexistence of something?
11:43:58 <monochrom> And to find out "does X break on other things", you keep exploring.
11:44:17 <sclv> ?djinn (b->a) -> a
11:44:18 <lambdabot> -- f cannot be realized.
11:44:55 <Cheery> Twey: so if it relies *only* to principles one can find to be true, it is proved?
11:45:36 <monochrom> mathematical truth /= physical truth.  pick one.
11:46:19 <Deewiant> @ty \f -> f undefined
11:46:20 <lambdabot> forall a t. (a -> t) -> t
11:46:48 <Deewiant> sclv: if that's acceptable to you ;-)
11:55:59 <Cheery> hm. the introduction -chapter of "The Implementation of Functional Programming Languages" gives the idea that actually writing and implementing a functional language would be simple! And with simple I mean.. Way damn simple.
11:56:07 <Cheery> simple and beautiful
11:56:25 <Twey> It is
11:56:42 <Twey> http://www.google.com/search?q=lambda+calculus
11:56:42 <lambdabot> Title: lambda calculus - Google Search
11:57:07 <Twey> http://www.google.com/search?q=haskell+scheme+24+hours&btnI
11:57:07 <lambdabot> Title: haskell scheme 24 hours - Google Search
11:57:52 <Twey> http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/parser.html in fact.
11:57:58 <lambdabot> Title: Write Yourself a Scheme in 48 hours, http://tinyurl.com/yzphh2
11:58:51 <Cheery> I mean, graph reduction is simple, and not only useful for haskell or clean
11:59:34 <monochrom> It does not treat type-checking. It assumes you're past that. It treats generating executable code. IIRC it doesn't treat garbage collection either.
12:00:08 <Cheery> and lambda calculus can be seen as a way to implement namespacing into such graph reducer.
12:00:10 <monochrom> But much complexity of the runtime is in the garbage collection. And much complexity at compile time is type checking.
12:00:39 <Cheery> monochrom: yep
12:01:52 <monochrom> Type checking is simple and beautiful if you don't mind a slow algorithm. To get it fast (e.g., a fast unification algorithm) is hairy.
12:02:01 <Cheery> gc is quite challenging problem, and most of the solutions I've seen does not deploy simple algorithms
12:02:37 <Deewiant> just allocate 640K statically and leave it at that, should be enough for anyone
12:02:40 <solrize_> doing single threaded simple minded gc is pretty easy if you don't mind the speed hit
12:02:56 <Cheery> monochrom: would there be a way to write a fast type checking algorithm that is also simple and beautiful?
12:03:09 <solrize_> but i think doing a pure language without getting clobbered is harder
12:03:43 <solrize_> i.e. if you just do graph reduction without a bunch of strictness analysis you suffer a lot
12:04:53 <Cheery> it sounds a similar stuff I heard about prolog when I asked the same thing
12:05:02 <monochrom> I don't know. From what I know, no one has accomplished it.
12:05:50 <Cheery> monochrom: what would be the reason?
12:06:09 <monochrom> Or else, what I consider hairy, other people consider well-understood, so there is no need to beautify.
12:08:55 <Cheery> I hope I have enough motivation for discovering simple, fast and elegant solutions for those things
12:09:42 <monochrom> Naive unification is slow when you have an expression dag exploiting sharing but you aren't aware of it. An n-node dag looks like a 2^n node tree to you. So you spend that much time.  The solution is to know it's a dag, and use lots of object identity, hashing, memoization, ... to eliminate redundancy.  I consider that hairy.
12:09:53 <Cheery> while reading the papers about haskell through, I'm trying to learn some skills to possibly even accomplish this
12:10:33 <Cheery> thought, first going to sauna
12:11:17 <Cheery> I think I'm good forward thought, this far the introduction of this book I'm reading has made really much sense, I've understood very well what this book is about and how it is organized
12:12:11 <Cheery> even thought this thing is almost 500 pages long
12:12:59 <Cheery> but I think I don't care this time, this time I have a reason to read it through
12:15:27 <roconnor> Ah, Cheery is in Finland; hence the sauna.
12:15:41 <roconnor> Why doesn't Canada have Sauna's everywhere :(
12:15:49 <roconnor> saunas
12:16:49 <monochrom> We inherited our culture from Britain. We have pubs everywhere. Oh, and ski resorts too.
12:17:56 <monochrom> We also got influence from the US, though we put in our own twist. We go to stadiums and watch and yell at hockey games.
12:18:29 <sieni> roconnor: well, you should have :-)
12:19:42 * roconnor switches from pine to alpine
12:20:12 <solrize_> cheery, you're looking at SPJ book about FP implementation?  yes, it's very good, it demystified haskell a lot for me
12:20:22 <solrize_> even just as a user not worrying about implementing the language
12:21:28 <hpaste>  My sunshine pasted "Sweet lettrer" at http://hpaste.org/6237
12:21:54 <solrize_> whaaa?
12:23:33 <monochrom> "My love, my sunshine, you make my life sweet, every function I type."  -- fan letter to the haskell programming language
12:24:36 <roconnor> I can only assume this is paste is the beginning of a new ARG
12:25:02 <roconnor> @go ARG
12:25:03 <lambdabot> http://en.wikipedia.org/wiki/Alternate_reality_game
12:25:03 <lambdabot> Title: Alternate reality game - Wikipedia, the free encyclopedia
12:25:17 <swidgy> cheery: i'm going through the book right now.  so far, it's been really enlightening, and VERY approachable.  it touches on the harder aspects, but makes the basic theory in unoptomized form very clear and consice
12:26:09 <drguildo> is anybody here familiar with the book "programming in haskell" and can help me get my head around chapter 8?
12:26:40 * roconnor wonders if chapter 8 is IO
12:26:50 <drguildo> nope
12:26:55 <drguildo> not explicitly anyway
12:26:58 <drguildo> it's a parser
12:27:07 <solrize_> what book?
12:27:36 <drguildo> programming in haskell
12:27:54 <drguildo> by graham hutton
12:27:54 <solrize_> anyway i don't have it, i wondered who the author was
12:27:57 <solrize_> oh heh
12:28:04 <swidgy> g hutton
12:28:06 <solrize_> is it good?
12:28:13 <drguildo> so far, yes
12:28:23 <drguildo> but i can't seem to get my head around this bit
12:28:30 <solrize_> can you explain the problem?
12:29:02 <swidgy> the parser chapter is short, and touches on the basics of char parsers
12:29:03 <drguildo> i've tried a few times, with no success. i'm not sure the explanation is a bit lacking, i guess it's all relative though.
12:29:06 <glen_quagmire> how can I do runtime typechecking?
12:29:23 <drguildo> it's going to be difficult because he uses his own notation for some reason
12:29:32 <drguildo> and then "converts" it to haskell
12:29:32 <solrize_> glen, haskell uses compile time typechecking.  you can have sum types, which are basically tagged unions, if that helps
12:29:36 <glen_quagmire> i'll try harder to come up with a better question
12:29:46 <drguildo> but i can try
12:30:28 <augustss> glen_quagmire: maybe you want Data.Dynamic?
12:30:45 <swidgy> drguildo: by "converts it to haskell", are you referring to the conversion to "do notation"?
12:31:00 <drguildo> swidgy: yes, exactly
12:31:15 <drguildo> it's the arrows i don't get though
12:31:18 <monochrom> IIRC some code in the book conflicts (name clash for example) with preloaded libraries.
12:31:22 <glen_quagmire> in my language, I want to make these happen:    1 == 2,  'a' == 'a', "hello" == "blah"...etc.    so it's like operator overloading.   compareOp op [a,b] = unpackVal a `op` unpackVal b      -- i'm not sure about types of a b
12:31:25 <drguildo> in his original notation mainly
12:31:46 <drguildo> monochrom: i haven't even tried running his code because it has very little in common with what's in the book
12:32:10 <glen_quagmire> if the expression is parsed to be [Str "hello", Char 'a']  then compareOp should throwError
12:32:16 <drguildo> i found somebody asking about the same chapter on the haskell cafe mailing list but that didn't really help me
12:32:18 <monochrom> "λx → blah" is \x -> blah
12:32:19 <swidgy> drguildo: it's pretty much haskell all the way through.  the idea is that the parser is a monad, and follows general monad conventions such as the >>= (bind) operator.  have you had exposure to monads at this point?
12:32:38 <solrize_> glen_quagmire, you want the Ord typeclass?
12:32:39 <drguildo> swidgy: no, and he doesn't cover monads until later in the book :-)
12:32:40 <monochrom> "x ← blah" is x <- blah.
12:32:44 <glen_quagmire> so, in the body of compareOp, I want to check type of a and b... i could do patternmatching. but it's very cumbersome
12:32:58 <solrize_> Ord a => op :: a -> a -> Bool
12:33:09 <augustss> glen_quagmire: make a sum type to keep all your different kind of values in and check the types when you need
12:33:11 <glen_quagmire> case a of Str s -> case b of Str s' -> s `op` s'
12:33:27 <glen_quagmire> otherwise -> throwError "bad type"
12:33:28 <drguildo> monochrom: i understand lambda functions (i think) but this section is explaining the later notation and i don't understand it
12:33:41 <solrize_> oh i see, you're writing an interpreter for a dynamically typed language
12:33:43 <drguildo> later/latter
12:33:57 <glen_quagmire> data Val = Str String | Int Integer | Float Double | ...
12:34:03 <monochrom> Does any earlier chapter talks about "do" and "monads"?
12:34:10 <drguildo> monochrom: nope
12:34:12 <augustss> glen_quagmire: case (a, b) of (Str a, Str s') -> s `op` s'
12:34:16 <ttt--> typeOf x == typeOf y ?
12:34:22 <glen_quagmire> compareOp :: (a -> a -> Bool) -> [Val] -> Bool
12:34:32 <swidgy> drguildo: is the notation using >>= clear for you, and only the "do" confusing, or is the former fuzzy as well?
12:34:33 <solrize_> glen, http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Dynamic.html
12:34:36 <lambdabot> http://tinyurl.com/fmmvy
12:34:40 <glen_quagmire> oh so, I have to do the pattern matching
12:34:52 <monochrom> Alright, keep working, and don't forget that to learn anything you should read 3 books 4 websites and 5 blogs. :)
12:34:56 <dons> ?users
12:34:57 <lambdabot> Maximum users seen in #haskell: 465, currently: 448 (96.3%), active: 15 (3.3%)
12:35:18 <augustss> glen_quagmire: well, there ar other ways, but pattern matching is good here
12:35:34 <augustss> glen_quagmire: btw, there are no interesting functions of type a->a->Bool
12:35:43 <drguildo> swidgy: i understand his definition of >>=. that is, the operator he defines using haskell code
12:36:04 <SamB> hmm, I'm getting a lot of TCP retransmissions from darcs.haskell.org...
12:36:15 <drguildo> swidgy: but his usage of it afterwards doesn't make sense in terms of my understanding of it
12:36:17 <Heffalump> I think it's known to be in trouble
12:36:20 <Heffalump> the machine, that is
12:36:32 <glen_quagmire> augustss: djin can't give a function for a -> a -> Bool ?
12:36:38 <SamB> well... I heard some kind of limitting was put in place to reduce bandwidth use.
12:36:47 <Heffalump> glen_quagmire: what would such a function do?
12:36:49 <oerjan> glen_quagmire: there is no way it could actually use the a
12:36:50 <Heffalump> SamB: ah.
12:36:54 <SamB> TCP retransmissions CAN'T be helping with that
12:37:07 <oerjan> @djinn a -> a -> Bool
12:37:07 <lambdabot> f _ _ = False
12:37:33 <drguildo> he defines >>= as taking a parser, a function which returns a parser, and "returning" (don't know the functional equivalent of that term) another parser
12:37:45 <oerjan> that and True, and a bit of seq for strictness perhaps, is all you can do
12:37:53 <glen_quagmire> oh djinn also usese readline (me on windows)
12:38:01 <SamB> I think it needs better QoS
12:38:09 <SamB> or traffic shaping...
12:38:33 <oerjan> @free f :: a -> a -> Bool
12:38:33 <lambdabot> f x = f (g x) . g
12:38:45 <drguildo> but in the bit after that, somehow it manages to keep track of the values that are passed between the parsers
12:38:45 <augustss> glen_quagmire: Maybe you want a function like (Ord a) => a->a->Bool?
12:39:01 <augustss> @djinn a->a->Bool
12:39:01 <lambdabot> f _ _ = False
12:39:31 <swidgy> drguildo: basically every function (in this context) returns a parser that holds the current state of the parse.  each parser can also hold a value, which is a sort of bucket that functions can put something into
12:39:37 <oerjan> now put g = const anything in that, and you get f x y = f anything anything
12:39:50 <drguildo> and he does return (f v1 v2 v3 vn) at the end of it all, and i have no idea what f is meant to do
12:40:05 <augustss> @djinn (Eq a) => a -> a -> Bool
12:40:05 <lambdabot> f = (==)
12:40:07 <monochrom> drguildo: Your current understand is ok.  The "returned" parser is indeed the two operand parsers' codes stitched together with data passing from the first to the second.
12:40:08 <swidgy> drguildo: the >>= passes this value from the result of the left hand parser into the right hand parser
12:40:44 <swidgy> drguildo: so >>= takes a parser on the left because whatever function was on the left returned it.  it takes a value on the right because it will pull that value out of the left side and pass it to the right
12:41:36 <Feuerbach> why "Unacceptable argument type in foreign declaration" can arise?
12:41:38 <swidgy> drguildo: the whole expression will result in another parser with another value in it
12:41:45 <drguildo> monochrom: well, the second operand to >>= is a function (called f) which is meant to return a parser but he never shows or explains this function which is confusing
12:42:32 <monochrom> The first parser is supposed to produce a value when run.  That value becomes the parameter to the second.
12:42:35 <swidgy> drguildo: the second function is defined as a lambda.  so in section 8.4, where he notes p1 >>= \v1 -> p2, the (\v1 -> p2) is that function
12:42:40 <drguildo> swidgy: i thought it took a function on the right?
12:43:01 <swidgy> the value in the parser returned from p1 is passed into the lambda and bound to v1
12:43:04 <augustss> Feuerbach: probably when you have used a type that is not a type in C
12:43:57 <monochrom> This chapter is tough because it teaches three things.  Parsing.  Monads.  Combining functions to make a greater one.
12:44:20 <swidgy> drguildo: sorry.  my wording was fuzzy... it takes a function that accepts a value.  correct
12:44:39 <drguildo> swidgy: i kinda understood that, it's mainly how it's keeping track of all the values returned by the intermediate parsers i don't get
12:45:00 <drguildo> the way he splits the lambdas over newlines confused me initially
12:45:03 <monochrom> Imperative programmers already know parsing and can learn monads (the vague idea anyway) on short order.  But they will have trouble with the third because they were trained to avoid doing it ever.
12:45:27 <swidgy> drguildo: simply remove the newlines when using the >>= notation
12:45:39 <drguildo> swidgy: yeah, that's what i figured hehe
12:45:43 <glen_quagmire> cool!   Djinn> class Ord a where (>) :: a -> a -> Bool     Djinn> bleh ? (Ord a) => a -> a -> Bool         bleh = (>)
12:46:09 <osfameron> monochrom: I disagree.  Combining functions seems very natural to me now whereas parsing is simple in concept but a pain in the arse in practise, and monads still make very little sense
12:46:30 <swidgy> drguildo: so if you remove the newlines, you'll need to note that the lambda expressions extend all the way to the right
12:46:48 <swidgy> drguildo: that's important.  that means that v1 is a bound variable all the way to the end
12:46:56 <drguildo> swidgy: towards the "return"?
12:47:01 <swidgy> drguildo: then when v2 is bound, it becomes available, along with v1, all the way to the end as well
12:47:17 <swidgy> drguildo: so when return is called, all variables v1 through vn are bound and available
12:47:20 <monochrom> osfameron: alright, I'm speaking statistically.
12:47:39 <swidgy> drguildo: because each subsequent lambda is embedded in the former lambda
12:47:44 <monochrom> and of course biased, anecdotal, unverified statistics :)
12:47:51 <osfameron> monochrom: fair enough, just one datapoint :-)
12:47:55 <osfameron> .win 38
12:48:03 <osfameron> bah
12:48:10 <monochrom> OTOH our very presence here is also self-selecting.
12:48:22 <drguildo> this is really confusing
12:48:40 <swidgy> drguildo: so in (p1 >>= \v1 -> expr), expr is EVERYTHING ELSE all the way too and including the return
12:48:47 <monochrom> We are here because we "get it" despite all our previous brainwashing.  But few people outside survived that brainwashing.
12:48:52 <drguildo> my head is in that state where you don't even know what you don't understand
12:49:01 <drguildo> so you can't even ask a question, ugh
12:49:49 <swidgy> drguildo: there's a lot of little pieces to the puzzle ;)  it just takes time.  i recall giving up on Haskell for a while, as it was overwhelming.  don't do that, and you'll be fine ;)
12:50:27 <drguildo> i've taken 2 or 3 breaks from this chapter and i keep coming back to it but don't really get anywhere
12:50:52 <monochrom> drguildo: Between the 1st and 2nd parsers there are two channels to be linked up.  One is the stream to be parsed - the 1st consumes some of it and the rest needs to be given to the 2nd.  The other is the 2nd wants an extra parameter from the 1st.  Both data channelling are done by >>=.
12:50:54 <drguildo> i mean breaks of like a week or two
12:51:13 <monochrom> Someone said >>= is plumbing.  Perhaps that helps you.
12:51:39 <swidgy> drguildo: for your current dillema, just note that "p1 >>= \v1 -> p2 >>= \v2 -> p3" becomes, with parentheses "p1 >>= (\v1 -> p2 >>= (\v2 -> p3))"
12:51:59 <swidgy> drguildo: pay attention to the scoping, and you'll see why v1 and v2 are both in scope at p3
12:53:21 <drguildo> hrmmm
12:53:38 * wli has had the best luck with the algebraic definition.
12:53:54 <monochrom> Remember that "return" is not a keyword.  Not a control-flow thing.  It's just another function.
12:54:13 <drguildo> i can't keep all this stuff he's expecting me to remember in my head at the same time
12:54:17 <drguildo> the author
12:54:29 <monochrom> It doesn't even mark the end of some scope.  It doesn't cause execution to jump to anywhere else.
12:54:39 <drguildo> yeah, i realise that
12:54:46 <drguildo> it's just the return he defined earlier on
12:54:56 <swidgy> yeah.... just rename it "unit"
12:55:01 <monochrom> If it happens to appear at the end of a do-block, it does a useful non-trivial thing.  Otherwise, it's nop.
12:55:04 <drguildo> which returns the value it's passed and the rest of the string to be parsed
12:55:08 <Frederick> Folks how can I argument that the semantics of the commands of an imperative language is a parcial function? O know that a vbad formed command is not represented in the "output" domain but how do I write it properly?
12:55:40 <wli> That is, Functor, a generalization of map, with fmap :: (a -> b) -> f a -> f b, a canonical injection return :: t -> m t, and a sort of unraveling / un-nesting operator join :: m (m t) -> m t
12:57:35 <monochrom> Frederick: IMO it's the same question as: "how can I argue that the semantics of gravity is space-time curvature?"
12:57:50 <drguildo> so what does that huge lambda expression evaluate to?
12:58:09 <drguildo> "p1 >>= \v1 -> p2 >>= \v2 -> p3"
12:58:22 <wli> Generalizing Hamilton-Jacobi equations so the induced metrics need not be positive definite?
12:58:27 <drguildo> if it even is a lambda
12:58:32 <swidgy> drguildo: whatever p3 evaluates to, which will be a parser
12:58:50 <drguildo> ok, so you pass it a string and what happens?
12:58:55 <swidgy> drguildo: in my example, i didn't do anything with v1 and v2.  in the book, he passes them to f
12:59:42 <swidgy> drguildo: if you don't use the values, then all you're doing is confirming that p1, p2, and p3 were each able to parse the string.  you get nothing of value as output, except knowing that it worked
12:59:48 <monochrom> I say that because my answer is: you can't.
12:59:50 <swidgy> drguildo: you get validation
13:00:26 <drguildo> what i'm asking is how it's evaluated
13:00:29 <swidgy> drguildo: if you "return" the values in some way, like he does with "return (f v1 v2 ... vn)", then you can do somethign with them
13:00:47 <drguildo> because i still don't understand what's going on
13:01:24 <swidgy> drguildo: well, here it gets complicated.  the whole thing, when fully evaluated, evaluates to a function.  this final function, if passed an input, will operate on it and return an output
13:01:46 <drguildo> actually, yes, thinking about it, it is a big lambda because the definition in the book says p >>= f is a lambda
13:01:50 <monochrom> The "semantics" is a model.  It simplifies reality.  It approximates reality in some aspects you care, and it misses reality in some aspects you don't care.  You can only give a few informal reasons (unprovable and unfalsifiable) why you think this model makes sense.  Then you can try to show that your model makes great predictions with little work.  Then you hope that other people like it.
13:02:12 <roconnor> @seen bjorn
13:02:12 <lambdabot> I haven't seen bjorn.
13:02:43 <swidgy> drguildo: right.  it's a strange thing at first.  that's why he has a "parse" function
13:02:59 <swidgy> drguildo: the "parse" function takes the parser (the p1 >>= stuff), and gives it an input
13:03:07 <swidgy> drguildo: it "runs" the final parser
13:03:36 <augustss> @seen Cale
13:03:36 <lambdabot> Cale is in #haskell-overflow, #haskell and #ghc. I last heard Cale speak 11h 16m 34s ago.
13:03:44 <monochrom> For example, "the semantics of a haskell data type is a CPO", true or false?
13:03:57 <monochrom> That depends on which "haskell" you have in mind.
13:04:24 <Frederick> monochrom Iu thibk I manbaged it :p
13:04:34 <drguildo> hmmm
13:04:47 <Cheery> back from sauna
13:04:50 <monochrom> The idealized "haskell", the theory, the mental model, yes, a type is a CPO there.
13:05:14 <drguildo> so v1, v2 etc are parameters to lambdas
13:05:33 <swidgy> drguildo: correct
13:05:34 <monochrom> The "haskell" actually running on my computer?  No way.  My computer is not a CPO.  My computer is a pile of crap.
13:05:37 <drguildo> which are passed to the lambdas by f?
13:05:44 <dmwit> Hiya, Cheery, welcome back!
13:05:44 <augustss> Does anyone know where the source for the Expr stuff in lambdabot is?
13:06:05 <dmwit> ?where expr
13:06:05 <lambdabot> http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
13:06:09 <drguildo> but f is one of the lambdas! my head hurts
13:06:13 <swidgy> drguildo: let's take "p1 >>= \v1 -> return v1" as a simple example
13:06:18 <wli> Simple reflection.
13:06:26 <dons> augustss: it's Twan's blog post, yeah.
13:06:28 <swidgy> drguildo: p1 is executed, which results in a parser with a value
13:06:28 <monochrom> (My computer is going to hate me for saying that. :) )
13:06:30 <augustss> dmwit, yes but is that what's running?
13:06:40 <swidgy> drguildo: that value is passed to "\v1 -> return v1" as v1
13:06:51 <dmwit> augustss: Oh, I don't think that's exactly what's running, no.
13:06:52 <swidgy> drguildo: that function is run, resulting in "return v1"
13:06:56 <monochrom> @vixen Are you a CPO or are you a pile of crap?
13:06:57 <lambdabot> yes, i am
13:07:00 <monochrom> hahahaha
13:07:09 <swidgy> drguildo: return places v1 into a new parser object, which is the final result of the expression
13:07:45 <augustss> monochrom: you run on a pile of crap?  i have to make do with FSM
13:07:53 <dons> augustss: the actual code, http://code.haskell.org/lambdabot/scripts/SimpleReflect.hs
13:07:55 <monochrom> haha
13:08:07 <drguildo> swidgy: i think i understand
13:08:29 <swidgy> drguildo: the book does the same thing, only layered several times.  return (f v1 v2 ... vn) is the last thing to run, after all of the v's have been bound
13:08:49 <swidgy> drguildo: then f returns a value, and return places that value into a parser
13:09:54 <swidgy> drguildo: so that whole nasty thing just ends up resulting in a parser.  only a new parser that combines the effects of p1..pn together
13:10:11 <dcoutts> bringert: cheers
13:10:18 <dcoutts> dons: ping :-)
13:10:27 * dcoutts is feeling very pleased with himself
13:10:35 <bringert> oh yeah, I wanna ping dons too
13:10:40 <bringert> good work dcoutts
13:10:47 <dcoutts> bringert: thanks :-)
13:10:56 <drguildo> i thought return returned [(a, String)]
13:11:56 <swidgy> drguildo: so that expression we're talking about returns a parser.  but it's generic.  it's just a function.  it still needs input!  you can then pass that combined parser, and a string to parse, to the "parse" function, to get the "[(a, String)]" as output
13:12:01 <Jaak> isn't parser of a a String -> [(a, String)]
13:12:17 <dons> dcoutts: pong!
13:12:32 <Jaak> so return x = \s -> [(x, s)]
13:12:32 <swidgy> drguildo: so that expression we're talking about returns a parser.  but it's generic.  it's just a function.  it still needs input!  you can then pass that combined parser, and a string to parse, to the "parse" function, to get the "[(a, String)]" as output
13:12:35 <swidgy> oops ;)
13:12:42 <swidgy> double vision
13:12:57 <dcoutts> dons: did you get a chance to read the note I sent earlier, any comments?
13:13:04 <dons> dcoutts: thinking about it :)
13:13:12 <drguildo> that's currying, right?
13:13:17 <dons> but yeah, i think we can host it. esp. after july once we're in the big new building
13:13:21 <dcoutts> dons: great, I think SyntaxNinja had very tentatively offered hosting
13:13:22 <swidgy> drguildo: note that "parse" has type "Parser a -> String -> [(a, String)]"
13:13:34 <swidgy> drguildo: so if you give it a parser, you still have "String -> [(a, String)]"
13:13:35 <dons> dcoutts: right, that's my understanding after talking to Paul H.
13:13:48 <dons> dcoutts: 1U is fine, and we'll have as many IPs as we need in the new office.
13:13:54 <dcoutts> dons: bringert is also investigating the possibility of hosting with the multi-core group at Chalmers
13:13:58 <swidgy> drguildo: given a string, you finally get [(a, String)]
13:14:07 <dons> dcoutts: ok. wherever is most convenient
13:14:16 <dcoutts> dons: ok, that sounds quite promising
13:14:19 <dons> dcoutts: the CSE/UNSW group might also be able to, if it came to it.
13:14:35 <drguildo> swidgy: so you pass parse that massive lambda and it returns a curries function that takes a string and gives you the tuple-list?
13:14:41 <drguildo> *curries
13:14:44 <swidgy> drguildo: yes
13:14:45 <dcoutts> dons: all of them can have accounts of course, we want to open it like community.h.o to everyone to do research and general hacking
13:14:45 <drguildo> *curried
13:14:46 <drguildo> urgh
13:15:04 <swidgy> drguildo: and the beauty is, if you partially apply the parser, you end up with a function that be run many times on different strings
13:15:09 <swidgy> drguildo: with the same parser
13:15:44 <dcoutts> dons: we're not sure with the Chalmers group, if we host there we may have to share with non-haskell jobs, so hosting with you may well be the best bet
13:15:54 <augustss> dons: thanks!  I have a small, gruesome hack that allows you to print functions as well with Expr
13:16:03 <drguildo> cool
13:20:23 <dons> dcoutts: right, i think we can accomodate that
13:20:59 <drguildo> i think i understand now
13:21:02 <dcoutts> dons: cool
13:22:00 <swidgy> drguildo: glad we could help.  when you get to monads, you'll have a better idea of some of the internals as well
13:22:10 <dons> dcoutts: now we have to find a good candidate
13:22:45 <dcoutts> dons: right, I'm just drafting an announcement, I'll send it round
13:23:00 <dcoutts> dons: to announce the project and invite student applications
13:23:06 <hpaste>  glen_quagmire pasted "why do I get this type error?" at http://hpaste.org/6238
13:23:44 <dons> dcoutts: great. we'll really want to target what, phd-level compiler backend hackers with haskell experience?
13:23:44 <drguildo> i'm going to go and think about this some more
13:23:49 <drguildo> thanks for your help
13:24:09 <dons> dcoutts: nr's students, et al.
13:24:10 <glguy> glen_quagmire: you need to write the a and b in the first line with fromIntegral
13:24:22 <glguy> glen_quagmire: since you are using op as a function on Floats
13:24:32 <dcoutts> dons: right, MSc and above, the funding level is not insubstantial so we can request the best
13:24:42 <glguy> glen_quagmire: if you want 'op' to be more polymorphic than that, you'll have to specify
13:24:44 <glen_quagmire> glguy: aren't I using op as function on Num class?
13:24:48 <dons> and its important for the project to suceed as well
13:24:53 <dons> we'll need some good supervision
13:25:02 <glguy> glen_quagmire: a single instance of Num is chosen when that functio nis used
13:25:28 <glen_quagmire> glguy: how can I specify to make op be more polymorphic?
13:26:05 <glguy> compareOp :: (forall a. Num a => (a -> a -> Bool)) -> [Val] -> Bool
13:26:28 <dcoutts> dons: indeed, I'm hoping JaffaCake could mentor :-)
13:26:36 <dons> right.
13:26:45 <glguy> glen_quagmire: that requires Rank2Types
13:27:03 <dcoutts> dons: or anyone else suitably qualified, since I proposed it I'm prepared to be backup
13:27:04 <augustss> glen_quagmire: what glguy said, but you can't pass, e.g., < to compareOp
13:28:07 <glen_quagmire> i think i have 2 choises:  make all numbers Double or Integer and use ==, <..    or have different operators:  int== float== ...etc
13:28:32 <augustss> glen_quagmire: you can make your approach work
13:28:34 <glguy> glen_quagmire: you compare 'op' operates on Num while (<) operates on Ord
13:29:32 <glen_quagmire> do I still need Rank2Types for that?
13:30:30 <glguy> Do you want to use 'op' on different types inside compareOp?
13:31:37 <glen_quagmire> 1 == 2.0       I would want 1 to be Float
13:32:10 <glen_quagmire> 1 `op` 2.0    .. maybe my parsing is wrong.  parse 1 => Int 1,  parse 1.0 => Float 1.0
13:32:40 <glguy> > 1 == 2.0
13:32:41 <lambdabot>  False
13:33:00 <glguy> 1 is parsed as the same type as 2.0
13:33:05 <glen_quagmire> haskell compiler somehow converts 1 to Double i think
13:33:17 <augustss> glen_quagmire: a different approach (without the need for rank2 polymorphism) is to use compare inside compareOp.  And instead of an op you pass a lit of the acceptable results from compare.
13:36:22 <roconnor> > fromInteger 1 == fromFloat 2.0
13:36:22 <lambdabot>   Not in scope: `fromFloat'
13:36:33 <roconnor> > fromInteger 1 == 2.0
13:36:34 <lambdabot>  False
13:36:46 <roconnor> @type \l -> fromInteger l == 2.0
13:36:47 <lambdabot> Integer -> Bool
13:37:08 <roconnor> glguy: 1 is parsed as fromInteger 1
13:37:33 <roconnor> glguy: defaulting is used to make 1 == 1 unambigous
13:37:39 <glguy> roconnor: yup
13:38:30 <newsham> hi
13:40:07 <oerjan> > fromRational 2.0
13:40:07 <lambdabot>  2.0
13:40:59 <augustss> 2.0 :: Rational
13:41:05 <augustss> > 2.0 :: Rational
13:41:06 <lambdabot>  2%1
13:41:28 <augustss> > 2312312.787126387123681e121 :: Rational
13:41:29 <lambdabot>  2312312787126387123681000000000000000000000000000000000000000000000000000000...
13:43:07 <glen_quagmire> ordBool target x = case x of   target {- EQ, LT, ... -} -> True ; otherwise -> False
13:43:28 <glen_quagmire> is there a way to do that?  case target masks the parameter target
13:43:50 <augustss> x `elem` target ?
13:44:00 <glen_quagmire> hah thanks
13:44:31 <glen_quagmire> ah that's why you said "pass a list of acceptable.."
13:44:40 <augustss> yep
13:52:57 <akamaus> greetings. Last day I was fighting with my happs based toy webapp which crashes while serving some clients.
13:54:06 <mae> what is the crash
13:54:26 <mae> and the whole app crashes or you mean the page has an error
13:54:30 <akamaus> getNameInfo: does not exist (Temporary failure in name resolution)
13:54:37 <akamaus> i mean process terminates
13:54:55 <akamaus> i believe there is a bug in network library concerning resolution of ipv6 addresses
13:55:51 <mae> ah yes i remember this from yesterday
13:55:52 <mae> what a pita
13:56:20 <akamaus> this happens then getNameInfo called with SockAddrInet6. I tested it
13:56:21 <mae> where does your app make name resolutions?
13:56:37 <akamaus> i dont know )
13:56:49 <akamaus> mine code certainly doent
13:57:33 <akamaus> is there a way to get function call stack or something like this?
13:58:47 <mae> can you hpaste the error output
13:59:19 <akamaus> at first i suspected show instance for SockAddr but i fixed unwrapped call to getNameInfo, but app still crashes
13:59:35 <mae> ok here is what i'm wondering
13:59:42 <mae> why the heck is happs making a name resolution
13:59:47 <akamaus> grepping through happs sources shows no getNameInfo calls
14:00:27 <mae> what ip are you binding your app too
14:00:42 <akamaus> i use debugFilter, it dumps some logs. hostnames are present there
14:01:02 <mae> hostnames of clientS?
14:01:13 <akamaus> ipv4, default settings
14:01:30 <mae> akamaus: what hostnames are being resolved, is what i'm asking
14:02:07 <mae> also, what platform are you on
14:02:36 <akamaus> > hostnames of clientS? particular one that fails is one from gprs provider, i dont know exactely, since app fails before dumping logs. Should i try to sniff it?
14:02:36 <lambdabot>  Parse error at "of" (column 11)
14:03:18 <akamaus> app runs on OpenVZ vps, it was build with ghc-6.8.2 on my desctop machine under gentoo linux
14:03:19 <mae> akamaus: no i don't think so, but in the logs it shows the clients hostnames right?
14:03:56 <akamaus> it crashes before dumping logs
14:06:16 <mae> this is in Listen.hs
14:06:17 <mae>   let msg = "\nIPV6 is not supported yet. \nLikely you made a localhost request \n"++
14:06:18 <mae>             "and your machine resolved localhost to an IPv6 address. \n"++
14:06:34 <mae> so ipv6 is not supported first of all
14:06:45 <mae> maybe you could proxy it through apache to handle ipv6?
14:06:46 <paczesiowa> does gtk2hs need iconv under windows? I get this error "Loading package glib-0.9.12.1 ... can't load .so/.DLL for: iconv (addDLL: unknown error)" and I have no idea what to fix it for windows
14:07:55 <dcoutts> paczesiowa: the gtk2hs installed does install the iconv.dll and adjusts the user's %PATH% so compiled programs can find it and dozens of other gtk dlls
14:08:16 <glen_quagmire> data Val = Int Integer | Float Double | Str String | ...    is there a meaningful function of type   Val -> a    where a can be Integer, Double, String...etc ?
14:08:16 <akamaus> mae: are there any chances it tries to resolve address before testing this?
14:08:44 <dcoutts> paczesiowa: so if you're using a command window that was opened before you ran the installer then the %PATH% will not have updated, try opening a new command window
14:09:02 <glen_quagmire> no that doesn't make sense. I think i need unpackInt (Int i) = i     unpackFloat (Float i) = i .. etc
14:09:21 <oerjan> glen_quagmire: define it using record notation
14:09:45 <oerjan> data Val = Int {unpackInt :: Integer} | ...
14:09:50 <paczesiowa> dcoutts: thanks, that did it
14:10:02 <dcoutts> paczesiowa: great
14:10:03 <glen_quagmire> oerjan: niffy!
14:11:48 <dmwit> Isn't amazing how it doesn't seem like gruntwork to write it in record notation, but it *does* seem like gruntwork to write out the actual functions?
14:12:16 <mrd> does anyone use Yi and have an interesting configuration to share?
14:12:19 <dmwit> I mean, the actual amount of characters used is not so different...
14:13:51 <mae> um
14:13:55 <mae> because its not "automagical" ?
14:14:04 <mae> ; )
14:16:49 <dmwit> Can somebody take a look at this problem? http://fudge.fit.edu/Problems/Archive/Structural_Equivalence
14:16:50 <lambdabot> Title: (*Fudge).Problems["Structural Equivalence"]
14:17:08 <dmwit> That looks like you have to solve the problem of CFG equivalence to solve this problem.
14:17:11 <dmwit> Is that true?
14:18:25 <monochrom> First of all I think the page has much html or css problem.  Why must it hard-code a width so that I cannot use a slightly narrower window for my browser?
14:18:45 <dmwit> Yeah, I have a lot of issues with the presentation, too.
14:18:47 <monochrom> Why do people think that everyone is obliged to use full screen for browsers?
14:18:54 <akamaus> mae: i got ip of client. it's ipv4 in the end. Probably there were errors in my tracing code.  resolveip utility returns error for it
14:18:57 <dmwit> I've filed bug after bug on their bug report thing, but nothing happens. =/
14:19:31 <dmwit> Light text on a light background is not so great, either, for example.
14:19:37 <monochrom> They just think everyone has quad-head 12800x10240 displays.
14:20:07 <monochrom> One day I'll make one such ridiculously huge page to parode them.
14:20:15 <mae> akamaus: i'm thinking what is most likely happening is that happs is doing a reverse lookup of an ip address and then in this case it didn't resolve
14:20:23 <mae> but that is just a WAG (wild-assed-guess
14:20:42 <idnar> @src (&&&)
14:20:42 <lambdabot> f &&& g = arr (\b -> (b,b)) >>> f *** g
14:21:44 <MyCatVerbs> @src (***)
14:21:44 <lambdabot> f *** g = first f >>> second g
14:21:51 <monochrom> Yes, seems like CFG parsing to AST, then recursive equality.
14:21:54 <MyCatVerbs> @src second
14:21:54 <lambdabot> Source not found. Just try something else.
14:21:57 <Spockz> @src >>>
14:21:57 <lambdabot> Source not found. Sorry.
14:22:04 <Spockz> @src (>>>)
14:22:04 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
14:22:12 <MyCatVerbs> Spockz: >>> is arrow composition.
14:22:13 <dmwit> monochrom: No, look again... check in particular the "R S W Z" equivalence.
14:22:28 <dmwit> monochrom: Plain old recursive equivalence will get into an infinite loop
14:22:32 <Spockz> MyCatVerbs: we don't have covered that yet
14:23:05 <dmwit> monochrom: I think the type declarations are essentially a CFG (i.e. "type X = struct(A B)" is "X -> AB" in CFG-land).
14:23:08 <monochrom> Oh fun, recursion.
14:24:00 <dmwit> And I *thought* I remembered somewhere that equivalence of CFG's was impossible in general.
14:24:14 <oerjan> dmwit: yes
14:24:16 <dmwit> s/impossible/undecidable/
14:24:37 <dmwit> Although... hm.
14:25:14 <dmwit> These aren't quite CFG's, because each symbol has exactly one production (i.e. there is no "A -> B | C" equivalent).
14:25:19 <dmwit> I wonder if that helps...
14:25:28 <SamB> it won't hurt
14:25:49 <gwern> hmm. I'm being pushed out of the whatsnew in hackage! i better upload some more packages
14:25:54 * gwern uploads hsntp
14:26:10 <monochrom> R = int int R.  S = int S.  I am not sure why they are equivalent.
14:26:27 <akamaus> mae: probably yes, but it hardly can be called a correct behavior to crash on first WAG, imho. What can be done with it?
14:27:39 <dmwit> monochrom: The description of "equivalence" in the problem is highly flawed, but it seems to me that what they mean is, the types are equivalent if the string of types produced are equivalent.
14:28:06 <dmwit> monochrom: So R = [int,int..] and S = [int,int..] => R is equivalent to S.
14:28:15 <bringert> dcoutts: ok, it seems like galois has competition for the hosting, see email
14:28:26 <smg> swap :: (Show a,b) => (a,b) -> (b,a) fails, how can i specify it?
14:28:33 <monochrom> I think that's too much fudging.  (Pun intended. :) )
14:28:41 <bringert> swap: why Show?
14:28:51 <dmwit> monochrom: I agree. =)
14:28:56 <smg> bringert: i just want to know how i can have 2 arguments before the =>
14:28:59 <smg> is that possible?
14:29:11 <dmwit> monochrom: For example, by the definition they give, "A" and "B" would not be equivalent, even though "type A = B"!
14:29:33 <dmwit> smg: (Show a, Show b) => ...
14:29:41 <bringert> smg: the things before => aren't arguments, it's a context
14:29:41 <bringert> smg: but yes, you can have more than one
14:29:55 <bringert> smg: like dmwit said
14:30:09 <smg> ah okay
14:30:13 <smg> bringert: thank you
14:30:29 <dmwit> smg: I doubt you really want those constraints on swap, though. ;-)
14:30:49 <bringert> hmm, I should modify that, it's not two *contexts*, it's a context with two constraints
14:30:59 <bringert> just to be anal
14:31:32 <dmwit> Be nice to yourself, call it pedantic. ;-)
14:31:55 <oerjan> IANAL
14:35:11 <dons> haskell weekly news, http://reddit.com/info/6bg2z/comments/
14:35:28 <monochrom> onoes, it's moved to reddit!
14:35:51 <smg> bringert: maybe you add "class" :P
14:35:51 <monochrom> (it's only a matter of time before it's also on diggs, facebook, youtube, ...)
14:35:57 <mae> akamaus: i agree that that behavior sucks ; )
14:36:18 <mae> akamaus: it should be wrapped in an exception at the least, but right now i was just trying to troubleshoot the problem first and foremost
14:38:13 <akamaus> mae: excuse me, i just misinterpreted your previous answer. And meaning of WAG ;)
14:38:15 <therp> who were recently discussing md5/sha1 security here?
14:38:26 <dons> also, summer of code, http://reddit.com/info/6bg3e/comments/
14:38:41 <dons> therp: there's been some talk about unifying the openssl wrappers to shaN and md5?
14:39:14 <therp> ah sorry, I misunderstood the concept of this page http://crackfoo.nicenamecrew.com/ -- it doesn't seem to invert things. it's just an inverted lookup table.. foo
14:39:25 <dcoutts> bringert: cool, I'm writing to them with more details
14:40:17 <bringert> dcoutts: I'm going to e-mail the local IT guy who knows if we have rackspace etc
14:40:25 <dcoutts> bringert: ok
14:44:19 <dons> dcoutts: re. getting recruits, i wonder if we can contact some of the compiler research groups directly
14:44:27 <dons> to get the absolute best candidates
14:44:39 <dons> (do we have *anyone* in mind?)
14:44:40 <Heffalump> what are you recruiting for?
14:44:47 <dcoutts> dons: sure, we should disseminate the announcement as widely as possible
14:44:47 <gwern> @seen shapr
14:44:47 <lambdabot> I saw shapr leaving #haskell, #scannedinavian and #haskell-blah 1d 19h 29m 38s ago, and .
14:44:49 <Heffalump> SoC?
14:45:10 <dcoutts> Heffalump: a top secret project to take over the world :-)
14:45:19 <Heffalump> cool!
14:45:23 <dcoutts> which is obviously why we're discussing it here
14:45:32 <Heffalump> SoC is old hat, taking over the world is where it's at
14:45:36 <dons> involving a particular hardware manufacturer of multicore machines of the risc flavour
14:46:01 <Heffalump> IBM? Sun?
14:46:17 <dcoutts> Heffalump: I've been negotiating with Sun to do a joint project, to fund a student to do some cool stuff with GHC and multi-core Sparc
14:46:29 <Heffalump> wow, cool!
14:46:32 <dcoutts> yeah
14:46:34 <dons> dcoutts has gone all corporate :)
14:46:46 <Heffalump> this coming from you...
14:46:53 <dcoutts> they've said "Let's go make it happen."
14:47:23 <dcoutts> Heffalump: I contacted people at Sun, yes.
14:47:26 <dcoutts> dons: heh heh :-)
14:47:30 <Heffalump> so the student might be anywhere?
14:47:38 <dcoutts> right, anyone, it's not me! :-)
14:47:50 <Heffalump> I meant "this coming from you..." as in dons talking about you being corporate while he works for Galois
14:47:53 <Heffalump> any*where*.
14:48:01 <dcoutts> it's really supposed to be a joint project between the Haskell.org community and Sun
14:48:10 <dcoutts> with lasting benefits for both sides
14:48:26 <dcoutts> so I'm not representing any company in this
14:48:28 <dons> Heffalump: hehe
14:48:32 <Heffalump> what'd it be, a whole PhD or a short-term thing?
14:48:45 <dcoutts> three month summer project, like GSoC but paid better
14:48:58 * gwern is mentioned 31 times in the current HWN
14:49:06 <bringert> dcoutts: or longer, but paid the same per month
14:49:06 <dons> gwern++
14:49:13 <dcoutts> if it goes well there might be follow on projects with more funding available
14:49:20 <dcoutts> bringert: true, that's possible
14:49:54 <dons> dcoutts: did you know the ia64 port of ghc was funded by intel (as part of a larger effort to get compiler support for itanium).
14:49:56 <gwern> ...which is the same number as the last HWN. spooky!
14:50:02 <dcoutts> dons: I didn't
14:50:02 <dons> we've got precedent in this area -- i'd forgotten
14:50:15 <dcoutts> interesting, who worked on that? how was it organised?
14:50:23 <gwern> dons: you ruined everything, you know. it would've been 32 since I uploaded hsntp not terribly long after you apparently started writing the hwn
14:50:31 <dcoutts> dons: I'm just following the GSoC model since that's what I'm familiar with
14:50:35 <shteou> Any people here who've played with YHC bytecode?
14:50:52 <dons> the "gelato consortium" -- intel, hp, et al, funded the linux port , and a bunch of OS guys to work with itanium back in the early 2000s.
14:50:54 <shteou> Have just been messing with something in particular and it turns out constTables aren't as constant as I thought :/
14:51:05 <dons> one of those kernel guys was at unsw, and did the ghc port
14:51:54 <dcoutts> dons: I see
14:57:49 <idnar> @where fptools
14:57:49 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/building/sec-cvs.html
14:58:00 <idnar> hmm, that URL is broken
15:00:42 <dons> http://www.haskell.org/ghc/docs/latest/html/
15:00:42 <lambdabot> Title: GHC Documentation
15:00:51 <dons> ?where+ fptools http://www.haskell.org/ghc/docs/latest/html/
15:00:51 <lambdabot> It is forever etched in my memory.
15:03:06 <glen_quagmire> http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/
15:03:09 <lambdabot> Title: fptools/
15:03:18 <RayNbow> hey dons, I've been wondering... for how long have you been programming in Haskell? :)
15:04:12 <glen_quagmire> is this haskell version of asl ?
15:04:40 <olsner> glen_quagmire: that'd be "what's your monad" :P
15:04:51 <dons> RayNbow: since 1999, supposedly :) but i had 2.5 years off
15:06:25 <RayNbow> dons: ah... just wondering because of that "Teach yourself programming in 10 years" article that was posted a while ago on reddit
15:07:00 <RayNbow> I have been programming for a while though (started in Basic so I've been mutilated for life :p), but less than 2 or 3 years in Haskell
15:07:02 <glen_quagmire> olsner: what's your monad?
15:07:28 <RayNbow> (and I didn't really use Haskell a lot in the beginning, it was just a mandatory course for me back then :p)
15:07:33 <idnar> I guess I'm confused, what is fptools?
15:07:46 <dons> idnar: it was the old name for the collected haskell base libraries and compilers
15:07:54 <dons> it doesn't really exist anymore
15:07:56 <idnar> ah
15:08:04 <idnar> I'm trying to set up lambdabot here
15:08:17 <dons> oh, you dont' need to worry about that plugin
15:08:56 <oerjan> @list fptools
15:08:56 <lambdabot> dummy provides: eval choose id read show dummy bug get-shapr faq paste learn map shootout botsnack thanks thx thank you wiki oldwiki docs source fptools hackage
15:09:03 <oerjan> @help fptools
15:09:03 <lambdabot> fptools <lib>. Lookup url of ghc base library modules
15:09:46 <paczesiowa> @src Point
15:09:46 <lambdabot> Source not found. My brain just exploded
15:10:17 <oerjan> @hoogle Point
15:10:17 <lambdabot> GHC.Exts.breakpoint :: a -> a
15:10:17 <lambdabot> GHC.Exts.breakpointCond :: Bool -> a -> a
15:10:26 <oerjan> no such thing apparently
15:10:49 <paczesiowa> that's what makes it scary, because it works:/
15:10:59 <oerjan> where?
15:11:00 <gwern> '/usr/lib/gcc/x86_64-pc-linux-gnu/4.2.3/../../../../x86_64-pc-linux-gnu/bin/ld: cannot find -lfltk' <-- any ideas? it's strange, extra-libraries: fltk doesn't help though the FFI library files compile fine with extra-libraries: fltk
15:11:28 <paczesiowa> I think, maybe gtk2hs exports it
15:11:59 <paczesiowa> hoogle indexes gtk2hs?
15:12:15 <oerjan> no idea
15:12:16 <dcoutts> paczesiowa: there's a separate gtk2hs hoogle
15:12:57 <oerjan> @docs List
15:12:57 <lambdabot> List not available
15:13:00 <paczesiowa> dcoutts: I know, why is it seperate hoogle?
15:13:10 <oerjan> @docs System.Time
15:13:10 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/4/System-Time.html
15:13:18 <idnar> hmm, no libghc6-zlib-dev in debian
15:13:26 <dcoutts> paczesiowa: architecture issues in hoogle 3, it'll be integrated in hoogle 4
15:13:33 <oerjan>  @docs still broken
15:15:16 <idnar> ugh, and libghc6-plugins-dev is out of date
15:18:01 <SyntaxNinja> glguy: dude, I haven't seen any commits all morning. what gives?
15:19:06 <paczesiowa> dcoutts: bless you
15:20:39 <idnar> hrm, pulling from http://darcs.haskell.org/cabal seems really slow
15:20:41 <lambdabot> Title: Index of /cabal
15:21:20 <dcoutts> idnar: the server is applying throttling atm
15:21:28 <idnar> ah, I see
15:22:39 <dons> SyntaxNinja: hah
15:22:47 <gwern> dcoutts: is messing aorund with include-dirs: the right way to fix an error like '/usr/lib/gcc/x86_64-pc-linux-gnu/4.2.3/../../../../x86_64-pc-linux-gnu/bin/ld: cannot find -lfltk'?
15:22:52 <SyntaxNinja> y0 dons
15:23:00 * dons notes is ridiculously sunny
15:23:17 <SyntaxNinja> dons: getting in through your blackened blinds and everything?
15:23:36 <SyntaxNinja> dons: sof dragged me around for 50 miles yesterday
15:23:47 <dons> wow. sore today, or feeling ok?
15:23:52 <SyntaxNinja> feeling ok.
15:24:04 <dons> cool
15:24:22 <SyntaxNinja> so it seems that either javascript is dumb or I am, since I can't figure out how to #include a .js file within another .js file
15:24:27 <dcoutts> hia SyntaxNinja :-)
15:24:31 <SyntaxNinja> heya duncan
15:24:36 <newsham> normal js doesnt have includes.
15:24:42 <newsham> you can include multiple js's from your html
15:25:11 <SyntaxNinja> I was thinking it would be really cool to have a Haskell Mashup Framework that just had bindings for JSON and a bunch of "standard" web apps like google maps, del.icio.us, whatever.
15:25:13 <newsham> nothing a syntax ninja cant fix :)
15:25:25 <SyntaxNinja> newsham: oh whew. I thought I was going nuts.
15:25:43 <SyntaxNinja> newsham: any insight as to why this limitation? it seems like hierarchical includes are totally broken by this model
15:26:03 <dons> SyntaxNinja: was thinking the same thing. did some json/delicious stuff yesterday. there's a few of these now, in isolation (gravatars, sparklines, google charts, delicious)
15:26:19 <newsham> no, but from my point of view, its prob nice having all included javascripts explicit in a web page
15:26:25 <newsham> since js comes with security considerations
15:26:34 <dons> json "ffi" stuff is pretty easy now, too.
15:26:47 <SyntaxNinja> dons: yeah, so bring them together in a package and maybe standardize some of the surrounding infrastructure
15:26:56 <newsham> if you use flex (flash) you get includes... thats also based on ecma script (although slightly not the same)
15:27:19 <SyntaxNinja> newsham: yeah, I can see that.  but it feels like, well A includes B and B includes C, so what do you have to do? Flatten it by making A include both B and C.  Strange.
15:27:30 <dons> SyntaxNinja: i could imagine a json "ffi" guide at some point. they're all so similar, and use their own suite of libs, similar to the C ffi
15:27:35 <newsham> include all deps :)
15:27:41 <dons> except using network stuff, md5s, json, utf8
15:27:48 <newsham> sort of like linking against all deps, no? :)
15:27:57 <SyntaxNinja> newsham: yeah.
15:30:31 <swidgy> i suppose you could have a "load" function that did an xmlhttprequest and eval of the dependency
15:30:37 <Big_Red> anyone know a good c progamming channel
15:30:57 <Big_Red> i don't want to plague you with my ineptness in a nonhaskell language
15:31:57 <stevan> ##c?
15:31:58 <newsham> efnet #c used to be pretty good
15:32:05 <newsham> havent been in a long time
15:34:52 <jeffz> Big_Red: if you don't have a copy of k&r second edition, use this http://publications.gbdirect.co.uk/c_book
15:34:53 <lambdabot> Title: The C Book - Table of Contents
15:37:44 <RayNbow> > let cstyle xs = map (xs!!)
15:37:44 <lambdabot>  Parse error at end of input
15:37:46 <RayNbow> hmm
15:37:52 <RayNbow> @define cstyle xs = map (xs!!)
15:37:53 <lambdabot> Undefined.
15:38:05 <resiak> dons: perhaps HWN should have a 'packages uploaded by gwern' section :)
15:38:17 <RayNbow> @help
15:38:17 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
15:38:45 <RayNbow> @let cstyle xs = map (xs!!)
15:38:45 <lambdabot> Defined.
15:38:58 <RayNbow> > let a = cstyle [1,2,3,4]   in  a[0]
15:38:59 <lambdabot>  [1]
15:39:07 <RayNbow> we can now lure in C/Java/C#/etc programmers :p
15:39:39 <newsham> > (cstyle [1,2,3,4,9,2,3,1])[3..5]
15:39:40 <lambdabot>  [4,9,2]
15:39:49 <newsham> slices
15:39:55 <RayNbow> cool huh? :)
15:45:07 <Big_Red> fail - noone replied on ##c
15:45:18 <Big_Red> i don't think that anyone could actually hear me or something...
15:45:23 <newsham> > let (!!>) x y = liftM (x !!) y in [1,2,3,4,9,2,3,1] !!> [3..5]
15:45:24 <lambdabot>  [4,9,2]
15:45:38 <newsham> i want binop modifiers :(
15:45:38 <jeffz> Big_Red: what was your question?
15:45:49 <Big_Red> oh trying to do matrix manipulation in c
15:45:54 <jeffz> oh?
15:45:56 * jeffz runs away.
15:45:57 <Big_Red> i'm basically converting some fortran code to
15:45:58 <Big_Red> c
15:46:07 <Big_Red> and default is like for loop
15:46:20 <Big_Red> but there aren't any of the easy to use things like haskell's "length" function
15:46:39 <Big_Red> suddenly tricky to stop thinking in functions and think imperatively
15:47:33 <newsham> length of what?
15:47:39 <jeffz> Big_Red: so, what was your question?
15:59:50 <augustss> @users
15:59:51 <lambdabot> Maximum users seen in #haskell: 465, currently: 429 (92.3%), active: 12 (2.8%)
16:02:20 <gwern> 'The most obvious problem Erlang has for applications is sucky string handling. In Erlang, there is no string type, strings are just a list of integers, each integer being an encoded character value in the string. '
16:02:25 <gwern> 'It's not all bad. It has the benefit of taking the same built-in list operations, libraries and optimizations reusing them for string processing. But it also means you can't distinguish easily at runtime between a string and a list, and especially between a string and a list of integers. '
16:03:12 <lament> sounds like a critical flaw!
16:03:17 * lament throws erlang out of the window
16:04:49 <tromp> > 3%5
16:04:50 <lambdabot>  3%5
16:05:22 <tromp> > 5 `mod`3
16:05:23 <lambdabot>  2
16:09:10 <augustss> is Cale the lambdabot maintainer now?
16:09:42 <gwern> think so
16:09:44 <tibbe> @seen dcoutts
16:09:44 <lambdabot> dcoutts is in #gentoo-haskell, #haskell, #ghc, #haskell-overflow and #haskell-soc. I last heard dcoutts speak 45m 17s ago.
16:09:50 <dcoutts> hia tibbe
16:10:09 <tibbe> dcoutts: hey, how's your student's unicode bytestring work coming?
16:11:14 <dcoutts> tibbe: he's got two weeks of exams which started two days ago, I expect we'll get started after that
16:11:32 <olsner> I want to write a monad transformer based on a combination of StateT and WriterT - why can't I use newtype-deriving for Functor, Monad, MonadWriter, MonadState?
16:11:44 <dcoutts> tibbe: ask sioraiocht how the exams are going :-)
16:11:51 <dcoutts> @seen sioraiocht
16:11:51 <lambdabot> sioraiocht is in #scala, #haskell-blah and #haskell. I don't know when sioraiocht last spoke.
16:11:53 <dons> augustss: yeah
16:12:45 <hpaste>  olsner pasted "GeneralizedNewtypeDeriving" at http://hpaste.org/6243
16:12:58 <tibbe> dcoutts: heh
16:13:02 <BMeph> > 4 * (3%5)
16:13:02 <lambdabot>  12%5
16:13:06 <olsner> what does it mean for the eta-reduction property not to hold?
16:13:38 <gwern> it means the Great Old Ones are returning
16:13:58 <gwern> Ia! Ia! Cthulu f'thagn wump'l Ry'leh!
16:14:25 <augustss> olsner: perhaps you should try the ghc manual?
16:14:50 <olsner> oh great, you need a *manual* to use haskell nowadays? :P
16:15:11 <idnar> what about an automatic?
16:15:11 <newsham> i think he means you should manually invoke ghc
16:16:13 <augustss> a manual is more fun to drive
16:16:46 <tromp> > 4-1`mod`2
16:16:47 <lambdabot>  3
16:17:28 <Toxaris> olsner: I think the problem is the (History a)
16:17:37 <newsham> august: is that why its more fun to commute?
16:17:54 <olsner> woah! that actually did it
16:18:22 <olsner> but... how? why?
16:18:26 <Toxaris> olsner: a will change all the time (with every >>=), but the state will be the same, so that's just wrong
16:18:43 <gwern> bah. what extension do we use for a line like '    I# size# → case newPinnedByteArray# size# s of '? UnboxedTuples doesn't seem to be cutting the mustard
16:18:43 <olsner> ah, I'm mixing things up actually
16:19:07 <olsner> the History type obviously shouldn't depend on the return types, but like on the writer monoid
16:19:38 <Toxaris> olsner: now about eta-reduction: do you know what it is? (do you care?)
16:19:42 <dons> gwern: -fglasgow-exts
16:19:49 <tromp> :t fromInteger
16:19:50 <lambdabot> forall a. (Num a) => Integer -> a
16:19:54 <tromp> :t fromInt
16:19:55 <lambdabot> Not in scope: `fromInt'
16:19:56 <gwern> dons: the entire thing?
16:20:04 <olsner> eta-reduction is one of those standard lambda calculus reductions, right?
16:20:07 <gwern> there isnae an LANGUAGE pragmas for't?
16:20:38 <tromp> how do you map Int to Integer again?
16:20:40 <Toxaris> olsnder: yep, it's (\x -> f x) == expression in Haskell
16:20:50 <Toxaris> olsnder: ehm, (\x -> f x) == f
16:20:59 <Toxaris> olsner: hmm, "olsner"
16:21:03 <gwern> ?wiki eta reduction
16:21:03 <lambdabot> http://www.haskell.org/haskellwiki/eta_reduction
16:21:04 <augustss> tromp: fromIntegral
16:21:06 <glen_quagmire> gwern: ghc --supported-languages ?
16:21:12 <augustss> or toInteger
16:21:15 <olsner> so, basically, the last argument of my newtype has to be the last argument applied to the type of the field?
16:21:15 <tromp> thanks, augustss
16:21:20 <tromp> :t toInteger
16:21:21 <lambdabot> forall a. (Integral a) => a -> Integer
16:21:27 <tromp> :t fromIntegral
16:21:28 <lambdabot> forall a b. (Num b, Integral a) => a -> b
16:21:43 <olsner> which means my 'a' can't appear in the middle
16:21:57 <gwern> glen_quagmire: I use the haddock docs for Distribution.Extension, but yes, I've looked at the list, and only UnboxedTuples
16:22:10 <gwern> wait, maybe MagicHash as well
16:22:38 <xpika> hi, im going to try forcing a package intstall of the debian sid ghc on my etch install. wish me luck!
16:22:57 <shepheb> in a Gtk2Hs app, what is the best practice for arbitrary simple line, rectangle, circle drawing (by the program, not from user)
16:23:07 <Toxaris> olsner: your HistoryWriterT is not of that form, it has form (\x -> (... x ...) x). (with x = type argument a)
16:23:12 <dcoutts> shepheb: cairo
16:23:30 <dcoutts> shepheb: see the gtk2hs cairo demos
16:23:33 <shepheb> dcoutts: does cairo work for Windows? I need Windows and Linux.
16:23:40 <Toxaris> olsner: so newtype deriving can't use eta reduction to find a type of kind (* -> *), involving HistoryWriterT, which is needed for typeclass Monad
16:23:41 <dcoutts> shepheb: yep, and osx
16:23:48 <shepheb> dcoutts: alright, I'll have a look
16:23:50 <xpika> shepheb:  moveTo lineTO
16:23:54 <Toxaris> olsner: since you used a somewhere in the middle of the type
16:24:38 <olsner> I believe I actually somewhat understand this now
16:24:43 <shepheb> dcoutts: goes cairo support have to be compiled in to Gtk2Hs?
16:24:48 <shepheb> does*
16:25:11 <Toxaris> olsner: so basically ghc told you that you shouldn't use that a there
16:25:29 <dcoutts> shepheb: yes, but it's on by default if your version of gtk+ is not truly ancient
16:25:40 <shepheb> dcoutts: okay, thanks.
16:26:02 <Toxaris> olsner: (this is only a very high-level explanation, I don't know what exactly happens during newtype deriving)
16:29:45 <xpika> yes, I had heaps of dependancy issues but -force installing debian sids ghc6 on etch worked anyway :)
16:30:33 <dmwit> Are there words/read equivalents for ByteString?
16:30:48 <oerjan> @hoogle words
16:30:48 <lambdabot> Prelude.words :: String -> [String]
16:30:48 <lambdabot> Data.List.words :: String -> [String]
16:30:48 <lambdabot> Data.ByteString.Char8.words :: ByteString -> [ByteString]
16:30:55 <dcoutts> dmwit: words yes, read no
16:30:59 * dmwit blinks
16:31:02 <Big_Red> ok screw c and its insurmountable compound failure - does anyone know a good c++ forum, or failing that c#
16:31:06 <dcoutts> you can use read . unpack
16:31:16 <dmwit> That function is not in this documentation!
16:31:17 <Big_Red> although c# is kinda restricted to machines with .net
16:31:24 <dmwit> dcoutts, oerjan: Okay, thanks.
16:31:25 <Cale> augustss: yeah, apparently ;)
16:31:30 <dcoutts> Big_Red: erm, you're in #haskell :-)
16:31:37 <Big_Red> hence asking where
16:31:48 <dmwit> Big_Red: Maybe ##c++?
16:31:55 <Cale> I've abused this fact to start distributing propaganda about library changes :)
16:31:59 <augustss> Cale: I have a small extension to the simple reflection
16:32:00 <Cale> :t (.)
16:32:01 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:32:06 <Cale> Cool
16:32:07 <xpika> Big_Red:  yes, and C is an compound success
16:32:12 <Cale> I'd happily add it.
16:32:17 <augustss> to print functions
16:32:34 <augustss> so it might clash with the other function printing in lambdabot :(
16:33:03 <augustss> you can look at http://augustss.blogspot.com/
16:33:04 <lambdabot> Title: Things that amuse me
16:33:09 <Cale> Well, we could remove that. The other function printing is pretty simplistic.
16:33:39 <SamB> don't forget about smallcheck...
16:34:15 <SamB> er, that is, be carefull not to break it
16:35:48 <Sarajevo> haskell
16:36:03 <hpaste>  augustss pasted "Expr function printer" at http://hpaste.org/6244
16:36:07 <Sarajevo> never heard of it, what can I do with haskell ? can I code a game with this programming language ?
16:36:13 <happyhacker> Can anyone please help me getting started with haskore properly?
16:36:18 <happyhacker> Sarajevo, yes you can
16:36:23 <Sarajevo> is Haskell procedural or OOP language ?
16:36:27 <augustss> no
16:36:29 <Cale> Sarajevo: neither
16:36:29 <happyhacker> none of both
16:36:39 <Cale> augustss: I'll add it to SimpleReflect
16:36:45 <Sarajevo> hmm
16:36:58 <Cale> Sarajevo: It's a pure functional programming language.
16:37:03 <dons> Sarajevo: check out haskell.org for an overview, and introduction
16:37:07 <happyhacker> I've installed Haskore but I  don't understand how to run the examples from it
16:37:08 <Sarajevo> ok
16:37:26 <happyhacker> and yes, I read the manual
16:37:43 <glguy> Sarajevo: You've got a lot of rehabilitation ahead of you if those are the only two categories you seen languages fall into ;)
16:37:46 <Cale> Sarajevo: It's statically typed with a very expressive type system that has type inference, it's (typically) lazily evaluated (which means that functions are evaluated outermost first)
16:38:24 <Sarajevo> I can code in c and asm x86 only
16:38:30 <Sarajevo> ok Cale
16:38:36 <Cale> Sarajevo: ah, so this will be very different :)
16:38:48 <Sarajevo> hmm
16:39:03 <Sarajevo> are there any compilers for windows ?
16:39:14 <Sarajevo> can I call API functions from Haskell ?
16:39:19 <glen_quagmire> yes
16:39:26 <happyhacker> ghc is available for win
16:39:30 <Sarajevo> cool
16:39:41 <monochrom> I am a bit uncomfortable with an obsession with "lol".
16:39:44 <Sarajevo> I gotta try it
16:39:48 <glen_quagmire> Sarajevo: http://www.haskell.org/ghc/docs/latest/html/users_guide/ffi.html
16:39:49 <lambdabot> Title: Chapter 9. Foreign function interface (FFI)
16:40:10 * QtPlatypus finds it somewhat interesting that people outside the functional langauge community consider procedural and OOP programing to be diffrent paradines.  While within the functional lanaguage community there normally considered to procedural code.
16:40:14 <QtPlatypus> Or at least imperative.
16:40:34 <glen_quagmire> procedural is superset of OOP
16:40:54 <glen_quagmire> maybe not. oop can be purely functional maybe
16:41:10 <Cale> OOP and procedural are really orthogonal
16:41:16 <Toxaris> many formalized oo calculi are purely functional
16:41:16 <BMeph> @faq "can I call API functions from Haskell ?"
16:41:16 <lambdabot> The answer is: Yes! Haskell can do that.
16:41:33 * BMeph chortles with evil glee
16:41:51 <Toxaris> this is an ad-hock overloading of "language paradigm"
16:41:52 <SamB> @faq can I has class aliases?
16:41:53 <lambdabot> The answer is: Yes! Haskell can do that.
16:42:05 <SamB> @faq ... without implementing them myself?
16:42:06 <lambdabot> The answer is: Yes! Haskell can do that.
16:42:37 <augustss> never trust a bot
16:42:39 <Cale> @undef
16:42:40 <lambdabot> Undefined.
16:42:56 <Cale> > \(x,y) -> x + y
16:42:56 <lambdabot>  Add a type signature
16:43:03 <Cale> > \() -> 1
16:43:04 <lambdabot>  \ () -> 1
16:43:06 <Toxaris> there is "top-level construct to structure code: none at all -- procedure -- object"
16:43:07 <Cale> hmm
16:43:18 <dons> > \(x,y) -> x + y :: Expr
16:43:18 <lambdabot>  \ (x,y) -> x + y
16:43:27 <mauke> what the
16:43:29 <dons> haha
16:43:33 <dons> augustss++
16:43:38 <Toxaris> and there is "basic element of code: expression -- command -- equation -- ..."
16:43:51 <gwern> never trust any bot over 30!
16:43:53 <Botje> yes, augustss++ -- fine bit of hacking, there.
16:43:59 <Cale> augustss++
16:44:10 <Botje> I just read the blog post :)
16:44:14 <SamB> > \(x,y) -> x + y
16:44:14 <lambdabot>  Add a type signature
16:44:19 <tromp> let fibs2 = zipWith (+) (0:1:fibs2) (1:fibs2)
16:44:20 <SamB> @type \(x,y) -> x + y
16:44:21 <lambdabot> forall t. (Num t) => (t, t) -> t
16:44:23 <Cale> > \(x,y) -> x + y + z
16:44:23 <lambdabot>  \ (x,y) -> x + y + z
16:44:24 <augustss> > scanr (.) id [(*2),f::Expr->Expr,(+1)]
16:44:25 <lambdabot>  [\ x -> f (x + 1) * 2,\ x -> f (x + 1),\ x -> x + 1,\ x -> x]
16:44:30 <tromp> > fibs!!5
16:44:31 <lambdabot>   Not in scope: `fibs'
16:44:34 <SamB> oh right ;-P
16:44:35 <tromp> > fibs2!!5
16:44:35 <lambdabot>   Not in scope: `fibs2'
16:44:39 <dons> > ord
16:44:39 <lambdabot>        add an instance declaration for (SimpleReflect.ExprArg Char)
16:44:43 <Botje> tromp: you mean @let
16:44:48 <dons> boo, that used to work
16:44:49 <tromp> ah:)
16:44:50 <SamB> > \x -> x+y
16:44:51 <lambdabot>  \ x -> x + y
16:44:54 <tromp> @let fibs2 = zipWith (+) (0:1:fibs2) (1:fibs2)
16:44:54 <lambdabot> Defined.
16:44:56 <tromp> > fibs2!!5
16:44:56 <lambdabot>  13
16:45:03 <Cale> > scanl (.) id [(*2),f::Expr->Expr,(+1)]
16:45:04 <lambdabot>  [\ x -> x,\ x -> x * 2,\ x -> f x * 2,\ x -> f (x + 1) * 2]
16:45:07 <mauke> > typeOf x
16:45:07 <lambdabot>   add an instance declaration for (Typeable Expr)
16:45:07 <lambdabot>     In the expression: type...
16:45:07 <dons> > ((+1) :: Int -> Int)
16:45:07 <lambdabot>        add an instance declaration for (SimpleReflect.ExprArg Int)
16:45:13 <gwern> I've been wondering, what does these lines of output mean:? Preprocessing executables for joinhsc-0.1...
16:45:15 <Cale> whoops!
16:45:16 <gwern> shift/reduce conflicts:  12
16:45:17 <Cale> hehe
16:45:21 <Cale> There's a bug there
16:45:21 <augustss> dons: maybe it could again if you hack ghc to be smarter about overlapping instances
16:45:22 <dons> so the old instance for Typeable => Show doesn't work now?
16:45:26 <dons> yeah
16:45:35 <Cale> \ x -> f x * 2
16:45:38 <Cale> should be
16:45:41 <Cale> \ x -> f (x * 2)
16:45:55 <Cale> er
16:46:02 <Cale> hmm
16:46:04 <Cale> maybe not :)
16:46:05 <mauke> Cale: can you derive Typeable for Expr?
16:46:11 <augustss> The old one won't work, the instance heads overlap completly and ghc doesn't backtrack
16:46:12 <tromp> i'm doing project euler
16:46:35 <Saizan> gwern: that's output frm Happy i think, saying that the grammar submitted has those problems
16:46:54 <Cale> ah, no, it's right :)
16:47:00 <Cale> mauke: I'll check
16:47:12 <SamB> gwern: shift/reduce conflicts aren't usually too serious...
16:47:25 <Cale> @undefine
16:47:25 <lambdabot> Undefined.
16:47:31 <tromp> how do you get prefix of a list up to first element satisfying some predicate?
16:47:33 <SamB> they tend to arise from things like the possibility of ambiguous if nesting...
16:47:35 <gwern> Saizan: oh. I suppose that makes sense, this library does seem to have a lot of parsing in it
16:47:38 <Cale> @instances Typeable
16:47:38 <lambdabot> Couldn't find class `Typeable'. Try @instances-importing
16:47:41 <Cale> hmm
16:47:42 <augustss> tromp: takeWhile
16:47:53 <Cale> > typeOf x
16:47:54 <lambdabot>   add an instance declaration for (Typeable Expr)
16:47:54 <lambdabot>     In the expression: type...
16:47:56 <tromp> sounds right, augustss:)
16:48:08 <Toxaris> tromp: takeWhile (not . <predicate>) <list>
16:48:24 <tromp> there's no takeUntil?
16:48:24 <gwern> 'JoinHs is a dialect of Haskell supporting concurrent and distributed programming using Join-calculus as a basis. The result is a declarative way to define concurrent abstractions, which can be distributed in a transparent fashion.'
16:48:27 <SamB> wouldn't it be takeUntil?
16:48:49 <SamB> > takeUntil id [False, False, True]
16:48:49 <lambdabot>   Not in scope: `takeUntil'
16:48:54 <SamB> > takeWhile id [False, False, True]
16:48:55 <lambdabot>  []
16:49:06 <SamB> @hoogle takeUntil
16:49:07 <lambdabot> No matches found
16:49:07 <monochrom> @hoogle (a -> Bool) -> [a] -> [a]
16:49:07 <lambdabot> Prelude.filter :: (a -> Bool) -> [a] -> [a]
16:49:07 <lambdabot> Prelude.takeWhile :: (a -> Bool) -> [a] -> [a]
16:49:07 <lambdabot> Prelude.dropWhile :: (a -> Bool) -> [a] -> [a]
16:49:10 * gwern hopes all the libraries that makeup JoinHs will cabalize as nicely as joinhsc
16:49:29 <SamB> tromp: oh well, there's always takeWhile . (not . )
16:50:09 <SamB> @pl takeWhile . (not .) $ p
16:50:09 <lambdabot> takeWhile (not . p)
16:50:23 <Toxaris> what about (fst .) . span?
16:50:31 <mauke> @unpl takeWhile . (not . )
16:50:31 <lambdabot> (\ d -> takeWhile (\ g -> not (d g)))
16:50:34 <monochrom> slower
16:50:46 <Cale> > typeOf x
16:50:47 <lambdabot>  SimpleReflect.Expr
16:50:52 <Cale> there you go
16:50:59 <tromp> cool; problem2 answered right first time
16:51:03 <mauke> > \x -> y
16:51:04 <lambdabot>  \ () -> y
16:51:09 <mauke> fail
16:51:09 <glen_quagmire> :info typeOf
16:51:09 <augustss> haha
16:51:18 <SamB> @type (\ d -> takeWhile (\ g -> not (d g)))
16:51:19 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
16:51:35 <SamB> @pl (\ d -> takeWhile (\ g -> not (d g)))
16:51:35 <lambdabot> takeWhile . (not .)
16:51:43 <augustss> mauke: it's the weird top level defaulting
16:52:21 <SamB> hmm, @unpl has no taste
16:52:35 * Botje licks lambdabot 
16:52:40 <Botje> lambdabot has a flavor, though
16:52:41 <mauke> can has flavr?
16:52:42 <augustss> Cale, dons: I'll ponder the function printing to see if I can figure something out
16:52:51 <Cale> > \(x :: Expr) -> y
16:52:51 <lambdabot>  Parse error in pattern at "->" (column 14)
16:52:59 <Cale> > \x -> y :: Expr
16:53:00 <lambdabot>  \ () -> y
16:53:03 <Cale> > \x -> y :: Expr -> Expr
16:53:04 <lambdabot>  Couldn't match expected type `Expr -> Expr'
16:53:15 <Cale> > (\x -> y) :: Expr -> Expr
16:53:16 <lambdabot>  \ x -> y
16:53:57 <augustss> > const :: Expr -> Expr -> Expr
16:53:57 <lambdabot>  \ y -> \ x -> y
16:54:01 <Cale> augustss: The MR should be turned off.
16:54:16 <Cale> (Just for reference)
16:54:26 <Cale> > let f = \x -> y in f
16:54:26 <lambdabot>  \ () -> y
16:54:35 <augustss> Cale: but the defaulting to () is to be able to print, e.g., []
16:54:51 <Cale> hmm, right
16:55:06 <Botje> darcs is failing :(
16:55:20 <augustss> > flip :: (Expr->Expr->Expr)->Expr->Expr->Expr
16:55:21 <lambdabot>        add an instance declaration for
16:55:21 <lambdabot>       (SimpleReflect.ExprArg (Expr -> ...
16:55:30 <glguy> Botje: in general or right now?
16:55:42 <augustss> arghh!! My work is not done yet!
16:55:48 <BenC> I have a strange error that I can't figure out how to fix -- I pasted the code for it (I think it's enough to see the problem) here http://hpaste.org/6246  the problem occurs because I never use the options (of type o) inside the function, so it doesn't realize that the type o must be the same as in the context (I think)... is there any way to get it to constrain things correctly?
16:55:48 <Botje> i'm trying to darcs pull my parsec3 up to date
16:55:51 <Botje> seems to just hang there
16:55:54 <newsham> how is unit () represented in the lambda calculus?
16:56:53 <augustss> id
16:57:07 <augustss> well, that's one way
16:57:12 <Botje> feh, i'll just re-pull
16:58:06 <idnar> Building plugins-1.0...
16:58:07 <idnar> src/Language/Hi/Binary.hs:90:7:
16:58:07 <idnar>     Could not find module `Data.Array.Base':
16:58:07 <idnar>       it is a member of package array-0.1.0.0, which is hidden
16:58:08 <idnar> argh-
16:58:36 <glguy> pluggins might not work on 6.8
16:58:46 <tromp> i think that's the standard way
16:58:54 <idnar> @version
16:58:54 <lambdabot> lambdabot 4p597, GHC 6.8.2 (Linux i686 2.40GHz)
16:58:54 <lambdabot> darcs get http://code.haskell.org/lambdabot
16:59:04 <glguy> oh, cool, it's updated
16:59:06 <newsham> aug: \x -> x?
16:59:24 <tromp> the same way that gives you \x y->x for True and \x y->y for False
16:59:27 <idnar> where do I get a version of plugins that works with 6.8? :P
16:59:49 <dons> idnar: http://code.haskell.org/~dons/code/hs-plugins/
16:59:49 <lambdabot> Title: Index of /~dons/code/hs-plugins
17:00:07 <idnar> cool
17:01:01 <yav> dons: do you want a bytestring puzzle?
17:01:21 <campusblo> hi folks
17:01:23 <glguy> look who's a regular irc user ;)
17:01:38 <dons> yav, possibly...
17:01:39 <dons> glguy: :)
17:01:40 <idnar> man, that's quite a hostname mask
17:01:44 <dons> SyntaxNinja's still here too
17:01:59 <dons> @seen elliottt
17:01:59 <lambdabot> I saw elliottt leaving #haskell-soc 11d 23h 33m 4s ago, and .
17:02:03 <dons> ah well
17:02:21 <campusblo> hey folks im writing a simple haskell function and the base case is a list with one element . im kinda rusty on haskell
17:02:34 <yav> dons: i think i managed to cut down that "out of stack" problem quite a bit, if you want to take a look
17:02:42 <dons> ah right. cool.
17:02:42 <dmwit> campusblo: [x]
17:02:44 <dons> yeah, send it over.
17:02:48 <campusblo> should that be foo [x] = x
17:02:57 <campusblo> ok
17:03:03 <dons> it felt like there was an optimiser bug down there somewhere, yav
17:03:05 <Zao> campusblo: It depends on what your function is supposed to do.
17:03:07 <campusblo> i want to say if theres only one element then print that element
17:03:28 <Zao> That function of yours returns the element. It does no printing.
17:03:41 <campusblo> oh ok
17:03:45 <campusblo> thatnks zao
17:03:46 <hpaste>  yav pasted "Using up the stack" at http://hpaste.org/6247
17:03:50 <campusblo> thats all i needed to know
17:04:01 <Zao> The type of it is foo :: [a] -> a
17:04:31 <yav> dons: yeah, i've learned all about rewrite rules and fusion by now :-)
17:04:45 <yav> but i am not sure if its a GHC problem
17:04:53 <dons> oh interesting. that's a short one.
17:06:33 <hpaste>  campusblo pasted "maxlist" at http://hpaste.org/6248
17:06:49 <campusblo> thats a small function to get the max of the list
17:06:52 <glguy> ?src maximum
17:06:52 <lambdabot> maximum [] = undefined
17:06:52 <lambdabot> maximum xs = foldl1 max xs
17:06:55 <campusblo> i know that the otherwise part is wrong
17:07:04 <campusblo> what should it be?
17:07:26 <campusblo> if id do maxlist [1,2,3,4] i get 2 as the answer
17:07:29 <idnar> src/System/Plugins/ParsePkgConfCabal.hs:287:34:
17:07:29 <idnar>     Ambiguous occurrence `depends'
17:07:29 <idnar>     It could refer to either `Distribution.InstalledPackageInfo.depends', imported from Distribution.InstalledPackageInfo at src/System/Plugins/ParsePkgConfCabal.hs:8:0-39
17:07:30 <Toxaris> campusblo: i don't think the otherwise part is the problem
17:07:32 <idnar>                           or `Distribution.Package.depends', imported from Distribution.Package at src/System/Plugins/ParsePkgConfCabal.hs:9:0-26
17:07:35 <idnar> argh!
17:07:39 <Toxaris> campusblo: have a look at the "head xs ..." part
17:08:08 <newsham> > foldl1 max [1,2,3,4]
17:08:09 <lambdabot>  4
17:09:01 <hpaste>  BenC annotated "What's wrong with this?" with "How can I get this to typecheck?" at http://hpaste.org/6246#a1
17:09:18 <campusblo> toxaris whats wrong with it?
17:09:25 <hpaste>  glguy annotated "maxlist" with "maxList in the spirit of its parent" at http://hpaste.org/6248#a1
17:09:28 <Toxaris> campusblo: well, it's wrong :)
17:09:29 <campusblo> it stops the function?
17:09:40 <campusblo> i know that . what would make it right?
17:10:01 <Toxaris> campusblo: in your example [1, 2, 3, 4], what is x and what is xs in the first recursion step
17:10:18 <campusblo> x is 1 and xs is 2
17:10:36 <campusblo> well xs is 2 3 4 []
17:10:36 <glguy> :3:4:[]
17:10:58 <Toxaris> campusblo: exactly, x is 1 and xs = [2, 3, 4] or 2 : 3 : 4 : []
17:11:03 <dons> yav, so it depends on a .. in the second list
17:11:15 <Toxaris> campusblo: so will head xs >= x be true or false?
17:11:36 <campusblo> true
17:11:38 <campusblo> and it ends
17:11:48 <campusblo> ok so i need something which is going to do a recursion there as well
17:11:58 <Toxaris> campusblo: exactly, this is the point where you need recursion!
17:12:22 <Toxaris> campusblo: at this point, you know that the max can't be the x (since head xs is bigger), but it could be *any* of the elements of xs
17:12:39 <idnar> yay, one dependency left
17:14:20 <glguy> BenC: Looks like a case for functional dependencies
17:14:54 <BenC> glguy: I was thinking that, but I have no idea where I would put the functional dependency...
17:15:13 <Toxaris> glguy: your maxlist looks like the inner loop of bubble sort :)
17:17:02 <Saizan> do the simply typed lambda calculus have the notion of principal type?
17:17:15 <glguy> class (Monad m) => ReaderM m i | m -> i where
17:17:17 <glguy>   -- | Get the context.
17:17:19 <glguy>   ask :: m i
17:17:38 <glguy> BenC: That's the definition of ReaderM, which is basically what you are trying to create
17:17:46 <campusblo> ok so i can make it work for a sorted list. but what about an unsorted list?
17:18:23 <campusblo>  | x >= head xs what then?
17:18:52 <campusblo> maxlist tailxs?
17:19:05 <glguy> where did x go?
17:20:24 <Toxaris> campusblo: which numbers may possibly be the maximum if x >= head xs?
17:20:42 <campusblo> x
17:20:52 <campusblo> or a number after head xs
17:20:57 <tromp> you dont want to compare with head xs, but with maxof xs
17:21:02 <BenC> glguy: right -- this is just a special case of ReaderT... but if I try to put a functional dependency on the class MonadCmd, it will then complain because it doesn't like the two instance declarations that pass things up  to the OptionsM monad
17:22:03 <BMeph> campusblo: Here's a scary thought - what if you conpared x and... maxlist xs? ;)
17:22:30 <glguy> BenC: I'm not sure what the first instance does for you
17:22:53 <glguy> BenC: I think you'd want to newtype your monad
17:23:03 <glguy> rather than making it a special case of readert
17:23:10 <Toxaris> campusblo: yes, so you have to find the maximum of the list containing x and (all of xs but the head). you can construct this list and recursively call maxlists
17:23:17 <monochrom> campusblo: glguy's code works for all unsorted lists.  It has an interesting invariant: the head is always the max of the items seen so far.  Notice the recursive call: maxlist (x1:xs) or maxlist (x2:xs), not maxlist xs.
17:23:36 <BenC> glguy: so the point was that I can use liftOptions to perform some action inside whichever reader contains an option, no matter how many other readers are wrapped around it
17:24:06 <monochrom> A sample run: maxlist [3,1,4,1,5] -> maxlist [3,4,1,5] -> maxlist [4,1,5] -> maxlist [4,5].
17:24:26 <glguy> BenC: but rather than lifting to the nearest ReaderT
17:24:26 <Toxaris> glguy: the first instance is the base case for the recursion searching down the monad transformer stack for a OptionsM
17:24:41 <glguy> BenC: you could lift to a concrete monad was all I was suggesting
17:25:13 <glguy> Toxaris: I understand the goal, just asking about the approach
17:25:18 <BenC> glguy: oh... I see... I'll try that, but I'm not sure how that'll help the type inferrer figure out that log should be valid
17:26:29 <tibbe> should I export Control.Applicate from my parser module or should I let people import it themselves. what do you guys think?
17:26:34 <campusblo> wow i didnt know i could do that
17:26:37 <campusblo> it works
17:26:39 <tibbe> (the library is not very useful without)
17:27:22 <campusblo> basically you're dropping terms from the middle of the list right?
17:27:30 <campusblo> i would not have thought of doing it that way
17:27:50 <campusblo> i would have gone through element by element from left to right
17:28:47 <BMeph> campusblo: That's what's happening, it just drops either the first or the second element, depending on which one is smaller. :)
17:29:04 <Toxaris> tibbe: if Control.Applicative is the "main interface" for your parser, you should export it, I would say.
17:29:15 <mauke> 「maxList (x : xs) = findMax x xs where findMax curmax [] = curmax; findMax curmax (x : xs) = findMax (if x > curmax then x else curmax) xs」
17:29:21 <tibbe> Toxaris: ok
17:29:22 <Toxaris> tibbe: e.g. if Control.Applicative.<|> is the <|> to be used
17:29:35 <SamB> mauke: what's with the funky brackets?
17:29:44 <tibbe> Toxaris: it is, the parser is Applicative and Alternative but not monadic
17:29:53 <mauke> SamB: I like them
17:30:02 <SamB> but what are they FOR
17:30:18 <SamB> you weren't writing a sentence in japanese...
17:30:20 <Toxaris> tibbe: yeah I've just read your -cafe mail
17:30:35 <tromp> has any1 looked at http://projecteuler.net/index.php?section=problems&id=185 ?
17:30:36 <lambdabot> Title: Problem 185 - Project Euler
17:30:46 <tibbe> Toxaris: :) solved all my problems now, the parser is done, may add some utility functions to it but that's it
17:31:07 <monochrom> campusblo: It always drops either the first or the second element.  That is left-to-right for me.
17:31:52 <campusblo> yes mauke that works too thanks
17:31:56 <dons> yav, works fine under stream fusion :)
17:31:56 <campusblo> later folks
17:32:51 <monochrom> Nice, mauke has found and uses the Chinese quotation marks. :)
17:32:55 <hpaste>  dons annotated "Using up the stack" with "stream fused no leak" at http://hpaste.org/6247#a1
17:33:34 <campusblo> queston
17:33:48 <campusblo> is it better to use otherwise or try to specify all cases?
17:34:07 <monochrom> whichever you like.
17:34:10 <campusblo> like in my program there are two possibilities
17:34:23 <campusblo> none has an inherent advantage?
17:34:29 <monochrom> no.
17:34:41 <campusblo> i guess specified situations are more readable later on though?
17:34:59 <glguy> BenC: still there?
17:35:06 <BenC> glguy: yeah
17:35:19 <glguy> one solution is to use ScopedTypeVariables and PatternSignatures
17:35:24 <BMeph> tromp: Interesting - I'll have to put that on my "list." ;)
17:35:34 <glguy> so that instead of just
17:35:37 <glguy> using a _
17:35:40 <glguy> and ignoring the type
17:35:45 <BenC> I could use _::o?
17:35:48 <glguy> you can link it's type to the class head
17:36:09 <hpaste>  glguy annotated "What's wrong with this?" with "with extensions" at http://hpaste.org/6246#a2
17:36:16 <BenC> ah, I had tried to get it to let me do that, and it was saying that o wasn't in scope -- I'm guessing that ScopedTypeVariables will let me do that?
17:36:27 <glguy> BenC: yeah, check out the forall I had to add
17:36:29 <campusblo> ok later folks thanks for the help
17:36:48 <BenC> glguy: Ah... so you need both the extension and the forall?
17:36:57 <glguy> the extension enables the forall
17:37:05 <gwern> Good news everyon! I got my girl scout cookiees today
17:37:20 <glguy> BenC: you could avoid the patternsignatures
17:37:23 <tibbe> why is Functor both in Prelude and Control.Monad?
17:37:29 <glguy> by putting the pattern on the liftOptions ask, I'd imagine
17:37:39 <monochrom> Can girl scout cookies write Haskell?
17:37:46 <mauke> @faq
17:37:46 <lambdabot> The answer is: Yes! Haskell can do that.
17:38:18 <monochrom> You mean "Haskell can girl scout cookies write Haskell"?
17:38:36 <glguy> the girl scouts teach girls an important lesson in how you can make more money by providing less product each year at higher prices
17:38:39 <Toxaris> tibbe: Most parts of the Prelude are duplicated somewhere else, for people who import Prelude () but want to use Functor anyway. I wonder why there's now Data.Functor
17:38:41 <dons> girl scout cookies are great.
17:38:50 <gwern> if Haskell Curry were around, you can betcha he'd enjoy girl scout cookiees
17:38:57 <gwern> especially 6 boxes of Thin Mints
17:39:09 <gwern> glguy: that's inflation, man. deal
17:39:40 <glguy> gwern: what they did to the caramel / coconut / chocolate things (which are delicious) goes way past inflation
17:39:54 <gwern> glguy: the samoas?
17:39:57 <glguy> yeah
17:39:59 <glguy> those
17:40:03 <olsner> wow, -fvia-c really increases compilation times
17:40:12 <glguy> the thin mints, while they give you the same, are two serving packages
17:40:22 <glguy> (same as always I mean)
17:40:33 <BMeph> @faq Can Haskell kick goals from across the pitch?
17:40:33 <lambdabot> The answer is: Yes! Haskell can do that.
17:40:34 <gwern> glguy: dunno. 50 cents in the 70s to 3.50 right now for thin mints seems pretty par for the course for inflation
17:40:41 <BMeph> Heh-heh. ;p
17:40:43 <glguy> once you open one you have to finish the whole thing, can't put them down
17:41:03 * glguy wonders if gwern is a girlscout
17:41:08 <gwern> glguy: sure, blame the girlscouts for your own glottony
17:41:12 <gwern> *gluttony
17:41:49 <glguy> gwern: just like mcdonalds gets successfully sued for providing popular hamburgers, I'm going to get my payout!
17:42:20 <gwern> glguy: wouldn't matter. girl scouts don't really get discounts; or rather, the discounts go to the troop and national.
17:42:22 <gwern> :(
17:42:33 <idnar> hmm, my lamdbabot isn't joining any channels
17:43:05 <glguy> gwern: discounts?
17:44:09 <gwern> glguy: yeah. the manufacturers charge girl scouts national something like 1.50 a box, and the rest goes to overhead, national, and the last 50 cents or so funds the local girl scouts troop selling the box
17:44:55 <glguy> so it's a lesson in corporate expoitation and child labor?
17:45:07 <gwern> something like that
17:45:09 <glguy> ah
17:45:14 <gwern> prepares you to be an american
17:45:24 <gwern> 'If the more esoteric (to C family programmers, anyway) languages like Lisp and Haskell offer such big productivity gains, then why aren't there more high-profile projects written in them?' 'Hah! That's an easy one. All the time saved with productivity gain gets wasted in language advocacy.'
17:45:34 <idnar> where do I get Data.Number.Symbolic?
17:46:15 <gwern> idnar: doesn't sound standard look at http://hackage.haskell.org/packages/archive/numbers/2007.9.25/doc/html/Data-Number-Symbolic.html
17:46:20 <lambdabot> http://tinyurl.com/ytadfn
17:46:57 <gwern> ?hackage numbers
17:46:57 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/numbers
17:47:08 <idnar> ah
17:47:10 <gwern> 'Instances of the numerical classes for a variety of different numbers: (computable) real numbers, arbitrary precision fixed numbers, arbitrary precision floating point numbers, differentiable numbers, symbolic numbers, natural numbers, interval arithmetic.'
17:47:33 <gwern> ah, if only it had a class for positive reals
17:48:29 <monochrom> Why do you need a class for positive reals?  A class of non-negative reals does just fine.
17:48:46 <BenC> glguy:  Ok, I got it to work with ScopedTypeVariables -- thanks!  Now what were you saying about using Newtype to clean things up a bit?
17:48:52 <idnar> < lambdabot>  /tmp/MehxMJ9909.o: unknown symbol `__stginit_numberszm2007zi9zi25_DataziNumb...
17:48:55 <idnar> urgh
17:49:09 <gwern> monochrom: I want to exclude 0
17:49:52 <monochrom> OK, positive non-standard reals. :)
17:50:38 <gwern> monochrom: ie, I'm playing with very simple models of a nuclear explosion, and it makes no sense for the thermal radiation at a particular to ever be 0 or negative (inverse squared never goes to 0)
17:50:40 <Japsu> "data nazi numb"
17:51:56 <gwern> (although Iwould want reals for the blast wave, since the psi increases, peaks, and then goes negative as the displaced air returns and the firestorm sucks air upwards)
17:51:59 <Botje> gwern: you get to blow stuff up with haskell? I want your job :)
17:52:35 <gwern> Botje: nah, this is for personal education
17:52:36 <monochrom> reciprocals of distances are non-negative reals, and all of them.  this representation rules out zero-ground.  as a bonus, you also have a sane representation of +infinity.
17:53:10 <monochrom> Oops, replace "distances" by "radiation levels".
17:53:53 <gwern> monochrom: it doesn't really make sense to speak of zero ground as a point, anyway, since that'd be inside the bomb itself
17:53:54 <augustss> restricting yourself to positive reals makes an awful lot of functions partial
17:54:28 <gwern> ie, if you air-burst as you should to maximize surface destruction, 'ground zero' is still quite a few meters away from the fireball
17:57:11 <gwern> (nom nom nom)
17:58:51 <gwern> monochrom: acutally, speaking of radiation levels, that's currently the hardest part. there are a lot of variables in it, and my information on clothing and materials is incomplete - not to mention I am unsure of the cleanest way to handle the probabilities of disease/death
17:59:40 <dcoutts> sounds charming
18:01:21 <gwern> oh it is. do I simply return a list of percentages? do I multiply them together? how do I handle male/female/child differences? how detailed should I be?
18:01:47 <AshyIsMe> what do you guys work for Dr Evil or something?
18:02:01 <SamB> AshyIsMe: eh?
18:02:08 <gwern> do I factor in residual genetic damages? do I add parameters for whether it was an air burst or ground burst, and increase fallout for the latter with increased long-term radiation poisoning and permanent damage to the gene pool?
18:02:13 <SamB> is he hiring functional programmers?
18:02:13 <AshyIsMe> why not figure out fusion based energy production or something you freaks
18:02:19 <AshyIsMe> oh ok
18:02:27 <monochrom> One reason you can publish a million research papers is you can try all variations and publish one paper each.
18:02:38 <AshyIsMe> i thought you were trying to figure out the optimal air burst distance for a nuclear warhead to cause maximal destruction
18:02:55 * QtPlatypus ponders a template based program that just generates papers.
18:03:00 <SamB> AshyIsMe: there might be more than one reason to do that...
18:03:13 <SamB> say, if you wanted to figure out the maximum destruction...
18:03:22 <SamB> so you could design protections...
18:03:45 <AshyIsMe> yeah maybe
18:04:01 <AshyIsMe> or you could figure out how you pissed someone off enough for them to launch a nuclear warhead at you...
18:04:14 <gwern> AshyIsMe: it's an interesting question. if you have a radiation-enhanced warhead, then you've lost most of the blast wave energy by diverting it to radiation, so the 60*w^3 rule of thumb may not be useful if you could irradiate enough soil and generate enough fallout to compensate in terms of megadeaths
18:04:44 <Botje> @vixen functional nukes
18:04:44 <lambdabot> fun fun fun!
18:04:56 <SamB> @vixen fun
18:04:56 <lambdabot> I define fun
18:04:57 <Botje> even \bot agrees
18:05:17 <SamB> @vixen I
18:05:18 <lambdabot> hey, what's in a jack and coke anyhow?
18:05:23 <SamB> @vixen
18:05:23 <lambdabot> Im going to be a movie star.  I just applied online for this new movie with chris farley.  It only cost me $50!
18:05:25 <AshyIsMe> gwern, getting fusion to work is interesting too and involves less deaths...
18:05:48 <gwern> AshyIsMe: no it doesn't. how precisely do you think thermonuclear bombs work?
18:05:56 <gwern> I'll give you a hint, it only *starts* with fission
18:06:15 <hpaste>  Paczesiowa pasted "drawingArea in scrolledWindow" at http://hpaste.org/6249
18:06:20 <SamB> gwern: well, they idea is that you want to somehow contain the fusion reaction
18:06:32 <gwern> AshyIsMe: hell, we'd be a lot better off if we didn't know how to get fusion to work! then the gigaton h-bombs wouldn't even be a possibility
18:06:40 <idnar> @src ($+)
18:06:40 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
18:06:47 <Botje> @src (<+)
18:06:47 <lambdabot> Source not found. You untyped fool!
18:06:59 <SamB> while avoiding becoming mind-controlled by malevolent artificially intelligent tentacles
18:07:23 <monochrom> I read a Tom Clancy book. It does say how complex and delicate a working nuclear bomb is. One example is you use wire length to ensure timing.
18:07:27 <gwern> SamB: I see. has that worked brilliantly for fission reactions? containing it, I man...
18:07:54 <gwern> monochrom: an implosion design, I take it
18:08:03 <monochrom> Yeah.
18:08:21 <gwern> gun designs don't require the same precise timing of shaped explosives, and the tolerances are a lot more generous these days anyway with better designs and ingredients
18:08:25 <SamB> gwern: I never said it could work
18:08:29 <SamB> that's just the desire
18:17:28 <paczesiowa> could any of you confirm (and perhaps explain) that (why) this: http://hpaste.org/6249 doesn't have scrollbars for that picture?
18:18:11 <paczesiowa> *working scrollbars
18:26:13 <newsham> how do you list installed packages that are not deps of other installed packages?
18:28:16 <gwern> newsham: how to list non-depended packages? I suppose you could write a tool to parse package.conf into a directed graph and skim off the top
18:28:41 <newsham> oops, wrong channel.
18:28:52 <dcoutts> newsham: not really
18:29:05 <newsham> yes really, i meant freebsd packages. sorry
18:29:11 <dcoutts> newsham: oh ok :-)
18:29:32 <BMeph> newsham: no way! ;)
18:29:40 <dcoutts> it might be an interesting thing for ghc/cabal packages too
18:30:11 <dcoutts> cabal has code to get a PackageIndex InstalledPackageInfo which could be used to make a Graph and answer that question
18:31:28 <roconnor> good god, higher order reflected expressions!
18:31:38 <roconnor> does the insanity here never stop?
18:31:50 <roconnor> stop doing the impossible!
18:32:00 <gwern> @quote impossible
18:32:00 <lambdabot> ghc says: panic! (the `impossible' happened, GHC version 6.4)
18:33:30 <gwern> roconnor: nonsense. I daresay you haven't had much practice. Why, sometimes I've believe as many as 6 impossible things before breakfast.
18:34:23 <roconnor> :D
18:38:23 * dolio welcomes the new language for practical dependently typed programming, replacing the old language for practical dependently typed programming.
18:38:45 <gwern> meet the new type, same as the old type
18:38:49 * edwinb hears his name
18:39:22 <edwinb> it's a pity there haven't been any that allow you to do actual programming...
18:49:57 <mofmog> so if I have parse A that returns a tybe B
18:49:59 <mofmog> why is the type
18:50:05 <mofmog> Parser B
18:50:05 <mofmog> ?
18:50:14 <mofmog> dont parsers take in an input?
18:50:29 <mofmog> or is the input assumed from the fact that a parser is (i think) a monad?
18:50:59 <paczesiowa> Parser takes string as input
18:51:17 <paczesiowa> @src Parser
18:51:17 <lambdabot> Source not found. My mind is going. I can feel it.
18:51:28 <EvilTerran> the type is :: GenParser input state result
18:51:29 <paczesiowa> Parser is GenParser [Char]
18:51:41 <EvilTerran> GenParser [Char] (), even
18:52:48 <dibblego> > foldr f z [1,2,3]
18:52:48 <lambdabot>  f 1 (f 2 (f 3 z))
18:53:47 <EvilTerran> > foldl f z [1,2,3]
18:53:47 <lambdabot>  f (f (f z 1) 2) 3
18:54:41 <dibblego> > foldr1 f [1,2,3]
18:54:43 <lambdabot>  Add a type signature
18:56:27 <newsham> whoa, lambdabot does symbolic evals?
18:56:39 <SamB> newsham: since a few hours ago, yes
18:56:54 <newsham> neat.  i wish my lb was newer than a few hrs old :(
18:57:05 <SamB> it didn't need a reboot
18:57:19 <whee> @uptime
18:57:19 <lambdabot> uptime: 2d 9h 9m 50s, longest uptime: 1m 10d 23h 44m 29s
18:57:20 <SamB> as far as I could tell ,anyway
18:57:23 <whee> aww :)
18:57:35 <SamB> yeah, no reboot
18:57:39 <dons> whee: ?
18:57:46 <SamB> Cale: did you check it in?
18:57:48 <whee> dons: I want to see it beat 1m :P
18:57:55 <dons> 18:57  dons> ?uptime
18:57:56 <dons> 18:57  lambdabot> uptime: 2m 4d 1h 39m 27s, longest uptime: 2m 4d 1h 39m 27s
18:59:03 <wagle_home> ?  i thought i'd seen lambdabot get restarted in the last few weeks
18:59:49 <gwern> @where DSP
18:59:49 <lambdabot> I know nothing about dsp.
18:59:52 <dons> there's many bots.
18:59:55 <gwern> @where dsp
18:59:55 <lambdabot> I know nothing about dsp.
19:00:39 <gwern> so there's this wifi haskell src repo, which errors on 'Could not find module `DSP.Source.Oscillator':'. anyone know where a package providing DSP (digital signal processors I think) might be found?
19:00:45 <gwern> I don't see anything on hackage
19:01:10 <dons> oh, i think i know that one
19:01:19 <gwern> (and http://haskelldsp.sourceforge.net/ seems to be dead)
19:01:21 <dons> http://darcs.haskell.org/dsp/
19:01:28 <lambdabot> Title: Index of /dsp
19:02:01 <gwern> huh
19:02:13 <paczesiowa> could any of you confirm (and perhaps explain) that (why) this: http://hpaste.org/6249 doesn't have scrollbars for that picture?
19:02:41 <dons> paczesiowa: check on the gtk list perhaps? or bug dcoutts when he's awake
19:03:27 <radix> paczesiowa: I just ran your example and I get scroll bars
19:03:35 <wagle_home> paczesiowa, i have no idea, but in tcl/tk, you gotta tell the scrollbar about the thing being scrolled and the thing being scrolled about the scrollbar..  but maybe your case is different
19:03:42 <paczesiowa> do they work?
19:03:50 <radix> paczesiowa: but they seem to be ineffectual
19:04:14 <radix> that is, they're acting as if there is nothing out of view.
19:04:33 <paczesiowa> when I put a table inside scrollongwindow, it works ok, but not with drawingArea
19:04:42 <dons> gwern: even http://www.ohloh.net/projects/12215
19:04:43 <lambdabot> Title: haskelldsp - Ohloh
19:05:08 <dons> gwern: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/dsp
19:05:32 <gwern> wow, darcs,haskell is slow tonite
19:06:05 <gwern> dons: you were right; DSP.Source.Oscillator is indeed in that repo
19:07:30 <Plouj> hi
19:08:20 <Plouj> why do I get "Not in scope" on the first line of the following: parseString :: Parser LispVal
19:08:23 <Plouj> parseSTring = do char '"'
19:08:51 <gwern> @where green-card
19:08:51 <lambdabot> I know nothing about green-card.
19:08:52 <Plouj> "Not in scope: `parseString'" to be more specific
19:09:04 <mauke> Plouj: because typo
19:09:11 <dons> parseSTring <--
19:09:23 <Plouj> oh, thanks
19:09:27 <Plouj> wait
19:09:34 <Plouj> that's not a problem with the first line though
19:10:02 <Plouj> misleading
19:10:05 <dons> right. it assumes parseSTring is some other binding that you've declared
19:10:15 <dons> but it can't find a binding to match the type you wrote
19:10:58 <dons> so you just stated the type for a function that doesn't exist, and the compiler complained as it should
19:14:23 <Plouj> compiles should know what I mean!
19:14:27 <Plouj> compilers*
19:18:29 <BMeph> Plouj: Compilers DO know what you mean. They just find it funnier to play around with what you actually said. ;)
19:18:52 <luqui> :kind (->)
19:19:02 <mauke> @unkind (->)
19:19:03 <lambdabot> ?? -> ? -> *
19:19:12 <luqui> I don't understand that
19:19:15 <luqui> what do the ?s mean?
19:20:00 <dolio> ?? is either # or *. ? is either ?? or (#). (I think that's how it goes).
19:20:00 <lambdabot> Plugin `compose' failed with: Unknown command: ""
19:20:27 <dolio> Or, that is, they're unions, more or less.
19:20:28 <dons> :t \x -> 1#
19:20:29 <lambdabot> forall t. t -> GHC.Prim.Int#
19:20:57 <luqui> ah, and # is an unboxed?
19:20:58 <mauke> @kind GHC.Prim.Int#
19:20:58 <lambdabot> #
19:20:59 <dolio> @kind Int#
19:21:00 <lambdabot> Not in scope: type constructor or class `Int#'
19:21:12 <dolio> # is unboxed values. (#) is unboxed tuples.
19:21:25 <dons> :k GHC.Exts.Int#
19:21:26 <lambdabot> #
19:21:40 <dons> :t "foo"#
19:21:40 <lambdabot> GHC.Prim.Addr#
19:22:56 <luqui> so unboxed tuples can't be given as arguments?
19:23:19 <dons> :t let f (# 1, 2 #) = 3 in f
19:23:20 <lambdabot>     Couldn't match kind `(#)' against `??'
19:23:20 <lambdabot>     When matching the kinds of `(# t1, t2 #) :: (#)' and `t :: ??'
19:23:20 <lambdabot>     When generalising the type(s) for `f'
19:23:27 <dolio> I think that's right. They're for returning multiple values in registers (at least, that's the use case the GHC manual gives).
19:23:38 <luqui> interesting
19:23:38 <dons> :t \f -> case f of (# 1, 2 #) -> 3
19:23:39 <lambdabot> scripts/SimpleReflect.hs:219:51:
19:23:39 <lambdabot>     Ambiguous type variable `a' in the constraints:
19:23:39 <lambdabot>       `ExprArg a'
19:23:47 <dons> oh grr!
19:23:52 <Plouj> http://paste.lisp.org/display/57109 - I'm trying to print string converted to an integer which has been converted to a string, what am I doing wrong?
19:23:53 <dons> :t \f' -> case f' of (# 1, 2 #) -> 3
19:23:54 <lambdabot> scripts/SimpleReflect.hs:219:51:
19:23:54 <lambdabot>     Ambiguous type variable `a' in the constraints:
19:23:54 <lambdabot>       `ExprArg a'
19:24:01 <dons> Cale ?
19:24:01 <dolio> Hahaha.
19:24:15 <dons> :t \f' -> case f' of (# 1, 2 #) -> (3 :: Integer)
19:24:15 <lambdabot> scripts/SimpleReflect.hs:219:51:
19:24:15 <lambdabot>     Ambiguous type variable `a' in the constraints:
19:24:15 <lambdabot>       `ExprArg a'
19:24:22 <dons> oh, lots of defaulting not working :(
19:24:23 <dolio> augustss' new higher order reflection showing.
19:24:27 <mauke> Plouj: passing two arguments to 'show'
19:24:37 <dons> :t \f' -> case f' of (# (1::Int), (2::Int) #) -> (3 :: Integer)
19:24:37 <lambdabot> scripts/SimpleReflect.hs:219:51:
19:24:37 <lambdabot>     Ambiguous type variable `a' in the constraints:
19:24:37 <lambdabot>       `ExprArg a'
19:24:40 <dons> hmm
19:25:19 <Plouj> mauke: that's not what the error message says
19:25:38 <mauke> what is the error message?
19:25:45 <Cale> dons: oh, hmm
19:25:56 <Cale> dons: hehe, I don't know what's going on there.
19:26:21 <dolio> :t \f -> case (f :: (# Int, Int #)) of (# 1, 2 #) -> 3
19:26:22 <lambdabot>     Couldn't match kind `??' against `(#)'
19:26:22 <lambdabot>     When matching the kinds of `t :: ??' and `(# Int, Int #) :: (#)'
19:26:22 <lambdabot>       Expected type: (# Int, Int #)
19:26:23 <dons> oh, i wonder why its even showing in :t
19:26:27 <Plouj> mauke: http://paste.lisp.org/display/57109#1
19:26:35 <Cale> Oh, everything uses the exact same imports now.
19:26:39 <dons> ah ok
19:26:48 <dons> :t quickCheck undefined
19:26:49 <lambdabot>     Ambiguous type variable `a' in the constraint:
19:26:49 <lambdabot>       `Testable a'
19:26:49 <lambdabot>         arising from a use of `quickCheck' at <interactive>:1:0-19
19:26:54 <dons> ok
19:27:05 <mauke> Plouj: how is that not what the error message says?
19:27:31 <Plouj> it's talking about ++ receing the wrong argument
19:27:35 <mauke> the error message says 'show read' is a String but you're using it as a function [Char] -> [Char]
19:27:36 <Plouj> type
19:27:38 <mauke> by passing it another argument
19:27:48 <mauke> no
19:27:56 <Plouj> well, that makes no sense
19:28:15 <Plouj> what I though I was doing is passing the return value of read "35" to show
19:28:21 <adu> hi
19:28:25 <adu> i forgot what the difference between data and newtype was...
19:28:37 <luqui> adu, newtype gets no runtime representation
19:28:38 <mauke> Plouj: s/(show/show (/
19:28:58 <Plouj> humm, ok
19:28:59 <adu> luqui: does that mean you can't use it in pattern matching?
19:29:02 <Plouj> I'll add that to be sure
19:29:08 <luqui> adu, you can
19:29:17 <luqui> adu, it just is a synonym for the underlying type
19:29:31 <luqui> adu, but the constructor allows you to build recursive types and things that you can't do with synonyms
19:29:34 <adu> luqui: now i'm even more confused, I thought that was 'type'
19:30:14 <SamB> Cale: but how the heck did the constraint come into play?
19:30:15 <luqui> adu, I think of it as newtype builds a type synonym that needs a constructor, type builds one that doesn't
19:30:21 <Cale> SamB: I don't know.
19:30:22 <Plouj> now it's talking about some new variable a that I have no clue about: http://paste.lisp.org/display/57109#2
19:30:25 <Cale> @undef
19:30:25 <lambdabot> Undefined.
19:30:29 <adu> luqui oh ok
19:30:31 <Cale> :t \f' -> case f' of (# (1::Int), (2::Int) #) -> (3 :: Integer)
19:30:32 <lambdabot> Top level:
19:30:32 <lambdabot>     Couldn't match kind `(#)' against `??'
19:30:32 <lambdabot>     When matching the kinds of `(# Int, Int #) :: (#)' and `t :: ??'
19:30:39 <Cale> :t \f' -> case f' of (# 1, 2 #) -> 3
19:30:40 <lambdabot> Top level:
19:30:40 <lambdabot>     Couldn't match kind `(#)' against `??'
19:30:40 <lambdabot>     When matching the kinds of `(# t1, t2 #) :: (#)' and `t :: ??'
19:30:44 <Plouj> I guess they come from defintions of show and read...
19:30:57 <luqui> adu, but they're used just like data in most concievable ways (they're a bit different in strictness semantics)
19:30:59 <SamB> @scheck id = not . not
19:30:59 <lambdabot>  Parse error at "=" (column 4)
19:31:11 <SamB> @scheck id x == not . not $ (x :: I)
19:31:12 <lambdabot> Couldn't match expected type `Expr'
19:31:19 <SamB> @scheck \x -> id x == not . not $ (x :: I)
19:31:20 <lambdabot> Couldn't match expected type `a -> b' against inferred type `Bool'
19:31:28 <tensh> Plouj: show is trying to use read as input, and read is not a String
19:31:37 <SamB> @scheck \x -> id x == (not . not) (x :: I)
19:31:37 <lambdabot> Couldn't match expected type `I' against inferred type `Bool'
19:31:40 <luqui> adu, http://www.haskell.org/haskellwiki/Newtype
19:31:41 <lambdabot> Title: Newtype - HaskellWiki
19:31:42 <SamB> hmm.
19:31:46 <luqui> for further reading :-)
19:31:46 <SamB> silly me
19:31:52 <SamB> @scheck \x -> id x == (not . not) x
19:31:53 <lambdabot>   Completed 2 test(s) without failure.
19:31:57 <Plouj> tensh: why is it doing that?
19:32:02 <SamB> @scheck \x -> id x == not x
19:32:03 <lambdabot>   Failed test no. 1. Test values follow.: True
19:32:15 <SamB> @scheck \f x -> f x == not x
19:32:16 <lambdabot>       instance (Typeable a, Typeable b) => Show (a -> b)
19:32:16 <lambdabot>         -- Defined i...
19:32:23 <Cale> Plouj: show read "35"  means (show read) "35"
19:32:36 <SamB> Cale: okay, what's that then?
19:32:37 <tensh> Plouj: I haven't looked at the code, but seeing from what you pasted here it seems like you have done something like this: "show read n", am I right?
19:32:51 <Plouj> Cale: ok, I realized that was a problem with precedence rules I wasn't ware of
19:32:51 <adu> luqui: I'm writing a disassembler, and I'm wondering what the best way to represent instructions is... I'm thinking data Instr = Mov x y | Push x | Pop x ...
19:32:55 <Cale> Plouj: That is, take show, apply it to read, and then take the result and apply it to "35", which isn't well typed
19:33:09 <SamB> @scheck ($())
19:33:10 <lambdabot>       instance (Typeable a, Typeable b) => Show (a -> b)
19:33:10 <lambdabot>         -- Defined i...
19:33:19 <Cale> SamB: huh?
19:33:23 <Plouj> Cale: not to mention that it doesn't make sense and not what I wanted :)
19:33:39 <SamB> Cale: that's not what SmallCheck failures are supposed to look like!
19:33:41 <Plouj> tensh: something like show (read "N")
19:34:09 <tensh> Plouj: that should work
19:34:12 <tensh> well
19:34:13 <luqui> adu, that seams reasonable
19:34:31 <adu> luqui: yey, i'm not insane :)
19:34:34 <tensh> apart from the "N" bit ;)
19:34:54 <tensh> nm
19:35:47 <Plouj> is Haskell so obscure on purpose?
19:35:47 <mauke> read uses its surrounding type context to determine what to do
19:35:55 <mauke> show doesn't provide enough information
19:36:08 <luqui> Plouj, avoiding success at all costs, as they say :-)
19:36:13 <Cale> SamB: What are they supposed to look like?
19:36:29 <luqui> Plouj, more serously, sortof.  we want purity, no other languages get near purity, so we're unlike other languages
19:36:36 <Cale> SamB: hmm
19:37:03 <monochrom> @seez newsham
19:37:03 <lambdabot> newsham is in #haskell. I last heard newsham speak 40m 9s ago.
19:37:41 <monochrom> > \ x ->  f x
19:37:41 <lambdabot>  Add a type signature
19:37:47 <monochrom> > \ x ->  f x  :: Expr
19:37:48 <lambdabot>  <() -> SimpleReflect.Expr>
19:37:54 <luqui> I briefly used the unspoken isomorphism between myself and the Haskell language
19:37:58 <Plouj> luqui: purity of what?
19:38:11 <Cale> SamB: ah, SmallCheck defines its own Show instance for functions
19:38:21 <luqui> Plouj, referentially transparent lambda calculus.
19:38:26 <Cale> SamB: that's funny.
19:38:35 <SamB> Cale: I told you to remember about it!
19:38:47 <SamB> it's not a bit funny
19:39:04 <luqui> Plouj, a way I like to think of referential transparency is that you can run any part of the program at compile time and not get into trouble
19:39:14 <luqui> (any part that you have enough information to run, that is)
19:39:44 <Plouj> humm
19:40:21 <monochrom> > \ x y -> x + y :: Expr
19:40:21 <lambdabot>  <SimpleReflect.Expr -> SimpleReflect.Expr -> SimpleReflect.Expr>
19:40:32 <Cale> SamB: trying out a fix now
19:40:37 <Cale> @undef
19:40:37 <lambdabot> Undefined.
19:40:45 <Cale> @scheck ($())
19:40:45 <lambdabot> Add a type signature
19:40:48 <monochrom> > \ x -> x + 0 :: Expr
19:40:49 <lambdabot>  <SimpleReflect.Expr -> SimpleReflect.Expr>
19:40:52 <Cale> @scheck \f x -> f x == not x
19:40:53 <lambdabot>   Failed test no. 1. Test values follow.: {True->True;False->True}, True
19:40:53 <SamB> yeah, bad test
19:41:00 <SamB> much much better ;-)
19:41:12 <Plouj> ah, I'm not first to get this error after following the same steps: http://firstian.blogspot.com/2007/05/haskell-diary-day-1.html !
19:41:13 <lambdabot> Title: Finding My Cup of Tea: Haskell Diary, Day 1
19:41:21 <SamB> @check \f x -> f x == not x
19:41:22 <lambdabot>   add an instance declaration for (Show (Bool -> Bool))     In the expression...
19:41:26 <Cale> monochrom: Sorry, that's disabled at the moment.
19:41:28 <SamB> but now quickcheck doesn't work
19:41:34 <monochrom> Alright no problem :)
19:41:36 <SamB> > \f x -> f x == not x
19:41:36 <BMeph> Plouj: Your problem is that read "35" doesn't know what kind of result to make. That's what the "ambiguous 'a'" means. :)
19:41:37 <lambdabot>  <(Bool -> Bool) -> Bool -> Bool>
19:41:55 <SamB> > (+)
19:41:55 <lambdabot>  <Integer -> Integer -> Integer>
19:42:00 <Cale> SamB: okay, I need to add the ShowFun module explicitly to the import lists for things which need it now.
19:42:01 <SamB> > x+y
19:42:02 <lambdabot>  x + y
19:42:06 <Plouj> BMeph: I see
19:42:33 <SamB> I see you guys got the type display worked in with augustss' stuff. sweet.
19:42:52 <dons> cool
19:43:00 <Cale> SamB: No, I just turned augustss' stuff off for the moment.
19:43:03 <mauke> > \x -> x + y
19:43:04 <lambdabot>  <SimpleReflect.Expr -> SimpleReflect.Expr>
19:43:04 <Cale> @undef
19:43:04 <lambdabot> Undefined.
19:43:10 <Cale> @check \f x -> f x == not x
19:43:11 <lambdabot>  Falsifiable, after 2 tests: <Bool -> Bool>, False
19:43:12 <SamB> > \x y -> (x + y :: Expr)
19:43:13 <lambdabot>  <SimpleReflect.Expr -> SimpleReflect.Expr -> SimpleReflect.Expr>
19:43:16 <SamB> oh.
19:43:25 <SamB> > x+y
19:43:26 <lambdabot>  x + y
19:43:33 <SamB> why does that still work then?
19:43:38 <Cale> The basic SimpleReflect is still on.
19:43:38 <dons> > ord
19:43:39 <lambdabot>  <Char -> Int>
19:43:42 <SamB> ah.
19:43:50 <Plouj> I sort of cheated and googled for examples of using read and now I realize I need to do 'read "35":Int', but how would I figure that out from just having a definition of read: http://www.haskell.org/onlinereport/standard-prelude.html#$vread ?
19:43:51 <lambdabot> Title: The Haskell 98 Report: Standard Prelude
19:44:16 <mauke> Plouj: not easily
19:44:24 <mauke> the language definition is not a tutorial
19:44:31 <Cale> There were some bugs which Lennart likely wanted to work out anyway, and it was causing conflicts with SmallCheck, so I turned it off for now.
19:44:44 <luqui> Cale, how... did it make that function?
19:44:56 <SamB> Plouj: well, the fact that the compiler couldn't figure out what type to make it is a good clue
19:44:57 <luqui> in \f x -> f x == not x, that is
19:44:59 <luqui> is it using djinn?
19:45:05 <luqui> or...
19:45:10 <Cale> luqui: what?
19:45:18 <Cale> luqui: Randomly.
19:45:19 <luqui> you had quickcheck generate a function
19:45:23 <Cale> Yes.
19:45:30 <SamB> Cale: smallcheck doesn't use randomness
19:45:38 <Cale> Quickcheck has always been able to randomly produce functions.
19:45:44 <Plouj> SamB: heh, I don't mean picking Int vs Float or Bool, I mean how would I figure out to use the "::Int" syntax to get 'read "35"' to convert 35 to an integer
19:45:44 * luqui didn't know that
19:45:59 <BMeph> Plouj: To make sense of that definition, you'd need to read more of the standard. Hm, that sounds rather circular, but it IS true. :)
19:46:01 <Cale> That's what the coarbitrary function is for.
19:46:02 <SamB> It does an exaustive search of a certain space
19:46:05 <Cale> @type coarbitrary
19:46:06 <lambdabot> forall a b. (Arbitrary a) => a -> Gen b -> Gen b
19:46:26 <Cale> @check \f x -> f x == not x
19:46:27 <lambdabot>  Falsifiable, after 0 tests: <Bool -> Bool>, True
19:46:48 <SamB> @scheck \f x -> f x == not x
19:46:49 <lambdabot>   Failed test no. 1. Test values follow.: {True->True;False->True}, True
19:46:51 <SamB> @scheck \f x -> f x == not x
19:46:51 <lambdabot>   Failed test no. 1. Test values follow.: {True->True;False->True}, True
19:46:52 <SamB> @scheck \f x -> f x == not x
19:46:53 <lambdabot>   Failed test no. 1. Test values follow.: {True->True;False->True}, True
19:46:57 <SamB> same one, every time ;-P
19:47:00 <Cale> It transforms a Bool generator using the Bool input.
19:47:03 <SamB> also, it tells you WHICH one.
19:47:11 <SamB> which is really sweet.
19:47:31 <Cale> It's pretty likely that quickcheck could do that.
19:47:32 <Plouj> I wish they taught haskell at my school
19:47:38 <SamB> Cale: it could
19:47:57 <Cale> SamB: Yeah, just show the values at which the function gets called.
19:48:11 <BMeph> Plouj: So do we - it'd mean more jobs for Haskellers, for one. ;)
19:48:19 <Cale> and the (arbitrary) results that got returned
19:48:20 <SamB> well, it couldn't do exactly what smallcheck does...
19:48:33 <SamB> could it?
19:48:39 <Cale> Roughly yes.
19:48:49 <Cale> Even for functions with infinite domains.
19:49:05 <Cale> Might require a bit of evil.
19:49:19 <SamB> whoa, neat.
19:49:33 <SamB> If I load SmallCheck and type maybe...
19:49:38 <SamB> it prints this:
19:49:39 <SamB> {()->{{()->()}->{Nothing->();Just ()->()}}}
19:50:29 <Cale> @scheck maybe
19:50:30 <lambdabot> Add a type signature
19:50:48 <SamB> Cale: I typed just "maybe"
19:50:58 <SamB> as in, I used SmallCheck's show to show maybe
19:51:04 <Cale> ah
19:51:18 <Cale> That's what you mean :)
19:51:22 <SamB> maybe we should add a command to invoke smallcheck's show instance?
19:51:56 <Cale> I'm confused enough as it is about which modules get loaded and how they interact :)
19:51:58 <Cale> hehe
19:52:19 <tromp_> @check 0^n == 0
19:52:22 <SamB> well, it would be just like the @scheck
19:52:24 <monochrom> overlapping instance is evil!
19:52:25 <lambdabot> Terminated
19:52:33 <tromp_> @scheck 0^n == 0
19:52:37 <Cale> SamB: Yeah, I suppose that'd work :)
19:52:38 <lambdabot> Done.
19:52:41 <SamB> except instead of invoking smallCheck n, it would invoke show
19:52:51 <tromp_> > 0^0
19:52:52 <lambdabot>  1
19:52:52 <luqui> @scheck \f x -> f x == x
19:52:53 <lambdabot>   Completed 1 test(s) without failure.
19:52:59 <luqui> @scheck \f x -> f x == (x :: Bool)
19:52:59 <lambdabot>   Failed test no. 2. Test values follow.: {True->True;False->True}, False
19:53:03 <Cale> @check \n -> 0^n == 0
19:53:03 <lambdabot>  Falsifiable, after 0 tests: 0
19:53:07 <Cale> @scheck \n -> 0^n == 0
19:53:08 <lambdabot>   Failed test no. 1. Test values follow.: 0
19:53:08 <luqui> @scheck \f x -> f x == True
19:53:09 <lambdabot>   Failed test no. 2. Test values follow.: {()->False}, ()
19:53:16 <luqui> @scheck \f x -> f (x :: Bool) == True
19:53:16 <lambdabot>   Failed test no. 4. Test values follow.: {True->True;False->False}, False
19:53:30 <luqui> whee this is fun
19:53:38 <tromp_> @check \n -> (0^n == 0)
19:53:38 <lambdabot>  Falsifiable, after 0 tests: 0
19:53:38 <gwern> @where greencard
19:53:38 <lambdabot> I know nothing about greencard.
19:53:59 <gwern> 'sblood!
19:54:31 <luqui> heh
19:54:50 <gwern> this program wants greencard, whose last release was in *2003*?
19:55:02 <gwern> goddamn my balls a million times, as the Flemish curse goes
19:55:39 <wagle_home>  > 2008 - 2003
19:55:56 <wagle_home> <lambdabot> a billion years
19:55:59 <Cale> gwern: That's what happens when you go digging through people's old unmaintained bitrotting software.
19:56:23 <gwern> Cale: this code is from Google Code! Google Code didn't even exist in 2003!
19:57:21 <lament> hey, come on, only 2003, when was the last release of TeX?
19:57:48 <lament> (checking... 2002. Not much difference)
19:58:07 <gwern> dec 2002
19:58:40 <lament> but that's clearly not a reason not to use tex :D
19:59:07 <tromp_> @check \n -> n < 1000000
19:59:07 <lambdabot>  OK, passed 500 tests.
19:59:14 <tromp_> @check \n -> n < 100000
19:59:14 <gwern> the last release of the tex which people actually use (latex) was in 2004 or so
19:59:14 <lambdabot>  OK, passed 500 tests.
19:59:18 <tromp_> @check \n -> n < 10000
19:59:18 <lambdabot>  OK, passed 500 tests.
19:59:22 <tromp_> @check \n -> n < 1000
19:59:22 <lambdabot>  OK, passed 500 tests.
19:59:28 <tromp_> @check \n -> n < 100
19:59:29 <lambdabot>  Falsifiable, after 277 tests: 103
19:59:33 <wagle_home> rofl
19:59:33 <gwern> but in this case, the 2003 release of greencard was an alpha version, not even a stable
19:59:34 <tromp_> cute:)
19:59:38 <dmwit> Haskell has a handicap in these competitions with small inputs.
19:59:48 <SamB> whoa, nasty...
19:59:56 <Cale> @scheck \n -> n < 1000
19:59:57 <lambdabot>   Completed 13 test(s) without failure.
19:59:59 <dons> dmwit: ?
20:00:00 <dmwit> It takes 20ms just to start up a program, so it has no chance of demolishing those 0ms C++ programs...
20:00:10 <dons> 20ms huh.
20:00:27 <tromp_> @check \n -> n > -100
20:00:27 <lambdabot>  Falsifiable, after 276 tests: -120
20:00:33 <dons> $ time ./a.out
20:00:33 <dons> ./a.out  0.00s user 0.00s system 0% cpu 0.006 total
20:00:36 <gwern> but I don't unerstand - greencard is still searched for in Cabal's configuration; how could an ostensibly important program be MIA since 2003?
20:00:39 <SamB> dmwit: we could use JHC for those
20:00:52 <dmwit> dons: 20ms on the judge machine, with no optimizations.
20:01:01 <dons> oh, no optimisations wtf?
20:01:06 <SamB> gwern: is it MIA?
20:01:09 <gwern> SamB: assuming JHC compiles, and can compile the programs of interest
20:01:11 <dons> {-# OPTIONS -O2 #-} :)
20:01:13 <tromp_> @check \l -> l!!20
20:01:14 <lambdabot>  Arguments exhausted after 0 tests.
20:01:17 <dmwit> =)
20:01:21 <dons> SamB: not on the judges machine
20:01:21 <wagle_home> oh oh..  gwern was born before 2003..
20:01:38 <SamB> dons: what the heck?
20:01:46 <SamB> skip the stupid contest
20:01:52 <gwern> SamB: http://www.haskell.org/greencard/ <-- looks like the official homepage, last release in 2003, and I suspect it doesn't work with 6.8.x
20:01:53 <lambdabot> Title: GreenCard: A Haskell Foreign Function Interface Preprocessor
20:02:01 <dmwit> SamB: fair enough
20:02:05 <tromp_> @check \(_:_:_:_:_:a:[]) ->a
20:02:05 <lambdabot>  Arguments exhausted after 0 tests.
20:02:17 <tromp_> @check \(a:[]) -> a
20:02:17 <lambdabot>  Arguments exhausted after 0 tests.
20:02:33 <tromp_> @check \(a:[]) -> a == True
20:02:34 <lambdabot>   Non-exhaustive patterns in lambda
20:02:50 <tromp_> @check \a -> head a == True
20:02:51 <lambdabot>  Falsifiable, after 1 tests: [False]
20:03:13 <wagle_home> so fix it..  (and dont procrastinate like i am with 6.8.2 ppc/10.5
20:03:21 <tromp_> @check \a -> head . tail . tail . tail $ a == True
20:03:21 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Bool'
20:03:42 <tromp_> @check \a -> (head . tail . tail . tail) a == True
20:03:43 <lambdabot>  Exception: Prelude.tail: empty list
20:03:45 <dibblego> @check \x -> x == (x == True)
20:03:46 <lambdabot>  OK, passed 500 tests.
20:03:54 <dibblego> please stop writing == True :)
20:04:11 <tromp_> sorry:(
20:04:21 <tromp_> @check \a -> (head . tail . tail . tail) a
20:04:22 <lambdabot>  Arguments exhausted after 0 tests.
20:04:24 <dibblego> what are you trying to do?
20:04:46 <tromp_> getting failure with [False,False,False,False]
20:04:58 <dibblego> why would that fail?
20:05:25 <dmwit> ?check \a -> a !! 3 -- equivalent
20:05:25 <lambdabot>  Arguments exhausted after 0 tests.
20:05:30 <tromp_> yields False
20:05:52 <dmwit> Right, not all lists have "True" in their 3rd position.
20:06:18 <tromp_> why doesn't it answer Falisfiable?
20:06:25 <dolio> Interesting. QuickCheck captures bottoms and treats them like a ==>.
20:06:28 <dmwit> ?check \a -> length a > 3 ==> a !! 3
20:06:29 <lambdabot>  Arguments exhausted after 0 tests.
20:06:39 <dolio> tromp_: It has to do with the way quickcheck generates test cases.
20:07:10 <dolio> It starts at small values, and increses the size of the values based on the number of passed tests.
20:07:24 <tromp_> @check \l-> length l < 2
20:07:24 <lambdabot>  Falsifiable, after 4 tests: [(),()]
20:07:32 <tromp_> @check \l-> length l < 6
20:07:33 <lambdabot>  Falsifiable, after 6 tests: [(),(),(),(),(),()]
20:07:36 <SamB> Cale: try this
20:07:36 <dolio> So it's possible to write preconditions such that it never generates values big enough to satisfy the preconditions.
20:07:39 <SamB> *SmallCheck Test.QuickCheck> quickCheck $ \f xs -> f xs == (sum xs :: Double)
20:07:48 <tromp_> @check \l-> length l < 17
20:07:48 <lambdabot>  Falsifiable, after 47 tests: [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(...
20:08:28 <tromp_> @check \l-> l!!4 == 0
20:08:29 <lambdabot>  Exception: Prelude.(!!): index too large
20:08:29 <SamB> Cale: after a few tries it will probably produce an input list that isn't even included in the displayed function domain...
20:08:49 <luqui> @check  \l -> length (l :: Integer) < 17
20:08:50 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Integer'
20:08:50 <tromp_> @check \l-> l!!0 == 0
20:08:51 <lambdabot>  Falsifiable, after 0 tests: [-1,0]
20:09:00 <luqui> @check  \l -> length (l :: [Integer]) < 17
20:09:01 <lambdabot>  Falsifiable, after 44 tests: [21,-20,20,-10,-24,10,8,-14,8,14,-16,-23,-17,-2...
20:09:05 <dolio> At least, with the default generator. That's all customizable when you use it yourself.
20:09:09 <tromp_> @check \l-> l!!2 == 0
20:09:10 <lambdabot>  Exception: Prelude.(!!): index too large
20:09:13 <luqui> @check  \l -> sum (l :: Integer) > 1000
20:09:13 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Integer'
20:09:17 <luqui> @check  \l -> sum (l :: [Integer]) > 1000
20:09:18 <lambdabot>  Falsifiable, after 0 tests: [1,2]
20:09:20 <luqui> haha again
20:09:27 <luqui> @check  \l -> sum (l :: [Integer]) < 1000
20:09:28 <tromp_> > []!!(-1)
20:09:28 <lambdabot>  Falsifiable, after 358 tests: [117,-131,-105,-9,-173,-95,135,97,-40,86,-36,1...
20:09:28 <lambdabot>  Exception: Prelude.(!!): negative index
20:10:15 <SamB> how does QuickCheck generate functions over Double, anyway?
20:11:03 <luqui> @check  \f -> (f (0 :: Double) :: Double) /= f 1
20:11:03 <lambdabot>  Falsifiable, after 2 tests: <Double -> Double>
20:11:20 <dons> SamB: by lifting the Random class
20:11:24 <luqui> @check  \f -> (f (0 :: Double) :: Double) /= f 1 || f 0 == f 2
20:11:25 <lambdabot>  Falsifiable, after 254 tests: <Double -> Double>
20:11:27 <dons> it would benefit from using a good random gen
20:11:51 <luqui> @scheck  \f -> (f (0 :: Double) :: Double) /= f 1 || f 0 == f 2
20:11:57 <lambdabot> Done.
20:12:07 <luqui> ha, gotcha!
20:12:14 <dolio> Well, now I'm confused. Why is 'check \l -> l !! 3' treated as having a precondition?
20:14:33 <cpfr> luqui, scheck == smallcheck ?
20:14:33 <dmwit> It probably throws an exception on the first attempt.
20:14:39 <dmwit> cpfr: yes
20:14:56 <dolio> @check \l -> (l :: [Bool]) !! 3
20:14:57 <lambdabot>  Exception: Prelude.(!!): index too large
20:14:59 <dmwit> ?check \l -> any l
20:14:59 <lambdabot>  Falsifiable, after 0 tests: <() -> Bool>, []
20:15:05 <dolio> What is l defaulting to?
20:15:14 <dmwit> ?check \l -> or l
20:15:14 <lambdabot>  Falsifiable, after 0 tests: []
20:15:25 <dolio> @check ()
20:15:25 <lambdabot>  Arguments exhausted after 0 tests.
20:15:30 <dolio> I guess that's what.
20:15:50 <dmwit> ?check \l -> (l :: ()) !! 3 -- what?
20:15:51 <lambdabot>  Couldn't match expected type `[a]' against inferred type `()'
20:15:53 <SamB> @scheck ()
20:15:53 <lambdabot>       add an instance declaration for (SmallCheck.Testable ())
20:15:53 <lambdabot>     In the exp...
20:16:00 <SamB> @scheck []
20:16:00 <lambdabot>       add an instance declaration for (SmallCheck.Testable [a])
20:16:00 <lambdabot>     In the ex...
20:16:03 <SamB> @scheck False
20:16:04 <lambdabot>   Failed test no. 1. Test values follow.:
20:16:06 <dmwit> ?check \l -> (l :: [()]) !! 3 -- what?
20:16:06 <lambdabot>  Arguments exhausted after 0 tests.
20:16:07 <dolio> @check \l -> (l :: [()]) !! 3
20:16:08 <lambdabot>  Arguments exhausted after 0 tests.
20:16:10 <SamB> @scheck True
20:16:10 <lambdabot>   Completed 1 test(s) without failure.
20:17:11 <tromp_> @check \a b c n->a^n+b^n=c^n
20:17:11 <lambdabot>  Parse error at "=c^n" (column 18)
20:17:16 <tromp_> @check \a b c n->a^n+b^n==c^n
20:17:17 <lambdabot>  Exception: Prelude.^: negative exponent
20:18:03 <tromp_> @check \a b c->a^2+b^2!=c^2
20:18:03 <lambdabot>   Not in scope: `!='
20:18:04 <SamB> @check \a b c n-> a > 0 ==> a^n+b^n==c^n
20:18:05 <lambdabot>  Falsifiable, after 0 tests: 1, -1, 1, 1
20:18:09 <tromp_> @check \a b c->a^2+b^2\=c^2
20:18:09 <lambdabot>   Not in scope: `\='
20:18:15 <tromp_> @check \a b c->a^2+b^2/=c^2
20:18:15 <lambdabot>  Falsifiable, after 2 tests: 0, 0, 0
20:18:16 <SamB> @check \a b c n-> a > 0 ==> a^n+b^n /= c^n
20:18:17 <lambdabot>  Exception: Prelude.^: negative exponent
20:18:24 <SamB> @check \a b c n-> n > 0 ==> a^n+b^n /= c^n
20:18:25 <lambdabot>  Falsifiable, after 6 tests: 2, 0, 2, 1
20:19:03 <SamB> @check \a b c n-> n > 1 ==> a^n+b^n /= c^n
20:19:04 <lambdabot>  Falsifiable, after 28 tests: -6, 0, 6, 6
20:19:28 <luqui> @check ()
20:19:29 <lambdabot>  Arguments exhausted after 0 tests.
20:19:39 <SamB> @check \a b c n-> all (>0) [a,b,c,n] ==> a^n+b^n /= c^n
20:19:40 <lambdabot>  Falsifiable, after 1 tests: 1, 1, 2, 1
20:19:41 <tromp_> @check \a b c n->a<=0 || b<=0 || c<=0 || n<=2 ||a^n+b^n/=c^n
20:19:41 <lambdabot>  OK, passed 500 tests.
20:19:59 <tromp_> there, fermat proved:)
20:20:08 <wagle_home> @check \a b c n -> n > 2 ==> a^n+b^n == c^n
20:20:09 <lambdabot>  Falsifiable, after 0 tests: -2, -1, 2, 3
20:20:28 <SamB> @check \a b c n-> all (>0) [a,b,c,n-1] ==> a^n+b^n /= c^n
20:20:29 <lambdabot>  Arguments exhausted after 13 tests.
20:20:35 <SamB> @scheck \a b c n-> all (>0) [a,b,c,n-1] ==> a^n+b^n /= c^n
20:20:35 <lambdabot> Done.
20:21:28 <tromp_> @check \a b -> a^2+b^2 == 19
20:21:29 <lambdabot>  Falsifiable, after 0 tests: 0, 0
20:21:32 <tromp_> @check \a b -> a^2+b^2 /= 19
20:21:33 <lambdabot>  OK, passed 500 tests.
20:21:43 <tromp_> @check \a b c -> a^2+b^2+c^2 /= 19
20:21:44 <lambdabot>  Falsifiable, after 56 tests: 3, 3, -1
20:22:00 <tromp_> @check \a b c -> a^2+b^2+c^2 /= 191
20:22:01 <lambdabot>  OK, passed 500 tests.
20:22:22 <tromp_> @check \a b c -> a^2+b^2+c^2 /= 190
20:22:23 <lambdabot>  Falsifiable, after 33 tests: -3, 10, -9
20:23:08 <dolio> @check \i -> i < 3000
20:23:08 <lambdabot>  OK, passed 500 tests.
20:23:15 <dolio> Maximum number found.
20:23:24 <allbery_b> heh
20:24:31 <tromp_> i found a smaller maximum number earlier:)
20:24:43 <dolio> 24?
20:24:56 <tromp_> @check \i->i<1000
20:24:56 <lambdabot>  OK, passed 500 tests.
20:24:59 <dolio> What about 18?
20:25:05 <dmwit> ?check \i -> i < 200
20:25:06 <lambdabot>  OK, passed 500 tests.
20:25:09 <tromp_> @check \i->i<143
20:25:10 <lambdabot>  Falsifiable, after 421 tests: 180
20:25:21 <tromp_> @check \i->i<190
20:25:21 <lambdabot>  Falsifiable, after 484 tests: 190
20:25:25 <dolio> http://au.youtube.com/watch?v=f3ek85X2uOE
20:25:26 <lambdabot> Title: YouTube - Mr. Show - Biggest Number
20:25:32 <tromp_> @check \i->i<191
20:25:32 <lambdabot>  OK, passed 500 tests.
20:25:37 <TSC> > head [ (a,b,c) | a <- [0..], b <- [0 .. a], c <- [0 .. b], a^2+b^2+c^2 == 190] -- come on, be exhaustive
20:25:37 <lambdabot>  (10,9,3)
20:25:40 <dmwit> The person to find the smallest maximum number will be deemed the luckiest. =)
20:25:45 <dmwit> ?check \i -> i < 180
20:25:46 <lambdabot>  Falsifiable, after 478 tests: 232
20:25:53 <dmwit> ?check \i -> i < 180
20:25:54 <lambdabot>  Falsifiable, after 427 tests: 181
20:25:59 <dmwit> Aw, shoot.
20:26:06 <wagle_home> maxBound :: Bit
20:26:12 <wagle_home> > maxBound :: Bit
20:26:13 <lambdabot>   Not in scope: type constructor or class `Bit'
20:26:20 <wagle_home> bah
20:26:22 <dmwit> > maxBound :: Bool
20:26:22 <lambdabot>  True
20:26:28 <dmwit> > maxBound :: Word1
20:26:28 <lambdabot>   Not in scope: type constructor or class `Word1'
20:26:49 <wagle_home> maxBound :: Unary
20:26:56 <wagle_home> > maxBound :: Unary
20:26:57 <lambdabot>   Not in scope: type constructor or class `Unary'
20:27:08 <dmwit> What would you event want that to be?
20:27:12 <tromp_> > maxBound :: ()
20:27:13 <lambdabot>  ()
20:27:25 <wagle_home> i vote tromp_ wins
20:27:38 <dmwit> oh.
20:27:42 <dmwit> Now I get it. =)
20:27:48 <dmwit> > maxBound :: Void
20:27:48 <lambdabot>   Not in scope: type constructor or class `Void'
20:28:09 <wagle_home> > maxBound :: undefined
20:28:09 <lambdabot>        add (Bounded undefined) to the context of
20:28:09 <lambdabot>         the polymorphic type...
20:28:26 <dmwit> > maxBound :: a -- equivalent
20:28:27 <lambdabot>        add (Bounded a) to the context of
20:28:27 <lambdabot>         the polymorphic type `forall...
20:28:52 <wagle_home> maxBound :: bottom
20:29:03 <dmwit> same
20:29:04 <wagle_home> nm
20:29:08 <SamB> @scheck \s -> (s :: [Int]) == (reverse . reverse) s
20:29:09 <lambdabot>   Completed 25059 test(s) without failure.
20:35:12 <SamB> Cale: should look at adding lazy smallcheck support sometime...
20:35:49 <dmwit> > let digit r = div (10*numerator r) (denominator r); digits n = digit n : digits (10 * n - fromIntegral (digit n)) in digits (1%9)
20:35:49 <dons> gwern: want to put smallcheck on hackage?
20:35:49 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
20:36:41 <dmwit> > iterate (\n -> 10 * n - 1) (1/9)
20:36:42 <lambdabot>  [0.1111111111111111,0.11111111111111105,0.1111111111111105,0.111111111111104...
20:37:30 <gwern> dons: isn't it there already?
20:37:57 <SamB> gwern: nope
20:37:58 <dons> nope.
20:38:17 <dons> Lemmih: happs on ohloh, http://www.ohloh.net/projects/8196/analyses/latest :)
20:38:17 <lambdabot> Title: HAppS - Ohloh
20:38:24 <gwern> huh. sure; as a recent release, couldn't be too hard
20:38:33 <gwern> more fun than hacking greencard's makefiles nayway
20:38:37 <gwern> @where smallcheck
20:38:37 <lambdabot> http://www.cs.york.ac.uk/fp/smallcheck0.2.tar
20:38:52 <gwern> ;hm. surely that's not right
20:41:02 * wli suggests using some sort of probability distribution in tandem with the bounding interval.
20:41:10 <gwern> doesn't it have a darcs repo somewhere?
20:42:02 <gwern> ah, there we go. for once a site search wasn't crappy!
20:42:06 <gwern> @where+ smallcheck http://www.cs.york.ac.uk/fp/darcs/smallcheck/
20:42:06 <lambdabot> Good to know.
20:42:20 * wli has heard rumors that the bounding intervals in interval arithmetic tend to suck.
20:43:56 <gwern> dons: no go. no license information
20:44:17 <gwern> the ANN emails mention nothing on licenses as well
20:44:54 <wli> roconnor had a different idea, which was to use laziness in order to compute inputs to the precision necessary for the output to have the precision demanded of it by the caller.
20:45:17 <dons> gwern: ndm will know.
20:45:35 <gwern> @seen ndm
20:45:35 <lambdabot> I saw ndm leaving #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 13h 35m 25s ago, and .
20:46:27 <gwern> I'll just email runciman
20:47:21 <dons> cc. ndm.
20:47:27 <dons> cr rarely responds to mail
20:47:37 <dons> its usually easier to get one of his phd students to chase him
20:47:37 <gwern> oh dear.
20:47:52 <dons> such as ndm or naylor
20:47:58 <gwern> lol?
20:48:07 <gwern> oh, he's ndm's advisor? cool
20:54:33 <gwern> ok, sent
20:54:39 <gwern> not as easy as it looked, heh
21:03:13 <sclv> did anyone ever take over maintainership of the collections package?
21:04:14 <gwern> ok. so greencard now works again
21:05:16 <dons> sclv: good question
21:05:32 <sclv> it seems like an excellent soc project, is why.
21:05:50 <dons> well, at this point, it needs a careful hand
21:07:24 <sclv> well, maybe adrian hey would have time for light mentoring if not maintainership?
21:08:22 <sclv> splitting out the clean stuff, implementing the standard api for it, and running benchmarks seems like a reasonable goal.
21:09:16 <BMeph> Just curious, but how much do that package and Edison overlap?
21:09:20 <dons> sclv: yep.
21:09:25 <dons> BMeph: a lot, iirc
21:09:36 <dons> sclv: we need to get ashley and jyp on board
21:09:45 <dons> its all in the benchmarking
21:09:55 <dons> iirc jyp reckons we can out do Data.Map
21:10:17 <adu> For my disassembler, should I put my libraries under 'Debug.', 'Trace.' or 'Foreign.'?
21:18:12 <sclv> the other thing i'd really like to see and am considering making a soc proposal about is work on the mtl, since it is the standard after all... pulling together a general monadBase suitable for the mtl, with caughtMonadBase generalizing gCatch over any monad base, and a set of simple primitives that would allow the creation of, e.g., gAtomically, etc.
21:18:49 <sclv> it seems maybe a bit researchy for soc, but doesn't seem insanely so? lots of the pieces are there -- just haven't been pulled together.
21:18:51 <dons> its a pity that monadLib is the only active mtl-alike
21:18:55 <dons> but noone uses it (bar hpaste)
21:19:12 <dons> maybe too researchy .. also, how many soc students could grok it?
21:19:27 <dons> then again, soc students are surprising
21:20:04 <sclv> mtl is part of the stdlibs though, so fixing it seems a very sane thing to do... but it requires work, and not all of it fun.
21:20:48 <roconnor> why don't we all just use monadLib?
21:21:40 <dons> we could
21:21:56 <roconnor> problem solved. :)
21:21:58 <dons> the mtl maintainers and monadlib maintainers sit next to each other
21:22:11 <dons> and the monadLib maintainer's supervisor is the mtl designer
21:22:32 <roconnor> dons: can you ask the mtl people what's up with their choice of methods in the classes?
21:22:36 * dons has a bag of little known ironies of the haskell world
21:22:46 <dons> roconnor: ask mpj
21:23:04 <yav> mark didnt pick the names :-)
21:23:11 <roconnor> I mean, what's up with pass?
21:23:18 <roconnor> why is it there
21:23:28 <dons> actually, that's right, some of the names are quite different to hte paper
21:23:41 <roconnor> there is no pass in the paper cited.
21:23:43 <yav> i think that the names in monadlib are a bit nicer
21:24:00 <yav> but, of course, i am biased
21:24:23 <sclv> oerjan came up with a handy use for pass for me the other day. but then i realized i didn't want it after all... :-)
21:25:01 * roconnor want's ContT Writer to be a Writer Monad.
21:25:04 <roconnor> wants
21:26:04 <yav> i think that this instance is in monadLib
21:26:06 <roconnor> I can only assume that pass was just made up by someone for no reason other than to prevent ContT Writer from being a Writer. :D
21:26:47 <roconnor> yav: correct, monadLib doesn't have all these random functions tacked onto the classes.
21:27:08 <yav> actually it does, but they are split into more classes
21:27:24 <roconnor> oh
21:27:27 <Cale> We really should take monadLib, fix it up a bit into something perfect, and then replace the MTL with it.
21:27:31 <roconnor> well then :)
21:27:41 <yav> for example WriterM and RunWriterM
21:27:54 <glguy> class (WriterM m i) => RunWriterM m i | m -> i where
21:27:56 <glguy>   collect :: m a -> m (a, i)
21:28:16 <Cale> There's still a few subtle things which monadLib gets a bit wrong, and I'd have to check if all the interactions are the right ones.
21:28:26 <sclv> I suppose ExceptionM eliminates the need for gcatch?
21:28:48 <yav> Cale: bug-reports are most welcome :-)
21:29:24 <dons> monadLib has a lot of good will, for a project no one uses :)
21:29:27 <Cale> yav: Well, one thing is that it would be better to use (s,a) than (a,s) in your pairs.
21:29:36 <dons> that seems like a good thing, if we could get the momentum to replace mtl
21:29:40 <Cale> This is because (,) s is a Functor.
21:29:49 <dons> yav, maybe *you'd* like to help coordinate a SoC project to clean/replace mtl?
21:29:50 <roconnor> dons: I would never use mtl for a new project.
21:30:10 <roconnor> ... granted I haven't used monadLib yet
21:30:12 <Cale> another thing to check is whether StateT over Cont is the same as ContT over State.
21:30:18 <dons> for something like xmonad, mtl is still required, since its prebuild on all distros
21:30:29 <Cale> If it is, like it is in the MTL, I think that's not really the best design choice possible.
21:30:53 <glguy> Cale: we talked about that one last night
21:30:56 <glguy> it's different
21:31:03 <roconnor> Cale: aren't StateT and ContT well defined?
21:31:31 <Cale> roconnor: The lifting instances can be done in different ways.
21:31:45 <dolio> And polymorphic callCC :: ((a -> (forall b. m b)) -> m a) -> m a
21:32:13 <dolio> Or would that rule it out of... Hugs?
21:32:15 <Cale> In the MTL, they go out of their way to make ContT State the same as StateT Cont, but I think that's wrong.
21:32:16 <dons> yav, don't forget daylight savings
21:32:17 <roconnor> Cale: I'm surprised there is a choice. :)
21:32:30 <roconnor> Cale: that does sound wrong.
21:32:32 <yav> i was just complaining about it to glguy :-)
21:32:39 <dons> hehe
21:32:46 <dons> the sun sure sets late. surprised me.
21:33:13 <glguy> yav: were you privmsg'ing me?
21:33:18 <sclv> it would be really nice if monadlib provided MaybeT by default, as well.
21:33:35 <dons> oh, yes. MaybeT missing is a bit of a gripe. that would provide another incentive to monadLib
21:33:37 <yav> glguy: yeah, nothing important though
21:33:40 <dons> the missing monads of mtl.
21:33:52 <glguy> yav: the messages didn't come through as you aren't registered with nickserv I'd imagine
21:34:04 <yav> oh yeah
21:34:05 <Cale> Also, LogicT really deserves to be in there.
21:34:19 <Cale> LogicT is incredibly nice.
21:34:21 <BMeph> But renamed ListT. ;)
21:34:28 <yav> we have ChoiceT
21:34:32 <Cale> No, ListT should just be removed.
21:34:33 <yav> it sounds the same :-)
21:34:35 <glguy> OptionT
21:34:46 <dons> LogicT sounds cooler
21:34:51 <yav> FreedomT?
21:34:51 <BMeph> NonDeterministicT? ;)
21:34:59 <dons> yav, *yeah*!
21:35:03 <BMeph> QuantumT! ;p
21:35:07 <glguy> HandcuffsT
21:35:11 <Cale> yav: ChoiceT seems to be missing the fair composition operators.
21:35:27 <Cale> yav: I'm not saying they can't be implemented...
21:35:38 <yav> whats the type of the operator?
21:36:04 <Cale> There's one like bind, there's one like mplus...
21:36:24 <dolio> http://hackage.haskell.org/packages/archive/logict/0.2.3/doc/html/Control-Monad-Logic-Class.html
21:36:28 <lambdabot> http://tinyurl.com/37f4ga
21:36:30 <Cale> They do a kind of interleaving, so even if the first thing produces infinitely many results, you don't get stuck on one.
21:36:46 <Cale> yes, look at that :)
21:37:13 <Cale> ifte and once are also quite good, and all of them are implementable in terms of msplit.
21:37:45 <dons> Cale, you'd be a good candidate to contribute to monadLib
21:38:04 <dons> if we ever want to make the mtl endgame happen.
21:38:06 <yav> yeah, monadLib is missing something like 'msplit' --- i have been thinking of how to add it, but a bunch of the liftings are not obious
21:38:11 <glguy> msplit seems like it would be the "RunChoiceM"
21:38:33 <yav> yeah, that's what's missing
21:39:13 <glguy> didn't we draw this one up on the whiteboard a month back?
21:39:36 <yav> also, i think that for these kinds of applications, it would be good to have some kind og "strategy" language that descibes how you want to search for answers
21:39:43 <Cale> I would just steal LogicT and its implementation wholesale.
21:39:46 <sclv> dunno if gCatch is necessary... but the same mechanism or variants thereof let you also do interesting things for monads built on, e.g., STM (not just gAtomically, but also gOrElse and gAlways, among others) or other base monads with similar functions... this idea's just been dawning on me. not quite ready for primetime, but I suppose I can just hack away at it for a while...
21:41:12 <yav> glguy: which one?
21:43:32 <dolio> yav: Do you mean lifting msplit into, say, (ReaderT r Choice) is hard?
21:43:56 <dolio> yav: I ended up implementing all the various logical operators by lifting individually, rather than lifting msplit.
21:44:20 <dolio> Since they didn't work right using the default definitions with my lifted msplit.
21:44:29 <dolio> Or, at least, some didn't. Perhaps not ReaderT.
21:45:03 <yav> yeah
21:45:18 <yav> the problem is that you can write the lifitngs, but often the behavior is very surprising
21:45:36 <gwern> ironic. you need greencard to install greencard
21:46:19 <gwern> despite how I have the section which compiles the greencard executable listed before the library sections which requires a greencard binary!
21:46:24 * BMeph hates out-of-date bootstraping programs
21:47:31 <gwern> BMeph: actually, this is more a cabal failing - it's a case where compiling in sections leads to an error, not merely an inefficiency (like when you have to compile the library several times)
21:47:49 <gwern> it *could* work, the binary it needs is there. just, cabal won't
21:50:05 * BMeph still hates out-of-date bootstraping programs, though greencard may not one in particular
21:50:33 <BMeph> s/not/not be/
21:50:51 <shteou> Howdy.
21:50:59 <gwern> BMeph: well, it does do it kind of ugly, with ../s galore, but it could easily have been written to compile greencard-bin, install, and then compile the library normally with whatever greencard it finds in $PATH like normal
21:51:18 <shteou> Hmm, anyone familiar with the G-Machine implemented in YHC?
21:53:16 * gwern isn't
22:00:34 <gwern> http://hackage.haskell.org/trac/hackage/ticket/89#comment:4 <-- annoying. very annoying. oh so annoying
22:00:39 <lambdabot> Title: #89 (Sharing of object files between executable builds?) - Hackage - Trac
22:00:46 <shteou> heh, didn't think there would be at this time I guess :)
22:01:21 <gwern> shteou: it's late in the US and europe
22:01:49 <shteou> Indeed, most of the people I know who work with it are from the UK.
22:01:55 <shteou> I'm just up a little late :s
22:11:50 <shteou> Hmm, think I sorted my problem actually.
22:14:58 <shteou> Think I just shaved 40% size off all binary operations.  I'll ask about it tomorrow :x Not sure if I understand how this G-Machine works entirely heh.
22:17:49 <crutcher> Hi. I find myself needing this function a lot:  f .< g = curry (f . (uncurry g))
22:18:03 <crutcher> is there any precedent for this?
22:18:16 <crutcher> is there some standard means of doing this?
22:18:45 <dmwit> :t \f g -> curry (f . (uncurry g))
22:18:47 <lambdabot> forall c a b c1. (c1 -> c) -> (a -> b -> c1) -> a -> b -> c
22:19:10 <crutcher> yes, I know I can write it out.
22:19:22 <dmwit> :t \f g -> f . g
22:19:23 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
22:19:30 <dmwit> bwuh?
22:20:08 <dmwit> Oh, I see.
22:20:29 <crutcher> oh, you were talking to lambdabot
22:21:11 <crutcher> especially when I'm trying to do point-free style, I find myself wanting that func all the time.
22:21:45 <crutcher> and there seems to be lots of occurances of that pattern in haskell code that I see.
22:22:07 <BMeph> Ah, yes, that's (.).(.)
22:22:32 <crutcher> :t (.).(.)
22:22:33 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
22:22:47 <BMeph> o.O
22:23:15 <BMeph> Cale! Come fix your crazy bot! ;)
22:24:03 <gwern> @seen Cale
22:24:03 <lambdabot> Cale is in #haskell-overflow, #haskell and #ghc. I last heard Cale speak 44m 20s ago.
22:24:39 <wagle_home> :t (.)
22:24:40 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
22:24:55 <gwern> hm. now the question is how do I install a shell script to the same place as the haskell program
22:24:57 <BMeph> It's called "dot" in the Wiki.
22:25:29 <crutcher> okay, ((.).(.)) f g works, but ugh.
22:25:52 <wagle_home> so lambdabot speaks doublespeak-haskell now?
22:26:18 * gwern hums anything you can do, I can do better; 'anything you shell scripts can do, Haskell can do better, yes it's true'
22:26:26 <BMeph> crutcher: Hey, when you come to the pointless cafe, you take your order, and Like it! ;p
22:26:33 <sclv> crutcher -- define it as dot = fmap . fmap and then you can use it inline. a `dot` b
22:27:14 <sclv> you may want to define it as `o` or <$$>, which are also sometimes used.
22:27:20 <crutcher> BMeph: my concern is that its a lot of chars, not that it isn't an infix opperator.
22:27:45 <BMeph> crutcher: 'dot' is a lot of chars? ;)
22:28:28 <wagle_home> :t fmap
22:28:29 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
22:28:44 <BMeph> I.e., dot f g, if you're going to use it function-style, vice operator-style.
22:28:50 <adu> is there a builtin function for hGetBytes in this page:
22:28:50 <adu> http://koweycode.blogspot.com/2007/02/reading-and-writing-utf-8-in-haskell.html
22:28:50 <adu> ?
22:28:51 <crutcher> BMeph: I can of course define a new func.
22:28:52 <lambdabot> Title: koweycode: reading and writing UTF-8 in Haskell, http://tinyurl.com/2jl8ar
22:29:15 <crutcher> hmm, fmap . fmap != (.).(.)
22:29:30 <wagle_home> :t (.).(.)
22:29:31 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
22:29:44 <wagle_home> :t fmap `fmap` fmap
22:29:44 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
22:29:51 <BMeph> crutcher: Au contraire, look up fmap for the ((->) r) Functor. ;)
22:30:30 <wagle_home> great..  we now have two names for fmap, and none for composition
22:30:33 <gwern> anyone know if hugs has an equivalent to ghc's --print-libdir?
22:31:05 <sclv> wagle_home: actually, we have three for composition: fmap, . and <$> (not to mention the arrow combinators. :-P)
22:31:21 <crutcher> BMeph: it only works if I define the functor, it doesn't work generally.
22:31:43 <gwern> I have long wished for my composition to be as simple as my telephone. I have received my wish: I no longer understand my telephone. (with apologies)
22:31:44 <sclv> the functor is in control.monad.instances as i recall.
22:32:05 <wagle_home> compose :: (b -> c) -> (a -> b) -> (a -> c)
22:32:18 <wagle_home> . is fmap now
22:32:33 <BMeph> Now, the function I would like to simplify, is: splitter f list = f (head list) (tail list). I do that a lot, but not (quite) enough to put it in my utility kit.
22:33:23 <Cale> BMeph: what's wrong?
22:33:49 <sclv> ?hoogle hGet
22:33:51 <lambdabot> Data.ByteString.hGet :: Handle -> Int -> IO ByteString
22:33:51 <lambdabot> Data.ByteString.Char8.hGet :: Handle -> Int -> IO ByteString
22:33:51 <lambdabot> Data.ByteString.Lazy.hGet :: Handle -> Int -> IO ByteString
22:33:53 <Cale> <BMeph> Cale! Come fix your crazy bot! ;)
22:33:58 <BMeph> Cale: Oh, nothing, lambdabot's spitting out definitions in "Functor space" now, is all. :)
22:34:02 <sclv> adu ^^
22:34:08 <Cale> Oh, I generalised (.)
22:34:12 <gwern> BMeph: is that the same as splitter f [x:xs] = f x xs ?
22:34:13 <Cale> It means the same thing as fmap
22:34:32 <Cale> Note that the instance of Functor for ((->) e) makes it the same as composition.
22:34:40 <Cale> So this just generalises composition.
22:34:41 <BMeph> [22:20]	<dmwit>	:t \f g -> f . g
22:34:42 <BMeph> [22:20]	<lambdabot>	forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
22:34:43 <gwern> @pl splitter f [x:xs] = f x xs ?
22:34:43 <lambdabot> (line 1, column 19):
22:34:43 <lambdabot> unexpected "="
22:34:43 <lambdabot> expecting variable, "(", operator or end of input
22:34:48 <sclv> next up -- returning ++ to mconcat!!
22:34:55 <gwern> @pl splitter f (x:xs) = f x xs ?
22:34:55 <lambdabot> (line 1, column 19):
22:34:55 <lambdabot> unexpected "="
22:34:55 <lambdabot> expecting variable, "(", operator or end of input
22:35:03 <gwern> @pl splitter f (x:xs) = f x xs
22:35:03 <lambdabot> splitter = (`ap` tail) . (. head)
22:35:05 <gwern> gah.
22:35:15 <crutcher> another one I do all the damn time: \f g x y -> f (g x) (g y)
22:35:16 <BMeph> gwern: Yeah, I guess that's a better form for it. :)
22:35:37 <BMeph> crutcher: That's an easy one - that's "on". :)
22:35:45 <gwern> ew. still, I'll never get used to the pattern matching is  (x:xs) and not [x, xs] or [x:xs]
22:35:48 <Cale> :t on
22:35:49 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
22:35:51 <gwern> it just seems wrong
22:36:14 <Cale> > on f g x y
22:36:15 <lambdabot>  Add a type signature
22:36:18 <Cale> > on f g x y :: Expr
22:36:18 <lambdabot>  Add a type signature
22:36:29 <BMeph> bzzt
22:36:45 <Cale> curious
22:37:02 <Cale> > on (f :: Expr -> Expr) (g :: Expr -> Expr) (x :: Expr) (y :: Expr) :: Expr
22:37:02 <lambdabot>  Couldn't match expected type `Expr -> c'
22:37:05 <crutcher> hmm. How old is 'on'?
22:37:10 <adu> sclv: thanks
22:37:15 <Cale> > on (f :: Expr -> Expr -> Expr) (g :: Expr -> Expr) (x :: Expr) (y :: Expr)
22:37:16 <lambdabot>  f (g x) (g y)
22:37:19 <Cale> aha
22:37:19 <crutcher> I see it in Data.Function
22:37:30 <crutcher> but it isn't in my default scope in ghci
22:37:36 <Cale> :m + Data.Function
22:37:36 <sclv> adu: it returns a bytestring instead of a list, but that's possibly saner and more efficient for most purposes anyway.
22:37:41 <crutcher> though everything else in Data.Function is.
22:37:57 <BMeph> crutcher: Yeah, isn't that a pill? :p
22:38:30 <sclv> > \x -> f x :: Expr
22:38:31 <lambdabot>  <() -> SimpleReflect.Expr>
22:38:41 <sclv> > (\x -> f x) :: Expr
22:38:41 <lambdabot>      The lambda expression `\ x -> f x' has one argument,
22:38:41 <lambdabot>     but its type `E...
22:38:52 <sclv> ah well.
22:39:44 <wagle_home> :t (+ 1) . (+ 1)
22:39:45 <lambdabot> forall a. (Num a) => a -> a
22:40:05 <crutcher> :t on
22:40:06 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
22:40:20 <wagle_home> :t (+ 1) `fmap` (+ 1)
22:40:21 <lambdabot> forall a. (Num a) => a -> a
22:40:39 <sclv> ?quote explode
22:40:39 <lambdabot> cjeris says: Cale: I like how you conveniently gloss over the part where your head explodes.
22:41:36 <wagle_home> :t ((+ 1) `fmap`)
22:41:37 <lambdabot> forall a (f :: * -> *). (Functor f, Num a) => f a -> f a
22:42:51 <wagle_home> :t (`fmap` (+ 1))
22:42:52 <lambdabot> forall b a. (Num a) => (a -> b) -> a -> b
22:43:42 <BMeph> Cale Gibbard: A man, for whom making demons fly out of noses is a calling, not a hobby. ;)
22:43:47 * wagle_home still disbelieves the need to have 2 (3?) names for fmap
22:44:18 <Cale> BMeph: It's really not so bad.
22:44:34 <Cale> BMeph: Once you know what a Functor is, it's fairly natural.
22:44:56 <Cale> wagle_home: I think there should be exactly two names, and they should be (.) and map
22:45:16 <Cale> (It's important enough to warrant having both an infix and prefix form)
22:45:32 <wagle_home> :t map
22:45:32 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
22:45:33 <BMeph> Cale: Truly, you DO "put the 'funk' in 'functional'." :)
22:46:01 <Cale> I haven't generalised map yet ;)
22:46:16 <wagle_home> :t <$$>
22:46:17 <lambdabot> parse error on input `<$$>'
22:46:24 * BMeph sits back and watches the Chaos Rise
22:46:25 <Cale> hehe, if I'm really evil, I'll flip $ at some point :)
22:46:30 <Cale> er, flip the associativity :)
22:46:34 <wagle_home> :t <$>
22:46:35 <lambdabot> parse error on input `<$>'
22:46:43 <Cale> :t (<$>)
22:46:44 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
22:47:29 <Cale> It's too bad that there's no possibility of an implicit identity functor.
22:47:56 <Cale> Then <$> and $ would be the same thing.
22:48:57 <mrd> and  then cale would complete his evil plan of making everything equal to fmap
22:49:07 <mrd> muhahha, it's ALL FUNCTORS
22:49:29 <Cale> It's really true, it really is.
22:49:40 <BMeph> "My God, it's full of [functors]!" ;)
22:51:20 <BMeph> That's what I love about Haskell - you can hardly go for an hour without hearing/learning something that you want to put on a T-shirt. :)
22:51:48 <BMeph> @where Lisp
22:51:48 <lambdabot> I know nothing about lisp.
22:51:55 <BMeph> Amen, Sister! ;)
22:51:56 <wagle_home> @instances Functor
22:51:57 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
22:52:05 <mrd> @remember lambdabot I know nothing about lisp.
22:52:05 <lambdabot> I will never forget.
22:52:54 <wagle_home> :t (. flip)
22:52:55 <lambdabot> forall b a b1 c. ((b1 -> a -> c) -> b) -> (a -> b1 -> c) -> b
22:53:14 <wagle_home> :t (flip .)
22:53:15 <lambdabot> forall a b c (f :: * -> *). (Functor f) => f (a -> b -> c) -> f (b -> a -> c)
22:53:55 <wagle_home> :t flip
22:53:56 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
22:54:37 <wagle_home> hmm..  does it mess up currying?
22:54:50 <BMeph> Does what mess up currying, wagle?
22:55:33 <gwern> what's an easy way to have a binary which calls 'ghc --print-libdir' on startup? there don't seem to be any obvious runShellCommands in the libs
22:55:39 <wagle_home> :t (flip (\f g x-> f (g x)))
22:55:40 <lambdabot> forall t t1 t2. (t -> t1) -> (t1 -> t2) -> t -> t2
22:55:42 <gwern> (and returns the String, obviously)
22:55:59 <mrd> gwern: using ghc api?
22:56:07 <mrd> runInteractiveCommand can get the output
22:56:14 <wagle_home> :t (flip (\f g x-> f (g x))) (+ 1)
22:56:15 <lambdabot> forall t a. (Num a) => (a -> t) -> a -> t
22:56:21 <wagle_home> :t (flip (\f g x-> f (g x))) (+ 1) (+ 2)
22:56:22 <lambdabot> forall a. (Num a) => a -> a
22:56:23 <gwern> mrd: I doubt that'd be the easy way
22:56:31 <wagle_home> :t (flip (\f g x-> f (g x))) (+ 1) (+ 2) 3
22:56:31 <lambdabot> forall a. (Num a) => a
22:56:39 <gwern> @hoogle runInteractiveCommand
22:56:39 <lambdabot> System.Process.runInteractiveCommand :: String -> IO (Handle, Handle, Handle, ProcessHandle)
22:56:45 <wagle_home> :t (flip .) (+ 1)
22:56:46 <lambdabot> forall a b c. (Num (a -> b -> c)) => (a -> b -> c) -> b -> a -> c
22:56:48 <mrd> it's not hard
22:56:53 <wagle_home> :t (flip .) (+ 1) (+ 2)
22:56:54 <lambdabot> forall b c. (Num (b -> c), Num ((b -> c) -> b -> c)) => b -> (b -> c) -> c
22:56:57 <mrd>   (_, _, err, ph) <- runInteractiveCommand "ghc -v"
22:56:57 <mrd>   waitForProcess ph
22:56:57 <mrd>   cs <- hGetContents err
22:57:02 <wagle_home> :t (flip .) (+ 1) (+ 2) 3
22:57:03 <lambdabot> forall b c. (Num b, Num (b -> c), Num ((b -> c) -> b -> c)) => (b -> c) -> c
22:57:07 <mrd> modify that a bit
22:57:14 <wagle_home> (flip .) (+ 1) (+ 2) 3
22:57:22 <wagle_home> > (flip .) (+ 1) (+ 2) 3
22:57:22 <lambdabot>        add an instance declaration for
22:57:22 <lambdabot>       (Num (b -> c), Num ((b -> c) -> ...
22:57:32 <gwern> mrd: dunno about handles. are there any examples?
22:57:33 <wagle_home> (flip (\f g x-> f (g x))) (+ 1) (+ 2) 3
22:57:45 <gwern> @hoogle executeFile
22:57:46 <lambdabot> No matches found
22:57:54 <gwern> @hoogle execute
22:57:54 <lambdabot> No matches found
22:57:54 <wagle_home> > (flip (\f g x-> f (g x))) (+ 1) (+ 2) 3
22:57:55 <lambdabot>  6
22:58:06 <mrd> huh? that code bit i posted will do it
22:58:13 <wagle_home> there you go..  (.) is not compose
22:58:33 <mrd> except use (_, out, _, ph) <- ...
22:58:41 <gwern> mrd: oh, sry. didn't see it among all the noise
22:58:42 <mrd> instead of reading stderr
22:59:24 <mrd> it seems pretty easy to me.  it also seems to be the only way.
22:59:27 <wagle_home> see that, Cale?
22:59:57 <wagle_home> oops, i did it wrong
23:00:30 <wagle_home> > ((\f g x-> f (g x)) flip) (+ 1) (+ 2) 3
23:00:31 <lambdabot>        add an instance declaration for
23:00:31 <lambdabot>       (Num (b -> c), Num ((b -> c) -> ...
23:00:37 <hpaste>  mrd pasted "getRunCommandOutputLine" at http://hpaste.org/6251
23:00:49 <mrd> ^ that's what i've been using for grabbing one line from a command output
23:01:06 <Cale> wagle_home: hm?
23:01:29 <gwern> @hoogle waitForProcess
23:01:29 <lambdabot> System.Process.waitForProcess :: ProcessHandle -> IO ExitCode
23:01:56 <wagle_home> Cale, i thought i found where (.) wasnt being curryied the same as compose
23:02:17 <wagle_home> but i did it wrong
23:02:19 <Cale> huh
23:02:22 <Cale> oh, okay
23:02:28 <mrd> gwern: what ya planning to do with ghc api?
23:02:43 <Cale> (.), when its type is specialised, should be entirely identical to compostiion
23:02:46 <Cale> composition*
23:02:49 <wagle_home> :t (flip .)
23:02:50 <lambdabot> forall a b c (f :: * -> *). (Functor f) => f (a -> b -> c) -> f (b -> a -> c)
23:03:13 <wagle_home> :t ((\f g x -> f ( g x)) flip)
23:03:14 <lambdabot> forall t a b c. (t -> a -> b -> c) -> t -> b -> a -> c
23:03:31 <gwern> mrd: nothing; it's for greencard
23:03:39 <Cale> right, with f = ((->) t)
23:03:43 <gwern> it requires the location of the library directory for some reason
23:03:52 <mrd> ?pl \ a b -> out b a
23:03:52 <lambdabot> flip out
23:04:19 <gwern> and I figured it was easier to write a haskell script to wrap around it and supply it with a default than to update the shell scripts and figure out how to make cabal install them, and as executable
23:04:45 <wagle_home> :t (flip .) (+ 1)
23:04:46 <lambdabot> forall a b c. (Num (a -> b -> c)) => (a -> b -> c) -> b -> a -> c
23:04:58 <wagle_home> :t (flip .) (+ 1) (+ 2)
23:04:59 <lambdabot> forall b c. (Num (b -> c), Num ((b -> c) -> b -> c)) => b -> (b -> c) -> c
23:05:02 <mrd> hah, i rewrote ashell script in haskell for the same reason
23:05:38 <wagle_home> :t ((\f g x -> f ( g x)) flip) (+ 1)
23:05:39 <lambdabot> forall a b c. (Num (a -> b -> c)) => (a -> b -> c) -> b -> a -> c
23:05:47 <wagle_home> :t ((\f g x -> f ( g x)) flip) (+ 1) (+ 2)
23:05:48 <lambdabot> forall b c. (Num (b -> c), Num ((b -> c) -> b -> c)) => b -> (b -> c) -> c
23:06:01 <gwern> mrd: did you ever figure out how to do it? at some point I suspect I'll need to do it
23:06:16 <BMeph> @remember mrd ?pl \ a b -> out b a   <lambdabot> flip out
23:06:16 <lambdabot> It is stored.
23:06:29 <mrd> no, it's probably not that bad.  i just prefered not to have the shell script.
23:06:35 <gwern> @hoogle createPipe
23:06:36 <lambdabot> No matches found
23:07:09 <wagle_home> @instances Num
23:07:09 <lambdabot> Double, Float, Int, Integer
23:07:46 <wagle_home> hmm..  too bad it doesnt notice that there are no instances of Num (b -> c)
23:09:00 <Cale> wagle_home: There could be though
23:09:17 <wagle_home> church numerals i suppose
23:09:27 <Cale> Well, you could define a pointwise instance
23:09:44 <Cale> (f + g)(x) = f x + g x
23:10:15 <mrd> distributive?
23:11:00 <Cale> You'd get f * (g + h) = f*g + f*h by the same property holding on the codomain of the maps.
23:12:03 <Cale> since, (f * (g + h)) x = f x * (g x + h x) = f x * g x + f x * h x = (f * g) x + (f * h) x = (f * g + f * h) x
23:12:56 <wagle_home> i guess you now have to explain functors to noobs before you explain function composition..  8/
23:13:00 <hpaste>  gwern annotated "getRunCommandOutputLine" with "probably could do better" at http://hpaste.org/6251#a1
23:14:07 <gwern> wagle_home: as I said, Cale is single-handedly undoing years of work on comprehensible error messages...
23:15:16 <Cale> wagle_home: No, you can just describe the special case.
23:15:32 <Cale> But it should be one of the earlier topics you bring up :)
23:16:27 <coffeemug> man, SML isn't fun to use at all compared to Haskell
23:16:34 <coffeemug> may be it's because I'm new to it
23:16:40 <gwern> yay! greencard and greencard-lib now both work in cabal without any handholding!
23:16:46 <wagle_home> :t (.)
23:16:47 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
23:16:53 <gwern> man, do I upload to hackage first or email the maintainers or what?
23:17:07 * gwern knows the answer to that one! do both!
23:17:35 <gwern> it's a neat feeling when hours of works finally tidies up in two neat packages you know other people will appreciate and be able to make use of
23:17:45 <wagle_home> whats of type forall a b (f :: * -> *, g :: * -> *). (Functor f, Functor g) => (g a -> g b) -> f a -> f b
23:17:49 <gwern> especiall when it's an old unloved program you're helping
23:18:27 <gwern> @djinn forall a b (f :: * -> *, g :: * -> *). (Functor f, Functor g) => (g a -> g b) -> f a -> f b
23:18:27 <lambdabot> Cannot parse command
23:18:33 <dmwit> wagle_home: Basically nothing.
23:18:33 <gwern> @hoogle forall a b (f :: * -> *, g :: * -> *). (Functor f, Functor g) => (g a -> g b) -> f a -> f b
23:18:33 <lambdabot> Hoogle Error: Parse Error: Unexpected character '* -> *, g '
23:18:37 <Cale> wagle_home: nothing
23:18:46 <gwern> @hoogle (g a -> g b) -> f a -> f b
23:18:47 <lambdabot> Data.Generics.Schemes.everywhere :: (a -> a) -> a -> a
23:18:47 <lambdabot> Data.Generics.Schemes.everywhere' :: (a -> a) -> a -> a
23:18:47 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
23:18:54 <dmwit> wagle_home: There's always bottom, but that's hardly an interesting value.
23:19:24 <dmwit> ?djinn (Functor f, Functor g) => (g a -> g b) -> (f a -> f b)
23:20:12 <dmwit> ?botsmack
23:20:12 <lambdabot> :)
23:20:13 <wagle_home> i was trying to make fmap symmetrical in its arguments..
23:20:33 <wagle_home> didnt do it right...  (again)
23:20:40 <dmwit> fmap is an axiom, not much you can change there.
23:21:42 <wagle_home> was trying to let the g functor be (-> a)
23:23:58 <wagle_home> but i suspect the type would stil be something like  (Functor f, Functor g) => g (a -> b) -> (f a -> f b)
23:25:00 <wagle_home> i think i'm looking for something more general than a functor
23:26:02 <dmwit> There's not much above Functor on the simplicity food-chain.  Maybe category...
23:26:05 <wagle_home> (i'm uh, thinking out loud, sorry)
23:26:47 <wagle_home> (swapping in category theory from 8 years ago or so)
23:28:42 <wagle_home> :t fmap (+ 1)
23:28:43 <lambdabot> forall a (f :: * -> *). (Functor f, Num a) => f a -> f a
23:29:40 <wagle_home> :t fmap
23:29:41 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
23:30:35 <wagle_home> :t (.) . (.)
23:30:36 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
23:30:50 <crutcher> thanks all.
23:31:17 <wagle_home> @src Functor (-> a)
23:31:18 <lambdabot> Source not found. You speak an infinite deal of nothing
23:31:26 <wagle_home> @instances Functor
23:31:26 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
23:31:53 <wagle_home> @src (Functor ((->) r))
23:31:53 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
23:32:14 <wagle_home> okm not thats unfair
23:32:21 <wagle_home> ok now thats unfair
23:32:24 <RayNbow> @src ((->) r) fmap
23:32:25 <lambdabot> Source not found. Maybe you made a typo?
23:32:30 <dmwit> fmap = (.)
23:32:50 <dmwit> ?src (r ->) fmap
23:32:50 <lambdabot> Source not found. My pet ferret can type better than you!
23:32:55 <dmwit> bwuh
23:39:36 <RayNbow> hmm
23:39:48 <RayNbow> dmwit, I dug around in the source
23:40:06 <dmwit> fmap = liftM?
23:40:09 <RayNbow> instance MonadReader r ((->) r)
23:40:22 <RayNbow> instance Functor (Reader r) where
23:40:22 <RayNbow>     fmap f m = Reader $ \r -> f (runReader m r)
23:40:45 <dmwit> That's the wrong instance.
23:40:53 <BMeph> src (->) fmap
23:40:53 <RayNbow> oh right
23:40:56 * gwern wipes my hands of greencard. a good night's work
23:40:59 <BMeph> @src (->) fmap
23:40:59 <lambdabot> fmap = (.)
23:41:14 <BMeph> @src (,) fmap
23:41:14 <lambdabot> fmap f (x,y) = (x, f y)
23:41:22 <RayNbow> but...
23:41:23 <RayNbow> instance MonadReader r (Reader r) where
23:42:07 <dmwit> You want
23:42:17 <dmwit> instance (MonadReader r) => Functor r where
23:42:22 <dmwit> or something along those lines.
23:42:44 <dmwit> If it has plain Reader, it's not what most people use. ;-)
23:44:24 <wagle_home> thats not the fmap on (,) i would expect (though not sure what would be both better and work)
23:44:42 <wagle_home> @src Either fmap
23:44:42 <lambdabot> fmap _ (Left x) = Left x
23:44:42 <lambdabot> fmap f (Right y) = Right (f y)
23:45:27 <dmwit> The only other choice is to apply f to the left hand side of the tuple, really.
23:45:46 <wagle_home> yeah, that was what i was saying wouldnt work..  8(
23:46:56 <dmwit> Why?
23:47:07 <dmwit> fmap f (x, y) = (f x, y) -- seems fine to me
23:47:22 <wagle_home> would force you to have type (a,a)
23:47:27 <dmwit> The only thing is that the types don't quite line up
23:47:46 <dmwit> wagle_home: No, it would force you to have a type constructor Flip or so, that's all.
23:48:11 <wagle_home> i mean fmap f (x,y) = (f x, fy)
23:48:14 <wagle_home> i mean fmap f (x,y) = (f x, f y)
23:48:22 <dmwit> Oh, yeah, that one isn't as nice.
23:48:23 <gwern> this Idris language is hard to install. I oughta help the author out
23:48:46 <wagle_home> unless f was polymorphic..  8)
23:49:55 <gwern> (bad practices also with his data files...)
23:49:58 <gwern> ah well
23:50:02 <gwern> good night everyone
23:50:35 * wagle_home suddenly wonders what a bifunctor is
23:51:01 <gwern> it's not quite a homofunctor, not quite a heterofunctor
23:51:02 <BMeph> Good night, gwern, and good night to the rest of #haskell. :)
23:51:11 <Twey> 'nigh BMeph.
23:51:17 <Twey> 'night even.
23:51:47 <wagle_home> nope, not what i'm looking for
23:52:25 <jlhamilton> I've been playing around with Parsec-3.0.0.  What type signature should I give to the function simple = char 'a' if I just want to parse Strings?
23:52:43 <jlhamilton> In ghci I can run let simple = char 'a' in parseTest simple "a" with no problems.
23:54:48 <quicksilver> jlhamilton: type ":t simple" in ghci.
23:54:52 <quicksilver> then use that type :)
