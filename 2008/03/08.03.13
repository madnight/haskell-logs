00:00:13 <lispy> > splitAt 4 [1..]
00:00:14 <lambdabot>  ([1,2,3,4],[5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
00:00:28 <bd_> just shove the Data.LazyBytestring.Bytestring (which you should look into using :) into a State...
00:01:29 <solrize_> lispy that splitting doesn't really handle the situation, i'm going to need small seqs of random #'s at different places in the program
00:02:17 <lispy> solrize_: you won't be able to split it, take the fst and later split the snd?
00:02:19 <solrize_> hmm putting the rng inside a State and passing that around to different pure funcs is an interesting idea
00:02:56 <solrize_> well those funcs also have to be in State i guess
00:03:02 <solrize_> maybe that's better than being in IO?
00:03:12 <mauke> @src State
00:03:12 <lambdabot> Source not found. It can only be attributed to human error.
00:03:37 <lispy> solrize_: State is easier to deal with usually.  BTW, have you seen MonadRandom?
00:03:41 <bd_> grabRandomBytes :: Int -> State [Word8] [Word8]  = \n -> do { xs <- get; let (h, t) = splitAt n xs; put t; return h }
00:03:44 <lispy> ?go MonadRandom
00:03:45 <lambdabot> http://www.haskell.org/haskellwiki/New_monads/MonadRandom
00:03:46 <lambdabot> Title: New monads/MonadRandom - HaskellWiki
00:03:53 <solrize_> i did look at monadrandom
00:04:00 <solrize_> i should look again
00:04:36 <lispy> haddock: no GHC lib dir specified
00:04:43 <lispy> What does that mean?
00:04:50 <lispy> and why should I care?
00:10:37 <solrize_> factor looks like forth
00:17:07 <solrize_> is factor interesting?  it looks as painful as forth but without the benefit of tinyness
00:19:41 <lispy> grr, what is up with haddock
00:19:58 <lispy> it says no lib dir specificed, so I use --lib=`ghc --print-libdir` and it still complains
00:20:32 <lispy> good grief, you need -B not --lib
00:21:39 <mcnster> odd q: can i call a primitive method foo# :: IO () from my module if i don't have access to the IO data constructor?
00:24:45 <solrize_> IO is not a data constructor it's a type constructor
00:24:56 <ZimaN> nobody has access to any IO data constructor afaik
00:27:21 <mcnster> solrize, actually the type of foo# should be :: State# (RealWorld) -> (# State# (RealWorld), () #) so i would need to construct a type of IO with the IO data constructor
00:28:05 <solrize_> what's the # ?   this is over my head
00:30:21 <mcnster> solrize, unboxed types (suitable for sending to a primitive method).  this is obscure
00:32:04 <mcnster> methinks i'm going to have to humble myself before a haskell master to get to the bottom of this :-)
00:33:14 <solrize_> can you use unsafeperformIO to escape the IO type?
00:34:17 <mauke> yes
00:34:27 <mauke> however, just escaping the IO type is easy
00:34:37 <mauke> unIO :: IO a -> a; unIO _ = undefined
00:34:45 <mauke> the trick is getting useful values out :-)
00:35:57 <solrize_> i thought there was a way to do that
00:36:14 <solrize_> i.e. you can use unsafeperformio to get f :: forall a. forall b.  a->b
00:37:13 <solrize_> hmm http://paste.lisp.org/display/42083
00:37:17 <solrize_> unsafeCoerce# ?
00:40:51 <lispy> any haddock hackers here?
00:41:00 <lispy> do you know if -optghc can be passed multiple times?
00:41:10 <lispy> or should I put quotes around it or what?
00:41:21 <Cale> :t const undefined
00:41:21 <lambdabot> forall a b. b -> a
00:41:23 <lispy> something like +RTS -RTS would be nicer
00:41:34 <Cale> ;)
00:43:04 <solrize_> hmm i have a function that might not work sometimes, because of error conditions.  do i make it return an Either or do i make it raise an exception on failure?
00:43:29 <mauke> same thing
00:47:39 <Heffalump> tibbe: errm, fairly sure, 6.6 had loads of stuff in base
00:48:08 <tibbe> Heffalump: ok, I guess I have to download and test then :)
00:48:36 <tibbe> Heffalump: when I think about it you must be right because it's base 2.x that include bytestring, etc
00:48:45 <Heffalump> tibbe: the release notes just mention removing Regex to a separate package
00:48:53 <tibbe> Heffalump: I wonder which packages the release notes refer to
00:48:54 <Heffalump> and they also talk about adding bytestring
00:54:05 <solrize_> is there a way to automatically derive Show for every type where that's possible?  that would make debugging easier
00:55:14 <solrize_> loooooo
00:55:18 <solrize_> sorry
01:11:20 <tibbe> solrize: yes, add "deriving Show"
01:11:29 <tibbe> data Foo = Foo Int deriving Show
01:12:19 <dmwit> I think he wanted some kind of "meta-deriving Show" that worked for *all* data types.
01:12:32 <dmwit> Which isn't really possible short of TH or so.
01:12:41 <tibbe> ah
01:12:51 <tibbe> so he doesn't have to add it, I see
01:13:20 <dmwit> lazy bugger =)
01:13:21 <tibbe> I'm not sure if I'd want that, aren't instances always exported?
01:13:27 <mauke> write your types in terms of Either and (,)
01:13:31 <tibbe> or is it only if the type constructors are?
01:13:42 <mauke> type Foo = Int  -- showable
01:13:55 <dmwit> mauke: That's just trading one annoyance for another.
01:17:56 <solrize_> yes, what dmwit said, i don't actually want deriving show on all the types in the real program, i want to enable it as something like a debugging flag as a compiler option, or something like that
01:24:34 <glguy> ?seen cale
01:24:35 <lambdabot> cale is in #ghc, #haskell-overflow and #haskell. I last heard cale speak 43m ago.
01:45:45 <solrize_> there is no hash function like md5 or sha in the ghc library :(
01:46:25 <taruti> solrize_: but there are many implementations of those floating around.
01:47:39 <solrize_> yeah, i see there's something in hackage, but that's nonstandard and in principle could be flakier.  apparently anybody can upload stuff to hackage including someone like me (shudder).
01:49:28 <Heffalump> stuff is getting moved out of GHC to ease the maintenance headache for the GHC people
01:49:42 <Heffalump> and to make it easier to maintain and upgrade independently, and to use by other compilers
01:49:49 <opqdonut> is control.comonad getting into prelude at some point?
01:49:52 <solrize_> but that just transfers the headache to the users
01:50:00 <cjs> Editor question: I'm using vi now, and the haskell.vim plugin seems to work ok, but I really wouldn't mind better automatic reformatting. Any thoughts on what I should do? Is there a "you, dude, you should be using this" haskell editor?
01:50:11 <Heffalump> to some extend, but I think it's a good thing overall
01:50:15 <opqdonut> cjs: yeah, emacs
01:50:16 <hpaste>  dmwit pasted "md5 hash (in IO monad)" at http://hpaste.org/6326
01:50:29 <opqdonut> it has the best haskell-mode :)
01:50:39 <opqdonut> you might want to try leksah too, a pretty promising haskell-ide
01:50:47 <solrize_> i'm using emacs but find myself wishing for an ide that had full scale type inferencing and could figure out what module every function came from
01:50:49 <cjs> Hmm...that's what I was suspecting.
01:50:58 <cjs> And least it's got vile.
01:51:17 <taruti> and viper :)
01:51:18 <dmwit> There's really no stunningly good Haskell development environment.
01:51:22 <solrize_> bwahahaha, runWithInput "md5sum"
01:51:37 <dmwit> Not the way, say, emacs is excellent for lisp or Eclipse is good for Java.
01:51:47 <cjs> Hm. Well, this may be what gets me off of vi, after 23 years....
01:52:01 <cjs> Eclipse and similar things I am not touching. Ew.
01:52:06 <dmwit> I mean, :set autoindent is not *that* bad.
01:52:16 <dmwit> Oh, I wouldn't recommend Eclipse for Haskell.
01:53:08 <dmwit> solrize_: Yup, I took the cheater's way out. =P
01:53:20 <solrize_> heffalump i guess it depends what your goals are, i respect the notion of haskell as a research language that avoids success at all costs, but there seems to be a faction that actually wants success in the form of beating python and java for programmer acceptance.  and in order to do that it simply has to have serious libraries with real maintainers and not rely on some free-for-all repository that anyone can dump junk into
01:53:47 <Heffalump> works for Perl..
01:53:54 <dmwit> XMonad found out something similar, that's why there's a Core and a Contrib repository.
01:53:59 <Heffalump> I think it's in fact the only way you can scale.
01:54:06 <wagle_home> huh..  my impression of java (or eclipse) is that its one big free-for-all of software
01:54:09 <Heffalump> some kind of quality mark might help, though
01:54:20 <cjs> Not if it's the quality mark of Java libraries. Eww.
01:54:21 <integral> not entirely successfully.  There's a lot of crap on CPAN and no real good guide or commonly accepted "good" modules communicated other than by word of mouth
01:54:29 <glguy> Do you have to create diff arrays in IO? (and then you can use them functionally?)
01:54:30 <dmwit> wagle_home: I think Java/Python are pretty "batteries-included" kind of languages.
01:54:55 <dmwit> wagle_home: Most of the libraries for common stuff are centrally-dictated.
01:55:01 <solrize_> perl has Digest::MD5
01:55:39 <wagle_home> i hang with enterprise java programmers..  they do a LOT of word-of-mouth about which package is best for what, etc
01:55:52 <glguy> :-( there is no DiffUArray of Bools
01:56:30 <Heffalump> integral: sure.
01:56:37 <Heffalump> but Perl is still very successful
01:56:44 <Heffalump> and IMO CPAN is a large part of that
01:56:48 <solrize_> yeah, java and python both rely a lot on external modules (in python's case, more than it should, imo) but basic things like md5 are part of the distros of both
01:57:05 <solrize_> and i'm not sure what it takes to contribute something to cpan
01:57:13 <solrize_> or whether there's any review mechanism available
01:57:40 <wagle_home> nike, for example, has a list of something like 11 packages they expect people to know that arent included in java distributions
01:58:17 <solrize_> php has pretty good libraries
02:03:42 <hpaste>  solrize pasted "more IO pain" at http://hpaste.org/6327
02:03:56 <opqdonut> The goggles! They do nothing!
02:04:37 <opqdonut> solrize_: so what's the problem there?
02:04:45 <oerjan> glguy: huh? have you checked?
02:05:01 <solrize_> opqdonut it's a pain to have to put the encryption result into IO, in part because now i don't see how to quickcheck it
02:05:35 <opqdonut> well pass an explicit StdGen to it?
02:05:39 <opqdonut> use the Random monad?
02:05:48 <solrize_> i may have misunderstood the discussion earlier about putting randomchars into State but anyway i think that's a bit dangerous because it could lead to reusing a random stream?
02:05:51 <solrize_> hmm
02:06:04 <opqdonut> well actually not
02:06:06 <solrize_> Random uses unsafeperformio or something like that?
02:06:18 <opqdonut> solrize_: no, it passes around a RNG
02:06:39 <solrize_> well where does the entropy come from?
02:06:52 <opqdonut> well it gets passed in from main
02:06:53 <solrize_> i guess you seed the rng in main
02:06:54 <solrize_> right
02:06:57 <opqdonut> yeah
02:07:04 <opqdonut> but after that everything's pure
02:07:23 <solrize_> so i can bind the /dev/urandom string in main and then write a stdgen around that?
02:07:36 <opqdonut> well you can use newStdGen
02:07:43 <opqdonut> :t newStdGen
02:07:46 <lambdabot> IO StdGen
02:07:55 <opqdonut> which does the seeding for you
02:08:08 <opqdonut> from an OS-offered random source
02:09:31 <solrize_> so i'd have   encrypt' :: StdGen -> Key -> Plaintext -> Ciphertext
02:09:39 <opqdonut> yeah
02:09:53 <opqdonut> or RandStream -> Key -> Plaintest -> Ciphertext
02:09:55 <taruti> StdGen is not secure cryptographically
02:09:57 <opqdonut> if that suits you better
02:10:01 <oerjan> glguy: no DiffArrays shouldn't need IO - they have IArray instances (i guess that's what's missing for Bool?)
02:10:19 <opqdonut> taruti: yeah, but it can be replaced with something that is
02:10:46 <opqdonut> :t randoms -- solrize_: you can use this to get a stream of random
02:10:47 <lambdabot> forall g a. (RandomGen g, Random a) => g -> [a]
02:10:56 <solrize_> and then randstream <- readFile "/dev/urandom; encrypt = (encrypt' randstream)
02:11:20 <solrize_> lemme try that
02:11:45 <opqdonut> solrize_: yeah, except /dev/urandom is not too great
02:13:04 <solrize_> as far as i can tell, it is ok once there is enough initial system entropy
02:13:16 <solrize_> if i get more serious i will use a hardware rng
02:13:31 * oerjan wonders why the heck the IArray instances for IOToDiffArray IOUArray are not written generically
02:16:40 <solrize_> hmm how do i run quickcheck inside IO ?
02:16:45 <solrize_> i'm back where i started
02:18:14 <opqdonut> solrize_: well pass a random stream that quickcheck generates?
02:18:29 <solrize_> hmm, i will have to check the qc docs to see how to do that
02:18:33 <opqdonut> then there's also hUnit which is suitable for testing stuff in IO
02:18:48 <opqdonut> solrize_: well quickcheck generates arbitary test cases
02:18:54 <opqdonut> just have it generate the random stream too
02:19:12 <hpaste>  (anonymous) annotated "more IO pain" with "(no title)" at http://hpaste.org/6327#a1
02:19:21 <solrize_> oops that was me
02:19:32 <opqdonut> test_foo stream data = (decrypt . encrypt stream) data == data
02:19:33 <opqdonut> or something
02:20:02 <glguy> ?index comparin
02:20:02 <glguy> ?index comparing
02:20:04 <solrize_> yeah that makes sense i guess
02:20:04 <ketil> about hackage - are failed build retried occasionally, or only on re-upload?
02:20:05 <lambdabot> bzzt
02:20:05 <lambdabot> bzzt
02:20:16 <dmwit> ?hoogle comparing
02:20:16 <lambdabot> Data.Ord.comparing :: Ord a => (b -> a) -> b -> b -> Ordering
02:20:29 <dmwit> let bzzt = Data.Ord in bzzt
02:20:29 <glguy> thnx
02:20:57 <oerjan> glguy: i assume getting Bool is just a matter of copying the exact same code that is used for all the other instances :/
02:21:59 <oerjan> unless there is some actual technical reason why it's left out
02:22:07 <solrize_> hmm my paste was wrong
02:23:59 <hpaste>  solrize annotated "more IO pain" with "re: IO pai" at http://hpaste.org/6327#a2
02:24:27 <solrize_> this is just way ugly
02:25:04 <Baughn> solrize_: If you want encryption, why don't you use openssl?
02:25:17 <opqdonut> solrize_: you might want to use type instead of newtype
02:25:30 <opqdonut> so you wouldn't have to unwrap constructors at every junction
02:27:58 <quicksilver> solrize_: why are encrypt and decrypt in IO? they don't appear to do any IO?
02:28:43 <opqdonut> i think he was fixing that but forgot to change the typesigs
02:28:45 <Riastradh> randomchars?
02:30:07 <quicksilver> (I can't think of any reason for decrypt to be in IO, ever. Encrypt might be in IO if its generating a random key.
02:30:24 <quicksilver> although far better to put random key generation somewhere separate.
02:30:55 <hpaste>  solrize annotated "more IO pain" with "better but still ugly" at http://hpaste.org/6327#a3
02:31:09 <opqdonut> quicksilver: that's what i've been telling
02:31:41 <quicksilver> solrize_: you have a typo with encrypt and encrypt', too.
02:31:55 <opqdonut> yeah and that code doesn't typecheck :)
02:32:08 <solrize_> baughn, i'm trying to write something like JCA/JCE for haskell, i.e. a crypto API that wraps some algorithms with key management and a type system
02:32:15 <solrize_> the one i just pasted compiles
02:32:21 <solrize_> i somehow broke it before pasting last time
02:32:38 <opqdonut> but why are you returning that stuff in IO?
02:32:39 <Baughn> solrize_: That's fine, but I imagine it would be far easier to use the existing functions in hOpenSSL as a base
02:32:47 <taruti> you have looked at the existing solutions?
02:32:48 <opqdonut> no reason for it
02:33:01 <solrize_> baughn, i might use openssl as a base sometime, right now i'm just figuring out what the types would look like
02:33:02 <taruti> Crypto toolkit, openssl bindings etc
02:33:29 <solrize_> oh wait, decrypt is still in io
02:33:31 <solrize_> lemme fix that
02:33:39 <Jedai> solrize_: rather than IO in encrypt, you should use a Random monad (cf WIki)
02:33:55 <opqdonut> solrize_: you don't need to have encrypt in IO either
02:33:58 <solrize_> huh?  looks like i pasted the wrong thing somehow?
02:34:02 <opqdonut> now that you're passing in a random stream
02:34:13 <solrize_> this is broke, what i pasted is not my current version
02:34:13 <Jedai> solrize_: And decrypt shouldn't be in IO anyway
02:34:13 <solrize_> sorry
02:34:15 <solrize_> just a sec
02:34:42 <quicksilver> ;)
02:34:50 <quicksilver> solrize_: do you see the encrypt'/encrypt typo, too?
02:34:53 <solrize_> i used clipboard-kill-ring-save
02:35:07 <solrize_> quicksilver, please wait til i paste the right text, sorry about this
02:35:13 <quicksilver> :)
02:35:34 <solrize_> damn, i'm having trouble pasting from emacs, sec
02:35:44 <opqdonut> :)
02:35:57 <taruti> having decrypt inside Monad m => ... -> m PlainText would be useful for some things.
02:36:02 <hpaste>  solrize annotated "more IO pain" with "ok, these are pure" at http://hpaste.org/6327#a4
02:36:21 <solrize_> ohhhh silly me, i was using emacs in a terminal so no clipboard operations
02:36:35 <Baughn> taruti: Decrypt should be a pure function. If the user wants to lift it into a monad, that's his business
02:36:49 <quicksilver> looks better.
02:37:10 <quicksilver> Baughn: in a monad != impure. I presume taruti was talking about error handling.
02:37:16 <taruti> Baughn: and what should it do e.g. for invalid ciphertexts? (e.g. having a length restriction or carrying MDC)
02:37:29 <Baughn> taruti: Throw an exception and kill the program, of course
02:37:31 <solrize_> part of the reason for putting decrypt into IO is that it might want to do the decryption on external hardware
02:37:37 <solrize_> though that might be a legitimate use of unsafePerformIO
02:37:38 <Baughn> taruti: ..point taken.
02:37:48 <Baughn> solrize_: It should be, yes
02:38:02 <quicksilver> it might be.
02:38:09 <quicksilver> it depends on the scheduling of the hardware
02:38:24 <taruti> generic monad + unsafePerformIO if one is using something that needs IO underneath to do the decryption.
02:38:38 <quicksilver> generic monad for failure is a horrible pattern.
02:38:53 <taruti> quicksilver: what would be nicer?
02:38:57 <quicksilver> MonadError
02:38:57 <solrize_> generic monad?   i was asking earlier whether it was better to use Either or raise an exception
02:39:01 <quicksilver> or just plain Either
02:39:08 <Baughn> Or Maybe?
02:39:08 <solrize_> i wrote something like this in python that raised exceptions on all errors
02:39:12 <taruti> limiting to Maybe/Either creates more messy code.
02:39:21 <Baughn> solrize_: In python it's actually feasible to /catch/ errors
02:39:34 <taruti> the Data.Map way is quite clean.
02:39:35 <solrize_> i think in case of error, it's important to give some idea of what went wrong, so Maybe isn't so great
02:39:37 <wagle_home> why would a encrypter need to use unsafe IO?
02:39:46 <quicksilver> wagle_home: if it was offloading it to hardware
02:40:03 <Baughn> quicksilver: What sort of hardware?
02:40:15 <quicksilver> encryption hardware.
02:40:16 <solrize_> baughn, what's the prob with catching exceptions in haskell?
02:40:28 <wagle_home> guh..  i'm tired and shoulda gone to sleep an hour ago..  gnite
02:40:33 <quicksilver> like those cards the US make you install if you want to handle credit card numbers.
02:41:00 <Baughn> solrize_: Lack of an exception hierarchy. There may be various test functions, but in general.. you can't tell what sort of exception it is
02:41:01 <quicksilver> so that the FBI can steal your customers details. Allegedly. :P
02:41:12 <quicksilver> Baughn is spreading FUD.
02:41:15 <solrize_> :)
02:41:21 <Baughn> solrize_: Then of course there are libraries like System.Posix that just use error
02:41:24 <quicksilver> it's perfectly possible to catch exceptions in haskell.
02:41:36 <quicksilver> it's not as clean as it could be, but it's not a big problem either.
02:41:40 <solrize_> hmm
02:41:55 <quicksilver> however, what you can't/shouldn't do is try to catch an 'error' thrown by pure code.
02:42:03 <solrize_> i guess exceptions are less important since you can monadically combine Eithers etc
02:42:18 <quicksilver> as a general rule, IO code can use error if you like, although throwDyn is better.
02:42:20 <solrize_> can you mix Either and Maybe cleanly?
02:42:23 <quicksilver> pure code should use Either.
02:42:30 <quicksilver> (or MonadError's throwError)
02:42:49 <solrize_> ok, so if encrypt and decrypt are "pure" then they shouldn't throw errors.
02:43:13 <quicksilver> not if you want the user to be able to catch them, no.
02:43:23 <quicksilver> error in pure code is OK for things which "should never happen"
02:43:26 <quicksilver> i.e. programmer bugs.
02:43:30 <Baughn> If the user /wants/ to throw an error, he can use an incomplete pattern match
02:43:41 <quicksilver> but it's not OK for things which genuinely might happen (like invalid ciphertext)
02:44:12 <quicksilver> things which genuinely might happen are best handled as Either or as MonadError.
02:44:36 <Baughn> quicksilver: Perhaps I've only seen /bad/ uses of exceptions, then. It seems to me that an awful lot of IO actions use error.
02:44:54 <quicksilver> as I said, IO code can user error if it wants
02:44:55 <quicksilver> that's ok
02:44:57 <solrize_> so how does the current paste look stylistically, e.g. is that encrypt' thing lame ?
02:44:59 <quicksilver> it's pure code that musn't.
02:45:36 <quicksilver> solrize_: as a general tactic it's fine. In this particular case, I wouldn't bother with "let encrypt = encrypt' rs"
02:45:44 <quicksilver> it just "wastes a line"
02:45:59 <quicksilver> I'd write "let ct = encrypt' rs (Key "foo") (Plaintext "plugh")"
02:46:02 <solrize_> well i want to use encrypt in multiple places
02:46:17 <quicksilver> and you probably want the to use different random streams :)
02:46:24 <quicksilver> not "rs" every time.
02:46:29 <quicksilver> otherwise that's not very random...
02:46:37 <solrize_> oh crap yes, that's what i was asking about earlier
02:46:48 <quicksilver> IE encrypt needs to return the "unused portion" of the randomstream
02:47:04 <solrize_> it sounds like i really do have to put encrypt in a monad in order to make sure rs is never re-used
02:47:19 <quicksilver> you don't have to. but that would be one way of abstracting the details away.
02:48:00 <quicksilver> like any programming decision, building up ever more complex monads is a cost/benefit tradeoff
02:48:13 <taruti> solrize_: that is probably good for symmetric crypto. for public key crypto it has some problems (the length of the plaintext cannot be arbitrary in most cases).
02:48:22 <solrize_> well the idea of a type system is to enforce invariants like that, and this is an important one, re-using rs would be a total security failure
02:48:22 <quicksilver> there is some complexity in building the framework, and some benefit in producing simpler-looking and less-buggy code.
02:48:27 <quicksilver> agreed.
02:48:41 <quicksilver> it's a particular sub-use of the state monad, with the RS as the state.
02:48:47 <quicksilver> it has been called the Supply monad
02:49:22 <quicksilver> there is a particular example, with a simple use case, at the bottom of http://www.haskell.org/haskellwiki/FoldableAndTraversable
02:49:23 <lambdabot> Title: FoldableAndTraversable - HaskellWiki
02:49:28 <solrize_> taruti, yeah, i'll probably look at some HSM manual to see how they handle public key and so forth
02:49:33 <quicksilver> there is a more general defintion at http://www.haskell.org/haskellwiki/New_monads/MonadSupply
02:49:33 <lambdabot> Title: New monads/MonadSupply - HaskellWiki
02:49:45 <quicksilver> or you can just use a state monad if you like :)
02:50:10 <Baughn> @docs ioError
02:50:10 <lambdabot> ioError not available
02:50:40 <solrize_> this looks nice (monadsupply) i'll try to figure it out
02:50:53 * solrize_ still getting the hang of the simplest monads
02:51:27 <solrize_> this stuff really feels a lot more solid than python already, even though i'm still clueless with the language
02:53:15 <solrize_> how hard is it to implement type inference?
02:54:57 <johnnowak> solrize: HM isn't too difficult
02:56:11 <solrize_> someone was saying last night that HM is conceptually simple but if you do it the naive way it takes exponential time
02:56:24 <johnnowak> solrize: http://research.microsoft.com/users/luca/Papers/BasicTypechecking.pdf
02:56:25 <lambdabot> http://tinyurl.com/2vvcte
02:56:31 <johnnowak> aye, that's true
02:56:46 <solrize_> oh cool, a cardelli paper, thanks
02:57:44 <johnnowak> the only real trick is dealing with free and non-free variables...the rest of it you could probably figure out for yourself if given some time
02:57:50 <Baughn> quicksilver: Okay, then. How *do* I catch a "nonexistent user" error from System.Posix.getUserEntryForName, without also catching things I don't want to catch?
02:58:28 <solrize_> johnnowak thanks
02:58:44 <Baughn> ioeGetErrorType /works/, sort of, but since the value it returns only shows as "failed" it isn't entirely clear how to match against it
02:59:53 <taruti> Baughn: lots of exception code uses Control.Exception and not IOErrors.
03:00:50 <Baughn> I haven't wanted to use any of those yet, unfortunately
03:02:15 <solrize_> is there a pure haskell version of AES which is fast?
03:02:33 <Baughn> solrize_: hopenssl isn't pure haskell (it uses openssl), but it's definitely fast
03:03:39 <solrize_> hopenssl isn't in the ghc lib, i'm thinking of writing an aes-based deterministic rng as an exercise and contributing it to hackage, but i don't want to rely on two levels of hackage if i can help it
03:03:59 <solrize_> plus also openssl is a core dumping piece of crap :)
03:04:13 <skorpan> YOU are a core dumping piece of crap
03:04:26 <glguy> is there a version of (!) without bounds checking?
03:04:50 <skorpan> @src (!)
03:04:50 <lambdabot> arr@(Array l u _) ! i = unsafeAt arr (index (l,u) i)
03:05:01 <glguy> ?index unsafeAt
03:05:01 <lambdabot> bzzt
03:05:09 <glguy> ?hoogle unsafeAt
03:05:10 <lambdabot> No matches found
03:06:22 <scook0> glguy: check the source links from the public array documentation
03:06:34 <oerjan> glguy: it's an IArray method
03:06:56 <glguy> it's in Data.Array.Base
03:06:59 <glguy> at least
03:07:13 <scook0> also, unsafeAt uses Int indices rather than Ix, so it's not a drop-in replacement
03:07:16 <scook0> (iirc)
03:07:23 <smg> @src take
03:07:23 <lambdabot> take n _      | n <= 0 =  []
03:07:23 <lambdabot> take _ []              =  []
03:07:23 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
03:07:36 <skorpan> lub lub
03:10:25 <bringert> skorpan: what's up with the name calling?
03:10:31 <glguy> scook0: that's correct (and part of the benefit :) )
03:11:00 <scook0> yup
03:12:46 <glguy> bringert: he hasn't thrown names around since 08.03.12:13:07:39
03:13:14 <bringert> "skorpan: YOU are a core dumping piece of crap", 11:04
03:13:22 <glguy> (aside from the obvious instance just now)
03:14:03 <bringert> I'm assuming it's meant to be a joke, but I'm not sure everyone understands it as such
03:14:21 <alexeyr> Hi everyone! Is there a way to get tab completion and history handling for ghci under windows?
03:15:30 <bringert> this is one of the most civil irc channels, and I'd like to keep it that way. newcomers might think that name-calling is an acceptable level of discourse.
03:16:11 <solrize_> is there a simple way pattern match in an expression, without resorting to a case statement or let binding?
03:16:55 <glguy> ( \ (x:xs) -> undefined )?
03:17:34 <solrize_> like I have Just x and Right y, and i want to know if x==y
03:18:28 <solrize_> i.e. x is inside a Maybe value, and y is inside an Either, so i have to pattern match to get them out
03:18:30 <oerjan> > (\(Just x) (Right y) -> x == y) (Just 5) (Right 3)
03:18:31 <lambdabot>  False
03:18:45 <solrize_> ok, lambda binding, similar to let
03:19:04 <skorpan> bringert: sorry about that then
03:19:04 <hpaste>  solrize annotated "more IO pain" with "mysterious error" at http://hpaste.org/6327#a5
03:19:04 <glguy> > (\ Nothing -> () ) (Just 1)
03:19:05 <lambdabot>   Non-exhaustive patterns in lambda
03:19:07 <oerjan> a pattern matching _is_ a binding
03:19:09 <glguy> (don't forget)
03:19:22 <bringert> skorpan: no problem
03:20:29 <oerjan> solrize_: you also could make field names (if these are your own data types) or use some other extractor
03:20:37 <solrize_> 1) i'd like to get rid of the let/if/else at the end of the last paste; 2) i don't undestand why it won't compile, it says "the last statement of a do must be an expression", but i thought "let ..." IS an expression
03:20:56 <oerjan> let ... in ... is an expression
03:21:04 <oerjan> let ... alone is not
03:21:06 <solrize_> yeah, it's a let ... in
03:21:48 <oerjan> solrize_: you have , instead of ; in the let
03:22:08 <solrize_> oh!
03:22:09 <solrize_> thanks
03:22:19 <oerjan> that , triggered the parse error rule, so it thought the do ended there
03:22:24 <solrize_> haha
03:22:25 <quicksilver> Baughn: that's a bug in getUserEntryForName, no more, no less.
03:22:33 <quicksilver> Baughn: it is *not* a failure in haskell's exception handling.
03:22:59 <quicksilver> Baughn: file a bug and preferably a patch :P
03:23:10 <oerjan> solrize_: now since you _are_ in a do, you can leave out the in and indent the if line less
03:23:12 <quicksilver> Lemmih: about?
03:24:09 <oerjan> solrize_: also you can combine all the lets in your do, since they are lazy
03:24:33 <oerjan> let me annotate
03:24:46 <solrize_> hmm now it's complaining about indentation
03:24:57 <oerjan> solrize_: _only_ the if line, not the else one
03:25:00 <quicksilver> oerjan: although some people prefer to order them logically rather than relying on the laziness.
03:25:05 <quicksilver> oerjan: it's a matter of taste, I think.
03:25:10 <oerjan> yeah
03:25:47 <solrize_> anyway what i was trying to do was bogus, the type error really was catching a bug.  wow!!
03:25:49 <glguy> the only advantage to using the extra lets in do notation I've seen is that it makes it easy to transplant them
03:25:51 <glguy> comment one out
03:25:52 <bringert> dcoutts, Igloo: is there any chance of trac.haskell.org happening soon? is there anything I can do to help make it happen?
03:25:53 <glguy> etc
03:25:58 <scook0> I find myself avoiding non-monadic let, because I can never figure out how to best indent it :)
03:26:06 <quicksilver> heh.
03:26:14 <scook0> so I'm a where-junkie instead
03:26:25 <quicksilver> I tend to prefer let over where, but use both.
03:26:25 <bringert> scook0: yeah, it's a pain
03:26:44 <scook0> it's also easy to interconvert between monadic-let and <-
03:26:45 <hpaste>  oerjan annotated "more IO pain" with "Alternative" at http://hpaste.org/6327#a6
03:26:50 <scook0> when changing the monadicity of your functions
03:27:06 <hpaste>  solrize annotated "more IO pain" with "indentation.." at http://hpaste.org/6327#a7
03:27:11 <quicksilver> scook0: beware of the difference between "s <- foo s" and "let s = foo s" ;)
03:27:17 <quicksilver> scook0: has bitten me more than once
03:27:49 * scook0 makes a mental note to institute an occurs-check
03:28:09 <solrize_> oerjan, thanks, yeah that looks attractive
03:28:18 <solrize_> still has my wrong semantics :)
03:30:12 <hpaste>  solrize annotated "more IO pain" with "still wrong indentation" at http://hpaste.org/6327#a8
03:30:56 <oerjan> solrize_: else must be indented more
03:31:04 <solrize_> oh, it can't line up with the if
03:31:07 <solrize_> hmm
03:31:13 <oerjan> it's a frequent annoyance of mixing do blocks with if-then-else
03:31:21 <solrize_> ugh now i get a mess of type errors
03:31:24 <oerjan> (since that's the only place the problem shows up)
03:31:37 <solrize_> i can't compare two plaintexts...
03:31:54 <solrize_> i added deriving eq
03:32:02 <solrize_> now it compiles
03:32:38 <hpaste>  solrize annotated "more IO pain" with "now it works!  thanks" at http://hpaste.org/6327#a9
03:32:54 <quicksilver> oerjan: for some people it shows up with case of, as well
03:33:03 <oerjan> yeah
03:33:10 <quicksilver> I don't write case of that way.
03:33:22 <quicksilver> Did they add a ghc extension for the if/then thing in recent versions?
03:33:22 <hpaste>  solrize annotated "more IO pain" with "the whole file" at http://hpaste.org/6327#a10
03:33:27 <tibbe> @seen dons
03:33:27 <lambdabot> dons is in #xmonad, #haskell-soc and #haskell. I last heard dons speak 4h 7m 13s ago.
03:33:34 <quicksilver> (I was opposed to that, I prefer a simple layout rule to one with lots of exceptions.
03:33:35 <tibbe> anyone familiar with the deep RULES magic?
03:33:58 <quicksilver> tibbe: the two simons, dons and dcoutts are your best bets as far as I know.
03:34:13 <tibbe> I need to find them then :)
03:34:19 <tibbe> @seen JaffaCake
03:34:19 <lambdabot> I saw JaffaCake leaving #haskell and #ghc 11h 3m 51s ago, and .
03:34:31 <tibbe> @seen dcoutts_
03:34:31 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell-overflow, #haskell and #ghc. I last heard dcoutts_ speak 12h 36m 20s ago.
03:35:42 <tibbe> what's the other simon's handle?
03:35:54 <oerjan> never seen him here i think
03:36:00 <quicksilver> he doesn't IRC often.
03:36:39 <tibbe> ah, ok
03:37:06 <tibbe> I guess I should do a write-up to -cafe or glasgow-haskell-users
03:37:26 <tibbe> I had one rules which used to fire but doesn't anymore
03:38:23 <solrize_> how reliable do you folks think ghc is compared with e.g. python ?
03:38:50 <opqdonut> very
03:39:06 <ZimaN> what do you mean by `reliable'?
03:39:08 <opqdonut> staticness implies reliability :)
03:40:47 <tibbe> if you want some anecdotal evidence I've never had any problems with GHC not attributable to my own, small brain
03:43:25 <solrize_> zimaN, by reliable i mean my program won't fail because of incorrect code in the compiler or the libraries that come with it
03:43:52 <quicksilver> I've never personally experience a bug where the compiler generated wrong code.
03:43:54 <quicksilver> Ever.
03:43:54 <Botje> solrize_: uh, incorrect code in the compiler would make _ANY_ code fail :)
03:44:17 <quicksilver> I've experienced a bug in which incorrect code (which should have been rejected) made the compiler crash in a surprising way.
03:44:41 <quicksilver> Of course, there have been code generation bugs. But I'm pleased to say they've been incredibly rare.
03:45:18 <solrize_> let's say boeing makes a new jetliner and progams the avionics in haskell.  are you willing to be a passenger on the first flight?
03:45:37 <Botje> sure
03:45:40 <quicksilver> More so that if they'd written it in C++, certainly.
03:45:52 <Botje> "I flew with lambda airlines!"
03:45:54 <quicksilver> the question is more about their testing regime and their engineers than the compiler, to be honest.
03:46:09 <solrize_> quicksilver, true, i think they usually use ada for that stuff though
03:46:20 * solrize_ has gotten interested in ada, which is probably insane
03:48:49 * Baughn would be unwilling to set foot on any flight where crucial software has used unverified compilers
03:49:03 <Baughn> Mind you, if boeing /did/ do that, they'd probably do a thorough code review of ghc first
03:49:34 <solrize_> ghc seems too big to review
03:50:28 <solrize_> what's a verified compiler?  just one that has been reviewed?  or one written in something like coq?
03:51:10 <Baughn> Depends on your degree of paranoia
03:51:36 <quicksilver> "Who shall verify the compiler verifiers?"
03:51:37 <quicksilver> etc
03:53:19 <Baughn> solrize_: GHC being big /is/ a problem. I'd be fine with using it for most situations, but probably not bank backends, flight instruments or nuclear plant safety systems.
03:54:12 <solrize_> so what would you use for that?  GCC is probably as big as GHC and it's written in a much scarier language :)
03:54:20 <johnnowak> solrize: nothing insane about being interested in ada
03:54:38 <johnnowak> solrize: spark ada is often used for such things
03:54:58 <Baughn> solrize_: Not my field, but probably ada or some such
03:55:02 <solrize_> hmm
03:55:35 <solrize_> i thought those projects used ada mostly b/c it's been around for so long and it's understandable by non-CS engineers
03:55:55 <Baughn> The second is a lie. There is no such thing as a language that's understandable to non-cs people.
03:56:11 <solrize_> ???
03:56:25 <johnnowak> solrize: ada, and especially variants like spark ada, have a lot of features that help you write bug-free and secure code
03:56:27 <solrize_> non-CS people write python, vb, spreadsheets, etc. all the time
03:56:37 <Baughn> solrize_: Okay. Clarification:
03:56:51 <Baughn> solrize_: There is no such thing as a language that won't let cs people write code that non-cs-people won't understand
03:57:01 <opqdonut> :)
03:57:06 <solrize_> that makes sense
03:57:18 <vincenz> That's a rather plain tautology
03:57:25 <johnnowak> Baughn: sure there is.
03:57:26 <Baughn> It's not a tautology
03:57:38 <johnnowak> http://www.cliff.biffle.org/esoterica/hq9plus.html
03:57:38 <lambdabot> Title: HQ9+
03:58:02 <Baughn> johnnowak: ...I should have known. Okay, no /useful/ language. ;)
03:58:07 <solrize_> aircraft and nuke stuff may actually be less demanding on the programming language than security stuff, since flight instruments usually aren't designed to withstand malice
03:59:08 <Baughn> As for haskell, I could make an argument that lazy evaluation is hard to reconcile with hard realtime systems
03:59:28 <solrize_> baughn, good point.  maybe GC in general too
03:59:35 <Baughn> solrize_: To the contrary
03:59:58 <Baughn> solrize_: Incremental GC is about the /only/ good memory-management scheme that doesn't collide with hard realtime. malloc/free certainly do.
04:00:32 <Baughn> (Quite a few other schemes also work, but they're considerably harder to use. Arena allocation and such.)
04:00:36 <johnnowak> likely you're just allocating everything up front anyway
04:00:37 * vincenz chuckles
04:00:47 <vincenz> Baughn: malloc and free are good for hard real time
04:00:58 <vincenz> Baughn: Just maybe not the variant that ships with $FAVOURITE_OS
04:01:21 <solrize_> i think the realtime ada profiles just use static allocation
04:01:29 <vincenz> But it is rather obvious that malloc/free should work if incremental GC works, for the good reason that you could always write the inc-gc code in your 'free' function
04:01:49 <Baughn> Now that's cheating
04:01:52 <vincenz> No it's not
04:01:55 <SamB> yeah, it is
04:02:15 <vincenz> The only difference between a gC and a malloc/free system is that the prior must discount what is no longer alive
04:02:39 <vincenz> s/discount/discover
04:02:39 <Baughn> An incremental gc does have the advantage that it can be /simple/
04:02:45 <SamB> anyway, is a conservative GC sufficient?
04:02:50 <vincenz> malloc/free can be simple too
04:02:57 <Baughn> SamB: For what?
04:03:04 <SamB> for hard realtime
04:03:13 <Baughn> SamB: I've never seen an incremental conservative gc, but I can't state with certainty that they're impossible
04:03:21 <SamB> you know, as opposed to a precise GC
04:03:26 <johnnowak> Baughn: even with an incremental gc and bounded collection times, that won't guarantee you that collections take up so much time that there's not enough cycles left to do any useful work
04:03:46 <vincenz> johnnowak: that''s a matter of system dimensioning
04:03:57 <SamB> johnnowak: hard realtime is about guarenteeing the opposite
04:04:14 <johnnowak> SamB: hm?
04:04:18 <SamB> that they WON'T take up too much time...
04:04:29 <solrize_> i've always been skeptical of conservative gc if it ever handles malicious data
04:04:30 <johnnowak> ah, typo.
04:04:37 <Baughn> johnnowak: Reserve a certain percentage of memory for the GC, and you guarantee a certain max time spent in GC. You have to figure out the maximal memory use anyway, so you might as well just increase that by 20%
04:04:39 <johnnowak> indeed i meant that.
04:04:52 <vincenz> Baughn: Right, system-dimensioning :)
04:05:31 <SamB> there's no guarentee that your task will run fast enough on a Z80, either
04:06:03 <solrize_> what would you use if you wanted to write some pure computational function, that had to be both reliable and super fast?  e.g. something like a DCT routine for a video decoder
04:06:28 <johnnowak> probably C.
04:06:30 <SamB> I would steal someone else's?
04:07:03 <sieni> fortran iv ftw!
04:07:05 <vincenz> Yep, I'd go with C too
04:07:22 <Baughn> solrize_: How fast?
04:07:43 <solrize_> i think C is both 1) not fast enough, i don't know any C compilers that generate XMM instructions on the x86 for example; and 2) not reliable enough, i remember there were bugs in libjpeg and in libgzip for years, that could cause buffer overflows (= security failure) on some maliciously crafted malformed inputs
04:07:51 <sieni> solrize_: or you could adapt fftw to producing dct code
04:08:02 <solrize_> dct was just an example
04:08:04 <vincenz> solrize_: hardware?
04:08:09 <vincenz> solrize_: it's a poorly picked example
04:08:13 <johnnowak> solrize: not everyone writes code with buffer overflows
04:08:20 <solrize_> vincenz, maybe poorly picked
04:08:20 <vincenz> for one cause most embedded systems put stuff like that in HW
04:08:20 <Baughn> solrize_: Since you mentioned "video decoder".. VHDL, perhaps
04:08:38 <vincenz> I bet most ARMs ship with a DCT Block if you pick the right one
04:08:44 <solrize_> johnnowak nobody writes code with buffer overflows on purpose :)
04:08:58 <johnnowak> solrize_: sure, but that really has little to do with it
04:09:04 <SamB> or you could use an FPGA
04:09:11 <vincenz> eww
04:09:27 <solrize_> video is just an example, i'm wondering about the general case of wanting to write a critical subroutine for max performance and max assurance at the same time
04:09:29 <vincenz> SamB: there's no reason to put this on an FPGA
04:09:45 <Baughn> An FPGA can in some circumstances be faster than an ASIC, so.. *grin*
04:09:50 <solrize_> i.e. Ada is probably a better choice than C
04:10:00 <SamB> probably cheaper too
04:10:01 <vincenz> Baughn: slurp slupr, power, slurp slurp
04:10:14 <SamB> hmm, power usage I don't know about
04:10:20 <johnnowak> solrize_: ada would be no faster than C, likely slower
04:10:25 <solrize_> different example: bignum arithmetic for public key cryptography
04:10:25 <Baughn> vincenz: 's okay. We have to keep the heating on all year anyway.
04:10:43 <vincenz> anywho, for something as std like DCT, cast it into hardware
04:10:49 <vincenz> been there, done that
04:10:56 <vincenz> it only costs more if you have to make a new chip for it
04:11:13 <SamB> well, I heard that most hardware designs include some kind of PLD these days...
04:11:14 <johnnowak> solrize_: C?
04:11:15 <vincenz> FPGA is only a good choice for : experimental setups or very specific hw
04:11:28 <vincenz> SamB: yes, but not for something as std as DCT
04:11:46 <solrize_> i met a guy from coverity last night and told him that after reading dawson engler's page i left feeling like C should just be outlawed :)
04:11:48 <SamB> okay
04:12:26 <solrize_> and if i write in C, then there's the question of how to compile it
04:12:53 <SamB> what did you actually want to write?
04:12:53 <QtPlatypus> Well thats a problem with any compiled lang.
04:13:48 <SamB> QtPlatypus: hmm, in context I think he means how to compile it in such a way as to generate highly-optimized code
04:13:55 <johnnowak> forth would be an interesting choice for such things perhaps. there's so little there that you can verify it all the way down. if something goes wrong, it's your fault.
04:14:05 <solrize_> samb, it's more of an academic/theoretical question, but i'm interested in 1) internet security / crypto; 2) medical devices
04:14:20 <baaba> <solrize_> johnnowak nobody writes code with buffer overflows on purpose :) <-- i guess you never saw anyone type "sprintf"
04:14:24 <solrize_> by "how to compile it" i meant "am i really going to trust something as crufty as gcc, for a critical program" ?
04:14:51 <johnnowak> solrize_: you can't
04:15:23 <SamB> solrize: please do not discuss medical devices seriously here
04:15:24 <solrize_> is there really stuff done about verification of forth?
04:15:35 <scook0> I remember hearing murmurs about (BSD?) kernel devs expressing interest in a simpler, more trustworthy C compiler
04:15:43 <SamB> but you said your interest is academic/theoretical, so I suppose it is okay...
04:15:56 <johnnowak> scook0: they're working with pcc
04:16:16 <solrize_> interesting
04:16:33 <quicksilver> SamB: why would it not be appropriate to dicuss (programming for) medical devices seriously here?
04:16:39 <quicksilver> it strikes me as a very interesting topic.
04:16:40 <SamB> I mean, I'm only okay with causing hypothetical deaths, not actual ones...
04:16:47 <solrize_> hehe
04:16:58 <quicksilver> discussing it is different from asking you to write the code :)
04:17:11 <solrize_> probably more people have been killed by spreadsheets than by buggy embedded code :)
04:17:23 <SamB> well, by "seriously" I mean "with the intent of going on to write actual code"
04:17:36 <quicksilver> solrize_: For some small (but interesting) modules it is possible to model-check the generated code.
04:17:42 <johnnowak> guaranteed termination!
04:17:50 <quicksilver> solrize_: by which I mean, exhaustively check every possible set of inputs and confirm the correct output.
04:17:53 <SamB> johnnowak: use a death laser!
04:18:02 <solrize_> quicksilver hmm interesting
04:18:03 * johnnowak loses an eye
04:18:08 <quicksilver> solrize_: once you've done that, you don't have to worry about your compiler.
04:18:16 <quicksilver> (you have to worry about your model checker, of course!)
04:18:17 <SamB> quicksilver: that only works for combinational code
04:18:31 <quicksilver> right. It does turn out to cover some interesting cases, though..
04:18:36 <SamB> and perhaps trivial sequential code
04:18:54 <quicksilver> There are also cases where you can provide interesting continuity arguments.
04:19:04 <SamB> (using combinational and sequential as defined in any standard logic design textbook)
04:19:17 <quicksilver> if you can model your assembly language, or some intermediate form, as having only continuous components.
04:19:28 <SamB> hmm.
04:19:43 <quicksilver> Microsoft have done some interesting work on model checking device drivers. (That's not exhaustive checking, though.)
04:19:46 <SamB> linear or non-linear?
04:20:00 <solrize_> continuous?  like in math?
04:20:04 <SamB> solrize: yes!
04:20:08 <quicksilver> yes, continous like in math
04:20:17 <quicksilver> although sometimes with a slightly unfamiliar topology.
04:20:29 <solrize_> hmm
04:21:10 <SamB> what kinds of topology?
04:21:34 <SamB> C^n not good enough?
04:21:37 <solrize_> i've seen some papers about machine code verification where they have a formal model of the instruction set, but they always seem to use some toy subset instead of the full banana
04:21:56 <SamB> solrize: of course
04:22:06 <SamB> that's for didactive reasons
04:22:17 <solrize_> yeah
04:22:20 <SamB> they can't fit the whole instruction set in a standard-sized paper
04:22:58 <solrize_> well even the parts that aren't in the paper, they don't try to model the whole instruction set, but i think the chip designers must have to do that
04:23:13 <solrize_> so it's disappointing that there's not code around for it
04:23:20 <SamB> hmm?
04:23:38 <SamB> oh, you mean the code downloads don't cover nearly the whole set either?
04:23:46 <solrize_> right
04:24:05 <SamB> not even the whole user-side i386 set?
04:24:11 <solrize_> right
04:24:26 <solrize_> well the later x86's anyway which are bigger
04:24:26 <ivanm> does the fgl library support both directed and undirected graphs?
04:24:51 <SamB> I meant specifically 386, in this instancef
04:24:54 <solrize_> althouhg, i haven't been looking real hard
04:24:59 <solrize_> samb not sure about 386
04:24:59 <SamB> s/f$//
04:26:12 <skorpan> how do you guys pronounce GADT?
04:26:27 <ivanm> GAD-T?
04:26:45 <steven_ashley> gee aye dee tee?
04:26:49 <SamB> Gee Ay Dee Tee
04:27:12 <SamB> doesn't aye rhyme with eye?
04:27:22 <steven_ashley> depends where you live ;)
04:27:24 <SamB> er. sound the same?
04:27:40 <skorpan> aye1      /aɪ/ Pronunciation Key - Show Spelled Pronunciation[ahy]
04:27:41 <steven_ashley> but yes, properly speaking
04:27:47 <skorpan> aye2      /eɪ/ Pronunciation Key - Show Spelled Pronunciation[ey
04:27:51 <steven_ashley> I think :/
04:28:56 <Baughn> Never yet had to pronounce it. "Gad-tee", I guess
04:29:07 <SamB> well, however "A" is spelled
04:29:13 <quicksilver> solrize_: of course then it remains to check if the actual chips correctly implement the instruction set.
04:29:23 <quicksilver> solrize_: (and of course, they don't. All chips have bugs)
04:29:24 <johnnowak> i've seen people say G A D T
04:29:40 <johnnowak> i tend to say "gat" when talking to myself.
04:29:49 <opqdonut> i say [gadt]
04:29:57 <skorpan> a friend of mine said "gadget" which sounds cool
04:29:58 <opqdonut> to myself at least
04:30:00 <SamB> opqdonut: how do you verbalize the []
04:30:02 <quicksilver> I tend to say "my precious, wantss it" when talking to myself.
04:30:07 <Baughn> solrize_: So you want to use a democratic process of execution, and have three different CPUs /made by three different teams/
04:30:10 <SamB> quicksilver: ... scary
04:30:24 <opqdonut> SamB: [] meaning pronunciation
04:30:33 <opqdonut> knot [not]
04:30:34 <SamB> Baughn: which somehow have identical timing?
04:30:36 <opqdonut> and so on
04:30:45 <solrize_> baughn, yeah, and with separate software implementation on machine #4, like on the space shuttle
04:30:58 <Baughn> SamB: Doubt it. Use asynchronous latches.
04:31:04 <solrize_> although i think the 3 primary machines are the same
04:31:42 <SamB> yeah, Baughn's way sounds a bit complicated
04:31:55 <Baughn> It should be reliable, though
04:32:11 <SamB> only if the way you interconnect the CPUs is...
04:32:48 <johnnowak> yarn and masking tape
04:32:54 <Baughn> The interconnect should be simpler, and such less likely to make mistakes
04:33:05 <Baughn> Otherwise there's no point, of course
04:33:07 <steven_ashley> SamB: I pronounce 'eye' like the letter 'i' and 'aye' like the letter 'a'. A New Zealand thing I guess :P
04:33:25 <solrize_> in the end it comes down to engineering, i.e. perfection is unattainable.  what i'm wondering is, how closely the academic functional programmers are able to approach (or surpass) the assurance levels of the millitary/NASA/medical crowd using lower tech methods but with a lot of process bureaucracy
04:34:05 <Baughn> FWIW, I've never yet seen a haskell program with a real bug
04:34:08 <solrize_> i mean it's nice that the bsd folks are trying to write another C compiler in C, but if they wrote in haskell they'd probably get something more reliable
04:34:15 <solrize_> darcs had bugs, i thought
04:34:17 <johnnowak> Baughn: define bug.
04:34:37 <solrize_> ghc has a bug tracker :)
04:34:41 <Baughn> johnnowak: "Program causes unrecoverable error"
04:34:51 <Baughn> Yeah, I know. I haven't looked very hard.
04:35:02 <johnnowak> solrize_: aye, you have git, pile of perl and C that it is, gaining popularity rapidly, and darcs, written in haskell, suffering because it goes on vacation for weeks at a time
04:35:14 <SamB> I could write a bad fsck
04:35:35 <Baughn> SamB: Bugs aren't bugs if they're deliberate
04:35:38 <SamB> johnnowak: darcs goes on vacation?
04:35:47 <Botje> solrize_: did you see the study on programming languages?
04:35:48 <SamB> Baughn: I wouldn't have to do it deliberately
04:35:54 <johnnowak> SamB: takes hours for simple actions sometimes
04:36:02 <solrize_> botje which paper?
04:36:04 <SamB> johnnowak: even HEAD?
04:36:13 <DQuest> I'd say haskell has a natural advantage because the type system picks up most errors, referential transparency means you can write decently modular software and not worry about breaking other components, and the functional approach lends it self better to abstraction.  It doesn't mean that your logic will be bug free, mind
04:36:24 <DQuest> itself, even
04:36:28 <SamB> johnnowak: using a darcs-2 repository?
04:36:29 <Botje> http://web.cecs.pdx.edu/~apt/cs457_2005/hudak-jones.pdf
04:36:43 <solrize_> oh yes i saw that
04:36:46 <johnnowak> SamB: darcs 2 supposedly fixes thing.
04:36:53 <solrize_> 1000 lines of ada vs. 80 lines of haskell or something like that
04:36:54 <johnnowak> to be clear, i'm not bashing darcs. it's all i use.
04:37:27 <SamB> johnnowak: if you personally experience these problems regularly, you should be testing darcs2
04:37:37 <johnnowak> SamB: i am
04:37:42 <SamB> good
04:37:48 <mux> I've been bitten by darcs a few times; probable cos the revert command isn't the same apparently as the one in cvs
04:37:49 <johnnowak> although i personally didn't experience them often
04:37:55 <SamB> okay
04:38:06 <SamB> me either, really
04:38:21 <johnnowak> perhaps an overblown issue...
04:38:21 <SamB> I've hit them a few times, I guess.
04:38:39 <SamB> most notably when Lemmih completely reorganized the conjure repository
04:38:50 <johnnowak> regardless, it does seem to be the reason it gets little use. well, that and the fact that people don't enjoy compiling ghc.
04:39:30 <SamB> I just had to forget about trying to merge my locally-created patches automatically then
04:39:46 <SamB> compiling ghc?
04:40:10 <solrize_> dquest one thing i've heard is that the ada compilers have to be tested very extensively for certification, and also that the language spec is very rigorous (I don't know if it has a formal semantics like SML); haskell seems loose by comparison.
04:40:10 <Zao> The last couple of versions I haven't been able to cross compile it :(
04:40:39 <SamB> cross compile what?
04:41:04 <Zao> GHC.
04:41:11 <SamB> you were able to before?
04:41:28 <Zao> I've had more success with things like 6.4 than 6.6 and 6.8 at least.
04:41:47 <DQuest> solrize_: I don't know ADA so I can't really comment.  That said, I'd also heard that it's very well tested.
04:42:02 <solrize_> if i actually write this crypto lib in haskell, i'm sort of toying with the idea of putting it onto a gumstix board and trying to put it through fips 140-3
04:43:17 <Zao> SamB: It's mostly rooted in that the binary blob GHCs do not build cleanly on neither my AIX 5.3 or Solaris boxen.
04:43:24 <DQuest> I'd totally forgotten about gumstix
04:43:46 <solrize_> do you know anything about typed assembly code?  is that just for writing proof carrying code, or is it actually helpful for ensuring that compilers don't trip up?
04:44:04 <solrize_> gumstix is cool, i just wish they made one that was completely usb powered
04:50:14 <solrize_> agda was written by someone named catarina coquand,  i wonder if she is related to thierry coqand, the guy who did coq?
04:52:41 <skorpan> coquand was my teacher, is he famous?
04:53:58 <SamB> solrize: compilers could generate typed assembly language
04:54:00 <mattam> skorpan: he is, and his wife catarina too, in the Type Theory community.
04:54:05 <solrize_> thierry coquand?  yes, very famous.  everyone who uses coq has heard of him .
04:54:20 <SamB> it would be useful to assure that they don't screw up the typesafety at the last possible moment
04:54:27 <Heffalump> is that like saying Haskell is a famous programming language? :-)
04:54:59 <mattam> Thierry Coquand has left the Coq development team for a long time though.
04:55:00 <SamB> Heffalump: is it?
04:55:12 <SamB> it's not as well-known as Java, obviously.
04:55:34 * Heffalump doesn't know much about typed assembly languages; do they normally use dependent types?
04:55:44 <Smurfen_> skorpan: His wife is head of a department here
04:55:50 <skorpan> Smurfen_: i see
04:55:51 <SamB> but then, when I heard Java was the language of the web, I then concluded that what I know know as HTML must be Java ;-)
04:55:56 <skorpan> Smurfen_: are you planning on taking his course?
04:56:04 <Smurfen_> Which one?
04:56:15 <skorpan> logic in computer science
04:56:23 <skorpan> it was a good course
04:56:39 <Smurfen_> Maybe sometime
04:56:44 <SamB> Heffalump: apparantly some do. there's no reason why they shouldn't.
04:56:52 <johnnowak> Botje: that hudak/jones paper is just silly
04:58:07 <hallongrottan> skorpan: are you planning on taking automata theory?
04:58:09 <Heffalump> well, it's kind of necessary for many of the low-level games you might want to play on assembler optimisation
04:58:15 <hallongrottan> thierry has that course aswell
04:58:22 <Smurfen_> He's quite cool
04:58:26 <Smurfen_> A lot of chocolate though
04:58:33 <solrize_> he's in .se now?
04:58:40 <hallongrottan> solrize_: yes, he works at chalmers
04:58:53 <skorpan> hallongrottan: nope
04:58:59 <solrize_> chalmers sounds like a central place for this stuff
04:59:17 <hallongrottan> skorpan: why not?
05:00:01 <DQuest> oooh
05:00:15 * DQuest has been pondering PhDing in type theory and functional programming.  I didn't know about that one
05:00:18 <Vico> coquand is a horrible lecturer though
05:00:26 <DQuest> I'd have to learn swedish, mind
05:00:42 <Vico> which is pretty sad
05:00:52 <Smurfen_> I don't think so
05:00:53 <Smurfen_> :/
05:01:11 <quicksilver> something very odd about someone coming into a channel and joining a conversation which started before they arrived, and using their first sentence to insult/criticise.
05:01:25 <Vico> shoulder-ircing quicksilver ;)
05:02:04 <SamB> it was either that or the logs
05:02:06 <yitz> solrize_: We are far behind the military/NASA/medical crowd. Their methods also assure job security and certification. We only prevent bugs.
05:02:18 <SamB> I've seen that kind of thing happen before ;-)
05:02:58 <yitz> quicksilver: hi, how are you. Your keyboard squeaks - ha!
05:04:00 <solrize_> did you read that joel reymont rant against haskell a while back?
05:04:01 * quicksilver shudders
05:04:09 <quicksilver> solrize_: the poker one?
05:04:13 <quicksilver> yes we all read it multiple times
05:04:20 <quicksilver> it kept being ressurected by sites like reddit :P
05:04:30 <quicksilver> night of the living poker servers
05:04:46 <titusg> not me. worth reading?
05:04:48 <jones-> solrize_: link?
05:05:01 <quicksilver> titusg: if you want an insight into how a programmer might misunderstand haskell, yes.
05:05:08 <ivanm> does the fgl library support both directed and undirected graphs?
05:05:11 <quicksilver> if you're hoping for insights into how to program haskell, no :P
05:05:26 <titusg> I must say, I wouldn't expect too much from him.
05:05:29 <Gilly> if I read contents of a socket using hGetContents can I still write to it?
05:06:20 <titusg> There was a funny thread on c.l.l. last week about that -- "I've been using haskell for a whole week, and here's what's wrong with it..."
05:07:30 <doserj> ivanm: i think it does directed graphs
05:07:31 <bringert> DQuest: you don't have to learn swedish to be a phd student at chalmers
05:07:47 <ivanm> doserj: hmmm..... well, realistically, that's what I need ;-)
05:07:48 <solrize_> quicksilver, yeah, the poker server.  jones, gimme a sec to find the link
05:07:53 <ivanm> I just thought it did undirected
05:08:07 <Heffalump> DQuest: I don't think you need to learn Swedish to work at Chalmers. Might help for living in Sweden, though.
05:08:08 <bringert> DQuest: have you seen this http://www.cs.chalmers.se/~koen/phdad.html
05:08:09 <lambdabot> Title: PhD Positions in Functional Programming at Chalmers
05:08:12 <solrize_> zomg, he's using factor now
05:08:13 <DQuest> bringert: I imagine it'd make life easier though.  Besides, there's nothing quite so embarassing as being in a foreign country and having to use English
05:08:23 <Vq^> titusg: c.l.l.?
05:08:26 <Heffalump> oh, bringert just said that. Sorry :-)
05:08:38 <bringert> DQuest: we have lots of foreign phd students here. they pick up swedish along the way
05:08:40 <titusg> Vq^: comp.lang.lisp
05:08:49 <bringert> DQuest: some really well
05:09:08 <bringert> DQuest: the best way is to find a swedish girl-/boyfriend
05:09:14 <Heffalump> I think if I wasn't a native English speaker I'd be less embarrassed about visiting countries and not knowing the native language
05:09:15 <quicksilver> I learnt some computer-game swedish once.
05:09:25 <_alexey_r_> I don't get tab completion in cygwin using rlwrap. Is this normal?
05:09:32 <quicksilver> not very useful in general.
05:09:51 <DQuest> Heffalump: yeah.  I feel like another arrogant English person if I'm forced to walk up to people and try english
05:10:24 <steven_ashley> > (head . fst) (foldr (\a (b,c) -> (a:b,a:c)) ([],[]) (1:error "input list"))
05:10:25 <lambdabot>  Exception: input list
05:10:26 <steven_ashley> head (foldr (\a b-> a:b) [] (1:error "input"))
05:10:30 <steven_ashley> > head (foldr (\a b-> a:b) [] (1:error "input"))
05:10:31 <lambdabot>  1
05:10:32 <Heffalump> I find France ok because I speak enough French to try to communicate. Most people quickly switch to English of their own volition, but at least I tried.
05:10:33 <steven_ashley> :/
05:10:49 <solrize_> jones-  http://www.wagerlabs.com/blog/2006/01/haskell-vs-erla.html
05:10:50 <lambdabot> Title: Tenerife Skunkworks: Haskell vs Erlang: Reloaded
05:11:00 <Heffalump> in Germany I can at least ask if they speak English in German. Everywhere else, I'm totally stuffed.
05:11:42 <vincenz> Heffalump: easy "english?"
05:12:03 <DQuest> "The last date for your full application to arrive is March 11, 2008."
05:12:04 <DQuest> nevermind then
05:12:06 <vincenz> if they speak english then they can understand an english question
05:12:13 <titusg> solrize_: *That* joel, right. Too many blogging joels.
05:13:11 <Heffalump> vincenz: sure, but it's politer.
05:13:33 <bringert> DQuest: if you are seriously interested, send koen an e-mail and check if you could still apply
05:13:33 <yitz> Here's a more recent rant: http://www.wagerlabs.com/blog/2007/05/who-let-the-dog.html
05:13:34 <lambdabot> Title: Tenerife Skunkworks: Who let the dogs out?
05:13:53 <solrize_> that's the one where he decides he likes ML
05:13:56 <georgw> Can a function return more than one variable?
05:13:57 <solrize_> i dunno if he stuck with that
05:14:33 <yitz> georgw: a tuple, or a list.
05:14:48 <georgw> yitz: tuple
05:14:59 <vincenz> yitz: haha "trading did not turn out so well for me" and now he's doing trading
05:15:10 <Vq^> georgw: they have to return a single value in the same way as they can only take a single value as an argument
05:15:20 <georgw> yitz: Say something like (12, False)
05:15:28 <yitz> georgw: sure
05:15:38 <georgw> yitz: That's good news. :-)
05:15:39 <DQuest> bringert: I've not even got a CV ready at the moment.  I might be able to whip one up tomorrow though
05:15:43 <yitz> georgw: or any other complex data structure of your choice.
05:16:19 <georgw> yitz: Yeah, but I didn't want to declare complicated structures for just one function call...
05:16:28 <DQuest> I may well just take a year off from computers anyway.  Four years without a rest gets a bit stressful
05:16:34 <yitz> georgw: then tuple's the way to go.
05:16:39 <DQuest> This may be finals stress :P
05:16:42 <georgw> yitz: Cool, thanks.
05:16:48 <solrize_> bbl, thanks for all the help everyone
05:41:19 <smg> @src (>>=)
05:41:19 <lambdabot> Source not found. My brain just exploded
05:41:23 <smg> hehe
05:41:56 <opqdonut> @src (>>=) Maybe
05:41:56 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
05:42:05 <opqdonut> @src Maybe (>>=)
05:42:05 <lambdabot> (Just x) >>= k      = k x
05:42:05 <lambdabot> Nothing  >>= _      = Nothing
05:42:08 <opqdonut> :)
05:42:12 <opqdonut> you need to specify the instance
05:47:46 <smg> @src liftM
05:47:46 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
05:49:20 <skorpan> liftM is like a monadic version of ($) in some sense
05:49:32 <skorpan> that's how i like to think of it at least
05:51:29 <opqdonut> liftM is fmap :)
05:51:31 <quicksilver> that's why <$> == liftM
05:51:37 <quicksilver> because it "looks like" ($)
05:51:54 <skorpan> oh cool
05:51:58 <skorpan> i didn't even know that
05:52:04 <skorpan> @src fmap
05:52:04 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
05:52:35 <steven_ashley> fmap is part of the class Functor
05:52:36 <resiak> @src [] fmap
05:52:36 <lambdabot> fmap = map
05:52:40 <resiak> @src IO fmap
05:52:40 <lambdabot> fmap f x = x >>= (return . f)
05:52:44 <opqdonut> @src Monad fmap
05:52:44 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
05:52:51 <opqdonut> @src (Monad m) fmap
05:52:52 <lambdabot> Source not found. My mind is going. I can feel it.
05:52:53 <skorpan> i don't understand in what way fmap == liftM
05:53:14 <opqdonut> dig up the Functor instance for Monad
05:53:33 <skorpan> Monad m => Functor (WrappedMonad m)
05:53:35 <skorpan> that one?
05:53:44 <opqdonut> but the type is right: a -> b -> m a -> m b
05:53:48 <opqdonut> skorpan: yeah
05:53:51 <quicksilver> skorpan: all monads should also be functors.
05:53:56 <opqdonut> and it obeys the functor laws
05:54:03 <skorpan> i don't even know what a functor is tbh
05:54:03 <quicksilver> skorpan: (and, if they are, liftM is the "right" definition of fmap)
05:54:09 <opqdonut> there is a hierarchy of classes here, Monad>Applicative>Functor
05:54:20 <quicksilver> skorpan: a functor is something you can sensibly use 'liftM' on
05:54:20 <opqdonut> skorpan: functor is just a container :)
05:54:25 <quicksilver> skorpan: that's a good way to think of it.
05:54:28 <smg> @src ap
05:54:28 <lambdabot> ap = liftM2 id
05:54:29 <opqdonut> something you can map on
05:54:30 <quicksilver> (fmap, if you prefer)
05:54:37 <smg> ah interesting
05:54:49 <skorpan> oh
05:54:56 <quicksilver> it in some limited sense 'contains' values of type 'a' and you can 'apply' a function to all of them.
05:54:58 <skorpan> "something you can map on" sounds reasonable
05:55:09 <quicksilver> Maybe, List and Tree are the prototypical examples.
05:55:14 <skorpan> instance Functor [] where
05:55:14 <skorpan>     fmap = map
05:55:16 <quicksilver> Monads give you slightly more sophisticated examples.
05:55:18 <opqdonut> IO is pretty good too
05:55:21 <opqdonut> an example
05:55:28 <Vq^> titusg: that fella was a bit weird
05:55:35 <skorpan> fmap f x           =  x >>= (return . f)
05:55:46 <skorpan> i'm not sure in what sense "mapping" is going on there
05:56:23 <steven_ashley> the result of x is being mapped onto another value by f ?
05:56:30 <quicksilver> well >>= "extracts" the result of the action "X"
05:56:31 <opqdonut> take the value out of x (unwrap), apply f, and return (wrap
05:56:31 <skorpan> yeah, i just got i t:)
05:56:41 <quicksilver> then, you apply f to that result
05:56:45 <quicksilver> and re-wrap
05:56:46 <quicksilver> :)
05:56:58 <skorpan> (return . f) was tricky for a second there
05:57:13 <skorpan> but then i realised that "do res <- x; return $ f x" is the same thing
05:57:21 <skorpan> no
05:57:23 <skorpan> f res*
05:57:31 <doserj> haskell sometimes requires bidirectional reading abilities :)
05:57:36 <skorpan> doserj: indeed!
05:57:51 <doserj> x >>= f >>> return
05:57:58 <skorpan> @src (>>>)
05:57:58 <lambdabot> Source not found. Just try something else.
05:58:23 <doserj> (>>>) = flip (.)
05:58:38 <doserj> (to make it simple...)
05:59:09 <skorpan> wow, that was weird.
05:59:13 <opqdonut> doserj: that's a nice way of putting it
05:59:26 <skorpan> i don't think that i would ever write it like that
05:59:47 <opqdonut> skorpan: you will, you will
06:00:03 <skorpan> how do i know which of >>= and >>> has higher precedence?
06:01:42 <doserj> infixl1 >>=, infixr1 (>>>)
06:01:45 <doserj> so my example would need some parantheses :)
06:01:55 <skorpan> let me guess
06:02:00 <skorpan> (x >>= f) >>> return?
06:02:34 <doserj> you had a 50:50 chance ...
06:02:38 <skorpan> dammit.
06:02:44 <skorpan> @src flip
06:02:44 <lambdabot> flip f x y = f y x
06:02:46 <doserj> think about the types
06:03:23 <doserj> (or think about the original version with (.)
06:03:39 <skorpan> flip f x y = f y x...
06:03:59 <skorpan> the fact that >>> is infix messes me up
06:06:07 <doserj> flip x * y = y * x
06:06:19 <doserj> (abusing the syntax...)
06:08:31 <dcoutts_> @seen bringert
06:08:31 <lambdabot> bringert is in #darcs, #ghc and #haskell. I last heard bringert speak 1m 47s ago.
06:10:17 <bringert> hi dcoutts_
06:28:55 <edwinb> Cabal question: If I have a library section and an executable in my .cabal file, should I expect it to build everything twice?
06:29:43 <mauke> sadly, yes
06:29:58 <edwinb> curses
06:30:08 <edwinb> not that it takes long
06:30:14 <edwinb> just seemed odd
06:35:29 <tibbe> but it's a known problem
06:43:42 * shteou cracks open the wine and write code
06:43:53 <shteou> This is going to get messy :)
06:48:09 <byorgey> edwinb: basically, it's currently impossible to have an executable which depends on a library which is built from the same .cabal file.
06:48:50 <byorgey> edwinb: since it first checks to see whether all the dependencies are satisfied before building everything, and at that point the library is of course not installed.
06:49:09 <byorgey> not that this can't be solved of course, but IIUC it's tricky.
06:49:31 <edwinb> shame, it'd be a bit neater that way but it doesn't really matter
06:49:38 <byorgey> indeed.
06:53:57 * EvilTerran ponders downloading the GHC source and having a poke about
06:54:11 <EvilTerran> (i'm procrastinating :D)
06:54:47 * byorgey encourages EvilTerran to go for it
06:55:04 <byorgey> nothing like some good old-fashioned productive procrastination
06:55:13 * yitz used to do that, but now just pokes around with it online
06:56:15 <EvilTerran> i was idly thinking of having a go at some of the proposed extensions in the haskell' trac
06:56:29 * vincenz thinks more people should PEEK before POKEng
06:56:48 <EvilTerran> lamda-match looks relatively straightforward, and i want to use it myself
06:57:04 <vincenz> EvilTerran: lambda-match?
06:57:48 <EvilTerran> (|PAT -> EXP) desugaring to (case of PAT -> return EXP; _ -> mzero). or thereabouts.
06:58:02 <EvilTerran> (using one extension to describe another here :D)
06:58:28 <EvilTerran> ?where lambda-match
06:58:28 <lambdabot> I know nothing about lambda-match.
06:58:31 <EvilTerran> ?where lambdamatch
06:58:31 <lambdabot> I know nothing about lambdamatch.
06:58:32 <EvilTerran> hm
06:59:09 <vincenz> EvilTerran: oh, monadic lambdas
06:59:31 <EvilTerran> yeah, i guess
07:00:46 <EvilTerran> ?where+ lambda-match http://hackage.haskell.org/trac/haskell-prime/ticket/114
07:00:47 <lambdabot> It is forever etched in my memory.
07:00:50 <georgw> ghc knapsack4.hs -o knapsack4
07:00:50 <georgw> compilation IS NOT required
07:00:50 <georgw> knapsack4.o(.text+0x2ad): In function `rPa_info':
07:00:50 <georgw> : undefined reference to `containerszm0zi1zi0zi1_DataziSequence_zdf35_closure'
07:00:50 <georgw> knapsack4.o(.text+0x5ab): In function `sR2_info':
07:00:51 <georgw> : undefined reference to `containerszm0zi1zi0zi1_DataziSequence_adjust_closure'
07:00:57 <georgw> Anyone have a hint?
07:01:05 <EvilTerran> or at least until you next crash without being flushed, eh, lambdabot? :P
07:01:16 <taruti> georgw: add -package containers ?
07:01:25 <doserj> or --make
07:01:35 <quicksilver> EvilTerran: if you're playing with such things, I would love to have case | GUARD
07:01:44 <quicksilver> EvilTerran: (as short hand for the ugly case () of () | GUARD)
07:01:55 <georgw> doserj: That did it. :-)
07:02:09 <EvilTerran> hm. there seems to already be a patch for lambda-match
07:02:15 <georgw> doserj: Can you tell me what was wrong before...
07:02:25 <quicksilver> georgw: "always use --make"
07:02:26 <Cheery> @where Data
07:02:26 <lambdabot> I know nothing about data.
07:02:29 <EvilTerran> might need brought up-to-date for ghc 6.8, tho
07:02:31 <quicksilver> georgw: is the simplest rule to remember.
07:02:38 <EvilTerran> @index Data
07:02:38 <lambdabot> Data.Generics.Basics, Data.Generics
07:02:39 <georgw> quicksilver: hehe, ok.
07:02:53 <EvilTerran> quicksilver, hm. i'll put it on my to-do list :P
07:02:54 <quicksilver> georgw: --make tells it to do the package search and work out your dependencies automatically
07:03:14 <quicksilver> EvilTerran: I only suggest it because it strikes as trivial, and perhaps a good start if you going to get into GHC hacking.
07:03:25 <georgw> So "import ..." in the source code is not enough, ghc needs additional hints for linking?
07:03:36 <quicksilver> correct.
07:03:44 <quicksilver> well
07:03:53 <quicksilver> in a sense, "import ..." *is* enough
07:04:00 <quicksilver> and --make is that flag which tells it to honour it :)
07:04:18 <doserj> ghc is a bit stupid in that regard...
07:04:19 <quicksilver> perhaps --make should be default. Certainly some people think so.
07:05:15 <Vq^> i think the flag is a good idea
07:05:23 <mauke> it's to make former C programmers feel more comfortable
07:05:28 <Vq^> i like that the default isn't to follow dependencies
07:06:02 <Heffalump> I think the main reason for that is historic.
07:06:10 <georgw> alright, fair enough.
07:06:11 <Vq^> ah, now im little more than a scared C code-monkey :o)
07:06:42 <shepheb> a
07:10:16 <sieni> Vq^: scared and beaten?
07:10:32 <tromp> you can be a software simian:)
07:12:32 <Cheery> what would be a good name for comonad that reads and writes bytes into bytestring?
07:13:44 <Vq^> sieni: the usual scare of change probably; thought i mostly use the --make flag when invoking ghc
07:14:11 <Cheery> I thought about calling it stuffer and ripper
07:15:49 <Cheery> extract (stuff lolcatByteString » stuffing warrocket)
07:16:14 <Cheery> extract (rip lolcat » ripping warrocket)
07:16:44 <Cheery> or actually.
07:17:02 <Cheery> extract (stuffing lolcat » stuff lolcats
07:20:44 <georgw> Hmm... as discussed with Cale yesterday, I have a big efficiency problem with a recursive Knapsack implementation. Profiling indicates that much of the time is spent in my random number generator function. I cleaned up the code and switched to a purely recursive implementation, and the problem is still the same, the program consumes heaps of memory if I increase the iterations. Are there some tricks on how to implement recursion efficiently?
07:21:34 <Cheery> or
07:22:23 <Cheery> extract (media n » stuff lolcat)
07:22:23 <Vq^> georgw: tail-recursion usually is the key to flatten the memory-use for recursive algorithms
07:22:33 <Cheery> extract (media n » rip lolcat)
07:23:06 <Vq^> georgw: sometimes that means to have an accumulating argument to the function rather than returning an intermediate/part-value
07:24:07 <vincenz> georgw: hard to talk without code
07:24:19 <ivan_> @unmtl StateT s (ErrorT m) a
07:24:19 <lambdabot> err: `ErrorT m (a, s)' is not applied to enough arguments.
07:24:19 <vincenz> georgw: sounds to me like you need strictness
07:25:00 <ivan_> @unmtl StateT s (ErrorT m Maybe) a
07:25:00 <lambdabot> s -> Maybe (Either m (a, s))
07:25:07 <hpaste>  georgw pasted "knapsack4" at http://hpaste.org/6329
07:25:42 <georgw> It's rather short. coreIterator and bestOfMany are the recursive functions.
07:25:56 <ivan_> @unmtl StateT s (Error m) a
07:25:56 <lambdabot> s -> Error m (a, s)
07:26:33 <vincenz> georgw: @paste
07:26:45 <vincenz> oh
07:26:47 <glen_quagmire> mtl means monad transformation library?
07:26:49 * vincenz missed that line
07:27:22 <georgw> Cale mentioned strictness last time and that I could enforce strictness with ! somehow.
07:27:38 <vincenz> georgw: have a testsample?
07:27:59 <Vq^> glen_quagmire: it usually refers to a specific library, but yes
07:28:02 <georgw> vincenz: http://www.tik.ee.ethz.ch/sop/education/lectures/BOD/exercises/project1/instances/project1_task2b.dat
07:28:04 <lambdabot> http://tinyurl.com/2xm4tu
07:28:18 <georgw> A knapsack with 100 items.
07:28:55 <glen_quagmire> Vq^: thank you
07:30:03 <georgw> Hmm... maybe I should look at CPS?
07:30:38 <Vq^> georgw: im not completely sure but this might be relevant: http://www.haskell.org/haskellwiki/Performance/Accumulating_parameter
07:30:39 <lambdabot> Title: Performance/Accumulating parameter - HaskellWiki, http://tinyurl.com/2599r3
07:31:17 <vincenz> georgw: woo
07:31:23 <vincenz> georgw: improved performance by factor 10
07:31:32 <vincenz> and no more stack-blow
07:31:56 <georgw> vincenz: oooohhh, so nice. What id you change exactly?
07:32:41 <hpaste>  vincenz annotated "knapsack4" with "Make sure to compile with -fbang-patterns" at http://hpaste.org/6329#a1
07:33:05 <vincenz> This was off the top of my head
07:33:08 <vincenz> haven't looked at your code in depth
07:35:26 <Vq^> georgw: small comment, most Haskell-programmers write var' instead of newvar
07:35:38 * vincenz nods
07:35:56 <vincenz> additionally, you're constantly passing round the same information
07:36:11 <vincenz> why not put bestOffMany inside of coreIterator
07:36:23 <vincenz> or even better, remove coreIterator all-together
07:36:25 <vincenz> altogether
07:36:44 <vincenz> Mind if I rewrite some?
07:36:54 <georgw> Vq^: thanks for the hint!
07:37:42 <georgw> vincenz: Compiled the code, and works much better. I owe you a beer! Thanks a lot. And of course, I'd be very happy for edits to the code. It's a good opportunity to learn.
07:37:50 <Vq^> one solution to avoid passing around all those constant arguments might be to declare those functions in a where block to a function that takes those constant arguments
07:38:26 <vincenz> yeah
07:38:32 <vincenz> Vq^: there's some other better ideas
07:38:41 <glen_quagmire> what's foldl'  is it standard?
07:38:44 <georgw> Ah, sorry, bad timing... have a meeting right now. Will be back in about half an hour and look at the stuff. Much thanks for your help!
07:38:48 <vincenz> glen_quagmire: yes
07:38:51 <Vq^> it's quite common in GUI-code for example (but it might be better to use some form of Reader)
07:39:12 <Vq^> glen_quagmire: it's located in Data.List
07:39:13 <glen_quagmire> oh i was looking for it in Prelude.
07:41:06 <glen_quagmire> @src length
07:41:06 <lambdabot> Source not found. It can only be attributed to human error.
07:42:47 <ivan_> Monads are used to represent features of computation. What "computation feature" is modelled by a list? can any 1 help me to answer this question, what do they mean?
07:43:06 <dolio> Nondeterminism.
07:43:39 <ivan_> and what does nondeterminism mean?
07:43:52 <Vq^> in a way, backtracking
07:44:32 <Vq^> but maybe thats attributed to MonadPlus... :/
07:44:49 <dolio> It means that there are places where the computation can arbitrarily follow one of many paths.
07:45:05 <dolio> So, for instance, 'do a <- [1,2,3] ; ...'
07:45:38 <dolio> This means, roughly, 'set a to either 1, 2 or 3 and continue'.
07:46:04 <dolio> And, at the end, the list monad returns all successful branches of the computation.
07:46:56 <Vq^> dolio: but is "successful" there attributed to the monad?
07:47:51 <dolio> Well, roughly, "successful" means a path that ends in "return a" for some a.
07:48:17 <ivan_> dolio: thats cool =) didn't know that u could do this with list
07:48:25 <dolio> And failure involves mzero along the way somewhere.
07:48:30 <Vq^> cartesian product might be a better answer
07:49:37 <Vq^> ivan_: the list-monad is quite a neat thing actually :)
07:50:11 <dolio> Yeah. The neat thing is that due to lazy evaluation, you get a backtracking search of the solution space, as Vq^ said.
07:50:42 <dolio> So if you do 'head (some-list-computation)' it does depth first search to find the first answer, and then quits.
07:52:53 <dolio> Strictly speaking, there is more than one implementation of a nondeterminism monad (and MonadPlus captures the essentials), but list is one.
07:59:59 <dcoutts_> DukeDave: when we were calculating data structure overheads I was thinking that it's annoying having an extra word for each heap allocated object, turns out the standard JVM uses two words and extra padding for alignment
08:01:01 <dcoutts_> so a heap allocated Java Integer take 4 words or something like that
08:01:13 <dcoutts_> where GHC gets away with just 2 words
08:01:46 <hpaste>  vincenz annotated "knapsack4" with "Slightly slower but more haskelly" at http://hpaste.org/6329#a2
08:01:54 <Baughn> dcoutts_: What's the extra word for? Type tag?
08:01:54 <tromp> individual Ints dont matter much
08:02:05 <Baughn> Seems odd, given that ghc knows the type statically
08:02:19 <tromp> as long as containers of Ints are memory efficient
08:02:38 <dcoutts_> Baughn: "In Hotspot, a typical mature JVM, an object header is two words, a mark and a klass. The mark is used for bookkeeping of operations like synchronization and identity hash code. The klass is a full machine pointer, to a metadata object which describes the object’s layout, methods, and other type information."
08:03:02 <dcoutts_> Baughn: oh the header word is not for runtime types but to tell the GC about the structure of the heap object
08:03:11 <dcoutts_> in GHC that is
08:03:59 <Baughn> Okay. Is that just to make things easier, or is there some deep reason the GC can't look up the static type information?
08:04:12 <dcoutts_> Baughn: GHC knows the type statically but that doesn't help with telling the GC what the heap object looks like, especially as the heap object can be different for values of the same type
08:04:22 <dcoutts_> consider different constructors Left | Right
08:04:30 <dcoutts_> or unevaluated thunk vs evaluated data
08:04:58 <Baughn> Oh, thunks. Of course.
08:05:17 <dcoutts_> and the GC does need to know because it has to look inside the object for pointers to other objects when tracing
08:05:34 <skorpan> what is "do" notation syntactic sugar for?
08:05:44 <Cin> >>= and >>
08:06:25 <skorpan> is this why you can't use <- in >>= declarations?
08:06:34 <Cin> do line <- getLine; putStrLn line; is equivilant to getLine >>= \line -> putStrLn line -- or getLine >>= putStrLn
08:06:46 <Cin> skorpan: well, you need `do' in order to use <-
08:07:46 <glen_quagmire> I take a list l and a constant a. I want to produce a list result such that result[i] == a*l[i] + (1-a)*result[i-1] for i > 0
08:08:30 <hallongrottan> does anyone have a suggestion on how to write your own show-instance?
08:08:47 <skorpan> hallongrottan: instance Show Mytype where
08:09:04 <EvilTerran> > zipWith (+) <*> reverse . zipWith (*) [1..
08:09:04 <lambdabot>  Parse error at end of input
08:09:09 <tromp> @show scanl
08:09:09 <lambdabot> "scanl"
08:09:10 <hallongrottan> skorpan: orly, i wish it was that simple
08:09:17 <skorpan> hallongrottan: what's the problem?
08:09:20 <tromp> @hoogle scanl
08:09:20 <lambdabot> Prelude.scanl :: (a -> b -> a) -> a -> [b] -> [a]
08:09:20 <lambdabot> Data.List.scanl :: (a -> b -> a) -> a -> [b] -> [a]
08:09:20 <lambdabot> Data.ByteString.scanl :: (Word8 -> Word8 -> Word8) -> Word8 -> ByteString -> ByteString
08:09:20 <EvilTerran> > zipWith (+) <*> reverse . zipWith (*) [1..] $ [u,v,w,x,y,z]
08:09:23 <lambdabot>  [u + 6 * z,v + 5 * y,w + 4 * x,x + 3 * w,y + 2 * v,z + 1 * u]
08:09:36 <EvilTerran> > (zipWith (+) <*> reverse) . zipWith (*) [1..] $ [u,v,w,x,y,z] -- ups
08:09:37 <lambdabot>  [1 * u + 6 * z,2 * v + 5 * y,3 * w + 4 * x,4 * x + 3 * w,5 * y + 2 * v,6 * z...
08:09:48 <hallongrottan> skorpan: we're trying to write a show-instance for Trace in lab2
08:09:55 <hallongrottan> but it does not work very well :/
08:09:55 <EvilTerran> glen_quagmire, owzat?
08:10:04 <skorpan> hallongrottan: what is your show function?
08:10:19 <tromp> scanl (\x y-> 0.2*x + 0.8*y) 0 [1..10]
08:10:26 <tromp> > scanl (\x y-> 0.2*x + 0.8*y) 0 [1..10]
08:10:27 <lambdabot>  [0.0,0.8,1.76,2.7520000000000002,3.7504000000000004,4.7500800000000005,5.750...
08:10:31 <hallongrottan> skorpan: what do you mean?
08:10:31 <EvilTerran> hallongrottan, what's your datatype?
08:10:43 <skorpan> hallongrottan: you have to declare the show function for Trace
08:10:47 <hallongrottan> EvilTerran: type Trace a = [Item a]
08:11:08 <EvilTerran> err. you can't write instances for "type"s, only "data"s and "newtype"s
08:11:15 <hallongrottan> ah
08:11:25 <tibbe> the quality of reddit comments is really decreasing
08:11:34 <EvilTerran> because an instance for (Trace a) would overlap the instance for [a]
08:11:36 <Cin> tibbe: almost to the point of slashdot
08:11:44 <tibbe> it's terrible
08:12:00 <tibbe> lots of "I did/didn't like the article" etc
08:12:04 <glen_quagmire> EvilTerran: i was trying to implement this in haskell and see how it compares:  http://jfkbits.blogspot.com/2008/03/rc-filter-with-ocaml.html
08:12:09 <lambdabot> Title: JFKBits: RC Filter with OCaml
08:12:09 <tibbe> hint: use the up/down vote
08:12:25 <EvilTerran> hallongrottan, if there's no Show instance for Item, you could probably get away with it with the OverlappingInstances language extension
08:12:28 <Cin> tibbe: i personally don't read the comments. i find some articles interesting, but people's opinions of them not
08:12:45 <tibbe> right, same here except for when I'm bored
08:13:08 <tibbe> but people like Cale, etc sometimes drop gems that I don't want to miss but I've added them on my friends list to track them
08:14:05 <roel_> I think the reddit comments will eventually reach some asymptotic line at which point they can't sink any lower
08:14:12 <EvilTerran> hallongrottan, bearing in mind that the specification for Show is that it should produce valid haskell code that would evaluate to the original expression, is Show even really what you want?
08:14:24 <roel_> We could call it the youtube threshold
08:14:38 <hallongrottan> EvilTerran: no, we dont :P nvm that
08:14:41 * Cin likes how reddit's submit page has the url "/submit" but the title "post" .oO(pick one, guys?)
08:14:55 <EvilTerran> hallongrottan, it might be better to just write a showTrace function that does what you want
08:20:41 <hallongrottan> EvilTerran: yeah. perhaps it is
08:31:34 <Toxaris> EvilTerran: are you sure about "the specification for Show"? I think that derived Show behaves this way, but your own Show instances may do what they want.
08:32:21 <glen_quagmire> f x0 y ==> f x1 (f x0 y) ==> f x2 (f x1 (f x0 y)) ==> ...    is this continuation passing style?
08:32:54 <titusg> how can a list of integers be represented as a single integer?
08:33:16 <glen_quagmire> length xs ?
08:33:20 <Toxaris> interesting side note: the behaviour of derived Show instances is given in terms of "is an element of a list", without specifying what that means. see -cafe thread about Eq to see why this may be a problem for crazy-minded people.
08:33:30 <glen_quagmire> titusg: do they have to be one-to-one?
08:33:35 <Toxaris> titusg: goedel numbering?
08:33:40 <titusg> This is mentioned in oleg's Implicit Paramter's pearl, but not explained
08:33:53 <titusg> Toxaris: come again?
08:34:14 <Toxaris> titusg: it's the name for "represent arbitrary data as a single integer"
08:34:26 <doserj> \ xs -> sum $ zipWith (^) primes xs
08:34:37 <doserj> \ xs -> product $ zipWith (^) primes xs -- sorry
08:35:44 <doserj> that at least deals with natural numbers.
08:35:45 * EvilTerran was just about to give doserj's second version there, albeit pointlessly
08:36:00 <EvilTerran> (product . zipWith (^) primes)
08:36:03 <glen_quagmire> > product $ zipWith (^) [2,3,5,7] [100,526,742,432]
08:36:04 <lambdabot>  6121756519590579436037193966551477018184148689286877743270123897514684610934...
08:36:11 <EvilTerran> cor blimey
08:36:15 <hpaste>  wfarr pasted "config" at http://hpaste.org/6330
08:36:17 <Toxaris> titusg: there are various methods, both datatype specific (like doserj's primes method) and general (e.g. encoding of arbitrary algebraic data types)
08:36:41 <tromp> > primes
08:36:42 <lambdabot>   Not in scope: `primes'
08:36:50 <Toxaris> titusg: but it is never used, of course, it's just a proof tool. it's sometimes easier to work with a single number instead of arbitrary data.
08:37:18 <titusg> doserj: thanks. The closest I got to this was reading "godel, escher, bach" some time ago and not really getting it...
08:37:45 <glen_quagmire> > product $ zipWith (^) [2,3,5,7] [0,0,0,0]
08:37:45 <lambdabot>  1
08:37:57 <Baughn> titusg: On the other hand, once you've serialized data inrto a bytestring (or whatever), it's very easy to convince yourself that the bytestring is a single integer
08:38:10 <titusg> Toxaris: yes, the paper says "a list of ints can be represented as one (huge) integer but supporting lists directly is more convenient..."
08:38:20 <glen_quagmire> man it's impossible to have two lists to come up with the same godel number
08:38:45 <tromp> you can represent any lambda term with a bitstring
08:39:08 <doserj> you can represent anything with a bitstring
08:39:10 <tromp> as shown in my paper
08:39:13 <glen_quagmire> the product of powers of prime method can be invertable right?
08:39:37 <Toxaris> glen_quagmire: sure. prime factor decomposition isn't fast, but easy.
08:39:41 <Baughn> glen_quagmire: Yes, but there are invertable methods that produce significantly less astronomical numbers. ;)
08:40:17 <tromp> my method produces the shortest bistrings (up to a constant)
08:40:28 <Toxaris> all these methods are invertable. you just enumerate all possible results, compute their godel number, and stop when you reached the number you search for.
08:40:44 <glen_quagmire> tromp: can i see your paper (/me collects papers but never reads them)
08:41:01 <Baughn> tromp: I'll stick with plain old binary serialization, I think
08:41:14 <tromp> http://homepages.cwi.nl/~tromp/cl/LC.pdf
08:41:53 <glen_quagmire> thank you
08:41:55 <tromp> also see http://homepages.cwi.nl/~tromp/cl/cl.html
08:41:55 <lambdabot> Title: John's Combinatory Logic Playground
08:42:44 <guenni> Hi, is there a way to define the Lisp/Scheme functions cons, car and cdr in Haskell without using and data declarations?
08:43:18 <glen_quagmire> guenni: car == head   cdr == tail ?
08:43:18 <glen_quagmire> > head [1,2,3]
08:43:18 <tromp> sure
08:43:19 <lambdabot>  1
08:43:23 <tromp> let cons = \x y z -> z x y
08:43:56 <tromp> let cdr = \x -> x (\x y -> x)
08:44:13 <tromp> let car = \x -> x (\x y -> y)
08:44:23 <tromp> hmm, maybe i got car and cdr reversed:)
08:44:24 <guenni> cooooool!
08:44:39 <guenni> tromp: thank you very much!!!!
08:44:56 <glen_quagmire> > (\x y z -> z x y) 1 [1,2,3]  :: Expr
08:44:56 <lambdabot>      The lambda expression `\ x y z -> z x y' has three arguments,
08:44:57 <lambdabot>     but it...
08:45:34 <tromp> you can't mix those defs with haskell lists
08:45:37 <georgw> vincenz: Thanks for the edits! I like the haskelliness. :-) Takes a while to get used to writing in that way, but looks way more beautiful.
08:47:12 <vincenz> georgw: most welcome :)
08:47:51 <vincenz> georgw: notice how I pacck up the data that changes
08:47:55 <vincenz> so you only have one changing item
08:48:09 <vincenz> + you don't need to unpack and repack tuples, which can be expensive
08:49:25 <vincenz> georgw: btw, I take it tht flipSome does not care about psitions?
08:50:43 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/6332
08:50:49 <georgw> vincenz: Yeah, I noticed that. Also very interesting way of simulating loops, haven't seen that before. What do you mean "does not care"?
08:51:26 <vincenz> georgw: well you're passing in randoms, right?
08:51:38 <vincenz> so why not use foldl'?
08:52:48 <georgw> vincenz: see the comment below that definition. Seemed to fit better with the order of the variables.
08:52:55 * vincenz nods
08:53:15 <georgw> vincenz: Is there a difference between foldl and foldr in performance?
08:53:19 <vincenz> doh
08:53:41 <EvilTerran> doh!
08:53:55 <georgw> ?!
08:53:55 <lambdabot> Maybe you meant: . ? @ v
08:54:03 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/6333
08:54:06 <vincenz> georgw: seems my code introduces a bug in yours
08:54:17 <vincenz> georgw: it always uses the same distance
08:54:35 <EvilTerran> in general, foldr performs better
08:54:46 <EvilTerran> as foldl results in a big unevaluated thunk
08:54:50 <vincenz> lemme fix
08:54:57 <vincenz> EvilTerran: foldl'
08:55:02 <EvilTerran> i know
08:55:02 <georgw> vincenz: Ahh, yep, see it. Should have distance within the variable part.
08:55:09 <vincenz> georgw: yeah
08:55:10 <byorgey> IMO saying foldr 'performs better' than foldl is misleading.
08:55:10 <EvilTerran> he didn't ask about foldl' :P
08:55:14 <vincenz> georgw: but let me get this
08:55:14 <byorgey> it's sort of the wrong question
08:55:19 <byorgey> they are different things.
08:55:19 <vincenz> georgw: bestOfMany tries all distances?
08:55:29 <vincenz> georgw: and returns the best one?
08:55:32 <EvilTerran> byorgey, i agree, but i was trying to answer the question as it was asked. :P
08:55:44 <georgw> vincenz: Yes, exactly. And always from the same pivot.
08:55:59 <vincenz> georgw: aha
08:56:02 <vincenz> georgw: I can do better then
08:56:06 <byorgey> EvilTerran: well, then we have different pedagogical approaches, I suppose =)
08:56:21 <vincenz> :t maxBy
08:56:23 <lambdabot> Not in scope: `maxBy'
08:56:33 <EvilTerran> i'm feeling ambivalent today. usually i'd be more thorough. ;)
08:56:36 <vincenz> :t maximumBy
08:56:37 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
08:57:02 <byorgey> georgw: check out http://haskell.org/haskellwiki/Stack_overflow for more information on the difference between foldl', foldl, and foldr.
08:57:05 <lambdabot> Title: Stack overflow - HaskellWiki
08:57:08 <byorgey> @where folds
08:57:08 <lambdabot> http://cale.yi.org/index.php/Fold_Diagrams
08:57:12 <byorgey> also those diagrams =)
08:57:49 <vincenz> bleh
08:58:29 <vincenz> georgw: yeah, then bestOfMany is slightly off in latest version
08:59:11 <georgw> byorgey: thanks for the links. I think I get the problem, will have to let the information sink in a bit. =)
08:59:26 <byorgey> georgw: cool, no problem =)
08:59:54 <georgw> vincenz: So would you use an Order over Seq Bool or something alike then?
09:00:23 <georgw> byorgey: It's those kinda things that separate a recovering Haskell newbie to someone who can write useful programs. ;-)
09:00:54 <byorgey> georgw: well, there's no real separation, it's more of a continuum =)
09:02:31 <RayNbow> http://www.lkozma.net/wpv/ ++ http://reddit.com/r/programming/info/6bwra/comments/
09:02:31 <lambdabot> Title: WikipediaVision (beta)
09:02:32 <georgw> byorgey: With stack overflows presenting somewhat more of a hurdle than matters of style. ;-)
09:03:01 <dcoutts_> mnislaih: btw, how's the cabal config stuff going?
09:03:20 <mnislaih> hiya dcoutts_ : almost finished
09:03:26 <dcoutts_> mnislaih: oh cool
09:03:48 <mnislaih> I could push a patch tomorrow probably
09:04:13 <dcoutts_> mnislaih: that's great, we're getting pretty near to being able to do a 1.4 release :-)
09:04:33 <mnislaih> I'm all in for breaking Cabal 1.4 :)
09:04:40 <dcoutts_> mnislaih: if you want and review feedback you can send whatever you've already got
09:04:43 <dcoutts_> mnislaih: hah hah
09:04:56 <mnislaih> after that patch, another one for cabal-install will follow
09:04:56 <dcoutts_> our test case is all of Hackage :-)
09:05:00 <dcoutts_> mnislaih: ok
09:05:34 <dcoutts_> our aim for 1.4 is that every package that built with 1.2 should build with 1.4
09:06:04 <dcoutts_> and that we should not introduce new syntax that 1.4 accepts that breaks 1.2
09:06:16 <mnislaih> that's a great testcase, although not for my patch, really, as hpc would probably reveal
09:06:29 <mnislaih> I'll see if I can  quickly set up HTTP access to my Cabal darcs repo so that you can look at it
09:06:46 <dcoutts_> mnislaih: or darcs send your existing patches to the list
09:07:19 <dcoutts_> mnislaih: what goes wrong with hpc?
09:07:54 <dcoutts_> oh, I see, you mean hpc would tell us that the new code does not get good coverage with hackage as the test case
09:08:03 <mnislaih> oh, nothing. I mean the stuff in the ticket I'm working is for command-line flag handling, and that will not get tested by building hackage projects
09:08:09 <dcoutts_> right
09:08:23 <mnislaih> (which worries me slightly)
09:08:43 <Mr_Awesome> i dont know why foldl even exists
09:09:08 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/6335
09:09:52 <georgw> vincenz: To fix the distance thing, I would have to remove the loop and use recursion with (distance-1) again, right? Or would I reintroduce some ugly almost-tail-recursiveness then?
09:11:04 <Saizan> is there no portable function to get the size of a file?
09:11:48 <dcoutts_> @hoogle filesize
09:11:48 <lambdabot> System.IO.hFileSize :: Handle -> IO Integer
09:11:48 <lambdabot> System.IO.hSetFileSize :: Handle -> Integer -> IO ()
09:12:36 <dcoutts_> Saizan: so you have to open the file first to use that
09:13:03 <vincenz> georgw: yep
09:13:08 <vincenz> georgw: but coreIterator can remain as is
09:13:51 <vincenz> georgw: the code has some deeper unhaskell-issues
09:13:56 <vincenz> georgw: but I can't get into it more now :|
09:14:18 <georgw> vincenz: What's unhaskellish?
09:14:25 <Saizan> dcoutts_: thanks
09:14:25 <georgw> vincenz: Any pointers?
09:14:33 <vincenz> georgw: Well I wouldn't loop on the distance
09:14:37 <vincenz> georgw: I'd map over [1..distance
09:14:41 <vincenz> georgw: and then compare at the end
09:14:48 <vincenz> maximumBy
09:15:01 <georgw> vincenz: Oh, I see.
09:15:05 <vincenz> in general I tend to turn loops into lists
09:15:14 <vincenz> when working in haskell that is
09:15:24 <georgw> vincenz: Ah, that makes sense. I might rewrite that then.
09:15:33 <vincenz> but it's a bit trickier
09:15:38 <vincenz> due to the randomlist which is being traced along :|
09:16:01 <georgw> vincenz: Yeah, the random stuff has given me headaches, it's mildly annoying.
09:16:13 <vincenz> sounds like State to me :)
09:16:34 <georgw> vincenz: Yeah, that i haven't looked into yet. Would that be useful here?
09:16:48 <vincenz> I'd make the core functionality of bestXXX a State thing
09:16:54 <vincenz> then I'd map over [1..distance]
09:17:05 <vincenz> that should get you [m a]
09:17:07 <vincenz> where m = State
09:17:14 <vincenz> then you do 'sequence' to get m [a]
09:17:25 <vincenz> and then do a maximumBy knapValue
09:17:37 <vincenz> where 'a' == Seq Int
09:18:25 <georgw> vincenz: Sounds cool. I'll do some reading and try that. :-)
09:18:46 <vincenz> It probably won't give you the utmost fastest solution, but definitely more Haskelly
09:19:12 <vincenz> Once you have that, tell me, cuse State has some strictness issues
09:19:25 <georgw> vincenz: Maybe you can give me one more hint: I not only have to return the best value but also the time-series of the best value. I'm afraid I might break tail-recursiveness when I add that...
09:19:38 <Saizan> > '\0' == '\NUL'
09:19:38 <lambdabot>  True
09:19:52 <vincenz> georgw: well that's the point, only return 'Seq Int'
09:19:57 <vincenz> georgw: and do a maximumBy knapValue
09:20:07 <vincenz> maximumBy (compare `on` knapValue)
09:20:42 <georgw> vincenz: But that's only over distance, not over the iterations...
09:21:03 <georgw> vincenz: Hmm.. or I might be confused...
09:22:07 <vincenz> georgw: ok, then don't do maximumBy
09:22:12 <vincenz> georgw: have it return [m a]
09:22:21 <vincenz> then replicate counter (thatlist)
09:22:45 <vincenz> and only then sequence and maximumBy
09:23:41 <vincenz> obviousy flattening after replication
09:23:43 <vincenz> :t join
09:23:44 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
09:24:11 <georgw> vincenz: I think I'm lost at this point. But that's ok, I'll do some reading and then look at your suggestion. I haven't looked at monads enough yet.
09:24:31 <vincenz> maximumBy (compare `on` knapValue). join . replicate counter $ map (worker parameters) [1..distance
09:24:36 <vincenz> that should be the core
09:24:41 <vincenz> worker parameters should just generate stuff
09:25:05 <vincenz> might as well write it now :)
09:25:17 <georgw> vincenz: oic. Nice. Thanks! :-) I'll try. =)
09:26:14 <vincenz> georgw: 4194 with 60 elements.
09:26:18 <vincenz> georgw: that is the corret answer?
09:26:25 <vincenz> just as test-case, so I don't muck anything up gain
09:26:32 <georgw> vincenz: 4314 with 62 elements.
09:26:41 <georgw> vincenz: May still be the distance thing?
09:27:16 <vincenz> ok
09:27:20 <vincenz> yeah, still had the distance thing
09:27:26 <dcoutts_> does anyone have an opinion on cabal and striping executables? Should it do it by default upon install or not? What should the command line flag be? --strip=yes/no --strip --no-strip ?
09:28:17 <dcoutts_> for most on/off configure flags we use --enable-foo --disable-foo
09:28:24 <georgw> vincenz: Then local exploitation is not efficient, and it won't find the best in the given iterations I guess.
09:30:31 <vincenz> georgw: imme a bit
09:30:40 <georgw> vincenz: =)
09:34:26 <vincenz> georgw: ok, correct version now
09:34:28 <vincenz> time to get cracking ;)
09:35:11 <byorgey> dcoutts_: you mean stripping?
09:35:21 <dcoutts_> erm, yes
09:35:33 <dcoutts_> p/pp
09:35:39 <byorgey> dcoutts_: aha!  I was always confused about what striping executables meant
09:35:43 <Saizan> keeping it consistent with the other flags seems good
09:35:58 <byorgey> made me think of RAID and so forth...
09:36:04 <byorgey> =)
09:36:11 <dcoutts_> so the point is, it only happens to executables atm and only at install time
09:36:26 <dcoutts_> and we need to be able to turn it off, if we decide the default should be on
09:36:41 <dcoutts_> because some distros prefer to do it themselves
09:37:28 <dcoutts_> so we could have a really long winded name like we do for --enable-executable-profiling
09:37:39 <dcoutts_> --disable-executable-stripping
09:37:45 <georgw> vincenz: Did you get it to work?
09:37:53 <vincenz> georgw: nearly :)
09:37:58 <vincenz> georgw: I hae the correct result, yes
09:38:05 <vincenz> time to refactor
09:38:08 <dcoutts_> in theory we could do it differently for libs than exes, at the moment we'll not do libs at all
09:38:23 <georgw> vincenz: Ahh. =)
09:40:11 <hallongrottan> skorpan: our monad AND Cgi-stuff works now =)
09:40:28 <hallongrottan> just the example left
09:40:35 <skorpan> great
09:40:53 <hallongrottan> yeah
09:41:01 <hallongrottan> were your example any funny?
09:41:41 <vincenz> georgw: does the order of how we genreate mater?
09:41:46 <vincenz> georgw: I guess not since randomness is purely random?
09:42:01 <vincenz> georgw: so [1..distance] == [distance,distance-1, .. 1] ?
09:42:02 <georgw> vincenz: order does not matter at all.
09:42:11 <vincenz> great
09:43:03 <skorpan> hallongrottan: nope
09:45:54 <gnuvince> Is there a way to time a function call in Haskell?
09:46:51 <vincenz> :t maximumBy
09:46:52 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
09:46:54 <vincenz> :t on
09:46:55 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
09:46:57 <vincenz> @hoogle on
09:46:57 <lambdabot> Data.Function.on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
09:46:57 <lambdabot> Text.ParserCombinators.Parsec.Char.oneOf :: [Char] -> CharParser st Char
09:46:57 <lambdabot> Data.Function :: module
09:47:34 <vincenz> :t (&&&)
09:47:35 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
09:48:01 <gnuvince> :info on
09:49:23 <byorgey> gnuvince: in ghci you can do :set +s, and it will then time the evaluation of expressions
09:49:24 <hallongrottan> skorpan: haha ok, sweet
09:49:30 <byorgey> gnuvince: I don't know if that's enough for what you want
09:49:56 <gnuvince> byorgey: most likely, yes.
09:50:09 <gnuvince> byorgey: thank you.
09:51:04 <smg> mh, how can i get an Float to Int?
09:51:07 <smg> x :: Int ?
09:51:28 <doserj> > round 3.3
09:51:29 <lambdabot>  3
09:51:46 <vincenz> :t mapM
09:51:47 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
09:53:07 <smg> i see
09:53:55 <vincenz> @hoogle maximumBy
09:53:56 <lambdabot> Data.List.maximumBy :: (a -> a -> Ordering) -> [a] -> a
09:53:56 <lambdabot> Data.Foldable.maximumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a
09:54:27 <doserj> @hoogle (Integral b, RealFrac a) => a -> b
09:54:28 <lambdabot> Prelude.truncate :: (RealFrac a, Integral b) => a -> b
09:54:28 <lambdabot> Prelude.round :: (RealFrac a, Integral b) => a -> b
09:54:28 <lambdabot> Prelude.ceiling :: (RealFrac a, Integral b) => a -> b
09:54:58 <smg> dogbite: but that only rounds
09:55:13 <doserj> smg: see the hoogle results
09:55:56 <Toxaris> > maximum $ True : [False]
09:55:56 <lambdabot>  True
09:56:01 <Toxaris> > maximum $ True : cycle False
09:56:02 <lambdabot>  Couldn't match expected type `[Bool]' against inferred type `Bool'
09:56:08 <Toxaris> > maximum $ True : repeat False
09:56:12 * quicksilver sighs at the exception/error FUD on the the -cafe
09:56:13 <lambdabot> Terminated
09:56:26 <vincenz> georgw: odd
09:56:32 <vincenz> georgw: 10000 iterations with distance 10 gives value: 842 with 10 elements.
09:56:32 <RayNbow> quicksilver: -cafe?
09:56:33 <georgw> vincenz: no luck?
09:56:40 <quicksilver> RayNbow: haskell-cafe, it's a mailing list
09:56:42 <Toxaris> shouldn't max :: Bool -> Bool -> Bool and maximum be defined in a way that allows maximum $ True : cycle False == True ?
09:56:42 <vincenz> georgw: I'm guessing cause I go through randomstate differently
09:57:15 <georgw> vincenz: Hmm... kinda strange that it's exactly 10 elementns.
09:57:27 <georgw> vincenz: Could it be that the pivot isn't updated?
09:57:32 <RayNbow> @where cafe
09:57:32 <lambdabot> I know nothing about cafe.
09:57:37 <vincenz> georgw: pivot needs to update?
09:57:47 <quicksilver> Toxaris: maybe. But you'd need a separate class for that
09:58:05 <quicksilver> Toxaris: with constraints Bounded in addition to Ord
09:58:12 <RayNbow> quicksilver, this thread? http://www.nabble.com/Exception-handling-when-using-STUArray-td15911479.html
09:58:13 <quicksilver> Toxaris: separate function, I mean, not separate class.
09:58:13 <lambdabot> Title: Nabble - Haskell - Haskell-Cafe - Exception handling when using STUArray, http://tinyurl.com/33g5ws
09:58:16 <georgw> vincenz: Well... loosely speaking... we have a current best and call it pivot, search in the neighborhood of the pivot for the next best and then this is the pivot.
09:58:17 <quicksilver> RayNbow: yes.
09:58:21 <gnuvince> @src cycle
09:58:21 <lambdabot> cycle [] = undefined
09:58:21 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
09:58:23 <vincenz> georgw: oh!
09:58:25 <vincenz> georgw: ok
09:58:28 <vincenz> gimme a bt more ;)
09:58:36 <georgw> vincenz: :-)
09:59:13 <Toxaris> quicksilver: wouldn't max True _ = True; max False x = x be enough?
09:59:29 <quicksilver> Toxaris: that is a special case :P
09:59:37 <quicksilver> Toxaris: recall that max is defined over all of Ord.
09:59:40 <quicksilver> :t max
09:59:41 <lambdabot> forall a. (Ord a) => a -> a -> a
09:59:48 <doserj> @src Ord
09:59:48 <lambdabot> class  (Eq a) => Ord a  where
09:59:48 <lambdabot>     compare      :: a -> a -> Ordering
09:59:48 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
09:59:48 <lambdabot>     max, min         :: a -> a -> a
09:59:51 <stew> Hmm, say I have fac 0 m = 1   fac n m = fac (n-1) (m*n), how would I make the arguments strict?
09:59:58 <Toxaris> quicksilver: every max is a special case, isn't it?
10:00:03 <quicksilver> no
10:00:05 <doserj> quicksilver: you can redefine it
10:00:16 <quicksilver> max a b = if a < b then b else b
10:00:21 <quicksilver> doserj: true, I didn't know that.
10:00:35 <Toxaris> quicksilver: max is a class method
10:00:41 <quicksilver> doserj: but it would still be more elegant to do it generically over all Bounded types.
10:00:45 <quicksilver> right, I didn't realise that.
10:00:54 <Toxaris> @src Bounded
10:00:54 <lambdabot> class  Bounded a  where
10:00:54 <lambdabot>     minBound, maxBound :: a
10:01:04 <Toxaris> what about half-bounded types
10:01:07 <Toxaris> e.g. Nat
10:01:45 <vincenz> :t liftM
10:01:46 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
10:02:27 <Toxaris> @src maximum
10:02:27 <lambdabot> maximum [] = undefined
10:02:27 <lambdabot> maximum xs = foldl1 max xs
10:03:06 <Toxaris> does this foldl1 mean that maximum has to evaluate all of xs even with a lazy max?
10:03:15 <vincenz> 10000 iterations with distance 10 gives value: 3580 with 57 elements.
10:03:17 <byorgey> shteou: using -XBangPatterns, you can say fac !n !m = fac (n-1) (m*n)
10:03:34 <vincenz> georgw: ^^
10:03:40 <shteou> Aah okay, thanks byorgey.
10:04:04 <georgw> vincenz: Now I am curious. =)
10:04:22 <byorgey> shteou: or you could go the old-fashioned but less syntactically controversial way: fac n m = n `seq` m `seq` fac (n-1) (m*n)
10:05:05 <vincenz> georgw: that bad?
10:05:12 <shteou> Ah yes byorgey, that's what I was looking for
10:05:23 <shteou> Tyvm :)
10:05:26 <georgw> vincenz: What do you mean?
10:05:33 <vincenz> georgw: well it's not your answer
10:05:48 <vincenz> 10000 iterations with distance 10 gives value: 3406 with 53 elements.
10:05:52 <vincenz> If I do 1..distance
10:06:37 <georgw> vincenz: Order should not matter at all...
10:06:51 <vincenz> how come I get different values?
10:07:12 <georgw> vincenz: Since we compare to the pivot always, the maximum should be independent of order in terms of distance.
10:07:18 <georgw> vincenz: Can you hpaste the code?
10:07:22 <vincenz> sure
10:07:26 <vincenz> just a sec, trying with 50k
10:07:36 <Toxaris> > True > undefined
10:07:37 <lambdabot>  Undefined
10:08:02 <Toxaris> maybe max is fine, but > is too strict in a sense
10:08:20 <quicksilver> > max True undefined
10:08:20 <lambdabot>  Undefined
10:08:49 <quicksilver> > isn't too strict
10:08:49 <lambdabot>   Not in scope: `strict'
10:08:59 <quicksilver> you could argue for >= being too strict
10:09:01 <quicksilver> but > has to be
10:09:08 <Toxaris> oh I see
10:09:18 <Toxaris> > True >= undefined
10:09:19 <vincenz> @hoogle zipWith3
10:09:19 <lambdabot>  Undefined
10:09:19 <lambdabot> Prelude.zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
10:09:19 <lambdabot> Data.List.zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
10:09:26 <georgw> vincenz: Ahh, I use 100k to get the optimum.
10:09:35 <Toxaris> but max could be defined with >=
10:09:47 <georgw> vincenz: But after 10000 should be closer already, I guess.
10:09:52 <shteou> Hmmm... I want YHC to leave out calls to Prelude;Prelude.Int;Prelude.Num;*/- :(
10:10:00 <Toxaris> > undefined > False -- > is too strict, too
10:10:01 <lambdabot>  Undefined
10:10:14 <shteou> It must easily spend 70% of it's time in there.
10:10:14 <Toxaris> > False > undefined -- I mean this I think
10:10:15 <lambdabot>  Undefined
10:10:34 <vincenz> georgw: I find it surprising that results would be that deterministic
10:10:42 <vincenz> georgw: cleaining some more
10:11:37 <georgw> vincenz: surprising that we should always get the same maximum?
10:11:41 <mnislaih> dcoutts_: I have mixed feelings about the end result. The datatype for Options ended up becoming a little messy
10:11:49 <mnislaih> dcoutts_: take a look at http://ender4.dsic.upv.es/cgi-bin/darcsweb.cgi?r=Cabal;a=summary
10:11:51 <lambdabot> Title: darcs - Cabal
10:12:00 <vincenz> georgw: i mean on 10K
10:12:19 <vincenz> 10000 iterations with distance 10 gives value: 3738 with 60 elements.
10:12:51 <hpaste>  vincenz annotated "knapsack4" with "Much more haskelly (and I think correct this time :)" at http://hpaste.org/6329#a3
10:12:57 <fophillips> Can anyone suggest a graphics library (preferably not Gtk+ dependant) that would be suited for drawing graphs.
10:13:02 <vincenz> I got rid of itemlist
10:13:03 <fophillips> Of the node and arc variety.
10:13:13 <vincenz> georgw: I'm reasonably happy with this solution
10:13:37 <dcoutts_> mnislaih: heh, sorry about that optimisation option :-)
10:14:11 <dcoutts_> mnislaih: first I added the proper^H^H^HBritish spelling, then I added optional optimisation level, makes it fairly complex
10:14:12 <xerox> fophillips: this one is pretty nice http://dockerz.net/software/chart.html
10:14:12 <lambdabot> Title: A haskell chart library
10:14:33 <mnislaih> yeah, so much for "big design up-front". I ended up doing something completely different to what I wrote up in the ticket. The fault is in part due to options like that one
10:14:49 <fophillips> xerox: 17:13:03 < fophillips> Of the node and arc variety.
10:15:05 <dcoutts_> mnislaih: the OptDescr data type doesn't look too bad to me
10:15:19 <dcoutts_> mnislaih: what would you do if we didn't have complex options like that one?
10:15:25 <xerox> fophillips: something like SVG?
10:15:30 <fophillips> Possibly.
10:15:54 <dcoutts_> mnislaih: or to put it another way, how much would we need to simplify the option to get a simpler representation?
10:16:37 <xerox> fophillips: what about http://www.haskell.org/gtk2hs/docs/current/Graphics-Rendering-Cairo.html#v%3Aarc
10:16:39 <lambdabot> http://tinyurl.com/266njv
10:16:41 <mnislaih> That's a good question. You need that kind of expressivity after all, so there is no value in a simpler representation
10:16:43 <georgw> vincenz: Looking at it now. But it doesn't find the maximum of 4314 yet, right?
10:16:46 <quicksilver> fophillips: the best option is almost certainly cairo, which would go against your gtk prohibition.
10:17:03 <quicksilver> fophillips: failing that you could take a look at wx, but it's much less capable in that department.
10:17:13 <vincenz> georgw: no, but that could be due to randomness
10:17:17 <vincenz> georgw: and I get higher values
10:17:17 <fophillips> Gtk+ will have to do then.
10:17:17 <xerox> BTW it is not tied to GTK.
10:17:19 <fophillips> Thanks.
10:17:19 <Vq^> fophillips: does it have to be a library?
10:17:29 <dcoutts_> quicksilver, fophillips: technically, cairo does not depend on gtk+, gtk+ depends on cairo
10:17:29 <fophillips> Not necessarily.
10:17:35 <Vq^> fophillips: it wouldn't suffice to output plotting-information to something like gnuplot?
10:17:37 <mnislaih> In the end, options like that one ended up helping me to find the kind of representation we needed. Although probably there is a more elegant way to model it, I couldn't think of it
10:17:46 <dcoutts_> mnislaih: ok
10:17:53 <georgw> vincenz: Oh, ok. I'll have to check that out.
10:17:54 <fophillips> Vq^: Does gnuplot do that type of graph?
10:17:59 <Saizan> dcoutts_: i guess it's a bad thing to open all the files up front when implementing tar
10:18:09 <Saizan> dcoutts_: right?
10:18:12 <vincenz> georgw: easiest way, predefine a random string
10:18:21 <vincenz> georgw: and run both versions with the predefined randomness
10:18:22 <quicksilver> xerox, dcoutts_ : interesting. My mistake.
10:18:31 <quicksilver> fophillips: No. Graph Viz does, though.
10:18:31 <dcoutts_> mnislaih: and most of the different opt/reqArg '''' variants are for String/ReadS/ReadP ?
10:18:33 <vincenz> georgw: though I do go [1..distance]
10:18:40 <vincenz> georgw: not [distance,distance-1..1]
10:18:45 <mnislaih> dcoutts_: just don't pull yet, I have to ammend a few things
10:18:48 <dcoutts_> Saizan: perhaps, there might be a lot of them
10:19:00 <Vq^> fophillips: what kind of graph?
10:19:03 <dcoutts_> mnislaih: sure, np, send a patch to the list when you're ready
10:19:03 <mnislaih> dcoutts_: yep
10:19:18 <Vq^> fophillips: http://www.gnuplot.info/screenshots/index.html#demos
10:19:19 <lambdabot> Title: gnuplot screenshots
10:19:24 <tibbe> dcoutts_: I'm trying to write some RULES, would you be able to help?
10:19:28 <dcoutts_> mnislaih: so if we had fewer parsers we could do with fewer ''' variants
10:19:29 <mnislaih> dcoutts_: there is ReadE now too :)
10:19:31 <georgw> vincenz: I'll look at the code, maybe I find something. Seems to be too big a variation to be attributable to randomness...
10:19:32 <fophillips> Vq^: Nodes and arcs.
10:19:39 <fophillips> Vq^: AKA networks.
10:19:43 <dcoutts_> mnislaih: so I noticed :-) we really need a new One True Parser
10:19:46 <mnislaih> dcoutts_: exactly. Only that now we have one more parser kind, readE :)
10:19:51 <Vq^> fophillips: what about graphviz then??
10:19:56 <georgw> vincenz: Many thanks for the code, it's a great example to learn some new techniques. =)
10:20:01 <Vq^> fophillips: i use it together with Haskell all the time :)
10:20:08 <fophillips> Vq^: I'm looking into it now.
10:20:09 <fophillips> :)
10:20:11 <dcoutts_> tibbe: sorry, not now, I've got to disappear off to London
10:20:20 <tibbe> dcoutts_: alright :)
10:20:25 <tibbe> don't worry
10:20:30 <dcoutts_> mnislaih: thanks! :-)
10:20:31 <ndm> i want to prove that a term rewriting system terminates - anyone know of a program to check such things?
10:20:35 <tibbe> @seen JaffaCake
10:20:36 <lambdabot> JaffaCake is in #ghc and #haskell. I don't know when JaffaCake last spoke.
10:20:40 <dcoutts_> see you later tibbe
10:20:43 <tibbe> cya
10:20:44 <mnislaih> dcoutts_: np
10:20:46 * dcoutts_ disappears
10:21:34 <vincenz> georgw: welcome
10:21:42 <byorgey> @seen Cale
10:21:43 <lambdabot> Cale is in #ghc, #haskell-overflow and #haskell. I last heard Cale speak 9h 40m 8s ago.
10:21:48 <fophillips> Graphviz it is then.
10:21:49 <fophillips> Thanks.
10:21:52 <vincenz> dcoutts_: no you didn't, you're still here
10:21:54 <byorgey> is Cale writing a raytracer?
10:22:31 <glen_quagmire> instance Eq MyType where  a == b = True  ;  is this ok?
10:22:44 <vincenz> georgw: don't forget the false case
10:23:00 <quicksilver> glen_quagmire: it's not likely to be very meaningful.
10:23:13 <quicksilver> glen_quagmire: but there are no laws against it :P
10:23:16 <georgw> vincenz: What do you mean?
10:23:26 <glen_quagmire> newtype PrimFun = PrimFun ([Val] -> Evaluated Val);  instance Eq PrimFun where a == b = True
10:23:44 <vincenz> georgw: wrong person
10:23:51 <vincenz> glen_quagmire: don't forget the False-case
10:23:56 <vincenz> stoopid tab-complete
10:24:05 <byorgey> glen_quagmire: why do you need the Eq instance?
10:24:06 <quicksilver> glen_quagmire: what is the point of the eq instance? how does it help you?
10:24:10 <georgw> vincenz: Ahh. ;-)
10:24:11 <glen_quagmire> maybe it's flawed. I wanted to store primitive functions as my language values
10:24:37 <glen_quagmire> data Val = Int Integer | ... deriving (Eq, Ord)   so that I can use compare function on Val
10:24:52 <glen_quagmire> now, I have data Val = ... | Prim PrimFun
10:24:55 <doserj> glen_quagmire: it's typically safer to have a == b = False
10:25:32 <vincenz> doserj: safe in the sense of less buffer-overflows?
10:25:36 <skorpan> class (Monad m) => MonadState s m | m -> s where
10:25:42 <skorpan> what does | m -> s mean?
10:25:57 <vincenz> skorpan: the monad type uniquely defines the state type
10:26:06 <vincenz> meaning there's no two instances of MonadState
10:26:09 <vincenz> with the same 'm' but different 's''
10:26:25 <skorpan> okay, i don't quite get it,
10:26:32 <vincenz> you can't have
10:26:37 <vincenz> instance MonadState Foo X where ..
10:26:43 <vincenz> instnce MonadState Foo Y where ...
10:26:49 <quicksilver> glen_quagmire: well if you're happy that when comparing two values which happen to be functions then it will always be true
10:26:58 <quicksilver> glen_quagmire: then that's fine :)
10:27:15 <doserj> vincenz: missing to recognize equal values typically only increases memory. missing to recognize inequality typically gives surprising semantic differences
10:27:20 <quicksilver> as doserj points out, always false would be a more natural choice in some respects.
10:27:39 <vincenz> doserj: it was a poor attempt at humor :)
10:27:47 <glen_quagmire> maybe i need to separate Val and Val2
10:28:11 <glen_quagmire> ParsedVal   and EvaluatedVal
10:28:18 <doserj> vincenz: :)
10:31:15 <ToRA> if i'm doing ghc --make, i shouldn't need to be passing -l flags if i'm using libraries from hackage should i? (i'm appearing to need to to use the ncurses bindings, which is surprising me)
10:33:58 <glen_quagmire> if ghc-pkg list   has ncurses, probably you don't need -I flag. but i'm not sure
10:34:06 <shteou> ndm: Hi, do you know if the HBC description on the Haskell Wiki is up to date and correct?
10:34:08 <quicksilver> I think that means they have not quite been correctly make into ghc pkgs
10:34:17 <quicksilver> i.e. it's a packaging bug in ncurses
10:34:19 <quicksilver> I'm not sure though
10:34:28 <ndm> shteou: no idea, email the Yhc list to ask - its Tom who does that, not me
10:34:37 <shteou> Righto!
10:36:34 <ndm> shteou: oh, i enjoyed your talk today btw!
10:36:59 <shteou> ndm: I was shaking :(
10:37:05 <shteou> A bottle of wine has sorted me out though
10:37:33 <ndm> shteou: you looked a little bit nervous at the beginning, but were absolutely fine towards the end - you did very well
10:37:38 <Heffalump> shteou: augustss might be a good person to ask about HBC :-)
10:37:43 <shteou> Thanks ndm :)
10:37:44 <ndm> matt (the guy sat next to me) agreed with you
10:37:48 <ndm> Heffalump: wrong HBC :)
10:37:57 <shteou> hehe
10:38:11 <Heffalump> oh :-)
10:38:24 <Spockz|Uni> hello
10:38:29 <Heffalump> so, errm, what is this one?
10:38:41 <dons> Heffalump: is squiggle your project?
10:38:41 <Spockz|Uni> http://hpaste.org/6328#a1
10:38:50 <shteou> ndm, I'm actually looking at YHC now, I want to see if it's possible to produce better bytecode for obviously strict arguments.
10:39:07 <Spockz|Uni> why  should I use do .. in the else branch?
10:39:30 <ndm> shteou: have you read supero? my guess is that it isn't, without a real strictness analyser in Yhc, which we have, just not in the main copmile part
10:39:39 <ndm> Heffalump: Haskell Byte Code - the Yhc G-machine byte code
10:39:56 <ndm> Heffalump: when we named it, we weren't aware of the original HBC :)
10:39:58 <Heffalump> dons: yes.
10:40:03 <dons> ndm: did you see Andrew Coppin's question about locking on windows, on the list?
10:40:08 <dons> Heffalump: sounds useful!
10:40:23 <Heffalump> I might end up merging it into haskelldb, but Igloo said it was better to register the project on spec for now.
10:40:24 <ndm> dons: no, title?
10:40:27 <dons> we're messing around with similar things at the moment.
10:40:42 <quicksilver> Spockz: the inside of the else branch is an expression.
10:40:49 <dons> Subject: Re: [Haskell-cafe] File I/O question
10:40:57 <quicksilver> Spockz: if you have two statements, you need 'do' to turn them into an expression.
10:41:14 <quicksilver> Spockz: (I also think you mean return c not return input)
10:41:56 <Spockz> quicksilver: ah, ok.
10:41:56 <Spockz> input asks the question again
10:42:05 <quicksilver> then you mean input
10:42:08 <quicksilver> not return input
10:42:22 <Spockz> indeed
10:42:27 <Spockz> I fixed that locally :P
10:42:31 <quicksilver> ;)
10:43:05 <Spockz> thanks
10:43:40 <ndm> dons: using hte underlying CreateFile function call,  you just mask in a SHARE_READ flag - but no idea if its even possible to do via Haskell
10:43:41 <quicksilver> you can, of course, return an IO action.
10:43:47 <quicksilver> but it's not what you want to do here
10:44:00 <ndm> dons: if it isn't done yet, it could be trivially added, but would have to be added deep in the GHC libs
10:44:02 <quicksilver> (it's a useful way to return a "callback" or "call-later" action)
10:44:19 <ndm> don't think you can change your SHARE access after opening a handle though
10:44:22 <shteou> ndm: I haven't read that, I will put it on my todo list, I'll get this bytecode editor done first, though
10:44:37 <esteth_> I'm trying to follow haskellwiki's "Roll your own IRC bot" to learn more about using monads and IO in a sort of "real life" situation. Problem is that i'm still not all that good with types, and i'm getting type errors that i'm not sure what to do with. Here's my code: http://pastebin.com/db80dfa2
10:44:40 <ndm> shteou: you should write your report up first :)
10:45:07 <quicksilver> ndm, dons: this is a symptom of GHC choosing rather radically different ways of interpreting the h98 report's requirement on windows vs on unix
10:45:22 <quicksilver> (based on the different natural primitives/conventions of those two platforms)
10:45:24 <hpaste>  Spockz annotated "inputtest" with "fix(ed)" at http://hpaste.org/6328#a2
10:45:30 <mrd> esteth_: what's the error. also we have hpaste.org for haskell code
10:45:39 <shteou> ndm: That's been handed in now, I do need to stick the code in the repo some time soon though
10:45:50 <esteth_> oh, sorry :P I'll pastebin the error aswell, just a sec
10:45:57 <ndm> shteou: ah, ok, hack away then :)
10:46:01 <shteou> :p
10:46:35 <hpaste>  Esteth pasted "(no title)" at http://hpaste.org/6338
10:47:23 <mrd> oh, you mean hGetLine
10:47:30 <mrd> getLine works on stdin
10:47:44 <mrd> @hoogle getLine
10:47:44 <lambdabot> Prelude.getLine :: IO String
10:47:44 <lambdabot> System.IO.getLine :: IO String
10:47:44 <lambdabot> Data.ByteString.getLine :: IO ByteString
10:48:30 <esteth_> Ohh, thanks. I should be using hGetLine then :)
10:49:41 <mrd> and you aren't supplying enough parameters to privmsg later on
10:50:36 <esteth_> ah, i feel silly. thanks :)
11:10:31 <georgw> vincenz: Can you use RandomState with (Seq Bool) and with [Seq Bool] and it still refers to one state of the RNG?
11:13:53 <hpaste>  mrchebas pasted "Failing standalone deriving for Typeable and Data" at http://hpaste.org/6340
11:14:04 <mrchebas> yo people
11:14:22 <mrchebas> i am struggling with standalone deriving for Typeable and Data with GHC 6.8.2
11:14:27 <mrchebas> it fails mysteriously
11:14:37 <mrchebas> look at the paste
11:14:42 <mrchebas> http://hpaste.org/6340
11:15:03 <dons> hey mrchebas
11:15:33 <mrchebas> hi dons
11:15:53 <mrchebas> a bit quiet here
11:16:45 <dmead> boo
11:16:47 <dmead> man
11:16:50 <dmead> #haskell is big now
11:16:54 <dmead> bigger than java for some time
11:17:13 <vincenz> georgw: yep
11:17:37 <georgw> vincenz: ok, thx. Gee, there is soooo much I still have to learn about Haskell.
11:17:38 <vincenz> georgw: read up on moands
11:17:41 <vincenz> monads
11:17:42 <dons> mrchebas: better to ask on the mailing list
11:17:45 <mrd> oh no, we're popular?
11:17:52 <dons> get SPJ or one of the standlalone deriving people to answer
11:17:52 <vincenz> RandomSate is a monad, returning a type of item 'a'
11:17:52 <georgw> vincenz: ok. Tough stuff, it seems.
11:17:56 <dons> ?users
11:17:56 <lambdabot> Maximum users seen in #haskell: 473, currently: 456 (96.4%), active: 12 (2.6%)
11:17:59 <vincenz> in this case it either returns (Seq Bool)
11:18:01 <vincenz> or [Seq Bool]
11:18:04 <mrchebas> dons: probably a good idea for the cafe, thanks
11:18:11 <vincenz> however inside the monad (Whicch is a state monand, hence it has state) the state is that randomlist
11:18:19 <vincenz> no matter what type you return
11:20:29 <monochrom> I can explain why #haskell is going to be bigger than #java.  Everyone has figured out Java.  Many hasn't figured out Haskell.  :)
11:21:01 <wy> Isn't it already bigger than #java?
11:22:31 <wy> We have 461 total, but #java has only 273
11:22:55 <mrd> what about ##java
11:22:56 <cjb> there might be a bigger #java on a different network, though.
11:23:16 <wy> I don't know... what's the difference between #java and ##java?
11:23:26 <vincenz> wy: one '#' character
11:23:28 <wy> when I use "/join #java", I got into ##java
11:23:39 <tromp> #haskell is the better place to get help on your recursion theory assignments
11:23:41 <mrd> ## channels are discussion
11:24:00 <dons> java doesn't have an open source community that uses irc
11:24:17 <mrd> that java has an open source community at all has always puzzled me
11:24:17 <wy> mrd: what does that mean?
11:24:59 <mrd> wy: well, i'm not terribly sure, but the operators of this network seem to encourage people to have ## channels for "unofficial" stuff
11:25:28 <wy> Isn't chat unofficial by nature ;)
11:25:45 <wy> I found I can't ask any question in ##java
11:27:17 <wy> Some answers I got... "Why do you think you can iterate over an array with for (.. : ..)?", "go read the API", ...
11:28:24 <mrd> they are competing with ##c
11:28:27 <vincenz> I have found that the complexity of a language is directly related to the friendliness of the channel
11:28:40 <dons> heh
11:28:41 <olsner> lol, "Why do you think ..." ... Java breaks brains, it seems
11:28:56 <vincenz> With known exception being #ocaml due to the presence of -1- individual
11:29:14 <olsner> mr harrop?
11:29:18 <vincenz> no
11:29:25 <vincenz> Is he even in there?
11:29:28 <dons> DukeDave: did you resolve your issue in the end?
11:29:28 <Vq^> vincenz: how do we measure complexity then?
11:29:35 <tromp> it only takes 1 person to make a channel unfriendly?
11:29:35 <dons> or did it land in the too hard basket?
11:29:39 <EvilTerran> i'd s/complexity/quality/
11:29:44 <vincenz> tromp: You've never met Smerdy?
11:29:50 <EvilTerran> all the #java folk are bitter 'cos their language sucks :P
11:29:54 <tromp> never
11:29:57 <Vq^> :)
11:30:09 <vincenz> I think dons can testament
11:30:17 <olsner> I dunno, he's just the most famous troll I know of... I thought he was in the ocaml/lisp camp
11:30:17 <vincenz> He's probably the only non-troll banned from #haskell
11:30:21 <EvilTerran> meanwhile, all the #haskell folk are happy 'cos their language is *awesome* :)
11:30:40 <dons> vincenz: there's been a couple of others.
11:30:46 <vincenz> dons: Ah, I didn't know :)
11:31:17 <vincenz> Good thing I added 'probably' :)
11:31:54 <vincenz> wy: ouch, #scheme
11:32:03 <vincenz> I guess scheme is not a complex language :)
11:32:59 <tromp> i see a Smerdyakov in #ocaml
11:33:05 * vincenz nods
11:33:35 <tromp> can irssi split the window between diff channels?
11:33:44 <vincenz> tromp: why not use screeen?
11:33:48 <vincenz> But yes, I think it can
11:33:55 * olsner lurks in #ocaml to see if anything interesting happens
11:33:58 <byorgey> tromp: yes, it can split horizontally
11:34:24 <byorgey> tromp: do /window show n  to get a new split with window #n in it
11:36:47 <georgw> Ohhh, brain overflow... is there some easy explanation to what &&& does?
11:37:01 <vincenz> georgw: yes
11:37:06 <vincenz> georgw: fr arrow being (->)
11:37:16 <vincenz> (f &&& g) x === (f x, g x)
11:37:26 <mrd> > (f &&& g) x :: (Expr, Expr)
11:37:28 <lambdabot>  (f x,g x)
11:37:44 <dons> ?src (&&&)
11:37:44 <lambdabot> f &&& g = arr (\b -> (b,b)) >>> f *** g
11:38:00 <byorgey> > ((+1) &&& abs) (-4)
11:38:01 <lambdabot>  (-3,4)
11:38:04 <vincenz> dons: ouch
11:38:09 <jleedev> @type f
11:38:10 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
11:38:10 <dons> ?src (***)
11:38:10 <lambdabot> f *** g = first f >>> second g
11:38:20 <jleedev> @type x
11:38:21 <lambdabot> Expr
11:38:31 <dons> :t (.)
11:38:32 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:39:38 <georgw> vincenz: Why does it say in the docu on Haskell.org: (&&&) :: a b c -> a b c' -> a b (c, c')
11:39:51 <georgw> Seems to do something different...
11:40:18 <vincenz> georgw: it's more generic
11:40:29 <vincenz> georgw: (->) is an instance of Arrow
11:40:32 <desegnis_> georgw: replace ‘a’ by (->) to get the more specific type signature
11:40:47 <vincenz> :t (&&&)
11:40:48 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
11:41:08 <desegnis_> georgw: (b -> c) -> (b -> c') -> (b -> (c,c'))
11:41:23 <vincenz> and remember
11:41:30 <vincenz> (b -> c) === (->) b c
11:41:48 <vincenz> It's an infix type-constructor
11:42:11 <vincenz> (Just like on the expression-level you have:    a + b === (+) a b )
11:42:16 <georgw> Ohh, I see. Sorta. Bits of brain are escaping through my ears... ;-)
11:42:24 <ispy_> It happens dude :)
11:42:27 <vincenz> Welcome to Haskell :)
11:42:30 <ispy_> haha
11:42:39 <georgw> it hurts! ;-)
11:42:44 <vincenz> The stuff oozing out is crap like C
11:42:53 <georgw> vincenz: Hehehehe. =)
11:42:55 <vincenz> Empty the cup before filling it :)
11:43:07 <georgw> vincenz: Ok, seems like I should get drunk tonight.
11:43:13 <georgw> Eliminate all the weak brain cells.
11:43:17 <georgw> Make room for new ones.
11:43:26 <lispy> yay haddock2!
11:43:30 <vincenz> georgw: btw
11:43:35 <vincenz> georgw: I just noticed you're in switzerland?
11:43:45 <vincenz> georgw: I'm moving to zurich soon, and this may be o interest to you
11:43:54 <georgw> vincenz: Correct. PHD student at ETH Zurich.
11:43:55 <vincenz> georgw: http://oasis.yi.org/oasis/HUGZ
11:44:04 <georgw> vincenz: Oh, nice!
11:44:06 <lambdabot> Title: HUGZ - Oasis Wiki
11:44:16 <vincenz> First meet to take place once I move there, that being May
11:44:51 <vincenz> Feel free to put yourself on the wiki
11:45:26 <georgw> vincenz: That's cool! Looking forward to meeting you. I owe you a beer.
11:45:56 <vincenz> Great
11:46:08 <DukeDave> dons: Hey, no I haven't had a chance to look at it again with work
11:46:12 <vincenz> Maybe you can show me the nice side of Zurich then :)
11:46:25 <wieczyk> > id
11:46:25 <lambdabot>  Add a type signature
11:46:29 <georgw> vincenz: Sure. And let me know if I can be of any help.
11:46:31 <DukeDave> dons: I'm going to do some work at the weekend & post my findings to cafe
11:46:33 <wieczyk> > id :: Int -> Int
11:46:34 <lambdabot>  <Int -> Int>
11:46:36 <lispy> vincenz: Zurich only has nice sides I think :)
11:46:49 <wieczyk> It is possible to add to my GHCi something like this ? <Int -> Int> ?
11:47:08 <georgw> lispy: It does. :-) The lake is wonderful in the summer.
11:47:08 <lispy> wieczyk: Well, could use lambdabot locally
11:47:18 <dons> DukeDave: ok.
11:47:24 <lispy> georgw: I was there in october and it was still nice :)
11:47:29 <vincenz> lispy: well I've only been there 1 day for my interview, so I wouldn't know where to go
11:47:33 <allbery_b> http://hpaste.org/2814 ?
11:48:50 <pejo> vincenz, they hired you after just 1 live interview?
11:49:04 <vincenz> pejo: Yep
11:49:08 <lispy> has anyone here tried running a local hoogle?  Do you have thoughts about doing it?  Is it worth it? (I would want to add non-standard modules)
11:49:18 <vincenz> pejo:  I had a few phone interviews -and- it was a full day of live interviews...
11:49:20 <lispy> vincenz: congrats
11:49:44 <vincenz> pejo: Wait, why 'they'?
11:49:55 <Gilly> is it possible to construct a list in some monad by repeatedly calling some function: constr list x = append list x  and then if i do constr list 1 ; constr list 2 ; constr list 3 we would have [1,2,3] in list.
11:50:04 <georgw> vincenz: I added myself to the Wiki. Now I'll go for a beer or so... gotta clear my head out. ;-)
11:50:04 <Cheery> Should all Comonads be Functors, why?
11:50:08 <pejo> vincenz, your employer, that is.
11:50:10 <georgw> See you around!
11:50:11 <vincenz> georgw: enjoy
11:50:15 <vincenz> pejo: ah ok :)
11:50:27 <ehird> q: i have a nested data structure.
11:50:32 <desegnis> Gilly: Looks like the Writer monad
11:50:35 <ehird> basically, it's loads of stuff and then
11:50:37 <vincenz> pejo: well I live in another country..
11:50:41 <ehird> Foo [MyStructure]
11:50:44 <lispy> desegnis: oh, good call
11:50:49 <vincenz> pejo: flying me up and down multiple times would prolly be more expensive for them?
11:50:54 <ehird> I want to 'flatten it' -- turn it into a list of the datastructures, -without- MyStructures.
11:51:01 <ehird> Instead, there will be 'references' to other ones.
11:51:02 <Gilly> desegnis: ok, how do i use that?
11:51:05 <ehird> Basically, turning them into pointers.
11:51:17 <ehird> What would be the cleanest representation of a reference, & is there a nice algorithm to do this?
11:52:12 <vincenz> ehird: a zipper
11:53:26 <desegnis> Gilly: In the hierarchical module docs, look for Control.Monad.Writer and its submodules
11:54:15 <ehird> vincenz: doesn't seem right
11:54:15 <desegnis> Gilly: Note that it is written in a very generic way, so you won't even see a list there
11:54:25 <Gilly> i see
11:54:27 <ehird> the 'trivial' version of what i'm saying is adding:
11:54:29 <ehird> Ref Integer
11:54:34 <ehird> and making the integers indices of the list
11:54:36 <desegnis> Gilly: I'll try to come up with an example
11:54:51 <ehird> & that's what the scheme version of the code does
11:54:51 <Gilly> desegnis: thanks
11:56:31 <desegnis> > execWriter (tell [1] >> tell [2] >> tell [3])
11:56:32 <lambdabot>  [1,2,3]
11:57:29 <Gilly> hmm, nice
11:58:50 <wy> vincenz: Just came back from vegetable cutting. ouch #scheme!
11:59:29 <wy> tromp: who's Smerdyakov?
12:02:24 <tromp> annoying presence on #ocaml, according to vincenz
12:06:53 <tromp> let pascal  = iterate (\row -> zipWith (+) ([0] ++ row) (row ++ [0])) [1]
12:08:04 <tromp> let choose n k = pascal !! n !! k
12:08:15 <tromp> > choose 8 4
12:08:16 <lambdabot>  Couldn't match expected type `t1 -> t'
12:08:35 <gnuvince> :t choose
12:08:36 <lambdabot> forall a. (Random a) => (a, a) -> Gen a
12:08:59 <tromp> pascal!!8!!4
12:09:07 <tromp> > pascal!!8!!4
12:09:07 <lambdabot>   Not in scope: `pascal'
12:09:53 <wagle_home> > pascal!!8!!4 :: Expr
12:09:53 <lambdabot>   Not in scope: `pascal'
12:09:58 <EvilTerran> @let pascal  = iterate (\row -> zipWith (+) ([0] ++ row) (row ++ [0])) [1]
12:09:58 <lambdabot> Defined.
12:10:03 <EvilTerran> > pascal!!8!!4
12:10:04 <lambdabot>  70
12:10:16 <tromp> thx:)
12:10:46 <EvilTerran> > iterate (zipWith (+) <$> ([0]++) <*> (++[0])) [1]
12:10:47 <lambdabot>  [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],...
12:11:07 <ClaudiusMaximus> hi all, got a question about GHC's FFI: is it allowed to call hs_add_root() for another module after a previously added module has already had some of its Haskell code executed?
12:11:08 * wagle_home is too lazy to read scrollback..  8(
12:11:58 <tromp> :t <$>
12:11:59 <lambdabot> parse error on input `<$>'
12:12:02 <EvilTerran> iterate (([0]++) <$| zipWith (+) |*> (++[0])) [1]  -- or, with suitable pseudo-infix operators defined
12:12:12 <mehrheit> :t (<$>)
12:12:13 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:12:15 <EvilTerran> ?src <$>
12:12:15 <lambdabot> f <$> a = fmap f a
12:12:18 <wagle_home> EvilTerran, hmm..  and they complain about perl being line noise..  8)
12:12:38 <EvilTerran> wagle_home, indeed. we can even beat perl at that :D
12:13:01 <tromp> :t (<*>)
12:13:02 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
12:13:48 <mehrheit> > (+2) <$> (Just 1)
12:13:49 <lambdabot>  Just 3
12:15:02 <tromp> > (Just 1) >>= liftM (+2)
12:15:03 <lambdabot>   add an instance declaration for (Num (Maybe a1))
12:15:40 <wagle_home> :t (<$>)
12:15:41 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:15:42 <Gilly> hm... i have a higher-order function that works in io monad and i'd like to pass 'tell' as a function from writer monad such that it would build up a list of values... running into trouble with running all these monads at the same time
12:16:16 <wagle_home> > Just (+2) <*> (Just 1)
12:16:17 <lambdabot>  Just 3
12:17:20 <mehrheit> @index liftM
12:17:20 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
12:17:36 <wagle_home> (+2) <*> 1
12:17:41 <wagle_home> > (+2) <*> 1
12:17:41 <lambdabot>        add an instance declaration for (Num ((a -> b) -> a), Num (a -> b))
12:17:50 <EvilTerran> you can think of (<*>) as liftM2 ($), if it makes things easier
12:18:05 <EvilTerran> although it's not strictly accurate
12:18:20 <EvilTerran> it is for all Applicatives that are also Monads
12:18:22 <wagle_home> :t liftM2 ($)
12:18:23 <lambdabot> forall a b (m :: * -> *). (Monad m) => m (a -> b) -> m a -> m b
12:18:41 <EvilTerran> :t ap
12:18:42 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
12:18:47 <EvilTerran> ?src ap
12:18:47 <lambdabot> ap = liftM2 id
12:18:55 <wagle_home> :t liftM2 (.)
12:18:56 <lambdabot> forall a b (f :: * -> *) (m :: * -> *). (Monad m, Functor f) => m (a -> b) -> m (f a) -> m (f b)
12:19:00 <EvilTerran> <*> is the "apply" for which Applicative is named
12:19:38 <byorgey> wagle_home: note that (.) has been generalized by Cale...
12:19:51 <EvilTerran> :t liftM2 (Prelude..)
12:19:52 <lambdabot> forall b c a (m :: * -> *). (Monad m) => m (b -> c) -> m (a -> b) -> m (a -> c)
12:20:05 <wagle_home> yeah, thats why i did it..  but i was confused for a different reason
12:21:05 <wagle_home> @instances Applicative
12:21:05 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
12:21:13 <wagle_home> @instances-importing Applicative
12:21:14 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
12:21:15 * EvilTerran notes that (.) = fmap makes a perverse sort of sense if you think of (a -> b) as being the type of "mappings" rather than "functions"
12:21:17 <wagle_home> bah
12:21:33 <EvilTerran> @instances-importing Control.Applicative Applicative
12:21:34 <lambdabot> ((,) a), ((->) a), Const m, IO, Maybe, WrappedArrow a b, WrappedMonad m, ZipList, []
12:21:46 <EvilTerran> @help instances-importing
12:21:46 <lambdabot> instances-importing [<module> [<module> [<module...]]] <typeclass>. Fetch the instances of a typeclass, importing specified modules first.
12:22:39 <wagle_home> :t (.)
12:22:40 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:23:11 <wagle_home> would be less confusing (to me, i guess) if that was forall a b (f :: * -> *). (Functor f) => (a -> b) -> (f a -> f b)
12:23:16 <desegnis> Gilly: You could use the Writer monad transformer, which is called WriterT. But then again you'd have to ‘lift’ all IO actions
12:23:21 <byorgey> wagle_home: it is!
12:23:32 <wagle_home> i know
12:23:46 <wagle_home> took me a while though
12:24:51 <EvilTerran> ... but so, as fmap :: (a -> b) -> Map k a -> Map k b makes sense, so does fmap :: (a -> b) -> (->) k a -> (->) k b
12:25:34 <EvilTerran> and (a -> b) -> (->) k a -> (->) k b = (a -> b) -> (k -> a) -> (k -> b) = typeOf (.)
12:25:57 <wagle_home> no, thats fmap..  still dont understand why a category theoretic arrow composed with an object in another category is the compose operation, though
12:26:29 * EvilTerran is babbling about his own little thing here
12:27:01 <wagle_home> the "no thats fmap" is me arguing with myself
12:27:10 <dfranke_> aargh.
12:27:19 <EvilTerran> namely, reading (->) as Map when it suits, to make the Functor etc instances for (e->) more comprehendable
12:27:41 <EvilTerran> *comprehensible
12:27:57 <dfranke_> is there any possible Haskell program that I ought to be able to write that would hang when run standalone but terminate properly when being straced?
12:28:15 <dfranke_> or is this necessarily another compiler/runtime bug?
12:29:34 <Heffalump> if you can do it in C you can do it in Haskell, I'd guess.
12:29:51 <dfranke_> well, I mean without Foreign.C or FFI or anything.
12:30:04 <dfranke_> this is a deadlock of some sort.
12:30:17 <wagle_home> what strange thing is your program trying to do?
12:30:55 <dfranke_> it's a library implementing UNIX pipes as an arrow...
12:31:02 <DQuest> Hmm, remind me: can you do strict evaluation in haskell?
12:31:15 <dfranke_> and I have a test case that pipes 200 instances of cat to one one another.
12:31:25 * tibbe is pondering how he best can send Strings for logging from one thread to another
12:31:30 <DQuest> I have a report due in 4 hours in which I've got to blather on about the lazy operator in Alice ML, and I can't remember if there's a strict counterpart in haskell.
12:32:03 <DQuest> It's days like this where I come very close to completely understanding nihilism...
12:32:18 <dfranke_> DQuest: the closest thing to strictness in Haskell is seq.
12:32:36 <dfranke_> a `seq' b will fully evaluate a and then return b.
12:32:52 <DQuest> *nods* so you can fake it up at least
12:33:35 <Heffalump> a `seq` b will evaluate a to WHNF only
12:33:48 <Heffalump> which is a long way from "fully"
12:34:03 <DQuest> I'll write it anyway and then cite you, muahahaha!
12:34:12 <tromp> > [0..] `seq` ()
12:34:13 <lambdabot>  ()
12:34:29 <wagle_home> > [1..] `seq` 'a'
12:34:29 <lambdabot>  'a'
12:34:38 <wagle_home> awww.. ya beat me
12:34:52 <DQuest> What about >>?
12:34:57 <tromp> > undefined `seq` 0
12:34:59 <lambdabot>  Undefined
12:35:15 <tromp> > Just undefined `seq` 0
12:35:15 <gnuvince> Heffalump: WHNF?
12:35:16 <lambdabot>  0
12:35:34 * wagle_home is thinking about dfranke_'s problem, but not getting much of anywhere
12:35:34 <wagle_home> "Weak Head Normal Form"
12:35:38 <Heffalump> weak head normal form
12:35:48 <DQuest> [5..] >> [1] appears to generate an infinite stream of ones
12:35:52 <Heffalump> you evaluated it just as far as you need to find out if there's a lambda or a specific constructor at the top.
12:36:28 <DQuest> I suppose that makes sense, mind
12:36:42 <wagle_home> > [(5::Int) ..] >> return 1
12:36:43 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
12:37:02 <wagle_home> large, but not infinite
12:37:29 <Heffalump> however without the sig it'd default to Integer
12:37:35 <wagle_home> yeah
12:37:40 <Cheery> I extended comonads into a boring application
12:37:42 <wy> tromp: hmm he is working for Jean Street Capital
12:37:48 <Cheery> *Serializer> extract (picking (Bytes.pack [51,52,53]) » byte)
12:37:48 <Cheery> (51,"45")
12:37:48 <Cheery> *Serializer> extract (mashing Bytes.empty » mashByte 1 » mashByte 2)
12:37:48 <Cheery> "\SOH\STX"
12:38:27 <Heffalump> Prelude> length [(5::Int)..]
12:38:27 <Heffalump> Prelude> length [(5::Int)..2147483643
12:38:41 <hpaste>  Cheery pasted "Pick & Mash" at http://hpaste.org/6341
12:38:41 <Heffalump> hmm, tab completion caused something weird to happen there.
12:38:55 <Heffalump> Anyway, ghci did evaluate that in a reasonable time (less than a minute)
12:40:03 <Cheery> wdut?
12:40:29 <Cheery> I think it is quite lame thing
12:40:55 <Cheery> oh, and forgot the superfluous language pragmas in
12:41:24 <dfranke_> Is it possible that strace would ever cause a system call to terminate with EAGAIN, when otherwise it would just hang?
12:42:36 <quicksilver> any wxhaskell hackers?
12:48:07 <wagle_home> dfranke_, i've heard that it can be easy to deadlock pipes, but i dont appear to have any examples in my head
12:48:42 <hpaste>  ToRA pasted "hscurses + unicode?" at http://hpaste.org/6342
12:48:55 <ToRA> anybody know anything about hscurses + unicode + haskell strings?
12:50:22 <ToRA> i can't seem to get hscurses to render lambdas, though my term will quite happily
12:52:01 <Saizan> ToRA: encode as uft8 first?
12:52:24 <wagle_home> dfranke_, how are you scheduling giving processing time to different consumer/producers in your DAG?  DCG?
12:53:33 <Cin> tora: perhaps encode with utf8-string's encodeString
12:53:44 <wagle_home> dfranke_, sounds like you suspect the strace of causing blocked processes to give up control to other processes in the pipeline, allowing progress
12:54:24 <ToRA> Saizan,Cin: ah ok i'll try that
12:55:22 <wy> anyone here has interned for Jean Street?
12:55:47 <ToRA> Saizan/Cin: excellent, worked like a charm.  Many thanks
13:01:43 <byorgey> wy: ITYM Jane Street?
13:06:04 <wy> byorgey: maybe not. It's called Jean Street Capital. an NY company which uses OCaml
13:06:17 <tromp> jane street
13:06:36 <wy> oh...
13:06:38 <wy> got it
13:07:01 <wy> yes. jane street
13:07:01 <byorgey> wy: =)
13:07:30 <conal> Jean Street sounds more fun to me.
13:07:47 <byorgey> apparently the 'e' wandered over two places when no one was looking =)
13:08:07 <tromp> you're free to found Jean Street
13:08:25 <conal> tromp: can i get that in writing?
13:08:47 <conal> ;)
13:09:51 <byorgey> "Jean Street Capitol: providing for your governmental architecture needs since 2008"
13:10:08 <wy> wagle_home: I got admission from IU
13:10:40 <byorgey> wy: congrats!
13:10:51 <wy> byorgey: thanks :)
13:17:02 <wagle_home> wy, gratz!
13:18:19 * EvilTerran suddenly gets the hang of this proof assistant he's been playing with
13:18:26 <byorgey> EvilTerran: which one?
13:18:28 <EvilTerran> wow. suddenly this is unexpectedly easy to use.
13:18:30 <EvilTerran> JAPE
13:18:31 <ehird> @src noneOf
13:18:31 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
13:18:36 * Heffalump wishes he had time to learn proof assistants.
13:18:38 <Heffalump> Though not JAPE.
13:18:39 <ehird> @src Text.ParserCombinators.Parsec.noneOf
13:18:39 <lambdabot> Source not found. The more you drive -- the dumber you get.
13:19:06 <EvilTerran> J∀P∃, if you prefer :P
13:19:12 <byorgey> hehe
13:19:26 <gbacon> preddddddy leddddders...
13:19:36 <Heffalump> J{\forall}P{\exists}
13:19:59 <wy> wagle_home: thanks. I guess I will be happy there
13:24:43 <dfranke_> wagle_home: nevermnd for now... I'm going to try to boil this down to as simple a test case as I can.
13:28:11 <wagle_home> wy, check out CISAB, if animal stuff interests you
13:28:54 <wy> wagle_home: ah! that's interesting
13:29:43 <ehird> @hoogle [(a,b)] -> Map a b
13:29:44 <lambdabot> Data.Map.fromDistinctAscList :: [(k, a)] -> Map k a
13:29:44 <lambdabot> Data.Map.fromList :: Ord k => [(k, a)] -> Map k a
13:29:44 <lambdabot> Data.Map.fromAscList :: Eq k => [(k, a)] -> Map k a
13:30:13 <ehird> hm, wait, that won't work
13:31:00 <ehird> hmm, the usage of this will be really ugly :)
13:35:09 <Cheery> somehow error handling in haskell does not make me happy
13:36:55 <Cheery> you can pull together something relatively simple, quite fast
13:37:08 <Cheery> when you need to handle errors, it blows up
13:37:58 <Cheery> the result is either cryptic errors or cryptic code
13:39:21 <Cheery> then there is this world of warnings
13:39:29 <Cheery> in some warnings, one should halt, in others not
13:40:09 <Cheery> in another warnings, the computation should be continued but handled different
13:40:51 <Cheery> in most cases, you end up with a conclusion that you do not want the error strings to clutter up your code
13:41:42 <wagle_home> | uniq
13:47:51 <vincenz> QC makes testing fun!
13:48:37 <Cheery> thus, in stuff like: Just foobar <- getEnv "A"  the error ought be interesting.
13:50:54 <wy> wagle_home: there are too many exciting things there
13:51:45 <RobHu> Could some people let me know if the video plays for them on http://www.foomongers.org.uk/videos/spj-typedriventestinginhaskell.html ? I'm getting conflicting reports.
13:52:38 <Nafai> I'm downloading the linked video right now
13:52:53 <RobHu> From which site?
13:54:20 <Nafai> http://videos.foomongers.org.uk/spj-typedriventestinginhaskell.h264.mp4 <= It's linked on that page under Materials, with the link "Video download"
13:54:22 <lambdabot> http://tinyurl.com/2f5d7d
13:54:22 <byorgey> RobHu: I'm downloading it too.  it's Very Large.
13:54:35 <Nafai> 5 more minutes and I'll have it :)
13:54:46 * byorgey is jealous
13:54:49 <RobHu> Nafai: What download speed are you getting ?
13:54:51 <byorgey> I still have 31 minutes to go
13:55:01 <RobHu> byorgey: The original here on my laptop is 15GB :D
13:55:02 <wagle_home> streaming it from the net on my suse 10.1 x86_64 machine
13:55:09 <Nafai> ~ 150 k/s
13:55:14 <RobHu> mmm
13:55:19 <RobHu> You'll find the mirror is much faster
13:55:28 <byorgey> RobHu: yikes!
13:56:10 <RobHu> byorgey: My poor laptop got very hot for 2 hours compressing it for you :)
13:56:27 <byorgey> RobHuslaptop++
13:56:43 <byorgey> hehe, RobHu++ too =)
13:56:50 <RobHu> I'm the guy frantically trying to pan the camera to keep up with SPJ :P
13:57:02 <lispy> anyone have haksell modules for working with python?
13:57:21 <byorgey> lispy: I think glguy was recently working on just such a thing.
13:57:42 <TomMD> I can't find a simple Haskell IPC library - anyone know of one?
13:58:04 <TomMD> ex: Unix datagram sockets.
13:58:42 * wagle_home kicks the camera person
13:58:49 <sebell> TomMD: Well, I believe Network.Socket will give you access to those
13:59:16 <TomMD> sebell: Access, yes, high level IPC, no.  I'll write one once I don't think I'm duplicating.
14:00:10 <sebell> TomMD: Like yourself, I've never heard of one :)
14:00:37 <Cheery> is there an operation on monads like this one?
14:01:07 <oerjan> Cheery: like what?
14:01:12 <Cheery> Monad m => m Bool -> m a -> m [a]
14:01:33 <byorgey> Cheery: what would that do?
14:01:37 <Cheery> @hoogle Monad m => m Bool -> m a -> m [a]
14:01:37 <lambdabot> No matches, try a more general search
14:01:56 <oerjan> Cheery: should it run the second only if the first gives True?
14:02:17 <Cheery> oerjan: yep, and recurse that
14:02:34 <lispy> TomMD: dons wrote a blog article about that once
14:02:41 <oerjan> oh repeat while True...
14:02:48 <Cheery> ie. m Bool >> m a >> m Bool >> m a >> m Bool etc. then -> m [a]
14:02:52 <oerjan> Cheery: nothing predefined
14:02:55 <byorgey> aha
14:03:08 <RobHu> Is the video link worth posting to Haskell cafe ? I'm not on the mailing list, if you guys think so could someone please post it there?
14:03:10 <byorgey> there really ought to be a whileM in the libraries.  perhaps I will propose one.
14:03:12 <lispy> glguy: give me python modules in haskell!!! :)
14:03:14 <oerjan> there is a lack of loops with escape
14:03:40 <Cheery> byorgey: whileM and whileM_ probably
14:03:45 <Cale> Yeah, it might be nice to have some which pass the loop body a continuation to call.
14:03:45 <TomMD> If I do write an IPC I'll need a windows guru to check out that platform.
14:03:46 <byorgey> Cheery: indeed
14:03:57 <RobHu> actually, I'll sign up to send it
14:04:15 <tibbe> how do I join (i.e. wait for) two threads to finish?
14:04:27 <byorgey> RobHu: yes, it's definitely worth posting to the cafe
14:04:29 <Cin> waitForThread or something
14:04:43 <Cin> @hoogle wait
14:04:43 <lambdabot> System.Process.waitForProcess :: ProcessHandle -> IO ExitCode
14:04:43 <lambdabot> Control.Concurrent.QSem.waitQSem :: QSem -> IO ()
14:04:43 <lambdabot> Control.Concurrent.QSemN.waitQSemN :: QSemN -> Int -> IO ()
14:04:49 <Cheery> thought, theres so many possible whileM -things
14:04:53 <Cin> hm, nop
14:05:09 <tibbe> or does the process wait for all threads to finish before exiting?
14:05:18 <tibbe> I have a ThreadId
14:05:19 <Cheery> the one where a is returned as [a] is just a thing I need right now
14:05:32 <oerjan> tibbe: you have to use MVars or something to signal from the finishing threads
14:05:33 <Cheery> and there would be an another, like:
14:05:47 <tibbe> oerjan: I see
14:05:49 <Cheery> (a -> m Bool) -> m a -> m ()
14:05:56 <tibbe> oerjan: so the waiting thread takes the mvar
14:06:00 <oerjan> tibbe: and the process ends when the main thread does
14:06:08 <tibbe> oerjan: ok
14:06:17 <RobHu> I used the web interface to sign up to haskell-cafe, but I haven't received an email - how long should it take? It's been a few minutes.
14:06:26 <RobHu> ah, speak to soon...
14:06:28 <byorgey> Cheery: that would probably be the preferred form of whileM_
14:06:57 <oerjan> tibbe: i recall from the last discussion that a thread may finish without trace if you don't arrange for it to signal its demise :)
14:06:58 <byorgey> Cheery: and whileM would be :: (a -> m Bool) -> m a -> m [a]
14:07:13 <tibbe> oerjan: ok :)
14:07:19 <Cheery> byorgey: ingenious
14:07:27 <byorgey> Cheery: you could recover your  m Bool -> m a -> m [a]  by passing 'const foo' as the first parameter
14:08:00 <monochrom> RobHu: Don't worry, haskell-cafe is quiet now. Last message was an hour ago.  As long as you receive a confirmation message that's fine.
14:08:29 <monochrom> But if you receive no confirmation email, check your spam filter mechanisms.
14:08:30 <Cheery> byorgey: thought, the (a -> m Bool) -> m a -> m [a] would be more like untilM
14:08:46 <byorgey> Cheery: actually, you're right
14:08:46 <olsner> @index untilM
14:08:46 <lambdabot> bzzt
14:08:51 <byorgey> Cheery: or doWhileM =)
14:08:59 <byorgey> that would probably be too confusing...
14:09:02 <olsner> doMwhile :P
14:09:12 <gbacon> @src untilM
14:09:12 <lambdabot> Source not found. You type like i drive.
14:09:18 <Cheery> iDrive
14:09:22 <olsner> @ty untilM
14:09:23 <lambdabot> Not in scope: `untilM'
14:09:54 <RobHu> Could someone give me a heads up if they get a mail from me on haskell-cafe? Thanks
14:10:08 <Cheery> @src until
14:10:09 <lambdabot> until p f x | p x       = x
14:10:09 <lambdabot>             | otherwise = until p f (f x)
14:10:37 <byorgey> Cheery: ah, yes, to be consistent untilM should just generalise until
14:10:39 <byorgey> @type until
14:10:40 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
14:11:44 <Cin> :t liftM until
14:11:45 <lambdabot> forall a (m :: * -> *). (Monad m) => m (a -> Bool) -> m ((a -> a) -> a -> a)
14:11:48 <byorgey> (a -> m Bool) -> (a -> m a) -> a -> m a ?    hrm
14:12:19 <Cheery> :t liftM
14:12:20 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
14:12:24 <oerjan> Cin: liftM will do nothing about which actions are performed, it only changes the result
14:12:28 <byorgey> well, it's not as obvious as I thought.  maybe this is why it's not already in the standard libraries =)
14:12:47 <Cin> oerjan: i figured
14:13:50 <Cheery> hm. there should be something like that, but yep, it's hard to decide what sort of things they should be then
14:15:17 <oerjan> Cin: in fact nearly none of the complicated monadic operations will let an action depend on the returned result of another - they are essentially Applicative.  only a few of the most primitive ones are exceptions, like >>= and join
14:15:37 <Cheery> there's chance for somebody to write a nice paper about looping in haskell ;)
14:18:31 <oerjan> hm.  if Applicative had been a superclass of Monad, then this would have been obvious from Control.Monad being nearly empty.  i'm sure then someone would have filled it with loops and stuff already.
14:19:14 <byorgey> oerjan: interesting point.
14:19:48 <tromp> > 26.8 / 2.2
14:19:48 <lambdabot>  12.181818181818182
14:20:16 <tromp> > 9.8 * 12.181818181818182
14:20:17 <lambdabot>  119.38181818181819
14:20:51 <tromp> > 17.5 * 12.181818181818182
14:20:51 <lambdabot>  213.1818181818182
14:21:03 <EvilTerran> > 18 / 99
14:21:04 <lambdabot>  0.18181818181818182
14:21:17 <tromp> > (211.61+283.85)/2
14:21:18 <lambdabot>  247.73000000000002
14:21:21 <EvilTerran> use Rationals, man. this is haskell, after all.
14:21:30 <EvilTerran> > 26.8 / 2.2 :: Rational
14:21:30 <lambdabot>  134%11
14:21:46 <tromp> sorry, bear with me:)
14:21:56 <tromp> > 247.73 * 120.01
14:21:56 <lambdabot>  29730.0773
14:22:17 <EvilTerran> yeah, i don't think so well when there's something of the ursine persuasion nearby either.
14:22:32 <Cin> pigs?
14:22:40 <lispy> bears
14:22:41 <dmwit> bears...
14:22:48 <Cin> haha, i make joke.
14:24:58 <Cheery> multiM c m = c >>= g where g True = liftM2 (:) m (multiM c m)
14:24:58 <Cheery>                            g False = return []
14:24:58 <Cheery> multiM_ c m = c >>= g where g True = m >> multiM_ c m
14:25:00 <Cheery>                             g False = return ()
14:25:12 <Cheery> byorgey: what do you like about these?
14:25:43 <Cheery> @ let multiM c m = c >>= g where g True = liftM2 (:) m (multiM c m) ; g False = return []
14:25:47 <Cheery> @let multiM c m = c >>= g where g True = liftM2 (:) m (multiM c m) ; g False = return []
14:25:49 <lambdabot> Defined.
14:26:09 <Cheery> @type  multiM
14:26:10 <lambdabot> forall (m :: * -> *) a. (Monad m) => m Bool -> m a -> m [a]
14:26:27 <EvilTerran> tromp, you know you can interact with lambdabot via pm?
14:26:36 <byorgey> Cheery: nice.
14:26:37 <EvilTerran> assuming you're identified to services, anyway
14:27:07 <byorgey> Cheery: what about this?
14:28:23 <byorgey> hang on
14:28:52 <byorgey> @type let multiM c m = c >>= g where g True = liftM2 mappend m (multiM c m) ; g False = return mempty in multiM
14:28:53 <lambdabot> forall (m :: * -> *) a. (Monad m, Monoid a) => m Bool -> m a -> m a
14:29:09 <byorgey> hm, that's not quite right
14:29:42 <Cheery> you mean you'd generalize to monoids...
14:29:46 <Cin> i'm really enjoying the Beautiful Concurrency paper
14:29:47 <byorgey> nvm, I guess a list is just fine =)
14:29:57 <byorgey> you can do whatever you want with the results of the list, after all
14:30:22 <byorgey> including mconcat =)
14:30:38 <Cheery> well, I don't end up being greedy, but it may be ok to use mappend or sth.
14:31:07 <Cheery> many = multiM isEmpty
14:32:14 <Cheery> runGet (many protocol) `liftM` (Bytes.readFile =<< xauthority)
14:34:14 <AMcBain> Is there an "IDE" I can get for Haskell for Linux (Kubuntu)? My professor says the labs uses the Hugs system (and I wanted to be as compatible as possible) so I installed that but it only came with packages, no GUI.
14:34:31 <dmwit> Try running "hugs".
14:34:45 <dmwit> It's not an IDE, just a REPL-alike.
14:35:00 <dmwit> For development, I think most people use vim/emacs.
14:35:12 <lament> AMcBain: basically, no.
14:35:25 <lament> AMcBain: but there's eclipsefp, a plugin for eclipse
14:35:38 <lament> i haven't had much luck with it.
14:35:59 <lament> also, you're lucky! you get to study haskell :)
14:36:47 <AMcBain> So the only choice I have is this command line tool? Alright ... well we just got off of scheme (and still have a few projects left to do ...)
14:37:19 <lament> wow, scheme AND haskell
14:37:40 <dmwit> Sounds like a class that introduces a million-and-one languages.
14:37:53 <dmwit> That way you get to learn the syntax of all of them, and appreciate none of them.
14:37:55 <dmwit> =/
14:37:58 <lament> yeah
14:38:13 <lament> dmwit: enough scheme to learn that it has a bunch of parentheses :)
14:38:34 <lament> admittedly my uni used to teach scheme for a semester as the first CS course, and most people hated it.
14:38:55 <dmwit> For a class like that, I'd really want some editor that works OK for all languages, rather than having to learn a new IDE for each one.
14:38:57 <lament> everybody who had any previous exposure to programming hated it for the syntax, and everybody else just went along.
14:38:58 <dmwit> But that's just me.
14:40:24 <AMcBain> Well considering I just turned in a project in C++ that worked in valgrind but not by itself ... so any language is better than that ...
14:44:49 <travisbrady_> can anyone tell me is it normal for newbies (like me) to want to extract things from Monads before working with them as opposed to dealing with the value while wrapped in the Monad?
14:45:19 <oerjan> travisbrady_: completely normal i think.  but wrong.  ;)
14:45:58 <travisbrady_> oerjan: thanks, so what are the tools one needs to get comfortable with?  liftM fmap?
14:46:07 <oerjan> although you can approximate it with do x <- ... notation
14:46:59 <oerjan> ... or with >>=.   the thing is that you are sort of extracting, but still within the monad.
14:48:09 <travisbrady_> oerjan:  a big hurdle for me has been what to do with things wrapped in Just, i often pull them out within a do block, but this feels messy
14:48:18 <oerjan> liftM = fmap in all sensible cases
14:48:36 <oerjan> travisbrady_: for Just you can use pattern matching
14:49:02 <oerjan> extraction is possible for some specific monads like Maybe / []
14:49:19 <tromp> :t (.)
14:49:20 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:49:40 <oerjan> tromp: Cale redefined (.) = fmap in lambdabot :)
14:49:58 <oerjan> :t (++) -- and this is mappend i think
14:49:59 <lambdabot> forall m. (Monoid m) => m -> m -> m
14:50:36 <tromp> fmap seems like a generalized (.)
14:51:16 <tromp> (.) is fmap for the Functor (->)
14:51:26 <idnar> some people would like fmap to be spelled (.) :)
14:51:38 <idnar> oh.
14:51:46 <oerjan> travisbrady_: actually nearly every monad _can_ be extracted (IO being the main case where you usually shouldn't) but it would usually be a bad idea to extract (other than with <- or >>=) just to put it back into the same monad
14:51:50 <idnar> apparently I'm a bit late to the conversation
14:53:15 <tromp> wait, (.) is fmap for the Functor (a ->)
14:53:29 <travisbrady_> thanks oerjan
14:53:32 <tromp> so (.) is more polymorphic than fmap?
14:53:51 <idnar> no
14:54:04 <idnar> (.) is a specific case of fmap
14:54:52 <bos> (.) is also known as <$> for a suitable Applicative
14:55:26 <ehird> @pl \i l -> reverse $ drop i reverse l
14:55:26 <lambdabot> (reverse .) . flip drop reverse
14:55:29 <ehird> beh
14:56:00 <ehird> @pl \i l -> reverse $ drop i $ reverse l
14:56:00 <lambdabot> (reverse .) . (. reverse) . drop
14:57:29 <ehird> @hoogle a -> b -> b
14:57:29 <lambdabot> Prelude.const :: a -> b -> a
14:57:30 <lambdabot> Prelude.seq :: a -> b -> b
14:57:30 <lambdabot> GHC.Conc.par :: a -> b -> b
14:57:36 <ehird> was hoping for Trace
14:57:36 <ehird> :)
14:59:51 <dmwit> ?pl \i l -> take (length l - i) l
14:59:51 <lambdabot> join . (take .) . flip ((-) . length)
15:01:03 <dmwit> ?hoogle String -> b -> b
15:01:04 <lambdabot> Debug.Trace.trace :: String -> a -> a
15:03:55 <ehird> > let dropEnd i = reverse . drop i . reverse; encode ""       = ""; encode [x]      = [x]; encode (x:y:xs) = x : (encode xs ++ [y]); decode ""     = "";decode [x]    = [x]; decode (x:xs) = x : last xs : decode (dropEnd 1 xs) in (decode.encode) "hello world"
15:03:55 <lambdabot>  "hello world"
15:04:06 <faxathisia> Hi
15:04:12 <ehird> @check (\x -> let dropEnd i = reverse . drop i . reverse; encode ""       = ""; encode [x]      = [x]; encode (x:y:xs) = x : (encode xs ++ [y]); decode ""     = "";decode [x]    = [x]; decode (x:xs) = x : last xs : decode (dropEnd 1 xs) in ((decode.encode) x) == x)
15:04:13 <lambdabot>  OK, passed 500 tests.
15:04:15 <ehird> \o/
15:04:50 <faxathisia> > let dropEnd i = reverse . drop i . reverse; encode ""       = ""; encode [x]      = [x]; encode (x:y:xs) = x : (encode xs ++ [y]); decode ""     = "";decode [x]    = [x]; decode (x:xs) = x : last xs : decode (dropEnd 1 xs) in encode "what does this do?"
15:04:51 <lambdabot>  "wa osti o?dsh edth"
15:05:04 <faxathisia> hehe
15:05:05 <ehird> faxathisia: changes anything into line noise that still 'feels' like the original text
15:05:10 <ehird> and provides a way to go back again
15:05:32 <faxathisia> 0246...7531 ?
15:05:39 <dmwit> yeah
15:06:11 <faxathisia> > let dropEnd i = reverse . drop i . reverse; encode ""       = ""; encode [x]      = [x]; encode (x:y:xs) = x : (encode xs ++ [y]); decode ""     = "";decode [x]    = [x]; decode (x:xs) = x : last xs : decode (dropEnd 1 xs) in encode "wa osti o?dsh edth"
15:06:12 <lambdabot>  "w siodhethd s? toa"
15:06:26 <faxathisia> > let dropEnd i = reverse . drop i . reverse; encode ""       = ""; encode [x]      = [x]; encode (x:y:xs) = x : (encode xs ++ [y]); decode ""     = "";decode [x]    = [x]; decode (x:xs) = x : last xs : decode (dropEnd 1 xs) in iterate encode "what does this do?"
15:06:27 <lambdabot>  ["what does this do?","wa osti o?dsh edth","w siodhethd s? toa","wsohtds oat...
15:06:31 <ehird> yep
15:06:32 <ehird> runs forever
15:06:39 <ehird> it's my favourite silly-cipher
15:06:41 <ehird> even more than rot13
15:06:50 * faxathisia wonders how long the period is..
15:06:52 <sethk> what's the syntax for an empty list?  I'm using [], but it's a list of Strings so [] = "", not empty
15:07:00 <glguy> lispy: some example code is in the hpastetwo repository on code.h.o
15:07:06 <glguy> Highlighting module
15:07:15 <lispy> hmm
15:07:18 <faxathisia> sethk: Huh?
15:07:30 <dmwit> > let chunk i = takeWhile (not . null) . unfoldr (Just . splitAt i); encode xs = let chunks = chunk 2 xs in map head chunks ++ reverse (map (!!1) chunks) in encode "what does this do?"
15:07:31 <lispy> glguy: hpastetwo?
15:07:31 <lambdabot>  "wa osti o?dsh edth"
15:07:36 <lispy> ?where hpastetwo
15:07:36 <lambdabot> I know nothing about hpastetwo.
15:07:41 <glguy> http://code.haskell.org/hpaste.git
15:07:44 <quicksilver> sethk: in a list of strings, [] is empty.
15:07:59 <sethk> quicksilver, ok, then perhaps I'm misinterpreting what I'm seeing
15:08:01 <quicksilver> sethk: [""] would be a list with a single member, being an empty string.
15:08:12 <quicksilver> you could also write [""] as [[]]
15:08:19 <dmwit> decode is a little trickier, let's see...
15:08:22 <quicksilver> (which is different from [])
15:08:32 <sethk> quicksilver, ok.  I'll go back to the code.  I'm getting ["","", ...], I must have a logic error
15:08:33 <hpaste>  ehird pasted "an encoder/decoder, including 'main'. a pipe. give 'decode' as arg to decode. no ending newline at t" at http://hpaste.org/6344
15:08:40 <ehird> ..he bottom of this file
15:08:41 <ehird> :)
15:08:50 <Cheery> is there a function that returns the first one that satisfies a function?
15:08:50 <ehird> your reward for writing your own decoder is getting that encoder&decoder
15:08:50 <ehird> haha
15:08:53 <lispy> glguy: hmm...are you sure that's the right url?
15:09:06 <lispy> glguy: there doesn't seem to be any haskell code there
15:09:23 <sethk> quicksilver, so  [] ++ list   is list?
15:09:25 <Cheery> ie. head . filter f
15:10:01 <lispy> ?check \list -> [] ++ list == (list :: [Int])
15:10:02 <lambdabot>  OK, passed 500 tests.
15:10:16 <ehird> lispy: you have to git it
15:10:17 <ehird> :)
15:10:37 <lispy> oh, git...yeah i don't have that installed anywhere
15:10:48 <quicksilver> sethk: correct, as elegantly confirmed by lispy there :)
15:11:08 <dmwit> > let decode xs = let (b, e) = splitAt (length xs `div` 2) xs in concat $ zipWith (\a b -> [a, b]) b (reverse e) in decode "wa osti o?dsh edth"
15:11:09 <lambdabot>  "what does this do?"
15:11:10 <hpaste>  ehird pasted "the encoder/decoder as before, but decoded for you" at http://hpaste.org/6345
15:11:13 <dmwit> Sweet!
15:11:26 <sethk> quicksilver, ok.  I think the compiler is referring a different type than [String].  I'll put in explicit signatures and see where I messed up
15:11:35 <dmwit> There's a solution with only a single pattern for each function. =)
15:11:51 <faxathisia> mm nice
15:11:54 <dmwit> Oh, but decode only works for even-length strings, hmm.
15:11:55 <faxathisia> that's neat
15:12:19 <ehird> dmwit: neat
15:12:22 <ehird> apart from the even-length thing
15:12:27 <ehird> btw -- to use my program:
15:12:31 <ehird> $ echo -n "..."|./encode&&echo
15:12:35 <ehird> best way, since newlines make it go all weird
15:12:47 <ehird> bs a,snenwie aei oalwidre l gt kmsnle ci ywte
15:13:36 <dmwit> heh
15:14:05 <ehird> i wonder...
15:14:11 <ehird> encode a corpus of text, feed it to a markov chain
15:14:13 <ehird> decode its output
15:14:27 <oerjan> ooh wait a complication - if some letter of a cycle is duplicated, you don't need to use swap for that cycle
15:14:34 <oerjan> wrong channel
15:15:12 <sethk> quicksilver, found it.  I used : instead of ++ in one spot
15:15:28 <ehird> dmwit: I wonder if golfing this program would be fruitful. :-P
15:15:40 <dmwit> heh
15:16:10 <quicksilver> sethk: easy mistake to make :)
15:16:37 <quicksilver> sethk: often the type checker will catch it, but not in this particular case.
15:18:34 <sethk> quicksilver, it did catch it, I just didn't understand the message  :)
15:24:00 <glguy> lispy: it is a git repo, just do: git clone http://code.haskell.org/hpaste.git
15:26:36 * tibbe celebrates a successful hacking evening
15:27:54 <dmwit> tibbe: 'grats!
15:28:41 <dons> lambdabot: ?join #xmonad
15:28:41 <dons> ?join #xmonad
15:29:22 <tibbe> ah, JaffaCake !
15:32:48 <faxathisia> What is an irregular datatype?
15:34:33 <TomMD> One that Simon didn't write?
15:34:44 <idnar> haha
15:39:38 <dons> dcoutts__: i opened a ticket for the issue that came up, http://hackage.haskell.org/trac/ghc/ticket/2154
15:39:41 <lambdabot> Title: #2154 (Stack overflow due to unsafePerformIO) - GHC - Trac
15:39:44 <dons> dcoutts__: if you've anything to add.
15:40:04 <dons> once JaffaCake confirms what is going on, i'll push the change to bytestring to use dupablePerformIO
15:40:38 <wagle_home> PUIUSOPIO
15:41:09 <wagle_home> (Programming Under the Influence of UnSafePerformIO)
15:41:21 <dons> :)
15:41:40 <oerjan> i thought it was some finnish swear word...
15:41:56 <kosmikus> faxathisia: you mean irregular as in "not regular"? that's a recursive datatype that cannot be written using a first-order fixpoint operator
15:42:16 <dons> hey kosmikus, coming to the hackathon?
15:42:20 <kosmikus> faxathisia: i.e., the recursive call(s) change(s) the argument(s) of the datatype
15:42:28 <shepheb> UUPIOA? "Users of unsafePerformIO Anonymous" "My name is Braden, and it's been three weeks since I last unwrapped impure code"
15:42:37 <faxathisia> ahh.. thanks kosmikus
15:43:13 <kosmikus> dons: thinking about it ... but I still have to teach during that time
15:43:28 <kosmikus> dons: you're going?
15:46:29 <hpaste>  kokr pasted "Lexer for s-expr-like syntax" at http://hpaste.org/6348
15:47:26 <hpaste>  kokr annotated "S-Expression PolyParse parser" with "Parser for s-expr-like syntax has a memory leak..." at http://hpaste.org/6310#a1
15:47:33 <dons> kosmikus: yep.
15:49:45 <ehird> s-expr: trivial
15:49:56 <kosmikus> dons: I'm certainly interested to go. If I can arrange it, I'll try to. But probably I can only decide two weeks from now, and then have to hope that I can still find a relatively cheap flight.
15:50:10 <dons> oh, remember also its over a weekend
15:50:18 <dons> fri,sat,sun.
15:50:33 <dons> and also galois and credit suisse are covering all the catering :)
15:52:01 <kosmikus> hehe
15:52:30 <dons> (i'm really happy about that, all the dinners will be covered. so much nicer for the student hackers)
15:52:40 <kosmikus> yes, it's good that it is a weekend
15:52:54 <kosmikus> during the week I certainly couldn't go
15:53:21 <kosmikus> oh ok, even dinners
15:53:28 <kosmikus> and all the beer?
15:53:37 <dons> good question. maybe?
15:53:41 * dons needs to consult on that
15:54:00 <dons> swedish beer, eh?
15:55:35 <kosmikus> that's not necessarily bad if you can get any for a reasonable price
15:55:44 <sieni> swedish dinners are better than swedish beer
15:55:58 <dons> should be fun!
15:56:02 <TomMD> luckys
15:56:18 <dons> TomMD: I wonder if we should do an east coast hackathon next...
15:56:30 <dons> at least something this side of the atlantic, eh?
15:56:50 <kosmikus> plans for co-locating with ICFP again?
15:57:09 <dons> not sure yet. up in vancouver is hard for students
15:57:23 <dons> but its on the radar
15:57:24 <TomMD> dons: I'd definiately show up.  Similar thought: Andy was suggesting a week or two long course (vice a hackathon) which might help many people get up to speed on developing.
15:57:28 <byorgey> east coast hackathon = yes please! =)
15:57:41 <dons> TomMD: oh, that's interesting
15:57:48 <dons> byorgey: hehe.yeah. i think we'd find heaps of people
15:58:13 <tuukkah> swedish cider seems to be world-famous
15:58:20 <byorgey> I might even be willing to help organize such a thing...
15:58:35 <dons> mmm. good  to know
15:58:38 <Qerub> How would you rewrite this ugly function? I must be forgetting some standard function.
15:58:40 <Qerub> increasingNumbers x = all id $ zipWith (<=) x (tail x)
15:58:57 <tensh> the hackathon is located at chalmers, right?
15:59:07 <dons> yeah
15:59:31 <wagle_home> :t or
15:59:32 <lambdabot> [Bool] -> Bool
15:59:40 <tuukkah> :t and
15:59:41 <lambdabot> [Bool] -> Bool
15:59:41 <tensh> ok, might see you in the hallway then ;)
15:59:45 <tuukkah> ;-)
15:59:51 <dons> tensh: cool :)
16:00:12 <faxathisia> > let increasingNumbers x = all id $ zipWith (<=) x (tail x) in increasingNumbers [1,2,3,1,2,4,5,6,4,3,2,7,8,4,7,9,10]
16:00:12 <lambdabot>  False
16:00:13 <dons> http://hackage.haskell.org/trac/ghc/ticket/2154
16:00:14 <dons> grr
16:00:15 <lambdabot> Title: #2154 (Stack overflow due to unsafePerformIO) - GHC - Trac
16:00:22 <wagle_home> tensh, yeah..  just had "ormap" bouncing around my head
16:00:23 <dons> http://haskell.org/haskellwiki/Hac4
16:00:23 <lambdabot> Title: Hac4 - HaskellWiki
16:00:39 <byorgey> tensh: note, all id = and
16:00:54 <faxathisia> :t and . zipWith (>) x (tail x)
16:00:55 <dons> ?check \xs -> all id xs == and xs
16:00:55 <lambdabot>     Couldn't match expected type `[a]' against inferred type `Expr'
16:00:55 <lambdabot>     In the second argument of `zipWith', namely `x'
16:00:55 <lambdabot>     In the second argument of `(.)', namely `zipWith (>) x (tail x)'
16:00:56 <lambdabot>  OK, passed 500 tests.
16:01:06 <faxathisia> :t \x -> and . zipWith (>) x (tail x)
16:01:07 <lambdabot>     Couldn't match expected type `[Bool]' against inferred type `Bool'
16:01:07 <lambdabot>       Expected type: [[Bool]]
16:01:07 <lambdabot>       Inferred type: [Bool]
16:01:20 <faxathisia> :t \x -> and (zipWith (>) x (tail x))
16:01:21 <lambdabot> forall a. (Ord a) => [a] -> Bool
16:01:36 <Qerub> Right, all id = and. Thanks!
16:01:55 <faxathisia> > let increasingNumbers x = and (zipWith (>) x (tail x)) in increasingNumbers [1,2,3,1,2,4,5,6,4,3,2,7,8,4,7,9,10]
16:01:55 <lambdabot>  False
16:01:57 <byorgey> oh, hehe, s/tensh/Qerub/ =)
16:02:00 <faxathisia> > let increasingNumbers x = and (zipWith (>) x (tail x)) in increasingNumbers [1,2,3]
16:02:01 <lambdabot>  False
16:02:04 <faxathisia> huh
16:02:10 <tensh> byorgey: figured :)
16:03:03 <BMeph> > let increasingNumbers x = and (zipWith (>) x (tail x)) in increasingNumbers [3,2,1]
16:03:04 <lambdabot>  True
16:03:20 <BMeph> > let increasingNumbers x = and (zipWith (<) x (tail x)) in increasingNumbers [1,2,3]
16:03:21 <lambdabot>  True
16:05:32 <ziman> @type split
16:05:33 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
16:05:53 <ziman> wow :)
16:05:56 <ziman> laziness rocks :)
16:07:25 <Igloo> That's not related to laziness
16:09:19 <Igloo> It's something like    let (n, g') = random g in (mkGen n, g')   except probably cleverer than that
16:10:44 <byorgey> > let increasingNumbers = and . ap (zipWith (<)) tail in increasingNumbers [1,2,3]
16:10:45 <lambdabot>  True
16:10:48 <wagle_home> is there a fold that takes more than one list, or a zip that returns a monad other than lists?
16:11:04 <gnuvince_> :t ap
16:11:05 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
16:11:52 <Qerub> More code to scrutinize… What would you change in http://pastie.caboo.se/165444?
16:11:53 <lambdabot> Title: #165444 - Pastie
16:12:04 <byorgey> wagle_home: there's Foldable, not sure if that's what you're looking for
16:12:17 <wagle_home> @instances Foldable
16:12:17 <lambdabot> Couldn't find class `Foldable'. Try @instances-importing
16:12:42 <faxathisia> :t count
16:12:43 <lambdabot> Not in scope: `count'
16:13:55 <Qerub> This "proportion $ countBools $ map isBouncy [0..]" flow feels pretty awkward...
16:14:30 <Qerub> By the way, the code solves http://projecteuler.net/index.php?section=problems&id=112.
16:14:31 <lambdabot> Title: Problem 112 - Project Euler
16:15:18 <byorgey> Qerub: doesn't proportion result in division by zero?
16:15:26 <byorgey> I guess it doesn't if you never look at that value =)
16:17:06 <byorgey> Qerub: you can also implement digits in a sort of "cheating" way as  digits = map digitToInt . show
16:17:25 <byorgey> I don't know how the speed compares though
16:18:25 <Qerub> byorgey: Yes, I get a NaN there. Good catch.
16:18:43 <Qerub> I'll "benchmark".
16:18:46 <byorgey> Qerub: in general, though, I think it looks pretty good =)
16:19:05 <Qerub> Thank you! :)
16:20:30 <wagle_home> byorgey, dont think so, but interesting!
16:21:13 <hpaste>  dfranke pasted "This shouldn't hang, right?" at http://hpaste.org/6350
16:21:18 <byorgey> wagle_home: heh. well, what are you trying to do?
16:21:29 <dfranke_> ^^^ but it does
16:23:25 <Qerub> byorgey: Thank you for your help.
16:23:28 <Qerub> Good night everybody!
16:23:41 <byorgey> bye Qerub!
16:23:42 <wagle_home> > True >> False
16:23:43 <lambdabot>  Couldn't match expected type `m a' against inferred type `Bool'
16:23:56 <dfranke_> Somebody want to tell me I'm stupid before I report this as a GHC bug?
16:30:29 <Igloo> dfranke_: It might be caused by a deadlock caused by the lock for a handle
16:31:25 <dfranke_> Igloo: I don't see why that would be since only one thread should be using any given handle...
16:31:35 <dfranke_> Igloo: but is that a bug in the runtime regardless?
16:32:01 <wagle_home> try making the test input foo\n
16:32:30 <dfranke_> wagle_home: still hanging.
16:32:47 <dfranke_> wagle_home: but pipes aren't line-buffered anyway unless they're connected directly to a terminal.
16:33:03 <wagle_home> was thinking maybe cat was
16:33:17 <dfranke_> cat just uses stdio I assume.
16:33:31 <pastorn> @hoogle FilePath -> ByteString
16:33:31 <lambdabot> No matches, try a more general search
16:33:31 <dfranke_> at the syscall level everything is block-buffered.
16:33:36 <Igloo> dfranke_: Ah, looks like it might be this: http://hackage.haskell.org/trac/ghc/ticket/1936
16:33:38 <lambdabot> Title: #1936 (When lazy IO blocks, it blocks the whole runtime) - GHC - Trac
16:33:43 <wagle_home> try a very long input
16:33:44 <dfranke_> Igloo: yes, I reported that.
16:33:44 <pastorn> @hoogle FilePath -> [Word8]
16:33:44 <lambdabot> No matches, try a more general search
16:33:56 <Philippa> pastorn: you shouldn't expect to find functions of those types
16:33:56 <dfranke_> Igloo: it's supposed to be fixed.  I'm using a snapshot build.
16:34:02 <Philippa> @hoogle FilePath -> IO ByteString
16:34:02 <lambdabot> Data.ByteString.readFile :: FilePath -> IO ByteString
16:34:02 <lambdabot> Data.ByteString.Char8.readFile :: FilePath -> IO ByteString
16:34:02 <lambdabot> Data.ByteString.Lazy.readFile :: FilePath -> IO ByteString
16:34:09 <pastorn> right
16:34:15 * pastorn didn't really think...
16:34:45 <pastorn> i was just thinking of what i wanted, not what i could expect
16:35:11 <pastorn> which one of these do i want? are they the same?
16:35:19 <Igloo> dfranke_: OK, well, if you make a ticket then we can look into it properly
16:35:56 <dfranke_> Igloo: doing so now.  I just wanted someone to check my sanity first.
16:44:09 <wagle_home> dfranke_, can you flush output before getcontents?
16:44:41 <dfranke_> wagle_home: that's cat's job, not mine.
16:45:26 <dfranke_> but cat will do so and exit as soon as it reads an EOF.
16:45:53 <olsner> hey! lambdabot's repo man quote is wrong
16:46:01 <olsner> "The more you drive, the less intelligent you are"
16:46:27 <olsner> is what I just heard said in the movie
16:46:30 <whee> hrm, I can't get HAppS-Data to build: ghc-6.8.2: internal error: R_X86_64_PC32 relocation out of range: (noname) = 0x7c10d7d28
16:46:36 <wagle_home> i got burned long long ago by not doing a flush, and its the only hammer i got left
16:47:52 <dfranke_> wagle_home: yeah, I've learned my lessons about buffering over many years with much pain.
16:48:04 <dfranke_> wagle_home: but I think I've got it down cold now, and this is supposed to work.
16:48:53 <wagle_home> forking processes in haskell is new to me..  thanks for the intro..  8)
16:48:57 <dfranke_> but it was indeed very unsettling the first time I got different output from a program if I piped it to less.
16:50:45 <dons> whee: yikes
16:50:55 <dons> whee: looks like a ghc bug
16:51:40 <whee> dons: I had to apply the patch attached here to use ghci: http://hackage.haskell.org/trac/ghc/ticket/2013
16:51:41 <lambdabot> Title: #2013 (ghci crash on startup: R_X86_64_32S relocation out of range.) - GHC - Tra ...
16:51:47 <dfranke_> dons: there seems to be a festival of those today...
16:51:47 <dons> ah right
16:51:52 <whee> but there seems to be a problem with template haskell
16:52:16 <allbery_b> huh, I associate that error with attempts to mix 64-bit and 32-bit libraries
16:52:16 <lambdabot> allbery_b: You have 1 new message. '/msg lambdabot @messages' to read it.
16:52:49 <whee> allbery_b: my system is entirely 64-bit, so that seems unlikely
16:53:49 <allbery_b> ...unless it's a ghc-created object / library that's inappropriately 32-bit
16:54:26 <whee> perhaps
16:54:48 <allbery_b> (or, if you used a vendor package to install ghc and/or libraries, that the vendor mis-tagged a 32-bit library build as 64-bit)
16:58:24 <whee> I don't see anything related to ghc as 32-bit
16:58:24 <dfranke_> y'know, out of all the bugs in the past year or so that have taken me more than an hour to diagnose, I think the majority have turned out to be compiler bugs.
16:58:58 <dfranke_> apparently I'm the sort of programmer that breaks compilers.  I'm not sure whether that's good or bad.
17:01:06 <oerjan> it's good for the rest of us :)
17:01:35 <whee> I guess I'll give the latest darcs version a shot
17:04:02 <tibbe> how do I convince cabal-install to also install the profiling version of a library I already have installed? Adding -p doesn't help
17:04:21 <dons> so configure with -p
17:04:27 <dons> then build and install will generate both
17:04:43 <tibbe> dons: ah yes but I'm trying to do cabal install -p bytestring
17:04:48 <tibbe> I can do it manually for sure
17:04:54 <dons> right. so it needs to happen at configure time
17:04:56 <dons> not install time
17:05:00 * tibbe wonders if that will confuse cabal-install
17:05:06 <dons> oh, hmm, cabal-install
17:05:07 <dons> i see.
17:05:10 <dons> sorry,  yeah.
17:05:14 <tibbe> :)
17:05:17 <dons> i think that needs a newer cabal-install
17:05:27 <tibbe> I have the newest!
17:05:41 <tibbe> with a brand new bug, cabal upgrade doesn't work anymore
17:06:19 <whee> tibbe: I thought I was nuts when it stopped doing what I thought it should do :P
17:06:40 <tibbe> whee: it is /very/ suprising
17:09:48 <tibbe> reinstalling bytestring by hand and configuring using -p didn't help either!
17:10:50 <whee> tibbe: I just updated cabal and cabal-install and upgrade seems to work now
17:11:01 <dons> c -p works for me with bytestring
17:11:13 <tibbe> hmm
17:11:15 <tibbe> weird
17:12:50 <tibbe> dons: I did downloaded the library from hackage, unpackes, c -p --user --prefix, c b, c install, no worky
17:13:08 <tibbe> dons: also tried ghc-pkg unregister first
17:13:36 <tibbe> dons: no wait, it did!
17:13:45 <tibbe> dons: it's complaining about a new library now, sorry
17:14:46 <tibbe> whee: not here, darcs pull -a didn't give me any new patches, do you pull from darcs.haskell.org?
17:15:22 <dons> for bytestring ?
17:15:57 <whee> tibbe: mmm, it is apparently still broken. It updated a couple of things, but then the same brokenness the second time
17:16:08 <tibbe> ah ok
17:16:09 <whee> maybe the HAppS failure did something :|
17:16:16 <tibbe> probably when there's nothing left to upgrade
17:18:22 <wferi> Hi! What concept is the "predicate and" function defined as: p1 `pAnd` p2 = \o -> p1 o && p2 o
17:19:44 <mauke> what do you mean by "concept"?
17:19:59 <tibbe> :t and
17:20:00 <lambdabot> [Bool] -> Bool
17:20:10 <mauke> :t liftM2 (&&)
17:20:11 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m Bool -> m Bool
17:20:15 <wferi> I don't know exactly, but I have the feeling that it must have a name.
17:20:27 <wferi> Yes, like that.
17:20:33 <mauke> it's && lifted to ((->) e)
17:21:00 <wferi> Thanks, that's already good enough for me.
17:21:22 <mauke> :t liftM2 (&&) (> 0)
17:21:23 <lambdabot> forall a. (Ord a, Num a) => (a -> Bool) -> a -> Bool
17:23:24 <Cin> > 'a' > 'b'
17:23:25 <lambdabot>  False
17:27:09 <BMeph> That was fun - just tried my own version of that Project Euler problem. It's much easier to conceptualize than my current "tasker". :)
17:29:04 <BMeph> I used a lot more of the Monad libs than Qerub, but I basically wrote the same program.
17:29:31 <wferi> In which module is the reader monad instance?
17:30:00 <BMeph> ... I always use "Control.Monad.Reader," myself. :)
17:30:30 <wferi> thanks.
17:30:40 <BMeph> You bet. :)
17:32:29 <dons> wow, did people know about the project to rewrite the fedora bootscripts in haskell?
17:32:42 <dons> ""I don't know if I like python in particular for this roll (maybe something like Haskell that has proven to be light and quick as well as nicer to deal with)"
17:33:00 <mauke> somehow that sounds like a bad idea to me
17:33:22 <wferi> I heard about it quite some time ago. I wonder where they get with that.
17:33:37 <dons> worked for linspire.
17:33:51 <dons> seriously, using interpreted stuff for critical, and needs-to-be-correct boot code?
17:34:07 <mauke> seriously, using a language that can't create processes?
17:34:11 <dons> statically typed, compiled, pure. exactly what you need in state situation
17:34:25 <dons> that's not a property of the language...
17:34:46 <mauke> I just want a working forkProcess :-(
17:34:58 <dons> execve is where you need ti
17:35:09 <wferi> how is it not working?
17:35:36 <dons> also, they want to do things with all their cores
17:36:18 <TomMD> dons: do you have a link/
17:36:20 <TomMD> ?
17:36:41 <mauke> wferi: http://haskell.org/ghc/docs/latest/html/libraries/unix/System-Posix-Process.html#2
17:36:43 <dons> https://www.redhat.com/archives/fedora-devel-list/2008-January/msg00484.html
17:36:45 <lambdabot> Title: Re: Init : someone could comment this ?, http://tinyurl.com/3ck677
17:36:45 <lambdabot> http://tinyurl.com/obhpz
17:36:58 <dons> via fedora weekly news, http://lwn.net/Articles/265149/
17:36:58 <lambdabot> Title: Fedora Weekly News Issue 115 [LWN.net]
17:37:00 <TomMD> If only we could get the xen tools away from python and into some Haskell goodness.
17:38:07 <wferi> ugh, that ugly warning was new to me.
17:38:44 <Cin> giveRaiseToFirst = update (salary . fst) (+100)
17:38:49 <Cin> functional references are sooo cool
17:38:53 <Cin> does anyone know how old this page is? http://twan.home.fmf.nl/blog/haskell/overloading-functional-references.details
17:38:55 <lambdabot> Title: Overloading functional references - 21 thoughts, http://tinyurl.com/2ustba
17:38:56 <orzo> How do i use foreign export dynamoic?
17:39:09 <orzo> ghc is complaining about the use of the word "dynamic"
17:39:24 <orzo> is it an option to the compiler?
17:39:39 <mauke> -fffi
17:40:03 <orzo> doesn't work.
17:40:28 <orzo> i already have {-# LANGUAGE ForeignFunctionInterface #-} at the top
17:40:31 <solrize> > Just 3 >> Just 5 >> Just 6
17:40:32 <lambdabot>  Just 6
17:40:37 <solrize> > Just 3 >> Just 5 >> Nothing >> Just 6
17:40:38 <lambdabot>  Nothing
17:40:48 <solrize> > Left 3 >> Left 4
17:40:48 <lambdabot>  Add a type signature
17:41:01 <solrize> > (Left 3 >> Left 4) :: Either Int Int
17:41:03 <lambdabot>   add an instance declaration for (Error Int)
17:41:04 <lambdabot>     In the expression: (Left 3 ...
17:41:13 <solrize> huh?
17:41:25 <mauke> orzo: wait, export?
17:41:30 <mauke> what is that supposed to do?
17:41:56 <Botje> solrize: Error Int is not a valid instance.
17:41:56 <solrize> dons, wow, i wonder if that's a lindows influence
17:42:05 <Botje> Either e is a monad if Error e exists
17:42:18 <orzo> it is supposed to make a function that transforms a Haskell function into a C function pointer
17:42:23 <Botje> > Left "meow" >> Right 5
17:42:24 <solrize> botje ohhhh, thanks, this starts to make sense now
17:42:26 <lambdabot>  Left "meow"
17:42:35 <Botje> > Right 5 >> Right 3 >> Right 42
17:42:35 <mauke> orzo: I can't find that in the FFI spec
17:42:36 <lambdabot>  Add a type signature
17:42:47 <Botje> > Right 5 >> Right 3 >> Right 42 :: Either String Int
17:42:48 <lambdabot>  Right 42
17:42:59 <SamB> mauke: oh, it's in there
17:43:02 <orzo> http://www.haskell.org/hdirect/ffi-11.html
17:43:03 <Botje> by convention, Left signals an error
17:43:03 <lambdabot> Title: A Haskell foreign function interface: Exposing Haskell functions: Exposing Haske ...
17:43:09 <SamB> mauke: would that it were a bit different
17:43:11 <orzo> it must be an extension to the spec
17:43:12 <Botje> and Right is a useful result
17:43:18 <SamB> orzo: nope!
17:43:22 <orzo> i also see it in GHC docs
17:43:28 <SamB> orzo: maybe you just didn't do it right
17:43:35 <SamB> what did you write?
17:43:35 <chessguy> @bot
17:43:35 <lambdabot> :)
17:43:50 <solrize> botje, yeah, i didn't realize that the error had to be in a special typeclass.  i kept seeing mention of the Either monad and couldn't understand why Left Int didn't work
17:44:02 <solrize> my function actually has an enumeration type for its error codes
17:44:06 <orzo> foreign export dynamic exportHandler :: ( Bool -> Ptr CChar -> CSize ) -> IO Addr
17:44:13 <solrize> so i have to make that an instance of the Error typeclass ?
17:44:17 <Botje> yes
17:44:30 <mauke> orzo: I only see foreign import ccall "wrapper" mkCallback :: IO () -> IO (FunPtr (IO ()))
17:44:30 <SamB> I know it's in the FFI spec, because it's the one form that Jhc doesn't support...
17:44:33 <chessguy> @bot
17:44:33 <lambdabot> :)
17:44:37 <travisbrady_> is there an easy way to make ghc make use of more than one core?
17:44:38 <Botje> haven't done so before, so don't ask me what error requires :)
17:44:44 <solrize> thanks, the light bulb is coming on :)
17:44:53 <dons> travisbrady_: easy? use threads, compile with -threaded
17:44:57 <dons> use +RTS -N2
17:45:01 <dons> or more
17:45:10 <travisbrady_> dons: i've been poking around your blog re: just that topic
17:45:11 <gnuvince_> @hoogle mask7
17:45:11 <lambdabot> No matches found
17:45:25 <SamB> see, the feature is there!
17:45:34 <orzo> maybe it was in an earlier edition of the FFI spec
17:45:38 <travisbrady_> dons: but I've gotta rework the code a bit to use forkIO right?
17:45:42 <SamB> orzo: same feature
17:46:04 <dons> travisbrady_: right. a lighter alternative is to use `par` and learn about Control.Parallel
17:46:06 <orzo> i dont understand what you are trying to tell me, samb
17:46:21 <dons> then the code doesn't need reworking, but its hard to pick a good parallel evaluation strategy
17:46:43 <orzo> take a look at http://www.haskell.org/hdirect/ffi-11.html and tell me how to do that with modern ghc
17:46:44 <lambdabot> Title: A Haskell foreign function interface: Exposing Haskell functions: Exposing Haske ...
17:46:45 <Botje> solrize: http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Error-Class.html#t%3AError
17:46:47 <lambdabot> http://tinyurl.com/2ly45m
17:46:56 <hpaste>  travisbrady pasted "Counting unique things can this be parallelized?" at http://hpaste.org/6351
17:47:03 <SamB> foreign import ccall "wrapper" exportHandler :: ( Bool -> Ptr CChar -> CSize ) -> IO (Ptr ( Bool -> Ptr CChar -> CSize ))
17:47:30 <orzo> hm
17:47:38 <SamB> er, possibly s/Ptr/FunPtr/
17:47:41 <travisbrady_> warning on that paste i'm a total newbie
17:47:43 <SamB> yes.
17:47:59 <mauke> orzo: http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffise4.html#x7-190004.1.3
17:48:01 <lambdabot> Title: 4 Specification of External Entities, http://tinyurl.com/2pdya4
17:48:53 <SamB> orzo: this way has the advantage of being typechecked, too
17:49:13 <travisbrady_> dons: does anything in what I pasted stand out as being easily parallelizable?
17:49:40 <dons> travisbrady_: map
17:49:46 <dons> you can always use parMap instead of map
17:49:52 <dons> from Control.Parallel.Strategies
17:49:55 <dons> but it might not win anything.
17:50:05 <dons> you usually have to think about how to parallelise
17:50:09 <travisbrady_> dons: ohhhhhhh! i'll try just for fun
17:50:47 <orzo> thanks
17:55:14 <wagle_home> @yow
17:55:14 <lambdabot> I am a traffic light, and Alan Ginzberg kidnapped my laundry in 1927!
17:56:24 <dmwit> There's nothing in all-caps in that sentence!
17:56:26 <dmwit> Try again.
17:56:29 <dmwit> ?yow!
17:56:29 <lambdabot> Now I think I just reached the state of HYPERTENSION that comes JUST
17:56:29 <lambdabot> BEFORE you see the TOTAL at the SAFEWAY CHECKOUT COUNTER!
17:56:49 <dmwit> ?yarr!
17:56:49 <lambdabot> Is that a hornpipe in yer pocket, or arr ya just happy ta see me?
17:59:42 <wagle_home> how'd you know i needed all caps?
18:01:44 <dmwit> Getting enough caps is the only way to stay regular.
18:01:54 <dmwit> EAT TOTAL
18:02:17 <dmwit> </weirdo>
18:08:26 <SamB> hmm, how do I jump to pattern match error locations...
18:08:52 <dmwit> Do you not have a line number, somehow?
18:09:01 <dmwit> oh
18:09:06 <dmwit> run-time errors, huh?
18:09:19 <SamB> *** Exception: FrontEnd/Class.hs:(417,4)-(435,55): Non-exhaustive patterns in function f
18:09:31 <dmwit> hahahahahahaha
18:09:33 <SamB> compilation-shell-minor-mode is not able to cope with this
18:09:51 <dmwit> 19 lines of error
18:09:55 <dmwit> Pretty impressive. =)
18:10:05 <SamB> what?
18:10:08 <SamB> 19 lines?
18:10:15 <dmwit> > 435 - 417 + 1
18:10:16 <lambdabot>  19
18:10:29 <SamB> that just means the function is 19 lines long
18:10:36 <dmwit> (Yes, I know there's probably just one line of error.  It's a joke.)
18:10:37 <SamB> and none of the patterns match
18:10:59 <SamB> actually the error is caused by lines that are missing
18:11:00 <dmwit> Sorry, I should be less gleeful about your misery.
18:11:21 <SamB> oh well, apparantly I'm already at the error's location
18:11:36 <SamB> but I wish I could get emacs to get along with GHC on this matter...
18:15:40 <orzo> hm
18:16:05 <orzo> another follow up to my previous question.  I needed to use freeHaskellFunctionPtr to free the closure in the old style
18:16:17 <orzo> what's the new way?
18:16:35 <SamB> orzo: does that still work?
18:16:38 <orzo> no
18:16:44 <orzo> it says it's an undefined symbol
18:16:50 <SamB> @hoogle FunPtr
18:16:50 <lambdabot> Foreign.Ptr.FunPtr :: data FunPtr a
18:16:50 <lambdabot> GHC.Exts.FunPtr :: data FunPtr a
18:16:50 <lambdabot> GHC.Exts.FunPtr :: Addr# -> FunPtr a
18:16:59 <SamB> @hoogle freeF
18:17:00 <lambdabot> No matches found
18:17:03 <SamB> @hoogle freeH
18:17:03 <lambdabot> Foreign.Ptr.freeHaskellFunPtr :: FunPtr a -> IO ()
18:17:04 <mauke> @hoogle freeHaskellFunPtr
18:17:05 <lambdabot> Foreign.Ptr.freeHaskellFunPtr :: FunPtr a -> IO ()
18:17:25 <orzo> i am freeing it from C
18:17:48 <SamB> orzo: well, does the HsFFI.h declare a function for that?
18:18:33 <orzo> it declares hs_free_fun_ptr( HsFunPtr fp)
18:19:01 <orzo> guess i'll just assume it's the same
18:19:15 <SamB> yeah
18:19:29 <SamB> can't see what else it could be!
18:19:58 <ehird>  @hoogle free
18:20:06 <ehird> @hoogle Ptr a -> IO ()
18:20:06 <lambdabot> Foreign.Marshal.Alloc.free :: Ptr a -> IO ()
18:20:06 <lambdabot> Foreign.ForeignPtr.addForeignPtrFinalizerEnv :: FinalizerEnvPtr env a -> Ptr env -> ForeignPtr a -> IO ()
18:20:06 <lambdabot> System.IO.hPutBuf :: Handle -> Ptr a -> Int -> IO ()
18:20:14 <ehird> @hoogle a -> Ptr a
18:20:14 <lambdabot> No matches, try a more general search
18:20:17 <ehird> darn
18:20:33 <mauke> @hoogle with
18:20:34 <lambdabot> Foreign.Marshal.Utils.with :: Storable a => a -> (Ptr a -> IO b) -> IO b
18:20:34 <lambdabot> Foreign.ForeignPtr.withForeignPtr :: ForeignPtr a -> (Ptr a -> IO b) -> IO b
18:20:34 <lambdabot> System.IO.withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
18:21:52 <dainanaki> What's the most up to date binding for the OS X Cocoa libraries?
18:22:33 <dmwit> I doubt there even is one.
18:22:43 <dmwit> Haskell is pretty proud of its cross-platform bindings...
18:22:49 <dainanaki> yes true
18:23:06 <dmwit> Even the "unix" package works on Windows. =)
18:23:13 <dainanaki> but gtk+ on os x can be finicky at times since it's running in the X11 server
18:23:32 <dmwit> Although Google proves me wrong.
18:24:11 <dmwit> http://hoc.sourceforge.net/
18:24:12 <lambdabot> Title: HOC: A Haskell to Objective-C Binding
18:24:13 <dainanaki> i know they are out there, I'm just not sure which ones would actually even work with Leopard since a lot of the efforts seem to be rather old
18:24:18 <dmwit> Looks like that is basically the only choice.
18:32:38 <chessguy> @quote
18:32:38 <lambdabot> Entropy says: I agree; we need to remove Emacs' ridiculous dependency on a kernel being present
18:33:10 <chessguy> M-x bypass-kernel
18:33:19 <chessguy> @quote macs
18:33:19 <lambdabot> shachaf says:  monochrom: Emacs is also a joke. :-)
18:33:58 <monochrom> haha
18:34:05 <chessguy> @quote macs
18:34:05 <lambdabot> sorear says: [emacs haskell mode] not fucked up, just well documented
18:34:48 <monochrom> @quote joke
18:34:49 <lambdabot> shachaf says:  monochrom: Emacs is also a joke. :-)
18:34:51 <monochrom> @quote joke
18:34:52 <lambdabot> shachaf says:  monochrom: Emacs is also a joke. :-)
18:34:59 <monochrom> @quote joke
18:34:59 <lambdabot> shachaf says:  monochrom: Emacs is also a joke. :-)
18:35:06 <monochrom> ok, that's the only one?
18:35:24 <monochrom> I wonder what was the joke before that.
18:37:27 <wagle_home> people put at least two of my quotes in, and a week or two ago, there was only one left
18:38:01 <chessguy> @quote wagle_home
18:38:01 <lambdabot> No quotes match. Where did you learn to type?
18:38:37 <Japsu> perhaps quotes decay if they don't get lol'd at often enough
18:38:41 <SamB> @quote wagle
18:38:41 <lambdabot> wagle says: wagle: in the end all entities die. dont bother living.  lambdabot: thread killed
18:38:48 <SamB> @quote wagle
18:38:48 <lambdabot> wagle says: wagle: in the end all entities die. dont bother living.  lambdabot: thread killed
18:38:49 <SamB> @quote wagle
18:38:50 <lambdabot> wagle says: wagle: in the end all entities die. dont bother living.  lambdabot: thread killed
18:38:52 <SamB> @quote wagle
18:38:52 <lambdabot> wagle says: wagle: in the end all entities die. dont bother living.  lambdabot: thread killed
18:39:37 <vincenz> that'll be enough
18:39:41 <NatLWalker> ...
18:41:02 <Japsu> bah, it's night in Europe, no-one's using the channel for anything useful anyway
18:41:51 <wagle_home> sun's still up here..  8-p
18:41:55 <Japsu> in the absence of signal, noise prevails
18:57:40 <dcoutts> @seen tibbe
18:57:40 <lambdabot> I saw tibbe leaving #haskell-soc, #darcs, #xmonad, #ghc and #haskell 1h 6m 12s ago, and .
19:01:23 <SamB> @type unfoldr
19:01:24 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
19:01:39 <doctormach> Does anyone have an idea about why Data.IntMap would be many times slower than Data.Map?
19:02:05 <SamB> no!
19:03:21 <doctormach> Are they for different purposes or are they meant for the same thing?
19:03:23 <allbery_b> normally it's not.  strictless?
19:03:27 <allbery_b> er, strictness
19:03:34 <allbery_b> IntMap is a specialization of Map
19:03:49 <doctormach> I don't think so, there doesn't appear to be much difference in memory use
19:04:23 <hpaste>  doctormach pasted "IntMap slowness" at http://hpaste.org/6352
19:04:43 <allbery_b> hm, what version of ghc (and, if appropriate, the collections library)?  someone might have broken something along the way
19:05:04 <TomMD> Has anyone seen an application claim to "over thirty years of experience programming Haskell"?  If so, thats when we know Haskell has failed to avoid success.
19:05:08 <allbery_b> IntMap certainly *used* to be faster (and a bit smaller; think the keys are unlifted) than Map
19:05:20 <doctormach> It's 6.8.2
19:05:33 <doctormach> OS X 10.5 x86
19:09:27 <solrize> most of the ghc libraries are missing from the source distro -- is there a way to do a complete installation from source?
19:11:13 <ecks> hey, is there a way to declare a type which uses a class, such as fractional?
19:11:28 <ecks> or must it only be data constructor?
19:11:37 <TomMD> solrize: You are probably talking about installing from source + installing the ghc-extras package, I am guessing.
19:11:42 <monochrom> solrize: add the "extralibs" source tarball
19:11:47 <solrize> tommd, hmm, not sure
19:11:50 <solrize> ok i'll try that
19:12:20 <solrize> extralibs is just 1.9MB and the src tar is 6.7MB
19:12:26 <solrize> as compared to the binary distro which is around 40MB
19:12:27 <solrize> hmm
19:12:31 <solrize> sounds like a lot is still missing?
19:13:45 <solrize> ok, got the tarball, it extracted into ghc-6.8.2, not sure if that's good or not
19:13:46 <monochrom> The compiler itself is larger than the libraries, yes, when counting source code.
19:14:05 <TomMD> ecks: Not sure what you want.  You know of polymorphic types, yes?  (func :: (Fractional a) => a -> Bool).  If you are asking about replacing a data constructor in the type declaration with a generalized something then no, I don't think you can do that.
19:14:11 <solrize> i can go into that dir and type "make" again even though the compiler is already built?
19:15:17 <monochrom> I don't think anyone has tried that.  Usually everyone unpacks both tarballs before building.
19:15:24 <solrize> seems to be going ok
19:15:45 <TomMD> I think the makefiles are actually pretty smart - I've built things in all sorts of bad orders.
19:16:16 <ecks> TomMD: what i meant was that that if i want to make my own type, such as "type Value = (type which is instance of Num)" would i be able to do that?
19:17:25 <TomMD> ecks: Oh, not that I know of, no.  I'd give it a trivial test case and if the compiler complains without suggesting a Glasgow extension then I'd consider that a final answer.
19:17:26 <solrize> Language/Haskell/Parser.hs:3712:1:
19:17:26 <solrize>     Warning: Pattern match(es) are overlapped
19:17:26 <solrize>              In a case alternative: _ -> ...
19:18:00 <ecks> yeah, i think i found it in the haskell wikibooks
19:18:16 <ecks> http://en.wikibooks.org/wiki/Haskell/Classes_and_types
19:18:17 <lambdabot> Title: Haskell/Classes and types - Wikibooks, collection of open-content textbooks
19:18:42 <ecks> does anyone know why data constructors are allowed but not types?
19:19:38 <dcoutts> dons: seen Simon's update frame patch? does that fix the testcase you found?
19:20:43 <monochrom> That warning should be harmless.
19:23:32 <dejones> ?seen Cale
19:23:32 <lambdabot> Cale is in #ghc, #haskell-overflow and #haskell. I last heard Cale speak 5h 19m 47s ago.
19:23:46 <dmwit> solrize: You may have covered all the possible patterns, or have two _ patterns.
19:23:58 <solrize> that wasn't from something i wrote, it was from building ghc
19:24:24 <dmwit> ah
19:24:40 <dmwit> ecks: Where?
19:25:07 <dmwit> oh
19:25:35 <dmwit> I'm not sure there's a deep reason behind that; it's just a decision you have to make one way or the other.
19:28:18 <dejones> Anyone familiar with memoization in Haskell?  I'm trying to apply memoization to the Ackermann function to help me learn to use memoization in Haskell...  I found some code with Fibonacci, but I can't seem to get it to work with the Ackermann function.
19:28:22 <hpaste>  dejones pasted "Ackermann memoization issues.." at http://hpaste.org/6353
19:29:49 * dejones hears crickets chirping.... silence in the room... heh.
19:30:53 <dmwit> dejones: Check your types.
19:30:59 <dmwit> dejones: They aren't what you think.
19:31:24 <dejones> dmwit: hmm..  yah, I'm clearly not understanding how the memoization functions work...
19:31:25 <dmwit> dejones: In particular, the bounds you are supplying to "dp" aren't right: you need both a lower and an upper bound on m/n.
19:31:32 <monochrom> http://www.haskell.org/haskellwiki/Dynamic_programming_example  may help.
19:31:33 <lambdabot> Title: Dynamic programming example - HaskellWiki
19:31:39 <dmwit> Like so: "dp ((0, 0), (m, n)) ack m n".
19:31:52 <dejones> dmwit: I see.
19:32:01 <dmwit> "dp (a, b)" means memoize the function for values between "a" and "b".
19:32:29 <dmwit> (So, it doesn't mean memoize the function for the variables "a" and "b".)
19:32:38 <dejones> dmwit: Ahhhh.
19:35:33 <dons> dcoutts: haven't tested against head
19:35:43 <dcoutts> dons: 'k
19:35:45 <dejones> dmwit: different error now...
19:36:30 <dmwit> ack, sorry
19:36:35 <dmwit> I wrote it wrong.
19:36:51 <dmwit> Well, the basic idea is that you need "ack" to be curried.
19:36:57 <dmwit> so:
19:37:02 <hpaste>  dejones annotated "Ackermann memoization issues.." with "Ackermann memoization issues.." at http://hpaste.org/6353#a1
19:37:24 <hpaste>  ecks pasted "(no title)" at http://hpaste.org/6354
19:37:33 <dmwit> ack rec (0, n) = ...
19:37:51 <dmwit> ackermann_mem m n = dp ((0, 0), (m, n)) ack (m, n)
19:38:01 <ecks> hello, for some reason, i get an error when I try to make TableMove an instance of Eq, i get a kind error
19:38:04 <dmwit> dejones: Do you follow?
19:38:32 <dejones> dmwit: we are changing the parameters to ack so it uses the pair since we are using pairs are our arguments to dp?
19:38:48 <dmwit> ecks: instance Eq a => Eq (TableMove a) where ...
19:38:48 <dejones> that way it can treat the pair as a single calculation of ackermann?
19:38:58 <dmwit> dejones: correct
19:39:11 <dejones> :)
19:39:13 <dejones> dmwit: thanks
19:39:45 <ecks> dmwit: actually, i want a to be in the Fractional class
19:40:03 <dejones> dmwit: I'm getting the same error still... see hpaste
19:40:14 <ecks> may i just write "instance Fractional a => Eq (TableMove a) where..."
19:40:29 <solrize> can someoen tell me again how to use Either as a monad?
19:40:29 <dmwit> ecks: Yes, if Fractional implies Eq.
19:40:56 <dmwit> dejones: Can you paste the updated code, too?
19:40:58 <hpaste>  (anonymous) annotated "Ackermann memoization issues.." with "(no title)" at http://hpaste.org/6353#a2
19:41:01 <dejones> oops
19:41:04 <dmwit> heh
19:41:05 <dejones> yea, it's there
19:41:20 <dmwit> > Left 3 >> Right 5 -- solrize: ?
19:41:21 <lambdabot>  Add a type signature
19:41:32 <dmwit> > Left 3 >> Right 5 :: Either Int Int
19:41:32 <lambdabot>   add an instance declaration for (Error Int)
19:41:33 <lambdabot>     In the expression: Left 3 >...
19:41:36 <dmwit> ah
19:41:47 <dmwit> > Left "HEY!" >> Right 5 :: Either String Int
19:41:48 <lambdabot>  Left "HEY!"
19:42:05 <solrize> > Right 3 >> Right 5
19:42:06 <lambdabot>  Add a type signature
19:42:10 <dmwit> solrize: The Left constructor needs to take an Error instance.
19:42:16 <solrize> > Right 3 >> Right 5 :: Either String Int
19:42:17 <lambdabot>  Right 5
19:42:27 <solrize> right, so I put in an instance error declaration
19:42:27 <solrize> sec
19:42:45 <hpaste>  solrize pasted "this doesn't typecheck" at http://hpaste.org/6355
19:43:10 <dmwit> dejones: "rec" must also take one argument, via the same transformation.
19:43:36 <dejones> dmwit: oops, didn't update the recursive calls ;)
19:44:05 <dmwit> solrize: It's ambiguous, right?
19:44:26 <dmwit> solrize: Give an explicit type-signature in there.
19:44:52 <dmwit> Also, it doesn't complain about "instance Error What"?  That surprises me.
19:44:56 <hpaste>  (anonymous) annotated "this doesn't typecheck" with "(no title)" at http://hpaste.org/6355#a1
19:45:10 <solrize> it didn't complain abotu that but adding the annotation didn't help
19:45:19 <dmwit> What error do you get?
19:45:33 <solrize> either.hs:6:20:
19:45:33 <solrize>     No instance for (Monad (Either What))
19:45:33 <solrize>       arising from a do statement at either.hs:6:20-26
19:45:33 <solrize>     Possible fix: add an instance declaration for (Monad (Either What))
19:45:58 <SamB> do you have Control.Monad.Error imported?
19:46:35 <hpaste>  dejones annotated "Ackermann memoization issues.." with "Ackermann memoization issues.. bad results." at http://hpaste.org/6353#a3
19:46:37 <dejones> dmwit: heh, well it runs now, so that's an improvement, but it returns 2 for all Ackermann (m, n).
19:46:46 <dmwit> solrize: import C.M.Error, as SamB said.
19:46:46 <solrize> import Control.Monad.Error.Class
19:46:49 <solrize> oh ok
19:46:50 <solrize> lemme try that
19:47:16 <solrize> that works!  thanks!!!!
19:47:29 <dmwit> dejones: heh
19:51:58 <dejones_> dmwit: hello, sorry got disconnected...
19:51:59 <dejones_> :(
19:52:03 <dmwit> =/
19:52:08 <dejones_> yea, sucks
19:52:15 <dejones_> computer completely locked up on me
19:52:17 <dmwit> I'm not really sure how to help with the final bug, sorry. =P
19:52:31 <dejones_> lol
19:55:03 <dejones_> dmwit: yea, it seems that the paris (m,n) as arguments seem to screw up the calculation.
19:55:25 <dmwit> Really?  How?
19:55:53 <dmwit> If you just pass "ack" to "fix" instead of "dp (...)", does it still fail?
19:56:13 <wy> Are there evidences that "everything is an object" is wrong? I have the hunch, but I haven't a formal proof for that
19:56:20 <dejones_> dmwit: what is "fix" ?
19:56:23 <dmwit> :t fix
19:56:24 <lambdabot> forall a. (a -> a) -> a
19:56:34 <dmwit> dp is fix with memoization.
19:56:37 <dejones_> oh..
19:56:42 <monochrom> How can there be a formal proof?
19:56:44 <dejones_> dmwit: I did not know that.
19:56:50 <dmwit> :t fix :: ((a -> b) -> (a -> b)) -> (a -> b)
19:56:50 <lambdabot> forall a b. ((a -> b) -> a -> b) -> a -> b
19:57:16 <dejones_> ?src fix
19:57:16 <lambdabot> fix f = let x = f x in x
19:57:18 <monochrom> "everything is an object" is not wrong, just stupid.
19:57:19 <wy> monochrom: I don't know. Maybe just some convincing arguments
19:57:24 <dejones_> dmwit: what do I need to import for fix?
19:57:30 <dejones_> :/
19:57:41 <dmwit> nothing?
19:57:44 <dmwit> ?index fix
19:57:44 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
19:57:46 <wy> and not merely a feel
19:57:59 <dmwit> Oh, apparently Control.Monad or any of its descendents
19:58:47 <dejones_> dmwit: nope, fix works.  ;)
19:58:59 <dmwit> What!
19:59:02 <dejones_> yep!
19:59:09 <dejones_> crazy!
19:59:33 <solrize> > fix cos
19:59:34 <lambdabot>  Exception: <<loop>>
20:00:06 <dmwit> > fix (1:)
20:00:07 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
20:00:14 <dejones> ?
20:00:44 <dmwit> And you don't get an out-of-bounds error or anything?
20:00:49 <dmwit> Something doesn't add up here.
20:00:56 <dmwit> Paste the most recent version of your code?
20:01:55 <dejones> ok
20:03:04 <dejones> hpaste going slooow
20:03:32 <byorgey> I just noticed that too
20:03:38 <byorgey> hope it wasn't me =)
20:05:00 <dejones> hmm, hpaste may be down?
20:05:09 <dmwit> ?where hpastetwo
20:05:09 <lambdabot> I know nothing about hpastetwo.
20:05:09 <byorgey> seems to be back to normal now
20:05:13 <hpaste>  dejones annotated "Ackermann memoization issues.." with "Ackermann memoization.. fix works.  ;)" at http://hpaste.org/6353#a4
20:05:15 <dejones> ok worked
20:07:01 <dmwit> I get an error in array index.
20:07:07 <dejones> odd
20:07:23 <dmwit> I don't think (m,n) is the right upper bound for Ackermann.
20:07:30 <dejones> dmwit: quite possibly
20:07:45 <dejones> since n+1... n should grow
20:08:20 <dmwit> Worse is the "rec _ (rec (m, n-1))" case. ;-)
20:08:25 <dejones> dmwit: it seems fix is smart.  ;)
20:08:33 <monochrom> To compute the right upper bound, first you have to compute the Ackermann function...
20:08:35 <dmwit> fix doesn't use an array.
20:08:43 <dejones> dmwit: what does it use?
20:08:48 <dmwit> dejones: Nothing!
20:08:50 <dejones> monochrom: lol, yea...
20:08:53 <dejones> dmwit: huh?!
20:08:54 <monochrom> recursion. plain dumb recursion.
20:08:56 <dmwit> ?src fix
20:08:56 <lambdabot> fix f = let x = f x in x
20:09:07 <dejones> dmwit: no memoization? lol
20:09:18 <dmwit> No!  That's why we have to write "dp" manually.
20:09:22 <dejones> haha
20:09:29 <dejones> ok ok
20:09:33 <monochrom> http://www/vex.net/~trebla/haskell/fix.xhtml
20:09:38 <monochrom> oops
20:09:43 <monochrom> http://www.vex.net/~trebla/haskell/fix.xhtml
20:10:01 <dmwit> dejones: For small values of the ackermann function, just replace the bounds in ackermann_mem.
20:10:26 <dmwit> Something like "ackermann_mem m n = dp ((0, 0), (30, 100000)) ack (m, n)" or something.
20:10:32 <dejones> dmwit: hahah
20:10:44 <dmwit> It will fail as soon as you try to go outside those bounds, but that's the price you pay for memoization.
20:10:50 <dejones> yeah...
20:11:16 <dejones> can we do like, "(m, )" for the upper bound?
20:11:27 <dmwit> Not really.
20:11:37 <dejones> > (1, )
20:11:37 <lambdabot>  Parse error at ")" (column 5)
20:11:38 <dmwit> The Array needs to know how much space to allocate.
20:11:48 <dmwit> > (,) 1 -- a function
20:11:49 <lambdabot>  Add a type signature
20:11:59 <dmwit> :t (,) 1
20:12:00 <lambdabot> forall t b. (Num t) => b -> (t, b)
20:12:02 <dejones> dmwit: I was hoping the laziness would just grow the array bounds as needed...
20:12:13 <dmwit> Sorry, that's not what laziness means. =P
20:12:17 <dejones> hehe
20:12:34 <dmwit> Arrays are "spine-strict".
20:12:54 <dmwit> Many useful data-structures are spine-strict.
20:13:38 <wagle_home> all those darn boxes!  unbox them all!
20:13:45 <orzo> hello
20:13:49 <monochrom> I like boxes.
20:13:59 <orzo> i'm calling a haskell function from c
20:14:05 <orzo> and the c code prints many messages
20:14:10 <orzo> and teh haskell function prints a message
20:14:18 <orzo> but they aren't showing in the right sequence apparently
20:14:21 <monochrom> Are they spam?
20:14:39 <orzo> the haskell messages seem to gather together and then dump all at once
20:14:51 <orzo> they're debug messages
20:14:55 <monochrom> the haskell RTS has its own buffer.
20:15:20 <orzo> i see
20:15:20 <monochrom> and of course, the C RTS has its own buffer too.
20:15:20 <dmwit> Maybe mark your C functions as "safe" or whatever?
20:15:29 <orzo> well, can i flush the buffer?
20:15:32 <dmwit> Oh, I guess that won't help in this case, huh.
20:15:34 <dmwit> :t flush
20:15:35 <lambdabot> Not in scope: `flush'
20:15:37 <dmwit> :t hFlush
20:15:38 <lambdabot> Not in scope: `hFlush'
20:15:42 <dmwit> bwuh?
20:15:48 <monochrom> The Haskell side is hFlush.  The C side is flush.
20:15:49 <dmwit> ?hoogle Handle -> IO ()
20:15:49 <lambdabot> System.IO.hClose :: Handle -> IO ()
20:15:49 <lambdabot> System.IO.hFlush :: Handle -> IO ()
20:15:49 <lambdabot> GHC.ConsoleHandler.flushConsole :: Handle -> IO ()
20:16:03 <orzo> well c flushes after \n
20:16:11 <orzo> haskell apparnetly doesn't
20:16:28 <monochrom> oops, the C side is fflush
20:16:49 <wagle_home> hehe..  my first guess is always flush
20:16:57 <orzo> ?hoogle stdOut
20:16:57 <lambdabot> System.IO.stdout :: Handle
20:16:57 <lambdabot> Distribution.Simple.Utils.rawSystemStdout :: Verbosity -> FilePath -> [String] -> IO String
20:16:57 <lambdabot> Distribution.Simple.Program.rawSystemProgramStdout :: Verbosity -> ConfiguredProgram -> [ProgArg] -> IO String
20:17:04 <glguy>  debugging messages should be going out stderr
20:17:07 <glguy> which isn't buffered
20:17:10 <glguy> iirc..
20:17:22 <dmwit> Depends how you wrote your debugging messages, I guess.
20:17:29 <dmwit> Or do you mean as a policy kind of thing?
20:17:34 <glguy> that
20:17:54 <glen_quagmire> there is SetBuffering or something
20:18:00 <glen_quagmire> :t SetBuffering
20:18:01 <lambdabot> Not in scope: data constructor `SetBuffering'
20:18:16 <glguy> hSetBuffering
20:18:30 <dmwit> :t zipWith4
20:18:31 <lambdabot> forall a b c d e. (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]
20:18:32 <glen_quagmire> hSetBuffering stdout NoBuffering -- might do orzo
20:18:36 <dmwit> Wow.
20:18:43 <dmwit> It actually exists.
20:18:52 <glen_quagmire> up to zipWith5 i think
20:19:00 <dmwit> ?pl \f x -> f x x x x
20:19:00 <lambdabot> join . join . join
20:19:05 <dejones> dmwit: this is really really weird... if I don't make my array big enough, it gives me almost all of the correct answer but leaves off the largest digit, like (4, 1) it gives 5535 instead of 65535.... can you say, wtf?
20:19:10 <dejones> is that not weird or what?
20:19:11 <wagle_home> :t zip
20:19:12 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
20:19:21 <wagle_home> :t zipWith
20:19:22 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
20:19:24 <dmwit> dejones: Try importing Data.Array instead of Array.
20:19:30 <dmwit> dejones: Maybe you're getting an old version of Array.
20:19:33 <wagle_home> :t (.)
20:19:33 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
20:19:50 <glguy> fail
20:19:52 <wagle_home> hmmm...
20:20:05 <dejones> dmwit: same thing with Data.Array...
20:20:10 <dmwit> weird
20:20:14 <dejones> dmwit: Loading package array-0.1.0.0 ... linking ... done.
20:20:18 <dejones> is that an old version?
20:20:20 <glguy> I think that Cale is doing that to . and ++
20:20:34 <wagle_home> @hoogle (Functor f) => (a -> b -> c) -> f a -> f b -> f c
20:20:34 <lambdabot> Prelude.flip :: (a -> b -> c) -> b -> a -> c
20:20:34 <lambdabot> Data.Function.flip :: (a -> b -> c) -> b -> a -> c
20:20:34 <lambdabot> Data.Function.on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
20:20:46 <dejones> dmwit: that is the version on haskell.org, it seems
20:20:51 <dejones> in the API.
20:20:56 <dejones> http://haskell.org/ghc/docs/latest/html/libraries/
20:21:05 * dmwit shrugs
20:21:20 <dejones> dmwit: think I should post this to the haskell-cafe...?  maybe a compiler bug?
20:21:32 <dmwit> I don't know, post it here again.
20:21:39 <dmwit> Maybe somebody else has more of a clue than me. =)
20:21:43 <dejones> heh, ok
20:21:45 <dejones> 1 sec
20:21:46 <dmwit> :t ap
20:21:46 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
20:21:57 <dmwit> :t sequence
20:21:58 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
20:22:07 <orzo> hmm
20:22:14 <orzo> i added a call to hFlush stdout after every print
20:22:21 <orzo> and it is still behaving as before
20:22:55 <monochrom> Does the C code use the result of the Haskell code?
20:23:33 <orzo> no
20:23:49 <monochrom> Then, how do you know when is the Haskell code run?
20:24:20 <hpaste>  dejones annotated "Ackermann memoization issues.." with "Ackermann memoization... very weird output." at http://hpaste.org/6353#a5
20:24:21 <orzo> i put a print in c just before calling out to haskell and a print in haskell at the entry point
20:24:27 <wy> wagle_home: Do you understand syntax-cases?
20:24:41 <gwern> I am feeling aimless and dispirited. is there a cure in haskell for what ails me?
20:24:47 <orzo> i see the c prints and then i see the haskell prints, and they don't interleave like i expected
20:24:48 <dejones> dmwit: I added comments to show the test cases.
20:24:55 <cjb> gwern:
20:24:55 <wagle_home> wy: probably
20:24:56 <dmwit> ?faq I am feeling aimless and dispirited. is there a cure in haskell for what ails me?
20:24:56 <lambdabot> The answer is: Yes! Haskell can do that.
20:24:56 <dejones> anyone else get the same output?
20:24:56 <cjb> @faq
20:24:56 <lambdabot> The answer is: Yes! Haskell can do that.
20:25:16 <monochrom> My next hypothesis is threading.
20:25:18 <wy> wagle_home: I haven't figured out what datum->syntax is doing
20:25:19 * gwern feels a little less dispirited; that joke never gets old
20:26:32 <monochrom> Could you re-code something so that the C code uses something from the Haskell code?
20:26:36 <wy> had a trauma at #scheme today... so... sorry I always digress
20:27:04 <dejones> anyone else try my code from my hpaste?  I am getting very odd output from ghci.
20:27:35 <monochrom> gwern: do you want a new form of the joke?
20:27:42 <dejones> hello _dolio.  :)
20:28:08 <orzo> i added both hFlush after print and a call to hSetBuffering stdout NoBuffering
20:28:15 <orzo> still, no effect
20:28:51 <dolio> Eh?
20:28:57 <dmwit> orzo: Have you considered the possibility that everything is working correctly?
20:29:12 <dmwit> Maybe those prints really occur in that order.
20:29:19 <wagle_home> wy, sounds like a wadler-ism.. (after my time)..  where do you see this?
20:29:24 <orzo> i see
20:29:25 <dejones> hey dolio, just saying hi.  I'm having some weird output if you want to take a look.  :)
20:29:38 <dolio> Heh. All right.
20:29:44 <orzo> are function calls buffered by the RTS too?>
20:29:55 <nordius> :t itag
20:29:56 <lambdabot> Not in scope: `itag'
20:30:00 <orzo> i expect a function to execute immediately when i call it from c
20:30:04 <hpaste>  dejones annotated "Ackermann memoization issues.." with "Ackermann memoization... very weird output." at http://hpaste.org/6353#a6
20:30:09 <wy> wagle_home: kent's chapter in "beautiful code"
20:30:14 <dejones> dolio: there you go, hpaste
20:30:28 <dejones> see test cases in the comments at the bottom.
20:30:28 <SamB> @faq can I has oracle?
20:30:28 <lambdabot> The answer is: Yes! Haskell can do that.
20:30:36 <dmwit> orzo: Hmm.  I'm not sure what you mean, but calls to C code are just as lazy as every other IO action.
20:30:45 <dmwit> orzo: (which is to say, not very lazy)
20:31:03 <orzo> i'm calling form C to a haskell closure
20:31:13 <orzo> via a wrapper
20:31:17 <wagle_home> url, or book?
20:31:18 <orzo> that the FFI generated
20:31:19 <wagle_home> wy
20:32:15 <dejones> dolio: odd stuff, eh?
20:32:16 <SamB> orzo: well, what type does the function have?
20:32:24 <orzo> which
20:32:29 <SamB> the one you are calling from C
20:32:30 <orzo> the pointer i'm using in c?
20:32:31 <dejones> dmwit: did ya try it ?
20:32:40 <dmwit> no...
20:32:45 <SamB> what is the Haskell type
20:32:47 <wy> wagle_home: http://www.cs.indiana.edu/~dyb/pubs/bc-syntax-case.pdf
20:33:01 <dejones> dmwit: :P
20:33:22 <dolio> > let ack 0 n = n + 1 ; ack m 0 = ack (m-1) 1 ; ack m n = ack (m-1) (ack m (n-1)) in ack 4 1
20:33:24 <dmwit> I gave up after all the type errors went away, that's as much debugging as I'm capable of. =P
20:33:24 <orzo> ypedef void HaskellHandler( bool isOutgoing, char *p, size_t len );
20:33:28 <lambdabot> Terminated
20:33:33 <adu> how do I pass something from Haskell to Python?
20:33:39 <dmwit> adu: via C
20:33:42 <adu> ic
20:33:45 <dolio> > let ack 0 n = n + 1 ; ack m 0 = ack (m-1) 1 ; ack m n = ack (m-1) (ack m (n-1)) in ack 0 0
20:33:46 <lambdabot>  1
20:34:02 <dejones> dmwit: lol, thanks for the help... definitely helped my understanding.  :)
20:34:25 <dmwit> adu: http://wiki.python.org/moin/PythonVsHaskell
20:34:26 <lambdabot> Title: PythonVsHaskell - PythonInfo Wiki
20:34:34 <gwern> monochrom: what new form are you proposing?
20:34:47 <monochrom> @hackage Ail
20:34:48 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Ail
20:34:48 <wy> wagle_home: It's not quite readable. I guess I need to find something else
20:35:17 <adu> dmwit: interesting...
20:35:17 <monochrom> perhaps should be Aile
20:35:35 <dejones>  > let ack 0 n = n + 1 ; ack m 0 = ack (m-1) 1 ; ack m n = ack (m-1) (ack m (n-1)) in ack 3 1
20:35:55 <hpaste>  orzo pasted "stdout still appears buffered" at http://hpaste.org/6356
20:36:05 <gwern> monochrom: heh. is that library good for what ails ya?
20:36:21 <dejones> > (+) 1 2
20:36:24 <lambdabot>  3
20:36:31 <dejones> > let ack 0 n = n + 1 ; ack m 0 = ack (m-1) 1 ; ack m n = ack (m-1) (ack m (n-1)) in ack 3 1
20:36:32 <lambdabot>  13
20:36:33 <monochrom> Yes :)
20:36:50 <dejones> ack 4 1 would take lambdabot some time....  heh
20:37:02 <orzo> http://hpaste.org/6356
20:37:16 <orzo> that's my haskell code
20:37:17 <gwern>  > let ack 0 n = n + 1 ; ack m 0 = ack (m-1) 1 ; ack m n = ack (m-1) (ack m (n-1)) in ack 4 1
20:37:52 <orzo> I call makeHandler from C to get a function pointer that points to smtpHandler
20:38:15 <dejones> gwern: does it work when you put the space before the >
20:38:16 <dejones> ?
20:38:22 <dejones> I didn't think it did...
20:38:26 <dmwit> no
20:38:31 <gwern> > let ack 0 n = n + 1 ; ack m 0 = ack (m-1) 1 ; ack m n = ack (m-1) (ack m (n-1)) in ack 4 1
20:38:35 <dejones> lol
20:38:37 <lambdabot> Terminated
20:38:39 <dejones> haha
20:38:40 <gwern> bah! Nazi science sneers at spaces
20:38:50 <solrize> > do { [1,2]; 3 <- 4; [5] }
20:38:50 <lambdabot>   add an instance declaration for (Num [t])
20:38:50 <lambdabot>     In a 'do' expression: 3 <- 4
20:38:50 <lambdabot> ...
20:38:51 <dejones> gwern: lambabot is a quitter.
20:39:00 <dejones> or lambdabot, rather
20:39:01 <solrize> > do { [1,2]; 3 <- 4::Int; [5] }
20:39:02 <lambdabot>  Couldn't match expected type `[t]' against inferred type `Int'
20:39:03 <gwern> dejones: it terminated it - with extreme prejudice
20:39:07 <dmwit> > do { [1, 2]; 3 <- [4]; [5] }
20:39:07 <lambdabot>  []
20:39:13 <solrize> wow, just wow.
20:39:19 <dmwit> yup =)
20:39:25 <dmwit> > let 1 = 2 in 1 + 1
20:39:25 <lambdabot>  2
20:39:26 <dejones> dolio: any luck with the Ackermann stuff?
20:39:33 <dejones> that output really confuses me.
20:39:50 <dolio> Yeah, I don't know. That looks weird.
20:39:56 <dmwit> > do { [1, 2]; 4 <- [4]; [5] } -- huh
20:39:57 <lambdabot>  [5,5]
20:40:05 <dolio> I'd expect array index errors or something.
20:40:22 <dejones> dolio: yea, that's what dmwit expected.  I guess I could post it to haskell-cafe?
20:40:36 <dmwit> solrize: It's actually not so surprising, now that I think about it: that's just pattern matching.
20:40:37 <dejones> Let the compiler "experts" crunch on it? ;) heh
20:40:40 <wagle_home> wy: my model is this (i started the same place they did, but i wandered on my own, so may differ): programs usually start as strings..  strings get read in to produce data structures in memory called s-expressions, but strings are NOT the only source of s-expressions.  when you have a pointer pointing to an s-expression, and wish to compile it, as if it were a program, then the s-expression data-structure needs to be parsed
20:40:40 <wagle_home>  into "syntax"..  now my concept of syntax is that of a different sort of datastructure..  in the past, i have gotten the impression that dybvig (and wadler) view syntax as s-expressions "painted" as syntax (ie, s-expressions that are certified as parseable, or somesuch)
20:40:44 <dolio> Not a bdad idea.
20:40:50 <dmwit> solrize: The "let 1 = 2" thing is much more surprising to me. =)
20:40:51 <dejones> dolio: yea.. thanks for trying.  :)
20:40:54 <solrize> > let 3=4 in 5
20:40:55 <lambdabot>  5
20:41:04 <dejones> dmwit: thanks again for helping with the type issues.  :)
20:41:11 <dmwit> suer
20:41:21 <solrize> well i thought pattern match failure was supposed to throw an error
20:41:30 <dmwit> No, it calls "fail".
20:41:44 <dmwit> > do { Nothing <- Just (Just 3); Just 5 }
20:41:45 <lambdabot>  Nothing
20:41:58 <dmwit> > do { Nothing <- Just Nothing; Just 5 }
20:41:59 <lambdabot>  Just 5
20:42:10 <dmwit> > do { fail "pattern match"; Just 5 }
20:42:11 <lambdabot>  Nothing
20:42:26 <wagle_home> wy..  but i never figured out exactly what dybvig was calling syntax was
20:42:35 <orzo> ok, i just need a flush in c just before entering haskell
20:42:42 <orzo> and haskell flushes
20:42:45 <orzo> it works now
20:42:51 <dmwit> solrize: Errr, to be more specific: pattern match failures call "fail" when it's in a monad, and call "error" when it's in a function definition.
20:43:31 <solrize> they are different somehow?
20:43:47 <dmwit> Very different.
20:43:49 <glguy> also , the let binding is lazy
20:43:55 <wagle_home> wy ..  i skimmed the first half od wadler's dissertation before it fell off the back of my desk or something 8-9 years ago)
20:44:34 <glguy> > let Just x = Nothing in 5
20:44:34 <lambdabot>  5
20:44:36 <glguy> > let Just x = Nothing in x
20:44:36 <lambdabot>   Irrefutable pattern failed for pattern Data.Maybe.Just x
20:44:47 <wagle_home> he was painting different levels of syntax or something..  colors representing scope, maybe, i think
20:45:07 <wy> wagle_home: did you mean philip wadler?
20:45:07 <solrize> let 3=x in x
20:45:10 <solrize> > let 3=x in x
20:45:11 <lambdabot>  x
20:45:15 <solrize> heh
20:45:26 <wagle_home> damn, no, sorry...  waddell
20:45:30 <wagle_home> wy
20:45:31 <glguy> solrize: let 3=x doesn't affect x
20:45:32 <monochrom> Hrm, need to flush C before calling Haskell. That's odd.
20:45:33 <wy> haha
20:45:46 <glen_quagmire> > let 3=xxx in xxx
20:45:46 <lambdabot>   Not in scope: `xxx'
20:45:56 <glguy> :t x
20:45:57 <wy> wagle_home: got it. maybe I'll get by skipping a section
20:45:57 <lambdabot> Expr
20:46:14 <monochrom> The defined names are a, b, c, ... , z
20:46:23 <glen_quagmire> > let 3*x = 6 in x
20:46:24 <lambdabot>  x
20:46:30 <wagle_home> macros are probably the most interesting thing about scheme
20:46:33 <glen_quagmire> > let 3*xx = 6 in xx
20:46:33 <lambdabot>   Not in scope: `xx'
20:47:00 <wagle_home> "programs are data structures"
20:47:07 <lament> the most interesting thing about scheme is SICP
20:47:11 <gwern> data are programs
20:47:29 <glen_quagmire> shouldn't  this be possible?    let (3+x) = 6 in xx   ?
20:47:30 <gwern> hm. 'pedant cat says: data are programs'
20:47:43 <gwern> or is that too subtle?
20:47:55 <wagle_home> "data are programs are data are programs are data are programs ..."
20:48:14 <dmwit> glen_quagmire: That doesn't bind xx to anything.
20:48:16 <gwern> @wn data
20:48:17 <lambdabot> *** "data" wn "WordNet (r) 2.0"
20:48:17 <lambdabot> data
20:48:17 <lambdabot>      See {datum}
20:48:17 <lambdabot>  
20:48:17 <lambdabot> *** "data" wn "WordNet (r) 2.0"
20:48:18 <lambdabot> [9 @more lines]
20:48:24 <dmwit> > let 3 + x = 6 in 3 + 5
20:48:25 <lambdabot>  6
20:48:25 <lament> wagle_home: it's a pretty trivial identity, you have to admit.
20:48:27 <gwern> data is plural right?
20:48:37 <lament> wagle_home: i mean, that's the whole point of Von Neumann architecture.
20:48:46 <wagle_home> haskell programs arent data, except in template haskell
20:48:57 <dmwit> False.
20:49:01 <lament> everything is data
20:49:04 <gwern> lament: if it was so trivial, would von neumann have gotten the architecture named after himself?
20:49:09 <lament> it's a computer you're dealing with
20:49:26 <lament> gwern: computers are not trivial. But in the context of a computer, "code is data" is trivial.
20:49:30 <wy> wagle_home: I heard that template haskell treat program as a special type
20:49:55 <wagle_home> wy there are datastructures in template haskell to represent programs
20:50:34 <wy> wagle_home: yes. I guess it's much like something like data Expr = Var ... ?
20:51:20 <wagle_home> i keep not finding a month to really dive into template haskell
20:51:24 <wy> wagle_home: so the program can't be type check before it's expanded
20:51:24 <gwern> lament: dunno. isn't babbage remembered for suggesting that his computing machiens might operate on their own instructions?
20:51:28 <monochrom> One compiler's data is another computer's code.
20:51:38 <adu> what exactly is this template haskell yur talkin about?
20:52:20 <wy> adu: It's some kind of syntactic abstraction system for haskell
20:52:26 <SamB> monochrom: ???
20:52:27 <gwern> adu: scary stuff. don't use it if you don't have to
20:52:27 <wy> I wonder if anyone is using it
20:52:33 <wagle_home> s/computer/blackbox/g
20:52:47 <monochrom> It's a joke.
20:52:48 <solrize> happs uses it
20:52:56 <solrize> it turns haskell into lisp ;)
20:53:02 <gwern> wy: oh, it gets used in places, and sometimes quite neatly. Igloo has an old mandelbrot generator which used TH for some interesting optimizations
20:53:34 <wagle_home> yeah, how DARE template haskell turn pristine syntax into...  UGH... data!
20:54:01 <SamB> but it only does it inside quasiquotation brackets
20:54:25 <adu> gwern: so thats the difference between template Haskell, and just using a type-class, isn't that why type-classes were invented?
20:55:05 <adu> oh are you talking about Liskell?
20:55:14 <gwern> adu: I don't know how you can even compare type classes and template haskell, so I will forbear from further comment
20:55:23 <adu> ok
20:55:24 <wy> adu: that's different thing. for example you might be able to use a syntactic abstraction to create a do notation if we don't already have one, without changing GHC
20:55:40 <SamB> wy: not really
20:55:54 <wy> SamB: I know it can't ;)
20:56:01 <wy> that's just an analogy
20:56:12 <adu> oic
20:56:35 <SamB> you COULD use it to create, say, mdo
20:56:35 <wy> SamB: Is TH mainly used as a code generator?
20:56:43 <wagle_home> i dont speak for others, but i would use template haskell (or macros in scheme) to write dsl "compilers" that automatically re-target to the current version of the underlying machine/compiler (eg, haskell or scheme)
20:56:56 <SamB> wy: it's not good for much else
20:57:02 <mauke> I use TH to run code at compile time
20:57:18 <SamB> well, yes, you CAN use it for that
20:57:22 <adu> that is TH?
20:57:30 <adu> s/that/what/
20:57:41 <adu> oooo TH is template haskell
20:57:42 <SamB> I've used it to crash GHCi
20:57:45 <adu> ic now
20:57:53 <adu> it all makes sense
20:58:10 <wy> Can it destructure input code?
20:58:20 <SamB> by generating somewhat large list literaals
20:58:36 <SamB> wy:if you pass it in [| |], yes
20:58:45 <wagle_home> i did do this in scheme, and the birth of hygiene completely stopped me from building my own programs (creating my own lexical scopes)..  i could not write the program (lambda (x) x), because it would automagically convert the two x's to be different symbols..
20:58:48 <adu> thats not large
20:59:17 <wy> SamB: That's weird. How is [| |] type checked?
21:00:26 <SamB> I don't remember whether any typechecking is done before splicing
21:00:58 <lament> the idea of DSLs is a little iffy
21:01:14 <wy> :t ([|)
21:01:15 <lambdabot> parse error on input `|'
21:01:33 <wy> :t ([| 42 |])
21:01:34 <lambdabot> parse error on input `|'
21:01:54 <lament> it's no accident that mainstream languages don't have advanced macros
21:01:59 <wy> SamB: so it has some special compiler support
21:02:16 <adu> lament: why do you say that?
21:02:25 <lament> (discounting perl as being too weird in general)
21:02:28 <SamB> wy: certainly!
21:02:40 <SamB> and lambdabot doesn't support parsing TH, incidentally
21:02:53 <lament> adu: it's questionable whether the pros outweigh the cons.
21:03:09 <wy> so [| |] will parse the code into expressions I guess
21:03:13 <SamB> so even if, by some chance, TH were still turned on in the GHC flags, the brackets wouldn't work
21:03:17 <adu> lament: are you talking about hygenic macros specifically?
21:03:25 <lament> adu: no, just macros
21:03:31 <SamB> wy: into ExprQ, or Q Expr
21:03:32 <adu> but macros are easy
21:03:37 <wagle_home> obsessive-compulsive macros
21:03:42 <adu> just pass some text through cpp or m4
21:04:02 <lament> cpp is hardly "advanced", and its use is mostly discouraged
21:04:15 <adu> but then you said "just macros"
21:04:18 <lament> and m4 is not quite mainstream
21:04:20 <SamB> where Q is a stand-in for an arbitrary monad implementing a particular class (yes, there is a type called Q, but it is just an existential...)
21:04:24 <adu> what you mean if you don't mean "just macros"?
21:04:39 <lament> adu: i meant powerful macros that you can actually use for building DSLs
21:05:05 <adu> like Scheme's (syntax-rules ...)?
21:05:11 <lament> sure
21:05:23 <adu> ya those are nice
21:05:31 <adu> although I like the way Mathematica does it
21:05:38 <lament> or like lisp's defmacro, they don't have to be hygienic
21:05:39 <SamB> eh????
21:05:50 <adu> which coincidently is similar to how scheme does it
21:06:00 <wagle_home> sometimes you want hygiene..  just not all the time
21:06:08 <SamB> mathematica seems to do a LOT with substitution...
21:06:29 <dfranke_> wagle_home: you sound like you're channeling Paul Graham :-)
21:06:33 <wagle_home> but i think hygiene is misnamed..  causes too much religious fervor
21:06:52 <lament> yes, they should have been called "righteous" instead
21:06:56 <adu> ya I have no idea what hygenic means, now that I think about it
21:06:56 <wagle_home> i dont know what paul graham is going on about..
21:06:59 <dcoutts> dons: ping
21:07:05 <lament> adu: "clean"
21:07:20 <adu> something involving namespaces or bindings or something...
21:07:25 <SamB> adu: you know, like using deoderent every day
21:07:32 <adu> lament: m4 macros are "clean" in my view
21:07:36 <lament> adu: bindings don't get shadowed by stuff in the macro
21:07:48 <dfranke_> basically it means that lexical symbols inside a macro can't leak into the calling environment.
21:07:49 <wagle_home> throwing out obsessive-compulsive macros is like throwing the baby out with the bath water..  obsessive-compulsive macros were a very important discovery..
21:07:56 <lament> er, they do get shadowed
21:08:02 <wagle_home> ... just misnamed quite a tad
21:08:04 <lament> but the other way doesn't work
21:09:24 <wagle_home> its when you want to modularize the building of new lexical scopes that obsessive-compulsive macros fall down
21:10:45 <wagle_home> those are big systems of macros..  made possible by the power of things like extend-syntax..  but things like extend-syntax make eugene rightly wonder about beta-substition...
21:11:03 <dcoutts> SyntaxNinja: ping
21:11:15 <wagle_home> the disaster is that people think  obsessive-compulsive macros are the ONLY way to do macros
21:11:15 <dcoutts> @localtime dons
21:11:17 <lambdabot> Local time for dons is Thu Mar 13 21:11:16 2008
21:12:19 <wagle_home> .. but as i said, they are very important..  all i can tell about paul graham is that he want to throw them out, "just because"
21:14:02 <gwern> how does localtime work? does it work on whois data or did dons provide his timezone at some point?
21:14:22 <wagle_home> when i constructed my large system of macros, i did have techniques for avoiding inadvertant name collisions, but those techniques were nothing like beta-substition..
21:14:51 <mauke> @localtime gwern
21:15:51 <wagle_home> shapr (i think) had a database of various people's latitude and longitude, and a picture of the globe with marks for each person
21:15:59 <wagle_home> @localtime wagle
21:16:08 <mauke> @localtime wagle_home
21:16:08 <lambdabot> Local time for wagle_home is Thu Mar 13 21:16:08
21:16:23 <gwern> @localtime lambdabot
21:16:23 <lambdabot> I live on the internet, do you expect me to have a local time?
21:16:33 <wagle_home> <mauke> @localtime wagle_home
21:16:33 <wagle_home> * Received a CTCP TIME from lambdabot
21:16:53 <wagle_home> there ya go
21:17:14 <wagle_home> lambdabot just knows who to ask
21:17:20 <gwern> ah. my client is set to block that sorta thing, which explains the silence
21:17:36 <wagle_home> uh uh..
21:17:51 * wagle_home suddenly feels big target on his back
21:18:30 <gwern> why, Perry Wagle your IP is showing!
21:19:59 <adu> so foncused
21:20:15 <adu> s/foncused/confused/
21:21:09 <dcoutts> dons, SyntaxNinja: I've sent you a note
21:21:46 * dcoutts :: IO Sleep
21:22:07 <wagle_home> \
21:22:16 <wagle_home> x <- dcoutts
21:22:45 <wagle_home> x <- dcoutts ; waglize x
21:22:53 <adu> wakeUp dcoutts >>= unsafePerformIO
21:23:06 <dcoutts> aaarg!
21:23:12 <wagle_home> o.O
21:23:54 <mauke> instance Monad Dream
21:24:18 <mauke> you can't just go Dream a -> a and take something out of a dream
21:24:36 <mauke> but join :: Dream (Dream a) -> Dream a is ok because you can have dreams inside dreams
21:24:52 <gwern> mauke: are you imlpying that one can never awake from a dream?
21:24:53 <gwern> scary
21:25:03 <mrd> what happens in monads, stays in monads
21:25:11 <adu> lol
21:25:12 <wagle_home> typeFix Dream
21:25:13 <mauke> you can, but it won't let you keep dream objects
21:25:25 <adu> instance Monad Vegas
21:25:27 <gwern> the first rule of FP club is, you don't parody fight club
21:26:07 <mauke> the first rule of fix club is "the first rule of fix club is "the first rule of fix cl
21:26:33 <bos> @remember mauke the first rule of fix club is "the first rule of fix club is "the first rule of fix cl
21:26:33 <lambdabot> It is stored.
21:26:49 <bos> mauke: that's brilliant.
21:26:53 <adu> wouldn't it be " ... \" ... \\" ... \\\\" ...
21:27:14 <Apocalisp> What is the asymptotic upper bound for the magnitude of a program that can determine the asymptotic upper bound for the magnitude of any program?
21:27:28 <wagle_home> > fix "1"
21:27:28 <lambdabot>  Couldn't match expected type `a -> a'
21:27:29 <mauke> :-)
21:27:42 <mrd> magnitude of a program?
21:27:47 <wagle_home> > fix ("1":)
21:27:48 <lambdabot>  ["1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1"...
21:27:52 <Apocalisp> complexity of the algorithm
21:27:52 <mrd> like how brightly it shines?
21:28:00 <mauke> > fix (("the first rule of fix club is " ++) . show)
21:28:01 <lambdabot>  "the first rule of fix club is \"the first rule of fix club is \\\"the first...
21:28:01 <Apocalisp> like how long it will run
21:28:06 <mrd> what is the upper bound? infinity, undecidable probably
21:28:13 <wagle_home> > fix (shows "1")
21:28:14 <lambdabot>  "\"1\"\"1\"\"1\"\"1\"\"1\"\"1\"\"1\"\"1\"\"1\"\"1\"\"1\"\"1\"\"1\"\"1\"\"1\"...
21:28:26 <wagle_home> > putStr $ fix (shows "1")
21:28:27 <lambdabot>  <IO ()>
21:28:29 <mauke> > fix show
21:28:29 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
21:28:35 <lekro> Apocalisp: isn't that a variant of the halting problem, i.e., there is no such program in the first place?
21:28:36 <adu> Apocalisp: well I would think it would have to at least be n = the number of nodes in an AST that represents a program
21:29:02 <wagle_home> > show $ fix show
21:29:03 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
21:29:19 <adu> wierd
21:29:21 <dejones> hey dmwit and dolio: I got an answer to the GHC weirdness for the Ackermann function with the Array memoization...   "Exceptions raised by array-related operations. (NOTE: GHC currently does not throw ArrayExceptions)."  from http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html
21:29:22 <lambdabot> http://tinyurl.com/sqmlj
21:29:31 <dejones> :
21:29:31 <wagle_home> darn..  i wanna print, which gets rid of the outer quotes at least
21:29:31 <dejones> :)
21:29:42 <Apocalisp> lekro: Yes, you're right. It is the halting problem.
21:30:29 <adu> Apocalisp: so has it been proven to be at least n?
21:30:55 <lekro> Apocalisp: wait, did you say *least* upper bound or just upper bound?
21:31:12 <adu> asymptotic
21:31:18 <lekro> still
21:31:32 <lekro> you could always return the definition of the busy beaver function
21:31:46 <wagle_home> its easy to paint "halting problem" on everything
21:31:57 <mrd> sure is, Rice's theorem :)
21:32:09 <adu> or you could make a type
21:32:46 <Apocalisp> lekro: The upper bound, such that no input will cause the algorithm to use more resources than the bound (memory or time, either way).
21:32:51 <adu> data HaltSolution = Halting f | NonHalting f;
21:33:08 <lekro> Apocalisp: well, what about the busy beaver function?
21:33:37 <adu> and the upperbound = O(1)
21:33:39 <lekro> isn't that an upper bound of any algorithm?
21:34:58 <Apocalisp> lekro: I'm not sure what you mean
21:34:59 <adu> so whats the difference between the halting problem and PvsNP
21:35:10 <wagle_home> asymptotic complexity seems a kinda "non-trivial property"...  8)
21:35:39 <lekro> Apocalisp: http://en.wikipedia.org/wiki/Busy_beaver
21:35:39 <lambdabot> Title: Busy beaver - Wikipedia, the free encyclopedia
21:36:20 <lekro> as far as I understand it it's kind of an "absolute" upper bound on (terminating) algorithms
21:37:41 <Apocalisp> lekro: Oh, right. So how long would it take a program to determine that "yes, this algorithm is a busy beaver"?
21:37:51 <lekro> that's impossible
21:37:59 <Apocalisp> fair enough
21:38:17 <wagle_home> the wikipedia article discusses that issue
21:38:45 <lekro> Apocalisp: but the point is that the busy beaver is a valid upper bound of any algorithm
21:38:58 <lekro> Apocalisp: a very over-estimating bound, of course.
21:39:35 <lekro> Apocalisp: as in O(busyBeaver n)
21:42:16 <bos> wow, someone working on GHC as a final year undergraduate project.
21:42:23 <bos> that's pretty impressive.
21:42:49 <bos> i'm usually happy if a final year undergrad can read a digital clock and tell me what time it is.
21:43:19 <glguy> :-/
21:43:38 <johnnowak> bos: what horrible school are you associated with?
21:43:58 <bos> johnnowak: hard knox.
21:44:55 <gwern> hm. maybe someone will know this question: suppose I wanted a frontend to GHCi in which infix operators had to have spaces around them (ie 'f.g' is distinct from 'f . g' - one be function composition and t'other be a strange function name). is there any particular way I would go about this?
21:45:04 <sarehu> actually, lekro, is O(busyBeaver n) really correct?  You better be careful about which n you choose
21:46:09 <sarehu> or am I just being retarded again.  Hmm, I think I am
21:46:30 <lekro> sarehu: yeah, I was thinking about that, too. The input is considered part of the algorithm in this case I guess
21:46:46 <gwern> Adamant: halting and related problems are about whether something is answerable, P, NP, and the many many other complexity classes are about how hard to answer an answerable thing is, iirc
21:46:53 <gwern> er. I meant that for adu
21:47:16 <gwern> adu: halting and related problems are about whether something is answerable, P, NP, and the many many other complexity classes are about how hard to answer an answerable thing is, iirc
21:47:16 <wagle_home> i think n is the number of states in the BB turing machine..  so you'd have to turn the algorithm into a turing machine, and find its number of states..  iirc, BB goes berzerk after n=4 to 7 or thereabouts
21:47:57 <lekro> wagle_home: turning an algorithm into a turing machine is computable, so it is less than busy beaver and the big-O notation hides that
21:48:00 <wagle_home> oh the size of the universal turing machine is an issue too
21:49:33 <yrlnry> What's the name of the function  f that does   f 3 x = [x,x,x] ?
21:49:43 <lekro> :t replicate
21:49:44 <lambdabot> forall a. Int -> a -> [a]
21:49:46 <yrlnry> Thanks.
21:49:55 <gwern> @hoogle Int -> a -> [a]
21:49:55 <lambdabot> Prelude.replicate :: Int -> a -> [a]
21:49:55 <lambdabot> Data.List.replicate :: Int -> a -> [a]
21:49:56 <mauke> @hoogle Int -> a -> [a]
21:49:56 <lambdabot> Prelude.replicate :: Int -> a -> [a]
21:49:56 <lambdabot> Data.List.replicate :: Int -> a -> [a]
21:50:00 <mauke> AIIRRR
21:50:20 <gwern> mauke: don't worry, I was already jinxed by lekro, so I shan't jinx you
21:50:39 <wagle_home> eh darn, i was polluted by staring at take 5 $ repeat foo earlier today
21:50:43 <mauke> @. hoogle type \3 x -> [x,x,x]
21:50:44 <lambdabot> Did you mean: forall t t1. (Num t) => t -> T1 -> [T1]
21:50:44 <lambdabot> Data.List.genericReplicate :: Integral i => i -> a -> [a]
21:50:50 <yrlnry> @pl \s n -> foldr (++) "" (replicate n s)
21:50:50 <lambdabot> (foldr (++) [] .) . flip replicate
21:51:11 <mauke> foldr (++) ""? isn't that concat?
21:51:17 <gwern> > take 5 $ cycle "foo"
21:51:18 <lambdabot>  "foofo"
21:51:22 <yrlnry> @pl \s n -> concat (replicate n s)
21:51:22 <lambdabot> (join .) . flip replicate
21:51:24 <yrlnry> thanks!
21:52:01 <gwern> @pl foo s n = concat (replicate n s)
21:52:02 <lambdabot> foo = (join .) . flip replicate
21:52:03 <gwern> @pl foo s n = concat  . replicate n s
21:52:03 <lambdabot> foo = ((join .) .) . flip replicate
21:52:10 <doctormach> Are there any compilers besides ghc that implement strictness annotations?
21:52:38 <mauke> yes, they're standard haskell
21:52:44 <gwern> @pl foo = concat  . replicate
21:52:44 <lambdabot> foo = join . replicate
21:52:58 <gwern> what?
21:53:03 <gwern> :t join
21:53:04 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
21:53:06 <gwern> :t concat
21:53:06 <lambdabot> forall a. [[a]] -> [a]
21:53:15 <mauke> :t join . replicate
21:53:16 <lambdabot>     Couldn't match expected type `(->) a' against inferred type `[]'
21:53:16 <lambdabot>     Probable cause: `replicate' is applied to too many arguments
21:53:16 <lambdabot>     In the second argument of `(.)', namely `replicate'
21:53:25 <gwern> @src concat
21:53:25 <lambdabot> concat = foldr (++) []
21:53:52 * gwern wonders what would happen if concat was defined as = join
21:53:55 <yrlnry> Thanks everyone.
21:54:05 <wagle_home> it isnt?
21:54:28 <gwern> @src join
21:54:28 <lambdabot> join x =  x >>= id
21:54:41 <wagle_home> @src concat
21:54:41 <lambdabot> concat = foldr (++) []
21:54:49 <gwern> wagle_home: they would seem to be defined differently
21:55:08 <wagle_home> coulda sworn i saw the equality in some prelude or other
21:55:24 <gwern> wagle_home: maybe it's a bug? check the report
21:55:32 <mauke> they're functionally equivalent for lists
21:55:38 <yrlnry> Is "" identical to [], or does it carry some sort of character type?
21:55:47 <mauke> :t ("", [])
21:55:47 <lambdabot> forall a. ([Char], [a])
21:55:53 <yrlnry> THanks.
21:56:06 <wagle_home> instance Monad ([]) where join = concat                              ... or somesuch
21:56:25 <mauke> join is not a method
21:56:40 <wagle_home> :t join
21:56:41 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
21:56:53 <wagle_home> :t concat
21:56:54 <lambdabot> forall a. [[a]] -> [a]
21:57:18 <wagle_home> :t join :: [[a]] -> [a]
21:57:19 <lambdabot> forall a. [[a]] -> [a]
21:57:26 <glguy> join is not a class method of Monad
21:57:36 <wagle_home> it was when/where i looked
21:57:49 <glguy> not in Haskell at least
21:57:54 <glguy> it can be defined as such though
21:58:26 <wagle_home> was 5 years ago or so
21:59:02 <glguy> the standard hasn't changed in 5 years
21:59:18 <mauke> １０ ｙｅａｒｓ
21:59:34 <glguy> when was the FFI added?
21:59:54 <glguy> ?src join
21:59:54 <lambdabot> join x =  x >>= id
22:00:00 <gwern> mauke: whoa. was that unicode?
22:00:08 <mauke> gwern: yes
22:00:26 <adu> join :: Monad m => m (m a) -> m a
22:00:29 * gwern wishes I knew how people kept typing in random unicode stuff with such aplomb
22:00:54 <mauke> scriptable irc client
22:01:08 <bos> @hoogle unsafeCoerce
22:01:09 <lambdabot> Unsafe.Coerce.unsafeCoerce :: a -> b
22:02:06 <dejones> Is there a good book any of you might recommend for learning Haskell?  I'm a Computer Science Master's student, so I'm fine with Algorithms/Data Stuctures, but I'd like to learn more about using Functional Progamming and Haskell...
22:02:26 <wagle_home> where did i claim that this was in the standard?  huh?  huh?
22:02:49 <wagle_home> pretty sure it was ghc or hugs though, those would be the ones i woulda used
22:03:14 <wagle_home> (not any more though, just looked)
22:03:47 <wagle_home> could be pre haskell98, though..  time has been flying along
22:04:55 <adu> i think Fortress is a little more gentle when it comes to converting over to FP
22:06:25 <dejones> Particularly, it would be nice to find a book on more complex topics with Haskell, such as Monads, Parallelism, and implementation of efficient Algs/DataStructures... any suggestions?
22:07:00 <adu> i could write yet another monad tutorial if need by
22:08:41 <wagle_home> start the YA2MT. YA3MT, ... series
22:08:46 <adu> dejones: there is a huge amount of material about exactly that, but the problem is that its not in book form, its scattered accross papers and wikis
22:09:11 <Spark> fortress? functional programming? what?
22:09:34 <wagle_home> @google fortress
22:09:35 <lambdabot> http://www.fortressinv.com/
22:09:35 <lambdabot> Title: Fortress Investment Group LLC
22:09:39 <adu> Spark: if it weren't for the 'self' keyword, Fortress traits somewhat resemble Haskell typeclasses
22:09:40 <wagle_home> oh well
22:09:53 <adu> http://fortress.sunsource.net/
22:09:54 <lambdabot> Title: fortress: Home
22:10:17 <dejones> adu: yeah, I navigate the wiki to find papers... but, reading papers a certain amount of knowledge is usually assumed and not presented in a method of "this is how you do this in Haskell" but more of a "we used Haskell to explore" this topic of research.
22:10:20 <Spark> having type classes doesn't make it functional :)
22:10:29 <dejones> adu: but, they are still quite useful and interesting.
22:10:46 <wagle_home> http://en.wikipedia.org/wiki/Fortress_programming_language
22:10:48 <adu> Spark: then what does?
22:11:26 <Spark> referential transparency would be a good start
22:11:51 <adu> Spark: all languages have referential transparency
22:11:57 <dejones> adu: Nope.
22:11:59 <adu> yes
22:12:03 * Spark prepares the catapult
22:12:06 <dejones> ???
22:12:42 * adu prepares
22:13:04 <adu> maybe i should clarify
22:13:06 <dejones> adu: Only purely functional languages are referentially transparent.
22:13:29 <dejones> http://en.wikipedia.org/wiki/Pure_function
22:15:52 <wagle_home> the optimizer in my compiler replaces equals with equals all the time
22:16:12 * dejones ponders "are we still going to need the catapult?"
22:16:22 <dejones> hehe
22:16:29 <adu> I understand what is meant by "referential transparency" and that it means that identifiers can be replaced with the value that they refer to at any point, and that functions must explicitly declare all of their inputs but if you include implicit arguments then the argument doesn't stand as well, expecially if you start including pointers as values, at which point an identifier can always be replaced with its pointer (referential tr
22:16:54 <dmwit> Huh.
22:17:02 <adu> thats what i meant
22:17:18 <wagle_home> adu end got clipped
22:17:34 <dmwit> (ST.runSTArray . createCounts $ 3) doesn't type-check, but (ST.runSTArray (createCounts 3)) goes through just fine.
22:17:37 <dmwit> Any hints?
22:17:52 <adu> at which point an identifier can always be replaced with its pointer (referential transparency) even if the pointer can change. Its all a matter of perspective.
22:17:55 <glguy> $ isn't polymorphic enough
22:18:03 <dmwit> oy
22:18:15 <dmwit> I wasn't even aware I was using higher-ranked types.
22:18:16 <bd_> dmwit: don't use a composition operator on runST*
22:18:25 <bd_> (the problem is actually . here)
22:18:30 <glguy> ah
22:18:46 <dmwit> I'm not so sure that ($) works correctly, either.
22:19:00 <bd_> :t runSTArray
22:19:03 <lambdabot> Not in scope: `runSTArray'
22:19:08 <dejones> bd_: hmm... if the . and $ don't work equally as well as the ()'s then why use them at all...?
22:19:09 <dmwit> I tried sticking "runSTArray $" at the beginning of the definition for createCounts, which didn't type-check either.
22:19:12 <bd_> hm, no good testing here
22:19:12 <dmwit> No composition there.
22:19:29 <bd_> dejones: Normally they do, but runST does some nasty tricks with the type system
22:19:47 <dejones> bd_: Hmm, I'm not familiar with runST...
22:19:50 <bd_> dejones: For the details you'll have to ask someone better acquainted with the theory ...
22:19:57 <glguy> Wasn't $ special-cased in 6.8.2
22:20:00 <glguy> or at least 6.8.x
22:20:07 <glguy> for rank2types
22:20:16 <bd_> runST has a weird type: runST :: (forall s. ST s v) -> v
22:20:44 <bd_> what this means is that the left hand side must have the /same/ v for /any/ type s
22:21:26 <bd_> ...and somehow that breaks when you use ($) :: (a->b) -> a -> b, ask someone who knows the theory better
22:21:29 <bd_> >_>
22:22:51 <sarehu> ok, (runST $ return 3) is working in ghc 6.8.2
22:22:56 * dejones is a Haskell newb and is no help with this.  ;)
22:23:49 <wagle_home> i always do notice that everyone who uses the phrase "referential transparency" never supports their position, just threatened the alleged non-believer
22:23:56 <sarehu> holy wtf..
22:24:18 <sarehu> ...> id runST (return 3)
22:24:39 <sarehu> <interactive>:1:0:    couldn't match expected type 'm t' against inferred type 'forall s. ST s a'.....
22:24:47 <sarehu> ...> (id runST) (return 3)
22:24:49 <sarehu> 3
22:24:56 <scook0> o_O
22:24:57 <sarehu> 8-o
22:25:08 <dmwit> Why is that surprising?
22:25:19 <Pseudonym> Oh... happy Pi day, everyone!
22:25:23 <Pseudonym> > let p d = take d(fix(\i y h->let(z,x)=fix(\f xs->case xs of{((n,d,c):y)->let{(z,k)=f y;(q,r)=(c*10+k)`divMod`d}in((n,d,r):z,n*q);_->([],0)})y in case x of{9->i z(h++[9]);10->i z(map(\x->(x+1)`mod`10)h++[0]);_->h++i z[x]})((1,10,2):[(i,2*i+1,2)|i<-[1..(10*d)`div`3]])[])in p 100
22:25:23 <dejones> ?
22:25:24 <sarehu> a b c != (a b) c
22:25:25 <lambdabot>  [3,1,4,1,5,9,2,6,5,3,5,8,9,7,9,3,2,3,8,4,6,2,6,4,3,3,8,3,2,7,9,5,0,2,8,8,4,1...
22:25:27 <dmwit> (id runST) (return 3) = runST (return 3) = 3
22:25:30 <Pseudonym> Pi for everyone!
22:25:44 <dejones> lol
22:25:48 <dmwit> sarehu: false?
22:25:49 <andyjgill> Mmmm. pi.
22:26:02 <sarehu> dmwit: see first and second example; compare
22:26:05 <dmwit> sarehu: oh, yeah
22:26:09 <glguy> wagle_home: kind of hard to disagree with 1/2 of an argument
22:26:12 <dmwit> Sorry, I see what you mean now.
22:26:17 <scook0> @oeis A000796
22:26:17 <lambdabot> Decimal expansion of Pi.
22:26:17 <lambdabot> [3,1,4,1,5,9,2,6,5,3,5,8,9,7,9,3,2,3,8,4,6,2,6,4,3,3,8,3,2,7,9,5,0,2,8,8,4,1,...
22:26:29 <wagle_home> there's a licence plate in portland "mmmmpi"
22:26:37 <bd_> wagle_home: 'non believer'? eh? what position?
22:26:49 <dmwit> sarehu: That is exactly the problem I was bumping up against: ($) is not polymorphic enough, and id = ($).
22:28:03 <cygnus_> Pseudonym: how accurate is that pi
22:28:23 <glguy> dmwit: what version of ghc?
22:28:40 <Pseudonym> cygnus: See the 100 at the end?
22:28:45 <Pseudonym> Change that.
22:28:46 <dmwit> glguy: 6.8.2
22:28:51 <wagle_home> bd_ the people who dont see the one true light of "referential transparency"..  its always used as an unexplained codeword, and eyes glaze over if you try to make sense of it
22:28:57 <dmwit> glguy: err... 6.6.1
22:28:58 <dmwit> heh
22:29:51 <cygnus_> Pseudonym: what is the way it's calculating it called
22:30:01 <bd_> wagle_home: er. referential transparency just means you can replace identifiers with the expression they were set to at definition, without worrying about the identifiers changing, or some side-effect occuring too many or too few times. There's nothing mystical about it.
22:30:29 <bd_> eg; let foo = ...; bar foo foo  -- is the same as bar (...) (...) and vice versa, no matter what is in the ...
22:30:56 <bd_> assuming you have referential transparency, which is a condition which can be broken by using unsafePerformIO improperly for example
22:31:08 <Pseudonym> cygnys: It's using a continued fraction.
22:31:47 <wagle_home> i say something like "my optimizing compiler replaces equals with equals all the time", and get nothing..  usually the definition of RT is "able to replace equals with equals" is the best you can get..  this stuff with identifiers is new
22:32:12 <bd_> wagle_home: identifier == variable, basically. Except since in haskell 'variables' don't vary, that's not a very good term...
22:32:15 <Pseudonym> I think.
22:32:16 <bd_> so that's*
22:33:13 <wagle_home> when you start thinking about space complexity in haskell, the transparency gets kinda foggy
22:33:14 <glguy> referential transparency lets you replace *expressions* with their values, not just identifiers
22:33:19 <Pseudonym> Now I'm not so sure.  I wrote it a couple of years ago.
22:33:34 <bd_> for example, in C, if you start with: char x = getchar(); char y = x + x;  this is not the same as: char y = getchar() + getchar();
22:33:42 <cygnus_> ye cause to write an expanding decimal you need to be able to know when tis grater or les than
22:33:57 <allbery_b> bd_: it's also erroneous
22:34:28 <bd_> allbery_b: precisely, replacing the variable with its definition not only changes the semantics, but also possibly introduces undefined behavior.
22:34:28 <wagle_home> a side effectful quasi-expression has to be replaced by one that makes the same observable side effects
22:34:49 <dejones> "recursive supercombinators" -- now that sounds complex.  :)
22:34:55 <allbery_b> bd_: not my point.  the type of getchar() is (int), not (char)
22:35:01 <bd_> wagle_home: The thing is, haskell, doesn't let you write these kinds of expressions with side effects. So that kind of replacement is safe, and this is what we mean by 'referential transparency'
22:35:16 <wagle_home> i can turn nested do loops in fortran inside out if i obey certain rules
22:35:24 <bd_> oh, well, pay no attention to the lossy downcast behind the curtain :)
22:35:38 <allbery_b> (and youy thereby lose EOF)
22:36:15 <glguy> wagle_home: but that doesn't relate back to referential transparency
22:36:23 <Pseudonym> Actually, I think it's a tableau algorithm, now that I think of it.
22:36:24 <bd_> wagle_home: Well, I don't know about fortran, but the main thing is haskell forces you to not write code that doesn't allow referential transparency. This is nice because you can easily refactor out an expression that occurs frequently as a variable (it works backwards too!) without worrying about side-effects
22:36:25 <glguy> (or have we moved on :0/)
22:36:34 <bd_> and moreover the compiler can too
22:36:41 <wagle_home> coercion of suspensions to values is a side effect..  one that can affect the behavior of the garbage collector and thus the runnabilty of the program on a particular platform under particular conditions
22:37:16 <bd_> wagle_home: The assumption is you have unlimited memory :)
22:37:44 <bd_> yes the lifetimes of objects can change if you lift expressions like this
22:37:47 <wagle_home> the reality is that you dont..  you want the airliner to run out of memory?
22:37:51 <scook0> but if your program terminates without crashing, then you still get the same result
22:38:18 <bd_> wagle_home: well, theoretically you can panic, discard the value of the expression, then re-compute it later if you need it
22:38:38 <bd_> all made possible because it has no side effects
22:38:43 <bd_> in practice no compilers do this though
22:39:11 <bd_> it's hard to tell ahead of time whether you need to save the values needed to recompute it - it could be the result is smaller than what it references to compute said result
22:40:08 <wagle_home> well, actually daisy/dsi (steve johnson, eric jeschke) lets suspensions run more than one time (to avoid locking) because suspensions are pure
22:40:52 <glguy> that's just "call by name"?
22:41:04 <dejones> anyone read "Programming in Haskell" by Graham Hutton?  any good?
22:41:05 <bd_> does it keep them after they've been computed, and then every thread stops for GC?
22:41:20 <dejones> ?seen Cale
22:41:21 <lambdabot> Cale is in #ghc, #haskell-overflow and #haskell. I last heard Cale speak 8h 37m 35s ago.
22:41:28 <Cale> hi
22:41:37 <dejones> hey Cale.
22:41:44 <Cale> What's up?
22:41:54 <wagle_home> i think purity is cool..  its "referential tranparency" being equated to purity that i balk at
22:42:17 <solrize> dejones, i looked at that book yesterday, it does seem pretty good, though NO book that i've looked is enough to get to really know what you're doing
22:42:17 <dejones> Cale: I'm considering buying a textbook to facilitate my learning of Haskell.  :)  Any recommendations?
22:42:35 <solrize> http://realworldhaskell.org looks promising :)
22:42:38 <roconnor> what is the difference between referential transparency and purity?
22:42:40 <lambdabot> Title: Real World Haskell
22:42:43 <wagle_home> glguy, no, its regular lazy pure functional, except suspensions are processes (running on a parallel machine)
22:42:52 <dejones> solrize: Yeah.  I've heard about "Real World Haskell."
22:43:04 <glguy> Cale: I've noticed that in ghc6.8.2 runs lists faster than nondett now
22:43:15 <glguy> (which I don't think always used to be the case, and might not be generally)
22:43:20 <Cale> dejones: Well, hmm, I haven't real so many paper Haskell texts. Real World Haskell isn't out yet, I don't think, but I think parts of it are online in beta form
22:43:25 <dejones> I think I'd like a book that covers more of the theory and monads, and possibly some efficient implementations of algorithms/data structures...
22:43:39 <wagle_home> i see it as purity gives you a particularly nice and simple form of referential transparency...
22:43:46 <wagle_home> but i'm not the norm
22:44:03 <Cale> dejones: Graham Hutton's new text is supposed to be good, but more basic in nature. There's also a book by Simon Thompson that lots of people recommend.
22:44:08 <dejones> but, I guess I'm mostly interested in complex topics.
22:44:25 <dejones> http://www.amazon.com/gp/product/0521692695?ie=UTF8&tag=progrinhaske-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0521692695
22:44:27 <lambdabot> http://tinyurl.com/2pwhsf
22:44:29 <dejones> http://www.amazon.com/gp/product/0201342758/ref=pd_luc_0000205216926950201342758
22:44:31 <lambdabot> http://tinyurl.com/3yralp
22:44:39 <solrize> dejones i think also the complex stuff is in academic papers
22:44:47 <wagle_home> who is writing the "real world haskell" book
22:44:54 <dejones> first is Graham Hutton's, second is Simon Thompson's
22:45:00 <dejones> solrize: yea, it does seem that way.  ;)
22:45:45 <solrize> hanging out on this channel also helps a lot
22:46:07 <dejones> solrize: I'm here almost every day... often bothering Cale.  ;)
22:46:18 <Cale> Bryan O'Sullivan, Don Stewart and John Goerzen
22:46:28 <solrize> bos and dons are regulars here
22:46:32 <dejones> Cale: you missed my Ackermann function memoization questions earlier...
22:46:39 <solrize> i don't know whether jgoerzen comes here much
22:47:07 <Cale> He's regularly here by the name CosmicRay, if my name mapping is correct.
22:47:08 <dejones> Cale: I had to post to the haskell-cafe mailing list b.c of some weird output from GHC; it seems that GHC does not throw exceptions for Arrays.
22:48:16 <Cale> Oh, that's odd. It should throw some exceptions...
22:49:44 <dejones> Cale: My email to haskell-cafe: http://www.haskell.org/pipermail/haskell-cafe/2008-March/040598.html
22:49:45 <lambdabot> Title: [Haskell-cafe] Ackermann Function Memoization, GHC Weird Output or Bug?, http://tinyurl.com/3x3q2l
22:50:25 <wagle_home> i guess my viewpoint is colored by the fact that i think "replacing equals with equals" is particularly interesting in the presence of side-effects, not horrid and to be eradicated when possible
22:51:18 <roconnor> wagle_home: what do you mean by that?
22:51:28 <Cale> Let me try...
22:53:56 <wagle_home> roconnor, using dependency analysis to turn a set of fortran do loops inside out to maximize the parallelism for a particular model of parallelism
22:54:37 <wagle_home> same side effects, different way of achieving them
22:57:16 <shachaf> They've added the new comprehension syntax to GHC?
22:57:23 <glguy> Cale: both interpreted and compiled?
22:57:32 <glguy> would seem so :-/
22:57:38 <Cale> There's something strange going on.
22:57:42 * shachaf still doesn't really like it.
22:57:51 <Cale> It certainly does throw array index out of bounds errors.
22:58:02 <wagle_home> new comprehension syntax?
22:58:14 <dejones> Cale: it doesn't throw array index out of bound errors for me...
22:58:20 <Cale> dejones: Not your program.
22:58:23 <dejones> Oh
22:58:24 <dejones> lol
22:58:25 <Cale> dejones: But in general it does.
22:58:30 <dejones> Right.
22:58:36 <Cale> I'm trying to sort out what's happening.
22:58:44 <dejones> Ok.  :)
22:58:51 <wagle_home> dejones, what values from out of bounds indexes do you get?
23:00:07 <shachaf> wagle_home: See http://blog.omega-prime.co.uk/2008/03/14/bitesize-functional-programming-comprehensive-comprehensions/ .
23:00:10 <lambdabot> Title: 24 :: (Bloggable a) => a -> IO () 1 16  Blog Archive 1 46  Bitesize Functional ..., http://tinyurl.com/2g4fpp
23:00:11 <dejones> wagle_home: the values seem to be truncated results of the correct answer... "seem" to be.  -- my code is posted in this email: http://www.haskell.org/pipermail/haskell-cafe/2008-March/040598.html
23:00:12 <lambdabot> Title: [Haskell-cafe] Ackermann Function Memoization, GHC Weird Output or Bug?, http://tinyurl.com/3x3q2l
23:02:12 <glguy> Cale: it has to do with the tuple indexing
23:02:25 <glguy> > array ((0,0),(1,1)) [((0,0),5),((1,1),6),((1,0),7),((0,1),8)] ! (0,3)
23:02:27 <lambdabot>  6
23:02:41 <Cale> Oh, that's brutal.
23:02:54 <Cale> That's certainly a bug.
23:03:00 <dejones> ?
23:03:26 <Cale> dejones: look at what it normally does when you index out of bounds:
23:03:27 <OceanSpray> Cale, I sort of figured out why certain views give you blackness.
23:03:47 <glguy> > index ((0,0),(1,1)) (0,3)
23:03:48 <lambdabot>  Exception: Error in array index
23:03:52 <Cale> > array (0,3) [(0,5),(1,6),(2,7),(3,8)] ! 4
23:03:53 <lambdabot>  Exception: Error in array index
23:04:24 <glguy> > array ((0,0),(1,1)) [((1,1),6)] ! (0,3)
23:04:25 <lambdabot>  6
23:04:34 <OceanSpray> it's the rotateBy function's fault, since it ALWAYS rotates with respect to the cardinal axes.
23:05:06 <Cale> OceanSpray: I have no idea what your rotateBy is doing.
23:05:15 <OceanSpray> Me neither.
23:05:16 <wagle_home> shachaf, hmm..  thanks
23:05:18 <OceanSpray> I got rid of it.
23:05:34 <Cale> OceanSpray: The only trig functions you should need for that are cos and sin.
23:05:54 <OceanSpray> hmm...
23:06:02 <OceanSpray> anyways, good night.
23:06:07 <Cale> g'night
23:06:47 <dejones> Cale, glguy: I didn't realize you could index an array by a pair, as in glguy's example...
23:07:10 <dejones> "> array ((0,0),(1,1)) [((1,1),6)] ! (0,3)"
23:07:14 <Cale> dejones: How could you not have noticed that? :)
23:07:21 <Cale> dejones: Your program does it :)
23:07:37 <dejones> Cale: dmwit helped me with the program.  I didn't say I completely understood it.  ;)
23:07:47 <Cale> ah, okay
23:07:56 <wagle_home> dejones, hmm..  5533 == 65533 `mod` 10000, or is that what you noticed?
23:08:18 <dejones> but, I did "assume" it was indexing by the pairs... I just didn't know if it was really working bc of the odd output from GHC and no array index exceptions.
23:08:32 <dejones> wagle_home: yes, that is what I noticed.
23:08:43 <dejones> quite odd coincidence.
23:09:03 <dejones> I guess my wording of "truncated" answers was really incorrect, heh.
23:09:28 <glguy> > listArray ((0,0),(1,1)) [1..] ! (1,-1) -- feature, not a bug ;)
23:09:29 <lambdabot>  2
23:09:34 <dejones> lol
23:10:35 <dejones> "Exceptions raised by array-related operations. (NOTE: GHC currently does not throw ArrayExceptions)." --- according to http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html#v%3AArrayException
23:10:35 <lambdabot> http://tinyurl.com/sqmlj
23:11:00 <Cale> dejones: It doesn't throw ArrayExceptions, it *does* however throw 'error' exceptions.
23:11:28 <dejones> Cale: Ahh... so this issue is an ArrayException, so it is not thrown?
23:12:04 <Cale> No, the problem is just some buggy instance code which is supposed to throw an error but doesn't.
23:12:29 <Cale> You should get an ErrorCall exception with something like "Error in array index"
23:13:18 <Cale> When it says that ArrayExceptions aren't thrown, it doesn't mean that no exceptions are thrown for array errors, it just means that it's a different kind of exception.
23:13:27 <dejones> Cale: Gotcha.
23:13:54 <dejones> So, the reply to my email on haskell-cafe isn't really that useful.  ;)
23:14:14 <Cale> Right.
23:14:23 <glguy> did my reply on the list go through?
23:14:30 <dejones> glguy: Yep, I just got it.
23:14:37 <Cale> glguy: I'm seeing it here.
23:14:47 <wagle_home> urgh, the url died
23:14:51 <glguy> k (I send so little mailing list mail, never know)
23:14:57 <wagle_home> The requested URL /pipermail/haskell-cafe/2008-March/040598.html was not found on this server.
23:15:27 <Cale> > array ((0,0),(1,1)) [((1,1),6)] ! (0,4)
23:15:28 <lambdabot>  Exception: Error in array index
23:15:34 <Cale> > array ((0,0),(1,1)) [((1,1),6)] ! (0,2)
23:15:35 <lambdabot>  Exception: (Array.!): undefined array element
23:16:33 <dejones> glguy: so, that behavior you posted is incorrect, right?
23:16:40 <Cale> > array ((0,0),(1,1)) [((0,0),'a'),((0,1),'b'),((1,0),'c'),((1,1),'d')] ! (0,2)
23:16:40 <lambdabot>  'c'
23:16:47 <Cale> > array ((0,0),(1,1)) [((0,0),'a'),((0,1),'b'),((1,0),'c'),((1,1),'d')] ! (0,-1)
23:16:48 <lambdabot>  Exception: Error in array index
23:16:51 <Cale> > array ((0,0),(1,1)) [((0,0),'a'),((0,1),'b'),((1,0),'c'),((1,1),'d')] ! (1,-1)
23:16:51 <lambdabot>  'b'
23:16:56 <Cale> ...
23:17:00 <Cale> > array ((0,0),(1,1)) [((0,0),'a'),((0,1),'b'),((1,0),'c'),((1,1),'d')] ! (1,-2)
23:17:00 <lambdabot>  'a'
23:17:07 <Cale> That's screwed up.
23:17:10 <dejones> lol
23:17:19 <Cale> I think I see what's happening.
23:17:30 <dejones> GHC is going crazy?  :P
23:17:32 <mauke> is this C?
23:17:46 <Cale> It's just applying a formula to translate the pair index into a flat array index
23:17:47 <glguy> the behavior is pretty clear
23:17:47 <dejones> Cale: can you test that in Hugs maybe?
23:17:55 <Cale> and only checking if it's in bounds afterward
23:17:56 <mauke> @src Ix
23:17:56 <lambdabot> class (Ord a) => Ix a where
23:17:56 <lambdabot>     range           :: (a,a) -> [a]
23:17:56 <lambdabot>     index           :: (a,a) -> a -> Int
23:17:56 <lambdabot>     inRange         :: (a,a) -> a -> Bool
23:17:56 <lambdabot>     rangeSize       :: (a,a) -> Int
23:18:07 <Cale> (that is, if the flat index is in bounds)
23:18:27 <mauke> > index ((0,0),(1,1)) (1,-2)
23:18:28 <lambdabot>  Exception: Error in array index
23:18:52 <Cale> See, if it actually did that test, it would be okay.
23:19:00 <dejones> Yeah..
23:19:09 <Cale> My guess is that it's not using the index function like it should be.
23:19:17 <Cale> hmm
23:19:20 <Cale> I'll have a look :)
23:19:28 <dejones> > array ((0,0),(1,1)) [((0,0),'a'),((0,1),'b'),((1,0),'c'),((1,1),'d')] ! (index (1,-2))
23:19:28 <lambdabot>  Couldn't match expected type `(t, t1)'
23:19:34 <dejones> :t index
23:19:35 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Int
23:19:49 <glguy> > index ((0,0),(1,1)) (0,2)
23:19:50 <lambdabot>  Exception: Error in array index
23:20:18 <dmwit> ?hoogle (a -> m a) -> Int -> m a
23:20:19 <lambdabot> No matches, try a more general search
23:20:28 <dmwit> Anybody?
23:20:29 <Cale> instance (Ix a, Ix b) => Ix (a, b) where -- as derived
23:20:29 <Cale>     {-# SPECIALISE instance Ix (Int,Int) #-}
23:20:29 <Cale>     {-# INLINE range #-}
23:20:29 <Cale>     range ((l1,l2),(u1,u2)) =
23:20:29 <Cale>       [ (i1,i2) | i1 <- range (l1,u1), i2 <- range (l2,u2) ]
23:20:32 <Cale>     {-# INLINE unsafeIndex #-}
23:20:34 <Cale>     unsafeIndex ((l1,l2),(u1,u2)) (i1,i2) =
23:20:36 <Cale>       unsafeIndex (l1,u1) i1 * unsafeRangeSize (l2,u2) + unsafeIndex (l2,u2) i2
23:20:38 <Cale>     {-# INLINE inRange #-}
23:20:40 <Cale>     inRange ((l1,l2),(u1,u2)) (i1,i2) =
23:20:42 <Cale>       inRange (l1,u1) i1 && inRange (l2,u2) i2
23:20:44 <Cale>     -- Default method for index
23:20:50 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-Arr.html
23:20:50 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/2lr2q9
23:21:00 <glguy> you know better :-p
23:21:04 <dmwit> :t \f n -> foldl' (>>=) [] (replicate n f)
23:21:05 <Cale> meh
23:21:05 <lambdabot> forall b. (b -> [b]) -> Int -> [b]
23:21:19 <dmwit> good enough
23:22:21 <Cale> arr@(Array l u n _) ! i = unsafeAt arr $ safeIndex (l,u) n i
23:22:53 <Cale> safeIndex :: Ix i => (i, i) -> Int -> i -> Int
23:22:53 <Cale> safeIndex (l,u) n i = let i' = unsafeIndex (l,u) i
23:22:53 <Cale>                       in if (0 <= i') && (i' < n)
23:22:53 <Cale>                          then i'
23:22:53 <Cale>                          else error "Error in array index"
23:22:59 <Cale> yep, there's the bug
23:23:21 <dejones> whoa
23:23:25 <Cale> It's only testing if the result of unsafeIndex is in range, which is brutally stupid.
23:23:27 <dejones> lots of quit/join there...
23:23:27 <dmwit> netsplit
23:23:39 <dejones> Cale: what's the bug again?
23:23:43 <glguy> clarke... you should know better
23:23:50 <dejones> Cale: it got mixed up for me.
23:24:12 <Cale> dejones: There's a function called index...
23:24:14 <Cale> :t index
23:24:15 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Int
23:24:22 <Cale> It takes a pair of bounds
23:24:24 <glguy> Cale: but it's *faster* this way
23:24:25 <Cale> and an index
23:24:39 <Cale> and it gives an Int index into a flat array, where the element should go
23:25:06 <Cale> Bounds and indices can be any datatype so long as it's an instance of Ix
23:25:18 <Cale> (and index is a member of Ix which is supposed to make that happen)
23:25:33 <solrize> concurrent coq!
23:25:42 <solrize> http://lambda-the-ultimate.org/node/2638
23:25:43 <lambdabot> Title: The YNot Project | Lambda the Ultimate
23:26:05 <Cale> However, we see that (!) doesn't actually call index like it's supposed to
23:26:09 <Cale> arr@(Array l u n _) ! i = unsafeAt arr $ safeIndex (l,u) n i
23:26:24 <Cale> It calls "safeIndex" (which is humourously named in light of all this)
23:26:52 <Cale> and then unsafeAt, which is just a direct lookup into the array
23:27:02 <Cale> (no bounds checking there)
23:27:21 <Cale> Now, let's look at what safeIndex does
23:27:22 <dejones> but what about this part:
23:27:23 <dejones>    index		:: (a,a) -> a -> Int
23:27:23 <dejones>     -- | Like 'index', but without checking that the value is in range.
23:27:43 <Cale> that comment applies to the following line
23:28:26 <Cale> safeIndex :: Ix i => (i, i) -> Int -> i -> Int
23:28:26 <Cale> safeIndex (l,u) n i = let i' = unsafeIndex (l,u) i
23:28:26 <Cale>                       in if (0 <= i') && (i' < n)
23:28:26 <Cale>                          then i'
23:28:26 <Cale>                          else error "Error in array index"
23:28:39 <Cale> So here, what does safeIndex do?
23:29:01 <Cale> It calls unsafeIndex, which doesn't check if the value is in range.
23:29:34 <Cale> unsafeIndex is just a formula which would translate the pair index into an Int index into the array
23:30:15 <Cale> It then looks to see if the result that it gets from unsafeIndex is nonnegative and less than the flat array size.
23:30:23 <Cale> If so, then indexing succeeds.
23:30:27 <dejones> heh
23:30:39 <Cale> But the check that the index was actually valid was never done!
23:30:46 <semka> hi there
23:31:04 <glguy> Haskell, meet C. C, Haskell:
23:31:05 <glguy> #include <stdio.h>
23:31:07 <glguy> void main(void) {
23:31:09 <glguy>   int arr[2][2] = { { 0 , 1 } , { 2 , 3 } };
23:31:11 <glguy>   printf("%d",arr[1][-1]);
23:31:13 <glguy> }
23:31:22 <dejones> Cale: so it should be a recursive call to safeIndex instead of unsafeIndex?
23:31:26 <mauke> void main is wrong
23:31:37 <glguy> mauke: you've missed the point, look again
23:31:57 <mauke> no, I didn't
23:31:58 <dejones> lol
23:32:13 <dejones> glguy: segfault?  ;)
23:32:18 <wagle_home> mauke..  this is C, uh, you know?
23:32:22 <dejones> can't have negative indices in C.
23:32:25 <allbery_b> difference being C explicitly lets you do that
23:32:31 <wagle_home> 1
23:32:32 <mauke> <mauke> is this C? <- I noticed first
23:32:35 <allbery_b> dejones: you can, actually
23:32:42 <glguy> dejones: it works fine
23:32:43 <dejones> allbery_b: really?
23:32:45 <dejones> odd
23:32:46 <allbery_b> arrays are read-ony pointers
23:32:48 <mauke> wagle_home: yeah, so? C requires main to return int
23:33:11 <glguy> mauke: and that would make my paste one line longer
23:33:15 <glguy> and wouldn't addres the point
23:33:17 <wagle_home> the above will work, though..  its uh, C, you know?
23:33:19 <mauke> glguy: no, one character shorter
23:33:21 <dejones> allbery_b: ah yea, I guess it would just be the same as subtracting a pointer...
23:33:25 <allbery_b> indexing backwards from a pointer is perfectly valid, "result is undefined if the index falls outside of the indexed storage" or some such thing
23:33:28 <mauke> glguy: main doesn't require a return statement
23:33:32 <glguy> mauke: might be bed-time
23:33:43 <Cale> dejones: No, safeIndex is totally broken. It should be using the 'index' function.
23:33:49 <wagle_home> maybe --pedantic will get it to barf on the void main though
23:34:28 <wagle_home> actually the include might include a external int main () somewhere
23:34:32 <dejones> ?src index
23:34:32 <lambdabot> Source not found. You type like i drive.
23:34:32 <mauke> (there are platforms where void main will fail to run or crash after main ends)
23:34:33 <allbery_b> (the canonical example of C not making any real distinction between pointers and arrays:  3["abcdefgh"] == 'c'
23:34:45 <mauke> allbery_b: that's a nonexample
23:34:46 <dejones> Cale: is the source for index in that file?
23:34:54 <mauke> [] is a pointer operator
23:34:56 <TSC> That's an example of the commutativity of + for pointers and ints
23:34:56 <allbery_b> ([] maps to pointer addition, doesn't matter which side is the pointer)
23:35:11 <mauke> a[b] := *(a + b)
23:35:12 <dons> wow, where did this unsafeIndex code come from?
23:35:14 <allbery_b> the point (so to speak) is that an array is a pointer
23:35:16 <dons> that looks super wacky
23:35:20 <mauke> allbery_b: it isn't
23:35:25 <allbery_b> and a pointer is unconstrained
23:35:34 <allbery_b> it's a read-only pointer, mauke
23:35:36 <mauke> no
23:35:42 <wagle_home> C special cases on statically indexed 2-dimensional arrays to be a real 2 d array
23:35:45 <dejones> glguy: what did that C function print?  :)
23:35:50 <mauke> wagle_home: wtf?
23:35:55 <glguy> 1
23:36:03 <mauke> allbery_b: what is sizeof "x"?
23:36:06 <wagle_home> C special cases on statically dimensioned 2-dimensional arrays to be a real 2 d array
23:36:14 <Cale> dejones: Look for: "instance (Ix a, Ix b) => Ix (a, b) where". You'll see a comment saying "default method for index", which means to look in the class declaration.
23:36:21 <wagle_home> ha!  toldya!  1!
23:36:28 <Cale> So it's at the top in the class decl. for Ix
23:36:34 <semka> what software powers planet.haskell.org?
23:36:38 <allbery_b> mauke: I won't argue that there aren't hacks all over the place, but fundamentally what I said is true
23:36:43 <mauke> no
23:36:50 <mauke> there are no hacks
23:36:53 <dejones> glguy: neat stuff.  :)
23:36:56 <Cale> dons: safeIndex is more wacky :)
23:36:59 <wagle_home> mauke, which wtf are you referring to?
23:37:14 <allbery_b> (and, sizeof gives you the allocated size of the array, which is 2.  this is expected when passing a whole array to sizeof and is something of a hack)
23:37:15 <Cale> dons: It's perhaps the least aptly named function I've seen in a long time.
23:37:17 <mauke> wagle_home: what you said about C special casing arrays
23:37:25 <mauke> allbery_b: it's not a hack
23:37:35 <allbery_b> C's, array handling is schizo
23:37:50 <wagle_home> yeah..  foo[10][12] is not an array of arrays, its a real bonafide 2-d array
23:38:04 <mauke> wagle_home: C has no 2-d arrays. it's an array of arrays.
23:38:06 <dejones> Cale: found it.  I'm not very familiar with the "instance" syntax.  ;)
23:38:07 <dons> Cale, yes, that's the one. captain super wacky
23:38:24 <wagle_home> mauke, uh, yes it does
23:38:25 <allbery_b> the compiler does weirdshit to masquerade a 2d array
23:38:25 <QtPlatypus> I don't think its schizo.  Its just conistant in a very strange way.
23:38:31 <glguy> wagle_home: you mean to say it is a contiguous region of memory, and not an array of pointers?
23:38:39 <mauke> wagle_home: how?
23:38:48 <mauke> allbery_b: C arrays have no structure and no operations
23:38:50 <mauke> that's all
23:38:55 <wagle_home> severe hackery
23:39:31 <allbery_b> wagle_home:  static multidimensional arrays are laid out as single dimensional, then the compiler simulates array pointers.  severe hackery indeed
23:39:32 <dons> Cale: do we know where this code came from?
23:39:39 <allbery_b> like I said, schizo
23:39:43 <wagle_home> i'm not talking theory here, i'm talking reall experience
23:39:47 <mauke> the compiler doesn't simulate array pointers
23:39:50 <Cale> dons: I don't know.
23:39:50 <dons> actually, its the kind of code hpc would have caught.
23:39:53 <mauke> there are no pointers in arrays
23:39:59 <dons> andyjgill: have you seen this safeIndex function?
23:40:04 <dons> so so wrong, and hpc would have spotted it
23:40:36 * wagle_home looks outside and sees the sky is still blue
23:40:36 <allbery_b> sure it does.  in a dynamic array a[1][1] involves two pointers, in a static one therer's only one; a[1] is shandled specially
23:40:44 <mauke> what do you mean by "dynamic array"?
23:40:51 <allbery_b> it's not specific to 2dm btw; same happens with static 3d or other arrays
23:41:05 <dejones> dons: what is hpc?
23:41:14 <Cale> I'm actually kind of interested to know who checked that code in ;)
23:41:15 <dons> dejones: the code coverage tool built into ghc
23:41:22 <dejones> dons: thanks
23:41:25 <dons> i might have a go tomorrow to show how it would have found the bug
23:41:34 <dons> since that could woudl have been bright yellow in the coverage report :)
23:41:48 <allbery_b> mauke:  e.g. char *a[n] or char **a instead of static a[n][m]
23:41:48 <dejones> dons: post it to my email!  :)
23:41:56 <glguy> that'd mean you forgot to test the index function?
23:42:03 <mauke> allbery_b: char *a[n] is an array of pointers. and char **a is not an array at all
23:42:17 <dejones> dons, Cale: I'm glad I'm somehow helping Haskell and GHC through my learning of Haskell.  :)
23:42:24 <Cale> dons: Why would it be yellow?
23:42:43 <Cale> dons: As far as I can tell, all of that code executes quite often.
23:42:44 <allbery_b> most things treat them identically but the compiler pretends a[x] (for a[n][m]) is a (const) pointer
23:42:46 <mauke> so uh, if x[i] is a pointer, x[i][j] involves a dereference
23:43:02 <mauke> in your example, a[x] is an array
23:43:09 <mauke> no special case, no hacks
23:43:13 <Cale> dons: It's just that some incorrect indices are classified as correct by it.
23:43:14 <dons> glguy: yeah, entirely untested, and deeply weird logic
23:43:24 <glguy> dons: no, I mean you'd have tested that function
23:43:27 <glguy> dons: and declared it working
23:43:31 <allbery_b> point being, the standard requires that arrays pretend to be pointers
23:43:35 <glguy> code coverage wouldn't tell you it wasn't being used in !
23:43:43 <mauke> allbery_b: the word you're looking for is "evaluate"
23:43:47 <wagle_home> mauke: try a real program on a real c compiler.  you will find that you are wrong, and we are right.
23:43:48 <mauke> arrays evaluate to pointers
23:43:49 * dons digs around in Array
23:43:57 <Cale> It is being used in (!)
23:44:03 <mauke> wagle_home: you're very confused
23:44:06 <Cale> and all of it is regularly used...
23:44:22 <wagle_home> mauke: you are getting more confused by the moment
23:44:23 <mauke> wagle_home: I am a C compiler
23:44:37 * allbery_b rolls his eyes
23:44:39 <Cale> > listArray ((0,0),(1,1)) [0..] ! (0,3)
23:44:40 <lambdabot>  3
23:44:42 <Cale> > listArray ((0,0),(1,1)) [0..] ! (0,4)
23:44:42 <glguy> maybe move the argument to privmsg?
23:44:43 <lambdabot>  Exception: Error in array index
23:44:46 <dons> its scary that code isn't even commented
23:44:56 <dejones> lol
23:44:57 <dons> mauke: OT
23:45:01 <allbery_b> really this is basic comp.lang.c stuff
23:45:07 <wagle_home> i'm talking FACT, dude, not something i read someplace
23:45:09 <dejones> Cale: that's a pretty serious bug then?
23:45:12 <mauke> yeah, let's continue in #haskell-blah (if at all)
23:45:20 <Cale> dejones: Yes, it's absolutely ridiculous.
23:45:27 <dejones> lol
23:45:30 * allbery_b is just going to go to bed
23:45:36 <Cale> dejones: Someone is going to be very very embarrassed.
23:45:58 <dejones> Cale: oops.  ;)
23:46:06 <dejones> Maybe it was SPJ, hehe
23:46:08 <dejones> lol
23:46:11 <Cale> hehe
23:46:18 <dons> i'm not sure where the arrays lib came from
23:46:21 <glguy> woot, let's embarrass the contributor
23:46:24 <dons> that was early build/foldr days
23:46:28 <glguy> That'll teach 'em
23:46:28 <Cale> can we somehow ask darcs where that code came from?
23:46:43 <yav> you should try to :-)
23:46:43 <glguy> if the repository is small enough, you could
23:46:44 <dons> i'm more interested in what else lurks in that code :(
23:47:03 <dejones> dons, time for an Array rewrite/inspection?  ;)
23:47:24 <dons> ArrayBase.lhs was already quite old by 2001
23:47:25 <Cale> It's so silly. If it had just used 'index' it would have been fine.
23:47:45 <dons> it came from the hslibs repo
23:48:26 <Cale> Instead, it goes to elaborate lengths to cheat at testing index validity, and do it incorrectly..
23:48:54 <dejones> lol
23:49:37 <dejones> dons: how did you find the info for where that code came from?  with darcs?
23:49:52 <dons> yeah
23:50:04 <dons> but i haven't spotted this code, since its older than the repo
23:50:15 <dejones> lol
23:51:08 <dejones> GHC doesn't have a set of unit tests to confirm code such as Array in the standard library works correctly?
23:51:36 <Cale> dejones: It has a reasonably extensive set of tests and sample programs, iirc.
23:51:46 --- mode: ChanServ set +o yav
23:51:47 <Cale> dejones: This isn't covered, I'm guessing :)
23:51:55 <dejones> Cale: Hmm, just seems like something that would have been caught...
23:51:56 <dejones> yeah
23:51:59 <Cale> yav: +o?
23:52:12 <dons> what's yav up to?
23:52:30 <Cale> ...
23:52:30 <yav> oh the power
23:52:36 * dons slaps yav
23:52:37 <dejones> Cale: I guess it was such a fundamental thing that the unit test writers just assumed it "must" work?  ;)
23:52:45 <yav> gasp
23:52:51 --- mode: ChanServ set +o Cale
23:52:55 --- mode: Cale set -oo Cale yav
23:52:59 <dejones> yav: share the wealth ;)
23:52:59 <dons> the unit test writers?
23:53:00 <dejones> uh oh
23:53:09 <Cale> *plonk*
23:53:10 <dejones> dons: well, whoever wrote the set of tests....?
23:53:17 <dons> the set of tests?
23:53:19 <dfranke_> how did that happen?
23:53:48 <Cale> dons: Isn't there a pretty extensive set of test programs?
23:53:51 <dejones> dons: Cale said that he thought GHC had a "reasonably extensive set of tests and sample programs" ...?
23:53:52 <wagle_home> > cat mauke.c
23:53:52 <wagle_home> #include <stdio.h>
23:53:52 <wagle_home> void main (void) {
23:53:52 <wagle_home>   char foo[2][2];
23:53:52 <wagle_home>   foo[0][0] = 100;
23:53:52 <lambdabot>   Not in scope: `mauke'
23:53:52 <wagle_home>   foo[0][1] = 101;
23:53:54 <wagle_home>   foo[1][0] = 110;
23:53:56 <wagle_home>   foo[1][1] = 111;
23:54:00 <wagle_home>   {
23:54:02 <wagle_home>     char *baz = foo;
23:54:04 <wagle_home>     printf ("baz[%d] = %d\n", 0, baz[0]);
23:54:06 <wagle_home>     printf ("baz[%d] = %d\n", 1, baz[1]);
23:54:07 --- mode: ChanServ set +o Cale
23:54:08 <wagle_home>     printf ("baz[%d] = %d\n", 2, baz[2]);
23:54:10 <wagle_home>     printf ("baz[%d] = %d\n", 3, baz[3]);
23:54:10 --- kick: wagle_home was kicked by Cale (Cale)
23:54:12 <dejones> dons: I assumed that GHC would have some sort of unit testing for the standard library?
23:54:20 <dejones> ty Cale.
23:54:20 --- mode: Cale set -oo Cale yav
23:54:59 <dons> the base library has a pretty good set of tests, but its old, and i doubt covered well
23:55:30 <dons> actually, getting test coverage would be a good result for  the hackathon
23:55:42 <dons> work out what's being run and never tested
23:55:51 <dejones> dons: Google SoC?  ;)
23:55:52 <dfranke_> dons: wrt the "comprehensive comprehensions" thing you posted to reddit...
23:56:05 <dfranke_> does this mean that 'order', 'group', and 'by' are going to be reserved words?
23:56:08 <mauke> wagle_home: #haskell-blah, dude
23:56:18 <wagle_home> > ./mauke
23:56:18 <wagle_home> baz[0] = 100
23:56:18 <wagle_home> baz[1] = 101
23:56:18 <wagle_home> baz[2] = 110
23:56:18 <wagle_home> baz[3] = 111
23:56:18 <lambdabot>   parse error on input `./'
23:56:20 <dons> dfranke_: well, its been in ghc for a few months now.
23:56:22 --- mode: ChanServ set +o dons
23:56:23 <wagle_home> i'm done
23:56:25 --- kick: wagle_home was kicked by dons (dons)
23:56:33 <dejones> lol.
23:56:37 <dons> seriously. this is unacceptable.
23:56:38 <dejones> n1, gg.  :)
23:57:05 <wagle_home> dons--
23:57:14 <dejones> dons: the code?  or the lack of unit tests to catch it?  or both?
23:57:45 <dons> are people drunk, or something?
23:57:46 <Cale> wagle_home: This is #haskell, not #c :)
23:57:48 --- mode: ChanServ set -o dons
23:58:11 <Cale> wagle_home: If you're going to be offtopic, you could at least be quiet about it :)
23:58:16 <wagle_home> Cale, then kick everyone involved
23:58:41 <glguy> do it! /mkick
23:58:49 <Cale> wagle_home: The discussion is okay, just no more pastes.
23:59:00 <wagle_home> i said "i'm done"
23:59:07 <sieni> dons: not yet
23:59:08 <dons> pasting C code is definitely not ok in here ;)
23:59:19 <dons> sieni: what are you waiting for then?!
23:59:19 <wagle_home> pasting proofs is not ok?
23:59:21 <mauke> wagle_home: #haskell-blah, dude
23:59:31 <dons> hpaste.org
23:59:32 <glguy> wagle_home: use hpaste for that sort of thing
23:59:35 <wagle_home> mauke: you first
23:59:36 <mauke> and no, pasting >2 lines is not ok
23:59:51 <dons> so is some one going to turn the safeIndex thingamy into a bug report?
23:59:58 <mauke> wagle_home: eh, I'm already there
23:59:59 <Cale> (I know, I just did it a few times with that library thing, but at least that was Haskell code ;)
