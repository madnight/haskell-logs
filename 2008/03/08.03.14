00:00:03 <dons> Igloo's probably scratching around for bugs to fix.
00:00:14 <mauke> for 15 minutes, actually
00:00:37 <sieni> dons: gotta spend a day at work first :-)
00:01:05 <dejones> dons: is there no set of unit tests that are ran for the standard library in GHC?
00:01:19 <dons> dejones: sure there is, there just not complete
00:01:33 <dons> http://darcs.haskell.org/testsuite/
00:01:35 <lambdabot> Title: Index of /testsuite
00:01:59 <dejones> dons: I'm willing to help with those.  :)
00:02:16 <dons> http://darcs.haskell.org/testsuite/tests/ghc-regress/array/
00:02:17 <lambdabot> Title: Index of /testsuite/tests/ghc-regress/array
00:02:34 <dons> not nearly enough. and the array library is on its own now, so could be tested separately
00:02:44 <dons> yet another good reason to get an improved arrays lib
00:03:15 <dons> glguy: btw, re. comprehensive comprehensions, have we ever heard of anyone using them?
00:03:28 <dons> did wadler jump the shark on this one? :)
00:03:38 <glguy> dons: not to my knowledge. this seems absolutely gratutious
00:03:43 <dfranke_> dons: no he isn't... I handed him a hairy one this morning :-)
00:03:53 <dons> yav, actually, didn't SPJ say they'd only get into ghc over his dead body?
00:04:04 <dejones> lol
00:04:10 <yav> i dont know
00:04:17 <dons> at the HW.
00:04:21 <glguy> SPJ died??! :-(
00:04:37 <dons> at the end of the talk. actually, we've got that on video
00:05:08 <dejones> his dying words...  "All type systems are not equal!!!"
00:05:10 <dejones> hehe
00:05:17 <dons> Cale, so will you make a bug report about this?
00:05:19 <dons> ?bug is the url
00:05:19 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
00:08:25 <mauke> wagle_home: so are you coming or what?
00:08:37 <wagle_home> 'i said "i'm done"'
00:09:20 <wagle_home> not that dons can read or anything
00:09:26 <mauke> you also said "you first" and spammed the channel
00:09:35 <glguy> yes, let's fight about fighting
00:09:55 * dejones ...
00:10:06 <wagle_home> i spammed the channel with fewer chars than i usually type in a few minutes
00:10:11 <dons> oh man. is this still going?
00:10:12 <wagle_home> i'm done again
00:10:20 <dfranke_> glguy: now you're fighting about fighting about fighting :-)
00:10:21 <dons> ?time wagle_home
00:10:21 <lambdabot> Local time for wagle_home is Fri Mar 14 00:10:21
00:10:36 <dons> i can't explain it.
00:10:38 <glguy> dfranke_: more like *YOU* are fighting about fighting about fighting
00:10:40 <glguy> :0o
00:11:19 <dons> ;$*
00:11:21 <Cale> glguy: Is that a monocle?
00:11:38 <glguy> I think it's spelled typo :-D
00:11:38 <dfranke_> glguy: more like you are fix ("fighting about" :)
00:11:49 <Cale> Sort of looks like a Japanese style smiley with a monocle :)
00:11:58 <dejones> Well Cale, dons, glguy.. thanks for the help and I'm glad the bug was found.
00:12:02 <dejones> G'night.
00:12:04 <glguy> night
00:12:25 <dons> yeah, bed time. night all.
00:12:27 <Cale> ..:0_o
00:12:27 <dejones> I'm willing to help with writing more unit tests
00:12:30 <dons> keep those indices safe
00:12:33 <dejones> for GHC
00:12:40 <dmwit> Is there a (length . filter id) function?
00:12:42 <dejones> I'm sure that would help me learn Haskell too
00:12:43 <dejones> :)
00:12:48 <dejones> anyway, g'night.
00:22:27 <xpika> > 5 ^ (1/2)
00:22:28 <lambdabot>  Add a type signature
00:22:45 <xpika> > 5 ^ (1/2) :: Float
00:22:45 <lambdabot>  Add a type signature
00:22:49 <xpika> :(
00:22:56 <xpika> fix plz.
00:22:59 <mauke> it doesn't know which type 1/2 is supposed to be
00:23:09 <Mr_Awesome> @type (^)
00:23:09 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
00:23:32 <glguy> ^ is for non-negative integrals
00:23:32 <scook0> > 5 ** (1/2)
00:23:33 <lambdabot>  2.23606797749979
00:23:40 <glguy> *powers
00:24:01 <glguy> ^^ for potentially negative integral powers
00:24:05 <xpika> glguy: thankyou
00:24:13 <glguy> ** for fractional powers
00:24:39 <quicksilver> *^* for numbers which are integral except when there is a full moon
00:24:51 <glguy> or weekends
00:24:54 <Mr_Awesome> i dont really understand the need for multiple exponentiation functions
00:26:28 <quicksilver> better type safety
00:26:33 <wagle_home> > 2 ^^ (-2)
00:26:33 <lambdabot>  0.25
00:26:37 <quicksilver> note that 3^2 is definitely an integer
00:26:54 <quicksilver> more generally, for all b^n, b^n is the same type as b.
00:26:57 <mauke> > length "x" ** 1
00:26:57 <lambdabot>   add an instance declaration for (Floating Int)
00:26:57 <lambdabot>     In the expression: lengt...
00:26:59 <wagle_home> . o O { duh }
00:27:03 <quicksilver> if b is integer, so is b^n
00:27:14 <quicksilver> if b is real, so is b^n
00:27:33 <quicksilver> (positive) integer exponentiation is a type preserving op
00:28:18 <wagle_home> > 2^55
00:28:19 <lambdabot>  36028797018963968
00:28:34 <wagle_home> > 2^(55::Int)
00:28:35 <lambdabot>  36028797018963968
00:28:41 <wagle_home> ah good
00:28:46 <glguy> 64 bit host
00:28:56 <wagle_home> > 2^(155::Int)
00:28:57 <lambdabot>  45671926166590716193865151022383844364247891968
00:28:58 <glguy> either way
00:29:06 <glguy> integer defauting
00:29:14 <glguy> :t (^)
00:29:15 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
00:29:32 <glguy> :t 2^(155::Int)
00:29:33 <lambdabot> forall t. (Num t) => t
00:29:36 <wagle_home> yeah, but i made one of the two args Int..  was good that that didnt make the other an int
00:32:29 <wagle_home> > 2^(155::Int) :: Int
00:32:30 <lambdabot>  0
00:32:49 <wagle_home> > 2^(155::Int) - 1 :: Int
00:32:49 <lambdabot>  -1
00:33:08 <wagle_home> > (2 :: Integer)^(155::Int) - 1 :: Int
00:33:08 <solrize_> > let a = 2^(155::Int)
00:33:08 <lambdabot>  Parse error at end of input
00:33:08 <lambdabot>  Couldn't match expected type `Int' against inferred type `Integer'
00:33:15 <solrize_> @a = 2^(155::Int)
00:33:15 <lambdabot> Maybe you meant: activity activity-full admin all-dicts arr ask . ? @ v
00:33:23 <solrize_> @d a = 2^(155::Int)
00:33:23 <lambdabot> Maybe you meant: devils dice dict dict-help djinn djinn-add djinn-clr djinn-del djinn-env djinn-names djinn-ver docs dummy . ? @ id v
00:33:28 <solrize_> hm
00:33:52 <solrize_> (2::Int)^155
00:33:56 <wagle_home> > ((2 :: Integer)^(155::Int) - 1) :: Int
00:33:56 <lambdabot>  Couldn't match expected type `Int' against inferred type `Integer'
00:33:58 <solrize_> > (2::Int)^155
00:33:59 <lambdabot>  0
00:34:12 <solrize_> > (3::Int)^155
00:34:12 <lambdabot>  -1245143621
00:34:14 <wagle_home> was thinking i should get a type, not a parse, error
00:34:15 <solrize_> lol
00:34:20 <solrize_> > (3::Integer)^155
00:34:20 <lambdabot>  89907201863535854420702290135762284537312963394702682637089810488324824507
00:35:59 <wagle_home> :t (^)
00:36:01 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
00:36:29 <glguy> wagle_home: you did get a type error
00:37:01 <glguy> Oh
00:37:03 <glguy> I see
00:37:07 <wagle_home> yeah, after i parenthesized more than i thought i should need to from the previous example that i extended
00:37:07 <glguy> had to scroll up
00:39:21 <wagle_home> hmm..  seems to be a bug in lambdabots parser
00:39:42 <glguy> > () -- (
00:39:43 <lambdabot>  ()
00:39:50 <wagle_home> ghci type errors on both
00:57:51 <lispy> > 2 ^ 2 ^ 2 ^ 2 ^ 2
00:57:52 <lambdabot>  2003529930406846464979072351560255750447825475569751419265016973710894059556...
00:57:57 <lispy> > 2 ^ 2 ^ 2 ^ 2
00:57:58 <lambdabot>  65536
00:58:36 <sieni> > 9 ^ 9 ^ 9
00:58:41 <lambdabot> Terminated
00:58:59 <wagle_home> lispy, thats the easy way to compute ackerman's, you cheater!  8)
01:00:39 <tibbe> how come functions from libraries that I have installed with profiling don't show up in the profiling output?
01:01:57 <wagle_home> you compiled them with profiling?
01:08:55 <lispy> wagle_home: have you ever seen the function knuth defined?
01:09:47 <wagle_home> lispy, no..  what is it?
01:10:02 <lispy> I'm having a hard time finding it because I don't know the name
01:10:26 <Mr_Awesome> the hair-raiser?
01:11:57 <wagle_home> yargh..  cut&paste in xwindows USED TO WORK
01:12:01 <lispy> wagle_home: http://en.wikipedia.org/wiki/Knuth%27s_up-arrow_notation
01:12:02 <lambdabot> Title: Knuth's up-arrow notation - Wikipedia, the free encyclopedia
01:12:35 <wagle_home> lispy..  yeah, was trying to paste that from firefox, but xchat cant paste from firefox
01:12:45 <wagle_home> cool
01:13:03 <wagle_home> yeah, i've seen that before
01:13:07 <Zao> wagle_home: Pasting in X11 tends to work provided you have the stuff in the right buffer and have chanted the right invocations.
01:14:00 <lispy> YMMV, but X11 copy/paste/buffer system is a lot nicer than the stupid C-c and C-v bindings
01:14:21 <wagle_home> lispy *when it works*
01:14:47 <wagle_home> i'd prefer C-c and C-v to non-functional..
01:14:49 <lispy> at least with the X11 system you can do all the operations with the mouse regardless of keyboard layout
01:15:31 <wagle_home> even the new terminal emulators are breaking the whole X11 cut&paste
01:16:36 <wagle_home> oh yay..  C-c got firefox to copy the url into X11's cut buffer
01:16:46 <wagle_home> thought i'd tried that before
01:17:28 <wagle_home> oh well..  i'm just grumpy because both my apple notebooks died, one trying to save the other..
01:17:51 <wagle_home> its was sooo heroic!
01:18:32 * johnnowak_ presses command-v a few times just because he can
01:19:14 * wagle_home covers his eyes
01:20:11 <wagle_home> actually, i have an old g3 from 1998 running 10.2..  i should fire it up just to show them
01:20:14 * johnnowak drags text from his irc client to his mail client and file browser just because he can
01:20:22 * johnnowak kicks off his shoes
01:20:24 <johnnowak> ahhhh
01:28:16 <solrize_> is there a way to type-annotate a do statement at the top?  like      do :: Maybe Gizmo { ... }
01:28:27 <solrize_> in order to say what monad it belongs in
01:29:04 <Mr_Awesome> why would you want to?
01:29:10 <solrize_> makes the code clearer
01:29:22 <dmwit> annotate the function name instead
01:29:34 <solrize_> but this is inside a function
01:29:35 <dmwit> f :: Maybe Gizmo; f = do
01:29:45 <solrize_> yeah, that's ugly
01:29:55 <dmwit> ?
01:30:07 <solrize_> creates a symbol that never gets used
01:30:21 <solrize_> if i say "f = something" then i expect to have to remember f
01:30:46 <dmwit> How about a where clause?
01:30:59 <solrize_> that would be way at the end of  a multi-line do
01:31:15 <dmwit> It sounds like your function is trying to do too much.
01:31:19 <solrize_> i just want to signal at the top that i'm about to carry out a monadic calculation
01:31:38 <Mr_Awesome> "do" is a pretty obvious signal of that...
01:31:45 <solrize_> yeah but it doesn't say which monad
01:32:02 <dmwit> But why would you want to restrict it to a single monad?
01:32:03 <Mr_Awesome> is it necessary to restrict?
01:32:23 <dmwit> Oh yeah, it's just a signal.
01:32:24 <dmwit> ok
01:32:27 <solrize_> it's just like putting a type annotation on a function
01:32:31 <solrize_> it documents what's going on
01:32:47 <dmwit> It's not really possible to do what you're asking, but the fact that you ask for it signals that you are doing something that goes against the grain of the language.
01:32:49 <solrize_> the inferencer can figure it out but a human reader benefits
01:32:57 <solrize_> hmm
01:35:00 <Mr_Awesome> i would say if you feel its necessary to annotate the do block, you may want to factor it out
01:35:21 <dmwit> > and []
01:35:22 <lambdabot>  True
01:52:22 <solrize_> hmm i try to install darcs and it won't build
01:52:31 <solrize_> checking GHC.Handle.openFd... NOT old API
01:52:31 <solrize_> checking GHC.Handle.openFd new API... failed
01:52:31 <solrize_> configure: error: Couldnt figure out how to call GHC.Handle.openFd!
01:52:37 <solrize_> won't configure
01:53:31 <solrize_> GHC.Handle.openFd doesn't exist
01:56:53 <grasshopper> Hello
01:57:14 <grasshopper> This is my first time using an IRC chat.
01:57:32 <Botje> welcome!
01:58:21 <sieni> internet relay chat chat rules!"
01:59:32 <grasshopper> I will have to use more IRCs in the future.
01:59:45 <dmwit> :t fmap
01:59:46 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
01:59:58 <dmwit> :t fmap :: (a -> b) -> Either c a -> Either c b
02:00:00 <lambdabot> forall a b c. (a -> b) -> Either c a -> Either c b
02:00:04 <dmwit> aw, nuts
02:01:58 <dmwit> Well... that didn't last long.
02:09:09 <dmwit> either++
02:09:16 <dmwit> either--
02:09:21 <dmwit> catamorphisms++
02:14:45 <dmwit> I often want any2/all2 :: (a -> b -> Bool) -> [a] -> [b] -> Bool.
02:14:51 <dmwit> oh ho!
02:15:14 <dmwit> :t \xs ys f -> any (uncurry f) (xs, ys)
02:15:15 <lambdabot>     Couldn't match expected type `[(a, b)]'
02:15:15 <lambdabot>            against inferred type `(t, t1)'
02:15:15 <lambdabot>     In the second argument of `any', namely `(xs, ys)'
02:15:19 <skorpan> hey guys
02:15:21 <dmwit> :t \xs ys f -> any (curry f) (xs, ys)
02:15:22 <lambdabot>     Couldn't match expected type `Bool' against inferred type `b -> c'
02:15:22 <lambdabot>     Probable cause: `curry' is applied to too few arguments
02:15:22 <lambdabot>     In the first argument of `any', namely `(curry f)'
02:15:27 <skorpan> just came back from failing a haskell exam
02:15:34 <dmwit> skorpan: =/
02:15:42 <skorpan> yep..
02:15:43 <quicksilver> :(
02:16:07 <skorpan> i was not alone though, as several people before me handed in empty exams
02:16:29 <dmwit> Yikes!
02:16:37 <skorpan> i think i was the eighth person to hand in empty
02:16:38 <pjd> dmwit: any . zipWith ?
02:16:41 <dmwit> :t \xs ys f -> any (curry f) (zip xs ys)
02:16:42 <lambdabot>     Couldn't match expected type `Bool' against inferred type `b -> c'
02:16:42 <lambdabot>     Probable cause: `curry' is applied to too few arguments
02:16:42 <lambdabot>     In the first argument of `any', namely `(curry f)'
02:16:51 <dmwit> :t \xs ys f -> any (uncurry f) (zip xs ys)
02:16:52 <lambdabot> forall a b. [a] -> [b] -> (a -> b -> Bool) -> Bool
02:16:56 <dmwit> There it is!
02:17:07 <dmwit> I got the arguments in the wrong order, but... =)
02:17:23 <dmwit> pjd: Kind of, but I don't think exactly that.
02:17:29 <dmwit> :t (any .) . zipWith
02:17:30 <lambdabot>     Couldn't match expected type `Bool' against inferred type `[c]'
02:17:30 <lambdabot>       Expected type: (a -> b -> c) -> [a] -> [b] -> Bool
02:17:30 <lambdabot>       Inferred type: (a -> b -> c) -> [a] -> [b] -> [c]
02:18:25 <pjd> :t let (...) = (.).(.).(.) in any ... zipWith
02:18:26 <lambdabot>     Couldn't match expected type `a -> Bool'
02:18:26 <lambdabot>            against inferred type `[c]'
02:18:26 <lambdabot>     Probable cause: `zipWith' is applied to too many arguments
02:18:34 <dmwit> pjd: (((and .) .) . zipWith  -- bummer
02:18:45 <dmwit> err...
02:18:49 <pjd> :t let (...) = (.).(.).(.) in and ... zipWith
02:18:50 <lambdabot> forall a b. (a -> b -> Bool) -> [a] -> [b] -> Bool
02:18:51 <dmwit> (((and .) .) .) . zipWith
02:18:56 <pjd> there we go
02:19:16 <dmwit> I like my one better. =)
02:19:28 <skorpan> :t (.) . (.)
02:19:28 <dmwit> ?pl \f xs ys -> any (uncurry f) (zip xs ys)
02:19:28 <lambdabot> (. zip) . (.) . any . uncurry
02:19:28 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
02:21:32 <pjd> skorpan: more conventionally, (a -> b) -> (x -> y -> a) -> (x -> y -> b)
02:22:20 <trez> skorpan: how did it go?
02:22:28 <dmwit> ?hoogle uncurry3
02:22:28 <lambdabot> No matches found
02:22:38 <skorpan> trez: i handed in empty, how about you?
02:22:53 <trez> skorpan: same here :)
02:22:56 <dmwit> Wow.
02:23:05 <dmwit> It's hard to beat the average that way. =P
02:23:06 <skorpan> trez: srsly, fsck ulf
02:23:38 <dmwit> Unless it is possible to lose points by answering a question...
02:24:38 <trez> should really do some more pen'n'paper haskell so I understand my limitations :)
02:25:12 <skorpan> trez: i thought the exam was going to be more theory oriented
02:25:46 <hallongrottan> YO
02:25:51 <quicksilver> pen'n'paper programming is much harder than real programming
02:25:55 <dmwit> Hiya hallongrottan!
02:26:00 <dmwit> true, true
02:26:01 <skorpan> hallongrottan: how did the exam go?
02:26:02 <quicksilver> something which would often catch out our students.
02:26:17 <hallongrottan> skorpan: helt åt helvete
02:26:20 <skorpan> :)
02:26:23 <hallongrottan> did number 4
02:26:27 <hallongrottan> and nothing else lol
02:26:38 <dmwit> Hey, that's one more problem than most people in here.
02:26:43 <skorpan> i tried the fourth question, but couldn't figure out what he really wanted the "run" function to do
02:26:47 <hallongrottan> dmwit: sweet
02:27:05 <hallongrottan> skorpan: i named it eval and it just recurses until it finds an integer or a bool
02:27:08 <hallongrottan> sort of
02:27:14 <skorpan> hallongrottan: that's what i was thinking as well
02:27:23 <dejones> what university are you guys at?
02:27:24 <hallongrottan> and gave it like
02:27:33 <skorpan> dejones: chalmers/gothenburg's university
02:27:36 <hallongrottan> skorpan: Exp -> Either Bool Integer
02:27:39 <pjd> @djinn (a -> b -> c -> d) -> (a, b, c) -> d
02:27:39 <lambdabot> f a (b, c, d) = a b c d
02:27:41 <hallongrottan> something like that
02:27:43 <skorpan> hallongrottan: yep
02:27:54 <dejones> skorpan: cool.  :)  I'd like to be at a university that teaches/uses Haskell in a course.
02:27:54 <dmwit> :t fromList
02:27:55 <lambdabot> Not in scope: `fromList'
02:28:16 <skorpan> dejones: well, imo this course was pretty lousy :/
02:28:31 <dejones> ouch, why?
02:28:33 <skorpan> the first haskell course was great though, with john hughes
02:28:46 <hallongrottan> skorpan: i think this course is nice, however ulf is weird
02:28:51 <skorpan> dejones: well for starters we had no *real* lectures, but rather watching the teacher code
02:28:54 <hallongrottan> like the first haskell course i had was with koen claessen
02:29:00 <hallongrottan> and it was great
02:29:10 <skorpan> hallongrottan: koen would be great
02:29:17 <hallongrottan> indeed he would
02:29:27 <skorpan> i believe he really has a passion for fp and is willing to actually teach others
02:29:33 <dejones> what's the title of this course you are taing?
02:29:39 <dejones> * taking
02:29:40 <skorpan> dejones: advanced functional programming
02:30:08 <dejones> skorpan: do they use a textbook?
02:30:13 <hallongrottan> dejones: nope
02:30:16 <skorpan> dejones: no, mainly pappers
02:30:16 <dejones> that sucks
02:30:17 <skorpan> papers*
02:30:22 <hallongrottan> we had no real lectures either
02:31:02 <hallongrottan> it would have been nice with just some notes on what he coded
02:31:09 <hallongrottan> rather than just getting the code
02:31:12 <skorpan> i agree
02:31:33 <skorpan> and what's up with having a project two weeks after the course ends?
02:31:47 <hallongrottan> yeah, that's kinda weird
02:31:54 <hallongrottan> goodbye, easter
02:32:07 <dejones> skorpan: http://www.cs.chalmers.se/Cs/Grundutb/Kurser/afp/ -- is that the course?
02:32:08 <lambdabot> Title: Advanced Functional Programming
02:32:14 <hallongrottan> dejones: yes
02:32:17 <trez> well, there were slots open today to the oralexam ;)
02:32:33 <dejones> hallongrottan: seems like a cool course in the topics covered... at least, I find the projects interesting.  :)
02:32:42 <hallongrottan> dejones: yes, but like
02:32:45 <hallongrottan> the course ends NOW
02:32:58 <hallongrottan> but now we're having a project which ends in like 3 weeks
02:32:59 <hallongrottan> :s
02:33:09 <dejones> lol
02:33:20 <dejones> that seems contradictory...
02:33:23 <hallongrottan> it's an interesting course, but i think ulf made it harder than neccessary
02:33:30 <skorpan> much, much harder
02:33:37 <bringert> "2008-02-26	   	The instructions for the project are now available."
02:33:45 <bringert> just saying
02:33:48 <trez> ;)
02:33:51 <skorpan> bringert: yes, but we had a huge lab at the same time
02:34:10 <skorpan> and also, we don't read one course at a time, but two
02:34:26 <dejones> skorpan, hallongrottan, trez: have any of you read any of the textbooks that teach Haskell?  do you recommend any of the books for learning Haskell?
02:34:46 <skorpan> dejones: i haven't read any book on haskell but easily passed the previous haskell course
02:34:52 <hallongrottan> dejones: i have the "Haskell, the craft of functional programming"
02:34:55 <hallongrottan> which is quite nice
02:35:30 <skorpan> there
02:35:33 <dejones> I more interested in a book that covers the more complex topics of Haskell, such as monads and so on.
02:35:49 <bringert> I think that the problem with the current AFP course is that it hasn't changed much since the days when the 10 or so people who were really interested in FP took it. now there are what, 50 students every year?
02:35:51 <hallongrottan> dejones: my book has only one chapter on monads
02:36:03 <hallongrottan> i think it was easier learning monads by reading on the net
02:36:09 <dejones> hallongrottan: I see.
02:36:25 <bringert> there ought to be an "intermediate functional programming course"
02:36:46 <skorpan> bringert: all the people taking the course are really interested in fp, it's just that it has gotten popular
02:36:46 <dejones> did you guys already do the project:  A monad for replaying computations ??
02:36:51 <skorpan> yes dejones
02:36:55 <hallongrottan> dejones: yes
02:36:56 <skorpan> but that's a lab
02:36:58 <bringert> the step from the intro course to afp is very steep unless you have spent a lot of time learning more about haskell on your own
02:36:59 <hallongrottan> that was lab2
02:37:10 <dejones> that seems like an interesting project / lab :)
02:37:19 <hallongrottan> dejones: it sure was
02:37:24 <hallongrottan> but quite hard though
02:37:44 <bringert> skorpan: ok, true. I should have said "the 10 or so people who have learnt a lot about Haskell on their own after taking the intro course"
02:38:24 <skorpan> bringert: yes, well, personally i don't think the recommended prerequisities for the course were like that
02:38:34 <dejones> I guess they don't post the solutions to these projects / labs?  ;)
02:38:35 <bringert> skorpan: yes, that's the problem with the course
02:38:37 <skorpan> the idea is that you should be able to come straight from the intro course to the advanced course
02:38:59 <bringert> skorpan: yes, and that's wrong. that's why there should be an intermediate FP course
02:39:06 <skorpan> bringert: perhaps so
02:39:13 <hallongrottan> that would be quite nice
02:39:22 <skorpan> i'm anxious to see what the examinator says when he sees the exam results
02:39:25 * bringert was the AFP course assistant a few years ago
02:39:26 <hallongrottan> heh
02:39:41 <skorpan> bringert: datateknik student?
02:39:49 <bringert> doktorand
02:40:06 <skorpan> still at chalmers?
02:40:16 <hallongrottan> skorpan: lol maybe one of us at GU may have passed
02:40:19 <hallongrottan> out of like...10?
02:40:23 <dejones> Oh, your course is great -- they actually link the papers!  :)
02:40:32 <dejones> I'm glad I stayed up so late to find this course.
02:40:41 <dejones> 5:40am for me  :/
02:40:45 <dejones> I need to get some sleep...
02:41:15 <skorpan> the night is young! or ... morning.
02:41:17 <dejones> seems like a really interesting course
02:41:20 <dejones> good luck guys!
02:41:20 <dejones> :)
02:41:22 <dejones> later
02:41:31 <skorpan> thanks :P
02:43:09 <bringert> skorpan: yes, http://www.cs.chalmers.se/~bringert/
02:43:09 <lambdabot> Title: Bj&ouml;rn Bringert
02:44:08 <hallongrottan> lol &ouml;
02:44:16 <hallongrottan> no utf-8 for you!
02:46:21 <ketil> tibbe: you need to compile with -auto-all (or otherwise specify cost centres)
02:46:48 <ketil> (oh, drat, that was old.  Didn't realize I was scrolled back :-)
02:47:10 <bringert> hmm, lambdabot ought to decode that
02:48:04 <ketil> bringert, to UTF-8?  Are we agreed that that is the standard charset for IRC?
02:48:22 <bringert> ketil: I am agreed on that anyway :-)
02:48:28 <hallongrottan> so am i :P
02:48:44 * ketil votes for utf-8, too.
02:49:33 * sieni votes for utf-ebcdic
02:49:37 <bl> NickServ seems to vote against...
02:50:24 * ketil tried to re-nick to 'blåbærfrø', but my client, or server, or protocol seems to just chop it at the first sign of trouble.
02:50:48 <hallongrottan> ketil: norwegian :o
02:50:50 <hallongrottan> sweet
02:51:37 * ketil waves.
02:51:43 <hallongrottan> \o
03:06:51 * SamB is getting exceptions from exceptions...
03:07:29 <Zao> SamB: That's exceptional.
03:22:45 <Spockz|Laptop> hello
03:23:23 <Spockz|Laptop> when I do a --make on windows I get a bunch of files, *.h1, *.h2 and *.o
03:23:26 <Spockz|Laptop> But not an exe
03:23:55 <quicksilver> ghc --make foo.hs should create foo.exe
03:24:34 <Spockz|Laptop> it doesn't :(
03:24:44 <Spockz|Laptop> it creates those files I described above
03:25:34 <xpika> is there a way to view haskell function evaluations?
03:26:15 <quicksilver> xpika: not surewhat you mean, but it might be hat
03:26:31 <SamB> xpika: there seems to be a GHCi debugger
03:26:38 <SamB> that might do what you mean, possibly
03:29:58 <Spockz|Laptop> quicksilver: do you have any other idea?
03:31:34 <skorpan> could anyone point me to a website where they show a few concrete examples of implementations using the State monad?
03:32:10 <SamB> hmm.
03:32:32 <skorpan> there are lots and lots of theoretical explanations, but a practical example seems to be a rare finding
03:32:43 <SamB> hmm. State.
03:32:57 <byorgey> Spockz|Laptop: maybe try using the -main-is flag?
03:33:15 <SamB> well, the first thing that comes to mind is assigning unique numbers...
03:33:26 <skorpan> yes, i've actually done that
03:33:31 <skorpan> but i mean in just a bit larger scale
03:33:46 <SamB> I think I use StateT a lot more than State
03:33:54 <skorpan> i get that feeling as well
03:33:55 <byorgey> skorpan: you could look at the xmonad source =)
03:34:06 <skorpan> byorgey: ah, of course :) but... in a bit smaller scale.
03:34:37 <SamB> you basically use State when you would use StateT but you don't actually have another monad you wanted to stack it on ;-)
03:35:12 <skorpan> :)
03:36:10 <SamB> I've used StateT (Ptr Word8) IO to implement brainf*ck, I think...
03:36:47 <Spockz|Laptop> I don't have a linker installed here on this laptop
03:36:49 <Spockz|Laptop> could that be it?
03:36:56 <Spockz|Laptop> I can create an assembly file
03:37:00 <SamB> that would definately make linking hard ;-)
03:37:20 <SamB> you could use GHCi to run programs
03:37:24 <Spockz|Laptop> indeed
03:37:27 <Spockz|Laptop> i am
03:37:31 <Spockz|Laptop> but I want to link it :+
03:37:41 <Spockz|Laptop> thought that a linker was provided with the gch download
03:37:49 <SamB> what OS?
03:37:57 <Spockz|Laptop> Windows
03:38:04 <SamB> oh, yes, it should be in that case
03:38:09 <SamB> as should a C compiler
03:38:25 <Spockz|Laptop> I can create a .hc file
03:38:32 <Spockz|Laptop> from that I can create the .s file
03:38:45 <Spockz|Laptop> but I can't make a .exe
03:39:10 <SamB> what happens when you run "ghc --make hello.hs"?
03:39:42 <paolino> @hoogle m a -> m b -> m (a,b)
03:39:42 <lambdabot> Prelude.asTypeOf :: a -> a -> a
03:39:42 <lambdabot> Prelude.const :: a -> b -> a
03:39:42 <lambdabot> Prelude.seq :: a -> b -> b
03:39:47 <SamB> after writing hello.hs, of course ;-)
03:40:08 <Spockz|Laptop> SamB: it creates h1, h2 and  .o files
03:40:39 <SamB> h2?
03:40:41 <paolino> @pl \a b -> a >>= \a' -> b >>= \b' -> return (a',b')
03:40:41 <lambdabot> liftM2 (,)
03:40:42 <Spockz|Laptop> not .h1, .hi sorry
03:40:54 <SamB> what's h2?
03:41:08 <Spockz|Laptop> it's identical to hi
03:41:12 <boy> what's the @pl command do?
03:41:12 <SamB> don't you get a linker error
03:41:22 <SamB> or something ?
03:41:25 <paolino> lambdabot is fast
03:41:26 <Spockz|Laptop> C:\workspace\FunctioneelProgrammeren\src>ghc --make Mastermind.hs
03:41:26 <Spockz|Laptop> [1 of 1] Compiling Mastermind       ( Mastermind.hs, Mastermind.o )
03:41:28 <scook0> @hoogle evalStateT
03:41:28 <lambdabot> Control.Monad.State.Lazy.evalStateT :: Monad m => StateT s m a -> s -> m a
03:41:28 <lambdabot> Control.Monad.State.Strict.evalStateT :: Monad m => StateT s m a -> s -> m a
03:41:33 <Spockz|Laptop> no error
03:41:49 <SamB> and there are no .exe files in the directory afterwards?
03:42:20 <Spockz|Laptop> no there aren't
03:43:12 <SamB> peculiar
03:43:40 <SamB> well, in the directory that ghc.exe is in, what other .exe files are there?
03:48:51 <Spockz|Laptop> found the problem
03:49:07 <Spockz|Laptop> I had module Mastermind where ...
03:49:18 <quicksilver> in that case you need --main-is
03:49:21 <Spockz|Laptop> changed it to module Main where ... and now it works
03:49:24 <quicksilver> I think someone told you that a while back :P
03:49:36 <quicksilver> if you have a non-Main main you need that
03:49:43 <Spockz|Laptop> quicksilver: I thought that was about the function main :x
03:49:58 <Spockz|Laptop> which function should be the main function, not which module should be main. Sorry
03:51:17 <SamB> Spockz: both, I think?
03:51:19 <quicksilver> it's ok :) that would be sensible too
03:53:44 <Saizan> bringert: ping
03:55:37 <paolino> :t uncurry.liftM2 $ (,)
03:55:39 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => (m a1, m a2) -> m (a1, a2)
03:56:02 <paolino> @pl uncurry.liftM2 $ (,)
03:56:02 <lambdabot> uncurry (liftM2 (,))
03:56:30 <paolino> @djinn uncurry.liftM2 $ (,)
03:56:30 <lambdabot> Cannot parse command
03:57:18 <Saizan> :t uncurry . liftM2 (,)
03:57:19 <lambdabot> forall b a1 a2. (b -> a1) -> (b -> a2, b) -> (a1, a2)
03:57:22 <aleator> I want a heterogenous collection. Can I have one, or should I rather go and bang my head on the wall for wanting one?
03:57:52 <Saizan> aleator: what do you want it for?
03:57:56 <smg> aleator: you can
03:58:11 <smg> if heterogenous collection = heterogenous list *g*
03:58:22 <aleator> I know of HList and it scares me :)
03:58:51 <aleator> I have several computations (optimization methods) that I want to string one after another and record a log of their functioning.
03:59:01 <aleator> Some contain different state than others.
03:59:29 <aleator> Easiest would be to just turn everything into string and persist those, but that feels silly.
04:00:16 <Saizan> what kind of state?
04:00:26 <Saizan> and where do they get if from?
04:01:33 <aleator> They are stateful in sense that they track things like iteration count, their own internal parameters that may change from on iteration to next and so on.
04:01:44 <aleator> Each adds a layer of data after the previous one.
04:02:06 <quicksilver> you should devise a type which they are all members of
04:02:09 <quicksilver> then they are no longer hetergenous
04:02:39 <scook0> if you don't need to restore from the log, String isn't as silly as it seems
04:02:54 <aleator> Well if method A has 5 different parameters and B 10 of which 5 aren't in A and so on..
04:03:12 <aleator> So I would need a typeclass for each and that is lot of boilerplate.
04:03:47 <aleator> And unfortunately, I would also like to use the said state variables to implement stopping criterion that can be threaded through each computation.
04:03:48 <scook0> what are you planning to do with this list once you've generated it?
04:04:27 <quicksilver> aleator: I don't think you necessarily need a typeclass for each.
04:04:33 <quicksilver> in fact, I'd be surprised if you did.
04:04:49 <quicksilver> haskells type system is more expressive than most people think, especially with existentials.
04:05:21 <scook0> Data.Dynamic might be an option, too
04:06:54 <aleator> scook0: Implement a stopping condition and then of course writing a plottable log file.
04:09:12 <scook0> how is the stopping condition supposed to work?
04:10:40 <scook0> for the log file part, it's might be best to have each component format its own output into String (or whatever)
04:10:41 <aleator> It should be a function that can accept any state that contains atleast minimum amount of information and return a boolean
04:11:14 <aleator> So that basic condition can be used for all A, B and C. More specific would operate with B and C and so on.
04:12:06 <aleator> A thing that you would usually do with typeclasses and existentials I guess.
04:12:33 <scook0> you could make a "StateComponent" type, with one constructor for each possible state field
04:12:47 <scook0> and represent each component's state as a list/set/map of these fields
04:13:20 <scook0> (though this wouldn't be independently extensible)
04:13:25 <aleator> Well, collapsing the 9 different optimization algorithms into one type seems quite ugly..
04:13:37 <aleator> Perhaps I go with easy way of Map String Dynamic.
04:14:07 <scook0> that sounds promising
04:14:34 <scook0> so each stopping function can query the map for the fields it needs
04:14:46 <scook0> and if any are missing, or have the wrong type, it can declare itself inapplicable
04:14:50 <aleator> And operate in Maybe so if it can't find it it won't stop.
04:14:56 <aleator> Yes.
04:15:16 <scook0> stoppingFunc :: Map String Dynamic -> Maybe Bool
04:15:36 <aleator> It is just that extensible records would be almost exact match to what I want.
04:15:56 <scook0> do you care about the distinction between "don't stop" and "inapplicable"?
04:16:12 <scook0> otherwise you could just have inapplicable functions return False
04:17:15 <scook0> (though you could achieve a similar effect using fromMaybe False)
04:24:09 <aleator> scook0: Well.. Preferrably it shouldn't compile if it is inapplicable, but it is not that critical.
04:26:00 <scook0> oh, ok
04:26:41 <scook0> you probably can't get much better without actually encoding extensible records
04:27:07 <aleator> Or oleg'ging my brains out. :)
04:27:30 <scook0> well, that's basically what I was referring to
04:28:34 <mudge> hey, anyone want to answer a c question?
04:28:50 <Vq^> mudge: maybe...
04:28:51 <aleator> Well, there is one thing. String keys for maps are probably not so optimal. Any suggestions? (Data Key = EC | Sigma | Foo | Bar | Baz | .. extend when needed)
04:30:00 <mudge> okay, if I put a subtraction in a while condition like this: while(file_position < (file_size - string_size))   will the subtraction occur in each iteration of the loop?
04:30:16 <mudge> even if the subtraction result never changes?
04:30:24 <bringert> Saizan: pong
04:30:39 <Vq^> mudge: it might get optimized away
04:30:47 <Saizan> bringert: createTarFile tarFile [dir] and extractTarFile tarFile should be inverses right? i get *** Exception: TAR header checksum failure. on the second
04:30:58 <Vq^> mudge: but i think you should assume that it doesn't
04:31:09 <mudge> but it might not?  so to be sure perhaps I should do the subtraction before the loop and use the result in the loop
04:31:11 <mudge> to be sure
04:31:20 <Vq^> mudge: yeah
04:31:36 <scook0> either that, or examine the disassembly ;)
04:32:02 <scook0> (which of course is less portable, and not future-proof)
04:32:03 <bringert> Saizan: interesting
04:32:06 <Saizan> bringert: and i can't extract that archive with my system tar, while extractTarFile works fine on archives created with my tar
04:32:26 <bringert> Saizan: what does the system tar say?
04:33:39 <Saizan> tar: This does not look like a tar archive
04:33:39 <Saizan> tar: Skipping to next header
04:33:39 <Saizan> tar: Error exit delayed from previous errors
04:34:04 <aleator> scook0: Eh. Well. Map String Dynamic does not work for logging :)
04:34:29 <scook0> aleator: no, but there's no rule that says you have to use the same type for both purposes
04:34:51 <scook0> have each method return (Map String Dynamic, String)
04:35:04 <scook0> where the second part gets dumped straight to the log
04:35:42 <scook0> another options is Map String (Dynamic, String)
04:36:15 <bringert> Saizan: what OS is this? and what tar version? GNU tar or something else?
04:36:33 <aleator> Hmm.. Or maybe if I want to get tricky, some existential type?
04:36:40 <bringert> Saizan: though the createTarFile / extractTarFile thing is a problem regardless
04:38:07 <Saizan> bringert: tar (GNU tar) 1.18 on linux
04:39:02 <Saizan> bringert: ghc 6.8.2
04:39:03 <bringert> Saizan: if you want to figure it out yourself, get out a hex editor
04:39:17 <bringert> Saizan: or put up the produced tar file somewhere
04:39:24 <bringert> Saizan: is this the darcs version?
04:39:47 <Saizan> yes
04:40:05 <Saizan> so it works fine for you?
04:40:07 <bringert> Saizan: see http://en.wikipedia.org/wiki/Tar_(file_format)#USTAR_format
04:40:16 <bringert> Saizan: I haven't tested it in a while
04:40:50 <bringert> Saizan: will test now
04:41:11 <bringert> it could be a problem with changes in recent versions of the binary package
04:41:28 <bringert> tar should maybe be changed to not use binary
04:42:50 <Saizan> my non-using binary version gets only as far as creating an archive that produces the top-level directory when extracted, so i reported this to see if you had a fix
04:45:38 <Saizan> bringert: btw, this is the file: http:/zzodici.yi.org/s/test.tar
04:46:03 <bringert> Saizan: createTarFile / extractTarFile works for me in a simple test
04:46:52 <bringert> Saizan: can't connect to server
04:48:14 <Saizan> bringert: oh, right, dns problems, http://84.222.236.203/s/test.tar
04:51:32 <bringert> hmm, the second header seems to be off by one byte
04:52:04 <bringert> all the headers seem to be 513 bytes
04:53:44 <Saizan> oh, the type is taking 2 bytes rather than one!
04:55:09 <bringert> the file size seems to take one byte too much too
04:58:47 <bringert> Saizan: I'm off, send a patch if you figure it out
04:59:24 <Saizan> bringert: ok
05:07:53 <ndm> grr, another paper I can't get: http://www.springerlink.com/content/m8g1xu8j4801k651/
05:07:54 <lambdabot> Title: SpringerLink - Journal Article
05:08:11 <ndm> anyone able to download that for me?
05:08:17 <ndm> i thought York subscribed to springer...
05:10:36 <georgw> vincenz: You there? :-)
05:14:25 <ivanm> ndm: I'd get it for you, but my net connection is playing up (and what with having to have it go through a proxy at uni... :s )
05:16:55 <ndm> ivanm: thanks anyway - i may have found a awy to get it now
05:17:21 <ivanm> no probs
05:18:02 <ndm> have it now - i love #haskell
05:20:48 <quicksilver> #haskell - violating journal copyright day and night!
05:21:27 <ndm> quicksilver: my institution is subscribed, its just saving me a trip to the library, and finding a library photocopy card
05:21:34 <ndm> (which is really expensive in York!)
05:22:25 <quicksilver> I was being flippant.
05:22:31 <TSC> Some publishers allow you to send the papers to friends anyway (at least ACM, IIRC)
05:23:02 <quicksilver> Not that I have much patience for journals who woudl complain about such schemes. A view which is shared, presumaly, by all academics who put their papers on their webpages.
05:23:16 <quicksilver> (which these days seems to be most of them, in CS, I'm pleased to say)
05:24:37 <ndm> the next step will be for everyone to put bibtex entries for their papers on their websites
05:24:50 <quicksilver> yeah, that would be nice.
05:25:05 <quicksilver> although only if they were correct.
05:25:15 <quicksilver> Do enoguh people know how to write correct bibtex entries, I wonder? :)
05:26:18 <ndm> don't know, i'm still learning!
05:27:10 <doserj> sometimes bibtex is a bit ambiguous. especially with conference proceedings. do you use the conference title, or the book title of the proceedings?
05:27:48 <ivanm> quicksilver: you'd think at least the journals would have the bibtex entries, but I've found that that's often not the case either :(
05:46:32 <georgw> I use a let ... = in putStrLn. Now I want to have a writeFile after the PutStrLn using the result from the let, but I cannot get it into that scope despite playing around with indentation... any ideas?
05:50:06 <doserj> if you are in a do-block, remove the "in"
05:52:08 <georgw> doserj: Thx!
05:54:00 <Cheery> say, there is this hGetContents
05:54:52 <Cheery> can I put two hGetContents on the same handle?
05:54:57 <mauke> no
05:55:08 <mauke> hGetContents effectively closes the handle
05:55:26 <Cheery> !!!
05:55:27 <georgw> What is the difference between the types String and [Char]?
05:55:42 <doserj> @src String
05:55:42 <lambdabot> type String = [Char]
05:55:51 <georgw> oic, fair enough. :-)
05:56:22 <Cheery> mauke: well, can one still write stuff to the handle if the list caused by hGetContents is still available?
05:56:33 <mauke> oh, a bidirectional handle?
05:56:40 <Cheery> a socket
05:56:52 <mauke> I don't know about those
05:57:02 <mauke> it might only shutdown the read end
05:57:03 <Cheery> hm. I try. :-)
05:59:16 <Cheery> mauke!
05:59:19 <Cheery> you know what?
05:59:22 <Cheery> it works.
06:02:12 <Cheery> I think next time when I return to that project, I'm going to write the stuff that reads the first reply given by the X11
06:07:36 <quicksilver> georgw: for what its worth, there are other ways.
06:07:59 <quicksilver> georgw: let foo = bar in putStrLn "bar" >> writeFile f foo
06:08:16 <quicksilver> georgw: although doserj's answer is definitely the simplest if you're in a do block anyway.
06:08:39 <quicksilver> Cheery: hGetContents and sockets is asking for pain.
06:08:47 <quicksilver> heck, my views on lazy IO are well recorded.
06:08:50 <quicksilver> but sockets makes it worse
06:08:54 <georgw> quicksilver: oic. >> just discards...
06:09:04 <quicksilver> georgw: well it discards teh return value
06:09:13 <quicksilver> georgw: but the action still happens (the printing)
06:09:16 <georgw> quicksilver: Yep.
06:12:30 <bringert> Saizan: any luck?
06:13:45 <Saizan> bringert: i fixed the bug in my non-binary version, still no luck otherwise
06:14:14 <bringert> Saizan: I suspect putOct
06:14:32 * quicksilver considers a failblog/lambdacat crossover entitled "hGetContents is full of FAIL"
06:14:33 <bringert> it does take n, and then adds a \NUL
06:15:04 <bringert> Saizan: it should probably be take (n-1)
06:15:58 <bringert> Saizan: "Thus although there are 12 bytes reserved for storing the file size, only 11 octal digits can be stored."
06:16:28 <bringert> Saizan: can you try changing to take (n-1) in putOct and see if it fixes the problem
06:16:41 <Saizan> bringert: ok
06:16:52 <bringert> Saizan: it will only appear on very large numbers, so that's probaly why it hasn't surfaced before
06:17:05 <bringert> Saizan: but you seem to get large file sizes for directories
06:18:55 <Saizan> bringert: yeah, that's weird, sicne they are empty
06:20:26 <bringert> Saizan: what does fmap fileSize $ getSymbolicLinkStatus "foo" give you
06:21:37 <Saizan> bringert: take (n-1) fixed it, it seems
06:21:52 <bringert> Saizan: ok, I'll push that
06:21:55 <bringert> Saizan: thanks
06:22:34 <georgw> Is appending at the head of a list a hell of a lot more efficient than appending at the tail?
06:22:40 <quicksilver> yes.
06:22:42 <Irrelevant> yes
06:22:47 <quicksilver> although it's not something to worry about for small lists
06:23:03 <georgw> quicksilver: Seems to be quite an issue for a list of 100000...
06:23:04 <quicksilver> but for large lists, if you need both-end access, try Data.Sequence.
06:23:13 <quicksilver> yes, for 100,000 definitely try data.sequence
06:23:20 <georgw> quicksilver: ok, thanks.
06:23:25 <Irrelevant> or, alternatively, using prepend-lists
06:23:45 <georgw> How does data.sequence and prepend lists compare in performance?
06:23:49 <Irrelevant> i.e., instead of using an [a] that just represents the list and (++)ing them together,
06:24:08 <Irrelevant> representing a list as an ([a] -> [a]) that prepends the list itself onto its argument
06:24:13 <Irrelevant> and (.)ing them together
06:24:15 <Saizan> bringert: however that gives 17592186048512, i guess there's a bug there too
06:24:41 <quicksilver> Irrelevant's lists give better performance for concatenating.
06:24:49 <quicksilver> but Data.Sequence gives better performance for lookup
06:24:51 <Irrelevant> so [x] becomes (x:), [1,2,3] becomes ([1,2,3]++) ie ((1:).(2:).(3:))...
06:24:52 <quicksilver> and better sharing
06:25:08 <quicksilver> Data.Sequence is a much more general-purpose structure.
06:25:11 <Irrelevant> mine is nice and lightweight if you're building a list without looking at it, then flattening it down
06:25:35 <Irrelevant> but D.Seq is much more generally useful
06:25:49 <bringert> Saizan: not necessarily. how is stat(2) specified?
06:25:49 <Irrelevant> mine is the sort of thing "shows" etc use
06:25:54 <Irrelevant> ?type shows
06:25:57 <lambdabot> forall a. (Show a) => a -> String -> String
06:26:08 <tibbe> I want my process to run in the background and for main to return, how can I make my process go into a daemon mode?
06:26:17 <opqdonut> i reimplemented the standard quicksort example using prepend-lists
06:26:19 <Irrelevant> > (shows 12.34) "and some stuff after"
06:26:20 <lambdabot>  "12.34and some stuff after"
06:26:28 <opqdonut> memory usage went down to 30% but time usage stayed constant
06:26:40 <Irrelevant> > (shows 12.34 . shows True . shows [1..3]) "and some stuff after"
06:26:40 <lambdabot>  "12.34True[1,2,3]and some stuff after"
06:27:35 <bringert> tibbe: you probably need to call the posix fork
06:27:44 <Saizan> bringert: well, even for files it gives only sizes bigger than that
06:27:52 <bringert> Saizan: hmm, ok
06:28:03 <bringert> Saizan: maybe a signedness problem
06:28:12 <bringert> tibbe: http://haskell.org/ghc/docs/latest/html/libraries/unix/System-Posix-Process.html#v%3AforkProcess
06:28:13 <lambdabot> http://tinyurl.com/obhpz
06:28:23 <Saizan> probably
06:28:58 <tibbe> bringert: giant warning. basically I just want to do something like main = forkProcess myIoAction
06:29:16 <tibbe> bringert: and have my program exit and the process to continue running
06:29:24 <georgw> Irrelevant: prepend works like a charm. :-)
06:30:48 <bringert> bbl, sorry
06:31:27 <georgw> What's the inequality test operator?
06:32:27 <opqdonut> /=
06:32:37 <georgw> thanks!
06:32:38 <doserj> @src Eq
06:32:39 <lambdabot> class  Eq a  where
06:32:39 <lambdabot>     (==), (/=)   :: a -> a -> Bool
06:32:42 <ivanm> @hoogle a -> a -> Bool
06:32:42 <lambdabot> Prelude.(==) :: Eq a => a -> a -> Bool
06:32:42 <lambdabot> Prelude.(/=) :: Eq a => a -> a -> Bool
06:32:42 <lambdabot> Prelude.(<) :: Ord a => a -> a -> Bool
06:33:23 <ivanm> I thought Eq had default implementations of == and /= ...
06:33:39 <opqdonut> it does
06:33:47 <opqdonut> but not in the source lambdabot looks at
06:34:07 <ivanm> ahhh
06:34:21 <ivanm> I thought lambdabot just used the ghc source...
06:34:42 <opqdonut> no no
06:34:56 <opqdonut> it uses an "educational" version of the prelude
06:35:01 <ivanm> ahhh
06:35:06 <opqdonut> might even be the definitions from the h98 standard
06:35:10 <ivanm> does "educational" == "dumbed down"?
06:35:13 <ivanm> ;-)
06:35:24 <opqdonut> well, ommitting irrelevant stuff mostly
06:35:41 <opqdonut> but yeah, usually educational means either dumbed down :P
06:37:45 <tibbe> so forkProcess doesn't seem to do
06:39:07 <scook0> tibbe: did you fork, and then terminate the parent?
06:39:25 <tibbe> scook0: the parent terminates when end of main is reached no?
06:40:29 <scook0> no idea
06:47:55 <jacobian_> what is the function that takes (a->b)->(a -> M b) for a monad M using return called?
06:48:24 <Si\> (return.) ?
06:49:01 <ivanm> @hoogle (a -> b) -> (a -> M b)
06:49:02 <lambdabot> No matches, try a more general search
06:49:15 <ivanm> I would think return . f, where f :: a -> b
06:49:26 <Si\> yes, (return.)
06:49:48 <ivanm> ummm, yeah, didn't see the . there ;-)
06:50:23 <jacobian_> yeah, thats what I'm using now, but I read some mcbride paper where he defines a left and right bracketing
06:50:54 <georgw> can I fold over a monad?
06:51:09 <jacobian_> f:: a -> b and f> :: a -> M b and <f> :: M a -> M b
06:52:29 <shepheb> georgw: a skim through Control.Monad might be handy in general. lots of useful functions there, including foldM
06:53:10 <georgw> thx!
06:57:08 <Cheery> xdxbiiii
07:01:28 <georgw> ok, I get it. Is there a way to just use a couple of lines from within the main do block as the monad to be passed to fold?
07:01:38 <georgw> s/fold/foldM/
07:09:09 <georgw> say I have a block with a couple of putStrLn and other computations acting on one variable. Now I want to run this five times for different values of the variable. Can I just somehow wrap mapM or something similar around these lines and supply a list in order to achieve that?
07:11:44 <quicksilver> georgw: yes, of course.
07:11:55 <shepheb> georgw: should be able to do mapM_ (do $ ...those lines ...) [values]
07:12:03 <quicksilver> georgw: any "couple of lines" is a independet IO action of its own
07:12:11 <georgw> Ahh, I think I forgot the extra do...
07:12:15 <quicksilver> georgw: all the combinators can be applied to whichever group
07:12:19 <quicksilver> yea, you need the do
07:12:33 <georgw> And the parentheses, too?
07:12:35 <shepheb> also, note mapM vs. mapM_
07:12:47 <shepheb> yes, they're necessary.
07:13:38 <orzo> I want to show an integer between 0 and 255 as a two digit hex string.  The first digit should be shown as 0 if that is the case
07:13:56 <quicksilver> showHex is almost what you want.
07:13:59 <orzo> > showHex 4 $ ""
07:14:00 <quicksilver> except for the 0 part
07:14:00 <lambdabot>  "4"
07:14:29 <quicksilver> > map (\n -> tail (showHex (256+n) "")) [1,11,100,200]
07:14:30 <lambdabot>  ["01","0b","64","c8"]
07:14:50 <scook0> oh, yuck :)
07:15:06 <orzo> heh
07:18:16 <georgw> Ahhh, I love Haskell. :-)
07:18:44 <georgw> Yes, I do love it. Only problem is, sometimes Haskell does not love me. ;-)
07:18:49 <scook0> > map (printf "%02x") [1,11,100,200] :: [String]
07:18:50 <lambdabot>  ["01","0b","64","c8"]
07:19:02 <scook0> printf strikes again!
07:19:05 <orzo> oh
07:19:15 <quicksilver> heh
07:19:18 <quicksilver> good point.
07:19:30 <scook0> I have a love/hate relationship with Haskell printf
07:21:02 <JohnMeacham> mrfl
07:22:09 <orzo> hmm
07:22:52 <orzo> peekCString is ok to use on a buffer that is not null terminated, isn't it?  Because the list is lazy
07:23:08 <quicksilver> peekCString wont' be lazy.
07:23:21 <quicksilver> IO operations very rarely are (only if they cheat)
07:23:25 <quicksilver> use peekCStringLen
07:24:02 <orzo> i don't want to iterate over the whole buffer
07:24:14 <orzo> i just want the front of it as a lazy list
07:25:06 <quicksilver> peek it a bit at a time then
07:25:21 <quicksilver> or hack up something evil with unsafeInterleaveIO if you must.
07:25:54 <byorgey> orzo: if I recall what you were asking about the other day, I think unsafeInterleaveIO may actually be what you want =)
07:26:06 <byorgey> evilness notwithstanding.
07:26:43 <EvilTerran> hehe... just noticed that.
07:27:40 <vincenz> georgw: hi
07:28:28 <orzo> well
07:28:38 <orzo> actually
07:28:42 <georgw> hey vincenz. I eventually found why the last code did not find the maximum. =)
07:29:13 <orzo> right now, for testing, i just want a haskell function that will acccept a buffer and do a hex dump of it, also showing printable chars
07:29:29 <georgw> vincenz: We maximized over the candidates, but did not take into account that the current pivot might be the maximum. Easily fixed by letting the distance start at 0. All I had to change was that one byte... ;-)
07:29:43 <orzo> so i can see that the buffer is being passed correctly
07:30:24 <orzo> what's haskell for C's isprint() ?
07:30:27 <vincenz> georgw: great :)
07:31:04 <georgw> vincenz: That session yesterday was veeeery helpful. It's a great way to absorb good coding style. :-)
07:32:06 <gnuvince> :t isPrint
07:32:07 <lambdabot> Char -> Bool
07:33:16 <vincenz> georgw: :)
07:33:53 <vincenz> georgw: Have you tried to compare greedy vs selfish-greedy with this randomized approach?
07:33:55 <orzo> nice
07:34:15 <orzo> of course, i'll have to convert from CChar to Char for that
07:34:18 <vincenz> nm, those are the same
07:34:49 <vincenz> georgw: basically fill from highest density to lowest density
07:35:23 <georgw> vincenz: No, have not. Would certainly be good for initialization though.
07:35:59 <byorgey> orzo: castCCharToChar
07:36:05 <vincenz> That's the typical ... what's the name ... oh yes, heuristical approach
07:36:23 <byorgey> orzo: http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign-C-String.html#v%3AcastCCharToChar
07:36:24 <vincenz> And then I just came up with an interesting idea
07:36:24 <lambdabot> http://tinyurl.com/3454mw
07:36:31 <vincenz> You could try flipping first the least dense ones
07:36:47 <byorgey> hehe, I didn't know dcoutts was working on RWH =)
07:36:52 <byorgey> so says SPJ...
07:37:15 <vincenz> byorgey: and dons too
07:37:24 <vincenz> byorgey: I guess you saw "Ooh! Crums!"
07:37:31 <byorgey> vincenz: well, dons really IS working on RWH =)
07:37:47 <byorgey> vincenz: hehe, yes
07:37:56 <dcoutts> RWH?
07:38:01 <byorgey> Real World Haskell
07:38:01 <vincenz> dcoutts: real world haskell
07:38:03 <vincenz> dcoutts: by bos
07:38:07 <dcoutts> ohh
07:38:16 <byorgey> dcoutts: SPJ said you were working on it in his recent talk =)
07:38:21 <dcoutts> hah, no
07:38:25 <byorgey> hehe
07:38:39 <byorgey> guess he confused you with CosmicRay =)
07:38:50 <dcoutts> or maybe with dons
07:38:58 <byorgey> no, he said dons, bos, and you
07:39:03 <dcoutts> oh
07:39:10 * dcoutts has no idea
07:39:35 <byorgey> I was amused =)
07:39:38 * dcoutts is busy running other secret Haskell world domination projects
07:40:28 <orzo> what's the difference between peekCStringLen and peekCAStringLen ?
07:40:39 <dcoutts> orzo: ascii or locale encoding
07:41:13 <orzo> hm, the docs should mention that
07:41:22 <byorgey> they do.  "Currently these functions are identical to their CAString counterparts; eventually they will use an encoding determined by the current locale."
07:42:25 <orzo> > printf "%02x" 'A'
07:42:26 <lambdabot>  Add a type signature
07:42:45 <quicksilver> > printf "%02x" 'A' :: String
07:42:45 <lambdabot>  "41"
07:43:42 <CosmicRay> byorgey: should I feel left out? ;-)
07:44:48 <byorgey> CosmicRay: only if you want to, I guess =)
07:44:52 <lars_t> :t isAscii
07:44:53 <lambdabot> Char -> Bool
07:44:59 <CosmicRay> byorgey: heh
07:45:10 <CosmicRay> byorgey: I'll have to remind him of this if I see him as OSCon again this year ;-)
07:46:04 <byorgey> hehe, indeed =)
07:46:19 <quicksilver> CosmicRay: I think he owes you a lambda T-shirt in apology.
07:46:34 <CosmicRay> quicksilver: ahhh.  Yes, I agree! :-)
07:46:47 <byorgey> ooh, good point, at least get some lambda-swag out of it!
07:46:52 <quicksilver> CosmicRay: since we're on the subject, how's the book going?
07:47:05 <quicksilver> when I can order 6 copies and tell my entire team they have a new language to learn? :)
07:47:23 <CosmicRay> quicksilver: it's going well.  I think we've got about 60% of the first draft done right now.
07:47:30 <CosmicRay> quicksilver: actually we are trying to figure that out right now :-)
07:47:56 <quicksilver> :)
07:47:59 <quicksilver> nice work.
07:48:12 <CosmicRay> I think we just pushed out 2 more chapters to our alpha reviewers, and think we'll move a handful from alpha to public beta here in the next week or so
07:48:34 <CosmicRay> I really appreciate that O'Reilly is letting us post this stuff in public.  Best feedback ever.
07:48:50 <CosmicRay> I'm used to working with one or 2 tech reviewers.  100 feels a bit different. ;-)
07:49:34 <resiak> Is the book going to stay on the 'tubes once it's published?
07:50:14 <CosmicRay> resiak: I don't know for sure what the plans are, but it's licensed under CC Attribution-Noncommercial, so I'd say it almost certainly will be present in some fashion or other
07:50:29 <resiak> oh, so it is
07:50:39 <CosmicRay> I think bos told me this is the first book O'Reilly is doing under a CC license
07:51:36 <resiak> I guess that the public review process doubles as free publicity
07:51:37 <CosmicRay> so if it works out well, I wouldn't be surprised to see more books following this model.
07:51:45 <kaol> CosmicRay: would you package it for non-free?
07:53:00 <CosmicRay> kaol: heh.  I guess I could consider it.
07:55:11 <CosmicRay> kaol: it would be ironic for me, who has been trying to rid Debian of non-free for 8 years, to upload something to it... that I'm an author of, no less.
07:55:48 <skorpan> data (Eq, Show) a => Rank a = String a
07:55:55 <skorpan> how do i do that? you all know what i mean i hope
07:56:11 <skorpan> nvm, figured it out
08:01:47 <quicksilver> skorpan: (a) don't bother there is no point
08:01:56 <skorpan> quicksilver: i know there is no point, it was just an example
08:01:57 <quicksilver> (b) use GADT syntax
08:02:04 <quicksilver> there is no point for any example.
08:02:08 <quicksilver> not just that example :P
08:02:21 <quicksilver> haskell 98 can't express what you want.
08:02:22 <skorpan> what is there no point to?
08:02:26 <skorpan> what no+
08:02:27 <skorpan> SNHOH
08:02:38 <quicksilver> trying to attach a class to a type in this way.
08:02:48 <quicksilver> GHC can express it via its GADT extension
08:02:52 <skorpan> ah, of course
08:03:01 <skorpan> you're absolutely right
08:03:06 <quicksilver> but it's only genuinely helpful if you have multiple constructors giving rise to different contexts.
08:03:17 <quicksilver> that's a bit obscure but it's useful if it's what you need.
08:03:30 <quicksilver> data Foo = Show a => Foo a | Eq b => Bar b
08:03:33 <quicksilver> (pseudo-syntax)
08:03:51 <skorpan> well i'm creating a DSL for board games and i was thinking of letting the user of the DSL specify her own ranks for the pieces on the board
08:04:01 <skorpan> such as King, Queen, Pawn, etc.
08:05:01 <orzo> how do i turn an Int into a CSize?
08:05:15 <skorpan> 5 :: CSize no?
08:05:30 <kpreid> @info CSize
08:05:30 <lambdabot> CSize
08:05:34 <kpreid> er
08:06:22 <shapr> skorpan: I think you should write a DSL that woks for two or three board games, then keep applying it to more. You'll quickly end up with something that works :-)
08:06:37 <orzo> rest = len - (fromEnum line_len :: CSize)
08:06:41 <orzo> it's not liking that
08:06:48 <quicksilver> fromIntegral, perhaps?
08:06:56 * shapr tries to remember what map is called in C#
08:06:57 <orzo> it's infering Int for the second parameter
08:07:05 <skorpan> shapr: "loop"
08:07:22 <orzo> fromIntegral worked
08:07:22 <shapr> skorpan: .Select() I think
08:07:44 <orzo> i used fromEnum elsewhere to get from Csize to Int
08:08:01 <orzo> is that proper?
08:08:46 <doserj> orzo: (fromEnum line_len :: CSize) /= fromEnum (line_len :: CSize)
08:08:49 <skorpan> shapr: do you program C# for work or just for painful pleasure?
08:09:05 <shapr> skorpan: For work these days
08:09:12 <skorpan> cool
08:09:23 <shapr> But right now I'm trying to write a deeply recursive lambda in C# and getting frustrated.
08:10:06 <orzo> doserj, i meant the first
08:10:19 <orzo> i'm converting to CSize
08:10:42 <orzo> line_len is Int
08:10:42 <doserj> @type fromEnum
08:10:43 <lambdabot> forall a. (Enum a) => a -> Int
08:10:54 <doserj> but fromEnum doesn't convert to CSize
08:11:07 <orzo> well that's what i was doing wrong
08:26:30 <desegnis> @src Enum
08:26:30 <lambdabot> class  Enum a   where
08:26:30 <lambdabot>     succ                     :: a -> a
08:26:30 <lambdabot>     pred                     :: a -> a
08:26:31 <lambdabot>     toEnum                   :: Int -> a
08:26:33 <lambdabot>     fromEnum                 :: a -> Int
08:26:35 <lambdabot> [3 @more lines]
08:27:16 * desegnis observes a symmetry
08:28:15 <kaol> @more
08:28:15 <lambdabot>     enumFrom                 :: a -> [a]
08:28:15 <lambdabot>     enumFromThen, enumFromTo :: a -> a -> [a]
08:28:15 <lambdabot>     enumFromThenTo           :: a -> a -> a -> [a]
08:28:49 <mm_freak> hi people…  which data structure would you recommend for the list of objects in games?  iteration should be O(N) and random access via identifier should be O(log N) if possible
08:29:39 <opqdonut> Map?
08:29:54 <quicksilver> mm_freak: Data.Sequence
08:30:00 <quicksilver> erm
08:30:08 <quicksilver> Data.Sequence if the IDs are all sequential.
08:30:13 <quicksilver> if they're not, then Data.Map
08:30:28 <shapr> FingerTrees? :-)
08:30:29 <desegnis> mm_freak, what are the characteristics of those "objects"? Are there identical objects, are there a zillion objects, ...
08:30:31 <mm_freak> nope, the IDs are pretty random
08:30:42 <quicksilver> Data.Map or Data.IntMap
08:31:33 <mm_freak> desegnis: data Object = …
08:31:51 <mm_freak> which can be anything from particles or particle groups to menus, enemies, geometry, etc.
08:32:48 <mm_freak> is Data.IntMap much faster than Data.Map for lookup?  i expect a few dozens of queries per frame
08:33:06 <opqdonut> btw you need an ordering for the identifiers
08:33:35 <mm_freak> yeah, i assumed so, but that's no problem
08:34:41 <byorgey> mm_freak: IntMap might be faster, you should try both and see if you get better performance.
08:35:13 <quicksilver> IntMap should be quite a bit faster as the number of elements gets large.
08:35:18 <desegnis> sounds like you're looking for a collection type to hold _all_ objects of a game in one structure? But, oh, I know nothing about common practices in game design anyway
08:35:25 <quicksilver> I havn'et compared them though
08:35:53 <mm_freak> it's not very easy to "try both"…  trying IntMap either means preprocessing maps or finding a good hash function
08:36:06 <quicksilver> and, your ID isn't an integer?
08:36:13 <mm_freak> String
08:36:15 <quicksilver> I mean, "ah, your ID isn't an integer"
08:36:19 <quicksilver> ok, use Data.Map
08:36:22 <quicksilver> and don't worry too much :)
08:36:27 <quicksilver> I think it'll be fine.
08:36:27 <mm_freak> hehe
08:36:41 <mm_freak> i think so, too…  at least on modern archs
08:36:54 <quicksilver> that is, I suspect you will have other bottlenecks in your program befrore you worry about Data.Map.lookup on a few thousands of objects.
08:39:34 <mm_freak> hmm…  i'm afraid, i'll end up writing my own data structure
08:39:50 <mm_freak> is there an easy way to nest Map without Either?
08:40:07 <quicksilver> ehm, I don't know what you mean on several levels.
08:40:15 <quicksilver> you can put anythign inside a map including other maps.
08:40:19 <quicksilver> so, yes, you can nest them.
08:40:38 <quicksilver> However, you shouldn't be "afraid" of writing your own data type, if that's what you meant.
08:40:49 <quicksilver> Writing your own data types is one of the first stages of haskell program design.
08:41:00 <dmwit> But there's a one-eighth chance of a magical explosion!
08:41:06 <quicksilver> (If you really meant your own data *structure*, then no, I wouldn't think you need to do that)
08:41:19 <mm_freak> sure, but not if i'm reinventing the steel (not learning haskell at the same time)
08:41:29 <mm_freak> uhm
08:41:31 <mm_freak> the wheel =)
08:42:13 <dmwit> Of course, if you stuff the Map in an IntMap, the chance of explosion drops by a factor of two with each additional IntMap wrapping, to a minimum of 1/256 chance of explosion.
08:42:41 <quicksilver> mm_freak: if you want useful advice you're going to have to explaina little more
08:42:44 <quicksilver> ;)
08:43:30 <georgw> how can I find the hamming distance of two lists? I.e. I want to count at which positions two lists differ. Is there a function for that or do I have to string together zipWith, filter and length?
08:44:01 <mm_freak> quicksilver: nevermind, i've found a solution =)
08:44:18 <quicksilver> georgw: sounds like a reasonable approach to me.
08:44:37 <dmwit> georgw: Are you talking about something like the diff algorithm?
08:44:57 <mm_freak> data Object = Group (Map String Object) | …
08:45:13 <quicksilver> sum (zipWith (\a b -> if a == b then 0 else 1) l1 l2)
08:45:14 <quicksilver> perhaps.
08:45:24 <quicksilver> cunningly using sum instead of length + filter.
08:45:34 <dmwit> georgw: Never mind, from looking up Hamming Distance I see you are not.
08:46:07 <kpreid> @type length . filter id . zipWith (==)
08:46:08 <lambdabot>     Couldn't match expected type `[Bool]'
08:46:08 <lambdabot>            against inferred type `[a] -> [Bool]'
08:46:08 <lambdabot>     Probable cause: `zipWith' is applied to too few arguments
08:46:22 <dmwit> :t (length . filter id .) . zipWith (==)
08:46:22 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Int
08:47:02 <dmwit> :t bool
08:47:03 <lambdabot> Not in scope: `bool'
08:47:45 <dmwit> :t let bool a b p = if p then a else b in (sum .) . zipWith ((bool 0 1 .) . (==))
08:47:46 <lambdabot> forall a a1. (Eq a1, Num a) => [a1] -> [a1] -> a
08:48:03 <kpreid> I'm mildly surprised there's no count (count f xs = length (filter f xs))
08:48:20 * dmwit practices his pl-foo
08:50:46 <mm_freak> i'm passing global configurations (like command line flags) as implicit parameters currently…  is this a good approach for this kind of configuration?
08:51:14 <quicksilver> in my opinion, no.
08:51:16 <byorgey> :t sum.zipWith((fromEnum.).(==))
08:51:17 <lambdabot>     Couldn't match expected type `[a]'
08:51:17 <lambdabot>            against inferred type `[a1] -> [Int]'
08:51:17 <lambdabot>     Probable cause: `zipWith' is applied to too few arguments
08:51:19 <dmwit> I'd prefer a Reader monad.
08:51:22 <quicksilver> I think implicit parameters are the spawn of the devil.
08:51:27 <quicksilver> it's your call, though.
08:51:43 <byorgey> :t ((sum.).).zipWith((fromEnum.).(==))
08:51:44 <dmwit> :t (sum .) . zipWith ((fromEnum .) . (==))
08:51:44 <lambdabot>     Couldn't match expected type `[a]' against inferred type `Int'
08:51:44 <lambdabot>       Expected type: [a1] -> [a1] -> [[a]]
08:51:44 <lambdabot>       Inferred type: [a1] -> [a1] -> [Int]
08:51:45 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Int
08:52:02 <mm_freak> they're quite handy, and i don't need monads
08:52:09 <byorgey> hm, now we'll never know which one was correct =)
08:52:15 <dmwit> It was mine. ;-)
08:52:16 <shapr> kpreid: What about atLeast n for lazy sequences?
08:52:28 <byorgey> dmwit: hm, so it was =)
08:52:28 <quicksilver> kpreid: yea, and count2 which combines that with zipWith
08:52:54 <kpreid> shapr: well, that's why filter + length-or-something-else is a better idea, I suppose -- less combination explosion
08:53:37 <byorgey> mm_freak: I've never seen anyone actually use implicit parameters.
08:53:46 <shapr> byorgey: I have.. it's scary.
08:54:35 <mm_freak> well, explicit passing and implicit configurations via the type-class system would be the alternatives
08:55:01 <mm_freak> the former is pretty ugly, and the latter appears like overkill to me, and it isn't quite as handy at some places, because it's always bound to a type
08:55:24 <quicksilver> I don't find explicit passing ugly, actually.
08:55:31 <quicksilver> I like to be able to see all the dependencies of my function
08:55:34 <quicksilver> (data dependencies)
08:55:36 <quicksilver> in its type
08:55:48 <mm_freak> you see them with impl. parameters as well
08:55:50 <quicksilver> I can see "this fuction uses the global config, and this one doesn't"
08:56:05 <mm_freak> func :: (?cfg :: Config) => Blah -> Blah
08:56:13 <quicksilver> yes, that's true.
08:57:00 <shapr> I've seen several problems with implicit parameters, but I forget the details.
08:57:10 <mm_freak> you just don't see it at the place where the function is called…  that's a benefit and a drawback
08:57:19 <georgw> Ok... this is probably trivial, but I don't see it: knapsack10.hs:62:61:
08:57:19 <georgw>     Couldn't match expected type `[Seq Bool]'
08:57:19 <georgw>            against inferred type `RandomState [Seq Bool]'
08:57:34 <shapr> mm_freak: I'd rather seen the monadic type signature myself.
08:58:02 <quicksilver> mm_freak: if you find them to work for you, then that's fine with me.
08:58:02 <georgw> I have to do some arrow trickery when dealing with state, right? Some monad stuff in there...
08:58:11 <quicksilver> I agree that ReaderT is noisy
08:58:14 <quicksilver> you have two choices:
08:58:31 <quicksilver> you either have some annotation over functions with don't need the config
08:58:35 <quicksilver> or some over functions which do.
08:58:54 <quicksilver> a third choice is to make every function need the config, even those that don't need it, but I think that's nasty.
09:00:03 <quicksilver> unfortunately I can no longer recall the line of reasoning which led me to conclude that implicit parameters were evil.
09:00:07 <quicksilver> Which is a shame.
09:00:18 <quicksilver> I just remember with certainty the conclusion I reached :)
09:00:25 <shapr> I can't remember the details of my experiences either, but they were enough to leave a powerful impression.
09:00:34 <mm_freak> hmm…  i'll have a closer look at the Reader monad, but i really wouldn't like to use monads, where they're actually not necessary
09:00:48 <quicksilver> mm_freak: why would you not want to?
09:00:58 <quicksilver> what is the perceived disadvantage of "using monads"
09:01:01 <shapr> mm_freak: Technically speaking, they're never really necessary, much like objects are never really necessary. You could do it all yourself.
09:01:13 <quicksilver> would you feel better if we renamed "ReaderT" "type safe implicit parameters"?
09:01:19 <quicksilver> and if we didn't discuss the fact it was a monad?
09:01:49 <mm_freak> well, you're right
09:02:21 <quicksilver> to my mind the disadvantage of ReaderT is the extra syntax to extract the value
09:02:29 <quicksilver> and the need to lift stuff, if you've got layered monads.
09:02:43 <quicksilver> that is why I end up fairly often just using an explict parameter.
09:02:51 <shapr> State and Reader monads are explicit passing done implicitly.
09:03:14 <quicksilver> well clearly.
09:03:15 <shapr> mm_freak: I would also like to know why you don't want to use monads.
09:03:28 <quicksilver> the question is to what extent they really are "implicit"
09:03:39 <quicksilver> that is, how much syntax do they cause vs. the syntax they save
09:03:50 <quicksilver> I find in simple cases they don't always pay their way
09:03:53 <ivan_> how does arrows work, where can i read about them?
09:04:07 <quicksilver> conversely in really large complex cases, they make a more convincing case.
09:04:08 <quicksilver> IMO.
09:04:12 <shapr> ivan_: http://www.haskell.org/arrows/ last I checked
09:04:13 <lambdabot> Title: Arrows: A General Interface to Computation
09:05:02 <ivan_> shapr: so they are written by john =)
09:05:05 <shapr> ivan_: And in a nutshell, they're a lot like monads, but one step up the abstraction hierarchy.
09:05:16 <shapr> ivan_: Well, sort of...
09:05:28 <quicksilver> I think they are a step sideways, really.
09:05:31 <ivan_> shapr: better go ask him =)
09:05:39 <shapr> ivan_: I already did!
09:05:58 <shapr> He gave a talk at EuroHaskell about Arrows, and how he jumped from monads to arrows.
09:06:19 <ivan_> shapr: no i mean i can go an ask him so he can explain it for me =)
09:06:23 <quicksilver> what's quite interesting, and I would like to see a really insightful article/paper about
09:06:23 <shapr> oh
09:06:37 <shapr> ivan_: Make sure and ask him about his experiences on the unicycle at EuroHaskell ;-)
09:06:40 <quicksilver> is the sense in which Applicative and Arrow are *different* steps back from Monad.
09:06:47 <skorpan> damn those unicycles
09:07:00 <skorpan> how come all functional programmers ride unicycles?
09:07:02 <ivan_> shapr: i will =)
09:07:20 <shapr> skorpan: I can sell you a used unicycle cheap...
09:07:27 <shapr> You just have to pick it up from my ex in Stockholm.
09:07:38 <skorpan> where in stockholm?
09:07:45 <shapr> Sundbyberg
09:08:05 <skorpan> my mom used to live in sundbyberg
09:08:11 <Philippa> skorpan: we've got rid of our training wheel
09:08:22 <quicksilver> *rimshot*
09:09:03 <skorpan> you're doing a nice rim job
09:09:21 <shapr> Aanyway...
09:09:33 <shapr> C# still isn't Haskell :-/
09:09:57 <shapr> quicksilver: It's a lattice.
09:10:13 <quicksilver> shapr: *nod* but that wasn't actually my question.
09:10:40 <shapr> My question would be, what are the various steps/properties, and how are the different vertices useful to me?
09:10:41 <quicksilver> skorpan: ick :P
09:10:44 <shapr> What's your question?
09:11:03 <quicksilver> shapr: my question is: as why would you step back to arrow, and why would you step back to applicative
09:11:12 <quicksilver> compare and contrast them computational
09:11:18 <shapr> oh
09:11:41 <shapr> Arrows alone can skip more computation than monads.
09:12:18 <shapr> quicksilver: http://www.cs.helsinki.fi/u/ekarttun/haskell/blackhole.txt
09:13:14 <shapr> But when you add functions, it doesn't work so well.
09:13:23 <quicksilver> yes, that's not the beginning and the end of the story though.
09:13:28 <shapr> Yeah, true
09:13:30 <quicksilver> it's certainly a data point.
09:13:35 <quicksilver> but they are useful for something.
09:13:40 <shapr> Yup, very much so.
09:13:46 <quicksilver> that invertible parsers paper, for example.
09:14:03 <quicksilver> on the other hand, some things which are claimed to be arrows are not, and that muddies the water
09:14:06 * quicksilver is looking at conal here
09:14:18 <Philippa> those aren't "claimed to be arrows", they're just stupidly named
09:14:34 <quicksilver> they implement the Arrow class.
09:14:38 <gregwebs> I would greatly appreciate it if anyone can help me with an install problem http://hpaste.org/6360
09:14:42 <shapr> Of course, Arrows, like Monads, are Monoids - http://lambda-the-ultimate.org/node/1750
09:14:43 <quicksilver> or in at least some versions they do.
09:14:45 <lambdabot> Title: Arrows, like Monads, are Monoids | Lambda the Ultimate
09:14:52 <quicksilver> they strikes me as claiming :)
09:14:57 <Philippa> quicksilver: monads support higher-order computations, which comes with a pile of problems for static analyses
09:15:03 <quicksilver> shapr: ehm but that's pretty obvious :P
09:15:14 <shapr> That wasn't originally obvious.
09:15:44 <shapr> When arrows were just Weak Freyd Categories, nobody had much of a clue how they connected to monads.
09:16:27 <quicksilver> shapr: I meant it was obvious they were monoids.
09:17:23 <quicksilver> Philippa: yes, that's more the kind of answer I was looking for.
09:17:45 <quicksilver> Philippa: But i was saying it would be nice to have a rather practically oriented overview of the kinds of things you can do with Arrow vs Monad vs Applicative
09:17:52 <shapr> quicksilver: Maybe you should write a blog post about other obvious stuff then, much of this is not obvious to me.
09:17:53 <quicksilver> Philippa: I know youa nd I were talking about it a couple of weeks ago.
09:18:07 <shapr> quicksilver: Go for it!
09:18:10 <shapr> Sounds great, I'll learn lots!
09:18:23 <quicksilver> shapr: are you saying that it wasn't obvious that (pure id) was an identity for a monoid with operation (>>>) ?
09:19:03 <opqdonut> :)
09:19:17 <Philippa> quicksilver: most of the practical stuff is going to be in terms of which kinds of analyses you need to be able to support and/or restrictions you need to be able to enforce
09:20:22 <Philippa> there's probably a neat invariant or two you can find about space usage and/or references in Applicatives-with-no-extras
09:20:28 <shapr> quicksilver: That part I can handle.
09:20:49 <Philippa> but really the big deal for them is that they're general enough to pull the kinds of tricks in the Idioms paper
09:21:04 <shapr> quicksilver: Anyway, are you going to write this overview?
09:21:57 <Gilly> which is faster, to create a Data.Sequence by appending elements into the right end using |> and then using toList to create a list or to create a list using standard : and then reversing it in the end?
09:22:10 <quicksilver> shapr: no, because I don't now the answers :)
09:22:18 <shapr> What better way to find those answers? :-)
09:22:20 <Philippa> Gilly: I suspect the former for big enough lists, but you'd have to benchmark
09:22:26 <shapr> Force that thunk!
09:22:40 <mm_freak> shapr: because monads somehow substitute inconvenience by complexity
09:22:52 <Philippa> ...actually, it probably depends on how the result list's consumed
09:23:00 <Gilly> strict stuff
09:23:14 <Gilly> i'm creating this in io monad, reading from handle
09:23:18 <Philippa> could be either way then, benchmark it
09:23:59 <Gilly> i was just wondering that reversing a list could be a long operation, to reach the last element doesn't it have to traverse all the way back there?
09:25:03 <Philippa> it does, yes. Once you've paid that cost the rest's cheap though
09:25:25 <Philippa> and |> is more expensive than : and toList won't be cheap either
09:25:38 <Philippa> what with it involving traversing the entire Seq
09:25:50 <Gilly> hm, but when it reverses will it have to keep a giant stack?
09:26:06 <Gilly> like going into that very end then comin back the recursion hierarchy
09:26:32 <Philippa> yeah, it will briefly
09:26:49 <Philippa> I don't think GHC does tail-modulo-cons optimisations
09:26:58 <Gilly> that might be bad if i have long chunks of data... speaking of megabytes here :P
09:27:28 <Gilly> though, bytestrings might be better anyways then
09:28:27 <Philippa> yeah, quite possibly
09:28:39 <tromp> see how much slower sum reverse [1..1000000] is compared to sum [1..1000000]
09:30:08 <Gilly> oh but bytestring append is o(n)... that's not nice either
09:31:13 <dcoutts> Gilly: lazy bytestring have faster append
09:31:50 <opqdonut> you might want to try append-lists
09:31:54 <opqdonut> *prepend-lists
09:32:06 <shepheb> reverse is tail recursive, I thought. it's strict, and takes O(n) time, but it doesn't blow up the stack. or am I wrong?
09:32:07 <opqdonut> instead of using [a] you use [a]->[a] and ++ becomes .
09:32:09 <Gilly> dcoutts: what does O(n\c) mean there?
09:32:29 <dcoutts> Gilly: c is the chunk size
09:33:06 <dcoutts> Gilly: a lazy bytestring is basically a list of strict bytestrings, so append just appends the lists of chunks
09:33:44 <Gilly> ah, nice
09:34:19 <opqdonut> Gilly: if you need only fast appending, use prepend-lists :)
09:34:34 <Gilly> opqdonut: yea i got to figure out what i actually will need :P
09:35:05 <Gilly> well, i'll need to get an ordinary string or a bytestring out of it
09:35:21 <quicksilver> if you're dealing with medium sized data with a wide range of access patterns, Seq is probably good.
09:35:24 <Gilly> since i'm running this in cgi monad and it provides output and outputFPS
09:35:33 <quicksilver> if you're dealing with HUGE data then you'll probably want ByteString.
09:35:44 <quicksilver> but the overhead of Seq Char is pretty high if you don't really need all those features.
09:35:49 <desegnis> shepheb: Yes, reverse is tail recursive, because it's a left-fold
09:36:12 <dcoutts> Gilly: a lazy bytestring is an ideal output form for cgi, I hope outputFPS does not require a strict bytestring, that'd be very wasteful
09:36:20 <roconnor> @src reverse
09:36:21 <lambdabot> reverse = foldl (flip (:)) []
09:37:04 <Gilly> dcoutts: yea i guess i'll go with that :)
09:37:20 <shepheb> yes, okay. just trying to confirm my thinking. it would be foldl', of course, in Data.List. thanks.
09:39:37 <quicksilver> dcoutts: well, a one-off copy from lazy to string is only a malloc + memcpy, surely?
09:39:47 <quicksilver> dcoutts: technically it's wasteful but it's not exactly going ot be a problem.
09:40:56 <desegnis> GHC defines an own version of reverse, which is just the left fold written out... Is that for performance reasons?
09:41:25 <opqdonut> the ghc source is kinda funny with functions like that
09:41:27 <opqdonut> dunno why
09:41:33 <desegnis> ha :)
09:41:42 <ivan_> need a little help with arrows i want to use arows for some kind of circuit like in---[f]--out, so i want to pass a value into in and evaluate f for that value and return value in out? which arrow lib am i suposed to use?
09:42:18 <opqdonut> why are you using arrows? for introspection?
09:42:51 <ivan_> dunno, just want to test them =)
09:43:00 <Philippa> ivan: you're probably 'supposed' to write your own Arrow
09:43:08 <Philippa> that is, an instance of the Arrow class as in Control.Arrow
09:43:41 <opqdonut> yeah
09:43:43 <ivan_> yea that could be the case =) i am defining transferfunctions, and i need to evaluate the under a givven frequency as input
09:47:05 <desegnis> shepheb: foldl' wouldn't gain anything here because, I think, you'd only force the (:) constructor, and there's nothing to reduce about it
09:48:27 <gregwebs> can anyone help me with an install problem?
09:52:21 <Lemmih> gregwebs: Just ask.
09:52:39 <gregwebs> Thanks,http://hpaste.org/6360
09:53:21 <skorpan> http://en.wikibooks.org/wiki/Haskell/State <- someone should fill in some neat info
09:53:22 <lambdabot> Title: Haskell/State - Wikibooks, collection of open-content textbooks
09:54:19 <Lemmih> gregwebs: Make sure 'cabal' is using the correct ghc binary.
09:54:38 <Lemmih> gregwebs: Then check if you can load 'pretty' in ghci.
09:55:34 <fons> hi all
09:55:43 <fons> I have a question regarding monad transformers
09:56:09 <fons> type TravSEIO s e a = (StateT s (ErrorT e IO)) a
09:56:25 <fons> I have, as typed above, a stack of two transformers
09:56:58 <fons> lifting an "IO a" value to TravSEIO is easy: I just need to use (lift.liftIO)
09:58:31 <fons> but ... how can I lift teh value returned by a function which can lead to errors but which, doesn't output IO values?
09:58:38 <wy> Stephen Weeks is going to phone interview me in an hour. What's the best topic to come up with him?
09:59:02 <opqdonut> fons: lift.liftIO.return?
09:59:06 <skorpan> wy: who is he?
09:59:13 <wy> author of MLton
09:59:18 <skorpan> what is MLton?
09:59:22 <mrd> heh
09:59:27 <skorpan> ML thing?
09:59:37 <mrd> whole program SML compiler
09:59:39 <wy> i'm applying an internship at Jane Street
09:59:56 <fons> opqdonut: not really, the value to be lift is not a, but Either e a
10:00:02 <wy> I haven't tried it though. It seems to be fast
10:00:09 <fons> to be lifted*
10:00:10 <mrd> yes, it's probably the 2nd most popular impl
10:00:28 <wy> Is partial evaluation a good topic?
10:00:29 <mrd> are you applying to work on compilers? =)
10:00:33 <opqdonut> fons: hmm, something like "fmap return" then
10:00:46 <wy> It's best if I can work on compilers intead of applications
10:01:01 <Lemmih> fons: Plain 'lift'?
10:01:39 <fons> Lemmih: you are right
10:01:44 <sebell> I thought liftIO takes care of the necessary (lift . lift)... etc, should you only need one?
10:02:11 <fons> sebell: no, you need to compose various lifts to reach different levels of the stack
10:02:27 <quicksilver> fons: you are incorrect.
10:02:43 <opqdonut> different levels by typing?
10:02:44 <quicksilver> fons: the purpose of the classes (MonadIO, MonadState, etc)
10:02:50 <quicksilver> is that you never need to compose lifts.
10:03:00 <quicksilver> get, put, ask, liftIO
10:03:04 <quicksilver> all these work at any level.
10:03:12 <fons> Lemmih: oh, now I get it, and actually it semantically works as expected.
10:03:42 <hpaste>  (anonymous) pasted "more install problems" at http://hpaste.org/6361
10:04:06 <fons> quicksilver: let me check it again
10:04:26 <gregwebs> Lemmih, http://hpaste.org/6361
10:04:41 <davidL> is anyone here familiar with House's TCP stack?
10:04:41 <lambdabot> davidL: You have 1 new message. '/msg lambdabot @messages' to read it.
10:05:11 <Lemmih> gregwebs: ghci -package pretty.
10:05:20 <fons> quicksilver: then I must be missing something important, using barely liftIO to lift an IO value in the transformer stack I typed above leads to this error
10:05:22 <fons>     Couldn't match expected type `ErrorT e IO'
10:05:23 <fons>            against inferred type `IO'
10:05:33 <fons> lift.liftIO works just fine
10:05:40 <gregwebs> ghc-6.8.2: can't load .so/.DLL for: HSpretty-1.0.0.0
10:07:03 <fons> quicksilver: actually, see the all about monads tutorial http://www.haskell.org/all_about_monads/html/stacking.html
10:07:03 <lambdabot> Title: Managing the transformer stack
10:07:17 <fons> quicksilver: When using lifting with complex transformer stacks, you may find yourself composing multiple lifts, like lift . lift . lift $ f x
10:07:50 <opqdonut> :t lift
10:07:53 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Monad m, MonadTrans t) => m a -> t m a
10:07:59 <sebell> fons: Yeah, but liftIO is different. Both StateT and ErrorT are instances of MonadIO
10:08:44 <AMcBain> Is there any place I can get a downloadable PDF with an index of language commands? I have one for Scheme and have an assignment due in Haskell after my spring break, but this PC doesn't have WiFi (Linux + proprietary cards = evil!!!) and that's all I have at home ...
10:08:45 <fons> so, the goal of stacking is to be able to keep using get, put, throwError ... regardless of the srack but I think lift works differently
10:09:22 <fons> sebell: uhm, let me check again
10:09:23 <skorpan> is there any con in using the same constructor name as the data type itself?
10:09:25 * fons is a bit confused
10:09:32 <skorpan> e.g. data Hello = Hello String | Hello Int
10:09:39 <opqdonut> skorpan: not really
10:09:45 <skorpan> good
10:09:46 <Cale> skorpan: You can't name multiple constructors the same thing.
10:09:52 <opqdonut> errr except yeah
10:09:52 <sebell> skorpan: Not that way ;)
10:09:54 <lament> AMcBain: use windows :)
10:09:58 <skorpan> :/
10:09:59 <opqdonut> different constructors need to be distinct
10:10:10 <skorpan> okay
10:10:22 <opqdonut> but one of them can have the same name as the type
10:10:30 <AMcBain> lament: Well gee thanks for the enlightenment :-/ I have Windows under a VM, but as such, it doesn't see any hardware.
10:10:59 <AMcBain> I had XP installed for real, until it committed suicide.
10:11:56 <opqdonut> AMcBain: http://haskell.org/ghc/docs/latest/
10:11:59 <fons> OK, my apologies quicksilver, yiou were right, but only in the case of liftIO, in case you are not lifting an IO value you still need to compose calls to lift
10:11:59 <lambdabot> Title: Index of /ghc/docs/latest
10:12:00 <Lemmih> gregwebs: You're ghc installation seems to be borked.
10:12:07 <Lemmih> gregwebs: Sorry, *your.
10:12:15 <opqdonut> AMcBain: html/ has the library docs
10:12:22 <AMcBain> okau
10:12:58 <Cale> Actually, lament's suggestion would probably be unhelpful Haskell stuff generally works nicer on linux.
10:13:07 <fons> thanks sebell I get it now
10:13:13 <quicksilver> fons: that's thwy you need typeclasses
10:13:27 <quicksilver> fons: for every group of operations which you often lift, you invent a typeclass.
10:13:34 <quicksilver> fons: MonadState for get/put
10:13:41 <quicksilver> fons: monadIO for liftIO
10:13:53 <gregwebs> Lemmih: that's what I think, I have tried completely re-installing, and the files seem to exist
10:13:54 <quicksilver> fons: MonadError for throwError.
10:13:55 <Cale> Oops, missed some punctuation there :)
10:13:57 <opqdonut> why liftIO?
10:14:06 <opqdonut> i mean, why does it exist
10:14:18 <sebell> opqdonut: Convenience?
10:14:18 <quicksilver> fons: the goeal of the typeclasses is to let haskell's own type inference guide how many lifts are need, basically.
10:14:27 <quicksilver> at the cost of having to put a lot of lifts into the instances
10:14:28 <opqdonut> sebell: well why is it restricted to IO?
10:14:32 <quicksilver> but at least you only write them once.
10:14:37 <quicksilver> opqdonut: it doesn't have to be.
10:14:50 <quicksilver> there is MonadST along similar lines, at least in example code somewhere.
10:14:55 <quicksilver> and you can generalise further if you want.
10:14:56 <opqdonut> well why the name then?
10:14:57 <shepheb> opqdonut: see New Monads on the wiki, it has MonadBase
10:14:59 <davidL> I am creating a TCP/IP in Haskell. Should I store TCP options as Bools or should I have a function that calculates them as needed?
10:15:03 <opqdonut> yeah okay
10:15:10 <opqdonut> this has just bothered me for a while :)
10:15:17 <quicksilver> A better question is "why doens't the FFI put everything into MonadIO instead of IO"
10:15:18 <fons> quicksilver: right, but it might happen that you only want to lift a non-IO value once (like in my case), the is easier to simply compose various calls to lift
10:15:28 <quicksilver> (then you woudln't need all these liftIOs at all)
10:15:31 <quicksilver> fons: yes, true.
10:15:36 <quicksilver> fons: but in general they are to be avoided.
10:15:42 <sclv> there's a monad base in new monads on the wiki, and monadLib has it too
10:15:44 <sebell> opqdonut: I think liftIO seems distasteful because of the name. But like quicksliver said, the same thing is accomplished with get, put, throwError, etc.
10:15:52 <Cale> AMcBain: a list of commands? Well, there's http://cs.anu.edu.au/Student/comp1100/haskell/tourofsyntax.html
10:15:54 <lambdabot> Title: Tour of the Haskell Syntax
10:16:12 <Cale> AMcBain: I'm not exactly sure what is meant by 'commands' :)
10:16:33 <fons> quicksilver: well, thanks, MTPC are nice and make really general interfaces but make my brain hurt sometimes :)
10:16:38 <quicksilver> if I had a bunch of a relatively small number of IO things I might well bundle them into MonadQuicksilver
10:16:45 <quicksilver> and then use them without lift
10:16:48 <quicksilver> for a particular purpose.
10:17:04 <quicksilver> I personally wish that big bindings, especially those that used callbacks, worked this way.
10:17:07 <hpaste>  orzo pasted "what's wrong?" at http://hpaste.org/6363
10:17:15 <quicksilver> so e.g. everythiing in GL was MonadGL m =>
10:17:18 <quicksilver> instead of IO.
10:17:22 <orzo> hey
10:17:31 <orzo> i'm getting an error in that paste
10:17:36 <orzo> it's probably something simple
10:17:46 <fons> orzo: missing enclosing parenthesis?
10:17:55 <AMcBain> Cale: That page is sort of what I'm looking for. For Scheme I had this nice sR5 PDF with an index and everything in it ...
10:18:00 <opqdonut> couldn't we just have "instance (MonadBase b m,MonadTrans t) => MonadBase b (t m)"??
10:18:00 <AMcBain> (the prof found it)
10:18:10 <orzo> fons, where?
10:18:11 <opqdonut> or does that require ghc exts?
10:18:14 <fons> in the unsafeInterleaveIO call
10:18:32 <Cale> Well, http://www.haskell.org/ghc/docs/latest/html/libraries/index.html is the documentation for the libraries that come with GHC.
10:18:52 <quicksilver> fons: you need ( ) around that do
10:18:58 <Lemmih> orzo: Your indentation is off.
10:19:01 <quicksilver> orzo: sorry, that's for you.
10:19:04 <Cale> http://haskell.org/onlinereport/standard-prelude.html -- this is the Haskell 98 prelude, which is worth reading.
10:19:05 <lambdabot> Title: The Haskell 98 Report: Standard Prelude
10:19:08 <davidL> (for example some options use only 3 or 4 bits, I could create a new Word8 for those or I could have a function that takes an existing Word8 to get them)
10:19:23 <quicksilver> orzo: or, you use a $ after unsafeInterleaveIO
10:19:24 <sebell> or $...
10:19:27 <quicksilver> whichever you prefer.
10:19:27 <AMcBain> Cale: I installed the Hugs command line thing, as that is the Linux equivalent to the Windows software he said the labs have.
10:19:39 <Cale> AMcBain: okay
10:19:46 <jeffwheeler> I'm brand new to Haskell, but is there some reason `round 6.5` returns 6?
10:19:50 <Samburger> How can I check if 2 binary search trees are equal?
10:19:51 <Cale> > round 6.5
10:19:57 <lambdabot>  6
10:19:59 <Cale> > round 7.5
10:20:00 <lambdabot>  8
10:20:01 <orzo> THANKS, FONS
10:20:06 <orzo> and quicksilver
10:20:07 <Cale> It's round-to-even
10:20:26 <jeffwheeler> Weird, but okay...
10:20:30 <Cale> This eliminates some bias.
10:20:30 <AMcBain> Which is in total contrast to mathmatical rounding ...
10:20:50 <Cale> No, this is the standard way to round numbers throughout most of the world.
10:20:54 <sebell> AMcBain: Biased!
10:20:58 <shepheb> statistics and finance round the way Haskell does.
10:21:04 <Cale> Mathematics doesn't really prescribe how to do rounding.
10:21:08 <jeffwheeler> Seriously? I've never heard of that.
10:21:10 <shepheb> not to imply a left-to-right causality there
10:21:20 <sebell> shepheb: :)
10:21:28 <AMcBain> Anything .5 and above goes up, .4 and down goes to the previous number.
10:21:44 <Cale> AMcBain: That has a positive bias.
10:21:49 <sebell> AMcBain: Ok, so Grade 5 mathematics then
10:22:01 <skorpan> lol
10:22:08 <Cale> AMcBain: Things will on average go up slightly more often than they will go down, which is bad.
10:22:26 <byorgey> not if it's my bank account!
10:22:34 <byorgey> unfortunately my bank does not agree =(
10:23:00 <jeffwheeler> Ha, you all are right: http://en.wikipedia.org/wiki/Rounding -- I learn something new everyday, I suppose; thanks
10:23:01 <lambdabot> Title: Rounding - Wikipedia, the free encyclopedia
10:25:08 <byorgey> jeffwheeler: in any case, if you are actually writing a program where the precise rounding behavior actually matters, you'll probably want to save yourself the trouble and just hit yourself in the head with a hammer instead. ;-)
10:25:49 <jeffwheeler> fortunately, I am not :D (just following http://www.haskell.org/haskellwiki/Learn_Haskell_in_10_minutes, where a note on that might be useful)
10:25:50 <lambdabot> Title: Learn Haskell in 10 minutes - HaskellWiki
10:26:12 <Cale> :)
10:26:38 <Cale> > map round [-10.5,-9.5..10.5]
10:26:39 <lambdabot>  [-10,-10,-8,-8,-6,-6,-4,-4,-2,-2,0,0,2,2,4,4,6,6,8,8,10,10]
10:27:06 <byorgey> hmm, you'd think the docs for round would explain this, but... they don't.
10:27:53 <Cale> byorgey: Well, the Prelude in the report at least kind of specifies it.
10:28:21 <bos> i like "at least kind of specifies".
10:28:28 <byorgey> sure, but it would still be nice to have in the haddocks for the Prelude.
10:28:32 <Cale> Right.
10:29:03 <byorgey> "round x at least kind of returns the nearest integer to x.  sometimes."
10:29:31 <Cale> bos: Well, it has that behaviour in the default method in the class decl. But it doesn't actually say explicitly that it must round to even.
10:29:45 <bos> right.
10:29:56 <Cale> ah, 6.4.6: "round x returns the nearest integer to x, the even integer if x is equidistant between two integers."
10:30:12 <byorgey> jeffwheeler: by the way, welcome to Haskell and to #haskell! =)
10:30:12 <quicksilver> this only happens because we use base 2 :P
10:30:23 <quicksilver> otherwise, 0.5 woudln't be exact anyway, and we would be able to tell.
10:30:30 * quicksilver suggests all banking be done in base 3
10:30:37 <Cale> lambdabot: @join #jhc
10:30:43 <jeffwheeler> byorgey: thanks; I figured I'd try it out while waiting for OCaml's GODI, and haven't closed it yet
10:31:14 * byorgey suggests all banking be done in integer units =P
10:31:26 <mrd> count your pennies
10:31:42 * mrd asks byorgey to split 100 pennies between 3 people
10:32:07 * byorgey gives each person 30 cents and takes a 10 cent processing fee
10:32:09 <sebell> So how many digits of 3.499(repeat) are required to round to 4? :)
10:32:20 <mrd> infinite
10:32:21 <EvilTerran> 1 cent for the taxman, 33 cents each :)
10:32:36 <sebell> mrd: Surely not
10:32:49 <mrd> well then it's not 3.5
10:33:22 <dons> ?users
10:33:22 <lambdabot> Maximum users seen in #haskell: 473, currently: 457 (96.6%), active: 24 (5.3%)
10:33:34 <mrd> what to do when we break 500?
10:33:47 <gnuvince> Try to break 600?
10:33:49 <sebell> mrd: It is on a computer at least
10:34:10 <mrd> sebell: how?
10:34:25 <sebell> mrd: Floating point
10:34:26 <mrd> are you talking about what IEEE floating point can represent?
10:35:42 <desegnis> > round (3.5 - 1e-15)
10:35:43 <lambdabot>  3
10:36:51 <sebell> > round (3.5 - 1e-16)
10:36:51 <lambdabot>  4
10:37:23 <desegnis> > 3.5 - 1e-16
10:37:24 <lambdabot>  3.5
10:37:28 <desegnis> > 3.5 - 1e-15
10:37:29 <lambdabot>  3.499999999999999
10:37:31 <byorgey> don't make me use the floating-point stick!
10:38:20 <Sansjo> anyone wanna earn $10 paypal/moneybookers pm me.
10:38:36 <desegnis> sebell: It's not the fault of round if Double cannot accurately represent 3.5 - 1e-16
10:38:41 <lament> i want to earn much more than that :(
10:38:50 <sebell> desegnis: I know, I wasn't implying otherwise.
10:39:05 <desegnis> sebell, alright
10:39:12 --- mode: ChanServ set +o quicksilver
10:39:16 --- mode: quicksilver set +b *!*n=POCT@*.direct-adsl.nl
10:39:16 --- kick: Sansjo was kicked by quicksilver (quicksilver)
10:39:21 <dons> thanks quicksilver
10:39:28 --- mode: quicksilver set -o quicksilver
10:39:38 <quicksilver> I daresay he'll be K-lined in a minute. Normally that's what happnes :P
10:39:39 <lament> "direct-ads"
10:40:56 <Gilly> uh, why isn't there snoc' in lazy bytestrings?
10:40:59 <Gilly> similar to cons'
10:59:22 <dons> can anyone reproduce this bug? http://hackage.haskell.org/trac/ghc/ticket/2156
10:59:24 <lambdabot> Title: #2156 (compilation math/truncate bug with optimization enabled) - GHC - Trac
10:59:30 <dons> > truncate (log 8 / log 2)
10:59:31 <lambdabot>  3
10:59:51 <smg> hehe
10:59:52 <skorpan> :t truncate
10:59:54 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
11:00:00 <skorpan> :i truncate
11:00:03 <skorpan> i guess not?
11:00:14 <smg> no
11:00:18 <EvilTerran> ?index truncate
11:00:18 <lambdabot> Prelude
11:00:28 <smg> class (Real a, Fractional a) => RealFrac a where
11:00:33 <smg>   truncate :: (Integral b) => a -> b
11:00:37 <smg>   	-- Defined in GHC.Real
11:00:53 <taruti> dons: I get different results.
11:01:08 <taruti> dons: nonoptimized -> 3, optimized -> 2
11:01:15 <dons> ah ha!
11:01:16 <byorgey> dons: I can reproduce it as well.
11:01:27 <dons> ok guys. cool. can you add that to the tickedt.
11:01:32 <dons> and check -fvia-C and -fasm
11:01:33 <taruti> ghc 6.8.2 + debian + i386
11:02:02 <dons> check if it also happens with -fvia-C
11:02:08 <taruti> via-c optimized -> 3
11:02:11 <dons> since that would narrow it down to a native codegen bug
11:02:14 * taruti adds info to the ticket
11:02:15 <dons> awesome.
11:03:25 <sebell> dons: Strange, I get 2 with both -O1 and -O2
11:03:36 <dons> try -Onot
11:03:56 <Botje> -Oops
11:04:01 <byorgey> dons: what does -fasm do?
11:04:02 <sebell> dons: Ah, yup: 3
11:04:14 <Syzygy-> -Omalley
11:04:16 <dons> byorgey: uses the native code generator (the default)
11:04:19 <sebell> dons: I misread the ticket :)
11:04:22 <byorgey> dons: oh, ok
11:04:30 <byorgey> yeah, I get 3 with -fvia-C -O2
11:04:37 <byorgey> but 2 with -fasm
11:05:23 <dons> ok. so codegen issue
11:05:27 <dons> on x86
11:05:27 <roconnor> @quote equality
11:05:27 <lambdabot> pkhuong says: you'll probably still want unsafeEquality or whatever, though
11:05:32 <roconnor> @quote equality
11:05:32 <lambdabot> JamesMckinna says: We are once again left with the miserable prospect that it is equality that divides us.
11:05:47 <byorgey> dons: looks like
11:09:30 <hpaste>  cadabra pasted "reading lines from a file" at http://hpaste.org/6364
11:09:53 <cadabra> I'm just barely trying to learn haskell and get used to the syntax and type system
11:10:25 <cadabra> I'm trying to read lines from a file, up until I hit a "#" line, and then return an array with those lines
11:10:26 <roconnor> cadabra: excellent
11:10:52 <dons> a list?
11:10:56 <cadabra> What I have right now doesn't compile
11:10:57 <roconnor> cadabra: if you are starting out with Haskell, then you should probably work with lists instead of arrays.
11:10:58 <cadabra> Oh yes, a list
11:11:07 <roconnor> @paste
11:11:07 <lambdabot> Haskell pastebin: http://hpaste.org/new
11:11:17 <cadabra> http://hpaste.org/6364
11:11:20 <roconnor> cadabra: if you want you can paste what you have ^^
11:11:30 <dons> the lazy readFile and lines functions are your friend
11:11:32 <dons> and takeWhile
11:12:42 <cadabra> Is takeWhile like filter?
11:13:24 <sclv> ?hoogle takeWhile
11:13:24 <lambdabot> Prelude.takeWhile :: (a -> Bool) -> [a] -> [a]
11:13:24 <lambdabot> Data.List.takeWhile :: (a -> Bool) -> [a] -> [a]
11:13:24 <lambdabot> Data.ByteString.takeWhile :: (Word8 -> Bool) -> ByteString -> ByteString
11:13:50 <shepheb> cadabra: in spirit, yes. but takeWhile stops after the first False element, while filter keeps going.
11:13:56 <fons> Lemmih: probably is too late, but the answer wasn't pain lift but lift. ErrorT. return (quite ugly frankly)
11:14:05 <dons> yes, your code is very imperative, cadabra
11:14:06 <fons> plain*
11:14:09 <cadabra> The problem with my current approach is that it doesn't compile.. but also it would overflow the stack. Should I acumm the list in a param, or is there a better way?
11:14:11 <dons> you read a line, and process it, and so on
11:14:28 <hpaste>  dons annotated "reading lines from a file" with "more functional" at http://hpaste.org/6364#a1
11:14:35 <roconnor> cadabra: let me tell you how to fix your type error
11:14:47 <cadabra> woot.
11:14:49 <roconnor> cadabra: firstly you need   " then return ([]::[String]) "
11:14:59 <roconnor> brackets around the type annoation
11:15:04 <dons> cadabra: so in that solution I read all the lines lazily, and just return those up to the first one starting with #
11:15:09 <roconnor> cadabra: then you need "return (nextln : rest)"
11:15:17 <roconnor> cadabra: brackets around the :
11:15:29 <dons> its a much more "haskell" approach -- break the problem up into pieces, and compose those pieces
11:15:42 <roconnor> cadabra: because "return nextln : rest" parses as "(return nextln) : rest"
11:15:43 <dons> rather than trying to write a loop that does everything, with IO mixed in
11:16:09 <roconnor> cadabra: then now that is fixed, you can remove the type annoation and just say "then return []"
11:16:11 <sclv> cadabra: the usual haskell idiom would be to write "return $" and everything you want to return after the dollar sign.
11:16:30 <sclv> remember that function application always binds tightest
11:16:31 <cadabra> Thanks roconnor, that helps me get started. I like your approach dons, but I'm not familiar with '.' yet
11:16:48 <dons> that composes two functions, like | in unix
11:16:53 <dons> > map toUpper "haskell"
11:16:54 <lambdabot>  "HASKELL"
11:17:05 <dons> > filter (=='L') . map toUpper $ "haskell"
11:17:05 <lambdabot>  "LL"
11:17:13 <roconnor> cadabra: and then after all that, we can step back and make your code more haskelly, by following dons's recommendations
11:17:14 <cadabra> Aha
11:17:19 <dons> > map toLower . filter (=='L') . map toUpper $ "haskell"
11:17:19 <lambdabot>  "ll"
11:17:24 <dons> > length . map toLower . filter (=='L') . map toUpper $ "haskell"
11:17:25 <lambdabot>  2
11:17:54 <hpaste>  roconnor annotated "reading lines from a file" with "fixing errors" at http://hpaste.org/6364#a2
11:18:07 <orzo> i need example code demonstrating unsafeInterleaveIO
11:18:27 <gnuvince> @hoogle a -> [a] -> Int
11:18:27 <lambdabot> No matches, try a more general search
11:18:48 <roconnor> cadabra: what you have writen is very Cish :)
11:18:57 <cadabra> What is $?
11:19:07 <shepheb> @src ($)
11:19:07 <lambdabot> f $ x = f x
11:19:11 <cadabra> I was kinda going for Scheme-ish
11:19:21 <roconnor> f $ a b == f (a b)
11:19:28 <roconnor> cadabra: f $ a b == f (a b)
11:19:29 <dons> with no parens
11:19:31 <cadabra> Oh
11:19:46 <cadabra> Cool
11:19:57 <shepheb> cadabra: it's ordinary function application, but with lowest precedence rather than highest.
11:20:07 <roconnor> it's how we stop our code from looking like scheme :P
11:21:12 <cadabra> I'm undecided about parens everywhere vs. syntax
11:21:26 <dons> well, $ is a function :)
11:21:27 <sclv> orzo: http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-IO.html -- the lazyRead function.
11:21:29 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/2vwfwr
11:22:05 <roconnor> cadabra: you could have written ($) yourself.  It just happens to be part of the standard library.
11:22:11 <Deewiant> > scanl (flip ($)) "haskell" [map toUpper, filter (=='L'), map toLower, show . length]
11:22:11 <lambdabot>  ["haskell","HASKELL","LL","ll","2"]
11:22:14 <cadabra> Okay
11:22:17 <sclv> ?src $
11:22:17 <lambdabot> f $ x = f x
11:22:21 <dons> Deewiant: :)
11:22:22 <roconnor> @src map
11:22:22 <lambdabot> map _ []     = []
11:22:22 <lambdabot> map f (x:xs) = f x : map f xs
11:23:08 <roconnor> dons: I would be inclinded to separate the output (putStrLn) from the purely function program (map ... s) in your example. :)
11:23:31 <cadabra> A question. Do I have to do "x <- fooio \n return (a : x)" or is there a shortcut so I can put fooio in (a : ...)?
11:23:44 <dons> roconnor: i would too, if there was more to do
11:23:45 <Deewiant> fooio >>= return . (a:)
11:23:49 <sclv> cadabra: do you understand how do notation desugars?
11:23:53 <orzo> www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-IO.html -- the lazyRead function.
11:23:54 <dons> interact :)
11:24:10 <roconnor> cadabra: liftM (a:) fooio
11:24:10 <cadabra> sclv, I don't think so
11:24:24 <sclv> ?undo do {x <- fooio; return (a : x) }
11:24:24 <lambdabot> fooio >>= \ x -> return (a : x)
11:24:37 <cadabra> ooh
11:24:51 <cadabra> That's a lot of syntax hehe..
11:25:06 <tromp> :t liftM
11:25:08 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
11:25:08 <dons> >>= is a function :)
11:25:12 <dons> most things are functions in haskell
11:25:13 <sclv> if you're ever curious about how something is going to come out and can't quite figure it out, you can privmesage lambdabot and get it to undo it for you. pretty soon it'll be very obvious to you.
11:25:19 <cadabra> so >>= extracts and passes as a param?
11:25:36 <sclv> ?type (>>=)
11:25:36 <Deewiant> essentially, yes.
11:25:37 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
11:25:43 <roconnor> @pl fooio >>= \ x -> return (a : x)
11:25:43 <lambdabot> (a :) `fmap` fooio
11:25:58 <cadabra> fooio >>= return . (a:)
11:26:10 <sclv> ?type fmap
11:26:11 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:26:12 <Deewiant> liftM/fmap is arguably cleaner
11:26:12 <roconnor> sclv: >>= followed by a return can be simplified into a liftM (a.k.a fmap)
11:26:19 <cadabra> So let's see here.. that works because (a:) returns a curried?
11:26:23 <cadabra> function
11:26:41 <cadabra> okay
11:27:55 <sebell> Why does SML use a mix of products and curried functions again?
11:27:59 <roconnor> liftM (a:) fooio
11:28:08 <dons> sebell: lost in the mists of time
11:28:23 <cadabra> Thanks roconnor
11:29:16 <roconnor> (f >>= return . g) === (liftM g f) === (fmap g f) == (g `fmap` f) == (g `liftM` f)
11:29:41 <roconnor> === (f >>= \x -> return (g x))
11:30:45 <cadabra> So return just wraps the value in a monad. Does it jump out of the function too, like in C?
11:31:11 <roconnor> nope, return is only vaguely like C's return.
11:31:28 <opqdonut> very poor name choice imo :)
11:31:28 <Deewiant> @src IO return
11:31:28 <lambdabot> return x    = returnIO x
11:31:29 <roconnor> it's probably best to think of it as totally different.
11:31:31 <opqdonut> mixes up everyone
11:31:46 <roconnor> @type return
11:31:47 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
11:31:47 <opqdonut> even worse when inside a do-block
11:32:18 <roconnor> cadabra: so it is best to think of return as a function that sticks a value inside a monad.
11:32:29 <cadabra> Alright
11:34:29 <cadabra> Does anyone here use Emacs? Which haskell mode do you use?
11:34:40 <cjb> cadabra: Stefan's haskell-mode.
11:34:47 <sebell> The One True Haskell Mode
11:34:59 <byorgey> there's more than one?
11:35:09 <cjb> yeah, I don't actually know of any others.
11:35:16 <sebell> Neither do I.
11:35:25 <cjb> http://www.iro.umontreal.ca/~monnier/elisp/#haskell-mode
11:35:25 <lambdabot> Title: Emacs Lisp packages
11:35:44 <shapr> hiya cjb!
11:36:07 <cjb> shapr: 'ello.
11:36:11 <shapr> cjb: Did you see my reply wishing that the XO were as easy to purchase as the Arduino?
11:36:26 <cadabra> Okay, that's the one I have. It doesn't seem to indent if...then...else correctly
11:36:57 <Jetty> How can I check if 2 lists of tuples are equal?
11:37:04 <cadabra> unless I write if cond then \n true-exp else \n false-exp
11:37:05 <shapr> Jetty: (==) ?
11:37:08 <cjb> cadabra: hm, in my experience, indentation errors there mean my code is buggy, but I'm not a very good Haskell programmer :)
11:37:29 <byorgey> cadabra: you do know you can hit tab multiple times to get different indentations?
11:37:37 <cadabra> yup yup
11:37:43 <byorgey> cadabra: indentation is hard, it just tries to guess at some possibly correct locations
11:37:46 <byorgey> ok =)
11:37:56 <shapr> Indentation is hard, let's use curly braces!
11:38:06 <shapr> @quote shopping
11:38:06 <lambdabot> mauke says: reading existentials is hard. let's go shopping!
11:38:14 <byorgey> cadabra: in my experience, it doesn't always get things right, every now and then I have to align things by hand
11:38:24 <Deewiant> I prefer if cond \n then true-exp \n else false-exp
11:38:38 <Deewiant> works reasonably well in Vim, at least.
11:38:54 <sebell> if-then-else within do blocks is particularly nasty
11:39:01 <cjb> shapr: I've been turned off curly braces by the Haskell lecturer who gave us code that used curly braces and *didn't indent after them*.
11:39:02 * cjb mutters.
11:39:05 <cadabra> If I do Deewiant's, it puts the "then" at the same level as the "if"
11:39:09 <byorgey> cadabra: also, I think you'll find that you use if-then-else way less often in Haskell than you would in other languages.
11:39:23 <byorgey> cjb: ick!
11:39:28 <cadabra> Aha
11:39:32 <shapr> cjb: ick
11:39:43 <Cale> if foo
11:39:46 <Cale>   then bar
11:39:49 <Cale>   else quux
11:40:03 <FlamingCows> Hi.  I'm fairly new to haskell, and while I think I understand all the basics concepts involved, I'm having some trouble with the specifics.  My biggest question right now is how I can convert a basic String/[Char] and get a ByteString version of it.  It's tried casting directly to ByteString and to [Char8], but I get errors on both.
11:40:18 <Cale> FlamingCows: pack, iirc
11:40:23 <FlamingCows> s/It's/I've/
11:40:25 <Cale> :t Data.ByteString.Char8.pack
11:40:26 <lambdabot> String -> BSC.ByteString
11:40:29 <roconnor> @hoogle String -> ByteString
11:40:29 <lambdabot> Data.ByteString.Char8.pack :: String -> ByteString
11:40:30 <sebell> FlamingCows: try hoogling for the type signature you want
11:40:46 <roconnor> @where
11:40:46 <lambdabot>  @where <key>, return element associated with key
11:40:51 <roconnor> @where Hoogle
11:40:51 <lambdabot> http://haskell.org/hoogle
11:41:02 <FlamingCows> sebell: I tried a bunch of Hoogle queries and came up with nothing.
11:41:03 <shapr> #haskell > ##csharp for a very large value of greater.
11:41:19 <FlamingCows> But I'll try pack, thanks.
11:41:21 <sebell> FlamingCows: Well roconnor's query got the answer right away
11:41:26 <roconnor> FlamingCows: searching for String -> ByteString should work.
11:41:34 <lispy> shapr: IMO, #haskell is the most polite and genuinely useful large channel on freenode
11:41:51 <FlamingCows> Heh, okay.  Noted for the future.  Thanks.
11:41:51 <shapr> lispy: Yeah, probably so.
11:41:55 <roconnor> FlamingCows: good luck! come back anytime.
11:42:09 <sebell> lispy: and ##c is the most useless and unfriendly
11:42:13 <FlamingCows> I'm not done yet. That was just my first question. :)
11:42:24 <roconnor> FlamingCows: ah. :)
11:42:45 <ivan_> what is the name of the function that zips two lists with a operator?
11:42:45 <lispy> shapr: I had a guy in Debian who told me he knew how to fix an obscure problem I was having with APT, but that he _would not_.  I don't get that kind of crap response here :)
11:42:55 <shapr> lispy: the former #python maintainers asked me last week how #haskell could get almost as big as #python and be far more polite and informative :-)
11:42:58 <lispy> ivan_: zipWith
11:43:06 <ivan_> lispy: thx =)
11:43:06 <roconnor> @hoogle (a -> b -> c) -> [a] -> [b] -> [c]
11:43:07 <lambdabot> Prelude.zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
11:43:07 <lambdabot> Data.List.zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
11:43:07 <lambdabot> Control.Parallel.Strategies.parZipWith :: Strategy c -> (a -> b -> c) -> [a] -> [b] -> [c]
11:43:28 <shapr> lispy: Yeah, #haskell is much nicer than #debian
11:43:29 <lispy> shapr: interesting
11:43:34 <FlamingCows> Next is how do I convert an Int to [Word8].  I just tried Hoogle with Int -> [Word8] and got nothing.
11:43:50 <sebell> FlamingCows: Data.Binary has an instance for that, check the sources
11:43:51 <ivan_> roconnor: if one list is infinite will it stop for the shortest list?
11:43:55 <shapr> lispy: I claimed the cause was asshole intolerance on my part.
11:44:05 <lispy> shapr: heh!
11:44:14 <roconnor> FlamingCows: big endian or little endian?
11:44:33 <tromp> it's like ability to appreciate haskell filters out the less friendly folks:)
11:44:42 <shapr> tromp: Sometimes...
11:44:52 <roconnor> ivan_: zips stop on the shortest list.
11:44:55 <FlamingCows> Either.  In fact, the whole reason I need to do the conversion is to switch from one to the other.  If you know a way to get the binary little endian representation from memory, that would work too.
11:45:04 <byorgey> shapr++
11:45:25 <byorgey> for doing the hard work to create such a wonderful, friendly channel =)
11:45:29 <dons> FlamingCows: you want to shift off the bytes in big or little endian?
11:45:42 <tromp> u mean @karma+ ?
11:45:43 <FlamingCows> I need them in little endian.
11:45:56 <byorgey> tromp: nick++ is a shortcut.
11:46:00 <byorgey> @karma nick
11:46:00 <lambdabot> nick has a karma of 3
11:46:05 <byorgey> nick--
11:46:08 <byorgey> @karma nick
11:46:08 <lambdabot> nick has a karma of 2
11:46:09 <tromp> oh, cool
11:46:16 <roconnor> FlamingCows: I don't think there is a standard function for what you want.  There is probably something in Hackage for you, but you might be better off writing your own.
11:46:19 <tromp> tromp--
11:46:25 <tromp> @karma tromp
11:46:25 <lambdabot> You have a karma of 0
11:46:37 <tromp> tromp--
11:46:39 <tromp> @karma tromp
11:46:39 <lambdabot> You have a karma of 0
11:46:42 <cadabra> Anyway, thanks for the crash course guys ;o
11:46:43 <byorgey> tromp: you can't change your own karma, unless...
11:46:53 <byorgey> cadabra: anytime! =)
11:47:01 <dons> *M> unroll 12312321
11:47:01 <dons> [1,223,187]
11:47:20 <hpaste>  dons pasted "unroll the bytes" at http://hpaste.org/6365
11:47:27 <shapr> tromp++ (lambda playground)
11:47:31 <shapr> @karma tromp
11:47:31 <lambdabot> tromp has a karma of 1
11:47:32 <cadabra> oh and I'll study your solution dons!
11:47:33 <dons> FlamingCows: ^
11:47:48 <FlamingCows> Thanks.
11:48:34 <cadabra> Is there a local cli hoogle?
11:48:42 <cadabra> oh google
11:48:57 <roconnor> @docs Data.Binary
11:48:57 <lambdabot> Data.Binary not available
11:48:57 <cadabra> knows
11:49:08 <lispy> cadabra: yeah there is a local hoogle, either lambdabot or hoogle itself
11:49:18 <FlamingCows> Perhpas I'm approaching this the wrong way, though.  Basically I'm building packets that are essentially laid out like C structs that get fired off as the data segment in a TCP packet.  I was under the impression that Haskell's Network library would require me to switch Ints and fixed length (non-null-terminated) strings to little endian by hand in order to arrive at the proper ByteString.  Can anyone confirm if that is 
11:49:44 <dmead> i think you're right
11:49:51 <dmead> the int used by the haskell VM isn't your system's int
11:49:56 <lispy> FlamingCows: I think your IRC client is cutting off part of what you're saying
11:50:09 <FlamingCows> lispy: Where abouts?
11:50:10 <dons> FlamingCows: oh, use Data.Binary
11:50:11 <dmead> you need #Int or something
11:50:20 <lispy> FlamingCows: your message ended with "anyone confirm if that is"
11:50:28 <dmead> [true]
11:50:35 <FlamingCows> "Can anyone confirm if that is the case before I go through the effort of implementing it?"
11:50:39 <FlamingCows> Not that important.
11:51:01 <dons> note also,
11:51:01 <dons> Prelude Data.Binary Data.ByteString.Lazy> unpack (encode (258 :: Int))
11:51:02 <dons> [0,0,0,0,0,0,1,2]
11:51:03 <dons> :)
11:51:16 <roconnor> > Data.Binary.put (0xffeeddbb::Int)
11:51:17 <lambdabot>   Not in scope: `Data.Binary.put'
11:51:23 <dons> encode
11:51:32 <roconnor> > Data.Binary.encode (0xffeeddbb::Int)
11:51:33 <lambdabot>   Not in scope: `Data.Binary.encode'
11:51:56 <dons> :t Data.ByteString.Lazy $ Data.Binary.encode (0xffeeddbb::Int)
11:51:56 <lambdabot>     Not in scope: data constructor `Data.ByteString.Lazy'
11:52:01 <roconnor> dons: does encode specifiy the endianess?
11:52:03 <dons> :t Data.ByteString.Lazy.unpack $ Data.Binary.encode (0xffeeddbb::Int)
11:52:04 <lambdabot> [Word8]
11:52:06 <dons> roconnor: yeah, big endian
11:52:16 <dons> use the le encoder for little endian
11:52:43 <hpaste>  dons annotated "unroll the bytes" with "Data.Binary approach" at http://hpaste.org/6365#a1
11:53:09 <roconnor> FlamingCows: since the size of Int is system dependent you may want to use Int32 or Word32 instead.
11:53:35 <FlamingCows> roconnor: Yeah, I know.  I wasn't focusing on that yet is all. :)
11:53:41 <roconnor> :)
11:53:54 <dons> FlamingCows: but you should familiarise yourself with Data.Binary
11:54:08 <dons> which offers all the facilities for converting types to big/little/host endian byte streams
11:54:11 <dons> and back
11:54:13 <FlamingCows> Yeah, I'm trying to right now.
11:56:19 <sclv> ?seen igloo
11:56:20 <lambdabot> igloo is in #haskell-soc, #haskell, #ghc and #darcs. I last heard igloo speak 1h 58m 7s ago.
11:57:55 <Saizan> is unsafeInterleaveIO supported by other compilers?
11:58:28 <dons> other compilerS?
11:58:40 <lispy> it's in System.IO.Unsafe these days, so I think maybe?
11:59:07 <JohnMeacham> ghc                  15.52    seconds            (1.0 x)
11:59:07 <JohnMeacham> jhc_boehm            0.30    seconds            (0.0 x)
11:59:07 <JohnMeacham> jhc_grin             0.05    seconds            (0.0 x)
11:59:11 <JohnMeacham> woo. infinitely faster.
11:59:35 <Heffalump> JohnMeacham: cool :-)
11:59:38 <Heffalump> at doing what?
11:59:54 <bos> i often get that sort of speedup when i have a compiler bug that causes an immediate crash :-)
12:00:01 <sebell> JohnMeacham: Very nice. What is it? ;)
12:00:35 <byorgey> ghc takes a long time to print its name, apparently ;)
12:00:39 <Heffalump> bos: yes, that one's very familiar :-)
12:00:42 <JohnMeacham> that is the 'atom' test. which isn't surprising, it is known to be bad on ghc, which is why it makes a good benchmark.
12:01:11 <sebell> JohnMeacham: What's the Grin GC?
12:01:16 <JohnMeacham> but it is good to see things faster with the boehm collector.
12:01:23 <JohnMeacham> just static analysis.
12:01:29 <sebell> Oh, still using Boehm?
12:01:59 <lispy> interesting, I was under the impression boehm isn't such a great GC
12:02:24 <JohnMeacham> you can choose. right now is just 'boehm' and 'static', but I am adding a new one right now, a variant of a straightforward mark-sweep one but with careful attention to caching effects.
12:02:48 <sebell> JohnMeacham: Interesting
12:03:26 <byorgey> JohnMeacham: you mean, you can choose at compile time which runtime system you want to use?  nifty =)
12:03:26 <JohnMeacham> it does require 'libjudy' to be installed though at runtime, but that isn't too bad I think. it is fairly portable and useful.
12:04:02 <JohnMeacham> byorgey, even better. you can take the C code generated by the compile and just gcc it with -DJHC_GC=BOEHM or whatnot to change it after the code has been compiled :)
12:04:13 <byorgey> JohnMeacham: oh, nice! =)
12:05:08 <JohnMeacham> yeah. the C code itself is portable, so you can take the c code and bring it over to some other computer and gcc it. jhc is designed to be a cross-compiler natively.
12:05:29 <JohnMeacham> it is how I was able to compile haskell stuff for my iPhone. :)
12:05:47 <Cheery> gggrrrrkkk! iPhone
12:06:17 <byorgey> JohnMeacham: hehe, awesome
12:06:19 <Cheery> check how iDrive
12:06:36 <JohnMeacham> I like iPhysics. a general physics simulator. great to play with on the bus.
12:08:50 <bos> libjudy?
12:09:06 <FlamingCows> Trying to build Data.Binary gives a parse error related to the cabal file.  I assume I'm screwing something up?
12:09:12 * bos is very skeptical of the claims made for the judy code.
12:09:17 <FlamingCows> The error is: "Setup.lhs: binary.cabal:22: Invalid syntax (no colon after field name)"
12:09:34 <bos> FlamingCows: you probably need a 1.2 version of cabal
12:09:43 <bos> FlamingCows: you're using ghc 6.6, right?
12:09:51 <JohnMeacham> bos: why skeptical?
12:10:10 <FlamingCows> bos: Yes.
12:10:28 <bos> JohnMeacham: http://www.nothings.org/computer/judy/
12:10:29 <lambdabot> Title: A performance comparison of Judy to hash tables
12:10:36 <bos> FlamingCows: upgrade cabal
12:12:12 <FlamingCows> Should I be upgrading ghc to 6.8 while I'm at it?
12:12:37 <bos> FlamingCows: depends on whether you feel like it or not. 6.8.2 is faster and has some nice new features.
12:13:50 <lispy> ghc6.8.2 supports cabal-install and haddock2
12:13:58 <lispy> those are two great reasons to upgrade it
12:14:19 <JohnMeacham> yeah, the judy authors replied to that somewhere.
12:15:17 <FlamingCows> Upgrading ghc gives me the newest cabal anyway, right?
12:15:57 <FlamingCows> Assuming I wipe out my old install and just grab fresh binaries.
12:22:48 <JohnMeacham> http://citeseer.ittc.ku.edu/fritchie03study.html - there is also this study.
12:22:49 <lambdabot> Title: A Study of Erlang ETS Table Implementations and Performance (ResearchIndex)
12:23:54 <dejones> ?seen Cale
12:23:54 <lambdabot> Cale is in #ghc, #haskell-overflow and #haskell. I last heard Cale speak 43m 29s ago.
12:24:08 <dejones> hey Cale, did you submit the bug report for the Array index bug?
12:24:08 <bos> FlamingCows: it will give you a sufficiently new one, yes
12:24:44 <dejones> ?seen dons
12:24:44 <lambdabot> dons is in #xmonad, #haskell-soc and #haskell. I last heard dons speak 26m 16s ago.
12:25:38 <shapr> @seen simonpj
12:25:38 <lambdabot> I haven't seen simonpj.
12:26:02 <vegai> I have! Live!
12:26:12 <dmead> ?karma
12:26:13 <lambdabot> You have a karma of 3
12:26:13 <vegai> less than 4 hours ago :)
12:26:39 <cjb> I worked in the building next to him, but back then I thought Haskell was just for people with beards.
12:26:39 <vegai> shapr: hey. What have you been doing lately?
12:26:59 <bos> JohnMeacham: cool link, thanks
12:27:22 <bos> ah, judy arrays are really compressed radix trees.
12:27:44 <shapr> vegai: You saw SPJ less than four hours ago?
12:27:52 <shapr> cjb: MSR Cambridge?
12:27:56 <vegai> shapr: yep. Stellar performance
12:28:03 <shapr> cjb: Er, did SPJ have a beard?
12:28:10 <shapr> vegai: Cool! How was it?
12:28:23 <vegai> shapr: my employer sent me to this thing http://qcon.infoq.com/ and there was a track where he introduced Haskell.
12:28:25 <lambdabot> Title: QCon Conferences
12:28:39 <vegai> nothing much new for me, but it was extremely cool
12:29:12 <cjb> shapr: I worked in the Cavendish next door for two years, on Dasher.
12:29:13 <shapr> Nifty, did you get to talk to SPJ afterwards?
12:29:24 <cjb> I think he probably didn't have a beard.  But everyone else did.
12:29:28 <shapr> heh
12:29:38 <vegai> yeah. Unfortunately, I didn't have much to say at that point ;-p
12:29:45 <Cale> dejones: nope, but I did send a comment to the haskell-cafe list
12:30:42 <bos> JohnMeacham: why are the HsJudy collections all embedded in monads?
12:31:40 <Cale> bos: there's more than one monad involved?
12:31:55 <bos> Cale: parameterised over an arbitrary monad
12:32:13 <Cale> odd
12:32:35 <Cale> I could understand being in IO
12:32:44 <bos> i know. i can understand an embedding into IO, but ... there's no doco to suggest why others.
12:32:54 <bos> maybe it's to permit use of fail?
12:33:10 <dejones> Cale: I guess I'l submit the bug.  :P
12:33:14 <dejones> I'll
12:33:56 <RayNbow> <vegai> I have! Live! <-- lucky bastard :p
12:34:04 <dejones> Cale: oh, I think it has already been submitted: http://hackage.haskell.org/trac/ghc/ticket/2120
12:34:06 <lambdabot> Title: #2120 (Arrays allow out-of-bounds indexes) - GHC - Trac
12:34:40 <Cale> It appears so :)
12:35:28 <dejones> I went ahead and replied to the haskell-cafe mails, so people know the bug is already submitted.
12:35:48 <vegai> RayNbow: I truly am
12:39:08 <RayNbow> vegai: I actually wonder if SPJ will ever visit the Netherlands... :p
12:39:17 <Cale> @seen Igloo
12:39:17 <lambdabot> Igloo is in #haskell-soc, #haskell, #ghc and #darcs. I last heard Igloo speak 2h 41m 5s ago.
12:39:26 * RayNbow hopes he will
12:40:09 <dejones> RayNbow: isn't SPJ going to be in the Netherlands this summer for the AFP Summer Course?
12:40:31 <dejones> RayNbow: http://www.st.cs.ru.nl/AFP_TFP_2008/
12:40:32 <lambdabot> Title: Home Page AFP/TFP 2008
12:40:41 <dejones> :)
12:40:51 <dejones> RayNbow: Your wish has been granted.
12:41:02 <JohnMeacham> bos: because ijust arrays are mutable.
12:41:18 * RayNbow blinks
12:41:25 * RayNbow clicks on the link and starts reading
12:41:44 <JohnMeacham> bos: I only have experience with my binding http://repetae.net/repos/HsJudy/
12:41:45 <lambdabot> Title: Index of /repos/HsJudy
12:41:50 <vegai> now if I could be so lucky that I could get my employer to send me to the CUFP...
12:41:56 <bos> JohnMeacham: yes, that's the one i was wondering about
12:42:00 <shapr> vegai: Yeah!
12:42:42 <JohnMeacham> because judy arrays are not persistant, they are mutable, thus you need to put them in either the IO or ST monad.
12:43:22 <tromp> how many Kbytes is libJudy?
12:43:25 <RayNbow> dejones: I'm a poor student though :p
12:43:55 <dejones> RayNbow: Yeah, me too.  I'm trying to figure out a way for me to get there...  I have to fly from the U.S.  :(
12:46:12 <dejones> ?src takeWhile
12:46:12 <lambdabot> takeWhile _ []                 =  []
12:46:12 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
12:46:12 <lambdabot>                    | otherwise =  []
12:46:35 <JohnMeacham> boe: though note that my HsJudy bindings have the ability to freeze judy arrays so that you can use them purely from then on.
12:47:08 <JohnMeacham> I know there is some other hsjudy out there but it was signifigantly more complicated and had more overhead last I looked..
12:48:06 <bos> JohnMeacham: yours is the one on hackage, right?
12:48:27 <JohnMeacham> hmmm... looks like there are a few different bindings out there.
12:48:39 * shapr boings
12:48:39 <JohnMeacham> looks like the hackage one is based on mine. at least I am listed as an author.
12:48:58 <JohnMeacham> I could have sworn I saw another one out there at some point.
12:49:28 <bos> gwern: can you shed any light on this?
12:50:45 <Cale> http://img.worsethanfailure.com/images/200803/errord/farads.png
12:51:05 <shapr> Cale: cute!
12:51:56 <Igloo> I get the feeling I'm missing something
12:52:11 <Igloo> Oh, I didn't read the URL
12:52:45 <Cale> Igloo: Did you see that array indexing bug?
12:52:54 <Igloo> I don't think so
12:52:59 <sebell> I feel like discharing around 3pm as well
12:53:03 <Cale> > listArray ((0,0),(1,1)) [1..] ! (0,3)
12:53:04 <lambdabot>  4
12:53:11 <sebell> *discharging
12:53:20 <Igloo> Oh, from a while ago, yes
12:53:40 <Cale> Why doesn't it just use index instead of this safeIndex nonsense?
12:54:11 <Igloo> Because people can define their own Ix definitions, if you just use index then you can read off the end of an array
12:54:44 <Igloo> safeIndex is safe, but we didn't do the double-checking as some people were concerned about performance
12:56:04 <Cale> Igloo: It was creating very strange issues with dejones' memoisation code, where if the arrays weren't large enough, the program would still terminate and produce a result which was incorrect.
12:56:06 <cadabra> "readFile" returns a lazy string right? Does "lines" return a lazy list? The docs don't seem to mention it..
12:56:18 <mrd> lists are lazy
12:56:21 <Valodim> yes
12:56:22 <Cale> cadabra: yes, lines is a pure function and operates lazily.
12:56:37 <Cale> @src lines
12:56:37 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
12:56:41 <Cale> fine.
12:57:13 <dejones> Igloo: You can see the code / test cases that Cale is talking about here: http://www.haskell.org/pipermail/haskell-cafe/2008-March/040598.html
12:57:15 <lambdabot> Title: [Haskell-cafe] Ackermann Function Memoization, GHC Weird Output or Bug?, http://tinyurl.com/3x3q2l
12:57:35 <cadabra> The list is lazy simply because lines is pure?
12:57:59 <Cale> cadabra: lists are basically always lazy.
12:58:00 <mrd> lists are always lazy
12:58:12 <cadabra> woah.
12:58:14 <mrd> a function might force evaluation though, like foldl'
12:58:14 <oerjan> cadabra: well not _necessarily_, but mostly pure functions are designed as lazily as possible
12:58:29 <Cale> cadabra: Of course, the exact implementation of lines matters for the output to become available as it chops the string up.
12:58:44 <oerjan> hm...
12:58:51 <cadabra> So. I can read one line from my file, and then when I want to read another, haskell resumes execution of lines?
12:58:57 <Cale> cadabra: If it did something silly like splitting the lines off of the end of the string, then you'd have to wait for the entire string to be available, but it doesn't do that.
12:59:01 <mrd> yea, for example, if "lines" depended upon the end of the list  before it could return anything, it wouldn't be particularly lazy
12:59:03 <Cale> cadabra: yep
12:59:10 <oerjan> > head . head . lines $ 'a':undefined
12:59:10 <lambdabot>  'a'
12:59:14 <oerjan> yay
12:59:14 <Cale> cadabra: Evaluation proceeds outermost first.
12:59:42 <cadabra> that's crazy awesome
12:59:58 <Cale> cadabra: Only the parts of the list you pattern match against (or print to the screen, etc.) will be computed.
13:00:10 <Cale> > repeat 1
13:00:11 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
13:00:18 <Cale> > scanl (+) 0 (repeat 1)
13:00:18 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
13:00:42 <Cale> > let evens = 0 : map (+1) odds; odds = map (+1) evens in evens
13:00:42 <lambdabot>  [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
13:01:00 <gwern> bos: what is this about hsjudy?
13:01:09 <Cale> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
13:01:09 <lambdabot>  Parse error at end of input
13:01:12 <Cale> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
13:01:13 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
13:01:17 <bos> gwern: did you put it up on hackage?
13:01:30 <cadabra> I wonder how you implement something like that in a programming language?
13:01:31 <Cale> cadabra: data can even be recursive, as the above examples show :)
13:02:00 <Cale> cadabra: Lazy evaluation consists of essentially two basic details
13:02:08 <gwern> bos: I did
13:02:08 <gwern> it builds, right?
13:02:10 <gwern> I was sure I fixed the build problems
13:02:28 <bos> i was just curious if you changed anything relative to johnmeacham's code.
13:02:38 <Cale> One is that evaluation is outermost first. The second is that parameters to a function which occur multiple times in the function body are only computed once and then shared between the copies.
13:02:40 <bos> he didn't seem to know it was on hackage at all.
13:02:51 <Cale> Let me show an example :)
13:03:05 <Cale> cadabra: We'll start with the function  double x = x + x
13:03:05 <cadabra> What does it mean that evaluation is outermost?
13:03:22 <gwern> bos: well, what I did was basic porting to 6.8, which mostly entailed cabal file changes and switching OPTIONS to LANGUAGE
13:03:23 <Cale> Er, okay, I'll explain that more generally
13:03:34 <gwern> bos: but I think the readme mentioned it was someone's SoC
13:03:37 <Cale> In strict evaluation (like most programming languages use)
13:04:14 <dons> JohnMeacham: cool numbers.
13:04:16 <Cale> you evaluate innermost first. If you have the function application f (g x), say, g is first applied to x, and then the result is passed to f
13:04:17 <bos> ok
13:04:25 <cadabra> ah, I see
13:04:29 <Cale> In Haskell, that's not what happens.
13:04:39 <Cale> (g x) is passed, unevaluated, to f
13:04:43 <gwern> bos: if there's much fundamentally different, I think youd'd have to ask 'Caio Marcelo de Oliveira Filho <cmarcelo@gmail.com>' who mentions in the readme
13:04:46 <gwern> This code is part of my summer of code project. Please, before changing something get in touch with me (cmarcelo at gmail || cmarcelo at #perl6).
13:04:46 <cadabra> wait, I'm sorry, I have to run to class. Back on in 3 minutes
13:04:49 <gwern> I pasted my summer of code application, which describes roughly what's this going to be. As time pass it'll become more proper README file =)
13:04:50 <Cale> oh, okay
13:05:03 <bos> gwern: ok
13:05:34 <bos> i wonder how much that code has diverged from JohnMeacham's version
13:06:17 <JohnMeacham> bos: looks like it is just filled out mainly. mine was just an initial binding for JudySet as that is all I needed.
13:06:31 <cmarcelo> gwern: bos: I am the author, was part of my SoC project, we tried to use it with Pugs...
13:07:23 <gwern> cmarcelo: what happened? I noticed it didn't seem to be used anywhere
13:08:19 <byorgey> hehe, apparently cadabra has to GO to class, but not actually pay attention? =)
13:08:57 <bos> cmarcelo: oh, cool.
13:09:11 <gwern> byorgey: his class must be very close if he can make it in 3 minutes...
13:09:18 <dmwit> byorgey: Yeah, I've never understood that myself.
13:09:26 <cmarcelo> I've wrapped the other structures available in Judy.. We had some memory related problems and I ended up focusing (after SoC) in other aspects of Pugs...
13:09:28 <bos> JohnMeacham: cmarcelo: gwern: it would be very nice if the two implementations reconverged into one :-)
13:09:31 <dmwit> I know a lot of people that go to class, fully planning to sleep through it.
13:09:50 <byorgey> dmwit: well, maybe if your grade depends on attendance, but not participation...?
13:09:51 <dmwit> At that point, I wonder why they even bother going.
13:10:04 <dmwit> yeah, maybe...
13:10:05 <byorgey> an odd grading system, perhaps, but I'm sure it happens
13:10:14 <gwern> dmwit: so they can learn through osmosis
13:10:26 <cadabra`> I knew that haskell doesn't evaluate expressions until they're needed, but I didn't know that a function could return a part of a result and then return the rest when needed.
13:10:32 <byorgey> hehe, like putting a recording under your pillow?
13:11:00 <cmarcelo> bos: I think JohnMeacham didn't worked on it after I've started... but would be glad to converge them if needed..
13:11:00 <dmwit> "I learned Japanese by putting a recorder under my pillow.  Now I can speak flawless Japanese... but only when I'm asleep!"
13:11:03 <gwern> bos: I dunno, is there anything really to merge? I get the impression JohnMeacham abandoned it when it met his needs and cmarcelo then developed it to relative completeness
13:11:12 <byorgey> cadabra`: pretty cool, huh? =)
13:11:27 <cadabra`> to say the least
13:11:42 <cadabra`> So, are there separate stacks, or how does that work?
13:12:02 <bos> ok, that's useful to know.
13:12:02 <Cale> Well, let me show a basic example first
13:12:14 <Cale> and then we'll do one with a more complicated datastructure
13:12:35 <Cale> Suppose we have double x = x + x
13:12:47 <Cale> and we're evaluating double (double 5)
13:13:00 <Cale> In a strict language, it would go like this:
13:13:03 <Cale> double (double 5)
13:13:07 <Cale> -> double (5 + 5)
13:13:14 <Cale> -> double 10
13:13:17 <Cale> -> 10 + 10
13:13:18 <Cale> -> 20
13:13:20 <cmarcelo> bos: are you using it?
13:13:23 <cadabra`> Applicative, right?
13:13:24 <cmarcelo> (judy)
13:13:31 <bos> cmarcelo: no, but thinking about it.
13:13:54 <Cale> Well, hmm, it's innermost-first application.
13:14:12 <cadabra`> Okay
13:14:22 <Cale> In a language where function applications are evaluated outermost first (also known as normal order evaluation), it would go like this:
13:14:26 <Cale> double (double 5)
13:14:34 <Cale> -> double 5 + double 5
13:14:41 <Cale> -> (5 + 5) + double 5
13:14:45 <Cale> -> 10 + double 5
13:14:50 <Cale> -> 10 + (5 + 5)
13:14:53 <Cale> -> 10 + 10
13:14:55 <Cale> -> 20
13:14:56 <sebell> cadabra`: I believe application is leftmost innermost, so yes?
13:15:02 <sebell> cadabra`: *applicative
13:15:14 <Cale> Notice that we waste some work here, by computing double 5 twice.
13:15:14 <cadabra`> Alright
13:15:22 <sebell> cadabra`: I believe what Cale is talking about is Normal order
13:15:23 <Cale> Lazy evaluation is an optimisation of this
13:15:26 <cadabra`> Yes
13:15:48 <Cale> Where we share the results of evaluating function parameters which are duplicated in the body
13:15:54 <cadabra`> It passes in a reference to the expression instead
13:16:06 <Cale> If you'll allow me to use let-expressions to represent this sharing:
13:16:10 <Cale> double (double 5)
13:16:15 <Cale> -> let x = double 5 in x + x
13:16:21 <Cale> -> let x = 5 + 5 in x + x
13:16:25 <Cale> -> let x = 10 in x + x
13:16:26 <Cale> -> 20
13:16:54 <Cale> Of course, in a real implementation we might use pointers or something to get the effect.
13:17:58 <laura85> hi ^^
13:18:00 <Cale> Or we could use a graph to represent it.
13:18:07 <Cale> hello laura85
13:18:10 <dmwit> Welcome back, laura85!
13:18:23 <Cale> cadabra`: Okay, so perhaps something more interesting...
13:18:51 <dejones> hey laura85, are you in Switzerland?
13:19:08 <laura85> dejones, yup ^^
13:19:10 <Cale> cadabra`: Let's look at the expression  head (map (+1) [1..10])
13:19:17 <Cale> We have:
13:19:20 <Cale> head (x:xs) = x
13:19:25 <Cale> map f [] = []
13:19:27 <cmarcelo> bos: I will be in a conference next days (not Hs related) so probably won't have time to take a look again at hsjudy. but after that we could catchup and see what still need to be fixed there etc...
13:19:31 <Cale> map f (x:xs) = f x : map f xs
13:19:42 <cadabra`> okay
13:19:48 <Cale> Now, we work outermost first.
13:19:55 <dejones> laura85: cool.  Know much about ETH Zurich and Zurich, Switzerland?  Like that university and city?  I'm considering ETH Zurich for my PhD studies.
13:19:59 <cmarcelo> gwern: btw, thanks for adding it to hackage...
13:20:03 <Cale> head needs to match against (x:xs), but map (+1) [1..10] isn't directly in that form
13:20:09 <Cale> So we evaluate it,
13:20:28 <cadabra`> Oh
13:20:32 <cadabra`> it clicked
13:20:33 <Cale> and then map needs to know if [1..10] is in the form [] or in the form (x:xs)
13:20:42 <bos> cmarcelo: sure, thank
13:20:48 <Cale> So we evaluate [1..10] by one step, giving 1 : [2..10]
13:21:04 <Cale> then the second line of map applies:
13:21:10 <gwern> cmarcelo: sure. if you have any other packages which could use a hackage upload, I'd appreciate knowing
13:21:21 <cadabra`> So there aren't two stacks, or any resuming or functions. But because map is recursive, it returns a new expression, not a complete result
13:21:27 <cadabra`> resuming of
13:21:29 <Cale> and our expression reduces to   head ((1+1) : map (+1) [2..10])
13:21:40 <Cale> right
13:21:51 <Cale> and now head can finish matching
13:22:02 <Cale> x = (1+1), xs = map (+1) [2..10]
13:22:09 <Cale> and head just returns x
13:22:17 <Cale> so our expression is reduced to (1+1)
13:22:20 <cadabra`> and because it uses outermost evaluation, the return expr of map isn't evaluated until it's second part, the recursive call, is needed?
13:22:27 <Cale> right
13:22:35 <Cale> Which is, when something pattern matches against it.
13:22:41 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/6367
13:22:44 <roconnor> > (0.4 + 0.03*2)/3
13:22:45 <cadabra`> how neat and clean
13:22:46 <lambdabot>  0.15333333333333335
13:23:02 <dejones> laura85: did you see my message?  ;)
13:23:05 <codetoad> i'm trying to make my own instance of Arbitrary for testing Rational numbers: http://hpaste.org/6367
13:23:16 <Cale> Yeah, there's surprisingly little magic to it :)
13:23:18 <codetoad> [i copied that from somewhere else]
13:23:20 <roconnor> > (0,36 + 0.03*2)/3
13:23:20 <lambdabot>   add an instance declaration for (Fractional (t, t1))
13:23:24 <roconnor> > (0.36 + 0.03*2)/3
13:23:25 <lambdabot>  0.13999999999999999
13:23:43 <laura85> dejones, ah yes. I'm an ETH student ^^
13:23:58 <laura85> dejones, CS
13:24:08 <dejones> laura85: Awesome.  Do you like ETH Zurich?
13:25:40 <laura85> dejones, mhm I like it ^^  best school ever haha
13:25:44 <JohnMeacham> cmarcelo: yeah, I have not updated it since you started with it I think.
13:26:03 <cadabra`> So what you actually return is cons(first-result, expr-ref), which then can build the rest of the list.
13:26:12 <byorgey> codetoad: I think the problem is that n and d' are being inferred to have type Rational as well
13:26:17 <JohnMeacham> I could have sworn I found another judy binding in the wild somewhere. but now I can't find it. hmm... perhaps I drempt it.
13:26:20 <dejones> laura85: sent you a pm
13:26:23 <oerjan> codetoad: remove "types =" i think
13:26:28 <byorgey> codetoad: so when you call arbitrary to get values for them, it's infinite recursion
13:26:34 <laura85> dejones, are blocked (see server message)
13:26:42 <oerjan> oh wait
13:26:45 <byorgey> codetoad: try using % instead of / to construct the rational result
13:26:52 <byorgey> @type (%)
13:26:53 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
13:27:02 <byorgey> then n and d' will be Integers
13:27:10 <oerjan> codetoad: anyway "where types = a :: Rational  makes no sense there
13:27:13 <EvilTerran> cadabra`, it's more that you return cons(first-expr-ref, second-expr-ref)
13:27:16 <dejones> laura85: works now :)
13:27:22 <oerjan> oops
13:27:28 <EvilTerran> as it were
13:27:33 <cadabra`> Oh, right
13:27:41 <oerjan> gah, of course it does.  actually that's a nice trick
13:27:50 <EvilTerran> (1+1 : ...), not (2 : ...)
13:28:04 <codetoad> changing from (/) to (%) did the trick
13:28:07 <EvilTerran> head turns that into (1+1), then the evaluation of (+) turns that into 2
13:28:23 <codetoad> could i have also somehow specified that n, d' were to be Integers?
13:28:24 <cadabra`> Yeah
13:28:36 <dejones> laura85: re-sent pm  :)
13:28:36 <cadabra`> I'm jumping too far ahead
13:29:14 <laura85> dejones, oh didn't you get my answers?
13:29:23 <oerjan> codetoad: you would have to use % anyhow
13:29:33 <oerjan> because / doesn't work with Integers
13:29:45 <dejones> laura85: nope, didn't get the answers...
13:29:52 <Maddas> laura85: Did you register? :-)
13:30:21 <Maddas> FWIW, I agree that Zurich is quite a nice place to live. Out of curiosity, where do you live/study now, dejones?
13:30:24 <laura85> Maddas, nope, how can i do that?
13:30:48 <ertai> q: What's the point about the Read class?
13:30:53 <Maddas> laura85: Did you receive any messages (notices) from NickServ (or similar) when messaging dejones?
13:30:58 <dejones> Maddas: University of Kentucky in Lexington, KY.  Master's student in Computer Science of Engineering.
13:31:05 <laura85> Maddas, uh no
13:31:11 <Maddas> laura85: oh, never mind then :-)
13:31:14 <oerjan> ertai: to allow turning Strings into values of various types
13:31:35 <Maddas> laura85: (If you did receive them, they might have been in your IRC server status window, not the channel window, depending on the IRC client.)
13:31:38 <oerjan> including Strings read from files etc.
13:31:42 <codetoad> oerjan: types = .. was from a quickcheck tutorial i found.  i understood it to be equivalent to prop_f' :: Rational -> .. but i am probably mistaken
13:31:44 <ertai> oerjan: Yes, my question is little more deep
13:31:47 <Maddas> dejones: cool :-)
13:31:57 <Maddas> dejones: Were you going to do CS?
13:32:00 <oerjan> codetoad: i think that's right now :)
13:32:12 <ertai> oerjan: because there is no method in that class right?
13:32:30 <oerjan> ertai: sure there is
13:32:32 <oerjan> @src Read
13:32:33 <lambdabot> class Read a where
13:32:33 <lambdabot>   readsPrec    :: Int -> ReadS a
13:32:33 <lambdabot>   readList     :: ReadS [a]
13:32:33 <lambdabot>   readPrec     :: ReadPrec a
13:32:33 <lambdabot>   readListPrec :: ReadPrec [a]
13:32:35 <laura85> dejones, join #{surname of prof you named}
13:32:48 <ertai> oerjan: oops
13:32:48 <dejones> Maddas: Yep, continue on with CS for PhD.  I'd like to go some place that is doing things with functional programming languages, particularly haskell.
13:32:50 <oerjan> @src ReadS
13:32:50 <lambdabot> Source not found. I am sorry.
13:33:06 <oerjan> er, ReadS a = String -> [(a,String)] iirc
13:33:26 <dejones> Maddas: any suggestions?  :)
13:33:55 <Heffalump> I've not heard of any Haskell research in Zurich
13:33:58 <cadabra`> My junior level algorithms class is using C# for the projects. yay.
13:34:04 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/6367#a1
13:34:13 <dejones> Heffalump: Some in the NetOS group, at least according to their projects page.  :)
13:34:16 <oerjan> ertai: oh btw ReadPrec is a more efficient ghc addition
13:34:18 <ertai> oerjan: ok thanks I will read a little more about
13:34:45 <Heffalump> dejones: oh, interesting
13:34:48 <ertai> these things and come back later with more questions
13:34:53 * Maddas doesn't really know whether the ETH is active in functional language programming.
13:34:55 <oerjan> (H98 only has the first two methods)
13:35:11 <dejones> Maddas, Heffalump: Yeah, I'm interested in Haskell and Systems programming uses.  :)
13:35:12 <dons> Cale, do you know Chris Anand ?
13:35:33 <Cale> dons: I did, I haven't talked to him in a long while.
13:35:33 <dejones> hey dons, it seems that array index bug was already reported... I found the bug report.
13:35:42 <dons> dejones: cool.
13:35:47 <dejones> :)
13:35:57 <dons> http://reddit.com/r/programming/info/6c4d3/comments/ looks interesting, Cale. i wondered if there was a paper?
13:36:26 <Cale> Cool Coconut is doing well, it seems :)
13:36:33 <dons> did you work on that?
13:36:41 <Cale> Coconut is the project I was working on a few years ago, yeah.
13:36:51 <dons> ah, i guessed right
13:36:56 <cadabra`> I'm trying to make "123" -> [1, 2, 3] .. Thinking that --- map (\x -> (read x)::Int) (head $ lines s)  --- should work. But I'm missing a type issue somewhere..
13:37:22 <dejones> Cale: That looks like a cool project.  :)
13:37:32 <EvilTerran> cadabra`, each element of a String is a Char
13:37:40 <EvilTerran> ?hoogle Char -> Int
13:37:40 <lambdabot> Data.Char.digitToInt :: Char -> Int
13:37:40 <lambdabot> Data.Char.ord :: Char -> Int
13:37:40 <lambdabot> Data.ByteString.Char8.count :: Char -> ByteString -> Int
13:37:43 <oerjan> cadabra`: what do you want lines for?
13:37:43 <laura85> Maddas, EE isn't, but CS dept is ^^
13:37:54 <EvilTerran> > map digitToInt "123"
13:37:55 <lambdabot>  [1,2,3]
13:37:55 <dons> > map digitToInt "1213"
13:37:55 <lambdabot>  [1,2,1,3]
13:37:58 <cadabra`> Aha, and read takes a String
13:38:16 <Igloo> Cale, dejones: http://hackage.haskell.org/trac/ghc/ticket/2120
13:38:19 <lambdabot> Title: #2120 (Arrays allow out-of-bounds indexes) - GHC - Trac
13:39:27 <oerjan> > map (read . return) "123" :: [Int]
13:39:27 <lambdabot>  [1,2,3]
13:39:37 <dejones> Igloo: is the "proposal" supposed to be a code patch to do what is needed?  ;)
13:40:16 <cadabra`> oerjan: clever
13:40:39 <oerjan> cadabra`: intToDigit is more efficient though :)
13:40:44 <oerjan> er digitToInt
13:40:48 <cadabra`> :)
13:40:49 <ertai> q: derived Read, Show don't handle cyclic values right?
13:41:00 <byorgey> ertai: sure they do!
13:41:09 <byorgey> just maybe not in the way you want ;)
13:41:19 <Maddas> laura85: :-)
13:41:22 <Igloo> dejones: Yes, along with a summary to start the discussion, etc
13:41:25 <oerjan> ertai: well it gives an infinite String, which might not contain everything
13:41:39 <oerjan> > [[1..],[1..]]
13:41:40 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
13:41:44 <dejones> Cale, Igloo: Cale would probably be more qualified to do the proposal.  But, I am interested... it would probably help me learn Haskell better.  :)
13:41:53 <oerjan> (never gets to the second copy)
13:42:18 <byorgey> > sort . concat $ [[1,3..], [2,4..]]
13:42:21 <lambdabot> Terminated
13:42:32 <laura85> Maddas,  undergrad/masters/phd?
13:42:51 <oerjan> ertai: because of pureness and parametricity, there is no way in Haskell to actually _detect_ that a value is cyclic
13:42:58 <tromp> :t digitToInt
13:42:58 <Maddas> Master's, but on an internship right now.
13:42:59 <lambdabot> Char -> Int
13:43:15 <ertai> oerjan: yes I understand that
13:43:19 <tromp> > digitToInt 'a'
13:43:19 <lambdabot>  10
13:43:24 <tromp> > digitToInt '-'
13:43:25 <lambdabot>  Exception: Char.digitToInt: not a digit '-'
13:43:29 <dejones> Maddas: where are you at?
13:43:33 <tromp> > digitToInt 'z'
13:43:33 <lambdabot>  Exception: Char.digitToInt: not a digit 'z'
13:43:38 <tromp> > digitToInt 'f'
13:43:38 <lambdabot>  15
13:43:41 <tromp> > digitToInt 'g'
13:43:42 <lambdabot>  Exception: Char.digitToInt: not a digit 'g'
13:43:53 <tromp> kinda arbitrary notion of digit:)
13:44:01 <EvilTerran> hm. you'd think it'd either stop at 9 or go up to z
13:44:09 <oerjan> ertai: so Show is right out for any abbreviation.  Read could support it but the default derivations don't.
13:45:11 <tromp> > intToDigit 15
13:45:12 <lambdabot>  'f'
13:45:14 <tromp> > intToDigit 16
13:45:15 <lambdabot>  Exception: Char.intToDigit: not a digit 16
13:45:17 <ertai> that's too bad, because I was just happy to use an infinite (or cyclic) value but I remark that I must serialize them.
13:45:45 <tromp> should be called intToHexDigit
13:45:48 <oerjan> EvilTerran: yeah it's just to support up to hex...
13:46:11 <ertai> there is no library that could work on a lower level and detect sharing and cycles
13:47:09 <EvilTerran> ertai, it'd be implementation dependent
13:47:09 <oerjan> ertai: that would be almost the same as arbitrary function serialization i suspect?
13:47:09 <oerjan> because of thunks
13:47:10 <laura85> Maddas, cool, i'm undergrad.... bah
13:47:20 <EvilTerran> indeed, that too
13:47:46 <ertai> ertai: right, but that would be already useful
13:47:47 <oerjan> ertai: maybe try one of the graph libraries...
13:48:13 <ertai> actually that's an xmonad layout ;)
13:48:37 * oerjan has no experience with those though
13:49:28 <hpaste>  dmwit pasted "Any reason I should be worried about this?" at http://hpaste.org/6368
13:49:59 <ertai> I mean that's basically a simple data type that I want to use in an infinite way.
13:50:04 <dmwit> I ask because I couldn't find it in the libraries, and sometimes things are purposefully kept out of libraries because they're dangerous for some reason.
13:50:56 <oerjan> dmwit: i recall that being discussed before.  you might want to be careful about list lengths...
13:51:13 <Feuerbach> Why can't I partially apply type synonim? Say, if I declare type Reader r a = (r->a), I can't then make (Reader r) an instance of Monad
13:51:14 <oerjan> (might be in an older hpaste)
13:51:19 <for2> hi i'm new to haskell i'm having difficulties doing numerical conversion between types.. i have this function that takes two GLints but i have two GLfloats
13:51:23 <dmwit> Yeah, it does depend on the two lists having the same length.
13:51:32 <for2> i've been playing around with fromRational and toInteger with no luck
13:51:42 <dmwit> oerjan: If that's the only concern, I'm pretty happy. =)
13:52:00 <dmwit> :t fromIntegral
13:52:01 <lambdabot> forall a b. (Num b, Integral a) => a -> b
13:52:09 <dmwit> for2: ^^
13:52:19 <oerjan> dmwit: unless you have a bug i don't think there should be other problems.  it's equivalent to tuples after all
13:52:23 <for2> ok thx i'll give it a shot
13:52:26 <dons> for2: you want to convert floats to ints?
13:52:31 <Maddas> dejones: ETH Zurich :-)
13:52:33 <for2> yes
13:52:38 <dons> for2: likely you'll need to truncate/round/ceiling/floor them
13:52:41 <dmwit> Oh, I got it backwards then.
13:52:42 <dons> :t truncate
13:52:42 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
13:52:47 <dons> > truncate pi
13:52:48 <lambdabot>  3
13:52:54 <dejones> Maddas: ahhh.  Cool.  :)
13:52:54 <for2> Ooooo
13:52:56 <Maddas> laura85: We didn't actually have any other choice yet when I began -- but I would've done this in either case.
13:53:03 <oerjan> Feuerbach: the instance selection is based on data/newtype being special.  with type there is no guarantee the a is actually put last in the result...
13:53:11 <dejones> Maddas: How do you like ETH Zurich?
13:53:26 <oerjan> which is required for instance selection being a first-order unification process, iiuc
13:54:42 <Maddas> dejones: I like it a lot, but it's quite different from US universities, for all that I know.
13:54:54 <dejones> Maddas: How so?
13:55:00 <oerjan> Feuerbach: you can do type Reader = (->) though :)
13:55:01 <dejones> Maddas: How is it different...?
13:55:21 <Feuerbach> oerjan: I know, and that confuses me :)
13:55:29 <oerjan> Feuerbach: oh and having instances of "type"s is an extension anyhow
13:55:45 <Maddas> dejones: Want to take it somewhere else? I feel like it's not on-topic for #haskell :-)
13:56:21 <dejones> Maddas: sure, #ethzurich ?
13:56:23 <oerjan> Feuerbach: it could have tried to eta-reduce the definition for you automatically, but then you might just wonder why it didn't work in other cases (when a doesn't appear only last)
13:56:26 <Maddas> sure :-
13:57:05 <awesame> do you folks think it's accurate to describe linked lists as "algebraically fundamental"?
13:57:45 <awesame> or maybe I'll just say "simple" instead of "fundamental"
13:57:54 <Maddas> Algebraically?
13:57:56 <BSP_> Feuerbach: the kind of (->) is * -> * -> *, but it's not easy to say what "kind" the Reader type synonym has. you kind of have to think about it as a macro
13:57:58 <Feuerbach> oerjan: and where does "being last" come from?
13:58:01 <dons> they're the epitome of recursive types mirrored in a recursive structure
13:58:07 <dons> i'd call them "foundational"
13:58:17 <awesame> foundational, that's not bad
13:58:30 <dons> along with sums and products types
13:58:41 <oerjan> Feuerbach: in a data or newtype you can only leave out final arguments for instances
13:58:58 <dons> lazy lists in particular epitomise many fundamental aspects of computer science
13:59:06 <oerjan> and the type definition would have to translate into a data or newtype with the corresponding property
13:59:24 <dons> recursion and induction
13:59:31 <awesame> yeah, that firms up my intuition
13:59:42 <oerjan> e.g. you cannot make an instance for (-> r), only for (r ->)
14:00:49 <oerjan> BSP_: actually i vaguely recall ghc _does_ ascribe kinds to type synonyms (and requires them to be used consistently)
14:01:25 <BSP_> oerjan: really? if you can come up with an example of that i'd be interested to see it
14:01:43 <dmwit> :t (ask >>=)
14:01:44 <lambdabot> forall (m :: * -> *) a b. (MonadReader a m) => (a -> m b) -> m b
14:02:38 <travisbrady> can someone tell me why in this example http://en.wikibooks.org/wiki/Haskell/Concurrency the readerThread doesn't just recurse forever?
14:02:56 <oerjan> BSP_: well like type Flip a b c = a c b, then (without an annotation to the opposite) you could only use it with kinds a :: * -> * -> *, b :: *, c :: *
14:03:18 <dons> travisbrady: readTChan will block
14:03:33 <dons> travisbrady: and when the main thread ends, all other threads are collected
14:03:36 <oerjan> but it would be perfectly legal to annotate it and get a :: (* -> *) -> * -> *, b :: * -> *, c :: *, say
14:03:47 <oerjan> iiuc
14:04:08 <travisbrady> dons: ahhh, thank you
14:04:30 <dons> search for daemonic threads in Control.Concurrent docs
14:05:03 <oerjan> (but only one of those for a given definition)
14:06:28 <oerjan> http://haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#type-synonyms "GHC currently does kind checking before expanding synonyms (though even that could be changed.)"
14:06:31 <lambdabot> Title: 8.4. Extensions to data types and type synonyms, http://tinyurl.com/3czedj
14:06:49 <BSP_> oerjan: yeah was just playing with it: interesting, thanks for the info
14:09:27 <dejones> Cale: you going to join the start-up with Coconut?  ;)
14:09:54 <Cale> dejones: I'm actually looking more toward pure mathematics lately.
14:13:42 <dejones> Cale: I see.  :)
14:13:52 <dejones> Cale: what university are you at again?  I forget...
14:14:08 <Cale> Waterloo.
14:14:27 <Cale> But for a master's degree I'll probably end up going somewhere else.
14:15:17 <Cale> (I'm essentially finished my BMath degree, modulo a course I annoyingly am forced to take because of an uncorrectable clerical error.)
14:15:53 <cjb> Cale: wow, you're an undergrad?
14:15:56 <Heffalump> how on earth did that happen?
14:16:08 <cjb> I guess I shouldn't be surprised -- the high school students on here are smarter than me too ;-)
14:17:30 <Cale> Heffalump: Somehow the marks for two of my courses were recorded incorrectly on my transcript. I took steps to get them corrected back while I was still at the university, someone told me things were okay, but they apparently didn't actually fix the issues, which I didn't find out about until I'd been away for a couple yers.
14:17:33 <Cale> years*
14:18:04 <Cale> One of the mistakes was still fixable, for the other, the prof had left the country, and records of the marks were destroyed.
14:18:14 <dons> by fire?
14:18:31 <Cale> By the university not storing them for whatever reason.
14:18:31 <Heffalump> and there was no documentation of your steps to fix them?
14:18:39 <dons> Heffalump: so what are we going to do about merch for the hackathon?
14:18:45 <Heffalump> dons: merch?
14:18:46 <Cale> Heffalump: Apparently.
14:18:50 <cadabra> I'm trying to match "abc#def#ghi" with (as:'#':bs:'#':cs), but it won't
14:18:54 <dons> -endise
14:19:13 <dons> cadabra: won't work like that. you'll need to split recursively
14:19:19 <Heffalump> I guessed that, and I thought the answer was nothing. We're providing food instead.
14:19:23 <cadabra> oh
14:19:33 <dons> Heffalump: true, but we're cashed  up this time -- more than we need?
14:19:54 <dons> > map (\x -> case x of '#' -> '\t'; _ -> x) "abc#def#geh"
14:19:55 <lambdabot>  "abc\tdef\tgeh"
14:19:58 <dmwit> cadabra: In that pattern match, you would end up with types (as :: Char), (bs :: Char), and (cs :: [Char])... do you see why?
14:19:58 <dons> > words $ map (\x -> case x of '#' -> '\t'; _ -> x) "abc#def#geh"
14:19:59 <cadabra> because as/bs/cs match single items, not lists?
14:19:59 <lambdabot>  ["abc","def","geh"]
14:20:09 <cadabra> except for cs
14:20:12 <dmwit> right
14:20:17 <cadabra> I see, okay
14:20:33 <dmwit> And (++) isn't a constructor, so you can't match on that.
14:21:08 <cadabra> Aha, : is a ctor but ++ is an ordinary function
14:21:13 <dmwit> yep
14:21:53 <oerjan> > groupBy (const (=='#')) "abc#def#geh"
14:21:54 <lambdabot>  ["a","b","c#","d","e","f#","g","e","h"]
14:21:59 <oerjan> er
14:22:17 <oerjan> > groupBy (const (/='#')) "abc#def#geh"
14:22:18 <lambdabot>  ["abc","#def","#geh"]
14:22:18 <idnar> > groupBy (const (/='#')) "abc#def#geh"
14:22:19 <lambdabot>  ["abc","#def","#geh"]
14:22:20 <idnar> heh
14:22:28 <dmwit> > groupBy (\x y -> x /= '#' && y /= '#') "abc#def#geh"
14:22:29 <lambdabot>  ["abc","#","def","#","geh"]
14:22:37 <dons> dmwit: nice
14:22:47 <dons> groupBy, I never think of that for splitting
14:22:54 <dmwit> Me neither. =)
14:22:57 <dmwit> oerjan++
14:23:00 <dons> \x y -> x /= '#' && y /= '#' looks arrows-ish
14:23:10 <dons> prize for golfing that to something nice
14:23:12 <dmwit> liftM2 (&&) (x /=) (y /=)
14:23:46 <dmwit> > groupBy (\x y -> liftM2 (&&) (x /=) (y /=) '#') "abc#def"
14:23:47 <lambdabot>  ["abc","#","def"]
14:23:57 <smg> > filter (/='#') $ groupBy (\x y -> x /= '#' && y /= '#') "abc#def#geh"
14:23:58 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
14:23:58 <dejones> Cale: that sucks...
14:24:14 <dmwit> > filter (/='#') $ groupBy (\x y -> x /= '#' && y /= '#') $ "abc#def#geh"
14:24:14 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
14:24:24 <dmwit> > filter (/="#") $ groupBy (\x y -> x /= '#' && y /= '#') $ "abc#def#geh"
14:24:24 <lambdabot>  ["abc","def","geh"]
14:24:27 <smg> hehe
14:24:28 <Cale> dejones: Yeah, but I'm pretty much over it :)
14:24:35 <smg> nice one
14:24:51 <oerjan> > groupBy ((&&) `on` (/= '#')) "abc#def"
14:24:52 <lambdabot>  ["abc","#","def"]
14:24:55 <dejones> Cale: The Waterloo solar car team is great.  I've met them a few times in competitions.  They are cool.  :)
14:24:59 <dmwit> oerjan: OOOO
14:25:16 <dmwit> dons: I think it's prize time. =)
14:25:16 <cadabra> neat
14:25:20 <Cale> dejones: Yeah, I remember seeing a solar car or two around :)
14:25:22 <roconnor> I did it!  I got partitionEithers added to the GHC libs!
14:25:28 <dmwit> Yes!
14:25:35 <smg> roconnor: nice, but what's it?
14:25:50 <gwern> @src partitionEithers
14:25:50 <lambdabot> Source not found. You type like i drive.
14:25:51 <dmwit> partitionEithers :: [Either a b] -> ([a], [b])
14:25:51 <Igloo> roconnor: Sorry about all the bumps along the way!
14:25:56 <gwern> roconnor: you lie!
14:25:57 <dejones> Cale: haha.  Yep, lots of fun with those guys at the solar car competitions.  :)
14:26:01 <gwern> you lie like a rug
14:26:09 <gwern> the words coming out of your mouth are filth!
14:26:18 <gwern> @hoogle partitionEithers
14:26:18 <lambdabot> No matches found
14:26:29 <dmwit> partitionEithers xs = ([a | Left a <- xs], [b | Right b <- xs]) -- smg
14:26:34 <smg> i see hehe
14:27:49 <gwern> dmwit: so it goes [Direction a] -> ([Left a], [Right a])?
14:28:01 <gwern> (or is left/right the Either type?)
14:28:02 <stepcut> guru challange, guess the output of this function before running it, everywhere (mkT (\s -> reverse (s ++ show (length s)))) (Just "hello")
14:28:12 <sebell> gwern: Either!
14:28:14 <dmwit> gwern: Left/Right are the Either constructors.
14:28:20 <stepcut> s/challange/challenge/
14:28:28 <dons> stepcut: mkT eh?
14:28:39 <stepcut> yeah
14:28:41 <sebell> Earl Grey?
14:28:54 <dmwit> nice
14:29:07 <gwern> that's not very intuitive, I don't think. data Either = Left | Right? where do these directions come from
14:29:08 <thetallgu1> dons: is that like "Et tu, mkT, eh?"
14:29:10 <oerjan> :t mkT
14:29:11 <lambdabot> Not in scope: `mkT'
14:29:23 <sebell> gwern: They're not directions, they're hands :)
14:29:25 <dmwit> gwern: They're just convenient opposites.
14:29:32 <dons> stepcut: i give up. too much generics magic in one pass there  :)
14:29:42 <dons> let me check with my generics guru, elliottt
14:30:15 <dmwit> gwern: And you know what they say: the only intuitive interface is the nipple, and even that is learned.
14:30:47 <whee> gwern: Right means the right thing happened, Left means something else :)
14:31:04 <dmwit> > return 3 :: Either String Int
14:31:05 <lambdabot>  Right 3
14:31:22 <dmwit> > fail "hey!" :: Either String Int
14:31:22 <lambdabot>  Left "hey!"
14:31:26 <stepcut> dons: yeah, HAppS has a function, gReplace f x = everywhere (mkT f) x, and I was trying to use it to do, 'gReplace decodeString', to fix the encoding on all the strings in my data type :)
14:31:40 <gwern> whee: that's a terrible pun
14:31:50 <dons> stepcut: oh my
14:32:17 <stepcut> dons: happs unicode support is broken at the moment :-{
14:32:20 <bitrot> not too hard, but juuuuust right.
14:32:37 * bitrot picks the right window
14:32:47 <thetallgu1> dons: but it makes for amusing examples.
14:33:40 <dons> thetallgu1, stepcut: wow.
14:33:48 <dons> its pretty awesomely obfuscated :)
14:33:51 <roconnor> Igloo: thanks!  I suppose adding stuff to the standard lib ought not to be too easy
14:33:51 <thetallgu1> dons: unexpecte, eh?
14:34:10 <dons> this is a whole new world of obfuscated haskell right here
14:34:16 <dmwit> So what does it do?
14:34:17 <stepcut> dons: hehe
14:34:21 <dmwit> (For us non-gurus?)
14:34:28 <thetallgu1> Take out the reverse and try it again
14:34:44 <dons> > everywhere (mkT (\s -> reverse (s ++ show (length s))) everywhere (mkT (\s -> reverse (s ++ show (length s)))) (Just "hello")
14:34:44 <lambdabot> Unbalanced parentheses
14:34:47 <stepcut> dmwit: the result is, Just "01e6l20o4l8h", not entirely clear on what it does
14:34:53 <dons> > everywhere (mkT (\s -> reverse (s ++ show (length s)))) (Just "hello")
14:34:53 <lambdabot>   Not in scope: `mkT'
14:34:56 <dons> boo
14:35:36 <roconnor> @src Eithre
14:35:36 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
14:35:38 <roconnor> @src Either
14:35:38 <lambdabot> Source not found. You speak an infinite deal of nothing
14:35:44 <oerjan> > foldr (\x s -> reverse ((x:s) ++ show (length (x:s)))) "0" "hello"
14:35:45 <lambdabot>  "01e6l20o4l8h"
14:35:51 <oerjan> yay i was right
14:35:54 <dons> heh
14:36:36 <dmwit> Oh, that's a weird function.
14:37:14 <thetallgu1> in any case, gReplace does not do what we were hoping.
14:38:32 <dmwit> > foldr ((reverse .) . (:)) [] [1..8]
14:38:32 <oerjan> so everywhere applies the function to every subconstructor of the same type before applying it to the whole
14:38:32 <lambdabot>  [2,4,6,8,7,5,3,1]
14:39:17 <stepcut> gReplace (show . (length :: String -> Int)) (Just "hello") --> Just "2"
14:39:35 <oerjan> heh
14:39:55 <thetallgu1> oerjan: yes, there's a note about that in the Data.Generics examples, but I read it late at night and can't find it again.
14:39:58 <oerjan> > foldr (\x s -> show (length (x:s))) "0" "hello"
14:39:59 <lambdabot>  "2"
14:40:24 <oerjan> > scanl (\x s -> show (length (x:s))) "0" "hello"
14:40:24 <lambdabot>  Couldn't match expected type `[String]'
14:40:36 <oerjan> > scanr (\x s -> show (length (x:s))) "0" "hello"
14:40:37 <lambdabot>  ["2","2","2","2","2","0"]
14:42:52 <shepheb> when working in a monad transformer, what's the canonical way to catch IO errors like a file not existing?
14:43:39 <lispy> shepheb: I'm not sure, but isn't there a catchIO or sometihng?
14:43:42 <lispy> ?hoogle catchIO
14:43:42 <lambdabot> No matches found
14:43:45 <lispy> ?hoogle catch
14:43:45 <lambdabot> Prelude.catch :: IO a -> (IOError -> IO a) -> IO a
14:43:45 <lambdabot> Control.Exception.catch :: IO a -> (Exception -> IO a) -> IO a
14:43:45 <lambdabot> System.IO.Error.catch :: IO a -> (IOError -> IO a) -> IO a
14:43:45 <dons> shepheb: MonadError for your type?
14:43:49 <thetallgu1> This illuminates the probably a bit: http://www.cs.vu.nl/boilerplate/testsuite/gshow/Main.hs
14:43:51 <oerjan> :t catchError
14:43:52 <lambdabot> forall (m :: * -> *) a e. (MonadError e m) => m a -> (e -> m a) -> m a
14:44:11 <shepheb> dons: ah, yes.
14:44:35 <oerjan> IO is a MonadError and that should trickle up - but i'm not sure if the throw/catch will preserve all your intermediate transformer actions
14:45:03 <shepheb> oerjan: that's not a problem here, it's very self-contained
14:46:05 <oerjan> @instances- Control.Monad.Error MonadError
14:46:05 <lambdabot> IOError IO, e (Either e), e (ErrorT e m), e (RWST r w s m), e (ReaderT r m), e (StateT s m), e (WriterT w m)
14:46:50 * oerjan notices that lambdabot commands which are prefixes of each other is bad for abbreviating things.  especially for the shorter one.
14:47:12 <oerjan> @inst Monad
14:47:13 <lambdabot> Maybe you meant: instances instances-importing list
14:47:19 <oerjan> @insta Monad
14:47:20 <lambdabot> Maybe you meant: instances instances-importing index list paste unmtl
14:49:01 <oerjan> prefixes otherwise take precedence over edit distance i think, so there would have been no problem with those extra at the end if the prefix hadn't been ambiguous
14:49:14 <johnny10119> please i need mailer corect inbox mailer i can give some thing in retun please
14:49:57 <dmwit> You are probably in the wrong channel.
14:50:16 <johnny10119> ok so were do i go then
14:50:44 <whee> #mailer-corect-inbox-mailer?
14:50:55 <Cale> johnny10119: Does this have anything to do with Haskell programming?
14:51:20 <Valodim> haha
14:51:27 <mperillo> hi all
14:51:28 <Cale> Haskell is a pure functional programming language.
14:51:33 <dmwit> mperillo: Hiya!
14:51:33 <Cale> mperillo: hello
14:51:53 <mperillo> I have found a possible bug in the Haskell98 Report, where should I report it?
14:52:01 <Cale> mperillo: Well, what is it?
14:52:04 <dmwit> You'd better start here. =)
14:52:09 <smg> mperillo: can you show us?
14:52:23 <Cale> mperillo: There are a number of things which are considered bugs in the Report.
14:52:27 <dmwit> haha
14:52:30 <dmwit> too true
14:52:54 <mperillo> http://groups.google.it/group/comp.lang.haskell/browse_thread/thread/ac9271f77d8a2859/e6893012371a80c8
14:52:56 <lambdabot> Title: possible bug in the Haskell report - comp.lang.haskell | Google Gruppi, http://tinyurl.com/26ch73
14:52:58 <oerjan> mperillo: also there is a list of errata
14:53:38 <dmwit> bug
14:53:45 <mperillo> oerjan, where can I found it?
14:53:54 <dmwit> Not a terribly important one, though, given the amount of n + k patterns these days.
14:54:50 <mperillo> dmwit, right, its only a type
14:54:59 <mperillo> s/type/typo/
14:55:07 <oerjan> mperillo: http://haskell.org/definition/haskell98-revised-bugs.html
14:55:09 <lambdabot> Title: Haskell 98 (Revised Report): ERRATA
14:56:21 <mperillo> oerjan, thanks; it is not linked in http://haskell.org/haskellwiki/Definition
14:56:22 <lambdabot> Title: Language and library specification - HaskellWiki
14:56:24 <oerjan> http://www.haskell.org/haskellwiki/Language_and_library_specification also contains an email for reporting
14:56:25 <lambdabot> Title: Language and library specification - HaskellWiki, http://tinyurl.com/2to3n6
14:57:32 <oerjan> mperillo: sure it is, that's where i found it (those are redirections to the same page)
14:58:17 <mperillo> oerjan, you are right, I totally missed it (I was serching for "errata")
14:59:44 <oerjan> although it hasn't been updated for a while, good luck on the email still being valid
15:00:16 <mperillo> oerjan, ok I have sent the email, thanks for the help
15:02:38 <oerjan> You're welcome :)
15:02:40 <johnny10119> hi
15:03:02 <johnny10119> do u have mailer
15:03:12 <oerjan> johnny10119: you just asked
15:03:32 <johnny10119> are u there
15:03:44 <dmwit> Do you have a web browser?
15:04:24 --- mode: ChanServ set +o bos
15:04:44 <johnny10119> yes i do
15:04:55 --- mode: bos set +b *!*@82.128.27.*
15:04:55 --- kick: johnny10119 was kicked by bos (bos)
15:05:03 --- mode: bos set -o bos
15:05:10 <solrize> i cn haz spam ?
15:05:25 <cjb> yes, you can has spamburger
15:05:59 <dmwit> bos :: spamburger -> banhammer
15:08:13 <roconnor> @faq I can haz spam?
15:08:13 <lambdabot> The answer is: Yes! Haskell can do that.
15:12:00 <smg> dmwit: maybe you should have asked him if he "has brain" :)
15:12:35 <dmwit> I was thinking that, but then decided this channel is just usually so polite that it would be...
15:12:40 <dmwit> I don't know, mean. =P
15:12:54 * roconnor made a lemon custard pie for pi day.
15:13:08 * vincenz is jealous
15:13:20 <oerjan> I CAN HAS BRAAAAAINS?
15:13:29 <oerjan> (the zombie cat)
15:13:57 <roconnor> when is lambda day?
15:14:37 <shepheb> roconnor: June 14, the birthday of Alonzo Church?
15:14:43 <smg> oerjan: :)
15:14:59 <smg> oerjan: you like that I CAN stuff? maybe you should go for LOLcode :)
15:15:12 <shepheb> or maybe September 12, birthday of Haskell Curry.
15:16:19 <dmwit> June 14 is a nice round quarter year from pi-day.
15:16:58 <dmwit> Also, it's very close to my birthday and my brother's birthday: I'd get to celebrate for three days in a row!
15:16:59 <shepheb> September 12th is almost a half-year from pi day, though
15:17:23 <smg> someone is interesting in implementing LOLCode Parser in Haskell for fun with me?
15:17:28 <dmwit> Yeah, but the date it's closest to is September 11th.
15:17:37 <dmwit> smg: I believe it's been done.
15:17:49 <smg> dmwit: :(
15:17:53 <shepheb> the 14th is my birthday, actually. I'm probably biased therefore, but it seems more appropriate if it were Church's birthday rather than Curry's, this is lambda day
15:18:04 <dmwit> smg: Which certainly shouldn't stop you, of course. =)
15:18:08 <roconnor> smg: you can still do one.
15:18:15 <smg> sure, would i use parsec?
15:18:23 <dmwit> Parsec is nice.
15:18:25 <whee> I don't see a haskell implementation listed here: http://lolcode.com/implementations/implementations
15:18:26 <lambdabot> Title: implementations:implementations · LOLCODE
15:18:58 <oerjan> curry's can be ski day :)
15:19:13 * monochrom sends shepheb a virtual pie for pi birthday.
15:19:14 <smg> so i usually use parsec, or should i implement first a parser module?
15:19:28 <tromp> shld be Schoenfinkels?!
15:19:34 <dmwit> http://www.haskell.org/pipermail/haskell-cafe/2007-May/026142.html
15:19:35 <lambdabot> Title: [Haskell-cafe] data PLZ a, http://tinyurl.com/2my4vu
15:19:39 <dmwit> That's what I was thinking of. =P
15:20:12 <smg> Schoenfinkeling, a german word, really ugly :)
15:20:22 <dmwit> smg: You could probably even take advantage of Haskell's parser... make an EDSL. =)
15:20:30 <shepheb> monochrom: sorry, I should have been more specific: /June/ 14th is my birthday
15:20:47 <resiak> you weren't born monthly
15:20:48 <resiak> ?
15:20:51 <smg> dmwit: so first i need LOLCode in EBNF or something do i?
15:21:02 <dmwit> smg: yeah, something like that
15:21:11 <shepheb> I'm going to see if I can get my roommates to get me an xmonad t-shirt.
15:21:18 <dmwit> smg: It's best if you can get it into left-recursive form, too.
15:21:48 <smg> that's the thing, hard to find a syntax document for it
15:21:59 <piojo> has anybody else written a "mapWithIndices :: (e -> i -> e') -> Array a i e -> Array a i e'" function?
15:23:34 <dmwit> kind error
15:24:04 <smg> strange i won't find a good grammar of it dmwit
15:25:10 <dmwit> smg: Language design was one of the last things on the minds of the creators.
15:25:24 <whee> smg: does this help? http://lolcode.com/contributions/bnf-grammar-goldparser
15:25:24 <lambdabot> Title: contributions:bnf-grammar-goldparser · LOLCODE
15:27:27 <smg> whee: that is incredible
15:27:27 <smg> :)
15:28:08 <whee> smg: it might need to be updated for lolcode 1.2 though :)
15:29:53 <shepheb> what's the canonical way to read an entire file strictly, either by line or all at once?
15:30:24 <dmwit> hGetContents, hClose?
15:30:49 <smg> whee: i'm just thinking to design my own language for fun
15:30:51 <shepheb> dmwit: oh, does the latter force the reading? I think lazy IO is biting me here.
15:30:57 <dmwit> Oh, maybe not.
15:31:00 <smg> whee: but i don't know if this is cool :]
15:31:08 <dmwit> hm
15:31:20 <shepheb> would $! hGetContents h work?
15:31:33 <dmwit> $! just evaluates to the first constructor, so no.
15:31:49 <shepheb> @src ($!)
15:31:49 <lambdabot> Source not found. You type like i drive.
15:31:51 <dmwit> But (s == s) `seq` hGetContents h would be good, maybe.
15:31:58 * roconnor dislikes lazy IO!
15:32:07 <bos> contents <- hGetContents h; length contents `seq` return contents
15:32:15 <dmwit> Yeah, or length.
15:33:03 <quicksilver> string Bytestring version of hGetContents would be better.
15:34:02 <shepheb> bos++: that worked, thank you.
15:34:24 <gwern> 'Even Higher-Order Functions for Parsing or Why Would Anyone Ever Want To Use a Sixth-Order Function? by Chris Okasaki. Journal of Functional Programming, 8(2):195-199, March 1998. ' <-- awesame
15:34:53 <monochrom> haha
15:34:56 <johnny10119> s.kepki';-
15:35:06 <Jaak> @type \f -> head . concat . map tail . group . iterate f
15:35:07 <lambdabot> forall a. (Eq a) => (a -> a) -> a -> a
15:35:33 <Jaak> i just love haskell :')
15:35:37 <johnny10119> hi lamb
15:37:19 <dmwit> ?type \f -> let xs = iterate f in fst . head . dropWhile (uncurry (/=)) . zip xs (tail xs)
15:37:20 <lambdabot>     Couldn't match expected type `[a]'
15:37:20 <lambdabot>            against inferred type `a1 -> [a1]'
15:37:20 <lambdabot>     In the first argument of `zip', namely `xs'
15:37:31 <dmwit> ?type \f -> let xs = iterate f in fst . head . dropWhile (uncurry (/=)) $ zip xs (tail xs)
15:37:32 <lambdabot>     Couldn't match expected type `[a]'
15:37:32 <lambdabot>            against inferred type `a1 -> [a1]'
15:37:32 <lambdabot>     In the first argument of `zip', namely `xs'
15:37:35 * monochrom wonders if johnny10119 is even lambda-calulus-complete.
15:37:36 <dmwit> meh
15:37:45 <dmwit> Are any of us?
15:38:29 <monochrom> shh :)
15:38:39 <johnny10119> y
15:39:04 <monochrom> Well, to tell you the truth, give me more paper and ink, and I can keep going.  So can you, I'm sure.
15:39:15 <hpaste>  travisbrady pasted "Threaded file read and processing" at http://hpaste.org/6369
15:39:43 <travisbrady> does anyone have pointers for the above paste?
15:40:17 <travisbrady> i'm attempting to read a space-delimited file and count the unique values in some field
15:40:27 <johnny10119> yes i can get one
15:41:05 <travisbrady> i'm running into trouble with the concurrency stuff, basically have a race
15:41:16 <monochrom> I wonder if you must use threading.
15:41:26 <dmwit> johnny10119 sounds awfully botty.
15:41:38 <travisbrady> monochrom: i don't have to, i'm just using this as a way to learn about the concurrency stuff
15:41:41 <dmwit> @vixen Do you think johnny10119 is a bot?
15:41:41 <lambdabot> no, how dare you ask if i'm a bot!
15:41:47 <dmwit> heh
15:42:03 <Heffalump> oh, johnny10119 is lambdabot?
15:42:14 <bos> travisbrady: you can use newTChanIO to create a TChan in the IO monad, fwiw
15:42:43 <travisbrady> bos: ahhh, and avoid the atomically $ bit?
15:42:45 <johnny10119> y do u guys tink am an bot?
15:42:47 <travisbrady> bos: hi by the way
15:42:53 <bos> :-)
15:42:56 <Heffalump> johnny10119: do you know what Haskell is?
15:43:09 <bos> yes, exactly
15:43:20 --- mode: ChanServ set +o bos
15:43:39 --- mode: bos set +b *!*@ml82.128.13.107.multilinks.com
15:43:39 --- kick: johnny10119 was kicked by bos (bos)
15:43:55 --- mode: bos set -o bos
15:44:08 <smg> so i specified my language in EBNF
15:44:12 <bos> travisbrady: what's the problem you're seeing?
15:44:14 <smg> now i need to work with parsec? :)
15:44:20 <dejones> > iterate (+1) 0
15:44:20 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
15:44:39 <dmwit> http://buckwheat.stanford.edu/weird.png <-- where did that 's' just before the "Interrupted" come from?
15:45:53 <travisbrady> bos: basically if i call threadDelay in main i get the right answer, otherwise I get zero
15:46:19 <travisbrady> which means that i'm reading the TVar when exRows has not finished
15:46:28 <smg> so parsec is a good idea to build a parser?
15:46:38 <bos> travisbrady: oh!
15:47:02 <monochrom> smg: Yes.
15:47:14 <bos> travisbrady: the behaviour you're seeing is fine. your code has a bug.
15:47:17 <travisbrady> but i'm certain i have really structured the problem incorrectly, so i'm curious as to how a non-newb would do this
15:47:28 <travisbrady> bos: haha, yes, indeed
15:48:08 <bos> travisbrady: the problem is that you're using the same variable for communication between your worker threads as you are to signal that your work is complete. so your main thread can't tell that the work is complete. use a separate TVar for that.
15:48:37 <monochrom> smg: IMO there are only two choices that reduce work.  If you want to write a recursive-descent parser, Parsec.  If you want to feed LALR or something into a generator, Happy.
15:48:53 <smg> hehe
15:48:58 <smg> import Parsec fails damn
15:49:03 <quicksilver> monochrom: why not polyparse ?
15:49:13 <monochrom> Oh!  I forgot Polyparse.
15:49:15 <travisbrady> bos: oh i see, so have the pullRows accept a TVar Bool?
15:49:16 <SamB> smg: that way is, um, outdated
15:49:33 <smg> SamB: ?
15:49:39 <monochrom> import Text.ParserCombinators.Parsec
15:49:46 * EvilTerran wants to know why that isn't Text.Parser
15:49:52 <EvilTerran> i want a good reason, dammit
15:49:54 <bos> travisbrady: probably using an MVar would be even easier.
15:50:03 <EvilTerran> (... .Parsec)
15:50:08 <smg> ah
15:50:09 <monochrom> Because we have a fetish on combinators :)
15:50:10 <Jaak> EvilTerran: since 3.0 it is
15:50:16 <EvilTerran> yay
15:50:26 <EvilTerran> now to do the same for ReadP etc :P
15:50:26 <monochrom> @vixen Do combinators make you feel hot?
15:50:26 <lambdabot> others seem to think so, but i think i'm just alright :)
15:50:29 <bos> travisbrady: if you create an empty MVar, then the worker fills it and the master blocks on it, you get exactly the semantics you want.
15:50:40 <Jaak> wait, no. Text.Parsec
15:50:49 <bos> travisbrady: you could of course use a TMVar, but there's no need for transactional semantics.
15:50:59 <Jaak> but it makes more sense than Text.ParserCombinators.Parsec...
15:51:11 <bos> travisbrady: so. that's the standard way to solve that problem.
15:51:26 <travisbrady> bos: perfect, thank you
15:52:33 <bos> np
15:55:37 <lispy> if you have a grammar with a rule like, foo ::= A [B], meaning B is optional and you don't have a good default value for B, what do you do?
15:55:46 <lispy> Use Maybe B ?
15:56:10 <bos> lispy: are you talking in the context of parsec?
15:56:17 <monochrom> Yes, I would try that first.
15:56:19 <lispy> bos: yeah, guess I should have said that :)
15:56:28 <lispy> option Nothing parseB
15:56:32 <lispy> something like that is what I was thinking
15:56:39 <bos> lispy: there's a combinator that will attempt a parse and wrap it in Maybe if it succeeds
15:56:44 <oerjan> :t Text.ParserCombinators.Parsec.optional
15:56:45 <lambdabot> forall tok st a. Text.ParserCombinators.Parsec.Prim.GenParser tok st a -> Text.ParserCombinators.Parsec.Prim.GenParser tok st ()
15:56:59 <oerjan> hm not right
15:57:00 <EvilTerran> not that one
15:57:04 <oerjan> :t Text.ParserCombinators.Parsec.optionMaybe
15:57:05 <lambdabot> forall tok st a. Text.ParserCombinators.Parsec.Prim.GenParser tok st a -> Text.ParserCombinators.Parsec.Prim.GenParser tok st (Maybe a)
15:57:07 <tromp> try?
15:57:10 <oerjan> that was it
15:57:38 <lispy> ah, I guess http://legacy.cs.uu.nl/daan/download/parsec/parsec.html is no longer good to go by?
15:57:45 <oerjan> (those last two are not in the original manual iirc)
15:57:53 <solrize> does anyone know of a functional implementation of something like gzip?  i.e. not a C wrapper
15:57:55 <lispy> is there an updated version of the original manual?
15:58:41 <bos> lispy: the haddocks are quite good.
15:58:45 <lispy> tromp: try allows a parser to consume some input and then if it fails the next parser is able to start off as if the previous one never ran
15:58:53 <oerjan> lispy: i don't know.  most of it was still right before 3.0 i think
15:59:10 <lispy> thanks, I'll stick more to the haddock
15:59:21 * quicksilver agr
15:59:31 <quicksilver> for the previous version of parsec, the old manual was fine.
15:59:38 <quicksilver> for the new version, the haddock is supposed to be improved
15:59:46 <quicksilver> an awful lot you can guess from thetypes anyway :)
16:00:12 <lispy> sometimes I just don't like the way the haddock is organized.  For example, this page doesn't list very much of parsec's interface: http://www.haskell.org/ghc/docs/latest/html/libraries/parsec/Text-ParserCombinators-Parsec.html
16:00:12 <lambdabot> http://tinyurl.com/yzf69j
16:00:45 <lispy> I guess I want the combinators page
16:00:46 <sieni> solrize: why would you need a functional implementation of zlib?
16:00:57 <solrize> i want to compress a lot of short strings
16:01:04 <lispy> optionMaybe :: GenParser tok st a -> GenParser tok st (Maybe a)
16:01:08 <lispy> that must be what I want
16:01:23 <sieni> solrize: compress short strings o_O
16:01:28 <bos> lispy: that looks like it
16:01:52 <solrize> my idea is to compress a static text corpus to build up a compressor state, then compress each short string starting from that state
16:02:25 * lispy wonders if attempting to build a static analysis tool for python will actually pay off
16:02:31 <cjb> lispy: I'm interested in that
16:02:41 <cjb> lispy: does this include static typing in the language?  :)
16:03:00 <lispy> cjb: well my first task will be to build a parser that can look for special comments where we can encode types
16:03:11 <SamB> lispy: ... static ... analysis ... Python?
16:03:12 <cjb> lispy: have you seen the PEP?
16:03:12 <solrize> lispy, there's a lot of different tools like that, none of them can completely analyze python but most do a fairly large fragment
16:03:15 <gbacon> @pl \f -> read $ f $ sort n
16:03:15 <lambdabot> read . ($ sort n)
16:03:17 <SamB> ????
16:03:23 <solrize> look at PyPy for example, RPython is statically typed with inference, more or less
16:03:31 <gbacon> @pl \f n -> read $ f $ sort n
16:03:31 <lambdabot> (read .) . (. sort)
16:03:35 <lispy> cjb: no I haven't I've been looking for tools and haven't found any.
16:03:45 <solrize> lispy, pylint ?
16:04:11 <cjb> lispy: http://www.artima.com/weblogs/viewpost.jsp?thread=85551 , http://www.artima.com/weblogs/viewpost.jsp?thread=86641 , http://www.artima.com/weblogs/viewpost.jsp?thread=87182
16:04:12 <lambdabot> Title: Adding Optional Static Typing to Python
16:04:15 <lispy> interesting, my attempts to find static tools for python just lead me to a powerpoint presentation given by guido
16:04:23 <cjb> there's a syntax proposed there; I'd suggest implementing that, rather than using comments
16:04:32 <lament> python has static tools?
16:04:43 <ivan> rpython
16:04:45 <lispy> cjb: for this to be of any use to my (at work) it has to work with normal python
16:04:47 <solrize> also pyrex
16:05:01 <cjb> lispy: oh.  okay.
16:05:11 <lament> lispy: several people wrote type inferencers of some kind
16:05:27 <lispy> lament: why do they hide them :)
16:05:39 <lament> probably because they're incomplete and bitrot
16:06:22 <SamB> lispy: you'd have more luck using rpython, I think...
16:06:32 * lispy is looking up PEP, rpython and pylint, did I miss anything?
16:06:44 <SamB> lispy: ask which PEP
16:06:52 <cjb> lispy: PEPs are the method for proposing new python features.
16:06:56 <solrize> lispy: Shed Skin, Pyrex
16:06:58 <SamB> because a PEP is basically a python RFC
16:06:59 <solrize> those are python dialects
16:07:01 <Maddas> If you're interested in general approaches taken by similar projects for other languages, there has been some work describing adding type inference to Scheme.
16:07:03 <solrize> more or less
16:07:18 <solrize> stalin (scheme whole-program optimizing compiler) does extensive type inference
16:07:21 <lispy> er, rpython seems broken: http://www.rpython.org/
16:07:26 <solrize> and i just saw something last night about a fully static version of scheme
16:07:28 <ivan> it's part of pypy
16:07:31 <solrize> lispy, rpython is a sublanguage inside pypy
16:07:41 <Maddas> solrize: Other implementations do too, and have more accessible literature about their approach :-)
16:07:49 <SamB> solrize: scheme doesn't have those pesky attributes
16:08:07 <Maddas> Right, it's a lot easier there, I suspect. At least not as messy.
16:08:10 <solrize> yeah, python is just all over the place, i've come to think of it as a juvenile language
16:08:29 * Maddas liked it less the more he had to use it :-/
16:08:40 <monochrom> python is a fine juvenile language
16:08:47 <solrize> :)
16:08:53 <gnuvince_> @hoogle (::)
16:08:53 <lambdabot> Did you mean: (::)
16:08:53 <lambdabot> Prelude.undefined :: a
16:08:53 <lambdabot> Control.Monad.State.Class.get :: MonadState s m => m s
16:09:03 <Maddas> monochrom: But there are far nicer juvenile languages, which is why it bothered me :-)
16:09:05 <ivan> i've been in the python monkey house far too long
16:09:06 <solrize> looks like dcoutts wrote a zlib wrapper for haskell ?
16:09:19 <gnuvince_> What's the priority of (::)?
16:09:19 <SamB> what's a nicer juvenile language?
16:10:22 <lispy> hmm...pylint looks nice
16:10:25 * Maddas suggests Scheme and ducks
16:10:45 <lament> scheme is a nice language for teaching mathematicians to program.
16:10:59 <oerjan> gnuvince_: lower than all operators
16:11:10 <gnuvince_> oerjan: thank you
16:11:21 <solrize> i just also saw something about a pure functional scheme, i.e. without setq
16:12:12 <dons> did anyone else see fizz buzz in the type system? http://blog.omega-prime.co.uk/2008/02/27/
16:12:15 <lambdabot> Title: 24 :: (Bloggable a) => a -> IO () 1 1 29  2008  February  27 34
16:12:21 <solrize> hahaha
16:12:25 <whee> has anyone tried parsec 3's ByteString and ByteString.Lazy implementations? are they supposed to be faster than String?
16:12:27 <lispy> oh what if we had a lazy, static type checked, purely functional scheme... ;)
16:12:28 <SamB> I don't even remember what fizz buzz is supposed to do
16:12:34 <bos> whee: apparently they're very slow
16:12:37 <SamB> lispy: um
16:12:42 <lispy> dons: fizz buzz?
16:12:49 <SamB> that would basically be haskell with some features missing
16:12:57 <SamB> and an easier-to-parse syntax
16:13:01 <lispy> SamB: I know :)
16:13:02 <Maddas> And not really in the same domain as Python use :-)
16:13:03 <lament> solrize: no scheme has setq :)
16:13:08 <solrize> i like the blog name too
16:13:09 <solrize> :: (Bloggable a) => a -> IO ()
16:13:10 <whee> bos: I'm seeing about 33% slower for one of my parsers, so I'm not nuts then :)
16:13:14 <SamB> lament: they have it
16:13:18 <SamB> they just don't know how to spell
16:13:27 <lament> .....yeah
16:13:36 <dons> http://reddit.com/r/programming/info/6c4z4/comments/ :)
16:13:55 <bos> whee: compared to what, previous parsec, or parsec 3 on String?
16:14:02 <whee> bos: parsec 3 with String
16:14:05 <lispy> "there are no results here"
16:14:07 <dons> whee: yeah, there was a rumour.
16:14:16 <solrize> dons, that fizzbuzz has to go into "evolution of a haskell programmer"
16:14:38 <dons> perhaps 'bytestringparser' would be a better soln?
16:14:45 <SamB> solrize: I thought that was all fibs...?
16:14:50 <SamB> dons: eh?
16:14:50 <dons> or 'bytestringreadp'
16:15:08 <solrize> it was actuallly all factorial   iirc
16:15:17 <SamB> that was my other guess
16:16:33 <lament> dons: :D
16:17:32 <dons> byorgey: congrats!
16:17:37 <dons> bjpierce's group?
16:17:40 <byorgey> dons: thanks!
16:17:44 <byorgey> dons: yep
16:17:53 <dons> awesome!
16:18:03 <dons> one more haskeller on the inside :)
16:18:10 <byorgey> and stephanie weirich + steve zdancewic
16:18:16 <byorgey> hehe, indeed =)
16:18:18 <dons> yeah, excellent group
16:18:40 <dons> and Peng Li's still there?
16:19:29 <dmwit> Just barely, I think.
16:19:55 <byorgey> I don't know
16:20:10 <byorgey> ok, gotta run to a concert, catch you all later =)
16:23:09 <Saizan> ?seen dcoutts
16:23:09 <lambdabot> dcoutts is in #gentoo-haskell, #haskell, #ghc, #haskell-overflow and #haskell-soc. I last heard dcoutts speak 6h 46m 57s ago.
16:23:26 <Saizan> ?seen bringert
16:23:26 <lambdabot> I saw bringert leaving #darcs, #ghc and #haskell 36m 50s ago, and .
16:27:01 <dons> is 'Where()' in C# lazy bind? http://rapidapplicationdevelopment.blogspot.com/2008/03/how-systemlinqwhere-really-works.html
16:27:02 <lambdabot> Title: Rapid Application Development: How System.Linq.Where() Really Works, http://tinyurl.com/22a2r4
16:31:16 <mofmog> I love functional programming because it means  dont have to draw environment models
16:32:51 <gbacon> @pl \a b -> (length a) `compare` (length b)
16:32:51 <lambdabot> (. length) . compare . length
16:33:10 <oerjan> compare `on` length
16:33:30 <gbacon> @ty on
16:33:31 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
16:33:35 <gbacon> @src on
16:33:35 <lambdabot> (*) `on` f = \x y -> f x * f y
16:34:02 <gbacon> oerjan: where is on defined?
16:34:08 <dobblego> ?index on
16:34:08 <lambdabot> bzzt
16:34:15 <oerjan> @hoogle on
16:34:15 <lambdabot> Data.Function.on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
16:34:15 <lambdabot> Text.ParserCombinators.Parsec.Char.oneOf :: [Char] -> CharParser st Char
16:34:15 <lambdabot> Data.Function :: module
16:34:17 <dobblego> in bzzt :)
16:34:35 <dobblego> ?Src on
16:34:36 <lambdabot> Maybe you meant: rc src
16:34:37 <oerjan> a very useful module that
16:34:37 <dobblego> ?src on
16:34:37 <lambdabot> (*) `on` f = \x y -> f x * f y
16:35:01 <idnar> @type on
16:35:03 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
16:35:05 <gbacon> @karma+ oerjan
16:35:06 <lambdabot> oerjan's karma raised to 13.
16:35:08 <idnar> oh there
16:35:13 <oerjan> ?index unsafeLaunchMissiles
16:35:13 <lambdabot> bzzt
16:35:15 <dobblego> > let f = compare `on` length in f [1..10] [1..]
16:35:17 <lambdabot>  Terminated
16:36:16 <solrize> @karma lambdabot
16:36:16 <lambdabot> lambdabot has a karma of 1
16:36:20 <solrize> hehe
16:36:33 <EvilTerran> > let f = compare `on` length in f [1..10] [1..]
16:36:35 <lambdabot>  Terminated
16:36:40 <EvilTerran> oh, i see
16:36:48 <EvilTerran> thought it was just the bot being tempramental
16:37:07 <OceanSpray> Cale, you alive?
16:37:09 * EvilTerran thinks
16:37:26 <EvilTerran> see, this'd be another good application of zipAllWith
16:37:32 <oerjan> hm...
16:37:48 <OceanSpray> I still don't know how to construct a proper view.
16:37:49 <oerjan> > let f = compare `on` map (const ()) in f [1..10] [1..]
16:37:50 <lambdabot>  LT
16:37:54 <EvilTerran> ?type (++) -- what's this doing these days?
16:37:55 <lambdabot> forall m. (Monoid m) => m -> m -> m
16:38:00 <OceanSpray> > _|_
16:38:01 <lambdabot>  Parse error at "|_" (column 2)
16:38:13 <EvilTerran> > (EQ ++ LT, EQ ++ GT, LT ++ EQ, LT ++ GT)
16:38:14 <lambdabot>  (LT,GT,LT,LT)
16:38:27 <EvilTerran> > GT ++ EQ
16:38:28 <lambdabot>  GT
16:38:52 <oerjan> the first which is not EQ iirc
16:39:38 <EvilTerran> ok, f = (mconcat .) . zipAllWith (const $ const EQ) (const LT) (const GT)
16:39:50 <EvilTerran> (not that zipAllWith's in the standard library...)
16:40:08 <oerjan> so you didn't like my compare `on` map (const ()) ? :)
16:40:14 <EvilTerran> oerjan, ta. that makes sense.
16:40:14 <idnar> > [1] ++ [2]
16:40:15 <lambdabot>  [1,2]
16:40:17 <EvilTerran> i'm still thinking
16:40:18 <idnar> @instances Monoid
16:40:18 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
16:40:27 <idnar> oh duh
16:40:30 <EvilTerran> altho your way is fine
16:41:19 <EvilTerran> could do something clever with genericLength
16:41:22 <EvilTerran> ?type genericLength
16:41:22 <lambdabot> forall b i. (Num i) => [b] -> i
16:41:34 <EvilTerran> ... and instance Num [()]
16:43:36 <tromp> > () :: Num
16:43:37 <lambdabot>      Class `Num' used as a type
16:43:37 <lambdabot>     In the type `Num'
16:43:37 <lambdabot>     In an expression ty...
16:44:01 <tromp> @instances Num
16:44:01 <lambdabot> Double, Float, Int, Integer
16:44:14 <EvilTerran> or instance Num (Fix Maybe), if you want to be really evil about it
16:45:53 <EvilTerran> ... where newtype Fix f = Fix (f (Fix f))
16:46:23 <ivo> does anyone know litb (nickname) ? pls message me
16:46:48 <EvilTerran> so the elements of Fix Maybe'd be, what... iterate (Fix . Just) (Fix Nothing)
16:46:57 <oerjan> @seen litb
16:46:57 <lambdabot> I saw litb leaving #haskell 11d 23h 29m 40s ago, and .
16:47:13 <idnar> > () :: Num ()
16:47:13 <lambdabot>      Class `Num' used as a type
16:47:13 <lambdabot>     In the type `Num ()'
16:47:13 <lambdabot>     In an expression...
16:47:20 <idnar> er, that made no sense
16:47:28 <EvilTerran> idnar, what _are_ you doing?
16:47:37 <idnar> EvilTerran: getting confused, mostly
16:47:47 * EvilTerran ponders instance Num Bool and instance Num ()
16:47:52 <idnar> for some reason I briefly confused "type class" and "type constructor"
16:48:08 <EvilTerran> arithmetic mod 2 and mod 1, respectively :D
16:48:15 <ivo> yes, same here in icq , litb was last online at 2.3 , he was also missing at a test on thursday at study, seems strange, hope he is ok
16:48:32 <oerjan> oh
16:48:39 <EvilTerran> =/
16:48:59 * EvilTerran sends good vibes, just in case
16:49:23 <EvilTerran> (i'm not all evil. sometimes i can be GoodTerran. :P)
16:50:09 * EvilTerran chuckles at "yetAnotherOne has quit"
16:50:48 * EvilTerran wonders if instance Num Void would be arithmetic mod 0
16:51:21 <EvilTerran> seeing as N parameterless constructors => arithmetic mod N
16:51:36 <mofmog> that reminds me
16:51:40 <mofmog> is there a mod that can work on floats?
16:52:03 <dons> mofmog: so I added fmod to the cmath library yesterday :)
16:52:22 <EvilTerran> not in the standard library
16:52:44 <dons> http://hackage.haskell.org/packages/archive/cmath/0.2/doc/html/Foreign-C-Math-Double.html#v%3Afmod
16:52:46 <lambdabot> http://tinyurl.com/yr96me
16:52:49 <EvilTerran> you can do it with division and floor
16:53:02 <mofmog> that returns an Integer or something back doesnt it though?
16:53:11 <EvilTerran> or iteratively in O(log divisor) additions or something
16:54:20 <dons> > Prelude Foreign.C.Math.Double> fmod 7 pi
16:54:21 <lambdabot>   Not in scope: `fmod'
16:54:21 <dons> 0.7168146928204138
16:55:10 <tromp> > -1 `mod` 3
16:55:11 <lambdabot>  -1
16:55:21 <tromp> > -1 `rem` 3
16:55:22 <lambdabot>  -1
16:55:34 <tromp> anything that gives a sensible result?
16:55:39 <mofmog> > 2.4 `rem` 2.5
16:55:39 <lambdabot>  Add a type signature
16:55:42 <dons> :t quot
16:55:43 <lambdabot> forall a. (Integral a) => a -> a -> a
16:55:54 <dons> (-1) `quot` 3
16:55:56 <dons> > (-1) `quot` 3
16:55:56 <lambdabot>  0
16:56:33 <Cale> OceanSpray: hi
16:56:34 <tromp> i hate mod returning negative numbers
16:56:35 <idnar> :t div
16:56:36 <lambdabot> forall a. (Integral a) => a -> a -> a
16:56:36 <Cale> OceanSpray: what's up?
16:56:48 <OceanSpray> I have no idea how to contruct eye rays.
16:56:52 <idnar> > (-1) `div` 3
16:56:53 <lambdabot>  -1
16:57:04 <idnar> oh
16:57:18 <OceanSpray> rotateBy obviously doesn't work right,
16:57:39 <mofmog> is clean abandonware?
16:57:39 <OceanSpray> and I can't seem to figure out how to project unto a plane.
16:57:44 <mofmog> it seems like there havent been any updates
16:59:26 <OceanSpray> Is there a Matrix datatype?
17:00:57 <Cale> OceanSpray: in various linear algebra libraries, there is
17:01:04 <Defiler> In a literal Haskell string like "L\\x0a\n", the 'L' has no special meaning, right?
17:01:10 <Cale> OceanSpray: You could just implement matrix multiplication yourself.
17:01:11 <Defiler> I am trying to port a Haskell test suite to another langauge
17:01:22 <Cale> Defiler: right
17:01:53 <OceanSpray> I hated matrices in math class.
17:02:04 <Defiler> Cale: Thanks
17:02:46 <dons> mofmog: there's a few researchers working on it, that's about it
17:03:03 <oerjan> tromp: it doesn't, `mod` has higher precedence than unary minus
17:03:04 <Defiler> Has anyone used YEAST?
17:03:09 <oerjan> > (-1) `mod` 3
17:03:10 <lambdabot>  2
17:03:10 <Defiler> This appears to be some funny YEAST token
17:03:14 <mofmog> needs better linux support apparently
17:03:40 <tromp> ah, all is well:)
17:03:52 <oerjan> :t simpleFraction
17:03:52 <lambdabot> Not in scope: `simpleFraction'
17:04:12 <tromp> strange for unary minus to have such low precedence though
17:04:13 <oerjan> :t properFraction
17:04:13 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> (b, a)
17:04:22 <oerjan> tromp: it's the same as binary
17:04:39 <roconnor> @check \a b -> 0 <= b ==> 0 <= a `mod` b && a `mod` b < b
17:04:40 <lambdabot>  Exception: divide by zero
17:04:46 <roconnor> @check \a b -> 0 < b ==> 0 <= a `mod` b && a `mod` b < b
17:04:47 <lambdabot>  OK, passed 500 tests.
17:04:47 <oerjan> mofmog: properFraction gives you Float mod 1
17:05:03 <roconnor> Why no type abiguity error?
17:05:31 <oerjan> roconnor: defaulting
17:05:43 <roconnor> finally
17:06:11 * roconnor hopes check defaults to Integer rather than Int.
17:07:00 <oerjan> @check \x -> typeOf (x-0) == "Integer"
17:07:01 <lambdabot>  Couldn't match expected type `TypeRep'
17:07:11 <oerjan> oh
17:07:29 <idnar> @check \x -> x > fromInteger (maxBound :: Int)
17:07:29 <lambdabot>  Couldn't match expected type `Integer' against inferred type `Int'
17:07:30 <oerjan> @check \x -> typeOf (x-0) == typeOf(undefined::Integer)
17:07:30 <lambdabot>  OK, passed 500 tests.
17:07:36 <idnar> @check \x -> x > fromIntegral (maxBound :: Int)
17:07:37 <lambdabot>  Falsifiable, after 0 tests: -1
17:07:48 <idnar> uhm.
17:07:50 <idnar> @check \x -> x <= fromIntegral (maxBound :: Int)
17:07:51 <lambdabot>  OK, passed 500 tests.
17:08:09 <roconnor> idnar: inconclusive.
17:08:13 <idnar> indeed
17:08:14 <oerjan> it is not sure that it generates Integers that big in any case
17:08:27 <roconnor> @check \x -> x <= fromIntegral (maxBound :: Int) `div` 2
17:08:27 <lambdabot>  OK, passed 500 tests.
17:08:39 <oerjan> @check \x -> typeOf (x-0) == typeOf(undefined::Integer)
17:08:40 <lambdabot>  OK, passed 500 tests.
17:08:44 <idnar> > (maxBound :: Int) + 1
17:08:44 <lambdabot>  -2147483648
17:08:54 <roconnor> @check \x -> x <= fromIntegral (maxBound :: Int) `div` 20
17:08:55 <lambdabot>  OK, passed 500 tests.
17:08:58 <idnar> @check \x -> (x + (maxBound :: Int)) > 0
17:08:59 <lambdabot>  Falsifiable, after 4 tests: 1
17:09:09 <idnar> oops
17:09:18 <idnar> that doesn't make any sense either
17:09:29 <roconnor> x has been forced to be an int
17:09:37 <roconnor> @check \x -> (x + fromIntegral (maxBound :: Int)) > 0
17:09:38 <lambdabot>  OK, passed 500 tests.
17:09:42 <roconnor> \o/
17:09:44 <oerjan> i think my typeOf proves it well enough
17:09:49 <idnar> > 1 + fromIntegral (maxBound :: Int)
17:09:50 <lambdabot>  2147483648
17:09:56 <roconnor> oerjan: oh I missed that
17:09:59 <idnar> > (1 :: Int) + fromIntegral (maxBound :: Int)
17:10:00 <lambdabot>  -2147483648
17:10:10 <roconnor> @check \x -> typeOf (x-0) == typeOf(undefined::Int)
17:10:11 <lambdabot>  Falsifiable, after 0 tests: 1
17:10:15 <idnar> I saw the typeOf, was just exploring alternative possibilities
17:10:15 <roconnor> :)
17:10:25 <Notostraca> okay, where does hsc2hs look for .h files to include (that is, its search path)?
17:10:32 <idnar> after 0 tests?
17:10:36 <idnar> that seems off-by-one
17:10:41 <Notostraca> I am trying to compile mage 1.1
17:10:44 <idnar> perhaps it should say "0 successful tests"
17:11:01 <hpaste>  travisbrady pasted "Error running configure" at http://hpaste.org/6370
17:11:26 <travisbrady> i'm attempting to install 6.8.2 on ubuntu and got the "cannot determine current directory" msg
17:15:41 <OceanSpray> :t zipWih
17:15:42 <lambdabot> Not in scope: `zipWih'
17:15:44 <OceanSpray> :t zipWith
17:15:44 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
17:15:53 <OceanSpray> :t zip
17:15:53 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
17:22:58 <roconnor> @type liftM2
17:22:59 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
17:23:25 <czakey> hi
17:23:55 <OceanSpray> :t zipWith_
17:23:56 <lambdabot> Not in scope: `zipWith_'
17:24:23 <hpaste>  czakey pasted "pattern match" at http://hpaste.org/6371
17:24:47 <czakey> whats wrong with that pattern match?
17:26:08 <mauke> looks ok
17:26:20 <czakey> but not matching...
17:26:31 <mauke> then line doesn't contain "foo"
17:26:45 <czakey> im guessing that newline is somewhere at the end
17:27:10 <mauke> try printing (show line) instead of line
17:27:54 <EvilTerran> czakey, where's "line" coming from?
17:28:50 <czakey> input from remote client
17:29:17 <czakey> this is something like "server"
17:29:42 <czakey> accepting connections, and handling commands from clients
17:30:09 <czakey> i think there is better way to do that instead of case
17:30:32 <czakey> but there is only 3 or 5 commands
17:30:54 <czakey> so... case is simplest way I think
17:31:52 <czakey> oooh
17:32:02 <czakey> I've done it
17:32:15 <czakey> client sends "\r"
17:32:18 <czakey> at the end
17:32:21 <czakey> huh
17:32:30 <czakey> i guessed that was \n
17:32:56 <czakey> anyway thanks for "show line" mauke
17:32:57 <czakey> :)
17:34:27 <czakey> hmm
17:35:11 <czakey> but question is: how to match "foo <somethin non predictible here>"?
17:35:42 <EvilTerran> 'f':'o':'o':_
17:36:19 <EvilTerran> or if "foo" `isPrefixOf` line then ... else ...
17:36:24 <EvilTerran> ?index isPrefixOf
17:36:24 <lambdabot> Data.List
17:36:47 <czakey> thanks
17:37:14 <czakey> dirty but quite good for me :>
17:37:29 * EvilTerran would quite like a nicer way of doing the latter, but i doubt it'll ever really fit into haskell
17:38:21 <EvilTerran> er, former
17:38:38 <mauke> "foo" ++ _ would be a trivial extension
17:38:51 <EvilTerran> if only (case line of "foo"++_ -> ...) worked. and the general case.
17:38:51 <czakey> oh
17:38:53 <czakey> right
17:38:54 <mauke> sort of like n+k patterns, only better behaved
17:39:05 <czakey> thanks
17:39:13 <EvilTerran> that alone would be a trivial extension, but something general'd be quite a lot harder.
17:39:18 <EvilTerran> well, i guess that's views
17:39:24 <EvilTerran> ?hoogle dropPrefix
17:39:24 <lambdabot> No matches found
17:39:58 <EvilTerran> ?hoogle stripPrefix
17:39:58 <lambdabot> Data.List.stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]
17:40:06 <EvilTerran> there it is!
17:40:58 <EvilTerran> with views, you could write ''case line of (stripPrefix "foo" -> Just suffix) ->'' where you'd want to write ''case line of ("foo"++suffix) ->''...
17:41:40 <EvilTerran> or, with pattern guards, | Just suffix <- stripPrefix "foo"
17:41:50 <EvilTerran> (and that one has the bonus of even being implemented!
17:42:52 <czakey> anyway
17:43:07 <czakey> ("foo"++_) ->
17:43:10 <czakey> wont work
17:44:00 <EvilTerran> sadly not. we were just musing about possible extensions
17:44:10 <EvilTerran> i'd go for the "if isPrefixOf" version
17:44:18 <Gnezdo> I'm running haddock2 on that big tree of .hs files. Many mains cause haddock grief:  module `main:Main' is defined in multiple files: ...
17:44:35 <Gnezdo> Is there an easy way to tell it to ignore this or something?
17:44:36 <hpaste>  (anonymous) annotated "Error running configure" with "(no title)" at http://hpaste.org/6370#a1
17:45:19 <codemac> I'm getting this "Occurs check: cannot construct the infinite type:" error, and it says the probable cause is that a variable is applied to too many arguments?  What's the general way around this?
17:45:34 <EvilTerran> czakey, the (Foo:Bar:Baz:_) version has the advantage of not needing an Eq constraint on the type, but is ugly and horrible
17:45:42 <mauke> codemac: fix the code
17:45:53 <EvilTerran> and there's no harm in having an Eq constraint, because you're dealing with Chars, and they *do* have Eq implemented, so it's fine
17:46:01 <hpaste>  codemac pasted "(no title)" at http://hpaste.org/6372
17:46:49 <mauke> codemac: modTotal (l + 1) h f (t + l)
17:47:35 <codemac> mauke: thanks, stupid mistake
17:48:17 <czakey> EvilTerran: but (stripPrefix "foo" -> Just suffix) ->'' wont work
17:48:25 <czakey> I dont know why
17:48:27 <EvilTerran> czakey, sorry, that's another extension :P
17:48:35 <czakey> parse error on input `->'
17:48:37 <EvilTerran> an un-implemented one, at that
17:48:48 <czakey> heheh
17:48:59 <czakey> hm
17:49:13 <czakey> so whats the cleanest way of doing this?
17:49:16 <EvilTerran> i mentioned a couple of working solutions to your problem, then launched into a tangent about how nice it'd be given a couple of unimplemented extensions
17:49:27 <EvilTerran> if "foo" `isPrefixOf` line then ... else ...
17:49:32 <czakey> I dont realy want to write lexer for 3 commands ;>
17:49:47 <EvilTerran> the stripPrefix thing would only be a significant saving if you actually wanted the suffix, anyway
17:50:49 <Saizan> "foo"++ would be a more useful version of n+k patterns :)
17:51:01 <czakey> yup
17:51:13 <czakey> but "foo"++_ wont work
17:51:34 <Saizan> czakey: yeah, because ++ is not a constructor
17:51:37 * EvilTerran starts envisaging something horrible involving annotations to mark a function as invertible
17:52:09 <Saizan> that has been envisaged already!
17:52:22 <Saizan> here
17:52:48 <czakey> I guess its to late for me
17:53:31 <czakey> I'd better do it tomorrow
17:53:41 <czakey> eeek... later this day ;)
17:54:48 <EvilTerran> "invert x ++ y = z where x = ...; y = stripPrefix x z" or something
17:55:22 <czakey> uh
17:55:23 <roconnor> Epigram!
17:55:34 <EvilTerran> allow arbitrary expressions on the LHS of the first = or something :)
17:55:38 <EvilTerran> czakey, don't worry, that's not real haskell either
17:55:41 <czakey> 3 wtf/min
17:56:13 <Saizan> real haskell is so 98
17:57:32 <czakey> http://www.osnews.com/images/comics/wtfm.jpg
17:57:34 <czakey> ;)
17:58:13 <czakey> I'll back to this later that morning
17:58:31 <czakey> after some sleep I hope ;]
17:58:35 <czakey> cu
18:04:32 <glen_quagmire> is gtk2hs being deprecated (for windows)?
18:04:43 <araujo> mm...
18:04:56 <araujo> glen_quagmire, I don't think so .....
18:05:04 <mofmog> UGH type checking is killing me
18:05:30 <glen_quagmire> binary release of gtk2hs windows is for ghc 6.6.1  and building from source requires gladewin32 which seems to be down (http://gladewin32.sf.net)
18:05:31 <lambdabot> Title: Index of /
18:10:02 <Saizan> glen_quagmire: gtk2hs is surely still alive
18:11:31 <Saizan> http://haskell.org/gtk2hs/download/ <-- and the last release works with 6.8.1 apparently
18:11:32 <lambdabot> Title: Gtk2Hs  Download
18:12:29 <Toxaris> EvilTerran: your "invertible function" idea is basically provided by Prolog. concat(A,B,AB) should be able to bind one of the variables, if the other two are given :)
18:14:23 <Toxaris> I'm not sure whether a more unification-like aproach instead of pattern matching would be usefull without backtracking. I assume one would call it "first-class patterns" in Haskell instead of unification.
18:15:13 <Saizan> Toxaris: well, it depends if you allow non-deterministic patterns or not
18:15:24 <Toxaris> The obvious benefit would be to allow much more "custom" binding forms, which could be a good thing for EDSLs.
18:16:08 <Toxaris> Saizan: non-deterministic as in "n+k" with both n und k variables?
18:16:14 <Toxaris> "n and k2
18:16:16 <glen_quagmire> yah not working with 6.8.2  /me builds glade
18:16:46 <Saizan> Toxaris: yeah, or concat with less than two ground parameters
18:19:57 <hpaste>  mofmog pasted "(no title)" at http://hpaste.org/6373
18:20:08 <mofmog> hey can anyone help with ^^
18:20:26 <mofmog> this line: ("mod", (\(x:y:xs) -> (mod (truncate x) (truncate y)))) seems to be giving me trouble
18:20:53 <mofmog> the error is  No instance for (Integral Float)
18:20:53 <mofmog>       arising from use of `mod' at calcsrc.hs:30:35-63
18:21:12 <mauke> :t truncate
18:21:13 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
18:21:53 <SamB> mofmog: fromInteger
18:22:00 <mauke> mofmog: mod returns an integer
18:22:05 <SamB> add that around the mod thing
18:22:08 <mofmog> alright
18:22:09 <SamB> also, the usual syntax is
18:22:19 <SamB> (truncate x `mod` truncate y)
18:23:39 <mofmog> oh hey it works
18:23:41 <mofmog> ^_^
18:23:47 <mofmog> oh i see
18:23:52 <mofmog> i can't wrap an integer into Number
18:23:58 <mofmog> have to turn it into a float first
18:24:20 <mofmog> Actually, I think a better way to go around things is if i could make Number contain either a float or an integer
18:25:17 <hpaste>  Toxaris annotated "(no title)" with "untested refactoring ideas :)" at http://hpaste.org/6373#a1
18:27:53 <Toxaris> mofmog: data CalcVal = ... | Number (Either Float Integer) | ... :)
18:28:21 <Toxaris> mofmog: but I would consider data CalcVal = ... | Integer Integer | Double Double | ...
18:28:38 <Toxaris> or maybe CalcInt and CalcDouble
18:39:37 <Toxaris> Saizan: why are non-deterministic patterns a problem? I mean, they may not be useful without backtracking, but couldn't they be handled by the "take first matching pattern" rule like with regular pattern matching? The obvious idea would be to process   foo ("prefix" ++ x) = x  by calling   "prefix" ++ x   which yields  'p':'r':'e':'f':'i':'x':x  which can be used as a pattern for foo.
18:40:46 <Toxaris> now,   foo (x ++ y)  can be processed by calling (x ++ y) which unifies x with [] in the base case of ++'s definition and yields y as pattern for foo.
18:44:13 <Toxaris> hmm, not sure whether foo (x ++ "postfix") will work this way :( here we need recursion after all, so blindly unifying x with [] will not work
18:44:56 * Toxaris talks random nonsense and should go to bed
18:45:17 <solrize> any idea what Text.Packrat is?  something like parsec?  i'm trying to find a json parser and the first one that turned up, depends on packrat.
18:46:02 <roconnor> I assume it is a packrat parser
18:46:10 <solrize> oh yeah right, i forgot about those
18:46:11 <solrize> hmm
18:46:26 <solrize> anyway i guess that's another module to go and find.  hmm.
18:46:39 <solrize> anyone got a favorite json parser?  there doesn't seem to be one in hackage, in case anyone is making a list.
18:47:04 <roconnor> wasn't there someone blogging about parsing json in Haskell?
18:47:27 <roconnor> or doing something with json
18:47:46 <solrize> shrug
18:48:06 <scook0> you might be able to get away with a YAML parser
18:48:15 <solrize> i found the packrat parser
18:48:18 <solrize> http://darcs.haskell.org/SoC/haskellnet/Text/Packrat/Pos.hs
18:48:21 <solrize> http://darcs.haskell.org/SoC/haskellnet/Text/Packrat
18:48:22 <lambdabot> Title: Index of /SoC/haskellnet/Text/Packrat
18:48:58 <solrize> hmm, how do i import from the current directory?  the json file says "import Text.Packrat.Parse" which goes and looks in some library
18:50:52 <solrize> -i. -i doesn't quite do it
18:51:18 * SamB thinks he has class alias almost done
18:56:20 <gwern> hm. haskellnet. i keep meaning to get around to that
18:56:55 <solrize> this packrat stuff sounds pretty neat, can someone tell me again whether parsec is better?
18:57:15 <scook0> gwern: will that be before or after Control.World.Dominate? ;)
18:57:22 <gwern> parsec is a diffrent kind of parser from packrat, iirc, differen trade offs
18:57:27 <gwern> scook0: too impure
18:58:21 <gwern> although I suppose if I rulled the world I could force launchMissiles to be pure by destroying them all
19:01:11 <solrize> http://snippets.dzone.com/posts/show/3660  parsec based json parser
19:01:12 <lambdabot> Title: JSON Parser in Haskell [json] [haskell] [parsec]
19:01:26 <solrize> oh it's a lame subset or something
19:01:49 <gwern> 80/20...
19:01:55 <Maddas> 4
19:02:19 <solrize> yeah it says to use the one i found earlier, that uses the packrat parser
19:07:00 <solrize> bah, i changed all the module names in the .hs files to load in the current directory, there has to be a better way than that
19:10:18 <Notostraca> How is the speed doing on that json parser anyway?
19:10:34 <glen_quagmire> is it ok to have both 6.8.1 and 6.8.2 installed?
19:10:50 <solrize> i haven't timed it yet
19:11:07 <solrize> the packrat parser looks interesting but it's running a bunch of haskell code and building fancy data structures in order to parse
19:11:17 <solrize> i wonder if it can instead compile those grammars into harpy
19:12:12 <RichN> I'm having a problem with packages on my machine. I installed bytestring-0.9.0.4 in my GHC-6.6.1 installation. I tried to import ByteString, but since 6.6.1 has an older version registered, I get a "multiple package" error. Unfortunately, ghc-pkg now won't unregister bytestring-0.9.0.4!
19:13:36 <RichN> I installed Takusen-0.6. But when I tried to unregister it to instal 0.8, ghc-pkg again doesn't see it (but GHC does.) Has anyone seen something like this?
19:14:43 <RichN> Both of these packages are in my user directory, so I guess I could delete the directory and rebuild everything. I'd like to be able to stop this from happening again, though.
19:15:43 <Notostraca> I'm trying to compile mage 1.1 on windows, but it uses ncurses and apparently windoze doesn't have a port of that.
19:15:57 <Notostraca> So I'm trying to get it to use pdcurses
19:16:36 <Notostraca> the problem is with compiling the file Curses.hs
19:16:52 <Notostraca> I got it via curses.hsc
19:17:21 <Notostraca> using hsc2hs from ghc, but I don't know what the proper args for it are
19:17:44 <Notostraca> like how I get pdcurses in the build path...
19:18:40 <Notostraca> does anyone know about .hsc files and where you put C++ libraries for GHC to see them?
19:20:35 <pantsd> 2
19:21:05 <gwern> Notostraca: I would suggest installing cygwin as that almost surely includes ncurses for windows
19:21:17 <Notostraca> ok I will try it then
19:21:33 <gwern> failing that, I would suggest editing curses.hsc and look for comments including 'ncurses ' and changing that and the cabal file to read pdcurses
19:22:22 * gwern has no idea how compatiable pcurses is with ncurses these days
19:28:19 <Notostraca> both pdcurses and ncurses use a file called curses.h
19:28:40 <Notostraca> so that shouldn't be the problem
19:29:16 <Notostraca> but, even in cygwin, with what has got to be an environment with ncurses, I am getting the same thing
19:29:38 <Notostraca> undefined reference to <some thing from ncurses>
19:29:59 <Notostraca> over and over for each ncurses variable or function
19:30:50 <conal> does anyone here know of a rational reconstruction of the list/backtracking applicative functor (AF)?  if i decompose the list type into pieces (Maybe, pair, and recursion), i can see where the ZipList AF comes from, but not the list AF.
19:40:22 <Notostraca> gwern: mage wasn't ever meant to compile on windows, was it?
19:43:31 <gwern> Notostraca: roguelikes are rare on windows. they're a very Unix phenomenon - what with them using the 'terminal' and all
19:45:13 <araujo> a roquelike Haskell game!
19:45:17 <araujo> er
19:45:19 <araujo> roguelike
19:45:22 <araujo> :-)
19:46:21 <gwern> araujo: you sound gobsmacked
19:46:56 * araujo was thinking to code "the lambda revenge"
19:47:19 <gwern> the what?
19:47:52 <araujo> gwern, that's the roguelike title game :-)
19:48:13 <gwern> and what is a title game?
19:48:33 <araujo> oh, game title I meant
19:49:13 <gwern> araujo: how would you structure it?
19:50:03 * araujo would use λ as the main character
19:50:44 <gwern> not a @? SHOCK
19:50:50 <araujo> gwern, it would have a nice set of purely functional arsenal weapons
19:51:00 * BMeph hopes valve doesn't kick araujo to the curb...
19:51:24 <araujo> gwern, no way
19:51:24 <gwern> BMeph: we've got like 3000 years of prior art on λs
19:51:44 <araujo> mmm...
19:51:47 <BMeph> gwern: "we"? ;)
19:51:58 * gwern spoke royally
19:52:01 <araujo> BMeph, we are immortals around here
19:52:16 <Cale> Anyone here play a roguelike named powder?
19:52:20 <gwern> pronouns. they are a difficult concept
19:52:30 * BMeph walks off, muttering "there can be only one"...
19:52:31 <gwern> Cale: is it written in haskell?
19:52:39 <araujo> Cale, i doubt it is any better than 'the lambda revenge'
19:52:40 <Cale> gwern: no, not that I'm aware of
19:52:43 <Cale> heh
19:52:53 <araujo> heck, I will write an example
19:52:55 <araujo> it might be fun
19:53:12 <gwern> http://www.zincland.com/powder/index.php?pagename=about <-- a DS roguelike. fun
19:53:13 <lambdabot> Title: POWDER
19:53:22 <Cale> Yep, that's the one.
19:53:52 <Cale> It's had about 5 years of development and 102 releases.
19:54:07 <araujo> o_0
19:54:39 <gwern> release early, release often
19:54:41 <Cale> It's quite addictive :)
19:54:56 <SamB> DS?
19:55:01 <SamB> as in NDS?
19:55:04 <Cale> It strikes a nice balance between difficulty and playability :)
19:55:10 <Cale> SamB: yes
19:55:23 * gwern will try it then
19:55:27 <Cale> SamB: It runs on the DS, GBA, and PSP
19:55:36 <SamB> too bad I don't have any of those
19:55:39 <Cale> as well as Windows/Mac/Linux
19:55:41 <SamB> ah
19:55:45 <SamB> that's nice
19:56:25 <SamB> suppose it would be silly to run on GBA/DS and PSP but not PC ;-)
19:56:34 <Cale> Some of the bugfixes are kind of funny...
19:56:39 <Cale> "Throwing a -2 mithril chainmail in the air will no longer heal you."
19:57:09 <gwern> Cale: o.0 wonder what logic made that heal you before.,,
19:58:10 <Cale> I wonder if throwing a mithril chainmail of higher quality in the air *does* heal you...
19:58:19 <SamB> or perhaps it hurts you?
19:58:28 <SamB> in proportion to the quality
19:58:32 <Cale> I'll have to try now :)
19:58:55 <SamB> (but isn't mithril supposed to be light weight?)
19:59:11 * Cale goes off in search of a mithril chainmail :)
19:59:17 * scook0 is busy writing a roguelike in Haskell, strangely enough
19:59:51 <SamB> I am busy implementing class aliases
20:00:03 <scook0> though actually I'm currently swearing at GHC's implementation of deriving (Ix)
20:00:23 <SamB> what's it doing?
20:00:24 <scook0> because it doesn't seem to match the H98 spec
20:00:43 <SamB> what does the spec say?
20:01:14 <scook0> the spec says that when deriving Ix for a single-constructor type, the derived instance is "as shown for tuples"
20:01:36 <scook0> but GHC seems to traverse the components in the opposite order
20:02:31 <scook0> if I copy the H98 definition and change it from tuples to my datatype, I get different behaviour than from the derived instance
20:04:45 <SamB> wow
20:04:59 <SamB> report as a bug on GHC trac
20:05:23 <Cale> hmm, doesn't seem to do much.
20:05:31 <SamB> wouldn't be surprised if they ended up changing the standard instead though!
20:05:33 <SamB> dunno
20:05:41 <Cale> I'll have to try it with a +2 mithril chainmail at some point.
20:05:49 <Cale> But that'll be harder to find :)
20:06:32 <scook0> (what's frustrating is that I deliberately ordered my fields so as to get the Ix behaviour I wanted)
20:06:54 <SamB> in that case you probably should be instancing it explicitly anyway
20:07:05 <Cale> er... hmm, actually it does hurt you :)
20:07:20 <SamB> Cale: so I bet it hurts more if you use a +2
20:07:31 <SamB> why a -1 wouldn't have healed you, I don't know
20:09:25 <SamB> oh, because a +0 hurts too?
20:10:10 <Cale> hmm
20:10:28 <wagle_home> maybe a -2 weighs so much that it forces you to sit on your haunches on the floor (heal!)
20:10:37 <wagle_home> eerr..  heel
20:12:57 <wagle_home> scook0, can you reorder them again to get Ix to misbehave in the way you want?
20:13:07 <heatsink> Is "Peyton" SPJ's middle name, or part of his last name?
20:13:36 <scook0> wagle_home: I'd rather leave them as-is and write my own Ix, at this point
20:13:54 <andyjgill> Peyton is part of his last name.
20:14:03 <heatsink> okay, thanks.
20:14:15 <scook0> having (y,x) coordinates is weird, but at least it's consistent with curses
20:14:16 <SamB> as evidenced by Sarah's name
20:14:38 <SamB> @google "But I don't want functional programming"
20:14:38 <lambdabot> No Result Found.
20:14:46 <SamB> hmm.
20:14:56 <SamB> @google "I don't want functional programming"
20:14:57 <lambdabot> No Result Found.
20:15:04 <SamB> what was that quote?
20:16:43 <heatsink> I don't get it...
20:17:29 <SamB> "But I don't _want_ functional programming!"
20:17:29 <SamB> -- Sarah Peyton Jones, age 11, upon hearing the rules of Go
20:18:07 <Thiagarajan> hey..i am new to haskell and i have been trying to write a procedure to integrate using simpsons's rule....
20:18:30 <Thiagarajan> i wrote the procedure but it seems to throw an ambiguious type variable error
20:18:53 <SamB> @hpaste
20:18:53 <lambdabot> Haskell pastebin: http://hpaste.org/new
20:18:59 <Cale> Thiagarajan: let's have a look :)
20:19:55 <hpaste>  Thiagarajan pasted "(no title)" at http://hpaste.org/6374
20:20:18 <Cale> Thiagarajan: the error is in your type signature
20:20:39 <Cale> Thiagarajan: Num is a class, not a type constructor
20:21:15 <Thiagarajan> ooh...sorry...that was the wrong error message....
20:21:31 <Cale> If you leave out the signature, you get an ambiguity, yeah
20:21:45 <Thiagarajan> yeah...any ideas??
20:21:48 <Cale> It wants something to be both Floating and Integral, which is unlikely :)
20:21:56 <Cale> So you're missing a numeric conversion somewhere...
20:23:07 <Thiagarajan> does that mean i have to specify the types explicitly somewhere in the code??...i hope not..it makes my code look unelegant than it already is...:)
20:23:18 <allbery_b> no, it means you need a fromIntegral somewhere
20:23:18 <Cale> ah, you're using odd
20:23:20 <Cale> :t odd
20:23:21 <lambdabot> forall a. (Integral a) => a -> Bool
20:23:27 <shepheb> what's the safe way to destroy a window and its children in Gtk2Hs?
20:23:30 <Thiagarajan> aaah..okay
20:23:34 <Cale> But you're also dividing by integral
20:23:36 <Cale> :t (/)
20:23:37 <lambdabot> forall a. (Fractional a) => a -> a -> a
20:23:41 <Cale> er, by interval
20:23:51 <Cale> and nothing is both Integral and Fractional
20:24:01 <byorgey> Thiagarajan: you don't have to, but I recommend it -- writing down the types makes you think about the types, which helps you write correct code more quickly.
20:24:10 <Cale> so you'll need  h = (b - a) / fromIntegral interval
20:24:21 <byorgey> I don't think type signatures make code look inelegant.
20:24:26 <byorgey> but maybe that's just me =)
20:24:50 <Thiagarajan> byorgey..No..that's not what i meant.....i like writing down type signatures too...i meant explicitly in the code like (2 :: Int)..something like that
20:25:11 <Cale> Thiagarajan: explicit type signatures won't fix this problem, but they'll usually make the error message more informative
20:25:15 <byorgey> Thiagarajan: oh! I see.  indeed, that is rather inelegant, and thankfully it's very rarely necessary
20:25:15 <wagle_home> byorgey, yeah, but you dont necessarily write down the most general type
20:25:19 <allbery_b> oin general if you need to do that then you haven'twritten a proper type signature somewhere else
20:25:41 <allbery_b> (note that you can specify a signature for things declared in let or where)
20:26:02 <byorgey> wagle_home: I certainly try to.  performing type inference in one's head is a very useful skill. =)
20:26:05 <Thiagarajan> @cale yeah it works....now i have to see whether the procedure is correct
20:26:05 <lambdabot> Unknown command, try @list
20:26:24 <byorgey> hm, there ought to be a @cale command...
20:26:43 <Thiagarajan> :)
20:26:46 <shepheb> @quote cale
20:26:47 <lambdabot> glguy says: xxxx: did Cale get to you?
20:26:48 <Cale> @quote Cale
20:26:49 <lambdabot> Cale says: I should actually think before coding, but the type system is so good :)
20:26:57 <Cale> @quote Cale
20:26:58 <lambdabot> Cale says: I should write a program which automatically mods down any article containing the word "Agile"
20:27:43 <Cale> @palomer
20:27:43 <lambdabot> (_|_)
20:27:44 <Cale> @palomer
20:27:44 <lambdabot> I think vim is good for the rubbish bin
20:27:50 <Cale> @keal
20:27:50 <lambdabot> you need a Zh function in Haskell
20:27:54 <Cale> @keal
20:27:54 <lambdabot> obviously you never heard of Tier. theoretically it would work using nanobots
20:27:55 <whee> I'm really good at writing ugly code :(
20:28:46 <shepheb> did anyone else think "@cale = @quote cale" there?
20:29:18 <Cale> @yow
20:29:18 <lambdabot> They collapsed ... like nuns in the street ... they had no teen
20:29:18 <lambdabot> appeal!
20:29:21 <guenni2> @guenni
20:29:21 <lambdabot> Unknown command, try @list
20:29:24 <heatsink> Actually, that "yeah it works..." quote would suit cale I think.
20:29:39 <guenni2> @list
20:29:40 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
20:30:04 <wagle_home> @dwim
20:30:04 <lambdabot> Unknown command, try @list
20:30:11 <wagle_home> darn
20:30:13 <Cale> @keal
20:30:13 <lambdabot> write an algorthim that generates the correct responses for a phone survey based on number of rings whether answered how quickly hung up on and the mood of the receiver
20:30:15 <byorgey> heh
20:30:27 <Cale> @keal
20:30:27 <lambdabot> i dont really eat vegetables unless cheese is a vegetable
20:31:07 <Cale> @protontorpedo
20:31:07 <lambdabot> wil I make mroe $$ than learning java or APL or smalltalk or plt scheme or ruby or perl or clisp?
20:31:08 <shepheb> is yow a captured troll like keal?
20:31:18 <Cale> shepheb: no, it's zippy the pinhead quotes
20:31:29 <Cale> @protontorpedo
20:31:29 <lambdabot> how would haskell solve the following gnarley problem: many client distributed accross the usa, transfers must take palce in the form of file transfer, and data must be read from files, and recorded,
20:31:29 <lambdabot>  then other partners who apply taxes to this data and then give abck new files with taxes aded, then last transers to 4th parties who get us paid for the phone calls that are the product
20:31:32 <shepheb> cale: duly noted.
20:31:55 <whee> http://hpaste.org/6375 - anything obvious for getting rid of this case? (or anything else for that matter)
20:32:17 <whee> I can explain what I'm actually doing because it's nutty :|
20:32:20 <shepheb> what's the safe way to destroy a window and its children in Gtk2Hs?
20:33:24 <byorgey> shepheb: you need to stand back at least 10 feet
20:33:32 <byorgey> and wear proper protective eyewaer
20:33:44 <Cale> whee: That's an interesting way to indent let-expressions.
20:33:49 <SamB> then, lob a brick at it
20:33:58 <Cale> whee: I usually prefer to put the 'in
20:34:06 <byorgey> also, be sure to destroy the window first, if you destroy its children it gets really mad.
20:34:09 <shepheb> I won't say I walked into that, because I did say "in Gtk2Hs" :P
20:34:17 <Cale> ...the 'in' at the start of the following line
20:35:03 <whee> Cale: probably a better place..I think I've done that is an O'Caml habit
20:35:20 <whee> s/I've done//
20:35:48 <Cale> shepheb: Graphics.UI.Gtk.Windows.Window.throwBrick ;)
20:35:53 <SamB> shepheb: the fact that gtk2hs probably doesn't support feet will make this difficult, yes
20:36:11 <shepheb> Cale: I read all the way to the end of that line hoping for an answer, only to be dashed at the last.
20:36:17 <SamB> shepheb: honestly, look in the GTK documentation
20:36:31 <wagle_home> grep -r --color catchBrick src/
20:37:20 <Cale> shepheb: Actually, it's probably widgetDestroy
20:37:45 <Cale> Graphics.UI.Gtk.Abstract.Widget
20:38:10 <Cale> "\In most cases, only toplevel widgets (windows) require explicit destruction, because when you destroy a toplevel its children will be destroyed as well."
20:38:43 <wagle_home> i like it so much when they use "most" like that
20:39:03 <SamB> isn't there a way to do it like the user clicked on close?
20:39:06 <shepheb> cale: yes, thanks.
20:39:41 <shepheb> SamB: yes, and I have that for my main window. this is for an initial window that is to show the main window and die when the continue button is clicked.
20:39:51 <allbery_b> there are widgets that aren't asociated with specific windows, those are generally clearly documented in both GTK and gtk2hs documentation
20:40:34 * SamB waits for jhcp to recompile
20:41:34 <glguy> ?seen dons
20:41:34 <lambdabot> dons is in #xmonad, #haskell-soc and #haskell. I last heard dons speak 3h 10m 14s ago.
20:42:28 <allbery_b> shepheb: use a dialog window, the dialog stuff lets you bind buttons to close the dialog etc.
20:42:46 <shepheb> allbery_b: glade-3 crashed whenever I tried to create one.
20:42:54 <shepheb> that, and I just finished it.
20:42:56 <allbery_b> oh.  cute
20:42:57 <Cale> whee: Why are you using an accumulator?
20:42:58 <hpaste>  heatsink pasted "refactoring for whee (not verified)" at http://hpaste.org/6376
20:43:57 <hpaste>  scook0 pasted "deriving (Ix) vs. listArray" at http://hpaste.org/6377
20:44:02 <whee> Cale: that's just how I thought of the problem
20:44:03 <Cale> We could avoid the use of acc altogether I suspect. You're only adding things to the beginning of the list, so why not return a cons instead of tail recursing?
20:44:08 <whee> I don't really have a valid reason
20:44:23 <Cale> I expect that doing that will clean things up a bit.
20:44:28 <scook0> could someone with 6.8 please run that, and tell me what you get?
20:44:58 <scook0> (on 6.6 the arrays are different, which I consider to be a bug)
20:46:03 <Cale> scook0: Not equal
20:46:20 <scook0> Cale: thanks
20:48:14 <allbery_b> <SamB> isn't there a way to do it like the user clicked on close?
20:48:49 <allbery_b> that's trickier than it seems, because it's normally a dance with the window mamnager
20:49:15 <hpaste>  Cale annotated "(no title)" with "first step: remove accumulator" at http://hpaste.org/6375#a1
20:50:32 <atp> did you guys see this coconut tech talk Korollary posted to reddit?
20:50:37 <allbery_b> (basically the window is sent a WM_DELETE message and must either do cleanup and then widgetDestroy, or reject the close attempt [which is generally considered Improper Behavior])
20:50:40 <Cale> atp: yes
20:50:45 <atp> that is some hardcore shit
20:51:05 <Cale> atp: Yeah, I worked on it a little bit at the beginning of the project a few years back.
20:51:08 <atp> usually i see hour long talks and only watch 5 minutes, but this i sat through with bated breath
20:51:16 <byorgey> now that the accumulator is gone, there's no more need for a separate pairEvents function
20:51:18 <allbery_b> you could forge a WM_DELETE but it's actually better to ignore such forged events for security reasons
20:51:26 <atp> Cale: wow.
20:51:47 <atp> i wish the code for tanh had been more visible, i would have liked to see it
20:51:47 <byorgey> atp: link?
20:51:59 <hpaste>  Cale annotated "(no title)" with "next step, remove (now extraneous) helper function" at http://hpaste.org/6375#a2
20:52:01 <glguy> scook0: duplicating the Haskell 98 code on my own gives the same results
20:52:04 <atp> byorgey: http://www.youtube.com/watch?v=yHd0u6zuWdw
20:52:13 <byorgey> atp: thanks
20:52:14 <lambdabot> Title: YouTube - Coconut: COde CONstructing User Tool
20:52:15 <glguy> scook0: meaning that Data.Array matched haskell 98
20:52:21 <atp> byorgey: http://reddit.com/r/programming/info/6c4d3/comments/
20:52:29 <atp> byorgey: not much in the way of useful comments though
20:53:22 <byorgey> cool, I'll watch it tomorrow (not enough time before bed tonight...)
20:53:34 <atp> byorgey: do, it's really fascinating
20:53:58 <scook0> glguy: you got "arrays are equal" from my sample program?
20:54:00 <atp> i love it when hardcore assembly hackers and hardcore functional programmers get together and kick ass
20:54:21 <glguy> scook0: reconstructing the sample instance from Haskell98
20:56:17 <scook0> glguy: the derived and H98 instances seem to give the same results for range, but different results for listArray
20:56:55 <glguy> ah, the deriving specifically
20:57:20 <hpaste>  Cale annotated "(no title)" with "possible next step, use pattern guard" at http://hpaste.org/6375#a3
20:57:28 <scook0> i.e. for the derived instance, listArray doesn't behave in the way range suggests
20:57:31 <glguy> the automatic deriving switches the precedence of the components of the Pos constructor
20:57:40 <glguy> nothing to do with listArray
20:57:43 <Cale> whee: how is that?
20:57:43 <glguy> it's that deriving Ix
20:57:49 <glguy> doesn't do what your commented code does
20:58:04 <whee> Cale: you're coding faster than I can read and understand :)
20:58:26 <Cale> whee: I have a feeling that splitting up the code a little more may help a bit, in order to express what's semantically going on here --  I don't actually understand what the code is really doing.
20:58:45 <glguy> scook0: hmm, nevermind :)
20:58:51 <glguy> something more devious is going on
20:59:05 <Cale> whee: For example, that conditional in matchingEvent is something which looks like it should have a name.
20:59:16 <scook0> glguy: pretty sure it's to do with conversion to Int indices
20:59:44 <scook0> and listArray making incorrect assumptions about those indices
21:00:18 <whee> Cale: basically I have a list of events (start or stop), and I'm trying to pair them up
21:00:23 <scook0> listArray assumes the mapping from (Ix a) => a -> Int is monotone
21:00:35 <scook0> but the derived instance violates that assumption
21:00:44 <Cale> whee: okay...
21:01:03 <whee> but sometimes the start doesn't have a matching stop (no matching makeId), so I have to rely on a start and match the buildId. I thought of it as a filter, but there's that find in there that needs the rest of the list
21:01:31 <Cale> whee: ah, okay, I understand now.
21:01:39 <glguy> listArray (l,u) es =
21:01:40 <glguy>     let n = safeRangeSize (l,u)
21:01:42 <glguy>     in unsafeArray (l,u) (zip [0 .. n - 1] es)
21:01:44 <glguy> from Data.Array.Base
21:02:23 <scook0> I believe zip [0 .. n - 1] gives different results from zip (range (l, u))
21:02:26 <scook0> which is the problem
21:02:43 <Cale> whee: This might be an unfoldr...
21:02:56 <scook0> I get correct results if I use the H98 instance, or the H98 definition of listArray (or both)
21:03:12 <Cale> hmm
21:03:22 <Cale> Not quite :)
21:04:02 <Cale> er, actually, yeah, it is...
21:04:10 <Cale> Followed by a catMaybes :)
21:04:15 <whee> unfoldr confuses me every time :)
21:04:28 <Cale> :t unfoldr
21:04:29 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
21:04:50 <Cale> So the type b is our sequence of log entries.
21:05:06 <Cale> a is going to be Maybe CompleteBuild
21:05:48 <BMeph> whee: If unfoldr gives you problems, you could use a helper function to organize the base case/loop functions.
21:06:01 <Cale> and the function we pass to unfoldr is going to (given that there are any entries left) look for (maybe) a matching entry, and return it along with the tail of the sequence
21:06:41 <Cale> Note that so long as there are elements left, it'll return Just, because no matter what, we want to continue processing elements.
21:07:13 <glguy> scook0: looks like the specific bug is that the derived "index" function is rong
21:07:15 <glguy> wrong
21:08:33 <whee> Cale: why is a Maybe CompleteBuild and not [CompleteBuild]?
21:09:00 <Cale> whee: We only find one match per iteration.
21:09:05 <Cale> (or none at all)
21:09:10 <Cale> at least, as I understand it...
21:09:13 <whee> er, yeah
21:09:26 <Cale> We could find *all* matching events, if that would be better.
21:09:32 <Cale> You could use something like partition
21:09:45 <Cale> and split out the matching and non-matching events
21:09:57 <Cale> But that doesn't look like what this does :)
21:10:12 <whee> no, you're right
21:10:34 <whee> so the function passed to unfoldr will contain the find on the tail of the sequence?
21:11:11 <Cale> yeah
21:12:49 <Cale> I don't have your L module, so I can't check if this is right, but...
21:12:51 <Cale> @hpaste
21:12:51 <lambdabot> Haskell pastebin: http://hpaste.org/new
21:13:26 <Cale> er, hang on a sec
21:13:34 <Cale> I'm actually not quite done :)
21:13:47 <whee> I can paste the LogEntry (L) module if you want it
21:13:50 <whee> it's pretty simple
21:15:58 <hpaste>  Cale pasted "refactoring" at http://hpaste.org/6378
21:16:12 <Cale> I *think* that's right...
21:16:44 <whee> that's nuts
21:16:48 <whee> :P
21:17:31 <Cale> see if it typechecks :)
21:18:37 <Cale> Note that catMaybes is in Data.Maybe
21:18:56 <Cale> and unfoldr is in Data.List of course
21:18:58 <whee> yep, typechecks and works
21:19:02 <Cale> awesome
21:19:14 <Cale> Do you want to go over it so you know how it works?
21:19:23 <Cale> Or does it make sense?
21:19:46 <whee> I'll have to prod it for a bit and make sense of it
21:20:10 <glguy> Cale: I found the patch and ticket for the array behavior discussed last night, #1046 committed by Igloo
21:20:12 <glguy> seems intentional
21:20:22 <Cale> glguy: Yeah. He mentioned to me that it was.
21:20:29 <Cale> glguy: It's still really ugly.
21:20:38 <whee> Cale: thanks for the help
21:20:45 <Cale> whee: No problem :)
21:21:03 <Cale> whee: Let me know if anything doesn't make sense, or if you need more code cleanup :)
21:21:33 <kbateman> I've got a little question about labelled fields in datatypes.
21:21:45 <Cale> kbateman: sure
21:21:58 <kbateman> data Rec = Rec  { field1 :: Int, field2 :: Int }
21:22:39 <kbateman> field1 and field2 are field labels, as well as functions of Rec -> Int for reading fields
21:22:58 <scook0> I have a feeling I know where this question is going :)
21:23:02 <Cale> kbateman: right
21:23:25 <kbateman> If I want a function that mutates r, I use r { field1 = 3 } or whatever.
21:23:33 <Cale> yeah, that works
21:24:10 <Cale> Unfortunately, it doesn't really give you a *function* for changing records, it just modifies the record in question.
21:24:10 <kbateman> Is there no simpler method for this than "changeField1 r n = r { field1 = n}"
21:24:23 <Cale> Not really.
21:24:50 <scook0> it's possible to use Template Haskell to derive "changeField1" and friends for you
21:25:00 <scook0> (which people have already done)
21:25:06 <kbateman> It just seemed awfully wordy, I thought I was missing something.
21:25:28 <scook0> but the TH code will end up expanding into what you've just written
21:25:41 <Cale> It's unfortunate that the record update syntax doesn't somehow hand you a function for updating records.
21:25:49 <kbateman> As long as I don't have to type it, that's the important thing. :)
21:26:48 <kbateman> It might have to do with changing multiple fields.  Multiple change-one-field functions would be inefficient then.
21:27:01 <Cale> Slightly, yeah.
21:27:53 <kbateman> Ok, well thanks then.
21:28:13 <Cale> Some people have proposed that rather than being field extractors, the field labels should refer to lenses, which is just a fancy way of saying something like (Rec -> Int, Int -> Rec -> Rec)
21:28:50 <scook0> and then of course there are all the various "new record system" proposals
21:28:58 <Cale> So you'd have some functions get and set which would extract the required functions from the lens, and have a syntax like:  set field1 n r
21:28:59 <whee> Cale: I think it makes sense now. Not sure if I would've ever been able to come up with it, though :)
21:29:22 <Cale> whee: Just takes time :)
21:29:31 <whee> unfoldr is a new one to me
21:29:57 <kbateman> It's just that if I wanted to make a list of accessors for a record, then I can use [field1, field2], but I have to have a bunch of baggage if I want to create mutators
21:30:18 <Cale> whee: The general idea is to look at the recursion you're doing, simplify it as much as possible (accumulators are often a bad plan), and then see if it matches the recursive pattern of any higher-order library function.
21:30:43 <Cale> kbateman: right.
21:32:04 <Cale> kbateman: Haskell's record system is just a thin crust on algebraic datatypes, rather than a proper record system. Lots of people have proposed all sorts of changes, but nobody's stepped up and really implemented one of them in GHC.
21:32:51 <Cale> kbateman: I'm reading GHC's source code in order to try and understand how I'd go about implementing Daan Leijen's proposal, but it's quite baffling as of yet. :)
21:33:41 <kbateman> I'm just going off on a tangent here anyway.  I'm setting up a GetOpt invocation with record mutators, and it seemed needlessly verbose.  Verbosity seems to be the way to go for right now.
21:35:05 <kbateman> Plus there's the Haskell "design smell" of "If it's verbose, you're doing it wrong".
21:35:14 <Cale> That's true :)
21:36:30 <kbateman> The closest to GHC's internals I've gotten is reading SPJ's "Spinless Tagless G-Machine" paper (which btw is a pretty cool sounding title)
21:36:58 <kbateman> s/Spinless/Spineless
21:36:59 <Cale> whee: haaaang on...
21:37:45 <Cale> > unfoldr (\x -> case x of [] -> Nothing; (x:xs) -> Just (f x, xs)) [1,2,3,4]
21:37:45 <lambdabot>  Add a type signature
21:37:49 <Cale> > unfoldr (\x -> case x of [] -> Nothing; (x:xs) -> Just (f x, xs)) [1,2,3,4] :: [Expr]
21:37:51 <lambdabot>  [f 1,f 2,f 3,f 4]
21:37:54 <Cale> heh
21:38:02 <Cale> *cough*
21:38:22 <chessguy> a.k.a. map?
21:38:33 <Cale> yes
21:38:40 <whee> haha
21:38:56 <chessguy> > map f [1,2,3,4] :: [Expr]
21:38:57 <lambdabot>  [f 1,f 2,f 3,f 4]
21:39:31 <jcreigh> oh! Shiny!
21:39:34 <jcreigh> How does that work?
21:39:45 <hpaste>  Cale annotated "refactoring" with "refactoring..." at http://hpaste.org/6378#a1
21:40:18 <Cale> jcreigh: The Expr machinery?
21:40:21 <jcreigh> yeah
21:40:29 <Cale> There's an article about it...
21:40:34 <Cale> @where SimpleReflect
21:40:34 <lambdabot> http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
21:41:14 <Cale> It's actually a little more sophisticated than the blog's version now.
21:41:31 <kbateman> @pl  unfoldr (\x -> case x of [] -> Nothing; (x:xs) -> Just (f x, xs))
21:41:31 <lambdabot> (line 1, column 29):
21:41:31 <lambdabot> unexpected ">"
21:41:31 <lambdabot> expecting variable, "(", operator or ")"
21:41:37 <Cale> But that'll give you something in the ballpark :)
21:42:00 <Cale> The pl plugin doesn't know about case
21:42:29 <kbateman> drat
21:42:48 <jcreigh> > sum [1..5] :: Expr
21:42:49 <lambdabot>  0 + 1 + 2 + 3 + 4 + 5
21:43:01 <whee> Cale: I don't get how matchingEvent would work in the map version
21:43:03 <Cale> > iterate f z
21:43:03 <lambdabot>  [z,f z,f (f z),f (f (f z)),f (f (f (f z))),f (f (f (f (f z)))),f (f (f (f (f...
21:43:20 <kbateman> > fix f z
21:43:21 <lambdabot>  Add a type signature
21:43:26 <jcreigh> > fix f
21:43:26 <Cale> whee: hmm...
21:43:26 <lambdabot>  Add a type signature
21:43:28 <kbateman> > fix f z :: Expr
21:43:29 <lambdabot>  f <SimpleReflect.Expr -> SimpleReflect.Expr> z
21:43:34 <Cale> whee: oh
21:43:47 <Cale> whee: aha, right, it's not quite like that.
21:44:04 <Cale> whee: That map is a type error now :)
21:44:21 <Cale> err...
21:44:33 <jcreigh> > sum $ map (*x) [1..5]
21:44:34 <lambdabot>  0 + 1 * x + 2 * x + 3 * x + 4 * x + 5 * x
21:44:43 <Cale> ah...
21:45:01 <Cale> > unfoldr (\x -> case x of [] -> Nothing; (x:xs) -> Just (f x xs, xs)) [1,2,3,4] :: [Expr]
21:45:03 <lambdabot>  [f 1 [2,3,4],f 2 [3,4],f 3 [4],f 4 []]
21:45:41 <Cale> > zipWith f [1,2,3,4] (tail $ tails [1,2,3,4])
21:45:42 <lambdabot>  Add a type signature
21:45:46 <Cale> > zipWith f [1,2,3,4] (tail $ tails [1,2,3,4]) :: [Expr]
21:45:47 <lambdabot>  [f 1 [2,3,4],f 2 [3,4],f 3 [4],f 4 []]
21:46:38 <Cale> So we don't *need* unfoldr, but it's becoming questionable whether this is clearer :)
21:47:26 <whee> I understand the zipWith idea better :)
21:49:11 <hpaste>  Cale annotated "refactoring" with "fixed... I think." at http://hpaste.org/6378#a2
21:49:42 <Toxaris> > [f x xs | x : xs <- tails [1, 2, 3, 4]] :: [Expr]
21:49:43 <lambdabot>  [f 1 [2,3,4],f 2 [3,4],f 3 [4],f 4 []]
21:50:37 <Cale> Ah, perhaps a list comprehension would indeed be best :)
21:51:21 <hpaste>  Cale annotated "refactoring" with "nice" at http://hpaste.org/6378#a3
21:52:33 <whee> hooray, I came up with nearly the same zipWith implementation :P
21:53:02 <whee> I seem to like $ more than . :)
21:53:17 <Cale> I have something against chaining $'s
21:54:03 <Cale> Whenever you have f $ g $ h $ x, it's usually a good idea to change it to f . g . h $ x
21:54:05 <roconnor> This may be the wrong place to ask, but are there command line arguments I can give to an ocaml compiled program to increase the stack size?
21:55:02 <Cale> But yeah, the decision between f . g $ x and f $ g x is less clear
21:55:49 <kbateman> roconnor:  set OCAMLRUNPARAM to "l=1000000" where 1000000 is the stack size in words you want.
21:56:05 <kbateman> see man ocamlrun for details
21:56:10 <Cale> I think I'd favour f . g $ x just a little more, since f . g is a nice subexpression of it, whereas f $ g still won't mean anything.
21:56:25 <kbateman> wait, that's just for interpreted programs...
21:57:58 <roconnor> kbateman: I guess that only works on bytecode ocaml programs
21:58:11 <roconnor> kbateman: ah, you just said that
21:58:20 * roconnor wishes Coq was written in Haskell.
21:58:29 <Cale> ulimit -s 65536
21:58:41 <Cale> where that's in kilobytes, I believe
21:59:55 <Cale> That's a bash command.
22:00:08 <roconnor> ah, that's why I can't find the man page
22:00:24 <kbateman> I think you can use -ccopt to pass an arg to the C compiler/linker, then have a --stack option in the -ccopt
22:01:05 <Cale> whee: That was fun :)
22:01:23 <roconnor> kbateman: I have a compiled program already.  I was vainly hoping for run time options like GHC compiled programs have
22:02:36 <roconnor> Cale: hmm, bash is only letting me shrink my stack size
22:03:50 <Cale> huh
22:03:54 <Cale> It works for me...
22:04:28 <roconnor> $ ulimit -s 65534
22:04:28 <roconnor> $ ulimit -s 65533
22:04:28 <roconnor> $ ulimit -s 65534
22:04:28 <roconnor> bash: ulimit: stack size: cannot modify limit: Operation not permitted
22:04:44 <kbateman> Might have to be root to expand it.
22:04:47 <SamB> that isn't bash's fault
22:05:11 <roconnor> how do I expand it as root?
22:05:54 <roconnor> sudo doesn't make any sense here.
22:06:40 <kbateman> su, then ulimit -s bigger, then start a new shell as yourself under the shell with the expanded limit, then run the program.
22:07:16 <roconnor> oh, but in anycase stack size              (kbytes, -s) 65533, which should be pleanty big
22:07:33 <roconnor> but I still get a stack overflow just as fast in my ocaml program
22:09:57 <kbateman> I'm not sure how the ulimit and the link-time limits interact here.
22:10:13 <roconnor> yeah
22:10:20 <roconnor> ya
22:14:55 <roconnor> ah, I found a temporary solution.
22:14:58 <whee> Cale: I'll have more fun for you in the future :)
22:15:19 <roconnor> If I don't specify a glob file, I don't get a stack overflow
22:15:36 <roconnor> now I have something I can point the author too
22:15:50 <nolrai_> :t =>>
22:15:51 <roconnor> my 44 Meg glob file.
22:15:51 <lambdabot> parse error on input `=>>'
22:16:04 <roconnor> :t (=>>)
22:16:05 <lambdabot> Not in scope: `=>>'
22:16:08 <kbateman> :t (>>=)
22:16:09 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
22:16:32 <nolrai_> thanks kbateman
22:17:06 <wagle_home> roconnor, what is coq written in?
22:17:09 <kbateman> :t (=<<)
22:17:09 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
22:17:13 <roconnor> wagle_home: ocaml
22:17:46 <wagle_home> well, thats not bad...
22:18:03 <kbateman> If it's not Haskell, it's CRAP!
22:18:14 <wagle_home> haskell is crap?
22:18:20 <roconnor> if it weren't for all the side effects.
22:18:38 <SamB> wagle_home: yeah.
22:18:39 <kbateman> Early-90's SNL reference.
22:18:42 <roconnor> actually, I'm not sure I'd blame this stack overflow on ocaml.
22:18:43 <SamB> you need that ther half-line
22:18:47 <wagle_home> darn
22:18:57 <SamB> here, borrow my crayon
22:18:57 <roconnor> but maybe.  In haskell you allocate much more on the heap.
22:18:59 <dolio> It'd also be nice if Coq didn't look like OCaml. :)
22:19:13 <SamB> this will allow you to upgrade from haskell to Haskell
22:20:01 <wagle_home> chez scheme is written entirely in chez scheme..  if he loses the binary, kent's hosed
22:20:28 <bd_> I ended up with baskell, am I doing something wrong?
22:20:38 <SamB> wagle_home: can't he get one from someone else?
22:21:08 <wagle_home> bd_ you are in the wrong classroom, the basket weaving one
22:21:40 <SamB> what kind of fold do I use to weave an easter basket?
22:21:41 <bd_> > inventory
22:21:41 <lambdabot>   Not in scope: `inventory'
22:21:52 <bd_> oh, namespace collision there
22:21:57 <wagle_home> SamB, one would hope
22:22:15 <SamB> wagle_home: yes???
22:22:32 <SamB> wagle_home: what kind?
22:22:41 <wagle_home> SamB, ?
22:22:48 <wagle_home> oh
22:23:04 <SamB> foldM?
22:23:08 <wagle_home> foldEgg
22:23:16 <SamB> hahahaha
22:23:22 <bd_> SamB: A basket is a two-dimensional structure, you'd need some sort of comonad
22:23:34 * SamB finds the very idea of folding eggs to be very humerous
22:23:50 <wagle_home> oreggami
22:24:09 <bd_> oregami*
22:24:19 <SamB> origami?
22:24:19 <bd_> origami*
22:24:55 <bd_> oregami: 俺神 <-- kind of a different meaning there >_>;
22:25:16 <SamB> well, I'm going to call it a night. class aliases will probably be another couple of weeks, at least...
22:26:41 <SamB> it is a night!
22:26:45 <SamB> good night.
22:26:52 * SamB pets night
22:27:45 <ray> oregami!
22:27:52 <wagle_home> a nice glottal stop (つ) before the G to get the egg
22:28:15 <wagle_home> (eggu?)
22:28:34 <adu> hi
22:28:40 <adu> I think I just had a revelation
22:28:55 <kbateman> Start yourself a religion, then. :)
22:29:28 <shepheb> there are lots of haskell features that come as a revelation or epiphany, what did you hit? :)
22:30:34 <kbateman> I still haven't written a monad tutorial.
22:30:36 <wagle_home> えっぐ
22:30:53 <adu> simply by enumerating all the combination of heterogeneous/homogenous collections with sequence/keyed collections with ordered/unordered collections you can come up with almost all major language constructs of any language! like do-notation, objects, let-notation, lists, tuples, sets, maps...
22:31:14 <wagle_home> monkey power!
22:31:54 <lispy> let-notatino?
22:31:57 <lispy> er notation*
22:32:21 <adu> and since there are 3 boolean properties, that turns out to be 8 possibilities, it just seems like the world of programming shouldn't be able to fit into 8 kinds of collections...
22:33:13 <wagle_home> 8?
22:33:38 <wagle_home> oh sorry
22:34:06 <wagle_home> what are the 3 boolean properties?
22:34:25 <adu> yes, let-notation establishes a map (not first-class, but a map nonetheless) between identifiers and types, but the return type of the "get-name-from-the-let-environment" is different for each identifier, which would make it a heterogeneous-keyed-ordered collection (ordered because of shadowing of variables, although I supposed unordered in Haskell...)
22:34:26 <Cale> bd_: does it become ga because of some kind of combination with the ore?
22:34:47 <bd_> Cale: hm?
22:35:00 * kbateman does not understand
22:35:10 <Cale> Isn't 神 pronounced かみ?
22:35:10 <bd_> Cale: well, vocalization of kanji compounds (whatever the actual term is) is kind of random
22:35:22 <Cale> mm
22:35:23 <bd_> so it could be かみ or it could be がみ depending on what compound it's in
22:35:35 <Cale> ah, okay
22:35:54 <lispy> or it could be garbeled letters under my screen/terminal/irc client combination
22:35:56 <mauke> I have no idea what you're talking about but I'm happy to see the pretty characters in my console :-)
22:36:19 <mauke> <3 unicode
22:36:22 <bd_> tsk, if you're not set up for unicode, how do you expect to see λ?
22:36:25 * lispy suspects that it is putty that is broken here
22:36:41 <lispy> I-hat right shift?
22:36:44 <dmwit> adu: You sound like this one homeless guy I knew once...
22:36:46 <adu> ooo i love kanji
22:36:53 <mauke> ∀a. a → a
22:36:57 <bd_> lispy: lambda
22:37:00 <adu> dmwit: is that a compliment or an insult?
22:37:07 <dmwit> =)
22:37:12 <dmwit> Just a joke.
22:37:15 <bd_> hmm, no forall in my font :(
22:37:23 <dmwit> I like unified theories of everything. =)
22:37:45 <pa-ching> So I have a recursive data type, clusters of which can be saved/loaded to disk... I want to write pure functions for manipulating them, but load the various clusters from disk lazily. Each cluster can be uniquely identified. I'm suspecting something along the lines of a IORef'd table of loaded clusters, and a unsafePerformIO... but is there a cleaner way to do this, purely?
22:37:46 * lispy wonders if a different version of putty is a worthwhile tihng to investigate
22:37:59 <lispy> 0.58
22:38:06 <lispy> surely there must be a more modern putty
22:38:07 <bd_> lispy: you need to flip putty into utf8, and your irc client needs to be in a utf8 locale
22:38:15 <adu> dmwit: then you would enjoy one idea i had for a programming language where application and assignment were the same operator (' ')
22:38:15 <bd_> putty defaults to iso-8859-1
22:38:25 <dmwit> pa-ching: Normally you just send things out of the monad when you want purity.
22:38:35 <Cale> pa-ching: You might be able to get away with unsafeInterleaveIO
22:38:58 <dmwit> Oh, I didn't read carefully enough.
22:38:58 <bd_> pa-ching: Is it meaningful to just mmap it, then shove the resulting buffer into a bytestring somehow?
22:39:02 <adu> dmwit: it basically turned into Prolog without parentheses
22:39:10 <dmwit> heh
22:39:14 <wagle_home> kanji came from chinese, but they mostly (though not entirely?) mean the same
22:39:18 <pa-ching> interleave eh...
22:39:31 <mauke> does anyone happen to know the codepoints for ligatures?
22:39:35 <Cale> :t System.IO.Unsafe.unsafeInterleaveIO
22:39:37 <lambdabot> forall a. IO a -> IO a
22:39:43 <bd_> wagle_home: for sufficiently broad meanings of 'the same' ... :)
22:39:51 <pa-ching> Hoho.
22:39:56 <adu> mauke: have you tried unicode.org?
22:40:17 <scook0> mauke: http://www.fileformat.info/info/unicode/char/search.htm
22:40:18 <lambdabot> Title: Unicode Character Search
22:40:19 <Cale> pa-ching: It turns an IO action x into one which when executed returns a value which when evaluated performs the execution of x in order to determine its value.
22:40:22 <wagle_home> allegedly a high school japanese can make sense of a chinese newspaper..  which seems pretty good
22:40:31 <lispy> bd_: utf8 allowed me to see the lambda, but not the other things
22:40:58 <bd_> wagle_home: I don't think they'd *understand* it, but they might  be able to pick out words here and there. The grammar is *completely* different (Japanese doesn't use kanji for grammar structures at all)
22:41:04 <bd_> only noun and verb stems
22:41:12 <mauke> thanks
22:41:12 <wagle_home> yeah
22:41:26 <pa-ching> Hmmmm....
22:41:37 <bd_> lispy: you need to set your font to something that contains the characters in question as well. For Japanese, MS Gothic works well. (don't use the one with the @, and you need CJK language support installed)
22:42:01 <Cale> pa-ching: Effectively, this defers the I/O, in this case, a load from disk, until later when the actual value is needed
22:42:14 <pa-ching> Or maybe I should just abandon my recursive data structure, I don't really know how to make it work in tandem with a monad...
22:42:30 <bd_> pa-ching: what kind of structure is it?
22:42:37 <Cale> pa-ching: you mean in tandem with the IO monad specifically ;)
22:42:40 <bd_> or well, what are you trying to do? :)
22:42:51 <wagle_home> i have my ears covered, but can i have three more hands to cover my eyes and mouth to protect me from unsafeAtAnySpeedIO?
22:42:55 <lispy> bd_: putty doesn't have very many fonts and I don't see MS Gothic :(
22:42:56 <pa-ching> It could represent a bunch of things...
22:42:59 <pa-ching> say it's an AST
22:43:11 <bd_> lispy: you need to install CJK language support in the regional settings control panel for it
22:43:21 <lispy> bd_: hmm..okay
22:43:29 <bd_> pa-ching: well, I mean, how big is it, how do you plan to access it, and well, what is it :)
22:43:45 <pa-ching> Yeah, trying to put my thoughts together :)
22:43:47 <pa-ching> hmm
22:44:50 <adu> Cale: my favorite monad is (GenParser t s)
22:45:01 <wagle_home> the world needs a unicode haskell irc client
22:45:15 <adu> wagle_home: written in haskell of course
22:45:20 <pa-ching> data Val = Str String [Val] | Ref Val [Val] -- for example
22:45:36 <pa-ching> so a cluster of Vals is a tree of 'em...
22:45:37 <adu> wagle_home: perhaps also written as an extension for Yi, which would make it even more like Emacs...
22:45:44 <pa-ching> It's identifiable by an ID
22:46:23 <wagle_home> adu ooo!  and a lambdabot interface to @djinn your code for you
22:46:26 <pa-ching> So later say I just want to spit out all of the strings concatenated in tree order...
22:46:47 <adu> wagle_home: whats gjinn?
22:46:56 <pa-ching> and wherever there's a Ref instead of a Str, spit out the ID of whatever it's referring to
22:46:57 <dmwit> ?djinn (a -> a) -> a
22:46:57 <lambdabot> -- f cannot be realized.
22:47:03 <pa-ching> nevermind how that ID is obtained eheh.
22:47:06 <dmwit> ?djinn (a -> a) -> (a -> a)
22:47:06 <lambdabot> f a = a
22:47:22 <dmwit> It writes code, given type annotations.
22:47:35 <dmwit> It doesn't do recursive types, and type-classes are mostly out.
22:47:41 <lispy> ?djinn (a -> a) -> a -> a
22:47:41 <lambdabot> f a = a
22:47:47 <pa-ching> Then I'd like for the Ref's first member to be lazily loaded from disk... the ID would be known whenever the data was first created...
22:47:55 <pa-ching> hmm this is pretty wind-y
22:48:06 <dmwit> ?djinn (a -> b) -> (c -> a) -> (c -> b)
22:48:07 <lambdabot> f a b c = a (b c)
22:48:08 <lispy> ?djinn a -> (a -> a) -> a
22:48:08 <lambdabot> f a b = b a
22:48:09 <wagle_home> ?djinn a -> m a
22:48:09 <lambdabot> -- f cannot be realized.
22:48:13 <adu> ?djinn a -> (b, a)
22:48:13 <lambdabot> -- f cannot be realized.
22:48:22 <shepheb> @seen byorgey
22:48:22 <lambdabot> byorgey is in #haskell-blah, #xmonad and #haskell. I last heard byorgey speak 1h 55m ago.
22:48:28 <dmwit> ?djinn (Monad m) => a -> m a
22:48:31 <adu> ?djinn a -> [a] -> a
22:48:31 <lambdabot> f a _ = a
22:48:32 <wagle_home> ?djinn a -> (a,a)
22:48:32 <shepheb> byorgey: congratulations on the admission!
22:48:33 <lambdabot> f a = (a, a)
22:48:49 <adu> ?djinn a -> [a] -> [a]
22:48:49 <lambdabot> f _ a = a
22:49:07 <lispy> djinn has a tendency to cheat and do very trivial things
22:49:11 <dmwit> adu: As I said, it's not so smart about recursive types. =P
22:49:18 <dmwit> and what lispy said
22:49:19 <adu> ic
22:49:27 <wagle_home> "simplest inhabitant"?
22:49:29 <kbateman> ?djinn (a -> b -> c) -> b -> (a -> c)
22:49:29 <lambdabot> f a b c = a c b
22:49:56 <lispy> ?djinn [a] -> a
22:49:56 <lambdabot> -- f cannot be realized.
22:50:11 <dmwit> That's pretty true, though.
22:50:13 <lispy> ?src head
22:50:13 <lambdabot> head (x:_) = x
22:50:14 <lambdabot> head []    = undefined
22:50:19 <wagle_home> ?djinn a -> [a]
22:50:19 <lambdabot> -- f cannot be realized.
22:50:19 <lispy> but...but...^^ ;)
22:50:25 <dmwit> ;-)
22:50:33 <Cale> @djinn-env
22:50:33 <lambdabot> data () = ()
22:50:33 <lambdabot> data Either a b = Left a | Right b
22:50:33 <lambdabot> data Maybe a = Nothing | Just a
22:50:33 <lambdabot> data Bool = False | True
22:50:33 <lambdabot> data Void
22:50:35 <lambdabot> type Not x = x -> Void
22:50:38 <lambdabot> class Eq a where (==) :: a -> a -> Bool
22:50:41 <dmwit> "undefined" is the killer part, as I'm sure you know. =)
22:50:42 <Cale> Djinn doesn't even know about lists.
22:50:45 <lispy> oh hrm, no lists
22:50:57 <lispy> ?djinn Maybe a -> a
22:50:57 <lambdabot> -- f cannot be realized.
22:51:03 <Cale> @djinn-add data List a = Nil | Cons a (List a)
22:51:09 <dmwit> ?djinn a -> Maybe a
22:51:09 <lambdabot> Cannot parse command
22:51:09 <lambdabot> f :: a -> Maybe a
22:51:09 <lambdabot> f = Just
22:51:14 <Cale> @djinn a -> List a
22:51:14 <lambdabot> Cannot parse command
22:51:14 <lambdabot> -- f cannot be realized.
22:51:24 <kbateman> ?djinn [a] -> b -> [(b,a)]
22:51:24 <lambdabot> Cannot parse command
22:51:24 <lambdabot> -- f cannot be realized.
22:51:28 <Cale> uhhh...
22:51:39 <newsham> hi
22:51:44 <Cale> @help djinn
22:51:45 <lambdabot> djinn <type>.
22:51:45 <lambdabot> Generates Haskell code from a type.
22:51:45 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
22:51:47 <adu> @djinn Char
22:51:47 <lambdabot> Cannot parse command
22:51:47 <lambdabot> -- f cannot be realized.
22:51:48 <Cale> grr
22:51:50 <adu> lol
22:51:53 <Cale> @djinn-clear
22:52:08 <Cale> @djinn Char
22:52:08 <lambdabot> -- f cannot be realized.
22:52:14 <Cale> okay, that's better
22:52:22 <lispy> ?djinn-env
22:52:22 <lambdabot> data () = ()
22:52:22 <lambdabot> data Either a b = Left a | Right b
22:52:22 <lambdabot> data Maybe a = Nothing | Just a
22:52:22 <lambdabot> data Bool = False | True
22:52:22 <lambdabot> data Void
22:52:24 <lambdabot> type Not x = x -> Void
22:52:24 <adu> @djinn Int
22:52:26 <lambdabot> class Eq a where (==) :: a -> a -> Bool
22:52:28 <lambdabot> -- f cannot be realized.
22:52:40 <mauke> @djinn Bool
22:52:40 <lambdabot> f = False
22:52:40 <lispy> ?djinn ()
22:52:40 <lambdabot> f = ()
22:53:01 <Cale> @djinn Eq a => (b -> a) -> Either a b -> a -> Bool
22:53:01 <lambdabot> Cannot parse command
22:53:10 <Cale> @djinn (Eq a) => (b -> a) -> Either a b -> a -> Bool
22:53:10 <lambdabot> f a b =
22:53:10 <lambdabot>     case b of
22:53:10 <lambdabot>     Left c -> (==) c
22:53:10 <lambdabot>     Right d -> (==) (a d)
22:53:11 <lispy> ?djinn Eq a => Bool -> () -> Either () Bool
22:53:11 <lambdabot> Cannot parse command
22:53:28 <Cale> uhhh...
22:53:28 <lispy> ?djinn (Eq a) => Bool -> () -> Either () Bool
22:53:28 <lambdabot> f a _ =
22:53:28 <lambdabot>     case a of
22:53:28 <lambdabot>     False -> Left ()
22:53:28 <lambdabot>     True -> Right False
22:53:32 <adu> @djinn a -> a -- and some comments
22:53:32 <lambdabot> Cannot parse command
22:53:40 <Cale> ah
22:53:45 <Cale> nice :)
22:54:13 <adu> @djinn (Num a) => a
22:54:28 <Cale> Clearly, djinn only knows about Eq at present.
22:54:40 <adu> oh, actually, it wasn't so clear
22:54:42 <Cale> (otherwise, djinn-env would have listed other classes :)
22:54:47 <lispy> ?djinn (Eq a) => a -> a -> Bool
22:54:48 <lambdabot> f = (==)
22:54:50 <adu> what is djinn-env?
22:55:01 <Cale> Oh, you missed it :)
22:55:03 <lispy> finally, djinn gave me something interesting!
22:55:04 <Cale> @djinn-env
22:55:05 <lambdabot> data () = ()
22:55:05 <lambdabot> data Either a b = Left a | Right b
22:55:05 <lambdabot> data Maybe a = Nothing | Just a
22:55:05 <lambdabot> data Bool = False | True
22:55:05 <lambdabot> data Void
22:55:07 <lambdabot> type Not x = x -> Void
22:55:09 <wagle_home> @djinn (Eq a) => a -> a -> Bool
22:55:09 <lambdabot> class Eq a where (==) :: a -> a -> Bool
22:55:10 <adu> no i saw it it just didn't make any sense
22:55:10 <lambdabot> f = (==)
22:55:18 <adu> o wait, it does have bool
22:55:27 <lispy> ?djinn (Eq a) => a -> a -> Maybe Bool
22:55:27 <lambdabot> f a b =
22:55:27 <lambdabot>     case a == b of
22:55:27 <lambdabot>     False -> Nothing
22:55:27 <lambdabot>     True -> Just False
22:55:28 <Cale> It's the list of definitions which are presently active.
22:55:35 <mauke> haha
22:55:38 <adu> i missed the bool part and then I thought the Bool recognition was magick...
22:55:45 <wagle_home> Just False?  lol
22:55:58 <lispy> True -> Just False is awesome
22:55:58 <dmwit> That's interesting...
22:56:14 <wagle_home> it thinks False is the exemplar Bool
22:56:37 <adu> what if it was data Bool = True | False instead?
22:56:40 <wagle_home> @djinn a-> Bool
22:56:40 <lambdabot> f _ = False
22:56:57 <Cale> It probably finds that one too, and  Just (a == b)
22:57:04 <wagle_home> @djinn Bool   -- better yet
22:57:04 <lambdabot> Cannot parse command
22:57:05 <Cale> But it doesn't know which one is best.
22:57:11 <wagle_home> @djinn Bool
22:57:11 <lambdabot> f = False
22:57:17 <bd_> ?djinn Bool -> Either Bool Bool
22:57:17 <lambdabot> f a =
22:57:17 <lambdabot>     case a of
22:57:17 <lambdabot>     False -> Left False
22:57:17 <lambdabot>     True -> Left True
22:57:39 <lispy> heh
22:57:45 <Cale> It tries to use up things which are available to it.
22:57:51 <adu> @djinn Either (Maybe Bool) Bool
22:57:51 <lambdabot> f = Left Nothing
22:57:51 <lispy> clearly djinn could simplify it's results
22:57:55 <wagle_home> i suppose the first constructor is a reasonable exemplar
22:58:04 <adu> @djinn Maybe (Either Bool Bool)
22:58:04 <lambdabot> f = Nothing
22:58:22 <Cale> It'll use the other constructors if it's already used the first one.
22:58:48 <Cale> @djinn a -> b -> Either a b
22:58:48 <lambdabot> f a _ = Left a
22:58:52 <Cale> @djinn a -> b -> Maybe (Either a b)
22:58:53 <lambdabot> f a _ = Just (Left a)
22:58:55 <wagle_home> but in (,) and Either, i think the second position should be the exemplar (or am i misremembering?)
22:59:08 <Cale> @djinn a -> Maybe (Either a Bool)
22:59:08 <lambdabot> f a = Just (Left a)
22:59:22 <Cale> See, this is slightly better than Nothing, because it uses up 'a'
22:59:32 <wagle_home> > Left 1 >> Left 2
22:59:32 <lambdabot>  Add a type signature
22:59:34 <lekro> @djinn Maybe a -> Either () a
22:59:34 <lambdabot> f a =
22:59:34 <lambdabot>     case a of
22:59:34 <lambdabot>     Nothing -> Left ()
22:59:34 <lambdabot>     Just b -> Right b
22:59:43 <lispy> ?djinn (Eq a) Either Bool a -> Either Void a -> () -> Bool
22:59:43 <lambdabot> f _ a =
22:59:43 <lambdabot>     case a of
22:59:43 <lambdabot>     Left b -> void b
22:59:43 <lambdabot>     Right _ -> \ _ -> False
22:59:45 <wagle_home> > Left 1 >> Left 2 :: Either Int
22:59:45 <lambdabot>      `Either Int' is not applied to enough type arguments
22:59:45 <lambdabot>     Expected kind `...
22:59:55 <mauke_> > Left 1 ++ Left 2
22:59:56 <lambdabot>   add an instance declaration for (Monoid (Either t b))
22:59:59 <Cale> what the...
23:00:03 <wagle_home> > Left 1 >> (Left 2 :: Either Int)
23:00:03 <lambdabot>      `Either Int' is not applied to enough type arguments
23:00:03 <lambdabot>     Expected kind `...
23:00:11 <wagle_home> doh
23:00:15 <wagle_home> > Left 1 >> Left 2 :: Either Int Int
23:00:16 <lambdabot>   add an instance declaration for (Error Int)
23:00:16 <lambdabot>     In the expression: Left 1 >...
23:00:27 <wagle_home> bah
23:00:31 <lispy> ?djinn (Eq a) => Either Bool a -> Either Void a -> () -> Bool
23:00:32 <lambdabot> f a b =
23:00:32 <lambdabot>     case a of
23:00:32 <lambdabot>     Left c -> case c of
23:00:32 <lambdabot>               False -> case b of
23:00:32 <lambdabot>                        Left d -> void d
23:00:34 <lambdabot>                        Right _ -> \ _ -> False
23:00:36 <lambdabot>               True -> case b of
23:00:38 <lambdabot>                       Left e -> void e
23:00:40 <lambdabot>                       Right f -> \ _ -> f == f
23:00:42 <lambdabot>     Right g -> case b of
23:00:42 <bd_> > Left "1" >> Left "2" :: Either String String
23:00:43 <lispy> that's better
23:00:44 <lambdabot>                Left h -> void h
23:00:46 <lambdabot>  Left "1"
23:00:48 <lambdabot> Plugin `djinn' failed with: thread killed
23:01:02 <lispy> whoa, that killed it?
23:01:07 <Cale> taking too long
23:01:19 <wagle_home> oh, i discovered a parse glitch in lambdabot earlier today
23:01:27 <lispy> Cale: did you notice i had a syntax error the first time and it accepted, though?
23:01:32 <Cale> yes
23:01:36 <Cale> that was bizarre
23:01:54 <wagle_home> > 2^(155::Int) - 1 :: Int
23:01:55 <lambdabot>  -1
23:01:57 <adu> ?djinn Void
23:01:58 <lambdabot> -- f cannot be realized.
23:02:13 <lispy> ?djinn (Eq a)
23:02:13 <lambdabot> -- f cannot be realized.
23:02:15 <lispy> ?djinn (Eq a) a
23:02:15 <lambdabot> -- f cannot be realized.
23:02:18 <lispy> ?djinn (Eq a) Void
23:02:18 <lambdabot> -- f cannot be realized.
23:02:20 <wagle_home> > (2 :: Integer)^(155::Int) - 1 :: Int
23:02:20 <lambdabot>  Couldn't match expected type `Int' against inferred type `Integer'
23:02:24 <lispy> ?djinn (Eq a) Either a b
23:02:24 <lambdabot> -- f cannot be realized.
23:02:27 <lispy> ?djinn (Eq a) Either a b -> B
23:02:27 <lambdabot> -- f cannot be realized.
23:02:31 <wagle_home> > ((2 :: Integer)^(155::Int) - 1) :: Int
23:02:32 <lambdabot>  Couldn't match expected type `Int' against inferred type `Integer'
23:02:36 <dmwit> :t (^)
23:02:37 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
23:02:45 <mauke_> ?djinn (Eq a) ()
23:02:45 <lambdabot> -- f cannot be realized.
23:02:55 <bd_> ?djinn (Eq a) => ()
23:02:55 <lambdabot> f = ()
23:02:59 <wagle_home> ghci parses  (2 :: Integer)^(155::Int) - 1 :: Int, but gives type error
23:03:09 <adu> you should be able to use (**) if all arguments are integers
23:03:13 <bd_> wagle_home: that's because Integer and Int are different types
23:03:22 <dmwit> > ((2 :: Integer) ^ (155 :: Int)) - 1
23:03:23 <lambdabot>  45671926166590716193865151022383844364247891967
23:03:26 <bd_> ..oh
23:03:30 <wagle_home> yeah, but lambdabot gives parse error, not type error
23:03:38 <mauke_> where's the parse error?
23:03:52 <wagle_home> > (2 :: Integer)^(155::Int) - 1 :: Int
23:03:53 <lambdabot>  Couldn't match expected type `Int' against inferred type `Integer'
23:04:00 <wagle_home> hmm..  he fixed it
23:04:17 <dmwit> The result has type Integer, not Int.
23:04:20 <dmwit> Seriously.
23:04:29 <dmwit> > (2 :: Integer) ^ (155 :: Int) - 1 :: Integer
23:04:30 <lambdabot>  45671926166590716193865151022383844364247891967
23:04:46 <wagle_home> seriously, i'm looking for a type error instead of a parse error..  seriously!
23:05:02 <mauke_> you never got a parse error
23:05:04 <dmwit> ?
23:05:17 <wagle_home> yeah i did
23:05:30 <mauke_> chapter and verse, please
23:05:47 <wagle_home> mauke_, go troll someone else
23:06:55 <adu> > foldr (^) 1 (replicate 3 2)
23:06:55 <lambdabot>  16
23:06:57 <adu> > foldr (^) 1 (replicate 4 2)
23:06:58 <lambdabot>  65536
23:08:54 <adu> > foldr (^) 1 (replicate 3 3)
23:08:54 <lambdabot>  7625597484987
23:08:59 * wy survived the interview :)
23:09:06 <wagle_home> foldl (^) 1 (replicate 3 2)
23:09:15 <wagle_home> >foldl (^) 1 (replicate 3 2)
23:09:16 <vincenz> People
23:09:18 <vincenz> Please use pm
23:09:21 <vincenz> This is getting spammy
23:09:22 <wagle_home> > foldl (^) 1 (replicate 3 2)
23:09:23 <lambdabot>  1
23:09:29 <adu> vincenz: ok
23:09:33 <wagle_home> > foldl (^) 1 (replicate 4 2)
23:09:33 <lambdabot>  1
23:09:35 <adu> wy: YEY!
23:09:36 <wy> hehe. much better than google
23:09:38 <vincenz> Cale: you too this time :)
23:09:51 <vincenz> wagle_home: idem
23:09:56 <vincenz> adu: that wasn't to you actually
23:10:02 <adu> o ok
23:10:16 <wagle_home> vincenz, you arent participating
23:10:25 <vincenz> wagle_home: Keep the spam down
23:10:27 * Cale considers using djinn some more... :)
23:10:29 <wagle_home> vincenz, you arent participating
23:10:33 <vincenz> wagle_home: You can use lambdabot perfectly well in pm
23:10:37 <wagle_home> vincenz, you arent participating
23:10:44 <adu> wy: what kind of interview? the new job kind? or the you f*** up on your taxes kind?
23:11:15 <wy> adu: what's the last kind about?
23:11:24 <wy> adu: a summer internship
23:11:25 <lispy> IRC is like multiplayer [insert favorite editor]!
23:11:42 <vincenz> lispy: and try @djinning in pm pleas :)
23:11:53 <wy> adu: from jane street
23:11:59 <adu> like when the IRS hunts you down and you're going down an allyway, then you can't run any more and you turn around, and they say "Time for an ......... Interview"
23:12:06 <lispy> vincenz: I stopped quite some time ago, kthx bye ;)
23:12:15 <mauke_> lispy: multiplayer cat :/
23:12:20 <vincenz> lispy: That was retroactive comment :)
23:12:28 <Adamant> wy: are they using any Haskell yet, or just O'Caml still?
23:12:31 <mauke_> no items. append only. final destination.
23:12:40 <wy> Adamant: OCaml
23:12:48 * solrize_ dint know you could pm that bot
23:13:11 <lispy> solrize: yeah, pretty much everything works there but :t is broken :(  (?type still works though)
23:13:19 <vincenz> sorear: As long as you're registered
23:13:20 <adu> oo i like ocaml so far
23:13:23 <vincenz> oop
23:13:25 <vincenz> solrize: ^^
23:13:29 <Cale> hehe, :t let f x = (x,x); f2 x = f (f x); f3 x = f2 (f2 x) in f3
23:13:50 <wagle_home> vincenz, try taking your anti-social leanings out of the channel please
23:14:14 <sorear> mumble mumble
23:14:21 <vincenz> sorear: sorry, wrong tab-complete
23:14:22 <mauke_> Cale: is that the exponential type checking thingy?
23:14:28 <Cale> mauke_: yeah
23:15:53 <wy> credit suisse is using Haskell according to Heffalump
23:15:56 <Feuerbach> where does (>>=) sign come from?
23:16:01 <solrize_> (((x,x),(x,x)),((x,x),(x,x)))
23:16:05 <vincenz> wy: Yep, augustss works there, I believe
23:16:24 <wy> vincenz: really I thought he works for another company
23:16:49 <wy> "...Currently I only work 40% at Chalmers, the rest of the time I work at CR&T."
23:16:50 <lispy> wagle_home: relax, we were spamming the channel
23:16:52 <vincenz> I'm pretty sure it was him that was doing Haskell and banking.
23:17:39 <wy> vincenz: the website is unreadable for me ;)
23:18:04 <lispy> Feuerbach: I think it's supposed to look like a pipe
23:18:16 <vincenz> wy: http://en.wikipedia.org/wiki/Lennart_Augustsson
23:18:19 <vincenz> wy: that page must be outdated
23:18:37 <vincenz> oh wait, CR&T is probably Credit Suisse?
23:18:49 <vincenz> Nm
23:19:47 <wy> vincenz: no
23:19:56 <wagle_home> lispy, and i think it abated on its own
23:20:15 <vincenz> wy: Anyways, I think that page must be outdated then.  I vividly recall that being discussed at Hac'07, and wikipedia refers to it too
23:20:25 <vincenz> And I've pmed him about it personally
23:20:27 <wy> I still remember that august.c I tried many years ago. I never thought the author was a functional programmer
23:20:30 <Feuerbach> lispy: I had the same guess, but curious, who invented it :)
23:21:10 <wagle_home> @google who invented >>=
23:21:14 <lambdabot> http://library.christchurch.org.nz/kids/inventions/
23:21:14 <lambdabot> Title: Inventors and Inventions - Fact Sheets - Christchurch City Libraries
23:21:17 <wy> vincenz: yes. wikipedia is newer
23:21:27 <wagle_home> oh well
23:21:49 <wy> wagle_home: pretty intuitive uh
23:21:52 <adu> everyone knows google only parses alphanumerics ">>=" is just whitespace
23:22:31 <wy> @google >>=
23:22:32 <lambdabot> No Result Found.
23:22:44 <wy> Your search - >>= - did not match any documents.
23:22:55 <wagle_home> lispy, i find short sessions of multiple people interacting with lambdabot exciting and interesting
23:22:56 <adu> see i told you
23:24:41 <solrize_> > let x=3 in map (\f->f x) [(+1),(+2),(+5)]
23:24:42 <lambdabot>  [4,5,8]
23:24:46 <Cale> For people wanting a *real* Project Euler style problem, find a 57-regular graph having diameter 2 and girth 5. If you succeed, the result is publishable :)
23:24:47 <solrize_> is there a better way to write that?
23:25:03 <wy> so Credit Suisse is a swiss bank
23:25:17 <mauke> > map ($ 3) [(+1),(+2),(+5)]
23:25:18 <lambdabot>  [4,5,8]
23:25:23 <solrize_> yes, you can open a swiss bank account there
23:25:27 <mauke> > sequence [(+1),(+2),(+5)] 3
23:25:28 <lambdabot>  [4,5,8]
23:25:32 <solrize_> thanks
23:25:47 <wy> solrize_: with monads? ;)
23:25:55 <solrize_> heh :)
23:25:57 <Cale> with *a* monad
23:26:09 <Cale> hehe
23:26:16 <solrize_> wanted to write a cleaner fizzbuzz
23:26:28 <cjb> .. so you wrote it in the type system?
23:26:33 <hpaste>  solrize pasted "fizzbuzz" at http://hpaste.org/6380
23:26:50 <vincenz> cjb: That's passe, nowadays the cool kids do it in the kind-system.
23:26:54 <solrize_> lol
23:27:00 <cjb> http://blog.omega-prime.co.uk/2008/02/27/?
23:27:01 <lambdabot> Title: 24 :: (Bloggable a) => a -> IO () 1 1 29  2008  February  27 34
23:27:07 <wy> unfortunately they only hire PhDs in last two years as interns
23:27:17 <cjb> (-- FizzBuzzing At The Type Level)
23:27:48 <vincenz> cjb: neat :)
23:28:06 <cjb> looked pretty ugly to me, actually :)
23:28:39 <vincenz> cjb: that's' like a milli-oleg of type-hackery
23:29:16 <faxathisia> hello
23:29:22 <Cale> hi
23:29:30 <faxathisia> Just curious.. if anyone has implemented a WAM or a VAM in haskell?
23:29:45 <Cale> What is that?
23:29:55 <solrize_> wide area monad
23:30:00 <faxathisia> lol
23:30:04 * lispy heads to bed
23:30:05 <faxathisia> warren/vienna abstract machine, often used for compiling Prolog to
23:30:09 <wy> People's Bank of Switzerland...
23:30:15 <wy> faxathisia: hello!
23:30:39 <wy> reminds me of my country...
23:30:51 <faxathisia> :)
23:31:04 <solrize_> wyoming?
23:31:17 <wy> people's republic of china
23:31:21 <solrize_> oh :)
23:31:45 <Adamant> now we go from types to kinds. are we going to run out of similar words to use?
23:31:54 <faxathisia> just call them all types
23:31:57 <Cale> sorts
23:32:03 <Adamant> thingies
23:32:04 <faxathisia> infact call them all values
23:32:21 <Feuerbach> is it possible to write monad which is restricted (e.g. Show a => m a)?
23:32:25 <Cale> We'll simply index them with ordinal numbers.
23:32:45 <Cale> Feuerbach: You can't make it an instance of Monad.
23:32:56 <Cale> Feuerbach: (if you mean what I think you mean)
23:32:56 <Adamant> type kind 1 (types), type kind 2 (kind), etc.
23:33:12 <Cale> ... type kind omega
23:33:36 <Feuerbach> I mean I define kind m, which can be applied only to certain class of underlying types
23:34:22 <Cale> ... type kind (smallest uncountable ordinal)
23:35:21 <Cale> Feuerbach: yeah, that's not possible
23:35:38 <Feuerbach> ok, thanks
23:36:02 <Cale> Feuerbach: you can restrict the construction of values of type m a, so that the only defined values of type m a will be ones where Show a holds, say.
23:36:12 <Cale> Feuerbach: But undefined :: m a for any a
23:36:57 <Cale> Feuerbach: In particular, Set can't be made an instance of Monad for this reason, as it requires Ord in order to implement its functionality.
23:37:26 <Feuerbach> heh, nice example!
23:38:27 <faxathisia> hm
23:38:39 <wagle_home> Cale i thought it needed Eq?
23:39:01 <Cale> wagle_home: at minimum, but you need Ord if you want it to be efficient.
23:39:07 <solrize_> it's probably implemented with something like Map
23:39:14 <wagle_home> yeah
23:39:14 <Cale> With some type system extensions in GHC (or fiddling around by hand), you can have it store an Ord dictionary in with the Set value.
23:39:19 <faxathisia> Can I write high performance audio synthesis and mixing software in haskell?
23:39:33 <wagle_home> well, actually, hash tables...
23:39:35 <Cale> Then bind is easy, but you get stuck when writing return.
23:39:43 <Cale> wagle_home: nope
23:39:49 <wagle_home> ?
23:39:49 <Cale> Binary balanced trees :)
23:40:04 <Cale> So much nicer than hashtables :)
23:40:17 <lispy> Cale: http://www.randomhacks.net/articles/2007/03/15/data-set-monad-haskell-macros
23:40:18 <lambdabot> Title: How to make Data.Set a monad, http://tinyurl.com/22rhsc
23:40:33 <lispy> I know I said I was going to bed, but I saw that on my way to sleep and I couldn't let it rest :)
23:40:37 <wagle_home> seems all the enginneers rage to use hashtables, but i'm behind
23:40:39 <lispy> good night for real now :)
23:41:01 <Cale> lispy: I know that trick, it's bad for a number of reasons :)
23:41:13 <lispy> Cale: which trick? going to sleep? ;)
23:41:39 <Cale> lispy: No, parametrising the Monad class over the contained type.
23:42:01 <lispy> Cale: but seriously, other than requiring hack-ish things like no implicit prelude or TH, what is so bad about it?
23:42:43 <Cale> Well, for one, it means that you have to prove naturality for monad instances, whereas with the current definition, that's guaranteed by the type system.
23:43:13 <vincenz> lispy: Breaking up monad like that is a good idea
23:43:25 <vincenz> lispy: Swierstra did the same thing to enable incremental and accumulating parsers
23:43:36 <Cale> I thought of it a long time ago, and decided it wasn't worth mentioning.
23:44:42 <Cale> hmmm... I wonder if the fmap/return/join presentation is any nicer...
23:45:21 <lispy> Cale: naturality?
23:45:26 <Cale> lispy: yep
23:45:52 <Cale> lispy: join and return must be natural transformations
23:46:09 <Cale> lispy: Normally, the Haskell type system guarantees this, by polymorphism.
23:46:18 <lispy> fmap f . return == return . f
23:46:19 <lispy> fmap f . join == join . fmap (fmap f)
23:46:22 <lispy> those two?
23:46:26 <lispy> (I found them on the blog)
23:46:41 <Cale> That looks right.
23:46:49 <solrize_> lispy, look at the haskell wikibook on category theory
23:47:11 <solrize_> it explains the join/fmap construction of monads
23:47:19 <solrize_> i don't think it discusses naturality though
23:48:13 <solrize_> anyone ever code in ocaml?  is it, like, somewhere between lisp and haskell?
23:48:31 <Cale> I guess it is. It's closer to Haskell than to Lisp, I'd say.
23:48:41 <mauke> it's like a strict haskell without typeclasses
23:48:43 <adu> theres a typo
23:48:48 <Cale> and bad syntax
23:48:54 <adu> in "how to make Data.Set..."
23:48:57 <lispy> but a nice macro system
23:49:04 <mauke> it's not bad, just really ugly :-)
23:49:22 <Cale> That is the definition of bad ;)
23:49:26 <solrize_> i wonder if the syntax could be cleaned up
23:49:28 <adu> s/Set.Set/S.Set/
23:49:28 <solrize_> even sml is less ugly
23:49:43 <solrize_> http://eigenclass.org/hiki/gibak-backup-system-introduction  this looks like a cool program but it's in ocaml
23:49:47 <lambdabot> Title: eigenclass - A better backup system based on Git
23:49:51 <lispy> If you're going to pickup ocaml these days, it's probably better to play with F#, so you can claim .NET experience and use FP (I'm actually completely not serious)
23:50:11 <faxathisia> I don't see what's wrong with ocaml
23:50:19 <faxathisia> good software's been written in it
23:50:21 <solrize_> lispy i don't use windows
23:50:31 <lispy> faxathisia: when you use pattern matching you can only do it for one formal parameter at a time
23:51:00 <lispy> faxathisia: that's the only gripe I can make off the top of my head.  It's better than a lot of languages, I would imagine though.
23:51:03 <mauke> bundle them in a tuple and match on that
23:51:18 <lispy> mauke: yeah, you lose some composability if you do that thoguh
23:51:43 <solrize_> if you want to add two floats you have to say (e.g.) 2.0 +. 3.0
23:51:46 <solrize_> iirc
23:51:54 <lispy> oh yeah, no type classes
23:51:56 <lispy> that's right
23:52:11 <solrize_> and put ;; after everything
23:52:19 <solrize_> and it's impure
23:52:23 <mauke> you don't actually need ;; in ocaml
23:52:27 <lispy> no no, ; after most things, and ;; after everything else.
23:52:30 <solrize_> oh ok
23:52:46 <solrize_> it doesn't support parallelism right now iirc
23:52:48 <mauke> ; is >>
23:52:50 <lispy> but the exact rules are not easy to learn I guess?  Easiest to try and see what the parser likes :)
23:52:50 <mauke> :-)
23:53:00 <adu> why would you require that (Ord a) => Set a ?
23:53:05 <mauke> ; is just an infix operator
23:53:07 <mauke> it works like , in C
23:53:23 <lispy> adu: because then you can do O(log n) lookup?
23:53:41 <adu> thats not a set, then, it would be OrderableSet
23:53:47 <mauke> ;; separates toplevel statements, but you can omit it if the second statement starts with a top-level keyword
23:53:54 <mauke> (like open, type, let, etc.)
23:54:19 <adu> imho, all the ugliness stems from "(Ord a) => Set a"
23:55:08 <adu> in reality only "(Eq a) => Set a" is needed, but thats about the same problem...
23:55:48 <mauke> if it's only Eq a, I might as well use a list
23:56:20 <lispy> mauke: if I used ocaml regularly I think I would be forced to write a macro to convert haskell style pattern matches to valid OCaml
23:56:48 <falbani> Hi
23:56:48 <mauke> heh
23:57:05 <mauke> lispy: might as well add support for type signatures while you're at it :-)
23:57:17 <lispy> mauke: and type classes?
23:57:36 <mauke> that might be a bit more difficult
23:57:39 <lispy> mauke: oh, and reimplement much of the standard language in the lazy module? ;)
23:58:30 <hpaste>  falbani pasted "Data.HashTable: Why the output is 0?" at http://hpaste.org/6381
23:58:40 <falbani> I am trying to learn how to use Data.HashTable and I can't figure out why the output of this code is 0: http://hpaste.org/6381
23:59:01 <mauke> aieee
23:59:26 <faxathisia> you should perhaps learn about do notation
23:59:42 <faxathisia> which lets you leave out a lot of the >>= and >>'s
