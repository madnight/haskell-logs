00:00:12 <crutcher> love it. still confused.
00:00:13 <Cale> Yeah, so try implementing your own parsing monad using that type :)
00:00:14 <crutcher> :/
00:00:30 <Cale> (You're looking for exercises after all :)
00:00:46 <crutcher> okay, so you say: [], Maybe, and State.
00:01:03 <crutcher> Those are reimplementable (unlike IO) in reasonable time.
00:01:08 <Cale> But really, there's a whole lot less to monads than you'd think, given the vast number of tutorials.
00:01:29 <crutcher> and if I can do them enough, maybe I'll get it? That's the theory?
00:01:35 <Cale> Really, it's just a way to make the interfaces of some libraries similar in this small way so that we can write some functions that work with all the libraries.
00:01:45 <Cale> (which is the content of Control.Monad)
00:01:48 <scook0> the hard part about monads is that they're so simple
00:01:49 <crutcher> Yeah, I know. There's virtually no code there :/
00:01:54 <adu> crutcher: yeah, theres not much to interfaces
00:02:25 <Cale> crutcher: I think you just have to program with them for a while, and you'll get it. Do you have any specific questions about monads?
00:02:40 <slava> Cale: is there a paper describing lambdabot's @pl feature?
00:02:48 <Cale> slava: I don't know.
00:02:54 <crutcher> really, was looking for some exercises which didn't just re-iterate the defs
00:03:02 <crutcher> but I appreciate your help.
00:03:13 <Cale> crutcher: Do you know about the function sequence?
00:03:17 <Cale> 'sequence'
00:03:20 <crutcher> Maybe in a week I'll bug you about Functors
00:03:33 <Cale> Oh, you should probably understand Functors before Monads.
00:03:36 <solrize_> monads are a special case of functors
00:03:38 <solrize_> yeah
00:03:52 <solrize_> functors are simpler
00:03:56 <Cale> A functor is just something which has "something like map"
00:03:58 <slava> :t Functor
00:03:59 <lambdabot> Not in scope: data constructor `Functor'
00:04:02 <Cale> :t fmap
00:04:03 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
00:04:23 <adu> my favorite monad-related type is "RealWorld" hehe
00:04:47 <Cale> If f is a functor, then fmap takes a function from a's to b's, and takes an (f a) (whatever sort of data that is), and produces an (f b)
00:05:00 <slava> is there a function which takes a to f a?
00:05:07 <pjd> :t pure
00:05:08 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
00:05:14 <Cale> So you might think of it as applying the function to all the values of type a in the data structure.
00:05:16 <pjd> :t return
00:05:17 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
00:05:35 <Cale> slava: Not for general functors, but for specific cases, yes.
00:05:47 <slava> so general functors are not functors in the category theory sense?
00:05:49 <pjd> slava: Applicative and Monad are more specific instances of Functor
00:06:00 <Cale> slava: They are functors in the category theory sense.
00:06:18 <slava> functors can be applied to functions and objects in category theory
00:06:21 <Cale> slava: Oh, the mapping on objects is just the type constructor f
00:06:27 <slava> ah, got it
00:06:43 <scook0> and fmap is the mapping on morphisms
00:06:48 <crutcher> k, this gives me something to work on. I've got one (distantly) related question
00:06:59 <Cale> Really, Haskell Functors are endofunctors on the category of Haskell types.
00:07:05 <Cale> (and Haskell-definable functions)
00:07:25 <slava> i thought it was functors in the category of haskell values, which is why i was confused
00:07:33 <crutcher> the parallel and/or distributed haskells, are they implemented on an abstract infallible machine, or do they directly expose node failure?
00:07:34 <Cale> crutcher: Write a function  sequence :: (Monad m) => [m a] -> m [a]
00:07:52 <slava> :t join
00:07:53 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
00:07:56 <adu> whats the short-word (like Grp) for the category of Haskell types?
00:08:01 <scook0> speaking of functors, what's the relationship between categorical functors and ML functors?
00:08:07 <pjd> adu: Hask, i think
00:08:08 <slava> scook0: there isn't one IIRC
00:08:19 <slava> ML functors are functions from modules to modules
00:08:39 <slava> basically a saner version of C++ templates
00:08:53 <Cale> crutcher: Parallel Haskell doesn't expose any kind of concurrency. Concurrent Haskell exposes concurrency (so the result of a computation can depend on the interleaving of effects occurring concurrently), but I'm not sure what you mean by node failure.
00:08:55 <scook0> yeah, I'm (roughly) familiar with what ML functors are
00:09:20 <slava> Cale: node failure = a thread crashes
00:09:44 <crutcher> Real machines can fail. Distributed algos can be classified as running on either fallible or infallible nodes.
00:09:48 <scook0> and I'm pretty sure that the OO use of "functor" has nothing to do with CT
00:09:56 <scook0> but I was never sure about ML functors
00:09:58 <crutcher> the infallible versions are easier to describe, prove, etc.
00:10:03 <Cale> Oh, if, in concurrent Haskell, a thread throws an exception which it doesn't catch, or has an exception thrown at it which it doesn't catch, then that thread stops.
00:10:18 <slava> what about other threads which may depend on this thread in some way?
00:10:26 <slava> does it have supervision trees like erlang?
00:10:38 <Cale> No. You'd have to implement that.
00:10:41 <crutcher> but if you want to run them, you have to simulate an infallible collection of nodes on top of a fallible one. Which means causal replays when a node fails
00:11:19 <adu> well technically, Haskell's Functor is missing one aspect
00:11:24 * slava goes back to debugging his mutable state
00:11:28 <solrize_> would erlang-like supervision be feasible to implement?
00:11:30 <crutcher> okay, my long term goal is to build up a haskell where we can write complex distributed programs whith no internal error handling, and run them on a system which handles the replays
00:11:32 <Cale> crutcher: I don't think much has been done in the way of distributed computing, at least in GHC.
00:11:48 <scook0> adu: which is?
00:11:51 <Cale> crutcher: For the stuff that's in GHC, it's basically assumed to be running on an SMP machine.
00:12:41 <crutcher> well, I've got a lot to learn before I can even try, but I am quite interested in large scale computing
00:12:42 <Cale> There was a project a while back...
00:13:01 <Cale> http://www.macs.hw.ac.uk/~dsg/gdh/
00:13:01 <crutcher> I've seen some stuff on the web about it, but the projects look stale.
00:13:02 <lambdabot> Title: Glasgow Distributed Haskell
00:13:11 <slava> multi-threaded debuggers are tricky...
00:13:36 <Cale> solrize_: I don't see any fundamental reason that it shouldn't.
00:14:03 <Cale> STM is a really nice foundation on which to build concurrent abstractions.
00:14:09 <adu> a Functor must have (a -> b) -> f a -> f b and also a -> f a, and fmap is the first
00:14:16 <Cale> adu: no
00:14:23 <Cale> adu: It only must have fmap
00:14:34 <slava> when your concurrency is shared state, who debugs the debugger?
00:14:37 <adu> Cale: i know, the Haskell version only has fmap
00:14:46 <scook0> adu: we just mentioned this
00:14:46 <Cale> adu: There's not necessarily a natural transformation from 1 -> F
00:14:53 <scook0> fmap is the mapping on morphisms
00:15:05 <adu> yes
00:15:09 <scook0> and the type-operator f is the mapping on objects
00:15:09 <pjd> slava: @pl works with rewrite rules
00:15:10 <Cale> f itself is the mapping on objects
00:15:17 <Cale> remember that objects are types
00:15:19 <scook0> i.e. the objects are types
00:15:24 <slava> pjd: are they documented?
00:15:36 <adu> true
00:15:54 <Cale> But there's not necessarily a function a -> f a
00:16:10 <solrize_> Learn Haskell. It will force you out of your imperative mindset against your will, and teach the superset of concepts that all other functional languages only have pieces of. Learning Scheme will be easier, but you will program in scheme like you program in your current language, because scheme allows you to program how you like. Haskell doesn't. It's mean to you, and that's a good thing.
00:16:10 <solrize_> After you learn Haskell, learn scheme. It will teach you all the dirty little secrets Haskell kept you from, in its futile attempt to guard your purity. You won't appreciate the guilty pleasures of AST rewriting until you have toiled under Haskell's watch full hand. Then learn Erlang, or just pick up a book on the pi calculus and implement erlang as Haskell arrows... it will be trivial once you understand Haskell and Scheme.
00:16:12 <adu> there is for every functor i can think of...
00:16:32 <pjd> slava: they're listed, i guess: http://code.haskell.org/lambdabot/Plugin/Pl/Rules.hs
00:16:37 <slava> i know
00:17:35 <adu> solrize: have you?
00:18:53 <pjd> slava: Optimize.hs is maybe relevant
00:20:28 <solrize_> adu have i what?  i just pasted that quote from an ltu thread because it was funny
00:20:39 <solrize_> i've programmed some in scheme but not erlang
00:20:59 <scook0> solrize_: you probably want to put quotes in context
00:21:00 <solrize_> and i'm just starting to make sense out of haskell
00:21:03 <solrize_> oh sorry :)
00:21:11 <scook0> and for something that long, you might be better off just giving a link
00:21:23 <adu> o
00:21:24 <scook0> (dumping that much text in the channel is a little rude)
00:21:29 <solrize_> true.  though it's in the middle of a big discussion thread, not easy to link to
00:22:05 <dolio> F a = a -> r would be a functor without a function a -> F a, except it's not a covariant functor like the Functor type class wants.
00:22:57 <slava> so Functor is not a CT functor, it's a CT covariant functor
00:23:25 <solrize_> "Laziness is pretty much a necessity for any pure functional language." (from same thread).   that doesn't seem right ...
00:23:40 <dolio> Well, it's a covariant endofunctor on the category of the haskell type system, or something like that.
00:24:44 <pjd> "functor" unqualified generally assumes "covariant", doesn't it?
00:25:07 <Cale> pjd: yes
00:25:07 <dmwit> ?src sum
00:25:07 <lambdabot> sum = foldl (+) 0
00:25:33 <dolio> You can write a more general version, but that gets kind of hairy without much motivation (that I know of).
00:25:53 <pjd> so Functor is really CovariantEndFunctor, but probably no-one wants to write the latter out all the time
00:26:00 <pjd> EndoFunctor, even
00:26:13 <Cale> Contravariant functors can generally be treated as covariant functors from the opposite category
00:26:46 <Cale> Also, it's hard to know what a non-endo functor of the same sort would be.
00:26:47 <slava> is the opposite category of Hask useful?
00:26:55 <Cale> slava: theoretically
00:27:05 <slava> does it have a realization?
00:27:20 <Cale> Yes. You just formally flip the directions of all the arrows.
00:27:22 <dolio> Like: 'class Functor f c1 c2 where fmap :: c1 a b -> c2 (f a) (f b)'
00:27:37 <slava> i mean is there another way to describe it other than 'opposite types' and 'opposite morphisms'?
00:27:41 <Cale> So in the opposite category, f: A -> B, is a Haskell function of type B -> A
00:28:01 <slava> for example, in commutative algebra the category of affine rings is the opposite category of affine sets
00:28:04 <dolio> Then F a = a -> r has an instance: "instance Functor F (->) (Flip (->)) where ..."
00:28:25 <Cale> Oh, I don't know if it's isomorphic to anything interesting at all.
00:28:37 <slava> that's what i meant sorry
00:29:37 <vegai> the standard libs that come with ghc don't have an os.path.walk -like thing, do they?
00:29:46 <solrize_> http://www.informatik.uni-kiel.de/~fhu/PUBLICATIONS/1999/ifl.ps.gz
00:29:48 <lambdabot> http://tinyurl.com/2ke3y7
00:30:10 <solrize_> Erlang-Style Distributed Haskell
00:30:41 <pjd> TypeCompose includes a definition of contravariant functors
00:30:43 <pjd> http://darcs.haskell.org/packages/TypeCompose/doc/html/Control-Compose.html#1
00:30:46 <lambdabot> http://tinyurl.com/22438u
00:31:04 <pjd> cofmap :: (a -> b) -> (f b -> f a)
00:31:12 <vegai> @hoogle walk
00:31:13 <lambdabot> No matches found
00:31:15 <dolio> conal's TypeCompose actually has a type for such opposite functions, but I don't know if he does anything with it.
00:31:23 <Cale> Arrows can be put on a nice solid foundation in which the opposite category shows up in a somewhat obvious way
00:31:25 <Cale> http://www.cs.ru.nl/~heunen/publications/2006/arrows/arrows.pdf
00:32:08 <Cale> It turns out they're monoid objects in categories of bifunctors C^op x C -> C
00:32:32 <Cale> (by Arrows, I mean Hughes' Arrows, of course)
00:33:10 <Cale> I found that a particularly pleasant description.
00:40:06 <dmwit> ?src maximum
00:40:06 <lambdabot> maximum [] = undefined
00:40:06 <lambdabot> maximum xs = foldl1 max xs
00:40:24 <dmwit> The standard library needs more foldl'.
00:51:58 <adu> ooo Eriskay
01:11:19 <solrize_> http://koweycode.blogspot.com/2007/01/think-of-monad.html
01:11:20 <lambdabot> Title: koweycode: think of a monad...
01:21:07 <dmwit> That tutorial didn't really do it for me.
01:21:35 <dmwit> ?src genericLength
01:21:35 <lambdabot> genericLength []    = 0
01:21:35 <lambdabot> genericLength (_:l) = 1 + genericLength l
01:21:50 <dmwit> ?src length
01:21:50 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
01:28:55 <Tobsan> dmwit: you can see the source code for length on the web
01:28:59 <Tobsan> http://haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-List.html#length
01:29:01 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/23ncyu
01:29:40 <dmwit> Tobsan: They are substantially the same, yet length succeeds where genericLength gives me a stack overflow.
01:29:46 <steven_ashley> I am having some weird issues with a foldr, could someone please have a look at -> http://hpaste.org/6425
01:30:07 <dmwit> Tobsan: Do you think it's just because (+) in Int is strict, or could there be something else odd?
01:30:09 <steven_ashley> replacing "f x (myfoldr1 f init xs)" with "f x (as,bs) where (as,bs) = (myfoldr2 f init xs)" changes the behaviour of the program
01:30:18 <steven_ashley> I didn't expect that
01:30:44 <Tobsan> dmwit: i really have no idea, sorry
01:30:52 <Tobsan> genericlength looks fine too
01:33:03 <dmwit> steven_ashley: myfoldr2 has a different type...
01:33:20 <steven_ashley> yes, but how would that cause a change in evaluation?
01:33:28 <steven_ashley> in how it is evaluated*
01:33:33 <dmwit> I'm still looking. =P
01:33:52 <pjd> so maybeToList and listToMaybe are examples of (category theory) natural transformations?
01:35:46 <pjd> given that maybeToList . fmap f == fmap f . maybeToList
01:35:53 <pjd> and listToMaybe . fmap f == fmap f . listToMaybe
01:37:53 <dmwit> steven_ashley: That *is* an odd one.
01:38:08 <steven_ashley> yeah, it has me stumped :(
01:38:51 <dmwit> steven_ashley: The only thing I can think of is that the pattern-match in the "where" binding is somehow more lazy than the other function applications.
01:38:58 <dmwit> But it sounds a bit like a GHC bug.
01:39:41 <dmwit> Give me a half a tick and I'll see how hugs treats it.
01:39:48 <steven_ashley> cheers :)
01:39:57 <dmwit> ...same way
01:40:01 <steven_ashley> hmm
01:40:06 <dmwit> So there must be something interesting going on. =P
01:40:10 <steven_ashley> yeah
01:40:33 <dmwit> I don't think I can help you, but hang around here during a more busy time and I'm sure somebody will have a tip.
01:40:49 <steven_ashley> yeah, thats cool, thanks anyway :)
01:44:54 <ski> steven_ashley : in `myfoldr2' the `(as,bs)' argument to `f' is in WHNF regardless of the result of the recursive call
01:45:05 <Cale> @free listToMaybe
01:45:06 <lambdabot> $map_Maybe f . listToMaybe = listToMaybe . $map f
01:45:11 <Cale> @free maybeToList
01:45:12 <lambdabot> $map f . maybeToList = maybeToList . $map_Maybe f
01:45:25 <ski> this matters because your `test' pattern-matches on pairs
01:45:30 <Cale> pjd: ^^
01:45:55 <pjd> Cale: wow, nice
02:00:03 <steven_ashley> ski: thanks
02:00:31 <ski> (you're satisfied ?)
02:00:46 <quicksilver> pjd: all polymorphic functions are natural transformations
02:00:59 <quicksilver> pjd: so any polymorphic function :: Maybe a -> [a] would be natural
02:01:09 <quicksilver> pjd: (and the two you gave are certainl examples)
02:02:53 <pjd> quicksilver: only if either side are functors, right?
02:03:04 <steven_ashley> ski: enough to know that its not a bug and that I need to read up on how laziness works in haskell a bit more
02:03:16 <steven_ashley> ski: WHNF = whole normal form?
02:03:16 <pjd> (and the polymorphism isn't limited to a type class or such)
02:03:38 <pjd> Weak Head Normal Form
02:03:44 <steven_ashley> ahh
02:03:55 <wagle_home> @google weak head normal form
02:03:55 <lambdabot> http://encyclopedia2.thefreedictionary.com/Weak+Head+Normal+Form
02:07:38 <wagle_home> is it just me, or is the display of slashdot all screwed up?
02:08:11 <siti> wagle_home: just you I think ;)
02:08:22 <wagle_home> weird
02:08:28 <quicksilver> looks fine to me. wagle_home probably lost a stylesheet.
02:08:31 <siti> maybe it's a little broken because the an item on the poll is to big
02:16:06 <skorpan> what do i do when i get "not in scope" on data constructors that are imported?
02:16:16 <wagle_home> quicksilver, yeah..  my dns gets wonky when i restart firefox, and i think it lost the stylesheet url, but not the content url
02:16:32 <dmwit> skorpan: First, make sure they're spelled correctly and that they're really imported.
02:16:34 <wagle_home> its better now..  8/
02:16:44 <dmwit> skorpan: (Some modules don't export all their data constructors.)
02:16:45 <Cale> skorpan: are you sure they're imported? Note that if you import or export a type, to get the constructors, you have to put (..) after it
02:17:23 <skorpan> Cale: i export everything from everything and import it as well
02:17:33 <skorpan> but i think i've found some strange thing which might make this fail
02:17:46 <skorpan> for some reason a whole other module is being loaded by ghci
02:18:09 <skorpan> oh shi-
02:18:11 <wagle_home> why have modules if you export and import everything?
02:18:14 <skorpan> i've been working in the wrong directory
02:18:24 <skorpan> wagle_home: because i'm trying to find the error in my program?
02:19:12 <wagle_home> oki..  not objecting, more curious
02:19:30 <quicksilver> I sometimes have modules which export everything
02:19:39 * wagle_home just got here
02:19:46 <quicksilver> I put them in modules just because the organisation makes sense. They may be reusable.
02:20:19 <quicksilver> Sometimes I do it because I don't want to pollute other modules with the stuff this module imports, too
02:20:31 <quicksilver> or to let it import stuff unqualified which I only import qualified elsewhere.
02:22:15 <wagle_home> i havent used modules in haskell..  so have no tricks up my sleave
02:27:10 <dmwit> ?pl \f -> liftM2 (>) (f . numerator) (f . denominator)
02:27:10 <lambdabot> ap (liftM2 (>) . (. numerator)) (. denominator)
02:27:19 <dmwit> yeah, no thanks
02:27:27 <dmwit> liftM2 is far enough obfuscated for me. =P
02:28:18 <yitz> @type liftM2 (>) `on` f numerator denominator
02:28:19 <lambdabot>     No instances for (Show (Ratio a -> a), Show (Ratio a1 -> a1))
02:28:19 <lambdabot>       arising from a use of `f' at <interactive>:1:16-38
02:28:19 <lambdabot>     Possible fix:
02:28:52 <wagle_home> :t liftM2
02:28:53 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
02:28:53 <dmwit> :t on
02:28:54 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
02:29:06 <yitz> @type \x -> liftM2 (>) `on` f (numerator x) (denominator x)
02:29:07 <lambdabot> forall a1 (m :: * -> *) a a11. (SimpleReflect.FromExpr (m a1), Show a11, Integral a, Monad m, Ord a1) => Ratio a -> a11 -> a11 -> m Bool
02:29:25 <dmwit> heh, SimpleReflect
02:29:34 <dmwit> @type \f x -> liftM2 (>) `on` f (numerator x) (denominator x)
02:29:35 <lambdabot> forall a1 (m :: * -> *) a a11. (Integral a, Monad m, Ord a1) => (a -> a -> a11 -> m a1) -> Ratio a -> a11 -> a11 -> m Bool
02:29:50 <yitz> anyway, something like that
02:29:55 <dmwit> @type \f x -> (liftM2 (>)) `on` f (numerator x) (denominator x)
02:29:56 <lambdabot> forall a1 (m :: * -> *) a a11. (Integral a, Monad m, Ord a1) => (a -> a -> a11 -> m a1) -> Ratio a -> a11 -> a11 -> m Bool
02:30:08 <dmwit> hmm
02:30:56 <dmwit> @type \f -> (liftM2 (>)) `on` f (. numerator) (. denominator)
02:30:57 <lambdabot> forall a1 (m :: * -> *) b a b1 a11 a2. (Integral a11, Integral a, Monad m, Ord a1) => (((a -> b) -> Ratio a -> b) -> ((a11 -> b1) -> Ratio a11 -> b1) -> a2 -> m a1) -> a2 -> a2 -> m Bool
02:31:03 * dmwit stops
02:31:19 <yitz> @type \f x -> liftM2 (>) `on` f (numerator x) (denominator x)
02:31:20 <lambdabot> forall a1 (m :: * -> *) a a11. (Integral a, Monad m, Ord a1) => (a -> a -> a11 -> m a1) -> Ratio a -> a11 -> a11 -> m Bool
02:32:48 <yitz> @type \f x -> f  `on` (liftM2 (>))  (numerator x) (denominator x)
02:32:49 <lambdabot> forall c a1 a. (Integral (a -> a1), Ord a1) => (Bool -> Bool -> c) -> Ratio (a -> a1) -> a -> a -> c
02:33:15 <yitz> getting closer
02:34:04 <yitz> @type on
02:34:05 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
02:34:33 <yitz> @type denominator
02:34:34 <lambdabot> forall a. (Integral a) => Ratio a -> a
02:35:54 <yitz> @type \f x -> fliftM2 $ (>) `on` f  (numerator x) (denominator x)
02:35:55 <lambdabot> Not in scope: `fliftM2'
02:35:55 <lambdabot>     precedence parsing error
02:35:55 <lambdabot>         cannot mix `($)' [infixr 0] and `on' [infixl 0] in the same infix expression
02:36:25 <yitz> @type \f x -> liftM2 ((>) `on` f  (numerator x) (denominator x))
02:36:26 <lambdabot> forall b a a1 (m :: * -> *). (Monad m, Integral a, Ord b) => (a -> a -> a1 -> b) -> Ratio a -> m a1 -> m a1 -> m Bool
02:36:37 <dmwit> :t \f -> (liftM2 (>) numerator denominator) `on` f
02:36:38 <lambdabot>     Couldn't match expected type `b -> c' against inferred type `Bool'
02:36:38 <lambdabot>     Probable cause: `>' is applied to too many arguments
02:36:38 <lambdabot>     In the first argument of `liftM2', namely `(>)'
02:36:55 <gour> anyone using emacs with cabal file?
02:36:57 <dmwit> :t \f -> (liftM2 (>) numerator denominator) `on` (f .)
02:36:58 <lambdabot>     Couldn't match expected type `b -> c' against inferred type `Bool'
02:36:58 <lambdabot>     Probable cause: `>' is applied to too many arguments
02:36:58 <lambdabot>     In the first argument of `liftM2', namely `(>)'
02:37:25 <gour> i've some strange experience in regard with tabs/spaces...cabal complaining about tabs
02:37:37 <dmwit> on (+) f x y = f x + f y -- just writing it down to stare at it
02:37:44 <yitz> @type \f -> liftM2 (\x -> (>) `on` f  (numerator x) (denominator x))
02:37:45 <lambdabot> forall b a a2 (m :: * -> *). (Monad m, Integral a, Ord b) => (a -> a -> a2 -> b) -> m (Ratio a) -> m a2 -> m (a2 -> Bool)
02:38:44 <yitz> @type \f z -> liftM2 (\x y -> (>) `on` f  (numerator x) (denominator y)) z z
02:38:45 <lambdabot> forall b a a1 (m :: * -> *). (Monad m, Integral a, Ord b) => (a -> a -> a1 -> b) -> m (Ratio a) -> m (a1 -> a1 -> Bool)
02:38:50 <dmwit> :t \f -> on (liftM2 (>)) (f .) numerator denominator
02:38:51 <lambdabot> forall b a. (Integral a, Ord b) => (a -> b) -> Ratio a -> Bool
02:38:56 <dmwit> There it is!
02:39:06 <yitz> yay!
02:39:15 <Deewiant> @pl \f -> on (liftM2 (>)) (f .) numerator denominator
02:39:15 <lambdabot> flip (flip (on (liftM2 (>)) . (.)) numerator) denominator
02:39:36 <dmwit> So I want
02:39:48 <dmwit> liftM2 (>) `on` (strlen .) numerator denominator -- =)
02:40:12 <quicksilver> you need ()
02:40:20 <quicksilver> (liftM2 (.) `on` f) num denom
02:40:22 <dmwit> Yeah, I do.
02:40:35 <quicksilver> that's why it didn't type when you tried it a few screens back ;)
02:41:01 <quicksilver> erm, I missed my shift key on the >. but you take the point :)
02:41:10 <dmwit> oh!
02:41:12 <yitz> I like the new debugger in ghci, but the type checker is still the best debugger
02:41:13 <dmwit> yeah
02:41:44 <dmwit> I'll leave that in the code to mysteriorize myself later. =)
02:42:06 <yitz> put in an explicit type sig and it won't be mysterious at all.
02:42:44 <dmwit> bigNumerator :: Ratio a -> Bool
02:43:04 <dmwit> bigNumerator = (liftM2 (>) `on` (length . show .)) numerator denominator
02:43:15 <dmwit> Does the type-sig explain that function to you?
02:43:39 <dmwit> (It doesn't to me, and I just wrote it!)
02:43:45 <pjd> dmwit: what's that for?
02:43:57 <dmwit> Project Euler problem 57.
02:44:15 <yitz> mmm... the monad instance for -> does obscure things sometimes
02:44:16 <dmwit> It tells if the numerator has more digits than the denominator.
02:44:37 <pjd> yitz: it's perfectly clear once you get the hang of it
02:44:51 <pjd> it just turns numerator and denominator into adjectives
02:46:58 <yitz> @type \x -> (>) `on` (length. show) (numerator x) (denominator x)
02:46:59 <lambdabot>     Couldn't match expected type `t -> a -> b'
02:46:59 <lambdabot>            against inferred type `Int'
02:46:59 <lambdabot>     Probable cause: `length' is applied to too many arguments
02:47:38 <dmwit> @type \x -> ((>) `on` (length. show)) (numerator x) (denominator x)
02:47:39 <lambdabot> forall a. (Integral a) => Ratio a -> Bool
02:47:56 <yitz> right. isn't that more clear?
02:48:18 <dmwit> Actually, I think this is a better way of clarifying:
02:48:32 <Baughn> @ty on
02:48:33 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
02:48:35 <dmwit> :t liftM2 ((>) `on` (length . show)) numerator denominator
02:48:36 <lambdabot> forall a. (Integral a) => Ratio a -> Bool
02:48:54 <dmwit> I find it interesting that you can move the liftM2 out of the "on" clause.
02:49:10 <yitz> @pl \x -> ((>) `on` (length. show)) (numerator x) (denominator x)
02:49:10 <lambdabot> liftM2 ((>) `on` (length . show)) numerator denominator
02:49:24 <yitz> didn't someone just say that?
02:49:31 <dmwit> No, before it was
02:49:47 <dmwit> (liftM2 (>) `on` (length . show .)) numerator denominator
02:50:14 <dmwit> There, I have to mix "liftM2" and "on" in my mental stack.
02:50:17 <ski> @type \f -> (`on` f)
02:50:18 <lambdabot> forall b c a. (a -> b) -> (b -> b -> c) -> a -> a -> c
02:50:37 <dmwit> After moving "liftM2" out, I feel much more comfortable figuring things out one at a time.
02:50:58 <dmwit> (But then, I now feel somewhat comfortable with what liftM2 does in the (e ->) monad.)
02:51:25 <yitz> I really think it looks cleaner with the explicit parameter instead of liftM2. Not as cool, but it will save lots of debugging time.
02:51:41 <dmwit> ok
02:51:43 * dmwit shrugs
02:51:51 <dmwit> There's no accounting for taste. ;-)
02:52:06 <yitz> a chacun
02:53:19 <Baughn> @hoogle (b -> b -> b -> c) -> (a -> b) -> a -> a -> a -> c
02:53:19 <lambdabot> No matches, try a more general search
02:54:05 <Baughn> @. pl djinn (b -> b -> b -> c) -> (a -> b) -> a -> a -> a -> c
02:54:05 <lambdabot> f = (((const . const) .) .) . join . (ap .) . join . liftM2
02:54:17 <dmwit> :t \f g -> do { a <- g; b <- g; c <- g; return (f a b c) }
02:54:18 <lambdabot> forall (t :: * -> *) t1 t2. (Monad t) => (t1 -> t1 -> t1 -> t2) -> t t1 -> t t2
02:54:59 <dmwit> :t \f g -> liftM3 f g g g
02:55:00 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> a1 -> a1 -> r) -> m a1 -> m r
02:55:29 <dmwit> :t \f -> join . join $ liftM3 f
02:55:30 <lambdabot> forall a3 r (m :: * -> *). (Monad m) => (a3 -> a3 -> a3 -> r) -> m a3 -> m r
02:55:47 <dmwit> :t join . join . liftM3
02:55:48 <lambdabot> forall a3 r (m :: * -> *). (Monad m) => (a3 -> a3 -> a3 -> r) -> m a3 -> m r
02:56:18 <dmwit> :t join . join . liftM3 :: (b -> b -> b -> c) -> (a -> b) -> a -> a -> a -> c
02:56:19 <lambdabot>     Occurs check: cannot construct the infinite type: c = a -> a -> c
02:56:27 <dmwit> Oh, rats, I haven't got it right at all.
02:56:35 <dmwit> That reads the same 'a' every time. =/
03:01:10 <dmwit> ?djinn (b -> b -> b -> c) -> (a -> b) -> a -> a -> a -> c
03:01:10 <lambdabot> f a b c _ _ = a (b c) (b c) (b c)
03:01:13 <dmwit> heh
03:01:19 <dmwit> That doesn't do what you want, either.
03:01:59 <dmwit> :t const . const . join . join . liftM3 :: (b -> b -> b -> c) -> (a -> b) -> a -> a -> a -> c
03:02:01 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
03:02:22 <dmwit> :t const (const (join . join . liftM3)) :: (b -> b -> b -> c) -> (a -> b) -> a -> a -> a -> c
03:02:23 <lambdabot>     Occurs check: cannot construct the infinite type:
03:02:23 <lambdabot>       a3 = a3 -> a3 -> a3 -> c
03:04:04 <pjd> :t \a b c _ _ -> a (b c) (b c) (b c)
03:04:05 <lambdabot> forall t t1 t2 t3 t4. (t3 -> t3 -> t3 -> t4) -> (t -> t3) -> t -> t1 -> t2 -> t4
03:04:17 <pjd> is that a bug in djinn?
03:04:25 <dmwit> nope
03:04:34 <pjd> the type differs, though
03:04:51 <dmwit> :t \a b c _ _ -> a (b c) (b c) (b c) :: (b -> b -> b -> c) -> (a -> b) -> a -> a -> a -> c
03:04:52 <lambdabot>     Inferred type is less polymorphic than expected
03:04:52 <lambdabot>       Quantified type variable `a' is mentioned in the environment:
03:04:52 <lambdabot>         a :: t
03:05:06 <dmwit> eh?
03:05:27 <dmwit> In any case, the type of "f" provided by djinn is strictly more general than the one we asked for, so that's okay.
03:06:20 <dmwit> oh
03:06:30 <dmwit> :t (\a b c _ _ -> a (b c) (b c) (b c)) :: (b -> b -> b -> c) -> (a -> b) -> a -> a -> a -> c
03:06:31 <lambdabot> forall b c a. (b -> b -> b -> c) -> (a -> b) -> a -> a -> a -> c
03:06:42 <dmwit> See?  The types are compatible. =)
03:08:53 <pjd> :t undefined :: (b -> b -> b -> c) -> (a -> b) -> a -> a -> a -> c
03:08:54 <lambdabot> forall b c a. (b -> b -> b -> c) -> (a -> b) -> a -> a -> a -> c
03:08:56 <pjd> :P
03:09:01 <dmwit> ;-)
03:09:10 <dmwit> But djinn doesn't know about undefined.
03:09:15 <mauke> ‚ä•
03:09:16 <dmwit> ?djinn a -> b
03:09:16 <lambdabot> -- f cannot be realized.
03:09:31 <dmwit> That's the closest djinn gets to saying "f = undefined".
03:09:48 <ski> @djinn Void
03:09:48 <lambdabot> -- f cannot be realized.
03:10:03 <dmwit> ?djinn Void -> ()
03:10:03 <lambdabot> f = void
03:10:08 <dmwit> ?
03:10:12 <dmwit> ?djinn-env
03:10:12 <lambdabot> data () = ()
03:10:12 <lambdabot> data Either a b = Left a | Right b
03:10:12 <lambdabot> data Maybe a = Nothing | Just a
03:10:12 <lambdabot> data Bool = False | True
03:10:12 <lambdabot> data Void
03:10:14 <lambdabot> type Not x = x -> Void
03:10:16 <lambdabot> class Eq a where (==) :: a -> a -> Bool
03:10:16 <ski> void :: Void -> a
03:10:29 <dmwit> How does that work?
03:10:32 <ski> void v = case v of { }  -- conceptually
03:10:38 <dmwit> bwuh
03:11:00 <mauke> zen'd
03:11:00 <ski> no cases in `Void', no branches needed
03:11:10 <dmwit> Void is a bizarre thing.
03:11:17 <ski> it is not
03:11:21 <dmwit> It is too!
03:11:31 <dmwit> I feel young again!
03:11:34 <ski> what is bizarre is that it is not allowed in standard haskell
03:12:03 <mauke> newtype Void = Void Void
03:12:08 <quicksilver> I didn't know djinn could grok type classes at all
03:12:10 <ski> `Void' is just as much (or as little) bizarre as claiming that the empty set exists
03:12:30 <Baughn> What do you mean, "exists"?
03:12:31 <dmwit> quicksilver: Can it?
03:12:38 <quicksilver> @djinn Eq a => a -> a -> Bool
03:12:38 <lambdabot> Cannot parse command
03:12:53 <quicksilver> not sure why the class appears in djinn-env
03:12:59 <ski> Baughn : "can be spoken about" (in reasonable languages ;)
03:13:04 <dmwit> ?djinn (Eq a) => a -> a -> Boll
03:13:04 <lambdabot> -- f cannot be realized.
03:13:06 <dmwit> ?djinn (Eq a) => a -> a -> Bool
03:13:06 <lambdabot> f = (==)
03:13:13 <dmwit> Ah, it needs parens.
03:13:15 <Baughn> ski: By that definition, harry potter exists. ^^;
03:13:27 <ski> Baughn : yes
03:13:38 <Baughn> ski: Not that I have any problems talking about the empty set, void, or even bottom
03:13:56 <quicksilver> @djinn (Eq a) => a -> Either a b => Either Bool b
03:13:56 <lambdabot> Cannot parse command
03:14:06 <quicksilver> @djinn (Eq a) => a -> Either a b -> Either Bool b
03:14:07 <lambdabot> f a b =
03:14:07 <lambdabot>     case a == a of
03:14:07 <lambdabot>     False -> Left False
03:14:07 <lambdabot>     True -> case b of
03:14:07 <lambdabot>             Left _ -> Left False
03:14:08 <lambdabot>             Right c -> Right c
03:14:23 <quicksilver> ehm, not quite what I expected :)
03:14:39 <dmwit> heh
03:15:39 <ski> "Following Quine, it could be said that to exist is to be a value of a variable inside an appropriated logic"
03:15:58 <ski> (that's the sense of `exist' i was referring to)
03:16:18 <quicksilver> djinn fails to be functorial over Either _ b
03:16:24 <quicksilver> that surprises me quite a lot.
03:16:37 <Baughn> ski: No problem, then. You just have to tailor the logic to the values.
03:21:54 <dmwit> Heh, it takes 14.97s to solve this problem, of which 14.53s is building a Data.Set of the primes up to 1000000.
03:22:29 <dmwit> Haskell needs a library of fast (read: GMP-based) prime-related operations.
03:25:56 <Saul_> is there a way to use hoogle to search in (say) the GLUT library?
03:26:26 <dmwit> Yes, but you have to install hoogle locally and set up the list of functions/type-signatures yourself.
03:27:01 <dmwit> Actually, that last part is not so bad as you might think; :b on each module you want to search gives basically the format Hoogle expects, I think.
03:28:53 <Saul_> ok thanks
03:31:25 <Saizan> haddock has a flag to generate output for hoogle
03:33:59 <quicksilver> Saul_: FWIW, I just use :b
03:34:07 <quicksilver> Saul_: and then the search functions of my editor :)
03:34:30 <quicksilver> (combined with bookmarks on the haddock and liberal use of :i)
03:35:37 <Saul_> ok
03:35:56 <Saul_> What does FWIW mean btw?
03:36:36 <dmwit> for what it's worth
03:36:57 <Saul_> ah ok
03:37:38 <quicksilver> not that a hoogle built-in to ghci wouldn't be lovely
03:37:41 <quicksilver> it would
03:37:52 <quicksilver> but you can get quite a wa with the existing commands
03:43:36 <Saul__> Ok
03:43:57 <Saul__> Fullscreen worked, now I need something other than a reboot to exit :)
03:44:16 <dmwit> Saul_: From what, xmonad?
03:44:44 <Saul_> GLUT
03:44:50 <dmwit> oh, heh
03:45:01 <dmwit> Your window manager doesn't have a key-command for that?
03:45:41 <Saul_> I has, but the keys don't get to the window manager apparently
03:45:54 <dmwit> !
03:46:03 <quicksilver> can't you switch to a text cnsole and kill the process?
03:46:10 <quicksilver> or ssh in from another machine?
03:46:36 <Saul_> no alt-tab didn't work
03:46:51 <mauke> ctrl-alt-f1
03:47:05 <Saul_> ssh would probably work, but I don't have a machine lying around with internet
03:47:21 * ski just got the idea that hugs/ghci(/lambdabot ? ;) could use `:(' and `:)' to start and end multi-line expressions ..
03:47:28 <Saul_> mauke: That one might work, but I'd rather not try :)
03:47:34 <mauke> why not?
03:47:42 <mauke> alt-f7 to switch back
03:47:54 <quicksilver> ctrl-alt-f1 is a million times better than rebooting...
03:47:57 <Botje> ski: how about "LAMBDA CAT SEZ" and "LAMBDA CAT HAZ SPOKEN" ? :)
03:48:00 <mauke> assuming a typical linux setup
03:48:07 <Saul_> mauke: Because if it doesn't work I still have to reboot
03:48:25 <ski> Botje : too long and difficult to remember
03:48:31 <Saul_> I think I'll add in a kill command on esc
03:48:37 <mauke> I fail to see the problem
03:50:18 <jeffz> ctrl-alt-f1 can lock some video drivers, but it's usually fine.
03:50:59 <Saul_> But what if that command also doesn't pass on outside of the program?
03:52:48 <quicksilver> Saul_: I completely don't understand. Ctrl-alt-f1 is a standard tool which all linux programmers use every day
03:52:58 <quicksilver> and vastly preferable to a hard reboot...
03:53:33 <osfameron> what's Ctrl-Alt-F1 ?
03:53:41 <osfameron> oh
03:53:44 <osfameron> changing VT
03:54:09 <osfameron> how's that related to rebooting?
03:54:09 <Saul_> I have no problem with using it, but I'm not sure if it will work
03:54:12 <Saul_> alt-tab didn't work
03:54:40 <osfameron> well, try it
03:54:47 <osfameron> Ctrl-Alt-F1 usually works everywhere
03:54:55 <osfameron> apart from my $boss's new thinkpad, funnily enough
03:54:55 <byorgey> ctrl-alt-f1 is trapped at the kernel level, IIUC
03:55:13 <osfameron> you could always Ctrl-Alt-Backspace to restart X without rebooting
03:56:03 <Saul_> I'll try those later on, but I'm going to add my own kill
03:56:15 <Saul_> I need it anyhow
03:56:45 <mauke> did I just disconnect?
03:57:08 <ski> no
03:57:20 <mauke> haha, awesome. irssi++
03:57:37 <ski> cable unplugged ?
03:58:08 <mauke> no, I just installed a patched version of irssi and upgraded to it without disconnecting
03:58:31 <ski> upgraded the running process ?
03:58:31 <osfameron> oh?  last time I tried to do that, irssi promised it wouldn't restart, and then crapped itself anyway :-)
03:59:01 <mauke> ski: apparently
03:59:17 * osfameron looks at List::MoreUtils and sighs about it not being as nice as the prelude
03:59:53 * mauke sighs about List::Util::sum using foldl1 for no good reason
04:00:59 <osfameron> mauke: does it make a difference?
04:01:40 <mauke> for empty lists, yes
04:01:50 <quicksilver> > sum []
04:01:54 <lambdabot>  0
04:04:51 <Gilly> is it possible to make an efficient shortest path algorithm (like dijkstra) without using monadic arrays or similar structures with changeable states?
04:04:51 <osfameron> ah, cos their reduce does that
04:04:58 <osfameron> it does sort of make sense for max and min though
04:05:34 <mauke> osfameron: no, reduce is standard foldl
04:05:51 <osfameron> ah
04:05:58 <mauke> it's just that sum is effectively defined as sum xs = foldl (+) (head xs) (tail xs)
04:07:49 <Gilly> nvm, found an interesting mailing list discussion on the subject :P
04:08:02 <sebasmagri> hi people... i'm having some problems to emerge darcs... could anybody help me? http://gentoo-ve.pastebin.com/m3a80c6ea
04:08:33 <quicksilver> This morning's useful function: Data.Map.fromListWith
04:09:15 <quicksilver> cleverer than I realised.
04:09:24 <dmwit> :t fromListWith
04:09:25 <lambdabot> Not in scope: `fromListWith'
04:09:31 <dmwit> :t Data.Map.fromListWith
04:09:32 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> [(k, a)] -> M.Map k a
04:09:35 <unenough> how's Yi?
04:10:15 <dmwit> quicksilver: A foldl on the lists as partitioned by k?
04:10:40 <quicksilver> yes
04:10:43 <quicksilver> more like a foldl1
04:10:49 <dmwit> right
04:11:10 <quicksilver> I used it to build up an "Album name" => [(artist,track)] map
04:11:21 <quicksilver> from a list of (album,(artist,track)) triples
04:14:27 <skorpan> what's the difference between "import qualified X" and "import qualified X as Y"?
04:14:32 <skorpan> no wait!
04:14:36 <skorpan> that's not my question...!
04:14:40 <dmwit> heh
04:14:48 <skorpan> "import X as Y" vs "import qualified X as Y"
04:14:49 <dmwit> You only get one, so you've got to make it count. ;-)
04:14:58 <skorpan> :)
04:15:13 <dmwit> import X as Y imports things into both the global, the X., and the Y. namespaces.
04:15:26 <dmwit> import qualified X as Y imports things only into the X. and Y. namespaces.
04:15:37 <skorpan> oh...
04:15:41 <unenough> is Yi alive?
04:17:01 <skorpan> very much so, i think
04:17:35 <ski> mauke : `List::Util::sum' ?
04:17:48 <unenough> the wiki page was last updated in june 2006
04:17:50 <mauke> ski: what about it?
04:17:58 <ski> mauke : where is that from ?
04:18:10 <mauke> http://search.cpan.org/~gbarr/Scalar-List-Utils-1.19/lib/List/Util.pm#sum
04:18:12 <lambdabot> Title: List::Util - A selection of general-utility list subroutines - search.cpan.org, http://tinyurl.com/36qy47
04:18:20 <ski> ok, ty
04:18:27 <skorpan> unenough: there were 11 patches between March 9 and 15
04:18:31 <skorpan> in the darcs repo
04:18:40 <unenough> that would make it....
04:18:47 <unenough> >(15-9)/(11 :: Float)
04:18:58 <skorpan> :|
04:19:09 <unenough> that would make me dumb
04:19:11 <skorpan> i think you mean 11/(15-9)
04:19:22 <unenough> yes
04:19:30 <mauke> > 11/(15-9) :: Rational
04:19:30 <skorpan> ~2 patches per day
04:19:31 <lambdabot>  11%6
04:21:04 <unenough> :O
04:23:28 <asmanian> whats this "%" sign? where is it defined? (ghci doesnt seem to know it) [<- haskell beginner]
04:23:36 <byorgey> asmanian: Data.Ratio
04:23:39 <mauke> @index (%)
04:23:39 <lambdabot> Data.Ratio
04:23:45 <asmanian> thnx
04:23:45 <byorgey> it's for constructing rational numbers.
04:24:09 <asmanian> cool stuff :)
04:24:31 <byorgey> asmanian: so in ghci you can do  :m +Data.Ratio  to load it (apologies if you already knew that =)
04:24:47 <lesshaste> how hard is to it to make a randomised quicksort in haskell?
04:25:03 <byorgey> asmanian: and welcome to Haskell/#haskell =)
04:25:07 <quicksilver> not particularly hard.
04:25:10 <lesshaste> I know you can't really pick the random pivot in the C style way as it would take too long
04:25:12 <dmwit> It's not too hard, but it isn't that pretty.
04:25:14 <asmanian> thnx byorgey :)
04:25:15 <EvilTerran> it has a few obstacles
04:25:15 <quicksilver> but not necessarily particularly simple either.
04:25:19 <mauke> lesshaste: why not?
04:25:25 <EvilTerran> unsafePerformRandom?
04:25:43 <quicksilver> it also isn't particularly sensible.
04:25:47 <lesshaste> mauke: doesn't it take linear time to pick out a random element?
04:25:56 <quicksilver> merge sort is just a better algorithm for a functional list.
04:25:58 <byorgey> for a list, yes.
04:26:01 <quicksilver> of course, if you have an array, then use quicksort, sure.
04:26:02 <ski> lesshaste : are you talking lists or arrays ?
04:26:04 <mauke> lesshaste: not on arrays
04:26:10 <asmanian> its a tough learning curve for an imperative programmer, but I think as soon as I find a suitable project and some time, my haskell knowledge hopefully boosts by getting my hands dirty
04:26:13 <lesshaste> ah.. arrays are too modern for me :)
04:26:21 <quicksilver> well quicksort is an array algorithm.
04:26:27 <quicksilver> so if you don't want to use arrays, don't use it :P
04:26:44 <lesshaste> quicksilver: I was hoping there was some beautiful purely functional list method
04:27:01 <byorgey> asmanian: I'm sure it will.
04:27:05 <quicksilver> lesshaste: there is. it's called merge sort.
04:27:11 <byorgey> hehe
04:27:19 <lesshaste> quicksilver: what about the problem of just randomised the list?
04:27:27 <lesshaste> is that also not possible to do nicely ?
04:27:31 <smg> good morning
04:27:34 <quicksilver> sure
04:27:36 <lesshaste> randomising
04:27:38 <byorgey> hey smg
04:27:39 <smg> how can i get 2 / 3 which returns Fract into an Int ?
04:27:46 <quicksilver> @go haskell perfect shuffle
04:27:49 <lambdabot> http://okmij.org/ftp/Haskell/perfect-shuffle.txt
04:27:53 <EvilTerran> div? quot?
04:27:58 <byorgey> smg: hm?  you want round?
04:28:05 <mauke> smg: 2 `div` 3
04:28:05 <smg> round will return Integral
04:28:10 <quicksilver> but if you prefer the naive solution, just zip with with a random list and sortBy snd.
04:28:11 <smg> ah div
04:28:13 <smg> i forgot about div :)
04:28:16 <ski> smg : `floor',`ceiling',`round' may be what you want
04:28:16 <mauke> smg: Int is an Integral
04:28:19 <lesshaste> quicksilver: that's great and also answers the quicksort question :) thanks
04:29:02 <lesshaste> quicksilver: hmm. how can you make a random list with no duplicates without using the perfect shuffle algorithm?
04:29:53 <Toxaris> what's the point of implementing quicksort by using sortBy as a primitive?
04:30:01 <lesshaste> Toxaris: a good point :)
04:30:10 <Toxaris> just use sort and be happy.
04:30:27 <lesshaste> Toxaris: it's just an exercise for pedagogical reasons..
04:31:18 <lesshaste> that's a lovely document I have to say (the perfect shuffle one)
04:31:30 <smg> mauke: but not vice versa eh? :P
04:32:39 <byorgey> smg: hm?  round returns *any* Integral, which includes Int.
04:32:54 <byorgey> what type it returns depends on the context in which it is used.
04:33:00 <byorgey> > round 4.9 :: Int
04:33:01 <lambdabot>  5
04:33:06 <smg> :P
04:33:08 <byorgey> > round 4.9 :: Integer
04:33:08 <lambdabot>  5
04:33:12 <smg> but `div` is better for my usage
04:33:22 <byorgey> oh, sure, just clarifying =)
04:33:24 <dmwit> > round 5.9 :: Int
04:33:24 <lambdabot>  6
04:33:30 <quicksilver> lesshaste: erm, by reimplmenting the perfect shuffle without admitting it? :)
04:33:30 <dmwit> wait
04:33:41 <quicksilver> lesshaste: (the two problems seem almost equivalent to me)
04:33:41 <dmwit> > map round [4.5, 5.5] :: [Int]
04:33:42 <lambdabot>  [4,6]
04:33:46 <dmwit> Ah, there we go.
04:33:47 <lesshaste> quicksilver:  :)
04:33:51 <quicksilver> banker's rounding.
04:33:54 <TSC> Those crazy bankers
04:34:08 <EvilTerran> > map round [1%2,..]
04:34:08 <lambdabot>  Parse error at "..]" (column 16)
04:34:11 <EvilTerran> > map round [1%2..]
04:34:12 <lesshaste> quicksilver: in any case... the answer to my original question was "Do the perfect shuffle then non randomised quicksort" :)
04:34:12 <lambdabot>  [0,2,2,4,4,6,6,8,8,10,10,12,12,14,14,16,16,18,18,20,20,22,22,24,24,26,26,28,...
04:35:04 <byorgey> > map round [1%3..]
04:35:05 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
04:35:09 <byorgey> ah, much better =)
04:37:55 <dolio> > round (2.5 :: Rational)
04:37:56 <lambdabot>  2
04:40:55 <quicksilver> one of the coolest things about haskell's overloaded Num type is "2.5" as a precise Rational.
04:41:23 <smg> hehe
04:41:53 <dozer> @pl a >= mn && a <= mx
04:41:54 <lambdabot> a >= mn && a <= mx
04:41:54 <skorpan> no.
04:42:10 <dozer> @pl f a = a >= mn && a <= mx
04:42:10 <lambdabot> f = liftM2 (&&) (>= mn) (<= mx)
04:42:13 <mauke> @pl \mn mx -> a >= mn && a <= mx
04:42:13 <lambdabot> (. (a <=)) . (&&) . (a >=)
04:42:43 <dozer> I think the explicit arg version is more readable in this case :)
04:43:01 <mauke> :t inRange
04:43:02 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Bool
04:56:00 <Oejet> Hi.
04:58:36 <quicksilver> hi
05:14:00 <b_jonas> dozer: I must say, this is one example when J's higher-order primitives allow you to write the example simply
05:14:13 <b_jonas> but that's OT this channel
05:14:46 <dozer> mm
05:15:17 <unenough> laziness is a virtue
05:15:33 <dozer> k, next question :) given some expression/value in ghci, can I ask ghci to list instances of classes it inhabits?
05:15:57 <unenough> proof: if man weren't lazy, he would never had invented the wheel (credits to my high schoo math teacher)
05:15:59 <quicksilver> well, not in one step
05:16:08 <quicksilver> but :i Num will list all Num instances in scope
05:16:38 <ToRA> dozer, :t e gives expression e's type, then :i type lists what the type is an instance of
05:16:51 <quicksilver> dozer: it ought to be easy enough to write a ghci macro for it
05:17:00 <quicksilver> ToRA: and then :i class lists other instances of that class :)
05:17:02 <ToRA> or as quicksilver says, :i class tells you what types are instances of a class
05:17:11 <ToRA> quicksilver: beat me to it :)
05:17:16 <dozer> k - found what I wanted to know in 2 steps rather than 1
05:17:29 <dozer> was expecting this to work:   :i (<5)
05:18:34 <quicksilver> :i for values might be an interesting feature request
05:19:04 <dozer> it ticks part of the 'wtf can I do with this now?' box
05:19:20 <quicksilver> :wtf ?
05:19:33 <ziman> can i find out whether a type is instance of a class somehow? ghci bugs me with an `overlapping instances' error and i can't see how that's possible in my code
05:19:34 <dozer> what the £&(%
05:22:57 <EvilTerran> dozer, does :t on the expression followed by :i on the reported type work?
05:23:29 <EvilTerran> ziman, ":i Foo" in ghci
05:23:49 <EvilTerran> ghci> :i Bool
05:23:49 <EvilTerran> data Bool = False | True        -- Defined in GHC.Base
05:23:49 <EvilTerran> instance Bounded Bool -- Defined in GHC.Enum
05:23:49 <EvilTerran> instance Enum Bool -- Defined in GHC.Enum
05:23:50 <EvilTerran> ...
05:24:14 <dozer> EvilTerran: not very well :)
05:24:49 <b_jonas> could you do, like, '(id :: (Enum a) => a) (undefined :: Bool)' to find out if Bool is an Enum?
05:25:00 <b_jonas> or the same with :t
05:25:14 <b_jonas> thugh that only works for * types, not higher-order types
05:25:27 <dozer> EvilTerran: works better if I strip out the (x =>) part of the reported type
05:25:34 <b_jonas> @type (id :: (Enum a) => a) (undefined :: Bool)
05:25:35 <lambdabot>     Couldn't match expected type `a1' against inferred type `a -> a'
05:25:35 <lambdabot>       `a1' is a rigid type variable bound by
05:25:35 <lambdabot>            the polymorphic type `forall a1. (Enum a1) => a1'
05:25:43 <EvilTerran> ah, yes, :i doesn't work so well on type-expressions, either
05:25:54 <EvilTerran> (either as compared to value expressions)
05:26:01 <EvilTerran> @type (id :: (Enum a) => a -> a) (undefined :: Bool)
05:26:03 <lambdabot> Bool
05:26:13 <b_jonas> @type (undefined :: (Enum a) => a -> a) (undefined :: Bool)
05:26:14 <lambdabot> Bool
05:26:25 <b_jonas> @type (undefined :: (Enum a) => a -> a) (undefined :: Double)
05:26:26 <lambdabot> Double
05:26:38 <b_jonas> @type (undefined :: (RealFloat a) => a -> a) (undefined :: Bool)
05:26:39 <lambdabot>     No instance for (RealFloat Bool)
05:26:39 <lambdabot>       arising from instantiating a type signature at <interactive>:1:1-36
05:26:39 <lambdabot>     Possible fix: add an instance declaration for (RealFloat Bool)
05:26:47 <b_jonas> so that works
05:26:51 <EvilTerran> it'd be nice if you could just say ((undefined :: Bool) :: exists a. Enum a => a) or something... :P
05:26:51 <b_jonas> very well
05:27:04 <EvilTerran> actually, hold on...
05:27:13 <b_jonas> EvilTerran: you could do that with asType
05:27:15 <EvilTerran> ?type (undefined :: Enum a => a) :: Bool
05:27:16 <lambdabot> Bool
05:27:24 <EvilTerran> there we go. that's nicer.
05:27:29 <EvilTerran> ?type (undefined :: RealFloat a => a) :: Bool
05:27:30 <lambdabot>     No instance for (RealFloat Bool)
05:27:30 <lambdabot>       arising from instantiating a type signature at <interactive>:1:1-29
05:27:30 <lambdabot>     Possible fix: add an instance declaration for (RealFloat Bool)
05:28:02 <b_jonas> @type (undefined :: Bool) :: RealFloat a => a
05:28:03 <lambdabot>     Couldn't match expected type `a' against inferred type `Bool'
05:28:03 <lambdabot>       `a' is a rigid type variable bound by
05:28:03 <lambdabot>           the polymorphic type `forall a. (RealFloat a) => a'
05:28:14 <ziman> EvilTerran, yes, but this is weird. ghci says `Overlapping instances for Wrappable ([Int] -> [Int]), Matching instances: instance (Printable a) => Wrappable a ...', however, i only instantiated String, Int, and [Int] as Printable. I can't see how this might cause a function to be Wrappable
05:28:17 <b_jonas> that can't match if two types can be unified
05:28:30 <b_jonas> is there a way to do that too?
05:28:49 <ziman> or i don't understand instantiation fully
05:29:20 <thartman> is there any language extension that lets you hide instances when importing a module?
05:29:22 <EvilTerran> b_jonas, the more general type has to be on the outside
05:29:42 <EvilTerran> er, inside
05:29:44 <b_jonas> EvilTerran: but what if you want to match two types of which neither are more general?
05:29:49 <quicksilver> ziman: that makes EVERYTHING Wrappable.
05:29:55 <EvilTerran> can you give an example?
05:30:00 <quicksilver> ziman: instance (Foo a) => Bar a says "EVERYTHING is a Bar"
05:30:12 <b_jonas> like Complex a and Num
05:30:16 <quicksilver> ziman: "... but add a Foo constraint too"
05:30:23 <b_jonas> those would match only if a is RealFloat or something
05:30:30 <EvilTerran> ?type (undefined :: Complex a => a) :: Num a => a
05:30:30 <lambdabot>     Type constructor `Complex' used as a class
05:30:31 <lambdabot>     In the type `(Complex a) => a'
05:30:31 <lambdabot>     In an expression type signature:
05:30:36 <EvilTerran> er what
05:30:40 <ziman> quicksilver, doesn't that mean that "everything that is Foo is also a Bar"?
05:30:47 <quicksilver> ziman: No, as I said.
05:30:51 <quicksilver> ziman: it means EVERYTHIING is a Bar.
05:30:57 <quicksilver> (but add a Foo constraint)
05:31:03 <b_jonas> EvilTerran: (Complex a), not (Complex a => a)
05:31:10 <EvilTerran> ziman, the type system doesn't take class contexts into account
05:31:28 <EvilTerran> when deciding which instance fits
05:31:35 <quicksilver> ziman: you might get the behaviour you expect if you turn on overlapping instances and maybe some other extensions.
05:31:37 <b_jonas> I want ghci to find out if there's a type that's both Complex a and Num a => a
05:31:44 <b_jonas> even thoguh I can do this case by hand
05:31:52 <quicksilver> But I don't use those, because I don't understand how they work precisely.
05:31:53 <EvilTerran> i'll think about it.
05:31:54 <EvilTerran> :P
05:32:02 <ziman> EvilTerran, quicksilver, okay, thanks much
05:32:48 <b_jonas> @type (id :: (a,a)->(a,a)) (undefined :: (Complex a, (Num a => a)))
05:32:49 <lambdabot>     Couldn't match expected type `Complex a'
05:32:49 <lambdabot>            against inferred type `(Num a) => a'
05:32:49 <lambdabot>     When matching `(Num a1) => a1'
05:34:22 <b_jonas> I mean, the compiler _can_ do that internally
05:34:27 <b_jonas> let me think
05:34:55 <quicksilver> b_jonas: the compiler never does that kind of search.
05:35:06 <b_jonas> quicksilver: I think it does.
05:35:09 <quicksilver> it never asks the question "which types saisfy these constraints"
05:35:13 <b_jonas> yep
05:35:18 <b_jonas> but it does do something like that
05:35:22 <quicksilver> the only question it ever asks is "does this type satisfy these constraints"
05:35:24 <b_jonas> it can unify two types like that
05:35:25 <TomMD> ?localtime quicksilver
05:35:28 <lambdabot> Local time for quicksilver is Mon Mar 17 12:35:25 2008
05:35:32 <b_jonas> a moment
05:35:36 <quicksilver> b_jonas: I believe you are wrong.
05:35:44 <b_jonas> let me try to create an example then
05:36:03 <quicksilver> the only type it simplifies contexts is superclass constraints, I think.
05:37:26 <b_jonas> which module has Complex?
05:37:45 <b_jonas> Data.Complex
05:39:22 <b_jonas> hmm
05:39:37 <b_jonas> maybe I don't understand what let-polymorphism really means
05:40:52 <ski> let-polymorphism is to only generalize at the binding-level in `let'
05:41:21 <b_jonas> here, look
05:41:28 <b_jonas> :t let { f :: Complex a -> Complex a; f = undefined; g :: Num b => b -> b; g = undefined; } in f (g undefined)
05:41:29 <lambdabot> forall a. (RealFloat a) => Complex a
05:41:55 <lesshaste> Are there any "sensible" problems that are known to take asymptotically longer in a purely functional setting than in an imperative one?
05:42:01 <b_jonas> it's unified the type (Complex a) with the type (Num b => b)
05:42:14 <b_jonas> I know it doesn't look at class context when it does the unification
05:42:23 <quicksilver> lesshaste: asymptotic factors of log n are common, yes.
05:42:24 <b_jonas> so it doesn't exactly find the intersection of the two types
05:42:34 <b_jonas> but it finds the unification by normal haskell rules
05:42:35 <lesshaste> quicksilver: oh ok.. do you know of one by any chance?
05:42:46 <b_jonas> the result is the type it's output
05:42:57 <quicksilver> lesshaste: stuff that makes essential use of mutation.
05:43:19 <yitz> quicksilver: no, there can be no difference
05:43:30 <lesshaste> quicksilver: well that's why I ask as I can think of tree algorithms that appear to but then some smart person comes along with a really clever functional solution :)
05:44:08 <lesshaste> quicksilver: so I was wondering is there is anything that is widely accepted to have this gap
05:44:42 <b_jonas> lesshaste: have you seen http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf (or the book it was expanded to)?
05:45:01 * shepheb would like to find that book, what's it called?
05:45:12 <quicksilver> yitz: I didn't say always, I just said it's common.
05:45:23 <dmwit> I guess the last time somebody asked this question, we decided that it is still an open problem whether mutation gets you any asymptotic efficiency.
05:45:24 <quicksilver> @go purely functional data structure
05:45:24 <lesshaste> b_jonas: I did see it once but thanks for reminding me of it
05:45:24 <yitz> quicksilver: sometimes an "imperative setting" hides the log n factor of memory access by hardwiring the cpu's parallel memory access hardware into the language. The fact that Haskell forces you to admit it does not mean that the algorithm has higher complexity.
05:45:25 <lambdabot> http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
05:45:40 <quicksilver> yitz: well, of course. btu that's a separate algoritm.
05:45:42 <quicksilver> erm
05:45:43 <quicksilver> argument.
05:46:05 <lesshaste> dmwit: ah ok.. very interesting thanks
05:46:20 <quicksilver> there is http://www.amazon.com/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504
05:46:22 <lambdabot> http://tinyurl.com/38dwc2
05:46:24 <quicksilver> that's the book version
05:46:40 <dmwit> Purity + strictness = less asymptotically efficient than impurity + strictness in some cases.
05:46:57 <lesshaste> dmwit: I should know these things but I am not even sure what the computational model would be if you were looking for  lower bounds for problems, for example.  In the imperative model you have the RAM model, Turing machines, pointer machines etc.
05:46:57 <dmwit> But purity + laziness ?= impurity + strictness.
05:47:13 <b_jonas> quicksilver: what do you say about that type statement?
05:47:15 <shepheb> quicksilver: thanks. I looked at his thesis in August when I first looked at Haskell. another read now should bring more enlightenment.
05:48:39 <quicksilver> b_jonas: yes, but it's not calculating the intersection of two classes, which is what I thought you were asking for.
05:48:48 <quicksilver> b_jonas: it's just checking if Complex is an instance of Num.
05:49:00 <b_jonas> yes, that's true
05:49:01 <b_jonas> I mean
05:49:16 <b_jonas> if you wanted to calculate the intersection of (Foo a => a) and (Bar a => a) that way
05:49:18 <dmwit> > sum . map digitToInt . show $ 2^1000
05:49:19 <lambdabot>  1366
05:49:24 <b_jonas> you'd just get ((Foo a, Bar a) => a)
05:49:35 <b_jonas> but it does look at instances for more complicated classes
05:49:36 <lesshaste> dmwit: ok so I think the answer is going to be that there is a gap
05:49:48 <b_jonas> note how it's found the class RealFloat which was not present in the query
05:49:51 <b_jonas> only in the instances
05:49:55 <dmwit> lesshaste: Any particular reason?
05:50:15 <lesshaste> dmwit: I am thinking of things like linear time sorting of integers
05:50:16 <quicksilver> b_jonas: yes, that's because instance RealFloat a => Num (Complex a)
05:50:21 <b_jonas> so I think it can solve problems that are non-trivial to colve by hand this way
05:50:27 <lesshaste> dmwit: can that really be done in a functional setting?
05:50:41 <b_jonas> yep, and it selects that instance only using the right hand side
05:50:43 <dmwit> Sure.
05:50:45 <b_jonas> not the constraints
05:51:01 <quicksilver> yes.
05:51:09 <lesshaste> dmwit: ok :) you know I am going to ask how now
05:51:11 <b_jonas> still, it's good to know how to ask this kind of question from ghci
05:51:34 <dmwit> lesshaste: Keep in mind that purity = lots of sharing.
05:52:02 <dmwit> lesshaste: So I think (?) that the usual, say, counting sort with a Data.Array would give you your linear-time sort.
05:52:40 <dmwit> Bah, that's even too complex.
05:53:03 <dmwit> Just go ahead and do a radix-sort with our nice built-in linked lists, right?
05:54:04 <oklofok> @die 1d2
05:54:05 <lambdabot> 1d2 => 2
05:54:15 <lesshaste> dmwit: radix sort needs count sort
05:54:15 <dmwit> (Sorry for being a bit incoherent, it's very late here.)
05:54:29 <dmwit> lesshaste: eh?  Maybe I'm saying the wrong names then.
05:54:52 <dmwit> Let's say you're sorting the integers [0..4].
05:54:58 * shepheb ponders list monad and radix sort
05:55:10 <dmwit> :t partition
05:55:11 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
05:56:10 <dmwit> :t uncurry (++) . partition (\x -> x `div` 2 == 0) . uncurry (++) . partition even
05:56:11 <lambdabot> forall a. (Integral a) => [a] -> [a]
05:56:27 <dmwit> There's your linear-time sort for the integers up to 4.
05:56:34 <yitz> @type even
05:56:35 <lambdabot> forall a. (Integral a) => a -> Bool
05:56:40 <shepheb> constants might suck, but that seems to be O(n * d), d the number of digits in the longest number, which is bounded for Int.
05:56:44 <dmwit> (untested, the first condition might have to be ... /= 0 or something.)
05:57:33 <lesshaste> what does :t do?
05:57:40 <dmwit> It shows the type of a function.
05:57:44 <lesshaste> ah ok :)
05:57:52 <dmwit> How much Haskell do you know?
05:58:13 <b_jonas> ok, now a question
05:58:14 <lesshaste> dmwit: I learnt miranda
05:58:17 <b_jonas> this works:
05:58:20 <lesshaste> dmwit: but that is out of fashion now :)
05:58:31 <lesshaste> dmwit: so I only know the haskell parts that are like miranda
05:58:32 <dmwit> lesshaste: Oh, maybe I should give a bit more explanation for that code, then?
05:58:37 <lesshaste> dmwit: yes please :)
05:58:41 <dmwit> ok =)
05:58:58 <dmwit> partition even -- this will split the list into even and odd numbers
05:59:03 <dmwit> > partition even [1..10]
05:59:04 <lambdabot>  ([2,4,6,8,10],[1,3,5,7,9])
05:59:07 <b_jonas> @type  let { f :: Complex a -> Complex a; g :: Num b => b -> b; (f, g) = (undefined, undefined); } in ()
05:59:08 <lambdabot> ()
05:59:15 <b_jonas> but this gives a strange error:
05:59:20 <b_jonas> @type  let { f :: Complex a -> Complex a; g :: Num b => b -> b; (f, g) = undefined; } in ()
05:59:20 <dmwit> uncurry (++) -- this recombines the two lists after partition splits it
05:59:21 <lambdabot>     Cannot match a monotype with `forall a. Complex a -> Complex a'
05:59:21 <lambdabot>       Expected type: (forall a. Complex a -> Complex a,
05:59:21 <lambdabot>                       forall b. (Num b) => b -> b)
05:59:26 <b_jonas> what does that error mean?
05:59:35 <dmwit> > uncurry (++) ([2,4,6,8],[3,5,7,9])
05:59:36 <lambdabot>  [2,4,6,8,3,5,7,9]
05:59:36 <b_jonas> what on earth is a monotype?
05:59:50 <dmwit> lesshaste: Good so far?
05:59:54 <lesshaste> dmwit: yep :)
06:00:05 <b_jonas> is that like a magnetic monopole?
06:00:10 <lesshaste> dmwit: could you do me a favour and paste the code somewhere?
06:00:14 <dmwit> lesshaste: Okay, then you can guess what the next step is: partition on the second bit (rather than the last).
06:00:18 <dmwit> lesshaste: sure
06:00:20 <lesshaste> dmwit: I find the bot replies confusing
06:00:22 <quicksilver> monotype == monomorphic type, I think.
06:00:24 <lesshaste> thx
06:01:16 <lesshaste> dmwit: but the algorithm appears to be n log n but linear
06:01:22 <lesshaste> dmwit: one pass per bit
06:01:37 <dmwit> lesshaste: One pass per bit, but a constant number of bits.
06:01:48 <shepheb> lesshaste: constant passes per bit.
06:01:55 <lesshaste> dmwit: the number of bits is a function of the input size
06:02:02 <dmwit> nope
06:02:02 <lesshaste> it's not a constant..
06:02:13 <lesshaste> well let's define the input to be in the range 1..n
06:02:19 <lesshaste> now it certainly isn't a constant ;)
06:02:30 <dmwit> hpaste.org/6430
06:03:01 <dmwit> lesshaste: The way you get away with linear-time sorting algorithms is by restricting the range of the input.
06:03:04 <lesshaste> the trivial C style answer in this case is just to place each number in it's correct location in an auxiliary array
06:03:08 <lesshaste> dmwit: right
06:03:13 <dmwit> lesshaste: For simplicity, I restricted it down to [0..3], but you can do it for Int as well, with a little patience.
06:03:23 <lesshaste> dmwit: if you have values in the range 1..n then you get linear time imperatively
06:03:36 <lesshaste> dmwit: is it linear functionally too?
06:03:40 <dmwit> lesshaste: You can still get that here, if you declare n ahead-of-time.
06:03:50 <dmwit> lesshaste: of course, and with the same basic algorithm
06:04:01 <lesshaste> dmwit:  if you do it bit wise you get log n passes though
06:04:10 <dmwit> lesshaste: You make one pass per bit, functionally or imperatively.
06:04:16 <dmwit> lesshaste: ...no
06:04:20 <lesshaste> dmwit: the imperative code is quite different
06:04:24 <lesshaste> dmwit: one pass in all cases
06:04:31 <dmwit> lesshaste: It's still one pass per bit, it's just that there's log n bits.
06:04:31 <lesshaste> for the range 1..n
06:04:43 <dmwit> lesshaste: Hmm, I think you (or I!) may be confused.
06:04:48 <lesshaste> dmwit: right.. the functional code takes log n passes, the imperative code takes one
06:04:56 <dmwit> proof?
06:05:00 <lesshaste> dmwit: :) I want to sort an array of numbers in the range 1..n
06:05:07 <dmwit> i.e. name a sort that Wikipedia knows about?
06:05:16 <shepheb> if we're sorting machine Ints here, that's a constant, though. 32, generally.
06:06:03 <lesshaste> dmwit: imperatively I just read each value and place a 1 in that position.. For i  = 1..n (C[i] := 1)
06:06:33 <lesshaste> dmwit: then you have only to go through C to get the sorted elements (you should initialise C to zero first I suppose)
06:07:02 <dmwit> lesshaste: i.e. you know there will be at most one copy of each number?
06:07:06 <lesshaste> dmwit: it doesn't have a name I don't think as it is so simple :).. it's basically one half of counting sort. The other half is to make it stable but we aren't worrying about that
06:07:09 <tromp> 32 is just log n where n <= 2^32
06:07:15 <b_jonas> quicksilver: still don't understand
06:07:28 <lesshaste> dmwit: you can do  For i  = 1..n (C[i] += 1) if there can be more than one copy of each number
06:07:28 <shepheb> yes, of course, but it doesn't grow with n the input size.
06:07:35 <dmwit> right
06:07:40 <tromp> by the time you sort 2^64 numbers, you'd expect to be on a 64 bit machine
06:07:42 <b_jonas> is the a in the Inferred type (chopped by lambdabot) different from the a in the Expected type
06:07:43 <dmwit> lesshaste: This is also possible in Haskell.
06:07:47 <lesshaste> dmwit: aha!
06:07:51 <lesshaste> dmwit: using arrays right?
06:07:55 <dmwit> lesshaste: (Though it's not quite as obvious why it should be linear.)
06:08:07 <lesshaste> dmwit: oh... tell me more :)
06:08:09 <b_jonas> wait, monomorphic type is related to the monomorphism restriction with let-polymorhism?
06:08:12 <dmwit> lesshaste: Yes, you can use arrays, or you can even use linked-lists, depending on your assumptions.
06:08:55 <lesshaste> dmwit: ok.. so basically I don't know anything about haskell and arrays... sorry
06:08:59 <dmwit> lesshaste: Instead of (c[n] += 1), you use the moral equivalent of (c[n] := n : c[n]).
06:09:23 <b_jonas> lesshaste: haskell has multiple types of arrays
06:09:33 <dmwit> lesshaste: Where (:) is the "cons" operator that creates a linked list with head "n" and tail "c[n]".
06:09:34 <laura85> hi ^^
06:09:48 <lesshaste> dmwit: How does that help make it sorted?
06:09:58 <lesshaste> dmwit: oh I see.. sorry.. n = i :)
06:10:08 <dmwit> lesshaste: right =)
06:10:19 <dmwit> lesshaste: Then you just concatenate these lists as the last step.
06:10:36 <lesshaste> dmwit: so to find this gap I need to stop thinking that haskell doesn't have arrays :)
06:10:52 <lesshaste> dmwit: so what is the problem with mutability if you can update arrays in constant time?
06:10:53 <dmwit> Well... you'll be pretty sad if you design all your algorithms around arrays.
06:11:00 <lesshaste> :)
06:11:04 <dmwit> The constant is big.
06:11:06 <dmwit> =)
06:11:09 <lesshaste> :)
06:11:28 <lesshaste> dmwit: thx.. this has been very enlightening
06:11:41 <laura85> dmwit, hey ^^
06:11:47 <dmwit> laura85: Hiya!
06:11:52 <dmwit> How's it going?
06:12:10 <laura85> dmwit, I'm fine, thanks. how about you?
06:12:20 <dmwit> I'm tired.  It's bedtime!
06:12:23 <dmwit> =D
06:12:37 <laura85> dmwit, 2:12 pm here ^^
06:12:38 <lesshaste> good night
06:12:48 <lesshaste> laura85: that can be bedtime too :)
06:13:06 <laura85> lesshaste, heh I know what you mean ^^
06:13:13 <lesshaste> :)
06:16:05 <oklofok> @die 1d2
06:16:05 <lambdabot> 1d2 => 2
06:16:33 <oklofok> ...
06:17:07 <ski> @die 3d6 + 2
06:17:07 <lambdabot> 3d6 + 2 => 13
06:17:24 <ski> @die 0d5
06:17:24 <lambdabot> 0d5 => 0
06:17:27 <ski> @die 1d1
06:17:28 <lambdabot> 1d1 => 1
06:17:29 <ski> @die 1d0
06:17:29 <lambdabot> 1d0 => 1
06:17:40 <ski> hm ?
06:18:11 <shepheb> minimum result on any roll is 1, in most tabletop systems?
06:18:15 <mauke> @die 1.5d2
06:18:16 <lambdabot> unexpected ".": expecting digit, "d", "+" or end
06:18:19 <mauke> :(
06:18:57 <shepheb> s/on any roll/on any unmodified roll/
06:19:05 <mauke> I think I still have the source for my extended dice roller somewhere. it allowed fractional and even complex arguments
06:19:50 * shepheb rolls 6d8i-4
06:20:31 <ski> `1d0' ought to give "division by zero" or somesuch, no ?
06:20:34 <tromp> @die 2d6
06:20:34 <lambdabot> 2d6 => 6
06:20:35 <shepheb> and deals imaginary-imaginary damage to imaginary-real monsters.
06:20:38 <tromp> @die 2d6
06:20:38 <lambdabot> 2d6 => 6
06:20:39 <tromp> @die 2d6
06:20:40 <lambdabot> 2d6 => 7
06:20:41 <tromp> @die 2d6
06:20:41 <lambdabot> 2d6 => 12
06:21:00 <tromp> @die 1000000d6
06:21:00 <lambdabot> 1000000d6 => 3499626
06:21:08 <mauke> oh, wait
06:21:18 <shepheb> mauke: roll in the complex and real dimensions independently and then just combine the result?
06:21:22 <mauke> it converts complex inputs to reals first :/
06:21:33 <shepheb> awww. oh well.
06:21:56 <ski> mauke : fractional/complex number of rolls, or number of sides ?
06:22:08 <Lemmih> join #happs
06:22:10 <mauke> both
06:22:18 <ski> intriguing
06:22:32 <shepheb> but it just projects onto the reals?
06:23:10 <mauke> wait, this is weird
06:23:24 <mauke> it filters complex numbers through abs(), but not negative reals
06:23:35 <yitz> what are a, b, and c in dice adb+c?
06:24:00 <sfultong> salutations, all!
06:24:02 <mauke> a = number of dice, b = number of sides
06:24:13 <yitz> hi sfultong
06:24:47 <ski> greetings and salutations, sfultong
06:25:06 <sfultong> thanks yitz, ski
06:25:07 <yitz> c=?
06:25:26 <ski> yitz : some extra offset/number to add to the result
06:26:02 <b_jonas> shepeb: is that like the imaginary dragons in the Cyberiad?
06:26:02 <shepheb> have we got a bundle of Okasaki's structures on hackage or in the libraries? that table of runtimes is damn impressive.
06:26:51 <mauke> @where edison
06:26:51 <lambdabot> http://www.eecs.tufts.edu/~rdocki01/edison.html
06:26:56 <b_jonas> for reference, the random number function in J raises a domain error for non-real complex input
06:27:25 <sfultong> I've just been using ubuntu (coming from gentoo), and it seems that there are even fewer haskell packages available... is there a way to use cabal or something to keep my haskell libs more current in an easy fashion?
06:27:26 <shepheb> @where+ edison http://www.cs.princeton.edu/~rdockins/edison/home/
06:27:27 <lambdabot> Good to know.
06:27:27 <mauke> @where+ edison http://www.cs.princeton.edu/~rdockins/edison/home/
06:27:28 <lambdabot> I will never forget.
06:27:30 <mauke> haha
06:27:35 <ski> does `J' have quaternions ?
06:27:36 <b_jonas> (it does the same for non-integral real ones)
06:27:40 <b_jonas> ski: no
06:28:09 <b_jonas> (not as primitives that is, there's a module to do some calculations on them)
06:28:14 <glen_quagmire> wow i went to #hakell  and no one was there
06:28:25 <mauke> potato
06:28:30 <b_jonas> (whereas complex doubles are primitive numbers)
06:28:50 <ski> ic
06:29:18 <shepheb> sfultong: cabal-install should make it easier. though I don't have much experience with it.
06:32:54 <b_jonas> (it gives a domain error for negative integers as well)
06:34:45 <shepheb> the distro packaging systems move far too slow for hackage. even, apparently, for GHC. some distros still have 6.6.1, when 6.8.1 is now over 5 months old.
06:36:42 <glen_quagmire> windows distro has 6.8.2 official binary
06:36:43 <pejo> shepheb, in fairness it's been a bumpy ride between 6.6 and 6.8.
06:37:13 <sfultong> shepheb: thanks, yeah... I want a hackage-based repository system that's easy
06:37:47 <oklofok> @die 1d2
06:37:47 <lambdabot> 1d2 => 2
06:37:50 <oklofok> ...
06:38:17 <opqdonut> @die 100d1
06:38:17 <lambdabot> 100d1 => 100
06:38:18 <opqdonut> :)
06:38:39 <shepheb> glen_quagmire: but it doesn't have a moral equivalent to "apt-get install ghc". you have to go to the site, download it, and install the binaries. if you're doing that, x86 Linux and OSX have packages too.
06:40:01 <shepheb> as a specific case, it would help a lot for xmonad evangelism if the answer to dependencies was "apt-get install ghc-6.8.2" instead of "go to this link and..."
06:40:10 <Beelsebob> I've not explicitly "wanted" that, but certainly the whole site and the way it works lends it well to the idea of doing pkg management
06:40:46 <sfultong> shepheb: couldn't xmonad be all statically compiled?  I imagine it'd still be pretty small...
06:41:29 <sfultong> I wonder what distro has the best package support for haskell...
06:42:02 <opqdonut> gentoo and debian are pretty good
06:42:10 <opqdonut> debian unstable that is
06:42:18 <shepheb> sfultong: yes, of course, and it is. but changing one's configuration means recompilation. it's fast, but it requires GHC. that said, most distros do have 6.6.1, which does work.
06:44:01 <sfultong> if debian unstable is pretty good, why isn't ubuntu unstable seeming to be very good? :(
06:44:39 <sfultong> maybe I shouldn't have switched from gentoo... I figured that ubuntu would be popular enough to have up-to-date haskell stuff
06:44:58 <opqdonut> because ubuntu sucks nowadays :)
06:45:08 <shepheb> asking the question is probably tantamount to volunteering, but what about setting up and apt repo for hackage, or at least GHC?
06:45:18 <quicksilver> it's an excellent idea
06:45:24 <quicksilver> you could work with the debian ghc maintainers
06:45:26 <quicksilver> (igloo?)
06:45:44 <opqdonut> an apt-repo for hackage would be best
06:45:57 <opqdonut> there was someone keeping unofficial bleeding-edge ghc packages a while ago
06:46:01 <quicksilver> in principle it could even be auto-built
06:46:12 <quicksilver> opqdonut: the official ones are normally not long behind anyhow
06:46:17 <shepheb> it's obviously huge win. I'm just not sure how much work is involved to set it up, and how much automation vs. manual updating would be necessary.
06:46:31 <sfultong> hmm... I'm nothing like an expert at package maintenance, but I'm tempted actually...
06:47:16 <shepheb> well, hang on. cabal-install does basically the same thing,
06:47:46 <shepheb> getting packages from hackage.
06:47:57 <sfultong> maybe make a thin wrapper around cabal-install packages for debs?  I dunno how feasible that would be
06:48:13 <shepheb> so maybe just the GHC one is worthwhile.
06:48:49 <inimino> I just installed cabal-install on debian stable
06:49:23 <inimino> it's a fair bit of work because of all the dependencies
06:49:34 <sfultong> hmm :-/
06:49:58 <sfultong> I was hoping to install cabal-install on ubuntu, but there doesn't seem to be any easy package
06:50:13 <shepheb> okay. that's maybe a good argument for looking into it.
06:50:28 <pejo> sfultong, upgrading an individual package (ghc for example) can usually be done in a few simple steps by changing the package specification in a few selected places.
06:50:35 <inimino> ghc and cabal-install debian packages would have saved me some hours
06:50:55 <pejo> sfultong, (assuming you have a package for a previous version).
06:51:56 <shepheb> I have no idea how much work is necessary to set up an apt or debian repo. more worrying, there's a ton of stuff on hackage, and it's very interconnected. we have a list of dependencies in the form of cabal files, but who knows how easy that would be to automate into packages.
06:52:33 <sfultong> well, isn't it just a matter of parsing the cabal files then? :-P
06:53:14 <inimino> http://www.haskell.org/haskellwiki/Creating_Debian_packages_from_Cabal_package
06:53:16 <lambdabot> Title: Creating Debian packages from Cabal package - HaskellWiki, http://tinyurl.com/2m8u8w
06:54:16 <hallongrottan> skorpan: how's your project going?
06:54:37 <shepheb> hmm. there's a couple of questionable points there. as long as the info for those files can be retrieved automatically, it can be done. but the copyright info, the descriptions.
06:55:25 <Philippa> maintainer info, too
06:55:47 <sfultong> hmm... if maintaining a package repository would involve legal/copyright issues, then I'm out
06:56:05 <shepheb> some of that is in cabal files and hackage pages.
06:56:16 <Philippa> yes, but it's put up by anyone
06:56:31 <shepheb> it's not copyright issues, just that the package system wants to know the license.
06:56:31 <Philippa> which means that someone else can upload something having got it wrong
06:57:01 <shepheb> and some descriptions are empty, outdated or otherwise bad.
06:59:27 <skorpan> hallongrottan: i'm able to move pieces in a cool unicode art chess board now and also checking whether the moves are valid
06:59:33 <hallongrottan> skorpan: sweet
06:59:38 <skorpan> i have a long way to go though
06:59:42 <hallongrottan> i havent got that far on my lol
06:59:51 <hallongrottan> mine*
07:00:06 <skorpan> i'm not yet using any monad, which i'm pretty sure would make the code much cleaner
07:00:12 <hallongrottan> ah
07:00:16 <hallongrottan> perhaps, yes
07:00:20 <skorpan> i'll probably be using either the Reader or State together with ErrorT
07:00:38 <skorpan> it will be a pain changing it in the code later
07:02:02 <sfultong> heh... anyone read the reddit article equating monads to hard drugs?
07:02:35 <b_jonas> sfultong: no, link?
07:03:36 <sfultong> http://abaababa.blogspot.com/2008/02/monads-are-class-of-hard-drugs.html
07:03:38 <lambdabot> Title: Abaababa: Monads are a class of hard drugs, http://tinyurl.com/2kdlnx
07:03:55 <b_jonas> thx
07:04:04 <thartman> in ghci quickcheck p works, but :r with the same line of code causes an error.   http://hpaste.org/6433
07:04:30 <skorpan> awesome
07:04:41 <thartman> dunno why hpaste didn't announce that. any idea what ghci is doing differently via the interactive prompt?
07:05:28 <pjd> it's weird how people react to monads
07:05:40 <pjd> monoids are a comparable abstraction, and no one makes a fuss about them
07:05:45 <thartman> that guy is a lambda-terrorist :)
07:05:57 <pjd> i guess it's all IO's fault
07:06:08 * shepheb always misses something good when his connection dies.
07:06:25 <sfultong> pjd: because many people outside the haskell community know about monads, but I'm guessing many less know about monoids
07:06:41 <pjd> shepheb: http://abaababa.blogspot.com/2008/02/monads-are-class-of-hard-drugs.html
07:06:43 <lambdabot> Title: Abaababa: Monads are a class of hard drugs, http://tinyurl.com/2kdlnx
07:06:44 <skorpan> "...the original paper on monads is actually quite easy to understand and fun to read..." where is it?!
07:06:59 <sfultong> hehe
07:07:01 <pjd> skorpan: i think the reddit commentary has linkage
07:07:11 <sfultong> is that referring to wadler's paper?
07:07:22 <b_jonas> shepeb: http://tinyurl.com/2kdlnx
07:07:23 <lambdabot> Title: Abaababa: Monads are a class of hard drugs
07:07:26 <b_jonas> linked from reddit
07:08:26 <b_jonas> OH FUCK
07:08:43 <gwern> for a language no one uses, everyone complains a lot about monads and transformers
07:09:02 <sfultong> quite true
07:09:11 <b_jonas> ROOT PARTITION FULL
07:09:53 <gwern> b_jonas: so delete /usr/share/doc. boom, many megs freed
07:10:21 <thartman> hey am I being heard? (new irc client)
07:10:29 <scook0> thartman: loud and clear
07:10:30 <b_jonas> gwern: no, I deleted a knoppix dvd image I already burned
07:10:32 <vincenz> thartman: no you're not being head
07:10:33 <thartman> coolio :)
07:10:34 <vincenz> heard
07:10:38 <b_jonas> and will delete some older photos I have one dvds
07:10:53 <b_jonas> I have much more disk space but not on this partition
07:11:02 <thartman> anyone know what [#p, #d, i] means in the erc mode line?
07:11:15 <thartman> I thought maybe i meant ignored or something
07:11:21 <glen_quagmire> i think those are ghc stuff
07:11:22 <gnuvince> thartman: those are the channels that have activity on them
07:11:43 <glen_quagmire> what is erc mode line?
07:12:11 <glen_quagmire> :t (#p)
07:12:14 <lambdabot> parse error on input `)'
07:13:00 <glen_quagmire> data Int = GHC.Base.I# GHC.Prim.Int#  something like this?
07:13:27 <quicksilver> glen_quagmire: he's talking about an IRC client, not haskell.
07:13:32 <wvd> hello
07:13:36 <ski> glen_quagmire : erc is an irc client for emacs, the mode line is the mode line of the buffer in question
07:13:53 <thartman> sorry, should have been more clear
07:13:55 <glen_quagmire> i fail from the morning
07:14:17 <glen_quagmire> what is # in GHC.Base.I# ? hard to google
07:14:41 <ski> "just" a naming convention
07:14:42 <Lemmih> glen_quagmire: It's part of the name.
07:14:58 <hallongrottan> how do i define my own instance of Eq for a datatype?
07:15:03 <Lemmih> glen_quagmire: Like '_' in 'mapM_'.
07:15:13 <wvd> I want to get input using getLine and then keep the string that the user typed around and later display it with putStrLn, how do I turn the value from getLine into a String from an IO String?
07:15:17 <mauke> hallongrottan: data X ... deriving (Eq) :-)
07:15:18 <glen_quagmire> > let a# = 1 in (a + 2)
07:15:18 <lambdabot>  Parse error at "=" (column 8)
07:15:20 <ski> hallongrottan : `instance Eq Foo where ... == ... = ...'
07:15:31 <mauke> wvd: do you know about do-notation?
07:15:47 <hallongrottan> ski: but if i need to compare the stuff in the definition of ==
07:15:47 <Lemmih> glen_quagmire: It's not valid haskell98. GHC uses it for GHC specific things.
07:15:53 <hallongrottan> does that work?
07:16:04 <ski> compare what stuff ?
07:16:15 <mauke> @src Bool (==)
07:16:15 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
07:16:21 <glen_quagmire> Lemmih: oh i see
07:16:31 <glen_quagmire> hallongrottan: maybe compare function?
07:16:31 <hallongrottan> ski: let's say i want stuff from my datatype to be equal when they have the same constructor
07:16:39 <glen_quagmire> > compare 1 2
07:16:41 <lambdabot>  LT
07:16:45 <wvd> mauke: yes, thats how I'm getting the string in the first place
07:16:50 <hallongrottan> oh
07:16:53 <wvd> in a do { ... }
07:16:56 <ski> @src [] (==)
07:16:56 <lambdabot> []     == []     = True
07:16:56 <lambdabot> (x:xs) == (y:ys) = x == y && xs == ys
07:16:56 <lambdabot> _xs    == _ys    = False
07:17:14 <hallongrottan> ah thanks
07:17:15 <mauke> wvd: do { x <- getLine; putStrLn x }
07:17:36 <wvd> so do { i <- getLine; return i }
07:17:45 <mauke> wvd: that's equivalent to getLine
07:18:04 <wvd> I dont want to print it immediatle
07:18:05 <wvd> y
07:18:07 <wvd> sorry
07:18:22 <wvd> I want to do other things first and then eventaully putStrLn
07:18:30 <scook0> do { x <- getLine ; otherStuff ; putStrLn x }
07:18:40 <scook0> is that what you mean?
07:18:48 <wvd> why do I have to do it all in the same do { .. }?
07:18:59 <scook0> because that's the scope of x
07:19:06 <ski> wvd : you can break it up into separate definitions if you like
07:19:36 <b_jonas> why on earth is my ghc build directory so huge if the source tarballs are small?
07:19:41 <wvd> ski: thats what I'm trying to do
07:19:55 <wvd> but when I get to the putStrLn in my second do { ... }
07:19:58 <ski> scook0 : possibly, it could be easier to explain, if you give more context
07:19:59 <scook0> wvd: perhaps hpaste what you've got?
07:20:03 <b_jonas> the complete build directory built is 1112912K
07:20:07 <wvd> it moans that the string is not a string but an IO String
07:20:09 <ski> @hpaste
07:20:09 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:20:10 <inimino> what is the "user-install" option in cabal-install?
07:20:17 <shepheb> that "hard drug" article leaves me feeling like he's wanting to have and eat cake. purity is good, but you need to handle side effects somehow.
07:20:20 <b_jonas> whereas the two archives are less than 8M
07:20:38 <b_jonas> I don't care about the disk space, but it's just strange
07:20:40 <quicksilver> shepheb: he wants to have his coke and eat it ? :P
07:20:51 <shepheb> quicksilver: well played :D
07:21:15 <hallongrottan> ski: i suppose making my data type an instance of Ord is the same, but with the other operators?
07:21:30 <scook0> inimino: configures cabal packages as --user
07:21:45 <ski> hallongrottan : yes
07:21:59 <scook0> i.e. installs them under your home dir, rather than system-wide
07:22:19 <shepheb> also, GHC is slow largely because it does a lot of work, not because Haskell is slow. darcs has well-known -- and apparently solved, meaning it can't be the language's fault! -- performance problems. I guess you can't win against bad logic.
07:22:36 <wvd> ski: there, http://hpaste.org/6434
07:22:42 <ski> hallongrottan : iirc, you only have to define `(<=)' or `compare', the other members have default definitions in terms of those
07:22:58 <hallongrottan> aha, sweet
07:23:43 <ski> wvd : your `get_inp' can be defined as `get_inp = getLine', there's no difference
07:23:54 <wvd> yes
07:23:57 <shepheb> does darcs 2 push and pull patch in a bundle instead of one at a time? 900 patches * 100ms ping = 90 second download. then it applies them in about three seconds.
07:24:17 <wvd> but note that I'm trying to do it across two different and seperate do { .. } blocks
07:24:44 <ski> wyd : inside a `do'-expression, you can "extract" the results of any IO actions you want .. but you have to "use" the results in the same `do'-expression .. note that "use" may be passing into another function, though
07:25:38 <ski> http://hpaste.org/6434#a1
07:25:41 <wvd> so once I enter a do block thats it, end of program, everything I want to do has to happen there?
07:26:15 <ski> either it has to happen there, or in IO-actions called from there
07:26:44 <byorgey> note you can still use pure functions from within do-blocks, however.
07:26:45 <ski> (if by "do" you mean "perform IO-things")
07:26:48 <byorgey> just not vice-versa.
07:26:58 <ski> usually, one does something along the line
07:26:58 <wvd> theres no idea of get some input, do some pure functional type stuff, get some other input, do more pure stuff, print the results unless you do all of it in the same do block?
07:27:05 <byorgey> (note: this is a lie and applies only to the IO monad =)
07:27:27 <gbacon> wvd: that could happen inside the same do block
07:27:42 <mauke> wvd: do blocks are a red herring
07:27:43 <byorgey> wvd: no, you can certainly do that.  do { x <- foo; let y = purefunc x; blah blah }  and later purefunc x = ...
07:27:51 <ski> do {input <- getSomeInputPlease; let output = process input; showThisOutput output}
07:28:51 <byorgey> mauke has a good point, it's really all about the types, not about do-blocks vs. not
07:28:59 <ski> wvd : it would be easier to help if you could give more hints on what exactly you want to do
07:30:06 <ski> (possibly, what you want is very possible, just that you don't know yet how to structure the code in haskell to make it fit)
07:30:48 <wvd> ski: thanks but its allright, I just dont get haskell, time to accept that and move on and get some work done in something a bit more forgiving
07:31:21 <wvd> like brainf_ck or intercal :P
07:31:24 <gbacon> wvd: let us know what you're trying to do, and someone can give you a leg up
07:31:27 <byorgey> wvd: note that 'not getting haskell' right now (understandable) is not the same as 'complete inability to ever get haskell' (doubtful).
07:31:37 <byorgey> =)
07:31:40 <hallongrottan> is there a datatype that describes natural numbers?
07:31:43 <hallongrottan> like 0 and above
07:31:59 <byorgey> hallongrottan: [()] ?  or you mean something built-in?
07:32:06 <hallongrottan> i mean something built in
07:32:08 <hallongrottan> like Integer
07:32:12 <byorgey> hallongrottan: no
07:32:15 <hallongrottan> too bad
07:32:21 <byorgey> yes, it's unfortunate
07:32:26 <hallongrottan> then i'll have to check it manually
07:32:34 <byorgey> but I think there are various libraries that implement it
07:32:44 <hallongrottan> well, it's not much work for me anyways
07:33:05 <byorgey> data Nat = Z | Suc Nat
07:33:11 <byorgey> hallongrottan: what are you trying to do?
07:33:45 <mauke> wvd: does http://mauke.ath.cx/stuff/haskell/how-to-io.html help?
07:33:46 <lambdabot> Title: Haskell: How To IO
07:34:02 <byorgey> wvd: note that 'return 0' at the end of main is not correct.  'return' probably isn't what you think it is.  it's named unfortunately and has little to do with 'return' in C.
07:34:06 <bd_> hallongrottan: You could implement it as a wrapper over Integer. Or use one of the Word types (they correspond to unsigned integer types in C)
07:34:28 <byorgey> 'return x' just means 'create a monadic computation that does nothing and results in the value x'.
07:34:43 <inimino> scook0: thanks
07:34:58 <pjd> wvd: you can think of the IO monad as the shell around an egg;  it's the least interesting bit :)
07:36:18 <pjd> the bulk of your program might be called from an IO block, but be otherwise independent of it
07:36:57 <hallongrottan> bd_: it wasnt really that important, but thanks anyway =)
07:39:10 <ski> wvd : the main points of the `IO' thing is to ensure : a) non-IO parts of the program may not call IO parts ; b) IO parts are sequenced
07:40:11 <ski> wvd : unless you want to call IO parts from non-IO parts, you should be fine .. in particular, you may pass results of IO parts into both other IO and non-IO parts
07:41:28 <wvd> ski: what does my get_inp function actually return?
07:41:40 <wvd> its not a string, because I cant print it
07:41:47 <wvd> its something called IO String
07:41:53 <ski> `get_inp' is not a function, it is an IO-action
07:42:07 <ski> *if* that action is run, it will return a string
07:42:52 <ski> actions may be run by either putting them into other `do'-expressions, or putting them as `main'
07:42:59 <EvilTerran> well, it is a function, but it's a function that returns an action
07:43:00 <EvilTerran> :P
07:43:11 <wvd> how do I get the string out of IO string to print it without doing it all in the same do block or is there just no way to do that and to even attempt it in haskell is folly and shows my lack of understanding?
07:43:13 <ski> (or putting them as input to interactors like hugs and ghci)
07:43:28 <mauke> get_inp is not a function, it's a constant
07:43:43 <mauke> and you get the String from IO String with >>=
07:43:48 <mauke> or <- in do notation
07:43:59 <ski> wvd : `get_inp' represents the action of reading a string, it doesn't represent the string itself
07:44:25 <wvd> so what do I need to do to get_inp to make it represent the string itself then?
07:44:33 <kpreid> wvd: execute it
07:44:34 <ski> wvd : maybe you want to see a silly^H^H^Hmple example of coding with IO ?
07:44:43 <mauke> wvd: get_inp = "some string"
07:44:53 <mauke> if get_inp is the string itself, it's a constant string
07:45:36 <quicksilver> wvd: "x <- get_inp"  now get_inp is the action, and 'x' is the actual string.
07:46:56 <wvd> so folly then ;)
07:48:27 <quicksilver> not at all.
07:48:38 <quicksilver> what you asked for is quite possible
07:48:51 <quicksilver> 'x' is now a normal string, you can pass it to other functiona however you want
07:51:24 <wvd> quicksilver: but I cant for instance return it from the do block and still expect it to be a normal string right?
07:51:48 <marshmallows> wvd: reverse :: String -> String, getLine >>= (print . reverse) :: IO String
07:52:23 <marshmallows> (parenthesis not needed)
07:53:09 <pjd> wvd: you can't break it out of IO, yeah
07:53:46 <pjd> wvd: what programming background do you come from?
07:53:47 <mauke> wvd: that would mean actually running the action inside of haskell
07:53:59 <mauke> which is not allowed because of purity
07:54:12 <wvd> pjd: non-pure imperative c, c++, perl
07:54:45 <quicksilver> wvd: well, you're just thinking about the problem wrong.
07:54:56 <quicksilver> wvd: it's the do block that has the IO type
07:54:57 <quicksilver> wvd: not the string.
07:55:03 <pjd> wvd: i guess you're familiar with callbacks, then?
07:55:06 <quicksilver> wvd: *anything* returned from that do block will have IO type
07:55:14 <quicksilver> because the do-block is an IO action.
07:55:15 <wvd> pjd: somewhat
07:55:17 <EvilTerran> marshmallows, er, getLine >>= print . reverse :: IO ()
07:55:42 <quicksilver> wvd: the problem you're worrying about is a non-problem, but it would be easier to show you that with a real example in mind :)
07:56:19 <pjd> wvd: a useful way to think about the IO type is as an action which hasn't happened yet
07:56:23 <elzurk> last mightybyte
07:56:31 <elzurk> oops, wrong channel
07:56:32 <quicksilver> (and might never happen, or might happen more than once)
07:57:15 <pjd> wvd: so an IO String is something that will result in a string
07:58:25 <pjd> wvd: you can't take the string "out" of the IO, because there isn't any actual string yet
07:59:20 <pjd> wvd: what you can do, though, is add a function that will accept the string when it arrives, like a callback
07:59:38 <wvd> ok
07:59:46 <pjd> the simplest way to do this is with a function called fmap
07:59:48 <pjd> :t fmap
07:59:50 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:00:13 <pjd> (IO is a Functor, not just a Monad;  you'll learn more about that later :)
08:00:30 <pjd> :t fmap length getLine
08:00:31 <lambdabot> IO Int
08:00:45 <hallongrottan> oh sweet
08:00:49 <hallongrottan> i didnt know about that
08:00:52 <marshmallows> :t getLine >>= return . length
08:00:54 <lambdabot> IO Int
08:01:26 <shepheb> hallongrottan: every monad is also a functor, though the standard type classes don't implement that.
08:01:41 <wvd> until you started throwing around terms like Functor, I almost thought I started getting the gist of it :P
08:02:23 <quicksilver> I don't know if fmap makes things simpler, when you're learning.
08:02:33 <quicksilver> do { x <- getLength ; return (length x) }
08:02:35 <quicksilver> is the same thing.
08:02:42 <wvd> I kid, this has been enormously helpful, and I just want to point out that you guys are awesome and very helpful
08:02:42 <pjd> only more complicated :)
08:02:42 <quicksilver> fmap is shorter and more elegant, sure.
08:03:00 <quicksilver> it's only more complicated in a sense.
08:03:03 <wvd> but I have to go now, before my brain melts out of my ears and nostrils
08:03:03 <quicksilver> I'm not sure it really is.
08:03:05 <wvd> thanks
08:03:11 <bd_> fmap is the same as liftM, note
08:03:13 <quicksilver> the point is, if you're learning do notation, you might as well get happy with it.
08:03:24 <quicksilver> I would learn the shortcuts afterwards, personally.
08:03:31 <bd_> except fmap needs a Functor instance, which isn't /automatically/ created for a monad
08:03:33 <Philippa> bd_: should be rather than guaranteed, I believe
08:03:45 <bd_> Philippa: right, but if it's not then the functor instance is broken :)
08:04:04 <Philippa> bd_: no, there's more than one possible functor on a lot of types
08:04:19 <Philippa> the report doesn't require that Functor instances are the same functor as the one a Monad instance is built around
08:04:20 <bd_> but a monad has a specific relation to a functor
08:04:28 <pjd> quicksilver: *shrug*
08:04:39 <Philippa> there may be more than one possible monad on some types, too
08:04:39 <bd_> so although the report doesn't require it, it's arguably the wrong functor for the type anyway
08:04:49 <Philippa> there's definitely at least two for Either, for example
08:04:53 <bd_> if you want a different one newtype it :)
08:05:13 <Philippa> but it's only "arguably" and it's a bad idea to rely on it without checking
08:05:14 <pjd> quicksilver: i've generally had more success introducing things in the order of Functor -> Monad -> do notation
08:05:26 <EvilTerran> Philippa, at least two? which're you thinking of?
08:05:39 <Philippa> EvilTerran: swap Left and Right round :-)
08:05:43 <bd_> I support, but I would definitely call any type with definitions of Functor and Monad where return/join/fmap isn't the same monad as return/>>= buggy :)
08:05:49 <EvilTerran> you can't swap Left and Right, 'cos then the partial application of Either in the instance decleration wouldn't work
08:05:50 <bd_> suppose*
08:06:03 <pjd> Functor is a much more intuitive abstraction than Monad
08:06:08 <Philippa> EvilTerran: note lowercase "monad" rather than Monad
08:06:11 <EvilTerran> ahh
08:06:26 <pjd> everyone already knows how map works on lists and such
08:06:29 <Philippa> the partial application bit's an accident
08:06:34 <quicksilver> pjd: I think that's the approach a mathmetician would take, but I think it's the wrong approach for a computer programmer
08:06:42 <quicksilver> especially an imperative one
08:06:43 <visof> hello
08:07:09 <bd_> pjd: I think it depends on what you're doing with it. Functor makes lots of sense when you're working with monads as containers, but return and bind make a lot of sense when you're working with a monad as a sequencing method
08:07:32 <bd_> and of course the same monad could be used in both ways at different times
08:07:37 <visof> i found in my faculty university book with name "Algorithms A functional programming approach"
08:07:41 <pjd> bd_: Functor makes plenty of sense for IO too
08:07:41 <quicksilver> indeed, throwError and catchError have familiar-shaped types, relative to the monad operations :)
08:07:52 <visof> by fethi Rabhi and Guy Lapalme
08:07:54 <quicksilver> :t throwError
08:07:55 <lambdabot> forall e (m :: * -> *) a. (MonadError e m) => e -> m a
08:08:00 <quicksilver> :t catchError
08:08:01 <lambdabot> forall (m :: * -> *) a e. (MonadError e m) => m a -> (e -> m a) -> m a
08:08:09 <visof> did anyone read this book?
08:08:18 <marshmallows> :t (return, (>>=))
08:08:20 <lambdabot> forall a (m :: * -> *) (m1 :: * -> *) a1 b. (Monad m1, Monad m) => (a -> m a, m1 a1 -> (a1 -> m1 b) -> m1 b)
08:08:20 <shepheb> does anyone have an intuition for partially applied composition?
08:08:23 <sfultong> hmm, cabal install really works rather painlessly
08:08:28 <bd_> pjd: putStr "foo" >> putStr "bar" makes more sense than join $ fmap (const $ putStr "bar") (putStr "foo") to me :)
08:08:56 <bd_> it's all about using the right tool at the right time
08:09:00 <pjd> bd_: right, and that's different to fmap length getLine :)
08:09:13 <bd_> pjd: oh, sure, but that's data manipulation more than IO in my mind :)
08:09:42 <Philippa> bd_: but it's also the answer to "how do I take the string out of getLine?"
08:10:00 <bd_> the length of it you mean
08:10:11 <Philippa> no, I don't
08:10:32 <bd_> fmap length getLine <-- throws away the string returned by getLine after counting its length
08:10:38 <Philippa> the thing with "how do I take the string out of getLine?" is that nobody wants /just/ the literal answer
08:10:42 <Philippa> they want to know what to do instead
08:10:44 <pjd> bd_: the great thing about that approach is that it naturally leads to join/bind
08:11:06 <Philippa> right, you only need to use join as far as explaining bind - but explaining join tells you something important about monads
08:11:35 <bd_> I'm not sure we're disagreeing... I'm just saying that in not all cases is fmap/join/return easier to work with than return/>>=  :)
08:12:09 <Philippa> ...that's not the message you're conveying at first glance though
08:12:25 <pjd> bd_: indubitably, but this is about what road is easier to learn
08:12:51 <Philippa> bind as "build it, run it" makes a certain amount of sense
08:13:18 <Philippa> and join tells you that you get higher-order computations - that you really can treat monads as "like ordinary haskell, but...", if you like
08:13:24 <quicksilver> Well, my message was "when trying to explain to an imperative programmer about not being able to take stuff out of IO, fmap doesn't help"
08:13:41 <pjd> quicksilver: right, and all i'm saying is that my experience is the opposite
08:13:48 <quicksilver> I would rather show them how to use do blocks, which look like the programming they're used to.
08:13:50 <Philippa> quicksilver: I disagree, insofar as you're also trying to tell them about what to do instead
08:13:55 <Philippa> *nod*
08:13:57 <quicksilver> and how to join them together.
08:14:04 <Philippa> but when you get to "how does that desugar?", fmap's a useful step
08:14:10 <quicksilver> sure.
08:14:15 <quicksilver> we weren't at that stage yet, iIMO
08:14:26 <Philippa> and not everyone responds well to do straight away
08:14:33 <quicksilver> we were at the "this isn't possible" stage
08:14:33 <pjd> quicksilver: i know lots of Twisted Python people, for example
08:14:35 <Philippa> programming in an ANF variant's a pain in the arse
08:14:41 <quicksilver> and I was trying to explain that it was.
08:15:22 <pjd> quicksilver: fmap with IO is exactly the most familiar abstraction
08:16:49 <pjd> quicksilver: more generally, anyone who's worked with GUI/networking frameworks that make use of callbacks can immediately connect that to fmap
08:17:20 * quicksilver doesn't really see that.
08:17:34 <quicksilver> I would have said callbacks were actions-as-first-class-values
08:17:39 <pjd> the former are probably the most common kind of explicit effect sequencing in mainstream imperativia
08:17:46 <gwern> @seen SamB
08:17:47 <lambdabot> SamB is in #xmonad, #perl6 and #haskell. I last heard SamB speak 13h 31m 46s ago.
08:18:04 <Philippa> pjd: not the semicolon?
08:18:05 <quicksilver> setupKeyboardHandler : (Key -> IO ()) -> IO ()
08:18:20 <pjd> Philippa: no, that's implicit sequencing :)
08:18:34 <pjd> Philippa: rather, sequencing of implicit effects
08:18:50 <pjd> as opposed to sequencing of explicit effects, like callbacks/monads
08:18:58 <Philippa> they're not particularly implicit if the statements're assignments and the like
08:19:09 <Philippa> if they're behind a function call, sure
08:19:18 <ejt> y, I can't see your distinction between implicit and explicit there
08:19:52 <pjd> quicksilver: coming from Twisted, the literal translation of d.addCallback(foo) is fmap foo d
08:20:11 <ski> visof : heh, i have that book beside me, atm
08:20:20 * quicksilver goes to look up addCallback
08:20:31 <visof> ski is it good?
08:21:10 <pjd> quicksilver: it's a method of Deferred, which is more or less an IO or Error monad
08:21:50 <quicksilver> I think that's an terrible translation.
08:21:51 <ski> visof : i found it a few days ago at the uni library, have only browsed it a little yet, chapter 3 looks interesting
08:21:52 <marshmallows> Should I write my VM in Haskell?
08:21:58 <quicksilver> addCallback attaches an IO action.
08:21:59 <pjd> quicksilver: YMMV
08:22:04 <quicksilver> fmap attaches a pure function
08:22:06 <Philippa> pjd: this isn't what I think of when someone says 'callback', FWIW
08:22:10 <marshmallows> I'm trying to decide between C and Haskell
08:22:13 <quicksilver> addCallback relates to something which happens "later"
08:22:16 <quicksilver> fmap happens "now"
08:22:23 <quicksilver> I think they are totally, utterlly different
08:22:28 <quicksilver> and only rather distantly related :P
08:22:41 <skorpan> is there any way to convert a String into ByteString?
08:22:46 <quicksilver> skorpan: pack.
08:22:47 <pjd> quicksilver: addCallback adds a function
08:22:50 <Philippa> quicksilver: for rather weird values of 'now'
08:22:58 <quicksilver> Philippa: true enough.
08:23:01 <Philippa> it certainly doesn't have effects the moment it's evaluated
08:23:07 <quicksilver> Philippa: but it's the best "now" we have, in haskell.
08:23:15 <dcoutts_> skorpan: for that kind of question hoogle is great:
08:23:16 <dcoutts_> @hoogle String -> ByteString
08:23:16 <lambdabot> Data.ByteString.Char8.pack :: String -> ByteString
08:23:25 <Philippa> but /not/ the best "now" we have in discussing monadic actions
08:23:37 <Philippa> marshmallows: it depends muchly on what you're doing
08:23:38 <quicksilver> pjd: the example given in http://twistedmatrix.com/projects/core/documentation/howto/defer.html is "printData"
08:23:39 <skorpan> dcoutts_: didn't find it when hoogling in the webbrowser
08:23:41 <pjd> quicksilver: that function can return another Deferred, in which case addCallback joins them (so it's really both fmap and bind), but not returning a Deferred is by far the most common case
08:23:54 <quicksilver> pjd: printData clearly has a side effect, it prints the result
08:24:02 <quicksilver> pjd: so addCallback is being used to attach an IO action
08:24:12 <quicksilver> (which is what I would normally think of as a callback)
08:24:18 <quicksilver> this is different from fmap, though.
08:24:26 <Philippa> pjd: you're refusing to allow Twisted the evaluation/execution separation you allow Haskell
08:24:43 <Philippa> quicksilver, even
08:24:44 <Jedai> marshmallows: Well writing your VM in Haskell should be faster and have less headaches
08:24:57 <Philippa> but the VM will run slower
08:25:00 <marshmallows> headaches is one reason I like haskell :P
08:25:05 <Philippa> you will /not/ achieve the same max performance
08:25:18 <Jedai> marshmallows: But to have the same efficiency would be difficult
08:25:20 <shapr> But you'll be able to do all kinds of cool stuff with your implementation.
08:25:36 <marshmallows> I like the idea of not having to write a GC..
08:25:40 <Jedai> Philippa: You could use Harpy to do a bit of JIT
08:26:06 <Philippa> Jedai: iff you're restricting to x86, no?
08:26:25 <Jedai> Philippa: Right
08:26:27 <Philippa> marshmallows: it may well be worth prototyping in haskell even if you intend to move to C later
08:26:45 <marshmallows> ok
08:26:48 <marshmallows> thanks :)
08:26:55 <marshmallows> I'm going to just write this in Haskell and see what happens\
08:26:55 <roconnor> @go 1 CHF in USD
08:26:56 <lambdabot> 1 Swiss franc = 0.990491 U.S. dollars
08:27:05 <ejt> marshmallows: or even write a haskell program to generate the C from your prototype
08:27:07 <phlpp> @go 1 EUR in USD
08:27:08 <lambdabot> 1 Euro = 1.5594 U.S. dollars
08:27:14 <phlpp> 1.55 o_O
08:27:16 <hallongrottan> @go 1 SEK in USD
08:27:16 <lambdabot> 1 Swedish krona = 0.165196 U.S. dollars
08:27:19 <Jedai> Yes, anyway in the same amount of time you'll have more feature and good efficiency in Haskell than in C
08:27:44 <Philippa> Jedai: ...questionable re "good efficiency", the curve's odd
08:28:12 <Jedai> If you intend to get the best performance, you could wind up rewriting in C, but the prototype would smooth the reimplementation
08:28:24 <Philippa> this is a VM we're talking about, so there's less room for algorithmic improvement than you might expect
08:28:34 <roconnor> @go 1 oz of gold in USD
08:28:36 <lambdabot> http://www.kitco.com/
08:28:36 <lambdabot> Title: Kitco - Gold Precious Metals - Buy Gold Sell Gold, Silver, Platinum - Charts, Gr ...
08:28:43 <roconnor> ah well
08:28:44 <pjd> quicksilver: FWIW, callbacks like printData are pretty atypical
08:29:07 <pjd> it's about the equivalent of trace in Haskell
08:29:18 * quicksilver nods
08:29:30 <quicksilver> but a callback "which does something" must be typical?
08:29:38 <quicksilver> it's got to have some side-effect, or what's the point?
08:30:03 <quicksilver> I mean, I agree with twisted's naming scheme. What they're calling a callback is what I would call a callback.
08:30:13 <pjd> some callbacks have side effects
08:30:16 <quicksilver> An effectful action to be called at a later time, based on some kind of event or timing.
08:30:29 <pjd> but most ones just alter the value as it passes through the chain
08:30:55 <pjd> the concept is exactly the same
08:31:27 <pjd> nah, the way you do stuff like that is by creating a deferred that fires later
08:31:36 <pjd> and add callbacks to that
08:31:42 <quicksilver> yes, exactly.
08:31:56 <quicksilver> the callback is "acn actio to be called at a later time"
08:32:03 <pjd> the Deferred that gets passed around, exactly like you would an IO value
08:32:03 <quicksilver> the "later time" is "when this deferred fires"
08:32:18 <pjd> right, which is a fair description of how IO works :)
08:32:25 <quicksilver> not really
08:32:39 <quicksilver> IO actions don't carry with them their own destiny
08:32:44 <quicksilver> they can be used multiple times or not at all
08:33:01 <Philippa> it sounds to me like a Deferred is like that too
08:33:02 <quicksilver> from that code example it seems to me that a given deferred is going to happen in 3 seconds, unless you reprogram it before then.
08:33:26 <quicksilver> so a particular deferred has an execution strategy in mind (albeit one which you can change by calling methods on it)
08:33:48 <pejo> quicksilver/pjd, what started this discussion?
08:34:16 <pjd> pejo: pedagogy :)
08:34:28 <quicksilver> a discussion of how to explain IO to a newcomer with an imperative background
08:34:37 <quicksilver> pjd finds fmap a useful tool, and likened it to callbacks
08:34:45 <quicksilver> I was a bit surprised since fmap doesn't seem much like callbacks to me.
08:34:58 <Philippa> yeah, this is a weird value of 'callback'
08:35:16 <Philippa> I find fmap useful, but more as a variant of function application here!
08:35:17 <pjd> fmap transforms the result of the IO action when it fires
08:35:28 <Philippa> pjd: which is /not/ what callbacks in general do
08:35:40 <pjd> s/IO/Deferred/ and s/fmap/addCallback/
08:35:48 <pjd> Philippa: it certainly is, in Twisted
08:35:55 <Philippa> Twisted != callbacks in general
08:35:59 <pejo> quicksilver, oh, does this stem from the discussion with wvd earlier?
08:36:03 <quicksilver> pejo: yeah
08:36:14 <quicksilver> although we've strayed pretty far, it remains interesting
08:36:17 <quicksilver> (to me, at least)
08:36:30 <Philippa> "callback" is a long-established term in imperative programming, and Twisted's usage is highly specialised
08:36:50 <pjd> Philippa: i might be a bit biased due to immersion :)
08:36:52 <quicksilver> the twisted callback is an extra IO action which gets chained on when the deferred finally fires.
08:37:01 <Philippa> so you shouldn't say "callback" and expect someone to hear "Twisted callback"
08:37:04 <quicksilver> it can, potentially, act as a filter altering the return value.
08:37:15 <quicksilver> that's the understanding I've gained in the last 15 minutes
08:37:18 <quicksilver> correct me if I'm wrong :)
08:37:26 <Philippa> right, it's part of a callback chain. Used to do that with interrupts back in the day, too
08:37:44 <pjd> quicksilver: most twisted callbacks are probably not IO actions (by which i assume you mean functions with side effects)
08:38:36 <quicksilver> yes, I see that now
08:38:43 <quicksilver> (by reading more of these examples)
08:38:51 <Philippa> pjd: the important bit is the behaviour of "addCallback", not callbacks in general
08:38:56 <quicksilver> callbacks are idiomatically used *only* to filter/transform the result.
08:38:56 <pjd> Philippa: i don't expect someone to hear "Twisted callback";  like you point out, callback chains are really the intuition
08:39:00 <pjd> and they're not uncommon
08:39:07 <Philippa> however, they're not the same as callbacks
08:39:15 <quicksilver> but you did go on to say something about event/gui programming, pjd
08:39:27 <quicksilver> and in event/gui programming the dominant kind of callback is definitely an IO action
08:39:35 <quicksilver> click on this button and that light goes on
08:39:38 <quicksilver> (IO action)
08:39:42 <Philippa> and you don't necessarily get to work with a chain
08:40:00 <Philippa> and if you do, you don't necessarily get to /see/ that it's a chain
08:41:20 <pjd> quicksilver: the analogical thing to a callback returning an IO action, by the way, is when it returns another Deferred
08:41:51 <Philippa> pjd: by this point, you're well into specialised territory when it comes to using it as an example
08:42:20 <pjd> Philippa: sure, this is beyond fmap
08:43:03 <quicksilver> so, I do now understand what you meant.
08:44:32 <quicksilver> But really I think you're referring a particular Twisted isiom
08:44:34 <quicksilver> idiom
08:44:44 <quicksilver> so it coul dbe really handy for explain to other twisted programmers :)
08:44:49 <quicksilver> but perhaps not in general.
08:46:48 <mperillo> hi
08:47:01 <mperillo> are you speaking about Twisted? what a surprise!
08:47:05 <quicksilver> ;)
08:48:00 <mperillo> by the way, what are the patterns use for asynchronous programmin in haskell?
08:49:05 <pjd> quicksilver: the idiom isn't limited to Twisted, though
08:49:28 <pjd> MochiKit (JavaScript library/framework) for example is also based around it
08:49:52 <dozer> mm, I think I get monad transformers now
08:49:59 <dozer> after spending all day fighting with one :)
08:50:32 <quicksilver> pjd: yes, but mochikit's callbacks are almost invariably IO actions.
08:50:40 <quicksilver> and never pure fmap-style transformers.
08:50:49 <quicksilver> they do things like modify the DOM based on the event
08:51:08 <pjd> type-wise, they are fmap-style
08:51:18 <pjd> which is the intuition that matters
08:51:28 <quicksilver> no they're not, because they hide an IO action in the impurity of javascript.
08:51:38 <quicksilver> so they are actually nothing like fmap.
08:51:58 <pjd> so does e.g. trace
08:52:27 * quicksilver shrugs
08:52:30 <pjd> anyway, i'm beating a dead horse :)
08:52:33 <ski> addCallBack :: Foo a -> (a -> IO b) -> Foo b  -- ?
08:52:35 <quicksilver> don't be ridiculous
08:52:48 <quicksilver> people don't use tricks like trace to write real haskell programs
08:52:55 <quicksilver> it's not haskell, and it's a debugging hack, that's all.
08:53:13 <quicksilver> ski: well that's what I'd call a "real callback", yes.
08:53:23 <shapr> @quote
08:53:23 <lambdabot> thetallguy says: Using and advocating Haskell is like being Calvin (and Hobbes). To you, it's alive, real, a true delight. To those who know better, it's a stuffed tiger.
08:53:29 <pjd> ski: it has the type of both fmap and addCallback
08:53:33 <quicksilver> ski: but pjd is arguing that fmap adds a callback.
08:53:39 <pjd> yay dynamic polymorphism
08:53:43 <pjd> err
08:53:43 <shepheb> I can't think of anything more productive to beat, or more productive to do with the dead horse, though.
08:53:46 <pjd> both fmap and bind
08:54:10 <ski> quicksilver : do the added callback need to be able to do IO (or other side-effects) ?
08:54:46 <quicksilver> ski: if you like you can read back 5 pages of text :P
08:54:54 <ski> how about a `Functor' instance for `ReadIORef' .. is that a callback ?
08:55:05 <quicksilver> ski: the breif summary is that there is apparently a common twisted idiom in which the callback doesn't do IO.
08:55:15 <quicksilver> ski: in which case, I agree completely with pjd that that is like fmap.
08:55:18 <ski> (quicksilver : i've looked at it now and then, yes :)
08:55:26 <quicksilver> ski: but then he tried to extend that to Mochikit
08:55:37 <quicksilver> ski: in mochikit callbacks are almost without exception having side-effects
08:55:48 <quicksilver> and I believe the analogy with fmap is now very weak.
08:55:56 <hallongrottan> it's not possible to derive a type, is it=
08:55:57 <hallongrottan> ?
08:55:59 * ski has no idea what `Mochikit' is, btw ..
08:56:17 <ski> hallongrottan : what do you mean ?
08:56:17 <quicksilver> hallongrottan: I'm not realy sure what you mean?
08:56:34 <hallongrottan> ski: let's say i've got type Foo = (Bar, Int)
08:56:45 <hallongrottan> and i want it to be treated in a special way when comparing, for instance
08:56:46 <pjd> ski: it's a browser-side javascripting toolkit
08:56:54 <quicksilver> hallongrottan: you what to make a new type
08:57:00 <quicksilver> hallongrottan: with data most likely (maybe newtype)
08:57:05 <hallongrottan> hmm
08:57:13 <quicksilver> hallongrottan: 2-tuples are not a new type, and you can't change their Ord isntance.
08:57:13 <hallongrottan> havent really figured out how newtypes work
08:57:19 <hallongrottan> quicksilver: i see
08:57:20 <ski> newtype Foo = MkFoo {unFoo :: (Bar,Int)}  -- e.g.
08:57:25 <quicksilver> rule (1) : don't use 'type'
08:57:25 <hallongrottan> hmm
08:57:28 <ski> or simply
08:57:31 <quicksilver> rule (2) : don't use 'newtype'
08:57:36 <quicksilver> I.e. always use data.
08:57:36 <pjd> (quicksilver: i didn't try to extend the argument to MochiKit;  just pointed out that Deferred is not just a Twisted thing)
08:57:40 <quicksilver> it's much simpler :)
08:57:42 <ski> newtype Foo = MkFoo (Bar,Int)  -- if you don't need the selector
08:58:10 * ski uses `newtype' all the time .. more seldom `type'
08:58:37 <pjd> rule (3): don't use type/newtype yet
08:58:38 <pjd> ?
08:58:42 <quicksilver> yeah, I was exagerrating
08:58:43 * quicksilver nods
08:58:53 <quicksilver> my point is that type/newtype cause confusion, and 'data' is a sensible default.
08:59:03 <quicksilver> newtype is mostly just a slight performance hack on data
08:59:09 <quicksilver> although it does have a subtle semantic consequence
08:59:15 <pjd> newtype is useful for newtype deriving, though
08:59:18 <ski> first learn `data', then you can worry about `newtype', yes
08:59:19 <quicksilver> and it unlocks newtype deriving
08:59:21 <quicksilver> right.
08:59:23 <tromp> :t ap const id
08:59:26 <lambdabot> forall a. a -> a
08:59:34 <quicksilver> but as a rule of thumb, if in doubt, use data for all :)
08:59:36 <ski> tromp : yes ?
08:59:57 <tromp> just checking that ski = i :)
09:00:07 * ski = i
09:00:46 <tromp> :t ap
09:00:46 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
09:00:50 <marshmallows> hehe
09:01:22 <pjd> :t (<*>)
09:01:23 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
09:01:36 <tromp> so you can truly say: i am ski
09:01:47 <ski> hehe
09:02:14 <marshmallows> :t ($) `ap` <*>
09:02:15 <lambdabot> parse error on input `<*>'
09:02:19 <marshmallows> :t ($) `ap` (<*>)
09:02:20 <lambdabot>     Occurs check: cannot construct the infinite type:
09:02:20 <lambdabot>       a = (a -> a1) -> a -> b
09:02:20 <lambdabot>     Probable cause: `<*>' is applied to too few arguments
09:02:51 <pjd> @remember <tromp> :t ap const id <ski> tromp : yes ? <tromp> just checking that ski = i :)
09:02:51 <lambdabot> Good to know.
09:04:04 <oerjan> :t ap return undefined
09:04:05 <lambdabot> forall a. a -> a
09:04:28 <thartman> :i ap
09:04:44 <oerjan> no :i in lambdabot
09:05:19 <marshmallows> @hoogle ap
09:05:19 <lambdabot> Control.Monad.ap :: Monad m => m (a -> b) -> m a -> m b
09:05:20 <lambdabot> Prelude.appendFile :: FilePath -> String -> IO ()
09:05:20 <lambdabot> System.IO.appendFile :: FilePath -> String -> IO ()
09:05:50 <oerjan> :t fix (ap return)
09:05:51 <lambdabot> forall a. a -> a
09:07:00 <oerjan> @src -> mfix
09:07:00 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
09:07:17 <marshmallows> :t fix (ap return)
09:07:18 <lambdabot> forall a. a -> a
09:07:23 <oerjan> @src (->) mfix
09:07:23 <lambdabot> mfix f = \ r -> let a = f a r in a
09:07:59 <roconnor> ``LISP is a (broken) version of the untyped lambda calculus, whereas the universe is apparently written in a typed linear calculus. So the universe is more likely written in Clean than LISP.
09:08:30 <marshmallows> O_o lol
09:08:40 <marshmallows> where is this?
09:08:54 <roconnor> http://reddit.com/r/programming/info/6ca01/comments/c03gqy8
09:09:30 <marshmallows> (In what respects is it broken? effects?)
09:10:05 <roconnor> marshmallows: I was thinking about the ``dynamic scoping'' when I said broken, but effects were also in the back of my mind.
09:10:21 <marshmallows> ah ok
09:10:58 <roconnor> I really prefer ``broken alpha-conversion'' to ``dynamic scoping''
09:11:46 <nominolo> but sometimes it's useful!
09:12:02 <roconnor> *L*
09:12:06 <nominolo> call it "automatic environment propagation"
09:12:22 <marshmallows> yes.. I can't think of any languages that aren't broken for some pragmatic reason
09:12:44 <roconnor> and sometimes people's lives are saved by not wearing seatbelts when they are thrown from a burning wreck.
09:12:52 <Philippa> dynamic scoping doesn't count as breakage so long as you're not trying to be eg a lambda calculus
09:13:19 <roconnor> it breaks referential transparency
09:13:32 <Philippa> sure, but that's not an essential property of all possible languages
09:13:48 <Philippa> it's just a useful property - something that can be traded off
09:14:16 <oerjan> roconnor: [citation needed] :)
09:14:20 <roconnor> granted dynamic scoping doesn't reformat your harddrive
09:14:23 <nominolo> roconnor: what about Oleg's (et al) use of type classes to "solve" the configuration problem?
09:14:26 <roconnor> ... actually I bet it could.
09:15:03 <byorgey> @where hs-plugins
09:15:03 <lambdabot> http://code.haskell.org/~dons/code/hs-plugins
09:15:04 <nominolo> roconnor: the problem is when you don't have both dynamic and lexical.  like emacs lisp
09:15:47 <quicksilver> I find dynamic scoping makes it rather hard to reason in a modular way
09:15:55 <nominolo> roconnor: though, really what Oleg is doing is to use the typechecker to automatically add a parameter to each function that needs it
09:15:56 <quicksilver> (even informally)
09:16:18 <quicksilver> perhaps that's just "dynamic scoping used badly" though
09:16:21 <Philippa> *nod*. Typechecker abuse is fun
09:16:27 <roconnor> nominolo: I don't know what Oleg did with typeclasses to solve the configuration problem, and I don't know what it has to do with referential transparency. :(
09:16:30 <quicksilver> of course everything used badly can he a problem.
09:16:38 <Philippa> roconnor: RTFPaper, then?
09:16:50 <nominolo> roconnor: it looks a look like dynamic scoping
09:17:03 <roconnor> nominolo: but haskell is referentially transparent.
09:17:21 <roconnor> I don't see how the class system breaks that.
09:17:23 <Socrates`> Could anyone point me towards a good tutorial or examples of the State monad?
09:17:23 <nominolo> roconnor: then i guess it's some subform of dynamic scoping
09:17:47 <Philippa> roconnor: RTFPaper, it's easier that way
09:19:00 <Philippa> it's a functional pearl by Oleg and CCShan
09:19:08 <roconnor> What is broken is calling a perfectly working function in an empty context, and having it do something different because you happened to use a variable of the same name that formats your hard drive when it is evaluated.
09:19:45 <nominolo> http://okmij.org/ftp/Haskell/types.html#Prepose
09:19:46 <lambdabot> Title: Haskell Programming: Types
09:20:00 <Philippa> roconnor: that's not an empty context, the whole notion of context changes. That's the point.
09:20:04 <Gilly> is there a way to convert starray to regular one so i could get it out of the monad?
09:20:16 <Gilly> i mean like builtin function
09:20:20 <oerjan> @hoogle freeze
09:20:21 <lambdabot> Data.Array.MArray.freeze :: (Ix i, MArray a e m, IArray b e) => a i e -> m (b i e)
09:20:21 <lambdabot> Data.Array.MArray.unsafeFreeze :: (Ix i, MArray a e m, IArray b e) => a i e -> m (b i e)
09:20:26 <pjd> Socrates`: http://www.haskell.org/all_about_monads/html/statemonad.html#example ?
09:20:27 <lambdabot> Title: The State monad, http://tinyurl.com/2g4v8r
09:20:40 <Socrates`> Thanks pjd
09:20:46 <Gilly> oh cool, thanks
09:20:48 <roconnor> Philippa: right, when how my function behaves depends on the context of execution, that is when trouble appears.
09:20:50 <oerjan> Gilly: freeze
09:21:00 <Gilly> yea, i got it :) thank you
09:21:41 <nominolo> roconnor: in Oleg's approach this context is represented by a typeclass
09:21:43 <Philippa> roconnor: but that's also fully intentional. The relevant discipline includes not rebinding stuff to format the HD in the first place - the code that calls you owns you
09:21:52 <Philippa> and we do actually do such things in Haskell
09:21:53 <byorgey> @seen hpaste
09:21:53 <lambdabot> I saw hpaste leaving #haskell 1d 7h 26m 19s ago, and .
09:21:57 <oerjan> Gilly: oh also runSTArray
09:21:58 <pjd> Socrates`: the Haddock docs also have some examples
09:21:58 <byorgey> oh noes!
09:22:00 <Gilly> ah and there's runSTArray too..
09:22:04 <Gilly> i must be blind :)
09:22:06 <Philippa> every time we write code parameterised on the monad it runs in, for example
09:22:08 <marshmallows> Are there some examples of VMs in haskell, I've seen a gameboy emulator but is there others?
09:22:18 <roconnor> nominolo: that doesn't sound like dynamic scoping at all.
09:22:22 <oerjan> Gilly: it's more efficient when you can use it, since it doesn't copy
09:22:42 <byorgey> dcoutts_, dons, or anyone else: any ideas on http://hpaste.org/6439 ?  I've hidden newer versions of Cabal so I'm pretty sure it's using 1.2.3.0
09:22:55 <roconnor> Philippa: how the hell am I supposed to know what variable names I am or am not allowed to use?
09:23:02 <Philippa> marshmallows: a lot of people wrote one for the ICFP contest a couple of years back
09:23:48 <Philippa> roconnor: the principled answer'd be to give you your own namespace for stuff you want to keep hidden and you don't have any say over the rest
09:23:56 <Socrates`> pjd: Where can I find those?
09:23:58 <mperillo> i'm interested in the discussion about twisted deferred model
09:24:07 <Philippa> less principled answers're basically achieving the same effect by convention or process
09:24:15 <pjd> Socrates`: http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-State-Lazy.html
09:24:16 <lambdabot> http://tinyurl.com/2dn8t6
09:24:25 <Socrates`> pjd: Super, thanks again
09:24:45 <ski> roconnor : in `implicit parameters' there's syntactic difference between normal and dynamic variables <http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#implicit-parameters>
09:24:45 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#implicit-parameters>
09:25:00 <roconnor> Philippa: ugh, reminds me of the Barendregt convention.
09:25:02 <pjd> Socrates`: there's a fairly involved tree enumeration example right at the end
09:25:15 <nominolo> roconnor: well, dynamic-extent variables in Common Lisp work pretty much like this, except that they are propagated implicitly
09:25:24 <dcoutts_> byorgey: no you're using the development version of Cabal there
09:25:43 <byorgey> dcoutts_: hmm.  how can I make sure it's using an older version if I have both installed?
09:25:47 <dcoutts_> byorgey: if you run the configure step with -v you'll see that that's the case
09:26:02 <Socrates`> pjd: Handy, I'm working with a tree-like structure
09:26:12 <Socrates`> Looks like the standard example for teaching State
09:26:14 <roconnor> nominolo: unless I'm mistaken, implicit parameters in Haskell cannot be shadowed, and are constrant throught execution of the program.
09:26:31 <byorgey> dcoutts_: ah, you're right
09:26:40 <Philippa> roconnor: if you intend to use the capabilities that dynamic scoping offers, you're going to have to do something. That applies even if you succeed in encoding it in RT form
09:26:42 <dcoutts_> byorgey: cabal does not consider visibility when deciding what packages are available, that only affects ghci and ghc --make. Perhaps it should though, at least as a preference.
09:26:43 <roconnor> .. and maybe I'm mistaken.
09:26:55 <ski> roconnor : implicit parameters can be locally rebound
09:26:55 <nominolo> roconnor: no shadowing? hm
09:26:57 <byorgey> dcoutts_: ah, good to know.
09:27:08 <byorgey> that was never clear to me before.
09:27:15 <quicksilver> implicit parameters at least have fixed type.
09:27:19 <dcoutts_> byorgey: it cannot ignore hidden packages completely or you'd never be able to use the ghc package for example.
09:27:28 <byorgey> right.
09:27:30 <quicksilver> that makes the 'rebinding to erase hard disk' worry less of a worry.
09:27:34 <Philippa> roconnor: there were linear implicit parameters too
09:27:44 <byorgey> dcoutts_: ok, so I guess I'll just add another constraint in the .cabal file
09:27:46 <dcoutts_> byorgey: and if a package specifies a version that is only available hidden then we probably have to pick that version.
09:27:53 <quicksilver> but overall, implicit parameters have not beeng a very successful experiment.
09:28:12 <byorgey> dcoutts_: makes sense.
09:28:59 <dcoutts_> byorgey: but there is certainly an argument to be made that if we have a hidden foo-2.0 and a visible foo-1.0 and a package does specifies merely >= 1.0 then perhaps we should pick the 1.0 rather than the hidden 2.0.
09:29:12 <dcoutts_> byorgey: feel free to file a feature request along those lines.
09:29:19 <quicksilver> iwn 20
09:29:21 <quicksilver> gah!
09:29:24 <byorgey> dcoutts_: ok, I think I will. =)
09:29:28 <ski> quicksilver : though the local rebinding may change the type
09:31:31 <dcoutts_> byorgey: in the mean time, the plugins package needs to be fixed to depend on Cabal >= 1.2 && < 1.3
09:31:46 <byorgey> dcoutts_: ok, I was just about to ask you what version I should put after the <
09:31:49 <dcoutts_> @tell dons the plugins package needs to be fixed to depend on Cabal >= 1.2 && < 1.3
09:31:50 <lambdabot> Consider it noted.
09:32:04 <quicksilver> ski: but that's OK cos you can't then call functions which expect it to have the other type
09:32:07 <quicksilver> ski: (right?)
09:32:07 <byorgey> yep, adding < 1.3 works, it compiles now
09:32:14 <quicksilver> ski: so really it's a different variable then.
09:32:29 <roconnor> Okay, well maybe there is nothing more I can say.  Breaking scoping rules destroys modularity and composability.  I think maintaining locality is one of the most fundamental goals of programing languages, but perhaps I am too dogmatic.
09:32:50 <quicksilver> it is a question of degree
09:32:57 <quicksilver> there is a sense in which putStrLn is dynamically bound
09:32:59 <ski> quicksilver : yes, i think one can think of it like that
09:33:06 <quicksilver> I can link your program against a newer version of the base lib
09:33:13 <quicksilver> in which putStrLn does something totally different :)
09:33:21 <quicksilver> so dynamic binding isn't that different from dynamic linking.
09:33:36 <quicksilver> instinctively, I agree with your instincts though.
09:33:44 <quicksilver> I avoid dynamic scoping like the plague.
09:34:03 <ski> the important thing is to be aware of, and control, the side-effects, imo
09:34:22 <oerjan> dynamic scoping has killed millions of people on three different continents
09:34:35 <ski> (and syntactic cues can help with that)
09:35:22 <roconnor> quicksilver: one day we will fix dynamic linking too. :)
09:36:44 <ski> petnames locally associated with signatures of referents ?
09:37:37 <byorgey> woohoo, I got lambdabot to build! =D
09:38:01 <roconnor> ski: I kinda though that quicksilver was concerned about updated libraries rather than name space collision.
09:38:04 <byorgey> now to figure out why it always says Terminated when I try to use the @run plugin...
09:38:49 <ski> (updated libraries would have different signtures ..)
09:39:20 <roconnor> ski: by signature do you mean a crypto digest?
09:39:27 <ski> yes
09:39:31 <sclv> byorgey: have you tried -fno-schwarzenegger ?
09:39:45 <byorgey> sclv: hahaha
09:39:48 <roconnor> ski: ah okay.  I thought you meant type signature.
09:40:09 <byorgey> I must admit I haven't tried that, thanks =P
09:40:46 <oerjan> @remember byorgey now to figure out why it always says Terminated when I try to use the @run plugin... <sclv> have you tried -fno-schwarzenegger ?
09:40:46 <lambdabot> I will remember.
09:41:07 <ski> @quote
09:41:07 <lambdabot> emertens says: screw ruby on rails, I'm using snakes on a plane
09:41:57 <byorgey> snakes on a plane = django ?
09:42:07 <roconnor> http://r6.ca/blog/20060809T115300Z.html
09:42:07 <lambdabot> Title: Python on Planes
09:42:15 <roconnor> ``I‚Äôm developing a spiffy new web framework in python called Python on Planes. I‚Äôm looking for a spiffy logo to go with it.
09:42:42 <byorgey> oh, hehe
09:43:56 <xd> snakes on a plane
09:44:07 <roconnor> ski: I was thinking of something similar to that.  I was thinking GUIDs instead of digests.
09:44:32 <ski> why `GUID's ?
09:44:39 <roconnor> ski: I guess the difference is between being concerned about accidental collisons vs malicious collisons.
09:45:30 <roconnor> one could assing a GUID to the semantic idea of what a function is intended to do, rather than the intensional definition of the function.
09:45:46 <roconnor> so one could update the same function.
09:46:06 <ski> ok
09:46:13 <roconnor> ... I'm not sure this is as good of an idea as your idea.
09:47:22 <ski> have you seen <https://www.zooko.com/distnames.html> ?
09:47:52 <quicksilver> incidentally, the linux kernel has versioned symbols doesn't it?
09:47:57 <quicksilver> and doesn't glibc ?
09:49:41 <ski> roconnor : also, some threads around <http://srfi.schemers.org/srfi-84/mail-archive/msg00002.html> may be interesting, as well ..
09:50:57 <oerjan> "Humans are incapable of securely storing high-quality cryptographic keys, and they have unacceptable speed and accuracy when performing cryptographic operations. (They are also large, expensive to maintain, difficult to manage, and they pollute the environment. It is astonishing that these devices continue to be manufactured and deployed. But they are sufficiently pervasive that we must design our protocols around their limitations.)"
09:51:22 <roconnor> :D
09:51:56 <sethk> I'm starting a new program that needs parsing.  Is parsec still the "official" combinator parsing library?
09:51:57 <pejo> quicksilver, I'm fairly sure the linux kernel just removes stuff. You don't want to be out of tree with a module.
09:53:05 <pjd> oerjan: but they're so cute
09:53:34 <quicksilver> sethk: I would suggest that parsec, readp and happy are all equally "official"
09:53:37 <oerjan> that is true
09:53:49 <Philippa> sethk: parsec's a lot of people's first call when they look at a language, if that's what you want
09:53:50 <quicksilver> sethk: but nonetheless I'd probably recommend polyparse over any of them
09:53:51 <sclv> parsec is now the best supported one with bytestrings though, no?
09:53:57 <byorgey> especially the cute ones
09:55:26 <sethk> quicksilver, I didn't know about polyparse.  I'll look at it, so that at least I know what it is
09:55:46 <sethk> happy's not combinators, though, I thought
09:56:11 <ski> @where harpy
09:56:11 <lambdabot> http://uebb.cs.tu-berlin.de/harpy/
09:56:54 <quicksilver> yeah, happy's not combinators.
10:00:12 <sclv> is the main advantage of polyparse laziness and space efficiency?
10:01:48 <marshmallows> I think you can use try less htan with Parsec since <|> commutes?
10:01:51 <marshmallows> I might be wrong though
10:02:58 <EvilTerran> ?where polyparse
10:02:58 <lambdabot> http://www.cs.york.ac.uk/fp/polyparse/
10:03:36 <malcolmw> you don't need 'try' at all.
10:08:21 <quicksilver> sclv: <flamebait>the main advantage is that polyparse is not a broken design for combinators
10:08:49 <quicksilver> sclv: more seriously, though, the asymettric <|> makes Parsec non-compositional, which makes it a bit clumsy to use.
10:09:58 <sclv> ok -- so its not performance issues as such but whether or not ppl find parsec's "try" semantics messy.
10:10:15 <EvilTerran> and parsec's "try" semantics are what make it fast
10:10:23 <quicksilver> right. performance is not the argument I was interested in.
10:10:32 <quicksilver> although I believe polyparse also has good semantics.
10:10:45 <quicksilver> I've written many parsers in my life and performance has never been anissue for me
10:10:51 <sethk> I find parsec confusing, but that may be because I'm easily confused.  :)
10:10:53 <quicksilver> (I do understand that it is, for some other use cases)
10:11:08 <sethk> quicksilver, in the thing I'm working on now, performance is not going to be a factor
10:11:46 <taruti> sethk: maybe use ReadP then?
10:12:04 <sethk> taruti, I have some reading to do.  :)
10:12:16 <EvilTerran> i find ReadP provides good practice at making sure your grammar is unambiguous
10:12:27 <EvilTerran> seeing as it lists all possible parses
10:12:49 <sethk> EvilTerran, in a form that's actually useful?
10:13:07 <sclv> does polyparse give all parsec's cuteness for built in lexer functions and symbol tables, and chainl type functionality?
10:13:25 <EvilTerran> sethk, as [(a, String)] - a list of parse results and their trailing characters
10:13:37 <sclv> because that to me would be the other advantage of parsec -- for lots of very common tasks it has much more built in.
10:14:01 <EvilTerran> altho, if you're using ReadP, i'd go for tracking down whoever-it-was's version that isn't restricted to Strings
10:14:18 <EvilTerran> (that really should be in the standard libs instead of ReadP itself, IMO)
10:14:43 <EvilTerran> ?where ParseP
10:14:43 <lambdabot> I know nothing about parsep.
10:14:49 <EvilTerran> ah, thought that'd be worth a shot =/
10:15:05 <malcolmw> sclv: certainly you can write lexer functions in polyparse, although usually it is better to write separate lexers (IMHO)
10:15:32 <sethk> ReadP is a peer of Parsec?
10:15:41 <malcolmw> EvilTerran: parsek
10:15:55 <EvilTerran> ?where parsek
10:15:55 <lambdabot> http://www.cs.chalmers.se/Cs/Research/Functional/MultiLib/koen/Parsek.hs
10:16:26 <EvilTerran> ok
10:16:35 <sethk> I lost the thread, parsek is what?
10:16:49 <taruti> yet another parser combinator library
10:17:26 <sclv> zounds.
10:17:52 <malcolmw> parsek is ReadP, but with a parsec-like API
10:18:29 <dons> ?yow
10:18:30 <lambdabot> CONGRATULATIONS!  Now should I make thinly veiled comments about
10:18:30 <lambdabot> DIGNITY, self-esteem and finding TRUE FUN in your RIGHT VENTRICLE??
10:18:52 * sclv stubbornly maintains that the feature-bang-per-buck of parsec is still head and shoulders above the rest
10:19:36 <sclv> </flamebait>
10:19:53 <Philippa> <quicksilver> sclv: more seriously, though, the asymettric <|> makes Parsec non-compositional, which makes it a bit clumsy to use. <- that's highly debatable, it pretty much boils down to what you mean by 'compositional'
10:19:59 <sclv> see quicksilver, this is what happens when you forget to close a tag!!!
10:20:03 <Peaker> what are you guys parsing?
10:20:06 <Philippa> the left-biased choice is there for reasons other than efficiency
10:20:08 <Peaker> how often do you need to parse?
10:20:30 <sethk> Peaker, I'm building a parser for a software building system I'm working on
10:20:51 <Peaker> sethk, you created a language to describe the target recipes?
10:21:22 <malcolmw> Philippa: what better definition of "compositional" is there, than being able to take two working parsers, glue them together with <|>, and for it still to work.  (Parsec breaks this property)
10:21:41 <quicksilver> Philippa: malcolmw was quicker than me, but that's what I meant.
10:21:50 <sethk> Peaker, well, sort of.  Currently it initialize Haskell record type data structures, and I'm going to parse a more convenient description.
10:21:56 <Philippa> malcolmw: I suspect what you have in mind isn't left-bias but the need for try though
10:22:16 <Peaker> sethk, how come the Haskell one is not convenient?
10:22:29 <Philippa> would you consider l <||> r = try l <|> r to be compositional?
10:22:33 <sclv> <|> is generally biased, no?
10:22:52 <malcolmw> Philippa: true enough
10:22:55 <sethk> Peaker, Many empty initialization statements, which makes it error prone to read.
10:23:26 <sethk> Peaker, in many cases I have 109 lines, only two of which have data
10:23:31 <malcolmw> Philippa: it just seems odd that a major combinator like <|> should be non-compositional
10:23:48 <Philippa> *nod* - try was a big design decision
10:24:07 * EvilTerran tries to work out if he can tie the knot to write a "single-pass" BF interpreter
10:24:14 <Peaker> sethk, can't you use something like  blah{a=1;b=2} ?
10:25:08 <sethk> Peaker, Sure, that's what I do.
10:26:03 <sethk> Peaker, it's a cross compilation system, which adds complexities
10:26:08 <Philippa> FWIW, if we're ever at the same hackathon or something I'd be happy to collab on giving PolyParse the same set of new tricks Parsec's grown
10:28:29 <sethk> quicksilver, the wiki information on polyparse is ... sparse
10:28:35 <quicksilver> that's true
10:28:39 <quicksilver> but malcolmw is here :)
10:29:15 <sethk> quicksilver, ok, that's a good point
10:29:40 <sethk> quicksilver, malcolmw, can you point me to an example implementation in polyparse?
10:29:48 <malcolmw> there is a paper on its design at http://www.cs.york.ac.uk/~malcolm/partialparse.html
10:29:50 <lambdabot> Title: Partial parsing: combining choice with commitment
10:30:09 <dons> http://events.sac-home.org/s-hack/ what's this then?
10:30:11 <lambdabot> Title: S-Hack 2008 ª S-Hack 2008
10:30:13 <malcolmw> contains a running example of an XML parser
10:30:19 <sethk> malcolmw, thanks
10:30:22 <dons> ah "on our functional streaming & data parallel framework"
10:32:39 <sclv> oh, hey, idea! parsec really needs updated and cleaned up documentation to go along with the haddocks, no?
10:32:53 <sclv> this could be something for the guy who wants to write documentation.
10:33:07 <Philippa> yeah, that sounds like a good idea
10:33:44 <esteth> i'm having trouble coming to terms with f = map (2*) being equal to f xs = map (2*) xs
10:34:16 <sclv> esteth: how's that?
10:34:22 <gnuvince> esteth: map (*2) returns a new function.
10:34:36 <svahn> Just look at it like functionrenaming, or something.
10:34:53 <sclv> ok a simple example is say you have a function add
10:35:05 <sclv> and it is of type Int->Int->Int
10:35:11 * shapr 's brain explodes after reading a comonad transformer
10:35:27 <sclv> then "add 1" is of type Int->Int, no?
10:35:40 <esteth> yes
10:35:56 <sclv> so f = add 1 is a function from Int->Int
10:36:04 <sclv> and f x = add 1 x is the same thing.
10:36:11 <sclv> as is f = \x -> add 1 x
10:36:38 <sclv> that's all that's going on in your example above, except the operator sections and the map make it look more confusing.
10:37:06 <esteth> ah, right. Since they are equal, we can write f 3 and it will become add 1 3 because f is literally equal to "add 1" ?
10:37:59 <shapr> Cale: Did you ever write a functional pearl for swing?
10:38:24 <sclv> essentially -- there's some stuff with let-floating and the "dreaded monomorphism restriction" that makes this more complicated in certain cases when you're worried about either performance or certain types of polymorphism.
10:39:01 <esteth> sclv: Ok, thanks :)
10:40:38 <gwern> @seen scook0
10:40:38 <lambdabot> scook0 is in #haskell. I last heard scook0 speak 3h 18m 40s ago.
10:41:45 <gwern> @ask scook0 I happened to mention your curses binding to stefan wehr, and he said 'We haven't made many design choices for HSCurses; it's more or less a literate binding for the underlying C library.'; are your dislikes because of the other modules, like Widget or whatever?
10:41:45 <lambdabot> Consider it noted.
10:48:11 <oerjan> @hoogle receive
10:48:11 <lambdabot> No matches found
10:50:10 <lament> Cale: that datatypes a la carte paper made my head explode :(
10:54:09 <sclv> shapr -- do you have a link to the comonad transformer thing by the way
11:03:29 <shapr> sclv: Don't think it's public yet, should be public by april 2nd at the latest.
11:03:52 <sclv> cool
11:04:20 <dons> Igloo: re bit flags, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/bitset
11:05:15 <Igloo> dons: ta
11:06:03 <sclv> ah, Igloo, just wanted to let you know that the flock package could stand to be slightly better documented -- in particular, noting that a resource exhausted error is thrown when a nonblocking call to lock can't acquire the proper lock.
11:12:44 <dons> ?users #xmonad
11:12:44 <lambdabot> Maximum users seen in #xmonad: 126, currently: 126 (100.0%), active: 7 (5.6%)
11:12:48 <dons> woot :)
11:13:03 <vegai> hey, what am I doing here :P
11:13:10 <dons> vegai!
11:13:17 <vegai> dons!
11:13:26 <newsham> anyone know the URL to the slide deck about video game programming where they encourage using functional techniques?  they have stats in it like how many of the loops are simple folds, etc...
11:13:32 <vegai> ah, now I remember. I saw SPJ last week and got awestruck
11:13:43 <dons> ah, that explains it, vegai
11:14:05 <vegai> I think I'm gonna keep reminding people of this for the next 6 months at least
11:14:13 <NikkiA> newsham, was it something by the naughty dog team by any chance?
11:14:27 <newsham> I dont recall who it was by.  i thought i saved a copy but i cant find it
11:15:11 <newsham> also whats a good lay-paper/blog/whitepaper about why purity is important for impending massively parallel machines?
11:15:24 <NikkiA> naughty dog did release a presentation from a GDC on how they used lisp in jak and daxter a couple of weeks ago, i think that was in a slide format, so might be it
11:16:10 <newsham> this was more of an analysis.. they analyzed the various parts of a game engine in terms of the latency needed, the number of computations,  the kind of code, and what techniques can be used to make them more efficient
11:17:04 <dbueno> What is the quickest way to get an IntMap instance that unwraps a newtype to get an integer key before calling the IntMap function?  Shall I be more concrete?
11:18:18 <desegnis> please
11:18:32 <dbueno> I maintain several Maps from (newtype-wrapped) Ints to other values.  I'd like to be able to use IntMap, but am I going to have to manually write a wrapper function for every map operation I care about, that unwraps the newtype before (e.g.) inserting?
11:19:00 <dbueno> newtype V = V { unV :: Int } -- I use these as keys, but I can't use IntMap, because a V is not an Int.
11:19:03 <benny99> I'm sorry, what was the "this is a multiline definition"-"command" again?
11:19:44 <desegnis> dbueno: You'd have to "manually" unwrap the Ints so you may use them as IntMap keys, yes
11:20:24 <dbueno> desegnis: That's what I was afraid of.  I probably only would have to wrap a few operations, but there are many places that call those operations ... ugh.
11:20:58 <newsham> I think I found it "The Next Mainstream Programming Languages: A Game Developer's Perspective".  grabbing ppt's now to check
11:21:21 <newsham> http://www.cs.princeton.edu/~dpw/popl/06/Tim-POPL.ppt
11:22:18 <therp> newsham: this isn't related to the game semantics thing posted on LTU recently?
11:22:27 <NikkiA> strange, server dns doesn't resolve here...
11:22:44 <pejo> therp, that's a different thread.
11:23:35 <newsham> dont know.  I dont follow LTU.  This did go across LTU in 2006.
11:23:59 <shapr> I used to follow LtU, it was pretty good.
11:24:11 <shapr> hej pejo!
11:24:17 <NikkiA> pdf version is here, btw : http://www.st.cs.uni-sb.de/edu/seminare/2005/advanced-fp/docs/sweeny.pdf
11:24:21 <lambdabot> http://tinyurl.com/7cyhz
11:24:22 <shapr> Oh hey, where's Boegel?
11:24:55 <pejo> Hey shapr! Why did you stop following LtU?
11:25:41 <newsham> so anyone know a good lay paper on purity and concurrency?
11:25:55 <cjb> newsham: such as STM?
11:26:01 <lament> the STM paper
11:26:01 <therp> shapr: I started to use google reader (blog aggregator) recently to track LtU, planet haskell, /. and programming.reddit.com. I found this to be much more easier to follow because it gives you a nice interface of stuff you've already read
11:26:18 <shapr> Yeah, I agree. I used google reader as well.
11:26:40 <shapr> I'm still uncomfortable with data that's not on my own hard drives though.
11:26:41 <NikkiA> i stopped using google reader recently (when the exploit was announced) :)
11:26:43 <lament> newsham: http://research.microsoft.com/Users/simonpj/papers/stm/beautiful.pdf
11:26:44 <lambdabot> http://tinyurl.com/2hyrxp
11:27:01 <newsham> cjb: something less specific than STM though.
11:27:08 <shapr> pejo: Life got busy, and I saw too much of Achilleas on LtU.
11:27:27 <shapr> Also, the sort of articles that were showing up on LtU didn't interest me.
11:27:30 <newsham> Beautiful Concurrency might work..
11:27:32 <pejo> shapr, I haven't seen much of him lately. You should come back. :-)
11:27:46 <shapr> Fortunately, I got hold of a copy of Coq'Art yesterday... That should keep me busy for a few weeks.
11:27:56 <therp> oh coqart
11:28:16 <lament> newsham: that's STM though
11:28:51 <shapr> pejo: Nowadays I have lots of in-person interaction opportunities of LtU quality. I live in the same town with people like cjb, edwardk, Felleisen, Shivers, etc
11:29:45 <skorpan> is there any way to make my main program import B, which imports C and make my main program still have access to C?
11:29:55 <therp> btw does anyone know how much $ the authors of such highly specialized books see from publishers like Springer? I incidentally found a pdf of a springer book, I was about to purchase. but after I read the letter from knuth (http://www-cs-faculty.stanford.edu/~knuth/joalet.pdf) about commercial publisher I'm not so sure whether I'm going to print that book by myself
11:29:56 <pejo> shapr, oh, neu (?) has a quite prominent pl group.
11:30:02 <benny99> are 'nested wheres' not possible ?
11:30:13 <shapr> yup, I work a few blocks away from NEU.
11:30:34 <astrolabe> skorpan: import C into A aswell?
11:30:40 <therp> s/whether/whether I should be the book or print it myself/
11:30:59 <skorpan> astrolabe: yes, so there is no other way, right?
11:31:05 <pejo> therp, that letter is about increasing prices of journals though.
11:31:18 <shapr> therp: I'll be surprised if the authors get any amount of money from Spring, but I still follow the laws. I figure I can't expect people to follow my source licenses unless I follow their licenses.
11:31:25 <newsham> lament: *nod*
11:31:26 <quicksilver> skorpan: tell B to export C
11:31:28 <astrolabe> skorpan: you can export the relevant bits of C from B.
11:31:40 <therp> pejo: I know still it makes me feel less guilty of not buying books from Springer (next to that it's much quicker to print and bind it myself)
11:31:44 <skorpan> oh
11:32:34 <therp> shapr: yeah, that's a moral issue for me too, as I would like to see much more people obeying copyright (simply because this would make free software much more attractive)
11:33:25 <benny99> anybody ?
11:33:43 <dons> benny99: sure,  they're fine
11:33:56 <dons> let x = y where y = z where z = 2
11:34:25 <Gnezdo> Does anybody know how to deal with haddock2's error: module `main:Main' is defined in multiple files: ...
11:34:40 <Gnezdo> Surely I have a bunch of Main's
11:35:05 <shapr> therp: I totally agree.
11:35:12 <benny99> dons: ok, guess my problem is somewhere else :(, I might paste my code? it's tiny
11:35:29 <shapr> therp: I don't buy music from the riaa/mpaa and I don't read research papers that cost money.
11:35:44 <dons> ?patse
11:35:44 <dons> ?paste <--
11:35:46 <lambdabot> Haskell pastebin: http://hpaste.org/new
11:35:46 <lambdabot> Haskell pastebin: http://hpaste.org/new
11:35:48 <dons> ?bot!
11:35:48 <lambdabot> Missing argument. Check @help <vote-cmd> for info.
11:35:59 <shapr> I just bought another six months worth of hosting for hpaste, btw.
11:36:15 <newsham> http://www.eecs.berkeley.edu/Pubs/TechRpts/2006/EECS-2006-183.html
11:36:16 <lambdabot> Title: The Landscape of Parallel Computing Research: A View from Berkeley | EECS at UC  ..., http://tinyurl.com/2v7slf
11:36:18 <dons> glguy: ^
11:36:24 <therp> shapr: full ack :) @music, internet radio is much more convenient (amarok has a huge list of radio stations for all tastes)
11:36:25 <benny99> dons: http://hpaste.org/6443
11:36:28 <quicksilver> shapr: yay :)
11:36:29 <dons> glguy's written hpaste 2.0.
11:36:43 <shapr> Cool, is it running on hpaste.org yet?
11:36:50 <benny99> glguy: thanks ;)
11:37:03 <dons> shapr: nope, but let's do that.
11:37:07 <dons> i'll talk to glguy
11:37:16 <benny99> dons: some wrong indention, but haskell-mode does not find it :(
11:37:26 <benny99> dons: using ghci
11:37:32 <sclv> there are still eventually the migration of old paste issues, unless he's tackled that already?
11:38:30 <quicksilver> benny99: indentation looks ok in that paste to me
11:38:37 <quicksilver> benny99: are you using real tabs in teh source?
11:38:40 <quicksilver> that could break it
11:39:00 <quicksilver> benny99: OH
11:39:06 <quicksilver> benny99: problem isn't indentation
11:39:10 <quicksilver> benny99: it's missing else clause :P
11:39:30 <benny99> quicksilver: oh, I *must* have an else-clause ?
11:39:37 <benny99> makes sense :D
11:39:42 <benny99> damn
11:39:46 <quicksilver> well what value woudl you expect it to return
11:39:49 <quicksilver> (in the else case)
11:39:52 <quicksilver> expressions must have values...
11:39:54 <glguy> undefined!
11:39:58 <quicksilver> glguy: shuddup :P
11:40:07 <lament> heh, D. Friedman joined LtU two days ago
11:40:08 <glguy> :-o
11:40:15 <lament> probably once shapr left, he decided it was safe to go in
11:40:46 <Gilly> do we have a function for converting Chars to digits (Ints)? like '1' -> 1
11:41:13 <quicksilver> :t digitToInt
11:41:14 <lambdabot> Char -> Int
11:41:29 <benny99> quicksilver: yep, thous I said "that makes sense"
11:41:32 <Gilly> ah, thanks :)
11:42:10 <benny99> quicksilver: but I guess my approach is stupid then :(
11:42:13 <shapr> lament: Am I so dangerous?
11:42:23 <lament> shapr: clearly!
11:42:33 <shapr> In that case, I'm coming to your house!
11:42:39 <Mr_Awesome> > digitToInt 'a'
11:42:40 <lambdabot>  10
11:42:49 <Mr_Awesome> :)
11:43:00 <Mr_Awesome> > digitToInt 'g'
11:43:00 <lambdabot>  Exception: Char.digitToInt: not a digit 'g'
11:43:18 <Mr_Awesome> > digitToInt 'f'
11:43:19 <lambdabot>  15
11:43:23 <Mr_Awesome> hex only, i see
11:43:49 <benny99> quicksilver: nope, wait.. don't boher, sorry
11:43:57 <lament> shapr: oh no! But my house is probably boring if you're not into playing music. Still, you could teach me to unicycle.
11:44:37 <shapr> I am into playing music.
11:44:53 <cjb> what kind of music do you both play?
11:45:00 <lament> shapr: really, what instruments?
11:45:16 <shapr> I play guitar and drums with much enthusiasm and little skill.
11:45:21 * NikkiA plays synth, guitar and bass, too :P
11:45:29 * cjb guitar.
11:45:32 <lament> cjb: lots of stuff, there's like 30 instruments in the house
11:45:41 <cjb> I guess we can add to the list:  Haskell coders are vegetarian, Go-playing guitarists.
11:45:46 <shapr> I need to buy a guitar, I haven't played since I moved to Boston.
11:45:58 <shapr> I've only played Go once.
11:46:25 <vegai> piano here :)
11:46:34 <quicksilver> cjb: unicycling?
11:46:34 <NikkiA> cjb, i guess that disqualifies me, i'm not veggie and i don't play go :/
11:46:55 * NikkiA skulks back to the ML languages :)
11:46:55 <mrd> i can't play an instrument to save my life
11:47:28 <lament> i want to play with other people more. I need to join a band or something.
11:47:31 <shapr> mrd: doesn't require skill, just enthusiasm ;-)
11:47:42 <lament> shapr: right.... just like unicycling :)
11:47:43 <mrd> i would probably get kicked out of the Pretty Terrible Orchestra
11:47:53 <cjb> mrd: for being too good?  :)
11:48:03 <cjb> it seems like they should embrace you wholeheartedly!
11:48:25 <shapr> lament: The difference being that low quality guitar playing will usually not cause broken bones (unless you persist around unappreciative people).
11:48:31 <cjb> http://www.bbc.co.uk/dna/h2g2/A676163
11:48:32 <lambdabot> Title: BBC - h2g2 - The Not Terribly Good Club of Great Britain
11:49:02 <cjb> (oh, please, Segovia didn't use a plectrum.  ridiculous.)
11:50:17 <lament> that's the point :)
11:52:44 <benny99> shapr: you appear to play guitar as I do :p
11:53:09 <shapr> I sing with equal enthusiasm, but a bit more skill.
11:53:09 * cjb plays guitar kinda clumsily -- http://www.youtube.com/watch?v=r9YIhLtMmQ4
11:53:15 <lambdabot> Title: YouTube - Fantasie in D Minor, Weiss
11:53:36 <lament> no sound at work :(
11:53:52 <gwern> @seen dons
11:53:52 <lambdabot> dons is in #xmonad, #haskell-soc and #haskell. I last heard dons speak 6m 11s ago.
11:54:38 <gwern> dons: would you be terribly troubled if hmp3 stopped using its own curses binding and began using hscurses?
11:54:43 <benny99> cjb: :/ that's great
11:54:56 <cjb> benny99: not to Proper Guitarists :)
11:55:01 <benny99> cjb: damn :(
11:55:15 <lament> cjb: do you just play classical?
11:55:26 <cjb> lament: yeah, lately
11:55:50 <cjb> benny99: notice about half the comments are negative :)
11:56:05 <benny99> cjb: that's great for a youtube-video
11:56:05 <ivant> cjb, nice playing
11:56:14 <benny99> cjb: I wish I could play that well
11:56:15 <cjb> yeah, I like youtube a lot
11:56:17 <benny99> good
11:56:29 <benny99> cjb: I meant the comments
11:56:33 <cjb> before youtube, people would have these hundreds-of-dollars sheet music collections, and would learn from them
11:56:35 <ivant> cjb, are the sheets for this piece are in public domain, available somewhere?
11:56:45 <benny99> cjb: yeah :) ?
11:56:57 <dons> gwern: yes. i would be troubled
11:57:09 <cjb> benny99: and youtube and tab sites change it a lot -- I use youtube to look at the fingering other people use
11:57:18 <cjb> it makes it *so* much easier to learn pieces
11:57:22 <gwern> dons: oh. may I ask why?
11:57:23 <dons> gwern: and i won't accept patches for that. if anything, i'd go the other way and move hmp3's nano curses binding into its own lib
11:57:40 <ivant> cjb, I like to come up with weird fingerings :-)
11:57:47 <dons> a lot of time was spent getting hmp3's curses binding to be backwards compat with ocurses and irix curseds
11:57:50 <benny99> cjb: yep :) -- anyway any tabs ?
11:57:53 <dons> it uses the strict subset that is portable
11:57:58 <cjb> I think I got it from the delcamp.net site
11:58:00 <dons> that information is super valuable
11:58:03 <cjb> it's a web forum, free to register, and has a PDF archive
11:58:06 <cjb> of scores
11:58:27 <gwern> dons: people are actually using hmp3/ghc/etc on Irix?
11:58:40 <quicksilver> dons: gosh. IRIX compatibility. Now that's something not many people take the time to worry about ;)
11:58:45 <benny99> cjb: thanks :) (though we should rather talk about that stuff in #haskell-blah)
11:58:47 <cjb> (for an example of what the commentors didn't like -- my fingers fly around a lot, but it's not because the piece is hard, it's because I kinda have no idea where they're going)
11:59:04 <cjb> like a martial artist who does these flourishy moves that actually waste a lot of energy
11:59:15 <ivant> cjb, thanks for the pointer
11:59:45 <dons> gwern: i have, yes. and i know you like to break portability to shrink cabal files, but i don't :)
11:59:48 <gwern> ocurses is openBSD's curses binding, I'd guess
11:59:56 <dons> no.
11:59:59 <dons> its another one.
12:00:18 <dons> anyway, hmp3 works. hscurses is unsatisfactory -- that's why i wrote a new curses binding for hmp3
12:00:48 <gwern> '-- attrs dont work with Irix curses.h. This should be fixed' <-- so hmp3's binding works, except when it doesn't
12:01:30 <dons> gwern: they do work.
12:01:40 <dons> what do you think happens when attrs aren't found?
12:02:00 <dons> anyway, there are better battles to fight that needlessly breaking hmp3
12:02:15 <gwern> dons: hey, I didn't write that - presumably you did
12:02:32 <dons> i did. and i'm suggesting that you're misinterpreting the comment
12:02:47 <dons> it means it defaults to 2-colour mode on irix.
12:02:59 <dons> since bold/underline etc attrs aren't supported
12:05:03 <shapr> Ya know, unit testing is a lot harder in the imperative side of life.
12:05:27 * shapr misses QuickCheck very much.
12:06:27 <quicksilver> shapr: create haskell images of your core data types, create haskell code which unsafePerformIO wraps your C# code
12:06:31 <quicksilver> shapr: then use quickcheck
12:06:32 <quicksilver> :)
12:06:55 <shapr> quicksilver: I considered that, but the C# FFI is quite painful.
12:07:24 * quicksilver knows nothing about the C# FFI. Not a jot. Not even whether it exists.
12:07:29 <quicksilver> so I'll take your word for it :)
12:07:42 <ToRA> mmm, there was a thesis i read this morning about a C# / haskell bridge...could use that?
12:07:50 <shapr> The pain might still be worthwhile .
12:07:52 <shapr> ToRA: whaat??
12:08:02 <ToRA> 1 sec, see if i can dig it out
12:08:04 * shapr boings excitedly
12:08:24 <quicksilver> I wouldn't get too excited.
12:08:26 <quicksilver> He said 'thesis'
12:08:30 <quicksilver> that means it's research-ware
12:08:40 <shapr> Better than writing my own...
12:08:52 <shapr> That is, if the source is usable for commercial purposes.
12:08:55 <quicksilver> it either never-ran, or it depends on the unreleased custom hackery of some long departed RA from the author's alma mater
12:09:06 <quicksilver> 'paperware'
12:09:17 <shapr> I hope not :-(
12:09:35 <shapr> I have had years of experience with paperware though. QuickCheckM comes to mind.
12:09:48 <quicksilver> well, look, if I've reduced your expectations, then you can only be pleasantly surprised, right?
12:09:51 <quicksilver> :)
12:09:57 <ToRA> mmm, i seem to have wiped the email - iirc it was linked on one of chak's emails to ghc-users
12:10:08 * shapr cries
12:10:25 * shapr hits google with a big stick
12:10:29 <dcoutts_> dons: you'll be pleased to know that executable stripping will go into Cabal-1.4
12:10:38 * dcoutts_ records a patch to do just that...
12:11:50 <dcoutts_> dons: the trade off is that hackage will start warning when you use ghc-options: -optl-Wl,-s
12:12:03 <dcoutts_> and eventually it'll reject that completely
12:17:23 <_andre> hello. i have ghc installed in my home dir (--prefix=$HOME/local). do i need any special flag when installing a cabal package for it to be installed in the correct place?
12:17:36 <mauke> no
12:17:45 <mauke> well, depends on which correct place you want
12:17:53 <ToRA> shapr: http://www.haskell.org/pipermail/haskell-cafe/2008-March/040682.html
12:17:54 <lambdabot> Title: [Haskell-cafe] type families, fun deps, lattices imposed on/by types, http://tinyurl.com/33pmec
12:18:02 <ToRA> right at the bottom is the link to the thesis
12:18:14 <_andre> i'm trying to install the LDAP package but it's trying to install stuff in /usr/local/share/doc
12:18:35 <mauke> oh, right. you still need to specify the prefix for each package
12:18:42 <dcoutts_> _andre: use --user --prefix=$HOME/.cabal, or use cabal-install which does that by default.
12:19:03 <mauke> --user shouldn't be necessary if ghc lives in his ~, right?
12:19:05 <kolmodin> mnislaih: hia, you probably want to write your _darcs/prefs/author again in your copy of cabal
12:19:15 <dcoutts_> mauke: I guess so
12:19:22 <kolmodin> mnislaih: it has some junk in it
12:19:24 <_andre> ok, lemme try that
12:19:30 <shapr> ToRA: thanks!
12:19:40 <mnislaih> hi lennart, yes it does, I'll be resending later
12:20:37 <mnislaih> it is annoying that this happened, probably because of some readline problem in my system
12:21:00 <kolmodin> maybe so
12:21:00 <_andre> worked, thanks :)
12:21:23 <mnislaih> but as I made some changes on duncan's advice this afternoon, I have to resend anyway
12:21:28 <_andre> i thought it would try to install it together with the other cabal stuff that comes with ghc
12:21:30 <kolmodin> ah, ok
12:22:43 <dcoutts_> _andre: cabal never install where ghc is installed, it does exactly the same as autoconf/automake does and defaults to a global installation in /usr/local
12:23:16 <_andre> i see
12:23:32 <dcoutts_> _andre: the new cabal version also supports a convenient user install which goes in $HOME/.cabal
12:24:09 <dcoutts_> _andre: but you're using probably the version where you must specify the --user and --prefix separately
12:27:57 <safedave> Hi.  Sorry if this has been covered elsewhere, but I'm a newbie and not sure if I'm doing a thorough enough search.......is there a binary distro of GHC that works on a Mac PPC running Mac OS Leopard?  If not, is there another Haskell compiler that would work in this configuration?
12:28:49 <haraldk> I don't know, but it used to be a lot of hassle, at least
12:28:58 <skorpan> hassle with haskell!
12:30:09 <cjb> safedave: someone posted this question to haskell-cafe in the last few days, if I recall?
12:30:27 <safedave> Thanks, cjb.  I'll take a look there.
12:32:24 <pejo> safedave, I think Christian Maeder sent a patch to ghc-users for getting ghc to build on leopard/ppc.
12:32:50 <cjb> safedave: found it:  http://thread.gmane.org/gmane.comp.lang.haskell.cafe/37687
12:32:51 <lambdabot> Title: Gmane Loom
12:33:00 <safedave> Thank you!
12:33:20 <shapr> Ok, now I just have to figure out how to contact Andrew Appleyard...
12:33:23 <shapr> @seen ozone
12:33:23 <lambdabot> I haven't seen ozone.
12:33:27 <shapr> hmm
12:33:49 <cjb> shapr: perhaps Bertie Bananatree knows where to find him
12:34:30 <shapr> :-P
12:34:35 <shapr> @seen chillix
12:34:35 <lambdabot> I saw chillix leaving #ghc and #haskell 7h 50m 13s ago, and .
12:34:39 <shapr> bah
12:35:10 <shapr> humbug
12:35:35 <shapr> The author of this .net <-> Haskell bridge is not easily found, nor is his binding, namely "Salsa"
12:35:47 <haraldk> You can use the dot dot notation for your enum-deriving datatypes, right?
12:36:05 <mauke> haraldk: sure
12:37:16 <haraldk> It's been a while... I just forgot to surround the .. with spaces nicely
12:41:46 <dcoutts_> mnislaih: I'm pushing a couple changes, I don't think the'll conflict with your patches, but you might want to pull before sending your changes to the list
12:41:54 <dcoutts_> just to be sure
12:41:59 <mnislaih> sure, np
12:43:27 <dcoutts_> mnislaih: I've held off adding a new flag to control executable stripping 'til after your changes go in
12:43:38 <mnislaih> thanks
12:44:01 * dcoutts_ pushes exe stripping patch but without the configure flag to turn it on/off
12:44:40 <laura85> re ^^
12:45:17 <Frederick> folks is haskell the craft of functional programming a good book?
12:45:35 <shapr> Frederick: it's pretty good.
12:45:41 <laura85> Frederick, i think: yes
12:45:53 <Frederick> any better suggestion for a start?
12:45:57 <shapr> Frederick: But you may want to check out The Haskell School of Expression instead.
12:46:11 <dcoutts_> Frederick: I recommend "Programming in Haskell" as the best intro book
12:46:12 <laura85> Frederick, (i've got a copy). there's also wikibooks Haskell, which is free ^^
12:46:24 <shapr> I wish "Real World Haskell" were ready!
12:46:26 * fophillips has The Haskell Road
12:47:06 <dcoutts_> Frederick: I wrote a review of "Programming in Haskell" for The Monad.Reader which you may like to read
12:47:13 <Frederick> I need a hands on book I know the theory of functional programming I need a crash course more coding less talking which is better for me?
12:48:03 <orzo> i want to make an function return itself as part of a pair with other data all within IO.  I get an error "Occurs check: cannot construct infinite type"
12:48:10 <orzo> is there anyway to do what i want?
12:48:20 <mauke> yes, use a data type
12:48:32 <dcoutts_> Frederick: hmm, well Programming in Haskell starts with the real basics and doesn't really get into advanced topics, but it's also pretty short, covering the material it does in the quickest time.
12:48:36 <orzo> so i just need to explicitly make the type, and it will work?
12:48:51 <mauke> you'll have to manually wrap/unwrap
12:49:18 <orzo> I dont understand
12:49:25 <dcoutts_> Frederick: you can read my review for more details which also includes a comparison with the other major books
12:49:41 <lament> realworldhaskell!
12:50:16 <mauke> data Omg = C (Omg -> Omg)
12:50:25 <Frederick> point is a ihave cathegory theory and semantics class this semester I will need some functional language knowledge
12:50:35 <mauke> foo (C f) = Omg (foo . f)
12:50:37 <roconnor> orzo: mauke means that you will have to manually wrap (apply a constructor) and unwrap (pattern match on a constructor) when manipulating your new data type.  But this is what you expect.
12:51:38 <roconnor> orzo: http://r6.ca/blog/20060919T084800Z.html is a simple example
12:51:38 <lambdabot> Title: Y Combinator in Haskell
12:51:50 <roconnor> newtype Mu a = Roll { unroll :: Mu a -> a }
12:52:09 <roconnor> think of Roll and unroll as Wrap and unwrap
12:52:42 <wli> Mitchell uses up/dn
12:52:47 <olsner> data Roll = Rick Roll | Duck Roll | Barrel Roll :P
12:53:33 <roconnor> we wanted a type where b = b -> a, but that is an infinite type (... -> a) -> a) -> a.
12:53:55 <roconnor> but Mu a is isomorphic to (Mu a) -> a
12:54:12 <roconnor> the Roll and unroll functiosn provide this isomorphism
12:54:34 <roconnor> and being isomorphic is good enough for most purposes.
12:54:51 <b_jonas> rocconnor: I did some similar wrapping in http://www.math.bme.hu/~ambrus/pu/olvashato/t2n.sml
12:57:24 <mornfall> Anyone can think of an easy way to lazily generate powersets?
12:58:02 <mrd> > filterM (const [False ..]) [1..]
12:58:03 <lambdabot>  Exception: stack overflow
12:58:05 <mrd> blah
12:58:13 <mrd> actually that does read the whole list doesn't it
12:58:20 <Jaak> > filterM (const [False, True]) [1..]
12:58:21 <lambdabot>  Exception: stack overflow
12:58:23 <sethk> mornfall, pay somebody else to write it ... :)
12:58:28 <Jaak> double bah :P
12:58:30 <mornfall> : - )
12:58:38 <mrd> > [False ..]
12:58:38 <lambdabot>  [False,True]
12:58:43 <Jaak> aah
12:58:46 <Jaak> ofc
13:00:03 <roconnor> mornfall: I wrote one once
13:00:31 <trez> > [True ..]
13:00:32 <lambdabot>  [True]
13:01:07 <oklofok> @die 1d2
13:01:07 <lambdabot> 1d2 => 1
13:01:30 <roconnor> let p l=[]:do{(n,x)<-zip[0..]l;map(x:)$take (2^n)$p l}  in p [1..
13:01:32 <roconnor> let p l=[]:do{(n,x)<-zip[0..]l;map(x:)$take (2^n)$p l}  in p [1..]
13:01:34 <dons> "Congratulations!
13:01:35 <dons> Your organization "haskell.org" has been accepted in to the Google
13:01:35 <roconnor> > let p l=[]:do{(n,x)<-zip[0..]l;map(x:)$take (2^n)$p l}  in p [1..]
13:01:35 <dons> Summer of Code(tm) 2008"
13:01:36 <lambdabot>  [[],[1],[2],[2,1],[3],[3,1],[3,2],[3,2,1],[4],[4,1],[4,2],[4,2,1],[4,3],[4,3...
13:01:37 <dons> woot!
13:01:40 <dons> malcolmw: !!!
13:01:49 <byorgey> =D
13:01:50 <trez> nice
13:01:54 <skorpan> hey trez
13:01:57 <skorpan> how's the project coming?
13:02:05 <mornfall> roconnor: Ick... : - )
13:02:19 <malcolmw> dons: oh cool
13:02:22 <roconnor> mornfall: I was trying to make it in the fewest characters possible :(
13:02:28 <roconnor> http://www.bushong.net/dave/comparisons/powerset.html
13:02:29 <lambdabot> Title: Programming Comparisons: Power Set
13:02:34 <malcolmw> dons: I'd forgotten the notification was due
13:02:39 <trez> skorpan: all fine, just a lack of inspiration at the moment but going strong :)
13:02:47 <trez> skorpan: and for you?
13:02:49 <skorpan> trez: what was it that you were making, btw?
13:03:04 <trez> a embedded language for a calendar
13:03:14 <skorpan> well, mine is coming along just fine i guess, it's just that the embedded language part (doing board games) isn't very big compared to the chess example
13:03:17 <skorpan> oh
13:03:26 <mornfall> roconnor: Thanks, looks good...
13:03:31 <skorpan> trez: what are the features then?
13:12:26 <fophillips> Any ideas <http://hpaste.org/6449>?
13:13:38 <Toxaris> fophillips: ghx --make bikes.hs ?
13:13:44 <Toxaris> fophillips: hmm, ghc of course
13:14:41 <olsner> fophillips: if you want it runnable as an executable, you have to add -main-is Bikes, and you need a definition of main
13:14:57 <lament> bikes!
13:16:37 <olsner> lament: bikes indeed!
13:17:48 <sethk> Haskell people can't spell separator
13:19:53 <dons> ?spell separator
13:19:59 <dons> oh, not this bot
13:20:15 <sethk> dons, found it misspelled in three places this morning.  :)
13:20:19 <inimino> but they can spell 'intercalate'
13:20:26 <sethk> I'm not finding Parsec, does that mean I need to get it from hackage?
13:20:45 <mauke> Text.ParserCombinators.Parsec?
13:21:01 <sethk> right, found that part in the docs
13:21:05 <olsner> can't properly intercalate separators from intercalators from all the intercalating
13:21:28 <sethk> mauke, and as far as I can tell I didn't fat finger it.
13:22:02 <sethk> parsec is listed on hackage, I'll try getting it
13:31:46 <mnislaih> dcoutts_:  I have to run, darcs sending now
13:33:05 <dcoutts_> mnislaih: great, thanks!
13:33:49 <mnislaih> dcoutts_: I secretly sneaked a BoolOpt constructor in OptDescr, fyi
13:34:22 <mnislaih> it turns out it is needed to support fields like 'library-profiling = True'
13:34:40 <dcoutts_> mnislaih: ok
13:34:54 <oklofok> @die 1d2
13:34:54 <lambdabot> 1d2 => 2
13:35:09 <Saizan> dcoutts_: re moving sdist to cabal-install, do we want to also keep it in Cabal at least for 1.4 so we don't break the UserHooks api or we don't care?
13:35:50 <dcoutts_> Saizan: we should keep the stuff in Cabal too for the time being
13:36:03 <MarcWeber> Can someone tell me how this type within an instance declaration is to be read or where I can find the documentation? http://rafb.net/p/YmRcE487.html
13:36:04 <lambdabot> Title: Nopaste - No description
13:36:14 <dcoutts_> Saizan: anyway, there's not much we'd remove since at least the code to prepare the image dir would stay in the Cabal lib
13:37:08 <Saizan> dcoutts_: ok, but cabal-install sdist should run the potential user-customized hooks?
13:37:08 <mauke> looks like associated types
13:37:25 <dcoutts_> Saizan: we'd probably only be removing the command line UI for the sdist code and possibly the top level sdist function that sequences the phases of preparing a tarball
13:37:34 <dcoutts_> Saizan: no, it can ignore them
13:38:00 <tibbe> dcoutts: what's the nick of your student? I'm really curious about the unicode stuff
13:38:20 <dcoutts_> Saizan: it can call directly into the Cabal lib to do what it needs without going via the command line ./setup interface
13:38:36 <Saizan> dcoutts_: perfect
13:38:48 <dcoutts_> Saizan: though it will need to pass that LocalBuildInfo since we need that to be able to run preprocessors
13:38:53 <dcoutts_> tibbe: sioraiocht
13:39:33 <Saizan> dcoutts_: there's a cabal function to read that, it doesn't seem a problem
13:40:36 <dcoutts_> Saizan: yes, though there would be a problem if the package required an older cabal version since then it'd use an older format for the dist/setup-config and we'd not be able to read it
13:40:43 <sioraiocht> tibbe: give me a week, i;m finish up exams :)
13:40:45 <sioraiocht> *finishing
13:41:09 <tibbe> sioraiocht: didn't mean to rush you in any way
13:41:17 <cjb> Has anyone considered maintaining a page of useful future Haskell projects?
13:41:22 <tibbe> sioraiocht: I'm just curious
13:41:24 <sioraiocht> tibbe: I know, hehe.  That's why you haven't heard anything, though.
13:41:30 <cjb> ie. libraries that do not yet have Haskell bindings, applications not yet written
13:41:39 <sioraiocht> I will be happy to keep you up to date/discuss it with you soon, though
13:42:18 <tibbe> sioraiocht: that's fine, it's just that I'd be happy to provide some early feedback when the design is still malleable.
13:42:25 <tibbe> sioraiocht: great
13:42:29 <sioraiocht> tibbe: certainly
13:43:07 <tibbe> sioraiocht: before you get top attached to any one solution ;) not saying I have any deep insights or anything
13:43:23 <sioraiocht> tibbe: i welcome any input, though. seriously
13:43:26 <Saizan> dcoutts_: ah, right, to solve that we'd need to create the directory with the older version and then create the archive with cabal-install
13:43:53 <tibbe> sioraiocht: great
13:44:15 <EvilTerran> ?src Cont
13:44:15 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
13:44:37 * EvilTerran notes that he should be using the builtin Cont monad rather then (effectively) rolling his own
13:44:42 <dcoutts_> Saizan: right, but we cannot actually do that because there's no way to get the older cabal to prepare the dir without also running tar which may not exist
13:45:26 <dcoutts_> Saizan: so probably the thing to do is just read the saved config and if it fails then pass Nothing to prepareTree
13:45:40 <dcoutts_> Saizan: and warn
13:45:44 <Saizan> dcoutts_: ok
13:46:05 <dcoutts_> Saizan: we don't need to worry too much about that kind of issue
13:46:35 <Saizan> dcoutts_: i used unsafeInterleaveIO in the tar code to avoid keeping all the files open at the start, because readFile is not enough lazy, is that a problem?
13:46:36 <Gilly> if i use show with an integer does it convert it lazily?
13:47:22 <dons> > show (2^1000)
13:47:26 <lambdabot>  "107150860718626732094842504906000181056140481170553360744375038837035105112...
13:47:40 <dons> > show (2^1000000000000000)
13:47:43 <dcoutts_> Saizan: you could but I don't see that it's necessary, you can just interleave the reading and writing, no?
13:47:46 <lambdabot> Terminated
13:47:59 <Gilly> i guess no then :P
13:48:38 <dcoutts_> Saizan: open a temp file, then one by one, read the src files and write out their headers and content to the tarfile, then at the end, rename the temp to the target
13:48:53 <glguy> Do I file this bug under rhythmbox or selinux-policy-targeted?
13:49:45 <Saizan> dcoutts_: well not just rename, i'd have to reread it and use compress then
13:49:50 <glguy> whoops
13:50:02 <dons> chan err
13:50:28 <dcoutts_> Saizan: oh, I see, right.
13:51:20 <dcoutts_> Saizan: where as if you used unsafeInterleaveIO then you could 'read' all the files upfront, make the output lazy bytestring in pure code and then write out and compress in one go, and only then would the src files get opened and read.
13:51:34 <dcoutts_> Saizan: if the code's cleaner that way, do it, it's ok to use unsafeInterleaveIO.
13:51:56 <EvilTerran> woo, my BF interpreter works
13:52:13 <dcoutts_> EvilTerran: great what's next? LOLCODE?
13:52:15 <EvilTerran> but it seems to be awfully strict... i'm not getting any output 'til it has all the input
13:52:42 <Saizan> dcoutts_: ok :)
13:53:03 <lispy> if I have foo :: a -> (forall b. b) -> c, does the forall in that position behave as existential or universal?
13:53:30 <dcoutts_> EvilTerran: kolmodin and I were talking about writing a LOLCODE interpreter in the style of an operational semantics specification and writing it up for The Monad.Reader including how to model the IO behaviour
13:53:49 <RayNbow> does anyone know of a function namer variant of http://www.classnamer.com/ ?
13:53:50 <lambdabot> Title: ClassNamer
13:53:54 <EvilTerran> !paste
13:53:55 <RayNbow> I need one for my Haskell code :p
13:54:03 <EvilTerran> hm.
13:54:09 <EvilTerran> http://hpaste.org/6450
13:54:24 <cjb> there, started:  http://haskell.org/haskellwiki/Potential_projects
13:54:25 <lambdabot> Title: Potential projects - HaskellWiki
13:54:30 <cjb> ^ please add stuff!
13:55:02 <EvilTerran> (if anyone wants to take a look)
13:55:47 <dozer> Is there a function that looks like "[Maybe a] -> Maybe a" and returns the first Just in the list, or Nothing if there is no Just?
13:55:55 <dcoutts_> EvilTerran: ah, so output is a continuation
13:56:02 <EvilTerran> dozer, listToMaybe . catMaybes?
13:56:03 <byorgey> dozer: mplus
13:56:19 <EvilTerran> > msum [Nothing, Just 1, Nothing, Just 2]
13:56:20 <lambdabot>  Just 1
13:56:21 <byorgey> dozer: er, I mean, msum
13:56:26 <EvilTerran> > mconcat [Nothing, Just 1, Nothing, Just 2]
13:56:26 <lambdabot>  Add a type signature
13:56:29 <EvilTerran> hm.
13:56:49 <EvilTerran> dcoutts_, well, the continuations i'm more worried about are the ones i tied a knot in to make it look single-pass
13:56:56 <dozer> dho! so obvious now you mention it
13:57:04 <byorgey> EvilTerran: Maybe isn't an instance of Monoid by default, since there are several sensible instances.
13:57:21 <EvilTerran> i think it is, actually, just it needs a monoid instance on the parameter as well
13:57:27 <EvilTerran> > mconcat [Nothing, Just [1], Nothing, Just [2,3]]
13:57:28 <lambdabot>  Just [1,2,3]
13:57:43 <byorgey> EvilTerran: oh, interesting, I didn't know that
13:57:50 <byorgey> well, that's one of the sensible instances =)
13:58:04 <EvilTerran> there's also ones for newtypes called (iirc) First and Last
13:58:12 <byorgey> right, that's what I was thinking of
13:58:46 <EvilTerran> dcoutts_, the output being a prepender was just so it came out in the right order :P
13:59:16 <EvilTerran> i'm thinking i could possibly make the whole thing neater by using Control.Monad.Cont, tbh
14:00:22 <lispy> ?hoogle [Maybe a] -> Maybe a
14:00:23 <lambdabot> No matches, try a more general search
14:00:39 * lispy is surprised hoogle didn't find anything
14:00:52 <EvilTerran> it doesn't specialise methods to instances, iirc
14:01:02 <dcoutts_> EvilTerran: well, maybe. Certainly the interpreter might work better as a continuation monad, eg the output issue
14:02:35 <EvilTerran> i'm quite pleased with thinking of tying the knot to get the continuation associated with [s available when parsing the matching ]s
14:05:25 <lispy> :t asTypeOf
14:05:26 <lambdabot> forall a. a -> a -> a
14:05:39 <lispy> > 1 `asTypeOf` 'a'
14:05:39 <lambdabot>   add an instance declaration for (Num Char)
14:06:10 <lispy> > 1 `asTypeOf` 1.0
14:06:10 <lambdabot>  1.0
14:06:30 <lispy> I always find that function to be weird.
14:08:04 <cjb> dons: ping
14:08:25 <Twey> > asTypeOf 2.0 1
14:08:26 <lambdabot>  2.0
14:08:32 <Twey> > asTypeOf 1 2.0
14:08:33 <lambdabot>  1.0
14:08:42 <Twey> Huh?
14:08:47 <cjb> dons: well, I should just ask.  Do you think someting like http://haskell.org/haskellwiki/Potential_projects already exists?  If not, should I try mailing it out to haskell-cafe etc?  Is there anything else that should be there?
14:08:49 <Twey> Oh
14:08:51 <lambdabot> Title: Potential projects - HaskellWiki
14:08:53 <Twey> Converted
14:09:07 <unenough> this is how monads were explained to me
14:09:17 <lispy> Twey: yeah, when a type is ambiguous you can give the type checker a hint, that's probably how to think of that
14:09:48 * Twey nods.
14:10:03 <lispy> are there ways to simulate lexically scope type variables in H98?
14:10:25 <unenough> tell me if it's accurate: main is a constant function that returns something that represents all the side-effects that should occur. the individual side effects are combined using monads so that you end up with one "object" that describes the correct order for them to be applied
14:12:45 <Baughn> unenough: True enough, though it's more "is" than "returns"
14:13:06 <unenough> Baughn: ok that's how Peaker explained it to me :)
14:13:07 <DRMacIver> Hm. Stupid question about the paterson conditions. a) says "No type variable has more occurences in the assertion than in the head". But with -XFlexibleInstances declarations of the form instance (Foo a) => Foo (a -> a) seem to be kosher.
14:13:17 <Baughn> unenough: ..that's how I explained it to peaker. >_>
14:13:24 <unenough> :)
14:13:30 <DRMacIver> So does the restriction just mean that no type variable appears in the assertion that doesn't appear in the head?
14:13:57 <EvilTerran> DRMacIver, there, a only appears once in the assertion, and twice in the head...
14:14:06 * DRMacIver blinks
14:14:14 <DRMacIver> Yes. I'm being an idiot. Don't mind me...
14:14:18 * EvilTerran pokes DRMacIver :D
14:15:21 <EvilTerran> the point is that the typechecker works from things it needs to satisfy (eg an instance head) to the conditions necessary to satisfy them (eg an instance context/assertion/whatever)
14:15:36 <EvilTerran> the coverage condition means that each step of this makes the problem smaller, so it's guaranteed to terminat
14:16:14 <DRMacIver> Hm. The coverage condition only seems to be about functional dependencies?
14:16:20 <EvilTerran> noo
14:16:40 <Heffalump> I thought it was
14:16:44 <EvilTerran> it's what you quoted above, plus some more stuff to the same effect
14:16:50 <EvilTerran> i think...
14:16:56 <DRMacIver> I'm looking at: http://haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#instance-decls
14:16:59 <lambdabot> Title: 8.6. Class and instances declarations, http://tinyurl.com/3ym44d
14:17:28 <fophillips> Haskell + Graphviz = sex in network form
14:17:53 <unenough> apropos graphviz, you must see what I did :)
14:18:18 <unenough> (the begginings of) a true GUI for dot
14:19:43 <DRMacIver> ok. So the condition *does* seem to prohibit instance declarations like (Foo (a, a)) => Foo [a]. So things work like I expected. I was just getting myself into a muddle. :)
14:19:47 <DRMacIver> Thanks
14:20:04 <EvilTerran> indeed
14:20:19 <EvilTerran> the problem with something like that one is if you wrote something like "instance Foo (a,a) => Foo a"
14:20:27 <unenough> http://www.youtube.com/watch?v=RT87JfTYIvo
14:20:28 <lambdabot> Title: YouTube - GraphUI
14:20:43 <EvilTerran> because it'd start trying to prove Foo a, then Foo (a,a), then Foo ((a,a),(a,a)), then foo (((a,a),(a,a)),((a,a),(a,a))) ...
14:20:51 <DRMacIver> Right
14:23:00 <unenough> fophillips: did you see that?
14:23:40 <fophillips> I haven't yet clicked on the link
14:24:01 <fophillips> I just made a quite interesting fractal pattern with co-totients and twopi
14:24:27 * unenough won't even ask what co-totients is
14:24:51 <fophillips> That is very cool/
14:24:54 <fophillips> s / .
14:25:01 <unenough> yes it is :)
14:25:14 <unenough> if only i had the time to re-write it so it actually becomes useful
14:25:50 <unenough> the keyboard control especially, makes it so much easier to very very quickly build diagrams
14:26:10 <fophillips> If you had shown it to me 6 months ago when I was doing my decision maths course I would have kissed you.
14:26:17 <fophillips> But, alas, it is not to be.
14:26:30 <unenough> you had to do many graphs?
14:26:38 <fophillips> Loads.
14:26:41 <unenough> you can always take the course again
14:26:51 <fophillips> Could do.
14:27:12 <fophillips> Although I have rather a lot on my maths plate at the moment.
14:27:21 <unenough> well it's not in practical state right now anyway, it needs a total rewrite
14:28:01 <fophillips> What would also be useful is to be able to apply popular algorithms to the graphs.
14:28:49 <unenough> that was the next step :)
14:29:04 <unenough> I have a friend who is going to do a doctorate in graph theory
14:29:22 <fophillips> Ooh.
14:29:24 <kpreid> unenough: saw your question a couple days ago on #darcs. you can't in general get only the most recent condition, but you can use darcs get --partial to skip everything before a checkpoint (if the source repository has one)
14:29:42 <benny99> @seen cjb
14:29:42 <lambdabot> cjb is in #haskell. I last heard cjb speak 20m 55s ago.
14:30:00 <unenough> kpreid, thanks i figured that already. it was still very slow
14:30:12 <cjb> benny99: Hi.
14:30:24 <unenough> fophillips: http://code.google.com/p/enough/wiki/Graphui has some more outdated info and pics
14:30:25 <lambdabot> Title: Graphui - enough - Google Code
14:30:36 <benny99> cjb: hi :)
14:30:47 <benny99> cjb: did you recieve my private message?
14:33:06 <benny99> cjb: if there's not time to bother with that question, it doesn't matter
14:33:36 <fophillips> unenough: I might have considered helping, if I had ever used Python :)
14:34:04 <unenough> fophillips if I will REALLY have time, i'll learn haskell a lot and do it in haskell
14:34:16 <unenough> but that will take a few months
14:34:38 <fophillips> :)
14:35:00 <sethk> what's the syntax for setting one field of a record type?  (xyz rtype) extracts the field xyz.  How  do I set it?
14:35:12 <EvilTerran> rtype{xyz= ...}
14:35:14 <kpreid> sethk: rtype {xyz = 9 }
14:35:22 <sethk> kpreid, thanks
14:35:35 <sethk> EvilTerran, thanks
14:35:47 <cjb> benny99: No, I didn't receive it.
14:35:53 <cjb> benny99: Perhaps you aren't registered on freenode?
14:35:54 <orzo> Not in scope: type constructor or class `ForiegnPtr'  -- i don't understand.  I imported Foreign.ForeignPtr, doesn't that put it in scope?
14:35:58 <benny99> cjb: I am :)
14:36:02 <cjb> benny99: It's a requirement for sending private messages.  Oh.. weird.
14:36:09 <sethk> didn't realize I can use that syntax to set only part of it.
14:36:13 <cjb> Try sending it again, maybe?
14:36:44 <kpreid> orzo: in "import Foo.Bar" Bar is a module name, which has nothing to do with the type names the module exports
14:37:05 <benny99> cjb: I asked you to join #haskell-blah -- and whether you could tell me "How to start to learn to play classical guitar"
14:37:06 <oerjan> orzo: did you spell it like that?
14:37:28 <Synth-c> tussen x = x>=1 && x<=6
14:37:34 <Synth-c> @type tussen x = x>=1 && x<=6
14:37:35 <lambdabot> parse error on input `='
14:37:36 <orzo> pasted from my code: "import Foreign.ForeignPtr"
14:38:02 <oerjan> orzo: i mean in the other use
14:38:10 <oerjan> `ForiegnPtr'
14:38:45 <orzo> ah, there was one typo
14:38:57 <sethk> kpreid, EvilTerran, I'm doing something wrong.  I've done this, which the compiler doesn't like (in the let section):  ldef = haskellDef                 ldef { reservedNames = ["package", "version"] }
14:39:14 <orzo> ie, ei, tomayto/tomahto :P
14:39:36 <kpreid> sethk: I can't tell without knowing the types, but maybe you want haskellDef (ldef { ... }) ?
14:39:43 <benny99> cjb: *how to best
14:39:51 <sethk> kpreid, type is in Parsec.Language.  I'll try that
14:40:13 <oerjan> Synth-c: inRange (1,6)
14:40:18 <oerjan> :t inRange (1,6)
14:40:21 <lambdabot> forall t. (Ix t, Num t) => t -> Bool
14:41:24 <lispy> anyone know when HW 2008 submission deadline happens?
14:41:31 <lispy> I see that ICFP is 2008
14:41:31 <Toxaris> sethk: maybe like this: ldef = haskellDef { reservedNames = ... }
14:41:38 <lispy> er April 2, 2008
14:42:08 <sethk> Toxaris, the compiler accepts that.  hopefully it does what we think it does.  thanks
14:42:24 <benny99> cjb: (I'm not completely new to the guitar, but to classical)
14:42:35 <Toxaris> sethk: that means: let ldef be a copy of haskellDef with the reservedNames component changed to ...
14:43:07 <dozer> mm - I am setting up a tic-tac-toe game
14:43:13 <dozer> the play function takes 2 players
14:43:35 <dozer> they should really be monadic functions to allow them to store personal state, ask the user for input etc.
14:43:44 <dozer> but they need seperated monads
14:44:09 <cjb> benny99: Oh, interesting.  I guess I recommend searching youtube for beginning classical guitar lessons (pretty sure there are some), and then the delcamp.net forums
14:44:54 <benny99> cjb: ok, thanks :)
14:47:30 <benny99> cjb: (I just tried to figure out something classical to play something without tabs -- I know what you were talking about now)
14:48:53 <dmwit> Haskell is pretty beautiful.
14:49:29 * benny99 agrees
14:49:34 <unenough> what triggered that?
14:49:56 <dmwit> "Find the sum of digits in the numerator of the 100th convergent of the continued fraction for e." -- problem description
14:50:18 <dmwit> problem 65  = digitalSum . numerator . fractionFromList . take 100 $ fractionListForE -- problem solution
14:50:52 <Gilly> projecteuler? :)
14:50:55 <dmwit> There's such a close match between the words of the problem and the tokens in the solution it's scary.
14:50:58 <dmwit> Gilly: yep =)
14:51:16 <Gilly> been doin those too today :) rated 47% now :P
14:51:24 <dmwit> Yow!  Nice work. =)
14:51:48 <Gilly> well, most of them are rather trivial :P
14:52:04 <Gilly> or, to this point they've been, gettin harder though
14:52:40 <dmwit> I skipped around a bit.
14:52:56 <dmwit> tried some of the later ones... they can get quite tough to solve in <60s!
14:53:06 <Gilly> well, i've done some of the later ones too :)
14:53:21 <malcolmw> lispy: end of June
14:53:30 <dmwit> Have you gotten any of the ones that use "minimize n/phi(n)" in their description?
14:53:42 <dmwit> Those are always *way* slow for me...
14:53:59 <Gilly> not sure...
14:54:44 <malcolmw> lispy: http://haskell.org/haskell-symposium/2008/
14:54:46 <lambdabot> Title: Haskell Symposium 2008
14:54:56 <Gilly> i've done 69
14:55:02 <Gilly> Find the value of n <= 1,000,000 for which n/?(n) is a maximum.
14:55:19 <dmwit> Wow.
14:55:35 <Gilly> also 70 :)
14:55:39 <dmwit> I can't even compute n/phi(n) for each n < 100,000 in under 60s.
14:55:40 <Gilly> Find the value of n, 1 < n < 107, for which ?(n) is a permutation of n and the ratio n/?(n) produces a minimum.
14:55:46 <dmwit> There must be a better way.
14:55:58 <Gilly> how are you computing phi?
14:55:59 <malcolmw> haskell.org has been accepted as a mentoring organisation for google summer of code, yay
14:56:19 <dmwit> countDivisors = product . map ((+1) . length) . group . factor
14:57:02 <Gilly> you know, phi(n) = (p_1 - 1)*p_1^(\alpha_1 - 1)*(p_2 - 1)*p_2`(\alpha_2 - 1)* ... * (p_n - 1)*p_n^(\alpha_n - 1) where p_i are the prime divisors of n and \alpha_i are their exponents
14:57:06 <unenough> malcolmw: are there mayn students that know haskell?
14:57:15 <unenough> (i will be one, soon)
14:57:23 <dmwit> Gilly: Right, that's essentially what countDivisors there does.  (Right?)
14:57:40 <malcolmw> unenough: over a hundred student proposals last year
14:58:08 <unenough> wow
14:58:10 <dmwit> Gilly: Although that actually calculates n - phi, it's basically the same idea.
14:58:12 <Gilly> ah
14:58:27 <Gilly> i should've read it more carefully... maybe your factoring function is the problem then?
14:58:38 <dmwit> That is entirely possible. =P
14:58:49 <dmwit> My factor function is totally naive.
15:00:03 <dmwit> Gilly: http://hpaste.org/6454
15:00:18 <dmwit> It just iterates through the primes, looking for ones that divide n.
15:00:51 <dmwit> I wonder what happens if I change (n < x) to (n < x * x).
15:00:55 * dmwit tests
15:01:30 <monochrom> There is much overlap between pointfree programming and component programming.
15:01:33 <Gilly> ah you gotta be careful with it but that's where your problem is :)
15:02:36 <Gilly> basically my factor function looks for primes in the range [2..(sqrt i)] (not calculating sqrt though) and finds the smallest divisor, divides as long as it's possible and does the same again
15:02:54 <Gilly> anyways, i noticed my problem 69 is written in C and it's really fast :P
15:03:02 <dmwit> ah
15:03:17 <dmwit> Well, that's cheating, C has access to the GMP.
15:03:18 <dmwit> =)
15:03:25 <Gilly> heh, didn't use that :)
15:03:38 <Gilly> but in that case we can use floating point arithmetic too and use a different formula for phi
15:05:17 <Gilly> ./69 > log  0.08s user 0.00s system 99% cpu 0.084 total
15:05:22 <Gilly> so that's how fast you can make it :P
15:05:51 <dmwit> yikes!
15:09:37 <dmwit> Well, that change makes it a lot faster, but it's still two minutes to map countDivisors [1..1000000]. =/
15:09:45 <dmwit> Oh well.
15:10:35 <Gilly> i'd suggest using phi(n) = n \prod_{p|n} (1 - 1/p) for this one
15:11:00 <dmwit> I tested it, the time is almost identical.
15:11:30 <Gilly> hm, it's supposed to be done at the same time you are generating your primes :)
15:11:40 <Gilly> using erast sieve
15:12:01 <dmwit> Oh, interesting.
15:12:02 <Gilly> well, it's not so elegant in haskell as in C :P
15:12:16 <dmwit> yeah
15:12:35 <dmwit> Any prime algorithm that uses the word "sieve" is pretty much doomed in Haskell.
15:13:06 <Gilly> though, maybe you can mod it to get the same performance in haskell too, while keeping it elegant :)
15:13:35 <dons> bit sieves are pretty elegant in haskell (STU arrays)
15:13:40 <dons> and very performant
15:13:52 <dmwit> Oh no, phi n /= n - countDivisors n
15:13:55 <dmwit> D=
15:15:42 <int-e> problem 69 is a pen and paper problem.
15:16:16 <dmwit> I was thinking that, but I like programming. =)
15:16:54 <oerjan> if phi(n) = n \prod_{p|n} (1 - 1/p)  then n/phi(n) = \prod_{p|n} 1/(1 - 1/p), surely...
15:18:50 <Gilly> int-e: that's right too *g*
15:18:57 <NikkiA> stupid question, but is there any way to 'replace' a particular index in a list, other than (take n source) : newItem : (drop n+1 source), it seems pointless writing that whenever i need to do it, if there is already a 'standard' way
15:19:19 <dmwit> NikkiA: No, there's no standard way.
15:19:34 <dmwit> NikkiA: Usually, needing to do that is a sign that there's something wrong with your design.
15:20:33 <bd_> if you need to do that a lot, you might be better off with a diffarray or something
15:21:15 <Gilly> anyways, good night folks :)
15:21:24 <byorgey> or an IntMap?
15:22:12 <byorgey> NikkiA: lists are good for keeping things in a particular order.  they are not particularly good for storing an association between integer indices and items.  if you want to do the latter, you should use a different data structure, like Data.Map.
15:23:00 <quicksilver> a Sequence is quite good if you need a list which you often splice
15:23:12 <quicksilver> i.e. replace elements but especially insert/delete subsequences
15:23:35 <oerjan> @let primes = nubBy (((>1).).gcd) [2..]
15:23:36 <lambdabot> Defined.
15:23:50 <oerjan> > scanl (*) 1 primes
15:23:51 <lambdabot>  [1,2,6,30,210,2310,30030,510510,9699690,223092870,6469693230,200560490130,74...
15:23:59 <dmwit> Right.
15:24:00 <dozer> is there a MaybeT monad transformer?
15:24:18 <dolio> @hackage maybet
15:24:20 <bd_> http://www.haskell.org/haskellwiki/New_monads/MaybeT
15:24:20 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/maybet
15:24:20 <lambdabot> Title: New monads/MaybeT - HaskellWiki
15:24:21 <oerjan> if i'm thinking right, the number is 510510.
15:24:26 <dmwit> oerjan: Correct.
15:24:27 <dozer> ah, thx
15:24:55 <bd_> now, why isn't that in the mtl? :/
15:25:11 <dons> mtl doesn't have an active maintainer
15:26:35 <dozer> http://hpaste.org/6460
15:27:08 <dozer> I want to wrap up the players in this so that they can run in some monad e.g. IO or State
15:28:38 <dozer> so (Token -> Board a -> CellIX) would become something like (Token -> Board a -> m CellIX)
15:32:39 <oerjan> dozer: something like play :: (IArray a Cell, Monad m) => (Token -> Board a -> m CellIX) -> (Token -> Board a -> m CellIX) -> m (Maybe (Either (CellIX, Token, Board a) (Token, Board a)))
15:33:09 <oerjan> unless you mean m to replace some of Maybe and Either as well
15:33:30 <dozer> I mean something like you said - Maybe and Either need to stay in place rather than be hidden
15:33:52 <dozer> the problem is.. say player 1 is stateful, and player 2 is stateful
15:34:00 <oerjan> actually it looks like Token and Board a are part of the state?
15:34:20 <dozer> then we need to get the 'statefull' result for player 1's next move but not update the state used for player 2
15:34:28 <oerjan> dozer: you probably would give each of them a field in the combined state
15:34:57 <dozer> and perhaps player 1 is using IO to get moves (e.g. from a human on the terminal) and player 2 is a stateful bot
15:35:40 <oerjan> dozer: combining monads like that usually means making a larger monad that contains the needs of both, afaiu
15:37:59 <tromp> maybe Either can be a dual monad transformer
15:38:15 <oerjan> tromp: hm?
15:38:48 <tromp> oops, no, that doesn't work
15:39:23 <tromp> you need a pair for the state, but can use Either for the actions
15:40:15 <tromp> in combinatorial game theory, the 2 players are often called Left and Right
15:40:52 <oerjan> :t let mirror = either Right Left in mirror
15:40:53 <lambdabot> forall a a1. Either a a1 -> Either a1 a
15:43:11 <Toxaris> maybe players could specify *monad transformers* they want to use instead of monads
15:43:44 <dozer> mm, and run in MaybeT (player1T (player2T)) ?
15:45:15 <Toxaris> yeah something like this
15:45:44 <Toxaris> but I don't think that works without first-class classes
15:48:23 <laura85> good night everyone ^^
15:48:27 <edwardk> hrm would xmap :: (a -> b) -> (b -> a) -> (f a -> f b) most appropriately by viewed as a bifunctor from Hask x Hask^op -> Hask? or something else?
15:50:15 <edwardk> it looks a lot like Hom(-,-)
15:50:18 <oerjan> it reminds me of that newtype deriving bug mentioned yesterday, it looks like exactly the kind of function that would have to exist for a class involving uses of f to have sane newtype deriving...
15:50:21 <mib_v2einmiv> how can i do a benchmark test on two haskell script to see which is faster?
15:51:07 <oerjan> (that's my guess anyhow)
15:51:14 <edwardk> oerjan: its the sort of engine that powers my example from the other day, i'm just looking for firmer category theory roots for it =)
15:51:34 <ddarius> xmap is a dinatural transformation roughly between Hom(-,=)xHom(=,-) -> Hom(F-,F=)
15:51:41 <oerjan> edwardk: well you had a name in there, something Sheafs
15:52:17 <oerjan> (two names actually, i googled)
15:52:28 <edwardk> oerjan: FegarasSheard, which was a reference to the kind of exponential catamorphism it lets me use, but its not the right term for the functor/transformation/whatever that it is
15:52:43 <Toxaris> dozer: the problem is that player2 can't use (player1T (player2T ...)) without knowing player1T
15:53:17 <dozer> Toxaris: right, and we can't have player2 using (player2T (player1T)) very easily
15:53:34 <dozer> or can we?
15:53:59 <oerjan> actually perhaps some forall use could do it?
15:54:11 <oerjan> player2 can just apply the lift for player1T
15:54:36 <edwardk> ddarius: hrmm. i can see the signature S : C^op x C -> X  easily enough and yeah I know I can derive the second functor just by playing the whole thing in reverse. so ok, i'll take that =)
15:54:38 <oerjan> which follows from some forall t. MonadTrans t => context i think
15:54:53 <Toxaris> oerjan, dozer: player1T's lift could be applied by play?
15:55:12 <oerjan> and player2 could use player2T m by having a forall m. Monad m => context
15:55:32 <oerjan> Toxaris: hm that's true
15:55:53 <mib_v2einmiv> hey guys :how can i do a benchmark test on two haskell script to see which is faster?
15:56:02 <ddarius> edwardk: You may want to look at (co)ends.
15:56:17 <edwardk> ddarius: so would it be most appropriate to say its the definition for one of the two functors that make up the dinatural transformation then?
15:56:21 <cjb> mib_v2einmiv: running Unix?  Why not the "time" command?
15:56:35 <cjb> time ./prog1; time ./prog2
15:56:35 <oerjan> Toxaris: that doesn't solve the other way though, it seems an arbitrary underlying monad must be allowed
15:56:41 <nominolo> hm, is co-co-nut == nut?
15:57:20 <edwardk> fishing out my copy of categories for the working mathematician =)
15:57:49 <oerjan> nominolo: uld be
15:57:56 <Toxaris> oerjan: would that be a problem?
15:58:16 <oerjan> Toxaris: not if you can use forall m. Monad m =>
15:58:22 <Toxaris> I wonder what would happen to player2 if player1 includes ListT or similiar
15:58:35 <nominolo> also, i want a Cocomonad
15:59:33 <nominolo> proposed operations: ">=<" and "reunit"
16:00:18 <edwardk> nominolo: class Monad m => Cocomonad m; instance Monad m => Cocomonad m;    -- done =)
16:00:23 <ddarius> edwardk: Polymorphic functions are natural transformations, except when they are not.  When a type variable (functor parameter) occurs both covariantly and contravariantly a dinatural, rather than a natural, transformation must be used.
16:00:45 <nominolo> edwardk: that requires overlapping instances!
16:01:04 <edwardk> nominolo: well you didn't say you wanted your Cocomonad to be haskell 98 now did you? =)
16:01:27 <nominolo> you got me there
16:01:56 * byorgey wants a Cocoamonad
16:02:10 <edwardk> ddarius: ok, then what would and end of that dinatural transformation look like? i'll admit thats about where my category theory gets fuzzy.
16:03:03 <nominolo> byorgey: that's called "IO"
16:03:13 <unenough> fophillips, if you're interested i've created a downloadable version
16:04:05 <fophillips> unenough: If you give me the link I'll try it out tomorrow.
16:04:15 <unenough> http://enough.googlecode.com/files/graphui488.tar.gz
16:04:22 <ddarius> edwardk: You take (co)ends of bifunctors of the form CxC^op -> D, it just that that dinatural transformation looks similar to some particular theorems related to indexed (co)limits and (co)ends.
16:04:23 <unenough> fophillips: you'll need python and pygame
16:04:27 <fophillips> Thanks
16:04:44 <unenough> i hope it will actually work for you :) (it does here)
16:04:49 <edwardk> basically a particular instance of this would look like data Lam a = Lam (a -> a) | App a a; with an instance Foo f where xmap f g (Lam k) = Lam (f . k . g); xmap f g (App a b) = App (f a) (f b)
16:05:11 <edwardk> where Foo is whatever the appropriate name of this typeclass that i've been using for 6 months without appropriately naming =)
16:06:00 <ddarius> In general if you are working with type variables that occur positively and negatively you want to look at dinatural transformations and those readily lead to (co)ends.
16:06:07 <orzo> The last statement in a 'do' construct must be an expression
16:06:14 <orzo> this is probably stupid, but i don't see the problem with the code
16:06:24 <nominolo> orzo: paste
16:06:39 <lispy> orzo: usually means you need a 'return'
16:06:43 <nominolo> orzo: do you have an if- in the code?
16:07:09 <orzo> yes i do have an if
16:07:19 <orzo> just before the error
16:07:21 <edwardk> ok, so syntactically since the dinatural stuff is usually expressed C^op x C -> X, would it be more 'correct' if the arguments were swapped leading to (b -> a) -> (a -> b) -> (f a -> f b) ?
16:07:24 <ddarius> Categories for the Working Mathematician somewhat covers this, Basic Concepts of Enriched Category Theory has a good discussion of dinatural transformations and (co)ends as well as another online CT text.  I have an article that brutally introduces one to various results related to indexed (co)limits and (co)ends.
16:07:39 <orzo> let (a,b) = if c then d else e
16:07:43 <nominolo> orzo: the then and else must be indented
16:07:48 <nominolo> relative to the if
16:07:51 <orzo> i put them one one line
16:07:59 <ddarius> edwardk: The argument order isn't important.
16:08:00 <orzo> if then and else all
16:08:13 <nominolo> orzo: can you please paste your code?
16:08:26 <nominolo> http://hpaste.org/new
16:08:29 <edwardk> ddarius: i kinda figured, just wanted to make sure. the main argument for the other order is it makes deriving an instance of this method from fmap slightly lighter syntactically ;0
16:08:49 <fophillips> unenough: "No modules named twisted.internet"
16:08:55 <orzo> http://hpaste.org/6464
16:08:55 <fophillips> I hate Python :(
16:09:15 <edwardk> letting you say 'const fmap' instead of const . fmap for the default instance for anything that is a Functor
16:09:28 <edwardk> pragmatics, not category theory speaking =)
16:09:37 <nominolo> orzo: i think the problem is in the let
16:09:48 <lispy> orzo: that first line has a do but no values are returned
16:09:51 <nominolo> indent the fp <- part
16:09:53 <unenough> fophillips, as an imperative language with dynamic typing it's one of the best i know of
16:09:58 <nominolo> and all subsequent stuff
16:10:03 <NikkiA> fophillips: same here, although i withstand it so i can use 'web2py' at times
16:10:17 <edwardk> ddarius: i found the CT for the working mathematician bit about it. i'll have to refresh my brain on CT before it parses properly.
16:10:21 <unenough> but then again, an imperative language with dynamic typing is a pretty bad starting point
16:10:21 <fophillips> unenough: RUBY
16:10:23 <fophillips> :)
16:10:34 <edwardk> 8 months of c# have rotted the brain.
16:10:42 <unenough> fophillips: i'm not biased, i just never used Ruby
16:10:58 <nominolo> orzo: oh, right.  the let + do doesn't seem right
16:11:10 <lispy> orzo: you need something after 'let fetchCompleted cs = ...' that is an expression, I think
16:11:13 <fophillips> It's my most often used language.
16:11:38 <orzo> oh right
16:11:56 <unenough> well, let me know if you happen to run it
16:12:32 <fophillips> I'll try tomorrow, night.
16:12:51 <orzo> i aded "fetchCompleted complete" to the end
16:12:59 <orzo> but doesn't affect the error being reported
16:12:59 <oerjan> orzo: note that you don't need a new let for each definition if they are consecutive.
16:13:08 <unenough> fophillips: whenever :)
16:13:13 <unenough> good night
16:13:31 <oerjan> however, you have an indentation problem there too
16:13:51 <edwardk> ddarius: do you have a link to your 'brutal' introduction handy?
16:14:37 <oerjan> it's not technically legal for the indent after let saveParts ... do to be lined up with saveParts, although ghc may allow it (it relaxes some rules)
16:14:50 <oerjan> (similarly for the others)
16:15:15 <ddarius> edwardk: I'd have to email it to you, it's still incomplete.  While for the most part the content I want is there (except I may add a general CT intro to make it self-contained), I've only done the layout for about half of it and it still needs to be revised for wording and presentation.
16:15:42 <edwardk> if you send it i'll take it in the spirit intended and not call you out on formatting, i promise ;)
16:15:53 <oerjan> orzo: i see another error: you need parentheses around (isOutgoing, Ptr, len):packets
16:17:26 <lispy> orzo: http://hpaste.org/6464#a2 ?
16:18:49 <orzo> lispy, no change
16:20:20 <oerjan> orzo: hm one question, you say it reports an error on the first line.  what is the function _before_ that one?
16:20:55 <oerjan> a similar error in that one might be triggered only when it reaches this one
16:21:38 <ddarius> edwardk: ps or pdf?
16:21:58 <edwardk> whatever is easier, if no preference, pdf is fine
16:22:05 <orzo> oerjan: processPackets packets = mapM_ handlePacket packets
16:22:14 <oerjan> oh
16:22:20 <oerjan> that doesn't have any do
16:22:33 <oerjan> orzo: did you fix the missing parentheses i mentioned?
16:22:44 <oerjan> (in the first line)
16:23:42 <oerjan> orzo: other than that error i cannot see any obvious syntax errors in your second paste
16:26:12 <oerjan> orzo: hm wait i found something.  you cannot have a lambda expression just after another expression.  you need parentheses around them or an operator between
16:26:52 <oerjan> in fact that might trigger the error i think
16:27:21 <EvilTerran> the usual operator to use for that being $
16:27:50 <orzo> ok
16:27:53 <oerjan> here it would be best with parentheses since there are two lambdas
16:28:04 <orzo> you guys have helped a bunch, let me paste the fixed up viersion
16:28:06 <oerjan> also each lambda is greedy rightward
16:28:50 <orzo> http://hpaste.org/6464#a3
16:29:34 <oerjan> that "The last statement in a 'do' ..." error is evil.  It can happen with almost any kind of syntax error inside a do expression, because the parse error rule for layout causes the parser to try to end the do before proceeding
16:29:50 <dozer> ddarius: I must admit, all that stuff about (co)ends just confused me
16:29:56 <oerjan> so the real reason is often completely unrelated
16:30:50 <oerjan> orzo: oh you really did mean the lambdas to nest in each other?  then $ could have been used as well
16:31:29 <oerjan> orzo: that in do trick shouldn't be necessary though
16:32:11 <EvilTerran> orzo, in the definition of dupBuffer, is the body of that second lambda meant to be a do{} block?
16:32:27 <EvilTerran> 'cos it aint
16:32:35 <oerjan> (technically your last case is still not legally indented but this is a case where ghc is lenient i think)
16:32:52 <jeffwheeler> I'm sure this is obvious, but how are Haskell's lists handled internally? They're treated like a singly-linked-list.
16:32:57 <ddarius> dozer: Which context are you referring to?  (i.e. "all that stuff about (co)ends" where?)
16:32:57 <jeffwheeler> Is that the case?
16:33:06 <ddarius> @src []
16:33:06 <lambdabot> data [] a = [] | a : [a]
16:33:33 <EvilTerran> jeffwheeler, "internally" is an implementation detail :P
16:33:43 <EvilTerran> but, yes, all current implementations handle them as linked lists
16:33:55 <jeffwheeler> Ah, okay. I was just curious.
16:33:59 <jeffwheeler> Thanks :)
16:34:26 <ddarius> EvilTerran: In this case, there isn't much flexibility to reasonably swap out an alternate implementation.
16:34:35 <dozer> ddarius: from half an hour ago
16:34:45 <oerjan> orzo: http://hpaste.org/6464#a4
16:34:49 <EvilTerran> ddarius, indeed, but i've gotta keep that caveat in in the interests of rigour. :P
16:36:12 <ddarius> dozer: My mentioning of (co)ends or (co)ends in, say, Categories for the Working Mathematician.  I just mentioned them because they seem like they may be related or useful for edwardk, I could easily be wrong.
16:37:04 <dozer> ah, ok
16:38:21 <EvilTerran> ?index digitToInt
16:38:21 <lambdabot> Data.Char
16:38:37 <EvilTerran> ?vixen how are you today?
16:38:40 <lambdabot> i am wonderful, thanks for asking!
16:39:18 <edwardk> ddarius: still not sure about the coend stuff, and the dinatural transformation in question seems to be more implied than stated by that function signature, so i'm still a bit at a lost
16:39:20 <edwardk> er loss
16:43:31 <oerjan> @seen hpaste
16:43:31 <lambdabot> I saw hpaste leaving #haskell 1d 14h 47m 57s ago, and .
16:45:12 <unenough> @seen Peaker
16:45:12 <lambdabot> I saw Peaker leaving #haskell 5h 54m 36s ago, and .
16:45:15 <unenough> @seen Peaker_
16:45:15 <lambdabot> I saw Peaker_ leaving #haskell 1d 5h 40m 11s ago, and .
16:45:26 <ddarius> As I said earlier, normally we view polymorphic functions as natural transformations, but type F a = a -> a isn't a functor because a occurs both positively and negatively, so e.g. fix :: (a -> a) -> a isn't a natural transformation.  However, what we can do is write type F' a b = a -> b and and then fix is a dinatural transformation from F' to Id, a dinatural transformation F => G being a family of functions indexed by a from Faa -> Gaa satisfying a law.
16:46:47 * unenough will now spend 148 hours reading that last line (and for understanding it, 1343.2 more)
16:47:40 * EvilTerran got the approximate gist of it. apart from the Faa -> Gaa bit, anyway.
16:47:49 <ddarius> In your case, xmap is a dinatural transformation from a bifunctor (Hask^op x Hask) x (Hask^op x Hask)^op -> Hask
16:48:29 <ddarius> EvilTerran: In the case of F' = F, Faa is F' a a
16:48:31 * unenough faints on the sight of "dinatural transformation of a bifunctor"
16:48:44 <EvilTerran> i see. i think.
16:48:47 <ddarius> from a bifunctor
16:49:52 <ddarius> A natural transformation is just a dinatural transformation between (bi)functors that ignore their second arguments.
16:50:03 <dozer> ok, next fun thing: given (MaybeT m) and some (f :: Maybe a), how do I 'lift' f into MaybeT m?
16:50:10 <unenough> does haskell somehow support automatic inversion of functions (when possible)?
16:50:17 <ddarius> unenough: NO.
16:50:19 <ddarius> er No
16:50:35 <dozer> :t maybe Nothing (lift . return)
16:50:36 <hasenov> what is a good way to debug haskell functions?
16:50:36 <lambdabot>     Couldn't match expected type `Maybe' against inferred type `t m'
16:50:36 <lambdabot>       Expected type: m a1 -> Maybe a
16:50:36 <lambdabot>       Inferred type: m a1 -> t m a1
16:50:42 <byorgey> unenough: good question, but that's not possible in general.
16:50:59 <oerjan> dozer: NothingT?
16:51:00 <unenough> byorgey but when it is possible
16:51:05 <unenough> is it supported?
16:51:09 <hasenov> is there some feature of ghc which lets me trace through code, kinda like python's pdb?
16:51:17 <byorgey> unenough: however, you could easily write a recursive data type which encodes functions for which it is possible to compute an inverse
16:51:27 <ddarius> hasenov: There's a debugger implemented recently, but I haven't yet used it and in the time I've used Haskell I haven't missed not having one.
16:51:30 <EvilTerran> ?type Data.Traversable.sequence . fmap return
16:51:31 <lambdabot> forall a (m :: * -> *) (f :: * -> *). (Monad m, Data.Traversable.Traversable f) => f a -> m (f a)
16:51:32 <oerjan> dozer: also lift . return = return is probably a law
16:51:41 <ddarius> I guess there was a double negative there...
16:51:44 <EvilTerran> er, that's not quite right
16:51:51 <EvilTerran> ... is it?
16:52:05 <ddarius> hasenov: Yes, new versions of GHCi have a debugger built in.
16:52:22 <glen_quagmire> i am writing a read-eval-print-loop.  how can I maintain environment across many calls to eval function?
16:52:27 <EvilTerran> you'd need to add in the MaybeT constructor as well, but i think that's right
16:52:28 <byorgey> unenough: for example, data InvertibleFunc = Plus Int | Minus Int | Compose InvertibleFunc InvertibleFunc
16:53:01 <byorgey> then inverse :: InvertibleFunc -> InvertibleFunc given by inverse (Plus n) = Minus n,  inverse (Compose f g) = Compose (inverse g) (inverse f) and so on
16:53:02 <hasenov> ddarius : k, i found it thanx
16:53:14 <EvilTerran> unenough, you might be able to do something with analysis of, say, template haskell's parse trees
16:53:19 <EvilTerran> inverting where possible
16:53:29 <glen_quagmire> http://hpaste.org/6466    this is a rather long testcase
16:53:39 <byorgey> J actually has built-in support for inverting functions when possible, it's pretty cool =)
16:53:49 <monochrom> Richard Bird's "Algebra of Programming" covers inverting functions.
16:53:52 <unenough> ok, thanks. i'm still a haskell noob, so i can't really understand your examples yet
16:54:09 <byorgey> monochrom: does it really?  cool.
16:54:18 * byorgey really really really wants to read that.
16:54:28 <byorgey> I hope it's in the Penn library.
16:54:37 <monochrom> You have to brave through 100 pages of dense category theory first. :)
16:54:59 <unenough> ouch
16:55:00 * EvilTerran should read that. i might be getting Bird to supervise a project sometime soon, so it'd be good to know some of his work in more detail
16:55:13 * monochrom believes in the power of mathematics.
16:55:29 <byorgey> monochrom: well, I've already braved 50 pages of Category Theory for the Working Mathematician, I figure I'll be OK =)
16:56:13 <monochrom> I hope you'll enjoy calculational reasoning, which is quite different from how the typical working mathematician thinks.
16:58:21 <Cale> uh, which examples?
16:58:51 <ddarius> monochrom: I imagine most mathematicians have "modes" where they go through more or less straight calculation.
16:59:32 <monochrom> They do not maximize that mode.
16:59:44 <Cale> Most of them anyway.
16:59:49 <unenough> monochrom is that book readable for a sophomore?
16:59:53 <monochrom> Calculational reasoning means you stay in that mode forever.
17:00:02 <Cale> The point is to try to avoid doing anything tedious.
17:00:27 <Cale> unenough: Which book?
17:00:35 <Cale> Category theory for the working mathematician?
17:00:49 <unenough> Algebra of Programming
17:00:56 <Cale> Oh, I haven't seen that.
17:01:11 <glen_quagmire> newtype Wrap a = ErrorT String (StateT (Map String Val) Identity) a  ;  eval :: Val -> Wrap Val ;  how can I write a repl that calls eval many times and maintain the state in Wrap Val monad?
17:01:23 <ddarius> I've wanted to read The Algebra of Programming, but it's too expensive for me, and I doubt it's anywhere too handy for me currently.
17:01:24 <monochrom> Sorry, I no longer know what sophomores can read.
17:01:45 <Riastradh> glen_quagmire, surely you mean `type', not `newtype', there?
17:01:49 <unenough> neither can I
17:01:58 <unenough> s/can/do
17:02:11 <glen_quagmire> Riastradh: i forgot newtype Wrap a = Wrap { runWrap :: ... }
17:02:23 <glen_quagmire> deriving ( .... )
17:02:32 <glen_quagmire> http://hpaste.org/6466  <- testcase
17:02:35 <Riastradh> unenough, I think generally it's more a matter of what sophomores are willing to read than what they are capable of reading.
17:02:54 <dmwit> glen_quagmire: foldl' (>>=) -- it's not clear what you want, but maybe this?
17:03:26 <unenough> Riastradh that is correct.
17:03:37 <Riastradh> And that's hard to generalize.
17:04:03 <dmwit> glen_quagmire: It might also be mapM, or replicateM, or foldM...
17:04:08 <glen_quagmire> maybe i should not use monads all together
17:04:11 <Riastradh> I don't think `sophomore' is a good class on which to generalize, furthermore.
17:04:16 <roconnor> @src Identity
17:04:16 <lambdabot> newtype Identity a = Identity { runIdentity :: a }
17:04:23 <dmwit> glen_quagmire: If you just clarify what you want, we may be able to help more. =)
17:04:33 <glen_quagmire> I just want to write  a repl that does this:   >>> a = 1;   >>> a    returns 1
17:04:47 <unenough> Riastradh my question should have been are there many mathematical prerequisites
17:04:49 <glen_quagmire> a repl that lets me set variables and access the variables
17:05:30 <oerjan> glen_quagmire: perhaps you might want IO rather than Identity, since you have interactive IO
17:06:27 <oerjan> then you should not need to leave the monad
17:07:00 <oerjan> and can do ordinary imperative programming within it
17:08:37 <oerjan> repl = do line <- liftIO getLine; val <- parse line; result <- eval val; liftIO (print val); repl
17:08:50 <oerjan> something like that
17:09:03 <glen_quagmire> oerjan: oh thank you /me triers
17:09:15 <hasenov> does anyone know why i need to pass -fno-monomorphism-restriction to ghci in order for it to run it?
17:09:28 <hasenov> is smthing wrong with my types?
17:09:41 <oerjan> if your val's contain mutable parts you may need to replace print by something monadic too
17:10:24 <dmwit> hasenov: http://www.haskell.org/haskellwiki/Monomorphism_restriction
17:10:25 <lambdabot> Title: Monomorphism restriction - HaskellWiki
17:10:40 <oerjan> er s/val/result/ a couple of places :)
17:10:44 <dmwit> hasenov: The MR was put in place to protect you a little bit.
17:11:22 <dmwit> hasenov: The idea is that top-level polymorphic values may have to be computed once for each type that it is polymorphic over.
17:11:37 <EvilTerran> hasenov, also, use -XNoMonomorphismRestriction instead, or put {-# LANGUAGE NoMonomorphismRestriction #-} in your file. those're the preferred methods these days.
17:11:41 <dmwit> hasenov: The MR restricts such values to a single type so that it is computed exactly once.
17:11:55 <dmwit> hasenov: (Usually, this is not what *I* want, but I can see the reasoning behind it.)
17:12:51 <hasenov> idk, i dont have print statements or anything in my code yet though
17:13:41 <oerjan> hasenov: you can also get around the restriction by giving explicit type declarations
17:13:44 <dmwit> hasenov: You can usually fix things up right and proper with one or two explicit type-annotations; GHC figures that if you declare something to be polymorphic, you're aware that it may be computed multiple times.
17:14:36 <gwern> @pl prop_union s = union s s == s
17:14:36 <lambdabot> prop_union = (==) =<< join union
17:14:46 <hasenov> oh ok
17:15:13 <hasenov> i dont have any type declarations yet
17:17:54 <gwern> 'Circular definition cat is circular definition cat'
17:18:25 <dmwit> lambdacast :: cats -> dogs
17:21:15 <TomMD> @src fmap :: (a -> a) -> Maybe a -> Maybe a
17:21:16 <lambdabot> Source not found. Just try something else.
17:22:03 <hasenov> ddarius : do u happen to know when the ghci debugger was introduced? i have 6.6.1 and it is the unmasked one on my distro
17:22:16 <monochrom> 6.8.x
17:22:18 <hasenov> do i need to switch to 6.8.2?
17:22:24 <hasenov> ah
17:22:27 <dmwit> ?src Maybe fmap
17:22:27 <lambdabot> fmap _ Nothing       = Nothing
17:22:27 <lambdabot> fmap f (Just a)      = Just (f a)
17:22:55 <monochrom> I don't use distros for ghc.
17:23:56 <wagle_home> monochrom, its nice to have uninstall...
17:24:08 <dmwit> *gasp*
17:24:15 <monochrom> rm -rf /usr/local/lib/ghc-6.8.2
17:24:28 <wagle_home> man pages
17:24:48 <dmwit> rm -rf /Programs/GHC/6.8.2
17:24:52 <dmwit> gets the man pages, too ;-)
17:25:19 <monochrom> man ghc --> "please just see http://haskell.org/haskellwiki/GHC "
17:25:19 <lambdabot> Title: GHC - HaskellWiki
17:25:31 <wagle_home> eh, i install stuff in /usr/local..  uninstall by erasing /usr/local, and reinstalling everything..  8/
17:25:46 <dmwit> yikes
17:25:58 <monochrom> That is your problem IMO.
17:26:39 <monochrom> Or more strongly, that is a straw-man attack IMO.
17:26:47 <wagle_home> ?
17:27:10 <dons> uinstall is so rarely needed
17:27:24 <dons> we don't like mutating values, after all :)
17:27:38 <wagle_home> yeah..  thats why my uninstall method for /usr/local isnt so painful
17:27:44 <lament> (you mean your system is NOT a monad?)
17:27:47 <lament> *file system
17:27:51 <monochrom> I understand the need to uninstall.  When you move on to 6.10.11, you do want to erase 6.8.2 somehow.
17:28:16 <ddarius> monochrom: You do?
17:28:17 <Toxaris> why?
17:28:33 <ddarius> Maybe, 5.4.2
17:28:49 <monochrom> OK, let's say erase 6.4 instead.
17:29:56 <monochrom> <Watson tone> There may be only 5 people in the whole world who need to keep around old versions of ghc. </Watson tone>
17:30:20 <dons> i like having old versions around
17:30:30 <monochrom> Yeah, you're one of those 5. :)
17:30:33 <lament> your job is to find those people... and terminate them
17:30:34 <dmwit> I think there's a world market for maybe 5 copies of GHC.
17:30:43 <lament> target #1 is clear
17:31:21 <dozer> ouch - MaybeT has no MonadPlus instance
17:32:25 <lament> Can somebody recommend a research paper to read on the bus that will NOT make my head explode?
17:32:29 <dons> hmm.
17:32:29 <lament> (my head explodes easily)
17:32:30 <dons> lament: in what area
17:32:32 <monochrom> "why FP matters"
17:32:48 <dons> "The History of Haskell"
17:32:53 <lament> dons: cool stuff! I liked Beautiful Concurrency
17:33:09 <dons> "The Zipper "
17:33:24 <dons> "Comprehending monads"
17:33:25 <hasenov> "why FP matters" is really good
17:33:28 <dmwit> Wearing the Hair Shirt
17:33:46 <hasenov> almost everything i wrote is based off it
17:33:47 <monochrom> Oleg's stuff doesn't make your head explode.  Actually it does, but you'll lose consciousness before you explode, so there is no difference to you.
17:33:55 <araujo> shapr!!!!
17:34:19 <dmwit> A Taste of Rewrite Systems
17:34:22 <dons> "Finger Trees: A Simple General-purpose Data Structure"
17:34:30 <dmwit> ooo finger trees
17:34:35 <Toxaris> type-level head explosion will statically ensure that your dynamic thinking system is not damaged
17:34:39 <oerjan> finger licking good?
17:34:54 * EvilTerran wants to come up with a data-structure that he can call "porcupine trees"
17:34:56 <lament> thanks!
17:35:23 * Toxaris reads random Functional Pearls on the bus.
17:35:56 <shepheb> EvilTerran: tree zipper with a 2d list of children? other end of the zipper is the tail.
17:36:11 <monochrom> @remember Toxaris type-level head explosion will statically ensure that your dynamic thinking system is not damaged
17:36:11 <lambdabot> Done.
17:36:13 <EvilTerran> hmm
17:36:27 <BMeph> "Generalizing Generalized Tries"
17:36:32 <wy> I found the type of (!!) deceptive
17:36:37 <wy> :t (!!)
17:36:38 <lambdabot> forall a. [a] -> Int -> a
17:36:39 <Toxaris> is it funny without the Oleg-context? or is the Oleg-context obvious?
17:36:46 <dons> oh, the type context holes paper is a good one
17:36:51 <dons> just on the edge of brain explosion
17:37:03 <monochrom> It is funny without the Oleg context.
17:37:03 <lament> you mean... it's on the edge of brain explosion for _you_?
17:37:08 <dons> ?go type type of one-holed contexts mcbride
17:37:09 <lambdabot> http://www.era.lib.ed.ac.uk/bitstream/1842/778/1/lindley_thesis.pdf
17:37:16 <dons> hmm, no.
17:37:17 <dmwit> ?quote Toxaris
17:37:17 <lambdabot> Toxaris says: type-level head explosion will statically ensure that your dynamic thinking system is not damaged
17:37:36 <dons> "The Derivative of a Regular Type is its Type of One-Hole Contexts"
17:37:39 <dons> i enjoyed that paper
17:37:43 <Botje> ?quote experts
17:37:43 <lambdabot> shapr says: Anyway, I'm just a walking index into the Haskell world. I can tell you a little bit about many things, but I will quickly forward you to the experts for more detail.
17:37:52 <Botje> ?quote brane
17:37:53 <lambdabot> Botje says: Leading experts on haskell recommend at least twenty-four hours between brane asplosions.
17:38:12 <wy> oh... maybe I should ask for a clarifying of monads and exceptions
17:38:18 <dmwit> ?quote exceptions
17:38:18 <lambdabot> No quotes match. I've seen penguins that can type better than that.
17:38:24 <glen_quagmire> wikiepdia is down. they are probably moving to HappS
17:38:25 <dmwit> ?quote monads
17:38:25 <lambdabot> monochrom says: If you come across "monads are fun!" it's probably Wadler.  If you come across "continuations are fun!" it's probably Appel.
17:38:44 <monochrom> That one was a long time ago. :)
17:38:47 <dmwit> ?quote wadler
17:38:47 <lambdabot> wadler says: The way we can tell it's C# instead of Haskell is because it's nine lines instead of two.
17:38:54 <dmwit> ?quote wadler
17:38:55 <lambdabot> wadler says: Curried food and curried functions are both aquired tastes
17:39:49 <wy> I had been wondering whether Appel could write functional programs at all..
17:39:54 <ddarius> Either of those are acquired tastes?
17:40:18 <wy> oh don't digress... what are exceptions
17:40:30 <oerjan> mm, curry
17:40:31 <wy> It's weird that they are not captured by the types
17:40:32 <monochrom> You know how the saying goes about how there is only one intuitive thing.
17:40:45 <Toxaris> wy: informally or technical?
17:40:53 <ddarius> wy: They are when you use monads to model exceptions.
17:41:16 <wy> ddarius: but they are not modeled with monads in haskell, why?
17:41:27 <wy> :t head
17:41:27 <lambdabot> forall a. [a] -> a
17:41:41 <monochrom> Oleg has an article on that.
17:41:43 <wy> I have no idea this function can cause exceptions
17:42:12 <oerjan> @where catch
17:42:12 <lambdabot> http://www.cs.york.ac.uk/~ndm/projects/catch.php
17:42:16 <Saizan> well, actually the type says that it can't be total
17:42:32 <wy> Saizan: how can I know that?
17:42:49 <monochrom> http://www.haskell.org/pipermail/haskell/2004-June/014271.html  is Oleg's article.
17:42:50 <lambdabot> Title: [Haskell] Exceptions in types and exception-free programming
17:43:00 <Toxaris> wy: if you count bottom as an exception, you cannot avoid to have them everywhere
17:43:04 <Saizan> data [a] = [] | a : [a], in the [] case you can't return an 'a'
17:43:29 <wy> Saizan: but I can't see it from the type
17:43:35 <shapr> @quote dmwit
17:43:36 <lambdabot> dmwit says: Only in #haskell would somebody consider rolling back a process fork.
17:43:38 <glen_quagmire> i think monads are placebo. people say they are nice. and you just believe they are nice although they are darn hard to make sense of
17:43:40 <wy> Toxaris: bottom... is something more special
17:44:01 <monochrom> placebos are not darn hard to make sense of.
17:44:02 <shapr> glen_quagmire: Monads are easy, they just do a lot of stuff.
17:44:09 <shapr> glen_quagmire: Try reading "All About Monads"
17:44:15 <Toxaris> wy: I have been told that (error "head []") is semantically bottom
17:44:41 <bd_> Toxaris: yep. So is length ([1..] :: [Integer])
17:44:42 <oerjan> there are two kinds of bottom, exceptions and non-termination, iiuc
17:44:47 <ari> Semantically?
17:44:51 <bd_> oerjan: semantically they're the same
17:45:02 <bd_> in practice, sometimes the runtime can give you a nice message informing you about it
17:45:06 <bd_> but it's not required to
17:45:08 <dmwit> Right, exceptions are just an optimization of non-termination.
17:45:09 <monochrom> Don't say "semantically" too easily.  There are many different semantics.
17:45:23 <bd_> monochrom: How about according to haskell's denotational semantics?
17:45:32 <monochrom> That one is cool.
17:45:47 <oerjan> bd_: they invented a new semantics for exceptions i think
17:46:00 <EvilTerran> if we had guarded and structural recursions encoded in the types, it'd be theoretically possible to eliminate bottom altogether, i think...
17:46:02 <wy> glen_quagmire: I'd recommend Wadler's article "The Essence of Functional Programming"
17:46:16 <bd_> EvilTerran: Then it wouldn't be turing complete
17:46:21 <oerjan> @go imprecise exceptions
17:46:22 <lambdabot> No Result Found.
17:46:26 <EvilTerran> indeed not
17:46:28 <bd_> oerjan: It's still bottom though
17:46:36 <wy> I found no other tutorials easier than that
17:46:56 <EvilTerran> you'd have to include some way of expressing unsafe recursions, but it'd appear as a type annotation
17:47:16 <EvilTerran> and you could express a lot of algorithms without using it
17:47:55 <monochrom> binary search needs it IIUC
17:48:10 <Toxaris> wy: but to your question. I understand that the idea of how-are-they-called-somewhat-pure exceptions is that throwing an exception is seen as pure, but catching them is done via an Exception-Catching-Oracle living in IO. so part of the exception handling is indeed marked by IO, but not all of it.
17:48:20 <wy> so is it to say that Haskell exceptions are semantically different those of Java's?
17:48:29 <glen_quagmire> wy: nice
17:48:30 <ddarius> bd_: Haskell doesn't have a denotational semantics.
17:48:56 * monochrom hides
17:48:59 <Toxaris> ddarius: cannot have or there is no written record of it?
17:49:02 <ddarius> However, in Haskell 98, error "foo" is uncatchable and thus the same as bottom as far as the rest of the Haskell program is concerned.
17:49:27 <ddarius> Toxaris: Does not.  One can certainly be written.  More than one could be written.
17:50:11 <oerjan> ddarius: the haskell report defines recursion in terms of least fixpoint, iirc, so some denotational semantics is presupposed
17:50:27 <monochrom> "the obvious one" :)
17:50:40 <Toxaris> wy: that's the exact opposite of other exception-aware type systems. e.g. in java, functions which may throw exceptions are marked.
17:51:32 <wy> I guess exceptions are not shown as monads  because it's catched and converted to bottom. Is this thinking right?
17:51:36 <monochrom> Or you can read it this way.  An implementation will have to define its own denotational semantics.  Then lfp means lfp there.
17:51:56 <newsham> what about "formulating haskell" doesnt that give some denotational semantics?
17:52:01 <wy> because you have "error "empty list"" in head
17:52:17 <SamB> newsham: hmm?
17:52:17 <lambdabot> SamB: You have 1 new message. '/msg lambdabot @messages' to read it.
17:52:21 <SamB> @messages
17:52:22 <lambdabot> gwern said 20h 12m 38s ago: I've seent you a number of ZMachine patches. I'd like to add it to Hackage, but my testing has a problem - I can't seem to actually do any typing/input. is this a known
17:52:22 <lambdabot> problem, or can you type and play the provided .z5s just fine?
17:52:26 <wy> :t error
17:52:27 <lambdabot> forall a. [Char] -> a
17:52:29 <newsham> http://www.cs.kent.ac.uk/pubs/1992/123/index.html
17:52:29 <lambdabot> Title: Computer Science: Publication: Formulating Haskell
17:52:37 <wy> it's still a little weird
17:52:42 <SamB> wow
17:52:46 <SamB> patches for ZMachine???
17:53:19 <SamB> oh is that what this email from gwern is
17:55:46 <ddarius> There are no complete formal semantics for Haskell 98.
17:56:07 <ddarius> Let alone one that is "blessed" as the normative one.
17:56:09 <monochrom> Since "formulating haskell" gives a logic for proving program properties, I say it's closest to Hoare's logic.  Not denotational.  Nevermind that it re-uses the symbol ‚ä• - there is even no partial order defined.
17:56:14 <SamB> on accouunt of nobody wanting to create one when it would be out oof date before they began ;-)
17:56:50 <Toxaris> wy: I understand error as: error msg = unsafeThrowError msg `seq` (let x = x in x)
17:57:05 <Toxaris> wy: so semantically, error msg = let x = x in x
17:57:37 <SamB> hmm, what was that nice paper about exceptions
17:57:43 <SamB> it defined a minisemantics
17:58:02 <oerjan> maybe http://research.microsoft.com/~simonpj/Papers/imprecise-exn.htm ?
17:58:03 <lambdabot> Title: Simon Peyton Jones: papers
17:58:09 <SamB> yes, that one!
18:02:19 <newsham> "Miranda is a trademark of Research Software Limited".  what became of that company?
18:02:56 <SamB> it's limitations got the best of it?
18:03:30 * SamB thinks his GHC has a broken recompilation checker...
18:03:42 <gwern> newsham: 'in the long run, the utility of all nonFree software approaches zero'
18:03:58 <gwern> SamB: any idea 'bout my question?
18:04:25 <SamB> gwern: I don't remember that being a problem in the past
18:04:46 <SamB> my main issue was that I couldn't for the life of me figure out a decent way to implement the status area
18:05:22 <gwern> SamB: so zmachine works for you right now? you can type in input and play dandy, modulo known bugs in implementation?
18:05:43 <SamB> gwern: I haven't tried it lately
18:05:56 * gwern wonders what lately is
18:06:04 <SamB> I donn't remember
18:06:06 <gwern> could it be subtle breakage from gtk updates?
18:06:38 <SamB> indeed it could be
18:07:29 <newsham> so RSL went under?  changed names? got bought?
18:08:21 <gwern> SamB: what's the difference betwen .inf and .z5? i note only the latter seems to work
18:08:43 <SamB> gwern: .inf is source files ;-)
18:09:16 <gwern> oh
18:09:24 <gwern> SamB: all of a sudden, I feel very stupid
18:09:28 <SamB> lol
18:09:35 <SamB> it's okay ;-)
18:09:48 <gwern> SamB: you're supposed to be typing in the box in the bottom, not the actual prompt in the middle of the screen, aren't you?
18:10:19 <wy> :t  let x = x in x
18:10:20 <lambdabot> forall t. t
18:11:20 * BMeph wants to find a college named "Abel," so he can join the Abelian Field Hockey team
18:11:38 <Maddas> :-)
18:11:42 <gwern> lol. I can crash Museum.z5 by typing 'look map' instead of 'look at map'
18:11:43 <gwern> fun
18:12:09 <gwern> BMeph: that is a terrible joke, and you are a bad person for thinking of it and you should feel bad
18:12:34 * gwern begins telling BMeph about my dog Clyde who got euthanized today; BMeph feels bad
18:12:44 * BMeph looks at the "Unified Field Hockey" sweatshirt he's wearing...and grins
18:16:03 <SamB> BMeph: I will work for galois for a similar reason
18:16:19 <SamB> they DO have a field hockey team, right?
18:16:40 * BMeph wants to see pictures of the Galios Field Hockey jersey
18:16:50 <BMeph> s/Galios/Galois/
18:17:02 <wy> Toxaris: It's weird. It returns a bottom there... and it's unclear how the message gots displayed
18:17:22 * gwern doesn't know who to complain to about the zmachine crash. do I complain to SamB or do I credit it and complain to GHC? '[finding abbrev 0 at $84][finding abbrev 1 at $8c][(0,"look"),(5,"at"),(8,"map")] \ [(0,"look"),(5,"at"),(8,"map")] \ zmachine: internal error: task 0xa031e0: main thread 1 has been GC'd \ (GHC version 6.8.2 for x86_64_unknown_linux) \ Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug'
18:17:39 <Toxaris> > let x = x in x -- wy are you talking about this?
18:17:41 <lambdabot>  Exception: <<loop>>
18:17:48 <wy> yes. and why it stops
18:18:00 <SamB> gwern: I am pretty sure I didn't do that
18:18:08 <SamB> I don't remember doing anything THAT unsafe
18:18:38 <BMeph> SamB, gwern: I'm wearing my Unified Field Hockey sweatshirt because the lettering is green. :)
18:18:38 <gwern> SamB: then u explain why 'look map' is a crash for Museum.z5 and 'look at map' ain't
18:19:01 <Toxaris> wy: I think the compiler realizes that it must be bottom and introduces an error-call to change a looping bottom to a terminating bottom. but maybe the rts realizes it, i don't know exactly
18:19:08 * wy kept getting low grades from his compiler course
18:19:14 <SamB> gwern: heap corruption is a cruel mistress
18:19:18 <SamB> wy: you did?
18:19:20 * gwern is wearing nothing green because the feast of st. patrick was two days ago
18:19:22 <SamB> you get to take one?
18:19:44 <gwern> wy: lol 'kept' how many times did you take it?
18:20:18 <wy> gwern: I mean homework and project assignments
18:20:19 <Toxaris> I had to extend a badly written Java compiler for a Pascal-like toy language in my compiler course
18:20:36 <Toxaris> only chance to fight back: i wrote comments using Haskell as pseudocode :)
18:20:40 <wy> Toxaris: similar experience
18:20:54 <wy> but we are writting from scratch
18:21:06 <olsner> heh, yeah, my Java code is littered with Haskell comments :P
18:21:07 * ddarius doesn't even own anything with green on it.
18:21:27 <ddarius> Toxaris: The RTS
18:21:47 <Toxaris> wy: the given codebase featured a hand-written recursive descent parser in a single file
18:22:05 <wagle_home> at least my compiler course used scheme
18:22:20 <wy> Toxaris: better than using CUP
18:22:22 <Toxaris> wy: with absolutely no abstractions used... (there *are* functions in java after all, even if they aren't first-class, you *can* call them).
18:22:44 <wy> wagle_home: I really want to drop it and go to IU immediately to take Kent's course
18:22:48 <olsner> our compiler course had Pascal code ported to C++ by a Java coder
18:23:30 <wy> wagle_home: oh I will visit on Wednesday
18:23:37 <wagle_home> wy, cool
18:23:56 <wy> :p
18:24:10 <SamB> olsner: I would rather have just used turbo pascal
18:24:12 <wagle_home> when is spring break there?
18:24:43 <Toxaris> but I had general course about programming languages with Scheme assignments and a course about static analysis with free language choice (i oscillated between prolog and haskell), so i maybe shouldn't complain too loud
18:24:51 <Beelsebob> has anyone got any experience of calling Python via the FFI?
18:24:55 <wy> wagle_home: spring break is last week. This week is Cornell's spring break
18:24:58 <oerjan> wy: ghc has a trick used in some optimization settings, where whenever it starts evaluating a thunk it sets a kind of tag on it (a black hole) so that if it reaches that thunk again recursively before finishing its evaluation, it throws that <<loop>> exception instead of really looping
18:25:35 <wy> oerjan: do you think that's why error msg can stop?
18:25:42 <newsham> beel: not I, but should just be like haskell calling C and C calling python, no?
18:26:00 <oerjan> yes.  that's what the <<loop>> exception means, afaiu
18:26:01 <wy> wagle_home: how do you like Kent's course?
18:26:07 <Beelsebob> newsham: well, yes, ideally I'd like to miss out the C step all together
18:26:24 <oerjan> er, not error msg, but that let x = x in x
18:26:24 <Beelsebob> and get Haskell to load the Python interpretter and call stuff
18:26:35 <Beelsebob> wy: you're interested in Kent's course?
18:26:44 <newsham> beelsebob: *nod*  so its just like calling the C API from in FFI :)
18:26:54 <Beelsebob> <-- teaches FP seminars & terminals at kent
18:26:56 <oerjan> error msg just stops immediately i assume
18:26:57 <wy> Beelsebob: yes. I heard they made a new framework for the course
18:27:24 <Toxaris> oerjan: interesting. so the thunk is changed two times. at the beginning of evaluation to a call to error, and at the end of evaluation to a function returning the result?
18:27:25 <gwern> 'Well, if you take the case of Miranda, the amount of documentation on the web is minimal (with half the links broken). Contrasted that with the open standard of Haskell which arose out of the concern that Miranda was a proprietary language. Not sure if the owners of Miranda made money by keeping the language to themselves, but in the long run Miranda is a doomed programming language, which is odd since it had at least a 5 year jump on ...
18:27:30 <wagle_home> wy, was pretty good the first time he taught it..  8)
18:27:30 <gwern> ... Haskell. '
18:27:37 <Beelsebob> wy: yeh, unfortunately, of what I've seen of the new version it mostly seems to involve cutting out anything that students might find difficult (eg Functional Programming)
18:27:42 <Beelsebob> and replacing it with more Java modules
18:28:12 <wy> Beelsebob: uhh... Are you at IU?
18:28:16 <oerjan> Toxaris: that's my understanding
18:28:22 <Beelsebob> IU?
18:28:27 <wy> indiana
18:28:32 <Beelsebob> no
18:28:33 <Beelsebob> UKC
18:28:40 <Beelsebob> University of Kent at Canterbury
18:28:40 <wagle_home> i suspect Beelsebob is at kent state?
18:28:48 <wagle_home> oh ..  or there
18:28:50 <Beelsebob> hehe
18:28:52 <wy> How do you know the course? ... aha!
18:28:53 <Spark> kent as in south of london?
18:28:56 <wy> oh...
18:29:00 <Beelsebob> east of London actually
18:29:02 <Beelsebob> but yeh
18:29:03 <Spark> is it?
18:29:05 <Spark> heh
18:29:13 <Spark> i'm thinking of surrey
18:29:13 <Spark> oh well
18:29:14 <wy> Beelsebob: so you mean the place Kent, not the person Kent?
18:29:20 <Spark> is it east of essex?
18:29:26 <Beelsebob> I mean the place Kent, yes
18:29:29 <unenough_> whew....i just spent 5 hours of my life battling windows
18:29:38 <ddarius> unenough_: Did you win?
18:29:39 <Beelsebob> Spark: kent is the most south easterly county in england
18:29:39 <wy> Beelsebob: I meant Kent Dybvig ;)
18:29:43 <Beelsebob> lol
18:29:47 <wy> lol
18:29:56 <Spark> ah it's where dover is?
18:30:03 <Spark> now everything makes sense
18:30:03 <wagle_home> i tried to mount an ntfs volume rw from linux, and i failed..
18:30:19 <wy> I really wonder if I should stay in my course. I spent days and nights to make my framework elegant, but only got comments asking me not to make operators function calls
18:30:20 <Beelsebob> yes, dover is close to the most south easterly point, and london is the most north westerly point in Kent
18:30:21 <unenough_> ddarius surprisingly, yes!
18:30:24 <Beelsebob> well, london isn't in kent
18:30:27 <Beelsebob> but you get what I mean
18:30:27 <olsner> wagle_home: corrupting the ntfs file system in the process, I presume?
18:30:34 <Beelsebob> Kent ends at the M25
18:30:39 <Spark> ah right
18:30:45 <newsham> i think ntfs writing is still considered dangerous and requires a special build option to enable
18:30:58 <Spark> you can use fuse to do ntfs on linux
18:31:01 <Spark> it's pretty slow though
18:31:10 <wagle_home> olsner, nah..  it just either refuses to mount it at all, or else refuses to give write permission to root
18:31:12 <Spark> i would put all the files you want to share between them on an ext2 partition or something
18:31:18 <Spark> mount them from both windows and linux
18:31:20 <Beelsebob> ntfs3g is meant to be pretty safe
18:31:28 <unenough_> windows can mount ext2?
18:31:34 <Spark> i have a program to do it
18:31:35 <Beelsebob> although OS X still only allows read only, so there must be something dodgy about the implementation
18:31:41 <Spark> but it only does partitions
18:31:44 <Spark> not arbitrary files
18:31:48 <Spark> so i haven't had a chance to test it
18:31:58 <Spark> it's called "ext2 voumne manager"
18:31:59 <Beelsebob> tbh, if I want windows/linux/os x to all have access to a file, FAT32 is the answer
18:32:06 <Beelsebob> wish that wasn't the case
18:32:07 <wagle_home> i wouldnt trust windows xp with the knowledge of how to read my ext3 fs's
18:32:09 <Spark> ext2fsd.com
18:32:13 <SamB> hmm, I seem to be missing gtk2hs
18:32:14 <olsner> I wonder why ntfs write support is so hard to implement compared to every other crazy file system
18:32:22 <bd_> olsner: it's been implemented in ntfs-3g
18:32:31 <Beelsebob> olsner: because no one knows what ntfs really looks like
18:32:31 <wy> wagle_home: explore2fs seems to be stable
18:32:34 <Beelsebob> except MS
18:32:35 <newsham> olsner: undocumented changes in each version?
18:32:40 <Spark> fat32 doesn't get you unix file permissions though, sadly
18:32:41 <bd_> olsner: and works just fine as long as it's cleanly unmounted
18:32:52 <Beelsebob> everything we know about NTFS is a guess from looking at what windows writes to the disk
18:33:09 <Beelsebob> Spark: idd
18:33:09 <Beelsebob> :(
18:33:24 <Beelsebob> nor a lot of other things, like 4GB file support
18:33:33 <Beelsebob> or if you want windows to understand it, 32GB volume support
18:33:44 <newsham> not "everything" there are several books with information from the ntfs authors
18:33:49 <newsham> (though incomplete)
18:34:05 <unenough_> i think disassembling the ntfs driver helped
18:34:12 <Toxaris> wy: I tend to solve such problems by artificially introducing another abstraction without changing my actual codebase. maybe "an operator is a function call" sounds bad to your teacher, but "i can reuse code for both operators and function calls by introducing a common CallableEntity abstraction" sounds better
18:34:20 <Beelsebob> the annoying thing is... ZFS looks like something good to try to get everyone to standardise on
18:34:26 <Beelsebob> but it can't be integrated into linux
18:34:30 <Beelsebob> because of the licence :(
18:35:03 <bd_> the on-disk format is documented, so theoretically someone else could write a new driver
18:35:34 <bd_> @ ZFS
18:35:35 <wy> Toxaris: I just tried to make it like lambda calculus ;)
18:35:36 <unenough_> i know that the linux driver will refuse to mount an ntfs volume of a hibernating computer
18:35:50 <Beelsebob> bd_: theoretically, but it's taken Sun long enough to get theirs right
18:35:50 <unenough_> so i guess windows does some nasty things at least in that case
18:35:52 <bd_> unenough_: that makes sense though
18:36:07 <bd_> unenough_: if you modify it, windows will be very very confused when it wakes up (= massive disk corruption)
18:36:09 <wy> and I don't have "statements" but all expressions. That's another complaint from the TA
18:36:14 <Beelsebob> it'd be *really* hard to independantly write a new one that doesn't infringe copyright
18:36:19 <newsham> beelse: that doesnt sound annoying to me at all.  then again, I have FreeBSD with has ZFS :)
18:36:36 <newsham> btw, whats wrong with writing a ZFS module for linux?
18:36:37 <bd_> Beelsebob: Surely it could be loaded into the kenrel as a module, just like nvidia et al?
18:36:38 <unenough_> bd_ if windows would just write the hibernation status to a file, and linux doesn't touch that file, then why not? but it doesn't do that
18:36:42 <newsham> you can modload nongpl code in if you want
18:37:03 <Beelsebob> newsham: bearing in mind that the panacea I'm aiming at is not going "wee, I have a zfs drive, I win" but instead going "wee, I have a disk with support for lots of stuff, that Linux, OS X, and windows can all read and write properly"
18:37:06 <newsham> hmm.. maybe this is #haskell-blah stuff
18:37:12 <unenough_> maybe it is
18:37:12 <Beelsebob> plausable
18:37:14 <bd_> unenough_: er, the problem is the hibernation status is a kernel image, which contains information about the FS metadata, and you don't want that information to become inconsistent with the actual on-disk state
18:37:27 <wy> but the most points was deducted because I didn't check "variable initialization" (10%) :p
18:37:33 <unenough_> orthogonal persistence is the answer!
18:37:45 <unenough_> to some question
18:37:46 <olsner> hmm, your compiler teacher sounds quite backward when it comes to programming languages
18:37:49 <unenough_> :P
18:37:56 <Toxaris> wy: I assume you have to implement a compiler for a given language?
18:38:27 <wy> do we really need file systems?
18:38:33 <unenough_> no!
18:38:42 <unenough_> nor do we need the web
18:38:43 <wy> Toxaris: yes. something like Java
18:39:04 <porrifolius> Hi.  Just been looking for help on #gentoo-haskell getting darcs compiled... thought I'd ask here as well:
18:39:10 <porrifolius> Just tried to emerge darcs 1.0.9 from gentoo-haskell overlay (got GHC 6.8.2 installed) and got the error: 'configure: error: Couldnt figure out how to call GHC.Handle.openFd!'  Any advice?
18:39:16 <Toxaris> I like the statement - expression distinction, but i would try to design it so that expressions are pure :)
18:39:17 <wy> I just want to try to see how the implementation for such a crappy language could also be elegant
18:39:26 <unenough_> we need a world of referencable objects that live in a single-level storage
18:39:27 <olsner> otoh, finding uninitialized variables is a really useful analysis for crappy languages
18:39:33 <porrifolius> Looks like it was trying to decide between new and old GHC file apis.
18:39:41 <Toxaris> if you find a way, don't forget to publish it
18:40:44 <wy> but does it worth 10%... it could be added in several minutes
18:40:54 <Toxaris> so why didn't you add it?
18:41:03 <wagle_home> Beelsebob, oh well: WARNING: Deficient Linux kernel detected. Some driver features are
18:41:04 <wagle_home> .....
18:41:11 <wy> I just neglected it ;)
18:41:28 <olsner> several minutes? shouldn't that be about 10% of what you spent? :P
18:42:33 <dmwit> porrifolius: Huh, that sounds pretty bad.
18:42:47 <dmwit> porrifolius: Have you got two versions of GHC installed?
18:42:50 <Toxaris> as usual with assignments i assume. you spend days and nights on writing an ad-hoc embedding of Haskell into your actual implementation language, and then you need some minutes to solve the actual problem in Haskell, which leaves you with 2-10 hours to encode it in the implementation language
18:42:58 <wy> The spec reads like "...the compile will check that variables are initialized before their use...", and not like "LAW 101.2: the compile must check that variables are initialized before their use."
18:43:01 <dmwit> porrifolius: What version of cabal?  (ghc-pkg list cabal will tell)
18:43:15 <Toxaris> if I ever have too much time (which, because of #haskell) will never be, I'll write a Haskell->Java converter :)
18:43:34 <dmwit> porrifolius: Sorry, ghc-pkg list Cabal
18:43:48 <porrifolius> dmwit: Nope. Just trying to set up a new machine. GHC-6.8.2, Cabal-1.2.3.0.
18:43:54 <wy> olsner: hmm it should be... but it took me 40 hours just to write the parser
18:44:14 <dmwit> porrifolius: Well those sound fine.
18:44:30 <porrifolius> dmwit: I have the same combination of GHC, Cabal and darcs on another machine... but it grew up through various versions. This machine is newly incarnated.
18:45:39 <olsner> well, well, time to sleep and figure out ways to sneak in haskell in our production code at work
18:45:45 <dozer> now I'm confused
18:46:05 <dozer> my tictactoe program works(ish)
18:46:20 <olsner> this is the first time it compiles, right?
18:46:46 <wy> olsner: what do you use in your production code?
18:46:51 <olsner> (it would be so awesomely haskellish if it actually is :P)
18:47:48 <olsner> wy: right now, working on a sub-project in Java and C... but mostly it's C++
18:48:05 <dozer> http://hpaste.org/6467
18:48:13 <dozer> this code works as expected
18:48:22 <dozer> except that it doesn't exit eagerly on a win
18:48:47 <dozer> it carries on playing untill the outer `mplus` is triggered, at which point it returns the first win made
18:49:31 <wagle_home> wy: oh yeah, i was going to note that programming in java is a different mindset, you think more in terms of virtual dispatch that in "i'm applying this particular instance of a function"
18:49:54 <wagle_home> s/that in/than in/
18:51:02 <dozer> it is as if the 2nd args to mplus are being fully evaluated before looking at the first args
18:51:17 <wy> wagle_home: more classes mean more trouble when you add virtual methods
18:51:21 <wagle_home> not that i know java that well..  but i did write a scheme interpreter in java, and there was one (1) if statement in the whole thing
18:52:09 <wy> wagle_home: you mean (cond..) ?
18:52:10 <monochrom> So you used subclasses and dispatch heavily?
18:52:23 <wagle_home> java if statement
18:52:23 <oerjan> dozer: what's your Monad?
18:52:25 <wy> wagle_home: oh I got it reversed..
18:52:36 <wy> I thought you wrote a java interpreter in scheme ;)
18:52:46 <monochrom> Haha.
18:52:49 <dozer> oerjan: MonadT with the MonadPlus instance from the wiki
18:53:02 <shapr> @users
18:53:02 <lambdabot> Maximum users seen in #haskell: 464, currently: 429 (92.5%), active: 25 (5.8%)
18:53:07 <wagle_home> wy, i should do that too, except it'd now be haskell
18:53:07 <dozer> mplus x y = MaybeT $ liftM2 mplus (runMaybeT x) (runMaybeT y)
18:53:10 <wy> monochrom: yes for the AST
18:53:11 <monochrom> "I wrote a JVM in Haskell. There was one (1) if statement in the whole thing." :)
18:53:24 <SamB> gwern: "look map" isn't crashing here...
18:53:28 <wy> so I tried to reduce the number of AST node types to the minimum
18:53:57 <oerjan> dozer: er, MaybeT you mean?
18:54:04 <gwern> SamB: fun. could the architecture be at fault? I'm on x86_64
18:54:08 <gwern> 'An Ocaml warrior suddenly jumped out and hrew a malformed interrobang in an attempt to corrupt Con's deterministic purity by destructively assigning his state with referencial transparency (a black magic considered one of the darker evils from the depths of hell). Cons took up his parenthsis and swiped at the Caml with a quickly-crafted lambda function, but the Caml inferred the type of attack and was successfully able to evade any ...
18:54:10 <dozer> oerjan: yup, I'm getting tired ;)
18:54:12 <wagle_home> "I wrote a JVM in pointless style haskell ...."
18:54:15 <SamB> gwern: 'spossible!
18:54:16 <gwern> ... side effects. He didn't notice, however, that Cons' intention was not to slay him with the lambda but rather to incorperate the lambda into a foldl incantation to collapse the Ocaml's state into a single return value. The Ocaml let out a scream as the tail-recursive function produced a single value from his state without any side-effects: -3.'
18:54:30 <SamB> gwern: anyway, report it as a GHC bug like the message says
18:54:34 <dozer> oerjan: and the players are bothin the IO monad, so it is MaybeT IO
18:54:45 <wagle_home> ... well, ok, there was one (1) point in the whole thing
18:54:55 <SamB> gwern: are you writing a new piece of IF?
18:54:58 <gwern> SamB: you on i386?
18:55:04 <SamB> gwern: yes.
18:55:14 <gwern> SamB: no - that's from http://dis.4chan.org/read/prog/1202856797/1-40
18:55:16 <lambdabot> Title: 4chan BBS - Original Content
18:55:43 <SamB> haskell on *4chan*?
18:55:48 <olsner> wtf, there's a 4chan with contents?
18:55:51 <gwern> SamB: just to double check, you compiled with my patches and did 'zmachine Museum.z5' and immediately, the very first input, was 'look map'?
18:55:56 <wy> wagle_home: you have one if statement, because you didn't use subclasses?
18:56:00 <olsner> sense - it makes none!
18:56:01 <Pseudonym> What's a 4chan?
18:56:13 <gwern> SamB: yeah, the textboarders are weird assholes who venerate SICP and to a lesser degree haskell
18:56:36 <Pseudonym> Oh, it's like reddit, only porn.
18:56:42 <bd_> eh? people use world4ch?
18:56:47 <SamB> gwern: well, that wasn't how I'd done it
18:56:47 <gwern> '
18:56:49 <Toxaris> we could immediately run small games and web 2.0 applications while compiling if we had a type-level JVM in Haskell
18:56:49 <gwern> Discipline was tight in the Haskell nomads. If a given expression did not behave deterministically he had to be wrapped up in the shroud of the monad and returned to the homelands after a ritualistic suicide - they couldn't afford to have monads in their tight-knit battle group. It jjust wasn't acceptable.'
18:56:51 <SamB> but that works fine
18:57:00 <SamB> [finding abbrev 0 at $84][finding abbrev 1 at $8c][(0,"look"),(5,"map")]
18:57:00 <SamB> [(0,"look"),(5,"map")]
18:57:23 <oerjan> dozer: ah yes, that MonadPlus is broken
18:57:43 <oerjan> it runs both IO actions before combining them
18:57:58 <glen_quagmire> val <- parse input;    val :: Either Err Val  ;    how can I pass val to eval?  eval :: Val -> Wrap Val
18:58:01 <wagle_home> wy, there was one place where i had to use instanceOf and force a cast..  dont remember what it was
18:58:01 <dozer> oerjan: ah, ok, that sounds like it matches my symptoms
18:58:23 <wy> wagle_home: I used lots of instanceof
18:58:48 <glen_quagmire> case parse input of  Left err -> throwError "wrong" ; Right val -> eval val      is this ok?
18:58:49 <Toxaris> wy: that's bad. instanceof is akin of goto in spirit.
18:59:02 <gwern> SamB: guess I'll have to report it, but when they ask for more info, I'll have trouble I suppose
18:59:08 <wy> Toxaris: but what else can I do
18:59:14 <gwern> 'Cons turned to Cudder, "Report?" Cudder was dressed in the standard garb of the Haskell nomads - relatively light armor guilded with the holy symbols of Haskell. The Nomads didn't need much armor - they travelled fast and they travelled hard, almost as hard as the Sussman rides your sister's ass every night when you're alone in your room whacking off to the sacred tomes. And they were armed to the teeth. They provided a deterministic ...
18:59:20 <gwern> ... and constant effect to the battle, such that their arrival could almost be curried to optimize the battle's execution speed and bring it to a quick close.'
18:59:32 <Toxaris> wy: use more classes :)
19:00:18 <dolio> Write your own if statement using anonymous inner classes instead of lambda expressions.
19:00:34 <dozer> oerjan: so if I re-write that to be something like: mplus x y = MaybeT $ case (runMaybeT x) of Just a -> return a ; Nothing -> ...
19:00:51 <oerjan> dozer: i was pasting
19:01:03 <wy> uh...
19:01:18 <dozer> oerjan: paste away...
19:02:17 <Toxaris> wy: and use a sensible language with multiple inheritance (or mixins) and multimethods :)
19:02:26 <Toxaris> (not that i know any)
19:02:45 <wy> CLOS?
19:02:56 <wy> can haskell do that?
19:03:43 <dolio> mplus mx my = MaybeT $ runMaybeT mx >>= \x -> case x of Just a -> return a ; Nothing -> my
19:03:46 <dolio> I think.
19:03:55 <dolio> Oops, you need a runMaybeT around the my.
19:03:56 <oerjan> http://hpaste.org/6467#a1
19:04:07 <glen_quagmire> what I want to do:  read user input -> parse and eval input -> print result -> read user input ....  meanwhile, parse and eval maintains state.  repl = do i <- getLine; result <- parseAndEval i; repl will not maintain the state. Do I have to put the state in IO monad to maintain the state?
19:04:37 <Toxaris> sensible = statically typed and featuring syntax
19:04:46 <scook0> wy: the syntax would be nasty, and the type encodings would be horrendous (or unsafe), so probably no
19:04:46 <lambdabot> scook0: You have 1 new message. '/msg lambdabot @messages' to read it.
19:04:58 <oerjan> dolio: return a doesn't quite agree with mine either
19:05:13 <dolio> I suppose not..
19:05:27 <wy> scook0: you mean haskell?
19:05:39 <dolio> Yeah, yours is right.
19:06:10 <scook0> wy: yeah
19:06:48 <wy> scook0: hmm that's weird. I thought haskell is good at everything
19:06:55 <Maddas> Nothing is.
19:07:43 <shepheb> is there a pointless way to update a data field? ie. an alternative to \x -> x{ field = newval }
19:07:50 <Toxaris> wy: as i understand it, it's not clear what's subtyping means for Haskell. It's not clear for Java either, but the Java people don't care.
19:07:58 <oerjan> glen_quagmire: er that do should be in your combined monad, and you left out the liftIO's i suggested
19:08:17 <scook0> shepheb: not unless you write a bunch of setters yourself, or use TH to derive them
19:08:22 <oerjan> (which are necessary for doing IO in a transformed monad)
19:08:27 <scook0> (which code already exists to do)
19:08:49 <shepheb> scook0: I was afraid of that. ah well.
19:09:24 <SamB> gwern: in any case, I've pushed your patches
19:09:43 <gwern> SamB: I noticed
19:09:47 <SamB> thanks for sending them
19:10:00 <gwern> SamB: just to double check, your architecture is i386 and not i686 or x86_64?
19:10:04 <oerjan> dozer: did that help?
19:10:18 <gwern> SamB: well, I plan to put it up on hackage sooner or later - to join the other Game stuff there
19:10:33 <SamB> why do you say "and not i686"?
19:10:51 <scook0> gwern: (re HSCurses) I'm writing a list of the reasons why I decided not to modify HSCurses
19:10:51 <oerjan> glen_quagmire: btw do launch repl from the IO monad you would do something like main = execStateT repl initialState
19:10:55 <gwern> SamB: it might make a difference. I believe in too much info in bug reports, not too little
19:10:56 <oerjan> *to
19:10:57 <ddarius> Toxaris: What subtyping would mean is more or less clear.  Haskell just doesn't have it.
19:11:07 <scook0> and I am, in principle, not opposed to integrating my stuff back
19:11:08 <wy> Toxaris: I've thought about a way to eliminate the notion of subtyping
19:11:11 <SamB> gwern: my CPU happens to be an i686
19:11:12 <gwern> scook0: ok. I'm sure both I an him are interested in your reasons
19:11:15 <SamB> P4, to be specific
19:11:26 <Toxaris> wy: how so?
19:11:26 <gwern> SamB: alright
19:12:02 <wy> It's not very useful to say a type is a subtype of another
19:13:16 <dozer> oerjan: in ghci it typechecks fine, but for some reason when I put it in a file, I get an infinite type error
19:13:27 <oerjan> huh
19:13:31 <gwern> SamB: and your OS?
19:13:42 <wy> there will stil be subtyping, but it's included in something more general so that we don't need a distinct notion for it
19:13:57 <Excedrin> dozer: are you running ghci with -fglasgow-exts ?
19:14:11 <oerjan> maybe i messed up something
19:14:24 <SamB> Linux hydrogen 2.6.22-2-686 #1 SMP Fri Aug 31 00:24:01 UTC 2007 i686 GNU/Linux
19:14:27 <joed> hmmm, something I probably could find on the lists bit is ghci now all kosher with Leopard? I had some major issues with it, ghc working just fine
19:14:53 * gwern guesses that was from uname -a
19:15:03 <SamB> indeed
19:15:08 <shapr> I wish references would give section numbers instead of page numbers. Papers on an author's website often don't have the journal page numbers.
19:15:36 <dozer> oerjan: ah, I think the code you pasted is (Monad m) => MaybeT m (Maybe a) -> MaybeT m a -> MaybeT m a
19:15:36 <wy> I'd rather say it later when I got it clear
19:15:41 <SamB> shapr: perhaps the authors just ought to typeset the papers with the proper page numbering
19:15:57 <Toxaris> wy: hehe no prob.
19:16:00 <gwern> http://hackage.haskell.org/trac/ghc/ticket/2164 <-- looking at this I realize just how many packages I have installed
19:16:03 <lambdabot> Title: #2164 (zmachine: internal error: task 0xa031e0: main thread 1 has been GC'd) - G ...
19:16:27 <wy> Toxaris: It's somewhat like structural subtyping
19:16:35 <shapr> SamB: I think that's hard to do when the author copies are usually what is sent to the journal.
19:17:21 <oerjan> dozer: it typechecks here
19:17:24 <SamB> shapr: they could rerun the typesetting after they recieve their copy...
19:17:28 <dcoutts> gwern: that's even more than I have registered
19:17:43 <dozer> oerjan: paste agan?
19:18:00 * gwern is amused
19:18:10 <SamB> though I guess section numbers are more informative
19:18:27 <Toxaris> wy: an important point is the difference between subclassing and subtyping. imho oo languages should have different notions for these different things.
19:18:33 <SamB> maybe the articles in a journal should eacch get their own numberspace ;-)
19:18:37 <dcoutts> gwern: $ time ghc-pkg list > /dev/null
19:18:40 <oerjan> dozer: http://hpaste.org/6467#a2
19:18:53 <oerjan> the rest is directly from the wiki
19:19:10 <dcoutts> gwern: takes 1.3s user time on my box
19:19:10 <gwern> $ghc-pkg list > /dev/null  1.20s user 0.00s system 100% cpu 1.197 total
19:19:17 <dcoutts> gwern: you've got a faster machine :-)
19:19:25 <oerjan> dozer: maybe you tried dolio's version? :)
19:19:35 <wy> Toxaris: I tend to not think in an oo language. The idea of "everything is an object" is toxic
19:19:57 <gwern> dcoutts: well, I spent a good 800USD on the parts, I'd hope it'd be fast (I'd just as soon not need to upgrade for some years)
19:20:02 <dcoutts> gwern: it's annoying since it adds that long to every ghc invocation when building stuff
19:20:20 <dcoutts> I filed it as a perf bug
19:20:30 <gwern> plus - quadcore! for concurrency playing around goodness
19:20:31 <dcoutts> it should be using a binary cache of the package db
19:20:33 <gwern> dcoutts: really - is that in configure or install?
19:20:45 <glen_quagmire> oerjan: thank you!
19:20:50 <Toxaris> wy: why?
19:20:50 <dozer> got it oerjan :) I had a (Just a -> return a) rather than (Just _ -> return mx)
19:21:02 <dcoutts> gwern: it happens three times during configure, and once per lib/exe
19:21:09 <wy> Toxaris: they put methods into objects, then they have "static methods", then they want "external methods"...
19:21:30 <gwern> ouch... I was thinking configure seemed kind of slow >.< - 3.6 seconds just for that
19:21:40 <wy> Toxaris: That betrayed the truth that methods shouldn't belong to objects
19:21:42 <dozer> that has fixed it :)
19:21:43 <dcoutts> gwern: three times because we call ghc-pkg list and there are two other places where we call ghc during configure in such a way that ghc has to parse its package conf file
19:22:02 <Maddas> wy: Are you talking about any particular language?
19:22:05 <dcoutts> gwern: it's all down to the overhead of using 'reads' on the content of the package.conf
19:22:13 <dozer> oerjan: thanks for all the help
19:22:24 <dcoutts> gwern: as you know, Read / reads is a very slow parser
19:22:26 * gwern chants, performance doesn't matter, performance doesn't matter...
19:22:27 <gwern> well, it's not like autotools is any speed demon
19:22:27 <wy> Maddas: I'm talking about almost all oo languages, excluding CLOS
19:22:32 <Maddas> wy: Ok.
19:22:43 <Maddas> Even in CLOS, though, everything is an object ;-)
19:22:50 <gwern> dcoutts: indeed. I'm a little surprised, I thought it'd be using something faster (parsec?)
19:22:51 * Maddas has to run
19:23:02 <dcoutts> gwern: just Read/Show
19:23:02 <dozer> oerjan: why is the version on the wiki forcing evaluation eagerly then?
19:23:08 <wy> Maddas: uhh... is it?
19:23:18 <solrize> parsec is pretty slow too, i thought
19:23:26 <dozer> oerjan: is it the liftM2?
19:23:29 <oerjan> :)
19:23:35 * gwern suspects it's a lot faster than read/show
19:23:41 <dcoutts> gwern: and it'll be worse when cabal calls ghc in single shot mode when it does parallel builds, then it'll be 1.2 sec overhead per module.
19:23:58 <dcoutts> it just needs to use a binary format like it does for .hi files
19:24:09 <oerjan> dozer: yeah, liftM2 only changes results, not actions run.  i think i'll edit the wiki version
19:24:52 <wy> Maddas: I don't know how it is implemented
19:25:02 <dozer> oerjan: k, well, I've played 'cheating' x0 where I can place any piece in any order, and I've played player-turn x0, and both seem to exit on win now, as expected
19:25:22 <wy> but it seems that most functions in CLOS are outside of objects
19:25:58 <cjs> So, getting yi installed is an interesting exercise.
19:26:02 <Toxaris> wy: what do you mean by "method in a object"?
19:26:31 <wy> Toxaris: maybe I should say class
19:26:36 <Toxaris> (I don't think the meaning of OO is well-defined)
19:26:44 <cjs> For vty 3.0.1, what does "Setup.lhs: vty.cabal:22: 'Executable' stanza starting with field 'build-depends'" mean? That I have some old libraries?
19:26:50 <gwern> cjs: no kidding. what error did you run into?
19:27:11 <gwern> cjs: what ghc and cabal you using?
19:27:13 <dozer> Toxaris: it seems to be defined by what ppl claim it will do for your dev process, not so much by what features it provides
19:27:15 <wy> I thought CLOS is an exception because it's based on generic functions, not message passing
19:27:41 <cjs> ghc 6.6.1, and the Cabal that I assume came with it.
19:28:31 <gwern> cjs: just stop there. there is no way you are going to install yi with 6.6.1
19:29:00 <cjs> Too old?
19:29:06 <cjs> Or too new?
19:29:10 <sorear> what!?
19:29:30 <sorear> yi *predates* ghc 6
19:29:35 <gwern> cjs: too old. much too old. you need 6.8.2
19:29:39 <sorear> how can it possibly require 6.8
19:29:44 <sorear> it predates 6.6
19:29:48 <gwern> sorear: I sort of assume he's talking about darcs yi
19:29:49 <cjs> Oh, there's a 6.8.2 out. Huh.
19:29:54 <cjs> No, 0.3.
19:30:01 * gwern notes that funny thing, programs evolve
19:30:12 <gwern> oh. hm. I think 0.3 may've required 6.8.2 as well
19:30:48 * SamB hopes that, now that he's got Jhc recognizing ?? and ? kinds in sourcefiles, it will actually compile Control.Monad.Instances
19:30:58 <gwern> 'tested-with:    GHC==6.8.2' yeah, 0.3 wants 6.8.2
19:31:10 <SamB> (You see, that's how I'm telling Jhc the kind of (->)
19:31:44 <cjs> BIAS.
19:32:08 <glen_quagmire> what is meaning of liftIO ? document only has type specification
19:32:36 <cjs> You'd think that with Lennart as a NetBSD developer we'd have an up-to-date ghc.
19:32:41 <gwern> ..ok, I think cjs was joking there. I hope so
19:32:54 <oerjan> glen_quagmire: it's for lifting IO actions into other monads that support it
19:32:56 <dons> cjs, he's not a current dev
19:33:22 <shepheb> gwern: I'm pretty sure cjs meant "back in a second", and wasn't calling us biased.
19:33:34 <shepheb> that threw me for a minute there
19:33:36 <oerjan> (mainly monads built by using transformers on IO)
19:33:44 <gwern> shepheb: guess I learned a new acronym then
19:34:02 <cjs> Huh? I was away for a moment....and Lennart is an "active" NetBSD developer, I believe, at least by the rules of the NetBSD foundation....I'm confused.
19:34:23 <glen_quagmire> so, for all IO monad related commands, I have to prefix it with liftIO. like, liftIO $ hFlush stdout
19:34:29 * SamB wishes for the n^3rd time that JHC's base wasn't so tangled
19:34:33 <oerjan> glen_quagmire: yeah
19:34:52 <glen_quagmire> thank you oerjan . it starts to make sense
19:35:10 <scook0> glen_quagmire: if you want to do a bunch in a row, remember that you can do liftIO $ do
19:35:49 <cjs> Oh, yes, someone did update it!
19:37:14 <glen_quagmire> i would never have thought that i should run userPrompt, parse, eval, and print  all in my monad
19:37:37 <lispy> SamB: I thought you just said, "nerd" time in l33t
19:37:39 <solrize> is it reasonable to use parsec to parse complicated binary data formats?
19:38:03 <SamB> solrize: not really
19:38:08 <solrize> hmm ok
19:38:09 <solrize> thanks
19:38:12 <cjs> What does one use?
19:38:17 <ddarius> With Parsec3 maybe, but Data.Binary is "the" thing.
19:38:27 <lispy> Parsec3?
19:38:40 <oerjan> glen_quagmire: well parse probably has parts that are just in the Parsec monad i would guess? :)
19:38:44 <dons> ddarius: have you looked into the performance issues reported for parsec3 ?
19:38:46 <lispy> who is working on Parsec3?
19:38:47 <cjs> particularly for interesting formats that involve things such as integers encoded in variable numbers of bits?
19:38:54 <solrize> data.binary is in hackage?
19:38:56 <dons> solrize: i think perhaps Data.Binary and bytestring-readp ?
19:38:58 <dons> solrize: sure.
19:39:01 <dons> ?hackage binary
19:39:01 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/binary
19:39:10 <solrize> thanks
19:39:13 <dons> its aimed at parsing complicated binary formats
19:39:19 <dons> but not too complicated :)
19:39:24 <solrize> http://code.haskell.org/binary/
19:39:25 <lambdabot> Title: Data.Binary - efficient, pure binary serialisation for Haskell
19:39:26 <ddarius> dons: No, but they were expected.  I don't think xerox did any performance tuning and I know I didn't.  Also, for Strings there's pretty much no reason to expect parsec3 to be faster.
19:39:40 <solrize> yah!  it uses bytestring :)
19:39:50 <dons> ddarius: ok
19:39:55 <ddarius> dons: However, I am interested in improving performance and I have some ideas that may make a difference.
19:39:57 <dons> solrize: it should rock.
19:40:01 <lispy> ddarius: hmm...then what was the point of parsec3?
19:40:06 <dons> please report a bug, if you find it does not rock to your expectations
19:40:31 <ddarius> lispy: You can use it over bytestrings not just strings and it lets you do more (it's a monad transformer not just a monad)
19:41:09 <ddarius> Of course, it letting you do more means it's going to be harder to make it faster and naively you should expect it to be slower for trivially "ported" parsec2 code.
19:41:22 <lispy> I see
19:41:57 <Saizan> ddarius: what's the type of e.g. many in parsec3?
19:42:07 <solrize> oh cool, it's a typeclass, you can write serializers/deserializers for arbitrary datatypes
19:42:20 <dons> solrize: right
19:42:26 <dons> and it super super fast
19:42:26 <lispy> solrize: ah the beauty of haskell :)
19:42:29 <solrize> and it uses generics in some mysterious way to get the right result type :)
19:42:39 <dons> like >100M/second :)
19:42:52 <dons> solrize: oh, "Generics" in the boring java sense, yeah
19:43:01 <dons> not generics in the scary higher kinded haskell sense
19:43:10 <solrize> hmm well it uses SYB
19:43:12 <dons> it just dispatches based on the type (statically)
19:43:16 <dons> no.
19:43:23 <SamB> hmm, I think I've nearly got Control.Monad.Instances typechecking in Jhc...
19:43:25 <ddarius> Saizan: The same as before just with an extra Monad m => parameter
19:43:28 <SamB> that's cool.
19:43:29 <dons> there's a script you can use to derive Binary using SYB
19:43:33 <dons> but its not part of Data.Binary itself
19:43:57 <solrize> i see, so you can generate put/get for complex types automatically with the script?
19:44:01 <lispy> using SYB or drift?
19:44:10 <SamB> both can derive it
19:44:13 <SamB> but not the same way
19:44:16 <SamB> afaik
19:44:37 * ddarius hugs wget
19:44:38 <lispy> deriving it via SYB is interesting, I wouldn't have guessed you could do that
19:44:55 <solrize> anyway it looks way cool, exactly the right thing
19:44:56 <bd_> a 'script'? Not magic typeclass hackery?
19:45:34 <lispy> SYB is scrape your boiler plate, right?
19:45:42 <wy> cjs: is he?
19:45:51 <dolio> Heh.
19:45:52 <Saizan> bd_: SYB at runtime kills performance, i suppose
19:45:55 <dolio> Scrap.
19:46:04 <lispy> dolio: thanks, yeah typo :)
19:46:33 <solrize> yeah i looked at the SYB papers a while back and they were baffling, but happs uses it so i figured it was something i'd have to study at some time or another
19:46:46 <bd_> Saizan: Well, SYB is /only/ at runtime, so I don't see the difference.
19:46:50 <bd_> or rather
19:47:08 <bd_> you can't boil it away in a script, if anything the compiler takes it away at inlining/rewrite rules
19:47:42 <SamB> hmm. Apparantly the typechecker needs to be convinced that (->) a b is the same as (a -> b)...
19:47:47 <bd_> so if the script uses SYB... but doesn't put it into the code... then it's not using SYB, it't just generating an instance :)
19:47:53 <lispy> if dons says 'script', I wouldn't rule out rewrite rules automatically
19:47:56 <SamB> I guess that's what John meant about converting back and forth
19:48:07 <cjs> wy: Lennart?
19:48:18 <SamB> bd_: derive may use SYB...
19:48:32 <wy> cjs: yes I saw he wrote some NetBSD drivers, but that might be a long time ago?
19:48:43 <bd_> SamB: deriving, you mean...?
19:49:14 <solrize> i wonder if there's a way to preprocess parsec grammars into these things
19:49:18 <wkh> does anyone know of examples of using haskell for code generation? i don't mean compilation, i mean like generating database access layers for web applications
19:49:18 <cjs> Oh, he's still a developer, yes. Not sure when his last commit was, but I could find out if you're terribly interested.
19:50:02 <cjs> Oh, maybe not. His shell is nologin.
19:50:24 <lispy> wkh: I created an embedded language in haskell to generate procmail configurations
19:50:39 <wkh> lispy: do you have any links or anything i can look at..?
19:50:48 <lispy> wkh: sure, just a second
19:50:51 <wkh> great, thanks
19:51:27 <lispy> wkh: I used to have a wikipage describing it, but my wiki went down and I haven't restored it yet, http://projects.codersbase.com/repos/autoproc/
19:51:27 <lambdabot> Title: Index of /repos/autoproc
19:51:40 <wkh> cool, thanks
19:51:44 <lispy> wkh: in general I think you want to search for the topic of 'embedded domain specific languages'
19:51:52 <wkh> yeah, that's what i've been reading up on
19:52:19 <gwern> wkh: I think a lot of the SQL bindings generate SQL guaranteed to be typesafe
19:52:27 <lispy> wkh: hopefully that coed isn't too scary, it was one of the first things I ever wrote in Haskell and it really doesn't do that much other than help you write well formed procmail
19:52:38 <gwern> lispy: I loathe the procmail config; would your utility be of help?
19:53:02 <lispy> gwern: Sure, I used it actually to maintain my procmail stuff until I switched to gmail
19:53:33 <lispy> gwern: I even added a way to do tagging with procmail but never really used it because that was right when I switched to gmail
19:53:57 <gwern> a makefile. guess this is from before cabl became widespread
19:54:06 <glen_quagmire> yay it worked! i feel much more manly than when I eliminated all template errors in C++
19:54:22 <lispy> gwern: I don't think cabal was invented yet
19:54:52 <solrize> are there any error handling recipes for Data.Binary?  i.e. with EitherT or something like that?
19:55:09 <glen_quagmire> oerjan++
19:55:23 <gwern> the funny thing is, most of the couple thousands lines in my .procmailrc are one-off sed recipes for stripping out email signatures
19:55:27 <gwern> and ads. I really hate the ads
19:55:28 <oerjan> heh :)
19:55:36 <solrize> lol
19:56:08 <solrize> wow
19:56:10 <solrize> Debian From Scratch
19:56:10 <solrize>     A single, full debian rescue CD. The tool that generates these ISO images (dfsbuild) is written in Haskell.
19:56:15 <solrize> (from wiki)
19:56:34 <Thiagarajan> i just started learning about monads.....and i have a question...is it right to think about monads,specifically the bind operator as abstraction of data transport mechanism
19:56:46 <wy> cjs: are you developing for NetBSD?
19:56:52 <dons> hmm, that's a new metaphor, Thiagarajan
19:56:55 <glen_quagmire> Thiagarajan: i think of (>>=) as semicolon in java
19:57:04 <dons> but yes, they're sometimes thought of as containers, and >>= as glue for moving things between containers
19:57:22 <cjs> Yes, though I'm not particularly active these days, aside from adding and updating packages.
19:57:22 <glen_quagmire> stmt1 ; smmt2  ==>  command1 >>= command2
19:57:41 <cjs> I've got a couple of little projects to do, but the usual time issues.
19:58:05 <kbateman> I'd say (>>) is closer to semicoon in java.
19:58:14 <Thiagarajan> glen_quagmire: thinking of monads as semicolon in java was convenient when using the do syntax...but it confuses me when doing the actual implementation of >>-
19:58:18 <scook0> gwern: http://hpaste.org/6468
19:58:43 <kbateman> There are lots of correct ways to think about monads.
19:59:13 <scook0> lots of broken ones too, but some of those happen to work most of the time :)
19:59:56 <dons> Thiagarajan: but yes, >>= is "plumbing" the state around
19:59:57 <Thiagarajan> dons:hmm..yeah i din't stumble upon that explanation anywhere....but i thought it was appropriate seeing that a lot of application of monads seem to revolve around passing data from point a to point b
20:00:30 <cjb> dons: Hi, left something in scrollback about http://haskell.org/haskellwiki/Potential_projects
20:00:31 <lambdabot> Title: Potential projects - HaskellWiki
20:00:36 <dons> threading state in the background is one obvious way its seen as plumbing
20:00:48 <cjb> dons: Do you think something like this already exists, and if not should I mail the link off to -cafe, etc etc?
20:00:55 <solrize> monads are like bicycles that haskell uses to transport values from function to function.  after you learn to ride them, they become second nature, but until then they are scary and disorienting.  everyone who figures it out ends up writing their own tutorial explaining how they look at it.  this is called the "bike shed effect".  ;-)
20:02:00 <kbateman> Monads are like the blind men and the elephant.
20:02:03 <Thiagarajan> solrize:yeah..i was thinking of writing a tutorial in an hour or so...after i messed around with nondet monad
20:02:25 <scook0> cjb: I know there's already a wiki page that suggests foreign libraries to bind
20:02:30 <solrize> kbateman, yeah it eventually comes down to a unification algorithm :)
20:02:34 <cjb> scook0: oh, cool.  any idea where?
20:02:56 <cjb> ah, I guess here
20:02:58 <cjb> http://haskell.org/haskellwiki/Wanted_libraries
20:02:58 <lambdabot> Title: Wanted libraries - HaskellWiki
20:03:08 <scook0> yup
20:03:15 <lispy> I don't think I understand monads yet, I haven't written a tutorial yet
20:03:41 <kbateman> I think I understand them, but I'm just too lazy to do it.
20:03:41 <SamB> that's silly
20:03:43 <solrize> #
20:03:43 <solrize> # Binary serialisation support should be ported to bytestring, and added to the extralibs bundle   -->  is that data.binary ?
20:03:45 <SamB> I understand them
20:03:55 <SamB> but I never got around to finishing my tutorial
20:04:03 <SamB> which wasn't specifically about monads in any case
20:04:15 <scook0> some of the stuff on that page is probably stale
20:04:33 <lispy> I don't see C bindings to darcs
20:04:36 <lispy> that should be on that list
20:04:48 <solrize> what's the current situation regarding bytestring and unicode?
20:05:27 <SamB> hooray
20:05:37 <SamB> oh rats
20:05:51 <dons> solrize: sounds like an old ticket?
20:06:00 <dons> yeah, Data.Binary is the serialisation support we have
20:06:07 <solrize> that thing i pasted?  it's from "wanted libraries"
20:06:07 <dons> for binary data
20:06:51 <wkh> lispy: you wrote 755 LOC of Haskell to avoid writing 154 LOC of config data?
20:06:53 <wkh> :)
20:07:34 <lispy> wkh: I wrote 755 LoC of Haskell to avoid mis-filtering my mail yet again
20:07:39 <edwardk> @pl \x = Cont $ \f -> f (xmap (flip runCont f) (Cont . const) x)
20:07:39 <lambdabot> (line 1, column 4):
20:07:39 <lambdabot> unexpected "="
20:07:39 <lambdabot> expecting operator, pattern or "->"
20:07:50 <edwardk> @pl \x -> Cont $ \f -> f (xmap (flip runCont f) (Cont . const) x)
20:07:50 <lambdabot> Cont . ap id . flip (flip xmap (Cont . const) . flip runCont)
20:08:03 <solrize> is that the right way to handle unicode if i have to deal with nfkd ?
20:08:03 <gwern> scook0: ok, thanks. I'll send a copy to stefan
20:08:06 <lispy> wkh: I also did it for a class, and only about 2/3 of that was used.  The other 1/3 was for an experimental approach I never used.
20:08:10 <gwern> scook0: do you have an email address?
20:08:30 <wkh> lispy: it's interesting how you did it, i'm reading it over. thanks
20:09:02 <lispy> wkh: yeah, enjoy.  I think my approach is pretty straight forward for how edsls are implemented.
20:09:19 <wkh> as the ruby people say, it reads just like english!!
20:09:24 <lispy> wkh: Oh, I have some code to generate Excel formulas too
20:09:26 <solrize> hmm the House url is dead
20:09:35 <lispy> wkh: would that interest you?
20:09:41 <wkh> lispy: yes please :D
20:09:49 <lispy> wkh: okay, I'll have to package it, just a sec
20:10:01 <scook0> gwern: btw, all the stuff in that list is stuff I've already implemented (i.e. it's not just a wishlist)
20:10:16 <edwardk> @pl \x -> Cont $ \f -> f (xmap  (Cont . const) (flip runCont f) x)
20:10:16 <lambdabot> Cont . ap id . flip (xmap (Cont . const) . flip runCont)
20:10:21 <edwardk> not much better
20:10:37 <sethk> solrize, I downloaded it a couple of weeks ago.  Not sure of the URL, bug google found it
20:10:38 <gwern> scook0: heck, I'll just CC you in the email
20:10:46 <gwern> scook0: gotcher
20:11:39 <Maddas> wy: Well, what I pointed was that everything can be an object in CLOS (I am not sure whether everything actually is, but most things are). It's just that objects don't 'own' methods in any sense. And I find that model much, much nicer than the typical OO model as well.
20:12:07 <atp> CLOS is cool
20:13:09 <Maddas> The generic function model seems to blend in much nicer with the ordinary, OO-less model.
20:14:00 <mofmo1> say i had a tree and i want to edit it
20:14:02 <lispy> hpaste doesn't announce anymore
20:14:08 <lispy> wkh: http://hpaste.org/6469
20:14:13 <dons> !paste
20:14:15 <dons> hmm
20:14:17 <gwern> lispy: your autoproc is very interesting; I think I'll cabalize and hackage it if I can figure out how to have a config which doesn't need to be compiled in
20:14:17 <lispy> wkh: turned out to be just one module
20:14:26 <mofmo1> if i did the good old thread through method with all functional operations, wouldnt this be very inefficient?
20:14:26 <gwern> > 2 + 2
20:14:29 <mofmo1> in terms of coding?
20:14:30 <gwern> @quote bot
20:14:30 <lambdabot> Renkin says: Is lambdabot omnipotent or something?
20:14:30 <lambdabot>  4
20:14:35 <scook0> I'm not entirely convinced that generic functions should completely replace message sending
20:14:55 <scook0> though I imagine that if you have only one, GFs are probably better
20:14:55 <lispy> gwern: okay, but part of the point of an eDSL is that you compile it in the host language :)
20:15:04 <lispy> gwern: but maybe I misunderstood
20:15:17 <lispy> gwern: please send me the patches if you get it working
20:15:32 <gwern> lispy: sure, but think of it this way - how would you cabal-install autoproc?
20:15:43 <Maddas> scook0: Right, wy (who isn't here anymore, I just noticed) was complainign about everything being shoehorned into one way of doing it.
20:15:53 <gwern> (that's half the draw of hackage for me, cabal-install)
20:16:05 <lispy> gwern: Yeah, I don't think it makes sense with cabal-install
20:16:30 <lispy> gwern: you could try some template haskell tricks though
20:16:40 <lispy> gwern: use TH + Haskell98 parser?
20:16:44 <gwern> lispy: offhand, I think the xmonad model might make sense, since Rules.hs is still a Haskell module, no?
20:16:48 <lispy> splice in the config at run-time
20:17:04 <lispy> gwern: I've never looked at xmonad.  What do they do?
20:17:07 <gwern> lispy: heh. I don't know how to do either
20:17:10 <lispy> hs-plugins could probably work too.
20:17:31 <EvilTerran> lispy, you configure xmonad by editing (one of) the source files and rebuilding
20:17:46 <Toxaris> mofmo1: you might be interested in zippers. they allow to move around in a datastructure and change the current position.
20:17:49 <lispy> EvilTerran: oh, so how do you cabal-install xmonad?
20:18:06 <dcoutts> lispy: easy: cabal install xmonad
20:18:18 <dcoutts> just like every other package on hackage
20:18:21 <gwern> lispy: xmonad is compiled with a default config baked in; then when you run it, it looks for a .xmonad/xmonad.hs, and if it exists, it compiles *that* instead and runs the new one on top of itself
20:18:24 <lispy> wkh: The cool, very cool, thing about the Excel code is that you use the normal Haskell numeric functions and get back excel formulas :)
20:18:33 <mofmo1> toxaris: just a general question. I was reading over set-car! today
20:18:45 <mofmo1> and set-cdr! for that matter
20:18:46 <gwern> lispy: thus you cabal install xmonad && cabal install xmonad-contrib, and then create a xmonad.hs if you want to customize it
20:18:52 <Saizan> lispy: the xmonad executable checks if there's ~/.xmonad/xmonad.hs and calls ghc to build it automatically
20:18:53 <Toxaris> mofmo1: and zippers are purely functional
20:18:54 <lispy> gwern: ah, well you only run autoproc when you change the config
20:19:16 <dcoutts> lispy: the ~/.xmonad/xmonad.hs gets built against the installed xmonad lib
20:19:19 <wkh> lispy: yeah, i'm looking over it and playing around with it in ghci. very cool...
20:19:28 <lispy> gwern: so you might need a daemon process to monitor ~/.autoproc/rules.hs
20:19:47 <dcoutts> @where autoproc
20:19:47 <lambdabot> I know nothing about autoproc.
20:20:09 <lispy> dcoutts: http://projects.codersbase.com/repos/autoproc/
20:20:09 <lambdabot> Title: Index of /repos/autoproc
20:20:19 <dcoutts> @where+ autoproc http://projects.codersbase.com/repos/autoproc/
20:20:20 <lambdabot> It is stored.
20:20:32 <Toxaris> mofmo1: you can wrap the explicit threading of current state in a monad to arrive at a set-car like interface
20:20:48 <lispy> dcoutts: because of bugs in lambdabot that's probably the 3rd time that's been added :)
20:20:53 <dcoutts> lispy: oh it's a procmail style thing?
20:20:54 <lispy> let's hope it sticks :)
20:21:01 <gwern> lispy: I was thinking: you cabal-install autoproc; autoproc comes with a minimalistic set in Filter.hs; whenever you run the autoproc bin (from /usr/bin/autoproc or wherever), it looks for a .autoprocrc; if it exists, it calls ghc on it, fork/execs it, and *then* autoproc turns the Rules into a .procmailrc
20:21:07 <lispy> dcoutts: yeah, you use an edsl to generate procmail recipes
20:21:13 <mofmo1> that reminds me, read more about transformers
20:21:26 <gwern> otherwise it dumps out a the default .procmailrc that is dervied from the default Rules
20:21:28 <lispy> gwern: sounds great
20:21:29 <dcoutts> lispy: and the rules are compiled against the autoproc lib?
20:21:46 <lispy> dcoutts: nope, it generates a ~/.procmailrc
20:21:52 <lispy> dcoutts: on stdout :)
20:22:08 <gwern> lispy: the trick is to make .autoprorc a complete replacement for main.hs (whatever it is), so you need to expose all of autoprocrc as a library
20:22:27 <gwern> then you can 'locally' override the minimalist Rules module - if any opf this is making sense
20:22:30 <lispy> gwern: it's very small, so hopefully that is easy?
20:22:41 <dcoutts> lispy: ah, so you write a small rules.hs which is built against the rest of the autoproc code and that program generates a procmail script
20:22:50 <lispy> dcoutts: correct
20:23:05 <lispy> and you can decide higher order rules and whatnot as needed
20:23:08 <dcoutts> lispy: sounds like the xmonad model would work fine
20:23:09 <lispy> since it's all haskell
20:25:07 <dcoutts> lispy: so you'd autoproc rules.hs > recipes
20:25:32 <dcoutts> the autoproc program would compile rules.hs against the autoproc lib and run that program
20:25:52 <lispy> what is the autoproc lib?
20:26:07 <lispy> Oh
20:26:14 <lispy> autoproc lib is everything except rules.hs
20:26:17 <dcoutts> right
20:26:25 <dcoutts> everything that rules.hs imports
20:26:38 <gwern> well, if we're defining rules.hs as contaiing 'main'
20:27:08 <dcoutts> if you like, that's not necessary
20:27:14 <lispy> gwern: You seemed to be the most interested in this at the moment, so I think you should do it however  you think makes sense.
20:27:31 <lispy> I don't use it anymore
20:27:46 <gwern> in this case, you'd actually want to have everything as a libraary except autoproc.hs, since that contains main
20:28:12 <lispy> gwern: currently there is some configuration in Configuration.hs too
20:28:18 <lispy> so we'll want to move that also
20:28:24 <glen_quagmire> :t (>>-
20:28:26 <lambdabot> parse error (possibly incorrect indentation)
20:28:53 <gwern> you see in autoproc.hs where 'import Rules (rules)'? and how main is basically defined as 'putStrLn $ showProcmailrc $ concatMap generate $ execWriter rules'? you'd rewrite main to use 'myRules' and define 'myRules' as some mutation of the 'rules' Rules provides
20:29:08 <gwern> lispy: oh hum. you're right, those variables could vary
20:30:03 <lispy> gwern: I think Configuration is only used in Classifier.hs
20:30:09 <solrize> wow you can tell ghc exactly what types to specialize to   (solrize is looking at codec/Binary/UTF8/Generic.hs)
20:40:44 <gwern> solrize: pfft. JHC can superspecialize
20:41:13 <SamB> Well, I think I did fairly well considering how little I understand of JHC's kind inference...
20:41:17 <solrize> yeah, i like the idea of being able to specialize on important types and generically handle less frequently used ones
20:41:36 <solrize> however i also like the idea of using unboxed int32's :)
20:45:19 <SamB> Oh, I fixed Jhc's diagram of the semilattice of kinds in my patch too...
21:03:09 <pa-ching> Is there a Haskell equivalent for memset in the foreign interface? Want to zero some allocated memory...
21:03:34 <bd_> pa-ching: you could set up a ccall to memset
21:03:37 <pa-ching> Guess I could just actually use it yeah hehe
21:03:47 <bd_> (there might be a builtin, I didn't check)
21:03:55 <pa-ching> not that I can see
21:04:00 <pa-ching> although memmove etc are there
21:04:19 <SamB> @hoogle memset
21:04:20 <lambdabot> Data.ByteString.Internal.memset :: Ptr Word8 -> Word8 -> CSize -> IO (Ptr Word8)
21:04:33 <pa-ching> hoho
21:04:34 <pa-ching> Thanks
21:04:38 <SamB> hmm. I'm guessing you should just foreign import it
21:04:44 <pa-ching> alright
21:04:47 <SamB> rather than using something marked ByteString.Internal
21:04:52 <pa-ching> hehe
21:04:56 <SamB> however you could of course copy/paste the code from there
21:05:25 <ddarius> There should be something in the FFI
21:05:28 <ddarius> @where ffi
21:05:28 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
21:05:37 <SamB> ddarius: should /= is
21:06:40 <pa-ching> Eh, no worries
21:06:44 <pa-ching> It's easy enough
21:08:07 <solrize> looks like you just serialize binary data across the ffi and do unsafe casts at both ends?
21:08:42 <SamB> solrize: eh?
21:08:58 <SamB> the point is that the data is already on the other side of the ffi...
21:09:03 * solrize was wonderng how you send data structures to ffi functions
21:09:19 <pa-ching> the Storable typeclass handles that
21:09:23 <solrize> foreign functions that is
21:09:23 <SamB> or, well, I guess pa-ching has not so much data as a place to put it
21:09:44 <pa-ching> (working with openGL textures, just need a nice empty block of memory for blitting)
21:09:55 <Maddas> So many places to put, so little data.
21:11:31 <solrize> pa-ching why not just use haskell code, if it's an initial area
21:11:47 <solrize> if you're going to make all the blt operations foreign
21:12:08 <pa-ching> FreeType is doing the blitting...
21:12:23 <pa-ching> initial area?
21:12:27 <pa-ching> Sorry, not sure what you mean
21:12:49 <solrize> if  you just wanted to make an empty area that you were then going to do a bunch of bitblt operations into
21:13:14 <pa-ching> er, yes..?
21:13:40 <pa-ching> Using Foreign.Marshal.Alloc's allocaBytes
21:13:46 <solrize> yeah
21:14:04 * SamB withPersonHandle $ sleep
21:14:13 <pa-ching> then blit with FreeType and pass the Ptr to OpenGL
21:14:22 <solrize> hmm
21:14:49 <solrize> anyway i'd hope writing a staightforward zeroizing function in ghc should run reasonably fast for that purpose
21:15:09 <pa-ching> One would hope
21:15:11 <solrize> or maybe freetype has an operation to blit a regiont o 0
21:15:13 <solrize> to 0
21:15:23 <pa-ching> But memset is honestly quite convenient
21:15:38 <solrize> i'm surprised it's not there in foreign.marshal
21:15:42 <pa-ching> Yeah, me too
21:15:55 <solrize> these are goign to be small regions like character cells in a browser or something?
21:15:56 <pa-ching> It probably also does fancy things with words to speed it up
21:16:02 <solrize> it says in the performance tips that calling the ffi is quite expensive
21:16:08 <pa-ching> Hoh, really
21:16:18 <dons> you can use memset if you've a Ptr and a length
21:16:22 <pa-ching> Yep
21:16:25 <dons> solrize: its not that expensive.
21:16:46 <pa-ching> I mean this is compiled to C anyways, all it has to do is convert a couple Ints to Int32s
21:16:59 <solrize> oh that's good to know, i was wondering what it was doing, i figured it was locking the gc or something
21:16:59 <scook0> perhaps it's talking about safe foreign calls
21:17:03 <dons> memset is exported from Data.ByteString.Internal btw,
21:17:09 <dons> memset :: Ptr Word8 -> CInt -> CSize -> IO (Ptr Word8)
21:17:13 <scook0> I was under the impression that "unsafe" calls are fast
21:17:28 <pa-ching> Yep
21:17:36 <bd_> dons: It might not be in future versions though - isn't that wnat .Internal usually indicates? :)
21:17:43 <bd_> what*
21:18:06 <dons> bd_: true enough.
21:18:21 <dons> they should be exported from Foreign.C.Something
21:18:47 <bd_> it's not really C though, is it? It's more like a generic Storable task to zero out a block of memory, right?
21:18:54 <dons> its a call to C.
21:19:01 <bd_> that it's implemented with a C memset call is just an implementation detail
21:19:10 <dons> yeah...
21:19:17 <solrize> it says unsafe calls stop all the threads
21:19:49 <bd_> solrize: that's for the old non-threaded RTS I think...
21:19:59 <solrize> hmm, maybe the wiki is out of date
21:21:07 <bd_> hmm
21:21:27 <bd_> I do however note that the call to select in the IO manager is safe though
21:21:29 <dons> "Optionally, an import declaration can specify, after the calling convention, the safety level that
21:21:32 <dons> should be used when invoking an external entity. A safe call is less efficient, but guarantees to
21:21:35 <dons> leave the Haskell system in a state that allows callbacks from the external code. In contrast, an
21:21:38 <dons> unsafe call, while carrying less overhead, must not trigger a callback into the Haskell system."
21:21:47 <bd_> hm, so the call to select should not be safe?
21:22:06 <dons> most calls are 'unsafe' -- that is, they don't mess with stuff in haskell
21:22:20 <dons> very few imports actually call back
21:23:07 <scook0> "safe" these days also runs the call in a separate (pooled) OS thread, right?
21:23:19 <scook0> to prevent foreign calls from blocking haskell execution
21:25:32 <solrize> i find myself wishing for some kind of low level imperative sublanguage inside ghc, that was still properly typed under the haskell type system, and compiled to fast code to get rid of a lot of ffi applications
21:27:24 <dons> that's called unboxed core :)
21:27:32 <solrize> cool :)
21:27:36 <dons> its basically pseudocode for the raw machine
21:28:28 <solrize> googling "unboxed core" found stuff about magnetic core memory and about decomissioned car parts :)
21:29:13 <dons> look up 8.2.¬†Unboxed types and primitive operations in the ghc users' guide
21:29:32 <dons> note that the idea is usually that ghc can optimise high level code to the ideal low level core
21:30:04 <solrize> i thought ghc (for one thing) used boxed ints all over the place
21:30:19 <dons> typically they're optimised away
21:30:27 <solrize> oh cool
21:30:43 <solrize> i guess there's just a bunch of optimization tricks that one gets familiar with
21:30:57 <solrize> i coded some of those euler problems in C and haskell and the C was around 4x faster
21:31:02 <dons> (+) :: Int -> Int -> Int becomes +# :: Int# -> Int# -> Int#  -- the unboxed, raw machine
21:31:08 <dons> 4x is ok for naive coding
21:31:16 <dons> typically i try to aim for 2x or better
21:31:17 <solrize> oh neat, that's what # means
21:31:32 <solrize> 2x is good
21:32:00 <solrize> in some cases it would be good to have inline asm, to use x86 SSE instructions and such
21:32:15 <dons> for that i usually just ffi call C
21:32:38 <bd_> It'd be interesting to be able to supply inlinable asm rewrite rules though...
21:32:43 <dons> if you check the shootout, that's highly optimised, 50% faster to 150% slower than C is around the mark.
21:33:00 <dons> you can of course ffi link asm too
21:33:06 <dons> use inline asm in C, then ffi C
21:33:28 <dons> i've never seen a use for that though :)
21:33:41 <solrize> is it feasible to have an internal compiler using harpy, as a target encoding for something like parsec parsers?
21:34:08 <bd_> dons: nono, I mean, have the haskell NCG inline the assembler right then and there
21:34:22 <dons> yeah. that's fairly accepted use for harpy
21:34:23 <bd_> I don't know, maybe it's not possible for whatever reason
21:34:37 <dons> bd_: it used to be possible, at least.
21:34:45 <solrize> how fast/slow is parsec compared to a careful hand coded parser ?
21:35:06 <BMeph> sohlrize: Consider this, though - how much longer did it take you to think of and write out the solutions of the two, in comparison?
21:35:15 <dons> parsec's pretty good
21:35:29 <dons> if you care about performance , use happy (one of the parser generators)
21:35:54 <solrize> bmeph i wrote the haskell one first, then the c one, i think i wrote the c one faster partly because it was a reimplementation and partly because i'm a lot more experienced with c than haskell
21:36:01 <BMeph> If the C program runs 4x faster, but took 5x longer to write up... and debug... well, :)
21:36:37 <solrize> but yeah, my ambition is to eventually outlaw all c programs everywhere forever :)
21:36:42 <dons> yeah, using haskell to work out the solution, then replace parts with C, is a good approach
21:36:59 <dons> its probably not a good idea to write the original in C. not so great for exploratory math work :)
21:37:01 <BMeph> sohlrize: Okay, that's fair. That approach works, too.
21:37:26 <BMeph> dons: So, you're saying that Haskell is now C's type checking system? ;)
21:38:14 <dons> also good to use QuickCheck to check C code, over the ffi
21:38:47 <solrize> there's certain functions where i don't mind spending extra coding time on, because they are cpu intensive
21:39:02 <solrize> i've just gotten more and more paranoid towards c
21:40:03 <solrize> it looks to me like this core stuff is post-type-erasure ?
21:40:14 <solrize> i was hoping something where all the user level types still got checked
21:41:31 <dons> no, the types are around.
21:41:40 <dons> they're just unboxed, primitive types
21:41:51 <dons> but really, ghc will optimise to this stuff almost all the time
21:41:59 <dons> you can check what is generated by using -ddump-simpl
21:43:07 <solrize> hmm, i guess it takes coding in a C-like style
21:44:14 <BMeph> Just curious, but has anyone (besides me) looked at http://blog.plover.com/CS/udcodes.html
21:44:15 <lambdabot> Title: The Universe of Discourse : Uniquely-decodable codes
21:44:26 <dons> right. you either code at a high level, and look how its optimised, or you code at a low level, and plan how its optimised yourself
21:44:34 <solrize> bmeph, yeah i saw that
21:45:45 <solrize> if you just code straightforwardly with some strictness annotations do you end up with speed like ML ?
21:46:05 <wkh> it always depends on specifics
21:46:10 <wkh> (probably)
21:47:03 <solrize> http://hpaste.org/6470   this always says the func takes 5 microseconds which is way too short
21:47:41 <pa-ching> So how are typeclass lookups implemented anyways..
21:47:52 <pa-ching> Can't just use a v-table, can you..?
21:48:06 <dons> they're usually resolved statically
21:48:21 <pa-ching> ah right
21:48:21 <oerjan> solrize: let b = id $! x  is completely redundant.  the next b <- shadows it
21:48:35 <solrize> oh let me fix that sorry
21:48:43 <bd_> and when static resolution isn't possible, a v-table can be passed in as a hidden parameter
21:48:57 <pa-ching> hmmm..
21:49:28 <solrize> http://hpaste.org/6470#a1  changed, same result
21:49:33 <oerjan> @hoogle evaluate
21:49:33 <lambdabot> Control.Exception.evaluate :: a -> IO a
21:49:38 <pa-ching> But if the instance is in another module, how do you know what the table looks like
21:49:45 <pa-ching> are there IDs or something?
21:49:45 <solrize> the id $! is supposed to force evaluation of x
21:49:47 <solrize> is that right ?
21:49:59 <oerjan> solrize: yeah the let b = is still redundant, due to laziness
21:50:08 <dolio> (id $!) = id
21:50:09 <oerjan> nope
21:50:21 <oerjan> try evaluate x
21:50:27 <oerjan> (the above one)
21:50:36 <solrize> $! doesn't de-lazify?  hmm    ok thanks trying ...
21:50:54 <solrize> espeed.hs:15:10: Not in scope: `evaluate'
21:50:55 <oerjan> solrize: it only applies if the result is actually evaluated
21:51:13 <solrize> hmm
21:51:14 <oerjan> solrize: ^^^
21:51:30 <solrize> oh i have to import that
21:51:31 <solrize> sec
21:51:54 <solrize> same result
21:51:57 <dancor> i can't find where in the lambdabot code it actually evaluates haskell code
21:53:52 <solrize> http://hpaste.org/6470#a2
21:54:06 <oerjan> solrize: no no
21:54:10 <oerjan> not let b = ...
21:54:19 <oerjan> just evaluate x, as an action
21:54:30 <solrize> oh ok
21:54:32 <solrize> sec
21:54:35 <oerjan> a let b = ... will never have any effect since nothing uses the b
21:54:51 <solrize> ahhhaa
21:54:59 <TSC> return $! x
21:55:02 <TSC> should do it
21:55:04 <solrize> 89000000   picoseconds
21:55:09 <oerjan> yeah that's another
21:55:19 <solrize> = 89 milliseconds
21:55:22 <solrize> hmm
21:55:24 <oerjan> i forgot that one, although it's even simpler (no imports)
21:55:24 <solrize> actually not so good
21:55:36 <solrize> can i use replicateM 1000 $ evaluate x    ?
21:55:49 <oerjan> no
21:56:00 <oerjan> the x will be shared, and only evaluated once
21:56:37 <oerjan> but you can do mapM_ evaluate listOfValues
21:56:46 <oerjan> i should think
21:57:20 <solrize> is there a lot of overhead to the evaluate and getclocktime?  89 msec for that operation is not so good
21:57:36 <solrize> well i guess i'm comparing it to much fancier implementations
21:57:40 <solrize> so it's ok really :)
22:00:02 <oerjan> um your modexp doesn't look right - it doesn't recurse
22:00:19 <solrize> barf, you're right :)
22:00:25 <solrize> thanks :)
22:00:33 <solrize> musta got confused
22:01:01 <oerjan> although that may not actually help the speed...
22:01:46 <LeCamarade> Hi, a guide to using the Crypto library, please?
22:02:16 <solrize> in fact the modexp is completely wrong
22:02:36 <oerjan> solrize: look at the source for (^)
22:03:07 <solrize> not sure where ^ is but this should be simple to fix
22:03:28 <oerjan> @where prelude
22:03:28 <lambdabot> http://www.haskell.org/onlinereport/standard-prelude.html
22:03:45 <oerjan> in there somewhere
22:03:51 <LeCamarade> ?where crypto
22:03:52 <lambdabot> http://www.haskell.org/crypto
22:04:10 <LeCamarade> ?doc crypto
22:04:10 <lambdabot> crypto not available
22:05:55 <solrize> hmm i fixed it but it's still wrong
22:06:59 <oerjan> the pxn b b should use something else instead of b
22:08:26 <solrize> http://hpaste.org/6470#a3  current version which is still wrong
22:09:53 <Peaker> @src when
22:09:53 <lambdabot> when p s = if p then s else return ()
22:10:04 <Peaker> say, how does that work? Are s and () of the same type?
22:10:16 <solrize> s is supposed to be a monadic action
22:10:21 <oerjan> :t when
22:10:24 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
22:10:34 <solrize> and return () lifts () into the monad
22:10:38 <scook0> s has type m ()
22:10:51 <LeCamarade> s has type Monad m => m ()
22:11:12 <Peaker> oh
22:11:14 <scook0> (for some Monad m, yes)
22:11:15 <Peaker> thanks
22:11:15 <LeCamarade> (So it doesn't have to be an action ... could be Maybe, maybe.)
22:11:39 <solrize> yeah, monadic value, i didn't realize those weren't also called actions
22:12:02 <kbateman> solrize, I wrote a similar powmod function recently that works.  Want it?
22:12:17 <LeCamarade> (Although the do {} makes it look like they are actions. :-\))
22:12:20 <oerjan> solrize: i don't see anything wrong with your last version
22:12:39 <solrize> kbateman, couldn't hurt, i'm just not sure what i did wrong with this one
22:12:47 <solrize> and it passes a few simple tests
22:13:02 <Peaker> would it be useful to have a:  whenvalue p s default = if p then s else return default ?
22:13:04 * LeCamarade fights the urge to escape smileys in (parethesed :-\)) statements.
22:13:16 <oerjan> LeCamarade: Maybe values are considered actions when Maybe is considered as a Monad
22:13:17 <Peaker> I guess that's a normal "if" in that case..
22:13:19 <solrize> oh it's ok now
22:13:56 <Peaker> btw:  if p then t else f    t and f have to be the same type, or only the same class, or either?
22:14:20 <LeCamarade> oerjan: So, basically, any monad is an action, you mean? "Maybe action"? "IO action"? Oh, well.
22:14:31 <oerjan> yeah
22:14:55 <LeCamarade> #haskell: Anybody suffered with the crypto library? I could use some encouragement.
22:15:05 <LeCamarade> Where to find the docs, for one thing?
22:15:14 <kbateman> http://hpaste.org/6470#a4
22:15:17 <solrize> lecamerade i messed with it a little last night
22:15:26 <solrize> main thing i noticed was inconsistency between arg types in different modules
22:15:28 <oerjan> Peaker: same type
22:15:34 <LeCamarade> solrize: Where did you get the docs?
22:15:42 <solrize> and also having to grovel around a lot converting bytes to longwords etc.
22:15:48 <solrize> docs are on hackage if we're talking about the same module
22:15:53 <LeCamarade> All I want is to use the SHA and Blowfish thingies. Need 'em.
22:15:58 <Peaker> oerjan, then why does ghci say, for: if True then 5 else ()       No instance for (Num ())
22:16:11 <LeCamarade> Before I lose it and re-implement.
22:16:28 <solrize> sec
22:16:28 <oerjan> Peaker: because 5 is actually in a class (Num), so theoretically () could me made to fit
22:16:40 <oerjan> by making the type () belong to the class Num
22:17:07 <oerjan> in which case the 5 would be forced to be () too
22:17:09 <solrize> lecamerade http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Crypto-4.1.0
22:17:12 <lambdabot> http://tinyurl.com/yomk9r
22:17:20 <bd_> oerjan: Or it would contain only zero
22:17:40 <solrize> i wonder how fast a modexp i can write in haskell
22:17:44 <Peaker> oerjan, doesn't that mean that the then/else are allowed to be of differing types if those types are in the same class?
22:17:54 <lispy> solrize: pretty fast, want to see mine?
22:17:55 <oerjan> bd_: no, any Num class must implement all integer literals by implementing fromInteger
22:17:59 <solrize> lispy, sure
22:18:17 <bd_> > (fromInteger 256) :: Word8
22:18:18 <lambdabot>  0
22:18:25 <lispy> solrize: it's in here: http://files.codersbase.com/miller-rabin.hs
22:18:25 <bd_> one option I support
22:18:27 <bd_> suppose*
22:18:33 <bd_> is that allowed to be the bottom?
22:18:46 <oerjan> s/class/type/
22:18:52 <Peaker> can I implement a Z_2 or (Z n)  Num type?
22:18:58 <lispy> solrize: it's based on an implementation from a book on computational number theory
22:19:03 <Peaker> fromInteger x = x % n
22:19:21 <oerjan> Peaker: nope, they must be of the same type.
22:19:40 <oerjan> Peaker: yes, you can
22:19:51 <Peaker> oerjan, oh, if () is a Num class, it would use fromInteger on ()?
22:20:12 <Peaker> oerjan, how would it know that fromInteger is the right "convertor"?
22:20:15 <solrize> lispy that's basically the same algorithm i used, you have to do really crazy things to write a super fast modexp
22:20:15 <lispy> what is () as an number?
22:20:19 <oerjan> Peaker: the Word8, Word16 etc. types are essentially that for mod 256 and 65536 respectively
22:20:33 <Peaker> oerjan, I see
22:20:46 <solrize> it would be good if ghc exported the gmpy implementation of modexp since it's using gmpy anyway
22:21:05 <lispy> solrize: well, you might be able to access it
22:21:07 <Peaker> oerjan, How does Haskell know, when trying to match the types of a THEN and ELSE clauses, to try the Num class's fromInteger method?
22:21:19 <lispy> solrize: or, your could look into the source of ghc and make it export it
22:21:51 <lispy> Peaker: I think it knows how from the D-M type checking
22:22:05 <solrize> lispy i think i'm not up to the task of messing with ghc source
22:22:18 <solrize> and anyway the idea would be to distribute apps that use modexp
22:22:24 <oerjan> Peaker: the literal 5 in haskell is always syntactic sugar for fromInteger (5 :: Integer) (yeah it seems a bit circular but it works)
22:22:27 <solrize> and making users hack the compiler to use the app doesn't sound so hot
22:23:05 <lispy> solrize: well, if you hacked Ghc the goal would be to put your modExp in a library so that they'd just need version X or later of ghc and your library :)
22:23:30 <solrize> the ghc maintainers would have to accept the patch no ?
22:23:36 <lispy> right
22:23:41 <oerjan> so the question is just which type of the Num class to try
22:23:46 <Peaker> oerjan, ok, when haskell sees   "someFunc x"  (in this case someFunc is fromInteger) and a "y", will it try to get "y" to be in same class of "x" so that it can also call someFucn on it? Or is this a special-case for fromInteger?
22:24:07 <solrize> http://www.shamus.ie/index.php?page=Benchmarks     here are some speeds to try to beat
22:24:08 <lambdabot> Title: Shamus Software Limited - Benchmarks
22:24:15 <solrize> they are pretty old
22:24:21 <solrize> i think gmpy is comparable if it's not using sse
22:24:33 <lispy> solrize: it's probably not easy, but it would certainly be cool if you wrote gmp library by exposing the same gmp functions that ghc is already using internally
22:25:09 <solrize> you mean import a second instance of gmpy with ffi wrappers around it?
22:25:38 <oerjan> Peaker: the sugar is special for fromInteger, and a couple other cases
22:25:59 <oerjan> Peaker: but x is an Integer, and is not the same as y's type necessarily
22:26:28 <dons> Peaker: there's lots of rewrite rules for fromIntegral and from* functions to turn them into no-ops
22:26:35 <Peaker> oerjan, I don't understand why the sugar causes it to try to "fromInteger" on the ()
22:26:49 <oerjan> Peaker: it doesn't
22:26:50 <Peaker> dons, what's a "rewrite rule"?
22:26:57 <dons> compiler optimisation
22:27:31 <oerjan> it desugars to if True then fromInteger 5 else ()
22:27:53 <Peaker> dons, I see, I just don't understand why Haskell is trying to call fromInteger on y  in the expression:  if True then 5 else y  (Even if I understand that 5 is  fromInteger (5::Integer))
22:28:05 <kbateman> Integer sugar: http://haskell.org/onlinereport/exps.html end of section 3.2
22:28:07 <oerjan> Peaker: it _doesn't_
22:28:08 <lambdabot> Title: The Haskell 98 Report: Expressions
22:28:15 <Peaker> oerjan, then why does it want y to be in Num class?
22:28:17 <oerjan> it only calls it on the 5
22:28:30 <bd_> Peaker: because the true and false branches of the if have to be the same type
22:28:39 <oerjan> because the result of fromInteger is in the Num class
22:28:44 <oerjan> :t fromInteger
22:28:46 <lambdabot> forall a. (Num a) => Integer -> a
22:28:47 <bd_> and since one of them is in Num (because you put 5 there) so must y
22:28:48 <Peaker> bd_, I know they have to be, but Num is not the same type, its the same class
22:29:12 <bd_> Peaker: No, they need to be the same type - that statement tells it that that type, whatever it may be, needs to be in Num
22:29:12 <oerjan> Peaker: the type of the then part is Num a => a, the type of the else part is ()
22:29:27 <Peaker> I see..   fromInteger returns not a specific type, but a specific instance
22:29:38 <Peaker> whew, sorry for missing that part. Thanks! :)
22:29:41 <oerjan> Peaker: it then must make those consistent and unifies to Num () => ()
22:29:43 <bd_> Peaker: eh? oO
22:30:37 <oerjan> that is, both sides must be type () and that type must be in the Num class
22:30:38 <Peaker> oerjan, Yeah, I did not know that the "Num a =>" part was considered part of its type when equating the types.
22:31:03 <oerjan> well... sort of
22:31:30 <bd_> It's not part of the type... but it tells it what the type needs to be. Ie, if you were to write 'Num a => a', 'Num a' isn't part of the type, but tells the compiler that whatever 'a' turns out to be, it has to be in Num
22:31:37 <oerjan> whatever a ends up as must satisfy the Num
22:31:51 <lispy> it's a constraint on the type
22:32:23 <Peaker> How does:  if True then 5 else 6.0       know to convert 5 to a float?
22:32:35 <Peaker> or, how does it know what function to use to do that?
22:32:45 <lispy> Peaker: there is some magic to get numeric constants to work out
22:32:50 <oerjan> Peaker: it becomes Num a => a and Fractional b => b, respectively
22:33:09 <Peaker> lispy, So I can't have that magic for my own classes/types
22:33:20 <oerjan> but Fractional is a subclass of Num, so the Num becomes redundant
22:33:35 <lispy> Peaker: the magic is only that "1" (the literal) is of several different number types
22:33:42 <oerjan> :t 1
22:33:43 <lambdabot> forall t. (Num t) => t
22:33:46 <oerjan> :t 1.0
22:33:47 <lambdabot> forall t. (Fractional t) => t
22:34:12 <lispy> hmm...then what is all the business in the H98 report about default num types?
22:34:26 <Peaker> how is it converting 5 to 5.0? What function is used to do that?
22:34:37 <oerjan> lispy: there are some cases where the type remains ambiguous
22:34:51 <Peaker> (fromInteger 5)::(Fractional a=>a) ?
22:35:20 <oerjan> Peaker: it uses fromInteger on the 5 and fromRational on the 6.0
22:35:57 <lispy> Peaker: fromInteger is reimplemented for each type class
22:36:13 <oerjan> Peaker: Num is a superclass of Fractional, so everything that can be used for all Nums can also be used for all Fractionals
22:36:42 <kbateman> :t \x -> if x then 5 else 5.0
22:36:43 <lambdabot> forall t. (Fractional t) => Bool -> t
22:37:13 <oerjan> lispy: say in 3^2, the type of the 2 does not actually influence the type of the result, so there is no way to infer it completely.  it therefore defaults to Integer.
22:37:17 <Peaker> oerjan, lispy, bd_: Ok, thanks for clearing it all up
22:37:58 <oerjan> lispy: and there is also the Dreaded Monomorphism Restriction which can apply even if the type does appear in the final result
22:38:09 <lispy> DMR
22:38:18 <lispy> it's like DRM, but worse
22:38:38 <oerjan> oh let's not exaggerate :D
22:39:45 * mrd looks for -fno-rights-management
22:39:59 <dancor> so why does plugins-1.1 yell about configure: error: cannot find install-sh or install.sh in "." "./.." "./../.."
22:44:31 <dancor> also here is a perhaps more interesting one.  when i build hs-plugins from darcs it says: ghc-6.8.2: unknown package: bytestring-0.9.0.1 (dependency of ghc-6.8.2)
22:44:53 <dancor> now it is true that i removed 0.9.0.1 and only have 0.9.0.4, but why does it care about that
22:47:54 <lispy> dancor: do you see anything suspicious in the output of ghc-pkg?
22:49:31 <dancor> lispy: well it looks like i have the problem Cale had: http://tuukka.iki.fi/tmp/haskell-2008-01-31.html
22:49:32 <lambdabot> Title: haskell-2008-01-31
22:49:52 <dons> dancor: it links against ghc-api, which depends on 0.9.0.1
22:49:53 <dons> i think
22:49:58 <Cale> which problem?
22:50:17 <Cale> oh
22:50:19 <dancor> i guess my options are to reinstall 0.9.0.1 or rebuild ghc or try to trick it into liking me
22:50:34 <Cale> Oh, reinstall 0.9.0.1
22:50:44 <Cale> It's by far the easiest way to go :)
22:50:44 <lispy> dancor: is there a problem with multiple versions of a library? I don't think there is.
22:50:53 <Cale> lispy: In this case, yes.
22:50:58 <dancor> lispy: no except that i was getting weird things happening
22:51:33 <Cale> lispy: GHC is linked against one particular version, so to use the GHC API, datastructures generated by other libraries have to be compatible with that.
22:51:51 <lispy> Ah
22:52:32 <dancor> i still think something is broken with all of this
22:53:05 <dancor> i guess i'm gentoo-used to being able to compile my problems away
22:53:51 * lispy is allergic to the gentoo way of doing things so feels the need to disagree on prinicple ;)
22:54:05 <lispy> But, who wants to bicker about that here? I don't...
22:54:42 <dancor> i need two versions of bytestring installed today.  how many will i need tomorrow
22:54:42 <lispy> dancor: what were the problems you had with 0.9.0.1?
22:55:08 * dancor disagrees with exponential dependency growth on priciple
22:55:17 <Cale> dancor: No, you really only need one :)
22:55:29 <lispy> If you actually need different versions then whether you compiled it yourself isn't going to make much difference.
22:55:48 <dancor> Cale: i would rather need the latest one
22:55:51 <dancor> heh
22:56:05 <lispy> dancor: you will probably like to use cabal-install for getting/building packages if you're not using it already
22:56:14 * dancor upgrades to ghc 6.10 out of spite
22:57:18 * ivanm passes lispy some anti-histamine
22:57:52 <Heffalump> dancor: and using a magic wand?
22:57:53 * lispy takes the anti-histamine and starts feeling less 'itchy' already.
23:02:10 <lispy> is ghc pretty easy to compile these days?
23:06:02 <dancor> why do i feel like there should be more overlap than there seems to be among hs-plugins,ghci,ghc
23:06:27 <dancor> and lambdabot
23:06:32 <dancor> wrt code evaluation
23:06:43 <Cale> Oh, there should be.
23:06:47 <dancor> (warning i have a very poor understanding of all these programs)
23:06:55 <Cale> hs-plugins was written prior to the ghc-api
23:07:06 <Cale> (well, prior to it being a library)
23:07:43 <dancor> if i want my new program to feature run-time haskell code evaluation
23:07:50 <dancor> what is the right way
23:08:04 <Cale> I only recently chopped a big chunk of hs-plugins out and made it use the ghc-api, but it could probably use the ghc-api for basically everything that it does.
23:08:12 <dancor> i'm guessing it's not system $ "echo " ++ s ++ "|ghc"
23:08:32 <Cale> heh
23:08:54 * LeCamarade >>= work
23:08:55 <Cale> Well, what will the runtime Haskell code evaluation be used to do?
23:11:19 <solrize> lispy i haven't hacked the code or anything but i had no prob compiling 6.8.2 using 6.4
23:11:28 <solrize> i installed 6.4 from binary iirc
23:11:40 <solrize> unfortunately i think there's no other compiler that can compile it
23:13:46 <Cale> Really, you ought not to be compiling GHC yourself unless you're also hacking on it.
23:14:49 <lispy> Cale: well, in dancor's case he could (maybe) compile ghc and swap in whatever version of bytestring
23:15:13 <lispy> (I used the male pronoun out of habbit, I don't actually know if dancor is male)
23:15:30 <solrize> would a female dancor be dancress ?
23:15:45 <lispy> that is dangerously starwars sounding...
23:16:03 <lispy> "Luke, It's a dancor, get out of there!"
23:16:58 <wy> what does -fno-monomorphism-restriction do?
23:17:16 <mauke> disable the monomorphism restriction
23:17:32 <Cale> wy: It turns off a particularly pointless technical restriction which was included in the Haskell report.
23:17:35 <bd_> wy: normally something like this (with no type signature):  foo = fmap succ  would be rejected, because it's polymorphic,but you've not given a type signature to limit the polymorphism
23:18:03 <bd_> -fno-monomorphism-restriction tells it to go on despite the lack of the type signature
23:18:03 <lispy> :t fmap succ
23:18:04 <lambdabot> forall a (f :: * -> *). (Functor f, Enum a) => f a -> f a
23:18:08 <bd_> yep
23:18:33 <mauke> in this case, you could also use foo x = fmap succ x
23:18:33 <Cale> Note that this only applies to pattern bound variables
23:18:53 <dancor> so wait, where is Cabal >=1.3.7
23:18:58 <bd_> mauke: I thought only the type mattered?
23:19:02 <wy> Does this happen only in definitions like that?
23:19:06 <lispy> dancor: in the cabal repository?
23:19:08 <lispy> ?where cabal
23:19:08 <lambdabot> http://www.haskell.org/cabal
23:19:11 <mauke> bd_: no, it must be argumentless
23:19:33 <Cale> wy: It only happens to definitions which don't have function parameters on the left hand side.
23:19:37 <bd_> oh, huh
23:19:48 <bd_> interesting
23:19:50 <dancor> lispy: that only mentions 1.2.3.0
23:20:00 <dancor> ah nm
23:20:30 <Cale> Basically, the reasoning is that pattern-bindings (which is what such definitions are called), normally can be relied upon to be computed once and then shared.
23:20:54 <wy> > showM = show
23:20:55 <lambdabot>  Parse error at "=" (column 7)
23:21:09 <Cale> But if the pattern binding is typeclass-polymorphic, in the implementation, it's really a function.
23:21:24 <Cale> So it won't get memoised.
23:21:43 <bd_> > let showM = show in showM
23:21:45 <lambdabot>  <() -> [Char]>
23:21:54 <Cale> This is exactly the kind of stupid detail which the Report really tries to avoid, but for whatever reason, they decided to include it.
23:21:54 <lispy> Cale: function of an implicit dictionary?
23:21:59 <Cale> lispy: yeah
23:22:06 <mauke> > let f = show in (f 'x', f "x")
23:22:07 <lambdabot>  ("'x'","\"x\"")
23:22:11 <bd_> it seems like it'd have much better been a warning not included in the spec
23:22:18 <Cale> yes.
23:22:28 <lispy> Cale: so what is it in an implementation that doesn't use dictionaries? (oleg says this is possible, further details are beyond me :)
23:22:38 <dolio> @type let showM = show in showM
23:22:39 <lambdabot> forall a. (Show a) => a -> String
23:23:05 <Cale> lispy: In an implementation that doesn't use dictionaries, it might be even more silly.
23:23:25 <dolio> jhc doesn't use dictionaries, no?
23:23:27 <Cale> lispy: But in general, you may end up computing something more than once if it's polymorphic.
23:23:40 <Cale> You need to compute it at least once for each type at which it's used.
23:23:43 <bd_> lispy: You could fire up GHC at runtime to specialize things as needed :D
23:23:57 <bd_> Or your equivalent non-dictionary-using compiler
23:24:04 <Cale> I'm not sure how such implementations deal with polymorphic recursion.
23:24:48 <Cale> Like, how does jhc deal with  f 0 x = show x; f n x = f (n-1) (x,x) ?
23:25:22 <oerjan> o_O
23:25:25 <lispy> > let f 0 x = show x; f n x = f (n-1) (x,x) in f
23:25:25 <Cale> f :: (Show a) => Int -> a -> String
23:25:26 <lambdabot>      Occurs check: cannot construct the infinite type: a = (a, a)
23:25:26 <lambdabot>       Expec...
23:25:35 <Cale> Must include type signature :)
23:25:54 <lispy> > let f :: (Show a) => Int -> a -> String; f 0 x = show x; f n x = f (n-1) (x,x) in f
23:25:55 <lambdabot>  <Int -> () -> [Char]>
23:26:18 <Cale> > let f :: (Show a) => Int -> a -> String; f 0 x = show x; f n x = f (n-1) (x,x) in f 5 0
23:26:18 <lambdabot>  "(((((0,0),(0,0)),((0,0),(0,0))),(((0,0),(0,0)),((0,0),(0,0)))),((((0,0),(0,...
23:26:50 <Cale> I'm not sure how that's handled without dictionary passing.
23:27:17 <Cale> (for more fun, change Int to Integer ;)
23:27:27 <lispy> What about Num b?
23:27:43 <lispy> > let f :: (Num b, Show a) => b -> a -> String; f 0 x = show x; f n x = f (n-1) (x,x) in f
23:27:44 <lambdabot>  <Integer -> () -> [Char]>
23:27:51 <lispy> hmm...
23:27:57 <oerjan> defaulting
23:27:59 <lispy> Cale: why does lambdabot specialize that so much?
23:28:06 <sieni> > let f :: (Show a) => Int -> a -> String; f 0 x = show x; f n x = f (n-1) (x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x) in f 5 0
23:28:07 <lambdabot>        add (Show
23:28:07 <lambdabot>              (a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a...
23:28:19 <sieni> > let f :: (Show a) => Int -> a -> String; f 0 x = show x; f n x = f (n-1) (x,x,x,x,x,x,x,x,x) in f 5 0
23:28:20 <lambdabot>  "(((((0,0,0,0,0,0,0,0,0),(0,0,0,0,0,0,0,0,0),(0,0,0,0,0,0,0,0,0),(0,0,0,0,0,...
23:28:34 <oerjan> lispy: it must give it a specific type in order to show it
23:28:41 <Cale> lispy: extended default rules
23:28:43 <lispy> I wish ghc could build instances of Show (,) at compile time as needed
23:29:01 <Cale> lispy: How would it know how many would be needed?
23:29:09 <Cale> er...
23:29:17 <Cale> You mean for large tuples?
23:29:21 <lispy> ya
23:29:23 <Cale> ah
23:29:34 <lispy> (,...,)
23:30:22 <sieni> vampire-with-closed-eyes-smiley?
23:31:01 <dolio> Cale: Man, jhc takes a long time to compile that. :)
23:31:16 <Cale> dolio: Does it finish?
23:31:24 <dolio> Oops, no, got an error.
23:31:33 <lispy> dolio: oh, please paste it
23:31:37 <lispy> or hpaste it
23:31:40 <dolio> Something about IORefs.
23:31:49 <dolio> Paste what?
23:32:01 <lispy> your error
23:32:20 <lispy> I don't have a copy of jhc to experiment with
23:33:27 <dolio> http://hpaste.org/6471
23:35:52 <Cale> Heh, that's an awesome error message :)
23:36:05 <dolio> Very lucid. :)
23:36:27 <dolio> It's a "user error" though, so I did something wrong, right? :)
23:42:55 <lispy> heh, awesome
23:44:02 <Peaker> a newtype loses all of the instance declarations, right?
23:44:18 <Peaker> (of the type it "copies")
23:44:20 <sclv> yep
23:44:20 <mauke> yes
23:44:25 <Peaker> k, thanks
23:44:46 <sclv> with the newtypeDeriving language extension you can derive them right back though, the ones you want...
23:45:03 <lispy> Peaker: although, you can get them back with newtype deriving.  I don't remember if this is an extension or part of H98.
23:45:14 <lispy> oh, sclv answered that too :)
23:45:17 <sclv> @quote fugue
23:45:17 <lambdabot> monochron says:  "Welcome to #haskell, where your questions are answered in contrapuntal fugues."
23:45:59 <solrize> i think a lot of usages of "type" turn out to be bogus since the user seems to expect consistency checking that doesn't happen
23:46:15 <lispy> I just looked up fugue at wikipedia but I didn't understand the definition
23:46:48 <sclv> just listen to some bach -- it'll be clear enough. or better yet, read hofstader!
23:46:48 <solrize> it's polyphonic music where you have a theme repeating in different voices
23:47:00 <lispy> solrize: type, in my experience, is mostly useful for creating an easier to type name for something
23:47:05 <solrize> like "row row row your boat" sung in a round
23:47:19 <lispy> oh, I get it now
23:47:39 <lispy> "a theme repeating in different voices" is a prefect description given taht quote
23:47:49 <solrize> the more complex ones are amazing to listen to
23:48:47 <lispy> solrize: in darcs source we use type PatchSet p x = RL (RL (PatchInfoAnd p)) () x -- I would much rather type PatchSet p x when I need a patchset
23:48:51 <Cale> solrize: could you elaborate on your comment about types?
23:49:33 <solrize> cale: type Red = Int; type Blue = Int; f :: Red-> String;  f (fromIntegral 7::Blue)  should not typecheck
23:50:07 <lispy> solrize: a type is like a typedef
23:50:15 <lispy> solrize: well, 'type' is like typedef
23:50:29 <solrize> lispy, right, it's like the bogus pseudo-types from the sucky C language :)
23:50:38 <mauke> it's not bogus or pseudo
23:50:42 <mauke> they're simply type aliases
23:50:48 <mauke> nothing wrong with that
23:50:48 <Cale> solrize: ah, right, 'type' is essentially just for reducing keystrokes and adding a small amount of documentation. It's not actually useful beyond that, and you should always consider newtype instead.
23:51:28 <solrize> cale, newtype makes more sense now that there's newtype deriving, but without it, newtype on Nums (etc) is a huge nuisance
23:51:35 <lispy> solrize: you might think typedef in C is sucky, but I'd love it if they would add it to Java :)
23:51:50 <sclv> the fact that types can't be partially applied really bugs me -- it would be a simple language extension, as long as the complexity was limited.
23:52:04 <solrize> my officemate used to use ada and says that it keeps all those types separate, he's going to bring in an ada book so i can look at it
23:52:09 <solrize> but i don't think i actually want to code in ada :)
23:52:14 <lispy> sclv: I wish we have type level lambdas.
23:52:30 <solrize> i wish it was possible to create types inside a function--is there a way to do that ?
23:52:46 <mauke> you can keep them separate in C too: struct red { int value; };
23:52:54 <sclv> absolutely, even though it would be a can of worms.
23:53:06 <solrize> mauke yeah i guess so (C example)
23:53:35 <solrize> i was surprised even in C to find out that there was no checking between (say) size_t and off_t in the system lib, and i've been coding C for a long time
23:53:37 <sclv> i'm sure that a sufficiently restrictive set of rules could be created though so it didn't get too bad.
23:53:50 <lispy> what is off_t?
23:53:58 <solrize> file offset
23:54:00 <mauke> numeric offsets
23:54:07 <solrize> brb
23:55:54 <Peaker> when is the Monad fail method used?
23:56:10 <allbery_b> failed pattern matches
23:56:21 <oerjan> @undo do Just x <- y; return x
23:56:21 <lambdabot> y >>= \ a -> case a of { Just x -> return x; _ -> fail ""}
23:57:03 <Peaker> so generally invocations of fail are generated by the unsugar'ing of do?
23:57:32 <oerjan> yeah
23:57:42 <lispy> Cale: so if fail is called when patterns don't match, and you want to remove fail from Monad, then what will happen when patterns fail to match?
23:57:45 <solrize> pattern match failure throws an exception outside of monads?  or only outside Maybe ?
23:57:46 <allbery_b> generally, yes.  when user code "wants" fail, what it really wants is MonadPlus's mzero method
23:58:01 <Cale> lispy: Another typeclass will be used for that.
23:58:12 <allbery_b> solrize: match failure ouside a monad calls error, yes
23:58:13 <solrize> or, IO doesn't implement fail
23:58:19 <Cale> In particular, MonadZero or a new MonadFail.
23:58:35 <dolio> @src IO fail
23:58:35 <lambdabot> fail s  = failIO s
23:58:48 <oerjan> @src failIO
23:58:48 <lambdabot> failIO s = ioError (userError s)
23:58:51 <solrize> aha
23:58:59 <sclv> I'm starting to find it really irritating that the comma is syntax for tuples and lists both.
23:59:19 <Peaker> I find syntax irritating in general :-)
23:59:24 <sclv> just needless visual confusion.
23:59:49 <solrize> (you (came to) the '(right (place)))
