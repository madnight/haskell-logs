00:00:01 <lispy> :t (+1)
00:00:04 <lambdabot> forall a. (Num a) => a -> a
00:00:12 <lament> with currying, unless each partial application of your function makes sense in the problem domain, it's just another leaky abstraction
00:00:27 <dons> cool, we're winning the tiling window manager vote contest, http://forums.gentoo.org/viewtopic-t-664451-highlight-.html?sid=1dbf28fa3267f04cc3885fd8bb6c6b16 :)
00:00:28 <lambdabot> http://tinyurl.com/393qf7
00:00:45 <dons> probably some good material in there for things to improve
00:02:47 <dons> ?users
00:02:47 <lambdabot> Maximum users seen in #haskell: 472, currently: 416 (88.1%), active: 9 (2.2%)
00:02:57 <lispy> :t map (flip ($)) (repeat (+1)
00:02:58 <lambdabot> parse error (possibly incorrect indentation)
00:03:04 <lispy> :t map (flip ($)) (repeat (+1))
00:03:05 <lambdabot> forall b a. (Num a) => [((a -> a) -> b) -> b]
00:04:06 <cjs_> Well, it's time to hack some more on the test framework, and maybe start using QuickCheck. Any thoughts on examples of packages or applications that have a good test framework?
00:04:24 <cjs_> is there some sort of standard for how you set up extensive tests?
00:04:39 <lispy> There is some guidelines explained in the haskellwiki.
00:04:47 <lament> dons could probably tell a thing or two about that
00:04:53 <dons> cjs_: you use QuickCheck, and -fhpc to ensure coverage
00:04:54 <lament> ...except for all the NDAs
00:05:00 <lispy> cjs_: are you familiar with doing test coverage analysis?
00:05:03 <dons> well, using open tools
00:05:20 <dons> cjs_: write good generic QC properties, then run them with -fhpc and look at the coverage output
00:05:37 <dons> and you get graphs like this, http://galois.com/~dons/tmp/hpc_index.html
00:05:45 <dons> along with very deep testing done by QuickCheck
00:05:49 <cjs_> Test coverage analysis? I know what it is, but I've never used it in anger.
00:05:50 <dons> (even exhaustive at some types!)
00:06:02 <dons> well, its super easy in ghc -- maybe easier than any other language ?)
00:06:07 <dons> just run your test code with -fhpc
00:06:12 <dons> then type: hpc report foo
00:06:14 <dons> after
00:06:28 <solrize_> wow, which xmonad.operations expression is not covered?
00:06:28 <cjs_> BTW, typing "test" into the search box at haskell.org takes me to an unexpected page....
00:06:47 <dons> solrize_: the impure stuff
00:06:57 <solrize_> just 1 out of 616, hee
00:07:06 <dons> the core logic is StackSet.hs -- that's the main thing to check
00:07:16 <dons> though Operations does more than I'd like
00:07:25 <solrize_> oh sorry i meant stackset
00:07:27 <solrize_> i misread the graph
00:07:36 <solrize_> it says 615 out of 616 expressions are covered
00:07:40 <solrize_> so i wondered what the 616th was
00:07:47 <dons> right. and there's a beer for the guy who writes a test for 616
00:07:58 <solrize_> well now we've all gotta know what 616 is
00:08:02 <dons> interestingly, you could replace it with 'undefined' and the tests would still pass
00:08:08 <dons> clikc on the link, and its highlighted in yellow
00:08:15 <dons> untested code is coloured yellow, by default
00:08:20 <solrize_> neat
00:08:30 <solrize_> why are the otherwises green ?
00:08:36 <dons> they're always true
00:08:40 <solrize_> oh wait, they're otherwise nothing?
00:08:47 <dons> so things that always evaluate to True could be suspicious
00:08:52 <dons> ?src otherwise
00:08:52 <lambdabot> otherwise = True
00:08:56 <vegai> argh, the configuration file syntax of xmobar is quite frustrating
00:08:56 <dons> so that's no very suspicious
00:08:57 <cjs_> Ah, so section 6.6 of the ghc manual will give me all the foo on code coverage. Good.
00:08:58 <solrize_> oh oops
00:09:09 <dons> cjs_: no, you need ghc 6.8
00:09:20 <dons> vegai: use dzen2 ? :)
00:09:28 <cjs_> Errr...section 6.6 of the ghc 6.8 manual? :-)
00:09:41 <vegai> dons: yes, I suppose that's an option
00:10:06 <dons> hmm. cjs_ heh
00:10:20 <solrize_> hmm it's in the delete function
00:10:23 <solrize_> on "w"
00:10:26 <dons> yep
00:10:35 <solrize_> which i guess is a window
00:10:40 <solrize_> why is it so polymorphic?
00:10:43 <dons> the testsuite is here, http://code.haskell.org/xmonad/tests/Properties.hs
00:10:51 <dons> run it with runhaskell tests/Properties.hs
00:11:01 <dons> or build with: configure -f testing
00:11:06 <dons> polymorphism is good
00:11:09 <cjs_> Ok, I'm going to go read some xmonad source and get some ideas.
00:11:16 <dons> it means you can instantiate to different index and element types
00:11:28 <dons> and also, so we don't depend on representation details of various things
00:11:36 <cjs_> BTW, is the "#ifdef TESTING" sort of thing in the ghc source code at all common?
00:11:50 <dons> not really
00:11:51 <cjs_> Come to think of it, I'd imagine not, unless Hugs also supports it...
00:11:58 <dons> people tend to use an external properties file
00:12:05 <solrize_> this is nice, i'd also like to read through the whole code sometime
00:12:07 <solrize_> it's comprehensible
00:12:15 <solrize_> and it's doing nontrivial stuff
00:12:23 <dons> solrize_: oh, the testsuite?
00:12:28 <solrize_> the testsuite and xmonad
00:12:32 <cjs_> Does one usually put tests in separate files, or in the same file as the code?
00:12:37 <solrize_> hmm, it uses generics?
00:12:47 <dons> not that i know of.
00:12:52 <solrize_> Gen
00:12:55 <dons> cjs, either is fine
00:13:03 <dons> Gen stands for Generate
00:13:06 <solrize_> oh ok
00:13:11 <dons> check the QuickCheck docs
00:13:17 <lispy> dons: okay, I'm compliling darcs-unstable with -fhpc, let's see what happens
00:13:17 <solrize_> aha yes i remember now
00:13:22 <dons> lispy: yay
00:13:48 <lispy> dons: does hpc change semanitcs in any cases?
00:13:48 <dons> its kind of amazing how awesome -fhpc is
00:13:52 <dons> nope
00:13:53 <cjs_> dons: thanks. I'm sure I'll be back in an hour with more questions.
00:14:03 <solrize_> -fhpc is a quickcheck flag?  or compiler flag?
00:14:07 <dons> its so far beyond anything i've seen, and then you add quickcheck to the mix
00:14:10 <dons> a ghc flag
00:14:29 <dons> so you can even get traces of what code was evaluated in a normal run of the program
00:14:33 <lispy> dons: what types of coverage does it support? does it do definition-use checking?  That one is pretty much the sweet spot for purely functional code
00:14:34 <solrize_> oh neat
00:14:36 <dons> or traces up to when an error happeend
00:14:49 <dons> lispy: it just tags things that were evaluated
00:14:58 <dons> so dead code is yellow
00:15:01 <solrize_> can they incorporate something like catch sometime?  (pattern matching exhaustiveness checker)
00:15:04 <dons> and you can drill down to expressions
00:15:26 <dons> well, hpc is for runtime invariants
00:15:30 <dons> which complements static analysis
00:15:37 <dons> you want a full array of tools for building industrial code
00:15:37 <solrize_> yeah catch is separate
00:15:45 <solrize_> right
00:15:47 <solrize_> http://www.haskell.org/haskellwiki/Haskell_program_coverage
00:15:47 <lambdabot> Title: Haskell program coverage - HaskellWiki
00:15:51 <lispy> Man, I really wish we could standardize darcs on ghc6.8, but the Simons changed the gadt type checking too much and broke our type witness code :(
00:16:26 <solrize_>   http://projects.unsafePerformIO.com/hpc
00:16:27 <solrize_>    hahaha
00:16:27 <lambdabot> Title: Haskell Program Coverage
00:17:24 <lispy> heh, we should have a site that just gives arguments to use Haskell called unsafeCoerce.com
00:17:27 <solrize_> always true / always false   ==   as determined by runtime tracing, not static analysis, hmm
00:17:31 <solrize_> lispy hah
00:17:35 <dons> solrize_: that's right.
00:17:40 <solrize_> neat
00:17:42 <dons> so if you test badly, you don't reveal much
00:18:02 <blarz> @users
00:18:02 <lambdabot> Maximum users seen in #haskell: 472, currently: 420 (89.0%), active: 9 (2.1%)
00:18:15 <dons> you want to have a blended approach of type safety, type proofs, static checking, unit and property testing, and hpc
00:18:32 <lispy> dons: oh, where does the ghc runtime store the results for hpc?
00:18:35 <dons> all are cheap enough to use at some point or another
00:18:45 <lispy> dons: because, the darcs tests all run in subdirs
00:18:47 <dons> lispy: 'ticks', a runtime primitive , like with profiling
00:18:52 <solrize_> those bargraphs, green = evaluated / red=unevaluated  even if it was always true or always false
00:18:55 <lispy> dons: but the exe remains in the top dir
00:18:57 <dons> oh, in the dir the tests are run
00:19:08 <dons> so not sure what happens if the tests call up
00:19:19 <dons> you can combine and fold over separate test runs
00:19:22 <solrize_> wonder if this stuff could be used for profile directed optimization
00:19:44 <lispy> dons: yeah, I knew you could combine, I'm just worried that after each test the testsuite will trash the results
00:20:54 <lispy> Hmm...I need a way to test it
00:21:28 <lispy> what is the name of the created file?
00:21:37 <lispy> .something?
00:21:50 <dons> .tix
00:21:57 <lispy> there is a .hpc
00:22:03 <lispy> it was generated by make I guess
00:22:04 <dons> and the .hpc dir
00:22:08 <dons> iwth .mix files or some such
00:22:21 <lispy> I don't see a .tix file
00:22:41 <lispy> oh, darcs.tix
00:23:12 <dons> hpc report darcs :)
00:23:25 <dons> then combine the tix for all the runs, and you'll have some pretty graphs
00:23:30 <dons> hpc markup darcs -- for the .html
00:23:36 <lispy> hrm...I saw the output of the .tix file on stdout when i type 'make test'
00:24:12 <lispy> okay, I wrote that done
00:24:22 <lispy> I'm just worried the darcs test suite is designed to work against hpc
00:24:41 <lispy> in fact, it looks like some of the tests have failed because of hpc :(
00:24:51 <lispy> it appears to confuse the scripts
00:25:02 <lispy> Oh
00:25:13 <lispy> I bet we have to add all the hpc generated files to the boring lst
00:25:27 <lispy> otherwise tests that look for adds will add the hpc files
00:25:53 <lispy> which also seems to pointout that the hpc files are generated in the wrong directory :(
00:26:07 <lispy> but maybe they give us an env variable to override
00:28:27 <lispy> hmm...who do I contact for bug reports/suggestions?
00:29:12 <lispy> the HPC website only says that Dana Herz created it
00:30:40 <lispy> $ hpc6 report darcs
00:30:40 <lispy> hpc6: can not find Autoconf in ["./.hpc"]
00:54:46 <johnnowak> "Site5.com was one of the first and is still one of the only hosts providing the latest support for Ruby on Rails."
00:54:58 <johnnowak> well let's see, what else can I paste in the wrong window...
00:55:05 <johnnowak> i'm sure i'll find something...
00:55:06 <ZsoL> heheh
00:55:07 <ZsoL> :-)
00:57:34 <lispy> dons: I'd love to run hcp on darcs, but it looks like it will have to wait for another day.  I sent Dana an email asking for advice.
00:58:49 <lispy> dons: from my point of view, it would be nice if there was an RTS option to control where the .hpc/.tix stuff is written
00:59:39 <lispy> Because with that I could just control it from the test harness (and equivalently from ./configure, autoconf or make)
01:03:47 <cjs_> So if I want to test something that's not exported from a module, the only way I can do that is to have the test within the module, right?
01:04:03 <lispy> cjs_: yes and no
01:04:21 <lispy> cjs_: How do you feel about the C pre-processor?
01:04:35 <lispy> cjs_: you could have a conditional compilitation for testing
01:04:56 <cjs_> Well, if I added up all of the misery it's cost me over the last 25 years....
01:05:06 <lispy> cjs_: you could also define your QC properties inside the module and export those
01:05:14 <cjs_> And cpp only works with ghc, right?
01:05:30 <lispy> I don't know about the ghc only bit, but I only use ghc :)
01:06:00 <cjs_> Actually, even now I have a unitTest definition in every module, and I expect that exporting that would not hurt much.
01:06:20 <cjs_> Although, is it going to drag along all of its code when I make a binary if unitTest is not used in that binary?
01:06:27 <lispy> cjs_: but, I would recommend sticking to a naming convention for tests and then just exporting the test functions with the expectation that people understand they aren't to use them, only the testing module uses them
01:07:27 <lispy> cjs_: I don't know the answer to the question about bringing along all the code, but I would expect that if something is exported, it's exported and ghc has to assume things will want to link with it at some point
01:08:10 <cjs_> Right, which could potentially limit the compiler's ability to optimize, right?
01:09:12 <lispy> I don't know.  But, then I would just use CPP
01:09:39 <lispy> I think you can manually run cpp on the source even if you're not using ghc
01:09:39 <cjs_> I suppose one thought that might avoid cpp would be to do something such as have a Foo.ht containing the test code for Foo.hs, and when doing testing, concatenate the former to the latter.
01:09:58 <lispy> sure
01:10:52 <cjs_> Ah, I see how that could work, actually. You could build a test tree in your build directory which is the entire source tree with that done to it.
01:12:07 <cjs_> Does ghci work well under Windows? I need the ability to be able to have Excel call out to Haskell code to do stuff, which I know I can do with Hugs.
01:12:37 <cjs_> (Or I need to find some alternative. But getting my financial guy to start replacing chunks of his spreadsheets with Haskell in a very interactive way is very, very appealing to me.)
01:13:47 <lispy> ghc works great on windows, I've had some losy interactions with ghci though.  It seems the windows shell doesn't always do what I want
01:13:53 <lispy> Or was it cygwin
01:14:09 <lispy> cjs_: how do you plan to make excel and haskell interact?
01:14:18 <lispy> I've seen all manners of this before
01:14:33 <lispy> I've seen socket communication implemented on both sides, dlls and com
01:15:16 <lispy> the socket way isn't the fastest, but I think it's faster than COM and it's probably the most stable
01:15:30 <lispy> (so don't rule it out straight away just because it sounds hockey)
01:18:17 <cjs_> I can see a lot of options, but I was going to start with David Wakeling's code.
01:18:28 <lispy> cjs_: oh what is that?
01:18:56 <cjs_> That basically builds a file and runs hugs on it. Though I want to keep the Haskell definitions in their own file, and execute that followed by the stuff I generate from the spreadsheet.
01:19:23 <lispy> cjs_: are you familiar with red-rover software?
01:19:24 <cjs_> He wrote a paper on it in the JFP.
01:19:30 <cjs_> No, I'm not.
01:19:53 <cjs_> http://neilmitchell.blogspot.com/2007/03/hsexcel.html
01:19:55 <lambdabot> Title: Neil Mitchell's Haskell Blog: HsExcel
01:19:59 <lispy> okay, they make tools for excel to help normal people effectively do software engineering
01:20:07 <cjs_> Full text at http://www.scribd.com/doc/264667/Spreadsheet-functional-programming (requires Flash).
01:20:09 <lambdabot> Title: Spreadsheet functional programming, http://tinyurl.com/3au62c
01:20:12 <lispy> redrover was started by a research group at OSU
01:20:29 <cjs_> I'm not sure it's possible for normal people to do software engineering. :-)
01:20:40 <lispy> and, afaik (and I used to work with them) they are the lead group doing excel research
01:21:01 <cjs_> Facitousness aside, if this is about getting Excel junkies to use better SE techniques, I'm all for it.
01:21:23 <lispy> cjs_: so, even if you don't use their software, you could (and should?) look at their research papers on the subject, especially anything by Robin Abraham
01:21:59 <lispy> cjs_: http://www.redroversoftware.com/products/detect?gclid=CL-TkfurqpICFQgogwod0RTBQw
01:22:01 <lambdabot> Title: RedRover Software | RedRover Detect, http://tinyurl.com/2ly6zf
01:22:43 <lispy> cjs_: I have no idea if their software has a reasonable price, but definitely some of the stuff robin did like ucheck and goal debug are very cool and very end-user oriented
01:23:02 <lispy> cjs_: you can find a lot of their papers published at vl/hcc
01:23:53 <cjs_> I just saw a $695 price for one of their packages in a news article. So it seems reasonable enough, at least for this project.
01:24:01 <cjs_> vl/hcc?
01:24:01 <lispy> cjs_: http://web.engr.oregonstate.edu/~erwig/papers/abstracts.html
01:24:02 <lambdabot> Title: Publication-Abstracts by Martin Erwig
01:24:18 <lispy> cjs_: visual languages/human centric computing
01:24:30 <cjs_> Ah.
01:24:56 <lispy> you'l want to look at (at Martin's website), GoalDebug: A Spreadsheet Debugger for End Users and UCheck: A Spreadsheet Unit Checker for End Users
01:25:19 <lispy> cjs_: as well as the type inference for spreadsheets and autotest
01:25:22 <cjs_> I'm not aiming quite in that direction; I'm at the moment sort of dreaming of Excel as a sort of 2D cell-based REPL.
01:26:03 <lispy> That's certainly possible
01:26:17 <cjs_> The spreadsheet is a nice interface for some stuff, but I'm thinking you don't really want any serious equations in there.
01:26:41 <lispy> spj worked with one of the OSU researchers once to add real user defined functions to excel, but it was never implemented by MS :(
01:27:29 <cjs_> For something used so seriously on billion dollar projects, it's pretty amazing what they leave out.
01:27:57 <lispy> cjs_: well, best of luck, see if you can get a trial of the redrover stuff before you buy it and def. read up on the stuff by robin (and maybe shoot him an email if you want to ask questions about interfacing with excel, he works at MS now ;)
01:28:05 <cjs_> The Mac version of Excel doesn't even have VBA. Useless for any serious work. We're going to have to go back to Windows.
01:28:05 <lispy> cjs_: yup
01:28:32 <lispy> No, VBA, but surely it has other extension mechanisms right?
01:28:39 <lispy> Maybe you could write a dll?
01:29:02 <lispy> plugin python or something if you need a dynamic language, and have that build the bridge to haskell?
01:29:22 <cjs_> Not as far as I can tell. It appears to be good for reconciling your checkbook, and that's about it.
01:29:28 <lispy> (I should have said, .so or framework instead of dll, but you probably know what I meant...)
01:29:44 <cjs_> (It is the "home edition"; they appears to be no "pro" version for Mac.)
01:30:01 <lispy> Next question.  Does it have to be excel?
01:30:05 <cjs_> Yeah, I understand. I've had the misfortune to spend enough time on Windows to know all about that. :-)
01:30:10 <cjs_> No.
01:30:17 <lispy> What if you switch to gnumeric or open office where you can integrate at the source level.
01:30:37 <cjs_> It's a convenient starting point, but even that Haskell spreadsheet is on the list.
01:31:02 <lispy> oh okay, so you guys are very serious about making the right tool and not just using something close
01:31:05 <lispy> I respect that.
01:31:10 <cjs_> I need to stick with Excel for a couple of months, though, so I can get a sense of what my guy is doing with it, and what I'd have to replace, and so on.
01:31:27 <cjs_> Thanks. It's why I'm using Haskell in the first place.
01:31:43 <lispy> cjs_: Oh, here is an idea.
01:31:51 <lispy> cjs_: have you ever seen ghci on acid?
01:31:58 <cjs_> No.
01:32:19 <lispy> The basic idea is that ghci allows the user to load custom code on start up, basically providing a plugin framework.
01:32:38 <lispy> ghci on acid is a particular set of code that allows the ghci instance to run lambdabot in the background.
01:32:49 <lispy> You could do something very similar with excel communication I bet
01:32:55 <lispy> Or, in your case, do it in reverse.
01:32:57 <cjs_> Hmm!
01:33:46 <lispy> Well, with so many options, you have your work cut out for you.
01:33:52 <cjs_> Actually, forward would be very cool.
01:34:09 <cjs_> Imagine being able to manipulate the spreadsheet at the REPL prompt.
01:34:17 <lispy> cjs_: if you're the academic type, you could probably even get some type of paper at the Haskel workshop explaining what your organization did in the end and the things you considered
01:34:35 <cjs_> Yes, if this goes well, I can definitely see a paper coming out of it.
01:34:40 <cjs_> I'll be famous!
01:34:44 <lispy> hehe
01:35:32 <cjs_> More seriously, I can probably justify it in that it's likely to lead to product and consulting sales.
01:35:34 <lispy> cjs_: darcs get http://www.cse.unsw.edu.au/~dons/code/goa/
01:35:36 <lambdabot> Title: Index of /~dons/code/goa
01:35:52 <lispy> ah good point
01:36:44 <cjs_> We (starling-software.com) need to find a good product so that we can get rich. And I think that some lie in this direction.
01:37:14 <lispy> ah, well be careful about redrover then, I know they are trying to patent everything
01:37:31 <cjs_> Oh, really? *Sigh*.
01:37:40 <lispy> when I last talked to the profs they were talking about having the OSU lawyers get them some patents
01:37:44 <lispy> Yes, I know.
01:37:53 <cjs_> Then again, maybe they'll buy us.
01:37:57 <lispy> Hehe
01:38:33 <cjs_> Ha ha! "[S]tudies have shown that most end-user spreadsheets contain non-trivial errors." No! Say it isn't so!
01:38:35 <lispy> http://www.cse.unsw.edu.au/~dons/code/goa/GOA.hs
01:38:53 <lispy> cjs_: yeah, they contain a scary amount according to the research
01:39:09 <lispy> wakeup is the interesting code
01:39:48 <lispy> cjs_: good luck, it's very far past my bedtime
01:40:15 <lispy> cjs_: and feel free to /msg me if you have any questions or what contact info for any of the researchers I mentioned.
01:41:02 <cjs_> Thanks!
01:44:15 <lispy> cjs_: oh one more before I go to bed.  IBM created a spreadsheet system called A4, it was targeted at sysadmins, but the cool thing was you could embed arbitrary java in the cells.  You might look up their research for some ideas of what not to do ;)
01:46:06 <cjs_> Heh.
01:51:23 <Enzo> Hello all! Earlier today I attempted to upload several CGI webapps onto my webpage through the hosting services of Register.com. Problem is: under the file details, my webapps are being interpreted by the server as Pearl script, but they are 100% written Haskell script. Does anyone know of a site that will support Haskell Script?
01:51:54 <Enzo> *written in
01:54:51 <earthy> there is one, just a sec
02:02:29 <earthy> Enzo: www.nearlyfreespeech.net
02:02:57 <vegai> aha, I seem to have found a reason to use darcs over mercurial. It seems that mercurial doesn't support cloning through http without a specialized server
02:03:41 <Enzo> earthy! thans so much =]
02:03:50 <Enzo> *thanks
02:05:26 <earthy> http://example.nfshost.com/versions.php for the versions of all languages they support for CGI
02:05:28 <lambdabot> Title: Versions of CGI Languages
02:06:27 <vegai> I wonder if git supports that..
02:08:47 <vegai> No, that doesn't even.
02:08:49 <vegai> darcs++
02:11:40 <wagle_home> i thought git could do stuff over http
02:12:43 <wagle_home> its just an ugly way to do it, or something
02:15:13 <vegai> I tested this at my apache site. Did hg init, git init and darcs init
02:15:19 <vegai> then added a few files and committed/recorded
02:15:25 <vegai> then tried to clone/get it from home
02:15:32 <vegai> didn't work with git, hg, but worked with darcs
02:16:16 <vegai> of course, it could be some subtle issue with virtual hosts or something, but for vegai the end-user, darcs's shares spiked now
02:16:35 <cjs_> How about using them over ssh?
02:17:11 <vegai> that works, of course, but I'm thinking of making something public
02:17:15 <vegai> read-only
02:17:21 <cjs_> Works for all three?
02:17:27 <vegai> ssh. Sure.
02:17:35 <vegai> but it's not as convenient as http
02:17:57 <cjs_> I'd imagine it's a configuration issue.
02:18:13 <vegai> could very well be. But again, darcs just works
02:18:32 <vegai> I'm actually quite fond of mercurial, so it's a bit sad if I won't get it to work this way
02:32:46 <vegai> aha, there's a static-http method in mercurial, but they recommend against it because of its bad performance
02:32:55 <vegai> I wonder if darcs has similar problems with it
02:34:32 <Beelsebob_> The one practical thing I've found to distinguish between the various distributed scms is that darcs is the only one that does not need to have a process running where the repository is stored
02:34:55 <Beelsebob_> so you can host your repositories anywhere you have write access to, as opposed to anywhere you have permission to run servers
02:37:33 <quicksilver> Beelsebob_: bzr also has that property.
02:37:39 <Beelsebob_> oh?
02:37:42 <quicksilver> indeed.
02:37:43 <Beelsebob_> I've not heard of that one
02:37:52 * Beelsebob_ goes scuttling off to investigate it
02:38:07 <quicksilver> it writes via scp or sftp or ssh
02:38:12 <vegai> the worst thing to do really is to check out every technology under the sky :)
02:38:32 <JohnMeacham> hmm.. we need to figure out something better for #ifdefs in libraries...
02:39:17 <JohnMeacham> it would be nice to be able to say things like #if FUNDEPS  rather than an odd combination of checking __NHC__ __GHC__ __JHC__ etc that become out of date.
02:39:22 <vegai> well... doing hg clone static-http URL elapsed over 5 seconds. darcs get for the same repo took 0.3 seconds
02:43:40 --- mode: irc.freenode.net set +o ChanServ
03:04:36 <ertai> Is there some kind of 'if' lifted to monads? My condition is in the monad.
03:06:40 <Feuerbach> ertai: no, as far as I remember
03:06:47 <jeffz> hmm, if my biggest complaint about Haskell is that invalid escape sequences don't produce the character following the backslash in invalid string literals, Haskell is doing pretty good, heh.
03:07:18 <ertai> Feuerbach: thanks
03:07:52 <Beelsebob_> jeffz: that's one of my favourite features
03:08:05 <Beelsebob_> it means you get a compiler error when you meant to add \\, but forgot one
03:08:29 <jeffz> Beelsebob_: oh, I get a compiler error when I try to type a valid string literal for another language in my Haskell source :)
03:08:40 <Beelsebob_> yep
03:33:26 <dancor> is string replace already somewhere.  not seeing in Data.List
03:39:15 <ertai> Is there a way to locally disable a warning like "Warning: Defined but not used Foo"
03:47:10 <matthew_-> ertai: yeah, export Foo
03:47:14 <matthew_-> ;)
03:47:21 <MarcWeber> ertai: http://rafb.net/p/tLzEzf86.html is seen sometimes
03:47:22 <lambdabot> Title: Nopaste - No description
03:47:57 <byorgey> ertai: if you put an underscore at the beginning of a name, it won't warn if it's unused
03:48:23 <byorgey> ertai: you can also use {-# GHC_OPTIONS -fno-warn-unused-binds #-} to turn it off for a whole file
03:50:45 <ertai> actually that's the 'main' file, the export trick don't works.
03:51:45 <ertai> and the '_' trick don't work for constructors
03:51:57 <ertai> that's why I ask :)
03:55:39 <matthew_-> if it's the Main module and it's a constructor that's never used then you can freely delete it
03:57:25 <matthew_-> well if you don't like the warning, just comment the constructor out
04:01:38 <malcolmw> you can certainly export from the main module: "module Main (main, other, stuff) where"
04:10:32 <unenough> can a function evaluate to itself?
04:11:06 <desegnis> @type id
04:11:08 <desegnis> @type id id
04:11:15 <lambdabot> forall a. a -> a
04:11:16 <Jaak> yes? let x = x in x
04:11:17 <lambdabot> forall a. a -> a
04:11:40 <desegnis> unenough, depending on what you had in mind
04:11:54 <unenough> > let f _ = f in f 3
04:11:55 <lambdabot>      Occurs check: cannot construct the infinite type: t = t1 -> t
04:11:55 <lambdabot>     Probab...
04:12:17 <unenough> i'll take that as a no.
04:12:24 <matthew_-> you can't have infinite types
04:12:40 <unenough> why is that an "infinite type"?
04:13:02 <matthew_-> f :: a -> a -> a -> a -> a ....
04:13:11 <mauke> f :: b@(a -> b)
04:13:32 <unenough> i just want f to evaluate to f
04:13:35 <matthew_-> lol, don't quite think you can do aliases at the type level there mauke ;)
04:13:49 <ari> :t \f -> const f
04:13:50 <lambdabot> forall a b. a -> b -> a
04:14:00 <mauke> that would be its type if it were legal :-)
04:14:00 * ari sees
04:14:13 <mauke> unenough: you need a data wrapper
04:14:16 <matthew_-> mauke: indeed. :)
04:14:25 <unenough> data wrapper? (i'm a n00b)
04:14:50 <mauke> data Foo a = F (a -> Foo a)
04:15:32 <MaSSaSLaYeR> Hello i got a question it's vb.net well to the point: I'm searching for an ftpclient dll file can anyone help me in my search because i can't find one and i wrote an upload in vb.net but it only uploads to some ftp's
04:15:50 <unenough> MaSSaSLaYeR, this is a Haskell channel...
04:16:00 <mauke> f _ = F f
04:16:09 <unenough> you might as well ask in #pjamas
04:16:21 <blarz> obvious troll is obvious
04:16:22 <Jaak> there's #pjamas?
04:16:23 <MaSSaSLaYeR> well i'm just searching :( because first of all there's no vb.net channel
04:16:30 <unenough> Jaak, there should be! heh
04:16:34 <MaSSaSLaYeR> and i can't find it @@ :(
04:16:40 <matthew_-> surely that'll be pyjamas, no?
04:16:42 <mauke> MaSSaSLaYeR: yes, there is
04:16:51 <unenough> MaSSaSLaYeR, search the web. http://www.codeproject.com for example
04:16:53 <lambdabot> Title: CodeProject. Free source code and programming help
04:17:07 <MaSSaSLaYeR> i posted it there before
04:17:17 <unenough> don't post, search
04:18:14 <MaSSaSLaYeR> mauke wich one?
04:18:25 <mauke> #vb.net
04:18:31 <mauke> surprise!
04:18:38 <MaSSaSLaYeR> and unenough i searched there, the ftuploader there is crap
04:18:40 <MaSSaSLaYeR> and pure code
04:18:50 <MaSSaSLaYeR> mauke, i'm normally on server swiftirc
04:19:01 <mauke> I don't care
04:19:04 <unenough> MaSSaSLaYeR, there is #vb.net. it exists
04:19:19 <MaSSaSLaYeR> i go there now atm^
04:19:46 <mauke> do you want to learn Haskell?
04:19:48 <unenough> and now there is also #pjamas, thanks to myself.
04:19:52 <unenough> heh mauke  :)
04:21:28 <matthew_-> it's pyjamas!
05:02:14 <SamB> hmm. no wonder the boxy types techreport is so copy/paste unfriendly... it was transcoded by ghostscript!
05:04:35 * JohnMeacham hates LALR parsers
05:04:54 <SamB> what is LALR?
05:05:06 <SamB> I forget :-(
05:05:16 <JohnMeacham> like happy or yacc or bison use.
05:05:18 <allbery_b> linear recursive with lookahead
05:05:30 <SamB> oh, that kind.
05:05:50 <JohnMeacham> once you use PEGs, there is no going back. they are just super.
05:08:03 <SamB> do they have decent debugging?
05:08:09 <SamB> (unlike happy?)
05:08:44 <JohnMeacham> yes. but there is basically no need to debug them as you express pretty much exactly what you want.
05:08:58 <JohnMeacham> it's impossible to create ambiguous grammers.
05:09:37 <JohnMeacham> and you can actually produce decent error messages.
05:12:46 <SamB> oh, no ambiguous grammers huh
05:12:52 <SamB> is that actually nice?
05:13:09 <ketil> What's a PEG?
05:13:15 <wli> > take 5 . map (fst . head) . groupBy ((==) `on` (floor . snd :: (Integer, Rational) -> Integer)) $ iterate (\(n, x) -> let n' = n + 1 in (n', x + recip (fromInteger n') :: Rational)) (1, 1)
05:13:21 <lambdabot>  [1,4,11,31,83]
05:13:22 <SamB> oh, he left
05:14:16 <ketil> Yup.  I guess we'll have to ask Google instead... :-)
05:14:40 <ketil> http://en.wikipedia.org/wiki/Parsing_expression_grammar
05:27:37 <ralejs> I'm trying to validate a patch to ghc. But the validate script complains that "Haddock's internal GHC version must match the configured GHC version". How do I fix this?
05:28:25 <Baughn> ralejs: Wildly guessing, recompile haddock?
05:28:41 <dcoutts_> ralejs: you'd have to build haddock using your current version of ghc, or don't bother with building docs
05:28:51 <nefffffff> http://www.meine-nackte-ex.net/?uid=138832
05:28:52 <lambdabot> Title: Meine Ex Nackt!!!
05:28:53 <nefffffff> http://www.meine-nackte-ex.net/?uid=138832
05:28:54 <lambdabot> Title: Meine Ex Nackt!!!
05:28:55 <nefffffff> http://www.meine-nackte-ex.net/?uid=138832
05:28:55 <lambdabot> Title: Meine Ex Nackt!!!
05:29:01 --- mode: ChanServ set +o dcoutts_
05:30:18 <ralejs> dcoutts_: what's the easiest way to build haddock with an inplace ghc?
05:30:32 <dcoutts_> ralejs: I've really no idea, ask in #ghc
05:30:33 --- mode: ChanServ set -o dcoutts_
05:30:58 <ralejs> dcoutts_: ok, thanks
05:31:20 <dcoutts_> ralejs: if I were you, I'd just use haddock 0.x rather than 2.x
05:32:36 <sioraiocht> is it possible to have a right recursive grammar with left associative operators?
05:33:52 <ralejs> dcoutts_: are you saying I should uninstall haddock 2.x? Any particular reason?
05:34:33 <dcoutts_> ralejs: or at least make 'haddock' link to your 0.x version rather than 2.x version
05:34:40 <dcoutts_> because then you will not have that problem
05:35:10 <dcoutts_> I don't think the ghc build system typically uses haddock 2.x so you're hitting a problem other people do not have
05:35:23 <ralejs> dcoutts_: ok, I'll try that.
05:35:29 <dcoutts_> you don't have to be the pioneer :-)
05:36:18 <ralejs> r
05:36:32 <ralejs> Ooops.
05:54:54 <EvilRanter> sioraiocht, that depends on parser tool your working with. i think you can make it work with parsec, for instance.
05:55:03 <sioraiocht> ah
05:55:07 <sioraiocht> cheers
05:55:16 <EvilRanter> (consider chainl and chainr)
05:56:04 <EvilTerran> if nothing else, you can introduce them with a second pass over the AST to fix the associativities
06:00:41 <EvilTerran> Syzygy-, hehe. i like your hostname.
06:19:05 <Syzygy-> EvilTerran: Nice, eh? :)
06:28:29 <dcoutts_> sioraiocht: I'd not bother either, I'd parse ignoring operator fixity (ie keep them as lists) and reassociate later when you know the operator fixities. I did that for a compiler and it works nicely.
06:28:53 <sioraiocht> dcoutts_: good advice, thanks :)
06:28:59 <dcoutts_> it makes it much easier to report decent error messages too
06:32:54 <MyCatVerbs> Hmmm. Is the code that winds up on the language shootout even remotely idiomatic?
06:32:58 <shapr`> @users
06:32:59 <lambdabot> Maximum users seen in #haskell: 472, currently: 446 (94.5%), active: 12 (2.7%)
06:33:08 <shapr`> Good morning #haskell!
06:33:23 <shapr`> I'm going to Las Vegas tomorrow, are there any interesting FP things there?
06:34:01 <xerox> You can bet there are!
06:34:59 <Baughn> MyCatVerbs: Not in any language I've looked at
06:35:30 <Baughn> MyCatVerbs: ..the haskell code looks somewhat like decently idiomatic C. Thing is, the C code /doesn't/ look like good C. :P
06:37:44 <qebab> C code doesn't really look like good anything unless you find that sort of thing charming
06:38:23 <Baughn> There is good c code, and there is bad c code. The latter variant is, of course, far more common; that does not exclude the former from existence.
06:39:48 <qebab> of course there is good C code, it's the visual appearance I don't think too much of
06:40:05 <Baughn> That's okay. I dislike the visual appearance of haskell too. ;)
06:40:39 <sioraiocht> Baughn: get out! =p that actually surprises me, though
06:40:43 <sioraiocht> although i think the most visually appealing language i have seen is lua
06:40:57 <unenough> as soon is we finish our earth-shattering semantic editor, all this will not matter! visual appearance is superficial
06:41:11 <unenough> (it might take a few years)
06:41:13 <unenough> :P
06:42:23 <Baughn> sioraiocht: It's probably transference. Haskell probably /looks/ decent, I just hate writing it - the indentation style is a horror.
06:42:51 <sioraiocht> hrm, i've never ha a problem with its indentation
06:43:18 <Botje> write AST nodes directly!
06:43:35 <Baughn> I'd like to!
06:43:43 <Baughn> That reminds me, I should check out liskell again
06:44:31 <unenough> when we are done, it will be possible to select your favorite visualization/edit mode
06:44:37 <Baughn> sioraiocht: I'm using haskell-mode, and it doesn't always (read: quite often not) put the indentation where I want it to
06:44:52 <Baughn> sioraiocht: It's not really a fault of haskell /either/, then. It's haskell-mode.
06:44:53 <sioraiocht> you know it cycles through tabs, right?
06:44:56 <Baughn> Yes
06:45:49 <Baughn> That said, it often puts the marker further to the right than I want it to, and further than it has to be
06:46:21 <Baughn> I'd fix it, but haskell-mode is a mess. ^^;
06:47:23 <Baughn> ..hopefully the last four months of development has fixed it. Seems they've split out a haskell-indent module.
06:49:18 <cjs_> Hey, you think you've got it bad, try writing Haskell in vi.
06:49:24 <zeroflagWork> mauke: you around?
06:49:25 <dancor> why do you think not putting spaces after commas is so common in haskell, but like " -> " and other things seem to always have the spaces
06:49:29 <DRMacIver> Hm. If I have a list of (Int, Int) pairs and want to generate an IntMap [Int] where x maps to the list of y such that (x, y) is in the original list, what's an efficient way of doing so? There's the obvious fold over the list or the obvious cleverness with sorting, grouping, etc but I was wondering if there's a better way. (the list is largeish - at least a few hundred thousand)
06:49:49 <dancor> DRMacIver: isn't IntMap bad and you should use Map instead?
06:49:50 <schemelab> CosmicRay: ping?
06:49:57 <CosmicRay> schemelab: pong
06:50:00 <DRMacIver> dancor: Is it?
06:50:04 <Jedai> DRMacIver: fromListWith
06:50:10 <schemelab> error making blog entry at Sequence
06:50:24 <CosmicRay> schemelab: what's it doing?
06:50:49 <DRMacIver> Jedai: Ah ha. I hadn't noticed that function. Thanks.
06:50:50 <schemelab> CosmicRay: http://hpaste.org/6634
06:51:30 <MyCatVerbs> cjs_: vim seems fine enough for it. Why on Earth would you ever use vi instead of vim, (barring, say, hacking on a toaster).
06:51:31 <CosmicRay> schemelab: doh.  let me /msg you the email address to report that to.
06:51:31 <Jedai> @hoogle Data.Map.fromListWith
06:51:31 <lambdabot> No matches, try a more general search
06:51:44 <MyCatVerbs> s/)\./)?/
06:52:05 <Jedai> @hoogle fromListWith
06:52:05 <lambdabot> Data.Map.fromListWith :: Ord k => (a -> a -> a) -> [(k, a)] -> Map k a
06:52:05 <lambdabot> Data.IntMap.fromListWith :: (a -> a -> a) -> [(Key, a)] -> IntMap a
06:52:05 <lambdabot> Data.Map.fromListWithKey :: Ord k => (k -> a -> a -> a) -> [(k, a)] -> Map k a
06:52:24 <shap1> So, anyone here in Las Vegas?
06:52:29 <cjs_> Oh, I am using vim. But I've not found anything for it that does automatic formatting.
06:52:36 <CosmicRay> schemelab: /msg sent.  the sequence is now hosted over at cs.pdx.edu, so I don't have direct control over that machine
06:52:43 <schemelab> got it
06:52:56 <CosmicRay> shapr1: hey shapr.  no, I'm not in vegas.  you vacationing there?
06:53:05 <cjs_> E.g., I change a variable name ina function definition, which changes the indentation, and then I have to manually re-indent all the following lines.
06:53:36 <CosmicRay> cjs_: the emacs modes for haskell are much more robust than the vim modes, unfortunately
06:53:54 <shapr1> CosmicRay: sort of
06:53:57 <cjs_> Of course. Emacs is, in general, a better editor.
06:54:16 <shapr1> I'm doing team building in vegas, tomorrow through sunday.
06:54:21 <CosmicRay> ah, lovely.
06:54:32 <CosmicRay> is it as mind-numbing as it sounds?
06:54:39 <shapr1> Yeah, I hope I don't have to gamble.
06:54:40 <schemelab> It is understood that algorithm analysis only concerns itself with large n. Since most web programming has to do with short round trips, how does algorithm analysis figure in?
06:54:58 <shapr1> CosmicRay: Ed loaned his Coq'Art book, I should be fine :-)
06:55:03 <CosmicRay> heh
06:55:10 <EvilRanter> schemelab, say your database has a million rows...
06:55:18 <Baughn> schemelab: Say you get a million visitors a second...
06:55:28 <schemelab> good points
06:55:32 * dancor is not really into style that requires you to reindent things anyway
06:55:50 * EvilRanter uses the same size indents for everything, rather than lining things up vertically
06:56:00 <shapr1> I think JohnMeacham used to be in Vegas, but is no longer.
06:56:06 <shapr1> @users
06:56:07 <lambdabot> Maximum users seen in #haskell: 472, currently: 446 (94.5%), active: 25 (5.6%)
06:56:13 <Baughn> schemelab: A good algorithm will handle a thousand visitors per second. A bad algorithm won't. Either might live with ten, but if they're equally simple, why bother with the bad one?
06:56:13 <EvilRanter> if i had a snazzy sentient editor that could line things up neatly even when i changed things, i'd do so
06:56:21 <EvilRanter> but i don't, so i don't
06:56:36 <shapr1> Oh hey, who was working on the snazzy editor for non-monospaced layout?
06:56:43 <schemelab> yes, I never thought of it that way. than you Baughn and EvilRanter
06:56:58 * dancor doesn't like things to get too wide either
06:57:33 <EvilRanter> schemelab, altho most of the important bits of "algorithm design" for webdev boil down to stuff like "don't fetch the entire table from the database when you only need three lines"
06:57:52 <EvilRanter> er, rows
06:57:59 * matthew_- uses a 1600x1200 monitor for a reason: line width!
06:58:11 <schemelab> that's actually pre-algorithm... you have to formulate the query properly...
06:58:20 * EvilTerran uses a 1024x768 monitor for a reason, too - my laptop won't do anything bigger =/
06:58:43 <cjs_> matthew_: that's silly. Everybody knows that the reason to use a 1600x1200 monitor is so you can have three 80-column xterms side by side.
06:58:48 <matthew_-> heh, yeah I dislike it when I have to use my laptop as everything then wraps
06:58:59 <EvilTerran> altho that reminds me, i was gonna plug in this ancient (PS/1 era, SVGA) monitor i've got sitting on the desk next to me
06:59:08 <matthew_-> cjs_: sure, on a different workspace. But I run emacs fullscreen
07:00:15 <dancor> i wouldn't mind writing a cool code transmogrifier sometime.  maybe even hook it into yi some day
07:01:54 <matthew_-> are you meant to pronounce yi as "why" or "yai" ?
07:02:03 <matthew_-> ("jai"?)
07:02:06 * EvilTerran pronounces it "yee"
07:02:11 <matthew_-> oh!
07:02:12 <dancor> basically, by improving your vim or emacs modes instead of developing yi, you are only supporting terrorism
07:02:18 <idnar> I keep wanting to pronounce it "yee ai"
07:02:26 <idnar> (like "vee ai")
07:02:36 <matthew_-> no! it's called vim!
07:02:42 <matthew_-> ;)
07:02:51 <EvilTerran> ... which i pronounce "vai"
07:02:58 <matthew_-> quite.
07:03:08 <EvilTerran> or "six" ;)
07:03:17 <matthew_-> you see, this is why emacs is superior
07:03:24 <matthew_-> unambiguous pronounciation
07:03:52 <mauke> zeroflagWork: ?
07:04:14 <MyCatVerbs> matthew_-: I have a cheaper solution: tiny console fonts!M
07:04:35 * MyCatVerbs uses 9x15 for more or less everything. Any smaller and his eyes won't cope. Any larger and things don't fit.
07:05:05 <schemelab> is Haskell appropriate for solving logic puzzles?
07:05:54 <MyCatVerbs> schemelab: you can do pretty well by using the list monad, effectively that gives you backtracking search (but with no cut operator).
07:06:18 <schemelab> I see... ok I will post it to comp.lang.haskell in  a bit
07:06:30 <MyCatVerbs> schemelab: e.g. each step in the search is a function from one possibility to a list of further possibilities.
07:06:42 <MyCatVerbs> schemelab: ever used Prolog?
07:06:43 <schemelab> JVR wrote a logic system in Haskell.
07:06:53 <schemelab> the guy who wrote "Logc Maths and Computer Programming in Haskell"
07:07:07 <MyCatVerbs> Haven't read it. Any good?
07:07:15 <schemelab> That was a great book... only it didnt go into monads or any deep haskell
07:07:46 <schemelab> MyCatVerbs: what is your email address?
07:08:25 <MyCatVerbs> schemelab: See privmsg (I don't want my email address coming up on the public #haskell archives and getting spambotted).
07:08:29 <schemelab> yes got it
07:08:45 <schemelab> you have a present coming your way :)
07:08:56 <MyCatVerbs> schemelab: by far the best place to post queries of the type you seem to be mulling is the haskell-cafe mailing list.
07:09:20 <MyCatVerbs> @haskell-cafe
07:09:20 <lambdabot> Unknown command, try @list
07:09:27 <MyCatVerbs> http://www.haskell.org/mailman/listinfo/haskell-cafe
07:09:28 <lambdabot> Title: Haskell-Cafe Info Page
07:10:07 <schemelab> ok MyCatVerbs, merry christmas. check your inbox :)
07:10:15 <MyCatVerbs> If you subscribe and post to that, you'll get at least three or four decent answers to whatever question it is that you might need to pose.
07:10:33 <schemelab> I have to goto work at a bank now, and I can only get to google groups :)
07:10:45 <schemelab> so talk with you later on..have nice day... and Go Gunners!!!
07:11:25 <zeroflagWork> mauke: ah, hi. 1) I can't join ##c here... seems I'm banned without ever coming near that channel... 2) I can't join #c on efnet because it's +k, 3) C is eating away my sanity.
07:11:30 <matthew_-> MyCatVerbs: that's not quite true. Some of the less easy questions tend to get ignored
07:11:56 <mauke> zeroflagWork: go to efnet #c, the key is C :-)
07:12:10 <zeroflagWork> >_<
07:12:29 <idnar> looks like ##c has all IRC gateways banned
07:12:59 <zeroflagWork> no one really wants to do C anyway so I think that's a good thing...
07:15:52 <shapr1> zeroflag: hiya!
07:16:00 <shapr1> zeroflagWork: When did you start learning Haskell?
07:17:20 <wolfgangbeck> is there any documentation about 'forall'? I try to get rid of the XScopedTypeVariables extension
07:17:43 <zeroflagWork> shapr1: I didn't really... I just need my fellow lunatic mauke to help me out on my C parser.
07:17:52 <wolfgangbeck> examples at http://hackage.haskell.org/trac/haskell-prime/wiki/ScopedTypeVariables dont compile with ghc 6.8.2
07:17:58 <lambdabot> Title: ScopedTypeVariables - Haskell Prime - Trac, http://tinyurl.com/3b2sn9
07:18:46 <shapr`> zeroflag: Oh, you should try Haskell! It's really fun! It's very different from C though.
07:19:18 <wolfgangbeck> I'm not going to argue with a robot, but the examples on that page don't work
07:19:42 <quicksilver> wolfgangbeck: why are you trying to get rid of the extension?
07:19:43 <dolio> What errors do you get?
07:20:44 <wolfgangbeck> don't know if those extension will be maintained forever
07:20:57 <quicksilver> just remove the type signature then.
07:21:05 <quicksilver> :)
07:21:29 <quicksilver> the type signatures which require scoped type vars are not expressible in Haskell98
07:21:45 <shapr`> wolfgangbeck: I think forall will be around forever.
07:21:48 <quicksilver> so if you do not wish to use the extension, then you cannot give them signatures.
07:21:53 <wolfgangbeck> the error goes like ' No instance for (Encodable (forall a. a))'
07:22:01 <shapr`> oh
07:22:12 <zeroflagWork> shapr`: I got a few looks at haskell and it doesn't quite feel like a language I'd need to know...
07:22:13 <wolfgangbeck> the problem is, i don't currently use forall
07:22:30 <quicksilver> wolfgangbeck: then you're not using ScopedTypeVariables.
07:22:35 <quicksilver> :)
07:22:55 <quicksilver> it looks like you might be using existential types, though.
07:22:59 <wolfgangbeck> that's funny. with -XScopedTypeVariables the code compiles, without it doesnt
07:23:05 <shapr`> zeroflagWork: What do you need to know?
07:23:12 <quicksilver> wolfgangbeck: can you paste the code?
07:23:29 <matthew_-> wolfgangbeck: you are using the same type variable in the function sig and in a function sig in a where clause ?
07:23:30 <wolfgangbeck> it's a  little long
07:23:41 <wolfgangbeck> is there a pasting web site?
07:23:48 <matthew_-> @hpaste
07:23:48 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:23:49 <shapr`> !paste
07:23:53 <shapr`> oops
07:25:19 <wolfgangbeck> have to shorten it for hpaste
07:26:31 <quicksilver> it may be that XScopedTypeVariables is unlocking another extension that you in fact depend on
07:26:51 <quicksilver> but certainly I wasn't aware that Scoped kickis in unless you are using forall
07:27:07 <shapr`> zeroflagWork: What fits into what you need to know?
07:27:41 <wolfgangbeck> ok, pasted http://hpaste.org/6635
07:28:27 <wolfgangbeck> ignore the TLS part, http://hpaste.org/6636
07:28:50 <EvilTerran> um... why did you paste it twice?
07:28:55 <Saizan> wolfgangbeck: yeah, that x :: a signature needs ScopedTypeVaribales
07:29:22 <EvilTerran> wolfgangbeck, is that signature even necessary? it looks like the thing should be able to infer it
07:29:35 <quicksilver> ah yes
07:29:45 <quicksilver> a type variable introduced by a class context
07:29:55 <wolfgangbeck> EvilTerran: haven't tried without ig yet
07:29:57 <quicksilver> didn't realise that was possible but it makes sense.
07:30:20 <quicksilver> I don't think that sig is needed no.
07:30:31 <Saizan> quicksilver: i was actually very surprised when i realized that needed an extension :)
07:30:52 <quicksilver> I think this *might* be a GHC bug.
07:31:04 <quicksilver> I think that is supposed to require (forall a . Encodable a)
07:31:33 <Saizan> instead of Encodable (forall a. a) ?
07:31:37 <wolfgangbeck> it seems to work without sig
07:32:29 <wolfgangbeck> I tried to copy the forall statement suggested in ghc's error message, but it resulted in a syntax error
07:32:55 <quicksilver> Saizan: well it's just htat I think scoped type vars aren't supposed to be introduced except by explicit foralls
07:32:57 <wolfgangbeck> I think I try to remove the sigs
07:33:04 <quicksilver> so this might be a bug in the implementation of the extension
07:33:09 <quicksilver> or it might be a bug in quicksilver's understanding.
07:33:14 <dolio> Yeah, I can't tell why that'd need scoped type variables...
07:33:45 <dolio> That just looks like Read.
07:34:24 <Saizan> dolio: the (x::a) annotation needs it, but the code works without
07:34:42 <wolfgangbeck> thanks for your help
07:34:43 <dolio> Well, yes.
07:35:01 <Saizan> i don't know what h98 says about typevars from instance heads, though
07:36:33 <quicksilver> Saizan: they certainly aren't scoped.
07:36:40 <quicksilver> Saizan: tyvars are never scoped in h98
07:37:00 <quicksilver> (that is to say, their scope never extends beyond the type they are part of)
07:54:44 <Baughn>  
08:19:11 <daniel_larsson> @users
08:19:11 <lambdabot> Maximum users seen in #haskell: 472, currently: 460 (97.5%), active: 16 (3.5%)
08:23:12 <luqui> how do I tell haddock to ignore some code it doesn't understand?
08:25:16 <dcoutts_> luqui: #ifdef HADDOCK
08:25:43 <luqui> dcoutts_, thanks
08:26:26 <byorgey> hey, neat, I didn't know you could do that =)
08:27:27 <luqui> dcoutts_, haddock gives me 'parse error' on the line with the #ifndef
08:27:40 <dcoutts_> luqui: you have to cpp it first
08:27:41 <luqui> compiles fine though
08:27:54 <dcoutts_> cabal will do that for you if you use extensions: CPP
08:28:25 <luqui> :q
08:28:33 <luqui> er... irc /= vim :-)
08:28:41 <dcoutts_> :-)
08:28:54 * dcoutts_ thinks :) and :-) should be vim commands
08:30:02 <luqui> dcoutts_, by use extensions do you mean {-# LANGUAGE CPP #-}?
08:30:21 <Saizan> i think if you use {-# LANGUAGE CPP #-} haddock will handle it, since it uses ghc?
08:30:32 <dcoutts_> Saizan: only for haddock-2.x
08:30:46 <dcoutts_> luqui: that'll help for ghc but Cabal cannot read those yet you so have to use extensions: CPP in the .cabal file
08:34:39 <ahunter> Hmm, I did some more investigation into questions I had last night...Consider this segment:
08:34:39 <ahunter> let total = case arg of
08:34:39 <ahunter>                 [count] -> read count
08:34:39 <ahunter>       keys = map (`mod` (5*total)) $ take total $ randoms $ mkStdGen 5 :: [Int]
08:34:39 <ahunter>       keys' = map ((`mod` (5*total)) . fst . next . mkStdGen) [1..total]
08:34:40 <ahunter> (For my purposes, total is in the 10k-100k range.)  Now, I force both lists to be fully evaluated, which isn't slow, by "print $ (sum keys,sum keys')".  Now, if I use keys' as a source of test cases in another function, it's nice and fast.  If I use keys, it's horribly slow.  I'm relatively confident it isn't the numbers themselves causing the trouble, due to extensive testing, though I could always be wrong.  For one thing, this behaivor is entirel
08:40:55 <luqui> gah! this is annoying!  it seems that HADDOCK is not defined even when generating documentation
08:41:09 <luqui> thus #ifdef HADDOCK works because it excludes the clause; #ifndef HADDOCK does not work
08:42:03 <skorpan> you guys! i passed the advanced functional programming course.
08:42:05 <skorpan> yay for me!
08:42:10 <skorpan> and it's all thanks to you guys!
08:42:22 <luqui> so.. really.. _we_ passed it  :-P
08:42:30 <idnar> haha
08:42:33 <skorpan> we did!
08:42:50 <Igloo> skorpan: Please post us our commission cheque
08:43:19 <Igloo> luqui: What version of haddock do you have?
08:43:21 <skorpan> what the heck is that?
08:43:38 <Igloo> skorpan: n/m, just an attempt at humour  :-)
08:43:43 <skorpan> right :)
08:44:00 <Igloo> luqui: You want __HADDOCK__
08:44:55 <luqui> Igloo, thanks
08:45:21 <luqui> Igloo, w00t yay it works
09:05:27 <cjs_> is there a class or something for saying that two numbers are approximately equal, for use when comparing floating point numbers? Or maybe, close to each other within a certain error?
09:07:41 <cjb> @src floatEq
09:07:44 <lambdabot> Source not found. You type like i drive.
09:07:53 <cjb> cjs_: looks like:
09:07:57 <cjb> instance Eq Float where
09:07:57 <cjb>   x == y                =  x `floatEq` y
09:08:29 <mauke> cjb: I don't think so
09:08:35 <cjb> ah
09:08:45 <Gilly> cjs_: abs (a-b) < epsilon
09:09:05 <cjb> Gilly: I think cjs_knows how to do that, but was wondering if it's encapsulated anywhere
09:09:12 <cjb> or at least, that's what I was wondering :)
09:09:26 <Gilly> cjb: i know, and i think it might be encapsulated somewhere, not sure though
09:09:44 <Gilly> but it isn't that hard to write and should be clear for the one reading the code
09:11:21 <Gilly> an ohh. i read the question wrong too, he was asking for "a class or something" :P
09:17:37 <cjs_> Yes, it's not hard to write, I was just wondering if, e.g., ~= is already there because I'm not yet terribly familiar with the libs.
09:18:41 <cjs_> I'm using it for testing; I guess what I really want is something like "(stuff stuff stuff) == around 6.315"
09:22:04 <quicksilver> cjs_: it's not there, no.
09:22:18 <quicksilver> cjs_: I'm 99% sure I know the standard libs well.
09:22:24 <quicksilver> it could be in some lib on hackage, though.
09:23:17 <quicksilver> you could knock up some funky syntax so you could write:
09:23:30 <quicksilver> (x + y - z) =~= Tolerance 0.0001 6.315
09:23:41 <quicksilver> and then define "around = Tolerance 0.000001"
09:23:44 <quicksilver> to write
09:23:50 <quicksilver> (x+y-z) =~= around 6.315
09:25:19 <cjs_> yeah, that's  the sort of thing I'm looking for.
09:25:24 <cjs_> Anyway, gotta run. Thanks.
09:25:54 <byorgey> that syntax doesn't even look particularly funky to me =)
09:43:34 <schemelab> MyCatVerbs: ping? got it?
09:53:08 <pete1> Is it correct that ghci cannot accept the same code which is accepted by ghc compiler?
09:53:09 <pete1> see http://hpaste.org/6638
09:53:09 <pete1> when I try to enter the code manually in ghci I get errors if the type is not explicitly provided like this:
09:53:09 <pete1> let x = pSym 'x' :: AnaParser [Char] Pair Char (Maybe Char) Char
09:53:09 <pete1> but it is not needed in the hpaste example
09:54:56 <pete1> the error is like:
09:54:56 <pete1> Prelude UU.Parsing.CharParser UU.Parsing> let x = pSym 'x'
09:54:56 <pete1> <interactive>:1:8:
09:54:56 <pete1>     No instance for (IsParser p Char)
09:54:56 <pete1>       arising from a use of `pSym' at <interactive>:1:8-15
09:54:57 <pete1>     Possible fix: add an instance declaration for (IsParser p Char)
09:54:59 <pete1>     In the expression: pSym 'x'
09:55:01 <pete1>     In the definition of `x': x = pSym 'x'
09:56:22 <jbapple> Is there an unsafeEscapeCont :: Cont r a -> a like unsafePerformIO :: IO a -> a ?
09:56:44 <mauke> @src Cont
09:56:45 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
09:57:27 <mauke> :t \x -> runCont x id
09:57:30 <lambdabot> forall a. Cont a a -> a
09:58:41 <dcoutts_> jbapple: mauke's point is that there is nothing unsafe about running the Cont monad
09:58:59 <mauke> I have a point?
09:59:03 <dcoutts_> :-)
09:59:29 <jbapple> dcoutts_: But there is something unsafe about abort :: ((a -> r) -> r) -> a, which is not provable in constructive logic
10:00:18 <dcoutts_> jbapple: oh it might not fit the abstraction you're trying to build, but it's not unsafe in the way unsafePerformIO is unsafe
10:00:41 <dcoutts_> runCont cannot cause segfaults :-)
10:00:47 <dcoutts_> unsafePerformIO can
10:01:01 <jbapple> :t runCont
10:01:05 <lambdabot> forall r a. Cont r a -> (a -> r) -> r
10:01:22 <jbapple> runCont does not have the type I'm looking for.
10:01:27 <dcoutts_> :t flip runCont id
10:01:28 <lambdabot> forall a. Cont a a -> a
10:01:59 <byorgey> pete1: yes, ghci does not work on everything which is accepted by ghc.
10:01:59 <lambdabot> byorgey: You have 1 new message. '/msg lambdabot @messages' to read it.
10:02:13 <byorgey> pete1: for example, you cannot declare data types in ghci.
10:02:39 <jbapple> dcoutts_: which makes sense, since ((a -> a) -> a) ->a is true. But ((a -> r) -> r) ->a is a horse of another color
10:02:51 <jbapple> dcoutts_: maybe I'm misunderstanding you
10:02:58 <pete1> byorgey: ok; is there a list of what does not work in ghci somewhere?
10:03:01 <dcoutts_> jbapple: oh I see
10:03:29 <byorgey> pete1: hm, I don't know
10:03:41 <byorgey> pete1: there probably is in the docs for ghci
10:03:55 <pete1> byorgey: I thought I can do anything in ghci what I can do in an IO monad but this does not seem to be the case (after my test mentioned)
10:04:14 <ahunter> I do remembering reading a paper somewhere that showed that adding callcc to a lambda-calculus-alike extended the type-theory analogue from constructive to classical logic (callcc ~ LEM, or more accurately Pierce's Law, which is equivalent)
10:04:22 <dcoutts_> jbapple: so I don't know. Whatever you write has to be an ordinary typed function, continuations are not a language primitive so there is no unsafe primitive escape hatch
10:04:28 <Saizan> ?type let abort x = Cont $ \_ -> x in abort
10:04:29 <lambdabot> forall r a. r -> Cont r a
10:04:45 <jbapple> ahunter: That's Griffin's "A formulae-as-types notion of control"
10:05:12 <Saizan> so abort :: r -> (a -> r) -> r
10:05:12 <ahunter> jbapple: yeah, that's the one, I think
10:05:21 <ahunter> $src abort
10:05:23 <byorgey> pete1: in your specific example, the difference appears to be that when ghc runs over the entire program, it can see how you are using x and is thus able to infer an appropriate type for it.
10:05:25 <ahunter> @src abort
10:05:25 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
10:05:38 <Saizan> ahunter: abort is not in the standard libraries
10:05:45 <ddarius> ahunter: Thinking about how the LEM works in that context is... interesting.
10:05:46 <byorgey> pete1: however, when you just type  'let x = pSym 'x'' at the ghci prompt, it does not know yet that you are going to pass x as a parameter to test
10:05:55 <pete1> byorgey: ach, good point!
10:06:03 <byorgey> and so it is not able to infer a type for it, for some reason
10:06:07 <ddarius> Saizan: We should change MonadCont to have only one method that is control rather than callCC
10:06:28 <pete1> byorgey: I see now that ghc has more information to infer correct types
10:06:46 <pete1> byorgey: thanks
10:06:46 <quicksilver> ghc's non-local type inference confuses occasionally
10:06:51 <quicksilver> even without ghci
10:07:06 <quicksilver> it can lead to code which is correct being copy-pasted out of a file and then rendered incorrect
10:07:18 <quicksilver> because the surrounding context affected its type inference
10:07:26 <quicksilver> overall it's a good thing though :)
10:07:28 <ahunter> ddarius: agreed...pretty cool though
10:07:38 <quicksilver> and it doesn't bite you if you explicitly type all your toplevel decls.
10:07:40 <byorgey> this is why you should never copy-paste code, but import the module instead =)
10:07:59 <quicksilver> byorgey: you might, for example, be refactoring your code
10:08:00 <byorgey> (among a few other reasons... =)
10:08:03 <quicksilver> byorgey: out into a module :)
10:08:19 <quicksilver> and be surprised when it apparently fails to typecheck
10:08:38 <quicksilver> (monomorphism restriction mostly)
10:08:43 <ahunter> byorgey: speaking of which, this is stupid, I know, but why can't I say ":l Data.Map", or as far as I can tell, any module which is scoped?
10:08:56 <byorgey> quicksilver: fair enough =)
10:09:07 <byorgey> ahunter: try ":m +Data.Map" instead
10:09:29 <byorgey> ahunter: as for why there is a difference, I'm not really sure
10:10:09 <byorgey> ahunter: :l is for modules you have written, :m is for loading modules installed in a library
10:10:20 <Botje> :l only looks in the current directory, :m looks in the system path
10:10:27 <jbapple> I can write abort for Typeable types, but I'm not sure if it's, er, what I want
10:10:29 <jbapple> http://hpaste.org/6639
10:10:31 <ahunter> byorgey: ah, I see
10:10:32 <Saizan> :l takes a file, :m a module
10:11:29 <jbapple> It doesn't "work" on  abortDyn (\x -> x "foo")
10:12:09 <jbapple> OTOH, writing the same things without dynamics (on one of the types that can be easily packed in an exception) works fine
10:12:36 <Saizan> jbapple: so you want abort outside the Cont monad?
10:12:48 <jbapple> i.e. abortString (\x -> x "foo"), ghci informs me, is "foo"
10:12:52 <jbapple> Saizan: yes
10:13:38 <jbapple> Saizan: and I know it can't be written safely, but I'm eager to accept that, if I can understand in what way it is unsafe.
10:28:29 <MyCatVerbs> schemelab: sorry for the slow response, was running various errands.
10:28:37 <MyCatVerbs> schemelab: no, I'm afraid I haven't.
10:31:39 <[1]schemelab> MyCatVerbs: join #mycatverbs please
10:33:56 <jbapple> abort using unsafeCoerce: http://hpaste.org/6639
10:34:45 <jbapple> it seems to work:
10:34:45 <jbapple> abortCoerce (\x -> x length) >>= \f -> print $ f "this is a string of length 29"
10:34:50 <jbapple> 29
10:40:14 <roconnor> jbapple: abortCoerce seems unsafe
10:40:29 <roconnor> jbapple: what if f throws an exception?
10:41:11 <jbapple> roconnor: which f, now?
10:41:37 <roconnor> abortCoerce (const (throw foo))
10:43:35 <jbapple> roconnor: hm
10:44:09 <byorgey> well, I wouldn't expect something implemented using unsafeCoerce to be particularly safe... =)
10:44:31 <roconnor> byorgey: I do.
10:44:46 <roconnor> unless it is called unsafeAbortCoerce
10:44:59 <byorgey> oh, fair enough.
10:45:06 <jbapple> f can't throw an exception before the "good" one unless it ignores its argument, right?
10:45:57 <jbapple> ok, bad naming :-) I'm not making a library proposal or anything
10:46:04 <roconnor> jbapple: hmm
10:46:35 <roconnor> jbapple: I'm not sure.  You can do pretty strange things with when a is a function type.
10:48:01 <Baughn> @type const ((a -> b) -> c -> (a -> b))
10:48:04 <lambdabot> parse error on input `->'
10:48:06 <Baughn> @type const :: ((a -> b) -> c -> (a -> b))
10:48:07 <lambdabot> forall a b c. (a -> b) -> c -> a -> b
10:48:30 <jbapple> Prelude Main Control.Exception> unsafeAbortCoerce roconnorCounterExample
10:48:30 <jbapple> *** Exception: Abort.hs:43:5-45: Non-exhaustive patterns in lambda
10:49:16 <roconnor> abortCoerce (const (throw (ErrorCall foo)))
10:49:17 <lispy> ?djinn (a -> b) -> c -> a -> b
10:49:18 <lambdabot> f a _ b = a b
10:49:39 <Baughn> Good djinn.
10:50:28 <roconnor> @djinn ((((a->b)->a)->a)->b)->b
10:50:28 <lambdabot> f a = a (\ b -> b (\ c -> a (\ _ -> c)))
10:51:29 <jbapple> Then again, functions that throw are already unsafe.
10:51:43 <lispy> ?djinn a->(b->(a->(a->(b->b))))
10:51:43 <lambdabot> f _ _ _ _ a = a
10:51:48 <roconnor> jbapple: why?
10:51:53 <jbapple> roconnorCounterExample :: (a -> Bot) -> Bot does not look like a safe function to me
10:51:58 <jbapple> they're not necessarily unsafe
10:52:09 <jbapple> I should say they might already be unsafe
10:52:23 <roconnor> jbapple: can I cause a segfault with throw?
10:52:35 <lispy> ?pl f a = a (\ b -> b (\ c -> a (\ _ -> c)))
10:52:36 <lambdabot> f = ap id (flip id . (. const))
10:53:28 <lispy> ?. pl djinn (a -> b) -> (c -> d) -> a -> c -> (b, d)
10:53:29 <lambdabot> f = flip . (((.) . (,)) .)
10:53:57 <lispy> That's so cool, BTW, the ?. operator.
10:54:18 <roconnor> jbapple: my counter example is safe because it doesn't use any unsafe functions.
10:54:42 <roconnor> it is your abortCoerce that is unsafe and can segfault.
10:54:59 <jbapple> roconnor: let me think some more about that
10:56:16 <lispy> jbapple: may I see the definition of abortCoerce?
10:56:21 <roconnor> unsafeCoerece is perfectly legitamate to use when you know that either the types are the same, or you know that it will be coerced back into the right type before it is used.
10:56:32 <jbapple> http://hpaste.org/6639#a2
10:57:09 <roconnor> jbapple: but in your case one of your unsafeCoerece fails this property.
10:57:35 <roconnor> because your error handler may accidentally catch a real exception.
10:57:45 <jbapple> roconnor: I see.
10:58:11 <roconnor> jbapple: maybe you can somewho use phantom types so that you only catch your own exception.
10:58:17 <roconnor> *somehow
10:59:23 <jbapple> I'd like to use throwDyn, but (a) I don't want only Typeables and (b) even for Typeables, it just doesn't seem to work the same way
11:00:06 <lispy> jbapple: just a terribly minor nit pick.  Usually people use the infix catch so that it needs more naturally.  do foo `catch` myErrorHandler
11:00:19 <lispy> er reads not needs
11:00:53 <jbapple> http://hpaste.org/6641
11:01:09 <roconnor> jbapple: I've got another counter example.
11:01:38 <lispy> ?. pl djinn (a -> b) -> f a -> f b
11:01:38 <lambdabot> (line 1, column 1):
11:01:38 <lambdabot> unexpected "-"
11:01:38 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
11:02:12 <Deewiant> @djinn (a -> b) -> f a -> f b
11:02:13 <lambdabot> -- f cannot be realized.
11:02:31 <roconnor> jbapple: abortCoerce (\a -> a (\ b -> b (\ c -> a (\ _ -> c))))
11:03:04 <roconnor> jbapple: I'm actually unsure what this does.
11:03:20 <roconnor> jbapple: maybe we can simplify it.
11:03:50 <ahunter> @djinn (t -> t) -> t
11:03:50 <lambdabot> -- f cannot be realized.
11:04:13 <roconnor> jbapple: the problem is that f may capture the  (\v -> throw $ ErrorCall $ unsafeCoerce v) and stuff it into it's result.
11:04:38 <Deewiant> @ty \f -> f undefined
11:04:40 <lambdabot> forall a t. (a -> t) -> t
11:04:44 <roconnor> then the user may use that result which will throw an exception.
11:05:21 <roconnor> jbapple: and the exception may be caught, expecting an ErrorCall, and then segfault.
11:05:44 <roconnor> @type ErrorCall
11:05:45 <lambdabot> Not in scope: data constructor `ErrorCall'
11:05:53 <roconnor> @hoogle ErrorCall
11:05:54 <lambdabot> Control.Exception.ErrorCall :: String -> Exception
11:05:54 <lambdabot> Control.Exception.errorCalls :: Exception -> Maybe String
11:06:46 <roconnor> jbapple: so your other use of unsafeCoerce is also unsafe.
11:07:13 <Deewiant> unsafeCoerce is unsafe.
11:07:32 <roconnor> Deewiant: not every use of it.
11:07:58 <Deewiant> true. In what kind of situations is it needed, though?
11:08:20 <Deewiant> Experimental stuff that the latest GHC can't typecheck due to bugs? :-P
11:08:46 <roconnor> Someone showed me one case where two polymorpic variables a and b had to be the same due to case analysis.
11:10:02 <roconnor> Haskell code extracted from coq uses unsafeCoerce, in a somewhat less safe way.
11:10:07 <roconnor> but still arguably safe.
11:10:26 <dolio> CC-delcont needs it.
11:10:45 <jbapple> When discussing Leibniz equality, Emir Pasalic talks about it in his thesis
11:10:54 <roconnor> The coq code uses unsafeCoerce to tunnel data through the unit type, it is reconverted back on the other end.
11:11:13 <roconnor> this is a bit unsafe because the optimizer can screw things up.
11:11:31 <Baughn> Unit type? ()?
11:11:32 <jbapple> http://homepage.mac.com/pasalic/p2/papers/thesis.pdf , page 80
11:11:42 <roconnor> Baughn: ().
11:12:06 <dolio> It uses a monad generating unique propmts represented by integers to mark places in a stack of functions representing a continuation...
11:12:11 <roconnor> tunnelling data through polymorphic variable type would be safer.  Possibly even completely safe.
11:12:43 <roconnor> jbapple: that may have been the example I was looking at.
11:12:47 <dolio> And when you go to split the continuation, you know when you find the right prompt that the types unify, but there's no way to tell the type system that. So you use unsafeCoerce.
11:13:25 <jbapple> dolio: where is delcont from?
11:13:53 <dolio> CC-delcont is a delimited continuations library I maintain.
11:13:55 <dolio> It's on hackage.
11:17:36 <opqdonut> polymorphic references are problematic right?
11:17:50 <guenni> is it possbile to define a function in a way that it's name can be printed?
11:18:31 <roconnor> guenni: not directly
11:18:58 <opqdonut> how does IORef not have these problems?
11:19:02 <guenni> roconnor: thx
11:19:41 <roconnor> opqdonut: have what problems?
11:20:07 <dolio> opqdonut: Binding via lambda abstraction is monomorphic.
11:20:15 <dolio> Which is what do-notation translates into.
11:20:40 <dmhouse> opqdonut: they do, see http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO-Unsafe.html#v%3AunsafePerformIO
11:20:41 <lambdabot> http://tinyurl.com/2akd4n
11:20:50 <dolio> That's why unsafePerformIO + IORef defeats the type system.
11:21:25 <dmhouse> But only coupled with unsafePerformIO.
11:23:33 <chessguy> anybody messed with generating JS from haskell much?
11:23:44 <chessguy> i'm wondering if it's machine-readable JS or human-readable
11:24:05 <opqdonut> dmhouse: so why not in the IO monad?
11:24:18 <opqdonut> dolio: i'm sorry i don't think i understand?
11:24:24 <dmhouse> opqdonut: what dolio said.
11:24:27 <lament> is generated code ever human-readable?
11:24:28 <dolio> Well, I'm a bit hazy myself.
11:24:29 <opqdonut> :t \x -> x
11:24:30 <lambdabot> forall t. t -> t
11:24:34 <opqdonut> isn't that polymorphic?
11:24:49 * shap1 throws lambdas at jbapple
11:24:50 <opqdonut> or what did you mean by lambda abstraction?
11:25:13 * jbapple ducks
11:25:15 <dolio> But when you pick t, it's set for the entire body of the function.
11:25:25 <shap1> jbapple: So, when are you visiting Boston?
11:26:29 <dolio> So, 'newIORef undefined >>= \r -> putIORef r True ; (readIORef r :: IO Int)' is invalid, because when you pick t, it can be either Int or Bool, but not both.
11:27:07 <opqdonut> ah i think i see
11:27:11 <dolio> That is '\r -> ... :: IORef t -> IO t'
11:27:34 <opqdonut> so the only way of having, say, "IORef a" is doing "newIORef undefined" ?
11:28:43 <dolio> Well, the only way you can use it in an inconsistent way is to have it bound in a let block.
11:28:57 <dolio> Or top level, of course.
11:29:43 * shap1 wanders off to the doctor
11:30:03 <dolio> Using it in a do block, or via explicit lambda expressions will cause the type variables to all be instantiated to the same thing for the course of its use.
11:31:17 <opqdonut> ah yes
11:31:41 <opqdonut> yes now i see
11:32:06 <opqdonut> assigning something with a specific type into the IORef "locks" it's type
11:32:33 <opqdonut> and if nothing locks it, the IORef is left polymorphic and we have to use defaulting or a compilation error :)
11:33:05 <monochrom> <3 polymorphism
11:33:15 <roconnor> chessguy: Javascript?
11:33:23 <dolio> Well, it won't get defaulted.
11:33:32 <dolio> The parameter isn't part of a type class.
11:34:11 <chessguy> roconnor, yes, sorry
11:34:40 <dolio> But short of unsafePerformIO, there's no way to get an 'IORef a' in a situation where you can instantiate 'a' to two different things.
11:35:01 <roconnor> I fiddled around with it a while back.  I don't think the resulting code was human readable.
11:35:14 <roconnor> chessguy: but I never got it to work.
11:35:25 <roconnor> chessguy: I hear it has gotten better since then.
11:35:40 <dolio> I was thinking it might be doable with higher rank types a while back, but all I could figure out was 'IORef (forall a. a)', which is an IORef that must contain bottom. :)
11:35:44 <chessguy> roconnor, so the goal is human-readable?
11:35:45 <opqdonut> dolio: well, i something like storing Nums in a IORef
11:36:06 <dolio> You probably could do that with higher rank types.
11:36:31 <opqdonut> yeah
11:37:04 <dolio> t :: IORef (forall a. (Num a) => a)
11:37:21 <monochrom> Or existential type.
11:37:47 <dolio> t <- newIORef 5 :: IO (IORef (forall a. Num a => a))
11:38:09 <dolio> That works, but it's not unsafe.
11:38:32 <dolio> You can't, say, put a Double in and get back an Int, because a Double isn't 'forall a. Num a => a'
11:38:39 <opqdonut> yeah
11:40:57 <roconnor> chessguy: no I don't think so.
11:41:18 <roconnor> chessguy: when I say, getting better, I mean it generates working javascript.
11:41:28 <chessguy> ah, that's always a good hting
11:42:37 <jbapple> http://hpaste.org/6642
11:43:36 <jbapple> ach, I don't think that works either
11:46:24 <DRMacIver> Hm. Can I use GHC to cross compile a linux suitable binary from windows?
11:47:13 <Igloo> No
11:47:24 <DRMacIver> ok
11:47:56 <roconnor> jbapple: same problems.
11:48:18 <jbapple> roconnor: I think I understand the "what if f throws" problem
11:48:28 <jbapple> roconnor: the other one, I'm still confused about
11:48:34 <jbapple> roconnor: could you explain again?
11:49:13 <roconnor> jbapple: I can try, but I will admit that I don't have a full understanding of the other problem.  It is just a worry. ... a signifigant worry.
11:49:45 <roconnor> jbapple: the basic problem is that f may use your function (\v -> throwDyn $ toEmpty v)) twice!
11:50:19 <roconnor> jbapple: the first use is the normal use, but the second use would be to hold onto that function tucked away inside v.
11:51:00 <roconnor> jbapple: so that when people try to use the result of abortAny, then gain access to (\v -> throwDyn $ toEmpty v))
11:51:27 <roconnor> jbapple: when they use v this is executed again and an exception is thrown.
11:52:11 <roconnor> jbapple: but v is used in a context where the user is catching dynamic exceptions of type Empty.
11:52:56 <roconnor> jbapple: so they try to use it as if it were empty, but umm, it isn't empty because something was just coerced into being the empty type.
11:53:31 <roconnor> jbapple: anyhow, this problem was much worse when you were coercing to strings.
11:53:44 <jbapple> roconnor: But Empty isn't exported
11:53:57 <roconnor> jbapple: and now it will be mitigatted somewhat if you don't export Empty.
11:53:59 <mauke> hahaha http://en.wikipedia.org/wiki/Simon_Peyote_Joints
11:54:21 <roconnor> jbapple: but nested uses of abortAny still concerns me.
11:54:56 <roconnor> I'm not sure.  You might end up catching an exception thrown by the wrong instance of abortAny.
11:55:52 <jbapple> http://hpaste.org/6642#a1 fixes the easier-to-understand problem, perhaps: it rethrows any exceptions f finds
11:56:05 <jbapple> (except Empty ones)
11:56:46 <Cale> mauke: That's terrible
11:57:11 <gwern> > map (:[]) "foo bar"
11:57:12 <lambdabot>  ["f","o","o"," ","b","a","r"]
11:57:27 <Cale> > map return "foo bar"
11:57:27 <lambdabot>   add an instance declaration for (Show (m Char))
11:57:34 <Cale> > map return "foo bar" :: [String]
11:57:34 <lambdabot>  ["f","o","o"," ","b","a","r"]
11:57:43 <mauke> > return . "foo bar" :: [String]
11:57:44 <lambdabot>  ["f","o","o"," ","b","a","r"]
11:58:17 <akkartik> I'm looking for the one-to-many analog to zip: foo 'a' [1, 2, 3] = [['a', 1], ['a', 2], ['a', 3]]. Does this beast have a name?
11:58:31 <gwern> mauke: mind blowing
11:58:33 <jbapple> roconnor: How would f's hold on v be visible outside abort?
11:58:37 <gwern> the listmonad strikes again!
11:58:51 <skorpan> > zip (cycle 'a') [1, 2, 3]
11:58:52 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Char'
11:58:53 <Cale> akkartik: That would be a type error there, because Char isn't an instance of Num
11:58:59 <gwern> akkartik: unfold maybe?
11:59:04 <skorpan> as you can see zip makes tuples
11:59:07 <byorgey> > zip (repeat 'a') [1,2,3]
11:59:07 <lambdabot>  [('a',1),('a',2),('a',3)]
11:59:18 <skorpan> [ ['a', x] | x <- [1, 2, 3] ]
11:59:21 <skorpan> > [ ['a', x] | x <- [1, 2, 3] ]
11:59:21 <lambdabot>   add an instance declaration for (Num Char)
11:59:21 <lambdabot>     In the expression: 1
11:59:21 <lambdabot>     In ...
11:59:22 <byorgey> > sequence ['a'] [1,2,3]  -- maybe this?
11:59:22 <lambdabot>  Couldn't match expected type `m a' against inferred type `Char'
11:59:23 <roconnor> jbapple: something like abortAny (\a -> a (\ b -> b (\ c -> a (\ _ -> c))))
11:59:25 <akkartik> ack, but of course..
11:59:25 <mauke> > map ((,) 'a') [1,2,3]
11:59:25 <lambdabot>  [('a',1),('a',2),('a',3)]
11:59:31 <byorgey> oh, duh =)
11:59:57 <Cale> > sequence [[5],[1,2,3]]
11:59:57 <lambdabot>  [[5,1],[5,2],[5,3]]
12:00:14 <byorgey> so, that would work, except that ['a', 1] is not well typed =)
12:00:24 <gnuvince> :t sequence
12:00:25 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
12:00:58 <akkartik> this is an absolute torrent :) thanks guys
12:01:47 <roconnor> jbapple: in this case a is bound to (\v -> throwDyn $ toEmpty v)
12:01:51 <Cale> > map (\x -> [5,x]) [1,2,3]
12:01:52 <lambdabot>  [[5,1],[5,2],[5,3]]
12:02:15 <roconnor> jbapple: and v is bound to (\ b -> b (\ c -> a (\ _ -> c)))
12:02:35 <roconnor> jbapple: which you can see, holds onto a in a limited sense
12:04:12 <roconnor> jbapple: abortAny (\a -> a (\ b -> b (\ c -> a (\ _ -> c)))) returns (let a=\v -> throwDyn $ toEmpty v in (\ b -> b (\ c -> a (\ _ -> c))))
12:04:34 <jbapple> roconnor: hm
12:04:46 <roconnor> jbapple: there is no problem yet
12:04:50 <roconnor> jbapple: but I worry.
12:05:29 <jbapple> roconnor: why isn't that yet a problem?
12:05:54 <roconnor> because if that a is used inside a subsequenct call to abortAny, then you may end up catching the wrong exception and coerce the wrong value.
12:06:17 <roconnor> jbapple: there is not problem yet because I haven't illustrated a segfault.
12:06:33 <roconnor> jbapple: so maybe everything is actually fine.
12:06:46 <roconnor> jbapple: but I wouldn't bet on it.
12:07:54 <byorgey> @quote fire.hose
12:07:55 <lambdabot> byorgey says: sometimes asking #haskell for help can be like taking a drink from a fire hose
12:08:01 <byorgey> akkartik: =)
12:09:34 <dolio> You just found the marble in the oatmeal.
12:11:28 <gwern> @quote oat
12:11:29 <lambdabot> jcreigh says: <chessguy> i mean if someone says factorial should be of type String -> [(Float, Bool)], you should just tell them they're nuts  <jcreigh> > let fac n = map (\x -> (x, True)) $ scanl (*
12:11:29 <lambdabot> ) 1 [1..(read n)] in fac "5" :: [(Float, Bool)]
12:13:10 <roconnor> > let fac n = map (\x -> (x, x==product [1..n])) $ scanl (*) 1 [1..(read n)] in fac "5" :: [(Float, Bool)]
12:13:18 <lambdabot>  Couldn't match expected type `Float' against inferred type `String'
12:13:49 <roconnor> > let fac n = map (\x -> (x, x==product [1..(read n)])) $ scanl (*) 1 [1..(read n)] in fac "5" :: [(Float, Bool)]
12:14:05 <lambdabot>  thread killed
12:14:28 <dolio> http://au.youtube.com/watch?v=OXc5ltzKq3Y
12:14:29 <lambdabot> Title: YouTube - Firehose
12:15:26 <roconnor> lambdabot: show me some love here.
12:16:13 <Deewiant> > let fac n = map (flip (,) True) (scanl (*) 1 [1..read n]) in fac "5" :: [(Float, Bool)]
12:16:13 <lambdabot>  [(1.0,True),(1.0,True),(2.0,True),(6.0,True),(24.0,True),(120.0,True)]
12:17:35 <roconnor> > let fac n = map (\x -> (x, x==fromInteger (product [1..(read n)]))) $ scanl (*) 1 [1..(read n)] in fac "5" :: [(Float, Bool)]
12:17:49 <lambdabot>  [(1.0,False),(1.0,False),(2.0,False),(6.0,False),(24.0,False),(120.0,True)]
12:20:08 <noteventime> Where was that page with the proposals for the next Haskell standard?
12:20:15 <noteventime> Lol, found it
12:20:17 <Deewiant> > let fac n = (\a -> init a ++ (\(x,_) -> [(x,True)]) (last a)) $ map (flip (,) False) (scanl (*) 1 [1..read n]) in fac "5" :: [(Float, Bool)]
12:20:17 <noteventime> Sorry
12:20:19 <lambdabot>  [(1.0,False),(1.0,False),(2.0,False),(6.0,False),(24.0,False),(120.0,True)]
12:20:40 <Deewiant> @pl \a -> init a ++ (\(x,_) -> [(x,True)]) (last a)
12:20:40 <lambdabot> liftM2 (++) init (return . flip (,) True . fst . last)
12:21:13 <roconnor> ah fst . last; the best of the worst.
12:21:31 <Deewiant> :-)
12:22:26 <byorgey> dolio: what the heck is that from!?
12:22:30 <bd_> something makes me think that that could be done better with arrow functions
12:22:32 <bd_> :t second
12:22:33 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
12:22:48 <dolio> byorgey: UHF
12:22:57 <dolio> Weird Al's finest movie.
12:22:58 <Deewiant> I thought about it but couldn't come up with something quickly
12:23:22 <byorgey> dolio: ah, I see =)
12:23:22 <bd_> :t \a -> liftM2 (++) id (second (const True) . last)
12:23:24 <lambdabot>     Couldn't match expected type `(d, Bool)'
12:23:24 <lambdabot>            against inferred type `[a]'
12:23:24 <lambdabot>       Expected type: (d, Bool) -> (d, b)
12:23:33 <bd_> :t \a -> liftM2 (++) id ((:[]) . second (const True) . last)
12:23:34 <lambdabot> forall t d. t -> [(d, Bool)] -> [(d, Bool)]
12:23:51 <bd_> minus \a ->
12:23:57 <nibro> @where paste
12:23:57 <lambdabot> http://hpaste.org/new
12:24:17 <bd_> @check \a -> (liftM2 (++) init (return . flip (,) True . fst . last) (a :: [(Int, Bool)])) == (liftM2 (++) id (second (const True) . last) a)
12:24:18 <lambdabot>  Couldn't match expected type `[(Int, Bool)]'
12:24:46 <Deewiant> @check \a -> (liftM2 (++) init (return . flip (,) True . fst . last) (a :: [(Int, Bool)])) == (liftM2 (++) id (return . second (const True) . last) a)
12:24:46 <lambdabot>  Exception: Prelude.init: empty list
12:25:07 <bd_> what did you change?
12:25:11 <Deewiant> @check \a -> null a || (liftM2 (++) init (return . flip (,) True . fst . last) (a :: [(Int, Bool)])) == (liftM2 (++) id (return . second (const True) . last) a)
12:25:12 <lambdabot>  Falsifiable, after 1 tests: [(0,True),(3,True)]
12:25:26 <bd_> > (liftM2 (++) id (return . second (const True) . last) [(0,True),(3,True)]
12:25:27 <lambdabot> Unbalanced parentheses
12:25:32 <Deewiant> bd_: added 'return .' in the second one
12:25:33 <bd_> > (liftM2 (++) id (return . second (const True) . last)) [(0,True),(3,True)]
12:25:33 <lambdabot>  [(0,True),(3,True),(3,True)]
12:25:37 <bd_> ah
12:25:48 <bd_> > (liftM2 (++) init (return . flip (,) True . fst . last) [(0,True),(3, True)]
12:25:49 <lambdabot> Unbalanced parentheses
12:25:52 <bd_> > (liftM2 (++) init (return . flip (,) True . fst . last)) [(0,True),(3, True)]
12:25:53 <lambdabot>  [(0,True),(3,True)]
12:25:56 <bd_> hmm
12:26:05 <nibro> someone who'd like to take a look at this?
12:26:05 <bd_> oh, didn't strip off the last
12:26:06 <nibro> http://hpaste.org/6644
12:26:12 <bd_> ...did I? I did...
12:26:12 <unenough> > liftM liftM
12:26:13 <lambdabot>  Add a type signature
12:26:15 <nibro> any answers much appreciated
12:26:17 <bd_> oh, init
12:26:26 <bd_> @check \a -> null a || (liftM2 (++) init (return . flip (,) True . fst . last) (a :: [(Int, Bool)])) == (liftM2 (++) init (return . second (const True) . last) a)
12:26:26 <lambdabot>  OK, passed 500 tests.
12:29:05 <ptolomy2> Is it safe to unsafePerformIO (newIORef Nothing)?
12:29:24 <mauke> unlikely
12:29:36 <bd_> ptolomy2: Define 'safe'
12:30:01 <bd_> It won't crash, but it might be evaluated more than once (= you get more IORefs than expected)
12:30:11 <ptolomy2> "not likely to result in horrible errors when the value returned is later set to (Just Foo) in IO"
12:30:18 <bd_> in GHC you'll want to bind it to a top-level variable, and use NOINLINE
12:30:19 <monochrom> I think it opens up a type unsoundness.
12:30:26 <bd_> and yes, explicitly type it
12:30:30 <ptolomy2> I intend it to be monomorphic.
12:30:31 <ahunter> Erm, this is stupid, but I have f :: a -> b -> c -> d, g :: [a], h :: [b], i :: [c] (g,h,i match lengths...) and I want to map f across the three lists. The kind of thing that in scheme is just (map f g h i).  Is there a clean way to do this?
12:30:38 <monochrom> OK, monomorphic is safe.
12:30:45 <bd_> :t zipWith3
12:30:46 <lambdabot> forall a b c d. (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
12:30:51 <bd_> ahunter: how's that look?
12:30:58 * ptolomy2 is aiming to do the equivalent of a null pointer. 
12:31:02 <bd_> zipWith3 f g h i
12:31:15 <unenough> A function in Haskell is a value just like any other, right?
12:31:21 <ahunter> sweet, ty
12:31:30 <bd_> ptolomy2: Why do you need to create an IORef with an unsafePerformIO? The only time that's useful is for global variables.
12:31:45 <bd_> so if you're using it for something else ... don't, it won't behave the way you expect
12:31:48 <Excedrin> unenough: pretty much
12:31:49 <monochrom> nibro: I'm looking.
12:32:10 <unenough> So, why doesn't this simple evaluate to the function that it is:
12:32:18 <nibro> monochrom: :-)
12:32:18 <unenough> > id
12:32:19 <lambdabot>  Add a type signature
12:32:25 <mauke> it does
12:32:33 <unenough> "Add a type signature"?
12:32:34 <Deewiant> @ty id
12:32:35 <lambdabot> forall a. a -> a
12:32:45 <mauke> unenough: that's just for printing
12:32:45 <Twey> > id :: Int -> Int
12:32:46 <lambdabot>  <Int -> Int>
12:32:49 <bd_> unenough: It needs to know what type you expect id to be
12:32:51 <unenough> oh
12:32:55 <unenough> ok i got it
12:32:57 <Twey> There are different ids
12:33:01 <bd_> It'll try to infer it usually, but you didn't give it any help :)
12:33:03 <Twey> For different types
12:33:04 <unenough> yeah... forgot about that
12:33:06 <Twey> (kind of)
12:33:10 <ptolomy2> Well, I have a big pile of nice lazy pure code to generate some deep structures, then I realize "Oh man, I'd really like to be able to be able to cache some stuff in there when I later am walking this in the IO monad"..
12:33:39 <Cale> In general, you can't print functions to the screen at all, since they're not usually instances of Show, but lambdabot has some instances when the types are monomorphic.
12:33:44 <Cale> (and instances of Typeable)
12:33:58 <bd_> ptolomy2: That's not really safe, you might end up with N different IORefs when you expected to have one
12:34:00 <ptolomy2> In most languages, I'd do a null reference/pointer, and it seems like such a thing is safe to have in a pure context so long as it isnt referenced.
12:34:07 <ptolomy2> Oh, I want N different ones.
12:34:16 <bd_> ptolomy2: Except the N isn't under your control :)
12:34:17 <Cale> ptolomy2: You could split up the computation in the IO monad.
12:34:19 <ptolomy2> Oh.
12:34:36 <unenough> Cale, monomorphic?
12:34:43 <Cale> unenough: Opposite of polymorphic
12:34:45 <Deewiant> instance Show (a -> b) where show _ = "<function>"
12:34:48 <unenough> ok
12:35:01 <ptolomy2> Cale: As in "do all my lazy stuff, but have it return some IO (), which is later sequenced or something?"
12:35:10 <bd_> ptolomy2: The problem is: If you just write (newIORef Nothing), GHC's free to evaluate that exactly once, over your /entire program/
12:35:15 <Cale> ptolomy2: well, that might be an option...
12:35:20 <bd_> and it's also free to evaluate it thousands of times
12:35:29 <bd_> I mean, in unsafePerformIO that is
12:35:53 <bd_> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-Conc.html#prodding <-- you can force it to take the former approach to make a global variable
12:35:54 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/344gsg
12:36:03 <ptolomy2> Dang. Haskell discourages dirty low level hacks, which is a bit awkward when you start wanting to do dirty low-level hacks.
12:36:03 <Cale> ptolomy2: But I was suggesting that you have some IO action which looked like   do let {x = firstPartOfComputation}; cacheStuff x; let {y = secondPartOfComputation x}; ...
12:36:34 <bd_> I recall reading some paper which did dirty hacks to implement memoization
12:36:54 <bd_> I forget what paper it was though...
12:37:02 <Cale> ptolomy2: But I'm not exactly sure what it is that you're doing, so I have no idea if that's at all reasonable.
12:37:41 <bd_> ptolomy2: You could also use a State monad and just use the state variable to hold your cache
12:38:34 <ptolomy2> Ok, context: I have an interpreter that does all the parsing and analysis for code lazily as needed (I sorta use laziness where "if (x == NULL) x = parseStuff()" might be used elsewhere).. I figure I can save myself the trouble of looking up method calls dynamically by doing call-site caching, but that will require IO somewhere.
12:39:14 <Cale> ptolomy2: Why will it require IO?
12:39:30 <unenough> Can someone explain this syntax please?
12:39:34 <unenough> @ty lifTM
12:39:35 <lambdabot> Not in scope: `lifTM'
12:39:37 <Cale> ptolomy2: You can just make that method call lookup part of the data structure perhaps?
12:39:38 <unenough> @ty liftM
12:39:39 <Deewiant> @ty liftM
12:39:39 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
12:39:40 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
12:39:48 <mauke> unenough: which part?
12:39:51 <Cale> ptolomy2: then when it's evaluated, it'll be only evaluated once.
12:40:00 <unenough> what's the . and the =>
12:40:03 <Deewiant> (m :: * -> *) specifies the kind of m, it's a GHC extension
12:40:12 <mauke> unenough: everything before the . is not standard haskell 98
12:40:27 <mauke> the => separates class constraints and the actual type
12:40:32 <Deewiant> @ty 1
12:40:33 <lambdabot> forall t. (Num t) => t
12:40:46 <Cale> unenough: that's saying that for all types a1 and r and all type constructors m, if m is an instance of Monad, then liftM has type (a1 -> r) -> m a1 -> m r
12:40:58 <unenough> thanks everybody!
12:41:31 <Cale> Basically, liftM is the same thing as map, but generalised to monads other than lists.
12:41:40 <bd_> ptolomy2: research.microsoft.com/~simonpj/Papers/weak.ps.gz may be of interest
12:41:41 <Cale> > liftM (*2) [1,2,3]
12:41:42 <lambdabot>  [2,4,6]
12:41:43 <ptolomy2> Cale: It'd be nice if that'd work, but the language is uncomfortably dynamic, so a method may go away at any time; my approach is to keep a namespace and method state datatype which the cache will check, and if it is the same use the cached value, and if not do the lookup and recache.. possibly eventually a Self-like polymorphic inline cache thing.
12:41:56 <bd_> ptolomy2: it includes a generic function result caching method
12:42:17 <unenough> ok
12:42:26 <Cale> > liftM (*2) (Just 5)
12:42:26 <lambdabot>  Just 10
12:42:36 <bd_> ptolomy2: if you're already in a monad of some sort, you can always put the St or IO monad under it to use STRefs or IORefs
12:42:40 <ptolomy2> .. although this optimization should probably not happen until I've done quite a few other refactorings.
12:42:45 <Cale> :t liftM (*2) readLn
12:42:46 <lambdabot> forall a1. (Read a1, Num a1) => IO a1
12:42:50 <mauke> St. Monad
12:43:16 <ptolomy2> bd_: Evaluation happens in a monad (a transformer with StateT and IO at the core), but parsing and analysis are all pure
12:43:35 <bd_> ptolomy2: your dynamicism would occur at runtime, though, right?
12:43:41 <ptolomy2> Yeah.
12:43:54 <bd_> though, oh, hm
12:44:13 <bd_> ptolomy2: You could put a spot for a IORef in the tree, start it out undefined, then use Data.Generics to replace them with real IORefs :)
12:44:16 <ptolomy2> Hm.. I guess I could do data ParsedStuff = LazilyParsedStuff | Other (IORef trickyRuntimeWhatnot)
12:44:19 <bd_> Data.Generic even
12:44:53 <ptolomy2> bd_: That'd probably work. It comes very close to my initial "start it out with a null pointer and fill it in later" thing.
12:45:06 <bd_> <3 Data.Generic
12:45:21 <Cale> ptolomy2: You should be able to keep parsing in a completely separate pass from evaluation, I'd hope.
12:45:27 <nibro> throwing this out here again: http://hpaste.org/6644
12:45:34 <nibro> anyone knows the answer to my questions there?
12:46:06 <ptolomy2> Cale: For sure.
12:46:22 <aks42> Hello! I got a user question, hope I am right here. What is the most efficient way to test, if a list has exactly one element. Like "null" as a test for empty lists. I'd like to avoid counting with "length" and then comparing to 1. I'd expect that to be inefficient.
12:46:29 <Cale> nibro: GHC 6.8 has type equality constraints -- I haven't read your thing completely yet, so I don't know if that's what you're looking for.
12:47:10 <nibro> Cale: without testing, I suppose that *may* work, though it would be totally counter to my purpose of wanting a simpler type :)
12:47:12 <bd_> aks42: case l of [x] -> True; [] -> False  works :)
12:47:14 <bd_> er
12:47:15 <bd_> _ -> False
12:47:45 <bd_> or \l -> (not $ null l) && (null $ drop 1 l)
12:47:53 <mauke> liftM2 (&&) (not . null) (null . tail)
12:47:54 <bd_> but the case is probably the most 'efficient'
12:47:57 <Deewiant> that's what I use, and I compared a few implementations and it does seem that that generates the fastest-looking Core code
12:48:00 <bd_> because everything else is built out of cases in the end
12:48:06 <Deewiant> the liftM2 generates the same code
12:48:08 <Deewiant> IIRC
12:48:19 <bd_> same code as the case? neat
12:48:25 <mauke> I wasn't serious :-)
12:48:31 <aks42> Ah, that is good to know. Thank you. Then I'l use a case and try to match [_].
12:48:40 <Deewiant> length1 [_] = True; length1 _ = False;
12:49:05 <Deewiant> mauke: I thought about pointlessing it that way but decided against it ;-)
12:49:23 <ahunter> Out of curiousity, does getting the error: ":test: thread blocked indefinitely" just mean that the runtime can't find anything to run and there's no external calls it's waiting on?
12:49:54 <bd_> ahunter: It means there was a deadlock of some sort - the runtime was able to prove that the thread could never, ever be awoken
12:50:06 <roconnor> where is unsafeCoerce in GHC 6.6?
12:50:11 <ahunter> ok, that's...od
12:50:19 <mauke> @index unsafeCoerce
12:50:19 <lambdabot> bzzt
12:50:26 <bd_> @hoogle unsafeCoerce
12:50:26 <lambdabot> Unsafe.Coerce.unsafeCoerce :: a -> b
12:50:53 <ahunter> http://hpaste.org/6645
12:51:02 <bd_> ahunter: To be precise, it does a garbage collection cycle, with anything that could awaken a thread being considered a reference to it. If the thread is still on the chopping block, it's sent an exception.
12:51:20 <Cale> > fun :: forall a m. (C m a, C m (X m ())) => a -> X m ()
12:51:20 <lambdabot>  Parse error at "." (column 18)
12:51:21 <Cale> > fun a = foo (foo a :: X m ())
12:51:21 <lambdabot>  Parse error at "=" (column 7)
12:51:23 <ptolomy2> Hm.. I think after a while I'll send an experience report to -cafe.. I suppose my experiences trying to manage a performance-oriented and inherently imperative task as a haskell noob might be interesting.
12:51:24 <bd_> ahunter: takeMVar on an empty mvar blocks
12:51:24 <Cale> sigh :)
12:51:32 <ahunter> "test" with the proper arguments will do a bunch of computation, and finish by putting to the Mvar it's passed
12:51:34 <Cale> nibro: how is that?
12:51:36 <bd_> ahunter: and since no other thread has a reference to the MVar, you have a deadlock
12:51:40 <mauke> ahunter: looks like replicateM
12:51:45 <nibro> Cale: didn't work, still no way to tie the equality constraints in the type to have anything to do with the types of the expressions
12:51:51 <bd_> oh, wait
12:51:51 <Baughn> bd_: Is it possible to affect that? It's being overly smart and discounting the deadlock when there's a signal handler that might awaken it.
12:51:58 <ahunter> bd_: dopesn't test have a reference to the mvar?
12:52:11 <bd_> Baughn: I don't know, I'm not a GHC runtime hacker :)
12:52:13 <Cale> nibro: You actually don't need those either. You just need lexically scoped tyvars.
12:52:15 <syntaks> hello
12:52:24 <bd_> ahunter: Apparently not. One of your tests must have leaked one
12:52:26 <Cale> nibro: (have a look at the code I just pasted above)
12:52:30 <Cale> syntaks: hello
12:53:02 <nibro> Cale: that code worked fine! :-)
12:53:18 <ahunter> bd_: pretty sure that's not possible, I can demonstrate that it does (for example, if "threads =1" and I do retval <- takeMVar $ head retvs, it works
12:53:37 <Cale> nibro: the explicit forall turns on lexical scoping of the bound variables over the whole function definition
12:53:41 <nibro> Cale: was that because the forall introduced tyvars a and m...
12:53:43 <ahunter> mauke: where is replicateM defined/
12:53:45 <bd_> ahunter: huh, weird, what is the test then?
12:53:45 <nibro> right :-)
12:53:49 <monochrom> nibro: I'm about to post the same. Cale beats me to it. :)
12:54:03 <bd_> ahunter: http://hpaste.org/6645#a1 try something like this maybe?
12:54:05 <mauke> @index replicateM
12:54:06 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
12:54:07 <Cale> ahunter: Control.Monad
12:54:09 <nibro> Cale, monochrom: thanks a lot, just what I was looking for :-)
12:54:12 <unenough> What's missing here?
12:54:13 <unenough> > liftM liftM (Just (id :: Int->Int))
12:54:13 <lambdabot>  Add a type signature
12:54:14 <monochrom> Without "forall a m", every time you say "m" it can be a different m.
12:54:17 <Baughn> bd_: I don't suppose you could point me at the part of the RTS that does the detection?
12:54:30 <Deewiant> @ty liftM liftM (Just (id :: Int->Int))
12:54:31 <lambdabot> forall (m :: * -> *). (Monad m) => Maybe (m Int -> m Int)
12:54:33 <Baughn> bd_: It seems to me that an explicit check for XCPU (which can never break deadlocks) is in order
12:54:41 <bd_> Baughn: I read this on the GHC internals pages on trac a while ago... I haven't looked at the actual code
12:54:53 <nibro> monochrom: yeah, so I noticed, nice to know there's a simple way to introduce scoped tyvars without resorting to dummy arguments
12:54:55 <ahunter> http://hpaste.org/6646
12:55:22 <ahunter> bd_: I'm confident it gets to the putMVar line, if I add printfs between res <- ... and putMVar, I get there
12:55:43 <bd_> ahunter: at a guess, maybe a test thread died due to an exception? If not... not sure (and need to afk shortly...)
12:56:20 <unenough> Deewiant, what argument is missing for that call to work?
12:56:37 <ahunter> bd_: don't think so, though would it be a problem if test just runs off the end?
12:56:46 <nibro> Cale, monochrom: it worked wonders in my real code as well, thanks a lot! :-)
12:56:55 <bd_> ahunter: well if it dies before hitting putMVar...
12:57:07 <Cale> nibro: no problem :)
12:57:10 <bd_> But I don't know :/
12:57:14 <ahunter> bd_: not happening, I can trace that...thanks anyway
12:57:33 <monochrom> nice.
12:57:55 <roconnor> *AbortEmpty> r <- abortAny (\a -> a (\b -> b (\c -> a (\_ -> c))))
12:57:56 <roconnor> *** Exception: (unknown)
12:58:03 <Deewiant> unenough: what exactly are you trying to do?
12:58:05 <roconnor> jbapple: that surprises me.
12:58:46 <unenough> Deewiant, i'm trying to call liftM with itself as the function
12:58:51 <unenough> (educational purposes :)
12:58:52 <jbapple> roconnor: I lost the thread. What surprises you?
12:59:06 <syntaks> is it possible to initialize record fields from IO actions? For example, assuming that I have data MyRec = Rec {a::String}, I'd want to write something like f :: IO MyRec; f = Rec {a=getLine}
12:59:09 <jbapple> jbapple: oh, that thing you just typed
12:59:12 <Deewiant> unenough: I can see that, and you've managed to confuse me as to what's going on, in the process ;-)
12:59:28 <gwern> @hoogle m a -> a
12:59:29 <lambdabot> Prelude.id :: a -> a
12:59:29 <lambdabot> Unsafe.Coerce.unsafeCoerce :: a -> b
12:59:29 <lambdabot> Data.Function.id :: a -> a
12:59:32 <roconnor> jbapple: that running  abortAny (\a -> a (\b -> b (\c -> a (\_ -> c)))) throws an exception.
12:59:35 <Baughn> bd_: I'd like to say I found it, but Scheduler.c is 3205 lines. Oh well; I /did/ want to figure it out more generally.
12:59:43 <Deewiant> unenough: it seems to me that the outer liftM lifts the inner liftM to an arbitrary monad
12:59:51 <roconnor> jbapple: I don't think it should.
13:00:00 <Deewiant> unenough: and you're not specifying which one, which is why the type signature is Maybe (m Int -> m Int) for any Monad m.
13:00:23 <unenough> isn't it because of the Just?
13:00:29 <bd_> Baughn: And remember the actual detection is the GC's job :)
13:00:30 <Cale> > map ($ [1,2,3]) (liftM liftM [(+1), (*2), (+5)])
13:00:35 <lambdabot>  [[2,3,4],[2,4,6],[6,7,8]]
13:00:41 <Deewiant> unenough: that specifies the outer monad, so just for one of the liftMs.
13:00:44 <byorgey> syntaks: f = Rec `fmap` getLine  ought to work
13:00:45 <bd_> Baughn: keep in mind that one might /want/ to wait for a signal in some cases
13:01:04 <Baughn> bd_: Yes, but this is a special case
13:01:04 <Cale> > sequence (liftM liftM [(+1), (*2), (+5)]) [1,2,3]
13:01:05 <lambdabot>  [[2,3,4],[2,4,6],[6,7,8]]
13:01:10 <bd_> howso?
13:01:28 <roconnor> *AbortEmpty> r <- abortAny (\f -> f 5)
13:01:29 <byorgey> syntaks: you can't say Rec {a = getLine} directly, since getLine :: IO String, and a needs to be just a String
13:01:29 <Baughn> bd_: I want it to detect if (a) there are no running threads, and (b) the only installed handler is for XCPU - cpu time limit exceeded, which will never happen
13:01:29 <unenough> Deewiant, ok i'll look into Cale's examples
13:01:31 <roconnor> *** Exception: (unknown)
13:01:48 <roconnor> jbapple: okay, it doesn't even work in the simple case.
13:01:53 <Baughn> bd_: My latest patch to lambdabot broke loop detection by installing a handler for XCPU, see. :P
13:01:59 <jbapple> roconnor: oops, must have lost something along the way
13:02:02 <byorgey> syntaks: perhaps more readable would be  f = do { l <- getLine ; return $ Rec { a = l } }
13:02:08 <Deewiant> > let f = liftM liftM (Just id) in case f of Nothing -> Just 1; Just f -> f (Just 3)
13:02:09 <lambdabot>  Just 3
13:02:10 <bd_> ah
13:02:18 <Deewiant> unenough: too many Monads in one line :-P
13:02:21 <syntaks> byorgey, yep... but I had hoped there was a way to kind of promote the IO to the enclosing context
13:02:30 <unenough> yeah ;)
13:02:50 <Baughn> bd_: Well, I should say, (a) no threads that could conceivably wake up except for the signal
13:02:56 <byorgey> syntaks: well, that's what the example I showed first with fmap is doing, basically
13:03:23 <bd_> Baughn: Well, the actual signal dispatch stuff is in GHC.Conc
13:03:38 <bd_> (and I actually have a half-finished patchset to add epoll support to that, which I should clean up and submit sometime)
13:03:40 <roconnor> jbapple: it seems your catchDyn isn't working properly.
13:03:42 <byorgey> syntaks: the fmap is promoting Rec :: String -> MyRec  to  fmap Rec :: IO String -> IO MyRec
13:03:47 <syntaks> byorgey, will taht just initialize the fields in the order in which they are declared?
13:03:55 <gwern> hm. so if I have 'fakeSendKey char = withDisplay $ liftM $ \dpy -> allocaXEvent $ \replyPtr ->', I get a m Display/Display type mismatch error, but if I remove the liftM, I get 'Couldn't match expected type `X a' against inferred type `IO ()''.
13:03:56 <gwern> ...What?
13:04:28 <byorgey> syntaks: right
13:04:40 <byorgey> syntaks: if you want to use record syntax, you'll probably have to use the second way that I showed, with the explicit do-block
13:04:46 <jbapple> roconnor: it's the case statement, in which I conflate Dynamic and Empty, foolishly
13:05:04 <syntaks> byorgey, so for any Rec {f1::a... fn::x} there is a Rec a ... x , so to speak?
13:05:24 <roconnor> jbapple: really? it looks okay to me.
13:05:44 <jbapple> @type catchDyn
13:05:50 <byorgey> syntaks: right, in fact, the record syntax is just some syntax sugar to give you a way to extract individual elements by name
13:05:50 <lambdabot> Not in scope: `catchDyn'
13:05:50 <jbapple> :type catchDyn
13:06:00 <Baughn> bd_: This is perhaps beside the point, but my new server can grep the ghc source tree in .063 seconds. I'm happy ^_^ - but isn't there a better way to navigate through haskell code? ^^;
13:06:10 <jbapple> :t Control.Exception.catchDyn
13:06:10 <lambdabot> forall a exception. (Typeable exception) => IO a -> (exception -> IO a) -> IO a
13:06:14 <byorgey> syntaks: but "under the hood" they are still stored in a particular order, and you can use it as if you hadn't used the record names
13:06:34 <jbapple> :t fromDynamic
13:06:35 <lambdabot> forall a. (Typeable a) => Dynamic -> Maybe a
13:06:46 <syntaks> byorgey, ok... that gives me something to go on... thanks a lot!
13:06:56 <byorgey> syntaks: you're welcome, glad it was helpful!
13:07:00 <bd_> Baughn: haddock docs? :)
13:07:28 <roconnor> jbapple: I'm not convinces that fromDynamic works on coerced values.
13:07:48 <Baughn> bd_: How do I make it show internals such as NonTermination, then?
13:07:53 <roconnor> jbapple: in fact, I think it may break horrably.
13:07:58 <bd_> Baughn: No idea :/
13:08:05 <roconnor> jbapple: but I don't know much about Dynamic.
13:10:17 <bd_> Baughn: anyway, must afk, good luck finding it :)
13:10:21 <Baughn> bd_: "scheduleDetectDeadlock". I must say, compared to SBCL, this is /good/ C. ^_^
13:10:49 <syntaks> byorgey, can the fmap example also work for records with more than one field?
13:11:23 <byorgey> syntaks: no, not in the same way
13:11:43 <byorgey> syntaks: although you could use Control.Applicative combinators to do something similar
13:12:04 <byorgey> syntaks: something like  MultiFieldRec <$> getLine <*> getLine <*> getInt <*> getChar
13:12:21 <byorgey> which is actually rather nice, IMO =)
13:13:05 <byorgey> that would get two lines, an int, and a char from stdin (assuming getInt and getChar are defined appropriately, which I think they are) and put them all in a MultiFieldRec
13:13:16 <syntaks> byorgey, at first sight, this looks spooky... but I'll just try it... no better way to learn than to get your hands dirty :)
13:13:21 <byorgey> and the type of the entire expression would be  IO MultiFieldRec
13:13:34 <byorgey> assuming  data MultiFieldRec = MultiFieldRec String String Int Char
13:13:51 <ahunter> so, the feeling you get when STM means you can write nice easy code and do half a million tree operations, concurrently split among 8 processors, on the same tree, in all of 8 seconds?  Pretty fun.
13:14:08 <Baughn> bd_: Found it. Fixed it. Apart from naming, a one-liner - this was enjoyable.
13:14:09 <byorgey> ahunter: =D
13:14:29 <byorgey> ahunter: that sounds awesome.  Maybe blog about it somewhere? =)
13:14:46 <byorgey> syntaks: sure, have fun.  ask away if you've got questions. =)
13:15:34 <ahunter> byorgey: my PLs seminar (three students and an interested prof) are currently translating the STAMP benchmarks; when we're done, we'll be making them public
13:15:45 <byorgey> ahunter: cool.
13:18:12 <roconnor> strange.
13:18:31 <roconnor> *AbortEmpty> dynTypeRep (toDyn ())
13:18:31 <roconnor> ()
13:18:31 <roconnor> *AbortEmpty> catchDyn (return $ throwDyn ()) (return . dynTypeRep)
13:18:31 <roconnor> *** Exception: (unknown)
13:18:34 <adiM> I am trying to install maybeT from http://hackage.haskell.org/cgi-bin/hackage-scripts/package/MaybeT-0.1.0 . runhaskell Setup.hs build says Illegal instance declaration for `MonadReader r (MaybeT m)' ...   Use -XFlexibleInstances if you want to disable this.). How do I do this?
13:18:34 <ahunter> Actually, there's a style question:  I'm doing some monadic computation.  Halfway through, I need to make a decision and either return a value or continue with more calculation.  Is there a cleaner way than this: http://hpaste.org/6648
13:18:35 <lambdabot> http://tinyurl.com/2ld9g2
13:18:40 <roconnor> why doesn't the second command work?
13:19:22 <ahunter> I'd like to get rid of the nested do statement, push that up to top level somehow...
13:19:37 <roconnor> I know this dynamic type stuff was no good.
13:19:43 <roconnor> *knew
13:20:45 <monochrom> adiM: somewhere in the cabal file you can add that.  This means probably the package hasn't been updated to include it.
13:22:37 <byorgey> ahunter: well, you could do it with continuations, but that's probably way overkill for what you're trying to do =)
13:22:52 <byorgey> ahunter: there's also an Exit monad on the wiki somewhere
13:22:56 <adiM> monochom, thanks. Found ghc-options field in the cabal file
13:28:09 <dolio> roconnor: throwDyn () throws a ()
13:28:17 <dolio> return . dynTypeRep catches a Dynamic.
13:28:28 <dolio> So your exception goes through.
13:29:23 <dolio> catchDyn (throwDyn (toDyn ())) (return . dynTypeRep) -- ==> ()
13:29:56 <roconnor> oh
13:32:11 <roconnor> dolio: that suggests that jbapple
13:32:20 <roconnor> 's first implemenation was correct
13:32:21 <dolio> catchDyn apparently lets you catch an acception of any specific typeable type.
13:32:29 <dolio> Exception, even.
13:32:39 <dolio> Man, that was quite a slip, there.
13:32:59 <roconnor> so catchDyn will only catch exceptions of the proper typeable type?
13:33:12 <roconnor> that's pretty magical
13:33:24 <dolio> Yeah, catchDyn (...) (\() -> ...) will catch any () thrown.
13:33:30 <dons> Typeable makes your Types into Values :)
13:33:51 <roconnor> dolio: but not catch anything else.
13:33:56 <dolio> Right.
13:35:11 <dolio> Your catch function has to take a concrete exception type, though, apparently.
13:35:16 <dolio> Which isn't surprising, I guess.
13:35:28 <EvilTerran> polymorphic types aint Typeable
13:35:53 <roconnor> *AbortEmpty> :type abortAny
13:35:54 <roconnor> abortAny :: forall a. ((a -> Bot) -> Bot) -> IO a
13:35:54 <roconnor> *AbortEmpty> r <- abortAny (\a -> a (\b -> b (\c -> a (\_ -> c))))
13:35:54 <roconnor> *AbortEmpty> :type r
13:35:54 <roconnor> r :: ((() -> ()) -> ()) -> ()
13:35:54 <roconnor> *AbortEmpty>
13:36:33 <roconnor> *AbortEmpty> :type r
13:36:35 <roconnor> r :: ((() -> ()) -> ()) -> ()
13:36:47 <roconnor> WTF?
13:36:48 <dolio> EvilTerran: Well, I mean, you can't even give it a function that will catch any typeable and return some constant.
13:36:52 <dolio> You have to pick one.
13:36:52 <roconnor> where did all those unit's come from?
13:37:15 <dolio> So it knows what to try to cast to.
13:38:02 <dolio> roconnor: Defaulting, maybe?
13:38:16 <roconnor> I thought Defaulting only work on Num types.
13:39:07 <roconnor> not only that ((() -> ()) -> ()) -> () is an imposible type for r to be
13:39:25 <roconnor> boy, this has really messed up GHC.
13:39:37 <dolio> Oh, I guess it wouldn't be defaulting. There's no typeclass involved, even.
13:42:58 <roconnor> *AbortEmpty> x <- evaluate id
13:43:00 <roconnor> *AbortEmpty> :type x
13:43:00 <roconnor> x :: () -> ()
13:43:05 <roconnor> ?
13:43:26 <roconnor> does ghci do more defaulting than ususal?
13:43:28 <dolio> Wait, yeah, that has to be defaulting.
13:43:39 <dolio> It has to pick a type to evaluate id at.
13:43:48 <Twey> :t evaluate
13:43:49 <lambdabot> forall a. (Testable a) => a -> Gen Result
13:43:56 <Twey> Er
13:43:59 <roconnor> wrong evaluate
13:44:00 <Twey> What's this?
13:45:28 <Cale> :t Control.Exception.evaluate
13:45:29 <lambdabot> forall a. a -> IO a
13:45:32 <dolio> roconnor: I get GHC.Prim.Any -> GHC.Prim.Any
13:45:41 <dolio> Which is possibly even weirder.
13:46:27 <roconnor> I think it is an imporvement
13:49:10 <dolio> I suppose, it still does what it's supposed to if you unsafeCoerce stuff.
13:59:54 <pleaseandthankyo> do you have to respect and let them know that you respect others beliefs? what if someone hurt you for not respecting?
14:00:28 <cjb> How is this question on-topic for this channel?
14:00:29 <ahunter> I think you might be in the wrong room
14:02:00 <pleaseandthankyo> do you have to respect and let them know that you respect others beliefs? what if someone hurt you for not respecting?
14:02:10 --- mode: ChanServ set +o Cale
14:02:22 --- mode: Cale set -b *!*@adsl-99-148-255-87.dsl.hstntx.sbcglobal.net
14:02:25 <dolio> @vixen What do you think?
14:02:25 <lambdabot> i do occassionally, i guess
14:02:27 --- mode: Cale set +b *!*@CPE00012e15cab1-CM00194757ed42.cpe.net.cable.rogers.com
14:02:37 <QplQyer> hmm   (cHandle,cHost,cPort) <- accept servSock    gives: ERROR "httpserver.hs":10 - Syntax error in expression (unexpected `<-')  anyone knows why?
14:02:47 --- mode: Cale set -o Cale
14:03:03 <kpreid> QplQyer: that line or a preceding one is wrongly indented
14:03:50 <ahunter> dolio: what is @vixen?
14:04:01 <dolio> @vixen What are you?
14:04:01 <lambdabot> i truely am
14:04:08 <dolio> @vixen a/s/l
14:04:08 <lambdabot> 19/f/California
14:04:13 <olsner> @vixen indeed?
14:04:13 <lambdabot> first you tell me.
14:04:24 <sethk> what's the general procedure to use the debugger?  Do you have to compile with a debugging flag?
14:04:32 <QplQyer> hmm should be properly indented though
14:04:46 <ahunter> ah, so slutty Eliza?
14:05:47 <thoughtpolice> sethk: no, use it from ghci
14:06:03 <gwern> I sometimes wish we had a more compact import notation. it's annoying to have to write 'import' a bazillion times sometimes
14:06:03 <sethk> thoughtpolice, ok.  I just found the page in the wiki about it. :)
14:06:26 <sethk> gwern, create a macro and bind it to a key
14:06:57 <shapr> ahunter: Vixen was originally an IM bot written in Visual Basic.
14:07:12 <gwern> sethk: it's an aesthetic thing
14:07:15 <shapr> It was ported to a lambdabot plugin by Mark Wotton.
14:07:28 <ahunter>  shapr: thanks
14:08:10 <gwern> @where HTK
14:08:10 <lambdabot> I know nothing about htk.
14:08:53 * gwern wonders what the HTK is mentioned by http://haskell.org/haddock/ - Haskell TK?
14:08:55 <lambdabot> Title: Haddock
14:09:24 <gwern> @where+ htk http://www.informatik.uni-bremen.de/htk/
14:09:24 <lambdabot> I will remember.
14:09:24 <gwern> @where HTK
14:09:24 <lambdabot> http://www.informatik.uni-bremen.de/htk/
14:09:46 <sethk> I must be doing something wrong.  I load the module in ghci.  Then I say :break 713, but it says "cannot find default module for breakpoint.  Perhaps no modules are loaded for debugging?"
14:09:46 <QplQyer> http://hpaste.org/6649  is there some wrong indentation there?
14:09:57 <sethk> but the wiki doesn't show any special way to load a module for debugging
14:10:44 <Botje> QplQyer: you can't do that
14:10:55 <Botje> the binding you made in the accept won't be transferred to the last part
14:11:01 <sethk> hmm, now a different message  "cannot set breakpoint on ..... module ProcessSpecs is not interpreted"
14:11:43 <sethk> so how do I load a module to be interpreted?
14:12:01 <EvilTerran> well, first you gotta have the .hs for it
14:12:08 <sethk> yes, of course, I do
14:12:11 <sethk> that's what I loaded
14:12:31 <EvilTerran> ok. i usually have this problem when trying to do stuff to core modules or whatever, so i often don't ;)
14:12:51 <EvilTerran> you may have to delete the compiled version from wherever ghc put it
14:13:02 <sethk> EvilTerran, you mean the .hi? or the .o?
14:13:09 <EvilTerran> the .o, iirc
14:13:40 <sethk> EvilTerran, thanks, that did it
14:13:45 <EvilTerran> :)
14:14:01 <QplQyer> Botje: hmm, they do something similar in http://sequence.complete.org/node/258 though
14:14:01 <lambdabot> Title: A simple TCP server | The Haskell Sequence
14:14:06 <roconnor> jbapple: here is core-dumping code for you: http://hpaste.org/6642#a2
14:14:19 <EvilTerran> some would say that behaviour;s a slight mis-feature, but there you go
14:14:51 <sethk> EvilTerran, I guess using the compiled code in ghci is good, in general.
14:14:54 <Botje> QplQyer: I annotated your hpaste
14:14:58 <Botje>          bracket ((cHandle,cHost,cPort) <- accept servSock)
14:14:58 <Botje>                     hClose
14:14:58 <Botje>                     (do { putStrLn $ "Connection from host " ++ cHost })
14:14:58 <Botje>          acceptLoop servSock
14:15:00 <EvilTerran> yeah, better performance
14:15:00 <Botje> argh
14:15:05 <Botje> http://hpaste.org/6649#a1
14:15:16 <roconnor> <interactive>: internal error: PAP object entered!
14:15:16 <roconnor>     (GHC version 6.6.1 for i386_unknown_linux)
14:15:28 <EvilTerran> but if it needs to interpret, it aught to be able to look for the source even if there's an object file there
14:15:37 <Botje> and there's supposed to be a -> after \(_, host)
14:15:39 <Botje> sigh :)
14:16:21 <QplQyer> ah i see :)
14:16:22 <QplQyer> thanks!
14:16:25 <Botje> there, refresh
14:16:27 <sethk> how do a run a program with arguments from within ghci?
14:17:18 <jbapple> roconnor: thanks, looking at it
14:17:38 <sethk> is it :main xxx xxx  ...?
14:17:44 <Zao> sethk: There's withArgs.
14:18:08 <Zao> withArgs ["omg", "wtf"] main
14:18:13 <sethk> Zao, thanks
14:18:51 <EvilTerran> :main omg wtf
14:18:54 <EvilTerran> should also work
14:19:19 <sethk> don't need quotes?
14:19:38 <EvilTerran> nope
14:20:30 <Twey> :t withArgs
14:20:32 <lambdabot> Not in scope: `withArgs'
14:20:37 <Twey> Er
14:20:38 <glguy> System.Environment
14:20:51 <MarcWeber> Does anyone know wether Benedikt Schmidt (author of shim) shows up occasionally?
14:21:32 <roconnor> jbapple: the resulting q has type Integer, but it is really a (((Bool -> Bot) -> Bool) -> Bool)
14:21:34 <MarcWeber> @seen beschmi
14:21:34 <lambdabot> I haven't seen beschmi.
14:23:43 <roconnor> jbapple: in paticular q is actually (\_ -> True)
14:25:45 * Baughn notes that something about ParsePkgConf.hs in GHC breaks when compiling with -j5
14:27:20 <Baughn> (I get the same error as http://www.haskell.org/pipermail/glasgow-haskell-users/2008-March/014462.html. I'm on x86_64/linux, though. How odd.)
14:27:21 <lambdabot> Title: ANN: ghc 6.8.2 from MacPorts, http://tinyurl.com/2o2pkm
14:29:23 <QplQyer> hmm in hugs it works now, but I'm having problems with ghc 6.8.2 in gentoo, tells me Network module cannot be found
14:29:36 <QplQyer> worked before with other versions though
14:30:12 <glguy> it is probably a separate package
14:30:26 <glguy> Might want to search portage for a ghc network library
14:32:05 <QplQyer> well, it wanted to downgrade ghc to 6.4 when grabbing that package, but it could be masked, let's see
14:33:13 <roconnor> I don't suppose Dynamic can make a branded type on the fly.  That'd be pretty cool!
14:33:55 <roconnor> @type fromDynmaic
14:33:56 <lambdabot> Not in scope: `fromDynmaic'
14:34:01 <roconnor> @type fromDynamic
14:34:02 <lambdabot> forall a. (Typeable a) => Dynamic -> Maybe a
14:34:43 <sizur> good evening
14:35:06 <sizur> did we break 500 recently?
14:35:57 <roconnor> newBrandedType :: (forall s. (Typeable s) => (a -> s, s -> a) -> IO b) -> IO b
14:36:03 <roconnor> or somthing like that.
14:36:17 <Japsu> @users
14:36:17 <lambdabot> Maximum users seen in #haskell: 472, currently: 455 (96.4%), active: 28 (6.2%)
14:36:37 <roconnor> newBrandedType :: forall a. (Typeable a) => (forall s. (Typeable s) => (a -> s, s -> a) -> IO b) -> IO b
14:36:58 <roconnor> withNewBrandedType :: forall a. (Typeable a) => (forall s. (Typeable s) => (a -> s, s -> a) -> IO b) -> IO b
14:37:19 <Baughn> roconnor: What does that /do/? What type is b?
14:37:34 <roconnor> Baughn: b is anything.
14:37:44 <opqdonut> /b/ is anything
14:37:47 <opqdonut> disregard that
14:38:01 <roconnor> Baughn: it creates a new type isomophic to a, but having a different type from a.
14:38:05 <Baughn> opqdonut: That was random
14:38:15 <sizur> including a and s
14:38:20 <opqdonut> Baughn: ;)
14:38:23 <olsner> indeed, /b/ is random
14:38:53 <Baughn> roconnor: Clearly not intended for proponents of duck typing, I take it
14:39:31 <roconnor> sometimes if it walks like a duck and quacks like a duck, it is just isomorphic to a duck.
14:40:02 <opqdonut> roconnor: :D
14:40:27 <mrd> also know as a ducktor
14:40:53 <sizur> and in rare cases, if it walks like a duck and quacks like a duck, it's a sick fox.
14:41:01 <loop_> ducktor? doctor duck?
14:41:04 <roconnor> Baughn: I don't want to catch some random duck in my duck exception handler just because I happened to accidently make a token that looks like someone else's duck.
14:41:59 <roconnor> Hmm, prehaps I'm being too complicated.
14:42:08 <Twey> sizur: Ahahahaha
14:42:14 <Baughn> roconnor: I see your point. The typing is /static/, though
14:42:33 <Baughn> It seems to me that you can always make a new datatype for your duck
14:43:00 <roconnor> perhaps jbapple just needs to manufacture a unique new object, rather than a unique type.
14:43:32 <roconnor> @hoogle unique
14:43:32 <lambdabot> Data.Unique :: module
14:43:32 <lambdabot> Data.Unique.Unique :: data Unique
14:43:32 <lambdabot> Data.Unique.newUnique :: IO Unique
14:44:02 <roconnor> jbapple: make a newUnique, throw it, catch it and see if it is the same unique.
14:44:18 <roconnor> is Unique an instance of Typeable?
14:45:12 <roconnor> :(
14:45:27 <EvilTerran> ?instances-importing Data.Typeable Unique Typeable
14:45:27 <lambdabot> Couldn't find class `Typeable'. Try @instances-importing
14:45:54 <EvilTerran> ?instances-importing Data.Typeable Typeable
14:45:55 <lambdabot> s a
14:45:58 <EvilTerran> fnord
14:46:03 <roconnor> could it be made an instance of Typeable?
14:46:12 <dolio> Mmm, nothing like a good 'Ask reddit: complain about Haskell for a while.'
14:46:43 <DRMacIver> When I did that almost noone complained. :)
14:46:59 <EvilTerran> roconnor, using standalone deriving declarations, i think so
14:47:07 <gnuvince_> dolio: that's always fun
14:47:22 <dolio> DRMacIver: I seem to recall your article have legitimate points.
14:47:29 <dolio> Not, "type classes are like Java."
14:47:52 <DRMacIver> dolio: I certainly hope it did. :)
14:47:55 <EvilTerran> roconnor, "deriving instance Typeable Unique" with {-# LANGUAGE StandaloneDeriving #-}
14:48:11 <DRMacIver> (The point wasn't really "lets complain about Haskell" but "lets complain about languages we use and like")
14:49:07 <roconnor> EvilTerran: does that work?
14:49:13 <EvilTerran> dunno, but it might
14:49:20 <roconnor> Unique is a primative type I assume.
14:49:24 <roconnor> @src Data.Unique
14:49:24 <lambdabot> Source not found. Take a stress pill and think things over.
14:49:40 <EvilTerran> that shouldn't affect whether you can derive Typeable on it, should it?
14:49:47 <roconnor> either that or it is just an Integer.
14:49:57 <DRMacIver> I think it's just an Integer
14:49:59 <roconnor> EvilTerran: oh, perhaps not.
14:50:10 <roconnor> EvilTerran: can I make my own instance of Typeable?
14:50:24 <dolio> newtype Unique = Unique Integer deriving (Eq, Ord)
14:50:25 <EvilTerran> oleg says "don't, you can break haskell doing that"
14:50:58 <EvilTerran> http://okmij.org/ftp/Haskell/types.html#unsound-typeable
14:51:02 <lambdabot> Title: Haskell Programming: Types
14:51:05 <jbapple> roconnor: newBrandedType f = f (toDyn,fromJust .fromDynamic)
14:51:22 <ac> I just installed GHC on a new system, and when trying to build software with Setup.lhs, it complains about not finding libdl.so. What package is this in?
14:52:13 <roconnor> jbapple: i think throwing a new Unique is the way to go.  Although rumour has it that it isn't thread safe.
14:52:30 <dolio> Data.Unique is a global MVar.
14:52:57 <roconnor> or maybe it is threadsafe.
14:52:58 <EvilTerran> huh. that seems like it'd be relatively easy to fix with a stream, surely?
14:53:21 <jbapple> roconnor: I don't understand how a unique avoids the problem you found earlier
14:54:39 * EvilTerran blinks at Staz's hostname
14:55:35 <qwr> ac: libdl.so is part of libc
14:55:41 <ac> aw crap
14:56:20 <qwr> ac: libc6-dev: /usr/lib/libdl.so
14:56:36 <roconnor> jbapple: if you check to see that you are catching the excepting with the unique signature you built, then you will know it is safe to coerce back.
14:56:40 <ac> huh. I just have /lib/libdl.so.2
14:57:00 <ac> every now and then I find myself having to link /lib/libfoo.so.x to /lib/libfoo.so. Is that bad?
14:57:06 <qwr> ac: lrwxrwxrwx 1 root root 15 25. jaan  03:45 /usr/lib/libdl.so -> /lib/libdl.so.2
14:57:14 <jbapple> oh. hm.
14:57:16 <EvilTerran> ... ah, this is catching exceptions? surely you need a unique type rather than value for that?
14:57:31 <roconnor> jbapple: exception throwing code still leaks out, but it isn't dangerous I don't think.
14:58:20 <EvilTerran> data Zero deriving Typeable; data Succ a deriving Typeable; type Uniq0 = Zero; type Uniq1 = Succ Uniq0; type Uniq2 = Succ Uniq1; ...
14:58:28 <roconnor> unless Dyanmic can be used to coerce beween two different but identical data structures.
14:58:38 <EvilTerran> don't export Zero or Succ, then no-one else can have the same types!
14:58:54 <DRMacIver> Hm. "cabal list" seems to be barfing midway through for me with the error message cabal: Couldn't read cabal file "./HFuse/0.1/HFuse.cabal"
14:59:07 <Baughn> roconnor: unsafeCoerce does exist. I'm not sure how /smart/ it would be, but it should theoretically work
14:59:29 <roconnor> Baughn: yeah, but without unsafeCoerce.
14:59:36 <Japsu> remember, ceiling cat is watching you unsafeCoerce!
14:59:50 <roconnor> Baughn: I don't know if Dyanmic distinguishes between isomorphic types.
14:59:51 <dolio> Oh, I see how Oleg's example works.
15:00:10 * EvilTerran would expect that to be "segfault cat is watching you unsafeCoerce"
15:00:23 <EvilTerran> roconnor, it uses Typeable to distinguish types, iirc, so it should
15:00:48 <roconnor> I don't know if Typeable distinguishes between isomorphic types.
15:01:15 <roconnor> ``(representation) equivalence''
15:01:20 <lispy> andyjgill: do I need to worry about saving the .hpc directory?  It sounds like I just need to save the .tix files from your email description.
15:01:22 <roconnor> :/
15:01:26 <roconnor> that doesn't sound good.
15:01:27 <EvilTerran> given "newtype Foo = Foo () deriving Typeable", typeOf (Foo ()) /= typeOf (), if that;s what you mean
15:01:55 <glguy> can the current associated types implementation support: class C a b c | a b -> c, a c -> b   ?
15:02:03 <roconnor> EvilTerran: how about data Foo = Foo in one module, and data Foo = Foo in another module?
15:02:15 <EvilTerran> roconnor, i'm pretty sure it distinguishes
15:02:47 <dcoutts_> DRMacIver: hmm, I get that too
15:03:53 <roconnor> if it does, then the exceptions leaking from jbapple's code (tagged with unique identifies) should be safe, because there would be no way for the user to catch the exception.
15:04:25 <EvilTerran> i guess so
15:04:37 <DRMacIver> dcoutts_: Any chance there's an easy fix? :)
15:04:56 * EvilTerran considers that "data Uniq0 deriving Typeable; data Uniq1 deriving Typeable; ..." would work just as well, if not better, than his last suggestion
15:05:24 <roconnor> @type cast
15:05:25 <lambdabot> forall a b. (Typeable b, Typeable a) => a -> Maybe b
15:05:27 <dcoutts_> DRMacIver: not sure yet, want to look into it?
15:05:49 <DRMacIver> I don't think I'd have a clue where to start. :)
15:05:51 <ac> are there Haskell bindings for the new xlib? What's it called, xcb?
15:10:10 <sethk> the debugger is nice, once you get accustomed to it.
15:10:22 <DRMacIver> Hm
15:10:43 <DRMacIver> Has the .cabal file format has changed recently? HFuse appears to have an invalid .cabal file.
15:11:01 <DRMacIver> For some reason it doesn't like the line "if arch(x86_64)"
15:11:09 <ddarius> It changed between < 1.2 and >= 1.2 seemingly.
15:11:11 <dcoutts_> DRMacIver: I must have broken the parser in some way
15:11:20 <dcoutts_> DRMacIver: what Cabal lib version are you using?
15:11:24 <DRMacIver> darcs
15:11:33 <dcoutts_> yes, what version number
15:11:42 <dcoutts_> cabal --version will tell you both
15:11:53 <DRMacIver> 1.3.8
15:12:07 <dcoutts_> ta
15:12:32 <dolio> glguy: You're probably safer sticking with fundeps. It's hard to tell, based on mailing list traffic, how far along equality constraints are in 6.8.
15:13:06 <glguy> :) I don't have any intention of actually using them at this point
15:13:22 <glguy> but it sounds like equality constraints are how you'd express those
15:13:25 <glguy> then
15:13:30 <dolio> Plus, the type family implementation of those fundeps is significantly more verbose.
15:14:31 <dolio> Yeah, 'class (F1 a b ~ c, F2 a c ~ b) => C a b c where F1 a b :: * ; F2 a c :: * ; ...' I think.
15:14:37 <dolio> Something like that, at least.
15:15:46 <dolio> I don't think they're taking out fundeps (yet, at least), so it's probably better to let the compiler translate to that for you.
15:16:09 <glguy> Hopefully it doesn't come to them removing fundeps
15:16:24 <ddarius> They'd like to.
15:16:32 <glguy> :-/
15:16:34 <EvilTerran> i think we've got too used to 'em for them to be removed at this point
15:17:01 <ddarius> glguy: As EvilTerran suggests, whether they'd like to or not, they aren't going anywhere for a while at least.
15:17:31 <EvilTerran> maybe we'll eventually decide that we like the final implementation of type families so much that we'll let them deprecate fundeps
15:17:35 <Lemmih> Happy-1.17 doesn't build with the latest Cabal?
15:17:50 * dcoutts_ stabs Takusen in the Setup.hs file
15:18:03 <glguy> nooo
15:18:08 <dcoutts_> Lemmih: is that a bug report?
15:18:09 <glguy> leave takusen alone!
15:18:15 <glguy> it didn't hurt anyone
15:18:21 <dcoutts_> It did!
15:18:24 <dcoutts_> it does!
15:18:28 <dcoutts_> it pains me
15:18:31 <dcoutts_> greatly
15:18:37 <glguy> just don't look inside
15:18:42 <dcoutts_> it's got the worst Setup.hs in all the world
15:18:51 <dcoutts_> I cannot make Cabal-1.4 compatible with it
15:18:56 <ddarius> At least it is in Haskell and not Python...
15:19:07 <Lemmih> dcoutts_:  http://hackage.haskell.org/packages/archive/happy/1.17/logs/failure/ghc-6.8
15:19:09 <lambdabot> http://tinyurl.com/3b6mto
15:19:22 <Lemmih> I guess it's a known issue.
15:19:40 <dcoutts_> Lemmih: oh, that's ok, I'm fixing that
15:20:06 <dcoutts_> I can make Cabal-1.4 compatible with all the existing Setup.hs scripts in hackage, even lhs2tex, but not Takusen
15:20:07 <yav> oh cabal violence! :-)
15:20:38 <dcoutts_> it copies goups and goups of internal code out of Cabal-1.2 and bungs it into its Setup.hs script
15:20:42 <yav> hey dcoutts_ is there a way to instruct cabal to build only one of the executables specified in a cabal file?
15:21:07 <dcoutts_> yav: you can set any of them to not be buildable by default
15:21:08 <ddarius> dcoutts_: So don't have cabal-1.4 be compatible with it...
15:21:24 <dcoutts_> ddarius: I'm not going to, I'm sending them a patch to make it work with both
15:21:29 <dcoutts_> for some future release
15:21:53 <dcoutts_> but I am otherwise trying to make Cabal-1.4 compatible with 1.2 and all the existing packages
15:22:35 <yav> dcoutts_: you mean i have to modify the cabal file?  i was thinking along the lines of the targets in make, where I specify it on the command line
15:22:49 <dcoutts_> yav: no, not yet
15:23:04 <dcoutts_> it's the downside of putting multiple exes in a package
15:23:05 <yav> ok
15:23:15 <dcoutts_> the package is the unit of distribution
15:23:44 <yav> my use case is a test suite, with lots of little programs
15:26:00 <Lemmih> @seen nibro
15:26:00 <lambdabot> I saw nibro leaving #haskell 2h 2m ago, and .
15:26:40 <dcoutts_> yav: at some point we'll have a different system for tests
15:28:16 <yav> yeah, prolly a good idea.  for the same use case it is usefule to share optons between executables in a cabal file
15:32:07 <ac> so does the Haskell x11 package use libx11 or libxcb?
15:32:59 <allbery_b> libx11 currently
15:33:26 <jbapple> roconnor: DynamicAbort.hs:13:0:
15:33:26 <jbapple>     The data constructors of `Unique' are not all in scope
15:33:26 <jbapple>       so you cannot derive an instance for it
15:33:26 <jbapple>     In the stand-alone deriving instance for `Typeable Unique'
15:33:26 <jbapple> Failed, modules loaded: none.
15:33:51 <yitz> ok, what's the trick to get cabal-install to build the haddocks? cabal haddock --help is not very helpful.
15:33:54 <roconnor> jbapple: bug report. :)
15:34:08 <jbapple> roconnor: is that a bug?
15:34:20 <roconnor> jbapple: well, feature request.
15:34:43 <jbapple> roconnor: I'm not sure that it's not for good reason. I'll have to think about that
15:35:06 <roconnor> jbapple: dolio says that Unique is just a wrapper around Integer.
15:36:07 <roconnor> jbapple: other than crazy module dependencies, I think there is no reason that Unique shouldn't be Typeable.
15:36:39 <ac> allbery_b: I heard that the xcb API is actually defined in XML and the entire library is generated (and it's fairly easy to generate bindings in other languages using this)
15:36:53 <dolio> They're both in base, so I doubt it'll be a problem.
15:39:14 <roconnor> jbapple: another question is, are you okay with abortAny leaking exceptions, even if they are safe?
15:39:36 <jbapple> That's a good question
15:40:16 <roconnor> jbapple: It's a bit unclear what your ultimate goal is, other than exploring functional interpetations of classical logic.
15:40:23 <byorgey> ac: I think sjanssen was working on xcb bindings, once upon a time, but didn't have time to continue
15:40:38 <byorgey> ac: but it's possible someone may do it as a google Summer of Code project
15:42:01 <ac> byorgey: cool. I actually don't know much about xcb, and how many applications actually use it, but I've heard it's a vastly better API than xlib :-P
15:42:23 <jbapple> roconnor: That's roughly the goal. I was thinking of trying to understand things like ((a->b)->Either a c)->(Either ((a->b)->a) ((a->b)->c)) that are admissible but not provable
15:42:47 <byorgey> ac: yes, I've heard the same.  sounds like it would be really nice to be able to port xmonad to use xcb instead of X11.
15:43:52 <gwern> I've heard xcb actually has a formal specification
15:43:54 <allbery_b> ac: it's actually preferable to bind to the C interface, I think, because it lets you use it with other C-interfacing libraries that use X11 (gtk2hs, HOpenGL) (at least once they're ported to xcb)
15:44:03 <roconnor> jbapple: :) Okay I hope i've illustrated you can do strange things with functions.
15:44:09 <ac> I get the impression that using xlib directly is almost never worth it. I wonder if Haskell bindings to xcb would actually be usable enough to write regular apps with it
15:44:13 <gwern> byorgey: no doubt, although given that sjanssen failed, I wonder how easy a binding is
15:44:31 <dcoutts_> ac: much more so than xlib I think, yes.
15:44:44 <dcoutts_> the xcb api is more orthogonal
15:44:51 <allbery_b> unlikely; xlib and xcb would both be low level, things like gtk2hs are more suited to application development
15:45:01 <byorgey> gwern: sjanssen failed, or sjanssen didn't have time to finish?
15:45:02 <ac> I heard it has PostScript-like 2D primitives similar to OpenGL's 3D primitives
15:45:09 <dcoutts_> ac: cairo, yes.
15:45:15 <dcoutts_> it's pretty cool
15:45:23 <roconnor> jbapple: http://r6.ca/blog/20040616T005300Z.html
15:45:24 <lambdabot> Title: Excluded Middle Almost Reasonable.
15:45:33 <gwern> byorgey: who knows. ask'im. the end result is no hcb tho
15:46:18 <jbapple> roconnor: YOu have. I also want to understand how the Cont monad acts when r is _|_
15:46:30 <byorgey> gwern: yes, but it makes a big difference to someone else who might want to try...
15:47:25 <jbapple> roconnor: How do you generate those strange links on your page?
15:50:04 <monochrom> Ha, fun, there is such a protocol as "data" :)
15:51:35 <ac> dcoutts_: cool indeed. I've always been annoyed at having to choose OpenGL vs Cairo, but with xcb you'll get both I believe
15:52:39 <dcoutts_> ac: you've always been able to use both as far as I know
15:52:50 <ac> dcoutts_: how so?
15:53:07 <ac> I guess you can use gtk's OpenGL bindings
15:53:13 <dcoutts_> ac: yes
15:53:42 <dcoutts_> it gives you as many GL drawing areas as you like which you can mix in with the rest of your UI
15:53:57 <Peaker> is Cairo like SDL.Video ?
15:54:26 <ac> Peaker: Cairo is a graphics library that has similar primitives as PDF or SVG
15:54:43 <Peaker> ac, Can it be used with SDL?
15:54:54 <ac> Peaker: I assume so
15:55:26 <dcoutts_> Peaker: it can draw to raw in-memory bitmaps so you can probably make it work with SDL
15:55:54 <Peaker> does it use a pixel-based, or metric-based coordinate system?
15:56:25 <dcoutts_> metric, it supports affine transforms
15:56:47 <Peaker> cool - does it know your monitor size in order to convert metrics to pixels?
15:59:11 <roconnor> @google data URI kitchen
15:59:13 <lambdabot> http://software.hixie.ch/utilities/cgi/data/data
15:59:13 <lambdabot> Title: The data: URI kitchen
15:59:23 <roconnor> jbapple: ^^
16:00:09 <dcoutts_> Peaker: the initial transform matrix is related to the pixels, so you'd have to scale it yourself (but that's trivial)
16:00:35 <Peaker> dcoutts_, sounds like OpenGL
16:00:49 <dcoutts_> yeah, but 2D and much simpler api
16:01:15 <dcoutts_> and with multiple backends
16:01:36 <dcoutts_> and nice anti-aliased output by default
16:02:05 <Peaker> I see
16:02:31 <dons> vote for xmonad, http://www.linuxjournal.com/content/kde-or-gnome-or :)
16:02:32 <lambdabot> Title: KDE or GNOME or? | Linux Journal
16:02:33 <Vq^> cairo from haskell is really neat
16:02:53 * dons is surprised, pleasantly, that they included xmonad
16:03:05 <Peaker> When using Cairo, what do you typically use for event input, etc?
16:03:21 <ac> speaking of xmonad, where's the NoBorders layout module?
16:03:34 <dons> in XMonad.Layout.NoBorders
16:03:40 <dcoutts_> Peaker: if you're using it with gtk then you use gtk, cairo is output-only
16:04:16 <elliottt> dons: you've almost beaten enlightenment! :)
16:04:20 <ac> dons: yeah, it looks like the installer didn't include contrib
16:04:21 <dons> hehe.
16:04:39 <dons> enlightenment was written by a guy at UNSW a couple of years before I was there.
16:04:54 <elliottt> raster?
16:04:56 <dons> yeah
16:05:03 <dons> apparently he wore lots of silly hats
16:05:04 <elliottt> i used to follow that project closely
16:05:09 <elliottt> hehe
16:05:10 <roconnor> monochrom: data URIs can be a great way of defeating the security system of a browser, because the URL vaguely looks like it is coming from localhost.
16:05:11 <Peaker> dcoutts_, I hate existing application toolkits :-(  I think they make horrible UI's
16:05:21 <Peaker> dcoutts_, that cannot be properly controlled with a keyboard
16:05:27 <elliottt> after 4 years of waiting for 0.17, i gave up :)
16:05:47 <ac> Peaker: let's write a new one
16:06:01 <dcoutts_> Peaker: gtk can give you all keyboard input, just make a window and respond to the key press events
16:06:13 <Twey> elliottt: It's pretty awesome though.
16:06:26 <dcoutts_> Peaker: it's not complicated, you don't have to make lots of widgets etc
16:06:30 <elliottt> Twey: yeah, it is
16:06:46 <elliottt> Twey: i used to build it somewhat frequently from cvs, but it just got to be a chore :(
16:07:01 <ac> Peaker: have you seen "The Lively Kernel" Google TechTalk?
16:07:04 <Peaker> ac: I want a new one that is quite different from existing ones
16:07:10 <Peaker> ac: Nope
16:07:12 <Peaker> ac: What's it about?
16:07:20 <Twey> elliottt: The Gentoo ebuild does that for me :-)
16:07:25 <elliottt> ah, hehe
16:07:30 <ac> Peaker: a Smalltalk style UI written in JavaScript and SVG
16:07:32 <elliottt> i wonder what they've got going for arch...
16:07:43 <dcoutts_> dons: come on, I'm sure you can rustle up a bit more ballot stuffing than that!
16:07:53 <dcoutts_> only 10 votes for xmonad so far
16:07:58 <dcoutts_> #haskell!! come on
16:08:06 <Peaker> ac: Smalltalk style, e.g Squeak?  I don't recall Squeak being particularly good at keyboard control
16:08:19 <elliottt> Twey: oh wow, they've got e-cvs in arch.  maybe it's time to give it a try again
16:08:38 <ac> Peaker: and this probably isn't either, but that doesn't mean it couldn't be. I thought it was somewhat interesting
16:08:43 <ac> Peaker: I haven't actually fooled with the software myself yet
16:08:53 <Igloo> dcoutts_: Votes?
16:08:59 <dcoutts_> http://www.linuxjournal.com/content/kde-or-gnome-or
16:08:59 <lambdabot> Title: KDE or GNOME or? | Linux Journal
16:09:12 <Peaker> The way the mouse is used in current UI's is a mistake - and a new GUI needs to fix that. Also, a GUI should be virtually completely auto-generated from the type information of the functions you want to expose, and configurable by the user
16:10:42 <Peaker> With Gtk+, for example, if you have a lazy data structure such as a tree, you have to expose a super-horrible tree-walking interface for it to be able to display it in a Gtk.TreeView, and even then, its not allowed to be very big
16:10:43 <yitz> Peaker: you can pick up the mouse and use it to click keys on the keyboard
16:10:51 <Peaker> yitz, :-)
16:11:13 <ac> Peaker: ah ok, that's absolutely nothing like Squeak, but interesting
16:11:47 <ac> Peaker: also largely unrealistic in my opinion because it takes a skilled UI designer to make a good interface
16:12:17 <ac> perhaps the code could be autogenerated, but not the GUI layout and behavior
16:12:27 <Peaker> ac: I think the practice should be mechanized into an automatic algorithm, perhaps with some hints
16:12:36 <yitz> Peaker: yes, all major UIs still feel like MFC. About time to move on.
16:13:36 <ddarius> dons: How is xmonad in that list but not dwm or wmii or ion?
16:13:40 <dcoutts_> DRMacIver: found the bug
16:14:03 <dcoutts_> ddarius: dons probably slipped them a fiver ;-)
16:14:43 <DRMacIver> dcoutts_: Shiny. Anything exciting? :)
16:15:17 <dcoutts_> DRMacIver: Parse.munch1 Char.isAlphaNum
16:15:23 <dcoutts_> what's wrong with that
16:15:28 <Peaker> yitz, I especially hate the repeated "tab,tab,tab,tab" cycle, when there are ~100 more keys on the keyboard
16:15:43 <Miko77> Hi, im at learning functional programming and want to buy a book about haskell. what can you recommend me? im not an english native speaker so simple english would be nice in the book perhaps even german.
16:15:45 <dcoutts_> DRMacIver: the line that failed to parse was "        if arch(x86_64)\n"
16:15:56 <DRMacIver> Oh, doesn't match underscores?
16:15:58 <dcoutts_> > Data.Char.isAlphaNum '_'
16:16:00 <lambdabot>  False
16:16:03 <dcoutts_> DRMacIver: wins!
16:16:37 <dons> ddarius: i don't know. cool, isn't it? :)
16:16:50 <dons> ddarius: brand awareness :)
16:16:50 <ddarius> xmonad is doing reasonably well so faup
16:17:06 <newsham> > Data.Char.isUpper ':'
16:17:07 <lambdabot>  False
16:17:19 <newsham> lies!
16:17:21 <DRMacIver> dcoutts_: Would it be worth making cabal a bit more robust to the presence of bad files?
16:17:43 <Twey> newsham: Not a lie
16:17:44 <dcoutts_> DRMacIver: that's what I've been trying to do for the last couple weeks
16:17:44 <yitz> Peaker: Your comment about TreeView resonates with me. I'm trying to do something slightly non-trivial with them just now. It makes Haskell feel like MFC. Yuck.
16:17:46 <Twey> It's not upper-case
16:17:51 <DRMacIver> dcoutts_: Ah, fair enough. :)
16:18:06 <DRMacIver> dcoutts_: Anyway, thanks.
16:18:09 <newsham> twey: colon is upper case punctuation I say
16:18:09 <dcoutts_> DRMacIver: it's tricky because we do not want to accept new parses
16:18:14 <Twey> > isLower ':'
16:18:15 <lambdabot>  False
16:18:22 <Twey> Punctuation is neither
16:18:29 <yitz> (dcoutts_: not your fault of course, your port is fantastic)
16:18:37 <dcoutts_> DRMacIver: because then people will use them and older cabal will fall over with unhelpful error messages
16:18:57 <dcoutts_> yitz: TreeView is pretty complicated, we could improve the binding further
16:19:09 <DRMacIver> dcoutts_: I was thinking more in terms of ignoring the file, printing an error message and moving on rather than the current behaviour where it seems to die as soon as it reaches a file it doesn't understand
16:19:20 <newsham> Twey: type constructors start with upper case characters, infix operators are punctuation, :+ is an infix type constructure. qed.
16:19:26 <newsham> (ditto for ":")
16:19:45 <Peaker> yitz, I created a Python tracer that shows a Python program execution as a tree of function invocations in a treeview - so I had created a lazy-loading tree from a file for this, had worked 5 hours on the tracer, file format, and all, and another 6 hours on having Gtk+ use it
16:19:45 <dcoutts_> DRMacIver: in theory hackage will not allow uploading any files with parse errors, so as long as we have no regressions it's ok
16:19:49 <Twey> Haha
16:19:59 <Twey> newsham: Tell it to the Unicode committee :-)
16:20:10 <newsham> do they know haskell yet?
16:20:11 <DRMacIver> dcoutts_: In theory, theory and practice are the same, etc. :)
16:20:13 <Peaker> yitz, And then when trying to add a filter on the tree - I discovered that a filter in Gtk+ must be O(entire_tree) rather than O(visible_tree) so its not possible
16:20:19 <dcoutts_> DRMacIver: and we're currently not parsing most files in the index on purpose, because doing so is slow, so we cannot easily skip the ones that do not parse
16:20:35 <DRMacIver> dcoutts_: Ah
16:20:50 <ac> How do I compile ~/.xmonad/xmonad.hs in the context of ~down/software/xmonad/ so it actually finds all the imports? (this is really a GHC question, not an xmonad question)
16:21:11 <dcoutts_> DRMacIver: part of the testing procedure for Cabal-1.4 (that I'm doing at the moment) is checking that all the .cabal files parse with the new Cabal lib and that all the Setup.hs scripts compile. So I'd have caught that bug at some point anyway.
16:21:14 <Twey> newsham: I suspect so.
16:21:33 <dcoutts_> DRMacIver: I was checking Setup.hs scripts first :-)
16:21:40 <DRMacIver> dcoutts_: Fair enough. :)
16:21:56 <yitz> dcoutts_: it would be nice to have more pure plumbing for that kind of stuff, redesigned for Haskell, and then have a simple IO function that gives it backing in the wm.
16:22:03 <dcoutts_> and I've modified Cabal to make them all work, all except Takusen
16:22:11 <yitz> Peaker: ugh
16:23:25 <dcoutts_> yitz: the hard part of the TreeView is making a mutable store, it's easy to take an immutable Haskell structure and make it the model for a treeview, but mutations are much harder
16:23:43 <Peaker> yitz, I think that all GUI's I have ever wanted could have been auto-deduced from the type of the information that I wanted accessible..
16:23:51 <koninkje> @pl \x y-> a (b x y)
16:23:51 <lambdabot> (a .) . b
16:23:55 <dcoutts_> Peaker: I don't think so
16:23:57 <Peaker> yitz, I am not even sure it needed hints
16:24:11 <yitz> hmm: don't know how many votes, but *no* comments in favor of xmonad. come on, can't we be chattier than that?
16:24:18 <dcoutts_> not in my experience, there is more variation in presentation
16:24:24 <Peaker> dcoutts_, what needs to variate?
16:24:51 <dcoutts_> Peaker: displaying various kinds of data as graphs
16:25:10 <dcoutts_> that's node/edge graphs, not charts
16:26:03 <Peaker> dcoutts_, what is the type of the graph, a couple of lists?
16:26:24 <yitz> dcoutts_: for my current app, the tree is complex, but does need to be mutated once built. it really hurts to have to jump through all those imperative hoops.
16:26:37 <yitz> does *not* need
16:28:34 <dcoutts_> yitz: you're using the new tree view api right?
16:29:07 <yitz> mm... i think so.
16:29:14 <Peaker> dcoutts_, how do you want to display the graph?  A graph is too general a type to know how you'd want to display it
16:29:26 <dcoutts_> Peaker: exactly
16:29:33 <Peaker> dcoutts_, A typed-GUI would need a more specific type than that
16:30:11 <Peaker> dcoutts_, the programmer should be specifying the types, not they physical layout and such.. the physical layout should be editable in runtime anyhow
16:30:14 <dcoutts_> yitz: eg see gtk2hs/demo/treeList/DirList.hs it's not doing much to set up the model
16:30:39 <dcoutts_> Peaker: oh sure, I much prefer using glade, you can see what you're doing
16:30:48 <dcoutts_> but that's separate from the type
16:31:05 <Peaker> dcoutts_, "glade" should be accessible to the user that's using ti
16:31:09 <Peaker> dcoutts_, while he's using it
16:31:23 <dcoutts_> that's not impossible, though it's not the standard setup
16:31:37 <Miko77> Hi, im at learning functional programming and want to buy a book about haskell. what can you recommend me? im not an english native speaker so simple english would be nice in the book perhaps even german.
16:32:16 <dcoutts_> Miko77: there is a list of books on the haskell.org website under the learnng links
16:32:28 <dcoutts_> Miko77: you could check there if there's a German language one
16:32:32 <roconnor> hmm, not many people in #haskell.de
16:32:52 <dcoutts_> Miko77: if you have to pick an English one, I recommend "Programming in Haskell"
16:32:52 <Miko77> dcoutts_, i checked it yet, but a lot of books seemed to be bad
16:33:21 <Miko77> dcoutts_, its a bit short, i prefer it too to wait till third edition of the craft of functional programming or real world haskell
16:33:27 <ac> grr. I installed XMonadContrib separately, but it's not appearing in /usr/local/lib
16:33:49 <dcoutts_> Miko77: if you're just learning it's great
16:34:28 <dcoutts_> it's also a bit cheaper than the bigger textbooks
16:34:38 <Miko77> i want to understand it. thats why i wanted to buy Haskell: the craft of functional programming, but its just avaliable in uk an costs above 70 Euro because of shipping
16:34:49 <Miko77> and its from 1999. not up to date
16:35:06 <dcoutts_> Miko77: the Real World book will not cover introductory stuff, but there are several that do
16:35:27 <Miko77> dcoutts_, not? i read the examples and it seemed its for beginners
16:35:28 <glguy> Anything from 1998 on will be able to teach you Haskell98
16:35:48 <glguy> dcoutts_: Real World Haskell seems to cover beginning stuff
16:35:54 <glguy> dcoutts_: from the look of the sample chapters
16:36:17 <dcoutts_> not like "Programming in Haskell", it's a different scale of "introductory" I think
16:36:23 <Miko77> but Real World haskell will not explain so much about functional programming like the craft of f. p. i think
16:36:50 <Miko77> Theres no date when real world haskell will be avaliable
16:37:04 <yitz> dcoutts_: yeah, but I'm gathering richly structured info from a bunch of xml files and rendering it in a left pane tree and right pane tree. (left and right pain i should say). it's very doable, but just doesn't feel right in imperative style.
16:37:39 <dcoutts_> yitz: so you mean the setup of the view is too imperative
16:38:30 * glguy writes papers functionally, no backspace
16:38:52 <dcoutts_> (store :: ListStore a) <- listStoreNew (listOfStuff :: [a])
16:39:02 <dons> glguy: you just need to stall all revisions
16:39:22 <glguy> stall?
16:39:38 <yitz> yeah, just my taste i guess. it seems similar to what i would do in c. i would rather have a nice haxml filter that does it all, or something like that.
16:40:14 <dons> store. weird.
16:47:16 <skorpan> dons: i don't know how much you're developing hmp3 right now, but is it relatively easy to add support for submitting to last.fm?
16:49:16 <conal> does liftM == fmap (i.e., fmap h m == m >>= return . h) follow from the monad laws?
16:49:42 <ddarius> conal: Including the functor laws, yes.
16:49:44 <monochrom> Yes.
16:50:04 <ddarius> Er, ignore the first part of my response.
16:50:18 <conal> how does it follow?
16:50:37 <yitz> conal: there's a proof in the wikibook
16:50:42 <ddarius> @free return
16:50:44 <lambdabot> Expected variable or '.'
16:52:27 <conal> yitz: do you remember where in the wikibook?
16:53:38 <yitz> http://en.wikibooks.org/wiki/Haskell/Category_theory
16:54:25 <ddarius> m >>= f = join (fmap f m); m >>= return . f = join (fmap (return . f) m); (>>= return . f) = join . fmap (return . f) = join . fmap return . fmap f = fmap f
16:54:26 <yitz> dcoutts_ wrote it, iirc
16:54:38 <dcoutts_> hmm?
16:55:18 <dcoutts_> yitz: ?
16:55:41 <yitz> wasn't you?
16:55:52 <ddarius> So it follows from the definition of (>>=) in terms of join and fmap and preservation of (.) by fmap and the right unit law of join.
16:56:36 <yitz> oh, it was dhouse. sorry.
16:56:48 <conal> thanks very much for the help!
17:05:13 <ahunter> @djinn a -> b- > b
17:05:16 <lambdabot> Cannot parse command
17:05:41 <ddarius> @. pl djinn a -> b -> b
17:05:43 <lambdabot> f = const id
17:05:56 <EvilTerran> or flip const, or curry snd
17:06:06 <ahunter> thought flip const would work, just wanted to check
17:06:33 <Twey> :t const
17:06:37 <lambdabot> forall a b. a -> b -> a
17:06:42 <Twey> :-\
17:06:45 <Twey> @src const
17:06:45 <lambdabot> const x _ = x
17:06:51 <lament> :t flip const
17:06:52 <lambdabot> forall a b. b -> a -> a
17:06:53 <Twey> What's this for?
17:07:00 <mauke> creating constant functions
17:07:15 <Twey> Aren't all functions constant?
17:07:18 <lament> @djinn b -> a -> a
17:07:18 <lambdabot> f _ a = a
17:07:27 <Cale> > map (const 5) [1,2,3,4,5]
17:07:28 <lambdabot>  [5,5,5,5,5]
17:07:34 <lament> has anybody tried proving complicated theorems with djinn?
17:07:44 <Cale> > filterM (const [False,True]) [1,2,3]
17:07:45 <lambdabot>  [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
17:07:49 <mauke> Twey: no, they usually return different things for different inputs
17:07:53 <Twey> Oh, I see
17:08:39 <mauke> :t return False ++ return True
17:08:41 <lambdabot> forall (m :: * -> *). (Monoid (m Bool), Monad m) => m Bool
17:08:55 <ddarius> @djinn ((x -> a) -> f a) -> f x
17:08:55 <lambdabot> -- f cannot be realized.
17:09:02 <ari> What the
17:09:02 <ddarius> @djinn Functor f => ((x -> a) -> f a) -> f x
17:09:02 <lambdabot> Cannot parse command
17:09:05 <ari> :t (++)
17:09:08 <lambdabot> forall m. (Monoid m) => m -> m -> m
17:09:16 <Cale> hehe, I generalised (++) :)
17:09:19 <EvilTerran> ari, it doesn't do typeclasses
17:09:31 <Cale> So you can use (++) for non-list things now
17:09:34 <ari> Cale: I was wondering how that'd happened :)
17:09:36 <Cale> (in lambdabot :)
17:09:39 <mauke> :t join (.) return False ++ join (.) return True
17:09:40 <lambdabot>     Occurs check: cannot construct the infinite type: a = m a
17:09:40 <lambdabot>       Expected type: a -> a
17:09:40 <lambdabot>       Inferred type: a -> m a
17:09:43 <ddarius> :t (++)
17:09:45 <lambdabot> forall m. (Monoid m) => m -> m -> m
17:09:45 <mauke> :(
17:09:53 <Cale> One of my favourite things to concatenate are orderings
17:10:02 <mauke> :t return (return False) ++ return (return True)
17:10:04 <lambdabot> forall (m :: * -> *) (m1 :: * -> *). (Monoid (m1 (m Bool)), Monad m1, Monad m) => m1 (m Bool)
17:10:05 <lament> @djinn (a -> b) -> (b -> a)
17:10:05 <lambdabot> -- f cannot be realized.
17:10:25 <dons> xmonad's not winning by enough yet, http://www.linuxjournal.com/content/kde-or-gnome-or
17:10:26 <lambdabot> Title: KDE or GNOME or? | Linux Journal
17:10:28 <ari> Cale++
17:10:31 <Cale> > sortBy (comparing length ++ compare) (words "this is a test of concatenating orderings")
17:10:34 <lambdabot>  ["a","is","of","test","this","orderings","concatenating"]
17:10:39 <mauke> :t filterM (return (return False) ++ return (return True))
17:10:40 <lambdabot> forall (m :: * -> *) a. (Monoid (m Bool), Monad m) => [a] -> m [a]
17:10:44 <ddarius> We need xmonad to beat GNOME!
17:10:51 <yitz> EvilTerran: or seq. he, he.
17:10:54 <mauke> > filterM (return (return False) ++ return (return True)) [1,2,3]
17:10:54 <lambdabot>   add an instance declaration for (Monoid (m Bool))
17:11:02 <mauke> > filterM (return (return False) ++ return (return True)) [1,2,3] :: [[Int]]
17:11:04 <lambdabot>  [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
17:11:11 <mauke> yes!
17:11:25 <mauke> I have mastered thee, Monoid!
17:11:56 <dolio> @djinn (a -> b) -> (Not b -> Not a)
17:11:56 <lambdabot> f a b c = b (a c)
17:12:06 <EvilTerran> yitz, sure, if you're willing to live with the consequences...
17:12:17 <lament> dolio: hee
17:12:17 <EvilTerran> ?src Not
17:12:17 <lambdabot> Source not found. My pet ferret can type better than you!
17:12:20 <ertai> :t comparing
17:12:21 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
17:12:35 <dolio> type Not a = a -> Void
17:12:49 <EvilTerran> ?djinn-env
17:12:49 <lambdabot> data () = ()
17:12:49 <lambdabot> data Either a b = Left a | Right b
17:12:49 <lambdabot> data Maybe a = Nothing | Just a
17:12:49 <lambdabot> data Bool = False | True
17:12:49 <lambdabot> data Void
17:12:51 <lambdabot> type Not x = x -> Void
17:12:53 <lambdabot> class Eq a where (==) :: a -> a -> Bool
17:12:56 <Cale> > sortBy (comparing (uncurry (+)) ++ comparing fst) [(x,y) | x <- [1..3], y <- [1..3]]
17:12:59 <dons> ddarius: sounds godo to me :)
17:12:59 <lament> @djinn a -> (Not (Not a))
17:12:59 <lambdabot>  [(1,1),(1,2),(2,1),(1,3),(2,2),(3,1),(2,3),(3,2),(3,3)]
17:12:59 <lambdabot> f a b = b a
17:13:30 <dolio> @djinn Not (((a -> b) -> a) -> a)
17:13:30 <lambdabot> -- f cannot be realized.
17:13:31 <ddarius> dons: If xmonad could beat gnome, then it wouldn't need to.
17:13:53 <mauke> > sortBy (comparing (uncurry (+)) ++ compare) [(x,y) | x <- [1..3], y <- [1..3]]
17:13:53 <lambdabot>  [(1,1),(1,2),(2,1),(1,3),(2,2),(3,1),(2,3),(3,2),(3,3)]
17:14:11 <Cale> @djinn (((Not (Not a) -> Not (Not b)) -> Not (Not a)) -> Not (Not a))
17:14:12 <lambdabot> f a b = void (a (\ c _ -> void (c b)) b)
17:14:29 <lament> i'm not sure this definition of Not is entirely legit
17:14:35 <ddarius> lament: djinn does a good job on continuation passing code.
17:14:37 <dolio> @djinn Not (Not (((a -> b) -> a) -> a))
17:14:37 <lambdabot> f a =
17:14:37 <lambdabot>     void (a (\ b -> void (a (\ _ -> b (\ c -> void (a (\ _ -> c)))))))
17:14:55 <EvilTerran> good lord
17:15:01 <EvilTerran> ?djinn-names
17:15:02 <lambdabot> Either Left Right Maybe Nothing Just Bool False True Void Not Void Eq Bool
17:15:08 <Cale> lament: How so?
17:15:09 <EvilTerran> hm.
17:15:16 <lament> ah, nm
17:15:34 <Cale> lament: (remember that this is intuitionist logic, which is very unintuitive ;)
17:15:50 <ddarius> Cale: What's unintuitive about it?
17:16:13 <Cale> ddarius: Well, that double negation isn't the same as the identity, for instance :)
17:16:25 <lament> @djinn ((a -> b) -> a) -> a
17:16:26 <lambdabot> -- f cannot be realized.
17:16:35 <lament> what does double negation mean?
17:16:37 <Cale> I'm not not going to the store.
17:16:49 <lament> i mean in intuitionistic logic :)
17:17:03 <dolio> @djinn-add type Cont r a = (a -> r) -> r
17:17:06 <lament> @djinn Not False
17:17:06 <lambdabot> -- f cannot be realized.
17:17:12 <lament> @djinn Not True
17:17:12 <lambdabot> -- f cannot be realized.
17:17:27 <dolio> @djinn ((a -> Cont r b) -> Cont r a) -> Cont r a
17:17:27 <lambdabot> f a b = a (\ c _ -> b c) b
17:17:30 <Cale> lament: Well, one way to look at it is that it's a way of embedding classical logic.
17:17:32 <lament> @djinn True
17:17:33 <lambdabot> -- f cannot be realized.
17:17:36 <ddarius> False and True aren't types.
17:17:41 <dolio> @djinn Not Void
17:17:41 <lambdabot> f a = a
17:18:05 <lament> @djinn Not Bool
17:18:06 <lambdabot> -- f cannot be realized.
17:18:11 <dolio> Void is false, () is true.
17:18:18 <Cale> Since even though not (not a) is not the same thing as a, we do have that not (not (not a)) is the same as not a, and hence that not (not (not (not a))) is the same as not (not a)
17:18:22 <lament> @djinn Not ()
17:18:22 <lambdabot> -- f cannot be realized.
17:18:25 <dolio> At the type level.
17:18:34 <mauke> @djinn Not (Not ())
17:18:34 <lambdabot> f a = a ()
17:18:38 <lament> Cale: what the hell.
17:18:57 <monochrom> This law is in classical logic and not in intuitionistic logic:  ((x and y) implies z) implies ((x implies z) or (y implies z)).  I once explained it to DRMacIver as he had found it counterintuitive.  Here is why: most intuitions read "A or B" as "A is provable or B is provable".
17:19:03 <ddarius> @djinn Not (Not (Not (Not a))) -> Not (Not a)
17:19:04 <lambdabot> f a b = void (a (\ c -> void (c b)))
17:19:39 <Cale> and so by applying 'not not' to all our variables, we get back to a classical-logic-like setting.
17:20:12 <ddarius> Proof-theoretically, the double negation transform is the continuation passing transform.
17:21:31 <yitz> there we go, someone said some nice things about xmonad in a comment. not even a user of xmonad, they're using Ion.
17:22:02 <dolio> @djinn (a -> b) -> Not (a, Not b)
17:22:02 <lambdabot> f a (b, c) = c (a b)
17:22:32 <ddarius> The other way doesn't hold though.
17:22:42 <ddarius> @djinn Not (a, Not b) -> (a -> b)
17:22:42 <lambdabot> -- f cannot be realized.
17:23:00 <dolio> Yeah.
17:23:18 <ertai> why groupWith and sortWith are in GHC.Exts and not in Data.List ?
17:23:27 <dolio> That's an encoding of functions in terms of continuations in a paper I was reading.
17:23:49 <dolio> A function a -> b is a continuation that takes a pair of an a and a continuation that takes a b.
17:23:55 <ddarius> dolio: Indeed.  It's a common definition for implication in classical logic.
17:24:14 <Cale> ertai: Huh? Are they there?
17:24:22 <Cale> ertai: Which version of GHC?
17:24:26 <dons> ddarius: though we're not trying to beat gnome -- its a bit silly -- since xmonad plays well with gnome.
17:24:31 <dons> we should advertise that more widely
17:24:40 <monochrom> Eh? groupBy and sortBy are in Data.List and are probably a better choice.
17:24:41 <ddarius> xmonad is not a desktop manager
17:24:53 <yitz> dons: someone wrote it in a comment there
17:24:56 <dons> right. its the underlying glue. then let gnome do all the funky things
17:25:08 <dons> so choose both, if you want
17:25:37 <dons> ddarius: using xmonad yet, btw?
17:25:51 <dons> simon marlow started yesterday. don't get left behind!
17:25:58 <Twey> Heh
17:26:04 <dolio> ddarius: Ah, indeed. I suppose be De Morgan's that's equivalent to Not a \/ b, which is how you (or, I) usually see it.
17:27:08 <dolio> I hadn't thought of that.
17:27:12 <ertai> Cale: darcs tells me that they are there from 12/20/07
17:27:39 <ertai> monochrom: {group,sort}With are nice shortcuts however
17:27:41 <Cale> ertai: You're running a non-release version?
17:28:27 <yitz> dons: I have to run kde via kdm because of my kids/wife. how hard would it be to use xmonad on my own login?
17:28:42 <ddarius> dons: The version of xmonad I'm using is 0.3 and that's not the version I started with.
17:28:46 <mauke> not very
17:28:47 <ertai> Cale: nope I run ghc-6.8.2, and it even don't have them.
17:28:51 <dons> yitz: pretty easy, just tweak gdm or kdm to allow choosing xmonad
17:28:56 <dons> yitz: there's a big howto for this
17:28:59 <mauke> I run xmonad via gdm
17:29:09 <Cale> ertai: I don't see those functions in GHC.Exts
17:29:11 <dons> and you keep using the kde trays and so on
17:29:13 <yitz> dons: i see the howto for gnome
17:29:15 <dons> ddarius: ah yes.
17:29:39 <yitz> ah, there it is
17:29:45 <ddarius> dons: The only reason I didn't use it earlier was that I didn't have linux installed at the time.
17:29:52 <ertai> Cale: I mean, they are in the darcs repo, but not released indeed.
17:34:44 <dolio> Is 6.10 getting stream fusion for lists?
17:34:46 <AMcBain> I installed hugs (command line) (I'm on Linux) and I can't seem to get it to load a file I created. What is the base dir for the program when I load it?
17:35:17 <monochrom> perhaps the current directory
17:35:39 <dons> dolio: nope. but i'll improve the library support
17:35:45 <dons> so that just means no list comprehension magic
17:35:47 <AMcBain> that would seem to make sense, except nothing happens when I ":load program"
17:35:58 <dolio> Ah.
17:36:00 <AMcBain> oh
17:36:02 <AMcBain> nvm.
17:36:13 <AMcBain> I guess I defined a function, which I had to call.
17:36:19 <Twey> Heh
17:39:05 <AMcBain> I have the task of writing a program I wrote in Scheme in Haskell. If it wasn't the point of the class, I would just leave it in Scheme and contemplate the point hit I would take when I turned it in. Google was no help, so I'm trying to decipher the "Haskell in 10 minutes" ... which doesn't seem all that helpful to me.
17:42:09 <travisbrady> can anyone point me at a description of what monads are?
17:42:18 <travisbrady> sorry monoids!
17:42:36 <dcoutts_> doesn't google help?
17:42:58 <ddarius> @google monoids
17:43:00 <lambdabot> http://en.wikipedia.org/wiki/Monoid
17:43:00 <lambdabot> Title: Monoid - Wikipedia, the free encyclopedia
17:43:25 <dcoutts_> travisbrady: they're just objects with an associative 'append' operator and a distinguished 'zero' value
17:43:25 <AMcBain> holy crud! GHC is the slowest package I have seen install via apt-get ...
17:43:25 <dcoutts_> the zero value has to be a unit of the append
17:43:30 <travisbrady> dcoutts_: sorry, i was googling too specifically "haskell monoids"
17:43:38 <monochrom> has a binary operator, it has to be associative.  has an "identity" element e, i.e., this law holds: forall x. x `operator` e = x, e `operator` x = x.
17:43:49 <dcoutts_> AMcBain: remember you're trying to get help here :-)
17:44:17 <AMcBain> yeah I know, but since all the tutorials online are oriented to it instead of hugs ...
17:44:36 <ddarius> GHC is way better than Hugs, pretty much all around.
17:44:40 <AMcBain> (I installed hugs because I thought I would get the same GUI app that we were supposed to use in the labs)
17:44:53 <AMcBain> wrong expectation I guess.
17:44:55 <dcoutts_> AMcBain: the ghc package does include a lot of stuff, there's an on going programme to make it more modular
17:44:56 <yitz> AMcBain: ghc is worth it. in the meantime - what does your scheme prog do?
17:44:58 <monochrom> winhugs requires windows
17:45:23 <monochrom> Do an apt-get downgrade to XP. :)
17:45:43 <dcoutts_> AMcBain: also, you're probably downloading ghc-6.6.1 which was the last big monolithic release
17:46:50 <AMcBain> My new PC when I get it *will* have XP. When I installed this, it was bliss, but when I started to find all the limitations, segfaults, things I couldn't do, it became a pain. And I'm not a person adverse to doing stuff via command line or low level. Think of how bad this must be for users *not* very interested in computing fields of study.
17:47:40 <AMcBain> The program recursively solves a "lights-out" or "blackout" board of any size. I do it via depth-first brute-force iterative backtracking.
17:48:09 <AMcBain> ah, it finished.
17:49:39 <roconnor> @djinn (((a -> b) -> a) -> Not (Not a))
17:49:39 <lambdabot> f a b = void (b (a (\ c -> void (b c))))
17:50:56 <AMcBain> Yay. I got it to print a string. Step at a time.
17:51:26 <yitz> AMcBain: link for "lights-out" or "blackout"?
17:51:34 <AMcBain> oh :)
17:52:09 <AMcBain> http://www.abeautifulmind.com/games/blackout/index.html
17:52:09 <lambdabot> Title: A Beautiful Mind :: Blackout
17:52:25 <solrize> err
17:52:29 <lament> somebody needs to write a sudoku solver in djinn
17:52:39 <lament> is there a type system sudoku solver already?
17:53:26 <EvilTerran> sounds painful
17:53:35 <EvilTerran> i wonder if it'd be possible without -XUndecidableInstances
17:53:49 <Botje> AMcBain: fwiw, perhaps the gui you're using was helium?
17:53:56 <AMcBain> I don't need a gui.
17:54:05 <AMcBain> I just need to solve a inputed solution.
17:54:19 <AMcBain> Which I have already done in scheme :)
17:55:28 <ddarius> There's a simpler game solver in the type system.
17:55:52 <lament> we need to have more stuff in the type system
17:56:03 <lament> the rest of haskell is pretty unpleasant :)
17:56:07 <AMcBain> I've already done it. I just have to convert it to Haskell. that's the point of the assignment is to do a solver in Haskell but the professor recommended we do it in scheme first.
17:57:38 <solrize> are you gonna do it in the haskell type system?
17:57:49 <AMcBain> My program solves a given input to a given "solution", to get an answer in a reasonable amount of time I am allowed (I asked) to only solve a well chosen input to a certain "color" (I represented the colors with 0 and 1). My original solution solved to a all 0 board and an all 1 board and picked the answer with the least number of steps.
17:58:00 <AMcBain> Huh? Haskell type system?
17:58:29 <solrize> yeah, so you can solve a problem instance by compiling the program, without having to actually run it
17:58:37 <Botje> *G*
17:58:48 <Botje> AMcBain: when is the assignment due?
17:59:25 <AMcBain> solrize: Wha? Botje: Friday, but since it is already done in Scheme if I don't get a *working* program in Haskell I can turn that in instead (take a point hit)
17:59:47 <solrize> amcbain, i'm joking, sort of
17:59:48 <Botje> I wish you the best of luck.
17:59:55 <Saizan> @djinn ((((a -> b) -> a) -> a) -> Not (Not a))
17:59:57 <lambdabot> -- f cannot be realized.
18:00:10 <Botje> haskell's type system is turing complete and should be able to solve sudoku problems
18:00:12 <solrize> haskell's type system is fancy enough that you can write programs in it but doing that is pretty crazy
18:00:50 <Botje> lgeek
18:00:52 <Botje> argh
18:01:09 <EvilTerran> time for a password change, Botje?
18:01:21 <Botje> not really
18:01:33 <Botje> i was trying to find an email from thinkgeek in mutt :)
18:01:47 <AMcBain> botje: Ugh, it took me at least 3 to 4 days on #scheme (they all know) to get a working solution ... they helped me half way there and I got the last part myself. (that was only for a single line shuffle) Then I did the full board one myself. (2 different assignments, same approach)
18:02:12 <AMcBain> Well I was told that Haskell and Scheme had similar workings so all I would have to do is change the syntax ...
18:02:35 <AMcBain> At least I don't think I abused the Scheme dynamic typing, so I should be okay in that regard.
18:02:44 <EvilTerran> well, that depends entirely on how imperative your scheme is
18:02:59 <EvilTerran> what with haskell actually enforcing purity
18:03:09 <monochrom> Everything made of atoms has "similar" working.
18:03:28 <AMcBain> I can paste it if you want ... ? (just to see what it looks like, I want to do the conversion myself)
18:03:41 <EvilTerran> ok
18:03:47 <ddarius> monochrom: But Scheme is made of atoms while Haskell is not.
18:04:04 <lament> haskell is pure energy
18:04:32 <yitz> @hpaste
18:04:32 <lambdabot> Haskell pastebin: http://hpaste.org/new
18:04:46 <monochrom> There is a stronger conjecture.  Everything made of GUT particles has "similar" working.
18:05:48 <yitz> AMcBain: 3x3 board?
18:06:18 <AMcBain> Well that's what the website is, but I programmed mine to be able to do any size (just depends on how patient you are)
18:06:41 <AMcBain> http://hpaste.org/6650
18:07:07 <AMcBain> It got cut off ... !?
18:07:43 <Botje> I wonder if a drscheme plugin for haskell is viable
18:08:08 <Saizan> AMcBain: it's limited to 5k characters
18:08:20 <AMcBain> Botje: That would be nice.
18:08:32 * Botje might make the time to write it up for GSoC
18:08:54 <yitz> AMcBain: yeah, you're over the limit, but anyway, I don't see any set! or do, so I think you're probably in good shape.
18:09:03 <AMcBain> http://paste.lisp.org/display/58065
18:09:06 <AMcBain> There we go.
18:09:20 <AMcBain> (it also does ")" hightlights on rollover :)
18:09:48 <AMcBain> yitz: bang functions and non-recursive Scheme? Oh no!
18:09:49 <AMcBain> :P
18:10:19 <Botje> *nit-pick: that get function looks an awful lot like list-ref
18:10:50 * AMcBain searches for "get" in his non-organized code.
18:11:06 <AMcBain> oh, well sort-of
18:11:26 <AMcBain> I could probably have done (car (list-ref lst))
18:11:30 <Botje> AMcBain++ # (invert (invert (invert (invert (invert ...
18:11:30 <EvilTerran> eeech
18:11:35 <EvilTerran> now i remember why i don't do lisp
18:11:49 <AMcBain> That's Scheme. Big difference.
18:12:03 <EvilTerran> scheme and clisp are both lisps :P
18:12:15 <AMcBain> Just details :P
18:12:15 <EvilTerran> Botje, for the love of god, get that man an infix operator
18:12:20 <Saizan> it's still an unintellegible stream of parentheses to me
18:13:00 <Botje> EvilTerran: actually, mzscheme _DOES_ have an infix operator
18:13:04 <AMcBain> Makes sense to me. The only reason I did (invert (invert ... was because the next one needed the change from the previous, because selection a "spot" involved flipping those "spots" around it.
18:13:18 <Botje> (lst . invert . i)
18:14:16 <EvilTerran> i'd probably write that in haskell as a foldr over a list of changes or something
18:14:28 <zooko> Greetings, folks!
18:14:48 <zooko> Does anybody have an IRC Chump Bot written in Haskell that I can use in the #tahoe channel?
18:15:20 <AMcBain> Hm ... that's an idea. However it probably defeats what I'm supposed to be learning (only sort of, I'd still have to learn it), you would call it ugly, and the prof would probably rather I just turn in the Scheme instead ...
18:15:30 <EvilTerran> given !invert :: Board -> Coordinate -> Board", the function "foldr invert :: Board -> [Coordinate] -> Board" would invert at each given co-ordinate
18:15:45 <EvilTerran> er, that ! should be a "
18:16:18 <Saizan> zooko: Chump?
18:16:19 <AMcBain> huh?
18:17:14 <EvilTerran> AMcBain, i'm taking a function that inverts in one place, and devising from it a function that inverts in as many places as you like
18:18:03 <EvilTerran> alternatively, you could write it as "board `invert` (x1,y1) `invert` (x2,y2) `invert` ..., with an infixl decleration for `invert`
18:18:29 <AMcBain> Okay, uh, any response where would make me seem dense. Maybe I *am* better off turning in the Scheme.
18:18:54 <EvilTerran> maybe yea, maybe nay
18:19:01 <EvilTerran> don't let me put you off with my ramblings
18:19:04 <AMcBain> I'm more lost than the C++ I'm taking.
18:19:29 <AMcBain> (which I mostly understand surprisingly, given the language's penchant for making learning it hard)
18:19:38 <EvilTerran> "you are in a maze of twisty little languages, none alike"
18:19:41 <Botje> you seem to be learning a lot of languages this year, care to give a count?
18:20:43 <AMcBain> I already knew Java, JS, (QBASIC), used to know NQC, C++ (this year), Scheme (this year). I think that's about it ...
18:21:07 <wagle_home> my understanding is that C++ is big and complex, but that there is a nice clean simple powerfull subset that you can use..  unfortunately, i don't know what that subset is
18:21:12 <AMcBain> Sadly no fun esoteric languages ...
18:21:20 <Botje> haskell is fun!
18:21:25 <Botje> but unfortunately not esoteric :(
18:21:26 <AMcBain> wagle_home: C?
18:21:33 <AMcBain> :D
18:21:34 <gweiqi> boost
18:21:36 <wagle_home> no..  objects
18:21:48 <wagle_home> C is full o' warts
18:21:51 <AMcBain> oh. There is Obj-C, which mac uses.
18:22:05 <AMcBain> Botje: Taxi looks fun.
18:22:08 <EvilTerran> objC's okay...
18:22:28 <yitz> shall we mention unlambda?
18:22:35 <AMcBain> Never heard of it.
18:22:41 <wagle_home> haha..  no, C++
18:25:36 <zooko> Saizan: a Chump Bot is a bot that hangs around, and when someone says a URL it fetches the URL and posts the title to the IRC channel.
18:26:07 <TSC> lambdabot does that
18:27:07 <TomM1> lambdabot also does my homework.
18:27:31 <monochrom> lambdabot ate my homework.  That's what I told my prof.
18:27:33 <TSC> lambdabot writes your homework questions too
18:27:48 <wagle_home> AMcBain, the guy who did LLVM told me this
18:27:50 <TomMD> @vixen Do you do my homework too?
18:27:50 <lambdabot> whoa whoa whoa, one question at a time!
18:27:57 <wagle_home> @go LLVM
18:28:00 <lambdabot> http://llvm.org/
18:28:00 <lambdabot> Title: The LLVM Compiler Infrastructure Project
18:28:03 <joricj> lambda bot is my prof
18:30:39 <yitz> @go allmydata tahoe
18:30:42 <lambdabot> http://allmydata.org/
18:30:42 <lambdabot> Title: allmydata.org "Tahoe"  Trac
18:31:50 <joricj> does haskell have something like symbols?
18:32:23 <joricj> like in scheme i'd use 'client-connected
18:32:44 <zooko> yitz: :-)
18:33:31 <yitz> zooko: I worked on a startup doing stuff similar to that some years ago
18:33:41 <kpreid> joricj: data Foo = Bar | Baz deriving (Eq, Show, Read)
18:33:58 <kpreid> joricj: not really the same, but if you want an enum or so, that's what you use
18:34:13 <kpreid> joricj: (whoops, add deriving Enum as well)
18:34:21 <wagle_home> joricj, what fearture of ssymbols do you want?
18:34:32 <yitz> kpreid: how about Bounded?
18:34:45 <kpreid> zooko: that's not the definition of chump I know...
18:37:44 <zooko> 3h
18:37:47 <zooko> oops.
18:38:04 <zooko> kpreid: do tell.
18:39:14 <kpreid> zooko: all I've heard says that a chump is a bot that runs a link-blog based on urls mentioned in the channel, with comments
18:40:20 <zooko> kpreid: oh yeah.  I misremembered.
18:43:26 <ddarius> New Catsters!
18:43:45 <dons> woot!
18:52:00 <Cale> uh, really?
18:52:28 <Cale> The latest I see is still the ones from 2 months ago.
18:53:26 <ddarius> I think what happened is that the renamed them, though at least the Double Categories one
18:53:33 <ddarius> seems not in my collection.
18:56:24 <monochrom> What is catsters?
18:56:32 <dons> ah hmm
18:58:19 <golubovsky> @seen chessguy
18:58:20 <lambdabot> I saw chessguy leaving #haskell 7h 9m 37s ago, and .
18:58:28 <Twey> And .?
18:58:56 <EvilTerran> it's a quirk
18:59:08 <Twey> Unexpected feature?
18:59:11 <Twey> :-)
19:01:23 <monochrom> Oh, now I remember catsters.
19:01:24 <ddarius> That bug has been there forever.
19:01:33 <EvilTerran> ?help seen
19:01:33 <lambdabot> seen <user>. Report if a user has been seen by the bot
19:01:47 <EvilTerran> that makes it sound almost ominous
19:01:49 <monochrom> @unseen dons
19:01:49 <lambdabot> dons is in #ghc, #xmonad, #haskell-soc and #haskell. I last heard dons speak 2m 55s ago.
19:02:03 <ddarius> "Report all suspicious activity"
19:02:09 <monochrom> Haha
19:02:57 <monochrom> @usrz
19:02:57 <lambdabot> Maybe you meant: src url users
19:03:01 <monochrom> @userz
19:03:01 <lambdabot> Maximum users seen in #haskell: 472, currently: 431 (91.3%), active: 12 (2.8%)
19:03:29 <EvilTerran> "<lambdabot> scanning area... target acquired, launching SCUDs"
19:04:21 <yitz> @slap enemy
19:04:21 * lambdabot jabs enemy with a C pointer
19:04:28 <cjs_> Hm. So how do I figure out the number of sig digs in a Double (or Numeric or whatever)?
19:04:30 <Twey> EvilTerran: Hahaha
19:04:32 <monochrom> "<lambdabot> scanning area... target acquired, launching SCUDs... rolling back transaction due to contention... oops, too late, missiles launched anyway"
19:05:02 <EvilTerran> unsafeFireSCUDs#
19:05:05 <Twey> cjs_: length . show ?
19:05:19 <EvilTerran> Twey, eeew
19:05:19 <yitz> next version of lambdabot upgrades to STM
19:05:23 <cjs_> I was thinking that, actually. :-)
19:05:32 <cjs_> But first you have to take all of the zeros off of the end.
19:05:37 <ddarius> @src Real
19:05:38 <lambdabot> class  (Num a, Ord a) => Real a  where
19:05:38 <lambdabot>     toRational      ::  a -> Rational
19:05:48 <ddarius> @src Floating
19:05:48 <lambdabot> class  (Fractional a) => Floating a  where
19:05:48 <lambdabot>     pi                                                      :: a
19:05:48 <lambdabot>     exp, log, sqrt, sin, cos, tan                           :: a -> a
19:05:48 <lambdabot>     asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh :: a -> a
19:05:48 <lambdabot>     (**), logBase                                           :: a -> a -> a
19:05:53 <EvilTerran> and some values aren't precisely representable as doubles, so will have INFINITY sigfigs :P
19:06:08 <cjs_> That's all right.
19:06:30 <monochrom> Methinks you need RealFrac
19:06:31 <roconnor> @src RealFrac
19:06:31 <lambdabot> class  (Real a, Fractional a) => RealFrac a  where
19:06:31 <lambdabot>     properFraction                   :: (Integral b) => a -> (b,a)
19:06:31 <lambdabot>     truncate, round, ceiling, floor  :: (Integral b) => a -> b
19:06:32 <AMcBain> Ugh. It looks like I'm going to need some serious help. The only guide I can find for Scheme to Haskell is one that teaches you how to make a Scheme interpreter in Haskell using Monads. Well I know enough about Monads to know I won't need it. Plus the professor grades like a mad man, so I don't have a choice, I have to turn it in Haskell.
19:06:38 <roconnor> @src RealFloat
19:06:38 <lambdabot> Source not found.
19:06:39 <monochrom> Darn.
19:06:45 <cjs_> I'm comparing those with numbers I make, to the number of sig digs in my number.
19:06:54 <dons> AMcBain: you know Scheme?
19:06:59 <dons> and are learning Haskell
19:07:03 <roconnor> @hoogle mantissa
19:07:04 <lambdabot> No matches found
19:07:12 <roconnor> @hoogle encodeFloat
19:07:13 <lambdabot> Prelude.encodeFloat :: RealFloat a => Integer -> Int -> a
19:07:19 <roconnor> @src RealFloat
19:07:19 <lambdabot> Source not found. Sorry.
19:07:26 <yitz> > floatToDigits 10 3.14159
19:07:27 <roconnor> lambdabot: screw you
19:07:30 <lambdabot>  ([3,1,4,1,5,9],1)
19:07:38 <cjs_> AMcBain: that's a good little tutorial, actually. And you don't really have to worry about the monads bit; it's just a pretty standard functional parser.
19:07:47 <yitz> > floatToDigits 16 3.14159
19:07:48 <lambdabot>  ([3,2,4,3,15,3,14,0,3,7,0,12,13,12],1)
19:08:13 <AMcBain> dons: Yeah. But apparently that isn't good enough. The professor loves Scheme (greatest thing since sliced bread), but this assignment is due in Haskell. He only we suggested that we do it in scheme first, so we have a partial fall-back, or a better chance of completing the assignment.
19:08:17 <roconnor> cjs_: I think you want floatDigits
19:08:18 <yitz> > floatToDigits 10 pi
19:08:19 <lambdabot>  ([3,1,4,1,5,9,2,6,5,3,5,8,9,7,9,3],1)
19:08:24 <roconnor> > floatDigits pi
19:08:26 <lambdabot>  53
19:08:31 <gwern> > 3.5 + 2.8
19:08:32 <lambdabot>  6.3
19:08:33 <monochrom> In RealFloat, there is floatDigits
19:09:07 <monochrom> > map floatDigits [pi, 2, log 10]
19:09:09 <lambdabot>  [53,53,53]
19:09:46 <monochrom> Scheme is the greatest thing since sliced bread.
19:09:56 <monochrom> Haskell is the greatest thing since Scheme.
19:09:56 <ddarius> Sliced bread isn't actually all that great.
19:09:57 <EvilTerran> well, that's not right
19:10:00 <AMcBain> The whole point of the class is to be able to apply what we are learning to other languages so we can learn them easily and relative to their paradigm (not just trying to do say, Java in Scheme or such) but as such he won't answer any questions we ask him about Haskell.
19:10:27 <cjs_> Haskell is...different.
19:10:30 <AMcBain> He pretends he doesn't know what it is, and replies: "I love Scheme".
19:10:43 <gwern> monochrom: and agda/epigram/qi are the best things since haskell?
19:10:46 <AMcBain> Nice guy, but can be an asshole om purpose.
19:10:50 <monochrom> Yes.
19:10:54 <EvilTerran> AMcBain, poke him with a sharp stick 'til he complies :D
19:11:01 <AMcBain> Can't do that.
19:11:03 <monochrom> poke him with a C pointer
19:11:13 <EvilTerran> "THE POWER OF LAMBDA COMPELS YOU"
19:11:14 <AMcBain> We tried that. All we got was "Scheme doesn't have pointers"
19:11:35 <ddarius> Haskell does.
19:11:42 <monochrom> DDoS him.
19:11:56 <gwern> scheme has continuations. they're even better
19:12:24 <AMcBain> I only took this class out of sequence because some upperclassmen suggested that taking a class with this professor was a chance I shouldn't pass up. And we can't use continuations. We were only allowed to use "good" functional programming.
19:12:26 <cjs_> roconnor: Yes, it looks as if floatToDigits is the thing.
19:12:42 <yitz> AMcBain: there's a small scheme interpreter written in Haskell. Download it, and include your scheme program as a string constant.
19:13:00 <Cale> AMcBain: What are you writing in Haskell?
19:13:01 <AMcBain> That's not what he wants, and I know that.
19:13:32 <monochrom> haha
19:13:34 <Cale> (and are there any immediate questions you might have?)
19:13:38 <yitz> Cale: He's writing http://www.abeautifulmind.com/games/blackout/index.html
19:13:39 <lambdabot> Title: A Beautiful Mind :: Blackout
19:13:54 <yitz> without the graphics :)
19:14:00 <AMcBain> Cale: I'm going to attempt to convert my program: http://paste.lisp.org/display/58065 to Haskell.
19:14:09 <AMcBain> and come out with a working Haskell program.
19:14:19 <gwern> yitz: my flash isn't working. what is that?
19:14:27 <AMcBain> a "working program" is part of the requirements :-/
19:14:36 <Cale> Oh, that shouldn't be so bad.
19:14:46 <AMcBain> "shouldn't"
19:15:13 <AMcBain> I'm not finding any tutorials that aren't throwing me the "syntax book" at me.
19:15:23 <AMcBain> (and hitting me in the face)
19:15:39 <gwern> goddamn you Mainichi Daily news! you just broke all my links
19:15:46 <gwern> wtf. it's not too hard to add redirects
19:16:04 <yitz> gwern: cover an othello board with pieces. at each move, flip a piece plus each adjacent piece (not diagonal). get the board to be all one color in minimum moves.
19:16:48 <ddarius> gwern: All your links are belong to Mainichi
19:16:56 <AMcBain> The problem being that it took me about 3 days or so (maybe 4?) to do that program in the paste with help. The assignment I got help on was to do a shuffle, where we had to get from a to b in a 1x4 "board", and I scaled that approach up to the paste you see.
19:17:01 <gwern> yitz: hm. what's that isomorphic to?
19:17:37 <yitz> gwern: dunno. tried playing the flash for a few minutes. it's weird.
19:18:09 <gwern> ddarius: no, they is belong to Internet Archive, for backing up the articles....
19:18:25 * gwern really needs to get around to earning some money to donate to the IA. they are so underappreciated
19:19:31 <roconnor> IA?
19:19:40 <roconnor> oh internet archive
19:20:34 <byorgey> gwern: it's isomorphic to computing the inverse of a 64x64 sparse binary matrix  =)
19:21:20 <AMcBain> uh well, okay, cale ... you're the one that said this "shouldn't be so bad". Mind helping me? (pointers and other things). Like how I might get that same nested function thing I'm doing (so I don't litter everything with global functions (which I don't even know how to do either). Isn't there a simple tutorial that isn't cheesy "5 steps" or "in 10 minutes"?
19:21:25 <gwern> byorgey: hmm, I see!
19:21:51 <Cale> AMcBain: Mostly we recommend the Wikibook and YAHT
19:22:00 <gwern> the wikibooks is good
19:22:03 <AMcBain> Okay.
19:22:08 <gwern> and if it isn't good, write some cogent criticisms and it'll become better :)
19:22:14 <Cale> AMcBain: If you've used something like ML before, you might also find the "Gentle" tutorial useful.
19:22:14 <gwern> @where wikibook
19:22:15 <lambdabot> http://en.wikibooks.org/wiki/Haskell
19:22:28 <Cale> (actually, you might find it useful anyway, but it's a little fast)
19:22:31 <AMcBain> ML. Never heard of it.
19:22:32 <Cale> @where tutorial
19:22:32 <lambdabot> http://www.haskell.org/tutorial/
19:23:17 <Cale> ML is a family of functional languages which are pretty close to Haskell.
19:23:56 <Cale> (well, there's an original one called ML, and then there's SML and Caml and O'Caml and a bunch of others)
19:24:48 <TomMD> Are type familes available in GHC head or 6.8.x?
19:25:42 <EvilTerran> 6.8 has 'em. ish.
19:25:55 <Jedai> OCaml and SML are probably the most useful and used family of ML now
19:26:01 <TomMD> ish... sounds like I should test.
19:26:11 <dobblego> F#
19:26:37 <Jedai> TomMD: 6.8 (and even GHC head) lacks some of the features of the paper though
19:26:50 <TomMD> Do you know which?
19:27:22 <Jedai> dobblego: Can we really call F# a ML ?
19:28:09 <ddarius> dobblego: Yes.
19:28:39 <dobblego> Jedai, sure, why wouldn't you?
19:29:43 <Jedai> dobblego: overloading, object system (a regular one, not the OCaml one)... But I guess the base is still very close to ML
19:31:14 <Jedai> AMcBain: Do you do something clever in your Scheme ? Or are you just exploring all the possibilities ?
19:31:26 <AMcBain> Clever? Huh?
19:32:07 <Jedai> AMcBain: I mean this game is very simple, so it may have some mathematical proprieties easy to exploit to find the solution fast ?
19:32:29 <Jedai> AMcBain: I guess you're just exploring all paths ?
19:32:31 <AMcBain> Nah, I just did a backtracking solution with a max bound.
19:33:01 <AMcBain> Visually, I can exploit patterns I know lead to a solution in a certain number of moves.
19:33:25 <Cale> AMcBain: In Haskell, you shouldn't need a max bound :)
19:33:38 <Jedai> AMcBain: Visually ? But this recognition of pattern isn't exploited in your program, is it ?
19:33:43 <Cale> AMcBain: You can generate the entire game tree, and then just search through it however you'd like :)
19:33:57 <Jedai> Cale: Except if there is no solution (is it possible ?)
19:34:27 <AMcBain> Jedai: We by visually, I mean I can see the whole board. so I can see things that the program won;t know without explicitly checking, plus my solution works for an n-size board. The pattern thing only works for 3x3
19:34:33 <Cale> Jedai: well, of course you wouldn't find one in that case, but I think every pattern can be done
19:34:56 <AMcBain> Cale: No, the program doesn't know when to stop "swaping" values so it just keeps on going, and being depth first, it never ends. So no tree.
19:35:23 <Cale> AMcBain: well, sure, but you just wouldn't explore that tree depth first :)
19:35:38 <cjs_> Hmm...sounds like you want to rewrite the algorithm to take advantage of lazyness. I'd recommend doing that after a mechanical translation.
19:35:44 <Cale> But lazy evaluation means that you can construct the infinite tree and then search.
19:35:49 <AMcBain> I already have a depth first solution to the problem, so why destroy that?
19:36:14 <Cale> Sure, if you'd prefer :)
19:36:27 <AMcBain> The program is already mostly functionally oriented, so I just need to convert it and beware of syntax.
19:36:30 <AMcBain> I hope.
19:36:34 <AMcBain> :-/
19:36:41 <Jedai> AMcBain: Do you stop as soon as you find a solution or do you continue exploring other branches ?
19:37:11 <AMcBain> When I find a solution I just return. So I sort of hope that the first solution is the best. (chances are it's not, but why keep searching?)
19:37:42 <Jedai> AMcBain: In fact, a program in Haskell to do what you appear to be doing should be extremely short and simple...
19:38:07 <AMcBain> Basically I didn't want to have to compare returned results against the previous return and see if it was better (assuming of course that '() was an invalid solution)
19:39:32 <AMcBain> Oh, that was why. It would require mroe work, because I think I would get shot if I used a bang function (with a let)
19:40:51 <Jedai> AMcBain: You didn't need to, you just have to lower the maxBound of your exploration for the next branches
19:41:58 <AMcBain> well, I found that most of the searching performed in the first branch was repeated ... don't know why. (that was for my 1x4 problem shuffle solution, not this particular one)
19:42:20 <AMcBain> I do know that the center position is the first combination tried though :)
19:46:57 <AMcBain> Okay, I got it to load a main and Sol module ...
19:47:08 <AMcBain> It prints 'hello' :-/
19:48:21 <joricj> > case "str" of 's':'t':_ -> 1
19:48:30 <lambdabot>  1
19:48:42 <joricj> > case "str" of 's':'t':'r':a -> a
19:48:43 <lambdabot>  ""
19:49:23 <joricj> > case "str" of "st":a -> a
19:49:24 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
19:50:14 <joricj> is there a shortcut way to say "verylongstring_" -> mycase?
19:51:09 <EvilTerran> joricj, sadly not
19:51:14 <ddarius> s == "verylongstring_"
19:51:23 <EvilTerran> ?type isPrefixOf -- there's this
19:51:25 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
19:52:09 <Cale> AMcBain: I have a solution here which is ~30 lines of code.
19:52:12 <EvilTerran> so you could write that as "s | "verylongstring" `isPrefixOf` s -> ...
19:52:41 <joricj> hmmm
19:52:42 <ddarius> Cale and his verbose code...
19:52:57 <Cale> Yeah, I could probably get that down somewhat :)
19:53:03 <AMcBain> Cale: well, okay, but isn't the point of this assignment for me to do it? :P (not that the prof wouldn't take it, if I properly cited the source)
19:53:04 <EvilTerran> but that only works if you have Eq on the elements. which is fine for strings, but might occasionally cause trouble with other list types
19:53:10 <EvilTerran> ?quote EvilTerran import
19:53:10 <lambdabot> EvilTerran says: if three of those lines aren't import Control.Monad; import Control.Arrow; import Control.Applicative;, you can make it shorter ;]
19:53:29 <Cale> AMcBain: Well, I'm not going to just hand it to you. :)
19:53:34 <AMcBain> I know.
19:53:37 <Cale> AMcBain: But using laziness is good :)
19:53:39 <ddarius> Cale's point is that it can be done concisely (and presumably reasonably easily)
19:53:41 <AMcBain> Hence the ":P"
19:54:05 * EvilTerran suffers adverb overload at ddarius' comment
19:54:07 <Cale> You can construct the lazy tree of all the possible ways to move, along with the move sequences involved
19:54:21 <Cale> and then write a general breadth first search
19:54:27 <Cale> (which gives you a lazy list)
19:54:37 <EvilTerran> you don't even need an explicit tree, i suspect. a tree of thunks'd work.
19:54:41 <Cale> and then just find the first element of that list which is a solution (that is, which is the empty board)
19:54:44 <AMcBain> But concise isn't the point here. I'm just about getting the original program to Haskell, without trying to do the equivalent of "Java in Scheme" (which would be very hard to do given that I originally programmed it with functional programming in mind)
19:55:12 <ddarius> AMcBain: You are going to end up doing the equivalent of "Scheme in Haskell"
19:55:21 <Cale> AMcBain: You *can* do that, it's just that what's natural in Haskell and what's natural in scheme are two different things :)
19:55:56 <AMcBain> Okay fine, I'll just say it: I hate this fucking assignment. That said, I still have to do it.
19:56:29 <joricj> is there example code of constructing a lazy tree of nodes and edges? could you use it to create a lazy graph too? what are the limits?
19:56:46 <cjs_> Actually, it sounds like a pretty fun assignment to me, once you get over the syntax issues. Just start translating it bit by bit, learn the syntax, and then rewrite and have fun.
19:56:49 <Cale> btw, that flip function is *much* easier to write if you just generate a list of the (index,index) pairs, and then filter for validity.
19:57:11 <Cale> You don't end up with all the edge cases.
19:58:53 <Cale> and the function to apply those changes is then just a fold over the list of changes to make
19:59:08 <AMcBain> The original program was a shuffle of a 1x4 grid where I had "B" "W" and one "-" and had to get from A to B, so I fed it A and B and got the steps required. Then to make the same top-level tree logic I used work with my modified "swap" (now called "flip") which was 2D, so I made functions to convert the 1D number to a 2D xy, without having a 2D list of lists represented as a single list (I tried initially and decided to do what was easiest)
20:00:11 <Cale> valid (x,y) = 0 <= x && x <= 2 && 0 <= y && y <= 2
20:00:11 <Cale> moveChanges (x,y) = filter valid [(x,y),(x+1,y),(x-1,y),(x,y+1),(x,y-1)]
20:00:11 <Cale> move (x,y) b = foldr change b (moveChanges (x,y))
20:00:32 <Cale> (where change takes a move and a board and applies the change to that board)
20:01:00 <Cale> er, a position and a board, and flips the cell at that position
20:02:03 <Cale> Of course, if you want this to work for more board sizes, it's easy to add that parameter (in fact, the Haskell array library is such that I could probably just use that to check the bounds)
20:02:32 <AMcBain> aghk. Look my head is going to explode, really. I just want to do this and get it over with, and I'm not really getting anywhere, and by myself I'm being slow, the wiki book is still explaining typing and why mixing True and 3 in a list is bad (stuff I already know) and (no offense) everyone here is telling me that I could have done a much better job hand I already know everything in the universe before I even started the assignment.
20:02:52 <AMcBain> had*
20:03:13 <Cale> AMcBain: I'm not trying to be insulting or anything, I'm just showing another way.
20:04:15 <dobblego> I'll tell you you need to know everything in the universe if you like ;)
20:04:21 <AMcBain> 41
20:04:24 <AMcBain> +1
20:04:28 <dobblego> prime!
20:04:34 <AMcBain> (mistyped 42)
20:04:53 <dobblego> AMcBain, take a break, come back and we'll help out
20:05:17 <Saizan> ?google haskell gentle introduction
20:05:22 <lambdabot> http://www.haskell.org/tutorial/
20:05:22 <lambdabot> Title: A Gentle Introduction to Haskell, Version 98
20:05:28 <AMcBain> Stuff I was typing but got distracted by other comments -> "I know, but that's just it: I only need to convert my way to complete the assignment. This is very shortsighted and if I was actually learning Haskell (I have a feeling that the next assignment would be in a different language yet) I might rewrite it to be more efficient ..."
20:05:40 <Saizan> that's faster ^^^^
20:06:18 <Cale> It's easy to know everything in the universe if you're a solipsist.
20:06:36 <Saizan> well you still need to learn a little of haskell to translate that
20:06:42 <AMcBain> And I can pretty much do almost anything I need in Scheme now, and in Java I can do any damn thing you want (JS too) but learning new languages is frustrating when your own prof won't help you and everyone tells you it's easy.
20:07:00 <dolio> Yeah, but then all your knowledge isn't useful. :)
20:07:04 <Cale> AMcBain: Well, learning Haskell is not necessarily easy.
20:07:13 <Cale> (and you absolutely should not expect it to be)
20:07:49 <Cale> Haskell makes all the other languages in the world look like dialects of one another by comparison. :)
20:08:04 <dolio> @quote qwe1234
20:08:04 <lambdabot> qwe1234 says: sometimes i think lisp is as deadly to programmer competence as java or basic.
20:08:05 <Cale> (not quite true, but almost)
20:08:56 <chessguy> Cale, ever programmed in RPG? :)
20:09:00 <AMcBain> Well the guy in front of me has a working solutions (breadth even!) in both, and there are some others who haven't even a working solution in Scheme, so I'm slightly more than middle of the road, and not too far from sending a mass e-mail asking for Haskell help from other classmates and trying to "break into" the group (I'm the only underclassman)
20:09:15 <bitrot> no, learning Haskell is like mountain biking.  it can hurt, but damn, it's fun :)
20:10:44 <Cale> chessguy: I haven't been out in the real world enough for that :)
20:11:01 <svat> AMcBain: you could also try asking here about specific things and what the syntax is for doing them.
20:11:02 <chessguy> Cale, that's another _very_ different language
20:11:16 <AMcBain> I'm beginning to think I shouldn't have taken this class out of sequence.
20:11:24 <cjs_> Learning Haskell is not easy.
20:11:28 <chessguy> all i remember about it is, it's based on columns, somehow
20:11:35 <AMcBain> (not that there are any classes that I would have needed to take this one)
20:11:44 <Jedai> AMcBain: To encourage you, I just wrote a solution in 20 lines of Haskell in 10 minutes
20:12:10 <joed> Hah
20:12:13 <AMcBain> That's not encouraging at all!
20:12:21 <chessguy> AMcBain, what problem are you trying to solve?
20:12:23 <joed> AMcBain: Are you having fun out of waters?
20:12:30 <svat> AMcBain: If you have written it in Scheme, and it is reasonably functional (and not the "code rewriting code" Lispishness), it should be simple to directly translate into Haskell, I think.
20:12:32 <Cale> AMcBain: While I bet that you will actually be able to get that program working, to give you some idea, it took me about 2 months before I started to feel like I could really get things done using Haskell, and about a year before I was comfortable. I consider it the most worthwhile programming language I've learned yet, but it took some time. :)
20:12:38 <AMcBain> Oh lovely. ##java members. Now I can be humiliated in more than one channel
20:12:59 <joed> AMcBain: Nah, I'd praise your for being here.
20:13:08 <Jedai> AMcBain: That means you can get a working solution fast, I didn't use too much magic in it too.
20:13:08 <AMcBain> Thanks :)
20:13:28 <dolio> chessguy: Well, obviously, Haskell doesn't make befunge look like smalltalk. :)
20:13:37 <Jedai> AMcBain: And it gives you an idea of why Haskell may be a valuable language to learn :-)
20:13:42 <AMcBain> svat: I've been told that by everyone but it still isn't falling into place, for someone like me who has a large grasp of OO languages that aren't functional.
20:14:48 <Cale> AMcBain: Perhaps you'd just like a tour of the Haskell syntax to give you some idea of what things are supposed to look like?
20:15:01 <AMcBain> Okay, well let's start with this: How can I use a module to make sure that my functions that I wrote can't be seen outside of that module? Similar to my Scheme program, but not necessarily nested like the get inside of sol.
20:15:03 <Cale> http://cs.anu.edu.au/Student/comp1100/haskell/tourofsyntax.html
20:15:05 <lambdabot> Title: Tour of the Haskell Syntax
20:15:24 <Cale> Modules each go in a separate file
20:15:30 <Jedai> AMcBain: module Blackout (solveBoard) where
20:15:35 <gwern> @seen lispy
20:15:35 <lambdabot> lispy is in #haskell, #darcs, ##logic, #ghc and #haskell-blah. I last heard lispy speak 5h 14m 15s ago.
20:15:36 <dobblego> you use an explicit export list and list only those functions you want available
20:15:38 <Cale> and are named the same as the filename
20:15:41 <joed> AMcBain: learn a functional language to really grasp OO
20:15:55 <Cale> see Jedai's example -- you'd put that at the top of your file
20:16:06 <Cale> and name the file something like  Blackout.hs
20:16:09 <Jedai> AMcBain: Only solveBoard will be exported from that module Blackout
20:16:37 <AMcBain> Oh, so I want to do Sol (sol)?
20:16:44 <AMcBain> (as in the Scheme, that's what I call)
20:17:09 <AMcBain> *slap* I was already given that by cjs_ ... ugh why didn't I see it?
20:18:14 <Cale> I'd start just by putting everything in one module though
20:18:29 <AMcBain> What's the comment syntax?
20:18:32 <Cale> and not including the module decl. (which will just export everything)
20:18:37 <Cale> -- this is a one line comment
20:18:40 <Cale> {- this is
20:18:44 <AMcBain> Okay.
20:18:47 <Cale>   a multiline comment -}
20:18:50 <AMcBain> I only used ;; in Scheme anyways.
20:19:02 <Cale> Multiline comments may be nested.
20:19:49 <AMcBain> Ah yes, I've done that occasionally in JS, but only to remove things when refactoring and such. (abomination otherwise)
20:19:49 <Mr_Awesome> hooray for comment nesting!
20:19:54 <cjs_> Note to self: do not type "repeat 3" into a REPL prompt.
20:20:28 <EvilTerran> > repeat 3
20:20:34 <lambdabot>  [3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3...
20:20:41 <Cale> cjs_: You can just kill the evaluation, can't you?
20:20:43 <EvilTerran> > fix show
20:20:43 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
20:20:50 <Cale> > fix (3:)
20:20:51 <lambdabot>  [3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3...
20:21:14 <EvilTerran> > iterate id 3
20:21:14 <lambdabot>  [3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3...
20:21:46 <mauke> > [3,3..]
20:21:47 <lambdabot>  [3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3...
20:21:54 <AMcBain> You could play with my JS bot using Rhino ...one of my test plugins was "eval", and I prevent use of "bot." but you could still do some pretty evil stuff ...
20:21:59 <AMcBain> X)
20:22:26 <svat> Has there been talk of adding docstrings to Haskell at some point?
20:22:43 <patchwork> @src fix
20:22:43 <lambdabot> fix f = let x = f x in x
20:23:02 <mauke> > cycle[3]
20:23:03 <lambdabot>  [3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3...
20:23:34 <patchwork> fix is one wacky function
20:23:45 <patchwork> for being so simple
20:23:54 <Cale> It finds the least-defined fixed point of its parameter
20:23:58 <EvilTerran> fix f = f (fix f) -- if you prefer
20:24:36 <AMcBain> Why does "sol = board\n        print(board)" give "not in scope:
20:24:40 <AMcBain> 'board'"
20:25:19 <koninkje> because you haven't defined the variable board anywhere?
20:25:21 <EvilTerran> do you mean "sol board =\n..."?
20:25:22 <cjs_> So totally useless question, but do people usually use tabs in their .hs files, or spaces?
20:25:25 <Twey> > take 10 $ fix (3:)
20:25:29 <lambdabot>  [3,3,3,3,3,3,3,3,3,3]
20:25:34 <cjs_> (I.e., for a line starting in column 8.)
20:25:35 <Cale> cjs_: *always* spaces
20:25:37 <Twey> cjs_: I use spaces
20:25:43 <dolio> Spaces.
20:25:46 <EvilTerran> AMcBain, parameters come before the =, not after
20:25:48 <AMcBain> cjs: One tutorial told me tabs were bad.
20:25:51 <EvilTerran> cjs_, i use spaces too
20:25:52 <mauke> tabs! (just to be different)
20:25:52 <cjs_> Hm. So I should definitely switch, then.
20:25:53 <patchwork> > 3:
20:25:53 <AMcBain> EvilTerran: Oh.
20:25:54 <Twey> Tabs change width
20:25:54 <lambdabot>   parse error on input `}'
20:25:56 <Cale> cjs_: I make sure that my editor is configured such that tab characters never end up in source files
20:26:00 <patchwork> > (3:)
20:26:02 <Twey> Which is irritating if you're trying to line things up
20:26:04 <lambdabot>  <[Integer] -> [Integer]>
20:26:22 <EvilTerran> tabs may confuse the layout desugarer
20:26:22 <Cale> (In fact, I think they should be considered lexical errors by the compiler)
20:26:30 <Jedai> cjs_: Spaces, death to the tabulation !! ;-)
20:26:36 <AMcBain> My Java alway uses tabs, but when I do C++ in nano, it's always spaces because of the size of the terminal being so small.
20:26:42 <mauke> my haskell coding styles allows use of tabs
20:26:47 <EvilTerran> that's pretty unanimous. i'm surprised.
20:26:55 <cjs_> Depends on how you're trying to line stuff up. In vi, the shiftwidth setting and the shift operators make life very simple for block-syntax languages such as C and Ruby.
20:27:01 <EvilTerran> (not entirely, but mostly)
20:27:19 <svat> cjs_: it will not remain lined up on *others'* computers :)
20:27:43 <cjs_> Sure it will, if they set tabstops to God's True Value of 8.
20:27:48 <mauke> depends on how you write code
20:27:53 <AMcBain>  Couldn't match expected type `(a -> IO ()) -> t1 -> t'
20:27:53 <AMcBain>            against inferred type `IO ()'
20:27:57 <mauke> (my tabstop=4, btw)
20:27:59 <cjs_> shiftwidth fills with spaces and tabs as appropriate.
20:28:00 <Twey> cjs_: Ych
20:28:01 <Jedai> At least, be careful that tabulation shows in your editor with the same width that GHC see them (8 spaces)
20:28:04 <Twey> tabstop=2
20:28:23 <cjs_> Twey: that's broken. You want shiftwidth=2 tabstop=8.
20:28:30 <mauke> cjs_: NO!
20:28:41 <mauke> you never want shiftwidth /= tabstop
20:28:48 <Twey> Heh
20:28:50 <mauke> that leads to broken layout
20:29:07 * Twey doesn't use tabs anyway, tab is just a convenient 'two spaces' key.
20:29:10 <cjs_> What? That's the only way layout can work if you use tabs.
20:29:17 <mauke> more importantly, it leads to mixed spaces/tabs for indentation, which is just ugly
20:29:22 <mauke> cjs_: wrong
20:29:23 <ahunter> The RealWorld tokens that the IO monad passes around...they don't contain any actual data, do they?  Am I right in thinking they're just placeholders to ensure proper evaluation?
20:29:31 <cjs_> Layout will break if tabstop /= 8.
20:29:33 <dons> ahunter: they're removed statically
20:29:38 <mauke> cjs_: wrong :-)
20:29:40 <Cale> ahunter: They're a hack
20:29:43 <cjs_> mauke: ok, explain to me what breaks with ts=8 sw=4.
20:29:46 <dons> ahunter: they're of unboxed kind, so can be entirely optimised away
20:29:52 <Cale> ahunter: and yeah, they contain no data
20:29:56 <AMcBain> I guess that error means that I didn't declare my function's parameter's types. Am I right?
20:29:59 <mauke> cjs_: the look of the code, because I use ts=4
20:30:01 <dolio> Huh, Oleg helped write The Reasoned Schemer. I didn't know that.
20:30:11 <EvilTerran> ahunter, RealWorld's a pecularity of GHC's implementation, anyway
20:30:19 <Jedai> AMcBain: You don't need to declare types, they're inferred
20:30:23 <Cale> ahunter: This is just GHC's specific way of implementing the IO monad of course. It could be implemented another way
20:30:31 <AMcBain> Jedai: Then why the error?
20:30:32 <Jedai> AMcBain: Which error ?
20:30:35 <AMcBain>  Couldn't match expected type `(a -> IO ()) -> t1 -> t'
20:30:35 <AMcBain>            against inferred type `IO ()'
20:30:49 <AMcBain> All I have are print statements inside the function.
20:30:54 <mauke> cjs_: if your code assumes a fixed number of spaces per tab, you might as well use spaces instead
20:30:56 <ahunter> right, thanks, just confirming what I had inferred by some statements in a paper
20:30:58 <cjs_> mauke: yes, but then your layout can easily break, because ghc won't see the same indentation you're seeing.
20:31:05 <EvilTerran> AMcBain, it means you're using something of type "IO ()" (ie, not a function) where it wants a "(a -> IO ()) -> t1 -> t"
20:31:09 <Jedai> You're doing something wrong
20:31:09 <Cale> AMcBain: print is a function which takes a value and produces an action for printing that value on the screen
20:31:13 <Cale> (which is itself a value)
20:31:14 <mauke> cjs_: the only reason to use tabs for indentation is to make the indentation customizable
20:31:16 <EvilTerran> AMcBain, check your parentheses and your indentation
20:31:23 <cjs_> mauke: it's not a fixed number of spaces per tab. It's a fixed column multiple.
20:31:32 <mauke> same thing
20:31:32 <Cale> AMcBain: You might want to read by very quick intro to IO in Haskell
20:31:35 <Cale> my*
20:31:43 <ddarius> ahunter: Note, that that is just how GHC implements IO.  Other implementations use other approaches.
20:31:48 <Cale> http://www.haskell.org/haskellwiki/Introduction_to_IO
20:31:49 <lambdabot> Title: Introduction to IO - HaskellWiki
20:31:50 <EvilTerran> ?go monads don't-care
20:31:54 <lambdabot> http://sigfpe.blogspot.com/2007/11/io-monad-for-people-who-simply-dont.html
20:31:54 <lambdabot> Title: A Neighborhood of Infinity: The IO Monad for People who Simply Don't Care
20:32:13 <Cale> We don't need to explain monads :)
20:32:15 <mauke> if you assume fixed anything for tabs, just set expandtab and be done
20:32:15 <cjs_> mauke: anyway, I think you're right about using spaces instead of tabs if you use ts=8. Though some edits are easier if the tabs are there. (Midline tab ones.)
20:32:17 <Cale> (just the IO monad)
20:32:31 <mauke> I never use tabs in the middle of a line
20:32:33 <EvilTerran> AMcBain, i found that "din't care" link to be quite helpful if you just want to get on with it
20:32:39 <cjs_> Ha! Success! I got this whole high-flauting channel arguing about spaces versus tabs!
20:32:51 <mauke> I think it's just me
20:33:03 <cjs_> But nobody's mentioned Hitler yet. Darn.
20:33:15 <AMcBain> You just did.
20:33:35 <cjs_> Doesn't count for the prize. I need to incite someone else to do it.
20:33:38 <AMcBain> Lovely. I think the error arose because I did '=\n    print(len)\n    print(value)' how can I make that work.
20:33:40 <EvilTerran> it doesn't count if you mention it on purpose
20:33:51 <EvilTerran> AMcBain, stick "do" after the "="
20:33:59 <AMcBain> oh
20:33:59 <ddarius> EvilTerran: How do you accidentally mention Hitler?
20:34:05 <EvilTerran> and get rid of those parentheses, you don't need them
20:34:14 <Cale> AMcBain: maybe form a do-block for it?
20:34:24 <EvilTerran> ddarius, don't ask me. fundies manage, though.
20:34:29 <AMcBain> do { print ; print }?
20:34:38 <Cale> do { print foo; print bar }
20:34:39 <EvilTerran> AMcBain, did you see that link? it'd really help, i think
20:34:48 <Cale> (or my Introduction to IO link)
20:34:58 <mauke> cjs_: to be honest, I use expandtab for haskell code now, but I still write code as if using variable-width tabs for indentation
20:34:58 <EvilTerran> main = do
20:35:01 <EvilTerran>     print len
20:35:03 <EvilTerran>     print value
20:35:24 <pantsd_> question: What libraries do people recommend for bayes classification?
20:35:26 <AMcBain> Well the {} would make me happy.
20:35:28 <EvilTerran> (or not main. whatever the function's called.)
20:35:44 <EvilTerran> you can use 'em explicitly if you like
20:35:46 <Cale> AMcBain: braces and semicolons are always optional in Haskell
20:35:49 <ddarius> :set expandtab :set ai
20:35:53 <gwern> pantsd_: are there any? I guess you'd need more than one to be able to make reccomendations
20:35:57 <AMcBain> Cale: I noticed.
20:36:06 <mauke> ddarius: exactly
20:36:08 <EvilTerran> the report defines layout in terms of adding {};s to indented code
20:36:26 <AMcBain> Yes.
20:36:38 * EvilTerran switches off this monitor and goes to bed
20:36:40 <AMcBain> Well I just removed them anyways ...
20:36:44 <ddarius> EvilTerran: Good idea
20:37:10 <EvilTerran> what, sleep? yeah, seeing as it's 03:40 over here.
20:37:14 <EvilTerran> =/
20:37:18 <pantsd_> gwern: I've found ~2 using google (circa 05)
20:37:27 <EvilTerran> g'night folks. don't tear the place apart while i'm away. :P
20:37:42 <atp> 3:40am? wow, i'm at work by then
20:37:49 <atp> obviously we have different schedules
20:38:44 <gwern> pantsd_: really? links pls
20:39:47 <AMcBain> Okay, so as to typing, Haskell doesn't really care about the type of the variable as long as I am consistent everywhere? (relative to that variable) ... Meaning that all my Scheme code is good because I don't expect any variable to be any other type than what I need?
20:39:59 <AMcBain> originally needed*
20:40:23 <koninkje> AMcBain: Even though braces and semicola are optional in Haskell, the whitespace sentitivity gets cranked up to 11 when you use the 'do' notation so I highly recommend using them there
20:40:29 <mauke> pretty much :-)
20:40:38 <dons> acura: that kind of makes sense, yeah :)
20:40:41 <dons> AMcBain: ^
20:40:49 <AMcBain> Wha?
20:40:57 <dons> as long as you don't go treating ints as strings or what have you
20:41:01 <dons> or lists as  trees
20:41:06 <AMcBain> No, I meant to koninkje
20:41:07 <Cale> koninkje: hm? I've never thought of it as any more whitespace sensitive as anything else...
20:41:15 <mauke> haskell automatically determines the types of everything based on how you use it
20:41:41 <AMcBain> So does JS, but that leads to lots of quirky things :) Which I readily "abuse".
20:41:42 <Cale> koninkje: I suppose you need to indent if-then-else correctly inside of a do-block, while you don't have to if it's just on the rhs of a definition
20:41:49 <koninkje> AMcBain: Oh I was just saying that using braces and semicolons is a Good Idea(tm) with the 'do' notation.
20:42:05 <AMcBain> When in Rome ...
20:42:16 <Cale> AMcBain: in contrast to JS, Haskell determines the types of everything at compile time
20:42:18 <koninkje> Cale: there are all sorts of places it breaks (embedded if-then-else, embedded do,...)
20:42:35 <Cale> koninkje: So everything is still statically typed, it's just that the types are inferred.
20:42:37 <koninkje> everywhere else the whitespace sensitivity is sane though
20:42:53 <mauke> how does embedded do break?
20:42:59 <gwern> AMcBain: haskell tries to be as consistent as possible within the strictures of your type sigs and the known type sigs of functions you invoke
20:43:03 <ddarius> koninkje: The rules are consistent.  They only "break" if you are expecting an inconsistency.
20:43:07 <AMcBain> Cale: Well with that obvious distinction, yes. I thought about making a string based Scheme interpreter in JS, but having ot do other homework put and end before I started.
20:43:13 <gwern> AMcBain: sometimes your code will try to do things that the library code says it shouldn't be doing, or your code doesn't contradict other bits of your code (like, say explicit type sigs), things should be fine
20:43:44 <Jedai> AMcBain: There's no quirky thing with Haskell, if it compiles it will work, meaning you can have an error of logic in your code but it won't break
20:43:53 <AMcBain> My Scheme program only used lists and ints, and I always kept the same types for each parameter.
20:44:00 <AMcBain> (afaik)
20:44:05 <atp> scheme -> haskell (or vice versa) will be sort of weird because of lazy evaluation though
20:44:13 <atp> (nothing to do with type checking of course)
20:44:16 <dolio> ddarius: do-if-then-else is a bit cryptic when you first encounter it.
20:44:25 <dolio> Then again, I've come to like indenting then and else more all the time.
20:45:17 <gwern> haskell -> scheme doesn't sound too hard, but I wouldn't look forward to see futures or lazy lambdas littered all over the place in the generated code
20:45:28 <Cale> I've always thought the standard indentation of if-then-else in Haskell was much saner than what they typically use in C and Java, etc.
20:46:02 <atp> gwern: yeah, there would be lots of delay/promise stuff most likely
20:46:02 <Jedai> This game is really simple, in my solution, I just used Array for the Board and a list monad for the exploration of the solution space
20:46:42 <atp> gwern: but i meant more from an idiomatic perspective... eager functional languages use tail recursion a lot, and so they do a lot of left folding... whereas in a lazy context right folding is often much more intuitive
20:46:50 <zooko> yitz: what was your startup years ago?
20:46:53 <atp> stuff like that...
20:46:56 <AMcBain> I haven't even got farther than defining the names of a few functions from my Scheme program and someone else already has another solution! grrrrr.
20:47:06 <zooko> I, too, worked at a startup doing stuff like that years ago.  ;-)
20:47:26 <Jedai> AMcBain: But I have two years of experience with Haskell...
20:47:26 <AMcBain> Now, how can I do the equivalent to a named let? Like "(let (i size) ..." ?
20:47:39 <mauke> let i = size in ...
20:47:47 <mauke> or just let i = size; if you're in a do block
20:47:51 <atp> the only thing about haskell syntax that still annoys me is minus' dual role as negate and subtract
20:47:53 <solrize> amcbain do you think of reading one of the tutorials?
20:47:58 <AMcBain> Jedai: Still it's something I'd rather not hear at this point ...
20:48:14 <AMcBain> solrize: I have one open and jump around as needed. (Haskell.pdf, wikibook)
20:48:20 <solrize> oh cool
20:48:36 <solrize> it sounds like you might want something more introductory though
20:48:40 <Jedai> AMcBain: Don't worry, and just translate your Scheme program first, you can refactor later
20:48:48 <gwern> AMcBain: a where clause mebbe
20:48:54 * gwern likes where better than let
20:49:08 <mauke> where is not always appropriate
20:49:13 <yitz> zooko: yes, 4 or 5 yrs ago
20:49:16 <AMcBain> "let i = size in" how do I name it? "let i = size in loop"?
20:49:19 * Jedai like where too
20:49:36 <mauke> e.g. when your definition depends on variables bound in a do block
20:50:14 <Jedai> mauke: Yep, and "let ... in ..." is a real expression, whereas "where" can only be used at declaration level
20:50:36 <Jedai> mauke: But where I have a choice, I prefer where :-P
20:50:40 <zooko> yit: what was it called?
20:50:43 <AMcBain> Yes, but does putting "loop" after "in" let me name it so I can call it from inside it?
20:50:59 <zooko> I was working on Mojo Nation 4 or 5 years ago, which is the great grand uncle of allmydata.org "Tahoe", the Least-Authority Filesystem.
20:51:01 <solrize> amcbain lets can be recursive you don't need letrec
20:51:04 <mauke> AMcBain: huh?
20:51:10 <Cale> AMcBain: name what?
20:51:33 <AMcBain> My Scheme used a "named let" so I could define some variables initially, then call it recursively ...
20:51:38 <Jedai> AMcBain: I don't even understand what you're trying to do...
20:51:44 <solrize> cale he  is asking if    "let foo n = foo(n-1) + foo(n-2) ..." is allowed
20:51:52 <solrize> like letrec in scheme
20:51:53 <Cale> oh
20:52:01 <solrize> at least i think that was the question
20:52:03 <mauke> solrize: are you sure?
20:52:04 <AMcBain> "(let loop (i size) (loop (+i 1)))
20:52:06 <Cale> Right, all lets in Haskell are potentially recursive.
20:52:07 <AMcBain> "
20:52:26 <AMcBain> That is what I mean.
20:52:29 <Cale> > let evens = 0 : map (+1) odds; odds = map (+1) evens in evens
20:52:29 <lambdabot>  [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
20:53:08 <AMcBain> Wha? Can I get it without that mysterious "map" keyword ...
20:53:11 <mauke> *** ERROR: Compile Error: syntax-error: malformed let: (let loop (i size) (loop (0.0+1.0i 1)))
20:53:18 <mauke> also, 'map' is not a keyword
20:53:25 <solrize> map is just like in scheme
20:53:28 <Jedai> AMcBain: map is just a function
20:53:28 <AMcBain> Ugh. I sound so stupid on this channel.
20:53:28 <solrize> mapcar
20:53:54 <solrize> map (*2) [1,2,3,5,10,15]
20:53:57 <solrize> > map (*2) [1,2,3,5,10,15]
20:53:58 <lambdabot>  [2,4,6,10,20,30]
20:54:09 <AMcBain> mauke: What is that error from? The let I pasted should have worked in Scheme ...
20:54:27 <mauke> AMcBain: a scheme interpreter called gosh
20:54:29 <solrize> that didn't look like valid scheme
20:54:31 <Jedai> AMcBain: I don't see how...
20:54:47 <mauke> Gauche scheme interpreter, version 0.8.11 [utf-8,pthreads]
20:54:59 <Jedai> AMcBain: It don't make sense, and this is not correct syntax for let
20:55:11 <solrize> although my scheme memory is weak and i get its syntax confused with other lisps
20:55:14 <AMcBain> I used Dr. Scheme with SR5 ...
20:56:15 <AMcBain> (let loop ((i 0)) (if (< i 10) i (loop (+ i 1)))) should be a better example.
20:56:19 <Jedai> AMcBain: Normally let syntax is (let (bindings) body)
20:56:33 <solrize> oh i see.
20:56:36 <AMcBain> (assuming that I have correct parenthesis)
20:56:44 <mauke> that returns 0
20:56:53 <AMcBain> Should be >
20:56:56 <AMcBain> Hehe
20:56:57 <solrize> hmm
20:57:05 <solrize> i think you want a lambda in there?
20:57:08 <AMcBain> Nope.
20:57:16 <AMcBain> It works as is, in Dr Scheme.
20:57:22 <solrize> hmm
20:57:25 <AMcBain> Syntactic sugar, sure, but ...
20:57:28 <AMcBain> :)
20:57:50 <Jedai> AMcBain: Why not use define ? It's its normal role
20:57:56 <solrize> what is the result of that let in drscheme?
20:58:15 <AMcBain> If I had used > instead of < it should produce 11 I think. One sec.
20:58:37 <AMcBain> Yes, 11.
20:59:17 <solrize> > let loop i = if (i<10) then i else loop (i+1) in loop 0
20:59:20 <Jedai> I don't like this syntactic sugar at all... It confounds two thing, definition and call
20:59:23 <lambdabot>  0
20:59:33 <AMcBain> You need to make it >
20:59:38 <Jedai> > let loop i = if (i > 10) then i else loop (i+1) in loop 0
20:59:38 <solrize> > let loop i = if (i>10) then i else loop (i+1) in loop 0
20:59:40 <lambdabot>  11
20:59:40 <lambdabot>  11
20:59:47 <solrize> these go to 11 :)
20:59:51 <AMcBain> Hah!
20:59:59 <AMcBain> :)
21:00:30 <mauke> > let loop = max 11 in loop 0
21:00:31 <lambdabot>  11
21:00:37 <mauke> OPTIMIZED
21:00:51 <AMcBain> Anyways, I think now look at it, I don't see when I really used that let ... there are at least a few places where I could have just recursively called the function itself. I only see one case where I actually needed one.
21:01:15 <solrize> > head (dropWhile (< 10) [0..])
21:01:16 <AMcBain> Okay, more than one, but still.
21:01:16 <lambdabot>  10
21:02:04 <solrize> amcbain in haskell you generally don't have to use recursion very much.  generally when you want to do something repeatedly it turns out you really want to map or fold over some structure
21:02:15 <solrize> fold is what a lisper would call "reduce"
21:02:42 <AMcBain> Yes, but I need to convert all my recursive functions, and I'm certainly not going to drop everything to try to pick up something I hardly understand.
21:03:04 <solrize> you can generally write scheme the same way
21:03:55 <AMcBain> We weren't taught map. We were supposed to follow the ideas of functional programming which involves recursion. (opinions excluded)
21:04:06 <solrize> well ok
21:04:22 <solrize> if the exercise is to write out the recursion explicitly then of course you have to do that
21:04:34 <solrize> @src map
21:04:34 <lambdabot> map _ []     = []
21:04:34 <lambdabot> map f (x:xs) = f x : map f xs
21:04:39 <solrize> @src foldl
21:04:39 <lambdabot> foldl f z []     = z
21:04:39 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
21:04:54 * AMcBain *cringes*
21:04:58 <solrize> those functions just abstract away the recursion conveniently
21:05:18 <AMcBain> You don't know how badly I just want to give up ...
21:05:19 <solrize> you understand that map just applies the function to each element of a list?
21:05:25 <solrize> > map sqrt [1,2,3,4,5]
21:05:26 <lambdabot>  [1.0,1.4142135623730951,1.7320508075688772,2.0,2.23606797749979]
21:05:35 <AMcBain> But that's not what I need.
21:05:44 <Cale> Recursion actually isn't really in the spirit of functional programming, even though at some low level it's what's used to bootstrap things. Really we use higher-order functions.
21:05:54 <cjs_> Can someone explain this to me?
21:06:08 <solrize> oh ok, i just thought that explanation might help you uncringe from seeing the code for map ;)
21:06:13 <cjs_> > floatToDigits 10 0.2
21:06:14 <lambdabot>  ([2],0)
21:06:41 <Cale> > floatToDigits 10 pi
21:06:42 <lambdabot>  ([3,1,4,1,5,9,2,6,5,3,5,8,9,7,9,3],1)
21:07:02 <Cale> > floatToDigits 2 pi
21:07:02 <solrize> :t floatToDigits
21:07:04 <lambdabot>  ([1,1,0,0,1,0,0,1,0,0,0,0,1,1,1,1,1,1,0,1,1,0,1,0,1,0,1,0,0,0,1,0,0,0,1,0,0,...
21:07:06 <lambdabot> forall a. (RealFloat a) => Integer -> a -> ([Int], Int)
21:07:16 <AMcBain> Unscringe? No. You would need to tell me I'm allowed to do this in JS or Java to do that, which defeats the purpose of the class, and would make the professor feel he failed in teaching me. I certainly don't want to pull nothing out of this class.
21:07:41 <AMcBain> Even if it means not quitting and getting this into Haskell.
21:08:08 <solrize> amcbain you're doing ok, haskell has a very steep learning curve compared with other languages.  are you generally comfortable with scheme so far?
21:08:58 <AMcBain> Hell yea. I can pretty much do what I need via recursion and functions, assuming I give it enough thought and find appropriate helper functions to reduce syntax (cadr, etc(
21:09:21 <solrize> amcbain that stuff is a lot easier in haskell
21:09:24 <AMcBain> I tend not to want to give it enough thought sometimes ...
21:09:59 <solrize> let (a:b:rest) = [1,2,3,4,5]  in b
21:10:02 <solrize> > let (a:b:rest) = [1,2,3,4,5]  in b
21:10:04 <lambdabot>  2
21:10:10 <AMcBain> (mainly because I think if I can finish early, I can go back into my comfort zone, which is not what I need to do)
21:10:12 <solrize> you can pattern match like that instead of messing with kludges like cadr
21:10:42 <svat> > b where a:b:rest = [1,2,3,4,5]
21:10:42 <lambdabot>  Parse error at "where" (column 3)
21:10:47 <svat> why doesn't that work?
21:11:02 <Cale> svat: because 'where' isn't an expression form
21:11:08 <solrize> maybe you're trying to absorb too many things at once and that's making it hard
21:11:09 <Cale> svat: It's part of the syntax of declarations
21:11:27 <AMcBain> But that isn't why I used Cadr, I'm not trying to find a "2" in a list, I'm trying to find the value at position 2 or other things that I can easily get with recursion.
21:11:58 <Cale> svat: that is to say, when you write something like:
21:12:03 <Cale> foo = bar^2
21:12:06 <Cale>   where bar = 5
21:12:12 <Twey> solrize: Eh
21:12:16 <solrize> oh i see, something like
21:12:18 <Cale> the 'where' is attached to the definition of 'foo'
21:12:24 <Cale> not to the expression bar^2
21:12:26 <AMcBain> Is it = or == in haskell?
21:12:39 <Cale> AMcBain: == for equality testing,  = for definition
21:12:43 <AMcBain> Okay.
21:13:02 <Twey> solrize: takeUntil f = head . (dropWhile f)
21:13:12 <svat> Cale: right, thanks.
21:13:12 <solrize> > let f n list =  if n==0 then (head list) else f (n-1) (tail list)   in   f 3  [1,2,3,4,5,6]
21:13:14 <lambdabot>  4
21:13:34 <Twey> @pl \a b c -> a . (b c)
21:13:34 <lambdabot> (.) . (.)
21:13:42 <svat> AMcBain: solrize's earlier example *was* to show you how to get the element at position 2. (Where 2 is a small number.)
21:13:44 <Twey> Oops
21:14:06 <Twey> @pl \x -> a . (b x)
21:14:06 <lambdabot> (a .) . b
21:14:08 <solrize> the second example was how to do it recursively with head and tail (which are like car and cdr)
21:14:26 <AMcBain> How do I return a value? Just state it? (Like Scheme)
21:14:28 <svat> > let a:b:rest = [10, 20, 30, 40, 50] in b
21:14:29 <lambdabot>  20
21:14:35 <mauke> AMcBain: yes
21:14:35 <ahunter> http://hpaste.org/6651  I
21:14:38 <Cale> AMcBain: yeah, just state it.
21:14:52 <Cale> AMcBain: the right hand side of an = is required to be an expression having a value
21:14:54 <ahunter> '*I'm quite positive I can clean that by introducing a monad transformer for Random but I'm very shaky on how that works--can anyone help me?
21:14:58 <mauke> there is no 'return' keyword like in java
21:15:10 <mauke> (there's a return function but it does something completely different)
21:15:15 <AMcBain> That's what I figured.
21:16:16 <yitz> > let c = b where { _:b:_ = [10, 20 .. 50] } in c
21:16:16 <lambdabot>  20
21:17:55 <AMcBain> "listofsize size 0 . loop i-1"? I need to do the equivalent of (cons (listofsize size 0) (loop (- i 1)))
21:18:06 <AMcBain> Oops, : not .
21:18:52 <solrize> whats listofsize?
21:18:57 <mauke> listofsize size 0 : loop (i - 1)
21:19:18 <mauke> or ((:) (listofsize size 0) (loop ((-) i 1))) if you like that syntax
21:19:27 <AMcBain> ick
21:19:28 <solrize> mauke arggh
21:19:30 <Cale> hmm
21:19:52 <svat> AMcBain: Haskell's empty list is called "[]", but your "listofsize" is probably something else?
21:20:08 <AMcBain> listofsize is a recursive function to generate a list of a given size filled with that value. In this case, I'm wiling to drop the recursion for some crafty stuff I see involving [3..]
21:20:10 <mauke> I suspect it's replicate
21:20:14 <Cale> > replicate 10 0
21:20:15 <lambdabot>  [0,0,0,0,0,0,0,0,0,0]
21:20:23 <AMcBain> Or that.
21:20:39 <yitz> > replicate 3 (replicate 3 0)
21:20:40 <lambdabot>  [[0,0,0],[0,0,0],[0,0,0]]
21:20:51 <AMcBain> No, I ... Ooooo!
21:20:57 <bd_> > replicateM 8 "01"
21:20:57 <AMcBain> Me likey.
21:20:58 <lambdabot>  ["00000000","00000001","00000010","00000011","00000100","00000101","00000110...
21:21:07 <AMcBain> Not so much that one.
21:21:17 <bd_> :D
21:21:30 <AMcBain> Hm, I can completely remove listofsize!
21:21:34 <Cale> That one can wait ;)
21:21:40 <mauke> listofsize = replicate
21:21:41 <solrize> bd_:  auggggggggghhhhhhhhhh
21:21:47 <bd_> solrize: m?
21:21:52 <yitz> @let allsol size = replicate size . replicate size
21:21:57 <lambdabot> Defined.
21:22:27 <yitz> > allsol 3 0
21:22:27 <lambdabot>  [[0,0,0],[0,0,0],[0,0,0]]
21:22:31 <yitz> allsol 3 1
21:22:41 <yitz> > allsol 3 1
21:22:41 <lambdabot>  [[1,1,1],[1,1,1],[1,1,1]]
21:22:52 <AMcBain> Yes, that is what I intend to do, is convert the two function into one.
21:23:17 <bd_> > transpose $ replicateM 4 "01"
21:23:18 <lambdabot>  ["0000000011111111","0000111100001111","0011001100110011","0101010101010101"]
21:23:46 <solrize> stop that :)
21:23:49 <yitz> I left off the last param of replicate, making it a function, so I could use it twice using the composition operator "."
21:24:22 <Cale> heh, that's awesome :)
21:24:23 <bd_> solrize: :)
21:24:28 <Cale> (the transpose trick :)
21:24:43 <AMcBain> Reason for that? What was wrong with the nested replicate?
21:24:58 <Cale> AMcBain: they're just off on a tangent
21:25:38 <AMcBain> Go figure. Do it one way, and everyone has a different way of doing it. heh, I would probably be doing the same thing, in the channel of the language of my choice :)
21:25:42 <Cale> AMcBain: replicateM is a funky generalisation of replicate, and in a particular specialisation, lets you construct all the words on an alphabet of a given length
21:26:03 <ahunter> @src randT
21:26:03 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
21:26:07 <ahunter> @src RandT
21:26:07 <lambdabot> Source not found. That's something I cannot allow to happen.
21:26:10 <ahunter> @src RandomT
21:26:10 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
21:26:16 <mauke> > replicateM 3 ".-"
21:26:17 <lambdabot>  ["...","..-",".-.",".--","-..","-.-","--.","---"]
21:26:19 <Cale> ahunter: It's not in the libraries.
21:26:35 <ahunter> Cale: Oh hell, I'd have to write my own?
21:26:39 <svat> AMcBain: nothing, it's just a "pointfree" thing. You can write "allsol size x = replicate size (replicate size x), but it often feels nice to "cancel" and remove arguments from the definition :)
21:26:53 <Cale> ahunter: You might be able to get it from hackage
21:26:56 <bos> ahunter: hackage
21:27:00 <Cale> ahunter: and it's also on the wiki
21:27:21 <bd_> > join (liftM (.)) replicate 4 " "
21:27:22 <lambdabot>      Occurs check: cannot construct the infinite type:
21:27:22 <lambdabot>       m = (->) (m (a -...
21:27:24 <bd_> hmm
21:27:30 <bd_> > join (liftM2 (.)) replicate 4 " "
21:27:30 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
21:27:30 <lambdabot>       Expected...
21:27:32 <bd_> bah
21:27:44 <dons> ?users
21:27:44 <lambdabot> Maximum users seen in #haskell: 472, currently: 425 (90.0%), active: 19 (4.5%)
21:28:49 <yitz> AMcBain: let's do your "redefine" and "change":
21:28:57 <yitz> first of all-
21:29:03 <AMcBain> Okay, I guess. I have offsol and onsol done now.
21:29:14 <yitz> > splitAt 3 [1..10]
21:29:15 <lambdabot>  ([1,2,3],[4,5,6,7,8,9,10])
21:29:34 <yitz> > const 5 "whatever you want"
21:29:35 <lambdabot>  5
21:30:05 <svat> @src const
21:30:05 <lambdabot> const x _ = x
21:30:10 <AMcBain> Well, how about this: Can we do get next instead?
21:30:27 <yitz> ok, now for redefine, instead of plugging in a val, we'll apply a function to that element. So in particular, you can use const to set it to a value.
21:30:54 <AMcBain> You totally lost me.
21:31:33 <yitz> ok, sorry. Your redefine changes an element to a specific value, right?
21:32:07 <AMcBain> Yes. It does what set! would do if I hadn't avoided it.
21:33:01 <yitz> So I'm suggesting something slightly more general - instead of throwing away the old value, we'll apply a second function to it. You can pass in any function you want as the second function, so in particular you can use it to throw away the value as before. Watch:
21:33:42 <yitz> @let redefine f i xs = let (h, t:ts) = splitAt i xs in h ++ f t : ts
21:33:43 <lambdabot> <local>:2:61:     Occurs check: cannot construct the infinite type: a = [a]  ...
21:33:47 <yitz> oops
21:33:59 <AMcBain> So essentially we are making a function that can take another function and to something to the index we desire? Such as flip it from 0 to 1 and back as later needed?
21:34:15 <AMcBain> s/and/to do/
21:34:25 <lispy> gwern: I don't see anything wrong with autoproc, I actually was surprised to see it's not on hackage yet
21:35:22 <yitz> @let redefine f i xs = let { (h, t:ts) = splitAt i xs } in h ++ f t : ts
21:35:23 <lambdabot> <local>:2:65:     Occurs check: cannot construct the infinite type: a = [a]  ...
21:35:24 <Jedai> AMcBain: Yes, that's it
21:35:27 <mauke> @undefine
21:35:28 <lambdabot> Undefined.
21:35:37 <mauke> @let redefine f i xs = let (h, t:ts) = splitAt i xs in h ++ f t : ts
21:35:37 <yitz> @let redefine f i xs = let (h, t:ts) = splitAt i xs in h ++ f t : ts
21:35:37 <lambdabot> <local>:1:61:     Occurs check: cannot construct the infinite type: a = [a]  ...
21:35:38 <lambdabot> <local>:1:61:     Occurs check: cannot construct the infinite type: a = [a]  ...
21:35:46 <yitz> @undefine
21:35:46 <lambdabot> Undefined.
21:35:48 <mauke> what the
21:36:04 <Jedai> @let redefine f i xs = let (h, t:ts) = splitAt i xs in h ++ (f t : ts)
21:36:04 <lambdabot> Defined.
21:36:13 <yitz> ok, thanks :)
21:36:26 <mauke> Cale!
21:36:32 <yitz> anyway, look at that for a moment.
21:36:44 <gwern> lispy: oh. I'm not yet really done. I think Config (the environmental variables) needs to be reworked
21:36:54 <Cale> mauke: hm? Oh, did I forget an infix declaration?
21:36:58 <gwern> and I haven't tested it by moving my own procmailrc into it
21:37:13 <yitz> let's try it:
21:37:23 <AMcBain> yitzL Can't we make it any simpler? I bet I could modify my recursive one to do this, but I don't think that's what you're trying to do ...
21:37:30 <AMcBain> s/L/:/
21:37:31 <mauke> Cale: I think so
21:37:32 <yitz> > redefine (+5) 3 [1..10]
21:37:33 <lambdabot>  [1,2,3,9,5,6,7,8,9,10]
21:37:46 <yitz> i know. you'll see in a minute
21:37:49 <yitz> see how it works?
21:37:54 <Cale> @undefine
21:37:54 <lambdabot> Undefined.
21:37:57 <AMcBain> Well yes, I get that part.
21:37:58 <Cale> @let redefine f i xs = let (h, t:ts) = splitAt i xs in h ++ f t : ts
21:37:59 <lambdabot> Defined.
21:38:03 <Cale> there we go :)
21:38:07 <yitz> thanks Cale!
21:38:58 <yitz> ok, the point is that now we can use redefine to create "change". the idea is - pass redefine to itself as the function
21:39:08 <Cale> Oh, and I just realised we'd have a similar problem with (.), so that'll be fixed on the next undefine as well.
21:39:47 <mauke> but . is associative, no?
21:39:51 <lispy> gwern: ah
21:40:00 <AMcBain> yitz: Sure.
21:40:06 <Cale> yeah, it is
21:40:07 <mauke> oh, in conjunction with other operators
21:40:10 <Jedai> @let change (x,y) f = redefine (redefine f y) x
21:40:11 <lambdabot> Defined.
21:40:14 <Cale> right
21:40:32 <lispy> :t redefine
21:40:33 <lambdabot> forall a. (a -> a) -> Int -> [a] -> [a]
21:40:48 <Cale> :t change
21:40:49 <lambdabot> forall a. (Int, Int) -> (a -> a) -> [[a]] -> [[a]]
21:41:12 <lispy> > redefine (+1) 4 [1..3]
21:41:13 <lambdabot>  Exception: <local>:1:22-45: Irrefutable pattern failed for pattern (h, t : ts)
21:41:19 <Jedai> change (1,1) not (replicate 3 (replicate 3 False))
21:41:25 <Jedai> > change (1,1) not (replicate 3 (replicate 3 False))
21:41:26 <lambdabot>  [[False,False,False],[False,True,False],[False,False,False]]
21:41:37 <yitz> > change (2,3) (+7) (replicate 3 (replicate 3 0))
21:41:37 <lambdabot>  Exception: <local>:1:22-45: Irrefutable pattern failed for pattern (h, t : ts)
21:41:53 <yitz> > change (1,2) (+7) (replicate 3 (replicate 3 0))
21:41:54 <lambdabot>  [[0,0,0],[0,0,7],[0,0,0]]
21:42:11 <lispy> > redefine (+1) 2 [1..3]
21:42:12 <lambdabot>  [1,2,4]
21:42:16 <lispy> Oh
21:42:23 <lispy> It applies the function at the index?
21:42:31 <Cale> lispy: right
21:42:32 <yitz> lispy: yep
21:43:25 <lispy> applyAt seems like a bit better name :)
21:43:31 <yitz> lispy: and change does the same thing in 2 dimensions
21:43:53 <yitz> (and now, Oleg, generalize that using type classes...)
21:44:09 <yitz> lispy: agreed
21:44:12 <lispy> :t (+1) `redefine` 3
21:44:13 <lambdabot> forall a. (Num a) => [a] -> [a]
21:44:31 <lispy> the way that reads, I don't expect it to work like it does
21:45:23 <lispy> and it should probably return Maybe
21:45:43 <yitz> ok, we'll let AMcBain work out exactly what's best. I was just trying to follow more or less the original Scheme.
21:46:04 <lispy> okies, I was just picking some nits
21:46:17 <yitz> lispy: in general, Maybe would be good, but it's not need for this particular problem (except for robustness)
21:46:33 <yitz> trying to keep it simple.
21:46:38 <lispy> yeah, who cares about robustness :)
21:47:04 <Jedai> lispy: The students do not
21:47:16 <svat> is it possible to remove the "point" in square n = replicate n . replicate n?
21:47:27 <yitz> AMcBain: how are you doing over there?
21:47:33 <AMcBain> Working.
21:47:37 <lispy> ?unpl \n -> replicate n . replicate n
21:47:37 <mauke> svat: it's always possible
21:47:37 <lambdabot> \ n c -> replicate n (replicate n c)
21:47:42 <yitz> ok
21:47:45 <Jedai> @pl \n -> replicate n . replicate n
21:47:46 <lambdabot> liftM2 (.) replicate replicate
21:47:48 <yitz> good sign
21:47:57 <ddarius> Damn @pl
21:48:10 <ddarius> join (liftM2 (.)) replicate
21:48:12 <lispy> :t \n -> join (replicate n)
21:48:13 <lambdabot>     Couldn't match expected type `(->) a' against inferred type `[]'
21:48:13 <lambdabot>     Probable cause: `replicate' is applied to too many arguments
21:48:13 <lambdabot>     In the first argument of `join', namely `(replicate n)'
21:48:20 <lispy> oh, that's what I meant
21:48:29 <mauke> ddarius: the replicates have different types
21:48:40 <ddarius> kuso!
21:49:49 <lispy> svat: there is even a name for removing that point, I think it's eta-expansion
21:49:54 <yitz> > let square n = replicateM 2 . replicate n in square 2 7
21:49:56 <lambdabot>  [[7,7],[7,7],[7,7],[7,7]]
21:50:04 <yitz> urgh
21:50:37 <yitz> > let square n = replicate 2 . replicate n in square 2 7
21:50:39 <lambdabot>  [[7,7],[7,7]]
21:50:43 <yitz> > let square n = replicate 2 . replicate n in square 3 7
21:50:44 <lambdabot>  [[7,7,7],[7,7,7]]
21:50:49 <yitz> nope
21:51:07 <ddarius> > let square n = sequence . replicate n in square 3 7
21:51:07 <lambdabot>   add an instance declaration for (Num (m a))
21:51:18 <solrize> oh stop torturing poor AMcBain
21:52:11 <yitz> solrize, it's ok, i think AMcBain has got it
21:52:15 <solrize> hehe
21:54:07 <svat> @src liftM2
21:54:08 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
21:54:12 <lispy> if we making doing your homework for you at least as hard to understand as doing it yourself, then people won't use as to get good grades, right? ;)
21:54:13 <yitz> > let square n = sq . replicate n; sq xs = zipWith const xs $ repeat xs in square 3 7
21:54:13 <lambdabot>  [7,7,7]
21:55:00 <lispy> :t \xs -> zipWith const xs $ repeat xs
21:55:09 <lambdabot> forall a. [a] -> [a]
21:55:34 <ddarius> @free zipWith
21:55:35 <lambdabot> (forall x. h . k x = p (f x) . g) => $map h . zipWith k xs = zipWith p ($map f xs) . $map g
21:55:52 <lispy> zipWith const is ... odd
21:56:04 <AMcBain> http://hpaste.org/6652
21:56:14 <ddarius> lispy: How so?
21:56:20 <svat> > let square n = sq . replicate n; sq xs = zipWith const xs $ repeat 42 in square 3 7
21:56:21 <lambdabot>  [7,7,7]
21:56:21 <lispy> ?check \xs ys -> zipWith const xs ys == xs
21:56:24 <lambdabot>  Falsifiable, after 2 tests: [(),()], [()]
21:56:26 <yitz> > let square n = sq . replicate n; sq xs = zipWith const (repeat xs) xs in square 3 7
21:56:27 <lambdabot>  [[7,7,7],[7,7,7],[7,7,7]]
21:56:33 <yitz> ha!
21:56:43 <ddarius> lispy: It's a variant of take that takes the count in unary.
21:57:14 <lispy> ?check \xs ys ===> (length xs < length ys)-> zipWith const xs ys == xs
21:57:14 <lambdabot>  Parse error at "===>" (column 8)
21:57:34 <lispy> what is that syntax again?
21:57:47 <lispy> ddarius: but yeah, i think i see
21:57:50 <dolio> ==>
21:57:50 <ddarius> lispy:  ==> is a normal operator
21:58:22 <lispy> ?check \xs ys -> (length xs < length ys) ==> zipWith const xs ys = xs
21:58:22 <lambdabot>  Parse error at "=" (column 59)
21:58:27 <lispy> ?check \xs ys -> (length xs < length ys) ==> zipWith const xs ys == xs
21:58:28 <lambdabot>  OK, passed 500 tests.
21:58:39 <lispy> ?scheck \xs ys -> (length xs < length ys) ==> zipWith const xs ys == xs
21:58:41 <lambdabot> Done.
21:58:45 <AMcBain> Can anyone explain the error in my paste, other than me just trying to remake my cursive functions again?
21:58:52 <ddarius> > ap (zipWith const) repeat . replicate 3 $ 7
21:58:53 <lambdabot>  [7,7,7]
21:59:24 <lispy> I don't really see it as `take`, beceause it returns the first list
21:59:45 <lispy> it seems like, when length xs < length ys, we can just replace zipWith const xs ys, with xs
21:59:46 <ddarius> flip take then
22:00:04 <lispy> and it's undefined otherwise
22:00:13 <lispy> er wait, not undefined
22:00:22 <AMcBain> Ooo yay. Errors solved with a let.
22:00:40 <ddarius> @check \xs ys -> take (length ys) xs == zipWith const xs ys :: [Int]
22:00:41 <lambdabot>  Couldn't match expected type `[Int]' against inferred type `Bool'
22:00:45 <lispy> > (\xs ys -> zipWith const xs ys == xs) [1..6] [7..9]
22:00:46 <lambdabot>  False
22:00:51 <lispy> > (\xs ys -> zipWith const xs ys) [1..6] [7..9]
22:00:52 <yitz> lispy: yes. zipWith const xs ys means take as many elts of xs as there are in ys.
22:00:52 <lambdabot>  [1,2,3]
22:01:03 <ddarius> @check \xs ys -> take (length ys) xs == zipWith const xs ys
22:01:04 <lambdabot>  OK, passed 500 tests.
22:01:20 <yitz> > zipWith const [1..100] [10,20,30]
22:01:21 <lambdabot>  [1,2,3]
22:01:41 <lispy> yeah, I like take (length ys) xs, much better :)
22:01:56 <ddarius> The zipWith version is lazier
22:02:07 <yitz> what if ys is infinite?
22:03:01 <AMcBain> redefine not in scope!? Come on. I removed the (sol) for testing!
22:03:52 <yitz> AMcBain: Yes, "let" is your friend (or its cousin "where"). no need for "do" here.
22:05:15 <AMcBain> The do is for redefine.
22:05:32 <lispy> ?let takeAsManyFrom = zipWith const
22:05:34 <lambdabot> Defined.
22:05:47 <AMcBain> Now I have some damn type error.
22:05:52 <lispy> > [1..4] `takeAsManyFrom` [1..2]
22:05:53 <lambdabot>  [1,2]
22:06:23 <lispy> there, now i only care that it has a weird name, not a weird definition :)
22:07:03 <AMcBain> Apparently it won't let me do some kind of : with [stuff] to [[stuff]] ...
22:07:36 <svat> I had made up a convention of using _ in names for placeholders. takeAsManyFrom_AsThereAreIn [1..4] [1..2] :)
22:07:41 <lispy> AMcBain: it depends on how many levels of nesting in your list
22:07:45 <lispy> :t (:)
22:07:48 <lambdabot> forall a. a -> [a] -> [a]
22:07:59 <lispy> AMcBain: you see from the type, that it takes an element and puts it on the front of a list
22:08:12 <lispy> AMcBain: so if your list is really a list of lists, then the element must be a list
22:08:22 <AMcBain> "[1,2,3]: [[1],[2]]" works on the command-line
22:08:34 <AMcBain> So I don't see where my code fails ...
22:08:36 <lispy> > [1..3] : [[1..3],[4..6]]
22:08:37 <lambdabot>  [[1,2,3],[1,2,3],[4,5,6]]
22:08:42 <ddarius> svat: Now make a preprocessor for some keyword syntax.
22:09:05 <AMcBain> My code is the same as the paste, with just a let in front of change and loop.
22:09:18 <yitz> AMcBain: I annotated your hpaste. (now why isn't hpaste announcing automatically anymore?)
22:09:24 <AMcBain> I noticed that too.
22:09:26 <ddarius> !paste
22:09:42 <ddarius> That would be because hpaste isn't here.
22:09:52 <yitz> @seen hpaste
22:09:52 <lambdabot> I haven't seen hpaste.
22:09:55 <lispy> No hpaste to see here folks.
22:09:58 <lispy> move along.
22:10:02 <Cale> Who is in charge of that?
22:10:08 <yitz> glguy?
22:10:15 <ddarius> Cale: shapr
22:10:23 <lispy> ?get-shapr
22:10:23 <lambdabot> shapr!!
22:10:47 <AMcBain> What is different (other than syntax) in your annotation?
22:10:54 <Cale> ?get-shapl
22:10:54 <lambdabot> shapr!!
22:10:57 <Cale> heh
22:11:16 <AMcBain> I don't really see a difference (other than the parenthesis around the one thing)
22:11:36 <yitz> I got rid of the "do" - that's for something else, you don't want it here.
22:11:51 <yitz> yeah, I fixed those parens.
22:12:12 <AMcBain> "fixed"? It would've worked otherwise ...
22:12:15 <AMcBain> :P
22:12:50 <Cale> > do x <- [1,2,3]; y <- [4,5]; return (x,y)
22:12:52 <lambdabot>  [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
22:12:55 <Cale> ;)
22:12:55 <lispy> ?got-shapes
22:12:55 <lambdabot> Unknown command, try @list
22:12:57 <lispy> ?got-shape
22:12:57 <lambdabot> shapr!!
22:13:02 <yitz> No, "f head list" mean give head and list as two parameters to f.
22:13:08 <lispy> ?got-shae
22:13:08 <lambdabot> Unknown command, try @list
22:13:08 <AMcBain> oh
22:14:12 <AMcBain> I still get that error ...
22:14:13 <AMcBain> loop list x
22:14:17 <AMcBain> argh.
22:14:20 <AMcBain> damn clipboard
22:14:29 <AMcBain> Occurs check: cannot construct the infinite type: a = [a]
22:14:29 <AMcBain>       Expected type: [[a]]
22:14:29 <AMcBain>       Inferred type: [a]
22:15:01 <yitz> The other thing is that you slipped back into scheme-ish recursion. You can do that (maybe best to for this h/w to get done quickly) but for us that is kind of like goto. You are re-inventing splitAt, basically.
22:15:15 <AMcBain> It says it doesn't like it as part of the first argument as list ...
22:15:20 <AMcBain> s/list/tail
22:15:51 <yitz> your version?
22:16:11 <AMcBain> Yes, but with no lets and a where, using your initialization.
22:16:17 <AMcBain> yitz: Why do you think the paste said "please don't hate me" at the top. I don't get all that fancy shit you have been throwing into the bot all night. I probably never will, so I do recursion.
22:16:41 <yitz> No hate :)
22:17:48 <AMcBain> Okay, I added what I have at the current moment.
22:17:53 <AMcBain> http://hpaste.org/6652#a2
22:17:58 <yitz> > let f x = take 3 x in f (tail [1..50])
22:18:00 <lambdabot>  [2,3,4]
22:18:07 <yitz> > let f x = take 3 x in f tail [1..50]
22:18:08 <lambdabot>  Couldn't match expected type `[a]'
22:18:17 <yitz> see?
22:18:30 <AMcBain> Well yes, but I fixed that error ...
22:18:39 <svat> AMcBain: The idea is that instead of writing your "redefine" function which changes your particular list's (0,1) position, it is actually cleaner to write a function that changes an arbitrary position in an arbitrary list of lists in an arbitrary way, and then apply that function to your case.
22:18:53 <yitz> ok. what didn't it like?
22:18:54 <AMcBain> That's what I'm doing ...
22:19:37 <AMcBain> Okay putting (tail list) doesn't fix it either ...
22:19:45 <AMcBain> (the paste doesn't have parens)
22:19:46 <solrize> could you add a comment saying what the function does and giving an example or two?
22:19:57 <solrize> a type signature is generally also considered nice
22:20:01 <AMcBain> Well in a bit ...
22:20:12 <AMcBain> I code comment when I finish it ...
22:20:31 <svat> That... isn't the best idea :)
22:20:33 <solrize> a lot of times in haskell, if you write the type signature first, the code sort of writes itself
22:21:12 <AMcBain> I was told I didn't need to specify parameter types. Can't you all AGREE!?
22:21:29 <solrize> it's not required by the language, it's just helpful to readers, like code comments
22:21:32 <yitz> svat: remember, AMcBain's primary goal is to translate his scheme code into Haskell word for word - the fastest way to get his homework done. We are very gingerly trying to help him enjoy the experience (read: suffer less) by seeing the beauty of Haskell along the way, and perhaps getting an idea of how to really write this in Haskell. (It would be far shorter and more elegant.)
22:21:38 <solrize> yitz good point
22:21:44 <koninkje> is there a built in for getting negative infinity?
22:21:56 <solrize> > -Inf
22:21:57 <lambdabot>   Not in scope: data constructor `Inf'
22:21:58 <yitz> (or her)
22:22:12 <dolio> > -1/0
22:22:17 <lambdabot>  -Infinity
22:22:21 <ahunter> AMcBain: is your current version on hpaste or similar atm?
22:22:24 <solrize> :t Infinity
22:22:26 <lambdabot> Not in scope: data constructor `Infinity'
22:22:29 <AMcBain> Well I would be very happy to use built-in functions if they did exactly what I was writing ...
22:22:38 <AMcBain> ahunter: Sure, the last one.
22:22:40 <koninkje> (-1/0) works well enough
22:22:44 <koninkje> dankje
22:23:19 <svat> AMcBain: did you put parens around both the "tail list"s?
22:23:24 <AMcBain> Yes.
22:23:51 <AMcBain> It just happens that I can't really seem to find any unified listing of all the commands + a short summary of what they do (or how to use them) like I can for Scheme (I have a rather nice PDF)
22:25:06 <svat> http://undergraduate.csse.uwa.edu.au/units/230.301/lectureNotes/tourofprelude.html ?
22:25:08 <AMcBain> So if, as you said, there really is a splitAt function that returns something I can easily use, it would be great if I actually had something to look it up in. Which is one of the reasons I dreaded doing this: no API pages!
22:25:09 <lambdabot> Title: A Tour of the Haskell Prelude, http://tinyurl.com/ywhnjx
22:25:38 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
22:26:00 <Cale> http://haskell.org/onlinereport/standard-prelude.html
22:26:02 <lambdabot> Title: The Haskell 98 Report: Standard Prelude
22:26:08 <AMcBain> Figures. Google: You suck!
22:26:14 <yitz> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
22:26:15 <lambdabot> http://tinyurl.com/ovjef
22:26:37 <yitz> @google haskell prelude
22:26:38 <lambdabot> http://www.haskell.org/onlinereport/standard-prelude.html
22:26:38 <lambdabot> Title: The Haskell 98 Report: Standard Prelude
22:26:46 <yitz> not so bad
22:26:55 <AMcBain> If you know what you are looking for!
22:27:07 <AMcBain> How am I supposed ot know it is called "Prelude"?
22:27:18 <yitz> @google a summary of some basic functions in haskell
22:27:19 <lambdabot> http://www.ninebynine.org/Software/swish-0.1.html
22:27:19 <lambdabot> Title: Nine by Nine: Semantic Web Inference using Haskell
22:27:33 <yitz> eww
22:27:49 <yitz> you're right
22:28:08 <shachaf> @go basic functions in haskell
22:28:09 <lambdabot> http://www.haskell.org/onlinereport/basic.html
22:28:09 <lambdabot> Title: The Haskell 98 Report: Predefined Types and Classes
22:28:18 <dolio> You could always go to haskell.org, and click on 'Standard libraries'. :)
22:28:25 <shachaf> "summary" is a little specific.
22:28:30 <yitz> @google #haskell
22:28:31 <lambdabot> http://www.haskell.org/
22:28:31 <lambdabot> Title: Haskell - HaskellWiki
22:28:35 <AMcBain> Plus, I just realized that I did my original attempt backwards and went down by x, when I intended to go by y ,,,
22:29:57 <yitz> AMcBain, right, those are the kinds of errors that you avoid by doing things more elegantly at a higher level. also - I think you may have a 1-off error in your indices.
22:30:20 <AMcBain> No, I did that so I could apply f to the current value instead of discard it.
22:31:14 <yitz> ok. but anyway - no reason to mess around with those kinds of things, Haskell's higher-level functions let you avoid all that often enough.
22:31:48 <AMcBain> well I have one in the works, but it doesn't seem to like it ...
22:32:23 <AMcBain> http://hpaste.org/6652#a3
22:33:16 <yitz> stay away from "do" here.
22:33:27 <Cale> AMcBain: you're missing an 'in'
22:33:43 <Cale> and yeah, the 'do' is not what you want
22:33:54 <Cale> 'do' is only for combining monadic computations
22:34:00 <Cale> (like IO computations)
22:34:06 <AMcBain> then what do I need?
22:34:12 <Cale> just the let, most likely
22:34:13 <svat> you need to write expressions that say what something "is"
22:34:39 <Cale> let ... in ...
22:35:12 <AMcBain> well that's fine, but I still get an error on the (splitAt y list)
22:35:19 <yitz> Another problem: splitAt returns a tuple - two lists, not one, so you can't just feed it back into itself. split it into two steps.
22:35:45 <AMcBain> I thought I did that
22:36:00 <AMcBain> oh
22:36:00 <Cale> well, splitAt x is expecting a list
22:36:04 <AMcBain> In the second half
22:36:11 <Cale> but splitAt y list is a pair
22:36:12 <AMcBain> I did, but not the first
22:36:12 <yitz> like (a, b) = splitAt ... on one line, and then (c, d) = splitAt ... on the next line.
22:36:36 <Cale> oh, and halves is a pair, not a list, so head and tail don't apply to it
22:36:53 <Cale> The appropriate functions are fst and snd, but really, you'd rather pattern match
22:37:14 <Cale> (like yitz is showing)
22:37:46 <adu> so i got this tiny parser working Parsec...
22:37:47 <yitz> By writing (a, b) = splitAt ... you are pattern matching, so you get names for the two separate lists instead of a tuple containing two lists
22:38:02 <adu> then I added "a few abstractions" and now the parser no longer works... :(
22:39:09 <yitz> adu: look on the bright side, once you get the abstractions fixed, then it will do so much more.
22:41:00 <adu> yitz: :)
22:41:33 <adu> I think I learned to only focus on one abstraction at a time
22:42:06 <yitz> :)
22:42:20 <svat> AMcBain: your "redefine" is an "applyAtPosition", right? You might want to first write such a function for lists, then use that function for lists of lists -- take it slowly, break up your problem, etc. :) [This is what yitz was saying long ago, but... that clearly wouldn't have made much sense until you tried doing it yourself.]
22:43:02 <solrize> @check quot a b == div a b
22:43:06 <lambdabot>  Falsifiable, after 0 tests:
22:43:20 <solrize> ?
22:43:26 <adu> 0 tests?
22:43:36 <Cale> er, heh
22:43:38 <adu> @check 1 == 1
22:43:39 <lambdabot>  OK, passed 500 tests.
22:43:47 <Cale> @check \a b -> quot a b == div a b
22:43:48 <lambdabot>  Exception: divide by zero
22:43:55 <Cale> @check \a b -> b /= 0 ==> quot a b == div a b
22:43:56 <lambdabot>  Falsifiable, after 2 tests: -2, 4
22:44:02 <svat> What is this @check, BTW? Is it something I can use for my Haskell programs? (If/when I write any.)
22:44:10 <Cale> svat: yes, it's QuickCheck
22:44:24 <adu> @check Floating a => Num a
22:44:24 <lambdabot>  Parse error at "=>" (column 12)
22:44:57 <Cale> It takes a function, and applies it to randomly generated parameters of the right types
22:45:03 <adu> hmm
22:45:09 <Cale> and then sees if it can get the function to produce False
22:45:17 <Cale> (the function must produce a Bool)
22:45:25 <svat> Cale: thanks, I'm reading about it... seems very useful.
22:46:00 <adu> @check \x xs -> (x:xs) == xs
22:46:02 <lambdabot>  Falsifiable, after 0 tests: (), []
22:46:06 <Cale> @check \xs ys -> reverse (xs ++ ys) == reverse xs ++ reverse (ys :: [Int])
22:46:07 <lambdabot>  Falsifiable, after 1 tests: [3,-1,3], [1]
22:46:15 <Cale> @check \xs ys -> reverse (xs ++ ys) == reverse ys ++ reverse (xs :: [Int])
22:46:15 <lambdabot>  OK, passed 500 tests.
22:46:16 <yitz> @check \a b c->let x=(-b+sqrt(b^2-4*a*c))/2/a in a*x^2+b*x+c==0
22:46:17 <lambdabot>  Falsifiable, after 0 tests: 1.3333333333333333, 2.0, 1.0
22:46:46 <Cale> @check \a b c->let x=(-b+sqrt(b^2-4*a*c))/2/a in abs (a*x^2+b*x+c) < 0.0001
22:46:49 <lambdabot>  Falsifiable, after 0 tests: 0.0, -0.3333333333333333, 2.3333333333333335
22:47:03 <AMcBain> http://hpaste.org/6652#a4 I really want to give up ...
22:47:10 <adu> @check \x -> sqrt (x**2) == abs x
22:47:10 <lambdabot>  Falsifiable, after 3 tests: 2.4
22:47:19 <yitz> AMcBain: hang in there!
22:47:23 <Cale> AMcBain: seriously, pattern match!
22:48:07 <svat> AMcBain: like, write let (a,b) = splitAt y list instead of writing rows = ... and using "fst" and "snd" everywhere.
22:48:07 <Cale> all this fst and snd nonsense is really hard to keep track of!
22:48:19 <adu> hmm, why not replace "rows" with "(f,s)"
22:48:19 <AMcBain> It's not so bad.
22:48:51 <Cale> @check \a b c->let x=(-b+sqrt(b^2-4*a*c))/2/a in abs (a*x^2+b*x+c) < 0.1
22:48:51 <svat> AMcBain: yeah, but write (f,s) = splitAt y list, because no one is used to seeing fsts and snds :)
22:48:52 <AMcBain> Do I still use a let with the "pattern matching" stuff?
22:48:52 <lambdabot>  Falsifiable, after 1 tests: 0.0, 0.0, 0.0
22:48:57 <ahunter> Out of curiosity, since we're talking about QuickCheck, what's the point of the coarbitrary method of the Arbitrary class?
22:48:58 <adu> AMcBain: ya
22:48:58 <Cale> er...
22:49:07 <yitz> @check \b c->let x=(-b+sqrt(b^2-4*c))/2 in abs(a*x^2+b*x+c) < 0.0001
22:49:08 <lambdabot>   add an instance declaration for (Arbitrary Expr)     In the expression: let...
22:49:18 <Jedai> ahunter: It's to test functions
22:49:57 <Jedai> ahunter: With coarbitrary well defined, you can generate random functions
22:50:02 <yitz> @check \b c->let x=(-b+sqrt(b^2-4*c))/2 in abs(x^2+b*x+c) < 0.0001
22:50:03 <lambdabot>  Falsifiable, after 1 tests: -2.0, 1.5
22:50:11 <Cale> hmm
22:50:17 <yitz> now what?
22:50:38 <adu> AMcBain: just do the following replacements at least: 'rows' -> '(rf, rs)' and 'fst rows' -> 'rf' and 'snd rows' -> 'rs' and 'cols' -> '(cf,cs)' and 'fst cols' -> 'cf' and 'snd cols' -> 'cs' or something
22:50:40 <Cale> > let (b,c) = (-2.0, 1.5); x=(-b+sqrt(b^2-4*c))/2 in x
22:50:41 <lambdabot>  NaN
22:50:48 <Cale> ah, of course :)
22:50:56 <Cale> hehe
22:51:04 <AMcBain> adu: I was already on that ...
22:51:13 <Cale> So, we need to ensure that the quadratic is actually solvable :)
22:51:30 <adu> Cale: heh
22:51:30 <svat> @check \b c->let x=(-b+sqrt(b^2-4*c))/2 in b^2 < 4*c || abs(x^2+b*x+c) < 0.0001
22:51:31 <lambdabot>  OK, passed 500 tests.
22:51:33 <Cale> @check \a b c -> b^2 - 4*a*c > 0 ==> let x=(-b+sqrt(b^2-4*a*c))/2/a in abs (a*x^2+b*x+c) < 0.1
22:51:34 <lambdabot>  Falsifiable, after 4 tests: 0.0, 3.0, -2.25
22:51:36 <dolio> @check \f l -> f l == (f . reverse . reverse) (l :: [Int])
22:51:36 <lambdabot>  OK, passed 500 tests.
22:51:55 <adu> @check 1 == 0
22:51:56 <lambdabot>  Falsifiable, after 0 tests:
22:52:04 <svat> @check \a b c->let x=(-b+sqrt(b^2-4*c))/2/a in a==0 || b^2 < 4*c || abs(a*x^2+b*x+c) < 0.0001
22:52:05 <lambdabot>  Falsifiable, after 5 tests: 1.5, -3.5, 1.0
22:52:15 <Cale> @check \a b c -> b^2 - 4*a*c > 0 && a /= 0 ==> let x=(-b+sqrt(b^2-4*a*c))/2/a in abs (a*x^2+b*x+c) < 0.1
22:52:16 <lambdabot>  OK, passed 500 tests.
22:52:21 <AMcBain> Well let's put it this way, even after simplifying it, the error is still there.
22:52:24 <Cale> @check \a b c -> b^2 - 4*a*c > 0 && a /= 0 ==> let x=(-b+sqrt(b^2-4*a*c))/2/a in abs (a*x^2+b*x+c) < 0.000000001
22:52:24 <lambdabot>  OK, passed 500 tests.
22:52:26 <adu> ?src rot13
22:52:26 <lambdabot> Source not found. :(
22:53:12 <yitz> Cale: that should still fail on underflow
22:53:24 <yitz> abs a > 0.000001
22:53:39 <Cale> right
22:54:07 <yitz> otoh, d>=0 should be ok
22:55:16 <svat> @check \a b c->let x=(-b+sqrt(b^2-4*a*c))/2/a in a==0 || b^2 < 4*c || abs(a*x^2+b*x+c) < 0.0001
22:55:17 <lambdabot>  Falsifiable, after 2 tests: -1.5, -1.0, -1.5
22:55:43 <svat> @check \a b c->let x=(-b+sqrt(b^2-4*a*c))/2/a in a==0 || b^2 < 4*a*c || abs(a*x^2+b*x+c) < 0.0001
22:55:44 <lambdabot>  OK, passed 500 tests.
22:56:22 <AMcBain> I can't even print the fucking variables to see what they are and why it might be having an issue with them!?? Come on! This compiler is very unfriendly.
22:56:34 <AMcBain> s/compiler/language/
22:56:37 <svat> @check \a b c-> abs(a)>0.00001 && b^2 >= 4*a*c ==> let x=(-b+sqrt(b^2-4*a*c))/2/a in abs(a*x^2+b*x+c) < 0.0001
22:56:37 <lambdabot>  OK, passed 500 tests.
22:56:39 <Cale> AMcBain: which variables?
22:57:02 <Cale> AMcBain: The variables don't have values until the program runs. You're dealing with type errors.
22:57:08 <AMcBain> fr,sr,fc,sc
22:57:11 <Heffalump> AMcBain: that's what trace is for, at runtime.
22:57:32 <AMcBain> I just tried to print them, and it didn't like me just putting in print statements.
22:58:12 <Cale> AMcBain: that's because print actions have a different type
22:58:24 <Cale> because printing something on the screen is not, for example, a list of integers
22:58:31 <bd_> AMcBain: replace someValue with: trace ("Some debug output: " ++ show foo) someValue   (you'll need import Debug.Trace)
22:58:38 <yitz> AMcBain: use the ghci prompt like the python shell. Except use "let" to define variables and functions.
22:58:38 <bd_> and you can get things dumped to the console
22:58:55 <svat> AMcBain: but paste the code on hpaste; others will debug it for you ;-)
22:58:59 <AMcBain> And none of this is user friendly. Point proved.
22:59:06 <yitz> and no multi-line statements, use ";"
22:59:56 <AMcBain> This is what I got: http://hpaste.org/6652#a5 As is.
23:00:19 <AMcBain> Not that it is any more readable than before. I think it was more readable with the snd and fsts ...
23:00:58 <AMcBain> I could add more lets before the in to simplify that, but then I would only be returning the last computation ...
23:01:05 <svat> AMcBain: It is just unfamiliar if you are used to practices from other languages, that's all. Usually, one writes Haskell programs as short functions, each of which can be individually tested...
23:01:33 <adu> yey found it
23:01:47 <adu> > let rot13 s = map (\c -> fromMaybe c (lookup c transp)) s; transp = zip letters ((drop 26 letters) ++ (take 26 letters)); letters = join (map (\c -> [toUpper c, c]) ['a' .. 'z']) in rot13 "Hello World!"
23:01:48 <lambdabot>  "Uryyb Jbeyq!"
23:02:02 <AMcBain> Short and confusing = unfamiliar, sure, but long and more expressive of what is going on is better imo ...
23:02:35 <adu> let rot13 s = map (\c -> fromMaybe c (lookup c transp)) s; transp = zip letters ((drop 26 letters) ++ (take 26 letters)); letters = join (map (\c -> [toUpper c, c]) ['a' .. 'z']) in rot13 "Uryyb Jbeyq!"
23:02:39 <svat> AMcBain: You need fr ++ ..., not : (you are concatenating two lists, not adding an element to a list.
23:02:42 <adu> crap
23:03:02 <yitz> adu: >
23:03:09 <adu> i know
23:03:38 <AMcBain> Still fails.
23:03:50 <Jedai> AMcBain: Haskell function are much more readable than Java function, they express directly the intent whereas Java functions tends to lost themselves in record keeping
23:04:20 <vegai> http://reddit.com/info/6djqc/comments/
23:04:23 <AMcBain> That's not going to stick. You're telling that to a person who happens to really like Java.
23:04:51 <svat> AMcBain: it might help if you stop thinking of what *computation* is happening, and instead look at your expressions as definitions.
23:06:05 <AMcBain> Well it doesn't help that the error messages are almost as bad as C++!
23:06:20 <svat> AMcBain: what is your code currently, and what does it fail with? Did you write all list concatenations as ++?
23:06:31 <AMcBain> Except for the inner one.
23:06:41 <AMcBain> As that is still adding one item to  a list.
23:08:10 <Heffalump> AMcBain: so why don't you just program in Java and be done with it?
23:08:20 <AMcBain> That's not the point.
23:08:35 <sjanssen> so what is this function supposed to do, anyway?
23:08:37 <Jedai> AMcBain: Why didn't you use the definition we gave long ago in this forum, it's much more clear
23:08:37 <svat> AMcBain: the error messages can be confusing to new people, true. Once you understand the type system, they make more sense.
23:08:52 <AMcBain> I don't get anywhere by doing everything in Java, and I'm surely not very employable if I tell them "I only do Java"
23:09:33 <sjanssen> given a list, a function, and two indices, modify the yth element of the xth list with the function f?
23:09:41 <Jedai> AMcBain: Trying to do this function on 2D is an error
23:09:52 <AMcBain> Jedai: The "thing" you gave me a long while ago was (sorry) but a long stream of crap that made even less sense than what I have now.
23:10:18 <adu> what is this "redefine" supposed to do?
23:10:23 <adu> and what are some sample inputs?
23:10:27 <AMcBain> sjanssen: Close, y goes down, and x goes across.
23:10:30 <Jedai> AMcBain: It just worked perfectly on the first try...
23:11:14 <adu> y goes down...
23:11:18 <Jedai> AMcBain: redefine i f xs = let (h, t:ts) = splitAt i xs in h ++ (f t : ts)
23:11:29 <solrize> redefine :: [[a]] -> (a->a) -> Integer -> Integer -> [[a]]               ??
23:11:39 <AMcBain> Jedai: I meant what I said about that ...
23:12:03 <adu> AMcBain: what is the type signature of "redefine"?
23:12:07 <Jedai> AMcBain: change f x y xxs = redefine x (redefine y f) xxs
23:12:08 <AMcBain> Okay, I changed the last ++ in mine back to a : and it works again ...
23:12:22 <AMcBain> f is a functions, x and y are integers and list is a list.
23:12:27 <adu> ok
23:12:46 <AMcBain> (list which just happens to look like an array, except I just can't call it that ... :-/)
23:12:59 <solrize> it really is a list, made of cons cells like a lisp/scheme list
23:13:19 <Jedai> AMcBain: You could perfectly do all of that with arrays, that's what I used in my solution
23:13:35 <sjanssen> AMcBain: see my annotation -- I think this is the right way to do it
23:13:39 <adu> redefine :: [a] -> Integer -> Integer -> (a -> b) -> [b] ?
23:13:40 <AMcBain> Yea, but at least in Scheme they looked like a list with () and stuff.
23:13:51 <AMcBain> Every language I have ever known uses [] for arrays ...
23:13:54 <solrize> (1 2 3 4 5) instead of [1,2,3,4,5]   what's the diff?
23:14:19 <adu> solarize: that kind of stuff should be in compiler options, imho
23:14:23 <Jedai> AMcBain: I know languages which use {} for arrays (in fact Java does)
23:14:29 <AMcBain> Spaces and () :P
23:14:32 <adu> like --with-list="( )"
23:14:38 <adu> or --with-list="[,]"
23:14:43 <AMcBain> Jedai: Only when setting it up.
23:14:43 <sjanssen> adu: bleh
23:14:49 <AMcBain> with a certain syntax.
23:15:00 <Jedai> adu: Please no, that's an horrible suggestion...
23:15:05 <adu> hehe
23:15:07 <svat> adu: no way. Then you'll have hundreds of Haskell dialects, the Lisp problem :P
23:15:11 <sjanssen> adu: so we all can edit code that is very slightly different and depends on compiler flags to build correctly?  No thanks
23:15:21 <adu> GHC does it already
23:15:32 <Jedai> AMcBain: Ok so how is [] harder to use than {} or ()
23:15:59 <AMcBain> I'm not going there, I'm just moving on to the next function ...
23:16:03 <adu> iirc, there was a point where the -glosgow-ext got turned into 20 or so options
23:16:24 <adu> like -XArrow and -XMagicHash
23:16:27 <adu> or something
23:16:32 <sjanssen> adu: this is a bit different
23:16:34 <adu> hehe
23:16:36 <adu> i know
23:16:47 <AMcBain> "MagicHash" ... what where the devs on?
23:16:54 <adu> lol
23:17:00 <nornagon> whee, time to attend the second fp-syd meeting ever :) (couldn't make the first one :()
23:17:04 <svat> AMcBain: do you really not find the code (see yitz's latest cleanup) not clean and nice to read? :)
23:17:09 <solrize> > let update xs f i = [if i=k then x  else f x | (x,k) <- zip xs [0..]]  in update [2,3,4,5] (*3) 2    -- if you like python
23:17:09 <lambdabot>  Parse error at "=k" (column 26)
23:17:17 <solrize> > let update xs f i = [if i==k then x  else f x | (x,k) <- zip xs [0..]]  in update [2,3,4,5] (*3) 2    -- if you like python
23:17:29 <solrize> hmm?
23:17:32 <lambdabot>  thread killed
23:17:34 <solrize> looping?
23:17:45 <solrize> > zip [1,2,3] [1..]
23:17:45 <lambdabot>  [(1,1),(2,2),(3,3)]
23:18:23 <AMcBain> svat: well a little sure. I think maybe I'll take it.
23:18:28 <yitz> sjanssen: yes, we did something like that earlier. But AMcBain is trying to stay close to the original scheme code that is being translated.
23:18:37 <sjanssen> ah
23:18:40 <solrize> right i keep forgetting that
23:18:44 <solrize> too
23:18:56 <sjanssen> pssh, clearly the original scheme code is wrong :)
23:19:11 <AMcBain> Well, "close" as in if there is a shortcut and I understand it. And that paste I don't understand, so therefore ...
23:19:41 <sjanssen> AMcBain: then try to learn something
23:19:50 <AMcBain> And the Scheme code generates an answer, so it can't be wrong. It just doesn't happen to be the language of your choice, sjanssen.
23:20:02 <sjanssen> we're generally very good about answering questions
23:20:12 <svat> sjanssen: you don't need the case-of, right? If the snd of the split is empty then it's out of bounds anyway.
23:20:26 <AMcBain> Also being that it is 1:19 in the morning, I'm not about to dive head first into piles of stuff that can be delt with on my own time after the program works and is turned in.
23:20:52 <yitz> Right. is it due tomorrow?
23:21:11 <sjanssen> svat: well, I'd rather not fail if the index is out of bounds
23:21:20 <sjanssen> (where fail means _|_)
23:22:04 <yitz> sjanssen: here, we're trying to avoid _|_ in the homework monad.
23:22:05 <svat> sjanssen: But it makes the code so much cleaner! :)
23:22:25 <AMcBain> yitz: No, Friday ... but oh. It is Thursday now ...
23:23:32 <yitz> AMcBain: I think you're getting the basic idea. Better tackle expand, that's going to be the main issue here. It'll be along the same lines, but we may need a new idea or two.
23:25:27 <yitz> AMcBain: your scheme paste scrolled out of my window. what was that url again?
23:25:41 <AMcBain> Heh: http://paste.lisp.org/display/58065
23:25:48 <AMcBain> (I'm doing "get" right now)
23:26:04 <yitz> you probably won't even need that.
23:26:22 <yitz> better look at expand, that's where your program does its real work.
23:27:46 <AMcBain> Got it.
23:28:14 <AMcBain> Anyways, expand? Well I thought I would get all the little functions first, so that they are there when I do the big ones. Then I can factor them out as needed.
23:29:08 <hansfbaier_> haskell isnt good for realtime audio processing, right?
23:29:28 <bd_> ?faq
23:29:28 <lambdabot> The answer is: Yes! Haskell can do that.
23:29:48 <Heffalump> hansfbaier_: well, it has a stop-the-world GC
23:29:52 <yitz> well, process I guess.
23:29:58 <Heffalump> at least all implementations I know of do
23:30:34 <yitz> @. vixen faq Can you do audio processing?
23:30:34 <lambdabot> church is my favourite computer scientist.
23:30:47 <Cale> It is rather effective as a way to control lower-level devices for real-time audio processing though
23:31:30 <Cale> There are quite a few people doing that, notably Alex McLean (who has lots of videos on his blog about it)
23:32:07 <AMcBain> Hm. If I change my 1 and 0 I used in Scheme to True and False here, I can use not to flip the values, right?
23:32:08 <adu> > let update xs f i = elems (as//[(i::Int,f$as!i)]) where as = listArray (1, length xs) xs in update [1,2,3,4] (+5) 2
23:32:09 <lambdabot>  [1,7,3,4]
23:32:14 <hansfbaier> Cale: Do you have an url for it?
23:32:23 <yitz> Once we get fully parallel gc things will improve
23:32:33 <yitz> AMcBain: good idea
23:32:52 <adu> AMcBain: right
23:32:57 <Cale> http://doc.gold.ac.uk/~ma503am/alex/haskellmusic/ -- but it seems not to be responding to me at the moment
23:33:35 <sjanssen> yitz: AFAIK, GHC's new GC is still stop-the-world
23:33:48 <yitz> yes
23:36:20 <AMcBain> Hm. Is there any way to easily do gety and getx? I mean, I could technically update all the logic to work with the 2dimensional board ... but that wouldn't be worth my time ...
23:36:57 <AMcBain> Well hm. Nope, can't use % (if there is one) ...
23:37:13 <AMcBain> (guess there is)
23:37:44 <svat> What's gety and getx and %?
23:37:46 <yitz> AMcBain: divMod
23:37:53 <svat> oh ok.
23:38:13 <yitz> > 39 `divMod` 8
23:38:14 <lambdabot>  (4,7)
23:38:38 <Mr_Awesome> > -39 `divMod` 8
23:38:38 <lambdabot>   add an instance declaration for (Num (t, t))
23:38:46 <Mr_Awesome> > (-39) `divMod` 8
23:38:46 <lambdabot>  (-5,1)
23:38:54 <yitz> > 39 `mod` 8
23:38:54 <lambdabot>  7
23:39:00 <AMcBain> What gety/x does is converts a value relative to a 2dimensional board represented as a single list to the x or y of a 2dimensional board represented as a 2d list ...
23:39:03 <yitz> > 39 `div` 8
23:39:04 <lambdabot>  4
23:39:13 <Mr_Awesome> > (-39) `quotRem` 8
23:39:15 <lambdabot>  (-4,-7)
23:39:35 <svat> I think the names divMod and quotRem are switched.
23:39:42 <Mr_Awesome> the div, mod, quot, and rem functions always confuse me
23:40:10 <Mr_Awesome> svat: switched?
23:40:12 <AMcBain> So, if I did div and mod I can get what I want I guess ...
23:40:50 <svat> Mr_Awesome: I meant, I feel it should have been the other way round. But easy way to remember is that div and mod are the more common functions, and Haskell gives the "correct" results for them, unlike other languages :)
23:40:51 <yitz> AMcBain: yeah, that stuff'll be easy. I'm trying to grok process...
23:41:17 <svat> 5 `divmod (-8)
23:41:26 <svat> > 5 `divmod` (-8)
23:41:26 <lambdabot>   Not in scope: `divmod'
23:41:32 <svat> > 5 `divMod` (-8)
23:41:32 <lambdabot>  (-1,-3)
23:42:02 <svat> > 5 `quotRem` (-8)
23:42:03 <lambdabot>  (0,5)
23:42:49 <AMcBain> how do I get the length of a list?
23:42:51 <svat> Sigh, so there is still no function that always gives a nonnegative remainder?
23:43:03 <svat> > length [1, 3, 4]
23:43:04 <lambdabot>  3
23:43:14 <AMcBain> oh duh. Figures it would be named the same.
23:43:57 <yitz> ok got it
23:45:01 <svat> this scheme code is quite imperative...
23:45:37 <yitz> AMcBain: flip is an important Prelude function, so call it something else. how about flop?
23:46:20 <AMcBain> Well, the original function was called swap, but invert might work okay ...
23:46:32 <yitz> you use that for something else
23:47:01 <AMcBain> hm true. "click"? :) It was originally a GUI game ...
23:47:47 <yitz> ok, i see that expandn and process are not that complex, they just look that way because you are busy being careful about bounds.
23:48:19 <AMcBain> Yea, because if I don't, it doesn't know when to stop flipping ...
23:50:31 <yitz> and flip - uh, click - swap - is worried about edge cases. i'm sure that could be done more neatly, even in the scheme, but i'd say just translate it directly as if-then-else's and be done with it.
23:52:17 <AMcBain> Well in Java I could say that each level had done x flips. So there were no more children. When I did this via functions, I just had to set a lower limit.
23:54:24 <yitz> you might have been better off translating the Java to Haskell. It may not be as close as Scheme, but if you expressed your ideas most clearly there it would work the best.
23:55:17 <yitz> anyway, I've got to go. Good luck, I think you'll be fine. And there are always people around here who can help.
23:57:46 <hansfbaier> sjanssen: I rember there is something in the FFI that turns gc for certain instances, but that probably would not help if the gc is stop-the-world.
23:58:36 <hansfbaier> sjanssen: stable pointers or so...
