00:17:06 <dons> Cale: hehe http://nobodyreadsthis.co.uk/2008/03/08/curious-haskell-attention/
00:17:09 <lambdabot> Title: Curious Haskell Attention « Nobody Reads This, http://tinyurl.com/37h4uq
00:18:18 <ttt--> hi, is there a way to get a list of all the available functions of a certain type? (at runtime)
00:18:49 <dons> inside a haskell program? no, not really
00:18:56 <dons> you can use hoogle to find functions of a type though
00:18:58 <dons> ?where hoogle
00:18:58 <lambdabot> http://haskell.org/hoogle
00:19:08 <dons> ?hoogle a -> b -> [a] -> [b]
00:19:08 <lambdabot> No matches, try a more general search
00:19:13 <dons> ?hoogle (a -> b) -> [a] -> [b]
00:19:13 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
00:19:14 <lambdabot> Data.List.map :: (a -> b) -> [a] -> [b]
00:19:14 <lambdabot> Control.Parallel.Strategies.parMap :: Strategy b -> (a -> b) -> [a] -> [b]
00:19:26 <desegnis> ttt--, the list of functions of a certain type may well be infinite, but it is the same at compile time or at runtime
00:20:56 <ttt--> can you give an example of an infinite one?
00:21:33 <desegnis> ttt--, Integer -> Integer ?
00:21:50 <ttt--> i didnt mean with compositions, only the ones provides from the code
00:22:02 <desegnis> ah ok
00:22:28 <tibbe> good morning!
00:23:02 <ttt--> something like a hoogle search on the loaded packages
00:23:30 <ttt--> *modules
00:25:13 <desegnis> Well, that wouldn't be possible, unless you keep the module source around
00:25:23 <Cale> ttt--: That would have to be a language primitive...
00:25:31 <Cale> (but it doesn't exist)
00:25:51 <Cale> I'm not quite sure what you'd do with it.
00:27:53 <ttt--> something that tries to find functions from examples
00:28:20 <oerjan> > flip sequence 0 $ iterate ((+1).) id
00:28:21 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
00:28:40 <dmwit> ttt--: Haskell has very little reflection beyond the type system.
00:29:43 <ttt--> is that intentional?
00:29:59 * dmwit cocks his head
00:30:04 <dmwit> I honestly don't know!
00:31:16 <desegnis> I guess that most information for run-time reflection tends to be optimized away anyway, so it would be quite difficult to add reflection primitives
00:31:25 <ttt--> you can't ask a function what its type is at runtime, for example?
00:31:48 <desegnis> you can't
00:31:53 <ttt--> ok i see
00:32:47 <ttt--> i thought you could do a lot of fun AI things because you have all the type information
00:35:25 <Cale> Type information is only really present at compile time. There's a system called Data.Typeable which uses type classes to reflect it at runtime, but it has its limitations.
00:36:05 <Svrog> ttt--: http://www.informatik.uni-bonn.de/~ralf/publications/With.pdf
00:36:09 <Svrog> have a look at section 5
00:36:14 <ttt--> ok
00:36:41 <ttt--> how does GPLib do it?
00:37:03 <dmwit> I wonder what the answer to such a question would look like.
00:37:13 <dmwit> i.e. what is the type of the ":t" function?
00:37:50 <dmwit> a -> TypeRep, I guess. =P
00:37:56 <dmwit> :t typeOf
00:37:58 <lambdabot> forall a. (Typeable a) => a -> TypeRep
00:38:50 <ttt--> > typeOf (+)
00:38:51 <lambdabot>  Integer -> Integer -> Integer
00:39:01 <ttt--> > typeOf (+ 3)
00:39:03 <lambdabot>  Integer -> Integer
00:39:09 <dmwit> Not bad, eh?
00:39:16 <dons> you can do quite a bit of runtime reflection, but the applications are rare
00:40:33 <ttt--> typeOf doesn't seem to work in my ghc
00:40:57 <ttt--> dons: any places i can read about it?
00:40:58 <Svrog> typeOf is in Data.Typeable
00:41:00 <dmwit> :m + Data.Typeable
00:41:03 <Svrog> you have to import the module first
00:41:07 <ttt--> ok, thanks
00:55:39 <Cfr>  Cale: hehe http://nobodyreadsthis.co.uk/2008/03/08/curious-haskell-attention/
00:55:41 <lambdabot> Title: Curious Haskell Attention « Nobody Reads This, http://tinyurl.com/37h4uq
00:56:02 <Cfr> sorr
00:56:22 <Cale> Hehe, clearly I've already seen that ;)
00:56:51 <Cfr> my curiousity :)
00:58:55 <paolino> Java is very older and much more used, I don't understand the connection
00:59:05 <glguy> woot, I can run sqlite on IOArray Int Word8 s
00:59:33 <oerjan> Java is _not_ older than haskell
00:59:36 <Svrog> actually haskell is older than java
00:59:37 <Svrog> yes
00:59:50 <sm> that page reminds me of http://brucio.blogspot.com/ !
00:59:51 <lambdabot> Title: Lisp at Light Speed
00:59:53 <Baughn> > 1
00:59:56 <lambdabot>  1
01:00:32 <paolino> Java was made after 98 ?
01:00:44 <Baughn> Haskell was made before 98
01:01:08 <paolino> ok
01:01:08 <oerjan> haskell 98 is at least the fifth standard
01:01:14 <Baughn> ..you wouldn't want to use one of the early versions, though. stream i/o, no monads..
01:01:28 <oerjan> although they used to be more frequent in the past.
01:04:02 <paolino> still the reason of the little spread of haskell, I don't think has to do with age
01:04:09 <dolio> Yeah, 10 years is a while.
01:04:54 <dolio> 1.3, 1.4 and 98 appear to be spaced by around a year.
01:06:36 <oerjan> lessee... 1.3 was revolutionary.  1.4 was _too_ nice so they had to go back to 98?
01:07:12 <paolino> if I can say something about , I'd say haskell has steps, I can't climb it with a normal motorbike
01:07:53 <wagle_home> haskell's first definition/manual was in 1988..  java came out in 1995
01:09:17 <paolino> but then I don't need a climber technical wrapper to rest, I  can sleep on the step when I reached it :)
01:11:48 <paolino> If I could cluster programmers for temper, I suspect they would group in a cluster of quiteness
01:20:41 <dmwit> ?pl \b sp sm -> r b sp `mod` r b sm
01:20:41 <lambdabot> ap (flip . (((.) . mod) .) . r) r
01:20:47 <dmwit> ick
01:20:57 <dmwit> ?pl \b -> r b sp `mod` r b sm
01:20:57 <lambdabot> ap (mod . flip r sp) (flip r sm)
01:21:56 <dmwit> liftM2 mod (flip r sp) (flip r sm) -- should be reduceable somehow
01:22:38 <glguy> because of the flip r?
01:22:57 <dmwit> Because of the repeated r
01:23:32 <dolio> (mod `on` (r . b)) sp sm
01:23:45 <dolio> Oops, r b, not r . b
01:23:51 <dmwit> Nice!
01:24:26 <glguy> you could also base-64 encode your code
01:25:30 <oerjan> @pl \b sp sm -> (mod `on` (r . b)) sp sm
01:25:30 <lambdabot> (mod `on`) . (r .)
01:25:38 <oerjan> er
01:25:43 <oerjan> @pl \b sp sm -> (mod `on` (r b)) sp sm
01:25:43 <lambdabot> (mod `on`) . r
01:26:12 <wagle_home> @src on
01:26:12 <lambdabot> (*) `on` f = \x y -> f x * f y
01:27:47 * wagle_home dies of shock at lambdabot actually knowing the source of something non-trivial
01:28:24 <wagle_home> @pl on
01:28:24 <lambdabot> on
01:28:49 <wagle_home> @pl  (*) `on` f = \x y -> f x * f y
01:28:49 <lambdabot> (line 1, column 12):
01:28:49 <lambdabot> unexpected "="
01:28:49 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
01:29:43 <wagle_home> @pl  \s f x y -> f x `s` f y
01:29:44 <oerjan>  @pl is grammatically challenged
01:29:45 <lambdabot> join . ((flip . ((.) .)) .) . (.)
01:30:05 <dolio> We already knew that pl doesn't know about on. Otherwise I wouldn't have had to tell dmwit about it.
01:30:27 <wagle_home> i'm just tryin to follow along
01:30:56 <dolio> Someone should probably teach it.
01:31:04 <wagle_home> and i find pl horrifying, so i have to watch it carefully
01:31:07 <dolio> Since it's fairly common for people do come in here and do something like...
01:31:21 <dolio> @pl \x y -> fst x == fst y
01:31:21 <lambdabot> (. fst) . (==) . fst
01:31:42 <oerjan> @pl \y -> f x `s` f y
01:31:42 <lambdabot> (f x `s`) . f
01:31:51 <oerjan> @pl \x y -> f x `s` f y
01:31:51 <lambdabot> (. f) . s . f
01:32:06 <oerjan> @pl \f x y -> f x `s` f y
01:32:09 <lambdabot> flip =<< (((.) . s) .)
01:33:22 <oerjan> @pl \f -> (. f) . (s . f)
01:33:22 <lambdabot> ap ((.) . flip (.)) (s .)
01:33:34 <oerjan> @pl \s f -> (. f) . (s . f)
01:34:17 <lambdabot> ap ((.) . flip (.)) . (.)
01:34:50 <wagle_home> whoa..  that was a fasst 7 1/2 million years
01:35:27 <oerjan> but the answer wasn't 42.  er, what do you mean?
01:35:39 <wagle_home> took a while
01:36:04 <wagle_home> thought maybe youd computed the answer
01:37:03 <wagle_home> is it a theorem that all pointless code must contain at least one call to flip?
01:38:00 <wagle_home> hmm..  maybe only non-trivial pointless codde
01:39:24 <oerjan> @pl \a b c d e f -> a (b (c d) e) f
01:39:24 <lambdabot> (. (.)) . (.) . (.) . (.)
01:39:27 <oerjan> nope :)
01:39:40 <wagle_home> obviously trivial..  8)
01:40:14 <wagle_home> @pl \a b c d e f -> f e d c b a
01:40:14 <lambdabot> flip (flip . ((flip . ((flip . (flip .)) .)) .) . flip (flip . ((flip . (flip .)) .) . flip (flip . (flip .) . flip (flip . flip id))))
01:40:34 <igel> could someone please give me a hint when to use newtype? :)
01:40:37 <wagle_home> obviously a non-trivial permutation
01:41:04 <dmwit> igel: When you want a different instance of some class for a given type.
01:41:20 <dmwit> igel: For example, if you want to sort in reverse order, a newtype is ideal.
01:41:24 <igel> well i could use "data" as well
01:41:32 <igel> what's the advantage of newtype
01:41:33 <dmwit> yes
01:41:34 <igel> ?
01:41:39 <dmwit> Two advantages.
01:41:51 <dmwit> One is silly: newtype is slightly faster.
01:42:04 <dmwit> The other could be useful, but it's GHC-only: newtype deriving.
01:42:08 <igel> because it is not represented as an enum?
01:42:31 <igel> what is newtype deriving?
01:42:34 <dmwit> igel: Correct, newtypes are "unboxed".  In the actual code, they are represented without a constructor.
01:42:44 <igel> i see
01:42:51 <dmwit> newtype deriving lets you derive any instance that the wrapped type has.
01:43:16 <igel> and it cannot be distinguished from the original instance>?
01:43:27 <dmwit> right
01:43:31 <igel> e.g. data Foo = Foo Int deriving show
01:43:40 <igel> newtype Bar = Bar Foo deriving Show
01:43:41 <dmwit> Oh, well, no.
01:43:42 <dmwit> Sorry.
01:43:54 <dmwit> It is based on (but not indistinguishable from) the original instance.
01:44:14 <igel> so show (Bar (Foo 3)) = " Bar (Foo 3)" ?
01:44:14 <dmwit> The built-in derivations are the same (I think) as what you would get from data.
01:44:27 <dmwit> I believe so, but that is easily tested.
01:44:31 <igel> ok
01:44:35 <oerjan> Show is an exception
01:45:23 <igel> so Enum or Ord would be just like the wrapped instances?
01:45:31 <oerjan> right
01:45:35 <igel> ok
01:45:42 <igel> and is there any disadvantage of newtype?
01:45:51 <dmwit> It's annoying.
01:46:05 <igel> (except that it's limited to one argument in one constructor)
01:46:08 <dmwit> Although no more annoying than "data", I guess.
01:46:22 <dmwit> igel: Yes, one small downside.
01:46:25 <oerjan> although technically that is because those classes already are defined to derive that way, for data as well.  newtype deriving can also be used for classes that cannot be derived for data.
01:46:42 <dmwit> igel: Because it is unboxed, it treats bottom differently than data.
01:47:09 <dmwit> So, there's a difference between bottom and (Just bottom).
01:47:29 <dmwit> But if you say "newtype Foo = Bar Int", then bottom and (Bar bottom) are both bottom.
01:47:31 <dolio> That's unlifted, actually.
01:47:40 <dolio> Unboxed has to do with the way it's represented in memory.
01:47:53 <dmwit> Err... I think it really is unboxed.
01:48:04 <dmwit> (At least in GHC.)
01:48:29 <dmwit> Oh, you mean the bottom-related behavior.
01:48:31 <dmwit> ok
01:48:49 <igel> so "newtype Bar = Foo Int" is actually "data Bar = Foo !Int"?
01:49:01 <dolio> Yeah, I guess strictly speaking it's unboxed since there's no extra pointer.
01:49:17 <igel> ok
01:49:26 <igel> thank you!
01:49:30 <igel> :)
01:49:41 <dmwit> ?hoogle (a -> Bool) -> GenParser a st a
01:49:41 <lambdabot> Did you mean: (a -> Bool) -> GenParser a St a
01:50:01 <desegnis> igel, there are still subtle differences between those two Bars
01:50:25 <igel> desegnis: you mean the Bar !Int?
01:50:44 <desegnis> I mean newtype vs. data-with-!
01:51:09 <dolio> Nothing that can't be solved by sprinkling ~ all over your code. :)
01:51:22 <igel> ?
01:51:25 <desegnis> but I always forget the difference, wait a sec, let me remember
01:51:35 <igel> dolio: ~ ?
01:51:54 <dolio> ~p is an irrefutable pattern.
01:52:14 <igel> which is what?
01:52:48 <dolio> Essentially 'case foo of ~(Foo a) -> ...' is a way of saying that foo is always a (Foo a).
01:53:03 <dolio> So GHC doesn't actuallhy have to check, and foo doesn't have to be evaluated.
01:53:17 <igel> ah ok
01:53:27 <dolio> Of course, if it's not a (Foo a), and you use a later, exceptions are thrown.
01:53:27 <igel> i didn't know this
01:53:31 <desegnis> igel, let's call them newtype Bar1 = Foo1 Int, data Bar2 = Foo2 !Int
01:53:45 <dolio> Since a newtype can only have one constructor, all pattern matches on it are irrefutable.
01:53:53 <igel> i see
01:54:17 <dolio> Since it makes no sense to have an ordinary, branching case statement.
01:54:32 <igel> yeah
01:54:40 <desegnis> a pattern match on Foo1 will always succeed, whereas a pattern match on Foo2 is undefined whenever either the Int field, or the Bar2 value itself, is undefined
01:55:11 <desegnis> I always take http://haskell.org/haskellwiki/Newtype for reference :)
01:55:43 <igel> ah ok
01:55:49 <igel> thank you :)
01:56:02 <desegnis> igel, btw, are you the igel from rubyforen.de?
01:56:20 <igel> i'm afraid i'm not ;)
02:01:13 <tarbo> hello $C
02:03:13 <tarbo> hello #haskell
02:05:13 <tarbo> hello #haskell freenode
02:06:06 <paolino> @pl \(l,r) -> (max l) *** (min r)
02:06:06 <lambdabot> uncurry ((. min) . (***) . max)
02:07:58 <paolino> @pl \(mx,mn) (l,r) -> (mx l) *** (mn r)
02:07:58 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (***)) .))
02:08:38 <glguy> tarbo: are you a bot?
02:08:50 <tarbo> glguy: no, i am just an idiot. sorry for the interruption.
02:09:14 <glguy> I just noticed you've been joining the channel for 7 months but haven't said more than 5 things
02:09:22 <glguy> none on topic (which is ok)
02:09:41 <opqdonut> :)
02:09:49 <paolino> a bot-tom
02:10:02 <dmwit> heh
02:10:11 <opqdonut> well don't we all lurk on some channels
02:10:18 <dmwit> <3 Parsec
02:10:32 <glguy> opqdonut: do you have something to confess?
02:10:42 <opqdonut> yeah, i lurk on #lua
02:10:50 <opqdonut> I'M SORRY
02:11:03 <Gilly> *g*
02:11:05 <opqdonut> I JUST CAN'T PUSH MYSELF TO PART
02:11:09 <opqdonut> hi Gilly
02:11:13 <Gilly> o/
02:11:19 <glguy> opqdonut: the 3rd thing you've said in channel was directed to me :)
02:11:25 <glguy> (back in 2006)
02:11:56 <opqdonut> i never keep logs :)
02:12:26 <paolino> I will get cold in winter
02:12:31 * dolio deleted his #haskell logs a couple weeks ago when he noticed they were taking up hundreds of megabytes.
02:12:37 <glguy> logs are important for establishing a pattern of behavior
02:13:08 <glguy> #haskell back to 2004 is only 311 meg
02:13:21 <tarbo> glguy: i tend to use the logs here as a faq when i run into a problem. just fyi for why i hang out. i dont know enough to answer question, but i dont like to make noise ... so you can imagine i am sort of shell-shocked having spammed each of my channels.
02:13:22 <opqdonut> luckily irc logs compress well :)
02:13:52 <opqdonut> tarbo: yeah i remember messing up with /forall myself :/
02:13:59 <glguy> opqdonut: harder to search compressed logs :-p (harder, not hard)
02:14:12 <wagle_home> zgrep
02:14:15 <opqdonut> compressfs
02:14:21 <glguy> opqdonut: /forall?
02:14:42 <glguy> tarbo: no problem :O)
02:14:48 <opqdonut> glguy: irssi feature
02:15:12 <opqdonut> you can do stuff like /forall channel /lastlog foo
02:15:30 <opqdonut> but if you forget the second / it just sends "lastlog foo" to every channel...
02:15:51 <glguy> actually, grepping mildly compressed files might be faster
02:15:55 <glguy> if the bottle neck is IO
02:16:16 <dolio> I guess it was almost a month ago.
02:16:34 <dolio> Anyhow, my logs are currently from Feb 10 to now, and it's 13 MB.
02:16:36 <opqdonut> it should be possible to devise a compression scheme that would make grepping faster
02:16:46 <opqdonut> building an appropriate index or something like that
02:17:07 <dmwit> So, I'm tired and not thinking straight.  Is repeatedly doing a "partition" a reasonable way to separate out equivalence classes?
02:17:48 <opqdonut> i'd say you get an asymptotic factor of k where k is the number of equivalence classes
02:18:25 <dmwit> k*n, n the length of the list, right?
02:18:30 <opqdonut> yeah
02:18:55 <dolio> That's roughly 175 MB per year. So my IRC program isn't logging as efficiently as yours is, apparently. :)
02:19:09 <opqdonut> the naive solution is of course O(kn) too
02:19:35 <opqdonut> i'd say folding over the list with a list-of-classes accumulator would be a pretty neat solution
02:21:15 <dmwit> Harder to write than the straightforward recursion though, so it loses. =P
02:22:11 <opqdonut> yeah i guess repeated filterings might be as good too
02:23:33 <glguy> after gzip, the log is 119M
02:25:07 <paolino> @pl \(m,q) -> (+q).(*m)
02:25:07 <lambdabot> uncurry (flip ((.) . (+)) . (*))
02:26:09 <paolino> @info Eq
02:26:09 <lambdabot> Eq
02:26:12 <wagle_home> gzip --best?
02:26:18 <paolino> @hoogle Eq
02:26:18 <lambdabot> Data.Eq :: module
02:26:18 <lambdabot> Prelude.Eq :: class Eq a
02:26:18 <lambdabot> Data.Eq.Eq :: class Eq a
02:26:32 <glguy> wagle_home: that was with gzip and no flags
02:26:48 <glguy> does gzip --best offer much over bzip2?
02:27:25 <wagle_home> i have the impression that bzip2 is supposed to be better than gzip, but have no data
02:27:34 <opqdonut> faster at least
02:28:09 <glguy> is bzip2 slow to decompress too?
02:28:11 <glguy> or just to compress?
02:29:22 <wagle_home> dunno..  and i dunno is bzip2 has zgrep
02:29:30 <wagle_home> dunno..  and i dunno if bzip2 has zgrep
02:29:49 <glguy> bzgrep
02:29:56 <glguy> but more importantly, bzcat
02:29:58 <Cheery> @hoogle Path
02:29:59 <lambdabot> Data.Graph.path :: Graph -> Vertex -> Vertex -> Bool
02:29:59 <lambdabot> Distribution.Simple.InstallDirs.PathTemplate :: data PathTemplate
02:29:59 <lambdabot> Distribution.Simple.InstallDirs.PathTemplateVariable :: data PathTemplateVariable
02:30:03 <wagle_home> i'd time it yourself..  a few hours of amusement
02:30:49 <wagle_home> didnt find bzgrep on my machine
02:31:11 * dolio has bzgrep.
02:31:53 <glguy> bzip2 --best only took it down to 99M
02:32:59 <glguy> and it is just over 4x slower to decode
02:33:06 <glguy> (grep through)
02:34:17 <wagle_home> dolio, what package is bzgrep in?
02:35:04 <dolio> Part of bzip2, here.
02:35:15 <glguy> â””â”€(%)â”€â”€ rpm -qf `which bzgrep`
02:35:16 <glguy> bzip2-1.0.4-12.fc8
02:36:11 <glguy> gzip --best had the same results as -6 (default) 119M
02:36:16 <glguy> and fast grep too :)
02:36:33 <glguy> all this searching has kicked my fan on though
02:36:35 <wagle_home> hmm..  bzgrep not in bzip2 on suse 10.1
02:37:05 <glguy> do you use suse because it defaults to kde?
02:37:42 <wagle_home> i needed xen..  first try was fedora 7..  that didnt work.  next try was suse 10.1..  that worked
02:37:57 <glguy> ah, figured there was some special reason
02:38:16 <dolio> I tried out suse recently and it frightened me back to kubuntu.
02:38:22 <wagle_home> haha
02:39:18 <dolio> For example, the installer numbered my hard drives wrong, so I had to edit the boot command in grub to get it to work at all after installing. :)
02:44:23 <wagle_home> sounds more like a weird bios, but yeah
02:49:05 <ttt--> "The @pl (point-less) plugin is rather infamous for using the (-> a) monad to obtain concise code. "
02:49:22 <ttt--> could someone explain to me what this means :)
02:49:59 <Heffalump> I thought it used (r ->) mostly
02:50:15 <dolio> Yeah, that should be (->) a, not (-> a).
02:50:20 <Heffalump> which is a reader monad
02:50:35 <Heffalump> functions from some fixed type to any return type form a monad
02:50:37 <ttt--> is (->) a function?
02:50:43 <Heffalump> it's the type of a function
02:51:24 <wagle_home> @djinni (->)
02:51:25 <lambdabot> Cannot parse command
02:51:33 <wagle_home> @djinn (->)
02:51:33 <lambdabot> Cannot parse command
02:51:55 <quicksilver> any haxmlxperts?
02:52:11 <dolio> a -> b can also be written (->) a b
02:52:32 <quicksilver> I can't see an adjacency combinator.
02:52:44 <quicksilver> E.g. <foo/> "just after" <bar/>
02:54:40 <wagle_home> ok..  i cant think of a function of type (->), but am prepared to be surprised
02:55:04 <dolio> (->) isn't a type by itself. It's a type constructor.
02:55:17 <wagle_home> <ttt--> is (->) a function?
02:55:17 <wagle_home> <Heffalump> it's the type of a function
02:56:24 <dolio> At least, if by "type" you mean things with kind *.
02:57:03 <wagle_home> :k (->)
02:57:05 <lambdabot> ?? -> ? -> *
02:57:26 <wagle_home> oo..  question marks
02:57:36 <dolio> That would be * -> * -> *, except for the special unboxed kinds GHC has.
02:57:41 <wagle_home> i was expecting * -> * -> *
02:59:00 <dolio> ? is the union of * and #, and ?? is the union of ? and (#), I believe.
02:59:31 <wagle_home> what's #?
02:59:56 <ttt--> so "(-> a)" is just "a"?
03:00:15 <dolio> # is unboxed values (like, Int#, Word#, etc. machine values allocated on the stack, or something like that).
03:00:35 <dolio> (#) is unboxed tuples.
03:00:39 <dolio> Oh, I may have that backwards.
03:00:55 <wagle_home> ah, thanks
03:01:05 <dolio> Since unboxed tuples are for returning multiple results in registers.
03:01:14 <dolio> So ? is probably (#) and ??, and ?? is # and *.
03:01:21 * wagle_home sleeps now
03:01:36 <wagle_home> gnite
03:01:36 <ttt--> > (-> a) Int
03:01:36 <lambdabot>  Parse error at "->" (column 2)
03:01:55 <wagle_home> :t (-> a) Int
03:01:56 <lambdabot> parse error on input `->'
03:02:00 <wagle_home> aww
03:02:15 <quicksilver> :k ((->) a) Int
03:02:16 <lambdabot> Not in scope: type variable `a'
03:02:22 <quicksilver> :k ((->) Double) Int
03:02:22 <dolio> (-> a) isn't actually valid syntax, because you can section type operators.
03:02:23 <lambdabot> *
03:02:43 <quicksilver> it also wouldn't have a type (":t") because it isn't a value.
03:02:45 <wagle_home> cant..  oh yeah
03:02:50 <quicksilver> it is a type, so it has a kind.
03:03:03 <dolio> Ah, yeah, can't.
03:04:37 <dolio> (->) a is like the class of functions with domain 'a'.
03:05:03 <dolio> If you think of 'M = (->) a' then 'M b = a -> b' and 'M c = a -> c'.
03:06:06 <dolio> So, monads have lots of associated functions.
03:06:16 <dolio> Like join :: M (M a) -> M a.
03:06:42 <dolio> That becomes: join :: r -> (r -> a) -> (r -> a) (sorry about the switch to r).
03:06:58 <dolio> Oops, (r -> r -> a) -> (r -> a)
03:06:58 <oerjan> missing parentheses
03:08:07 <dolio> Which, if you look at the type, it must be duplicating the argument. So: join (\x y -> x + y) = (\x -> x + x).
03:08:46 <dolio> And there's also ap :: M (a -> b) -> M a -> M b ==> (r -> a -> b) -> (r -> a) -> r -> b, which happens to be the S combinator.
03:09:42 <dolio> s g f r = g r (f r)
03:10:17 <oerjan> > ap g f x :: Expr
03:10:17 <lambdabot>  Add a type signature
03:10:29 <oerjan> > ap g (f::Expr->Expr) x :: Expr
03:10:30 <lambdabot>  g x (f x)
03:10:57 <oerjan> hm i think a functional dependency might help...
03:11:46 <dolio> > join f x
03:11:46 <lambdabot>  Add a type signature
03:11:59 <dolio> > join (f :: Expr -> Expr -> Expr) x
03:12:00 <lambdabot>  f x x
03:12:15 <oerjan> oh right
03:12:19 <oerjan> it cannot be
03:19:01 <paolino> @pl \(uncurry (***) $  uncurry (***) (max,min) (2,3))
03:19:01 <lambdabot> (line 1, column 11):
03:19:01 <lambdabot> unexpected "("
03:19:01 <lambdabot> expecting operator or ")"
03:19:31 <paolino> @pl (uncurry (***) $  uncurry (***) (max,min) (2,3))
03:19:31 <lambdabot> uncurry (***) ((max *** min) (2, 3))
03:21:17 <oerjan> @unpl uncurry (***) ((max *** min) (2, 3))
03:21:17 <lambdabot> uncurry (***) ((max *** min) (2, 3))
03:21:56 <paolino> (max 2 *** min 3)
03:25:02 <paolino> @hoogle (a,b) -> (b,a)
03:25:02 <lambdabot> No matches, try a more general search
03:29:59 <Heffalump> paolino: some combination of flip and uncurry and id and curry does the job
03:30:04 <Heffalump> @pl \(a,b) -> (b,a)
03:30:04 <lambdabot> uncurry (flip (,))
03:30:19 <Heffalump> ah yes, (,) = curry id
03:45:24 <Cheery> @src Reader
03:45:24 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
03:45:29 <Cheery> @src Monad.Reader
03:45:33 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
03:45:44 <Cheery> BOB lol!
03:46:02 <oerjan> Bob was there, too.
03:46:34 <oerjan>  @src doesn't take module qualifiers.  it it's not there, it's not there.
03:46:41 <oerjan> afaik
04:05:18 <Lemmih> @seen Saizan
04:05:18 <lambdabot> Saizan is in #haskell-soc, #haskell-blah, #haskell-overflow and #haskell. I last heard Saizan speak 9m 20s ago.
04:05:54 <Lemmih> Saizan: PrivateGroup -> Group is not exported in hspread-0.2.
04:07:10 <Saizan> uhm
04:08:25 <Saizan> Lemmih: and you need it to send a privmsg, right?
04:08:44 <Lemmih> Saizan: Right.
04:09:39 <Peaker> what is the "base" package? is that ghc itself?
04:09:57 <Peaker> (Can't find it on hackage)
04:10:09 <dolio> It comes with ghc, but it's not just ghc.
04:10:38 <dolio> There's code for other compilers in it.
04:11:10 <Peaker> ok but I don't need to install it then
04:11:26 <dolio> No. If you have a compiler, you should have it.
04:11:31 <Peaker> the hackage.haskell.org is uploading to me at a whopping 1.7KB/sec
04:11:34 <Saizan> Lemmih: suggestions for the name? i've fromPrivateGroup here
04:12:18 <Lemmih> Saizan: Perhaps it should be a type synonym instead of a newtype.
04:12:38 <wy> @pl \y->f x == f y
04:12:38 <lambdabot> (f x ==) . f
04:16:41 <DukeDave> Erm, a bit of a simple monad question:    If I have 'f :: IO [a]' how do I apply 'length :: [a] -> Int' to get 'IO Int'
04:18:22 <DukeDave> Hmm, I have 'liftM length $ f'
04:18:27 <Peaker> downloading all the dependencies of cabal-install manually is crazy, its dozens!
04:21:18 <Lemmih> Peaker: All but two should be installed by default.
04:21:32 <Peaker> Lemmih, how do I know what's installed by default and what isn't?
04:22:08 <Lemmih> Peaker: Try to install the package. Cabal will complain about missing dependencies.
04:22:55 <Saizan> Lemmih: given that PrivateGroups are mostly given or used internally it makes sense, i'll make that change after lunch
04:23:18 <Peaker> Lemmih, how do I try to install the cabal-install package?
04:25:25 <Lemmih> Peaker: Download it and run 'runhaskell Setup.hs configure'.
04:26:26 <Peaker> $ runhaskell Setup.hs configure
04:26:26 <Peaker> Setup.hs: cabal-install.cabal:30: Invalid syntax (no colon after field name)
04:27:22 <Lemmih> Peaker: Your version of cabal is too old.
04:27:39 <Peaker> Its the best Ubuntu gutsy has got :(
04:28:04 <Peaker> well I did download all the dozens of dependencies manually
04:28:10 <Peaker> is it possible to install them in my homedir somehow?
04:29:06 <Lemmih> Peaker: Sure, configure with --prefix=... and --user.
04:30:33 <Peaker> my cabal is too old to install a newer Cabal
04:31:02 <Lemmih> Peaker: Cabal should bootstrap itself.
04:32:31 <Peaker> running runhaskell Setup.lhs --help is taking ages...
04:35:37 <Lemmih> Peaker: Good.
04:35:47 <Saizan> Peaker: you can compile it first, with ghc --make Setup.lhs
04:36:04 <Peaker> thanks
04:42:49 <Jaak> @paste
04:42:49 <lambdabot> Haskell pastebin: http://hpaste.org/new
04:44:01 <hpaste>  Jaak pasted "unsafeCoerce" at http://hpaste.org/6202
04:44:35 <Jaak> is there a way to write lookup without unsafeCoerce?
04:45:02 <Jaak> i think not, but i'm not sure...
04:45:53 <Lemmih> Jaak: You can make it safer by using Data.Typeable.
04:46:09 <ndm> Jaak: no, and i can tell that from the type signature alone
04:46:45 <Peaker> I've installed Cabal into ~/.haskell,  how do I now make it used, instead of my older system-wide Cabal?
04:46:46 <ndm> Jaak: there is no way that can be the correct type signature...
04:47:05 <ndm> Peaker: you can install it using cabal, runhaskell Setup configure/build/install in the cabal directory
04:47:41 <Jaak> well, yeah. but i have no idea what might be better signature there
04:48:58 <boyscared> anyone know if the catsters have higher quality downloadable videos somewhere?
04:49:10 <boyscared> grainy, streaming video hurts my brain
04:49:22 <Peaker> ndm, I think its already "installed", in my ~/.haskell, and now it has a bunch of .a and .o files in my ~/.haskell/lib/...  will those get used if I try to use cabal?
04:50:19 <Jaak> or if there even is better signature...
04:51:10 <ndm> Jaak: well, with that type signature it is going to remain unsafe
04:51:26 <wy> @pl (\a b -> f a `compare` f b)
04:51:26 <lambdabot> (. f) . compare . f
04:51:41 <ndm> Jaak: i suspect you'll have to remove the Forall in P
04:52:13 <Jaak> ndm: but how else can i implement environment?
04:52:17 <ndm> Peaker: did you install it with runhaskell Setup install?
04:52:26 <ndm> Jaak: why does Env have to be Env, and not Env a
04:52:38 <Peaker> ndm, Yeah, it now sits in my homedir
04:52:52 <ndm> Peaker: in that case it should be installed and used
04:53:17 <ndm> Jaak: if i was doing it, i wouldn't use GADT's or existentials, and it would be safer, more H98, and simpler
04:54:55 <quicksilver> ndm: how's your haxml?
04:54:56 <Jaak> ndm: true that. i was just toying around with GADTs at first, then i got messy
04:55:03 <Jaak> it*
04:55:44 <ndm> quicksilver: noexistant
04:55:50 * quicksilver nods
04:55:57 <ndm> Jaak: yeah, the second you roll out unsafeCoerce, you've gone wrong
04:56:12 <ndm> Jaak: and i'm fairly sure that use of unsafe coerce could be exploited to segfault
04:56:16 <ndm> quicksilver: use tagsoup instead :)
04:56:28 <quicksilver> if you must use unsafeCoerce, you should at least conceal it in Dynamic.
04:56:32 <quicksilver> which is externally safe.
04:56:32 <Jaak> yes, yes it can :)
04:56:43 <quicksilver> but I'm pretty sure that's not the right approach at all.
04:56:52 <ndm> Jaak: you should like you are speaking from experience :)
04:56:53 <quicksilver> ndm: well, I am certainly considering it.
04:57:02 <ndm> quicksilver: what is the problem you want to solve?
04:57:06 <quicksilver> ndm: I really was just playing with haxml for the sake of it.
04:57:13 <quicksilver> ndm: extracting data from a big XML file.
04:57:35 <ndm> quicksilver: tagsoup was born to do that, and it does it well - some people run it on 36Gb XML files
04:57:53 * ndm does not recommend or endorse such big XML files
04:58:24 <quicksilver> I have used tagsoup successfuly in the past.
04:58:28 <quicksilver> I like it.
04:58:29 <Jaak> meh, gadts aren't that great anyways
04:58:39 <ndm> Jaak: i agree, many people disagree :)
04:58:43 <quicksilver> As I say, I was playing with HaXml just to see what it was like.
04:59:02 <ndm> from my (very brief) look it seemed rather complex
04:59:20 <ndm> i.e. rather than learning XPath, you have to learn a Haskell encoding of XPath
04:59:47 <quicksilver> I think it's quite a nice API, just lacking in motivational documentation.
04:59:54 <quicksilver> but it does appear to be mostly context-free.
05:00:01 <quicksilver> and I need something context-sensitive.
05:00:24 <quicksilver> (find the <dict> element immediately follwing the <key> element with content "Tracks")
05:01:03 <ndm> sounds like a 1 liner in tagsoup
05:01:33 <quicksilver> well that's only the first part of the task. Then I have to process the content of the <dict> tag of course :)
05:01:54 <ndm> yeah, in the darcs tagsoup there is a TagSoup.Tree module, which may be of use
05:02:01 <Peaker> ndm, I try to build cabal-install now, but it cannot find Distribution.Simple, and I don't see why it'd be using files I installed in ~/.haskell/lib/...
05:02:03 <ndm> no gurantees, but i use it myself for some things
05:02:06 <ndm> entirely strict
05:02:25 <ndm> Peaker: if you installed cabal using cabal it shouled all work
05:05:28 <Saizan> Lemmih: pushed to http://happs.org/repos/hspread
05:05:41 <Lemmih> Saizan: Thanks.
05:06:30 <Saizan> Peaker: does ghc-pkg list lists the new Cabal as well?
05:07:30 <Peaker> Saizan, oh, it does! cool thanks
05:13:24 <quicksilver> Saizan: hspread? is that spreadlog?
05:16:38 <Lemmih> quicksilver: spread.org
05:18:14 <quicksilver> yeah, that's what I meant.
05:18:27 <quicksilver> we use that at work. nice thing.
05:20:34 <Baughn> In cabal, is "alpha" considered more or less stable than "experimental"?
05:21:40 <Lemmih> What's up with the recent changes on the Haskell wiki?
05:22:27 <Baughn> Lemmih: What do you mean? Is there something up?
05:23:01 <ndm> Baughn: i'd say more stable
05:23:55 <Lemmih> Baughn: It is very empty. Less than 50 changes in the last 30 days.
05:24:04 <quicksilver> Baughn: I would be surpised if there was any consensus.
05:24:17 <quicksilver> Baughn: "alpha" is supposed to mean "not yet feature complete"
05:24:21 <Baughn> Lemmih: Oh. In that case, you should fill it with something that improves on emptiness
05:24:26 <Lemmih> I know for sure that Happs2 has been changed recently but it isn't on the list.
05:24:31 <quicksilver> I could imagine different authors using experimental + alpha for the same things.
05:24:45 <Baughn> Lemmih: Ah, do you mean http://haskell.org/haskellwiki/Special:Recentchanges ?
05:24:49 <lambdabot> Title: Recent changes - HaskellWiki
05:25:05 <Lemmih> Baughn: Yeah.
05:25:25 <Baughn> Lemmih: That's just for changes to the /wiki/
05:26:01 <Lemmih> Oh, doh. I looked at the wrong page.
05:26:48 <Peaker> back, what can I do about " Could not find module `Distribution.Simple':"?
05:26:55 <Peaker> where is it supposed to be found?
05:27:01 <Peaker> (Trying to build cabal-install)
05:27:31 <Baughn> quicksilver: Is it possible to say something like "instance Castable a, b, c => a -> c where cast (a::a) = cast (cast a :: b) :: c"?
05:27:55 <Baughn> Peaker: Well, that's part of cabal..
05:28:18 * Baughn is stumped. That should be part of GHC.
05:28:32 <Peaker> Baughn, I run Setup install in the Cabal directory, and ghc-pkg list   shows Cabal installed in ~/.haskell
05:28:56 <Baughn> quicksilver: ..never mind, that syntax is so broken it hurts
05:29:07 <Peaker> I have "Distribution" files but not "Distribution.Simple"
05:29:58 <Baughn> Peaker: As I said, cabal should be part of ghc - and probably installed system-wide, come to think of it. Does ghc-pkg list show cabal *only* in ~/.haskell?
05:30:08 <Baughn> Peaker: Also, which version of cabal?
05:31:05 <Peaker> Baughn, /usr/lib/ghc-6.6.1/package.conf: shows Cabal-1.1.6.2,  but I installed /home/peaker/.ghc/x86_64-linux-6.6.1/package.conf:  Cabal-1.2.3.0
05:31:39 <Baughn> Peaker: I don't know. You could try wiping ~/.haskell and installing the newer cabal system-wide
05:31:54 <Baughn> Peaker: Or recompile ghc against that cabal, so you avoid any problems
05:32:19 <Peaker> Baughn, I don't know much about Haskell/ghc.. I could run configure/build/install on the newer Cabal as root I guess
05:32:21 <Peaker> (without --prefix)
05:32:23 <Peaker> will that work?
05:32:29 <Baughn> Yes
05:32:34 <Baughn> Unless it breaks everything
05:32:58 <Peaker> Baughn, it installed in /usr/local
05:33:01 <Baughn> Peaker: Cabal-1.2.3.0 does have Distribution.Simple; I don't know if 1.1.6.2 does, but it might be overriding your local version. Or, more likely, cabal-install just isn't looking there to begin with.
05:35:02 <Saizan> Baughn: you don't compile ghc against a cabal
05:35:22 <nolrai> :k Cont
05:35:24 <lambdabot> * -> * -> *
05:35:30 <Baughn> Saizan: I was thinking mostly of the bundled libraries
05:35:33 <Baughn> Surely they use cabal?
05:35:58 <Peaker> Baughn,  find /usr/local/lib/Cabal-1.2.3.0 -name "*Distribution.Simple*" finds nothing
05:36:05 <Saizan> yeah, but that's not relevant
05:36:43 <quicksilver> 1.1.6 does have Distribution.Simple.
05:37:02 <Baughn> Peaker: It should be "/usr/local/lib/ghc-6.8.2/lib/Cabal-1.2.3.0/Distribution/Simple"
05:37:21 <Peaker> Oh, that exists
05:37:43 <Baughn> So, if you say :module + Distribution.Simple in ghci?
05:37:48 <Peaker> building cabal-install's Setup.hs fails with: Could not find module `Distribution.Simple':
05:38:05 <Peaker> Could not find module `Distribution.Simple':
05:38:29 <Saizan> Peaker: do you have only one ghc installed?
05:38:56 <Baughn> Peaker: What does 'which ghc' say?
05:39:08 <Peaker> it lists "~/.haskell/lib/Cabal-1.2.3.0/ghc-6.6.1/Distribution/Simple.hi" as one of the locations it searched!
05:39:15 <Peaker> Saizan, I think so
05:39:23 <Peaker> /usr/bin/ghc
05:39:39 <Peaker> which goes through /etc/alternatives to: /usr/lib/ghc-6.6.1/bin/ghc
05:39:47 <Baughn> Peaker: Well, that's wrong. It seems you're mixing your distribution's ghc with your own
05:39:56 <Saizan> yeah
05:39:57 <Lemmih> Peaker: I'd recommend getting 6.8.2. It makes everything easier.
05:40:04 <Baughn> Peaker: Uninstall the OS's, and it should work. You'll probably have to open a new terminal window.
05:40:32 <Baughn> Peaker: In any case, ghc 6.6.1 can't use binaries from 6.8.2
05:40:59 <nolrai> any one here understand unimo?
05:41:46 <skorpan> i have a "data A = B b | C c | D d" and want to create an instance of Ord for those types.. is "instance Ord A where" what i should start with?
05:42:09 <Peaker> Baughn, I see, I wish it just had apt... How does darcs avoid the dependency hell?
05:43:01 <nolrai> skorpan: yes
05:43:23 <Saizan> Peaker: didn't you take the binary from haskell.org/ghc ?
05:43:30 <Lemmih> skorpan: data A b c d = ... ?
05:43:39 <Peaker> Saizan, I used my Ubuntu's ghc
05:43:51 <Peaker> Saizan, If I have to install everything from scratch, I think I'll just give up..
05:44:00 <Peaker> Saizan, I wanted to install a Haskell IDE but it is so much trouble :(
05:44:02 <Saizan> Peaker: and compiled 6.8.2?
05:44:19 <skorpan> nolrai: and then just do a bunch of pattern matching?
05:44:24 <Peaker> Saizan, no, I just tried to install a new Cabal because my built-in Cabal was too old
05:44:35 <Peaker> Saizan, I don't think I built a ghc at all
05:44:46 <Baughn> Peaker: WHat do you mean, "avoid"?
05:44:50 <nolrai> skorpan: thats what i would do.
05:45:05 <Peaker> Baughn, well  I guess darcs is packaged properly by Ubuntu...
05:45:13 <Baughn> Peaker: I reinstall haskell from scratch every week or so. I have a script for it.
05:45:22 <Baughn> Peaker: It does help that haskell /binaries/ are statically linked
05:45:25 <Peaker> Baughn, If users have to go through what I have to go through here, in order to practically use Haskell, its a _huge_ barrier of entry
05:45:29 <skorpan> nolrai: in my case it would be about 32 rules :/
05:45:34 <Baughn> Peaker: Yes
05:45:59 <Baughn> Peaker: It is getting better. Once 6.8.2 is in your distribution, it should be possible to put cabal-install there too
05:46:00 <Saizan> Peaker: i've never had it so hard as you
05:46:07 <Baughn> Peaker: cabal's interfaces are calming down, too
05:46:56 <Peaker> well, I'll just go through the tutorial in theory and not use it until Ubuntu has a usable package for it, I think
05:47:23 <Baughn> Peaker: That could be a year. The price of living at the bleeding edge is that you have to understand these things..
05:47:38 <Baughn> Peaker: Anyway, it's /easy/ now. I haven't had to edit a library to get it to compile in /months/.
05:47:50 <Saizan> Peaker: http://haskell.org/ghc/download_ghc_682.html#x86linux is painless to install, if you remove the one that comes with ubuntu first
05:47:52 <lambdabot> Title: GHC: Download version 6.8.2
05:48:20 <Baughn> From what I understand, he's already installed it - and somehow compiled cabal against it, to boot.
05:48:26 <Baughn> He just needs to remove ubuntu's
05:48:38 <Peaker> Baughn, well, I'd rather be able to just use a Haskell IDE and cool libraries to toy with and learn Haskell, rather than first learn about its library loading order, its meaningful files, etc.  Before I am even sure I like the language and want to use it at all
05:48:45 <Saizan> Baughn: the only reference to 6.8.2 was in your lines, afaik
05:49:06 <Baughn> Right you are. I misread.
05:49:26 <Baughn> So remove ubuntu-ghc, and remove ~/.haskell
05:49:44 <Saizan> Peaker: you don't need to know those things, it seems just like something is screwed up in your installation
05:49:50 <Peaker> Baughn, and install a new ghc like a Slackware user? :(
05:50:02 <Baughn> Peaker: You're the one who installed two copies of ghc. You're also the one who's trying to use cabal-install, which /is/ an experimental program..
05:50:17 <Peaker> Baughn, I don't think I have two copies of ghc
05:50:28 <Baughn> Peaker: You could also remove the /usr/local version of ghc, but then you're mostly stuck to the libraries that are bundled with ubuntu
05:50:32 <Peaker> Baughn, I am trying to build it, not use it, yet :)
05:50:57 <Peaker> Baughn, I don't have a /usr/local version of ghc, I have a /usr/local version of Cabal
05:51:11 <Cheery> haskell should obviously have support for flexible records
05:51:31 <Baughn> Cheery: Everyone agrees. Nobody agrees on exactly /how/.
05:51:35 * wli wants flexible variants more so.
05:51:54 * Baughn just wants to stop typing dataTypeNameAccessorFoo foo
05:52:01 <Cheery> relational databases and various other records would love them
05:52:09 <Cheery> [AuthFileEntry Local "bluebox" "0" "MIT-MAGIC-COOKIE-1" "****************",AuthFileEntry Local "localhost.localdomain" "0" "MIT-MAGIC-COOKIE-1" "****************"]
05:53:02 <Cheery> think about starting to shove -things away from that
05:53:04 <Baughn> Peaker: I recommend a wipe and reinstall (of /usr/local and ~/.haskell)
05:53:26 <Baughn> Peaker: Mostly because then I don't have to figure out your exact setup without shell access. ;)
05:53:34 <Peaker> Baughn, I need to install ghc 6.8.2 manually?
05:53:46 <Baughn> Peaker: Unless ubuntu has a copy somewhere, /yes/
05:53:56 <Peaker> Ubuntu only has 6.6.1
05:54:02 <Saizan> Peaker: http://haskell.org/ghc/dist/6.8.2/maeder/ghc-6.8.2-i386-unknown-linux.tar.bz2
05:54:03 <Baughn> Peaker: You can perfectly well write haskell code with 6.6.1, but a lot (a LOT) of libraries won't work
05:54:06 <lambdabot> http://tinyurl.com/3cqaam
05:54:33 <Baughn> Peaker: Oh, and there seems to be a 20-50% speed increase for code compiled with 6.8.2
05:55:04 <Peaker> ok I'll install ghc manually
05:55:16 <Cheery> Baughn: my proposal is that one would just make {} tuples (to remove commas), and give some functions to modify this sort of 'records' on primitive level
05:55:23 <Peaker> could be nice if someone held up an apt repo for newer ghc's
05:55:51 <quicksilver> Baughn: really? I use 6.6.1 constantly and I've never found a single library which didn't work.
05:56:57 <Peaker> what in ghc takes 41MB? is it more than source code?
05:57:01 <Baughn> It's probably more of a problem with the darcs versions of the libraries. Though..
05:57:10 <Cheery> so you could write something like: mapFilter (where authfamily Local) [{Local "bluebox" etc...
05:57:18 <Baughn> quicksilver tends to be right. If he says you won't get trouble, you won't.
05:57:33 <Saizan> Peaker: that's a binary distribution, with some libraries
05:58:10 <Baughn> Peaker: The /source/ is more like.. 500MB.
05:58:19 <Peaker> so, given a clean 6.6.1 ghc install in Ubuntu, and nothing in /usr/local or ~/.haskell, how do I build/install cabal-install ?
05:58:27 <Peaker> Baughn, 500MB of source code?!
05:58:31 <mulander> Peaker: did you try https://launchpad.net/ubuntu/hardy/hppa/ghc6-doc/6.8.2-1ubuntu1
05:58:35 <Baughn> Peaker: Post-compile
05:58:42 <Peaker> Baughn, how much pre-compile?
05:58:58 <Peaker> mulander, that's for hardy
05:59:26 <mulander> Peaker: I know, but there's a chance it will work fine :)
05:59:52 <Peaker> mulander, I'd rather try going the official way first :)
06:00:07 <Baughn> Peaker: 6.7MB after bzip2, so probably.. 20-30MB? 50?
06:00:31 <mulander> Peaker: well suite yourself, but a .deb from the same distro just few versions back is less trouble then source install
06:00:40 <mulander> Peaker: because it still get's noticed by your package manager
06:00:45 <Laney> Peaker: I've had some success using 6.8 from Hardy on my Gutsy install, just FYI
06:00:54 <Peaker> Laney, thanks
06:01:05 <Peaker> Baughn, ok, I have a clean state now
06:01:13 <Laney> Peaker: This was adding the hardy repos to sources.list and using "sudo aptitude install ghc6/hardy"
06:01:31 <Peaker> Baughn, with this being the only ghc6, and no Cabal installed other than the default one: ii  ghc6                      6.6.1-2ubuntu
06:01:57 <Peaker> Baughn, ghc-pkg list  shows just the default stuff
06:02:16 <Baughn> Peaker: Okay. What does ghci say if you try :module + Distribution.Simple now?
06:02:30 <Peaker> it works
06:02:34 <Peaker> Prelude Distribution.Simple>
06:03:00 <Baughn> Yeah, probably. It isn't fully loaded until you /use/ it, but it should be fine.
06:03:25 <Peaker> ghc --make Setup.hs  in cabal-install also worked
06:03:28 <Peaker> but now Cabal is too old
06:03:46 <Peaker> it can't read the cabal file of cabal-install
06:04:01 <Peaker> so I try to buil dCabal-1.2.3.0
06:04:04 <Peaker> to build, that is
06:04:17 <Baughn> Right. Now, you /could/ try updating cabal, but in my experience having two separate copies of it installed is a recipe for disaster
06:04:33 <Peaker> well, that's what I had, and going to have now, unless it can overwrite the old one?
06:04:54 <Baughn> You could try, but overwriting things in /usr/ is probably even worse
06:04:58 <Peaker> so there's no way for me to install a new Cabal that works?
06:05:12 <Peaker> unless I install everything without Ubuntu's help?
06:05:17 <Lemmih> Multiple copies of Cabal works just fine for me.
06:05:19 <Baughn> There's always.. yeah, that
06:05:31 <Peaker> ok, I'm back to waiting until it distribution matures to be usable
06:05:43 <Baughn> What do you need cabal-install for, though?
06:06:07 <Baughn> Packages build fine without it. Yes, manually, but that's one command per package (with appropriate &&s)
06:06:29 * Saizan has 4 versions of cabal
06:06:54 * Baughn only has one, and got version conflicts anyway
06:07:07 <Baughn> "This version of cabal (1.3.6) requires cabal 1.3.5 or lower
06:08:33 <Baughn> Peaker: You could always /try/ installing an extra cabal. If you're not going to use it otherwise, it falling apart again won't hurt you.
06:08:47 <Cheery> http://mureakuha.com/paste/?4c7eed4071648253f3e25951e7d9a73d
06:08:53 <Cheery> yay, got a response
06:09:34 <Baughn> Peaker: It'd be best to install with --user. Not that you also have to run setup with --user to make it /look/ at local libraries - makes sense, though
06:09:54 <Peaker> Baughn, that's what I did before, and I --prefix'd the new Cabal into ~/.haskell too
06:10:02 <Baughn> Peaker: Don't do that
06:10:07 <Baughn> Peaker: Just use --user, no --prefix
06:10:10 <Peaker> Baughn, ok I'll try
06:11:01 <Baughn> Peaker: Oh, and s/Not/Note/ - you *do* have to use --user for setup to look in your homedir for needed libraries
06:11:06 <Peaker> Baughn, hmm, I installed Cabal after configure --user, and install -v shows its copying to /usr/local, but I'm not root...?
06:11:56 <Peaker> oops, silly me I was root
06:12:05 * Baughn blinks
06:12:20 <Peaker> ok, now I am not root, and its STILL trying to do that, but now its ofcourse failing
06:12:29 <Baughn> You need to configure it again
06:12:51 <Baughn> Probably after cleaning as root, as there may now be files in there you don't have access rights too
06:12:51 <Lemmih> Baughn: Why shouldn't he use --prefix?
06:12:54 <Peaker> I did, but I think it didn't do anything, so now I cleaned and am rerunning it
06:13:17 <Baughn> Lemmih: ~/.haskell isn't in the default search path; the default ~/.ghc is. Just making it easier.
06:13:25 <dcoutts_> Peaker: are you using cabal-install or are you using the runghc Setup.hs interface?
06:13:40 <mulander> Baughn: he can export the path to $PATH
06:13:50 <Peaker> dcoutts, the latter (though I use ghc --make Setup.hs and then I use Setup directly)
06:13:53 <Lemmih> Baughn: He's using plain Setup so it defaults to /usr/...
06:13:59 <dcoutts_> Peaker: in the development version of Cabal we recently changed --user to imply --prefix=$HOME/.cabal
06:14:09 <Baughn> Lemmih: What, even with --user?
06:14:14 <dcoutts_> while the --global default prefix remains /usr/local
06:14:38 <Peaker> compiling Cabal after a clean is taking ages
06:14:41 <Lemmih> Baughn: Yeah.
06:14:59 <Baughn> Lemmih: Then why does everything get put in ~/.ghc here?
06:15:16 <dcoutts_> Peaker: you're using Cabal-1.3.x or the stable 1.2.3.0 version?
06:15:29 <Lemmih> Baughn: You're must likely using the development version.
06:15:51 <Peaker> dcoutts, I'm trying to build Cabal-1.2.3.0
06:16:10 <dcoutts_> Peaker: ah ok, so in that version --global/--user do not affect the default --prefix
06:16:53 <dcoutts_> Peaker: by default it'll use --global and --prefix=/usr/local
06:17:18 <dcoutts_> if you want a per-user install, you'd have to use --user --prefix=$HOME/somewhere
06:17:32 <dcoutts_> we simplified it in the latest version
06:17:49 <dcoutts_> and with cabal-install it's even simpler, it defaults to a user install into $HOME/.cabal
06:18:01 * dcoutts_ uses cabal-install exclusively
06:20:26 <Lemmih> dcoutts_: Btw, do you have any idea why *.haskell.org has been so slow lately?
06:21:10 <dcoutts_> Lemmih: darcs. and hackage. are hosted at galios and their server was under very heavy load, not sure why, so they were rate limiting connections
06:21:19 <dcoutts_> Lemmih: you'll have to ask dons for more details
06:23:20 <Heffalump> how busy do they get?
06:23:36 <Lemmih> I wonder if there's an easy way of maintaining darcs mirrors.
06:25:08 <dcoutts_> Lemmih: we need to find out first if it was a DoS attack or if it was just high legitimate load
06:25:49 <dcoutts_> if the latter we should think about disaggregating services from that server and using mirrors
06:26:20 <dcoutts_> but we need to know first what services are sucking the bandwidth, eg darcs, trac or hackage downloads
06:27:40 <Lemmih> Having mirrors of the darcs repos would be nice even if DoS attacks seldom happens. Several of the repos on *.haskell.org are essential for my work.
06:28:16 * Heffalump could probably host something, depending on load
06:28:23 <Lemmih> (I have a box in Amsterdam with a 100mbit connection that I'd love to "donate")
06:29:07 <Heffalump> it's so easy to switch that we probably don't need any automatic scheme for clients, just something in the DNS and automatic syncing by the mirrors
06:29:23 <Heffalump> switch darcs repo, that is
06:30:10 <Heffalump> of course, anyone can run a mirror without any special setup, unless automatic pulls would place too much load on the server
06:30:57 <dcoutts_> Heffalump: it might be easier to set up an auto darcs send on the server side, to darcs send to a number of subscribers
06:31:10 <dcoutts_> sorry, not easier, but less bandwidth
06:31:16 <Heffalump> ah, cunning
06:31:37 <dcoutts_> it could even be done now with a darcs apply hook
06:31:53 <dcoutts_> (probably)
06:31:59 <Heffalump> but darcs send is against a specific repo
06:32:13 <Heffalump> and you'd need to ensure that the email was distributed by something else, otherwise it'd use the same bandwidth anyway
06:32:16 * Heffalump --> lunch
06:37:19 <Y0Gi> hey. I keep failing to find out how to create a list of random numbers in haskell. what is the preferred and/or most elegant way?
06:37:31 <dolio> @type randoms
06:37:32 <lambdabot> forall g a. (RandomGen g, Random a) => g -> [a]
06:37:58 <Y0Gi> the list should contain Ints, btw.
06:38:18 <taruti> Is there any application/large example using hlists in addition to the toy ones?
06:38:25 <dolio> > randoms (mkStdGen 85) :: [Int]
06:38:27 <lambdabot>  [-1694287101,83449540,-839633381,1463969949,184262306,-459993646,-1280528057...
06:38:36 <Y0Gi> can you give me a short code example, please
06:38:44 <Y0Gi> ah
06:39:02 <dolio> You wouldn't want to use mkStdGen, though.
06:39:05 <Botje> is there a "haskell cookbook" ?
06:39:07 <dolio> @hoogle StdGen
06:39:07 <lambdabot> System.Random.StdGen :: data StdGen
06:39:07 <lambdabot> System.Random.mkStdGen :: Int -> StdGen
06:39:07 <lambdabot> System.Random.getStdGen :: IO StdGen
06:39:10 <Y0Gi> 85 is what? the seed?
06:39:23 <Y0Gi> yeah, I've tried to use StdGen so far
06:39:39 <Botje> :t getStdGen >>= randoms
06:39:40 <lambdabot>     Couldn't match expected type `IO b' against inferred type `[a]'
06:39:40 <lambdabot>       Expected type: StdGen -> IO b
06:39:40 <lambdabot>       Inferred type: StdGen -> [a]
06:39:45 <Botje> :t getStdGen >>= return randoms
06:39:46 <lambdabot>     Couldn't match expected type `IO b'
06:39:46 <lambdabot>            against inferred type `g -> [a]'
06:39:46 <lambdabot>     In the first argument of `return', namely `randoms'
06:39:48 <dolio> You'd want newStdGen.
06:39:48 <Botje> argh
06:39:52 <Botje> :t getStdGen >>= return . randoms
06:39:53 <lambdabot> forall a. (Random a) => IO [a]
06:40:18 <dolio> @type randoms `liftM` newStdGen
06:40:19 <lambdabot> forall a. (Random a) => IO [a]
06:40:25 <Botje> or that.
06:40:41 <dolio> newStdGen splits the global random generator.
06:41:23 <Y0Gi> where is the difference between the global gen and local ones? when to use which?
06:41:44 <dolio> Well, you can use a local one, but that requires you to pick a specific seed.
06:42:15 <dolio> The global one is seeded from some hopefully random source in the environment.
06:42:16 <Y0Gi> so the global gen cares for the seed itself?
06:42:51 <taruti> yes. but it is not cryptographically secure.
06:42:56 <Y0Gi> and when would I want to use the local one? I don't assume calling those with identical seeds will give me reproducable results
06:43:16 <dolio> > randoms (mkStdGen 85) :: [Int]
06:43:17 <lambdabot>  [-1694287101,83449540,-839633381,1463969949,184262306,-459993646,-1280528057...
06:43:18 <dolio> > randoms (mkStdGen 85) :: [Int]
06:43:19 <lambdabot>  [-1694287101,83449540,-839633381,1463969949,184262306,-459993646,-1280528057...
06:43:28 <dolio> Looks like the same sequence to me.
06:43:42 <nolrai> but useing the global puts you in the IO monad.
06:43:51 <Y0Gi> I see.
06:44:17 <dolio> @check \i -> take 50 (randoms (mkStdGen i)) == take 50 (randoms (mkStdGen i))
06:44:19 <lambdabot>  OK, passed 500 tests.
06:44:39 <Y0Gi> but when I don't want to use mkStdGen as dolio said above, what would I use then/how is newStdGen used?
06:44:41 <dolio> In fact, if it didn't give you the same results for the same seed, it couldn't have the type Int -> StdGen.
06:44:51 <Y0Gi> ok
06:46:33 <Botje> @src randoms
06:46:33 <lambdabot> Source not found. My pet ferret can type better than you!
06:46:47 <dolio> @src Int randoms
06:46:48 <lambdabot> Source not found. There are some things that I just don't know.
06:48:18 <Y0Gi> so what about newStdGen then?
06:48:53 <dolio> > newStdGen >>= return . randoms
06:48:53 <lambdabot>  Add a type signature
06:48:59 <dolio> > newStdGen >>= return . randoms :: IO [Int]
06:49:00 <lambdabot>  <IO [Int]>
06:49:12 <Peaker> dcoutts, so can I configure it to --prefix=~/.haskell ?
06:49:20 <Y0Gi> newStdGen implies IO?
06:49:27 <dolio> Yes.
06:49:40 <Y0Gi> and do I want that? :)
06:49:52 <dolio> How else are you going to get a random seed?
06:49:58 <dcoutts_> Peaker: no, you have to use $HOME, not ~ since the shell does not expand ~ in the middle of an argument
06:50:10 <Y0Gi> dolio: good point, thanks.
06:50:22 <Peaker> dcoutts, oh, ok
06:50:30 <dcoutts_> Peaker: you may prefer to use $HOME/.cabal as that's what cabal-install and new versions of Cabal use by default for user installs
06:52:08 <Peaker> dcoutts, its still using the old Cabal when I try to build cabal-install
06:52:35 <dcoutts_> Peaker: the darcs version of cabal-install requires the darcs version of the Cabal lib
06:52:41 <Peaker> I have an Ubuntu system-wide Cabal-1.1.6.2,  and at my home-dir: Cabal-1.2.3.0
06:52:55 <Peaker> dcoutts, ok, but I think its not even using the newer Cabal
06:53:24 <dcoutts_> Peaker: what version of cabal-install are you building? the latest version from darcs?
06:53:36 <Peaker> dcoutts, yeah
06:53:52 <dcoutts_> Peaker: ok, so you have to also install the latest Cabal from darcs too, first.
06:54:02 <dcoutts_> @where cabal-install
06:54:02 <lambdabot> http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
06:54:22 <dcoutts_> both darcs repos are linked from that page ^^^
06:54:22 <Peaker> I guess I'll give up on cabal-install then
06:54:48 <dcoutts_> Peaker: it needs latest Cabal lib, and the HTTP and zlib packages.
06:55:20 <Peaker> dcoutts, I wanted cabal-install so it wouldn't be so much of a pain to install the haskell IDE
06:55:21 <Peaker> and later others
06:55:32 <Peaker> but it seems to be a lot of work just to get cabal-install going
06:55:40 <dcoutts_> yes, it makes it a lot easier when you've got cabal-install
06:55:44 <dcoutts_> I use it all the time now
06:56:05 <Peaker> Is Leksah any good?
06:56:19 <dcoutts_> I've seen the author working on it but I've not played with it myself
06:56:27 <Peaker> what editor/IDE do you use?
06:57:17 <dcoutts_> I use nedit and vim
06:57:26 <dcoutts_> and ghci
06:57:32 <dcoutts_> and cabal-install
06:57:58 <dcoutts_> and a web browser for haddock docs
06:59:01 <Peaker> ok
06:59:09 <dcoutts_> lots of people use vim or emacs
06:59:14 <dcoutts_> both have decent haskell modes
06:59:48 <dcoutts_> gedit and several other editors have haskell syntax highlighting
07:02:30 <wy> I'm trying to find a summer internship with FP programming in the US. any ideas?
07:03:33 <Y0Gi> is there a convenient way to choose a random value from a list?
07:04:20 <Peaker> Y0Gi, random.choice
07:04:20 <Botje> get a random number , use it to index the list?
07:04:41 <Peaker> oops, wrong channel :)
07:05:04 <ndm> wy: google summer of code - see #haskell-soc
07:05:46 <Heffalump> wy: my company (Credit Suisse) potentially has things in NY
07:06:22 <Heffalump> though mostly we target grad students rather than undergrads
07:06:35 <wy> I'm grad student
07:07:09 <Y0Gi> I don't get the module system. e.g., why is there no need to explicitly import from modules like random?
07:07:29 <Heffalump> Y0Gi: probably because the Prelude re-exports stuff from it
07:07:57 <SamB> Y0Gi: in what context?
07:08:04 <SamB> Heffalump: it does?
07:08:29 <Heffalump> SamB: well, it's one possible reason; I'm guessing.
07:09:17 <scook0> Prelude, or perhaps some other module you've imported explicitly
07:09:44 <wy> Heffalump: I haven't found programmer job on the web site
07:09:45 <SamB> I really don't remember Prelude exporting Random stuff
07:10:45 <SamB> okay... WHY is ghci 6.8.2 not letting me run :b on Prelude?
07:10:58 <Lemmih> SamB: :b is breakpoint /-:
07:11:06 <SamB> Lemmih: oh
07:11:25 <SamB> why did they have to go and do that?
07:11:37 <Lemmih> SamB: They didn't mean to.
07:11:57 <SamB> so it's a regression?
07:12:05 <Lemmih> Well, it's a feature.
07:12:13 <SamB> surely not!
07:12:31 <SamB> breakpoints, yes
07:12:31 <Lemmih> :b is closer to :bre than :bro.
07:12:39 <SamB> ????
07:12:53 <SamB> how do you figure?
07:13:33 <olsner> shouldn't that give some kind of ambiguous-abbreviation-warning?
07:13:51 <SamB> really, they should explicitly add :b as an alias of :browse
07:14:36 <Lemmih> Special cases are bad.
07:14:56 <SamB> Lemmih: are they now?
07:14:58 <Lemmih> I'll vote for olsner solution. olsner: can we expect a patch?
07:15:11 <SamB> are I think olsner is also right, actually
07:15:26 <SamB> but I think :b as :browse should be explicitly added and documented
07:15:38 <SamB> s/are //
07:19:34 <Lemmih> Yeah, people keep hitting the problem and the error message is not very informative.
07:23:43 <SamB> Okay, I've created ticket #2142
07:27:30 <olsner> @index fix
07:27:30 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
07:28:05 <olsner> huh, but fix isn't a monad function?
07:28:12 <olsner> @src fix
07:28:12 <lambdabot> fix f = let x = f x in x
07:28:22 <conal> @type mfix
07:28:23 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
07:28:29 <SamB> I thought fix was in Prelude...
07:28:58 <dolio> No. It used to just be in Control.Monad.Fix, but it was moved to Data.Function.
07:29:21 <SamB> wierd.
07:43:52 <KonvIRC> Hi, I defined a function myAbs :: Num a => a -> a; myAbs x | x >= 0 = x | otherwise = -x. Hugs gives me the following error: Cannot justify constraints in explicitly typed binding;Type : Num a => a -> a; Given context : Num a;Constraints : Ord a. myAbs is identical to abs in prelude. Why do I get this error and what does this error exactly mean?
07:46:01 <dolio> @src Num
07:46:01 <lambdabot> class  (Eq a, Show a) => Num a  where
07:46:01 <lambdabot>     (+), (-), (*)           :: a -> a -> a
07:46:01 <lambdabot>     negate, abs, signum     :: a -> a
07:46:01 <lambdabot>     fromInteger             :: Integer -> a
07:46:12 <dolio> Note: Eq, not Ord.
07:47:16 <dolio> So myAbs needs a type of: (Num a, Ord a) => a -> a
07:48:13 <roconnor> KonvIRC: a quick search in http://www.haskell.org/onlinereport/standard-prelude.html and I didn't find your definiton of abs anywhere.
07:48:14 <lambdabot> Title: The Haskell 98 Report: Standard Prelude
07:50:18 <desegnis> noone ever understood what that (Eq a, Show a) is doing there, except for reducing some finger-typing (but then they could have added Ord there, too)
07:50:54 * roconnor doesn't like the Eq and Show conditions
07:51:18 <roconnor> My real numbers don't have an instance of Show or Eq.
07:51:21 <idnar> @src on
07:51:21 <lambdabot> (*) `on` f = \x y -> f x * f y
07:51:35 <KonvIRC> Its from http://undergraduate.csse.uwa.edu.au/units/230.301/lectureNotes/tourofprelude.html. This means numbers are not necessarily ordered?
07:51:38 <lambdabot> Title: A Tour of the Haskell Prelude, http://tinyurl.com/ywhnjx
07:52:24 <desegnis> that's right
07:52:42 <KonvIRC> Well, actually makes sense for e.g. complex numbers
07:52:44 <dolio> > (1 :+ 1) < (2 :+ 2)
07:52:44 <lambdabot>   add an instance declaration for (Ord (Complex t))
07:52:44 <lambdabot>     In the expression: (1...
07:53:01 <roconnor> KonvIRC: I wonder if that was from an older version of haskell?
07:53:53 <dcoutts_> hmm, what's a good two letter contraction for a Parser lib import? import qualified Text.PrettyPrint as PP is easy, but what for import qualified Text.ParserCombinators.PolyParse as ??
07:54:05 <roconnor> ... actually it says it is based on a paper for haskell '98
07:54:22 <Peaker> I'm looking at: http://www.haskell.org/tutorial/moretypes.html  at the Natural example, and specifically its "instance Num" declaration. It seems like there's code duplication between the -, + and * cases (and would be for many more methods such as those). Is there a more advanced Haskell technique to avoid this kind of duplication?
07:54:22 <lambdabot> Title: A Gentle Introduction to Haskell: Types, Again
07:54:59 <Peaker> Is it possible to specify that Num's operators all apply, by converting the inputs from naturals, and outputs back to Naturals?
07:55:11 <Peaker> (Rather than tediously typing that for each operation manually?)
07:55:39 <Heffalump> Peaker: well, you could write a higher-order function to do the work
07:55:48 <desegnis> Peaker, what about  viaNatural f x y = toNatural (fromNatural x `f` fromNatural y)
07:55:53 <Heffalump> e.g. onNaturals f x y = toNatural (f ^U
07:56:11 <roconnor> KonvIRC: I think that definition of abs doesn't actually occur in the Prelude ... not a good start to your tour. :(
07:56:22 <Peaker> desegnis, ah, and then how do you make */+/-/etc use viaNatural?
07:56:40 <Peaker> desegnis, is it possible to say "I'm an instance of Num, just have all my methods be viaNatural"?
07:56:46 <roconnor> KonvIRC: abs is actually an overloaded function, and could be defined in different was for different types.
07:56:56 <desegnis> Peaker, it's only possible for (+) and (*), because (-) is defined differently, obviously
07:57:07 <Peaker> desegnis, why is - defined differently?
07:57:23 <Peaker> desegnis, it seems the difference there is just for a better error msg, which is unrequired
07:57:25 <roconnor> KonvIRC: The definition shown is probably the definition for some specific instances of abs.
07:57:33 <roconnor> @src abs Integer
07:57:33 <lambdabot> Source not found. Take a stress pill and think things over.
07:57:38 <roconnor> @src Integer abs
07:57:38 <lambdabot> Source not found. stty: unknown mode: doofus
07:58:06 <desegnis> Peaker, no, it's not just for a better error message. It makes sure that 1 - 2 is undefined for natural numbers
07:58:24 <Peaker> desegnis, but wouldn't that already happen because of the failure inside the toNatural on the -'s result?
07:58:32 <Heffalump> Peaker: viaNatural doesn't work for unary operators, either
07:58:44 <Heffalump> you could imagine fixing that using more type class trickery, though
07:58:57 <shepheb> -ta l
07:59:02 <shepheb> mischan
07:59:03 <Heffalump> but you'd still have to enumerate the entire definition with viaNatural calls, there's no shortcut for that
07:59:07 <desegnis> Peaker, you would do instance Num Natural where (+) = onNaturals (+); (*) = onNaturals (*)
07:59:29 <desegnis> Peaker, ah yeah, right
08:00:03 <desegnis> Peaker, if you're looking for a really short shortcut, there's a langauge extension called Newtype deriving
08:00:11 <Peaker> I remember last time I tried delving into Haskell, I was bothered by lots of code duplication in the stdlib
08:00:21 <Peaker> I think that's a bad sign
08:00:47 <desegnis> Peaker, with newtype deriving, you would just say newtype Natural = MakeNatural Integer deriving (Num); and you're finished
08:01:18 <desegnis> albeit, you don't have the check for negative values then
08:01:30 <desegnis> which makes it useless in this particular case :)
08:01:44 <Peaker> Heh
08:01:46 <dolio> roconnor: All the instances for Ints use that scheme, only with 'negate x' instead of '-x'. And floats use that scheme only with '0.0' and negateFloat/negateDouble.
08:02:06 <Peaker> this time I gotta write some useful Haskell stuff before I decide, delving into the tutorial again, I really love a lot of what I see :)
08:02:18 <Peaker> the "gentle introduction" is not always so gentle, though
08:02:45 <desegnis> the explanations in the gentle intro are very well written, though
08:02:49 <Peaker> I think I also disliked the imperative part of Haskell...
08:03:03 <Peaker> haven't read all the way there again yet, though
08:03:21 <dolio> roconnor: The one for Integer is messy.
08:04:38 <dolio> I guess plain Int doesn't use that scheme, either. Just Int8/16/32/64.
08:04:45 <mulander> Peaker: what imperative part?
08:04:59 <Peaker> mulander, all the IO monads and syntax involving them, iirc
08:05:10 <Peaker> mulander, I don't think I fully understood it though..
08:05:13 <mulander> Peaker: imho monads have little to do with imperative programming
08:05:42 <mulander> in my opinion (note I'm also a haskell beginner) the 'do' statement may look like imprative programming
08:05:48 <mulander> but it's just syntatic sugar
08:06:13 <SamB> it's true that do is syntactic sugar...
08:06:28 <SamB> but Monads actually have everything to do with imperative programming
08:06:41 <SamB> at least in Haskell
08:06:59 <mulander> SamB: maybe mapping the concept, but they are not like regular imperative programming
08:07:02 <dolio> In denotational semantics, too, if you're into that.
08:07:14 <idnar> it's more like imperative programming in Haskell has everything to do with monads
08:07:33 <idnar> code in the list monad doesn't have anything to do with imperative programming, I would say
08:07:33 <tromp> some monads like List and Maybe have liuttle imperative about them
08:07:38 <idnar> (for example)
08:07:43 <sphynx> hi!
08:07:46 <SamB> idnar: true
08:08:34 <mulander> another example: map printf("some iteration %s more noise",some_calculation+0.5) to haskell
08:08:43 <roconnor> what is imperative programming?
08:08:54 <mulander> roconnor: good question :)
08:09:10 <ibid> roconnor: programming that must be done?
08:09:12 <roconnor> if it a about a sequence of steps, then I'd say that the List and especially Maybe have a lot to do with it.
08:09:16 <sphynx> I'm writing some Parsec code and don't know how to resolve correctly the following problem. I need to parse outline code (string starting with *, **, etc. - different levels of outline).
08:09:19 <tromp> imperative is changing state in sequential order
08:09:34 <noteventime> roconnor: State-change oriented programming?
08:09:39 <roconnor> right, if imperative is about changing state, then List and Maybe, not so much to do with it.
08:09:46 <ibid> imperative is about mutable state and sequencing
08:09:49 <idnar> well, generally speaking, I'd say "imperative programming" is about specifying actions
08:10:31 <idnar> instead of specifying what results you want, with the actions to get them being "implicit", you specify what actions you want taken, leaving the results you want "implicit"
08:13:25 <sphynx> when I parse one outline item I need to parse also its subitems (next lines with  number of asterisks greater then number of asterisks in current line). So I need item and subItem parsers, I start with item and after it's parsed - parse its children passing current level of outline as a parameter to subitem parser. Then I need to fail somehow in subItem parser if level is not greater than current
08:13:55 <sphynx> I use fail "some message" there, but then all my parsing process is failed
08:14:08 <dcoutts_> you need a backtracking parser
08:14:25 <sphynx> Yeah, I use lookAhead combinator
08:14:58 <sphynx> for adding lookahead possibility (to look forward at the asterisks' quantity to determine level)
08:15:35 <sphynx> I'm pasting code at the moment, maybe it might help to understand me better
08:16:36 <hpaste>  sphynx pasted "outline parser" at http://hpaste.org/6203
08:16:47 <sphynx> that is ^^
08:21:11 <Saizan> sphynx: since yo're using it with many  i thought it would just return an empty list if it fails?
08:23:43 <sphynx> Saizan: Yeah, it should return empty list, if fails. But I'm using 'fail' in orgSubitem, so it really fail all process with given message
08:25:12 <Saizan> sphynx: what happens if you use pzero instead of fail "message" ?
08:25:49 <idnar> pzero?
08:25:57 <idnar> oh
08:25:58 <sphynx> I'll try immediately
08:27:49 <Saizan> i never really understood the non-backtrackiness of parsec, but i've never really used it
08:28:20 <magnus__1> Saizan: it is very intuitive if you have ever written a recursive descent parser
08:28:25 <hpaste>  sphynx annotated "outline parser" with "result of pzero" at http://hpaste.org/6203#a1
08:28:55 <sphynx> I've inserted results...
08:29:03 <Saizan> magnus__1: heh, i've only studied them :)
08:29:16 <sphynx> It seems that lookAhead have not effect here
08:29:18 <hpaste>  mae pasted "ARGH! can't install happs with sp" at http://hpaste.org/6204
08:29:24 <magnus__1> sphynx: Actually, I don't know about the lookAhead function what it does
08:29:52 <mae> ; (
08:29:57 <sphynx> magnus__1: lookAhead code is here: http://haskell.org/ghc/docs/latest/html/libraries/parsec/src/Text-ParserCombinators-Parsec-Combinator.html
08:30:03 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/yw73jf
08:30:09 <sphynx> You could take a look, if you are interested
08:31:12 <magnus__1> sphynx: ah, yes, reading that makes it clear what it does
08:31:18 <sphynx> it simply stores the state of parser and then retrieves it (after invoking parser-parameter)
08:32:07 <Saizan> sphynx: and using many?
08:32:08 <sclv> isn't this a job for "try" ?
08:32:21 <Zyroth> What Linear Algebra library should I use if I want a wide range of functionalities and stability?
08:32:56 <sphynx> sclv: I don't know how can I put try here in my code
08:33:34 <sphynx> I just want to restore to previous state if parsed level is lower than given value...
08:34:04 <dancor> is there anything to daemonize a process?  i'm having trouble finding stuff like setsid()
08:34:06 <sphynx> I use try in something like 'try some <|> try another <|> third'
08:34:31 <Saizan> sphynx: then you should use lookAhead aroung orgSubItem, not inside.
08:35:08 <sclv> subitems <- try (many etc) <|> return [] ?
08:35:25 <Saizan> that also
08:35:40 <sphynx> Saizan: but if my subitems get parsed correctly - I don't want to restore state then
08:35:56 <Saizan> or many (try etc) <|> return []
08:36:00 <sclv> right: try only restores state on failure.
08:36:12 <Saizan> yeah, that's what try does
08:36:30 <Saizan> sclv: shouldn't many (try foo) be enough?
08:36:34 <sphynx> oh, ok!
08:36:46 <sphynx> I'll try now to use what you've said
08:37:15 <Dybber> Isn't it an error that the lines function throws away the last line if it is empty? I think it should give: lines "foo\nbar\n" == ["foo", "bar", ""]
08:37:26 <Dybber> > lines "foo\nbar\n"
08:37:27 <lambdabot>  ["foo","bar"]
08:37:41 <idnar> files normally end in a newline
08:37:47 <sclv> saizan: not sure. i'm sort of confused as to why the code is using the levels and lookaheads anyway. i'm sure it can be done that way, but i'd probably write something somewhat different that unrolled the many and intermixed it with the level checking.
08:37:50 <idnar> or rather, lines end in a newline
08:38:10 <idnar> so if you want a blank line at the end, you need two newlines
08:38:52 <tromp> < lines "\nbar"
08:39:01 <tromp> > lines "\nbar"
08:39:02 <lambdabot>  ["","bar"]
08:39:09 <sclv> or, actually, that's sort of silly. i was misreading what level meant.
08:39:29 <sphynx> sclv, what do you mean?
08:39:36 <Dybber> It just breaks my program somehow. I'm writing a diff clone
08:39:47 <sclv> nevermind: that was a misunderstanding on my part. i didn't get what level meant.
08:39:48 <Dybber> Well, I will write my own
08:39:50 <sphynx> level means number of asterisks (***, etc.)
08:40:04 <magnus__1> sphynx: how about this, does this work?    orgSubItem req = do try (do level <- lookAhead outline; guard (level>req || level==0)); orgItem
08:40:12 <sphynx> btw, using did not helo :(
08:40:15 <sphynx> help *
08:40:19 <dancor> > unlines $ lines "f\nb"
08:40:19 <lambdabot>  "f\nb\n"
08:40:58 <sclv> sphynx: did you try saizan's suggestion, which might be saner than mine?
08:41:34 <Dybber> dancor: good example, I think lines and unlines should be each others inverses
08:41:36 <Saizan> sphynx: however your second test couldn't give anything different than a failure
08:41:56 <sclv> hmm... actually, ignore the <|> [] too as it should be automatic with a many.
08:42:04 <magnus__1> Saizan: it should not fail on "D" though, right? it should fail at the start of the stream
08:42:07 <dancor> Dybber: it is a bit of a gotcha
08:42:26 <sphynx> magnus__1: your code gives the same result: failing on D
08:42:31 <dancor> Dybber: but it's almost a gotcha that exists in file newline conventions, not hs
08:42:32 <magnus__1> sphynx: ignore my suggestion by the way, it is clearly wrong. It may work with lookAhead
08:42:43 <magnus__1> sphynx: instead of try
08:43:01 <magnus__1> or a combination thereof
08:43:13 <Dybber> dancor: yeah, thats right
08:43:16 <magnus__1> lookAhead (try ( ... ))
08:43:26 <dancor> Dybber: open 'echo -n hi > a0' vs 'echo hi > a1' in editor e.g.
08:43:37 <sphynx> hm...
08:43:37 <magnus__1> sphynx: That must be the reason! look at the definition of lookAhead -- it doesn't restore the state if the parser fails
08:43:59 <dancor> in fact, diff has its "\ No newline at end of file" message
08:44:00 <magnus__1> sphynx: so you need to use lookAhead (try outline)
08:44:22 <sphynx> magnus__1: Yeah, might be so
08:44:23 <Saizan> magnus__1: but he doesn't want to restore the state if it succedes, no?
08:45:14 <magnus__1> Saizan: he does
08:45:15 <sphynx> Saizan: correct
08:45:34 <Dybber> dancor: yes, ok thats maybe the right solution. Let the user handle it.
08:45:41 <magnus__1> if outline succeeds, the state must be restored so that orgItem can work
08:45:59 <magnus__1> if outline fails, the state must be restored also
08:46:14 <Saizan> oh, right, orgItem parses level again
08:46:33 <dancor> it's starting to seem like no one ever daemonizes anything in hs, just throws it in screen
08:46:48 <dancor> guess i'll write this in python
08:47:42 <gnuvince_> :t composeAll
08:47:43 <lambdabot> Not in scope: `composeAll'
08:47:50 <sclv> dancor: what's the issue?
08:47:51 <magnus__1> sphynx: orgSubitem req = do try (do level <- lookAhead outline; guard (level > req || level == 0)); orgItem
08:48:09 <sclv> is there a lib that python provides that haskell doesn't?
08:48:48 <nornagon> sclv: daemonizing, perhaps.
08:48:49 <sphynx> magnus__1: it seems that combination of your and Saizan's approaches work well!
08:49:14 <magnus__1> sphynx: cool, paste it :)
08:49:27 <Saizan> it seems like there should be an easier solution
08:49:43 <sphynx> magnus__1: I'll play a bit with it, one minute please
08:49:58 <sphynx> trying different approaches :)
08:54:45 <magnus__1> Saizan: maybe this? do level <- try (lookAhead outline); guard (...level...); orgItem
08:54:48 <sclv> if there really isn't any daemon support in haskell (tho it shouldn't be hard to build it on system.posix) then it sounds like a good half-hour hacking project :-)
08:55:55 <hpaste>  sphynx annotated "outline parser" with "outline parser result" at http://hpaste.org/6203#a2
08:56:18 <sclv> cool!
08:56:37 <sphynx> It seems that adding try inside of 'many' has fixed the problem
08:56:55 <sphynx> It still not work for one line, but works good for the file with outlines
08:57:45 <sphynx> Under 'works for one line' I mean: parseTest (orgSubitem 2) "* DONE 1234 description\n"
08:58:19 <sphynx> It should fail, because number 2 is greater then 1 asterisk
08:59:07 <sphynx> And one more question: how to redefine this using guard?
08:59:58 <sphynx> Saizan, magnus__1, sclv : Thank you very much for the help!
09:00:54 <magnus__1> orgSubitem: if foo then bar else pzero   is equivalent to   guard foo >> bar   unless I am mistaken. In do notatino that will be   do guard foo; bar
09:01:12 <magnus__1> I meant sphynx: of course :D
09:01:19 <sclv> ?src guard
09:01:19 <lambdabot> guard True  =  return ()
09:01:19 <lambdabot> guard False =  mzero
09:01:57 <sclv> ?src unless
09:01:57 <lambdabot> unless p s = if p then return () else s
09:03:28 <magnus__1> ?src when
09:03:29 <lambdabot> when p s = if p then s else return ()
09:06:58 <hpaste>  sphynx annotated "outline parser" with "guard outline" at http://hpaste.org/6203#a3
09:07:38 <magnus__1> sphynx: good. Now the only thing that makes me nervous is that try around the whole of orgSubitem
09:08:21 <magnus__1> sphynx: I would put the try around only the first two lines of orgSubitem if I were you, to avoid try as much as possible (for space and memory performance, and for sensible error messages)
09:11:33 <hpaste>  sphynx annotated "outline parser" with "final version I hope :)" at http://hpaste.org/6203#a4
09:12:26 <sphynx> yeah, this looks good, thanks!
09:17:57 <akamaus> hi all. I'm experimenting with a toy ajax webapp based on happs. Sometimes server crashes with error message "getNameInfo: does not exist (Temporary failure in name resolution)". I dont use getNameInfo function myself so i have no ideas from where is's called. How to overcome this problem?
09:17:59 <roconnor> @go 200 F in C
09:17:59 <lambdabot> 200 degrees Fahrenheit = 93.3333333 degrees Celsius
09:18:22 <ttt--> that's hot
09:21:47 <lucca> @go c in furlongs per fortnight
09:21:47 <lambdabot> the speed of light = 1.8026175 x 10^12 furlongs per fortnight
09:21:53 <sclv> akamaus: try #happs
09:22:27 <akamaus> sclv: ok, i will
09:29:46 <EvilTerran> > mapM ((:)<$>toUpper<*>return.toLower) "internet!"
09:29:47 <lambdabot>  ["INTERNET!","INTERNET!","INTERNEt!","INTERNEt!","INTERNeT!","INTERNeT!","IN...
09:29:59 <EvilTerran> > drop 100 $ mapM ((:)<$>toUpper<*>return.toLower) "internet!"
09:30:00 <lambdabot>  ["INteRNeT!","INteRNeT!","INteRNet!","INteRNet!","INteRnET!","INteRnET!","IN...
09:34:53 <mulander> how long does it take to compile ghc on a PIII 600 pc (or similar)
09:35:08 <idnar> @src product
09:35:08 <lambdabot> product = foldl (*) 1
09:39:04 <Saizan> mulander: a night :)
09:39:11 <mulander> for comparision
09:39:14 <newsham> morning
09:39:22 <mulander> gcc while I was running gentoo took 8h for single pass
09:39:36 <mulander> so gcc upgrade took 16h
09:39:51 <mulander> does ghc compile in a two way pass also?
09:39:57 <Saizan> yes
09:44:31 <Ben`> how can I group a list by every 3 elements?  e.g. f [1,2,3,4,5,6,7] returns [[1,2,3],[4,5,6],[7]]
09:44:52 <shachaf> Ben`: unfoldr?
09:45:09 <Ben`> ok, I'll try that
09:45:12 <Ben`> thanks
09:45:31 <shachaf> > unfoldr (\x -> guard (not (null x)) >> return (splitAt 3 x)) [1..7]
09:45:31 <lambdabot>  [[1,2,3],[4,5,6],[7]]
09:45:41 <shachaf> Something like that.
09:45:41 <newsham> > let x = [1,2,3,4,5,6,7] in zip x (zip (drop 1 x) (drop 2 x))
09:45:42 <lambdabot>  [(1,(2,3)),(2,(3,4)),(3,(4,5)),(4,(5,6)),(5,(6,7))]
09:45:49 <newsham> oops not that
09:46:06 <newsham> mmm nice unfold
09:46:34 <monochrom> yeah
09:47:53 <sclv> @pl \x -> guard (not (null x)) >> return (splitAt 3 x)
09:47:53 <lambdabot> ap ((>>) . guard . not . null) (return . splitAt 3)
09:48:21 <newsham> taking the read out of readability
09:49:23 <sclv> (>>) . guard . not . null <*> return . splitAt 3 -- better?
09:49:37 <desegnis> Does somebody know whether Data.Algorithm.Diff (from Hackage) is written correctly? It gives unexpected results to me
09:50:04 <sclv> desegnis: probably is a bug.
09:50:10 * sclv hangs his head in shame
09:50:19 <newsham> there should be a name for (>>) . guard . f <#> return . g
09:50:31 <desegnis> sclv, oh, you're the author :)
09:50:37 <desegnis> good timing
09:50:51 <sclv> it was an early learning effort, and I thought I worked out the kinks, but...
09:51:21 <newsham> did you use min-edit-distance algo?
09:51:41 <sclv> yep -- the one that unix diff adopted from the, i think, 1984 paper.
09:52:16 <desegnis> sclv, for example it doesn't find an lcs of [4,2,3,5] and [1,2,3]
09:52:50 <newsham> what are F,S and B?  insert, delete and change of some sort?
09:53:00 <sclv> first, second, both
09:53:00 <desegnis> newsham, first, second, both
09:53:27 <newsham> oh it says it right there
09:53:28 <newsham> sorry
09:53:36 <sclv> *Data.Algorithm.Diff> getDiff [4,2,3,5] [1,2,3]
09:53:39 <sclv> [(S,1),(F,4),(B,2),(B,3),(F,5)]
09:54:15 <sclv> ?
09:54:17 <desegnis> I get [(F,4),(F,2),(F,3),(F,5),(S,1),(S,2),(S,3)] here
09:54:25 <sclv> zounds. it must be a bad version on hackage.
09:54:29 <newsham> weird
09:54:53 <sclv> *Data.Algorithm.Diff> getGroupedDiff [4,2,3,5] [1,2,3]
09:54:53 <sclv> [(S,[1]),(F,[4]),(B,[2,3]),(F,[5])]
09:55:11 <desegnis> sclv, I'm running it interpreted, but that shouldn't be imported?
09:55:17 <desegnis> *important?
09:55:30 <newsham> someone last night said their ghc6.8.2 returned [1,2,3] for dropWhile (==1) [1, 2, 3]
09:55:30 <sclv> designis: erm, no.
09:55:52 <sclv> check if it has "instance Ord DL where x <= y = poi x <= poi y"
09:56:12 <sclv> there was an ord instance that was wrong, but I could have sworn I fixed it before the upload...
09:56:33 <newsham> you could download and Data.Algorithm.Diff it
09:56:52 <desegnis> sclv, it has
09:57:26 <desegnis> oh wait
09:57:43 <desegnis> there is indeed a type in the released version, x instead of y
09:58:58 <desegnis> if I fix it, it seems to work correctly :)
09:59:25 <newsham> Prelude Data.Algorithm.Diff> getDiff [4,2,3,5] [1,2,3]
09:59:25 <newsham> [(F,4),(F,2),(F,3),(F,5),(S,1),(S,2),(S,3)]
09:59:30 <newsham> just downloaded and built from hackage
09:59:35 <newsham> the 0.1 version
09:59:43 <sclv> good catch -- pushing a new one now.;
10:00:08 * desegnis will print out Diff.hs and finally really understand the famous LCS algorithm
10:00:32 <newsham> diff algorithm is super easy if you dont optimize it
10:00:33 <sclv> the paper is totally easy!
10:00:41 <newsham> (or if you implement it using memoization)
10:00:46 <desegnis> Diff.hs is the most concise and precise definition of it I've been able to find :)
10:01:14 <sclv> well, it looks sort of different because its functional...
10:01:16 <hpaste>  mae pasted "(no title)" at http://hpaste.org/6207
10:03:25 <newsham> if implemented directly as recursion with no memoization its a really simple function
10:03:53 <sclv> newsham: with no memo its awful tho...
10:04:11 <newsham> yah.  but you can abstract out the memoization into a general memoizing function
10:04:16 <newsham> and keep the trivial recursive definition
10:04:30 <sclv> are we talking about the "snake" algo or the standard dynamic programming one?
10:04:53 <newsham> the one that's normally done using DP?  *shrug*  what's the snake one? :)
10:04:54 <sclv> (ok, hackage upload complete)
10:05:07 <newsham> here's my memoized edit distance in python (just as an example) http://www.thenewsh.com/%7Enewsham/x/machine/diff2.py
10:05:24 <newsham> also just edit distance, not the series of edits
10:05:56 <sclv> http://citeseer.ist.psu.edu/myers86ond.html
10:05:59 <lambdabot> Title: An O(ND) Difference Algorithm and Its Variations - Myers (ResearchIndex)
10:06:35 <mulander> hmm, anyone here using xmonad?
10:06:52 <newsham> probably, I think there's an #xmonad too
10:07:01 <newsham> sclv: danke
10:07:01 <shag> is there a simple way to create a cabal package containing a library and an executable where the executably is linked against the library?
10:07:07 <sclv> the one normally done using DP is, erm, O (NM) I think?
10:07:12 <mulander> newsham: ok, nvm.
10:07:20 <newsham> sclv: you're right
10:07:57 <sclv> this is way faster for normal usage -- it has the same worst case bounds tho.
10:08:08 <newsham> I always thought O(NM) was the optimal solution
10:08:23 <sclv> As I recall, ndm has a nice simple version of the other one floating around? and there's one in the hpaste source too.
10:09:00 <newsham> i'm sure there are many on hpaste as well
10:09:56 <sclv> if you look at the papers that cite the one I linked (which is, by the way, just an awesome paper for clarity and ease of understanding) there are all sorts of fancy variants as well for structured documents, special cases, etc.
10:10:06 <newsham> i have several python/haskell ones in my scrap dir
10:10:21 <desegnis> An explanation of the DP algorithm is in the Introduction to Algorithms book
10:10:26 <newsham> i will have to read through this
10:10:43 <newsham> the DP one is also on many websites including wikipedia
10:10:50 <newsham> ?go wikipedia levenshtein edit distnace
10:10:51 <lambdabot> http://en.wikipedia.org/wiki/Levenshtein_distance
10:10:51 <lambdabot> Title: Levenshtein distance - Wikipedia, the free encyclopedia
10:12:10 <FMota> Okay guys. So, I'm making an interpreter for a Lisp-like language in Haskell, and I haven't so much hit a snag, as I'm sure there's a simpler / more canon way to do what I want to do.
10:12:44 <FMota> type PrimOp = PrimOp -> Env -> [Obj] -> IO Obj
10:12:45 <newsham> whats the snag?  (btw did you see the scheme48 tutorial?)
10:13:40 <FMota> newsham: is there some kind of Monad, or some way to use Arrows, that will make PrimOp simpler?
10:13:59 <newsham> you want your primop to be a function whose first argument is a primop?
10:14:07 <FMota> and no, I haven't.
10:14:19 <FMota> Yes, a continuation.
10:14:31 <mrsolo> hmm isn't one of haskell tutorial about writing a schemem interpreter in haskell?
10:14:37 <FMota> And I pass a continuation to that continuation, and so on.
10:14:44 <newsham> ?go haskell scheme 48
10:14:50 <lambdabot> http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/overview.html
10:14:50 <lambdabot> Title: Write Yourself a Scheme in 48 hours
10:15:29 <newsham> fmota: I dont think I understand.  isnt that an infinite type that can never be realized?
10:16:02 <FMota> I don't understand why it would be an infinite type.
10:16:48 <FMota> you could always ignore just ignore the first argument.
10:16:51 <newsham> PrimOp = Primop -> XXX = (Primop -> XXX) -> XXX = ((Primop -> XXX) -> XXX) -> XXX ?
10:18:13 <FMota> well, suppose I make it a newtype, then: newtype PrimOp = PrimOp { runPrimOp :: PrimOp -> Env -> [Obj] -> IO Obj }
10:19:11 <mrd> "type"s can't be recursive
10:19:58 <sclv> haha: it was actually ab's diff I was thinking of: http://andrew.bromage.org/darcs/diff/Diff.hs
10:20:05 <FMota> but newtype/data, can.
10:20:15 <FMota> (or at least data can).
10:20:47 <mrd> recursive types can exist, but the way it is implemented in haskell is called "iso-recursive" types where some kind of fold/unfold operation is used to express the isomorphism between a type and its recursive expansion
10:20:59 <mrd> that mechanism is all folded into the "data" keyword
10:21:22 <mrd> the point of all that jazz is to make type equality much easier to decide
10:21:40 <FMota> ok
10:24:02 <mrsolo> how come type can't be recursive?
10:24:39 <mrsolo> is it implementation limitation? or there is some theory behind that?
10:24:45 <mrd> ^
10:25:31 <FMota> now, my question still remains
10:25:32 <sclv> type is just an alias, right?
10:25:45 <newsham> if types were recursive would type propogation be undecidable?
10:25:57 <newsham> type inference rather
10:25:59 <EvilTerran> a "type" is fully expanded in the course of type-checking
10:26:08 <EvilTerran> it'd be infinite if it were recursive
10:26:10 <mrd> maybe. it would be a lot harder, fo rsure.
10:26:13 <sclv> exactly.
10:26:18 <FMota> is there some way to make a Monad out of data PrimOp = PrimOp -> Env -> [Obj] -> IO Obj
10:26:23 <mrd> i know type-checking becomes something like EXPTIME hard
10:26:30 <sclv> its just a keystroke saving macro.
10:26:34 <ilyak_> Hi everyone!
10:26:37 <EvilTerran> FMota, not really; there's no type parameter
10:26:48 <newsham> is that a legal data definition?
10:26:56 <ilyak_> Which data structures haskell lists are, under the hood?
10:27:02 <FMota> newsham: good point, no.
10:27:02 <mrd> no because he's missing a constructor
10:27:07 <newsham> ilyak: depends :)
10:27:11 <mrd> @src []
10:27:11 <lambdabot> data [] a = [] | a : [a]
10:27:14 <sclv> you can't even declare instances for types without a language extension...
10:27:16 <mrd> that is a list
10:27:30 <ilyak_> mrd: Yeah, let's suppose
10:27:34 <EvilTerran> ilyak_, linked lists, give or take
10:27:37 <FMota> EvilTerran: argh. Yeah. maybe I can expand PrimOp to accepting a type argument, though.
10:27:41 <newsham> ilyak: in some haskell implementations data declarations are converted into functions
10:27:55 * FMota goes back into his den.
10:27:56 <ilyak_> EvilTerran: So, if they are linked lists, ++ should be very fast?
10:27:58 <newsham> ?go efficient interpretation jansen
10:28:00 <lambdabot> http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/j/Jansen:Jan_Martin.html
10:28:00 <lambdabot> Title: DBLP: Jan Martin Jansen
10:28:04 <ilyak_> Like, a few asm instructions?
10:28:10 <EvilTerran> ilyak_, heavens no
10:28:19 <EvilTerran> remember that everything in haskell is immutable
10:28:23 <mrd> ilyak_: ghc is very good at list manipulation
10:28:37 <mrd> i wouldn't worry about "a few asm instructions"
10:28:37 <newsham> ilyak: http://www.cs.nott.ac.uk/~nhn/TFP2006/Papers/03-JansenKoopmanPlasmeijer-EfficientInterpretation.pdf
10:28:41 <lambdabot> http://tinyurl.com/2drus8
10:28:41 <EvilTerran> you can't just change the "tail" field of the last cell in a list, you have to copy out all the cells on the left list again
10:28:55 <araujo> hello
10:29:10 <ilyak_> EvilTerran: What if I'm not using source list after ++? I think compiler should just use that?
10:29:40 <newsham> ?src (++)
10:29:40 <lambdabot> (++) []     ys = ys
10:29:40 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
10:29:58 <EvilTerran> if you can devise a compilation technique which can do that, sure
10:30:07 <ilyak_> newsham: Well, I guess compilers don't do it like that
10:30:26 <EvilTerran> but it's not easy to do even like that, let alone generalise into something actually significantly useful
10:30:34 <newsham> they probably could if someone implemented that optimization
10:30:35 <EvilTerran> ilyak_, ah, but they do
10:31:02 <mofmog> I think i have most of the basics down
10:31:04 <ilyak_> EvilTerran: But that means code will be very slow
10:31:06 <mofmog> now what should i write
10:31:09 <ilyak_> When it can be made fast
10:31:11 <EvilTerran> ilyak_, not well-written code
10:31:47 <EvilTerran> don't blame your tools
10:32:00 <ilyak_> EvilTerran: Well, straightforward code should be fast
10:32:22 <ilyak_> If I can compile in into efficent asm on the paper, I should also be able to write efficent compiler
10:32:56 <EvilTerran> be my guest
10:33:36 <ilyak_> Let's suppose we have two list and want to concatenate them fast and without mitating them
10:33:37 <newsham> if i can describe in words the content of a picture, I should be able to write a program which does that?
10:35:37 <ilyak_> We'll define a list element L that will consist of data d, pointer to next list element np, and pointer to next element in joined list jnp
10:35:51 <ilyak_> When we initialise list, np is equal jnp
10:36:08 <EvilTerran> (xs ++ ys, xs ++ zs)
10:36:13 <newsham> ilyak: what is your representation of [1..] ?
10:36:21 <ilyak_> And when we concatenate two lists l1 and l2, l1's last element jnp should point to l2's first element
10:36:30 <ilyak_> That's a few instructions
10:36:45 <EvilTerran> and how would me expression work?
10:36:49 <EvilTerran> &my
10:36:56 <ilyak_> And then we can iterate joined list going though item = item.jnp
10:37:33 <EvilTerran> and what about laziness?
10:37:35 <ilyak_> That would be fast, lists would not be mutated, but that would consume a little more memory
10:37:44 <ilyak_> EvilTerran: What about it?
10:38:05 <EvilTerran> what's the jnp of the last element in xs afterwards?
10:38:13 <newsham> so each list has one next pointer and one joined-next-pointer?
10:38:21 <EvilTerran> ys, or zs?
10:38:28 <ilyak_> EvilTerran: jnp of the last element of list l1 or list l2?
10:38:34 <ilyak_> newsham: Yeah.
10:38:45 <EvilTerran> xs, in my example
10:38:46 <newsham> ilyak: what if I join the same list with a dozne other lists?
10:38:51 <newsham> (see ET's example)
10:38:54 <ilyak_> Compiler can generate more than one joined-next pointer if necesary
10:39:08 <newsham> what if I join the list with an arbitrary number of other lists
10:39:11 <newsham> not known at compile time?
10:39:13 <ilyak_> I guess we can predict number of list joins during compile time
10:39:21 <newsham> no, that is undecidable
10:39:31 <ilyak_> newsham: Fall back to old behavior
10:39:40 <ilyak_> newsham: In most cases it is
10:39:42 <EvilTerran> > map (x++) [[x] | x <- [1..]]
10:39:43 <lambdabot>  Couldn't match expected type `Expr' against inferred type `[a]'
10:40:04 <newsham> *shrug* could work in some limited situations.. might offer some speedup, might not.
10:40:04 <EvilTerran> why bother, if it won't generalise?
10:40:16 <newsham> wait.. how do you know which next pointer to use?
10:40:19 <newsham> when you start passing these things around?
10:40:33 <newsham> now all of your uses of next pointer must be aware of which one you mean
10:40:42 <ilyak_> EvilTerran: Compiler should optimize for some limited situations.
10:40:55 <ilyak_> newsham: Yeah, they must
10:40:56 <newsham> ilyak: that is true,  but that doesnt mean this is one of those situations :)
10:41:03 <EvilTerran> the compiler should make code "fast enough"
10:41:07 <ilyak_> newsham: It does not.
10:41:09 <EvilTerran> while being "fast enough" itself
10:41:20 <newsham> premature optimization?
10:41:23 <sclv> ilyak_: there are difference lips, and ropes as well.
10:41:23 <EvilTerran> weighing it down with a million special cases will aid the former but cripple the latter
10:41:36 <sclv> not to mention finger trees (i.e. data.sequence)
10:41:51 <ilyak_> Well, I don't know.
10:41:56 <sclv> all different data structures that handle, in different ways, appending, cleanly.
10:42:03 <ilyak_> But I find myself writing a lot of code with list-joins
10:42:04 <sclv> it sounds sort of like you're describing a rope.
10:42:18 <newsham> ilyak: btw, your next pointers need to be lazy thunks sometimes
10:42:29 <sclv> also, for strings, see ShowS (which is a difference list in disguise)
10:42:57 <sclv> the general idea is to let a linked list be a linked list, but to have all this other stuff available when you need it.
10:43:04 <newsham> ilyak: there are ways to write code to avoid using ++
10:43:13 <sclv> ?where dlist
10:43:14 <lambdabot> http://www.cse.unsw.edu.au/~dons/dlist.html
10:43:18 <ilyak_> newsham: There are ways to write code in plain asm
10:43:22 <newsham> so making ++ fast is not the only option
10:43:23 <ilyak_> Not that we want to
10:43:44 <sclv> ilyak_: there's a huge difference between going lower level, and just using the right data structure for the task!
10:44:02 <newsham> also since ++ is lazy, its not always expensive
10:44:28 <sclv> I will grant, however, that if (++) was mappend then switching data structures would be somewhat easier, although its hardly a chore as is.
10:44:32 <dbremner> newsham - it looks like some people have experimented with cdr coding.
10:44:36 <yitz> hi all. Is dcoutts around?
10:44:43 <dcoutts_> @arr!
10:44:43 <lambdabot> Avast!
10:44:49 <newsham> cdr coding?  that went over my head
10:45:03 <ilyak_> I think Data.Sequence's list joining is slow, too?
10:45:04 <sclv> its a lisp trick.
10:45:19 <ilyak_> Is not it? I't clearly not O(n) as far as I understood the docs
10:45:35 <dcoutts_> yitz: hia
10:45:37 <ilyak_> That's, by the way, a point on supposedly declarative programming.
10:46:01 <yitz> dcoutts: I finally have ghc 6.8.2 on Tiger, due to the new MacPorts. Yay! Now I need gtk2hs. I'm having trouble (so far) with the mtl dependency
10:46:03 <Lemmih> yitz: dcoutts_ is omnipresent.
10:46:03 <newsham> i'm an over educated imperative programmer, which means I still know less than an unedereducated lisp programmer.
10:46:03 <newsham> please forgive my ignorance :)
10:46:06 <dbremner> sclv- that's what I thought, but google found this. http://www.dtek.chalmers.se/~d99getob/Projects/CSHC/download/CSHC-R010.ps
10:46:09 <ilyak_> If we think that list-join is the best description of what we're trying to do, we want to write ++ and let compiler to optimize it
10:46:09 <lambdabot> http://tinyurl.com/34zr9q
10:46:15 <dcoutts_> Lemmih: :-)
10:46:32 <yitz> hi Lemmih!
10:46:34 <dcoutts_> yitz: mtl should be bundled with your ghc instllation
10:46:36 <sclv> ilyak: if you're (++) n m then with linked lists it should be o(n) and with sequence it should be o(m) -- which if you're adding lots of small things to the end of a big thing, can be a big improvement.
10:47:05 <EvilTerran> sclv, shouldn't it be O(n `min` m)?
10:47:14 <ilyak_> sclv: I'm adding to the beginning of a big thing
10:47:19 <yitz> ghc-pkg list didn't list it. Tried to install from Hackage, but I can't seem to satifsfy gtk2hs with the offerings there.
10:47:20 <sclv> et: possibly.
10:47:21 <ilyak_> Looks like it should be fast on list?
10:47:37 <sclv> ilyak: then adding to the beginning of a big thing isn't an issue anyway, I think?
10:47:37 <newsham> why would you use "min" infix? :)
10:47:41 <ilyak_> (++) should be O(1)
10:47:49 <dcoutts_> yitz: if ghc-pkg lists it then gtk2hs should be happy
10:47:50 <gwern> '90% of C++ programming is memory management. \n The other 10% is also memory management.'
10:47:53 <sclv> so should primes, but go figure...
10:48:15 <ilyak_> sclv: Maybe, but my code is slow. I'm trying to understand, why.
10:48:15 <Cheery> no
10:48:20 <ilyak_> That's why I'm here.
10:48:25 <dcoutts_> yitz: does ghc-pkg list it now?
10:48:25 <Cheery> 90% of C++ is crap
10:48:28 <yitz> gtk2hs wants exactly version 1.0.1. Hackage has 1.1.0.0, gth2hs doesn't like it.
10:48:32 <Cheery> 10% is lisp
10:48:33 <newsham> gwern: heh.
10:48:41 <EvilTerran> oh, hey, dcoutts_. btw, i want to talk 3rd-year projects with you some time over the vac. not just now, i'm packing, but whenever.
10:48:42 <SamB> gwern: funny
10:48:46 <sclv> ilyak_: try a dlist. seriously.
10:48:51 <SamB> I've seen some C++ programs that do something useful
10:48:54 <SamB> where does that come in?
10:48:59 <sclv> also, have you profiled?
10:49:01 <dcoutts_> EvilTerran: sure
10:49:12 <EvilTerran> i'm thinking of doing a proof assistant in haskell, probably with gtk2hs
10:49:13 <sclv> because I wouldn't go blaming (++) unless the profiler told me to.
10:49:18 <dcoutts_> EvilTerran: cool
10:49:23 <newsham> can we have a language war?
10:49:24 <ilyak_> sclv: No. I'm not sure I have a haskell profiler
10:49:39 <dcoutts_> yitz: gtk2hs does not actually care what version of mtl you have
10:50:07 <sclv> if you have ghc, you do! compile with -prof -auto-all and then run with +RTS -p
10:50:31 <ilyak_> Looks like I don't have profiling libs
10:50:44 <ilyak_> It can't find Data.Sequence
10:50:53 <yitz> dcoutts_: the MacPorts port of gthk2hs won't install - it requires mtl 1.0.1. So sounds like that is MacPorts issue then.
10:51:15 <dcoutts_> yitz: how did you install mtl? via macports?
10:51:44 <yitz> wait, not correct. Hmm, let me get this story straight (I was working on it yesterday...)
10:51:50 <dcoutts_> yitz: if you installed mtl as a user rather than global package then you need to use ./configure --with-user-pkgconf when building gtk2hs
10:52:04 <sclv> ilyak: does that keep you from profiling or just from profiling inside sequence?
10:52:21 <ilyak_> sclv: It keeps me from compiling the damn thing
10:52:38 <sclv> ah, weird. :-(
10:52:39 <dcoutts_> yitz: otherwise it only looks at the globally registered packages (since by default gtk2hs will install globally too, and you cannot have a global package depend on a per-user one)
10:53:11 <hpaste>  Ilyak pasted "prof error" at http://hpaste.org/6211
10:53:24 <ilyak_> sclv: Look.
10:54:19 <desegnis> sclv, it was very instructive to read Diff.hs. It didn't occur to me that the transition from the algo description of Myers' paper to purely functional code can be as (apparently) simple/elegant as that. Man, why do I still suck so much as a coder?
10:54:44 <newsham> desegnis: knowing you have a problem is the first step :)
10:55:08 <desegnis> newsham, knowing the nature of the problem would be of more use to me
10:55:24 <mofmog> i just read a tutorial
10:55:35 <mofmog> and i want to use the lex function but it told me it's included in prelude
10:55:42 <mofmog> so i'm guessing i have to import it?
10:55:48 <newsham> desegnis: as long as you remain unsatisfied with your programming skills I'm sure you'll keep improving
10:55:48 <mofmog> but i dont know where it lives
10:55:54 <oerjan> no, Prelude is the autoimported module
10:56:02 <mofmog> oh ok
10:56:03 <sclv> designis: looking back, it seems a bit over obfuscated to me, actually. :-) i guess it was just banging away at it for a while... iterative design and all that, kept abstracting and abstracting.
10:56:16 <yitz> dcoutts_: There is no port for mtl - I installed that from hackage. However, gtk2hs and ghc are both from ports. gtk2hs is not registered to ghc. gtk-pkg register of gtk complained about the mtl version. Now gtk is listed in curly brackets in ghc-pkg list. When I try to run ghci -package gtk, ghci fails with a complaint about the mtl version. There, I think I've got it right now.
10:56:20 <desegnis> newsham, that sounds much better already
10:56:40 <yitz> correction: gtk _is_ registered, but with the error.
10:57:00 <dcoutts_> yitz: ok so it's in curly braces because it depends on some packages that are missing and so it is a broken package
10:57:26 <yitz> right. the package that is missing is mtl 1.0.1 - it want exactly that version.
10:58:09 <dcoutts_> yitz: ah, ok so you must have had mtl 1.0.1 installed and you built gtk2hs against that version
10:58:19 <mofmog> holy hell lex is powerful
10:58:37 <desegnis> sclv, the only bit I found hard to grasp is how, in dstep, you choose the farther-reaching of the D-paths on a specific diagonal. But then again, it's short, so it can't be too unclear
10:59:05 <dcoutts_> yitz: installed packages depend on the exact versions of the packages they were built against, you can rebuild from source and use whatever version is available
10:59:09 <sclv> that's what the broken ord instance was about.
10:59:44 <dcoutts_> yitz: so you probably need to re-install mtl and then rebuild gtk2hs from source to use that mtl version
10:59:48 <mofmog> if you have two algebraic data types that have the same subtypes
10:59:52 <mofmog> how does haskell pattern match?
11:00:11 <mrd> subtypes?
11:00:14 <dcoutts_> mofmog: you cannot use the same constructor name in two data types in the same module
11:00:49 <byorgey> mrd: mofmog probably means data constructors?
11:00:50 <newsham> like   data X = XTrue | XFalse     data Y = YTrue | YFalse?
11:01:11 <yitz> dcoutts_:  OK, so you think if I force MacPorts to rebuild gtk2hs now, it will use the mtl I installed in ghc manually (not something built into the gtk2hs port)?
11:01:33 <desegnis> sclv, yeah, having to read maximum as Â»of these two paths, choose the one reaching further along the i axisÂ«
11:01:48 <dcoutts_> yitz: I would not have thought that the gtk2hs port would have it's own bundled version of mtl, that seems rather unlikely
11:02:06 <yitz> ok, I'll give it a try. Thanks!
11:02:41 <dcoutts_> yitz: but if you managed to install it previously and you're sure you had not installed mtl first then I suppose it's possible the port is doing something odd like that
11:02:46 <desegnis> sclv, and remembering that's the right thing to do because the two paths are on the same diagonal
11:03:09 <dcoutts_> yitz: do you know how did mtl-1.0.1 ever get onto your machine in the first place?
11:03:29 <sclv> yeah -- that last bit is the sort of tricky part on the ord instance. the first bit seems like a natural mapping of the "max" concept to the data type.
11:03:57 <yitz> dcoutts_: probably bundled with a previous version of the ghc port.
11:04:39 <dcoutts_> yitz: perhaps the port is wrong, that it'd building against a bundled mtl but then not actually installing the mtl
11:06:56 <desegnis> sclv, it also puzzled me to read maximum when you always compare only two values. but I don't see a clean way to involve pairs, say (so you could do uncurry max)
11:07:34 <ilyak_> By the way, if we define list as function that returns (x, xs) we can easily write a very fast catenator
11:07:45 <desegnis> (that Â»alwaysÂ« above is a little inexact, I know :)
11:07:55 <ilyak_> Provided compiler generates efficent code for highte order functions
11:08:01 <yitz> dcoutts_: I had an older ghc port installed. Then I installed gtk2hs. Then (months later) I upgraded  the ghc port to 6.8.2. The gtk2hs port still believed that everything was fine. That was naive, it makes sense that it needs to be rebuilt with the new ghc.
11:08:02 <ilyak_> higher*
11:08:30 <sclv> desegnis: yeah -- the first and, i think also last values aren't pairs. they're what makes it messy.
11:09:18 <Cale> Another nice way to represent lists for fast concatenation is simply as functions which prepend some elements to another list.
11:09:41 <yitz> I wonder if MacPorts has a way of forcing a rebuild of gtk2hs when the ghc version changes, even if gtk2hs is compatible with both versions of ghc.
11:09:47 <Cale> Concatenation is then simply function composition.
11:09:52 <sclv> ilyak_: I was going to suggest that if you're getting the error on System, you might want to see if importing System.XXX instead of the haskell98 package helps.
11:10:03 <sclv> ghc without profiling is way less fun.
11:10:16 <dcoutts_> yitz: they have to do that kind of thing for other packages, like python, so perhaps
11:10:35 <ilyak_> import System (getArgs);
11:10:40 <ilyak_> That's what I have got
11:10:54 <sclv> ?hoogle getArts
11:10:55 <lambdabot> No matches found
11:10:58 <sclv> ?hoogle getArgs
11:10:58 <lambdabot> System.Environment.getArgs :: IO [String]
11:11:21 <sclv> there we are. try the qualified package name -- in general, those are always preferred and the old ones are around for H98 compatibility.
11:11:22 <desegnis> sclv, exactly. stupid Haskell lists, not being designed for handling the first and last element specially
11:11:55 <yitz> dcoutts_: well, I'll try to fix my gtk2hs now. In any case, who needs to hear about this issue with the gtk2hs port?
11:12:08 <dcoutts_> yitz: the portfile should list the maintainer
11:12:11 <oerjan> :t System.getArgs
11:12:12 <lambdabot> IO [String]
11:12:21 <newsham> desegnis: make your own :)
11:12:23 <oerjan> should be the same
11:12:25 * yitz looks at the portfile
11:13:24 <sclv> desegnis: it would be an interesting exercise to write the algo using the list monad explicitly. at the time i did this i didn't know enough to pull it off, but it seems like a very promising idea.
11:14:03 <oerjan> oh profiling libraries
11:14:08 <yitz> Maintainers: gwright@macports.org
11:15:57 <ilyak_> let catenateFast [] l2 = l2; catenateFast (x1:xs1) l2 = x1 : catenateFast xs1 l2
11:16:00 * desegnis thinks of a function mapping  [ (a,b), (c,d), (e,f) ]  to  [ a, phi b c, phi d e, f ]
11:16:04 <ilyak_> This function if O(1)
11:16:14 <ilyak_> Which does not mean it would be extremelly fast
11:16:26 <ilyak_> But it would catenate two lists efficently
11:16:28 <ilyak_> I guess
11:16:33 <ilyak_> Would not it? :)
11:17:31 <twanvl> ?src (++)
11:17:31 <lambdabot> (++) []     ys = ys
11:17:31 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
11:18:04 <ilyak_> Why would it be O(n) then?
11:18:15 <twanvl> ilyak_: It is still O(n), but the cost is spread out over the elements of the list
11:18:26 <tromp> it's O(first list size)
11:18:53 <ilyak_> Why? If we're doing this lazily?
11:20:17 <augustss> complexity is confusing with lazy evaluation
11:20:36 <tromp> b/c you assume strictness in complexity analysis
11:21:01 <Peaker> how do Haskell programs/compilers address time-complexity issues that arise from the lack of in-place mutations?
11:21:06 <tromp> you assume all of result will eventually be used
11:21:06 <augustss> The time it takes to compute l1++l2 is O(time to compute l1 to WHNF)
11:21:07 <ilyak_> tromp: And what?
11:21:25 <yitz> dcoutts_: can I use glade3 with gtk2hs, or only glade2?
11:21:40 <dcoutts_> yitz: they are both compatible
11:22:05 <dcoutts_> augustss: I was looking at Koen's ParseK, do you know if the version on your website the latest version? (he doesn't have any version on his own site)
11:22:10 <yitz> ok. Because I notice that the port only depends on libglade2.
11:23:04 <dcoutts_> yitz: right but glade2 and 3 are both compatible with libglade-2.x
11:23:15 <yitz> ah, ok.
11:23:23 <dcoutts_> augustss: and why isn't everyone using ParseK given the symmetric choice and all the different parseLongest/shorest methods etc
11:23:29 <augustss> dcoutts_: I might have some small updates to it at work
11:23:50 <augustss> dcoutts_: because it can blow up exponentially in your face :(
11:24:00 <Peaker> is it possible to implement any algorithm in Haskell, in the same time-complexity?
11:24:08 <Peaker> (as it is in imperative languages, that is)
11:24:09 <dmwit> Peaker: Have you seen Okasaki's work on data structures?
11:24:15 <Peaker> dmwit, Nope
11:24:26 <dcoutts_> augustss: oh :-( on what kind of grammars or inputs? I'm looking for a better parser for Cabal. (ReadP has no error messages)
11:24:33 <mrd> ?go purely functional data structures
11:24:34 <lambdabot> http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
11:24:35 <dmwit> Peaker: He deals a lot with time (and space) complexity in a lazy, immutable world.
11:24:46 <Peaker> dmwit, cool, thanks
11:25:08 <augustss> dcoutts_: I'm not sure when, but it happened to me when parsing a simple language of expressions
11:25:33 <dmwit> Peaker: I believe it's been shown that there are algorithms in a strict mutable language which have no equivalently-performant counterpart in a lazy, immutable language.
11:25:51 <gwern> Peaker: with laziness and destructive updates, you can get better complexities than imperative
11:25:51 <dcoutts_> dmwit: really? I thought that was still open
11:25:58 <dmwit> Peaker: (But the worst difference in time complexity is a factor of O(log n) or something.)
11:26:09 <Peaker> dmwit, but aren't there ways to optimize each of those cases specifically, add extra hints/assertions for the compiler to use, etc?
11:26:18 <SamB> gwern: how can that be so?
11:26:20 * Botje would also be interested in a nice parser library, since he's about to make an ML compiler in haskell
11:26:24 <dmwit> dcoutts_: I don't know, I didn't actually read the paper; but there was a headline on proggit. =P
11:26:26 <augustss> dmwit: it has definitely been shown that a strict language with mutation is more efficient than a strict language without mutation
11:26:28 <gwern> Peaker: but if you only use laziness, I think okazaki shows that you can always get a corresponding algorithm with log slowdown, or something like that
11:26:42 <dcoutts_> dmwit: I thought it had only been shown that strict mutable was faster than strict pure.
11:26:46 <dmwit> augustss: Ah, that's probably what I'm thinking of.
11:26:59 <Peaker> gwern, cool
11:27:13 <SamB> gwern: or at least, wouldn't that be really hard to prove? it's not true in the O(n) sense...
11:27:15 <dmwit> Peaker: See augustss/dcoutts_ comments. ;-)
11:27:18 <gwern> SamB: why would it not be so? it seems pretty intuitive to me, combining two optimizations is better than either one alone
11:27:19 <augustss> dmwit: it's probably true for lazy as well, but I don't know if iy has been shown
11:27:27 <dcoutts_> dmwit: for the example they found it could be done in a pure *lazy* language in the same time complexity as the strict mutable language.
11:27:42 <SamB> gwern: but you can translate the lazy algorithm to a mutation-only algorithm
11:28:04 <dmwit> dcoutts_: That's right, I remember that now.  The lazy algorithm had a really clever use of transpose, right?
11:28:12 <dcoutts_> dmwit: that's the one
11:28:27 <SamB> that is, there isn't any way to actually prevent laziness from being used once unrestricted mutation is allowed...
11:29:00 <Peaker> dmwit, k, cool, thanks I'll read those papers
11:29:29 <mofmog> is there a handy lex for s-expressions
11:29:29 <mofmog> or a way to parse nested lists
11:29:29 * gwern shrugs. I don't have a link to the paper I read on the topic
11:30:15 <mrd> if I want to watch a bunch of files for modifications, am I basically left to polling modify-times every so often?
11:31:36 <dmwit> Depends on your OS.
11:31:45 <dmwit> Newer versions of Linux have inotify, and MacOS X has some equivalent (or better) counterpart.
11:31:57 <mrd> hmm
11:34:30 <mofmog> nvm
11:35:33 <byorgey> mofmog: 'lex', 'reads', and so on are rather low-level for parsing.  you may want to take a look at something like Parsec.
11:36:35 <mofmog> yeah i realized
11:38:32 <hpaste>  desegnis pasted "sclv: I tried to do it with pairs, and it got worse!" at http://hpaste.org/6212
11:38:42 <hpaste>  yitz pasted "gtk2hs compile error" at http://hpaste.org/6213
11:39:36 <yitz> dcoutts_: sorry, stuck again. any ideas?
11:39:52 <dcoutts_> yitz: the error message describes the problem
11:40:11 <dcoutts_> you're building gtk2hs including profiling but you did not build mtl with profiling
11:40:48 <dcoutts_> yitz: so either don't build gtk2hs with profiling, or build mtl with profiling
11:40:53 <yitz> Why did the previous compiles work? They also ask for profiling
11:41:09 <yitz> I'm just asking the port to build itself.
11:41:43 <yitz> How do I add profiling to mtl? I just did the usual cabal dance to install it.
11:45:11 <Lemmih> yitz: Configure it with -p.
11:45:53 <yitz> Like this? runhaskell Setup.hs  configure -p --with-compiler=ghc-6.8.2
11:46:09 <Lemmih> yitz: Looks good.
11:46:16 <yitz> ok, I'll try it.
11:46:41 <hpaste>  ilyak pasted "To profile" at http://hpaste.org/6214
11:46:58 <ilyak_> Can someone profile that for me and hpaste results?
11:47:10 <ilyak_> I can't get the damn thing to compile with -prof
11:47:54 <sclv> desegnis: doesn't look worse to me, just about the same, actually?
11:47:56 <ilyak_> Also, ideas on refactoring it are welcome
11:48:01 <ilyak_> As it's pretty ugly
11:48:25 <Lemmih> ilyak_: Why can't you compile it with -prof?
11:48:40 <ilyak_> Lemmih: http://hpaste.org/6211
11:49:33 <dmwit> ?index getArgs
11:49:34 <lambdabot> System.Environment
11:49:46 <dmwit> ilyak_: Try importing System.Environment instead?
11:50:06 <dmwit> (and System.IO instead of IO, Data.Char instead of Char)
11:50:35 <ilyak_> dmwit: Same thing
11:50:44 <ilyak_> It complains on System.Environment now
11:53:03 <sclv> ilyak_: cripes. whatever the issue, it sure is slow...
11:53:48 <sclv> are you sure it terminates?
11:54:29 <ilyak_> sclv: Yeah, 2 minutes on my machine
11:54:36 <ilyak_> beef does that in 2 seconds
11:54:56 <ilyak_> Profiling is going to slow it down, also
11:55:50 <xerox> Anybody got handy some code to reify numbers in types and vice-versa ?
11:58:01 <sealioN> Hi, I am going to write a program that is to evaluate wherather a certain proof is guilty or not.. like: "and p q, imply p q, !q, eval p" where eval p in this case means: "evaluate wheather this proof is true or not"
11:58:11 <sealioN> the problem is that this is to an embedded language using monads :S
11:58:21 <sclv> btw ilyak_ I assume you've seen: http://sabbatical-year.blogspot.com/2008/01/brainfuck-its-last-one-i-promise.html
11:58:23 <lambdabot> Title: my sabbatical year diary: Brainfuck - it's the last one, I promise, http://tinyurl.com/3boata
11:58:37 <yitz> xerox: a few packages were just released within the past few week. Look around on hackage, and the cafe archives. (or google)
11:58:38 <ilyak_> sclv: No I didn't
11:58:49 <sealioN> so my question is: how should the monad head look alike? and how should the type of the monad look like?
11:59:04 <ilyak_> Also, the link is crashing my konq :(
11:59:09 <johnnowak> does anyone have good examples of the utility of GADTs besides darcs?
11:59:42 <smg> hello Cale :) i read your suggested book, do you have more hints for me? ;)
11:59:56 <roconnor> GADTs are used to implement the typed lambda calculus.
12:00:04 <Cale> smg: hehe, which book was that?
12:00:12 <Cale> smg: What would you like to know more about?
12:00:38 <roconnor> app :: Term (A -> B) -> Term A -> Term B
12:00:45 <roconnor> ...
12:02:14 <dmwit> sealioN: The problem is really too ill-specified to give an answer.
12:02:33 <yitz> roconnor: I'll bet we can come up with some more practical examples.
12:02:54 <sealioN> yea, I realized that too, in fact, this assignment might fail me cause I am too damn inexperienced with monads and embedded languages
12:03:02 <sealioN> :)
12:03:42 <smg> Cale: more advanced haskell
12:04:01 <smg> Cale: maybe you have some good thing to read for me otherwise i will stick to just write programs for learning
12:04:15 <ilyak_> sclv: Did it terminate?
12:04:37 <Cale> smg: Well, most of the more advanced topics are covered by a variety of papers.
12:05:11 <sclv> ilyak_: yes, just now. the results were unfortunately... less than enlightening.
12:05:37 <yitz> How about this: there are two ways to select on an ADT - by pattern matching on the constructor, and by matching on the type. GADTs allow us to decouple those.
12:05:48 <sclv> 100% of the time spent in render (surprise).
12:05:51 <smg> Cale: okay so i stick to write programs for fun and learning :]
12:06:30 <ilyak_> sclv: Paste them please
12:06:38 <Cale> smg: Yeah, http://research.microsoft.com/~simonpj/  Simon's papers are also good reading :)
12:06:38 <lambdabot> Title: Simon Peyton Jones
12:06:40 <sclv> you'll need to manually set some call center allocations to get anything useful.
12:06:51 <smg> Cale: okay ty i will read :)
12:07:02 <Axioplase> Hum.. Set is a CCC. Is "POWERSET" one too? (Object: subsets, arrows between all subsets)
12:07:13 <smg> CCC?
12:07:14 <hpaste>  sclv annotated "To profile" with "results (sigh)" at http://hpaste.org/6214#a1
12:07:29 <Cale> smg: Cartesian closed category
12:07:31 <Axioplase> smg: Cartesian Close Category. (I wrote too fast)
12:07:53 <Cale> Axioplase: The subsets of a specific set?
12:07:59 <Axioplase> Cale: yes
12:08:04 <smg> haha ok
12:08:16 <Cale> Well, the product of two subsets is not generally isomorphic to a subset.
12:08:24 <Cale> (nor is the exponential)
12:08:59 <Axioplase> Can't I define my own isomorphism? such as AxB =~ A U B
12:10:14 <Cale> But is A union B really a product object?
12:10:51 <Axioplase> Well, I would need to check the unicity of f : X |--> AxB
12:11:28 <oerjan> product is defined by a universal property.  there will be at most one candidate up to isomorphism
12:11:48 <Axioplase> Hum.
12:12:09 <Cale> and what would the projections be?
12:12:11 <mofmog> i have the procedure parseList = liftM CalcLs $ sepBy parseVal spaces
12:12:32 <mofmog> CalcLs is a data type and parseVal is a parser that outputs CalcLs's
12:12:53 <mofmog> however, it can also parse lists with parseList of course.
12:13:15 <oerjan> um spaces can match an empty string cannot it?  that may be a problem
12:13:25 <yitz> dcoutts_ and Lemmih: gtk2hs works, thanks! I'll let Greg know about my experiences.
12:13:33 <oerjan> *can it not
12:13:49 <Axioplase> Cale: right. I do have a problem I think..
12:13:55 <mofmog> i have my own version of spaces
12:14:03 <oerjan> ok
12:14:08 <mofmog> a lot of this code is basically me taking apart write your own scheme interpreter in 48 hours
12:14:23 <mofmog> i'm trying to strip it down to the most basic parts for a simple calculator with nested operations
12:14:30 <roconnor> ``Differential Calculus with Datatypes: the hole story''
12:16:54 <Cale> Axioplase: But here's a question -- what happens if you take a particular set and all its subsets, and the functions between them, and find the smallest subcategory of Set which is Cartesian closed, and contains that category as a full subcategory?
12:17:47 <tromp> > sum [i*i | i <- [1..18]]
12:17:48 <lambdabot>  2109
12:18:05 <ilyak_> sclv: Wow! I probably should break down it :)
12:18:11 <dmwit> > sum . map (^2) $ [1..18]
12:18:11 <lambdabot>  2109
12:18:29 <sclv> haha yeah the profile was like a shaggy dog joke. you know how to scc ?
12:19:02 <yitz> > sum $ map (^2) [1..18]
12:19:03 <lambdabot>  2109
12:19:14 <sclv> http://www.haskell.org/ghc/docs/latest/html/users_guide/profiling.html -- see 6.1
12:19:15 <lambdabot> Title: Chapter 6. Profiling, http://tinyurl.com/kwh6c
12:19:30 <sclv> erm. 6.1.1 that is.
12:20:37 <mofmog> is it just me or is that real world applications for haskell book's website
12:20:37 <mofmog> down
12:20:46 <ilyak_> I guess it inlined everything
12:20:52 <ilyak_> I wonder why it did that
12:20:53 <oerjan> haskell, now with the worst shaggy dog jokes ever
12:21:27 <mofmog> "OK so there was this reeallly functional language"
12:21:36 <mofmog> and everyone agreed, it was REALLY functional.
12:22:00 <mofmog> So they took it to the functionality contest and everyone agreed- definitely functional. So this language won the regionals and came to state where it met it's largest competition ever
12:22:01 <oerjan> this sounds like the history of LISP :D
12:22:18 <sclv> ilyak: not sure if it inlined it, or rather if it just doesn't automatically add cost centres to functions defined in where clauses.
12:22:22 <mofmog> it totally beat out the other languages and it was like "HOLY DANG THAT IS REALLY FUNCTIONAL"
12:22:34 <mofmog> and then it went to nationals and then the functional olympics where a judge said
12:22:44 <mofmog> "this language isn't that functional"
12:22:51 <oerjan> ilyak_: only top level definitions get cost centres i think
12:23:00 * sclv knows where this is going and so bites his tongue hard.
12:23:27 <oerjan> sclv: um it's finished i think
12:23:39 <oerjan> but i still think it sounds like LISP :)
12:23:56 <sclv> so the language went to a functional college and studied really hard.
12:24:09 <sclv> and it got rid of all its remaining side effects, and adopted terse syntax from K
12:24:33 <sclv> and it got someone to build a machine for it sort of like the old symbolics
12:24:45 <sclv> so that it executed on purely functional hardware with transactional memory.
12:25:07 <Axioplase> Cale: I have no idea
12:25:07 <dmwit> :t StateT
12:25:09 <sclv> and eventually it went back to the contest.
12:25:12 <lambdabot> forall s (m :: * -> *) a. (s -> m (a, s)) -> StateT s m a
12:25:19 <sclv> after also studying debate and rhetoric.
12:25:30 <sclv> and the judge said again "this language isn't really functional."
12:25:48 <sclv> so the language pulls out its pages of documentation and notes, and rifles through, and finally says: "fuck you, judge!"
12:26:12 <Axioplase> But that's somehow what I was trying to set up (without the "and contains that cat as a full subcat")
12:26:18 <tromp> > 13/12
12:26:19 <lambdabot>  1.0833333333333333
12:26:25 <dogbite> hi all.  is there a function defined of this type?
12:26:27 <dogbite> [(a -> Bool)] -> (a -> Bool)
12:26:35 <dogbite> i want to combine multiple predicates
12:26:43 <dogbite> using either an OR or and AND
12:26:45 <mofmog> lambda?
12:26:56 <Saizan> dogbite: sequence
12:26:59 <dmwit> dogbite: Use "and" and "map" (or "or" and "map").
12:27:13 <oerjan> :t (and .) . sequence
12:27:14 <lambdabot> forall (m :: * -> *). (Monad m, Functor m) => [m Bool] -> m Bool
12:27:14 <mofmog> fold?
12:27:25 <gwern> sclv: is... is that the punchline? that's pretty terrible
12:27:33 <mofmog> it's a shaggy dog joke
12:27:36 <mofmog> that's the point
12:27:36 <dmwit> :t all
12:27:37 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
12:27:55 <dogbite> okay i will look at each of those options
12:28:01 <dogbite> thank you!
12:28:24 <dmwit> :t modify
12:28:25 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
12:28:32 <sclv> ?go "fuck you clown"
12:28:38 <lambdabot> http://everything2.com/index.pl?node_id=1088657
12:28:38 <lambdabot> Title: The "Fuck you, clown!" story@Everything2.com
12:28:39 <oerjan> :t all ($ ?x)
12:28:40 <lambdabot> forall a. (?x::a) => [a -> Bool] -> Bool
12:28:56 <oerjan> dogbite: ^^ that one too
12:31:14 <dogbite> okay, i'm reading about sequence now... will check 'all' next.
12:31:36 <oerjan> for sequence, it's the (r ->) monad version btw
12:31:48 <dogbite> what do you mean by that?
12:31:56 <dogbite> i'm reading in Data.Sequence
12:32:03 <oerjan> sequence l x = map ($ x) l when l is a list of functions
12:32:15 <oerjan> definitely wrong place :)
12:32:24 <oerjan> @google sequence
12:32:25 <lambdabot> http://en.wikipedia.org/wiki/Sequence
12:32:25 <lambdabot> Title: Sequence - Wikipedia, the free encyclopedia
12:32:29 <oerjan> argh
12:32:32 <oerjan> @hoogle sequence
12:32:32 <dmwit> ?hoogle sequence
12:32:32 <lambdabot> Prelude.sequence :: Monad m => [m a] -> m [a]
12:32:32 <lambdabot> Control.Monad.sequence :: Monad m => [m a] -> m [a]
12:32:32 <lambdabot> Data.Traversable.sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
12:32:33 <lambdabot> Prelude.sequence :: Monad m => [m a] -> m [a]
12:32:33 <lambdabot> Control.Monad.sequence :: Monad m => [m a] -> m [a]
12:32:34 <lambdabot> Data.Traversable.sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
12:32:40 <mofmog> return a function that takes in a
12:32:42 <oerjan> Control.Monad
12:32:49 <dmwit> Oh, that's really in the Prelude?
12:32:51 <dmwit> Good for them!
12:33:22 <oerjan> oh right
12:33:44 <yitz> :t all . flip id
12:33:45 <lambdabot> forall b. b -> [b -> Bool] -> Bool
12:33:51 <oerjan> dogbite: however the require Monad instance is in Control.Monad.Instances or .Reader
12:33:53 <dogbite> hmm okay i'm going to have to take my haskelling to the next level then
12:33:54 <yitz> dogbite: here's another one
12:34:00 <mofmog> then fold the map
12:34:27 <yitz> (so the exact type you want would be flip (all . flip id)
12:35:02 * wli fixes up stuff.
12:35:08 <dogbite> what does all ($ ?x) mean
12:35:17 <dogbite> i know the '$'
12:35:19 <dogbite> and the all
12:35:24 <dogbite> but what is the '?'
12:35:28 <mofmog> yourFunc listOfPredicates = \a -> foldr or #f $ map (apply a) listOfPredicates
12:35:28 <oerjan> dogbite: it's a section.  ($ x) f = f $ x = f x
12:35:30 <mofmog> would that work?
12:35:48 <mofmog> and apply a fn = fn a
12:35:53 <mofmog> *shrug*
12:36:23 <dogbite> mofmog: looking at it...
12:36:25 <oerjan> dogbite: the ? is a prefix for dynamically scoped variables.  it's just a trick to get :t to give types for expressions with undefined variables in them
12:36:35 <mofmog> dogbite: dont take my word for it im a noob
12:36:43 <mofmog> that's how i'd do it in scheme at least
12:36:45 <oerjan> *here it's just
12:37:51 <oerjan> mofmog: or in haskell already does such a fold
12:37:53 <oerjan> @src or
12:37:53 <lambdabot> or    =  foldr (||) False
12:38:10 <mofmog> ah
12:38:18 <mofmog> so you could just do
12:38:19 <oerjan> and (apply a) = ($ a)
12:38:31 <mofmog> or $ map ($a) listOfPredicates
12:38:41 <oerjan> but also, any combines those
12:38:44 <oerjan> @src any
12:38:44 <lambdabot> any p =  or . map p
12:39:25 <tromp> @help
12:39:25 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:39:33 <tromp> @list
12:39:34 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
12:39:34 <mofmog> well he also wants to be able to do and
12:39:50 <oerjan> mofmog: for which there is all that was mentioned before
12:39:53 <oerjan> @src all
12:39:53 <lambdabot> all p =  and . map p
12:40:09 <dogbite> so in teh case of
12:40:24 <dogbite> all p = and . map p
12:40:38 <dogbite> that doesn't do short circuiting which seems bad
12:40:43 <oerjan> sure it does
12:40:50 <oerjan> it's quite lazy
12:41:05 <dogbite> then we should get along then
12:41:08 <oerjan> > all (< 5) [1..]
12:41:08 <lambdabot>  False
12:41:21 <oerjan> infinite list, but finishes at the 5
12:41:27 <dogbite> got it
12:41:59 <mofmog> all (< 5) [1..3]
12:42:07 <mofmog> > all (< 5) [1..4]
12:42:08 <lambdabot>  True
12:42:09 <dogbite> :t and . map
12:42:10 <lambdabot>     Couldn't match expected type `[Bool]'
12:42:10 <lambdabot>            against inferred type `[a] -> [b]'
12:42:10 <lambdabot>     Probable cause: `map' is applied to too few arguments
12:42:23 <dogbite> @tyupe (and . map)
12:42:24 <lambdabot>     Couldn't match expected type `[Bool]'
12:42:24 <lambdabot>            against inferred type `[a] -> [b]'
12:42:24 <lambdabot>     Probable cause: `map' is applied to too few arguments
12:42:28 <dogbite> @type (and . map)
12:42:29 <lambdabot>     Couldn't match expected type `[Bool]'
12:42:29 <lambdabot>            against inferred type `[a] -> [b]'
12:42:29 <lambdabot>     Probable cause: `map' is applied to too few arguments
12:42:44 <oerjan> dogbite: you cannot leave off the p like that
12:42:48 <yitz> @pl \x -> and . map x
12:42:48 <lambdabot> all
12:42:51 <dogbite> okay i'm not even making sense right now... i actually just woke up and my head is foggy
12:42:52 <yitz> ha!
12:42:57 <dogbite> i'll clear my head and resume.
12:42:57 <oerjan> :t (and .) . map
12:42:59 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
12:43:47 <dogbite> okay so this and . map x combination doesn't take in a list of predicates
12:44:06 <mofmog> it does
12:44:08 <mofmog> map takes in a list
12:44:15 <mofmog> :t map
12:44:16 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
12:44:25 <mofmog> well ok that's not clear
12:44:38 <oerjan> it does if your x is something that can be applied to a predicate
12:44:45 <oerjan> thus the ($ x)
12:44:58 <mofmog> map takes a function and a list and returns a list where each element has been replaced by the function of the element of the list
12:45:00 <mofmog> so
12:45:18 <mofmog> > map (\x -> x + 2) [1,2,3]
12:45:19 <lambdabot>  [3,4,5]
12:45:39 <oerjan> > map (\x -> x 2) [odd, even]
12:45:40 <lambdabot>  [False,True]
12:45:46 <dogbite> right
12:45:48 <oerjan> @pl \x -> x 2
12:45:48 <lambdabot> ($ 2)
12:45:54 * wli discovers the bug for his rational Hermite stuff was some derivative order hardcoded in the problem setup.
12:46:21 <yitz> > map ($ 2) [(+ n) | n <- [1,2,3]]
12:46:21 <lambdabot>  [3,4,5]
12:46:50 <mofmog> does map in haskell take more than one list?
12:46:58 <oerjan> no
12:46:59 <mofmog> or do you just use zipWith for that
12:47:04 <oerjan> yep
12:47:24 <oerjan> :t zipWith3 -- and it goes on a little further
12:47:25 <lambdabot> forall a b c d. (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
12:53:38 <conal> anyone know how 'deriving Ord' works for an algebraic data type?  i'm wondering if it defines min using the component min methods or if it uses the default for min (in terms of <=).
12:53:55 * johnnowak wishes he could get lambdabot's help to work
12:54:22 <oerjan> http://www.haskell.org/onlinereport/derived.html
12:54:23 <lambdabot> Title: The Haskell 98 Report: Derived Instances
12:54:28 <whee> johnnowak: which help?
12:54:37 <Cale> conal: It's essentially lexicographic ordering.
12:54:45 <johnnowak> whee: i just want to see the list of commands
12:54:54 <roconnor> I now think of deriving datatypes as making one hole contexts.
12:54:56 <whee> johnnowak: http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
12:54:58 <tromp> @list
12:54:58 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
12:54:58 <Cale> conal: First by the order of the constructors in the data declaration, then on each of the fields.
12:55:17 <johnnowak> bah, forgot the @
12:55:19 <johnnowak> thanks
12:55:20 <conal> Cale: i have a type for which it's important that my own min be used, not the default.  i'm wondering if my min gets used by the min in the enclosing algebraic type.
12:55:45 <xerox> ?source Data.List
12:55:45 <lambdabot> http://darcs.haskell.org/packages/4/Data/List.hs
12:56:01 <conal> Cale: the reason is that my type has rich partial information content, which is preserved by min, but cannot be preserved by (<=) due to the Bool type.
12:56:14 <oerjan> conal: hm the report does not specify
12:56:53 <conal> oerjan: oog.  i guess that means it's a (current-version-of-)ghc question.
12:57:35 <Cale> I think there's an implicit assumption in the Report that instances of Ord be total orders.
12:58:31 <conal> Cale: that's no problem.  my type is totally ordered.  but non-flat.
12:58:51 <oerjan> actually is it generally possible to define min using only min of the components?
12:59:07 <conal> btw, i'm playing with Warren Burton's "improving values" as a basis for simple & efficient FRP
12:59:14 <oerjan> you would need to compare for equality
13:00:16 <oerjan> min (a,b) (c,d) = if minac == a then (a,b) else (c,d) where minac = min a c
13:00:43 <oerjan> it's not obvious that that == comparison is always reasonable to do
13:00:51 <conal> oerjan: i suppose you're right.  maybe mine is a special situation.  no products.
13:01:02 <conal> i sure wouldn't want to use ==, which could fail to terminate.
13:01:42 <conal> though i guess that'd be fine for me, since it wouldn't happen in the absence of products.
13:01:53 <conal> and seems unavoidable
13:02:08 <Cale> It seems not to call min in the derived instance.
13:02:19 <conal> Cale: how can you tell?
13:02:21 <conal> i'm talking about the type here: http://darcs.haskell.org/packages/reactive/doc/html/Data-SFuture.html#t%3AAddBounds
13:02:27 <lambdabot> http://tinyurl.com/27mccw
13:02:43 <dmwit> ilyak_: Did you figure out why that bf program was taking so long?  If not, I can tell you. =)
13:02:45 <Cale> conal: Debug.Trace
13:03:00 <conal> Cale: oh!
13:03:02 <Cale> conal: As well as just defining things in such a way that I can tell :)
13:03:12 <dmwit> ilyak_: (It has to do with the program you are running, not with your interpreter being inherently slow.)
13:04:31 <conal> thx, Cale & oerjan.  i'll probably define my own Ord instance to make sure min uses my min and not (<=).
13:04:49 <oerjan> conal: oh my min definition above is wrong btw it doesn't consider that a may be == c
13:04:53 <roconnor> @src Ord
13:04:53 <lambdabot> class  (Eq a) => Ord a  where
13:04:53 <lambdabot>     compare      :: a -> a -> Ordering
13:04:53 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
13:04:53 <lambdabot>     max, min         :: a -> a -> a
13:05:37 <conal> has anyone played with "improving values"?  seems a very powerful idea.
13:05:47 <conal> i'm using them in a new FRP implementation.
13:05:50 <roconnor> @where improving value
13:05:50 <lambdabot> I know nothing about improving.
13:06:33 <conal> go warren burton improving values
13:06:35 <conal> @go warren burton improving values
13:06:38 <lambdabot> Plugin `search' failed with: No Location header found in 3xx response.
13:07:04 <conal> the only online (though not free) paper i could find: http://portal.acm.org/ft_gateway.cfm?id=99402&type=pdf&coll=portal&dl=ACM&CFID=15151515&CFTOKEN=6184618
13:07:54 <mofmog> somebody ought to write a tutorial going over a reasonably complex program
13:08:03 <mofmog> but- with comments EVERYWHERE
13:08:08 <mofmog> explaining every singlelittle detail
13:08:19 <dmwit> mofmog: Check out dons' blog for a start.
13:08:40 <mofmog> also i wish ghci were more amenable to experimentation
13:08:49 <conal> that ref again, without the junk: http://portal.acm.org/citation.cfm?id=99402 . "Indeterminate behavior with determinate semantics in parallel programs"
13:08:51 <mofmog> but that's another story that i'm probably wrong about
13:08:52 <lambdabot> Title: Indeterminate behavior with determinate semantics in parallel programs
13:11:30 <roconnor> I find ghci fairly amenable to experimentation
13:11:58 <roconnor> I often use it to slowly compose up a long (80 char) function
13:12:12 <roconnor> then once I'm happy I stick it in my file and reload
13:12:17 <roconnor> and repeat
13:12:37 <roconnor> granted ghci isn't so great for data structure development.
13:12:57 <pkazmier> As a learning exercise, I want to write a CSV parser (that handles quotes).  I was going to use parsec but then read somewhere that parsec reads everything into memory first.
13:13:05 <pkazmier> I need to parse some very large files.
13:13:13 <mofmog> i should probably look into integrating haskell with emacs or something
13:13:30 <mofmog> it'd be awesome if i could just run a buffer instead of into a line
13:13:36 <pkazmier> And I can't do the standard "lines" trick as the quoted strings extend over more than one line.
13:13:51 <oerjan> yeah Parsec is based on checking the entire input for errors before returning anything
13:13:56 <Zao> pkazmier: getContents perhaps?
13:14:05 <Zao> Oh.
13:14:21 <newsham> you can do it fairly easily w/o parsec
13:14:53 <newsham> there's a csv lib on hackage, btw (if you wanted to peek)
13:15:02 <atsampson> Alex and a function to stick the lines back together would be pretty straightforward -- or even just hand-coding it...
13:15:13 <dogbite> would some of you remind revisiting my question about how to create
13:15:15 <dogbite> [(a -> Bool)] -> (a -> Bool)
13:15:21 <pkazmier> newsham: I'll look for the CSV package.
13:15:34 <dogbite> suppose something simple like
13:15:40 <dogbite> [even odd]
13:15:45 <dogbite> [even, odd]
13:15:49 <newsham> also http://www.thenewsh.com/~newsham/x/csv.hs   but might not be the most intelligent way to do it
13:16:04 <newsham> (and only handles quotes at the start of each field, i dunno what the RFC says is allwoed)
13:16:05 <oerjan> dogbite: wasn't that my example above?
13:16:05 <dogbite> i understand i could use map ($)
13:16:21 <roconnor> @type map ($)
13:16:22 <lambdabot> forall a b. [a -> b] -> [a -> b]
13:16:33 <roconnor> ($) is id
13:16:37 <roconnor> and map id is id
13:16:43 <roconnor> so map ($) is id
13:16:45 <pkazmier> newsham: that's all I really need.  nothing fancy, but my quoted cells do extend multi lines, as long as it handles that, it's perfect.
13:16:45 <oerjan> map ($ x)
13:16:46 <dmwit> He means "map ($ x)".
13:16:50 <roconnor> oh
13:16:55 <dogbite> right
13:17:09 <dogbite> thank you though roconor -- good to be precise
13:17:16 <oerjan> dogbite: ($ x) = flip id x  btw.
13:17:21 <newsham> hmm.. mine doesnt handle multiline stuff
13:17:24 <newsham> i belive the hackage does
13:17:55 <dogbite> so, i wrote this
13:17:56 <dogbite> let andPreds = (\ps x -> and $ map ($x) ps)
13:18:06 <roconnor> @type \l -> and . (sequence l)
13:18:06 <conal> @src all
13:18:07 <lambdabot> forall (f :: * -> *). (Functor f, Monad f) => [f Bool] -> f Bool
13:18:07 <lambdabot> all p =  and . map p
13:18:35 <dogbite> so when we get to sequence with functors and moands
13:18:49 <dogbite> it is currently beyond me.  but if that's what is needed
13:18:56 <dogbite> i will go dive in and read all about those and revisit
13:19:02 <roconnor> it's not needed, it is just really general :)
13:19:11 <dmwit> dogbite: That's a fine way to write it.
13:19:13 <conal> @type \ x -> all ($ x)
13:19:14 <lambdabot> forall a. a -> [a -> Bool] -> Bool
13:19:16 <roconnor> dogbite: maybe you should delay that.
13:19:20 <oerjan> dogbite: you don't need sequence.  it is just a trick to get the x after the list of functions
13:19:25 <conal> @type flip $ \ x -> all ($ x)
13:19:26 <lambdabot> forall a. [a -> Bool] -> a -> Bool
13:19:36 <roconnor> @pl flip $ \ x -> all ($ x)
13:19:37 <lambdabot> flip (all . flip id)
13:19:38 <dmwit> :t all . ($)
13:19:39 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
13:19:40 <dogbite> okay but each of those examples there
13:19:42 <oerjan> sequence l x = map ($ x) l so you can use the latter method
13:19:44 <dogbite> their output is a Bool
13:19:49 <dogbite> i want a function as my output
13:19:53 <dogbite> a predicate function
13:20:16 <roconnor> dogbite: [a -> Bool] -> a -> Bool means that a -> Bool is returned.
13:20:18 <dmwit> oh
13:20:20 <oerjan> dogbite: your andPreds looks fine
13:20:24 <dmwit> :t all . (flip ($))
13:20:25 <lambdabot> forall a. a -> [a -> Bool] -> Bool
13:20:28 <RayNbow> <roconnor> @type \l -> and . (sequence l) <-- hmm, GHCi can infer its type, but Hugs cannot
13:20:34 <dogbite> i see
13:20:41 <oerjan> apart from being possible to shorten
13:20:51 <roconnor> RayNbow: you need to import Control.Monad.Reader
13:20:55 <dogbite> i'm fine with shortening
13:21:20 <conal> @ty (fmap.fmap) and sequence
13:21:21 <lambdabot> forall (m :: * -> *). (Monad m, Functor m) => [m Bool] -> m Bool
13:21:21 <RayNbow> roconnor: my copy of Hugs doesn't know that module :p
13:21:22 <allbery_b> dogbite: auto-currying and lazy evaluation man you need to rethink everything you know :) any function taking two arguments is really a function taking one argument and returning a function
13:21:32 <RayNbow> but then again, my copy might be outdated :p
13:21:36 <newsham> \x -> all $ map (\p -> p x) preds
13:22:02 <newsham> err that's "and" not "all" I think
13:22:03 <newsham> ?type and
13:22:04 <lambdabot> [Bool] -> Bool
13:22:07 <newsham> yah
13:22:11 <oerjan> RayNbow: got it here
13:22:36 <RayNbow> Hugs> :version
13:22:37 <RayNbow> -- Hugs Version 20051031
13:22:41 <dogbite> i think i just realized that many of you are sending me direct messages
13:22:46 <dogbite> and i always reply publicly
13:22:53 <newsham> ?pl \preds x -> and (map (\p -> p x) preds)
13:22:53 <lambdabot> (and .) . flip (map . flip id)
13:23:08 <SamB> dogbite: oh?
13:23:11 <RayNbow> I haven't updated Hugs since I installed GHC for the first time :p
13:24:29 <oerjan> dogbite: a dogbite: doesn't mean a private message, the others can see that too.  at least i haven't sent you any private ones
13:25:07 <dogbite> oh, okay
13:25:13 <dogbite> in my client when you do that your name is bolded
13:25:19 <dogbite> nm then
13:25:30 <oerjan> dogbite: it's just a custom to make it easier to follow if there are several conversations ongoing at the same time
13:25:37 <oerjan> in mine too
13:25:56 <oerjan> dogbite: but for actual private messages, my client opens a new subwindow
13:26:27 <dogbite> so the thing i don't like about my 'andPreds'
13:26:53 <dogbite> let andPreds = (\ps x -> and $ map ($x) ps)
13:27:03 <oerjan> let's rewrite it so it looks more like what you want
13:27:04 <dogbite> is that the 'x' is tied up in there
13:27:06 <dogbite> it's explicit
13:27:16 <oerjan> oh
13:27:17 <dogbite> and of course it's a big lambda
13:27:25 <oerjan> indeed
13:27:33 <dogbite> and want something like 'and $ map _blah_ ps'
13:27:34 <oerjan> so let's see what @pl does with it
13:27:45 <oerjan> @pl \ x -> and $ map ($x) ps
13:27:45 <lambdabot> and . flip map ps . flip id
13:27:50 <dogbite> what is @pl -- a proofer?
13:27:52 <oerjan> eek
13:27:59 <oerjan> @help pl
13:27:59 <lambdabot> pointless <expr>. Play with pointfree code.
13:28:06 <oerjan> it removes lambdas
13:28:26 <oerjan> but that was not very successful.  let's change to using all
13:28:27 <dogbite> @pl (\ps x -> and $ map ($x) ps)
13:28:27 <lambdabot> (and .) . flip (map . flip id)
13:28:37 <oerjan> @pl \ x -> all ($x) ps
13:28:37 <lambdabot> flip all ps . flip id
13:28:53 <oerjan> hmph
13:29:00 <dmwit> \p -> and $ map p xs === all p xs
13:29:03 <dogbite> how does it know what 'ps' is in the thing you sent it
13:29:11 <oerjan> it gets ugly with those flippings.
13:29:13 <oerjan> it doesn't
13:29:16 <litb> hello all
13:29:22 <oerjan> it treats it as an unknown functino
13:29:23 <dmwit> ?src all
13:29:23 <lambdabot> all p =  and . map p
13:30:13 <oerjan> dogbite: however this is one of the reasons why the sequence method can be nicer.  because it keeps things in the right order, you don't get all those flips
13:30:27 <oerjan> @pl \x -> and $ sequence ps x
13:30:27 <lambdabot> and . sequence ps
13:30:35 <litb> @src all
13:30:36 <lambdabot> all p =  and . map p
13:30:39 <litb> oh
13:31:23 <newsham> ?src sequence
13:31:23 <lambdabot> sequence []     = return []
13:31:23 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
13:31:23 <lambdabot> --OR
13:31:23 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
13:31:46 <dmwit> ?index getArgs
13:31:46 <lambdabot> System.Environment
13:31:51 <fasta> Why is darcs pull to update a GHC tree so slow?
13:31:51 <newsham> thats with ((->)r) ?
13:32:12 <fasta> Little bandwidth and CPU is being used.
13:32:15 <litb> @users
13:32:15 <lambdabot> Maximum users seen in #haskell: 465, currently: 442 (95.1%), active: 22 (5.0%)
13:32:19 <fasta> What's it waiting for?
13:32:28 <litb> oh it is stagnating
13:32:41 <oerjan> newsham: yeah.  sequence ps x = map ($ x) ps
13:33:12 <oerjan> hm...
13:33:38 <newsham> bot needs a "name-that-monad" feature
13:33:52 <litb> Cale: you there?
13:33:55 <oerjan> > and $ sequence 5 [(> n) | n <- [1..]] -- checking if still lazy
13:33:55 <lambdabot>        add an instance declaration for (Num [[a -> Bool] -> Bool])
13:34:00 <Cale> litb: yeah
13:34:04 <oerjan> eek
13:34:21 <litb> do you remember what you explained me weeks ago?
13:34:26 <oerjan> oh
13:34:33 <oerjan> > and $ sequence [(> n) | n <- [1..]] 5 -- checking if still lazy
13:34:34 <lambdabot>  False
13:34:36 <litb> it was MonadState or something
13:35:19 <newsham> > runState (do { x <- get; put (x+3); return (x+5) }) 10
13:35:20 <lambdabot>  (15,13)
13:35:21 <dogbite> so if i change it to be
13:35:22 <dogbite> let andPreds = (\ps x -> and $ sequence ps x)
13:35:38 <litb> ah, yeah that was what he explained
13:35:40 <jrx> @src sequence []
13:35:40 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
13:35:43 <dogbite> then the type is
13:35:45 <litb> is that MonadState ?
13:35:50 <dogbite> andPreds :: [() -> Bool] -> () -> Bool
13:35:51 <jrx> @src sequence
13:35:51 <lambdabot> sequence []     = return []
13:35:51 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
13:35:51 <lambdabot> --OR
13:35:51 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
13:36:03 <oerjan> jrx: it's not a method, so you'll have to unwind the definition yourself :/
13:36:18 <jrx> oerjan: ok, I see it now
13:36:27 <dogbite> and i don't understand that type
13:36:35 <dejones> Hey Cale, you seem to be pretty knowledgeable of Haskell.  So, I'm curious, what are some things that are -not- good about Haskell?  Or issues with Haskell?  I guess maybe more specifically, issues with GHC?
13:36:43 <dogbite> to understand it i'll need to try again to understand monads?
13:36:44 <oerjan> dogbite: oh you're bitten by defaulting
13:36:57 <dejones> Anyone else feel free to comment, also.
13:37:00 <Cale> dejones: It doesn't have a decent extensible record or variant system.
13:37:09 <newsham> :t (do { x <- get; put (x+3); return (x+5) })
13:37:09 <oerjan> try let andPreds ps x = and $ sequence ps x
13:37:10 <lambdabot> forall (t :: * -> *) t1. (Num t1, MonadState t1 t) => t t1
13:37:15 <newsham> :t runState
13:37:15 <Cale> dejones: There's a large number of things about the Prelude which I would change.
13:37:15 <lambdabot> forall s a. State s a -> s -> (a, s)
13:37:31 <newsham> litb: that's "State" which is instance of MonadState I think
13:37:31 <litb> oh, yeah MonadState
13:37:32 <Cale> dejones: The translation of the do-syntax is silly, and was better in Haskell 1.4
13:37:40 <litb> and runState was the field in it
13:37:45 <dejones> Cale, an example of something in the Prelude you would change?
13:37:47 <fasta> dejones: also, check the long list of bugs in GHC for practical problems.
13:37:48 <Cale> litb: Sorry, I'm only partially here :)
13:37:50 <SamB> http://repetae.net/recent/out/classalias.html
13:37:50 <lambdabot> Title: Class Alias Proposal for Haskell
13:37:55 <newsham> runState is the field in the definition of State s a, yes.
13:38:04 <Cale> litb: You had a question about MonadState?
13:38:14 <litb> it's already solved :)
13:38:15 <dejones> fasta: thanks.
13:38:19 <dogbite> oerjan: yes that's it
13:38:24 <litb> i was wondering what you did explain me back then
13:38:33 <dejones> Cale: How is the translations of the do-syntax silly?
13:38:37 <newsham> litb: there are irc logs online, too
13:38:43 <fasta> dejones: other language implementations also have problems, of course.
13:38:45 <Cale> dejones: Well, ($) has the wrong associativity, fail is in the Monad class, signum and abs are in the Num class, which requires Show and Eq spuriously.
13:38:48 <dogbite> oerjan: what sequence am i using htere?
13:38:54 <dogbite> there seems to be multiple sequences
13:39:08 <oerjan> dogbite: the Prelude one
13:39:12 <SamB> Cale: where should signum and abs be?
13:39:12 <dejones> fasta: Sure.  I'm interested in GHC because I'm planning on doing some stuff with the RTS this...
13:39:14 <Cale> dejones: fail is used for pattern match failure, whereas mzero was a much better choice
13:39:17 <oerjan> which is also the Control.Monad one
13:39:24 <dogbite> okay got it
13:39:31 <Cale> SamB: Perhaps in their own subclass of Num, I'm not sure.
13:39:36 <SamB> Cale: I like fail for pattern match failure!
13:39:43 <Cale> SamB: why?
13:39:45 <dogbite> well i'm going to go meditate for 10 hours and see if i can digest monads and arrows
13:39:51 <SamB> Cale: I like line numbers
13:39:52 <dejones> Cale: Why does ($) have the wrong associativity?  Example?
13:39:54 <oerjan> dogbite: the Traversable one is also compatible, but generalized to more than lists
13:39:57 <dogbite> also, i wrote up the emacs calendar code in haskell
13:40:05 <dogbite> well, i removed all of the display code
13:40:16 <dogbite> but i wrote up the rest
13:40:24 <fasta> dejones: stuff?
13:40:24 <Cale> dejones: Well, currently, whenever you have  f $ g $ h $ x, you can always rewrite that as  f . g . h $ x
13:40:29 <litb> is the Reader monad much more complicated than MonadState ?
13:40:32 <dogbite> so i'll read about how to release code to the community or whatnot
13:40:39 <glguy> litb, simpler
13:40:47 <dejones> fasta: Trying to implement the GHC RTS do run directly on the hardware, without an OS.
13:40:49 <litb> oh
13:40:51 <Cale> dejones: However, try removing the parens from f (g x) (h y) (k z)
13:41:05 <glguy> ?seen dons
13:41:05 <lambdabot> dons is in #xmonad, #haskell-soc and #haskell. I last heard dons speak 12m 56s ago.
13:41:06 <fasta> dejones: doesn't House already do that?
13:41:11 <Cale> dejones: If $ had the opposite associativity, you could write that  f $ g x $ h y $ k z
13:41:20 <fasta> dejones: (in a more or less non-optimal way probably)
13:41:36 <newsham> litb: State lets you read and write the state.  Reader lets you read the state but not update it
13:41:39 <Cale> SamB: Well, it doesn't have to be in the Monad class for that anyway.
13:41:53 <SamB> Cale: I totally agree that fail should not be there
13:42:13 <dejones> fasta: Yea, it does... It's for a master's project though, so it doesn't have to be new work.  ;)  But, I am working on ideas for improving on House.
13:42:40 <dejones> Cale: I see.  Did they have a reason for the associativity that was chosen?  ;)
13:42:44 <SamB> dejones: one marvelous feature would be not having to fork GHC
13:42:48 <litb> hm, will there be a Haskell 1.6 ?
13:42:53 <Cale> dejones: Not a good one.
13:42:59 <newsham> > runReader (do {x <- ask; y <- ask; return (x+y)}) 10
13:43:00 <lambdabot>  20
13:43:07 <BMeph> Cale: Flipped a coin? ;)
13:43:10 <dejones> Cale: hehe.
13:43:13 <SamB> litb: I don't think so
13:43:30 <litb> newsham: oh i see
13:43:31 * SamB doesn't think Haskell' deserves to be named 1.6
13:43:42 * wli dances for joy as his rational Hermite interpolation code rocks the bloody world.
13:43:44 <dogbite> in general do you think i should think of putting the calendar code
13:43:45 <Cale> BMeph: Well, they were influenced by this idiom of chaining $'s, but I, and some others, have decided that's a really stupid idiom, and we should try to use composition instead.
13:43:46 <dejones> SamB: I'm not sure I understand what your point is...?
13:43:51 <litb> oh, well c++ is caled 2003, come on :D
13:43:52 <dejones> (sorry)
13:43:52 <dogbite> in the main Data.Time.Calendar code?
13:43:59 * BMeph wonders if SamB would call Haskell' 1.5.1
13:44:07 <newsham> litb: there's also Writer
13:44:09 <SamB> dejones: well, House includes a modified GHC in it's source tree
13:44:28 <SamB> BMeph: how about Haskell 98 SE
13:44:30 <dejones> SamB: Right, oh you were saying for the implementation of the RTS, running code directly would be nice.  :(
13:44:31 <dejones> :)
13:44:36 <litb> @src Writer
13:44:37 <lambdabot> Source not found.
13:44:40 <dejones> SamB: Sorry, I got confused.
13:44:43 <TomMD> Is Osker going anywhere?
13:44:47 <newsham> > runWriter (do {tell 10; return 20})
13:44:48 <lambdabot>  Add a type signature
13:44:59 <BMeph> Cale: Those idioms don't seem to conflict to me...am I missing something else? ;)
13:45:15 <BMeph> SamB: LOL!
13:45:24 <Cale> BMeph: You have a choice between f . g . h $ x and f $ g $ h $ x
13:45:28 <Cale> (currently)
13:45:28 <SamB> BMeph: it's fairly accurate
13:45:31 <SamB> isn't it?
13:45:35 <oerjan> newsham: the tell needs to be a Monoid
13:45:36 <dejones> TomMD: I haven't seen any news about Osker...
13:45:47 <Cale> BMeph: If the associativity of $ were flipped, then the latter wouldn't mean the same thing.
13:45:51 <oerjan> > runWriter (do {tell [10]; return 20})
13:45:52 <lambdabot>  (20,[10])
13:45:59 <Cale> BMeph: However, there's another reason to prefer the former.
13:45:59 <newsham> danke
13:46:11 <newsham> > runWriter (do {tell [10]; tell [30]; return 20})
13:46:12 <lambdabot>  (20,[10,30])
13:46:16 <SamB> oh, and Haskell 1.4 is Haskell NT 3.51 ;-P
13:46:16 <Cale> g . h is likely to be well-typed
13:46:23 <Cale> g $ h most likely isn't
13:46:35 <Cale> (though in wacky circumstances with typeclasses, perhaps)
13:47:54 <BMeph> oerjan: Heh-heh - "do tell" :)
13:47:54 <roconnor> g . h is a subexpression (modulo associativity)
13:48:14 <Cale> Right.
13:48:33 <oerjan> Cale: i have one small counterargument.
13:48:37 <SamB> more important by far than being well typed
13:48:40 <litb> the one that i give tell must be a monad ?
13:48:53 <Cale> So it expresses things in a more compositional way, which gets you thinking in the right way, and makes the code slightly easier to edit.
13:48:59 <SamB> litb: Monoid
13:48:59 <BMeph> Cale: Okay, I get that, then.
13:49:10 <Cale> It's easier to see where various laws can be applied, typically.
13:49:31 <litb> and in v1.4, $ was flipped?
13:49:36 <Cale> No.
13:49:44 <Cale> $ has always had the wrong associativity
13:49:47 <litb> do you think they will ever flip it ?
13:49:55 <Cale> I'd like to see it happen.
13:50:29 <SamB> Let's be optimistic
13:50:33 <dejones> :)
13:50:36 <litb> fight for Cale hehe
13:50:36 <Cale> My general hope is that the language continues to evolve.
13:50:45 <roconnor> hmm, now that I think about it the symbols of . and $ probably should be the other way around.
13:50:49 <Cale> and we don't get stuck in a morass of backwards compatibility
13:51:16 <litb> yeah, like in c++
13:51:20 <roconnor> well, we'll just drop Haskell one day and move onward with Epigram
13:51:25 <oerjan> Cale: currently there are a number of syntaxes that are right-extending, such as let, case, and \ .  when you use them you often place a $ in front.  so you may have intermingled $ with other right-extending syntaxes.  currently you can see at a glance how far they extend.  but if $ changed associativity you would have to check whether two $'s have any of the other (especially \) between them to know where the first ends.
13:51:36 <dejones> roconnor: Epigram?
13:51:38 <Cale> roconnor: Only if Epigram looks really really different by then :)
13:51:47 <SamB> my preference is that we somehow figure out a scheme where we can keep a reasonable amount of backward compatibility while still being able to change things
13:52:03 <roconnor> http://en.wikipedia.org/wiki/Epigram_programming_language
13:52:06 <SamB> like, oh, Python?
13:52:07 <Cale> oerjan: sorry?
13:52:09 <glguy> f $ \ x -> g $ \ y -> z
13:52:16 <litb> the good thing is that $ is a lib function and you can always change it
13:52:20 <newsham> O'Python?
13:52:22 <Cale> That'll mean the same thing it currently does.
13:52:35 <oerjan> Cale: i am saying that with the current associativity, $ nearly always extends far to the right
13:52:46 <dejones> roconnor: ty
13:52:48 <roconnor> Cale: I haven't acutally use epigram, but I reread "The View from the Left" this week.  It makes me excited about programming again!
13:52:58 <oerjan> but with left associativity you would have to check closer
13:53:06 <SamB> python generally tries to roll in backwards-compat breaking changes in two phases
13:53:23 <newsham> if only we could suspend programming for 100yrs while the mathematicians worked out the details
13:53:29 <Cale> oerjan: Can you give an example?
13:53:29 <glguy> a reversed $ is one of those things you can use today
13:53:32 <dejones> newsham: lol
13:53:35 <SamB> (corresponding with minor versions)
13:53:35 <roconnor> Cale: I kinda want to write my own GUI front  end to epigram
13:53:37 <litb> lol newsham
13:53:48 <roconnor> Cale: one that makes the code as nice as the latex examples.
13:53:51 <SamB> newsham: never happen
13:54:07 <SamB> the details can't be worked out without trying to use the programming languages...
13:54:15 <newsham> i'm joking, of course.  i enjoy "hacking" the old fashion way very muchly
13:54:30 <newsham> and I'm excited that some day the math people will make code much nicer
13:54:39 <newsham> but it will be the death of many things I also enjoy
13:54:52 <SamB> newsham: such as?
13:54:57 <litb> yeah. i used to enjoy c++
13:55:00 <newsham> such as cranking out C code
13:55:04 <newsham> or debugging assembly
13:55:10 <newsham> or auditing code for security bugs
13:55:16 <newsham> or writing fuzzers
13:55:20 <SamB> security bugs will always happen
13:55:25 <siti> that's depressing isn't it :p
13:55:25 <SamB> it's not possible to avoid them
13:55:26 <newsham> yah but not the same kind
13:55:27 <allbery_b> system administration becomes impossible.  yug
13:55:36 <newsham> they will eventually all be specificationb ugs
13:55:38 <newsham> bugs
13:55:40 <siti> I hate doing lots of work for little gain
13:55:42 <newsham> and not implementation bugs
13:55:43 <SamB> true, buffer overflows may become a thing of the past at some point...
13:55:50 <roconnor> newsham: are you talking about epigram?
13:55:51 <SamB> newsham: not possible
13:55:59 <newsham> roconnor: yes, among other things
13:56:35 <newsham> samb: i'm less pessimistic.
13:56:40 <gwern> no doubt primitive enjoyed grooming each other and eating the lice
13:56:41 <gwern> *primitive humans
13:56:42 <SamB> I mean, at that point what you refer to as specification will be the implementation
13:56:45 <litb> what the heck is epigram ?
13:56:49 <litb> yet another language out there?
13:57:02 <newsham> samb: yes.
13:57:03 <roconnor> litb: http://en.wikipedia.org/wiki/Epigram_programming_language
13:57:18 <roconnor> litb: it is a glipse into the future of typed functional programming
13:57:21 <newsham> samb: but it will be a lot higher level
13:57:24 <roconnor> glimpse
13:57:30 <SamB> newsham: sure
13:58:49 <litb> whoo that is wordy
13:59:01 <SamB> I suppose it might possibly be called a specification as well as an implementation...
13:59:06 <roconnor> hmm, I didn't actually read the wiki page
13:59:20 * gwern reads the WP article on epigram. maybe I am missing somethng, but the natural numbers example makes me very disinclined to program in epigram
13:59:46 <newsham> gwern: you dont normally use peano numbers?
14:00:07 <gwern> newsham: it's the length and readability compared to the haskell version given which botherme
14:00:16 <glguy> Your program won't have any bugs though since you won't finish it
14:00:23 <siti> lol
14:00:42 <monochrom> haha
14:00:48 <roconnor> gwern: it is the dependent case analysis which is the great part, ... and which isn't discussed much in the article.
14:01:09 <roconnor> gwern: when you do a case analysis, the types you need to return ``improve''
14:01:33 <gwern> what?
14:01:41 <roconnor> so that when programing you ``learn'' more as you do case analysis.
14:02:09 * roconnor opens his View from the Left window
14:02:33 <newsham> url?
14:02:40 <dejones> Norman Ramsey ever come in here?
14:02:47 <dejones> or the #ghc channel?
14:02:52 <litb> hm, but that natural number type definition is really too wordy
14:02:54 <litb> for me
14:03:52 <dons> dejones: not that i know of.
14:05:14 <roconnor> gwern: you can implement an association list of length m with the dendent type Vec (N * X) m  (where m is a natural number)
14:05:39 <roconnor> gwern: you can easily write a function that determins if a given index i is in the domain by doing a search through the list.
14:05:58 <roconnor> gwern: then you can write a look up function that takes an i and a proof that the i is in the domain of the list.
14:06:20 <mux> have you guys seen http://ocaml.janestcapital.com/?q=node/11 ?
14:06:21 <lambdabot> Title: HOWTO: Static access control using phantom types | ocaml.janestcapital.com
14:06:34 <roconnor> as you write the lookup function, as you do case analysis on the list, the type of the proof becomes more refined
14:06:41 <roconnor> because of the dependent types.
14:06:57 <gwern> mux: yes. it looks pretty cool; I'd like to see what an IO monad would look like if it had pervasive capabilities
14:06:58 <mux> it's quite a nice introductory text for phantom types, better explained than the haskell tutorials I remember about
14:07:05 <mux> I rewrote that in haskell
14:07:05 <dons> cool
14:07:15 <roconnor> eventually you can use this proof to elimiate the branch entirely, or use it to pick out the element being sought.
14:07:44 <gwern> roconnor: hm. and this is something you cannot do with the fancier GADT or phantom stuff in haskell?
14:08:35 <roconnor> I believe there are things that you can do here that you cannot do with GADTs, but GADTs are a good stepping stone to programming with dependent types.
14:10:29 <hpaste>  mux pasted "Reimplementation of the PRef type" at http://hpaste.org/6216
14:10:30 <johnnowak> i asked earlier but i'll ask again: are there any examples of the utility of GADTs aside from darcs?
14:11:01 <roconnor> johnnowak: didn't like my typed lambda calculus example?
14:11:46 <johnnowak> ah, must've missed that. but yes, i should also say something besides an evaluator. that does seem to be the common example.
14:11:53 <augustss> mux: it's a nice post, but it's nothing new
14:11:55 <hpaste>  mux annotated "Reimplementation of the PRef type" with "(no title)" at http://hpaste.org/6216#a1
14:12:14 <mux> augustss: sure not, but I found it particularly clear
14:12:37 <augustss> mux: yes, it's well written
14:13:02 <augustss> you can play fun tricks with phantom types
14:13:49 <hpaste>  tphyahoo pasted "can I have an instance Arbitrary a for all (Bounded a, Enum a)" at http://hpaste.org/6217
14:15:09 <augustss> tphyahoo: try turning on scoped type variables
14:17:32 <tphyahoo> right, thanks, with -fglasgow-exts at least it compiles...
14:18:08 <oerjan> you're definitely going to need overlapping instances as well
14:19:07 <hpaste>  (anonymous) annotated "can I have an instance Arbitrary a for all (Bounded a, Enum a)" with "(no title)" at http://hpaste.org/6217#a1
14:21:14 <quicksilver> @seen malcolmw
14:21:14 <lambdabot> I saw malcolmw leaving #haskell-soc, #haskell-overflow, #haskell-blah, #haskell and #ghc 1d 4h 24m 29s ago, and .
14:29:00 <litb> i wonder whether you could code a one-ary function as a StateMonad
14:29:13 <litb> using get to get the parameter, and put to put the result
14:29:38 <SamB> eh?
14:29:43 * wli grinds out some speedups and accuracy improvements.
14:29:56 <dmwit> Not really, that would restrict you to only functions of type (a -> a).
14:30:05 <SamB> what about the return value?
14:30:21 <litb> oh, wait. put will overwrite the input then
14:30:29 <dmwit> right
14:30:45 <litb> then i will take return for the result
14:30:54 <oerjan> > (do x <- get; return (2*x)) 10
14:30:54 <lambdabot>        add an instance declaration for (MonadState a ((->) t))
14:30:58 <oerjan> eep
14:31:03 <oerjan> > (do x <- ask; return (2*x)) 10
14:31:04 <lambdabot>  20
14:31:14 <litb> ah i se
14:31:18 <JohnToten> Hello, everyone.
14:31:25 <dmwit> Hiya, JohnToten!
14:31:32 <litb> hi JohnToten !
14:31:43 <tromp> :t (do x <- ask; return (2*x))
14:31:44 <lambdabot> forall (t :: * -> *) t1. (Num t1, MonadReader t1 t) => t t1
14:32:28 <litb> oh wait, why didn't you need runReader ?
14:32:40 <JohnToten> Does anyone know where I can download Web 2.0?
14:32:42 <oerjan> because it's (r ->), not Reader r
14:32:57 <litb> :t ask
14:32:58 <lambdabot> forall (m :: * -> *) r. (MonadReader r m) => m r
14:33:12 <facedown> :t ask WTF
14:33:12 <lambdabot> Not in scope: data constructor `WTF'
14:33:14 <oerjan> @instances- Control.Monad.Reader Reader
14:33:14 <lambdabot> Couldn't find class `Reader'. Try @instances-importing
14:33:19 <facedown> :t ask
14:33:20 <lambdabot> forall (m :: * -> *) r. (MonadReader r m) => m r
14:33:24 <oerjan> @instances- Control.Monad.Reader MonadReader
14:33:24 <lambdabot> r ((->) r), r (ErrorT e m), r (RWS r w s), r (RWST r w s m), r (Reader r), r (ReaderT r m), r (StateT s m), r (WriterT w m), r' (ContT r m)
14:33:30 <facedown> > (do 'LOL')
14:33:30 <lambdabot>  Improperly terminated character constant at "'LOL'..." (column 5)
14:33:51 <litb> @src ask
14:33:51 <lambdabot> Source not found. Where did you learn to type?
14:33:51 <oerjan> > do "LOL"
14:33:53 <litb> hm
14:33:54 <lambdabot>  "LOL"
14:34:04 <facedown> > do 'JESSICA ALBA'
14:34:04 <lambdabot>  Improperly terminated character constant at "'JESS..." (column 4)
14:34:05 <oerjan> @src (->) ask
14:34:05 <lambdabot> ask = id
14:34:10 <facedown> do 'JESSICA_ALBA'
14:34:14 <facedown> > do 'JESSICA_ALBA'
14:34:14 <lambdabot>  Improperly terminated character constant at "'JESS..." (column 4)
14:34:15 <JohnToten> Where do I download Web 2.0?
14:34:20 <facedown> > do 'JESSICAALBA'
14:34:20 <lambdabot>  Improperly terminated character constant at "'JESS..." (column 4)
14:34:22 <facedown> damnit
14:34:24 <JohnToten> I think my Web version is old
14:34:25 <facedown> it doesnt wanna do alba
14:34:27 <JohnToten> I need to upgrade
14:34:27 <oerjan> facedown: '' is for single characters
14:34:29 <facedown> lambadabot is gay
14:34:30 <facedown> oh
14:34:35 <facedown> > do "JESSICA ALBA"
14:34:35 <lambdabot>  "JESSICA ALBA"
14:34:37 <facedown> finally
14:34:41 <JohnToten> FINALLY
14:34:42 <JohnToten> THE BOT
14:34:43 <JohnToten> HAS DONE
14:34:44 <facedown> > do "CUM ON ALBAS FACE"
14:34:45 <lambdabot>  "CUM ON ALBAS FACE"
14:34:45 <JohnToten> JESSICA ALBA
14:34:45 <tromp> :t do "yo"
14:34:46 <lambdabot> [Char]
14:34:52 <JohnToten> do do
14:34:59 <JohnToten> > do do
14:34:59 <lambdabot>  Parse error at end of input
14:35:03 <litb> lolz
14:35:13 <facedown> >do URMOM
14:35:18 <facedown> >do URMOM
14:35:20 <facedown> > do URMOM
14:35:21 <lambdabot>   Not in scope: data constructor `URMOM'
14:35:27 <JohnToten> litb
14:35:29 <facedown> > do lambdabot
14:35:29 <lambdabot>   Not in scope: `lambdabot'
14:35:32 <JohnToten> I happen to like crusty black bitches
14:35:34 <JohnToten> So suck my dick
14:35:34 <facedown> > do main
14:35:34 <facedown> > do _self
14:35:35 <lambdabot>   Not in scope: `main'
14:35:35 <lambdabot>   Not in scope: `_self'
14:35:35 <JohnToten> Thx
14:35:38 <dmwit> Feel free to grow up a bit at any time...
14:35:41 <facedown> WHAT'S IN SCOPE?
14:35:44 <facedown> > do scope
14:35:45 <lambdabot>   Not in scope: `scope'
14:35:48 <JohnToten> FEEL FREE TO LICK MY SHAFT, DMWIT.
14:35:49 <facedown> what is the main namespace
14:35:56 <JohnToten> Fucking jewburglar
14:36:00 <facedown> > do DUNK ON SHAWN BRADLEY
14:36:00 <lambdabot>   Not in scope: data constructor `BRADLEY'
14:36:03 <facedown> lmfao
14:36:12 <JohnToten> do ROCKBOTTOM on DMWIT
14:36:15 <JohnToten> lmfao
14:36:26 <oerjan> @where ops
14:36:26 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
14:36:30 <facedown> @where alba
14:36:30 <lambdabot> I know nothing about alba.
14:36:33 <facedown> fucker.
14:36:36 <facedown> @where facedown
14:36:36 <lambdabot> I know nothing about facedown.
14:36:40 <facedown> @where lambdabot
14:36:40 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
14:36:50 <facedown> @where INTHEWORLDIS CARMEN SANDIEGO
14:36:50 <lambdabot> I know nothing about intheworldis.
14:36:51 <Gestapo> @where Anne Frank
14:36:51 <lambdabot> I know nothing about anne.
14:36:53 <facedown> LMFAO
14:36:54 <facedown> LMFA
14:36:55 <facedown> LOFMAO
14:36:55 <Gestapo> LMFAO
14:36:56 <facedown> LMFAO
14:37:13 * Gestapo shoots a Jew.
14:37:14 <facedown> roflmao
14:37:27 <dmwit> Did 4chan mention #haskell or something?
14:37:36 <facedown> they mentioned you
14:37:46 <facedown> and your crew
14:37:49 <litb> Gestapo: u a racist?
14:37:51 <Gestapo> dmwit, du liebe die schwulen, ja?
14:37:56 <Gestapo> Nein, litb.
14:38:02 <facedown> litb: are you a racist
14:38:04 <Gestapo> I mean
14:38:08 <facedown> IT DOESNT MATTER IF YOU'RE A RACIST.
14:38:09 <Gestapo> dmwit, liebe du die schwulen, ja?
14:38:12 <litb> facedown: natuerlich nicht
14:38:18 <facedown> i hate nazis
14:38:20 <facedown> im racist
14:38:23 <Gestapo> lol
14:38:23 <facedown> fuck nazis
14:38:31 --- mode: ChanServ set +o Igloo
14:38:38 <facedown> whoever bans me is gay
14:38:41 <facedown> and has aids
14:38:45 <dmwit> "Nazi" is not a race.  Just thought I'd give you a tip.
14:38:47 * Gestapo bans Facedown.
14:38:51 <facedown> bye
14:39:03 <Gestapo> BAH GAWD
14:39:16 --- mode: ChanServ set +o dons
14:39:18 <newsham> hmm, #haskell-blah?
14:39:25 <dmwit> hush
14:39:41 --- kick: Gestapo was kicked by dons (dons)
14:39:49 <Gestapo> FUCK YOU DON
14:39:50 <Gestapo> BAH GAWD
14:39:56 --- mode: ChanServ set +o vincenz
14:39:56 --- mode: dons set -b *!*n=g@147.21.16.*
14:40:14 <newsham> its more fun to commute
14:40:18 <Igloo> Is there an unban-everyone command?
14:40:32 <dons> let me clean that up now.
14:40:42 --- mode: dons set -b *!*n=l@*.nr.ip.pt
14:40:51 --- mode: dons set -b *!*=cornwall@*.dsl.wotnoh.sbcglobal.net
14:40:51 <allbery_b> Igloo: xchat has such a command
14:41:02 <dons> well, we don't want to unban everyone..
14:41:11 --- mode: dons set -b *!*@81.198.255.197
14:41:18 --- mode: dons set -b *!*@cable.netlux.org
14:41:24 <Igloo> I thought that was the simplest fix, and pretty much as good. People we banned ages ago probably won't come back anyway
14:41:31 --- mode: dons set -b *!*=tuomov@*
14:41:31 <vincenz> Wow, it was a troll invasion :)
14:41:38 <Igloo> But I'm happy for you to manually weed instead
14:41:41 --- mode: dons set -b *!*n=SAS@*.net.novis.pt
14:41:45 <newsham> not-recently-used caching
14:41:47 * allbery_b really needs to work out another audio channel 
14:41:54 --- mode: dons set -b *!*n=none@*.hsd1.vt.comcast.net
14:41:57 <newsham> flush em all, add back new ones as needed
14:42:03 --- mode: dons set -b *!*n=erwin@*.pitt.east.verizon.net
14:42:06 <augustss> howdy dons
14:42:19 <BMeph> waits for the end of the "Troll-a-polooza"
14:42:32 --- mode: ChanServ set -o dons
14:42:35 <dons> that'll probably do.
14:42:39 <dons> hey augustss
14:43:00 --- mode: Igloo set -o Igloo
14:44:31 <Korollary> I miss the pioneers who got banned from #haskell.
14:44:46 <dons> hehe
14:44:48 <dons> smedy?
14:44:52 <Korollary> They were the real deal. These are buncha hacks.
14:44:56 <dons> and we don't see xah these days
14:45:04 <oerjan> When programmers were real programmers and trolls were real trolls?
14:45:07 <dons> even gschuett was funny
14:45:18 <gwern> we could send qwe an invite
14:45:27 <newsham> ?keal
14:45:27 <lambdabot> ithink has to do with hardcased government failsafe in chip
14:46:11 <augustss> ?keal
14:46:11 <lambdabot> you need a Zh function in Haskell
14:46:28 <Cale> @keal
14:46:28 <lambdabot> making a bot of me is highly offensive
14:46:31 <Cale> @keal
14:46:32 <lambdabot> endian mirrors the decimal
14:46:36 <Korollary> He has a point there. We can't have functions with capital initials.
14:46:50 <Cale> @keal
14:46:50 <lambdabot> i think i know what code does but code looks to simple to actually do it
14:46:54 <newsham> and making a bot of him was highly amusing
14:46:56 <Cale> @keal
14:46:56 <lambdabot> i just got banned from math because i not have good ability to convey thoughts
14:46:58 <newsham> err.. offensive ;-)
14:47:02 <Cale> @keal
14:47:02 <lambdabot> evaluating expressions is ALL haskell does?????
14:47:11 <Cale> @keal
14:47:11 <lambdabot> i aint running that on my puter
14:47:11 <augustss> lol
14:47:13 <Cale> @keal
14:47:13 <lambdabot> they dumbified you
14:47:17 <Cale> @keal
14:47:17 <lambdabot> write an algorthim that generates the correct responses for a phone survey based on number of rings whether answered how quickly hung up on and the mood of the receiver
14:47:24 <Cale> @keal
14:47:24 <lambdabot> oh btw my fpu is blown due to a hardcased failsafe i have 3 year warranty right. and then they call fads
14:47:34 <Korollary> fads?
14:47:41 <dons> feds?
14:47:49 <Cale> @keal
14:47:49 <lambdabot> primary elemental assumption of integer coefficients to roots in counting sytem is wrong
14:47:49 <dons> he was convinced the feds were bugging his fpu
14:47:51 <Korollary> they call the feds for his fpu?
14:47:55 <Korollary> ah ok
14:48:20 <Cale> @keal
14:48:20 <lambdabot> i cant think anymore
14:48:24 <Cale> @keal
14:48:24 <lambdabot> actually it bug in math
14:48:34 <dmwit> Gotta love the arrogance.
14:48:36 <Cale> @keal
14:48:36 <lambdabot> with KealDigit quantum crackproof encryption possible
14:48:45 <Cale> @keal
14:48:45 <lambdabot> better be atleast 16x16 color with extended ascii set
14:48:50 <Cale> @keal
14:48:50 <lambdabot> you need a Zh function in Haskell
14:48:53 <Cale> @keal
14:48:53 <lambdabot> nsa try kill me numerous times
14:49:30 <gwern> @where lava
14:49:30 <lambdabot> I know nothing about lava.
14:49:49 <gwern> @quote lava
14:49:49 <lambdabot> No quotes match. Just try something else.
14:50:26 <augustss> lava?
14:50:33 <gwern> @quote something else
14:50:33 <lambdabot> No quotes for this person. My brain just exploded
14:50:34 <newsham> lava.net
14:50:44 <SamB> lava.net?
14:50:54 <SamB> hardware design for visual basic
14:50:55 <newsham> www.lava.net?
14:50:55 <SamB> ?
14:51:02 <gwern> SamB: I doubt it
14:51:18 <gwern> @where+ lava http://www.cs.chalmers.se/~koen/Lava/index.html
14:51:19 <lambdabot> Done.
14:51:28 <gwern> 'Lava is a hardware description language based upon the functional programming language Haskell. Its main aim is to show that modern programming language features such as type inference, polymorphism, higher-order functions, type classes, and laziness are very useful even in hardware description. '
14:52:05 <joed> Lava the video : http://www.youtube.com/watch?v=uYwS9k1ZexY
14:52:06 <lambdabot> Title: YouTube - Benny Lava
14:52:25 <newsham> ?go lavalava
14:52:25 <lambdabot> http://en.wikipedia.org/wiki/Lavalava
14:52:25 <lambdabot> Title: Lava-lava - Wikipedia, the free encyclopedia
14:53:07 <IsoPallo> Uh. Need some sleep... Just read that "a hardway description language"...
14:53:18 <gwern> 'Currently, there are two versions of Lava in use. One, Chalmers-Lava, developed at Chalmers University of Technology in Sweden, is mainly aimed at interfacing to automatic formal hardware verification tools. The other, Xilinx-Lava, developed at Xilinx Inc., is aimed at generating configurations for Xilinx' FPGAs. We hope to merge these two version soon. '
14:53:37 <gwern> pity they don't seem to've merged, nor does the chalmers one list any licenses anywhere but in scripts/
14:54:44 <gwern> (well, at least the related Hawk project has an obviously nonfree license, which makes life easier)
14:57:09 <dons> gwern: see funhdl.org
14:58:28 <gwern> (atom is an rss spec; what a bad name)
14:59:35 <gwern> not on hackage and bsd-licensed? interesting
14:59:58 <Cale> If time is money, then instead of expanding and contracting the money supply, why don't the central banks just turn their clocks backwards and forwards?
15:00:01 <dons> talk to the guys at Eaton
15:00:17 <dons> Cale, hmm!
15:00:32 <SamB> Cale: because people would sue them if time wasn't monotonically increasing
15:00:51 <gwern> Cale: then their sticky fingers wouldn't be able to dip into the back and forth flow
15:01:02 <Cale> gwern: hehe
15:01:17 <BMeph> "Time flies like an arrow. Fruit flies like a banana." ;)
15:01:31 <gwern> they do, don't they?
15:01:52 <oerjan> don't know, never met a time fly
15:02:13 <gwern> no, fruit flies I meant
15:02:20 * BMeph makes sure his time fly is tightly zipped
15:02:21 * oerjan now will check how this apple flies
15:02:43 <gwern> cottleston cottleston, cottleston pie
15:02:49 <gwern> a bird can fly, but a fly can't bird
15:03:29 <gwern> ask me why, and I reply:
15:03:31 <gwern> cottleston cottleston, cottleson pie
15:03:55 <augustss> atom has patent problems
15:05:08 * gwern waits for augustss to enlarge
15:06:17 <augustss> enlarge?  i could explicate...
15:06:41 <gwern> enlarge on your statement, naturally
15:06:51 <augustss> atom was/is using some technology that MIT has a patent on and that is licenced to Bluespec Inc
15:06:57 * oerjan thought augustss had shrunk to atom size there
15:07:09 <gwern> google 'define:enlarge' says: 'elaborate: add details, as to an account or idea; clarify the meaning of and discourse in a learned way, usually in writing; "She elaborated on the main ideas in her dissertation" '
15:07:44 <SamB> atom?
15:07:51 <gwern> augustss: how long ago? even software patents expire
15:08:08 <augustss> gwern: around 2000
15:08:56 <siti> is hackage super slow for anyone else
15:09:03 <siti> I am only getting 5KB a second downloads
15:09:04 <siti> :(
15:09:15 <gwern> so a good 8 years then; /me begins reading WP for patent duration in the US
15:09:40 <SamB> I thought that was 7 years
15:10:39 <gwern> 2008-2000 = 8; but US patents are apparently 20 yrs
15:10:57 <SamB> 20!!!?
15:12:05 <idnar> @index digitToInteger
15:12:05 <lambdabot> bzzt
15:12:09 <radix> @seen shapr
15:12:09 <lambdabot> I saw shapr leaving #haskell, #scannedinavian and #haskell-blah 20h 57m ago, and .
15:12:12 <idnar> @hoogle Char -> Int
15:12:12 <lambdabot> Data.Char.digitToInt :: Char -> Int
15:12:12 <lambdabot> Data.Char.ord :: Char -> Int
15:12:12 <lambdabot> Data.ByteString.Char8.count :: Char -> ByteString -> Int
15:12:23 <gwern> SamB: what, you thought the US has a rational IP system? it's a classic example of rent-farming/regulatory-capture
15:12:31 <SamB> true
15:12:40 <gwern> and other countries are even wrose; the EU has nasty database and moral rights
15:12:56 <SamB> what's wrong with moral rights?
15:13:13 <augustss> gwern: it's too bad about the patents, i don't think that stuff should be patented, even if the ideas are actually significant
15:13:33 <gwern> SamB: they are inalienable, for starters
15:13:44 <SamB> I'd patent stuff and give the patents to an appropriate NPO
15:14:08 <gwern> they make the idea of Free licenses a joke; taken literally and legally, it's impossible to put any artistic works under a truly Free licnse in a moral rights regime
15:14:21 <SamB> gwern: oh?
15:14:23 <gwern> code might be exempt fromt hat problem, but even that's iffy
15:14:23 <SamB> what do they do?
15:14:36 <SamB> the only moral right I'm aware of is claiming authorship
15:15:26 <gwern> SamB: no, there's the right of an author to not be 'defamed', there's the right to see his work not be abused, and so on
15:15:46 <gwern> 'Moral rights include the right of attribution, the right to have a work published anonymously or pseudonymously, and the right to the integrity of the work. The preserving of the integrity of the work bars the work from alteration, distortion or mutilation. Anything else that may detract from the artist's relationship with the work even after it leaves the artist's possession or ownership may bring these moral rights into play.'
15:15:57 <gwern>  read: derivative works
15:16:07 <litb> digitToInt is a weird name IMHO
15:16:41 <gwern> 'Independently of the author's economic rights, and even *after* the transfer of the said rights, the author shall have the right to claim authorship of the work and to object to any distortion, mutilation or other modification of, or other derogatory action in relation to, the said work, which would be prejudicial to his honor or reputation.' [emp added]
15:16:43 <gwern> 'In most of Europe it is not possible for authors to assign their moral rights (unlike the copyright itself, which is regarded as an item of property which can be sold, licensed, lent, mortgaged or given like any other property).'
15:17:04 <SamB> gwern: so ... you are saying that if the author says "slice this book to smithereans", the government is going to say "no no no! you can't do that!"
15:17:04 <SamB> ?
15:17:48 <SamB> hrmm, perhaps I should have said ribbons rather than smithereens
15:18:16 <Heffalump> what jurisdictions have all that stuff?
15:18:30 <gwern> SamB: moral rights, iirc can be inherited, so even if an author promises to not enforce his moral rights, who the heck knows what his crazy relatives are gonna do?
15:18:47 * BMeph cancels his plans for a new printing of "Steal This Book"...
15:19:08 <SamB> BMeph: I'm fairly certain that you aren't actually supposed to steal that book
15:19:17 <gwern> 'The director of Highlander II, Russell Mulcahy, wanted his name removed after the completion bond company took over film production, but he was contractually obliged not to impugn the film and he was told that using a pseudonym would impugn it.' <-- lol
15:19:19 <SamB> I personally bought it at a book sale
15:19:41 <gwern> 'Some European countries also provide for artist resale rights, which mean that artists are entitled to a portion of the appreciation of the value of their work each time it is sold.' <-- cute
15:20:23 <SamB> that would make sense if it was the original being sold... maybe...
15:20:54 <BMeph> SamB: Whether you're REALLY supposed to steal it or not, the very title could be construed as..."prejudicial to [the author's] honor or reputation". ;p
15:21:45 <SamB> hmm.
15:21:55 <SamB> we should sue the EU for GPL violation, then.
15:23:05 <gwern> did the eu ever accept the GPL license? gotta ccept a license to be bound by any non-proprietary terms
15:23:47 <biouser> 'a' is a type?
15:24:09 <biouser> > double :: Num a => a -> a
15:24:10 <SamB> have they distributed any GPL'd software?
15:24:10 <lambdabot>  Couldn't match expected type `Double' against inferred type `Doc'
15:24:31 <BMeph> So, if the value of money makes the book double in price, the author gets a piece? Interesting... :p
15:25:00 <BMeph> biouser: Better, 'a' is a type variable! ;)
15:26:08 <biouser> BMeph, so Num -> Num would serve the same purpose?
15:26:10 <Peaker> Hey, can someone explain "data RealFloat a => Complex a = !a :+ !a"  in English?
15:26:14 <mauke> no, Num is not a type
15:26:26 <Peaker> I know what the !  strict specifier means
15:26:30 <BMeph> biouser: See mauke's remark. :)
15:26:49 <biouser> okay, thnks, digesting...
15:26:53 <mauke> data Complex a = C !a !a
15:26:54 <tromp> @instances RealFloat
15:26:54 <lambdabot> Double, Float
15:27:03 <mauke> where C = (:+)
15:27:18 <Peaker> tromp, oh, I think I understand now
15:27:19 <biouser> Num is a type class... what is Int?
15:27:26 <mauke> Int is a type
15:27:39 <allbery_b> Peaker: given a type a which is a member of class RealFloat, a value of the type Complex a is constructed with the operator a :+ a
15:27:42 <biouser> Int is a part of the Num class then?
15:27:55 <mauke> no, Int is freestanding
15:28:00 <mauke> it's an instance of Num, though
15:28:00 <biouser> okay
15:28:36 <allbery_b> hm, should have used quotes, or maybe ML type variable syntax :)
15:28:44 <Peaker> allbery_b, thanks
15:28:46 <augustss> If you think of Num as a set then Int is a member of that set
15:29:50 <allbery_b> "given a type 'a which is a member of class RealFloat, a value of the type (Complex 'a) is constructed with the operator (a :+ a) where the `a's are values of type 'a"
15:30:05 <biouser> does anyone know of a good resource for systems of difference equations in haskell?
15:30:55 <augustss> The 'RealFloat a => ' part of the Complex declaration is best ignored
15:31:06 <mauke> "the â€˜aâ€™s"
15:31:36 <hpaste>  cdsmithus pasted "Can you improve this code? (graph isomorphism test)" at http://hpaste.org/6218
15:33:08 <biouser> > Prepend 1 (Prepend 2 Empty)
15:33:08 <lambdabot>   Not in scope: data constructor `Empty'
15:33:17 <mauke> > (:) 1 ((:) 2 [])
15:33:18 <lambdabot>  [1,2]
15:33:24 <mauke> :-)
15:33:40 <biouser> where do Prepend and Empty live?  Not in ghci I suppose?
15:33:46 <fnord123> When implementing a language that can have first order functions, we need gc to solve the problem of storing function arguments until function invocation, right?
15:33:50 <mauke> never seen those before
15:34:35 <biouser> thnks mauke ... looks like that was exactly what I was trying to do...
15:34:35 <roconnor> cdsmithus: what advice are you looking for?
15:34:45 <yitz> augustss: No mention of patent problems in the wikipedia entry for atom. Anyway, Google adopted it, so even the largest companies would think twice about trying to defend such a patent. (But IANAL) http://en.wikipedia.org/wiki/Atom_%28standard%29
15:34:46 <lambdabot> Title: Atom (standard) - Wikipedia, the free encyclopedia
15:34:57 <cdsmithus> roconnor: Improve the running time, mainly.  But I wouldn't turn down anything else you want to suggest.
15:35:00 <fnord123> I'm trying to remember the name of the 'problem' of storing func args
15:35:26 <fnord123> found it http://en.wikipedia.org/wiki/Funarg_problem
15:35:28 <biouser> 1:2:3:[]
15:35:29 <roconnor> cdsmithus: return a proof of isomorphism, or a disproof of isomorphism. :P
15:35:31 <biouser> > 1:2:3:[]
15:35:32 <lambdabot>  [1,2,3]
15:35:39 <augustss> yitz: that's a different Atom
15:35:51 <cdsmithus> roconnor: In profiling, this is about 70% of the time taken by an application I'm working on.
15:35:56 <yitz> Oh. What were you refering to.
15:36:09 <augustss> the hardware design language
15:36:13 <cdsmithus> roconnor: You mean you think I should return the isomorphism itself?
15:36:29 <gwern> yitz: I think that's a different atom
15:36:30 <augustss> yitz: funhdl.org
15:36:48 <roconnor> cdsmithus: ideally, but I don't know what your application is.
15:36:57 <gwern> hm. http://www.cs.helsinki.fi/u/ekarttun/hs-fltk/hs-fltk/
15:36:58 <lambdabot> Title: Index of /u/ekarttun/hs-fltk/hs-fltk
15:37:36 <cdsmithus> roconnor: (My app isn't very interesting.  It tests some hypotheses about relationship between graphs and related C* and Leavitt path algebras.)
15:38:26 <yitz> augustss: ok, thanks. unfortunate name, besides the patent problem. :)
15:38:29 <gwern> didn't know there was a haskell FLTK binding
15:43:04 <litb> oh
15:43:17 <litb> is the fltk binding better than gtk2hs ?
15:43:28 <gwern> 'Static type-checking in Camelot guarantees RAM usage -- not only its safety but also its amount.'
15:43:36 <gwern> litb: unlikely. gtk2hs is heavily maintained
15:43:51 <gwern> 'Static type-checking in TyPiCal guarantees the respect of some protocols. In Acute, you can check the safety of communications...'
15:44:16 <SamB> litb: well, that depends on whether fltk is better than gtk, partly...
15:44:28 <litb> well, i mean the bindings
15:44:31 <litb> not the backends
15:45:12 <gwern> litb: right, that's what I was answering - gtk and fltk are for different targets, so the former is not a sensible question to ask
15:45:33 <litb> oh i see
15:47:14 <biouser> can someone through me an example or two of map() ?
15:47:29 <biouser> or does it not fly in the interpreter?
15:47:34 <mauke> > map (+1) [1,2,3]
15:47:34 <lambdabot>  [2,3,4]
15:47:36 <gwern> > map (*2) [1..]
15:47:36 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,5...
15:47:49 <biouser> sweet, thanks..
15:47:50 <mauke> > map sqrt [2,10,99,3]
15:47:51 <lambdabot>  [1.4142135623730951,3.1622776601683795,9.9498743710662,1.7320508075688772]
15:48:00 <gwern> > map (not) [True,True..]
15:48:00 <lambdabot>  Parse error at "True...." (column 17)
15:48:08 <gwern> > map (not) [True..]
15:48:09 <lambdabot>  Parse error at "True...." (column 12)
15:48:13 <mauke> > map not [True, True ..]
15:48:14 <lambdabot>  [False,False,False,False,False,False,False,False,False,False,False,False,Fal...
15:48:28 <idnar> > maxBound :: Bool
15:48:29 <lambdabot>  True
15:48:40 <idnar> > True > False
15:48:40 <lambdabot>  True
15:48:42 <idnar> heh
15:49:02 <mauke> > map fromEnum [False, True]
15:49:03 <lambdabot>  [0,1]
15:50:59 <augustss> > map (toEnum . fromEnum) [False,True] :: [Ordering]
15:50:59 <lambdabot>  [LT,EQ]
15:51:15 <tromp> mapM_(print.g 2)[0..3] where g b 0=b;g b n=g c$s 0n-1where s _ 0=0;s e n=mod n b*c^s 0e+s(e+1)(div n b);c=b+1
15:51:29 <tromp> > mapM_(print.g 2)[0..3] where g b 0=b;g b n=g c$s 0n-1where s _ 0=0;s e n=mod n b*c^s 0e+s(e+1)(div n b);c=b+1
15:51:29 <lambdabot>  Parse error at "where" (column 24)
15:51:53 <tromp> @define g b 0=b;g b n=g c$s 0n-1where s _ 0=0;s e n=mod n b*c^s 0e+s(e+1)(div n b);c=b+1
15:51:54 <lambdabot> Undefined.
15:51:56 <whee> gwern: is gtk2hs the "standard" for desktop GUI?
15:52:20 <tromp> how to define functions for lambdabot?
15:52:42 <mauke> > let g b 0=b;g b n=g c$s 0n-1where s _ 0=0;s e n=mod n b*c^s 0e+s(e+1)(div n b);c=b+1 in  mapM_(print.g 2)[0..3]
15:52:42 <lambdabot>  Float with missing exponent at "0e+s(..." (column 61)
15:52:57 <allbery_b> @help let
15:52:57 <lambdabot> let <x> = <e>. Add a binding
15:53:13 <tromp> let g b 0=b;g b n=g c$s 0n-1where s _ 0=0;s e n=mod n b*c^s 0e+s(e+1)(div n b);c=b+1
15:53:20 <tromp> g 0
15:53:21 <mauke> Unsafe.Coerce> map unsafeCoerce [False,True] :: [Ordering]
15:53:21 <mauke> [LT,EQ]
15:53:22 <tromp> > g 0
15:53:23 <lambdabot>  Add a type signature
15:53:31 <tromp> > g 0 :: Int
15:53:31 <lambdabot>        add an instance declaration for (SimpleReflect.FromExpr Int)
15:53:31 <lambdabot>     In th...
15:54:08 <mauke> > let g b 0=b;g b n=g c$s 0n-1where s _ 0=0;s e n=mod n b*c^s 0 e+s(e+1)(div n b);c=b+1 in  mapM_(print.g 2)[0..3]
15:54:10 <lambdabot>  <IO ()>
15:54:20 <augustss> > x+y :: Expr Int
15:54:20 <lambdabot>      Kind error: `Expr' is applied to too many type arguments
15:54:20 <lambdabot>     In the type...
15:54:28 <mauke> > x+y
15:54:28 <lambdabot>  x + y
15:54:32 <idnar> unsafeEvil
15:54:37 <tromp> use map (g 2) [0..3] instead
15:55:04 <biouser> what are some good things to import for music and signal processing?
15:55:05 <augustss> > (x,x)
15:55:05 <lambdabot>  (x,x)
15:55:15 <tromp> > let g b 0=b;g b n=g c$s 0n-1where s _ 0=0;s e n=mod n b*c^s 0 e+s(e+1)(div n b);c=b+1 in map (g 2) [0..3]
15:55:15 <augustss> > (\x->x,x)
15:55:15 <lambdabot>  [2,3,5,7]
15:55:16 <lambdabot>  Add a type signature
15:55:39 <augustss> :t (x,x)
15:55:40 <lambdabot> (Expr, Expr)
15:55:58 <augustss> > \ x -> x+y
15:55:59 <lambdabot>   add an instance declaration for (Typeable Expr)
15:56:19 <BMeph> @type const undefined
15:56:20 <lambdabot> forall a b. b -> a
15:57:45 <BMeph> biouser: Dutch, I'd say. Import a couple boatloads of Dutch people, and you should rock out. ;)
15:58:14 <dons> biouser: check hackage.haskell.org under Audio and Sound
15:59:28 <biouser> BMeph, I would but there are local ordinances and stuff...
15:59:44 <biouser> plus Dutch people are relatively pricey...
16:00:08 <tromp> we are?
16:00:08 <BMeph> biouser: Ordinances against Dutch? What, did someone watch too many Austin Powers movies? ;p
16:01:08 <Peaker> what other monads are there except the IO monads? Where can I read about those?
16:01:33 <mauke> @instances Monad
16:01:34 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
16:01:55 <Peaker> why is Maybe a monad?
16:01:57 <mauke> also, IO monad (singular)
16:01:59 * BMeph watches Peaker's eyes glaze
16:02:09 <mauke> what do you mean by "why"?
16:02:15 <mauke> what kind of answer do you expect?
16:02:24 <Peaker> why can't it be a normal type/constructor?
16:02:28 <tromp> because return = Just
16:02:36 <mauke> Peaker: huh? it is.
16:02:44 <idnar> Peaker: what's the difference between a "normal type/constructor" and a monad?
16:02:45 <mauke> what makes you think Monad is special?
16:02:50 <Peaker> idnar, I don't know :)
16:03:01 <Peaker> mauke, The tutorial's explanation of IO monads
16:03:08 <idnar> Monad is a type class that defines a certain set of operations
16:03:08 <mauke> there is no "IO monads"
16:03:14 <BMeph> Peaker: For the same reason "why" lists are monads: because they have membership cards to "Club Monad". ;)
16:03:16 <mauke> there is an IO type, and it implements the monad interface
16:03:22 <mauke> @src Monad
16:03:22 <lambdabot> class  Monad m  where
16:03:22 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
16:03:22 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
16:03:22 <lambdabot>     return      :: a -> m a
16:03:22 <lambdabot>     fail        :: String -> m a
16:03:25 <idnar> Maybe supports that set of operations, so it makes sense to define a Monad instance for it
16:03:26 <mauke> that's all there is to it
16:03:40 <mauke> you can ignore (>>) and fail
16:03:41 <Peaker> From the haskell.org/tutorial: "It's best to think of the I/O monad as simply an abstract data type."
16:04:38 <BMeph> Peaker: That quote should be "IO monad", technically. I/O is done with IO monads, but so are other things. :)
16:04:39 <Peaker> mauke, could be nice to mention that whereever monads are explained
16:06:08 <mauke> bah, one day I'm going to finish this IO tutorial
16:10:12 <whee> what is the 'const' function usually used for?
16:10:43 <Heffalump> ignoring arguments, mostly
16:11:31 <roconnor> whee: applyed to higher-order functions
16:12:14 <augustss> it's surprisingly useful
16:13:05 <ZimaN> > map (const 3) [1..7]
16:13:06 <lambdabot>  [3,3,3,3,3,3,3]
16:13:49 <dons> i use it a lot in testing
16:14:12 <dons> where you want to test particular behaviours, but ignore some arguments you don't want to test yet
16:14:18 <augustss> wow, i've "written" and run my first iPhone application
16:14:26 <Peaker> > :t const
16:14:26 <lambdabot>   parse error on input `:'
16:14:52 <dons> awesome, augustss !
16:14:57 <biouser> fold1 not in scope...
16:15:14 <dons> foldr1 ?
16:15:17 <monochrom> foldl ? fold1 ?
16:15:19 <augustss> i.e., i started Xcode and made a new iPhone app and built the empty app :)
16:15:22 <dons> ?hoogle fold1
16:15:22 <lambdabot> No matches found
16:15:25 <dons> ?hoogle foldl
16:15:26 <lambdabot> Prelude.foldl :: (a -> b -> a) -> a -> [b] -> a
16:15:26 <lambdabot> Data.List.foldl :: (a -> b -> a) -> a -> [b] -> a
16:15:26 <lambdabot> Data.Foldable.foldl :: Foldable t => (a -> b -> a) -> a -> t b -> a
16:15:40 <mauke> toList = dfold (const (:)) []
16:16:02 <biouser> lol, thank you kindly...
16:17:29 <Botje> hmm
16:17:50 <Botje> in my compiler, i'm going to need annotations (probably of different types) for any one of my AST nodes
16:18:00 <Botje> how should I best solve that; HList?
16:18:45 <Botje> one big datatype Annotation with a lot of constructors?
16:20:21 <augustss> Botje: I'd do the second, but I'm old fashioned
16:20:37 <augustss> Botje: there's also Data.Dynamic
16:21:23 <mauke> possibly related: http://haskell.org/haskellwiki/Indirect_composite
16:21:24 <lambdabot> Title: Indirect composite - HaskellWiki
16:21:48 <Botje> hmm
16:22:55 <Botje> data.dynamic seems nice
16:23:38 <whee> entirely over my head :P
16:23:56 <Botje> i'll still have to fromDynamic stuff, but i can live with that
16:24:14 <Peaker> http://www.haskell.org/tutorial/io.html  is there a missing underscore suffix in "sequence as" or is that on purpose?
16:24:14 <lambdabot> Title: A Gentle Introduction to Haskell: IO
16:24:25 <mauke> :t cast
16:24:26 <lambdabot> forall a b. (Typeable b, Typeable a) => a -> Maybe b
16:25:02 <mauke> Peaker: that's a bug
16:25:13 <Peaker> mauke, ok, thanks
16:25:37 <Botje> on that matter, should I use something like uniplate or syb?
16:26:41 <mauke> @let (===) :: (Eq a, Typeable a, Typeable b) => a -> b -> Bool; x === y = Just x == cast y
16:26:41 <lambdabot> Defined.
16:26:46 <mauke> > 1 === 1
16:26:46 <lambdabot>  True
16:26:50 <mauke> > 1 === ()
16:26:50 <lambdabot>  False
16:31:03 <augustss> > x === x
16:31:03 <lambdabot>   add an instance declaration for (Typeable Expr)
16:31:03 <lambdabot>     In the expression: x ==...
16:31:27 <mauke> where is Cale when I need him
16:32:07 <hpaste>  biouser pasted "Parse error on input 'infixr'" at http://hpaste.org/6219
16:32:43 <augustss> biouser: no local fixity declarations
16:33:12 <mauke> that looks like an indentation error
16:33:24 <biouser> augustss, not sure what you mean... mauke, that's kinda what I was thinking...
16:33:41 <Heffalump> you can't make fixity declarations anywhere other than at top-level
16:33:57 <mauke> sure you can
16:34:01 <mauke> works fine here
16:34:43 <hpaste>  mauke annotated "Parse error on input 'infixr'" with "compiles" at http://hpaste.org/6219#a1
16:35:06 <Heffalump> oh. So you can.
16:35:16 <Heffalump> (having checked the report)
16:35:27 <Heffalump> I was sure there was some problem with that. Perhaps it's a problem for implementors :-)
16:35:30 <augustss> Hmmm, it seems ghc accepts local fixity declarations.  I could have sworn those were out
16:35:54 <augustss> yes, I know there are problems with them
16:35:59 <biouser> okay, thanks, I got it...
16:36:00 <Heffalump> the report says you can too
16:37:46 <augustss> i bet ghc doesn't implement them correctly
16:38:04 <augustss> they make parsing even more difficult
16:38:33 <augustss> but i can't remember the example :(
16:41:45 <twanvl> ghc doesn't handle fixity in the parser, it is done in a later pass
16:43:38 <augustss> twanvl: i know, but it doesn't help.  ghc can't parse haskell correct enyway (even without local fixity)
16:43:54 <augustss> s/correct/correctly/
16:44:47 <twanvl> no implementation does fixity handling in the parser as far as I know, so they are all incorrect in some corner cases
16:44:58 <twanvl> is ghc any worse?
16:45:22 <augustss> no
16:46:51 <fnord123> Is a list a union type or a product type?
16:46:58 <Heffalump> both
16:47:12 <Heffalump> data List a = Nil | Cons a (List a)
16:47:28 <Heffalump> the | is a union and the multiple parameters to Cons are a product
16:47:32 <Igloo> The example is things like    case True of _ -> 1 == 1 == True   I think, where the second == should close the implicit {
16:48:02 <Heffalump> that's not a fixity example, though
16:48:33 <mauke> List a = Either () (a, List a)
16:48:34 <Igloo> Yes it is, it's the infix-none fixity of ==
16:48:45 <twanvl> "union type" is not really correct, it is better to call it a "sum type" or "disjoint union type"
16:49:37 <Igloo> that causes the parse error
16:50:07 <Heffalump> IM it's not an example of local fixity making things worse
16:50:38 <augustss> right
16:50:51 <Igloo> Well, it would be much easier to tell the parser what the fixity of operators is, and thus parse correctly, if there were restrictions on where you can put the fixity information
16:51:22 <mauke> > case True of _ -> 1 == 1 == True where infixl 1 ==
16:51:23 <lambdabot>   Not in scope: `=='
16:51:37 <Igloo> I don't remember any other issues with local fixity declarations
16:51:44 <fnord123> Well a unit types can be stored on the stack. And a product of unit types and a disjoin union of units can be stored on the stack... And if a list is a product of a unit and the disjoint union of a unit or product of a unit and disjoint union (etc), is there not a way for it to be kept on the stack despite the potential to grow? If not, I'm wondering what stops it. perhaps the 'etc' of the list...
16:51:45 <gwern> 'I have the sudden urge to write a screensaver that generates random type theory proofs. They just look so cool.'
16:51:46 <mauke> > case True of _ -> 1 == 1 == True where infixl 1 ==; (==) = (Prelude.==)
16:51:47 <lambdabot>  True
16:52:10 <mauke> what stack?
16:54:12 <BMeph> ..is "the" stack? :)
16:54:47 <fnord123> The stack in terms of a von neumann architecture
16:55:06 <Heffalump> fnord123: I think you're ignoring the recursive aspect of lists
16:55:28 <Heffalump> a product can be stored on the stack if its subcomponents can be, and likewise for a disjoint union
16:55:40 <Heffalump> but your argument that therefore a list can be is based on the claim that a list can be
16:55:44 <mauke> List = Fix (\t -> \a -> Either () (a, t))
16:55:52 <Heffalump> which is not well-founded
16:56:19 <mauke> wait, I think I got that wrong
16:56:19 <augustss> Fix is the crux
16:56:22 <fnord123> Heffalump: I am ignoring it for now.
16:56:39 <Heffalump> well, that's what stops it
16:56:52 <Heffalump> so if you are trying to decide that question, you can't ignore it :-)
16:56:57 <fnord123> I'm not claiming a list can be stored on the stack. I'm exploring if it's possible to do a transformation such that it will be on the stack
16:57:18 <Heffalump> well, not in a statically sized stack frame, since it's size is unbounded
16:57:24 <Heffalump> s/it's/its/
16:57:28 <augustss> exactly
16:57:39 <Heffalump> (which is what I was taking "stored on the stack" to mean)
16:58:05 <augustss> otherwise anything can be stored on the stack
16:58:23 <fnord123> hm, I'm thinking along the lines of a cps transformation. Perhaps some stuff can be cleaned up and other stuff placed there since we don't intend on returning.
16:58:53 <gwern> @seen shapr
16:58:53 <lambdabot> I saw shapr leaving #haskell, #scannedinavian and #haskell-blah 22h 43m 44s ago, and .
16:59:05 <Heffalump> I think that's rather optimistic.
16:59:17 <augustss> fnord123: you can stack allocate everything if you are willing to GC the stack
16:59:25 <Heffalump> and sounds like you are treating the stack as a heap, really
17:00:09 <gwern> @tell shapr I saw an old blog post of yours about how combinatorrent turned into conjure; thought you might be interested to know: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/conjure-0.1
17:00:09 <lambdabot> Consider it noted.
17:00:31 <gwern> speaking on conjure, if anyone has any spare time, I'd appreciate noting how successful a cabal install of conjure is
17:02:59 <fnord123> augustss: I'm trying to avoid gc. Heffalump: possibly.
17:04:03 <augustss> fnord123: well, then you should look at region inference.  regions can behave like stacks, so you have different stacks depending on the lifetime of the object
17:04:45 <fnord123> that sounds reasonable
17:05:43 * wli develops a grand plan to avoid ever forming matrices of the size of the full system and instead fart around with various right and left singular vectors of much smaller matrices.
17:05:59 <augustss> region based allocation is quite clever.  but it works less well with lazy evaluation than strict evaluation
17:06:23 <eyeris> is darcs.haskell.org overloaded today? darcs get has been painfully slow for the past 5 hours or so
17:06:50 <Igloo> It's been rate and/or connection limited for the last few days
17:06:59 <eyeris> that would explain it
17:07:12 <eyeris> why?
17:07:23 <eyeris> to save money on bandwidth? I'd donate :)
17:07:29 <Igloo> Because it was using too much bandwidth
17:07:30 <augustss> fnord123: still, jhc uses region inference
17:08:06 * Igloo doesn't know how much T1's in the US cost, but I doubt you'd donate enough  :-)
17:08:42 <eyeris> T1's *can* be extremely cheap, as long as you're close to the POP
17:08:52 <augustss> indeed
17:08:52 <Igloo> Hopefully we'll get something worked out, anyway
17:08:55 <eyeris> The lowest I've seen is ~$150/mo
17:10:17 <biouser> anyone got Haskore up in ghci?
17:11:16 <gwern> 'the legal system is the ultimate DoS attack'
17:11:37 <gwern> biouser: did henning update haskore yet? I thought he was still updating the dependencies
17:12:18 <biouser> not sure, was hoping for a simple import Haskore :\
17:17:29 <gwern> @quote poetix
17:17:29 <lambdabot> No quotes match. I've seen penguins that can type better than that.
17:17:43 <gwern> @quote+ poetix <poetix> I would really like to read, as an epistolary novel, the Curry-Howard correspondance (that is, letters they wrote to each other). Yes, I know it's really a correspondence, that they didn't actually correspond. But someone should write the letters they would have written if they had.
17:17:43 <lambdabot> No quotes for this person. :(
17:18:13 <SamB> @remember poetix I would really like to read, as an epistolary novel, the Curry-Howard correspondance (that is, letters they wrote to each other). Yes, I know it's really a correspondence, that they didn't actually correspond. But someone should write the letters they would have written if they had.
17:18:13 <lambdabot> Okay.
17:18:34 <SamB> @quote poetix
17:18:34 <lambdabot> poetix says: I would really like to read, as an epistolary novel, the Curry-Howard correspondance (that is, letters they wrote to each other). Yes, I know it's really a correspondence, that they
17:18:34 <lambdabot> didn't actually correspond. But someone should write the letters they would have written if they had.
17:18:59 <gwern> oh. bleh. lambdabot has too many commands, and they aren't particularly consistent
17:19:06 <SamB> true enough
17:20:09 <jaj> @karma lambdabot
17:20:09 <lambdabot> lambdabot has a karma of 1
17:20:33 <gwern> at least remember is mentioned in the docs
17:20:35 <gwern> @help quote
17:20:35 <lambdabot> quote <nick>
17:20:35 <lambdabot> remember <nick> <quote>
17:20:35 <lambdabot> Quote somebody, a random person, or save a memorable quote
17:20:46 <SamB> @help remember
17:20:46 <lambdabot> quote <nick>
17:20:46 <lambdabot> remember <nick> <quote>
17:20:46 <lambdabot> Quote somebody, a random person, or save a memorable quote
17:22:09 <jaj> lambdabot should support private queries so you could have a real haskell prompt on IRC without flooding a whole channel
17:22:36 <gwern> jaj: it does
17:22:38 <gwern> through /msg
17:22:57 <jaj> really? I tried some time ago and it didn't work
17:22:59 <Cale> I think :t might not work though. You may need to use @type
17:23:22 <Cale> There's some strangeness with the special commands in private, I haven't really sorted out why.
17:23:44 <gwern> jaj: you a registered nick?
17:23:56 <gwern> freenode only allows registered nicks to privmsg, iirc
17:23:59 <jaj> gwern: yes. it works now, neat!
17:27:20 <BMeph> TomMD: Hello! :)
17:27:26 <TomMD> Hello
17:33:14 <sethk> can someone tell me why these patterns are overlapped?  It's a function that takes three strings:
17:33:26 <sethk> generateConfigFlags configFlags _ _ = configFlags
17:33:41 <sethk> generateConfigFlags _ [] defaultConfigFlags = defaultConfigFlags
17:34:05 <sethk> generateConfigFlags _ extraFlags defaultFlags = defaultFlags ++ extraFlags
17:34:06 <Zao> The first one looks rather all-catching.
17:34:20 <sethk> Zao, yes, but that's the behavior I want
17:34:29 <Zao> As in, the rest will never be tried.
17:34:36 <sethk> Zao, I can do it with guards, but I'm not sure why I can't do it this way
17:34:53 <Zao> Matches are made top-down, stopping when one fits.
17:34:56 <sethk> Zao, oh, I see, I really mean that configFlags length not zero
17:35:05 <sethk> so I do have to use guards
17:35:06 <sethk> thanks
17:35:42 <sethk> Or I can use [] instead of _ and change the sequence
17:36:16 <Zao> All ways are good except for the bad ones.
17:36:34 <sethk> :)
17:45:43 <dons> gwern: goldmine, http://www.ninebynine.org/Software/
17:45:47 <lambdabot> Title: Index of /Software
17:46:43 <dons> note we've no rdf parsers on hackage yet
17:49:31 <gwern> goodness
17:49:49 <gwern> there's a lot there, you're right
17:51:10 <ehird> gwern: go upload it all to hackage?
17:51:11 <ehird> :p
17:51:14 <ehird> you seem to like doing that
17:51:35 <siti> @botsnack
17:51:35 <lambdabot> :)
17:52:43 <gwern> ehird: yeah. sometimes I can't, though; too hard to update, licensing is wrong, etc. eg, I'd love to upload the GeomAlgLib library, but it uses some old Array stuff I've found very hard to update
17:53:30 <gwern> sometimes I get help in updating stuff. I recently hit a jackpot - I found a complete implementation of FiniteMap in terms of Data.Map. that has already been *so* useful
17:54:38 <hpaste>  gwern pasted "shapr on #haskell" at http://hpaste.org/6223
18:08:42 <gogonkt-``> I want to translate darcs manual,What sould I do? Who sould cantact ?
18:10:11 <geezusfreeek> Is there any way that type checking in GHC can become undecidable besides using UndecidableInstances? I am using EmptyDataDecls, ExistentialQuantification, MultiParamTypeClasses, and FunctionalDependencies and seem to be causing a stack overflow in GHC.
18:10:26 <geezusfreeek> FunctionalDependencies perhaps?
18:10:40 <BSP_> you might just have really deep type class contexts
18:10:46 <BSP_> have you tried increasing the size of the context stack?
18:11:02 <Cale> Possibly. It's hard to tell exactly how all the features might interact sometimes.
18:11:06 <gwern> gogonkt-``: ask #darcs
18:11:14 <geezusfreeek> no i haven't. i'll try that now
18:11:40 <mae> this is the most annoying message lol
18:11:41 <mae>     The last statement in a 'do' construct must be an expression
18:11:52 <monochrom> hehe
18:12:00 <gogonkt-``> :) Thz gwern
18:12:36 <BSP_> i have a category theory question: am i right in thinking that the functor F(X)=A*X does not have an initial algebra and similarly the function G(X)=1+X does not have a final coalgebra?
18:12:54 <BSP_> bah, s/function/functor
18:13:35 <monochrom> They are algebraic functors. Even non-recursive. Initial algebras and final co-algebras exist, just trivial.
18:13:45 <gwern> gogonkt-``: if you don't want to ask them, I'd download the darcs repos and figure out how the manual is generated; that or you could copy it and translate it and put it up on thehaskell wiki
18:14:38 <monochrom> For example, note F(0) \equiv 0, strong hint that 0 is an initial algebra for F.
18:15:05 <BSP_> hmm ok i see
18:15:19 <BSP_> thanks for the help
18:15:20 <geezusfreeek> increasing the stack size seems to have done nothing for me (besides making it take much longer to overflow, of course)
18:15:28 <geezusfreeek> i guess i will just have to tinker around a bit more
18:16:06 <monochrom> Oops, wrong terminology.  s/algebraic functors/polynomial functors/
18:18:06 <BSP_> monochrom: ok, i'm trying to work it out. could you humour me and exhibit the trivial initial algebra : F(0) -> 0?
18:18:19 <BSP_> surely a function that returns sth in the set 0 is undefined
18:18:24 <BSP_> maybe this is ok..
18:21:11 <monochrom> Such a function is ok if the domain A*0 fails to spit out an element as well. :)  (This is for the usual Set category.)
18:21:47 <BSP_> i was afraid it would be something like that.. this really is a very boring algebra :)
18:22:12 <BSP_> thanks again
18:22:34 <monochrom> More generally, I could probably take some time to show that A*0 \equiv 0 in all categories where 0 and * are supported.  Then the isomorphism will serve as the required unique morphism from A*0 to 0.
18:25:41 <geezusfreeek> i can't imagine that i should have been able to create a nonterminating loop, but somehow i did. i ended up fixing it by correcting a type error it apparently wasn't able to report, but i have no idea how it caused a loop
18:26:00 <fnord123> Heffalump: you know what. I think if you consider lists as incomplete types at compile time (as they are based on disjoint unions) there's probably something to be said about the computability of lists. Namely, if they can't be stack-located, then they can't be flexibly used in non-turing complete languages.
18:26:02 <geezusfreeek> oh well
18:26:04 <tphyahoo> can I have multiple modules in a single .hs file?
18:26:45 <Cale> tphyahoo: Though the language standard doesn't rule it out, the implementations don't support that.
18:26:55 <tphyahoo> ok
18:27:07 <BSP_> geezusfreeek: are you able to reduce it to a small example and post it on the GHC tracker?
18:27:49 <geezusfreeek> i would love to be able to, but it'd probably take me hours... i've been adding complexity to this code all day
18:28:31 <geezusfreeek> i'll commit the current state of my code to another branch and look at it again later
18:31:20 <cdsmithus> So what's "CAF" in GHC profiling reports?  It used to be insignificant, but suddenly my program is spending 50% of its time there.
18:31:37 <Botje> cdsmithus: "constant applicative form"
18:31:58 <Botje> a lambda with no arguments at the top level
18:32:14 <cdsmithus> Botje: Thanks.
18:32:25 <sfultong> is binaryderive still the way to automate composing data structures to serialized format?
18:32:54 <BMeph> Hm, that's confusing - I'd call it "filterMaybe," but it's actually called "mapMaybe." Does this annoy anyone?
18:33:12 <Botje> :t mapMaybe
18:33:13 <lambdabot> forall a b. (a -> Maybe b) -> [a] -> [b]
18:33:52 <Botje> map somehow makes more sense.
18:33:54 <sclv> it does a map
18:33:59 <clanehin> it maps and filters in one pass, filter is just as innacurate as map
18:34:02 <sclv> ?ty catMaybes
18:34:03 <lambdabot> forall a. [Maybe a] -> [a]
18:34:07 <sclv> that's yr filter.
18:34:12 <monochrom> I have just verified generally that 0 satisfies all the requirements of products between A and 0.  So 0 and A*0 are isomorphic.  So we have a morphism A*0 -> 0.
18:34:21 <geezusfreeek> mapFilterMaybe?
18:34:25 <BSP_> monochrom: interesting :)
18:34:44 <gwern> has anyone ever heard of a haskell tool called 'uncc'? I've gotten it to compile and it runs fine, but when I run it on a binary like it wants it just spits out some cryptic info
18:34:46 <hpaste>  gwern pasted "uncc output" at http://hpaste.org/6224
18:35:21 <BMeph> But... catMaybes is just mapMaybe id. :p
18:36:15 <Cale> Not quite
18:36:20 <Cale> er
18:36:28 <Cale> oh, perhaps yeah :)
18:36:41 <Cale> right, yes, it would be :)
18:36:54 <monochrom> And since both 0 and A*0 are initial objects, if you have any F-algebra A*X -> X, you can trivially and uniquely map 0 to X, A*0 to A*X, and have the nice unique commuting diagram required of A*0->0 as an initial algebra.
18:37:37 <BMeph> And, that's just what "filter id" does with a list of Bools. Thus my point. :)
18:37:38 <Cale> monochrom: What are you doing?
18:37:59 <fnord123> gwern: looks like it decompiles code. are those %af, etc registers?
18:38:17 <Cale> BMeph: well, mayMaybe is more general :)
18:38:23 <geezusfreeek> gwern: don't know anything about uncc, but apparently it doesn't recognize ELF executables
18:38:29 <Cale> map*
18:38:35 <BSP_> monochrom: thanks! now i'm trying to work out the final coalgebra for F(X)=X+1 with my extremely basic knowledge of the subject and getting nowhere.. care to hazard a guess? :)
18:39:21 <BMeph> Cale: It's more like what clanehin observed, it maps and filters in one pass.
18:39:32 <Cale> Right
18:39:38 <monochrom> Actually the final co-algebra of A*X is not so trivial.  It is the same as "data L a = Ctor a (L a)".  Infinite stream, and without the Nil case.
18:39:40 <BMeph> Cale: Ah, yes, map is more general. :)
18:39:52 <BSP_> monochrom: surely it can't be X=0 again since we couldn't have a homomorphism
18:39:59 <geezusfreeek> gwern: if the term ELF is unfamiliar to you, it's a linker format.
18:40:08 <BSP_> monochrom: ah, i knew that was true of A*X, but i'm wondering about A+X
18:40:25 <BSP_> monochrom: or actually 1+X, which should be similar
18:41:19 <Cale> data F a = A a | F (F a)
18:42:14 <Cale> The final coalgebra of 1+X ought to be "lazy Nat", I would think.
18:43:09 <BSP_> hmm i see where you're coming from
18:43:40 <BSP_> this is due to the fact that haskell types are in some sense a final coalgebra?
18:43:55 <Cale> I believe so. I'm not absolutely certain.
18:44:18 <Cale> When you take the greatest fixed point, like Haskell does, you get the final coalgebra of that functor.
18:44:27 <Cale> Maybe that's wrong, it's just an intuition.
18:45:05 <BSP_> it's very similar to my intuition anyway :)
18:45:35 <BSP_> i guess lowest fixed points can only contain finite values or something
18:46:03 <mulander> I'm stuck on an example from writing a scheme in 48h wikibook (section:Parsing). The chapter instructs to add a spaces function, the import of Parsec uses hiding (spaces). And now ghc tells during compile time that spaces are not in scope - is this an error in the wikibook?
18:46:09 <monochrom> least fixed point is when you assume strictness.
18:47:11 <mulander> argh, sorry my bad :)
18:47:15 <mulander> just a typo :)
18:47:22 <Cale> mulander: ah, okay
18:47:29 <BSP_> monochrom: really? where does that come from, mathematically?
18:47:48 <Cale> mulander: I was going to suggest either removing the 'hiding' clause, or to write a 'spaces' of your own.
18:48:12 <monochrom> Admittedly I have only seen it from lots of examples, haven't proved it in any general setting.
18:48:20 <mulander> Cale: the hiding of spaces from Parsec was intentional in the textbook, to implement our own.
18:48:39 <gwern> hm. so if uncc doesn't handle linux binaries, I wonder what binaries it does handle
18:48:58 <mulander> but because I used :: on the actual function definition instead of = the error msg was generated and it + hiding (spaces) got me confused :)
18:49:19 <Cale> ah
18:49:56 <yav> hi, does anyone know if there is a way to tell ghc to not use a specific RULE?
18:50:04 <BSP_> monochrom: tbh i'm not even sure how to go about putting laziness/strictness into the algebra/coalgebra setting so if you could provide any pointer i'd be grateful :)
18:54:03 <hpaste>  tphyahoo pasted "need help writing a neater type signature for Enum instance of tuples of (Bounded a, Enum a) => a ) " at http://hpaste.org/6225
18:55:03 <Cale> yav: I'm not sure there's much you can do, apart from compiling without optimisations.
18:55:08 <monochrom> Example.  F(X) = 1 + Int * X.  "data L = Nil | Cons Int L".  List of Ints.  Initial algebra and lfp are both the set of finite lists (think strict languages like SML).  Final co-algebra and gfp are both the set of finite and infinite lists (think non-strict Haskell).
18:57:17 <geezusfreeek> gwern: well, ELF isn't just for Linux... it's actually quite common on many architectures and systems
18:58:19 <geezusfreeek> i suspect that uncc really only supports simple binaries
18:58:26 <BSP_> monochrom: ahhh ok, so it pretty much corresponds to what i said about LFP only containing finite lists. to be able to exhibit an infinite list you need both the GFP >AND< laziness (so your construction function terminates!). makes sense!
18:59:05 <gwern> geezusfreeek: ok. where could I find a simple binary on my system to try it with?
18:59:36 <SamB> Cale: well, you can turn off just the RULES...
19:00:01 <cdsmithus> I'm not understanding this profiling at all.  There are parts of the call tree that don't correspond to the source code at all.  Is something broken with GHC profiling output?
19:00:22 <SamB> cdsmithus: like what?
19:00:27 <yav> cdsmithus: it is because of lazyness
19:00:29 <SamB> things with dollar signs in them?
19:00:43 <yav> what you are seeing is the order in which things were evaluated, not called
19:00:57 <cdsmithus> yav: Really?  That doesn't seem very useful.
19:01:06 <monochrom> The relation holds in imperative programming too.  lfp is total correctness (assuming strictness if you look closely).  gfp is partial correctness.
19:01:09 <yav> well, it's what we have :-)
19:01:20 <cdsmithus> SamB: No, functions I wrote; just called in the wrong order.
19:01:33 <SamB> order?
19:01:47 <cdsmithus> SamB: In the call tree, stuff is sitting in places where it doesn't belong.
19:01:50 <SamB> you mean like they were invoking the wrong other functions?
19:01:56 <cdsmithus> SamB: Exactly
19:02:17 <monochrom> They say "partial correctness" means maybe it doesn't terminate.  Note they assume strictness when they say that.  If you remove that assumption, you then have freedom throwing in laziness and have more termination too.
19:02:53 <cdsmithus> SamB: i.e., here I have gassocs invoking isIsomorphic.  Except if I look at the source code, gassocs doesn't invoke isIsomorphic.  It calls other functions that do; but those call paths ARE there, and are accounted differently.
19:03:17 <SamB> cdsmithus: interesting
19:03:19 <cdsmithus> yav: That's still not seeming consistent with what I'm seeing..
19:03:20 <BSP_> monochrom: right, yes. but you could i guess have a language that used LFPs but was still lazy, if you really wanted to.. but you couldn't do much with the power
19:03:27 <SamB> maybe it's getting inlined?
19:03:33 <cdsmithus> Maybe.
19:03:56 <yav> cdsmithus: if you are debugging, consider using "trace"
19:04:03 <monochrom> In fact I do exactly that.  Take a partial correctness formal method.  It doesn't say what terminates and what doesn't.  Now I can plug in full strictness, or full non-strictness, or anything in-between.  Termination varies.
19:04:31 <cdsmithus> SamB: So I'm trying to figure out what to do about the 67% of time that's apparently taken by this non-existent call to isIsomorphic.
19:04:41 <glguy> yav: hello
19:05:02 <cdsmithus> Actually 180 million non-existent calls
19:05:07 <yav> glguy: hi---still trying to track the problem with out of stack on bytestrings
19:05:11 <loupgaroublond> bos, serpentine.com is down
19:05:23 <glguy> yav: oh. the lots of little files model works now
19:05:31 <glguy> (no locking though)
19:05:47 <yav> glguy: cool
19:06:41 <yav> glguy: do you know if i can turn off just one rule in GHC?
19:06:58 <glguy> to pin down which rule is the bug?
19:07:00 <glguy> (no)
19:07:14 <BSP_> monochrom: interesting :-). thanks for all your help! now since i've now stayed up to 3am reading about category theory i really should get some sleep :-)
19:07:24 <yav> yeah, i "meld"ed the rules in both cases, and there is one that is different, so i want to turn it off
19:07:26 <SamB> yav: you should make a ticket about THAT, actually...
19:07:47 <yav> good point.  i just wanted to make sure that i am not missing something from the docs
19:08:00 <SamB> even THAT would be ticketworthy
19:16:01 <cdsmithus> So I'm back to having no clue how to interpret this profiling output...
19:17:43 <yav> cdsmithus: the fact that the function does not call isIsomorphic does not mean much.  It must be forcing a thunk, that is calling 'isIsomorphic'
19:19:16 <cdsmithus> yav: Are you sure about this?  Because most of the result looks like a normal call stack, just with bits duplicated and some levels missing.
19:19:42 <yav> yes.  if most of them look normal, that means that your functions are mostly strict.
19:20:52 <cdsmithus> yav: Okay, so what's your advice?  Just search down all occurrences and add them up, and ignore the fact that they are duplicated in odd places?
19:21:49 <gwern> '17:10:57 <dark> Pseudonym: uncc is my decompiler project (machine code to C).  So far I'm just focusing on static i386 ELF binaries, but I plan to adapt it to whatever I need to decompile in the future.'
19:22:07 <yav> It depends.  What was the problem that you were solving?
19:22:27 <yav> glguy: Fixed!  Pull from utf8-string
19:22:44 <SamB> I thought the call stack was supposed to look more like the lexical stack than that?
19:22:47 <SamB> er.
19:22:52 <SamB> for profiling purposes.
19:23:09 <gwern> maybe the problem is I'm on x86_64, not i386
19:23:20 <cdsmithus> yav: Just trying to speed up execution time.
19:23:37 <cdsmithus> SamB: I would hope so.  But yav apprently says no.
19:23:51 <Cale> Yeah, the 'call stack' generated by the profiler is not really the call stack.
19:24:12 <cdsmithus> Cale: By which you mean it should be in lexical or evaluation order?
19:24:17 <SamB> gwern: if your binaries are x86_64, then they probably won't be suitable, no ;-)
19:24:19 <yav> At the top of the profile it should point you to where it spent most of its time, try to optimize those functions...
19:24:23 <Cale> lexical
19:24:33 <monochrom> "The call stack that can be profiled is not the real Call Stack"? :)
19:24:38 <cdsmithus> Cale: Okay, that helps a lot; though it doesn't explain what I'm seeing./
19:24:48 <Cale> What are you seeing?
19:26:05 <Cale> I see your code on hpaste, but not the profiling output.
19:26:09 <glguy> yav: what was the bug?
19:26:16 <cdsmithus> Cale: A lot of things.  What I'm focusing on now is that I see, for example, isIsomorphic listed under gassocs; but the text of gassocs contains no reference to isIsomorphic.  It doess use another function that uses isIsomorphic, but that shows up too; so I have isIsomorphic duplicated with very different performance for each.
19:26:17 <Cale> By the way, there's a graph isomorphism tester in hgal.
19:27:07 <Cale> (though that library could use some work, it's less useful than it could be in general)
19:27:09 <cdsmithus> yav: Thanks.  Unfortunately, that just tells me isIsomorphic (which I would make little progress optimizing) is using 80% of the time.  I'm trying to reduce the number of calls to it, but that requires I know the call site.
19:27:19 <glguy> yav: tsuck -> stack?
19:27:34 <yav> glguy: yes :-)
19:27:34 <glguy> :-p
19:27:42 <cdsmithus> Cale: Okay, thanks.  I will look at that.  Though I think the isomorphism check I've got is decent by now.
19:27:47 <Cale> cdsmithus: Have you read chapter 6 of the GHC user's guide? ;)
19:27:53 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/profiling.html
19:27:56 <lambdabot> Title: Chapter 6. Profiling, http://tinyurl.com/kwh6c
19:27:58 <cdsmithus> Cale: Read, yes.  Understood, not really.
19:28:03 <Cale> okay
19:28:30 <Cale> So you probably, at this point, want to start adding cost centre annotations to isIsomorphic, in order to pin down where the resource usage is.
19:29:01 <Cale> Can I see the current profiling output?
19:29:14 <yav> cdsmitus: if you don't want to optimizie isIso, try looking at who is forcing its evaluation.
19:29:30 <Cale> oh
19:29:32 <Cale> I see
19:29:35 <cdsmithus> Cale: Sure, I'll paste it.  (But it was with -cas-all; hope that doesn't screw things up; that was my last wild effort to tweak things)
19:29:40 <Cale> You want to know where isIsomorphic is called?
19:29:56 <Cale> That's okay
19:30:11 <Cale> -caf-all just adds cost centres on all cafs
19:30:37 <Cale> (that is, things which are definitionally constants)
19:30:52 <hpaste>  cdsmithus pasted "prof output" at http://hpaste.org/6226
19:31:20 <cdsmithus> That didn't work
19:31:38 <Cale> Okay, let's look at gassocs
19:31:58 <Cale> Since gassocs called isIsomorphic 85867798 times.
19:32:18 <cdsmithus> Right, except it didn't.  Hold on.
19:32:39 <hpaste>  cdsmithus annotated "prof output" with "related code" at http://hpaste.org/6226#a1
19:33:17 <Cale> You're compiling with optimisations?
19:33:26 <Cale> I wonder if there's some inlining happening.
19:34:21 <Cale> If so, turn optimisations off and try getting some profiling info from that.
19:34:22 <cdsmithus> Cale: Yeah; but if I turn off optimizations, it just overflows the heap at any heap size.  I'll try again, though.
19:34:38 <Cale> It doesn't matter, just don't let it run to completion.
19:35:02 <Cale> That is, let it run for a bit, and then Ctrl-C and, you'll still generate profiling output.
19:35:12 <cdsmithus> Since I'm rebuilding, take out -caf-all?
19:35:32 <Cale> -auto-all should do
19:35:51 <yav> cdsmithus: profiling without optimizations may not be such a good idea---GHC does a lot
19:36:08 <Cale> yav: Except it makes it impossible to read the profiling output.
19:36:15 <yav> no it does not
19:36:23 <yav> but i guess thats subjective :-)
19:36:29 <Cale> Not always.
19:36:34 <Cale> But in this case.
19:36:46 <yav> i would look at replacing intersectBy and isonub
19:37:10 <yav> both are probably quadratic operations
19:37:16 <cdsmithus> Cale: Hmm... taking a while just to get to the code I care about.  (It has to generate the graphs first.)  I guess I should let it run at least that long
19:37:38 <Cale> What does isonub do?
19:37:49 <cdsmithus> Cale: Takes a list of graphs, and removes isomorphic copies.
19:37:54 <Cale> cdsmithus: How?
19:38:08 <Cale> cdsmithus: I'm hoping that you're not just pairwise testing them?
19:38:16 <cdsmithus> Cale: First, sorts them by the characteristic polynomial of their adjacency matrix, then tests pairwise within each group
19:38:22 <Cale> oh, okay
19:38:34 <Cale> You could do better though.
19:38:46 <cdsmithus> Cale: How?
19:38:55 <yav> cdsmithus: got to go...  good luck!
19:39:00 <cdsmithus> yav: thanks!
19:39:33 <Cale> There are algorithms for canonicalising graphs.
19:40:14 <Cale> (so you could just test for isomorphism by equality after that)
19:40:20 <hpaste>  cdsmithus annotated "prof output" with "new profiling" at http://hpaste.org/6226#a2
19:40:51 <Cale> okay, so this gives a better idea of what's happening perhaps
19:40:51 <cdsmithus> Cale: Do you have any pointers?  I looked around a lot, but this is the best I found.
19:41:03 <Cale> Well, hgal :)
19:41:04 <cdsmithus> Cale: Yes, it does do that, definitely.  Thank you.
19:41:33 <Cale> idents is probably getting inlined or something.
19:41:43 <cdsmithus> @where hgal
19:41:43 <lambdabot> I know nothing about hgal.
19:41:51 <Cale> It's on hackage
19:42:06 <cdsmithus> Cale: Okay, thanks so much for your help.
19:42:36 <Cale> I'm not sure how readable the code is... Last time I looked at it, it was a bit of a horror.
19:43:06 <Cale> It would be *really* nice if someone were to get the relevant paper and work out a functional version :)
19:43:23 <Cale> HGAL is effectively an implementation of nauty.
19:43:37 <Cale> http://cs.anu.edu.au/~bdm/nauty/
19:43:38 <lambdabot> Title: The nauty page
19:43:46 <cdsmithus> Cale: Okay.  I was looking at nauty.  Couldn't figure it out.  But maybe I could if I needed to.
19:44:21 <Cale> http://cs.anu.edu.au/~bdm/papers/pgi.pdf
19:44:52 <glguy> :-p
19:44:55 <glguy> whoops
19:45:30 <cdsmithus> Cale: So the canonical labeling is that canonicalization you were talking about, after which testing by equality is possible?
19:45:40 <Cale> yeah
19:46:06 <cdsmithus> Cale: That sounds great.  Do you know if hgal works well with parallel edges and loops?
19:46:38 <Cale> I don't know...
19:46:48 <Cale> In the paper, he only talks about simple graphs.
19:46:49 <cdsmithus> Cale: Okay, I'll look into it then
19:47:43 <Cale> What are you working on?
19:48:18 <cdsmithus> Cale: The big picture is I'm testing a huge set of hypotheses about the relationship between directed graphs and their C* and Leavitt path algebras.
19:48:38 <cdsmithus> Cale: Math dept research stuff
19:48:55 <Cale> Cool, I wasn't aware that digraphs had associated C* algebras :)
19:49:45 <cdsmithus> Cale: Aye, they do.  And if the algebra is separable, purely infinite, simple, and hereditary, there are cool interplays between them.
19:50:16 <Cale> Oh, is this related to quiver algebras? I briefly heard something about those.
19:50:33 <cdsmithus> Cale: If it is, I don't know.  I've never heard of quiver algebras
19:50:41 <Cale> http://en.wikipedia.org/wiki/Quiver_(mathematics)
19:51:01 <cdsmithus> I'm sounding smarter than I really am; the really smart people in this are not me.  I'm just their code monkey.
19:51:05 <Cale> Multiplication is by concatenation of paths?
19:51:14 <cdsmithus> Cale: Yes, that is true
19:51:20 <Cale> ah, okay, it's the same thing :)
19:52:08 <Cale> The construction appeals to me, but I don't know too much about it.
19:52:08 <cdsmithus> Cale: That's very interesting.  Thanks for the link.
19:53:36 <cdsmithus> Actually, that doesn't look like the same thing.  But it's similar in a lot of ways.
20:01:59 <telexicon> is there something i need to add to vim to have it indent properly?
20:03:41 <dmwit> :set ai
20:04:23 <telexicon> that doesnt do proper indenting in haskell though
20:04:52 <dmwit> It's the closest I've ever gotten.
20:05:56 <telexicon> then i still have to move a bunch of stuff around
20:06:11 <dmwit> eh?
20:06:22 <telexicon> to make things line up properly
20:06:34 <dmwit> You shouldn't have to move much.
20:06:59 <mrd> haskell is whitespace sensitive, so there's not really any autoindenting mode
20:07:09 <mrd> I just set sts=2,sw=2,ai
20:07:26 <mrd> also, expandtab
20:07:34 <Cale> I just set expandtab and smarttab
20:07:52 <Cale> and use tab to get the cursor roughly where I want it, and then spaces to finish
20:08:40 <mrd> ah smarttab looks good too
20:09:59 <telexicon> isnt there a script or something that can look at the do or let on the previous line and line things up with the next character after that?
20:16:31 <JohnMeacham> I was able to make a pretty nice little garbage collector on short notice. In fact, I am finding it useful for just writing C programs in general. I think I will package it separately from jhc.
20:17:45 <JohnMeacham> only 2k of code added to the final executable for the GC. not bad.
20:18:12 <JohnMeacham> I do require libJudy to be installed though. I wonder if that is too burdensome? it should be a standard library anyway nowadays. it is just so useful.
20:26:13 <glguy> can I use some combinator of foreign import/export  to get a statically allocated FunPtr to pass out to a c library?
20:26:36 <glguy> or do I always need to write a "wrapper"
20:26:39 <glguy> and allocate memory
20:28:28 <dons> hmm. i think you can get away without htat.
20:28:30 <dons> let's see..
20:28:50 <glguy> (you can bill for this question ;)
20:29:45 <glguy> I think that the allocation should only be necessary if you are trying to preserve a closure
20:29:54 <glguy> but what I'm exporting has no free vars
20:30:06 <dons> data FunPtr a = FunPtr Addr#
20:30:27 <dons> that Addr# could come from a Ptr, which could come from a foreign import.
20:30:35 <dons> if its a Haskell function hmm, harder
20:31:10 <dons> check GHC.Ptr's docs. otherwise, not sure.
20:31:20 <glguy> kk
20:44:34 <BMeph> Does anyone remember talking earlier about JetBrains' MPS project?
20:45:56 <glguy> BMeph: that was skew
20:46:41 <BMeph> glguy: Ah, thanks, I thought someone said something about it, but I couldn't recall.
20:47:58 <BMeph> It looks like those guys could have something there, if only they weren't dedicated to Java programming. Interesting idea, but a butt-ugly, clunky-looking interface. :|
20:49:39 <BMeph> It also reminds me of that "Subtext" think that came up a couple months ago.
20:52:48 <wagle_home> @seen Cale
20:52:48 <lambdabot> Cale is in #haskell-overflow, #haskell and #ghc. I last heard Cale speak 44m 56s ago.
20:52:54 <Cale> hi
20:53:24 <wagle_home> hey Cale, what happened to fold_diagrams?
20:53:40 <Cale> nothing?
20:53:44 <Cale> http://cale.yi.org/index.php/Fold_Diagrams
20:53:45 <lambdabot> Title: Fold Diagrams - CaleWiki
20:54:01 <wagle_home> http://cale.yi.org/index.php/Fold_Diagrams
20:54:02 <lambdabot> Title: Fold Diagrams - CaleWiki
20:54:11 <Cale> I hope that's still accessible from the outside world...
20:54:14 <wagle_home> weird..  doesnt work
20:54:33 <wagle_home> ok. now it works
21:01:55 <sclv> ok, cabal/ghc-pkg question. if I have something I want to package that uses a nonstandard lib that isn't packaged, but really should be (i.e. Control.Monad.Maybe -- ffs I should just make a proposal to add it to the mtl already anyway) and i include Control/Monad/Maybe.hs in my source tree, assuming that its only used internally to the lib and not reexported, that shouldn't cause any clashes, right?
21:02:11 <sclv> (i.e. if its set to hidden)
21:09:34 <gwern> sclv: if Control/Monad/Maybe.hs and Control.Monad.Maybe both existed on your system, and the compiling instance of GHC could see both (suppose your cabal file has build-depends: monad-maybe), why would it *not* be confused by the duplicate definitions?
21:10:30 <sclv> because ghc always prefers source trees to installed libs?
21:11:05 <sclv> erm, speaking of which, oh great master of cabalization, do you happen to know if there's a monad-maybe on hackage?
21:11:20 <gwern> I don't think it does. I've run into cases where I had Util installed from some other package, and a local Util.hs, and iirc, there was conflicts
21:11:31 <gwern> what would a monad-maybe be anyway?
21:12:15 <gwern> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/MaybeT-0.1.1 <-- this maybe
21:12:18 <lambdabot> http://tinyurl.com/35knx4
21:12:18 <sclv> fail = lift Nothing. return = lift . Just
21:12:22 <sclv> sorta
21:12:24 <gwern> at least, it exports a Control.Monad.Maybe
21:13:08 <BMeph> Maybe is already a monad, so what would a "monad maybe" be? :)
21:13:30 <BMeph> Er, a "monad-maybe"? :)
21:13:44 <sclv> monadT maybe, that is.
21:13:46 <gwern> BMeph: it maybe a monad?
21:14:16 <wagle_home> Either a (Maybe a)
21:14:25 <BMeph> gwern: Heh-heh. ;)
21:14:35 <gwern> althought if it isn't a monad, what? arrow, applicative, comonad, something else I don't understand probably
21:15:16 <BMeph> sclv: Yeah, I think you might be looking at MaybeT, like gwern said.
21:15:56 <sclv> BMemph: that's what I want. I'm using the one from the wiki currently. sigh. this one doesn't provide mplus because mplus is ambiguous.  more evidence that mplus is broken.
21:16:11 <sclv> because how much *more* broken is it to require a call to fail as opposed to mzero.
21:18:08 <sclv> this is a case where they should just give it an alternative instance and be done with it.
21:19:14 <dolio> That's weak. It should define 'instance MonadPlus (MaybeT m)'.
21:21:25 <dolio> That same rationale would lead to there being no State/Reader/Writer/Cont instances for the transformers, because it might be transforming a monad of the same type.
21:22:42 <sclv> its very silly yes. and worse yet, using the monad and defining your own instance would probably lead to more issues than just including yr. own in the source tree..
21:29:35 <sclv> the comments are so self-depreciating too! gawd. "  -- I hope this is correct.  At a minimum, it typechecks." haha I totally identify, but way to instill confidence.
21:31:16 <Cale> dolio: Those instances are occasionally really annoying.
21:32:02 <Cale> (and they really do hurt beginners' understanding of how monad transformers work)
21:32:07 <Cale> But yeah.
21:32:27 <dolio> Such is our plight in life. :)
21:32:29 <sclv> Cale: but without instance scoping, the possibility of overlapping orphan instances is just so painful.
21:34:49 <Cale> There's at least one lifting instance which seems to work the wrong way.
21:35:09 <Cale> ContT over State shouldn't be the same as StateT over Cont, but they are.
21:35:13 <sclv> in the wiki maybe or the hackage one?
21:35:18 <Cale> In the mtl.
21:35:26 <sclv> ah -- right.
21:35:36 <dolio> I wasn't suggesting a lifting instance. I was suggesting the non-lifting MonadPlus.
21:35:47 <Cale> Oh, where?
21:35:49 <sclv> have you made a proposal to libraries@?
21:35:52 <dolio> MaybeT.
21:36:00 <Cale> sclv: Nope.
21:36:30 <dolio> It leaves out MonadPlus with the rationale that it's ambiguous between the MaybeT m monoid and the lifted monoid.
21:36:38 <Cale> It's actually "correct" in that the resulting instances are valid. It's just unexpected, given the behaviour of, say, StateT over List.
21:37:01 <dolio> But a similar argument would avoid defining 'instance MonadState s (StateT s m)' because it's ambiguous with the lifted instance.
21:37:13 <sclv> Cale -- might seem an easier battle to win that, e.g., removing fail entirely or switching the associativity of ($)
21:37:15 <Cale> Oh, yeah, that's a bit funny.
21:37:58 <Cale> Another thing which is really broken is ListT.
21:38:22 <Cale> It's funny how the MTL hasn't changed at all since it was added to the libraries.
21:38:26 <sclv> right -- as i recall, someone even wrote a correct one? no idea why that hasn't been fixed too.
21:39:09 <Cale> Well, okay, there was that splitting of the classes into separate modules for whatever reason.
21:39:32 <Cale> and the Lazy/Strict distinction
21:40:41 <dolio> The correct one doesn't actually use [].
21:41:00 <Cale> Yeah. The *real* correct one is LogicT.
21:41:01 <dolio> It's not in mtl, either, is it? It's part of base.
21:41:01 <glguy> Cale: monadLib doesn't make that mistake
21:41:07 <sclv> the other really silly thing is that adding CaughtMonadIO for gcatch seems to have stalled out...
21:41:12 <glguy> Cale: and it's run functions are the right way around!
21:42:14 <Cale> I see that it still gets the pairs the wrong way though ;)
21:44:10 <glguy> but it's attention to strictness/laziness and correct instances help make up for that oversight :-p
21:44:20 <Cale> :)
21:44:48 <glguy> mtl's string based error monad is a pain too
21:45:00 <Cale> Curious that ChoiceT looks very much like LogicT, and yet the fair choice operations aren't implemented
21:45:15 <glguy> what are those?
21:45:56 <Cale> They let you combine computations which produce an infinite number of options.
21:46:13 <glguy> diagonal traversal?
21:46:20 <Cale> Basically, yeah.
21:46:29 <Cale> Well, a sort of interleaving.
21:46:34 <gwern> Cale: they implement dovetailing?
21:46:35 <glguy> I'll bring it up
21:47:01 <dolio> Given that type for runChoiceT, you could implement them all.
21:47:14 <Cale> Probably you could just copy the implementations of most of it from the LogicT code. There's a very simple primitive which gives you everything, called msplit.
21:47:17 <dolio> I think, at least.
21:47:58 <Cale> msplit :: m a -> m (Maybe (a, m a))
21:49:47 <dolio> Aww, it doesn't have the rank-2 callCC, either.
21:54:29 <hpaste>  morrow pasted "graphs" at http://hpaste.org/6228
21:55:42 <hpaste>  morrow annotated "graphs" with "rest" at http://hpaste.org/6228#a1
22:06:35 <hpaste>  morrow annotated "graphs" with "forgot to put `edges' in the export list" at http://hpaste.org/6228#a2
22:32:44 <hpaste>  morrow annotated "Can you improve this code? (graph isomorphism test)" with "interesting paper => alg" at http://hpaste.org/6218#a1
22:56:07 <JohnMeacham> I just wrote a scheme interpreter that uses the jhc runtime in order to test it...
22:56:40 <JohnMeacham> seems a little like overkill... but at least I can benchmark my garbage collector independently of the compiler.
23:00:27 <gwern> JohnMeacham: while you're up, you know what a make failure erroring as 'sed -i FrontEnd/HsParser.hs -e 's/^{-# OPTIONS/{-# OPTIONS_GHC -w/'
23:00:29 <gwern>  sed: -e expression #1, char 1: unknown command: `F'
23:00:32 <gwern> means?
23:03:24 <dmwit> wow
23:06:25 <gwern> @where maak
23:06:25 <lambdabot> I know nothing about maak.
23:06:57 <gwern> @where+ http://www.cs.uu.nl/wiki/Trace/MaakBuildSystem
23:06:57 <lambdabot> Done.
23:07:25 <gwern> the ironic part of the aforegoing is that I took the url from a @where maak query in some old #haskell logs
23:07:36 <gwern> @where+ maak http://www.cs.uu.nl/wiki/Trace/MaakBuildSystem
23:07:36 <lambdabot> It is forever etched in my memory.
23:07:39 <gwern> @where maak
23:07:39 <lambdabot> http://www.cs.uu.nl/wiki/Trace/MaakBuildSystem
23:07:47 <solrize_> hey does anyone know the general method for writing a haskell program and releasing it for windows?
23:07:52 <dmwit> ?where http
23:07:52 <lambdabot> http://www.haskell.org/http/
23:08:05 <gwern> solrize_: cabal, I would expect
23:08:06 <dons> solrize_: by using cabal , the build system
23:08:15 <solrize_> thanx i'll check that
23:08:15 <dmwit> ?where http://www.cs.uu.nl/wiki/Trace/MaakBuildSystem
23:09:03 <solrize_> http://haskell.org/haskellwiki/Cabal/How_to_install_a_Cabal_package
23:09:08 <lambdabot> Title: Cabal/How to install a Cabal package - HaskellWiki, http://tinyurl.com/39kra4
23:09:16 <solrize_> arggh!!  tar xfz  blecch tar.gz, runghc configure?
23:09:29 <solrize_> I want to be able to release something like a .msi with a one-click installer
23:09:42 <gwern> @hoogle Exception
23:09:42 <lambdabot> Control.Exception :: module
23:09:42 <lambdabot> Control.Exception.Exception :: data Exception
23:09:42 <lambdabot> Control.Exception.ArithException :: ArithException -> Exception
23:10:05 <gwern> @hoogle unsafePerformIO
23:10:05 <lambdabot> Foreign.unsafePerformIO :: IO a -> a
23:10:05 <lambdabot> System.IO.Unsafe.unsafePerformIO :: IO a -> a
23:10:21 <gwern> solrize_: in that case, look up the gtk2hs project, I vaguely recollect them having such a installer
23:10:58 <gwern> @hoogle Files
23:10:58 <lambdabot> Distribution.PackageDescription.dataFiles :: PackageDescription -> [FilePath]
23:10:58 <lambdabot> Distribution.PackageDescription.extraSrcFiles :: PackageDescription -> [FilePath]
23:10:58 <lambdabot> Distribution.PackageDescription.extraTmpFiles :: PackageDescription -> [FilePath]
23:11:00 <solrize_> hmm, ok, i'll look for that
23:11:10 <gwern> @hoogle Posix.Files
23:11:11 <lambdabot> No matches, try a more general search
23:11:13 <solrize_> it doesn't have to be fancy or graphical, just very simple for non-technical users to install easily
23:11:24 <solrize_> something like python distutils would be enough
23:11:39 <solrize_> maybe i could wrap something like innosetup around this cabal stuff
23:11:42 <gwern> @hoogle Pretty
23:11:42 <lambdabot> No matches found
23:12:39 <gwern> @hoogle nest
23:12:39 <lambdabot> Language.Haskell.TH.PprLib.nest :: Int -> Doc -> Doc
23:12:39 <lambdabot> Text.ParserCombinators.Parsec.Token.nestedComments :: LanguageDef st -> Bool
23:12:39 <lambdabot> Text.ParserCombinators.Parsec.Language.nestedComments :: LanguageDef st -> Bool
23:13:44 <dons> solrize_: to install from source?
23:15:56 <gwern> ah forget it. time to call it a night
23:16:21 <solrize_> dons, i'm ok with distributing source as a tarball but i want to make a really simple executable installer
23:16:31 <solrize_> it's possible that the whole app could be a single .exe
23:17:25 <solrize_> the app is the tcp proxy that i pasted here a few nights ago, it's actually supposed to be an irc proxy
23:17:41 <dons> solrize_: right, but you intend for the users to build source?
23:17:46 <dons> or to install a pre-built binary?
23:18:12 <solrize_> prebuilt binary for total simplicity.  source available if they want it
23:18:40 <solrize_> the users will be folks who have on idea what a compiler is
23:23:46 <dons> so cabal for the source, and the binary, just whatever installer people use
23:24:06 <dons> there's a special installer ghc uses -- that's reusable, but i've not tried it.
23:24:13 <solrize_> yeah, i'm fairly clueless about windows and was wondering if there was a standard installer for haskell
23:24:33 <solrize_> python has distutils and then you can wrap that with innosetup (sort of like install shield, but free)
23:25:33 <solrize_> and i guess it's possible to use innosetup with a ghc compiled binary
23:25:50 <taruti> Using nsi with cabal works.
23:25:50 <solrize_> so yeah i guess this sounds reasonable
23:25:53 <solrize_> nsi?
23:27:00 <taruti> http://nsis.sourceforge.net/Main_Page
23:27:02 <lambdabot> Title: Main Page - NSIS
23:28:57 <solrize_> thanks that looks cool
23:29:55 <solrize_> oh man you need windows dev tools to use it?
23:29:56 <dons> good to know, taruti
23:29:57 <solrize_> hmm
23:30:28 <taruti> solrize_: I think I used that on linux.
23:30:35 <taruti> to create windows installers
23:30:46 <solrize_> interesting
23:30:54 <glguy> "windows dev tools"
23:31:00 <robreim> Quick Q: Can someone remind me of the function to make the current haskell sleep in haskell?
23:31:05 <glguy> threadDelay
23:31:07 <solrize_> i see, some parts of it are written in c++ so you need visual studio to compile it under windows
23:31:09 <taruti> at least hsql seems to use it.
23:31:09 <robreim> Thanks
23:31:10 <Nafai> Yeah, you can use nsis on Linux
23:31:30 <taruti> spoop: apt-get install nsis
23:31:35 <taruti> *solrize
23:31:39 <solrize_> cool
23:32:04 <solrize_> that's awesome if i can make a windows installer under linux without actually touching a windows box
23:34:56 <taruti> I think I have some example if you are interested. (although it may be a little bitrotted)
23:36:14 <solrize_> sure that would be great
23:40:23 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/6229
23:41:21 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/6230
23:41:49 <taruti> solrize_: the first one is how to generate nsi:s for libraries and the second one is a shared cabal.nsh
23:42:15 <solrize_> great thanks
23:44:53 <solrize_> that 6230 is cabal configuration and not an nsi script?
23:46:17 <taruti> solrize_: 6230 is a file called "cabal.nsh" which is shared nsi script for various cabal packages. so the invidual package nsi scripts can be minimal (typically 4 lines) and readable.
23:46:29 <solrize_> oh i see
23:46:38 <solrize_> thanks, this is cool
23:53:24 <glguy> ?hoogle sync
23:53:24 <lambdabot> GHC.Conc.asyncRead :: Int -> Int -> Int -> Ptr a -> IO (Int, Int)
23:53:24 <lambdabot> GHC.Conc.asyncWrite :: Int -> Int -> Int -> Ptr a -> IO (Int, Int)
23:53:24 <lambdabot> GHC.Conc.asyncDoProc :: FunPtr (Ptr a -> IO Int) -> Ptr a -> IO Int
23:53:28 <glguy> ?hoogle+
23:53:28 <lambdabot> GHC.Conc.asyncReadBA :: Int -> Int -> Int -> Int -> MutableByteArray# RealWorld -> IO (Int, Int)
23:53:28 <lambdabot> GHC.Conc.asyncWriteBA :: Int -> Int -> Int -> Int -> MutableByteArray# RealWorld -> IO (Int, Int)
23:53:28 <lambdabot> Control.Exception.AsyncException :: AsyncException -> Exception
