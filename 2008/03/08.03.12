00:00:13 <adu> > let ls@@(n,y) = x++[y]++z where (x,_:z) = splitAt n ls in "Hello"@@(4, 'a')
00:00:13 <lambdabot>  "Hella"
00:00:30 <adu> thats what I was looking for :)
00:00:59 <faxathisia> l @@ (i,k) = (l,i) >- const k
00:01:29 <adu> o did you arelady do that?
00:01:46 <adu> whats (>-)?
00:01:49 <faxathisia> no I think your definition is better than mine
00:01:58 <BMeph> > mapX gcd (+3) [20,19..1]
00:01:59 <lambdabot>   add an instance declaration for (Num [a])
00:02:05 <faxathisia> but taking a function instead of an element is more general
00:02:13 <BMeph> bah. :)
00:02:17 <adu> faxathisia: right the whole cps thing
00:02:29 <lekro> > mapX id id [10,9..1]
00:02:30 <lambdabot>      Occurs check: cannot construct the infinite type: a1 = a1 -> b
00:02:30 <lambdabot>       Exp...
00:02:43 <BMeph> Well, that's something to poke around with later - good night, all. :)
00:03:27 <lekro> :t mapX
00:03:30 <lambdabot> forall a a1 b. (a -> a1 -> b) -> ([a] -> [a1]) -> [a] -> [b]
00:04:06 <dons> mapX eh?
00:04:21 <dons> Cale, i heard a rumour you'd redefined the Prelude for the bot?
00:04:31 <seafood_> Newbie question here. How do you make a shell script using Haskell? #!/usr/local/bin/runhaskell ???
00:04:32 <dons> in true Haskell 1.4 style?
00:04:33 <Cale> dons: Just (++) and (.)
00:04:36 <seafood_> I can't quite work it out
00:04:41 <lekro> > mapX (,) id [1..10]
00:04:42 <lambdabot>  [(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10)]
00:04:45 <dons> seafood_: #!/usr/bin/env runhaskell
00:04:47 <dons> is good
00:04:49 <dons> hey, btw
00:05:27 <Cale> > sortBy (comparing length ++ compare) (words "this is a test of the emergency broadcasting system")
00:05:28 <lambdabot>  ["a","is","of","the","test","this","system","emergency","broadcasting"]
00:05:56 <dons> ++ !? (.) ??
00:06:02 <dons> is this going to confuse newbies terribly?
00:06:08 <Cale> :t (++)
00:06:09 <lambdabot> forall m. (Monoid m) => m -> m -> m
00:06:10 <Cale> :t (.)
00:06:11 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
00:06:13 <dons> oh my
00:06:20 <solrize> comparing length ++ compare            ?????
00:06:26 <dons> see.
00:06:30 <Cale> ++ is the general monoid operation now
00:06:31 <solrize> you can concatenate functions?
00:06:31 <seafood_> dons: Do you just write code after that?
00:06:35 <Cale> yep :)
00:06:39 <dons> it needs a different name though, Cale, since you're confusing newbies now
00:06:44 <Cale> @instances Monoid
00:06:44 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
00:06:45 <dons> seafood_: yeah
00:06:46 <solrize> > :t (++)
00:06:46 <lambdabot>   parse error on input `:'
00:06:51 <solrize> :t (++)
00:06:52 <lambdabot> forall m. (Monoid m) => m -> m -> m
00:06:53 <Cale> dons: Nah, we just have to change the prelude.
00:07:02 <Cale> :)
00:07:03 <seafood_> dons: I'm getting some nonsense about 'Could not find module `/Users/sseefried/local/bin/scripts/sum''
00:07:17 <faxathisia> hehe
00:07:18 <dons> i don't like the idea of confusing people. its not a haskell interpreter then
00:07:20 <solrize> that's a lambdabot thing?
00:07:29 <dons> Cale, how about introducing it with a different character?
00:07:50 <Cale> dons: I've thought about that, but really, it's just a couple small generalisations.
00:08:06 <Cale> Code which works in Haskell will still work.
00:08:07 <dons> but it'll break anyone who tries to paste the code into their terminals
00:08:20 <faxathisia> dons: That happens anyway
00:08:31 <faxathisia> You have to add lots of modules
00:08:33 <Cale> This is true, but there's lots of stuff which is in libraries and even in libraries only in lambdabot.
00:08:41 <faxathisia> :t (.) :: (a -> b) -> (c -> b) -> (a -> c)
00:08:42 <lambdabot>     Couldn't match expected type `a' against inferred type `b'
00:08:42 <lambdabot>       `a' is a rigid type variable bound by
00:08:42 <lambdabot>           the polymorphic type `forall a b c. (a -> b) -> (c -> b) -> a -> c'
00:09:00 <Cale> :t (.) :: (a -> b) -> (t -> a) -> (t -> b)
00:09:01 <lambdabot> forall a b t. (a -> b) -> (t -> a) -> t -> b
00:09:07 <dons> i think its silly to change the names.
00:09:16 <dons> since that's one new thing we'll have to explain now
00:09:34 <Cale> We won't have to explain it if the Prelude changes ;)
00:11:23 <dons> the first newbie who gets confused should be the first moment you revert this, imo.
00:11:40 <faxathisia> people are confused in #haskell 24/7..
00:11:44 <dons> did you change ($) too ? ...
00:11:50 <Cale> No, not yet.
00:12:03 <dons> i've got my eye on you, Cale Gibbard
00:12:10 <Cale> hehe
00:12:34 <Cale> All the changes I've made so far are pretty much backwards compatible.
00:12:59 <Cale> Just that you get new code which works instead of being a type error.
00:13:23 <dons> and we'll need to clarify when someone pulls a non-haskell tricky
00:14:13 <Cale> solrize: (f ++ g) x = f x ++ g x, and ++ on Ordering values basically picks the left value, unless it's EQ, in which case it picks the right one.
00:14:16 <Cale> That is,
00:14:17 <faxathisia> I think you should just update @src
00:14:23 <Cale> LT ++ y = y
00:14:26 <faxathisia> so it's consistent
00:14:29 <Cale> GT ++ y = y
00:14:32 <Cale> Er
00:14:39 <Cale> no
00:14:42 <Cale> EQ ++ y = y
00:14:46 <Cale> x ++ y = x
00:14:51 <solrize> this is getting more and more like python duck typing.... do we really want that? :)
00:15:02 <faxathisia> solrize: What is? Typeclasses?
00:15:03 <lekro> > mzero ++ mzero
00:15:04 <lambdabot>   add an instance declaration for (Monoid (m a))
00:15:05 <Cale> It's just a typeclass.
00:15:11 <faxathisia> I don't agree
00:15:12 <lekro> this worked before, no?
00:15:18 <lekro> ;)
00:15:26 <solrize> typeclasses gone wild
00:15:28 <Cale> class Monoid where
00:15:37 <Cale> class Monoid a where
00:15:41 <Cale>   mzero :: a
00:15:46 <Cale> er
00:15:46 <lekro> no, I don't want to criticize this change.
00:15:50 <Cale> d'oh
00:15:57 <Cale>   mempty :: a
00:16:00 <wli> mempty
00:16:03 <Cale>   mappend :: a -> a -> a
00:16:04 <Cale> right
00:16:15 <Cale> So I've renamed mempty to ++ and mappend to zero
00:16:16 <wli> There's a monoid, but no semigroup, which screws up nonempty strings badly.
00:16:24 <faxathisia> o_o
00:16:27 <Cale> damn, I must be freaking tired
00:16:34 <Cale> So I've renamed mempty to zero and mappend to ++
00:16:39 <Cale> It is 3am
00:16:49 <wli> Cale: Nah. You're just wanting 1.4 back.
00:16:51 <faxathisia> :t ([] ++)
00:16:52 <lambdabot> forall a. [a] -> [a]
00:17:06 <Cale> wli: heh, that doesn't explain my bout of dyslexia :)
00:17:20 <wli> Oh, but it does. ;)
00:17:22 <Cale> heh
00:17:33 <adu> Cale: really? how did you do that? I've always thought Monoid and MonadZero were similar...
00:17:53 <Cale> adu: Monoid and MonadPlus are similar
00:18:06 * wli wants scoped instances bad.
00:18:10 <adu> right! MonadPlus.... agh, they're all the same...
00:18:25 <faxathisia> scoped instances... huh?
00:18:40 <Cale> wli: Like in the paper by Kahl?
00:19:08 <wli> Cale: No idea about Kahl's paper. It's an obvious concept, albeit one whose implementation is far from obvious.
00:21:04 <solrize> So, things I hate about Haskell:
00:21:04 <solrize> Let's start with the obvious. Monad tutorials. No, not monads. Specifically the tutorials. They're endless, overblown and dear god are they tedious. Further, I've never seen any convincing evidence that they actually help. Read the class definition, write some code, get over the scary name.
00:21:30 <wli> The reason for wanting scoped instances so badly is to have locally-scoped instances for instance MonadPlus m => Monoid m
00:21:44 <wli> And the reverse, depending.
00:21:52 <faxathisia> this is pasted from http://shreevatsa.wordpress.com/
00:22:38 <wli> solrize: springschool95.ps is what did it for me, and it's by no means a "monad tutorial," though YAHT's monad transformer chapter helped quite a bit, too.
00:23:17 <solrize> hmm, i haven't seen springschool95.ps.  i've looked at YAHT though, it's pretty good.
00:23:28 <solrize> i just thought that quote was funny because it's exactly true
00:23:38 <adu> YEY i've implemented almost all of the Bits typeclass
00:23:44 <wli> solrize: springschool95.ps is an old school Mark Jones paper.
00:23:45 <solrize> that stuff about robots with radioactive waste in space capsules set me back months i'm sure
00:23:51 <Cale> heh
00:24:02 <Cale> I'd like to think that my tutorials are actually useful.
00:24:07 <solrize> wli the one that did it for me was wikibooks/Haskell/Category_theory
00:24:11 <faxathisia> Cale: Yes
00:24:16 <faxathisia> for me at least
00:24:21 <wli> solrize: The important thing about springschool95.ps for me was defining it all via fmap, join, and return.
00:24:32 <Cale> I wouldn't have written them if I didn't think they filled some gap in the way that people were thinking.
00:24:49 <hpaste>  adu pasted "Bits ByteString (little-endian)" at http://hpaste.org/6302
00:25:07 <Cale> There are a lot of terrible monad tutorials though.
00:25:27 <solrize> cale was the radioactive was one yours?  (blush)
00:25:30 <Cale> solrize: no
00:25:31 <solrize> waste
00:25:38 <solrize> whew :)
00:25:40 <Cale> solrize: That one is indeed horrific.
00:25:42 <adu> Cale, which ones did you write?
00:25:45 <faxathisia> I thought it was funny...
00:25:52 <Cale> Monads as Computation and Monads as Containers.
00:25:55 <faxathisia> It would be ridiculous to actually try to learn from it..
00:25:57 <solrize> oh those were good
00:26:11 <Cale> http://www.haskell.org/haskellwiki/Monads_as_Computation
00:26:13 <lambdabot> Title: Monads as computation - HaskellWiki
00:26:15 <Cale> http://www.haskell.org/haskellwiki/Monads_as_Containers
00:26:17 <lambdabot> Title: Monads as containers - HaskellWiki
00:26:31 <Cale> I also wrote http://www.haskell.org/haskellwiki/Introduction_to_IO
00:26:31 <lambdabot> Title: Introduction to IO - HaskellWiki
00:26:38 <quicksilver> I must say, I pretty much learnt monads by example.
00:26:51 <quicksilver> Just looking at the types of getLine, putStrLn and a few examples of using them
00:26:54 <Cale> and http://cale.yi.org/index.php/How_To_Use_Monad_Transformers
00:26:56 <lambdabot> Title: How To Use Monad Transformers - CaleWiki
00:27:01 <quicksilver> gave me the general drift.
00:27:09 <solrize> http://unenterprise.blogspot.com/2008/02/tell-us-why-your-language-sucks.html    this is a good article
00:27:10 <lambdabot> Title: Desperately UnEnterprise: Tell us why your language sucks, http://tinyurl.com/39d9cd
00:27:13 <quicksilver> you can fill in the details later
00:27:54 <mofmog> what could cause an input of 0.3 into a Double to become 0.0
00:27:56 <lekro> how do I effectively use these Monoid wrappers like Sum? Like, when I have a [Maybe Int], what's the easiest way to get the sum of the Just values?
00:28:00 <Cale> How to use monad transformers actually isn't really a tutorial for people who don't already know how monad transformers work.
00:28:00 <mofmog> not a truncate in sight
00:28:20 <faxathisia> :t liftM2 (+)
00:28:22 <Cale> It would perhaps better be named "How to use monad transformers correctly"
00:28:23 <lambdabot> forall a1 (m :: * -> *). (Monad m, Num a1) => m a1 -> m a1 -> m a1
00:28:53 <wli> solrize: Could you expand the URL wikibooks/Haskell/Category_theory?
00:28:54 <adu> what the heck is a monad transformer?
00:28:56 <faxathisia> > let sumM = foldr (liftM2 (+)) Nothing in sumM [Nothing, Just 2, Nothing, Just 3]
00:28:57 <lambdabot>  Nothing
00:28:59 <m_abuse> re
00:29:01 <faxathisia> :S
00:29:04 <faxathisia> not like that :P
00:29:09 <solrize> wli   http://en.wikibooks.org/wiki/Haskell/Category_theory
00:29:13 <Cale> adu: It's something which turns a monad into a new monad.
00:29:26 <adu> like (map f)?
00:29:41 <Cale> adu: For example, you can add state to the list monad, and get a monad in which you have state transformations and nondeterminism.
00:29:57 <Cale> Remember that monads are type constructors.
00:29:59 <m_abuse> whats the best way to list all installed packages including version-information?
00:30:22 <Cale> m_abuse: ghc-pkg list
00:30:23 <m_abuse> thx Cale
00:30:44 <adu> Cale: like [ST a] or ST [a]?
00:30:53 <adu> what kind of state?
00:30:57 <Cale> StateT s [] a
00:31:27 <Cale> newtype StateT s m a = StateT { runStateT :: s -> m (a,s) }
00:31:28 <quicksilver> lekro: mconcat [ Sum x | Just x <- l ]
00:31:29 <wli> solrize: Your comment, then, is precisely the same as mine. fmap, return, and join.
00:31:44 <adu> i'm tired
00:31:52 <quicksilver> lekro: alternatively, mconcat . map Sum . catMaybes $ l
00:31:54 <adu> and "newtype" still hurts my brain
00:32:05 <lekro> quicksilver: I see, thanks
00:32:06 <Cale> adu: data would be fine
00:32:12 <quicksilver> lekro: or, foldMap Sum l -- needs import Data.Foldable for foldMap
00:32:22 <quicksilver> damn, foldMap Sum (catMaybes l)
00:32:23 <quicksilver> I mean.
00:32:26 <Cale> http://hpaste.org/6292 conveniently shows the instance.
00:32:56 <solrize> why ever use "type" instead of "newtype"?  i mean "type" types aren't checked, which means they're not really types...
00:33:24 <Cale> solrize: type just gives type synonyms, in case there's a type with a long name which you don't want to be bothered typing out over and over
00:33:32 <solrize> hmm ok
00:33:33 <wli> Is there a data structure lib floating around for O(lg(n)) maintenance of a dynamic set of disjoint intervals with O(lg(n)) search for intersections with intervals outside the set?
00:33:43 <Cale> solrize: Or to document things a bit without actually doing something real at the type level.
00:34:05 <Cale> wli: Maybe have a look at the finger trees paper.
00:34:13 <adu> like type RecordIdentifier = Int
00:34:29 <Cale> wli: I seem to recall something like that as a special case of finger trees.
00:34:38 <wli> Cale: I'd be happy with AVL trees or RB trees (though I can obviously hammer out such myself).
00:34:46 <solrize> adu that just seems bogus, newtype RecordIdentifier = RecordIdentifier Int   actually gets you some typechecking
00:34:55 <Cale> wli: Right, but with Finger trees, you write one monoid instance and you're done.
00:34:58 <wli> Oh, crap, I just realized I need coordinate-aligned bounding boxes, not 1D intervals.
00:34:58 <solrize> wli maybe there's some way to do it with data.map
00:35:32 <wli> Well, I need 1D intervals, too.
00:35:39 <wli> (Sparse block matrices.)
00:36:04 <adu> solrize: but if you keep on doing that then you'll need to (Wrap (Every (Thing in))) parens so get at the actual data
00:36:08 <Cale> Er, that and a "Measured" instance.
00:36:45 <Cale> Yeah, it's pretty simple...
00:36:47 <solrize> adu, i guess that can happen, but there's no runtime cost
00:37:00 <adu> only brain cost
00:37:02 <mofmog> haskell is the best language i've ever used. it also happens to be the most annoying
00:37:16 <adu> mofmog: lol
00:37:19 <mofmog> scratch that, it's a hair better than java
00:37:20 <solrize> adu it's like a microcosm of a correctness proof
00:37:43 <Cale> 4.8 Application: interval trees
00:37:43 <Cale> Our final application augments finger trees to support query operations on sets
00:37:43 <Cale> of intervals: we show how to find an interval that overlaps with a given interval in
00:37:43 <Cale> Θ(log(n)), and all m of them in Θ(m log(n/m)) time
00:37:49 <adu> but its just so rusty when it comes to math
00:37:56 <mofmog> haskell needs an IDE that does on the fly type checking
00:38:08 <faxathisia> mofmog: I use ghci for that
00:38:16 <adu> mofmog: I'm writing an IDE
00:38:27 <mofmog> it should INSERT the type definition into your code
00:38:44 <mofmog> so if I wrote say
00:38:47 <adu> so far I have command-line options and an OpenGL frame...
00:38:57 <mofmog> fac 0 = 1
00:39:04 <mofmog> fac a = a * fac (a -1)
00:39:33 <mofmog> it should insert above fac, "fac :: Integer -> Integer" or something of the sort
00:39:44 <faxathisia> I can't see why would you want that?
00:39:56 <Cale> fac :: <TAB>
00:40:00 <Cale> hehe
00:40:06 <wli> Cale: I want it for sparse block matrices, so it'll be entries representing the values for sets of indices like [(i, j) | i <- [iLo .. iHi], j <- [jLo .. jHi]]. They'll be multiplied by sparse vectors and/or matrices on the left and right.
00:40:07 <mofmog> well it shouldn't ever be different than what you think it would be right?
00:40:08 <adu> Cale: that would be better
00:40:31 <mofmog> also you should be able to left click on something and blammo, the type comes up
00:40:35 <faxathisia> mofmog: but why do you want all these type annotations in your code/
00:40:46 <mofmog> so i can keep track of everything
00:40:47 <scook0> personally, I tend to write my signatures *before* my definitions
00:40:57 <scook0> so I usually don't run into that particular problem :)
00:41:08 <adu> mofmog: its very often different or not derivable, like distinctions between Int/Integer
00:41:42 <mofmog> but if it can be inferred
00:42:09 <xpika> is there a cabal install equivalent to "apt-cache search"?
00:42:30 <adu> aanyways igtg
00:42:45 <Cale> xpika: I usually just go to http://hackage.haskell.org/packages/archive/pkg-list.html and look through the packages.
00:43:08 <adu> i love apt-cache search
00:43:15 <adu> :)
00:43:30 <solrize> is there a cute way to compare two Maybe Strings?
00:43:39 <Cale> solrize: Compare them how?
00:43:46 <xpika> Cale: thats worse than "cabal list | grep xxx"
00:43:50 <Cale> > Just "hello" < Just "foobar"
00:43:52 <lambdabot>  False
00:43:57 <Cale> > Just "hello" > Just "foobar"
00:43:57 <lambdabot>  True
00:44:02 <Cale> > Just "hello" > Nothing
00:44:03 <lambdabot>  True
00:44:08 <Cale> > Just "hello" < Nothing
00:44:09 <lambdabot>  False
00:44:41 <solrize> hmm
00:45:12 <solrize> yeah ok, i was looking at http://softwaresimply.blogspot.com/2008/02/how-i-learned-to-stop-worrying-and-love.html  and trying to see if there was a way to use `ap` or something to get rid of the lift/return
00:45:15 <lambdabot> Title: Software Simply: How I Learned to Stop Worrying And Love Haskell's Type Inferenc ..., http://tinyurl.com/2duemm
00:45:22 <xpika> > Just "U" > Just "I"
00:45:23 <lambdabot>  True
00:45:43 <solrize> but it looks logically necessary
00:45:52 <Cale> yeah, that is the nice way to do it
00:46:13 <Cale> btw, fail is evil, and we should all pretend that it doesn't exist :)
00:46:29 <Cale> Use throwError if you want to throw an error :)
00:46:39 <Cale> Or mzero :)
00:47:02 <mofmog> sometimes when parsing i forget i have to parse the WHOLE thing
00:47:15 <mofmog> yeah, using just digits for numbers isnt gonna ct it when you use floats
00:49:43 <solrize> basically i think these tutorials need to be written with pencil and paper exercises like a math book
00:49:48 <mofmog> so what are the advantages of monads over uniqueness types?
00:50:15 <mofmog> it seems, on the face, that uniqueness types are easier to understand but a little more "cheating"
00:50:29 <mofmog> simply just threading a variable through
00:50:53 <solrize> the clean implementers seem to think compiling haskell is just a change to their compiler front end.  i wonder if it can be done the other way around.
00:51:30 <Cale> We'd need some type system extensions.
00:51:38 <Cale> But other than that, yeah.
00:51:49 <Cale> They're very similar languages.
00:52:15 <solrize> do uniqueness types fit into something like henk ?
00:53:09 <mofmog> wow i'm actually applying data directed programming to my calculator
00:53:11 <mofmog> woohoo
00:53:22 <Cale> I don't really know much about Henk.
00:53:31 <xpika> can electrical signals interfere with my brain?
00:53:45 <solrize> it's supposed to be the new intermediate language for ghc.  its type system is the lambda cube
00:54:18 <Cale> Ah, I thought GHC just switched to system F_C
00:54:24 <glguy> I always thought of the lambda cube as a graph that described type systems
00:54:30 <glguy> what does it mean for the type system to  be lambda cube?
00:54:45 <solrize> hmm
00:54:48 <faxathisia> What's C?
00:55:00 <araujo> A letter
00:55:02 <notsmack> glguy: it means the most expressive corner of the cube, i'd imagine
00:55:20 <Cale> faxathisia: Type equality constraints.
00:55:25 <mofmog> well you see the earth is actually a lambda cube
00:55:30 <mofmog> one side for day oen side for night
00:55:45 <mofmog> it's a little hard to explicate but you must follow me about the lambda cube that is how space and tiem is structured
00:55:49 <glguy> mofmog: that's the timecube
00:55:56 <mofmog> LAMBDAcube
00:56:05 <faxathisia> you should make a parody site :P
00:56:07 <mofmog> my conception of the world is turing complete
00:56:40 <solrize> the henk paper is gone from spj's homepage?
00:59:56 <sclv> http://citeseer.ist.psu.edu/jones98bridging.html this?
00:59:57 <lambdabot> Title: Bridging the gulf: a common intermediate language for ML and Haskell - Jones, La ...
01:00:09 <solrize> no
01:00:33 <solrize> http://research.microsoft.com/research/pubs/view.aspx?id=371&type=Publication
01:00:35 <lambdabot> Title: Henk: A Typed Intermediate Language, http://tinyurl.com/3xajf8
01:00:50 <wli> Nature called, sorry. While I was up there it seems that when I thought about it you only need range intersections for one coordinate at a time depending on whether the matrix/vector or matrix/matrix product is coming at you from the right or left.
01:01:09 <Cale> wli: That seems sensible.
01:01:53 <wli> OTOH you have two dynamic sets of disjoint intervals all of whose intersections you want, which is a different (less commonly analyzed?) algorithm.
01:02:04 <Cale> wli: You can steal an implementation of interval trees from the Finger tree paper. It's about 10 lines added to the fingertree library.
01:02:26 <Cale> (well, a bit more if you want a nice polished library of operations)
01:02:53 <wli> Yeah. I obviously would rather spend more time hacking on the things that the linear algebra is getting used for than the guts of the linear algebra itself.
01:05:04 <solrize> anyone use hxt?  is it the best way to crunch large .xml's fast?
01:06:06 <Cale> solrize: I don't know about large xml files, but it's decent for normal sized things.
01:06:26 <solrize> large = maybe 10 MB, i guess that's not enormous
01:06:31 <Cale> solrize: There were some performance issues with large files and I'm not sure if those got hammered out.
01:06:37 <solrize> hmm
01:07:10 <wli> If I'm right about how to go about this, it's the sort of tree walk that seems to need Fortran pointers in Haskell.
01:07:24 <solrize> zipper?
01:07:28 <Cale> wli: hm?
01:07:53 <wli> Cale: Walking back up from leaves and back down again to get to the next intersection.
01:08:16 <Cale> Did you look at that paper?
01:08:57 <wli> Cale: "Finger tree paper" didn't give me a good idea of where to look.
01:09:39 <Cale> ah, I'll get you a link
01:09:49 <Cale> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/fingertree-0.0
01:09:52 <lambdabot> http://tinyurl.com/2t8z7n
01:09:54 <Cale> http://www.soi.city.ac.uk/~ross/papers/FingerTree.html
01:09:55 <lambdabot> Title: Finger Trees: A Simple General-purpose Data Structure
01:11:01 <wli> Cale: Thanks.
01:13:09 <quicksilver> gah at incomplete APIs
01:13:27 <quicksilver> wx appears to have no way to load an Image from an in-memory block, only from a file.
01:17:45 <mofmog> i love how you can reduce with monad operators
01:17:55 <mofmog> so far my one and only reason for sticking with them
01:17:57 <mofmog> ^_^
01:18:12 <mofmog> makes data directed programming work oh so well
01:46:05 <solrize> catMaybes ms = [ x | Just x <- ms ]            wow
01:46:18 <faxathisia> @undo [ x | Just x <- ms ]
01:46:19 <lambdabot> concatMap (\ a -> case a of { Just x -> [x]; _ -> []}) ms
01:46:49 <faxathisia> map fromJust . filter isJust
01:47:01 <solrize> how did it know?
01:47:12 <faxathisia> ?where lambdabot
01:47:13 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
01:47:34 <faxathisia> This http://www.cse.unsw.edu.au/~dons/lambdabot/Plugin/Undo.hs
01:47:46 <oerjan>  @undo implements the official translations of list comprehensions and do expressions from the haskell report
01:48:01 <oerjan> or something close to it
01:54:04 <solrize> QuickCheck.Gen looks unsafe?  you can get its values out into a pure function
01:54:33 <oerjan> it's a pure monad
01:55:30 <solrize> but it's got this nondeterministic seed inside
01:56:29 <solrize> i see, anything that uses it also has to be in the monad
01:56:48 <oerjan> or pass in the seed
01:57:10 <solrize> the doc i'm looking at doesn't say how to do that, maybe it needs an update
01:57:53 <oerjan> hm the constructor may not be exported
01:58:26 <oerjan> ah, the generate function
01:58:33 <oerjan> :t Test.QuickCheck.generate
01:58:37 <lambdabot> forall a. Int -> StdGen -> Gen a -> a
01:59:39 <oerjan> @hoogle Gen a -> a
01:59:39 <solrize> i can understand quickcheck itself doing unsafe operations since it's basically a debugging tool, but the wikibook doc suggests using quickcheck.gen to get random numbers into the non-IO parts of your app, which seems to miss the point
01:59:40 <lambdabot> No matches, try a more general search
02:00:07 <oerjan> i don't think there is anything unsafe about it
02:00:34 <solrize> hmm
02:00:47 <oerjan> newtype Gen a = Gen (Int -> StdGen -> a)
02:01:07 <oerjan> inside, Gen is simply a function that needs to be supplied the initial seed
02:01:49 <solrize> http://en.wikibooks.org/wiki/Haskell/Hierarchical_libraries/Randoms  gives the impression that it seeds itself
02:01:55 <lambdabot> http://tinyurl.com/2fpup7
02:03:41 <oerjan> no, it clearly mentions the generate function
02:04:34 * oerjan thinks Gen has a tiny deviation from the monad laws...
02:04:42 <solrize> oh i see thanks
02:05:19 <oerjan> the actual random generator passed into a subaction can depend on how it is split up...
02:11:08 <quicksilver> yup
02:11:15 <scook0> @src guard
02:11:15 <lambdabot> guard True  =  return ()
02:11:15 <lambdabot> guard False =  mzero
02:11:16 <quicksilver> but such deviations don't violate the spirit of the laws
02:11:38 <quicksilver> in my opinion.
02:13:02 <oerjan> thus "tiny"
02:13:37 <oerjan> it could get ugly if some compiler actually tried to _assume_ the monad laws, though
02:19:02 <scook0> is it the case that comonads are not Applicative, in general?
02:19:19 <quicksilver> well the 'ugliness' would be limited to some times getting different results for a fixed seed.
02:19:45 <quicksilver> oerjan: so I think it would only really matter if the compiler was non-deterministic, sometimes applying the laws and sometimes not :)
02:19:46 <oerjan> since a monad need have no escaping function, a comonad needs not have a pure/return, i think
02:20:06 * yitz supports abiding by the monad laws
02:21:07 * yitz just joined in the middle of the discussion, though.
02:23:20 <oerjan> yitz: it's the Get monad.  the little violation may be important for laziness, i think - you don't have to thread state through it that way
02:23:45 <Cheery> why in haskell you do not write constructors completely in upper case?
02:23:54 <yitz> Get monad?
02:24:02 <oerjan> yitz: from QuickCheck
02:24:20 <yitz> Cheery: WHO SAYS YOU DON'T?
02:24:41 <oerjan>   Gen m >>= k =
02:24:41 <oerjan>     Gen (\n r0 -> let (r1,r2) = split r0
02:24:41 <oerjan>                       Gen m'  = k (m n r1)
02:24:41 <oerjan>                    in m' n r2)
02:24:46 <yitz> IT COULD GET TIRESOME AFTER A WHILE, THOUGH IMHO.
02:25:06 <mauke> THAT'S WHAT CAPSLOCK IS FOR
02:25:42 <Cheery> hah, stop the emotions, just thinking out loud. :)
02:25:52 <yitz> mauke: ah, thanks. whew.
02:26:04 <oerjan> e.g. with x >>= return, x ends up getting passed split r0 instead r0 itself, as x alone does
02:26:18 <oerjan> *fst (split r0)
02:26:27 <oerjan> *of
02:28:46 <oerjan> afk
02:29:48 * yitz , who has been criminally lazy about unit testing lately, reviews the QC docs
02:44:08 <yitz> oerjan: I see. It satisfies the monad laws only if the random generator is truly random, which is almost never true.
02:47:42 <yitz> oerjan: So you really want  something like Gen f where f :: RandomGen g => Int -> g -> (a, g). Or better yet, data Gen m a; instance MonadRandom m => Monad (Gen m) where...
02:49:54 <smg> good morning
02:49:57 <yitz> oerjan: Also, it's still not a good idea to rely upon split. I still don't think anyone has done any serious verification of its properties for any generator (except /dev/random).
02:50:10 <opqdonut> mhmm
02:50:42 <solrize> the library should get a deterministic cryptographic prng that can be seeded from /dev/urandom
02:51:02 <opqdonut> well that isn't enough for split
02:51:06 <Botje> isn't there a mersenne twister implementation on hackage?
02:51:09 <opqdonut> because split needs to be deterministic too
02:51:17 <smg> Botje: if you find, tell me *g*
02:51:20 <solrize> what exactly is split supposed to do?
02:51:28 <yitz> Botje: mersenne twister is a bad choice if you need split.
02:51:29 <opqdonut> solrize: split one random generator into two
02:51:30 <solrize> yes i do remember seeing an MT on hackage
02:51:39 <Botje> ah.
02:51:41 <solrize> opqdonut split RNG into two with the same initial state?
02:51:48 <opqdonut> solrize: basically you take two random values and seed two new RNGs with them
02:52:03 <opqdonut> but that makes the RNGs pretty dependent actually
02:52:12 <opqdonut> solrize: no, two _independent_ RNGs
02:52:23 <solrize> oh ok, that shouldn't be a problem if the initial rng is any good
02:52:47 <opqdonut> well
02:52:59 <yitz> solrize: depends what you mean by "good". No one has really studied that very carefully.
02:52:59 <opqdonut> there is practically no mathematical research into this
02:53:00 <solrize> by "any good" i mean "cryptographic"
02:53:12 <opqdonut> so existing RNGs aren't designed to handle this stuff
02:53:22 <solrize> the good ones are :)
02:53:28 <quicksilver> well you don't just take two random values
02:53:29 <yitz> solrize: nope
02:53:32 <opqdonut> cryptographic is not enough, nothing guarantees seeding with produced values is safe
02:53:34 <solrize> really this is done in crypto all the time
02:53:36 <quicksilver> you take two random values of the size of the whole state.
02:53:50 <quicksilver> so if you have a 2048-bit mersenne and you want to split it
02:54:00 <opqdonut> you need 4k?
02:54:03 <quicksilver> you take a 2048-bit random number and use that as one seed.
02:54:12 <quicksilver> this is obviously rather expensive
02:54:18 <solrize> there's no reason for such large state if the algorithm has good enough mixing
02:54:22 <quicksilver> but much safer than taking two 32 bit random numbers :)
02:54:56 <solrize> really, it's enough to use (say) AES in counter mode, starting from a random key
02:55:30 <yitz> solrize: maybe. but maybe not. no one has ever seriously tested that.
02:55:38 <opqdonut> solrize: well write a paper on it if you know for sure
02:55:45 <opqdonut> i don't claim to be a crypto expert
02:56:12 <solrize> opqdonut the definition of AES is it's supposed to be computationally indistinguishable from a randomly chosen permutation on 2**128 elements
02:56:39 <solrize> so from that you can prove all kinds of properties about difficulty of distinguishing its output from a true RNG
02:56:40 * pastorn hates indentation!!
02:56:41 <opqdonut> solrize: and it gets seeded with 32 bits?
02:56:47 <solrize> opqdonut no 128 bits
02:57:02 <solrize> 128 192 or 256 bits, your choice
02:57:06 <pastorn> how du i force it so that evertyme i use TAB all get are WHITESPACEs in vim?
02:57:16 <yitz> solrize: meaning that if you do certain kinds of computations, it has been tested that they will not distinguish them. this isn't one of the kinds of computations that has been tested.
02:57:26 <Zao> pastorn: :se et
02:57:28 <opqdonut> well, if you take two sequences from a permutation they're guaranteed to be distinct right?
02:57:34 <opqdonut> element-wise distinct
02:57:35 <Zao> pastorn: :retab if you want to change existing tabs.
02:57:42 <pastorn> Zao: thanks :)
02:57:46 <solrize> solrize, any distinguisher would be considered a serious security failure of AES
02:58:00 <pastorn> Zao: do i give retab a number or something?
02:58:06 <solrize> opqdonut yes however that only becomes noticable after around 2**64 output blocks in the case of something like AES
02:58:31 <solrize> so alternatively you could use something like SHA256, which however doesn't have such a security property explicitly stated
02:58:32 <Zao> pastorn: No, it uses your ts setting.
02:58:38 <Zao> Or sw, can never remember.
02:58:57 <opqdonut> solrize: yeah i believe split can be pretty robust with some generators
02:58:59 <solrize> http://www-cse.ucsd.edu/~mihir/cse207/classnotes.html   this book is great for crypto theory
02:58:59 <lambdabot> Title:
02:59:02 <opqdonut> however nothing has been proved
02:59:08 <Zao> (expandtab, tabstop, shiftwidth  by the way)
02:59:57 <solrize> opqdonut it's true, if P=NP then all crypto is dead ;).  but cryptographic pseudorandomness is the AES security criterion and it's been beaten on very extensively by people who know what they're doing as part of the certification process
03:00:26 <opqdonut> solrize: well, you can have trapdoors outside NP too :)
03:00:39 <opqdonut> halting problem or something like that
03:01:01 <opqdonut> public key being a turing machine and the private key a proof that it halts for example :)
03:01:10 <solrize> hmm :)
03:01:21 <solrize> not sure how to encrypt with that :)
03:01:25 <opqdonut> but yeah, it would wreck existing crypto
03:01:29 <pastorn> Zao: thanks a lot :D *modifys .vimrc*
03:01:31 <opqdonut> but trapdoors are not limited to NP
03:01:33 <faxathisia> where will you get an endless supply of hard theorems?
03:01:52 <solrize> goldreich "foundations of cryptography" goes into this deeper, i haven't read it much though
03:01:53 <opqdonut> faxathisia: good question :)
03:01:54 <faxathisia> don't say @free :P
03:02:48 <yitz> solrize: we currently use a one of L'Ecuyer's generators (an old one, unfortunately, he has new ones that are better), explicitly designed to produce multiple random streams. He has done extensive testing on them. But, sadly, not for exactly the kinds of independence you need for split.
03:03:09 <quicksilver> I think it's fairly clear that crypto algorithms always get broken.
03:03:13 <quicksilver> it's just a question of how soon.
03:03:29 <quicksilver> and how feasible the attacks are for various bit sizes.
03:04:16 <solrize> quicksilver, really, these functions have held up pretty well, DES has been around for 30+ years and the only reason it's no good any more is that the keys weren't big enough
03:04:25 <solrize> the theoretical breaks against it aren't much better htan brute force
03:05:14 <yitz> quicksilver: like any security, crypto is not about making it impossible to get it. it is about making it more expensive to get in than the profit you would earn.
03:05:56 <quicksilver> yitz: right.
03:06:20 <solrize> well, what i'm getting at is that there's well developed theory now, that if you start from some security assumptions that can be stated precisely, you can prove other properties mathematically
03:06:35 <quicksilver> yitz: but the problem is that new attacks always come along later, if it's important, and they make it less expensive thatn it was :)
03:06:53 <yitz> so if it is already worth it to bribe someone, then spending more on better crypto is a waste of money.
03:06:59 <solrize> so that if you believe that AES does what its specification says it does (i.e. that it's undistinguishable from a random permutation) then you can derive a theorem saying that split works
03:07:08 <quicksilver> yitz: and computers get faster too.. so you have to somehow guess (a) how much better the attacks are going to get, and (b) how much faster computers are going to be.
03:07:32 <quicksilver> yitz: of course, social engineering outstrips hacking every time. But it's less interesting to talk about ;)
03:08:00 <yitz> i suppose the direction in crypto is to find algorithms that are strongly non-parallelizable :)
03:08:28 <solrize> nah, they just make the keyspace big enough and let the attacker use all the parallelism they want :)
03:08:48 <yitz> quicksilver:  not true, it's even more interesting. but off-topic for this channel, sadly.
03:10:41 <solrize> actually you can turn AES into a pseudorandom function by just throwing away half the output (just use 64 bits of each output block), it looks like
03:11:03 <solrize> http://citeseer.ist.psu.edu/tarkkala02cryptology.html
03:11:03 <lambdabot> Title: Cryptology: Special Topics PRP to PRF constructions II: The Sum Construction (Re ...
03:14:09 * RayNbow blinks at http://reddit.com/r/programming/info/6bq6y/comments/
03:14:30 <RayNbow> (Haskell support for Clean)
03:23:09 <SamB> RayNbow: yeah, that does seem kinda crazy!
03:23:50 <SamB> I wonder how they are planning to get Haskell and Clean code to interoperate ?
03:23:58 <SamB> anyway... I should not read it now ;-)
03:24:11 <quicksilver> lol
03:24:22 <quicksilver> ah, misread
03:24:34 <quicksilver> I thiought they were insulting ghc, but they're not really :)
03:26:26 <solrize> is that uniqueness stuff interesting?
03:26:35 <quicksilver> yes, it is.
03:26:43 <solrize> hmm
03:26:44 <SamB> yeah, uniqueness is interesting
03:26:54 <SamB> apparantly, if you have that you don't need an IO monad
03:27:10 <SamB> I still don't know what it IS though
03:27:25 <solrize> well yeah, i mean if you've got the io monad, is uniqueness STILL interesting ;)
03:27:31 <faxathisia> yes
03:27:43 <faxathisia> It's like linear logic in the type system
03:27:45 <SamB> because it means you don't have to have the IO monad as a primitive
03:28:17 <SamB> faxathisia: I thought it was probably something like that ;-)
03:28:25 <quicksilver> you don't have to have the IO monad as primitve in haskell, either.
03:28:42 <quicksilver> the IO monad could be algebraic.
03:28:57 <SamB> that counts as primitive
03:29:04 <quicksilver> no, it doesn't.
03:29:09 <quicksilver> it could be written in pure haskell.
03:29:10 <SamB> the RTS still needs it wired-in that way
03:29:14 <quicksilver> so, that's not primitive.
03:29:22 <solrize> cool, they're gonna include haskell in fedora 9
03:29:30 <quicksilver> The RTS would still need magic to run main, sure.
03:29:38 <quicksilver> but that's no less tru in uniqueness types.
03:29:41 <SamB> I count that as primitive
03:29:44 <quicksilver> the RTS needs magic however you play it.
03:30:11 <SamB> yes, but uniqueness types gives you about the same thing GHC has now, except the primitives are safer
03:30:29 <quicksilver> how are the primitives safer?
03:30:43 <quicksilver> since the IO monad requires no primitives ;P
03:30:46 <SamB> you can't accidentally use the same world more than once
03:30:59 <mnislaih> and what is the trade-off of having uniqueness in the type system ?
03:31:08 <SamB> mnislaih: you have to implement them!
03:31:10 <quicksilver> Oh, I see. YOu mean safer than the actual IMPLEMENTATION ghc uses.
03:31:15 <quicksilver> well yes, that's true.
03:31:18 <mnislaih> SamB I imagine you will have to rennounce to something
03:31:25 <quicksilver> but since that's abstract to the programmer, that doesn't matter.
03:31:34 <SamB> true!
03:31:44 <SamB> also, I expect you can use uniqueness types for other things?
03:31:45 <ski> @check True
03:31:47 <lambdabot>  OK, passed 500 tests.
03:32:09 <quicksilver> yes, you can use uniqueness types for "one-use-only" arrays with destructive update.
03:32:12 <faxathisia> mnislaih: No I don't think so.. inference is stilly decidable and everything isn't it?
03:32:22 <quicksilver> I didn't say that very well. But you know what I meant :)
03:32:38 <SamB> quicksilver: without having to fuse the array code, I guess?
03:32:50 <ski> SamB : yes, arrays, files, separable subsystems for graphics, etc ..
03:33:08 <SamB> the "downside" being that you have to use an explicitly single-threaded array type?
03:33:14 <quicksilver> not really.
03:33:23 <SamB> so-called downside
03:33:24 <quicksilver> it's more like, it makes it easier for the compiler to fuse
03:33:37 <SamB> quicksilver: why would the compiler need to fuse it this way?
03:33:37 <quicksilver> or, it makes it harder for the programmer to write non-fusing code :)
03:33:50 <quicksilver> because the type system forbids multiple use.
03:33:55 <SamB> the compiler doesn't need to fuse it
03:34:06 <SamB> it can just KNOW that it is safe to update the array
03:34:13 <quicksilver> the program still talks about multiple copies of the array.
03:34:21 <SamB> oh?
03:34:22 <quicksilver> it's just the type system guarantees they are only used once.
03:34:29 <quicksilver> so the type system proves that it's safe to fuse.
03:34:31 <SamB> oh, yes.
03:34:35 <quicksilver> the copile has still got to actually do it.
03:34:38 <SamB> but I don't call that fusion.
03:34:39 <quicksilver> compiler.
03:34:44 * quicksilver shrugs
03:34:53 <quicksilver> it's removal of an intermediate data structure.
03:34:59 <SamB> hmm.
03:35:00 <quicksilver> call it deforestation if you prefer :)
03:35:07 <SamB> okay, that works for me
03:35:21 <quicksilver> I don't know if the clean guys actually do this.
03:35:23 <SamB> deforestation-at-a-distance, lets say
03:35:25 <quicksilver> I don't know much about clean.
03:35:31 <SamB> why wouldn't they?
03:35:36 <SamB> it would be a shame to waste it
03:36:17 <quicksilver> yes, I imagine they do.
03:36:27 <SamB> why don't we have that yet?
03:36:33 <SamB> I guess those trade-offs:
03:36:42 <SamB> have to implement it, probably wreaks havoc...
03:37:03 <quicksilver> I would suspect it would interactly poorly with some of the advanced type system stuff
03:37:06 <SamB> I suppose the clean guys are implementing that as a Haskell extension as well?
03:37:10 <quicksilver> rank N types and so on
03:37:15 <quicksilver> but I"m only guessing here.
03:38:54 <quicksilver> someone must surely have written a paper on extended haskell type inference to uniqeuness types
03:38:58 <quicksilver> but I can't find one.
03:39:27 <SamB> why must they have?
03:39:48 <SamB> maybe nobody has ever done it before?
03:39:57 <quicksilver> because it's an obvious question, you'd think someone would have answered it :)
03:40:43 <SamB> obvious question != question considered worth the effort
03:41:27 <faxathisia> I think all you need is to be able to split the context while type checking
03:41:37 <faxathisia> so for inference this would correspond to ..?
03:42:56 <quicksilver> I know a fair amount about logic, but I have no idea what logic Clean corresponds to.
03:43:03 <quicksilver> I'm fairly sure it *isn't* linear logic.
03:43:27 <quicksilver> the logical question would be "how does clean's logic interact with nested quantifiers"
03:43:32 <quicksilver> and other haskell stuff like that.
03:43:51 <quicksilver> the other question is how do uniqueness types and type classes / mptcs / fundeps interact.
03:44:13 <SamB> I don't see why uniqueness types would have much impact on typeclasses
03:44:38 <SamB> hmm.
03:45:17 <divip> quicksilver: papers:  Improved Uniqueness Typing for Haskell ( Arie Middelkoop -- Master’s Thesis),  Uniqueness Typing Simplified
03:46:04 <SamB> Can typeclasses be translated to dictionaries *before* running GHC over them?
03:46:46 <quicksilver> if they could, we wouln't need System Fc
03:46:53 <quicksilver> System F woulc be enough
03:47:01 <quicksilver> so there must be some reason you can't, in all cases.
03:47:07 <SamB> oh.
03:47:16 <quicksilver> it's not obvious to me though :)
03:47:29 <quicksilver> divip: thanks. dowloaded for future perusal :)
03:47:36 <SamB> wait, wee didn't have system Fc before associated types...
03:47:57 <faxathisia> where is Fc described?
03:48:12 <SamB> associated types papers??
03:48:13 <quicksilver> SamB: GADTs, I think.
03:48:20 <SamB> oh was it GADTs?
03:48:31 <SamB> well, neither of those is typeclasses
03:48:46 <quicksilver> true. good point.
03:48:49 <quicksilver> faxathisia: http://research.microsoft.com/%7Esimonpj/papers/ext%2Df/
03:48:50 <lambdabot> Title: Simon Peyton Jones: papers
03:48:55 <faxathisia> thanks
03:49:35 <quicksilver> SamB: looks like you need it even for fundeps.
03:49:41 <quicksilver> unless I misunderstand the abstract.
03:50:18 <SamB> I think you did, because I didn't see it in GHC before ATs were being implemented...
03:51:49 <quicksilver> I'm quite surprised you need it even for gadts.
03:51:58 <quicksilver> I should probably read the paper and find out why :)
03:52:00 <SamB> I think you don't
03:52:18 <SamB> because I believe we had those before I saw it too
03:52:35 <SamB> perhaps it only makes GADTs a lot easier?
03:59:29 <quicksilver> SamB: take a look at chillix's abstract : http://www.cse.unsw.edu.au/~chak/papers/SCPD07.html
03:59:30 <lambdabot> Title: Research Papers of Manuel Chakravarty
04:02:49 <SamB> no time
04:03:27 <quicksilver> ;)
04:03:35 <quicksilver> the abstract is only 3 sentences on that webpage
04:03:37 <quicksilver> but fair enough
04:03:46 <quicksilver> I don't have time to read the paper itself either...
04:04:08 <SamB> maybe later
04:05:09 <Spockz> @pl  aap = and (map isDigit s)
04:05:10 <lambdabot> aap = all isDigit s
04:05:23 <Spockz> @pl  aap s = and (map isDigit s)
04:05:24 <lambdabot> aap = all isDigit
04:25:36 <solrize> >let a=[1..10] in do {b<-take 4 (tails a); guard (length b > 4); return b}
04:26:00 <solrize> >let a=[1..10] in do {b<-map (take 4) (tails a); guard (length b > 4); return b}
04:26:19 <oerjan> you need space after >
04:26:26 <solrize> > let a=[1..10] in do {b<-map (take 4) (tails a); guard (length b > 4); return b}
04:26:27 <lambdabot>  []
04:26:30 <solrize> thanx
04:26:31 <solrize> hmm
04:26:56 <oerjan> all the b's have length <= 4, surprisingly enough ;)
04:27:47 <solrize> > let a=[1..10] in do {map (take 4) (tails a) >>= \b-> guard (length b > 4); return b}
04:27:48 <lambdabot>  []
04:28:11 <solrize> hmm
04:28:25 <oerjan> that actually is incorrect
04:28:37 <oerjan> the return b doesn't refer to the b you think
04:28:38 <solrize> the b isn't bound after the guard i guess
04:28:42 <oerjan> > b :: Expr
04:28:43 <lambdabot>  b
04:29:21 <oerjan> the ; before it ends the lambda
04:29:44 <solrize> > let a=[1..10] in [take 4 b | b<-tails a, length b > 4]
04:29:45 <lambdabot>  [[1,2,3,4],[2,3,4,5],[3,4,5,6],[4,5,6,7],[5,6,7,8],[6,7,8,9]]
04:29:50 <solrize> yeah that's it :)
04:30:05 <RayNbow> why were you trying to write that using do? :p
04:30:06 <solrize> > let a=[1..10] in [take 4 b | b<-tails a, length b >= 4]
04:30:07 <lambdabot>  [[1,2,3,4],[2,3,4,5],[3,4,5,6],[4,5,6,7],[5,6,7,8],[6,7,8,9],[7,8,9,10]]
04:30:56 <oerjan> that's a bit expensive for long a
04:31:14 <solrize> hmm
04:31:18 <oerjan> (the length test that is)
04:31:30 <oerjan> better to do the take first
04:31:31 <solrize> oh good point
04:31:36 <solrize> yeah
04:32:19 <solrize> > let a=[1..10] in [b | b<-map (take 4) $ tails a, length b >= 4]
04:32:20 <lambdabot>  [[1,2,3,4],[2,3,4,5],[3,4,5,6],[4,5,6,7],[5,6,7,8],[6,7,8,9],[7,8,9,10]]
04:32:20 <quicksilver> a more efficient version of length b >= 4
04:32:32 <quicksilver> is (not . null. take 4) b
04:32:45 <quicksilver> more efficient in some circumstances, at least.
04:32:48 <solrize> take 4 [1,2,3]
04:32:51 <oerjan> you mean drop 3
04:32:53 <quicksilver> erm
04:32:56 <quicksilver> thank you oerjan :)
04:32:56 <solrize> yeah
04:33:00 <quicksilver> that is indeed what I mean.
04:33:26 <solrize> i think i'd really write this with an array
04:33:29 <solrize> this is for euler 11
04:33:46 <RayNbow> quicksilver: boolean logic is hard... even though we're only manipulating True and False ;)
04:35:59 <quicksilver> RayNbow: so many ways to get it wrong :)
04:39:55 <TomMD> lol, in #xen someone asked how unsafe something is and I almost ask back "does it use unsafePerformIO?"
04:40:13 <TomMD> To early to help people I guess
04:41:35 <solrize> anyone ever looked at F# ?
04:41:55 <tensh> does anyone know the exact difference between a shallow and a deep embedding?
04:42:21 <quicksilver> roughly, yes.
04:42:33 <TomMD> There is a great paper on exactly that linked from haskell.org
04:42:43 <quicksilver> in a deep embedding you model actions (combinators) with constructors
04:42:52 <quicksilver> so they don't actually do anything ecept build structure
04:42:58 <quicksilver> which you can later analyse.
04:43:02 <tensh> TomMD: would you mind pointing me to it? I've been looking all over without results
04:43:52 <TomMD> tensh: I'm looking for it - but only have ten minutes to spare.  I'll @tell you via lambdabot if I find it later.
04:44:38 <bringert> solrize: a little bit
04:44:42 <tensh> quicksilver: ok, so you can pretty much say that only one method needs to know of other parameters, such as environment?
04:44:57 <DukeDave> dons: Morning, I've just been playing with your post (http://hpaste.org/6285) and it sure is faster! Unfortunately I've been unable to replicate your reduction in memory usage.. My testing with 'ps v -C' indicates it's using the same as the strict bytestrings before
04:45:02 <tensh> i.e. the run function
04:45:05 <quicksilver> the point about a deep embedding is it's amenable to static analysis later, as I understand it.
04:45:12 <solrize> bringert what do you think of it (ie. f#)?
04:45:12 <quicksilver> so you can optimise etc.
04:45:21 <quicksilver> btu I maye have misunderstood some of the details :)
04:45:58 <bringert> solrize: I like the language interoperability, being able to  integrate with e.g. C# and use values from one language in another
04:46:11 <bringert> solrize: and that you can use .net libraries
04:46:12 <byorgey> DukeDave: dons is probably still asleep =)
04:46:12 <tensh> TomMD: you don't have to jump through hoops ;)
04:46:42 <TomMD> but now I'm irritated that I can't remember the paper and didn't read it too long ago.
04:46:49 <bringert> solrize: if you have to program for .net, then you should definitely look at F#
04:46:50 <solrize> bringert, hmm, actually i'm wondering if a tiny embedded implementation of it makes sense
04:46:54 <solrize> i don't use windows :)
04:47:11 <bringert> solrize: F# without .net doesn't seem all that useful
04:47:27 <solrize> well it's less syntactically ugly than sml or ocaml i gather
04:47:43 <DukeDave> byorgey: Good tip, do you know lamdabots messaging syntax?
04:48:00 <byorgey> DukeDave: sure, just @tell <user> message
04:49:24 <solrize> bringert anyway thanks
04:49:45 <TomMD> tensh: "Defining and Implementing Closed, Domain-Specific Languages"
04:49:49 <DukeDave> @tell dons Morning, I've just been playing with your post (http://hpaste.org/6285) and it sure is faster! Unfortunately I've been unable to replicate your reduction in memory usage.. My testing with 'ps v -C' indicates it's using the same as previously (http://hpaste.org/6268)
04:49:50 <lambdabot> Consider it noted.
04:49:58 <DukeDave> Cheers :)
04:50:17 <tensh> TomMD: ooh, goodie :)
04:50:18 <tensh> thanks
04:50:22 <TomMD> np
05:02:45 <smg> > let perfect n = [x | x<-[1..n], sum ((\j -> [i | i <- [1..j], j `mod` i == 0]) x) - x == x] in perfect 1000
05:02:46 <lambdabot>  [6,28,496]
05:02:51 <smg> > let perfect n = [x | x<-[1..n], sum ((\j -> [i | i <- [1..j], j `mod` i == 0]) x) - x == x] in perfect 10000
05:02:54 <lambdabot>  [6,28,496,8128]
05:03:10 <solrize> is it possible to implement GADT's in plain system F ?
05:03:40 <mux> solrize: yes, that is what haskell was doing before 6.8.*
05:04:05 <mux> the internal language was mostly System F omega + lots of extensions for GADTs and the rest
05:04:18 <mux> they say it was problematic though
05:04:26 <solrize> what does it use now?
05:04:33 <mux> and it was getting very difficult to have all the extensions work and play nice with each other
05:04:49 <mux> now it's System Fc, system F with type equality constraints
05:04:55 <solrize> ic
05:04:57 <solrize> thanks
05:05:12 <solrize> what's "functional reactive programming"?
05:05:43 <mux> @seen dons
05:05:44 <lambdabot> dons is in #xmonad, #haskell-soc and #haskell. I last heard dons speak 4h 46m 22s ago.
05:06:50 <smg> > let perfect n = [x | x<-[1..n], sum ((\j -> [i | i <- [1..(j-1)], j `mod` i == 0]) x)  == x] in perfect 1000
05:06:50 <lambdabot>  [6,28,496]
05:06:57 <smg> > let perfect n = [x | x<-[1..n], sum ((\j -> [i | i <- [1..(j-1)], j `mod` i == 0]) x)  == x] in perfect 1001
05:06:58 <lambdabot>  [6,28,496]
05:11:44 <quicksilver> solrize: it's a way of declaring relationships between output and input
05:12:03 <quicksilver> or output and 'something observable, like input or IO or progress in another thread'
05:12:15 <solrize> hmm interesting
05:12:25 <quicksilver> so you can get dynamically updating output from a simple declarative specification
05:12:33 <solrize> cooool
05:12:37 <quicksilver> like "This input box always shows how many packets we've processesd today'
05:12:44 <quicksilver> would be a very very simple example.
05:13:49 <solrize> sounds like textvars in tkinter :)
05:13:53 <quicksilver> yes
05:14:01 <quicksilver> if that's what I think it is, at least
05:14:05 <quicksilver> that's a simple example of the idea.
05:14:28 <Igloo> SamB: No plans currently
05:15:03 <quicksilver> http://www.haskell.org/haskellwiki/Libraries_and_tools/GUI_libraries
05:15:06 <lambdabot> Title: Applications and libraries/GUI libraries - HaskellWiki, http://tinyurl.com/gn7tc
05:15:13 <quicksilver> solrize: almost everything in "1. High-level" in that page
05:15:19 <quicksilver> solrize: is using FRP to some extent.
05:15:25 <quicksilver> Beware, a lot of that is abandoned old projects :(
05:15:44 <solrize> neat
05:16:04 <solrize> i don't understand why every gui toolkit i've ever seen sucks so much
05:16:12 <quicksilver> because it's hard :)
05:16:16 <quicksilver> (hard to make one which doesn't)
05:16:47 <mux> I've always been rather fond of gtk+ myself
05:16:52 <solrize> most gui's i've written could be done in html with possibly a few extra widgets
05:17:14 <mux> eww, say no to the applicative web. >:)
05:21:40 <quicksilver> solrize: you say that as if you think it's somehow surprising?
05:21:46 <quicksilver> HTML is a phenomenally complex system.
05:21:59 <quicksilver> many many times more complex than GTK or Wx
05:22:08 <quicksilver> it's a massive overkill for application development
05:22:10 <quicksilver> *except*
05:22:17 <quicksilver> we all have these applications we call browsers
05:22:20 <solrize> yeah but the browser takes care of it.  writing html is easy, writing a gtk app that does pretty much the same thing as an html page is a zillion times harder
05:22:22 <quicksilver> which have the build in ability to display them
05:22:33 <mux> solrize: not so sure about it
05:22:34 <quicksilver> really, that's not true.
05:22:48 <quicksilver> you can design a UI in glade in about one tenth of the time y ou can build an HTML page.
05:22:56 <mux> exactly, I was going to say that
05:23:02 <quicksilver> Now, when you come to actually add functionality to that UI, that's going to be hard
05:23:06 <quicksilver> but that's hard in web apps too
05:23:10 <mux> oh yes
05:23:21 <mux> especially if you want a wep app that will work for mostly everyone
05:23:38 <quicksilver> HTML+CSS+extensions+JS is a totally disastrous mess, really
05:23:43 <quicksilver> but it has one strong virtue: ubiquity
05:24:01 <quicksilver> which over-rules all its inadequacies for many purposes
05:24:08 <quicksilver> which is why it's so widely used / useful :)
05:24:55 <solrize> well as long as i keep stuff simple, i find web apps easier to write than gui apps, maybe mostly because the user clicks "submit" and you get all the fields in a table-like structure instead of having to wire up special purpose code to each widget in the interface
05:25:53 <mux> I'm tempted to add that gtk+ is billion times more coherent as an API than html and friends
05:25:53 <quicksilver> that's for a very particular kind of app, though
05:26:01 <quicksilver> form submission is not a general app :)
05:26:06 <mux> and you don't need 4 different technologies to achieve your goal
05:26:26 <quicksilver> sure, HTML forms are pretty good at being forms.
05:26:30 <mux> HTML + CSS intertwined with JavaScript to avoid full-page reloads, and so on
05:26:36 <mauke> SCALABLE ENTERPRISE SOLUTIONS
05:26:52 * quicksilver hands mauke a cup of steaming java.
05:27:19 <opqdonut> :)
05:27:24 <solrize> yeah, ajax etc. turns nightmarish fast
05:27:44 <opqdonut> quicksilver: my friend had a java->shit autocomplete in his irssi a while ago
05:27:52 <mux> you end up using other APIs and layers such as the prototype API to avoid portability issues
05:28:01 <mux> but it's still a huge mess :)
05:28:26 <quicksilver> opqdonut: ;)
05:28:55 <quicksilver> I quite enjoy web programming, in the same way I enjoy crossword puzzles
05:28:58 <quicksilver> the challenge is fun
05:29:06 <opqdonut> *shudder*
05:29:08 <solrize> sounds like haskell :)
05:29:08 <mux> I loathe web programming
05:29:11 <quicksilver> (although I don't get paid for doing the crossword, that helps)
05:29:15 <opqdonut> i have a web programming course
05:29:21 <opqdonut> i have to choose between java and php
05:29:27 <quicksilver> but I don't find it a particularly pragmatic way of writing applications.
05:29:50 <solrize> php is good for simple stuff, practical low tech approach
05:29:58 <solrize> easy templating
05:30:13 <mux> I sooo hate php with a passion.. :-)
05:30:17 <faxathisia> The best way to make a website is using SLIME, hunchentoot & xml-mixed-mode
05:30:44 <solrize> my haskell goal is to figure out how to use happs -- it's compelling but uses very advanced haskell
05:30:52 <solrize> what's slime and hunchentoot ?
05:30:54 <amaron> how about zope?
05:31:08 <mauke> (((LISP)))
05:31:14 <opqdonut> solrize: i prefer perl :)
05:31:16 <solrize> zope has seemed awful to me but i haven't looked at it in detail
05:31:25 <opqdonut> hmm, web programming in perl6
05:31:40 <shapr> I did Zope and Plone for a living for a few years.
05:31:40 <lambdabot> shapr: You have 1 new message. '/msg lambdabot @messages' to read it.
05:31:42 <shapr> I like Haskell better.
05:31:49 <amaron> zope3 is more clean, but extremely complex too
05:31:54 <solrize> shapr do you know anything about happs ?
05:32:00 <shapr> Yes, I do.
05:32:05 <faxathisia> happs is impossible to install :P
05:32:06 <solrize> cool
05:32:29 <opqdonut> :D
05:32:38 <opqdonut> lua could be nice for web programming too
05:32:49 <solrize> happs state is just brilliant
05:32:49 <mux> mod_bf !
05:32:49 <faxathisia> lua wont beat common lisp
05:33:06 <mauke> common lisp is crippled enough; no beating required
05:33:08 <solrize> that's the part of happs that interests me the most
05:33:25 <shapr> Every language has its good points.
05:33:42 <faxathisia> hmm.. almost every language
05:33:43 <mauke> malbolge?
05:33:55 <shapr> Sure, malbolge is good for torturing people :-)
05:34:14 <mux> INTERCAL for web programming!
05:34:32 <mauke> oh god
05:34:46 <mauke> wasn't there an implementation of INTERCAL that used COME FROM for multithreading?
05:35:41 <mux> that would be pretty terrific :)
05:37:17 <quicksilver> happs is interesting, but I sometimes wish it didn't try to be so clever all at once :)
05:37:44 <shapr> Yeah, I wish that too.
05:38:49 <mux> I've been stopped in learning happs when realizing it uses TH
05:39:27 <solrize> yeah also uses SYB
05:40:17 <quicksilver> I find alexj's views about relational databases interesting.
05:40:22 <quicksilver> But I don't agree with all of them.
05:40:40 <quicksilver> at least, I don't agree with the lengths they are carried to.
05:42:57 <shapr> I think HAppS has a bit too much magic.
05:43:27 <solrize> maybe so
05:46:09 <Vq^> quicksilver: what does he say?
05:47:28 <dcoutts> hia nominolo
05:47:43 <nominolo> aloha
05:47:56 <nominolo> > Nothing `mappend` Just []
05:47:56 <lambdabot>  Just []
05:48:05 <nominolo> > Just ["foo"] `mappend` Just []
05:48:06 <lambdabot>  Just ["foo"]
05:48:30 <nominolo> > Just ["foo"] `mplus` Just []
05:48:31 <lambdabot>  Just ["foo"]
05:49:00 <mauke> > Just "foo" ++ Just "bar"
05:49:01 <lambdabot>  Just "foobar"
05:50:49 <quicksilver> Vq^: he cdoesn't like them.
05:51:00 <quicksilver> Vq^: he thinks persistent data is a better model
05:51:18 <quicksilver> Vq^: and criticises all the time we spend marshalling/unmarshalling from relational to (data/object) form.
05:51:28 <quicksilver> (I don't mean CPU time, I mean programmer time)
05:51:33 <opqdonut> hmm, Maybe is kind of like expanding a magma into a monoid
05:52:06 <opqdonut> one could look at Either as expanding a monoid into a group, if one would define the operation suitably
05:52:43 <skorpan> when i'm installing wxhaskell i get this error: wxc/src/db.cpp:1165: error: ‘SQLCHAR’ was not declared in this scope
05:53:03 <skorpan> does anyone know why? i installed wxwidgets successfully with --with-odbc
05:53:05 <Smurfen_> skorpan: owned
05:53:20 <Smurfen_> skorpan: worst cont ive seen!
05:53:32 <skorpan> right
05:54:39 <mux> are there people who have had problems with linker errors with runplugs from the lambdabot darcs? I found a workaround and am interested in knowing if others have the same issue
05:55:05 <solrize> is there an operator like . that associates the other way?  so instead of f . g . h  i'd write   h ? g ? f
05:55:17 <solrize> i.e. run h first, like a unix pipe
05:55:38 <skorpan> $ ?
05:55:50 <faxathisia> > let di = flip id in f `di` g `di` h
05:55:51 <lambdabot>  Add a type signature
05:55:51 <solrize> no that just has lower precedence
05:55:55 <faxathisia> > let di = flip id in f `di` g `di` h :: Expr
05:55:55 <skorpan> okay
05:55:55 <lambdabot>  Add a type signature
05:55:59 <faxathisia> hmpf
05:56:00 <quicksilver> solrize: you don't mean associates the other way.
05:56:13 <quicksilver> solrize: (.) is associative, it doesn't matter which way it associates :)
05:56:15 <solrize> hmm ok
05:56:17 <quicksilver> h >>> g >>> f
05:56:20 <solrize> :t flip id
05:56:21 <lambdabot> forall b c. b -> (b -> c) -> c
05:56:21 <quicksilver> is the answer to your question.
05:56:50 <mauke> > f >>> g
05:56:50 <lambdabot>        add an instance declaration for
05:56:50 <lambdabot>       (SimpleReflect.FromExpr (a c d),...
05:57:00 <solrize> quicksilver, thanks
05:57:10 <mauke> > (f >>> g) x
05:57:10 <lambdabot>  Add a type signature
05:57:45 <Stwange> does anyone understand Turing reductions? I sort of vaguely understand, but nowhere enough for what I've got to do.
05:58:14 <quicksilver> solrize: you'll need to import Contorl.Arrow((>>>))
05:58:17 <quicksilver> and spel it rite, too.
05:58:49 <tromp> I do, Stwange
05:58:53 <solrize> Prelude Control.Arrow> ((++"a") >>> (++"b") >>> (++"c")) ""
05:58:53 <solrize> "abc"
05:58:55 <solrize> nice
05:58:56 <solrize> thanks
05:59:07 <pastorn> @hoogle LazyBytestring
05:59:07 <lambdabot> No matches found
05:59:14 <pastorn> @hoogle Word
05:59:15 <lambdabot> Data.Word :: module
05:59:15 <lambdabot> Data.Word.Word :: data Word
05:59:15 <lambdabot> GHC.Exts.Word :: data Word
05:59:29 <pastorn> @doc Data.Word
05:59:29 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/4/Data-Word.html
05:59:55 <pastorn> yay! 404!!
06:00:03 <pastorn> could someone please repair that?
06:00:52 <Stwange> tromp, I don't really know what I'm trying to ask. I have to prove that L1 <= L2 for three different examples (it doesn't say if I'm trying to prove they are not recursive or anything). All I know is that I'm trying to find some function that maps the output of L1 to something a turing machine for L2 will accept... but I don't understand all the technical definitions or anything
06:01:32 <Stwange> does L1 have to accept it before L2 does anything?
06:01:52 <solrize> how can there be Num (b->c)   ?
06:02:36 <solrize> output of L1?
06:02:52 <tromp> L1 <= L2 means a turing machine exists that can solve L1 with help of L2
06:02:52 <mauke> solrize: http://mauke.ath.cx/stuff/haskell/fun.hs
06:03:09 <solrize> oh ok
06:03:10 <solrize> sure
06:03:13 <shapr> hoi tromp!
06:03:28 <solrize> like if you can solve 3SAT you can solve anything in NP
06:03:51 <tromp> the help in this case is being able to ask questions about L2 membership as a sort of oracle
06:03:56 <solrize> right
06:03:58 <tromp> hi Shae
06:04:20 <tromp> L2 is not a machine, you cant talk of L2 doing soimething
06:04:33 <solrize> yeah, i understand, you have an L2 oracle
06:04:48 <solrize> you want to show a reduction from L1 to L2
06:05:38 <tromp> you're given a string whose membership in L2 must be decided
06:06:16 <tromp> you can ask as many questions about L2 membership as you like
06:06:27 <tromp> sorry L1 in first sentence
06:06:30 <solrize> ok
06:06:54 <Stwange> I thought it was f(L1) = L2?
06:07:00 <Stwange> not f(L2)=L1
06:07:36 <solrize> so you want to know if some number is prime
06:07:41 <tromp> you're not talking about many-one reduction are you?
06:07:45 <solrize> and you've got a recognizer for boolean satisfiability
06:07:56 <solrize> yeah, the way these problems are usually set up, you're only allowed to call the oracle once
06:08:05 <solrize> "karp reduction" vs "cook reduction"
06:08:36 <Stwange> tromp, I'm really not sure, I'll give an example of what I'm being asked. This example is from an exercise sheet, not the assignment, I don't believe in plaigairising. One second
06:08:58 <smg> someone in here likes APL?
06:09:07 <faxathisia> smg: I do
06:09:10 <faxathisia> but I don't know it well
06:09:45 <Stwange> tromp: define a function f:L101 < Lu where L101 = { Bi | 101 is in L(Mi) } and Lu is the universal machine
06:09:57 <Stwange> is this a many-one reduction?
06:10:27 <solrize> what's L(Mi) ?
06:10:29 <smg> faxathisia: i just read about APL but i like haskell more
06:10:31 <smg> hehe
06:10:31 <tromp> you cant reduce to machines:)
06:10:40 <tromp> Lu must be a language
06:10:47 <Stwange> the Language M accepts, Bi is the encoding of Mi
06:11:20 <solrize> oh
06:11:31 <tromp> so L101 is all machines that accept 101?
06:11:50 <tromp> suitably encoded
06:12:20 <solrize> L101 is the encodings of all the machines where Mi accepts 101
06:12:22 <solrize> yeah
06:13:05 <tromp> and Lu is {(Bi,x,y) | machine Mi on input x outputs y} ?
06:13:41 <tromp> or simply  {(Bi,x) | machine Mi accepts input x} ?
06:13:41 <Stwange> Lu is {(M,w) | w not in L(M) }
06:13:50 <Stwange> sorry, it is in
06:13:58 <Stwange> yeah pretty much
06:14:19 <tromp> ok, this is about many-one reductions
06:14:39 <tromp> you want function f such that x in A iff f(x) in B
06:15:50 <tromp> e.g. f(Bi) = (Bi,101)
06:15:51 <Stwange> yeah that sounds right
06:16:03 <Stwange> ok this is the bit I don't understand
06:16:11 <Stwange> what's (Bi, 101) - does it mean append 101?
06:16:24 <Stwange> oh, it takes the encoding, and 101
06:16:25 <tromp> no, some suitable encoding of the pair
06:16:59 <tromp> which is already assumed in definition of Lu
06:17:28 <Stwange> that sort of makes sense I guess
06:17:54 <hallongrottan> hello mikael
06:17:58 <mikael> hey
06:18:10 <Smurfen_> sup mang!
06:18:47 <mikael> not much
06:19:55 * scook0 is surprised to find that arrays don't seem to feature a lookup function
06:20:10 <faxathisia> :t (!)
06:20:11 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
06:20:49 <nornagon> :t lookup
06:20:50 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
06:21:29 <scook0> > listArray (0,0) [1..] ! 2
06:21:30 <lambdabot>  Exception: Error in array index
06:21:39 <Stwange> thanks a lot tromp, hopefully I can get my head around this now
06:21:55 <faxathisia> > listArray (0,5) [1..] ! 2
06:21:55 <scook0> nothing stops you from checking the bounds yourself, of course
06:21:55 <lambdabot>  3
06:22:05 <tromp> you're welcome, Stwange
06:22:06 <scook0> it just seems like a strange omission
06:22:20 <faxathisia> @hoogse Array i e -> i -> Maybe e
06:22:20 <lambdabot> No matches, try a more general search
06:22:27 <faxathisia> @hoogse Array i e -> i -> m e
06:22:27 <lambdabot> No matches, try a more general search
06:22:29 <faxathisia> :(
06:23:07 <scook0> @haggle lookup
06:23:07 <lambdabot> Prelude.lookup :: Eq a => a -> [(a, b)] -> Maybe b
06:23:07 <lambdabot> Data.List.lookup :: Eq a => a -> [(a, b)] -> Maybe b
06:23:07 <lambdabot> Data.HashTable.lookup :: HashTable key val -> key -> IO (Maybe val)
06:24:09 <quicksilver> scook0: what do you mean by "a lookup function" ?
06:24:17 <scook0> quicksilver: Data.Map.lookup
06:24:30 <quicksilver> you mean, you want it to have a Maybe type?
06:24:35 <quicksilver> is that your only objection to (!)
06:24:37 <quicksilver> ?
06:25:09 <scook0> well, I'd prefer a more general type than Maybe, but yes -- and of course I could write my own
06:25:36 <quicksilver> you only want Nothing if the index is out of range?
06:25:54 <quicksilver> I imagine the reason it isn't there is just because array programs are generally expected to know the range of their arrays
06:26:01 <quicksilver> so this is an unusual case
06:27:10 <scook0> I'm writing a variant of ReaderT that stores an array of environment data
06:28:01 <scook0> and I'd like to give client code a choice of error-handling policy
06:28:29 <scook0> (and nice error messages)
06:29:05 <quicksilver> this is a reasonable desire :)
06:29:20 <quicksilver> I'm not entirely sure why you'd bother to use arrays, though
06:31:18 <scook0> it's for an app-specific problem
06:33:15 <scook0> the array contains a table of "classes", and each "object" has an index into the table
06:43:15 <Cheery> I guess type-checking is impossible on imperative languages because it requires value-centric -view on programming, whereas in pure assembly there's pointer-centric -view
06:44:04 <quicksilver> that's a strange comment.
06:44:14 <Cheery> oh well, not impossible, but hard
06:44:15 <quicksilver> There are plenty of ways to type-check imperative languages.
06:44:30 <quicksilver> C++ is type checked in moderately strong ways.
06:44:47 <quicksilver> haskell's do { } blocks are a type checked imperative mini-language.
06:44:49 <faxathisia> you can type check but with a language that has explicit allocation & freeing, you can't have type safety
06:44:51 <quicksilver> or can be viewd as such.
06:45:12 <quicksilver> faxathisia: you can perfectly well imagine type systems which account for such things.
06:45:19 <quicksilver> faxathisia: of course, they have problems of their own
06:45:20 <Cheery> and type-inference is also quite hard there
06:45:24 <quicksilver> but people do work on this stuff.
06:45:36 <faxathisia> well yeah, bakers linear lisp stuff is an example
06:45:47 <faxathisia> I should have specified, C or C++ style languages
06:46:17 * quicksilver nods
06:46:21 <quicksilver> the problem there is mutation, though.
06:46:27 <quicksilver> not explicit allocation/deallocation
06:46:37 <quicksilver> free() essentially changes the type of a variable
06:46:42 <quicksilver> (from Ptr to NullPtr, if you like)
06:46:49 <faxathisia> ah, true
06:47:06 <Cheery> hmm.. when one thinks of it..
06:47:08 <Sluor> quick question: I'm trying to multiply a Int (received from length <list>) with a Float. Afaik, I can't do this. Any suggestions?
06:47:14 <quicksilver> you might say "the problem is the interaction between explicit allocation and mutation"
06:47:17 <quicksilver> or something.
06:47:20 <quicksilver> Sluor: fromIntegral
06:47:20 <Cheery> yes the mutation seems to be the problem, since in haskell, your value does never change
06:47:23 <scook0> @quote fromIntegral
06:47:23 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
06:47:32 <Cheery> even if it'd be a pointer, but if it'd never change, you'd be quite safe
06:47:36 <quicksilver> > fromIntegral (length [1,5,1]) * 2.0
06:47:37 <lambdabot>  6.0
06:47:42 <Sluor> Integral == Int or Integer?
06:47:46 <quicksilver> Sluor: yes.
06:47:52 <quicksilver> (and a few other possibilities)
06:47:56 <quicksilver> Cheery: exactly.
06:48:03 <Sluor> cool. thanks all.
06:48:12 <quicksilver> Cheery: and if you program in "C++ - without - explicit - allocation"
06:48:19 <quicksilver> Cheery: you do indeed get this kind of safety.
06:48:27 <quicksilver> Many C++ programmers aspire towards that as a goal.
06:48:38 <quicksilver> (hiding the explicit allocation away in one module, or something similar)
06:54:12 <scook0> how is the mutation important?
06:54:16 <Toxaris> what's the problem with mutation and type checking? if mutation is defined in a way that values can only be replaced by values of the same type, i don't see a problem
06:54:39 <faxathisia> Toxaris: That's not how it works in reality though
06:55:24 <Toxaris> that means that it's not possible to see Ptr and NullPtr as different types in quicksilver's example, and invalid Ptr accesses are not type errors
06:55:47 <Toxaris> just as (fromJust Nothing) is not considered a type error in Haskell
06:57:01 <Toxaris> faxathisia: why not? because mutation in real languages doesn't have that property?
06:57:08 <faxathisia> foo * x; bar * y; free(x); y = malloc(sizeof bar);  puts(x->name); // it could be that there is an uninititalzed 'bar' in the place of foo.. but you treat it as a foo.. that's a type error
06:57:58 <scook0> faxathisia: so you're referring to the fact that free does mutation?
06:58:12 <Cheery> quicksilver: thought c++ in itself is quite hideous, and verbose
06:58:19 <faxathisia> treating an object of one type as on object of another type
06:58:29 <quicksilver> Cheery: C++ has its unattractive properties. It doesn't have to be verbose if used well.
06:58:37 <quicksilver> At least, not verbose like Java.
06:58:58 <Cheery> but still it is hideous if nothing else
06:59:01 <quicksilver> however, making C++ as safe as it can be requires a lot of attention to detail
06:59:06 <quicksilver> stuff like copy constructors et al
06:59:16 <quicksilver> and a small mistake there can really screw things up.
06:59:27 <faxathisia> Cheery: How hidous a language is, is orthogonal to type systems :P
06:59:30 <scook0> (because otherwise I don't see where the mutation is)
06:59:31 <quicksilver> once you've got the basic types + data correct and safe, the actual programming part isn't too bad.
06:59:46 <quicksilver> Toxaris: agreed.
06:59:52 <jleedev> "unsafeCoerce True :: Maybe a" --> Just Segmentation fault
06:59:52 <quicksilver> Toxaris: it's just that free is type-changing.
06:59:57 <scook0> the problem with C++ is that it has a huge essential complexity, *and* a huge accidental complexity
06:59:58 <quicksilver> Toxaris: (in this sense)
07:00:21 <Cheery> btw. playing out with type inferencing, it seems quite really nice!
07:00:21 <quicksilver> Toxaris: of course there is another sense in which free isn't type-changing. But that type-system is too weak to prevent segfaults.
07:00:39 <quicksilver> so, we prefer the system which prevents segfaults
07:00:46 <quicksilver> and we have the problem that free is type-changing.
07:00:49 <Cheery> so infinite type is valid type signature, but because it is hard problem, it is yelled as error
07:01:02 <quicksilver> NOne of this is insoluble. I'm just talking about some of the issues.
07:01:19 <Cheery> and type error becomes if the type is invalid..
07:01:41 <Cheery> polymorphic types seem like they'd be almost free with prolog
07:02:03 <DukeDave> @seen dcoutts
07:02:03 <lambdabot> dcoutts is in #gentoo-haskell, #haskell, #ghc, #haskell-overflow and #haskell-soc. I last heard dcoutts speak 1m 39s ago.
07:02:07 <faxathisia> Cheery: You can do Prolog style programming in Haskell Type System
07:02:37 <DukeDave> dcoutts: Heya, I was just reading you spectacular plan for space saving: http://www.haskell.org/pipermail/haskell-cafe/2008-March/040452.html
07:02:39 <lambdabot> Title: [Haskell-cafe] Re: Constructing Data.Map from ByteString, http://tinyurl.com/2df5so
07:03:03 <DukeDave> And I'm going to have a crack at getting it working :)
07:03:20 <dcoutts> hia DukeDave
07:03:26 <faxathisia> Cheery: or did you mean, to implement inference for?
07:03:30 <Toxaris> I would prefer a type system for Haskell which prevents pattern match failures. That is not possible. Does that mean that typechecking pure functional languages is hard?
07:03:32 <Cheery> faxathisia: remember reading about that once
07:03:51 <Cheery> but what I meant is that you could possibly implement type inference for free in prolog. :)
07:03:55 <Cheery> almost for free
07:04:06 <faxathisia> Cheery, yeah, http://muaddibspace.blogspot.com/2008/01/type-inference-for-simply-typed-lambda.html
07:04:08 <lambdabot> Title: Muad`Dib: Type inference for The Simply Typed Lambda Calculus, http://tinyurl.com/ynjhl6
07:04:18 <faxathisia> 3 lines.. but close
07:04:21 <dcoutts> DukeDave: keep your current version around as a test oracle for the more complex one
07:04:53 <DukeDave> dcoutts: I'm relying on hpaste to be my versioning system ;)
07:05:04 <scook0> Toxaris: I know of a type system that decidably prevents pattern match failures
07:05:12 <allbery_b> hpaste has been known to get zeroed
07:05:18 <scook0> unfortunately it rejects all valid programs as well, so it's not terribly useful ;)
07:05:23 <Cheery> faxathisia: would that be practical?
07:05:37 <DukeDave> Also I have been records mem footprints for various size data sets using previous versions..
07:05:41 <Cheery> I think an optimized prolog environment in a FPL environment would be a cool addition
07:05:50 <Toxaris> scook0: that's a very nice type system, and it's language independent, so it works for C++ and segfaults, too
07:05:57 <hpaste>  dolio pasted "type safe interpreter" at http://hpaste.org/6305
07:07:18 <faxathisia> dolio: awesome!
07:20:55 <Saizan> faxathisia: typing the Y combinator works only because there's no occurs check, right?
07:21:23 <faxathisia> Yes
07:21:33 <faxathisia> It's kind of evil :P
07:22:41 <BMeph> faxathasia: Evil "light," eh? ;p
07:23:38 <faxathisia> hmm?
07:24:34 <smg> wow! hamming problem in haskell is really easy :)
07:26:16 <Lemmih> Saizan: I've put hspread-0.3 on hackage, FYI.
07:28:03 <Saizan> Lemmih: ok
07:42:08 <smg> @src liftM
07:42:08 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
07:45:48 <wli> Depends on what you do with the occurs check.
07:47:00 <roconnor> `` Proponents of languages that still have relatively minute - and therefore relatively close-knit and well-informed user communities - are making the mistake I made: seeing the evident success and enthusiasm of their fellow ``cult members'' as a direct consequence of qualities of their favorite language. They are wrong; if - against all odds - their language should escape into the mainstream the vastly enlarged user community
07:47:02 <roconnor> will get its share of the problems and failures.
07:47:12 <roconnor>  - Bjarne Stroustrup.
07:47:52 <dejones> roconnor: good quote.  interesting that it is from the C++ designer.  ;)
07:48:32 <kosmikus> lUlf
07:48:35 <kosmikus> sorry
07:49:02 <roconnor> dejones: I'm reading http://www.research.att.com/~bs/blast.html, but I could be reading an article about Haskell written in a few years.
07:49:03 <lambdabot> Title: Stroustrup: newsgroup posting
07:49:22 <roconnor> ``Clearly, I thought naively, C++ attracts a much better class of programmers, learning C++ helps people to absorb the key concepts of good programming/design, and the resulting success makes people more tolerant and helpful.
07:49:28 <roconnor> ``I was wrong.
07:49:58 <dejones> Hmm
07:50:28 <dejones> Yea, that could potentially be said of Haskell in the future...
07:50:39 <flux> maybe there could be a programming language that was more like a self-aware organism. at first it would punish from all the smallest mistakes, but when you show advanced concepts it becomes more tolerant of little mistakes :-)
07:50:46 <dejones> roconnor: thanks for the link.  :)
07:51:08 <flux> "nope, you cannot omit those trailing ;'s yet, but maybe after you use some higher order functions there.."
07:51:19 <quicksilver> roconnor: yes, that strikes me was very perceptive and relevant.
07:52:26 <scook0> "avoid success at all costs" indeed
07:53:06 <Toxaris> flux: the cool thing about programming is that you don't have to interact with living organisms. please don't change that. the real-life part of life is hard enough as it is.
07:53:46 <flux> I think that could still be an interesting idea in a brainfuck-kind-of-way, but extremely difficult to pull off
07:54:23 <faxathisia> flux: Lisp macros :D
07:54:51 <flux> faxathisia, hm, good point :)
07:55:09 <flux> although not exactly what I had in mind..
07:55:26 <Toxaris> flux: a possible start could be self-learning layout rules. you provide a corpus of programs using both layout and explicit blocks, and the compiler "learns" your personal flavour of layout rules, so that you can start to omit explicit block syntax
07:56:08 <scook0> exchanging programs would be fun
07:56:12 <quicksilver> It's an amusing idea with some practical shortcomings
07:56:16 <quicksilver> like publishing programs :)
07:56:17 <quicksilver> exactly
07:56:25 <flux> that would be the fun part of it, no?-)
07:56:25 <quicksilver> would be fun to play with though
07:56:35 <flux> "well you just need to train your compiler/interpreter first.."
07:56:52 <flux> not anymore that fancypants copypasting code off the web
07:56:56 <dejones> Toxaris: I agree.  Programming is a nice world where we have to "play by the rules."  ;)
07:57:01 <flux> you need to read, understand and rewrite it :)
07:57:24 <flux> dejones, same thing.. but the rules keep changing!
07:57:26 <roconnor> Toxaris: I've always thought that the AST should be separated from text files, so that people could plug in different style sheets.
07:57:45 <Toxaris> roconnor: that sounds too much like Java for me :)
07:57:51 <flux> or xml :-/
07:57:54 <faxathisia> How is that like Java?
07:58:13 <smg> > p >> q == p >>=
07:58:14 <lambdabot>   parse error on input `}'
07:58:16 <Toxaris> it's like Java editing which is nearly impossible without advanced editor support, folding etc.
07:58:30 <faxathisia> I write java using a plaintext editor
07:58:35 <faxathisia> It's not difficult at all
07:58:38 <smg> > p >> q == p >>= \_ -> q
07:58:38 <lambdabot>  Couldn't match expected type `m a' against inferred type `Expr'
07:58:45 <flux> I suppose you could cheat with the "game" by providing a pre-taught interpreter
07:59:25 <flux> maybe some GA could work here (I have no experience with GA whatsoever): "here's a program that works the way I want, now here's another program that shoud still work, figure it out"
08:00:12 <dejones> flux: good luck coming up with the rules to teach your GA what the "best" outcomes are.  ;)
08:00:51 <flux> dejones, maybe some AST closeness index could be devices
08:00:57 <flux> s/devices/deviced/
08:01:04 <Toxaris> roconnor: but i agree with your goal, I would just not seperate AST & text representation, but use style sheets to convert between text representations of the same AST
08:01:15 <dejones> hmm
08:01:25 <flux> although if it only enforced the compatiblity in the plain AST level it wouldn't be so cool. but it would be a start!
08:01:46 <flux> I don't know how you would write a GA that generated useful parsers though :)
08:01:48 <Toxaris> now with learnable style sheets, we could convert copy&paste to our own style automatically
08:02:23 <smg> someone know in which module is ord and chr?
08:02:27 <Toxaris> Data.Char
08:02:49 <roconnor> Toxaris: sure, style sheets are for both reading and rendering, and hence can be used to convert between layouts.
08:02:56 <Toxaris> hehe I want my compiler to automatically include modules I typically use
08:03:24 <smg> Toxaris: ty
08:03:28 <flux> now that would be a challenging thing to learn :)
08:03:30 <quicksilver> import Toxaris
08:03:47 <roconnor> Toxaris: exactly, the Haskell 98 style sheet would have an hidden import Prelude that could be removed for your own style sheet.
08:03:56 <Toxaris> and some fuziness in name resolution would be interesting. If there are multiple bindings in scope, use the one which yields a type-correct program
08:03:59 <flux> "hm, the code should work after removing this import", I suppose it could learn that it should always include it
08:04:21 <byorgey> Toxaris: hehe, that would be interesting =)
08:05:14 <smg> > let uCase z = [ chr(ord y - 32) | y<-z] in upperCase "foobar"
08:05:15 <lambdabot>   Not in scope: `upperCase'
08:05:19 <smg> > let uCase z = [ chr(ord y - 32) | y<-z] in uCase "foobar"
08:05:20 <lambdabot>  "FOOBAR"
08:05:34 <faxathisia> > let uCase = map toUpper in uCase "foobar"
08:05:36 <lambdabot>  "FOOBAR"
08:06:09 <Toxaris> quicksilver: yeah a possible first step, but I need different Toxaris modules, e.g. for scripts, numeric stuff, #haskell hacking (Arrow, Applicative, Monad, Foldable, ...), and I want the compiler to figure out what I'm up to
08:06:19 <Toxaris> hmm, no, I don't want that, it's just an idea...
08:07:23 <doserj> and "import Toxaris" can't export qualified Data.Map as M, for example...
08:07:43 <Toxaris> > let uCase z = [ chr(ord y - 32) | y<-z] in upperCase "test123\0"
08:07:43 <quicksilver> doserj: yeah, that's an annoying wart.
08:07:44 <lambdabot>   Not in scope: `upperCase'
08:07:46 <Toxaris> > let uCase z = [ chr(ord y - 32) | y<-z] in uCase "test123\0"
08:07:47 <lambdabot>  Exception: Prelude.chr: bad argument
08:07:53 <quicksilver> doserj: that shoudl be fixed.
08:08:36 * doserj nods
08:08:39 <Toxaris> > map toUpper "test123\0"
08:08:40 <lambdabot>  "TEST123\NUL"
08:08:51 <Toxaris> smg: better use unicode-aware library functions :)
08:09:10 <smg> hehe
08:09:16 <smg> but is \0 unicode? :P
08:09:25 <scook0> though toUpper is not exactly a shining beacon of "Unicode-aware"
08:09:30 <smg> hrhr
08:10:38 <Toxaris> scook0: not? too bad. I've read "convert a letter ..." in the docs as "convert characters belonging to the LETTER class"
08:10:43 <roconnor> toUpper needs to take a language parameter.
08:11:01 <roconnor> so that we can have Turkish i's
08:11:01 <dejones> roconnor: this is great --- "I wish I had an electronic equivalent to a little duck-horn, so that a rude BEEP was triggered by every unsupported derogative statement about C++. The noise would be deafening, though. An increasing number of people seem to relish displaying their ignorance and poor manners by snide remarks and gratuitous inaccuracies."
08:11:16 <Toxaris> but I don't understand unicode anyway :)
08:11:23 <scook0> toUpper 'ß'
08:11:37 <Toxaris> > toUpper 'ß' -- yes?
08:11:37 <lambdabot>  Improperly terminated character constant at "'ß'" (column 9)
08:11:40 <roconnor> > toUpper 'ß'
08:11:40 <lambdabot>  Improperly terminated character constant at "'ß'" (column 9)
08:11:52 <scook0> > toUpper '\223'
08:11:53 <lambdabot>  '\223'
08:11:55 <Toxaris> what's that?
08:12:14 <quicksilver> scook0: lambabot doesn't understand UTF8 encoding in IRC messages.
08:12:14 <faxathisia> why can't lambdabot do unicode?
08:12:19 <scook0> toUpper's type is incompatible with true Unicode case-conversion, even in a known locale
08:12:27 <faxathisia> why not fix that?
08:12:27 <faxathisia> :S
08:12:30 <quicksilver> lambdabot can do unicode
08:12:38 <quicksilver> it just doesn't do UTF8 encoding on input/output
08:12:44 <quicksilver> which might feel like the same thing, but it isn't  :P
08:13:09 <quicksilver> historically I suppose the reason was "because tehre is no haskell module to do UTF8 en/decoding"
08:13:15 <quicksilver> now I think the reason is "patches welcome"
08:13:27 <Toxaris> > "ß" -- so what does that mean for \bot?
08:13:28 <lambdabot>  "\223"
08:13:42 <quicksilver> hmm
08:13:49 <quicksilver> actually that looks like I'm wrong?
08:13:50 <scook0> toUpper (head "ß")
08:13:53 <scook0> > toUpper (head "ß")
08:13:54 <lambdabot>  '\223'
08:13:57 <quicksilver> looks like it did parse it.
08:14:07 <Toxaris> maybe there is *some* utf8 decoding somewhere in the toolchain :)
08:14:10 <quicksilver> otherwise it would have been two chars long
08:14:18 <quicksilver> > length "A_"
08:14:19 <lambdabot>  2
08:14:22 <quicksilver> hmm
08:14:24 <quicksilver> copy-paste mangled that
08:14:26 <quicksilver> you do it?
08:14:36 <quicksilver> :t toUpper
08:14:37 <lambdabot> Char -> Char
08:14:49 <quicksilver> Toxaris: why is that type incompatible with case conversion?
08:15:03 <Toxaris> Toxaris: ask scook0
08:15:12 <quicksilver> oops
08:15:16 <Zao> Doesn't lowercase eszet in unicode <5.1 uppercase to SS?
08:15:19 <idnar> > length "ß"
08:15:20 <lambdabot>  1
08:15:22 <quicksilver> scook0: why is that type incompatible with case conversion
08:15:29 <quicksilver> ah, that would be why
08:15:31 <quicksilver> it can be more than one char?
08:15:32 <scook0> yeah
08:15:34 <idnar> I guess it doesn't like utf8 character constants
08:15:49 <Toxaris> Zao: would be a sensible choice, language wise
08:15:51 <quicksilver> interesting.
08:16:01 <scook0> an individual unicode code-point is not a very useful type, in general
08:16:02 <Toxaris> > toUpper 'ä'
08:16:02 <lambdabot>  Improperly terminated character constant at "'ä'" (column 9)
08:16:28 <Toxaris> > (length "ä", head "ä", "ä")
08:16:29 <lambdabot>  (1,'\228',"\228")
08:16:31 <scook0> > toUpper (head "ä")
08:16:31 <lambdabot>  '\196'
08:17:02 <quicksilver> Toxaris: I wonder if that's a GHC (hs-plugins) bug
08:17:23 <quicksilver> scook0: I think that's a bit harsh. I think it's quite a useful type for all kinds of things :)
08:17:31 <quicksilver> scook0: it just may have its limitations.
08:17:46 <quicksilver> scook0: it's great for things like storing the names of all my friends, irrespective of their alphabets.
08:18:25 <scook0> quicksilver: either your friends all have very short names, or you've misunderstood me :)
08:19:05 <scook0> [Char] is useful; Char is not as useful as people with ASCII-trained minds tend to assume
08:19:36 <quicksilver> scook0: oh, I see.
08:19:40 <quicksilver> scook0: yes, that makes sense :)
08:19:41 <MarcWeber> Using HDBC-postgresql print =<< sFetchAllRows' =<< prepare con "SELECT a from test"
08:19:51 <quicksilver> scook0: Char is useful insofar as it is part of [Char] :)
08:19:55 <Toxaris> scook0: but if String is more then a list of Chars, newtype String would be more approbiate, wouldn't it?
08:19:58 <MarcWeber> returns only [] .. Is there antoher prepare function for SELECT queries I've missed?
08:20:04 <scook0> because of things like "ß"->"SS", and combining characters, and such
08:20:29 <Toxaris> scook0: I mean, is it meaningful to process a unicode string "character by character"?
08:21:06 <scook0> in a lot of particular cases yes, but in general no
08:21:49 <scook0> hmm, maybe that's a bit misleading
08:22:24 <Toxaris> so a general interface would need something like chars :: String -> [String]
08:22:39 <Toxaris> which for most cases would be equivalent to (map (:[])), but not all cases
08:23:11 <scook0> did I mention that unicode is hard? :)
08:23:18 <dcoutts_> it's soo hard
08:23:23 <Toxaris> I always wonder why.
08:23:27 <dcoutts_> everything is context dependent
08:23:35 <dcoutts_> because human language is hard
08:24:22 <scook0> unfortunately, I have to go -- have fun
08:24:30 <MarcWeber> dcoutts_: That's a sentence to be quoted :)
08:25:15 <dcoutts_> heh
08:25:33 <quicksilver> Toxaris: the fact that not all written languages use alphabets is part of the hardness
08:25:39 <quicksilver> and not all graphemes are letters, etc
08:26:46 <quicksilver> look up abjad and syllabary in wikipedia to get an outline of the issues.
08:27:14 <DukeDave> So, I want all the functionality of Data.IntMap but where the keys are Data.Word... I've figured out that I can use fromIntegral to convert but is there a smart way to define 'WordMap' without writing a bunch of boilerplate for IntMap ?
08:27:15 <quicksilver> in brief, hebrew, kanji and arabic are different from alphabetic languages in all kinds of ways
08:27:28 <quicksilver> which mess with your defintion of "one Char"
08:32:24 <dcoutts_> DukeDave: not really, you can write wrapper functions for the couple IntMap functions you use
08:32:44 <dcoutts_> DukeDave: so you're going for the IntMap solution rather than the array index solution
08:33:00 <dcoutts_> DukeDave: what is the size of your input and the amount of memory available?
08:33:33 <quicksilver> IIRC, his input was 500MB
08:33:42 <quicksilver> and he had 4G available?
08:34:41 <pastorn> with eg. Word8, what is the notation for writing hex?
08:34:51 <pastorn> 0xFF $FF?
08:35:00 <tibbe> > 0xFF
08:35:01 <lambdabot>  255
08:35:03 <pastorn> or will i have to write 255?
08:35:06 <dcoutts_> > '\xff'
08:35:07 <pastorn> oh, cool
08:35:07 <lambdabot>  '\255'
08:35:16 <resiak> > fromIntegral 0xFF :: Word8
08:35:16 <lambdabot>  255
08:35:32 <dcoutts_> oh sorry, that was a Char
08:35:48 <pastorn> thanks :)
08:35:56 <tibbe> dcoutts: is that unicode code point 255?
08:36:08 <dcoutts_> aye
08:36:11 <tibbe> '\x555'
08:36:14 <tibbe> great
08:36:21 <resiak> > ((toEnum . fromEnum) '\xff') :: Word8
08:36:21 <tibbe> > ;\x555'
08:36:21 <lambdabot>  Parse error at ";\x55..." (column 1)
08:36:21 <lambdabot>  255
08:36:29 <hpaste>  DukeDave pasted "Indexing pos/len & concat of vals" at http://hpaste.org/6306
08:36:34 <tibbe> > '\x555'
08:36:35 <lambdabot>  '\1365'
08:36:43 <tibbe> > '\1365'
08:36:44 <lambdabot>  '\1365'
08:36:54 <tibbe> > length "\1365"
08:36:55 <lambdabot>  1
08:36:56 <DukeDave> dcoutts_: Okay so that's where I am at the moment with the approach you described in you latest Email
08:36:58 <tibbe> great
08:37:26 <DukeDave> So ValPtr holds the offset and length of each value
08:37:40 <DukeDave> Then I was going to have a 'WordMap' from Key to ValPtr
08:37:48 * Toxaris just received it's new PC :)
08:38:29 <dcoutts_> DukeDave: use data ValPtr = ValPtr {-# UNPACK #-} !Word {-# UNPACK #-} !Word
08:38:33 <DukeDave> My hope then is that I can somehow lazily read in the file extracting just the values to a single ByteString
08:38:39 <quicksilver> Toxaris: ITYM "his" or at least "its"
08:39:03 <dcoutts_> DukeDave: that's only 3 words compared to 7 for (Word, Word)
08:39:04 <sclv> might be an absurd idea, but would adding mmap to the problem help?
08:39:09 <quicksilver> you might as well read in the whole file.
08:39:16 <quicksilver> 90% of the file is values anyway
08:39:17 <Toxaris> quicksilver: yes thanks :)
08:39:20 <quicksilver> seems silly to worry about 10% of it :)
08:39:36 <DukeDave> dcoutts_: Now that's what I wanted to hear, I was actually going to ask if that was a good idea earlier having read up on UNPACK
08:40:52 <dcoutts_> DukeDave: yes, don't worry about concatenating just the values, there are bigger savings at smaller costs
08:40:55 <DukeDave> quicksilver: But after we've parsed the Key as a Data.Word it'll be much small right?
08:41:13 <quicksilver> not really.
08:41:17 <dcoutts_> DukeDave: it depends on the ratio of the key to the value size
08:41:18 <quicksilver> 4 bytes is 4 bytes
08:41:29 <quicksilver> well, Data.Word is smaller than bytestring because of the overhead
08:41:31 <quicksilver> so, yes.
08:41:41 <quicksilver> you were right :)
08:41:42 <dcoutts_> DukeDave: and the easier saving is from using an array index and binary search rather than an IntMap
08:43:11 <DukeDave> quicksilver: Yeah, so the string "123456" is going to be 6 Words in size but once it's read to 123456::Word it's just one, right?
08:43:53 <Saizan_> "123456" is 6 Word8 + bytestring description overhead
08:43:54 <DukeDave> dcoutts_: When you say 'Array' we're talking about Data.Array?
08:44:04 <dcoutts_> DukeDave: Data.Array.Unboxed
08:44:06 <dcoutts_> yes
08:44:25 <dcoutts_> DukeDave: do you see what I was suggesting for the index approach?
08:45:07 <dcoutts_> the first approximation is an ordinary Array (Key, ValPtr)
08:45:27 <dcoutts_> so you have a dense array sorted by the Key
08:45:35 <DukeDave> With you
08:45:37 <dcoutts_> and you have to do a binary search to do lookups
08:46:00 <dcoutts_> so the fact that it's dense is what will save us memory
08:46:14 <dcoutts_> however that representation is still too costly, lets refine one step
08:47:19 <dcoutts_> Array Int TheStuff;  and data TheStuff = TheStuff  !Word !Word !Word --and use UNPACKED etc
08:47:46 <dcoutts_> so for each entry that's 1 word for the array and 4 for TheStuff
08:48:05 <dcoutts_> so 5 overall, which is better than the IntMap ValPtr
08:48:23 <quicksilver> DukeDave: ehm, but that's not really what we're talking about.
08:48:23 <dcoutts_> which was 4 for the IntMap node and 3 for the ValPtr
08:48:36 <quicksilver> DukeDave: we're talking about 32 bit numbers represented on disk.
08:48:39 <quicksilver> On disk, they are 4 bytes.
08:48:42 <dcoutts_> however we can still do better!
08:48:49 <quicksilver> as a bytestring they are 4 bytes (but with overhead)
08:48:56 <quicksilver> as a Data.Word they are 4 bytes (but with overhead)
08:49:02 <quicksilver> the representation hasn't changed much
08:49:06 <quicksilver> (endian issues, perhaps)
08:49:11 <quicksilver> it's the overhead that has changed :)
08:49:23 <dcoutts_> instead of a single array of a structure of 3 Words we can use three arrays of Words
08:49:42 <dcoutts_> then it's just 3 words per entry
08:49:58 <dcoutts_> and if we know the lengths are 16 or 8 bit then we save another 2-3 bytes
08:50:10 <dcoutts_> getting us to a minimum of 9 bytes per entry
08:50:15 <mux> when you need to "lift" a type-class constraint into an otherwise polymorphic type (* -> *), is it usual to use GADTs?
08:50:26 <dcoutts_> DukeDave: make sense?
08:52:30 <DukeDave> dcoutts_: Yes, thought I'm not looking forwards to getting a working implementation, the documentation on Array seems a little sparse (excuse the pun)
08:52:55 <dcoutts_> DukeDave: you'd only be using pure arrays, so their api is easy
08:53:03 <dcoutts_> DukeDave: a ! i  to index
08:53:14 <dcoutts_> and use arrayList to construct
08:53:38 <DukeDave> @hoogle arrayList
08:53:41 <lambdabot> No matches found
08:54:05 <dcoutts_> DukeDave: oh listArray, sorry.
08:54:26 <dcoutts_> DukeDave: if you can sort the input file first it'd save doing the sort as your program starts up
08:54:46 <DukeDave> dcoutts_: Heh, just found it too
09:00:58 <dcoutts_> DukeDave: the hardest bit is probably the binary search and that's not really hard
09:02:50 <DukeDave> dcoutts_: Yeah it's mainly the time issue (i.e. Could have bashed this out in C++ in half a day *_*   )
09:03:12 <dcoutts_> DukeDave: what data structure would you have used there
09:03:25 <DukeDave> But it will be useful once it's done as my job is likely to involve lots of big Maps like this
09:03:34 <dcoutts_> if you went for any of the standard ones I think you'd have the same problem with overheads
09:03:56 <georgw> I have a problem with a / that should give me an integer for further integer computations. I don't understand the error:
09:04:07 <georgw> knapsack2.hs:175:18:
09:04:08 <georgw>     No instance for (RealFrac Int)
09:04:08 <georgw>       arising from a use of `floor' at knapsack2.hs:175:18-32
09:04:08 <georgw>     Possible fix: add an instance declaration for (RealFrac Int)
09:04:08 <georgw>     In the first argument of `(*)', namely `floor (thedist)'
09:04:08 <georgw>     In the first argument of `(/)', namely
09:04:10 <DukeDave> dcoutts_: Do you think?
09:04:10 <georgw>         `floor (thedist) * (thedist + 1)'
09:04:12 <georgw>     In the expression: floor (thedist) * (thedist + 1) / 2
09:04:30 <DukeDave> Well, my boss has already written it in C++, so I'll check it out & have a look ;)
09:04:36 <tibbe> geocalc: is thedist an Int, use fromIntegral
09:04:56 <dcoutts_> DukeDave: almost certainly, I don't expect the stl maps would be any more memory efficient, I'd expect you'd need a dense array solution even in C++
09:05:00 <resiak> georgw: if you want integer division, use div
09:05:51 <byorgey> georgw: unlike some other languages, in Haskell the type of / does not change depending on the type of the arguments.
09:05:51 <georgw> resiak: Thanks! :-)
09:05:55 <byorgey> @type (/)
09:05:56 <lambdabot> forall a. (Fractional a) => a -> a -> a
09:06:00 <byorgey> @type div
09:06:01 <lambdabot> forall a. (Integral a) => a -> a -> a
09:06:36 <georgw> so... fromIntegral could be used for conversion, too?
09:06:42 <byorgey> yup
09:07:02 <dons> ?users
09:07:02 <lambdabot> Maximum users seen in #haskell: 463, currently: 443 (95.7%), active: 13 (2.9%)
09:07:04 <byorgey> > (fromIntegral (1 :: Int)) / (fromIntegral (3 :: Int))  :: Double
09:07:05 <lambdabot>  0.3333333333333333
09:07:13 <byorgey> > (1 :: Int) `div` (3 :: Int)
09:07:14 <lambdabot>  0
09:07:49 <byorgey> georgw: the type system forces you to choose which one you want. =)
09:07:57 <byorgey> which is a good thing.
09:08:07 <georgw> I see. Good to know... :-)
09:13:42 <MyCatVerbs> Okay, I'm starting to hate Parsec. x_x
09:13:53 <joe_b> any ghc-savvy people on today?
09:14:28 <faxathisia> MyCatVebs: Impossible!
09:18:46 <twanvl> joe_b: just ask your question
09:19:54 <joe_b> im trying to understand the -u flags passed to gcc by ghc when linking
09:20:39 <joe_b> if you run ghc -v ... ghc passes a list of about 20 symbols to undefine
09:21:02 <joe_b> when compiling only haskell code, this is fine, but im trying to write a library in haskell that can be used by c programmers
09:21:23 <joe_b> i need to avoid these undefines
09:22:30 <joe_b> question is: what do they do?  how can i "pre-undefine" these symbols so that incorporating this library is seamless for the c programmers
09:23:38 <RayNbow> hey twanvl, do you know of any Haskell user groups in NL?
09:24:42 <twanvl> RayNbow: I don't know any
09:25:46 <twanvl> joe_b: why do you want to call a haskell library from C? usually it is the other way around
09:26:33 <joe_b> because i code in haskell and the other members of the team code in c, and they're writing the front end and im writing the backend
09:26:48 * RayNbow doesn't know any either... and from what I see/hear from fellow students, Haskell is not really popular in Delft :p
09:27:14 <RayNbow> it's a shame though... *is deperately trying to convert imperative proggers to become funky :p*
09:30:13 <twanvl> RayNbow: same here (Groningen), there is a functional programming course that uses Haskell, but must students never use Haskell beyond that course.
09:33:27 <MyCatVerbs> faxathisia: it's failing utterly basic usage cases for me.
09:34:03 <MyCatVerbs> faxathisia: for instance, it'd be nice if (many foo) simply returned 0 results if foo failed, rather than just fouling up.
09:34:41 <MyCatVerbs> faxathisia: e.g. parse (many (string "foo")) "foofoofo" -- fails, and is a huge pain in the arse
09:35:01 <Saizan> MyCatVerbs: you want a backtracking parser
09:35:13 <Saizan> MyCatVerbs: use ReadP or polyparse
09:35:33 <faxathisia> > parse (many (try (string "foo"))) [] "foofoofo"
09:35:33 <faxathisia> Right ["foo","foo"]
09:35:34 <lambdabot>   Not in scope: `string'
09:35:39 <Saizan> MyCatVerbs: or add try everywhere :)
09:35:40 <faxathisia> shut up lambdabot
09:36:00 <faxathisia> try everywhere works :D
09:36:01 <MyCatVerbs> Saizan: gah.
09:36:08 <faxathisia> MyCatVerbs: check it out
09:36:54 <MyCatVerbs> faxathisia: that's disgusting and defeats the whole point of using a nice library.
09:37:04 <mrd> no it's a purposeful choice on the part of Parsec
09:37:05 <faxathisia> uh no it doesn't
09:37:11 <mrd> it only backtracks when you use 'try'
09:37:15 <faxathisia> is it so hard to write (try ..)?
09:37:24 <Saizan> MyCatVerbs: no, that's how the library is designed. parsec is LL(1) if you want LL(k) use try
09:37:33 <mrd> if you factor your grammar correctly, you don't need 'try'
09:37:40 <mrd> (well, for most usages)
09:39:06 <MyCatVerbs> faxathisia: yes, it is. It coats everything up to the goddamn walls in masses of boilerplate-ey text and completely ruins the niceness of the syntax. :P
09:39:34 <dcoutts_> MyCatVerbs: try polyparse
09:39:57 <dcoutts_> it has a compositional <|> by default
09:40:41 <dcoutts_> with a optional commit to limit backtracking
09:43:48 <mrd> MyCatVerbs: if you don't understand how to use 'try', you might insert it everywhere, but a few of them go a long way
09:44:27 <Saizan> my "add try everywhere" was a joke
09:46:00 <MyCatVerbs> Saizan: my sense of humour is somewhat bruised since I'm already adding "spaces >>" everywhere.
09:47:54 <mauke> >> spaces is preferred
09:48:26 <conal> isn't parsec limited by the very nature of the Monad interface, which prevents (semi)static optimization?  perhaps an Applicative, non-Monad library would be able to make less harsh elegance/performance trade-offs.
09:48:54 <MyCatVerbs> mauke: oh. Any 'ticular reason? (Less backtracking on try, I'm guessing?)
09:49:29 <twanvl> MyCatVerbs: If it is possible you could use Parsec.Token, it does all the try and space things for you
09:49:40 <georgw> Ok, now I'm running into problems beyond syntax... ;-) I solve a random local search knapsack optimization problem. From a starting point, I select 10 new points, evaluate which is best, and continue with that one. Repeat 100000 times. Pretty simple in an imperative language. Somehow I run into trouble in Haskell, the program is eating all my memory... So the question is: How do I do this without wasting a lot of memory? Am I doing it wrong?  putStr
09:49:40 <georgw> Ln $ "Folding solution: "
09:49:40 <georgw>                ++ show (foldl stepper (SackState initsack initItems initItems initvalues) (dsetgenerator thelist thedist manyrandoms capacity)
09:49:53 <MyCatVerbs> @pl \p -> (p >>= \r -> spaces >> return r)
09:49:53 <lambdabot> ((spaces >>) . return =<<)
09:49:54 <mauke> MyCatVerbs: I think so
09:50:07 <mauke> MyCatVerbs: p <* spaces
09:50:11 <georgw> stepper :: SackState -> Dataset -> SackState
09:50:15 <Cale> georgw: foldl tends to construct very large expressions
09:50:17 <mauke> @index (<*)
09:50:18 <lambdabot> bzzt
09:50:32 <Cale> georgw: You might try switching to foldl'
09:50:54 <georgw> Cale: That's it?
09:50:57 <Cale> georgw: and depending on the exact type of thing you're folding the list into, possibly making that data structure stricter
09:51:25 <Cale> georgw: Possibly. Let me show an example
09:51:45 <Cale> Suppose we have something like foldl (+) 0 [1,2,3]
09:51:50 <Cale> This is evaluated like:
09:51:54 <Cale> foldl (+) 0 [1,2,3]
09:52:00 <Cale> foldl (+) (0+1) [2,3]
09:52:07 <Cale> foldl (+) ((0+1)+2) [3]
09:52:13 <Cale> foldl (+) (((0+1)+2)+3) []
09:52:18 <Cale> ((0+1)+2)+3
09:52:22 <Cale> (1+2)+3
09:52:24 <Cale> 3+3
09:52:26 <Cale> 6
09:52:31 <georgw> I see, so it unrolls first and computes then.
09:52:57 <jacobian> I like to think of it as replacing the "spine" with an operation.
09:53:02 <Cale> Now, if that list is lazily constructed, the memory costs for it won't have been paid yet. Effectively, you'll be paying for the memory when that expression is getting built.
09:53:12 <Cale> jacobian: Well, that's what foldr does
09:53:32 <Cale> foldl does a little more than just replacing the spine, it also flips things around a bit
09:53:38 <mauke> > foldl (+) 0 [1,2,3] :: Expr
09:53:38 <lambdabot>  0 + 1 + 2 + 3
09:53:56 <Cale> http://cale.yi.org/index.php/Fold_Diagrams -- you can see some diagrams of what the various folds do here
09:54:01 <lambdabot> Title: Fold Diagrams - CaleWiki
09:54:32 <mauke> > scanl f z [1,2,3,4,5]
09:54:33 <lambdabot>  [z,f z 1,f (f z 1) 2,f (f (f z 1) 2) 3,f (f (f (f z 1) 2) 3) 4,f (f (f (f (f...
09:54:45 <Cale> georgw: Note that foldl is still tail recursive, and is implemented with a nice loop, it's just that the loop typically does nothing more than build a large expression.
09:55:24 <Cale> georgw: Another option, potentially, is to make sure that you compile with optimisations. GHC is pretty good at detecting cases where laziness isn't doing any good and strictifying them.
09:55:26 <jacobian> wow those are great cale
09:55:26 <georgw> Cale: I see...
09:56:05 <georgw> Is fold generally a good idea or is it wiser to implement this differently?
09:56:14 <Cale> It's generally a good idea.
09:56:31 <Cale> What type is the result of the fold here?
09:56:36 <georgw> I still haven't figured out the best way of doing stuff efficiently that is easily done with loops with destructive update.
09:56:41 <quicksilver> "< mrd> if you factor your grammar correctly, you don't need 'try'"
09:56:46 <quicksilver> mrd: but I don't want to factor the grammar.
09:56:49 <quicksilver> That's mechanical.
09:56:55 <quicksilver> Why should I do something a computer can do better?
09:57:01 <mrd> then use 'try'
09:57:08 <mrd> and don't complain that it's slower
09:57:16 <georgw> Cale: I'm slinging around something called "SackState" which contains the current best knapsack and some statusdata.
09:57:31 <quicksilver> mrd: I don't even want to use try, though.
09:57:32 <Cale> georgw: Can I see the data declaration?
09:57:38 <georgw> data SackState = SackState {sackbest::Knapsack, sItems::[Bool], pivotItems::[Bool], svalues::[Int]} deriving Show
09:57:39 <mrd> then use polyparse
09:57:40 <quicksilver> mrd: I just want to write down my grammar.
09:57:45 <quicksilver> and have the parser parse it :)
09:57:48 <quicksilver> yes, quite.
09:57:51 <quicksilver> but that's the point ;)
09:57:56 <quicksilver> in my opinion.
09:58:19 <Saizan> polyparse is probably still slower
09:58:24 <mrd> indeed
09:58:33 <malcolmw> slower than what?
09:58:48 <mrd> a tortoise on a bad day
09:58:51 <Saizan> malcolmw: refactored grammar with parsec
09:58:58 <quicksilver> I wrote a pseudo-combinator parser in lua once
09:59:01 <Cale> georgw: ah, okay, this might be slightly tricky, in that depending on how things go, by switching to foldl' you might just move the complicated expressions inside the data structure
09:59:13 <quicksilver> it did left factoring automatically, and build 1 token lookahed tables automatically.
09:59:16 <malcolmw> Saizan: the lazy polyparse is 3-5x faster than parsec
09:59:31 <Cale> georgw: But that really depends on how exactly it's getting built up.
09:59:33 <malcolmw> Saizan: for some use cases, anyway
09:59:41 <georgw> Cale: There must be some much better way than what I am doing, right? Seems I'm pushing around a lot of data just to track state.
10:01:10 <Cale> georgw: Well, possibly...
10:01:51 <Saizan> malcolmw: oh, we're comparing a use case where you would need try in parsec, but implemented in polypoarse, against a version of that grammar rewritten to be LL(1) and implemented in parsec, so it's not very fair,, is polyparse supposed to be faster even in this case?
10:02:08 <Cale> georgw: Try foldl' in place of foldl and see if you still get the memory consumption, and make sure optimisations are turned on with -O2
10:03:00 <malcolmw> Saizan: well, if you refactor to be LL(1) for the polyparse version too, then yes, it should still be faster
10:03:43 <Cale> georgw: Basically, learning to do things efficiently in Haskell takes some getting used to, since evaluation is outermost-first rather than innermost-first, and you have to picture how expressions are geting built up.
10:03:51 <malcolmw> Saizan: comparing algorithms of different complexity classes is not usually very enlightening
10:04:02 <Cale> georgw: There are various tools for controlling the evaluation order though.
10:04:41 <Cale> Either by using stricter datastructures, or by explicitly adding strictness annotations to cause expressions to be evaluated earlier.
10:04:51 <Cale> (or using stricter operations, like foldl')
10:04:52 <Saizan> malcolmw: right, that's why i said it would probably be slower
10:05:15 <malcolmw> Saizan: right, yes, got it now
10:06:01 <ivan__> hi, is lists bind (>>=) defined as a >>= b = concatMap(b) a ????
10:06:34 <Cale> ivan__: yep
10:06:45 <Cale> > [1,2,3] >>= \x -> [x, x+10]
10:06:46 <faxathisia> (>>=) = flip concatMap
10:06:49 <lambdabot>  [1,11,2,12,3,13]
10:07:14 <Cale> > [1,2,3] >>= \x -> [x, x+10] >>= \y -> [x, x+y]
10:07:15 <lambdabot>  [1,2,1,12,2,4,2,14,3,6,3,16]
10:07:42 <ivan__> > 5+5
10:07:43 <lambdabot>  10
10:07:50 <ivan__> thx
10:07:55 <ivan__> :i flip
10:08:00 <Cale> :t flip
10:08:02 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
10:08:42 <Cale> Heh, flip :: (Functor f, Functor g) => f (g a) -> g (f a)
10:08:51 <Cale> (not quite :)
10:08:55 <georgw> Cale: foldl' and O2 (strangely the compiler said "compilation IS NOT required") didn't help. :-|
10:09:03 <Cale> georgw: okay
10:09:28 <Cale> georgw: Let's look a bit closer at your program. Could you put it on hpaste?
10:09:31 <Cale> @paste
10:09:31 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:09:57 <desegnis> georgw: Delete old *.o files, otherwise they won't be rebuilt
10:10:08 <Cale> Oh, that is a good point.
10:10:16 <Cale> try that first :)
10:10:27 <hpaste>  Georg pasted "Knapsack" at http://hpaste.org/6307
10:10:42 <quicksilver> -fforce-recomp
10:10:46 <Saizan> or -fforce-recomp
10:10:49 <quicksilver> is one alternative to deleting old o files
10:10:57 <georgw> Kinda ugly though that code.
10:11:14 <georgw> I'll take out the cruft if it helps for diagnosis.
10:12:22 <Cale> Just a note, usually the 'then' and 'else' should be lined up.
10:12:53 <georgw> Cale: Ah, yes, of course. Thanks.
10:13:07 <Cale> oh, it appears that your file got cut off
10:13:21 <Cale> (silly hpaste length restrictions)
10:14:05 <Cale> Who is presently in charge of hpaste? Is it glguy?
10:14:24 <Cale> It should at least warn you when it does that :)
10:14:48 <Cale> georgw: You could just add an annotation with the rest, possibly :)
10:15:10 <hpaste>  Georg pasted "knapsack2" at http://hpaste.org/6308
10:15:17 <Cale> georgw: See what happens when you force recompilation.
10:15:51 <georgw> Cale: yeah, no change after recompilation.
10:16:34 <Cale> oh, uh, what should I use as input?
10:17:27 <georgw> http://www.tik.ee.ethz.ch/sop/education/lectures/BOD/exercises/project1/instances/project1_task2b.dat
10:17:34 <lambdabot> http://tinyurl.com/2xm4tu
10:18:25 <Eelis> what is one supposed to do if one reports a library bug on libraries@haskell.org, including testcase and patch, and nobody seems to notice the post?
10:18:33 <georgw> I should run it at randiters = 100000. Eats up 800M of memory before I kill it.
10:19:43 <mux> @seen dons
10:19:43 <lambdabot> dons is in #xmonad, #haskell-soc and #haskell. I last heard dons speak 1h 12m 41s ago.
10:19:50 <mux> dons: still around?
10:22:23 <Cale> ah
10:22:38 <byorgey> Cale: I think glguy is developing a new and improved hpaste
10:22:47 <quicksilver> he is.
10:22:47 <Cale> I don't know about the heap yet, but a lot of allocation is being done in myRNG
10:23:02 <mux> mm, does GHC export some API that I can use to find the user directory, as in the one used when building with cabal and --user
10:23:12 <georgw> Cale: Doesn't laziness take care of that?
10:23:17 <quicksilver> Eelis: bug someone with commit access to apply the patch :)
10:23:30 <quicksilver> Eelis: I find dons is quite keen on bug fixes at the moment.
10:24:19 <Cale> georgw: hmm
10:24:26 <RobHu> Does anyone have any idea how long GHC 6.8 takes to compile on a C2D@2.4Ghz running OS X? It's been compiling for about 45 minutes now.
10:24:58 <Spockz> seems long to me
10:25:03 <Cale> georgw: Try this: compile with -prof -auto-all, and then run the program as you normally would, but with additional commandline parameters +RTS -p -hc -RTS
10:25:11 <RobHu> hmm
10:25:26 <dons> mux?
10:25:26 <lambdabot> dons: You have 5 new messages. '/msg lambdabot @messages' to read them.
10:26:03 <georgw> currently at 600M memory usage.
10:26:09 <mux> dons: I've been having a problem with runplugs from darcs lambdabot, and found a workaround that looks quite odd to me
10:26:13 <Cale> You'll get a .prof file which will tell you where the time and allocations are being spent, as well as a .hp file with heap profiling data. You can run hp2ps on that to get a nice postscript graph which shows how memory was distributed over the life of the program.
10:26:18 <mux> dons: one of the messages you have is about this
10:26:20 <RobHu> How do I install Quickcheck and Lazycheck? I'm going to a talk tonight with them in, but I've never installed a Haskell library before.
10:26:36 <georgw> Cale: Ahh, that's cool.
10:26:39 <dons> RobHu: follow the instructions for 'how to build a library' on hackage.haskell.org
10:27:09 <mux> dons: more specifically, runplugs was failing at runtime with linker errors suggesting that the -package flags were not passed appropriately
10:27:12 <georgw> Cale: Stack space overflow: current size 8388608 bytes.
10:27:13 <Cale> georgw: With -hc, that graph will be broken down by cost centre. There are a number of other modes as well.
10:27:20 <Cale> georgw: yeah, I hit that too
10:27:22 <dons> mux, ok.
10:27:40 <mux> dons: there is a -package numbers missing for real, but even with that one added, I ended up with the same errors
10:28:31 <mux> dons: so I completely removed the -package flags, and gave the full path "/usr/home/mux/.ghc/i386-freebsd-6.8.2/package.conf" to my package.conf file, and it now works
10:28:46 <dons> mm
10:29:10 <mux> I have no idea why it works though I removed the -package flags, and I have no idea if it should be needed to give the user package.conf there, but it owrks
10:29:17 <RobHu> dons: Thank you
10:29:20 <byorgey> morning dons!  sleep well?  ;)
10:29:28 <georgw> Trying to run with fewer elements now...
10:29:33 <edwinb> Hmm, the .cabal format seems to have changed. Maybe I shouldn't have stopped paying attention for a few months.
10:30:04 <dons> byorgey?
10:30:07 <mux> dons: when I say I pass the path to my package.conf file, I mean as a parameter to unsafeEval_, of course
10:30:20 <dons> i guess i did sleep well, thanks for asking!
10:30:29 <Stwange> how can I prove that a language is recursively enumerable, short of designing a turing machine to accept it?
10:30:39 <byorgey> dons: oh, I just recall you saying last night "must get sleep"... or something like that
10:30:53 <dons> byorgey: did you send patches to xmonad@ yesterday? i've not seen them on the list yet.
10:30:57 <Cale> georgw: Okay, so cost-centre heap profiling says that myRNG is creating most of the items on the heap, and that stepper is holding on to most of them.
10:31:08 <byorgey> dons: hm, strange.  I did send them.
10:31:15 <dons> have you seen them ?
10:31:35 <georgw> Cale: That's sweet. Extremely nice tool.
10:31:50 <georgw> Cale: Just looking at the graph now...
10:31:53 <byorgey> dons: well, I don't get copies back of messages I send to the list, so I don't know.
10:31:57 <dons> hmm
10:31:59 <Cale> georgw: er, the second fact was because of retainer profiling
10:32:03 * byorgey checks the mailman archive
10:32:04 <Cale> that's -hr
10:32:45 <georgw> Cale: So I have to look at the random stuff it seems. Any general hint on how to better thread in the randoms?
10:32:50 <byorgey> dons: http://www.haskell.org/pipermail/xmonad/2008-March/005051.html
10:32:51 <lambdabot> Title: [xmonad] runLayout changes!
10:33:00 <byorgey> dons: that's odd
10:33:00 <Cale> georgw: I think what's happening is that lots of stuff is ending up in these lists which aren't being forced to evaluate.
10:33:14 <byorgey> dons: I'm not sure what that means.  did it filter my message or something?
10:33:19 <dons> hmm
10:33:26 <byorgey> I typed a bunch of text in the email but none of it is there
10:33:31 <Cale> georgw: hmm
10:36:13 <byorgey> dons: should I try sending it again?
10:36:23 <quicksilver> it didn't like your MIME formatting.
10:36:29 <quicksilver> it didn't like "multipart/alternative"
10:36:32 <quicksilver> which is a bit stupid
10:36:35 <quicksilver> I can't think why it wouldn't
10:36:40 <quicksilver> (doesn't mean it didn't go out to the list, though)
10:36:50 <byorgey> well, it's gmail's MIME formatting...
10:36:59 <byorgey> I've sent patches to the list this way before
10:37:13 <byorgey> although maybe I've never sent more than one at a time... ?
10:37:54 <Cale> georgw: If you'll wait until later tonight, I'll be happy to help more extensively, but I really need to study for an econ quiz.
10:38:39 <Cale> georgw: In the meantime, I think the problem is that these Knapsack values are building up expressions in their fields rather than real lists and Ints
10:38:57 <Cale> georgw: For the Ints, it's easy to fix by adding a ! in front of the type in the data declaration.
10:39:07 <Cale> georgw: For the lists, it might be more subtle.
10:40:08 <georgw> Cale: Well, thank you very much for the extensive help! I won't be online later tonight, but maybe I'll catch you tomorrow or the day after then. I'll try if cleaning things up a bit will help.
10:40:14 <Cale> okay
10:40:33 <georgw> What does the ! do?
10:41:03 <Cale> It means that when the Knapsack itself is pattern matched against, those fields will be evaluated first, regardless of whether they'd otherwise need to be.
10:41:35 <Stwange> when doing a turing reduction, can the function be vague? Eg. f: (Mi, x) where x is a member of the language accepted by Mi?
10:41:41 <Cale> They're just evaluated up to determining the top-level constructor. In the case of an Int, that means full evaluation, but in the case of a list, it just means enough to say if it's empty or not.
10:42:21 <Cale> georgw: At some level, the only thing which causes evaluation to occur is case expressions doing pattern matches on data.
10:42:37 <byorgey> Stwange: I'm not sure what you are asking.  Can you be a bit more specific?
10:42:44 <georgw> Cale: ok, I see.
10:43:21 <georgw> Cale: Well, thanks again and much success with that econ quiz!
10:43:35 <Cale> georgw: Thanks! One thing which might be worth attempting is replacing various lists with Data.Sequence values.
10:44:14 <Cale> georgw: Lists are good when you expect to just linearly iterate over them (which is common and that's why they're popular)
10:44:14 <Stwange> byorgey, I need to prove that all recursively enumerable languages can be reduced to the universal language ( { (M, w) | M accepts w }) - I'm not asking for the answer, but if I could write a function for it eg. f: (machine, string) such that the string is accepted by the machine, I know how to do it... but otherwise I'm not sure how to write a general function that will provide something the TM will accept
10:44:24 <Cale> georgw: But they're bad for just about everything else.
10:45:09 <georgw> Cale: ah, ok. I'll look at that.
10:45:41 <Cale> georgw: An effective mnemonic is that you use lists in Haskell the same way you'd use loop counters in an imperative language.
10:46:22 <mrd> Stwange: if you had a machine A_{TM} (as that one is often called), use it to simulate a Turing machine
10:46:39 <Cale> But when you're manipulating sequences of data, pulling items out randomly and such, they're terrible, since they have O(n) access time to the nth element, and the laziness tends not to be so useful in those cases.
10:46:44 <georgw> Cale: ok, so I would use it for the "outer loop" but not to store the state of the knapsack (which was [Bool]).
10:46:49 <Cale> yeah
10:47:07 <quicksilver> unless they have less that, say, 5 items
10:47:16 <quicksilver> (to be honest, less than 100 items is fine in many cases)
10:47:20 <Cale> Data.Sequence is a fast strict sequence type. You also already know about arrays.
10:47:36 <quicksilver> "spine-strict"
10:47:39 <quicksilver> just to be pedantic :)
10:48:09 <Stwange> byorgey, I know how to prove that if L2 is r.e. and L1 <= L2 then L1 is r.e, but I don't know how to prove that all L1 (where L1 is r.e) <= A_{TM}
10:48:41 <Cale> Right, the elements are still lazy :)
10:51:04 <ivan__> is there any list transform monad?
10:51:12 <Gilly> does there exist a builtin function like startswith "Hello" string returning True iff. string begins with "Hello"?
10:51:13 * byorgey is amused by Cale's inability to stop being helpful
10:51:17 <mrd> Stwange: what can happen when you use a Turing Machine to decide a r.e. language?
10:51:35 <byorgey> Gilly: yes, isPrefixOf
10:51:42 <Gilly> ah, thanks :)
10:51:43 <byorgey> Gilly: in Data.List
10:51:51 <Gilly> ok, great
10:52:05 <Stwange> mrd, if the string is a member of the language, it will accept and halt, otherwise it will either reject and halt or loop indefinitely
10:52:10 <mrd> right
10:52:22 <Cale> byorgey: hehe
10:52:22 <byorgey> ivan__: you mean ListT ?  It exists somewhere on the wiki, although IIRC there are various subtle issues with it...
10:52:34 <mrd> so, using A_{TM}, can you simulate a Turing Machine M that accepts an r.e. language L?
10:53:01 <mux> dons: any thoughts on that runplug issue?
10:54:14 <ivan__> byorgey: thx
10:56:10 <Stwange> I'm not sure mrd, I mean I could pass it a specific machine and a string that machine accepts, but what's the point?
10:56:31 <mrd> yes, you could find out if it accepts some <M,w>
10:56:41 <mrd> and what do you do if A_{TM} says that M rejects w?
10:57:03 <Stwange> just reject?
10:57:09 <Stwange> but what if it looks indefinitely?
10:57:12 <Stwange> *loops
10:57:20 <mrd> which machine loops?
10:57:31 <byorgey> ivan__: http://haskell.org/haskellwiki/ListT_done_right , http://haskell.org/haskellwiki/ListT_done_right_alternative
10:57:31 <lambdabot> Title: ListT done right - HaskellWiki
10:57:45 <Stwange> M
10:57:55 <mrd> right, so how would you simulate that?
10:58:02 <olsner> @seen oerjan
10:58:02 <lambdabot> I saw oerjan leaving #haskell 6h 15s ago, and .
10:58:09 <Stwange> why would I want to simulate an infinite loop?
10:58:28 <olsner> because you have too much time to spare?
10:58:29 <mrd> because you are imitating the behavior of a Turing machine on some r.e. language
10:59:11 <Stwange> I could similate an infinite loop by passing the string back into m, but what would be the point? The machine would loop anyway
11:01:06 <Stwange> and by passing it back in, wouldn't I just be making the recursive subset of RE languages not recursive?
11:01:29 <mrd> M would halt, then
11:05:21 <Stwange> so just by putting M in, I'm simulating M
11:07:21 <Stwange> sorry if I'm slow on the uptake mrd, I've been staring at this greek for ten hours now :)
11:08:55 <mrd> well, do you see that A_{TM} can decide anything that a Turing Machine can decide, or even when a T.M. would loop?
11:09:30 <Stwange> no... I thought the halting problem was not decidable?
11:09:52 <mrd> and the language A_{TM} accepts is not decidable either
11:11:48 <mrd> you see that A_{TM} and the halting problem are basically the same thing, right?
11:14:10 <Baughn> The general halting problem isn't decidable. This doesn't stop us from deciding some, possibly even many of its cases
11:14:29 <Baughn> The actual proof does use a somewhat contrived program, after all
11:14:35 <mrd> i prefer the term semi-decidable actually
11:14:42 <mrd> it's more descriptive than r.e.
11:14:48 <mrd> (at least, to a non-mathematician)
11:15:49 <laz0r> hi #haskell, are there any image-manipulation related modules available for haskell?
11:15:50 <dons> Cale: here's a challenge, http://tourdelisp.blogspot.com/2008/03/farewell-haskell.html
11:15:50 <lambdabot> Title: Tour de Lisp: Farewell Haskell
11:15:57 <Stwange> but I thought the A_{TM} was RE, just not recursive?
11:15:59 <dons> lambdabot: sure. check hackage.haskell.org
11:16:06 <dons> laz0r: ^^
11:16:15 <mrd> Stwange: hmm?
11:16:38 <Stwange> so if the A_{TM} is recursively enumerable, it must be decidable?
11:16:39 <laz0r> dons, ok, i will have a look
11:16:40 <Baughn> Come to think of it, the proof only states that for every halting-problem decider, there is at least /one/ program that it can't decide on
11:16:50 <Stwange> oh wait... recursive is decidable isn't it, not RE
11:16:51 <mrd> recursively enumerable = semi decidable
11:17:15 <faxathisia> yes but when you try to write a program that decides whether or not another program halts it really is a difficult problem
11:17:28 <Baughn> No question of /that/, no
11:18:07 <Baughn> It's just, I wouldn't call the current proof /useful/ in most senses. It still makes sense to try building one.
11:19:37 <Stwange> so, if L1 is recursively enumerable, and I need to show it reduces to A_{TM}, I just need to come up with some function that takes M1 and pairs it with some string it accepts... do I need to simulate halting?
11:19:45 <RayNbow> <dons> Cale: here's a challenge, http://tourdelisp.blogspot.com/2008/03/farewell-haskell.html <-- lol, that was fast :p
11:19:45 <lambdabot> Title: Tour de Lisp: Farewell Haskell
11:21:04 <faxathisia> "2nd I didn't learned anything new" haha
11:22:15 <noteventime> faxathisia: A deeply epistemological statement :p
11:22:31 <dons> RayNbow: ?
11:22:44 <olsner> who's tourdelisp?
11:22:58 <lament> farewell haskell!
11:23:16 <faxathisia> seems to be a blog wiht someone complaining that <arbritrary language> is not <favorite language>
11:23:30 <dons> where favorite language is lisp
11:23:40 <dons> is this a live case of lisp blub?
11:23:49 <olsner> ah! I see "a modest proposal" has resurfaced on reddit
11:24:16 <faxathisia> dons: they also seem to be interested in Qi so I think all is lost for them
11:24:22 <lament> "Farewell Haskell, you're joining the company of languages that didn't taught me much about programming"
11:24:30 <noteventime> I did the opposite :) I started learning lisp and couldn't quite cope with dynamic typing
11:24:38 <RayNbow> dons: well, how long has that guy of Tour de Lisp been using Haskell?
11:24:50 <dons> so as i say here, i kind of missed about a dozen points, http://reddit.com/r/programming/info/6btaq/comments/c03fcz3
11:24:50 <lament> noteventime: lisp does have type declarations that help
11:24:51 <mrd> Stwange: do you see that A_{TM} <= H_{TM} and H_{TM} <= A_{TM} ?
11:25:03 <noteventime> lament: I found it to be rather cumbersome though
11:25:34 <noteventime> lament: It didn't fit naturally into the language, felt like something someone tucked on for performance
11:25:36 <lament> noteventime: I found Lisp to be rather cumbersome. The declaration system fits right in.
11:25:38 <faxathisia> never found type declarations useful except for optimization
11:25:44 <Stwange> H_{TM} is the halting machine?
11:25:48 <mrd> yea
11:25:56 <lament> noteventime: I dunno, it seems fit about as naturally as everything else there
11:26:02 <mrd> A is "acceptance" and H is "halting"
11:26:26 <lament> noteventime: and I really wouldn't mind having it in Python
11:26:31 <RayNbow> dons, those dozen points... are a lot :p
11:26:45 <noteventime> lament: I found macros to be really neat, though  monads seem to solve some of the problems macros solved
11:26:48 * RayNbow is still learning/has to learn several of those :p
11:27:04 <Stwange> what about TMs that loop forever?
11:27:15 <cafr> anyone bumped into the "type synonyms must be fully applied" restriction? i'm trying to get around it.
11:27:16 <noteventime> lament: I'd prefer static typing by default and dynamic typing as an extra :)
11:27:21 <mrd> Stwange: what about them?
11:27:25 <lament> noteventime: yes, i agree
11:27:49 <faxathisia> I prefer having multiple tools ..
11:28:10 <Stwange> I guess they have nothing to do with A_{TM} and H_{TM}? Because H_{TM} are recursive?
11:28:20 <mrd> Stwange: no, they are not recursive at all
11:28:38 <lament> noteventime: there's something wrong with lisp macros. Every non-trivial macro definition i've seen is really ugly.
11:28:40 <Stwange> do they halt, or is it checking if they halt?
11:28:55 <dons> gwern: did you check to see if hs-plugins actually built from the tarball you created?
11:28:57 <faxathisia> lament: sigh..
11:29:00 <RayNbow> Stwange is doing some Theory of Computation course? :)
11:29:09 <mrd> Stwange: you're working this wrong.  A <= B iff _given_ an oracle for B you could decide A.
11:29:10 <dons> it doesn't -- you should check with the author at least to test the .tar.gz :(
11:29:17 <noteventime> lament:  I thought the same about a lot of Haskell code before I got used to it :)
11:29:25 <Stwange> RayNbow, yeah and I hate it :(
11:29:51 <lament> noteventime: oh, sure, but even lisp gurus admit things get pretty hairy pretty fast with macros
11:30:05 <Stwange> ok and accepting turing machines always halt, so that would be a simple mapping to H_{TM}
11:30:05 <Maddas> lament: Is this any different with TH?
11:30:07 <mrd> Stwange: so I ask you, show that A_{TM} <= H_{TM}
11:30:09 <Maddas> (I don't know)
11:30:21 <lament> Maddas: i don't know, haven't looked at TH
11:30:34 <mrd> given an oracle which solves H_{TM}, build a machine to decide A_{TM}
11:30:55 <mrd> (this is Turing-reducibility btw)
11:31:25 <lament> this Qi thing seems kinda neat :D
11:31:43 <dmead> does anyone know if the GRE practice test that ETS posts is complete bullshit or an actual test?
11:31:49 <RayNbow> reducibility (<=) is kind of confusing for a lot of students in the beginning
11:32:13 <jacobian_> dmead: For physics it is basically identical
11:32:23 <jacobian_> dunno about CS as I never took it
11:32:26 <RayNbow> A <= B basically means that A is not necessarily more difficult than B
11:32:28 <dmead> i'm doing the comp sci one, and i found an error
11:32:30 <dmead> on their test
11:32:38 <dmead> so i'm wondering if it's all bullshit
11:32:46 <mrd> you know, i thought i did too, but i forgot to check up on it
11:32:50 <tmfe> quit
11:33:07 <Stwange> ok, so say a machine halts (that's what H_{TM} means?), then it's just a simple case of accepting if it accepted, and rejecting if it didn't to do an accepting TM, no? Doesn't that mean H_{TM} and A_{TM} are equivalent?
11:33:24 <mrd> H_{TM} = { <M,w> | M halts on input w }
11:34:09 <mrd> yes, so that way is easier
11:34:22 <mrd> the H_{TM} <= A_{TM} requires a bit more thinking
11:34:28 <Stwange> and A_{TM} = { <M, w> | w is a member of L(M) }?
11:35:04 <mrd> M accepts w, so yes
11:35:15 <Stwange> but H_{TM} isn't the same as recursively enumerable is it? Aren't the recursive ones the ones that always halt?
11:35:28 <mrd> H_{TM} is a language, not a class
11:36:51 <ivan__> where can i read about why the monad laws have to yeild for the monad to work?
11:39:24 <Baughn> ivan__: Why they have to work? Have you considered how a monad in which they didn't would act?
11:40:17 <cafr> i recall an excellent motivation of the monad laws by albert lai on haskell-cafe not too long ago
11:40:40 <Stwange> So given an oracle for an A_{TM}, I should be able to decide H_{TM}?
11:41:32 <Stwange> well if the A_{TM} has accepted or rejected, this would be an accept on the H_{TM} because it had halted?
11:41:41 <Stwange> I'm not sure where I'd get the reject from though
11:42:11 <mrd> if A_{TM} accepts <M,w> that means M halts and accepts w
11:42:23 <Gilly> Hm, I'm trying to use Takusen to store some binary data in Sqlite but it seems to get annoyed of 0x00s in the binds... Any ideas?
11:42:27 <mrd> if A_{TM} rejects <M,w> that means either M halts and rejects w, or M does not halt on w.
11:42:59 <Stwange> but would A_{TM} reject if it didn't halt? Would it not just carry on forever?
11:43:18 <mrd> no, you have an oracle for A_{TM}.  oracles don't loop forever.
11:43:48 <Stwange> I thought an oracle was just a turing machine, even if it was a theoretical one?
11:44:07 <mrd> it's a Turing Machine which always halts
11:44:09 <Baughn> Stwange: It does things that turing machines provably can't. I'd say not.
11:44:19 <mrd> ie. a magic fairy box
11:44:29 <ndm> hmm, how would you go about proving that let v = x in y => y[v/x] terminates?
11:44:33 <mrd> remember you're proving an implication.  assumptions -> consequence
11:44:44 <ndm> i.e. if you apply that rule as long as possible, then it terminates
11:45:02 <mrd> well that's kinda tough in most languages, since the term can get bigger
11:45:17 <ndm> yeah, i know :)
11:45:48 <ndm> but i'm reasonably sure it _is_ terminating, given a finite expression
11:45:50 <mrd> i know you know :P how's the supercompiler
11:46:02 <ndm> not looked at it in ages
11:46:07 <ndm> this is for something entirely different
11:46:25 <mrd> which language? that's not guaranteed to terminate in Haskell
11:46:41 <ndm> assume let /= letrec
11:46:54 <ndm> i.e. x may not refer to v
11:47:05 <mrd> well even in say, scheme it's not
11:47:23 <ndm> even with non-recursive lets?
11:47:41 <ptolomy2> Anybody aware of an existing bytestring trie implementation?
11:48:00 <mrd> ndm: wait, are you talking about reducing that whole term to normal form, or just the substitution step?
11:48:28 <ndm> mrd, i mean applying that substitution step anywhere within an expression as often as you want, in any order you choose
11:48:59 <mrd> depends on the language -- in some it could occur forever
11:49:02 <ndm> i.e. if we had a rewriting system, and i gave you that rule, is there an input expression on which you can apply the rule as often as you want
11:49:03 <Stwange> sorry if I'm being dumb mrd, but I'm still not sure how this is related to all RE languages reducing to A_{TM}... I see how it's similar but that's all
11:49:30 <ndm> mrd: given a language with non-recursive lets, and finite input expressions, could it occur?
11:49:47 <mrd> ok I guess yuo're not counting something like: let v = (\x . xx) (\x . xx) in v?
11:50:09 <ndm> mrd, you can't do lambda expansion or anything, just that one single rule
11:53:14 <mrd> i don't know offhand
11:53:21 <mrd> sounds awfully limited
11:53:40 <ndm> mrd, think a program transformation situation, not an evaluation function
11:57:00 <ndm> mrd, interesting example however, i think that shows up a flaw in some of my reasoning elsewhere - will have a think, many thanks
11:57:58 <mrd> maybe it can be done by induction on the number of lets
11:58:00 <mrd> hmm
11:58:06 <mrd> no tht wouldn't work
11:58:13 <ndm> i was thinking the number and position
11:58:22 <ndm> i.e. weight let's more the higher up they are
11:58:28 <ndm> but still a tricky problem
12:00:31 <jacobian_> <ndm> hmm, how would you go about proving that let v = x in y => y[v/x] terminates?
12:00:39 <jacobian_> Can't you just rewrite that as abstraction and application?
12:01:04 <jacobian_> or is that a letrec
12:01:50 <ndm> jacobian_: yes, but that isn't one of the rules
12:02:02 <ndm> jacobian_: you can't if it was a letrec, but you can for a let
12:02:23 <hpaste>  kokr pasted "S-Expression PolyParse parser" at http://hpaste.org/6310
12:03:37 <jacobian_> Well in the presence of uncontrolled "unfolding" we can't show termination.  If this is a single unfolding of v in y then it should be obviously terminating as the operation isn't even recursive.
12:04:14 <jacobian_> If we want to be able to do it sometimes and fail other times we can choose a criterion that lets us have a controlled unfolding.
12:04:37 <Cheery> @where Comonad
12:04:37 <lambdabot> http://www.eyrie.org/~zednenem/2004/hsce/Control.Comonad.html
12:04:51 <jacobian_> the homeomorphic embedding gives one relation that will allow you to control unfolding
12:05:57 <ndm> jacobian_:  i am aware of the homeomorphic embedding, but there is no recursive unfolding here, only inlining non-recursive let bindings
12:06:22 <ndm> i have even written a homeomorphic embedding library for haskell - http://www.cs.york.ac.uk/fp/darcs/homeomorphic
12:06:23 <lambdabot> Title: Index of /fp/darcs/homeomorphic
12:07:55 <jacobian_> well can't we change non-recursive let bindings into applications?
12:08:25 <ndm> we can, but i change applications to non-recursive let bindings
12:08:32 <jacobian_> ah :)
12:09:00 <ndm> i think my proof will fall down, as it happens, because of the Y combinator, as mrd mentioned
12:09:26 <ndm> if you combine application -> let and let -> replacement, then the Y combinator does get you
12:10:01 <shteou> Hi ndm.
12:10:07 <ndm> hi shteou
12:10:13 <augustss> Hi Neil
12:10:20 <shteou> I put a suggestion for a program on the YHC wiki, a bytecode editor, would anyone find that useful?
12:11:01 <ndm> shteou: i'm sure they would, there was half a Yhc.ByteCode library at some point, but i don't think we've ever had a bytecode editor, despite a rough intention to write one at some point
12:11:19 <ndm> augustss: hi - your sort function is very impressive :)
12:11:28 <augustss> :)
12:11:38 <ndm> i had wondered how such nice code ended up in Yhc...
12:11:42 <shteou> heh k, I'll check out the library shortly
12:11:59 <augustss> well, niklas didn't mind borrowing library code
12:12:00 <jacobian_> I think there should be two notions of replacement.
12:12:28 <ndm> according to Malcolm, you actually emailed it to them
12:12:44 <esteth> I have ghc installed from the ubuntu repositories. If i uninstall it, then install from source, will all my libs break. And most importantly, will xmonad break
12:12:59 <ndm> jacobian_: i'm not sure, i think i may have to go a few steps back in the case of my entire proof, to deal with that Y combinator, or show why its not possible
12:13:04 <Zao> esteth: If it's the same version, it ought to work.
12:13:11 <Zao> esteth: If the version differs, you need to rebuild all.
12:13:24 <augustss> ndm: oh, quite possible, I don't mind sharing
12:13:40 <esteth> Zao: It's not. I want to go from 6.6.1 to 6.8.2. Argh. that's a pain. Thanks though
12:13:55 <ndm> yeah, hopefully it can end up in GHC, and then everyone can benefit from it
12:14:22 <jacobian_> I think that there should be "opening" where you replace a bound debruijin index with the thing that it is applied to, and replacement where you take a free variable and replace it.
12:15:32 * MyCatVerbs wonders.
12:16:04 <MyCatVerbs> Poll: would you smack someone upside the head with a 2x4 in return for an Oracle for the halting problem?
12:16:23 <Zao> MyCatVerbs: You can't make an omelette without breaking a few eggs.
12:16:34 <augustss> ndm: does the yhc sort collect with rising and falling sequences?
12:16:39 <Stwange> mrd, is A_{TM} R.E? this could have been where my issues were
12:16:49 <mrd> Stwange: yes
12:16:51 <ndm> augustss: yes
12:17:01 <MyCatVerbs> Zao: k. How about a fast Oracle for the graph-labelling problem?
12:17:14 <augustss> ndm: then I think it's been improved over the hbc version
12:18:48 <Maddas> Any Haskell on OLPC users here?
12:19:48 <Cin> Mars, the Bringer of War. amazing
12:19:54 <jacobian_> ndm: I'm working on a provably terminating supercompiler in coq.
12:20:10 <ndm> jacobian_: oh, cool - have you seen Supero?
12:20:14 <Zao> MyCatVerbs: A coloring oracle would probably be more useful than a haltdeciding oracle.
12:20:31 <jacobian_> ndm: Yeah, my advisor was just reading your paper on it.
12:20:49 <Maddas> jacobian_: Where's the excitement if you know that it'll terminate even before you start compiling? :-]
12:21:11 <Stwange> mrd, but the complement isn't?
12:21:13 <int-e> Maddas: you can still bet on whether it'll terminate within 100 years or not :P
12:21:19 <ndm> jacobian_: the draft for the IFL post proceedings, or the IFP proceedings one?
12:21:33 <Maddas> int-e: But that's just a constant factor!
12:21:37 <ndm> jacobian_: the post proceedings uses homeomorphic embedding
12:21:38 <mrd> Stwange: the complement would be co-semi-decidable
12:21:57 <jacobian_> ndm: Hmmm, I didn't look closely, I just saw it on his desk.
12:22:05 <mrd> Stwange: the only way that a semi-decidable language and its complement are semi-decidable is if the language is decidable
12:22:41 <augustss> termination is overrated
12:23:12 <ndm> jacobian_: the papers are really different from each other, especially in their approach to termination
12:23:15 <Stwange> co-semi-decidable?
12:23:34 <mrd> Stwange: this is easy to show.  a semi-decidable language always halts for Acceptance.  a co-semi-decidable language always halts for Reject.
12:23:35 <ndm> augustss: often Supero feels like it doesn't terminate
12:24:04 <jacobian_> hehe
12:24:05 <mrd> Stwange: if a language is both, then it always halts
12:24:12 <jacobian_> Yeah, I read both papers.
12:24:14 <mrd> er, the machine deciding it
12:24:18 <LordBrain> Anyone have a simple example of Text.Html usage?
12:24:20 <augustss> To quote Yves Lafont (insert french accent): "What we need is not termination, but fast termination."
12:25:07 <jacobian_> termination is a necessary condition for fast termination though.
12:25:10 <ndm> i've got the final IFL post-proceedings one around somewhere
12:25:36 <LordBrain> The documentation i found at http://cvs.haskell.org/Hugs/pages/libraries/base/Text-Html.html is basically nonexistant
12:26:00 <roconnor> termination may be overrated, but Turing completeness is even more overrated.
12:26:00 <LordBrain> perhaps if i had more familiarity with parsec type parsers...
12:26:10 <LordBrain> if this is a parsec thing...
12:26:41 <Zao> LordBrain: I prefer the WASH/HTML transformer.
12:26:53 <Zao> I even managed to trick it into outputting reasonably valid XHTML :)
12:26:56 <MyCatVerbs> Zao: but you can reduce instances of the colouring problem to the halting problem.
12:27:03 <LordBrain> well i wanted to start with what comes with hugs/ghc
12:27:30 <Zao> MyCatVerbs: I knew it was a trick question but my CS knowledge is neglected.
12:27:33 <MyCatVerbs> Zao: just construct a TM that halts iff the graph's first node has colour a, another that halts iff the second node has colour b, etc. :)
12:27:37 <augustss> roconnor: I agree
12:27:40 <ndm> jacobian_: when you have some results/proofs etc, please do email me
12:27:57 <MyCatVerbs> Zao: no, it wasn't a trick question. I was just curious as to how cheap smacking someone upside the head with a 2x4 was in terms of Oracles. :D
12:28:21 <Stwange> mrd, so a co-semi-decidable language is a recursive language?
12:29:31 <Zao> MyCatVerbs: It also naturally depends on the target in question.
12:29:53 <jacobian_> ndm: will do
12:29:56 <mrd> Stwange: no
12:30:05 <mrd> Stwange: you know recursive languages are decidable, period
12:30:42 <mrd> decidable languages  \subseteq  (semi-decidable \intersect co-semi-decidable)
12:30:47 <LordBrain> There's no little snippets of Text.Html examples online anywhere?
12:31:09 <roconnor> logical consistency, however, may not be overrated.
12:31:27 <MyCatVerbs> Zao: grouchiness x = (sum (filter would-smack-for-free world-population)) / (sum (filter (not . would-smack-for-free) world-population))
12:31:40 <MyCatVerbs> @pl \x = (sum (filter would-smack-for-free world-population)) / (sum (filter (not . would-smack-for-free) world-population))
12:31:40 <lambdabot> (line 1, column 4):
12:31:40 <lambdabot> unexpected "="
12:31:40 <lambdabot> expecting operator, pattern or "->"
12:32:05 <MyCatVerbs> Oh oops, no '-'s in names. >>
12:36:18 <EvilTerran> ?seen dcoutts
12:36:18 <lambdabot> dcoutts is in #gentoo-haskell, #haskell, #ghc, #haskell-overflow and #haskell-soc. I last heard dcoutts speak 5h 18m 43s ago.
12:36:25 <dcoutts_> hia EvilTerran
12:36:48 <EvilTerran> hi
12:37:59 <EvilTerran> i just got a strongly-worded email for the comlab about the deadline for project proposals that went by on monday. hadn't realised they were quite so set on it all being sorted out ZOMG NOW, from talking to third-years, but from what it said, i was thinking it'd be good to get it sorted out
12:38:26 <hpaste>  wfarr pasted "config" at http://hpaste.org/6311
12:38:33 <dcoutts_> EvilTerran: ah, for 4th year projects?
12:38:36 <EvilTerran> 3rd
12:38:40 <dcoutts_> oh right, ok
12:38:41 <Stwange> mrd, I thought the definition of recursive was that they halted, and recursive enumerable are only guaranteed to halt with accept
12:38:52 <EvilTerran> so... would you like to supervise my gtk2hs-based proof assistant? :)
12:39:28 <dcoutts_> EvilTerran: I cannot personally supervise, you need an academic member of staff but I'm happy to advise you informally
12:39:34 <EvilTerran> ah, okay
12:39:54 <dcoutts_> EvilTerran: I'm already advising on two other projects in that way
12:39:57 <mrd> Stwange: right, and how is that different from "decidable" and "semi-decidable"
12:40:05 <EvilTerran> i figured it'd be nice to have you on board, seeing as you're "the haskell guy"
12:40:10 <dcoutts_> :-)
12:40:20 <dcoutts_> EvilTerran: and a gtk2hs maintainer :-)
12:40:30 <EvilTerran> indeed :)
12:41:06 <EvilTerran> i believe proof assistants are Bernard's forte, but i hear he's on sabbatical next year =/
12:41:49 <dcoutts_> oh right, I didn't know that
12:42:00 <dcoutts_> that he's on sabbatical
12:42:29 <dcoutts_> EvilTerran: I presume you've played with his previous proof assistants
12:42:45 <dcoutts_> jape was tcl iirc and he had some rewrite in python too I think
12:42:47 <EvilTerran> not his in particular, no. i'll have a gander sometime
12:42:57 <mrd> Stwange: it's not, in case you weren't getting my rhetorical question
12:43:16 <EvilTerran> ... hm, do you think Bird would be interested? seeing as he's into functional programming
12:43:53 <dcoutts_> EvilTerran: perhaps, he's retiring soon though but it's certainly worth asking
12:43:59 <EvilTerran> and "the algebra of programming" - i was hoping to make the sort of thing you could play with haskell expressions in as well as logic stuff
12:44:53 <EvilTerran> do you think anyone else in particular would be interested in supervising that sort of thing?
12:45:11 <dcoutts_> EvilTerran: Ralf Hinze is worth asking too
12:45:26 <dcoutts_> though he just agreed to supervise a 4th year FP project
12:45:58 <EvilTerran> cool. i'll email 'em all.
12:46:01 <Stwange> sorry mrd, it didn't flash
12:46:25 <Stwange> yeah ok so recursive is decidable, RE is semi-decidble
12:48:12 <mrd> and then you asked about co-semi-decidable, and I pointed out that the only way that a language is both semi-decidable and co-semi-decidable is if it is decidable
12:48:24 <Stwange> what does co-semi-decidable mean?
12:48:58 <mrd> a machine deciding that language is guaranteed to halt if the answer is Reject
12:49:18 <mrd> vs semi-decidable where it is guaranteed to halt if the answer is Accept
12:51:10 <Stwange> so the co and semi pretty much cancel out?
12:51:27 <byorgey> Stwange: a language is co-X if its complement (i.e., all strings NOT in the language) is X.
12:52:31 <byorgey> Stwange: so if you can recognize strings which are in a language (it's semi-decidable), and you can also recognize strings which aren't (it's co-semi-decidable), then obviously the language is decidable -- just run both recognizers in parallel.
12:52:50 <Gilly> Has anyone any experience on storing binary blobs in sqlite database using Takusen? It's causing interesting problems for me :P
12:53:18 <Stwange> ah, co is short for complement
12:53:22 <Stwange> I wasn't picking up on that
12:53:27 <byorgey> Stwange: right =)
12:53:42 <Stwange> sorry if I'm pestering you guys, I've been sat here for like 12 hours and im frazzled, so a little slow on the uptake
12:54:02 <Stwange> I really appreciate you taking the time to explain things to me though
12:54:23 <byorgey> Stwange: no pesterage has occurred as far as I can see =)
12:54:44 <mrd> aye, getting the terminology straight is probably the hardest part :)
13:03:00 <ivan__> when is GADTs usefull?
13:03:34 <pjd> when your ADTs are not generalized enough?
13:03:38 <roconnor> for constructing typed interpreters?
13:03:46 <pjd> (sorry, i'm not being useful :)
13:04:38 <augustss> for representing, e.g., monads?
13:05:11 <roconnor> GADTs are a little peak into dependent types, which is the way of the future.
13:07:39 <skorpan> you IDIOT ivan__!
13:07:45 <Saizan> the type-inferring definition of the simply typed lambda calculus is very nice, but it seems that you get into troubles if you add polymorphism
13:08:31 <roconnor> skorpan: ?
13:08:46 <hpaste>  gilly pasted "Takusen problems" at http://hpaste.org/6313
13:08:53 <skorpan> roconnor: i'm being silly
13:09:00 <skorpan> i'm sitting right next to the idiot right now
13:09:11 <Stwange> if a language isn't semi-decidable, can it have a complement that isn't either?
13:11:19 <roconnor> skorpan: okay. :)
13:11:31 <mrd> Stwange: you mean if its harder than semi-decidable?
13:12:21 <Stwange> mrd, like if it's not RE
13:12:43 <mrd> so it's undecidable, sure
13:12:49 <phlpp> :t permute
13:12:52 <lambdabot> Not in scope: `permute'
13:12:56 <phlpp> @hoogle permute
13:12:56 <lambdabot> Text.ParserCombinators.Parsec.Perm.permute :: PermParser tok st a -> GenParser tok st a
13:12:56 <lambdabot> System.Console.GetOpt.Permute :: ArgOrder a
13:13:09 <mrd> not to confuse you more, but there's a whole hierarchy of undecidable languages of which semi-decidable / co-semi-decidable are the bottom rung
13:13:30 <Stwange> so it's possible for L and co-L to be undecidable?
13:14:05 <mrd> yes
13:14:19 <Cheery> can you explain the comonad?
13:14:28 <Cheery> it's behavior is quite weird
13:15:09 <Cheery> for instance, how does it end up sequencing the stuff?
13:15:41 <sclv> Cheery: its uses are still sort of obscure for lots of applications. Someone pointed toward Data.Supply on hackage the other day as a good example of where that sort of construction makes sense.
13:15:41 <Cheery> for instance, this context -thingy
13:15:42 <mrd> Stwange: there are problems so hard that even having an oracle for the Halting problem won't help you
13:15:58 <Cheery> @where Data.Supply
13:15:58 <lambdabot> I know nothing about data.supply.
13:16:08 <sclv> on hackage.
13:19:29 <roconnor> > let sevenofnine (a,b,c,d,e,f,g,h,i) = g in seveofnine (1,2,3,4,5,6,7,8,9)
13:19:30 <lambdabot>   Not in scope: `seveofnine'
13:19:36 <roconnor> > let sevenofnine (a,b,c,d,e,f,g,h,i) = g in sevenofnine (1,2,3,4,5,6,7,8,9)
13:19:37 <lambdabot>  7
13:19:50 <Cheery> uuuuugh
13:20:23 <Cheery> sclv: anyway, only thing I'm interested about is how it sequences stuff
13:20:53 <sclv> why?
13:20:54 <byorgey> ugh, a nine-tuple?
13:20:56 <Cheery> it seems to be a weird hack. :)
13:20:59 <byorgey> a nonuple?
13:21:17 <sclv> its not a weird hack. its a category-theoretical concept. it doesn't necessarily sequence.
13:21:24 <roconnor> byorgey: more functions for Data.Tuple :)
13:21:42 <Cheery> ..?
13:22:01 <Cheery> sclv: well, when I think about a context monad
13:22:03 <byorgey> roconnor: oh, uh, right!  man, I hate it how I have to re-define sevenofnine for EVERY project I write
13:22:28 <sclv> comonad /= context monad!
13:22:34 <mrd> svn9
13:22:49 <mrd> fst3,snd3,thd3 ... svn9
13:22:50 <Cheery> are we speaking the same language now?
13:23:26 <mrd> also we should define car, cdr, caar, cadr, cdar, cddr, cadar, ...
13:23:38 <sclv> i dunno.
13:24:13 <Cheery> (.>>) :: Comonad w => w a -> b -> w b, (=>>) :: Comonad w => w a -> (w a -> b) -> w b
13:24:18 <wli> Use typeclasses.
13:24:29 <wli> e.g. http://holomorphy.com/~wli/Untuple.hs
13:25:23 <Cheery> @where Context
13:25:23 <lambdabot> I know nothing about context.
13:26:02 <Cheery> oh well, there was this sort of odd thing:
13:26:04 <Cheery> instance Comonad (Context c) where extract   (Context f c) = f c duplicate (Context f c) = Context (Context f) c
13:26:38 <Cheery> ugh, I said Context monad when I were supposed to say Context comonad
13:27:11 <Cheery> CoNfusionMonad
13:28:34 <Cheery> sclv: anyway, there's that sort of context comonad
13:28:47 <EvilTerran> is there an Ntext Monad?
13:28:54 <sclv> right -- but i don't think it implies sequencing.
13:29:07 <sclv> have you read sigpfe's posts on comonads?
13:29:12 <Cheery> nop
13:29:39 <sclv> if you're interested in getting your head around them, they're excellent -- there was one just recently, and there were a few last year.
13:29:56 <sclv> sigfpe.blogspot.com/
13:30:08 <Cheery> anyway, those have weird properties.  extract ((Context id 50) .>> 100)
13:30:59 <Cheery> extract ((Context id 50) =>> modify (*2))
13:35:18 <Stwange> does recursive == P?
13:37:17 <tromp> what is P, Stwange?
13:37:58 <Stwange> tromp, problems that can be solved in polynomial time
13:38:24 <oerjan> what is recursive?
13:38:43 <Stwange> problems that are decidable, ie. turing machines halt on them
13:38:48 <oerjan> (i know what it generally means, but i cannot connect it to P)
13:38:53 <oerjan> oh.  of course not.
13:39:15 <oerjan> the halting problem for P is not in P
13:39:32 <Stwange> yeah but that's not recursive either
13:39:37 <oerjan> sure it is
13:39:43 <oerjan> or wait
13:39:49 <roconnor> recusive languages == decidable languages
13:39:52 <Stwange> yeah
13:40:04 <oerjan> of course P doesn't have a halting problem
13:40:10 <roconnor> recusive languages == decidable languages == computable languages
13:40:22 <dejones> recusive?  or recursive?
13:40:27 <roconnor> recursive
13:40:36 <brothers> roconnor: really? how convenient
13:40:50 <oerjan> anyway, EXPTIME is not all polynomial
13:40:59 <dejones> roconnor: just thought maybe I was lost.  ;)
13:41:19 <roconnor> recursively enumerable languages = semi-decidable languages
13:41:28 <dejones> dynamic programming with Haskell is making my brain melt.  :(
13:41:33 <roconnor>  == c.e. (computable enumerable?) languages
13:41:45 <Stwange> are some semi-decidable languages in P?
13:41:49 <ndm> does GHC apply the simplification (\v -> x) y => let v=y in x ?
13:41:50 <Stwange> and not in decidable
13:42:21 <roconnor> Stwange: is P the P from P = NP?
13:42:21 <oerjan> you use a diagonalization argument on P to get a problem that cannot be solved in P, but easily with something a bit larger
13:42:21 <ndm> and if so, does anyone know where in the simplifier? i'm reading it, but it looks like 2000 lines of greek to me
13:42:38 <Stwange> roconnor, yeah, but that's not been proven
13:42:42 <oerjan> Stwange: everything in P halts.  therefore it is decidable.
13:42:51 <dejones> argh, having a fever really makes concentrating difficult.  :(
13:43:17 <sclv> ndm: don't know the code, but i recall an spj paper from some years back on let floating describing the ghc algorithm in some depth.
13:43:32 <hpaste>  Tobsi pasted "non-exhaustive patterns" at http://hpaste.org/6314
13:43:49 <hallongrottan> anyone care to explain why i get non-exhaustive patterns in that paste?
13:43:49 <Stwange> oerjan, does everything in P halt? Even on reject?
13:43:59 <roconnor> Stwange: it is important to be aware the difference between terms about algorithms (P, NP etc) vs terms about languages (resursive, semi-decidable)
13:44:00 <sclv> from what i recall, i can't imagine it wouldn't apply that simplification.
13:44:15 <roconnor> Stwange: they are related but different.
13:44:25 <Stwange> roconnor, I am aware that they are different, I just want to know how related they are
13:44:45 <Stwange> like, is P a subset of recursive? Does P == recursive? is recursive a subset of P?
13:44:51 <oerjan> Stwange: yes
13:44:56 <doserj> hallongrottan: an answe could be an empty list
13:45:10 <hallongrottan> doserj: yes
13:45:13 <oerjan> everything in NP halts do, it just doesn't always give the right answer
13:45:20 <ndm> sclv: thanks, i know the paper, will check it out
13:45:23 <oerjan> *too
13:45:39 <doserj> hallongrottan: but you are not matching on that
13:46:02 <roconnor> All languages that P-time algorithms decide are recursive because P algorithms always decide.
13:46:20 <hallongrottan> doserj: gotta look it up, brb
13:46:32 <roconnor> so in that sense P induce a subset (a tiny subset) of recursive languages.
13:46:39 <oerjan> Stwange: P <= NP <= PSPACE <= EXPTIME <= primitive recursive <= recursive <= rec. enumerable
13:46:48 <oerjan> just for a part of the hierarchy
13:46:53 <Stwange> so both P and NP are recursive?
13:46:57 <oerjan> yep
13:47:07 <Stwange> ok, thanks :)
13:47:12 <roconnor> oerjan: each of those <= are even huger than the last!
13:47:20 <oerjan> roconnor: _might_ be
13:47:27 <roconnor> oh right
13:47:51 <opqdonut> yeah, some might be equalities :P
13:47:55 <oerjan> it is not known for the four first, for neighbors
13:48:04 <roconnor> well, it is only the first 1 or 2 that may be equal
13:48:05 <oerjan> although P < EXPTIME
13:48:18 <opqdonut> and primrec<rec<rec.enum
13:48:19 <roconnor> oerjan: oh really
13:48:19 <roconnor> wow
13:48:19 <oerjan> perhaps even NP < EXPTIME, i'm not sure
13:48:36 <opqdonut> yeah i guess NP<EXPTIME
13:48:37 <oerjan> roconnor: you being ironic? :D
13:48:56 <roconnor> no, I didn't know that the first 4 were unknown.
13:49:07 <opqdonut> ah, NP<NEXPTIME
13:49:18 <opqdonut> (http://en.wikipedia.org/wiki/EXPTIME)
13:49:19 <lambdabot> Title: EXPTIME - Wikipedia, the free encyclopedia
13:49:30 <hallongrottan> doserj: do you have any suggestions on how to fix the match?
13:49:48 <oerjan> yeah, it is generally easy (by diagonalization) to get inequalities between classes measured in the "same" way
13:50:38 <doserj> hallongrottan: you need a case "toTrace ([]:ans) = ..."
13:50:55 <monochrom> Equality is a philosophical subject of eternal debate. Everyday at least 50 messages on the -cafe are dedicated to it. Discuss.
13:50:58 <dcoutts_> @seen dons
13:50:58 <lambdabot> dons is in #xmonad, #haskell-soc and #haskell. I last heard dons speak 2h 21m 48s ago.
13:51:02 <dons> dcoutts_: ?
13:51:36 <dcoutts_> dons: I think there's a good chance we can release Cabal-1.4 before the hackathon, any progress on the darcs repo field issue?
13:51:43 <roconnor> @quote equality
13:51:43 <lambdabot> JamesMckinna says: We are once again left with the miserable prospect that it is equality that divides us.
13:51:44 <dcoutts_> it'd be nice to have that in the 1.4 release
13:52:04 <dcoutts_> dons: if you think it's not going to happen for this release I'll punt it to the next milestone
13:52:34 <dcoutts_> it's probably more important to get the design right than to have it immediately
13:52:43 <dons> dcoutts_: its likely to be towards the end of the month
13:53:27 <dcoutts_> dons: lemme know how it goes and if you think it'll be ready for a release
13:53:36 <dons> ok
13:53:42 <hallongrottan> doserj: yeah, we did that, however our whole program seems to be lost now haha
13:53:53 <dcoutts_> dons: the number of tickets for 1.4 is dropping rapidly :-)
13:53:55 <hallongrottan> lost as in confised
13:53:57 <hallongrottan> sonfused*
13:54:00 <hallongrottan> confused*
13:54:01 <hallongrottan> lol
13:54:48 <Saizan> dcoutts_: does fixing this http://hackage.haskell.org/trac/hackage/ticket/40 mean implementing the create part of tar in Hackage.Tar, basically?
13:54:49 <lambdabot> Title: #40 (sdist runs tar, which is a problem under Windows) - Hackage - Trac
13:54:57 <oerjan> hallongrottan: that's some heavy self-reference there :D
13:55:05 <dons> dcoutts_: awesome bananas
13:56:06 <dcoutts_> Saizan: yes
13:56:18 <orzo> Hello
13:56:21 <dcoutts_> Saizan: want to have a go? it doesn't need to be high performance
13:56:41 <dcoutts_> Saizan: it'd basically mean porting the existing tar code to not use unix-compat or the binary lib
13:56:42 <byorgey> hi orzo
13:56:59 <dcoutts_> Saizan: which is what bringert did for the tar unpacking code
13:57:49 <orzo> I have some code that uses continuations in Scheme.  However, the lazy list implementation there is not fast enough for my purposes.  I chose scheme for the first-class continuations though.  I understand haskell has some sort of continuation semantics.  The question is, are haskell's continuations equally powerful with Schemes?
13:57:54 <dons> do we have some job for 'Michael' on the list, who'd like to write docs?
13:58:10 <dcoutts_> Saizan: probably using String to generate the tar headers and then packing it into a bytestring and using bytestring for the file data of course, that should be reasonably quick
13:58:25 <bringert> Saizan: it wouldn't be very hard
13:58:32 <Saizan> i see
13:58:40 <dcoutts_> dons: hmm, are there not quite a bit of the base/core libs that have poor haddoc docs but decent comments
13:58:47 <bringert> dcoutts_, saizan: or just produce a list of ByteStrings and then concat them
13:59:00 <dons> dcoutts_: indeed. i'm just about to suggest those.
13:59:03 <byorgey> orzo: sure.  laziness + first-class functions means that Haskell doesn't need any special support for continuations at the language level.
13:59:13 <orzo> I'm interfacing with c++, and the c++ code is pushing data in to the haskell/scheme code and that code  uses continuations to make a lazy list of the pushed in data that is processed as if it were pulled out of the list
13:59:24 <bringert> I have fixed some when I've come across them, e.g. control.parallel.strategies, parts of the System.posix
13:59:29 <dcoutts_> bringert: right, or not concat but lazy's fromChunks function and write it out
13:59:38 <bringert> there may be more to do in System.Posix
13:59:40 <Saizan> bringert: maybe producing the headers in bytestring directly means a lot of small ones?
13:59:43 <bringert> dcoutts_: right
13:59:47 <orzo> byorgey: are you sure haskell can do what i just said?
13:59:58 <bringert> Saizan: sure, but that's ok, do as dcoutts_ said
14:00:03 <dcoutts_> Saizan: each header is always exactly 512 bytes iirc, that's ok
14:00:13 <bringert> yeah, that's right
14:00:27 <bringert> the tar package actually makes very light use of the binary package
14:00:29 <byorgey> orzo: I'm not entirely sure I understand what the purpose of the continuations is
14:00:29 <dcoutts_> Saizan: so generate the header using String to accumulate the fields conveniently and then pack that into a 512 length strict ByteString
14:00:31 <monochrom> orzo: the package CC-delcont is more powerful than Scheme's call/cc
14:01:08 <dcoutts_> Saizan: then we end up with a list of header and content bytestrings, then we just concat them and write it out, lazy bytestring would be ideal.
14:01:47 <byorgey> orzo: note haskell is lazy, so lists in Haskell are lazy lists.  you don't need to do anything special in Haskell to create a lazy list.
14:01:51 <Saizan> dcoutts_: ok, i'll have a look
14:01:55 <bringert> Saizan: you basically just need to change putHeaderNoChkSum in http://code.haskell.org/tar/Codec/Archive/Tar/Write.hs use [...] instead of do {...}
14:01:55 <orzo> i know that byorgey
14:02:04 <byorgey> orzo: ok, sorry =)
14:02:10 <orzo> you guys understand my situation, right?
14:02:14 <dcoutts_> Saizan: and we do not need the unix-compat stuff, we'll not bother filling in the permissions and owner correctly or preserving symbolic links
14:02:14 <bringert> Saizan: and some of the other functions in the same way
14:02:39 <monochrom> But you need unsafeInterleaveIO to marshall FFI incomings into a lazy list.
14:02:56 <dcoutts_> Saizan: ndm will be very happy with you, he complains about the use of tar on windows
14:02:56 <byorgey> ah, true
14:03:12 <LordBrain> orzo, monochrom's last statement was for you
14:03:28 <orzo> c++ calls putEvent( e )  and a haskell or scheme thread that is waiting on a car operation on the lazy list unblocks
14:03:35 <orzo> yes, i see
14:04:08 <monochrom> I suppose alternatively you can use a monad supporting continuations.
14:04:31 <Saizan> dcoutts_: no symbolic links?
14:04:50 <dcoutts_> Saizan: no need and it's hard to do portably
14:05:04 <dcoutts_> Saizan: we fake symbolic links when we unpack anyway
14:05:10 <dcoutts_> by copying the content
14:05:59 <Cheery> hm. Context comonad seem to get a whole lot more interesting when I play with different types
14:06:10 <dcoutts_> Saizan: I don't think any packages seriously use them anyway for their source trees
14:06:11 <Cheery> and even further mysterious
14:08:23 <Saizan> dcoutts_: yeah, and the function that prepares the directory to pack copies contents as well probably
14:08:34 * Saizan checks
14:08:35 <dcoutts_> Saizan: right, yes
14:08:58 <oerjan> orzo: is it necessary to use actual lists?  otherwise a Chan might be easier...
14:10:39 <oerjan> @hoogle Chan a -> [a]
14:10:39 <lambdabot> No matches, try a more general search
14:11:12 <Cheery> experiment [(+10), (*2)] (Context show 50 =>> (\(Context f v) -> f v ++ "foo"))
14:11:12 <Cheery> ["60foo","100foo"]
14:11:21 <oerjan> oh wait
14:11:34 <Cheery> how does the context comonad stay in condition?
14:11:35 <oerjan> orzo: there is getChanContents which may be useful
14:11:43 <oerjan> @hoogle getChanContents
14:11:43 <lambdabot> Control.Concurrent.Chan.getChanContents :: Chan a -> IO [a]
14:11:53 <Cheery> it's sick as it can get
14:12:03 <oerjan> it does the conversion from Chan to lazy list
14:12:06 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/6315
14:12:48 <wieczyk> http://hpaste.org/6315 coudl someone help me with this ?
14:13:39 <wieczyk> Compiler is telling me about bat instance.
14:13:51 <oerjan> wieczyk: you are going to need the FlexibleInstances extension
14:13:52 <wieczyk> But i want to declare a show class for function types.
14:13:59 <wieczyk> aha
14:14:06 <oerjan> iirc
14:14:17 <wieczyk> that in std GHC i cannot do this ?
14:14:36 <dons> -XFlexibleInstances
14:14:36 <oerjan> wieczyk: haskell 98 has very restricted form of instances
14:14:40 <dons> is the flag you'll need
14:14:55 <oerjan> basically everything but the main type must be a type variable
14:15:21 <oerjan> so the Integer's need the extension to be allowed
14:15:47 <wieczyk> ok.
14:15:57 <wieczyk> hm
14:16:05 <wieczyk> can I declare Show for (a->a) ?
14:16:12 <oerjan> wieczyk: btw lambdabot has such an instance based on the Typeable class which is more flexible
14:16:21 <oerjan> > (+1)
14:16:22 <lambdabot>  <Integer -> Integer>
14:16:49 <oerjan> i guess that almost answers your last question too
14:16:54 <wieczyk> ;]
14:16:56 <wieczyk> thanks
14:18:55 <oerjan> wieczyk: you can also declare FlexibleInstances directly in your file: {-# LANGUAGE FlexibleInstances #-} at the top
14:19:39 <wieczyk> ok.
14:20:19 <oerjan> @seen olsner
14:20:19 <lambdabot> olsner is in #haskell-blah and #haskell. I last heard olsner speak 2h 56m 30s ago.
14:20:50 <olsner> oerjan: it was a known ghc bug, #1756 if my recollection of numbers doesn't fail me
14:21:07 <oerjan> ah :)
14:21:31 <oerjan> gah hpaste is slow
14:22:12 <dons> oerjan: ?
14:22:21 <dons> oh. is it down?
14:22:30 <oerjan> no, it just loaded slowly
14:22:33 <dons> huh. that took ages.
14:23:11 <oerjan> olsner: btw i just recalled, you don't need one LANGUAGE pragma for each language option, you can use commas
14:23:31 <olsner> heh, *now* you tell me? :P
14:27:29 <Cheery> I think I understand the comonad -thing now..
14:28:44 <roconnor> \o/
14:29:26 <Cheery> it's really completely opposite of monad, and completely opposite from what I thought it was
14:30:39 <roconnor> un unsequences things!
14:30:45 <roconnor> it unsequences things!
14:30:48 <roconnor> :D
14:31:04 <Cheery> into a State -monad, you can contain a state, into Context -comonad, you can contain a computation
14:31:34 <roconnor> sounds like you understand comonads better than I do.
14:31:45 <olsner> the impossible happened! someone understood comonads
14:31:54 <roconnor> I just understand they have something to do with labeled trees
14:32:16 <roconnor> or cellular automoton
14:33:18 <Cheery> yep, now you'll need to invent an another arcane mathematical riddle
14:33:21 <orzo> i would want my main program to be c++ and for it to call haskell code
14:33:27 <orzo> that's doable, right?
14:34:24 <roconnor> orzo: rumour has it that is doable.
14:34:38 <roconnor> I'm told the FFI goes both ways
14:34:55 <JaffaCake> orzo: doable, but difficult because you need to link using g++
14:35:15 <orzo> link with haskell runtime?
14:35:28 <orzo> is there just some dynamic library i can link against?
14:35:43 <oerjan> orzo: http://haskell.org/ghc/docs/latest/html/users_guide/ffi-ghc.html#ffi-library perhaps
14:35:44 <lambdabot> Title: 9.2. Using the FFI with GHC, http://tinyurl.com/yvfmf3
14:35:53 <orzo> thanks, oerjan
14:36:14 <oerjan> but if JaffaCake says it's difficult there have to be further complications
14:36:20 <lament> why is it that c++ never seems to play nice with other stuff (compared to c)?
14:36:41 <Excedrin> no abi
14:37:06 <roconnor> what is abi?
14:37:36 <mrd> C++ mangles names and does all sorts of wacky stuff
14:37:44 <Excedrin> Application Binary Interface
14:37:52 <mrd> roconnor: the convention for calling functions and stuff
14:38:21 <dcoutts_> tibbe: fixed cabal ticket #161 that you reported: 'sdist' cannot find some modules that 'build' finds ok
14:38:54 <tibbe> dcoutts_: nice. thanks!
14:39:00 <dcoutts_> tibbe: turns out it was pre-processing that was inconsistent and the build step should have failed too :-)
14:39:40 <dcoutts_> and the 'workaround' is actually the correct solution
14:39:51 <tibbe> :)
14:40:09 <tibbe> now I have an issue with haddock not finding Control.Applicative but GHCi does, any idea why?
14:40:24 <tibbe> does haddock keep its own module index or something?
14:40:33 <dcoutts_> yes
14:41:09 <dcoutts_> tibbe: ghc-pkg field base haddock-interfaces
14:41:51 <dcoutts_> those binary .haddock files contain the info about what haddock thinks is exported
14:42:21 <dons> hey tibbe, thinking of mentoring SoC stuff this year?
14:42:53 <tibbe> dons: I was going to do the Unicode stuff but that's taken :/
14:43:06 <tibbe> and I haven't come up with anything else but I would be up for it
14:43:36 <tibbe> dcoutts_: so Control.Applicative came with my GHC 6.8.2 so why do you think haddoc wouldn't know about it?
14:43:59 <dcoutts_> tibbe: what is the error message exactly?
14:44:08 <tibbe> dcoutts_: let me check
14:44:09 <dcoutts_> tibbe: and what version of haddock?
14:45:05 <dons> sclv: hey, what's up with all this point free stuff in HStringTemplate lib?
14:45:13 <dons> sclv: its impossible to read the src!
14:45:14 <tibbe> dcoutts_: Warning: in export list of "Hyena.Parser": module not found: "Control.Applicative"
14:45:37 <tibbe> dcoutts_: but trying out my module in ghci indeed shows that the names from C.A got exported
14:46:06 <dcoutts_> tibbe: and the haddock version?
14:46:26 <sclv> dons: it was a learning exercise for me in part -- helped me to factor a great deal, and think in terms of applicatives. doing it again i'd probably use an explicit reader monad and a great deal more do notation.
14:46:27 <tibbe> dcoutts_: 2.0.0.0
14:46:46 <sclv> does make it a bit hard to share code tho...
14:47:04 <dcoutts_> tibbe: I bet that the base.haddock was written by haddock-0.8 or 0.9
14:47:10 <tibbe> dons: I think applicative made my parser more readable
14:47:17 <dons> applicatives are great
14:47:19 <tibbe> dcoutts_: ah
14:47:23 <tibbe> dcoutts_: how to upgrade?
14:47:27 <dcoutts_> tibbe: do you get any warning about not being able to read .haddock files?
14:47:36 <dcoutts_> tibbe: I'd go the other way personally
14:47:56 <dcoutts_> tibbe: I'm not sure how to get ghc to build using haddock 2.0
14:47:59 <sclv> i guess i've lived with it a while, but i don't find most of it too hard to read, though...
14:48:10 <sclv> maybe the io stuff in group in particular was ugly...
14:48:21 <elliottt> sclv: it could do with a little simplification :)
14:48:33 <tibbe> dcoutts_: so I'm using a binary build of GHC
14:48:49 <tibbe> dcoutts_: probably why
14:49:00 <ivan__> what is a sequence combinator?
14:49:01 <tibbe> dcoutts_: but haddock works otherwise, it generates HTML
14:49:24 <dcoutts_> tibbe: sure, it just does not generate any links to the base or other core libs
14:49:47 <elliottt> sclv: it's a small thing, but in the docs for StringTemplateShow, you could have said that stringTemplateFormattedShow defaults to (\_ a -> stringTemplateShow a)
14:49:58 <elliottt> rather than bringing flip and (.) into it
14:50:25 <sclv> ah -- noted for the next revision.
14:50:49 <elliottt> it would be nice to have some examples of common use cases in the package as well
14:50:53 <sclv> any particularly ugly code ppl want me to clean up, feel free to shoot me an email and i'll try to get to it as well.
14:51:05 <oerjan> ivan__: hm?  need more context...
14:52:07 <sclv> as far as common use cases, well, i'm putting something together to put it through some paces and i'll have a few nicer api functions as well. haven't used it myself as much as i'd like to yet -- more wanted to get it all out there and in place.
14:52:39 <elliottt> awesome.  it just took me a little while to figure out that to get the $var.name$ syntax in the template, i had to use a map.
14:52:42 <ivan__> there is a question in constructing getString with use of getChar and then they ask which sequence combinator can u do this with?
14:53:07 <sclv> elliottt: you can also use generics! :-)
14:53:13 <elliottt> hehe
14:53:26 <elliottt> so, i tried that and it didn't seem to do exactly what i was expecting
14:53:34 <EvilTerran> ivan__, ah... i suspect that means "one of (>>) or (>>=)" by "sequence combinator"
14:53:40 <sclv> hmmm.. how so?
14:53:41 <elliottt> i have a few data types with labels that i want to push into the templates as records, essentially
14:54:08 <elliottt> when i fell back on the Data a instance for ToSElem, it didn't let me access the labels
14:54:19 <elliottt> so i've been writing my own instances of ToSElem since
14:54:48 <ivan__> EvilTerran: yea i think so too, but i have a problem, i have implemented getString = getChar >>= (\x -> if x /= '\n' then getString else return "()")
14:54:54 <sclv> weird... i'll look into it.
14:54:56 <ivan__> how do i get ridd of the return "()"
14:55:36 <oerjan> ivan__: shouldn't that be return "", and i don't think it should be gotten rid of
14:55:43 <elliottt> i'll give it another try, i'm trying to glean enough information from the string template docs to do something useful quickly, maybe i should just sit down with the python implementation and flesh out the template first :)
14:55:44 <sclv> since that was the whole point of the generics, really...
14:55:45 <EvilTerran> ivan__, surely you want to return "" (or "\n") if you read a newline, and at least this character if you didn't read a newline?
14:55:45 <tibbe> hmm, according to the versioning policy do I have to bump the major number if I remove dependencies? my intuition is that I shouldn't
14:55:59 <cinema_> Hi, does anyone know how to get an user's preference concerning the display of dates (european way of american way) ?
14:56:02 <elliottt> sclv: ah, ok.  i should definitely take another look, then
14:56:02 <dons> removing dependencies, and not changing the api?
14:56:03 <sclv> i have some random examples on my blog too...
14:56:12 <dons> tibbe: hmm, i'd probably minor version bump that
14:56:18 <sclv> but i haven't put the generics through as many paces as i'd like.
14:56:30 <tibbe> dons: yes, I don't need the HUnit dependency cause I don't use it anymore (doh!)
14:56:56 <sclv> thanks for the feedback!
14:57:14 <dejones> anyone happen to have a copy or access to the publication by John Hughes "Lazy memo-functions" and they could email me the pdf or post it online somewhere?  :)
14:57:22 <elliottt> sclv: no problem.  the library is exactly what i need :)
14:58:20 <oerjan> ivan__: also, you seem to be throwing away x after checking it, you probably want to combine it with the result of the recursion
15:06:15 <smg> @src and
15:06:15 <lambdabot> and   =  foldr (&&) True
15:12:23 <smg> @src concat
15:12:23 <lambdabot> concat = foldr (++) []
15:12:33 <smg> hehe as i guesses lambdabot i like you
15:19:04 <RayNbow> > let ones = 1 : ones      in     ones `genericIndex ` 147946214
15:19:12 <lambdabot> Terminated
15:19:14 <RayNbow> hmm
15:20:13 <RayNbow> > let ones = 1 : ones      in     ones `genericIndex ` 73973107  -- this should take like 5 secs
15:20:16 <lambdabot>  1
15:20:18 <oerjan> > showHex 147946214 ""
15:20:19 <lambdabot>  "8d17ae6"
15:20:28 <smg> hrhr
15:21:04 <orzo> i don't remember ghc being this slow to compile
15:21:28 <tromp> > repeat 1
15:21:29 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
15:21:38 <laura85> hi ^^
15:21:40 <Stwange> to show that every recursively enumerable language reduces to the universal language A_{TM}... is it just enough to say that if L is RE then there must be some TM that accepts it, and so there is a function f that can find a turing machine that matches any string s from L, and (L, s) is therefore a member of A_{TM}
15:22:02 <smg> @src (!!)
15:22:02 <lambdabot> xs     !! n | n < 0 = undefined
15:22:02 <lambdabot> []     !! _         = undefined
15:22:02 <lambdabot> (x:_)  !! 0         = x
15:22:02 <lambdabot> (_:xs) !! n         = xs !! (n-1)
15:22:33 <laura85> i need a hint: why is  (\x.(\y. y x)) of type:   a -> (a->b) -> b ?
15:23:22 <mrd> (\ x :: a.  (\ y :: a -> b. y x))
15:23:22 <Heffalump> has anyone shown you how to infer the types of things?
15:23:27 <chessguy> @type \x y -> y x
15:23:29 <lambdabot> forall t t1. t -> (t -> t1) -> t1
15:24:38 <chessguy> laura85, does it make more sense when you see it in this form (\x y -> y x)?
15:24:58 <mrd> Stwange: A_{TM} = { <M,w> | M is a Turing Machine and M accepts w }
15:25:17 <mrd> Stwange: just a minor point, but A_{TM} accepts Turing Machines (encoded) paired with input
15:25:53 <mrd> Stwange: are you trying to build a mapping reduction?
15:25:55 <Stwange> yeah I think so mrd, it's a reduction anyway
15:26:03 <Saizan> how do you get seconds since the unix epoch from a ClockTime in a haskell98 way?
15:26:12 <smg> @src elem
15:26:12 <lambdabot> elem x    =  any (== x)
15:26:21 <smg> @src any
15:26:21 <lambdabot> any p =  or . map p
15:26:23 <mrd> Stwange: well you are talking about a function f
15:26:40 <Stwange> mrd, don't you need to have some function f to reduce one language to another?
15:27:41 <mrd> Stwange: to mapping reduce A <= B you will want to create a computable function f which maps "Accept" instances of A to "Accept" instances of B, and "Reject" instances of A to "Reject" instances of B
15:28:13 <laura85> mrd, chessguy, I've already tried that, but still no progress here ^^ could you tell me what that function does?
15:28:30 <tromp> or, more conisely, x in A iff f(x) in B
15:29:01 <Stwange> what about f: (M, x) s.t x is a member of L(M)?
15:29:31 <chessguy> laura85, it takes two parameters. the first can be of any type. the second is a function, which it applies to the first parameter
15:30:12 <chessguy> thus, the type of the input to the parameter must be of the same type as the first parameter
15:30:20 <monochrom> laura85: I do not recommend minding what the function does. You don't need it for typing. But if you insist, (\x y -> y x) pi sin = sin pi.
15:30:20 <chessguy> perhaps this will help:
15:30:34 <chessguy> > (\x y -> y x) 3 (*2)
15:30:35 <lambdabot>  6
15:30:46 <monochrom> > (\x y -> y x) 3 f
15:30:46 <lambdabot>  Add a type signature
15:30:51 <monochrom> > (\x y -> y x) 3 f :: Expr
15:30:51 <lambdabot>  f 3
15:30:54 <monochrom> :)
15:30:57 <monochrom> @botsnack
15:30:57 <lambdabot> :)
15:31:08 <mrd> > flip ($) 3 f :: Expr
15:31:09 <lambdabot>  f 3
15:31:13 <monochrom> > (\x y -> y x) 3 (* 2) :: Expr
15:31:13 <lambdabot>  3 * 2
15:31:36 <chessguy> laura85, is this helping?
15:31:42 <laura85> monochrom, chessguy, thanks a lot ^^
15:32:07 <chessguy> @hoogle Expr
15:32:08 <lambdabot> Text.ParserCombinators.Parsec.Expr :: module
15:32:08 <lambdabot> Distribution.Simple.Program.alexProgram :: Program
15:32:08 <lambdabot> Text.ParserCombinators.Parsec.Expr.buildExpressionParser :: OperatorTable tok st a -> GenParser tok st a -> GenParser tok st a
15:32:12 <orzo> http://haskell.org/ghc/docs/latest/html/users_guide/ffi-ghc.html
15:32:12 <lambdabot> Title: 9.2. Using the FFI with GHC
15:32:24 <orzo> the example fails to compile with ghc 6.8.2
15:32:48 <orzo> Foo.hs:3:0: Invalid type signature
15:32:51 <oerjan> chessguy: not the same Expr
15:32:56 <oerjan> @where Expr
15:32:56 <lambdabot> http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
15:33:45 <chessguy> ah, leave it to twanlv
15:34:30 <Stwange> mrd, how can I create a mapping for any possible Turing machine? How do I know what it will accept/reject?
15:34:36 <doserj> orzo: {-# LANGUAGE ForeignFunctionInterface #-} ?
15:34:56 <orzo> doserj, hm?
15:35:10 <orzo> i tried to compile it like this: ghc -c Foo.hs
15:35:42 <orzo> do i have to do anything special to get ghc to understand the ffi?
15:35:49 <doserj> orzo: add {-# LANGUAGE ForeignFunctionInterface #-} before the module declaration
15:35:56 <orzo> oh
15:35:57 <oerjan> Stwange: you don't need to know.
15:36:15 <mrd> Stwange: you ahve a language L
15:36:17 <chessguy> hmm, bit of a hack there
15:36:34 <oerjan> iiuc, A_{TM} already knows that, essentially
15:37:24 <oerjan> Stwange: the function you want is _not_ from languages to Turing machines.  it is for _one_ language only, for which you know the TM
15:37:53 <dons> bringert: around?
15:37:54 <mrd> ah, you need to make sure not to mix up a language L and a class of languages such as r.e.  type error ;)
15:38:06 <orzo> hmm, FFI related headers were installed under lib/ghc-6.8.2/include/
15:38:11 <orzo> that's odd
15:38:22 <orzo> why aren't tehy put in the usual spot instead of under lib
15:38:40 <Stwange> mrd, yeah but it's any language from the class of languages
15:38:50 <Stwange> oerjan, it's general language, so how do I know the TM?
15:38:57 <bringert> dons: just barely
15:39:07 <oerjan> Stwange: you assume you know, since you know it is RE
15:39:11 <bringert> dons: off to bed in a half a minute
15:39:46 <Stwange> oerjan, all I know from that is that there exists some Turing machine that accepts it
15:39:57 <Stwange> wait... is the empty language RE?
15:40:04 <Stwange> because there cannot exist a TM to accept it
15:40:23 <oerjan> Stwange: sure there can
15:40:37 <oerjan> just a TM which always rejects immediately
15:40:47 <Stwange> that's not accepting though... ever?
15:40:56 <oerjan> indeed
15:41:17 <oerjan> which is exactly what you want for the empty language
15:41:51 <mrd> the empty language is regular
15:42:01 <tibbe> should I give my first version of a package version 0.1.0 or 0.1.1, why did GHC start counting at .1 instead of .0?
15:42:03 <doserj> Stwange: maybe watch the terminology. A TM accepts or does not accept a word, and thus recognises/decides a language
15:42:03 <oerjan> Stwange: i think your problem is you think you have to _construct_ the reduction function.  you only have to prove that it exists, given that your language is RE.
15:42:07 <EvilTerran> it's the bottom regex. i forget what it's called.
15:42:25 <Heffalump> tibbe: for 6.8, because they used the .0.foo numbers for release candidates
15:42:31 <chessguy> @quote regex
15:42:31 <lambdabot> No quotes match. The more you drive -- the dumber you get.
15:42:39 <oerjan> Stwange: this means you can assume you have the TM.  from there the rest can be done constructively.
15:42:40 <mrd> E_{TM} = { <M> | M is a Turing Machine with empty language } should be co-semi-decidable
15:42:54 <tibbe> Heffalump: oh, I see
15:43:02 <Stwange> oerjan, so I don't have to make a function? I just have to be able to say... there exists some function that will match a Turing Machine encoding with a string which it accepts, and this will be accepted by A_{TM}?
15:43:23 <tibbe> Heffalump: does that mean I can give mine 0.1 or are all three components required in the .cabal file always?
15:43:36 <Heffalump> I don't know anything about cabal version numbers.
15:44:15 <tibbe> ok
15:44:39 <tibbe> anyone with GHC 6.6 or 6.4 that can check (using ghc-pkg list) which version of mtl those ship with?
15:44:59 <Heffalump> 6.6: 1.0
15:45:18 <mrsolo_> ...
15:45:18 <mrsolo_>     * the Clean Compiler
15:45:18 <mrsolo_> We are adding a new front-end to the Clean compiler that will accept Haskell '98 source code. ..
15:45:24 <oerjan> Stwange: well you have to prove the function exists
15:45:27 <mrsolo_> faster execution?
15:45:47 <tibbe> Heffalump: thanks
15:46:46 <Stwange> oerjan, should I be working backwards from the A_{TM}?
15:46:51 <tibbe> Heffalump: does 6.6 have the base package split? don't remember
15:47:03 <oerjan> Stwange: in some sense your function is trivial.  it is just f(s) = <TM, s>
15:47:18 <oerjan> iiuc
15:47:30 <Stwange> yeah I guessed that oerjan, I just thought it was too vague and wasn't really a proof
15:47:52 <oerjan> the proof is in showing that the function does what it should, though
15:47:53 <Heffalump> tibbe: no
15:48:13 <QoS> anyone here good with rigid variable problem and forall and type-stuff like that? :P
15:48:38 <oerjan> which is also fairly easy once you get cleared up what is assumed and constant, and what actually varies
15:49:14 <Heffalump> QoS: I have a fair bit of experience, but only empirical (i.e. fixing by experimentation)
15:49:33 <Stwange> for every TM there must exist some function that can provide <TM, s> where s is in L(TM), and by the definition of A_{TM} this means that there is some function that maps TM to A_{TM}?
15:49:42 <Stwange> or is that still too vague
15:50:04 <tensh> what's wrong with "send s = local ([s]++) $ return ()"? I use a ReaderT in my type which stores [String]
15:50:08 <tensh> it doesn't seem to add elements
15:50:36 <oerjan> Stwange: there is still some conceptual mixup there
15:51:40 <oerjan> tensh: the local only affects the stored value inside the return () part
15:52:31 <QoS> Heffalump: well I have a function that takes 2 values and a function, for example func (val 1) (val 2) (<=)
15:52:43 <tensh> oerjan: ahh, that stings... is there anyway to update it in a magic way?
15:52:43 <QoS> and it should output true here
15:53:03 <oerjan> tensh: that's what StateT is for
15:53:07 <EvilTerran> tensh, looks like you want State instead of Reader
15:53:23 <tensh> ahh
15:53:23 <QoS> now the problem is that I wanna be able to deal with Bools aswell
15:53:32 <Heffalump> Bools where, in the values?
15:53:33 <tensh> yeah, and [String] with state
15:53:37 <tensh> thanks a lot :)
15:53:44 <QoS> Heffalump: yes
15:53:56 <QoS> forall a. (Num a, Ord a) => a -> a -> Bool
15:54:14 <QoS> since Bool isnt Num it wont work for Bool =)
15:54:29 <EvilTerran> the stored value in Reader is scoped to within the second parameter to local, or to the overall monadic action passed to runReader(T)
15:54:40 <Heffalump> why do you need the Num constraint?
15:54:46 <orzo> is there any page on how to link using gcc instead of ghc?
15:55:10 <dainichi> QoS: if you're providing the comparison function, why do you need those constraints?
15:55:13 <QoS> for it to work with Ints ?
15:55:25 <EvilTerran> ?type modify -- i think this'll be the function you're after, tensh
15:55:28 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
15:55:34 <QoS> I need to to comparison on int, bool and double
15:55:46 <tensh> EvilTerran: yes, I got it now... I was just stupid ;)
15:55:49 <QoS> dont wanna make sepparate functions
15:55:56 <dainichi> they're all instances of Ord
15:55:58 <tensh> I actually did it with state and String once just to practice
15:56:01 <tensh> thanks
15:56:45 <oerjan> tensh: btw if you only are passing s _outward_ then WriterT is also a possibility
15:56:51 <Heffalump> but it would work with Ints with just the Ord constraint
15:57:02 <QoS> hm yea Ord seems to be enough
15:57:14 * Heffalump disappears to bed
15:57:25 <tensh> oerjan: ok, thanks
15:57:39 <QoS> hm I had arithemtic operations there before so thats why I had Num
15:57:57 <QoS> forgot to remove it ;>
16:00:17 <shepheb> the gtk2hs installer fails for me on Windows because of an illegal instruction
16:01:05 <shepheb> hmm, it's only 18KB. something clearly went wrong
16:01:30 <shepheb> okay, download seems to have failed silently. sorry for the noise.
16:01:56 <Stwange> oerjan, can you give me another pointer? I'm not sure exactly what you mean by a conceptual mixup
16:03:20 <oerjan> Stwange: the function should go from the set of words that TM accepts or rejects to the set of words that A_{TM} accepts or rejects.
16:03:37 <oerjan> er
16:03:56 <chot> hi! is there any way to have wheres in lambda functions?
16:04:01 <oerjan> s/that TM accepts/that _a_ given TM accepts/
16:04:11 <tibbe> Heffalump: are you sure, just read the release notes for 6.0
16:04:16 <tibbe> Heffalump: 6.6 I mean
16:04:31 <oerjan> chot: not at their top level, use let instead
16:04:46 <chot> oerjan: ok, thnx
16:04:49 <QoS> tibbe: think he went to bed
16:04:59 <tibbe> ok
16:05:01 <tibbe> ty
16:06:43 <QoS> now if I'd want to do something similiar but for arithmetic without Bool ofc but for Int and Double is there a way to make the typechecker allow it?
16:07:52 <oerjan> QoS: it may be a good idea to write the function without type declaration first, and use :t to find out what the compiler expects the type to be
16:07:57 <QoS> the main problem I think is that Double is instance of Fractional and Int of Integrag
16:08:01 <QoS> *Integral
16:08:17 <QoS> oerjan: I tried that ;p
16:09:06 <oerjan> oh you were doing some higher rank stuff?
16:09:37 <QoS> I guess its rank stuff, tried reading about it but it is confusing
16:09:47 <oerjan> i don't know if it is possible to generalize over the actual class used
16:10:22 <QoS> Other type system extensions.. thats where I read about forall
16:10:28 <QoS> ok
16:11:58 <Stwange> oerjan, wouldn't that be two functions? One it accepts and one it rejects?
16:12:03 * oerjan suddenly wonders if GADTs could do something like that
16:12:41 <oerjan> Stwange: no.  the function should send accepted words to accepted words and rejected words to rejected words
16:13:49 <Stwange> isn't that what the iff takes care of? eg. s is in L iff f(s) in A_{TM}?
16:13:58 <oerjan> yes
16:14:05 <Stwange> oh wait... is that the answer? Just f(TM, s), and the iff takes care of the mapping?
16:14:22 <Stwange> sorry, f(s) = <TM, s>
16:14:30 <oerjan> exactly :)
16:15:24 <Stwange> thanks a lot oerjan, and thanks for making me work for it, frustrating as it was. Now I just got to make sure I know how to write it up...
16:19:27 <bparkis> an observation:  if R is an equivalence relation, then the levelsets of (a R) are the equivalence classes of it
16:20:52 <IsoPallo> Is there a reason why the examples on monads in all the tutorials define (>>=) with something like \s -> let xxx in yyy? would \s -> yyy where xxx be illegal?
16:21:23 <IsoPallo> Or am I just being ignorant?
16:21:28 <Cale> IsoPallo: where isn't an expression form, so s wouldn't be in scope
16:21:31 <bparkis> (that is R :: A -> A -> Bool)
16:21:45 <EvilTerran> wheres don't attach to lambdas
16:21:58 <Cale> IsoPallo: A 'where' clause is part of the function declaration as a whole.
16:22:16 <EvilTerran> Cale, or a case statement
16:22:44 <Cale> case expression? Are you sure?
16:22:49 <IsoPallo> Oh. Ok. Got it.
16:22:54 <cjb> hum, anyone want to recommend any particularly fun Haskell PDFs?
16:23:00 <cjb> (papers, tutorials, whatever)
16:23:14 <oerjan> > case 1 of 1 -> s where s = "quite sure"
16:23:14 <Cale> mm, yes
16:23:14 <lambdabot>  "quite sure"
16:23:26 <Cale> (I just looked at the Report :)
16:23:36 <IsoPallo> Could we have an extension with "where" on lambdas too? :)
16:23:42 <cjb> Cale: I guess I was hoping for something more inspiring than the report :)
16:23:58 <Cale> cjb: Oh, that wasn't directed at you :)
16:23:59 <Cale> hehe
16:24:07 <Cale> cjb: Have you read the STM paper?
16:24:21 <Cale> cjb: In general, Simon Peyton Jones' papers are pretty fun
16:24:31 <dibblego> is "the STM paper" the same as what is written in Beautiful Code?
16:24:34 <cjb> oh!  heh.
16:24:41 <bparkis> I guess "level set" is usually only applied to functions from R^n -> R^m, what is the more general term?
16:24:42 <Cale> dibblego: It's the research paper behind that.
16:24:50 <dibblego> Cale, cheers
16:24:59 <Pseudonym> But today, I'd read the "Beautiful Code" chapter first.
16:25:00 <oerjan> IsoPallo: probably not, but http://hackage.haskell.org/trac/haskell-prime/wiki/LambdaCase has been suggested
16:25:06 <lambdabot> Title: LambdaCase - Haskell Prime - Trac
16:25:12 <dibblego> there was a chapter in Beautiful Code that made me puke
16:25:20 <Pseudonym> Which one?
16:25:26 <oerjan> which would give where from the case statements, i expect
16:25:33 <Cale> bparkis: fibre
16:26:35 <bparkis> ah thanks
16:26:41 <EvilTerran> oerjan, well, you could write "case of PAT -> EXP where BINDS" with that in place of "\PAT -> let BINDS in EXP"
16:26:44 <Cale> bparkis: also see preimage
16:26:48 <bparkis> yup
16:27:06 <oerjan> EvilTerran: that's what i meant
16:27:22 <EvilTerran> indeed
16:27:54 <chot> hm is there any way to raise floats? ^ only does integers
16:28:09 <bos> > 2 ** 3
16:28:10 <lambdabot>  8.0
16:28:12 <bos> > 2 ** 3.5
16:28:13 <lambdabot>  11.313708498984761
16:28:26 <chot> great thnx
16:30:05 <IsoPallo> I was just constantly distracted by running into lets while reading an expression. I would find it cleaner to have any shorthand defined outside the expression as whole...
16:30:17 <IsoPallo> But that's just me :)
16:30:26 <IsoPallo> I'm still learning.
16:30:57 <OceanSpray> In my raytracer, every surface has a "smoothness" value, which determines how accurate the reflection ray is.
16:31:33 <OceanSpray> I was thinking of using a random number generator to simulate this effect,
16:31:46 <OceanSpray> but to do so, I'll have to pass the generator around every function.
16:31:52 <OceanSpray> is there an easier way?
16:31:59 <dmwit> IsoPallo: where clauses/top-level definitions can replace let clauses.
16:32:01 <Stwange> be back soon, thanks oerjan
16:32:11 <dmwit> OceanSpray: State monad?
16:32:31 <dmwit> http://www.haskell.org/haskellwiki/New_monads/MonadRandom
16:32:32 <lambdabot> Title: New monads/MonadRandom - HaskellWiki
16:33:55 <OceanSpray> oy, another monad?
16:34:12 <OceanSpray> and I was hoping to keep this program mostly monad-free.
16:34:38 <Cale> IsoPallo: In many cases, it's quite natural. Especially for things like the definition of bind in the state monad.
16:34:45 <Cale> That is,
16:35:24 <Cale> x >>= f = State $ \s -> let (v,s') = runState x s; (w,s'') = runState (f v) s' in (w,s'')
16:35:30 <Cale> or:
16:35:38 <Cale> x >>= f = State $ \s -> let (v,s') = runState x s; in runState (f v) s'
16:36:05 <Cale> It indicates the order in which we think of the state transformations as occurring, even if the evaluation proceeds in a different order.
16:39:04 <chessguy> heh.  nothing like googling for an algorithm and landing on a page with a haskell fragment that solves it
16:39:34 <dmwit> That seems pretty uncommon, what was the algorithm?
16:39:42 <dons> chessguy: awesome
16:39:48 <Excedrin> quicksort
16:39:52 <dons> i'd love haskell to be  the pseudocode of choice
16:39:57 <dmwit> Pretty awesome, though, yeah. =)
16:40:16 <wagle_home> did you find the quicksort using the type system?  8)
16:40:26 <dmwit> I write in Haskell for all my algorithms class assignments, it's shorter than some people's pseudocode. =)
16:40:28 <Peaker> wagle_home, what's that?
16:40:29 <chessguy> dmwit, http://www.flightlab.com/~joe/sgml/validate.html
16:40:29 <lambdabot> Title: How to validate XML
16:40:47 <chessguy> (though i was actually trying to do XML, and that page has more to do with regexes
16:41:03 <wagle_home> Peaker, http://haskell.org/haskellwiki/Type_arithmetic#An_Advanced_Example_:_Type-Level_Quicksort
16:41:04 <lambdabot> Title: Type arithmetic - HaskellWiki, http://tinyurl.com/2cvjlr
16:42:37 <IsoPallo> Cale: Yes, it is quite natural. It just makes me mentally place the "\s ->" part otside the expression and thus forget it....
16:42:45 <wagle_home> i thought the point of pseudocode is that it didnt have to typecheck..  ie, dont bother avoiding occurs checks, etc
16:43:14 <fophillips> Is GHC architecture dependent?
16:43:40 <wagle_home> sorta..  6.8.2 hasnt been ported to macosx10.5 on ppc
16:43:43 <Peaker> wagle_home, I didn't finish reading the tutorial yet, even :)
16:44:16 <fophillips> Ah yes, just found the platforms page. Sorry.
16:44:29 <wagle_home> it compiles, so has to generate object code and syscalls/etc for the platform
16:46:16 <agl> anyone have an OpenID account with an openidv2 capable provider that can help me with testing?
16:46:31 <agl> (I think a Yahoo account will do)
16:46:49 <Peaker> wagle_home, it could compile to C or such
16:50:15 <shepheb> is there a low-pain way to get Haskell code in place of some Glade XML?
16:50:23 <chessguy> @type foldl
16:50:27 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
16:50:43 <shepheb> I know Glade has a C code output mode, would that and then manually translating be the shortest path?
16:51:43 <chessguy> @pl \e -> n . f d e
16:51:43 <lambdabot> (n .) . f d
16:52:29 <OceanSpray> http://img503.imageshack.us/img503/9740/outov1.png
16:52:52 <OceanSpray> the shadow looks weird.
16:53:06 <roconnor> shepheb: if you click your heals as say ``there is no binding like gtk2hs'' then dcoutts will appear and answer your question. :)
16:53:15 <OceanSpray> how do raytracers usually construct their view rays?
16:53:25 <dcoutts> roconnor: hah hah ha
16:53:46 <oerjan> @remember roconnor if you click your heals as say ``there is no binding like gtk2hs'' then dcoutts will appear and answer your question.
16:53:46 <lambdabot> It is forever etched in my memory.
16:53:57 <roconnor> heels
16:53:59 <roconnor> damn
16:54:03 <dcoutts> shepheb: the answer is no, you have to load the xml at runtime.
16:54:10 <EvilTerran> OceanSpray, your sphere is likely to be eaten by a grue
16:54:10 <oerjan> @forget roconnor if you click your heals as say ``there is no binding like gtk2hs'' then dcoutts will appear and answer your question.
16:54:10 <lambdabot> Done.
16:54:26 <oerjan> @remember roconnor if you click your heels and say ``there is no binding like gtk2hs'' then dcoutts will appear and answer your question.
16:54:26 <lambdabot> I will never forget.
16:54:33 <roconnor> :D
16:54:51 <dcoutts> shepheb: it might be possible to compiler the xml into your prog and load it from memory, but we do not ever translate the xml into haskell code that does the equivalent widget construction
16:54:54 <oerjan> lambdabot, now doing history revisionism :)
16:54:55 <wagle_home> Peaker, it apparently compiles to either C or C--, but i havent looked into the details
16:55:07 <EvilTerran> dcoutts, is such a thing theoretically possible?
16:55:10 <Peaker> wagle_home, that makes it as independent as C is
16:55:17 <dcoutts> shepheb: you'll notice that even generating C code is deprecated, glade-3 does not support that anymore
16:55:28 <dcoutts> EvilTerran: sure, glade-2 did it for C code
16:55:28 <shepheb> dcoutts: okay, that's what I thought. ah, and that's why I can't find the option. sigh.
16:55:52 <shepheb> the libglade dependency is making it cry on Windows. it's not a complex GUI, I'll probably just end up reading the XML and writing code to match.
16:56:02 <wagle_home> Peaker, well, apparently its a pain to get it to work on macosx10.5 on ppc..  (i suspect not much of a pain, but enough of one that it hasnt been done)
16:56:10 <dcoutts> shepheb: the gtk2hs installer comes with libglade
16:56:25 <dcoutts> shepheb: is there a problem with that?
16:56:27 <shepheb> also, I have a TextView that's expanding as I add more text. that's definitely not win, but I'm not sure how to approach it.
16:56:39 <shepheb> oh, really? I must be having path stupidity then.
16:56:54 <dcoutts> put the text view inside a scrolledwindow
16:57:49 <dcoutts> shepheb: btw, Gtk+ now has it's own glade-like xml format and loader built in, some future version of the glade program will be able to generate it (and I think there's a converter too)
16:58:03 <dcoutts> gtk2hs doesn't bind that yet but it should be easy to add
16:58:28 <SamB> dcoutts: glade *like*?
16:58:31 <shepheb> dcoutts: I have Gtk2Hs/lib/glade-2.0.lib, but not the libglade-2.0-0.dll the runtime dies wanting.
16:58:38 <SamB> why didn't they just use GLADE?
16:58:43 <dcoutts> SamB: the xml format is a bit cleaner
16:58:58 <SamB> they, hmm, could have supported both formats?
16:59:11 <dcoutts> there is a converter I think
16:59:11 <SamB> in what sense is it cleaner?
16:59:16 <EvilTerran> that'd be even less clean than using either one
16:59:19 <SamB> oh, converter. that helps a lot ;-)
16:59:32 <dcoutts> SamB: more generic, fewer special cases, so the loader code is simpler
16:59:42 <dcoutts> SamB: and no libxml dependency
16:59:45 <chessguy> does anybody understand http://www.flightlab.com/~joe/sgml/validate.html well enough to comment on how it would be implemented for xml validation?
16:59:45 <SamB> is it cleaner syntactically?
16:59:46 <lambdabot> Title: How to validate XML
16:59:55 <SamB> libxml dependencies are not properties of languages
17:00:32 <dcoutts> SamB: true true that's an implementation detail of the GtkBuilder vs libglade
17:02:10 <bparkis> xml validation couldn't use regular expressions as far as I know
17:02:18 <bparkis> xml is not a regular language
17:02:40 <bparkis> well, it could use them but only for tokenization
17:02:51 <shepheb> dcoutts: the RTS loader and the installation of Gtk2Hs are looking for different files.
17:03:07 <chessguy> bparkis, it's not talking about using regexs to do the xml validation
17:03:13 <chessguy> (i don't think)
17:03:40 <dcoutts> shepheb: can you be more specific?
17:04:05 <dcoutts> shepheb: and you did start from a clean command window after installing gtk2hs, so you get the %PATH% changes that the installer made
17:04:17 <shepheb> dcoutts: I'm not sure, I'm trying that now.
17:04:34 <EvilTerran> bparkis, i think it's using something equivalent to an infinite regular expression
17:04:39 <Laney> Hmm, can someone help me with a (hopefully) simple HaXml question? I have a Document and need to apply a String -> String function to all <body>...</body> nodes but am having trouble getting my head around the combinators.
17:04:44 <EvilTerran> of a certain form
17:05:26 <shepheb> dcoutts: win! it worked. should the Gtk2Hs installer be the only dependency for GHC-less souls on Windows (my app uses Gtk core, Cairo and Glade)
17:06:09 <dcoutts> shepheb: if you're making redistributable binary apps using gtk2hs then there's something a good deal simpler
17:06:19 <EvilTerran> (he said, noting that "infinite regular expressions" would be able to solve any problem, as you could just enumerate every word in the alphabet)
17:06:45 <dcoutts> shepheb: http://haskell.org/gtk2hs/win32/gtk+-2.10.14-win32.zip
17:07:03 <dcoutts> shepheb: and here's a demo installer http://haskell.org/~duncan/gtk2hs/LSystemSetup.exe
17:07:32 <dcoutts> shepheb: that installer does not require ghc or gtk+
17:07:42 <shepheb> dcoutts: awesome, thanks.
17:07:47 <chessguy> EvilTerran, bparkis, seems to be a pretty old article, i doubt it's even still maintained
17:08:19 <SamB> bparkis: see relax NG
17:08:29 <SamB> that's the closest it gets to regular expressions, I think
17:08:37 <SamB> and the spec looks like an FP paper!
17:09:37 <SamB> of course, that's actually more grammers than regexes...
17:11:09 <solrize> so how difficult would it be to take the 1) python; 2) java standard library manuals and reimplement all the modules in haskell?  at least in the python case, there's not THAT much code.
17:11:27 <dons> for python, most of it is done already in one lib or another
17:11:29 <dons> not sure about java
17:11:35 <EvilTerran> java? why'd you *want* to?
17:11:39 <dons> it would be great to identify what libs are missing
17:11:57 <Pseudonym> "Missing" is the wrong word.
17:11:57 <shepheb> dcoutts: does that installer install the Gtk2hs bundle, or something else?
17:12:31 <dcoutts> shepheb: it installs the contents of the .zip file I listed above
17:12:34 <solrize> there's a lot of functions that are half-assedly implemented out somewhere on the net, but i mean something shippable with the compiler, that's at least as reliable as the python or java counterpart
17:12:36 <dons> what facilities aren't availbale?
17:12:43 <shepheb> dcoutts: ah, excellent
17:12:53 <solrize> dons, i'm not sure what's missing, that's part of the question
17:13:05 <solrize> as for java, its libraries tend to be much more feature complete than python's
17:13:27 <dons> so i've done some cross checking against hackage.haskell.org, and python, and they're getting quite close
17:13:36 <solrize> is there something like urllib2?
17:13:45 <dons> what does that do?
17:13:52 <solrize> retrieves web pages
17:13:55 <dons> sure.
17:14:04 <dons> tagsoup, for example, or the curl bindings
17:14:04 <solrize> an http client that understands http authentication, cookies, proxies, etc.
17:14:09 <dons> right.
17:14:19 <solrize> tagsoup is an html parser i thought
17:14:21 <dons> the curl package definitely does.
17:14:24 <solrize> curl bindings is a wrapper for an external program
17:14:27 <solrize> sounds like
17:14:28 <dons> it also downloads pages, and breaks them up
17:14:30 <dons> no, to libcurl
17:14:39 <solrize> hmm that could be ok
17:14:50 <dons> its just a haskell library. but yeah, web stuff is basic functionality
17:14:53 <dons> we're looking beyond that now
17:15:06 <solrize> also would like something like JSSE
17:15:10 <dons> what's that do?
17:15:16 <solrize> TLS / SSL
17:15:27 <dons> ah, like HOpenSSL ?
17:15:32 <solrize> no, written in java
17:15:55 <solrize> not bindings to some crufty C library full of buffer overflows :)
17:15:58 <dons> well, trawl over hackage, and see what you think's missing
17:16:13 <solrize> ok
17:16:29 <solrize> also a fast xml parser, not sure if haxml or hxt qualify, i don't yet understand enough to use them
17:16:46 <dons> there's a binding to expat tnow
17:16:51 <dons> hexpat, on hackage.
17:16:55 <SamB> hmm. bindings to Java? can we do those yet?
17:17:09 <dons> there's about 5 xml parsers. but i think hexpat's probably the fastest
17:17:17 <solrize> samb that's interesting, an FFI -> JNI bridge
17:17:22 <solrize> dons, thanks, i'll look at hexpat
17:17:33 <SamB> solrize: I was thinking more gcj
17:18:01 <darrint> Is there a channel on freenode good for math help?
17:18:07 <EvilTerran> #math
17:18:10 <EvilTerran> perhaps?
17:18:23 <Peaker> mathematicians would never use something that obvious
17:18:26 <SamB> Cale hangs there, it must be good!
17:18:27 <chessguy> yeah, #math isn't too bad
17:18:39 <EvilTerran> also, #haskell works pretty well :)
17:19:05 <darrint> Duh. #math. Thanks.
17:19:09 <Botje> state it as a type question.
17:20:56 <bparkis> I think #math on efnet is better than #math on freenode
17:21:08 <SamB> huh
17:21:12 <Stwange> mrd, sorry to bother you again, but does this sound about right: Given some L that is RE, some f that maps encodings of all TMs to all Strings <TM, w>, and A_{TM}, it follows that w £ TM iff <w,TM> £ A_{TM}
17:21:25 <SamB> #zsnes used to be way worse over there... I wonder if it still is?
17:21:30 <solrize> also it's not enough that   forall x.  exists python library x  => exists haskell library x.
17:21:34 <travisbrady> is there a tool anywhere to show the de-sugaring of the do syntax?
17:22:01 <SamB> @undo do you; think; this <- will help --?
17:22:01 <lambdabot>  Parse error at end of input
17:22:04 <solrize> there's a disease in the python library where someone implements just enough of some protocol to get their application working, then puts it in the library and now "python supports x"
17:22:09 <solrize> but the implementation is actually incomplete or flaky
17:22:11 <SamB> @undo do you; think; this <- will; help --?
17:22:11 <lambdabot>  Parse error at end of input
17:22:23 <EvilTerran> hm
17:22:25 <SamB> @undo do you; think; this <- will; help
17:22:25 <lambdabot> you >> think >> will >>= \ this -> help
17:22:34 <EvilTerran> ah. --? gets parsed as an operator.
17:22:39 <gnuvince_> solrize: you read Olin Shivers' post about sre, eh?
17:22:43 <EvilTerran> > (--?)
17:22:43 <lambdabot> Unbalanced parentheses
17:22:44 <solrize> sre?
17:22:59 <SamB> EvilTerran: that one was your fault
17:23:06 <travisbrady> thanks SamB
17:23:09 <EvilTerran> what
17:23:15 <EvilTerran> > --?
17:23:15 <lambdabot>   parse error on input `--?'
17:23:16 <SamB> EvilTerran: you commented out the paren!
17:23:24 <SamB> well, I think you did...
17:23:38 <SamB> > x --? y
17:23:38 <lambdabot>   Not in scope: `--?'
17:23:38 <EvilTerran> Language.Haskell parses --? as an operator instead of a comment start
17:23:43 <SamB> ah.
17:23:52 <SamB> is that correct?
17:23:55 <Toxaris> ">"-parser /= @undo-parser
17:23:56 <EvilTerran> i have no idea
17:24:08 <SamB> GHCi does too
17:24:16 <EvilTerran> but i always try to leave a space after my --s, just in case
17:24:20 <SamB> so confusing, this comment syntax/operator overlap is
17:24:36 <SamB> > x --# y
17:24:36 <lambdabot>   Not in scope: `--#'
17:24:55 <SamB> hmm, wait, scope error means it got to the compiler, duh...
17:25:10 <Toxaris> > x --? y
17:25:10 <lambdabot>   Not in scope: `--?'
17:25:21 <Toxaris> > (?)
17:25:21 <lambdabot>   Not in scope: `?'
17:25:24 <Toxaris> > (--?)
17:25:24 <lambdabot> Unbalanced parentheses
17:25:26 <Toxaris> > (--? )
17:25:26 <lambdabot> Unbalanced parentheses
17:25:29 <Toxaris> ?
17:25:38 <Toxaris> > (--? x)
17:25:38 <lambdabot> Unbalanced parentheses
17:25:45 <Toxaris> > (x --? x)
17:25:45 <lambdabot> Unbalanced parentheses
17:25:52 <Toxaris> > x --? x
17:25:52 <lambdabot>   Not in scope: `--?'
17:26:07 * Toxaris votes for "broken"
17:26:14 * EvilTerran too
17:26:32 <SamB> I think Language.Haskell must be misparsing the (x --? x) ?
17:26:39 <EvilTerran> that's my theory
17:26:45 <SamB> er.
17:26:51 <SamB> (--?), at any rate
17:26:53 <EvilTerran> something's getting interpreted as a comment that isn't
17:26:57 <SamB> Well, all of them.
17:26:57 <EvilTerran> or vice-versa
17:27:04 <Toxaris> > x --? y )
17:27:04 <lambdabot>  Parse error at end of input
17:27:25 <SamB> GHCi is happy with all of those
17:27:26 <EvilTerran> ?type (x --? x)
17:27:27 <lambdabot> parse error (possibly incorrect indentation)
17:27:42 <Toxaris> > ( x --?php print ")" ?--
17:27:42 <lambdabot> Unbalanced parentheses
17:27:47 <SamB> @undo do you <- like; this -- better?
17:27:47 <lambdabot> like >>= \ you -> this
17:28:03 <SamB> oh, I already got it to work once
17:28:10 <SamB> Toxaris: what the heck?
17:28:30 <SamB> was that some sort of joke about PHP security?
17:28:40 <SamB> (which is itself a joke?)
17:29:00 <Toxaris> SamB: it was a joke about abusing comment-like syntax to mean something
17:29:08 <Toxaris> maybe a bad joke
17:29:22 <SamB> what's with the parens?
17:29:35 <SamB> Haskell also does this!
17:29:43 <SamB> as does SGML
17:30:02 <SamB> well. SGML does it the other way, possibly...
17:30:10 <EvilTerran> {-# THIS IsAMeaningfulComment #-}
17:30:10 <Toxaris> and I don't like it :) a comment is a comment is a comment is not for machines
17:30:13 <SamB> abusing non-comment syntax for comments?
17:30:36 <SamB> <!DOCTYPE -- hi don't you just love it when I do this -- ...
17:30:58 <whee> is there a nice way to clarify main here? http://hpaste.org/6317
17:31:05 <Toxaris> I like the idea of mixing multiple languages in one text file, e.g. pragmas and source code and documentation and ...
17:31:24 <Toxaris> but there should be a dedicated language feature in the "host" language to do so
17:31:40 <EvilTerran> whee, "main = dzen $ xmonad . myConfig"?
17:31:57 <travisbrady> @undo main = do
17:31:57 <lambdabot>  Parse error at "=" (column 6)
17:31:57 <travisbrady>   gen <- getStdGen
17:31:57 <travisbrady>   let ns = randoms gen :: [Int]
17:31:58 <travisbrady>   print $ take 10 ns
17:32:23 <whee> EvilTerran: yes, that works, thanks
17:32:23 <EvilTerran> gotta be on one line, travisbrady
17:32:28 <whee> (I really thought I tried that one :|)
17:32:48 <travisbrady> EvilTerran: i figured, but couldn't get it it to work
17:33:15 <SamB> Toxaris: you don't like pragmas?
17:33:20 <EvilTerran> @undo do gen <- getStdGen; let ns = randoms gen :: [Int]; print $ take 10 ns
17:33:20 <lambdabot>  Parse error at end of input
17:33:30 <travisbrady> @undo do gen <- getStdGen; let ns = randoms gen; print $ (take 10 ns)
17:33:30 <lambdabot>  Parse error at end of input
17:33:34 <solrize> is there something like python's socketserver module, and its cgihttpdserver ?
17:33:35 <SamB> Toxaris: or haddock syntax?
17:33:35 <Toxaris> travisbrady: main = print =<< (take 10 . randoms) `fmap` getStdGen
17:33:36 <EvilTerran> @undo do gen <- getStdGen; let { ns :: Int; ns = randoms gen }; print $ take 10 ns
17:33:36 <lambdabot> getStdGen >>= \ gen -> let {
17:33:36 <lambdabot>                              ns :: Int; ns = randoms gen} in print $ take 10 ns
17:33:42 <solrize> i use that all the time for minimal web apps
17:33:45 <Toxaris> travisbrady: but you have to add the :: [Int] somewhere :(
17:33:56 <EvilTerran> @undo do gen <- getStdGen; let { ns = randoms gen }; print $ take 10 ns
17:33:56 <lambdabot> getStdGen >>= \ gen -> let { ns = randoms gen} in print $ take 10 ns
17:33:58 <SamB> Toxaris: perhaps you will like what Relax NG compact provides?
17:34:11 <travisbrady> Toxaris: ahhh, thank you
17:34:21 <travisbrady> EvilTerran: awesome, didn't know about putting let in braces, thank you
17:34:42 <Toxaris> SamB: exactly. obviously, pragmas and haddock are sensible tools, but they could be better if they were less ad-hock
17:34:46 <EvilTerran> ?type print . take 10 . randoms =<< getStdGen
17:34:47 <lambdabot> IO ()
17:34:51 <EvilTerran> that should work, too
17:35:08 <SamB> (The ability to include arbitrary (logical) XML annotations in a file having reasonable syntax?)
17:36:00 <Toxaris> none of these will work due to missing typing
17:36:16 <Toxaris> it's the show . read problem
17:36:41 <EvilTerran> it works for me - ghc 6.8
17:37:04 <Toxaris> interesting. what does it do and how does it know what to do?
17:37:30 <EvilTerran> it uses (extended?) defaulting to pick the default type as Int
17:37:56 <Toxaris> crazy
17:39:36 <travisbrady> EvilTerran: your final example works for me while hacking in ghci, but won't compile
17:39:53 <EvilTerran> ah. Toxaris++
17:40:20 <Stwange> mrd, if I do a reduction with a formula f(x) = (M, x) for all M, how can I show this is total? Or is that a really dumb question?
17:40:27 <EvilTerran> try "(print :: [Int] -> IO ()) . take 10 . randoms =<< getStdGen" or something
17:41:34 <travisbrady> EvilTerran: perfect, thanks
17:47:27 <MarcWeber> HAppS conatains data MethodMap where ... I've never seen this before. How is this called so that I can look it up?
17:47:53 <MarcWeber> I only know about data Name = Cons ..
17:57:48 <warmenhoven> does anyone here use (or work on) Network.HTTP (http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HTTP-3001.0.4)?
17:57:50 <lambdabot> http://tinyurl.com/yr2pgg
17:58:23 <MarcWeber> warmenhoven: Whats your problem?
17:58:55 <warmenhoven> MarcWeber: it's using the absolute uri in my GET requests, and some web servers don't like that.
18:00:25 <MarcWeber> warmenhoven: If it doesn't work I think HAppS does also contain a http client (but I've never used it) Without reading source I can't tell you anything about this topic :(
18:00:53 <warmenhoven> MarcWeber: sorry, HAppS? (i'm still new here)
18:01:19 <EvilTerran> ?where happs
18:01:19 <lambdabot> http://happs.org
18:01:24 <EvilTerran> ... handy
18:01:28 <warmenhoven> EvilTerran: thanks
18:02:25 <MarcWeber> warmenhoven: But it might be overkill because it's the webserver itself containing simpleHTTP client get function
18:05:52 <dcoutts> warmenhoven: it's it correct to use the full uri? that's http-1.1 iirc. it allows virtual servers etc
18:06:06 <dcoutts> it's is / isn't it
18:06:20 <EvilTerran> dcoutts, i thought that's what the compulsary Host: header (or whatever it's called) is for
18:06:31 <warmenhoven> dcoutts: the spec says servers are required to accept it but clients 'must' use the path, and use the Host: header
18:06:45 <warmenhoven> dcoutts: anyway, some servers don't like it.
18:06:57 <dcoutts> oh ok, well send a patch to the http lib, sounds simple
18:09:15 <slowriot> Hello #haskell
18:09:30 <solrize> host: is an http 1.1 thing, but almost all clients send it even with http 1.0 requests and just about all servers understand it
18:10:16 <solrize> what are the rules about getting something into hackage?
18:10:26 <slowriot> What situations are C still used in as opposed to C++? It seems like it is pretty popular for language and OS API's.
18:10:55 <dcoutts> solrize: if you're the package author you just request an account and then upload
18:11:09 <solrize> dcoutts, hmm, thanks
18:11:14 <slowriot> Is this because cdecl is a standardized calling convention?
18:11:21 <slowriot> I realize that this isn't a haskell question.
18:11:48 <solrize> slowriot i think C is still used for lots of low level things and as such, its usage has been staying steady, while C++ is maybe on the decline
18:11:55 <solrize> C++ is for writing big applications that crash :)
18:12:10 <dcoutts> slowriot: C calling convention is the standard cross language ABI
18:12:33 <slowriot> by C calling convention, do you mean cdecl?
18:12:39 <dcoutts> yep
18:14:43 <slowriot> So languages know which intructions they need in order to call a C function, but if they tried to call some other language's (like C++'s) functions, the necessary set of instructions could differ depending on the compiler?
18:15:00 <thoughtpolice> is there a way in emacs-mode to put the portability/stability/maintainer clause at the beginning of a module?
18:15:19 <solrize> slowriot, for ordinary functions c++ calling conventions should be the same as C's.  i think.
18:18:29 <slowriot> solrize: I think you're right. VC++ 8's default calling convention is cdecl
18:18:42 <slowriot> other options are fastcall and stdcall
18:19:22 <slowriot> so cdecl is the standard calling convention, why not use C++ for language API's?
18:20:08 <BMeph> "<solrize>	C++ is for writing big applications that crash :)"
18:20:27 <shteou> :f
18:21:05 <dcoutts> slowriot: the C and C++ conventions are the same, you only use the C++ extensions if you're passing C++ objects and you don't want to do that in language other than C++
18:21:11 <glen_quagmire> c++ is for professional enterprise systems just like java. they are not for research like haskell
18:21:40 <SamB> but C uses different naming
18:21:55 * SamB thought C++ was for crashing
18:22:21 <Mr_Awesome> C seems to crash a lot more than C++
18:22:22 <scook0> dcoutts: what about overloaded functions?
18:22:25 <kencausey> Is $ used just to eliminate a set of parentheses?
18:22:26 <slowriot> I'm still not sure why C is preferred over C++ for language API's
18:22:46 <Mr_Awesome> kencausey: a lot of times. but it can also be passed to a higher-order function :)
18:22:54 <dcoutts> scook0: the linker symbol mangling is different, the calling convention is the same
18:22:55 <kencausey> OK, I see
18:23:10 <scook0> fair enough
18:23:12 <kencausey> thanks
18:23:16 <SamB> slowriot: C++ is a heck of a lot more complicated, involves name mangling, calling conventions/packing are NOT the same,
18:23:17 <glen_quagmire> @src ($)
18:23:17 <lambdabot> f $ x = f x
18:23:35 <Mr_Awesome> wow. that was fast...
18:23:45 <slowriot> so C++ uses cdecl and C uses cdecl, but they are different cdecls?
18:23:45 <SamB> slowriot: cannot be called by C code unless it uses appropriate names...
18:23:52 <glen_quagmire> @fixity ($)
18:23:52 <lambdabot> Unknown command, try @list
18:24:23 <SamB> slowriot: well, if you foreign export "C" it works alright...
18:24:41 <SamB> C++ just has so many *more* things to have conventions aboud...
18:24:43 <ivan__> i have a Tree a = Node a (Tree a) (Tree a) and i want to create a Tree (a,Int) where the int is a uniq number to all nodes, how do i traverse through the tree?
18:24:53 <slowriot> SamB: I see
18:25:08 <slowriot> You can return C structs from C functions, right?
18:25:19 <SamB> yeah
18:25:50 <slowriot> it would just allocate the data on the heap and then return a pointer to it, or something along those lines
18:25:52 <Stwange> does this sound about right for a turing reduction function? Given a language L, f(w) = (Bi, w) such that Mi recognises L?
18:25:52 <SamB> but the FFI won't work with that...
18:25:56 <SamB> slowriot: no!
18:26:05 <SamB> it probably would go on the stack
18:26:13 <SamB> possibly in registers, depending on ABI
18:26:34 <slowriot> SamB: Yeah, otherwise you would have to worry about freeing it
18:27:32 <glen_quagmire> traverse (Node (a,i) l r) = Node (a, i++) (traverse l) (traverse r)  where i++ is incrementing i
18:28:16 <glen_quagmire> hrm i'm not sure how to get unique number among members of a structure
18:28:28 <Cale> glen_quagmire: hm?
18:28:49 <slowriot> it seemse like you could handle class objects and structs the same way, though
18:28:54 <Cale> glen_quagmire: Oh, perhaps I see what you're doing?
18:28:59 <SamB> glen_quagmire: State monad?
18:29:06 <glen_quagmire> < ivan__> i have a Tree a = Node a (Tree a) (Tree a) and i want to create a Tree (a,Int) where the int is a uniq number to all nodes, how do i traverse through the tree?
18:29:12 <Cale> glen_quagmire: You're trying to number the nodes of a tree?
18:29:14 <glen_quagmire> i was trying to help ivan__  but i failed
18:29:18 <Cale> ah
18:29:24 <SamB> glen_quagmire: use State
18:29:46 <Cale> Well, before we go looking at the state monad, I think it's informative to see how to do this in a pure way.
18:30:01 <glen_quagmire> State monad is the next section . /me studies Reader monad now
18:30:21 <Cale> We'll define the function traverse' :: Integer -> Tree a -> Tree Integer
18:30:45 <Cale> er...
18:30:51 <Cale> We'll define the function traverse' :: Integer -> Tree a -> (Integer, Tree Integer)
18:31:15 <SamB> Cale: you just drop the data on the floor?
18:31:19 <slowriot> so when VC++ 8 says it uses "cdecl" does it really mean "cdecl with c++ extensions"? Come to think of it, it says __cdecl. Is that different than cdecl?
18:31:21 <Cale> It will label the nodes of the tree with Integers, starting with the given one, and give us back the next integer after the largest that it used.
18:31:24 <tensh> ivan__: for the non-monad version, do a helper function with the signature "label' :: Tree a -> Int -> (Tree (a,Int), Int)
18:31:31 <tensh> "
18:31:36 <tensh> worked just fine for me
18:31:42 <Cale> ah, you want to keep it?
18:31:47 <Cale> That's no harder.
18:31:57 <SamB> that's basically what Cale just said, except Cale was apparantly going to just make a tree of Integers
18:32:01 <Cale> traverse' :: Integer -> Tree a -> (Integer, Tree (Integer,a))
18:32:10 <SamB> and didn't realize you wanted to have the integers along with the existing data...
18:32:15 <tensh> yeah, it's just that I did the exercise 2 hours ago :)
18:32:32 <SamB> somehow having missed the types glen_quagmire mentioned
18:32:51 <glen_quagmire> what exercise is this from tensh ?
18:33:07 <tensh> practice exercises for the course at our school
18:33:13 <Cale> ivan__: Are your trees really infinite, or do they have a base case? :)
18:33:29 <glen_quagmire> yah you need    | Leaf a    probably
18:33:39 <Cale> Or  | Tip
18:33:40 <tensh> there's Empty as well
18:33:41 <ivan__> Cale: basecase
18:34:21 <Cale> So we have:  traverse' n Empty = (n, Empty)
18:34:40 <tensh> pretty much
18:35:16 <ivan__> Cale: think it should be traverse' n Empty = Empty
18:35:30 <tensh> ivan__: make a helper function
18:35:32 <Cale> ivan__: no, because you need to return the next label to be used
18:35:53 <Cale> ivan__: In the empty tree case, you haven't used up any labels, so you just pass n along.
18:36:08 <ivan__> Cale: ahaa, thats right
18:36:10 <tensh> and then just do "let (tree,_) = label' tree 0 in tree" or something
18:36:10 <ivan__> =)
18:37:23 <Cale> traverse' n (Branch x l r) = let (n',l') = traverse (n+1) l; (n'',r') = traverse n' r in (n'', Branch (n,x) l' r')
18:37:26 <tensh> ivan__: look forward to doing it with state monads. they're really handy
18:37:45 <OceanSpray> @src minimum
18:37:45 <lambdabot> minimum [] = undefined
18:37:45 <lambdabot> minimum xs = foldl1 min xs
18:37:53 <ivan__> tensh: that is the next question =)
18:38:45 <Cale> These sound like exercises I'd give.
18:38:50 <tensh> ivan__: I know... we're probably taking the same course :)
18:38:53 <OceanSpray> @src foldl1
18:38:54 <lambdabot> foldl1 f (x:xs) = foldl f x xs
18:38:54 <lambdabot> foldl1 _ []     = undefined
18:38:59 <OceanSpray> @src foldl2
18:38:59 <lambdabot> Source not found. Take a stress pill and think things over.
18:39:02 <OceanSpray> ???
18:39:03 <TSC> Ha
18:39:07 <Cale> hehe
18:39:08 <OceanSpray> @src foldl
18:39:08 <lambdabot> foldl f z []     = z
18:39:08 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
18:39:14 <Stwange> is anyone still around that understands Turing reductions and has a minute or two to spare?
18:39:19 <ivan__> tensh: this course sux
18:39:37 <OceanSpray> Oh, I see what it is now.
18:39:39 <tensh> ivan__: I'm not very happy with the layout either
18:39:48 <tensh> though it's interesting when you sit down and do things properly
18:40:08 <tensh> in my opinion at least
18:40:14 <ivan__> tensh: Assignments + exam + project = too much
18:40:20 <tensh> ivan__: did you do your presentation?
18:40:29 <tensh> yes, I think so too
18:40:34 <TSC> There's barely time to fit in IRC!
18:40:34 <ivan__> tensh: nope, i am doing it on friday
18:40:44 <tensh> lucky bastard ;)
18:40:50 <ivan__> have u done it?
18:40:53 <tensh> doing it tomorrow and I have nothing to show so far
18:41:03 <Cin> what's the coolest thing in haskell at the moment?
18:41:05 <OceanSpray> :t foldl
18:41:09 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
18:41:13 <ivan__> tensh: me neither =) but i have a first draft ready but it realy sux
18:41:18 <OceanSpray> :t foldl1
18:41:19 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
18:41:32 <tensh> I made a mistake in chosing project and now I'm just kind of stomping ground on square one
18:41:45 <ivan__> tensh: what is the project about?
18:41:49 <tensh> fudgets
18:41:52 <tensh> you?
18:42:16 <ivan__> embedded language for frequency analasis =)
18:42:21 <glen_quagmire> ivan__: do you want to label Node only or Empty too?
18:42:33 <ivan__> glen_quagmire: just the nodes
18:42:57 <glen_quagmire> and the numbers of Nodes should not have gaps?
18:43:28 <ivan__> glen_quagmire: dosn't matter just it is a uniq number for all nodes =)
18:43:32 <tensh> it can be done without gaps without too much hassle
18:44:04 <tensh> Cale already gave away the answer :)
18:44:45 <tensh> though I'm not sure if the numbers will turn out alright at it, but that can easily be fixed with some minor adjusting
18:45:24 <ivan__> tensh: but there is not much of an example it just says an uniq integer
18:45:41 <tensh> yes, but still ;)
18:45:59 <ivan__> :p first thing to do is to get it to work =)
18:47:22 <tensh> actually, the task right after is about state monads so I'm pretty sure they mean that it's supposed to be in order
18:47:39 <tensh> it's kind of like a comparison
18:47:55 <\z> anyone here familiar with the cabal libs (Distribution.*)?
18:51:21 <Saizan> \z: better to just ask your question
18:51:54 <\z> I'm reading through the library sources, and it all just seems a little complex
18:52:09 <\z> I'm wondering if I'm missing something fundamental here....
18:53:58 <Saizan> are you looking for something in particular?
18:55:06 <\z> Saizan: not yet.  Just trying to get my feet wet at the moment
18:55:06 <Saizan> i've only dealt with the Distribution.Simple.* tree for now, though
18:55:36 <\z> I've run Distribution.* through a short little program to build a dependency graph, and fed that to dot
18:55:45 <\z> the output was, um, rather complicated
18:56:14 <\z> even whittling out a lot of the modules, it's still fairly hairy
18:57:23 <roconnor> @wn breaching
18:57:24 <lambdabot> No match for "breaching".
18:57:29 <roconnor> @wn breach
18:57:29 <lambdabot> *** "breach" wn "WordNet (r) 2.0"
18:57:29 <lambdabot> breach
18:57:29 <lambdabot>      n 1: a failure to perform some promised act or obligation
18:57:29 <lambdabot>      2: an opening (especially a gap in a dike or fortification)
18:57:29 <lambdabot>      3: a personal or social separation (as between opposing
18:57:31 <lambdabot> [8 @more lines]
18:58:46 <glen_quagmire> ivan__: http://hpaste.org/6318
18:59:57 <BMeph> Just wondering, but are triple-stacked monad structures a usual thing for a "real" application, or do things (the structure of the data) get broken down before that point?
18:59:58 <Saizan> \z: uhm yeah i can imagine that, however i'd start with looking at Distribution.Simple, that's the main entry point, and see how it pulls in the pieces
19:03:02 <Saizan> BMeph: it seems quite common, sometimes unrolling the stack can get some performance improvements
19:03:11 <\z> Saizan: I started with that, but even Distribution.Simple loads 20+ modules
19:03:22 <\z> So I thought I'd start bottom up, and that's no easier.  ;-)
19:04:17 <\z> Saizan: Plus, figuring out Cabal alongside cabal-install is difficult, because it's not immediately obvious what parts cabal-install is superceding
19:04:18 <ivan_> glen_quagmire: i have alredy fixed it but thx =) can check out your solution
19:05:29 <BMeph> Saizan: Okay, it just looks...complicated, that's all. :)
19:05:46 <Saizan> \z: well cabal-install just uses what cabal provides via Distribution.Simple.SetupWrapper, the specific things are the bits that interact with hackage
19:06:10 <\z> I'm wondering if there's a simpler way to do all this
19:06:18 <ivan_> glen_quagmire: you write nice code =)
19:06:53 <Saizan> BMeph: really? i found that mixing transformer to get your finely tuned monad can simply the code a lot
19:07:01 <Saizan> "simplify"
19:08:40 <Saizan> \z: that would be appreciated i guess, but most of the modules are dedicated to a specific command
19:09:13 <BMeph> Saizan: Well, that's my next step - figuring out the right transformer, and how to use it. ;)
19:11:10 <Saizan> BMeph: seen this? http://cale.yi.org/index.php/How_To_Use_Monad_Transformers
19:11:13 <lambdabot> Title: How To Use Monad Transformers - CaleWiki
19:15:00 <BMeph> Saizan: I've read thro' sigfpe's blog on them and the Wikibook blurb. I'll give it a look-see, couldn't hurt (much)... ;)
19:24:38 <lispy> \z -> z + 1
19:24:49 <lispy> interesting nick...
19:27:04 <\z> lispy: thanks
19:27:12 <\z> @hpaste
19:27:12 <lambdabot> Haskell pastebin: http://hpaste.org/new
19:27:29 <dino-> Is it arbitrary that Maybe is an instance of Monad but Either itself isn't?
19:27:40 <SamB> @instances Monad
19:27:41 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
19:27:43 <hpaste>  \z pasted "Is Distribution.* complex?" at http://hpaste.org/6319
19:27:46 <SamB> dino-: it isn't?
19:27:59 <dino-> Hm, not according to the docs on my system.
19:28:10 <\z> Saizan: I started with a simple question: how do I find out what modules are installed
19:28:14 <\z> (I forgot how I got there)
19:28:18 <dino-> Did it not used to be?
19:28:39 <\z> going through the cabal-install and Cabal codebases, that paste seems to be the simplest way to do it
19:29:11 <\z> that simple question loads 7 modules explicitly, and 34 modules in total from Distribution.*, and that seems like a lot to me...
19:29:27 <SamB> dino-: import Control.Monad.Error
19:29:32 <SamB> also install the mtl
19:29:37 <dino-> I was looking at Data.Either
19:30:44 <dino-> So I guess part of what I'm confused about is why is Data.Maybe instanced into Monad but Data.Either is not.
19:31:25 <TSC> "Either e" is
19:31:32 <TSC> Either alone can't be, because it has the wrong kind
19:32:20 <lispy> dino-: yeah, exactly what TSC said
19:32:58 <lispy> dino-: it's a good observation BTW
19:33:15 <TSC> > Left "x" >> Right 10
19:33:16 <lambdabot>  Left "x"
19:34:15 <dino-> lispy: Hey, thanks for saying so. I'm horrified by lack of progress with monads after all this time.
19:34:29 <dino-> So, wait, why did that just happen with the (>>) ?
19:34:44 <lispy> ?src Monad (Either String)
19:34:44 <lambdabot> Source not found.
19:35:03 <lispy> dino-: because for Monad (Either String), fail = Left
19:35:23 <TSC> The semantics of >>= for the Either e monad is "stop when you hit a Left"
19:35:42 <dino-> Ah, like Maybe.
19:35:54 <dino-> It's the fail condition.
19:35:55 <dino-> ok
19:36:04 <TSC> > Right 10 >> Right 5 >> Left "!" >> Right 15 >> undefined
19:36:05 <lambdabot>  Left "!"
19:36:08 <TSC> > undefined >> Right 10 >> Right 5 >> Left "!" >> Right 15 >> undefined
19:36:09 <lambdabot>  Undefined
19:36:19 <TSC> So in the first case, the undefined is never reached
19:36:23 <dino-> So the left here is terminating everything.
19:36:26 <Korollary> There ought to be a crash-and-burn monad where failure goes as deep as possible.
19:37:05 <dino-> What I have is poor code with deeply nested case and if statements checking things for Just or Nothing and in some cases generating error messages. I can see enough to know that's like 4 kinds of not right.
19:37:29 <TSC> Either String sounds like a good match for that
19:38:29 <lispy> doesn't the all about monads website have an example of this?
19:38:46 <dino-> It definitely talks in detail about Maybe
19:39:06 <lispy> dino-: this is probably right at your level: http://www.haskell.org/all_about_monads/html/errormonad.html
19:39:07 <lambdabot> Title: The Error monad
19:39:47 <lispy> and there is another paper I'm thinking of that illustrates this concept
19:39:48 * shepheb refactored some of his command-parsing code into Either String a, with a big win as a result
19:39:49 <lispy> hm...let me find it
19:41:12 <tensh> shepheb: congratulations :)
19:41:51 <lispy> dino-: this is more about monad transformers, but don't be scared,  you've stared down this path and soon you'll be able to grok this well written intro guide: http://uebb.cs.tu-berlin.de/~magr/pub/Transformers.pdf
19:42:43 <dino-> lispy: I just went through that over the past couple of weeks and it was very good.
19:43:16 <dino-> I was surprised by all the lifting instances that already exist for these things, the do blocks magically were devoid of lifts everywhere except for IO.
19:43:33 <lispy> yeah, monad transformers are life savers
19:44:49 <dino-> But why isn't there a runMaybe ?
19:45:21 <BMeph> dino-: "Either" has kind * -> * -> *, so it wouldn't fit as a Monad. "Either e" does, though. :)
19:45:43 <TSC> What would runMaybe do?
19:47:19 <TomMD> ?vixen Do you hear the crickets chirping?
19:47:19 <lambdabot> i'll hafta plead the fifth on that one.
19:48:07 <dino-> I'm not really sure. I see this elsewhere like runIdentity, runState
19:48:23 <dino-> And it was explained here once that there's sort-of a hidden runIO that goes on outside of main
19:48:30 <TomMD> but Maybe monads don't really need an extra part passed in, like an initial state ;-)
19:48:34 <dino-> Or you could think of it that way perhaps.
19:49:25 <TSC> There are fromJust and fromMaybe for pulling the "a" out of a "Maybe a"
19:49:31 <BMeph> dino: run<insert a Monad name> usually indicates a Monad Transformer execution.
19:49:41 <OceanSpray> oy, I've got a problem.
19:50:09 <BMeph> OceanSpray: Name it, and Claim it! ;)
19:50:42 <BMeph> ...or just talk about it, and maybe someone else'll help you solve it. :)
19:50:45 <TomMD> Carefule - if BMeph finds your address you'll get a bill for five dollars a minute.
19:51:14 <hpaste>  morrow pasted "first start at an (x)html form widget lib" at http://hpaste.org/6321
19:51:17 <TomMD> ;-)  Just kidding BMeph.... althought, that isn't such a bad idea....
19:51:20 <OceanSpray> It's that raytracer I wrote.
19:51:29 <OceanSpray> I changed some code, and added refraction.
19:51:40 <OceanSpray> now all I get is blackness with every render.
19:51:45 * BMeph has a chat with his "$3-a-minute" killer deal "friends...
19:51:49 <BMeph> TomMD: ;)
19:51:59 <hpaste>  (anonymous) annotated "first start at an (x)html form widget lib" with "+" at http://hpaste.org/6321#a1
19:53:32 <dino-> Thank you for the help.
19:56:39 <lispy> OceanSpray: You're bending the light too much and now it's missing the camera :)
19:56:48 <dino-> The instances list in the Haddock doc for Control.Monad is very short and doesn't have Either e and many things. Is this something about how the docs were generated?
19:56:58 <dino-> Like things in mtl, maybe not noted there, or something similar?
19:57:31 <lispy> :t fromMaybe
19:57:32 <lambdabot> forall a. a -> Maybe a -> a
19:57:38 <lispy> > fromMaybe Nothing
19:57:38 <lambdabot>  Add a type signature
19:57:44 <lispy> > fromMaybe 1 Nothing
19:57:45 <lambdabot>  1
20:01:06 <scook0> @instances Monad
20:01:07 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
20:01:36 <lispy> dino-: maybe we need to look at the Haskell 98 report to find that instance
20:02:01 <SamB> what should an enum instance for arithmatic mod foo do?
20:03:16 <TomMD> SamB: I like throwing exceptions instead of rolling over.  I'm sure someday code will unexpectably terminate as a result, but this is better than an unexpected rollover on succ.
20:03:44 <SamB> TomMD: this is DELIBERATELY mod foo...
20:03:55 <orzo> where can i get the hlist paper?
20:04:13 <orzo> i used google, but the link wont work
20:04:40 <lispy> dino-: actually, I'm not finding much in the report about instance Monad (Either e)
20:04:48 <dino-> Me either.
20:05:03 <SamB> it isn't there
20:05:16 <SamB> it *is* apparantly in Control.Monad.Error...
20:06:12 <orzo> i want to use the ffi to access certain c++ classes
20:06:29 <orzo> what sort of interface would you give it?
20:06:31 <lispy> orzo: http://homepages.cwi.nl/~ralf/HList/ this?
20:06:32 <lambdabot> Title: Strongly typed heterogeneous collections
20:06:43 <SamB> what has hlist to do with C++?
20:06:56 <orzo> lispy, that looks right.  Page wont load for me
20:07:02 <lispy> orzo: weird
20:07:13 <SamB> orzo: find a proxy?
20:07:14 <lispy> orzo: that's a link directly to the pdf, try thathttp://homepages.cwi.nl/~ralf/HList/paper.pdf
20:07:30 <lispy> er with out junk on the http: http://homepages.cwi.nl/~ralf/HList/paper.pdf
20:07:38 <orzo> SamB, well there's a scheme of implementing an OO system where the instances are HLists
20:07:51 <lispy> orzo: you want OOHaskell?
20:08:09 <lispy> that would be here: http://homepages.cwi.nl/~ralf/OOHaskell/
20:08:09 <lambdabot> Title: Haskell's overlooked object system
20:08:10 <SamB> orzo: but it seems like you will not have the HList code anywhere near the C++ code...
20:08:16 <TomMD> Is there a good document showing off haskell-src or should I just hash things out based on haddock?
20:08:26 <Stwange> is it a hamilton or a hamiltonian cycle? Google can't seem to make up its mind
20:08:47 <lispy> is it tower of hanoi or towers of hanoi?
20:08:52 <orzo> well really, what i have is pure abstract class interfaces and i want to make them available to haskell
20:08:54 <shepheb> Stwange: xkcd used hamiltonian :P
20:08:57 <SamB> doesn't hamiltonian just mean "in the way of hamilton"?
20:09:09 <orzo> so i have a class with only pure virtual functions
20:09:16 <Stwange> heh, thanks shepheb I've never known them to be wrong
20:09:18 <BMeph> orzo: Have you tried CiteSeer? :)
20:09:22 <lispy> knuth claims it's tower of hanoi
20:09:26 <orzo> and i want to wrap it up in some way and call it from haskell
20:09:31 <orzo> no, i haven't tried anything yet
20:09:40 <orzo> I've never heard of CiteSeer
20:09:47 <lispy> CiteSeer is a paper archive
20:10:00 <orzo> oh
20:10:01 <lispy> with biblio info and such
20:10:07 <SamB> orzo: well, step one is to write some extern "C" wrappers...
20:10:38 <scook0> if your calling code only ever deals with the abstract interface, it shouldn't be too hard to make a wrapper
20:10:53 <lispy> orzo, SamB is right, I don't think there is any way to make the object oriented part of C++ interface directly with Haskell
20:11:12 <SamB> lispy: or a point
20:11:27 <SamB> if it's just a pure virtual interface
20:11:36 <lispy> my understanding of the FFI is that it only works with things that are linkable to good old-fashioned C code.
20:11:49 <shepheb> @index EitherT
20:11:50 <lambdabot> bzzt
20:11:55 <orzo> well
20:11:57 <BMeph> Ah, OOHaskell is an Oleg Production. Figures. :)
20:11:59 <dino-> Is that lambdabot that's so clever with the @instances? I may need to get one of those running locally for offlineness.
20:12:10 * lispy grumbles about OOHaskell
20:12:16 <lispy> I never could get it to type check!
20:12:48 <orzo> i'll do what i have to do, i suppose, but where i'm starting is these pure virtual classes, and I want to make them available to haskell and I'm not sure what it should look like when it's all done
20:13:11 <lispy> I don't know if my GHC was buggy or what, but I tried to wrap HList and OOHaskell into cabal sized libraries, but none of the examples worked when I compiled things that way.  It was bizarre.
20:13:17 <orzo> i mean an instance might be a function of an algebriac type whose constructors are all methods
20:13:23 <orzo> or i might do it some other way
20:14:07 <orzo> each method might be an ordinary haskell function that accepts an instance parameter
20:14:27 <lispy> orzo: that last one is pretty common i believe
20:14:37 <lispy> that is how C++ does it under the hood too
20:14:39 <orzo> or each method might be a field in an OOHaskell instance
20:15:02 <lispy> orzo: if you get the OOHaskell approach to work that would be interesting.
20:15:42 <lispy> orzo: but I'd read the OOHaskell paper before I worry too much about putting the OOHaskell library to use.  They made a good point in the begining of the paper that many OO concepts can be mapped into 'standard' hasakell.
20:16:00 <lispy> and by making the point, I mean they show you how to do the mapping.
20:16:35 <orzo> well
20:16:43 <hpaste>  SamB pasted "Someone please fill in Enum ?" at http://hpaste.org/6322
20:16:52 <orzo> i suppose i just want to obey an established idiom for this
20:17:13 <orzo> how do people normally do up c++ class interfaces for haskell?
20:17:15 <SamB> orzo: probably the paper will explain that ;-)
20:17:24 <orzo> i have the OOHaskell paper
20:17:28 <SamB> the standard idioms, I mean...
20:17:30 <orzo> but it sort of depends on the hlist paper
20:17:45 <SamB> the standard idioms won't...
20:17:47 <lispy> orzo: I think the way you suggested of making haskell functions who's first parameter is a reference to an instance would be the most natural.
20:17:48 <orzo> that's why i was trying to get the hlist paper
20:17:57 <Stwange> hey dibblego :)
20:18:04 <SamB> a Ptr, actually
20:18:11 <Stwange> :(
20:18:25 <lispy> orzo: that's the way C++ does it under the hood and I don't really see a problem with it
20:18:40 <SamB> that's pretty much the Haskell idiom, anyway...
20:19:06 <orzo> ok, but it does put all my class methods in the namespace
20:19:21 <SamB> *that* is unavoidable
20:19:22 <lispy> orzo: use the module system to control that
20:19:38 <orzo> so one module per class?
20:19:38 <lispy> orzo: one module per class and only export what you want to export
20:20:04 <lispy> Yes, the Haskell module system is very similar to classes in most OO languages.
20:20:15 <lispy> It's not as fancy, but it maps to that somewhat.
20:21:36 <orzo> ok
20:21:54 <orzo> it'd be nice if my bindings could be auto generated
20:22:10 <lispy> There has been work in that direction.
20:22:15 <orzo> for c++?
20:22:19 <lispy> for C
20:22:19 <lament> heh, earlier today i wrote a long rant about how i like OO for its namespace compartmentalization.
20:22:41 <lament> (which you can sort of fake in haskell with modules, but it's way less nice)
20:23:00 <lispy> orzo: If you know perl or some similar language that has partial or full C++ parser I bet you could auto generate those.
20:23:05 <lament> probably the feature i miss the most in haskell...
20:23:29 <orzo> i have a partial c++ parser implemented in scheme
20:23:32 <lispy> orzo: I don't know that perl has such a parser, but it wouldn't surprise me.
20:23:45 <Stwange> this might be a really stupid question, but I have been here for ~20 hours... is an undirected hamiltonian cycle equivalent to a directed one where the first edge (v,w) found is directed and all others discarded?
20:24:11 <orzo> it's probably not worthwhile for me to make it work automatically at this point though
20:24:30 <lispy> orzo: no but it is a reasonable goal
20:24:32 <orzo> there's only 2 or three interfaces
20:24:38 <Stwange> all other (v,w) discarded that is
20:24:48 <lispy> Stwange: I would ask in #math.
20:25:12 <Stwange> thanks lispy :)
20:25:20 <lispy> Stwange: good luck :)
20:25:37 <SamB> the only project I'm aware of that does large-scale binding to C++ from Haskell re-uses data from an Eiffal binding for the same library...
20:25:44 <SamB> (wxHaskell)
20:26:06 <lispy> we have a C parser in Haskell now as a library right?
20:26:16 <lispy> if so, then it's time we had one for C++
20:26:29 <SamB> it's a library now?
20:26:33 <SamB> dcoutts: is this true?
20:26:45 <lispy> It was very close to being a library (I thought) quite awhile ago.
20:26:49 <lispy> I'll go check hackage
20:26:55 <SamB> that's what dcoutts said, yes
20:27:08 <SamB> but he didn't seem to actually be planning on doing the work or anything
20:27:22 <SamB> seemed to be waiting for someone else to do it
20:28:24 <lispy> well no C or C++ parsers on Hackage
20:28:58 <glen_quagmire> can a language's parsing be undecidable?
20:29:19 <lispy> http://www.cse.unsw.edu.au/~chak/haskell/c2hs/
20:29:20 <lambdabot> Title: Manuel M T Chakravarty - C->Haskell
20:29:32 <lispy> glen_quagmire: yes, see the recent article about parsing perl
20:30:31 <glen_quagmire> oh right. that was only for _parsing_ perl
20:31:09 <orzo> is it possible to implement a haskell module entirely from c?
20:31:15 <SamB> oh, by the way, http://hpaste.org/6322 implements modular arithmatic parameterized by the modulus (expressed at the type level)...
20:31:25 <lispy> glen_quagmire: I guess the formal and traditional definition of parseable forces it to mean that it's decidable.  But, then that's why thay say perl isn't parseable.
20:32:05 <lispy> orzo: I think so.
20:32:13 <lispy> orzo: depending on what you mean
20:32:20 <lispy> orzo: You'd have to define the FFI
20:32:44 * lispy heads home
20:34:01 <orzo> so i can compile Foo.c into Foo.o and then use the Foo module from haskell by linking in Foo.o
20:34:11 <SamB> orzo: eh?
20:34:17 <SamB> no...
20:34:24 <SamB> you need to use the FFI...
20:34:51 <Cale> http://www.marriedtothesea.com/031208/y2k-bug.gif
20:35:30 <SamB> orbitz?
20:35:37 <orbitz> samb?
20:35:42 <SamB> is that the drink with the oddly suspended orbs?
20:35:43 <Cale> It was this ridiculously bad drink.
20:35:45 <Cale> yes
20:35:51 <orbitz> yes, it' sdisgusting
20:35:56 <SamB> yes, that is DISGUSTING
20:36:01 <SamB> I had it once years ago
20:36:04 * Maddas thought he was named after the company
20:36:07 <wy> syntax is always easy to forget... what's wrong with this? let a === b = a+b in 1 === 2
20:36:26 <orbitz> Cale: wheee
20:36:28 <Cale> http://www.kibo.com/kibofood/#ORBITZ
20:36:28 <lambdabot> Title: Kibo's junk food reviews
20:36:30 <SamB> orbitz: do you discuss this often?
20:36:31 <TomMD> wy: you need a 'let'
20:36:49 <orbitz> SamB: it' skind of bad memories
20:36:55 <wy> TomMD: I already have one?
20:36:59 <shepheb> is there an EitherT online somewhere (or some other fail = error message, return = success monad)?
20:37:08 <SamB> I was just thinking people might bring it up a lot because of your nick
20:37:23 <orzo> the FFI specifies a cplusplus calling convention.  Does ghc support that and make it work with the g++ convention?
20:37:36 <wy> > let a===b = a+b in 1===2
20:37:37 <lambdabot>  3
20:37:39 <SamB> and anyway you would tend to notice whenever people discuss it in the same IRC channel
20:37:44 <orbitz> http://www.bevnet.com/reviews/orbitz/
20:37:44 <lambdabot> Title: Orbitz - The BevNET.com Review
20:37:52 <SamB> orzo: never heard of anyone actually supporting it
20:37:56 <wy> uhhh... why doesn't it work here
20:38:02 <orbitz> oh drats, they removed the reviews
20:38:07 <wy> > let a === b = a+b in 1 === 2
20:38:07 <TomMD> wy: use (===) instead of infix
20:38:08 <lambdabot>  3
20:38:10 <orbitz> the reveiws are along the liens of "this is th worst drink i have ever treid"
20:38:26 <orbitz> SamB: most people associate orbitz with the travel company, so they look over my drinka ssociation
20:38:31 <SamB> orbitz: they did?
20:38:34 <wy> TomMD: why does it work here? I tried to make it (===) but it still doesn't work
20:38:45 <Cale> White is the vilest of all. It is "PinEapPle bAnaÑa cherRy coConUt" (with half of them upside down in addition to the random tilde.) It tastes like coconut flavored disinfectant.
20:39:03 <wy> probably something wrong with haskell-mode
20:39:20 <wy> it works in the terminal
20:39:23 <SamB> I think they should have just made a drink that actually tasted as cool as it looked.
20:39:54 <orzo> I found this on the wiki: http://www.haskell.org/haskellwiki/CPlusPlusFromHaskell
20:39:55 <lambdabot> Title: CPlusPlus from Haskell - HaskellWiki
20:40:05 <orbitz> SamB: pepsi blue?
20:40:31 <shepheb> I need a monad transformer that returns an error message (String) on failure, and an a on success.
20:40:39 <SamB> orbitz: pepsi blue?
20:40:57 <SamB> orbitz: I meant, they could have included floating orbs and all... if they'd just made it taste good!
20:41:15 <dino-> shepheb: I'm only learning some of this right now, but maybe ErrorT
20:41:21 <SamB> you'd think they'd have realized that this was a key element of soft-drink success
20:41:46 <orbitz> SamB: i'll meditate on it
20:41:51 <orbitz> sleep!
20:41:58 <Maddas> That's not meditating!
20:42:13 <SamB> Maddas: he will place the IRC transcript under his pillow
20:42:14 <orbitz> shush yoU!
20:42:24 <shepheb> dino-: I could have sworn I just looked that up, and saw that it was for exception handling.
20:42:35 <Maddas> SamB: And play an audio version while he sleeps, yes, that'll work. :-)
20:42:37 <SamB> actually, wait, that will crinkle and keep him awake
20:43:05 <SamB> the reviews are there still!
20:44:09 <dino-> shepheb: I could be not understanding what you want to do.
20:44:28 <wy> TomMD: got it...
20:44:32 <shepheb> dino-: no, ErrorT is perfect. I just can't figure out what I read that was about catching pattern mismatches and other exceptions.
20:44:49 <shepheb> since I thought /that/ was ErrorT. anyway, thanks.
20:45:04 <TomMD> wy: excellent!  Now for the easy part - make a patch, upstream, make a regression test, force it on the dev team.
20:45:06 <SamB> bevnet did not like any of them
20:45:15 <SamB> some of them, they say, would have been tolerable without balls
20:45:26 <wy> TomMD: No. that's my mistake ;)
20:45:54 <wy> TomMD: I almost forgot what the toplevel definition should be like
20:45:59 <dino-> My take on it was that you can use throwError and catchError if you want to do something resembling exception try/catch, but you don't have to use it that way.
20:47:01 <wy> hmmm how can I hide >>= from the prelude?
20:47:21 <lispy> > let a --- b = a - b in 1 --- 2
20:47:21 <lambdabot>  Parse error at end of input
20:48:11 <wy> > let a -+- b = a - b in 1 -+- 2
20:48:11 <lambdabot>  -1
20:48:18 <lispy> > let a --. b = a - b in 1 --. 2
20:48:19 <lambdabot>  -1
20:48:21 <wy> :t (---)
20:48:22 <lambdabot> parse error (possibly incorrect indentation)
20:48:31 <lispy> interesting taht --- is not valid but --. is
20:48:37 <shachaf> wy: import Prelude hiding ((>>=))?
20:48:44 <shachaf> wy: Or -fno-implicit-prelude.
20:48:59 <shachaf> wy: (Which also affects do-notation.)
20:49:43 <wy> shachaf: uhh. I just want to try to redefine >>= so that play with let a>>=b = ... do x<-e1 ...
20:50:12 <wy> I guess it's already impossible to play this trick
20:50:48 <Cale> wy: You need to define an instance of Monad
20:50:55 <wy> lispy: do you think that's because that -- is comment? but I remember that -- is comment only if the third one is not '-'
20:51:09 <shachaf> wy: Use -fno-implicit-prelude.
20:51:20 <shachaf> wy: Or just define your own Monad instance, of course, yes.
20:51:26 <shachaf> wy: Depending on what you're doing.
20:51:43 <lispy> wy: what you want to do is possible, but if you're not changing the type signature of (>>=), just make a monad instance :)
20:51:49 <wy> Cale: I see the problem... so does that work correctly now?
20:51:53 <shachaf> Hmm, why is (---) invalid?
20:52:05 <Cale> wy: sorry?
20:52:15 <lispy> I think the better question is why is --. a valid identifier
20:52:16 <allbery_b> shachaf: I think it's taken as a comment
20:52:27 <allbery_b> (not sure if that's ghc or Language.Haskell
20:52:29 <allbery_b> )
20:52:34 <Cale> shachaf: The report defines any sequence of -'s not followed by another symbol character to be the start of a comment
20:52:42 <lispy> I think it would be easier for "--.*^" to start comments
20:52:58 <shachaf> Cale: Of two or more '-'s.
20:52:59 <TomMD> No - I use that operator
20:53:02 <lispy> instead of "--[^-]*"
20:53:08 <Cale> yes, of two or more dashes
20:53:22 <Cale> That's not quite the pattern
20:53:49 <lispy> I'm not good with regular expressions, what is the right pattern?
20:54:37 <lispy> "--.*$" vs. "--[^-]*$"  (what's wrong with those?)
20:54:38 <wy> Cale: I just want to try redefine (>>=) so as to capture the (>>=) inside the do notation
20:54:53 <Cale> --a will start a comment, for instance
20:54:54 <allbery_b> wy: IIRC GHC has that hardwired
20:55:06 <allbery_b> even if you override the prelude
20:55:18 <lispy> Cale: and "--a" matches "--[^-]*$" doesn't it?
20:55:24 <Cale> er, yes
20:55:46 <Cale> --> is not the start of a comment
20:55:50 <Cale> It's an operator symbol.
20:55:57 <lispy> Oh, I see what you were getting at
20:56:27 <lispy> But yeah, I would prefer it if "--.*" started comments
20:56:40 <wy> > -----------------------------------
20:56:40 <lambdabot>   parse error on input `}'
20:56:47 <Cale> But there are cool operator symbols that start with --
20:56:52 <wy> > 1 -----------------------------------------------
20:56:53 <lambdabot>  1
20:56:59 <Cale> Specifically, various arrow-looking things. :)
20:57:31 <Cale> > let a --> b = b/a in a --> b --> c
20:57:31 <lambdabot>  c / (b / a)
20:57:35 <wy> yes. maybe making -- the comment start token is a bad choice
20:57:46 <TomMD> Cale: If you don't mind me asking, are you a Galois person?  I ask to test my theory that anyone on #haskell 24/7 has been assimilated by Galois ;-).
20:57:47 <lispy> Yeah, but it makes it non-trivial for emacs M-; to work correctly.  And all my versions of emacs do it incorretly as result (although I've been told emacs22 fixes this)
20:57:52 <Cale> It's an okay choice. I don't see anything wrong with the existing syntax.
20:57:59 <Cale> TomMD: No.
20:58:09 * allbery_b suspects he disproves that one
20:58:22 <lispy> and I care more about emacs working correctly than strange operators :) (tbh, I'm not a huge fan of user defined operators)
20:58:29 <Cale> TomMD: I've considered the possibility of applying for work there at some time in the future.
20:58:55 <Cale> lispy: It's not like it's uncomputable.
20:59:00 <TomMD> Your day job includes Haskell now?
20:59:23 <Cale> TomMD: I'm not employed.
20:59:37 <lispy> Cale: by non-trivial i meant the difficulty to implement it correctly :)
20:59:52 <Cale> I'm doing a correspondence course, and then I'm going to look for graduate schools.
21:00:01 <wy> > let a---------------------->b = a-b in 1---------------------->2
21:00:02 <lambdabot>  -1
21:00:23 <Cale> lispy: It can be done with a regular expression :)
21:00:34 <Cale> (look in the Haskell report)
21:00:55 <lispy> And my complaint against user defined operators is that they often don't look like much and grepping for their definition can be hander than normal functions in my experience
21:01:06 <wy> lispy: nothing for haskell syntax has been easy for emacs
21:01:24 <Cale> --> would be nice syntax for arcs in a library for graphs, for instance
21:01:31 <adu> did some one say 'adu'?
21:01:38 * wy don't want to complain about the indentation again
21:01:38 <Cale> adu
21:01:40 <adu> o "graduate schools"...
21:01:42 <adu> hehe
21:01:43 <allbery_b> heh
21:01:44 <Cale> heh
21:01:52 <allbery_b> like that a-b triggered my client:)
21:02:06 <lispy> Cale: The point of M-; is that it's a toggle, getting it to toggle correctly is the hard part for emacs
21:02:17 <Cale> What does it do?
21:02:46 <lispy> Cale: you select a region then press M-; and it either comments out the region or uncomments the region
21:02:46 <wy> I'd prefer a xml like syntax with multiple views
21:02:55 <wy> with graphics
21:03:00 <adu> wy: for what?
21:03:12 <wy> adu: for a programming language
21:03:14 <Cale> lispy: That's trivial with Haskell. Just put {- before it and -} after.
21:03:18 <lispy> Cale: it's something I do surprisingly often.
21:03:31 <lispy> Cale: Yes, quite unfortunately I've had to start doing that.
21:03:35 <adu> wy: I'd perfer lisp over xml or "SXML" as they call it
21:03:42 <Cale> lispy: Why not write M-; to do it?
21:04:28 <lispy> Cale: the cool thing about M-; is that you don't have to select the same region to untoggle it
21:04:32 <Cale> lispy: It's guaranteed to be correct, even if the block contains such a comment, because {- comments {- can be nested -} -}
21:04:39 <wy> adu: Doesn''t lisp seem to be too plain? xml seems to be good enough for internal representation.
21:04:44 <mrd> what's the case which breaks M-;, I can't figure it out
21:05:03 <Cale> lispy: So?
21:05:23 <lispy> Cale: suppose you block comment a region, and then you want to uncomment the inner 3 lines
21:05:25 * wy is trying to find where the heck jedit installed itself to
21:05:35 <Cale> lispy: Presumably you could just select the {- at the start and M-;, and it'd find the matching -} and remove both.
21:05:42 <lispy> Cale: with the way it's currently implemented to use -- instead of {- -} this step is easy
21:06:19 <adu> wy: my beef with XML is that its much bigger than people think. XML contains legacy syntax like <!ATTRIBUTE  and <!ELEMENT and <!NOTATION and <!SOMETHINGELSE which are rarely used. XML could be used as a templating language in and of itself, but it is so rarely used for this purpose the features might as well be removed from the language
21:06:26 <Cale> I suppose emacs lisp isn't such a nice programming language, but it really can't be *so* bad.
21:06:45 <lispy> Cale: if {- can nest, and you start reading backwards you have to balance them to uncomment the right one
21:06:53 <Cale> That's true.
21:06:57 <wy> someone caught my attention by saying jedit is the his position on the question of "vim vs. emacs"
21:07:21 <Cale> It's the sort of thing which if you can't do it as a first year CS student, you should probably switch majors.
21:07:21 <mrd> did you have a good chuckle
21:07:29 <adu> my position in vim/emacs is both, I like bof'em
21:08:35 <lispy> Cale: doing something and doing something within someone's legacy framework are totally different though
21:08:41 <Cale> heh
21:08:49 <adu> its much easier to break away
21:08:52 <mrd> that's why i'm writing my own haskell editor from scratch
21:08:55 <mrd> woo hoo
21:09:08 <adu> mrd: wanna write a huge bloated editor with me?
21:09:10 <Cale> I don't think that the language should be designed to make things easy for the writers of text editors.
21:09:12 * araujo was writing his own haskell editor too
21:09:13 <mrd> nooo
21:09:18 <wy> adu: I found we need something else...
21:09:33 <adu> wy: I like this 'something else' you speak of...
21:09:34 <mrd> we already have Yi and Leksah on that front
21:09:35 <lispy> Cale: Why?  Is developer time unimportant?
21:09:40 <araujo> got a basic notepad-alike up and running
21:09:53 <Cale> lispy: Well, it should be designed to make things easy for the people who are using the language.
21:09:55 <adu> wy: what do we need?
21:10:06 <lispy> Cale: look at perl, it's aparantly very hard to write tools to analyze the code
21:10:08 <mrd> i am thinking the next scheme-in-48-hours should be an editor.  gtk2hs is so nice.
21:10:09 * araujo should probably add lambdabot support to it, indentation and use it
21:10:17 <wy> adu: wait for a few years and see ;)
21:10:23 <lispy> Cale: well, from my point of view, good editor support is part of that
21:10:24 <adu> wy: what do you mean?
21:10:46 <adu> wy: are you working on something?
21:11:01 <adu> wy: or are you working on the 'something else' you spoke of earlier?
21:11:43 <Cale> lispy: I don't contest that. I just don't think the language design should be influenced by the fact that it'd be slightly harder to program certain editor features. Those sorts of things only have to be done once.
21:11:45 <lispy> Cale: I think "real world" programmers send more time reading/understanding code than they do developing it.  So I think a well designed language and environment makes those the easier tasks.
21:11:48 <wy> adu: not really. just dreaming
21:12:02 <lispy> Cale: why? because we all use the same editor?
21:12:08 <BMeph> Has anyone considered that maybe half of emacs' unsatisfying actions are attributable to its reliance on Lisp? ;)
21:12:19 <Cale> Similarly, "it'd be a little harder to write the compiler" isn't an excuse not to add a useful feature.
21:12:47 <wy> adu: the problem is that what this thing should be written in. It should be stable enough, but it's stable, it won't improve...
21:12:52 <lispy> a hard to write compiler is more likely to have bugs though, so I think a balance is important
21:13:02 <Cale> BMeph: In particular, a broken lisp.
21:13:04 <allbery_b> BMeph: emacs-alikes not based on Lisp tend to go nowhere fast
21:13:08 <allbery_b> and ==Cale
21:13:21 <allbery_b> they keep talking about redoing emacs in Guile...
21:13:31 <Cale> Why not scheme?
21:13:39 <allbery_b> Guile is GNU Scheme
21:13:46 <hpaste>  dolio annotated "type safe interpreter" with "Haskell translation?" at http://hpaste.org/6305#a1
21:13:52 <Cale> Ah, okay.
21:13:58 <adu> This conversation reminds me of something I overheard today. Someone was writing code in a highlighting editor, and passed the string "http://www.example.com" to a function, and they had to consult with several other developers because half of the string "turned green" and it took 5 other developers to educate him that it was still able to compile, and that the syntax highligher was stupid
21:13:59 <lambdabot> Title: Example Web Page
21:14:05 <lispy> one of the big arguments against using scheme is that for many emacs functions dynamic scope is actually useful
21:14:09 <BMeph> allbery_b: Maybe THAT is because people recognize that you're just copying Emacs. Vi, for example, isn't based on Lisp, right?
21:14:23 <Cale> adu: haha, that's terrible
21:14:23 <allbery_b> right
21:14:28 <dino-> adu: That's an amusing story.
21:14:41 <Cale> Syntax highlighters should not be based on regular expressions.
21:14:54 <wy> allbery_b: guile seems to be not so good
21:15:01 <allbery_b> BMeph: it's not always obvious that it's copying Emacs, even
21:15:12 <bos> emacs's haskell syntax highlighting gets double quotes inside single quotes wrong.
21:15:27 <allbery_b> just that such editors don't seem to work well in not-Lisp
21:15:32 <bos> '"' turns everything that follows into "i'm inside a string!" colour.
21:15:33 <lispy> Cale: While I agree that regular expressions are overused in the 'industry', it does make the syntax highlighter much easier to get working, even if it's half-assed.
21:15:34 <bd_> Cale: if not, then what?
21:15:35 <allbery_b> with the possible exception of IBM's XEDIT
21:15:35 <dino-> I might have quietly compiled it first to see if it was a bullshit highlight, rather than call for a congress.
21:15:52 <allbery_b> which has the excuse of being one of the few usable editors for 3270-type terminals
21:16:14 <dino-> Assuming that I didn't get that it was a string to begin with, say.
21:16:16 <Cale> bd_: Proper parsers.
21:16:23 <Pseudonym> allbery_b: The competition isn't great, IIRC.
21:16:38 <bd_> Cale: what happens when your text is (temporarily) not parsable, then? :)
21:16:56 <lispy> incremental parsers are hard
21:17:02 <allbery_b> stop highlighting until it is
21:17:03 <Cale> There are various well-studied mechanisms for recovery.
21:17:04 <adu> wy: I think you're onto something
21:17:11 <BMeph> lispy: ...let's go shopping? ;)
21:17:34 <lispy> BMeph: let's do it in regular expressions so we have time at the end of the week to go shopping, yes :)
21:17:44 <adu> wy: so you think the problem is a language barrier?
21:17:49 <allbery_b> (XEDIT used REXX.  I don't know how much of its functionallity was *written* in REXX, though)
21:18:02 * lispy isn't really trying to encourage regular expressions, but they sure are quick 'n dirty
21:18:06 * Pseudonym used PE2
21:18:09 <Pseudonym> And kedit.
21:18:36 <wy> adu: I said that's just dreaming. I must secure my life first actually ;)
21:18:36 <lispy> REXX is IBM's smalltalk like language?
21:18:50 <allbery_b> er, no
21:19:04 <adu> i thought Rexx was like Perl?
21:19:16 <allbery_b> an interpreted vaguely-sort-of-like-PL/I
21:19:25 <lispy> oh, and if people here want to write emacs-like editor in something besides elisp, get hacking on yi.  That's an editor you can extend in Haskell via hs-plugins.
21:19:32 <wy> adu: I like TeXmacs somewhat. I hope something more than that could be used as an programming editor
21:19:34 <Pseudonym> Kinda lispish, too, without the lisp syntax.
21:19:44 <Pseudonym> Really, it's just a vanilla procedural scripting language.
21:19:47 <allbery_b> Object REXX added a smalltalk-like object system on top of it, though
21:20:18 <adu> I think TeXmacs is deceiving, because its not TeX, and its not Emacs
21:20:20 <allbery_b> fwiw, BSD nvi is scriptable in Perl, Tcl, and possibly Python these days.  I don't think anyone actually does so, though
21:20:52 * allbery_b admits to having *used* REXX like Perl back in his OS/2 days
21:20:57 <wy> adu: of course it's not TeX. I like it much better than TeX
21:21:05 <allbery_b> because damned near eveyrhting was scriptable in REXX
21:21:11 <wy> adu: the name is not good ;)
21:21:29 <adu> ooo I'm going to hack on Yi!
21:21:41 <mrd> good luck, it gives so many compile errors
21:21:44 <wy> but that's a way to catch people's attention
21:21:54 <lispy> wy: my only complaint back in the day with Texmacs was that it held me back from learning the actual latex.  But, otherwise it's very nice (and that's not much of a complaint, more of a compliment)
21:21:56 <Pseudonym> Woo, talking about old terminals.
21:22:03 <Pseudonym> I did my honours thesis on one of these:
21:22:05 <Pseudonym> http://archive.computerhistory.org/resources/physical-object/hazeltine/102651077.lg.jpg
21:22:07 <lambdabot> http://tinyurl.com/ypq2u3
21:22:15 <Pseudonym> (It was retro at the time.)
21:23:04 <wy> lispy: so you'd say it freed you from having to learn latex?
21:23:32 <mrd> lispy: that's why I stopped using LyX
21:23:48 <mrd> because it was preventing me from taking advantage of macros -- the whole point of TeX
21:23:57 <wy> mrd: LyX is only a frontend for latex I guess
21:24:06 <mrd> yea, more or less
21:24:26 <Stwange> I just finished all the work I had to do on computability theory and turing reductions (20 straight hours later =( ). Thanks a lot for the guidance and explanations of concepts guys, I really appreciate it you saved me a lot of time
21:24:38 <mrd> Stwange: what book?
21:24:43 <mrd> (are you using?)
21:25:03 <Stwange> mrd, I wasn't, it's an assignment but I *forgot* to go to any of the lectures
21:25:10 <mrd> and there's no book?
21:25:21 * dolio is pleased with how non-heinous his interpreter with GADTs and type families is.
21:25:36 <Stwange> some awful lecture notes that are deliberately written to confuse from years ago, but no, no book
21:25:43 <mrd> hmm.  we used Sipser.
21:25:49 <Pseudonym> We used Sudkamp.
21:25:53 <mrd> might want to take a look. might be in your library.
21:26:11 <Stwange> is it massively in depth with mathematical notation?
21:26:18 <mrd> no it's very friendly
21:26:18 <wy> mrd: I got it from the library
21:26:20 <Pseudonym> http://www.cs.wright.edu/~tsudkamp/book.htm <- Pretty easy to read.
21:26:21 <lambdabot> Title: Languages and Machines
21:26:25 <mrd> it has the proofs, but first sketches
21:26:27 <lispy> wy: knowing latex makes TeXmacs even easier to use, but not knowing it isn't a problem.  So yeah, I would say it does a decent job of freeing the user from learning latex.
21:26:35 <adu> i found out what "yi" means....
21:26:39 * mrd checks out tsudkamp
21:26:53 <adu> i found a page all about it:
21:26:55 <adu> http://ja.wikipedia.org/wiki/%E7%BE%A9
21:26:55 <Pseudonym> I must say, though, I found Sudkamp's book... uh... not challenging enough.
21:27:09 <Pseudonym> It was simpler than the lectures.
21:27:12 <Pseudonym> But maybe that was just me.
21:27:27 <wy> how much computing theory is enough I guess?
21:27:46 <Stwange> neither of them are in the library :(
21:28:07 <adu> wy: as much as it takes for you to get sick of it all and finally write that damn AI everyone's been asking for
21:28:19 <OceanSpray> hey Cale
21:28:26 <Cale> hi
21:28:30 <lispy> wy: enough that when you're writing code you can look at something and guess approximately what the big O is, and also, have a hunch when something is undecidable.
21:28:33 <dolio> @seen Jaak
21:28:34 <lambdabot> Jaak is in #friendly-coders, #gentoo-haskell and #haskell. I don't know when Jaak last spoke.
21:28:37 <wy> adu: what does it mean? I know that chinese character
21:28:55 <Pseudonym> I've heard good things about Anderson's "	Automata theory with modern applications".
21:28:58 <adu> wy: "Yi" = Righteous!
21:28:59 <Pseudonym> But I haven't looked at it myself.
21:29:05 <OceanSpray> with Imlib, createImageUsingArray takes an array with indices ((0, 0), (x, y)), right?
21:29:22 <adu> I'm going to be hacking on a Righteous Editor!
21:29:23 <adu> :)
21:29:44 <Cale> OceanSpray: yeah
21:29:52 <Stwange> wait, sudkamp's is, I was looking for tsudkamp :S
21:29:52 <OceanSpray> how come when I render something, it's sideways?
21:29:59 <Cale> OceanSpray: good question :)
21:29:59 <Pseudonym> Stwange: Your best bet is to look up the call number, then go to that area of the library and see what's on the shelf.
21:30:01 <Stwange> I'll check it out Pseudonym
21:30:15 <wy> lispy: the first thing I have a hunch. I don't know much about decidability
21:30:17 <Pseudonym> I've learned many cool things that way.
21:30:24 <Stwange> Pseudonym, I did do that before, looked up all the books on computability, but they were all in greek if you know what i mean
21:31:02 <dolio> @tell Jaak http://hpaste.org/6305#a1
21:31:02 <lambdabot> Consider it noted.
21:31:02 <lispy> wy: well, knowing if it's NP/NP-complete probably comes up more than undeciable now that I think about it.
21:31:19 <wy> adu: haha. who chose this name?
21:31:37 <OceanSpray> hmm
21:31:47 <adu> wy: i dunno
21:31:53 <Stwange> mrd, is it worth buying? I'll probably only use it once for the exam. I did find this stuff interesting, but I'm scarred for life
21:32:00 <OceanSpray> how do raytracers USUALLY create a set of rays?
21:32:10 <Cale> OceanSpray: I noticed some really strange behaviour of your newView function too.
21:32:16 <mrd> it's really not that bad, you just tried to do it inside out and backwards
21:32:17 <OceanSpray> yes, it's weird.
21:32:28 <OceanSpray> hold on, lemme upload the newer code.
21:32:44 <Cale> OceanSpray: I refactored it a bit, but it's still strange. I really should write it for myself, I've done it before :)
21:32:46 <mrd> can't you check it out of the library?
21:32:52 <Stwange> nah they don't have a copy
21:33:01 <adu> wy: apparently, "Yi" when used as a prefix can also mean "volunteer" or "justice", although I can see the "volunteer" being appropriate for an opensource project
21:33:04 <OceanSpray> Cale, can I see what you've done?
21:33:13 <hpaste>  Cale pasted "modified newView" at http://hpaste.org/6323
21:33:39 <OceanSpray> http://www.pastebin.ca/940677
21:33:40 <mrd> perhaps ask a professor or other student
21:33:48 <wy> adu: are you chinese?
21:34:16 <wy> 义务劳动
21:34:30 <Stwange> I can try it mrd , anyway it's approaching 5am so I think I might hit the hay before I start working on friday's deadline
21:34:37 <mrd> good thinking
21:34:41 <Stwange> thanks a lot for the help mrd, I really mean that
21:34:51 <Cale> OceanSpray: Oh, and I should give you my scene :)
21:35:01 <OceanSpray> oooh
21:35:06 <mrd> you're welcome, i hope i didn't make it worse
21:35:34 <hpaste>  Cale annotated "modified newView" with "scene" at http://hpaste.org/6323#a1
21:35:47 <wy> lispy: I hope there are some automatic assistant to reasoning about NP-completeness etc
21:36:16 <adu> wy: no, but I lived in japan for 6 years, so I know how to lookup C/J/K characters
21:36:45 <Cale> OceanSpray: Normally, I'd place the camera at (1,1,1) and point it toward the middle of the spheres, but that doesn't seem to give me anything but blackness.
21:36:52 <Cale> OceanSpray: I don't understand why.
21:37:04 <OceanSpray> have you seen the rotateBy function?
21:37:13 <Cale> I should look at that, yes :)
21:37:22 <OceanSpray> it does some strange things.
21:37:34 <Cale> Yes, indeed it does.
21:37:50 <Cale> In fact, that's kind of insane...
21:37:59 <Cale> It shouldn't require atan
21:38:13 <adu> wy: http://www.mandarintools.com/cgi-bin/wordlook.pl?word=%E7%BE%A9&searchtype=trad&where=start
21:38:15 <lambdabot> Title: Dictionary Search Results, http://tinyurl.com/2doxjt
21:38:24 <OceanSpray> well, you do see what I was trying to do, yes?
21:38:37 <OceanSpray> I mean, that CAN'T be how views are usually generated.
21:38:48 <Cale> um...
21:38:58 <lispy> wy: I don't think it's possible to have an automatic assistant for that task unless we can take the A out of AI for machines.
21:39:13 <adu> wy: I kind of like the simplified version more...
21:39:20 <wy> adu: ... compulsory education? I don't think the translation is correct
21:39:20 <Cale> OceanSpray: Usually you can just work out the 4 corners and linearly interpolate.
21:39:31 <OceanSpray> linear?
21:39:50 <adu> wy: thats affter you add 3 other characters to it
21:39:59 <adu> wy: one of them might be "not"
21:40:09 <OceanSpray> oh, I see what you mean.
21:40:09 <Cale> Yeah. Imagine a rectangle whose normal is the direction of the camera, and which is placed some distance away from it.
21:40:32 <wy> adu: I mean.. what do you think when you see "compulsory"? the student or the school?
21:40:38 <Cale> The rays through various points on that rectangle are the rays you're tracing.
21:41:00 <adu> wy: I think teachers are stupid for making me do things
21:41:08 <Cale> You'll need some rotation perhaps to find out the ideal rectangle for the field of view you'd like.
21:41:35 <adu> wy: are you chinese?
21:41:38 <wy> adu: that word originally means that the society will provide free education for some years for any people
21:41:45 <lispy> hmm...it seems that ghc6.6 no longer likes -opt-P-P
21:41:51 <wy> adu: yes :)
21:41:58 <adu> wy: ni hao!
21:42:06 <wy> adu: ni ye hao!
21:42:11 <allbery_b> shouldn't that be -optP?
21:42:19 <allbery_b> i.e. -optP-P
21:42:38 <lispy> oh, you're right, I did typo that
21:42:41 <lispy> thatkns
21:42:44 <lispy> er thanks
21:43:24 <lispy> next question
21:43:56 <lispy> if I have a full directory structure and I want to run haddock on all the sources (I'm sure the standard libs have this problem) what is a good way to make haddock do that?
21:44:19 <lispy> I also need to have ghc pre-process the source files as they use CPP
21:44:21 <OceanSpray> Cale, your scene seems to be quite complex.
21:44:29 <OceanSpray> It's taking a really long time to render.
21:44:48 <wy> adu:  義經 is iching
21:45:08 <Cale> OceanSpray: Hehe, but it only has 4 spheres ;)
21:45:26 <OceanSpray> Maybe it's because I added refraction.
21:45:38 <Cale> Oh, that'll be really fun then :)
21:45:41 <wy> Cale: are you writing a renderer?
21:45:46 <Cale> wy: OceanSpray is.
21:46:03 <Cale> I've written a raytracer or two before and so I'm helping out a bit :)
21:46:35 <OceanSpray> http://img247.imageshack.us/my.php?image=outjx3.png
21:46:43 <OceanSpray> this what it's supposed to look like?
21:46:57 <Cale> Yep
21:47:02 <wy> Cale: I was writing a renderer in the winter, but I digressed into trying to modify the type system of haskell ;)
21:47:02 <Cale> Pretty much.
21:47:29 <OceanSpray> did the refraction add anything?
21:47:36 <Cale> actually, I can't tell
21:48:18 <Cale> There's no obvious difference.
21:48:30 <OceanSpray> hmm.
21:49:28 <Cale> There's a better view to choose, but that rotation function is really screwy.
21:49:43 <adu> hmm
21:50:13 <adu> I'm having trouble with darcs again
21:50:14 <adu> in order to get yi i need darcs, and darcs won't compile
21:50:22 <Pseudonym> This is an old picture, but:
21:50:25 <Pseudonym> http://andrew.bromage.org/haskrt.png
21:50:46 <adu> there was another thing i needed darcs for, i don't remember...
21:51:30 <wy> anybody tried bazaar?
21:51:41 <OceanSpray> whoah, motion blur?
21:51:48 <Pseudonym> Yup.
21:51:48 <cjb> yeah.  it's full-featured and a little slow.
21:51:50 <adu> "Couldnt figure out how to call GHC.Handle.openFd!"
21:52:23 <Pseudonym> Also of interest:
21:52:26 <Pseudonym> http://andrew.bromage.org/test3.png
21:52:56 <Pseudonym> Someone who knows something about importance sampling might like to think about what those white dots are.
21:55:31 <wy> Pseudonym: which picture?
21:55:48 <Pseudonym> That last one.
21:55:52 <Pseudonym> http://andrew.bromage.org/test3.png
21:56:24 <wy> Pseudonym: cornell box :)
21:56:37 <Pseudonym> Yup.
21:57:09 <wy> Pseudonym: Are you mixing brdf and luminaires sampling?
21:57:19 <Pseudonym> Yes.
21:57:32 <lispy> adu: darcs won't compile? what is the error?
21:58:19 <wy> I had this problem before. And I recall as if I got something wrong about the distribution
21:58:27 <adu> "configure: error: Couldnt figure out how to call GHC.Handle.openFd!"
21:58:37 <Pseudonym> The problem is combining two histograms.
21:58:44 <lispy> adu: what version of ghc, what OS and what version of darcs?
21:58:52 <lispy> adu: iirc that's a solved problem
21:59:03 <Pseudonym> But this was actually the effect that I was trying to understand at the time, so I'm glad I got it. :-)
21:59:37 <wy> Pseudonym: that's cool! I haven't yet seen any freely available haskell renderer that's trying to be real ;)
22:00:47 <Pseudonym> Well, this isn't freely available, and nor is it useful.
22:01:04 <Pseudonym> In fact, I think the source code for the Cornell box experiment is lost in a hard drive crash.
22:01:18 <Pseudonym> Shouldn't be hard to reproduce, though.  It was only about 150 lines.
22:01:35 <adu> darcs-1.0.9 ghc-6.8.2
22:01:42 <wy> I hope there is some programming environment that's much like gmail in the future
22:01:59 <adu> wy: how is gmail a programming environment?
22:02:08 <wy> so we need only a browser to start programming
22:02:34 <wy> adu: I mean those kind of SOA thing
22:02:37 <scook0> google docs meets IDE
22:02:45 <wy> hehe
22:02:56 <bd_> what, like google's "google mashups" thing? :)
22:02:57 <shachaf> wy: There are some things like that, for web development, I think.
22:03:04 <OceanSpray> "[karl@da-yu birdray]$ ./birdray
22:03:04 <OceanSpray> Stack space overflow: current size 8388608 bytes.
22:03:04 <OceanSpray> Use `+RTS -Ksize' to increase it."
22:03:06 <OceanSpray> oh lord.
22:03:20 <lispy> adu: ah, so I think you either need make sure your 1.0.9 has all the patches as http://darcs.net/repos/stable or use http://darcs.net/repos/unstable, or just use ghc6.6
22:03:21 <lambdabot> Title: darcs
22:03:35 <adu> oh
22:03:43 <adu> so i should use unstable...
22:03:49 <wy> Pseudonym: that's nice... I remember I struggled with the Java renderer trying to find out where is my intensity modified...
22:04:12 <lispy> adu: yeah, it should be fairly stable when using darcs1.x or even hashed repositories.
22:04:42 <wy> Pseudonym: later I found the arguement passed in (which is supposed to get my output... you know java..) is not set to zero in the framework...
22:05:06 <adu> yey fdToHandle passed :)
22:05:30 <adu> i like unstable :)
22:05:39 <lispy> unstable has a lot of cool features at the moment
22:05:43 <lispy> darcs2.0 will be nice
22:05:59 <Adamant_> wy - look at Jiggy
22:06:14 <Adamant_> full Javascript IDE in Javascript
22:06:16 <wy> OceanSpray: the problem might be about the geometry factor I guess
22:08:01 <lispy> anyone know off the top of their head how to escape the / character in haddock comments?
22:08:45 <lispy> n/m
22:08:51 <lispy> the manual says \/ should do it
22:10:42 <wy> Adamant_: is it for iPhone?
22:11:03 <Adamant_> I think the base tech is also used elsewhere
22:11:12 <Adamant_> but it's for iPhone/iTouch too
22:11:37 <OceanSpray> another stack overflow
22:11:59 <OceanSpray> I'm starting to get the feeling that the refraction rays are entering an infinite loop.
22:12:07 <shachaf> wy: Look at Heroku/Appjet, also, I think.
22:12:19 * shachaf doesn't really see the point of these.
22:13:20 <Adamant_> shachaf: right now I agree
22:13:39 <Adamant_> but in the future, I dunno. There may be some advantages.
22:13:57 <Adamant_> just wait until Haskell gets in Silverlight. ;)
22:14:30 <adu> lispy: is it "turning green"?
22:14:45 <lispy> adu: is what turning green?
22:14:53 <adu> n/m just kidding
22:15:41 <adu> it was a story i told about an hour ago
22:16:54 <lispy> adu: that's what you get for trying to have a sense of humor
22:17:13 <lispy> adu: try to take life a bit more seriously please, kthnx
22:17:47 <Adamant_> disregard that, I turn green
22:24:21 * lispy finds a reference to lispy in the darcs source code and replaces it with his RealName(tm)
22:24:45 <adu> lispy: RealNames make me turn green
22:24:59 <lispy> adu: there you go with that sense of humor
22:25:08 <adu> lol
22:25:20 <lispy> adu: it's your undoing, i'm sure of it.  Like greek heros you have a tragic flaw.
22:27:09 <lispy> arg, haddock should tell you what it barfed on
22:27:18 <lispy> instead it just barfs with a line #
22:27:42 <lispy> (which is often wrong, BTW)
22:27:59 <lispy> granted, my haddock might be old
22:28:26 <allbery_b> modern haddock is based on ghc, isn't it?
22:28:35 <allbery_b> more likely to get line numbers and such right
22:28:54 <lispy> this is 0.8
22:29:25 <lispy> but I have to make it work with this version because I think this is the machine that droundy builds darcs on
22:29:34 <lispy> or at least a similar setup
22:31:50 <lispy> I want to haddock-ify darcs
22:32:04 <lispy> but this stupid haddock parse error...grr
22:33:37 <adu> goodnight
22:36:40 <Cale_> Hehe, I have this example coded up in povray now.
22:37:35 <Cale> I'll put up a png once it's finished rendering. :)
22:37:37 <hpaste>  lispy pasted "haddock keeps barfing, but why?" at http://hpaste.org/6324
22:39:15 <lispy> any one have any ideas why haddock wouldn't like that file?
22:39:47 <lispy> It says it has problem with the first character of the line that begins "import ..." but it should stop by the time it gets to that line
22:39:50 <Cale> http://cale.yi.org/autoshare/spherefractal.png
22:39:52 <lispy> so I think the error message is off
22:40:33 <dfranke_> is there a way to check at runtime whether the threaded runtime is being used?
22:40:56 <lispy> Cale: pretty
22:40:58 <Cale> OceanSpray: ^^ check that out :)
22:41:24 <bos> Cale: zomg trippy
22:41:35 <Cale> There are just 4 spheres and 3 lights.
22:41:41 <Cale> (and a camera)
22:41:52 <Cale> They're all placed at the vertices of a cube.
22:42:37 <dfranke_> Wow.
22:42:45 <dfranke_> did you discover this, or just implement it?
22:42:45 <Cale> You can do this in real life too, if you have some large metallic spheres.
22:43:15 <lispy> yes, but can you figure out why haddock fails to parse my example input :)
22:43:46 <Cale> lispy: I haven't used Haddock all that much, but maybe try moving the import up above the block comment?
22:44:29 <lispy> Cale: I'm trying it now
22:44:49 <lispy> oh, I think you're not to something
22:45:22 <Cale> dfranke_: I found it while playing around with scenes for my own raytracer a while back.
22:45:30 <dolio> Move it above the module declaration.
22:45:36 <dons> dfranke_: the trick i use is to try to run the program with +RTS -N2
22:45:37 <dfranke_> no... I think you need to move the block comment above the module declar --
22:45:38 <dfranke_> right.
22:45:43 <dons> it will fail if the wrong runtime is linked
22:45:46 <lispy> Cale: thanks, I would never have guessed that was the problem.  I guess that's what I get for reading their documentation out of order.
22:45:46 <dolio> The comment, that is.
22:45:59 <dfranke_> dons: won't help me here...
22:46:12 <dfranke_> dons: since #1936 is fixed I'm pulling PipeArrow out of mothballs...
22:46:23 <dons> cool
22:46:47 <lispy> what is PipeArrow?
22:46:56 <lispy> dfranke_: your suggestion works too
22:47:08 <dfranke_> dons: and I'm annoyed by this caveat in System.Process.waitForProcess:
22:47:08 <lispy> thatks peeps
22:47:11 <dfranke_> GHC Note: in order to call waitForProcess without blocking all the other threads in the system, you must compile the program with -threaded
22:47:25 <dons> right.
22:47:28 <dons> so do that :)
22:47:34 <dons> -threaded is a good default
22:47:51 <dfranke_> I'd really like to have it work properly in the non-threaded runtime.
22:48:18 <dons> well, if there's only one thread to wait, they're all going to wait..
22:49:20 <dfranke_> well, no... non-threaded runtime still gives you green threads.
22:49:37 <dfranke_> and there are going to be lots of those flying about.
22:50:11 <lispy> oh rm, haddock can't handle this haskell identifier ":>"
22:51:06 <dons> dfranke_: but there's only one os thread that's going to block...
22:51:27 <dfranke_> right, and I don't want it to do that.
22:51:42 <dons> so you'll need some kind of IO manager thread that can do the waiting
22:51:44 <dfranke_> I just want the green thread to wait on the process, not the OS thread.
22:51:55 <dons> and that's not possible
22:52:07 <dons> silly kernel
22:52:09 <Cale> http://cale.yi.org/autoshare/spherefractal2.png
22:52:34 <dons> is that a haskell binding to gnuplot, Cale?
22:52:44 <Cale> dons: No, this is just povray output.
22:52:46 <dfranke_> again, not true.  I can use the non-blocking call instead, and put it in a spinlock with `yield'.
22:53:05 <dfranke_> but that's unfriendly to other OS processes, so I don't want to resort to that unless I have to.
22:53:12 <Cale> dons: It's a scene which I was playing around with in OceanSpray's raytracer, and my own raytracer a while back.
22:53:20 <dfranke_> hence checking whether the threaded runtime is in use.
22:53:34 <dons> ah interesting. i'd not thought of that
22:54:03 <Cale> dons: It's 4 spheres, 3 lights, and a camera.
22:54:34 <dons> cool
22:54:36 <lispy> oh hrm, it seems haddock also does not like GADT syntax
22:55:00 <Cale> In that shot, you're right in the centre of the 4 spheres, looking directly at one of the spheres.
22:55:06 <dolio> You need haddock 2 for GADTs.
22:55:34 <Cale> http://cale.yi.org/autoshare/spherefractal.png -- this gives a better idea of what's going on, as you can actually see the 4 spheres clearly.
22:55:48 <Cale> (it's just centred at (1,1,1) rather than (1/2,1/2,1/2))
22:57:00 <lispy> dolio: Hmm...I may need ghc6.8.2 for haddock 2
22:57:03 <Cale> Heh, apparently lots of other people have had the same idea: http://www.miqel.com/fractals_math_patterns/visual-math-wada-basin-spheres.html
22:57:05 <lambdabot> Title: Patterns of Visual Math -Secret Inner Life of Mirrored Spheres: Wada Basins, http://tinyurl.com/2r2hja
22:57:09 <dolio> lispy: Yep.
22:57:17 <dfranke_> dons: this started as such a nice elegant hack, and now it's grown to 500 lines of dealing with all these stupid edge cases :-\
22:57:23 <lispy> that might be a show stopper for me
22:57:23 <Cale> There are some beautiful real-life photos there.
22:58:08 <lispy> dolio: I could surround things in #ifndef __HADDOCK__ but I'm using quite a few GADTs
22:58:14 <dons> dfranke_: you can assume a threaded runtime. why not?
22:58:26 <dons> keep it simple, release early
22:59:49 <solrize_> wow, the first ones are actual physical photos, i thought they were raytraced until i read the text
22:59:52 <OceanSpray> Cale, I just came out of the shower.
23:00:35 <OceanSpray> and I must say, that's a crazy pattern.
23:01:05 <Cale> It's a great way to stress test simple raytracers :)
23:02:27 <lispy> hmm, what was the tool that install things from hackage?
23:02:34 <Cale> cabal-install
23:02:34 <solrize_> cabal?
23:02:59 <lispy> cabal-install is not part of debian?
23:03:02 <dons> cabal builds packages, cabal-install installs cabal packages
23:04:44 * lispy starts installing cabal from darcs
23:05:17 <dfranke_> dons: ah well.  I guess since I'm already assuming a snapshot build of GHC it's no big deal.
23:06:02 <dfranke_> but the whole idea of this package is to take all these stupid details off the mind of the programmer, so I hate to have this one leak.
23:06:22 <lispy> I have a really slow connection to darcs.haksell.org, is that normal?
23:06:52 <glguy> a rate limit was added
23:06:55 <glguy> recently
23:07:52 <lispy> ah, I don't know my transfer rate, but I might as well go to bed waiting for this 'darcs get --partial' to complete
23:07:57 <lispy> :)
23:09:18 <lispy> dons: any idea what the darcs.haskell.org server needs in order to be faster? Is it funding, redundancy, more admins or what?
23:10:36 <OceanSpray> Cale, can Imlib output more than 16bit colors?
23:10:58 <lispy> OceanSpray: with how widely used it is, I would bet yes.
23:11:03 <lispy> (but I don't know that as a fact)
23:11:11 <Cale> OceanSpray: Can it output 16 bit colours?
23:11:36 <Cale> OceanSpray: I've never seen more than 8 bit actually work, despite the fact that it uses Word32's for channels.
23:11:51 <OceanSpray> well, dang.
23:12:01 <dons> lispy: a bigger pipe to the internet
23:12:07 <dons> lispy: which we'll have soonish
23:12:20 <lispy> dons: ah, cool
23:12:28 <glguy> roughly in one internet year
23:12:32 <OceanSpray> also, I don't think I'm doing refraction right.
23:12:35 <dons> or 12 weeks
23:13:06 <dons> i wonder if we can move, and keep d.h.o online the whole time
23:13:23 <glguy> whole  time?
23:13:31 <glguy> like put it on a cell phone
23:13:34 <glguy> on it's way over?
23:13:43 <siti> lol
23:14:29 <glguy> dons: this is a good point... we should just say at our current location
23:14:33 <Cale> ooh, this new rendering is going to be pretty. I moved the lights inward somewhat :)
23:14:35 <glguy> too much disruption
23:14:39 <lispy> "And between the hours of 2am and 4am, d.h.o was running off of dons' iPhone."
23:14:52 <glguy> dons doesn't have a phone!
23:15:00 <glguy> (secret is out)
23:15:21 <dons> who needs a phone when i have irc
23:15:22 <solrize_> :t (\->)
23:15:25 <lambdabot> Not in scope: `\->'
23:15:35 <solrize_> :t (\<-)
23:15:35 <lambdabot> Not in scope: `\<-'
23:15:41 <bockmabe> :t foldl
23:15:42 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
23:15:50 <dons> glguy: well, more that we mirror it, get the mirror into place, then switch
23:16:08 <glguy> dons: sure, but my scenario was funnier
23:16:14 <dons> that's ttrue
23:17:03 <dons> i'm only really interested in a phone i can irc from
23:17:18 <Maddas> "Please don't check any code out unless absolutely necessary; darcs.haskell.org runs on GPRS and they charge by the kB.'
23:17:21 <Maddas> '
23:18:13 <glguy> dons: 1980s technology meets the modern cellphone?
23:18:39 <dons> yep
23:18:43 <dons> ssh also
23:18:48 <glguy> irc on my cellphone would be damaging for me
23:19:46 <glguy> if you had an iphone you could play "smudge in my password before the timeout", and need no other games
23:20:10 <Cale> http://cale.yi.org/autoshare/spherefractal3.png -- that's what happens when you move the lights toward the centre by sqrt(3)/5
23:20:57 <Cale> The boundaries are all nicely lit up now :)
23:21:01 <glguy> dons: maddox of the greatest site on the Internet reviews a phone that does ssh
23:21:20 <dons> yeah.
23:21:27 <dons> that's the greatest review of all time , ever
23:21:37 <dons> you can tell he loves freedom
23:21:53 <dons> made me want to get a nokia
23:21:54 <glguy> as in bribes or as in handcuffs?
23:22:18 <dons> mm. i'm thinking of doing a jdh30 quotes special this hwn coming up
23:22:26 <glguy> url
23:22:26 <dons> so many juicy tidbits
23:22:43 <Cale> I love how typing "best page" into firefox's URL bar takes you to his site.
23:23:03 <dons> oh man
23:23:05 <glguy> and for good reason
23:23:09 <dons> that's cool
23:25:33 <Cale> I love how he works the fundamental trig limit theorem into that review.
23:26:07 <glguy> When I see people wearing Crocs, I know immediately that we have nothing in common, and that we should never  be friends or have any meaningful kind of relationship
23:26:14 <dons> huh, an openid enabled blog. and about factor. http://www.phildawes.net/blog/2008/03/12/beginning-factor-is-like-programming-assembler/
23:26:20 <lambdabot> Title: Phil Dawes&#8217; Stuff  Blog Archive  Beginning Factor is like programming as ..., http://tinyurl.com/2j5csl
23:27:35 <BMeph> glguy: Crocs? As in La Coste/Izod?
23:28:34 <glguy> http://www.thebestpageintheuniverse.net/c.cgi?u=fashion
23:28:36 <lambdabot> Title: Fashion tips for women from a guy who knows dick about fashion.
23:28:36 <glguy> as in the shoes
23:29:26 <pjd> he should do a bit about Haskell
23:29:27 <Jaak> dolio: sweet, thanks
23:29:27 <lambdabot> Jaak: You have 1 new message. '/msg lambdabot @messages' to read it.
23:30:34 <dolio> Jaak: It uses de Bruijn indicies, but I thought it was close enough.
23:31:14 <dolio> Reflecting strings into the type system would be too much work. :)
23:35:31 <lispy> cabal might make building/configuring/installing haskell programs very consistent, but the README should probably still tell the user how to do those steps
23:36:21 <lispy> it turns out that, since I'm human I've forgetton the invocations since I last used cabal
23:37:50 <dfranke_> lispy: runhaskell Setup.hs configure && runhaskell Setup.hs build && runhaskell Setup.hs install
23:38:07 <lispy> dfranke_: thanks
23:38:15 <BMeph> glguy: Thanks for the blog pointer - I got a few good chuckles, AND got to tease my wife! ;)
23:38:20 <BMeph> Well, good night, all. :)
23:38:37 <lispy> now my problem is that I don't know which package to install to get zlib >= 0.3
23:38:50 <lispy> I installed this: zlib1g-dev
23:40:37 <lispy> oh that's a dirty trick, zlib is something on hackage i think.
23:41:49 <lispy> Codec/Compression/GZip.hs:46:7:
23:41:49 <lispy>     Could not find module `Data.ByteString.Lazy':
23:41:49 <lispy>       it is a member of package bytestring-0.9.0.1, which is hidden
23:41:59 <boyscared> anyone know a tutorial online that describes the syntax and use of multiple constructors?
23:42:06 <lispy> Could it be that my bytestring needs updated?
23:42:23 <lispy> oh, I bet I know the problem
23:42:28 <lispy> I must have an old version
23:42:39 <lispy> boyscared: multiple constructors?
23:42:48 <glguy> like Bool?
23:43:04 <boyscared> that's what "yet another haskell tutorial" calls it
23:43:35 <boyscared> but, it kinda glosses over the topic...
23:44:50 <lispy> oh
23:45:02 <lispy> data Foo = Foo | Bar | Baz | Quux
23:45:04 <lispy> I bet that's what they mean
23:45:13 <lispy> all of those will give me something of type Foo
23:45:27 <boyscared> yep, that's it
23:45:41 <boyscared> is there another term for that?
23:46:33 <lispy> algebriac data type :)
23:46:52 <lispy> I think I'm just tired, I don't see anything wrong with calling it multiple constructors
23:48:29 * lispy gets going with 'cabal'
23:48:55 <pjd> boyscared: http://en.wikibooks.org/wiki/Haskell/Type_declarations ?
23:48:56 <lambdabot> Title: Haskell/Type declarations - Wikibooks, collection of open-content textbooks
23:50:41 <boyscared> ok, i guess there really isn't anything special about them. YAHT kinda made it seem like there was. plus the exercises after that section were impossible with the info provided up to that point
23:51:25 <dfranke_> compiling ghc-STABLE:
23:51:26 <dfranke_> ghci/InteractiveUI.hs:434:35: Not in scope: `topHandlerFastExit'
23:55:20 <hpaste>  solrize pasted "is this going to leak file descriptors?" at http://hpaste.org/6325
23:56:42 <lispy> this cabal-install is extra super spiffy!
23:57:25 <bd_> solrize: they'll be closed eventually when the handle's collected, but exactly when is unpredictable
23:57:32 <bd_> wait
23:57:34 <lispy> it was worth the tedious bootstrapping process
23:57:37 <bd_> hmm
23:57:48 <bd_> I think readFile closes the handle if you reach the end
23:57:52 <bd_> otherwise, when it's GC'd
23:58:01 <mauke> what's the n for?
23:58:05 <glguy> correct
23:58:20 <solrize_> mauke, the function returns a list of n random numbers
23:58:25 <mauke> why?
23:58:31 <mauke> just return an infinite list
23:58:37 <solrize_> hmm
23:58:38 <solrize_> yeah
23:58:47 <lispy> > take 4 [1..]
23:58:49 <lambdabot>  [1,2,3,4]
23:58:50 <solrize_> point is i still may want to call this func a whole lot of times
23:59:08 <lispy> solrize_: so take n from it a whole lot of times :)
23:59:09 <solrize_> so if it's not going to close the fd's... i better do something
23:59:19 <glguy> solrize_: if you are worried about reclaiming file descriptors, withBinaryFile might be a better choice
23:59:21 <bd_> solrize: you'd probably be better off calling once, getting an infinite stream, then splitting it to get your random bytes
23:59:34 <solrize_> bd, yeah, that's probably best
23:59:41 <solrize_> i'll see if i can figure out how to do that
23:59:47 <bd_> your handle stays open forever, you only open it once, and you get all the random bytes you need
23:59:50 <lispy> :t splitAt
23:59:51 <lambdabot> forall a. Int -> [a] -> ([a], [a])
23:59:54 <bd_> more importantly, you don't need to stay in IO :)
