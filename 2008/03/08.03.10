00:04:12 <jlhamilton> It works if I give simple the type Parsec String () Char
00:37:13 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/6252
00:37:23 <campusblo> hi folks can someone check this code for me?
00:37:46 <campusblo> its a small program to return the end of a tuple
00:38:08 <campusblo> i dont understand why i keep getting that error
00:38:26 <Zao> Doesn't tail y have type [Int]?
00:38:41 <campusblo> you asking?
00:38:48 <campusblo> because i think it does
00:38:55 <campusblo> but winhugs doesnt seem to think so
00:39:27 <campusblo> wait
00:39:28 <campusblo> sorry
00:39:50 <Zao> It most certainly has type [Int], which doesn't match against your signature.
00:40:11 <Zao> ghci points at (tail y) being the broken part too.
00:41:15 <campusblo> ok so in the sig i need a list of tuples
00:41:48 <campusblo> sorry i was testing with tuples
00:43:06 <adu> campusblo: do you still need help?
00:43:40 <campusblo> im trying to figure it out adu
00:43:48 <adu> campusblo: i can tell you why
00:44:26 <campusblo> how would i say empty tuple?
00:44:31 <adu> ()
00:45:16 <adu> or Nothing, depending on context
00:45:28 <campusblo> *** Type           : [()]
00:45:38 <campusblo> *** Does not match : [(Int,Int)]
00:45:48 <adu> oo you mean an empty pair
00:45:55 <campusblo> yeh
00:45:55 <adu> thats totaly different
00:45:58 <campusblo> for the base case
00:46:25 <campusblo> oh ok . how do i say empty pair?
00:46:28 <adu> well, the base case would match [] not [(..., ...)]
00:46:55 <Zao> Mustn't a tuple have at least two elements?
00:47:59 <campusblo> ok so now i can't use head again
00:48:10 <adu> right
00:48:15 <adu> you would use fst/snd instead
00:48:15 <Zao> head is for lists.
00:48:54 <adu> try "search x (y:ys) | x == (fst y) = (snd y) | x /= (fst y) = (search x ys)"
00:49:19 <adu> with "search x [] = 0"
00:49:57 <dmwit> :t find
00:49:58 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
00:50:07 <campusblo> thanks adu
00:50:19 <adu> :)
00:51:46 <dmwit> :t \x -> maybe 0 snd . find ((==x) . fst)
00:51:47 <lambdabot> forall a b. (Eq a, Num b) => a -> [(a, b)] -> b
00:52:11 <campusblo> i was wondering though, how would you say second in an ordered pair?
00:52:21 <Zao> :t snd
00:52:22 <lambdabot> forall a b. (a, b) -> b
00:52:30 <adu> campusblo: snd
00:52:37 <dmwit> :t \x -> fromMaybe 0 . lookup x
00:52:37 <lambdabot> forall a b. (Eq a, Num b) => a -> [(a, b)] -> b
00:52:55 <campusblo> ok thanks
00:54:48 <adu> campusblo: also, if you want a shortcut, "search x = maybe 0 snd . find ((x==) . fst)" works just as well as dmwit noted
00:55:18 <dmwit> "search x = fromMaybe 0 . lookup x" is shorter. =)
00:55:25 <adu> hehe
00:57:28 <campusblo> ok thanks folks
01:20:32 <taruti> dons: the lambdabot repository @ code.haskell.org could use a tag (darcs get --partial wants to pull 1619 patches).
01:51:04 <wagle_home> http://packman.iu-bremen.de/suse/10.1/
01:51:06 <lambdabot> Title: Index of /suse/10.1
01:51:34 <wagle_home> i dont get it..  my browser wont see that
01:52:27 <oerjan> well mine does
01:53:34 <wagle_home> i think verizon is playing some sort of game..  they like intercepting my http stuff already
01:53:46 <glguy> verizon dns is pretty lousy
01:53:50 <glguy> I switched
01:53:55 <glguy> got tired of stuff not resolving
01:54:18 <wagle_home> the server resolved, just not the rest of the url
01:55:10 <wagle_home> uh never mind..  was getting some other server
03:54:59 <johnnowak> might anyone be able to tell me why 'b' is null? http://paste.lisp.org/display/57116
03:57:15 <dmwit> johnnowak: cfold doesn't look well-typed.
03:57:27 <dmwit> Oh, wait.
03:57:37 <dmwit> No, cfold just looks oddly-typed. =P
03:57:54 <johnnowak> how so?
03:58:17 <johnnowak> ACK
03:58:19 <dmwit> :t let cfold f z [] = []; cfold f z (x:xs) = f x z (\f -> cfold f y xs) in cfold
03:58:20 <lambdabot>     Occurs check: cannot construct the infinite type:
03:58:20 <lambdabot>       t = t1 -> Expr -> (t -> [a]) -> [a]
03:58:20 <lambdabot>     Probable cause: `f' is applied to too many arguments
03:58:36 <johnnowak> it type checks
03:58:42 <johnnowak> cfold :: (t -> t1 -> (t1 -> [a]) -> [a]) -> t1 -> [t] -> [a]
03:58:50 <johnnowak> the trouble is that the first case should be returning 'z'...
03:59:22 <johnnowak> ah, that's better.
04:05:41 <taruti> What is the preffered version of hs-plugins for ghc 6.8.2?
04:14:23 <quicksilver> @where hs-plugins
04:14:23 <lambdabot> http://code.haskell.org/~dons/code/hs-plugins
04:14:26 <quicksilver> taruti: that one
04:14:43 <quicksilver> malcolmw: I have some first-time-haxmler's thoughts, if you're interested.
04:15:15 <malcolmw> quicksilver: sure.  enough to make an email?  or just a couple of quick comments?
04:15:15 <lambdabot> malcolmw: You have 2 new messages. '/msg lambdabot @messages' to read them.
04:17:39 <quicksilver> malcolmw: whichever you prefer, I guess :) I find IRC more conducive to discussion but if you're mostly not around then email might work better.
04:18:41 <malcolmw> quicksilver: if I don't have time to work on it right now, it is better to have a permanent record in email, so i can come back to it
04:18:54 <malcolmw> quicksilver: but if you want to discuss it first, that is fine too!
04:19:38 <taruti> quicksilver: that doesn't seem to work. first the cabal file needs extra dependencies (6.6->6.8.2) and then it goes onto complaining about STArray constructor having changed. Does that version really work?
04:20:03 <quicksilver> malcolmw: well, first comment is I was surprised you don't have 'Show' instances for Content and Element and friends.
04:20:12 <quicksilver> I find these things invaluable when you're feeling your way around a new API.
04:20:23 <quicksilver> taruti: erm. Maybe it's the wrong repo then.
04:20:37 <quicksilver> taruti: that definitely shouldn't happen.
04:21:05 <taruti> mmh
04:21:20 <quicksilver> Cale: did lb's where database get reset?
04:21:55 <Cale> quicksilver: Not that I'm aware of, but I did get the repository from darcs, so it might have been slightly out of date at the time I did that.
04:21:59 <dcoutts> @seen sclv
04:21:59 <lambdabot> sclv is in #darcs, #xmonad, #ghc, #haskell-blah and #haskell. I last heard sclv speak 5h 41m 20s ago.
04:22:06 <dcoutts> sclv: pong
04:22:06 <lambdabot> dcoutts: You have 2 new messages. '/msg lambdabot @messages' to read them.
04:22:09 <quicksilver> Cale: is that @where correct?
04:22:11 <quicksilver> @where hs-plugins
04:22:12 <lambdabot> http://code.haskell.org/~dons/code/hs-plugins
04:22:23 <Cale> yes
04:22:26 <quicksilver> hmm
04:22:38 <quicksilver> then why is he seeing the STArray constructor error?
04:22:46 <quicksilver> that's supposed to be a symptom of the old codebase, not the new.
04:22:58 <Cale> Because he doesn't have that one.
04:23:16 <quicksilver> that seems like a sensible answer.
04:23:22 <taruti> hmm. my error.
04:23:26 <Cale> Which module is the error in?
04:23:26 <quicksilver> taruti: are you sure you downloaded the right thing / compiled the right thing? :)
04:23:29 <taruti>  http://www.cse.unsw.edu.au/~dons/code/hs-plugins <- this was too old.
04:23:32 <lambdabot> Title: Index of /~dons/code/hs-plugins
04:23:34 <quicksilver> right.
04:23:38 <quicksilver> that's why I didn't give you that.
04:23:53 <Cale> Which module is the compiler getting stuck on?
04:24:10 <malcolmw> quicksilver: yes, I recall k scaldiferri having a similar complaint on his blog.  Maybe more people use ghci than I realise.  It's easy to fix
04:24:14 <Cale> Inside src/ you should see only System/
04:24:27 <Cale> If you see Language/ then you have the wrong version.
04:24:42 <quicksilver> malcolmw: second comment is about the Combinators interface.
04:24:53 <Cale> (and it's the modules in Language/ which have the STArray problem)
04:24:57 <quicksilver> malcolmw: I found myself wishing that more of the combinators had more general types.
04:25:16 <malcolmw> quicksilver: more general how?
04:25:28 <quicksilver> not specialised to CFilter i
04:25:45 <quicksilver> "o :: (a -> [b]) -> (b -> [c]) -> (a -> [c])
04:25:47 <quicksilver> for example.
04:26:01 <quicksilver> some of them already are more general. |>| is, for example.
04:26:21 <quicksilver> malcolmw: point is when processing XML I don't always want to produce more XML. Sometimes I want to produce an answer :)
04:26:28 <quicksilver> in some other data type.
04:26:29 <malcolmw> quicksilver: hmm, I thought I already made them as general as possible, but maybe I missed a few
04:26:42 <malcolmw> quicksilver: ah, good point
04:26:54 <quicksilver> malcolmw: well o is just a section of concatMap. it's also >=> in the list monad, if I'm not mistaken.
04:27:39 <malcolmw> quicksilver: for a long time I wondered if the HaXml combinators were really a monad.  IIRC they are not.  But they might be an Applicative Functor or something instead
04:27:49 <quicksilver> malcolmw: however, I think there is a kind of "abstraction leak" in this a -> [b] interface.
04:28:00 <quicksilver> malcolmw: they're the Kleisli arrow of the list monad, aren't they?
04:28:09 <malcolmw> quicksilver: yep
04:28:16 <Jaak> the o sure looks like arrow compose
04:28:34 <malcolmw> that's why HXT took my combinators and made them arrows
04:28:36 <quicksilver> consier this : children `o` tag "foo"
04:28:49 <quicksilver> malcolmw: you can't distinguish between "I found a tag foo, and it had no children"
04:28:53 <Jaak> aaah, figures
04:28:54 <quicksilver> and "I didn't find a tag foo"
04:29:07 <malcolmw> quicksilver: I see
04:29:14 <quicksilver> that confused me quite a bit for a while.
04:29:46 <quicksilver> I ended up replacing : postProcess . (children `o` tag "foo")
04:29:56 <quicksilver> with (postProcess . children) . tag "foo"
04:30:00 <quicksilver> roughly
04:30:12 <quicksilver> which can distinguish between no tag, and tag with no children.
04:30:41 <nomeata> hi. are there any plans in GHC to make the libraries more ABI-stable, and to support shared haskell libraries?
04:30:41 <lambdabot> nomeata: You have 1 new message. '/msg lambdabot @messages' to read it.
04:30:43 <malcolmw> quicksilver: I think you can distinguish using something like "(children inside tag foo)`onFail`(something else)"
04:30:58 <hpaste>  quicksilver pasted "my HaXml code" at http://hpaste.org/6254
04:31:00 <malcolmw> quicksilver: I don't actually remember the combinator names, but something to do with choice
04:31:25 <quicksilver> malcolmw: take a look at that paste, if you're interested.
04:31:37 <quicksilver> malcolmw: that's the code I came up with for parsing an Apple-style .plist file.
04:32:00 <hpaste>  quicksilver annotated "my HaXml code" with "missed out 'getText'" at http://hpaste.org/6254#a1
04:32:07 <yitz> malcolmw: for heavy-duty real-life xml work - when do I want haxml and when do I want hxt? (yes, I know you're biased, that's one reason I'm asking you)
04:33:06 <malcolmw> yitz: I've never used HXT, so I can't compare except theoretically
04:33:14 <yitz> ok, fair enough
04:33:20 <yitz> hearsay is fine
04:33:23 <faxathisia> hi
04:34:11 <faxathisia> I wrote an interpreter for this language but the self interpreter for the paper doesn't work :/
04:34:15 <malcolmw> yitz: so HaXml now has lazy parsing, which can come in handy for large or incomplete XML inputs
04:34:56 <malcolmw> yitz: but HXT sees more maintenance work than I can afford to put into HaXml, so it is probably more feature-complete
04:34:59 <yitz> malcolmw: ok. how's standards compliance? dtds? xsds?
04:35:21 <quicksilver> malcolmw: I'm pleased with the way it works, but slightly disatisfied with the mixture of "map", "concatMap", (.) and `o` meaning subtly different things.
04:36:12 <malcolmw> yitz: HaXml was XML-1.0 compliant (excluding character encodings) when I wrote it.  There have been a couple of revisions to 1.0 since then, which broke a couple of small things (since fixed), but there may be more lurking.
04:36:35 <DukeDave> Quick advice question, I'm about to write a function to read a (560MB) file into a Data.Map.. Is there anything I should consider?
04:36:47 <malcolmw> yitz: HaXml does DTD, but not XSD.
04:36:52 <yitz> malcolmw: parsing styles - dom-like, sax-like, or whatever?
04:36:57 <DukeDave> I.e. I am planning to to a foldlM Data.Insert
04:37:19 <yitz> malcolmw: how complete is dtd support (I know that's a big pain)
04:37:37 <quicksilver> DukeDave: keys and values are strings?
04:37:46 <malcolmw> yitz: HaXml has sax-like, not dom-like, but does have functional-style parsing into a concrete tree.  HXT has DOM.
04:38:01 <dmwit> DukeDave: Do you know anything helpful, like that the input keys are in ascending order or so?
04:38:02 <yitz> DukeDave: use foldl' and insertWith'
04:38:05 <taruti> thanks
04:38:10 <taruti> grr @ irssi.
04:38:16 <DukeDave> quicksilver: Keys are Data.Word
04:38:28 <quicksilver> DukeDave: values are?
04:38:30 <Cale> taruti: figure it out?
04:38:36 <malcolmw> yitz: there are some odd corners of the DTD language that I did not understand (and were not explained in the spec), like NOTATION types etc
04:38:53 <DukeDave> dmwit: Unfortunately not, there is some ordering (i.e. blocks in order) but we can make no guarantee
04:38:55 <Cale> yitz: It really annoys me that Data.Map doesn't have insertWith'
04:38:56 <dmwit> DukeDave: fromList/fromListWith is more convenient (but equivalent in terms of speed).
04:38:59 <DukeDave> quicksilver: Strings
04:39:07 <quicksilver> DukeDave: OK, definitely use ByteString.
04:39:14 <quicksilver> loading 560MB of strings will make you unhappy.
04:39:25 <DukeDave> ByteString, roger
04:39:30 <taruti> Cale: yes. got it working.
04:39:39 <quicksilver> DukeDave: approximiately how many K-V pairs?
04:39:40 <malcolmw> quicksilver: Yes, I understand.  The different kinds of "it's just composition" glue to plug combinators together is a bit of a pain.
04:39:40 <Cale> taruti: great :)
04:39:50 <yitz> I sure don't understand them either. But I'll need to read in all kinds of dtd produced by people/apps that do.
04:39:57 <DukeDave> In terms of speed is it better to read the keys to a Data.Word or leave them as ByteStrings ?
04:40:01 <quicksilver> malcolmw: on a more trivial note, I was annoyed by all the explict constructor matching I needed to do :)
04:40:10 <Cale> Er, duh
04:40:12 <quicksilver> malcolmw: you don't seem to be in favour of selector functions
04:40:23 <Cale> yitz: It really annoys me that Data.Map doesn't have fromListWith', heh
04:40:32 <quicksilver> DukeDave: they're 4-byte, I take it? You might as well get them as words, IMO.
04:40:52 <quicksilver> malcolmw: like (in that paste) getting the 'name' of the element for a sensible error message.
04:40:54 <yitz> Cale: ah, ok. right.
04:41:14 <Cale> I've been up a little long :)
04:41:33 <DukeDave> quicksilver: Just waiting for wc to come back with a number of k/vs
04:41:41 <malcolmw> quicksilver: re selectors - good point.  I rarely use them, but when I do, they are very useful.
04:42:28 <yitz> Cale: I still remember when Data.Map didn't even have insertWith'. That was *really* annoying.
04:42:47 <Cale> Yeah, then there's basically nothing you can do :)
04:43:06 <quicksilver> malcolmw: I guess I was really wondering if I was doing something stupid: I.e. if these 'omissions' weren't really omissions because there was a better way of doing it.
04:43:30 <quicksilver> malcolmw: I think my conclusion is that your combinators are just great for XML -> XML but could perhaps be polished up a bit for XML -> SomethingElse.
04:43:38 <malcolmw> DukeDave: how much parsing does the file need?  If it is significant enough to want parser combinators, then you'll almost certainly want polyparse's laziness
04:44:25 <malcolmw> quicksilver: that's an insightful point.  they were indeed only designed for XML transformation, because that was what the customer wanted.
04:44:49 <quicksilver> malcolmw: but still, I did manage to transform XML into a nice rep of an Apple PList file with really not many lines of code. So it's not bad.
04:44:54 <malcolmw> quicksilver: but you are right that perhaps the combinators could all be more general
04:45:04 <quicksilver> malcolmw: this "no children" vs "no match" issue was the most painful one.
04:45:20 <malcolmw> quicksilver: OK.  email me about that one.
04:45:48 <malcolmw> quicksilver: oh, and mention the other points briefly too :-)  just to help my failing memory.
04:47:02 <yitz> malcolmw: a functional concrete tree repr. is likely a far better "dom-like" than dom. Is it possible in hxt?
04:47:11 <quicksilver> malcolmw: OK, I'll drop you an email this evening. the address that you typically use to post to the cafe is the right one?
04:47:22 <DukeDave> malcolmw: Parsing is trivial, it's just  "<key> \t <value> \n"
04:47:22 <malcolmw> quicksilver: yep
04:47:44 <DukeDave> quicksilver: 17611671 pairs to be read in
04:47:59 <quicksilver> Gosh.
04:48:00 <malcolmw> DukeDave: oh, not too difficult then - any deeper structure in the keys or values?
04:48:09 <quicksilver> A Data.Map of 17m values.
04:48:11 <yitz> dom would be good for - uh - literal translation of Java dom code into haskell
04:48:14 * yitz shudders
04:48:24 <quicksilver> that's going to take a fair few MB of heap space, I think.
04:48:25 <DukeDave> And at 600MB for the text file I need the whole map to fit in memory.. (4GB to play with)
04:48:34 <ndm> DukeDave: lines and break should be plenty of sufficient
04:48:39 <quicksilver> I wonder what the fixed-cost per node overhead for Data.Map is.
04:48:40 <malcolmw> yitz: I rather expect HXT has the concrete tree as well as a DOM interface, yes
04:48:55 <ndm> DukeDave: but you may want to store Key/Value's in ByteString's rather than String, since they take up less space (unless they are dead short)
04:48:57 <DukeDave> malcolmw: None at all
04:49:40 <malcolmw> DukeDave: numbers? text?
04:49:47 <DukeDave> ndm: Yeah, currently it's going to be  Data.Map Data.Word Data.ByteString
04:50:12 <quicksilver> DukeDave: I think you should expect it to take between 1 and 2G in memory to represent.
04:50:32 <DukeDave> That would be great..
04:50:54 <quicksilver> DukeDave: you've got a fixed cost per map node of, I would expect, 40-100 bytes,
04:51:02 <quicksilver> I'm not sure exactly how much.
04:51:15 <quicksilver> plus your actual data which is around 40 bytes.
04:51:25 <malcolmw> I have some 200 textfiles to read, each of which contains 330 million values
04:51:28 <quicksilver> 80 x 17M = 1G.
04:51:41 <quicksilver> ehm.
04:51:47 <quicksilver> 1.5G :)
04:52:02 <yitz> malcolmw: thanks. It sounds like I should have both in my toolbox.
04:52:37 <malcolmw> hey andyjgill!  can't sleep?
04:52:49 <faxathisia> HI
04:53:07 <dmwit> HELLO HELLO!
04:53:10 <ndm> yitz: i just have tagsoup in my toolbox, and have never needed more
04:53:10 <andyjgill> No, I'm in Kansas right now. Its 7am here. :-)
04:53:22 * faxathisia is not in Kansas
04:53:37 <DukeDave> Right, lets code this up and see.. I'm going to use readLine, read, foldl' and insertWith'. Sound good?
04:54:08 <quicksilver> I think you want to use ByteString.hGetLine.
04:54:21 * DukeDave nods
04:54:35 <DukeDave> Although, can I read a Bytestring to a Word?
04:54:38 <faxathisia> is ByteString lazy?
04:54:48 <malcolmw> andyjgill: I was wondering if you had a JaffaCake with you, but he's probably in Portland right now
04:54:58 <ndm> faxathisia: if you call hGetLine, it reads only one line, so yes
04:55:04 <faxathisia> cool
04:55:13 <andyjgill> Yes, he got to portland okay. I had lunch with him on Saturday.
04:55:41 <andyjgill> And he starts his sabbatical today.
04:56:32 <malcolmw> andyjgill: say, do you know anything deep about ghc's SPECIALISE pragmas?  Like did you help implement them or anything?
04:56:53 <andyjgill> malcolmw: no, sorry.
04:57:18 <malcolmw> andyjgill: OK, I'll bug JaffaCake when he appears then.
04:57:50 <andyjgill> No problem.
04:58:46 <dcoutts> malcolmw: btw, I wanted to talk to you about polyparse again at some point when you have a moment
04:59:06 <malcolmw> dcoutts: yes, I saw your messages on lambdabot
04:59:50 <malcolmw> dcoutts: "<?> has no effect for severe errors (because onFail gets ignored for severe errors)"
05:00:07 <malcolmw> dcoutts: can you explain what you expected?
05:04:25 <georgw> Hi all. Me again with a general Haskell question. I want to implement a randomized algorithm to optimize a knapsack problem. I wonder how to best structure the code. I have to repeatedly use a bit of randomness to modify a knapsack 100'000 times. Should I best write a function (monad, I guess?) that does a perturbation and call that 100'000 times? Or should I write a fuction, generate 100'000 sets of randomness in main and give that as an argument t
05:04:25 <georgw> o a function? Should I look at and instance Computation? Some general hint for a direction would greatly help me. :-)
05:05:55 <Cale> georgw: well, there are a few ways to string pseudorandom generators or their results through your code
05:06:29 <Cale> georgw: Indeed, one of them is to use the randoms, or randomRs function to generate an infinite list of random values and then pass that into your algorithm.
05:07:21 <Cale> georgw: another would be to pass around StdGen values explicitly. Using randomR will give you a pseudorandom value, and a fresh generator state to be used.
05:07:47 <Cale> (there's a function split which splits a generator into two, for when you need to make two recursive calls)
05:08:57 <Cale> georgw: another possibility is using a monad like the State monad to manage the threading of that StdGen through your program. There's also (on the wiki) a custom monad built from the State monad for that.
05:09:24 <dcoutts> malcolmw: I was expecting it to be somewhat declarative like in parsec: parseVersion <?> "version" so when there's a failure in it it says what it was expecting
05:10:03 <dcoutts> malcolmw: I was experimenting with commit, eg in a package parser we have "foo-1.0" I was adding a commit after the '-'
05:10:15 <georgw> Cale: Any particular method you would recommend?
05:10:23 <Cale> georgw: Well, these are all reasonable.
05:10:45 <dcoutts> malcolmw: and it changed the error message from "version" to an error message that reflected the internal structure of the version parser, about a non-empty sequence of things
05:10:45 <Cale> georgw: If you know what each step is going to do with the knapsack, it would be worth considering designing the program as a fold.
05:10:45 <malcolmw> dcoutts: ah, ok, that was not what I thought <?> did.  Easily fixed I think
05:11:24 <georgw> Cale: Ah, that's interesting. I never thought of it as a fold...
05:11:54 <dcoutts> malcolmw: I'm not sure that the polyparse error reporting system is ideal, it reflects the parse tree rather than the set of things expected and what was actually encountered, the latter is much more helpful I think.
05:11:56 <Cale> georgw: On the other hand, if you really need mutation, there is a monad called ST which gives you mutable arrays and references and can wrap everything up into a pure computation.
05:12:52 <Cale> georgw: Somewhere in between those two is just explicit recursion, keeping the current state in the parameters to the function.
05:13:09 <malcolmw> dcoutts: I can see that.  But I also think it is relatively straightforward to get what you want.  I'll play around and push something later today.
05:13:10 <georgw> Cale: Ok, thanks. I guess, I'll read the Monad chapter in YAHT first and then structure the program in one of those ways. Fold looks like something interesting to try.
05:13:20 <dcoutts> malcolmw: see also Koen Claessen's ParseK which uses a symmetric <|> and uses parsec's error reporting style
05:13:24 <Cale> You tend to want to avoid explicit recursion, but sometimes it's a flexible thing to do when you don't know what else to try.
05:13:29 <georgw> Cale: Did explicit recursion up to now, but fold seems like a nices structure.
05:13:55 <malcolmw> dcoutts: ooh, is that new?
05:13:57 <Cale> Yeah, map, filter, and various folds take the place of loops in most Haskell code.
05:14:06 <georgw> Takes a while to get used to the tools of functional programming. X-)
05:14:19 <Cale> Generally, data structures, and the higher-order functions on them, are our control structures.
05:14:30 <dcoutts> malcolmw: it was a bit of an experiment, it was mentioned in the ReadP paper as a version of parsec based on the ReadP ideas
05:14:39 <dcoutts> @where parsek
05:14:39 <lambdabot> http://www.cs.chalmers.se/Cs/Research/Functional/MultiLib/koen/Parsek.hs
05:14:50 <dcoutts> hmm, that's not the version I was thinking of
05:15:09 <georgw> Cale: Yep, figured that out and really liked it. As soon as I hit recursion, I'm not so sure anymore. But that problem is sure a nice project for experimentation.
05:16:07 <malcolmw> dcoutts: p <?> e = p `adjustErr` (\m-> "When expecting a "++e++":\n"++indent m)
05:16:43 <dcoutts> malcolmw: http://www.augustsson.net/Darcs/Parsek/
05:16:44 <lambdabot> Title: Index of /Darcs/Parsek
05:17:41 <dcoutts> malcolmw: so polyparse's <|> is left biased, yes? but is properly compositional
05:18:08 <malcolmw> dcoutts: left biased, yes.  the clue is in the name "onFail" :-)
05:18:20 <malcolmw> dcoutts: and compositional, yes
05:18:38 <dcoutts> malcolmw: so the key difference between polyparse and ReadP/ParseK is that the latter have an unbiased <|>
05:18:54 <faxathisia> http://www.cs.chalmers.se/Cs/Research/Functional/Pictures/logo.gif heh
05:18:56 <dcoutts> malcolmw: which is a blessing and a curse
05:18:57 <lambdabot> http://tinyurl.com/ywyygf
05:18:58 <malcolmw> dcoutts: I guess so
05:19:17 <malcolmw> unbiased = must parse in parallel = big space leak?
05:19:32 <dcoutts> malcolmw: right
05:19:36 <dcoutts> malcolmw: ParseK has a cunning thing where you can select the kind of parse you want, shortest, longest, all, etc
05:20:09 <dcoutts> malcolmw: well, not a space leak exactly since it never has to backtrack, but if there are lots of 'live' parses then it has to remember them all
05:20:23 <dcoutts> malcolmw: so it depends on the ambiguity of the grammar
05:20:42 <earthy> that's much the same issue that UULib's parsing lib has
05:20:48 <dcoutts> malcolmw: I asked augustss why he doesn't use it all the time and he said he got exponential blowup for an expression parser
05:20:59 <malcolmw> :-)
05:21:04 <dcoutts> but did not really investigate the details
05:21:13 <dcoutts> malcolmw: so I'm still not sure where to go :-)
05:21:54 <dcoutts> malcolmw: I think the most important aspect for a cabal parser is good error messages and small enough to bundle in the Cabal lib (or if it's a core lib of course so we can depend on it)
05:22:37 <malcolmw> dcoutts: I think we can get good error messages out of polyparse, but it probably needs a little bit of work to get them just the way you want them.
05:22:53 <dcoutts> malcolmw: perhaps I should do a side-by-side comparison of ReadP, polyparse, parsec, parsek :-)
05:23:07 <malcolmw> dcoutts: parsec is a core lib (but there are now multiple versions)
05:23:23 <dcoutts> malcolmw: it's not a core lib any more
05:23:37 <pejo> dcoutts, if you do - please write it down. :-)
05:24:10 <dcoutts> malcolmw: at least I didn't think it was, network depends on it but I don't think that's a core lib either
05:24:13 <earthy> and include uulib's parsing, so doaitse has something to shoot at :)
05:24:23 <dcoutts> earthy: oh yes, that too
05:24:40 <malcolmw> dcoutts: if you do all 12 versions of polyparse, against the rest, I'll be impressed.
05:24:46 <dcoutts> heh, would be tricky to get all the qualified names and operators
05:25:06 <malcolmw> earthy: I tried to modify uulib to get a monadic interface, but it defeated me
05:25:06 * earthy hints at a haskell parser combinator taskforce :P
05:25:07 <dcoutts> malcolmw: they're not different in error messages or expressiveness though are they?
05:25:19 <earthy> malcolmw: that's because it's almost impossible
05:25:28 <DukeDave> So I have a function [(k,a)] -> Map k a which (strictly) populates my map... If I now write a function FileHandle -> [(k,a)] and use liftM on my populating function will my program load all of [(k,v)] first and then populate the map? :|
05:25:35 <earthy> at least given the kinds of optimizations it does
05:25:58 <earthy> doaitse's cracked that nut as well though. there's some info in the LerNet'08 lecture notes on that
05:26:02 <malcolmw> dcoutts: all the polyparse variants have an almost identical interface, it is true.  they differ in speed and error messages
05:26:38 <dcoutts> malcolmw: oh, then yes, I'd want to compare the bsd version and the version with best error messages
05:27:42 <yitz> DukeDave: if your function is lazy you'll be fine.
05:27:54 <malcolmw> dcoutts: for my paper, I reimplemented the HaXml parser using Parsec to compare with polyparse, so that might be a good starting place
05:28:06 <faxathisia> @remember yitz if your function is lazy you'll be fine.
05:28:06 <lambdabot> Done.
05:28:21 <DukeDave> yitz: I'm using the strict version of insertWith :o
05:28:37 <dcoutts> malcolmw: I was thinking of just adding parsers for all the basic cabal data types for all the different parser libs
05:28:50 <malcolmw> dcoutts: well that would be simpler
05:28:54 <yitz> DukeDave: that's right, but that's just for the second step where you build the map.
05:29:00 * malcolmw heads for lunch
05:32:36 <yitz> DukeDave: when I do this kind of thing, I always try stuff on small subsets first to make sure it works. (and save my work, so that after I sink my machine I can get it all back)
05:33:06 <DukeDave> yitz: Very wise :)
05:35:35 <johnnowak> ?hoogle (a -> [a] -> ([a] -> [b]) -> [b]) -> [a] -> [b]
05:35:35 <lambdabot> No matches, try a more general search
05:36:15 <faxathisia> johnowak: Huh?!
05:36:36 * johnnowak is marginally confused
05:38:07 <faxathisia> :t const id :: (a -> [a] -> ([a] -> [b]) -> [b]) -> [a] -> [b]
05:38:08 <lambdabot>     Couldn't match expected type `b' against inferred type `a'
05:38:08 <lambdabot>       `b' is a rigid type variable bound by
05:38:08 <lambdabot>           the polymorphic type
05:38:43 <faxathisia> johnowak: I don't think such a function exists
05:38:57 <ToRA> @djinn (a -> [a] -> ([a] -> [b]) -> [b]) -> [a] -> [b]
05:38:57 <lambdabot> -- f cannot be realized.
05:38:59 <faxathisia> what sort of thing is it?
05:39:22 <yitz> @type const (flip ($))
05:39:23 <lambdabot> forall a b b1. b1 -> a -> (a -> b) -> b
05:40:45 <johnnowak> ?type \g f (x:xs) -> f x xs (\y -> g f y)
05:40:46 <lambdabot> forall t t1 t2 t3. ((t -> [t] -> (t1 -> t2) -> t3) -> t1 -> t2) -> (t -> [t] -> (t1 -> t2) -> t3) -> [t] -> t3
05:40:49 <johnnowak> blort
05:40:57 <faxathisia> yow
05:41:12 <faxathisia> what's that for O_o
05:41:19 <kpreid> ah, yeah, the first type sig can't exist because the function of that type has to supply the [a] -> [b] function
05:41:45 <kpreid> well, it can if the function is const [] or const [_|_] ...
05:41:54 <ski> johnnowak : what are you trying to do ?
05:43:43 <DukeDave> @hoogle ReadMode
05:43:43 <lambdabot> System.IO.ReadMode :: IOMode
05:43:43 <johnnowak> ski: er.. yaht exercise. write map in continuation passing style
05:43:58 <DukeDave> Uh...   Module `System.IO' does not export `ReadMode'
05:43:58 <faxathisia> :t map
05:44:00 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
05:44:43 <johnnowak> i get the feeling i didn't do it right.
05:45:04 <faxathisia> (a -> (b -> k1) -> k1) -> [a] -> ([b] -> k2) -> k2
05:45:08 <faxathisia> is that the right type?
05:45:10 <ski> johnnowak : why bother with `cfold', then ?
05:45:18 <faxathisia> for CPS map
05:45:23 <yitz> DukeDave: FileMode(..) (or something like that)
05:45:30 <johnnowak> ski: was trying to understand the cfold example
05:45:41 <johnnowak> http://paste.lisp.org/display/57123
05:46:02 <faxathisia> johnowak: Is my type correct?
05:46:41 <DukeDave> yitz: Still dying, even with FileMode(ReadMode)
05:46:46 <johnnowak> faxathisia: i don't know. hm.
05:46:53 <faxathisia> How do you CPSify the type of a higher order function?
05:47:01 <yitz> DukeDave: sorry, it's: IOMode(..)
05:47:21 <DukeDave> Aha :D
05:47:32 <DukeDave> Could probably have got there myself with Hoogle ;)
05:48:25 <johnnowak> faxathisia: i don't seem to know
05:48:36 <ski> johnnowak : you need a worker-wrapper
05:48:41 <faxathisia> anyone?
05:48:43 <ski> faxathisia : yes
05:49:09 <johnnowak> faxathisia: is that paste completely wrong then?
05:49:20 <ski> the latest ?
05:49:31 <johnnowak> http://paste.lisp.org/display/57123
05:50:51 <faxathisia> ?Djinn (a -> (b -> k1) -> k1) -> Maybe a -> (Maybe b -> k2) -> k2
05:50:51 <lambdabot> f _ _ a = a Nothing
05:51:06 <faxathisia> yes.. ?
05:51:13 <faxathisia> :/
05:51:25 <faxathisia> ?Djinn (a -> (b -> k) -> k) -> Maybe a -> (Maybe b -> k) -> k
05:51:25 <lambdabot> f a b c =
05:51:25 <lambdabot>     case b of
05:51:25 <lambdabot>     Nothing -> c Nothing
05:51:25 <lambdabot>     Just d -> a d (\ e -> c (Just e))
05:51:54 <yitz> @type let{cmap f []=[];cmap f(x:xs)=f x xs(\y->cmap f y)}in\f s->cmap(\x xs c->f x: c xs)s
05:51:55 <lambdabot> forall t a. (t -> a) -> [t] -> [a]
05:51:57 <dolio> @type let map' f [] k = k [] ; map' f (x:xs) k = f x (\b -> map' f xs (\bs -> k (b : bs))) in map'
05:51:58 <lambdabot> forall t a t1. (t -> (a -> t1) -> t1) -> [t] -> ([a] -> t1) -> t1
05:52:08 <johnnowak> yar!
05:52:16 <johnnowak> that looks more reasonable
05:52:56 <ski> johnnowak : i think your paste possibly works .. but i don't think it is idiomatic cps
05:53:02 <johnnowak> faxathisia: why is it that the example in yaht doesn't take an argument argument?
05:53:07 <johnnowak> ski: it does seem to work
05:53:15 <johnnowak> *an EXTRA argument rather
05:53:41 <ski> johnnowak : because that `cfold' version corresponds to `foldl' so it is tail-recursive, so it doesn't need non-local continuation argument
05:53:50 <ski> (i.e. it is not a good example, imo)
05:54:08 <johnnowak> ah i see. i was unsure about map because it wasn't tail recursive...
05:54:12 <johnnowak> let me see if i can get filter then.
05:54:16 <yitz> > let{cmap f []=[];cmap f(x:xs)=f x xs(\y->cmap f y);map' f s=cmap(\x xs c->f x: c xs)s}in map' (+3)[2,4..10]
05:54:17 <lambdabot>  [5,7,9,11,13]
05:57:48 <faxathisia> :t let mapk f [] k = k [] ; mapk f (x:xs) k = mapk f xs \bs -> f x : bs in mapk :: (a -> (b -> k) -> k) -> [a] -> ([b] -> k) -> k
05:57:48 <lambdabot> parse error on input `\'
05:57:59 <faxathisia> :t let mapk f [] k = k [] ; mapk f (x:xs) k = mapk f xs (\bs -> f x : bs) in mapk :: (a -> (b -> k) -> k) -> [a] -> ([b] -> k) -> k
05:57:59 <lambdabot>     Occurs check: cannot construct the infinite type: b = (b -> k) -> k
05:58:03 <faxathisia> :/
05:58:33 <faxathisia> :t let mapk f [] k = k [] ; mapk f (x:xs) k = mapk f xs (\bs -> ?what) in mapk :: (a -> (b -> k) -> k) -> [a] -> ([b] -> k) -> k
05:58:34 <lambdabot>     Could not deduce (?what::k) from the context ()
05:58:34 <lambdabot>       arising from a use of `mapk' at <interactive>:1:71-74
05:58:34 <lambdabot>     Possible fix:
05:59:53 <dolio> @type let map' f [] k = k [] ; map' f (x:xs) k = map' f xs (\bs -> f x (\b -> k (b:bs))) in map'
05:59:54 <lambdabot> forall t a t1. (t -> (a -> t1) -> t1) -> [t] -> ([a] -> t1) -> t1
06:01:26 <Cale> johnnowak: map isn't tail recursive, but it's something much nicer, it's productive, in the sense that it immediately returns a constructor.
06:01:45 <faxathisia> :t let mapk f [] k = k [] ; mapk f (x:xs) k = mapk f xs (\bs -> f x (\b -> k (b : bs))) in mapk :: (a -> (b -> k) -> k) -> [a] -> ([b] -> k) -> k
06:01:46 <lambdabot> forall a b k. (a -> (b -> k) -> k) -> [a] -> ([b] -> k) -> k
06:02:02 <Cale> johnnowak: Thus, evaluating map only costs a constant amount for each cell of the resulting list you use.
06:02:41 <faxathisia> can you higher order CPS automatically?
06:03:20 <faxathisia> must be able to ..
06:03:29 <Cale> I'm pretty sure it's possible.
06:03:45 <dolio> @type \f l = runCont $ mapM (Cont . f) l
06:03:46 <lambdabot> parse error on input `='
06:03:52 <dolio> @type \f l ->' runCont $ mapM (Cont . f) l
06:03:54 <lambdabot> lexical error in string/character literal at character 'r'
06:03:55 <dolio> @type \f l -> runCont $ mapM (Cont . f) l
06:03:56 <lambdabot> forall a r a1. (a1 -> (a -> r) -> r) -> [a1] -> ([a] -> r) -> r
06:04:32 <ski> > let aba xs = abaK xs id; abaK [] k = k []; abaK (x:xs) k = abaK xs (k . (x :) . k) in aba [0,1,2,3,4]
06:04:32 <lambdabot>  [0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0]
06:04:40 <faxathisia> huh! :D
06:04:51 <ski> (ponder that for awhile ! :)
06:05:37 <DukeDave> @wikibook
06:05:38 <lambdabot> Unknown command, try @list
06:05:44 <ski> (faxathisia : "higher order CPS" ?)
06:05:47 <DukeDave> @where wikibook
06:05:47 <lambdabot> http://en.wikibooks.org/wiki/Haskell
06:07:30 <shapr> @where shapr
06:07:30 <lambdabot> http://www.ScannedInAvian.com/hope
06:08:03 <ski> @where haskell
06:08:03 <lambdabot> http://haskell.org/
06:10:08 <shepheb> ski: I think he was using "higher order" as a verb.
06:10:57 <ski> i still don't get what he was meaning by that
06:11:12 <ski> (or she, as the case may be)
06:13:36 <dolio> I think he means finding the CPS form of functions which take functions as arguments, which must, of course, be CPSed themselves.
06:14:08 <ski> > let append xs = appendK xs id; appendK [] k = k; appendK (x:xs) k = appendK xs (\ys -> k (x:ys)) in append [0,1,2] [3,4]  -- another fun cps thing
06:14:09 <lambdabot>  [0,1,2,3,4]
06:16:19 <dolio> @type let appendK [] k = k; appendK (x:xs) k = appendK xs (\ys -> k (x:ys)) in appendK
06:16:21 <lambdabot> forall t t1. [t] -> ([t] -> t1) -> [t] -> t1
06:16:45 <dolio> Oh, right. I see what's going on.
06:17:04 <ski> a `shift' in the right place ..
06:17:44 <georgw> For random variations I need to create a list (or array if better suited) where all elements are false by default and at most m elements are true. I thought it might be a good way to use an initial list with all elements false and then to three times flip an element at a random position. But how do I do this best in Haskell?
06:17:57 <ski> [[tau]]_e = ([[tau]]_v -> o) -> o
06:18:00 <ski> [[alpha]]_v = alpha
06:18:02 <ski> [[tau0 -> tau1]]_v = [[tau0]]_v -> [[tau1]]_e
06:18:07 <georgw> s/three\ times/m\ times/g
06:18:21 <ski> that's one cps translation for types (cbv variant)
06:20:28 <ski> append xs = reset (append' xs)
06:20:31 <ski>   where
06:20:36 <ski>   append' [    ] = shift xs -> xs
06:20:37 <ski>   append' (x:xs) = x : append' xs
06:20:44 <ski> ^ in direct style
06:21:06 <georgw> [1,2,3,4,5] ! 2
06:21:16 <ski> (er, rename `xs' to `k' in the `shift' part .. doesn't matter for correctness, though)
06:21:23 <quicksilver> georgw: generate the three random flips
06:21:29 <ski> > [1,2,3,4,5] !! 2
06:21:30 <lambdabot>  3
06:21:34 <quicksilver> georgw: then 'lazily' generate the correct list.
06:21:52 <georgw> ski: thx! :-)
06:22:24 <georgw> quicksilver: By generating randomly the list index and flipping?
06:22:34 <quicksilver> my point is, don't actually 'do' the flip
06:23:01 <quicksilver> just generate a list on demand which includes the flip
06:23:23 <georgw> quicksilver: Ok, so I'd have a function that takes a list, does the flip and returns the new list, right?
06:24:24 <faxathisia> ski: What are _e and _v?
06:24:24 <shapr> @users
06:24:24 <lambdabot> Maximum users seen in #haskell: 465, currently: 415 (89.2%), active: 14 (3.4%)
06:24:32 <quicksilver> > let gen n len [] = replicate (len - n) False ; gen n len (m:ms) = if m == n then True : gen (n+1) len ms else False : gen (n+1) len (m:ms) in gen 0 10 [2,5]
06:24:33 <lambdabot>  [False,False,True,False,False,True,False,False,False,False]
06:24:55 <ski> faxathisia : expression- and value- variants of the transformation
06:25:10 <quicksilver> georgw: gen 0 len flips : generate a list of bools of length 'len' all False except for those indexes mentioned in the list 'flips'.
06:26:45 * johnnowak still doesn't understand why cfold doesn't need another argument
06:28:16 <georgw> quicksilver: That's neat. :-) Where should I generate the randomness? I could do that in main and pass it all along, or I could have it in that function, but I guess that would be monadic then. Which way might hurt less?
06:28:21 <ski> johnnowak : you can define it so it uses an extra argument .. but it will just carry it around, not changing it at any time
06:28:33 <ski> @src foldr
06:28:33 <lambdabot> foldr f z []     = z
06:28:34 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
06:28:54 <johnnowak> ski: I guess that problem is that I don't know how to verify that a function is properly written in CPS.
06:28:54 <ski> @src foldl
06:28:54 <quicksilver> georgw: definitely not in that function.
06:28:56 <lambdabot> foldl f z []     = z
06:28:56 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
06:29:32 <ski> johnnowak : every (non partially applied) call should be a tail call
06:29:50 <faxathisia> It may be clearer when using uncurried functions
06:29:57 <ski> *nod*
06:30:20 <ski> (or it may be clearer to grind through a cps-transform by hand a few times)
06:33:03 <johnnowak> ski: http://en.wikipedia.org/wiki/Continuation-passing_style#Examples -- are those examples correct?
06:33:08 <ndm> for some reason I seem to disagree vehemently with everything that Adrian Hey says on the mailing list...
06:34:04 <shapr> ndm: What did he say?
06:34:32 <ndm> shapr: i said that instance Ord (Int, Bool) where compare (a,_) (b,_) = compare a b   is a fine Ord instance
06:34:47 <ndm> (assuming an associated Eq, and probably not overloading Tuple but defining your own data type)
06:34:59 <ndm> he says that sort which just keeps track of duplicates and does replicate is a fine solution
06:35:05 <faxathisia> johnnowak: There's no reason to have put (* x x (lam.. instead of (* y y (lam.. but I guess that's not important
06:35:57 <ndm> he seems to be the only person i consistently disagree completely with...
06:37:22 <ski> johnnowak : yes, those scheme examples are correct, modulo choice of evaluation order of arguments (to be left-to-right)
06:38:22 <georgw> Is there a //-equivalent for lists?
06:38:27 <johnnowak> hm, thanks.
06:38:28 <yitz> ndm: does that mean I'm improving?
06:38:39 <ndm> georgw: you mean \\ ?
06:38:59 <ndm> georgw: if you are asking for set subtraction/difference
06:39:05 <ski> > [0..9] \\ [4..6]
06:39:06 <lambdabot>  [0,1,2,3,7,8,9]
06:39:09 <ndm> yitz: have i ever disagreed with you?
06:39:27 <georgw> I want to modify a value in a list.
06:39:29 * ndm doesn't have a IRC name/email mapping, or a very good memory
06:40:13 <ndm> georgw: i have (|+) :: [a] -> (Int,a) -> [a] defined, which replaces the index with a particular value
06:40:51 <georgw> ndm: Is that a custom definition?
06:41:01 <DukeDave> So I have a function f :: IO a, I'd like to repeat it to produce a list IO [a] stopping on some condition IO Bool, thoughts?
06:41:02 <ndm> georgw: yes
06:41:45 <georgw> thx.
06:42:17 <ndm> i could give you the definition, but its fairly trivial, and mine has rather undefined behaviour if the index is out of range - as in i have no idea what it does
06:42:27 <quicksilver> DukeDave: informally you will see people describe that as "untilM"
06:42:37 <quicksilver> DukeDave: however it's not in the standard library
06:42:49 <quicksilver> DukeDave: and there are a couple of slight variations in how you might set it up.
06:43:45 <DukeDave> Perfect!
06:43:52 <ski> (!!<-) :: [a] -> Int -> (a -> a) -> [a]  -- another variant
06:44:02 <DukeDave> I have found a version by Cale: http://hpaste.org/5213
06:44:03 <yitz> ndm: I don't have a scorecard :) It happens sometimes, and I take that seriously when it does.
06:44:12 <quicksilver> DukeDave: ;)
06:44:22 <DukeDave> Seems like pattern that would be in the standard library
06:44:44 * quicksilver takes it very seriously when ndm disagrees with him.
06:45:01 <quicksilver> after all, that would mean ndm was wrong, and we wouldn't want that :P
06:45:17 * ndm reminds people that sometimes ndm posts to the list while drunk, and other time's he's just plain wrong
06:45:39 <ndm> (for example by using an ' in times)
06:45:41 <DukeDave> Also quicksilver, as per my "read a big file to a Data.Map" question, I'm going to use untilM to produce [(k,v)] and then load it in to the Map with a function [(k,v)] -> Data.Map k v
06:46:12 <DukeDave> Laziness will remove the intermediate list won't it? :S
06:46:22 * yitz triees to jhit the rhight keyds omn thhr kyboatrf
06:47:05 <ndm> DukeDave: be careful with sometime like untilM - things like mapM can leak stack references, and be O(n) space
06:47:21 <ndm> untilM may have the same problem, depending on the implementation
06:47:28 <DukeDave> Worrying
06:48:03 <quicksilver> DukeDave: no.
06:48:14 <quicksilver> DukeDave: intermediate lists cannot be removed when they intermediate via IO.
06:48:25 <ndm> by remove i assumed he meant "be consumed and produced lazily"
06:48:26 <DukeDave> Crap,
06:48:36 <ndm> not actually being removed as in never existing
06:48:38 <DukeDave> ndm: Yeah that's what I mean
06:48:59 <ndm> quicksilver: and they can be removed using Supero :)
06:49:07 <quicksilver> ndm: yes, but I'm talking about GHC.
06:49:09 * shepheb uses http://www.haskell.org/haskellwiki/Haskell_user_locations as a crude IRC <-> email mapping.
06:49:10 <lambdabot> Title: Haskell user locations - HaskellWiki
06:49:15 <quicksilver> this list isn't produced lazily.
06:49:23 <quicksilver> if it's produced in IO, it's produced strictly.
06:49:25 <DukeDave> So I'd expect it to do:   readLine -> parse out (k,v) -> add (k,v) to Map -> garbage collect (k,v) -> repeat
06:49:42 <quicksilver> it will, if that's what you do.
06:49:46 <malcolmw> dcoutts_: can you give me your gmail address, for SoC mentoring application please?
06:49:50 <quicksilver> but if you build a big [(k,v)] list then it won't
06:50:00 <quicksilver> it will instead build a big [(k,v)] list.
06:50:06 <quicksilver> strangely enough ;)
06:50:45 <ndm> shepheb: i can't find the actual generated picture?
06:51:32 <shepheb> ndm: yeah, that map doesn't seem to work. I just paste the lat/long into Google Maps if I want to see where someone is. but many of the lines IRC and real name or email.
06:53:51 <shapr> ndm: Um, do you remember who I am?
06:54:06 <ndm> shapr: how could i forget you :)
06:54:16 <shapr> Ok, just wondering :-)
06:55:28 <quicksilver> DukeDave: IMO, you could either use lazy IO (which is indecent)
06:55:38 <quicksilver> DukeDave: or, you should generate the map as you go along.
06:56:04 <ndm> or some unsafeInterleaveIO should do the trick
06:56:42 <DukeDave> At the moment I'm using ByteString.hGetLine
06:57:14 <quicksilver> unsafeInterleaveIO would be the first of my two options :)
06:58:47 <yitz> I hide my use of unsafeInterleaveIO by using readFile. No one will ever suspect...
07:02:16 <hallongrottan> cannot construct the infinite type, what does that mean?
07:03:12 <yitz> hallongrottan: you probably did not supply the right number of arguments to a function.
07:03:17 <hallongrottan> hmm
07:04:02 <ndm> hallongrottan: or are returning something too listy
07:04:16 <ndm> hallongrottan: if you hpaste the code i'm sure someone will figure it out
07:04:23 <hallongrottan> lol
07:05:44 <hallongrottan> well we have monad which in one of it's type constructors takes another monad as argument, which seems to be a problem
07:05:59 <quicksilver> could be a bracketing error.
07:06:07 <quicksilver> FooT bar (BarT baz) IO a
07:07:39 <hallongrottan> hmm indeed odd
07:08:19 <root> Hey all. I'm working through YAHT, but i'm having trouble with one of the exercises. I'm supposed to define a my_map function. I have: my_map _ [] = []; my_map f (x:xs) = (f x) + (my_map f xs), but the compiler complains that it couldn't match [a] against Char when i try to use my_map Char.toUpper "Hello world"
07:08:34 <yitz> :t \f -> f f
07:08:35 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
07:08:35 <lambdabot>     Probable cause: `f' is applied to too many arguments
07:08:35 <lambdabot>     In the expression: f f
07:08:44 <yitz> :t \x -> x : x
07:08:45 <faxathisia> root: It's just that you use + instead of :
07:08:45 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
07:08:45 <lambdabot>       Expected type: [a]
07:08:45 <lambdabot>       Inferred type: a
07:09:04 <ndm> edwinb: you should really add your blog to planet.haskell.org!
07:09:14 <quicksilver> root: I don't think you really want a (+) there.
07:09:23 <root> faxthisia: Ahh, thanks. I'm too used to ruby using + for list concatenation(sp?).
07:09:43 <hallongrottan> root: haskell uses ++ to concatenate lists
07:09:52 <yitz> root: + in Haskell is only for number thingies
07:10:06 <faxathisia> : conses
07:10:11 <faxathisia> ++ is not what you want here
07:10:27 <faxathisia> unless you are writing concatMap
07:10:47 <faxathisia> (which you aren't)
07:11:30 <edwinb> ndm: I suppose I could, but I only post once every 10 months or so ;)
07:11:39 <root> I'm jus re-writing the map function. Thanks a bunch for the help, it works now with : in place of + :) What makes the ++ operator different from the : operator then? out of interest
07:11:49 <faxathisia> > 5 : [6,7,8]
07:11:50 <lambdabot>  [5,6,7,8]
07:11:51 <edwinb> I was alarmed to find that if you post stuff on a blog, people will read it. Isn't the internet fun...
07:11:54 <faxathisia> > [5] ++ [6,7,8]
07:11:55 <lambdabot>  [5,6,7,8]
07:12:08 <ndm> edwinb: thats perfect - a small number of quality interesting posts, rather than a deluge of crap :)
07:12:13 <faxathisia> (:) :: a -> [a] -> [a]
07:12:21 <faxathisia> (++) :: [a] -> [a] -> [a]
07:12:39 <root> Ahh, ok. So : adds something to a list, and ++ joins lists. Thanks
07:12:46 <ndm> edwinb: i think your idea of a simple practical dependently typed language is brilliant! if it is as simple as a cabal package i would definately give it a go
07:12:52 <edwinb> ndm: I quite enjoy deluges of crap too ;)
07:13:03 <edwinb> I will make it easy to compile soon
07:13:16 <edwinb> it's a bit tortuous at the minute
07:13:18 <ndm> yeah, i realise that is an afterthought
07:13:23 <faxathisia> Where is simple practical dependently typed language?
07:13:32 <hallongrottan> SPDTL!
07:13:33 <ndm> but downloading epigram, and having to try and learn Emacs at the same time, i gave up completely
07:13:57 <edwinb> really I just wanted IO and all that fun stuff...
07:14:01 <georgw> How can I create a function that takes an array?
07:14:19 <pejo> edwinb, there are plenty of grad students in the world procrastinating. :-)
07:14:23 <georgw> localModify :: Array -> [Int] -> [Bool]; localModify a [] = elems a
07:14:29 <georgw> This does not seem to work.
07:14:30 <faxathisia> @where edwinb
07:14:30 <lambdabot> I know nothing about edwinb.
07:14:37 <edwinb> pejo: you don't have to be a grad student to procrastinate ;)
07:14:51 <edwinb> faxathisia: http://www.dcs.st-and.ac.uk/~eb/Idris/
07:14:54 <lambdabot> Title: Idris
07:15:07 <edwinb> Extremely flaky, research quality, hard to compile. There will be no refunds.
07:15:13 <faxathisia> ooh I've seen Ivor and this stuff
07:15:16 <faxathisia> thank you
07:15:23 <edwinb> But I thought it'd be an entertaining side project ;)
07:15:29 <ndm> edwinb: anyway, add your blog to planet haskell :) - that way i can unsubscribe to your feeds
07:16:44 <pejo> edwinb, what is it a side project to?
07:17:34 <edwinb> the stuff I'm supposed to be doing... which is resource aware programming, dependent types for resource usage correctness, that sort of thing
07:17:48 <edwinb> but i might try actually using it and see how it goes...
07:18:21 <quicksilver> georgw: Indeed. "Array" is not a valid type.
07:18:52 <georgw> quicksilver: How can I pass arrays to functions then?
07:18:59 <quicksilver> georgw: Array types generally look like "Array i e" where 'i' is the index type and 'e' is the element type.
07:19:07 <georgw> oic.
07:19:13 <quicksilver> Array Int Bool
07:19:18 <georgw> Ahhh.
07:19:21 <quicksilver> for example (an array of Bools indexed by integers)
07:20:13 <georgw> Excellent, thanks. :-)
07:20:25 <ToRA> q: what would people call \(_,_,c) -> c ... thd, thr, trd ..?
07:20:41 <ndm> ToRA: thd3
07:20:48 <ndm> ToRA: than you can have fst3 and snd3 as well
07:20:55 <ToRA> ndm: ah cunning
07:21:15 <ndm> ToRA: i'd love those to be in Data.Tuple
07:21:29 <ziman> is there any way to implement arrays in haskell itself?
07:21:48 <ndm> ziman: Data.IntMap - but it is no longer O(1) lookup
07:22:02 <ndm> (well, technically it is)
07:22:13 <ndm> in my experience, Data.IntMap outperforms arrays for lots of tasks
07:22:16 <edwinb> ndm: planet contact has been duly notified ;)
07:22:22 <ndm> edwinb: good good :)
07:22:47 <ziman> i mean, with O(1) lookup and without interfacing to C or something
07:23:00 <ziman> is Data.Array implemented natively, then?
07:23:15 <ndm> ziman: not possible, so yes, Data.Array is native
07:23:18 <faxathisia> ToRA: frst scnd thrd
07:23:25 <ziman> ndm, thank you
07:23:47 <quicksilver> you need an underlying primitive to give you contiguous chunks of memory with O(1) indexing.
07:24:00 <ToRA> faxathisia: heh, not a fan of vowels?
07:24:05 <quicksilver> GHC has something called ByteArray#
07:24:09 <faxathisia> hehe
07:24:12 <quicksilver> on which you could choose to implement an array.
07:24:47 <quicksilver> however, O(1) indexing is a fiction really, as people round here often observe :)
07:29:05 <shapr> What's the best Haskell wiki?
07:31:27 * Lemmih votes for haskell.org
07:32:33 <quicksilver> I assume shapr means wiki-implemented-in-haskell
07:35:47 <shapr> I was hoping for that, yes :-)
07:36:39 <quicksilver> I'm not aware of any.
07:36:46 <shapr> I just realized I'm no longer doing anything commercial with scannedinavian.com ... I can run postmaster on it now!
07:37:04 <shapr> I know of Flippi, and HAppSwiki
07:37:10 <shapr> I'm pretty sure there were some others.
07:37:42 <quicksilver> postmaster?
07:40:22 <shepheb> a
07:40:44 <root> Hmm. How would i convert from a getLine IO String to a Num? or once something has become "tainted" by IO is it impossible to remove this "taint"?
07:41:17 <quicksilver> in a sense, it is impossible to remove this taint.
07:41:24 <quicksilver> but fortunately this doesn't matter.
07:45:08 <root> how so? I'm trying to let the user input some numbers, then add them up by folr'ing the list. However,the compiler complains that it can't match [a] to type IO [String]. I've "read" the IO String, which i thought would remove the IO taint from it, but evidently not
07:47:12 <ToRA> main = do { nums <- readLn ; let res = sum nums ; print res }
07:47:12 <cin> root: well, you are in the IO monad, a sequence of actions. each action must return `IO a'
07:47:20 <quicksilver> do { nums <- ionums; let readnums = map read nums; return (foldr (+) 0 readnums) }
07:47:24 <cin> root: you bind the 'a' part to a variable with nice do notation or bind >>=
07:47:25 <quicksilver> for example.
07:49:15 <root> ToRA / quicksilver: That's certainly more concise than what i've got, but i'm attempting to follow the format so far in YAHT. I'll paste what i have so far. cin: So as long as i'm inside a do block, i can only return (IO a)?
07:49:30 <cin> root: yes
07:50:51 <root> http://pastebin.com/m3e860019 is what i have at the moment. I should map the list to a read version of the list only after i have it outside the IO block?
07:51:11 <cin> root: do notation is syntactic sugar for working with monads. note IO is just one kind of monad
07:51:15 <quicksilver> root: the error is "let numlist = doEntry"
07:51:23 <quicksilver> root: doEntry is a monadic action
07:51:26 <quicksilver> you wanted to say
07:51:28 <quicksilver> numlist <- doEntry
07:52:23 <quicksilver> root: if you like, you can think that "<-" unwraps one level of IO
07:53:53 <root> Right. So the = operator says these things are actually equal. the <- operator says "run the action and assign it's return value to this thing"?
07:53:58 <quicksilver> exactly.
07:54:23 <quicksilver> in "numList <- doEntry", doEntry has the type IO [Int] and numList has the type [Int]
07:54:34 <quicksilver> in the "=" version, then they are both IO [Int].
07:55:23 <root> quicksilver: Aha, thanks. This makes more sense now :)
08:14:39 <shapr> quicksilver: http://postmaster.cryp.to/
08:14:41 <lambdabot> Title: Postmaster ESMTP Server
08:15:28 <gwern> quicksilver: the postmaster packages are also on hackage
08:15:43 <quicksilver> shapr: that would appear to be GPL. Why would you be unable to use it on a machine which also has commercial use?
08:16:26 <shapr> quicksilver: Because if it broke horribly, I might not be able to pay my bills.
08:16:31 <quicksilver> oh, I see.
08:16:33 <quicksilver> understood.
08:16:34 <quicksilver> :)
08:16:46 <quicksilver> I thought you were alluding to some horrific licence restriction.
08:16:48 <shapr> Previously that same box was also the main email server for some other people who were paying their bills that way.
08:17:11 <shapr> Nah, just that I want to balance being a Haskell fanboy with eating on a regular basis.
08:17:42 <shapr> Speaking of fanboys, I met one of the Arduino developers on Saturday evening, yay!
08:42:01 <hpaste>  Tobsan pasted "Monad nonworking" at http://hpaste.org/6255
08:42:25 <hpaste>  Tobsan pasted "Monad working" at http://hpaste.org/6256
08:43:02 <hallongrottan> anyone who can see the difference between these two?
08:43:10 <hallongrottan> we have been checking for like an hour now
08:43:18 <hallongrottan> the first one does not work, and the second one does
08:44:38 <hallongrottan> seems as the problem is in line 32 (in the working code) and 33 (in the nonworking)
08:46:43 <hallongrottan> lol
08:47:00 <hallongrottan> nvm, now we found it ahhhhhhhhhhhhhhhhhhhhhhhh
08:47:23 <byorgey> hallongrottan: what was the problem?
08:47:38 <byorgey> I couldn't see any real difference
08:47:38 <mightybyte> @hoogle liftIO
08:47:38 <lambdabot> Control.Monad.Trans.liftIO :: MonadIO m => IO a -> m a
08:47:53 <hallongrottan> byorgey: seems as it was the deriving part in the Item type
08:48:06 <byorgey> aha!
08:48:18 <hallongrottan> how can one say deriving (Show, Read) on a type when using GADTs?
08:49:05 <quicksilver> I believe you can't.
08:49:06 <EvilTerran> you can't derive on GADTs, i don't think
08:49:08 <ToRA> hallongrottan: i don't think you can if you've declared a data type that doesn't have an 'ordinary' representation
08:49:43 <byorgey> well, this one does, but I don't think the compiler can tell the difference
08:50:08 <hallongrottan> ToRA: oh well, then we just have to use the normal representation then
08:50:29 <ToRA> @paste
08:50:30 <lambdabot> Haskell pastebin: http://hpaste.org/new
08:50:32 <quicksilver> or just write out hte instances.
08:50:39 <quicksilver> mind you, writing out Read instances is tiresome.
08:50:53 <skorpan> how could i possibly get "non-exaustive.." in a case which has _ -> ?
08:50:54 <hpaste>  ToRA pasted "show for a ('ordinary') gadt" at http://hpaste.org/6257
08:51:34 <ToRA> hallongrottan: that quite happily works...but the moment you specialise the type, use an existential or anything non h-98 you can't do it
08:52:59 <ToRA> skorpan: you can't..?
08:54:31 <byorgey> skorpan: paste your code, perhaps?
08:54:37 <skorpan> that was my bad
08:54:45 <skorpan> it wasn't the case, it was the function pattern matching
08:54:47 <skorpan> fixed it
08:55:27 <byorgey> skorpan: =D
08:56:04 <skorpan> silly things happen :/
09:00:51 <roconnor> > sin (x)
09:00:52 <lambdabot>  sin x
09:02:26 <phyrephox> hello, i'm trying to install the HGL package from hackage on windows and i get this error: "Could not find module `Graphics.Win32': it is a member of package Win32-2.1.1.0, which is hidden"
09:02:46 <phyrephox> any idea what that means? i think i have Graphics.Win32, because i can go into ghci and :m +Graphics.Win32 no problem
09:05:35 <byorgey> phyrephox: it might mean that the .cabal file for HGL doesn't list Win32 as a dependency
09:05:59 <byorgey> phyrephox: you can try editing the .cabal file to add Win32 to the build-depends: field
09:06:59 <phyrephox> sweet, that worked; thanks!
09:08:37 <byorgey> phyrephox: great! you're welcome =)
09:09:17 <byorgey> aftershocks of the Great Base Package Split of '08...?
09:11:37 <phyrephox> i do not know of such exciting things :O
09:11:47 <quicksilver> dcoutts: I have a theoretical question about my understanding of cabal.
09:11:58 <dcoutts_> quicksilver: yes?
09:12:24 <quicksilver> dcoutts_: suppose someone wrote a package called 'ImageLoader' which provided functions to load all kinds of image as Ptr a.
09:12:49 <quicksilver> dcoutts_: and they then provided a class IsImage i where load :: Ptr a -> i
09:13:07 <quicksilver> dcoutts_: and they wanted to provide instances for various common image-using libraries, like gtk, wx, gl, etc etc
09:13:09 <shteou> Hi malcolmw, are you available?
09:13:37 <quicksilver> dcoutts_: how could they do this without becoming dependent on all those packages?
09:13:55 <malcolmw> shteou: yes
09:14:07 <dcoutts_> quicksilver: that's tricky, the question is what package to put the instances into
09:14:20 <dcoutts_> quicksilver: this is very similar to the DB backend problem
09:14:43 <quicksilver> dcoutts_: yes, it is.
09:14:50 <dcoutts_> quicksilver: eg HDBC has backends for a few DB systems and you're likely to only have one or two installed
09:15:01 <quicksilver> dcoutts_: simplest answer is to multiply the packages?
09:15:05 <quicksilver> I guess that makes sense
09:15:14 <quicksilver> imageloader-gtk, imageloader-wx, imageloader-gl
09:15:22 <shteou> Hey, I was just looking at YHC's binary operations, ADD_W etc.  Do you know if it is possible to reuse one of the operand nodes allocated on the heap to return the result?
09:15:24 <quicksilver> (each being very small packages just containing 'adapters')
09:15:32 <dcoutts_> quicksilver: right
09:15:37 <sclv> what about flags?
09:15:55 <dcoutts_> quicksilver: or tauksen includes all backends in one package them all in and has horrible hacks to not build the unneeded ones
09:15:59 <sebell> Any Parsec gurus around? I've defined a parser Genparser Word8 st a, but I'm having troubles building up some of the parser primitives due to the limited exports from Parsec. What's the parser to unconditionally obtain the next available token?
09:16:18 <quicksilver> peek, IIRC?
09:16:21 <quicksilver> @hoogle peek
09:16:21 <lambdabot> Foreign.Storable.peek :: Storable a => Ptr a -> IO a
09:16:21 <lambdabot> Foreign.Storable.peekElemOff :: Storable a => Ptr a -> Int -> IO a
09:16:21 <lambdabot> Foreign.Storable.peekByteOff :: Storable a => Ptr b -> Int -> IO a
09:16:23 <shteou> malcolmw: I attempted it (resulted in an ~40% smaller binary operation) and it seems to work, but I'm not certain it is allowed on the G-Machine.
09:16:24 <quicksilver> hrm
09:16:32 <ohub> sebell; anyToken?
09:16:43 <sclv> quicksilver: I think you can do it all with cabal configurations.
09:16:47 <dcoutts_> quicksilver, sclv: yes, you could also flags to adjust how the package it built
09:17:26 <quicksilver> and those flags can 'observe' which other packages are currently installed?
09:17:26 <malcolmw> shteou: hmm, I'm not sure
09:17:36 <dcoutts_> quicksilver: yep, something like...
09:17:39 * quicksilver nods
09:17:46 <quicksilver> but then, if the user installs a new backend afterwards
09:17:48 <quicksilver> it's too late
09:17:53 <dcoutts_> quicksilver: yep
09:17:54 <quicksilver> cos the decisions were made at build-time.
09:17:59 <sclv> right-- they need to reinsall takusen or whatevs
09:18:02 * quicksilver nods
09:18:25 <dcoutts_> quicksilver: flag wx; library { if flag(wx) { build-depends: wx; cpp-options: -DUSE_WX } }
09:18:38 <malcolmw> shteou: the operands in the heap are possibly shared with other applications, so I would guess that overwriting them is bad
09:18:59 <quicksilver> dcoutts_: *nod*
09:19:28 <dcoutts_> quicksilver: the flag can be forced on or off but the default is to search for a value of the flag that works on the machine
09:19:43 <quicksilver> oh, interesting.
09:19:53 <dcoutts_> quicksilver: and it looks for a solution with the flag being true first, and that can be adjusted to try for a False solution first
09:20:08 <malcolmw> shteou: you could test whether your version gives the right answer for something like (let x = y+1 in (x+x)+x)
09:20:17 <dcoutts_> quicksilver: but the user can always force the value of any flag
09:21:01 <shteou> malcolmw: Okay, I will give it a go shortly.  I'd best tie up this JIT compiler first though! Thanks
09:21:37 * osfameron eeeks at Russell's proof that 1+1=2
09:21:40 <dcoutts_> quicksilver: the flag solution probably makes most sense unless you need to have users install other backends later, for a DB that it more likely the case
09:21:53 <dcoutts_> it/is
09:21:59 <faxathisia> what proof?
09:22:37 <quicksilver> dcoutts_: thanks, that's cleared up the basic issues. flags which are automatically searched for errors is an interesting approach.
09:23:00 <dcoutts_> quicksilver: yes it is an interesting point in the design space, and potentially tricky :-)
09:23:09 <dcoutts_> quicksilver: we currently use naive backtracking search
09:23:20 <quicksilver> did you consider using a GA to explore very large search spaces with chrosomal combination? :)
09:23:36 <dcoutts_> quicksilver: no but we might consider a SAT solver :-)
09:24:15 <dcoutts_> even without that search feature we know that package installation is an NP-complete problem
09:24:52 <dcoutts_> fortunately we normally only get easy instances of it
09:25:15 <dcoutts_> but it makes it pretty important to use an algorithm that is not guaranteed to always find a solution if one exists
09:26:31 <faxathisia> osfameron: is it online?
09:27:49 <quicksilver> hmm. remind me, where is Bertrand Russell's blog?
09:28:02 <quicksilver> didn't Wittgenstein make a couple of memorable comments there?
09:28:21 <cin> quicksilver: i have some recordings of him if you want them. excellent olden days accent
09:29:29 <mrd> quicksilver: his proof that 1+1=1 is easier
09:31:58 <osfameron> I like the 1+1=1 proof
09:32:05 <osfameron> didn't know it as Russell's though
09:32:27 <osfameron> faxathisia: I think parts of principia mathematica are online, from a quick google.  I've not read it
09:32:30 <faxathisia> the one where you divide by zero? not really a proof
09:32:48 <faxathisia> oh right, thanks
09:32:49 <astrolabe> Hardy gave a proof too
09:33:01 <quicksilver> it's an example of how sloppy reasoning can lead to fallacies rather than a proof, surely.
09:33:07 <faxathisia> yes
09:33:07 <astrolabe> Yes
09:33:34 <astrolabe> Actually wrong assumptions
09:36:02 <hpaste>  DukeDave pasted "Reading file to Data.Map" at http://hpaste.org/6259
09:37:01 <DukeDave> So that approach, sane or madness?
09:37:30 <cin> unless you're going to write to it... why a Map and not Array?
09:38:07 <faxathisia> I may write (left, right) where (left:right:_) = .. but it's just a minor syntax thing..
09:38:16 <faxathisia> (Instead of (list!!0, list!!1))
09:38:34 <NixNax> a newb question: I'm using IORef for tons of mutable particles. When I move and display all the particles, everything works fine. But when I move all the particles but only display a few of them, I run out of memory in seconds. I'm guessing this has something to do with lazyness.. When the particles aren't drawn, their position expressions are never evaluated and grow larger and larger. But I'm not sure about that, and I don't know what is a g
09:38:34 <NixNax> way to fix the problem (except: draw everything every frame). Test code here: http://hpaste.org/6258 . Search for XXX for the critical code position.
09:40:40 <ToRA> DukeDave: what's wrong with Map.fromList ?
09:42:08 <Botje> NixNax: I think the problem is with $=
09:42:12 <Lemmih> NixNax: Try $=! instead of $=.
09:42:13 <Botje> @src $=
09:42:14 <lambdabot> Source not found. You speak an infinite deal of nothing
09:42:22 <taruti> NixNax: could you make "pos particle $= p + v" stricter? (i.e. if it is performing writeIORef (pos particle) (p+v), use writeIORef (pos particle) $! (p+v)
09:42:29 <Deewiant> @src ($=)
09:42:29 <lambdabot> Source not found. My pet ferret can type better than you!
09:42:51 <NixNax> Ok, thanks. I'll try your suggestions and let you know
09:44:01 <DukeDave> ToRA: I didn't know it existed :)
09:44:27 <DukeDave> My only concern is it's non strict ?
09:47:10 <ToRA> http://www.haskell.org/ghc/docs/latest/html/libraries/containers/src/Data-Map.html#fromList
09:47:12 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/2zyyhg
09:47:18 <ToRA> i think it's strict...
09:47:40 <NixNax> Yes, both $=! and writeIORef (pos particle) $! (p+v) worked. Thanks again
09:50:08 <phyrephox> so i'm trying to install the GD package, and i'm having trouble installing the C portion of it
09:50:19 <phyrephox> i guess the C compiler doesn't know where the GD lib is on my system
09:50:34 <phyrephox> how can i provide an include path?
09:51:04 <phyrephox> i'm using cabal; i'm thinking i need to use "--prog-options", but i'm not sure what to put for prog -- i tried --gcc-options and --cc-options, to no avail
09:53:41 <dcoutts_> phyrephox: currently there is no way via the cabal command line, we've got an open ticket for that issue
09:53:57 <dcoutts_> in the mean time, the workaround is to use cc-options: in the .cabal file
09:56:08 <phyrephox> dcoutts, ok, i'll try that; thanks!
09:58:13 <NixNax> Is it possible to add strictness to IORef itself? So that whatever gets stored in the IORef is always immediately evaluated. I tried "data Test = Test (IORef !Double)" and got "unexpected strictness annotation". This compiled: "data Test = Test !(IORef Double)" but the value wasn't strict, unsurprisingly. This is not a real problem but I'm just curious
09:58:36 <quicksilver> NixNax: no, you'd need to change the definition of IORef itsef
09:58:41 <quicksilver> NixNax: which you don't have access to.
09:58:46 <NixNax> quicksilver: ok, thanks
09:59:07 <NixNax> quicksilver: are there other IORef-like containers that would work like that?
09:59:28 <quicksilver> UArrays are the only strict ref-like contains that I can think of
09:59:33 <quicksilver> they have to be strict, to be unboxed.
10:00:02 <NixNax> ok, I'll have a look. Although they're probably meant for some more special purpose
10:01:13 <quicksilver> yes, they are
10:01:31 <quicksilver> the idea of a strict IORef is quite an interesting one.
10:01:46 <quicksilver> but you could write one yourself just by wrapping 'write', of course.
10:14:27 <Baughn> Would it be sane to have cabal-install install (and upgrade) ghc itself?
10:15:10 <dcoutts_> Baughn: not yet, ghc is too complex to build completely using cabal
10:15:24 <gwern> @quote SPJ
10:15:24 <lambdabot> twifkak says: [on dons] i wonder if he and SPJ have a bet going for "most newbs recruited in '07"
10:15:27 <Baughn> dcoutts_: I didn't necessarily mean have it build ghc
10:15:33 <gwern> dcoutts_: when can we has hackaged GHC?
10:15:39 <dcoutts_> heh heh
10:15:58 <Baughn> dcoutts_: Just.. being able to hand someone cabal-install, and have it download and install ghc if you're missing one or it's too old
10:16:03 <dcoutts_> Baughn: I'm not sure what you mean then, that's what cabal does
10:16:12 <gwern> @quote SPJ
10:16:12 <lambdabot> davidhasselh0f says: [on SPJ's "A Taste of Haskell" tutorial:] It's better than sex.
10:16:16 <gwern> @quote simon
10:16:16 <lambdabot> syntaxfree says: Many people think the core ideas behind Haskell came from academic luminaries such as Philip Wadler and Simon Peyton-Jones. What actually happened is that during a functional
10:16:16 <lambdabot> programming conference, some key academics were teleported to the Deep Complex Universe. In the Deep Complex Universe some Gnomes were having Tangling problems. Wadler & friends solved their
10:16:16 <lambdabot> problems and as a reward the Tangled Gnomes gave them the S
10:16:32 <faxathisia> @quote lazy
10:16:32 <lambdabot> malig says: quantum mechanics actually strikes me as less wierd than lazy evaluation sometimes. at least it disallows time travel
10:16:37 <gwern> > 1 + 1 -- you alive, lambdabot?
10:16:38 <lambdabot>  2
10:16:42 <faxathisia> @quote lazy
10:16:42 <lambdabot> vegai says: Hey Haskell! Give me that File! -Naah, I'm too lazy. *thinks* I'll give you a cookie if you tell me how many letters that file has! -Oh, ok!
10:16:49 <Baughn> dcoutts_: I'm suggesting that cabal-install could (via a special case) download the *binary* ghc and install that
10:17:00 <dcoutts_> Baughn: we have no plans for that
10:18:22 <Baughn> dcoutts_: I didn't expect you to. But if I wrote a patch, is there any chance it would be accepted?
10:18:42 <dcoutts_> Baughn: that seems rather hard
10:18:58 <dcoutts_> to find the binary based on the current os and arch and install it in the right place
10:19:02 <shapr> @quote dcoutts
10:19:02 <lambdabot> dcoutts says: monad transformers are not known for their blistering speed
10:19:17 <gwern> gave them the S - ? what?
10:19:17 <gwern> @quote simon
10:19:18 <lambdabot> ghc says: TELL SIMON: evalAbsence
10:19:18 <dcoutts_> and integrate it with cabal-install's dependency algorithm
10:19:18 <gwern> I'm out of ideas. what's a stereotypical SPJ quote?
10:19:22 <dons> ?yow
10:19:22 <lambdabot> Are we live or on tape?
10:19:29 <dons> i can't tell!!
10:19:29 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
10:19:35 <faxathisia> @quote lazy
10:19:36 <lambdabot> vegai says: Hey Haskell! Give me that File! -Naah, I'm too lazy. *thinks* I'll give you a cookie if you tell me how many letters that file has! -Oh, ok!
10:19:39 <DukeDave> Erm, how am I supposed to use -p on my binary if it also takes command line params? :S
10:19:40 <lament> @quote spj
10:19:40 <lambdabot> spj says: it looks like hopscotch! (referring to a funny notation for lists)
10:19:43 <faxathisia> @quote lazy
10:19:44 <lambdabot> yitz says: if your function is lazy you'll be fine.
10:19:48 <Baughn> dcoutts_: Haskell is supposed to be the language for hard stuff, right? ;)
10:19:49 <shapr> hi dons!
10:19:51 <quicksilver> dons: this episode first went out yesterday at 6pm eastern
10:20:01 <quicksilver> dons: your part is quite disappointing, I'm afraid.
10:20:08 <Baughn> dcoutts_: I'll take that as a "maybe", and try it.
10:20:10 <shapr> episode?
10:20:13 <shteou> Hmm, is mtl a standard GHC package?
10:20:18 <shapr> shteou: I think so.
10:20:27 <shapr> monad transformer library
10:20:29 <glguy> shteou: "standard ghc package?"
10:20:37 <quicksilver> depends what you mean by "standard"
10:20:41 <glguy> if you're starting a new project you'll want to at least consider monadLib
10:20:42 <quicksilver> it comes with the big binary bundles, yes
10:20:47 <dcoutts_> Baughn: I can certainly find you an easier and more immediately useful ticket if you want to hack on cabal
10:21:11 <dons> glguy: monadLib pimp eh?
10:21:19 <shteou> Righto quicksilver :)
10:21:32 <Baughn> dcoutts_: I wouldn't be as motivated, but if you can find something addressing the same general problem ("Making haskell easy to use"), that could work
10:21:46 <shteou> Thank Frank for apt-get.
10:21:50 <dcoutts_> Baughn: sure, there are plenty :-)
10:21:59 <gwern> hm. 'I are SPJ cat; ur bug are fized in head'?
10:22:13 <shapr> gwern: Are you making a lambdacat?
10:22:23 <dcoutts_> Baughn: we all want to make Haskell easy to use, that's what cabal and hackage are for (despite what some thing that it's to cause pain)
10:22:50 <Baughn> dcoutts_: Actually, how about "have cabal-install check the packages for cryptographic signatures"? That should be considerably simpler, and has obvious utility (mirrors, etc.)
10:22:52 <quicksilver> I thought cabal and hackage were created to raise the bar for library creation, and thus discourage poor libraries.
10:22:59 * shteou gets excited
10:23:10 <shteou> Things are compiling >:D
10:23:21 <dcoutts_> Baughn: here's the complete list of current tickets:
10:23:22 <dcoutts_> http://hackage.haskell.org/trac/hackage/report/9
10:23:27 <lambdabot> Title: {9} Active Tickets by Component - Hackage - Trac
10:23:39 <dcoutts_> Baughn: there is one on security and crypto
10:23:48 <Baughn> ..it doesn't load
10:24:14 <dcoutts_> Baughn: there are plenty of project sized ones there, and then there are a few more immediate ones for the next Cabal release:
10:24:14 <dcoutts_> http://hackage.haskell.org/trac/hackage/query?status=new&status=assigned&status=reopened&group=component&milestone=Cabal-1.4&order=priority
10:24:20 <lambdabot> Title: Custom Query - Hackage - Trac, http://tinyurl.com/25boef
10:24:31 <dcoutts_> Baughn: it should do eventually, the server is just being a tad slow
10:25:28 <dcoutts_> Baughn: the biggest project is dependency analysis, loads of other features we want are blocked on that one
10:25:40 <gwern> wait, dammit. that one is already done - http://arcanux.org/lambdacats_3.html
10:25:40 <gwern> shapr: I was :(
10:25:40 <gwern> shapr: ya get my conjure message?
10:25:42 <lambdabot> Title: Lambdacats
10:25:42 <gwern> shapr: actually, I was wondering about that uncc package on your website - what sort of output is uncc supposed to have when it runs successfully?
10:25:43 <gwern> quicksilver: no, it's supposed to make them easier to create for the maintainer, easier to dsitribute and install! make things easier on everyone except the cabal devs
10:25:53 <quicksilver> gwern: yes, it was irony :)
10:25:55 <shapr> gwern: Yeah, got your messages, haven't done anything with 'em though.
10:26:28 <\z> anyone have a moment for a 'cabal install' question?
10:27:14 <shapr> lament: I get the impression that humans integrate their tools into their definition of self, thus making them very defensive about those tools.
10:27:22 <dcoutts_> \z: yep, so long as it's about the darcs version of cabal-install, not the old version on hackage
10:27:39 <gwern> shapr: 'sok. thought you'd appreciate knowing about furhter evolutions of your code
10:27:40 <gwern> quicksilver: irony doesn't travel well over IRC
10:27:49 <\z> dcoutts_: I've got cabal-install version 0.4.3
10:27:55 <dcoutts_> \z: ok
10:28:21 <\z> I noticed that 'cabal install' was dropping stuff in my ~/.cabal directory
10:28:23 <Baughn> dcoutts_: Guest login doesn't seem to be working, and I can't find a "register" link. I'll have a look at #214, though; I happen to have some free time the next two weeks.
10:28:39 <\z> then I found the ~/.cabal/config file, and set 'user-install: false'
10:28:48 <gwern> bah. I can't think of any SPJ lolcats besides the done one
10:28:50 <quicksilver> gwern: that makes it all the more fun :)
10:28:51 <dcoutts_> Baughn: check the password it's got a ' at the end
10:29:07 <gwern> I hate when you think of an existing thing which you saw previously, but worse >.<
10:29:09 <\z> when I run cabal configure, I always set --prefix=/opt/local, but that preference isn't remembered when it's time to do a cabal install
10:29:11 <dcoutts_> \z: ok, and now you're having problems doing global installs
10:29:35 <dcoutts_> \z: the install is actually a configure+build+install all in one go
10:29:36 <\z> no.  I want to do global installs.  :-)
10:29:47 <\z> Ah.  That wasn't clear...
10:29:54 <dcoutts_> \z: so do cabal install --prefix=/opt/local
10:30:04 <dcoutts_> \z: however you'll have to do that as root
10:30:05 <\z> what I want to do is specify a default prefix in the ~/.cabal/config file, if that's possible.
10:30:25 <\z> and, failing that, see where the ~/.cabal/config file is read in so I can muck around a little
10:30:27 <Baughn> dcoutts_: Is it normal that people operate this as "guest"? -_-
10:30:35 <dcoutts_> \z: you can, you can specify the defaults for user installs and global installs separately
10:30:38 <\z> dcoutts_: yeah, sudo cabal install isn't an issue
10:30:45 <\z> ooh, neat.
10:31:08 <gwern> quicksilver: the problem is, all I know SPJ for is his xmonad OSCON demo, and closing GHC bugs. how can I work that into a paordy of the  'I are serious cat; this is serious thread' lolcat? I just can't
10:31:30 <dcoutts_> Baughn: yep, when we allowed registration the spammers knew how to register and we got loads of comment spam
10:31:45 <quicksilver> gwern: read his "hair shirt" talk.
10:31:49 <dcoutts_> Baughn: just add yourself in the 'cc' list
10:31:53 <quicksilver> gwern: that gives you some idea of the way he talks.
10:32:04 <\z> dcoutts_: is there a way to do 'just' install once all the prep work is done?
10:32:06 <quicksilver> @go wearing the hair shirt a haskell retrospective
10:32:07 <lambdabot> http://research.microsoft.com/~simonpj/papers/haskell-retrospective/index.htm
10:32:07 <lambdabot> Title: Wearing the hair shirt: a retrospective on Haskell
10:32:16 <dcoutts_> \z: not at the moment
10:32:38 <gwern> quicksilver: well, that opens a possibilityt of a cat srteching upwards and apparently to gesturing to its chest 'u likez my hair shirt?'
10:32:51 * gwern has no such picture though
10:33:00 <dcoutts_> \z: what do you need to do that you cannot do with install?
10:33:11 <dcoutts_> \z: or you want to build as user and install as root?
10:33:33 <\z> dcoutts_: what I would like to do is store a preference for --prefix=/opt/local
10:33:38 <gwern> or 'hair shirt, I haz it' or something
10:33:55 <dcoutts_> \z: that's fine, just use, global-prefix: whatever
10:34:07 <gwern> 'hair shirt, I wears it'?
10:34:10 <\z> Ah.  And where can I find that in the sources?
10:34:19 <roconnor> @seen Igloo
10:34:19 <lambdabot> Igloo is in #haskell-soc, #haskell, #ghc and #darcs. I last heard Igloo speak 1m 2s ago.
10:34:54 <dcoutts_> \z: you don't need to edit the sources :-) though if you want to hack on new features that's great :-)
10:35:03 <\z> dcoutts_: that's what I'm asking.  :-)
10:35:16 <dcoutts_> \z: just put "global-prefix: /opt/local" in the ~/.cabal/config
10:35:23 <dcoutts_> \z: lemme fine the bit in the source for you...
10:35:29 <\z> dcoutts_: the cabal library seems to be well documented, but some of the cabal install options aren't as clear
10:35:38 <roconnor> @tell Igloo Do you have some time to apply the PartitionEithers patch now?
10:35:38 <lambdabot> Consider it noted.
10:35:45 <lament> shapr: it's refreshing to see linux fanboyism at least somewhat balanced by windows fanboyism
10:35:58 <roconnor> I assume lambdabot can send messages accross channels
10:36:09 <dcoutts_> \z: see Hackage.Config.configFieldDescrs
10:36:59 <dcoutts_> \z: map userInstallDirField installDirDescrs adds a "user-" prefix to all the install dir fields, and similarly for "global-"
10:37:13 <Igloo> roconnor: If you've summarised the discussion to the ticket, and it's ready to commit, assign the ticket to me
10:37:14 <lambdabot> Igloo: You have 1 new message. '/msg lambdabot @messages' to read it.
10:37:54 <roconnor> Igloo: does that mean I have to repatch it against HEAD?
10:37:54 <\z> dcoutts_: aha!  that would explain why I couldn't find it looking through the wrong bunch of sources.  ;-)
10:38:09 <dcoutts_> \z: :-)
10:38:32 <Igloo> roconnor: No, by "ready to commit" I just meant there was a concensus that it should be applied. I'm happy to do any merging necessary
10:38:36 <dcoutts_> \z: the config file writer code is getting an overhaul, see http://hackage.haskell.org/trac/hackage/ticket/223
10:38:39 <lambdabot> Title: #223 (allow per-package configuration options in config file) - Hackage - Trac
10:38:44 <roconnor> Igloo: oh, whew
10:38:47 <Igloo> :-)
10:42:13 <gwern> hey, does anyone have a usenet subscription here?
10:42:21 <Baughn> "subscription"?
10:42:46 <dcoutts_> \z: are you looking to hack on some particular cabal/cabal-install feature?
10:43:03 <dcoutts_> \z: our support for global installs is not great yet
10:43:20 <Baughn> gwern: Why do you ask?
10:43:20 <gwern> Baughn: yeah, my ISP doesn't offer a feed
10:43:28 <Baughn> gwern: Oh. Google does, though
10:43:31 <Zao> gwern: conjure doesn't support big files (probably 2G+) with InterfaceNaive.
10:43:36 <\z> dcoutts_: nothing major.  I was looking into why a preference in cabal configure was ignored with cabal install.
10:43:38 <Zao> gwern: Is conjure yours or have you just packaged it?
10:43:49 <gwern> (and I know of no useful free ones which allow posting)
10:43:50 <dcoutts_> \z: in cabal-install I mean, Saizan has a patch to add a --su-cmd option which should improve that
10:43:53 <\z> dcoutts_: also, it would be nice to specify that docs should always be built
10:44:12 <dcoutts_> \z: yes, nobody is working on that one at the moment: http://hackage.haskell.org/trac/hackage/ticket/206
10:44:14 <lambdabot> Title: #206 (cabal-install should be able to generate haddock docs) - Hackage - Trac
10:44:35 <Zao> gwern: Most probably, the use of Int at prepareHandle.
10:45:03 <dcoutts_> \z: the real reason install always does re-configure is that we don't have a proper dependency system yet, so we don't know that we've already done the configure and build
10:45:05 <Zao> Ah, it wasn't your library.
10:45:09 <Zao> Sorry for the noise.
10:45:12 <gwern> Baughn: I want to tell http://groups.google.com/group/rec.games.roguelike.development/browse_thread/thread/8d25f057a90d87aa/126dd8aadd8156bf?lnk=gst&q=mage+haskell#126dd8aadd8156bf about  http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mage-1.1.0
10:45:15 <lambdabot> Title: Has anyone seen this? A NetHack clone written in Haskell. - rec.games.roguelike. ..., http://tinyurl.com/2o9cqe
10:45:41 <\z> dcoutts_: what qualifies as a 'real dependency system'?  and is the macports hack unsuitable?
10:46:01 <dcoutts_> \z: more like make, where it tracks file dependencies properly
10:46:07 <Baughn> gwern: Hm. Let's see..
10:46:13 <dcoutts_> \z: ie builds a graph, checks file modification times etc
10:46:13 <gwern> Zao: it doesn't? that's too bad. is interfacenaive 32-bit or soemthing?
10:46:13 <gwern> Zao: the latter, but given that th maintainers don't seem to be maintaining it
10:46:54 <dcoutts_> \z: http://hackage.haskell.org/trac/hackage/ticket/15
10:46:58 <lambdabot> Title: #15 (implement dependency analysis) - Hackage - Trac
10:47:02 <roconnor> @spell partition
10:47:05 <dcoutts_> \z: you can see it's an old ticket by it's low number :-)
10:47:13 <\z> :-)
10:47:28 <roconnor> @spell partititon
10:47:34 <roconnor> @bot
10:47:34 <lambdabot> :)
10:47:53 <dmwit> partition
10:47:56 <gwern> Zao: what error does a >2gig torrent give?
10:47:58 <dcoutts_> \z: the one about building docs etc would be a very useful project and once the config file stuff is rewritten then it could also be stored as a permanent preference
10:48:07 <Zao> gwern: From what I can see, they hSeek with an fromIntegral'd Int.
10:48:10 <dcoutts_> \z: so if you're looking for something to do... :-)
10:48:21 <Zao> gwern: conjure: debian-40r3-amd64-DVD-1.iso: hSeek: invalid argument (Invalid argument)
10:48:31 <gwern> Zao: I'd test it, right now I don't have any >2gig torrent, my biggest is 1.5gigs
10:48:41 <\z> dcoutts_: yeah, kinda
10:49:08 <dcoutts_> \z: and it's somewhat related to http://hackage.haskell.org/trac/hackage/ticket/225
10:49:11 <lambdabot> Title: #225 (allow installing just specific bits, like just docs) - Hackage - Trac
10:49:13 <\z> I was looking into Control.Applicative and Control.Alternative to write a parser parameterized by its stream, but parsec-3.0.0.0 is out...
10:49:22 <Zao> gwern: For example - ftp://ftp.acc.umu.se/debian-cd/current/amd64/bt-dvd/debian-40r3-amd64-DVD-1.iso.torrent
10:49:27 <mrd> new parsec? hmm
10:50:18 <gwern> Zao: man, conjure is lousy with Ints
10:52:52 <Zao> That reminds me, I should cabalize my hastris.
10:52:58 <shapr> hastris?
10:53:13 <Zao> shapr: OpenGL xtris clone in Haskell.
10:53:16 <shapr> Who's running the conjure project these days?
10:53:34 <shapr> @where conjure
10:53:34 <lambdabot> http://darcs.haskell.org/~lemmih/conjure/
10:53:41 <shapr> Oh, Lemmih?
10:55:56 <gwern> shapr: he hasn't applied my patches yet
10:56:22 <dons> could we get it on code.haskell.org ?
10:56:30 <dons> helps a lot for reviving projects
10:58:25 <Lemmih> I've heard he's been busy lately.
10:58:26 <roconnor> Igloo: okay, I set you as the owner.  And for some reason the status changed to new
10:58:33 <roconnor> http://hackage.haskell.org/trac/ghc/ticket/974#comment:11
10:58:36 <lambdabot> Title: #974 (Add partitionEithers, lefts, rights to Data.Either) - GHC - Trac
10:58:37 <Igloo> roconnor: OK, thanks!
10:58:48 <gwern> @pl infoTotalBytes t = sum $ map (fromIntegral  snd) $ fileInfo t
10:58:48 <gwern> @pl infoTotalBytes t = sum $ map (fromIntegral . snd) $ fileInfo t
10:58:48 <lambdabot> (line 1, column 18):
10:58:49 <lambdabot> unexpected "="
10:58:49 <lambdabot> expecting variable, "(", operator or end of input
10:58:49 <lambdabot> infoTotalBytes = sum . map (fromIntegral . snd) . fileInfo
10:59:05 <roconnor> Igloo: I looked at the patch as text, and I think it is still good
10:59:44 <Igloo> roconnor: Yeah, and I'm sure it'll be easy to merge if not
10:59:47 <dcoutts_> Lemmih: ;-)
11:03:23 <Plouj> gosh, exercises in http://halogen.note.amherst.edu/~jdtang/scheme_in_48 are diffucult
11:03:27 <Plouj> difficult*
11:04:24 <Plouj> I can't even tell which part of parseNumber can be re-written using do-notation
11:04:46 <gwern> 'You don't have permission to access /~jdtang/scheme_in_48/ on this server.'
11:04:48 <Deewiant> 403 Forbidden
11:05:04 <gwern> Plouj: is that more or less up to date than the haskell wikibook's Scheme section?
11:05:05 <Plouj> http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/parser.html
11:05:07 <lambdabot> Title: Write Yourself a Scheme in 48 hours, http://tinyurl.com/yzphh2
11:05:19 <Plouj> gwern: I wouldn't have a clue
11:05:50 <Deewiant> @src liftM
11:05:50 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
11:06:05 <Deewiant> Plouj: maybe that's too big a hint but oh well :-)
11:06:10 <Plouj> heh, indeed
11:09:19 <Plouj> although, emacs already shows me that
11:09:22 <Plouj> sort-of
11:11:18 <dolio> @where plugins
11:11:18 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
11:11:37 <Plouj> @src many1
11:11:37 <lambdabot> Source not found. Just try something else.
11:13:15 <noteventime> Does the Haskell mode for emacs support some kind of auto-completion?
11:14:23 <dolio> dons: Is the repository at unsw still the place to get the latest hs-plugins?
11:15:08 <mrd> noteventime: the usual stuff works, M-/
11:15:20 <noteventime> Ok
11:15:40 <noteventime> But it doesn't scan the imports or anything like that?
11:15:41 <gwern> dolio: no
11:15:52 <mrd> noteventime: no
11:15:55 <gwern> dolio: you want http://code.haskell.org/~dons/code/hs-plugins
11:15:55 <lambdabot> Title: Index of /~dons/code/hs-plugins
11:15:56 <noteventime> ok, thanks :)
11:16:06 <dolio> Ah, okay.
11:16:07 <mrd> unfortunately, GHC 6.8.2 has broken the ability to browse imports
11:16:13 <mrd> i'm not sure why
11:16:22 <mrd> er, 6.8+
11:16:35 <gwern> dolio: dons is very bad about updating his webpages. I've bugged him several times about this sort of thing
11:16:37 <Igloo> mrd: Are you using :b or :browse?
11:16:42 <mrd> :
11:16:42 <mrd> :b
11:16:43 <dolio> :)
11:16:48 <Igloo> mrd: Use :browse
11:16:55 <Igloo> :b is now :break
11:17:02 <gwern> @where+ hs-plugins http://code.haskell.org/~dons/code/hs-plugins
11:17:02 <gwern> @where+ plugins http://code.haskell.org/~dons/code/hs-plugins
11:17:02 <lambdabot> Done.
11:17:02 <lambdabot> Done.
11:17:08 <mrd> arggh
11:17:10 <mrd> haha
11:18:14 <mrd> noteventime: so if you :browse an import, emacs can consider those for completions
11:18:45 <shapr> The more I spend time on ##csharp, the more I like #haskell.
11:18:54 <dcoutts_> shapr: :-)
11:18:56 <dolio> gwern: You should have him upload plugins 1.1 to hackage, too (unless it doesn't build on 6.6, or something).
11:19:38 <gwern> dolio: he was reluctant, something about it being endoflifed and unmaintained
11:19:52 <noteventime> mrd: It's not an important feature to me, I just figured I'd enable it if it was available. Thanks for the tip though
11:20:37 <Plouj> the problem I have is that the function types in the tutorial don't match those in the documentation
11:22:07 <gwern> Plouj: try the wikibook one then
11:22:22 <gwern> I know people have been using that one, and being a wiki, almost surely updating it
11:23:00 <mrd> gwern: is that plugins uptodate for 6.8?
11:23:10 <dolio> Yeah.
11:23:17 <gwern> mrd: I think so
11:23:43 <gwern> it's not on my TODO list
11:23:43 <Plouj> both say: "result of many1 digit is actually a Parser String" but the documentation says: it returns "GenParser tok st [a]" http://legacy.cs.uu.nl/daan/download/parsec/parsec.html#many1
11:23:44 <mrd> aha, i downloaded a copy yesterday but that must have been old
11:24:21 <Plouj> maybe those are somehow equivalent, but in either case I'm totally lost
11:25:02 <mrd> Parser is a simpler type synonym than GenParser
11:25:35 <Plouj> well, the tutorial doesn't mention that
11:25:41 <mrd> it's like GenParser Char ()
11:26:00 <gwern> hm. hs-plugins needs cabal updating
11:26:00 <Plouj> and even then, what does Parser tok st [a] mean?
11:26:28 <mrd> The General Parser GenParser tok st a data type represents a parser that parses tokens of type tok with a user supplied state st and returns a value of type a on success.
11:26:47 <Plouj> wow
11:26:54 <mrd> Parser is used when there is no user-supplied state
11:26:58 <Plouj> that's confusing
11:27:00 <mrd> it's the same, just with () state
11:27:16 <mrd> that's why the tutorial sticks to Parser
11:28:04 <vss> hi
11:28:20 <Plouj> right now, I hate how there is no punctuation and everything just depends on the location of identifiers
11:28:34 <Plouj> s/everything/meaning of identifiers/
11:28:37 <mrd> ?
11:28:45 <mrd> what thing?
11:28:47 <vss> is there a tool out there that would insert parenthesis into a haskell expression, so that the precedence rules become "visible"?
11:29:12 <Plouj> mrd: what you said for example
11:29:23 <mrd> Plouj: I just copied that from the documentation.
11:29:28 <dons> vss, the ghc -ddump-parse pass
11:29:31 <Plouj> mrd: I realize that
11:29:33 <mrd> minus formatting, so you might want to scroll up to that
11:29:47 <vss> dons, thx, will check that out now
11:30:07 <Plouj> each identifier in "Parser tok st [a]" means a totally different thing yet they are all delimited by whitespace
11:30:23 <mrd> yes, they are parameters to the type GenParser
11:30:27 <mrd> (not Parser)
11:30:30 <Plouj> so to understand that one has to know the meaning of the location of each identifier
11:30:42 <Plouj> they are parameters?
11:30:43 <ndm> what does the term "boxed lambda" conjour up in peoples minds?
11:30:47 <mrd> I'm not sure I can help you if you don't understand the idea of parameters
11:30:59 <Plouj> I thought that was some haskell syntax
11:31:22 <Plouj> oh boy
11:31:28 <mrd> Plouj: the type has parameters which are themselves types that you can supply
11:31:44 <Plouj> I didn't expect that
11:31:49 <resiak> ndm: i'm imagining the "hook" at the top grappling with the edge of an open-topped box a little too high for it
11:32:01 <resiak> ndm: with #haskell looking on, making adoring noises
11:32:06 <ndm> resiak: i love that image!
11:32:19 * Plouj tries to read http://www.haskell.org/tutorial/goodies.html
11:32:20 <lambdabot> Title: A Gentle Introduction to Haskell: Values and Types
11:33:02 <mrd> @hoogle many1
11:33:03 <lambdabot> Text.ParserCombinators.ReadP.many1 :: ReadP a -> ReadP [a]
11:33:03 <lambdabot> Text.ParserCombinators.Parsec.Combinator.many1 :: GenParser tok st a -> GenParser tok st [a]
11:33:03 <lambdabot> Text.ParserCombinators.ReadP.skipMany1 :: ReadP a -> ReadP ()
11:33:08 <mrd> :t many1
11:33:09 <lambdabot> Not in scope: `many1'
11:33:17 <mrd> :t Text.ParserCombinators.Parsec.Combinator.many1
11:33:18 <lambdabot> forall tok st a. Text.ParserCombinators.Parsec.Prim.GenParser tok st a -> Text.ParserCombinators.Parsec.Prim.GenParser tok st [a]
11:33:27 <mrd> :t Text.ParserCombinators.Parsec.Combinator.many1 Text.ParserCombinators.Parsec.Combinator.digit
11:33:28 <lambdabot>     Not in scope: `Text.ParserCombinators.Parsec.Combinator.digit'
11:33:28 <ndm> if i defined it to be a data value containing a lambda, would that be "intuative" ?
11:33:31 <hpaste>  DukeDave pasted "Loading file to Data.Map" at http://hpaste.org/6261
11:33:52 <DukeDave> quicksilver: Sorry to be a pain again, if you have a sec can you comment on this ^
11:33:59 <DukeDave> Also, open to anyone else!
11:34:08 <DukeDave> It's using up waaaay more memory than it should do
11:34:39 <ndm> DukeDave: i know why :)
11:34:50 <ndm> DukeDave: you have to copy the bytestrings, copy i think
11:34:52 <mrd> Plouj: type Parser a = GenParser Char () a -- Parser takes 1 parameter which it supplies as the third parameter to GenParser along with the types Char and ()
11:34:52 <ndm> @hoogle copy
11:34:52 <lambdabot> Data.ByteString.copy :: ByteString -> ByteString
11:34:52 <lambdabot> Data.ByteString.Char8.copy :: ByteString -> ByteString
11:34:52 <lambdabot> Data.ByteString.Lazy.copy :: ByteString -> ByteString
11:35:09 <DukeDave> I've profiled it with -hm on a data set 1/10th the size and it behaves sensibly :S
11:35:18 <DukeDave> ndm: I'm intrigued :o
11:35:19 <gwern> confusing. cabal is not running the configure script like it should
11:35:21 <ndm> DukeDave: bytestring reads the whole thing, and refers to a portion of it
11:35:33 <ndm> DukeDave: i think, i know it would be true for strict bytestrings
11:35:35 <gwern> DukeDave: you obviously tried strict bytestrings
11:35:45 <gwern> right?
11:35:58 <DukeDave> gwern: I'm using Data.ByteString.Lazy.Char8
11:36:02 <ndm> DukeDave: imagine (0,"neil"), drop 2 gives you (2,"neil") not "il" in ByteString land
11:36:02 <mrd> Plouj: many1 digit :: Parser String can be substituted for GenParser Char () String by ordinary parameter substitution
11:36:19 <ndm> DukeDave: you may want to make the keys strict bytestrings, should be better memory use
11:36:22 <sethk> when the compiler says "expected type" and "inferred type" differ about a function signature, which is the signature?  expected or inferred?
11:36:31 <ndm> but keep the other bits lazy bytestrings
11:36:36 <ndm> plus why not fromList?
11:36:40 <dons> expected is what you wrote.
11:36:58 <sethk> dons, thanks
11:37:02 <DukeDave> ndm: I didn't use fromList because I was trying to get strictness... Am I getting confused?
11:37:15 <ndm> DukeDave: i think fromList is strict
11:37:19 <gwern> dons: y'know why the hs-plugins cabal file isn't running the configure script on runhaskell Setup configure?
11:37:33 <ndm> DukeDave: if it isn't, i think that would be a bug, and should be reported as such
11:37:34 <dons> build-type: Configure missing?
11:37:55 <gwern> hm. maybe
11:38:02 <ndm> DukeDave: and one comment, you can unindent your entire module by one tab
11:38:28 <DukeDave> ndm: So a suggestion would be: Use copy when I extract the key and value. Use fromList
11:38:33 <gwern> oh, wait/ I feel silly - it was my edit to Setup.lh
11:38:47 <ndm> DukeDave: yes
11:38:47 <gwern> dons: anyway so someone was suggesting uploading hs-plugins to hackage
11:38:50 <DukeDave> ndm: That's hpaste making it look pretty
11:38:56 <ndm> DukeDave: ah, fair enough :)
11:39:06 <dons> gwern: yeah, its a good idea.
11:39:13 <ndm> DukeDave: if the performance goes down by using fromList, report that as a bug
11:39:41 <ndm> DukeDave: probably make that change first, benchmark again, and then hopefully the copy change will actually give you a win
11:40:06 <araujo> anyone with lambdabot access here?
11:40:27 <shapr> me?
11:40:35 <shapr> What sort of access?
11:40:41 <shapr> If you mean physical access, you should talk to dons
11:41:02 <mrd> lambdabot exists in real life?
11:41:26 <araujo> shapr, to join a new channel
11:41:28 <shapr> Sorry, that information is classified. Have you written a lambdabot plugin?
11:41:40 <araujo> hah
11:41:45 * shapr grins
11:41:54 <mrd> hmm no.  /me ponders where these things get "plugged in"
11:41:55 <araujo> @join #haskell.es
11:41:55 <lambdabot> Not enough privileges
11:41:57 <araujo> :-)
11:42:04 <shapr> @join #haskell.es
11:42:12 <shapr> @listchans
11:42:13 <lambdabot> ##logic #darcs #friendly-coders #gentoo-haskell #gentoo-uy #ghc #haskell #haskell-blah #haskell-overflow #haskell-soc #haskell.es #jtiger #parrot #perl6 #rosettacode #scala #scannedinavian #unicycling
11:42:13 <lambdabot>  #xmonad
11:42:18 <araujo> shapr++
11:42:26 <shapr> Oh, maybe lambdabot2 does the language channels?
11:42:44 <shapr> Isn't there a second lambdabot?
11:42:48 * shapr doesn't remember
11:43:00 <araujo> shapr, there is none in there
11:43:07 <araujo> there was....
11:43:09 <araujo> :-P
11:43:56 <shapr> I bet this surprises no one... but C# and Windows Forms stuff is very far away from referentially transparent.
11:44:05 <shapr> Makes my head hurt sometimes.
11:45:05 <gwern> shapr: O RLY?
11:45:05 <hpaste>  DukeDave annotated "Loading file to Data.Map" with "Using copy" at http://hpaste.org/6261#a1
11:45:10 <DukeDave> ndm: Bad news, updated version, using both fromList or loadKVs is still hitting swap :(
11:45:30 <roconnor> The key to programming is to make all computation/effects as local as possible.
11:45:35 <roconnor> which is why I like Haskell
11:45:50 <roconnor> that and a strong type system for correctness.
11:46:06 <tromp> and the clean syntax
11:46:18 <shapr> Yeah, clean syntax is nice.
11:47:03 <roconnor> referential transparency is locality is a nutshell
11:47:04 <shapr> roconnor: Wouldn't stack based languages like postfix make everything local?
11:47:24 * shepheb ponders lambdabot's purpose in #unicycling
11:47:47 <laura85> hi ^^
11:47:56 <roconnor> shapr: sounds plausable.
11:48:20 <gwern> if anyone makes the wisecrack 'think globally, program locally', I shall slay them and turn their skull into my drinking goblet
11:48:20 <roconnor> I don't know much about stack based languages.
11:48:34 <roconnor> last time I checked, push down automoton were not turing complete.
11:48:44 <roconnor> not that I'm all that big on turing completeness
11:49:24 <Baughn> Haskell, the choice of green programmers: Think globally, program locally, act lazily
11:49:52 <laura85> hm i have to implement 'map' by using foldr. why does this not work: myMap :: (a -> b) -> [a] -> [b] , myMap f l = foldr f [] l ??
11:50:00 <roconnor> @quote Baughn Haskell, the choice of green programmers: Think globally, program locally, act lazily
11:50:01 <lambdabot> No quotes match. Just try something else.
11:50:08 <roconnor> @remember Baughn Haskell, the choice of green programmers: Think globally, program locally, act lazily
11:50:08 <lambdabot> Done.
11:50:10 <mrd> > foldr f [] l :: Expr
11:50:11 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Expr'
11:50:14 <mrd> > foldr f [] l :: [Expr]
11:50:14 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Expr'
11:50:27 <roconnor> > foldr f 1 [] :: [Expr]
11:50:28 <lambdabot>   add an instance declaration for (Num [Expr])
11:50:32 <mrd> > foldr f [] [a,b,c] :: Expr
11:50:34 <lambdabot>  Couldn't match expected type `Expr' against inferred type `[a]'
11:50:36 <mrd> blah
11:50:51 <Baughn> > foldr f [] [a,b,c] :: [Expr]
11:50:51 <lambdabot>        add an instance declaration for (SimpleReflect.FromExpr [Expr])
11:50:51 <roconnor> > foldr f a [] :: [Expr]
11:50:51 <lambdabot>  Couldn't match expected type `[Expr]' against inferred type `Expr'
11:50:54 <quicksilver> DukeDave: contrary to ndm I think you definitely *don't* want to copy the bytestrings.
11:50:57 <mrd> ok, it's (f a (f b (f c [])))
11:51:28 <mrd> you probably intended (f a : (f b : (f c : [])))
11:51:32 <quicksilver> DukeDave: if you don't copy them, then all your bytestrings will refer to the big cipy of the file in-memory.
11:52:03 <gwern> Programmers of the highest class, when they hear about Haskell, take it and practice it earnestly.
11:52:03 <quicksilver> DukeDave: that's a big win, assuming that "most" of the fie is values, which I believe it is.
11:52:04 <gwern> Programmers of the middle class, when they hear of it, take it half earnestly.
11:52:08 <gwern> Programmers of the lowest class, when they hear of it, laugh at it.
11:52:08 <mrd> > foldr (:) [] [a,b,c] :: [Expr]
11:52:09 <lambdabot>  [a,b,c]
11:52:10 <gwern> Without the laughter, there would be no Haskell.
11:52:43 <mrd> now that you know how to reconstruct the list with foldr, implement map
11:53:08 <DukeDave> quicksilver: Exactly, as we discussed earlier I want to see the Map with a memory foot print of around filesize + (Map node overhead * number of nodes)
11:53:50 * DukeDave has been drawing nice graphs with hp2ps but doesn't really understand what he's looking at
11:53:57 <laura85> mrd, hm... lemme understand
11:54:00 <laura85> :)
11:54:24 <mrd> > map f [a,b,c] :: [Expr]
11:54:24 <lambdabot>  [f a,f b,f c]
11:55:08 <tromp> @list Expr
11:55:08 <lambdabot> No module "Expr" loaded
11:55:12 <gwern> good news everyone! plugins 1.1 is now on Hackage. it would be truly bodacious if someone could take a look
11:55:17 <gwern> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/plugins-1.1
11:55:25 <gwern> dons: that includes you too
11:55:26 <lambdabot> http://tinyurl.com/29r3zs
11:55:44 <DukeDave> Mmmmm plugins *drool*
11:55:57 <mrd> gwern: i'll try it out tonight. i wanted to use it yesterday, but couldn't find the updated version.
11:56:14 <tromp> where is Expr defined?
11:56:43 <mrd> in lambdabot
11:57:04 <Baughn> tromp: lambdabot - SimpleReflect.hs, it seems
11:57:16 <mrd> there's a blog post about the technique used
11:57:24 <shteou> I need to stop handcoding bytecode and do some work :/
11:57:44 <quicksilver> DukeDave: yes, so I think you definitely don't want copy.
11:58:21 <tromp> how can i see what typeclasses have Expr in it?
11:58:35 <Baughn> @instances Expr
11:58:35 <lambdabot> Couldn't find class `Expr'. Try @instances-importing
11:58:39 <ndm> @seen kosmikus
11:58:39 <lambdabot> kosmikus is in #gentoo-haskell, #haskell, #ghc and #darcs. I don't know when kosmikus last spoke.
11:58:50 <Baughn> tromp: I suppose you could grep lambdabot for it..
11:58:54 <DukeDave> quicksilver: Any inspiration looking at the code why it might be having trouble?
11:59:04 <tromp> you want the inverse of @instances
11:59:32 <ndm> kosmikus: first question, is there an lhs2tex mailing list or should i mail haskell-cafe in the cc when asking lhs2tex questions, just so they don't come up regularly and repeatedly
11:59:50 <tromp> > succ a :: Expr
11:59:51 <lambdabot>  succ a
12:00:13 <tromp> >> a+1 :: Expr
12:00:17 <tromp> > a+1 :: Expr
12:00:18 <lambdabot>  a + 1
12:00:37 <quicksilver> DukeDave: I'll try to look, although my web browser runs rather slow on the train.
12:00:59 <DukeDave> Bless, thanks!
12:01:28 <quicksilver> Ah. You are loading the whole thing into a list of pairs first.
12:01:33 <quicksilver> I don't really recommend that.
12:01:51 <quicksilver> hmm. actually maybe not.
12:04:16 <quicksilver> DukeDave: how much memory is it using in fact?
12:04:58 <roconnor> ndm: how does Hoggle index it's libraries?  Is there a database used?
12:05:04 <roconnor> its
12:05:13 <byorgey> @where Expr
12:05:13 <lambdabot> http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
12:05:16 <byorgey> tromp ^^
12:05:19 <ndm> roconnor: haddock --hoogle, a text file is produced
12:05:29 <ndm> roconnor: or runhaskell Setup haddock --hoogle
12:05:37 <tromp> yes, byorgey?
12:05:46 <tromp> ah, thx
12:05:53 <byorgey> =)
12:06:28 <roconnor> ndm: okay; how is this stored internally when hoogle is running?
12:06:47 <ndm> roconnor: its parsed line by line, and stored in a list
12:06:58 <roconnor> :)
12:07:01 <roconnor> simple.
12:07:02 <ndm> roconnor: and the list is lazy, I think
12:07:05 <ndm> yes, and slow
12:07:12 <roconnor> slow?
12:07:14 <ndm> Hoogle 4 stores it in an on disk trie
12:07:25 <ndm> slow, if you have 1000's of types and want to hammer it a lot
12:07:26 <roconnor> oh
12:07:38 <ndm> i.e. not slow, but would be if you went for all the libraries
12:07:48 <gwern> ndm: is the trie where your 'thousands'x performance improvement is coming from?
12:07:54 <ndm> gwern: yes
12:08:08 <ndm> gwern: plus it doesn't have to parse each line, the line is preparsed and stored in binary
12:08:19 <Baughn> gwern: src/System/Plugins/Consts.hs:22:0: error: ../../../config.h: No such file or directory <-- This is from a clean 6.8.2 install combined with cabal upgrade
12:08:40 <gwern> Baughn: ok. are you going through cabal-install?
12:08:48 <Baughn> Yes
12:09:07 <gwern> Baughn: I know what the problem is there, the configure script didn't get run
12:09:27 <DukeDave> quicksilver: Just collecting some samples
12:09:48 <hpaste>  gwern pasted "a correct plugins configure" at http://hpaste.org/6262
12:10:18 <gwern> Baughn: I take it your configure output didnt include the 'sh configure --with-compiler=ghc --prefix=/home/gwern/bin --datadir=/home/gwern/bin/share
12:10:24 <gwern> line and suceeding output?
12:10:29 <Baughn> Correct
12:10:38 <Baughn> I also got "Setup.lhs:4:30: Not in scope: `autoconfUserHooks'" when trying to configure it manually
12:11:35 <davidL> Which type of literate Haskell is better for web presentation (Bird/latex)?
12:11:45 <quicksilver> DukeDave: I would also try to persuade dons to have a look, if he's still around.
12:11:53 <quicksilver> DukeDave: he knows about bytestrings and stricntness
12:14:00 <gwern> Baughn: ah, I must've accidentally introduced a recent Cabalism
12:14:24 <gwern> Baughn: try replacing the autoconfUserHooks with 'defaultUserHooks'
12:14:43 <Baughn> gwern: When I upgraded cabal instead, I got configure: error: cannot find install-sh or install.sh in "." "./.." "./../.."
12:16:08 <mrd> davidL: Bird style is pretty popular for HTML
12:16:17 <gwern> might be a stretch, but what's the output of 'autoreconf --version'?
12:16:23 <Baughn> gwern: Ah. I see you're using build-type: simple - I don't think you're supposed to do that.
12:16:36 <Baughn> 2.61
12:16:42 <davidL> mrd: do you have any examples besides "Composing Contracts"?
12:16:51 <gwern> ok, so that's not it
12:18:06 <hpaste>  gwern pasted "configure error's source" at http://hpaste.org/6263
12:18:19 <gwern> so the question becomes why is that part of the configure erroring
12:19:53 <Baughn> FWIW, the darcs version of hs-plugins builds just fine
12:20:11 <Baughn> It seems to have been configured using autoconf 2.59, though
12:20:16 <gwern> Baughn: but not from an sdist tarball
12:20:36 <gwern> Baughn: yeah, I accidentaally updated while debugging the sdist tarball, and decided might as well keep it
12:21:21 <Baughn> gwern: Now, according to strace it's only looking for install-sh in the actual tarball
12:21:27 <Baughn> gwern: I think you need to bundle it
12:21:59 <Baughn> gwern: http://www.haskell.org/cabal/release/latest/doc/users-guide/x30.html#general-fields <-- According to this you also need to change your build-type
12:22:02 <lambdabot> http://tinyurl.com/2hxddg
12:22:56 <gwern> Baughn: I *think* the 'setup script' there refers to Setup.hs not configure
12:23:08 <gwern> it's custom/complex if there's additional haskell beyond the usual main and hooks
12:23:19 <ndm> kosmikus: solved it
12:23:40 <Baughn> gwern: I read "default setup.hs" as "exactly the same as in the example, without even any extra hoks"
12:23:51 <Baughn> gwern: As I don't see cabal even /trying/ to run the script.. hang on, let me check
12:23:57 <laura85> mrd, thanks for the hint. but I'm still not sure how to implement map f l  with foldr. i mean: map f l == (foldr (:) []) (maplikefunction f l) is the only way i see
12:24:35 <DukeDave> quicksilver: Roger that, I'm just waiting for a profiled run of 1/10th my data set to finish
12:24:43 <Baughn> gwern: Yep. Changing it to Custom makes it at least /try/ to run configure.
12:24:58 <Baughn> That's with newest cabal, mind
12:25:18 <dcoutts_> Baughn: if you want it to run ./configure use build-type: Configure
12:25:56 <dcoutts_> Baughn: and/or in the Setup.hs script use defaultMainWithHooks autoconfHooks
12:26:20 <gwern> dcoutts_: is autoconfHooks a new thing?
12:26:25 <Baughn> dcoutts_: If that's the case, then http://www.haskell.org/cabal/release/latest/doc/libraries/Cabal/Distribution-PackageDescription.html#t:BuildType is lying. Or it's outdated, I suppose.
12:26:26 <lambdabot> http://tinyurl.com/2x9pyz
12:26:26 <mrd> laura85: well, consider that (:) = \ x y -> x:y
12:26:29 <gwern> Baughn's setup didn't seem to recognuize it
12:26:32 <dcoutts_> gwern: it's a renamed 'defaultHooks'
12:26:44 <dcoutts_> gwern: which was a confusing name because they were not default :-)
12:26:46 <Baughn> So build-type: configure would work regardless..
12:26:49 <mrd> davidL: wait what?
12:27:02 <mrd> what's composing contracts?
12:27:03 <davidL> mrd: http://contracts.scheming.org/
12:27:05 <lambdabot> Title: Composing Contracts
12:27:21 <dcoutts_> gwern: you might have thought that defaultMain = defaultMainWithHooks defaultHooks, but it's not true :-( in fact defaultMain = defaultMainWithHooks simpleHooks
12:27:46 <gwern> madness!
12:27:48 <mrd> erm, that's fine i guess.  really the only thing to keep in mind is to keep blank lines around the code blocks
12:27:50 <dcoutts_> gwern: previously only defaultHooks was exported, now that's deprecated and people are encouraged to use either simpleHooks or autoconfHooks
12:27:56 <Baughn> gwern: In fact, build-type: configure /does/ work with both versions of cabal. Useful.
12:28:00 <dcoutts_> gwern: tell me about it, it's more sensible now :-)
12:28:05 <laura85> mrd, oh didn't know that. i try ^^ thanks again
12:28:09 <Baughn> gwern: Well, except that it's still missing install-sh. ;/
12:28:14 <davidL> mrd: also note the embedded happs webserver :)
12:28:16 <gwern> dcoutts_: ok, so I guess I need to update the cabal dep if I want to use autoconfHooks, which version changed that?
12:28:36 <gwern> dcoutts_: currently I have >= 1.2 for section syntax
12:28:46 <dcoutts_> gwern: don't bother, just use defaultHooks, it still works and means you'll be compatible with both Cabal-1.2 and the upcomming 1.4
12:28:58 <gwern> ok then
12:29:24 <Baughn> gwern: And copying in a random install-sh from my own system makes it.. fail the compile at ParsePkgConfCabal. I think you should add a cabal dependency. :P
12:32:39 <Baughn> gwern: It does build with the newer cabal, though. So in summary, build-type: configure, install-sh and some currently unresolvable cabal dependency.
12:34:09 <dcoutts_> Baughn, gwern: what package is this?
12:34:26 <Baughn> plugins-1.1
12:36:37 <smg> forall is really nifty
12:36:38 <dcoutts_> Baughn: ah, and it depends on Cabal itself does it? and it's failing to build with the latest cabal version due to api changes?
12:37:02 <Baughn> No, it's failing to build with 1.2.3.0
12:37:07 <Baughn> It build just fine with the latest cabal
12:37:55 <dcoutts_> oh right
12:40:27 <byorgey> dcoutts_: did you get my patch fixing paragraph wrapping for synopses in 'cabal list'?
12:40:58 <byorgey> dcoutts_: it's in no way urgent of course =)
12:44:25 <roconnor> @spell transcendental
12:45:08 <mrd> laura85: did that help?
12:45:21 <MarcWeber> Can you still compile gcjnii with recent compilers? has anyone tried?
12:46:49 <byorgey> roconnor: that's correct =)
12:48:11 <laura85> mrd, well, if you meant:  map f l == foldr (\x y -> (f x) : y) [] l, then yes ^^
12:48:21 <mrd> good =)
12:49:11 <laura85> mrd, heh now I'm trying to do the same, but using foldl instead
12:49:25 <MyCatVerbs> @pl \x -> ("a",x)
12:49:25 <lambdabot> (,) "a"
12:50:18 <mrd> laura85: have you been able to reconstruct a list using foldl?
12:51:52 <laura85> mrd, not yet ^^
12:53:30 <hpaste>  DukeDave pasted "Memory stats" at http://hpaste.org/6264
12:53:41 <DukeDave> quicksilver: If you're interested ^
12:54:14 <DukeDave> dons: Can I borrow you for some ByteString interrogation if you have a minute :)
12:56:32 <tromp> > foldr ((:).f) [] [a,b,c,d] :: [Expr]
12:56:33 <lambdabot>  [f a,f b,f c,f d]
12:57:59 <mrd> laura85: you need a function of type [a] -> a -> [a]
12:58:38 <tromp> that's the slow way:)
12:59:42 <oerjan> > \x -> x :: Expr
12:59:43 <lambdabot>  <SimpleReflect.Expr -> SimpleReflect.Expr>
12:59:52 <oerjan> ah it was dropped
13:01:08 <oerjan> @pl f1x f = f (f1x f)
13:01:08 <lambdabot> f1x = fix (ap id)
13:02:30 <tromp> @pl s x y z = x z (y z)
13:02:30 <lambdabot> s = ap
13:03:10 <tromp> @pl si y z = z (y z)
13:03:12 <lambdabot> si = ap id
13:03:38 <tromp> @pl k x y = x
13:03:38 <lambdabot> k = const
13:04:18 <skorpan> is there any command in haskell-mode.el which checks for unused functions?
13:04:41 <gwern> skorpan: just turn on -Wall in your ghci and it'll tell you
13:05:07 <oerjan> @pl (\x -> x x) (\x f -> f (x x f))
13:05:11 <lambdabot> ap id id (ap id . ap id id)
13:05:11 <lambdabot> optimization suspended, use @pl-resume to continue.
13:05:27 <oerjan> oops
13:05:36 <oerjan> @pl (\x -> x x)
13:05:41 <skorpan> whoa those are lots of errors
13:05:44 <skorpan> or warnings.
13:06:09 <oerjan> @bot
13:06:18 <oerjan> oops
13:07:32 <dmwit> You killed it!
13:07:43 <dmwit> ...*after* it died. O_o
13:07:46 * oerjan does the poison frog dance
13:08:10 <laura85> mrd, hmm...
13:08:53 <dmwit> Hiya, laura85!
13:09:05 <laura85> dmwit, hi ^^
13:10:08 <roconnor> > exp pi
13:10:18 <mauke>  4
13:10:24 * oerjan cackles evilly
13:10:28 <roconnor> > exp pi - pi
13:10:31 <mrd> laura85: what ways to do you know to put something in a list?
13:10:31 <dmwit> > pi
13:10:37 <oerjan> @slap mauke
13:10:40 <dmwit> oh
13:10:53 <dmwit> Wow, that was way more confusing than it should have been.
13:10:54 * roconnor slaps mauke with a trout
13:11:11 <oerjan> 23.1406926327793
13:11:21 <olsner> hmm, I should try ghc with -Wall some time... sounds scary
13:11:34 * wli uses ghc with -Wall
13:11:41 * Zao hates -Wall
13:11:43 <dmwit> ghc -another -brick -in -the -Wall
13:11:44 <oerjan> hm exp pi - pi is rather close to 20
13:11:51 <Zao> I can't seem to get rid of my last orphaned instance :(
13:12:03 <laura85> mrd, i guess ++ and :
13:12:20 <mrd> laura85: now could you use those to make a function of type [a] -> a -> [a]?
13:12:20 <mauke> Zao: how is that a problem?
13:12:27 <hpaste>  Tener pasted "Calculation of all subsets" at http://hpaste.org/6265
13:12:36 <dmwit> oerjan: Yes.  I recall a story about somebody torturing a programming contest team by telling them their FPU emulator was faulty because e^pi-pi wasn't exactly 20 on it. =P
13:12:37 <Zao> mauke: It's a warning, polluting the beautiful warning-free output.
13:12:46 <oerjan> :D
13:13:05 <Stinger> xkcd comic
13:13:14 <ziman> dmwit, xkcd :)
13:13:24 <dmwit> Yep, that must be it. =)
13:13:27 <dcoutts_> DukeDave: perhaps I can answer your ByteString questions
13:13:30 <Zao> mauke: It's also that I don't quite understand what an orphan instance is, and how I can make it unorphaned.
13:13:35 <dmwit> Tener: Have you seen the beautiful list-monadic way to do that?
13:13:47 <dmwit> Oh, he doesn't seem to be in here.
13:13:52 <dcoutts_> byorgey: yes, I got it thanks, I've applied it locally, will push later
13:13:57 <mauke> Zao: I think it's an instance that is not in the same module as the class or data definiton
13:14:00 <oerjan> Zao: an orphan instance is one that is defined in a module that neither the type nor the class is defined in
13:14:35 <Zao> In my instance, I define an instance Num a => Num (Vector3 a), and neither Num nor Vector3 are mine.
13:14:37 <dcoutts_> byorgey: so what's the next cabal patch you want to work on? :-)
13:14:39 <byorgey> dcoutts_: cool.  no rush.
13:14:46 <dcoutts_> byorgey: I've been looking at more parsing stuff
13:14:47 <Zao> (Vector3 is from OpenGL)
13:15:12 <dcoutts_> byorgey: considering completely replacing the underlying parser lib
13:15:14 <byorgey> dcoutts_: hmm, not sure.  I'm in the middle of some other things at the moment, but I'll probably come round to it again at some point =)
13:15:23 <byorgey> dcoutts_: wow, that would be quite a change!
13:15:25 <dcoutts_> byorgey: because ReadP is made of fail
13:15:28 <byorgey> dcoutts_: what would you replace it with?
13:15:30 <oerjan> it's awkward to compile incrementally, and it also gives documentation trouble - witness all the people asking where to find the (r ->) Monad instance, which you simply have to know
13:15:30 <byorgey> hehe
13:15:31 <ziman> http://imgs.xkcd.com/comics/e_to_the_pi_minus_pi.png
13:15:35 <Zao> I can't quite see how I could resolve that without modifying library source.
13:15:47 <byorgey> dcoutts_: what makes you say that ReadP is made of fail?
13:15:57 <dcoutts_> byorgey: have you seen the error messages?
13:16:04 <byorgey> oh... no, not really
13:16:10 <dcoutts_> no neither have I
13:16:13 <dcoutts_> that's the point
13:16:17 <byorgey> oh... hehe =)
13:16:22 <dcoutts_> :-)
13:16:26 <byorgey> "made of fail"... indeed =)
13:16:40 <byorgey> it fails at failing
13:16:57 <oerjan> Zao: in a pinch you probably can turn off that specific warning with some flag
13:17:08 <dcoutts_> byorgey: probably one of: parsec, parsek, polyparse or the uulib parser
13:17:29 <byorgey> dcoutts_: ReadP seems nice for little lightweight applications, but Cabal certainly isn't
13:17:30 <hpaste>  dmwit annotated "Calculation of all subsets" with "Another (much slower) implementation" at http://hpaste.org/6265#a2
13:17:39 <byorgey> dcoutts_: cool
13:17:58 <dcoutts_> byorgey: right
13:18:10 <malcolmw> dcoutts_: I made a couple of changes to polyparse-bsd this afternoon
13:18:16 <dcoutts_> malcolmw: cool, what?
13:18:28 <malcolmw> dcoutts_: to improve error messages :-)
13:18:43 <dcoutts_> malcolmw: yay! :-)
13:18:51 <malcolmw> dcoutts_: so oneOf' has now disappeared and been folded into oneOf
13:18:59 <dcoutts_> malcolmw: oh nice
13:19:05 <malcolmw> dcoutts_: and <?> does what you think it should
13:19:10 <dcoutts_> great!
13:19:14 <Zao> oerjan: Good idea, since I now grok the meaning of the warning.
13:19:19 <wli> e^x - x = 20 then e^x = (x + 20) then 1 = e^(-x)*(x + 20) then -1 = e^(-x)*(-x - 20) then - e^(-20) = e^(-20 - x)*(-x - 20) then -x - 20 = W(-e^(-20)) then x = - 20 - W(-e^(-20)) where W(x) = y such that y*exp(y) = x
13:19:37 <malcolmw> dcoutts_: and there is an 'eof' parser, and satisfy now reports the token it found if it fails
13:19:51 <dcoutts_> malcolmw: cool, I'll give it another go
13:20:55 <malcolmw> dcoutts_: positional info is coming.  but it is really a tokeniser job, not the parser's job
13:22:04 <Philippa> in that the parser's job is just not losing it, yeah
13:25:20 <dcoutts_> malcolmw: how do you imagine it'll work?
13:26:01 <dcoutts_> malcolmw: that we map over the input to get a [(Char, Pos)] or something, so (Char, Pos) is the token type?
13:27:02 <dcoutts_> in the absence of a proper tokeniser, position per token is a bit expensive I imagine
13:27:37 <dcoutts_> and for .cabal files the format is just not defined in terms of a common token type
13:28:35 <smg> ah i forgot what "unification" was. can someone make a short example?
13:29:15 <laura85> mrd, hmmmm, (:) is a -> [a] -> [a], (++) is [a] -> [a] -> [a]
13:29:29 <malcolmw> dcoutts_: the two-level parsing gives good opportunities
13:29:51 <smg> mrd=merde?
13:29:54 <dcoutts_> malcolmw: we certainly know the starting line of each field
13:30:00 <malcolmw> dcoutts_: there can be a coarse-grain lexer with position consisting only of lines
13:30:10 <Botje> smg: unification is pattern matching done both ways
13:30:27 <dcoutts_> malcolmw: hmm, how does that work? what is the token type there?
13:30:30 <malcolmw> dcoutts_: then a finer-grain lexer with more specific line/column info
13:30:32 <smg> Botje: can you make a code example?
13:31:20 <malcolmw> dcoutts_: the coarse token type is "field" if you will
13:31:41 <malcolmw> the multi-line entity starting with keyword and colon
13:31:52 <Botje> not really
13:31:59 <Botje> too busy eating fruit salad :)
13:32:14 <smg> Botje: haha
13:32:16 <mrd> smg: i hope not
13:32:23 <smg> mrd: ah okay :)
13:32:26 <mrd> laura85: yes, so can you come up with a function [a] -> a -> [a]
13:32:27 <smg> Botje: come on
13:32:41 <malcolmw> dcoutts_: except it is a bit more complicated than just fields, because there is the whole stanza or conditional block idea too
13:32:54 <Botje> smg: i'm sure you're able to search google on your own. off you go.
13:32:57 * Philippa used tokens with start /and/ end position in the last parser she wrote...
13:33:07 <oerjan> smg: haskell does not have builtin unification for pattern matching, only for type inference
13:33:11 <Philippa> ...but then it was for a language with layout
13:33:20 <malcolmw> Philippa: yes, it is a straightforward extension
13:33:22 <Philippa> so you can't count columns quit eso easily
13:33:32 <oerjan> look at Prolog for a language which does
13:33:33 <Philippa> yep, nice, simple and dumb
13:33:57 <Philippa> talking of which, I *really* ought to finally implement the layout rule properly
13:34:02 <Philippa> I mean, I've been talking about it for over a year
13:34:23 <Philippa> also, it'll make me document the assumptions I've made about the language's grammar in approaching it that way, which is a good thing to've done
13:34:34 <wli> What is wrong with extant implementations?
13:35:08 <Philippa> wli: nobody really implements it as the standard defines it. Mostly because the definition is a mess
13:35:48 <Philippa> something about a preprocess to the parser being defined mostly as if it's a pure function but also in terms of parsing
13:35:59 <laura85> mrd, that's putting something to the of a list, right?
13:36:31 <Philippa> my solution's to have the two communicate: have the parser sit on top of a Layout monad that generates its input, then the parser can say "oops, failed, try it again now you know that?"
13:36:41 <wli> How's this new one different?
13:36:56 <malcolmw> Philippa: ah, a backtracking lexer
13:37:14 <Philippa> malcolmw: essentially, yeah. Of course, lexing's only LL(1)
13:37:20 <dmwit> laura85: That's one such function, yes.
13:37:28 <Philippa> and really it's not lexing as such, it's a stage between lexing and parsing still. But same difference
13:37:41 <dmwit> laura85: Assuming there was a word in "to the _ of a list", of course. ;-)
13:38:27 <malcolmw> well, collating positional info is nearly lexing, and inserting braces is ... well, yes, not really lexing either
13:38:30 <laura85> heh
13:39:42 <smg> oerjan: mh
13:40:46 <smg> oerjan: that was it type inference thank you
13:43:32 <mrd> laura85: so how would you do that?
13:44:32 <laura85> mrd, recursion? ^^
13:44:54 <dmwit> You shouldn't need recursion.
13:45:26 <shteou> malcolmw: I was investigating the (let x...(x+x)+x) example you gave earlier, it seems that YHC compiles code to push the constant, x, and makes applications to Prelude;fromInteger 3 times, thus resulting in 3 seperate heap nodes of x's value.  Thus changing the BINOPs works, however I assume this compiler behaviour can't be relied upon?
13:45:40 <mrd> :t (++)
13:45:52 <mrd> [a] -> [a] -> [a]
13:45:56 <byorgey> mrd: \bot is down
13:46:10 <mrd> now, what could you do to make that [a] -> a -> [a]?
13:46:34 <byorgey> mrd: and if it was up, you would have been shocked to find that the type of (++) is (Monoid a) => a -> a -> a  =)
13:46:35 <mrd> if you wrote a function \ x y -> x ++ y, it would have type [a] -> [a] -> [a]
13:46:36 <malcolmw> shteou: I would suggest not having x be constant
13:46:46 <mrd> byorgey: curses!
13:47:02 <byorgey> hehe, Cale changed it to mappend the other day =)
13:47:09 <malcolmw> shteou: or rather, not a literal.  make it a computation that the compiler can't spot and turn into a plain number
13:47:27 <shteou> Ah yes, I see, trying that now.
13:48:02 <mrd> laura85: if you wrote a function \ x y -> x ++ y, it would have type [a] -> [a] -> [a], so what would you do to that function to make its type [a] -> a -> [a] instead?
13:48:37 <shteou> malcolmw: The compiler still outputs the same mk_ap calls, just changes from PUSH_CONST to PUSH_ARG, I assume it is just a case of the compiler not optimizing though?
13:50:24 <shteou> I will stop pestering you, anyhow ;) I have no immediate intention of a foray into the Haskell specification and YHC's innard!
13:50:41 <malcolmw> shteou: well, I think the first time x is needed, it will be evaluated, and the heap node overwritten with the result.  if that happens after the applications of + have been created, but before they have been evaluated themselves, then it might all go wrong.  But perhaps the sequence of events generated by the compiler is always OK in this respect.
13:51:20 <malcolmw> shteou: don't you have a Report to write soon? :-)
13:51:46 <seaa> hi, I wonder why I get this error http://www.pastebin.org/23131 any answer would be greatly appreciated
13:52:03 <shteou> malcolmw: hehe yes I do :> I'll get back to that now, thanks again!
13:52:48 <oerjan> seaa: missing parentheses around m*2
13:52:50 <dmwit> seaa: The multiplication in line 4.
13:52:58 <dmwit> (Also line 3.)
13:53:10 <seaa> how come?
13:53:17 <malcolmw> shteou: all the best with that
13:53:18 <seaa> it's just a normal multiplication, isn't it?
13:53:20 <dmwit> Function application binds more tightly than anything else.
13:53:42 <laura85> mrd, hm \x y -> y ++ x ?
13:53:43 <dmwit> seaa: Yes, but you're multiplying the result of the function call (a [Bool]) by 2. =P
13:53:46 <shteou> Thanks malcolmw!
13:53:54 <dmwit> seaa: It parses as
13:54:06 <dmwit> (createSideList (n-1) m)*2
13:54:30 <oerjan> seaa: btw all the other parentheses other than around n-l are unnecessary i think :)
13:54:38 <seaa> oh, I see, omg, it worked now! thx a lot
13:54:53 <seaa> oerjan, will take them away then!
13:56:10 <MarcWeber> dcoutts_: Can you tell me how I get a flag or default value? Ther is now easy way, is there?
13:56:15 <oerjan> er, n-1, my browser does not distinguish them clearly in that paste
13:57:03 <laura85> mrd, no i meant \x y -> y : x
13:57:53 <oerjan> seaa: haskell precedence takes a bit getting used to :)
13:57:54 <dmwit> laura85: Nice one!
13:58:32 <dcoutts_> MarcWeber: are you trying to make a Setup.hs compatible with Cabal-1.3.x? If so don't bother, we'll change Cabal so that it is compatible with existing Setup.hs scripts on hackage.
13:58:32 <dmwit> laura85: Now see if you can figure out how to cram that into a fold.
13:58:50 <dcoutts_> MarcWeber: if it's for something else, then it's fromFlagOrDefault iirc
13:59:58 <MarcWeber> dcoutts_: Don't know which version it was. I'm trying to compile takusen.
14:00:14 <laura85> dmwit: foldl (\ x y -> (f y) : x) [] l ? hm but wouldn't it reverse the list at the same time?
14:00:33 <dmwit> What's f?
14:00:36 <MarcWeber> dcoutts_: I've used fromFlagOrDefault now, yes. But I don't like it because it ends up in duplication (of the default value "normal" in the verbosity case)
14:00:38 <laura85> function
14:00:48 <dcoutts_> MarcWeber: oh, that's a very complex Setup.hs, there's some commented out bits in that Setup.hs to deal with Cabal-1.3
14:01:01 <laura85> dmwit, f is a given function
14:01:01 <dmwit> laura85: But yes, that will reverse the list.
14:01:03 <dcoutts_> MarcWeber: just use fromFlag
14:01:11 <oerjan> laura85: to write map with foldl without reversing is quite inefficient
14:01:16 <dcoutts_> MarcWeber: those values all have defaults already
14:01:19 <MarcWeber> dcoutts_: What happens then if no verbosity is given? error .. ?
14:01:30 <oerjan> map is really closer to a foldr
14:01:39 <dmwit> laura85: In most cases, you want to use foldr.
14:01:39 <dcoutts_> MarcWeber: there's already a default specified, don't worry
14:01:46 <dmwit> laura85: This is one such case. =)
14:01:59 <dcoutts_> MarcWeber: if you're interested see Distribution/Simple/Setup.hs
14:02:01 <MarcWeber> dcoutts_: Then they should not have type Flag but only its value type..
14:02:17 <dcoutts_> MarcWeber: well some have defaults, some don't :-)
14:02:38 <MarcWeber>     configVerbose   :: Flag Verbosity, -- ^verbosity level
14:02:42 <MarcWeber> doesn't show it has.
14:03:04 <dcoutts_> MarcWeber: yes, we could do with a type that has the default already applied but we'd have to duplicate the whole record type
14:03:06 <laura85> dmwit, oerjan, good to know ^^
14:03:07 <laura85> heh
14:03:20 <dcoutts_> MarcWeber: eg see ConfigFlags
14:03:40 * dcoutts_ has to go
14:04:03 <MarcWeber> dcoutts_: I've copied the line from there..
14:04:21 <MarcWeber> dcoutts_: Don't you start somewhere with an "empty" record to set settings if they are found?
14:06:03 <MarcWeber> dcoutts_: I'll read the code for writing nonsense now
14:06:08 <laura85> brb ^^
14:08:03 <Saizan> MarcWeber: essentially the empty record already has the defaults filled, and then user-supplied setting override them, every record of flags is a monoid
14:12:55 <Cale> Lambdabot is down?
14:13:00 <Cale> @bot
14:13:20 <Cale> Huh, it ran out of memory.
14:13:54 <oerjan> @pl \x -> x x
14:14:02 <lambdabot> join id
14:14:11 <gwern> Cale: did someone discover a new attack?
14:14:25 <oerjan> that's the thing i was doing just before
14:14:30 <Cale> gwern: I don't think so.
14:14:35 <oerjan> although before that, i did one that was suspended
14:14:41 <Cale> gwern: It's probably just code.h.o thrashing.
14:14:58 <TomMD> ?users
14:14:58 <lambdabot> Maximum users seen in #haskell: 463, currently: 454 (98.1%), active: 6 (1.3%)
14:15:11 <oerjan>  @pl (\x -> x x) (\x f -> f (x x f))
14:15:21 <oerjan> @pl \x f -> f (x x f)
14:15:21 <lambdabot> ap id . join id
14:15:44 <Cale> Though it appears to have 409MB free now.
14:16:15 <Cale> I wonder why code.h.o appears to have no swap, and no buffers or cache.
14:16:19 <dons> Cale, it happens.
14:16:26 <dons> the OS just kills off processes
14:16:26 <Cale> cgibbard@haskell:~$ free
14:16:26 <Cale>              total       used       free     shared    buffers     cached
14:16:26 <Cale> Mem:        524288     114592     409696          0          0          0
14:16:26 <Cale> -/+ buffers/cache:     114592     409696
14:16:26 <Cale> Swap:            0          0          0
14:16:30 <Cale> right
14:16:42 <dons> better lambdabot than the web server
14:16:52 <dons> sometimes it goes the other way
14:17:04 <Cale> Why don't they have any swap?
14:17:30 <Cale> On a machine like that, you'd expect there to be about 1G of swap.
14:18:09 <roconnor> Cale: things are faster without swap.
14:18:22 <Cale> roconnor: They're also much less stable.
14:18:42 <dons> its  all virtual hosting
14:19:12 <roconnor> Cale: oh right.  for 1/2 a GB, I'd expect swap nowadays.
14:19:28 <roconnor> Cale: if they had 4GB of ram, I can imagine a no swap system.
14:19:33 <Cale> yeah
14:19:56 <Cale> I have a GB of memory in my machine, and can't really get by without swap.
14:20:11 <roconnor> anyhow, dons says it is a VM, so maybe that's what's going on.
14:22:38 <tromp> > foldl (\x y-> x . (y:)) id [a,b,c,d] [] :: [Expr]
14:22:39 <lambdabot>  [a,b,c,d]
14:24:32 <dolio> @type \f z -> runCont . foldM ((Cont .) . f) z
14:24:33 <lambdabot> forall a r b. (a -> b -> (a -> r) -> r) -> a -> [b] -> (a -> r) -> r
14:48:24 <MarcWeber> dcoutts_: | OptArg String (Maybe String -> a -> a) (a -> [Maybe String]) is the culprit right? Because there is a function converting a flag to a option again we need Flag.. because when omitting you would get -v normal although you haven't given this arg on cmd line ?
14:49:19 <MarcWeber> and commandShowOptions isn't used anywhere within cabal .. *lol*
14:50:05 <dons> http://reddit.com/info/6bkqu/comments/ A review of xmonad :)
14:50:47 <tibbe> is there no way to flush a Network.Socket.Socket or is there no need to?
14:52:27 * Heffalump is suffering from jdh30 on reddit again
14:52:59 <dons> sigh
14:54:34 <dons> it is so not worth responding
14:54:48 <dons> since his stated goal is to provoke, since all noise is traffic to his site
14:55:11 <Plouj> haskell is making every other language look easy
14:55:52 <Heffalump> the jdh30 downmod squad seems to have got a bit weaker lately, though. I like to respond to any rubbish he says that has a positive score.
14:57:07 <quicksilver> DukeDave: Hmm. given that dons didn't have time to comment, I suggest a -cafe post.
14:57:18 <quicksilver> DukeDave: the linear usage is linear, which is what you'd hope
14:57:37 <quicksilver> DukeDave: but the linear overhead is far higher than I would have guessed/hope.
14:58:09 <dons> Heffalump: though he's always  too slow to have any impact.
14:58:13 <dons> typically responding days later.
14:58:28 <dons> though he does walk back over posts adding little bombs
14:58:44 <Heffalump> true
14:59:43 <dons> so more worrying would be if he goes around these "consulting" talks bad mouthing haskell. i suspect he would
15:00:20 <dons> though i hope to drown competition in open source -- worked for most other langs :)
15:00:41 <DukeDave> quicksilver: Yeah I've been trying a few different things but am getting now where
15:00:43 <DukeDave> *no where
15:01:35 <augustss> where has jdh30 babbled now?
15:02:13 <Heffalump> more reddit threads
15:02:32 * tibbe 's web server just said Hello, World!
15:02:39 <Heffalump> Hello, tibbe's web server
15:02:46 <tibbe> :)
15:02:49 <augustss> he can be annoying
15:03:06 <tibbe> now lets see if I can get it to say hello world 1000+ times per second
15:03:09 <tibbe> then we're talking
15:03:13 <dons> augustss: highly.
15:03:41 <augustss> but i don't think he's inherently evil :)
15:04:01 <dons> but that's his goal. he stated that there's more traffic to his site generated by infighting in the FP community than without, so he does what he does
15:05:32 <Heffalump> I think he's a menace on reddit, because he sounds authoritative and is often quite convincing (and often is correct), but he throws in a lot of FUD and slander.
15:06:01 <dons> he uniformly tries to undermine the perception of haskell as production-ready
15:06:19 <dons> almost invariably his haskell comments are about fear and doubt
15:06:41 <Heffalump> FUD is hard to counter, so I try to catch him telling outright lies instead
15:06:49 <Plouj> heh
15:07:14 <tibbe> what's the thread in question?
15:07:37 <Heffalump> the most recent one is this: http://reddit.com/info/69jbs/comments/c03e9f6, but there were several some weeks ago
15:08:50 <Igloo> How does that increase traffic to his site? There's no link, is there?
15:09:10 <Plouj> Igloo: that was probably a general statement
15:09:32 <dons> Igloo: there's a long mail he wrote to the usenet group about his strategy
15:09:46 <dons> i've the link somewhere, but basically he analysed what triggers the most traffic
15:09:53 <Igloo> Oh, is this John Harrop(sp?)?
15:09:57 <dons> yeah
15:10:11 <Heffalump> he's said quite a lot of interesting stuff about GC performance lately, but unfortunately I don't trust a word he says
15:10:31 * Igloo doesn't understand at all. I don't even see how I could have found out his name, let alone website, without guessing at what the initials stood for
15:10:32 <Heffalump> which is a shame, since I'm sure quite a bit of it is actually right, I just don't know which bits
15:10:49 <dons> well, e.g. not trusting haskell for multicore, while asserting ocaml is fine is rather odd -- you don't have an smp runtime in ocaml. so he's just fudding around there.
15:10:51 <Heffalump> he advertises himself as the author of some books quite often
15:11:19 <dons> this thing about wanting to buy libraries is weird too
15:11:30 <dons> he complains that he can't buy haskell libraries. ah well
15:11:44 <Heffalump> I think that's just a convenient stick, because some commercial stuff is written in O'Caml.
15:11:50 <dons> yep
15:12:24 <Igloo> Send him my way - I'll sell him some Haskell libraries
15:12:36 <dons> :)
15:12:44 <dons> starting with Prelude.hs ?
15:13:07 <Excedrin> that comment makes me scratch my head... "Nobody really uses Haskell; the Haskell community codes stuff that nobody uses; libraries are impossible; where's the docs? but Haskell is great for coding on Linux!"
15:13:33 <dons> its all poison.
15:13:43 <BoudewijnEctor> Can someone tell me what kind of problem causes this error : *** Exception: fd:8: hClose: resource vanished (Broken pipe)
15:13:46 <tromp> @karma lambdabot
15:13:46 <lambdabot> lambdabot has a karma of 1
15:13:52 <seaa> hello guys, I have stumbled over another bug that I just can't understand -> http://www.pastebin.org/23144   and then again, any answers would be greatly appreciated
15:13:55 <Twey> Excedrin: Eh? o.@
15:13:57 <BoudewijnEctor> it's occurring within haskore
15:14:00 --- mode: irc.freenode.net set +o vincenz
15:14:07 <Excedrin> Twey: I agree...
15:14:12 <tromp> how to add karma again? lambdabot deserves more
15:14:26 <astrolabe> @help karma
15:14:26 <lambdabot> karma <polynick>. Return a person's karma value
15:14:34 <astrolabe> @help karma+
15:14:34 <lambdabot> karma+ <nick>. Increment someone's karma
15:14:35 <olsner> @karma lambdabot
15:14:35 <lambdabot> lambdabot has a karma of 1
15:14:45 <tromp> @karma+ lambdabot
15:14:45 <lambdabot> lambdabot's karma raised to 2.
15:14:49 <seaa> hello guys, I have stumbled over another bug that I just can't understand -> http://www.pastebin.org/23144   and then again, any answers would be greatly appreciated
15:14:56 <gwern> wonder if karma is an Int
15:15:01 <oerjan> seaa: btw we prefer hpaste for haskell pasting
15:15:04 <oerjan> @paste
15:15:04 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:15:18 <tromp> just try 2^31 karma+'s
15:15:24 <oerjan> yours loads really slowly...
15:15:34 <gwern> tromp: no you
15:15:37 <seaa> ok, will use that instead, sorry
15:15:43 <tromp> nah, i'm too lazy:(
15:15:44 <dons> its an Integer, gwern
15:16:12 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/6266
15:16:17 <seaa> http://hpaste.org/6266
15:16:17 <gwern> phoeey
15:16:19 <seaa> there u go :)
15:16:38 <seaa> omg, hpaste pwned me :S
15:16:42 <seaa> was faster =(
15:17:03 <oerjan> seaa: validate s (n-1) list
15:17:07 <dons> heh, its written in haskell :)
15:17:31 <seaa> what's wrong with it?
15:17:31 <oerjan> you cannot have parentheses around all the arguments of a function
15:17:55 <seaa> LOL
15:17:59 <seaa> sorry, got damn it!
15:18:03 <astrolabe> I think the fact that you can't buy haskell software is probably symptomatic of something bad, but I'm not sure what.
15:18:10 <BoudewijnEctor> can someone help me on this error?  *** Exception: fd:8: hClose: resource vanished (Broken pipe)
15:18:16 <seaa> I had my eyes focus on the first part of the function, lol, I have done to much c++ :P really sry
15:18:20 <oerjan> BoudewijnEctor: where do you get it?
15:18:24 <BoudewijnEctor> in haskore
15:18:29 <BoudewijnEctor> when trying to play midi
15:18:36 <BoudewijnEctor> or at least generating it
15:18:40 <dons> BoudewijnEctor: some input program died?
15:18:47 <gwern> astrolabe: its symptomatic of you being too poor to buy from the big haskell users like the banks or bluespec or galois etc
15:18:50 <Heffalump> astrolabe: yes, we're not making enough money out of it
15:19:00 <Heffalump> banks don't sell Haskell software
15:19:11 <BoudewijnEctor> dons, no an example
15:19:26 <astrolabe> gwern: But do these places sell software?
15:19:41 <dons> you can buy cryptol or bluespec if you want
15:19:43 <oerjan> @bf +-+-
15:19:44 <lambdabot>  fd:15: hClose: resource vanished (Broken pipe)
15:19:51 <gwern> astrolabe: do bespoke tailors sell clothing?
15:19:52 <BoudewijnEctor> dons,  the playSimple function from haskore generates it
15:19:57 <dons> hmm
15:19:57 <oerjan> BoudewijnEctor: ^^ the only place i've seen it before :D
15:20:02 <Heffalump> dons: could you tell him that, that way we can call him on lying next time he repeats that claim?
15:20:11 <laura85> is there a Char x, for which (isAlpha x && isAscii x) is false?
15:20:32 <oerjan> BoudewijnEctor: in that case it happens because it tries to call a nonexisting brainfuck interpreter, i think
15:20:41 <BoudewijnEctor> why brainfuck?
15:20:54 <oerjan> well that's what the @bf command does...
15:20:58 <BoudewijnEctor> ah okay
15:21:04 <oerjan> @unlambda ``skk #also bad
15:21:04 <lambdabot>  fd:15: hClose: resource vanished (Broken pipe)
15:21:07 <gwern> laura85: doesn't Char encompass all unicode points?
15:21:23 <BoudewijnEctor> Does someone have experience using haskore? I've been trying for a couple of days to get sounds out of it
15:21:28 <dons> Heffalump: if see he's claiming credit for "productizing" F#, interesting.
15:21:30 <quicksilver> laura85: something like a greek alpha, I would imagine.
15:21:41 <quicksilver> laura85: or perhaps something as simple as an e-acute.
15:21:41 <laura85> quicksilver, gwern: oh ok, thanks ^^
15:21:44 <oerjan> > isAlpha (chr 160)
15:21:45 <lambdabot>  False
15:21:49 <oerjan> > isAlpha (chr 180)
15:21:50 <lambdabot>  False
15:21:50 <gwern> that'd include stuff like spaces pucntuation and crazy things which don't make sense in any sane script but which are needed to represent the indigenous language of atlantis
15:21:55 <oerjan> > isAlpha (chr 200)
15:21:55 <lambdabot>  True
15:21:58 <oerjan> ah
15:22:20 <oerjan> > isAscii (chr 200)
15:22:21 <lambdabot>  False
15:24:14 <oerjan> laura85: ^^ that's an E with accent grave
15:25:10 <MarcWeber> BoudewijnEctor: what's your trouble?
15:25:12 <gwern> unicode I/O is problematic in haskell. bytestring's char8 stuff just makes it worse
15:25:44 <quicksilver> I don't think bytestring's char8 stuff made it any worse than it was before.
15:25:51 <quicksilver> certainly it didn't help, but then it wasn't trying to.
15:25:51 <BoudewijnEctor> MarcWeber, I understand the theory, but I can't get Haskore to create a midi file
15:25:57 <MarcWeber> BoudewijnEctor: it's a long time ago I've tried it.. Can you compile the examples?
15:26:10 <dons> Heffalump: http://reddit.com/info/69jbs/comments/c03ep8l :)
15:26:11 <BoudewijnEctor> MarcWeber,  Like these:http://www.haskell.org/haskore/onlinetutorial/haskoreexamples.html
15:26:13 <lambdabot> Title: Haskore Tutorial: Examples, http://tinyurl.com/27hu2t
15:26:13 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/6267
15:26:14 <dons> gwern: grab utf8string
15:26:26 <dons> use that to encode/decode String/ByteString as you wish
15:26:35 <BoudewijnEctor> MarcWeber, I can't , because it can't find the modules (these need to be fully qualiified I guess)
15:26:45 <Heffalump> dons: good good :-)
15:26:48 <radix> btw, what's the advantage of utf8string over Encoding?
15:26:56 <gwern> dons: that's exactly it, it isn't convenient at all! why don't we have sane UTF handling in XMC, because no one wanted to add a dependency
15:27:02 <dons> Heffalump: do you know kzm's bioinformatics company? i bet they're in the market too. hmm
15:27:07 <radix> encoding seems to be a pretty good package.
15:27:10 <oerjan> BoudewijnEctor: if it is similar to the lambdabot case, maybe it is trying to call an external program which you haven't installed?
15:27:20 <oerjan> (just guessing)
15:27:26 <MarcWeber> BoudewijnEctor: Wait, I'll grab the source again
15:27:29 <Heffalump> I think listing random companies that make software for internal use and saying that they might sell it if you give them enough money is probably not very useful.
15:27:32 <BoudewijnEctor> oerjan, that's just a specific error in a specific case
15:27:41 <Heffalump> But cryptol and the bluespec compiler are real products.
15:27:52 <BoudewijnEctor> MarcWeber, thanks. I'm getting used to haskell, but I'm having trouble keeping overview of haskore
15:28:00 <gwern> I
15:28:09 <gwern> m a little surprised. did henning update haskore for 6.8?
15:28:17 <astrolabe> I was interested in this article about basic programmers getting a lot of programs finished, and there is something in it I think.  I don't feel that as a community we produce our fair share of products (I certainly don't).
15:28:20 <BoudewijnEctor> gwern, no.
15:28:21 <astrolabe> http://reddit.com/r/programming/info/6bfs1/comments
15:28:30 <BoudewijnEctor> gwern, I thank that's the problem...
15:28:33 <BoudewijnEctor> *think
15:28:39 <dons> Heffalump: his mind set is so alien to the open source world its just hard not to speak at cross purposes.
15:28:52 <laura85> oerjan, heh thanks ^^
15:28:57 <Trollinator> can someone recommend a good german haskell book?
15:29:00 <dons> astrolabe: i think hackage is encouraging people to do the last 5% and upload
15:29:00 <gwern> astrolabe: I disagree. speaking from personal experience, we haskellers produce plenty of shit
15:29:11 <dons> astrolabe: but if people can finish the things they do, that's a lot of help
15:29:24 <gwern> astrolabe: the problem is, we never polish it up to the point where it's truly useful to non-haskellers, much less maintain it
15:29:46 <gwern> no one wants to put a ghc or darcs or xmonad level of work into their little projects
15:30:05 <astrolabe> dons, gwern: Yeah, it could be that the situation is now changing as hackage becomes more useful.
15:30:07 <taruti> and GHC is a moving target
15:30:26 <dons> astrolabe: people now know they're supposed to cabalise and upload to be considered done.
15:30:29 <dons> and we can keep lifting that bar
15:30:31 <taruti> 6.4 -> 6.6 -> 6.8 all require changes in many places
15:30:38 <dons> well, small changes.
15:30:47 <quicksilver> I don't particularly think the situation is worse in haskell than other communities.
15:30:50 <quicksilver> We're small.
15:30:53 <gwern> taruti: that's true of every useful language; could you take GNU software from '90 and easily compile it these days?
15:30:54 <quicksilver> (relative to Perl or Java)
15:30:55 <dons> we aim for a good conversion rate.
15:31:00 <taruti> dons: true. but changes that mean "this cannot be compiled without tweaking with it"
15:31:14 <astrolabe> quicksilver: This channel isn't small.
15:31:16 <quicksilver> if you remember when the Perl community was the size the haskell one is now, there weren't many good libraries either.
15:31:20 <quicksilver> there was no CPAN.
15:31:25 <taruti> gwern: most C libraries from 2005 still compile ok.
15:31:32 <taruti> gwern: same with perl
15:31:35 <Heffalump> we need better tools badly
15:31:48 <mauke> perl-5.8.8 passes perl1's test suite
15:31:51 <astrolabe> Heffalump: like what?
15:32:13 <gwern> taruti: that's true of haskell too; the breaking changes are usually for *building* it, which is cabal and GHC's meta-data fault
15:32:19 <quicksilver> mauke: ghc-6.8 still compiles haskell98 as well as 5.5 did.
15:32:26 <quicksilver> mauke: the problem is libraries + infrastructure.
15:32:31 <mauke> haskell98? hah
15:32:39 <Heffalump> a debugger, a good IDE
15:32:41 <quicksilver> not the language itself
15:32:44 <mauke> perl1 is almost a completely different language
15:32:45 <Heffalump> those are the two most critical ones
15:32:53 <dons> the stability issue is well known, and rapidly converging
15:32:55 <Heffalump> s/debugger/good debugger/ # ghci isn't nearly there yet
15:32:56 <taruti> gwern: true. but those little bits can be a pain.
15:33:02 <dons> i expect *far* less breakages in the next ghc iteration
15:33:06 <astrolabe> Heffalump: That would be awesome.
15:33:21 <Heffalump> it's not just awesome, it's critical to accelerate commercial takeup
15:33:26 <roconnor> > pi * sqrt(163)
15:33:27 <Heffalump> particularly in places without experts on hand
15:33:27 <lambdabot>  40.10916999113252
15:33:32 <taruti> dons: that would be nice :)
15:33:35 <roconnor> > exp (pi * sqrt(163))
15:33:35 <lambdabot>  2.6253741264076826e17
15:33:43 <roconnor> 3^40
15:33:48 <roconnor> > 3^40
15:33:49 <lambdabot>  12157665459056928801
15:33:52 <dons> Heffalump: an i bet courses/consultants/books also play a part.
15:33:56 <quicksilver> dons: the 6.6 -> 6.8 breakages were almost exclusively cabal + the great library split. If I'm not wrong.
15:34:00 <gwern> dons: are you sure? when compiling gtk2hs, I keep seeing these worrying messages about how unversioned dependencies will break with 6.10
15:34:03 <astrolabe> I suppose it is difficult to produce a proper debugger etc when the extent of the language is a bit wooly round the edges.
15:34:05 <quicksilver> dons: I.e. nothing to do with the copiler + the language, precisely.
15:34:06 <ndm> Heffalump: i agree! but who will fund such work
15:34:06 <lambdabot> ndm: You have 1 new message. '/msg lambdabot @messages' to read it.
15:34:13 <laura85> hm, if someone asks "What is the original message when the decrypted message is abc", wouldn't abc be the original message???
15:34:17 <taruti> quicksilver: yes. that was the issue for most things.
15:34:19 <quicksilver> to do with infrastructre and stuff
15:34:26 <roconnor> > logBase 2 (3^40)
15:34:27 <lambdabot>  63.39850002884625
15:34:29 <ndm> @messages
15:34:29 <lambdabot> dcoutts_ said 3d 21h 44m 20s ago: cabal upload is supposed to work, I use it. Is it not being nice to you?
15:35:03 <gwern> quicksilver: there's the FiniteMap issue, and a few others like stuff in System.* like dealing with the shell/other binaries, 0- but mostly it's infrastructure, yeah
15:35:07 <quicksilver> Heffalump: commercial take up of perl, python and C has proceeded largely without the help of any IDESs.
15:35:09 <dons> quicksilver could write more libraries :)
15:35:15 <quicksilver> Heffalump: debuggers I'll give you.
15:35:25 <dons> i'd like Cale to release some more stuff too
15:35:26 <ndm> Heffalump: York has applied for debugger projects and has been turned down because there isn't much new research to do
15:35:28 <quicksilver> dons: quicksilver writing more libraries would make upgrade problems worse I'm sure :)
15:35:46 <Pseudonym> GSoC
15:35:53 <Pseudonym> Just sayin'.
15:35:57 <gwern> dons: dunno if he has much more. he claimed nymphaea was all he had for me...
15:36:12 <astrolabe> Pseudonym: You'd need some pretty bright students.
15:36:13 <dons> happily, hackage is taking off. check ohloh, we're doing really well. >1.2M lines of code, 600 contributors. 350 projects archived
15:36:25 <Pseudonym> This is Haskell.  We only have bright students.
15:36:30 <dons> a dozen new projects a week
15:36:46 <dons> the foundations are in place for many domains that make churning out new bindings/layers cheap
15:36:49 <Heffalump> ndm: it's not academic projects that are needed really
15:36:53 <ndm> Pseudonym: a lot of GSoc Haskellers are fairly new to the language
15:36:55 <BoudewijnEctor> MarcWeber, already got these sources?
15:37:00 <Pseudonym> I know, I'm kidding.
15:37:02 <Stinger> I like haskell and am/was a terrible student
15:37:09 <ndm> Heffalump: no, its a commerical debugger, which no one is willing to pay for...
15:37:22 <Pseudonym> What we actually need is a critical mass of in-house and software-as-service projects.
15:37:24 <ndm> Heffalump: but if not written by a Uni, then by who?
15:37:38 <Heffalump> a Haskell tools vendor, obviously.
15:37:44 <Heffalump> and yes, I know it's chicken and egg
15:37:53 <MarcWeber> BoudewijnEctor: Yes and fixing some errors
15:38:03 <Heffalump> ndm: who have you tried to sell it to? What can it do?
15:38:05 <astrolabe> So, if someone wrote a good debugger, could they sell it?
15:38:15 <BoudewijnEctor> MarcWeber, thanks. I'm running gentoo btw (and Nix, but excluded that from my path for this)
15:38:32 <Heffalump> I reckon we'd buy it (as a matter of opinion, not a promise!)
15:39:05 <astrolabe> I think I'd have difficulty convincing my work.  They won't even pay for visual C++.
15:39:16 <MarcWeber> BoudewijnEctor: Anyway I can't no longer find the definition for %
15:39:18 <ndm> Heffalump: i have nothing yet, but given enough time I could write one (well i have written Gui-Hat, but that hardly counts) - but I don't think there is enough market to make it worth my while
15:39:29 <BoudewijnEctor> MarcWeber, how can I help?
15:39:39 <Heffalump> I didn't say there are easy solutions, just that we need that kind of stuff.
15:39:44 <gwern> BoudewijnEctor: gentoo *and* Nix? interesting,. how is that working?
15:39:44 <ndm> yeah, agreed
15:40:07 <astrolabe> Why is the ghci debugger insufficient? (I haven't used it yet).
15:40:10 <ndm> and i agree that we need a solid piece of engineering, not an academic exercise in theoertical debugging
15:40:34 <BoudewijnEctor> gwern, it works quite well. I tried to keep the Haskell and tex stuff within Nix
15:40:37 <dons> i don't know of anyone who's used it at galois, fwiw.
15:40:38 <Heffalump> no stack traces, history limited to 50 steps
15:40:38 <ndm> astrolabe: i can't use it, its too hard for me
15:40:45 <dons> quickcheck + hunit + prof + hpc
15:40:45 <Heffalump> I've used it a bit, it's occasionally useful.
15:40:50 <dons> acutally, -fhpc is kick butt awesome
15:40:52 <MarcWeber> BoudewijnEctor: Can you load HaskoreExamples.lhs into ghci?
15:40:58 <Heffalump> But I'm an expert Haskeller and also willing to give it the benefit of the doubt.
15:41:04 <Heffalump> dons: and sadly broken with TH in 6.8 :-(
15:41:04 <dons> i pretty much have -fhpc on by default now when testing
15:41:14 <quicksilver> I don't belive the ghci debugger is too hard for ndm. I believe that ndm has not invested enough time to grok it.
15:41:19 <dons> ah yes. you could tie down andy for that
15:41:20 <ndm> its not a good user interface, i think a good debugger has to be graphical in nature
15:41:23 <quicksilver> Which is a perfectly valid decision on his part.
15:41:30 <ndm> quicksilver: yes, but in general time to learn the debugger > time to solve the problem
15:41:33 <BoudewijnEctor> MarcWeber, here to find it? (except for google)
15:41:34 <Heffalump> well, that's a matter of integrating it with an IDE
15:41:53 <ndm> quicksilver: compare that to say the Visual Studio debugger, which is intuative, and has nearly no learning curve to start with
15:41:54 <taruti> having GHC compiled binaries print stack traces reliably without the profiling cruft would be a nice start.
15:41:56 <Heffalump> I also haven't even tried to inspect any values with it, I just use it to find infinite loops.
15:42:04 <MarcWeber> BoudewijnEctor:  I've found it (Data.Ratio
15:42:05 <whee> or you make the debugger sort-of-but-not-quite work like gdb :)
15:42:05 <mauke> heh, I think I suck at debugging
15:42:14 <mauke> I get confused by GUI debuggers
15:42:20 <Heffalump> it doesn't help that "stack trace" is an ill-defined concept in Haskell.
15:42:21 <mauke> I know a few gdb commands, though
15:42:24 <BoudewijnEctor> MarcWeber, please explain
15:42:33 <Cale> What I'd really like in the way of a Haskell debugger is something like HOPS for Haskell
15:42:52 <taruti> Heffalump: basically "what caused this exception to be thrown from deep inside library code"
15:42:55 <MarcWeber> BoudewijnEctor: I've used hoogle to find it. The module was missing import Data.Ratio
15:42:55 <Cale> That is, something which would let you watch the graph reduction graphically.
15:43:17 <astrolabe> Would it be possible for someone to rough out the structure of a debugger?  Say the main types and modules, and break the problem down into easier tasks?
15:43:18 <Heffalump> taruti: but do you blame the original caller, or the thing that caused it to be evaluated?
15:43:57 <Heffalump> the right thing to blame depends on programmer intention, as to whether it's ok for a certain unevaluated thunk to be hiding an exception or not
15:44:01 <astrolabe> Heffalump: Maybe report the arguments to the user and let him/her decide.
15:44:01 <BoudewijnEctor> MarcWeber, I'm not getting it
15:44:02 <dons> ndm++ filepath solves a problem for me
15:44:06 <quicksilver> ndm: I believe the visual studio debugger has a large learning curve, actually. I just believe you have used enough similar or related programs that you're used to it.
15:44:15 <Heffalump> astrolabe: what arguments?
15:44:15 <quicksilver> I also have never felt the need for the ghci debugger.
15:44:29 <Heffalump> I think the VS debugger is pretty easy to use.
15:44:29 <taruti> true. quite complex.
15:44:30 <quicksilver> I seem to find other ways to debug haskell programs which also work well.
15:44:54 <taruti> then again does a pure graph reduction model work for concurrent programs using IO heavily?
15:44:58 <astrolabe> Heffalump: If a library function gives an exception, then the arguments passed to that function.  Or have I misunderstood you?
15:44:59 <ndm> quicksilver: i got started with the VB debugger, which is easier than the VS one, and may have set me up for it
15:45:06 <Heffalump> algorithmic debugging is very cool, but it has way too much overhead for anything really big, which is typically where I find myself actually wanting a debugger.
15:45:15 <Heffalump> astrolabe: oh, right. But usually you want to know where those arguments came from.
15:45:21 <ndm> i'm not convinced algorithm debugging is that useful at all
15:45:57 <astrolabe> quicksilver: I think that there are certain kinds of programs that debuggers are very useful for.  Not so much CS type programs as applications, which is what we are trying to encourage.
15:46:11 <Cale> taruti: Even concurrent Haskell programs do graph reduction, they just do it concurrently.
15:46:43 <MarcWeber> BoudewijnEctor: Can you start ghci and :l HaskoreExamples?
15:46:56 <ndm> astrolabe: there are points in writing CS programs when I would have literally killed siblings for a debugger, even to the point were I tried Hat!!!
15:47:01 <BoudewijnEctor> ghci can't find the module
15:47:08 <astrolabe> Although, generally, a debugger would be useful to me to help find space leaks.
15:47:12 <BoudewijnEctor> but according to ghc-pkg list  , it is installed
15:47:19 <BoudewijnEctor> using ghc 6.8.2 btw
15:47:21 * Heffalump goes to bed
15:47:22 <astrolabe> ndm: hah :)
15:47:28 <MarcWeber> BoudewijnEctor: Which ghc versions are you using?
15:47:35 <BoudewijnEctor> 6.8.2
15:47:39 * ndm isn't that close to his siblings, but would still have had to wipe up the blood
15:47:49 <MarcWeber> BoudewijnEctor: One sec
15:48:44 <quicksilver> astrolabe: somethign would be useful to find spaceleaks
15:48:49 <quicksilver> astrolabe: but it wouldn't be much like a 'debugger'
15:48:56 <quicksilver> astrolabe: more a heap-graph-visualiser
15:49:34 <astrolabe> quicksilver: I don't think a haskell debugger would be much like a normal debugger, and would ideally have some kind of graph visualiser.
15:49:47 <quicksilver> yup that would be handy.
15:49:52 <laura85> chr.((\x y -> mod y x) 255).(+42).ord    returns "\139" for "a" but it's supposed to return another alphaletter (char -> char). what's wrong?
15:50:25 <MarcWeber> BoudewijnEctor: Get the patched version from http://mawercer.de/haskore.zip
15:50:27 <mauke> why do you think it should return an alphaletter?
15:50:47 <BoudewijnEctor> MarcWeber, thanks, I'll give it a shot
15:50:55 <MarcWeber> BoudewijnEctor: then start ghci and do :l HaskoreExamples  after that tab childSong6 should create test.mid
15:51:22 <laura85> mauke: it should encrypt a text and decrypt it and it's bijective
15:51:25 <MarcWeber> BoudewijnEctor: The t1 t2 t3 etc are test functions which should produce some sound but I think they are using CSound (haven't looked at them very closely)
15:51:34 <mauke> laura85: yeah, so?
15:52:13 <laura85> mauke: map f "Hello", where f is chr.((\x y -> mod y x) 255).(+42).ord ...
15:52:44 <mauke> HOW DOES THAT RELATE TO MY QUESTION
15:53:00 <MarcWeber> BoudewijnEctor: Got it?
15:53:05 <BoudewijnEctor> yup
15:53:10 <MarcWeber> BoudewijnEctor: I'm missing rosegarden on nix .. :(
15:53:14 <BoudewijnEctor> it works, what did you change :)
15:53:25 * EvilTerran remotely sets off the fire extinguisher by mauke's desk
15:53:26 <MarcWeber> BoudewijnEctor: Just use the diff tool :)
15:53:34 <BoudewijnEctor> willdo
15:53:37 <laura85> mauke, depends on which question you mean
15:53:42 <MarcWeber> BoudewijnEctor: Can you play the resulting .mid ?
15:53:56 <mauke> <mauke> why do you think it should return an alphaletter?
15:54:00 <BoudewijnEctor> No, but I have some doubts about the gentoo installation
15:54:10 <BoudewijnEctor> or it's ability to play midi
15:54:23 <mauke> your code obviously just adds 42 to each character
15:54:25 <BoudewijnEctor> the file is 1.3K big btw
15:54:29 <BoudewijnEctor> *test.mid
15:55:12 * EvilTerran wonders if there's sufficient demand for a withEnum f = toEnum.f.fromEnum
15:55:43 <quicksilver> don't think so
15:55:49 <quicksilver> that's generally an icky thiing to do :)
15:55:54 <quicksilver> except in a few special cases.
15:55:57 <EvilTerran> laura85, by the way, ((\x y -> mod y x) 255) = (\y -> mod y 255) = (\y -> y `mod` 255) = (`mod` 255)
15:56:08 <EvilTerran> quicksilver, heh, true
15:56:18 <BoudewijnEctor> MarcWeber, it works!
15:56:23 <EvilTerran> just thought it'd go nicely with betweEnum
15:56:25 <BoudewijnEctor> Had to use windows to play it, but it works
15:57:07 <tromp> :t chr
15:57:08 <lambdabot> Int -> Char
15:57:10 <tromp> :t ordf
15:57:11 <lambdabot> Not in scope: `ordf'
15:57:12 <tromp> :t ord
15:57:13 <lambdabot> Char -> Int
15:57:20 <MarcWeber> BoudewijnEctor: Nice. not for me.. But that's because of timitidy isn't installed correctly..
15:57:25 <laura85> EvilTerran, that helped a lot, thanks
15:57:33 <quicksilver> EvilTerran: however, I sometimes wish for class bi a b where in :: a -> b; out :: b -> a;  and then you define conf f = out . f . in
15:57:34 <BoudewijnEctor> MarcWeber, thanks :)
15:57:41 <tromp> > ord '0'
15:57:42 <lambdabot>  48
15:57:44 <quicksilver> EvilTerran: erm 'conj' not 'conf'.
15:57:56 <tromp> > succ '9'
15:57:56 <lambdabot>  ':'
15:58:00 <EvilTerran> Bi for bijection?
15:58:05 <tromp> > prev '0
15:58:05 <lambdabot>  Improperly terminated character constant at "'0" (column 6)
15:58:07 <tromp> > prev '0'
15:58:07 <MarcWeber> BoudewijnEctor: Go and write crazy music :)) But you should have a look at the csound manual *ohh*
15:58:07 <quicksilver> sort of, yes.
15:58:07 <lambdabot>   Not in scope: `prev'
15:58:16 <quicksilver> It's not a full domain bijection necessarily
15:58:22 <quicksilver> but bijection-onto-subset
15:58:27 <quicksilver> (aka injection..)
15:58:28 <EvilTerran> indeed
15:58:30 <BoudewijnEctor> MarcWeber, kosmikus wants me to give a talk about haskore next wensday
15:58:46 <BoudewijnEctor> so that's my main target currently
15:58:49 <quicksilver> BoudewijnEctor: short talk : (1) Haskore is cool (2) Haskore doesn't seem to work.
15:59:12 <BoudewijnEctor> quicksilver, true. But I don't think everybody will appreciate it
16:00:04 <laura85> mauke, changed that function to an equivalent version . now it returns "t" for "a"
16:00:22 <laura85> mauke, but does weird things like \ESC for "H"
16:00:26 <mauke> what exactly is your definition of "equivalent"?
16:00:46 <dibblego> if it now returns "a" and not "a", then it is not equivalent
16:00:50 <laura85> (1 + 1) * x == 2*x
16:00:51 <dibblego> er, "t" and not "a"
16:01:35 <MarcWeber> BoudewijnEctor But you won't give your talk near Vilingen-Schwenningen, will you ? :)
16:02:09 <BoudewijnEctor> MarcWeber, Utrecht, netherlands (home of Nix)
16:02:13 <BoudewijnEctor> *previous home
16:02:23 <MarcWeber> BoudewijnEctor: The same as always :(
16:02:31 <tromp> > succ True
16:02:31 <lambdabot>  Exception: Prelude.Enum.Bool.succ: bad argument
16:03:11 <laura85> dibblego, this sucks :-)
16:04:09 <dibblego> laura85, what are you trying to achieve and what have you currently got?
16:07:10 <laura85> dibblego, ok, i have to write a program which cracks  a  encrypted message when it knows its encryption-function (which is bijective btw)
16:07:12 <DukeDave> @seen dons
16:07:12 <lambdabot> dons is in #xmonad, #haskell-soc and #haskell. I last heard dons speak 1m 20s ago.
16:07:20 <dcoutts_> MarcWeber: commandShowOptions is used in cabal-install
16:07:20 <DukeDave> Yey :)
16:08:22 <DukeDave> dons: I was just about to fire a ByteString question off to cafe, but perhaps you'd like a sneak preview?  ;)
16:08:33 <MarcWeber> dcoutts_: Yes. I've seen the reply :)
16:08:50 <dcoutts_> MarcWeber: so the way the command flags stuff works is that we have a two way mapping between command line strings and the structured flags type
16:09:05 <dons> DukeDave: just mail it, i'll get to it after work.
16:09:29 <dcoutts_> MarcWeber: and each set of flags is a monoid, so that we can combine info from various sources, like config files, defaults, the command line etc
16:09:32 <DukeDave> Np, cheers :)
16:09:45 <MarcWeber> dcoutts_: That's not the point. I think it would be nice to see that Verbose is always defined as valid flag. A simple comment -- always defined would be enough..
16:09:51 <dibblego> laura85, so what's the difficulty?
16:10:19 <dcoutts_> MarcWeber: the only way to know is by looking at the commandDefaultFlags
16:10:44 <dcoutts_> MarcWeber: sure it'd be nice to have another set of flags where we know they're all non-empty, ie we've applied any defaults
16:11:03 <dcoutts_> but that means adding another type as far as I can see, I don't see a nice way to parameterise it
16:11:26 <dcoutts_> unless perhaps we parameterised by a functor and used Id in some places and Flag in others
16:11:31 <dcoutts_> but even that's not very nice
16:11:51 <MarcWeber> dcoutts_: You are right.. It's just: I didn't know it's safe to assume that defaultConfigFlags is really used.. (but this makes sense) ..
16:11:59 <laura85> dibblego, i thought map (chr.((\x y -> mod y x) 255).(+42).ord) "Test" would do the job, but it doesn't ^^
16:12:09 <dibblego> laura85, why not?
16:12:45 <dcoutts_> MarcWeber: and the thing is, in other cases it's not used, eg in cabal-install we do not apply the defaults we pass the 'diff' through
16:13:24 <laura85> dibblego, try it in Hugs. it returns some weird characters like \Esc etc.
16:13:26 <MarcWeber> dcoutts_: ok, Then the only way is learn how it works :)
16:13:32 <MarcWeber> I've done so now
16:13:33 <dibblego> > map (chr.((\x y -> mod y x) 255).(+42).ord) "Test"
16:13:34 <lambdabot>  "~\143\157\158"
16:13:56 <dcoutts_> MarcWeber: if you'd like to add any documentation, please do, it'd be much appreciated
16:14:20 <dibblego> laura85, clearly your function is not doing what you want it to do; so what do you want it to do?
16:14:41 <dcoutts_> MarcWeber: I agree it's particularly annoying for the verbosity flag since we use that all over the place
16:14:41 <MarcWeber> dcoutts_: what about -- always defined in Setup.[l]hs then?
16:14:49 <dcoutts_> MarcWeber: yep
16:15:12 <laura85> dibblego, my function, do you mean: chr.((\x y -> mod y x) 255).(+42).ord ? (that's a given example)
16:15:26 <dcoutts_> MarcWeber: my preferred solution for that is not to pass the verbosity flag at all but work within a monad that logs all actions
16:15:40 <dibblego> laura85, sure, what are you trying to achieve?
16:15:41 <BoudewijnEctor> MarcWeber, what's wrong with Utrecht?
16:16:06 <MarcWeber> BoudewijnEctor Nothing. It's wrong because it's to far away to jump in and listen to your talk :)
16:16:11 <laura85> dibblego, encrypt and decrypt a string
16:16:13 <BoudewijnEctor> LOL
16:16:19 <dibblego> laura85, yes, but how?
16:16:29 <BoudewijnEctor> MarcWeber, I'm just a 1st year msc student, so don't expect nice stuff he
16:16:40 <BoudewijnEctor> and it's just for about 15 minutes, but i will send you the sheets
16:16:46 <dibblego> laura85, are you trying to write the inverse of your given function?
16:16:46 <MarcWeber> BoudewijnEctor: And it would be much fun to join on weekends to hack on nix :)
16:17:00 <laura85> dibblego, yup
16:17:16 <BoudewijnEctor> MarcWeber, I'm planning to do so, but I'm currently recovering from a Pfeiffer's disease infection
16:19:47 <cjb> oh, mono
16:19:50 <dibblego> laura85, you're just adding 42 to each character; simply subtract 42 again
16:20:07 <cjb> I thought maybe Pfeiffer's disease was a codeword for eating too much spicy food the night before
16:20:14 <dibblego> > map (\c -> chr (ord c - 42)) "~\143\157\158" -- laura85
16:20:15 <lambdabot>  "Test"
16:20:59 <laura85> dibblego, sure, but that's just an example for f. what if f is something else?
16:21:25 <dibblego> laura85, then you'll have to write a different inverse?
16:21:49 <opqdonut> :)
16:22:57 <dmwit> Best way to get a Word32 to print as signed?
16:23:07 <dmwit> fromIntegral :: Word32 -> Int, or is there something better?
16:23:28 <olsner> hm, show . fromIntegral sounds like the easiest way
16:23:29 <dibblego> laura85, are you trying to write an inverse for the general bijection?
16:23:42 <dmwit> ok
16:23:55 <augustss> dmwit: Int32 might be a safer choice to convert to
16:24:02 <dmwit> Ah, good idea.
16:24:15 <dmwit> ?index Int32
16:24:15 <lambdabot> Data.Int, Foreign
16:24:18 <augustss> dmwit: and show . fromIntegral will not default to the right type
16:24:19 <hpaste>  DukeDave pasted "ByteString.readFile to Data.Map" at http://hpaste.org/6268
16:24:26 <laura85> dibblego, yes
16:24:34 <mauke> apply f 255 times
16:24:36 <dmwit> augustss: Right, I gave an explicit type annotation for it. =)
16:25:01 <mauke> well, 254
16:25:37 <dmwit> mauke: That fails for things with a cycle-length of, say, 7, right?
16:25:59 <dmwit> i.e. if my bijection permutes the first seven elements and leaves the rest alone?
16:26:09 <mauke> hmm, right
16:26:24 <smg> @pl test = \x -> \y -> \z -> x + y + z
16:26:24 <lambdabot> test = ((+) .) . (+)
16:26:32 <smg> hi mauke
16:26:44 <dmwit> > foldr1 lcm [1..255] -- rather a large number of iterations
16:26:44 <lambdabot>  8337245403447921335829504375888192675135162254454825924977726845769444687965...
16:26:54 <davidL> is there a simple way to remove all HTML tags from a bytestring?
16:26:54 <lambdabot> davidL: You have 1 new message. '/msg lambdabot @messages' to read it.
16:27:05 <dmwit> ?where tagsoup
16:27:05 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/tagsoup/
16:27:22 <smg> dmwit: hehe
16:27:28 <davidL> thank you dmwit!
16:32:48 <smg> lambdabot: how are you?
16:34:24 <dmwit> @vixen how are you?
16:34:24 <lambdabot> i am wonderful, thanks for asking!
16:34:41 <smg> haha
16:34:47 <smg> this really works nice
16:34:49 <smg> @vixen how are you?
16:34:49 <lambdabot> i'm good, you?
16:34:55 <smg> @vixen dito
16:34:56 <lambdabot> f
16:35:00 <smg> :]
16:36:12 <dmwit> Garbage in, garbage out. =)
16:37:54 <dmwit> Oh, man, this would have been so much nicer in the Writer monad instead of State.
16:38:05 <smg> dmwit: yeah EVA
16:38:40 <dmwit> But I'd need to know how many things have been written so far, so I guess I have to use State after all.
16:38:43 <dmwit> bummer =/
16:41:30 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/6269
16:41:41 <seaa> hellow again ;p
16:41:43 <seaa> http://hpaste.org/6269
16:41:51 <seaa> any help with this bug would be tremendously nice
16:42:47 <dmwit> Check the type of (:) vs (++).
16:42:49 <dmwit> :t (:)
16:42:50 <lambdabot> forall a. a -> [a] -> [a]
16:42:52 <dmwit> :t (++)
16:42:53 <lambdabot> forall m. (Monoid m) => m -> m -> m
16:42:58 <mauke> lolpwnd
16:42:58 <dmwit> bah
16:43:03 <mauke> :t (Prelude.++)
16:43:03 <lambdabot> forall a. [a] -> [a] -> [a]
16:43:13 <dmwit> Does that help?
16:43:25 <seaa> sec
16:44:05 <dcoutts_> @seen ndm
16:44:05 <lambdabot> I saw ndm leaving #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 30m 8s ago, and .
16:44:17 <dons> oh DukeDave, can you try the darcs version of bytestring?
16:44:41 <dmwit> <3
16:44:42 <seaa> dmwit, yes, I think so ;p
16:44:44 <dons> there was an issue to do with very slow Maps that got solved recently
16:44:47 <seaa> gonna try it out a bit! thx for now
16:44:50 <dmwit> EDSL for Mips programming.
16:45:10 <dcoutts_> @tell ndm even when we use the H98 bundled ReadP it turns out we cannot make cabal work with hugs without the -98 flag because Data.Version has a dep on the non-H98 ReadP module :-(
16:45:10 <lambdabot> Consider it noted.
16:47:57 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/6270
16:48:06 <seaa> dmwit
16:48:09 <seaa> can u take a loot at that one?
16:48:10 <BMeph> Ha-ha! Cale Strikes Again! :)
16:48:27 <DukeDave> dons: No, I'll grab it no
16:48:28 <Cale> What?
16:48:29 <DukeDave> *now
16:48:31 <mauke> seaa: apparently s is not a list of strings
16:48:55 <BMeph> "[16:43]	<dmwit>	:t (++) [16:43]	<lambdabot>	forall m. (Monoid m) => m -> m -> m
16:49:00 <dmwit> (try [s])
16:49:02 <Cale> So?
16:49:23 <BMeph> So, you Struck Again! :)
16:49:26 <dmwit> > (0, 0) ++ (3, 5)
16:49:26 <lambdabot>  Add a type signature
16:49:30 <Cale> uh, okay
16:49:31 <dmwit> ?
16:49:41 <dmwit> > (0, 0) ++ (3, 5) :: (Int, Int)
16:49:41 <lambdabot>   add an instance declaration for (Monoid Int)
16:49:41 <lambdabot>     In the expression: (0, 0) ...
16:49:43 <Cale> I suppose it has a different type than it usually would :)
16:49:59 <dmwit> What, no instance for Monoid Int?
16:50:02 <Cale> > (Sum 0, Sum 0) ++ (Sum 3, Sum 5)
16:50:03 <lambdabot>  (Sum {getSum = 3},Sum {getSum = 5})
16:50:08 <Cale> > (Sum 10, Sum 0) ++ (Sum 3, Sum 5)
16:50:09 <lambdabot>  (Sum {getSum = 13},Sum {getSum = 5})
16:50:19 <dmwit> Oh, there are many Monoids for ints, huh?
16:50:31 <Cale> > (Sum 10, Product 0) ++ (Sum 3, Product 5)
16:50:31 <lambdabot>  (Sum {getSum = 13},Product {getProduct = 0})
16:50:34 <dmwit> > (Product 10, Product 3) ++ (Product 1, Product 1)
16:50:34 <lambdabot>  (Product {getProduct = 10},Product {getProduct = 3})
16:50:39 <dmwit> Yeah, okay.
16:50:42 <smg> hey Cale what's up? :]
16:50:45 <Cale> hey
16:50:46 <dmwit> At least the names are consistent. =)
16:51:19 <mauke> :t Sum
16:51:20 <lambdabot> forall a. a -> Sum a
16:51:21 <Cale> > sortBy (comparing length ++ compare) (words "this is a bunch of words")
16:51:22 <lambdabot>  ["a","is","of","this","bunch","words"]
16:51:43 <dmwit> Mmm, that's nice.
16:51:51 <DukeDave> That is stunning
16:52:05 * dmwit stares for a bit
16:52:23 <dolio> > EQ ++ LT
16:52:24 <lambdabot>  LT
16:52:29 <Cale> Monoids are beautiful, our notation for them should be equally beautiful.
16:52:32 <dolio> > EQ ++ GT
16:52:33 <lambdabot>  GT
16:52:35 * smg needs to figure out that Expression of Cale
16:52:48 <dmwit> :t EQ
16:52:48 <Cale> smg: Note that ++ is now mplus in lambdabot
16:52:49 <lambdabot> Ordering
16:52:57 <dmwit> > mempty :: Ordering -- EQ
16:52:58 <lambdabot>  EQ
16:52:58 <smg> Cale: oh
16:53:03 <smg> @type (++)
16:53:04 <lambdabot> forall m. (Monoid m) => m -> m -> m
16:53:08 <Cale> er, mappend rather
16:53:17 <dolio> > LT ++ GT
16:53:18 <lambdabot>  LT
16:53:23 <Pseudonym> > GT ++ LT
16:53:24 <lambdabot>  GT
16:53:25 <smg> Cale you keep me on learning :)
16:53:29 <smg> now i need to learn Monoid :]
16:53:49 <dmwit> Nothing to learn, there's an identity and a (++).
16:53:54 <mauke> @src Monoid
16:53:55 <lambdabot> class Monoid a where
16:53:55 <lambdabot>     mempty  :: a
16:53:55 <lambdabot>     mappend :: a -> a -> a
16:53:55 <lambdabot>     mconcat :: [a] -> a
16:54:06 <Cale> and ++ is associative, that is (x ++ y) ++ z = x ++ (y ++ z)
16:54:14 <dmwit> mconcat = foldr (++) mempty
16:54:22 <smg> i see
16:54:27 <Cale> In lambdabot, the identity is called zero, in the libraries, it's called mempty.
16:54:34 <dmwit> > zero
16:54:35 <lambdabot>  ()
16:54:36 <smg> interesting
16:54:40 <smg> > () == zero
16:54:40 <roconnor> > exp (exp (exp 1))
16:54:41 <dmwit> Neat!
16:54:41 <lambdabot>  True
16:54:41 <lambdabot>  3814279.104760214
16:54:45 <mauke> > () ++ () ++ ()
16:54:46 <lambdabot>  ()
16:54:49 <Cale> (I renamed some things, so that it's nicer to use)
16:54:55 <monochrom> > zero :: Int
16:54:55 <lambdabot>   add an instance declaration for (Monoid Int)
16:54:55 <lambdabot>     In the expression: zero ::...
16:54:55 <smg> Cale: hehe
16:55:00 <dmwit> > zero ++ LT
16:55:00 <lambdabot>  LT
16:55:02 <smg> > [] == null
16:55:03 <dmwit> > zero :: Sum
16:55:03 <lambdabot>  Couldn't match expected type `[a]'
16:55:03 <lambdabot>      `Sum' is not applied to enough type arguments
16:55:03 <lambdabot>     Expected kind `?', but...
16:55:08 <smg> > [] == null []
16:55:08 <Cale> > zero ++ [1,2,3]
16:55:09 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Bool'
16:55:09 <lambdabot>  [1,2,3]
16:55:10 <monochrom> > zero :: Maybe Int
16:55:10 <lambdabot>   add an instance declaration for (Monoid Int)
16:55:10 <lambdabot>     In the expression: zero ::...
16:55:21 <monochrom> > zero :: [Int]
16:55:22 <lambdabot>  []
16:55:27 <Cale> > zero (First (Maybe Int))
16:55:28 <lambdabot>   Not in scope: data constructor `Int'
16:55:31 <roconnor> > exp 1000
16:55:31 <dmwit> > zero :: Maybe (Sum Int)
16:55:32 <lambdabot>  Infinity
16:55:32 <lambdabot>  Nothing
16:55:34 <monochrom> > zero :: Coke
16:55:35 <lambdabot>   Not in scope: type constructor or class `Coke'
16:55:50 <Cale> > zero :: (First Int)
16:55:51 <lambdabot>  First {getFirst = Nothing}
16:55:51 <roconnor> > log (1+(log ( 1+ log ( 1+ log (1 + pi)))))
16:55:52 <lambdabot>  0.49073150272758187
16:55:59 <Cale> There we are
16:56:03 <dolio> @type concat
16:56:04 <lambdabot> forall a. [[a]] -> [a]
16:56:09 <dmwit> ?index First
16:56:09 <lambdabot> bzzt
16:56:17 <Cale> :t First
16:56:18 <lambdabot> forall a. Maybe a -> First a
16:56:32 <shepheb> I have an interactive network app (specialized text chat) that I'm trying to strap a Gtk2Hs GUI to. but it seems that my other threads are not running.
16:56:33 <dmwit> First is just a newtype around Maybe or something like that?
16:56:39 <Cale> > First (Just 4) ++ First (Just 5)
16:56:40 <lambdabot>  First {getFirst = Just 4}
16:56:50 <Cale> > Last (Just 4) ++ Last (Just 5)
16:56:51 <lambdabot>  Last {getLast = Just 5}
16:56:51 <dmwit> > Second (Just 4) ++ Second (Just 5)
16:56:52 <lambdabot>   Not in scope: data constructor `Second'
16:56:57 <dmwit> got it
16:57:03 <dolio> Yeah, because the (Monoid (Maybe a)) just lifts the monoid on a.
16:57:13 <dmwit> Oh!
16:57:15 <dmwit> interesting
16:57:20 <mauke> @src First
16:57:21 <Cale> > Just [1,2,3] ++ Nothing
16:57:27 <lambdabot> Source not found. Just try something else.
16:57:29 <lambdabot>  Just [1,2,3]
16:57:30 <dmwit> It's like a "deep" Monoid vs. a "shallow" monoid for Maybe.
16:57:33 <Cale> > Just [1,2,3] ++ Just [4,5]
16:57:33 <dolio> > Just [1,2,3] ++ Just [4,5,6]
16:57:34 <lambdabot>  Just [1,2,3,4,5]
16:57:35 <lambdabot>  Just [1,2,3,4,5,6]
16:57:59 <mauke> > zero :: Product Int
16:58:00 <lambdabot>  Product {getProduct = 1}
16:58:01 <Cale> There are so many monoid instances, that we need lots of newtypes to manage them all :)
16:58:02 <dcoutts_> shepheb: you either have to set up cooperative scheduling using a simple one line trick or use the -threaded rts and then make really really sure that you never do GUI actions from any thread except the one that called mainGUI
16:58:16 <mauke> > getProduct zero
16:58:16 <lambdabot>  1
16:58:33 <shepheb> dcoutts_: I'll take door number one. what's this one-liner?
16:58:53 <dmwit> > repeat (getProduct zero) -- yet another [1,1..]
16:58:53 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
16:59:15 <shepheb> dcoutts_: oh, this has to work for Linux and Windows, in case that matters.
16:59:18 <dcoutts_> shepheb: see the gtk2hs FAQ, I can't remember off the top of my head, it's something like timeoutAdd (yield >> return True) 50
16:59:27 <smg> hehe
16:59:34 <dcoutts_> shepheb: no problem
16:59:37 <shepheb> dcoutts_: okay, thanks.
17:00:08 <dmwit> We should have a page where we show different ways to get [1,1..], sorted by length.
17:00:09 <dmwit> Just for fun.
17:00:39 <mauke> all 1's have the same length
17:01:30 <Cale> > length "[1,1..]" == length "repeat (getProduct zero)"
17:01:30 <lambdabot>  False
17:01:53 <dmwit> A 1 that is not cold is hardly a 1 at all.
17:02:09 <Saizan> :t zero
17:02:10 <lambdabot> forall m. (Monoid m) => m
17:02:19 <dmwit> zero = mempty
17:02:20 <dejones> Cale: Do you know the motivation behind $ being included in the Haskell syntax?
17:02:28 <dmwit> It isn't!
17:02:32 <Cale> dejones: It's not included in the Haskell syntax
17:02:33 <dmwit> It's in the libraries. ;-)
17:02:38 <smg> mh, haskell article in english wikipedia is impolite
17:02:38 <dejones> Cale: lol
17:02:52 <dejones> Hmm.. take it out of the libraries! :P
17:03:00 <Cale> dejones: Why?
17:03:02 * MyCatVerbs thinks it would be kinda nice if $ was included in the Haskell syntax.
17:03:09 <dejones> Hmm... I get frustrated with "multiple ways of saying the same thing" kinda syntax...
17:03:10 <Cale> dejones: I would say flip its associativity.
17:03:11 <shepheb> dcoutts_++ that worked, thanks!
17:03:20 <MyCatVerbs> Just so that you could use it for types. e.g. Maybe $ Maybe Foo, etc.
17:03:29 <mauke> TIMTOWTDI
17:03:40 <Cale> MyCatVerbs: Perhaps see TypeCompose
17:03:52 <dmwit> smg: where?
17:03:58 <mauke> type a :$ b = a b
17:04:03 <dolio> Cale: You should do that in lambdabot. That'll cause some nice hard to track failures for people. :)
17:04:04 <dejones> Cale: I guess at times I am frustrated with Haskell because I find its syntax hard to read because of the multitude of $, !!, . \, >>> characters that don't really have intuitive meaning, but are included.
17:04:27 <Cale> dejones: They're just functions.
17:04:29 <mauke> only \ is built in
17:04:36 <dejones> mauke: That makes me happy.  :)
17:04:38 <MyCatVerbs> Cale: !!!
17:04:46 <MyCatVerbs> Cale: and this is implemented as a library!?
17:04:47 <smg> http://en.wikipedia.org/wiki/Haskell_%28programming_language%29#Criticism
17:04:50 <lambdabot> http://tinyurl.com/y4aqxv
17:04:50 <Cale> MyCatVerbs: yeah.
17:05:15 <Cale> MyCatVerbs: With the limitations that brings
17:05:22 <monochrom> You can write your own Prelude and use Russian words instead of symbols, you know?
17:05:47 <MyCatVerbs> monochrom: not worth it unless you're going to use Russian swear words.
17:05:55 <dejones> lol
17:06:46 <matthew-_> sorry, what's flawed now?
17:06:48 <dejones> Cale, smg: I guess I find it very tedious to have to lookup in the API what the meaning is of these cryptic combinations of characters.
17:06:59 <Cale> dejones: You only have to learn them once :)
17:07:08 <monochrom> f `` x = f x.  Now you can write take 10 `` map f `` [1..10] instead of the "oh-so-unreadable-frustrating" take 10 $ map f $ [1..10]
17:07:09 <Cale> f . g . h $ x = f (g (h x))
17:07:34 <Cale> monochrom: Don't forget the infix decl!
17:07:36 <dejones> Cale: Yeah..  I do really like Haskell otherwise; strongly typed, lazy evaluation, purely functional, woohoo!
17:07:39 <mauke> monochrom: C is uppercase
17:07:48 <monochrom> Ooops.
17:08:26 <Cale> dejones: One thing which I wouldn't recommend is abusing $ by chaining multiple $'s together. You can always replace the first n-1 of them with function composition, which is an all around nicer operator.
17:08:47 <Cale> (.) is an associative operation
17:08:52 <MyCatVerbs> Cale: huh. I do that all the time.
17:09:00 <Cale> That is,  f . (g . h) = (f . g) . h
17:09:06 <MyCatVerbs> Cale: stringing $'s together, I mean.
17:09:10 * MyCatVerbs fires up vim...
17:09:21 <Cale> So there are effectively more subexpressions in f . g . h $ x than in f $ g $ h $ x
17:09:30 <smg> dejones: ok :)
17:09:32 <Cale> For instance, g . h is meaningful, but g $ h won't be.
17:09:55 <Cale> This helps you get thinking in the right way, and makes working with the code somewhat easier.
17:09:58 <whee> is there a permutations function in one of the libraries included with ghc?
17:10:21 <Cale> whee: Unfortunately not.
17:10:25 <dejones> Cale: Yeah, but why have (.) and ($) in the language?  They seem to accomplish the same thing...?
17:10:33 <Cale> It'll also make it easier for me to push my agenda of flipping the associativity of $ if people don't chain $'s like that :)
17:10:37 <dejones> lol
17:10:41 <Cale> dejones: They have different types
17:10:44 <Cale> :t (.)
17:10:45 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
17:10:46 <Cale> :t ($)
17:10:47 <lambdabot> forall a b. (a -> b) -> a -> b
17:10:54 <cjb> > let pms xs n = foldM (map . flip (:)) [] $ replicate n xs
17:10:54 <lambdabot>  Parse error at end of input
17:10:56 <Cale> heh, that first one is generalised :)
17:10:56 <dolio> When will I be able to write 'foldl $ flip (:) $ []' in lambdabot? :)
17:11:07 <cjb> dolio: :)
17:11:08 <seaa> :t nub
17:11:09 <lambdabot> forall a. (Eq a) => [a] -> [a]
17:11:12 <dejones> Cale: Functor?
17:11:17 <seaa> omg, lambdabot is imba
17:11:20 <Cale> In Haskell 98, (.) :: (a -> b) -> (t -> a) -> (t -> b)
17:11:34 <Cale> :t fmap
17:11:35 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
17:11:36 <smg> seaa: imba = imbalanced?
17:11:41 <seaa> yes
17:11:51 <Cale> dejones: Functor defines that fmap operation
17:11:52 <monochrom> One person's "plain English" is another persons "Greek letters".
17:11:56 <Cale> dejones: It's a generalisation of map
17:11:58 <smg> hehe
17:12:01 <dejones> Cale: I like the Haskell98 version of (.)  :)
17:12:10 <Cale> dejones: It turns out that function composition is a special case of that.
17:12:16 <seaa> smg, and not in a bad way, but in the way gaming ppl uses it when they see something they think rock!
17:12:16 <dejones> ahh
17:12:32 <Cale> dejones: So I generalised it :)
17:12:36 <smg> seaa: you most play wow then :)
17:12:51 <seaa> I do :)
17:12:58 <Cale> seaa: Watch Pure Pwnage?
17:13:08 <seaa> haha, yes I have :D
17:13:19 <smg> hahaha i don't play games but nevermind :)
17:13:54 <smg> i give a pupil private lessons in math because he plays the whole day WOW and can't compute 5*5*5 with his brain -.-
17:14:12 <roconnor> > 5*5*5
17:14:12 <lambdabot>  125
17:14:21 <seaa> haha, I must admit your brain gets abit fuzzy from playing too much ;p
17:14:21 <roconnor> smg: 125
17:14:21 <smg> seaa: now i know what he means with "imba" :]
17:14:41 <dmwit> roconnor: Now 5^5^5.
17:14:50 <dmwit> I'll even give you 5^5 for free: 3125
17:14:55 <roconnor> > 5^5^5
17:14:55 <dmwit> ;-)
17:14:55 <lambdabot>  1911012597945477520356404559703964599198081048990094337139512789246520530242...
17:14:58 <smg> roconnor: yes that's the way he does it. he evaluates also 2+10 with a calculator :|
17:15:09 <roconnor> > 2+10
17:15:09 <lambdabot>  12
17:15:17 <smg> he would love lambdabot i guess haha
17:15:37 <ziman> > e^pi - pi
17:15:37 <lambdabot>  Add a type signature
17:15:46 <smg> > e
17:15:46 <lambdabot>  e
17:15:47 <monochrom> > e^pi - pi :: Expr
17:15:47 <lambdabot>  Add a type signature
17:15:55 <roconnor> dmwit: I'll send you 5^5^5 in a private message.
17:15:57 <smg> > exp pi - pi
17:15:57 <lambdabot>  19.999099979189474
17:15:59 <dolio> > getProduct . mconcat . replicate 3 $ Product 5
17:16:00 <lambdabot>  125
17:16:05 <monochrom> > exp pi - pi :: Expr
17:16:05 <ziman> > 2.718281828^3.1415926536-3.1415926536
17:16:06 <lambdabot>  exp pi - pi
17:16:06 <lambdabot>  Add a type signature
17:16:12 <dmwit> roconnor: =P
17:16:20 <smg> how about asking google?
17:16:26 <dmwit> > exp pi - pi :: Double
17:16:27 <lambdabot>  19.999099979189474
17:16:36 <seaa> I think the expr "imba" comes from when for example blizzard or any other gamecompany realeases a patch where some changes made a class "imbalanced" in a way that it was just too good, and "something that is too good" probably got connected with imba after that
17:17:37 <seaa> oh, sorry for disturbing btw :>
17:17:49 <Cale> dejones: It really is better to write f . g . h $ x than f (g (h x)), generally, since it prepares your mind for treating functions as values. You're not just repeatedly applying various functions to bits of data, you're constructing the function that you need by snapping together other functions, and then applying that.
17:17:55 <smg> http://www.google.com/search?q=%285%5E5%29%5E5
17:17:56 <lambdabot> Title: (5^5)^5 - Google Search
17:18:08 <smg> lambdabot also is awesome fast
17:18:14 <Cale> smg: Sometimes.
17:18:28 <smg> Cale: hehe
17:18:50 <seaa> http://www.google.com/search?hl=sv&q=%28%285%5E5%29%5E5%29%5E5&lr=
17:18:51 <lambdabot> Title: ((5^5)^5)^5 - Google-skning, http://tinyurl.com/yo9lp7
17:19:00 <seaa> it's quite fast lol :)
17:19:01 <dejones> Cale: I like the f . g syntax.  It it just like the f circle g syntax for math f ( g() )  --- the $ is what I find awkward.
17:19:03 <BMeph> I boggle - "the impossible happened!"
17:19:08 <mauke> > ((5^5)^5)^5
17:19:09 <lambdabot>  2350988701644575015937473074444491355637331113544175043017503412556834518909...
17:19:26 <Cale> dejones: Well, it's just function application, but really low precedence.
17:19:30 <Cale> @src ($)
17:19:30 <lambdabot> f $ x = f x
17:19:35 <smg> hehe
17:19:40 <BMeph> I found a Paul Graham quote I agree with! =8*O
17:19:43 <mauke> well, f . g . h $ x + 1 looks better than (f . g . h) (x + 1)
17:19:50 <dejones> BMeph: what quote is that?  ;)
17:20:01 <BMeph> dejones: "Design your product to please the users."
17:20:06 <dejones> :)
17:20:15 <Pseudonym> Because users like Arc.
17:20:21 <BMeph> ROFL!
17:20:28 <smg> BMeph: :]
17:20:29 <dejones> heh, do they?  ;)
17:20:45 <BMeph> Pseudonym: I think it's more like (drug) users like Arc... ;)
17:20:48 <dejones> well, I guess since Paul is possibly the only one using Arc.
17:21:10 <Pseudonym> Him and RTM.
17:21:33 <Pseudonym> The man who is most famous for one of the earliest Internet worms.
17:21:37 <dmwit> BMeph: Reminds me of that jmz quote, "Design your program as if it's the only thing between me and sex."  i.e. get the *@$# out of the way
17:21:45 <dejones> mauke: Interesting example.
17:21:55 <BMeph> Seriously, though, I think I'll need to examine Arc. I've always thought that Lisp would be more interesting if they could just have the macro system... ;p
17:22:01 <monochrom> Fortunately I'm in the business of telling my users the cold, hard truth rather than pleasing them using lies.
17:22:40 <smg> dejones: you are learning haskell atm?
17:22:49 <dejones> smg: Yea.
17:23:00 <smg> i see. ;-)
17:23:06 <dejones> Trying to become an advanced user very quickly.  ;)
17:23:19 <dejones> I have a Master's thesis to complete!
17:23:19 <dejones> heh
17:24:02 <wagle_home> BMeph, what do you mean "just have the macro system"?
17:24:19 <dejones> mauke, Cale: but why did they choose the $?  Does the $ have any mathematical significance or some other reference?
17:24:40 <dmwit> nah
17:24:41 <Cale> dejones: It's a convenient character which is on most keyboards?
17:24:48 <lispy> > reverse (map (+1) [1..3]) : [9..12]
17:24:48 <lambdabot>   add an instance declaration for (Enum [a], Num [a])
17:25:05 <EvilTerran> ?type (:)
17:25:06 <lambdabot> forall a. a -> [a] -> [a]
17:25:09 <EvilTerran> ?type (++)
17:25:10 <lambdabot> forall m. (Monoid m) => m -> m -> m
17:25:14 <lispy> > reverse map [1..4] : [9..12]
17:25:15 <lambdabot>  Couldn't match expected type `[a]'
17:25:15 <EvilTerran> wait what
17:25:15 <dejones> Cale: I guess so...
17:25:18 <lispy> > reverse [1..4] : [9..12]
17:25:18 <lambdabot>   add an instance declaration for (Enum [t], Num [t])
17:25:22 <EvilTerran> ?index (++)
17:25:22 <lambdabot> Data.List, Prelude
17:25:25 <basti_> i also see $ as a vertically oriented dividing structure, much like |
17:25:34 <lispy> > [1..3]
17:25:34 <Cale> EvilTerran: that's my doing :)
17:25:34 <lambdabot>  [1,2,3]
17:25:34 <EvilTerran> ... what did you guys do?
17:25:42 <wagle_home> > reverse (map (+1) [1..3]) ++ [9..12]
17:25:42 <EvilTerran> ah. IT WAS YOU.
17:25:43 <lambdabot>  [4,3,2,9,10,11,12]
17:25:43 <dmwit> > reverse [1..4] ++ [9..12]
17:25:44 <lambdabot>  [4,3,2,1,9,10,11,12]
17:25:44 <Cale> EvilTerran: I generalised a few things for fun :)
17:25:51 <Cale> Also note:
17:25:51 <monochrom> Supposedly U+00A0 "no-break space" is a better choice than $
17:25:52 <EvilTerran> > Nothing ++ Just 12
17:25:52 <lambdabot>  Add a type signature
17:25:53 <Cale> :t (.)
17:25:54 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
17:25:57 <wagle_home> ha!  wagle 1, dmwit 0!
17:26:04 <EvilTerran> ah no you le didn't
17:26:05 <dmwit> eh?
17:26:13 <lispy> > reverse (map (+1) [1..3]) : [[9..12]]
17:26:13 <lambdabot>  [[4,3,2],[9,10,11,12]]
17:26:24 <EvilTerran> > (+1) . [1..10]
17:26:25 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
17:26:26 <wagle_home> oh, thought you were correcting the same thing i was
17:26:28 <lispy> okay, so the reverse binds tighter than the (:)
17:26:31 <Cale> EvilTerran: ... is that an attempt at French?
17:26:38 <dmwit> wagle_home: dmwit 0, wagle_home 0 =P
17:26:47 <wagle_home> 8(
17:27:01 <dejones> Cale: f . g . (h x) I guess I find that more intuitive than f . g . h $ x
17:27:04 <dmwit> lispy: Prefix function application binds more tightly than anything else.
17:27:09 <dejones> Cale: they are equivalent, correct?
17:27:13 <Cale> dejones: not quite
17:27:21 <dejones> How so?
17:27:22 <dejones> :)
17:27:25 <Cale> dejones: (f . g . h) x would be the same as f . g . h $ x
17:27:45 <Cale> $ binds more weakly than .
17:27:51 <lispy> that and ($) is allergic to higher rank types
17:28:01 <dejones> lispy: allergic? lol
17:28:04 <EvilTerran> Cale, not really, no :P
17:28:08 <BMeph> seaa: lambdabot's not imba - she's OP! :)
17:28:26 <seaa> BMeph, haha overpowered :)
17:28:37 <lispy> dejones: It gets a terrible rash in the type checking stage and goes home :)
17:28:49 <dejones> lispy: interesting..
17:28:57 <dejones> then why use $?  ;)
17:29:01 <DukeDave> dons: Using bytestring-0.9.0.4 from darcs, same problem :|
17:29:07 <smg> dejones: why not?
17:29:11 <lispy> dejones: because you're usually not using higher rank types :)
17:29:15 <Cale> dejones: A useful mnemonic is that whenever there's a $, it's like the stuff on the left and on the right are in parens.
17:29:15 <dejones> smg: bc it has a rash!
17:29:36 <Cale> dejones: Parens are sometimes hard to follow, because the close paren might be far away from the opening paren.
17:29:41 <Cale> For example,
17:29:52 <dons> DukeDave: can you try 0.9.0.5 from darcs?
17:29:56 <Cale> forM [1..10] $ \x -> do ...
17:30:01 <BMeph> I say, Lisp would be much more constructive without set, atom, quote, car, cdr... ;)
17:30:02 <smg> dejones: rephrase :)
17:30:09 <smg> @type forM
17:30:10 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
17:30:15 <BMeph> seaa: :)
17:30:20 <dons> DukeDave: http://darcs.haskell.org/bytestring
17:30:22 <lambdabot> Title: Index of /bytestring
17:30:58 <EvilTerran> Cale, i saw it on an imagemacro of, er, i think it was gerard depardieu, aiming a gun at the camera
17:31:10 <dejones> smg: rash for $, you will run (yoda talk)
17:31:12 <dejones> hehe
17:31:21 <smg> lol :)
17:31:28 <smg> $ can be handy sometimes
17:31:34 <smg> and you have to type less :)
17:31:35 <BMeph> Cale: Maybe the whole "anti-Lisp" attitude is why $ is so popular - "use as few ()'s as possible" :)
17:31:42 <DukeDave> dons: I just did  'darcs get --partial http://darcs.haskell.org/bytestring' and got 9.0.4    Is there something I'm missing?
17:31:45 <smg> BMeph: haha lol
17:31:46 <Cale> BMeph: yeah
17:31:47 <dejones> BMeph: maybe..
17:31:59 <Cale> Too many parens are bad.
17:32:00 <dolio> Actually, $ doesn't save you any typing/line length.
17:32:04 <BMeph> Er, rather "as few ('s and )'s..."
17:32:07 <dejones> I guess I find the () useful, if used in moderation...
17:32:09 <smg> the parentheses in lisp _can_ be evil
17:32:12 <mauke> EvilTerran: jean reno
17:32:22 <Cale> dolio: But it *does* save you from having to find which paren matches.
17:32:23 <smg> i don't want to have excess parentheses
17:32:28 <dolio> Yeah.
17:32:29 <dejones> Thanks for the $ clarification everyone.  :)
17:32:35 <dejones> Always a pleasure asking questions in here.
17:32:36 <EvilTerran> mauke, ah, yes. him too.
17:32:39 * dcoutts_ manages to use cabal-install to install filepath and Cabal for hugs
17:32:46 <EvilTerran> i think i've seen both, but that's the well-known version
17:32:49 <dolio> Although, I guess if ( and ) count as two keys each, it saves typing.
17:33:13 <BMeph> '$' is for people who scream out in fear, when they see: " parse error (possibly incorrect indentation)"
17:33:18 <monochrom> @quote plain
17:33:19 <lambdabot> Baughn says: [I] once explained monads to a non-programmer. "And? What's so hard about that?"
17:33:38 <monochrom> @file
17:33:39 <lambdabot> Maybe you meant: dice figlet free time
17:33:44 <monochrom> @quote file
17:33:44 <lambdabot> ghc says: Splices are not allowed in hs-boot files
17:33:48 <lispy> @free time
17:33:49 <lambdabot> Extra stuff at end of line in retrieved type "Not in scope: `time'\n\n"
17:34:17 <monochrom> @quote text
17:34:17 <lambdabot> Cale says: GADT pattern match in non-rigid context. There are prescriptions available for that sort of thing.
17:34:32 <dejones> Cale: More advanced topic time...  Monads vs Uniqueness types.  Go!  :)
17:34:33 <dejones> lol
17:34:33 <monochrom> @quote plain*text*file
17:34:33 <lambdabot> No quotes match.
17:34:41 <monochrom> @quote plain.*text.*file
17:34:41 <lambdabot> No quotes match. My mind is going. I can feel it.
17:34:47 <Cale> dejones: They're orthogonal.
17:35:11 <monochrom> They are friends.
17:35:24 <EvilTerran> Cale, well, they're definitely not parallel, but i wouldn't say they're quite orthogonal...
17:35:25 <Cale> dejones: They can both be used to handle I/O in a lazy functional language, but that's where the similarity ends, pretty much.
17:35:25 <dibblego> they're at a right-angle to each other
17:35:34 <EvilTerran> they do serve some of the same purposes
17:35:49 <Cale> One of the same purposes.
17:35:53 <dejones> Why might one be better than the other?
17:36:17 <EvilTerran> yeah, IO; but that's a pretty big purpose, seeing as we throw in stuff like immutable objects and RNG and whatnot
17:36:20 <Cale> dejones: Uniqueness types give you a way to say "this function parameter is used exactly once in the body of this function"
17:36:54 <Cale> dejones: Monads are a way to design combinator libraries such that they have a common interface, and can share generic control structures.
17:37:28 <Cale> Uniqueness types help the compiler to optimise code, because it can prove that a mutation-based implementation is safe.
17:37:49 <dolio> Monads suck and uniqueness types rule.
17:37:53 <dejones> lol
17:37:56 <Cale> They're pretty different concepts.
17:37:57 * dolio takes off his ayrnieu hat.
17:38:58 * Maddas steals dolio's hat
17:39:04 <dejones> Cale: "mutation-based implementation is safe" --- what do you mean by safe in this context?
17:39:42 <Cale> dejones: Suppose you have a recursive function, I'll use factorial as a simple example to start with.
17:39:47 <dejones> Ok
17:39:55 <Cale> We might write a tail recursive factorial like this:
17:40:43 <Cale> fac n = fac' 1 n where fac' k 0 = k; fac' k n = fac' (k*n) (n-1)
17:41:33 <Cale> It's safe for the compiler to implement this as a loop, with single variables for k and n which just get mutated as the computation proceeds.
17:42:29 <Cale> However, if there are multiple recursive calls, things are different. Let's look at the non-tail-recursive fibonacci function:
17:42:44 <Cale> fib 0 = 0; fib 1 = 1; fib n = fib (n-1) + fib (n-2)
17:43:22 <Cale> If the compiler tried to implement this by mutating n before calling fib, then n would have the wrong value by the time the second recursive call was made.
17:43:48 <gwern> 'astrolabe: there are points in writing CS programs when I would have literally killed siblings for a debugger, even to the point were I tried Hat!!!' <-- is Hat really that awful?
17:44:42 <Cale> gwern: It's not very compatible with extensions and random libraries you might be using.
17:44:57 <Cale> gwern: So you often have to transform the hell out of your program to use it.
17:46:19 <monochrom> Why would CS programs need a debugger?  Note it is not real-world programs.
17:47:25 <gwern> Cale: so it'd be easier to debug by print statements than use hat?
17:47:26 <Cale> monochrom: People don't magically stop making mistakes when they're not making money.
17:47:51 <gwern> (does hat even still work? should I put it on my todo list?)
17:48:08 <Cale> gwern: I'm pretty sure it still works.
17:48:30 <monochrom> I did not say mistakes are absent in CS programs.
17:48:34 <gwern> Cale: does it offer anything the ghci debugger doesn;t?
17:48:35 <Cale> gwern: I usually just go with Debug.Trace, if that. GHCi is usually more debugger than I need.
17:48:41 <Cale> Yes, it does.
17:48:49 <gwern> monochrom: a good cs program is correct by construction! :)
17:49:12 <dejones> Cale: http://en.wikipedia.org/wiki/Uniqueness_type --- Looking at that example, how does uniqueness typing enforce that f(a) never occurs again if you change a?  Does it keep track of the initial f(a) call and what a's value was?
17:49:12 <lambdabot> Title: Uniqueness type - Wikipedia, the free encyclopedia
17:49:19 <monochrom> The way you go about writing CS programs is:
17:49:21 <Cale> http://www.haskell.org/hat/
17:49:21 <lambdabot> Title: Hat - the Haskell Tracer
17:49:33 <Cale> dejones: a can only be used once.
17:49:53 <monochrom> 0. You write it with preconditions, postconditions, assertions, invariants, variants...  And use those to prove your program correct.  (I am not done yet.)
17:49:59 <Cale> dejones: That is, the uniqueness type means that a can literally occur only once in the body of the function.
17:50:01 <gwern> @where hat
17:50:01 <lambdabot> http://www.haskell.org/hat/
17:50:10 <monochrom> 1. Type it into the computer.  Add all those assertions.
17:50:16 <monochrom> 2. Run the program.
17:50:28 <dejones> 3. Computer melts.
17:50:34 <monochrom> 3. Marvel at all the reports of assertion violations despite you proved it correct.
17:50:35 <dcoutts_> 4. ???
17:50:44 <bd_> dejones: No, that's step 0.5: Programmer's brain melts
17:50:55 <dejones> bd_: How true.
17:51:00 <dcoutts_> 5. profit
17:51:07 <dcoutts_> and 4 was use hat :-)
17:51:10 <dejones> 6. Provide poor support.
17:51:15 <bd_> And by programmer, I mean math grad student, because a mere programmer wouldn't be able to prove correctness :)
17:51:21 <dejones> lol
17:51:22 <monochrom> But since you have a complete trace of assertion violations, you can quickly narrow down what goes wrong.  No debugger.
17:51:33 <bd_> (neither could the grad student, mind you...)
17:51:50 <dejones> bd_: Math grad-student could probably fake it better, at least.  ;)
17:52:27 <bd_> Oh, sure, they know all the big words. :)
17:52:30 <bd_> and the funny symbols, can't forget those
17:52:45 <gwern> programming in CS: 1) create an all new dependently typed FP proof language, because there can never be too many; 2) write up a proof of your program 3) ??? 4) Publish!
17:53:21 <dejones> Cale: Do you know why Haskell uses Monads instead of Uniqueness typing?
17:53:53 <lispy> bd_: I'm dealing with that regularly with my masters actually.
17:54:06 <Cale> dejones: If it did use uniqueness types, we'd probably still use monads as well.
17:54:08 <monochrom> Anyway, I'm dead serious, and I don't understand why all of you just go "lol" as soon as I mention assertions, preconditions, postconditions, invariants...  all sound practices both in CS and in real world.
17:54:16 <lispy> bd_: I have a BS in math and I'm working on a MS in CS, and I find it very hard sometimes to prove any sort of correctness about the code I'm writing.
17:54:17 <dejones> Cale: Why still use monads?
17:54:27 <gwern> dejones: because monads were neater and more general than uniqueness types, and haskell likes neat things - witness the invention of type classes for haskell
17:54:31 <Cale> dejones: Because it gives you all the control structures in Control.Monad for free.
17:54:43 <Cale> :t sequence
17:54:44 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
17:54:45 <Cale> :t mapM
17:54:46 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
17:54:49 <Cale> :t foldM
17:54:50 <gwern> which I am told was a foolish thing to make standard since type classes weren't well understood when they were made part of haskell
17:54:50 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
17:54:53 <Cale> :t zipWithM
17:54:54 <lambdabot> forall a b (m :: * -> *) c. (Monad m) => (a -> b -> m c) -> [a] -> [b] -> m [c]
17:55:11 <dejones> hmm
17:55:20 <Cale> :t replicateM
17:55:21 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
17:55:35 <dejones> gwern, Cale: we get those control structures because of the generalness of Monads?
17:55:54 <Cale> dejones: Well, it's handy to share code between libraries.
17:56:00 <bd_> lispy: moreover, wouldn't the proof be essentially a program itself? Or at least something that could (if you don't mind minor things such as run-time) be converted into a program?
17:56:02 <dolio> It's because IO is a monad.
17:56:06 <dejones> Cale: Yes, it is.
17:56:12 <Cale> dejones: Monads are just a way to structure libraries so they can share some code.
17:56:21 <dolio> If you didn't have an IO monad, you'd have to write mapIO, zipWithIO, etc.
17:56:46 <lispy> bd_: Hmm...Well, in my case I'm trying to prove that the core of darcs maintains correctness wrt patch theory
17:56:47 <dolio> Or write it out manually every time.
17:56:50 <Cale> Or worse yet, have them be built in to the language.
17:56:59 <lispy> bd_: so, I don't know about this run-time aspect
17:57:07 <Cale> (Like is the situation with for-loops in most imperative languages.)
17:57:18 <lispy> bd_: I mean, it's completely impractical to hardcode one run
17:57:25 <bd_> lispy: well, my main concern is how do you prove that whatever you're trying to prove doesn't have bugs /itself/ :)
17:57:39 <bd_> If you try to prove that program X meets spec Y, you just shift where all the bugs are.
17:57:56 <lispy> bd_: ah, the type system is my prover and I leave it as an exercise to the GHC folks to prove that it's correct :)
17:58:12 <bd_> lispy: sure, but you might be proving the wrong thing :)
17:58:15 <kpreid> lispy: different problem
17:58:33 <lispy> bd_: yes and I have done that before.
17:59:02 <dejones> Cale: Fun stuff.  Off to do Haskell coding now.  You've helped enlighten my Haskell knowledge once again.
17:59:08 <dejones> Thank you everyone else too, of course.
17:59:14 <dejones> Too many of you to type!
17:59:15 <lispy> bd_: I can only use the type system to ensure that fundamental properties are obeyed most of the time.  Violating them takes more work than obeying them.  In pratical terms, it's a nice happy medium
17:59:19 <glen_quagmire> is clean lazy evaluated?
17:59:34 <glen_quagmire> it is.
17:59:37 <Cale> dejones: It's often assumed that Haskell uses monads for I/O because it has to, but that's not the case, any combinator library would work as well, we just recognised that our I/O library is a monad, and so it can share some code with other monads.
17:59:47 <dejones> glen_quagmire: yea
18:00:08 <bd_> wasn't there an implementation of IO using lazy lists in a very early version of Haskell? Or rather, an IO system built using lazy lists...
18:00:29 <Cale> http://www.haskell.org/haskellwiki/Monads_as_Computation -- this has a good part of my philosophical outlook on monads in it.
18:00:30 <lambdabot> Title: Monads as computation - HaskellWiki
18:00:42 <dejones> Cale: Yay more theory.  :)
18:00:45 <lispy> bd_: I'm not sure about lazy lists, I do think someone was talking about early version of haskell using CPS for IO
18:00:54 <glen_quagmire> > let cross l1 l2 = do {x <- l1; y <- l2; return (x,y)} in cross [1,2,3] "abc"
18:00:55 <lambdabot>  [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
18:01:00 <dejones> Cale: Another tutorial by you too.  ;)
18:01:01 <glen_quagmire> even list is monad in haskell
18:01:01 <Cale> (I wrote it more as a tutorial for monad-tutorial writers than as a monad tutorial directly :)
18:01:03 <dolio> The retrospective talks about a lazy stream and a continuation IO system.
18:01:04 <guenni> dejones: sry to ask but that statement suggests you're an insider?
18:01:22 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
18:01:23 <lambdabot>  [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2,...
18:01:27 <dejones> guenni: insider into what?
18:01:43 <Cale> > filterM (const [True,False]) [1,2,3]
18:01:44 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
18:01:45 <guenni> sry that was to Cale, I got confused
18:01:50 <dejones> lol
18:01:59 <Cale> guenni: Insider?
18:02:14 <guenni> Haskell insider?
18:02:15 <bd_> guenni: That's not what Cabal refers to ;)
18:02:15 <dejones> Cale: Insider trading!  Give me some stock tips.  :P
18:02:37 <Cale> dejones: All on red.
18:02:43 * lispy crosses fingers
18:02:53 <dejones> Cale: Hehe.  Isn't that Craps not Stocks?  ;)
18:02:58 <bd_> dejones: short nhc
18:02:59 <lispy> I just recorded what could be a very important patch, I hope all the tests work :)
18:03:12 <dejones> bd_: what about goog?
18:03:18 <dejones> short them too?
18:03:20 <Cale> dejones: These days, who can tell the difference?
18:03:21 <dejones> think they'll keep going down?
18:03:24 <dejones> Cale: lol, true
18:03:39 <bd_> dejones: the market does not behave rationally when google's involved :)
18:03:50 <guenni> Cale: so no then?
18:04:12 <glen_quagmire> > sequence_ [[1,2,3], [4]]  --boobies
18:04:13 <lambdabot>  [(),(),()]
18:04:20 <glen_quagmire> darn i fail.
18:04:36 <dejones> bd_: How very true that is... Google stock went down last quarter bc their 1.1 Billion in profit was less than expected by Wall-Street, lol.
18:04:41 <lispy> ?quote bottom
18:04:41 <lambdabot> EvilTerran says: you've got bottoms everywhere that'll explode if you look at them
18:04:50 <dejones> bd_: something crazy like that.. heh
18:05:04 <bd_> dejones: Those stocks don't give any dividends or control, so what's the point in buying them? >_>
18:05:18 <Maddas> Fame and fortune!
18:05:21 <bd_> just so you can sell them to someone else? Shouldn't the price, rationally speaking, spiral endlessly down?
18:05:27 <dejones> bd_: Heh, speculation?  ;)
18:05:27 <Cale> guenni: I'm not sure what you mean.
18:05:30 <monochrom> Andrew Gordon's PhD thesis is on functional I/O, the equivalence between stream, CPS, and monad.
18:05:46 <dejones> monochrom: url?
18:05:47 <guenni> Cale: a Haskell Language Designer?
18:05:57 <lispy> oh, well if stream is in there then lazy lists probably did work
18:06:17 <monochrom> I have a book form on my bookshelf.  You want a url of a picture of that?
18:06:18 <dejones> bd_: I do like value-based investing.  Dividends are nice... getting paid just to own the stock.  :)
18:06:40 <Cale> guenni: Not really. I'd like to make some changes :)
18:06:41 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/6272
18:06:56 <Cale> guenni: I spend more time thinking about the language than writing code in it.
18:07:15 * lispy wants to get Cale interested in hacking darcs
18:07:20 <guenni> well that comes close to what I meant Cale
18:07:45 <seaa> sry for announcing it
18:07:45 <dejones> monochrom: Negative.  :P  What's the actual title of the thesis?  Maybe I can find it...
18:07:45 <Cale> guenni: But you won't find my name on any of the Haskell Reports.
18:07:51 <seaa> didn't realize what it meant until now
18:08:08 <monochrom> Functional Programming and Input/Output
18:08:12 <guenni> and funny enough Cale it is my current approach to learning Haskell right now too
18:08:34 <dejones> monochrom: http://research.microsoft.com/~adg/Publications/default.htm
18:08:35 <lambdabot> Title: Andrew D. Gordon: Index of Publications
18:08:38 <dejones> :)
18:09:05 <dejones> ah well, off to do some work.
18:09:07 <dejones> cya everyone.
18:09:13 <lispy> that's a lot of publications
18:14:06 <Cale> guenni: You can find a list on http://www.haskell.org/haskellwiki/Language_and_library_specification
18:14:08 <lambdabot> Title: Language and library specification - HaskellWiki, http://tinyurl.com/2to3n6
18:15:59 <roconnor> dividends just rededuce the value of stock by the same amount.  They are (modulo tax nonsense) pointless
18:17:15 <wli> Not pointless if you're the one getting paid them.
18:17:53 <roconnor> yeah, but your stock drops in value by the amount you are paid, so it makes no difference.
18:18:17 <roconnor> I you want to take money out of your stock holdings, just sell some stock.
18:26:31 <wli> The value of the annuity (geometric series) tends to exceed the stock price, but anyway.
18:30:03 <roconnor> > cos 1
18:30:04 <lambdabot>  0.5403023058681398
18:30:34 <roconnor> > cos 1 - cos 0
18:30:35 <lambdabot>  -0.4596976941318603
18:31:08 <lispy> > sin 1 - sin 0
18:31:09 <lambdabot>  0.8414709848078965
18:31:20 <dmwit> > (sin 1 - sin 0) ^ 2
18:31:21 <lambdabot>  0.7080734182735712
18:31:22 <roconnor> > (-cos 1) - (-cos 0)
18:31:23 <swidgy> > 2 + 2
18:31:23 <lambdabot>  0.4596976941318603
18:31:23 <lambdabot>  4
18:31:47 <dmwit> > - cos 1 - -cos 0
18:31:47 <lambdabot>      precedence parsing error
18:31:47 <lambdabot>         cannot mix `(-)' [infixl 6] and prefix ...
18:31:51 <lispy> > (sin 1)^1 + (cos 0)^2
18:31:52 <lambdabot>  1.8414709848078965
18:31:57 <dmwit> > -cos 1 - (- cos 0)
18:31:58 <lambdabot>  0.4596976941318603
18:31:59 <lispy> > (sin 1)^2 + (cos 0)^2
18:32:01 <lambdabot>  1.708073418273571
18:32:06 <lispy> > (sin 0)^2 + (cos 0)^2
18:32:06 <lambdabot>  1.0
18:32:18 <lispy> oh, my HS math teacher wasn't lying!
18:32:29 <EvilTerran> @check \x -> (sin x)^2 + (cos x)^2 == 1
18:32:30 <lambdabot>  Falsifiable, after 0 tests: 1.0
18:32:35 <dmwit> > (sin x) ^ 2 + (cos x) ^ 2 :: Expr
18:32:36 <lambdabot>  sin x * sin x + cos x * cos x
18:32:39 <lispy> ?scheck \x -> (sin x)^2 + (cos x)^2 == 1
18:32:40 <lambdabot>   Failed test no. 1. Test values follow.: -0.5
18:32:50 <EvilTerran> @check \x -> sin x^2 + cos x^2 > 0.99
18:32:51 <lambdabot>  OK, passed 500 tests.
18:33:07 <EvilTerran> @check \x -> sin x^2 + cos x^2 > 0.999
18:33:08 <lambdabot>  OK, passed 500 tests.
18:33:13 <EvilTerran> @check \x -> sin x^2 + cos x^2 > 0.9999
18:33:14 <lambdabot>  OK, passed 500 tests.
18:33:20 <EvilTerran> ... i think i'm done
18:33:22 <lispy> ?scheck \x -> abs ((sin x)^2 + (cos x)^2 - 1.0) < 0.0001
18:33:22 <lambdabot>   Completed 79 test(s) without failure.
18:35:10 <lispy> ?scheck \x -> abs ((sin x)^2 + (cos x)^2 - 1.0) < 0.000001
18:35:11 <lambdabot>   Completed 79 test(s) without failure.
18:36:12 <dmwit> But... does you think that techmology will change the way we live?
18:36:38 <monochrom> Is techmology related to homology? :)
18:36:55 <dmwit> techmology is honology's big brosher
18:37:12 <monochrom> Technology changes the way I live.
18:37:58 <monochrom> 20 years ago I would not learn Haskell, even if it were present, simply because my computer couldn't possibly run ghc.
18:38:19 <monochrom> Now I even build ghc with itself without thinking.
18:39:16 <monochrom> 20 years go I had to pick and bring just two hours of music with me because it was in bulky cassettes.
18:39:46 <monochrom> 10 years go it was a bit better. I could pick and bring 4 hours of music because it was on CDs.
18:41:02 <monochrom> Now I don't pick.  I have already put my complete library of 10GB of mp3 files on my mp3 player.  I can bring all of them.  Then I choose some to listen to impromptu.  No "let me load up my player" just before I leave home.
18:42:56 <monochrom> 10 years ago I didn't IRC. Only network connection was by phone. Didn't want to hog the phone line.
18:43:07 <monochrom> Now I IRC too much.
18:43:57 <monochrom> 10 years ago I didn't watch movies at home.  Somehow I didn't like video tapes.
18:44:45 <monochrom> Now I buy and watch DVDs regularly.  And I feel very comfortable re-playing the same movie many times, knowing it doesn't cause the same kind of tear-and-wear as video tapes.
18:45:10 * joed never got why one would want to watch the same movie again...
18:45:40 <monochrom> I'm sure there are things you do and I don't understand.
18:45:52 <joed> monochrom: Fair point.
18:45:56 <Excedrin> dvd drives wear out
18:46:44 <dmwit> VHS wears out faster.
18:46:49 * BMeph uses Winamp Remote to listen to his misic at work
18:47:20 <monochrom> In the past I never used Post-it notes.  But just now I have installed Ubuntu 7.10, which comes with software Post-it notes.  I'm now beginning to use it generously.
18:48:29 <monochrom> BMeph: I don't actually listen to music when I work.  I listen when I'm on bus, subway, ...
18:49:47 <roconnor> monochrom: kubuntu?
18:49:49 <monochrom> (My brain has a mutex. When I'm working, the music is ignored.  I can play music fine but I don't hear it.)
18:50:08 <monochrom> GNOME.  The original Ubuntu.
18:50:11 <roconnor> I find I use Knotes on occasion.
18:50:12 <BMeph> monochrom: Fair enough. I usually read on the bus, but if I listen to music at the same time, I forget to get up at my stop.
18:51:15 <BMeph> That reminds me of - "Ubuntu: From an ancient African word, meaning 'I can't install Debian.'" ;)
18:51:24 <roconnor> @quote ubuntu
18:51:25 <lambdabot> ricky_clarkson says: Ubuntu, an ancient African word meaning "I can't configure Debian".
18:51:39 <joed> monochrom: that is a fair thing, the music, means you sorta focus actually.
18:51:51 <BMeph> QFT - nice. :)
18:52:04 <monochrom> I used to write alot in pen and paper, e.g., had great research ideas and I wrote wrote wrote.  Now I type them.
18:52:24 <lispy> monochrom: When I listen to music at work it is so I don't hear anything (works with talkative co-workers).
18:53:03 <joed> I used to have great results for some reason Listening to Metallica when I did penetration testing....
18:53:22 <monochrom> Yeah, I'm particularly pleased that I'm gifted in being able to ignore the environment.  Only thing that can interrupt me is Call of Nature, which is kind of annoying. :)
18:53:30 <joed> And I drive way to fast listening to Classical music
18:57:54 * dcoutts__ notes the existence of a new "Haskell consultant"
18:58:47 <dcoutts> that makes two: http://haskell.org/haskellwiki/Consultants
18:58:49 <lambdabot> Title: Consultants - HaskellWiki
18:59:17 <roconnor> ooh
18:59:19 <dcoutts> no heavyweights yet
18:59:29 <roconnor> I should bea consultant too!
18:59:42 <dcoutts> roconnor: go for it! :-)
18:59:59 <roconnor> I didn't know it was as easy as editing a wiki page.
19:00:03 <dcoutts> hah
19:00:16 <dcoutts> he does have a web page of sorts :-)
19:01:45 <lispy> Yes, sometimes GHC asks me about types and I usually just charge a flat rate for my time.  Haskell consulting is easy ;)
19:10:22 <whee> > liftM and . sequence $ map Just [True, True, True]
19:10:23 <lambdabot>  Just True
19:10:33 <whee> is there a better way to write that "liftM and . sequence" part?
19:11:36 <dolio> > liftM and $ mapM Just [True, True, Ture]
19:11:36 <lambdabot>   Not in scope: data constructor `Ture'
19:11:42 <dolio> > liftM and $ mapM Just [True, True, True]
19:11:43 <lambdabot>  Just True
19:12:36 <resiak> > and <$> mapM Just [True, True, True]
19:12:37 <lambdabot>  Just True
19:13:22 <lispy> > map Just [True, True, True]
19:13:23 <lambdabot>  [Just True,Just True,Just True]
19:13:32 <lispy> it's just TRUE TRUE TRUE!!
19:13:37 <whee> resiak: where is <$> defined?
19:13:45 <lispy> ?hoogle <$>
19:13:45 <lambdabot> Control.Applicative.(<$>) :: Functor f => (a -> b) -> f a -> f b
19:14:36 <whee> lots more to read about, thanks
19:15:01 <dolio> (<$>) is just fmap (liftM).
19:15:30 <dolio> > and `liftM` mapM Just [True, True, True]
19:15:30 <lambdabot>  Just True
19:16:07 <lispy> ?src (<$>)
19:16:07 <lambdabot> f <$> a = fmap f a
19:16:28 <lispy> dolio: Oh, I see what you meant
19:16:41 <lispy> dolio: I tohught you meant fmap liftM == <$>
19:16:47 <lispy> :t fmap liftM
19:16:48 <lambdabot> forall a1 r (m :: * -> *) (f :: * -> *). (Functor f, Monad m) => f (a1 -> r) -> f (m a1 -> m r)
19:17:08 <whee> I don't understand the difference between fmap and liftM
19:17:44 <lispy> whee: fmap is like map for functors.  liftM is fmap, but for Monads.
19:17:53 <dibblego> whee, nothing
19:18:25 <dolio> The difference is an artifact of the way the haskell 98 class hierarchy is arranged.
19:18:33 <lispy> Haskell '98 has a bit of oddness that monads are not automatically functors.  But, they really should be, which would remove the need for liftM
19:27:46 <dolio> @type Control.Monad.Identity.runIdentity . fmap liftM
19:27:47 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => Control.Monad.Identity.Identity (a1 -> r) -> m a1 -> m r
19:28:00 <shepheb> what's the canonical Gtk widget for pure Cairo drawing?
19:28:15 <dcoutts> shepheb: DrawingArea
19:29:22 <dcoutts> shepheb: see the gtk2hs cairo demos
19:30:58 <N3W5P4P3R> new saitek keyboard http://www.badjasmine.com/my-ex/index.php?key=c8oap3i5av537tu
19:49:23 <dons> mm, the industry page is looking pretty good
19:49:23 <dons>   http://haskell.org/haskellwiki/Haskell_in_industry
19:49:24 <lambdabot> Title: Haskell in industry - HaskellWiki
19:49:36 <dons> perhaps other consultants should add their names to the consultants page
19:50:09 <sethk> dons, can't hurt
19:52:21 * kfish commissions a consultant to write his thesis for him
19:53:26 <SamB> kfish: it's against the functional programmer's code of ethics to do that!
19:53:55 <Igloo> There's an interesting bias towards company names starting with letters close to the start of the alphabet. I wonder if that's because everyone's chosen a name that they hope to get near the start of lists with, or just concidence
19:54:24 <SamB> I like ZZT's name
19:54:36 <dmwit> SamB: Yeah, who actually writes these days?  I'd at least want to be allowed to type a thesis.
19:54:38 <sethk> Igloo, look in any business directory, you'll find it's not coincidence.  I don't know if it's effective, but it's intentional
19:54:41 <SamB> specifically chosen to come at the END of the alphabet and for no other reason
19:55:12 <dmwit> Not chosen in honor of ZZ Top?
19:55:13 <SamB> dmwit: you know perfectly well that that is not what I meant
19:55:22 <dmwit> yes
19:55:39 <dons> is this a haskell job? http://article.gmane.org/gmane.comp.lang.haskell.cafe/30685
19:55:40 <lambdabot> Title: Gmane -- Mail To News And Back Again
19:56:05 <Igloo> sethk: A lot of them seem coincidental, though, e.g. the bank names (although I'm not sure where "Barclays" comes from)
19:56:57 <SamB> yes, certainly you can't blame banks whose names begin with "Bank" for being near the beginning of the alphabet
19:57:00 * Cale decides to name his company AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.
19:57:16 <dons> hmm, maybe we should merge the Jobs page and the Industry page, and the Consultants page
19:57:19 <dons> http://haskell.org/haskellwiki/Jobs
19:57:20 <lambdabot> Title: Jobs - HaskellWiki
19:57:24 <dons> clean  that all up a bit
19:57:35 * jeffz names his company !A to beat Cale.
19:58:09 * dons wants to work at \0
19:58:12 <Igloo> I don't think merging consultants in makes sense, as job-seekers and people looking to hire consultants are more or less disjoint
19:58:13 <SamB> arg, my xterms are dying of like crazy
19:58:15 <SamB> lately
19:58:28 <sethk> that's odd
19:58:45 <shepheb> http://uncyclopedia.org/wiki/AAAA
19:58:49 <SamB> someone please write a terminal program in Haskell thaat will provably not do that...
19:58:51 <lambdabot> Title: AAAAAAAAA! - Uncyclopedia, the content-free encyclopedia
20:00:30 <dons> SamB: interesting. high assurance systems software is actually a niche we could do
20:00:45 * dons can think of a high assurance window manager project, with a code base to start from
20:03:14 --- mode: irc.freenode.net set +o vincenz
20:03:39 <solrize> so why does nobody ever talk about jhc?  it looks actively developed and way cool.
20:04:09 <johnnowak> solrize: i suppose because it isn't usable yet
20:04:15 <solrize> hmm
20:05:08 <dons> it is pretty way cool
20:05:16 <dons> already starting to scare the pants on ghc :)
20:05:23 * dons wishes there were some papers about it
20:05:55 <Igloo> "scare the pants /on/"?
20:06:10 <dons> heh
20:06:20 <dons> did you see john's recent benchmarks?
20:06:27 <dons> he's got a few more things running
20:06:28 <Igloo> I don't think so
20:07:06 <dons> http://repetae.net/computer/jhc/results.html
20:07:07 <lambdabot> Title: nobench: Haskell implementation shootout
20:07:11 <dons> when its good, its very very good
20:07:21 <dons> but its so different from ghc, its hard to port improvements across, i suspect
20:07:39 <dons> maybe seeing the assembly produced by some of these could be used as leverage on jaffacake?
20:08:20 <Igloo> Hmm, I wonder what that integrate failure is
20:08:37 <SamB> Igloo: integrate failure?
20:08:48 <Igloo> See the URL above
20:09:15 <dons> looks like floating point issues
20:10:20 <Igloo> It's a pretty big error, although if it does 0/epsilon or something then it could be
20:10:57 <dons> hmm
20:11:08 <dons> you can check nobench from code.haskell.org/nobench
20:11:29 <Igloo> Sleep first  :-)
20:12:32 <solrize> it would be cool if the haskell runtimes had access to the compiler, e.g. "compile :: (a->b) -> (a->b)"
20:13:06 <Cale> solrize: id :: (a -> b) -> (a -> b)  ;)
20:13:13 <solrize> you'd give it a function like (map (2*)) . (filter isprime) that you built up dynamically out of combinators
20:13:35 <solrize> and it would give back a function that did the same thing but had been through compiler optimizations
20:13:52 <dons> :t System.Eval.Haskell.eval
20:13:53 <lambdabot> forall a. (Typeable a) => String -> [System.Eval.Utils.Import] -> IO (Maybe a)
20:13:56 <dons> :)
20:14:16 <solrize> huh?  i don't think i understand that
20:14:28 <solrize> oh i see, eval a string by compilng it
20:14:55 <solrize> i meant take something made out of HOF's and do all those loop fusion transformations etc
20:15:27 <solrize> like the jhc back end appears to generalize somehow?
20:17:03 <SamB> oh, you mean the crazy inlining?
20:17:16 <SamB> and points-to analysis?
20:17:35 <solrize> for jhc?  not sure
20:18:13 <dons> how about ghc spitting out the kind of core that jhc can handle, then having jhc optimise it, and feed it back to ghc? :)
20:18:22 <solrize> haha
20:18:43 <dejones> dons, is that cheating?  :P
20:18:47 <solrize> i saw something a while back about refitting ghc with a henk-like intermediate language.  did that actually happen?
20:18:51 <solrize> brb
20:20:04 <SamB> dons: so having JHC basically compile the whole program helps how?
20:20:25 <SamB> also, GHC would get it back in a blob...
20:21:20 <SamB> but I bet you can't convert JHC's core back to GHC's reasonably...
20:21:30 <dons> a big blob, then use ghc's code generator and runtime
20:21:36 <solrize> samb it looks like jhc's whole program compilation lets it resolve typeclass membership statically instead of passing dictionaries
20:21:40 <solrize> at runtime
20:21:49 <SamB> I am aware of this, yes
20:23:06 <SamB> well, actually, it doesn't have to resolve membership statically
20:23:21 <SamB> it just passes type information instead of dictionaries
20:23:22 <johnnowak> i think it does case analysis
20:23:44 <SamB> then that same optimization magic destroys as much of this as possible...
20:24:48 <dons> augustss and spj giving talks at QCon , London. SPJ's doing a lot of speaking work recently. good stuff!
20:25:00 <SamB> it might surprise you that I would learn about this implementing various FFI things... but I did...
20:25:41 <solrize> neat
20:26:41 <SamB> still not sure how to implement foreign export wrappers though...
20:28:43 <solrize> also superspecialization looks like a big win
20:28:48 <dons> spj's talk on friday, http://qcon.infoq.com/london/presentation/Haskell%3A+functional+programming+on+steroids
20:28:50 <lambdabot> Title: Presentations -> Haskell: functional programming on steroids, http://tinyurl.com/2d5wmd
20:30:26 <solrize> neat, will there be a transcript or vid online/
20:30:27 <solrize> ?
20:30:58 <Nafai> I liked spj's talk at (What was it?  Nokia?  Ericsson?)
20:31:09 <dons> yeah, the Ericsson talks were last week
20:31:42 <Nafai> I watched his talk and also the Galois guy's talk
20:31:53 <Nafai> I need to watch the talk on QuickCheck
20:34:53 <dejones> anyone going to AFP in the Netherlands?
20:35:03 <dejones> I'm hoping to.
20:35:04 <dejones> :)
20:35:13 <dejones> Try to learn lots of Haskell from the masters, heh.
20:35:47 <dejones> AFP - http://www.st.cs.ru.nl/AFP_TFP_2008/
20:35:48 <lambdabot> Title: Home Page AFP/TFP 2008
20:36:01 <dejones> Expensive though, for a student, at least.  :(
20:36:05 <gwern> wish I could get jhc to compile. then I could set about figuring out how viable a GHC replacement it is
20:37:13 <sethk> gwern, why do you want to replace ghc?
20:37:28 <dejones> dons, are any of those talks available online?
20:37:46 <SamB> gwern: it isn't even self-hosting yet
20:37:47 <dons> http://haskell.org/haskellwiki/Video_presentations
20:37:48 <dons> :)
20:37:50 <lambdabot> Title: Video presentations - HaskellWiki
20:37:53 <SamB> that is, not very!
20:38:15 <gwern> sethk: more compilers is better? and it looks to me like JHC has more potential performance wise than GHC
20:38:24 <dejones> dons, ahh the new vids have been posted!
20:38:31 <gwern> GRIN is cooler, and I like the idea of wholeprogram compilation
20:38:31 <dons> dejones: yeah, i just added them
20:38:35 <dejones> dons, have you ever gone to AFP?
20:38:39 <dons> not AFP, no.
20:38:49 <dons> but I hear SPJ is going to be talking about parallelism
20:38:58 <dejones> dons, yep that's a big reason why I want to go.
20:39:13 <dons> cool!
20:39:17 <dejones> it is related to my Master's thesis work...
20:39:19 <dejones> ;)
20:39:29 <dons> very cool.
20:39:30 <dejones> and an opportunity to learn a lot (for a lot of $$) haha
20:39:44 <dons> yeah, that was a pain living in .au -- no AFP
20:40:02 <solrize> ghc seems like a big old program with layers of cruft, jhc may be more streamlined
20:40:24 <dejones> dons, yeah... I'm hoping my university will contribute some funding to help pay for the plane ticket to the Netherlands for AFP.
20:40:31 <SamB> jhc does seem to have less-stratified cruft, yes
20:41:03 <dons> the compilation techniques are way more understood than in the late 80s :)
20:41:07 <BMeph> sethk: Also, ndm mentions in http://neilmitchell.blogspot.com/2008/03/sorting-at-speed.html that Yhc's sort is roughly double the speed of GHC.
20:41:08 <lambdabot> Title: Neil Mitchell's Haskell Blog: Sorting At Speed
20:41:27 <dejones> dons, time for a ghc re-write?  ;)
20:41:33 <dons> BMeph: the sort algo is different
20:41:35 <sethk> BMeph, you mean compiled programs run at double the speed, or that the compiler compiles more quickly?
20:41:53 <SamB> sethk: y
20:42:02 <solrize> sethk, according to that post, yhc's library sort function is 2x as fast as ghc's sort function
20:42:05 <SamB> Yhc sorts twice as fast as GHC compiles
20:42:38 <sethk> be interesting to see how general that is, or if it reflects simply a better sort implementation
20:43:31 <BMeph> sethk: It looks like a little of both. That's part of the "mystique" - of the sort implementation, anyway.
20:43:35 * SamB restarts WindowMaker
20:43:41 * SamB is hoping it will refresh it's menu
20:43:54 <dons> SamB: no xmonad?
20:44:00 <gwern> from the discussions, I think the latter
20:44:12 <gwern> sethk: someone said the sort came down to yhc from nhc years ago
20:44:26 <SamB> hmm, what do I need a WM for anyway
20:44:29 <pantsd_> Question: I have a module which exports Message (a type), I import it into another library (B) and re-export it. Then if I include library B in some library (C) and write something like foo (Message ...) = somestuff I get an error saying that the data constructor is not in scope. What should I do?
20:44:39 <gwern> sethk: so I think it must be algorithmic not code-generation - current ghc surely beats old nhc ?
20:44:41 <agl> I've got GHC compiled code running in a tight loop, calling select with a 0 timeout. Is there any way I can get a list of the threads to figure out who might be causing that?
20:45:04 <sethk> agl, depends on the o/s, I believe
20:45:23 <agl> sethk, I'm wondering about the Haskell threads (forkIO etc)
20:45:39 <agl> sethk, for the moment I'm not linking with -threaded
20:45:56 <shteou> gwern, from a brief scan over it is algorithmic
20:46:05 <shteou> The YHC code generation is far from ghc afaic :x
20:46:07 <agl> pantsd, are you exporting with (..) at the end to export the constructors too?
20:46:10 <dons> pantsd_: hmm, something's not being exported properly
20:46:45 <sethk> agl, see if the debugger with the latest release will help
20:46:47 <pantsd_> how would I go about figuring out how to export the missing constructor (or what the missing constructor is)?
20:46:55 <BMeph> gwern: It sounds like 1) The sort algorithms are different, and 2) the _risers_ "tweak" makes a big perf improvement.
20:47:37 <agl> sethk, the loop is so tight that Ctrl-C in ghci wont break into it
20:47:43 <Cale> pantsd_: At the top of the module which contains the type Message, you should see  module A (foo, bar, Message(..), quux) where
20:48:12 <sethk> agl, then it's possible additional threads wouldn't help because they might be livelocked out
20:48:14 <Cale> pantsd_: If Message doesn't have that (..) after it, or else an explicit list of constructors, only the type is being exported, and not the constructors.
20:48:21 <shteou> later all
20:48:42 <pantsd_> ahh
20:48:45 <pantsd_> Cale: thanks :)
20:48:50 <Cale> pantsd_: no problem :)
20:49:00 <gwern> BMeph: risers tweak? what the heck is that?
20:49:03 <pantsd_> Cale: I should probably ask in #csc first :P
20:49:08 <Cale> heh
20:49:31 <agl> gwern, see Neil's recent blog post on Planet Haskell
20:49:33 <Cale> I watch this channel more closely anyway :P
20:50:28 <pantsd_> sad. The csc is totally awesome sauce
20:50:38 <BMeph> gwern: It's in the blog link I ref'd. :)
20:51:19 <gwern> 'I ran the Yhc sort function against the GHC version, and was shocked to find that the Yhc code was twice as fast. I ran the benchmark under Yhc, GHC and Hugs (using reduction count in Hugs), and in all cases the performance was doubled. I was not expecting this result!' <-- yeah, so it's definitely algorithmic, since the YHC sort as compiled by GHC is faster than GHC by GHC
20:51:44 <newsham> "I was browsing through the Yhc standard libraries, as one does on the weekend"
20:52:08 <Cale> pantsd_: Has the PMC been revitalised at all yet? It sort of died when certain people left.
20:52:56 <agl> The only funky thing that I'm doing is having forkIO threads go into C, have the C callback via "export"ed functions and block on IO with threadWaitWrite, is there anything special I should know about that? (e.g. it's known not to work ;)
20:52:56 <roconnor> PMAMC&OC
20:53:01 <Cale> roconnor: indeed :)
20:53:35 <gwern> newsham: the delivery is very nicely deadpan
20:53:45 <omg911> for the opengl bindings for haskell... is there some function that i can use to exit a window/app for when the user clicks the close button?
20:54:10 <gwern> 'so, while killing some time doing complexity analysis of the standard libraries...'
20:54:11 <dons> agl, hmm, the only thing i can think of even vaguely relevant is that tight loops not allocating won't get noticed by the scheduler
20:54:25 <shepheb> gtk2hs configure isn't finding libglade, although I definitely have it installed. I did a make distclean to no effect.
20:54:33 <dons> omg911: whatever the usual opengl function for that is?
20:55:13 <omg911> well i normall just call the c exit function but there is no side effect in haskell...
20:55:34 <dons> well, you can call exitWith ExitSuccess
20:55:41 <dons> or exitFailure if you like :)
20:55:44 <agl> dons, well, it's the scheduler which has broken. It's certainly looping because it's calling select(). I guess I need to start digging into the GHC sources
20:55:52 <solrize> hey cale i just found a post of yours about monad transformers :0
20:55:53 <solrize> :)
20:55:58 <dons> agl, yeah, sounds like a job for simonmar
20:55:58 <omg911> dons: ok thx very much i'll have a look
20:56:09 <dons> omg911: its in the System.Exit module
20:56:11 <Cale> solrize: :)
20:56:16 <solrize> http://reddit.com/info/69jbs/comments/c038w5o
20:56:27 <gwern> omg911: I see in Monadius, which uses Opengl, it defines a 'exitLookp' which goes 'throwIO $ ExitException ExitSuccess'
20:56:48 <gwern> it uses it like thus: ' (Char 'q',_)  exitLoop' in a case expression in keyProc
20:56:57 <solrize> tell me something, if i have a type like IO [Int], there are two monads involved (IO and List).  does this have something to do with monad transformers?
20:57:08 <omg911> ok
20:57:15 <Cale> solrize: Not as such.
20:57:36 <Cale> solrize: Monad transformers often build new monads by secretly composing like that
20:58:15 <Cale> solrize: But they hide that implementation detail from you (and that particular composition, IO over List doesn't give a monad)
20:58:29 <solrize> hmm
20:58:38 <dons> Heffalump: i note jdh is really down on ocaml now too
20:58:43 <solrize> i think i made a breakthrough in the past week or so in understanding regular monads
20:58:53 <newsham> > foldr (+) x [1,2,3,4]
20:58:54 <lambdabot>  1 + (2 + (3 + (4 + x)))
20:58:54 <Cale> For example, StateT s m a  is internally represented by  s -> m (a,s)
20:59:23 <solrize> so now i can write things like "let f x = 3*x in [1..5] >>= return . f" to get the same thing as the obvious listcomp
20:59:26 <Cale> Whenever m is a monad,  StateT s m  is a monad as well.
20:59:56 <Cale> x >>= return . f  is the same as  liftM f x
20:59:58 <solrize> > foldr (*) x [1..5]
20:59:58 <lambdabot>  1 * (2 * (3 * (4 * (5 * x))))
21:00:09 <solrize> > 3 * 5
21:00:10 <shepheb> any thoughts on my glade problem?
21:00:10 <lambdabot>  15
21:00:13 <Cale> (which is the same as fmap f x)
21:00:24 <solrize> oh cool, i was wondering about that
21:01:02 * wli ponders arbitrary-precision interval arithmetic that also maintains the mean and variance of a distribution on the interval.
21:01:03 <solrize> like often i want to read some value and compute a function on it, e.g.  y = f(read()) in a language like python
21:01:27 <Cale> Yeah, that's what fmap is all about.
21:01:40 <solrize> in haskell i have to either split apart the composition i.e. do { x <- read ; return $ f x}
21:02:09 <solrize> or write something ugly like read >>= return . f
21:02:31 <solrize> liftM wasn't what i wanted because it lifts both sides of the function, i.e. turns a->b into m a -> m b
21:02:47 <solrize> and i really want a->m b  which is return . whatever
21:02:51 <agl> solrize, liftM f read  is the same as read >>= return . f
21:03:08 <dons> :t ?f <$> read
21:03:09 <lambdabot> forall a b. (Read a, ?f::a -> b) => String -> b
21:03:11 <solrize> hmm
21:03:12 <faxathisia> :t liftM
21:03:13 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
21:03:26 <Cale> :t liftM reverse getLine
21:03:27 <lambdabot> IO [Char]
21:03:28 <dons> :t toUpper <$> read
21:03:29 <lambdabot> String -> Char
21:03:59 <dons> ?. pl undo do { x <- read ; return (f x) }
21:04:00 <lambdabot> f `fmap` read
21:04:06 <Cale> dons: That's potentially confusing here, since read in this context is meant to be an IO action :)
21:04:11 <dons> ah oops
21:04:14 <solrize> yeah sorry
21:04:18 <dons> :t toUpper <$> readIO
21:04:19 <lambdabot>     Couldn't match expected type `Char' against inferred type `IO a'
21:04:19 <lambdabot>       Expected type: String -> Char
21:04:19 <lambdabot>       Inferred type: String -> IO a
21:04:20 <Cale> But it does work :)
21:04:26 <faxathisia> :t toUpper . read
21:04:27 <lambdabot> String -> Char
21:04:32 <Cale> :t map toUpper <$> readIO
21:04:33 <lambdabot>     Couldn't match expected type `[Char]' against inferred type `IO a'
21:04:33 <lambdabot>       Expected type: String -> [Char]
21:04:33 <lambdabot>       Inferred type: String -> IO a
21:04:38 <Cale> err...
21:04:40 <dons> :t readIO
21:04:41 <lambdabot> forall a. (Read a) => String -> IO a
21:04:51 <Cale> :t map toUpper <$> readLn
21:04:52 <lambdabot> IO [Char]
21:05:07 <Cale> :t map toUpper <$> getLine
21:05:08 <lambdabot> IO [Char]
21:05:11 <hpaste>  solrize pasted "ugly version of double echo" at http://hpaste.org/6277
21:05:15 <Cale> (readLn is unlikely there)
21:05:23 <Cale> :t (^2) <$> getLine
21:05:24 <lambdabot>     No instance for (Num String)
21:05:24 <lambdabot>       arising from a use of `^' at <interactive>:1:0-3
21:05:24 <lambdabot>     Possible fix: add an instance declaration for (Num String)
21:05:27 <Cale> :t (^2) <$> readLn
21:05:28 <lambdabot> forall a. (Read a, Num a) => IO a
21:05:31 <Cale> oy :)
21:05:47 <Cale> :t (^2) <$> readLn >>= print
21:05:48 <lambdabot> IO ()
21:06:09 <shteou> Hi again.
21:06:14 <faxathisia> Hello
21:06:20 <dons> we're approachign 100 contributors a month to tracked projects, btw, http://www.ohloh.net/languages/compare?commit=Update&l0=haskell&l1=-1&l2=-1&measure=contributors
21:06:22 <lambdabot> Title: Compare Languages - Ohloh, http://tinyurl.com/2e6yez
21:06:23 <dons> how cools is that :)
21:06:28 <shteou> :)
21:06:41 <dons> now we just need 100 new jobs, instead of 10
21:07:03 <shteou> Nearly as cool as finding out you have a 3rd year project due in 24 hours earlier than you expected, 56 hours before it has to be submitted!
21:07:11 <shteou> had*
21:07:25 <shteou> Wait, that's not even the right math.
21:07:33 <shteou> 32 hours :p
21:08:11 <BMeph> From my "Monadics" notes: ap (return f) x == (return . f) =<< x == fmap f x
21:08:28 <SamB> Oh good, I've got JHC failing to compile class aliases in the expected manner again ;-)
21:08:38 <solrize> i'm getting sleepy, can't really think through this stuff right now
21:08:45 * SamB had to rebuild the libs
21:09:32 <faxathisia> BMeph: huh ? is this on the wiki ? maybe it should be
21:09:45 <faxathisia> seems interesting..\
21:10:46 <BMeph> faxathasia: I could throw it in a discussion, I guess. It's part of the notes I made to get a grasp on the whole ap/bind/join business. :)
21:11:41 <hpaste>  solrize annotated "ugly version of double echo" with "hmm, fails" at http://hpaste.org/6277#a1
21:13:39 <Cale> solrize: print wants something which it can print, you're giving it an IO action
21:13:39 <solrize> someone has ghc running on a nokia handheld computer, wow
21:13:42 <solrize> that's a tiny little thing
21:14:20 <solrize> hm, i see, i got confused because i saw earlier that i could print io values
21:14:37 <dons> yeah, there's a hugs port too
21:15:02 <solrize> there's a good arm backend?
21:15:56 <solrize> i have an N770 that i never use
21:16:11 <solrize> it would be cool to run haskell apps on it but i think i would want to cross compile
21:17:18 <solrize> oh wow, i didn't know the debugger was now active in ghci by default
21:17:47 <sieni> hugs is ported to many platforms, but using ghc on such devices is a bit difficult, since apparently ghc doesn't have cross compilation support
21:17:57 <sieni> or that's at least what dcoutts said
21:17:59 <solrize> hmm
21:18:02 <solrize> that's unfortunate
21:18:08 <solrize> the nokia is just a tiny little thing
21:18:16 <solrize> i guess i'd have to remote access it
21:18:23 <solrize> typing on it is not practical
21:18:35 <shteou> This is painful, I have several thousand words to write in 7 tiring hours, but I want to code.
21:19:48 <sieni> solrize: and of course, no native code generation for arm, you have to go through c and gcc
21:20:08 <solrize> oh ok, there's a c backend then
21:20:55 <sieni> well at least debian on arm is supported according to the ghc web page
21:21:19 <dons> yeah, C backend, but that's fine.
21:22:00 <goalieca> heh. i like how in haskell you can arbitrarily define inline operators
21:22:11 <goalieca> i'm seeing all kinds of creative ones like .|.
21:22:33 <shteou> Indeed goalieca, it's very useful :)
21:23:03 <dibblego> ?type let sq x = x * x; y = \c r -> sqrt (c*c/4 + sq (r - sqrt(sq r - c*c/4))) in y -- is there anything in lambdabot to simplify this equation?
21:23:04 <lambdabot> forall a. (Floating a) => a -> a -> a
21:23:18 <solrize> i feel like i still have a tremendous amount more theory to grok before i can begin to understand something like happs
21:25:00 <sieni> yeah, the left finger operator ..|. and the right finger operator .|..
21:25:11 <solrize> what are those?
21:25:20 <goalieca> lol
21:25:42 <solrize> ph heh
21:25:49 <solrize> s/ph/oh
21:25:49 <faxathisia> I don't ithink it's a valid operatior?
21:26:05 <faxathisia> > let  x ..|. y = 3 in ..|.
21:26:05 <lambdabot>  Parse error at "..|." (column 22)
21:26:07 <sieni> faxathisia: dang :-)
21:26:09 <faxathisia> > let  x ..|. y = 3 in ..|.
21:26:10 <lambdabot>  Parse error at "..|." (column 22)
21:26:12 <faxathisia> oops
21:26:21 <faxathisia> > let  x .-|. y = 3 in .-|.
21:26:21 <lambdabot>  Parse error at ".-|." (column 22)
21:26:25 <faxathisia> hmmm. :/
21:26:49 <sieni> > let  x .-|. y = 3 in 7 .-|. 12
21:26:50 <lambdabot>  3
21:26:59 <sieni> > let  x ..|. y = 3 in 7 ..|. 12
21:27:00 <lambdabot>  3
21:27:03 <sieni> it works
21:27:21 <solrize> is there a way i can import more than one module with an import statement?
21:27:24 <faxathisia> ohhh wow.. stupid mistake
21:27:25 <faxathisia> thanks
21:28:14 <solrize> haha, javascript backend for yhc
21:28:18 <solrize> ghc needs that
21:29:55 <sieni> off to juggling
21:29:58 <newsham> and quick, soon js will be the only target left
21:30:29 <sarehu> solrize: nope... but you can export multiple modules and thus have only one module you need to import
21:30:49 <solrize> well i usually want to import Data.List, Data.Char, Control.Monad, etc
21:32:14 <sarehu> for a while, when writing personal stuff I had a module "Basics" that exported all that..
21:32:28 <solrize> ic
21:33:09 <solrize> is Network.Socket a lot more cumbersome to use than Network?
21:35:32 <solrize> zomg, someone rewrote parsec in python
21:35:58 <faxathisia> did anyone do it in javascript that would be useful
21:36:08 <cjb> there seems to be a fairly large group of people rewriting good Haskell feeatures in Python (e.g. quickcheck)
21:36:15 <cjb> faxathisia: you can compile Haskell to JavaScript :)
21:37:40 <bos> yeah, quickcheck gets ported a lot.
21:37:56 <bos> the thing is, quickcheck isn't nearly so useful if you can easily shoot yourself in the foot.
21:38:09 <bos> it's best suited to a language where you don't have a foot or a gun.
21:38:37 <solrize> quickcheck seems to make more sense with static types
21:38:46 <cjb> solrize: yes, very much so
21:39:08 <cjb> bos: and where you actually have enough information for it to be able to generate test data
21:39:17 <newsham> doesnt quickcheck work mostly because of type system?
21:39:36 <newsham> seems like it would be tedious in python
21:39:45 <cjb> yeah.  the python version requires you to choose a data generation function (there are builtin ones) or write your own.
21:39:45 <newsham> (or other dyn typed langs)
21:40:07 <cjb> it doesn't seem too bad, but it also does seem like it's missing the point somewhat.
21:41:11 <bos> newsham: you can still write type-based tests in python, they just get dispatched on at runtime.
21:41:41 <newsham> can you explain?  ie. I have   def foo(a,b) : return a+b
21:42:04 <newsham> what do you do to generate inputs a and b if I want to quickcheck(foo) ?
21:42:53 <newsham> (or quickcheck some prop of foo rather)
21:43:50 <bos> in that kind of case, you'd have to tell it that you want the property checked over some numeric type.
21:44:07 <cjb> I think bos is saying that you can have your tests do if isinstance(foo, bar):.
21:44:21 <bos> but if you were concerned with producing arbitrary values, you could manage that, albeit not having much fun.
21:45:03 <newsham> if you're just saying that python has "insinstance" I'm aware
21:45:18 <cjb> yeah.  so, more likely, you tell the python quickcheck to use an int generator function.  it is far less convenient (and arguably interesting) than quickcheck, but it's not necessarily less useful.
21:45:38 <cjb> ie. quickcheck(foo, gen_int)
21:45:49 <bos> right.
21:46:04 <faxathisia> o_o
21:46:13 <faxathisia> and this checks what ?
21:46:26 <cjb> faxathisia: do you know how quickcheck works in general?
21:46:29 <faxathisia> Yes
21:46:51 <faxathisia> def foo(a,b) : return a+b # What property are you checking?
21:46:59 <faxathisia> Is it not mentioned somewhere
21:47:03 <cjb> yeah, we'd need to specify that.
21:47:14 <cjb> I think we were ignoring that as the part that would be the same between both languages.
21:47:30 <faxathisia> It seems like a unit testing framework, and not a quickcheck implementation
21:47:36 <newsham> ?check \x y -> x < 0 || y < 0 || x + y > (x :: Integer)
21:47:36 <lambdabot>  Falsifiable, after 0 tests: 0, 0
21:47:41 <newsham> ?check \x y -> x < 0 || y < 0 || x + y >= (x :: Integer)
21:47:42 <lambdabot>  OK, passed 500 tests.
21:47:45 <cjb> say, quickcheck(foo(a,b) == foo(b,a), gen_int)
21:48:16 <cjb> newsham: btw, it would be fun to see Haskell used more on OLPC
21:48:27 <cjb> for example, we have a datastore implementation that is fragile as all hell.
21:48:33 <faxathisia> cjb: Is that even possible in python{ (just curious, I'm not aware of how macros work in it)
21:48:46 <newsham> cjb: yes, esp when correctness is important.
21:48:47 <cjb> and written in python, so we weren't exactly optimizing for speed
21:49:02 <cjb> faxathisia: good point.
21:50:21 <newsham> check(lambda a,b : foo(a,b) == foo(b,a), genint, genint)
21:50:28 <cjb> http://www.accesscom.com/~darius/software/clickcheck.html has our add example
21:50:28 <lambdabot> Title: Clickcheck and Peckcheck
21:50:31 <newsham> there are no macros in python
21:52:06 <newsham> ?check \x y -> x < 0 || y < 0 || x + y >= (x :: Int)
21:52:06 <lambdabot>  OK, passed 500 tests.
21:52:27 <solrize> datastore?  i've been wondering if there's a persistent implementation of something like Data.Map (i.e. write out an AVL tree into a disk file that you can keep appending to and can "rewind")
21:52:39 <newsham> > 1073741821 + 1073741821
21:52:39 <lambdabot>  2147483642
21:52:43 <newsham> > 1073741821 + 1073741821 :: Int
21:52:43 <lambdabot>  2147483642
21:52:52 <luqui> > let x = True; a0 = (x,x); a1 = (a0,a0); a2 = (a1,a1); a3 = (a2,a2); a4 = (a3,a3); a5 = (a4,a4); a6 = (a5,a5); a7 = (a6,a6); a8 = (a7,a7); a9 = (a8,a8); a10 = (a9,a9); a11 = (a10,a10); a12 = (a11,a11); a13 = (a12,a12); a14 = (a13,a13); a15 = (a14,a14); a16 = (a15,a15); a17 = (a16,a16); a18 = (a17,a17); a19 = (a18,a18); a20 = (a19,a19) in 42
21:52:53 <newsham> > 2147483642 + 2147483642 :: Int
21:52:54 <lambdabot>  -12
21:52:58 <lambdabot>  ghc: failed with error code 9
21:53:10 <luqui> > "still alive?"
21:53:11 <lambdabot>  "still alive?"
21:53:12 <luqui> yay
21:53:16 <solrize> :t Length
21:53:17 <lambdabot> Not in scope: data constructor `Length'
21:53:18 <solrize> :t length
21:53:19 <lambdabot> forall a. [a] -> Int
21:54:00 <newsham> Bug: haskell uses modular arithmetic.
21:54:07 <solrize> yeah
21:54:13 <Cale> hmm
21:54:16 <faxathisia> is not a bug...?
21:54:17 <solrize> length $ readfile "foo"
21:54:25 * Cale gets an idea
21:54:26 <solrize> can return the wrong answer if the file is > 4gb
21:54:29 <solrize> which often happens
21:54:33 <faxathisia> > 2147483642 + 2147483642 :: Integer
21:54:33 <lambdabot>  4294967284
21:54:34 <solrize> > 2gb rather
21:54:34 <lambdabot>   Not in scope: `rather'
21:54:41 <solrize> heh
21:54:57 <luqui> fortunately we have genericLength
21:54:58 <Cale> > maxBound :: Int
21:54:58 <lambdabot>  2147483647
21:55:14 <Cale> > maxBound :: Int64
21:55:15 <lambdabot>  9223372036854775807
21:55:25 <Cale> > maxBound :: Integer
21:55:25 <lambdabot>   add an instance declaration for (Bounded Integer)
21:55:25 <lambdabot>     In the expression: ma...
21:55:29 <sclv_> ?instances Int
21:55:43 <lambdabot> Couldn't find class `Int'. Try @instances-importing
21:56:08 <solrize> length still seems like a nasty source of bugs
21:58:30 <dons> :t genericlength
21:58:31 <lambdabot> Not in scope: `genericlength'
21:58:33 <dons> :t genericLength
21:58:34 <lambdabot> forall b i. (Num i) => [b] -> i
21:58:51 <dons> but you're likely to run out of memory before length overflows on 64 bit machine
21:59:01 <dons> so bugs relating to Int are rare (never?)
21:59:06 <dons> i'd love to know if someone had one
22:00:04 <Cale> dons: It's still bloody irritating, for instance, when writing things like 'mean', to have to do conversions explicitly or use genericLength
22:00:22 <Cale> (especially when we have things like SPECIALIZE and RULES)
22:00:23 <dons> yep
22:00:47 <yav> it is also annoying that Int can be negative while lengths can't
22:00:55 <yav> even in C they use unsigned :-)
22:01:12 <dons> yeah, Int64 too. all very silly
22:01:30 <dons> i wonder if anything would break if i changed bytestring lengths
22:01:42 <dons> to be Words/Word64s
22:02:17 <yav> unfortunately a bunch of stuff will probably break
22:02:29 <yav> not that it would be hard to fix, but i suspect that it will break
22:02:34 * dons tries to think what things
22:02:53 <dons> all the interfaces to String lengths, I guess
22:03:33 <dons> i think i've had one user complain about Int for ByteStrings, and they switch to lazy bytestrings (or 64 bit machines).
22:03:37 <yav> I was thinking that Int is very prevalent in the Prelude...  But Int64 is already a different type, so perhaps it wont be all that much that would break?
22:03:51 <dons> yeah, the Int64 means already they're using fromIntegrals where needed
22:04:01 <yav> good point
22:04:01 <dons> but i'm thinking more for the case of Word on 32 bit machines for strict bytestrings
22:04:19 <newsham> how inefficient is Integer?
22:04:27 <newsham> compared to Int of the native size?
22:04:29 <dons> ?src Integer
22:04:29 <lambdabot> data Integer = S# Int#
22:04:29 <lambdabot>              | J# Int# ByteArray#
22:04:42 <dons> 1 bit tag worth, and overflow checking on lots of ops
22:05:04 <newsham> yah, but arguably those overflow checks are the most important bits :)
22:05:05 <yav> wow, they are showing baywatch on tv :-)
22:05:25 <newsham> shouldnt Integer be the common case and Int be reserved for cowboys on the optimization ranch?
22:05:45 <newsham> (or the optimizer, if it were ever smart enough to do that)
22:06:20 <yav> they are not that easy to optimize away
22:06:27 <newsham> *nod*
22:06:38 <newsham> but auditing code for integer overflows is not easy either
22:06:57 <newsham> correctness > premature optimization
22:07:10 <bos> it makes a big difference to performance, and most integers are small.
22:07:24 <newsham> unless you get em from the attacker :)
22:07:46 <dejones> hey dons, you're in Portland, right?
22:08:16 <bos> if you're being attacked, you especially don't want to use Integer.
22:08:17 <dejones> dons, you communicate much with the people working on House at Portland State?
22:08:30 <bos> "i'm going to send you 10e300 bytes. please wait a bit."
22:08:39 <davidL> House is still being developed?
22:08:43 <yav> dejones: i worked on house
22:08:49 <dejones> yav, really?  great.
22:08:49 <gwern> dons: I don't know if it's a bug exactly but conjure seems to have problems relating to Int
22:09:01 <cjb> solrize: the datastore is an OLPC filesystem-like database, indexed with lots of metadata.
22:09:05 <newsham> bos: using 64 (and even 32-) bit ints doesnt solve that problem either.
22:09:05 <gwern> dons: which cause it to apparently barf when you hSeek on a file >2gigs
22:09:09 <yav> the folks at PSU are still intersted in that kind of stuff
22:09:21 <newsham> and those attacks are much less interesting than some of the more important integer issues
22:09:23 <bos> newsham: no, only being careful solves it.
22:09:24 <dejones> yav, I'm interested in Haskell and Systems programming.  I'm wondering what updates / progress the Portland State people have made
22:09:26 <cjb> idea being that five year-olds never want to see filesystem paths, but can cope with "I wrote this document with <friend> on <date>".
22:09:46 <dejones> yav, I'm hoping to do a Master's thesis (or project) this summer with Haskell and Systems work...
22:09:49 <newsham> bos: non-ideal integers have proven hard for programmers to be careful about.
22:09:51 <dejones> yav, are you at Portland State?
22:10:01 <bos> newsham: yes, i know.
22:10:06 <newsham> also if "Integer" is too slow, perhaps it should be the focus of optimization
22:10:10 <gwern> makes sense. most five year olds I've seen tend to just dump everything into a single folder and scan through it...
22:10:29 <yav> dejones: i graduated---mpj was my advisor
22:10:31 <solrize> dons, sorry was away from window.  yeah, length is probably ok with 64-bit ints but is dangerous with 32-bit ints when counting stuff like network and file bytes, given today's fast networks and large disks
22:11:01 <gwern> solrize: right, like the conjure bug I mentioned above
22:11:33 <dejones> yav, cool.  I'd like to potentially go to PSU this summer and work with them on something for my Master's thesis.  :)
22:11:58 <yav> dejones: you should drop them a mail
22:12:03 <yav> and portland is very nice in the summer :-)
22:12:08 <luqui> @pl (\x -> x x) (\x -> x x)
22:12:09 <Cale> I think that Int should be relegated to a separate library and used only when performance is explicitly a problem.
22:12:16 <dejones> yav, yeah, I'm emailing my advisor here first to make sure it would be OK.
22:12:22 <cjb> newsham: I think that's like saying that if long int is slower than int, it should be the focus of optimization :)
22:12:27 <newsham> solrize: this year :)
22:12:38 <Cale> cjb: And why shouldn't it be?
22:12:50 <newsham> cjb: arbitrary sized integers can be optimized, like any other data structure
22:13:03 <dejones> yav, do you know of any progress with House?  Based upon their latest paper, it seems they are interested in extending Haskell to support low-level data types.
22:13:07 <luqui> did I kill lambdabot?
22:13:18 <Cale> cjb: (so it might involve some optimisation at the hardware level)
22:13:18 <newsham> > foldr (+) x [1,2,3]
22:13:22 <Cale> @bot
22:13:28 <yav> dejones: yeah, that was my work
22:13:29 <gwern> @quote house
22:13:29 <Cale> luqui: I doubt it was your fault.
22:13:39 <yav> dejones: they are looking at reliable runtime systems at the moment
22:13:42 <solrize> most regular apps don't need arbitrary sized integers, since ints are typically used to count things.  but 32 bits isn't enough.  if ints defaulted to 64 bits even on 32 bit hw, that would mostly fix this problem
22:14:09 <dejones> yav, awesome.  I am interested in the RTS and Concurrency for OSes.
22:14:10 <bos> then ints would be slow.
22:14:34 <Cale> luqui: In fact, it didn't even get your message
22:14:48 <newsham> solrize: most regular apps have bugs in them due to not using arbitrary sized integers.
22:14:57 <Cale> @pl (\x -> x x) (\x -> x x)
22:15:02 <dejones> yav, are you still in Portland at PSU?
22:15:04 <lambdabot> ap id id (ap id id)
22:15:10 <lambdabot> optimization suspended, use @pl-resume to continue.
22:15:31 <yav> dejones: i am in portland at galois
22:15:33 <solrize> newsham, hmm, most times when i've used ints > 64 bits, i was really explicitly aware of it
22:15:41 <dejones> yav, ahh.  Galois gets all the Haskell people.  ;)
22:15:50 <solrize> at least in systems-like programs
22:16:04 <yav> true :-)
22:16:34 <Cale> solrize: If arbitrary sized integers would be fast enough though, it's silly not to use them
22:16:42 <Cale> solrize: and they usually are.
22:16:59 <Cale> (since they typically represent small enough numbers using machine ints)
22:17:00 <yav> dejones: have you seen peng li's work on concurrency as a library---seems pretty cool
22:17:05 <newsham> 32-bit and 64-bit ints are optimizations (unless used explicitely for their modular properties)
22:17:10 <bos> if only we wrote our code in agda2, we'd know how big our ints were.
22:17:13 <solrize> yeah, i guess the compiler can figure out when it can use machine ints a lot of the time
22:17:18 <dejones> yav, can you answer a quick question I have about something in the "Writing Systems Software in a Functional Language: An Experience Report" paper?
22:17:19 <newsham> optimizations should be done when necessary
22:17:22 <Cale> @src Integer
22:17:28 <newsham> correctness should always be maintained
22:17:36 <yav> ergh, i could try :-)
22:17:39 <dejones> yav, Nope, I haven't... but, I will look into it.  Thanks for mentioning it.
22:17:47 <Cale> data Integer
22:17:47 <Cale>   = GHC.Num.S# GHC.Prim.Int#
22:17:47 <Cale>   | GHC.Num.J# GHC.Prim.Int# GHC.Prim.ByteArray#
22:17:58 <solrize> i've heard of some compielrs checking array subscripts using the decision procedure for presberger arithmetic, as long as there's no x*y multiplication (just mult. by constants)
22:18:16 <dejones> yav, the lightweight concurrency with Haskell by Peng Li?
22:18:23 <Cale> solrize: That's insane :)
22:18:55 <yav> dejones: yeah
22:19:04 <dejones> Ok
22:19:13 <solrize> apparently it's like type inference, the worst case runtime is awful but in normal practical instances it's not so bad
22:20:15 <gwern> is that because presberger arithmetic is decidable?
22:20:16 <dejones> yav, in the paper, why is the bit pattern for stack_seg 10110?  (at the bottom of page 4 on the left)
22:20:34 <Cale> I wonder whether hardware could be doing anything more to make arbitrary precision integer arithmetic fast?
22:20:42 <Cale> gwern: yes
22:20:49 <solrize> gwern, yes
22:20:56 <Maddas> Cale: That sounds like something that would generally be true ;-)
22:21:02 <solrize> cale, yes, hardware could trap overflow on addition and stuff like that
22:21:02 <gwern> hm. so presberger arithemtic is decidable, because it omits multiplication. how the heck does multiplication lead to undecidability?
22:21:32 <newsham> cale: tag support in hardware like parisc?
22:21:33 <Cale> solrize: Yeah, that's a good point.
22:21:51 <dejones> yav, btw, what's your name?  Mine is donnie.  :)
22:21:52 <newsham> hardware already traps arithmetic overflow
22:21:52 <solrize> gwern multiplication leads to undecidability because it lets you encode arbitrary sentences as numbers
22:22:10 <faxathisia> gwern: because you can encode statements about the satisfiability of statements
22:22:11 <solrize> newsham usually overflow sets a condition code that needs an extra cycle to check
22:22:15 <faxathisia> (I think..)
22:22:28 <solrize> and you can encode sentences like "this sentence cannot be proved"
22:22:41 <newsham> oh you mean raising a cpu exception instead
22:22:57 <yav> dejones: take a look at the definition of SegType
22:23:00 <solrize> newsham yes, like floating point arithmetic
22:23:12 <gwern> solrize: I guess I'm kind of wondering why you couldn't encode that using addition and so on; doesn't multiplication just come down to repeated addition?
22:23:19 <gwern> what's special about multiplication?
22:23:42 <yav> it states that DataSeg values start with 10 followed byExpDown (1), followed by writable(1), followed by access (0)
22:23:51 <Cale> gwern: Of course, it's not just multiplication and addition, but universal quantifiers.
22:24:23 <dejones> yav, I see.  I didn't understand the #'s.
22:24:29 <glguy> yow
22:24:33 <glguy> @yow
22:24:41 <Cale> gwern: It's not easy to express, say, forall x. exists y. y = x * x, using just addition, for instance.
22:24:41 <solrize> gwern, if you want to encode an n-tuple of ints as a single int, like (a,b,c,d,e) to an int, the usual encoding is something like 2^a * 3^b * 5^c * 7^d * 11^e
22:24:46 <newsham> how many modern cpus support a trap-on-condition instruction?
22:24:52 <yav> dejones: the # means "join the bitpatterns together
22:24:59 <dejones> yav, gotcha.. didn't know that.  ;)
22:25:17 <solrize> newsham i thought all ieee floating point implementations had to be able to trap
22:25:23 <yav> is lambdabot dead?
22:25:24 <dejones> yav, so the initial B10 is just padding, or an identifier bit pattern?
22:25:36 <newsham> i mean for integer condition flags
22:25:46 <dejones> yav, yea, seems lambda bot went into an infinite recursion outta here...
22:25:49 <solrize> gwern, strictly speaking you don't need multiplication for undecidability.  there's a system called robinson arithmetic which is a little bit stronger than presberger arithmetic and is undecidable but doesn't have multiplication
22:25:55 <solrize> http://en.wikipedia.org/wiki/robinson_arithmetic
22:25:57 <newsham> ie: add r1 = r2+r3; trap on carry
22:26:11 <solrize> oh wait it does have multiplication
22:26:14 <solrize> but doesn't have induction
22:26:29 <yav> the 10 is from the hardware spec---it is how the hardware knows what kind of segment we have
22:26:29 <gwern> Cale: hm. but suppose we had some crippled multiplication where you could only use a variable once, so you could do forall x. exists y. y = x * 2, and not y = x *x; would that still allow for undecidability?
22:26:58 <solrize> x*2  is the same as x+x
22:27:14 <gwern> Cale: y = x * 2 could be turned into y = x + x, then, which brings us back down into decdability?
22:27:14 <Cale> Well, if you only have multiplication by constants...
22:27:19 <bos> that's why multiplication by constants is allowed.
22:27:30 <solrize> right
22:27:35 <Cale> But if you have multiplication by even other variables, it'll get complicated.
22:27:54 <dejones> yav, gotcha.  thanks for the input there.  :)
22:27:57 <Cale> That would be interesting though, what happens if you have only "linear" quantification.
22:29:15 <gwern> (I feel like there's something profound and self-referential I'm missing about the distinction between multiplication which allows x*x and multiplication which allows x*2)
22:29:18 <solrize> hmm   forall x.   forall y.  forall z.  x=y*z
22:29:37 <bos> gwern: because you can't rewrite x*x statically without knowing what x is.
22:29:38 <Cale> forall z. exists x y. x * y = z
22:29:39 <solrize> gwern, yes, that's right, x*constant is just repeated addition
22:29:54 <Cale> Or  forall x y. exists z. x * y = z
22:30:01 <bos> but you *can* rewrite x * k as k repeated additions, statically.
22:30:01 <faxathisia> you need * to encode Godels beta  function
22:30:40 <solrize> http://en.wikipedia.org/wiki/incompleteness_theorem sort of explains this
22:31:08 <faxathisia> beta m n j = m `mod` n*(j+1)+1
22:31:39 <faxathisia> for any list of numbers there l there exists m n so that l = map (beta m n) [1..k]
22:32:10 <faxathisia> and beta is quite central to the proof I think (?)
22:32:46 <gwern> is beta used in the famous godel numbering?
22:33:15 <newsham> hah http://lxr.mozilla.org/seamonkey/source/js/src/Y.js
22:33:21 <solrize> gwern yes
22:33:40 <solrize> godel numbers are usually done with exponentiation like above
22:34:12 <solrize> p1^a * p2^b * ...  where p_k = the kth prime #
22:34:33 <gwern> ok; once you have full multiplication, then you can jump to exponentiation then, no? (unlike addition/multiplication)
22:35:02 <luqui> gwern, ot
22:35:07 <solrize> hmm
22:35:08 <luqui> gwern, it's not a trivial thing to do
22:35:17 <luqui> but yes, that was a substantial portion of godel's proof
22:35:34 <solrize> gwern i don't have the mechanism in my head any more
22:35:35 <bos> i can tell you they don't have discussions like this on #php.
22:35:39 <solrize> bos :)
22:35:46 <faxathisia> bos: Let's invade
22:36:11 <bos> beware of geeks bearing gifts of category theory and undecidability
22:36:13 <Cale> gwern: Once you have arithmetic with addition and multiplication, and a sufficiently strong logic (say, first order logic), you can embed all of mathematics.
22:36:27 <gwern> faxathisia: that would be hilarious. in the middle of a highfalutin' discussion on CS theory, to just enmasse /join
22:36:29 <faxathisia> what is all of mathematics?
22:36:45 <solrize> errr no you can't do set theory that way
22:36:57 <luqui> faxathisia, another way to put it is that that system is turing complete
22:37:00 <Cale> solrize: you could, in a somewhat bizarre way :)
22:37:05 <gwern> Cale: I figured as much; simple lambda calculus can do it, afaik, so why not arithmetic with a bit of logic?
22:37:09 <faxathisia> ahh ok
22:37:14 <faxathisia> O_o
22:37:16 <faxathisia> what
22:37:48 <solrize> cale what i mean is there's lots of theorems provable from (e.g.) set theory that aren't provable just from peano arithmetic
22:37:58 <solrize> even pure arithmetic statements
22:38:05 <solrize> http://en.wikipedia.org/wiki/goodstein's_theorem
22:38:13 <luqui> solrize, but that's not true, because you can embed the axioms of set theory into numbers
22:38:21 <luqui> and use numbers to encode proofs about them
22:38:24 <gwern> faxathisia: turing completeness lurks in the strangest places. have you seen some of the esoteric languages like FRACTRAN?
22:38:30 * wli realizes a rather interesting application of what he's working on.
22:38:44 <faxathisia> yes :D
22:38:47 <solrize> luqui, hmm, maybe we're not using these terms the same way
22:38:55 <Cale> solrize: But you can always embed set theory in arithmetic, via the same sort of encoding which is used in the proof of Gdel's incompleteness theorem
22:39:02 <faxathisia> I wrote a fractran intrepreter:
22:39:03 <faxathisia> (*{~1 i.~[@(=<.)@:*)
22:39:09 <luqui> solrize, well the difference is that when you're doing set theory with first order arithmetic, your variables aren't representing numbers
22:39:27 <luqui> it's very hard to explain
22:39:45 <gwern> wow. goodstein's theorem blows my mind
22:39:47 <faxathisia> I'm confused.. what's all of mathematics?
22:39:54 <gwern> faxathisia: neat. is, uh, that APL?
22:39:55 <Cale> faxathisia: That is one hell of a smiley.
22:40:08 <luqui> faxathisia, anything at all.   it's actually more than mathematics.  anything that one can do in a formal system.
22:40:20 <solrize> luqui, my brain is not big enough for this :).  but lessee, i mean sure, the theorems of set theory are recursively enumerable
22:40:27 <faxathisia> gwern: J, it's successor of APL
22:40:27 <Cale> faxathisia: I mean all of contemporary mathematics, starting from ZFC, and developing analysis and algebra, and so on.
22:40:33 <gwern> faxathisia: actually, I could include that in https://secure.wikimedia.org/wikipedia/en/wiki/FRACTRAN needs more code
22:40:57 <solrize> so yeah you can have some function in PA that cranks them out
22:40:59 <luqui> solrize, yeah, so you could prove goodstein's theorem in PA, but it wouldn't be about it's own model of PA
22:41:02 <gwern> faxathisia: neat. you mind me adding it?
22:41:14 <faxathisia> gwern: No, that's fine.. there is an example use here http://www.esolangs.org/wiki/Fractran
22:41:59 <faxathisia> There is a difference between encoding mathematics and proving mathematics?
22:42:13 <luqui> solrize, I had a fun discussion on my blog with someone about this kind of stuff tha tyou might be interested in: http://luqui.org/blog/archives/2007/09/22/reply-to-platonism/
22:42:16 <faxathisia> for example.. you can't prove induction with lambda calculus ..
22:42:45 * solrize bookmarks luqui's blog :)
22:43:36 * Cale hopes that Platonism in mathematics will go away entirely soon :)
22:43:59 <solrize> luqui that post looks really good, i gotta read it when i'm awake
22:44:23 <faxathisia> Cale: "Platonic idealism is the theory that the substantive reality around us is only a reflection of a higher truth."?
22:44:27 <faxathisia> This or something else?
22:44:36 <solrize> i remember hearing that the fundamental theorem of linear algebra can't be written in zfc
22:44:52 * gwern reads http://www.esolangs.org/wiki/Talk:Fractran - *IO* in Fractran? maddness
22:45:20 <solrize> http://www.esolangs.org/wiki/Talk:Fractran   => database error
22:45:30 <Cale> faxathisia: The idea that mathematical theorems are in some sense "truths", and there's some "right" set of axioms.
22:45:40 <solrize> hmmw works now
22:46:23 * roconnor wonders if he is a Platonist.
22:46:26 <roconnor> probably not
22:46:33 <gwern> neat, we need luqui's blog on planet haskell
22:46:33 <Cale> faxathisia: Or taken further, the idea that there's some magical mathematical reality which mathematical statements discuss, and that this can really only be one way. The idea that mathematics is discovered, not invented.
22:46:36 <solrize> roconnor do you believe that the continuum hypothesis has a definite truth value?
22:46:52 <roconnor> solrize: certainly not
22:46:57 * luqui requested to have it added a few weeks ago... :-/
22:47:04 <solrize> ok, i think that means you're definitely not a platonist, but i'm not sure :)
22:47:09 <Cale> roconnor: You're from Waterloo, you're not allowed to be a Platonist ;)
22:47:33 <roconnor> solrize: but ask me abount lower level statement in the arithmetic heirarchy.
22:47:41 <roconnor> Cale: why do you say that?
22:47:42 * wli is more concerned with the problems before him.
22:47:55 <gwern> luqui: I think I'm going to put your code on my list of stuff to steal^Wupload to hackage
22:47:58 <Cale> roconnor: Despite this, you're also supposed to be fanatically pro-(axiom-of)-choice
22:48:07 * gwern clucks at the lack of cabalization
22:48:09 <faxathisia> lol
22:48:15 <roconnor> Cale: we did make a shirt. :D
22:48:19 <Cale> roconnor: :)
22:48:35 <roconnor> Cale: my views on the axiom of choice have changed somewhat.
22:48:56 <solrize> well do you believe the axiom of infinity?
22:48:59 <Cale> I like it. Of course, it's as "really true" as everything else in mathematics.
22:49:01 <wli> There are interesting counter-choice arguments.
22:49:19 <wli> For instance, try working in NFU vs. ZFC.
22:49:28 <roconnor> Cale: that axiom of choice doesn't hold, but it is okay to assume because it doesn't have any relevent consequences.
22:49:39 <Cale> roconnor: what do you mean by "doesn't hold"?
22:49:49 <roconnor> where relevent consequences are some subset of arithmetic statments.
22:49:55 <Cale> Doesn't hold in what system?
22:49:56 <wli> (In that case, the axiom of choice can be disproved, but other, weaker axioms to accomplish similar tasks come in.)
22:50:04 <solrize> if hte axiom of choice doesn't hold then there can be non-well-orderable sets
22:50:27 <roconnor> Cale: doesn't hold in type theory (using classical quantfiers)
22:50:28 <luqui> here's one of my favorite counter-choice arguments: http://cornellmath.wordpress.com/2007/09/13/the-axiom-of-choice-is-wrong/
22:50:31 <Cale> roconnor: heh
22:50:33 <solrize> maybe that means transfinite induction isn't valid ?
22:50:37 <luqui> because of that post, I am pro-life :-p
22:50:58 <Cale> Mathematical axioms can't be "wrong".
22:51:09 <Cale> They can be inappropriate to a particular application.
22:51:12 <luqui> Cale, sure they can.  unrestricted set comprehension?
22:51:14 <solrize> oh i read that post a while back, terry tao's answers cleared it up i think
22:51:23 <Pseudonym> luqui: "Inconsistent" isn't the same as "wrong".
22:51:23 <roconnor> the set of provable arithemetic statements is conserved under the addition of the axiom of choice.
22:51:24 <Cale> luqui: You just get a boring system.
22:51:26 <faxathisia> here is an axiom: 1 = 0
22:51:41 <Cale> faxathisia: add the other ring axioms, and you'll have the trivial ring.
22:51:43 <luqui> I was assigning a meaning to wrong since it didn't have one in that sentence
22:51:53 <roconnor> So everytime you use the axiom of choice to prove something about software, you could have proved it without choice.
22:51:56 <Pseudonym> Is the trivial ring a ring?  I thought that 1 /= 0 was an axiom.
22:52:02 <solrize> faxathesia, that axiom has no models but otherwise as borcherds says, its a perfectly good theory
22:52:06 <luqui> it depends on who you ask
22:52:17 <Cale> Pseudonym: It's a ring, but not a field.
22:52:24 <Cale> (at least around where I live)
22:52:24 <faxathisia> what is a model?
22:52:31 <gwern> 'I think particularly troubling is in the uncountably many colors case, where any given prisoner has no chance to guess his hat color correctly, and yet almost all prisoners are correct.' <-- gah! my little mind hurts
22:52:33 <Pseudonym> Right.
22:52:40 <Cale> solrize: It has models, we found one :)
22:53:06 <luqui> faxathisia, it's a set which assigns a set theoretical meaning to logical symbols
22:53:18 <Cale> I found that blog post on the axiom of choice entirely unconvincing.
22:53:34 <Cale> I replied to it in fact.
22:53:34 <luqui> faxathisia, so a model of PA is the set {0,1,2,3,4,...} with "standard addition and multiplication"
22:53:44 <roconnor> of course, the axiom of choice does hold in type theory with constructive quantifiers; however I don't think that's what mathematicians mean by the axiom of choice.
22:53:50 <Cale> The reason that the result seems unintuitive is that the prisoners have superhuman memories.
22:53:58 <roconnor> ... I suppose it is hard to tell what mathematicians mean.
22:54:01 <faxathisia> What does standard addition and multiplication look like?
22:54:05 <luqui> faxathisia, more illuminating (or confusing), there's another model of PA which has more crap in it than just {0, 1,2,3,4... }
22:54:13 <Cale> roconnor: Mathematicians can be assumed to be talking about ZFC, most of the time.
22:54:30 <Cale> roconnor: Or something so close to it that for ordinary discussion it doesn't matter.
22:54:38 <roconnor> Cale: they don't act much like they are assuming ZFC.
22:54:44 <luqui> faxathisia, they're just set-theoretic functions, including the elements (0,0,0),(0,1,1),(1,1,2),(42,60,102), etc.
22:54:44 <Cale> Sure they do.
22:54:54 <faxathisia> oh ok
22:54:55 <luqui> (that was addition)
22:54:56 <faxathisia> I nee
22:54:57 <faxathisia> *see
22:55:02 <roconnor> Cale: they keep assigning types to functions.
22:55:18 <faxathisia> How do you know 0 = 1 has no model?
22:55:54 <roconnor> @djinn (Void -> (), () -> Void)
22:55:57 <luqui> faxathisia, well it does actually.  {0} with 0 := 0, 1 := 0.
22:56:15 <luqui> faxathisia, a sentence that doesn't have a model is  exists x. x /= x
22:56:18 <faxathisia> what does := mean? (sorry for so many questions..)
22:56:29 <Cale> roconnor: I typically define a function f as a triple, (A,B,Gamma) such that Gamma is a subset of AxB such that for each a in A, there is exactly one b in B for which (a,b) is in Gamma. When f = (A,B,Gamma), we write  f : A -> B
22:56:30 <solrize> one of my professors was a platonist who thought the most important question in mathematics was whether CH is true
22:56:34 <luqui> faxathisia, I'm just assigning the logical symbol on the left to the object in the model on the right
22:56:39 <roconnor> := means equal by definition.
22:56:47 <faxathisia> ok because reflexivity is defining feature of =
22:57:05 <Cale> roconnor: So the type of a function is just a proposition regarding it.
22:57:07 <Pseudonym> Cale: I call that the graph of a function.
22:57:09 <luqui> yeah, we have assumed that in our logic
22:57:19 <Cale> Pseudonym: The graph, together with the domain and codomain.
22:57:22 <Pseudonym> Yes.
22:57:52 <Pseudonym> Well, those are parts of the graph, much like the set of nodes is part of a graph.
22:57:58 <Cale> Pseudonym: But you have to define it somehow. I just characterise functions by their graph, domain, and codomain (and you can really skip the explicit domain)
22:58:00 * wli realizes that numerical solutions to diffeq's naturally give his stuff input it can readily use.
22:58:15 <Cale> Pseudonym: The codomain doesn't come with the graph, unfortunately.
22:58:27 <luqui> faxathisia, for further exploration: the point of models was to give meaning to the completeness theorem, which is "every consistent set of sentences has a model"
22:59:59 <faxathisia> What is the difference between the sentences and the definition of the logic these sentences are in?
23:00:11 <faxathisia> or are those the same thing?
23:00:40 <Cale> faxathisia: Sentences generally refer to the strings of symbols which a particular logic is manipulating.
23:01:37 <Cale> faxathisia: That logic would itself be defined in some other system. (Which may, by necessity, involve some informalities, as you have to stop at some point :)
23:02:12 <faxathisia> turtles all the way down!
23:03:46 <roconnor> Logic on top of Coq on top of ML on top of C on top of ASM, on top of Intel on top of Physics.
23:03:51 <roconnor> done!
23:04:14 <faxathisia> :D
23:04:42 <Cale> ...on top of ZFC, on top of English on top of common sense
23:05:23 <roconnor> Cale: you don't really beleive in this ZFC nonsense?
23:05:32 <Cale> roconnor: ZFC exists :)
23:05:41 <Cale> roconnor: At least as something we can talk about.
23:05:45 <Cale> roconnor: I'm a formalist.
23:06:03 <solrize> cale, does zfc have a standard model?  :)
23:06:03 <luqui> roconnor, isn't there another ML after ML?
23:06:05 <Cale> roconnor: So I really don't care whether it's true in any greater sense than whether I like it.
23:06:08 <roconnor> sure, but you don't believe it makes a suitable foundation for mathematics.
23:06:09 <mrd> ZFC does not not exist
23:06:12 <faxathisia> Cale: Have you compared a ZFC proof of induction with one in CIC?
23:06:15 <Cale> roconnor: Sure I do.
23:06:29 <roconnor> Cale: what are you doing on #haskell?
23:06:36 <roconnor> we are all type theoriest here. ;)
23:06:40 <Cale> roconnor: Talking about ZFC, apparently.
23:07:02 <solrize> cic is like haskell and zfc is like lisp?
23:07:03 <Cale> I really don't care for type theory as a foundation for mathematics.
23:07:10 <faxathisia> I need to understand ZFC better
23:07:12 <Cale> It's fine for programming systems though :)
23:07:33 <roconnor> zfc is not like lisp.  zfc is like ... nothing.
23:07:38 <Cale> I'd go with a category theoretic foundation for mathematics sooner than I'd go for a type theoretic one, most likely.
23:07:43 <roconnor> math is programming systems.
23:07:46 * wli formulates a plan based on the SVD of a lower triangular matrix whose entries A_{i,j} are C(i, j - 1) when j - 1 <= i and 0 otherwise (here the matrix is 1-based, so an m by n matrix' indices would have rows i range from 1 <= i <= m and columns j range from 1 <= j <= n).
23:08:06 <faxathisia> Category theory as a foundation for maths? :D
23:08:10 <roconnor> well at least catagory theory is almost type theory.
23:08:13 <Cale> roconnor: I disagree. Programming systems are about convincing a computer. Mathematics is about convincing other humans.
23:08:16 <luqui> After studying ZFC for five years now, the way it "looks" in my head approximately matches the way perl "looks"
23:08:19 <roconnor> type theory is a predicative topos.
23:08:24 <luqui> which is kind of depressing
23:08:29 <faxathisia> hmmmm.... any books about Category Theory as a foundation?
23:08:33 <Cale> roconnor: The line is fuzzy of course, but the practicalities are quite different :)
23:08:33 <faxathisia> that I should read
23:08:46 <faxathisia> luqui: lol :D
23:08:57 <roconnor> Cale: computers are less flaky.
23:08:59 <Cale> faxathisia: Yeah, "Sets for Mathematics"
23:09:12 <Cale> roconnor: Heh, have you used a computer lately?
23:09:17 <solrize> lawvere
23:09:18 <faxathisia> ohh thanks for reminding me, I was meaning to get it after hearing about it a couple times
23:09:28 <roconnor> I'd trust a proof that convinces a computer more than a proof that convinces a human.
23:09:44 <solrize> faxathesia, http://en.wikipedia.org/wiki/Categorical_logic
23:09:55 <Cale> roconnor: I wouldn't trust a proof that convinces a computer more than a proof that convinces me.
23:10:22 <roconnor> really, I would.
23:10:29 <faxathisia> You could be convinced by a computer proof though
23:10:29 <roconnor> Given the proofs that I've created for homework assignments.
23:10:42 <roconnor> I wouldn't trust proofs that convince me.
23:10:45 <solrize> > 3^500 `mod` 100
23:10:49 <Cale> faxathisia: Only insofar as I could read it and take it apart myself.
23:11:14 <Cale> The fact that the computer says "yes, this is true", isn't very convincing to me.
23:11:26 <Cale> I'd really rather understand it myself.
23:11:26 <luqui> solrize, lambdabot is sleeping
23:11:30 <Cale> It is?
23:11:30 <solrize> oh ok
23:11:37 <Cale> damn, what is going on?
23:11:41 <Cale> I just restarted it.
23:12:07 <Cale> @bot
23:12:11 <lambdabot> :)
23:12:25 <roconnor> lambdabot is tries of Cale's anti-computer bigotry.
23:12:43 <luqui> okay, let's see if I was the one who made it explode...
23:12:50 <roconnor> :)
23:12:51 <luqui> @pl (\x -> x x) (\x -> x x)
23:12:51 <Cale> roconnor: Heh, it's being more of an example justifying it.
23:13:00 <Cale> luqui: You weren't.
23:13:01 <faxathisia> I agree with what Cale said in that .. software is ridiculously unreliable though
23:13:01 <lambdabot> ap id id (ap id id)
23:13:05 <lambdabot> optimization suspended, use @pl-resume to continue.
23:13:08 <Cale> luqui: It was already offline when you asked that.
23:13:22 <solrize> hmm that article about categorical logic is actually kind of lame, but i think that refounding math on category theory was basically started by lawvere
23:13:24 <faxathisia> but it's going to be possible to help this with computer theorem proving, isn't it?
23:13:42 <luqui> and it just gave me an answer to the questionable question
23:13:43 <Cale> In order to trust, say, the fact that Coq says "yes, this is true", I have to trust the proof that Coq itself is correct.
23:14:02 <roconnor> faxathisia: that's right.  Software is unreliable because it isn't developed making full use of dependent types.
23:14:02 <mrd> and coq is written in ocaml, /shudder
23:14:09 <luqui> http://citeseer.ist.psu.edu/153536.html
23:14:09 <faxathisia> Cale: There are strong normalizaition proofs you can get from the site
23:14:19 <BMeph> G'night, all. :)
23:14:25 <luqui> ^^ How to believe a machine-checked proof
23:14:42 <luqui> I actually didn't like that paper very much, but it seemed relevant
23:14:48 <mrd> there's a paper on how to believe a twelf proof
23:14:55 <Cale> And *even* if I do trust that proof is correct, the fact that Coq tells me that the machine-proof is true doesn't really enlighten me in any way.
23:15:11 <faxathisia> Cale: You can print out the proof
23:15:19 <faxathisia> ever hand check that it is correct
23:15:28 <luqui> still might not enlighten you
23:15:30 * roconnor finds the list of lemmas fairly enlightening.
23:15:32 <faxathisia> no it wouldn't
23:15:33 <Cale> faxathisia: Which is typically far less readable than one written in English prose.
23:15:38 <faxathisia> true..
23:16:11 <faxathisia> If you want prove a theorem on paper informally to explain ideas to someone .. it's a different thing
23:16:16 <dmwit> http://en.wikipedia.org/wiki/What_the_Tortoise_Said_to_Achilles
23:16:17 <roconnor> actually the list of lemmas, and maybe the dependency graph gives you most of the enlightenment.
23:16:45 <dmwit> Even if you believe the axioms, and you believe that the axioms imply the conclusion, you may not believe the conclusion.
23:17:05 <faxathisia> but I agree ... \x -> \y -> x is a very odd looking proof that a -> b -> a
23:17:37 <gwern> 'Isashiki Takahiro (1999) summarizes past attempts and concludes they all fail before beginning yet another.'
23:17:47 <faxathisia> I think some proofs, like that of induction are very descriptive
23:17:51 <gwern> honestly, it strikes as just a reformulation of Hume's attack on causality
23:17:55 <roconnor> faxathisia: you just have to read it.
23:18:33 <roconnor> faxathisia: assume A (labeled x), assume B (labeled y), by assumption x, we have A as required. QED.
23:18:41 <solrize> Prelude> (3^333) `mod` 1000
23:18:41 <solrize> 523
23:18:57 <solrize> that's a computer calculation that i believe more than i'd believe my own hand calculation
23:19:01 <luqui> For complex statements I find the constructive view, i.e. a program as a proof, usually much easier to think about than a deductive view
23:19:24 <dmwit> > logBase 2 333
23:19:34 <dons> matthew-_: hey, is there any reason we shouldn't all be running distract?
23:19:40 <luqui> i.e. translate "a implies (b implies a)" to "if I have an a, and I have a b, I can get an a"
23:19:49 * mrd prods lambdabot -- compute damn you
23:19:59 <solrize> luqui, is it possible to prove nonexistence of something that way?
23:20:08 <dmwit> Anyway, I don't think it would take that long to compute 3^333 `mod` 1000. =)
23:20:18 <gwern> dons: the dbts using monotone or mercurial or whatever?
23:20:19 <faxathisia> lem1 $   is using lemma lem
23:20:27 <Cale> While I'm a formalist in one sense, I also really dislike being overly formal in constructing and communicating mathematics. The reason for this is that Gdel's incompleteness theorems imply that we can never be certain that any given system will be inconsistent. Relying too closely on the particular details of any one system then makes your arguments fragile. If your assumptions are clear, but the particular formali
23:20:27 <Cale> sm isn't, then it makes it more believable that the theorem would be easily transplanted.
23:20:33 <luqui> solrize, for falsehood you can use "if I have an a, I can get anything I want"
23:20:43 <dons> gwern: yeah
23:20:43 <solrize> hmm
23:20:46 <faxathisia> case foo of A -> ... ; B -> ... -- how do you read this though?
23:21:12 <gwern> dons: then yes. while emailing with the dev, he mentioned he's very unhappy with it, dislikes both darcs and the dvcs it is backed on and so on
23:21:18 <gwern> dons: consider it unmaintained
23:21:24 <luqui> it's just a program
23:21:40 <roconnor> Cale: logical strength in Goedel's sense is simply a matter of how much induction is available.
23:21:43 <faxathisia> Cale: I thought you could prove a logic was consistent.. like any strongly normalizing lambda calculus is a consisntent logic?
23:22:12 <luqui> faxathisia, for weak systems you can prove consistency
23:22:16 <Cale> faxathisia: Oh, sure, but not systems useful for mathematics.
23:22:17 <luqui> but not once they get strong enough
23:22:27 <roconnor> Cale: which is in turn dictated by what inductive type you allow to be well founded.
23:22:31 <Cale> (not the whole systems, maybe parts of them)
23:22:34 <faxathisia> Yeah, CIC is strongly normalizing
23:22:45 <Cale> roconnor: You're being too particular to a given system ;)
23:22:47 <faxathisia> and you prove lots with that
23:23:00 <roconnor> Cale: I don't think I am.
23:23:41 <luqui> roconnor, maybe you're talking on a higher level than I am, but there's an incompleteness theorem for first order logic with +,*, and ^ but no induction schema
23:24:14 <Cale> roconnor: "type"
23:24:33 <Cale> roconnor: Most of the systems which I'm talking about don't have types, only propositions.
23:24:42 <faxathisia> types are propositions :S
23:24:44 <solrize> roconnor do you mean more powerful systems can prove induction up to bigger and bigger ordinals ?
23:24:53 <roconnor> yeah well, let's stick with how much induction you have then.
23:25:38 <faxathisia> what does it matter if you call it a type or a proposition?
23:25:43 <faxathisia> It's like using -> vs =>
23:25:48 <roconnor> luqui: you make an interesting point.
23:25:50 <Cale> roconnor: Okay, in what sense does the inconsistency generated by adding both choice and the axiom of determinacy to ZF have anything to do with induction?
23:26:24 <roconnor> Cale: it gives you False, which is the ultimate induction principle.
23:26:32 <solrize> hehe
23:26:35 <roconnor> or the postultimate induction principle.
23:27:02 <gwern>  False: the ultimate ratio logicum :)
23:27:13 <gwern> King Curry had it stamped on all his guns
23:27:14 <roconnor> Cale: actually let me think about that a moment.
23:30:56 <dons> gwern: the maintainer, aka matthew-_ ?
23:33:10 <roconnor> I think I might have to look at how that contradiction works.  I suspect it has to do with induction over a well order generated by the axiom of choice. :)
23:34:30 <Cale> roconnor: It happens because AD can be used to prove that every subset of R is measurable.
23:34:54 <Cale> roconnor: Which, well, at least to me seems really unrelated to induction.
23:35:06 <Cale> But maybe there's a way to strangely interpret it as such :)
23:35:34 <roconnor> yeah, but AC makes an unmeasurable set by placing a well-order on R, right?
23:35:45 <gwern> dons: I guess so. I never was good with names
23:35:59 <solrize> i thought there were some LC axioms consistent with AC that also proved every subset of R is measurable
23:36:04 <solrize> or were at least consistent with that
23:36:17 <Cale> roconnor: Well, that's one way.
23:36:37 <Cale> roconnor: You can also use AC more directly on a set of equivalence classes.
23:37:15 <Cale> (pick one element from each equivalence class given by the relation that x ~ y iff x = y + q where q is rational.
23:37:17 <Cale> )
23:37:56 <roconnor> ah right
23:38:18 <roconnor> anyhow, I'm not sure the AC AD thing has anything to do with Goedel incompleteness.
23:38:26 <mrd> ACDC?
23:39:46 <Cale> roconnor: Well, my point is that if we accidentally introduce an inconsistency into our system, not notice it for a long time, and then later have to fix things up, extra formalism in our proof style, making our proofs really dependent on the particulars of our system, will make it hard to transplant things into whatever new system we pick.
23:41:25 <roconnor> Cale: one should only make a system strong by allowing more inductive types.  ... I'm not certain of this, but I think so.
23:41:30 <roconnor> er
23:41:32 <roconnor>  more induction
23:41:48 <Cale> That seems like a strange way to build new mathematical systems.
23:42:02 <Cale> But I'm not entirely sure of the sense in which you mean "induction" here.
23:42:10 <roconnor> Cale: that's how they do it with large cardinal axioms
23:42:23 <roconnor> larger well-orders
23:42:39 <roconnor> bigger ordinals
23:43:01 <Cale> That much is true :)
23:43:09 <faxathisia> iirc induction is basically a catamorphism but over properties?
23:43:19 <roconnor> bigger ordinals give you longer chains to induct down.
23:43:24 <roconnor> or up
23:43:31 <roconnor> or whichever way induction goes.
23:43:33 <Cale> But it's not always clear that every extension you might want to make corresponds to some form of additional inductive power.
23:43:58 <roconnor> no that isn't clear, but it seems to hold from what I've seen.
23:45:18 <roconnor> it allows you to prove more programs terminate.
23:45:42 <roconnor> and proving programs terminate is what math is all about :P
23:46:08 <Cale> Well, that's a bizarre way to look at things :)
23:46:15 <faxathisia> hmm induction is a bit different
23:49:02 <faxathisia> How do you generate the induction principle for a give data type?
23:49:15 <faxathisia> like data N = Zero | Succ Nat ==> P Zero -> (forall n, P n -> P (Succ n)) -> (forall n, P n)
23:49:47 <faxathisia> It's a bit different to the fold z -> (N -> z) -> N -> z
23:50:17 <solrize> if it's like set theory it requires well-ordering on anything you do induction on
23:51:17 <dons> ?join #xmonad
23:51:19 <roconnor> forall P : X -> Prop, (forall P (inductiveHypothesis1 -> constructor1)) -> (forall P (inductiveHypothesis2 -> constructor2)) -> ... -> forall x, P x.
23:51:25 <dons> ?bot
23:51:29 <dons> Cale?
23:51:36 <solrize> the bot is down
23:51:42 <Cale> Ugh.
23:51:47 <Cale> It keeps dying.
23:52:00 <dons> bad patches? or what ?
23:52:03 <dons> server
23:52:17 <Cale> I haven't changed much.
23:52:43 <roconnor> ero
23:52:44 <Cale> Probably the server's fault, I don't see anything in the log which would indicate a problem.
23:52:50 <Cale> Lambdabot started at: Tue Mar 11 02:11:56 EDT 2008
23:52:50 <Cale> Initialising plugins ......................................sending message to bogus server: IrcMessage {msgServer = "freenode", msgLBName = "urk!<outputmessage>", msgPrefix = "", msgCommand = "NAMES", msgParams = [""]}
23:52:50 <Cale> .................. done.
23:52:55 <Cale> that's it.
23:53:07 <roconnor> forall P : X -> Prop, (forall params1, (inductiveHypothesis1 -> constructor1)) -> (forall params2, (inductiveHypothesis2 -> constructor2)) -> ... -> forall x, P x.
23:54:54 <dons> Cale, are you running it in a loop?
23:55:00 <Cale> no.
23:55:02 <dons> while true ; do ./lambdabot -e online.rc ; done -- :)
23:55:05 <Cale> Perhaps I should be?
23:55:08 <dons> run that in a screen session
23:55:17 <Cale> heh
23:55:22 <dons> that's how i've traditionally run it -- then it only dies if locked
23:55:32 <dons> -e 'rc online.rc' i mean
23:56:10 * allbery_b thinks he's glad he runs an out of date version that only suffers from the Network bug and occasionally hitting the heap limit
23:58:15 <sclv_> a screen session? sheesh... cooking up a reasonable daemonize library for haskell is looking more attractive by the day.
23:58:30 <sclv_> lambdabotd
