00:00:01 <mauke> falbani: each call to ht allocates a new hashtable
00:00:30 <falbani> faxathisia: I know, but I prefer to explicit the operation when I do not understand well what I am doing
00:01:04 <faxathisia> you got the explicitness wrong though
00:01:19 <faxathisia> you just everytime disregard the hash table and start fresh
00:01:28 <falbani> mauke: I thought that... but then I don't know how to use this datatype...
00:01:47 <mauke> new (==) hashInt >>= \ht -> ...
00:01:56 <hpaste>  bd_ annotated "Data.HashTable: Why the output is 0?" with "with do-notation, it's a bit clearer why it doesn't work..." at http://hpaste.org/6381#a1
00:01:57 <falbani> I couldn't find any example on google
00:02:21 <yoshi> how would I say.. the element before (e.g. the element before '5' "34567" -> '4' )
00:02:33 <falbani> bd_: thanks!
00:02:37 <hpaste>  bd_ annotated "Data.HashTable: Why the output is 0?" with "fixed version" at http://hpaste.org/6381#a2
00:03:09 <falbani> now this is what I call "being helped" :P
00:03:13 <falbani> Many thanks
00:03:45 <hpaste>  bd_ annotated "Data.HashTable: Why the output is 0?" with "er, fixed the fixed version >_>" at http://hpaste.org/6381#a3
00:04:38 <hpaste>  bd_ annotated "Data.HashTable: Why the output is 0?" with "for reference, a non-do version" at http://hpaste.org/6381#a4
00:05:33 <adu> so what would happen if you added "(Eq a, Eq b) => Monad m" to Monad? would anything break?
00:05:49 <mauke> I think you can omit those parens
00:06:05 <mauke> adu: that doesn't look valid
00:06:12 <mauke> what are a and b?
00:06:21 <adu> in the definition of the class
00:06:49 <falbani> hpaste is so beatiful...
00:07:25 <bd_> adu: You'd get "Not in scope: Type variable `a'"
00:07:52 <adu> bd_ so those don't apply to the body of the type class definition?
00:08:08 <bd_> adu: No, they apply as a precondition to the class itself
00:08:43 <bd_> I mean, each equation in the type class members has its own variables, for those not mentioned in the class itself
00:09:15 <adu> then what would happen if you added "(Eq a, Eq b) => " to each function member of "Monad"
00:10:05 <bd_> adu: You'd get Ambiguous constraint `Eq a'  At least one of the forall'd type variables mentioned by the constraint must be reachable from the type after the '=>'
00:10:13 <bd_> :)
00:10:29 <bd_> unless it actually was defined using a and b
00:10:36 <bd_> in which case it might well break other things
00:10:45 <mauke> wait, that would make join useless
00:10:54 <mauke> most monads aren't instances of Eq
00:11:10 <bd_> mauke: well, 'a' and 'b' wouldn't be the monad, they'd be >>= and >>'s contained type
00:11:19 <bd_> and return would break as above
00:11:24 <bd_> only with `Eq b' probably
00:11:28 <mauke> look at the type of join
00:11:34 <bd_> join isn't primitive
00:11:38 <bd_> or well
00:11:40 <bd_> it's not in the Monad class
00:11:48 <mauke> ... so?
00:11:50 <adu> (Eq a, Monad m) => m a
00:13:53 <wvd> hello
00:15:52 <Cale> hello
00:17:07 <bd_> mauke: so, adding things to equations in monad doesn't change much... though I see your point now, eventually you'd have to update Monad
00:17:10 <bd_> adu: hm?
00:17:24 <bd_> adu: class Monad m where ... <-- Monad's definition
00:17:26 <bd_> no 'a' there :)
00:17:37 <mauke> what do you mean by "update Monad"?
00:17:58 <bd_> mauke: er, update things which use >>= and the like
00:18:11 <bd_> which will rapidly explode as non-equalable values are often passed through monads
00:18:14 <mauke> my point is that it would make Monad useless
00:18:20 <bd_> and not a functor
00:18:24 <adu> bd_: yes, but in order for the Set type-class to work with monads, the 'a' in return, and (>>=) would have to support either Eq or Ord
00:18:50 <bd_> adu: You'd need Ord. Eq isn't enough for efficient lookup (O(n^2) is not fun)
00:18:56 <bd_> or some kind of Hashable
00:19:16 <faxathisia> longjmp(cglobs->cint.CompilerBotch, 2);
00:19:19 <adu> efficient is a relative term when you're talking about such cruft
00:19:35 <bd_> adu: anyway, someone made a set monad anyway. The trick is to take advantage of the fact that there are no side effects, and switch to just using a list when Ord isn't available
00:20:03 <mauke> faxathisia: :(
00:21:02 <bd_> hmm
00:21:11 <bd_> adu: here's one method, not the one I was referring to: www.randomhacks.net/articles/2007/03/15/data-set-monad-haskell-macros
00:21:44 <adu> thats the one i've been referring to all along
00:22:25 <bd_> adu: http://www.haskell.org/pipermail/haskell-cafe/2007-January/021086.html here's another
00:22:27 <lambdabot> Title: [Haskell-cafe] Monad Set via GADT, http://tinyurl.com/27dnbn
00:22:33 <bd_> which doesn't need redefining Monad
00:22:46 <adu> o cool
00:22:59 <adu> not redefining things is nice
00:23:24 <adu> except when redefinition allows for peace and harmony <3
00:24:43 <adu> getting tired...
00:35:08 <solrize_> adu
00:37:30 <mae> hello people
00:37:43 <solrize_> is there some reason why "comparing" is in Data.Ord but not in Data.List since it's usually wanted in conjunction with sorting functions
00:37:46 <solrize_> ?
00:37:49 <mae> this is like, haskell, the dynamically typed metaprogramming language, right?
00:38:02 <solrize_> lol, hi mae
00:38:40 <Vq^> mae?
00:38:57 <mae> solrize_:  i would guess because data.ord does things on ord objects, and Data.List has functions which can take any type of function when filtering lists
00:39:01 <solrize_> is that an s-expression in your pocket or are you just glad to see me...
00:39:05 <mae> so though they are related, they don't semantically belong together
00:39:15 <mae> Vq^:  yes?
00:39:35 <solrize_> yeah but there's other instances of stuff being grouped or duplicated for convenience...
00:39:46 <solrize_> i get tired of having to import so many modules to do simple things
00:39:59 <mae> this isn't perl
00:40:01 <mae> its haskell ; )
00:40:08 <Vq^> mae: are you protontorpedo? :o)
00:40:09 <mae> spend more time, do less debugging later.
00:40:16 <mae> Vq^:
00:40:19 <mae> nope i'm mae ; )
00:41:04 <cadr> Could someone answer a dumb newbie question?
00:41:13 <Vq^> cadr: absolutely
00:41:14 <mauke> the answer is 42
00:41:19 <cadr> oddly, it is
00:41:41 <Vq^> one might argue that the question is the wrong one then ;)
00:41:42 <mae> solrize_:
00:41:46 <mae> i feel your pain solrize
00:42:00 <cadr> I am just learning haskell, and I decided a source of fun exercises would be SPOJ, but I am getting stuck on their 'test' question
00:42:06 <mae> but really, its better this way IMO because there isn't as much namespace pollution
00:42:12 <cadr> http://www.spoj.pl/problems/TEST/
00:42:20 <lambdabot> Title: Sphere Online Judge (SPOJ) - Problem TEST
00:42:20 <hpaste>  cadr pasted "spoj test" at http://hpaste.org/6382
00:42:32 <solrize_> if they want to fix namespace pollution, make separate namespaces for sum datatypes
00:42:39 <solrize_> and records
00:42:42 <mae> solrize_:
00:42:57 <mae> solrize_:  they can't because of the type inferencing..
00:43:06 <mauke> cadr: putStrLn
00:43:18 <cadr> ah
00:43:23 <mae> there is a ghc extension which does allow unambiguous things to be resolved correctly though
00:43:57 <mae> it would be cool if you could have parametric polymorphism i agree
00:44:13 <mauke> cadr: main = interact (unlines . takeWhile (/= "42") . lines)
00:44:17 <mae> but actually you can already do this if your records use classes instead
00:46:07 <solrize_> i'd be ok with having to annotate those values explicitly
00:46:14 <cadr> mauke: yeah, that's the answer they have, but I haven't gotten as far as figuring out what "interact" does :)
00:46:20 <solrize_> Foo.Bar, Foo.Dog, Foo.Cat etc.
00:46:22 <mauke> :t interact
00:46:23 <lambdabot> (String -> String) -> IO ()
00:46:41 <mauke> interact takes a function and turns it into an IO filter
00:46:56 <mauke> that is, it takes the text from stdin, passes it to your function, and prints the result
00:47:18 <cadr> wow, neat!
00:48:12 <faxathisia> @src interact
00:48:12 <lambdabot> interact f = do s <- getContents; putStr (f s)
00:48:12 <cadr> :t takeWhile
00:48:13 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
00:48:41 <dobblego> Prelude> interact id -- I will type abc
00:48:41 <dobblego> aabbcc
00:52:42 <cadr> mauke: can you explain your much simpler version of the Test program to me a bit more?
00:53:18 <mauke> do you know what . does?
00:53:55 <cadr> well, I know it's function composition, though I am still a little confused about the difference between it and $
00:54:11 <cadr> (though they are probably completely separate things)
00:54:17 <mauke> right :-)
00:54:20 <mauke> f $ x = f x
00:54:33 <mauke> $ is just .. syntax. it doesn't do anything, really
00:54:41 <cadr> $ is just a short cut to get rid of extra (), right?
00:54:45 <mauke> exactly
00:54:55 <bd_> $ is just id :)
00:55:06 <cadr> id?
00:55:13 <mauke> @src id
00:55:13 <dobblego> identity
00:55:14 <lambdabot> id x = x
00:55:19 <dobblego> ?type ($)
00:55:20 <lambdabot> forall a b. (a -> b) -> a -> b
00:55:28 <cadr> ah, ok
00:55:33 <dobblego> (a -> b) -> a -> b is right associative so (a -> b) -> (a -> b)
00:55:42 <mauke> unlines . takeWhile (/= "42") . lines is a function pipeline
00:55:48 <mauke> you read it from right to left
00:56:06 <mauke> the input is first sent through lines, then takeWhile, then unlines
00:57:04 <solrize_> @hoogle [a] -> n -> ([a],[a])
00:57:05 <lambdabot> Data.List.genericSplitAt :: Integral i => i -> [b] -> ([b], [b])
00:58:18 <cadr> so, lines creates an array by splitting the input on newline characters, takeWhile consumes the array up until we get to a "42", and then unlines converts the array back into a string
00:58:30 <mauke> yes, except s/array/list/g
00:58:37 <cadr> right
01:01:22 <mauke> basically, we've turned the problem into data transformation, then used interact to make it do I/O
01:01:23 <solrize_> @hoogle (Num n) => [a]-> n -> [[a]]
01:01:23 <lambdabot> No matches, try a more general search
01:01:29 <solrize_> @hoogle [a]-> n -> [[a]]
01:01:29 <lambdabot> No matches, try a more general search
01:01:52 <solrize_> how do I get [1,2,3,4,5,6,7]  ->  [[1,2,3], [4,5,6], 7] ?
01:02:18 <solrize_> > groupBy (`div`3) [1..7]
01:02:22 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -> Bool
01:02:22 <lambdabot>     Prob...
01:02:31 <solrize_> ???
01:02:33 <faxathisia> solrize: Impossible
01:02:47 <faxathisia> [[1,2,3], [4,5,6], [7]] -- can be done though
01:02:56 <solrize_> yeah that's what i meant
01:03:07 <cadr> So, I get the general idea, but I'm still a little unclear about when the transformation gets called
01:03:26 <solrize_> > groupBy (\a b->a`div`3 == b`div`3) [1..7]
01:03:28 <lambdabot>  [[1,2],[3,4,5],[6,7]]
01:03:41 <solrize_> ugh
01:04:17 <solrize_> :t unfold
01:04:19 <lambdabot> Not in scope: `unfold'
01:04:24 <dobblego> :t unfoldr
01:04:25 <cadr> when I run main, I enter some data, it enter, and it immediately prints the response.  For some reason, I was expecting the responses to not be printed until I finally entered a '42'
01:04:25 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
01:05:08 <faxathisia> > let chunks n l = if length l < n then l else take n l : chunks n (drop 3 l) in chunks 3 [1..7]
01:05:09 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
01:05:09 <lambdabot>       Expected...
01:05:12 <Zao> cadr: Yay for laziness.
01:05:15 <cadr> ("hit enter", not "it enter")
01:05:22 <faxathisia> > let chunks n l = if length l < n then l:[] else take n l : chunks n (drop 3 l) in chunks 3 [1..7]
01:05:23 <lambdabot>  [[1,2,3],[4,5,6],[7]]
01:05:27 <faxathisia> > let chunks n l = if length l < n then l:[] else take n l : chunks n (drop 3 l) in chunks 3 [1..20]
01:05:28 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19,20]]
01:05:35 <solrize_> ugh
01:05:45 <mauke> cadr: that's interact cheating
01:05:52 <mauke> or rather, getContents
01:06:25 <mauke> cadr: the string it passes to your function doesn't actually exist yet; it's read on demand as the function progresses
01:08:18 <desegnis> > let chunks n = unfoldr (\xs -> case splitAt n xs of ([],[]) -> Nothing; xs' -> Just xs') in chunks 3 [1..20]
01:08:19 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19,20]]
01:08:33 <solrize_> let f xs = do { a<-listToMaybe xs; return $ splitAt 3 (fromJust a) }
01:08:48 <solrize_> oops
01:09:26 <solrize_> > let f xs = do { a<-listToMaybe xs; return $ splitAt 3 (fromJust a) } in unfoldr f [1..20]
01:09:26 <lambdabot>      Occurs check: cannot construct the infinite type: a = Maybe [a]
01:09:26 <lambdabot>       Ex...
01:10:26 <cadr> but what is doing the demanding?
01:10:26 <desegnis> solrize_: If you use the Maybe monad, with xs :: [a], then a :: a
01:10:46 <mauke> @src interact
01:10:46 <lambdabot> interact f = do s <- getContents; putStr (f s)
01:11:03 <solrize_> desegnis i'm confused
01:11:06 <mauke> cadr: the putStr, because it has to print stuff
01:17:04 <cadr> everything you've said has made sense, I'm just not sure it's soaked in yet. :)
01:17:26 <mauke> haha
01:17:38 <mauke> this may take some time getting used to
01:18:14 <cadr> yeah.  lazy made sense before this.
01:18:32 <cadr> But I have done very little IO so far in haskell.
01:18:57 <Cheery> how long are the internal graph nodes in haskell?
01:19:33 <mauke> if you're like me, this: http://mauke.ath.cx/stuff/haskell/how-to-io.html will explain the basics of the IO system
01:19:34 <lambdabot> Title: Haskell: How To IO
01:19:43 <mauke> if not, find another tutorial :-)
01:19:48 <Cheery> 8 bytes? 12 bytes? 16 bytes?
01:20:43 <cadr> thanks!
01:21:59 <FlamingCows> Can someone suggest a nice IDE for Haskell?  I'm using Visual Haskell right now, but it's choking on my updated ghc, and compiling by hand is starting to get tedious for incremental builds.
01:22:14 <mauke> eh? ghc --make
01:22:54 <FlamingCows> I'd rather have an IDE with integrated build commands, if anyone knows a good one...
01:23:01 <faxathisia> FlamingCows: I just run ghci in a terminal and then edit files with a text editor (emacs since it also syntax colors).. works well for me
01:23:12 <Heffalump> an updated Visual Haskell would be nice
01:23:21 <Heffalump> though TBH I found it quite flakey
01:23:26 <Zao> :set make_prg=runhaskell\ Setup\ build
01:23:39 <mauke> isn't it just makeprg?
01:23:41 <Zao> Err, makeprg, but you get the gist.
01:24:01 <mauke> just use mp, less opportunity for errors :-)
01:24:03 <Heffalump> I certainly would try to avoid Cabal while developing
01:24:04 <Cheery> faxathisia: I'm doing exactly same as you and going boing well forward
01:24:51 <FlamingCows> faxathisia: Yeah, that what I was going to do if no one suggested anything.  Except with vim instead of emacs. :)
01:25:00 <Cheery> some IDE would of course be cool, but what's the point? you eventually end up reimplementing either emacs or yi
01:25:21 <faxathisia> sure
01:26:04 <FlamingCows> Well, my other reason for asking is that VH has realtime error checking.  I know some people don't like that, but it's helped a bunch while I'm still getting the hang of Haskell.
01:26:33 <FlamingCows> I saw an Eclipse plugin, but it didn't look very mature or supported.
01:27:03 <Heffalump> people like Intellisense a lot
01:27:17 <Heffalump> once they get used to it they really miss it
01:27:51 <FlamingCows> Well, Eclipse is my first love for that sort of thing.  I'm only resorting to VS because it mimics Eclipse in that regard.
01:28:21 <Cheery> Heffalump: they won't if you give them an old MSVC++ (release 4 or 5)
01:28:42 <Cheery> because after that they hate it from bottom of their heart, because it generally sucked in those early versions
01:29:57 <Cheery> thought, one could have much more on graphs than they have for usual text interfaces
01:30:05 <Heffalump> yes, but it's very good now
01:30:53 <Cheery> what come to mind is simple-minded rewriting tools and such
01:31:42 <Cheery> for instance, changing the value name inside a function
01:32:08 <Cheery> or jumping into the type definition of some thing inside your environment
01:32:23 <Cheery> browsing through the libraries
01:32:30 <Cheery> hoogling them
01:32:32 <Cheery> etc.
01:32:42 <Cheery> one can invent bunch of that stuff
01:33:19 <Cheery> part of that would probably also prefer some sort of support from haskell environment itself
01:35:07 <Cheery> if I'd do an programming language, I'd really concentrate on toolsets within the language, making meta-circular interpreting successful, etc.
01:35:39 <Cheery> giving chance to exploit the internals with rage
01:36:02 <faxathisia> :D
01:36:35 <Cheery> giving way to embed nicely formatted graphs inside formats you create and give really clear way of handling them in another languages as well
01:36:56 <Heffalump> why doesn't hackage provide haddock docs online?
01:37:01 <Cheery> I just consider tools you use are that important
01:37:02 <faxathisia> I like a language you can just write code in with no regard what-so-ever of whether it will execute, then bend a metacircular interpreter towards what you had in mind til it's working
01:37:10 <Heffalump> is there some reason other than that noone has implemented it?
01:37:59 <faxathisia> lisps prolog haskell you can do this
01:38:24 <Cheery> faxathisia: yep, except I wouldn't actually use it so, rather other way around. But I rarely know what sort of code should I execute at times
01:38:24 <faxathisia> although it need not be totally circular
01:38:58 <Cheery> I prefer it would
01:39:52 <Cheery> internals of a functional programming languages are very valuable for programs as well, especially if well embedded into the language itself
01:40:21 <solrize_> meta ocaml ?
01:40:27 <faxathisia> Cheery have you seen LF?
01:40:32 <Cheery> nop
01:40:58 <Cheery> @where LF
01:40:58 <lambdabot> I know nothing about lf.
01:41:17 <solrize_> twelf
01:41:36 <faxathisia> citeseer is down :/
01:45:05 <dons> Heffalump: hmm?
01:45:14 <dons> "why doesn't hackage provide haddock docs online?" -- it does?
01:45:47 <Cheery> I'd like to have them provided offline, with some quick way to jump into them
01:45:55 <dons> Heffalump: http://hackage.haskell.org/packages/archive/cmath/0.2/doc/html/Foreign-C-Math-Double.html ?
01:45:56 <lambdabot> http://tinyurl.com/yr96me
01:45:58 <Cheery> without browser crappings
01:46:16 <hpaste>  morrow annotated "(no title)" with "(no title)" at http://hpaste.org/6379#a1
01:46:32 <mae> is there any clean / nice way of giving default values to haskell records or data types
01:46:57 <dons> mae, yeah, just describe a default value, then use record syntax to optionally override fields
01:47:13 <dons> its common to define an 'emptyFoo' value of :: Foo, with defaults set
01:48:20 <mae> dons: are you required to declare vars in a data declaration to use record syntax, or can you use it just by following the  same naming conventions?:
01:48:44 <dons> hmm?
01:48:46 <Heffalump> dons: ok, in that case how do I get to them from e.g. http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Takusen-0.8 (though I now notice that the "homepage" for that has some docs so my immediate problem is solved)
01:48:49 <lambdabot> http://tinyurl.com/2wj4qs
01:49:00 <mae> dons: can you epxlain the empty foo example a bit more
01:49:13 <dons> Heffalump: is there a build log link?
01:49:25 <dons> if the haddocks fail to generate, there'll be a link to a 'build log' with the failure report
01:49:32 <dons> mae: i'll write a quick exapmle
01:49:42 <Heffalump> ah, right. I see.
01:49:45 <mae> thank you
01:49:52 <Heffalump> and is hackage using 6.8 now?
01:51:06 <dons> yeah
01:51:10 <dons> and haddock 2.0, iirc
01:51:12 <dons> check the build log
01:52:03 <hpaste>  dons pasted "the joys of data types" at http://hpaste.org/6383
01:52:19 <mae> thanks dude you rock
01:52:38 <dons> creating new data types must be cheaper in haskell than just about any language. i love how data, and its shape, is treated seriously by haskell.
01:53:06 <scook0> it just occurred to me that if you have one or two fields you *don't* want to give defaults for
01:53:20 <scook0> you can turn the "default record" into a function that takes those as arguments
01:53:37 <dons> ah, and make them compulsory
01:53:37 <Heffalump> dons: it's pretty easy in ML too
01:53:40 <scook0> (though this won't let you pass them by name)
01:53:47 <dons> yeah, the ML family of languages
01:54:20 <mae> dons: ok so i have to explicitly set each to an initial value, no way to have this be done at compile time ?
01:54:22 <dons> sums, products and recursive types are foundational, and having the same syntax to introduce and eliminate structures makes interesting data structures cheap, simple , ubiquitous
01:54:38 <dons> mae, well, emptyT is a constant
01:54:43 <mae> ; )
01:54:46 <mae> k
01:55:01 <dons> but i guess you want, data T = T { foo :: Int ; foo = 7 } -- ?
01:55:02 <mae> would just be nice if they added an = sign to the declaration
01:55:04 <dons> it would be nice.
01:55:09 <mae> yeah ; )
01:55:20 <dons> the translation seems pretty straightforward too.
01:55:24 <mae> isn't this accomplished with the GADT extension for ghc
01:55:30 <dons> no?
01:55:53 <dons> Heffalump would know, but I'm not familiar with it, if that's the csae.
01:58:29 <Heffalump> I don't think it is
01:59:25 <Heffalump> rather, it certainly isn't, if you mean supplying default values
01:59:39 <dons> i'm not even aware of any discussion about such a feature
01:59:54 <dons> though i could imagine it lying around in a records proposal somewhere
02:00:05 <Heffalump> sounds like way too low power-to-weight to me
02:00:14 <dons> yeah. too rare to matter
02:00:25 <dons> big records that would need defaults are not common
02:01:03 <mae> hmm
02:01:29 <mae> is it considered "ok" to allow an undefined variable at runtime
02:01:32 <mae> or is that bad juju
02:01:38 <mae> i know the compiler screams and bitches
02:01:50 <dons> mae, you can use 'undefined' if you know you'll set it
02:01:54 <dons> or never access it
02:02:55 <Heffalump> I would suggest leaving the field out in preference to using undefined
02:03:02 <Heffalump> you'll get a much better error, even if -Wall complanis
02:03:48 <mae> hmm
02:04:04 <dons> yeah, if its really optional, perhaps use Maybe a ?
02:04:09 <dons> and default it to Nothing
02:04:13 <dons> then its harder to go wrong
02:04:14 <mae> yeah i know about that option
02:04:19 <mae> but it seems superfluous to use that
02:04:27 <Heffalump> I used undefined ones sometimes that I update with a value later on
02:04:28 <mae> why can't undefined be like nil in lisp or rub6y
02:04:35 <Heffalump> but it's sacrificing safety
02:05:06 <Heffalump> mae: semantic reasons, if you mean "why can't we check for undefined"
02:05:23 <mae> right exactly
02:05:26 <mae> hm ok
02:05:28 <Heffalump> undefined is semantically equivalent to non-termination; if you distinguished them, unboxing would become impossible, amongst other things.
02:05:54 <mae> k i think i understand  ; )
02:06:19 <muriel> kayess: hi :)
02:06:25 <mae> ok can i override record readers/writers
02:06:30 <mae> or is that also unchangeable
02:06:52 <Heffalump> you can't change the behaviour of the ones you get for free when you define the datatype, if that's what you mean
02:07:01 <mae> ok
02:07:11 <dons> Nothing is nil, in Haskell
02:07:15 <mae> right
02:07:47 <Syzygy-> ?src undefined
02:07:47 <lambdabot> undefined =  error "Prelude.undefined"
02:08:40 <mae> any way i can roll the record syntax for use on a class
02:08:47 <mae> or is that "static" datatypes only so to speak
02:09:43 <dons> well, class methods act as record accessors to the implicit class dictionary, i guess
02:09:43 <hpaste>  morrow pasted "sels" at http://hpaste.org/6385
02:10:10 <mae> is _ == undefined ?? the behavior seems the same
02:10:32 <Heffalump> _ doesn't exist as a value (except perhaps in JHC)
02:11:18 <dons> and in the ghci debugger :)
02:11:25 <mae> heh
02:11:25 <dons> its used as notation for bottoms, strangely
02:18:12 <luntain> newbe question: I have downloaded HTTP and Browser haskell modules and am trying to compile the example, which failes saying unknown package: network. I am compiling using with ghc -o main -package network -package data --make Main.hs
02:18:30 <dons> perhaps grab network from hackage.haskell.org
02:18:32 <dons> ?hackage network
02:18:33 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/network
02:18:41 <luntain> thx
02:24:05 <mae> whats the closest haskell equivalent to my hash in ruby
02:24:09 <mae> or dictionary in python
02:24:17 <scook0> probably Data.Map
02:24:47 <audreyt> or Data.HashTable
02:25:09 <Heffalump> no, Data.Map
02:25:15 <Heffalump> Data.HashTable is an imperative structure.
02:25:25 <Heffalump> very bad idea in Haskell unless you're certain you need it for performance reasons
02:25:46 * wolverian spies audreyt 
02:25:47 <solrize_> hsjudy
02:26:01 <audreyt> wolverian: hi :)
02:26:08 <wolverian> hi, nice to see you again!
02:28:57 <solrize_> dons is that joys of datatypes for your book?  i've been wondering why "data" is supposed to be more expensive than the equivalent newtype
02:30:00 <dobblego> newtype is not equivalent - it is specialised
02:30:41 <solrize_> dobblego i don't grok the difference
02:31:04 <mae> solrize_: newtype can only have 1 argument, data has 0 or more
02:31:11 <Heffalump> solrize_: newtype is guaranteed to have no overhead, data isn't
02:31:15 <dobblego> solrize, newtype has the restriction of one type constructor with one argument (iirc)
02:31:24 <dobblego> er, data constructor
02:31:25 <hpaste>  morrow annotated "sels" with "the rest" at http://hpaste.org/6385#a3
02:31:27 <solrize_> yes but if the number of args to data happens to be 1, why doesn't it do the same as newtype?
02:33:13 <scook0> the meaning is slightly different
02:33:51 * Heffalump finds the details of that hard enough to remember that he keeps a note of it
02:34:05 <solrize_> hmm do i need to care about the difference?
02:34:16 <scook0> usually not
02:34:22 <hpaste>  morrow annotated "sels" with "for completeness" at http://hpaste.org/6385#a4
02:34:35 <Heffalump> solrize_: to get close to newtype, you'd also need the arg to data to be strict.
02:34:39 <Heffalump> But even then it's not quite the same.
02:34:51 <solrize_> newtype uses strict args?!!
02:35:05 <scook0> in a manner of speaking
02:35:26 <scook0> bear in mind that in the compiled code, newtype completely disappears
02:35:30 <Heffalump> it's implicitly strict, because it doesn't exist at runtime
02:35:44 <scook0> it's as if you'd used the underlying type, except the compiler helps you with discipline
02:36:01 <solrize_> scook0 right, so where is the strictness?
02:36:05 <solrize_> Int isn't strict
02:36:16 <solrize_> newtype Foo = Foo Int   isn't strict either, i'd hope
02:36:26 <Heffalump> evaluating Foo Int to WHNF involves evaluating the Int to WHNF.
02:36:27 <scook0> it's strict in the same way that id is strict :)
02:36:29 <Heffalump> It's strict in that sense.
02:36:42 <Heffalump> Whereas with data Foo = Foo Int, Foo undefined is in WHNF.
02:36:50 <scook0> solrize_: what do you mean by "Int isn't strict"?
02:37:21 <luntain> newbe question: where do I find data package from?
02:37:52 <solrize_> heffalump i think i see what you mean.  scook0, x::Int ; let x = 2/0   doesn't crash.
02:37:54 <scook0> luntain: what specifically are you trying to use?
02:37:59 <dobblego> luntain, data is a keyword; do you mean Data
02:38:18 <luntain> trying to compile an example that comes with HTTP and Browser haskell modules
02:38:23 <Heffalump> data ! and newtype both have a single _|_, the difference is you can match it against Foo _ with newtype but not data !
02:38:24 <scook0> solrize_: sure, but that has nothing to do with Int
02:38:35 <Heffalump> (I found my note on the difference :-)
02:38:50 <luntain> the command line is ghc -o main -package network -pacakge data --make Main.hs
02:39:10 <scook0> solrize_: to put it another way, a newtype isn't any lazier than its underlying type
02:39:16 <scook0> whereas a data can be
02:39:36 <solrize_> aha, i think i get it now.  thanks
02:40:43 <scook0> to really understand what's going on, you need to be comfortable reasoning about lazy evaluation
02:41:12 <solrize_> yeah, i think i understand it
02:42:11 <luntain> newbe question: I am trying to compile and example for Browser and HTTP modules with the following command ghc -o main -package network -pacakge data --make Main.hs which gives me an error: unknown pacakge: data; when I ommit -package data arg I get Could not find module Base64
02:57:18 <luntain> newbe question: what does dollar operator do?
02:59:48 <dobblego> luntain, function identity i.e. nothing
03:00:14 <lament> luntain: a $ b c = a (b c)
03:00:19 <lament> very convenient
03:00:23 <siti> it saves brackets :)
03:00:29 <siti> and sanity sometimes ;)
03:00:40 <yondalf> @src ($)
03:00:40 <lambdabot> f $ x = f x
03:01:15 <yondalf> luntain: it's also right-associative...e.g a $ b $ c => a (b c)
03:01:52 <luntain> thx all
03:08:48 <Cheery> the xorg protocol really well specifies why security protocol should be separate from actual protocols
03:09:00 <Cheery> ugh. X11 protocol meant
03:09:23 <Cheery> if it isn't
03:09:28 <Cheery> it sucks, and a lot...
03:23:02 <arussel> I am trying to install Yi on debian. I installed libghc6-gtk-dev package, but "runghc Setup.hs build" gives "No frontend was compiled sucessfully. Giving up."
03:23:22 <ziman> are list comprehensions slow? i wrote a program generating a list of pythagorean triples [(x, y, z) | x^2 + y^2 == z^2] using a list comprehension and a more verbose one, not using list comprehensions at all. While the first one generates 500 triples in 5 seconds, the other one runs in just 0.2 s.
03:23:29 <arussel> Do I have to install gtk _and_ vty ?
03:23:54 <hpaste>  Ziman pasted "pythagorean triples" at http://hpaste.org/6386
03:30:59 <Heffalump> ziman: the list comprehension should desugar to something very similar to what you wrote explicitly.
03:31:19 <Heffalump> so I don't understand the speed difference
03:34:04 <Heffalump> the only think I can suggest is investigating the details of what ghc output for it by inspecting the core and C--, which is not a trivial job
03:34:43 <ziman> Heffalump, thanks, i'll take a closer look at it
03:35:31 <hpaste>  drdo pasted "xmonad.hs" at http://hpaste.org/6387
03:37:00 * czShadoW just registered domain haskell.cz.
03:37:00 <arussel> when I installed a package via debian, do I have to tell yi where debian has installed it ?
03:42:33 <wli> ziman: No, that's just a slow algorithm for pythagorean triples.
03:42:46 <Cheery> I want to write a spreadsheet app, do you know something that'd be useful?
03:43:26 <hpaste>  nominolo pasted "weird -main-is problem" at http://hpaste.org/6388
03:43:42 <nominolo> can someone help me with this --^
03:43:54 <nominolo> or have any idea what's going wrong?
03:45:00 <nominolo> oh. hm, recompilation problem
03:47:55 <Heffalump> wli: ziman is comparing two slow programs for the triples with each other
03:48:22 <Heffalump> same algorithm, one expressed with list comprehensions and one expressed with concatMap and filter, which list comprehensions desugar to
03:48:51 <Heffalump> the only thing I could think of that might be different (though I'm not sure) is the way some of the free variables are handled
03:49:20 <ziman> both are bruteforce
03:50:27 <Cheery> say, I'd like to write user interface for spreadsheet application in haskell, what is the shortest path to achieving this?
03:51:20 <FlamingCows> I'm trying to use map with printf, and ghc is saying there's an ambiguous type issue even though I add a specific cast to my list argument to map.  I assume the issue is that even though I cast the list, the compiler doesn't carry over that cast into map.  Is there a solution to this, or am I trying to do this The Wrong Way?
03:51:56 <Gilly> ziman: 3.78 for pyth2, 3.82 for pyth1 using time here
03:52:04 <Gilly> no optimization
03:52:10 <QtPlatypus> I would be also wrting the backend in haskell as well.
03:52:18 <Gilly> thus for me list comprehensions are faster
03:52:23 <Heffalump> FlamingCows: "cast"?
03:52:41 <FlamingCows> adding a signature.
03:52:41 <Heffalump> FlamingCows: :: is a type annotation rather than a cast, all it does is constrain types.
03:52:48 <xerox> FlamingCows: the ambiguous type is the return type of printf.
03:52:51 <Heffalump> paste your code and the error and I'll see if anything jumps out
03:52:58 <FlamingCows> map (printf "%02x") ([1,2,3,4,5]::[Int])
03:53:00 <Heffalump> oh, or what xerox said, that sounds plausible
03:53:07 <FlamingCows> So what should that look like?
03:53:18 <Heffalump> map (printf "%02x") ([1,2,3,4,5]::[Int]) :: [String]
03:53:20 <Heffalump> at a guess
03:53:21 <Gilly> 0.29 with -O for pyth1 and 0.71 with -O for pyth2 so this time list comprehensions lose big time
03:53:41 <FlamingCows> ANd, yeah, I know cast isn't the right word.  Just used to calling type annotations that from Java.
03:54:07 <FlamingCows> Ah, that worked great.  Thanks Heffalump.
03:54:18 <Heffalump> thank xerox, he explained the issue
03:54:21 <desegnis> ziman: The speedup comes from your filtering on the list of zs instead of the list of 3-tuples. I guess this means less constructor indirection
03:54:22 <Heffalump> :-)
03:54:28 <FlamingCows> Thanks xerox. :)
03:54:43 <xerox> :) you could do ":t printf" in GHCi for more clues.
03:55:10 <FlamingCows> Yeah, the return type of printf being an issue never even occured to me, though.
03:55:19 <Heffalump> desegnis: the list comprehension won't filter on the three tuples, will it?
03:56:33 <desegnis> Heffalump: er, right... I have to look again at the desugared version (with guard)
03:56:56 * Heffalump is just reading the report
03:57:30 <Heffalump> I think it will desugar to a lot of nested functions.
03:57:36 <Heffalump> I guess those aren't getting optimised properly.
03:57:44 <Heffalump> Gilly: how does -O2 compare?
03:57:51 <desegnis> > let pyth3 = [1..] >>= \x -> [1..x-1] >>= \y -> [1..y-1] >>= \z -> guard (x*x == y*y + z*z) >> return (x,y,z) in take 5 pyth3
03:57:52 <lambdabot>  [(5,4,3),(10,8,6),(13,12,5),(15,12,9),(17,15,8)]
03:58:10 <desegnis> > let pyth4 = [1..] >>= \x -> [1..x-1] >>= \y -> filter (\z -> x*x == y*y + z*z) [1..y-1] >>= \z -> return (x,y,z) in take 5 pyth4
03:58:11 <lambdabot>  [(5,4,3),(10,8,6),(13,12,5),(15,12,9),(17,15,8)]
03:58:37 <ziman> Gilly, I used -O
03:58:50 <desegnis> Heffalump, ziman: pyth3 is slow, and pyth4 is fast
03:59:28 <desegnis> pyth3 should be equivalent to the list comprehension
04:00:03 <desegnis> pyth4 filters the z list, similar to pyth1
04:01:51 <Gilly> 0.71 for pyth2 (-O2) and 0.09 for pyth1 (-O2)
04:02:02 <desegnis> But the difference in efficiency is still a mystery to me
04:02:24 <Gilly> i'm on core 2 duo if that interests
04:03:25 <desegnis> Gilly: The answer is likely not to be given by benchmarks, but by a GHC sciant
04:03:50 <Gilly> sciant?
04:04:01 <desegnis> well... guru
04:04:02 <Gilly> (sorry for my english)
04:04:08 <desegnis> it's French I think :)
04:04:17 <Gilly> ah ok :) well - i know that but Heffalump asked how it goes with -O2 :P
04:04:28 <desegnis> ah right
04:04:30 <Heffalump> yes, I was just interested
04:04:53 <ziman> well, the difference is filtering the triplets vs. filtering the z-list, if i understand correctly
04:04:53 <Heffalump> seems like pyth1 is much more susceptible to optimisation
04:05:19 <desegnis> ziman: I think I got it wrong when I said that
04:05:56 <Heffalump> I really don't understand the difference between pyth3 and pyth4.
04:06:11 <Gilly> this is an interesting problem, as we should favor [|] over those filters by hand
04:06:26 <Heffalump> this is definitely one for dons and dcoutts, IMO
04:09:17 <desegnis> @seen dons dcoutts
04:09:17 <lambdabot> dons is in #xmonad, #haskell-soc and #haskell. I last heard dons speak 1h 50m 45s ago.
04:09:32 <desegnis> @seen dcoutts
04:09:32 <lambdabot> I saw dcoutts leaving #gentoo-haskell, #haskell, #ghc, #haskell-overflow and #haskell-soc 10h 46m 34s ago, and .
04:10:12 <desegnis> Looks like we have to wait a while :)
04:11:20 <EvilRanter> it's saturday, duncan probably won't be up 'til noon at least :P
04:12:53 <EvilRanter> ... someone ?localtime'd me. who did that?
04:12:57 <EvilRanter> ?localtime
04:12:58 <lambdabot> Local time for EvilRanter is Sat Mar 15 11:12:52
04:13:48 <Gilly> ?localtime
04:13:52 <lambdabot> Local time for Gilly is Sat Mar 15 13:13:51 2008
04:13:58 <Gilly> ah it goes with ctcp :P
04:14:11 * EvilTerran is tempted to tamper with his CTCP reply now
04:14:19 <smg> Gilly: i guess you can query lambdabot to ask for localtime etc :]
04:14:20 <desegnis> EvilRanter: I wanted to know whether you are in the UK or the US, to know what »til noon« means
04:14:30 <EvilTerran> k
04:14:39 <Gilly> smg: somehow i find it easier to read it on my irssi status bar
04:14:42 <Gilly> thanks for suggestion though
04:14:43 <Gilly> :P
04:14:59 <EvilTerran> (i've already tampered with my VERSION response, so it now says "VERSION xchat 2.8.4-1 Unicos/Ic [AMD Opteron 96*2.6GHz]" :D)
04:15:47 <EvilTerran> ?seen dcoutts_
04:15:47 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell-overflow, #haskell and #ghc. I last heard dcoutts_ speak 1d 17h 55m 1s ago.
04:15:53 <EvilTerran> hm. even longer ago.
04:17:21 <EvilTerran> well, anyway, dcoutts - and myself - are british, and he's a student (albeit a doctoral one), and it's weekend, so he probably won't emerge for a while :P
04:18:24 <EvilTerran> heck, it's perfectly reasonable, too - i'm quite often blathering away on here 'til 3am, 4am - and he seems to usually still be on here as i'm going to bed
04:18:48 * Heffalump got up at 7:45 today :-(
04:19:56 * EvilTerran got up at 11, as term starts again in a month and he needs to start sorting his sleeping patterns out now. otherwise i'd probably've got up later. ;)
04:20:29 <EvilTerran> anyway. this is all very off-topic.
04:20:33 <EvilTerran> 'boud those lambdas.
04:21:03 <desegnis> ^^
04:21:19 <EvilTerran> come back! they're not *that* scarey!
04:21:57 <Gilly> :)
04:22:08 <EvilTerran> come look at this one, it's cute and flu-OW! ... dammit, the cute fluffy ones have vicious teeth...
04:25:03 <desegnis> Gilly: Sorry. Turns out I wrote sciant, but meant savant.
04:25:15 <Gilly> desegnis: Ah, I see :)
04:26:14 <Gilly> Well, my english isn't that bad, but it's not so good either that I could argue the word 'sciant' didn't exist :)
04:26:38 <EvilTerran> 91,900 google hits agree with you ;)
04:26:48 <Gilly> *g*
04:27:25 <EvilTerran> "Bulgaria's leading IT outsourcing company Sciant"
04:27:53 <Gilly> is that also a /giant/ company?
04:28:05 <desegnis> even worse, I checked:
04:28:12 <desegnis> French sciant means boring
04:28:15 <EvilTerran> apparently it was acquired by VMware
04:28:23 <Gilly> hehe
04:28:39 <desegnis> bless my foreign language education
04:29:30 <Gilly> same for me... i took a german exam yesterday, it was part of finnish matriculation examinations, didn't go that well :P
04:32:18 <desegnis> oh, I always had good marks in French at high school, but I didn't learn anything there
04:34:12 <Gilly> same for me... got mainly 9s (scale is from 4 to 10, 10 being the best) but can barely speak it at all
04:34:18 <Gilly> i mean german
04:36:03 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/6389
04:50:44 <luntain> newbe question: If I compile an example code against a third party module (HTTP.hs) and get typing errors only in HTTP.hs, does it mean that the HTTP.hs has problems  (not compatible with new version of haskell compiler or sth) or is it more likely that I call it wrongly?
04:51:12 <Heffalump> it means that HTTP.hs has problems
04:53:12 <desegnis> luntain: You may double-check by trying to compile HTTP.hs on its own
04:54:49 <luntain> desegnis: ghc HTTP.hs prints out the same typing error, so there is sth wrong there...
04:57:34 <luntain> I want to do a simple http request, any easy way to do it in Haskell? Or maybe I should not have picked that project for learning Haskell :)
04:58:50 <Baughn> luntain: Should be pretty easy, but perhaps you should use http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HTTP-3001.0.4 ?
04:58:52 <lambdabot> http://tinyurl.com/282fmq
04:59:36 <luntain> Baughn: thx, I'll check it out
05:00:05 <Baughn> luntain: You can get it with cabal-install. Of course, you need it installed already to /compile/ cabal-install.
05:00:38 <Baughn> luntain: You could use http://brage.info/~svein/cabal if you're on x86_64, I guess
05:02:11 <Baughn> luntain: Anyway, then you just use Network.HTTP.simpleHTTP
05:08:24 <nominolo> @pl (\i -> pangoShape i >>= glyphItemExtents >>= print)
05:08:25 <lambdabot> (print =<<) . (glyphItemExtents =<<) . pangoShape
05:10:46 <opqdonut> :)
05:11:41 <Saizan> pangoShape >=> glypghItemExtents >=> print
05:58:43 <skorpan> not a lot of activity right now
06:10:13 <Peaker> Hi. Can Haskell be used as an "object capability" langauge? Can any Haskell construct map to the concept of "capability"?
06:10:34 <skorpan> que
06:11:14 <byorgey> Peaker: I'm not sure what you mean.  Can you give an example of an "object capability" language?
06:11:26 <Peaker> byorgey, Erights is one
06:11:44 * byorgey googles
06:11:47 <Peaker> byorgey, Object capabilities: http://en.wikipedia.org/wiki/Object-capability_model
06:11:48 <lambdabot> Title: Object-capability model - Wikipedia, the free encyclopedia
06:12:47 <Peaker> Basically, the idea is that the language can be used to enforce security, rather than an OS or permission check mechanisms, if the language can guarantee certain things
06:13:43 <Peaker> Under normal existing systems (non-functional, maybe) a reference designates an object to be used, and a separate permission list authorizes the use of that reference
06:14:14 <Peaker> With object-capability systems, a reference both designates an object, and represents the authority to use it - making permissions checks unnecessary
06:14:22 <byorgey> interesting
06:15:12 <Peaker> An obj-cap system will not have an "open" call which translates a filename to a capability to use that file, but instead pass around the capability instead of the filename in the first place
06:15:36 <Peaker> (which means we don't have to keep an access-control-list on the file, or attach "userids" to processes/etc)
06:15:54 <byorgey> you could certainly model that in Haskell, and use the type system to statically enforce certain properties
06:16:09 <byorgey> but I don't know whether Haskell would be particularly suited to that particular model.
06:17:01 <Peaker> you could say that file object references are being passed around between monadic functions when they want to use the file, right? And then have the main function take these files, and remove the "open" function?
06:17:44 <byorgey> well, there's no way really to have the main function "remove" the open function
06:17:52 <Peaker> I mean remove it from Haskell
06:18:27 <byorgey> but then how would you use it?  you don't want to remove it entirely, just restrict the places where it can be used, right?
06:18:53 <dozer> right - you want to make it accessible in some circumstances and inaccessible in others
06:19:06 <Peaker> byorgey, the place it can be used can simply be the wrapper code around main (not visible to the Haskell program)
06:19:23 <Peaker> Ideally, I'd want to remove "open" altogether, and allow passing around file objects instead of strings
06:19:31 <Peaker> (in the entire system, not just Haskell)
06:19:43 <dozer> anyone here used MonadRandom?
06:20:30 <Peaker> byorgey, I have an ambitious project to recreate the software world with obj-caps instead of the current "ambient authority" models (and a bunch of other ideas for the new software world :-)
06:20:49 <Peaker> And I am wondering whether Haskell is the correct foundation to base this world on
06:21:26 <Peaker> I have to write a project or two in Haskell first, ofcourse, but as of now I have only read some of the tutorial :)
06:22:22 <byorgey> Peaker: well, Haskell certainly does have much to offer towards statically guaranteed security/capability properties through the type system, I'm just not sure whether it would be good for an object-capability model in particular.
06:22:33 <byorgey> by "I'm not sure" I mean I'm really not sure, not that I think it isn't.
06:22:42 <byorgey> but in any event you should definitely learn Haskell. =)
06:22:50 <Peaker> byorgey, yeah, I'm working on it :)
06:22:51 <Baughn> Peaker: So, you're going to rewrite the world.
06:22:54 <Baughn> ..good luck
06:22:57 <Peaker> Baughn, :-)
06:23:29 <Peaker> Baughn, I think the task is overstated - the software world contains a lot of code, but not really that much essential functionality. Most functionality is used to work around horrible architecture decisions
06:23:51 <Baughn> Peaker: While you're at it, I'd like to note that (a) GC makes much more sense in the kernel than in single programs, and (b) program separation by MMU makes /no/ sense
06:23:56 <Peaker> Baughn, Creating a compatible world is hard, but creating a world with equivalent functionality is probably not that huge as it seems
06:24:21 <Peaker> Baughn, Agreed on both points. I don't think "processes" or hardware protection is the right model
06:24:23 <Saizan> Peaker: but, how do you identify files here? i.e. distinguish one from another
06:24:36 <Peaker> Saizan, They are simply two different file objects
06:24:40 <Baughn> Peaker: IIRC there's an experimental haskell-based OS.. somewhere
06:24:42 <desegnis> Peaker: Does  "recreate the software world" mean "invent a formal model of a new operating system"? or something completely different?
06:24:45 <Peaker> Saizan, whenever you have a file name, just use a file object
06:24:58 <Baughn> Peaker: Though I suppose it'd work just as well to start with linux and only ever have a single process running on top of it
06:25:20 <Saizan> Peaker: ok, but you don't present files as objects to the user, right?
06:25:22 <Peaker> desegnis, I want to create a new OS, but also new architectures for everything from human interaction with the computer to the web
06:25:38 <Peaker> Baughn, yep, that's our idea for bootstrapping
06:25:54 <Peaker> Saizan, The user is presented with file and directory objects,  why not?
06:25:57 <desegnis> Peaker, ah, so Baughn was right and you're really going to rewrite the world :)
06:25:58 <Baughn> Peaker: "our"?
06:26:12 <Peaker> Baughn, Yeah, me and a few friends are working on it with our (very little) spare time
06:26:23 * Baughn has seen this sort of thing before
06:26:30 <Peaker> Baughn, We intend to allocate our full time to it in a while (once we are financially capable)
06:26:35 <desegnis> Peaker: How are those objects distinguished for the user?
06:26:52 <desegnis> Peaker: I mean, UI-wise
06:27:00 <Peaker> desegnis, Depends on who is referencing them - if they are in an object database, then that database has metadata for each one that can be displayed
06:27:20 <Baughn> Peaker: One major problem is that, without separation, you /have/ to distribute programs in a form that don't allow them to corrupt the system when run. Source, fore xample.
06:27:38 <Peaker> Baughn, yeah, or a mid-level representation
06:27:49 <Baughn> Peaker: More work, but probably better, yeah. ;)
06:27:55 <desegnis> Peaker: What if, incidentally, the metadata is identical? Then you'd need an ID, just like a primary key in a database
06:28:05 <Baughn> Peaker: At least you have the major advantage of immutable data
06:28:15 <Peaker> Baughn, We believe that code should always be semantically encoded, not "text-encoded" at any stage, and that smart UI editors should edit that semantic representation directly. I believe it makes smart editors much more practical, and language extensibility much easier
06:28:37 <Peaker> desegnis, well, an object has identity in object systems. Not sure how that would map to Haskell, though
06:28:43 <Saizan> desegnis: yeah, my point, also i don't want to remember a random ID, but a name :)
06:29:00 <Peaker> Saizan, desegnis : The metadata of an object inside a database can contain a name, ofcourse
06:29:03 <Baughn> Peaker: Freeform filesystems do have their advantages
06:29:22 <desegnis> Saizan: yeah, because the ID or primary key could just as well be the name of the file
06:29:27 <Peaker> Have you guys seen subtextual?
06:29:47 <Saizan> Peaker: so if the user tells you to use the file with name "foo" you need an open.
06:29:58 <Baughn> Peaker: Perhaps you could go with a true relational database - one where /relations/ are the basic unit, instead of tables/rows
06:30:21 <Peaker> desegnis, Saizan: Its ok to have a database that looks like a regular filesystem hierarchy with string names - and then something like open() which actually searches this database - but permissions checks should be replaced by simply passing around references only to the subset of the world to which you have authority
06:30:37 <Peaker> Saizan, if the user can see and express access to "foo" then he is already authorized to do it,
06:30:58 <Peaker> Saizan, so if I have a database search somewhat similar to open, it would not need to do permissions checking.
06:31:15 <Peaker> Baughn, Yeah, I think using a relational database makes more sense than a string hierarchy in any case
06:31:45 <Baughn> Peaker: It needs to allow ad-hoc relations, otherwise the user will get very frustrated. In other words, just a true relational db..
06:31:55 <Peaker> Baughn, and that this database should not hold all objects, just organize objects for the user. For example, "system file" equivalents would just be objects referenced by other system objects directly, without sitting in the database
06:32:56 <Baughn> Peaker: Sure. Any object could reference another object, especially without process boundaries - the database is just so you can find them later, if you ever /drop/ the reference
06:33:07 <desegnis> Sounds like a very consequent abstraction away from the hardware
06:33:13 <Baughn> Peaker: While you're at it, use a single-level store. ;)
06:33:20 <Peaker> Baughn, I don't think I'd "drop" the reference :)
06:33:36 <Peaker> Baughn, yep :) RAM should be a transparent cache
06:34:00 <Peaker> Baughn, so far it seems you are very much aligned with our ideas :)
06:34:00 <Baughn> Peaker: When you close a word-processing application - or, close the document anyhow; I'm not sure closing the /application/ makes sense at all - the reference to the document is dropped
06:34:14 <Peaker> Baughn, "Applications" don't make sense without processes. The "word" object is just a document
06:34:22 <Baughn> Peaker: I've been thinking about it for years. I just don't think it's very likely to work
06:34:22 <Peaker> Baughn, oops, just an object
06:34:38 <Peaker> Baughn, and "Word" is a widget/UI attached to that object and removed at will
06:34:46 <Peaker> Baughn, why wouldn't it work?
06:34:55 <Baughn> Peaker: Market forces
06:35:10 <Baughn> Peaker: That's not to say I wouldn't enjoy trying. Say, do you have an irc channel?
06:35:12 <Peaker> Baughn, That may very well be - but wouldn't you like to see this working _technically_?
06:35:25 <Peaker> Baughn, Yeah, #enough
06:35:30 <Peaker> (As in Enough Lame Computing :-)
06:36:34 <kpreid> Peaker: have you seen the recent discussion on the cap-talk mailing list?
06:36:45 <Peaker> kpreid, nope, what was it about?
06:37:01 <kpreid> exactly what would or wouldn't need to be done to Haskell's standard library to make it an objcap system
06:37:17 <Peaker> kpreid, oh my. awesome timing :)
06:50:41 <skorpan> if i have data A = B | C and B = D and i have a function which returns an A, can i then return a D?
06:50:53 <skorpan> if data B = D that is, not type
06:51:19 <EvilTerran> no
06:51:29 <byorgey> skorpan: that would be a syntax error.
06:51:30 <EvilTerran> the first B is a value constructor, the second is a type constructor
06:51:30 <skorpan> okay, thanks
06:51:34 <EvilTerran> they're wholly independent
06:51:39 <EvilTerran> different namespaces
06:51:43 <desegnis> skorpan: You must carefully distinguish types and values in Haskell
06:51:44 <byorgey> oh, right, sorry
06:51:46 <skorpan> yes, that's what i thought
06:52:19 <skorpan> brb
06:52:47 <Peaker> kpreid, I can't find it in the lists
06:52:53 <Peaker> kpreid, in the archive of cap-talk I mean
06:53:48 <Myriad> Hello everyone...
06:54:40 <kpreid> Peaker: http://www.eros-os.org/pipermail/cap-talk/2008-March/010307.html is the thread start
06:54:42 <lambdabot> Title: [cap-talk] Abstractions that subsume capabilities
06:54:44 * kpreid is gone now
06:57:11 <Myriad> I'm looking for help with generating XML with HaXML - I think I an get it to consume XML but I cannot figure out how to output the XML
07:00:58 <skorpan> is it true that there is no Error monad, but only a type class?
07:01:25 <SamB> it's called Either, actually
07:01:28 <SamB> so yes and no
07:01:35 <skorpan> so Either is the monad?
07:01:39 <SamB> yes
07:01:44 <skorpan> okay, thanks
07:02:14 <SamB> there is an ErrorT as well, in case you hadn't noticed
07:02:36 <skorpan> yes, i noticed
07:03:04 <skorpan> it's a bit unintuitive, at least for me, that there is a monad transformer ErrorT but no Error
07:03:49 <resiak> Just pronounce "Either" as "Error" :)
07:04:00 <skorpan> ah! :) or ErrorT as EitherT
07:09:04 <SamB> I think they should have put in a typesynonym ...
07:43:46 <fxr> > sort "1234"
07:43:49 <lambdabot>  "1234"
07:43:55 <fxr> :t sort
07:43:56 <lambdabot> forall a. (Ord a) => [a] -> [a]
07:44:06 <fxr> @hoogle sort
07:44:10 <lambdabot> Data.List.sort :: Ord a => [a] -> [a]
07:44:10 <lambdabot> Data.ByteString.sort :: ByteString -> ByteString
07:44:10 <lambdabot> Data.ByteString.Char8.sort :: ByteString -> ByteString
07:44:19 <skorpan> how do you pronounce chess' "en passant"? "awn passawn"?
07:44:29 <fxr> @hoogle sortyBy
07:44:29 <lambdabot> No matches found
07:44:33 <fxr> @hoogle sortBy
07:44:33 <lambdabot> Data.List.sortBy :: (a -> a -> Ordering) -> [a] -> [a]
07:45:00 <fxr> > reverse . sort $ "1234"
07:45:01 <lambdabot>  "4321"
07:45:20 <fxr> > compare 1 3
07:45:20 <lambdabot>  LT
07:45:31 <fxr> > flip compare $ 1 3
07:45:31 <lambdabot>   add an instance declaration for (Num (t -> a))
07:45:33 <skorpan> > compare "hello" "olleh"
07:45:34 <lambdabot>  LT
07:45:46 <fxr> > sortBy (flip compare) "1234"
07:45:47 <lambdabot>  "4321"
07:45:55 <fxr> oh finally
07:50:46 <Plouj> hi
07:51:22 <fxr> > properFraction 10.12
07:51:23 <lambdabot>  (10,0.11999999999999922)
07:51:42 <fxr> hmp
07:51:53 <fxr> it says "takes a real fractional number x  and returns a pair (n,f) such that x = n+f"
07:52:03 <Plouj> why am I getting this error when linking Frag: http://pastebin.ca/943705 ?
07:52:11 <Plouj> errors*
07:52:27 <fxr> > let (a,b) = properFraction 10.12 in a+b
07:52:28 <lambdabot>  Add a type signature
07:52:58 <skorpan> > let (a,b) = properFraction (10.12 :: Float) in a + b
07:52:59 <lambdabot>   add an instance declaration for (Integral Float)
07:52:59 <lambdabot>     In the expression: pro...
07:53:03 <skorpan> fsck
07:53:11 <Cin> Plouj: it looks like you need opengl
07:53:28 <Plouj> I have various opengl -devel packages installed...
07:53:32 <Cin> Plouj: why aren't you using cabal to build it?
07:53:44 <Plouj> should I?
07:53:49 <Peaker> kpreid, "When combined with types, RT is a powerful reasoning tool" <- RT?
07:54:02 <Plouj> Cin: because the non-cabal instructions appear first in the README
07:54:20 <Cin> plouj: okay
07:55:15 <Cin> plouj: i don't know why that's happening
07:55:16 * Plouj tries with cabal
07:57:15 <Plouj> runghc Setup.hs build gives me the same error
07:59:01 <Cin> plouj: so there are various gl packages that'll need to be installed, if i remember correctly. the gl runtime, the development packages, and the haskell libraries?
07:59:15 <Plouj> well
07:59:42 <Plouj> I installed HOpenGL
07:59:48 <Plouj> into $HOME
08:01:03 <Cin> presumably the haskell library is installed otherwise you would be having compiler errors, not linker errors
08:01:32 <Cin> perhaps the gl library itself is not installed on your system. i don't know how to verify that
08:01:53 <Plouj> I have /usr/lib64/ghc-6.8.2/lib/GLUT-2.1.1.1/libHSGLUT-2.1.1.1.a which came with Fedora's ghc682.x86_64 package
08:02:16 <Cin> plouj: is GLUT installed?
08:02:28 <Plouj> just checking that
08:02:34 <Plouj> yup, it is
08:02:49 <Cin> plouj: and GLUT-dev or whatever your operating system calls it?
08:02:49 <Plouj> freeglut-devel, that is
08:02:56 <Cin> ah, hm
08:03:02 <Jaak> you need to modify your library path
08:03:19 <Plouj> Jaak: where and when?
08:03:57 <Jaak> i think, atleast
08:04:16 <Jaak> if you installed into $HOME linker might not know to look into $HOME/lib/
08:04:20 <Saul_> I've had to do a presentation on Eros earlier this week (it's a visual programming environment based on haskell) and just now I was playing Titan Quest (which is a Diablo type of computer game)
08:04:29 <Saul_> This got me thinking to combine the two
08:05:10 <esteth> I'm having difficulty with some basic pattern matching. how come [x] matches the list with only one item instead of a list of items, and how come it's (x:xs) to capture the head and tail of a list instead of [x:xs] like in the previous example?
08:05:14 <Saul_> In Diablo and Titan Quest you have these runes that you can put into your weapons and armor to enhance their abilities
08:05:37 <Cin> esteth: [x] is the same as (x:[])
08:06:09 <Saul_> so those are basically functions from equipment to equipment
08:06:29 <Saul_> although in those games you could only apply one rune to a piece of equipment
08:06:32 <Cin> esteth: does that answer your question?
08:06:54 <Saul_> so my idea was to make those runes act like functions in haskell
08:07:10 <Saul_> so you can apply one to a weapon and get a new enhanced weapon
08:07:12 <Cin> esteth: further... pattern-matching usually looks like how the value that you're matching against was constructed, if you follow
08:07:16 <Saul_> and then apply another
08:07:56 <Cin> esteth: so if you have a list of [1], then you use the way it was constructed to match against it, [x]. or, indeed, (x:[])
08:07:59 <Saul_> and then this can be used to explain things like polymorphism and higher-order functions to non-programmers
08:08:56 <scook0> "monads as epic loot!"
08:09:11 <Jaak> Saul_: how do runewords fit into picture? :P
08:09:17 <Cin> esteth: (considering one can use [1] or (1:[]) to construct a list)
08:09:17 <Saul_> scook0: :)
08:09:21 <thartman> esteth: to match any list, (x:xs)
08:10:21 <Saul_> Jaak: You mean like those in Diablo 2?
08:10:25 <Jaak> yah
08:10:35 <johnnowak> you know, i have no idea why in retrospect, but i also initially found the (x:xs) syntax for matching to be strange. i also expected [x:xs].
08:10:58 <tromp> the syntax is just x:xs
08:11:06 <johnnowak> yes, i realize that now
08:11:28 <Saul_> johnnowak: Probably because using cons and nil is not very familiar when you first start out
08:11:31 <Jaak> actually, i think socketing (morphisms) with items (objects) forms a category with or without runewords
08:11:39 <thartman> it's because square brackets are sugar, which only applies to lists. you probably thought square brackets had a more fundamental role in the language.
08:11:41 <johnnowak> Saul_: i'm a scheme programmer though.
08:11:42 <Jaak> you'll just need to take not scoketing as socketing
08:12:02 <johnnowak> thartman: possibly
08:13:15 <Saul_> Jaak: I think it would be better to use something more akin to function application, so when you use a rune it just updates the weapon
08:13:50 <Jaak> ah, okay
08:14:20 <Saul_> But I could make something to update the name as well, although that might become a little weird after 200 runes
08:14:44 <augustss> johnnowak: I've never understood why people find the pattern matching syntax confusing.  Patterns and expressions look exactly the same.  So if you know one, you know the other.
08:14:51 <Saul_> The idea is that weapons themselves are really basic, and runes only do very little
08:15:25 <johnnowak> does anyone know of a fucntional language that uses deconstructors instead of pattern matching? in order words, the definition of List would define some function unlist :: [a] -> b -> ([a] -> a -> b) -> b
08:15:31 <johnnowak> augustss: aye, not sure why it surprised me.
08:15:56 <Saul_> augustss: I think it's the sugar that people find confusing, because it's familiar to non-functional programmers, but actually works somewhat differently
08:16:08 <johnnowak> where 'b' is returned if [a] is null, else the other function is called which consumes the tail of '[a]' and the head of '[a]'
08:16:13 <Saul_> so you get to pile on a lot of runes to your gear
08:16:34 <augustss> Saul_: but the [] sugar works the same in patterns an expressions too
08:17:54 <augustss> johnnowak: I can't recall any language like that off the top of my head.  But if you do a type theory inspired language that would be one way.  You get the elimination rule from the introduction rules.
08:17:54 <Saul_> and you could have higher-order runes like a (foldr (.) id . repeat 3) that you can apply to runes
08:18:57 <johnnowak> augustss: aye, taking that approach for the language i'm working on
08:19:41 <Saul_> augustss: I'm not saying that haskell is illogical, I'm saying that most people worked with languages that are
08:19:55 <augustss> Saul_: :)
08:20:45 <augustss> johnnowak: And if you Church encode a data type in lambda calculus you get what you describe.
08:21:06 <blbrown> offtopic sort of.  Anyone know if there is a amazon ec2 freenode channel
08:22:05 <esteth> cin / thartman: Thanks. I was afk for a short while unexpectedly after i asked. That clarifies things though :)
08:23:53 <Eelis> johnnowak: Coq uses pattern matching /and/ automatically defined recursion operators (one for each inductively defined type) whose type is somewhat similar to what you mentioned.
08:24:09 <johnnowak> interesting, i'll give it a look
08:24:37 <Eelis> johnnowak: for example, when one defines lists, one gets list_rec of type  forall (A: Type) (P: list A -> Set), P nil -> (forall (a: A) (l: list A), P l -> P (a :: l)) -> forall l: list A, P l
08:25:14 <Eelis> if you take a constant function for P, it doesn't look so dependent anymore ;)
08:25:22 <johnnowak> aye
08:28:20 <Cheery> thick aluminiuam coated candy..
08:29:03 <Cheery> it'd look very hostile without a clear opening system
08:29:13 <johnnowak> > let unlist = (\x a f -> case x of {[] -> a; (x:xs) -> f x xs}) in unlist [1,2] [] (\x xs -> head xs : x)
08:29:13 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
08:29:13 <lambdabot>       Expected...
08:29:28 <johnnowak> hm.
08:30:09 <Jaak> \x xs -> head xs : x is the problem
08:30:26 <Jaak> it will inferr that xs is a list and x is a list
08:30:36 <Cheery> hm, I wonder how much an aluminium paper would hurt.
08:30:42 <johnnowak> ?type (\x xs -> head xs : x)
08:30:43 <lambdabot> forall a. [a] -> [a] -> [a]
08:30:48 <johnnowak> ah.
08:31:01 <johnnowak> ack
08:31:40 <johnnowak> ?type (\x xs -> x : head xs : [])
08:31:41 <lambdabot> forall a. a -> [a] -> [a]
08:31:52 <johnnowak> > let unlist = (\x a f -> case x of {[] -> a; (x:xs) -> f x xs}) in unlist [1,2] [] (\x xs -> x : head xs : [])
08:31:52 <lambdabot>  [1,2]
08:32:03 <desegnis> unlist looks like something between maybe and one step of a fold
08:34:46 <johnnowak> > let unmaybe = (\m a f -> case m of {Nothing -> a; Just x -> f x}) in unmaybe Nothing 5 (\x -> 10)
08:34:46 <lambdabot>  5
08:35:08 <atp> johnnowak: try maybe
08:35:18 <atp> ?type maybe
08:35:19 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
08:35:39 <Jaak> @type unfoldr
08:35:40 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
08:35:46 <johnnowak> atp: ah, indeed
08:36:22 <atp> johnnowak: i mean, if you're working in the pure, untyped lambda calculus, you can always functionally encode datatypes by letting them be functions that take functions that replace their constructors
08:36:39 <atp> johnnowak: the only time it gets tricky is when the constructors are recursive, like with a list
08:36:49 <atp> then you sort of end up working with folds...
08:40:29 <skorpan> is there any function in Data.Map which given a key, changes it?
08:40:57 <skorpan> or should i simply delete and insert?
08:41:03 <atp> wouldn't it be the same?
08:41:05 <monochrom> delete and insert
08:41:11 <skorpan> okay
08:41:13 <atp> remember, there is no destructive update
08:41:43 <monochrom> the API would not be the same :)
08:42:09 <atp> hehe
08:44:29 <conal> there's also mapKeys :: Ord k2 => (k1->k2) -> Map k1 a -> Map k2 a
08:44:34 <ils> hello. I'm trying to build regex-base-0.71 on gentoo with ghc-6.8.2 which is needed for darcs. I get message http://hpaste.org/6159. Seems that cabal thinks Data.Bytestring is hidden but actually it is  not.  Is it a known issue?
08:44:58 * monochrom shudders at mapKeys for changing just one key :)
08:45:09 * skorpan too
08:45:22 <idnar> @src Foldable
08:45:22 <lambdabot> Source not found. Are you on drugs?
08:45:25 * conal too, though wonders if skorpan is going to iteratively change a key
08:45:33 <monochrom> Oh! hehe
08:45:38 <skorpan> conal: indeed i am
08:45:57 * atp laughs at lambdabot.
08:46:04 <skorpan> or rather do M.insert x (M.delete k myMap)..
08:46:11 <atp> idnar: it's Data.Foldable, check out the library reference
08:46:16 <atp> idnar: the class is defined there
08:46:23 <monochrom> Damn imperative programmers, who reveal to you what they want to do one bit at a time!
08:46:36 <dino-> idnar: I wonder if you need to add bytestring to a build-depends in the .cabal file
08:46:48 <monochrom> The way they talk is the same as the way they program. :)
08:46:58 <conal> monochrom: years of shackles take time to drop
08:47:01 <idnar> atp: I just wanted to quickly check what functions it defines
08:47:11 <atp> idnar: fold, foldr, foldl, mainly
08:47:21 <idnar> dino-: I guess that was misdirected?
08:47:30 <dino-> yes, sorry
08:47:47 <dino-> ils: what I said about bytestring, ghc 6.8.2
08:47:52 <dino-> ^^
08:47:58 <atp> you know, it's funny... i work in finance, not programming, and we use this proprietary hunk of junk to generate reports
08:48:16 <Cheery> SKI combinator calculus is quite nice and clean
08:48:17 <skorpan> microsoft word?
08:48:39 <SamB> atp: excel?
08:48:43 <atp> and all the people without programming experience prefer to use it because it has this scripting language that is essentially poor-mans functional... imagine the C preprocessor with first class functions
08:48:48 <roconnor> BCKW
08:48:52 <hpaste>  dino- pasted "Maybe and Either" at http://hpaste.org/6390
08:48:53 <atp> prefer it over writing macros with excel, i mean
08:49:08 <SamB> I thought excel was a proprietary hunk of junk
08:49:21 <atp> SamB: in my work, we only have proprietary hunks of junk
08:49:24 <monochrom> regex-base 0.71 is awfully old.
08:49:24 <johnnowak> ?type let f x = x == x && f [x] in f :: Eq a => a -> bool
08:49:25 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
08:49:25 <lambdabot>       Expected type: [a] -> Bool
08:49:25 <lambdabot>       Inferred type: a -> t
08:49:26 <dino-> I need some help with these monads. I'm trying to understand how to use (Either e) to do simple fail-with-a-message things.
08:49:33 <johnnowak> what's the syntax for getting lambdabot to like that?
08:49:33 <ils> dino: sorry, cant catch you. What did you mean?
08:49:36 <Cheery> I'm thinking about it.. it's actually not hard at all to use SKI as well completely omitting lambdas
08:49:40 <SamB> dino-: well, you could use the fail method
08:49:53 <EvilTerran> ?type let f :: Eq a => a -> bool; f x = x == x && f [x] in f
08:49:54 <lambdabot>     Couldn't match expected type `bool' against inferred type `Bool'
08:49:54 <lambdabot>       `bool' is a rigid type variable bound by
08:49:54 <lambdabot>              the type signature for `f' at <interactive>:1:22
08:50:02 <EvilTerran> ?type let f :: Eq a => a -> Bool; f x = x == x && f [x] in f -- oops
08:50:03 <lambdabot> forall a. (Eq a) => a -> Bool
08:50:09 <dino-> ils: I was thinking perhaps that the .cabal file is for a diff version of the ghc where bytestring isn't hidden. But I could be wrong about that.
08:50:12 <johnnowak> ah silly casing.
08:50:15 <johnnowak> thanks
08:50:29 <EvilTerran> also i think you have to annotate the binding, not a use of the function
08:50:38 <johnnowak> right
08:50:42 <atp> anyway, i asked my coworker why this was, and she said to me, "anything with loops and variables is too confusing... mapping is much easier to understand"
08:50:50 <dino-> SamB: I understand that also possibly a more right way to do it would be with ErrorT, but I'm trying to understand why this works for that Maybe but not (Either String).
08:51:18 <Cheery> and suppercombinators actually feel more like a -@< than a leaf
08:51:23 <SamB> dino-: which code?
08:51:47 <dino-> the second one with Either
08:51:49 <SamB> dino-: also, bytestring was part of base not long ago...
08:52:34 <dino-> SamB: When I run the second script from my paste with the Either, I get "No instance for (Monad (Either [Char]))"
08:52:53 <EvilTerran> import Control.Monad.Instances
08:53:00 <SamB> EvilTerran: I tried that
08:53:01 <EvilTerran> (or .Error)
08:53:04 <SamB> it didn't seem to work
08:53:13 <SamB> yes, .Error should work
08:53:16 <SamB> that worked for me
08:53:40 <SamB> hmm, probably because you need another typeclass from that module ;-)
08:54:45 <Cheery> bt. from some reason I find out it intuitive that S a b c => (a c) (b c)
08:55:09 <atp> Cheery: it's just function application, really
08:55:24 <Cheery> lifted function application, of sort
08:55:45 <atp> Cheery: best thing to do to get an intuitive grasp of the S and K combinators is to manually translate lambda calculus into SK-calculus
08:55:47 <conal> monochrom's comment "Damn imperative programmers, who reveal to you what they want to do one bit at a time!" reminded me of Backus's classic "Can programming be liberated ..." paper.  I just reread the first section.  Snap!  Highly recommended: http://www.stanford.edu/class/cs242/readings/backus.pdf
08:55:49 <atp> at least, that worked for me
08:56:02 <SamB> hmm, is that =<< from the Reader monad?
08:56:20 <Cheery> and I and K are cousins, λx.x => I, λx.c => K
08:56:27 <Cheery> *K c
08:56:32 <EvilTerran> SamB, ap
08:56:44 <atp> Cheery: I is extensionally equivalent to S K _
08:56:51 <atp> Cheery: where _ is anything at all :)
08:57:17 <Cheery> atp: the implementation of functional programming languages gives the translation rules
08:57:30 <EvilTerran> > ap f x y
08:57:30 <lambdabot>  Couldn't match expected type `m a' against inferred type `Expr'
08:57:32 <EvilTerran> hm
08:57:41 <EvilTerran> > ap f g x
08:57:41 <lambdabot>  Add a type signature
08:57:45 <EvilTerran> > ap f g x :: Expr
08:57:45 <lambdabot>  Add a type signature
08:57:49 <EvilTerran> gah
08:57:54 <idnar> @type ap
08:57:55 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
08:57:57 <Cheery> while I notice them intuitive, I think there could be something cooler than lambdas which reduce into combinator calculus
08:58:09 <atp> Cheery: i'm not following you
08:58:14 <skorpan> you guys... i think i might have actually gotten State to work with my program now. and boy, does it feel awesome.
08:58:18 <EvilTerran> > ap (f :: Expr -> Expr -> Expr) (g :: Expr -> Expr) x
08:58:19 <lambdabot>  f x (g x)
08:58:27 <EvilTerran> phew
08:58:45 <Saizan> ?type [ap,(=<<) . flip]
08:58:46 <lambdabot> forall a b c. [(a -> b -> c) -> (a -> b) -> a -> c]
08:59:06 <koeien_> why can't i define (..) ?
08:59:16 <EvilTerran> > [1 .. 3]
08:59:16 <skorpan> koeien_: [1..3]
08:59:16 <lambdabot>  [1,2,3]
08:59:21 <EvilTerran> it's reserved syntax
08:59:22 <koeien_> bleh
08:59:32 <koeien_> i want to define (..) = \f g -> (f. ) . g
08:59:33 <atp> koeien_: you can do it by defining enumFromTo
08:59:33 <TomMD> @let (...) = (+)
08:59:34 <lambdabot> Defined.
08:59:36 <skorpan> sometimes i write (a:as), which also fails.
08:59:39 <TomMD> > 1 ... 3
08:59:40 <lambdabot>  4
08:59:42 <EvilTerran> koeien_, the traditional name is .:
08:59:49 <koeien_> ok
08:59:49 <atp> koeien_: yeah, that wouldn't work :)
08:59:56 <ils> dino:  you're right, after adding bytestring to Build-Depends now cabal complains about Data.Arry which probably in turn needs to be added
09:00:00 <koeien_> ty
09:00:18 * EvilTerran wants sections of .. at the same time as he gets sections of ,
09:00:40 <Saizan> ils: which package are you installing?
09:00:54 <ils> regex-base-0.71
09:00:57 <EvilTerran> (not entirely sure how they'd work, but bear with me :P)
09:00:58 <ils> for darcs
09:01:03 <Cheery> atp: ohwell, I think it is not quite obvious, and I don't at hand find any cooler thing that'd reduce to combinators
09:01:39 <EvilTerran> (..) :: Int -> Int -> [Int]; (..,) :: Int -> Int -> Int -> [Int]; ... -- or something
09:01:40 <dino-> ils: You'e building regex-base 0.71 you said?
09:01:49 <atp> Cheery: well, i think that most things aren't all that obvious when you start playing with them, you just have to experiment
09:02:01 <atp> Cheery: you can try writing code in lazy k
09:02:10 <dino-> I wonder if you need to use an old ver like that. Hackage shows them way up at 0.93 now and successfully building on 6.8
09:02:13 <Cheery> lazy k?
09:02:17 <atp> Cheery: yeah
09:02:22 <Cheery> atp: what's that?
09:02:32 <atp> Cheery: a lazy, pure functional language based on the ski calculus
09:02:41 <atp> Cheery: it's something of an esoteric language
09:02:56 <atp> Cheery: a purer version of unlambda because its functions are truly referentially transparent
09:03:19 <ils> dino: according to .cabal it's actually regex-base-0.72
09:03:23 <Cheery> actually, more I look of that ski -stuff, it looks as intuitive as the lambda -form
09:03:32 <Saizan> dino-: 0.93 is somewhat experimental
09:03:48 <atp> Cheery: it's too verbose in my mind
09:04:06 <Saizan> ils: 0.72.0.1 has a package that builds on 6.8 http://hackage.haskell.org/cgi-bin/hackage-scripts/package/regex-base-0.72.0.1
09:04:09 <lambdabot> http://tinyurl.com/2m5xlt
09:04:22 <Cheery> but uses less special characters, and you can reverse it to eliminate parentheses
09:04:29 <SamB> oh, was lazy k combinatory?
09:04:33 * SamB didn't remember
09:04:36 <atp> SamB: yeah
09:04:43 <ils> Saizan: thanks, will try to unmask it
09:04:51 <atp> SamB: it kind of hurts your brain to try to write anything non-trivial in it :)
09:04:53 <SamB> I guess that's where the K comes from ;-)
09:04:55 <johnnowak> atp: what do you mean by truly referentially transparent?
09:05:10 <johnnowak> oh -- nevermind. didn't see that was in contrast to unlambda.
09:05:19 <SamB> johnnowak: it processes church-encoded lazy streams
09:05:29 <atp> johnnowak: :)
09:05:30 <SamB> one for stdin, one for stdout
09:05:41 <johnnowak> yes i know
09:05:44 <SamB> well, I mean, it is passed standard in and returns stdout
09:06:14 <johnnowak> for some reason i read "unlambda" as "lambda calculus"
09:06:20 <SamB> hahhahaha
09:06:24 <atp> it doesn't do strictness analysis though and because it has no pattern matching or similar to force dethunking it bleeds memory like a babylonian whore
09:06:35 <johnnowak> possibly related to the fact that my place of work smell like paint at the moment... hm.
09:06:57 <atp> johnnowak: well, strictly speaking, combinatory algebra and lambda calculus are equivalent representations so you're good :p
09:07:22 <SamB> atp: yes, but lambda calculus doesn't have functions that print things to stdout or read from stdin
09:08:06 <atp> SamB: sure.  which is why i said that unlambda didn't have referentially transparent functions... which started all of this
09:08:31 <SamB> oh. /me got confused.
09:08:44 <atp> it's ok.  irc is chaotic ;)
09:09:47 <SamB> hmm, I wonder how I should keep track of default methods from class aliases...
09:16:32 <atp> man, i hope BSC doesn't go belly up...
09:18:05 <TomMD> BSC?
09:19:52 <atp> bear stearns co
09:27:25 <vincenz>  http://www.bolour.com/papers/monads-through-pictures.html   --
09:27:27 <lambdabot> Title: Monads through Pictures
09:27:27 <vincenz>                  wtf is a higher order monad
09:29:48 <Eelis> does it annoy anybody else that one cannot define constants for use in patterns?
09:30:00 <skorpan> Eelis: that's what erlang is for
09:30:08 <Baughn> Eelis: That's what guards are for
09:30:18 <Eelis> Baughn: i know, but it's annoying
09:31:21 <Saizan> vincenz: it seems like it's (higher-order (monad producers)), not ((higher-order monad) producers)
09:31:46 <skorpan> oeu
09:31:53 <vincenz> Saizan: His drawing(5) also makes absolutely no sense
09:31:54 <Cheery> how does haskell handle the polymorphic functions?
09:32:12 <Cheery> (on bytelevel)
09:32:38 <Saizan> Cheery: typeclass polymophism with dictionaries of methods, parametric doesn't need any special treatment
09:33:30 <monochrom> "Silicon Valley Patterns Group"
09:33:42 <conal> Saizan: on parametric polymorphism, one might consider uniform boxing as "special treatment"
09:34:13 <Cheery> Saizan: does it JIT?
09:34:39 <johnnowak> does anyone know of type system features or common extensions in haskell that would prevent specializing functions instead of passing dictionaries? it seems polymorphic recursion would be one.
09:35:08 <Saizan> conal: right, has non-unform boxing been considered?
09:35:29 <Cheery> but since it's polymorphic, doesn't that force one to supply some sort of type information along?
09:36:24 <Saizan> no, types are erased at compile time in ghc, but you might consider dictionaries a form of type information i guess
09:36:26 <johnnowak> Cheery: no as the function isn't doing anything with the value. values are still usually boxed though for other reason (garbage collection, etc)
09:36:26 <skorpan> @src State
09:36:26 <lambdabot> Source not found. Sorry.
09:36:40 <skorpan> where can i find the source for the state monad?
09:36:59 <conal> Saizan: several years ago, i think i heard talk that .net implementations of parametric polymorphism could generate code per representation size.  something like that.
09:37:48 <johnnowak> skorpan: http://www.haskell.org/all_about_monads/html/statemonad.html#definition
09:37:49 <lambdabot> Title: The State monad, http://tinyurl.com/2g4v8r
09:38:04 <Saizan> conal: yes, in C# it's like that iirc, but those are unboxed
09:38:12 * conal wonders if sarehu quit message means retroactively
09:38:14 <Cheery> johnnowak: so, let me get this right, polymorphism is implemented as some sort of OO?
09:38:34 <johnnowak> Cheery: polymorphism can mean a lot of things.
09:38:39 <conal> Saizan: by "uniform boxing", i mean boxing everything.
09:38:55 <skorpan> thanks johnnowak
09:39:01 <conal> (meant)
09:39:03 <johnnowak> Cheery: ad hoc polymorphism is implemented via dictionaries that are passed as additional arguments to a function
09:39:08 <Saizan> conal: ah, i understood it as boxing everything in the same way
09:39:20 <Cheery> johnnowak: just thinking about cases where (Num a) => a -> a
09:39:23 <conal> Saizan: ain't language grand?
09:39:37 <Cheery> and wondering to what sort of things those turn to
09:39:50 <Saizan> conal: heh :)
09:40:27 <johnnowak> Cheery: functions like (+) take an extra dictionary argument
09:40:48 <Saizan> Cheery: foo :: Num a => a -> a becomes foo :: NumDict a -> a -> a, with data NumDict a = { (+) :: a -> a -> a, ....}
09:41:22 <Saizan> Cheery: with a dictionary passing implementation, JHC does something different for example
09:41:25 <Cheery> so the operations are used from that dictionary passed along the function
09:41:34 <Cheery> urgh. meant passed along the datatype
09:41:40 <Cheery> it's pretty much object oriented then
09:41:53 <conal> and yet interestingly non-OO
09:42:14 <conal> since the dictionaries/vtables aren't in 1-1 correspondence with the values/objects.
09:42:38 <Saizan> yeah, but with types
09:42:48 <Cheery> but since it is arranged that way out, the thing could be indeed use JIT for those
09:43:10 <conal> so there could be two dictionaries for one values or one dictionary for two values or a huge array of values
09:43:24 <Saizan> Cheery: there's the SPECIALISE pragma in GHC for things like that
09:44:41 <Cheery> I've been thinking about a bit different implementation for stuff like polymorphism, I either need to handle it out compile-time or invent something else
09:45:35 <dozer> what's the simplest way to calculate a histogram from a list?
09:45:41 <Cheery> there you wouldn't necessarily need to have unique naming, ie. length  could naturally refer to definitions that do not fight together
09:45:59 <byorgey> dozer: something along the lines of group . sort, probably
09:46:12 <byorgey> > group . sort $ [2,5,5,3,6,3,2,3,2,2,3,6,6,6,2,3,1]
09:46:15 <lambdabot>  [[1],[2,2,2,2,2],[3,3,3,3,3],[5,5],[6,6,6,6]]
09:46:40 <dozer> map length $ group . sort $ [2,5,5,3,6,3,2,3,2,2,3,6,6,6,2,3,1]
09:46:54 <dozer> > map length $ group . sort $ [2,5,5,3,6,3,2,3,2,2,3,6,6,6,2,3,1]
09:46:54 <lambdabot>  [1,5,5,2,4]
09:46:56 <conal> > map (head &&& length) $ group . sort $ [2,5,5,3,6,3,2,3,2,2,3,6,6,6,2,3,1]
09:46:57 <lambdabot>  [(1,1),(2,5),(3,5),(5,2),(6,4)]
09:47:15 <dozer> thx - I can work with that :)
09:47:18 <skorpan> well, that's *one* way of doing it
09:47:19 <hhg> I love this channel :)
09:48:03 <Cheery> thinking about a system where you still have type classes, but their function is to group functionalities rather than to implement any new feature
09:48:42 <tromp> :t (&&&)
09:48:43 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
09:48:45 <chessguy> @bot
09:48:45 <lambdabot> :)
09:49:09 <benny99> hhg: me too
09:49:18 <johnnowak> Cheery: it's not OO because the dictionary is passed separately. in Num a => a -> a, only one dictionary needs to be passed
09:49:36 <Cheery> ie, could have type signatures like:  (a :length) => a -> Int -> b
09:50:23 <Cheery> oh well, more like: (a :length) => a -> b -> Int, because the earlier type definition always feels hostile
09:50:53 <faxathisia> Cheery, Maybe you could express this with dependent types?
09:51:05 <Cheery> or actually: (a -> Int :length) => a -> b -> Int
09:52:44 <dozer> :pl \a -> map length $ group . sort a
09:52:55 <dozer> @pl \a -> map length $ group . sort a
09:52:55 <lambdabot> map length . (group .) . sort
09:53:17 <shachaf> dozer: map length . group . sort
09:53:35 <shachaf> @pl \a -> map length (group (sort a))
09:53:35 <lambdabot> map length . group . sort
09:53:46 <skorpan> @pl .
09:53:46 <lambdabot> (line 1, column 1):
09:53:46 <lambdabot> unexpected "."
09:53:46 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
09:53:51 <skorpan> @pl (.) . (.)
09:53:51 <lambdabot> (.) . (.)
09:53:58 <dozer> dho!
09:54:06 <skorpan> @pl \x -> \a -> putStrLn x a
09:54:06 <lambdabot> putStrLn
09:54:35 <shachaf> @unpl (.) . (.)
09:54:35 <lambdabot> (\ i b c f -> i (b c f))
09:55:06 <skorpan> what does pl stand for?
09:55:10 <johnnowak> pointless
09:55:17 <skorpan> oh
09:55:21 <johnnowak> as in "pointfree"
09:55:26 <johnnowak> not er... that it's pointless.
09:56:02 <skorpan> @pl >>
09:56:02 <lambdabot> (line 1, column 1):
09:56:02 <lambdabot> unexpected ">"
09:56:02 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
09:56:07 <Cheery> oh well, I think I'll go around this type -stuff later, actually, after I've implemented my first graph reduction engine. :)
09:56:14 <skorpan> @pl (>>)
09:56:15 <lambdabot> (>>)
09:56:20 <skorpan> @unpl (>>)
09:56:21 <lambdabot> (>>)
09:56:26 <allbery_b> ?
09:56:29 <skorpan> dunno
09:56:50 <allbery_b> pl / unpl won't do much with just an operator.  what were you looking for?
09:56:58 <shachaf> @src (>>)
09:56:58 <lambdabot> m >> k      = m >>= \_ -> k
09:57:02 <skorpan> nothing really, just checking
09:57:03 <shachaf> @. pl src (>>)
09:57:04 <lambdabot> (line 1, column 1):
09:57:04 <lambdabot> unexpected end of input
09:57:04 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
09:57:08 <Cheery> I want to implement FP which you can just embed into file formats
09:59:21 <dozer> thx guys
09:59:27 <dozer> I've got my toy GA working now :)
09:59:48 <dozer> and am making nice histograms of how many generations it requires to solve my problem
10:02:17 <skorpan> it seems that i want both "s" and "a" in "State s a" to be the same thing.. then i guess i might be looking for another type of monad?
10:02:20 <Peaker> Is there a difference between \x -> y  and \ x -> y?
10:02:47 <skorpan> Peaker: i've never seen the latter
10:02:57 <gnuvince_> Peaker: no.
10:02:58 <Peaker> http://www.haskell.org/tutorial/monads.html
10:02:58 <lambdabot> Title: A Gentle Introduction to Haskell: About Monads
10:03:17 <Peaker> [1,2,3] >>= (\ x -> [1,2,3] >>= (\y -> return (x/=y) >>=    (\r -> case r of True -> return (x,y)    _    -> fail "")))
10:03:47 <gnuvince_> > (\x -> x + x) 3
10:03:48 <lambdabot>  6
10:03:50 <gnuvince_> > (\ x -> x + x) 3
10:03:51 <lambdabot>  6
10:03:53 <gnuvince_> > (\                                x -> x + x) 3
10:03:55 <lambdabot>  6
10:04:06 <EvilTerran> > join(+)3
10:04:07 <lambdabot>  6
10:04:19 <gnuvince_> :t join
10:04:22 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
10:04:31 <EvilTerran> here, m = (e ->)
10:04:52 <EvilTerran> ?type join :: (e -> e -> a) -> (e -> a)
10:04:54 <lambdabot> forall e a. (e -> e -> a) -> e -> a
10:07:26 <gwern> out of curisoity: how many people here use Firefox? are you using v3, or are you using less than 3?
10:07:57 <nolrai_> firefox v3 for me
10:07:59 <EvilTerran> Fx 2, here
10:08:03 <piojo> firefox v2
10:08:21 <nolrai_> wait no v2
10:08:38 <EvilTerran> thinking of getting 3, as there's a couple of ideas for extensions i have knocking around, and there's no point developing for onethat's about to go out of date.
10:09:00 <gwern> so the majority of haskellers are still on v2.x?
10:09:04 <tromp> v2
10:09:25 <mperillo> hi all
10:10:01 <Jaak> ffox3 > ffox2
10:10:08 <Jaak> using beta 4 right now
10:10:26 <Jaak> it's quite solid already
10:10:52 <gwern> Jaak: I agree, but ff3 changed the X.org classname so I need to update my xmonad docs when ff3 becomes widespread
10:11:24 * johnnowak is on safari
10:12:00 <shag> does a type/class name may contain "-"?
10:12:28 <Peaker> "updateSM                :: (S -> S) -> SM ()"  What do the () mean here?
10:12:41 <shachaf> Peaker: data () = ()
10:12:44 <shachaf> > ()
10:12:45 <lambdabot>  ()
10:12:45 <shachaf> @ty ()
10:12:47 <lambdabot> ()
10:12:54 <shachaf> Peaker: It's just an empty value.
10:12:57 <shachaf> shag: No.
10:12:59 <shachaf> @where report
10:12:59 <lambdabot> http://www.haskell.org/onlinereport/
10:13:07 <shag> shachaf: thanks
10:13:20 <Peaker> schlumpi, thanks
10:15:14 <TomMD> @where activities
10:15:14 <lambdabot> I know nothing about activities.
10:15:38 <TomMD> @where communities
10:15:38 <lambdabot> I know nothing about communities.
10:15:42 <skorpan> what is the actual difference between Reader and State?
10:16:00 <TomMD> +where communities http://www.haskell.org/communities/
10:16:00 <lambdabot> Title: Haskell Communities and Activities Report
10:16:25 <Peaker> I like Haskell, but I kinda hate its syntax :(
10:16:42 <TomMD> syntax?  What syntax?
10:16:53 <TomMD> All I see are spaces.
10:17:03 <Heffalump> @where+ communities http://www.haskell.org/communities/
10:17:03 <lambdabot> It is forever etched in my memory.
10:17:03 <skorpan> TomMD: the spaces are mainly the syntax
10:17:16 <Heffalump> (I presume that's what you meant, TomMD)
10:17:18 <TomMD> heffalump: right, I _always_ screw that up.
10:17:42 <TomMD> skorpan: yes, I'm just being a bit cheeky
10:17:47 <skorpan> TomMD: :)
10:18:10 <skorpan> ircing in emacs is a bliss, as when i type :), i can see the last :( being highlighted in the log
10:18:24 <TomMD> lol
10:18:37 <skorpan> when there are no :(, i get "mismatched paranthesis"
10:19:24 <TomMD> ?quote emacs
10:19:24 <lambdabot> Philippa says: because emacs wasn't a good enough OS after all
10:19:35 <TomMD> ?quote yi
10:19:35 <lambdabot> edwardk says: been playing with type level 2s complement arithmetic
10:20:04 <skorpan> the creator of yi is at my school
10:20:32 <TomMD> Would that be York?  I don't know who originated the project.
10:20:34 <gwern> skorpan: which creator is that?
10:20:36 <skorpan> chalmers
10:20:42 <skorpan> jean-phillipe bernardy, i mean
10:20:47 <skorpan> not the original developer
10:20:52 <TomMD> Figured it had to be York, Cambridge, or Chalmers.
10:20:53 <skorpan> so "creator" was a bad choice of words
10:21:07 <gwern> tuomo's riot beget dons's yi, which begat JPB's yi, which begat..
10:21:50 <TomMD> skorpan: So how do you like Chalmers?  Are you a native or from elsewhere in the world?
10:22:02 <skorpan> TomMD: native. chalmers is great!
10:22:20 <TomMD> I was considering applying, but I'm not as into hardware as I once was.
10:22:43 <skorpan> hardware? i haven't taken a single course on plain hardware since the first year
10:23:29 <skorpan> where do you study now?
10:23:51 <TomMD> skorpan: As a person seeking a PhD, I am trying to find an advisor with a "perfect" fit, Chalmers seemed to have lots of hardware oriented profs (ex: lava work)
10:24:01 <TomMD> skorpan: I am not in any college right now - industry.
10:24:08 <skorpan> oh, PhD stuff.
10:24:15 <Peaker> http://www.haskell.org/tutorial/monads.html is quite hard to follow
10:24:15 <lambdabot> Title: A Gentle Introduction to Haskell: About Monads
10:24:41 <TomMD> @go monads as containers
10:24:42 <lambdabot> No Result Found.
10:24:43 <skorpan> well, bernardy is a PhD student and has taught programming paradigms as well as advanced functional programming
10:24:50 <skorpan> i don't know what else he does, though
10:25:12 <Peaker> The examples are good, but there aren't enough of them.. far too few
10:25:44 <TomMD> Peaker: There are lots of other Monad tutorials (monads as containers, what in the hell are monads, etc).  Have you tried others?
10:25:45 <skorpan> he's also teaching software constraints and programming languages
10:26:00 <Peaker> TomMD, not yet, I'm still reading that one
10:28:20 <joricj> suppose i have a list of item [a,b,c,d,...,z] how can i turn it into [[a,b],[c,d],...,[z]]?
10:28:47 <skorpan> some sort of grouping is my guess
10:29:01 <skorpan> or perhaps mapping with "take" or something
10:29:15 <skorpan> takeWhile?
10:29:29 <Baughn> > map (take 2) $ tails $ [1..27]
10:29:30 <lambdabot>  [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,8],[8,9],[9,10],[10,11],[11,12],[12,...
10:29:31 <pejo> TomMD, this is a bit late, but here's an ad for chalmers: http://www.cs.chalmers.se/~koen/phdad.html
10:29:33 <lambdabot> Title: PhD Positions in Functional Programming at Chalmers
10:29:46 <Baughn> Hm. Almost.
10:29:53 <Jaak> > @type unfoldr (\xs -> if null xs then Nothing else (take 2 xs, drop 2 xs)) [1..10]
10:29:53 <lambdabot>  Parse error at "@type" (column 1)
10:29:59 <Jaak> > unfoldr (\xs -> if null xs then Nothing else (take 2 xs, drop 2 xs)) [1..10]
10:29:59 <lambdabot>  Couldn't match expected type `Maybe (a1, [a])'
10:30:07 <tromp> just write  pairs (a:b:xs) = (a,b):pairs xs ...
10:30:19 <Jaak> > unfoldr (\xs -> if null xs then Nothing else Just (take 2 xs, drop 2 xs)) [1..10]
10:30:20 <lambdabot>  [[1,2],[3,4],[5,6],[7,8],[9,10]]
10:30:24 <Jaak> > unfoldr (\xs -> if null xs then Nothing else Just (take 2 xs, drop 2 xs)) [1..11]
10:30:25 <lambdabot>  [[1,2],[3,4],[5,6],[7,8],[9,10],[11]]
10:30:29 <Jaak> there
10:30:42 <Jaak> this can be generalised
10:31:17 <Jaak> > let chop n = unfoldr (\xs -> if null xs then Nothing else Just (take n xs, drop n xs)) in chop 3 [1..10]
10:31:18 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10]]
10:32:08 <hpaste>  nolrai_ pasted "arrgh" at http://hpaste.org/6391
10:32:58 <sclv> ?hoogle splitAt
10:32:59 <lambdabot> Prelude.splitAt :: Int -> [a] -> ([a], [a])
10:32:59 <lambdabot> Data.List.splitAt :: Int -> [a] -> ([a], [a])
10:32:59 <lambdabot> Data.ByteString.splitAt :: Int -> ByteString -> (ByteString, ByteString)
10:35:35 <Peaker> is it equivalent to say: class A a where ...    and to say class A    and then specify (A a) => ... separately?
10:35:59 <Peaker> (I mean, does it matter whether definitions are contained inside the where clause of a class, or whether they are defined separately, with => )?
10:36:49 <EvilTerran> yes
10:36:52 <EvilTerran> it matters
10:36:56 <sclv> Peaker: any function that is polymorphic over a class only has access to the operations of the class contained in the initial where clause defining the class.
10:37:31 <EvilTerran> only the definitions in the where{} clause can be defined by instances
10:37:39 <Peaker> sclv, can't it use other functions defined for instances of the class?
10:37:44 <EvilTerran> that's the most important difference
10:37:53 <Peaker> oh
10:37:56 <sclv> You can think of a typeclass sort of like an "interface" in OO terms, at least as a first approximation.
10:38:16 <Peaker> the stuff in the class's "where" clause is what can be polymoprhically specified for instances?
10:38:21 <EvilTerran> yes
10:38:50 <Peaker> thanks, I'll digest the meaning of that :)
10:39:40 <sclv> if you have a function that's (A a) => etc... then you can conceptually imagine that this function only "knows" that its getting something that implements A... therefore, those are necessarily the only operations available to it.
10:40:22 <EvilTerran> it can, of course, use any functions in scope that will accept any instance of A as a parameter
10:40:37 <opqdonut> "typeclasses as interfaces" is a pretty good metaphor
10:40:40 <EvilTerran> but, in the end, these'll have to use the methods specified in the class
10:40:53 <opqdonut> especially if one is coming from the object-oriented paradigm
10:44:45 <TomMD> So what does Haskell need, a killer app or a killer dev tool?  I suppose it doesn't need either - it has both in a couple forms, but I've got two projects in my head that are reasonable size and will only do one (if that).
10:45:30 <solrize_> it needs killer documentation and solid libraries
10:46:05 <sclv> a few more killer apps would be nice though...
10:46:08 <Heffalump> dev tool
10:46:10 <piojo> TomMD: i wonder if an easy killer GUI building tool would help? I think that's what VC++ has over all the other IDEs. as for dev tools, it's hard to beat emacs
10:46:14 <Heffalump> well, depending on what the dev tool would do
10:46:35 <solrize_> python is doing ok with fairly lousy dev tools
10:46:38 <sclv> well, there's no standard fleshed out mid-high level gui library...
10:46:52 <ziman> away
10:46:56 <EvilTerran> what of gtk2hs?
10:46:56 <ziman> oops
10:47:03 <TomMD> Well, the tool I have in mind would be not so killer - just a simple information flow / hscolour library showing overt information propogation.
10:47:10 <sclv> et: mid-high.
10:47:21 <EvilTerran> gtk2hs too high for you? too low?
10:47:26 <sclv> what's the app :-)
10:47:29 <sclv> too low
10:47:46 <EvilTerran> k
10:47:48 <opqdonut> yeah, widget-fiddling-level
10:47:56 <piojo> does  gtk2hs have advantages over wxhaskell?
10:47:56 <opqdonut> not interface-description level
10:48:05 * sclv wants lisp-style CellsGTK on haskell.
10:48:13 <TomMD> sclv: Even less killer :-( but that word was a great way to generate conversation.  I was thinking of producing some of Dr. Awerbuchs work on DHTs as an app.
10:48:27 * Heffalump loses interest in either :-)
10:49:53 <solrize_> glade is pretty good as a gui layout tool, you're still left with connecting up the widgets with code though
10:50:03 <sclv> dhts would be lots of fun.
10:50:03 <EvilTerran> piojo, well, gtk2hs isn't a dead project
10:51:37 <sclv> and, in the haskell world, more novel.
10:51:53 <opqdonut> dhts?
10:52:00 <TomMD> distributed hash tables
10:52:00 <solrize_> distributed hash table
10:52:03 <opqdonut> ah
10:52:06 <TomMD> aka 3rd generation P2P network.
10:52:10 <sclv> distributed hash tables.
10:52:10 <gwern> EvilTerran: come now, wxhaskell isn't quite dead yet
10:52:27 <sclv> both are pretty researchy projects tho...
10:52:34 <EvilTerran> isn't wxwidgets a bit defunct?
10:52:51 <TomMD> well, what would be the point if they weren't?  Where would be the fun ;-)
10:53:28 <newsham> its all research until someone builds a web browser
10:53:28 <gwern> EvilTerran: there's work ongoing; it was recently put noto hackage for example
10:53:33 <gwern> which isn't something gtk2hs can say...
10:53:37 <piojo> EvilTerran: i didn't know wx wasn't being developed; that's sad
10:53:54 <EvilTerran> i may be mistaken
10:53:58 <piojo> oh... i see
10:54:10 <nolrai_> is 'newtype NoData = NoData ()' or 'data NoData = NoData' better?
10:54:11 <newsham> wasnt there a wx announce in the last HWN?
10:54:15 <EvilTerran> i appear to be a little mistaken, at least
10:54:16 <TomMD> ye[
10:54:18 <TomMD> yep
10:54:29 <Heffalump> nolrai_: either is fine
10:54:32 <EvilTerran> but when i looked a few months ago, nothing had happened to it for _anges_
10:54:35 <Heffalump> I think I'd prefer the latter slightly.
10:54:39 <gwern> a cat is fine too
10:54:39 <EvilTerran> *ages
10:54:50 <EvilTerran> nolrai_, i'd go for the latter
10:55:00 <gwern> EvilTerran: I think kowey got interested again
10:55:22 <EvilTerran> good-o
10:55:25 <sclv> nolrai_: with emptydatadecls you cna just do data NoData;
10:55:30 * gwern would like to take credit for that because of me packaging geni which relys on wxhaskell, but I can't really
10:55:35 <EvilTerran> sclv, er, that means something else
10:55:45 <roconnor> nolrai_: I would go with data, unless you want do to a bunch of deriving to get instances from () for NoData for free.  In that case newtype is worth considering.
10:56:26 <roconnor> nolrai_: empty data is even less data than no data.
10:56:36 <roconnor> sclv: empty data is even less data than no data.
10:56:46 <roconnor> sorry, that was for sclv
10:56:47 <sclv> right: but it depends how much he needs.
10:57:20 <nolrai_> I want somthing that exists only in the type system.
10:57:20 <nolrai_> I think.
10:57:30 <EvilTerran> in that case, empty data would be the way to go
10:58:04 <nolrai_> What would the difference be?
10:58:07 <EvilTerran> {-# LANGUAGE EmptyDataDecls #-} ...; data NoData;
10:58:16 <EvilTerran> the only value of one of those is _|_
10:58:27 <EvilTerran> yours has the values _|_ and NoData
10:58:29 <sclv> its an uninhabited typeclass -- no constructors.
10:58:35 <Heffalump> s/typeclass/type/
10:58:42 <sclv> right.
10:59:01 <newsham> data NobodyHome;
10:59:09 <roconnor> if you want to stay Haskell 98, a phantom type with one constructor is still reasonable.
10:59:25 <EvilTerran> and it can be useful for getting the type attached to things
10:59:39 <roconnor> but an empty type is better if you are willing to forego Haskell 98
10:59:40 <EvilTerran> because you can write NoData instead of having to write (undefined :: NoData)
11:00:22 <sclv> well, but if you're on the pure type level, you should never need to do either?
11:00:41 <nolrai_> thanks all.
11:01:50 <EvilTerran> sclv, it's often necessary to pass in a "value" of a phantom type to, say, a class method so it knows which instance of the class to use
11:01:59 <EvilTerran> i find.
11:02:22 <Heffalump> <aol>
11:02:31 <EvilTerran> heh heh heh
11:02:52 <Heffalump> though of course that makes it rather less phantom, because it ends up reified by a dictionary at runtime..
11:03:00 <Heffalump> (using a type class over one, that is)
11:03:33 <EvilTerran> i don't know what you mean by "reify" in this context, but i think i get the gist of what you're saying anyway ;)
11:04:10 * sclv is still having trouble grappling with a scenario where it couldn't be done otherwise.
11:05:21 <sclv> I suppose if you're using it for polymorphism rather than for phantom type tagging... but that's a different issue entirely?
11:06:35 <nolrai_> Whats phantom type tagging?
11:07:35 <lispy> nolrai_: data Foo a = Foo; mkIntFoo :: Foo Int; mkIntFoo = Foo
11:08:00 <lispy> nolrai_: then you could have functions like, addFoo :: Foo a -> Foo a -> Foo a
11:08:14 <lispy> nolrai_: and you wouldn't be able to addFoo on Foo Int and Foo String
11:08:21 <smg> liesen: mh why don't use derive?
11:09:06 <roconnor> > 0x13BCADD6460015
11:09:06 <hpaste>  nolrai_ pasted "why doesnt this work?!" at http://hpaste.org/6392
11:09:07 <lambdabot>  5555479367778325
11:09:29 <roconnor> > 0x13BCADD6460015*2^(-49)
11:09:30 <lambdabot>  Exception: Prelude.^: negative exponent
11:09:35 <roconnor> > 0x13BCADD6460015*2^^(-49)
11:09:36 <lambdabot>  9.868513771100007
11:09:52 <roconnor> > -0x13BCADD6460015*2^^(-49)
11:09:54 <lambdabot>  -9.868513771100007
11:10:13 <roconnor> > 0x1B25BE7716E0C1*2^^(-67)
11:10:14 <lambdabot>  5.1779627834704e-5
11:10:23 <roconnor> > exp(-0x13BCADD6460015*2^^(-49))
11:10:24 <lambdabot>  5.1779627834704e-5
11:10:28 <lispy> nolrai_: it's hard to tell :)
11:10:50 <tromp> :t (^^)
11:10:51 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
11:10:59 <tromp> :t (^)
11:11:01 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
11:11:24 <lispy> nolrai_: actually, it looks like you made a monad instance for Requests, but what about RequestHandler?
11:12:22 <lispy> nolrai_: you have a Read instance for RequestsHandler, but what is the monad instance?
11:13:07 * lispy wonders if nolrai_ is even watching the channel
11:13:40 <roconnor> > 0x1B25BE7716E0C1
11:13:42 <lambdabot>  7641324343189697
11:13:54 <lispy> > 0xdeadbeef
11:13:55 <lambdabot>  3735928559
11:14:12 <Jaak> > 0xdeadcafebabe
11:14:13 <lambdabot>  244838016400062
11:14:23 <lispy> I think this is nice but odd about the haskell lexer
11:14:25 <lispy> > 000001
11:14:26 <lambdabot>  1
11:14:33 <sclv> nolrai_: it looks to me like your first request call is too general -- the type inference algorithm can't narrow it down to your declared requesthandler instance.
11:14:34 <Jaak> hmm
11:14:48 <Cale> lispy: what is?
11:14:57 <nolrai_> but RequestHandler is a class, not a type?
11:15:28 <lispy> Cale: 000001 lexes as 1
11:15:46 <lispy> Cale: I think many other languages wouldn't handle it that way
11:16:00 <Cale> Is there any reason not to lex it as 1?
11:16:14 <sclv> right. and you gave it one instance, but the type inferred from yr. initial request call is more general.
11:16:24 <lispy> Cale: as I said, it's nice, just odd
11:16:29 <Cale> > 000129381
11:16:30 <lambdabot>  129381
11:16:40 <lispy> Cale: and by odd maybe I should say uncommon
11:16:51 <sclv> you might try giving the initial request call an explicit type signature and see if it helps.
11:17:10 <nolrai_> hmm.
11:17:23 <Blicero> lispy what do you mean uncommon? i think most languages lex it that way
11:17:26 <sclv> if so, then you know what the issue is -- the question is whether you can do what you want in the type system, or if its insufficiently smart.
11:17:26 <xerox> > lex "000001"
11:17:27 <lambdabot>  [("000001","")]
11:17:42 <Jaak> @type lex
11:17:43 <lambdabot> String -> [(String, String)]
11:17:49 <lispy> Blicero: what are some examples then?  I know python doesn't because I was writing a python parser yesterday
11:18:05 <Jaak> list of token, error pairs?
11:18:06 <Blicero> >>> 00001
11:18:06 <Blicero> 1
11:18:15 <Blicero> isnt that same? (this is in python)
11:18:42 <lispy> hmm...
11:19:01 <allbery_b> most languages will get 1 from that.  the question is what they do with e.g. 00000008
11:20:06 <lispy> I guess I misunderstood the BNF if that works in python
11:20:36 <lispy> I thought they said, anything starting with '0' was either hex or octal
11:20:57 <EvilTerran> yeah, so?
11:21:00 <lispy> and had to be either 0x, 0X, 0o or 0O
11:21:09 <EvilTerran> 00001 in octal is 00001 in decimal :P
11:21:20 <EvilTerran> > 010
11:21:21 <lambdabot>  10
11:21:30 <EvilTerran> hm. in C, that would come up as "8".
11:21:47 <nolrai_> 0x010
11:21:49 <EvilTerran> the prefix for octal isn't 0o in some languages, just 0
11:21:51 <nolrai_> > 0x010
11:21:52 <lambdabot>  16
11:21:58 <EvilTerran> > 0o10
11:21:59 <lambdabot>  8
11:22:01 <kowey> EvilTerran: wxhaskell just had a pre-release
11:22:12 <lispy> they kowey
11:22:14 <lispy> er hey
11:22:20 <kowey> hiya, lispy
11:22:29 <lispy> kowey: david accepted a patch to add a haddock tareg!
11:22:31 <lispy> er target
11:22:31 <EvilTerran> kowey, yeah, i've already determined that i was mistaken. ISTR it didn't have any updates for a while, but now it seems to be going again
11:22:37 * lispy is too excited to type correctly
11:22:56 <kowey> at last! I was afraid to rock the boat, but am glad this went in
11:22:59 <kowey> hyperlinks
11:23:15 <lispy> kowey: I have a demo of what it looks like with haddock2
11:23:33 <lispy> http://files.codersbase.com/darcs-haddock/
11:23:43 <lispy> I have to run
11:23:48 * lispy waves bye
11:23:52 <unenough> hi, can someone refer me to a tutorial?
11:24:02 <unenough> i've heard there is a "THE" tutorial
11:24:13 <unenough> ah found, forget it and thanks
11:24:47 <kowey> at the very least, this makes for great browsing, even without comments... thanks for persisting!
11:26:10 <Cale> unenough: YAHT and the Wikibook are popular
11:26:17 <Cale> @where yaht
11:26:18 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
11:26:21 <Cale> @where wikibook
11:26:21 <lambdabot> http://en.wikibooks.org/wiki/Haskell
11:26:24 <opqdonut> yeah the wikibooks are pretty good nowadays
11:26:30 <opqdonut> they used to be awful
11:26:38 <byorgey> unenough: there definitely isn't a "THE" tutorial, mix + match seems to be the way to go in general =)
11:27:00 <unenough> ok, thanks everybody! i'll check out both YAHT and the wiki """""books""""
11:27:11 <Cale> If you want a "THE" tutorial, that would probably be Graham Hutton's book ;)
11:29:00 <solrize_> there's a big gap between any of the tutorials/textbooks i've seen, and enough stuff to really know what you're doing
11:29:09 <gwern> opqdonut: 'pretty good nowadays, they used to be awful' is the mark of a successful wiki project
11:29:14 <solrize_> you have to read a lot of research papers
11:29:33 <EvilTerran> you also have to do loads of project euler problems
11:29:48 <EvilTerran> (well, it's not exactly necessary to do that in particular, but i find it really helps_
11:30:07 <tromp> have you done the last one?
11:30:16 <kowey> awful as a first step... good lesson in humility, learning to accept that what you do is going to be awful, at least in the beginning
11:30:25 <EvilTerran> i haven't got that far in
11:30:55 <opqdonut> gwern: trye
11:30:58 <opqdonut> *true
11:35:30 <unenough> Graham Hutton's book is the "THE" book?
11:35:59 <solrize_> i looked at it a couple days ago, it seems like a good introduction
11:36:03 <gnuvince_> I have it
11:36:06 <gnuvince_> It's good
11:36:19 <gnuvince_> I still need to really understand the monads chapter though
11:36:29 <shapr> Has anyone here tried to get the code to work for "Boxes go Bananas" by Geoff Washburn and Stephanie Weirich?
11:37:42 <unenough> our library has: "Haskell :the craft of functional programming /Simon Thompson"
11:38:26 <dons> Igloo: a bit data extension, you were thinking?
11:38:33 <dons> deriving the bit packing for a type?
11:39:23 <Igloo> dons: Something like   bitmap Foo = X & Y & Z
11:39:45 <shapr> Or does anyone know where some working source code is for 'Boxes Go Bananas' ?
11:40:22 <Igloo> Where (foo Y) is True or False, and (foo & Y) and (foo & !Y) turn the Y bit on or off
11:40:52 <nolrai_> whats the syntax for multiple funtional depencies?
11:40:55 <Heffalump> didn't the PSU guys write a paper about this at ICFP 05?
11:40:59 <Heffalump> nolrai_: comma separated
11:41:06 <Heffalump> class Foo a b | a -> b, b -> a
11:41:11 <nolrai_> thanks
11:41:14 <Igloo> Heffalump: About bitmaps?
11:41:26 <Heffalump> bit encoding of types
11:41:33 <Heffalump> I may be confused about what you're talking about..
11:41:58 <shapr> Heffalump: About Boxes Go Bananas?
11:42:50 <Heffalump> shapr: no, bit encoding
11:43:27 <shapr> oh
11:43:29 <Heffalump> hmm, it doesn't seem to be the ICFP 05 paper
11:44:28 <Igloo> That doesn't sound like what we're talking about
11:44:43 <nolrai_> what is "The Coverage Condition"? (context is a ghc error)
11:44:48 <Igloo> although I'm not entirely sure what it means
11:45:27 <Heffalump> grr, I can't find what I'm thinking of
11:45:49 <Heffalump> nolrai_: see the GHC manual, or use LANGUAGE UndecidableInstances to ignore it
11:46:19 <brad_larsen> I have a question about haskell boxed arrays and laziness.
11:46:57 <hpaste>  brad_larsen pasted "lazy array?" at http://hpaste.org/6393
11:46:59 <Heffalump> I distinctly remember a paper about bit-level encodings.
11:47:08 <Heffalump> And I could have sworn it was the OGI people.
11:47:14 <dons> yep.
11:47:31 <dons> iavor et al, working on a 'bitdata' for defining how types are packed
11:47:36 <dons> 2005 ICFP ?
11:47:37 <brad_larsen> So, there is the wavefront matrix code that I pulled from the wiki.   Defined recursively.
11:47:45 <dons> maybe it was hallgren/tolmach?
11:47:59 <chessguy> speaking of ICFP, is that coming up again soon already?
11:48:13 <dons> september
11:48:22 <brad_larsen> but if I try this :  wavefront 1000 ! (0,0)
11:48:25 <dons> Igloo: but why not just a type class, and a deriving?
11:48:25 <brad_larsen> it takes forever
11:48:39 <dons> Igloo: btw, what's ffiBit ?
11:48:40 <Heffalump> http://portal.acm.org/citation.cfm?doid=1086365.1086387
11:48:40 <chessguy> dons, is that when the programming contest is too? for some reason i was thinking spring
11:48:43 <lambdabot> Title: High-level views on low-level representations
11:48:51 <dons> oh, not sure about the contest
11:48:59 <Heffalump> chessguy: contest is June/July, but last time I looked the organisers hadn't been settled...
11:49:04 <chessguy> aha
11:49:14 <brad_larsen> I was expecting evaluating (wavefront 1000 ! (0,0)) to be constant-time
11:49:19 <chessguy> Heffalump, aha
11:49:52 <brad_larsen> whoops, I mean (wavefront 1000 ! (1,1))
11:50:03 <SamB> why is there no emacs regex debugger?
11:50:09 <SamB> or why is it impossible to find?
11:50:10 <brad_larsen> urrr...
11:50:11 <Heffalump> igloo: this is what I was thinking of (which was ICFP 05 after all): http://yav.purely-functional.net/publications/bitdata.pdf
11:50:16 * brad_larsen looks at his code more closely
11:50:27 <kowey> piojo: to answer your question about gtk2hs vs wxhaskell, some advantages are that it might be more straightforward for you to install on Linux, and that it supports tools like Glade (for designing the GUI without coding it up)
11:50:34 <whee> SamB: like M-x regexp-builder?
11:51:17 <kowey> on the other hand, wxhaskell provides what I think is a slightly higher level library, and more native behaviour on Windows/Mac (I think)
11:53:28 <opqdonut> SQL+haskell?
11:53:34 <SamB> whee: what does that do?
11:53:38 <opqdonut> is there a dsl for building sql queries or something?
11:53:48 <Heffalump> opqdonut: there's HaskellDB
11:53:55 <SamB> and why didn't I find it when I searched for "regexp debugger emacs" on google?
11:54:20 <Heffalump> and I'm currently hacking on a different one, but it's still work in progress and it requires ghc 6.9
11:54:20 <SamB> also I don't have that
11:54:31 <whee> SamB: it lets you see what a regexp is matching as you're typing it
11:54:42 <whee> so you can create a buffer of test cases and construct it interactively
11:54:53 <kowey> piojo: oh yeah, and note also that there's some interesting stuff like PropLang for gtk2hs, and autoforms for wxhaskell
11:55:06 <dons> opqdonut: HDBC is often recommended
11:55:20 <dons> but i'm not aware of any nice sql edsl
11:55:23 <dons> would be happy to see one
11:55:54 <Heffalump> is HDBC a DSL?
11:56:11 <Heffalump> HaskellDB certainly is one. It just has rather verbose types.
11:56:47 <dons> yeah, i don't think hdbc has much of a dsl (or any?)
11:57:01 <kaol> would it make sense to use TH on SQL statements?
11:57:02 <dons> hey, i note audreyt uploaded flipp 0.3
11:57:04 <dons> very interesting
11:57:12 <kowey> yeah!
11:57:12 <Heffalump> kaol: to do what?
11:57:16 <dons> i'm not sure it ever makes sense to use TH..
11:57:32 * Heffalump plans to use it to generate boilerplate
11:57:36 <opqdonut> dons: haskelldb is a dsl it seems?
11:58:20 <Heffalump> dons: did you see that example from above about list comprehensions being slower than similar code using concatMap and filter?
11:58:25 <kaol> to dig out placeholders from them... a bit like you can make a printf using TH.
11:58:29 <Igloo> I played with using TH to generate SQL a while ago, like this: http://urchin.earth.li/~ian/desc.txt
11:58:31 <dons> Heffalump: no, sounds interesting.
11:58:43 <SamB> I don't see why TH would help with SQL...
11:58:51 <dons> its surprising we don't have an agreed on combinator library for sql
11:58:56 <dons> seems like a killer app...
11:59:08 <opqdonut> mhmm
11:59:08 <dons> and one separate from the individual dbs
11:59:16 <Heffalump> igloo: oh, neat.
11:59:24 <Heffalump> that might fit well with squiggle.
11:59:26 <opqdonut> i think i'll use haskelldb, it looks great for what i have i n  mind
11:59:53 <opqdonut> except if this course requires me to write the sql queries by hand
12:00:11 <Heffalump> I got fed up with haskelldb after a while (hence writing squiggle), but one of the reasnos for that - the enforcement of unique result rows - has now been removed anyway.
12:00:13 <brad_larsen> I figured out my own problem.  I was thinking that a recursively-defined array I was using was not being evaluated lazily, and hence was taking a very long time to evaluate the value of the ``base'' term of the array.  It was taking a long time, but that was due to the creation of all the required thunks.
12:00:19 <SamB> dons: it isn't really
12:00:24 <Heffalump> no, haskelldb generates the queries for you
12:00:59 <SamB> the langauge of the combinators is, mostly... generating the SQL queries not so much...
12:01:20 <Heffalump> the whole SQL landscape needs sorting.
12:01:30 <Heffalump> Good job for the hackathon, methinks.
12:08:10 <dozer> is there a haskell hackathon comming up?
12:08:45 <Heffalump> yes, in Gothenburg
12:09:06 <dozer> oh - never been there - can you give me a URL or dates or something?
12:09:52 <TomMD> @where hackathon
12:09:53 <lambdabot> I know nothing about hackathon.
12:10:08 <TomMD> @go haskell hackathon
12:10:09 <lambdabot> http://www.haskell.org/haskellwiki/Hac_2007_II
12:10:09 <lambdabot> Title: Hac 2007 II - HaskellWiki
12:10:19 <Heffalump> nope :-(
12:10:32 <Heffalump> linked from the frontpage of haskell.org
12:10:59 <TomMD> @where+ hac08 http://www.haskell.org/haskellwiki/Hac_2008
12:10:59 <lambdabot> Good to know.
12:11:20 <TomMD> There should be an over arching wiki page for the hackathons
12:11:45 <Heffalump> agreed
12:11:51 <Heffalump> well volunteered :-)
12:12:24 <TomMD> nm, there is one
12:12:31 <TomMD> @where+ hackathon http://www.haskell.org/haskellwiki/Hackathon
12:12:31 <lambdabot> I will remember.
12:13:22 <dozer> mm, not enough time for me to organise to come ;(
12:13:41 <dozer> if there's one in 6 months or so, I will attend
12:13:55 <Heffalump> I'm sure there'll be one at ICFP
12:14:53 <tibbe> evening #haskell
12:15:01 <Heffalump> though a venue might be hard as there are no local FP research groups AFAIK
12:15:49 * SamB thinks he almost has class aliases implemented to the point where they won't typecheck
12:15:49 <conal> yo tibbe
12:16:04 <SamB> oh, I spoke too late!!!
12:16:08 <SamB> they already failed to typecheck
12:16:13 * tibbe is trying to implement HTTP 1.1, it's resisting his attempts
12:16:26 <tibbe> conal: I used lots of more AF now :) they're great
12:16:38 <conal> tibbe: !! :) :)
12:17:08 <tibbe> conal: wrote a incremental parser library that is applicative and alternative but not monadic and used it for parsing HTTP
12:17:26 <conal> tibbe: awesome!
12:17:41 <conal> tibbe: in what sense incremental?
12:18:02 <tibbe> conal: you can for example feed it data from the network as you receive it
12:18:02 <dons> tibbe: very nice
12:18:13 <conal> tibbe: generates some output before consuming all the output?
12:18:32 <tibbe> conal: and avoid problems with the iterator/lazy bytestring style (as described by oleg)
12:18:55 <tibbe> conal: no, it gives you a continuation you can keep on to until you get more data
12:19:17 <conal> tibbe: great!  are you writing it up for icfp or hw?
12:19:24 <tibbe> and it is nice and fast even without any rewrite rules optimization as of yet :)
12:19:28 <conal> i'd love to see more AF examples in the wild.
12:19:36 <tibbe> conal: I'm not sure it's worth writing up
12:19:40 <tibbe> conal: maybe when it's done
12:20:02 <tibbe> conal: now once it is written it feels kinda trivial
12:20:16 <Cale> tibbe: The best ideas always do
12:20:20 <tibbe> conal: but I'm thinking about doing some kind of write up on the web server once it's finished
12:20:33 <conal> tibbe: yeah -- my stuff, too.  i work like crazy to get things simple, and then have doubts whether they're worth publishing.
12:20:44 <conal> tibbe: please do.
12:20:48 <tibbe> Cale: but it's nothing new really, it's some ideas from the LogicT backtracking, some AF and that's it
12:21:07 <tibbe> Cale: it's like 200 lines of code for the basics!
12:21:29 <Cale> 200 lines of code isn't trivial
12:21:40 <tibbe> and it's similar to Adam Langley's parser on the API layer
12:22:23 <tibbe> Cale: there are comments ;) I should have said a 200 line file. although that includes no parser combinators as I use the ones in Control.Applicative, I will include quite a few rewrite rules I hope for some nice speedups
12:23:04 <desegnis> QuickCheck is 335 lines
12:23:17 <tibbe> but once it's done I'll make a post and people can tell me if they want me to write something about it
12:23:21 <Peaker> how is the type "(a,a) a -> Int" read in English? Is it different from "(a,a) -> a -> Int" ?
12:23:32 <Cale> Peaker: Syntax error.
12:23:46 <Saizan> > concat . zipWith (\i -> map (fmap (const i))) (concatMap (replicate 2) [0..]) . group $ [Nothing,Nothing,Just 'a',Just 'a', Nothing,Nothing,Nothing, Just 'b', Just 'b']
12:23:47 <lambdabot>  [Nothing,Nothing,Just 0,Just 0,Nothing,Nothing,Nothing,Just 1,Just 1]
12:24:02 <Peaker> http://www.haskell.org/tutorial/arrays.html defines: class  (Ord a) => Ix a  where            index       :: (a,a) a -> Int
12:24:02 <lambdabot> Title: A Gentle Introduction to Haskell: Arrays
12:24:05 <nolrai_> ghc is refusing to follow imports that have more than one '.'. this has happend to me before but i dont remember what i did to fix it. any ideas?
12:24:16 <Cale> Peaker: That's a typo
12:24:20 <Cale> :t index
12:24:21 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Int
12:25:03 <Peaker> Cale, oh, thanks.  As a Haskell newbie, I find the possibility of typos much lower than the possibility of my misunderstanding, so maybe a tutorial is not the place to have these typos :)
12:25:12 <Cale> hehe
12:25:28 <Cale> I'm surprised that there are still typos in that tutorial, given its age.
12:26:08 <Peaker> Cale, well, if nobody fixes this typo now, its understandable :)
12:26:22 <Saizan> ?type let foo :: (a,a) a -> Int; foo = undefined in foo
12:26:23 <lambdabot>     Kind error: `(a, a)' is applied to too many type arguments
12:26:24 <lambdabot>     In the type `(a, a) a'
12:26:24 <lambdabot>     In the type `(a, a) a -> Int'
12:26:33 <Cale> You might try sending an email to one of the authors.
12:27:12 <dons> nolrai_: ? -i.. ?
12:27:39 <SamB> man, overhauling JHC to support MPTCS would not be easy
12:28:15 <nolrai_> dons: but why would it work for ones with only one '.'? I try that though any way.
12:28:29 <Peaker> Cale, no easily accessible mailto: in the tutorial
12:28:41 <Peaker> Cale, maybe it should be converted to a wiki?
12:28:48 <conal> tibbe: is your blog on planet haskell?  if not, what's the url?
12:28:49 <dons> nolrai_: i often use  -i.. -i../dist/build/
12:29:03 <dons> oh, i don't think tibbe's is on p.h.o!
12:29:31 <tibbe> conal: it's nonexistent at the moment! I plan to use it for dog fooding my new server
12:29:37 <desegnis> Now that dons and Cale are around... Have there been any insights on the question raised this noon about poor efficiency of a list comprehension vs. filter?
12:29:40 <conal> tibbe: oh! :)
12:29:41 <Cale> I might have John Peterson's email...
12:30:11 <tibbe> conal: I'm procrastinating / hacking too much! ;)
12:30:20 <Cale> jpeterson@western.edu
12:30:24 <dons> desegnis: what's the code?
12:30:59 <Cale> That was in 2006, hopefully he still has that address.
12:31:08 <tibbe> I have exactly one problem left to solve in my web server implementation, how to deal with the fact that recv will end up giving me more bytes than I need so I need to tuck away those bytes somewhere until I continue with the next request.
12:31:13 <conal> tibbe: fun is good!
12:31:35 <Cale> He also maintain(s/ed) the haskell.org website, so he probably has write permissions there.
12:32:08 <tibbe> I have dealt with flag handling nicely thanks to dcoutts_ ideas, server state/environment thanks to xmonad, parsing thanks to AF and now I need to implement pipelining and chunked transfers correctly
12:32:16 <desegnis> > let pyth3 = [1..] >>= \x -> [1..x-1] >>= \y -> [1..y-1] >>= \z -> guard (x*x == y*y + z*z) >> return (x,y,z) in take 5 pyth3  -- this is rather slow
12:32:18 <lambdabot>  [(5,4,3),(10,8,6),(13,12,5),(15,12,9),(17,15,8)]
12:32:22 <tibbe> and enumerator thanks to oleg!
12:32:27 <Peaker> Cale, any chance you can send him the link/typo?
12:32:28 <desegnis> > let pyth4 = [1..] >>= \x -> [1..x-1] >>= \y -> filter (\z -> x*x == y*y + z*z) [1..y-1] >>= \z -> return (x,y,z) in take 5 pyth4  -- this is rather fast
12:32:29 <lambdabot>  [(5,4,3),(10,8,6),(13,12,5),(15,12,9),(17,15,8)]
12:32:30 <tibbe> lots of nice ideas I could profit from
12:32:33 <Cale> Peaker: sure
12:32:36 <Peaker> Cale, thanks
12:33:00 <desegnis> dons: not the clearest snippets, but the first what I found in my logs
12:33:31 <desegnis> dons: The first one should be a desugared list comprehension
12:33:52 <dons> well, no. since its not desguared to build/foldr as ghc does
12:33:57 <dons> so it won't fuse
12:34:09 <dons> that's the h98 desugaring, isn't it?
12:34:17 <desegnis> dons: anyway the real problem was a true list comprehension, wait
12:34:42 <dons> ok
12:35:13 <desegnis> dons: This is the OP's paste: http://hpaste.org/6386
12:35:55 <Heffalump> I suggested it for dons+dcoutts mainly because it's a good example to check out with stream fusion.
12:36:03 <desegnis> (btw, ziman: ping)
12:36:16 <dons> oh yes, classic deeply nested comprehensions
12:36:26 <dons> good stream fusion test case
12:36:40 <Heffalump> how is getting that finished up properly going, btw?
12:36:42 <Cale> There's a much faster way to generate Pythagorean triples.
12:36:59 <desegnis> Cale: I think that's not the point ;)
12:37:17 <ziman> desegnis, pong
12:37:29 <dons> Heffalump: rl's recently improved SpecConstr a lot for NDP, to make fusion work there better, so likely benefits streams as well
12:37:38 <desegnis> ziman: Just pointing you to the discussion of your paste around us
12:37:42 <Cale> desegnis: What is the point? :)
12:38:09 <ziman> desegnis, thanks :)
12:38:19 <desegnis> Cale: Finding out why the list comprehension is slower than the (basically) same algorithm expressed differently
12:39:28 <ziman> this seems to be the case only when -O is turned on
12:39:46 <eu-prleu-peupeu> hello
12:39:53 <eu-prleu-peupeu> is haskell better than OCaml ?
12:40:15 <TomMD> Depends on what you need to do.  I advise looking at the strengths of each and deciding for yourself.
12:40:15 <dons> there's no obvious ordering for programming languages.
12:40:18 <dons> they're different
12:40:22 <allbery_b> in whose opionion? and for what purpose?
12:40:52 <eu-prleu-peupeu> hmm
12:40:59 <eu-prleu-peupeu> ok
12:41:06 <eu-prleu-peupeu> and lisp, is haskell better than lisp ?
12:41:11 <allbery_b> same response
12:41:20 <TomMD> I think any "is language x better than y" is going to get the same answers.
12:41:24 <desegnis> dons: So if stream fusion were perfect, then fusion would happen, and the list comprehension would perform similarly to the alternative?
12:41:36 <eu-prleu-peupeu> ok
12:41:44 <dons> desegnis: it would probably yield better code than all :) you'd get unboxed loops
12:41:49 <dons> but i've not tried
12:41:54 <nolrai_> my librarys dont have Control/Monad/State.hs did the MTL get taken out or somthing?
12:41:57 <dons> currently, you have to desguar comprehensions anyway
12:41:59 <eu-prleu-peupeu> what is the best programming language in the world ?
12:42:07 <dons> eu-prleu-peupeu: wrong channel.
12:42:16 * allbery_b knows quite a few languages and continues to learn more --- because there's almost always some purpose for which some language is better suited than others, and it's good to use the appropriate tool for a job instead of having one big hammer
12:42:17 <gnuvince_> eu-prleu-peupeu: HTML
12:42:20 <dons> do you have a question about haskell, eu-prleu-peupeu ?
12:42:22 <Cale> eu-prleu-peupeu: That question is meaningless.
12:42:32 <eu-prleu-peupeu> gnuvince: html is not turing complete
12:42:48 <dons> that's what makes it so awesome
12:42:49 <eu-prleu-peupeu> hmm ok
12:42:49 <Cale> eu-prleu-peupeu: Heh, that doesn't mean it can't be the best.
12:42:54 * EvilTerran starts chanting ancient and terrible incantations
12:42:59 <eu-prleu-peupeu> is haskell the best language in the world ?
12:43:00 <Cale> eu-prleu-peupeu: It depends on what you mean by 'best', of course.
12:43:03 <gnuvince_> eu-prleu-peupeu: I was jerking you around; as dons, Cale and other mentionned, there's no "best" language.
12:43:03 --- mode: ChanServ set +o dons
12:43:06 --- mode: dons set +b *!*=Hugo_Gom@89.214.120.*
12:43:06 --- kick: eu-prleu-peupeu was kicked by dons (dons)
12:43:09 <TomMD> thank you dons.
12:43:10 --- mode: ChanServ set -o dons
12:43:12 <EvilTerran> yay, they worked.
12:43:16 * allbery_b was getting to that point too
12:43:24 <TomMD> EvitTerran: Are you talking about the kicking or some Haskell code?
12:43:28 <EvilTerran> the kicking :P
12:43:36 <monochrom> hahaha, html
12:43:40 <allbery_b> (but is somewhat loath to just pop up ops and kick someone)
12:43:53 <allbery_b> html+css?  html+js?  html+vba?
12:43:55 <dons> very suspicious ip, silly attempt at trolling.
12:44:02 <EvilTerran> i had him marked as a troll from the first question
12:44:04 <dons> they don't make trolls like they used to
12:44:09 <EvilTerran> suspicious IP?
12:44:09 <monochrom> html is turing complete if you give it a different semantics.
12:44:17 <desegnis> dons: Thanks, so we know at least, from an authorative source, where the performance difference comes from
12:44:20 <monochrom> for example <p> stands for recursion... :)
12:44:37 <dons> desegnis: the ultimate answer is to look at the core
12:45:57 * monochrom is a sophisticated, λ-calculus-complete troll.
12:46:08 <dons> that's true enough
12:46:14 <monochrom> haha
12:46:21 * monochrom hides
12:46:25 <smg> λ-calculus is cool.
12:46:32 <EvilTerran> monochrom, untyped, simply typed, System F_omega, ...?
12:46:32 <smg> n-reduction too. and utf8. :]
12:46:40 <Cale> λ-calculus is the best programming language
12:46:42 <Cale> ;)
12:46:49 <Peaker> UTF8 is not that cool :)
12:47:04 <marshmallows> λ-calculus + pattern-matching is better :P
12:47:05 <Cale> smg: You mean η-reduction.
12:47:07 <Cale> ;)
12:47:08 <EvilTerran> utf-8 is pretty darn cool...
12:47:16 <Peaker> EvilTerran, why is it cool?
12:47:19 <unenough> should be called WTF8
12:47:24 <dons> at some point we do need to declare #haskell at utf-8 channel
12:47:26 <monochrom> haha
12:47:32 <smg> Cale: ah yes, η here is η :)
12:47:39 <Cale> This entire network is a utf-8 network.
12:47:48 <smg> hehe
12:47:51 <conal> does anyone know how to get these nifty chars to show up in emacs/erc?
12:47:52 <monochrom> #haskell : utf-8 :: haskell : ghc   {- de facto -}
12:47:55 <smg> i like utf8 because i can write all special chars.
12:47:55 <dons> right, but just state it as official policy. that utf8 is ok.
12:47:57 <EvilTerran> well, it's compatible with 7-bit ASCII, and yet contains gazillions of characters
12:48:00 <Peaker> הסקל היא כבר תחנה של UTF8
12:48:08 <desegnis> Does "look at the core" generally refer to -ddump-ds?
12:48:19 <dons> desegnis: -ddump-simpl and -ddump-simpl-stats
12:48:24 <desegnis> dons, thanks
12:48:26 <dons> i.e. what your code looks like after optimising
12:48:30 <dons> and which rules fired
12:48:34 <EvilTerran> and lets you use funky unicode characters without your file-size doubling or quadrupling
12:48:51 <EvilTerran> (as long as you don't use them everywhere)
12:48:53 <ziman> well, the -ddump-simpl code is quite unreadable, at least for me
12:49:03 <nolrai_> So is there some reasom my libraries dont have Control/Monad/State.hs?
12:49:38 <nolrai_> Do i have to like install it seperate from ghc 8?
12:49:48 <Cale> odd, if I type greek characters in emacs, they show up bold.
12:49:48 <TomMD> I've often thought that a 'diff' for -ddump-simpl would help (which would remove all the noise generated by variable names never being consistent).
12:50:11 <Cale> conal: I'm afraid I've never used erc...
12:50:22 <EvilTerran> nolrai_, well, you could try that...
12:50:50 <EvilTerran> ?hackage mtl
12:50:50 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mtl
12:51:19 <nolrai_> I've never used hackage. is it hard?
12:51:26 <Cale> nolrai_: No, it's easy.
12:51:56 <Cale> nolrai_: You can either download packages by hand, or you can get cabal-install, which will download and install them for you.
12:52:05 <EvilTerran> download the .tar.gz, extract, runhaskell Setup.(l)hs configure, runhaskell Setup.(l)hs build, runhaskell Setup.(l)hs install. or cabal-install
12:52:18 <dons> TomMD: yes, in fact, i think ide support would be good
12:52:27 <dons> show the core generated by the code, as you're typing it
12:52:55 <TomMD> Yes, very cool... something you would be interested in, dons?
12:53:02 <dons> yeah, i could find it useful.
12:53:06 <SamB> dons: that sounds ... impossible
12:53:08 <dons> maybe something to think about before the hackathon
12:53:18 <dons> SamB: just show the core in one buffer, the code in the other
12:53:23 <dons> hit some key stroke to regenerate
12:53:24 <SamB> considering all the transformations that happen that involve the entire module being well-formed
12:53:29 <dons> and try to line up the top level definitions
12:53:45 <dons> not *interactive*, but at the same time, side by side
12:53:47 <cjb> conal: I'm using emacs/erc, and I see the nifty characters.
12:54:03 <SamB> dons: you said "as you're typing in"
12:54:06 <cjb> conal: I guess just make sure that your $LANG contains UTF-8 and that you have a font with the right coverage.
12:54:13 <dons> SamB: right.
12:54:26 * nominolo_ hates bugs in libraries :/
12:54:29 <conal> cjb: thx.  what's $LANG?
12:54:31 <Cale> It might help to use the new fancy emacs with freetype 2 support.
12:54:45 <cjb> conal: an environment variable that contains your locale, on Unix.
12:55:21 <SamB> I don't have a $LANG that I know of
12:55:31 <SamB> oh, huh, but I have one
12:55:32 <nolrai_> how does one install cabal? it looks useful.
12:55:32 <cjb> thunk:cjb~ % echo $LANG
12:55:32 <cjb> en_US.UTF-8
12:55:41 <SamB> yeah, me too
12:55:49 <SamB> I forgot what the variable was called I guess
12:55:54 <conal> i just tried changing my "mule language environment" to utf-8.  would someone please spout some utf-8 at me?
12:56:01 <smg> LC_ALL="en_US.UTF-8" :)
12:56:11 <marshmallows> ⌘⌚⌘
12:56:13 <gwern> foreign import ccall unsafe "curses_wrapper.h" gety ∷ Window → IO CInt
12:56:15 <dons> a wiki page for utf8 irc would be nice to add
12:56:20 <cjb> 15:48 <Peaker> הסקל היא כבר תחנה של UTF8
12:56:23 <roconnor> > 2^67
12:56:24 <lambdabot>  147573952589676412928
12:56:31 * EvilTerran needs a font with better unicode coverage =/
12:56:37 <conal> yeeps -- black rectangles.  i guess that's progress.  probably inadequate font.  thanks.
12:56:38 <smg> hehe
12:56:43 <Peaker> cjay, what about it?
12:56:43 <cjb> EvilTerran: DejaVu Sans is very good for that.
12:56:48 <gwern> conal: timeout ∷ Int → IO ()
12:56:48 <gwern> timeout = timeout_c ○ fromIntegral
12:56:51 <SamB> conal: you should try the font menu
12:56:53 <EvilTerran> i'd prefer monospaced...
12:57:00 <cjb> EvilTerran: DejaVu Sans Mono.  :)
12:57:03 <SamB> that set it to the, er, standard set
12:57:06 <conal> hm.  i'm on windows.  any recommendations there?
12:57:14 <SamB> oh.
12:57:17 * gwern seconds dejavu, 'tis what I use as well
12:57:20 <SamB> no clue how emacs uses fonts on windows
12:57:26 <EvilTerran> i have the dejavu fonts, but they're a wee bit ugly imo. i guess they work.
12:57:26 <cjb> yeah, me either.
12:57:27 <Peaker> that sentence is "Haskell is already a UTF8 channel", btw
12:57:31 <desegnis> cjb, EvilTerran, I'd suggest DejaVu Serif, but well... :)
12:57:51 * conal will someday leave windows behind
12:58:10 <gwern> conal: there is no day like the present
12:58:12 <shapr> hiya cjb!
12:58:17 <cjb> 'lo.
12:58:20 <EvilTerran> and they appear to not cover hebrew, while Courier New does
12:58:25 * shapr boings cheerfully
12:58:30 <conal> gwern: i haven't been able to get dual-head to work on my linux machine
12:58:37 <conal> otherwise, i'd be there.
12:58:59 <SamB> well, my machine doesn't have any heads
12:59:01 <SamB> so there
12:59:09 <shapr> Yay Higher Order Abstract Syntax!
12:59:20 <conal> shapr: for what?
12:59:31 <shapr> conal: For an assembler, sort of.
12:59:37 <gwern> conal: if thy second head offends thee, pluck it out! better to enter into the Kingdom of Freedom with only one head, than Windows with heads intact
12:59:47 <shapr> x64-specific
12:59:48 <conal> gwern: lol :)
13:00:11 <conal> shapr: boast warning: i co-authored the first HOAS paper
13:00:16 <shapr> ooh!
13:00:17 <shapr> Where is it?
13:00:25 <conal> my home page
13:00:25 <gwern> what profiteth a coder to gain a screen, and lose his soul?
13:00:28 <conal> @where conal
13:00:28 <lambdabot> I know nothing about conal.
13:00:36 <shapr> uh oh
13:00:38 <conal> @where+ conal http://conal.net
13:00:38 <lambdabot> Okay.
13:00:42 <shapr> @where conal
13:00:42 <lambdabot> http://conal.net
13:00:43 <shapr> yay
13:00:55 <idnar> shapr: YAYHOAS?
13:00:58 <conal> :)  i guess the where db got nuked at some point.
13:01:00 <idnar> :D
13:01:25 <conal> shapr: really, my pubs page: http://conal.net/papers
13:01:25 <lambdabot> Title: Conal Elliott&#146;s Publications
13:01:43 <conal> shapr: second from the bottom.
13:01:52 <shapr> conal: I hadn't even graduated high school then!
13:02:09 <shapr> I had found the internet though...
13:02:15 <conal> shapr: did you graduate from high school?
13:02:20 <shapr> conal: Sure, 1989
13:02:39 <shapr> Spent lots of years in college after that.
13:02:55 <conal> shapr: oh -- i wonder where i got the idea that you dropped out of high school.
13:02:56 * shapr reads conal's HOAS paper.
13:03:15 <shapr> conal: Nah, I dropped out of college after umpteen years. I had enough credits for a master's degree, but not enough in any one subject to get any sort of actual degree.
13:03:46 <conal> shapr: is the no-degree thing holding you back?
13:03:56 <shapr> Very much so.
13:04:05 <shapr> I got turned down from several Haskell jobs because of that.
13:04:05 <conal> oh, oog :(
13:04:09 <jso> shapr: sounds like my future. :(
13:04:22 <shapr> jso: There is a solution... get a degree!
13:04:26 <shapr> That's much of why I'm here in Boston now.
13:04:35 <jso> shapr: but taking classes is too much fun!
13:04:40 <gwern> 'ah, college - the best ten years of my life'
13:04:41 <cjb> shapr: ooh, going back to school?  where?
13:04:47 <conal> shapr: wow -- i'm surprised that anyone non-mainstream enough to want Haskell would care much about degrees.
13:04:51 <jso> gwern: :)
13:04:53 <shapr> cjb: In Boston, not sure which uni yet. Northeastern looks tempting.
13:04:55 <EvilTerran> gwern, ten?! you lack ambition, sir!
13:05:18 <shapr> cjb: Got any suggestions?
13:06:01 <gwern> conal: I think shapr is really a poseur
13:06:16 <rnorris> what's the secret for catching an exception thrown from pure code?
13:06:17 <gwern> EvilTerran: or I have too much, one or t'other...
13:06:22 <rnorris> catch (return (1 / 0 :: Rational)) (\_ -> return 3) doesn't work, for example
13:06:23 <nolrai_> how does one install cabal-install?
13:06:24 <roconnor> 67 * logBase 10 2
13:06:26 <roconnor> > 67 * logBase 10 2
13:06:27 <lambdabot>  20.169009709486737
13:06:36 <EvilTerran> in truth, i'm aiming for about that, actually. five-year degree + graduate study + phd...
13:06:43 <shapr> gwern: I have ops too :-)
13:06:45 <EvilTerran> er, four-year degree
13:06:48 <gwern> nolrai_: you cabal-install it, usually
13:07:00 <nolrai_> ??
13:07:14 <gwern> shapr: Ima not ascared of you! my mommy always told me to standa up to bullies!
13:07:37 <EvilTerran> gwern, oh, so *that*'s what happened to you...
13:07:38 <cjb> shapr: no, no suggestions.  can probably put you in touch with a CS grad from any of the schools if that helps.
13:07:39 <gwern> nolrai_: less facetiously, you go and install the darcs cabal, and then you go find the darcs cabal-install
13:07:41 <EvilTerran> (:P)
13:09:27 <EvilTerran> rnorris, the problem with doing stuff like that is, because haskell's order of evaluation is weird, it can be very difficult to know when an exception will be thrown
13:09:34 <desegnis> rnorris: Control.Monad.Exception.catch
13:09:42 <shapr> cjb: I need to get an undergrad degree first.
13:09:54 <shapr> cjb: But after that, I'll definitely appreciate grad school advice.
13:09:55 <EvilTerran> at least, i think that's the problem...
13:10:01 <rnorris> ok yeah i think i need to force evaluation inside that block. thanks
13:10:28 <shapr> Does anyone use darcs on win32?
13:10:39 <SamB> some people do
13:10:40 <EvilTerran> i've done so. i think.
13:10:41 <Heffalump> EvilTerran: why would you need graduate study *and* phd? surely with a 4-year masters you can go straight into the latter?
13:10:45 <Heffalump> shapr: I do
13:10:49 <SamB> ndm must surely do so
13:10:49 <EvilTerran> true
13:10:50 <Heffalump> it's not pleasant :-(
13:11:23 <EvilTerran> Heffalump, yeah, i'm not really paying attention here. as you could gather from me thinking my degree was five years not four. :P
13:11:40 <SamB> EvilTerran: wait, why is that strange?
13:11:40 <shapr> Is there a production quality Control.Comonad module?
13:11:41 <Heffalump> :-)
13:11:56 <EvilTerran> SamB, why's what strange?
13:12:02 <SamB> 5 year?
13:12:07 <cjb> shapr: What kind of degree would you go for, btw?  Perhaps they'd take you for a masters program?
13:12:14 <EvilTerran> um... because my degree is four years?
13:12:16 <cjb> shapr: oh, sorry, just saw scrollback.
13:12:50 <shapr> cjb: I'd like to do a math undergrad to learn something, or maybe just anything at all to get to the graduate program.
13:13:01 <EvilTerran> SamB, comlab.ox.ac.uk doesn't even offer five-year undergrad degrees anyway, only three and four
13:13:03 <cjb> shapr: that makes sense.
13:13:32 <cjb> England's pretty easy-going on the degree length.  You can usually get a CS degree in three years.
13:13:38 <cjb> Uh, Ph. D, I meant.
13:13:52 <EvilTerran> you can get a degree in three years too :)
13:13:56 <shapr> Is there any Control.Comonad library options other than the one by Dave Menendez?
13:13:58 <cjb> yeah :)
13:14:13 <EvilTerran> but if you want a masters straight out of your undergrad (like me), it'll generally be four years
13:14:32 <EvilTerran> or five with one of them being on industry placement
13:15:06 <Saizan> anyone knows if unsafeInterleaveIO is enough portable to be used in cabal-install?
13:15:34 <nominolo_> better not
13:15:43 <nominolo_> Saizan: what for?
13:17:01 * conal likes rnorris's quit msg
13:17:35 <Saizan> nominolo: well, i've to implement a function that creates a .tar.gz archive for sdist, so we don't need tar on windows
13:17:37 <EvilTerran> reminds me of "sorry this is taking so long. bear with me" "yeah, i don't work so well when there's a grizzly in the room either"
13:17:50 <shapr> cjb: I'll have to balance a full time job with going to school, that should be an exciting way to amputate any social activities.
13:18:09 <cjb> shapr: hm, how would that work?
13:18:24 <cjb> do they have undergrad night classes?
13:18:38 <nominolo> Saizan: why can't it be in IO ?
13:18:59 <Saizan> nominolo: but since compress from zlib expects a unique ByteString i've to either keep the files open with hGetContents or load all the contents in memory first
13:19:08 <Saizan> nominolo: it is in IO
13:19:17 <shapr> cjb: I hope so, or weekend classes.
13:19:23 <shapr> cjb: That's one of my constraints.
13:19:32 <nominolo> Saizan: can't you just write an external tar in Haskell?
13:19:44 <cjb> shapr: *nod*
13:20:46 <Saizan> nominolo: you mean a separate program?
13:20:51 <nominolo> yep
13:20:59 <nominolo> should be simple enough
13:21:33 <Saizan> yeah, actually we've that, but i suppose we wanted to keep dependencies to a minimum
13:21:46 <shapr> cjb: That does make me wish I'd done this ahead of time.
13:21:56 <Saizan> that's why cabal-install already has a tar-extract implementation in Hackage.Tar
13:22:01 <nominolo> but what's wrong with f <- liftM untar hGetContents ?
13:22:06 <nominolo> er
13:22:18 <nominolo> f <- untar =<< hGetContents
13:22:54 <Saizan> nominolo: sdist needs to create the tar archive, so it has to read the various files, create a single tar ByteString and compress it
13:23:55 <nolrai_> so where does cabal put the libs it installs?
13:23:57 <nominolo> Saizan: but sdist will be implemented by Cabal-install rather than Cabal now?
13:24:18 <nominolo> nolrai_: to where GHC or you say it should
13:25:51 <Saizan> nominolo: that's the plan, according to this http://hackage.haskell.org/trac/hackage/ticket/40
13:25:53 <lambdabot> Title: #40 (sdist runs tar, which is a problem under Windows) - Hackage - Trac
13:26:17 <shapr> xemacs and haskell-mode just aren't happy on win32
13:26:37 <nominolo> Saizan: right. so what are you trying to do?  Implement a simple tar/untar pair in Haskell?
13:26:39 <Peaker> xemacs is obselete'd by the emacs 22 isn't it?
13:26:43 <bpalmer> shapr: oh?
13:27:07 <Saizan> nominolo: the untar pair is already there in Hackage.Tar, i'm trying to implement the tar side
13:27:09 <conal> emacs be praised
13:27:10 <unenough> i don't think xemacs people think it's obsolete
13:27:22 <Saizan> s/pair/side/
13:27:33 <nominolo> Saizan: i don't understand why you need to make it a pure function.  it's a lazy bytestring, you use lazy IO, so everything will be fine
13:27:39 <sieni> Peaker: xemacs has been obspeted by vim a long time ago
13:27:45 <Peaker> sieni, haha
13:27:50 <Saizan> nominolo: yeah, i don't what to make it a pure function
13:27:57 <Saizan> ?type unsafeInterleaveIO
13:27:59 <lambdabot> Not in scope: `unsafeInterleaveIO'
13:28:08 <Saizan> nominolo: but i do want to use lazy IO
13:28:40 <Saizan> nominolo: and readFile is not enough lazy, so i need unsafeInterleaveIO to make it lazier
13:29:13 <nominolo> Saizan: it is not?
13:29:34 <sebell> shapr: Are you using the XEmacs package for haskell-mode?
13:29:47 <nominolo> "Read an entire file lazily into a ByteString."
13:29:49 <unenough> Peaker, i think you meant emacs 22 obseletes emacs 21
13:29:53 <shapr> sebell: I was, but it appeared to be older than the one by stefan monnier, so I grabbed that one and updated.
13:29:59 <Saizan> nominolo: yes, but it opens the file strictly
13:30:02 <xs> hi. i have an n by m grid, whose components can be in one of two states. the grid is frequently updated. i'm using an IArray, and i've also tried a UArray, but neither gives good performance (number of updates is typically in the millions). any ideas about a good data type?
13:30:16 <shapr> sebell: Now I'm having problems with cabal-minor-mode when I try to dump the buffer into ghci via C-c C-l
13:30:20 <Saizan> nominolo: which can become a problem if we've a large number of files
13:30:21 <sebell> shapr: It probably is older, but it should at least work ;)
13:30:22 <Peaker> unenough, I don't know of anyone who still wants to use xemacs after emacs22, or any feature xemacs still has that emacs22 doesn't
13:30:28 <xs> (bad performance means, too much memory use)
13:30:28 <shapr> sebell: It doesn't, sadly.
13:30:34 <sebell> shapr: Bummer!!
13:30:40 <shapr> sebell: charsetp appears to be defined, but not working on win32
13:31:16 * cjb switched from xemacs to emacs during emacs22.
13:31:20 <unenough> Peaker, an extra "X"
13:31:23 <shapr> Since haskell-mode can pull some of the pretty-lambda chars from jis-whatever, charsetp gets called to see if the japanese charset exists, and the whole thing craps out.
13:31:38 <nominolo> Saizan: supposedly System.IO.Unsafe is portable
13:31:45 <shapr> cjb: I switched to gnumacs for awhile, but xemacs has lots of nice stuff that isn't in gnumacs.
13:32:02 <unenough> shapr, like what?
13:32:14 <unenough> (i.e. "such as")
13:32:23 * cjb likes the pretty lambda chars.
13:32:27 <shapr> For example, eshell-toggle-cd is really nice
13:32:33 <sebell> shapr: Unfortunately I haven't used XEmacs on Win32 in quite some time, and I don't have a Win32 box available. bpalmer probably does though
13:32:37 <Saizan> nominolo: hugs has it, i can't tell if nhc or yhc do
13:32:52 <shapr> The electric-whatever completion code in gnumacs does not cover as much autocompletion as xemacs does.
13:33:31 <shapr> In my opinion, emacs newbies should start with xemacs, it's far more user friendly. Once you get past the point of needing emacs to be friendly, gnumacs has better support in general.
13:34:00 <shapr> On the other hand, one of my biggest points against gnumacs was recently solved.... RMS is no longer the maintainer.
13:34:23 <nominolo> Saizan: yhc: unsafeInterleaveIO f = return (unsafePerformIO f)
13:34:27 <nolrai_> whats the syntax for existantial datatypes with multiple constructors?
13:34:57 <czakey> hi
13:35:12 <shapr> hiya czakey
13:35:18 <nominolo> Saizan: http://darcs.haskell.org/yhc/src/packages/yhc-base-1.0/System/IO/
13:35:18 <lambdabot> Title: Index of /yhc/src/packages/yhc-base-1.0/System/IO
13:35:29 <shapr> bpalmer: Do you use xemacs on win32?
13:35:50 <shapr> sebell: How could I get the latest version of haskell-mode to show up in the xemacs packages?
13:37:02 <Saizan> nominolo: thanks :)
13:37:49 <Saizan> nominolo: i tried to avoid it just because it's unsafe but i see no other way
13:38:15 <sebell> shapr: M-x package-get-update-base RET maybe
13:38:26 <nominolo> Saizan: i don't think i really understand the issue, but at least it's portable
13:38:27 <hpaste>  czakey pasted "how to return String?" at http://hpaste.org/6394
13:38:40 <nominolo> Saizan: dcoutts can always reject the patch ;)
13:38:45 <shapr> sebell: Is there an xemacs-specific irc channel?
13:38:50 <Saizan> nominolo: sure :)
13:38:50 <czakey> how to return string in newEntry?
13:39:13 <sebell> shapr: #xemacs I believe. It's fairly quiet though
13:39:42 <sebell> shapr: Latest version of haskell-mode for XEmacs is 2.1, 2 years old
13:40:06 <czakey> command new <something>
13:40:12 <shapr> sebell: 2.4 mostly works
13:40:13 <nominolo> czakey: which string?
13:40:24 <czakey> shoud give client response
13:40:33 <czakey> and save something into a file
13:40:53 <czakey> so I have 'n':'e':'w':_ -> hPutStrLn h (newEntry newsfile)
13:40:57 <czakey> very ugly
13:41:03 <czakey> but works
13:41:06 <czakey> and then
13:41:13 <czakey> newEntry newsfile = do hPutStrLn newsfile "foo"
13:41:14 <nominolo> czakey: just capture the "_" and give it a name
13:41:30 <czakey> hm?
13:41:58 <czakey> how to do that?
13:41:58 <nolrai_> what {- LANGUAGE -} thingy do i need for forall?
13:42:07 <nominolo> 'n':'e':'w': foo -> ... doSomething foo
13:42:20 <nominolo> nolrai_: TypeOperators
13:42:21 <Heffalump> RankNTypes, or Rank2Types, or ExistentialQuantification, IIRC
13:42:28 <Heffalump> oh, ok :-)
13:42:44 <nominolo> well, i might be wrong
13:42:45 <czakey> hmm
13:42:54 <czakey> I'll try
13:42:58 <nominolo> i think type operators are "~>" and stuff
13:43:00 <Peaker> how does "const X" differ from just X?
13:43:03 <czakey> thanks
13:43:13 <nominolo> :t cost 42
13:43:15 <lambdabot> Not in scope: `cost'
13:43:19 <nolrai_> Peaker: type
13:43:19 <nominolo> :t const 42
13:43:21 <lambdabot> forall t b. (Num t) => b -> t
13:43:22 <dmhouse> Peaker: const x is a function that takes one parameter and returns x, no matter what that parameter is.
13:43:23 <nominolo> :t 42
13:43:24 <lambdabot> forall t. (Num t) => t
13:43:30 <Peaker> dmhouse, ah, thanks
13:43:49 <Peaker> nominolo, thank you too :)
13:43:53 <Cale> > filterM (const [True,False]) [1,2,3]
13:43:54 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
13:44:21 <unenough> powerset?
13:44:24 <Cale> yep
13:44:32 <unenough> how does it work? what's filterM?
13:44:45 <Cale> filterM is the monadically-generalised version of filter.
13:44:49 <nolrai_> Heffalump++
13:44:54 <Cale> In this case, it's using the list monad.
13:45:06 <dmhouse> ?type filterM
13:45:07 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
13:45:16 <Cale> The function you pass it takes a list element and returns a list of boolean decisions as to whether it should be kept
13:45:23 <Cale> Each of these is tried.
13:45:44 <Cale> So basically, that says "for each element of the list, regardless of what it is, keep it, or drop it"
13:45:51 <ziman> wow :)
13:45:53 <Cale> Which is, exactly the powerset.
13:46:11 <unenough> cool
13:46:25 <unenough> that is so much less lame than any other way!
13:46:26 <solrize_> is there a reason that type aliases don't do type checking?  i.e. type Red = Int, type Blue = Int,  (1::Red) + (2::Blue) adds just fine
13:46:44 <SamB> solrize: they wouldn't be aliases if they did
13:46:47 <SamB> try a newtype
13:46:52 <dmhouse> solrize_: they're the same type, so that's fine. Use newtypes if you actually want to create a new type.
13:46:57 <Peaker> If Maybe is a monad, what happens when you combine/augment Maybe's?
13:47:18 <czakey> hmm
13:47:18 <solrize_> with newtype I have to put those constructors everywhere, make Num instances, etc.
13:47:18 <solrize_> i want to be able to do (1::Red)+(2::Red)
13:47:19 <solrize_> just not mix red and blue
13:47:19 <Cale> Peaker: you mean with the monad operations?
13:47:24 <czakey> can I give more than one command in case
13:47:25 <SamB> Peaker: perhaps you meant to begin "if Maybe is a monoid"?
13:47:27 <Cale> Nothing >>= f = Nothing
13:47:33 <czakey> something like
13:47:36 <Cale> Just x >>= f = f x
13:47:43 <czakey> x -> foo
13:47:53 <Cale> x <- foo?
13:47:59 <Cale> er
13:48:02 <czakey> t -> { foo, bar, barr }
13:48:03 <Cale> oh, different context :)
13:48:12 <czakey> hehe sorry
13:48:16 <Peaker> oh, ok, augment is clear, how do you "combine" Maybe's?
13:48:20 <solrize_> newtype is a huge pain by comparison
13:48:25 <Cale> czakey: More than one command?
13:48:32 <czakey> hm
13:48:37 <Cale> czakey: What kind of command?
13:48:49 <czakey> I want to do something like:
13:48:53 <czakey> case ...
13:48:55 <Cale> czakey: The thing on the right of the -> in case is supposed to be a value.
13:48:55 <nominolo> solrize: ghc can derive instances for newtypes for you
13:49:05 <czakey>  x -> something
13:49:07 <solrize_> nominolo, hmm, how do i do that?
13:49:16 <solrize_> and is that ghc specific?
13:49:18 <czakey>  y -> something, something-else
13:49:18 <nominolo> LANGUAGE NewtypeDeriving
13:49:34 <nolrai_> nominolo: cool. how does that work?
13:49:37 <nolrai_> er
13:49:38 <Cale> {-# LANGUAGE NewtypeDeriving #-}
13:49:42 <nominolo> newtype Red = Red Int deriving (Num, Eq, Show, ...)
13:49:51 <Peaker> SamB, Cale: I meant the Maybe monad indeed.  I am looking at http://en.wikibooks.org/wiki/Haskell/YAHT/Type_advanced#Computations,  and it is unclear to me why combine (>>) is defined on Maybe's as ignoring the right-hand side
13:49:52 <lambdabot> http://tinyurl.com/39zrmw
13:49:56 <czakey> I cant find that anywhere
13:50:00 <nominolo> it does the unboxing for you and uses the instance for the embedded type
13:50:03 <solrize_> hmm that helps
13:50:11 <solrize_> so then I can say (Red 3) + 4
13:50:26 <solrize_> and the Num 4 will get treated as Red ?
13:50:32 <solrize_> hmm
13:50:43 <nominolo> > 4 :: Sum
13:50:44 <lambdabot>      `Sum' is not applied to enough type arguments
13:50:44 <lambdabot>     Expected kind `?', but...
13:50:48 <czakey> I want to do something like that:
13:50:51 <nominolo> > 4 :: Sum Int
13:50:51 <lambdabot>   add an instance declaration for (Num (Sum Int))
13:50:51 <lambdabot>     In the expression: 4 ::...
13:50:58 <Cale> Peaker: Ah, okay, well, it helps to look at >>= rather than >>
13:51:04 <solrize_> thanks
13:51:06 <solrize_> this is cool
13:51:14 <czakey> 'n':'e':'w':_ -> hPutStrLn h "something" AND hPutStrLn newsfile "foo"
13:51:18 <nolrai_> Peaker: think of it as an error conditon, keep computing unless you get a nothing then stop.
13:51:19 <Peaker> Cale, >>= is clear, but its not clear to me why >> just "randomly" takes one of the Maybe's
13:51:37 <Peaker> nolrai_, so a combine on maybe's is defined as just taking ANY of them that is not Nothing?
13:51:39 <nominolo> solrize_: yes that should work
13:51:43 <Cale> Peaker: x >> y is *always* defined as x >>= const y
13:51:57 <shapr> Do any problems result from wrapping a forall inside a newtype?
13:52:04 <TomMD> @src const
13:52:04 <lambdabot> const x _ = x
13:52:04 <nominolo> and often you write Newtypes like: newtype Red = Red { unRed :: Int } ...
13:52:07 <nolrai_> no thats the monoid.
13:52:26 <nominolo> > 4 :: Sum Int `mappend` mempty
13:52:26 <lambdabot>  Parse error at "`mapp..." (column 14)
13:52:41 <solrize_> peaker, m1 >>= m2 >>= m3 >>= ...      is m1 if all three are non-Nothing.   It's Nothing if ANY of them are Nothing.
13:52:42 <nominolo> > (4 :: Sum Int) `mappend` mempty
13:52:43 <lambdabot>   add an instance declaration for (Num (Sum Int))
13:52:48 <Cale> Peaker: If it's not defined as that, it's defined as something which is equivalent. (Sometimes there's a way to get better performance)
13:52:59 <solrize_> hmm maybe that's wrong
13:53:09 <nominolo> oh, right.  anyways it works with num instances
13:53:25 <Cale> solrize_: well, m2 and m3 won't have the same type as m1
13:53:42 <solrize_> oops
13:53:43 <solrize_> yeah
13:53:51 <Saizan> > getSum $ (Sum 4 ) `mappend` mempty 4
13:53:52 <lambdabot>  4
13:54:06 <solrize_> what I meant was:   do { m1; m2; m3; ...}
13:54:15 <nominolo> @instances-importing Num
13:54:16 <lambdabot> Double, Float, Int, Integer
13:54:18 <Cale> Or m1 >> m2 >> m3
13:54:25 <nominolo> :t (++)
13:54:26 <lambdabot> forall m. (Monoid m) => m -> m -> m
13:54:32 <Cale> ;)
13:56:03 <nominolo> > foldr1 (>>) [a,b,c]
13:56:04 <lambdabot>  Couldn't match expected type `m a' against inferred type `Expr'
13:56:04 <Peaker> solrize, Cale so Maybe is actually the opposite of what I said
13:56:22 <Peaker> solrize, Cale well not exactly, but now I get it, thanks!
13:56:29 <nominolo> there's mplus
13:56:48 <nominolo> > foldr1 mplus [Nothing, Just 4, Nothing]
13:56:49 <Cale> Peaker: It's just that >> isn't the primitive thing, so it turns out there's no choice in how to define it.
13:56:49 <lambdabot>  Just 4
13:57:23 <Peaker> Cale, why does it need to be defined at all then?
13:57:34 <Cale> Peaker: It doesn't have to be defined separately.
13:57:38 <nominolo> shapr: you can't wrap a forall in a newtype
13:57:42 <Peaker> Cale, optimization-purposes?
13:57:43 <nominolo> (i tried today)
13:58:00 <Cale> Yeah, if you're going to define it yourself, that would be the only reason.
13:58:20 <shapr> nominolo: Seems to work.
13:58:41 <nominolo> hm
13:59:02 <shapr> nominolo: In both 6.6.1 and 6.8.2
13:59:58 <hpaste>  nominolo pasted "newtype + existential" at http://hpaste.org/6395
14:00:13 <nominolo> shapr: i guess it was because my context is outside
14:00:19 <nominolo> shapr: but i think i need that
14:00:25 <jbjohns> Someone in #lisp just told me Lisp is (well can be with declares) statically typed, since SBCL will warn if you obviously violate a declare statement
14:00:56 <nominolo> jbjohns: it is Strongly typed and supports type declarations, yes
14:00:58 <Cale> newtypes can't be existential, because existentials are not isomorphic to any existing type
14:01:01 <tamere> @pl let p = sum $ map (2*) . filter even $ [1..100]
14:01:01 <lambdabot> (line 1, column 48):
14:01:01 <lambdabot> unexpected end of input
14:01:01 <lambdabot> expecting variable, "(", operator, "$", "$!", "`seq`", ";" or "in"
14:01:38 <nominolo> jbjohns: but it's messy
14:01:44 <dmwit> tamere: That's already point-free.
14:01:45 <jbjohns> but that's totally different then statically typed as in Haskell no?
14:01:50 <Cale> jbjohns: yes
14:01:59 <nominolo> jbjohns: it's only for performance
14:02:03 <dmwit> tamere: But in the future... you just need an "in" clause at the end.
14:02:12 <tamere> hehe i know
14:02:13 <dmwit> ?pl let f x = 2 * x in f
14:02:14 <lambdabot> (2 *)
14:02:15 <nominolo> jbjohns: in haskell you use it for more than just performance
14:02:17 <tamere> but i wonder who changed my nick...
14:02:46 <johnnowak> jbjohns: SBCL does do some static type checking, yes
14:03:02 <johnnowak> it will warn you if you do something stupid sometimes
14:03:28 <johnnowak> jbjohns: it can't enforce as much as something like haskell though
14:04:40 <nominolo> jbjohns: in Haskell you can use the type system to prevent you from stupid errors (even security problems, if done right)
14:04:49 <dons> the types in haskell are pervasive, and really shape the language. i imagine you could program lisp all day and never know about static types
14:04:56 <jbjohns> Anyone have a nice pointer to a formal definition of static typing?  One that supports my point please (as opposed to one that shoots it down :)
14:05:04 <shapr> nominolo: newtype B = B (forall b. <insert stuff>)
14:05:08 <shapr> nominolo: That's what we're using.
14:05:28 <johnnowak> jbjohns: he's not wrong. sbcl does offer some degree of static checking.
14:05:31 <jbjohns> dons:  sure, you have to put in a special statement to do the typing (really more of a compiler hint as I understood it)
14:06:09 <dons> right, so more like enabling extended warnings, than writing type system proofs about properties
14:06:13 <johnnowak> you'll get some warning even without hints
14:06:14 <nominolo> jbjohns: it's a primitive form of incremental static typing
14:06:44 <nominolo> jbjohns: primitive, because it has no formal basis (at least not that i know of)
14:06:45 <jbjohns> yea, that's what I wanted to call it, some kind of partial type checking, like what they propose for perl 6
14:06:50 <dons> perhaps that's the way to think about it. one is a simple form of what you see in full in haskell
14:07:15 <dons> like how you see simple forms of functional programming in ruby or python, so you see simple forms of static checking in some dynamically checked languages
14:08:03 <nominolo> dons: the compiler does that anyways .. for performance
14:08:16 <nominolo> that is, if you actually have a compiler
14:08:20 <dons> yeah, you need it if you want to do clever things at compilation time anyway
14:08:43 <dons> like the way purity is attempted to be recovered in C
14:09:01 <nominolo> how?
14:09:07 <dons> yet you wouldn't say C is a pure language, just because there's some compiler support for performance
14:09:11 <nominolo> using some annotations?
14:09:23 <dons> there's annotations, and i guess some effect inference
14:09:35 <dons> to recover the purity we start with in haskell by default
14:09:53 <nominolo> well, the problem always is that static type systems are pessimistic
14:09:56 <jbjohns> thanks for the answers all
14:09:58 <nominolo> so they can get in you way
14:10:04 <dons> yes, potentially.
14:10:13 <dons> you need a minimum level of expressivity
14:10:16 <roconnor> nominolo: what does it mean for a type system to be pessimistic?
14:10:18 <nominolo> that's why we have all those language extensions ;)
14:10:29 <nominolo> roconnor: reject if unsure
14:10:45 <dons> safe by default
14:10:46 <dons> :)
14:10:57 <nominolo> as opposed to optimistic typing like used for Erlang
14:11:10 <roconnor> oh okay.
14:11:15 <dons> that's the guiding prinicple: by default, do no harm
14:11:18 <johnnowak> heh, i like that. pessimistic and optimistic. surely that can be nicely twisted.
14:11:37 <nominolo> yeah
14:11:44 <skorpan> if i have a datatype Piece { pl :: String, rank :: a } and i create a function taking a Piece, how do i put the constraint that a must be showable?
14:12:01 <skorpan> Piece a = { pl :: String, rank :: a } that is
14:12:07 <johnnowak> dons: alternatively, dynamic languages are "by default, don't stop the programmer from doing good"
14:12:11 <Heffalump> f :: Show a => Piece a -> ...
14:12:35 <dons> johnnowak: or by default, assume the programmer is trying to do good
14:12:43 <skorpan> Heffalump: then i get:  Could not deduce (Show (Piece a)) from the context (Show a)
14:12:46 <johnnowak> sure
14:12:50 <dons> you have to assume they're not bad programmers :)
14:13:03 <dons> which is a big jump, imo, for some dynamic languages hehe
14:13:34 <johnnowak> and plenty of static languages...
14:13:43 <dons> yup
14:14:05 <dons> if only our CS courses were more thorough, i'd be more optimisitc :)
14:14:33 <lscd> do you know any place that does master's level CS courses in a particularly thorough way?
14:14:36 <Heffalump> skorpan: stick a deriving Show on the declaration of Piece
14:14:38 <johnnowak> i'd be more optimistic people were interested in learning rather than making sure they're already right
14:14:45 <nominolo> Chalmers is pretty good
14:14:45 <johnnowak> *if people
14:15:01 <nominolo> but I bet there are more
14:15:13 <lscd> sure, but the question is, which?
14:15:24 <Cale> The vast difference between dynamic and static typing is hidden by their similar names. They're not really two kinds of the same thing at all.
14:15:35 <nominolo> huh?
14:15:49 <Peaker> Cale, they do sound kinda.. opposite :)
14:15:52 <lscd> nominolo: which places do; the ones I'm more acquainted with, unfortunately, don't
14:16:01 * johnnowak wouldn't mind sweden...
14:16:01 <skorpan> nominolo: everyone knows chalmers is the greatest
14:16:05 <skorpan> there can be only one!
14:16:13 <hpaste>  nolrai_ pasted "why isn't the type system powerful enough to do what i want?" at http://hpaste.org/6396
14:16:37 <nominolo> skorpan: well, i honestly think it is.  and i actually did the masters
14:16:40 <Cale> Peaker: true, but they both sound like they have something to do with 'types', but really the 'types' are something different in each case.
14:16:46 <nominolo> skorpan: but i avoided all the java-courses
14:17:06 <skorpan> nominolo: java was a good introduction to oop imo
14:17:07 <nominolo> skorpan: though in one course i had to learn sequent calculus within one week
14:17:08 <solrize_> jbjohns, "A type system is a tractable syntactic method of proving the absence of certain program behaviors by classifying phrases according to the kinds of values they compute. "   (Pierce, TAPL)
14:17:20 * johnnowak is deeply disturbed by the java button on the chalmers website
14:17:22 <skorpan> nominolo: calculus in one week? which course was that?
14:18:16 <Cale> nolrai_: what error do you get?
14:18:46 <SamB> skorpan: sequent calculus
14:18:51 <nominolo> skorpan:TDA291  	Software engineering using formal methods
14:19:04 <Cale> nolrai_: er, that code typechecks.
14:19:05 <skorpan> nominolo: ah, you're an SE guy.. i'm at FoCaL myself
14:19:14 <nominolo> skorpan: no i'm CS
14:19:22 <nominolo> skorpan: but more FP
14:19:33 <skorpan> CS? is that a master program?
14:19:45 <nominolo> skorpan:DCS = Dependable Computer Systems
14:19:57 <skorpan> oh.. well you said CS.
14:20:28 <skorpan> and i think the program is called SDCS nowadays (secure and dependable computer systems)
14:20:34 <hpaste>  (anonymous) annotated "why isn't the type system powerful enough to do what i want?" with "(no title)" at http://hpaste.org/6396#a1
14:20:40 <nominolo> i keep my distance from any SE course
14:20:59 <nominolo> skorpan: yep. but Security was part of it before
14:21:03 <skorpan> i took the introductory SE course, unfortunately
14:21:09 <nolrai_> cale: ok, now it works. but arrghh I hate it when things work for no reason.
14:21:09 <TomMD> when (SE == System Engineering) (putStrLn "Good choice")
14:21:10 <skorpan> waste of time
14:21:27 <SamB> what is SE??
14:21:31 <skorpan> p "Sweet!" if (program /~ focal)
14:21:33 <Cale> nolrai_: huh?
14:21:39 <nominolo> SE = Software Engineering
14:21:40 <skorpan> =~*
14:21:46 <SamB> ah. the usual.
14:22:00 <SamB> I don't believe my school has that.
14:22:09 <SamB> per-se.
14:22:13 <TomMD> No no no, SE is for "security enhanced" becuse "secure" isn't good enough!
14:22:22 <nominolo> but our Computer Engineering departments seem to be pretty good too
14:22:22 <monochrom> SE = server enterprise
14:22:32 <SamB> Stupid Edition
14:22:48 <nominolo> Sign Extend
14:24:19 <TomMD> If they ever push the 'six sigma' concept in an SE class, run.  Of coase, you are running a bit late if you're in the class to find out.
14:24:23 <johnnowak> nominolo: were there many students there that didn't do CS for their undergrad?
14:24:52 <nominolo> hm, I know none
14:24:58 <johnnowak> eck
14:25:07 <nominolo> johnnowak: what did you do?
14:25:26 <nominolo> people had very different background though
14:25:28 <johnnowak> i'm a design student.. fine arts degree
14:25:38 <nominolo> oh, well
14:25:45 <skorpan> i have: data P a = Q a | F and i want to set the constraint that a has an instance of Show. how do i do that?
14:26:00 <nominolo> they have some arts+CS at the other university in Göteborg
14:26:13 <nolrai_> IO isnt type synonym is it?
14:26:16 <dmwit> skorpan: Prefer to set that constraint only on functions that use P's.
14:26:18 <johnnowak> nominolo: do you have a link?
14:26:28 <nominolo> i talked to someone who built a dancing snake robot as his thesis
14:26:33 <nominolo> hm, let me see
14:26:41 <dmwit> skorpan: Also, consider using the built-in Maybe type. ;-)
14:26:44 <johnnowak> nominolo: yeah, i'm in something like the undergrad equivalent of that now.
14:26:53 <skorpan> dmwit: why Maybe?
14:27:05 <dmwit> skorpan: Because that's the type you wrote there?
14:27:08 <SamB> nolrai_: no
14:27:14 <skorpan> dmwit: it was just a simplification :)
14:27:15 <dmwit> P = Maybe, Q = Just, F = Nothing
14:27:18 <Twey> data Maybe = Just a | Nothing
14:27:18 <skorpan> Maybe would not work in my case
14:27:19 <dmwit> oh
14:27:20 <dmwit> =)
14:27:43 <nominolo> johnnowak: http://www.gu.se/english/education/Independent+Student/Programmes_in_English/
14:27:45 <lambdabot> http://tinyurl.com/2jqcpr
14:28:00 <johnnowak> nominolo: thanks
14:28:04 <TomMD> skorpan: data (Show a) => P a = Q a | F -- You want that?
14:28:04 <skorpan> dmwit: http://pastebin.com/m3b6b608a
14:28:10 <skorpan> TomMD: yes!
14:28:13 <nominolo> johnnowak: OTOH, i don't think it's that hard to get into the Chalmers programme if you have at least some CS background
14:28:26 <skorpan> i get: Could not deduce (Show (Piece a)) from the context (Show a)
14:28:46 <unenough> i'm trying to ./Setup.sh configure, but i get missing dependencies
14:28:54 <dmwit> skorpan: Just stick deriving (Show) at the end of your type.
14:28:56 <roconnor> data Piece a = .... deriving (Show)
14:29:02 <unenough> is there any way to automatically downlaod & install (as apt-get does) the dependencies?
14:29:05 <nominolo> johnnowak: http://www.ituniv.se/index.php?option=com_content&task=view&id=1926&Itemid=173
14:29:06 <lambdabot> Title: IT-universitetet i Göteborg - C:Art:Media, 120 hp, http://tinyurl.com/33r275
14:29:10 <dmwit> skorpan: And drop that (Show a) => constraint on your type. ;-)
14:29:12 <skorpan> you guys seem sure that that should work.. humm.. i think it didn't work for me.
14:29:25 <hpaste>  nolrai_ annotated "why isn't the type system powerful enough to do what i want?" with "very strange error." at http://hpaste.org/6396#a2
14:29:41 <johnnowak> nominolo: i'm more interested in programming language design than art at this point i think
14:29:43 * skorpan will try to derive Show on freakin' everything and see what happens
14:29:54 <dmwit> nolrai_: That's an H98 restriction.
14:30:21 <dmwit> nolrai_: You can't put concrete types in the instance.
14:30:21 <nominolo> johnnowak: ok, then i guess the SDCS programme would be better for you
14:30:37 <unenough> help?
14:30:50 <dmwit> nolrai_: i.e. you could have instance RequestHandler (IO a b), but not instance RequestHandler (IO a Int).
14:30:56 <nominolo> johnnowak: http://www.chalmers.se/en/sections/education/masterprogrammes/programme-descriptions/secure-dependable
14:30:58 <lambdabot> Title: Chalmers: Secure and Dependable Computer Systems, http://tinyurl.com/35fpkb
14:31:05 <johnnowak> ah, thanks
14:31:13 <skorpan> okay i put "deriving Show" on my types now and i still get the same error but it has context () now
14:31:14 <monochrom> unenough: cabal-install does, but cabal-install itself is hard to install at the moment.
14:31:17 <dmwit> unenough: What's wrong?
14:31:24 <nominolo> johnnowak: but i think you can't apply for this year
14:31:37 <johnnowak> nominolo: it would be at least a year off anyway
14:31:37 <dmwit> skorpan: Why don't you paste a bit more of your code (along with the error) so we can see what you're talking about?
14:31:42 <unenough> Setup.hs: At least the following dependencies are missing:  < a list of stuff >
14:31:47 <TomMD> skorpan: I edited yours, it didn't hpaste here for some reason: http://pastebin.com/d5b3f4b33
14:32:02 <dmwit> unenough: So install those dependencies?
14:32:08 <skorpan> TomMD: so Show a => should still be there?
14:32:20 <dmwit> unenough: Does the output of "ghc-pkg list" look sane?
14:32:29 <dmwit> skorpan: Not in the data declaration.
14:32:37 <skorpan> dmwit: of course :)
14:32:41 <dmwit> ok =)
14:32:48 <skorpan> okay, so i did that, and i get "ambigous type variable a"
14:33:03 <unenough> dmwit, i am no judge of haskell-related sanity at this point of my noobness
14:33:17 <unenough> dmwit,  but it does print a list of packages
14:33:23 <nolrai_> is there a diffrence between 'forall a b.' and 'forall a. forall b.'?
14:33:31 <TomMD> sorry, my [carrier] pidgin keeps crashing.
14:33:36 <monochrom> No difference
14:33:50 <dmwit> unenough: Okay, you should probably just install the packages it is asking for, then.  Hackage will probably have most of them.
14:33:52 <nominolo> johnnowak: so take a look at what the programme covers.  many courses were very interesting and/or well-taught.  some weren't but that's normal, i guess
14:33:53 <SamB> nolrai_: uh... screen space?
14:34:16 <johnnowak> nominolo: formal education is an exercise in adjusting expectation
14:34:24 <nolrai_> dmwit: the error is desidedly deciving.
14:34:47 <hpaste>  skorpan pasted "Silly Show problems!" at http://hpaste.org/6397
14:34:53 <dmwit> nolrai_: Yeah.
14:35:26 <hpaste>  skorpan annotated "Silly Show problems!" with "The error." at http://hpaste.org/6397#a1
14:35:31 <Peaker> can "deriving" be used for my custom types, or only for some built-in types?
14:35:37 <nominolo> johnnowak: i mainly applied because they mentioned functional programming and i wanted to go somewhere to norway or sweden
14:35:46 <dmwit> skorpan: PieceSet?
14:35:51 <EvilTerran> Peaker, um... it works for any type, but only a specific set of typeclasses
14:36:01 <johnnowak> nominolo: heh, this is the extent of my thinking as well at the moment
14:36:02 <Peaker> EvilTerran, oops, I meant my classes
14:36:07 <nominolo> johnnowak: and i was positively surprised
14:36:08 <skorpan> dmwit: Data.Map.Map (Int, Int) (Piece a)
14:36:12 <Peaker> EvilTerran, if I create a new class, can it be "derived" for it too?
14:36:18 <dmwit> skorpan: Anyway, that looks fine, as long as you are calling "showPiece" with some value that's restricted to only one type.
14:36:21 <EvilTerran> not in haskell98, no
14:36:34 <Peaker> EvilTerran, seems like a missing spot in the language? :)
14:36:35 <unenough> actually, is it "noobism", "noobishness" or "noobness"?
14:36:54 <dmwit> skorpan: With that declaration, I get no errors in ghci.
14:36:54 <skorpan> unenough: "noobism" implies that "noobist" would be a noob
14:37:01 <skorpan> dmwit: hm..
14:37:01 <TomMD> skorpan: I get the PieceSet error (as dmwit said), but if I comment out the first two then it works fine.  Note that showPiece can actually be of type Show a => a -> IO ()
14:37:15 <johnnowak> nominolo: for my undergrad thesis, i'm working on a functional programming language. i'd like to continue doing so somehow...
14:37:26 <TomMD> skorpan: You can always omit the type signatures and see what GHC infers - sometimes its interesting to see how general your function really is.
14:37:40 <skorpan> TomMD: i guess
14:37:51 <EvilTerran> @@ Peaker, have a look at "newtype deriving" in the GHC manual - also check out (@where derive), (@where uniplate), and (@where syb)
14:37:51 <lambdabot>  Peaker, have a look at "newtype deriving" in the GHC manual - also check out http://www.cs.york.ac.uk/fp/darcs/derive, http://www-users.cs.york.ac.uk/~ndm/uniplate/, and http://www.cs.vu.nl/
14:37:52 <lambdabot> boilerplate
14:38:02 <skorpan> i'll try to work a bit more on this
14:38:05 <skorpan> thanks for your help
14:38:18 <nominolo> johnnowak: well, David Sands is doing semantics stuff, Andrei Sabelfeld language-based security.  Ulf is doing something with Agda
14:38:18 <EvilTerran> er, that last one should be http://www.cs.vu.nl/boilerplate
14:38:19 <dmwit> unenough: How about "ignorant"?
14:38:19 <lambdabot> Title: Scrap your boilerplate ... in Haskell
14:38:36 <unenough> dmwit, or dimwit? :)
14:38:39 <nominolo> johnnowak: then there are the Java+FM guys.  dunno what they're working on exactly
14:38:46 <dmwit> unenough: exactly =)
14:38:55 <EvilTerran> @where TH - template haskell's another way of getting the same end result, albeit an ugly one
14:38:55 <lambdabot> http://www.haskell.org/th
14:39:15 <johnnowak> nominolo: do students typically work on some project in progress (like agda)?
14:39:17 <EvilTerran> "scrap your boilerplate"'s pretty ugly, too. also dynamic and hairy.
14:39:58 <dmwit> skorpan: By the way, the only times I've ever seen that error were for calls to "read", so if you have any, you might want to look there first.
14:39:58 <dons> Igloo: hey, are you doing an audit for the current optimisations?
14:40:12 <nominolo> johnnowak: i guess it could be possible to suggest an own topic.  but they also have other interesting problems to work on
14:40:12 <dons> Igloo: i'd be interested to know what benchmarking set up you have
14:40:20 <EvilTerran> Peaker, i think the "best" tricks out of those are Derive (naturally) and Uniplate (which does something a bit different, but for the same end result of eliminating boilerplate). but that's a matter of opinion.
14:40:33 <Igloo> dons: No, We just noticed that that one made things worse when looking at the performance bugs
14:40:41 <johnnowak> nominolo: hm. i guess i'll see where i am in a year or so. thanks for the pointers.
14:40:42 <Peaker> EvilTerran, ok, thanks for the references
14:41:01 <EvilTerran> np :)
14:41:02 <nominolo> johnnowak: the application deadline for next year will likely be sometime in March
14:41:14 <johnnowak> aye
14:41:26 <nominolo> so better apply by the end of this year or at least start thinking about it early enough
14:41:35 <skorpan> dmwit: thanks, but i don't! :) it seems that when i cut the relevant parts out of my program and put them in a new file, it compiles and actually works just fine
14:41:45 <skorpan> i'll have to figure out what parts of my program that are messing it up
14:41:51 <dmwit> heh
14:41:53 <dmwit> g'luck
14:41:57 <skorpan> thanks :P
14:41:59 <Heffalump> hi dcoutts
14:43:04 <Igloo> dons: I don't really have a benchmarking setup. It was the heap usage that attracted my attention. Then nofib to check it wasn't useful in the average case.
14:43:40 <dons> ok.
14:44:12 <dons> jaffacake and i were discussing getting a benchmarking suite that can usefully tell you if things are getting faster or slower, into a stable state, while he's here
14:44:25 <Igloo> That would be great
14:44:49 <dons> yeah, real time feedback on how things were doing would really focus things
14:44:56 <dons> we saw hints of this when nobench was running
14:44:58 <Igloo> And also, that can tell you if something looks like it is linear or whatever
14:49:10 <skorpan> luke's irc client.. awesome
14:49:14 <shapr> Is there some sort of short idiom for stripping the contents out of a unary constructor?
14:49:29 <Heffalump> declare it with Foo { unFoo :: x }
14:49:33 <shapr> Ah, thanks
14:49:45 <mae> so, where can i get a good primer to generics
14:49:54 <Heffalump> very standard with newtype, less common in datatypes with multiple choices
14:50:31 <shapr> mae: http://www.cs.vu.nl/boilerplate/
14:50:31 <lambdabot> Title: Scrap your boilerplate ... in Haskell
14:51:25 <Heffalump> that's one view of generics
14:51:46 <Heffalump> well worth looking at, but be aware there are multiple possible approaches
14:51:47 <skorpan> i CAN'T figure this error out!
14:51:50 <shapr> mae: Another view is the papers of Andres Loeh and others: http://people.cs.uu.nl/andres/
14:51:50 <lambdabot> Title: Homepage of Andres L&ouml;h
14:52:01 <dmwit> skorpan: Don't panic!
14:52:06 <ivan___> algorith for solving polynomial equations, any suggestions?
14:52:06 <dmwit> skorpan: also, 42
14:52:21 <EvilTerran> newton-raphson?
14:52:40 <skorpan> dmwit: ah, of course!
14:52:57 <skorpan> no, but seriously, i've been pulling my hair for hours.
14:53:05 <skorpan> i'm going to go bald and i'm only 21
14:53:19 <TomMD> skorpan: paste please - if you are lucky you will make it to my ripe old age.
14:53:21 <dmwit> hpaste?
14:53:25 <skorpan> i'
14:53:39 <EvilTerran> ivan___, newton-raphson might not be stable in the discrete analysis sense, but it's the grand traditional approach, methinks.
14:53:40 <skorpan> i'm not too keen on pasting the full code as this is my course project
14:53:48 <dmwit> ah...
14:53:52 <shapr> Is there a short idiom for finding the type of an undefined in a particular piece of code?
14:53:54 <EvilTerran> skorpan, have you tracked it down to maybe a couple of functions?
14:53:54 <TomMD> Sure - perhaps just an error?
14:54:05 <skorpan> EvilTerran: unfortunately not
14:54:20 <Heffalump> shapr: I don't quite understand your question
14:54:22 <dmwit> shapr: f = undefined; ghci; :t f -- ?
14:54:22 <nominolo> skorpan: what error?
14:54:28 <EvilTerran> shapr, give it a concrete type that it definitely can't have and see what ghc says it's inferred the type to be from context?
14:54:29 <ivan___> EvilTerran: okay but i will only do analasis for LTI systems, will it do for those?
14:54:31 <skorpan> nominolo:     Ambiguous type variable `a' in the constraint:
14:54:31 <skorpan>       `Show a' arising from a use of `show' at Chess.hs:31:44-49
14:54:59 <dmwit> skorpan: It means you're applying show to a value that can have more than one type.
14:55:12 <dmwit> skorpan: Restrict that value to a single type with an explicit type-annotation.
14:55:16 <skorpan> dmwit: of course, as the type is (Piece a)
14:55:29 <TomMD> skorpan: I often see abiguous types if I am using "read" or deserializing via Data.Binary.
14:55:35 <skorpan> i have to let the user pick her own types for Piece
14:55:40 <EvilTerran> ivan___, i'm afraid i don't know what that means. er, try it and see?
14:55:43 <dmwit> skorpan: The real problem is *probably* in the call to showPiece, rather than the definition of showPiece.
14:55:44 <nominolo> yeah, you probably need a type annotation
14:55:53 <shapr> dmwit: Ah, excellent!
14:55:55 <unenough> OK everybody, here is a one-line cabal-install:
14:55:56 <skorpan> dmwit: i think so too.
14:55:57 <unenough> ./Setup.hs configure 2>&1 | tail -n +3 | awk '{print $1}' | xargs -ijoe sudo apt-get -y --force-yes install  libghc6-joe-dev
14:56:17 <dons> unenough: heh.
14:56:18 <dmwit> skorpan: So, provide an explicit type annotation at the call site.
14:56:31 <EvilTerran> unenough, good heavens. there's no need for that kind of language in here!
14:56:38 <skorpan> dmwit: exactly what do you mean?
14:56:41 * shapr snickers
14:56:50 <unenough> can you offer an alternative? i'd be glad...
14:56:58 <EvilTerran> TWAJS
14:56:58 <Peaker> unenough, hehe, that works for you?? it didn't work for me
14:56:58 <dmwit> skorpan: Something like... "showPiece (piece :: Piece Char)" or whatever.
14:57:00 <dons> who's going to byorgey's xmonad/zippers talk next week?
14:57:04 <dons> ?users
14:57:04 <lambdabot> Maximum users seen in #haskell: 475, currently: 469 (98.7%), active: 20 (4.3%)
14:57:06 <shapr> Does hs-plugins work on windows now?
14:57:09 <unenough> Peaker, yip it did
14:57:18 <Peaker> unenough, that's cool enough to put on the Haskell wiki then!
14:57:19 <Dybber> Where do I find information on ghc compiler flags? I wan't to read about -XTypeSynonymInstances
14:57:27 <ivan___> EvilTerran: it means that i am never trying to solve sqrt(polynomial) = something or Sin(polynomial) = something, just liniar polynomial x+x^2+x^3 = 0 =)
14:57:29 <EvilTerran> unenough, but can you write something equivalent in haskell? :P
14:57:30 <dmwit> skorpan: One such annotation for each time showPiece is called.
14:57:38 <skorpan> dmwit: what, wait! that actually works! :|
14:57:55 <nominolo> @google GHC User's Guide
14:57:56 <lambdabot> http://haskell.org/ghc/docs/latest/html/users_guide/index.html
14:57:56 <lambdabot> Title: The Glorious Glasgow Haskell Compilation System User's Guide, Version 6.8.2
14:58:11 * skorpan frowns...
14:58:12 <unenough> EvilTerran, if i weren't a dimwit ( = noob ala dmwit) then yes
14:58:36 <dmwit> unenough: You could install cabal-install.
14:58:49 <unenough> dmwit, but how?
14:58:50 <dmwit> unenough: Then your one-liner could become "cabal-install X". ;-)
14:58:51 <oerjan> Dybber: for -X flags, also look for LANGUAGE pragma (equivalent)
14:58:55 <EvilTerran> ivan___, well, newton-raphson should work for any continuous differentiable real-valued function. i'm just not sure how nice it plays with IEEE floats.
14:59:05 <dmwit> unenough: ...oh.  Is that what you were trying to install? =P
14:59:14 <unenough> no, but that too would be a problem
14:59:24 <ivan> is the CleverCSS python->haskell translation representative of proper haskell code?
14:59:52 <unenough> help. After running my horrendous script is still get: missing deps: zlib -any, plugins >=1.0, oeis -any
14:59:55 <EvilTerran> ivan___, see http://mathworld.wolfram.com/NewtonsMethod.html
14:59:56 <lambdabot> Title: Newton's Method -- from Wolfram MathWorld
15:00:08 <skorpan> dmwit: ahhh!! i'm so stupid! i just realised that the module where i use showPiece will always be showing a specific type of pieces!
15:00:14 <ivan___> EvilTerran: thx
15:00:14 <unenough> and my distribution doesn't contain oeis and zlib
15:00:15 <dmwit> unenough: OHHH, I see what you're doing!
15:00:39 <EvilTerran> ivan___, or indeed http://mathworld.wolfram.com/HornersMethod.html
15:00:39 <lambdabot> Title: Horner's Method -- from Wolfram MathWorld
15:00:39 <dmwit> unenough: Did you know you can do apt-get install libghc6-*-dev?
15:00:56 <dmwit> unenough: It's one of my first commands on any new system. =P
15:01:20 <Peaker> dmwit, isn't that libghc6-.*-dev?
15:01:38 <dmwit> Peaker: nope =/
15:01:50 <SamB> shouldn't that be in ''
15:01:50 <dmwit> Peaker: apt-cache uses regexen, apt-get uses file globs
15:02:07 <dmwit> SamB: Most shells will leave a * if there are no matches.
15:02:08 <Peaker> dmhouse, E: Couldn't find package libghc6-*-dev
15:02:14 <Peaker> oops
15:02:18 <SamB> dmwit: zsh doesn't
15:02:19 <Peaker> dmwit, E: Couldn't find package libghc6-*-dev
15:02:26 <dmwit> SamB: zsh certainly does.
15:02:29 <unenough> dmhouse, .* does it
15:02:31 <unenough> BUT
15:02:43 <SamB> mine complains
15:02:56 <Peaker> yeah some packages are b0rked
15:03:03 <unenough> on my ubuntu+1 I get another problem: libghc6-plugins-dev: Depends: ghc6 (< 6.6.1+) but 6.8.2-1ubuntu1 is to be installed
15:03:03 <Peaker> of libghc6-.*-dev
15:03:24 <unenough> *sigh*
15:03:25 <dmwit> SamB: Maybe you have some option set?
15:03:30 <dmwit> SamB: Or maybe I do. =P
15:03:41 <SamB> well, I didn't set much
15:03:45 <Peaker> unenough, Haskell and Ubuntu don't go well together :-(
15:03:48 * dmwit cat /etc/zsh/zshrc
15:04:02 <SamB> certainly not in /etc/zsh/zshrc
15:04:28 <dmwit> SamB: Ah, it's probably setopt no_nomatch
15:04:29 <dons> Peaker: sure they do.
15:04:38 <unenough> dons, but not ubuntu+1
15:04:44 <dons> you just have to install some things by yourself. from hackage.haskell.org
15:04:47 <dmwit> SamB: Sorry, I was wrong again. =P
15:04:52 <Dybber> oerjan: thanks, that gave me some results
15:05:04 <SamB> wee
15:05:05 <Peaker> dons, and conflict with Ubuntu's packages..?
15:05:34 <SamB> well, there was always the chance that something in the default .zshrc for the version I first installed had set some option...
15:07:21 <dons> Peaker: no, install as --user
15:07:33 <unenough> Peaker, where in the wiki would you put that?
15:07:34 <gnuvince_> :t nub<
15:07:35 <gnuvince_> :t nub
15:07:37 <lambdabot> parse error (possibly incorrect indentation)
15:07:38 <lambdabot> forall a. (Eq a) => [a] -> [a]
15:07:52 <Peaker> unenough, I donno
15:08:36 <unenough> i'll drop it then
15:09:42 <EvilTerran> *crunch*
15:10:03 <yitz> > let readMany = unfoldr $ listToMaybe . concatMap reads . tails in readMany "here's 23 ,43,5 and 7. And 32. Yes." :: [Int]
15:10:05 <lambdabot>  [23,43,5,7,32]
15:13:04 <SamB> hmm, how do I tell emacs to interpret color escapes?
15:13:12 <SamB> for a command run in a subshell
15:13:46 <Peaker> SamB, ansi-color-for-comint-mode-on I think
15:14:10 <SamB> cool
15:14:29 <SamB> I see it doesn't work retroactively
15:15:09 <SamB> hmm, and it's basically just stripping out the escapes for me
15:15:16 <SamB> but I bet that's because I'm in shell-mode
15:16:19 <Peaker> stripping them out?  As opposed to still having them along with the color?
15:16:19 <SamB> in other news ... my class aliases seem to work if you don't try to write default methods??? er. maybe not.
15:16:38 * SamB builds jhcp again so he can find out why
15:19:52 <unenough> dons, --user still tries to put stuff in /usr/local/share/doc
15:20:22 <Peaker> "This is because you cannot make instances out of non-fully-applied type synonyms." <- what does that mean? What is non-fully-applied here?
15:21:12 <Saizan> type Foo a = a, instance Class Foo where -- there Foo is not fully applied
15:21:22 <smg> > foldr1 (\x y -> x + 2*y) [1,0,1,0,0,0,1] -- bin2dec
15:21:23 <lambdabot>  69
15:21:25 <Saizan> you've not saturated its arguments
15:21:25 <yitz> Peaker: type Foo a = ... -- you cannot now say instance C Foo...
15:21:43 <Peaker> yitz, Saizan: Why not?
15:21:46 <smg> > foldr1 (\x y -> x + 2*y) [1,0,0,0,0,0,0,0] -- bin2dec
15:21:47 <lambdabot>  1
15:22:02 <Peaker> yitz, Saizan: I see what non-fully-applied means, but what can't you make them instances?
15:22:03 <smg> > foldr1 (\x y -> x + 2*y) $ reverse [1,0,0,0,0,0,0,0] -- bin2dec
15:22:04 <lambdabot>  128
15:22:07 <smg> hehe
15:22:09 <Cale> foldl
15:22:27 <Saizan> Peaker: to keep instance resolution sane, i guess
15:22:28 <Peaker> I guess it would complicate matters, but in theory it could work
15:22:33 <dmwit> > foldl' 0 (\x y -> 2 * x + y) [1,0,0,0]
15:22:34 <Peaker> Saizan, I see, thanks!
15:22:34 <lambdabot>        add an instance declaration for
15:22:34 <lambdabot>       (Num ((t -> t -> t) -> b -> t ->...
15:22:40 <Cale> > foldl (\x y -> 2*x + y) 0 [1,0,1,0]
15:22:41 <lambdabot>  10
15:22:44 <smg> hehe
15:22:47 <dmwit> Oops, wrong order, heh.
15:22:52 <Cale> > foldl (\x y -> 2*x + y) 0 [1,0,1,0,0,0,1]
15:22:53 <yitz> Peaker: they're not really types, just synonyms. Use newtype for that.
15:22:53 <smg> > foldr (\x y -> 2*x + y) 0 [1,0,1,0]
15:22:54 <lambdabot>  81
15:22:55 <lambdabot>  4
15:23:12 <Peaker> yitz, Yeah I understand now
15:23:17 <smg> foldl1 (\x y -> x + 2*y) [1,0,0,0,0,0,0,0] -- bin2dec
15:23:26 <smg> > foldl1 (\x y -> x + 2*y) [1,0,0,0,0,0,0,0] -- bin2dec
15:23:27 <lambdabot>  1
15:23:31 <dmwit> > foldr (\x y -> x + 2 * y) 0 [1,0,1,0]
15:23:33 <lambdabot>  5
15:23:39 <oerjan> smg: nothing dec there before show is applied :)
15:24:00 <dmwit> > readInt 2 isDigit digitToInt "10100"
15:24:01 <lambdabot>  [(20,"")]
15:24:06 <smg> > foldr (\x y -> x + 2*y) 0 [1,0,0,0,0,0,0,0]
15:24:08 <lambdabot>  1
15:24:19 <smg> okay -> enough :]
15:24:41 <tromp> :t readInt
15:24:42 <lambdabot> forall a. (Num a) => a -> (Char -> Bool) -> (Char -> Int) -> String -> [(a, String)]
15:25:04 <smg> dmwit: haha
15:25:05 <dons> unenough: use --prefix=$HOME --user
15:25:51 <tromp> > readInt 2 isDigit digitToInt "23"
15:25:52 <lambdabot>  [(7,"")]
15:26:01 <smg> hehe
15:26:12 <smg> @src iterate
15:26:12 <lambdabot> iterate f x =  x : iterate f (f x)
15:26:18 <smg> do i need to import readInt etc?
15:26:24 <vincenz> That's one nasty function
15:26:36 <vincenz> > readInt 2 isDigit digitToInt "2a3"
15:26:36 <lambdabot>  [(2,"a3")]
15:26:37 <dmwit> smg: import Numeric
15:26:40 <smg> i see
15:27:03 <dmwit> vincenz: Yeah, you need to be a bit more careful in production code.
15:27:05 <tromp> >  isDigit 'a'
15:27:06 <lambdabot>  False
15:27:18 <vincenz> > readInt 2 isDigit digitToInt $ ['1'..'9']
15:27:18 <lambdabot>  [(1013,"")]
15:27:19 <tromp> hmm, last time iit was true?
15:27:22 <smg> is there something like isUpper ?
15:27:22 <dmwit> > readInt 2 (\x -> x == '0' || x == '1') digitToInt "2a3"
15:27:23 <lambdabot>  []
15:27:34 <oerjan> > readInt 2 isHexDigit digitToInt "2a3"
15:27:35 <lambdabot>  [(31,"")]
15:27:36 <vincenz> that seems off
15:27:38 <yitz> > isUpper "A"
15:27:38 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
15:27:44 <yitz> > isUpper 'A'
15:27:44 <lambdabot>  True
15:27:48 <Saizan> > isDigit 'A'
15:27:49 <lambdabot>  False
15:27:51 <smg> hehe but in which module?
15:27:53 <smg> Data.Char?
15:27:57 <dmwit> tromp: no...
15:27:59 <Saizan> > isHexDigit 'A'
15:27:59 <lambdabot>  True
15:28:08 <dmwit> tromp: That's why the parse ended after '2'.
15:28:14 <smg> yes it's in Data.Char :]
15:28:17 <yitz> @where isUpper
15:28:17 <lambdabot> I know nothing about isupper.
15:28:18 <skorpan> what's a good way to generate a list, given X and Y, such that the list consists of pairs (W, Z) where W <- [X+1, X-1, X], Z <- [Y+1, Y-1, Y], except for (W, Z) == (X, Y)?
15:28:20 <vincenz> > 9+2*(8+2*(7+2*(6+2*(5+2*(4+2*(3+2*(2+2*1)))))))
15:28:21 <lambdabot>  1013
15:28:26 <tromp> > digitToInt 'a'
15:28:26 <lambdabot>  10
15:28:28 <yitz> @index isUpper
15:28:28 <lambdabot> Data.Char
15:28:28 <dmwit> ?index isUpper
15:28:28 <lambdabot> Data.Char
15:28:39 <tromp> ah, it was just digitToInt that was weird
15:28:45 <tromp> > digitToInt 'g'
15:28:45 <lambdabot>  Exception: Char.digitToInt: not a digit 'g'
15:28:55 <smg> > show $ foldr1 (\x y -> x + 2*y) $ reverse [1,0,0,0,0,0,0,0]
15:28:56 <lambdabot>  "128"
15:29:13 <smg> > "Result is: " ++ (show $ foldr1 (\x y -> x + 2*y) $ reverse [1,0,0,0,0,0,0,0]) ++ "."
15:29:14 <lambdabot>  "Result is: 128."
15:29:26 <smg> k enough lambdabot abuse for today
15:29:42 <yitz> @botsnack
15:29:42 <lambdabot> :)
15:29:43 <Saizan> > tail $ liftM2 (,) [x,x+1,x-1] [y,y+1,y-1]
15:29:43 <lambdabot>  [(x,y + 1),(x,y - 1),(x + 1,y),(x + 1,y + 1),(x + 1,y - 1),(x - 1,y),(x - 1,...
15:29:53 <smg> @botsnack
15:29:53 <lambdabot> :)
15:29:56 <smg> :]
15:30:56 <skorpan> what the heck Saizan
15:31:31 <yitz> @type liftM2 (,)
15:31:32 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
15:31:36 <SamB> @type x
15:31:37 <lambdabot> Expr
15:31:41 <SamB> @type y
15:31:42 <lambdabot> Expr
15:32:01 <SamB> hmm. why the monotypes?
15:32:15 <oerjan> @where Expr
15:32:15 <lambdabot> http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
15:32:42 <oerjan> SamB: to make that work
15:32:56 <SamB> I know what these things are for
15:32:59 <Saizan> SamB: less annotations
15:33:04 <oerjan> :t f
15:33:05 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
15:33:15 <SamB> hmm.
15:33:31 <SamB> I suppose you can't invoce fromIntegral on that anyway...
15:33:35 <SamB> er. invoke...
15:33:39 <SamB> > fromIntegral x
15:33:40 <lambdabot>  Exception: not a number
15:33:51 <oerjan> > [x..]
15:33:51 <lambdabot>  Exception: not a number
15:34:20 <smg> > let int2bin n = if n == 0 then [] else n `mod` 2 : int2bin (n `div` 2) in ( concat . map ( (\x -> take 8 (x ++ repeat 0)) . int2bin . ord)) "Foobar"
15:34:20 <lambdabot>  [0,1,1,0,0,0,1,0,1,1,1,1,0,1,1,0,1,1,1,1,0,1,1,0,0,1,0,0,0,1,1,0,1,0,0,0,0,1...
15:34:23 <smg> :]]
15:34:29 <Saizan> we should make [x..] work
15:34:48 <SamB> Saizan: implement enumFrom
15:35:21 <SamB> > 1+x
15:35:21 <lambdabot>  1 + x
15:35:24 <SamB> hmm.
15:35:25 <oerjan> > [1,2 .. x]
15:35:26 <Saizan> [x,succ x,succ (succ x),...
15:35:26 <lambdabot>  Exception: not a number
15:35:28 <dmwit> > map showIntAtBase 2 intToDigit . map chr $ "Foobar"
15:35:28 <lambdabot>  Couldn't match expected type `(Int -> Char) -> a -> b'
15:35:30 <SamB> > 1 + x + 1
15:35:31 <lambdabot>  1 + x + 1
15:35:34 <dmwit> :t showIntAtBase
15:35:35 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
15:35:36 <SamB> that's silly-looking
15:35:48 <dmwit> > map showIntAtBase 2 intToDigit "" . map chr $ "Foobar"
15:35:48 <lambdabot>  Couldn't match expected type `(Int -> Char) -> [Char] -> a -> b'
15:35:59 <dmwit> oy
15:36:03 <dmwit> > map showIntAtBase 2 intToDigit "" . map ord $ "Foobar"
15:36:04 <lambdabot>  Couldn't match expected type `(Int -> Char) -> [Char] -> a -> b'
15:36:13 <smg> dmwit: hehe
15:36:21 <dmwit> > map (showIntAtBase 2 intToDigit "") . map ord $ "Foobar"
15:36:21 <lambdabot>  Couldn't match expected type `String' against inferred type `Int'
15:36:25 <dmwit> bah
15:36:25 <smg> > let int2bin n = if n == 0 then [] else n `mod` 2 : int2bin (n `div` 2) in ( concat . map ( (\x -> take 8 (x ++ repeat 0)) . int2bin . ord)) "foo"
15:36:26 <lambdabot>  [0,1,1,0,0,1,1,0,1,1,1,1,0,1,1,0,1,1,1,1,0,1,1,0]
15:36:28 * dmwit gives up
15:37:48 <yitz> > let int2bin = map (`mod` 2) . takeWhile (> 0) . iterate (`div` 10) in int2bin 81
15:37:48 <lambdabot>  [1,0]
15:37:54 <dmwit> > map ($ "") . map (showIntAtBase 2 intToDigit) . map ord $ "Foobar"
15:37:55 <lambdabot>  ["1000110","1101111","1101111","1100010","1100001","1110010"]
15:38:03 <yitz> > let int2bin = map (`mod` 2) . takeWhile (> 0) . iterate (`div` 2) in int2bin 81
15:38:03 <lambdabot>  [1,0,0,0,1,0,1]
15:38:18 <ziman> ?type iterate
15:38:19 <lambdabot> forall a. (a -> a) -> a -> [a]
15:38:34 <dmwit> > iterate (1:)
15:38:35 <lambdabot>  <[Integer] -> [[Integer]]>
15:38:37 <dmwit> > iterate (1:) []
15:38:38 <lambdabot>  [[],[1],[1,1],[1,1,1],[1,1,1,1],[1,1,1,1,1],[1,1,1,1,1,1],[1,1,1,1,1,1,1],[1...
15:38:41 <Dybber> What does the pipe | mean in class definitions? E.g. in the definition of MonadState http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-State-Class.html
15:38:41 <lambdabot> http://tinyurl.com/yuyeqp
15:38:52 <dmwit> Dybber: It's a functional dependency.
15:39:20 <dmwit> Dybber: It means the type variables to the left of the (->) completely determine the type variables to the right of the (->).
15:39:59 <dmwit> So in your particular case, the monad 'm' completely determines the type of the state 's'.
15:40:10 <dmwit> i.e. if you have
15:40:17 <smg> > let chop8 bits = if null bits then [] else take 8 bits : chop8 (drop 8 bits) in (map (chr . (\z -> foldr1 (\x y -> x + 2*y) $ reverse z)) . chop8) 0,1,1,0,0,1,1,0,1,1,1,1,0,1,1,0,1,1,1,1,0,1,1,0]
15:40:17 <lambdabot>  Parse error at "]" (column 195)
15:40:20 <dmwit> instance MonadState Int (State Int)
15:40:24 <dmwit> then you can't also have
15:40:24 <smg> > let chop8 bits = if null bits then [] else take 8 bits : chop8 (drop 8 bits) in (map (chr . (\z -> foldr1 (\x y -> x + 2*y) $ reverse z)) . chop8) [0,1,1,0,0,1,1,0,1,1,1,1,0,1,1,0,1,1,1,1,0,1,1,0]
15:40:24 <lambdabot>  "f\246\246"
15:40:30 <dmwit> instance MonadState Int (State Integer)
15:40:33 <smg> \246 = o
15:40:34 <smg> ?
15:40:36 <smg> hehe
15:40:39 <dmwit> Dybber: Does this make sense?
15:40:45 <smg> > let chop8 bits = if null bits then [] else take 8 bits : chop8 (drop 8 bits) in (map (unichr . (\z -> foldr1 (\x y -> x + 2*y) $ reverse z)) . chop8) [0,1,1,0,0,1,1,0,1,1,1,1,0,1,1,0,1,1,1,1,0,1,1,0]
15:40:46 <lambdabot>   Not in scope: `unichr'
15:40:49 <smg> mh
15:40:50 <smg> damn it
15:40:50 <Dybber> Yes, I think I can follow you
15:41:22 <smg> > let chop8 bits = if null bits then [] else take 8 bits : chop8 (drop 8 bits) in (map (chr . (\z -> foldr1 (\x y -> x + 2*y) z)) . chop8) [0,1,1,0,0,1,1,0,1,1,1,1,0,1,1,0,1,1,1,1,0,1,1,0]
15:41:22 <lambdabot>  "foo"
15:41:27 <smg> ahhhhhhh :]
15:41:28 <smg> lambdabot: <3
15:42:12 <smg> Code _is_ poetry.
15:44:02 <yitz> > let groupsOf n = map (take n) . iterate (drop n) in groupsOf 8 [0,1,1,0,0,1,1,0,1,1,1,1,0,1,1,0,1,1,1,1,0,1,1,0]
15:44:03 <lambdabot>  [[0,1,1,0,0,1,1,0],[1,1,1,1,0,1,1,0],[1,1,1,1,0,1,1,0],[],[],[],[],[],[],[],...
15:44:16 <dmwit> needs more takeWhile (not . null)
15:44:19 <yitz> > let groupsOf n = takeWhile (not.null) . map (take n) . iterate (drop n) in groupsOf 8 [0,1,1,0,0,1,1,0,1,1,1,1,0,1,1,0,1,1,1,1,0,1,1,0]
15:44:19 <lambdabot>  [[0,1,1,0,0,1,1,0],[1,1,1,1,0,1,1,0],[1,1,1,1,0,1,1,0]]
15:45:56 * SamB wonders why emacs doesn't show lamdas green like it should
15:46:17 <BMeph69> @let cowbell = takeWhile (not . null)
15:46:18 <lambdabot> Defined.
15:46:23 <BMeph69> ;)
15:47:05 <dmwit> heh
15:47:14 <dmwit> I gotta have more cowbell!
15:47:36 <Dybber> hehe
15:48:50 <skorpan> damn you SNL
15:49:07 <hpaste>  smg pasted "encode/decode" at http://hpaste.org/6399
15:49:16 <smg> hehe
15:49:17 <smg> check it
15:49:26 <smg> yitz: intresting
15:49:32 <smg> SamB: get vim
15:50:18 <augustss> are lambdas green?
15:50:28 <oerjan> very environmental
15:50:51 <oerjan> no additives
15:50:53 <skorpan> is there *any* way to do "do" notation without using monads?
15:51:20 <augustss> -fno-implicit-prelude
15:51:46 <augustss> then you only need operators with the right names
15:52:58 <augustss> but when I want do notation without a monad I define a trivial monad that, e.g., builds syntax trees, and then you can treat the result as you like
15:52:59 <idnar> heh
15:53:10 <yitz> augustss: would import Prelude hiding ((>>=)) work?
15:53:26 <augustss> yitz: not without that flag
15:53:56 <dmwit> Really?
15:54:09 <dmwit> Does it import class definitions or something?
15:54:35 <augustss> the do notation is too wired in, and it expands to the qualified name
15:55:11 <yitz> augustss: so import Prelude hiding (Monad(..))?
15:55:29 <augustss> wouldn't help
15:55:37 <yitz> stubborn, eh?
15:55:45 <augustss> try it :)
15:55:48 <vincenz> Why would you want do-notation without a monad?
15:55:54 <oerjan> you need that + the flag i think
15:56:23 <yitz> augustss: I meant the compiler, not you, of course. :)
15:56:27 <oerjan> vincenz: parametrized monads, i hear.  btw would augustss's AST solution work for those anyhow?
15:56:50 <vincenz> oerjan: You mean like Oleg's?
15:57:05 <vincenz> class Monad i o m a ?
15:57:33 <tromp> can you put a marker in a .hs file to indicate that rest of file shld be ignored?
15:57:37 <oerjan> well i am not exactly sure what they are but my intuition is something like a State monad where the type of the state can change at each step
15:57:42 <vincenz> tromp: {-
15:57:46 <vincenz> tromp: and then -} at the end
15:57:46 <smg> skorpan: why would you? just turn layout of with { }
15:57:49 <tromp> thx, vincenz
15:58:00 <vincenz> tromp: that's just a block comment ...
15:59:04 <smg> vincenz: :]
15:59:05 <yitz> tromp: or make it a lhs file instead of hs, surround code in /code{begin} and /code{end}.
15:59:17 <yitz> uh, /begin{code}? which is it?
16:00:18 <yitz> (you can see how much I've been using latex in recent years...)
16:00:49 <SamB> \begin{code}
16:00:50 <SamB> lol
16:01:35 <yitz> SamB. there we go. tnx!
16:01:40 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/6400
16:03:17 <smg> yitz: hehe
16:05:47 <SamB> what is the haskell-hacker's favorite number?
16:06:11 <dmwit> What?
16:06:31 <SamB> okay, any geeky number would be okay actually
16:06:44 <roconnor> undefined
16:06:57 <lscd> 1
16:07:03 <roconnor> fix id
16:07:25 <dons> undefined, totally
16:07:34 <dmwit> exp (pi * (0 :+ 1))
16:07:44 <oerjan> 6400 above is pretty cool too
16:08:10 <oerjan> (nice and round however you look at it)
16:08:10 <yitz> mzero
16:08:18 <dmwit> haha
16:08:22 <Zao> I tend to go with take n $ 42:[3,5..]
16:08:31 <oerjan> ah yes i already pointed it out once: join (.)
16:09:39 <dmwit> join (.) just applies something twice?
16:09:41 <dmwit> interesting
16:09:55 <oerjan> it's the church numeral 2
16:09:58 <vincenz> join :: m(m a) -> m a
16:10:04 <dmwit> > join (.) (drop 1 . reverse) "abcd"
16:10:05 <lambdabot>  "bc"
16:10:05 <smg> > let (++++) ys = foldr (:) ys in (++++) [1..10] [10..20]
16:10:06 <lambdabot>  [10,11,12,13,14,15,16,17,18,19,20,1,2,3,4,5,6,7,8,9,10]
16:10:41 <vincenz> dmwit: spiffy
16:13:06 <vincenz> :t join (.) (.)
16:13:07 <lambdabot>     Occurs check: cannot construct the infinite type: a = f a
16:13:07 <lambdabot>     Probable cause: `join' is applied to too few arguments
16:13:17 <vincenz> :t join (.) ($)
16:13:18 <lambdabot> forall a b. (a -> b) -> a -> b
16:13:46 <vincenz> > join (.) ($) (+1) 2
16:13:47 <lambdabot>  3
16:14:36 <dmwit> That doesn't make any sense.
16:14:42 <dmwit> > join (.) ($) ord 'a'
16:14:42 <lambdabot>  97
16:14:54 <vincenz> ($) . ($) == ($) ???
16:14:55 <dmwit> oh
16:14:59 <dmwit> duh
16:15:25 <dmwit> At first I was thinking that 2 + 1 + 1 = 3.
16:16:02 <yitz> @type join ((.).(.))
16:16:04 <lambdabot> forall a (f :: * -> *). (Functor f) => (a -> f a) -> a -> f (f a)
16:16:11 <dmwit> It's a lot easier to grok if you write it as "id . id". =P
16:16:39 <yitz> > join ((.).(.)) (:[]) 2
16:16:42 <lambdabot>  [[2]]
16:16:49 <dmwit> > join (.) (.) (:[]) 2
16:16:49 <lambdabot>      Occurs check: cannot construct the infinite type: a = f a
16:16:49 <lambdabot>       Expected...
16:17:10 <dmwit> huh
16:17:23 <oerjan> those two (.)'s are not at the same type
16:17:37 <dmwit> mmm
16:18:00 <vincenz> :t join (.)
16:18:01 <lambdabot> forall a. (a -> a) -> a -> a
16:18:11 <vincenz> wt
16:18:13 <vincenz> wtf
16:18:18 <vincenz> how do you suddenly get a Functor ini there
16:18:23 <vincenz> :t join ((.).(.))
16:18:24 <lambdabot> forall a (f :: * -> *). (Functor f) => (a -> f a) -> a -> f (f a)
16:18:29 <oerjan> :t (.)
16:18:30 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:18:31 <dmwit> :t (.) -- because fo this
16:18:32 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:18:40 <vincenz> That''s new
16:18:52 <dmwit> :t (++) -- you'll be new to this, too, then
16:18:53 <lambdabot> forall m. (Monoid m) => m -> m -> m
16:18:53 <oerjan> vincenz: Cale's evil scheme :)
16:19:05 <vincenz> dmwit: oh noes!
16:19:07 <tibbe> what's this!?
16:19:13 <vincenz> mappend
16:19:52 <Cale> > sortBy (comparing length ++ compare) (words "this is a test of the emergency broadcasting system")
16:19:53 <lambdabot>  ["a","is","of","the","test","this","system","emergency","broadcasting"]
16:20:09 <oerjan> O_O
16:20:20 <vincenz> what's the type of ++ in there?
16:20:28 <Cale> :t comparing length
16:20:29 <lambdabot> forall a. [a] -> [a] -> Ordering
16:20:34 <oerjan> ah using -> Monoid
16:20:38 <dmwit> yeah
16:20:47 <tromp> :t comparing
16:20:48 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
16:20:50 <vincenz> Cale: you're evil
16:21:02 <vincenz> @src comparing
16:21:02 <lambdabot> Source not found. Are you on drugs?
16:21:06 <dmwit> Aw, come on, that's really pretty.
16:21:08 <vincenz> I do hope it is
16:21:11 <vincenz> comparing f = compare `on` f
16:21:20 <Cale> yeah, essentially
16:21:23 <vincenz> dmwit: it looks like a dynamically typed language!
16:21:23 <ziman> :t on
16:21:24 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
16:21:28 <Cale> comparing p x y = compare (p x) (p y)
16:21:35 <vincenz> Cale: I meant literally :)
16:21:45 <Cale> vincenz: Except it's *not* dynamically typed at all.
16:21:56 <yitz> comparing = compare `on`
16:21:57 <Cale> In fact, these tricks wouldn't even work in a dynamically typed language.
16:22:01 <oerjan> vincenz: comparing was added first
16:22:06 <vincenz> oerjan: bah
16:22:13 <dmwit> yitz: comparing = (compare `on`) -- for great pedanticism!
16:22:13 <vincenz> oerjan: that's how we get stuff like 'fail' in Monad
16:22:30 <vincenz> dmwit: or worse
16:22:31 <tibbe> yuck, fail
16:22:33 <vincenz> comparing = on compare
16:22:34 <Cale> vincenz: We get stuff like fail in Monad from people who don't like polymorphism
16:22:34 <dmwit> yitz: Or even just "comparing = on compare". =)
16:22:40 <oerjan> vincenz: well we narrowly escaped getting equating too ;)
16:22:46 <vincenz> dmwit: beatcha
16:22:53 <dmwit> vincenz: =/ *shame*
16:23:01 <Cale> It's all the fault of removing monad comprehensions
16:23:09 <vincenz> Those bastards
16:23:10 * yitz has slow keyboard fingers
16:23:19 <vincenz> I do hope we get first class pattern-match thingies
16:23:25 <vincenz> that |foo stuff looks really neat
16:23:28 <Cale> comparing is nice. I don't really care much for `on`
16:23:35 <vincenz> Cale: on is great
16:23:46 <vincenz> (==) `on` snd
16:23:56 <Cale> yeah, I know how it works :)
16:24:06 <vincenz> love `on` ice
16:24:13 <augustss> on rulez!  comparing is for weenies
16:24:20 <vincenz> +1
16:24:35 <vincenz> comparing is something thats not taken to the extreme
16:24:38 <vincenz> it's a halfway point
16:24:44 <vincenz> unrefactored code
16:24:45 <Twey> :t on
16:24:46 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
16:24:48 <tromp> :t (++)
16:24:49 <lambdabot> forall m. (Monoid m) => m -> m -> m
16:24:55 <Cale> :t comparing
16:24:55 * Twey sneezes.
16:24:55 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
16:24:56 <tromp> @instances Monoid
16:24:56 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
16:25:02 <Twey> @src on
16:25:03 <lambdabot> (*) `on` f = \x y -> f x * f y
16:25:13 <vincenz> :t (++) `on` snd
16:25:13 <lambdabot> forall a b. (Monoid b) => (a, b) -> (a, b) -> b
16:25:14 <oerjan> :t on (++)
16:25:15 <lambdabot> forall b a. (Monoid b) => (a -> b) -> a -> a -> b
16:25:21 <Twey> Ack, no generic definition
16:25:24 <vincenz> oerjan: hehe
16:25:32 <kraftyswine> I've got a question
16:25:39 <dmwit> kraftyswine: Shoot!
16:25:40 <Cale> kraftyswine: go for it
16:25:54 <kraftyswine> are monads essentially the same concept as Lisp's dynamic execution contexts?
16:26:03 <Cale> kraftyswine: I don't think so.
16:26:09 <tromp> @src Ordering
16:26:10 <lambdabot> data Ordering = LT | EQ | GT
16:26:12 <augustss> unlikely
16:26:16 <kraftyswine> how do they differ?
16:26:19 <Cale> kraftyswine: But I don't know much about Lisp's dynamic execution contexts.
16:26:25 <tromp> how is Ordering an instance of Moinid?
16:26:33 <tibbe> anyone have an example of a buffered socket? i.e. I want to make small reads but behind the scenes it makes big ones and buffer. preferably supporting pushing back read data into the buffer again (i.e. because I read too much because I couldn't know beforehand e.g. the size of an HTTP header)
16:26:58 <Cale> kraftyswine: Monads are a way of structuring combinator libraries so that they share some (very specific) combinators, and an API of general functions that work in all monads can be written.
16:26:59 <augustss> kraftyswine: how are ducks different from integrals?
16:27:19 <kraftyswine> lisp has dynamic, not static, scoping. So if you reference a variable that doesn't exist in the current scope then it looks in the scope of the function that called the current function.
16:27:32 <Peaker> kraftyswine, which Lisp?
16:27:40 <Cale> kraftyswine: Specifically, a monad is a type constructor m, together with functions return :: a -> m a, and bind :: m a -> (a -> m b) -> m b
16:27:41 <Peaker> kraftyswine, Scheme and CL are both lexically scoped, I believe
16:27:43 <kraftyswine> common lisp IIRC
16:27:44 <oerjan> > [x++y | x <- [LT..GT], y <- [LT..GT]]
16:27:44 <lambdabot>  Parse error at "LT..G..." (column 15)
16:27:46 <Riastradh> No, kraftyswine.
16:27:48 <kraftyswine> sigh
16:27:50 <kraftyswine> well whatever
16:27:50 <oerjan> > [x++y | x <- [LT ..GT], y <- [LT ..GT]]
16:27:51 <lambdabot>  [LT,LT,LT,LT,EQ,GT,GT,GT,GT]
16:27:51 <Cale> kraftyswine: and those are required to satisfy some laws
16:27:56 <kraftyswine> lisp before it had lexical scoping
16:28:09 <kraftyswine> I'm not interested in any fucking implementation details, eh?
16:28:25 <vincenz> kraftyswine: short answer, completely unrelated
16:28:28 <vincenz> kraftyswine: like cheese and the moon
16:28:37 <augustss> ducks and integrals
16:28:37 <vincenz> wait,less than cheese and the moon
16:28:47 <Riastradh> I was considering elaborating, kraftyswine, until your rather obscene and irrelevant outburst.
16:28:55 <kraftyswine> but a monad is used to pass stuff to a callee function, is it not?
16:29:04 <Cale> kraftyswine: no
16:29:06 <dmwit> no
16:29:07 <vincenz> kraftyswine: a monad is used to sequence actions
16:29:19 <kraftyswine> sigh
16:29:22 <kraftyswine> that's the same thing
16:29:24 <Cale> where "actions" is a highly general sort of word
16:29:36 <Cale> > do x <- [1,2,3]; y <- [4,5]; return (x,y)
16:29:36 <lambdabot>  [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
16:29:43 <Cale> There's an example of the list monad.
16:29:51 <Cale> Here's another:
16:30:03 <Cale> > filterM (const [True, False]) [1,2,3]
16:30:03 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
16:30:04 <dmwit> kraftyswine: It's not the same thing.  You can return things without defining an evaluation order.
16:30:26 <Cale> In the list monad, 'running an action' means 'picking an element from a list'
16:30:48 <augustss> and the sequence of actions doesn't necessarily affect the evaluation order
16:30:50 <vincenz> In the IO monad, it might mean launchcing a nuclear missile
16:31:05 <kraftyswine> I don't get your second example at all
16:31:07 <dmwit> kraftyswine: "f x = 2 * x" doesn't define when 'x' is evaluated; "f = do { x <- getLine; return (2 * read x) }" defines that x is evaluated before the return.
16:31:16 <Cale> In a parsing monad, for instance, 'running an action' means 'carrying out some parsing on the input'
16:31:28 <Cale> kraftyswine: To understand it, you have to know what filterM is.
16:31:38 <Cale> filterM is the monadically generalised version of filter
16:31:40 <int-e> kraftyswine: "sequencing" here does not necessarily mean sequential execution. In the List monad, you sequence different stages of what, operationally, can be described as a depth first search.
16:31:55 <Peaker> what does "monadically generalised" mean?
16:32:10 <drigz> scanl (\x y -> x ++ [y]) [] seems to outperform the standard 'inits'
16:32:14 <oerjan> Peaker: mad science
16:32:19 <Cale> kraftyswine: Rather than taking a plain predicate, it takes a function from elements of the list to (in this case) lists of booleans.
16:32:21 <vincenz> Peaker: warm fuzzy things
16:32:23 <drigz> a) why? and b) should it be replaced?
16:32:25 <Cale> Each boolean is tried.
16:32:46 <Peaker> Cale, filterM is specific to list monads, or can it be used with other monads?
16:32:53 <Cale> So that says "for each element of the list, regardless of its value, keep it, or throw it away"
16:32:56 <dobblego> ?type filterM
16:32:57 <dmwit> Peaker: All monads.
16:32:57 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
16:33:00 <Cale> It can be used with other monads.
16:33:18 * guenni2 wants a date with kraftyswine
16:33:22 <Peaker> Cale, isn't the try-all-cartesian-combinations a feature of the list monad?
16:33:25 * johnnowak wants more than a date
16:33:30 <Cale> For instance, in the IO monad, the predicate would be allowed to do some I/O before deciding whether to keep or drop each element
16:33:36 <Cale> Peaker: yes
16:33:48 <dmwit> Peaker: Yes, but this isn't the Cartesian product.
16:33:59 <dmwit> Peaker: This is the powerset.
16:34:01 * vincenz wants a date, period
16:34:01 <Cale> In a parsing monad, you'd do some parsing when deciding whether to keep or drop the elements.
16:34:18 <guenni2> vincenz: pick a number
16:34:23 <Cale> dmwit: It's the powerset in terms of a Cartesian product, in a sense.
16:34:28 <oerjan> vincenz: August 15 912.  hope this helps.
16:34:30 <vincenz> guenni2: 3/1/2
16:34:44 <guenni2> lol
16:34:46 <Peaker> dmwit, couldn't it be said to be a map of the cartesian product?
16:34:52 <tromp> :t filterM
16:34:53 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
16:35:02 <dmwit> Peaker: I guess it depends on what "map" means. =P
16:35:05 <Cale> You take a Cartesian power of [True,False], and use the results to tell you which of the elements to keep.
16:35:15 <Cale> see...
16:35:15 <kraftyswine> Cale: that's not really helping since I'm pretty sure monads have little to nothing to do with powersets or cartesian products, so you're only confusing things for me by dragging in irrelevancies.
16:35:16 <Peaker> dmwit, Literal application of the map function?
16:35:28 <Cale> kraftyswine: Oh, but the list monad does.
16:35:30 <vincenz> kraftyswine: And you're not making it easy to help you by being abbrasive.
16:35:57 <Cale> kraftyswine: and in general, nondeterminism monads do.
16:36:01 <dmwit> Peaker: Yes.  But the as Cale said, the Cartesian product is over [True, False], not the list you pass in as the last argument.
16:36:05 <guenni2> vincenz: he is like that, isn't he
16:36:15 <Cale> > mapM (const [True, False]) [1,2,3]
16:36:15 <lambdabot>  [[True,True,True],[True,True,False],[True,False,True],[True,False,False],[Fa...
16:36:24 <Cale> > filterM (const [True, False]) [1,2,3]
16:36:25 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
16:36:32 <Peaker> kraftyswine, I only learned what monads were today, so I can try to explain it in my own inaccurate way :)
16:36:42 <kraftyswine> please
16:36:43 <guenni2> vincenz: I made a bet that it would take him less than 2 mins to piss everyone off
16:36:49 <johnnowak> Peaker: make sure you put it on your blog
16:36:49 <Cale> kraftyswine: If you want a more general perspective...
16:36:56 <vincenz> guenni2: Not in #haskell :)
16:36:58 <Cale> http://www.haskell.org/haskellwiki/Monads_as_Computation
16:37:00 <lambdabot> Title: Monads as computation - HaskellWiki
16:37:00 <vincenz> Especially with Cale around
16:37:00 <Cale> read that :)
16:37:05 <vincenz> Cale is an unfervent helper
16:37:14 <vincenz> erm, fervent even
16:37:30 <vincenz> Or is that a dutch word only?
16:37:34 <oerjan> unferventless
16:37:42 <vincenz> oerjan: Thanks :)
16:37:46 <dobblego> "monads have little to nothing to do with powersets or cartesian products" <-- wtf?
16:37:50 <vincenz> In dutch it's simply 'fervent'
16:37:51 <Cale> kraftyswine: Please read the first section of my monads as computation tutorial. It should explain what monads are about.
16:38:04 <dobblego> oh, I see what's happening :)
16:38:09 <augustss> vincenz: it's an english word
16:38:12 <drigz> http://dictionary.reference.com/browse/fervent
16:38:13 <lambdabot> Title: fervent - Definitions from Dictionary.com
16:38:23 <tromp> :t mapM
16:38:24 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
16:38:31 <Cale> vincenz: oerjan is just being facetious
16:38:40 <vincenz> Cale: :)
16:38:41 <int-e> dobblego: right, because that's just two examples among many ;)
16:38:43 <Peaker> kraftyswine, Actually maybe I can't explain it any better than the tutorials: http://en.wikibooks.org/wiki/Haskell/YAHT/Monads
16:38:54 <oerjan> Cale: LIES
16:38:54 <vincenz> the YAHT tutorial is great
16:39:00 <Peaker> kraftyswine, I think I understood it (or almost understood it :-) from there
16:39:05 <dobblego> int-e, I thought kraftyswine was helping someone by saying that, but then I realised that kraftyswine was the person being helped
16:39:05 <vincenz> oerjan--
16:39:05 <tromp> @src mapM
16:39:05 <lambdabot> mapM f as = sequence (map f as)
16:39:32 <vincenz> Cale++
16:40:03 <gnuvince_> @hoogle (a -> b) -> [[a]] -> [b]
16:40:05 <lambdabot> No matches, try a more general search
16:40:20 <gnuvince_> :t map . zip
16:40:21 <lambdabot> forall a b. [a] -> [[b]] -> [[(a, b)]]
16:40:25 <vincenz> guenni2: concatMap
16:40:27 <Cale> kraftyswine: Let me know what you think after reading at least the first section :)
16:40:29 <vincenz> oh, nm
16:40:31 <oerjan> vincenz**
16:40:33 <vincenz> map f . concat
16:40:40 <yitz> @wn fervent
16:40:40 <dmwit> oerjan^^
16:40:40 <lambdabot> *** "fervent" wn "WordNet (r) 2.0"
16:40:40 <lambdabot> fervent
16:40:40 <lambdabot>      adj 1: characterized by intense emotion; "ardent love"; "an ardent
16:40:40 <lambdabot>             lover"; "a burning enthusiasm"; "a fervent desire to
16:40:40 <lambdabot>             change society"; "a fervent admirer"; "fiery oratory";
16:40:41 <vincenz> gnuvince_: even
16:40:42 <lambdabot> [10 @more lines]
16:40:54 <vincenz> dmwit~~
16:40:59 <dmwit> oerjan has been set to false
16:41:09 <tromp> > mapM (\n -> [0..n-1]) [2,5,3]
16:41:10 <lambdabot>  [[0,0,0],[0,0,1],[0,0,2],[0,1,0],[0,1,1],[0,1,2],[0,2,0],[0,2,1],[0,2,2],[0,...
16:41:13 <guenni2> vincenz: ?
16:41:19 <vincenz> guenni2: wrong tab-complete
16:41:21 <dmwit> (Assuming (^) is xor, of course.)
16:41:32 <guenni2> vincenz: np
16:41:50 <vincenz> guenni2: so did I win a date with that exact version of 3.5?
16:42:12 <Cale> > length . mapM (\n -> [0..n-1]) $ [2,5,3]
16:42:12 <lambdabot>  30
16:42:16 <augustss> what's inexact about 3.5?
16:42:19 <Cale> > product $ [2,5,3]
16:42:19 <lambdabot>  30
16:42:25 <vincenz> augustss: it has a floating point :)
16:42:37 <augustss> looks stable to me
16:42:44 <tromp> counting in mixed base number system...
16:43:00 <augustss> > 3.5 :: Rational
16:43:01 <lambdabot>  7%2
16:43:05 <vincenz> Nah, that's just my output system, I truncate it... otherwise it'd be 3.50000000000000000000000000000000000000001
16:43:14 <Cin> cale: why the ($)?
16:43:23 <tromp> > 0.3::Rational
16:43:24 <lambdabot>  3%10
16:43:24 <Cale> Cin: no good reason
16:43:36 <Cale> Cin: I'd replaced the length . mapM (\n -> [0..n-1]) with product
16:43:50 <vincenz> > 3.141592653589793
16:43:51 <lambdabot>  3.141592653589793
16:43:53 <vincenz> > 3.141592653589793 :: Rational
16:43:53 <lambdabot>  3141592653589793%1000000000000000
16:44:03 <yitz> > let oerjan = 2 in oerjan^^3
16:44:03 <lambdabot>  8.0
16:44:06 <Cin> cale: ah
16:44:19 <Peaker> what would filterM do if given an IO monad? :)
16:44:26 <Cale> I tend to prefer 7/2 when referring to the exact real or rational number, and 3.5 when referring to the results of an inexact measurement.
16:44:32 <yitz> > realToFrac pi
16:44:33 <lambdabot>  3.141592653589793
16:44:34 <vincenz> Ditto
16:44:41 <yitz> > realToFrac pi :: Rational
16:44:44 <lambdabot>  884279719003555%281474976710656
16:45:01 <Cale> Peaker: You don't so much *give* it the IO monad, but instantiate it with the IO monad in its type
16:45:20 <guenni2> vincenz: whom do you want the date with?
16:45:26 <Cale> Peaker: you get a function of type (a -> IO Bool) -> [a] -> IO [a]
16:45:32 <oerjan> @hoogle fileExists
16:45:32 <lambdabot> No matches found
16:45:37 <vincenz> guenni2: Is this a multiple-choice question or a trick one?
16:45:40 <oerjan> @hoogle exist
16:45:40 <lambdabot> Distribution.Extension.ExistentialQuantification :: Extension
16:45:40 <lambdabot> Language.Haskell.Extension.ExistentialQuantification :: Extension
16:45:40 <lambdabot> System.Directory.doesFileExist :: FilePath -> IO Bool
16:45:53 <oerjan> :t filterM System.Directory.doesFileExist
16:45:54 <lambdabot> [FilePath] -> IO [FilePath]
16:45:57 <vincenz> Peaker: You could, for instance, use IO operations in your condition to filter things in a list
16:45:58 <Peaker> Cale, so I can use the filter with a function that reads booleans from the user, as an example?
16:45:58 <Cale> where the resulting action will run each of the I/O performing predicates, and use the results to determine whether to keep each element
16:46:00 <guenni2> multiple choice
16:46:01 <Cale> yes
16:46:11 <oerjan> Peaker: ^^ example
16:46:13 <vincenz> guenni2: Do I get multiple choicces?
16:46:41 <guenni2> vincenz: you get one choice, but several options
16:47:07 <kraftyswine> well Cale, the first section is so much trash which I skipped then the second is less comprehensible the more I think about it. Specifically, it seems in no way different from any other function definition.
16:47:08 <Peaker> Cale, vincenz that's pretty cool..  But I get the sense that if filter had to be re-implemented as filterM to support monads, a lot of other functions have to, too?
16:47:22 <Cale> Peaker: yes
16:47:22 <Peaker> how is filterM defined?
16:47:25 <vincenz> Peaker: That's called a standard-library :)
16:47:31 <drigz> @src filterM
16:47:31 <lambdabot> Source not found. My brain just exploded
16:47:32 <vincenz> @src filterM
16:47:32 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
16:47:36 <Cin> > filterM (return . id) [a,b,c]
16:47:37 <lambdabot>  Couldn't match expected type `Bool' against inferred type `Expr'
16:47:48 <Peaker> vincenz, yeah, but what about my own functions?
16:47:58 <Peaker> vincenz, I wouldn't want to have to define funcM for every one of my func's
16:47:59 <Cale> kraftyswine: The first section is the important bit for understanding what monads are about from a programming perspective.
16:48:04 <drigz> @source filterM
16:48:04 <lambdabot> filterM not available
16:48:05 <vincenz> Peaker: usually we tend to build functions out of combinators
16:48:11 <Cale> kraftyswine: It's not different from any other function definition.
16:48:15 <vincenz> Peaker: I haven't found that to be a source of problems
16:48:27 <vincenz> Peaker: Normally your monadic interace is limited to a few functions
16:48:30 <vincenz> the rest is pure
16:48:37 <Cale> kraftyswine: It's just a pair of functions which you implement for your given type and they're required to satisfy some laws.
16:48:40 <oerjan> drigz: it's a bit too long
16:49:06 <Cale> kraftyswine: and that lets us get a whole library of general combinators built up from those two basic functions
16:49:06 <dobblego> Peaker, funcM is just liftM or fmap
16:49:11 <dons> ?users
16:49:11 <drigz> @source Control.Monad
16:49:11 <lambdabot> Maximum users seen in #haskell: 475, currently: 446 (93.9%), active: 25 (5.6%)
16:49:11 <lambdabot> http://darcs.haskell.org/packages/4/Control/Monad.hs
16:49:15 <Peaker> vincenz, I'd need to have a mirror of the pure functional world in my "stateful" action "world", wouldn't I?
16:49:19 <Cale> dobblego: hm?
16:49:23 <drigz> ^^^ is that link broken for others?
16:49:28 <Peaker> dobblego, oh, cool
16:49:29 <vincenz> Peaker: no, typically you'll reuse the pure functions
16:49:36 <dons> drigz: 4?
16:49:36 <dobblego> Cale, function application generalised to a Monad
16:49:41 <oerjan> drigz: @source and @docs got broken in 6.8
16:49:42 <dobblego> Cale, i.e. a functor
16:49:44 <dons> drigz: http://darcs.haskell.org/packages/mtl/ ?
16:49:46 <oerjan> @docs
16:49:47 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
16:49:47 <lambdabot> Title: Index of /packages/mtl
16:49:54 <Cale> dobblego: uh, but you're saying that funcM is usually fmap?
16:50:07 <dobblego> Cale, what else could funcM possibly be?
16:50:09 <oerjan> drigz: ^^ try that main page link, which still is correct
16:50:16 <Cale> Well, look at mapM
16:50:34 <Cale> It's completely different from anything you could get by simply applying functions to map
16:50:43 <dobblego> praps
16:51:01 <Peaker> wehre is the implementation of liftM?
16:51:06 <resiak> @src liftM
16:51:06 <dobblego> ?src lift<
16:51:06 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
16:51:06 <lambdabot> Source not found. Are you on drugs?
16:51:09 <Cale> in Control.Monad
16:51:10 <dobblego> ?src liftM
16:51:10 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
16:51:16 <drigz> dons, oerjan: thanks!
16:51:26 <Peaker> thanks
16:51:38 <dobblego> > liftM (+1) [1..10]
16:51:39 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
16:52:28 <Cale> kraftyswine: I think sequence is my favourite first example.
16:52:40 <Peaker> how do you unsugar that do?
16:52:59 <dobblego> @undo do { x1 <- m1; return (f x1) }
16:52:59 <lambdabot> m1 >>= \ x1 -> return (f x1)
16:53:01 <oerjan> @undo do { x1 <- m1; return (f x1) }
16:53:02 <lambdabot> m1 >>= \ x1 -> return (f x1)
16:53:03 <Cale> kraftyswine: It's a combining function which takes a list of "computations", whatever those are, and glues them together into a computation resulting in a list of results.
16:53:22 <dmwit> To instance Show, is implementing "show" enough?
16:53:23 <Cale> sequence :: (Monad m) => [m a] -> m [a]
16:53:37 <oerjan> dmwit: yes iirc
16:53:47 <vincenz> dmwit: shows is typically better
16:53:55 <augustss> dmwit: yes, nowadays :)
16:53:58 <Cale> It does this by simply recursing over the structure of the list, replacing list structure with program structure:
16:53:59 <oerjan> vincenz: you means showsPrec
16:54:02 <johnnowak> does anyone have a link to an alternative version of the haskell prelude with respect to Num? in particular, was there ever a proposal for Num to not imply Eq (to disallow floating point equality for example)?
16:54:04 <dmwit> Okay, thanks all.
16:54:07 <vincenz> oerjan: plain shows works too
16:54:10 <Cale> sequence [] = return []
16:54:10 <vincenz> iirc
16:54:22 <oerjan> er it's not a method
16:54:22 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
16:54:42 <vincenz> oerjan: doh
16:54:58 <vincenz> dmwit: anyways, showsPrec tends to be more efficient, since you can use function composition
16:55:09 <vincenz> dmwit: and you can ignore the 'd' parameter
16:55:23 <dmwit> ok
16:55:33 <dons> johnnowak: perhaps the numeric-prelude package?
16:55:40 <vincenz> showsPrec d (a,b) = shows a . shows b
16:56:01 <vincenz> showsPrec d (a,b) = ('(':) . shows a . shows b . (')':)
16:56:12 <johnnowak> dons: ah, thanks
16:56:15 <Cale> what about the comma? ;)
16:56:20 <vincenz> bah
16:56:35 <vincenz> showsPrec d (a,b) = ('(':) . shows a . (", " ++) . shows b . (')':)
16:56:50 <oerjan> > (1,2)
16:56:51 <lambdabot>  (1,2)
16:56:54 <augustss> vincenz: there's showChar and showString
16:56:59 <oerjan> actually no space by default
16:57:09 <vincenz> augustss: didn't know about the prior
16:57:19 <vincenz> showsPrec d (a,b) = ('(':) . shows a . (',':) . shows b . (')':)
16:57:27 <vincenz> :t showChar
16:57:27 <lambdabot> Char -> String -> String
16:57:38 <dons> johnnowak: reading through the early 90s haskell archives is also enlightening
16:57:38 <vincenz> Shouldn't that be called 'showsChar'
16:57:53 <augustss> yeah
16:57:55 <vincenz> @src showChar
16:57:55 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
16:57:58 <SamB> possibly
16:58:04 <vincenz> showChar = (:)
16:58:07 <dons> pretty, ohloh has logos now for haskell projects, http://www.ohloh.net/tags/haskell :)
16:58:08 <lambdabot> Title: Projects tagged &lsquo;haskell&rsquo; - Ohloh
16:58:16 <dons> Cale, looks like QuickCheck needs a logo!
16:58:39 <vincenz> dons: I'm pretty sure it has one
16:58:50 <atom> does the haskell length function for lists run in linear time?
16:58:56 <atom> or is it optimized?
16:58:57 <dons> ?src length
16:58:57 <lambdabot> Source not found. stty: unknown mode: doofus
16:59:01 <dons> hmm
16:59:05 <dons> atom: yes, of course.
16:59:06 <Cale> atom: It runs in linear time, and that's optimal.
16:59:07 <SamB> atom: you tell me!
16:59:13 <dons> ?src []
16:59:13 <lambdabot> data [] a = [] | a : [a]
16:59:23 <dons> it all flows from that type
16:59:39 <atom> Cale: I mean, you could always store the actual length in a field to optimize length queries...
16:59:41 <Cale> atom: The structure of lists is such that you can't access the nth element in any less than O(n) time.
16:59:52 <SamB> is it just me, or is GHC using the generic haskell logo?
16:59:54 <atom> Cale: so... no fast binary search?
16:59:57 <Cale> nope
17:00:01 <dobblego> atom, that would imply that the list is finite
17:00:09 <Cale> If you want fast binary search, you're using the wrong datastructure.
17:00:14 <atom> dobblego: damn, of course you're right...
17:00:25 <atom> Cale: care to make a suggestion?
17:00:25 <Cale> Lists take the place of loops, essentially.
17:00:32 <vincenz> atom: a tree :)
17:00:35 <kraftyswine> Cale: okay, I've got some broad idea what monads are about
17:00:41 <Cale> kraftyswine: great :)
17:00:48 <atom> vincenz: good one.
17:00:58 <vincenz> atom: if you want something prebuilt
17:01:01 <vincenz> atom: check Data.Sequence
17:01:06 <augustss> atom: and it would rule out lazy lists
17:01:07 <dons> SamB: right, since there's no ghc logo currently
17:01:12 <atom> vincenz: nope, tree is easy enough.
17:01:13 <kraftyswine> Cale: to use a monad, do you need to specify it explicitly?
17:01:31 <augustss> atom: Data.Sequence is excellent
17:01:36 <dons> Data.Sequence
17:01:39 <Cale> kraftyswine: Well, you can write things which are polymorphic over the monad type.
17:01:40 <dobblego> kraftyswine, there is the do keyword and the >>= and return functions
17:01:50 <Cale> kraftyswine: But in the end, yes, you do.
17:02:10 <Cale> (well, it might be implied by the types of things you're using)
17:02:20 <augustss> kraftyswine: if you're using a specific monad the type checker figures out whicj one it is
17:02:25 <Peaker> is it possible (even if bad practice) in theory to convert imperative programs to "imperative" Haskell programs with monads, in a way that reads just as imperative?
17:02:32 <Cale> For instance, most monads have at least a few primitive computations which are specific to that one monad.
17:02:44 <Cale> If you use one of those, type inference will do the rest.
17:02:55 <augustss> Peaker: yes
17:03:01 <Cin> peaker: i think one of the ideas of do-notation was to make it feel more imperative
17:03:09 <kraftyswine> Cale: what exactly is the relation between monads and function calls? I keep running over and over into the idea that monads are passed through function calls automatically
17:03:23 <dobblego> Peaker, Haskell is one of the best "imperative languages" I have ever used
17:03:29 <atom> it's not important right now anyway, mostly I'm thinking about how anyone can write anything optimal in haskell, since lots of algorythms require constant time random access in order to satisfy their time complexity "label" (for instance, I can't imagine n*log(n) quicksort without random access)
17:03:30 <Peaker> dobblego, really? :-)
17:03:36 <dobblego> Peaker, I'm not joking :)
17:03:42 <vincenz> I agree with dons
17:03:42 <Peaker> dobblego, any example of that?
17:03:43 <vincenz> dobblego:
17:03:44 <SamB> Peaker: augustss wrote a blog post about it
17:03:52 <Peaker> SamB, where?
17:04:01 <dobblego> Peaker, not off hand, sorry
17:04:12 <Cale> kraftyswine: Well, a monad is a type constructor, together with a definition for the functions return and (>>=).
17:04:18 <SamB> http://augustss.blogspot.com/2007/08/programming-in-c-ummm-haskell-heres.html
17:04:19 <lambdabot> Title: Things that amuse me, http://tinyurl.com/2948p6
17:04:19 <atom> and, before anyone asks, I'm not trying to be a troll, it's just been puzzling me for a long time
17:04:25 <unenough> can someone explain this? :
17:04:26 <unenough> https://launchpad.net/bzr/1.2/1.2/+download/Bazaar-1.2-OSX10.5.dmg
17:04:28 <lambdabot> http://tinyurl.com/38cg44
17:04:28 <augustss> Peaker: I would not hold up my blog post as an example of how to write Haskell code
17:04:32 <unenough> oops...mispaste!
17:04:40 <unenough> can someone explain THIS? :
17:04:40 <Cale> kraftyswine: Using return and (>>=) is just using some particular ordinary functions. We use the typeclass system to make things polymorphic though.
17:04:41 <unenough> Prelude> 3*(4/5)
17:04:41 <unenough> 2.4000000000000004
17:04:41 <unenough> Prelude> (3*4)/5
17:04:41 <unenough> 2.4
17:04:52 <Peaker> augustss, ofcourse, I am interesting in learning more about monads
17:04:52 <dmwit> Rounding error.
17:05:07 <dmwit> 4/5 is not exactly representable.
17:05:07 <yitz> dons: on ohloh, ghc says "primary language C" and "mostly written in C".
17:05:11 <Cale> unenough: floating point arithmetic doesn't have associative operations
17:05:11 <SamB> Peaker: I don't think that's what you'll learn
17:05:43 <dmwit> yitz: whoa, heh
17:05:52 <Peaker> what's the "$" do? And what the heck is "while" in Haskell? :)
17:05:53 <SamB> I expect you'll learn more about olegery than monads
17:06:11 <dobblego> f $ x = f x
17:06:21 <int-e> > takeWhile odd [1,3,5,7,8,9,10,11]
17:06:21 <lambdabot>  [1,3,5,7]
17:06:24 <SamB> Peaker: further down
17:06:27 <SamB> it is defined
17:06:35 <Peaker> SamB, ah
17:06:36 <johnnowak> yitz: ohloh is stupid
17:06:51 <Cale> kraftyswine: Typeclasses are essentially predicates on types, which, when the predicate holds, there is some set of functionality which is present.
17:06:53 <Peaker> dobblego, so $ applies a function to an argument?
17:06:56 <unenough> Cale, dmwit 4/5 is a Rational, no?
17:07:00 <unenough> should be
17:07:03 <SamB> well, or would be
17:07:03 <dmwit> nope
17:07:05 <Cale> unenough: No, not necessarily.
17:07:08 <dons> yitz: i suspects its the libgmp living in the rts getting counted
17:07:14 <Cale> unenough: In your case, it's a Double
17:07:15 <Peaker> dobblego, isn't it the same as just using a spaced-pair?  a b ?
17:07:20 <dobblego> Peaker, correct - it only serves to allow elimination of parentheses
17:07:22 <dmwit> unenough: Try this:
17:07:27 <Peaker> dobblego, oh, now its clear
17:07:28 <dmwit> > (4 :: Rational) / 5
17:07:28 <lambdabot>  4%5
17:07:32 <Cin> peaker: it's right-associative
17:07:35 <Cale> kraftyswine: Perhaps come to haskell-overflow, as this channel is pretty noisy :)
17:07:35 <yitz> dons: and everything else not being counted?
17:07:38 <dmwit> > 3 * ((4 :: Rational) / 5)
17:07:38 <lambdabot>  12%5
17:07:40 <dobblego> Peaker, yes, but consider length (map id [1..10]) versus length $ map id [1..10]
17:07:41 <johnnowak> Peaker: more like 'a $ b c d' is the same as 'a (b c d)'
17:07:42 <Peaker> Cin, ok, thanks
17:07:47 <dmwit> > (3 * (4 :: Rational)) / 5
17:07:48 <lambdabot>  12%5
17:08:10 <augustss> Peaker: my blog post has some heavy type class magic that I don't recommend to beginners :)
17:08:12 <Peaker> why is the $ necessary in the "while" example?
17:08:22 <dons> yitz: well, a quick grep, the rts is 55k, the compiler is 38k,
17:08:26 <dobblego> Peaker, it could easily have been replaced by using parentheses
17:08:36 <SamB> Peaker: because this
17:08:37 <Peaker> augustss, difficulty in training - ease in practice :)
17:08:40 <unenough> dmwit, ok
17:08:46 <johnnowak> Peaker: ($) is never necessary
17:08:46 <SamB> > id do return ()
17:08:47 <lambdabot>  Parse error at "do" (column 4)
17:08:54 <vincenz> dons: we need PreHaskell :) to write the RTS in
17:09:02 <SamB> Peaker: does that answer your question?
17:09:14 <Peaker> SamB, I think so - why isn't do usable as a value?
17:09:21 <SamB> Peaker: it is
17:09:25 <augustss> vincenz: part of the rts is planned to be rewritten in Haskell
17:09:26 <Peaker> SamB, I mean, without wrapping ()
17:09:33 <SamB> syntax
17:09:35 <SamB> that's all
17:09:36 <Cin> do is syntactic sugar
17:09:37 <vincenz> augustss: I didn't know that, interesting :)
17:09:40 <Twey> length map id [1..10] is equivalent to (length map) id [1..10], and length takes a list, not a function of type ((a -> b) -> [a] -> [b])
17:09:52 <augustss> vincenz: the scheduler
17:09:58 <Peaker> SamB, why isn't do {..} the same as (do {..}) what other precedence interpretation could there possibly be?
17:10:03 <vincenz> augustss: for threads?
17:10:05 <Cin> twey ^_^
17:10:09 <augustss> vincenz: yes
17:10:17 <vincenz> augustss: including STM?
17:10:18 <Twey> length $ map id [1..10] is equivalent to length (map id [1..10])
17:10:18 <SamB> Peaker: it just isn't syntactically valid, and don't ask me to explain why because I don't know ;-)
17:10:34 <SamB> there's not any great theoretical reason for it that I know of
17:10:39 <Peaker> SamB, I see
17:10:42 <roconnor> @go Hutton’s Razor
17:10:43 <Twey> Peaker: do isn't an operator AFAIK, I think it's Special.
17:10:43 <lambdabot> http://www.liu.edu/cwis/cwp/conted/hutton/staff.html
17:10:43 <lambdabot> Title: Hutton House Lectures
17:10:46 <Twey> Hi Cin :-)
17:10:48 <SamB> if there were, the theory involved would be the theory of parsing...
17:10:53 <augustss> Peaker: that's just the way the grammar is
17:11:05 <yitz> dons: still doesn't make sense. what % is gmp even in the rts? and anyway, it's just a linked lib. that's not the obvious meaning of "mostly written in".
17:11:13 <Peaker> augustss, weird, ok :)
17:11:15 <johnnowak> Peaker: because haskell programmers are afraid of s-expressions
17:11:32 <yitz> dons: are you sure that was generated automatically? maybe someone at ohloh just put it in for some reason.
17:11:50 <johnnowak> yitz: ohloh generates stuff automatically
17:12:02 <vincenz> yitz: paranoia :)
17:12:06 <SamB> yitz: they wouldn't deliberately do that to spite us
17:12:23 <vincenz> Oh no, Haskell! Let's pump up the c-count, everyone hates C!
17:12:51 <yitz> he, not to spite us, just not realizing that it's different than most compilers they've seen.
17:12:53 <SamB> look here
17:12:55 <augustss> just face it, ghc is mostly written in C
17:13:00 <SamB> http://www.ohloh.net/projects/5798/analyses/latest
17:13:00 <lambdabot> Title: GHC - Ohloh
17:13:59 <yitz> SamB: so mostly written in LaTeX, then. :)
17:14:02 <johnnowak> wasn't aware ghc included all that pascal and dos batch script
17:14:11 <SamB> what, that's 5%!
17:14:29 <augustss> Pascal?
17:14:42 <augustss> dos batch scripts i can believe
17:14:54 <SamB> probably it isn't really
17:14:57 <vincenz> Lol-code
17:15:04 <SamB> but I expect that that awk is actually awk
17:15:18 <augustss> FORTRAN!
17:15:22 <SamB> wish ohloh provided lists of files
17:15:40 <vincenz> How does ohloh work?
17:15:47 <vincenz> Does that mean ghc has to reside on ohloh?
17:15:49 <johnnowak> poorly
17:16:05 <SamB> vincenz: yes and no
17:16:07 <vincenz> Or do they analyze offsite repos?
17:16:17 <Twey> What?
17:16:18 <Twey> GHC?
17:16:20 <Twey> Pascal?
17:16:23 <SamB> they pull a local copy of the git mirror of ghc's repository
17:16:24 <Twey> O.O
17:16:30 <Twey> Ó.Ò
17:16:41 <vincenz> SamB: Must be expensive, storage/communication wise
17:16:58 <vincenz> And who got us into git ? :(
17:17:00 <SamB> vincenz: no more so than GHC development
17:17:10 <SamB> http://www.ohloh.net/projects/5798/enlistments
17:17:11 <lambdabot> Title: Enlistments - Ohloh
17:17:14 <vincenz> SamB: well ohloh hosts more than GHC I would presume
17:17:24 <dons> yitz: its generated automatically
17:17:29 <SamB> vincenz: oh, you meant diskspace
17:17:31 <vincenz> Eww, git
17:17:36 <Zao> vincenz: Indeed.
17:17:41 <SamB> yes, but see who you can blame?
17:17:46 <SamB> you can blame dons!
17:17:49 <SamB> he did it
17:17:50 * vincenz pokes dons in the linux-eye
17:18:02 <dons> fix darcs then.
17:18:03 <Cin> what's ew about git? linus tarballs?
17:18:07 <vincenz> I dislike git because I dislike the pompuousity with which the author presented it
17:18:12 <Cin> oh
17:18:14 <Zao> Cin: Weak portability.
17:18:14 <yitz> vince: @slap dons
17:18:21 <vincenz> @clap dons
17:18:21 <lambdabot> go slap dons yourself
17:18:24 <yitz> dons: well, are they getting this point right?
17:18:28 <Peaker> Lists are instances of MonadPlus, wouldn't it be equivalent to have a newtype MyList = List   that just uses return [] and >> to combine the lists, instead of mzero and mplus?
17:18:31 * SamB very carefully avoids pointing out that he is mirroring two projects himself
17:18:39 <vincenz> @nuke SamB
17:18:40 <lambdabot> Unknown command, try @list
17:18:46 * johnnowak didn't find the git presentation pompous 
17:18:52 <vincenz> Bah, we have unsafePerformIO but no nukes?!?
17:18:54 <SamB> git presentation?
17:19:04 <Cin> samb: it's on youtube
17:19:08 <SamB> lambdabot doesn't support unsafePerformIO
17:19:08 <johnnowak> SamB: http://www.youtube.com/watch?v=4XpnKHJAok8
17:19:09 <lambdabot> Title: YouTube - Tech Talk: Linus Torvalds on git
17:19:13 <SamB> I don't want to read that
17:19:13 <vincenz> johnnowak: oh come on, he comes in there and the first thing he does is apologize for his poor presentation.
17:19:29 <SamB> er. watch that now.
17:19:35 <vincenz> johnnowak: that's not the talk I meant
17:19:41 <johnnowak> vincenz: oh.
17:19:55 <johnnowak> that's the one i was referring to
17:20:02 <dons> ok. focus people.
17:20:47 <Peaker> why is MonadPlus required? what's the difference between mzero/mplus and return ()/>> ?
17:20:50 <dons> Cale, do you have a hi res version of the cabal box star logo? :)
17:20:54 <vincenz> johnnowak: oh never mind, it is
17:21:01 <dmwit> > return () :: [()]
17:21:02 <lambdabot>  [()]
17:21:06 <dmwit> > mzero :: [()]
17:21:07 <lambdabot>  []
17:21:23 <dmwit> > [1..3] `mplus` [5..10]
17:21:24 <lambdabot>  [1,2,3,5,6,7,8,9,10]
17:21:32 <dmwit> > [1..3] >> [5..10]
17:21:32 <lambdabot>  [5,6,7,8,9,10,5,6,7,8,9,10,5,6,7,8,9,10]
17:21:43 <Cale> dons: I have a scalable version...
17:21:46 <dons> Cale, also, i nominate you to do a ghc logo we can love :)
17:22:01 <Peaker> dmwit, but the list instantiation as a MonadPlus  could be a NewList instantiation as a Monad, couldn't it?
17:22:01 <dmwit> Peaker: There are different laws for return/>> than there are for mzero/mplus.
17:22:11 <dmwit> Peaker: no
17:22:14 <dons> personally, i'd think something based on the historical green dinosaur logo would be cool. b
17:22:57 <dmwit> Peaker: For one thing, the types of return and mzero aren't compatible.
17:23:14 <dmwit> Peaker: But the real problem is in the laws, as I said.
17:23:18 <Cale> http://cale.yi.org/autoshare/Cabal-built-with.svg
17:23:18 <dmwit> For example
17:23:23 <Cale> http://cale.yi.org/autoshare/Cabal.svg
17:23:28 <dons> cool, cheers.
17:23:30 <Peaker> dmwit, yeah,   I meant return some-zero-value
17:23:43 <Cale> dons: any other versions weren't done by me. I noticed some tiny cute bullets :)
17:23:54 <dons> yeah hehe
17:23:58 <dons> i think that was ross
17:24:01 <dmwit> Peaker: We demand that (mzero `mplus` a) = (a `mplus` mzero).
17:24:16 <gwern> Cale: what circumstances would a built-with-cabal be used and not just cabal?
17:24:20 <dmwit> Peaker: But (return () >> a) /= (a >> return ()) in most cases.
17:24:30 <dons> gwern: on a library page
17:24:31 <Peaker> dmwit, I see
17:25:06 <gwern> dons: so then what would you use cabal for instead of built-with-cabal? building is what cabal *does*
17:25:15 <dons> on cabal's page.
17:25:19 <Cin> cale: hehe, i like the optical illusion that the star on the top one is lighter than the bottom :P
17:25:30 <gwern> dons: but cabal is built with cabal!
17:25:38 <dons> so both would be appropriate
17:25:49 <dons> possibly, there should be a version that is recursive, or fractal, for that case
17:25:50 <Peaker> dmwit, why is MonadPlus a "subclass" of Monad? It doesn't seem to require it to be a monad
17:25:50 <gwern> gah
17:26:09 <pjd> Peaker: MonadPlus is basically Monad + Monoid
17:26:17 <dmwit> Peaker: Hm, good question, I never really thought about it.
17:26:17 <Peaker> pjd, Monoid?
17:26:23 <pjd> Data.Monoid
17:26:41 <Cin> the cabal logo on here isn't resized very well: http://www.haskell.org/cabal/
17:26:41 <lambdabot> Title: The Haskell Cabal
17:26:47 <dobblego> Peaker, it follows the monoid laws - specific to a monad
17:26:48 <shachaf> pjd: Not quite the same, though.
17:26:49 <Cale> Cin: I tried somewhat to account for that.
17:27:06 <dmwit> dobblego: What additional laws does it have over Monad and Monoid together?
17:27:12 <pjd> Peaker: MonadPlus mzero/mplus are basically Monoid mempty/mappend
17:27:14 <Cale> Cin: ... if I recall correctly, anyway
17:27:23 <dobblego> dmwit, none that I know of
17:27:47 <Cale> Cin: yeah, the bottom one is darker
17:27:52 <Peaker> pjd, I'm a beginner :) I guess I'll understand it later. Thanks
17:28:05 <pjd> Peaker: Monoid is really simple :)
17:28:06 <pjd> and useful
17:28:07 <dobblego> Peaker, the monoid laws are quite easy to understand
17:28:10 <dmwit> Peaker: It sounds like historical accident rather than deep reasoning that MonadPlus requires Monad.
17:28:13 <Cale> Cin: er, heh, it's actually not an optical illusion :)
17:28:34 <Peaker> dmwit, ah, that makes me proud of the question :)
17:28:34 <Cin> cale: are they actually different colours? :P
17:28:37 <Cale> Cin: I suppose that I decided it looked better that way
17:28:38 <Cale> yes
17:28:44 <pjd> Peaker: monoids are basically anything with an identity and an associative operation
17:28:50 <dobblego> @go monadplus reform proposal
17:28:51 <lambdabot> http://www.haskell.org/haskellwiki/MonadPlus_reform_proposal
17:28:51 <lambdabot> Title: MonadPlus reform proposal - HaskellWiki
17:29:04 <Peaker> pjd, but referential transparency contradicts identity?
17:29:17 <dmwit> no?
17:29:18 <Cin> cale: how's this? http://rtfs.ath.cx/Cabal-With-Text.png
17:29:19 <pjd> Peaker: lists are a monoid with [] and concatenation
17:29:22 <dons> Peaker: i'm not sure what you just said makes sense :)
17:29:26 <dmwit> > 0 + 1 -- 0 is the identity
17:29:27 <lambdabot>  1
17:29:27 <pjd> Peaker: identity as in identity element
17:29:40 <Peaker> pjd, that does not have an effect when used in the operation?
17:29:44 <yitz> Peaker: It's useful to have MonadPlus a subclass of Monad. You can specify it as a constraint in a type signature, and get Monad for free. For just Monoid, you use that.
17:29:46 <dobblego> 0 is the identity to +, 1 is the identity to *
17:29:49 <dmwit> Peaker: right
17:29:51 <Peaker> oh, ok
17:29:52 <pjd> Peaker: roughly
17:30:04 <pjd> the integers form two monoids
17:30:05 <dobblego> ?check \x -> x + 0 == x -- identity
17:30:08 <lambdabot>  OK, passed 500 tests.
17:30:16 <Peaker> pjd, why isn't Monoid the typeclass, instead of MonadPlus?
17:30:17 <dmwit> yitz: But you could do (Monad m, Monoid (m a)) =>
17:30:23 <pjd> one with (+) and 0, another with (*) and 1
17:30:32 <Peaker> pjd, is that a Haskell term or a math term?
17:30:43 <Cale> Cin: did you tweak the colours?
17:30:43 <pjd> Peaker: it's a general term
17:31:02 <dobblego> Peaker, sometimes it is called MonadWithPlus
17:31:02 <pjd> http://en.wikipedia.org/wiki/Monoid
17:31:02 <lambdabot> Title: Monoid - Wikipedia, the free encyclopedia
17:31:14 <Cin> cale: no, i just resized it. heh >___>
17:31:23 <Cale> Okay.
17:31:26 <dmwit> yitz: i.e. having Monad and Monoid as orthogonal classes, and leaving out MonadPlus, gets you just as much power (and more!) as we have now.
17:31:29 <Peaker> pjd, so monoid would be a meta-typeclass, as each type could "have" multiple monoids?
17:31:34 <yitz> dmwit: sure why not.
17:31:48 <Cale> Cin: Basically, the idea with those colour choices is to try to make the box stand out from the background by the same amount.
17:31:51 <yitz> dmwit: why leave out MonadPlus?
17:31:57 <dmwit> yitz: Why have it?
17:32:00 <pjd> Peaker: i don't know about "meta-typeclass"
17:32:04 <Cin> cale: (on my browser the logo on cabal's page is pixelated)
17:32:07 <pjd> it's just a plain one
17:32:30 <yitz> dmwit: you mean why have separate method names?
17:32:39 <Cale> Cin: oh, someone did something horrible to it.
17:32:46 <Cale> Cin: It's browser-resized.
17:32:48 <dmwit> yitz: I mean, why have the MonadPlus class at all?
17:32:50 <Cin> cale: yeah
17:32:53 <Peaker> pjd, well, in theory, you could define a Monoid to be an operation and an identity element, and then specify that MonadPlus is an instance of that (instance of meta-typeclass would be a typeclass), such that op is `mplus` and id is mzero
17:32:58 <Cin> cale: the colours are very nice imo
17:33:09 <dmwit> yitz: It's not my question, but I certainly think it is a valid one.
17:33:12 <pjd> Peaker: right, that's where something like class aliases would be useful
17:33:21 <Peaker> pjd, what are class aliases?
17:33:48 <Cin> cale: i see what you're saying. the one with the white background obviously needs darker colours to contrast better and vise-versa for the other one
17:33:51 <pjd> Peaker: http://repetae.net/recent/out/classalias.html
17:33:51 <lambdabot> Title: Class Alias Proposal for Haskell
17:34:01 <yitz> dmwit: (Monad m, Monoid (m a)) is inconvenient.
17:34:13 <dmwit> yitz: Well, that's certainly fair.
17:34:39 <pjd> Peaker: the problem is not unique to monoids;  for example, Monad and Functor are currently separate, even though they really shouldn't be
17:35:04 <Peaker> pjd, so class alises would be sort of "adapters" between classes?
17:35:17 <dons> hmm, are the sub-links on google search results for some key phrases set manually?
17:35:17 <Cale> Cin: yeah
17:35:35 <pjd> Peaker: well, i think it would eliminate the need for something like adapters
17:35:37 <yitz> dmwit: but yeah, having mappend = mplus and mempty = mzero is a bit of a mess.
17:35:42 <dons> e.g. if you google for 'xmonad' , it finds the homepage, and lists some deeper links, but the link titles aren't taken from the page source
17:36:06 * tibbe is shocked
17:36:19 <pjd> currently, you need adapters like Monad m => Applicative (WrappedMonad m)
17:36:28 <tibbe> my server just did 2900 QPS on a 120 byte document
17:36:31 <dons> tibbe: ...
17:36:38 <pjd> with class aliases, Monad would just be defined as Applicative + whatever to begin with
17:36:51 <dons> heh, 'programming in haskell' is online, http://books.google.com/books?id=olp7lAtpRX0C&dq=haskell+programming&pg=PP1&ots=IvE-lu7F9-&sig=UUkdE6MRIfsh3HVbI0z9LyBJ8fI&hl=en&prev=http://www.google.com/search?hl=en&safe=off&q=haskell+programming&btnG=Search&sa=X&oi=print&ct=title&cad=one-book-with-thumbnail#PPP1,M1
17:36:53 <lambdabot> Title: Programming in Haskell - Google Book Search, http://tinyurl.com/35pakg
17:37:28 <dons> with big chunks missing, oh well
17:38:27 <Toxaris> (Monad m, Monoid (m a)) has not the same meaning as (MonadPlus m). (MonadPlus m) means something like (forall a. Monoid (m a)).
17:39:33 <dmwit> That's the first good reason for MonadPlus I've heard all day.
17:39:39 <dmwit> Peaker: Did you catch that?
17:39:39 <Cale> dons: I can only see the contents and index.
17:40:06 <dmwit> Well... it's the first *difference*, anyway.
17:40:12 <dmwit> I'm not sure it's a good reason.
17:40:24 <Peaker> dmwit, I'm sorry, catch what?
17:40:50 <Peaker> what Toxaris said?
17:40:58 <dmwit> Peaker: See Toxaris' comment on why MonadPlus can sometimes be different from Monoid + Monad.
17:41:01 <dmwit> yeah
17:41:37 <Peaker> I don't understand the difference there, other than not stating m is a monad? Isn't the above polymorphic for all a's too?
17:42:14 <dmwit> Well (Monad m, Monoid (m Int)), for example, is different than (MonadPlus m).
17:42:43 <dons> Cale, any thoughts on what a good ghc logo would look like?
17:43:01 <yitz> dmwit: I don't think that's really fundamental, though it adds to the awkward factor.
17:43:04 <dmwit> There may be some special instance of Monoid for monads that return Int's, for example, but that doesn't work for monads that return arbitrary values.
17:43:04 <Peaker> dmwit, what if you s/Int/a
17:43:09 <Cale> dons: hmm...
17:43:25 <dons> there was a long thread about this recently, but nothing resulted
17:43:41 <dmwit> Peaker: I guess it's basically the same (Toxaris?) if you actually keep the 'a'.
17:43:49 <dons> this was the logo till 2000 or so, http://www.cse.unsw.edu.au/~dons/images/happy-dino.jpg
17:43:51 <dmwit> Peaker: But most functions will not be that polymorphic.
17:44:11 <roconnor> dons: that's pretty terrible
17:44:11 <Toxaris> Peaker, dmwit: I don't think so. consider the type of (>>=).
17:44:23 <dons> roconnor: hey, i bet it was awesome in 1991
17:44:35 <dmwit> :t (>>=)
17:44:36 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
17:44:48 <Toxaris> Peaker, dmwit: that is, consider functions with the *same* m but *different* a's
17:44:49 <roconnor> dons: we need something 21 century similar to: http://www.rubyonrails.org/images/rails.png
17:45:00 <roconnor> now that's a logo!
17:45:17 <dons> fancy pants
17:45:26 <yitz> dons: I suggested projecting a lambda onto the form of the Clyde Arc.
17:45:28 <dmwit> Toxaris: Literally different a's, or just a's and b's?
17:45:41 <roconnor> dons: unless we want a logo suitable for offset printing.
17:45:42 <Toxaris> dmwit: just a's and b's
17:45:52 <Peaker> dmwit, Toxaris Its a bit over my head right now, I have only read the tutorials yet :)
17:45:58 <dons> see also http://www.python.ie/images/python-logo.png
17:46:03 <dons> http://www.chipsquips.com/wp-content/uploads/2006/11/ruby.jpg
17:46:22 <dmwit> Toxaris: Oh, I see what you're saying; you'd have to specify (Monad m, Monoid (m a), Monoid (m b)) rather than (MonadPlus m).
17:46:33 <dons> http://www.erlang.org/doc/erlang.gif
17:46:49 <roconnor> erlang is stuck in the 20th century
17:47:10 <roconnor> back when e was popular
17:47:17 <Toxaris> dmwit: yeah that's the practical reason why it's a bad idea imho. But I think there are situations where you can't provide this extended context at all
17:47:19 <roconnor> now i is popular
17:47:46 <augustss> what's the next letter?
17:47:50 <dons> so a 3d space lambda with lightning bolts
17:47:50 <roconnor> We need a GHC logo where we can tack on a script i to get a GHCi
17:47:54 <dons> hmm, so 'e' was early 90s, 'i' was early 2000s
17:47:58 <resiak> iGHC
17:47:59 <roconnor> augustss: o
17:48:02 <pjd> augustss: h
17:48:13 <dons> 'x' is always in vogue
17:48:24 <roconnor> resiak: that actually sounds really good.  GHCi should be renamed.
17:48:40 <solrize_> ghc\
17:48:46 <resiak> ¡GHC!
17:48:53 <pjd> why not ghi
17:48:54 <solrize_> hehe
17:49:02 <solrize_> gh_c
17:49:15 <dmwit> pjd: I like it. =)
17:49:46 <dmwit> Then, when we get a really fast, extended version, we can call it efghi
17:50:13 <dons> augustss: did hbi start the whole 'i' craze? :)
17:50:37 <yitz> dons: Apple will claim it was them.
17:50:42 <augustss> no, it wasn't called ihb
17:51:18 <dons> if only. we could have sued apple
17:53:27 <solrize_> @pl sum $ do { i<-foo; j<-bar; k<-baz; f i j k}
17:53:27 <lambdabot> (line 1, column 10):
17:53:27 <lambdabot> unexpected "{"
17:53:27 <lambdabot> expecting variable, "(", operator, "$", "$!", "`seq`" or end of input
17:53:55 <solrize_> @pl sum $ do { i<-[1,2]; j<-[3,4]; k<-[5,6]; f i j k}
17:53:56 <lambdabot> (line 1, column 10):
17:53:56 <lambdabot> unexpected "{"
17:53:56 <lambdabot> expecting variable, "(", operator, "$", "$!", "`seq`" or end of input
17:54:07 <solrize_> @pl sum $ do { i<-[1,2]; j<-[3,4]; k<-[5,6]; return $ f i j k}
17:54:07 <lambdabot> (line 1, column 10):
17:54:07 <lambdabot> unexpected "{"
17:54:07 <lambdabot> expecting variable, "(", operator, "$", "$!", "`seq`" or end of input
17:54:13 <pjd> solrize_: sum . liftM3 f ?
17:54:14 <mauke> solrize_: ...
17:54:29 <pjd> liftA3, even
17:54:33 <solrize_> pjd, hmm, thanks
17:54:47 <pjd> solrize_: except not sum ., actually
17:55:03 <Toxaris> dmwit: foo :: MonadPlus m => m a   means that foo is allowed to use mplus :: m b -> m b -> m b for whatever b foo likes, but bar :: (Monad m, Monoid m a) => m a  means that bar is only allowed to use mappend :: m a -> m a -> m a  for a type a chosen by the caller.
17:55:24 <pjd> :t \f a b c -> sum $ liftM f a b c
17:55:25 <lambdabot> forall a a1 t t1. (Monad ((->) t1), Num a) => (a1 -> t -> [a]) -> (t1 -> a1) -> t1 -> t -> a
17:55:32 <pjd> :t \f a b c -> sum $ liftA3 f a b c
17:55:33 <lambdabot> forall a a1 b c. (Num a) => (a1 -> b -> c -> a) -> [a1] -> [b] -> [c] -> a
17:55:50 <roconnor> ``What do I mean by Web 2.0-Style Logo? If you follow Web 2.0 closely, you’ll see similarities in the way logos are designed: Simple, glossed, gradient, bright-colored and often came with a slight reflection and a beta sign just like this:
17:55:53 <roconnor> http://www.alleba.com/blog/2006/09/26/photoshop-tutorial-how-to-make-a-web-20-style-logo/
17:55:55 <lambdabot> Title: b Alleba Blog 3d  Photoshop Tutorial: How to Make a Web 2.0-Style Logo 49, http://tinyurl.com/vhlfs
17:55:57 <dmwit> Toxaris: Right. sneaky
17:56:38 <BMeph> roconnor: So, GHC's logo should be - a lambda on a silver platter? ;)
17:57:25 <Toxaris> :t mplus (return ()) (return ()) >> mzero
17:57:25 <solrize_> @pl sum [i*j*k | i<-foo, j<-bar, k<-baz]
17:57:26 <lambdabot> i * j * k | i <- foo + j <- bar + k <- baz
17:57:26 <lambdabot> forall (m :: * -> *) b. (MonadPlus m) => m b
17:57:44 <Toxaris> :t mappend (return ()) (return ()) >> mempty
17:57:45 <lambdabot> forall (m :: * -> *) b. (Monoid (m b), Monoid (m ()), Monad m) => m b
17:57:50 <dejones> anyone of the people in the AFP course at Chalmers around...?  I'm interested in the Shapes demo code.  :)
17:58:05 <Toxaris> dmwit: see how (Monoid (m ())) leaked to the context?
17:58:12 <Zao> dejones: Tried #haskell.se?
17:58:15 <dejones> http://www.cs.chalmers.se/Cs/Grundutb/Kurser/afp/lectures.html
17:58:16 <lambdabot> Title: Advanced Functional Programming
17:58:17 <dejones> Zao: nope
17:58:34 * roconnor fires up inkscape
17:58:44 <dmwit> Toxaris: yeah...
17:58:47 <roconnor> Not that I have any training in graphic design
17:58:54 <dejones> Zao: thanks for the suggestion.  :)
17:58:57 <Toxaris> dmwit: that means that every action polymorphic in the monad would have to specify which types the monadic type constructor is applied to, which obviously breaks a sensible abstraction barrier
17:59:06 <roconnor> But I'm sure all I need to do is read a few blog posts on  how to design a logo
17:59:20 <dejones> I'm mainly confused how to actually get the Shapes code to do the demo...
17:59:23 <dejones> http://www.cs.chalmers.se/Cs/Grundutb/Kurser/afp/lectures.html
17:59:23 <lambdabot> Title: Advanced Functional Programming
17:59:27 <dejones> Lecture 2
17:59:28 <dejones> :)
17:59:39 <dmwit> Toxaris: ok, ok, I get it! =P
17:59:39 <dejones> if someone wants to have a look.
18:00:02 <Toxaris> dmwit: I was happy that my example worked with lambdabot :)
18:01:10 <Toxaris> dmwit: nonetheless, I would like class MonoidConstructor m where zero :: m a; sum :: m a -> m a -> m a without the Monad superclass instead of MonadPlus
18:02:55 <Toxaris> or maybe the possibility to express (forall a . Monoid m a) in contexts. higher-ranked contexts :)
18:06:31 <ivan___> when i'm constructin a lambda function can i use where in it?
18:06:45 <pjd> ivan___: nope
18:06:58 <pjd> you can use let, though
18:07:02 <dmwit> You can use "let", though.
18:07:04 <dmwit> too slow
18:07:09 <ivan___> pjd: oh yea thx =)
18:07:30 <pjd> dmwit: all that fancy capitalization and punctuation :)
18:07:47 <dejones>     No instance for (Show (Signal.Signal Shape.Shallow.Shape))
18:07:47 <dejones>       arising from a use of `print' at Run.hs:7:2-21
18:07:51 <Peaker> I built a Haskell library that came with a Makefile, it generated a .a library. Is that normal? Why not .so?
18:08:01 <dejones> can someone explain what I need to do to add an instance declaration for Show?
18:08:02 <dejones> :)
18:08:04 <mauke> no dynamic loading
18:08:15 <pjd> dejones: you can derive it
18:08:17 <dmwit> dejones: ...deriving Show?
18:08:21 <Peaker> mauke, Haskell doesn't support dynamic loading .so's?
18:08:36 <mauke> that depends on the implementation
18:08:40 <dmwit> dejones: data Whatever a = ... deriving Show -- it's actually the syntax =)
18:08:42 <dejones> pjd, dmwit: I'm not sure how to do that... or what explicitly you mean by derive it?
18:08:56 <Peaker> mauke, ghc?
18:09:21 <dejones> dmwit: do you know of an example I could look at?  I think an example would help me better understand.
18:09:22 <dejones> :)
18:09:36 <dmwit> data Maybe a = Just a | Nothing deriving Show
18:09:45 <dmwit> There's really not much to understand.
18:09:56 <pjd> dejones: are those (Signal.Signal Shape.Shallow.Shape) your data types?
18:10:04 <dejones> pjd: Yeah.
18:10:13 <Peaker> how do I use a ".a" file compiled from a Haskell lib in my Haskell program?
18:10:15 <Peaker> (ghc)
18:10:29 <pjd> right, then just tack on "deriving Show"
18:10:40 <dejones> pjd, dmwit: yes, they are the data types.  They are from code here on Lecture 2: http://www.cs.chalmers.se/Cs/Grundutb/Kurser/afp/lectures.html
18:10:41 <lambdabot> Title: Advanced Functional Programming
18:10:42 <dmwit> dejones: Just stick a " deriving Show" after the end of the data declarations for Signal.Signal and Shape.Shallow.Shape.
18:10:45 <pjd> you probably want to add that to any data type you expect to be printing or showing
18:10:46 <dejones> ok
18:11:37 <dmwit> oh
18:11:39 <pjd> dejones: what happens is that the compiler mechanically derives a Show instance that more or less prints out a constructor as you would see it in source code
18:11:41 <dmwit> Never mind, you're screwed.
18:11:50 <dmwit> dejones: You're done for, you can't "show" functions.
18:11:55 <dejones> dmwit: lol
18:12:01 <dmwit> dejones: (And Shape is just a wrapper for a function.)
18:12:27 <pjd> > show show
18:12:28 <lambdabot>  "<() -> [Char]>"
18:12:31 <dejones> hah, then wtf is the point of this "demo" code if I can't actually use it to see the demo...?
18:12:33 <dejones> :/
18:12:40 * dejones is confused.
18:12:59 <tromp_> > 80/(1.85^2)
18:13:00 <lambdabot>  23.37472607742878
18:13:07 <tromp_> > 85/(1.85^2)
18:13:08 <lambdabot>  24.835646457268076
18:13:09 <dmwit> dejones: There must be some other way of visualizing Shape.
18:13:17 <pjd> dejones: you probably don't want to print it out, then
18:13:19 <dmwit> dejones: Do you have some way of showing graphics?
18:13:45 <dejones> dmwit: hmm, I guess there is some graphics library for Haskell... GtkHs maybe?
18:14:01 <dmwit> That sounds like more work than they're expecting you to go to.
18:14:09 <dmwit> Are you sure there's no library for showing Shapes?
18:14:28 <dejones> dmwit: Umm, not that I know of...?
18:14:34 * dejones is a Haskell newb.
18:14:54 <dejones> I'm not actually in the class..  I just saw it from the Chalmers guys in here.  So I am looking at some of the stuff to help me learn Haskell.  ;)
18:15:16 <dmwit> dejones: I'll give you a hint: there's a module called Render.
18:15:17 <dmwit> ;-)
18:15:43 <dejones> dmwit: yep, I see Render.
18:15:58 <dmwit> render  :: Window -> Shape -> String
18:16:04 <dmwit> defaultWindow :: Window
18:16:18 <dmwit> So you should be able to get a String out of your Shape without too much trouble.
18:16:53 <solrize_> @hoogle Bool -> Int
18:16:53 <lambdabot> Data.Time.Calendar.MonthDay.monthLength :: Bool -> Int -> Int
18:16:53 <lambdabot> Data.Time.Calendar.MonthDay.monthAndDayToDayOfYear :: Bool -> Int -> Int -> Int
18:17:03 <dejones> dmwit: hmm.
18:17:16 <solrize_> @pl \x -> if x then 1 else 0
18:17:16 <lambdabot> flip (flip if' 1) 0
18:17:20 <dmwit> solrize_: fromEnum
18:17:30 <dmwit> > map fromEnum [False, True]
18:17:31 <lambdabot>  [0,1]
18:17:31 <solrize_> :t if'
18:17:32 <lambdabot> Not in scope: `if''
18:17:43 <solrize_> fromEnum False
18:17:46 <SamB> > Data.Time.Calendar.MonthDay.monthLength True 1
18:17:47 <lambdabot>   Not in scope: `Data.Time.Calendar.MonthDay.monthLength'
18:17:47 <solrize_> > fromEnum False
18:17:48 <lambdabot>  0
18:17:51 <solrize_> hmm thanks
18:18:06 <Toxaris> > toEnum 3 :: Bool
18:18:07 <lambdabot>  Exception: Prelude.Enum.Bool.toEnum: bad argument
18:18:29 <solrize_> :t fromEnum
18:18:30 <lambdabot> forall a. (Enum a) => a -> Int
18:22:21 <Peaker> what's wrong with "do x <- getLine ; putStrLn (read x) * 2 ..." ?
18:22:42 <mauke> Peaker: putStrLn doesn't return a number
18:22:54 <dons> :t putStrLn ((read ?x) * 2)
18:22:55 <lambdabot>     No instance for (Num String)
18:22:55 <lambdabot>       arising from the literal `2' at <interactive>:1:22
18:22:55 <lambdabot>     Possible fix: add an instance declaration for (Num String)
18:22:55 <Toxaris> Peaker: putStrLn (readx * 2)
18:23:09 <dons> :t print ((read ?x) * 2)
18:23:10 <lambdabot> (?x::String) => IO ()
18:23:45 <Peaker> What about "x <- getLine ; putStrLn (read x * 2)" ?
18:23:52 <Toxaris> Peaker: hmm no you need print (read x * 2)
18:24:13 <Toxaris> Peaker: read x * 2 is a number, you have to convert it back to a string to putStrLn it
18:24:31 <dejones> dmwit: I'm confused.  :/
18:24:46 <dmwit> dejones: why?
18:24:54 <Peaker> Toxaris, what's the opposite of "read", to do that?
18:24:59 <Toxaris> Peaker: show
18:25:06 <pjd> @src print
18:25:06 <lambdabot> print x = putStrLn (show x)
18:25:11 <Peaker> Toxaris, oh I should have remembered that, thanks
18:27:20 <Toxaris> :t show (read "1" * 2)
18:27:20 <lambdabot> String
18:27:26 <dejones> dmwit: I'm trying to execute bouncingBall from Example.hs, and it is of type "Signal Shape" but, I'm having issues getting those types  :/
18:27:26 <Toxaris> > show (read "1" * 2)
18:27:27 <lambdabot>  "2"
18:27:46 <dejones> dmwit: I tried bouncingBall (constS 1) circle but no luck with that.
18:28:00 <dmwit> dejones: There is also an "animate" function.
18:29:07 <Plouj> what's a good haskell usergroup to ask help with this error: http://pastebin.ca/944365 ?
18:29:27 <dmwit> Plouj: add --make
18:29:35 <Plouj> dmwit: where?
18:29:36 <dmwit> Plouj: (to your ghc invocation)
18:29:46 <Plouj> `runghc Setup.hs build --make`?
18:30:00 <dmwit> Oh, this is some cabalized thing?
18:30:04 <dmwit> hm
18:30:08 <Plouj> apparently, yeah
18:30:12 <dejones> dmwit: ahh, I'll try animate  :)
18:30:16 <dmwit> Have you got the development version of GL/glut?
18:30:26 <Plouj> for C? yes
18:30:51 <Plouj> also, GHC in fedora comes with /usr/lib64/ghc-6.8.2/lib/GLUT-2.1.1.1/libHSGLUT*
18:31:16 <dmwit> It sounds like a cabal issue (not linking against a library).
18:31:24 <Plouj> yeah
18:31:27 <Plouj> and I see now way to debug it
18:31:31 <Plouj> no manual, no logs
18:31:38 <dons> Plouj: looks like missing glut libs, or else glut not found when linking
18:31:53 <dons> where does your glut C library live?
18:31:54 <Cale> Heh...
18:32:04 <dejones> dmwit: Thank you!  :)
18:32:07 * Cale considers using a patch of Glasgow tartan in a GHC logo :)
18:32:24 <dejones> dmwit: I was trying to execute the wrong function to get a demo to display.  :)  hahah, thanks!
18:32:35 <Plouj> /usr/lib/libglut.so and /usr/lib64/libglut.so
18:32:36 <dmwit> dejones: =)
18:32:52 <dons> Plouj: right, so is it the 64 bit that's failing to link here?
18:33:07 <dons> and are the functions like glutGet defined in that lib?
18:33:19 <Plouj> dons: I don't know!
18:33:26 <dejones> hey Cale, are possibly going to submit a "proposal" for that Array index bug?  http://hackage.haskell.org/trac/ghc/ticket/2120  --- I am wiling to help, but I'm not sure if I understand the code well enough to actually do the proposal alone.  ;)
18:33:29 <lambdabot> Title: #2120 (Arrays allow out-of-bounds indexes) - GHC - Trac
18:33:54 <Cale> dejones: That needs some thinking...
18:34:18 <Cale> dejones: The real problem is which primitives are the right ones for building an array library.
18:34:37 <Cale> dejones: Do you know what Igloo's reasoning was for going to this safeIndex way?
18:34:39 <dons> Plouj: you can set extra paths to look for libraries directly in the .cabal file
18:34:42 <dons> extra-lib-dirs: /usr/X11R6/lib/lib64  for exapmle
18:34:49 <dejones> Cale: performance?
18:35:12 <dejones> Cale: I'm sorry my gf is making me go get dinner right this moment!!  The place is closing.. I'll be back in a little bit.  Sorry!
18:35:25 <Cale> okay
18:35:25 <dejones> Cale: We can discuss more later... Sorry again!
18:35:37 <Cale> Not just performance. The problem is that arrays implemented the Haskell 98 way can end up allowing out of bounds accesses if you write bad instances of Ix
18:35:45 <dejones> Cale: you can email me if you wish... donnie@darthik.com  Cya
18:35:49 <Cale> okay
18:35:52 <BMeph> Cale: A lambda on a patch of tartan? ;)
18:35:59 <Cale> BMeph: hehe, yeah
18:36:18 <Cale> Or maybe made out of tartan :)
18:36:19 <Plouj> ok, never mind
18:36:25 <Plouj> this is too complicated
18:36:30 <Peaker> ghc -Wall is pretty insane
18:36:45 <Peaker> declare the types of all pattern elements explicitly?
18:37:02 <Cale> Oh, the University of Glasgow has its own tartan as well.
18:38:23 <unenough> After I learn Haskell, will i be able to go back to "regular" programming? or will I be to depressed to ever write another line of code in any other language?
18:38:34 <Zao> unenough: The latter.
18:38:39 <unenough> damn
18:38:46 <Cale> unenough: Well, depends on what you mean by "another language"
18:38:51 <Cale> hehe
18:39:15 <unenough> my boss won't like this at all
18:39:23 <Cale> Certainly most popular languages will seem a bit inflexible, unsafe and underpowered.
18:39:41 <unenough> they already seem like that
18:40:28 <Peaker> how do I declare a certain pattern is an error, explicitly:   itemAt [] _ = ?  (I am writing itemAt, to find item at a certain list index, for educational purposes)
18:40:29 <mofmo2> is there a way to generally extract the data wrapped inside a constructor?
18:40:51 <Peaker> mofmo2, pattern matching?
18:40:52 <Cale> Peaker: error "error in array index"
18:40:58 <Peaker> Cale, ah, thanks
18:40:58 <Cale> er, list index :)
18:41:02 <allbery_b> without knowing the constructor?  no
18:41:05 <Cale> Or whatever :)
18:41:16 <Peaker> Cale, is there an itemAt in the Prelude?
18:41:19 <monochrom> Someone did blog about how it's undesirable to be unable to go back.  "Haskell makes me unproductive because now I'm miserable at work..."
18:41:19 <mofmo2> cale: well, for some reason this doesnt work
18:41:39 <dons> Plouj: the issue is that your code built, but was unable to link against the C libraries, since they're stored in some non-standard location
18:41:39 <mauke> @hoogle [a] -> Int -> a
18:41:39 <lambdabot> Prelude.(!!) :: [a] -> Int -> a
18:41:39 <lambdabot> Data.List.(!!) :: [a] -> Int -> a
18:41:42 <mofmo2> ("ln", (\(  (Number x):xs) -> Number $ log x))
18:41:44 <dons> that's fixed by specifying the path
18:42:02 <mofmo2> it still thinks x is a CalcVal when it should now be a float
18:42:22 <Peaker> mauke, that's a pretty cool lambdabot feature :)
18:42:23 <mofmo2> data CalcVal = Number Float
18:42:46 <mauke> Peaker: http://haskell.org/hoogle/
18:42:46 <lambdabot> Title: Hoogle
18:43:34 <allbery_b> hm, I would expect that to work although I'd probably use a case expression instead
18:43:36 * SamB obtains an entire copy of the ZSNES repository
18:43:39 <allbery_b> (for readability)
18:44:03 <mofmo2> i just need log to work on the data inside the Number
18:44:06 <mofmo2> and then return a number
18:44:18 <mofmo2> would liftM work? even thouhg its nota  monad?
18:44:28 <Toxaris> mofmo2: no liftM works only with monads
18:44:37 <mofmo2> =/
18:44:46 <mofmo2> i had a general solution that only worked on numbers
18:44:48 <Toxaris> mofmo2: your code should work :)
18:44:53 <mofmo2> hmm
18:45:09 <mofmo2> Couldn't match expected type `Float'
18:45:09 <mofmo2>            against inferred type `CalcVal'
18:47:31 <Toxaris> mofmo2: i would add some type signatures to make sure that [CalcVal] -> CalcVal is indeed the type of the lambda function
18:47:49 <Toxaris> mofmo2: e.g. funcList :: [(String, [CalcVal] -> CalcVal)]
18:48:46 <Toxaris> mofmo2: adding type signatures for toplevel bindings sometimes helps to produces better error messages. type errors are "more local" this way, since they cannot "cross" top-level bindings by infering some valid, but unplanned type
18:50:09 <mofmo2> thanks
18:50:23 <mofmo2> i think this project has made me a lot more comfortable with haskell
18:50:36 <mofmo2> i'm still a bit wonky on combining monads
18:51:08 <mofmo2> in other news, my CALC program now has variables but no way of defining them yet
18:51:22 <mofmo2> i dont know if i should store the data of the variable in CALC code or as haskell data
18:51:44 <Peaker> I defined fib as:  fib@(1:tfib) = 0:1:[a+b|(a,b)<-zip fib tfib]    and then I call   (itemAt fib 0)  is failing with: test1.hs:5:4-47: Irrefutable pattern failed for pattern (fib@(1 : tfib))      how come?
18:51:58 <mauke> Peaker: 1 /= 0
18:52:05 <Peaker> oh whoops
18:52:08 <Peaker> why not a compile-time error?
18:52:21 <mofmo2> because GHC is smart
18:52:26 <mofmo2> sometimes i think GHC might be sentient
18:52:40 <mofmo2> it's like, "HOW DID IT KNOW?!?!"
18:52:57 <Peaker> mofmo2, why NOT a compile-time error?
18:53:05 <mauke> > let fib = 0 : 1 : zipWith (+) fib (tail fib) in fib !! 0
18:53:08 <tromp_> you can define it more easily using zipWith (+)
18:53:11 <lambdabot>  0
18:53:22 <scook0> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in take 10 fibs
18:53:23 <lambdabot>  [0,1,1,2,3,5,8,13,21,34]
18:53:51 <mauke> > let True = False in True
18:53:52 <lambdabot>  True
18:54:04 <TomMD> Peaker: If you think it should be, enter in a bug on trac and see what Igloo thinks.
18:54:14 <mauke> Peaker: let me try something
18:54:50 <Igloo> What's this? You want the above fib definition to give a compile time error?
18:54:52 <monochrom> The whole point of pattern matching is to try it at run time.
18:54:58 <Igloo> That's undecidable in general, if so
18:54:58 <mauke> oh, it said Irrefutable pattern
18:55:14 <solrize_> @hoogle (b -> (b,a)) -> b -> [a]
18:55:14 <lambdabot> No matches, try a more general search
18:55:17 <monochrom> And the whole point of programming is to leave something to run time.
18:55:22 <solrize_> @hoogle (b -> (a,b)) -> b -> [a]
18:55:22 <lambdabot> No matches, try a more general search
18:55:26 <mauke> what makes it irrefutable?
18:55:29 <solrize_> @hoogle (b -> Maybe (a,b)) -> b -> [a]
18:55:29 <lambdabot> Data.List.unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
18:56:08 <monochrom> Top-level pattern is as lazy as let.  let is equiv to "case ~(pattern) ..."
18:57:08 <Frederick> yo folks is there any ide you would point out to a starter in haskell?
18:57:24 <dmwit> vim/emacs are popular
18:57:27 <monochrom> IOW, IIUC, "x:xs = []" at top-level is irrefutable.
18:57:46 <Frederick> dmwit: but they dont properly auto-ident for me do they?
18:58:09 <scook0> you can't have complete auto-indent in haskell (with layout)
18:58:16 <scook0> the best you can get are suggestions
18:58:20 <dmwit> Frederick: In vim, :set autoindent is pretty good.  I've heard that emacs often offers several indentation suggestions on repeated presses of Tab
18:58:24 <dmwit> .
18:59:04 <monochrom> What you heard is true. I use it all the time.
19:00:23 <Frederick> emacs is evil :p
19:00:35 <dmwit> Agreed. =)
19:02:05 <Frederick>  iwill give a chance to emacs
19:02:12 <Frederick> usally for coding I use kdevelop :P
19:03:35 <Peaker> any hsdl user here?
19:11:17 * BMeph admires the contrapuntal harmony...of the crickets
19:11:56 * Cin looks up contrapuntal
19:16:32 <BMeph> @quote contrapuntal
19:16:32 <lambdabot> No quotes match. My brain just exploded
19:16:40 * BMeph boggles
19:21:07 <BMeph> @remember monochron  "Welcome to #haskell, where your questions are answered in contrapuntal fugues."
19:21:07 <lambdabot> Okay.
19:21:31 <Cin> musical words
19:21:38 <mauke> chron?
19:22:46 <Cin> it's like Tron but synCHronised, only one player can move a step on the grid at a time
19:26:43 <gwern> none of my questions have ever been answered in contrapuntal fugue!
19:27:00 <SamB> why is drdo banned?
19:27:11 <TomMD> Is there a reverse Maybe monad?  One such as: instance Monad Rmaybe where Rjust a >>= f = return a
19:27:30 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/6401
19:27:44 <TomMD> In other words: one that keeps the first result.
19:27:49 <dons> SamB: he's asking lots of people
19:27:57 <dons> SamB: grep the logs to find when it happened
19:28:12 <SamB> hmm, the ban is on *!*@*.net.novis.pt
19:28:19 <dons> urgh
19:28:25 --- mode: ChanServ set +o dons
19:28:37 <SamB> xerox did it
19:28:49 --- mode: dons set -b *!*@*.net.novis.pt
19:28:54 <dons> stupid
19:28:56 --- mode: ChanServ set -o dons
19:29:45 <wj7805> Hi #haskell.
19:29:58 <Cale> hello
19:30:33 <wj7805> I am trying to write a function to replace a given word in a string with another
19:31:03 <wj7805> And I am not sure how to traverse the string to identify which bit needs to be replaced
19:31:22 <mauke> pattern matching, recursion
19:31:46 <Cale> wj7805: Well, one thing you might look at using is the function tails.
19:31:47 <TomMD> > (\x -> map (\w -> if w == "word" then "notword" else w) words) "lala land food many word
19:31:47 <lambdabot>  Improperly terminated string at ""lala" (column 64)
19:31:53 <TomMD> damn
19:32:13 <wj7805> wow
19:32:23 <Cale> Oh, if you mean 'word' in the sense of 'whitespace-separated word', then yeah, words will be handy :)
19:32:23 <wj7805> is this channel an interpreter?
19:32:28 <Cale> yeah
19:32:28 <pjd> TomMD: Either?
19:32:33 <unenough> wj7805 lambdabot, is
19:32:40 <wj7805> That is awesome!
19:32:42 <Cale> In fact, it compiles a program for each expression you give it.
19:32:50 <TomMD> pjd: Humm... I considered Either but... hummm.. let me think why that wouldn't work.
19:32:53 <wj7805> hot damn, that is amazing.
19:33:05 <TomMD> Or perhaps would - thanks for the suggestions, pjd.
19:33:10 <unenough> wj7805, welcome to #haskell
19:33:27 <wj7805> Thanks :D
19:34:16 <dolio> TomMD: Rjust a >>= f = return a doesn't sound well typed at first glance.
19:35:46 <dolio> Unless the type of 'return a' is something like 'forall b. RMaybe b'.
19:35:50 <wj7805> Heh, this is so over my head.
19:36:39 <bjrn> Cale: I asked the other day about books on generating functions and someone (don't remember who) said I should ask you.
19:37:42 <Cale> bjrn: Um, well, the problem with all the books I've seen on the subject is that the books have the qualities {good, introductory, widely available}, pick any two.
19:37:51 <bpalmer> there was a free book on generating functions linked to from anarchaia within the past month, iirc
19:38:44 <dolio> Concrete Mathematics has a chapter on generating functions.
19:38:47 <Cale> A rather nice book, but not exactly one for the faint of heart is by David Jackson and Ian Goulden, and is called "Combinatorial Enumeration"
19:39:02 <dolio> Although, I don't know how in-depth it is.
19:39:23 <bpalmer> generatingfunctionology : http://www.math.upenn.edu/~wilf/DownldGF.html
19:39:23 <dolio> Or good, I suppose, as I'm not very familiar with the topic.
19:39:23 <lambdabot> Title: Download generatingfunctionology
19:39:23 <bjrn> Cheers, will check that out. I think bpalmer is talking about "generatingfunctionology", but other than the awkward title it didn't do it for me.
19:39:35 <Cale> It contains all the stuff you'll ever want to know, but it's not in the best order for learning. If you learn to skip to the beginning of the next section frequently, it actually wouldn't be so bad.
19:39:57 <Cale> Generatingfunctionology has the advantages of being introductory and widely available.
19:40:28 <Cale> I actually understand generating series quite well, and find myself utterly confused by it though.
19:40:28 <wj7805> What's the best book for a beginner? My school's using 'Haskell - The Craft of Functional Programming' and I am not too keen on it thus far.
19:40:45 <Cale> wj7805: Graham Hutton's new book is supposed to be very very good.
19:41:11 <wj7805> Programming in Haskell, Cambridge 2007?
19:41:33 <Cale> http://www.cs.nott.ac.uk/~gmh/book.html
19:41:35 <lambdabot> Title: Programming in Haskell
19:42:03 <wj7805> Hmmm, only 22 quid
19:42:07 <wj7805> on Amazon.co.uk
19:42:19 <lament> what's that amazing book that's supposed to be a practical approach?
19:42:19 <wj7805> Swuht.
19:42:19 <yitz> > words "here are some words"
19:42:20 <lambdabot>  ["here","are","some","words"]
19:42:44 <wj7805> hmmm, useful!
19:43:09 <yitz> :t words
19:43:10 <lambdabot> String -> [String]
19:43:58 <Cin> > unwords ["here","are","some","words"]
19:43:58 <lambdabot>  "here are some words"
19:44:50 <mofmo2> someone really needs to revise the haskell references
19:44:56 <mofmo2> sometihing akin to the python references
19:45:48 <newsham> you want mutable datastructures?
19:46:06 <tromp_> @check \s -> unwords (words s) == s
19:46:09 <lambdabot>  OK, passed 500 tests.
19:46:26 <TomMD> I would have ran for the hills if that failed.
19:46:36 <wj7805> lol
19:46:37 <tromp_> it shld fail
19:46:41 <johnnowak> newsham: i think he means the reference documentation
19:46:50 <newsham> oh
19:47:06 <wj7805> \x -> map
19:47:08 <dolio> > unwords (words "foo     bar       baz        quux")
19:47:08 <lambdabot>  "foo bar baz quux"
19:47:09 <newsham> *phew*
19:47:09 <wj7805> what does that do?
19:47:10 <TomMD> tromp_: I suppose you are right - words will kill the whitespace while unwords just uses space - right?
19:47:22 <TomMD> Yes, I see.
19:47:23 <tromp_> right
19:48:36 <tromp_> @check \s -> words (unwords ss) == ss
19:48:37 <lambdabot>   Not in scope: `ss'
19:48:42 <tromp_> @check \ss -> words (unwords ss) == ss
19:48:43 <lambdabot>  Falsifiable, after 0 tests: ["",""]
19:48:47 <wj7805> \x -> map                         <---- what does this do?
19:49:05 <pjd> wj7805: const map
19:49:11 <pjd> :t const map
19:49:12 <lambdabot> forall a b b1. b1 -> (a -> b) -> [a] -> [b]
19:49:17 <newsham> > let f x = map in f 3 (+1) [1,2,3]
19:49:18 <lambdabot>  [2,3,4]
19:49:22 <tromp_> @check \s -> words (unwords ss) == ss
19:49:23 <lambdabot>   Not in scope: `ss'
19:49:25 <TomMD> wj7805: First learn what 'map' does, then worry about (\x -> ...)
19:49:32 <TomMD> @src map
19:49:32 <lambdabot> map _ []     = []
19:49:32 <lambdabot> map f (x:xs) = f x : map f xs
19:49:34 <tromp_> @check \s -> unwords (words s) == s
19:49:34 <lambdabot>  OK, passed 500 tests.
19:49:37 <tromp_> @check \s -> unwords (words s) == s
19:49:37 <lambdabot>  OK, passed 500 tests.
19:49:38 <newsham> > (\x -> map) 3 (+1) [1,2,3]
19:49:39 <lambdabot>  [2,3,4]
19:49:54 <newsham> > (const map) 3 (+1) [1,2,3]
19:49:55 <lambdabot>  [2,3,4]
19:50:12 <newsham> ?src const
19:50:12 <lambdabot> const x _ = x
19:50:16 <TomMD> > map ("This " ++) ["house", "person", "thing","chat"]
19:50:16 <lambdabot>  ["This house","This person","This thing","This chat"]
19:50:54 <newsham> > unwords . map ("This " ++) . words $ "house person thing chat"
19:50:54 <lambdabot>  "This house This person This thing This chat"
19:50:59 <gnuvince_> :t const
19:51:00 <lambdabot> forall a b. a -> b -> a
19:52:05 <newsham> > let withWords f = unwords.f.words in withWords (map ("This " ++)) "house person thing chat"
19:52:05 <lambdabot>  "This house This person This thing This chat"
19:52:38 <TomMD> > unwords . map (++ " is great!") . map ("This " ++) . words $ "house person thing chat"
19:52:38 <lambdabot>  "This house is great! This person is great! This thing is great! This chat i...
19:53:16 <newsham> ?let withWords f = unwords.f.words
19:53:17 <lambdabot> Defined.
19:53:17 <SamB> dons: you use every piece of softare on that stack????
19:53:31 <araujo> hi
19:53:35 <wj7805> hi
19:53:40 <araujo> someone can get lambdabot joining #haskell.es ?
19:53:44 <Cale> sure
19:53:46 <newsham> > withWords (map (\x -> "This " ++ x ++ " is greaT!")) "house person thing chat"
19:53:47 <lambdabot>  "This house is greaT! This person is greaT! This thing is greaT! This chat i...
19:53:53 <TomMD> wj7805: Have the examples confused you enough yet?
19:53:55 <dons> SamB: do you use too many question marks????
19:54:01 <wj7805> TomMD: YES
19:54:14 <SamB> dons: there is a LOT of software on that stack!
19:54:23 <araujo> Cale, good :-)
19:54:24 <mofmo2> oh damn
19:54:26 <mofmo2> DAMN
19:54:33 <mofmo2> haskell is purely functional >_<
19:54:38 <TomMD> wj7805: 'map' will simply apply a function to each element in a list, producing the new list.
19:54:39 <wj7805> TomMD: This is like my 3rd day programming in Haskell...
19:54:43 <wj7805> Ah
19:54:46 <mofmo2> ok that means major rewrite time... *sigh*
19:54:46 <SamB> mofmo2: isn't that nice?
19:54:49 <newsham> as opposed to some languages which are barely functional
19:54:51 <Cale> ah, I see, I should probably have been running online2.rc :)
19:54:56 <TomMD> wj7805: map f [x,y,y] == [f x, f y, f z]
19:55:01 <SamB> mofmo2: what did you do?
19:55:04 <mofmo2> i just wish there was a set! hack right now
19:55:09 <mofmo2> i have a list of functions
19:55:10 <TomMD> wj7805: map f [x,y,z] == [f x, f y, f z] -- sorry for the typo above.
19:55:12 <newsham> > map f [1,2,3]
19:55:12 <lambdabot>  Add a type signature
19:55:13 <mofmo2> and i need to append to it
19:55:18 <Cale> mofmo2: ++
19:55:23 <newsham> > map f [1,2,3] :: [Int]
19:55:23 <lambdabot>        add an instance declaration for (SimpleReflect.FromExpr Int)
19:55:38 <SamB> mofmo2: State monad time!
19:55:39 <mofmo2> Cale: I need destructively change it
19:56:14 <dobblego> mofmo2, no you don't
19:56:17 <newsham> "hi, I just learned haskell, i wish there was a set! hack."  "use the state monad" hilarity :)
19:56:20 <Cale> mofmo2: That would be extremely confusing.
19:56:30 <dobblego> mofmo2, why do you think you do?
19:56:31 <pjd> mofmo2: what do you actually need to do?
19:56:40 <TomMD> wj7805: so that covers 'map'.  For example the "map ("This " ++) ["house", "car"], was just the FUNCTION prepending the string "This " onto each element of the list.
19:56:49 <SamB> what he's saying, I believe, is that he's painted himself into a corner where he would have liked to have a set! hack available
19:57:01 <Cale> mofmo2: You can't even *really* rely on Haskell being evaluated outermost first, as the compiler might decide that things should be evaluated in some other order as it sees fit.
19:57:06 <SamB> but knows he can't, and will just have to rewrite his program to be nice
19:57:08 <newsham> btw, there are languages kinda similar to haskell that allow "set!" type operations, like ocaml.
19:57:14 <mofmo2> CAle: that's why i said
19:57:17 <Cale> mofmo2: right
19:57:18 <mofmo2> "NOOO ITS PURELY FUNCTIONAL!!"
19:57:24 <newsham> but haskell will help you purify your thoughts :)
19:57:44 <dobblego> mofmo2, you want that; why do you think you don't?
19:57:59 <Cale> mofmo2: You can generally translate stateful computations into stateless ones which take an extra parameter (the initial state), and return an extra value as part of their result (the final state)
19:58:07 <mofmo2> of course
19:58:09 <mofmo2> a monad
19:58:10 <SamB> mofmo2: I hate it when I do that too ;-)
19:58:12 <TomMD> wj7805: And the dot "." as in: map ("This " ++) . words $ "house car" is just function composition.  so (f . g) x == f (g (x))
19:58:12 <mofmo2> but theni have to integrate that
19:58:21 <Cale> The state monad handles that for you, sure.
19:58:26 <bjrn> Someone who have never programmed before should probably get SICP then learn Haskell later, but that's sort of blasphemy in here i guess. :)
19:58:26 <SamB> painting oneself into a corner is never much fun
19:58:26 <mofmo2> ok i have a repl that is IO ()
19:58:35 <Cale> But I'm just saying even without a monad.
19:58:49 <mofmo2> hmm but my repl calls itself and it uses the IO monad
19:58:52 <mofmo2> sooooo
19:58:55 <SamB> StateT
19:59:02 <SamB> that will actually make things easier
19:59:04 <TomMD> wj7805: And don't worry about '$' it is just a low precidence infix identity function.  In plain english: $ is a replacement for parens ( ).  f $ g x == f (g x)
19:59:05 <SamB> believe it or not
19:59:09 <newsham> mofo: you can pass it the updated state each time
19:59:15 <Cale> uhh...
19:59:31 <wj7805> TomMD:
19:59:33 <newsham> (each time it calls itself)
19:59:35 <wj7805> lol
19:59:36 <SamB> now all you have to do is add liftIO in front of your IO things
19:59:42 <TomMD> :-)
19:59:45 <mofmo2> i see
19:59:50 <mofmo2> so let me try this out then
19:59:51 <Cale> So presumably the language that your repl is evaluating has some state which needs updating?
19:59:58 <SamB> and use the state monad to store the list of functions
19:59:58 <mofmo2> yes
20:00:05 <Cale> mofmo2: How much state?
20:00:16 <mofmo2> it has no support for local variables
20:00:18 <newsham> eval expr st = ....  eval subexpr updatedst ....
20:00:19 <Cale> Just a dictionary of bindings, or the whole world, or something in between?
20:00:19 <wj7805> TomMD: "low precedence infix identify function" is a great phrase to spring on newbs :)
20:00:24 <mofmo2> so not a whole environment model going on
20:00:39 <mofmo2> it's like cobol ^_^
20:00:44 <mofmo2> (in terms of state)
20:01:05 <roconnor> Should I watch that SPJ video on type-driven testing?
20:01:06 <Cale> Okay, well, you should be able to keep that state in some datastructure, and simply have it be a parameter to the REPL.
20:01:20 <TomMD> wj7805: Sorry.  I blame all the other people here on #haskell for making me talk that way.  Just think of it as parens:  putStrLn $ "some string" ++ var ++ "other string"
20:01:23 <Cale> (so when the REPL recurses, it passes the new value of that state along)
20:01:37 <mofmo2> Cale: i tried that at first, and it spat out something about it not working with the IO monad
20:01:40 <TomMD> wj7805: is just like: putStrLn ("some string" ++ var ++ "other string")
20:01:44 <Cale> mofmo2: hmm...
20:01:49 <mofmo2> lemme trty again
20:01:49 <Cale> mofmo2: Can I see?
20:01:52 <mofmo2> sure
20:01:52 <newsham> mofo: can you be more specific about the error?
20:01:54 <Cale> oh, okay
20:02:01 <newsham> familiar with hpaste?
20:02:06 <Cale> @hpaste
20:02:06 <lambdabot> Haskell pastebin: http://hpaste.org/new
20:02:18 <warmenhoven> in the STM monad, what happens if i 'retry' without first reading any TVars?
20:02:21 <wj7805> TomMD: OK, gotcha. I sorta understood if, it's just my mind sort of looked at that phrase and fight-or-flight kicked in :D
20:02:31 <wj7805> understood it**
20:03:03 <mofmo2> ok actually
20:03:08 <roconnor> warmenhoven: I was asking about the earlier
20:03:16 <mofmo2> i need to refactor in the state thing
20:03:19 <mofmo2> lemme just paste what i have
20:03:24 <Cale> d'oh :)
20:03:24 <roconnor> warmenhoven: one conjecture was that the thread is killed, but I don't know for sure.
20:03:46 <warmenhoven> roconnor: i guess i'll just have to try it then. thanks :)
20:03:56 <hpaste>  mofmog pasted "(no title)" at http://hpaste.org/6402
20:04:01 <mofmo2> let's just see if itll work
20:04:34 <mofmo2> lots of hacks involved but i'm just working towards having variables
20:04:43 <mofmo2> and afterwards non primitive functions
20:05:12 <TomMD> wj7805: Well, I'm going afk - other people here are usually more helpful than me anyway but i hope to see you around.  Enjoy Haskell and stick with it!
20:05:21 <wj7805> Thanks TomMD.
20:05:23 <SamB> jhc needs a logo
20:05:34 <SamB> what would a good logo for jhc be...
20:05:40 <dobblego> "working towards having variables"?
20:05:43 <SamB> some E code?
20:05:49 <mofmo2> dobblego: it's an interpreter
20:05:55 <newsham> mofo: and what was the error?
20:06:01 <mofmo2> none yet
20:06:18 <mofmo2> the problem as it is however is having to pass the funcList and symbList through the repl
20:06:20 <mofmo2> and thread it about
20:06:33 <mofmo2> so i was thinking that might cause trouble because repl is a function that works on monads
20:06:49 <newsham> thats not a problem you can make repl take extra args and still use the IO monad
20:07:03 <dons> or run it in StateT Foo IO a
20:07:06 <newsham> repl st = do ....   do putStrLn "Version 0.5"; repl st
20:07:11 <SamB> dons: that's what I said!
20:07:22 <mofmo2> yeah, i have to thread it into eval too
20:07:27 <mofmo2> hmm
20:07:31 <mofmo2> wait
20:07:31 <newsham> yes, StateT Foo IO a would be nice here, but he's just starting off in haskell
20:07:42 <qwr> mofmo2: or you can use IORef's?
20:07:46 <SamB> well, he could get adventurous
20:08:10 <yitz> qwr: sshhh
20:08:12 <Cale> I recommend just passing the state by hand.
20:08:16 <mofmo2> hmm, i dont think threading could work
20:08:21 <mofmo2> it has to go into eval
20:08:26 <mofmo2> and then it'd have to somehow get back out?
20:08:36 <Cale> Once you're comfortable doing that, then StateT and friends will make more sense anyway :)
20:08:48 <mofmo2> unless somehow haskell has dynamic scoping
20:08:55 <SamB> hahahaha
20:08:56 <mofmo2> that somehow works that way
20:09:06 <araujo> Cale, Thanks!
20:09:07 <Riastradh> Implicit parameters?
20:09:11 <SamB> that would be really damn confusing
20:09:12 <newsham> mofmo: yah, if eval alters the state it will need to take the state as a param and return a new state as a result
20:09:13 <Cale> araujo: no problem!
20:09:19 <araujo> :-)
20:10:26 <dons> yeah, learn to thread state first, then abstract out that plumbing with a state monad
20:10:32 <mofmo2> newsham ahhhhhh
20:14:13 <mofmo2> alright now i'm making eval return a tuple
20:15:49 <newsham> btw, if you have statements that can modify state and expresions that cant, it might make sense to separate them out so that eval expr doesnt need to return a new state but run stmt does
20:17:21 <bos> is there a debian package of 6.8 yet?
20:18:00 <solrize_> i looked for one a couple nights ago and there wasn't
20:18:05 <solrize_> but the source tarball worked fine
20:18:14 <solrize_> compiling from 6.4
20:18:31 <solrize_> and the 6.8.2 tarball binary worked ok on a fedora box i installed it on
20:18:52 <bos> fedora already has 6.8.2, so i'm not worried about that.
20:22:00 <Japsu> err, yes there is
20:22:05 <dons> pretty sure debian has 6.8.2
20:22:07 <Japsu> a debian package for 6.8.2, that is
20:22:09 <Japsu> in unstable
20:22:12 <Japsu> testing has 6.6
20:22:21 <Japsu> dunno about stable, but nobody uses it anyway
20:22:39 <dons> but its *so* stable!
20:22:59 <dons> such a fine line between stable and bitrotted. hmm
20:23:58 <bos> should i be running testing instead of etch, then?
20:24:03 <bos> or is testing etch?
20:24:15 * bos is new to the world of caring about bleeding-edge debian
20:24:25 <Igloo> The point of stable is that things /don't/ bitrot, e.g. in stable gcc isn't upgraded, so a new gcc can't break ghc
20:24:33 <newsham> bos: have some apathy.  i have some extra.
20:24:58 <bos> so Igloo - what's your sage advice, then? :)
20:25:58 <Igloo> If you really need the latest and greatest ghc, then tarball is probably the easiest way
20:27:13 <Japsu> I have Debian testing with select packages from unstable on my Debian virtual server
20:27:22 <kbateman> I have gentoo, with the newest ghc being 6.6.1, and I installed the 6.8.2 tarball under my home dir
20:27:38 <mofmo2> alright eval returns a 3-tuple
20:29:18 <solrize_> is it ok to put more than one module in a .hs file?  i want to lower the namespace pollution between functions
20:29:29 <bos> no, ghc won't accept it.
20:29:44 <solrize_> hmm ok thx
20:29:55 <kbateman> Ocaml can do more than one module per file, but I don't think Haskell can.
20:30:32 <bos> the spec allow it, but ghc doesn't.
20:30:39 <solrize_> ic
20:31:00 <kbateman> The Haskell 98 report allows it?
20:31:19 <solrize_> kbateman i asked about it because i thought i saw it somewhere but in the wikibook it says 1 module per file
20:31:27 <bos> it says nothing about it, so it's implicitly legal.
20:31:42 <solrize_> i dunno how you'd import anyway
20:32:00 <solrize_> haskell seems a little bit painted into a corner
20:32:08 <bos> hardly.
20:32:54 <solrize_> b/c of this namespace stuff, apparently more namespaces doesn't play well with type inference, so that's why there are no record types
20:34:09 <warmenhoven> roconnor: i have a partial answer, if you're still interested
20:34:16 <roconnor> warmenhoven: ok
20:34:26 <solrize_> bos you've done a lot of python, do you find you can do stuff in haskell as easily after a while?
20:34:49 <bos> solrize_: mostly, yes.
20:34:55 <solrize_> cool
20:34:57 <warmenhoven> roconnor: so the program i wrote up doesn't just do forkIO (atomically (retry)), because that's sort of pathological
20:35:19 <bos> solrize_: python has more convenient string handling, which hurts :-)
20:36:01 <warmenhoven> roconnor: instead it uses orElse and an array of TVar Bools, so that it has the potential of eventually not retrying
20:36:36 <bos> solrize_: fwiw, another book author, CosmicRay, used to be a major python hacker and switched
20:36:56 <solrize_> yeah, python just seems kind of juvenile now
20:37:28 <warmenhoven> roconnor: the program worked like you'd expect. while the [TVar Bool] was empty, it has nothing to read, so it calls 'retry' immediately and just waits on the `orElse` condition.
20:38:02 <warmenhoven> roconnor: once the array had something in it, it read the TVars properly. the thread certainly didn't just exit.
20:38:16 <solrize_> it has more library functions and is better documented but those things are fixable
20:39:09 <solrize_> bos are you going to discuss happs in the book?
20:39:10 <kbateman> Languages like python and tcl are flexible, but it seems like they lack a kind of integrity.
20:39:15 <bos> solrize_: no
20:39:38 <solrize_> kbateman python seems even looser than lisp
20:41:19 <kbateman> I used to really like lisp, until I ran across the function (I can't remember the name) that modifies a list
20:41:25 <roconnor> warmenhoven: I guess I didn't quite follow that.
20:41:38 <thermoplyae> i choked on lisp when i saw (tagbody)
20:41:39 <bos> nconc
20:41:42 <solrize_> kbateman there are a lot of those
20:41:45 <solrize_> nconc
20:41:50 <FMota> I get the impression that a lot of Haskell people are or were at some point Python people.
20:41:50 <solrize_> nreverse
20:41:57 <solrize_> anything starting with n
20:42:08 <solrize_> there are some pure lisp dialects
20:42:20 <solrize_> i was going to use hedgehog in an embedded project, but the project got cancelled
20:42:21 <pjd> FMota: they're both tasteful languages
20:42:34 <FMota> pjd: I agree. :-)
20:42:48 <kbateman> Now that I'm used to Hindley-Milner, I really don't like the fact that Lisp doesn't enforce type correctness.
20:42:52 <solrize_> i wonder if there's similar scheme to haskell migration
20:43:27 * EvilTerran schemed briefly a couple of years ago
20:43:27 <thermoplyae> typing macros correctly sounds hard
20:43:44 <warmenhoven> roconnor: http://www.warmenhoven.org/src/Retry.hs
20:44:04 <solrize_> haskell fixes most of the python shortcomings i used to whine about
20:44:50 <warmenhoven> roconnor: sorry for the lack of comments
20:45:02 <solrize_> i'm doing a lot of head scratching to do even simple things so far, but am figuring that's the notorious .hs learning curve
20:46:51 <solrize_> ghc is dog slow
20:46:59 <kbateman> @pl (\y -> you y off)
20:46:59 <lambdabot> flip you off
20:47:07 <solrize_> kbateman :)
20:47:30 <FMota> thermoplyae: I think to make macros work you'd just need the type [Code] -> IO Code (or something similar) and then typecheck its result.
20:47:30 <kbateman> not mine :).  from http://shae.livejournal.com/26364.html
20:47:30 <lambdabot> Title: shae: random #haskell quotes
20:47:39 <solrize_> hmm i get a ton of compiler warnings from the crypto cabal build process
20:48:38 <FMota> I don't think you could make further typechecking (to make sure the macros are capable of correct code) without dependent types, and it'd prolly be really inefficient.
20:49:02 <solrize_> can't you just do all the macro expansion then run the normal typechecker?
20:49:05 <thermoplyae> that seems like it has holes.  then again, macros are supposed to be taken care of at compile time, so it's not like typing errors would lurk at runtime
20:49:09 <solrize_> or do you mean the macros themselves should have typed args ?
20:49:33 <gwern> FMota: isn't MetaML have a staged typesafe architecture for macros?
20:49:38 <thermoplyae> ideally the macros would have typed args, but yeah, i can't think of a smarter way to do it than dependent types, and that would certainly be both hard and slow
20:50:06 <FMota> gwern: No idea.
20:50:20 <thermoplyae> gwern: i looked into various macro-supporting MLs, and they all limit what macros can do.  one of the looser ones i found allowed 'generating macros', where the code passed into the macro was black-box
20:50:36 <thermoplyae> and if you can't modify or destructure the arguments, then typing is pretty easy
20:50:50 * gwern struggles to avoid sarcastically pointing out how static typing is limiting too
20:51:33 <thermoplyae> that's sort of equivocation though :)
20:51:48 <FMota> Static typing involves a little more thought and a little more typing than dynamic typing, I'd say.
20:51:57 <mofmo2> OK THREADING THIS BY HAND IS GETTING ON MY NERVES
20:52:01 <mofmo2> how do i use StateT?
20:52:03 <mofmo2> HOW?
20:52:15 <mofmo2> actually dont answer that, i'm going to play video games instead
20:52:28 * solrize_ launches StateT Invaders
20:52:53 <BMeph> kbateman: Ah, a shapr-ism. :)
20:52:53 <FMota> :o Haskell is hard. Video games are easy.
20:53:07 <FMota> Someone should make a haskell video game!
20:53:17 <FMota> QED.
20:53:29 <gnuvince_> Haskell is hard. Let's go shopping!</consultant_barbie>
20:53:30 <johnnowak> solrize: ML is the simpler Scheme -> Haskell migration. liskell might help too.
20:53:36 <kbateman> Just come up with the right type, and @djinn will write it for you.
20:54:00 <FMota> @djinn x -> x
20:54:01 <lambdabot> f a = a
20:54:22 <gwern> FMota: what would you like? I have Frag, Monadius, Hetris, Mage... I haven't put roguestar on hackage yet, sry
20:54:29 <FMota> @djinn (a -> b -> c) -> (a -> b) -> a -> c
20:54:29 <lambdabot> f a b c = a c (b c)
20:54:52 <solrize_> ocaml is even uglier than standard ml but seems to have the fastest compiler and more useful code
20:55:01 <johnnowak> solrize: what's so ugly about it?
20:55:04 <gwern> nor did I put worm, connect 4, or paratrooper up on hackage yet either because of license issues
20:55:08 <solrize_> the surface syntax
20:55:10 <roconnor> @djinn ((((a -> b) -> a) -> a) -> b) -> b
20:55:10 <lambdabot> f a = a (\ b -> b (\ c -> a (\ _ -> c)))
20:55:14 <FMota> interesting, gwern. Though I mean a game where you learn Haskell. *shrug*
20:55:16 <johnnowak> solrize: .. what's so ugly about that?
20:55:20 <gwern> johnnowak: the lack of type classes is a pain
20:55:24 <solrize_> lots of keyword noise
20:55:28 <solrize_> 3.0 +. 4.0
20:55:36 <gwern> johnnowak: because everyone wants to write .+ instead of + or whatever!
20:55:48 <johnnowak> that's not really "lots of keyword noise"
20:56:13 <johnnowak> gwern: lack of functors is a pain
20:56:41 <thermoplyae> i would trade functors for type classes any day in ocaml :(
20:56:54 <solrize_> well i have the idea that i want to code in ocaml sometime but if i start using it first, i'd never figure out haskell; but if i can get a grip on haskell then ml will be easy by comparison ;)
20:56:55 <kbateman> Functions of type () -> () always seemed suspicious to me.
20:57:09 <solrize_> there's a theorem that ml functors and haskell type classes are equivalent
20:57:21 <thermoplyae> they're not equivalent in syntax
20:57:23 <johnnowak> solrize_: it strikes me as a fairly useless theorem
20:57:27 <gwern> I have faith that if functors are useful, haskell will get them
20:57:53 <solrize_> or ml modules rather, was it.
20:58:00 <johnnowak> http://www.cse.unsw.edu.au/~chak/papers/DHC07.html
20:58:00 <lambdabot> Title: Research Papers of Manuel Chakravarty
20:58:10 <johnnowak> er.. that's "Modular Type Classes"
20:58:13 <FMota> kbateman, are you afraid of:  win = unsafePerformIO takeOverTheWorld `seq` ()
20:58:16 <BMeph> @pl (\x y -> ninjas (out y x))
20:58:16 <lambdabot> (ninjas .) . flip out
20:58:23 <FMota> er,* win _ = ...
20:58:31 <solrize_> johnnowak i think that may be hte paper i'm remembering
20:58:33 <FMota> w/e
20:58:41 <johnnowak> solrize_: it isn't
20:58:48 <solrize_> hmm
20:59:05 <johnnowak> you're thinking of http://www.cse.unsw.edu.au/~chak/papers/WC06.html
20:59:06 <lambdabot> Title: Research Papers of Manuel Chakravarty
20:59:08 <solrize_> you're right the one i'm tihnking of showed a 2-way transformation
20:59:16 <kbateman> FMota:  some.  There are a few land mines like that in Haskell.
20:59:19 <solrize_> yeah that's the one
21:00:16 <roconnor> @djinn () -> ()
21:00:16 <lambdabot> f a = a
21:00:34 <kbateman> Java's designed to run untrusted code in a limited fashion, but I think Haskell programs have to trust everything they include and import.
21:00:46 <FMota> okay guys
21:00:48 <johnnowak> @djinn a -> (a, b) -> (a -> c) -> c
21:00:48 <lambdabot> f a _ b = b a
21:00:58 <FMota> I want a simple project so that I may learn a bit of haskell.
21:01:05 <FMota> What do you guys recommend?
21:01:13 <kbateman> FMota: cat
21:01:21 <kbateman> with all the options
21:01:24 <QtPlatypus> kbateman: Not quite, you can use monadic methods to limmit the dammige that untrusted code can do.  Sort of like what lambda bot does here.
21:01:26 <johnnowak> or maybe http://cat-language.com
21:01:26 <lambdabot> Title: The Cat Programming Language
21:01:47 <kbateman> QtPlatypus:  except when the code uses unsafePerformIO.
21:01:57 <petekaz> If I a guard throws an exception, 'head' on an empty list, does it just fall thru to the 'otherwise'?  Or does it bounce out all together with the exception?
21:02:08 <FMota> hah johnnowak. Thanks kbateman, I'll try that.
21:02:20 <Excedrin> the latter
21:02:22 <Notostraca> how the heck am I supposed to install cabal-install...?
21:02:29 * johnnowak wasn't joking
21:03:00 <Notostraca> it seems to require all these dependencies that should really...be automated...sniffle sniff
21:03:46 <Notostraca> I guess I should take the coward's way and ask for a binary
21:05:08 <petekaz> Excedrin: thanks.
21:05:45 <kbateman> petekaz:  it does an error.
21:05:47 <roconnor> Notostraca:  one day it will work
21:06:00 <kbateman> meaning Prelude.error
21:06:21 <gwern> :( My editing of Mage to use hscurses is not going well at all. mage has a pretty darn sophisticated curses binding
21:06:31 <Notostraca> one day after all of mankind is dead and apes rule the world once more?
21:06:46 <wj7805> Hi #haskell. What does       replace [] _ _ = []       do?
21:07:02 <roconnor>  replace
21:07:07 <roconnor> @hoogle replace
21:07:07 <lambdabot> Data.Array.Diff.replaceDiffArray :: (MArray a e IO, Ix i) => IOToDiffArray a i e -> [(Int, e)] -> IO (IOToDiffArray a i e)
21:07:07 <lambdabot> System.FilePath.Windows.replaceExtension :: FilePath -> String -> FilePath
21:07:07 <lambdabot> System.FilePath.Windows.replaceFileName :: FilePath -> String -> FilePath
21:07:28 <gwern> replace :: [a] -> b -> c -> [a]... hm doesn't seem very useful
21:07:29 <araujo> wj7805, a function taking 3 arguments , and if the first one is the empty list, it omits the rest of the args and returns the empty list
21:07:31 <roconnor> I don't think replace is a standard function
21:07:33 <johnnowak> wj7805: that looks like part of a function definition. is that all there is?
21:07:37 <gwern> @pl  replace [] _ _ = []
21:07:37 <lambdabot> (line 1, column 12):
21:07:37 <lambdabot> unexpected "_"
21:07:37 <lambdabot> expecting variable, "(", operator or end of input
21:07:44 <Notostraca> gwern: you mean ncurses is sophisticated?
21:07:56 <wj7805> nah, it is part of a bigger thing
21:07:59 <roconnor> wj7805: oh,... it is part of a function definition
21:08:08 <wj7805> replace :: String -> String -> String -> String
21:08:08 <wj7805> replace [] _ _ = []
21:08:08 <wj7805> replace haystack needle ocelot =
21:08:08 <wj7805>     if take (length needle) haystack == needle
21:08:08 <wj7805>         then ocelot ++ (replace (drop (length needle) haystack) needle ocelot)
21:08:09 <wj7805>         else [head haystack] ++ (replace (tail haystack) needle ocelot)
21:08:09 <gwern> Notostraca: not really. ncurses strikes me as crude and too low-level
21:08:14 <roconnor> it says that if the first argument is the empty list, ignore the other arguments and return the empty list.
21:08:20 <johnnowak> well then that's just one case of it that says what to do if you call replace with a null list as the first argument
21:08:30 <wj7805> ah
21:08:31 <wj7805> i see
21:08:40 <gwern> Notostraca: it's just that mage has a whole hierarchy of types and stuff built on top, and I'm finding it difficult integrating mage's tower of abstraction with hscurses
21:08:44 <johnnowak> although.. how is that ... String -> String -> String -> String ?
21:08:50 <johnnowak> oh, nevermind
21:08:53 <wj7805> huh?
21:09:11 <scook0> gwern: is there any particular reason why you're trying to migrate it to hscurses?
21:09:15 <wj7805> that's how I've been taught... types of inputs then output..
21:09:32 <johnnowak> i wonder if anyone on irc knows what nevermind means
21:09:50 <Notostraca> an incredible dungeon far above the clouds of imperativity: the mage's tower of abstraction!
21:09:50 <kbateman> @hoogle nevermind
21:09:50 <lambdabot> No matches found
21:09:55 <johnnowak> i knew it!
21:10:09 <wj7805> it's the good nirvana album
21:10:26 <warmenhoven> wj7805: it's the slick nirvana album. they had much better.
21:10:38 <gwern> scook0: to improve hscurses; to centralize effort around a single ncurses binding; because I already did the same thing for hetris
21:10:45 <scook0> (fwiw, I have my own not-yet-released curses binding)
21:10:47 <gwern> @wn nevermind
21:10:48 <lambdabot> No match for "nevermind".
21:11:00 <scook0> because I wasn't happy with hscurses :)
21:11:00 <gwern> never mind then
21:11:08 <wj7805> warmenhoven: really? what ones are better? nevermind is all I have.
21:11:18 <gwern> scook0: oh good grief. how far along is it? and why didn't you hack on hscurses?
21:11:51 <gwern> (no wonder haskellers never seem to get anywhere, we keep forking and abandoning stuff)
21:11:51 <scook0> a few different reasons
21:12:17 <scook0> e.g. I've paid particular attention to wide-char support
21:12:28 <nolrai_> why arnt type varibles declared in a type declaraions avalible in the definition?
21:12:32 <scook0> and I wanted the freedom to undo some of hscurses' design decisions
21:12:43 <Notostraca> Haskellers never seem to get anywhere because it is too freakin hard to become a Haskeller
21:12:54 <warmenhoven> wj7805: depends on what style you like. bleach is much harsher, as is incesticide. in utero is pretty popular; it has a lot of songs i'm sure you've heard. unplugged is whiny.
21:14:32 <scook0> gwern: it supports quite a few functions ... the main reason I haven't packaged it is that I wanted to dogfood it a bit first
21:14:59 <scook0> (also, it was a nice way to get some real FFI experience)
21:15:36 * gwern sighs. I can't really stop you, but I wish you had worked on hscurses instead
21:15:42 <kbateman> gwern:  We aren't abandoning anything.  We're just accomplishing our work non-strictly. :)
21:16:27 <kbateman> nolrai_: Are you having a problem with typing?
21:16:50 <gwern> kbateman: it's call by need but when other people need it, we evaluate to bottom...
21:17:32 <gwern> jesus. I give up on this; my work on merging mage and hscurses is a bust. too hard for me
21:17:44 <gwern> I suppose there are worse ways to spend a day
21:18:11 <kbateman> That which does not kill you makes you stronger.
21:22:34 <whee> Anyone have advice for gathering (mostly unrelated) data from a large list? I want to avoid iterating over the list more than once
21:23:40 <gwern> whee: you'll need to be more specific than that
21:24:05 <kbateman> Make it not a list.
21:24:30 <pjd> whee: you can collect the result of multiple functions while folding, or whatever
21:24:41 <whee> gwern: I have a list of records and I want to do things such as gather unique values of one of the fields, average another field, etc
21:25:10 <nolrai_> kbaterman?
21:25:42 <gwern> whee: try to define your needs more algorithmically. do you want cheap random access to any member of a list? do you want cheap iteration backwards and forwards? and so on
21:25:50 <kbateman> Make worker functions of Rec -> IO (), pass each record to each function
21:26:05 <kbateman> or Rec -> ST ()
21:26:17 <nolrai_> typeing as in keybords or typeing as in types?
21:26:18 <kbateman> nolrai_ ?
21:26:25 <pjd> fold (\x -> (f x, g x, h x)) (fnil, gnil, hnil)
21:26:33 <kbateman> I meant with types.
21:26:38 <nolrai_> Yes
21:26:57 <whee> pjd: that's probably the easiest way for what I need
21:26:58 <pjd> err, except with the right argument to the lambda
21:27:11 <pjd> s/argument/parameter list/
21:28:24 <pjd> whee: you should check that it actually makes things faster, though
21:28:47 <kbateman> mapM_ (mapM_ ($) actions) list
21:29:02 <kbateman> wait that doesn't work
21:29:32 <kbateman> nolrai_ : ask away
21:29:40 <gwern> mapM on a mapM would seem to require nested lists
21:36:12 <nolrai_> well i was trying to track down the types by using type anotations, but it wasnt letting me use the type varibles i had used in the anotation for the top, it would ether give me an error about it being an undefined type varible or shadow the top one. this was very anoying
21:42:03 <nolrai_> thats a bit long oops
21:44:06 <kbateman> I have that problem when I try to allocate STArrays of a class, and not a specific type.
21:44:51 <kbateman> There is a trick you can do:  sametype :: a -> a -> b; sametype = undefined
21:46:08 <kbateman> If you have "sametype x y" in a where clause somewhere, then that will make sure x and y have the same type.
21:46:23 <nolrai_> thats clever!
21:46:37 <mauke> or you could use scoped type variables
21:46:39 <kbateman> It's regrettably hackish.
21:46:49 <mauke> or ... where _ = [x, y]
21:47:00 <kbateman> Yeah, that's the same.
21:47:21 <nolrai_> mauke: scoped type varibles?
21:47:36 <cdsmithus> How in the world does one get a Source in the OpenAL bindings?
21:48:23 <mauke> nolrai_: http://haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#scoped-type-variables
21:48:24 <lambdabot> Title: 8.7. Other type system extensions, http://tinyurl.com/2nsm7r
21:49:09 <kbateman> So that's a ghc extension then.
21:49:27 <gwern> stefanor@cox.net is Stefan O'Rear, right? is he sorear here?
21:49:39 <sorear> hes
21:49:40 <sorear> yes
21:49:57 <gwern> how convenient
21:50:13 <gwern> sorear: I've made some patches to your genericserialize
21:50:14 <gwern> any objects to it going on hackage?
21:50:29 <sorear> nope
21:50:36 <sorear> I thought it was on hackage?
21:50:51 <gwern> sorear: I looked for it, but I could be wrong
21:51:10 <kbateman> arraytype :: a -> [a] -> b; arraytype = undefined
21:51:19 * gwern looks again and doesnae see it
21:51:35 <kbateman> You can define related types this way
21:53:24 <gwern> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/genericserialize-0.1 <-- well, hackage didn't complain, so I guess it wasn't there. 'tis now
21:53:26 <lambdabot> http://tinyurl.com/3xo6vf
21:54:01 <nolrai_> mauke thanks!
21:55:54 <gwern> the 'Upload date' on hackage is the date of the most recent upload, right?
21:56:03 <gwern> sorear: while we're on the subject, vty could probably use an upload too
21:57:28 <gwern> feb 2007... doesn't build with 6.8.x looks like
22:00:03 <solrize_> hmm, i downloaded hackage crypto and did the configure/build/install stuff but ghci can't find the results
22:00:05 <bos> wow, etch doesn't even have ghc 6.6.1. lame.
22:00:32 <sorear> gwern: g-s uploaded
22:00:33 <solrize_> is there a way to find its search path ?
22:01:17 <gwern> sorear: I, uh, already uploaded genericserialize
22:01:33 <sorear> gwern: erm, I mean patch applied
22:02:20 <nolrai_> is there a LANGUAGE pragma for scoped type varables?
22:03:31 <pjd> mauke: there's a typo in that bit you linked to
22:03:37 <gwern> ScopedTypeVariables, iirc
22:03:40 <mauke> nolrai_: http://haskell.org/ghc/docs/latest/html/libraries/Cabal/Language-Haskell-Extension.html
22:03:41 <pjd> where does one report that?
22:03:42 <lambdabot> http://tinyurl.com/2c2g5y
22:04:12 <gwern> nolrai_: short of using the ghc commandline option to get the current list, http://haskell.org/ghc/docs/latest/html/libraries/Cabal/Distribution-Extension.html is where you should look
22:04:13 <lambdabot> http://tinyurl.com/2b93uq
22:04:37 <gwern> yep, ScopedTypeVariables it is. I see that one often
22:05:39 <nolrai_> i was spelling varaibles wrong.
22:05:56 <nolrai_> as it seems i still do.
22:06:10 <gwern> heh
22:06:28 <gwern> sorear: two vty patches incoming
22:10:48 <Igloo> Does Judah Jacobson IRC?
22:11:29 <gwern> sorear: any objection to a vty upload?
22:11:37 <sorear> nope
22:11:45 <sorear> again, I thought it was
22:11:45 <gwern> 'k then
22:11:51 <sorear> did the hackagedb get purged?
22:12:28 <gwern> hm. better bump the version number
22:13:19 <hpaste>  nolrai_ pasted "this one works" at http://hpaste.org/6405
22:14:10 <mauke> whoa
22:14:28 <hpaste>  nolrai_ annotated "this one works" with "...but this one doesnt. Why" at http://hpaste.org/6405#a1
22:14:40 <mauke> {-# LANGUAGE X1, X2, X3 #-}  -- fewer lines needed
22:14:44 <gwern> looks like a record for most needed extensions per line!
22:15:36 <gwern> it's almost a 2:1 ratio. impressive
22:16:25 <nolrai_> two of them are unnessary.
22:16:52 <gwern> well, an awful lot of the code lines are unecessary too
22:18:08 <nolrai_> true.
22:19:29 <gwern> crud, phooey requires wxhaskell, which I've never been able to compile
22:23:28 <sorear> gwern: done
22:30:57 <petekaz> if I have a list such as ["a","b","\n","c"] and want to turn it into [["a","b"],["c"]] using the newline to group, what is the easiest way of doing it?
22:33:28 <pjd> petekaz: is that intended to be a list of characters?
22:33:32 <petekaz> no
22:33:37 <petekaz> its a list of strings.
22:33:46 <pjd> just checking
22:33:57 <dmwit> > groupBy (\x y -> x == "\n" || y == "\n") ["a", "b", "\n", "c"]
22:34:00 <lambdabot>  [["a"],["b","\n"],["c"]]
22:34:07 <dmwit> oops
22:34:14 <dmwit> > groupBy (\x y -> x /= "\n" && y /= "\n") ["a", "b", "\n", "c"]
22:34:15 <lambdabot>  [["a","b"],["\n"],["c"]]
22:34:31 <dmwit> :t on
22:34:33 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
22:35:13 <dmwit> > groupBy ((&&) `on` (/= "n")) ["a", "b", "\n", "c"]
22:35:14 <lambdabot>  [["a","b","\n","c"]]
22:35:21 <dmwit> not quite
22:35:34 <dmwit> > groupBy ((&&) `on` (/= "\n")) ["a", "b", "\n", "c"]
22:35:35 <lambdabot>  [["a","b"],["\n"],["c"]]
22:35:49 <Zao> :t nub
22:35:50 <lambdabot> forall a. (Eq a) => [a] -> [a]
22:36:21 <pjd> petekaz: where is that list from?
22:36:40 <dmwit> petekaz: But probably "unlines" somewhere earlier in your chain is better.
22:37:02 <dmwit> > map words . lines $ "something like\nthis"
22:37:03 <lambdabot>  [["something","like"],["this"]]
22:37:50 <petekaz> Its as csv parser
22:37:56 <petekaz> it just returns a list of cells
22:38:06 <petekaz> and newlines are kept as their own cell
22:38:27 <dmwit> Can you "lines" it, then map the csv parser over the lines?
22:38:31 <petekaz> I thought it would be easy to convert the [String] to [[String]] with the newlines.
22:38:35 <dmwit> I think that would  be the preferred solution.
22:38:58 <nolrai_> is there a "f :: State s r -> StateT s IO r" so that "f s" does the same thing to the state as "s" does?
22:39:00 <petekaz> no, because quoted cells may extend over lines.
22:39:06 <dmwit> mmm
22:39:32 <petekaz> I was using unfold.
22:39:33 <dmwit> nolrai_: lift?
22:39:38 <dmwit> :t lift
22:39:39 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Monad m, MonadTrans t) => m a -> t m a
22:40:17 <dmwit> Oh, no, that's not what you want.
22:40:41 <nolrai_> dmwit: yeah thats what im using in the other branch of the else.
22:41:13 <petekaz> > unfoldr (\b -> if null b then Nothing else Just (takeWhile (/="\n") b, tail $ dropWhile (/="\n") b)) ["pete","was","\n","here","\n"]
22:41:14 <lambdabot>  [["pete","was"],["here"]]
22:41:28 <petekaz> > unfoldr (\b -> if null b then Nothing else Just (takeWhile (/="\n") b, tail $ dropWhile (/="\n") b)) ["pete","was","\n","here"]
22:41:29 <lambdabot>  Exception: Prelude.tail: empty list
22:41:43 <dmwit> petekaz: You don't like the groupBy solution?
22:42:17 <dmwit> ...or the unfoldr solution? =P
22:42:19 <petekaz> it still has the \n's in it?
22:42:25 <dmwit> petekaz: filter?
22:42:39 <petekaz> my unfoldr breaks if it doesn't end with a newline though.
22:42:43 <petekaz> I'll use yours.
22:42:44 <dmwit> > filter (/= ["\n"]) $ groupBy ((&&) `on` (/= "\n")) ["a", "b", "\n", "c"]
22:42:45 <lambdabot>  [["a","b"],["c"]]
22:42:45 <petekaz> with filter.
22:43:01 <petekaz> thanks!
22:43:06 <dmwit> > filter (/= ["\n"]) $ groupBy ((&&) `on` (/= "\n")) ["a", "b", "\n", "\n", "c"]
22:43:07 <lambdabot>  [["a","b"],["c"]]
22:43:32 <dmwit> nolrai_: No, I don't think there's anything like that, but it shouldn't be too hard to write.
22:44:15 <pjd> this should go on the "frequently requested function" pile
22:45:16 <dmwit> :t \s -> get >>= (\(a, s) -> put s >> return a) . runState s
22:45:17 <lambdabot> forall (m :: * -> *) a t. (MonadState a m) => State a t -> m t
22:45:55 <dmwit> ?pl \(a, s) -> put s >> return a
22:45:55 <lambdabot> uncurry (flip ((>>) . put) . return)
22:46:01 <petekaz> which package does 'on' live in?
22:46:06 <dmwit> ?index on
22:46:07 <lambdabot> bzzt
22:46:16 <dmwit> Data.Function, I think.
22:46:23 <dmwit> 6.8.x and up
22:46:30 <petekaz> oh
22:46:40 <dmwit> Or in module Dmwit  on 6.6 and below. ;-)
22:46:42 <petekaz> I'm on 6.6.
22:46:53 <petekaz> thanks.
22:47:00 <nolrai_> :t execState
22:47:01 <lambdabot> forall s a. State s a -> s -> s
22:47:01 <dmwit> on (+) f x y = f x + f y
22:47:07 <dmwit> petekaz: ^^
22:47:58 <nolrai_> @t execState
22:47:58 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
22:48:10 <dmwit> execState loses the return value, though.
22:48:12 <nolrai_> @type execState
22:48:13 <lambdabot> forall s a. State s a -> s -> s
22:48:28 <nolrai_> yes your right.
22:48:45 <nolrai_> @type runState
22:48:46 <lambdabot> forall s a. State s a -> s -> (a, s)
22:48:53 <dmwit> modify . execState -- is sure pretty, though =)
22:49:40 <dmwit> nolrai_: Did you see what I :t'd above, or are you just trying to write it yourself as an exercise?
22:50:29 <nolrai_> no i didnt
22:50:46 <dmwit> :t \m -> get >>= (\(a, s) -> put s >> return a) . runState m
22:50:47 <lambdabot> forall (m :: * -> *) a t. (MonadState a m) => State a t -> m t
22:51:11 <nolrai_> cool
22:52:04 <dmwit> But rewriting your State monad function just in terms of MonadState primitives is also a pretty good solution.
22:52:06 <Cale> This has to be the most elaborate diagram I've ever constructed for the purposes of a feature request: http://launchpadlibrarian.net/12692602/rcp.svg
22:53:06 <dmwit> What do you use for your diagrams?
22:53:18 * dmwit hopes for an awesome answer like "Cairo"
22:53:22 <dmwit> oh, svg
22:53:32 * dmwit hopes for an awesome answer like "Inkscape"
22:54:17 <Cale> Yes, Inkscape. It's a feature request *for* Inkscape after all :)
22:54:26 <dmwit> ah, heh
22:54:47 <Cale> It'd be pretty cool to have that in Cairo too though.
22:56:09 <Cale> https://bugs.launchpad.net/inkscape/+bug/202751 -- here's the full request if you're interested :)
22:56:58 <Cale> But the diagram says most of it. Basically, I'm wishing for a new kind of control point in paths.
22:57:52 <dmwit> Is (*) smart enough that "0 * expensiveCalculation" is fast?
22:57:59 <Cale> no
22:58:02 <dmwit> ok
22:58:10 <Cale> At least not for all the default numeric types.
22:58:21 <Cale> You could construct a new numeric type for which it was :)
22:58:41 <dmwit> right
22:58:45 <dmwit> Well... maybe
22:59:06 <dmwit> But I guess it could never handle both (expensive * 0) and (0 * expensive). =P
22:59:30 <Cale> right
22:59:39 <Cale> You have to try evaluating at least one side :)
22:59:58 <Cale> It would be neat to be able to step the evaluation in a finer way than seq gives.
23:00:00 <dmwit> =)
23:00:17 <pjd> lazy numbers!
23:00:26 <Cale> Parallel lazy numbers!
23:00:26 <dmwit> You'd probably need Zero | Succ Nat to do better.
23:00:40 <pjd> concurrent distributed lazy numbers!
23:00:40 <nolrai_> ow
23:00:41 <dmwit> And then multiplication would be slow for other reasons. =)
23:01:28 <Spark> inkscape is currently my favourite drawing program
23:01:35 <Spark> although it does irritating things when used in a makefile
23:01:38 <Spark> like demanding DISPLAY be set
23:01:47 <dmwit> =/
23:01:51 <nolrai_> would that be just quadratic time, or factorial? (mult on Zero | Succ Nat)
23:02:16 <dmwit> factorial?
23:02:28 <roconnor> @seen dons
23:02:28 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 1702398823
23:02:32 <Cale> Heh, I suppose you'd also need something like unsafeCase, which would pattern match without doing any evaluation.
23:02:43 <roconnor> um, ok
23:02:53 <Cale> (for making Ints, for example, have that lazy behaviour)
23:03:01 <Cale> um...
23:03:21 <Cale> what the...
23:03:21 <dmwit> nolrai_: I think it's O(mn), where m and n are the input numbers.
23:04:22 <Cale> n * m = unsafeCase n of 0 -> 0; _ -> unsafeCase m of 0 -> 0; _ -> n `microSeq` m `microSeq` n * m
23:05:09 <Cale> Where unsafeCase is like case, but does no evaluation, and microSeq only evaluates the outermost function application, rather than all the way to WHNF.
23:05:37 <pjd> does anyone maintain hg (or something else) mirrors of the GHC repo?
23:06:08 <Cale> Er, I suppose you also need to know when they're both nonzero, duh.
23:07:21 <Cale> Hmm... what would the right language primitives for this sort of thing be...
23:08:37 <dmwit> :t (.) :: (a -> b) -> Array i a -> Array i b
23:08:37 <lambdabot>     Could not deduce (Ix i) from the context ()
23:08:38 <lambdabot>       arising from a use of `.' at <interactive>:1:0-2
23:08:38 <lambdabot>     Possible fix:
23:08:47 <dmwit> :t (.) :: (Ix i) => (a -> b) -> Array i a -> Array i b
23:08:48 <lambdabot> forall a b i. (Ix i) => (a -> b) -> Array i a -> Array i b
23:08:51 <dmwit> sweet!
23:09:19 <dmwit> Oh, that's actually not what I wanted.
23:10:01 <dmwit> ?hoogle (Ix i) => (i, i) -> (i -> a) -> Array i a
23:10:02 <lambdabot> No matches, try a more general search
23:11:19 <dmwit> Bah, this problem seems so easy, what am I doing wrong?
23:13:24 <mauke_> @hoogle array
23:13:24 <lambdabot> Data.Array.IArray.array :: (IArray a e, Ix i) => (i, i) -> [(i, e)] -> a i e
23:13:24 <lambdabot> Foreign.Marshal.Array :: module
23:13:24 <lambdabot> Data.Array :: module
23:20:01 <dmwit> Oh!
23:21:41 <dmwit> wait, no
23:23:12 <mofmo2> i almost had a heart attack
23:23:25 <mofmo2> i thought my homework wanted me to draw environment diagrams
23:23:35 <mofmo2> and i thought, "WAIT? IN ASCII? HOW CAN I SUBMIT THIS?"
23:23:46 <dmwit> WAUGH
23:24:04 <mofmo2> dmwit: it'd be alright on paper, but my class uses electronic submission
23:24:23 <dmwit> HOW CAN YOU CONTROL THE WORD-WRAP??
23:24:31 <dmwit> Yeah, that would suck.
23:31:47 <Cale> Just write instructions for drawing the appropriate environment diagrams :)
23:32:30 <Cale> Heh, or there's always SVG :)
23:37:03 <solrize_> anyone know how to get ghci to actually find a hackage package after it's been installed?
23:41:03 <boyscared> are all functions that are typed with only type variables parametrically polymorphic?
23:48:04 <scook0> solrize_: :m + isn't working
23:48:09 <scook0> ?
23:48:39 <solrize_> scook0 i think the prob is that the package's setup.hs put the lib into a nonstandard place and ghci doesn't know where to look for it
23:48:44 <solrize_> and the -i command line option doesn't help
23:48:48 <Cale> boyscared: All functions typed with any type variables at all are parametrically polymorphic.
23:48:56 <scook0> solrize_: what about ghc-pkg list?
23:49:09 <solrize_> hmm that finds it
23:49:30 <boyscared> Cale: so introducing a type class doesn't default it to ah-hoc polymorphism?
23:49:34 <scook0> normally it doesn't matter where your libs go, as long as they're registered
23:50:20 <Cale> boyscared: Typeclasses don't really fit my definition of ad-hoc polymorphism
23:50:53 <Cale> boyscared: It's more like they restrict the quantifiers in parametric polymorphism.
23:51:06 <boyscared> but, if those functions are fully parametric, then couldn't you get code inference out of the type definition?
23:51:12 <hpaste>  calvins pasted "A question of types" at http://hpaste.org/6406
23:51:23 <Cale> You can still get some code inference.
23:51:46 <solrize_> @hoogle (a->b) -> (a,a) -> (b,b)
23:51:46 <lambdabot> No matches, try a more general search
23:51:48 <Cale> @djinn (Eq a) => Either a b -> (b -> a) -> Bool
23:51:50 <lambdabot> f a b =
23:51:50 <lambdabot>     case a of
23:51:50 <lambdabot>     Left c -> c == c
23:51:50 <lambdabot>     Right d -> b d == b d
23:51:51 <calvins> haskell typing deities: can anybody see a type that I could give to the function I just pasted to make it work?
23:52:04 <Cale> heh, not quite the function I was looking for :)
23:52:05 <boyscared> what would i get from like f :: a -> Num
23:52:18 <boyscared> nothing useful, i'd imagine
23:52:23 <Cale> You mean  f :: (Num b) => a -> b?
23:52:39 <boyscared> yes
23:52:50 <Cale> Well, you might get something like const 0
23:53:04 <Cale> But that would require a bit of work :)
23:53:05 <scook0> @type \s v -> map (*s) v
23:53:06 <lambdabot> forall a. (Num a) => a -> [a] -> [a]
23:53:16 <scook0> calvins: is that the type you're after?
23:53:25 <calvins> scook0: that won't allow an int first arg and a [Float] second arg
23:53:54 <calvins> i want to allow any real type as first arg, and any list of reals as the second
23:54:09 <scook0> ah, I missed that, sorry
23:54:17 <calvins> and then get back list of integral if both real types were integral, and otherwise a list of floating
23:54:42 <Cale> boyscared: You can think of a typeclass-bounded type as just requiring another parameter to the function, which consists of a dictionary of implementations for methods of the class.
23:55:16 <Cale> boyscared: Any code inference will still work out just as well :)
23:55:35 <Cale> It's recursive types which tend to mess up code inference.
23:55:54 <boyscared> can djinn do this kinda code inference?
23:56:00 <Cale> Yeah, that's what it does.
23:56:25 <Cale> It doesn't know anything about recursive types though.
23:56:46 <Cale> It has rudimentary support for typeclasses.
23:57:01 <Cale> @djinn-env
23:57:01 <lambdabot> data () = ()
23:57:01 <lambdabot> data Either a b = Left a | Right b
23:57:01 <lambdabot> data Maybe a = Nothing | Just a
23:57:01 <lambdabot> data Bool = False | True
23:57:01 <lambdabot> data Void
23:57:03 <lambdabot> type Not x = x -> Void
23:57:05 <lambdabot> class Eq a where (==) :: a -> a -> Bool
23:57:45 <hpaste>  solrize pasted "a lame way to get random chars--what's better?" at http://hpaste.org/6407
23:58:13 <boyscared> so, ad-hoc polymorphism is only when there are no type variables?
23:58:16 <Cale> solrize_: System.Random
23:59:05 <Cale> boyscared: I tend to think of ad-hoc polymorphism as the sort where you have multiple definitions of a variable at different types, and the type context at the call-site must completely determine the type of the variable.
23:59:09 <solrize_> cale, that appears to be some kind of algorithmic rng... i really do want to read the random chars from /dev/urandom, it's just lame the way i did it with sequence and that listcomp
23:59:22 <Cale> Oh, replicateM
23:59:39 <Cale> replicateM n (hGetChar hh)
23:59:51 <solrize_> thanks
23:59:53 <solrize_> trying
