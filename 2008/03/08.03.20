00:00:36 <bd_> http://pastebin.org/24544 <-- code and error
00:02:18 <cjs> Ooo. I need a "--follow-incoherent-programmer" option for ghc.
00:02:38 <quicksilver> bd_: you need overlapping instances to have any chance of that being accepted.
00:02:44 <bd_> quicksilver: it already has that
00:02:51 <quicksilver> hmm.
00:02:52 <bd_> ... I think
00:02:59 <quicksilver> check :)
00:03:03 <quicksilver> "instance (HOLift m b, KaosDiagM r b, MonadKaos r m) => KaosDiagM r m" overlaps with everything.
00:03:13 <bd_> ... okay, it didn't have it, but it still breaks
00:03:22 <quicksilver> same error? or a different one?
00:03:31 <bd_> same error, plus some [overlap ok] annotations
00:04:27 <quicksilver> very few peopl eundertand the semantics of overlapping / undecidable / incoherent instances
00:05:08 <bd_> mhm
00:05:33 <bd_> I was hoping to save some typing with making instance declarations for all the other monad transformers... but at this rate maybe it's not worth it :)
00:05:40 <bd_> then again I still want to know how to fix it <.,
00:06:07 <glguy> 5~/exit
00:06:19 <quicksilver> I'm suprised it can't see the second as being more specific than the first
00:06:43 <quicksilver> maybe an interaction between overlaps and fundeps as you suggest.
00:07:02 <quicksilver> did you recompile all the code with the same flags/
00:07:03 <quicksilver> ?
00:07:06 <bd_> it says it depends on the instantiation of b and r, but those should be dependent on m...
00:07:07 <quicksilver> (or is it just one file)
00:07:18 <bd_> the code in question is all in one file
00:07:20 <bd_> I'll clean it
00:08:04 <quicksilver> Yeah. Beyond my understanding anyway. The only rule I understand is that, if overlap is OK, it's supposed to prefer more specific matches.
00:08:19 <quicksilver> I think the fundep might be making it ignore the second parameter, in a sense.
00:08:30 <quicksilver> Have you considered having the fundep the other way?
00:08:49 <bd_> KaosDiagM r m | r -> m you mean?
00:11:40 <bd_> because if so that would only ever allow one monad transformer for it... )
00:16:17 <bd_> oh well, I'll sleep on it
00:16:25 <bd_> and maybe manually write out instances tomorrow
00:35:19 <sclv> ?hoogle partitionEithers
00:35:19 <lambdabot> No matches found
01:01:54 <lispy> ?hoogle partition
01:01:54 <lambdabot> Data.List.partition :: (a -> Bool) -> [a] -> ([a], [a])
01:01:54 <lambdabot> Data.ByteString.partition :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
01:01:54 <lambdabot> Data.Set.partition :: Ord a => (a -> Bool) -> Set a -> (Set a, Set a)
01:01:58 <lispy> ?hoogle partitionBy
01:01:58 <lambdabot> No matches found
01:02:24 <dmwit> partitionEithers is in head only, I think.
01:02:29 <lispy> sclv: how does that work? it puts the lefts on one said and rights on the other?
01:02:41 <lispy> s/said/side
01:03:12 <sclv> yep -- its been added to the main libraries, but not yet in current distributions. :-(
01:04:07 <lispy> partitionEithers :: [Either a b] -> ([a],[b]), I think
01:05:03 <vegai> what's this rc that don's lambdabot uses? It's not plan9's rc, is it?
01:05:33 <lispy> :t let p (Left _) = True; p (Right _) = False in parition p
01:05:35 <lambdabot> Not in scope: `parition'
01:05:40 <lispy> :t let p (Left _) = True; p (Right _) = False in partition p
01:05:41 <lambdabot> forall t t1. [Either t t1] -> ([Either t t1], [Either t t1])
01:05:51 <vegai> oh, it actually is :)
01:05:55 <vegai> cool.
01:06:02 <lispy> oh, I see, you can't actually use parition to do this
01:06:17 <lispy> rc?
01:06:53 <lispy> ?src Data.List.parition
01:06:53 <lambdabot> Source not found. Just what do you think you're doing Dave?
01:06:57 <lispy> ?src Data.List.partition
01:06:57 <lambdabot> Source not found. It can only be attributed to human error.
01:06:58 <vegai> it's plan9's shell
01:07:08 <lispy> ?src partition
01:07:08 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
01:07:08 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
01:07:08 <lambdabot>                               | otherwise = (ts, x:fs)
01:07:10 <dmwit> partitionEithers xs = ([x | Left x <- xs], [y | Right y <- xs])
01:07:30 <lispy> dmwit: oh, hrm...that is succinct
01:07:42 <vegai> oh, wait a second. That has nothing to do with rc. rc is lambdabot's internal command
01:07:46 * vegai slaps forehead
01:08:18 <oerjan> @help rc
01:08:18 <lambdabot> rc name. Read a file of commands (asynchonously). FIXME: better name.
01:08:27 <vegai> aye
01:08:41 <lispy> read a file of commands?
01:08:56 <oerjan> @rc bet this requires some privileges
01:08:56 <lambdabot> Not enough privileges
01:09:17 <scook0> dmwit: that's two-pass, isn't it?
01:09:26 <scook0> (though not if you only want one side)
01:10:22 <quicksilver> scook0: I don't think there is an efficient one-pass algorithm, though?
01:10:33 <scook0> maybe not
01:10:36 <quicksilver> you can't generate two lists simultaneously in a single pass, can you?
01:10:50 <quicksilver> you'd need "interlinked thunks" in some sense.
01:11:09 <lispy> let paritionEithers xs = foldr select ([],[]) xs; select (Left x) ~(ts, fs) = (x:ts,fs);  select (Right x) = (ts,x:fs) in partitionEithers
01:11:10 <scook0> you could do it backwards and reverse, if you're willing to give up laziness
01:11:12 <scook0> (I think)
01:11:15 <quicksilver> right
01:11:19 <vegai> @hoogle Data.Number.Symbolic
01:11:19 <lambdabot> No matches, try a more general search
01:11:19 <lispy> :t let paritionEithers xs = foldr select ([],[]) xs; select (Left x) ~(ts, fs) = (x:ts,fs);  select (Right x) = (ts,x:fs) in partitionEithers
01:11:20 <lambdabot> Not in scope: `ts'
01:11:20 <lambdabot> Not in scope: `fs'
01:11:20 <lambdabot> Not in scope: `partitionEithers'
01:11:23 <quicksilver> but if you reverse, that's a second pass, morally.
01:11:25 <vegai> @hoogle Symbolic
01:11:25 <lambdabot> No matches found
01:11:31 <scook0> oh, that's true
01:11:41 <dmwit> Wait, why isn't one-pass possible?
01:11:58 <lispy> :t let paritionEithers xs = let select (Left x) ~(ts, fs) = (x:ts,fs);  select (Right x) = (ts,x:fs) in folder select ([],[]) xs in partitionEithers
01:11:59 <lambdabot> Not in scope: `ts'
01:11:59 <lambdabot> Not in scope: `fs'
01:11:59 <lambdabot> Not in scope: `folder'
01:12:00 <quicksilver> lispy: but that's unpacking and repacking tuples the whole time. Unless you believe the compiler can remove them.
01:12:02 <lispy> bah
01:12:20 <scook0> quicksilver: now if you don't care about order, then you can do one-pass by removing the reverse step
01:12:33 <lispy> quicksilver: well, I'm basing it on what lambdabot says parition is already implemented as, for whatever that is worth
01:12:57 <quicksilver> ;)
01:12:58 <dmwit> :t let pE [] = ([], []); pE ((Left x):xs) = let (l, r) = pE xs in (x:l, r); pE ((Right x):xs) = let (l, r) = pE xs in (l, x:r) in pE
01:12:59 <lambdabot> forall a a1. [Either a a1] -> ([a], [a1])
01:13:12 <dmwit> Why isn't that one-pass?
01:13:39 <quicksilver> I think it is, but it isn't efficient.
01:13:46 <dmwit> Oh, okay.
01:13:49 <quicksilver> because it's leaving all these tuple-thunks all over the place
01:13:57 <quicksilver> if you inspect the lefts but not the rights.
01:14:14 <lispy> heh, I think it's silly that partial functions are considered controversial
01:15:48 <lispy> :t let paritionEithers xs = let select (Left x) ~(ts, fs) = (x:ts,fs);  select (Right x) ~(ts, fs) = (ts,x:fs) in folder select ([],[]) xs in partitionEithers
01:15:49 <lambdabot> Not in scope: `folder'
01:15:49 <lambdabot> Not in scope: `partitionEithers'
01:16:01 <lispy> :t let partitionEithers xs = let select (Left x) ~(ts, fs) = (x:ts,fs);  select (Right x) ~(ts, fs) = (ts,x:fs) in foldr select ([],[]) xs in partitionEithers
01:16:02 <lambdabot> forall t t1. [Either t t1] -> ([t], [t1])
01:16:04 <lispy> there we go
01:16:11 <lispy> quicksilver: and so that one isn't efficient either?
01:18:32 <lispy> I think we need a isFoo deriving clause
01:18:57 <lispy> so that when you have a sum type such as data Foo = Foo | Bar | Baz, deriving (Is), gives you isFoo, isBar, isBaz automatically
01:19:07 <quicksilver> I want that occasionally, yes.
01:19:27 <quicksilver> I also want a "type of constructors" occasionally.
01:19:37 <lispy> what does that one do?
01:19:47 <lispy> I wonder if this can be easily accomplished with deriv
01:19:51 <lispy> er drift
01:20:08 <quicksilver> so if data Foo = Foo Int Int | Bar String, you get data Cfoo = Cfoo | Cbar
01:20:13 <quicksilver> i.e the corresponding enum, ignoring "contesnts" of constructors.
01:20:54 <lispy> what do you use it for?
01:20:54 <quicksilver> I did mention this to Neil once and he thought that Derive could do it.
01:21:00 <quicksilver> I never got around to trying though.
01:21:21 <quicksilver> same kind of thing as isFoo.
01:21:30 <lispy> I've heard of drift as allowing you to specify automatic derivations, but I don't know anything about Derive
01:22:01 <dolio> So, how about that Disciplined Disciple Compiler?
01:22:13 <lispy> huh?
01:22:15 <lispy> what is that?
01:22:18 <quicksilver> in fact, "isFoo" has the same information content, so anything you can do with one you can do with the other.
01:22:26 <dolio> http://www.haskell.org/haskellwiki/DDC
01:22:27 <lambdabot> Title: DDC - HaskellWiki
01:22:33 <quicksilver> it's just that sometimes having a representative for your constructors is handy.
01:23:56 <lispy> oh, derive is drift
01:26:21 <lispy> "This allows instances to be derived for a type after the original module has been compiled. As a bonus, simple utility functions can also be produced for types."
01:26:28 <lispy> Why don't I use it already??
01:26:33 <lispy> It sounds really cool
01:26:35 <quicksilver> wel.. they're different programs.
01:26:42 <quicksilver> but they aim for similar goals
01:28:19 <dolio> Certainly gets some hairy type signatures.
01:28:20 <lispy> quicksilver: it turns out, drift already has a rule builtin for 'is'
01:28:50 <lispy> quicksilver: according to the drift website it was renamed from derive due to a a tradmark infrigement
01:29:01 <dolio> map  :: forall a b %r0 %r1 !e0 $c0.  (a -(!e0 $c0)> b) -> List %r0 a -(!e1 $c1)> List %r1 b :- !e1 = !{ !Read %r0; !e0 },  $c1 = f : $c0
01:31:35 <lispy> "No support for TeX-style literate code."
01:31:36 <lispy> ugh
01:31:44 <lispy> Now I know part of why I've never used it.
01:31:50 <lispy> It should probably use the GHC api
01:32:01 <lispy> Or better yet, just be a ghc extension
01:40:54 <quicksilver> lispy: I was using derive as a shorthand for Data.Derive
01:41:01 <quicksilver> lispy: which is a different program, written by ndm.
01:41:07 <quicksilver> but with similar goals.
01:41:17 <lispy> oh
01:41:25 <lispy> is Data.Derive for nhc only?
01:41:31 <sorear> no
01:41:33 <quicksilver> no.
01:41:46 <sorear> it's based on TH these days, so it doesn't even *work* on nhc
01:41:55 <quicksilver> I don't know the details of he differences between DrIFT and Data.Derive
01:42:07 <quicksilver> there was evidently something about DrIFT that ndm didn't liike, though :)
01:42:15 <quicksilver> since it came first, and he chose to write his own.
01:43:15 <lispy> well, DrIFT doesn't support anything but vanilla H98 without literate
01:43:28 <lispy> so I can see where that's quite obnoxious
01:45:45 <lispy> the cool thing about Data.Derive is that it defines some TH stuff so that you can just include the generated derivations that way in your module
01:45:48 <lispy> very cool
02:00:34 <vegai> dons: Looks like lambdabot (darcs head) fails to start if commandPrefixes doesn't include "@"
02:00:52 <vegai> Config.commandPrefixes, that is
02:01:56 <vegai> in which case it responds:
02:01:56 <vegai> IrcMessage {msgServer = "offlinerc", msgLBName = "offline", msgPrefix = "null!n=user@null", msgCommand = "PRIVMSG", msgParams = ["offline",":@offline"]}
02:02:00 <vegai> Exception: all servers detached
02:06:03 <oerjan> @seen dons
02:06:03 <lambdabot> dons is in #haskell, #xmonad and #haskell-soc. I don't know when dons last spoke.
02:06:11 <oerjan> @uptime
02:06:11 <lambdabot> uptime: 4d 34m 26s, longest uptime: 1m 10d 23h 44m 29s
02:06:19 <skorpan> oerjan: don't you ever sleep?
02:06:49 <oerjan> sure, just very irregularly sometimes
02:07:15 <Riastradh> Hey, can lambdabot guess how long *anyone* has been up?
02:07:19 <Riastradh> @uptime
02:07:19 <lambdabot> uptime: 4d 35m 35s, longest uptime: 1m 10d 23h 44m 29s
02:07:23 <Riastradh> ...darn.
02:07:30 <oerjan> oh...
02:07:30 <Riastradh> I guess oerjan hasn't actually been up for four days.
02:07:39 <oerjan> :D
02:38:09 <dmwit> ?check \n -> 7 * (n `mod` 7) == (7 * n) `mod` 49
02:38:13 <lambdabot>  OK, passed 500 tests.
02:38:34 <dmwit> ?check \a n -> a * (n `mod` a) == (a * n) `mod` (a * a)
02:38:34 <lambdabot>  Exception: divide by zero
02:38:40 <dmwit> aw
02:38:46 <lispy> ?scheck \n -> 7 * (n `mod` 7) == (7 * n) `mod` 49
02:38:47 <lambdabot>   Completed 13 test(s) without failure.
02:38:48 <dmwit> ?check \a n -> a > 0 ==> a * (n `mod` a) == (a * n) `mod` (a * a)
02:38:49 <lambdabot>  OK, passed 500 tests.
02:40:00 <lispy> ?check False ==> True
02:40:01 <lambdabot>  Arguments exhausted after 0 tests.
02:40:29 <lispy> ?vixen exhausted before you even started, eh?
02:40:29 <lambdabot> i'm not a good starter. you start.
02:40:54 <lispy> ?check const False ==> True
02:40:55 <lambdabot>  Couldn't match expected type `Bool'
02:41:43 <dmwit> Okay, and I can prove it, great.
02:44:19 <lispy> ?check reverse . reverse == id
02:44:19 <lambdabot>   add an instance declaration for (Eq ([a] -> [a]))     In the expression: re...
02:44:33 <lispy> ?check reverse . reverse == (id :: [Int] -> [Int])
02:44:33 <lambdabot>   add an instance declaration for (Eq ([Int] -> [Int]))     In the expression...
02:44:39 <dmwit> ?check liftM2 (==) (reverse . reverse) id
02:44:39 <lambdabot>  OK, passed 500 tests.
02:44:44 <lispy> ?check (reverse . reverse) == (id :: [Int] -> [Int])
02:44:44 <lambdabot>   add an instance declaration for (Eq ([Int] -> [Int]))     In the expression...
02:44:58 <dmwit> lispy: You're doing equality on functions there...
02:45:14 <lispy> hm...yeah, I need to pass in the arg afterall
02:45:18 <lispy> silly me
02:45:25 <dmwit> No you don't, use the Reader monad. ;-)
02:45:30 <lispy> heh
02:45:31 <dmwit> But:
02:45:38 <dmwit> > reverse . reverse $ [1..]
02:45:42 <lambdabot> Terminated
02:46:01 <dmwit> Close, but not quite lazy enough to be id.
02:46:08 <lispy> sure
02:46:20 <lispy> ?check \x -> (reverse . reverse) x == (id :: [Int] -> [Int]) x
02:46:21 <lambdabot>  OK, passed 500 tests.
02:46:32 <lispy> ?check \x -> (reverse . reverse) x == id x
02:46:33 <lambdabot>  OK, passed 500 tests.
02:46:43 <dmwit> ?check liftM2 (==) (join (.) reverse) id
02:46:44 <lambdabot>  OK, passed 500 tests.
02:47:19 <lispy> > ap (+1) 2
02:47:21 <lambdabot>        add an instance declaration for (Num ((a -> b) -> a), Num (a -> b))
02:47:22 <dmwit> :t ap
02:47:26 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
02:47:39 <lispy> was it ap in the reader monad that applied the function to one argument twice or whatever it was?
02:47:47 <dmwit> ?check ap (==) (join (.) reverse)
02:47:48 <dolio> > ap (*) (+1) 5
02:47:48 <lambdabot>  OK, passed 500 tests.
02:47:48 <lambdabot>  30
02:47:51 <dmwit> Yes!
02:47:54 <dmwit> Man, golf is fun.
02:48:09 <quicksilver> quickcheck will still pass the reverse . reverse thing
02:48:16 <quicksilver> since it only tests finite input
02:48:29 <dmwit> right
02:48:34 <lispy> dmwit: yeah, that's what I was thinking with the ap
02:49:19 <lispy> dmwit: now if you can shorten (join (.) reverse)
02:49:26 <lispy> :t join (.) reverse
02:49:27 <lambdabot> forall a. [a] -> [a]
02:49:40 <dmwit> Hard to make that much shorter without changing the meaning of the test, I think.
02:49:49 <dmwit> :t fmap join
02:49:51 <lambdabot> forall (m :: * -> *) a (f :: * -> *). (Functor f, Monad m) => f (m (m a)) -> f (m a)
02:50:01 <quicksilver> > (join (.) reverse) "abcd"
02:50:01 <lambdabot>  "abcd"
02:50:31 <dmwit> > join (.) reverse "abcd"
02:50:31 <lambdabot>  "abcd"
02:50:55 <lispy> > join(.)reverse"abcd"
02:50:55 <lambdabot>  "abcd"
02:50:56 <dmwit> I mean, I could always just remove whitespace.
02:51:04 <dmwit> ?check ap(==)$join(.)reverse
02:51:05 <lambdabot>  OK, passed 500 tests.
02:51:31 <lispy> :t join(.)fix
02:51:32 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a
02:51:32 <lambdabot>     Probable cause: `join' is applied to too few arguments
02:51:34 <dmwit> Saves 20%!
02:52:04 <lispy> :t fix reverse
02:52:05 <lambdabot> forall a. [a]
02:52:15 <lispy> > fix reverse $ "hi"
02:52:15 <dmwit> Exception: <<loop>>
02:52:15 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `[a1]'
02:52:24 <dmwit> > fix reverse :: [Int]
02:52:24 <lambdabot>  Exception: <<loop>>
02:52:50 <dmwit> > fix show -- way more fun
02:52:51 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
02:52:53 <lispy> :t fix (.)
02:52:55 <lambdabot>     Occurs check: cannot construct the infinite type: a = f a
02:52:55 <lambdabot>       Expected type: (a -> b) -> a -> b
02:52:55 <lambdabot>       Inferred type: (a -> b) -> f a -> f b
02:53:10 <lispy> dmwit: yeah, I'm intimately famliar with fix show
02:53:18 <dmwit> =)
02:53:38 <lispy> > take 10 . map length . group . fix $ show
02:53:39 <lambdabot>  [1,1,1,3,1,7,1,15,1,31]
02:54:22 <lispy> :t fix (join (.))
02:54:23 <lambdabot> forall a. a -> a
02:54:36 <lenbust> how do I determine wether a Data.Graph is cyclic or not?
02:54:42 <lispy> > fix (join (.)) reverse
02:54:42 <lambdabot>  Add a type signature
02:54:47 <lenbust> can't seem to find an explicit method in the docs
02:54:48 <dmwit> > fix (join (.)) 3
02:54:52 <lambdabot> Terminated
02:55:27 <lispy> > fix (join (.)) 3 :: Expr
02:55:30 <lambdabot> Terminated
02:56:03 <lispy> lenbust: I've never used it, so I'm not much help
02:56:38 <oerjan> > iterate (join (.)) x
02:56:38 <lambdabot>  Couldn't match expected type `a -> a' against inferred type `Expr'
02:56:41 <dmwit> lenbust: You may have to check explicitly whether the endpoints of each edge you add are in the same SCC.
02:56:55 <oerjan> > iterate (join (.)) (f :: Expr -> Expr)
02:56:56 <lambdabot>  [<SimpleReflect.Expr -> SimpleReflect.Expr>,<SimpleReflect.Expr -> SimpleRef...
02:57:08 <lenbust> dmwit: SCC?
02:57:10 <lispy> oerjan: hrm.
02:57:16 <lispy> oerjan: you broke it! ;)
02:57:18 <dmwit> lenbust: Strongly-connected component.
02:57:31 <lispy> > iterate (join (.)) :: Expr
02:57:31 <lambdabot>  Couldn't match expected type `Expr'
02:57:48 <lispy> > iterate (join (.)) id :: Expr
02:57:48 <lambdabot>  Couldn't match expected type `Expr'
02:57:51 <lenbust> dmwit: ah, right. will walk with that idea for a bit.
02:58:01 <lispy> > iterate (join (.)) id :: [Expr]
02:58:02 <lambdabot>  Couldn't match expected type `Expr' against inferred type `a -> b'
02:58:34 <dolio> > map ($x) . iterate (join (.)) $ f
02:58:35 <lambdabot>  [f x,f (f x),f (f (f (f x))),f (f (f (f (f (f (f (f x))))))),f (f (f (f (f (...
02:58:48 <lispy> > iterate (join (.)) f
02:58:48 <lambdabot>  Add a type signature
02:58:55 <lispy> :t f
02:58:56 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
02:59:31 <dolio> > sequence (iterate (join (.)) f) x
02:59:32 <lambdabot>  [f x,f (f x),f (f (f (f x))),f (f (f (f (f (f (f (f x))))))),f (f (f (f (f (...
02:59:35 <lispy> :t x
02:59:36 <lambdabot> Expr
03:00:10 <lispy> oh, cool use of sequence
03:00:19 <lispy> I didn't realize map ($x) == sequence
03:00:31 <lispy> more like ~
03:00:35 <dolio> map ($x) == ($x) . sequence
03:00:36 <lispy> since it's not exactly equal
03:00:44 <lispy> ?free map ($x)
03:00:44 <lambdabot> Extra stuff at end of line
03:00:52 <lispy> ?free sequence
03:00:53 <lambdabot> Expected variable or '.'
03:01:09 <lispy> ?free \x -> map ($x)
03:01:09 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
03:01:26 <lispy> ?free \x -> ($x) . sequence
03:01:26 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
03:01:28 <lispy> hm
03:01:28 <oerjan> ouch
03:01:30 <dolio> @free seq :: [a -> b] -> a -> [b]
03:01:30 <lambdabot> (forall h. (forall k p. g . k = p . f                        =>                         h k = p)           =>            $map h xs = ys) => $map g . seq xs = seq ys . f
03:01:54 <oerjan> :t \x -> ($x) . sequence
03:01:55 <lambdabot> forall a a1. a -> [a -> a1] -> [a1]
03:02:11 <oerjan> ?free s :: a -> [a -> a1] -> [a1]
03:02:11 <lambdabot> (forall h. (forall k p. g . k = p . f                        =>                         h k = p)           =>            $map h xs = ys) => $map g (s x xs) = s (f x) ys
03:02:29 <lispy> cool
03:02:36 <dolio> @type flip sequence
03:02:37 <lambdabot> forall a b. b -> [b -> a] -> [a]
03:02:39 <lispy> it's awesome that's a free theorem
03:03:40 <lispy> ?free pe :: [Either a b] -> ([a], [b])
03:03:41 <lambdabot> $map_Pair ($map f) ($map g) . pe = pe . $map ($map_Either f g)
03:03:48 <oerjan> ?free flip sequence
03:03:48 <lambdabot> Extra stuff at end of line
03:03:57 <oerjan> sheesh
03:04:11 <lispy> what iz map_Pair? is that some variant of zip?
03:04:42 <dolio> mapPair :: (a -> b) -> (c -> d) -> (a,b) -> (c,d)
03:04:42 <quicksilver> I don't think so, no
03:04:53 <dolio> Er, (a,c) -> (b,d)
03:04:57 * quicksilver nods
03:04:58 <oerjan> probably (***)
03:05:01 <lispy> fmap?
03:05:07 <quicksilver> mapPair f g (a,b) = (f a, g b)
03:05:07 <lispy> ?type fmap
03:05:09 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
03:05:10 <quicksilver> it's a kind of double fmap
03:05:20 <oerjan> (***) i say
03:05:21 <dmwit> lispy: Not quite fmap, that only works on one side of the pair.
03:05:27 <quicksilver> fmap on both sides at one (but with different functions)
03:05:27 <dmwit> I'm with oerjan.
03:05:31 <dolio> Yeah, it's (***).
03:05:42 <dolio> Or bimap on the bifunctor (,), if you're into that.
03:05:43 <idnar> @type (***)
03:05:44 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
03:06:13 <idnar> @type (***) :: (a -> b) -> (c -> d) -> (a,b) -> (c,d)
03:06:14 <lambdabot>     Couldn't match expected type `b' against inferred type `c'
03:06:14 <lambdabot>       `b' is a rigid type variable bound by
03:06:14 <lambdabot>           the polymorphic type
03:06:26 <idnar> @type (***) :: (a -> b) -> (c -> d) -> (a,c) -> (b,d)
03:06:27 <lambdabot> forall a b c d. (a -> b) -> (c -> d) -> (a, c) -> (b, d)
03:07:10 <oerjan> :t (***).($)
03:07:11 <lambdabot> forall b' c' a b. (a -> b) -> (b' -> c') -> (a, b') -> (b, c')
03:08:11 <lispy> ?free (***)
03:08:11 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
03:08:18 <lispy> ?free ***
03:08:18 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
03:08:30 <oerjan> too polymorphic
03:08:40 <oerjan> ?free (***).($)
03:08:40 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
03:08:42 <lispy> ?free mp :: (a -> b) -> (b' -> c') -> (a, b') -> (b, c')
03:08:42 <lambdabot> g . p = q . f => k . f1 = f2 . h => $map_Pair g k . mp p f1 = mp q f2 . $map_Pair f h
03:09:46 <lispy> The theorem is free but it will cost you pattern match...
03:09:48 <oerjan> ?free map map
03:09:48 <lambdabot> Extra stuff at end of line
03:10:08 <lispy> :t map map
03:10:09 <lambdabot> forall a b. [a -> b] -> [[a] -> [b]]
03:10:20 <lispy> ?free mm :: [a -> b[ -> [[a]-> [b]]
03:10:20 <lambdabot> Extra stuff at end of line
03:10:24 <lispy> ?free mm :: [a -> b] -> [[a]-> [b]]
03:10:24 <lambdabot> (forall h. (forall k p. g . k = p . f                        =>                         h k = p)           =>            $map h xs = ys) => (forall f1 f2. $map g . f1 = f2 . $map f               =>
03:10:24 <lambdabot>               q f1 = f2) => $map q (mm xs) = mm ys
03:10:27 <oerjan> it seems to me like ?free has trouble when you try to give it a complicated expression
03:10:39 <oerjan> rather than a single identifier
03:10:46 <lispy> ?. free type map map
03:10:48 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
03:10:57 <lispy> that's what we reallly want
03:11:03 <lispy> but, it doesn't work :(
03:11:14 <dmwit> It's because ?type gives forall's.
03:11:32 <lispy> right, but free could be modified to accept those
03:11:32 <oerjan> ?free map
03:11:33 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
03:11:50 <oerjan> it does accept some...
03:11:58 <oerjan> ?. free type map
03:11:59 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
03:12:37 <oerjan> ?free id map
03:12:37 <lambdabot> Extra stuff at end of line
03:12:50 <oerjan> ?free id$map
03:12:50 <lambdabot> Extra stuff at end of line
03:12:57 <Deewiant> ?free (id$map)
03:12:57 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
03:13:04 <lispy> ?free f
03:13:05 <lambdabot> Plugin `free' failed with: Plugin/Free/Type.hs:(152,16)-(160,44): Non-exhaustive patterns in case
03:13:16 <lispy> oy vey
03:13:16 <oerjan> ?help free
03:13:16 <lambdabot> free <ident>. Generate theorems for free
03:13:27 <dolio> @free intercalate
03:13:28 <lambdabot> $map f . intercalate xs = intercalate ($map f xs) . $map ($map f)
03:13:42 <oerjan> well it's not advertised to take more than a single identifier
03:13:57 <lispy> oerjan: but sometimes it even fails at that
03:14:04 <lispy> ?free a
03:14:05 <lambdabot> a = a
03:14:10 <lispy> ?free x
03:14:11 <lambdabot> x = x
03:14:15 <lispy> ?free f
03:14:16 <lambdabot> Plugin `free' failed with: Plugin/Free/Type.hs:(152,16)-(160,44): Non-exhaustive patterns in case
03:14:17 <lispy> hrm
03:14:21 <lispy> That is weird
03:14:26 <lispy> :t (x, f)
03:14:27 <lambdabot> forall a. (SimpleReflect.FromExpr a) => (Expr, a)
03:14:28 <oerjan> lispy: well it knows about few typeclasses
03:14:42 <oerjan> ?list free
03:14:42 <lambdabot> free provides: free
03:14:50 <oerjan> perhaps none
03:14:53 <oerjan> ?free (==)
03:14:53 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
03:14:56 <lispy> ?free Show a => a
03:14:56 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
03:15:01 <oerjan> ?free compare
03:15:03 <lambdabot> Extra stuff at end of line in retrieved type "forall a. (Ord a) => a -> a -> Ordering\n"
03:15:24 <lispy> ?free Monad
03:15:24 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
03:16:02 <dmwit> Okay, how do I make a closed form for this function?
03:16:09 <dmwit> (You guys are clearly bored, so... =)
03:16:15 <dmwit> It's cyclic with period 4 and
03:16:27 <dmwit> map f [0..3] = [2,3,2,1]
03:17:17 <oerjan> > map (([2,3,2,1]!!).(`mod`4)) [0..]
03:17:18 <lambdabot>  [2,3,2,1,2,3,2,1,2,3,2,1,2,3,2,1,2,3,2,1,2,3,2,1,2,3,2,1,2,3,2,1,2,3,2,1,2,3...
03:17:26 <lispy> I'm no good at this sort of thing.  I've completely forgotten anything I ever knew about difference equations.
03:17:26 <dmwit> bah
03:17:57 <dmwit> I want to be clever about this! =P
03:18:01 <quicksilver> something to do with powers of -1, I imagine
03:18:13 <dmwit> ah!
03:18:26 <mattam> @src (.)
03:18:29 <lambdabot> (f . g) x = f (g x)
03:18:34 <dmwit> > map (\x -> (-1) ^ (x `div` 2)) [0..10]
03:18:34 <lambdabot>  [1,1,-1,-1,1,1,-1,-1,1,1,-1]
03:18:44 <TSC> > map (\x -> sin (x*pi/2) + 2) [0..]
03:18:50 <lambdabot>  [2.0,3.0,2.0,1.0,1.9999999999999998,3.0,2.0000000000000004,1.0,1.99999999999...
03:18:55 <quicksilver> I don't know if `div`2 falls in your definition of 'closed form'
03:18:56 <quicksilver> grin
03:18:58 <TSC> or rounded:
03:19:02 <TSC> > map (\x -> round $ sin (x*pi/2) + 2) [0..]
03:19:02 <lambdabot>  [2,3,2,1,2,3,2,1,2,3,2,1,2,3,2,1,2,3,2,1,2,3,2,1,2,3,2,1,2,3,2,1,2,3,2,1,2,3...
03:19:03 <taruti> > cycle [2,3,2,1]
03:19:04 <lambdabot>  [2,3,2,1,2,3,2,1,2,3,2,1,2,3,2,1,2,3,2,1,2,3,2,1,2,3,2,1,2,3,2,1,2,3,2,1,2,3...
03:19:16 <dmwit> quicksilver: div is OK
03:19:32 <TSC> sine ok?
03:19:52 <dmwit> Sine is ok, but I'd rather stay in Integral.
03:19:57 <TSC> Aww (:
03:20:00 <dmwit> =)
03:20:04 <quicksilver> if you don't want div you could do some cute with i and gaussian integers.
03:20:10 <solrize_> > iterate cos 1.0
03:20:10 <lambdabot>  [1.0,0.5403023058681398,0.8575532158463934,0.6542897904977791,0.793480358742...
03:20:22 <oerjan> well...
03:20:23 <solrize_> > iterate cos 1.0 !! 100
03:20:24 <lambdabot>  0.7390851332151607
03:20:28 <lispy> > iterate sin 1.0
03:20:29 <lambdabot>  [1.0,0.8414709848078965,0.7456241416655579,0.6784304773607402,0.627571832049...
03:20:34 <oerjan> > map (subtract 2) [2,3,2,1]
03:20:35 <lambdabot>  [0,1,0,-1]
03:20:40 <dmwit> > map (\x -> (-1) ^ (x `div` 2) * (x `mod` 2)) [0..10]
03:20:41 <lambdabot>  [0,1,0,-1,0,1,0,-1,0,1,0]
03:20:47 <dmwit> Nice!
03:21:15 <lispy> > zipWith (-) $ iterate (\x -> cos x, sin x) 1.0
03:21:16 <lambdabot>  Couldn't match expected type `a -> a'
03:21:25 <quicksilver> well if you're happy with `mod` then `mod`4 is the obvious function of period 4 :P
03:21:32 <quicksilver> (and div gives you mod)
03:21:45 <dmwit> quicksilver: Yes, but it doesn't have the right slope half the time.
03:22:00 <quicksilver> [2,3,2,1] !! (x`mod`4) :P
03:22:38 <lispy> > zipWith (-) (iterate cos 1.0) (iterate sin 1.0)
03:22:39 <lambdabot>  [0.0,-0.30116867893975674,0.11192907418083553,-2.4140686862961114e-2,0.16590...
03:23:07 <lispy> > drop 100 $ zipWith (-) (iterate cos 1.0) (iterate sin 1.0)
03:23:08 <lambdabot>  [0.5702326444871796,0.5710338649176506,0.5718237444528669,0.5726025487253179...
03:23:30 <xerox> ?oeis 0 1 0 -1 0 1 0 -1
03:23:30 <lambdabot> Periodic sequence 1,0,-1,0...; expansion of 1/(1+x^2).
03:23:30 <lambdabot> [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,...
03:23:30 <lispy> so the question is, what is that converging to?
03:23:48 <lispy> what the?
03:23:51 <lispy> ?help oeis
03:23:52 <lambdabot> oeis <sequence>. Look up a sequence in the Online Encyclopedia of Integer Sequences
03:24:05 <lispy> I'll be an uncle's monkey...
03:24:24 <dmwit> bwuh
03:24:32 <dmwit> 1/(1+x^2)?
03:24:49 <dmwit> Oh, some kind of Taylor expansion?
03:25:03 <oerjan> probably
03:25:04 <solrize_> yeah, 1/(1-x) = 1 + x + x**2 + x**3 + ...
03:25:24 <solrize_> those 1,0,1,0... are coefficients of the polynomial
03:25:28 <oerjan> > iterate cos 1.0 !! 1000
03:25:29 <lambdabot>  0.7390851332151607
03:25:34 <oerjan> > iterate cos 1.0 !! 1001
03:25:35 <lambdabot>  0.7390851332151607
03:25:48 <lispy> > drop 1000 $ zipWith (-) (iterate cos 1.0) (iterate sin 1.0)
03:25:49 <lambdabot>  [0.6844921617049755,0.6845192757449582,0.6845463494097883,0.6845733827995936...
03:25:57 <oerjan> > drop 1000 $ iterate sin 1.0
03:25:58 <lambdabot>  [5.4592971510185134e-2,5.456585747020246e-2,5.4538783805372415e-2,5.45117504...
03:26:07 <lispy> > drop 2000 $ zipWith (-) (iterate cos 1.0) (iterate sin 1.0)
03:26:08 <lambdabot>  [0.700422831934273,0.7004324631119172,0.7004420870940358,0.7004517038895851,...
03:26:23 <lispy> > drop 5000 $ zipWith (-) (iterate cos 1.0) (iterate sin 1.0)
03:26:23 <lambdabot>  [0.7146086880624594,0.7146111319474814,0.7146135751005517,0.7146160175220356...
03:26:36 <oerjan> hm sin -> 0 probably
03:26:48 <lispy> oerjan: yeah, that's what i expect
03:26:59 <Deewiant> > iterate sin 1.0 !! 1000
03:26:59 <lambdabot>  5.4592971510185134e-2
03:27:28 <Deewiant> awfully slowly
03:27:48 <oerjan> sin x ~ x for x ~ 0
03:28:50 <lispy> > foldl (-) $ zipWith (-) (iterate cos 1.0) (iterate sin 1.0)
03:28:51 <lambdabot>   add an instance declaration for (Num [a])
03:28:55 <lispy> > foldl1 (-) $ zipWith (-) (iterate cos 1.0) (iterate sin 1.0)
03:28:59 <lambdabot> Terminated
03:29:07 <solrize_> > let newton f x = (let x1 = x - (f x)/(d f x) in x1:(newton f x1); d f x = (let h=0.0001 in (f(x+h)-f(x-h))/(2*h) in newton cos 1
03:29:07 <lambdabot> Unbalanced parentheses
03:29:11 <oerjan> but in any case if it -> 0, then the difference goes to what cos went to, which seemed fast enough
03:29:42 <ZsoL> > let newton f x = (let x1 = x - (f x)/(d f x) in x1:(newton f x1); d f x = (let h=0.0001 in (f(x+h)-f(x-h))/(2*h) in newton cos 1)
03:29:42 <lambdabot> Unbalanced parentheses
03:30:10 <solrize_> > let newton f x = (let x1 = x - (f x)/(d f x) in x1:(newton f x1); d f x = (let h=0.0001 in (f(x+h)-f(x-h))/(2*h)) in newton cos 1
03:30:10 <lambdabot> Unbalanced parentheses
03:30:13 <solrize_> zzz
03:30:33 <oerjan> > iterate cos 0.7
03:30:34 <lambdabot>  [0.7,0.7648421872844885,0.7214916395975273,0.7508213288394496,0.731128772573...
03:30:35 <xerox> > (iterate (pred . cos) 1.0 !! 1000) - 1
03:30:36 <lambdabot>  -1.0
03:30:36 <solrize_> > let newton f x = (let x1 = x - (f x)/(d f x) in x1:(newton f x1)); d f x = (let h=0.0001 in (f(x+h)-f(x-h))/(2*h)) in newton cos 1
03:30:37 <lambdabot>  [1.6420926170045438,1.570675277036751,1.5707963267956897,1.5707963267948966,...
03:30:43 <xerox> much faster :)
03:31:07 <solrize_> > let newton f x = (let x1 = x - (f x)/(d f x) in x1:(newton f x1)); d f x = (let h=0.0001 in (f(x+h)-f(x-h))/(2*h)) in newton (\x->cos x - x) 1
03:31:08 <lambdabot>  [0.7503638676500973,0.7391128909028275,0.7390851333852653,0.7390851332151607...
03:31:35 <solrize_> > let newton f x = (let x1 = x - (f x)/(d f x) in x1:(newton f x1)); d f x = (let h=0.0001 in (f(x+h)-f(x-h))/(2*h)) in newton (\x->sin x - x) 1
03:31:36 <lambdabot>  [0.655145072717934,0.43359037021814306,0.2881484044942969,0.1918323182748828...
03:31:41 <solrize_> hmm
03:31:48 <solrize_> > let newton f x = (let x1 = x - (f x)/(d f x) in x1:(newton f x1)); d f x = (let h=0.0001 in (f(x+h)-f(x-h))/(2*h)) in newton (\x->sin x - x) 0.5
03:31:49 <lambdabot>  [0.331931941497139,0.22088000524055437,0.14713339625167557,9.805352006867539...
03:32:00 <solrize_> > iterate sin 1
03:32:01 <lambdabot>  [1.0,0.8414709848078965,0.7456241416655579,0.6784304773607402,0.627571832049...
03:32:07 <solrize_> > iterate sin 1 !! 100
03:32:08 <lambdabot>  0.16885248872798111
03:33:51 <lispy> after 5000000 iterations I can get it to about 0.001
03:34:08 <solrize_> google "oleg zipper" => "
03:34:08 <solrize_> Oleg Cassini Luggage Sets Flight 360 Spinner 3-Piece Set: Compare ...
03:34:08 <solrize_> Heavy duty #10 zipper on main packing compartment. Fully lined interior. ... Save on Oleg Cassini Luggage Sets. 110% Price Guarantee. Free Shipping"  sigh
03:34:36 <lispy> heh
03:34:40 <dmwit> solrize_: Try ~oleg ~zipper
03:34:59 <solrize_> gets about the same result
03:35:08 <solrize_> that luggage one was about halfway down the page, i just thought it was funny
03:35:15 <dmwit> oh
03:35:21 <lispy> ?go oleg haskell zipper
03:35:24 <lambdabot> http://okmij.org/ftp/
03:35:24 <lambdabot> Title: This FTP site
03:36:42 <lispy> > fix cos
03:36:43 <lambdabot>  Exception: <<loop>>
03:37:16 <dancor> what's the state of a recommended way to do error handling in new programs, as per http://article.gmane.org/gmane.comp.lang.haskell.libraries/6382
03:37:20 <lambdabot> Title: Gmane -- Mail To News And Back Again
03:37:42 <solrize_> Either
03:37:48 <dancor> ok
03:38:06 <solrize_> but I think the error message should be an enumerated code rather than a string
03:38:07 <oerjan> Either what? ;)
03:38:43 <solrize_> data Error_code = Out_of_space | Power_failure | User_too_stupid | ...
03:38:50 <solrize_> instance Error Error_code
03:39:01 <dancor> ok but i'm not using _'s :)
03:39:19 <solrize_> f :: Fruit -> Either Error_code Watermelon
03:39:24 <taruti> solrize_: then it becomes an issue of composing errors from different libraries.
03:40:18 <lispy> dolio: reading the blog post in that article should help you decide which to use too
03:40:24 <taruti> since every of them will have a custom error type and needs to be wrapped.
03:40:30 <solrize_> yeah but i think the experts here the other day said use error except for real system failures
03:40:34 <lispy> dolio: sorry mistell
03:40:41 <lispy> dancor: reading the blog post in that article should help you decide which to use too
03:41:48 <dancor> well i know i want to stay away from "8. go nuts" and anything with Dyn..
03:42:27 <solrize_> hmm, the arbitary-monad method looks good
03:42:45 <dancor> i think i'll start with Either String and see how much i hate my String type-cowardice
03:43:24 <dancor> it's like using general exceptions instead of custom ones
03:43:32 <solrize_> @src Typeable
03:43:32 <dancor> why isn't that more of a problem in e.g. pytohn
03:43:32 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
03:43:52 <dancor> the "composing errors from different libraries" problem
03:44:01 <solrize_> python apps tend to ignore errors and just crash with a stack trace
03:44:14 <dancor> at least it keeps things simple :)
03:45:03 <dancor> either is interesting because it makes the errors not like errors at all, just different kinds of responses
03:45:26 <solrize_> well they abort the computation in the error monad
03:45:33 <lispy> the generic monad way is probably the nicest for most uses
03:45:44 <lispy> fail "blah"; return foo
03:46:01 <lispy> let your user decide what monad to usne
03:46:21 <solrize_> :t fail
03:46:22 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
03:46:56 <dancor> so that's a generalized Either String
03:47:22 <lispy> yeah, but it also works for Maybe a
03:47:30 <lispy> you just lose the text
03:47:30 <solrize_> @src fail
03:47:30 <lambdabot> fail s      = error s
03:47:35 <solrize_> @src error
03:47:36 <lambdabot> error s = throw (ErrorCall s)
03:48:01 <lispy> ?instance (Either String)
03:48:01 <lambdabot> Maybe you meant: instances instances-importing
03:48:15 <lispy> well, fail doesn't always == error
03:48:21 <dancor> so it looks like fail or Control.Monad.Error if you want types are the winners
03:48:22 <lispy> I'm not sure which monad it's getting that from
03:48:35 <solrize_> getting what from?
03:48:42 <lispy> fail = error
03:48:48 <lispy> that's not true in general
03:48:51 <solrize_> oh hmm
03:48:55 <solrize_> io ?
03:49:00 <lispy> that's my guess
03:49:17 * dancor is freaked out when lbot specializes types arbitrarily
03:49:18 <oerjan> lispy: no, it's the default
03:49:29 <dancor> well i guess not arbitrarily.  defaultily
03:49:45 <lispy> for maybe, fail = const Nothing
03:49:58 <Deewiant> @src Maybe fail
03:49:58 <lambdabot> fail _      = Nothing
03:50:08 <quicksilver> fail is bad advice.
03:50:11 <quicksilver> it shouldn't be there.
03:50:13 <lispy> ?src [a] fail
03:50:13 <lambdabot> Source not found. I am sorry.
03:50:17 <lispy> ?src [] fail
03:50:18 <lambdabot> fail _      = []
03:50:20 <quicksilver> its only excuse is H98 compliance
03:50:28 <quicksilver> if you're not scared of MPTCs, use throwError
03:51:50 <RayNbow> http://www.valuedlessons.com/2008/03/why-are-my-monads-so-slow.html ++ http://reddit.com/r/programming/info/6cqw8/comments/
03:51:53 <lambdabot> Title: Valued Lessons: Why are my monads so slow?, http://tinyurl.com/3ywrlr
03:51:55 <RayNbow> (Python)
03:52:43 <quicksilver> personally I think Either String is the correct solution for typical small programs.
03:52:58 <quicksilver> Either (ErrorType) for larger programs or libraries with complex error reporting needs
03:53:02 <solrize_> it's more functional.  throw is way ugly.
03:53:17 <quicksilver> I don't find the composition of different libraries error types to be an issue.
03:53:26 <quicksilver> You only have to write a little stub to embed one in the other
03:53:28 <quicksilver> it's not hard to do.
03:53:43 <quicksilver> and it keeps you honest + precise about your exception types.
03:54:31 <dancor> can you use fail with ErrorType
03:54:56 <quicksilver> no
03:55:00 <dancor> why not
03:55:05 <quicksilver> because that's not its type
03:55:08 <quicksilver> :t fail
03:55:08 <oerjan> :t fail
03:55:09 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
03:55:09 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
03:55:12 <quicksilver> just don't use fail.
03:55:14 <quicksilver> it's broken and stupid
03:55:17 <quicksilver> and a mistake.
03:55:29 <dancor> so many conflicting opinions
03:55:31 <quicksilver> (at least, don't use it for exception handling :P)
03:55:33 <RayNbow> fail fails? :p
03:55:40 <Deewiant> fail fails at failure
03:55:43 <quicksilver> RayNbow: fail = epic fail
03:55:55 <dancor> metafail :: (String -> m a) -> n b
03:55:57 <Deewiant> :t epic
03:55:58 <lambdabot> Not in scope: `epic'
03:56:40 <dancor> quicksilver: how is fail bad
03:56:46 <quicksilver> it's in the wrong class.
03:56:49 <quicksilver> monads do not have failure.
03:56:59 <quicksilver> it is wrong for fail to be in the monad class.
03:57:04 <quicksilver> :t throwError
03:57:04 <lambdabot> forall e (m :: * -> *) a. (MonadError e m) => e -> m a
03:57:11 <quicksilver> throwError is "fail done right"
03:57:33 <quicksilver> (in the case that you have a 'message' or exception to pass)
03:57:49 <quicksilver> mzero is "fail done right" if it doesn't have an argument.
03:58:58 <scook0> don't you have to know e before you can call throwError?
03:59:13 <scook0> with fail you can just provide a string
03:59:33 <scook0> I realize that fail is in the wrong class, but throwError doesn't seem to be a complete replacement
03:59:38 <quicksilver> why not?
03:59:44 <quicksilver> you can make e String if you want it to be
03:59:51 <quicksilver> you can have a Monad whose exception type is strings
03:59:53 <quicksilver> if that's all you want.
04:00:11 <quicksilver> "e" is under your control. Well, the control of the programmer.
04:00:17 <scook0> but then my function can at best be polymorphic in (MonadError String m)
04:00:22 <scook0> which is not terribly convenient
04:00:26 <quicksilver> eh
04:00:31 <quicksilver> you can't have it both ways, ffs :P
04:00:33 <scook0> e.g. IO is incompatible
04:00:49 <quicksilver> your function must know what kind of error it can throw
04:01:01 <quicksilver> how can you expect to have a function which throws errors and doesn't know what type?
04:01:25 <quicksilver> (note that the "fail" instance in ErrorT does do coercion from strings though, if that's what you want)
04:01:34 <quicksilver> @src ErrorT fail
04:01:34 <lambdabot> fail msg = ErrorT $ return (Left (strMsg msg))
04:01:41 <quicksilver> :t strMsg
04:01:41 <lambdabot> forall a. (Error a) => String -> a
04:01:59 <quicksilver> but in fairness that's pretty much a hack around the broken fail type in the first place.
04:02:31 <scook0> I think I'll stick with fail
04:02:50 <scook0> in this particular code, all the monad-polymorphic stuff has tighter restrictions than Monad anyhow
04:03:24 <dancor> is there a os-agnostic way to combine file-paths
04:03:28 <quicksilver> yes.
04:03:29 <scook0> all I want to do is say "something went wrong; here's a string so the programmer can figure out what happened"
04:03:49 <quicksilver> then you could have a MonadError String constraint
04:03:55 <quicksilver> seems to me that's more honest than just using state
04:03:57 <quicksilver> :t </>
04:03:58 <lambdabot> parse error on input `</>'
04:04:01 <quicksilver> :t (</>)
04:04:02 <lambdabot> Not in scope: `</>'
04:04:09 <quicksilver> :t (System.FilePath.</>)
04:04:10 <lambdabot> FilePath -> FilePath -> FilePath
04:04:14 <quicksilver> dancor: there
04:04:18 <scook0> but then I can't call my functions directly in IO
04:04:22 <dancor> noice
04:04:30 <scook0> which I suppose is not absolutely necessary, but it would be a royal pain to lose
04:04:38 <quicksilver> @instances MonadError
04:04:39 <lambdabot> IOError IO, e (Either e), e (ErrorT e m), e (RWST r w s m), e (ReaderT r m), e (StateT s m), e (WriterT w m)
04:04:42 <scook0> (e.g. I could no longer easily call my functions from GHCi)
04:05:23 <quicksilver> runErrorT is not many characters :)
04:06:04 <scook0> that would get tedious very quickly
04:06:11 <quicksilver> there is probably more about your code I don't understand, though.
04:06:29 <scook0> yeah, the error-handling situation is a bit weird
04:06:51 <scook0> (for what I'm working on)
04:07:53 <scook0> while I'm ranting, let me complain about throwDyn
04:08:11 <scook0> and how much fun it is for your program to crash, saying "Error: (unknown)"
04:08:47 <quicksilver> how hard is to use catchDyn to report errors properly?
04:08:51 <quicksilver> (hint, not very...)
04:08:52 <quicksilver> :P
04:08:56 <scook0> (the solution being to have a top-level catch-all handler for any dynamic error that might escape)
04:09:37 <scook0> it's just annoying that throwDyn doesn't require a String/Show
04:10:22 <scook0> and again, my use of it is probably a bit unusual
04:10:26 <quicksilver> I think it would be annoying if it did.
04:10:43 <quicksilver> Note that you are free to always use a particular type which definitely does support Show
04:10:54 <quicksilver> and then you can use catch to display the error
04:11:06 <quicksilver> you can trivially write your own version of catchDyn for this custom type too
04:11:50 <scook0> as it turned out, I decided to abandon throwDyn and just use fail
04:12:13 <scook0> because the underlying library doesn't really give useful error feedback anyway
04:12:28 <scook0> so having my own exception type turned out to be useless
04:12:56 <scook0> but at least now I have accurate reports of which function failed, and what its arguments were
04:14:44 <dmwit> ?let strlen = genericLength . show
04:14:44 <lambdabot> <local>:9:25:     Ambiguous type variable `a' in the constraint:       `Show ...
04:15:50 <sergio_> Hello, does anybody uses hmake with ghc-6.8? I have problems with it. I need to use hmake to be able to use the hat debugger
04:37:51 <Esteth> Just popping in to tell everyone that was helping me yesterday evening with monads that i think i understand them now. Thanks for all the help guys, if you're still around
04:38:49 <dmwit> Sweet, good work!
04:39:03 <quicksilver> yay
04:39:05 <quicksilver> \o/
04:39:38 <quicksilver> sergio_: I think hmake (and indeed hat) are a bit bitrotted.
04:39:48 <quicksilver> malcolmw might be able to help you with hat, but he isn't around at the moment
04:44:47 <sergio_> thank you quicksilver. I had looked now for avoiding hmake and use hat-trans directly but many libraries are not supported
04:45:07 <sergio_> what is people using for debugging?
04:48:12 <dmwit> Well, in ghci 6.8 there's a built-in debugger.
04:48:34 <dmwit> I'm stuck on 6.6, but I mostly use "reasoning" for debugging.
04:50:18 <sergio_> mm, for the things I was debugging the step by step facility of ghc was not very informative
04:51:10 <sergio_> probably I need to spend more time learning to use it
04:51:16 <dmwit> Well, there's always Debug.Trace.
04:51:21 <dmwit> ?quote oasis
04:51:21 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
04:51:28 <scook0> @type either
04:51:32 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
04:51:53 <dmwit> either, maybe, bool... I *love* catamorphisms!
04:52:40 <sergio_> I'll look how it works.
04:53:14 <dmwit> sergio_: It just guarantees that it will print its first argument before the second argument is evaluated.
04:53:32 <dmwit> sergio_: The output can come in an odd order, but that's what laziness does to you. =P
04:55:41 <quicksilver> I never use trace, prefering instead to try out individual little functions in ghci and work upwards.
04:55:50 <quicksilver> as I zero in on unexpected behaviour
04:55:58 <quicksilver> (and then encode it in a regression test!)
04:57:48 <dmwit> Right, that's more or less what I meant by "reasoning".
04:59:10 <dmwit> Something I've found helpful in the past is to actually write tricky code twice; once with an algorithm that is really dumb and slow (but *obviously* correct ;-) and once with an algorithm that performs well.
04:59:58 <dmwit> Then you can take as long as you want comparing outputs, and just use the performant version after you've verified that it is pretty likely to be correct.
05:00:01 <integral> iirc it's _Writing Solid Code_ that recommends that so you can have automatic cross-checks between them in development builds
05:02:18 <quicksilver> dmwit: that's called writing a specification for your algorithm. What's nice about haskell is that it is a good language for writing specifications in :)
05:02:34 <quicksilver> and then quickcheck lets your compare specificaton to implementation.
05:03:15 <quicksilver> you can do the same trick for datastructures, too.
05:03:47 <quicksilver> I have a set of btree code which is polymorphic over representation, so you can run it against an 'in-memory model' of a btree, as well as an ondisk one.
05:04:31 <sergio_> thx dmwit and quicksilver. I'll be looking at those tools
05:10:38 <MarcWeber> How to generate the header files containing __stginit_<Module to be used from C> ?
05:21:54 <scook0> @hoogle Either a b -> (a -> a') -> Either a' b
05:21:54 <lambdabot> Did you mean: Either a b -> (a -> A') -> Either A' b
05:22:02 <scook0> @hoogle Either a b -> (a -> a1) -> Either a1 b
05:22:03 <lambdabot> Did you mean: Either a b -> (a -> A1) -> Either A1 b
05:24:25 <nominolo> @pl \j n -> maybe' m (\x -> maybe' (k x) j n) n
05:24:25 <lambdabot> join . (maybe' m .) . flip . flip (maybe' . k)
05:24:37 <nominolo> @pl maybe' m (\x -> maybe' (k x) j n) n
05:24:37 <lambdabot> maybe' m (flip (flip maybe' j . k) n) n
05:36:19 <SamB> whoa, ISO 14755 is neat
05:36:34 <SamB> I just typed 朝日
05:38:25 <lispy> MarcWeber: that sounds like an FFI question.
05:40:56 <MarcWeber> lispy it is :) I've found an old post (2005) using .hc insteoad of .hs Maybe this helps?
05:41:29 <MarcWeber> Now I'm getting cc1: error: unrecognized command line option "-fno-toplevel-reorder"
05:41:40 <MarcWeber> Perhaps I have to use an older gcc ?
05:41:51 <MarcWeber> or a newer one?
05:42:02 <MarcWeber> using 4.1.2 currently
05:43:10 <lispy> MarcWeber: The ghc manual has a section on FFI, have you looked at it yet?
05:43:36 <lispy> If so, then your next place to look in the haskellwiki
05:44:03 <lispy> I don't know how accurate a post from 2005 will be
05:44:21 <lispy> MarcWeber: there is also a section in the H98 report about FFI, but I don't know if it's useful
05:44:33 <SamB> I should think not
05:44:37 <SamB> I had no idea it was there...
05:44:52 <SamB> try reading the FFI addendum?
05:45:09 <lispy> SamB: the addendum is what i meant by "section" :)
05:45:12 <SamB> oh.
05:45:17 <SamB> that's not *in* the report
05:45:32 <lispy> http://www.haskell.org/haskellwiki/FFI_Introduction
05:45:33 <lambdabot> Title: FFI Introduction - HaskellWiki
05:45:39 <SamB> that's a seperate document which has some kind of official blessing, along with hierarchical module names
05:45:52 <lispy> http://haskell.cs.yale.edu/haskellwiki/GHC/Using_the_FFI
05:45:53 <lambdabot> Title: GHC/Using the FFI - HaskellWiki
05:46:03 <lispy> those two articles should help
05:46:05 <SamB> afaict, it's not even found on haskell.org
05:46:56 <lispy> the second link has quite a bit of code
05:46:58 * SamB wonders why rxvt-unicode-ml is only 5k bigger than the rxvt-unicode
05:47:19 <lispy> because rxvt is about as lightweight as a terminal can get?
05:47:34 <SamB> maybe it uses more memory or something...
05:47:43 <lispy> what does -m1 mean?
05:47:43 <gnuvince> urxvt++
05:47:49 <SamB> well, why bother having two packages if they are so close in size?
05:47:57 <SamB> multiple-language
05:48:01 <gnuvince> lispy: it's -ml, mutli-language
05:48:25 <lispy> 1 and l look pretty much identical on my screen.  What a crappy programming font.
05:48:52 <gnuvince> lispy: dejavu ftw
05:49:37 <lispy> SamB: oh, so you're saying for a measly 5k you get a superset?
05:49:48 <mauke> 1lI O0 rnm
05:50:12 <SamB> 5k of files on-disk, yes
05:50:22 <lispy> \/\/ |-| /-\ t?
05:50:54 <therp> bitstream vera monospace w0Ot!
05:50:57 <Deewiant> _ _        _ _ |  |-| /-\ |
05:50:57 * lispy remembers the time he filtered everything he said in irc through figlet first...
05:51:00 <Deewiant> darn
05:51:07 <mauke> ｗｈａｔ ｙｏｕ ｓａｙ
05:51:16 <SamB> mauke: stop speaking japanese
05:51:31 <Deewiant> ¿ǝsǝuɐdɐɾ
05:51:42 <mauke> ooh, I need that script
05:51:44 <lispy> I'm only utf8, I can't read any of that
05:51:54 <therp> lispy: that's all utf8
05:51:55 <SamB> you need better fonts
05:51:56 <Deewiant> it's all UTF-8
05:51:58 <Deewiant> mauke: http://www.revfad.com/flip.html
05:51:58 <lambdabot> Title: Flip
05:52:12 <lispy> I need better fonts, I can't read any of that
05:52:24 <Deewiant> dejavu ftw, as gnuvince said
05:52:27 <lispy> stupid putty
05:52:44 <SamB> lispy: oh, putty
05:52:46 <mauke> i s   t h i s   b e t t e r ?
05:52:56 <SamB> I recently patched jhc to make it work better in putty...
05:53:00 <Deewiant> this is putty, and it looks good to me
05:53:01 <lispy> did mauke just ask about butter?
05:53:14 <Japsu> U
05:53:16 <Zao> lispy: My putty does WTF-8 just fine, provided you use a sane font and pick the UTF-8 locale.
05:53:23 <Zao> s/locale/translation/
05:53:29 <SamB> Zao: what font?
05:53:31 <Japsu> l
05:53:40 <Japsu> heheh
05:53:43 <lispy> I did pick UTF-8, but my font options were lame.
05:54:03 <Japsu> recode_out_default_charset=UTF-16 clearly does not cause profit to be had
05:55:18 <Zao> Japsu: Very few terminals like anything else than 8-bit charsets.
05:55:40 <Deewiant> cmd.exe likes UTF-16
05:55:57 <lispy> cmd.exe is prue evil
05:56:05 <Deewiant> but then, ... yeah. :-P
05:57:30 <Zao> http://blogs.msdn.com/michkap/archive/2008/03/18/8306597.aspx http://blogs.msdn.com/michkap/archive/2008/03/19/8323216.aspx
05:57:44 <Japsu> Zao: I didn't touch term_charset.
05:59:29 <lispy> does utf-8 mean 8bits per char?
05:59:39 <Deewiant> define 'char'
05:59:39 <scook0> no
06:00:38 <scook0> UTF-8 encodes each Unicode codepoint into 1-4 bytes
06:00:41 <lispy> I don't know if it's because I'm a stupid american programmer or what, but this whole locale business is a mystery to me
06:01:17 <lispy> scook0: so something in each byte tells you if you should read the next one too?
06:01:55 <scook0> well utf8 has a nice property that many multibyte encodings don't have
06:02:01 <ivan> lispy: http://www.joelonsoftware.com/articles/Unicode.html
06:02:02 <lambdabot> Title: The Absolute Minimum Every Software Developer Absolutely, Positively Must Know A ...
06:02:40 <lispy> ivan: thanks, I was just looking for that article, but I couldn't remember enough of the title to find it
06:02:44 <scook0> you can always tell whether a given byte is a single-byte char, the start of a multi-byte char, or the continuation of a multi-byte char
06:02:52 <ivan> i googled absolute minimum programmer
06:03:25 <scook0> ascii codepoints take one byte
06:03:38 <scook0> most alphabets take two bytes per char
06:04:01 <scook0> and kanji generally take three
06:04:23 <scook0> the stuff that encodes to four bytes is pretty esoteric
06:04:36 <Deewiant> mostly dead languages
06:05:12 <scook0> Deewiant: and CJK supplements
06:05:18 <Deewiant> aye
06:05:25 <Deewiant> and then there's the private use area
06:06:35 <mauke> s s  s
06:06:38 <mauke> hmm
06:07:22 <mauke> lǝʇ,s ʇɹʎ ʇɥıs ɐƃɐıu
06:08:02 <Cheery> I'd like to know about logic programming by narrowing
06:08:19 <Cheery> do you know one single good paper that explains this stuff called narrowing?
06:09:15 <Cheery> or sth. else that'd explain it
06:09:21 <Cheery> anything would go
06:13:28 * DQuest switches to UTF-8 mode
06:13:37 <DQuest> bring on your crazy charsets!
06:13:51 <mauke> ǝʌıʇɐɯɹıɟɟɐ
06:14:04 <DQuest> OK, nevermind.
06:21:48 <Cheery> ☠☠☠☠☠☠
06:22:05 <Cheery> ʌ seems like an useful character
06:22:38 <DQuest> Looks like I can't get utf-8 going
06:22:40 <DQuest> how annoying
06:22:43 <Cheery> its A) a fighter plan B) some wacky combinator
06:23:49 <lispy> okay, that article helps a lot
06:23:50 <Cheery> C) a decapitated lambda
06:24:38 <ziman> conjunction :)
06:24:58 <lispy> now i know what unicode/usc-n/utf-8/utf-16/encoding mean, but I still don't know how to manage those details in a program
06:25:31 <Cheery> lispy: ?
06:25:40 <Cheery> those are character encodings
06:25:56 <Cheery> haskell strings are unicode strings
06:26:19 <lispy> they are codepoints, right?
06:26:23 <lispy> the chars
06:26:35 <lispy> but can you specify the encoding?
06:26:47 <Cheery> I don't know
06:27:01 <quicksilver> in haskell?
06:27:04 <quicksilver> not in the core libs, no.
06:27:10 <quicksilver> the core libs are only capable of 8bit output.
06:27:16 <quicksilver> with no encoding choice.
06:27:28 <quicksilver> there are a variety of packages out there to fix that, though.
06:27:30 <lispy> interesting, so why have unicode characters?
06:27:31 <Cheery> maybe you can define those other encodings with your own types
06:27:42 <quicksilver> lispy: so that it's possible to write encoding libs? :)
06:28:10 <quicksilver> at least if the underlying information is there, the language is expressive enough to write the encoders.
06:28:18 <quicksilver> if it wasn't you'd be stuck with a whole new data type
06:28:29 <lispy> quicksilver: once you have unicode characters you really only need to do the leg work when you read/write the data somewhere, eh?
06:28:36 <quicksilver> right.
06:28:43 <lispy> interesting
06:28:57 <Cheery> lispy: unicode characters are there because scientists and other world wants few billion non-alphabetic characters.
06:29:42 <Cheery> inside the same textfile
06:29:44 <gnuvince> Ou parce que tout le monde ne parle pas ncessairement anglais.
06:30:06 <lispy> le monad!
06:30:12 <\z> lispy: Char is a unicode codepoint
06:30:18 <\z> > minBound :: Char
06:30:20 <DQuest> ha, I can paste some utf-8 into my input line and it's fine but as soon as it appears in the output area irssi doesn't like it
06:30:21 <lambdabot>  '\NUL'
06:30:27 <\z> maxBound :: Char
06:30:29 <DQuest>  Hello world, Καλημέρα κόσμε, コンニチハ
06:30:33 <\z> > maxBound :: Char
06:30:34 <lambdabot>  '\1114111'
06:30:40 <lispy> \z: ya, I even said so above :)
06:30:45 <mrd> /set term_charset utf8
06:30:51 <\z> I don't know about how the I/O system works, which may be where the limitation arises
06:30:51 <mrd> and make sure your terminal supports it
06:30:52 <DQuest> mrd: I have
06:30:57 <mrd> urxvt perhaps
06:31:02 <mrd> and are you using screen? screen -U I hope
06:31:06 <DQuest> Literally it appears correctly in the input line.  I can view the example file in another window in screen
06:31:10 <DQuest> yes
06:31:11 <\z> lispy: sorry, playing catchup.  ;-)
06:31:36 <lispy> mrd: hmm...my linux box is set to utf8 as the locale, do i still need screen -U?
06:31:51 <Cheery> btw. does there exist any font that'd have every character there can be?
06:31:55 <mrd> dunno
06:32:07 <DQuest> hmm, I don't have a term_charset variable.  It's term_type
06:32:28 <lispy> thanks for the charset education this morning :)
06:32:33 * lispy tries to sleep again
06:32:45 <mrd> i got irssi 0.8.10
06:32:50 <mrd> kinda old
06:33:09 <DQuest> looks like mine is even older
06:33:15 <DQuest> but it's not my machine so I can't upgrade it
06:36:08 <wkh> going back to sleep?
06:36:09 <wkh> wtf?
06:36:12 * wkh has to go to work soon
06:41:44 <nominolo> hm, has anyone tried to change mtl to use cps-style and see how performance changed?
06:42:52 <nominolo> s/cps-style/cps/
06:42:56 <mm_freak_work> hi there
06:46:09 <Saizan> nominolo: not all of it
06:46:49 <nominolo> Saizan: what do you mean?
06:47:17 <nominolo> Saizan: not everything has been transformed or not every thing can be transformed?
06:57:06 <glen_quagmire> I'm doing this alot:   do { pushEnv; ... val <- someAction;   popEnv; return val; }    am I hitting some idiot pattern?
06:57:19 <resiak> @ty bracket
06:57:21 <lambdabot> Not in scope: `bracket'
06:57:26 <resiak> d'oh
06:57:36 <nominolo> @hoogle bracket
06:57:36 <lambdabot> Control.Exception.bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
06:57:36 <lambdabot> Control.Exception.bracket_ :: IO a -> IO b -> IO c -> IO c
06:57:36 <lambdabot> Control.Exception.bracketOnError :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
06:57:39 <glen_quagmire> if I pass env around as parameter, i don't have to manage environment stack myself in my monad.
06:57:49 <resiak> hmm, i could have sworn there was a general bracket for any monad
06:58:34 <mauke> what kind of environment is this?
06:58:35 <nominolo> glen_quagmire: just add a withSavedEnv combinator
06:59:09 <glen_quagmire> mauke: Data.Map String Val.  nominolo oh that makes sense
06:59:32 <nominolo> or, if you never change env, use a reader monad
06:59:39 <mauke> yeah, but does it need to be modified by subactions? otherwise you can just use Reader
06:59:44 <nominolo> or reader-writer-state (RWS)
07:00:02 <glen_quagmire> oh it shoudl have been    pushEnv env;    and environment is actually, [Data.Map String Val]
07:00:28 <nominolo> glen_quagmire: there's a withReader combinator for the Reader monad
07:01:32 <glen_quagmire> i'm using StateT because actions modify (add new (String, Val)) environment
07:02:59 <nominolo> 'local' changes a read-only env temporarily
07:03:16 <nominolo> but if you modify it, then a withFoo combinator makes more sense
07:04:25 <glen_quagmire> withBlah looks like fmap
07:05:31 <mm_freak_work> is there something as simple to use as System.Console.SimpleLineEditor, which works better?  the SLE doesn't seem to detect EOF properly
07:05:49 <mm_freak_work> and it fails, when input is provided through a pipe
07:06:23 <glen_quagmire> and that's for *nix only
07:07:02 <mm_freak_work> it's for personal use, so i don't care much about portability here =)
07:08:03 <nominolo> readline or editline, maybe?
07:08:25 <mm_freak_work> oh…
07:08:52 <mm_freak_work> the documentation of Readline was pretty overwhelming, when i visited it last time
07:09:00 <nominolo> yep
07:09:04 <mm_freak_work> even easier to use than SLE, thank you =)
07:09:07 <nominolo> but there was some tutorial
07:09:58 <mm_freak_work> there is an example in the doc
07:11:02 <mm_freak_work> but readline refuses to work with pipes, too =/
07:13:17 <mm_freak_work> d'oh, no it works, my fault, sorry
07:13:50 <Saizan> nominolo: everthing can be trasnformed afaiu, there hasn't been extensive benchmarks
07:16:06 <Saizan> nominolo: roconnor found a significant speedup in his code for last ICFP
07:17:21 <ilyak> I have a feeling that XSLT is more monadic than functional: xsl:template is like variable-decl >>= variable-decl >>= node-set >> node-set >> node-set >> node-set
07:17:45 <ilyak> I wonder if it's possible to write monad that will allow to translate xsl to haskell 1:1
07:18:02 <Saizan> nominolo: seen this? http://r6.ca/blog/20071028T162529Z.html
07:18:03 <lambdabot> Title: Continuation Passing Style for Monads
07:19:28 <mm_freak_work>       input <- hIsTerminalDevice stdin >>= (\isTerm ->
07:19:28 <mm_freak_work>                  readline $ if isTerm then "> " else "")
07:19:34 <mm_freak_work> what would be your way to express this?
07:23:03 <Saizan> mm_freak_work: i'd probably give a name to (\isTerm -> if isTerm then "> " else "") and then use function composition
07:23:31 <MarcWeber> Do I need to call __stginit_<module name> when calling haskell from C?
07:24:00 <MarcWeber> Becouse ghc does'nt add it to the header file _stub.h and it seems to work without for my simple example..
07:26:37 <EvilTerran> i'd just have: isTerm <- hIsTerminalDevice stdin; let input = if isTerm then "> " else ""
07:27:23 <EvilTerran> unfortunately, we don't have if' or somesuch Bool deconstructor, otherwise it'd work nicely with <$>
07:27:49 <EvilTerran> input <- bool "> " "" <$> hIsTerminalDevice stdin -- kinda thingt
07:33:17 <nominolo> Saizan: yep.  but he did manual specialisation.  i was hoping we'd have it in a library
07:33:59 <nominolo> but i'll have some time to kill tomorrow.  maybe i'll give it a shot
07:34:54 <mm_freak_work> EvilTerran: wenn, you forgot the readline part
07:35:25 <dcoutts> nominolo: more cont monads ? :-)
07:35:49 <nominolo> dcoutts: yeah, you gave me the idea for a good exercise
07:35:50 <mm_freak_work> Saizan: your solution even increases code for something as trivial as this…  and it isn't too straightforward, since hIsTerminalDevice is a monadic computation
07:36:02 <dcoutts> nominolo: oh yes, what's that?
07:36:04 <nominolo> dcoutts: but i use forall in each
07:36:18 <nominolo> dcoutts: rewrite all mtl-monads to cps form
07:36:30 <dcoutts> nominolo: I was thinking about that yesterday too :-)
07:36:39 <nominolo> dcoutts: which is exactly olegs tagless stuff, i think
07:36:41 <dcoutts> nominolo: but yes, using polymorphic components
07:36:52 <nominolo> newtype State' s a = State' { runState' :: forall r . s -> (a -> s -> r) -> r }
07:36:55 <dcoutts> so that one does not expose the 'r' parameter
07:36:57 <dcoutts> right
07:37:08 <nominolo> works like charm
07:37:37 <tensh> I've never understood what forall really does
07:37:42 <nominolo> @hoogle a -> b -> (a, b)
07:37:42 <lambdabot> Control.Monad.RWS.Lazy.execRWS :: RWS r w s a -> r -> s -> (s, w)
07:37:42 <lambdabot> Control.Monad.RWS.Strict.execRWS :: RWS r w s a -> r -> s -> (s, w)
07:37:42 <lambdabot> Control.Monad.RWS.Lazy.evalRWS :: RWS r w s a -> r -> s -> (a, w)
07:37:42 <dcoutts> nominolo: and what I was thinking was that it might be a better approach to optimising stacked monads, ie ones build using transformers
07:37:54 <Saizan> nominolo: do you have an idea for monad transformers? it's hard to not duplicate the continuation
07:38:05 <nominolo> dcoutts: yes, that's exactly what i want to find out
07:38:26 <nominolo> Saizan: not yet.  maybe some RULES magic
07:38:39 <nominolo> with proper newtypes
07:38:40 <dcoutts> nominolo: though I think it might need a compiler optimisation, to do some 'unpacking' of function representations
07:38:42 <Saizan> or you could just transform the final stack in one go..
07:39:01 <nominolo> dcoutts: hm, yeah
07:39:33 <nominolo> that's why i want to transform all monads.  maybe i get a feel for how to do it automatically
07:39:49 <dcoutts> nominolo: I think that at least for state/reader/writer they all flatten down to a single cont function with multiple input/output args
07:40:01 <dcoutts> where output args are of course input args to the continuation
07:40:08 <boudewijnector_> Can someone help me on compiling some code?
07:40:22 <Saizan> nominolo: for every monad m you end up with forall r. ContT r m
07:40:24 <nominolo> yes, that's how the state transformation worked
07:40:27 <dcoutts> that's the transformation that I think might require help from the compiler
07:40:38 <nominolo> dcoutts: though it might just fall out of constructor specialisation
07:40:54 <nominolo> if we apply it also to non-recursive functions
07:40:55 <Boudewijnector> Can someone help me getting this to work? http://hpaste.org/6521
07:41:06 <dcoutts> nominolo: I don't think so, where is the constructor? they're all lambdas
07:41:07 <Boudewijnector> It seems to expect a different type, but I don't understand why
07:41:18 <nominolo> dcoutts: (,)
07:41:28 <nominolo>   m >>= k = State' $ \s k' -> runState' m s $ \a s' ->
07:41:28 <nominolo>                               runState' (k a) s' $ \b s'' ->
07:41:28 <nominolo>                               k' b s''
07:41:40 <dcoutts> nominolo: oh we should be able to unpack those too, currying
07:41:51 <nominolo> note the \a s' ->  instead of >>= \(a,s') ->
07:41:58 <dcoutts> right
07:42:25 <nominolo> and (>>=) = ($) in cps
07:42:50 <dcoutts> and ghc is pretty good at optimising $ :-)
07:43:17 <dcoutts> I used to think that cont style would be really slow, with all these higher order bits all over the place
07:43:36 <dcoutts> then I used that style for Data.Binary.Put and discovered it's amazing
07:43:39 <nominolo> dcoutts: it could be slow with laziness
07:44:12 <mm_freak_work>       input <- let promptIO = hIsTerminalDevice stdin >>= (\isTerm -> if isTerm then return "> " else return "")
07:44:15 <mm_freak_work>                in promptIO >>= readline
07:44:15 <nominolo> dcoutts: CPS is used as low-level language in compilers ;)
07:44:19 <mm_freak_work> Saizan: didn't save a lot IMO =/
07:44:29 <dcoutts> that we only end up making a lambda thunk where we have to lazily suspend, the strict bits completely optimise away
07:44:43 <Saizan> ah, yeah, CPS changes strictness properties
07:44:44 <dcoutts> nominolo: I know, though not in ghc
07:44:55 <nominolo> dcoutts: not *yet*
07:45:08 <PeakerWork> Boudewijnector, seems that it thinks the "a" in your interval type is Pos, rather than Int, right?
07:45:18 <nominolo> Saizan: does it?
07:45:18 <quicksilver> ndm's supercompiler goes through something like CPS form, doesn't it?
07:45:23 <PeakerWork> Boudewijnector, even though it doesn't satisfy (Floating a) =>
07:45:26 <quicksilver> but I think you do have to be careful about strictness.
07:45:33 <Boudewijnector> PeakerWork: yes
07:45:43 <mauke> Boudewijnector: it does that because of `notElem` concat shadow
07:45:47 <Boudewijnector> PeakerWork: but how to improve this? I tried to rewrite the header
07:46:04 <MarcWeber> Boudewijnector: Try Hmm Try any (const True) :)..
07:46:06 <mauke> concat shadow :: [Pos], therefore interval l r :: [Pos]
07:46:17 <PeakerWork> Boudewijnector, I am a beginner myself :-)
07:46:18 <mauke> therefore a = Pos = (Int,Int)
07:46:20 <Saizan> ?type runState
07:46:29 <lambdabot> forall s a. State s a -> s -> (a, s)
07:46:33 <glen_quagmire> how can I do "     abc asdfo jsodf a     "   ==>  "abc"  ? first word of a string
07:46:40 <mauke> glen_quagmire: head . words
07:46:51 <Boudewijnector> Let me have a look
07:46:56 <glen_quagmire> > (head . words) "     abc  hello"
07:47:00 <lambdabot>  "abc"
07:47:04 <glen_quagmire> mauke: thank you!
07:47:09 <Saizan> > let loop = loop >> put 1 in execState loop 0
07:47:09 <lambdabot>  1
07:47:21 <Saizan> nominolo: try that with your transformed monad ^^^
07:47:30 <PeakerWork> mauke, shouldn't it yell about the mismatch with (Floating a)=>   first?
07:47:31 <jekor> What's the easiest way to pull options from a list of ADTs for the options (like from getOpt example in the GHC documentation). I'd like to use find, but how do I test for equality with a constructor?
07:47:45 <mauke> PeakerWork: no, that's checked later
07:47:49 <PeakerWork> mauke, oh
07:47:49 <mauke> it doesn't get that far
07:47:59 <glen_quagmire> words is similar to lines.  is there a more general function that can split according to given string?
07:48:15 <jekor> glen: I just looked for that the other day. I ended up using a Parser.
07:48:16 <dcoutts> jekor: fooOptions = [ foo | FooOption foo <- allOptions ]
07:48:34 <glen_quagmire> jekor: oh thanks
07:48:34 <jekor> dcoutts: Thanks. I guess I need to read up on list comprehensions.
07:49:00 <jekor> There were some other functions on the web though. I'll see if I can find them.
07:49:10 <MarcWeber> Boudewijnector: Is your hpaste trouble solved?
07:49:22 <Boudewijnector> MarcWeber: i'm still trying to do so
07:49:23 <dcoutts> jekor: list comprehensions are great, so in that example we're filtering the list so it's only ones that match that constructor pattern
07:49:32 <MarcWeber> Boudewijnector: Have you seen my last message?
07:49:37 <nominolo> Saizan: oh, ok
07:49:44 <jekor> dcoutts: The comments were interesting on http://julipedia.blogspot.com/2006/08/split-function-in-haskell.html
07:49:46 <lambdabot> Title: The Julipedia: A split function in Haskell, http://tinyurl.com/fhss7
07:49:49 <Boudewijnector> MarcWeber: nop, but now i do
07:50:11 <MarcWeber> Boudewijnector: didn't know about notElem :)
07:50:12 <jekor> dcoutts: You can also look at the source for words. I think it's a simple recursive function in a few lines that you could clone.
07:50:29 <jekor> Er...
07:50:33 <jekor> Those to glenn.
07:50:42 <dcoutts> jekor: yes, I have a few variants on splitBy/splitOn lying around in various projects
07:50:48 <jekor> :)
07:50:57 <dcoutts> problem is that one always needs slightly different variants
07:51:08 <dcoutts> there is no one standard one that fits every problem
07:51:09 <Saizan> nominolo: i think this is related to the fact that you can't have a MonadFix instance for ContT
07:51:11 <nominolo> Saizan: i think apfelmus posted a solution to this by using a state accumulating parameter
07:51:29 <jekor> dcoutts: I suspected that there was some reason it wasn't included.
07:51:38 <nominolo> Saizan: there was some paper on how to do value-recursion for Cont
07:51:44 <nominolo> or presentation
07:51:58 <MarcWeber> Boudewijnector: Without knowing what your code should do it's hard to help
07:52:04 <shepheb> is there a list of functional pearl papers somewhere?
07:52:09 <nominolo> but it used some elaborate tricks
07:52:09 <Saizan> nominolo: oh, do you have any pointers?
07:52:15 <Boudewijnector> MarcWeber: it's the beginning of a FOV algorithm
07:52:22 <MarcWeber> You any (`notElem` shadow ) .. causes the trouble.
07:52:31 <Boudewijnector> Okay, why?
07:52:36 <MarcWeber> Boudewijnector: Can yo udescribe in words what you like to do?
07:52:40 <nominolo> Saizan: http://www.google.se/url?sa=t&ct=res&cd=2&url=http%3A%2F%2Fwww.cse.ogi.edu%2F~magnus%2Fmdo-callcc-slides.pdf&ei=IXriR5P8MZvG0gS6orX5CA&usg=AFQjCNHJrHvsZ_C_IQQRE01xmHJHfVaRLA&sig2=SgeYGwRjp3RATkS_bIU-cQ
07:52:42 <lambdabot> http://tinyurl.com/3cgwvh
07:52:46 <nominolo> oops
07:52:53 <nominolo> www.cse.ogi.edu/~magnus/mdo-callcc-slides.pdf
07:52:56 <MarcWeber> Boudewijnector: Because shadow is a list of Pos, but intervval returns Float.
07:53:13 <Saizan> thnaks
07:53:16 <Boudewijnector> Sure,  Reachable l r =  there is an a, where a is in the interval domain of l r , and a is not in a collection
07:53:26 <MarcWeber> Boudewijnector: THus you're trying to check wether a Float is not contained in a list of Pos (don't know what your concat should do there)
07:53:35 <nominolo> http://www.cse.ogi.edu/pacsoft/projects/rmb/
07:53:35 <lambdabot> Title: Value Recursion in Monadic Computations
07:53:51 <Boudewijnector> Okay, that doesnt make sense indeed
07:57:39 <dcoutts> there just isn't enough Haskell code on hackage, the entire archive of .tar.gz packages comes to 69M (all versions of all packages)
07:58:35 * dcoutts goes off to write more Cabal/Haskage SoC proposals
08:00:21 <Lemmih> 69M of Haskell source code?
08:00:30 <nominolo> compressed
08:03:08 <Beelsebob> 69M compressed is really quite a lot
08:03:20 <glen_quagmire> 69M of haskell code can rewrite the universe
08:03:30 <Beelsebob> it probably compresses very well, I'd guess that probably means close to 69 million lines of code
08:03:38 <ivan_> if i have a module that imports another module, and i want to export one of the other modules constructor how do i do it?
08:04:18 <Lemmih> ivan_: You just export it.
08:04:21 <dcoutts> Beelsebob: we should get hackage to run sloccount on each package :-)
08:04:25 <byorgey> Beelsebob: probably not quite that much... one byte per line of code?
08:05:07 <Beelsebob> byorgey: considering the amount of indentation, probably along the lines of 60% of the text is gonna get taxen out just for whitespace
08:05:14 <byorgey> well, true...
08:05:14 <ivan_> Lemmih: dosn't work, i have imported Graphics.HGL in my module, and i have typed mymodule(Color) but when importing my module i cant use the Color constructors
08:05:20 <Beelsebob> and the amount of repeated text (how many maps are there gonna be in there)
08:05:31 <Lemmih> ivan_: Color(..)
08:05:38 <ivan_> :p silly me
08:05:39 <Beelsebob> I expect most functions can be compressed to fuck all
08:05:43 <ivan_> of course
08:05:51 <nominolo> Beelsebob: but note that it includes all versions of the packages
08:06:01 <Beelsebob> ah, okay
08:06:10 <nominolo> Beelsebob: so we count some packages 5 or more times
08:06:18 <Beelsebob> which will improve the compression
08:06:24 <Beelsebob> but not improve the amount of interesting code
08:06:56 <byorgey> that doesn't improve the compression, since each package version gets compressed separately
08:07:04 <Beelsebob> ah, bugger
08:07:29 <byorgey> so I think we're now at about a million lines of code
08:07:35 <byorgey> which is still pretty impressive =)
08:07:41 <ivan_> Lemmih: do u know why the lines get thick when drawing with color in HGL and without color they are fine and thin?
08:07:51 <Beelsebob> especially for Haskell
08:08:04 <Lemmih> ivan_: I have no idea.
08:10:47 <glen_quagmire> maybe colors make the lines thicker (perceptually)
08:11:05 <Boudewijnector> MarcWeber: I'm completely puzzled abou what to do.  I'd like to implement this piece of code: "reachable (l,r) =  (\exists a . a \in intertval (l,r) \and a \notin shadow)"
08:12:57 <MarcWeber> Boudewijnector: Can you tell me in English?
08:13:05 <Boudewijnector> yes
08:13:47 <Boudewijnector> reachable (l,r)  = IF there exists some 'a', where 'a' is in the result of interval (l,r) , and a is not in the shadow collection
08:15:10 <MarcWeber> Boudewijnector: That's the trouble intreval returns type a (Floating => a) .. but the shadow collection is [(l,r)] !
08:15:20 <MarcWeber> Boudewijnector: So what does "is in" mean here?
08:15:38 <Boudewijnector> I think , ' is in collection'
08:16:05 <MarcWeber> 2 `notElem` [(2,4),(4,0)] ?
08:16:14 <MarcWeber> @ Boudewijnector
08:16:26 <Boudewijnector> Well that won't work, obviously indeed
08:16:49 <MarcWeber> Boudewijnector: You have told me that some minutes ago.. So what are you trying to do?
08:17:28 <Boudewijnector> I don't know exactly,. The algorithm was given for an assignment
08:18:10 <Boudewijnector> Well I know some stuff. We're computing the angle of all tiles in a game, from a certain point (0,0) , and the blocks collection are the 'wall' tiles which block visibility
08:18:14 <MarcWeber> Boudewijnector: Why not try implementing it in PHP? Then it does compile at least :) *g*
08:18:29 <Boudewijnector> MarcWeber: I don't think kosmikus will like that
08:18:30 <MarcWeber> Boudewijnector: That's a lot more.
08:18:50 <byorgey> Boudewijnector: it seems to me since you don't care about the particular value of 'a', you shouldn't actually bother generating one
08:18:51 <Boudewijnector> furthermore, were' computing the angle of the specified tile
08:19:16 <byorgey> i.e. just deal directly with the interval (l,r) and see whether it intersects any of the intervals in the shadow collection
08:19:16 <byorgey> or something like that
08:19:27 <Boudewijnector> and if there's a blocking tile in the same range ,we know the first tile won't be visible (because we're moving away from the player)
08:19:47 <Boudewijnector> MarcWeber: So I do underrstand the algorithm, I guess
08:20:33 <jekor> OK, now I'm getting a different problem. This program worked before, but I just added argument parsing. I confirmed that inF and outF are the correct filenames.
08:20:40 <EvilTerran> ... this sounds like raycasting
08:20:56 <jekor> http://hpaste.org/6524
08:21:07 <MarcWeber> Boudewijnector: (0,0) _ } True.. Guess you can reach everything from the middle..
08:21:22 <Boudewijnector> Well, the players location is (0,0)
08:21:26 <Boudewijnector> So that's always visible!
08:22:10 * jekor slaps forehead.
08:23:00 <byorgey> jekor: figure it out? =)
08:23:33 <jekor> :)
08:23:49 <MarcWeber> Boudewijnector: What is a tile? A piece of a a cake?
08:24:00 <Boudewijnector> A tile is a Pos
08:24:23 <Boudewijnector> So it's just being depicted by coordinates
08:24:27 <MarcWeber> Boudewijnector: Isn't a tile an area?
08:24:36 <Boudewijnector> yes
08:24:51 <Boudewijnector> that's why were taking the extreme limits of it in the angle function
08:24:55 <Boudewijnector> the +|- 0.5
08:25:04 <MarcWeber> Boudewijnector: So [[Pos]] is a list of polygons?
08:25:06 <jekor> OK, even with the arguments in the correct order, I'm still getting the same problem.
08:25:43 <Boudewijnector> [[Pos]] is a list of list of positions, so a 2d list which lists all tiles of the game
08:25:51 <byorgey> jekor: can you paste an annotation with the new version?
08:25:56 <Boudewijnector> x-y coordinates of room
08:27:13 <byorgey> jekor: I haven't yet looked at your code carefully, but just to be sure you know, after calling hGetContents on a handle, it's put into a semi-closed state, and no further operations on the handle are allowed
08:27:18 <forkiliens> hi everyone. does somebody know where to start, if you want to write a simple formula manipulator?
08:27:45 <MarcWeber> Boudewijnector: What does reachable mean? Does the play look in any direction?
08:28:10 <jekor> byorgey: I'll keep that in mind. Before I added the getOpts stuff I was just using inFile = openFile "/tmp/fifo-in" ReadMode [...] and it was working.
08:28:25 <byorgey> forkiliens: you mean like a program that can do algebraic manipulations, e.g. you put in (x+1)^2 and it outputs x^2 + 2x + 1 ?
08:28:29 <Boudewijnector> MarcWeber: reachable means the player can see the tile (or mmore concise: There is no wall blocking the view of the tile from the player's perspective)
08:28:38 <jekor> I will post the new version as soon as I can figure out why the arguments are getting reversed.
08:28:43 <forkiliens> byorgey: yes, exaktly
08:28:55 <forkiliens> exactly like that.
08:29:07 <forkiliens> is there literature about it?
08:29:13 <byorgey> forkiliens: well, I would start by defining an appropriate data type that can describe the sorts of expressions you want to manipulate
08:29:33 <byorgey> then build up some operations to manipulate values of that type, starting simple and working your way up to more complex
08:29:38 <MarcWeber> Boudewijnector: Sho shadow is a list of "walls"?
08:29:47 <byorgey> and then write a parser and a pretty-printer last
08:30:03 <Boudewijnector> No
08:30:04 <forkiliens> ok, but what i meant is: are there maybe other people who have done similar work, so i don't have to start from scratch.
08:30:09 <byorgey> or sometime in the middle when you get annoyed at having to type things in manually
08:30:12 <Boudewijnector> Shadow is a list of invisible tiles
08:30:20 <Boudewijnector> The tiles *behind* the wall tiles
08:30:21 <byorgey> forkiliens: oh, I'm sure there are =)
08:30:21 <MarcWeber> Boudewijnector: You've tolde me: a list of tilse..
08:30:42 <Boudewijnector> Yes , sorry for not being that precise
08:30:45 <forkiliens> but not in haskell, right :)
08:30:51 <byorgey> forkiliens: what level are you thinking of?  you might check out some open source programs that can do that kind of thing
08:30:57 <byorgey> e.g. maxima
08:31:00 <MarcWeber> Boudewijnector: And behind means when looking from the point of the player (center)..
08:31:07 <Boudewijnector> yup
08:31:11 <byorgey> but I don't know if you're looking for something simpler to start
08:31:33 <Boudewijnector> There's a 'blocks' parameter to the function in which reachable is, containing all wall tiles
08:31:34 <MarcWeber> Boudewijnector: But if those tiles are behind walls I already know that I can't see (reach) them ?
08:31:44 <Boudewijnector> blocks is a list of Pos's
08:31:45 <byorgey> forkiliens: why do you want to write such a thing?
08:31:45 <doserj> jekor: the arguments are not getting reversed, I think
08:31:56 <Boudewijnector> Yes
08:32:04 <forkiliens> because i'm a tutor for mathematics
08:32:22 <forkiliens> and there isn't such a thing for students
08:32:32 <byorgey> forkiliens: there isn't?
08:32:35 <doserj> jekor: I think your "passThru" logic is confused...
08:32:40 <jekor> doserj: That's what I was hoping, because I'm going crazy otherwise.
08:32:45 <MarcWeber> Boudewijnector: So you can just do reachable = False ?
08:32:53 <MarcWeber> Boudewijnector: I'm still missing a point.
08:32:55 <byorgey> I was under the impression there is tons of such software
08:32:57 <forkiliens> if you think about mathematica, maple etc...
08:33:08 <forkiliens> that's tooo complicated for pupils
08:33:14 <forkiliens> they don't work with it.
08:33:17 <byorgey> I disagree.
08:33:17 <Boudewijnector> MarcWeber: what point are you missing?
08:33:22 <forkiliens> i have already tried it
08:33:26 <byorgey> but I guess it depends what age/level you are talking about
08:33:30 <Boudewijnector> http://www.cs.uu.nl/wiki/pub/Afp/ProgrammingTask/Practicum.pdf
08:33:36 <Boudewijnector> The assignment, it's on page 5
08:33:44 <Boudewijnector> Would you please have a look?
08:33:56 <MarcWeber> Boudewijnector: You want to get wether tiles are reachable. You only pass tiles beeing behind walls. Thus they all aren't reachabel. Thus you don't need a function ?
08:33:58 <doserj> jekor: what is "passThru (return stdin) i" supposed to do?
08:33:58 <byorgey> forkiliens: have you looked at sage?
08:34:09 <jekor> Found the problem and fixed.
08:34:12 <byorgey> I don't know too much about it but it might be interesting
08:34:21 <forkiliens> sage?
08:34:31 <forkiliens> have heard about it but never tried
08:34:50 <Boudewijnector> MarcWeber: no, let me think
08:34:52 <forkiliens> i havae tried about every computer algebra system there is. :9
08:34:55 <forkiliens> :9
08:34:57 <forkiliens> :)
08:34:57 <jekor> http://hpaste.org/6524#a1 <-- I had reversed the i and o.
08:35:20 <Boudewijnector> you compare the angles of the tiles you want to know about whether they're visible to the angle of wall-tiles
08:35:31 <byorgey> jekor: aha. =)  it works now?
08:35:37 <skorpan> is there any function which given a function (a -> Bool) and a list [a] returns the first "matching" element in the list? and i'm not looking for a combination of several functions.
08:35:45 <jekor> doserj: It confuses the heck out of me still. It (seems to!) pass stdin through to o and then pull from i to stdout.
08:35:54 <jekor> byorgey: *nod* :)
08:36:01 <glen_quagmire> how can I catch errors thrown by (maybe failed with) openFile ?
08:36:19 <byorgey> skorpan: no, there's no single function to do that.
08:36:20 <MarcWeber> Boudewijnector: So is the list of walls missing as input to reachabel then?
08:36:22 <jekor> Thanks everyone. Now off to work before I'm late!
08:36:22 <skorpan> byorgey: thanks
08:36:29 <glen_quagmire> i mean,    prog <- readFile moduleName      quits the interperter
08:36:44 <glen_quagmire> when moduleName can not be found
08:37:02 <Boudewijnector> MarcWeber: ?
08:37:26 <glen_quagmire> that line is ran inside Wrap monad which uses ErrorT. so, I exect the errors to be caught by Wrap monad
08:37:52 <quicksilver> glen_quagmire: use catch!
08:37:54 <byorgey> glen_quagmire: you still have to catch exceptions
08:38:12 <glen_quagmire> ah right i remember `catchError` from yesterday
08:38:29 <quicksilver> :t Data.List.find
08:38:32 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
08:38:42 <quicksilver> skorpan: maybe you're looking for that one?
08:38:48 <quicksilver> byorgey: does that one not count?
08:39:11 <glen_quagmire> is there a combinator that runs error-able actions ?
08:39:22 <glen_quagmire> so that I don't have to manually do catchError
08:39:23 <byorgey> quicksilver: er... NO! no, it doesn't. =P
08:39:40 <MarcWeber> Boudewijnector: Got it now. (l,r) passed at reachable is an edge of a wall..
08:39:47 * glen_quagmire writes one
08:39:48 <byorgey> skorpan: forgive me, I have failed you! =)
08:39:48 <quicksilver> :t try
08:39:49 <lambdabot> Not in scope: `try'
08:39:59 <quicksilver> :t Control.Exception.try
08:40:00 <lambdabot> forall a. IO a -> IO (Either GHC.IOBase.Exception a)
08:40:07 <quicksilver> glen_quagmire: that is, kind of.
08:40:08 <Boudewijnector> MarcWeber: you had a look at the PDF file?
08:40:21 <glen_quagmire> quicksilver: thank you
08:40:57 <MarcWeber> Boudewijnector: One sec
08:41:08 <forkiliens> byorgey: sage is written in python...
08:41:24 <skorpan> byorgey: filter did a pretty good job :/
08:41:34 <skorpan> not what i wanted, but..
08:41:48 <forkiliens> byorgey: but thanks anyway
08:41:48 <byorgey> forkiliens: indeed.
08:42:54 <quicksilver> skorpan: head . filter is like fromJust . find
08:43:09 <quicksilver> listToMaybe . filter is *exactly* find
08:43:12 <quicksilver> @src find
08:43:12 <lambdabot> find p          = listToMaybe . filter p
08:43:21 <skorpan> :t find
08:43:22 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
08:43:28 <skorpan> hm. what the heck.
08:43:48 <skorpan> thanks :P
08:48:26 * byorgey is amused at apparently being the loudest one in #haskell
08:48:38 <skorpan> how do you know that?
08:48:48 <byorgey> says so on http://www.cse.unsw.edu.au/~dons/irc/haskell-08.html
08:48:49 <lambdabot> Title: #haskell @ freenode.org stats by dons
08:49:06 <byorgey> I think it counts the number of exclamation points
08:49:17 <byorgey> apparently I use a lot of them?  who knew? =)
08:49:36 <skorpan> Is SamB stupid or just asking too many questions? 25.2% lines contained a question!
08:49:54 <MarcWeber> Boudewijnector: Where is the problem? You need to get an interval of the first passed pos as well. Than you can check wether the interval of the tiles behind is within it -> shadowed else visible
08:50:11 <Boudewijnector> Yes indeed
08:51:10 <Baughn> I talk less than hpaste. So saddening. :'(
08:51:27 <DQuest> well, I just had my last lecture ever
08:51:51 <Boudewijnector> MarcWeber: I just started trying to implement the reachable function
08:51:51 <byorgey> DQuest: is that good or bad?
08:52:01 <DQuest> Er, good, I guess
08:52:10 <byorgey> well, congratulations then =)
08:52:16 <DQuest> \o/
08:53:03 <DQuest> I think I could well end up researching type theory
08:53:46 <byorgey> DQuest: awesome!
08:56:00 * EvilTerran notes that he appears to be very active on here
08:56:26 <byorgey> EvilTerran: you didn't realize that before? =)
08:56:39 <EvilTerran> eh, i guess
08:56:59 <EvilTerran> ... why's "[]" on "most referenced nicks"? O.o
08:57:43 <byorgey> someone must have used [] as a nick at some point
08:57:57 * EvilTerran also notes that one of the "most referenced URLs" is a spam. someone should probably nix that.
08:59:37 <PeakerWork> lambdabot has quite a potty mouth. 0.0% words were foul language.
08:59:37 <PeakerWork> Cin also makes sailors blush, 0.0% of the time.
09:00:32 <EvilTerran> heh
09:06:42 <DQuest> well, that can change
09:06:53 <glen_quagmire> how can I test if a file exists?   isValid doesn't seem like it
09:07:05 <DQuest> > let animals = ["cock","ass","tit"] in animals
09:07:07 <lambdabot>  ["cock","ass","tit"]
09:07:20 <thoughtpolice> glen_quagmire: doesFileExist?
09:07:29 <glen_quagmire> if I just do readFile fn   then it the error it throws can't be caught by catchError
09:07:54 <DQuest> I bet that'd count as one word
09:08:00 <glen_quagmire> thoughtpolice: oh thank you!
09:08:04 <DQuest> (on a side note, what other animals are also crude words depending on context?)
09:08:07 <mauke> bad idea
09:09:53 <mauke> glen_quagmire: can't you just use catch?
09:10:12 <DQuest> > foldr (\x y -> x ++ " " ++ y) "" ["cock","tit","ass","margaret thatcher"]
09:10:14 <lambdabot>  "cock tit ass margaret thatcher "
09:10:23 <DQuest> lambdabot swears!
09:10:38 <DQuest> and that last one is a nasty 'un
09:10:42 * dcoutts submits three new Cabal/Hackage GSoC project proposals
09:10:46 <dcoutts> go sign up! :-)
09:12:05 <glen_quagmire> mauke: oh that might do too
09:14:41 <DQuest> > map (chr . (+1) . ord) "Unsd\USBnmrdqu`shud "
09:14:41 <lambdabot>  "Vote Conservative!"
09:14:45 <DQuest> lambdabot! potty mouth!
09:14:49 <DQuest> ok, I'm done :P
09:19:02 <glen_quagmire> @src bracket
09:19:03 <lambdabot> bracket before after thing = block $ do
09:19:03 <lambdabot>     a <- before
09:19:03 <lambdabot>     r <- catch (unblock (thing a)) (\e -> do { after a; throw e })
09:19:03 <lambdabot>     after a
09:19:03 <lambdabot>     return r
09:19:36 <DQuest> I'm reminded of this: http://www.bash.org/?178890
09:19:37 <lambdabot> Title: QDB: Quote #178890
09:22:31 <DQuest> I've never quite understood swear filters, really
09:23:17 <DQuest> Maybe there's a section of the populace who would be utterly scandalised upon hearing certain words, but I've never met any of 'em
09:23:40 <psofa> i think i funked up.I tried to create a function that returns a pair (data,sameTypefunction).Any way around this?
09:24:12 <psofa> Occurs check: cannot construct the infinite type: t = [t]
09:24:12 <psofa>       Expected type: [t] -> t1 -> t2
09:24:12 <psofa>       Inferred type: [[t]] -> t1 -> t1
09:24:19 <psofa> isnt that what it says?
09:24:49 <scook0> map (chr . (subtract 13) . ord) "Or-\128\130\DELr-\129|-rn\129-\134|\130\DEL-\\\131ny\129v{r;"
09:24:54 <scook0> > map (chr . (subtract 13) . ord) "Or-\128\130\DELr-\129|-rn\129-\134|\130\DEL-\\\131ny\129v{r;"
09:24:54 <lambdabot>  "Be sure to eat your Ovaltine."
09:24:55 <PeakerWork> psofa, why do you want a list inside infinite levels of lists?
09:25:08 <quicksilver> psofa: yes, you can do that.
09:25:29 <quicksilver> psofa: you just need a custom data type
09:25:38 <quicksilver> psofa: you want a function type F which returns a pair (data, F), right?
09:25:43 <psofa> yes
09:25:51 <quicksilver> note that this is exactly []
09:25:55 <quicksilver> you are reinventing lazy lists :)
09:26:21 <quicksilver> does this function take any parameters? if so, what type?
09:27:19 <psofa> this func takes a param String and a custom data C
09:28:08 <glen_quagmire> how is local implemented? i can't find source of it (from http://haskell.org/ghc/docs/latest/html/libraries/mtl/src/Control-Monad-Reader-Class.html#local)
09:28:11 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/2nkwcm
09:28:18 <magnusth> cabal question: it seems I have to pass '--user' to configure for cabal to pick up user installed packages, is it possible to trigger this behaviour through an environment variable instead?
09:29:07 <scook0> glen_quagmire: http://haskell.org/ghc/docs/latest/html/libraries/mtl/src/Control-Monad-Reader.html#Reader
09:29:07 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/2w6l99
09:29:31 <quicksilver> psofa: takes two parameters? so F :: String -> C -> (C,F) ?
09:30:18 <psofa> err wait i  f uped again
09:32:23 <glen_quagmire> I do this:  eval env val = do { pushEnv env; ... result <- eval env' val'; popEnv; return result }     -- eval env' val' might fail . and i need to popEnv when it fails.
09:33:43 <quicksilver> eval env' val `finally` popEnv
09:33:53 <psofa> this func takes [C] and A and returns an A , and A is a func that takes a String and  S and returns a (C,A)
09:33:54 <quicksilver> :t Control.Exception.finally
09:33:56 <lambdabot> forall a b. IO a -> IO b -> IO a
09:33:59 <quicksilver> but that's for IO exceptions.
09:34:24 <quicksilver> psofa: so "A" is the hard bit. you need to define it as a custom type
09:34:25 <glen_quagmire> hoa. maybe i'll try it with liftIO
09:34:27 <quicksilver> to allow the recursion.
09:34:51 <quicksilver> data A = A (String -> S -> (C , A))
09:35:03 <quicksilver> if you don't mind using the same name for constructor
09:37:18 <EvilTerran> ... could this be expressed as a scanl?
09:38:01 <EvilTerran> hm. probably not. never mind.
09:38:42 <Cheery> @where prolog
09:38:42 <lambdabot> I know nothing about prolog.
09:38:48 <Cheery> @where Prolog
09:38:49 <lambdabot> I know nothing about prolog.
09:38:54 <Cheery> @where Logic
09:38:54 <lambdabot> I know nothing about logic.
09:39:03 <Cheery> @where curry
09:39:03 <lambdabot> http://www.informatik.uni-kiel.de/~mh/curry/
09:41:33 <glen_quagmire> @hoogle m a -> IO a
09:41:34 <lambdabot> Control.Exception.evaluate :: a -> IO a
09:41:34 <lambdabot> Control.Concurrent.MVar.swapMVar :: MVar a -> a -> IO a
09:41:34 <lambdabot> Distribution.PackageDescription.withLib :: PackageDescription -> a -> (Library -> IO a) -> IO a
09:41:51 <Cheery> what was called that logic programming -module in haskell?
09:41:56 <magnusth> @where lambdabot
09:41:56 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
09:42:53 <monochrom> LogicT ?
09:49:26 <mauke> DQuest: chr . (+1) . ord == succ
09:50:51 <Twey> > succ 3
09:50:53 <lambdabot>  4
09:51:02 <Twey> @src succ
09:51:03 <lambdabot> Source not found. Take a stress pill and think things over.
09:51:06 <Twey> Eh.
09:51:16 <kpreid> @src Integer succ
09:51:16 <lambdabot> Source not found. That's something I cannot allow to happen.
09:51:31 <kpreid> @src Enum
09:51:31 <lambdabot> class  Enum a   where
09:51:31 <lambdabot>     succ                     :: a -> a
09:51:31 <lambdabot>     pred                     :: a -> a
09:51:31 <lambdabot>     toEnum                   :: Int -> a
09:51:31 <lambdabot>     fromEnum                 :: a -> Int
09:51:33 <lambdabot> [3 @more lines]
09:52:27 <Cheery> unification algorithm is functional
09:53:49 <Cheery> Unifyable -> Unifyable -> Result
09:54:56 <Cheery> where, the result introduces either few bindings or a failure, and Unifyable is a data structure with unification rules
09:55:51 <Cheery> Result would also contain backtracking choicepoints
09:56:46 <Cheery> that'd look a lot like prolog:
09:59:45 <Cheery> abka a b c = a `U` b & member b c
10:02:40 <Cheery> thus, you could as well use that to construct data, just provide an unifyable that allows this
10:07:59 <purejadekid> > pl (concat .) . map
10:08:02 <lambdabot>   Not in scope: `pl'
10:08:43 <purejadekid> > 4+5
10:08:45 <lambdabot>  9
10:09:24 <purejadekid> > @help
10:09:24 <lambdabot>  Parse error at "@help" (column 1)
10:09:43 <purejadekid> @help
10:09:43 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
10:09:43 <psofa> quicksilver, so im doing this because anonymous types dont support recursion?
10:09:51 <purejadekid> @list
10:09:51 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
10:10:01 <quicksilver> psofa: right.
10:10:11 <quicksilver> psofa: you have to name the type to allow recursion.
10:10:32 <psofa> thanks
10:10:47 <psofa> though its kinda ugly now :P
10:10:51 <purejadekid> @pl (concat .) . map
10:10:51 <lambdabot> (=<<)
10:11:11 <purejadekid> @pl \x y -> compare (length (head y)) (length (head x))
10:11:11 <lambdabot> flip (compare . length . head) . length . head
10:11:41 <opqdonut> purejadekid: comparing (length.head)
10:11:55 <opqdonut> where comparing f = compare `on` f
10:12:09 <purejadekid> yeah but on is not standard lib, right?
10:12:12 <purejadekid> I wish it were
10:12:18 <opqdonut> where (g `on` f) x y = f x `g` f y
10:12:19 <opqdonut> yeah
10:12:24 <purejadekid> :-)
10:12:25 <opqdonut> it's not in prelude
10:12:34 <opqdonut> but those are really widely used
10:12:37 <purejadekid> true
10:12:48 <purejadekid> I'm trying to reduce something to a complete one liner
10:12:54 <Cheery> I think I know now what would make haskell even better
10:13:13 <mauke> @index comparing
10:13:13 <lambdabot> bzzt
10:13:32 <mauke> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Ord.html#v%3Acomparing
10:13:34 <lambdabot> http://tinyurl.com/37zra8
10:13:49 <Cheery> it'd solve the problems around embedding error handling, reactive programming and logic programming, in a single consistent manner
10:13:52 <purejadekid> @pl filter (\x->length x >= 2)
10:13:52 <lambdabot> filter ((>= 2) . length)
10:15:39 <desegnis_> purejadekid: Not sure this was mentioned while I was disconnected, but "on" has been added to Data.Function
10:15:52 <purejadekid> great! thx
10:17:47 <psofa> quicksilver, im so owned again.I wanted to create an initial dummy A type function that returns a (C,A) but only the C part will be used (the second A is dummy).The thing is i cant define this dummy A since its recursive :P
10:17:50 <psofa> initialc "pop" s = (Cend,Env (\str -> \s -> (Cend,...theres no ending)
10:18:23 <Deewiant> @src on
10:18:23 <lambdabot> (*) `on` f = \x y -> f x * f y
10:19:21 <Deewiant> > let f (*) = 2 * 2 in f div
10:19:22 <lambdabot>  1
10:19:27 <psofa> err i meant returns (C,Env A)
10:19:28 <Deewiant> cool, didn't know you could do that
10:21:56 <Baughn> @src on
10:21:56 <lambdabot> (*) `on` f = \x y -> f x * f y
10:22:06 <Baughn> @src (.)
10:22:06 <lambdabot> (f . g) x = f (g x)
10:22:25 <ski> @src off
10:22:26 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
10:22:38 <psofa> lol
10:22:58 <Baughn> "This source is too important for me to allow you to read it."
10:23:07 <purejadekid> @pl \ ys -> concatMap (\z -> case z of { [] -> [] ; (x:xs) -> [x : y | y <- inits xs] }) (tails ys)
10:23:07 <lambdabot> (line 1, column 36):
10:23:07 <lambdabot> unexpected "{"
10:23:07 <lambdabot> expecting variable, "(", operator or ")"
10:23:15 <purejadekid> doh!
10:23:22 <quicksilver> psofa: data A = A (String -> (C,A))
10:23:29 <purejadekid> @src subsequences
10:23:29 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
10:23:36 <ski> newtype
10:26:17 <psofa> quicksilver, sure i did that ,what i need now is a dummy (String -> (C,A)) function, something like id()
10:26:29 <psofa> maybe a function that returns an error would work
10:26:41 <quicksilver> it will, yes
10:26:54 <quicksilver> A (\s -> (blah,error "Don't do this"))
10:26:58 <psofa> what is the right way to do it? or is this the only way?
10:27:07 <quicksilver> I'm not really sure what you're trying to do :)
10:27:17 <quicksilver> I imagine something like this:
10:27:54 <quicksilver> A (\s -> let (bar,baz) = some_computation s in (bar,continuation_based_on baz))
10:28:01 <quicksilver> would be the kind of thing you'd do.
10:28:01 <psofa> im trying just what you wrote. im just asking if theres a more proper way
10:28:24 <psofa> other than the error way
10:28:28 <quicksilver> well with a funny continuation-type type like that, you'd probably have a bunch of functions designed to build them.
10:28:37 <Baughn> > case (42,error "foo") of (a,_) -> a
10:28:37 <lambdabot>  42
10:28:43 <quicksilver> you could build one which returns itself:
10:28:47 <Baughn> > case (42,error "foo") of (a,b) -> a
10:28:48 <lambdabot>  42
10:28:56 <quicksilver> buildA = A (\s -> (blah,buildA))
10:29:08 <psofa> lol nice
10:29:12 <quicksilver> (Use value recursion to help you build recursive data)
10:30:54 <ski> looks like a synchonous stream processor from `String' to `C'
10:31:12 <quicksilver> yeah.
10:31:25 <quicksilver> I did point out to psofa that he was kind-of reinventing lists.
10:31:36 <quicksilver> but, it's still interesting to explore these things.
10:31:54 <quicksilver> I had a particle system model which 'single-stepped' and then returned itself as a continuation.
10:31:57 <quicksilver> as it were.
10:31:58 * ski nods
10:32:30 <psofa> what im trying to do actually is implement denotational semantics of a lang based on continuation
10:32:37 <psofa> im about to explode :(
10:32:44 <quicksilver> don't fight it.
10:32:50 <quicksilver> head-explosion is the solution, not the problem.
10:33:19 <ZsoL> that actualy makes sense
10:33:52 <byorgey> @remember quicksilver head-explosion is the solution, not the problem.
10:33:52 <lambdabot> I will never forget.
10:37:21 <psofa> anything that looks pretty bad in this?:
10:37:23 <psofa> push [head:clist] (Env cn) = Env cnew
10:37:24 <psofa> 	where cnew str s = (if str=="pop" then (head,push clist (Env cn))
10:37:24 <psofa> 					 else (cn "pop" s))
10:37:44 <EvilTerran> do you maybe mean (head:clist)?
10:38:32 <psofa> lol im so helpless thanks :)
10:39:25 <ski> parens around `if'-`then'-`else' not needed
10:39:54 <ski> maybe you'd prefer using guards or pattern-matching, though
10:41:01 <psofa> im so lucky ,ive done this [head:tail] thing on a whole program and the results were ok :|
10:41:45 <byorgey> psofa: [head:tail] means you have a list (outer [ ]) which contains a single list head:tail
10:41:53 <quicksilver> yes, you nested everything in one extra level of list
10:41:59 <psofa> yeah i got it now :)
10:42:02 <quicksilver> if you're totally consistent, you might stll get correct results :)
10:42:23 <byorgey> psofa: also, instead of saying cnew str s = if str=="pop" then ...  you could pattern-match on the "pop":
10:42:31 <byorgey> cnew "pop" s = (head,push...
10:42:40 <byorgey> cnew _ s = (cn "pop" s)
10:42:50 <byorgey> that seems more idiomatic to me
10:43:05 <psofa> yeah mine is ugly :)
10:43:11 <byorgey> you'll find that idiomatic Haskell very rarely uses if-then-else =)
10:43:50 <quicksilver> I do catch myself wishing for ( ? : ) occasionally
10:43:55 <quicksilver> I normally snap out of it.
10:44:04 <byorgey> hehe
10:44:05 <EvilTerran> quicksilver, you could kinda do that, actually
10:44:10 <byorgey> what's wrong with if' ?
10:44:30 <ski> nothing, i tell you
10:44:31 <quicksilver> you can, yews
10:45:23 <EvilTerran> data Options a = a :? a; (?:) :: Bool -> Options a -> a; True ?: (th :? el) = th; False ?: (th :? el) = el
10:45:49 <EvilTerran> give appropriate fixities, and "pred ?: thenClause :? elseClause"'d work
10:45:50 <glguy> In one of my larger projects, 0.5% of the source code lines have "then"
10:46:24 <glguy> which is 5x fewer than those with case :)
10:48:07 <dbueno> Can anyone think of a reason why adding a Debug.Trace.trace call at the beginning of a cost centre (the cost center is a top-level function whose SCC is added by -auto-all) causes the number of "entries" in the GHC .prof file to go from 400 or so to 2?
10:48:30 <dons> dbueno: its became a CAF?
10:49:08 <mnislaih> or maybe the cost is assigned to Debug.Trace.trace, which has no SCC attached.
10:49:13 <mnislaih> you want to put a manual SCC in that case
10:49:17 <dbueno> dons: I don't see what that has to do with Debug.Trace.trace, but I'm all ears.  That's literally the only change I made.
10:50:41 <dbueno> The top-level function takes two parameters.  There's only one call to it in my main function.  This gives me 460 or so "entries" which is weird in itself.  But putting the trace as the first form in the body of the function changes the entries to 2.
10:50:48 <glguy> Is the behavior of the default Storable instances define somewhere in the FFI spec?
10:51:36 <dbueno> mnislaih: Since I edited the body of the function, the cost assigned shouldn't vary, right?  I enter the function whether or not there's a "trace" call at the beginning.
10:54:41 <dbueno> Using -O0 instead of whatever the cabal default is to build gives 1 entry for both cases, which is what I expect.  The optimiser must be doing something tricky.
10:55:00 <dons> glguy: yeah. and in the src
10:55:55 <dcoutts_> dbueno: cabal uses -O1 by default, with the latest cabal you can specify it at configure time: cabal configure -O0
10:57:01 <dbueno> dcoutts_: Ah, thanks.
10:57:40 <dbueno> I guess it makes sense that the optimiser might screw around with entries.  Inlining and so on.  Although you'd think it might be possible to warn you if that's the case.
10:59:20 <ski> if the role name for a part of a conjunction is "conjunct", what is the role name for a quantified variable in a, say, universal, quantification ?
10:59:49 <sieni> "a universally quantified variable"?
11:00:00 <ski> that makes a quite long variable name ..
11:00:26 <ski> (though i suppose "quantifiedVariable" would work)
11:00:48 <dbueno> ski: bound variable?
11:01:06 <ski> (i was looking for something akin to "quantifyee", however that would be spelled)
11:02:05 <dbueno> mnislaih, dons: Thanks for the help.
11:02:49 <desegnis_> dbueno: "bound" reminds of a lambda abstraction or function equation; not so good for a type variable
11:03:20 <dbueno> desegnis_: Lambda abstraction and universal quantification have a lot in common. =]  It depends on context, also.
11:03:38 <desegnis_> right
11:03:46 <mae> is it worth the time / effort to recompile 6.8.1 with 6.8.1 (if you compiled it with 6.6.1 first)
11:04:22 <desegnis_> mae: It's definitely worth the effort to compile 6.8.2 with 6.8.1
11:04:44 <desegnis_> even though that doesn't answer your question
11:04:47 <mae> um
11:04:52 <mae> ok sorry
11:04:55 <mae> i compiled 6.8.2
11:04:58 <mae> with 6.6
11:05:06 <desegnis_> ah ok
11:05:16 <mae> so does it make much difference (performancewise) to compile it with itself
11:05:34 <mae> (compile time perf)
11:06:11 <desegnis_> not sure myself. That is to be expected at least
11:06:31 <Peaker> where's 6.7?
11:07:39 <Igloo> mae: No, not if you did a normal 2-stage build
11:15:13 <mae> Igloo: oh is the 2 stage build standard?
11:15:19 <mae> when i type make?
11:15:20 <mae> heh
11:15:58 <Igloo> Yup
11:16:36 <mae> Glasgow Haskell Compiler, Version 6.8.2, for Haskell 98, stage 2 booted by GHC version 6.6.1
11:16:55 <mae> so even though it says this, this means it was recompiled by 6.8.2 after bootstrapping from 6.6.1
11:18:08 <Igloo> Yes
11:18:43 <mae> ok great !
11:19:13 <byorgey> compilers compiling themselves still seems magical to me... =)
11:19:24 <byorgey> not in the sense that I don't understand it, it's just... magical
11:19:53 <vegai> hmuh, I'm trying to test some things that I have in my Main module (which includes a main function)
11:19:54 <ttt--> now we only need programs that write themselves
11:20:12 * ski is currently considering writing a compiler in that language that it will compile (a new language)
11:20:27 <vegai> ...with HUnit. But this doesn't seem to work. I have a Main_Test module which imports Main... but it seems that Main's main overrides Main_Test's main
11:20:43 <dons> you can only have 1 main in your  program
11:20:51 <ac> anybody here familiar with Alice ML?
11:20:53 <dons> or import qualified, (I think that works..)
11:21:20 <ski> ac : only browsed the documentaion a few times
11:21:27 <vegai> oh, of course...
11:22:11 <ac> I was just reading The Missing Link -- Dynamic Components for ML
11:22:15 <vegai> I'll try that. Odd thing is that I'm specifying what to import from Main, and I don't include its main function in that list
11:22:22 <Jose_Balado> for Alice Ml ask rossberg in SML channel
11:22:43 <ac> well, I was interested in a perspective of it from a Haskell programmer
11:23:03 <Jose_Balado> ah, ok, but rossberg programms is haskell too, I think
11:23:34 <vegai> ah, no. import qualified didn't help
11:25:36 <MarcWeber> Haske anyone worked on adding ghci support to vim so that you can script vim in haskell?
11:26:56 <vegai> ah, well. I suppose things in Main won't be tested
11:27:05 <lament> MarcWeber: no, but see Yi
11:27:39 <MarcWeber> lament I know about Yi.. that's why I know that there is still a lot to be implemented.. :)
11:27:43 <ac> Jose_Balado: do you mean #sml on freenode?
11:28:48 <ski> ac : i'd think so, yes
11:29:04 <Jose_Balado> yes, on freenode
11:40:32 <rlblaster> Hi! This works: putStrLn ((++) "A" "B")   but what should I do to make this work: (putStrLn . (++)) "A" "B"
11:41:16 <gbacon> rlblaster: what are you trying to do?
11:41:33 <Riastradh> curry (putStrLn . (uncurry (++)))
11:42:54 <andun_> @pl \a b -> putStrLn (a ++ b)
11:42:54 <lambdabot> (putStrLn .) . (++)
11:42:58 <rlblaster> gbacon: To pass a function as a parameter which concatenates two strings and then writes that out.
11:43:39 <rlblaster> Riastradh: That seems to work, thank you.
11:43:40 <gbacon> @pl \a b -> putStrLn $ a ++ b
11:43:40 <lambdabot> (putStrLn .) . (++)
11:44:17 <byorgey> rlblaster: the problem is that you want (++) to consume TWO arguments before the result is passed on to putStrLn
11:44:18 <gbacon> > let f = (show .) . (++) in f "foo" "bar"
11:44:22 <byorgey> so you need an extra .
11:44:23 <lambdabot>  "\"foobar\""
11:44:33 <byorgey> > ((putStrLn .) . (++)) "A" "B"
11:44:34 <lambdabot>  <IO ()>
11:44:49 <ski> > let (.:) = (.) . (.); f = show .: (++) in f "foo" "bar"
11:44:50 <lambdabot>  "\"foobar\""
11:45:02 <gbacon> NSFW!!!
11:45:04 <byorgey> rlblaster: personally, I would just write  \x y -> putStrLn (x ++ y)
11:45:29 <dancor> is 'unexpected' the right way to have a particular branch of parsing fail (if some test in not met)
11:45:34 <dancor> in parsec
11:46:32 <rlblaster> byorgey: That works too, thank you.
11:55:37 * byorgey throws marshmallows
11:56:58 <kfish> nom nom nom
11:57:38 <gbacon> data Projectile = forall a. WarmFuzzyThing a => Fire a
11:58:18 <vegai> ah, they finally renamed Monads as they always talk about
11:58:55 <Baughn> vegai: Of course. It's not just gbacon either - look at http://saxophone.jpberlin.de/MonadTransformer?source=http%3A%2F%2Fwww.haskell.org%2Fhaskellwiki%2FCategory%3AMonad&language=English
11:59:01 <lambdabot> http://tinyurl.com/2thc6d
11:59:28 <lament> "Warm, fuzzy things as containers"
11:59:30 <ski> vegai : but argument types are not allowed to have kind different from `*'
12:00:02 <ski> (well, in ghc that's `?', iirc)
12:00:05 <lament> "Meet Bob The Warm, fuzzy Lover"
12:00:15 * gbacon chuckles
12:02:18 <vegai> Awesome.
12:04:19 <Baughn> @let 2 + 2 = 5
12:04:20 <lambdabot> Defined.
12:04:47 <sek> > 2+2
12:04:47 <lambdabot> Terminated
12:04:47 <roconnor> > 2 + 2
12:04:48 <lambdabot> Terminated
12:04:51 <sek> damn
12:05:02 <Baughn> ..terminated?
12:05:18 <lispy> > (2+2, 2+3)
12:05:18 <lambdabot> Terminated
12:05:21 <roconnor> lambdabot couldn't bear to lie
12:05:21 <ski> > ()
12:05:22 <lambdabot>  ()
12:05:26 <lispy> > (2+1, 2+3)
12:05:27 <lambdabot> Terminated
12:05:29 <lispy> hmm
12:05:33 <lispy> > 2-1
12:05:34 <lambdabot>  1
12:05:37 <ski> <Baughn> @let 2 + 2 = 5
12:05:39 <lispy> ?undefine
12:05:40 <lambdabot> Undefined.
12:05:43 <lispy> > (2+1, 2+3)
12:05:44 <lambdabot>  (3,5)
12:05:55 <Baughn> My intention was not to prevent addition. >_<
12:06:03 <lispy> Baughn: you jerk! ;)
12:06:15 <sek> roconnor, a famous book says that one can be conditioned into "2+2=5"... :)
12:06:18 <lispy> breaking lambdabot...why I outta....
12:06:24 <chrisdone> glguy: any reason new hpaste hasn't replaced old hpaste yet?
12:08:04 <chrisdone> is this an acceptable definition of >>=? http://hpaste.org/6526
12:08:18 <chrisdone> and is my fmap definition acceptable?
12:08:28 <Baughn> So why did that break lambdabot, anyway?
12:09:33 <lispy> Baughn: I'm not sure.
12:09:47 <lispy> Baughn: I'm thinking it may have caused recursion, but I'm not sure how
12:09:48 <ski> chrisdone : no
12:09:56 <Cheery> > 2+2
12:09:56 <lambdabot>  4
12:10:12 <ski> chrisdone : `fmap' is ok
12:10:33 <Cheery> @let 2 + 2 = 5
12:10:33 <lambdabot> Defined.
12:10:37 <Cheery> > 2+2
12:10:37 <lambdabot> Terminated
12:10:40 <roconnor> @type (+)
12:10:41 <Taggnostr> :O
12:10:41 <lambdabot>     Ambiguous occurrence `+'
12:10:41 <lambdabot>     It could refer to either `L.+', defined at <local>:1:2
12:10:41 <lambdabot>                           or `Prelude.+', imported from Prelude at State/imports.h:2:0-66
12:10:42 <Cheery> hm. :/
12:10:52 <roconnor> @type (L.+)
12:10:52 <lambdabot> forall t t1 t2. (Num t, Num t1, Num t2) => t -> t1 -> t2
12:11:12 <Deewiant> > 2+2
12:11:12 <lambdabot> Terminated
12:11:18 <Baughn> > 3+3
12:11:18 <lambdabot> Terminated
12:11:22 <Cheery> how are you allowed to define something such absurd anyway?
12:11:23 <roconnor> > 2 + 2 ::Integer
12:11:23 <Deewiant> > let 2 + 2 = 5 in 2 + 2
12:11:23 <lambdabot> Terminated
12:11:24 <lambdabot>  5
12:11:31 <Baughn> @let a+b=5
12:11:32 <lambdabot> Defined.
12:11:34 <Baughn> > 2+2
12:11:35 <lambdabot> Terminated
12:11:42 <Baughn> Cheery: Why not? ;)
12:11:44 <Deewiant> Cheery: you're overriding the Prelude-defined (+)
12:11:46 <lispy> > let 2 + 2 = 5 in 2 + 2
12:11:47 <lambdabot>  5
12:11:59 <roconnor> @type (L.+)
12:12:01 <lambdabot> forall t t1 t2. (Num t, Num t1, Num t2) => t -> t1 -> t2
12:12:08 <Baughn> Cheery: I'd actually expect an exception with anything /but/ 2+2, after that
12:12:16 <lispy> but, if you redefine (+), then what does foo (n+1) = n, mean?
12:12:19 <ski> chrisdone : `(>>=)' fails the `return () >>= \() -> Cons False (Cons True Nil)  =  Cons False (Cons True Nil)' test (that's an instance of one of the monad laws)
12:12:33 <lispy> Baughn: me too, that's how it works with a local definition of (+)
12:12:42 <roconnor> @let 'a'+'b'="ab"
12:12:42 <lambdabot> <local>:1:0:     No instance for (Num Char)       arising from the literal `2...
12:13:01 <roconnor> is 2 + 2 a pattern?
12:13:17 <roconnor> n +k pattern?
12:13:44 <ski> i think not
12:13:44 <roconnor> maybe not
12:13:48 <roconnor> @undefine
12:13:48 <lambdabot> Undefined.
12:13:55 <roconnor> @let 'a'+'b'="ab"
12:13:55 <lambdabot> Defined.
12:14:11 <roconnor> > 'a'+'b'
12:14:11 <lambdabot> Terminated
12:14:21 <roconnor> @type (L.+)
12:14:22 <lambdabot> Char -> Char -> [Char]
12:14:36 <Baughn> @let a*b = a++b
12:14:36 <lambdabot> Defined.
12:14:47 <Baughn> > "foo" * "bar"
12:14:47 <lambdabot> Terminated
12:15:00 <Baughn> @let a %%%% b = a ++ b
12:15:00 <lambdabot> Defined.
12:15:08 <Baughn> > "foo" %%% "bar"
12:15:08 <lambdabot>   Not in scope: `%%%'
12:15:11 <Baughn> > "foo" %%%% "bar"
12:15:12 <lambdabot>  "foobar"
12:15:24 <Deewiant> @ty (L.%%%%)
12:15:25 <lambdabot> forall m. (Monoid m) => m -> m -> m
12:15:36 <Deewiant> @ty (L.*)
12:15:37 <lambdabot> forall m. (Monoid m) => m -> m -> m
12:15:40 <Baughn> @type (++)
12:15:41 <lambdabot> forall m. (Monoid m) => m -> m -> m
12:15:42 <Deewiant> right.
12:16:08 <Baughn> ++ is.. oh-kay.
12:16:20 <Cheery> I think, making a multi-purpose format that's purpose is to contain combinator clauses is pretty safe throw
12:16:41 <ski> ?
12:17:16 <Baughn> > error "foo"
12:17:17 <lambdabot>  Exception: foo
12:17:23 <Baughn> @let (+) = error "foo"
12:17:23 <lambdabot> <local>:4:0:     Multiple declarations of `L.+'     Declared at: <local>:1:3 ...
12:17:31 <ski> @undefine
12:17:31 <lambdabot> Undefined.
12:17:32 <Cheery> ski: because it allows containing very wide stuff
12:17:50 <ski> Cheery : what, sir, are you talking about ?
12:19:34 <Cheery> been thinking about writing a file format which's main purpose would be to contain a program written&typed in a functional programming language
12:20:59 <Cheery> and slowly realising how widely you could play out with such format
12:21:15 <roconnor> I read a thesis on a typed file system.
12:21:25 <roconnor> programs as functions.
12:21:34 <Peaker> Cheery, an .hs file is such a file, even though its optimized for human editing rather than programmable manipulatability
12:22:11 <lament> roconnor: heh
12:22:35 <lament> Windows PowerShell (ex-Monad) is a typed shell
12:23:16 <Cheery> Peaker: what I'm thinking about would be quite agnostic for a programming language you use.
12:23:37 <Peaker> Cheery, agnostic to what of the programming language? Could it hold both Haskell and C programs?
12:24:26 <Cheery> nah, not C
12:24:33 <Cheery> meant to say
12:24:42 <Cheery> agnostic for a functional programming language you use.
12:25:26 <lament> i suggest XML!
12:26:01 <Peaker> Cheery, you can easily trivialize syntatic difference - and I also have such a project in mind - but not semantic ones
12:26:07 <Cheery> I've been sketching in my mind that it'd be a spine serialised into a file, or even flatter form
12:26:40 <Twey> roconnor: I think that would be Rather Cool.
12:27:00 <chrisdone> ski: i think i'll define a Monoid and Foldable instance for List and then use foldr for >>=
12:27:08 <roconnor> Twey: it exists,  I think it was written in Clean.
12:27:08 <Twey> I like what PowerShell does with its commandletts
12:27:12 <Twey> commandlets**
12:27:18 <Twey> Oh really?
12:27:23 <roconnor> commandlets++
12:27:31 <Cheery> lament: I think XML would be quite horrifying, especially with a format that's purpose is to contain an image of the program thet you can verify
12:28:35 <Cheery> or handle as module, or bundle into a binary file sort of, or compile into native code
12:29:24 <lament> right, xml + xslt
12:30:54 <Cheery> Peaker: I don't want to promote haskell to systems which's lifetime is longer than haskell's (hopefully), and where updating everything system-wide would be a horrible feat.
12:31:30 <Cheery> what you need in those places is a bare-bones setting
12:32:18 <ski> chrisdone : could work, i guess
12:32:43 <Cheery> I'm thinking about doing stuff that could replace web 1.0&2.0 -vaporware
12:33:07 <Cheery> well, not replace, but obsolete anyway
12:33:15 <Twey> Cheery: Please hurry up.
12:35:06 <Cheery> current web infrastructure has lived for long, and is a burden to update, well, partially because it is poorly implemented, but anyway, updating gazillion machines to support new paradigms is a big task.
12:35:36 <Twey> It's a hack
12:35:36 <Cheery> so best bet is to provide something that won't get old too soon
12:36:00 <lament> Arc!
12:36:00 <Twey> You need something that will interface with the current Web
12:36:05 <lament> so you want to compile haskell to pure typed lambda calculus?
12:36:06 <Twey> So it's possible to upgrade parts of it at a time
12:38:06 <Cheery> lament: first I want the format, alongside that I may want to write compiler from haskell, but I'm also thinking about bootstrapping an even more practical language from that.
12:38:45 <lament> should be done by monday
12:38:47 <mae> which Text.Regex version is the fairest of them all, i don't know which one to download to install sp
12:38:49 <Twey> Heheh
12:39:07 <Cheery> :)
12:39:26 <Cheery> lament: actually a monday would be quite good goal to get something bare bones up
12:41:16 <Cheery> either today or tomorrow, I'm going to play out with few untyped data structures, thinking about trying out the usual tree populated with programs and combinators
12:42:06 <Cheery> but also wondering whether I could flatten the tree, without causing trouble
12:42:07 <smg> mae: http://www.serpentine.com/blog/2007/02/27/a-haskell-regular-expression-tutorial/
12:42:08 <lambdabot> Title: teideal glic deisbhéalach  Blog Archive  A Haskell regular expression tutoria ..., http://tinyurl.com/2xtgpw
12:42:08 <chrisdone> cheery: http://rtfs.ath.cx/misc/report.jpg "I want it done by monday"
12:43:10 <Cheery> ☠☠☠ WARNING: eye-burning cute picture! ☠☠☠
12:43:41 <Twey> Ahahahaha
12:43:43 <Twey> <3
12:43:59 <chrisdone> :P
12:44:32 <Twey> Hmmm... edited or dressed up, I wonder :-P
12:44:51 <oklopol> @die 1d2
12:44:51 <lambdabot> 1d2 => 2
12:44:59 <Cheery> @donotdieplease
12:45:00 <lambdabot> Unknown command, try @list
12:45:04 <Twey> Hahaha
12:45:06 <ddarius> People who put clothing on animals should be shot.
12:45:10 <Twey> 'Nooooo, lambdabot!'
12:45:25 <Twey> ddarius: Heh, those little 'doggy coats' offend me
12:45:30 <smg> ddarius: people who shave animals should be shot too :)
12:45:36 <Twey> Heh
12:45:44 <mauke> dirty deeds done with sheep
12:45:56 <Cheery> with the exception of shaving avian creatures
12:45:59 <Twey> But that dog in a suit is highly awesome, and I doubt he minded too much.  :-P
12:48:22 <gbacon> cats deserve to be shaven just on general principle
12:48:35 <Twey> :<
12:48:40 <Twey> Never
12:48:52 <mauke> tags: SERIOUS BUSINESS
12:49:17 <ari> In the future we will all have shaved cats.
12:49:36 <smg> mauke: haha
12:49:52 <Cheery> through my shaved lolcats
12:50:15 <Cheery> @type shave
12:50:16 <lambdabot> Not in scope: `shave'
12:50:30 <Cheery> shave (lol (cat
12:50:30 <gbacon> I CAN HAS RUSTY RAZER
12:51:08 <byorgey> @go shave and a haircut in EUR
12:51:09 <lambdabot> http://www.haircuts.ru/index_e.html
12:51:09 <lambdabot> Title: Extreme ladies' haircuts: bob, crop, pixie, bald and headshave. Fashion and styl ...
12:51:29 <byorgey> hm, google calculator doesn't have those units
12:51:48 <gbacon> @go 25 cents in EUR
12:51:48 <lambdabot> 25 U.S. cents = 0.159296546 Euros
12:52:08 <gbacon> shave and a haircut == 2 bits == 25 cents
12:52:30 <byorgey> ah, I knew the first == but not the second =)
12:52:38 <mae> i think there was a misunderstanding
12:52:42 <mae> which is the best performing..
12:53:01 <mae> tdfa, pcre, parsec, tre
12:53:06 <Cheery> @go 1$ to €
12:53:07 <lambdabot> http://www.apple.com/education/k12/onetoone/
12:53:07 <lambdabot> Title: Apple - Education - 1 to 1 Learning
12:53:13 <Cheery> @go 1$ to EUR
12:53:14 <lambdabot> http://www.x-rates.com/d/EUR/table.html
12:53:14 <lambdabot> Title: Exchange Rates Table for Euro, Euro
12:53:22 <stevan> is there a library similar to this one: http://www.cs.chalmers.se/Cs/Grundutb/Kurser/afp/lectures/lecture1/Signal.hs ?
12:53:22 <gbacon> byorgey: http://en.wikipedia.org/wiki/Bit_(money)
12:53:24 <Cheery> @go 1 U.S. dollar in EUR
12:53:24 <lambdabot> http://tinyurl.com/2tn2vo
12:53:24 <lambdabot> 1 U.S. dollar = 0.637186186 Euros
12:53:35 <Twey> @go 1 USD in GBP
12:53:35 <lambdabot> 1 U.S. dollar = 0.49960032 British pounds
12:53:39 <Twey> Nice.
12:53:41 <Cheery> @go 1 EUR in U.S. dollar
12:53:42 <lambdabot> 1 Euro = 1.5694 U.S. dollars
12:54:44 <gbacon> @karma- FederalReserve
12:54:44 <lambdabot> FederalReserve's karma lowered to -1.
12:54:44 <Peaker> @go 1 EUR in Israeli shekels
12:54:44 <lambdabot> 1 Euro = 5.30692159 Israeli shekels
12:54:54 <tromp> @go 1 EUR in USD
12:54:56 <lambdabot> 1 Euro = 1.5694 U.S. dollars
12:55:00 <Cheery> @karma+ Cheery
12:55:00 <lambdabot> You can't change your own karma, silly.
12:55:29 <skorpan> how do i check that i list contains no "Nothing"?
12:55:31 <tromp> @go 1 CAD in USD
12:55:32 <lambdabot> 1 Canadian dollar = 1.003915 U.S. dollars
12:55:42 <skorpan> a list [Maybe a] s.t. it only contains Just _
12:56:27 <tromp> @oeis 1,57
12:56:28 <lambdabot> Triangle of Eulerian numbers T(n,k) read by rows.
12:56:28 <lambdabot> [1,1,1,1,4,1,1,11,11,1,1,26,66,26,1,1,57,302,302,57,1,1,120,1191,2416,1191,12...
12:56:30 <desegnis_> > sequence [Just 1, Nothing, Just 3]
12:56:30 <lambdabot>  Nothing
12:57:01 <skorpan> > sequence [Just 1, Just 3]
12:57:01 <lambdabot>  Just [1,3]
12:57:09 <skorpan> > sequence [Just 1, Just 1]
12:57:09 <lambdabot>  Just [1,1]
12:57:34 <tromp> > sequence [2,3]
12:57:35 <lambdabot>   add an instance declaration for (Num (m a))
12:57:35 <gnuvince> :t sequence
12:57:37 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
12:57:37 <skorpan> i should refine my question a bit.. i want to check that the list contains *only* "Just x", where x is the same throughout the list
12:57:56 <byorgey> skorpan: all isJust
12:58:03 <skorpan> ah
12:58:05 <skorpan> of course
12:58:08 <byorgey> =)
12:58:13 <tromp> > group [ Just 1, Just 2, Just 2]
12:58:14 <lambdabot>  [[Just 1],[Just 2,Just 2]]
12:58:18 <skorpan> you're great help, thanks
12:58:23 <byorgey> skorpan: oh, wait, you also want all the x's to be the same?
12:58:25 <desegnis_> wait, where x is the same throughout the list?
12:58:28 <gbacon> skorpan: so do you want false for [Just 1, Just 2]?
12:58:39 <tromp> > lenght (group [ Just 1, Just 2, Just 2]) == 1
12:58:39 <lambdabot>   Not in scope: `lenght'
12:58:39 <skorpan> yes gbacon
12:58:50 <Twey> Heh
12:58:51 <skorpan> byorgey: yes, and i also realised that isJust isn't sufficient :)
12:58:56 <gbacon> @ty all (== . head)
12:58:58 <lambdabot> parse error on input `.'
12:59:05 <gbacon> @ty all ((==) . head)
12:59:06 <lambdabot>     Couldn't match expected type `Bool'
12:59:06 <lambdabot>            against inferred type `a -> Bool'
12:59:06 <lambdabot>     Probable cause: `==' is applied to too few arguments
12:59:23 <tromp> tail (group [ Just 1, Just 2, Just 2]) == []
12:59:29 <tromp> > tail (group [ Just 1, Just 2, Just 2]) == []
12:59:30 <lambdabot>  False
12:59:42 <tromp> > tail (group [ Just 2, Just 2, Just 2]) == []
12:59:42 <lambdabot>  True
12:59:50 <byorgey> > tail (group [Nothing, Nothing]) == []
12:59:51 <lambdabot>  True
13:00:08 <skorpan> tail (group [Just 1, Nothing])
13:00:08 <desegnis_> > let nub' = map head . group . sort in case nub' [Just 1, Just 1] of [Just x] -> True; _ -> False
13:00:09 <lambdabot>  True
13:00:12 <ddarius> > tail (group [])
13:00:14 <lambdabot>  Exception: Prelude.tail: empty list
13:00:30 <desegnis_> ah wait, why did I sort
13:00:51 <tromp> >case (group [ Just 2, Just 2, Just 2]) of [Just x] -> true
13:00:51 <desegnis_> too late in the evening :)
13:00:56 <psofa> quicksilver, now that im thinking it cant i use type A = String -> S -> A instead of defining the ugly custom data ?
13:01:43 <tromp> >case (group [ Just 2, Just 2, Just 2]) of [Just x] -> true; otherwise -> false
13:01:57 <desegnis_> tromp: you need a space after >
13:02:05 <tromp> > case (group [ Just 2, Just 2, Just 2]) of [Just x] -> true; otherwise -> false
13:02:05 <lambdabot>   Not in scope: `false'
13:02:12 <gbacon> > let f lst = case lst of { [] -> false; [Nothing:_] = false; [x@(Just _):xs] -> all (==x) xs } in f [Just 1, Just 2]
13:02:12 <lambdabot>  Parse error at "=" (column 52)
13:02:16 <tromp> > case (group [ Just 2, Just 2, Just 2]) of [Just x] -> True; otherwise -> False
13:02:16 <lambdabot>  Couldn't match expected type `[Maybe t]'
13:02:16 <desegnis_> tromp: and you need uppercase True and False
13:02:22 <gbacon> > let f lst = case lst of { [] -> false; [Nothing:_] -> false; [x@(Just _):xs] -> all (==x) xs } in f [Just 1, Just 2]
13:02:22 <lambdabot>   Not in scope: `false'
13:02:25 <desegnis_> tromp: and you need [[Just x]]
13:02:35 <tromp> > case (group [ Just 2, Just 2, Just 2]) of [[Just x]] -> True; otherwise -> False
13:02:36 <lambdabot>  False
13:02:54 <gbacon> > let f lst = case lst of { [] -> False; [Nothing:_] -> False; [x@(Just _):xs] -> all (==x) xs } in f [Just 1, Just 2]
13:02:54 <lambdabot>  Couldn't match expected type `[Maybe t]'
13:03:05 <tromp> > case (group [ Just 2, Just 2, Just 2]) of [(Just x:y)] -> True; otherwise -> False
13:03:06 <lambdabot>  True
13:03:12 <tromp> at last:)
13:03:22 <tromp> > case (group [ Just 1, Just 2, Just 2]) of [(Just x:y)] -> True; otherwise -> False
13:03:23 <lambdabot>  False
13:03:48 <desegnis_> ah, of course
13:04:17 <tromp> maybe [] should give True as well
13:05:01 <gbacon> > let f lst = case lst of { [] -> True; (Nothing:_) -> False; (x@(Just _):xs) -> all (==x) xs } in f [Just 1, Just 2]
13:05:02 <lambdabot>  False
13:05:06 <gbacon> > let f lst = case lst of { [] -> True; (Nothing:_) -> False; (x@(Just _):xs) -> all (==x) xs } in f [Just 1, Just 1]
13:05:07 <Twey> :t group
13:05:08 <lambdabot>  True
13:05:09 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
13:05:19 <Twey> Oh
13:06:25 <gbacon> > let f lst = case lst of { [] -> True; (Nothing:_) -> False; (x@(Just _):xs) -> all (==x) xs } in f [Just 1, Nothing, Just 1]
13:06:25 <lambdabot>  False
13:06:45 <byorgey> > let f lst = maybe False ((==1) . length . nub) (sequence lst)  in f [Just 1, Just 1, Just 2]
13:06:45 <lambdabot>  False
13:06:49 <byorgey> > let f lst = maybe False ((==1) . length . nub) (sequence lst)  in f [Just 1, Just 1, Just 1]
13:06:50 <lambdabot>  True
13:06:55 <byorgey> > let f lst = maybe False ((==1) . length . nub) (sequence lst)  in f [Nothing, Nothing]
13:06:56 <lambdabot>  False
13:08:09 <gbacon> byorgey: clever
13:09:21 <byorgey> @check \(lst::[Maybe Int]) -> let f1 l = maybe False ((==1) . length . nub) (sequence l); f2 l = case lst of { [] -> True; (Nothing:_) -> False; (x@(Just _):xs) -> all (==x) xs } in (f1 lst == f2 lst)
13:09:21 <lambdabot>  Parse error in pattern at "->" (column 21)
13:09:28 <smg> how is unicode character in haskell be possible?
13:10:01 <roconnor> > '\222'
13:10:01 <lambdabot>  '\222'
13:10:14 <byorgey> @check \lst -> let f1 l = maybe False ((==1) . length . nub) (sequence l); f2 l = case lst of { [] -> True; (Nothing:_) -> False; (x@(Just _):xs) -> all (==x) xs } in (f1 (lst::[Maybe Int]) == f2 lst)
13:10:15 <lambdabot>  Falsifiable, after 0 tests: []
13:10:15 <roconnor> > '\2222'
13:10:16 <lambdabot>  '\2222'
13:10:30 <roconnor> > toUpper '\2222'
13:10:31 <lambdabot>  '\2222'
13:10:38 <gbacon> :-)
13:10:42 <byorgey> > sequence ([] :: [Maybe Int])
13:10:42 <lambdabot>  Just []
13:10:43 <gbacon> edge cases
13:10:47 <byorgey> indeed...
13:10:53 <gbacon> right, but the length won't be 1
13:11:10 <byorgey> @check \lst -> let f1 l = maybe False ((<=1) . length . nub) (sequence l); f2 l = case lst of { [] -> True; (Nothing:_) -> False; (x@(Just _):xs) -> all (==x) xs } in (f1 (lst::[Maybe Int]) == f2 lst)
13:11:11 <lambdabot>  OK, passed 500 tests.
13:11:15 <byorgey> =D
13:11:20 * gbacon hi-fives
13:11:27 * byorgey high-fives back
13:12:08 <byorgey> skorpan: got all that? =)
13:14:15 <gbacon> @karma+ QuickCheck
13:14:15 <lambdabot> QuickCheck's karma raised to 4.
13:15:38 <tromp> (<=1) . length is not a good idea in general
13:15:46 <tromp> since length is pretty strict
13:15:52 <dmwit> null . drop 1
13:16:10 <tromp> that's better:)
13:20:14 <daveux_> How do I export a typeclass from a module? Say I define Show MyType -- how do I get show :: MyType -> String available to clients?
13:20:31 <mauke> that happens automatically
13:20:34 <dmwit> All instances are automatically exported.
13:20:37 <mauke> they just have to load your module
13:21:16 <dmwit> (I think class definitions are exported automatically too, but I'm not as sure about that one.)
13:21:21 <daveux_> Wonderful.
13:21:22 <Heffalump> they're not
13:21:34 <glguy> Cheery: no reason other than not having done it
13:21:34 <Heffalump> you can export Show(..) or you can export show
13:23:09 <Cale> Heffalump: He just wants to export the instance most likely.
13:23:25 <dons> Heffalump: are you in #haskell-soc ?
13:23:35 <Heffalump> no
13:23:53 <Heffalump> (am now)
13:24:27 <taruti> is that for mentors or generic discussion?
13:42:05 <joricj> hello
13:42:49 <forkiliens> hello joricj
13:43:18 <joricj> i have a small question, when i have a structure with a lot of fields, and i want to edit it ... i know that's not allowed. but how can i create a copy with some fields of the structure replaced
13:43:28 <joricj> eg i have:
13:44:12 <dmwit> Are you using records?
13:44:28 <joricj> data IRCMessage = IRCMessage { cmd :: String, args :: [String], trailing :: String }
13:44:35 <dmwit> foo { fieldName = newValue, otherFieldName = otherNewValue, ... }
13:44:51 <joricj> aaah
13:44:52 <skorpan> @pl \x -> player (snd x) == n
13:44:52 <lambdabot> (n ==) . player . snd
13:44:58 <skorpan> nice
13:44:59 <joricj> that looks excactly what i need, thx!
13:45:12 <joricj> @src snd
13:45:12 <lambdabot> snd (_,y) =  y
13:45:43 <skorpan> @pl \k -> attacked (fst k) game
13:45:44 <lambdabot> flip attacked game . fst
13:46:35 <skorpan> @pl \p -> case p of { (pos, Piece n King) -> True; _ -> False }
13:46:36 <lambdabot> (line 1, column 17):
13:46:36 <lambdabot> unexpected "{"
13:46:36 <lambdabot> expecting variable, "(", operator or end of input
13:46:54 <skorpan> no?
13:46:55 <dmwit> You can't ?pl pattern matches in general.
13:46:58 <skorpan> oh
13:47:13 <skorpan> that was the lambda function i really needed to have prettier
13:47:21 <dmwit> You'll need an "isKing" function or so.
13:47:35 <dmwit> Then you can write "isKing . snd".
13:47:40 <skorpan> @pl \p -> validMove (fst p) pos (snd p) game
13:47:41 <lambdabot> flip (uncurry (flip validMove pos)) game
13:47:45 <skorpan> lol
13:47:54 <roconnor> @hoogle (a ~> b) -> (c ~> d) -> ((a,c) ~> (b,d))
13:47:54 <lambdabot> Hoogle Error: Parse Error: Unexpected character '~> b) -> ('
13:48:10 <dmwit> :t (***)
13:48:11 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
13:48:17 <roconnor> @hoogle (arr a b) -> (arr c d) -> (arr (a,c) (b,d))
13:48:18 <lambdabot> Did you mean: Arr a b -> Arr c d -> Arr (a, c) (b, d)
13:48:25 <LordBrain> dons, will "Real World Haskell" contain a lot of up-to-date arguments for using haskell in the first  place and be suitable for complete new-comers to the language?
13:48:33 <gbacon> @hoogle (a -> b) -> (c ~> d) -> ((a,c) ~> (b,d))
13:48:33 <lambdabot> Hoogle Error: Parse Error: Unexpected character '~> d) -> ('
13:48:41 <gbacon> @hoogle (a -> b) -> (c -> d) -> ((a,c) -> (b,d))
13:48:41 <oklopol> @die 1d2
13:48:42 <lambdabot> No matches, try a more general search
13:48:42 <lambdabot> 1d2 => 2
13:48:44 <dmwit> roconnor: Are you just looking for the hoogle syntax, or did you want the actual answer?
13:48:53 <roconnor> dmwit: could I call the tensor product?
13:49:02 <roconnor> call that the
13:49:05 <dons> LordBrain: yes.
13:49:24 <dmwit> roconnor: ...I dunno.
13:49:42 <dmwit> ?hoogle Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
13:49:42 <lambdabot> Did you mean: Arrow a => a b c -> a B' C' -> a (b, B') (c, C')
13:49:46 <roconnor> quick, someone fetch a catagory theorist!
13:51:37 <gbacon> io $ findCategoryTheorist
13:52:52 <dmwit> Wow, hoogle is *really* bad at searching for Arrow stuff.
13:53:18 <dmwit> I searched for (***), copied the exact type signature it returned, and pasted that in the search box... no joy.
13:54:21 <skorpan> lol
13:55:08 <EvilTerran> it seems to not be very good with typeclasses
13:56:22 <MarcWeber> Anyone interested in a :ghci command within vim as well and want to help implementing it?
13:57:03 <cjb> you'd think people who want vim to be that extensible would just use emacs lke a normal person :)
13:57:04 * cjb duck.
13:57:27 <idnar> woo viper
13:57:41 <sethk> MarcWeber, I'm compiling from within vim.  I'd be mildly interested in ghci within vim, but only if the effort to get it working is modest.
13:57:51 <idnar> what would the comman do?
13:58:16 <MarcWeber> idnar: Execute arbitrarely haskell snippets the way :py supports python scripting
13:58:24 <gbacon> launch nethack, of course
13:58:29 <idnar> oh
13:59:16 <MarcWeber> sethk Don't know how much effort it is.. Adding some commands and using the already existing ghc lib can't be that hard.. (I'm struggling with how to pass configured options to C code (via defines ) now)
13:59:57 <EvilTerran> sethk, unfortunately that'd probably be quite hard, seeing as it says in the vim manual that embedding a terminal, even, would involve massive re-writing
14:00:05 <sethk> MarcWeber, I haven't been down in the guts of vim for quite a while.  If you're stuck I'll try to look at it.
14:00:20 <sethk> EvilTerran, ok, sounds like the comment about emacs is apt  :)
14:00:45 * EvilTerran tends to just have screen running with ghci in one frame and vim in t'other
14:00:54 <Eelis> i'm reading Erik Meijer's "Functional Programming with Bananas, Lenzes, ...". in section 3 he seems to be saying that arrow, the function space constructor, is a bifunctor. however, when i try to write that in Haskell with a   class Bifunctor f where bimap :: (a -> b) -> (a' -> b') -> f a a' -> f b b'  , i can't get the types to add up for an instance Bifunctor (,).  any suggestions?
14:00:59 <allbery_b> wait, what?  I thought it already did that
14:01:20 <MarcWeber> sethk Thanks. Do you know from memory how to get some env vars from within configure into feature.h ?
14:01:38 <sethk> MarcWeber, you mean the gnu configure script?
14:01:42 <Eelis> sorry, i meant instance Bifunctor (->)
14:01:48 <MarcWeber> sethk: Yes.
14:02:00 <roconnor> Eelis: (,) and (->) are not both bifunctors
14:02:15 <oerjan> Eelis: (->) is contravariant in its first parameter
14:02:17 <roconnor> -> is contravarient in it's first argument, while (,) is covarient.
14:02:27 <sethk> MarcWeber, I think you'll have to add an option to configure for it.
14:02:33 <MarcWeber> sethk: http://rafb.net/p/hkfeWg16.html
14:02:34 <lambdabot> Title: Nopaste - No description
14:02:45 <Eelis> roconnor: right, that makes sense. so is Erik Meijer just being "flexible" in the paper?
14:02:48 <roconnor> Can we come up with new names for covarient and contravarient.
14:03:10 <MarcWeber> sethk: There is a small bug in it. The next thing I have to figure out is how to get that configured option into C defines (where to add it to the Makefiles etc..)
14:03:11 <roconnor> like warm fuzzy and stinky turd?
14:03:28 <sethk> MarcWeber, Try setting CPPFLAGS
14:03:33 <MarcWeber> sethk: Do you think it's easier to figure out how to make gcc comtpile generated C code or to use ghc to compile vim ?
14:03:59 <sethk> MarcWeber, I'd guess the former, but that may only be because I've more experience there.
14:04:44 <MarcWeber> sethk: He. That's cool. I bet I'll ask you about this :)
14:06:14 <oerjan> Eelis: you could probably generalize to something that worked for both.  say class BiVFunctor (~>) (~~>) f where bivmap :: (a ~> b) -> (a' ~~> b') -> f a a' -> f b b'
14:07:09 <Eelis> oerjan: heh. i'd started defining a separate ContraBifunctor class, but your BiVFunctor looks much more fun ;)
14:07:59 <roconnor> what can be said about the BiVFunctor class?
14:08:32 <ilyak_> Is it not possible to write a Monad that limits types of a and b or mandates some relation between them?
14:09:11 <oerjan> (~>) and (~~>) would be the arrow types of two categories, i guess
14:09:22 <MarcWeber> EvilRanter: By the way: This patch alreadhy exists but got never integrated into the official distribution..
14:09:32 <ilyak_> oerjan: I guess I'll lose monad's syntax sugar that way
14:09:35 <oerjan> Hask itself for (->), Hask^op for something else
14:09:37 <ilyak_> And I like it :)
14:09:41 <MarcWeber> EvilTerran: This was for you :)
14:10:14 <allbery_b> wow.  nvi can :script, vim can't.
14:10:17 * allbery_b hugs nvi
14:10:19 <Eelis> oerjan/roconnor: anyway, thanks.
14:10:20 <joricj> in general, it doesn't matter if i move top live definition up or down, or does it?
14:10:36 <MarcWeber> allbery_b: Which :script language?
14:10:37 <Heffalump> ilyak_: if you use -fno-implicit-prelude then do notation desugars to whatever (>>=) and return you have in scope.
14:10:58 <allbery_b> nvi's :script is like the unix script command.  it starts an interactive shell in a buffer
14:10:58 <ilyak_> Heffalump: Cool, I guess I can do that
14:11:17 <allbery_b> there are separate commands for perl/tcl/pythoin scripting (when built with support)
14:11:24 <Heffalump> but obviously that precludes using normal Monads in the same source file
14:11:40 <MarcWeber> allbery_b: sure vim can this as well, even ruby and scheme. (but no haskell yet)
14:11:53 <allbery_b> er?
14:12:02 <allbery_b> I am not talking about command scripting.
14:12:13 <allbery_b> I am talking about what emacs calls process buffers
14:12:21 <sethk> I love when Heffalump says "obviously"; I know I'm about to feel really dumb
14:12:22 <ddarius> co/contra-variant
14:13:01 <ilyak_> By the way, I wonder how big is the gap between having do {} sugar and having macro system that is able to implement do {} by itself
14:13:09 <ilyak_> I can see some uses for it, to be honest :)
14:13:10 <allbery_b> <EvilTerran> sethk, unfortunately that'd probably be quite hard, seeing as it says in the vim manual that embedding a terminal, even, would involve massive re-writing
14:13:17 <allbery_b> *that* is what nvi's :script does
14:13:29 <Heffalump> sethk: do I say "obviously" a lot, then?
14:13:44 <sethk> Heffalump, no, only when you are saying things that are really hairy  :)
14:13:54 <ddarius> Heffalump: obviously
14:14:29 <mae> am i to understand that Haskell && x86_64 != work
14:14:39 <sethk> allbery_b, how does nvi compare to vim in general?
14:14:42 <dons> mae, that is false.
14:14:50 <MarcWeber> mae: Why?
14:14:55 <Heffalump> so would now be a bad time to discuss my cunning idea? :-)
14:15:08 <oerjan> Heffalump: Obviously
14:15:10 <mae> MarcWeber: i get cannot execute binary file when running an executable compiled on my fedora 6 x86_64 host
14:15:11 <Heffalump> ok then.
14:15:13 <dons> Prelude System.Info> System.Info.arch
14:15:14 <dons> "x86_64"
14:15:16 <MarcWeber> mae:  I'm running HAppS on x86_64 ..
14:15:17 <conal> does anybody have lhs2tex 1.13 (latest) working with cabal 1.3?
14:15:18 <sethk> Heffalump, not at all, just don't expect folks like me to grasp it immediately
14:15:32 <Heffalump> I still need to work out if it's correct, anyway.
14:15:35 <allbery_b> sethk: generally nvi is simpler; it mostly duplicates old vi
14:15:38 <MarcWeber> mae: what does file <your exectubale> say?
14:15:40 <dons> mae, there are possible package reasons for this. are you using a 32 bit ghc on a 64 bit machine?
14:15:53 <mae> Main.exe: Mach-O executable i386
14:15:53 <allbery_b> in fact it started as the BSD folks reimplementing vi after the AT&T license debacle
14:15:55 <mae> heh
14:16:01 <MarcWeber> mae: :)
14:16:13 <mae> MarcWeber: so do i need to give ghc a special flag?
14:16:20 <ilyak_> @src monad
14:16:20 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
14:16:20 <dons> mae, what platform?
14:16:21 <MarcWeber> mae: No, you need to recompile it :)
14:16:22 <Lemmih> mae: It should just work.
14:16:47 <ilyak_> Sorry, was thinking I'm in private :(
14:16:56 <dons> 64 bit windows?
14:16:58 <mae> Linux 2.6.9-023stab044.11-smp #1 SMP Sat Sep 29 13:36:25 MSD 2007 x86_64 x86_64
14:17:20 <dons> mae, why is it generating Main.exe and Mach-O objects?
14:17:25 <MarcWeber> mae: Have you compiled the executable for sure? Or did you copy the directory from somewhere else (x86) ?
14:17:31 <mae> you got me ; )
14:17:32 <dons> on linux/x86-64 we should see ELF files.
14:17:37 <mae> hmm this is possible
14:17:38 <mae> ls
14:17:51 <mae> AHA! the binary is in my repository
14:17:52 <mae> lol
14:17:56 <allbery_b> I like nvi because I like small editors for most stuff (in fact I never use :script) --- I use emacs for "big stuff" andf nvi for "small stuff"
14:17:56 <mae> sorry i'm an idiot
14:17:59 <dons> mae?
14:18:01 <mae> thanks all for help
14:18:06 <MarcWeber> mae: That's why I told you recompile it.. Never mind :)
14:18:12 <dons> were you trying to execute a windows binary on linux?
14:18:20 <mae> are .hi files plat independent
14:18:25 <dons> nope.
14:18:28 <mae> k
14:18:35 <MarcWeber> mae: But if you happen to know how to cross copmile.. then ping me.. I'd like to add this feature to nix one day:)
14:18:39 <dons> consider each ghc as an island unto itself
14:18:43 <dons> trapped in monad Platform
14:20:56 <lament> allbery_b: surely there're smaller editors than nvi?
14:21:02 <dmwit> ...along with nuclear waste and apples?
14:21:08 <mae> MarcWeber: what the heck is nix, you keep syaing this, are you talking about linux/unix?
14:21:16 <dons> nixOS?
14:21:24 <mae> MarcWeber: are you on windows?
14:21:49 <MarcWeber> mae: http://nix.cs.uu.nl/ kind of pure linux
14:21:50 <lambdabot> Title: Nix
14:22:24 <allbery_b> lament: surely, but few that are not command line stuff like /bin/ed (and the ones that are tend to use odd commands I don't know, whereas been using vi since 1982)
14:22:47 <lament> wow. I wasn't even born then.
14:22:50 <allbery_b> I should perhaps have said "minimalist"
14:23:18 <lament> kinda puts in perspective how old and pathetic vi is :P
14:23:34 <allbery_b> erm, emacs is older
14:23:52 <dmwit> And more pathetic!
14:23:55 <dmwit> *zing*
14:24:02 <dons> emacs is older than vi?
14:24:03 <lament> allbery_b: sure, i use vi :)
14:24:22 <allbery_b> emacs dates from the heyday of mit lisp
14:24:32 <allbery_b> I think it predates unix even
14:24:42 <dmwit> vi may be old and pathetic, but all the new stuff is just new and pathetic
14:24:43 <dons> 1976 for Vi, intiail Emacs release, 1976
14:24:47 <lament> wikipedia to the rescue!
14:24:49 <dons> both were released in 1976
14:24:54 <allbery_b> which emacs?
14:25:02 <dons> ah, GNU!
14:25:14 <allbery_b> 1976 sounds right for vi but I thought emacs started out as TECO macros in the 60s
14:25:15 <dons> i.e. TECO macros
14:25:35 <dons> the TECO macros were released in 76, sez wikipedia.
14:25:40 <allbery_b> ah
14:25:43 <dons> but TMACS was older
14:25:47 <dmwit> Here's a truly lost art: determine what your (screen-)name does in TECO.
14:25:48 <dons> Steele's precursor
14:26:03 <allbery_b> heheh
14:26:13 <dons> and TECO goes back to 1963
14:26:26 <lament> yay for obsolete software
14:26:45 <allbery_b> hm, maybe an early version existed but was unreleased back then
14:26:49 <Cheery> hm. Maybe I need to clarify how normal order evaluation is applied
14:26:53 <lament> software from the 60 is like music from the 60s. Old and pathetic. :D
14:27:20 * dons slaps lament
14:27:53 <lament> dons: you're not from the 60s, are you? :D
14:28:08 * allbery_b is
14:28:10 <dons> i guess you mean pop music from the 60s
14:28:11 <tromp> some of us are
14:28:27 <allbery_b> as for pop music... beatles?
14:29:02 <Cheery> say, how WHFN and supercombinators related?
14:29:36 <LordBrain> is Bryan Sullivan in here?
14:29:40 <ac> is Ryan Ingram around by any chance?
14:30:52 <ddarius> @seen bos
14:30:52 <lambdabot> bos is in #haskell and #ghc. I don't know when bos last spoke.
14:31:12 <LordBrain> dons, you guys could improve the public beta system for "Real World Haskell" by allowing comments on this page http://book.realworldhaskell.org/beta/  Then you could get suggestions on chapters which don't yet have drafts.
14:31:13 <lambdabot> Title: Real World Haskell
14:31:37 <Cheery> ah, IC, it is called a weak head normal form!
14:32:36 <dons> LordBrain: why not join the discuss@ mailing list?
14:32:55 <LordBrain> sure
14:34:16 <Cheery> does an evaluation strategy, that relies on supercombinators need to care about evaluation strategy at much except using the normal evaluation?
14:34:36 <LordBrain> where do i do that dons?
14:35:01 <dons> LordBrain: check the blog, it has details
14:41:01 * Heffalump wonders if there'll be any movement on haskell' any time soon
14:41:22 <dons> Heffalump: yes!
14:41:38 <dons> SimonM is comitting as we speak
14:41:56 <byorgey> o.O
14:42:05 <byorgey> committing what?
14:42:20 <glguy> to commit!
14:42:27 <lament> heh, bill joy on vim: "The fundamental problem with vi is that it doesn't have a mouse and therefore you've got all these commands."
14:42:36 <lament> s/vim/vi obviously
14:43:06 <glguy> sounds like bill joy hasn't use vim and you haven't used regexps ;)
14:43:20 <Heffalump> that was why I asked, but the commits seem quite trivial so far :-)
14:43:42 <lament> more bill joy: "EMACS is a nice editor too, but because it costs hundreds of dollars, there will always be people who won't buy it."
14:43:59 <mauke> wtf
14:44:04 <allbery_b> ah, back in the gosmacs days
14:44:23 <allbery_b> mauke: gnu emacs was in large part created because of the commercial Gosling emacs
14:45:01 <allbery_b> (and RMS's being mortally offended by Goslink taking the previously open Emacs sources and locking them up)
14:45:06 <allbery_b> Gosling
14:45:07 <mauke> ah
14:45:13 <conal> gosmacs was commercial?
14:45:28 <allbery_b> back in the day, yes
14:45:56 <conal> i guess i used it before then (at cmu)
14:46:24 <dons> Heffalump: are you on H'-private?
14:46:42 <lament> bill joy is an amazing fellow
14:46:43 <lament> "When I'm writing programs, I can type them in half the time with cat because the programs are six lines - a #include, main and a for loop and one or two variables."
14:46:54 <allbery_b> hehehe
14:47:51 <ski> Happy Happy Joy Joy.
14:48:07 <xerox> ♥
14:48:21 <oerjan> is that joy over Happy, or are you happy over Joy (the language)?
14:48:52 <ski> neither, in fact
14:48:55 <xerox> It's from MIT scheme!
14:51:02 <lament> MIT scheme is for some reason always happy when I kill it.
14:52:04 <Heffalump> dons: no.
14:52:24 <joricj> :t accept
14:52:24 <Heffalump> I presume it's, well, private :-)
14:52:25 <lambdabot> Not in scope: `accept'
14:52:32 <oerjan> @hoogle accept
14:52:32 <joricj> :t Network.accept
14:52:34 <lambdabot> No matches found
14:52:34 <lambdabot> Network.Socket.Socket -> IO (GHC.IOBase.Handle, Network.Socket.HostName, Network.Socket.PortNumber)
14:53:41 <malcolmw> Heffalump: you can see JaffaCake's commits on the cvs-other list (I think)
14:54:04 <Heffalump> they seem to be going to haskell-prime@
14:54:09 <Heffalump> at least 3 have done so far
14:54:21 <malcolmw> ah, yes, that's the right list
14:54:36 <joricj> the way tcp works, i can trust on (HostName,PortNumber) to be unique for every Handle, no?
14:55:13 <Heffalump> joricj: not over time
14:55:28 <Heffalump> but for a given fixed set of live connections, yes
14:55:34 <Heffalump> unless Handle does something weird, anyway.
14:55:42 <joricj> because i want to store information for every client thread
14:55:52 <joricj> so i need a key for my Data.Map
14:56:22 <joricj> i was passing Handle's around untill now untill i realized it doesn't have Ord so it's useless as a ey
14:56:55 <Heffalump> can't you get an Int from it somehow?
14:57:20 <joricj> hmm
14:58:00 <Heffalump> hmm, perhaps not
14:58:04 <allbery_b> use an intermediate map from unique-key to Handle
14:58:22 <allbery_b> System.Posix.IO can map between Fds and Handles
14:58:25 <joricj> allbery_b: but how do i get the unique key?
14:58:27 <bparkis> suppose you have a list of things, S, and a sequence of sublists s1, s2, ..., sn where each sublist retains the order of S but might not have the same number of elements
14:58:46 <allbery_b> generate it on the fly.  (hide in state or use an evil global variable via unsafePerformIO)
14:58:46 <joricj> oh
14:59:09 <joricj> what's unsafePerformIO?
14:59:20 <allbery_b> heh.  something you should probably avoid
14:59:25 <joricj> oh ok
14:59:29 <joricj> :)
14:59:31 <dmwit> bparkis: Sounds like Project Euler to me! =)
14:59:38 <bparkis> you could store the sublists as an additional note attached to each element of S: an array of pointers to the next element
14:59:47 <allbery_b> basically it's a hack to do I/O on the fly; the most common and sanctioned usage is to create global state
15:00:07 <bparkis> where each pointer has a number associated with it indicating which was the sublist where that pointer was _first_ relevant
15:00:37 <allbery_b> [ myGlobalVar :: IO Int; myGlobalVar = unsafePerformIO $ newIORef 0 ]
15:00:44 <dmwit> bparkis: You are wondering how to do this in Haskell?
15:00:57 <bparkis> this would reduce the storage space required to store s1 ... sn, and you could traverse any of the s_i's in time proportional to its length times a log factor
15:01:03 <joricj> oh okay. one more question, does Haskell automatically figure out how to do (Handle,String,Int) < (Handle,String,Int)?
15:01:10 <allbery_b> requires various kinds of evil to make sure it behaves properlu
15:01:19 <allbery_b> @instances Ord
15:01:20 <lambdabot> (), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
15:01:39 <bparkis> well dmwit I've found this channel to be a good forum for general algorithms stuff
15:01:41 <allbery_b> huh, I thought there was Ord for tuples
15:01:48 <dmwit> joricj: Yes, provided it knows how to do (Handle < Handle).
15:01:55 <dmwit> allbery_b: There is.
15:02:11 <allbery_b> didn't see it above
15:02:26 <joricj> dmwit: it doesn't...
15:02:35 <dmwit> > (3, 4) < (3, 5)
15:02:35 <lambdabot>  True
15:02:42 <allbery_b> anyway, given a definition for various length tuples, if the tuple's contents are Ord then the tuple can be Ord
15:02:44 <dmwit> > (3, 4, 5) < (3, 5, 6)
15:02:44 <lambdabot>  True
15:03:44 <dmwit> bparkis: Well, in Haskell, since purity ensures that values are unchanging, a sublist will share pointers with the list is was formed from.
15:03:53 <dmwit> bparkis: So that particular structure is much nicer in Haskell than in most languages.
15:04:13 <dmwit> bparkis: It is just [[Foo]], and you can use all the usual Data.List functions on it.
15:04:20 <bparkis> dmwit: I think I wasn't clear, I will write it out more specifically
15:05:54 <MarcWeber> Why does ghc -e "putStr "test"' print some control characters?
15:06:01 <MarcWeber> Can I switch this off?
15:06:25 <dmwit> Maybe it's your shell?
15:07:01 <MarcWeber> dmwit: When using ghc -e 'putStr "test"' | vim -  Its my shell? Wow!
15:07:13 <dmwit> Dunno, I did:
15:07:23 <dmwit> ghc -e 'putStr "test"' > test
15:07:30 <dmwit> and test was 4 bytes long.
15:07:55 <glguy> ghc -e 'putStr "test"' | vim -
15:07:58 <glguy> works nicely too
15:08:29 <dmwit> Yeah, I can't reproduce the issue here.
15:08:37 <MarcWeber> dmwit: Thanks. I've written ash wrapper. Maybe that is writing these characters..
15:11:27 <joricj> :t Network.accept
15:11:27 <lambdabot> Network.Socket.Socket -> IO (GHC.IOBase.Handle, Network.Socket.HostName, Network.Socket.PortNumber)
15:14:18 <joricj> > fac 100
15:14:18 <lambdabot>   Not in scope: `fac'
15:14:32 <joricj> > 100!
15:14:32 <lambdabot>   parse error on input `}'
15:14:41 <dmwit> > product [1..100]
15:14:42 <lambdabot>  9332621544394415268169923885626670049071596826438162146859296389521759999322...
15:15:16 <ski> @let fact = product . enumFromTo 1
15:15:17 <lambdabot> Defined.
15:16:06 <dmwit> ?fact fact
15:16:06 <lambdabot> fact: A fact is a fact is a fact is a fact. Or not.
15:17:13 <ski> @fib fib
15:17:13 <lambdabot> Maybe you meant: faq ft id
15:18:07 <vincenz> A fib is a fib is a fact is a fib is a fib.
15:18:11 <vincenz> :)
15:18:14 <vincenz> That's correct
15:19:09 <byorgey> @seen Cale
15:19:09 <lambdabot> Cale is in #haskell, #haskell-overflow and #ghc. I last heard Cale speak 1h 56m ago.
15:20:58 <lament> how do i declare void pointers in ffi?
15:21:19 <Cheery> was C a b = S a (K b)  or S (K a) b ?
15:21:39 <Cheery> oh wait
15:22:00 <Cheery> I remember B a b v → a (b v)
15:22:10 <Saul_> in vectorcalculus, if I have s * v1 = v2, then what is s?
15:22:13 <Cheery> so therefore, C a b v → (a v) b
15:22:20 <Saul_> where s is a scalar and v1 and v2 are vectors?
15:22:22 <mauke> yeah, C = flip
15:23:28 <roconnor> only strong monads are applicative functors, right?
15:23:34 <lament> to declare a void pointer, do i just write (Ptr a) in the signature?
15:23:42 <Botje> RARRR, MONAD SMASH!
15:23:48 <Saul_> I would say s = v2 / v1, but I'm not sure vectors are divisible
15:24:13 <ptolomy2> How efficient can I expect the code that GHC compiles  StateT IO code like (modify (\x -> x + 1))  to be? Best case would be a couple of instructions, I suppose.
15:24:19 <piojo> Botje: meow, warm fuzzy thing, meow
15:24:30 <Botje> :)
15:25:04 <Saul_> anyone??
15:25:41 <Botje> Saul_: s*v1 is every component multiplied by s, giving s2
15:25:51 <Botje> *v2
15:25:59 <Botje> if you want to go from v2 to v1, simply multiply by 1/s
15:26:31 <piojo> v2 = map (*s) v1
15:27:21 <Saul_> But I want to go from v2 to s?
15:27:35 <Botje> divide v2 by v1, component-wise
15:28:03 <piojo> you only need one element from each vector, though
15:28:06 <Botje> or just divide the first elements
15:28:12 <Saul_> ok, so that would be v2 `dot` (1/v1)?
15:28:36 <piojo> if v1 and v2 aren't empty, s = (head v2) / (head v1)
15:28:37 <dmwit> zipWith (/) -- maybe?
15:29:40 <ptolomy2> I'm finding myself a little frustrated, because a whole host of performance improvements that I'm considering require mutable state, but I get the impression that IORefs and StateT have enough overhead that it may not be worth it.
15:29:48 <Cheery> how spine is eliminated from the G-machine?
15:30:16 <sethk> Cheery, there's a paper available on line that has the details
15:30:21 <Saul_> ok thanks guys
15:31:43 <Cheery> sethk: do you know the main details about it?
15:32:04 <sethk> Cheery, I read the paper, but several months ago.  Let me look at it a moment.
15:34:21 <mae> are haskell threads os threads or lightweight threads
15:34:31 <forkiliens> is it a good style to declare an instance for show for a Maybe Type?
15:34:35 <mrd> mae: both
15:34:39 <ptolomy2> @type map
15:34:40 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
15:34:55 <forkiliens> i thought something like: show Nothing = ""
15:34:55 <mrd> lightweight threads can be dsitributed across multiple OS processes
15:35:02 <piojo> mae: at runtime, you pass the executable a flag to determine how many OS threads are allocated (default is 1)
15:35:03 <mrd> that can be*
15:35:05 <forkiliens> what do you say?
15:35:29 <kpreid> forkiliens: Maybe already has a Show instance
15:35:31 <dmwit> forkiliens: It should be done automatically.
15:35:43 <dmwit> forkiliens: (Assuming the wrapped type has a Show instance.)
15:35:58 <forkiliens> ok, i was implementig it for my own.. to learn about monads.
15:35:59 <forkiliens> :)
15:36:03 <kpreid> forkiliens: if you're trying to do some other kind of output, then you should use a typeclass other than Show
15:36:21 <forkiliens> no, i was computing the inverse of a matrix
15:36:33 <forkiliens> and implemented it as a maybe matrix
15:37:09 <ptolomy2> Anybody have experience with HsJudy?
15:37:12 <forkiliens> so for instance: inverse m, is a maybe matrix, since it does not have to have an inverse (in general)
15:38:05 <forkiliens> how is show for maybe a implemented?
15:38:15 <forkiliens> is: show Nothing = "" ?
15:38:16 <dons> you show the constructor, then show the field
15:38:39 <dmwit> forkiliens: show Nothing = "Nothing"; show (Just a) = "Just " ++ show a -- roughly
15:38:49 <forkiliens> aaah ok.
15:39:03 <forkiliens> thanks.
15:41:05 <chessguy> anybody here familiar with formal methods for requirements analysis?
15:42:32 * chessguy listens to the crickets chirping
15:42:43 <lispy> chessguy: I'm familiar with informal methods for informal requirements analysis :)
15:44:11 <chessguy> lispy, hmm. i'm trying to make sure i hit all the interesting use cases. i have 10 or so events that can happen, but there are all kinds of constraints on the order they can happen in
15:45:14 <chessguy> it feels like there should be a formal method involving some giant state machine that would do it, but i dunno
15:46:19 <monochrom> Ah, I know the exactly right formal method for that.  But I have to find the exact name.
15:46:44 * chessguy senses a joke coming up
15:48:49 <monochrom> LSC is the acronym.  SC = sequence chart.  I forgot L.
15:48:52 <ptolomy2> OOoh. Making a good Haskell Hashtable would be a good Google Summer of Code project..
15:48:59 * ptolomy2 looks for the place to suggest such things.
15:49:27 <monochrom> live sequence chart.
15:49:52 <piojo> ptolomy2: http://haskell.org/haskellwiki/Potential_projects ?
15:49:56 <lambdabot> Title: Potential projects - HaskellWiki
15:50:14 <cjb> There might be a SoC specific page, too.
15:50:28 <monochrom> It supports everything the "uml sequence chart" does (which is little), plus: "order doesn't matter here", "may vs must", "may-not vs must-not".
15:50:33 <chessguy> monochrom, thanks, i'll check it out
15:51:10 <monochrom> Great for making use-cases precise and complete.
15:51:22 <piojo> ptolomy2: cjb: http://hackage.haskell.org/trac/summer-of-code/wiki/SoC2008
15:51:23 <lambdabot> Title: SoC2008 - Haskell.org Google Summer of Code - Trac
15:51:30 <ptolomy2> piojo: Ah. Thanks. :)
15:51:46 * ptolomy2 finds the status of Data.Hashtable disgraceful, if understandable.
15:52:30 <monochrom> David Harel is the major proponent and probably also major inventor.
15:56:58 <augustss_> Don't use Data.Hashtable
15:57:27 <opqdonut> why?
15:57:41 <augustss_> it's got an ugly API
15:57:47 <dcoutts_> the range of tasks where it's appropriate is about this wide >.<
15:57:53 <monochrom> It's also a bit slow.
15:58:39 <lispy> It's funny that hash tables are so popular in dynamic languages and so unpopular in static languages
15:58:56 <lispy> I don't directly see a causality, but I suspect there is a correlation
15:58:56 <augustss_> are they unpopular in static languages?
15:59:11 <augustss_> I've used a lot of hash tables in C
15:59:24 <lispy> augustss_: maybe not unpopular in an absolute sense, but relatively speaking they seem unpopular to me
15:59:32 <ptolomy2> Despite the usefulness of Tries and Maps, I don't think they eliminate the need for hash tables.
15:59:38 <augustss_> they are unpopular in Haskell
16:00:02 <lispy> Which is too bad, it seems like you could use some type class magic to make them really nice
16:00:04 <ptolomy2> They are generally mutable, so the unpopularity is understandable. All things mutable tend to be ugly.
16:00:20 <lispy> Couldn't they be done the way Data.Map is done?
16:00:25 <lispy> Data.Map seems popular
16:00:31 <augustss_> they could
16:00:37 * lispy notes he knows nothing about Data.Map's interface
16:00:42 <monochrom> hash tables are popular in destructive languages.
16:00:48 <augustss_> but i'm not sure how efficient they would be
16:00:51 <ptolomy2> class Hashable a where hashValue :: a -> Word or something.
16:01:10 <dcoutts_> immutable hashtables would be fine
16:01:16 <lispy> put it in an STArray
16:01:22 <monochrom> Maybe it looks better in Disciple.
16:01:25 <ptolomy2> HashTable.ST
16:01:27 <lispy> that would make it mutable and fast right?
16:02:08 <twb> What's that cute little definition of (I think) Y using only the symbol "lambda" and punctuation?
16:02:43 <augustss_> twb: there is none in Haskell
16:02:48 <twb> Aw.
16:03:03 * twb wanders over to bug #lisp
16:03:13 <augustss_> Y = λf·(λx·f (x x)) (λx·f (x x))
16:03:32 <augustss_> but that doesn't type check in Haskell
16:03:35 <lispy> The other major feature I would want in a Hashtable implementation is a weak hashtable
16:04:01 * twb tries googling for "lambda lambda lambda"
16:04:02 <augustss_> lispy: but weak references is an orthogonal feature
16:04:52 <lispy> augustss_: how do you make it orthogonal?
16:05:01 <mauke> (setq Y #'(lambda (f) (funcall #'(lambda (x) (funcall f (funcall x x))) #'(lambda (x) (funcall f (funcall x x))))))
16:05:19 <monochrom> All the #' and funcall hurt my eyes.
16:05:31 <Maddas> #' isn't necessary there, is it?
16:05:37 <lispy> You don't need #' on a lambda in CL
16:05:45 <Maddas> Right.
16:05:53 <mauke> I included it for extra ugliness
16:05:53 <Maddas> And the funcall goes away for Scheme.
16:06:14 <monochrom> It is as though you're writing in Java and need all sorts of syntactic overhead just because you're using functions instead of objects.
16:06:34 <Maddas> Ah, perhaps you can also use punctuation instead of characters for variables.
16:06:36 <augustss_> lispy: keep weak pointers in your hash table.  this forces you into the IO monad, of course
16:06:43 <Maddas> monochrom: Except that you don't need it :-)
16:06:51 <augustss_> because it's highly non-functional
16:06:52 <mauke> $Y = sub { my $f = shift; sub { my $x = shift; $f->($x->($x)) }->(sub { my $x = shift; $f->($x->($x)) }) };
16:07:00 <opqdonut> :S
16:07:02 <monochrom> Well, funcall is still an eyesore.
16:07:20 <dcoutts_> augustss_: why don't we use immutable hashtables more? it seems fairly straightforward, Array Int [a] and a hash function (a -> Int)
16:07:21 <augustss_> monochrom: it sure is!
16:07:34 <Maddas> monochrom: Right.
16:07:58 <augustss_> dcoutts_: it's so easy to define Ord for types in Haskell and then ordered maps work fine
16:08:33 <dcoutts_> augustss_: there are probably circumstances where a hash is quicker due to fewer memory lookups
16:09:13 <dcoutts_> sure, the hash has to look at the whole thing you're hashing (usually) but that probably fits in a couple cache lines
16:09:32 <twb> For the record, I was thinking of this Common Lisp quine: ((λ (λ) `(,λ ',λ)) '(λ (λ) `(,λ ',λ)))
16:09:43 <lispy> I've never understood why someone would want to program in a language where the function abstraction allows you to make mistakes about which parameter you're accessing (eg., shift in perl)
16:09:51 <dcoutts_> or Array Int (Set a) to guard against worst case hash collisions
16:10:07 <augustss_> dcoutts_: yes, i'm sure there are cases where hash tables are faster
16:10:37 <augustss_> dcoutts_: but when i profile my code, it's rarely the maps that take up the time
16:10:45 <dcoutts_> augustss_: true true
16:10:55 <ptolomy2> Maps take up a considerable portion of the time in my code.
16:11:08 <lispy> Yeah, nlog(n) or faster usually isn't the bottle neck
16:11:24 <ptolomy2> And when it is, what should one do?
16:11:25 <monochrom> lispy: I see what you mean, but here is another perspective. Instead of thinking "parameters", if you think "parsing a stream", then shift makes a lot of sense.
16:11:34 <augustss_> ptolomy2: then you should investigate alternatives
16:11:35 <mauke> lispy: if I need multiple parameters, I use my ($x, $y, $z) = @_;
16:12:10 <monochrom> Also if you think "parsing a stream", you no longer make parameter mistakes.  (You make parsing mistakes, but that's really different.)
16:12:26 * ptolomy2 much prefers alternatives that someone smarter than himself built and tested.
16:12:40 <lispy> I should probably learn enough perl to know what ($x, $y, $z) = @_; means, but then, I haven't needed perl yet, so is it worth the effort?
16:12:41 <Maddas> lispy: I don't see why being allowed to make that mistake would stop you from wanting to use that language. It's no different from passing arguments in a list and popping off elements off that list.
16:13:23 <lispy> Maddas: but, I don't write all my functions to accept only lists
16:13:45 <lispy> Maddas: now that the stream point has been made, I can see that it would, at times, have merit
16:13:45 <Maddas> Indeed.
16:13:57 <Maddas> lispy: It's just a different way of doing things. I'm not sure what exactly you're getting at :-)
16:14:07 <monochrom> I use shift in Perl and shell scripts when I am processing command-line flags.  I don't use shift otherwise.  Fair?
16:14:43 <bos> ddarius: que?
16:14:46 <lispy> Maddas: to me, every function definition in perl is unsafe and compiling seems to offer no safety.  I quit using lisp as my language of choice for a reason :)
16:14:51 <Maddas> monochrom: shift is a regular array-processing function, not necessarily related to processing funciton arguments.
16:15:31 <Maddas> Function arguments, even.
16:15:31 <monochrom> I haven't really used Perl for a long time.
16:15:31 <lispy> These days I'm plauged by python at work :)
16:16:02 <mauke> lispy: ($x, $y, $z) = @_; is similar to let (x : y : z : _) = args
16:16:21 <lispy> The more I age as a programmer the more I want the machine to help me with the tedious parts that are unrelated to the real problem I want to solve.
16:16:55 <AndreWe> hi lispy, what don't you like about Python?
16:17:24 <lispy> Today that means Haskell is a good choice, tommorow maybe I'll be using some spiffy cool total language with a thin turing complete wrapper for IO
16:17:39 <lispy> AndreWe: the unsafe world of dynamic-only typing
16:17:47 <AndreWe> i see
16:18:02 <monochrom> I think your real beef is that here are several different things: parameter passing, list, array, stack, queue, ...  You want them to be of different types, but python and perl and etc use the same type for all of them, therefore some operations like shift are applicable to all, and you're unhappy.
16:18:03 <lispy> AndreWe: it means I have to spend more time on QA than I would have to spend in, say, Haskell.
16:18:31 <AndreWe> I'm just starting to learn Haskell, but the type system seems to be very sound, I like that.
16:18:52 <monochrom> In Haskell, they are made different types, so you're happier.
16:19:17 <lispy> AndreWe: the type system of Haskell is interesting enough you could spend quite some time just reading research papers about how to best exploit it and improve it
16:19:28 <joricj> and there's a type system on top of the type system
16:19:36 <lispy> joricj: kinds?
16:19:37 <AndreWe> which is?
16:19:37 <joricj> (called "kind"s)
16:19:50 <lispy> but, kinds is untyped essentially :)
16:19:51 <monochrom> And then, we come up with this great Data.Traversible class to cover them all, thereby giving you a shift operation to all of them, and so it's all the same again!
16:20:16 <joricj> but it's very dark magic, iam just starting out too and i never needed except when i wanted to create a Data.Map
16:20:45 <Philippa> AndreWe: kinds just make sure that you don't try to write "List Int String" as a type
16:21:09 <augustss_> kinds are like the simply typed lambda calculus, so you don't need another level above them
16:21:24 <augustss_> until you start doing fancier kinds!
16:21:36 <opqdonut> yeah you can pretty much ignore kinds
16:21:41 <joricj> what's a Functor?
16:21:44 <lispy> kinds make me want lambda abstractions at the type level
16:21:48 <AndreWe> Philippa: Sorry, I don't understand that. Could you elaborate, please?
16:21:49 <opqdonut> all the checks they do are pretty much "syntactic"
16:21:51 <Philippa> joricj: think of it as (f)Mappable
16:21:56 <lispy> so I can apply the type variables in the right places
16:22:00 <Philippa> AndreWe: List Int String isn't a valid type because list only takes one parm
16:22:05 <augustss_> lispy: it would be cool, but no more type inference
16:22:14 <Philippa> List has the kind * -> *, where * is "base type"
16:22:22 * AndreWe go it :-)
16:22:25 <joricj> mapable? like map or Data.Map?
16:22:28 * AndreWe got it :-)
16:22:57 <lispy> augustss_: I find that with higher rank types that I need to put a lot of type sigs anyway.  But, perhaps with type lambdas I would find it painful?
16:22:59 <augustss_> joricj: Functor is anything data structure that supports a map
16:23:05 <Philippa> you also get "higher kinds" - for example, given data Comp m a = Comp (m a), Comp :: (* -> *) -> * -> *
16:23:18 <Philippa> joricj: like map
16:23:26 <Philippa> in fact, the Functor instance for lists has fmap = map
16:23:37 <augustss_> lispy: I'm not sure it would be that painful, actually
16:23:38 <joricj> so it's an abstract way to say "collection"?
16:23:47 <Philippa> ...sort of, yes
16:23:56 <joricj> countable collection
16:23:57 <lispy> augustss_: Wouldn't you start needing it a lot more in things like do-notation?
16:23:58 <Philippa> it doesn't include ways of adding to or removing from the collection
16:24:03 <augustss_> joricj: except it includes things you would not think of as collections
16:24:04 <mauke> not necessarily countable
16:24:04 <Philippa> all you can do is map across it
16:24:16 <mauke> it doesn't even have to contain elements
16:24:33 <Philippa> all Monads are functors (if not necessarily instances of Functor) - liftM is their map
16:24:39 <joricj> but how can you map over something that doesn't contain any elements?
16:24:45 <Philippa> joricj: trivially
16:24:57 <joricj> oh
16:25:00 <mauke> data T x = T; instance Functor T where fmap T = T
16:25:00 <augustss_> lispy: I think do notations is orthogonal to type lambdas
16:25:15 <joricj> @src Functor
16:25:15 <lambdabot> class  Functor f  where
16:25:15 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
16:25:50 <lispy> augustss_: I thought maybe because it desugars to many lambda abstractions that if explicit type sigs are required it would imply you need type sigs in the do blocks
16:25:57 <augustss_> joricj: but you can think of f as some collection, it's a good approximation
16:26:16 <joricj> where can i learn all this stuff?
16:26:26 <mauke> @src (->) fmap
16:26:26 <lambdabot> fmap = (.)
16:26:29 <lispy> joricj: #haskell :)
16:26:40 <lispy> ?src [] fmap
16:26:40 <lambdabot> fmap = map
16:26:43 <mauke> surprise, functions are containers
16:26:56 <augustss_> joricj: there are lots of Haskell tutorials
16:27:01 <lispy> mauke: if they are 'containers' what do they hold?
16:27:02 * Philippa regrets not having asked for the rest of Graham Hutton's category theory notes when she was still at least nominally at UoN
16:27:09 <mauke> lispy: values
16:27:19 <Philippa> mauke: what *isn't* a container?
16:27:21 <lament> functions hold values?
16:27:31 <mauke> they're associative containers, so you need to provide a lookup key
16:27:38 <mauke> lookup f k = f k
16:27:39 <Philippa> lament: indexed by other values, yeah
16:27:43 <augustss_> lispy: you give the function the index value and it will give you back the value held at that position
16:27:54 <lament> oh, in that sense.
16:28:01 <lispy> okay, that's logical
16:28:11 <Philippa> joricj: "mappable thing" is a good intuition if it works for you :-)
16:28:37 <Philippa> containers're a good example of mappable things, but so are a surprising number of other things even when the functor doesn't forget everything
16:29:46 <idnar> I'm interested in the answer to Philippa's question ;)
16:29:50 <lispy> :t liftM2
16:29:51 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
16:30:07 <roconnor> is there a functor class for arrows?
16:30:17 <augustss_> idnar: well, continuations are not quite containers
16:30:29 <roconnor> oh wait, every function is an arrow.
16:30:30 <dmwit> Bool is not a container.
16:30:33 <roconnor> never mind.
16:30:35 <augustss_> they are kinda containers of anti-values, i guess
16:30:45 <AndreWe> Is there a documentation for the lamdbabot?
16:30:50 <Philippa> ...they don't make a big enough explosion
16:31:04 <lispy> AndreWe: kind of, the source is available and the supported commands can be listed
16:31:09 <lispy> ?version
16:31:09 <lambdabot> lambdabot 4p597, GHC 6.8.2 (Linux i686 2.40GHz)
16:31:09 <lambdabot> darcs get http://code.haskell.org/lambdabot
16:31:14 <lispy> ?commands
16:31:15 <lambdabot> Unknown command, try @list
16:31:17 <lispy> ?list
16:31:17 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
16:31:23 <lispy> AndreWe: those should get you started
16:31:36 <AndreWe> That's what I was looking for, thank you, lispy.
16:31:44 <augustss_> AndreWe: lambdabot is your friend
16:31:49 <augustss_> @botsnack
16:31:50 <lambdabot> :)
16:31:57 <jaj> @b52s
16:31:58 <lambdabot> It's a dreary downtown day, but at the end of my 40 foot leash is my little friend quiche.
16:31:58 <lispy> AndreWe: and some people say you're not an official member of #haskell until you contribute to lambdabot :)
16:32:22 <Philippa> yeah. Which leaves ops who aren't 'official members'
16:32:25 <augustss_> lispy: how many official members do we have?
16:32:42 <AndreWe> So, what do I have to do?
16:32:43 <Philippa> unless contributing to the quotes database counts, at least
16:32:48 <AndreWe> Is there a feature list? ;)
16:32:57 <mauke> @vixen is there a feature list?
16:32:57 <lambdabot> i'm sure there is
16:33:02 <lament> @quote lament
16:33:02 <lambdabot> lament says: hmph! i'm perfectly capable of writing obfuscated code by hand.
16:33:14 <augustss_> @figlet
16:33:14 <lambdabot> usage: figlet <text>.
16:33:22 <augustss_> @figlet foo
16:33:22 <lispy> AndreWe: lambdabot has a plugin design, so the features are defined by the set of modules you're using
16:33:22 <lambdabot> Couldn't run the figlet command.
16:33:44 <lament> figlet seems like a BAD idea.
16:33:46 <lispy> AndreWe: you'll like this one for code dev:
16:33:51 <lispy> ?hoogle [a] -> a
16:33:51 <lambdabot> Prelude.head :: [a] -> a
16:33:51 <lambdabot> Prelude.last :: [a] -> a
16:33:51 <lambdabot> Data.List.head :: [a] -> a
16:34:09 <augustss_> @freshname
16:34:09 <lambdabot> Hah
16:34:17 <augustss_> @freshname
16:34:17 <lambdabot> Hai
16:34:37 <lispy> AndreWe: and she can also do automatic refactoring for you
16:34:39 <augustss_> first i thought the bot was being cheeky!
16:34:49 <lispy> ?pl \x -> reverse (reverse x)
16:34:49 <lambdabot> reverse . reverse
16:35:00 <AndreWe> That's nice :-)
16:35:13 <lispy> ?unpl reverse . reverse
16:35:13 <lambdabot> (\ c -> reverse (reverse c))
16:35:44 <lispy> ?undo do { x <- [1..3], y <- "abc"; return (x,y)}
16:35:44 <lambdabot>  Parse error at "," (column 17)
16:35:46 <augustss_> @pl \ f g x -> f x (g x)
16:35:46 <lambdabot> ap
16:35:51 <lispy> ?undo do { x <- [1..3]; y <- "abc"; return (x,y)}
16:35:51 <lambdabot> [1 .. 3] >>= \ x -> "abc" >>= \ y -> return (x, y)
16:36:01 <lispy> ?redo [1 .. 3] >>= \ x -> "abc" >>= \ y -> return (x, y)
16:36:01 <lambdabot> do { x <- [1 .. 3]; y <- "abc"; return (x, y)}
16:36:20 <lispy> She can tell you how expressions are formed too
16:36:27 <AndreWe> how?
16:36:47 <lispy> > fix $ \fibs -> 1 : 1 : zipWith (+) (tail fibs) (fibs) :: [Expr]
16:36:48 <lambdabot>  [1,1,1 + 1,1 + 1 + 1,1 + 1 + 1 + (1 + 1),1 + 1 + 1 + (1 + 1) + (1 + 1 + 1),1...
16:36:55 <opqdonut> heh
16:37:09 <lispy> > 1 + 1 :: Expr
16:37:10 <lambdabot>  1 + 1
16:37:10 <AndreWe> @type zipWith
16:37:11 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
16:37:20 <augustss_> AndreWe: or write code for you if you know the type
16:37:24 <lispy> AndreWe: the magic there is just the :: Expr
16:37:26 <augustss_> @djinn a->a
16:37:26 <lambdabot> f a = a
16:38:05 <augustss_> > x^5
16:38:05 <lambdabot>  x * x * (x * x) * x
16:38:25 <lispy> oh yeah, x and f are special values of type Expr already
16:38:28 <lispy> :t f
16:38:29 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
16:38:29 <lispy> :t x
16:38:30 <lambdabot> Expr
16:38:43 <roconnor> > f x
16:38:43 <lambdabot>  Add a type signature
16:38:49 <roconnor> > f x :: Expr
16:38:49 <lambdabot>  f x
16:39:33 <augustss_> > recip x
16:39:33 <lambdabot>  recip x
16:39:48 <augustss_> > x * recip x
16:39:49 <lambdabot>  x * recip x
16:39:51 <lispy> > x `divMod` 5
16:39:51 <lambdabot>  (x `div` 5,x `mod` 5)
16:39:51 <AndreWe> that's too much for me to remember because I'm tired. But thank you all for the thorough introduction to lambdabot.
16:40:16 <augustss_> AndreWe: you'll see what people use it for
16:40:32 <AndreWe> Yes, see you tomorrow :-)
16:40:34 <AndreWe> Bye.
16:40:37 <lispy> AndreWe: bye
16:40:41 <lispy> sweet dreams
16:40:55 <lispy> (dream about lambdas!)
16:41:11 * lispy toss lambdas around the room shapr style
16:42:55 * roconnor throws a mu at lispy
16:44:58 <solrize> does anyone know how forkIO works?  i.e. is there a timer interrupt in the RTS or something?
16:45:30 <joricj> i've put my entire server state in one structure and pass that around everywhere (inside the IO Monad), the code doesn't look too good so i figured there might be a better way to do it.
16:45:35 <augustss_> you mean how it manages to time slice?
16:46:02 <augustss_> solrize: yes, there's a timer interrupt, but it's handled very carefully
16:46:17 <solrize> augustss yes thanks, thats what i was wondering
16:46:33 <joricj> i found an example of a monad on the wiki on the IRC_bot page, but its for read-only state only, how would i go about creating a monad for my server to handle the state so i can easily access and change the parts in it ?
16:46:58 <mauke> StateT s IO
16:47:05 <augustss_> solrize: you can only switch threads at certain safe points in the code
16:47:25 <joricj> mauke: okay i'll look that up
16:48:16 <solrize> augustss_ hmm yeah, i guess you wouldn't want to leave a graph node in some half-reduced state.  what happens if there's 1000's of threads, can they block for rather long times?  is all the regular i/o also interrupt driven?
16:49:13 <augustss_> solrize: threads can block indefinitely
16:49:13 <solrize> btw, motivation for the question is wondering whether trying to embed a python interpreter through the ffi would cause problems if both runtimes tried to set their own signal handlers
16:49:36 <dcoutts_> solrize: there is an IO manager thread (a Haskell thread) that manages blocking IO on behalf of all other Haskell threads that want to block to wait for completion of IO
16:49:36 <mauke> http://cale.yi.org/index.php/How_To_Use_Monad_Transformers
16:49:39 <lambdabot> Title: How To Use Monad Transformers - CaleWiki
16:49:42 <augustss_> solrize: yeah, that might be a disaster
16:49:58 <solrize> dcoutts_ thanks
16:50:16 <monochrom> The IO manager thread uses select() IIUC.
16:50:19 <solrize> there is an example in the python wiki of packaging a haskell function plus the GHC RTS in a windows .dll
16:50:41 <solrize> and i wonder if that could be done for linux
16:51:03 <Baughn> solrize: A lot (a /lot/) of GCs want to catch SIGSEGV. Which means you usually can't combine two languages that use GCs, so..
16:51:04 <solrize> monochrom, yeah, select makes sense (or poll/epoll) if io is in its own threadlet
16:51:09 <augustss_> solrize: the Haskell rts doesn't play that well with others, it likes to be in control
16:51:16 <solrize> baughn python uses naive reference counting
16:51:18 <dcoutts_> solrize: you'd need a way for ghc's rts to get its timer without using a signal. I believe that's possible now in Linux to have timer events delivered via a FD.
16:51:31 <solrize> dcoutts_ hmm
16:52:06 <dcoutts_> augustss_: so long as they're in different OS threads I think they could live happily in the same process, there are only a few global resources to watch out for, like stdin/out/err and global signals.
16:52:36 <dcoutts_> and I think ghc now keeps stdin/out/err in blocking mode, at least in the threaded rts
16:52:51 <augustss_> dcoutts_: it might be better under linux, but under windows I've had to lobotomize the rts some
16:53:00 <dcoutts_> augustss_: oh, like what?
16:53:14 <dcoutts_> and did you send patches? :-)
16:53:27 <augustss_> dcoutts_: stop it from installing signal handlers, for instance
16:53:39 <Philippa> having encountered windows RTS bugs in the past I suspect it's not half as well maintained as the linux one
16:53:43 <dcoutts_> augustss_: I know the timer stuff changed recently for ghc on unix
16:54:13 <augustss_> dcoutts_: if you want to use Haskell as a DLL you don't really want it to take over a lot of signal and kill, e.g., Excel, if you hit CTRL-C
16:54:32 <dcoutts_> augustss_: I'm not sure what a signal handler is on windows
16:54:56 <augustss_> dcoutts_: well, whatever it is that does the corresponding things
16:55:14 <dcoutts_> augustss_: yes I can see that might be a problem :-)
16:55:35 <bos> augustss_: we have a smidge of build breakage in the llvm repo
16:55:42 <dcoutts_> I didn't think that non-console apps got a kill 'signal' when you use ctl-c
16:55:46 <augustss_> dcoutts_: or if the RTS discovers a fatal error it likes to abort(), also not very nice to the application
16:56:09 <dcoutts_> augustss_: right, it should return to the rts caller
16:56:14 <augustss_> dcoutts_: it might not have been ctl-c
16:56:25 <dcoutts_> augustss_: I'm sure JaffaCake would be happy to receive patches
16:56:43 <augustss_> dcoutts_: i've sent patches, some have been merged
16:56:49 <dcoutts_> great
16:57:09 <augustss_> the rts also leaks resources if you try to use it as a dll
16:57:15 <augustss_> like critical regions
16:57:21 <lispy> solrize: I was told recently that GHC cannot build a .so on linux
16:57:50 <lispy> solrize: I don't know if it's possible to build the .so manually and link against Haskell via the FFI
16:57:52 <dcoutts_> augustss_: so those were your patches that I saw going past about that a while ago then
16:58:11 <augustss_> it was a while ago, and some of the problems i've not bothered to fix
16:58:23 <dcoutts_> clearly you need some ghc rts monkeys
16:58:33 <augustss_> indeed
16:58:45 <sethk> lispy, are you sure that's true about shared libs?
16:59:07 <augustss_> dcoutts_: another big problem is that the rts is statically linked
16:59:15 <dcoutts_> for now...
16:59:22 <augustss_> dcoutts_: so all dlls are 10M or more
16:59:32 <lispy> sethk: fairly sure that GHC can't directly build a .so from your Haskell code.  Seems like I found that on the web and heard it here too, but I'm never 100% certain.
16:59:48 <dcoutts_> augustss_: yes, building haskell packages as .so/.dll will really help, once it gets stable
16:59:58 <augustss_> dcoutts_: i'm just venting my complaints, i know it's all fixable
17:00:15 <dcoutts_> augustss_: plenty for us all to do
17:00:24 <sethk> lispy, I do see "Hcs static flags: -static"  But I'm not sure exactly what it means
17:00:54 <solrize> oops i have to be afk temporarily, i'm not ignoring you... thanks
17:01:30 <lispy> sethk: I have a very low priority hobby project where I wanted to build .so files and after my little bit of research I decided that it was safest to link statically via the FFI and forget about using .so/.dll.
17:01:53 <sethk> lispy, k
17:02:32 <lispy> sethk: but, I my guess is that if you generated the .so file and linked in your Haskell code into that .so that it should work
17:02:39 <solrize> http://wiki.python.org/moin/PythonVsHaskell#line-82   the example i was referring to is here
17:02:40 <lambdabot> Title: PythonVsHaskell - PythonInfo Wiki
17:02:55 <sethk> lispy, yes, but that only helps (as I think you said) on the far side of the FFI
17:04:59 <lispy> sethk: but, judging by the conversation that dcoutts_ and augustss_ were just having, it may be in the development queue that we get .so support, BTW, I know building one big statically linked .dll is possible (i've done that before)
17:05:35 <augustss_> one big dll is certainly possible, and it works pretty well
17:05:56 <lispy> augustss_: I had a lot of problems unloading the dll, but otherwise it worked great
17:06:11 <dcoutts_> lispy, sethk: ghc can build .so's on linux and the equivalent on OSX using PIC etc, it's in ghc-6.8 but is not at all mature yet, wait for 6.10
17:06:14 <augustss_> lispy: yeah, but unloading dlls is a pain
17:06:21 <lispy> in the end, I just didn't unload it (why do I want to unload it anyway??)
17:06:27 <dcoutts_> the equivalent work for PIC code in .dll's on windows is stalled
17:06:40 <augustss_> lispy: you need some call to unload before dllmain gets the final call
17:06:52 <dcoutts_> the chap working on it got tired, see his post to the ghc users list
17:07:04 <lispy> dcoutts_: bummer
17:07:12 <augustss_> bummer indeed
17:07:18 <dcoutts_> it's there is anyone wants to pick it up
17:07:21 * Baughn has seen quite a few dozens-of-megabytes executables on windows lately. Apparently you aren't the only ones fed up with DLLs.
17:07:42 <dons> disk is cheap :)
17:07:56 <lispy> disk is cheap; let's go shopping!
17:08:01 <Baughn> ..why not. It'd probably have loaded one copy of the dll per executable /anyway/.
17:08:01 <augustss_> not all kinds of disk
17:08:08 <dcoutts_> for most windows apps which ship all their .dlls there is little point in using dlls
17:08:37 <dcoutts_> the advantage is if you're using package management so can actually share stuff, or if you're doing dynamic code loading, plugins, com etc
17:09:01 <augustss_> dons: the kind of disk we have to store the dlls that are used on the trading floor is not cheap
17:09:04 <lispy> dcoutts_: what about development effort?  You can compartmentalize the compilation and just rebuild the dlls you need and avoid slow linkers
17:09:29 <dcoutts_> lispy: what makes you think static linkers are slower that dynamic linkers?
17:09:31 <dons> augustss_: oh, interesting!
17:10:04 <lispy> dcoutts_: nothing :)
17:10:06 <augustss_> dons: it's the kind of disk that has lots of redundancy, backups, replication all around the world, etc...
17:10:14 <dcoutts_> lispy: you can still compartmentalise by building static libs
17:10:36 <Baughn> lispy: The actual linking never seems to take more than a fraction of a second even with truly giant projects, though..
17:11:14 <sethk> dcoutts, OK, that's good news about shared libs, because otherwise the size of the programs can become an issue.
17:11:16 <dons> augustss_: right
17:11:16 <lispy> Baughn: maybe I'm misreading the output when I compile things is VS at work, but I would say it definitely takes time on my machine
17:11:24 <augustss_> dons: if all our dlls where written in haskell they wouldn't fit on the storage we have
17:11:44 <dons> wow.
17:11:47 <Baughn> lispy: I don't know. Perhaps VS's linker is slower for some reason, then.
17:12:01 <Pfft_> VS's linker is dead slow.
17:12:17 <Pfft_> At work, we have a program that currently takes 20 minutes to link.
17:12:23 <augustss_> dons: they might fit on the disk you can buy in the supermarket, though
17:12:54 <ddarius> Pfft_: What's the SLOC?
17:13:19 <Pfft_> about 400k lines of code.
17:13:27 <dobblego> pfft, what's the SLOC - has a certain unintended tone to it :)
17:13:34 <augustss_> the VS linker is atrocious
17:13:53 <lispy> okay, so I wasn't being weird, others have noticed it too
17:14:04 <dcoutts_> it's probably disk seek limited
17:14:13 <dcoutts_> trying to not use too much ram
17:14:38 <Baughn> Pfft_: Wow. mplayer is 620kLOC, and takes.. mm, about .2 seconds to link when it's all already in cache
17:15:57 <Pfft_> I really don't know what VS is doing, but I don't think it particularly saves memory -- it tends to eat up hundreds of MB _also_. Sigh.
17:16:27 <lispy> Good thing it's open source so we ca--oh wait...n/m
17:17:24 <lispy> maybe I shouldn't say that though.  firefox is open source and a memory hog, but I've never bothered to send in a patch reducing the memory foot print
17:17:36 <ddarius> It didn't start off that way.
17:17:43 <SamB> ddarius: eh?
17:18:00 <SamB> are you implying that there is some remnant of Netscape 4 in there somewhere?
17:18:13 <Baughn> lispy: Lots of other people /have/, and 3.0b4 is considerably better than the last stable version
17:18:13 <lispy> SamB: no, that FF didn't use to be a memory hog
17:18:14 <Philippa> lispy: half of what makes firefox a memory hog is their refusal to have the GC release heap to the OS
17:18:18 <ddarius> Firebird seemed reasonably lightweight.
17:18:28 <augustss_> in the olden days, when firefox was called lynx...
17:18:32 <lispy> Baughn: oh is b4 out now?  I've been trying to keep an eye open for it
17:18:35 <ddarius> SamB: Though I did very much like Netscape 4.
17:18:35 <SamB> augustss_: links
17:18:45 <Baughn> lispy: You missed it. It's been out for a week
17:18:53 * lispy goes to download it
17:18:54 <SamB> Philippa: hey, GHC won't do it either
17:18:59 <augustss_> SamB: but that's not an animal
17:19:27 <Baughn> SamB: Which makes GHC a memory hog too, yes
17:19:43 <Philippa> SamB: AFAIK that's not due to an ideological stance that not all hardware can back up though
17:19:55 <SamB> Philippa: eh?
17:19:56 <Philippa> I mean, my laptop's only got 4G of storage, it doesn't /have/ any swap
17:20:12 <Philippa> SamB: "the OS should handle it, we should feel free to chew up all the RAM we feel like"
17:20:35 <Philippa> (and get swapped out as needed, goes the theory)
17:20:39 <SamB> ah
17:20:50 <SamB> do they do anything about, er, locality of reference?
17:21:01 <Philippa> I wouldn't be surprised if they compact
17:21:05 <lispy> IMO darcs is bad about this type of memory usage too
17:21:09 <lispy> it mmaps anything it wants to read
17:21:17 <dcoutts_> Philippa: actually, firefox is a prime example of an app that should use GC and allow movable heap objects so they don't get such bad fragmentation problems
17:21:17 <augustss_> I don't think they compact, that's the problem
17:21:19 <lispy> so patches are limited by the amount of virtual memory you have
17:21:29 <Philippa> thing is, if I used firefox on my eee like I used it on my desktop, it'd blow my memory on it
17:21:34 <Baughn> SamB: Ah, nope. It only just now got a GC that can even handle cycles
17:21:38 <lispy> dcoutts_: isn't that what they moved to in version 3?
17:21:54 <Baughn> SamB: The sad thing is, I think they did that by using reference-counting /and/ mark-and-sweep
17:21:57 <dcoutts_> lispy: I don't think they use GC even in ff3
17:22:10 <Baughn> dcoutts_: Oh, they do. Just not a good one.
17:22:10 <SamB> Baughn: oh joy, it's Python all over again
17:22:21 <SamB> well, or something like that
17:22:22 <dcoutts_> Baughn: well certainly not relocatable heap objects
17:22:25 <lispy> dcoutts_: hmm....it's certainly hard to tell from that one guys blog what exactly is going into FF3 for memory updates...
17:22:35 <dcoutts_> or they'd not be going on about heap fragmentation
17:22:53 <SamB> so, do they have any plans to stop allocating so many resources on the X server?
17:23:07 <lispy> didn't they address that already?
17:23:23 <dcoutts_> SamB: I think so, eg dropping uncompressed images on non-visible tabs
17:23:35 <SamB> oh, wait, they aren't DFSG free anymore so I don't update...
17:23:40 <dcoutts_> and decompressing them again when needed
17:23:45 <lispy> DFSG?
17:23:53 <SamB> trademark issues
17:23:56 <lispy> SamB: the debian thing?
17:23:59 <SamB> yah
17:24:16 <lispy> I dunno, iceweasel seems to be just enough different from FF to be annoying about it
17:24:21 <allbery_b> debian free software guidelines.  something about labeling and the firefox logo
17:24:27 <SamB> that's why I don't want to "update"
17:24:53 <lispy> Why don't we have a killer Haskell based webbrowser?
17:25:05 <lispy> We'd have a good GC already in there :)
17:25:05 <bd_> allbery_b: It's not DFSG so much as debian couldn't fit their security process and mozilla's trademark rules together
17:25:09 <ddarius> lispy: There aren't many web browsers peried.
17:25:29 <Philippa> lispy: so, so not worth the hassle
17:25:48 <Philippa> I don't think we have a big enough community to maintain a fully-featured one, even
17:25:56 <Baughn> lispy: Because implementing CSS/HTML is hard, implementing javascript is.. not as hard, and implementing quirks is.. pretty easy, but there are way. too. many.
17:25:57 <SamB> bd_: the trademark makes the NAME firefox, as well as all associated imagery, effectively not DFSG free...
17:26:17 <bd_> Yes, but that wasn't the primary reason - mozilla specifically objected to their processes
17:26:23 <bd_> and so debian really had no choice
17:26:47 <adiM> How do I get rid of the quotes around a string in a function?
17:26:49 <bd_> ie, mozilla wants you to just follow their latest release, but debian likes to avoid adding feature releases to stable, instead cherry-picking security fixes
17:26:53 <SamB> not only that, but the way mozilla was trying to be so controlling...
17:27:05 <adiM> > let f a = (show a) ++ " ; " in f "A"
17:27:07 <lambdabot>  "\"A\" ; "
17:27:16 <MarcWeber> When lazily reading a file into a bytestring.. Will the whole (huge) file be split into several chunks so that some can be freed again after processing before the whole file has been read to memory?
17:27:23 <adiM> I do not want the \" here
17:27:26 <bd_> and so debian sidestepped the issue by changing the name
17:27:36 <dcoutts_> MarcWeber: yep, 64k chunks
17:27:38 <bd_> MarcWeber: if you use Data.ByteString.Lazy
17:27:46 <mauke> adiM: don't call show
17:27:51 <dcoutts_> MarcWeber: yes, only for .Lazy
17:27:51 <Pfft_> Ah, but speaking of "implementing Javascript is hard" -- did any of you see the report from Viewpoints Research Institute? Javascript implemented in 140 lines of code.
17:28:00 <Pfft_> (and compiled to native assembly)
17:28:05 <Philippa> Pfft_: for what value of "Javascript"?
17:28:08 <SamB> even if Debian could have gotten to an arrangement that would have allowed them to do that, they would probably not have accepted unless everyone ELSE was also allowed to do that...
17:28:09 <adiM> I want to call the function on both strings and integers, mauke.
17:28:20 <MarcWeber> bd_ Yes I know about them. thanks @ dcoutts_ as well
17:28:25 <augustss_> adiM: let f a = a ++ " ; " in f "A"
17:28:27 <mauke> make your own typeclass/show'
17:28:29 <Pfft_> Philippa: almost the entire language of javascrpt 1.4, they say
17:28:45 <Philippa> 80/20...
17:28:59 <augustss_> adiM: then you need a special show
17:29:07 <adiM> mauke.. I did that, but still does not work
17:29:12 <ddarius> The -language- of javascript is not that large, but that's the easy part.
17:29:15 <Pfft_> Perhaps, but I was still extremel impressed
17:29:17 <mauke> then you did it wrong
17:29:40 <Philippa> ddarius: true, I may be considering too many things part of the language as well
17:30:04 <adiM> I tried this definition of toString http://hpaste.org/6531
17:30:31 <mauke> eww
17:30:37 <lispy> is there a way to make FF3 use the FF2 address bar? (sometimes change is bad...)
17:30:38 <Baughn> Pfft_: Javascript's simple. The DOM is just a database of sorts. The renderer.. that's where you can sink decades and never get anywhere.
17:31:30 <mauke> I'd remove the Show a => constraint and define each ToString instance separately
17:31:50 <adiM> mauke... ok, will try that
17:33:01 <adiM> mauke... thanks, a bit tedious, but works :)
17:33:31 <mauke> I have another solution
17:34:01 <SamB> Baughn: DOM is not just a database
17:34:14 <mauke> adiM: http://hpaste.org/6532
17:34:28 <SamB> it has that imperative thing going on, AND those CSS things that apply...
17:34:56 <Baughn> SamB: Thus the "of sorts". I know there's more to it, but once you have the HTML/CSS renderer running at all, the dom is a very thin layer on top
17:35:28 <SamB> but the DOM messes up the CSS stuff
17:35:52 <Baughn> You mean "allows you to change it"
17:36:12 <SamB> you go to all that trouble to figure out what elements have what attributes, and then the pesky javascript program comes along and rearranges the tree!
17:36:28 <augustss_> adiM: using incoherent instances is asking for trouble
17:36:42 <jsedgwick> any utility function to access the first n elements of a list (as a list)
17:36:45 * ddarius never uses overlapping instances, let alone incoherent ones.
17:36:49 <Baughn> SamB: Perhaps it's time for prolog?
17:36:50 <adiM> mauke...thanks, yor example works
17:36:50 <SamB> jsedgwick: it's called take
17:36:54 <SamB> Baughn: prolog?
17:36:58 <SamB> no...
17:37:00 <oerjan> adiM: a third way, http://hpaste.org/6532#a1.  then you need to wrap Strings in RS before passing them to f
17:37:01 <SamB> I don't think so.
17:37:03 <jsedgwick> SamB: thx
17:37:15 <SamB> @where preludew
17:37:15 <lambdabot> I know nothing about preludew.
17:37:16 <SamB> @where prelude
17:37:16 <lambdabot> http://www.haskell.org/onlinereport/standard-prelude.html
17:37:25 <SamB> jsedgwick: have a read through that?
17:37:29 <ddarius> oerjan: Your show implementation is wrong.
17:37:33 <oerjan> argh
17:37:38 <oerjan> forgot to unwrap
17:37:49 <ddarius> newtype NoQuotes = NoQuotes String; instance Show NoQuotes where show (NoQuotes s) = s
17:37:59 <ddarius> (from my xchat line history)
17:38:07 <adiM> augustss_ what is incoherent instances?
17:38:10 <oerjan> adiM: corrected http://hpaste.org/6532#a2
17:38:52 <mauke> -fallow-incoherent-instances
17:39:19 <adiM> oerjan: In this case, I would need to typecast each string as RS?
17:39:34 <newsham> I've played around with this idea a little before and wondering if this pattern is already widely used or has a name.  Basically when you want to modify something that is part of a larger whole you have to have a way to take apart the whole, modify the piece, and then put back together the whole.
17:39:35 <augustss_> adiM: you have instances that contradict each other
17:39:45 <mauke> adiM: not typecast, wrap
17:39:52 <newsham> more generally there might be multiple steps:  take apart A, take apart B, take apart C, replace D, put together C, put together B, put together A
17:40:06 <SamB> jsedgwick: on second thought, no, don't try to read that
17:40:12 <SamB> it has hardly any comments
17:40:24 <newsham> and what I was playing around with is building a path of these modifiers as "A `combined` B `combined` C `combined` D"
17:40:41 <adiM> I think that mauke's solution is the most convinient for me...
17:40:45 <BMeph> newsham: Check out Conal's "DeepArrow" for more on that concept. :)
17:40:54 <newsham> bmeph: got an url?
17:41:20 <BMeph> newsham: http://haskell.org/haskellwiki/DeepArrow
17:41:21 <lambdabot> Title: DeepArrow - HaskellWiki
17:41:27 <BMeph> :)
17:41:32 <newsham> tysir
17:41:59 <BMeph> You bet.
17:42:05 <oerjan> adiM: just mentioning for completeness - the other day i suggested mauke's version and someone else the one i pasted now
17:42:31 <mauke> heh. fugue'd
17:42:36 <newsham> hmm.. seems like the same concept, but he's only using it for altering tuples used in arrows?
17:43:19 <jsedgwick> also, how do i convert a digit char to int?
17:43:28 <oerjan> :t digitToInt
17:43:30 <lambdabot> Char -> Int
17:43:30 * SamB wonders if there is any good freeware for CD ripping on windows
17:43:42 <BMeph> newsham: Yes. That's really all he needs it for, though, so it's now a bad fit. You want to expand it to records, I presume.
17:43:47 * jsedgwick feels dumb.
17:43:49 * jsedgwick is right.
17:44:13 <oerjan> @hoogle Char -> Int
17:44:13 <lambdabot> Data.Char.digitToInt :: Char -> Int
17:44:13 <lambdabot> Data.Char.ord :: Char -> Int
17:44:13 <lambdabot> Data.ByteString.Char8.count :: Char -> ByteString -> Int
17:44:21 <newsham> could be used for lots of stuff, for example:  replace (HTML/Header/Field "Cookie"/FieldValue/Base64/Words/Nth 5) "newWord"
17:44:24 <SamB> jsedgwick: this, on the other hand... http://www.haskell.org/onlinereport/list.html
17:44:24 <lambdabot> Title: The Haskell 98 Library Report: List Utilities
17:44:38 <newsham> bmeph: not necessarily records,but can be.
17:44:43 <newsham> think of:   unwords.f.words
17:44:53 <newsham> thats one simple (inexact, words.unwords != id) example
17:45:18 <BMeph> Right - intriguing.
17:45:34 <adiM> oerjan... I'll keep both solutions in my source code...one for a rainy day :D
17:45:43 <oerjan> :)
17:46:03 * BMeph wonders what SamB's opinion of "CDBurner XP" is...
17:47:46 <solrize> i wonder if you could use generic zippers to do that javascript dom rearrangement functionally
17:48:28 <solrize> can someone explain in 1 sentence how generic zipper actually works?  specifically does it involve calling a saved continuation from inside some combinator that thinks it's way inside the tree?
17:50:55 <dobblego> dons, s/persistance/persistence
17:51:07 <dobblego> dons, http://reddit.com/r/programming/info/6cuf8/comments/c03hz2k
18:00:25 <forkiliens> why do i get a parse error, if i try to define the following class:
18:00:43 <forkiliens> infixl 1 *
18:00:43 <forkiliens> class Group g where
18:00:43 <forkiliens>  (*) :: g -> g -> g
18:00:43 <forkiliens>   e  :: g
18:01:01 <forkiliens> anyone there?
18:01:31 <mauke> compiles here
18:01:41 <mauke> oh wait
18:01:46 <mauke> you indented e too far
18:02:03 <lament> haha
18:02:04 <lament> true
18:02:26 <forkiliens> that means?
18:02:50 <mauke> ( and e must start in the same column
18:03:07 <forkiliens> aahhhh. ok!!! thanks. lol
18:03:28 <forkiliens> cool.
18:03:40 * SamB wonders why words in PDFs "wiggle" sometimes... i.e. the letters are sometimes staggered a (sub) pixel up or down from others...
18:08:19 <lispy> go blah
18:08:20 <lispy> er
18:17:57 <solrize> @seen cjb
18:17:57 <lambdabot> cjb is in #haskell. I last heard cjb speak 2h 27m 43s ago.
18:20:29 <forkiliens> how does one make sure, that a defined monad obeys the rules a monad should obey?
18:20:35 <dobblego> forkiliens, quickcheck
18:20:46 <forkiliens> quickcheck?
18:20:51 <forkiliens> what's that?
18:20:51 <dobblego> @where quickcheck
18:20:51 <lambdabot> http://www.cs.chalmers.se/~rjmh/QuickCheck/
18:20:58 <forkiliens> ok, thanks
18:21:40 <BMeph> I find that an unsatisfying answer. :|
18:21:44 <dobblego> @check \a f -> return a >>= f == f a
18:21:45 <lambdabot>      Occurs check: cannot construct the infinite type: a = a1 -> a     Probab...
18:22:06 <forkiliens> quote : "that the properties hold in a large number of randomly generated cases  "
18:22:13 <forkiliens> that's not, what i meant.
18:22:24 <dobblego> you want to prove it?
18:22:25 <forkiliens> i mean, sth. like proving
18:22:29 <forkiliens> yes
18:22:52 <SamB> you could look at a proof system...
18:22:53 <dobblego> http://sequence.complete.org/node/359
18:22:54 <lambdabot> Title: Coq and The Monad Laws: The First and Second | The Haskell Sequence
18:22:59 <SamB> yes, like that!
18:23:46 <Taggnostr> is there a "manual" with the function of lambdabot?
18:24:06 <dobblego> @commands
18:24:06 <lambdabot> Unknown command, try @list
18:24:06 <chessguy> forkiliens, personally, i'd just evaluate it myself, if the functions aren't too function
18:24:09 <dobblego> @list
18:24:09 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
18:24:20 <Taggnostr> thanks
18:25:09 <forkiliens> ok, i understand. so it could happen, that someone defines a "monad", that is not a monad
18:25:32 <forkiliens> haskell does not support anything to handle this, right?
18:25:44 <mauke> right
18:26:27 <BMeph> ...yet. ;)
18:26:30 <forkiliens> ok, thank you
18:26:47 <forkiliens> yeah, that would be cool. integrated proofs
18:27:03 <lispy> forkiliens: I think it would be undeciable to prove it progmatically
18:27:23 <forkiliens> right again...
18:27:29 <forkiliens> there are limits...
18:27:31 <forkiliens> :)
18:28:02 <heatsink> Something's been bothering me....
18:28:22 <heatsink> Aren't the "dependent types" in DML really just type-level lambdas?
18:28:40 <lispy> what is DML?
18:28:57 <heatsink> Dependent ML... um... http://www.cs.bu.edu/~hwxi/
18:28:59 <lambdabot> Title: Hongwei Xi
18:29:17 <heatsink> It's an extension to ML where types can be indexed by integers
18:29:54 <heatsink> So for example instead of type List you can have type List(n) of lists of length n for nonnegative integer n
18:30:17 <heatsink> The (++) function has type forall m n. List m -> List n -> List (m+n)
18:30:26 <heatsink> and so forth.
18:30:54 <lispy> heatsink: cool, I have heard of dependent types, but never knew what they were or what they did
18:31:05 <lispy> and type level integers would be nice
18:31:10 <lispy> as would type level sets
18:31:15 <heatsink> lispy: To my understanding, those aren't dependent types though.
18:31:29 <heatsink> even if they are cool.
18:31:46 <heatsink> A dependent type is supposed to be a type indexed by _values_
18:32:58 <heatsink> So if I had a function replicate : Int -> List(n), where n is the value that was passed as the first parameter, that would be a dependently typed function.
18:33:23 <heatsink> In dependent ML, you can create a function replicate : forall n. Int(n) -> List(n) but that's not the same thing.
18:33:34 <heatsink> You're probably wondering why I'm so worked up.  I don't know.
18:34:42 <lispy> hehe
18:34:50 <lispy> heatsink: cool, thanks for the explanation
18:35:28 <Japsu> @dice 1d100
18:35:28 <lambdabot> 1d100 => 14
18:37:34 <wkh> dice is a d&d style dice roller?
18:39:11 <Japsu> generic rpg dice roller, yes ;)
18:39:11 <EvilTerran> heatsink, that List(n) thing sounds similar to something oleg's done
18:39:14 <EvilTerran> ?help dice
18:39:14 <lambdabot> dice <expr>. Throw random dice. <expr> is of the form 3d6+2.
18:39:21 <heatsink> hmm?
18:39:24 <Japsu> @dice 1287d545871
18:39:24 <lambdabot> 1287d545871 => 353452482
18:39:40 <dons> ?users
18:39:40 <lambdabot> Maximum users seen in #haskell: 473, currently: 417 (88.2%), active: 16 (3.8%)
18:39:48 <EvilTerran> http://okmij.org/ftp/Haskell/types.html#polyvartype-fn
18:39:49 <lambdabot> Title: Haskell Programming: Types
18:39:56 <EvilTerran> heatsink, that --^
18:42:05 <jsedgwick> is there an alternative way to find the first thing which satisfies conditions besides "head [x|conds]"?
18:42:08 <byte-> hello
18:42:19 * BMeph needs to have a browser window devoted to Oleg pages
18:42:23 <byte-> can anyone tell me if there's a standard function to do this?
18:42:29 <oerjan> :t find
18:42:30 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
18:42:45 <byte-> I want something that will find the first Just value in a chaining fashion
18:43:04 <byte-> for example, Nothing ?> Just 10 ?> Nothing would return Just 10
18:43:11 <byte-> (returning just 10 is fine, too)
18:43:16 <oerjan> byte-: mplus
18:43:28 * BMeph agrees
18:43:37 <oerjan> or msum for a list
18:43:46 <byte-> what module is that in?
18:43:52 <byte-> I don't have the GHC docs handy
18:43:54 <oerjan> Control.Monad
18:43:57 <byte-> thanks
18:44:03 <oerjan> @src MonadPlus
18:44:03 <lambdabot> Source not found. I am sorry.
18:45:08 <mofmog> so xmonad is great and all, but it's ugly as sin
18:45:39 <byte-> cool
18:45:45 <byte-> ok, thanks guys
18:45:46 <byte-> see ya
18:45:46 <lispy> mofmog: maybe ask in #xmonad if they have skins?
18:46:01 <mofmog> right now i'm trying to get it to work inside of gnome
18:46:26 <lispy> you want the gnome desktop with xmonad as your window manager?
18:46:30 <Jaak> it's exactly as ugly as your windows are
18:46:48 <Jaak> because it's a freakin window manager, not a window decorator
18:46:57 <lispy> mofmog: a couple years ago when I wanted to use sawfish/sawmill as my WM in gnome it was not easy
18:47:15 <mofmog> i just opened up the tutorial on the xmonad site
18:47:40 <mofmog> anecdote: some guy posted, "Id hate to see a windowing manager in haskell!" on my school's cs newsgroup
18:47:56 <mofmog> and a ta responded with, "well... xmonad"
18:47:57 <Saizan> it's very easy to use xmonad with gnome
18:48:48 <chessguy> i thought xmonad wasn't a full windowing manager, but just one layer of a WM
18:48:56 <heatsink> EvilTerran: argh, rewrite rule systems are bad enough.  Rewrite rule systems written with fundeps make my head hurt.
18:49:26 <EvilTerran> great, innit? :D
18:49:32 <BMeph> byte-: If you really want to be uptown, you could use catMaybes, and strip off the Justs, as well as the Nothings. :)
18:50:15 <BMeph> (Sighs) Someday, I am gonna have to break down, and learn how to type. ;p
18:50:32 <oerjan> @quote oleg.*explode
18:50:32 <lambdabot> bos says: 00:24 < bos> it seems that quite often people will have a poke at oleg's code, their heads will explode, and they'll find some other way to do their thing.
18:51:00 <ddarius> heatsink: And what is the meaning of: forall n. Int(n) -> List(n)
18:52:33 <lispy> ddarius: I think the point is that the return type isn't polymorphic in n, the whole type is
18:54:38 <heatsink> ddarius: For any n, the function will take a value of type Int(n) and return a value of type List(n).  Each Int(n) is inhabited by one value: for example, Int(5) is inhabited by the value 5.  Each List(n) is inhabited by lists of length n.  (It should really have another type parameter, something like "List(n) Char".)
18:55:13 <ddarius> And how do you instantiate the n.
18:55:41 <heatsink> ddarius: It's a system F type variable.
18:56:10 <heatsink> So it has to be passed to the function separately.
18:58:13 <ddarius> And my question is, what is the syntax of the type application.
19:01:12 <heatsink> I just meant it to be ordinary type application.  I should have left out the parentheses.
19:02:33 <newsham> bmeph stillhere?
19:02:39 <mofmog> ok
19:02:44 <mofmog> xmonad works sort of with gnome
19:02:44 <mofmog> haha
19:02:46 <BMeph> Yes.
19:02:48 <mofmog> no panels however
19:02:58 <newsham> bmeph: can you receiv privmsg's?
19:03:16 <ddarius> heatsink: My question is how do you make the 'n' an actual number.
19:03:19 <BMeph> Yep. :)
19:04:26 <heatsink> ddarius: I don't understand what you mean by "an actual number".
19:05:50 <heatsink> If you have some type-level entities (..., -2, -1, 0, 1, 2, ...) and operators (+, -, ...) that act just like integers, that's good enough to model integers.
19:06:53 <solrize> is there a "ph.d. pill" that i can take to understand this stuff?
19:07:03 <heatsink> Granted, the type checker does have to be extended to understand integer arithmetic, to decide whether terms are equal.
19:07:12 <mofmog> oh god
19:07:16 <mofmog> where the heck is configure.hs
19:07:22 <heatsink> solrize: Learning haskell helps a lot.  That's how I got started. :)
19:07:50 <solrize> heatsink, haskell seems to just scratch the surface of this highbrow type theory.  i've been thinking of sending away for the coq book :)
19:08:56 <dobblego> solrize, Haskell sells itself as practical and turing complete
19:09:12 <solrize> i don't know if haskell's type system is turing complete
19:09:28 <dcoutts_> solrize: it's not
19:09:36 <dons> it is with extensions though :)
19:09:47 <dons> and which extensions are required is subject to debate
19:09:51 <dobblego> maybe I dreamt that bit then :)
19:09:54 <dons> i'm not sure what the minimal set of extensions are
19:09:57 <solrize> allow-undecidable-instances ?
19:10:10 <dons> FDs or ATs, I think are needed
19:10:13 <dons> and some others
19:10:18 <thoughtpolice> FDs are the main thing I think
19:10:21 <thoughtpolice> if you allow undecidable instances
19:10:25 <wkh> dons: what, if anything, can you tell us about getting paid to write haskell code at galois?
19:10:27 <thoughtpolice> the typechecker can grind away forever
19:10:45 <dons> wkh, well, I get paid to write haskell code :)
19:10:48 <dons> all day long :)
19:10:51 <dons> and some open source too, fwiw
19:11:01 <solrize> i mean if you can have f :: Int -> List n   then type inference is undecidable i think
19:11:12 <solrize> well i mean with arbitrary more types like that
19:11:29 <solrize> so there's a proof obligation for any type
19:11:43 <solrize> dons, also at night :)
19:12:02 <newsham> solrize: the coq book isnt light reading either.
19:12:32 <wkh> i met this girl once, she loved the coq.
19:12:39 <solrize> newsham yeah i'm not surprised.   wkh lol
19:12:40 <wkh> couldn't get enough coq. straight up coq fiend
19:12:45 <dobblego> c-oh-k
19:12:54 <solrize> coke fiend ?
19:13:05 <newsham> wkh: i bet she was dependantly typed
19:13:29 <solrize> man, i tried to date a java programmer once, but she treated me like an object.
19:13:41 <Philippa> wkh: yeah, I knew this gay guy who was scared of coq though. He'd done an advanced formal logic course and winced at the mere mention of the Curry-Howard Isomorphism...
19:13:54 <thoughtpolice> solrize: if you want dirt on types, pierce's books are absolutely great (types and programminy languages & advanced topics in types and programming languages.)
19:14:02 <solrize> tim curry = moe howard.  yeah that makes me shudder too
19:14:05 <solrize> i have TAPL
19:14:12 <solrize> but haven't gotten to read it much yet
19:14:20 <Philippa> make time, it's worth it
19:14:27 <solrize> i mean, i don't even understand haskell yet
19:14:30 <thoughtpolice> it's very good. ATTAPL has a lot of really crazy interesting stuff too
19:14:32 <BMeph> Phillipa: Did the guy have bad prison flashbacks? ;p
19:14:59 <thoughtpolice> solrize: the book is pretty approchable, it starts with the simple lambda calculus and gradually expands and adds extensions (you can read around the book fairly non-linearly for the most part I've found)
19:15:09 <solrize> thoughtpolice some parts of ATTAPL are online, i figure the idea is read TAPL first
19:15:21 <thoughtpolice> solrize: I have both, I just looked at ATTAPL's TOC
19:15:44 <solrize> i liked augustss's blog post from a few days ago
19:16:00 <thoughtpolice> solrize: to get through a lot of TAPL as far as I've read it, you may have to know a little set theory
19:16:00 <solrize> i didn't realize that the main application of dep. types would be metaprogramming but it makes perfect sense
19:16:04 <thoughtpolice> but not much beyond that
19:16:10 <solrize> i know some set theory and logic
19:16:11 <Philippa> BMeph: nope. And any further discussion belongs in -blah
19:16:19 <solrize> but not much
19:16:23 <thoughtpolice> and if you've never done proofs before, tapl is still great.
19:16:31 <thoughtpolice> there're exercises and proofs all over the place :)
19:16:31 <BMeph> Phillipa: True dat. ;)
19:16:59 <Philippa> thoughtpolice: you don't need too much set theory, especially if you don't feel the need to 'get' all the proofs
19:17:24 <thoughtpolice> Philippa: honestly I don't, in that respect. I feel if I tried I'd end up seeing the wood for the trees
19:17:28 <solrize> slight change of topic since you mentioned set theory: have you heard of something called Z notation?  it's used by ada weenies for formal specs.  but its name comes from ZF set theory, which just screams "bogus" to me (i.e. transfinite iteration of powerset...)
19:18:14 <thoughtpolice> Philippa: i'm just going over it lightly right now, but in the beginning chapters I've already picked up a lot of awesome info.
19:18:18 <Philippa> solrize: did half a course in it at uni
19:18:30 <solrize> philippa on Z notation?
19:18:38 <Philippa> on Z, yes
19:18:40 <thoughtpolice> doesn't XCB use Z notation to prove correctness or something?
19:18:44 <solrize> was it bogus?
19:19:07 <solrize> i'm not sure what XCB is, but spark/ada uses z, i believe
19:19:13 <Philippa> nope, reasonably sensible language. Much of it amounts to FP over a set theory, but hey
19:19:23 <solrize> to prove preconditions/postconditions on functions
19:19:35 <solrize> i mean subroutines, not like FP functions
19:19:48 <thoughtpolice> solrize: xcb is basically an xlib replacement
19:19:50 <Philippa> sure. Z provides the spec and you work from there
19:21:09 <solrize> hmm is it something you could just drop into an FP language compiler instead of bothering to write all that imperative ada code?
19:21:42 <Philippa> not for the purposes ada is used for
19:22:03 <Philippa> and sometimes not at all
19:22:15 <Philippa> (sometimes it really is just conditions)
19:24:05 <solrize> hmm.  i've seen some claims about spark/ada projects, they say they sit around for 2/3 of the project writing specs in Z, then another 1/6 coding in ada, then 1/6 testing, or something like that.  nothing about prototyping.  i just can't imagine what that kind of development would be like.
19:25:29 <solrize> dons if you're allowed to say, what kinds of applications do they do in haskell up there?  and are you working in oregon now?
19:25:47 <thoughtpolice> ada apparently has some nice features to make 'programming in the large' a lot easier, so maybe their specs are all they need? :)
19:26:16 <newsham> which languages make programming in the nude easier?
19:26:48 <Botje> @remember newsham which languages make programming in the nude easier?
19:26:48 <lambdabot> It is stored.
19:27:00 <Botje> made me smile :)
19:27:06 <QtPlatypus> ASM because your working against the bare metal.
19:27:07 <solrize> thoughtpolice i'm used to specs being incomplete and/or wrong and not having any clue about what the application really should do until after it's already written.  hence, bang out code as fast as possible, see that it sucks because of misconceptions in your original plan, revise plan, write more code, repeat.
19:27:20 <newsham> qt: i would think that would make it less comfortable
19:27:52 <newsham> having specs just means that some other programmer wrote the program before you in a less precise language
19:27:57 <SamB> QtPlatypus: I never liked having bare metal up against my skin
19:28:07 <thoughtpolice> newsham: a really sexy one
19:30:32 <monochrom> haskell allows me to work with the bare lambda calculus.
19:31:02 <solrize> it must be a gay language, it has lambdas everywhere
19:32:00 <monochrom> python, java, c, ...  they all cover it up with layers and layers of pretense such as "object", "mutable state", "runtime type"
19:32:44 <solrize> i've gotten really terrified of C
19:32:54 <solrize> and i've written a lot of it back in the day
19:33:05 <solrize> but now i think it should be banned :)
19:33:08 <wkh> how do you get anything done in C
19:33:15 <wkh> every little thing requires calls to malloc
19:33:18 <wkh> or some crap
19:33:32 <monochrom> By typing 200 wpm. :)
19:33:32 <TomMD> Not if you write it correctly.  Malloc is slow and generally avoided.
19:33:42 <solrize> nah, just use a static buffer and don't bother to check subscripts :)
19:33:49 <TomMD> * in inner loops atleast.
19:35:38 <solrize> or run a conservative garbage collector like gcj does, so you can write internet apps that run out of memory when some dweeb sends them data that looks like pointers :)
19:35:51 <heatsink> Someone did that?
19:35:57 <newsham> mono: your bare lambdas have types
19:35:59 <heatsink> That's an interesting attack.
19:36:15 <solrize> heatsink, you mean fooling a conservative gc?  that's a well known attack
19:36:19 <monochrom> Yeah, mine do.
19:36:30 <newsham> so they're not completely bare :)
19:36:31 <monochrom> I like types.
19:37:39 <heatsink> For me, the problem with writing C is that none of the other C programmers understand when I use system F and currying.
19:37:47 <monochrom> Types resolve paradoxes.  There are other resolutions, but types resolves paradoxes in the cleanest way.
19:37:58 <newsham> what's system F?
19:38:08 <TomMD> GHC core - almost.
19:38:20 <oerjan> @go system-f
19:38:21 <lambdabot> http://en.wikipedia.org/wiki/System_F
19:38:21 <lambdabot> Title: System F - Wikipedia, the free encyclopedia
19:38:48 <newsham> mono: sure, but there are some cool lambdas that dont work with types
19:39:31 <newsham> heatsink: what kinda stuff do you do with systemF in C?
19:40:26 <qwr> uh. formatTimeDiff is really logical...  'm' -> show2 (fromEnum month + 1)
19:40:35 <monochrom> I guess the Alligator game is more bare then. :)
19:40:36 <newsham> in |- Lambda alpha . lambda x^alpha . x      the superscript alpha means that x is restricted to that type?
19:40:56 * qwr wonders what good is using 1-based numbering on time _differences_
19:41:22 <solrize> what's the capital lambda ?
19:41:25 <heatsink> newsham: I'm exaggerating a little.  But I use type classes in C basically the way they work internally in GHC: a type class is a struct with some function pointers inside.
19:41:36 <newsham> qwr: the month numbers are usually represented as zero to eleven, but humans prefer 1 to 12.
19:42:06 <qwr> newsham: so you prefer 1 month ago as today?
19:42:12 <oerjan> solrize: lambda with type as argument
19:42:40 <newsham> oh you're saying they're printing a time diff and adding 1 to the month.
19:42:48 <qwr> newsham: yes.
19:43:02 <solrize> oerjan, hmm, i think i get it.  someone should update the article to explain that.
19:43:04 <qwr> newsham: http://www.haskell.org/ghc/docs/latest/html/libraries/old-time/src/System-Time.html#formatTimeDiff
19:43:05 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/2k58eu
19:43:06 <solrize> thanks
19:44:37 <newsham> heatsink: hmm.. most of the people I know who still program C are fairly decent at it and should understand doing polymorphism in C
19:44:47 <newsham> granted I know less and less of them
19:46:07 <jsedgwick> can anyone explain why this implementation of the sieve of eratosthenes is hanging? http://hpaste.org/6535
19:46:12 <monochrom> I still write shell scripts, and I understand doing polymorphism in shell scripts.  But this is thanks to MLs and Haskell, not thanks to shell scripts. :)
19:49:51 <EvilTerran> jsedgwick, because tail recursion
19:50:15 <jsedgwick> hrm?
19:50:29 <solrize> there was some crazy Oleg article where he did peano arithmetic in C++ templates so that dividing by zero caused a type error
19:50:36 <solrize> at compile time
19:50:55 <EvilTerran> jsedgwick, your definition of sieve can't even return a partial result until the inner recursive call returns a partial resul
19:51:02 <BMeph> jsedwick: That's a naive sieve, though, isn't it?
19:51:13 <monochrom> Please note that "crazy Oleg" is redundant.  Just "Oleg" will do. :)
19:51:33 <EvilTerran> BMeph, let's not distract from the code being broken by arguing about semantics :P
19:52:08 <EvilTerran> jsedgwick, in order for a function that recurses forever to return a partial result in finite time, it has to *not* be tail-recursive
19:52:14 * BMeph with an agreeable grin, agrees to stop channeling Mel O'Neill for the night.
19:52:27 <EvilTerran> in general, you don't want tail-recursion in a lazily evaluated setting
19:52:33 <monochrom> > let f x = f x ++ x in f "hello"
19:52:39 <lambdabot> Terminated
19:52:44 <monochrom> See, that kills lambdabot. :)
19:53:07 <EvilTerran> i'm giving necessary-but-insufficient conditions, here
19:53:08 <monochrom> > let g x = x ++ g x in g "hello"
19:53:08 <lambdabot>  "hellohellohellohellohellohellohellohellohellohellohellohellohellohellohello...
19:53:21 <monochrom> That is what you should aspire to.
19:53:34 <solrize> monochrom, well i don't see the article now but that's probably just as well ;)
19:53:40 <EvilTerran> i'm not going to get into the nitty-gritty of recursion and co-recursion at this hour ;)
19:53:57 <oerjan> jsedgwick: i think you have the parameters of `mod` switched
19:54:10 <monochrom> Neither am I, but I'm showing an idiom.
19:54:28 <oerjan> oh and it should be /= not ==
19:54:44 <newsham> at which hour are nitty gritty of recursion appropriate?
19:55:01 <jsedgwick> oerjan: god damn it i pasted that mod snipper from something else
19:55:13 <EvilTerran> to nitpick for just a moment, you can write "square" as (^2)
19:55:35 <EvilTerran> " ... = if (head numbers)^2 < max ...
19:55:46 <EvilTerran> ?src (^)
19:55:46 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
19:55:51 <EvilTerran> ?src Int (^)
19:55:52 <lambdabot> Source not found. Where did you learn to type?
19:55:53 <EvilTerran> bah
19:56:19 <oerjan> oh and then head newnumbers will be wrong
19:56:20 <dmwit> (^) is defined outside of a type-class.
19:56:37 <EvilTerran> dmwit, i thought so, but just ?src (^) didn't work, so i thought i might be mis-remembering
19:56:46 <dmwit> o
19:56:54 <EvilTerran> p?
19:58:25 <oerjan> er wait no i think i was wrong about that last one
19:59:37 <wli> (^) is yet another case of wanting Natural or otherwise unsigned integral types where only Int or Integer is available.
20:00:20 <solrize> Int is scary they should get rid of it or at least make it overflow checked
20:02:22 <newsham> rename it UnsafeIReallyWantInt
20:02:30 <newsham> that would minimize the scariness
20:02:40 <solrize> use Word32 if you want unsafe ints
20:02:50 <newsham> yah that works
20:03:10 <EvilTerran> but Word32 is unsigned
20:03:18 <wli> MachineInt
20:03:43 <BMeph> So, has anyone used pairs to implement lists, a la Lisp?
20:03:48 <EvilTerran> if you're that bothered, just use Integer. it's not that bad really.
20:04:01 <EvilTerran> BMeph, i think you need an ADT to do that
20:04:04 <solrize> i am shocked, shocked i say, to learn that a supposedly upstanding language like haskell has unchecked ints running rampant everywhere
20:04:10 <EvilTerran> or foolery with existentials
20:04:32 <wli> data List t = List (t, Maybe (List t)) might do.
20:04:34 <solrize> bmeph, regular haskell lists are pairs, i thought.  List a = Nil | Cons a (List a)
20:04:37 <Cale> EvilTerran: The problem with "just use Integer" is that many Prelude and list functions are monomorphic and use Int.
20:04:55 <EvilTerran> because otherwise lists of different lengths have different types
20:04:56 <newsham> "Factoid: C# exposes more than 10 integer-like data types, none of which are those defined by (Pythagoras, 500BC)"
20:05:03 <newsham> "In the future, can we get integers right?"
20:05:05 <solrize> newsham :)
20:05:12 <newsham> http://www.cs.princeton.edu/~dpw/popl/06/Tim-POPL.ppt
20:05:28 <EvilTerran> Cale, eh, true. take it up with the report guys.
20:05:29 <newsham> (slide #38)
20:06:04 <dcoutts_> EvilTerran, Cale: but don't most of those have genericFoo variants that return any Num/Integral type
20:06:14 <dcoutts_> @type genericLength
20:06:16 <lambdabot> forall b i. (Num i) => [b] -> i
20:06:30 <wli> What's more disturbing yet is the lack of a Natural type or related typeclass otherwise enforcing nonnegativity.
20:06:33 <dcoutts_> so you can have your lazy Nats etc
20:06:44 <EvilTerran> dcoutts_, yeah, but that's so darn *long*
20:06:47 <EvilTerran> :P
20:06:50 <dcoutts_> heh
20:06:57 <solrize> wli, yeah, unsigned integers
20:07:11 <wli> Unsigned Integers even. ;)
20:07:22 <jsedgwick> oerjan: changing the mod around fixed everything except now the prime sticks around in the numbers list so it gets counted twice upon returning
20:07:30 <newsham> wli: dont integers map really easily to naturals?  toNat x | x < 0 = 0  | otherwise = x ?
20:07:36 <wli> (i.e. "unsigned bignums")
20:07:40 <jsedgwick> oerjan: the last prime
20:08:01 <wli> newsham: No. Negative integers raise exceptions in numerous instances.
20:08:10 <wli> newsham: e.g. (^)
20:08:31 <wli> *** Exception: Prelude.^: negative exponent
20:08:40 <newsham> let (^) x y = (real^) (toNat x) (toNat y)    ;-)
20:08:49 <jsedgwick> oerjan: easy fix though, took me a sec to figure out why the fuck
20:09:01 <newsham> but i agree.. why we dont have naturals
20:09:13 <newsham> esp in a principled language like haskell
20:09:15 <oerjan> jsedgwick: you changed == to /= as i said in the next message?
20:09:46 <jsedgwick> yeah
20:10:10 <wli> newsham: The bigger and broader issue is that the goal of having functions be total and things like exceptions avoided to the maximum extent possible is not very broadly shared.
20:10:12 <newsham> this popl slide deck is super cool btw
20:10:24 <newsham> wli: *nod*
20:11:05 <newsham> i would love it if my compiler (or lint) would tell me all of the partial functions (head) I have linked into my program
20:11:13 <wli> Maybe it's too traditional to do head/tail etc. with exceptions vs. MonadPlus etc.
20:11:20 <newsham> and the path between my code and the use
20:11:47 <newsham> what's the vs?
20:11:59 <EvilTerran> ?where catch
20:11:59 <lambdabot> http://www.cs.york.ac.uk/~ndm/projects/catch.php
20:12:09 <EvilTerran> that might be relevant to your interests, newsham
20:12:09 <BMeph> wli: Then fromEnum's return type could be more useful, eh? ;)
20:12:19 <newsham> et: danke
20:12:34 <wli> fromEnum is a disaster. :(
20:12:54 <newsham> et: oh, hmm that only checks patterns.
20:13:14 <EvilTerran> it what
20:13:15 <Cale> dcoutts_: Yes, but of course they're less convenient to use.
20:13:33 <heatsink> Huh?  I thought fromEnum was total?
20:14:05 <newsham> > toEnum 65535 :: Char
20:14:06 <lambdabot>  '\65535'
20:14:15 <EvilTerran> newsham, it desugars everything to the point where the only potential errors are calls to "error"
20:14:17 <newsham> > toEnum 2465535 :: Char
20:14:17 <lambdabot>  Exception: Prelude.chr: bad argument
20:14:25 <jsedgwick> oerjan: fixed, final, working. (not totally optimized but okay) http://hpaste.org/6535#a1
20:14:38 <EvilTerran> and then sweeps through the code making sure none of those calls to error will ever be executed
20:14:53 <newsham> et: ahh, that wasnt clear from the abstract.
20:14:53 <EvilTerran> based on analysis of the pattern-matching, yes
20:14:56 <jsedgwick> gnight
20:15:08 <solrize> i've always liked that sweeney presentation and have never understood why the FP experts never react to it much
20:15:18 <newsham> and it will consider all calls to error?
20:15:22 <EvilTerran> i went to a seminar ndm did at the oxford comlab about it :)
20:15:29 <SamB> solrize: what did he say again?
20:15:38 <EvilTerran> newsham, indeed
20:15:50 <SamB> sweeney has obviously grown a lot since he made ZZT ;-)
20:15:54 <newsham> sounds excellent
20:16:06 <solrize> samb - http://www.cs.princeton.edu/~dpw/popl/06/Tim-POPL.ppt
20:16:11 <solrize> there is a pdf around somewhere too
20:16:34 <EvilTerran> it uses a lossy representation of, say, integers, to keep things decidable - so it occasionally comes up with false positives
20:16:36 <solrize> http://www.st.cs.uni-sb.de/edu/seminare/2005/advanced-fp/docs/sweeny.pdf
20:16:37 <newsham> http://www.st.cs.uni-sb.de/edu/seminare/2005/advanced-fp/docs/sweeny.pdf
20:16:40 <lambdabot> http://tinyurl.com/7cyhz
20:16:40 <lambdabot> http://tinyurl.com/7cyhz
20:16:41 <solrize> jinx
20:16:51 <SamB> @go tim sweeney presentation haskell
20:16:52 <lambdabot> http://www.st.cs.uni-sb.de/edu/seminare/2005/advanced-fp/docs/sweeny.pdf
20:16:55 <EvilTerran> but he's chosen his representation so as to work in the majority of cases
20:17:25 <solrize> i think pattern match failure is completely separate issue from undetected int wraparound
20:17:40 <EvilTerran> yes it is
20:17:48 <SamB> solrize: that doesn't mean it isn't economical to test both together
20:17:52 <solrize> i'm ok with expecting my ints to never overflow but i still want a runtime exception just in case
20:17:52 <SamB> one could cause the other!
20:18:02 <oerjan> @tell jsedgwick You still have a bug somewhere - sieve 30 contains 25
20:18:02 <lambdabot> Consider it noted.
20:18:03 <solrize> well it's extremely hard to prove impossibility of int overflow
20:18:10 <EvilTerran> this was in the context of detecting potential calls to (^) with a negative second parameter
20:18:18 <solrize> i.e. i want to count the bytes in a file, it might be reasonable to use an int, except now that we have terabyte hard drives...
20:18:18 <SamB> he sstoled SPJs crayon!
20:18:25 <solrize> evilterran oh ok
20:18:51 <SamB> why did sweeney steal SPJs magical crayon?
20:19:12 <solrize> hmm, i think he doesn't understand dependent types (slide 28-29)
20:19:13 <newsham> anyone have the sweeney popl paper pdf (not slide deck) ?
20:19:21 <solrize> not that i understand them
20:19:27 <solrize> newsham yes the url was just here
20:19:34 <solrize> http://www.st.cs.uni-sb.de/edu/seminare/2005/advanced-fp/docs/sweeny.pdf
20:19:35 <lambdabot> http://tinyurl.com/7cyhz
20:19:46 <newsham> solrize: isnt that the pdf of the slide deck?
20:19:54 <solrize> yes
20:19:59 <newsham> i want the paper
20:19:59 <solrize> was there a paper?
20:20:16 <solrize> i had the impression it was just a talk, no paper
20:20:20 <newsham> http://portal.acm.org/citation.cfm?id=1111320.1111061
20:20:23 <lambdabot> Title: The next mainstream programming language
20:20:31 <newsham> *shrug* I assumed it was a paper if it was at popl
20:20:35 <solrize> pages: 269-269,   22kb pdf
20:21:00 <newsham> hmm thats not a lot of pages :)
20:21:29 <solrize> prob an abstract of the talk
20:22:32 <dolio> solrize: What's wrong with his dependent types (aside from having somewhat confusing syntax)?
20:22:40 <newsham> ahh invited talk
20:22:42 <oerjan> @tell jsedgwick The tail is in the wrong place - put it on one of the lists in the else part instead
20:22:42 <lambdabot> Consider it noted.
20:22:50 <wagle_home> neato slide show..  i'm inspired..  8)
20:22:57 <bsod2> ls
20:23:01 <bsod2> sorry
20:23:10 <solrize> dolio i think he doesn't mean for those types to be checked at compile time
20:23:20 <solrize> which would require proofs
20:23:34 <solrize> hmm maybe.
20:24:08 <solrize> if they are all vectors, and his subscripts are all const*a+b then range checking is decidable...
20:25:10 <heatsink> solrize: Very often the subscript expressions people are interested in are presburger arithmetic formulae.
20:25:25 <dolio> His 'nat<n' type is, I think, Fin n.
20:25:35 <solrize> if you have a matrix a[i,j] with subscripts like that, is it still decidable?
20:25:40 <dolio> And Fin n is a natural match for indexing Vec a n.
20:26:06 <SamB> why do we think sweeney doesn't get dependant typing?
20:26:19 <solrize> samb maybe i misunderstood the slide i was complaining about
20:26:29 <dibblego> SamB, depend*e*nt
20:26:41 <heatsink> solrize: Bounds checking is decidable.  Check i and j separately, each is exactly like the 1D case.
20:26:44 <SamB> oh. whatever.
20:26:54 <solrize> heatsink yeah
20:26:58 <dibblego> you said that the last 20 times you mispelled that word :)
20:27:46 <SamB> dibblego: and you kept track
20:27:53 <SamB> which is worse?
20:27:55 <dolio> I don't think his matrix type has any bounds checking. He's more concerned about indexing into the array of vertices (if I'm looking at the right spot).
20:27:56 <dibblego> no
20:28:09 <dibblego> SamB, if I had kept track, then definitely the poor spelling is worse
20:28:11 <oerjan> dibblego: obviously he is resistent
20:28:13 <newsham> samb: worse is better
20:28:19 <dibblego> oerjan, RAR! :)
20:28:25 <solrize> i see two cases: 1) indexes for sequential loops, replace all those with maps, get rid of subscripts.  2) indexes that were computed some messy way, therefore needing complicated checking to assure they are <n
20:28:27 <heatsink> solrize: The syntax he uses looks a lot like DML syntax
20:28:43 <solrize> heatsink hmm
20:28:59 <solrize> DML is not really dep. types , from earlier ?
20:29:05 <newsham> so has anyone redeveloped unreal3 in haskell yet?
20:29:07 <newsham> :)
20:29:16 <solrize> someone did a shooter game in haskell
20:29:24 <newsham> yah, saw it on the weekee
20:29:28 <solrize> yeah
20:29:30 <heatsink> heh
20:29:31 <dolio> No, you need to write it in Agda.
20:29:45 <newsham> not epigram?
20:30:19 <Toxaris> that sweeny slides contain "use haskell" on every second page, but on the very end, "i'll not use haskell because of the scary syntax".
20:30:49 <newsham> toxaris: see his talk title
20:31:13 <Toxaris> newsham: ... mainstream ...?
20:31:32 <solrize> he talks about lenient evaluation with a reference to some obscure old language that i couldn't find info about
20:31:53 <newsham> toxaris: sorry i misremembered the title..  I was assuming he's tlaking about a future language he'd like to see
20:31:56 <newsham> which might be haskell like
20:31:57 <newsham> but is not haskell
20:32:40 <Toxaris> newsham: basically he does, but the reason for his future language /= haskell is: he believes lazy evaluation to be costly, he doesn't like the syntax, he thinks haskell doesn't support arrays.
20:33:07 <Toxaris> and one one page, he talks about virtual classes (in the OO sense)
20:33:17 <solrize> and he thinks type inference gives lousy error messages (last slide)
20:33:19 <newsham> isn't "hard to tune for performance" very close to "costly" ?
20:33:21 <dolio> I never got Epigram 1 running very well, and Epigram 2 still isn't out yet.
20:33:33 <newsham> yah but he uses c++ which has very lousy template error messages
20:33:39 <newsham> so I assume he can live with the latter :)
20:33:42 <dolio> Agda just got an FFI to Haskell, so you can write real programs in it now. :)
20:33:46 <solrize> i find myself wishing for python-like expandable arrays
20:33:58 <newsham> solrize: make one :)
20:34:19 <solrize> newsham with the ffi?
20:34:27 <solrize> how do they write stuff like that?
20:34:35 <newsham> cant you just make a new data type in haskell to do what you want?
20:34:58 <lament> just bridge to python :)
20:35:03 <solrize> newsham the interface could be like intmaps, but i want the compact vector representation that gets bigger as you add more items
20:35:19 <solrize> [1,2,3,4,5] as a list of five cons cells... ouch
20:35:40 <newsham> solrize: right, so you write a new data type that preallocates some sized data and reallocates more when needed :)
20:35:51 <solrize> newsham, yeah
20:35:52 <newsham> just like python does in C, but you can do directly in haskell
20:36:16 <newsham> also isnt that kind of like what bytestrings give you?
20:36:23 <mae> any way to modify a record besides explicit record syntax {}
20:36:25 <solrize> newsham, hmmm, bytestrings, interesting idea
20:36:37 <solrize> i want to munch on very large int vectors
20:36:42 <dolio> Those only hold bytes or 8-bit characters, though.
20:36:54 <solrize> well i could use 4 bytes per ...
20:36:58 <Toxaris> solrize: you may be able to use laziness for the "allocate more space" part
20:37:08 <newsham> right but isnt the bytestring lib written all inhaskell?
20:37:19 <dcoutts_> newsham: almost
20:37:23 <solrize> bytestring lib has a bunch of compiler rewrite hacks iirc
20:37:39 <dcoutts_> but that just rewrites Haskell to Haskell
20:37:47 <solrize> hmm
20:37:53 <newsham> solrize: right, but thats an orthogonal issue.
20:37:53 <dcoutts_> there are a few calls out to C functions, memcmp etc
20:38:21 <dolio> What's the problem with 'data PythonArray a = PA Int (Array Int a)', though.
20:38:25 <dolio> Performance?
20:38:50 <lament> PythonList :)
20:39:09 <dolio> There's also Data.Sequence, of course.
20:39:16 <newsham> lament: he's talking about python arrays not lists
20:39:33 <solrize> dolio, yeah, maybe the best interface would be something like intmap but with the idea that you normally 1) would never update a cell once it had been set; 2) would fill the slots sequentially
20:39:59 <lament> newsham: it certainly seems like he's talking about lists...
20:40:02 <solrize> and i guess it would be ok if it allocated fixed size starrays and went thru a few levels of indirection (tree structure) to get to the place you want
20:40:07 <Toxaris> solrize: consider an infinite lazy list of lazily created arrays filled with an initial value. every "chunk" of that list, as well as the spine of the list, is only created when first accessed. is that what you want?
20:40:10 * solrize looking up data.sequence
20:40:24 <newsham> lament: maybe you're right
20:40:25 <solrize> toxaris i want an actual array full of actual ints that come from external sources
20:41:12 <newsham> lament: arrays are extendable in python, though
20:41:25 <solrize> for some reason hugs docs always come up on top of google, ghc docs somewhere lower, for queries like "data.sequence"
20:41:27 <Toxaris> solrize: and that's not what Data.Array gives you?
20:41:42 <Toxaris> solrize: use hoogle for such queries.
20:41:47 <solrize> toxaris data.array doesn't do that automatic resizing but i could wrap around it i guess
20:41:50 <solrize> @hoogle data.sequence
20:41:50 <lambdabot> Did you mean: Data.sequence
20:41:50 <lambdabot> Prelude.undefined :: a
20:41:50 <lambdabot> Control.Monad.State.Class.get :: MonadState s m => m s
20:42:08 <Toxaris> @hoogle Sequence
20:42:08 <lambdabot> Data.Sequence :: module
20:42:08 <lambdabot> Prelude.sequence :: Monad m => [m a] -> m [a]
20:42:08 <lambdabot> Control.Monad.sequence :: Monad m => [m a] -> m [a]
20:42:36 <solrize> hugs impl => The implementation uses 2-3 finger trees annotated with sizes, as described in section 4.2 of
20:42:38 <Toxaris> solrize: be aware of the hoogle bug with hierarchical namespace module names :)
20:42:51 <solrize> well i'm trying to find the actual docs not just the type sig
20:43:11 <Toxaris> solrize: sure, use http://www.haskell.org/hoogle/
20:43:11 <lambdabot> Title: Hoogle
20:43:23 <solrize> the main thing is i have a 4gb machine and would like to have at least 0.7 billion 4-byte ints in these arrays
20:43:43 <solrize> i.e. i don't mind some overhead of tree structures of 1000-size arrays but one cons node per int is just too much
20:44:05 <Spark> sounds like you want a low level language
20:44:06 <dolio> One thing is, if you're ever going to write to an 'immutable' array, it's probably going to be expensive.
20:44:22 <dolio> Since you have to copy it (barring DiffArray).
20:44:39 <solrize> well the "immutable" array could be a pointer to an underlying mutable vector
20:45:02 <solrize> i.e. i'd only be adding elements to the end through most of the operations
20:45:07 <solrize> hmm eventually i'd want to sort in place
20:45:10 <solrize> so it would be a mutable array
20:45:51 <solrize> anyways it's just something that's straightforward and more or less trivial in python but not that well supported in haskell, maybe because haskell progs don't usually do stuff like that
20:48:02 <solrize> the wikipedia HM article seems to describe an exp.time inference algorithm...
20:48:15 <heatsink> solrize: Are you traversing the data in a few simple access patterns, like streaming through it from beginning to end and sorting?
20:48:22 <solrize> heatsink yes
20:48:46 * SamB tries to coax JHC into allowing (->) to be used as a type constructor...
20:49:58 <lament> "more or less trivial in python but not that well supported in haskell" - doesn't that describe most things? :)
20:50:47 <solrize> lament i'm at the point in learning haskell while coding python at my day job, that i say "f(*&#(* haskell!  this would be so easy in python!"  and "f(*&@(& python, this would be so easy in haskell!"  about equally often
20:50:53 <SamB> lament: only easy things
20:51:05 <heatsink> solrize: you may be able to divide your problem into a functional computation part and an imperative storage-management part.
20:51:11 <SamB> hard things are still hard, but maybe not quite so bad
20:51:18 <solrize> heatsink, yes, i'll have to think about it more
20:51:33 <solrize> for the first pass i'll probably just dump all the data to a disk file and run the unix sort program :)
20:52:23 <solrize> i think python's main advantages are in library functions and datatypes like this
20:52:29 <Toxaris> newtype STClusteredArray a = ClusteredArray (STArray Int (STUArray Int a))
20:52:30 <solrize> that could be added to haskell libraries
20:52:31 <thoughtpolice> not even; just write a script to pipe it.
20:52:33 <heatsink> that works.
20:53:18 <Toxaris> or maybe STRef (IntMap (STUArray Int a))
20:53:33 <solrize> eventually i'd like to crank up the performance.  i've been wondering whether i could run the haskell app in a process of 100mb or whatever, and allocate the rest of the ram to something accessed through the ffi
20:53:55 <solrize> toxaris yeah the problem is that stuarray is fixed size
20:54:04 <solrize> why was it that i wanted variable size?  hmm
20:54:14 <solrize> yeah i wanted to do radix sorting on input as it came in
20:54:40 <bos> you could use judy array bindings.
20:54:42 <SamB> oops... forgot the base case...
20:54:49 <solrize> bos yeah judy looks interesting
20:54:50 <Toxaris> so what about the IntMap of STUArray solution?
20:55:06 <wagle_home> hmm..  i now claim to have implemented a state monad in bash..  8-p
20:55:15 <solrize> toxaris oh cool, i didn't understand at first look, what you meant by intmap
20:55:19 <bos> the judy API is really weird and with horrible naming, though.
20:55:19 <solrize> yeah that's a good idea
20:55:26 <bos> so it's hard on the eyes.
20:55:31 <solrize> judy is scary, 10k lines of c code to implement a hash table ?
20:55:34 <Toxaris> or Data.Sequence or [] or whatever :)
20:55:38 <bos> 25k lines.
20:55:40 <solrize> heh
20:55:53 <solrize> i wonder how many buffer overflows it has
20:56:04 <wkh> i've never used judy. what's the big deal about it
20:56:10 <wkh> it better make me ice cream sandwiches and stuff
20:56:19 <Toxaris> solrize: but since you have an upper limit on sensible array size (4G with todays machines), you could use an array of arrays
20:56:22 <wkh> is it like the be all hash table to rule them all or something
20:56:26 <wkh> becuse if not why should i care
20:57:18 <solrize> wkh, 1) it's very fast, uses horrendously complex code to put data on cache lines etc;  2) high density (uses memory efficiently), almost all the memory is usable for data
20:57:50 <wkh> i saw benchmarks to the contrary at some point
20:57:59 <solrize> wkh hmm
20:58:08 <solrize> i'm going by the brochure claims :)
20:58:15 <wkh> lies, damned lies, statistics, and benchmarks
20:58:22 <solrize> i only heard of it the other day when jmeacham was saying something about it
20:58:23 <newsham> "In a concurrent world, imperative is the wrong default!"
20:58:28 <solrize> i think i care mostly about the storage density
20:58:30 <newsham> mmm quotey goodness
20:58:42 <wkh> solrize: that's kind of interesting
20:58:50 <wagle_home> doesnt work for some architectures, or pathological cases on its preferred architecture?
20:58:58 <solrize> it has a bitmap type, that i guess can hold a 30 billion element set in 4gb
20:59:47 <solrize> anyway i'm probably prematurely optimizing :)
21:00:31 <solrize> brb
21:01:27 <ac> goalieca: Ingram?
21:01:50 <goalieca> ingram?
21:01:51 <goalieca> no
21:02:03 <ac> goalieca: ah, looking for another Ryan
21:02:56 <wagle_home> http://www.nothings.org/computer/judy/  (from http://en.wikipedia.org/wiki/Judy_array )
21:02:57 <lambdabot> Title: A performance comparison of Judy to hash tables
21:04:05 <solrize> oh yeah i saw that paper
21:04:10 <wkh> solrize: i wonder if you could use that for something like... a fast chess engine
21:04:16 <solrize> 25k lines to get 25% better performance than a simple hash table
21:04:27 <solrize> wkh, judy for a chess engine?  hmm interesting
21:04:29 <wkh> where you want to hold motherfucktons of positions in memory using bitboards
21:04:35 <solrize> for transposition table
21:04:42 <solrize> and endgame tablebase
21:05:11 <solrize> in that paper it says the biggest structure he tested was 128mb
21:06:11 <solrize> anyway i'm not terribly starved for cpu cycles, i'm just going "well haskell is maybe 2x slower than C, that's not a problem considering how much better a language it is, but if it's using 10x as much memory for data intensive apps..."
21:06:55 <wkh> yeah, modern languages are generally ram mchoggersons
21:07:25 <jaj> Hi! Does anybody know where I could find an example on how to use HStringTemplate?
21:07:34 <solrize> @go hstringtemplate
21:07:35 <lambdabot> http://fmapfixreturn.wordpress.com/2008/01/15/more-simple-hstringtemplate-examples/
21:07:35 <lambdabot> Title: More Simple HStringTemplate Examples  fmap fix return
21:08:01 <jaj> thank solrize :)
21:08:05 <solrize> jaj :)
21:08:12 <jaj> +s
21:09:28 <solrize> wkh yeah i think the intmap stuarray idea will probably take care of this
21:09:32 <ddarius> There you go ac
21:09:39 <wkh> http://nothings.org/computer/judy/
21:09:41 <lambdabot> Title: A performance comparison of Judy to hash tables
21:09:45 <wkh> here were there benchmarks i was referring to
21:09:50 <ac> ddarius: ?
21:10:00 <ddarius> [23:08] * ryani (n=ringram@ppp-71-139-8-149.dsl.snfc21.pacbell.net) has joined #haskell
21:10:02 <solrize> wkh yes i'm looking at that now
21:10:18 <ac> ddarius: ah yeah, I have join/parts ignored
21:10:21 <ac> thanks
21:11:02 <solrize> wow, judy is takint around 1 msec per access once there are 1e7 items?  that's terrible
21:11:24 <solrize> no wait that's wrong
21:11:30 <solrize> 1 microsecond
21:11:35 <solrize> i guess that's ok
21:11:39 <solrize> cas latency yada yada
21:17:50 <SamB> what is the fixity of ->?
21:18:13 <oerjan> hm
21:18:25 * SamB is too goofy to figure it out at the moment
21:18:35 <oerjan> needs a ghc extension to make sense
21:18:45 <oerjan> since otherwise there are no other infix ones
21:18:51 <SamB> see, I made this happen:
21:18:58 <SamB> Prelude Representation> tArrow
21:18:58 <SamB> TCon {typeCon = Tycon {tyconName = Jhc.Basics.->, tyconKind = (?? -> ?) -> *}}
21:19:26 <SamB> I guess it's infixr?
21:19:31 <oerjan> it's right associative at least
21:19:33 <oerjan> yeah
21:20:08 <oerjan> "Function arrow is infixr with fixity 0. (This might change; I'm not sure what it should be.)"
21:20:22 <oerjan> http://haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#infix-tycons
21:20:24 <lambdabot> Title: 8.4. Extensions to data types and type synonyms, http://tinyurl.com/3czedj
21:21:56 * SamB makes Kfun infixr, too, so he can just write this:
21:22:03 <SamB> tArrow = TCon (Tycon tc_Arrow (kindArg `Kfun` kindFunRet `Kfun` kindStar))
21:30:24 <wagle_home> http://scienceblogs.com/pharyngula/2008/03/expelled.php
21:30:25 <lambdabot> Title: Pharyngula: EXPELLED!
21:35:55 <newsham> why dont ocaml/f#/etc adopt haskell style function decls?
21:36:57 <dmwit> ?where monadlaws
21:36:57 <lambdabot> I know nothing about monadlaws.
21:37:13 <wagle_home> @ Monad Laws
21:37:17 <wagle_home> @go Monad Laws
21:37:18 <lambdabot> http://www.haskell.org/haskellwiki/Monad_Laws
21:37:18 <lambdabot> Title: Monad laws - HaskellWiki
21:37:38 <wagle_home> newsham, whats haskell?
21:37:44 <dmwit> Here is what I would like to prove:
21:37:59 <dmwit> m :: M () -- for some specific monad M
21:38:05 <dmwit> m >> return () === m
21:38:21 <dmwit> oh
21:38:30 <dmwit> m >>= return = m -- done
21:38:41 <ryani> that's not exactly true, is it?
21:38:54 <ryani> consider: return undefined >>= \_ -> return ()
21:38:56 <solrize> is there something like "lines" and "unlines" for bytestrings ?
21:39:08 <dmwit> ryani: That's certainly undefined.
21:39:18 <dmwit> oh
21:39:27 <dmwit> quite
21:39:51 <dmwit> Well, that's nasty, isn't it?
21:39:54 <wagle_home> @src lines
21:39:55 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
21:40:17 <solrize> hmm, B.split '\n'    gives a type complaint, ghc thinks '\n' is a Char
21:40:23 <solrize> and B.split wants a word8
21:40:55 <newsham> '\n' is a Char :)
21:41:06 <oerjan> solrize: you want to use ByteString.Char if you are going to mix it with Chars
21:41:13 <solrize> but the bytestring doc says '\n' should work
21:41:15 <wagle_home> > (toEnum 'a') :: Word8
21:41:17 <lambdabot>  Couldn't match expected type `Int' against inferred type `Char'
21:41:31 <dmwit> > toEnum . fromEnum $ 'a'
21:41:32 <newsham> > (toEnum.fromEnum 'a') :: Word8
21:41:32 <lambdabot>  Couldn't match expected type `f Int' against inferred type `Int'
21:41:33 <lambdabot>  Exception: Prelude.Enum.().toEnum: bad argument
21:41:42 <dmwit> > (toEnum . fromEnum $ 'a') :: Word8
21:41:42 <lambdabot>  97
21:41:50 <solrize> heh
21:42:32 <oerjan> solrize: documentation error i guess
21:42:48 <solrize> bleh i wonder what the right way is
21:43:02 <wagle_home> umm.. ok
21:43:06 <solrize> :t Data.ByteString.split
21:43:07 <lambdabot> Word8 -> BSC.ByteString -> [BSC.ByteString]
21:43:30 <oerjan> :t Data.ByteString.Char.split
21:43:31 <lambdabot> Couldn't find qualified module.
21:43:42 <oerjan> :t Data.ByteString.Char8.split
21:43:43 <lambdabot> Char -> BSC.ByteString -> [BSC.ByteString]
21:45:23 <solrize> http://groups.google.com/group/comp.lang.haskell/browse_thread/thread/4e8ebd45da251181/ef43781185dfaee3
21:45:25 <lambdabot> Title: Line sorting problem from other NG - comp.lang.haskell | Google Groups, http://tinyurl.com/36qjru
21:45:33 <solrize> i'm trying to do that example with bytestrings
21:46:01 <ryani> > return undefined >>= \_ -> return ()
21:46:01 <lambdabot>   add an instance declaration for (Show (m ()))
21:46:13 <ryani> > return undefined >>= \_ -> return () :: [()]
21:46:14 <lambdabot>  [()]
21:46:17 <oerjan> solrize: DBC8 has lines and words too
21:46:35 <solrize> dbc8?
21:46:42 <oerjan> ^^
21:47:17 * oerjan refuses to explain the obvious
21:47:45 <solrize> oh i see
21:47:45 <solrize> tx
21:50:10 <solrize> :t BSC.sort
21:50:11 <lambdabot> BSC.ByteString -> BSC.ByteString
21:50:19 <solrize> hmm string to string, rather than list to list???
21:50:49 <oerjan> that is weird
21:51:18 <newsham> why weird if it is replacing [Char] ?
21:51:50 <oerjan> hm
21:52:36 <solrize> ok it compiles under ghci but gets a ton of linker errors under ghc
21:52:37 <oerjan> well i didn't know sorting a [Char] was a frequent operation :D
21:52:55 <oerjan> solrize: did you remember --make ?
21:53:12 <solrize> no i didn't know about that, thanks
21:53:58 <solrize> went from 3 sec to 0.37 sec, but is still 10x slower than unix sort :(
21:56:47 <solrize> but supposedly data.list.sort isn't so good
22:01:12 <dons> you're sorting different structures :)
22:01:49 <solrize> yeah i used data.list.sort and it's 0.7 sec for that file, vs. 0.04 sec for unix sort
22:02:27 <dons> [Char] /= byte arrays
22:04:06 <solrize> right
22:04:25 <solrize> bsc.sort just counts how many of each char are in the string, cute
22:05:36 <SamB> solrize: what exactly were you expecting?
22:05:45 <SamB> besides which... that is the definition of "radix sort"
22:06:20 <solrize> samb yeah (actually "counting sort" but close enough)
22:06:54 <solrize> i commented out the data.list.sort and now it's 0.08 seconds
22:07:15 <solrize> though if it's a lazy list coming from lines... hmm
22:09:31 <solrize> well dbc8 is still a huge improvement over regular chars
22:10:30 <solrize> python is 7x faster than haskell :(
22:11:04 <Cale> What if you apply (unix) head to the output?
22:11:14 <solrize> cale ?
22:11:44 <Cale> like  mySort < bigfile | head -n 10
22:11:46 <solrize> oh you mean to force the lazy stream ?
22:11:58 <solrize> i instead printed out the length of the list
22:12:10 <Cale> To not force all the output.
22:13:19 <solrize> oh.  well it's already forced by printing the line count and by sorting
22:13:19 <bparkis> http://www.bparkis.com/node/12
22:13:21 <lambdabot> Title: Revision-controlled lists | www.bparkis.com
22:13:55 <bparkis> this is what I was talking about a few hours ago to dmwit
22:13:58 <Cale> solrize: The point is *not* to force it. I'm interested in the performance of using the sorting programs to just get the top 10 elements.
22:14:39 <solrize> err unless they're using particular algorithms (i.e. selection sort) that shouldn't make any difference, but i'll try
22:14:50 <solrize> i'll try   take 10 $ sort ....    how's that?
22:15:13 <Cale> Sure, or just use the unix program 'head' to take the first few lines.
22:15:37 <Cale> (Or are you on a windows machine?)
22:15:40 <dmwit> bparkis: reading
22:15:59 <solrize> i'm on a linux machine, "take 10" went a lot faster, maybe because it avoided writing the output
22:16:40 <solrize> i'm writing out with B.writefile   what do i use to write to stdout/
22:17:21 <solrize> http://hpaste.org/6537  here's the code   (hmm, no hpaste announce)
22:17:33 <solrize> with the take removed
22:17:45 <Cale> :t Data.ByteString.Lazy.putStrLn
22:17:48 <lambdabot> BSLC.ByteString -> IO ()
22:17:54 <Cale> :t Data.ByteString.Lazy.Char8.putStrLn
22:17:55 <lambdabot> BSLC.ByteString -> IO ()
22:18:30 <solrize> ok
22:18:30 <solrize>          mapM_ B.putstrLn $ sort m
22:18:39 <Cale> yeah, something like that :)
22:19:23 <Cale> Some lazy sorting algorithms have the nice property that if you only demand the first k elements, it does no more work than necessary to compute those.
22:19:58 <solrize> it went much faster thru head -10  but again i suspect that was partly due to i/o
22:20:25 <solrize> no it really was sort
22:20:29 <Cale> Maybe compare it with the other sorting programs through head
22:20:56 <solrize> unix sort runs at same speed as whole output, just crazy fast
22:21:40 <dmwit> The Gnu utils have been optimized in ridiculous ways.
22:22:01 <solrize> hmm
22:22:34 <Cale> Yeah, I don't think you can expect to beat unix sort very easily.
22:22:39 <dmwit> http://ridiculousfish.com/blog/archives/2006/05/30/old-age-and-treachery/
22:22:40 <lambdabot> Title: ridiculous_fish  Blog Archive  The Treacherous Optimization, http://tinyurl.com/n2n9t
22:23:53 <solrize> gnu grep uses a really cute combination of boyer moore and deterministic regexps as i remember
22:23:56 <solrize> i know the guy who wrote it
22:25:20 <bparkis> well dmwit but i'm dealing in an asymptotic optimization
22:25:43 <dmwit> bparkis: None of what I said was aimed at you.
22:25:49 <solrize> bah ken thompson has both of those things beat, he wrote the original regexp lib on some old ibm mainframe and actually compiled the regexp to machine code
22:26:30 <bparkis> ok
22:30:41 <dmwit> bparkis: That's a neat idea!
22:30:56 <dmwit> I'm not sure I really understand the details (yet), but the overview is very pretty. =)
22:31:42 <solrize> zipper ? :)
22:31:54 <dmwit> Similar, yes.
22:32:49 <bparkis> I basically summarize it at the end
22:33:51 <bparkis> it's assigning version control numbers to references that change over time, so that you can find any given version of the reference in time proportional to the length of time you're tracking over
22:34:01 <bparkis> er, time proportional to the log of the time period
22:38:45 <bparkis> I should have a picture
23:13:22 <bparkis> http://www.bparkis.com/node/12
23:13:23 <lambdabot> Title: Revision-controlled lists | www.bparkis.com
23:13:36 <bparkis> I updated it with a diagram that makes the first part a lot clearer
23:21:20 <bos> @seen dons
23:21:20 <lambdabot> dons is in #haskell, #xmonad and #haskell-soc. I last heard dons speak 1h 18m 53s ago.
23:21:31 <gimpyj> where the free shit at?
23:21:50 <gimpyj> @seen bos
23:21:51 <lambdabot> bos is in #haskell and #ghc. I last heard bos speak 30s ago.
23:24:10 <solrize> lol
23:32:32 <glguy> How do I make this: sum [1..999999]
23:32:35 <glguy> not blow the stack
23:32:37 <glguy> in ghci?
23:32:54 <mrd> > foldl' (+) 0 [1..999999]
23:32:55 <lambdabot>  499999500000
23:33:14 <bd_> > sum [1..999999]
23:33:15 <lambdabot>  499999500000
23:33:27 <bd_> > sum ([1..999999] :: [Integer])
23:33:28 <lambdabot>  499999500000
23:33:39 <glguy> same that I have to rewrite all of the Data.List functions to be strict to use them without optimizations on
23:33:42 <glguy> shame rather
23:33:45 <wkh> > 999999*(999999+1)/2
23:33:46 <lambdabot>  4.999995e11
23:33:56 <wkh> > 999999*(999999+1)/2 :: Integer
23:33:57 <lambdabot>   add an instance declaration for (Fractional Integer)
23:33:57 <lambdabot>     In the expression:...
23:34:01 <scook0> the other option being to give GHCi a really big stack
23:34:14 <scook0> though that might not work in all cases
23:34:15 <wkh> whatever, 1 + ... + n = n(n+1)/2 :P
23:34:15 <dmwit> glguy: Yeah, I feel the same way.
23:34:32 <dmwit> > 999999*(999999+1) `div` 2
23:34:33 <lambdabot>  499999500000
23:35:22 <glguy> that was a reduced example
23:35:33 <glguy> I'm not interested in sums in particular
23:36:43 <dmwit> of course
23:40:58 <wli> wkh: Bernoulli polynomials?
23:42:51 <wkh> wli: huh?
23:43:23 <wli> wkh: I like the binomial basis better C(n+k,k) or some such.
23:45:03 <wli> wkh: The indefinite sum of C(n+k, k) with respect to n is ((k+1)/(n+1))*C(n+k+1,k+1)
23:45:45 <wli> wkh: Or maybe it's with respect to k.
23:47:28 <wkh> dunno anything about that, 1+...+n is just the textbook example used to introduce proof by induction
23:48:02 <wli> wkh: Basically Newton series expansions.
23:52:01 <wkh> so you're one of those people who know assloads of pure math stuff but can also go on all day about memory hierarchies and other hardware stuff
23:53:55 <mofmog> so xmonad is pretty nifty and damn complete for 500 lines of code
