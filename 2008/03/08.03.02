00:00:14 <oerjan> (++) used to be mplus too, iirc
00:00:48 <oerjan> @quote 1\.4
00:00:48 <lambdabot> No quotes match. You type like i drive.
00:00:54 <oerjan> @quote 1.4
00:00:54 <lambdabot> lambdabot says: <chessguy> sorry, this is the bird book: http://www.amazon.com/Introduction-Functional-Programming-2nd-Bird/dp/0134843460/sr=8-6/qid=1159309594/ref=pd_bbs_6/104-1423720-3100708?ie=
00:00:54 <lambdabot> UTF8&s=books  <lambdabot> http://tinyurl.com/root7
00:00:57 <siti> I can certainly see why they done it, but it is a bit ugly too :(
00:01:45 <yondalf> http://tuukka.iki.fi/tmp/haskell-2007-08-13.html -- where the quote comes from
00:01:46 <lambdabot> Title: haskell-2007-08-13
00:01:58 <yondalf> yeah, it's a pity (++) got un-overloaded too
00:02:39 <cinimod> And here is the obscure type problem:
00:03:00 <cinimod> *Data.Binary.Strict.BitGet> :t getLeftByteString :: Int -> BitGet AB.ByteString
00:03:01 <cinimod> getLeftByteString :: Int -> BitGet AB.ByteString :: Int -> BitGet BI.ByteString
00:03:21 <cinimod> That's got me scratching my head
00:04:20 <cinimod> It wasn't the cpp macro after all
00:05:18 <oerjan> well with 4 different ByteString modules, and is it 2 or 4 different types named ByteString?
00:05:48 <oerjan> Strict vs. Lazy, and Byte vs. Char8
00:06:07 <cinimod> Shouldn't importing qualified sort this?
00:07:09 <oerjan> what are AB and BI?
00:08:32 <oerjan> are you sure they actually conflict?  maybe AB (whatever it is) imports its ByteString from BI = .ByteString.Internal
00:08:32 <ddarius> 2
00:08:46 <cinimod> Just labels to disambiguate Data.ByteString and Data.ByteString.Internal
00:08:50 <oerjan> ah.
00:09:07 <oerjan> i think AB.ByteString and BI.ByteString should be identical, then.
00:09:21 <cinimod> But I think AB does import BI but it shouldn't export it
00:09:22 <oerjan> it's just BI probably contains the actual definition
00:10:00 <oerjan> :t pack
00:10:07 <lambdabot> Not in scope: `pack'
00:10:10 <cinimod> The functions in AB won't work on BI.ByteString - I get a type error
00:10:13 <oerjan> :t Data.ByteString.pack
00:10:14 <lambdabot> [Word8] -> BSC.ByteString
00:10:19 <oerjan> heh
00:10:23 <cinimod> :t Data.ByteString.pack
00:10:24 <lambdabot> [Word8] -> BSC.ByteString
00:10:39 <oerjan> hm obscure module abbreviation there too
00:11:21 <oerjan> cinimod: you're sure AB is not Data.ByteString.Lazy?
00:12:04 <cinimod> I don't think so - import qualified Data.ByteString as AB
00:12:21 <cinimod> How would that become Data.ByteString.Lazy
00:12:54 <oerjan> it shouldn't.  that's weird.
00:14:04 <oerjan> do you get an error message if you do :t (undefined :: AB.ByteString) :: BI.ByteString
00:15:24 <cinimod> nope
00:15:30 <oerjan> perhaps that's not where the conflict is anyhow
00:15:46 <oerjan> what is the actual error you are getting?
00:16:21 <oerjan> (and how)
00:17:16 <cinimod> Hang on - I'll have to recreate it
00:21:16 <OceanSpray> I got an IO [()] action in main as the last expression.
00:21:56 <OceanSpray> it seems that only the first item in the list is being performed.
00:22:10 <cinimod> oerjan: I think it's something to do with Data.ByteString.Lazy - I'll paste something
00:22:53 <oerjan> OceanSpray: er, code?
00:23:37 <OceanSpray> hold on, lemme try something first.
00:23:45 <cinimod> Hmm hpaste is not talking to me
00:23:50 <OceanSpray> how do you annotate something as strict again?
00:24:07 <oerjan> as for changing IO [()] to IO (), you probably need to add a _ to mapM or sequence somewhere
00:24:10 <Mr_Awesome> you can use bang notation
00:24:15 <Mr_Awesome> i learned that today :)
00:24:21 <OceanSpray> I'm using mapM
00:24:26 <OceanSpray> add a _ ?
00:24:29 <OceanSpray> what's that mean?
00:24:32 <oerjan> cinimod: is fine here
00:24:55 <oerjan> OceanSpray: mapM_ and sequence_ throw away the final results, mapM and sequence collect them
00:25:01 <OceanSpray> oh
00:25:59 <hpaste>  cinimod pasted "ByteString Confusion" at http://hpaste.org/6051
00:26:07 <OceanSpray> nope, still ain't workin'
00:26:20 <OceanSpray> maybe it's because one of the actions is an infinite loop.
00:26:47 <cinimod> If I do :t do {x <- gnn 3; return (fnn 3 x)}
00:26:55 <oerjan> cinimod: note the annotate button for keeping pastes together
00:27:15 <cinimod> I get the error:
00:27:16 <cinimod>    Couldn't match expected type `B.ByteString'
00:27:16 <cinimod>            against inferred type `Data.ByteString.Internal.ByteString'
00:27:16 <cinimod>     In the second argument of `fnn', namely `x'
00:27:16 <cinimod>     In the first argument of `return', namely `(fnn 3 x)'
00:27:16 <cinimod>     In the expression: return (fnn 3 x)
00:27:31 <oerjan> ah yes B is .Lazy
00:27:36 <cinimod> But I'm importing Lazy
00:27:55 <cinimod> If I import Data.ByteString (no Lazy) then I get other errors
00:28:14 <oerjan> cinimod: gnn = BG.getLeftByteString
00:28:20 <oerjan> it uses Strict
00:28:42 <cinimod> integer.hs:42:0:
00:28:42 <cinimod>     Couldn't match expected type `Int64' against inferred type `Int'
00:28:42 <cinimod>       Expected type: (B.ByteString, Int64)
00:28:42 <cinimod>       Inferred type: (B.ByteString, Int)
00:28:42 <cinimod>     When using functional dependencies to combine
00:28:43 <cinimod>       MonadState (B.ByteString, Int) m,
00:28:45 <cinimod>         arising from a use of `get' at integer.hs:43:16-18
00:28:47 <cinimod>       MonadState (B.ByteString, Int64) m,
00:28:51 <cinimod>         arising from the type signature for `mmGetBit'
00:28:53 <cinimod>                      at integer.hs:(42,0)-(46,13)
00:28:55 <cinimod>     When generalising the type(s) for `mmGetBit'
00:29:23 <tibbe> how do I get cabal-install to look for libraries in /opt/local/lib?
00:29:39 <oerjan> cinimod: BG = Data.Binary.Strict.BitGet probably uses strict bytestrings
00:29:52 <cinimod> It looks like Lazy and not Lazy use Int64 and Int :-(
00:30:47 <cinimod> oerjan: you are right - then I'm not sure how to solve matching Int64 and Int
00:31:39 <oerjan> cinimod: is integer.hs the last file you pasted?
00:31:46 <cinimod> oerjan: maybe I don't need to - anyhow I have to go and cook breakfast
00:32:21 <cinimod> oerjan: yes - let me go and have breakfast and think about the problem a bit more and then I may have to ask more questions
00:32:51 <cinimod> oerjan: thanks for your help - it's made things a lot clearer to me - I though Lazy was a straight drop in for not Lazy
00:32:53 <oerjan> cinimod: you have an explicit Int64 in the type declaration for mmGetBit
00:33:15 <oerjan> cinimod: it mostly is, but you need to be consistent
00:34:05 <cinimod> oerjan: perhaps a (Num a) => rather than Int64 or maybe (Integral a) => ? - I'll experiment later
00:34:52 <oerjan> cinimod: oh i think i found it
00:35:11 <oerjan> mGetBit used .drop, forcing its argument to be Int
00:36:17 <oerjan> and that argument comes from the get of the monad
00:36:22 <oerjan> (indirectly)
00:36:55 <oerjan> just stick a fromIntegral in there
00:39:33 <OceanSpray> so, yeah
00:39:48 <oerjan> hm wait a moment.  .ByteString.Lazy.drop _does_ use Int64
00:39:49 <OceanSpray> it's definitely the infinite loop.
00:40:29 <oerjan> and .ByteString.drop uses Int
00:49:19 <OceanSpray> @index forkIO
00:49:19 <lambdabot> Control.Concurrent
01:06:14 <cinimod> oerjan: are you still suggesting using fromIntegral?
01:07:32 <cinimod> :t mod
01:07:40 <lambdabot> forall a. (Integral a) => a -> a -> a
01:09:35 <wy> hey, anybody remember how to set the shell so that the same command won't be recorded twice in the history file?
01:10:44 <Riastradh> rm ~/.bash_history
01:14:13 <dabblego> man nub :)
01:15:27 <cinimod> @seen oerjan
01:15:27 <lambdabot> oerjan is in #haskell. I last heard oerjan speak 34m 58s ago.
01:15:35 <cinimod> @seen dons
01:15:35 <lambdabot> dons is in #xmonad, #haskell-soc and #haskell. I don't know when dons last spoke.
01:16:58 <oerjan> ahem
01:17:53 <wy> got it... shell is really something ugly. I always forget how to set the options
01:18:10 <oerjan> changing Int64 to Int should also work.
01:18:40 <oerjan> there isn't a lazy GetBit?
01:19:54 <oerjan> :t (undefined :: Int) :: Int32
01:19:58 <lambdabot>     Couldn't match expected type `Int32' against inferred type `Int'
01:20:04 <oerjan> :t (undefined :: Int) :: Int64
01:20:05 <lambdabot>     Couldn't match expected type `Int64' against inferred type `Int'
01:20:12 <oerjan> good
01:22:08 <cinimod> oerjan: I've got a work around. Wait two ticks and I'll hpoaste.
01:22:35 <gio123> does somebody know how can i refresh winedit ? i added lncs package and now need to refresh
01:24:12 <hpaste>  cinimod annotated "ByteString Confusion" with "ByteString Confusion" at http://hpaste.org/6051#a1
01:25:18 <cinimod> And now I can do what I want to do:
01:25:20 <cinimod> *Main> :t do {x <- gnn 3; return (fnn 3 x)}
01:25:20 <cinimod> do {x <- gnn 3; return (fnn 3 x)} :: forall a. (Num a) => BG.BitGet a
01:26:57 <cinimod> oerjan: is the discrepancy between ByteString and ByteString.Lazy a bug?
01:27:30 <oerjan> it makes a bit of sense
01:27:47 <oerjan> a strict ByteString should always fit in memory, so its length should fit in an Int
01:28:42 <oerjan> but a lazy ByteString might be used e.g. for really huge files that don't
01:29:12 <siti> length should be a word :(
01:29:25 <siti> using ints for lengths is evil
01:29:32 <siti> and the cause of so many c/c++ bugs
01:29:38 <oerjan> there could have been an exported type synonym for the length type used, perhaps
01:31:02 <cinimod> I can get my code to work with strict bytestrings - I think I need a lazy BitGet / BitPut
01:31:39 <cinimod> I'll talk to agl to see what can be done
01:32:05 <cinimod> oerjan: thanks for your help
01:32:13 <oerjan> you're welcome :)
02:07:23 <appr> is there a monad transformer similar to the ST monad?  I would like to have a monad transformer with references
02:08:01 * oerjan has been wondering about whether that is possible
02:08:43 <oerjan> it has to be simulated however.  consider STT [].
02:09:20 <Heffalump> you'd need to put ST at the bottom
02:09:23 <oerjan> it would need to copy the entire heap, essentially, whenever there is nondeterminism
02:09:30 <appr> ok
02:10:37 <appr> thanks
02:14:39 <wagle_home> call-with-current-heap
02:14:44 <wagle_home> wow
02:19:06 <oerjan> then it's only matter of time before you want call-with-current-world
02:19:25 <oerjan> (for your IOT programs)
02:41:59 <uccus> @ (not :: a -> a)
02:42:12 <uccus> ? (not :: a -> a)
02:42:32 <uccus> @ not False
02:42:46 <xerox> > not False
02:42:50 <lambdabot>  True
02:42:59 <uccus> thanks xerox
02:43:17 <uccus> > (not :: a -> a) 13
02:43:18 <lambdabot>   a -> a
02:43:18 <lambdabot>       Inferred type: Bool -> Bool
02:43:18 <lambdabot>     In the expression: (not :: a -...
02:43:53 <uccus> so not cannot be "viewed" as a -> a?
02:44:14 <trofimovich> @version
02:44:14 <lambdabot> lambdabot 4p597, GHC 6.8.2 (Linux i686 2.40GHz)
02:44:14 <lambdabot> darcs get http://code.haskell.org/lambdabot
02:45:55 <uccus> is there a way to define a temporary datatype in lambdabot?
02:55:24 <RayNbow> hmm...
02:55:40 <RayNbow> "Trac detected an internal error: database is locked"
02:57:17 <pejo> :t not
02:57:25 <lambdabot> Bool -> Bool
02:58:21 <pejo> uccus, not has that type ^, doesn't have anything to do with how you view it.
02:59:19 <uccus> if I have a function that takes a parameter of type a -> a, it sure would make sense to pass not to that function wouldn't it?
03:01:00 <dv\> why couldn't you
03:01:38 <uccus> if a function _returns_ a function of type a -> a... couldn't I return not from that function?
03:01:55 <Heffalump> uccus: no.
03:02:13 <Heffalump> uccus: because by saying you are returning a -> a you are saying you'll do that for any a
03:02:19 <uccus> I can see why... hehehe... but isn't this asymmetric?
03:02:36 <Heffalump> in a sense, but with rank-2 types you can get the symmetry back
03:02:50 <Heffalump> if you have a function that takes (forall a . a -> a), then you can't pass not to it
03:03:23 <uccus> right. I get the point. thanks.
03:04:07 <uccus> I was reading http://blog.plover.com/oops/subtypes.html
03:04:08 <lambdabot> Title: The Universe of Discourse : Subtypes and polymorphism
03:04:32 <uccus> seems like ML has a gotcha there
03:05:31 <uccus> I practically know nothing about ML... what's the problem there? does it have subtyping while Haskell doesn't? something like that?
03:06:44 <Heffalump> no, it doesn't
03:07:39 <Heffalump> neither has subtyping in the inheritance sense
03:07:51 <Heffalump> though in both you can refine a polymorphic type by instantiating type variables
03:07:56 <Heffalump> ML has a problem because it has references
03:08:09 <Heffalump> whereas in Haskell references are safely hidden inside monads
03:09:44 <uccus> I'm sorry I don't quite follow you. What's the main problem of having references here?
03:09:56 <Heffalump> it's the problem described in that URL
03:10:12 <Heffalump> if you have a polymorphic reference, you can write to it at one type and read from it at another
03:10:29 <uccus> thanks. that's what I was trying to figure out.
03:11:19 <Heffalump> Haskell basically avoids it because the only way you can get a reference is inside a monad, and the only way you can pass things around inside monads is using lambda bindings, which are monomorphic.
03:12:47 <uccus> hahaha
03:12:53 <uccus> that actually makes sense
03:23:27 <magnusth> is there such a beast as a vim syntax file for cabal?
03:28:43 <Arnfreth> How do I install a library in ghc? ie, I need to use the data.time library, and I found it online and all, but I don't know how to actually, like, install it
03:30:15 <Arnfreth> anyone?
03:30:39 <Arnfreth> I'll bake a cake to whoever answers
03:30:48 <Heffalump> where did you find it?
03:30:55 <magnusth> Arnfreth: does it come with a cabal file?
03:31:02 <Arnfreth> I'm not sure
03:31:09 <Arnfreth> http://haskell.org/ghc/dist/current/docs/libraries/
03:31:15 <Arnfreth> I found it there, under data.Time
03:31:26 <Heffalump> it should be with GHC, then
03:32:05 <Arnfreth> really?
03:32:06 <Arnfreth> because when I try to load a file, it says " Could not find module `Data.Time.Calendar'"
03:32:36 <Heffalump> in ghci or ghc?
03:32:39 <Arnfreth> ghci
03:32:56 <Heffalump> what version?
03:33:21 <Beelsebob> using -package time?
03:33:28 <Arnfreth> I'm not totally certain. The standart ubuntu version, to secs
03:33:36 <Heffalump> that's probably 6.6
03:33:51 <Arnfreth> yeah, most likely
03:34:00 <Heffalump> which doesn't have that
03:34:05 <Heffalump> I'd suggest you upgrade
03:34:08 <Arnfreth> ic
03:34:23 <Arnfreth> I'll try that
03:34:28 <Arnfreth> thanks a lot :)
03:34:33 <Arnfreth> I owe you a cake
03:34:50 <Heffalump> I suspect it wouldn't travel across the Atlantic well :-)
03:35:13 <kep> :q
03:35:15 <Beelsebob> Arnfreth: are you using -package time on the command line?
03:35:31 <tibbe> @src some
03:35:31 <lambdabot> some v = some_v
03:35:31 <lambdabot>   where many_v = some_v <|> pure []
03:35:31 <lambdabot>         some_v = (:) <$> v <*> many_v
03:35:39 <Heffalump> Beelsebob: (a) you shouldn't need to in ghci and (b) ubuntu probably comes with 6.6 which I don't think has that module
03:35:57 <Beelsebob> Heffalump: ghci loads packages automagically?
03:36:01 <tibbe> @src many
03:36:01 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
03:36:06 <Heffalump> oh, wait, it does.
03:36:06 <Arnfreth> Beelsebob, I don't know exactly how to use that
03:36:17 <Heffalump> Arnfreth: try ghci -package time (as others have suggested)
03:36:25 <Heffalump> Beelsebob: it seems to for me
03:36:33 <Beelsebob> Heffalump: oh, okay, didn't realise
03:36:43 <Heffalump> Arnfreth: oh, the other thing is that I think the libraries are split up into multiple packages in Debian (and thus ubuntu)
03:36:45 <Arnfreth> "ghc-6.6.1: unknown package: time"
03:36:56 <Beelsebob> yeh, then you need to upgrade to 6.8.x then
03:37:05 <Heffalump> try installing libghc6-time-dev
03:37:13 <Heffalump> if it exists
03:37:17 <Heffalump> which it does in Debian
03:37:32 <Arnfreth> it exists
03:37:41 <Heffalump> I bet you don't have it installed.
03:37:51 <pejo> Arnfreth, apt-cache search libghc6 should give you a list of available libraries, in case you need something else.
03:37:52 <Arnfreth> and you are most correct
03:38:02 <Arnfreth> alright, cool
03:38:41 <Arnfreth> it works now
03:38:43 * Beelsebob wonders why ghc doesn't produce a warning instead of an error when it finds a module that's in a package you haven't explicitly asked for if ghci can do it
03:38:44 <Arnfreth> thanks a lot!
03:39:54 <Arnfreth> I anybody should happen to come by Andalucia, i will stay true to my cake promise!
03:40:06 <Beelsebob> hehe
03:40:28 <Beelsebob> closest I'll be getting is Antwerp at this rate
03:40:47 <Arnfreth> haha, too cold and cloudy
03:40:59 <Beelsebob> just right for me
03:41:09 <Beelsebob> I'm Scottish born, so I don't like it too hot
03:42:09 <Arnfreth> all respect to that
03:42:22 <Arnfreth> I'm danish but was just born in the wrong place
03:42:49 <Beelsebob> hehe
03:44:15 <Arnfreth> but the time stuff works like a charm... now I can get on with my project euler task...
03:44:43 <Beelsebob> :)
03:48:06 <Baughn> http://www.overclock3d.net/news.php?/input_devices/ocz_prepares_neural_impulse_actuator_for_shipping_next_week/1 <-- This is cool. In obHaskell, I intend to use haskell for interpreting the signals.
03:48:08 <lambdabot> Title: Overclock3D.Net :: News :: OCZ prepares Neural Impulse Actuator for shipping nex ..., http://tinyurl.com/37qja6
04:08:33 <tibbe> @src many
04:08:34 <lambdabot> Source not found. I've seen penguins that can type better than that.
04:08:47 <tibbe> @src Data.Applicative.many
04:08:47 <lambdabot> Source not found. Where did you learn to type?
04:08:57 <tibbe> @source Data.Applicative
04:08:57 <lambdabot> Data.Applicative not available
04:09:05 <trofimovich> @hoogle many
04:09:05 <lambdabot> Control.Applicative.many :: Alternative f => f a -> f [a]
04:09:06 <lambdabot> Text.ParserCombinators.ReadP.many :: ReadP a -> ReadP [a]
04:09:06 <lambdabot> Text.ParserCombinators.Parsec.Prim.many :: GenParser tok st a -> GenParser tok st [a]
04:09:42 <tibbe> oh! many and some are expressed in terms of each other so I have to implement one!
04:11:38 <tibbe> or maybe not, hmmm
04:31:39 <smg> @src tuple
04:31:39 <lambdabot> Source not found.
04:31:47 <smg> good morning! :]
04:32:09 <Deewiant> afternoon
04:32:49 <smg> i learned in yaht to handle IO errors with "bracket", but haskell.org tells me to use catch? :]
04:32:52 <smg> can i use both?
04:33:38 <Deewiant> I suppose
04:33:56 <Deewiant> @src bracket
04:33:57 <lambdabot> bracket before after thing = block $ do
04:33:57 <lambdabot>     a <- before
04:33:57 <lambdabot>     r <- catch (unblock (thing a)) (\e -> do { after a; throw e })
04:33:57 <lambdabot>     after a
04:33:57 <lambdabot>     return r
04:34:33 <Deewiant> as I thought: it's implemented in terms of catch, so it's just a higher-level interface
04:38:18 <smg> ah yes we need import IO to use bracket
04:38:28 <smg> catch and ioERROR is in the prelude
04:39:11 <Deewiant> or Control.Exception if you want to be fancy
04:39:39 <Feuerbach> Why read "3" is ambiguous, but read "3"+6 is not, while it's still polymorphic ((Num a, Read a) => a)? Is there (instance (Num a) => Read a) defined anywhere?
04:39:43 <smg> fancy = means to be nice
04:40:06 <smg> Feuerbach: because read can read Int or Float etc
04:40:15 <smg> > read "42" :: Int
04:40:20 <lambdabot>  42
04:40:21 <smg> > read "42" :: Float
04:40:22 <lambdabot>  42.0
04:40:42 <Deewiant> @ty read "3"
04:40:43 <lambdabot> forall a. (Read a) => a
04:40:45 <Deewiant> @ty read "3"+6
04:40:46 <lambdabot> forall a. (Num a, Read a) => a
04:40:53 <smg> Feuerbach: i guess implicit cast?
04:41:02 <smg> > read "42" + 1.0
04:41:03 <lambdabot>  43.0
04:41:04 <Deewiant> Feuerbach: I would guess it is because there's a default Int (or is it Integer?) for Num
04:41:17 <Deewiant> so that stuff like "print 1" works
04:41:28 <Deewiant> without having to specify print (1::Int)
04:42:24 <smg> btw
04:43:42 <apn> hi, I'm trying to install HSQL 1.7 for a PostgreSQL backend
04:43:59 <apn> I successfully configure, build, install'ed HSQL
04:44:28 <apn> but installing the Postgresql package fails
04:44:34 <apn> ghc-pkg: /usr/include/postgresql/8.1/server doesn't exist or isn't a directory (use --force to override)
04:44:45 <apn> there is no /8.1/ directory there
04:44:55 <apn> although I just installed PostgreSQL 8.1
04:45:10 <apn> what am I missing?
04:45:16 <apn> I using Debian
04:46:16 <jaj> apn: do you have a postgres server installed+
04:46:34 <mnislaih> dcoutts: how does one go about testing Cabal patches these days ?
04:46:37 <jaj> I'm not a debian user but perhaps there is a postgres-dev package
04:46:47 <mnislaih> dcoutts:  is it a good idea to test with the ghc suite ?
04:47:18 <jaj> they tend to not include development stuff into the main package but provide a -dev package
04:47:25 <apn> I have "postgresql-8.1" and "postgresql-client-8.1"
04:47:35 <smg> printf "%d" 10 :: String <-- gives me string how can i get number?
04:47:48 <apn> maybe I need "postgresql-server-dev-8.1"?
04:48:10 <jaj> apn: most probably
04:48:30 <Beelsebob> smg: hmm? you have the number -- 10
04:48:33 <apn> let's see
04:48:36 <Beelsebob> I don't follow what you want
04:49:14 <jaj> apn: can't you just install the libghc6-hsql-postgresql-dev package?
04:49:22 <jaj> through apt-get
04:49:51 <apn> that's version 1.6.8
04:50:15 <apn> ah yes, it works now
04:50:18 <Deewiant> smg: why not just 10? why the printf if you want the number :-)
04:50:27 <apn> -server-dev helped
05:04:35 <EvilTerran> smg, look at the Read and Show classes in the Prelude
05:04:51 <EvilTerran> > show "10"
05:04:51 <lambdabot>  "\"10\""
05:04:53 <EvilTerran> > show 10
05:04:53 <lambdabot>  "10"
05:04:58 <EvilTerran> > read "10" :: Int
05:04:59 <lambdabot>  10
05:05:10 <EvilTerran> > read "10" :: Double -- suddenly, magic
05:05:11 <lambdabot>  10.0
05:07:30 <Jaak> > read (read "\"10\"")) :: Int
05:07:30 <lambdabot> Unbalanced parentheses
05:07:37 <Jaak> > read (read "\"10\"") :: Int
05:07:38 <lambdabot>  10
05:08:06 <EvilTerran> @scheck \x -> (read.show) x == (x :: Int)
05:08:08 <lambdabot>   Completed 13 test(s) without failure.
05:08:13 <EvilTerran> @check \x -> (read.show) x == (x :: Int)
05:08:15 <lambdabot>  OK, passed 500 tests.
05:08:36 <EvilTerran> @help scheck
05:08:36 <lambdabot> scheck <expr>
05:08:36 <lambdabot> You have SmallCheck and 3 seconds. Test something.
05:09:58 <EvilTerran> @where smallcheck
05:09:58 <lambdabot> http://www.cs.york.ac.uk/fp/smallcheck0.2.tar
05:10:30 <Jaak> > fix (show . read)
05:10:31 <lambdabot>  Exception: <<loop>>
05:10:53 <Beelsebob> > fix ((show . read) :: Int -> Int)
05:10:54 <lambdabot>  Couldn't match expected type `Int' against inferred type `String'
05:11:01 <Beelsebob> oh, flail
05:11:07 <Beelsebob> <-- moron
05:11:44 <olsner> read . show?
05:11:48 <Beelsebob> idd
05:12:08 <Beelsebob> just misread what he typed
05:14:28 <EvilTerran> @yhjulwwiefzojcbxybbruweejw
05:14:28 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
05:14:55 <Beelsebob> @. vixen yhjulwwiefzojcbxybbruweejw
05:14:56 <lambdabot> Ok
05:14:59 <Beelsebob> lol
05:15:39 <Jaak> > fix show
05:15:40 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
05:15:51 <Beelsebob> o.O
05:15:55 <Beelsebob> interesting
05:15:56 <Jaak> magic!
05:16:07 <Beelsebob> magicall exponential \ generator
05:16:10 <cin> the gathering
05:16:33 <RayNbow> @src fix
05:16:33 <lambdabot> fix f = let x = f x in x
05:16:55 <EvilTerran> @@ @@ @read @run let s = (@show @yow) in "<yow> " ++ s ++ " <vixen> @vixen " ++ s
05:16:56 <lambdabot> Plugin `compose' failed with: Prelude.read: no parse
05:16:58 <EvilTerran> @@ @@ @read @run let s = (@show @yow) in "<yow> " ++ s ++ " <vixen> @vixen " ++ s
05:16:59 <lambdabot> Plugin `compose' failed with: Prelude.read: no parse
05:17:01 <EvilTerran> grr
05:17:06 <EvilTerran> it works in pm, damnit
05:17:09 <EvilTerran> @@ @@ @read @run let s = (@show @yow) in "<yow> " ++ s ++ " <vixen> @vixen " ++ s
05:17:11 <lambdabot> Plugin `compose' failed with: Prelude.read: no parse
05:17:14 <EvilTerran> >.<
05:17:22 <EvilTerran> @@ @read @run let s = (@show @yow) in "<yow> " ++ s ++ " <vixen> @vixen " ++ s
05:17:23 <lambdabot> Plugin `compose' failed with: Prelude.read: no parse
05:17:26 <EvilTerran> wtf
05:17:51 <EvilTerran> <EvilTerran> @@ @@ @read @run let s = (@show @yow) in "<yow> " ++ s ++ " <vixen> @vixen " ++ s
05:17:51 <EvilTerran> <lambdabot>  <yow> All of a sudden, I want to THROW OVER my promising ACTING CAREER, growa LONG BLACK BEARD and wear a BASEBALL HAT!! ...  Although I don't know WHY!! <vixen> well find out then
05:19:55 <Jaak> > take 10.(0:).map ((+1).snd).filter fst.zip (cycle [False,True]).map length.group$fix show
05:19:55 <lambdabot>  [0,2,4,8,16,32,64,128,256,512]
05:20:47 <EvilTerran> > fix $ (1:).map(+1)
05:20:48 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
05:21:01 * EvilTerran mumbles something and wanders off
05:21:23 <Jaak> > take 10 $ fix $ (1:).map(*2)
05:21:23 <lambdabot>  [1,2,4,8,16,32,64,128,256,512]
05:22:30 <EvilTerran> > iterate (*2) 1
05:22:31 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
05:23:39 <Baughn> > iterate (^2) 2
05:23:40 <lambdabot>  [2,4,16,256,65536,4294967296,18446744073709551616,34028236692093846346337460...
05:24:04 <Deewiant> > fix (scanl (+) 1)
05:24:16 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
05:24:34 <DQuest> that is beautiful
05:24:39 <Baughn> > fix (+1)
05:24:40 <lambdabot>  Exception: <<loop>>
05:24:40 <Deewiant> > fix (scanl (*) 2)
05:24:41 <lambdabot>  [2,4,16,256,65536,4294967296,18446744073709551616,34028236692093846346337460...
05:24:55 <Baughn> > fix (1+)
05:24:56 <lambdabot>  Exception: <<loop>>
05:25:07 <Baughn> ..no fair solving the halting problem
05:28:42 <olsner> > fix$(.)<$>(:)<*>((.((:[]).))(=<<).(*).(*2))$1
05:28:43 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
05:29:21 <EvilTerran> o god the colours
05:29:31 <Mr_Awesome> olsner: did you write that by hand?
05:29:57 <avtobiff> which db interface is the weapon of choice for haskell?
05:29:59 <olsner> Mr_Awesome: mostly.. but I started with something like iterate (*2) 1, expanding, rewriting and @pl'ing as I went along
05:30:24 <Mr_Awesome> indeed. bravo
05:30:31 <avtobiff> i am choosing between haskelldb, hdbc, hsql. pros cons. is there some documentation or tips?
05:31:02 * EvilTerran is tempted to bring out his fmappifier and see what it does to that
05:31:20 <olsner> (if it is something to be proud of is debatable :P)
05:31:42 <Mr_Awesome> heh, it scares off the newbies ;)
05:32:52 <olsner> EvilTerran: there's a liftM2 in there, written as f<$>x<*>y$z
05:33:43 <olsner> but liftM2 just seemed so verbose :P
05:33:49 <EvilTerran> olsner, so i see
05:34:46 <EvilTerran> > fix$fmap<$>(:)<*>((flip fmap(fmap(:[])))(=<<)`fmap`(*)`fmap`(*2))$1
05:34:47 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
05:35:12 <EvilTerran> i can't be bothered going any further by hand. the brackets're doing my head in. :P
05:35:17 <olsner> (:[]) = return
05:36:57 <olsner> btw, it uses ((:[]).f =<<) for a map f - you could change that to a fmap
05:37:37 <malebria> Hello there.
05:38:02 <malebria> Do you know what library is a good option to do a simple HTML/TeX generator?
05:38:07 <malebria> Like txt2tags...
05:42:25 <wli> What do you mean by a "HTML/TeX generator?"
05:44:03 <olsner> ghci gives me this: *** Exception: <stdin>: hGetContents: illegal operation (handle is closed) when trying to run :main <input.txt
05:44:17 <wli> Do you mean that it generates both in some combination or something else?
05:44:33 <olsner> perhaps using stdin is verboten in ghci
05:45:20 <malebria> wli: It gets a text file with very simple tags and converts it to a HTML or a LaTeX file.
05:45:35 <malebria> like //text// = <i>text</i> and \emph{text}
05:45:46 <EvilTerran> olsner, i don't think you can re-direct like that
05:45:55 <EvilTerran> you'll just be giving "<input.txt" as an argument
05:46:06 <olsner> meh
05:47:31 <wli> malebria: You'll probably do fine with a simple parser and ad hoc tree processing.
05:49:23 <malebria> wli: by simple parser you mean things like takeWhile, etc?
05:49:39 <smg> hehe
05:49:51 <smg> EvilTerran: that's awesome :]
05:50:02 <wli> malebria: No, a simple parser as in something calling into Parsec with little or no custom parsing algorithms.
05:50:35 <wli> e.g. no hand-coded Earley algorithms etc.
05:50:39 <malebria> hum..
05:50:52 <malebria> I've never done anything with Parsec...
05:50:56 <malebria> I'll take a look
05:51:30 <apn> avtobiff: I just succesfully installed hsql. It seems to be straightforward to use if you know sql
05:52:10 <olsner> how do I use the ghci debugger to find out where my program is stalling?
05:55:04 <olsner> specifically, I want to be able to Ctrl-C and see what everything's doing
05:55:27 <hpaste>  smg pasted "mycopy.hs" at http://hpaste.org/6054
05:55:59 <Baughn> apn: I never did figure out how you add parameters to a call in hsql, and only being able to use static queries is a bit useless.
05:56:02 <smg> hpaste: thank you :P
05:56:10 <Baughn> HDBC is considerably simpler on that front, at least
05:56:44 <EvilTerran> > sort "irrelevant" == sort "evilterran" -- smg, this is also relevant
05:56:47 <lambdabot>  True
05:56:52 <EvilTerran> (pardon the pun)
05:57:16 <apn> Baughn; as far as I could figure it out in the last hour or so that should work with String concatenation
05:57:23 <smg> EvilTerran: interesting
05:57:27 <Baughn> apn: Absurd
05:57:48 <smg> http://hpaste.org/6054?lines=true <-- line 32,33
05:57:49 <Baughn> apn: One *does not* use string concatenation, unless you're really /trying/ for security holes
05:57:52 <smg> can i make this more compact?
05:58:09 <apn> Baughn: execute c "CREATE TABLE "++thetablenameandstuff++";"
05:58:15 <smg> like say hPutStr handle $ hGetContents handle2 ?
05:58:22 <olsner> @remember EvilTerran > sort "irrelevant" == sort "evilterran"
05:58:22 <lambdabot> Okay.
05:58:30 <Baughn> apn: No user input?
05:58:31 <EvilTerran> :)
05:58:49 <apn> Baughn: you'd have to escape it first
05:59:07 <Baughn> apn: I don't see any escape functions in hsql
05:59:27 <apn> Baughn: then one would need to write their own
06:00:01 <Baughn> apn: I'll stick to parameters, thank you.
06:01:15 <smg>  --                           contents <- hGetContents in_handle
06:01:15 <smg>    --                         hPutStr out_handle contents
06:01:15 <smg>                            hGetContents in_handle >>= \temp -> hPutStr out_handle temp
06:01:20 <smg> that is equivalent isn't it?
06:01:21 <smg> :]
06:01:49 <Saizan_> you can eta-reduce the lambda abstraction
06:02:01 <Saizan_>  hGetContents in_handle >>= hPutStr out_handle
06:02:04 <smg> ah okay
06:02:29 <smg> Saizan_: cool! i figured it out on my own :]
06:14:30 <jrx_> @hoogle String -> [String]
06:14:31 <lambdabot> Prelude.lines :: String -> [String]
06:14:31 <lambdabot> Prelude.words :: String -> [String]
06:14:31 <lambdabot> Data.List.lines :: String -> [String]
06:14:43 <jrx_> @src words
06:14:43 <lambdabot> words s = case dropWhile isSpace s of
06:14:43 <lambdabot>     "" -> []
06:14:43 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
06:17:08 <Beelsebob> @src break
06:17:08 <lambdabot> break p =  span (not . p)
06:17:23 <Beelsebob> @src span
06:17:23 <lambdabot> Source not found. You speak an infinite deal of nothing
06:35:08 <smg> > take 5 $ repeat "I like Haskell"
06:35:13 <lambdabot>  ["I like Haskell","I like Haskell","I like Haskell","I like Haskell","I like...
06:56:06 <resiak> > cycle "I'm really into Haskell, and that's about it. "
06:56:07 <lambdabot>  "I'm really into Haskell, and that's about it. I'm really into Haskell, and ...
07:05:08 <jrx_> @hoogle (<$>)
07:05:09 <lambdabot> Did you mean: (<$>)
07:05:09 <lambdabot> Prelude.undefined :: a
07:05:09 <lambdabot> Control.Monad.State.Class.get :: MonadState s m => m s
07:05:21 <jrx_> @hoogle <$>
07:05:21 <lambdabot> Control.Applicative.(<$>) :: Functor f => (a -> b) -> f a -> f b
07:05:34 <smg> resiak: nice
07:07:36 <Beelsebob> > minimum [Just 5, Just 6, Just 2, Nothing]
07:07:40 <lambdabot>  Nothing
07:07:46 <Beelsebob> > minimum [Just 5, Just 6, Just 2]
07:07:46 <lambdabot>  Just 2
07:08:05 <smg> I love this channel.
07:08:18 <Beelsebob> > minimum ([] :: Maybe Int)
07:08:18 <lambdabot>  Couldn't match expected type `Maybe Int'
07:08:29 <Beelsebob> > minimum ([] :: [Maybe Int])
07:08:29 <lambdabot>  Exception: Prelude.minimum: empty list
07:09:43 <smg> @moo
07:09:43 <lambdabot> Maybe you meant: map more msg todo yow
07:10:40 <Beelsebob> aww, disapointing
07:11:51 <skorpan> hey
07:12:11 <skorpan> is there anything in haskell (library or something else) which work like atoms in erlang?
07:12:51 <Beelsebob> <ignorance>How does an atom in erlang work?</ignorance>
07:13:28 <skorpan> kind of hard to describe
07:13:38 <skorpan> how about "symbols" in ruby? kind of like those.
07:13:52 <oskarM> like atoms in Prolog?
07:14:05 <skorpan> could be like atoms in prolog, haven't really done very much in it
07:14:39 <Beelsebob> skorpan: stop giving examples in my list of "languages to learn at some point" :P
07:14:45 <skorpan> Beelsebob: :)
07:14:51 <andun> skorpan: if you do "data Atoms = Foo | Bar", then Foo and Bar are somewhat like atoms in Ruby
07:15:07 <skorpan> andun: yes, but then again, i want data Atoms to be infinite
07:15:16 <oskarM> Haskell is statically typed which makes some difference, but data declaration introduces a similar concept
07:15:24 <skorpan> i'm trying to make an embedded language for representing board games in haskell
07:15:42 <andun> skorpan: data Atom = Atom String, perhaps?
07:15:42 <skorpan> so one board game could have Queen, King, Rook, while another could have only Piece
07:15:57 <skorpan> andun: i guess that's the way, huh? :/
07:16:03 <Saizan_> skorpan: make it parametric in the "atom" type
07:16:41 <skorpan> Saizan_: that's what andun said, right? not too familiar with the terminology here
07:17:33 <Saizan_> eg, data Board a = Board [[a]], data ChessPiece = King | Queen | .. data GoPiece = Black | White,then you can have Board ChessPiece or Board GoPiece
07:17:55 <skorpan> ah
07:18:40 <andun> skorpan: i think the main reason why you need it in ruby is because two strings are different objects even if they contain the same text, but two symbols are the same, right?
07:19:03 <skorpan> andun: that's not really why
07:19:20 <Saizan_> so you can have functions that work on (Board a) generically, and still add some specific for each piece
07:20:08 <Saizan_> you probably want to add a typeclass somewhere
07:20:11 <skorpan> andun: what you said is true, but i don't think that's the main reason that matz chose to include symbols in ruby
07:20:25 <skorpan> symbols are just neat and good-to-have
07:21:32 <andun> andyjgill: in ruby, definately. in haskell i've never missed them
07:21:56 <ska-fan> Too bad the M in geek code stands for Macintosh already, else it could be used to signify ones understanding of monads :)
07:22:01 <andun> definitely* :p
07:25:33 <jpcooper> helo
07:25:34 <jpcooper> hello*
07:25:47 <jpcooper> how can one import FiniteMap on ghc-6.6.1?
07:27:11 <smg> jpcooper: :FiniteMap
07:27:16 <smg> eh :m FiniteMap
07:27:21 <Saizan_> jpcooper: you can install this http://hackage.haskell.org/cgi-bin/hackage-scripts/package/FiniteMap-0.1 , but if it's for new code use Data.Map
07:27:24 <jpcooper> doesn't work
07:27:26 <lambdabot> http://tinyurl.com/2j3ho6
07:27:35 <jpcooper> aah, YAHT said FiniteMap
07:27:36 <jpcooper> thank you
07:40:28 <jrx_> @src init
07:40:29 <lambdabot> init [x]    = []
07:40:29 <lambdabot> init (x:xs) = x : init xs
07:40:29 <lambdabot> init []     = undefined
07:40:44 <jrx_> > init [1,2,3]
07:40:48 <lambdabot>  [1,2]
07:44:04 * cjb declares that Cale won the hostname contest, with thunk.
07:44:15 <cjb> I'm gonna add "maybe" to the list too :)
07:44:25 <smg> mh now i need to recall what thunk was
07:44:52 <Beelsebob> smg: a thunk is a block of computation that still needs to be thunk about
07:44:59 <cjb> smg: what it means?  it's a lazy computation that hasn't yet been evaluated; a placeholder for a computation.
07:45:04 <smg> ah exactly
07:45:08 <Beelsebob> i.e. it's still sat there as an application, not fully evaluated
07:45:14 <shachaf> cjb: Hostname contest?
07:45:18 <smg> that was is. i read about in the chapter "strict" and stuff
07:45:20 <smg> and _|_
07:45:32 <cjb> shachaf: I was looking for five-letter FP-ish hostname ideas for a new machine
07:45:50 <cjb> and got.. thunk, monad, unity, curry, arrow, foldr, apply, ycomb, tuple, maybe.
07:45:54 <Beelsebob> spend enough time on t'internet smg and you'll be able to thunk about bottom any time you like
07:45:56 <shachaf> xmonad used to be called "thunk" too.
07:46:07 <mnislaih> @seen dcoutts
07:46:08 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-soc, #haskell-overflow, #haskell and #ghc. I don't know when dcoutts last spoke.
07:46:15 <smg> Beelsebob: :)
07:47:28 <smg> btw is ! for constructors something like ~ / fix() for functions?
07:47:32 <shachaf> cjb: Why five-letter?
07:47:43 <shachaf> smg: It makes things strict.
07:48:07 <shachaf> smg: (What do you mean, like fix()?)
07:48:07 <smg> shachaf: bot hdo then?
07:48:12 <Beelsebob> not totally strict though
07:48:23 <smg> i mean ~ and ! make things strict
07:48:28 <Beelsebob> only the outermost construction is strict
07:48:40 <shachaf> smg: ~ does the opposite, sort of.
07:48:48 <Beelsebob> you need to use deepSeq to get deep strictness
07:48:58 <smg> shachaf: ah okay
07:49:02 <smg> i never needed ~
07:49:04 <smg> only !
07:49:13 <shachaf> > let f ~(x:xs) = 5 in f []
07:49:14 <lambdabot>  5
07:49:24 <shachaf> > let f (x:xs) = 5 in f []
07:49:25 <lambdabot>   Non-exhaustive patterns in function f
07:49:36 <Beelsebob> smg: you never need ! either
07:49:37 <shachaf> smg: ~ is a pattern that always matches.
07:50:00 <smg> shachaf: hehe so is _ and @
07:50:09 <shachaf> smg: @?
07:50:11 <Beelsebob> smg: yes, but not in the same way
07:50:19 <shachaf> smg: @ is just giving a different name to a pattern.
07:50:22 <smg> i know :]
07:50:23 <Beelsebob> note that [] would not match against (x:xs) ever
07:50:29 <smg> but it matches also always :)
07:50:32 <Beelsebob> unless you really force it to
07:50:34 <smg> i learned that @ haskell.org :]
07:50:37 <smg> and @ implies ~
07:50:42 <Beelsebob> no
07:50:43 <cjb> shachaf: it's just a habit.  my last naming scheme was five-letter palindromes.
07:50:43 <jrx_> @hoogle String -> Int
07:50:43 <lambdabot> No matches, try a more general search
07:50:55 <Beelsebob> @ mereley lets you name a match in multiple ways
07:51:02 <cjb> (which you can type very easily; three fingers, and two of them don't move.)
07:51:06 <shachaf> cjb: I think "curry" is nice, since it's a real name.
07:51:18 <Beelsebob> x@(x1:xs) <-- still only matches against >0 element lists
07:51:34 <shachaf> How about "hlist"? Maybe too specific.
07:51:43 <cjb> yes, me too.  I used to live in Manchester in England, where everyone eats curry all the time.  :)
07:51:46 <Beelsebob> jrx_: try read
07:51:59 <Beelsebob> > read "5" :: Int
07:52:00 <lambdabot>  5
07:52:23 <jrx_> Beelsebob: yep, I know about read, I was just curious if there is some special prelude function for reading numbers
07:52:31 <cjb> in fact, a friend's naming scheme was types of curry -- dhansak, dopiaza, korma, rogan-josh, jalfrezi, etc.
07:52:33 <Beelsebob> yes, read :P
07:53:17 <EvilTerran> ?src concatMap
07:53:17 <lambdabot> concatMap f = foldr ((++) . f) []
07:53:28 <shachaf> How about other languages?
07:53:38 <shachaf> "clean", "lazyk", and so on.
07:53:55 * shachaf suspects this is a bit off-topic.
07:54:39 * EvilTerran finally satisfies himself that "m >>= g = Foldr$ \f e -> runFoldr m (\x h -> runFoldr (g x) f h) e" is correct for the Monad instance for "data Foldr a = Foldr (forall e. (a -> e -> e) -> e -> e)"
07:55:54 <EvilTerran> with "runFoldr (Foldr a) f e = a f e
07:55:54 <EvilTerran> ; toFoldr xs = Foldr$ \f e -> foldr f e xs; fromFoldr m = runFoldr m (:) []", the expression "fromFoldr $ toFoldr xs >>= toFoldr . fn" works out to "concatMap fn xs" :)
08:18:06 <avtobiff> where does the HSQL documentation reside?!
08:18:09 <avtobiff> lambdabot, HSQL
08:18:55 <avtobiff> nm found it
08:32:11 <Gilly> Does a neat way exist to do something like this: case t of (>=1) -> blah; (<=0) -> foo; otherwise -> bar ?
08:32:44 <Spark> what would otherwise consist of?
08:32:56 <Spark> and why not just use an if
08:33:03 <smg> Gilly: case compare t of
08:33:10 <Gilly> because then i'll have to use many nested ifs
08:33:35 <Heffalump> case t of _ | (t>=1) -> blah; (t<=0) -> foo; otherwise -> bar
08:34:02 <Spark> but there's only 2 possibilities
08:34:28 <Spark> unless you want to case over more intervals than just positive/negative
08:34:54 <Gilly> i want to case the three intervals
08:35:04 <Gilly> t <= 0, 0 < t < 1, 1 <= t
08:35:46 <avtobiff> is it possible to make a global constant in haskell? (i want database name to be the same in every function)
08:35:52 <smg> Heffalump: thank you
08:36:13 <Gilly> Heffalump: hm doesn't seem to work
08:36:35 <smg> Heffalump: no i know how to write case statement in one line
08:36:53 <Heffalump> gillu: really?
08:36:58 <Heffalump> s/gillu/Gilly/
08:37:01 <Gilly> yea
08:37:05 <Heffalump> smg: Gilly already told you that :-)
08:37:08 <Heffalump> Gilly: hpaste your code?
08:37:17 <smg> Heffalump: :)
08:37:29 <Gilly> sure, a minute :P
08:37:46 <Heffalump> the ; approach works for anything
08:38:03 <Heffalump> well sometimes you might need { } to
08:38:11 <Heffalump> s/ to/ too/
08:38:57 <hpaste>  Gilly pasted "Case of intervals" at http://hpaste.org/6056
08:39:09 <Gilly> there we go
08:40:08 <noecksit> hello, i have something that i would like to do but am not sure how to do it efficiently
08:40:24 <Heffalump> and what goes wrong?
08:40:43 <Gilly> invalid indentation / invalid pattern depending if i put it on one line or multiple lines
08:40:49 <noecksit> it is basically a 3x3 list, ie in each entry of a list, there is a list of three elements
08:41:01 <noecksit> or a tic-tac-toe board
08:41:03 <Heffalump> put the _ | on the next line before the first guard, and line the other guards up with that first guard
08:41:26 <noecksit> and i want to generate all the moves based on a current move and make a list of them
08:42:03 <noecksit> ive figured out how to do it somewhat but it seems very inefficient
08:42:34 <smg> whehn i'm in do block i can use {} and ;
08:42:39 <Gilly> > let t = 1 in case t of _ | (t<=1) -> "Foo" ; (t>2) -> "Bar"
08:42:39 <lambdabot>  Parse error in pattern at "->" (column 52)
08:42:48 <Gilly> that's what i got basically
08:43:05 <Heffalump> Gilly: I'm not acutlaly sure how to do it on one line correctly, I was just aping your syntax :-)
08:43:12 <Heffalump> the point of my hint was the use of _ for the pattern
08:43:37 <Heffalump>  \s1 s2 t -> case t of { _ | (t >= 1) -> s2 ; _ | (t <= 0) -> s1 ; _  -> (s1 + t * (s2-s1)) }
08:43:38 <Gilly> well i have it like this now:
08:43:43 <Gilly> case t of _ | (t>=1) -> s2
08:43:45 <Heffalump> that works, though it's not quite the same as I suggested.
08:43:46 <Gilly> oh doh
08:43:47 <hpaste>  noecksit pasted "tree" at http://hpaste.org/6057
08:43:52 <Gilly> it didn't multiline paste :P
08:44:01 <noecksit> here it is for someone that may look at it
08:44:04 <Heffalump> in fact it works without the braces
08:44:23 <Gilly> but... what does | do?
08:44:46 <Heffalump> Gilly: it introduces a guard.
08:44:59 <noecksit> it is not complete, because right now it just puts a Just O in every instance of Nothing
08:45:05 <Heffalump> which is a boolean condition that determines whether the clause will run, after pattern-matching.
08:45:19 <noecksit> i need it to put only one Just O based on n
08:45:21 <Heffalump> So we pattern match against _, i.e. the pattern that always matches, then the guard is checked.
08:45:26 <Gilly> ah
08:45:36 <Gilly> so i expect i got to add that guard to every clause
08:45:50 <Heffalump> you can have a list of guards for a single pattern
08:45:52 <Gilly> but... if the case matches the first pattern and fails the guard will it still try to match the second pattern?
08:45:58 <Heffalump> yes
08:46:01 <Gilly> ok great
08:46:26 <Heffalump> oh, duh
08:46:34 <Heffalump> I forgot to repeat the |s. That's why my code didn't work.
08:46:58 <Gilly> ah ok so one match suffices and then just use multiple guards?
08:47:02 <Heffalump> yep
08:47:14 <Heffalump> not quite sure how to do it on one line, but if you line up the |s under each other it'll be fine.
08:47:25 <Gilly> yea it works now :) thanks for your help
08:47:43 <Heffalump> smg: and you are still only slightly the wiser about doing case of on a single line :-)
08:49:59 <Heffalump> is jgbailey@gmail.com on here?
08:54:21 <KonvIRC> Hi. I am quite new to Haskell. I try to write a simple Sieve of Eratosthenes algorithm. First I want to filter out all numbers that can be divided by a number n using the following: filterNumbers n (x:xs) = if (x `mod` n) == 0 then filter n xs else x : filter n xs. But I get an error: Type Int does not match Int -> Bool. What am I doing wrong here?
08:55:10 <ibid> KonvIRC: you're mixing using filter and direct recursion. in this case, choose one but don't do both.
08:55:40 <EvilTerran> KonvIRC, i think you may want to say "filterNumbers" where you've said "filter"
08:55:47 <ibid> KonvIRC: ugh, forget what i said :
08:55:49 <EvilTerran> ?type filter -- filter is a builtin function
08:55:50 <ari> > filter (/= 10) [8..12]
08:55:50 <ibid> KonvIRC: EvilTerran is correct
08:55:55 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
08:55:56 <lambdabot>  [8,9,11,12]
08:58:48 <KonvIRC> Thanks, obviously I should use filterNumbers instead of filter on the right hand side. Stupid mistake
09:08:53 * EvilTerran blinks at monad transformers
09:09:44 * shachaf transforms monadic blinkers.
09:10:58 <EvilTerran> ?src ListT >>=
09:10:58 <lambdabot> Source not found. stty: unknown mode: doofus
09:11:01 <EvilTerran> ?src ListT (>>=)
09:11:01 <lambdabot> Source not found.
09:12:17 <EvilTerran> ?src concatMap
09:12:17 <lambdabot> concatMap f = foldr ((++) . f) []
09:16:16 <gnuvince_> @src reverse
09:16:16 <lambdabot> reverse = foldl (flip (:)) []
09:16:35 <gnuvince_> @src foldl
09:16:35 <lambdabot> foldl f z []     = z
09:16:35 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
09:16:56 <EvilTerran> :t foldr (liftM2 (:)) (return ())
09:17:00 <lambdabot>     Couldn't match expected type `[a1]' against inferred type `()'
09:17:00 <lambdabot>     In the first argument of `return', namely `()'
09:17:00 <lambdabot>     In the second argument of `foldr', namely `(return ())'
09:17:04 <EvilTerran> :t foldr (liftM2 (:)) (return []) -- ahem
09:17:05 <lambdabot> forall a1 (m :: * -> *). (Monad m) => [m a1] -> m [a1]
09:18:30 <EvilTerran> :t liftM concat . sequence
09:18:32 <lambdabot> forall a (m :: * -> *). (Monad m) => [m [a]] -> m [a]
09:27:19 <EvilTerran> :t liftM concat . sequence . map ?f =<< ?x
09:27:20 <lambdabot> forall a (m :: * -> *) a1. (?x::m [a1], ?f::a1 -> m [a], Monad m) => m [a]
09:27:44 <EvilTerran> i can't help but feel there must be a better way of doing that
09:28:38 <EvilTerran> (i'm not using lists in what i'm actually working on, but they are kinda similar)
09:28:52 * EvilTerran is trying to write FoldrT to go with his Foldr
09:29:36 <roconnor> EvilTerran: is m [a] a monad for you?
09:29:49 <EvilTerran> i'm trying to define the instance for it
09:29:57 <banbh> What is the right way to upgrade package like bytestring?  i have 6.8.2 installed on OS X, compiled from source.  this gave me bytestring 0.9.0.1.  I installed pureMD5 (which worked).  The I upgraded bytestring 0.9.0.4 in the usual way using cabal.  Now md5 complains about Couldn't match expected type `L.ByteString' against inferred type `bytestring-0.9.0.1:Data.ByteString.Lazy.Internal.ByteString'.  This happens when I try to rebuild pureMD5.
09:29:59 <roconnor> m [a] is not a monad in general.
09:29:59 <EvilTerran> instance Monad m => Monad (FoldrT m) where...
09:30:08 <EvilTerran> i know, i know
09:30:22 <EvilTerran> the MTL instance for ListT is broken
09:32:04 <EvilTerran> i'm looking at the "ListT done right"s for inspiration as wll
09:32:39 <Deewiant> banbh: Sounds odd, perhaps one of the object files expects bytestring-0.9.0.1? A clean rebuild might fix it, but I'm not sure.
09:33:19 <banbh> Deewiant: a clean rebuild of just pureMD5?
09:33:21 <mapreduce> Haskell has this thing called 'ap'.  What is that an abbreviation for?
09:33:40 <Deewiant> banbh: yeah, remove the .hi and .o files
09:33:49 <Deewiant> mapreduce: probably 'apply' in some weird way
09:34:16 <banbh> Deewiant: thanks.  i'm trying it now
09:35:23 <EvilTerran> mapreduce, Deewiant: yeah, apply
09:35:46 <EvilTerran> as in you can do with an Applicative functor
09:35:58 <mapreduce> Thanks.
09:37:47 <dcoutts> mnislaih: pong
09:37:58 <Jaak> @type ap
09:38:01 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
09:38:04 <banbh> Deewiant: I tried doing a cabal clean, configure and build for pureMD5 and received the same error
09:38:09 <mnislaih> dcoutts: yep
09:38:47 <Deewiant> banbh: meh, I'm afraid I don't know what's wrong then... perhaps the .cabal files refer to 0.9.0.1 directly or something, but I'm not very familiar with Cabal myself so I don't know
09:39:07 <dcoutts> mnislaih: you were asking about testing cabal patches, we don't have a formal test suite atm
09:39:27 <mnislaih> aha,
09:39:36 <kolmodin> @yarr!
09:39:36 <lambdabot> This is the END for you, you gutter-crawling cur!
09:39:38 <mnislaih> shall I send them your way for review then ?
09:39:43 <kolmodin> dcoutts: hia!
09:39:47 <resiak> how would you come to have an m (a -> b) in practice, other than by calling 'return' on a pure function?
09:39:48 <kolmodin> thought I would not see you
09:40:10 <Heffalump> resiak: the pure function might bind variables that were obtained inside a monad
09:40:11 * resiak gives a TIP to lambdabot, if she gets the POINT.
09:40:33 <Heffalump> e.g. do a <- readInt ; return (+a)
09:40:49 <dcoutts> banbh: it'll be because puremd5 package depends on both bytestring and the binary package and you upgraded bytestring but your binary package will still be using the older bytestring
09:40:55 <resiak> hrm, fair enough.
09:41:04 <shachaf> @ty (+) <$> [1,2,3]
09:41:05 <lambdabot> forall a. (Num a) => [a -> a]
09:41:08 <shachaf> @ty (+) <$> [1,2,3] <*> [4,5,6]
09:41:09 <lambdabot> forall a. (Num a) => [a]
09:41:18 <banbh> dcouts: thanks.  i'll try recompiling binary
09:41:23 <dcoutts> banbh: the latest version of cabal detects that error and gives an explanation of which packages have conflicting dependencies
09:41:34 <dcoutts> hia kolmodin
09:41:37 <banbh> dcoutts: thx
09:41:39 <Deewiant> > ap (+) (*2) 4
09:41:40 <lambdabot>  12
09:41:51 <resiak> > [(+1), (*3)] `ap` [5,6]
09:41:52 <lambdabot>  [6,7,15,18]
09:41:52 * roconnor wonders why people are still using MD5
09:41:58 <stevan> is there a simpler way of updating a field in state than this: modify $ \s -> s { count = succ $ count s } ?
09:42:00 <resiak> i suppose that woul also work!
09:42:17 <shachaf> roconnor: Because people are still using MD5? :-)
09:42:23 <banbh> is there a better digest in haskell?
09:42:34 <EvilTerran> stevan, sadly not. the record syntax is a bit rubbish.
09:42:48 <banbh> The advantage i found of pureMD5 is that can deal with large files
09:42:49 <roconnor> How come the Haskell Crypto library is in the Codec section, while pureMD5 is in  Cryptography section?
09:43:08 <roconnor> banbh: how do you mean?
09:43:17 <roconnor> advantage over what?
09:43:17 <dcoutts> roconnor: depends what category the package declares itself to be in
09:43:20 <shachaf> roconnor: Because people can pick their own categories.
09:43:36 <roconnor> can people make up their own categories?
09:43:43 <dcoutts> roconnor: not exactly
09:44:00 <banbh> roconnor: fair enough -- i haven't tried the other algorithms
09:44:04 <dcoutts> roconnor: or if it doesn't say then it goes by the name of the first part of the exposed modules
09:44:26 <roconnor> can a package be in more than one category?
09:44:55 <roconnor> banbh: I specificaly rewrite SHA1 to work are arbitarily long lists (or as long as SHA1 allows)
09:45:06 <roconnor> rewrote
09:45:26 <swidgy> i found Crypto painfully slow compared to hashing via libcrypt or just calling to the shell (shaXXXsum)
09:46:02 <roconnor> swidgy: that could be. :)
09:46:02 <dcoutts> mnislaih: great that you're hacking on #221 and #223, I'm around all evening if you have questions or want advice
09:46:28 <banbh> roconnor: would you recommend that?  essentially my needs are simply that i can generate a digest of largish files (say several MB) quickly
09:46:29 <swidgy> roconnor: yeah... not a big deal for one-off hashes, but hurts en mass
09:46:59 <banbh> roconnor: the md5 exploits are not really a concern for me
09:47:06 <roconnor> bahbh: well people should be using MD5 for any new applications.
09:47:10 <roconnor> er
09:47:12 <roconnor> shouldn't
09:47:14 <kolmodin> dcoutts: I've worked on #235
09:47:49 <dcoutts> kolmodin: excellent!
09:47:55 <roconnor> banbh: why are the exploits not a concern for you?
09:48:11 <kolmodin> dcoutts: and now I'd like to try it on this machine too, but I need to do a 'cabal update' first.
09:48:16 <kolmodin> dcoutts: but that only segfaults
09:48:19 <roconnor> banbh: it seems simpler to just use SHA1 instead.  No worries there (for now).
09:48:33 <kolmodin> and I don't really know how to debug it
09:48:43 <dcoutts> kolmodin: can you ltrace it? or get a gdb backtrace?
09:48:53 <banbh> roconnor: thanks.  so you would recommend Crypto 4.10?
09:48:57 <kolmodin> dcoutts: ltrace, sure
09:50:00 <roconnor> banbh: it depends on your requirements.  There is no bytestring SHA1 hash there yet, but I suppose it could be constructed.
09:50:06 <kolmodin> dcoutts: ltrace rather than strace?
09:50:39 <dcoutts> kolmodin: strace is system calls, ltrace seems to be able to trace C library function calls
09:50:43 <roconnor> banbh: Really my complaint is directed at the creator ofr pureMD5 more than the users of pureMD5.
09:50:49 <kolmodin> dcoutts: I've can send you what I've got so far
09:50:57 <dcoutts> kolmodin: sure
09:51:39 <skorpan> http://pastebin.com/d1b01c160 <- does anyone have any idea about what these errors mean?
09:51:44 <banbh> roconnor: is your complaint that the author is encouraging the use of md5 by providing the library?
09:52:02 <roconnor> yes
09:52:28 <roconnor> hmm, but now that you mention it, I suppose he could be providing it for compatability with old protocols.
09:52:52 <roconnor> I guess the only solution is for me to provide write SHA1 for bytestring.
09:53:37 <banbh> rconnor: i see;  regarding sha1 in (Crypto), i don't specifically need bytestrings, just the ability to read in and hash medium sized files (say several MB)
09:53:39 <smtms> roconnor, are you afraid someone might use MD5 in combination with SHA1 instead of SHA1 only in order to achieve greater security?
09:55:19 <roconnor> banbh: the version of SHA1 I wrote for crypto is lazy, so can consume arbitrarly long strings.  I make no claim about it being as fast as C implementations.
09:55:42 <roconnor> smtms: My concern is that someone will use pure MD5 in a new application.
09:56:05 <mornfall> How can SHA1 be lazy?
09:56:24 <mornfall> As in it won't compute the function as long as you don't look at the result? Or? ;)
09:56:44 <roconnor> mornfall: http://r6.ca/blog/20060707T184300Z.html
09:56:44 <lambdabot> Title: Lazy vs. Strict
09:58:36 <hpaste>  kolmodin pasted "cabal-install crash" at http://hpaste.org/6059
09:58:54 <kolmodin> dcoutts: ^^^
09:59:40 <kolmodin> skorpan: compile with --make too
09:59:44 <Cale> skorpan: They mean that you should use the --make :)
09:59:56 <Cale> option*
10:00:01 <kolmodin> skorpan: ghc --make BoardGame.hs
10:00:05 <shiram> do not use sha1 if you need security, these days it can be reversed in a 'resonable' amount of time
10:00:21 <kolmodin> skorpan: it's required to link in some packages that otherwise will be missing
10:00:22 <mornfall> roconnor: Ok. I'd probably call that property "streamy" or something.
10:00:30 <kolmodin> food! brb
10:00:36 <roconnor> mornfall: fair enough.
10:01:39 <skorpan> kolmodin: thanks
10:01:54 <roconnor> banbh: I just checked and SHA1 operates on 1 MB in a second or two.
10:02:18 <roconnor> Prelude Data.Digest.SHA1> hash (replicate 1000000 (toEnum (fromEnum 'a')))
10:02:18 <roconnor> Word160 883595068 3569670820 4129221419 3685558065 1697907055
10:02:18 <roconnor> (0.99 secs, 407534264 bytes)
10:02:40 <roconnor> Apparently SHA1 has been rewritten several times since I touched it.
10:02:52 <roconnor> so long as it is still streamy, I'm happy. :)
10:03:12 <banbh> roconnor: interesting.
10:03:39 <dcoutts> kolmodin: so it looks like something is freeing something and that segfaults
10:03:52 <dcoutts> kolmodin: if that is indeed the last call before the segfault
10:04:05 <roconnor> ``I find this a bit strange; to get the nice constant space results of lazy evaluation that I expect, I need to make it more strict.
10:05:26 <hpaste>  noecksit annotated "tree" with "(no title)" at http://hpaste.org/6057#a1
10:05:45 <noecksit> hello, i am having some problems with this code
10:06:00 <dcoutts> kolmodin: which is interesting because that freed address was indeed malloced previously
10:06:11 <noecksit> i cannot seem to make it into a subForest, even thought im almost there
10:06:17 <banbh> dcoutts: thanks.  i rebuilt binary and that solved the problem
10:06:50 <noecksit> makeSubForest returns a list of trees, to the main node
10:06:50 <dcoutts> banbh: great. As I say, the latest cabal will help with this problem by giving you a lot more info.
10:07:40 <noecksit> however, its just a list, and does not have the [] end statement, as in [Node a, Node b []]
10:09:36 <EvilTerran> sorry what
10:09:44 <EvilTerran> all non-infinite lists in haskell have a [] at the end
10:09:47 <EvilTerran> > 1 : 2 : 3 : []
10:09:52 <lambdabot>  [1,2,3]
10:10:18 <noecksit> no, thats not really what im trying to do, im using Data.Tree roseTree
10:10:57 <roconnor> banbh: Does that count as quickly for you? perhaps it is too slow.
10:13:27 <banbh> roconnor: I think I would need to do some more investigation to be sure.  It seems a little slow.  Essentially what I would like to be able to do is compute a checksum of lots of files as quickly as possible.  It does not need to be robust in the face of evil adversary.
10:13:58 <roconnor> banbh: if you want it to be fast, then you should use a checksum :)
10:14:20 <roconnor> CRC?
10:14:32 <banbh> roconnor: fair enough.  does haskell have a checksum function?
10:14:43 <roconnor> we must somewhere
10:14:52 <banbh> rconnor: perhaps a little more discriminating than CRC, though!
10:15:17 <roconnor> > 2^32
10:15:32 <lambdabot>  thread killed
10:15:48 <roconnor> lambdabot: what happened?
10:16:16 <EvilTerran> > 2^32
10:16:20 <lambdabot>  4294967296
10:16:21 <dino-> Maybe the Crypto package?
10:16:27 <dino-> For MD5 and SHA and things like that.
10:16:36 <roconnor> http://www.hcsw.org/haskell/crc32.hs
10:16:47 <dino-> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Crypto-4.1.0
10:16:55 <lambdabot> http://tinyurl.com/yomk9r
10:18:32 <banbh> roconnor: i didn't realize there were 32 bit CRCs (duh!), so yes I think I should try that.  thanks
10:18:58 <roconnor> banbh: I just google for haskell and CRC32
10:19:08 <roconnor> I don't know if that code is any good.
10:19:18 <roconnor> ... There really ought to be something in hackage.
10:19:48 <roconnor> banbh: you should add it, or write another one :)
10:20:35 <banbh> roconnor: you are right!  after all there are lots comments on the web on making this kind of algorithm go fast (including your post)
10:21:19 <banbh> roconnor: in case you are curious, i'm playing around with a (so far toy) build system that tries to do a "fixed point build"
10:21:29 <roconnor> :)
10:21:44 <banbh> roconnor: useful for compiling latex files (and a compilers)
10:21:45 <skorpan> how come hscurses messes my terminal up? it seems to be related to newlines in some way
10:22:15 <roconnor> I'm sure that if this CRC32 code is no good, then there is some project in Hackage with CRC code for the taking.
10:22:49 <roconnor> bahbh: you should read my article on the monad reader, about one pass algorithms ;)
10:23:31 <roconnor> banbh: although it is actually not really related to your project.
10:23:53 <roconnor> banbh: more like how to avoid writing programs like latex that require more than one pass.
10:24:56 <banbh> roconnor: i will read it, although i think i agree with you.  in this regard latex is very antiquated (to be polite)
10:25:52 <roconnor> banbh: of course we still have to deal with software like latex, so your fixed point compiler is still a good idea.
10:25:57 <banbh> roconnor: http://www.haskell.org/sitewiki/images/1/14/TMR-Issue6.pdf ?
10:26:00 <roconnor> er fixed point build.
10:26:51 <Heffalump> well, building stuff often involves finding a fixed point internally to the compiler, it's just that latex exposes that to the user
10:26:52 <roconnor> banbh: that's the one.  I quite like it.
10:27:19 <roconnor> banbh: I was so pleased to have a practical application of data recursion.
10:27:52 <banbh> roconnor: i saw it when it came out, made mental note to read it, and, well, didn't
10:27:58 <roconnor> ``
10:28:02 <roconnor> My very ï¬rst attempt at writing an assembler was awful. The tricky part of an
10:28:02 <roconnor> assembler is getting the jump instructions to jump to the right place. My ï¬rst
10:28:02 <roconnor> program output the encoded instructions, plus a table of labels and instruction
10:28:02 <roconnor> locations. Then I had to rerun my program to pass in the correct association list
10:28:02 <roconnor> between labels and instructions. Like TEX, it needed to be run more than once.
10:28:03 <roconnor> Certainly there is a better way than running a program twice.
10:28:44 <olsner> not so long ago, assemblers required you to maually specify the number of runs necessary to assemble your program
10:29:37 <roconnor> olsner: ugh.  I had no idea
10:29:44 <Saizan_> 2 passes aren't enough? some jumps can change the location of other code?
10:30:11 <olsner> some jump instructions do change size depending on the distance to the label; changing the distances between other labels etc :P
10:30:14 <banbh> i feel odd thinking that knuth was shortsighted with tex.  i assume resources were different when tex was designed and a streaming compiler was considered a requirement
10:30:27 <Heffalump> yeah
10:31:21 <Heffalump> I think the bigger mistake he made was to design a macro language. Proper abstraction is very hard.
10:32:30 <roconnor> olsner: I had to work hard to avoid that sort of thing.
10:32:54 <roconnor> banbh: actually I think I should have said LaTeX instead of TeX; although I'm not really sure who is at fault.
10:33:23 <roconnor> olsner: with complete freedom, there may not even be a fixed point.
10:34:20 <olsner> I think most require(d) you to specify the size of the jump instruction
10:34:32 <banbh> i'm pretty sure you can write a not-too-perverse latex program with no fixed point
10:35:08 <rey_> http://broken-latex.jottit.com/
10:35:08 <lambdabot> Title: Broken LaTeX: Home
10:35:21 <rey_> that's a (very perverse) example
10:37:50 <olsner> "perverse-latex" would have been a much funnier title :P
10:38:27 <roconnor> I made all my jumps long jumps to ensure I had a fixpoint. :(
10:38:29 <EvilTerran> kinky-latex? or is that going too far?
10:39:37 <MyCatVerbs> No, that's just about perfect, except for the tendency to trip naughty-content filters.
10:40:09 <Feuerbach> have you seen ant? ant is not TeX!
10:40:16 <MyCatVerbs> Mind, if you work for someone who actually uses such things, please do the human race a favour and leave to go somewhere where your employer actually respects you.
10:40:23 <MyCatVerbs> Feuerbach: ant is also a stupid name.
10:41:02 <monochrom> ant is an insect
10:41:09 <MyCatVerbs> Feuerbach: not that recursive acronyms are a problem, but FFS, surely they cannot possibly have failed to have heared of the Java build system? Nice name clash there, comrades.
10:41:42 <Feuerbach> MyCatVerbs: yeah, I know
10:42:13 <Feuerbach> and who cares about Java? :)
10:42:20 <MyCatVerbs> This is even dumber than the "plutoid" debacle.
10:42:31 <olsner> plutoid?
10:42:43 <lament> i know i'll start a company that makes cars! and i'll call it Porsche!
10:43:13 <MyCatVerbs> olsner: remember when the IAC decided to classify Pluto as "not a planet"?
10:43:38 <MyCatVerbs> olsner: so they needed a new classification for it. In a blazing display of no originality whatsoever, they picked the name "plutoid".
10:44:05 <olsner> oh... that's silly
10:44:14 <MyCatVerbs> olsner: also in a brilliant display of no concrete grasp on namespacing, they failed to check to see whether the new name conflicted with anyone else's vocabulary. Cue a whole pile of really pissed off geologists.
10:44:26 <newsham> yay, my monads are working now
10:44:36 <olsner> I thought they had revised the limit between asteroid and planet, and found that "oops, pluto isn't a planet with these definitions"
10:44:49 <olsner> rather than first decide !planet, then try to find a new classification
10:45:17 <MyCatVerbs> olsner: the most pissed-off group by far were, naturally enough, the people at the sharp end of the problem - people trying to work out what the geology of planets and hunks of rock *other* than the Earth.
10:45:30 <greendemon> Can debug.trace ever print output out of order, from the way it was executed?
10:45:35 <vardhan> quit
10:45:53 <newsham> greendemon: "the way it was executed" might be unexpected
10:46:03 <Deewiant> MyCatVerbs: "plutoid"? isn't it a "dwarf planet"?
10:46:19 <MyCatVerbs> greendemon: not without multithreading, but non-strict evaluation makes no particularly strong guarantees about what order things get evaluated in.
10:46:20 <newsham> deewiant: we prefer "little people planet"
10:46:25 <greendemon> Ok, but if I have: trace "functionA" (stuff)
10:46:25 <Deewiant> newsham: :-)
10:46:43 <greendemon> and my output is: functionA\n Segfault
10:46:48 <MyCatVerbs> Deewiant: dunno, did they change it? They definately did pick "plutoid" at first, though. I remember lots of whining about it on random corners of the internet.
10:46:57 <greendemon> that means the segfault is definitely in (stuff)?
10:47:24 <MyCatVerbs> greendemon: what the Hell are you doing to cause that!?
10:47:42 <greendemon> probably trying to evaluate an infinite list somewhere
10:47:44 <lament> whining about definitions is the root of all evil.
10:47:44 <MyCatVerbs> olsner: that sounds much more plausible than my version. :)
10:47:50 <greendemon> but I'm not sure
10:47:56 <greendemon> hence the debugging
10:48:23 <MyCatVerbs> greendemon: evaluating an infinite list shouldn't segfault, it should just hang.
10:48:30 <greendemon> oh
10:48:33 <Deewiant> MyCatVerbs: wikipedia says nothing of "plutoid" and claims it's been "dwarf planet" since 2006, which matches my memory of the events.
10:48:41 <greendemon> maybe too deep of a function stack then?
10:48:54 <Deewiant> I didn't follow it in too much detail though so it's entirely possible that it was "plutoid" at first.
10:48:54 <EvilTerran> that'd cause a stack overflow, not a segfault
10:49:06 <ska-fan> So Monads are a way of forcing sequentiality in a functional language?
10:49:10 <EvilTerran> segfaults should not happen in haskell code
10:49:21 <greendemon> Never?
10:49:28 <olsner> greendemon: Never!
10:49:29 <lament> I don't think plutoid was ever a word
10:49:32 <MyCatVerbs> greendemon: never. Your code runs in a managed environment.
10:49:39 <lament> 'plutoid' only returns 8K google hits
10:49:43 <olsner> stack overflow => "Error: Stack overflow"
10:49:45 <ska-fan> I once tried times 0 "a" and ghci crashed
10:49:56 <lament> and the hits don't seem related to pluto
10:50:07 <newsham> > 0 * "a"
10:50:10 <lambdabot>   add an instance declaration for (Num [Char])
10:50:12 <MyCatVerbs> olsner, lament, Deewiant: this is because I am an idiot and the term was actually "pluton".
10:50:18 <EvilTerran> ?hoogle times
10:50:19 <lambdabot> System.Time.diffClockTimes :: ClockTime -> ClockTime -> TimeDiff
10:50:30 <EvilTerran> ska-fan, what is "times"?
10:50:31 <lament> pluton already means something completely different
10:50:34 <MyCatVerbs> olsner, lament, Deewiant: which the historical record shows was mooted, objected to, then superceded.
10:50:51 <ska-fan> Ok, I'm lying. It was hugs.
10:51:00 <greendemon> Ok, well I'm just using GHC 6.6
10:51:06 <EvilTerran> but what is "times"?
10:51:07 <ska-fan> times 1 x = x
10:51:10 <EvilTerran> i see
10:51:12 <ska-fan> times n x = times (n-1) x ++ x
10:51:15 <greendemon> And it definitely says "Segmentation Fault"
10:51:22 <lament> MyCatVerbs: of course it was rejected, it's already a very common geological term
10:51:25 <EvilTerran> ska-fan, so... replicate, then?
10:51:32 <Deewiant> times (-1) x = problems
10:51:48 <EvilTerran> hm... or not. concat (replicate ...), i guess
10:52:00 <olsner> greendemon: try to find a reduced test case and hpaste it
10:52:05 <EvilTerran> ska-fan, that's not a segfault, tho, that'll be an infinite loop
10:52:06 <ska-fan> I don't know haskell really, I am playing with it, and was back then.
10:52:15 <ska-fan> EvilTerran: hugs segfaulted
10:52:16 <MyCatVerbs> lament: yeah, the funny thing is that when they raised that one, the excuse for why they hadn't avoided the clash was because they'd tried it in MSWord's spellcheck & got no result.
10:52:21 <EvilTerran> how peculiar
10:52:53 <greendemon> olsner: trying to find a reduced test case was the whole point of my Debug.trace statements
10:53:00 <greendemon> Hence the question
10:53:07 <greendemon> I'll keep looking though
10:53:15 <oerjan> http://en.wikipedia.org/wiki/Pluto_prototype
10:53:15 <lambdabot> Title: Pluto prototype - Wikipedia, the free encyclopedia
10:53:40 <ska-fan> Ok, so what about the notion that monads are a way of forcing sequentiality in a functional language?
10:53:47 <oerjan> ska-fan: hugs is not very stable these days
10:54:05 <olsner> monads are much more, but they are also that
10:54:11 <Cale> ska-fan: Conceptually, but they need not force the order of evaluation to be anything specific.
10:54:46 * ska-fan is reading about astronauts and space-stations now
10:55:06 <Cale> ska-fan: They're a way of describing computations which are in a certain sense "sequential", but that doesn't say anything about how those computations are really carried out.
10:55:23 <roconnor> monads sequence ``things'' but they do not often sequence evaluation.
10:55:30 <roconnor> yeah, what Cale said.
10:55:38 <ska-fan> Ok, to clear that up we would need a definition of sequential and agree on the environment in which we define it.
10:55:50 <Cale> Well, some examples should help...
10:56:00 <desegnis_> ska-fan, saying that monads are a way of forcing sequentiality is like saying that a television set is a way of watching âWho wants to be a millionaireâ
10:56:20 <ska-fan> ok
10:56:24 <ska-fan> where in reality it is what?
10:56:27 <olsner> hmm, I need a writer-like monad with an n-item history buffer that you can read... preferrably blazingly fast too :P
10:56:27 <monochrom> > do { x <- "ab"; y <- "01"; return [x,y] }
10:56:29 <Cale> > do { x <- [1,2,3]; y <- [1..x]; return (x,y) }
10:56:30 <lambdabot>  ["a0","a1","b0","b1"]
10:56:30 <lambdabot>  [(1,1),(2,1),(2,2),(3,1),(3,2),(3,3)]
10:56:49 <monochrom> lambdabot says I was first.  <duck>
10:57:03 <desegnis> ska-fan, a structure consisting of a type constructor, a function return, and a function (>>=)
10:57:19 <Cale> In these examples, the order of evaluation is nothing like the order in which the selections are made. It goes back and forth, backtracking to try different options.
10:57:29 <ska-fan> ok, I've read that a number of times already and didn't understand it :) Will read on for now :)
10:57:30 <roconnor> olsner: why only n?
10:58:13 <desegnis> ska-fan, it just means that a monad is a specific âinterfaceâ for the programmer
10:58:18 <Cale> ska-fan: If you'd like a broad philosophical overview about what monads mean for functional programming, I have a tutorial here: http://haskell.org/haskellwiki/Monads_as_computation
10:58:33 <oerjan> olsner: State (Seq something) perhaps?
10:58:57 <roconnor> olsner: so you want to read back or forward indexed by an offset from you current location in the monad?
10:59:05 <ska-fan> Cale: I'm going to read that on the train tomorrow, thanks
10:59:10 <monochrom> I agree that we need a clear definition of sequentiality.  I propose this: anything that satisfies return a >>= k  ==  k a, m >>= return  ==  m, and m >>= (\x -> k x >>= h)  ==  (m >>= k) >>= h  is sequential.
10:59:15 <Cale> ska-fan: If you know what a combinator library is already, I can summarise it in a somewhat glib fashion by saying that monads are simply a particular style of combinator library, and nothing more.
10:59:42 <Cale> monochrom: That'll work ;)
10:59:58 <monochrom> Name games are such much fun.
11:00:21 <oerjan> monochrom: your suggestion gives me such a warm fuzzy feeling
11:00:28 <roconnor> olsner: do you want to read back a certain number of characters, or a certain number of tells?
11:00:48 <olsner> it's more that I want to write loads of data in a stream, then be able to read back from the n last items (say, copy the last 3000 bytes and write them out again)
11:01:20 <roconnor> olsner: so you want to censor your output?
11:01:31 <roconnor> @hoogle censor
11:01:33 <lambdabot> Control.Monad.Writer.Class.censor :: MonadWriter w m => (w -> w) -> m a -> m a
11:01:38 <olsner> censor?
11:01:45 <roconnor> @hoogle pass
11:01:45 <lambdabot> Control.Monad.Writer.Class.pass :: MonadWriter w m => m (a, w -> w) -> m a
11:02:36 <roconnor> olsner: when you say you want to write them out again, do you want to overwrite the last 3000 bytes, or repeat the last 3000 bytes?
11:02:39 <oerjan> writer does not allow you to access the output of previous actions in later sequenced ones at all
11:02:49 <ddarius_> The easiest way to see that monads don't force sequentiality is to realize that the Identity monad is no different from no monad; it is no more "sequenced".
11:03:11 <olsner> roconnor: I want to repeat them (this is for my inflate implementation)
11:03:59 <monochrom> I was half pulling a pun, but half serious.  If you look at formal methods in the imperative world, and look for which axioms they use to formalize "sequential execution", which is clearly more important to them than to you, you will find that they use little more than associativity.
11:05:48 <olsner> the de/compression part of in/deflate is that you can repeat a run of characters starting up to 32768 bytes back
11:05:51 <roconnor> olsner: hmm, well, the most direct way of doing this is with state as oerjan said.
11:06:38 <ddarius> monochrom: Presumably it is non-commutative in general.
11:06:49 <olsner> hmm, yeah, probably best with a State thing
11:07:14 <roconnor> no other clever ideas imediately spring to mine, although I suspect there is some clever way to do this.
11:07:22 <oerjan> hm... you might be able to do better with some knot tying.  pass the writer result back in as State, and shift it as you write
11:08:18 <ska-fan> Are Monads implemented in Haskell? I.e. could I take a haskell implementation without monads and implement monads it it? Does that make any sense?
11:08:26 <monochrom> Yes.
11:08:35 <monochrom> I did it to OCaml.
11:08:42 <olsner> oerjan: hmm, yeah, that could work
11:08:42 <lament> poor ocaml!
11:09:47 <mrd> @src Monad
11:09:47 <lambdabot> class  Monad m  where
11:09:47 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
11:09:47 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
11:09:47 <lambdabot>     return      :: a -> m a
11:09:47 <lambdabot>     fail        :: String -> m a
11:10:41 <oerjan> olsner: it could be awkward to look at only the end of the history though
11:10:58 <oerjan> since you would need to drop things before it
11:13:21 <olsner> I was thinking that I'd keep a history field in my state, as well as a counter counting how much history I have, dropping when the history is too large.... but I will require a lazily evaluated output string rather than doing output=output++data for writing stuff
11:13:54 <olsner> perhaps writer+state, where the writer is the entire output, and the state has a reference to the writer output
11:13:56 <ddarius> ska-fan: The Monad class is just a type class like any other.  The IO monad is "built-in" and the only way of performing IO so you can't implement it in Haskell without it, but given another IO system such as the pre-monad ones, you could easily make an IO monad on top.
11:14:40 <ska-fan> ok
11:14:43 <monochrom> My supervisor wrote the article "do considered od"
11:14:54 <skorpan> is there any function which takes a String and concatenates it with itself X times, or do i have to write my own one?
11:15:28 <olsner> > concat . replicate 100 $ "Hello "
11:15:29 <lambdabot>  "Hello Hello Hello Hello Hello Hello Hello Hello Hello Hello Hello Hello Hel...
11:15:34 <skorpan> ah, replicate
11:15:41 <skorpan> replicate 10 $ "| "
11:15:47 <skorpan> no?
11:16:19 <oerjan> > [1..10] >> "Hello "
11:16:21 <lambdabot>  "Hello Hello Hello Hello Hello Hello Hello Hello Hello Hello "
11:16:30 <mrd> > replicate 10 "| "
11:16:31 <lambdabot>  ["| ","| ","| ","| ","| ","| ","| ","| ","| ","| "]
11:16:33 * oerjan grins
11:16:54 <monochrom> Damn monads.
11:16:57 <olsner> nice :D
11:17:11 <skorpan> thanks
11:17:24 <mrd> > concat (replicate 10 "| ")
11:17:24 <lambdabot>  "| | | | | | | | | | "
11:17:53 <mrd> > concat (intersperse "," ["a","b","c"])
11:17:53 <skorpan> replicate 10 '-'
11:17:53 <lambdabot>  "a,b,c"
11:18:03 <skorpan> > replicate 10 '-'
11:18:03 <lambdabot>  "----------"
11:18:06 <skorpan> cool
11:20:42 <shag> is there a library function for stripping leading and trailing whitespace from a string?
11:21:33 <Codex_> shag: use reverse and some trimming function that does leading spaces only.
11:21:52 <mrd> > dropWhile isSpace " a "
11:21:56 <lambdabot>  "a "
11:22:08 <ska-fan> yaht is still the best?
11:22:25 <mrd> > reverse . dropWhile isSpace . reverse $ dropWhile isSpace " a "
11:22:28 <lambdabot>  "a"
11:22:45 <shag> > reverse . dropWhile isSpace . reverse $ dropWhile isSpace " a b c "
11:22:48 <lambdabot>  "a b c"
11:22:52 <shag> very good
11:23:07 <shachaf> ska-fan: The best what?
11:23:14 <ehird> @karma lambdabot
11:23:14 <lambdabot> lambdabot has a karma of 0
11:23:22 <monochrom> Gentle Introduction is the best!
11:23:22 <ska-fan> resource on learning haskell without an active internet connection
11:23:47 <shachaf> ska-fan: I don't like it that much personally.
11:23:54 <monochrom> Then Bird's book is the best!
11:24:04 <ska-fan> haskell.org says gentle is not so gentle after all .. What would fit me was a concise text like dive into python for python
11:24:12 <newsham> i liked hutton's book.. i havent seen bird's
11:24:15 <shachaf> ska-fan: But I'm not sure about which alternatives are good.
11:24:21 <monochrom> I find gentle gentle.
11:24:51 <monochrom> gentle dives into haskell, if you like diving.
11:25:16 <lament> ska-fan: gentle is probably exactly that text
11:25:20 <monochrom> yaht just keeps on yachting and yachting and yachting...
11:25:28 <ehird> that was evil
11:25:28 <shachaf> Hutton's book is nice, but a bit short, I think.
11:25:29 <lament> it ain't gentle, but it's about as concise as it can be
11:25:36 <newsham> i should try reading gentle again, the first time it ripped right through my brain
11:25:46 <newsham> yah, hutton's book is too short
11:25:52 <roconnor> @hoggle listen
11:25:52 <lambdabot> Control.Monad.Writer.Class.listen :: MonadWriter w m => m a -> m (a, w)
11:25:53 <lambdabot> Control.Monad.Writer.Class.listens :: MonadWriter w m => (w -> b) -> m a -> m (a, b)
11:25:53 <lament> gentle like gangrape
11:26:19 <mrd> I read the Gentle Introduction, it reminded me of introductions to SML.  If you are familiar with other functional languages, it is good, I guess.
11:26:24 <ehird> @quote <lament> gentle like gangrape
11:26:24 <lambdabot> No quotes for this person. The more you drive -- the dumber you get.
11:26:32 <ehird> @remember <lament> gentle like gangrape
11:26:32 <lambdabot> Nice!
11:26:38 <monochrom> Please omit the < >
11:26:48 <monochrom> You may find @forget useful
11:26:49 <lament> PLEASE OMIT THE < >
11:26:51 <ehird> oh.
11:26:52 <ehird> ok. :P
11:26:59 <ehird> @forget <lament> gentle like gangrape
11:26:59 <lambdabot> No match.
11:27:02 <ehird> @forget gentle like gangrape
11:27:02 <lambdabot> No match.
11:27:08 <lament> @quote lament
11:27:08 <ehird> @forget lambdabot
11:27:08 <lambdabot> lament says: I'm running out of money and about to be evicted, what should i do? Use monads! My girlfriend dumped me, what should i do? Use applicative functors!
11:27:08 <lambdabot> Incorrect arguments to quote
11:27:10 <monochrom> Hrm.
11:27:28 <lament> i think lambdabot corrected it
11:27:34 * shachaf corrected it.
11:27:43 <monochrom> @quote lament gentle
11:27:43 <lambdabot> lament says: gentle like gangrape
11:27:49 <ehird> clever
11:27:53 <ehird> now, what about that evil
11:27:57 <monochrom> Thanks shachaf.
11:28:00 <lament> who needs automation when we have shachaf ?
11:28:07 <monochrom> and Cale
11:28:08 <roconnor> @type tell
11:28:09 <lambdabot> forall w (m :: * -> *). (MonadWriter w m) => w -> m ()
11:28:12 * shachaf is a bot, remember.
11:28:23 <lament> MonadWriter? That's Cale
11:28:33 <lispy> shachaf: botsnack
11:28:34 * monochrom votes for shachaf to be the next lambdabot
11:28:42 <ehird> @karma lambdabot
11:28:42 <lambdabot> lambdabot has a karma of 0
11:28:43 <shachaf> :-)
11:28:56 <monochrom> Then you will be trapped in the IO monad and cannot get out!
11:29:03 <lament> lambdabot++
11:29:27 <lispy> Help, I've been return'ed and can't get out!
11:29:41 * lament unsafePerforms lispy out
11:29:43 <shachaf> lispy: Try unsafePerformIO.
11:29:49 <ehird> lispy: The operation to get you out will not be safe.
11:29:56 <ehird> ahahahahhaha, we are all pathetic
11:30:08 <lament> yes. This is retarded. I quit.
11:30:35 <ehird> @type unsafeCoerce#
11:30:37 <lambdabot> Not in scope: `unsafeCoerce#'
11:30:49 <jleedev> how do you write coerce in terms of unsafePerformIO?
11:30:53 <jleedev> the docs mention it but don't say how
11:31:06 <skorpan> does anyone have any experience of hscurses here? i'm having trouble understanding its newline conventions
11:31:24 <lament> i have some
11:31:39 <skorpan> did you have trouble with newlines as well?
11:31:41 <lispy> skorpan: well, iirc lambdabot uses that library...maybe the lambdabot sources would help you?
11:31:48 <skorpan> @src hscurses
11:31:48 <lambdabot> Source not found. Take a stress pill and think things over.
11:32:00 <lispy> ?where hscurses
11:32:00 <lambdabot> http://www.informatik.uni-freiburg.de/~wehr/haskell/
11:32:01 <shachaf> lispy: lambdabot uses curses?
11:32:10 <lament> skorpan: no... i don't think so
11:32:14 <lispy> oh sorry. I'm confusing it with readline
11:32:16 <lispy> My bad.
11:32:30 <lament> i don't think i used newlines though
11:32:33 <ehird> jleedev: very easily
11:32:34 <ehird> like this:
11:32:53 <ehird> coerce a = let r = unsafePerformIO (newIORef undefined) in unsafePerformIO (do writeIORef r a; readIORef r)
11:33:00 <ehird> use like (well, don't):
11:33:04 <ehird> coerce (2 :: Int) :: String
11:33:12 <skorpan> for some reason i have to use "\r\n" instead of only "\n"
11:33:28 <skorpan> i'm not on a windows system.
11:33:33 <lispy> skorpan: oh, it's yi that uses curses
11:33:37 <newsham> "bird's" == bird/wadler?
11:33:40 <lament> skorpan: that's really odd.
11:33:44 <lispy> that's the one i should have said, not lambdabot
11:33:51 <lament> skorpan: or maybe not
11:34:10 <jleedev> ehird: why is r allowed to be polymorphic (IORef [a]) in this case but not when used properly?
11:34:14 <lament> skorpan: if you just use \n, does it begin on the same horizontal position aas the previous line?
11:34:27 <lament> i think that's normal
11:34:46 <skorpan> yes lament
11:34:59 <lament> so \n is linefeed, \r carriage return
11:35:03 <lament> just as it's supposed to be
11:35:11 <ehird> jleedev: its not [a]
11:35:14 <ehird> It's (IORef a)
11:35:18 <ehird> and because this:
11:35:36 <skorpan> lament: true, but i'm not used to seeing it on a unixish system
11:35:40 <sclv> jleedev: one of spj's papers talks about it. I forget if its directly on dynamics or on generics as a whole...
11:35:44 <ehird> Prelude Data.IORef> r <- newIORef undefined
11:35:44 <ehird> Prelude Data.IORef> writeIORef r (2 :: Int)
11:35:44 <ehird> <interactive>:1:14:
11:35:44 <ehird>     Couldn't match expected type `GHC.Prim.Any'
11:35:44 <ehird>            against inferred type `Int'
11:35:45 <oerjan> jleedev: do r <- newIORef undefined; whatever gets desugared to  newIORef undefined >>= \r -> whatever
11:36:04 <oerjan> it's monomorphic because it's a lambda parameter
11:36:04 <lament> skorpan: you could just take the control into your own hands and just put single-line strings at specified positions
11:36:12 <ehird> 'xactly
11:36:16 <skorpan> lament: also, i may not use putStrLn anymore, because of that silly \r\n think
11:36:16 <ehird> hmm
11:36:17 <skorpan> thing
11:36:18 <ehird> wait a minute..
11:36:34 <lament> skorpan: that's true, curses does not play with other output functions
11:36:43 <lament> skorpan: (anywhere, not just in haskell)
11:36:49 <jleedev> oerjan: that makes sense
11:37:00 <lament> skorpan: \r\n is how the terminal actually works.
11:37:16 <ska-fan> ok, gentle seems fitting. Now I'm looking for a kind of library reference in PDF format :)
11:37:30 <boy> i installed haskell-mode and gnu emacs, but am not getting any syntax highlighting. is there something obvious i'm forgetting to do?
11:37:33 <skorpan> lament: it's strange though, because the Curses.hs source uses putStrLn with no problems
11:37:41 <skorpan> perhaps they have redefined that functino
11:37:52 <skorpan> no, they haven't
11:38:18 <skorpan> on the other hand, they endWin before they putStrLn
11:38:24 <lament> heh :)
11:38:39 <xd> boy: try M-x global-font-lock-mode
11:39:05 <boy> woohoo :D
11:39:09 <boy> thanks a bunch :)
11:39:36 <skorpan> beware haskell-ind's indentation of then/else
11:39:46 <skorpan> if you use that minor mode
11:39:48 <ska-fan> Which editor is more popular in the haskell community?
11:39:56 <trez> skorpan: yo, what's up? :)
11:40:12 <boy> is simple-indent better?
11:40:15 <newsham> i heard vi is the one true editor
11:40:16 <skorpan> trez: doing the afp project :P i'm doing an embedded language for board games
11:40:17 <gnuvince_> ska-fan: I'd say Emacs and vim
11:40:18 <skorpan> how about you?
11:40:27 <ska-fan> gnuvince_: yeah, which of these two?
11:40:35 <ehird> emacs
11:40:40 <lament> vim
11:40:44 <lispy> yi!
11:40:44 <ska-fan> I see :)
11:40:49 <skorpan> ska-fan: doesn't matter which one is more popular, as there is only one true editor
11:40:51 <trez> skorpan: nice, haven't chosen any project yet.
11:40:58 <lispy> you also have the choice of eclipse-fp and visual haskell
11:41:16 <lispy> oh, and doesn't xcode support haskell?
11:41:21 <skorpan> trez: did you go to see stallman's lecture on free software?
11:41:46 <gnuvince_> ska-fan: who cares?  I use vim because I like it better, other people use Emacs because they like it better.  Use whichever editor you like better, even if that's nano.
11:41:50 <ehird> lispy: no way it doesn't
11:41:51 <trez> skorpan: nope, saw him earlier last year at draken, so that was enough :)
11:41:53 <ehird> well, about as much as textmate
11:42:01 <ehird> which can't indent at all and syntax highlights about 3 things
11:42:02 <ehird> :P
11:42:04 <newsham> "Functional programming with bananas, lenses, envelopes and barbed wire"  wow, what a title
11:42:05 <ehird> (if at all)
11:42:08 <skorpan> trez: yeah, so did i. it was the same speech this time.
11:42:12 <jleedev> @users
11:42:12 <lambdabot> Maximum users seen in #haskell: 463, currently: 446 (96.3%), active: 30 (6.7%)
11:42:17 <lispy> ehird: oh, maybe I was using an unofficial 3rd party plugin then
11:43:42 <ska-fan> gnuvince_: Well, I ask because if one of the two was significantly more popular than the other, there probably would be more scripts / plugins / whatever for the more popular one.
11:43:49 <lispy> did intercalate get accepted or was the name changed?
11:44:27 <gnuvince_> ska-fan: Emacs has a more complete Haskell mode, but that's more an Emacs thing than a popularity thing.
11:44:29 <olsner> @type intercalate
11:44:32 <lambdabot> forall a. [a] -> [[a]] -> [a]
11:44:45 <lispy> ska-fan: yeah, someone was working on a nice emacs mode, shim?  But, it required cabal the last time I looked at it, making it a bit of a show stopper for my usage.
11:45:01 <lament> cabal a showstopper?
11:45:20 <lispy> lament: yeah, cabal isn't general enough for some projects (like darcs)
11:45:48 <lament> lispy: you can still install it...
11:46:24 <lispy> lament: well, the problem is that your project must use cabal to use shim.
11:46:34 <lament> ohhh
11:46:34 <lispy> lament: at least, from the documentation I read, that's what I gathered.
11:46:39 <lament> i see
11:46:48 <lament> so the same thing that IDEs commonly do
11:46:57 <lament> take over the entire project management
11:47:51 <newsham> an IDE is about as useful as a hammer tuck taped to a band saw welded to a drill
11:47:56 <newsham> s/tuck/duck/
11:48:08 <swidgy> s/duck/duct/
11:48:17 <ska-fan> So is darcs like the most popular and most main-stream haskell program nowadays?
11:48:34 <Heffalump> probably
11:48:47 * oerjan was wondering what a hammer duck was there for a moment
11:48:47 <Heffalump> other contenders would be pugs and xmonad
11:49:01 <ska-fan> xmonad is not main-stream :)
11:49:14 <Heffalump> what makes you say that?
11:49:32 <ska-fan> only hard core geeks use tiling window managers
11:50:11 <ddarius> only programmers use darcs
11:50:23 <ska-fan> There are way more programmers than there are hard core geeks :)
11:50:23 <newsham> duct yes
11:50:34 <monochrom> only humans bicker
11:50:41 <newsham> do people use pugs?
11:50:43 <shachaf> GHC is as mainstream as most other Haskell programs. :-)
11:50:44 <lispy> monochrom: lol
11:50:51 <Heffalump> I think you have to be quite hardcore about version control to use darcs.
11:50:54 <oerjan> actually duck vs. duct is a completely legal variation i hear
11:51:07 <newsham> duct typing
11:51:15 <swidgy> heh
11:51:27 <ska-fan> Heffalump: yeah, maybe. although version control is in a state of flux at the moment. people are trying a lot of things.
11:51:31 <oerjan> clinging to your types, eh?
11:51:32 <lispy> Heffalump: I'd say that about distributed VCS in general, not just darcs
11:51:44 <swidgy> oerjan: there is Duck Tape branded duct tape
11:51:46 <monochrom> I am duct-taped to my types.
11:52:05 <ska-fan> distributed VCS are taking up in fact
11:52:09 <swidgy> oerjan: it's a highly complex issue ;)
11:52:13 <ska-fan> or taking on
11:52:19 <lament> and by distributed vcs, ska-fan means git.
11:52:34 <lispy> git :(
11:52:38 <oerjan> swidgy: ah yes, i think i read their faq on the issue (which is of course biased but still)
11:52:39 <swidgy> git :)
11:52:52 <lament> git ;=8
11:52:55 <quicksilver> bzr!
11:52:56 <quicksilver> hg!
11:53:02 <quicksilver> (there is more than just git and darcs)
11:53:10 <lament> bzr is the superawesome one?
11:53:19 <quicksilver> opinions vary. I like bzr.
11:53:28 <lament> oh, it's the python one
11:53:29 <olsner> wow, I seem to be tying the knot... it's mindboggling
11:53:32 <ska-fan> indeed, other than git, bzr and hg are very popular, too
11:53:41 <lispy> lament: I'm not sure, bzr used to always segfault on me when I tried looking at it.
11:53:54 <lament> stupid python programs always segfault.
11:54:04 <newsham> they do?
11:54:11 <ddarius> lament: Don't use stupid python programs then.
11:54:15 <ska-fan> is http://undergraduate.csse.uwa.edu.au/units/230.301/lectureNotes/tourofprelude.html the whole prelude?
11:54:17 <newsham> i've written lots of stpuid python programs
11:54:20 <newsham> and they dont segfault
11:54:22 <lament> newsham: no, they really aren't supposed to, ever :)
11:54:29 <lament> newsham: python is my favourite language
11:54:34 <oerjan> @where prelude
11:54:34 <lambdabot> http://www.haskell.org/onlinereport/standard-prelude.html
11:54:34 * lispy waits for lambdabot to shorten the url
11:54:38 <newsham> s/favourite/favorite/
11:54:40 <oerjan> ska-fan: ^^
11:54:45 <lament> bzr wiki page says it's "slower than git"
11:54:48 <quicksilver> lispy: that is a bit harsh, varying on FUD.
11:55:05 <quicksilver> lispy: I've used bzr for three years, I've introduced countless other people to it.
11:55:07 <ska-fan> ok :)
11:55:11 <quicksilver> not one of them has ever reported a segfault.
11:55:34 <lispy> quicksilver: Okay. YMMV.  But, when I tried bzr several years ago it would only segfault for me.  It really did scare me away.
11:56:19 <quicksilver> if it was "several years" ago, I wonder if that was bazaar.
11:56:34 <quicksilver> Different program. Written in C, IIRC, so more likely to segfult.
11:56:36 <monochrom> bizzare
11:56:49 <EvilTerran> *badum-chh*
11:57:14 <lispy> quicksilver: Probably.  I do think it was based on arch or something back then.
11:58:06 <roconnor> olsner: great!
11:58:23 * quicksilver is a bit frustrated by lack of documentation.
11:58:33 <quicksilver> Is there a nice example somewhere of SDL/OpenGL (in haskell?)
11:58:43 <olsner> output = execWriter $ runStateT (unInflate m) $ InflateState input output 0 0 0
11:58:55 <lispy> quicksilver: SDL?  Hmm....I have some HOpenGL examples, but I don't think they use SDL
11:59:07 <lispy> ?where nehe-tuts
11:59:07 <lambdabot> darcs get http://projects.codersbase.com/repos/nehe-tuts/
11:59:14 <lispy> quicksilver: ^^
11:59:27 <quicksilver> lispy: opengl on its own I'm good with.
11:59:30 <quicksilver> I've got the hang of that.
11:59:35 <quicksilver> But I want to load jpegs now.
11:59:43 <quicksilver> and I *think* the easiest way might be via SDL.
11:59:52 <quicksilver> Although I'm open to other suggestions :)
11:59:57 <lispy> There was someone around here doing some SDL w/OpenGL, iirc.  Who was that...
12:00:46 <quicksilver> I see old haskell-cafe postings
12:00:50 <quicksilver> which suggest it's actaully rather easy
12:00:55 <quicksilver> but I don't know how to start :)
12:01:04 <roconnor> olsner: what is your monad?
12:01:13 <lispy> oh, is Lemmih around?
12:01:17 <quicksilver> I don't see a single example program in the hsSDL dist.
12:01:25 <roconnor> olsner: oh, wait it is obvious from your run command.
12:01:29 <lispy> I think Lemmih helped me a fair bit when I was playing around with this stuff.
12:01:42 <quicksilver> lispy: yeah. I think Lemmih wrote the SDL binding :)
12:01:43 <roconnor> olsner: what are the semantics of the 0 0 0?
12:01:50 <conal> @seen Cale
12:01:50 <lambdabot> Cale is in #haskell-overflow, #haskell and #ghc. I last heard Cale speak 1h 2m 8s ago.
12:01:53 <quicksilver> lispy: if I can't find anything in another evening's searching, I'll just drop him an email.
12:02:08 <olsner> roconnor: currently written 0 bytes, the current byte is 0, and the number of bits left in the current byte is 0
12:02:45 <olsner> "currently written" = number of bytes written minus number of bytes dropped from the output log
12:02:49 <ska-fan> gentle says that a -> a is more general than [a] -> a
12:03:00 <lispy> ska-fan: right
12:03:06 <ska-fan> It says the same about [b] -> a and about a, both of which I understand
12:03:24 <ska-fan> I don't understand though how a -> a can be specialized to [a] -> a
12:03:32 <lispy> ska-fan: it can't
12:03:44 <lispy> > id :: [a] -> a
12:03:45 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
12:03:45 <lambdabot>     In the exp...
12:03:48 <roconnor> olsner: current byte is different from currently written bytes?
12:03:57 <olsner> (I should find a suitable abstraction for transforming bytestreams to bitstreams)
12:04:10 <conal> is there a way to get cabal to tell hscolour to add anchors for top-level defs (hscolour's -anchor option)?
12:04:11 <roconnor> olsner: use Data.Bitstream
12:04:19 <olsner> Oh.
12:04:26 <ska-fan> lispy: so if it can't be specialized, how can it be more general?
12:04:28 <roconnor> olsner: oh sorry, I was making that up
12:04:37 <olsner> that's mean!
12:04:43 <conal> i.e., during 'cabal haddock --hyperlink-source'
12:04:44 <roconnor> olsner: But I think Data.Binary does bit manipulation
12:05:17 <ska-fan> gentle specificially says that a -> a is a correct type for head
12:05:17 <lispy> ska-fan: a -> a, can be anything as long as your respect the a's stay the same.  But, [a] -> a, has the constraint the the input is a list.
12:05:23 <roconnor> olsner: crap, it doesn't.
12:05:34 <roconnor> I swear I've seen bit manipuation on bytestrings somewhere.
12:05:44 <quicksilver> lispy, ska-fan : I think it's a pretty funny sense of 'more general', TBH.
12:05:44 <ska-fan> lispy: exactly, and with head the first and the second a can never be the same
12:06:02 <ska-fan> So I don't see how a -> a can be a valid type for head
12:06:22 <lispy> ska-fan: url?
12:06:23 <skorpan> is there any "package manager" for hackage?
12:06:34 <lispy> skorpan: cabal install, I think?
12:06:40 <skorpan> okay
12:06:43 <Heffalump> i.e. no :-)
12:06:44 <quicksilver> lispy: http://www.haskell.org/tutorial/goodies.html
12:06:51 <lambdabot> Title: A Gentle Introduction to Haskell: Values and Types
12:06:52 <quicksilver> ska-fan: I think it's a mistake, frankly.
12:07:27 <quicksilver> ska-fan: I think it should probably read For example, the principal type of head is [a]->a; [b]->a, b->a, or even a are correct types
12:07:44 <ska-fan> quicksilver: I agree, that makes sense to me at least.
12:07:54 <lispy> ska-fan: I think the author meant a -> b, not a -> a
12:07:57 <roconnor> olsner: current byte is different from currently written bytes?
12:08:10 <ska-fan> ok, thanks for clearing that up ):
12:08:12 <ska-fan> :)
12:08:30 <newsham> hmm.. bird/wadler's book is available on amazon.com for $85 and new/used on amazon.co.uk for 3.34lb
12:08:38 <newsham> i knew the dollar was weak, but geeze
12:08:46 <olsner> roconnor: yeah, the byte-to-bit part takes one byte from the input list, stores it in "current byte" and shifts out one bit at a time
12:09:33 <lispy> newsham: yeah  it's a good time for european union companies to outsource to the US :)
12:09:39 <roconnor> oh, so these are current input btye and current output byte
12:10:02 <roconnor> olsner: what is the type of input?
12:10:10 <roconnor> olsner: and output.
12:10:22 <skorpan> "it is a member of package containers-0.1.0.1, which is hidden"
12:10:24 <skorpan> hidden!?
12:10:36 <olsner> [Word8] to [Word8]
12:10:50 <lispy> How is it that HM type system has unique principal types?
12:10:59 <lispy> Did they have to disallow certain things, and if so, what?
12:11:07 <roconnor> olsner: shouldn't the current byte just be the head of the list?
12:11:25 <quicksilver> lispy: I think it's a rather deep property.
12:11:38 <quicksilver> lispy: It's somehow related to curry-howard and intuitionistic logic.
12:11:39 <ddarius> lispy: ?  HM can obviously be extended in many many ways.
12:11:41 <newsham> hah, some of these books are selling for $150
12:12:07 <oerjan> skorpan: cabal hides every package not mentioned in the .cabal file
12:12:08 <newsham> will amazon.co.uk take american credit cards and shipping addrs?
12:12:17 <skorpan> oerjan: so how do i solve this?
12:12:39 <EvilTerran> @go abebooks
12:12:40 <lambdabot> http://www.abebooks.com/
12:12:40 <lambdabot> Title: AbeBooks: New & Used Books, Textbooks, Rare & Out of Print Books
12:12:48 <EvilTerran> newsham, have a shufty at that, maybe?
12:13:03 <newsham> eparse..
12:13:06 <newsham> ?all-dict shufty
12:13:09 <lambdabot> No match for "shufty".
12:13:30 <quicksilver> why is this : http://www.kroesen.net/ a mirror of haskellwiki?
12:13:32 <lambdabot> Title: Haskell - HaskellWiki
12:13:42 <lispy> newsham: http://www.urbandictionary.com/define.php?term=shufty
12:13:42 <lambdabot> Title: Urban Dictionary: shufty
12:13:45 <EvilTerran> newsham, "look"
12:14:02 <newsham> danke
12:14:20 <oerjan> skorpan: i am not sure, i only know this from channel conversation
12:14:24 <skorpan> oerjan: okay
12:14:30 <Cale> Hi conal
12:14:40 <skorpan> i feel bad when i download a package and it just won't install with default settings
12:14:44 <oerjan> maybe the package you are installing has not been updated for 6.8
12:15:14 <skorpan> it's vty
12:15:24 <skorpan> from the darcs repo
12:16:05 <newsham> hmm i think these cheap versions might be 1st ed
12:16:40 <newsham> textbooks are so pricey
12:16:42 <newsham> sucks to be a student
12:16:58 <skorpan> oops, it was an old vty version
12:17:01 <skorpan> works with the latest one
12:17:27 <oerjan> ah :)
12:19:24 <conal> Cale: i added monad composition to TypeCompose (darcs version), and i'd like your comments.  The new bit is at http://darcs.haskell.org/packages/TypeCompose/doc/html/Control-Compose.html#t%3ADistribM (see source link).
12:19:26 <lambdabot> http://tinyurl.com/22438u
12:19:34 <Cale> Cool :)
12:20:46 <Cale> http://en.wikipedia.org/wiki/Distributive_law_between_monads -- this lists the axioms required, but in CT notation.
12:21:29 <ehird> what BNF does Network.IRC use again?
12:21:36 <Cale> so, translating...
12:22:05 <smg> > let data Color = Red | Blue | Black | White | Yellow
12:22:05 <lambdabot>  Parse error at "data" (column 5)
12:22:10 <smg> > data Color = Red | Blue | Black | White | Yellow
12:22:11 <lambdabot>  Parse error at "data" (column 1)
12:22:15 <Cale> join . fmap distriM . distribM = distribM . fmap join
12:22:15 <smg> -.-
12:22:32 <conal> Cale: so l == distribM
12:22:36 <Cale> yeah
12:22:38 <EvilTerran> smg, lambdabot does expressions, and only expressions
12:22:47 <smg> ah okay
12:22:48 <EvilTerran> type declerations are not expressions
12:22:53 <ehird> aha
12:22:53 <ehird> IRC messages are parsed as: [ ':' prefix space ] command { space param } crlf
12:22:57 <Cale> fmap join . fmap distribM . distribM == distribM . join
12:23:04 <Cale> then...
12:23:32 <smg> it exists enumFrom and enumFromThen so it must also exists enumFromThenTo? i will try :]
12:23:39 <smg> > enumFromThenTo 1 10 100
12:23:44 <Cale> distribM . fmap return == return
12:23:44 <lambdabot>  [1,10,19,28,37,46,55,64,73,82,91,100]
12:23:49 <Cale> and
12:23:55 <smg> haha :]
12:24:01 <EvilTerran> ?src Enum
12:24:01 <lambdabot> class  Enum a   where
12:24:01 <lambdabot>     succ                     :: a -> a
12:24:01 <lambdabot>     pred                     :: a -> a
12:24:01 <lambdabot>     toEnum                   :: Int -> a
12:24:01 <lambdabot>     fromEnum                 :: a -> Int
12:24:03 <lambdabot> [3 @more lines]
12:24:04 <smg> > enumFromThenTo 1 11 100
12:24:05 <lambdabot>  [1,11,21,31,41,51,61,71,81,91]
12:24:06 <EvilTerran> @more
12:24:09 <Cale> distribM . return == fmap return
12:24:27 <Cale> That'll be it :)
12:24:29 <EvilTerran> @more?
12:24:42 <conal> Cale: thx
12:24:51 <lispy> the name, enumFromThenTo doesn't really evoke a lot of insight for me :)
12:24:59 <lispy> :t enumFromThenTo
12:25:01 <lambdabot> forall a. (Enum a) => a -> a -> a -> [a]
12:25:10 <Cale> conal: It might be interesting to know if these translate in any nice way into a set of conditions on bind.
12:25:19 <ski_> > enumFromThenTo 10 15 50
12:25:19 <lambdabot>  [10,15,20,25,30,35,40,45,50]
12:25:22 <dcoutts> > [1,3..9] == enumFromThenTo 1 3 9
12:25:22 <lambdabot>  True
12:25:30 <EvilTerran> lispy, it's mostly for the desugarer, so it doesn't really have to be fit for human consumption ;)
12:25:45 <conal> Cale: sure.  i'm going to walk through your translations and the diagrams and see if get the process.
12:26:03 <Cale> I'm not sure, but if there was anything written about it, I'm pretty sure I've seen a paper which was more CS-oriented regarding these distributive laws.
12:26:15 <Cale> I'll see if I can find it.
12:26:34 <lispy> > 1 `enumFromThenTo` 11 100
12:26:40 <lambdabot>   add an instance declaration for (Num (t -> t1))
12:26:46 <ski_> > (1 `enumFromThenTo` 11) 100
12:26:46 <lispy> > (1 `enumFromThenTo` 11) 100
12:26:47 <lambdabot>  [1,11,21,31,41,51,61,71,81,91]
12:26:47 <lambdabot>  [1,11,21,31,41,51,61,71,81,91]
12:26:57 <lispy> interesting
12:27:04 <oerjan> EvilTerran: i think the @more buffer got emptied by smg's intervening command
12:27:05 <conal> Cale: that'd be cool.  and if not, i can work with the diagrams.
12:27:16 <EvilTerran> bah
12:27:18 <lispy> Why doesn't the first way I typed that parse with the same precidence as the second way?
12:27:36 <EvilTerran> lispy, because function application is higher precedence than any infix operator
12:27:42 <Larose> if I have a function "foo :: Num a => Maybe a -> Maybe a". How do I call it with argument "1"  (foo 1) ?
12:27:44 <EvilTerran> and `enumFromThenTo` is an infix operator
12:27:48 <ski_> lispy : it was parsed as "1 `enumFromThenTo` (11 100)" because application binds tighter
12:28:05 <conal> Cale: do you know if anyone has explored replacing the monad transformer libraries with a type-composition approach?  it sure seems more modular.
12:28:08 <EvilTerran> Larose, foo (Just 1)?
12:28:09 <lispy> ski_: ah, (11 100), okay
12:28:55 <EvilTerran> ?src Maybe
12:28:56 <lambdabot> data Maybe a = Nothing | Just a
12:28:56 <smg> hehe oerjan :)
12:28:56 <Cale> conal: Well, there was a short article about it... Monad transformers are more general -- some of them arise from pre or post compositions, but some, like State, are something else altogether.
12:28:59 <Larose> EvilTerran: thanks! (sorry this was very noob)
12:29:07 <smg> ah cool i found out about showS accidently :)
12:29:11 <Cale> conal: It was on Reddit a while back.
12:29:39 <conal> Cale: glad to know.  if you run across the article, please let me know.
12:29:48 <Cale> okay, I'll have a look
12:29:56 <ska-fan> Is it by chance that SQL and Haskell share the comment leader?
12:30:01 <noecksit> how would i be able to create the opposite of a certain list to a known value
12:30:29 <noecksit> say i have [3,4,5], how would i be able to generate [0,1,2,6,7,8]?
12:30:30 <lispy> ska-fan: sorry? comment leader?
12:30:47 <ska-fan> --
12:30:53 <Deewiant> > [0..9] \\ [3,4,5]
12:30:53 <lambdabot>  [0,1,2,6,7,8,9]
12:30:54 <oerjan> >> [0..8] \\ [3,4,5]
12:30:57 <Cale> http://sneezy.cs.nott.ac.uk/fplunch/weblog/?p=84 -- ah, here it was
12:30:57 <lambdabot> Title: FP Lunch » Blog Archive » Monad Transformers
12:31:04 <oerjan> > [0..8] \\ [3,4,5]
12:31:05 <lambdabot>  [0,1,2,6,7,8]
12:31:26 <Cale> I'm not altogether certain about its claim for Cont, but the rest seems okay to me.
12:31:35 <noecksit> oh, ok thanx thats what i was looking for
12:31:35 <Deewiant> ska-fan: probably.
12:32:12 <Deewiant> but keep in mind that:
12:32:15 <Deewiant> > (3:[0..8]) \\ [3,4,5]
12:32:15 <lambdabot>  [0,1,2,3,6,7,8]
12:32:41 <noecksit> huh, is that in the prelude or some other module?
12:32:53 <smg> what?
12:32:55 <smg> \\ is prelude
12:33:00 <noecksit> oh, i think its in Data.List
12:33:06 <smg> it is?
12:33:07 <resiak> @pl \xs ys -> nub xs \\ nub ys
12:33:07 <lambdabot> (line 1, column 18):
12:33:07 <lambdabot> unexpected "\\"
12:33:07 <lambdabot> expecting variable, "(", operator or end of input
12:33:09 <ddarius> @index (\\)
12:33:09 <lambdabot> bzzt
12:33:13 <roconnor> @hoogle (\\)
12:33:14 <lambdabot> Did you mean: (\\)
12:33:14 <lambdabot> Prelude.undefined :: a
12:33:14 <lambdabot> Control.Monad.State.Class.get :: MonadState s m => m s
12:33:21 <smg> isn't \\ in Array?
12:33:22 <ddarius> @index (\\\\)
12:33:23 * resiak examines lambdabot.
12:33:23 <lambdabot> Data.IntMap, Data.IntSet, Data.List, Data.Map, Data.Set
12:33:26 <resiak> @pl \xs ys -> nub xs \\\\ nub ys
12:33:27 <lambdabot> (line 1, column 18):
12:33:27 <lambdabot> unexpected "\\"
12:33:27 <lambdabot> expecting variable, "(", operator or end of input
12:33:27 <conal> Cale: super.  thanks!  :)
12:33:38 <Cale> conal: I'll keep looking for that paper I was thinking of.
12:33:55 <noecksit> yeah, i meant (\\), and its not in my prelude, its in data.list however
12:34:04 <Cale> CiteSeer is annoyingly down.
12:34:22 <dolio> Yeah, it's been down for days.
12:34:31 <ddarius> "For each object A of C, !A is the co-free commutative comonoid co-generated by A."
12:34:44 <noecksit> its also in the List module
12:34:46 <ehird> @karma lambdabot
12:34:46 <lambdabot> lambdabot has a karma of 1
12:34:55 <smg> fromEnum is polymorphic so i need :: MyEnumerableData
12:34:58 <smg> is that true?
12:35:00 <conal> Cale: one thing i'd like to do is go back and simplify GUIs in Phooey.  i had a very lovely formulation via type composition, which i used for Functor & Applicative, but i didn't think i could use it for Monad.  i'll try again.
12:35:16 <smg> eh toEnum 0 :: MyEnumerableData
12:35:27 <ski_> ddarius : yes ?
12:35:27 <lispy> smg: sure
12:35:34 <smg> okay thank you lispy
12:35:49 <smg> your nickname is a neologism of lisp and py for python? :]
12:35:53 <lispy> ?type asTypeOf
12:36:03 <lambdabot> forall a. a -> a -> a
12:36:08 <lispy> smg: no python to see here :)
12:36:40 <smg> liesen: hehe
12:37:28 <Cale> conal: That would be interesting. The really nice thing about Applicative of course is that you don't have to add any extra information to say how things compose, but perhaps the appropriate distributive laws are available to make what you have into a monad :)
12:37:58 <conal> Cale: exactly!  i hadn't thought of that possibility until recently.
12:38:42 <Cale> http://web.cecs.pdx.edu/~mpj/pubs/composing.html -- ah, I think this might be it.
12:38:43 <lambdabot> Title: Composing Monads
12:39:26 <Cale> It's a little hard to find, given that it doesn't appear to refer to the distributive laws as such.
12:40:04 <conal> Cale: ooh -- i'd forgotten about that paper.  looks very applicable.  thanks again.
12:42:23 <smg> @src Ix
12:42:24 <lambdabot> class (Ord a) => Ix a where
12:42:24 <lambdabot>     range           :: (a,a) -> [a]
12:42:24 <lambdabot>     index           :: (a,a) -> a -> Int
12:42:24 <lambdabot>     inRange         :: (a,a) -> a -> Bool
12:42:24 <lambdabot>     rangeSize       :: (a,a) -> Int
12:42:35 <smg> so deriving Ord implies deriving Ix?
12:42:42 <smg> and not vice versa?
12:43:12 <ski_> vice versa
12:43:14 <Deewiant> if you want to have an Ix, it must be an Ord as well
12:44:03 <smg> okay
12:44:09 <smg> what does Ix stand for?
12:44:10 <smg> Index?
12:44:11 <ski_> instance Planet Ix
12:44:17 <Cale> smg: yeah
12:44:30 <smg> ah i like haskell it's intuitive :]
12:45:05 <Jaak> wait until you hear about monads :P
12:45:26 <oerjan> @quote paperwork
12:45:26 <lambdabot> tessier says: After the last newbies head exploded trying to read everything on that monad link there was a lot of paperwork. We'd like to avoid doing that again.
12:45:29 <Deewiant> I'd prefer Idx, Ix wasn't intuitive to me
12:45:43 <Jaak> @src Idx
12:45:43 <lambdabot> Source not found. Just what do you think you're doing Dave?
12:45:54 <smg> Jaak: why? i understand now nearly monads :)
12:46:03 <mattrepl> monads are sort of intuitive, it's the tutorials that are to blame
12:46:15 <smg> mattam: true
12:46:32 <ski_> mattrepl : always society, yes
12:46:35 <smg> i have read about >5 tutorials about monads, all had have it's weakness
12:46:38 <smg> hehe
12:46:46 <smg> i need to read about the mathematical definition of monads
12:46:58 <Deewiant> I've tried
12:47:03 <Deewiant> I decided to try again later
12:47:07 <Jaak> it's quite simple, really. once you know little category theory
12:47:43 <smg> yeah
12:48:03 <mattrepl> *nod* all the tutorials that I read (this was 1-2 years ago) were not helpful.  awkward squad paper is what helped the most.  aye, and getting familiar with CT
12:48:05 <ski_> a monad is an endofunctor with "unit" and "multiplication" natural transformations, satisfying unit and associativity laws
12:48:22 <Cale> Actually, if you can get as far as knowing what functors are about on your own, the YouTube videos by the Catsters are really good.
12:48:43 <smg> yes?
12:48:51 <smg> i will watch now all videos of it thank you Caelum
12:48:56 <smg> Cale was meant :\
12:48:58 <Deewiant> smg: your tab completion is borked
12:49:01 <Cale> http://uk.youtube.com/profile_play_list?user=TheCatsters
12:49:01 <lambdabot> Title: YouTube - TheCatsters's Playlists
12:49:11 <smg> Deewiant: yes
12:49:22 <Cale> Probably start with Natural transformations, and then Monads.
12:49:34 <smg> k
12:49:35 <Cale> and then Adjunctions :)
12:49:39 <Deewiant> Cale: cool, looks interesting
12:50:07 <smg> btw you like lhs?
12:50:11 <dolio> @djinn ((a -> r) -> b) -> a -> (b -> r)
12:50:11 <lambdabot> -- f cannot be realized.
12:50:16 <Cale> lhs?
12:50:22 <smg> literal haskell scripts or something
12:50:24 <dolio> @djinn (a -> (b -> r)) -> (a -> r) -> b
12:50:24 <lambdabot> -- f cannot be realized.
12:50:26 <Cale> oh, sure
12:50:30 <smg> Cale: with LaTeX and stuff
12:50:35 <ski_> dolio : why ?
12:50:45 <smg> ah okay :)
12:50:52 <Cale> They're nice for when you want to document things thoroughly :)
12:51:00 <smg> hehe yeah LaTeX ftw :]
12:51:35 <dolio> ski_: I've been thinking about the CPS monad lately. I've heard it's due to a self-adjoint functor, and (-> r) is the obvious one, but I don't see how that works.
12:52:16 <Cale> smg: You can also use the birdtrack style lhs in conjunction with other things, HTML is handy.
12:52:25 <oerjan> @src Cont
12:52:25 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
12:52:28 <ski_> dolio : ok .. hm
12:52:47 <roconnor> olsner: http://paste.lisp.org/display/36311 has an example to enforce that current output position is always the current output position.
12:52:51 <ddarius> dolio: (-> r) : C^op -> C
12:52:58 <smg> Cale: hehe i see, i will read about :]
12:53:03 <ddarius> The isomorphism defining the adjunction is flip
12:53:06 <ddarius> :t flip
12:53:10 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
12:53:12 <roconnor> olsner: scroll down to the "instance Monad Asm where"
12:53:34 <ski_> @djinn ((a -> r) -> b) -> (b -> r) -> a
12:53:34 <lambdabot> -- f cannot be realized.
12:53:44 <dolio> ddarius: Yeah. I guess it doesn't work in Haskell because the other category is Hask^op?
12:53:59 <ddarius> dolio: Doesn't work?
12:54:13 <ski_> dolio : you need to switch one of the arrows, to get both in `Hask'
12:54:31 <oerjan> dolio: the other category is nearly always something else, except for State i think
12:54:49 <dolio> oerjan: Yeah, I know.
12:55:25 <dolio> The adjunction for state is the only one defined in category-extras.
12:56:45 <ddarius> C(a,b->c) ~ C^op(a->c,b) ~ C(b,a->c)
12:57:15 <dolio> I tried defining Flip, too, which won't work for the category extras class, because it wants covariant functors.
12:57:19 <ddarius> Does it have a contravariant functor class?
12:57:22 <dolio> And Flip is a contravariant functor.
12:57:55 <ski_> category extras fix to `Hask' ?
12:58:29 <dolio> No, no contravariant functor class yet.
12:58:51 <dolio> Although I'm thinking of just gutting a fair amount of the functor stuff and having it depend on TypeCompose.
12:58:57 <dolio> Which I think does have a contravaraint functor class.
12:59:49 <Arnfreth> how do I install cabal-install after having fetched it with darcs?
13:00:31 <Arnfreth> I presume I'm supposed to run 'runhaskell setup.hs -configure, but there's no setup.hs in the root dir
13:00:57 <Arnfreth> and while there is a setup.hs in a dir called hackage, I get an error trying to run it with -configure
13:01:11 <dcoutts> Arnfreth: there is a Setup.lhs
13:01:32 <dcoutts> perhaps I should rename that to a Setup.hs
13:01:42 <roconnor> noo
13:02:12 <Arnfreth> there is yes, but when i try to run runhaskell Setup.lhs -configure i get an error too
13:02:23 <Arnfreth> runghc*
13:02:29 <doserj> configure, not -configure
13:02:54 <BMeph> Arnfreth: drop the dash, just type "runhaskell Setup.lhs configure"
13:02:58 <Arnfreth> "Setup.lhs: cabal-install.cabal:30: Invalid syntax (no colon after field name)"
13:03:16 <Arnfreth> when i use it without the dash
13:03:24 <doserj> ah, you need a newer cabal
13:03:30 <dcoutts> Arnfreth: looks like you're using a very old Cabal, you need the latest devel version of Cabal to build cabal-install
13:03:40 <allbery_b> that means old cabal version with new-style cabal file
13:04:01 <Arnfreth> I see... I'm a little new to this, but I though I got the newest version when I fetched it with darcs?
13:04:30 <dcoutts> Arnfreth: you need at least 1.2.x to be able to parse that .cabal file, but additionally the current development version of cabal-install needs the current development version of the Cabal lib
13:04:36 <dcoutts> @where cabal-install
13:04:37 <lambdabot> http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
13:04:44 <dcoutts> Arnfreth: see ^^
13:05:07 <dcoutts> it says "The current development version also requires the development version of the Cabal library http://darcs.haskell.org/cabal/."
13:05:08 <lambdabot> Title: Index of /cabal
13:05:50 <Arnfreth> I've been trying to follow it religiously so I actually installed the cabal library earlier
13:06:16 <dcoutts> Arnfreth: you can see what Cabal lib version you have, run ghc-pkg list Cabal
13:06:36 <dcoutts> hia conal, not sure what the problem with HsColour -anchor is, do you have any more details?
13:06:59 <Arnfreth> Cabal-1.1.3, Cabal-1.1.6.2
13:07:01 <Arnfreth> is the output
13:07:19 <dcoutts> Arnfreth: right, you need the current development version which is 1.3.6
13:07:23 <conal> dcoutts: thx.  i don't think i'm getting the anchors in my hscolour output.  so my top-level-links aren't working.
13:07:40 <Arnfreth> alright, do I fetch that with darcs?
13:07:47 <conal> dcoutts: does cabal pass -anchor to hscolour?
13:07:49 <dcoutts> conal: run with -v and see if Cabal is passing -anchor to HsColour, I think it should be.
13:07:57 <conal> dcoutts: will do.
13:07:59 <dcoutts> conal: looking at the code it certainly seems to
13:09:03 <conal> dcoutts: you're right.  it does.  hm.
13:09:05 <dcoutts> conal: HsColour doesn't use a very sophisticated lexer so it doesn't recognise everything, like instances iirc
13:09:51 <dcoutts> @where hscolour
13:09:51 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/hscolour/
13:09:52 <ttfh> is there a "Category Theory For Dummies"?
13:10:06 <b_jonas> lol
13:10:13 <dcoutts> conal: "HsColour is not yet able to add anchors to class methods, nor to foreign decls."
13:10:32 <dcoutts> conal: perhaps that's the problem? or are you getting no anchors at all?
13:10:35 <conal> dcoutts: my *class* links are broken
13:10:41 <BMeph> ttfh: Yes, there is - we refer to it as "Cale". ;)
13:11:15 <Arnfreth> dcoutts, I'll try to install the newest version of the cabal library. Thanks a lot for your help
13:11:22 <conal> dcoutts: oh, urg.  some work, some don't.
13:11:26 <dcoutts> conal: additionally it only uses a flat namespace so it cannot distinguish types from constructors like haddock can
13:11:32 <b_jonas> lol again
13:11:33 <ttfh> or to put it differently, is there a book on the subject I can buy and expect to understand?
13:11:56 <dolio> ddarius: I suppose I'm still a bit confused. For instance, leftAdjunct :: (Flip r a -> b) -> (a -> Flip r b), no? But that unwraps into '((a -> r) -> b) -> (a -> b -> r)', which you doesn't have a non-bottom definition (I think).
13:12:06 <Cale> ttfh: hmm... there's a few things I could point you to online.
13:12:39 <dcoutts> Arnfreth: np, let us know if you have any more problems. You could know that cabal-install is still beta quality and we hope early users like yourself will report any bugs you find in that trac I linked to a second ago.
13:12:45 <dcoutts> could/should
13:12:54 <Cale> ttfh: The trouble with learning pure category theory without having a rich mathematical background first is that you miss out on lots of the more interesting examples.
13:12:56 <mattrepl> ttfh: Pierce's "Basic Category Theory for Computer Scientists" seems to be working so far
13:13:07 <Cale> ttfh: But otherwise, the subject is reasonably learnable.
13:13:46 <dolio> ddarius: Or should there be more going on due to an additional step from Hask^op back to Hask?
13:13:47 <dcoutts> Cale: yeah, most of the examples I miss completely, I just don't have an intuition about examples using metric spaces etc
13:13:48 <b_jonas> my professor actually said that category theory isn't really deep
13:14:11 <paulp> if I have a file with many lines of integer data, is there a way to read that in haskell without being dragged through the IO monad? I can preprocess the file into valid haskell source so it's a list literal instead of raw numbers, but i was hoping for something cleaner.
13:14:21 <b_jonas> in that you shouldn't really expect lots of complicated new results you can only get by using category theory
13:14:24 <dcoutts> Cale: I really only get the set category and the category of types and functions
13:14:25 <Arnfreth> dcoutts, will do :)
13:14:34 <ddarius> dolio: Without having Hask^op, the adjuncts are going to look like (a -> Flip r b) -> (b -> Flip r a)
13:14:54 <Cale> dcoutts: Yeah, I think this recent interest by computer scientists has caught mathematicians completely off guard. Category theory is the game which is played with the other branches of mathematics as the pieces.
13:15:13 <ddarius> dcoutts: Have you looked at the Barr and Wells ESSLLI lecture notes?  That's all computer science.
13:15:26 <ttfh> Cale: Hmm, what's a rich mathematical background? I don't think I have one of those...
13:15:26 <dolio> ddarius: Okay, that makes sense.
13:15:28 <Cale> ttfh: http://www.math.uchicago.edu/~eugenia/catnotes/categorynotes-cheng.pdf -- these are some somewhat terse, but otherwise rather good notes.
13:15:29 <lambdabot> http://tinyurl.com/28sclm
13:15:45 <b_jonas> what's the relation of abstract algebra and category theory? are they the same?
13:15:52 <Cale> ttfh: Well, at least some group theory, ring theory, maybe some analysis
13:16:02 <SamB> b_jonas: no! for I understand abstract algrebra...
13:16:03 <dcoutts> ddarius: s'ok I was taught it on a course and just ignored the examples that were aimed at the mathematicians on the course
13:16:03 <opqdonut> b_jonas: category theory is more meta
13:16:32 <Cale> b_jonas: Abstract algebra studies some examples of categories, in more detail than would be reasonable to do with a purely categorical perspective.
13:16:46 <roconnor> damn.  According to wikipeida CRC-32 is slower than MD5.
13:16:54 <Cale> Specifically, the categories of groups, rings, and fields.
13:17:04 <b_jonas> no, that's not what I mean by abstract algebra
13:17:12 <b_jonas> groups and such are concrete
13:17:18 <SamB> roconnor: just stick one of them [citation needed] signs in there
13:17:27 <roconnor> http://www.cryptopp.com/benchmarks.html
13:17:28 <lambdabot> Title: Speed Comparison of Popular Crypto Algorithms
13:17:32 <Cale> b_jonas: Oh, you mean universal algebra?
13:18:15 <SamB> roconnor: well, that doesn't match what wikipedia said, does it?
13:18:35 <Cale> b_jonas: Universal algebra is all about sets with various n-ary operations on them. In essence, a direct generalisation of group and ring theory.
13:18:55 <roconnor> SamB: it matches qualitatively in that MD5 is listed as slightly faster than CRC32
13:18:56 <opqdonut> more akin to model theory right?
13:19:20 <Cale> Yeah, you could perhaps see it as a specialisation of model theory.
13:19:37 <SamB> roconnor: that's less than 1% difference
13:19:42 <SamB> that's practically the same speed
13:19:43 <opqdonut> though i guess universal algebra isn't really interested in the connection with logic
13:19:47 <Cale> Where you're dealing with structures that just have function symbols, but no relations other than equality to speak of.
13:20:07 <roconnor> SamB: yeah, but I was arguing that one should use CRC-32 instead of MD5 for checksums.
13:20:13 <ski_> dolio : `leftAdjunct :: Hask (Flip r a) b -> Opposite Hask a (Flip r b)' ?
13:20:17 <Cale> (but that's a bit of a funky way to look at it)
13:20:24 <opqdonut> mhmm
13:20:43 <SamB> roconnor: wouldn't it be better to look at the cryptographic properties as well?
13:20:44 <opqdonut> well you can pretty much look at any branch of mathematics as highly-specialized model theory
13:20:55 <Cale> right.
13:21:13 <b_jonas> yes, I mean universal algenra then
13:21:16 <roconnor> SamB: CRC-32 doesn't have cryptogrphic properties.  It has error detection properties.
13:21:21 <ski_> paulp : tried `interact' ?
13:21:44 <SamB> roconnor: well, what type environment were you proposing the use of CRC-32 in ?
13:21:45 <b_jonas> yes, it's sort of connected to logic and model theory
13:21:45 <roconnor> ah, the CRC runs faster on the pentum4
13:21:46 <paulp> hmmm, I may be unclear on interact
13:22:10 <Cale> There's probably a reasonably straightforward way to embed universal algebra in category theory (and perhaps even vice versa, for small categories), but the emphasis and philosophy is different.
13:22:14 <b_jonas> I don't know much about universal algebra, but I think some model theory results I've learnt could be categorised there
13:22:21 <SamB> roconnor: true
13:22:39 <SamB> about 50% faster
13:22:47 <ddarius> Cale: Universal algebra is more or less the initial algebra stuff
13:23:28 <roconnor> SamB: banbh wanted to use it for his make system.
13:23:48 <b_jonas> (I must say, even though I said group theory is are concrete
13:24:08 <dolio> ski_: I think it's the other way. leftAdjunct :: Hask^op (Flip r a) b -> Hask a (Flip r b)
13:24:27 <b_jonas> I meant that only in context. some of the advanced  group theory and representation theory and the stuff we had to learn seemed completely abstract to me and over my head)
13:24:30 <ski_> dolio : how is `Flip' defined ?
13:24:49 <roconnor> SamB: actually, now that I think about it, that probably means banbh wants a hash function rather than an error detection function.
13:24:51 <dolio> newtype Flip r a = F (a -> r)
13:25:17 <conal> In TypeCompose: newtype Flip (~>) b a = Flip { unFlip :: a ~> b }
13:25:33 <ski_> dolio : so, agreed
13:25:56 <ski_> oh
13:26:23 <dolio> Yeah, mine was specialized to functions.
13:26:28 <b_jonas> as for more concrete, I've heared two (unrelated) simple mathematics problems on the internets these days
13:27:11 <roconnor> @tell banbh I'm no longer certain that you want to use CRC-32, because you probably want a hash function rather than error detection.
13:27:11 <lambdabot> Consider it noted.
13:27:13 <b_jonas> one is this:
13:27:18 <Cale> b_jonas: Well, group theory is important for the reason that most of the structures studied by mathematicians turn out to be categories, and the isomorphisms from an object to itself, in any category, form a group, called the automorphism group of that object.
13:27:25 <banbh> roconnor: that's correct, i want a fast hash
13:27:25 <lambdabot> banbh: You have 1 new message. '/msg lambdabot @messages' to read it.
13:27:31 <ski_> (that `Flip' is btw roughly what i had in mind for `Opposite')
13:27:38 <b_jonas> Cale: yes, I know group theory is important
13:27:40 <Cale> b_jonas: (Which is a measure of its symmetries in some sense.)
13:27:48 <b_jonas> but I really meant _advanced_ group theory
13:27:57 <opqdonut> it's kind of a shame my uni isn't offering any category theory courses
13:27:58 <Cale> Just to give some idea of the abstract applicability of groups.
13:28:01 <b_jonas> not the group theory we learnt in the algebra courses
13:28:14 <Cale> b_jonas: How far did you get?
13:28:32 <b_jonas> I've no idea, I didn't understand it.
13:28:37 <Cale> b_jonas: oh, okay
13:28:47 <Cale> b_jonas: Did Sylow's theorems come up at all?
13:28:50 <b_jonas> It was something about representation theory
13:29:08 <b_jonas> Yes, Sylow's theorems did, I know those
13:29:14 <Cale> Well, representation theory is typically considered fairly advanced.
13:29:16 <dolio> ski_: Oh... leftAdjunct :: Flip (->) (Flip (->) r a -> b) -> (->) a (Flip (->) r b) ?
13:29:21 <dolio> ski_: Or something like that?
13:29:24 <Cale> (at least for the undergrad level)
13:29:32 <b_jonas> I forgot all of it after the exam
13:29:41 <dolio> Oops, I messed that up a little.
13:29:46 <b_jonas> even the parts I understood for the exam
13:29:51 <b_jonas> (that's normal)
13:30:13 <ski_> dolio : the latter
13:30:16 <Cale> I should really continue my study of representation theory. There is a place where it nicely intersects a bunch of combinatorics which I'm interested in.
13:30:24 <b_jonas> Anyway, first problem is combinatorics:
13:30:39 <b_jonas> Twenty-four bikers, 'A' to 'X', participate in matches.  In every match, exactly four bikers compete.  No two bikers may compete in more than one matches.  How many matches can you organize this way?
13:31:06 <dolio> ski_: Yeah, that might be definable.
13:31:12 <opqdonut> b_jonas: latin squares?
13:31:24 <b_jonas> opqdonut: no, not exactly
13:31:28 <b_jonas> but related
13:31:29 <Cale> So, how many set partitions of a set of size 24 into 6 sets of 4 elements?
13:31:36 <b_jonas> we don't know the answer for it
13:31:49 <b_jonas> the discussion is at http://www.perlmonks.com/?node_id=671445
13:31:51 <Cale> Do you know much about exponential generating series?
13:31:51 <lambdabot> Title: Unique Combos with Math::Combinatorics
13:31:55 <ski_> dolio : btw, why is this called `leftAdjunct' (with emphasis on `left') ?
13:32:05 <b_jonas> easy upper bound is 42, I found lower bound 38
13:32:28 <OceanSpray> http://en.wikipedia.org/wiki/Ray_tracing
13:32:28 <lambdabot> Title: Ray tracing - Wikipedia, the free encyclopedia
13:32:51 <OceanSpray> when they square a vector here, do they mean take the dot product of a vector and itself,
13:33:00 <OceanSpray> or multiplying the terms together?
13:33:02 <dolio> ski_: There's also rightAdjunct :: (a -> g b) -> (f a -> b). They're one of the definitions of adjoint functors.
13:33:04 <ddarius> OceanSpray: The former.
13:33:09 <OceanSpray> ah
13:33:39 <ddarius> OceanSpray: I highly recommend looking at geometric algebra at some point.
13:33:40 <ski_> dolio : yes, i know the operations .. i was just wondering about the choice of naming for them
13:33:59 <Cale> b_jonas: oh, wait
13:34:07 <OceanSpray> what do the double bars mean?
13:34:10 <Cale> b_jonas: You want to pick just *one* team of size 4?
13:34:15 <ddarius> OceanSpray: Magnitude.
13:34:23 <ddarius> I.e. sqrt(v^2)
13:34:28 <OceanSpray> then what's the single bars?
13:34:28 <Cale> b_jonas: I thought you wanted to split the 24 players into 6 teams.
13:34:39 <b_jonas> Cale: yep, one team
13:34:49 <Cale> oh, then that's easy, isn't it? (24;4)
13:34:50 <dolio> ski_: Ah. Well, I didn't pick the names, so I can't tell you the specific motivation.
13:34:55 <b_jonas> the answer for yours is easy I think
13:34:56 <Cale> The binomial coefficient.
13:35:04 <b_jonas> but no
13:35:08 <ski_> dolio : ok  (they just seem strange to me)
13:35:09 <b_jonas> we don't just want one
13:35:14 <Cale> okay
13:35:19 <ddarius> OceanSpray: A typo probably.  Both notations are used for magnitude.
13:35:24 <OceanSpray> huh
13:35:24 <Cale> You want 6?
13:35:33 <OceanSpray> that confused me a lot.
13:36:07 <ddarius> OceanSpray: Note that this notation is consistent with the absolute value notation.
13:36:16 <oerjan> > product[1..24]/product[1..4]^6
13:36:27 <swidgy> i think he wants all possible sets of six teams in such a way that pairs of players do not repeate between sets
13:36:28 <lambdabot>  3.24667053711e15
13:36:29 <OceanSpray> I know; absolute value means the distance to the origin.
13:36:38 <oerjan> > product[1..24]/product[1..4]^6 :: Rational
13:36:39 <lambdabot>  3246670537110000%1
13:36:45 <b_jonas> Cale: we want a set of sets \{a_0, ..., a_{n-1}\} so each a_i is subset of {0, .., 23}, each a_i has exactly four elements, and for each i/=j, a_i intersect a_j has at most two elements
13:36:47 <b_jonas> maximize n
13:36:53 <b_jonas> NO
13:36:54 <opqdonut> b_jonas: hmm, is that actully enumerating steiner systems?
13:36:59 <b_jonas> Cale: we want a set of sets \{a_0, ..., a_{n-1}\} so each a_i is subset of {0, .., 23}, each a_i has exactly four elements, and for each i/=j, a_i intersect a_j has at most one element
13:37:22 <opqdonut> hmm not steiner sets per se but definitely related
13:37:27 <Cale> oh, at most one element?
13:37:29 <opqdonut> yes, a hard combinatorial problem
13:37:31 <Cale> That's interesting.
13:37:42 <ski_> yes
13:38:06 <b_jonas> opqdonut: I think it's not exactly steiner system
13:38:16 <b_jonas> I don't know how hard it is, it may be hard
13:38:19 <opqdonut> yeah, not exactly
13:38:45 <ddarius> OceanSpray: Keep these links for the future http://staff.science.uva.nl/~leo/ga/ http://www.mrao.cam.ac.uk/~clifford/ http://modelingnts.la.asu.edu/
13:38:45 <roconnor> banbh: prehaps the term we are looking for is fingerpint http://en.wikipedia.org/wiki/Fingerprint_%28computing%29
13:38:47 <lambdabot> Title: Fingerprint (computing) - Wikipedia, the free encyclopedia
13:38:47 <lambdabot> Title: Geometric algebra (Clifford algebra)
13:38:53 <roconnor> ``Fingerprints are typically used to avoid the comparison and transmission of bulky data.
13:38:53 <facedown> earth
13:38:56 <facedown> fire wind water
13:38:56 <facedown> heart
13:38:58 <facedown> GO PLANET
13:39:00 <facedown> BY UR POWERS COMBINED
13:39:02 <facedown> I AM CAPTAIN PLANET
13:39:04 <facedown> CAPTAIN PLANET HES OUR HERO
13:39:07 <facedown> GONNA TAKE POLLUTION DOWN TO ZERO
13:39:08 <banbh> roconnor: yes
13:39:09 <facedown> HES OUR POWERS MANGIFIED
13:39:12 <facedown> AND HES FIGHTING ON THE PLANETS SIDE
13:39:16 <facedown> GONNA HELP HIM PUT ASUNER
13:39:20 <facedown> BAD GUYS WHO LIKE TO LOOT AND PLUNDER
13:39:22 <facedown> ULL PAY FOR THIS CAPTAIN PLANET
13:39:25 <opqdonut> what
13:39:26 <facedown> WE'RE THE PALANETEERS U CAN BE 1 2
13:39:27 <Syzygy-> ...
13:39:30 <facedown> CAUSE SAVING OUR PLANET IS THE THING TO DO
13:39:34 <facedown> LOOTING AND POLLITNG IS NOT THE WAY
13:39:37 <facedown> HERS WHAT CPATAIN PLNET
13:39:38 <facedown> HAS TO SAY
13:39:39 <facedown> THE POWER IS  YOURS
13:39:39 <Syzygy-> Any ops here?
13:39:40 <opqdonut> ops, plz
13:39:43 <facedown> k IM DONE
13:39:43 <facedown> SORRY
13:39:45 <facedown> ILL STOP
13:39:51 <OceanSpray> ddarius, thanks.
13:40:43 <roconnor> banbh: http://en.wikipedia.org/wiki/Rabin_fingerprint
13:40:55 <banbh> roconnor: in particular "Rabin's method is not secure against malicious attacks. An adversary agent can easily discover the key and use it to modify files without changing their fingerprint." is acceptable for my purposes
13:41:00 <Jim_Ross> Bah gawd, this room is just filled with intensity. The upcoming conversation is going to be one hell of a show!
13:41:09 <roconnor> banbh: it sounds fast
13:41:23 <Jim_Ross> Bah gawd, roconnor, that is one hell of a name you got yourself there.
13:41:35 <banbh> roconnor: so perhaps i have my homework now!
13:41:43 <Jim_Ross> Bah gawd, wish I had me some sort of edumucation and creatrivity like you, bah gawd.
13:41:54 <oerjan> @where ops
13:41:54 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
13:41:55 <roconnor> op
13:41:57 <Jim_Ross> BAH GAWD MY COCK IS SO HUGE
13:41:57 <Jim_Ross> BAH GAWD MY COCK IS SO HUGE
13:41:58 <Jim_Ross> BAH GAWD MY COCK IS SO HUGE
13:41:58 <Jim_Ross> BAH GAWD MY COCK IS SO HUGE
13:41:58 <Jim_Ross> BAH GAWD MY COCK IS SO HUGE
13:41:58 <Jim_Ross> BAH GAWD MY COCK IS SO HUGE
13:41:59 --- mode: ChanServ set +o dcoutts
13:42:00 <Jim_Ross> BAH GAWD MY COCK IS SO HUGE
13:42:00 * facedown does a stunner on roconner
13:42:01 <Jim_Ross> BAH GAWD MY COCK IS SO HUGE
13:42:03 --- kick: Jim_Ross was kicked by dcoutts (dcoutts)
13:42:06 --- mode: ChanServ set +o sorear
13:42:07 <facedown> crazy nut
13:42:17 --- kick: Jim_Ross was kicked by sorear (sorear)
13:42:24 <opqdonut> /kb already
13:42:27 <dcoutts> hmm, ban list full
13:42:30 <opqdonut> oh
13:42:35 <OceanSpray> remove someone from the bottom.
13:42:36 <b_jonas> delete some of it
13:42:44 <Jim_Ross> My lip is fucked up from licking sorear's mom's vagina. Bah gawd, ain't that the truff.
13:42:45 <Jim_Ross> My lip is fucked up from licking sorear's mom's vagina. Bah gawd, ain't that the truff.
13:42:45 <Jim_Ross> My lip is fucked up from licking sorear's mom's vagina. Bah gawd, ain't that the truff.
13:42:45 <Jim_Ross> My lip is fucked up from licking sorear's mom's vagina. Bah gawd, ain't that the truff.
13:42:47 <Jim_Ross> My lip is fucked up from licking sorear's mom's vagina. Bah gawd, ain't that the truff.
13:42:47 <smg> Jim_Ross?
13:42:48 --- mode: dcoutts set -b *!*@200.84.37.85
13:42:59 <smg> spam in #haskell? i never saw this before
13:43:09 <cjb> no, no, first we need to argue about what kind of priority queue properties the ban list should have :)
13:43:31 <idnar> smg: Spam? In /my/ IRC channel? It's more likely than you think.
13:43:33 <roconnor> cjb: LRB, least recently banned.
13:43:43 * Jim_Ross drops down from rafters.
13:43:45 --- mode: dcoutts set +b *!*@*.dsl.cavtel.net
13:43:45 --- kick: Jim_Ross was kicked by dcoutts (dcoutts)
13:43:55 <cjb> dcoutts: that might be an overly specific ban.
13:44:00 <opqdonut> wow, banning the whole cavtel
13:44:03 <dcoutts> hmm too wide
13:44:10 * dcoutts refines the ban
13:44:44 <b_jonas> I think you should delete some more bans so there's space for when we need it
13:44:47 --- mode: dcoutts set -b *!*@*.dsl.cavtel.net
13:44:58 <oerjan> my word exactly
13:45:01 <sorear> I think the entire country of Turkey is already banned, what's an ISP?
13:45:08 <b_jonas> lol
13:45:09 <opqdonut> sorear: :D
13:45:13 <b_jonas> what about china?
13:45:16 <oerjan> o_O
13:45:24 <DQuest> Probably don't need to ban them at this end, eh?
13:45:29 <wy> I'm rethinking about my parser. Do we need to distinguish types and identifiers in a parser?
13:45:29 <sorear> good point
13:45:38 --- mode: sorear set -o Soliah
13:45:43 --- mode: sorear set -o sorear
13:45:50 <opqdonut> wy: probably yes?
13:45:54 <b_jonas> my ISP (the most popular ISP of the country) was banned once in en.wikipedia for a week
13:45:59 * sorear slaps tabcomplete
13:46:00 <opqdonut> (i've missed any previous discussion on the topic)
13:46:09 <sorear> do I need to restore Soliah's op bit?
13:46:15 <wy> opqdonut: I'm doing that, but I found this a little ugly
13:46:28 <shachaf> sorear: Soliah isn't an op here, as far as I know.
13:46:33 <sorear> okay good
13:46:35 <opqdonut> wy: what are you parsing?
13:46:57 <b_jonas> why are there so many bans dated Jan 10 by douglas?
13:46:57 <wy> opqdonut: A practice language called IC, much like Java
13:47:08 <b_jonas> did he use some list of old bans or something?
13:47:41 <opqdonut> wy: so distinguishing between typenames and other identifiers is turning out hard?
13:47:46 <opqdonut> sounds odd
13:47:49 <ddarius> Girard has made his page a bit more colorful since last I was there.
13:48:02 <Heffalump> by "douglas"?
13:48:44 <Heffalump> I see a lot of bans all dating from the same time by ballard.freenode.net, which is probably due to net rejoins or the like.
13:48:56 <b_jonas> Heffalump: oh no, I misread it
13:48:56 --- mode: ChanServ set -o dcoutts
13:49:00 <b_jonas> not by douglas
13:49:03 <wy> opqdonut: No. not hard, but I found it not nice to distinguish them
13:49:26 <b_jonas> douglas is only the name of the server
13:49:37 <b_jonas> still, why so many bans on Jan 10
13:49:53 <b_jonas> what I mean to ask is, should those be considered the oldest?
13:50:05 <b_jonas> they all have the same time too
13:50:16 <opqdonut> wy: so you're saying something like "decl := identifier identifier" and handling everything during semantic analysis?
13:50:22 <wy> because the types don't say much about the name. I can't even get the super class names into the types
13:50:37 <Heffalump> they are all older than that date, but the information on when they actually date from is probably lost
13:50:41 <Heffalump> short of consulting logs
13:50:48 <wy> opqdonut: yes. I wonder if that would be better
13:51:22 --- mode: ChanServ set +o dcoutts
13:51:23 --- mode: dcoutts set +b Jim_Ross!*@*
13:51:28 --- mode: ChanServ set -o dcoutts
13:51:33 <dcoutts> does that seem correct?
13:51:36 <b_jonas> Heffalump: so should they remove all those bans?
13:51:47 <Heffalump> b_jonas: probably wouldn't hurt to do so
13:52:03 <wy> I think the reason I used so-called types is just to deal with some abnormalties, for examle there are something like new A[ ][ ][n] in the language
13:52:19 <Heffalump> timing out bans after a couple of months may well make sense. If people come back after that, we'll probably notice after a bit.
13:52:26 * Heffalump disappears
13:52:33 <b_jonas> Heffalump: yeah
13:52:52 <RayNbow> @hoogle Map
13:52:52 <lambdabot> Data.Map :: module
13:52:52 <lambdabot> Data.Map.Map :: data Map k a
13:52:52 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
13:52:52 <smg> idnar: :<
13:52:57 <b_jonas> if someone's so persistant to require a continuous ban, they'd be banned by freenode ops anyway
13:53:04 <wy> A[ ][ ][n] should be regarded as an array of A[ ][ ]. but this turned the language into LR(*)
13:53:43 <wy> oerjan: am I right about this?
13:54:18 <litb> hello all
13:54:22 <ski_> ddarius : anything more than the main page ?
13:55:05 <oerjan> wy: i don't see why
13:55:59 <banbh> roconnor: I just noticed http://www.haskell.org/pipermail/haskell/2007-October/019874.html
13:55:59 <lambdabot> Title: [Haskell] Fingerprints and hashing
13:56:30 <banbh> roconnor: so others (SPJ) have wanted fingerprints too
13:56:57 <wy> oerjan: I'm not sure. but the production for new is "expr ::= new type '[' expr ']'" and "type ::= int | boolean | string | id | type '[' ]'"
13:57:26 <wy> So if I have "new A[ ] [ ] [n]"
13:57:47 <wy> when I see the first '[', I don't know if I should reduce this to type
13:58:35 <oerjan> oh i thought you meant unbounded lookahead by *
13:59:03 <b_jonas> why?
13:59:05 <oerjan> shouldn't be more than LR(1) i think
13:59:29 <ddarius> ski_: ?
13:59:32 <wy> oerjan: It seems to be quite unbounded. since I used the lexer to grab all the [][][][] ... together and make a construct I called ArrayType to hold a name and a dimension of it
13:59:44 <ski_> ddarius : re Girard
13:59:57 <oerjan> wy: note that lookahead with LR is not the same as with LL
14:00:03 <smg> Cale: The Catsters! :)
14:00:08 <ddarius> ski_: Not that I saw.
14:00:17 <wy> oerjan: CUP reports no error, but when it parses, there are just weird parse errors
14:00:17 <oerjan> with LR, it's the lookahead you need after the _end_ of the whole structure
14:01:28 <wy> yes. that's after "type"
14:01:54 <wy> when I see '[', I don't know if the one after it is expr
14:02:12 <oerjan> indeed, which is not a problem with LR
14:02:31 <smg> i could not find an answer to that question: is hGetContents inefficient because it reads _all_ content into a string? or isn't it becaue of lazyness?
14:02:37 <smg> i couldn't figure out
14:02:45 <oerjan> smg: it's lazy
14:03:03 <wy> If it is expr, I'm finished with "type", but if it's not expr, I'm still inside a "type"
14:03:06 <oerjan> (except for the strict ByteString version)
14:03:23 <oerjan> oh, right
14:04:55 <wy> The problem is solved by using a lexer to get the types out... but I think the parser shouldn't know anything about type
14:04:58 <b_jonas> anyway, the other problem I read is a simple diophantian
14:05:01 <brehaut> quick question; is HoC (Haskell Objective C) still the best way to do cocoa  apps with haskell?
14:05:07 <b_jonas> this one we don't know a solution for either
14:05:10 <b_jonas> it's this:
14:05:28 <b_jonas> notice that 2^5 + 3^1 == 2^3 + 3^3
14:05:52 <OceanSpray> what's the default precedence of a newly created operator?
14:05:59 <oerjan> OceanSpray: infixl 9
14:06:01 <b_jonas> are there positive integers a, b, a', b' so that a /= a' but 3^a + 10^b == 3^a' + 10^b'
14:06:08 <b_jonas> ?
14:06:09 <OceanSpray> ok.
14:06:09 <wy> so I'm thinking about changing my identifiers to be able to attach a dimension, so A [ ] [ ] would be "Var("A",2)"
14:06:12 <lispy> ?check 2^5 + 3^1 == 2^3 + 3^3
14:06:18 <lambdabot>  OK, passed 500 tests.
14:06:33 <b_jonas> passed 500 tests? examined it carefully
14:06:37 <wy> normal identifiers are just with diension one...
14:06:54 <b_jonas> wy: I did something like that once
14:06:56 <wy> I used the dimensions only when I type check
14:07:07 <wy> b_jonas: really? how to you think?
14:07:16 <b_jonas> but it has the prolem that you can't subscript arbitary expressions, only variables
14:07:33 <b_jonas> which is not nice if you can return arrays
14:07:49 <b_jonas> luckily, this was a simple pascal-like thing so that was no problem
14:07:52 <wy> subscripts is another thing
14:07:56 <b_jonas> no arrays were ever returned
14:08:21 <b_jonas> wy: I mean, a variable reference like x was compiled as a special case of an indexing like x[1]
14:08:41 <b_jonas> and an indexing like x[2][5]
14:09:13 <b_jonas> similarly a variable assignment is treated as a special case of an array element assignment
14:09:34 <OceanSpray> :t filter
14:09:36 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
14:09:38 <wy> the problem of mine is that the language treat multi-dimensional arrays as arrays of lower dimensions. so I could have new A[ ] [ ] [n]
14:10:02 <b_jonas> what would the empty subscripts mean there/
14:10:04 <b_jonas> ?
14:10:22 <b_jonas> does it mean a column indexing with all elements in the first indices?
14:10:30 <wy> they mean A[][] is the type of array of array of A
14:10:48 <b_jonas> with unknown size?
14:11:10 <wy> so this new will create an array of array of array of A
14:11:19 <biouser> I have two lists (x,y,z,w) and (n,m,o,p) how can I check that at least 3 of the members are common?
14:11:32 <wy> that's terrible ;)
14:11:37 <biouser> order is not important
14:11:51 <b_jonas> biouser: are the lists sorted?
14:12:27 <OceanSpray> Prelude> sqrt (-1)
14:12:27 <OceanSpray> NaN
14:12:33 <OceanSpray> what's NaN?
14:12:34 <olsner> hmmmm... profiling says that ByteString.Lazy.putStr is allocating 300MB of memory trying to write 1MB
14:12:57 <biouser> not presently, they are just user inputs to a function that I want to return a bool == true or false, there are three common members
14:13:18 <dcoutts> olsner: probably because forcing the output forces lots of other stuff that was previously lazily suspended
14:13:36 <b_jonas> biouser: use the intersect function from Data.List I think
14:13:42 <dcoutts> olsner: I bet replacing putStr output with evaluate (length output) would do the same
14:13:55 <b_jonas> then use your favourite way to tell if the length is at least three
14:14:18 <olsner> that probably explains it
14:14:20 <b_jonas> though wait, it depends on how you count repetitions
14:14:58 <b_jonas> biouser: what would you want to do if some elements of one list are equal
14:14:59 <olsner> but it's just so damn hard to get anything to tell me where all this memory is going... it should be constant space!
14:15:07 <b_jonas> oh, and by the way, did you mean square brackets?
14:15:39 <biouser> type Hyper= (Int,Int,Int,Int)
14:15:49 <biouser> two of those are the arguments
14:15:58 <b_jonas> and do you want to only match the elements at the same positions in the two?
14:16:38 <biouser> just trying to check if there are three common elements between the two Hyper s
14:16:45 <b_jonas> like, what's the result for (0,1,2,3) and (1,2,3,4)?
14:16:50 <nominolo> > sqrt (-1 :: Complex)
14:16:52 <lambdabot>      `Complex' is not applied to enough type arguments
14:16:52 <lambdabot>     Expected kind `?',...
14:16:52 <biouser> true
14:17:07 <nominolo> > sqrt (-1 :: Complex Double)
14:17:09 <lambdabot>  -0.0 :+ 1.0
14:17:17 <b_jonas> what about (0,0,0,1) and (0,0,0,2)?
14:17:30 <wy> never mind. I've got it done dirty. there is too much to change even if the other way is better. the thing bothers me a little is that the symbol tables are built only after parsing, so I can only find the type of things from the symbol table, but the parser pretended that it knows the types, but actually they are no more than identifiers
14:17:30 <biouser> true
14:17:39 <b_jonas> and about (0,0,0,5) and (0,1,2,3)
14:17:55 <b_jonas> and the same two flipped
14:17:55 <biouser> zero is not actually allowed, but just b/c pf the narrow application I have in mind...
14:18:03 <b_jonas> uh, then
14:18:08 <biouser> flase
14:18:11 <b_jonas> (1,1,1,6) and (1,2,3,4)
14:18:15 <biouser> flase
14:18:16 <wy> so I think I should make all of them identifiers in parsing. That's neater
14:18:30 <biouser> duhr, false
14:18:39 <b_jonas> that's more difficult than
14:19:44 <b_jonas> make a list of the four elements, take the Data.List.(\\) of them, and check if it has at most one elements
14:19:47 <b_jonas> I think that should work
14:20:01 <b_jonas> though no, wait
14:20:06 <b_jonas> intersect might actually work
14:20:18 <b_jonas> > intersect [1,2,3,4] [1,1,1,5]
14:20:22 <lambdabot>  [1]
14:20:25 <b_jonas> > intersect [1,1,3,4] [1,1,1,5]
14:20:27 <lambdabot>  [1,1]
14:20:31 <b_jonas> > flip intersect [1,1,3,4] [1,1,1,5]
14:20:32 <lambdabot>  [1,1,1]
14:20:39 <b_jonas> hmm, then it doesn't
14:20:52 <nominolo> OceanSpray: Not A Number
14:20:56 <nominolo> > 1 / 0
14:20:57 <lambdabot>  Infinity
14:21:00 <biouser> maybe...
14:21:01 <nominolo> > 1.0 / 0
14:21:02 <lambdabot>  Infinity
14:21:05 <OceanSpray> ?
14:21:17 <nominolo> OceanSpray: NaN
14:21:26 <OceanSpray> > minimum [sqrt (-1), 1, 0]
14:21:27 <lambdabot>  0.0
14:21:32 <biouser> >length(intersect [1,2,3,0] [0,1,2,3])
14:21:36 <b_jonas> sue \\ then
14:21:41 <OceanSpray> > minimum [sqrt (-54) + 123, 1, 0]
14:21:41 <lambdabot>  0.0
14:21:48 <OceanSpray> > minimum [1, 0]
14:21:49 <lambdabot>  0
14:21:55 <b_jonas> I think that's not well defined
14:22:00 <nominolo> OceanSpray: NaN + anything = NaN
14:22:08 <b_jonas> minimum wants the types to be really Ord
14:22:26 <b_jonas> though maybe they use a cheating comparision for floats that's Ord
14:22:39 <b_jonas> > 1.0 < Nan
14:22:39 <lambdabot>   Not in scope: data constructor `Nan'
14:22:47 <b_jonas> > 1.0 < 0.0/0.0
14:22:47 <nominolo> OceanSpray: it's the IEEE version of undefined numbers
14:22:47 <lambdabot>  False
14:22:51 <b_jonas> > 1.0 > 0.0/0.0
14:22:52 <lambdabot>  False
14:22:56 <b_jonas> > 1.0 `compare` 0.0/0.0
14:22:57 <lambdabot>   add an instance declaration for (Fractional Ordering)
14:23:15 <b_jonas> > 1.0 < (0.0/0.0 :: Double)
14:23:16 <lambdabot>  False
14:23:28 <SamB> > 1.0 `compare` (0.0/0.0)
14:23:28 <lambdabot>  GT
14:23:36 <b_jonas> > 1.0 `compare` (0.0/0.0 :: Double)
14:23:36 <lambdabot>  GT
14:23:40 <b_jonas> > 1.0 < (0.0/0.0 :: Double)
14:23:41 <lambdabot>  False
14:23:54 <biouser> intersect is not in Prelude?
14:23:59 <smg> no
14:24:03 <b_jonas> > (0.0/0.0 :: Double) `compare` 1.0
14:24:04 <lambdabot>  GT
14:24:06 <biouser> can I import from ghci?
14:24:12 <biouser> into that is
14:24:15 <b_jonas> there, so it's indeed not Ord
14:24:24 <b_jonas> Data.List
14:24:26 <smg> you can but you need to find out where it is
14:24:30 <b_jonas> but as I've said, intersect won't work
14:24:44 <b_jonas> use (\\) instead which I _think_ will work, but I'm not sure
14:25:06 <smg> what's intersect? list1 AND list2 ?
14:25:06 <biouser> can you give an example?
14:25:46 <biouser> of (\\)
14:26:38 <oerjan> > [0/0] \\ [0/0]
14:26:39 <lambdabot>  [NaN]
14:26:47 * oerjan cackles evilly
14:27:33 <astrolabe> @type (\\)
14:27:35 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
14:27:36 <biouser> > length(intersect [1,2,3,0] [0,1,2,3])
14:27:37 <lambdabot>  4
14:27:37 <ddarius> Down with reflexivity!
14:27:46 <smg> \\ isn't that the array index operator?
14:27:52 <ddarius> smg: No
14:27:56 <smg> ah it was //
14:28:12 <oerjan> :t (//)
14:28:13 <lambdabot> forall i e. (Ix i) => Array i e -> [(i, e)] -> Array i e
14:28:16 <b_jonas> no, the array index is !!
14:28:18 <oerjan> that's update
14:28:20 <b_jonas> um no
14:28:25 <smg> b_jonas: that's list index
14:28:31 <oerjan> :t (!)
14:28:32 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
14:28:36 <smg> :t (!!)
14:28:37 <b_jonas> array index is ! , list index is !! , array update is //
14:28:37 <lambdabot> forall a. [a] -> Int -> a
14:28:47 <smg> ah damn you confuse me
14:28:58 <smg> array index: ! list index: !! array update: //
14:29:04 <OceanSpray> > minimum [sqrt (-1), sqrt (-2)]
14:29:05 <lambdabot>  NaN
14:29:06 <smg> :t (\\)
14:29:07 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
14:29:08 <b_jonas> yep
14:29:13 <smg> what does \\ ?
14:29:23 <b_jonas> delete multiple elements
14:29:31 <smg> ah cool
14:29:33 <biouser> > [1,2,3,0] \\ [0,1,2,3]
14:29:34 <lambdabot>  []
14:29:35 <smg> something like unique?
14:29:42 <oerjan> no that's nub
14:29:48 <b_jonas> > [1, 1, 1, 1, 2, 2] \\ [2, 1, 1]
14:29:48 <lambdabot>  [1,1,2]
14:29:54 <OceanSpray> how do I tell whether something is NaN?
14:30:02 <oerjan> :t isNaN
14:30:04 <lambdabot> forall a. (RealFloat a) => a -> Bool
14:30:06 <OceanSpray> oh
14:30:07 <OceanSpray> thanks
14:30:17 <b_jonas> > delete 3 [1, 5, 3, 2, 3, 9] -- deletes the first occurrence of an element
14:30:19 <lambdabot>  [1,5,2,3,9]
14:30:31 <b_jonas> \\ is the same but does multiple deletes at once
14:30:35 <smg> nice
14:30:37 <andyjgill> Afternoon room!
14:30:44 <b_jonas> which is why
14:30:57 <b_jonas> > [1, 3] \\ [1, 4]
14:30:58 <lambdabot>  [3]
14:31:18 <b_jonas> elements that don't occurr in the original list don't change it
14:31:23 <OceanSpray> > [1] ++ [] ++ [2]
14:31:24 <lambdabot>  [1,2]
14:31:26 <byorgey> hi andyjgill!
14:31:36 <b_jonas> for sets it's set difference, which is where it gets the name
14:31:41 <andyjgill> hi byorgey
14:31:50 <OceanSpray> > concat [[1], [2], []]
14:31:51 <lambdabot>  [1,2]
14:31:58 <OceanSpray> > concat [1, 2, []]
14:31:58 <lambdabot>   add an instance declaration for (Num [a])
14:32:07 <OceanSpray> > concat [1, 2]
14:32:07 <lambdabot>   add an instance declaration for (Num [a])
14:32:12 <OceanSpray> ah, I see.
14:32:31 <jleedev> > [1,2] >>= show
14:32:32 <lambdabot>  "12"
14:32:42 <smg> jleedev: interesting
14:32:50 <jleedev> smg: very
14:33:00 <jleedev> > concat (map show [1,2])
14:33:00 <lambdabot>  "12"
14:33:13 <smg> > "foo" >>= show
14:33:14 <lambdabot>  "'f''o''o'"
14:33:19 <resiak> oh, because [a] uses the magic showList thing
14:33:20 <gnuvince_> > concatMap show [1,2]
14:33:21 <lambdabot>  "12"
14:33:28 <smg> > 10, "foo" >>= shows
14:33:28 <resiak> or rather, Char does
14:33:28 <lambdabot>   parse error on input `,'
14:33:41 <ToXedVirus> > [1,2] ++ [3,4]
14:33:41 <lambdabot>  [1,2,3,4]
14:33:50 <ToXedVirus> kewl lambdabot
14:34:47 <smg> > shows 10 "foo"
14:34:50 <lambdabot>  "10foo"
14:35:05 <smg> > 10 "foo" >>= shows
14:35:06 <lambdabot>        add an instance declaration for (Num ([Char] -> String -> a))
14:35:15 <smg> > 10 "foo" >>= shows :: String
14:35:16 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `ShowS'
14:35:55 <oerjan> > fix (join shows)
14:35:55 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
14:36:03 <boy> i'm using haskell-mode in gnu emacs. is there a way to pull up hoogle-type context-sensitive help like how emacs+slime can with the CLHS?
14:36:19 <smg> oerjan: wtf?
14:36:31 <b_jonas> is that like fix show?
14:36:32 <b_jonas> > fix show
14:36:33 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
14:36:41 <smg> someone explain that magic? :]
14:36:44 <b_jonas> same apparently
14:36:46 <smg> @type fix
14:36:47 <lambdabot> forall a. (a -> a) -> a
14:37:00 <jleedev> > join shows "foo"
14:37:01 <lambdabot>  "\"foo\"foo"
14:37:15 <resiak> :t join shows
14:37:16 <lambdabot> String -> String
14:37:38 <oerjan> that join shows is just deception, since it never gets beyond the first copy
14:37:42 <biouser> intersect will work just missing some of the basic mechanics of function definition
14:37:55 <b_jonas> @src join
14:37:55 <lambdabot> join x =  x >>= id
14:38:15 <oerjan> (r ->) monad
14:38:54 <resiak> i'm having trouble seeing what x >>= id means in ((->) r)
14:39:07 <b_jonas> let's see it from the defns
14:39:12 <ddarius> :t join
14:39:13 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
14:39:14 <b_jonas> @src (->) >>=
14:39:14 <lambdabot> Source not found. Wrong!  You cheating scum!
14:39:18 <b_jonas> @src (->) (>>=)
14:39:18 <lambdabot> f >>= k = \ r -> k (f r) r
14:39:21 <b_jonas> there
14:39:23 <oerjan> smg: when showing a String, the result always starts with ", even without looking at the string.  that's enough to get fix going
14:39:29 <ddarius> @djinn (r -> r -> a) -> r -> a
14:39:29 <lambdabot> f a b = a b b
14:39:43 <oerjan> > iterate show ""
14:39:44 <lambdabot>  ["","\"\"","\"\\\"\\\"\"","\"\\\"\\\\\\\"\\\\\\\"\\\"\"","\"\\\"\\\\\\\"\\\\...
14:40:09 <resiak> oh, of course
14:40:09 <jleedev> @djinn (r -> a) -> (a -> r -> b) -> (r -> b)
14:40:09 <lambdabot> f a b c = b (a c) c
14:40:17 <b_jonas> so (join shows y) is ((shows >>= id) y) which is (id (shows y) y) which is (shows y y)
14:40:17 <smg> interesting
14:40:20 <b_jonas> makes sense, yes
14:40:30 <b_jonas> @pl \f x -> f x x
14:40:30 <lambdabot> join
14:40:33 <smg> i like it that haskell has so much stuff in the Prelude that is nice
14:40:46 <pa-ching> If I'm writing an instance function :: IO SomeType, is there any way to get access to an IORef from there? Can't change the definition to curry one in, so what alternatives might I have...?
14:42:14 <b_jonas> smg: fix and join aren't in the prelude
14:42:27 <oerjan> @go site:haskell.org global state
14:42:27 <lambdabot> No Result Found.
14:42:57 <oerjan> http://www.haskell.org/haskellwiki/Top_level_mutable_state
14:42:59 <lambdabot> Title: Top level mutable state - HaskellWiki
14:43:28 <smg> b_jonas: yeah i mean in general
14:43:49 <b_jonas> smg: yep, it's true in general
14:44:03 <b_jonas> I like that, but I even more like how good the libraries are
14:44:06 <pa-ching> oerjan: Thanks, yeah, the situation certainly isn't ideal...
14:44:33 <smg> > let (!) x = product [1..x] in ! 10
14:44:33 <lambdabot>  Parse error at "!" (column 31)
14:44:36 <smg> > let (!) x = product [1..x] in 10
14:44:36 <lambdabot>  10
14:44:38 <smg> > let (!) x = product [1..x] in 10 !
14:44:38 <lambdabot>  Parse error at end of input
14:44:46 <smg> -.-
14:45:02 <oerjan> > let (!) x = product [1..x] in (10 !)
14:45:02 <lambdabot>  3628800
14:45:20 <smg> oh my try wasn't that bad :]
14:45:36 <oerjan> technically it's a section, so requires parentheses (and a ghc extension not to be binary)
14:45:47 <jleedev> > let (x!) = product [1..x] in (10!)
14:45:47 <lambdabot>  Parse error in pattern at "in" (column 27)
14:45:59 <jleedev> > let (x!_) = product [1..x] in (10!)
14:45:59 <lambdabot>  Parse error in pattern at "in" (column 28)
14:46:04 <smg> > (\x -> product [1..x]) 10
14:46:04 <lambdabot>  3628800
14:46:14 <oerjan> jleedev: and you cannot do it in the defining part
14:46:31 <explisixjelly> ok, here's the thing
14:47:17 <smg> consider myadd x y = x + y i reduce to myadd = (+)
14:47:22 <smg> is that eta-reduction or a section?
14:47:36 <explisixjelly> inside a monad, I want to apply a function which returns Bool to all elements of a list. and I want to know if any application returned false
14:47:48 <explisixjelly> I can do that easily with and and mapM
14:47:58 <byorgey> smg: that's eta-reduction, and the fact that you can make infix operators into prefix functions with parentheses
14:48:10 <explisixjelly> but what if I want to stop at the first failed function?
14:48:23 <b_jonas> explisixjelly: lazyness does that
14:48:35 <oerjan> b_jonas: no!
14:48:36 <ddarius> b_jonas: Not for a monadic computation
14:48:49 <smg> byorgey: k and (x+) would be a section?
14:48:49 <biouser> intersect [5,2,2,2] [1,2,5,0]
14:48:49 <b_jonas> oh, mapM
14:48:51 <ddarius> :t foldM
14:48:52 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
14:48:53 <b_jonas> sorry
14:48:54 <biouser> > intersect [5,2,2,2] [1,2,5,0]
14:48:54 <lambdabot>  [5,2,2,2]
14:48:59 <oerjan> explisixjelly: you'll have to write your own version i'm afraid
14:48:59 <b_jonas> then it might or might not do that, yes
14:49:04 <byorgey> smg: right
14:49:14 <explisixjelly> oerjan, so there is no andM?
14:49:19 <smg> ah good eta-reduction is about functions then
14:49:19 <biouser> I see why it doesn't work, I only want [5,2] returned there
14:49:20 <b_jonas> didn't notice the mapM
14:49:24 <explisixjelly> because andM would be exactly what I need %)
14:49:38 <biouser> you were right b_jonas
14:50:34 <byorgey> smg: right, eta-reduction is a more general concept, it doesn't have anything to do with the particular syntax you are using
14:50:54 <smg> byorgey: nice :]
14:50:59 <byorgey> smg: whereas operator sections etc. are specific to Haskell syntax
14:51:13 <smg> ahh okay this makes things clear
14:51:20 <b_jonas> good night now
14:51:33 <byorgey> smg: =)
14:51:33 <smg> byorgey: and or let thingy, how would we call that? the let (!) x = ... ?
14:52:11 <byorgey> smg: I'm not sure what you are asking
14:52:55 <smg> > et (!) x = product [1..x] in (10!)
14:52:55 <lambdabot>  Parse error at "=" (column 10)
14:53:01 <smg> > let (!) x = product [1..x] in (10!)
14:53:02 <lambdabot>  3628800
14:53:08 <smg> how we call that?
14:53:49 <oerjan> :t let andM l = foldr (\x xs -> do b <- x; if b then xs else return False) (return True) l in andM
14:53:51 <lambdabot> forall (t :: * -> *). (Monad t) => [t Bool] -> t Bool
14:53:54 <byorgey> smg: well, you're creating a local binding for !
14:54:11 <oerjan> explisixjelly: ^^ if i did it right
14:54:25 <smg> ah i see
14:54:32 <smg> i just could do let (!)  x = product [1..x]
14:54:44 <byorgey> smg: the reason all those parentheses are necessary is just because of the way syntax works in haskell
14:54:54 <byorgey> smg: you can't have 'let' without 'in'
14:55:00 <byorgey> smg: unless you are in a do-block
14:55:13 <smg> hehe
14:55:16 <byorgey> but you could just say (!) x = product [1..x]
14:55:25 <OceanSpray> how should I represent color?
14:55:32 <OceanSpray> would (Int, Int, Int) suffice?
14:55:37 <smg> byorgey: yeah i get more familiar with ghci
14:55:52 <Baughn> OceanSpray: How about a fourier transform of incoming photons?
14:56:02 <jleedev> OceanSpray: depends on the library. gtk uses (Word16,Word16,Word16); cairo uses (Double,Double,Double)
14:56:03 <byorgey> smg: yes, you can do 'let' without 'in' in ghci, but that's because when you're typing things in ghci you are secretly in a big do-block =)
14:56:10 <dcoutts> OceanSpray: you could be more explicit about the range of the components
14:56:11 <OceanSpray> oy, what
14:56:11 <Baughn> OceanSpray: RGB can't represent infrared or gamma colors
14:56:19 <smg> byorgey: yeah namely main or?
14:56:31 <byorgey> smg: yeah, basically
14:56:41 <byorgey> smg: it is a do-block in IO
14:56:45 <jleedev> data Color = Color | LackThereof
14:56:50 <smg> byorgey: yeah i knew that
14:57:01 <smg> byorgey: can you specifiy the function in which i am? main?
14:57:30 <byorgey> smg: in ghci, you mean?  it doesn't really have a name
14:57:37 <smg> yeah
14:57:49 <Baughn> OceanSpray: "Color" is a mental construction that only applies to /multiple/ photons. You should probably construct a model of the visual cortex in your color type.
14:57:53 <smg> ah okay i just call it i'm on main do block in ghci :]
14:58:10 <lispy> I've seen some FFI examples, but nothing very encompassing or which explains simply, without cruft, how I would make my Haskell code linkable from C.  Anyone know of a simple 10 line program with makefile to show you how this works?
14:58:18 <gwern> I'm not really happy about Hscurses using the top level name HSCurses.*; but I'm not really sure, would Graphics.* be appropriate?
14:58:44 <lispy> gwern: or should it be Text.* ?
14:58:54 <OceanSpray> btw, what's Cairo?
14:59:03 <lispy> OceanSpray: iirc, it's a vector graphic api
14:59:09 <OceanSpray> oh.
14:59:16 <radetsky> gwern: I can't even get HSCurses to build, can you?
14:59:16 <dcoutts> @where cairo
14:59:16 <lambdabot> http://haskell.org/gtk2hs/
14:59:21 <biouser> > type Hyper = (Int,Int,Int,Int)
14:59:22 <lambdabot>  Parse error at "type" (column 1)
14:59:22 <Philippa> gwern: is it your project? If not, don't touch it
14:59:51 <OceanSpray> screw it, I'm just going to use 0 <= x <= 255 to represent the colors.
14:59:56 <gwern> lispy: see, that's the issue, is it text, system, or graphics?
15:00:13 <gwern> or does HSCurses.* really make sense?
15:00:13 <Philippa> we don't really have a good place for UI stuff, Graphics.* has been something of a hack ("but it's a *graphical* user interface!")
15:00:27 <Philippa> it makes as much sense as anything else
15:00:38 <Philippa> nothing else is likely to go for the namespace at least
15:00:53 <dcoutts> OceanSpray: then use Word8
15:00:54 <gwern> radetsky: yes. did you try the darcs repo? it apparently moved without stefan updating the homepage
15:00:56 <dcoutts> Philippa: we have Graphics.UI.*
15:01:10 <gwern> @where hscurses
15:01:11 <lambdabot> http://www.informatik.uni-freiburg.de/~wehr/haskell/
15:01:13 <lispy> gwern: UI.* is what makes sense to me
15:01:22 <Philippa> dcoutts: which is a stupid place to put non-graphical UI libs
15:01:32 <dcoutts> Philippa: sure
15:02:06 <sorear> gwern: O'Rear or Monnier?
15:02:20 <lispy> maybe it should have been UI.Graphics and UI.Text from the start, but who knows now.
15:02:25 <gwern> @where+ hscurses http://www.informatik.uni-freiburg.de/~wehr/software/haskell/#hscurses
15:02:25 <lambdabot> It is stored.
15:02:32 <gwern> sorear: Wehr :)
15:02:35 <gwern> @where hscurses
15:02:35 <lambdabot> http://www.informatik.uni-freiburg.de/~wehr/software/haskell/#hscurses
15:03:05 <jleedev> > (join (.) . join) (*) 5
15:03:09 <lambdabot>  625
15:03:28 <radetsky> I've heard of people having issues with darcs repos being corrupted. has anyone here had these problems?
15:04:03 <gwern> maybe it's just for early adopters using darcs-2
15:04:09 <lispy> radetsky: do you know if these people were trying out darcs2?
15:04:35 <radetsky> afaik, the problem has occured in both 1 and 2
15:04:37 <lispy> radetsky: the stable releases haven't corrupted repos for years, AFAIK
15:05:10 <lispy> there are non darcs ways to corrupt your repo.  DreamWeaver is apparantly really bad about this.
15:05:16 <biouser> > [1,1,1,3] \\ [1,1,1,2]
15:05:17 <lambdabot>  [3]
15:05:25 <biouser> > [1,1,1,2] \\ [1,1,1,3]
15:05:26 <lambdabot>  [2]
15:05:35 <biouser> I would like to add the two results
15:05:50 <biouser> to yield [5]
15:05:58 <sarehu> zipWith (+)
15:06:57 <biouser> tyvm sarehu
15:06:57 <sarehu> biouser: what are you really trying to do?  you want zipWith (+) (xs \\ ys) (ys \\ xs), or do you want something more specialized
15:07:20 <sarehu> :t (\\)
15:07:21 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
15:07:27 <lispy> > (\x y -> zipWith (+) (x \\ y) (y \\ x)) [1,1,1,3] [1,1,1,2]
15:07:28 <lambdabot>  [5]
15:07:47 <lispy> is that like, sum of the symmetric difference?
15:08:15 <biouser> well, I am trying to add (x,y,z,w) and (n,m,o,p} where three elements are common and remain the same and the one that is different is added
15:08:30 <sarehu> oh ok
15:08:48 <biouser> and later, if they are all the same then any one of the elements is doubled
15:08:51 <radetsky> gwern: somehow, hscurses works now
15:09:13 <radetsky> or at least, the install hasn't failed yet
15:09:15 <gwern> radetsky: well, remember the darcs repo is at http://www.informatik.uni-freiburg.de/~wehr/darcs/hscurses now
15:09:23 <biouser> I am trying to build larger hypercubes from small hyper rectangle base cases in 4d
15:09:29 <radetsky> right, I had to get a few patches from it
15:09:29 <smg> @pl mycount x = length . filter (==x)
15:09:29 <lambdabot> mycount = (length .) . filter . (==)
15:10:03 <radetsky> previously, it was dying in the process of doing some configure-script-related thing with ImageMagick
15:10:06 <OceanSpray> > minimum []
15:10:07 <lambdabot>  Exception: Prelude.minimum: empty list
15:10:17 <radetsky> NO EXCEPTIONS
15:10:39 <smg> @pl sieve_of_eratosthenes n = take n $ nubBy(((>1).).gcd)[2..]
15:10:39 <lambdabot> sieve_of_eratosthenes = ($ nubBy (((> 1) .) . gcd) [2..]) . take
15:10:42 <biouser> so 6x6x4x4 + 6x4x4x4 = 10x6x4x4
15:10:50 <biouser> where order never matters
15:11:01 <biouser> =4x4x6x10
15:11:12 <jrx_> @src (//)
15:11:12 <lambdabot> arr@(Array l u _) // ies = unsafeReplace arr [(index (l,u) i, e) | (i, e) <- ies]
15:11:15 <gwern> imagemagick? how odd
15:12:12 <lispy> biouser: if the order doesn't matter, maybe it's easier to come up with an 'canonical' representation or equivalence classes and use that
15:13:16 <biouser> lispy, I'm listening :)
15:13:19 <OceanSpray> >minimum [sqrt(-1)]
15:13:24 <OceanSpray> > minimum [sqrt(-1)]
15:13:25 <lambdabot>  NaN
15:13:39 <ddarius> > sqrt(-1) :: Complex Double
15:13:40 <lambdabot>  -0.0 :+ 1.0
15:13:55 <radetsky> is there a set of hscurses docs on the internets somewhere? I can't seem to build the docs on my machine
15:13:59 <lispy> biouser: Maybe it's best to keep the list sorted?
15:14:16 <Beelsebob> why is minimum of that NaN
15:14:27 <ski_> > sqrt (-1)
15:14:27 <jleedev> ?src minimum
15:14:27 <lambdabot> minimum [] = undefined
15:14:27 <lambdabot> minimum xs = foldl1 min xs
15:14:27 <lambdabot>  NaN
15:14:42 <ski_> > sqrt [sqrt (-1) :: Complex Double]
15:14:42 <lambdabot>        add an instance declaration for (Floating [Complex Double])
15:14:43 <lambdabot>     In the...
15:14:46 <biouser> @hoogle sort
15:14:46 <lambdabot> Data.List.sort :: Ord a => [a] -> [a]
15:14:46 <lambdabot> Data.ByteString.sort :: ByteString -> ByteString
15:14:46 <lambdabot> Data.ByteString.Char8.sort :: ByteString -> ByteString
15:15:02 <ski_> > minimum [sqrt (-1) :: Complex Double]  -- er :)
15:15:03 <lambdabot>        add an instance declaration for (Ord (Complex Double))
15:15:03 <lambdabot>     In the expr...
15:15:05 <Beelsebob> ah, it thinks NaN is less than any complex double
15:15:07 <biouser> @src sort
15:15:07 <lambdabot> sort = sortBy compare
15:15:10 <lispy> > minimum [sqrt(-1) :: Complex Double]
15:15:11 <lambdabot>        add an instance declaration for (Ord (Complex Double))
15:15:11 <lambdabot>     In the expr...
15:15:13 <gnuvince_> @src foldl'
15:15:13 <lambdabot> foldl' f a []     = a
15:15:13 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
15:15:18 <Beelsebob> or any number not on the 0i axis
15:15:26 <Beelsebob> how irritating
15:15:29 <lispy> how would you define < on complex?
15:15:30 <ddarius> Beelsebob: No, sqrt(-1) :: Double is NaN
15:15:45 <ski_> > minimum [1 :+ 0]
15:15:45 <lambdabot>   add an instance declaration for (Ord (Complex t))
15:15:51 <biouser> >sort [1,2,3,4,1]
15:15:56 <Beelsebob> @ty sqrt
15:15:57 <lambdabot> forall a. (Floating a) => a -> a
15:15:58 <ddarius> minimum is just satisfying the law, minimum [x] = x
15:15:59 <biouser> > sort [1,2,3,4,1]
15:16:00 <lambdabot>  [1,1,2,3,4]
15:16:12 <OceanSpray> how do I figure out what the precendence of an operator is?
15:16:23 <ddarius> :info in GHCi I believe
15:17:21 <ski_> when is minimum stable under permutation ?
15:17:35 <byorgey> lispy: there's no canonical way to do it
15:17:49 <hpaste>  dolio pasted "adjunctions" at http://hpaste.org/6060
15:18:00 <lispy> byorgey: so negative ;)
15:18:03 <ddarius> There are plenty of ways to do it, they just don't respect the operations
15:18:05 <biouser> nice, I got it for now, thanks everyone
15:18:08 <byorgey> lispy: you could do it "lexicographically" (order by real, then by imaginary), or maybe by magnitude...
15:18:09 <ski_> (i.e. what could be reasonable weak assumptions on the "order structure")
15:18:32 <jleedev> ski_: when x <= y implies y > x
15:18:35 <jleedev> ?src min
15:18:35 <lambdabot> min x y = if x <= y then x else y
15:18:35 <lispy> byorgey: yeah, I was being facecious when I asked
15:18:47 <byorgey> lispy: oh, ok, sorry =)
15:19:55 <lispy> I wonder what ordering them by magnitude does exactly.
15:20:22 <dolio> ski_: Is that about what you were looking for?
15:20:23 <ski_> jleedev : irreflexive `(<=)' ?
15:20:53 <ddarius> lispy: That's only a pre-order unless you add something else.
15:21:45 <ski_> dolio : hm `ContraFunctor' doesn't refer to `Morphism' ..
15:22:26 <dolio> ski_: Yeah, I didn't really go anywhere with that. I put it in at the beginning and didn't use it.
15:23:21 <jleedev> > foldl1 const [2,3,1]
15:23:22 <lambdabot>  2
15:23:24 <biouser> add_hyper (x,y,z,w) (n,m,o,p) = ([x,y,z,w] \\ ([x,y,z,w] \\ [m,n,o,p]) ++ (zipWith (+) ([x,y,z,w] \\ [n,m,o,p]) ([n,m,o,p] \\ [x,y,z,w]))
15:23:34 <dolio> ski_: I think what you want isn't Functor or ContraFunctor specifically, but that either g or f (not sure which off the top of my head) is a cat2 functor, while the other is a cat1 functor, or something.
15:24:25 <ski_> dolio : in the adjunction, they should be functors in opposite directions between the two categories
15:24:56 <ski_> F : C -> D
15:25:00 <ski_> G : D -> C
15:25:00 <OceanSpray> Maybe I'm worrying too much,
15:25:15 <OceanSpray> but is representing the bitmap as [[Color]] a bit too inefficient?
15:26:35 <Zao> OceanSpray: An Array would probably be a sane data structure.
15:26:42 <litb> > foldl1 const "Hello"
15:26:43 <lambdabot>  'H'
15:27:04 <ddarius> OceanSpray: For raytracing it won't really matter other than space-wise, but still, an array would be more appropriate.
15:27:31 <dolio> ski_: In any case, my original question which sparked all of this was whether, since (FlipF r) is self-adjoint, there was a proper comonad instance for Cont.
15:27:48 <dolio> ski_: But I guess it's a comonad in hask^op, which is a monad in hask, so no.
15:28:01 <ddarius> dolio: Well the comonad is the monad.
15:28:09 <biouser> both the expression before ++ and after ++ work, but I get a parse error for the whole thing
15:28:21 <biouser> possibly incorrect indentation
15:28:41 <biouser> > ([1,2,3,4] \\ ([1,2,3,4] \\ [1,2,3,0])) ++ (zipWith (+) ([1,2,3,4] \\ [1,2,3,0]) ([1,2,3,0] \\ [1,2,3,4])
15:28:41 <lambdabot> Unbalanced parentheses
15:28:58 <dolio> ddarius: Right. But defining a comonad instance for Cont wouldnt' be appropriate, because that's for comonads over Hask.
15:29:05 <biouser> hehe
15:29:11 <jleedev> > minimumBy (\_ _ -> GT) [1,2,3]
15:29:12 <lambdabot> Terminated
15:30:02 <ski_> dolio : m
15:30:03 <radetsky> can anybody help me out with hscurses? I tried to write a simple hello worldish program. it compiles fine, but produces a huge mess of yucky linker errors saying "undefined reference to <ugly decorated name>"
15:30:51 <BMeph> > ([1,2,3,4] \\ ([1,2,3,4] \\ [1,2,3,0])) ++ (zipWith (+) ([1,2,3,4] \\ [1,2,3,0]) ([1,2,3,0] \\ [1,2,3,4]))
15:30:51 <lambdabot>  [1,2,3,4]
15:31:21 <BMeph> biouser: An extra paren for the zipWith. :)
15:31:24 <Japsu> @index (\\)
15:31:24 <lambdabot> bzzt
15:31:27 <Japsu> :o
15:31:34 <radetsky> it looks vaguely like what you would get when attempting to link a c lib into a c++ program without properly informing the compiler, so I'm guessing I just made some minor error
15:31:48 <Japsu> is that "set minus"?
15:31:57 <Japsu> > [1,2,3] \\ [2]
15:31:57 <lambdabot>  [1,3]
15:32:02 <andun> radetsky: try --make
15:32:03 <Japsu> > [1,2,2,3] \\ [2]
15:32:04 <lambdabot>  [1,2,3]
15:32:06 <ddarius> list difference
15:32:07 <Japsu> k
15:32:21 <Japsu> @undef
15:32:22 <lambdabot> Undefined.
15:32:25 <Japsu> > [1,2,2,3] \\ [2]
15:32:26 <lambdabot>  [1,2,3]
15:32:27 <Japsu> hmm
15:32:36 <BMeph> hmm? :)
15:32:39 <Japsu> hmm.
15:32:45 <BMeph> hmm!
15:32:47 <lispy> It's probably assumed that the lists are ordered sets
15:33:02 <ddarius> @src (\\)
15:33:02 <lambdabot> (\\) = foldl (flip delete)
15:33:06 <radetsky> andun: I did. command was "ghc --make Curse" (Main file was Curse.hs)
15:33:07 <biouser> the above worked....
15:33:15 <BMeph> Â¡hmm
15:33:34 <Japsu> @type delete
15:33:36 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
15:33:48 <TSC> It doesn't have to be ordered, but it won't work on multisets
15:34:01 <Japsu> won't work, or just deletes the first?
15:34:03 <lispy> Well, lists are ordered
15:34:06 <TSC> Just the first
15:34:07 <Japsu> > [1,2,2,3] \\ [2,2]
15:34:08 <lambdabot>  [1,3]
15:34:16 <Japsu> > [1,2,2,2,3] \\ [2,2]
15:34:16 <lambdabot>  [1,2,3]
15:34:19 <TSC> So you could apply (\\ [2]) until you reach a fixpoint
15:34:31 <TSC> Or use filter
15:34:44 <Japsu> Act: 13,37
15:34:50 <Japsu> hmm
15:35:01 <lispy> ?type filter
15:35:03 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
15:35:07 <Japsu> > [2,1,3,2] \\ [2]
15:35:08 <lambdabot>  [1,3,2]
15:35:11 <Japsu> > [2,1,3,2] \\ [2,2]
15:35:11 <lambdabot>  [1,3]
15:35:47 <andun> radetsky: -lcurses, perhaps?
15:37:00 <jleedev> > (until =<< ap (==)) (delete 2) [1,2,2,3]
15:37:01 <lambdabot>  [1,3]
15:37:14 <radetsky> andun: nope. -package hscurses, as suggested by the README, also fails
15:37:55 <ski_> > [2,1,3,2] \\ repeat 2
15:38:02 <lambdabot> Terminated
15:42:10 <biouser> add_hyper (x,y,z,w) (n,m,o,p) = ([x,y,z,w] \\ ([x,y,z,w] \\ [m,n,o,p])) ++ (zipWith (+) ([x,y,z,w] \\ [n,m,o,p]) ([n,m,o,p] \\ [x,y,z,w]))
15:42:15 <biouser> so that works
15:42:30 <biouser> but now I need to filter by my other function, fits
15:42:50 <biouser> fits (x,y,z,w) (n,m,o,p)= 1 >= length([x,y,z,w] \\ [n,m,o,p])
15:42:55 <biouser> which returns a bool
15:44:54 <BMeph> biouser: It'll give you the same values, but you might get better performance, if you just say (not . null), instead of the "1 >= length" part.
15:44:54 <dons> ?yow
15:44:55 <lambdabot> If I felt any more SOPHISTICATED I would DIE of EMBARRASSMENT!
15:46:30 <BMeph> I thought you wanted ones that would be singleton or empty, though.
15:47:13 <biouser> BMeph, that is right, not two, three or four, only when the length is zero or one
15:47:29 <biouser> returns true
15:47:34 <hpaste>  dolio annotated "adjunctions" with "functors" at http://hpaste.org/6060#a1
15:47:48 <biouser> I am having trouble using filter here though
15:48:13 <lispy> > filter (==1) [1,2,1,3,1,4]
15:48:15 <lambdabot>  [1,1,1]
15:48:30 <lispy> ?hoogle notEquals
15:48:30 <lambdabot> No matches found
15:48:33 <lispy> ?hoogle notEqual
15:48:33 <lambdabot> No matches found
15:48:38 <OceanSpray> > 1 < sqrt(-1)
15:48:39 <lambdabot>  False
15:48:40 <lispy> oh, I'm thinking of something else
15:48:41 <ddarius> lispy: ?
15:48:44 <BMeph> biouser: If your tuples are in a list, that would work.
15:48:56 <lispy> ?hoogle notElem
15:48:56 <lambdabot> Prelude.notElem :: Eq a => a -> [a] -> Bool
15:48:56 <lambdabot> Data.List.notElem :: Eq a => a -> [a] -> Bool
15:48:56 <lambdabot> Data.Foldable.notElem :: (Foldable t, Eq a) => a -> t a -> Bool
15:49:00 <OceanSpray> > neg Infinity
15:49:00 <lambdabot>   Not in scope: data constructor `Infinity'
15:49:02 <lispy> that's what I was think ing of
15:49:02 <Baughn> > 2 > sqrt(-1)
15:49:03 <lambdabot>  False
15:49:10 <Baughn> > 2 < sqrt(-1)
15:49:10 <lambdabot>  False
15:49:34 <Baughn> So clearly, sqrt(-1) = 2
15:49:51 <lispy> Baughn: oh, good point
15:50:02 <BMeph> biouser: As long as you adjust your function to return True when the diff is singleton or nil.
15:50:51 <biouser> that is fine, I want add_hyper only to run if fits returns true
15:50:51 <ddarius> Baughn: Only if the Ord instance for Double is a total order.
15:51:14 <Baughn> ddarius: If only Double was the pertinent type..
15:51:18 <BMeph> :t filterM
15:51:19 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
15:51:35 <Baughn> > sqrt(-1) :: Double
15:51:36 <lambdabot>  NaN
15:51:46 <Baughn> > sqrt(-1)
15:51:47 <lambdabot>  NaN
15:51:57 <ddarius> The default for Floating is Double.
15:52:02 <Baughn> @ty 1+:1
15:52:03 <lambdabot> Not in scope: `+:'
15:52:07 <BMeph> > negate Infinity
15:52:07 <lambdabot>   Not in scope: data constructor `Infinity'
15:52:12 <Baughn> @ty 1:+1
15:52:13 <lambdabot> forall t. (RealFloat t) => Complex t
15:52:25 <Baughn> > sqrt(-1) :: Complex Double
15:52:26 <lambdabot>  -0.0 :+ 1.0
15:52:40 <Baughn> > (sqrt(-1) :: Complex Double) < 2
15:52:40 <lambdabot>        add an instance declaration for (Ord (Complex Double))
15:52:40 <lambdabot>     In the expr...
15:52:50 <biouser> where if fits returns true, proceed, if fits doesn't return true, end
15:53:14 <lispy> -0.0?
15:53:15 <BMeph> :t guard
15:53:17 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
15:53:35 <Baughn> lispy: How do you like your branch cuts today?
15:53:51 <monochrom> To take logs you must cut branches.
15:53:56 <augustss> > -0.0
15:53:56 <lambdabot>  -0.0
15:54:08 <augustss> > -0.0 == 0.0
15:54:09 <lambdabot>  True
15:54:13 <lispy> > -0.0 > 0.0
15:54:13 <lambdabot>  False
15:54:21 <lispy> > -0.0 < 0.0
15:54:22 <lambdabot>  False
15:54:35 <Baughn> > +0.0
15:54:36 <lambdabot>   parse error on input `+'
15:54:38 <augustss> > 1 / (-0.0)
15:54:39 <lambdabot>  -Infinity
15:54:41 <biouser> I can't find guard
15:54:49 <lispy> > -0.0 :: Expr
15:54:50 <lambdabot>  negate 0.0
15:54:51 <BMeph> biouser: looks like "guard(fits) >> add_hyper" (with appropriate arguments) will do it.
15:55:17 <BMeph> biouser: It's in Control.Monad.
15:55:55 <biouser> so import Control.Monad on the top?
15:55:55 <lispy> BMeph: >> and not >>= ?
15:56:10 <smg> > x <- [1,2,3]; y<-[2,3,4]; True <- x /= y; return (x,y)
15:56:10 <lambdabot>  Parse error at "<-" (column 3)
15:56:18 <lispy> I don't really know how guard works. so maybe that does make sense
15:56:36 <lispy> > do  x <- [1,2,3]; y<-[2,3,4]; True <- x /= y; return (x,y)
15:56:36 <smg> > [1,2,3] >>= x; [2,3,4] >>= y; True <- x /= y; return (x,y)
15:56:37 <lambdabot>  Parse error at ";" (column 14)
15:56:40 <lambdabot>  Couldn't match expected type `[t]' against inferred type `Bool'
15:56:43 <smg> ah do keyword -.-
15:56:54 <lispy> > do  { x <- [1,2,3]; y<-[2,3,4]; True <- x /= y; return (x,y) }
15:56:54 <lambdabot>  Couldn't match expected type `[t]' against inferred type `Bool'
15:57:17 <lispy> > do  { x <- [1,2,3]; y<-[2,3,4]; True <- return (x /= y) ; return (x,y) }
15:57:19 <lambdabot>  [(1,2),(1,3),(1,4),(2,3),(2,4),(3,2),(3,4)]
15:58:08 <lispy> > [ (x,y) | x <- [1,2,3], y<-[1,2,3], x /= y ]
15:58:09 <lambdabot>  [(1,2),(1,3),(2,1),(2,3),(3,1),(3,2)]
15:58:26 <lispy> I think that's the one you actually wanted
15:58:47 <smg> lispy: no :)
15:58:55 <smg> i wanted to try it with monads :
15:58:56 <smg> :)
15:59:06 <Baughn> smg: That /is/ a monad
15:59:07 <lispy> Oh, I see.
15:59:14 <EvilTerran> saying "True <- return (...)" is like saying "guard (...)"
15:59:30 <EvilTerran> except guard uses mzero instead of fail, so is superior :P
15:59:33 <Baughn> smg: Though monad comprehensions were removed for some odd reason
16:00:21 <biouser> add_hyper (x,y,z,w) (n,m,o,p) = guard(fits (x,y,z,w) (n,m,o,p))
16:00:21 <biouser> 	(([x,y,z,w] \\ ([x,y,z,w] \\ [m,n,o,p])) ++ (zipWith (+) ([x,y,z,w] \\ [n,m,o,p]) ([n,m,o,p] \\ [x,y,z,w]))
16:00:22 <smg> http://haskell.org/tutorial/monads.html <-- i'm there :]
16:00:45 <smg> Baughn: yeah okay i wanted to try "alternativ" syntax :]
16:01:01 <Baughn> > do x <- [1..4]; y <- [2..3]; return (x,y,x*y)
16:01:03 <lambdabot>  [(1,2,2),(1,3,3),(2,2,4),(2,3,6),(3,2,6),(3,3,9),(4,2,8),(4,3,12)]
16:01:09 <biouser> is that where guard would go?
16:01:29 <Baughn> > do x <- [1..4]; y <- [2..3]; guard (x /= y); return (x,y,x*y)
16:01:30 <lambdabot>  [(1,2,2),(1,3,3),(2,3,6),(3,2,6),(4,2,8),(4,3,12)]
16:01:55 <biouser> that is pretty sweet
16:02:09 <BMeph> biouser: guard(fits (x,y,z,w) (n,m,o,p)) >> add_hyper (x,y,z,w) (n,m,o,p)
16:02:22 <EvilTerran> > [(x,y,x*y) | x <- [1..4], y <- [2,3], x /= y]
16:02:23 <lambdabot>  [(1,2,2),(1,3,3),(2,3,6),(3,2,6),(4,2,8),(4,3,12)]
16:02:50 <EvilTerran> also. so in list comprehensions, True<- is kinda unnecessary :)
16:03:19 <smg> sure it is
16:03:32 <smg> i think it's needed for the teaching effect in the chapter 9 monads :)
16:04:41 <biouser> BMeph, I am trying to define add_hyper in a .hs
16:04:42 <BMeph> biouser: Try "fits (x,y,z,w) (n,m,o,p)= null . drop 1 $([x,y,z,w] \\ [n,m,o,p])"
16:05:08 <BMeph> Sounds good - toss it in and try it out. :)
16:05:24 <smg> xs >>= return . f	=	fmap f xs
16:05:39 <smg> that's a monadic law? so what does it mean xs should be a list?
16:05:42 <radetsky> re-asking my question...
16:06:04 <radetsky> I'm getting weird linker errors when building a simple hello-world program in hscurses
16:06:19 <biouser> parse error (possibly incorrect indentation)
16:06:19 <Cale> radetsky: Often linker errors are caused by not using --make
16:06:29 <BMeph> smg: Look at the difinition of (>>=). That'll tell you what the players should be. :)
16:06:34 <Cale> radetsky: Or appropriate -package options
16:06:36 <radetsky> Cale: I am using --make
16:06:39 <BMeph> s/difinition/definition/
16:06:42 <radetsky> and -package hscurses
16:06:42 <Cale> radetsky: oh, okay...
16:06:44 <Cale> hmm
16:06:57 <Cale> radetsky: I don't know. Have you pasted the errors somewhere?
16:07:04 <smg> BMeph: a Monadic value
16:07:17 <radetsky> in progress, hold on
16:07:46 <biouser> add_hyper :: Hyper -> Hyper -> [Int]
16:07:46 <biouser> guard(fits (x,y,z,w) (n,m,o,p)) >> add_hyper (x,y,z,w) (n,m,o,p) =  (([x,y,z,w] \\ ([x,y,z,w] \\ [m,n,o,p])) ++ (zipWith (+) ([x,y,z,w] \\ [n,m,o,p]) ([n,m,o,p] \\ [x,y,z,w]))
16:07:56 <BMeph> smg: Exactly. A list is a monadic value, so it would work there. Other monadic values would work, too.
16:08:45 <BMeph> biouser: WHOA! First define it, Then use it. ;)
16:08:58 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/6061
16:09:18 <radetsky> that would be me
16:09:26 <smg> BMeph: ah okay
16:09:27 <radetsky> I have to start remembering to label these things
16:09:37 <biouser> I am trying to define it so that fits must return true for add_hyper to proceed
16:09:41 <smg> i learned prelude monadic valus are list, IO and Maybe :]
16:09:57 <radetsky> Cale: it reminds me of what you get when you link c into c++ without properly informing the compiler
16:10:16 <BMeph> xs >>= f == join (fmap f xs)
16:10:16 <radetsky> i.e. the linker is looking for a decorated name in a list of undecorated names
16:10:27 <Cale> radetsky: That looks like the mtl is missing.
16:10:44 <Cale> radetsky: could you do:  ghc-pkg list mtl
16:10:57 <ddarius> Yeah, they split out the mtl after hscurses was made.
16:11:14 <radetsky> mtl-1.1.0.0
16:11:17 <BMeph> I wish they'd show that one more often, since join is more "true" to its monadic roots.
16:11:26 <ddarius> Try adding -package mtl
16:11:30 <Cale> okay, so at least the mtl package is installed...
16:11:33 <Cale> yeah
16:11:42 <Cale> I would think that --make would cover this, but perhaps now
16:11:44 <Cale> not*
16:11:47 <smg> @type fmap
16:11:48 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:11:56 <radetsky> thanks
16:12:01 <ddarius> I don't recall --make ever adding packages
16:12:02 <radetsky> -package mtl fixes it
16:12:25 <radetsky> oops, ddarius already said this
16:12:38 <ski_> does sections work for infix type constructors/variables in ghc ?
16:12:42 <smg> in short: when do i need fmap?
16:13:01 <Cale> ddarius: It usually solves package issues like this for me.
16:13:04 <BMeph> smg: ALL the time! ;)
16:13:19 <Cale> ddarius: But maybe if you explicitly specify a package, it won't do it anymore.
16:13:54 <radetsky> Cale: i first tried this with --make and no -package flags
16:14:03 <Cale> hmm
16:14:19 <biouser> add_hyper (x,y,z,w) (n,m,o,p) =  ([x,y,z,w] \\ ([x,y,z,w] \\ [m,n,o,p])) ++ (zipWith (+) ([x,y,z,w] \\ [n,m,o,p]) ([n,m,o,p] \\ [x,y,z,w]))
16:14:20 <smg> mh i don't really understand when i need it BMeph!
16:14:28 <biouser> why does that run but not with []
16:14:33 <dons> ?users
16:14:33 <lambdabot> Maximum users seen in #haskell: 463, currently: 423 (91.4%), active: 16 (3.8%)
16:14:38 <biouser> add_hyper (x,y,z,w) (n,m,o,p) =  [([x,y,z,w] \\ ([x,y,z,w] \\ [m,n,o,p])) ++ (zipWith (+) ([x,y,z,w] \\ [n,m,o,p]) ([n,m,o,p] \\ [x,y,z,w]))]
16:15:01 <ddarius> dons: Someone needs to make the next great Haskell app
16:15:19 <smg> @version
16:15:20 <lambdabot> lambdabot 4p597, GHC 6.8.2 (Linux i686 2.40GHz)
16:15:20 <lambdabot> darcs get http://code.haskell.org/lambdabot
16:15:48 <smg> BMeph: can you explain?
16:17:28 <BMeph> smg: BRB - need to get laundry.
16:18:36 <smg> laundry? okay
16:19:18 <radetsky> BMeph: you do laundry? what kind of hacker are you?
16:19:31 <ddarius> A well laundered one.
16:19:31 <smg> radetsky: laundry hacker?
16:19:38 <swidgy> neohacker
16:19:39 * ddarius needs to iron his uniform.
16:19:39 <radetsky> next thing you know, you'll be telling us you shower and shave
16:19:47 <smg> ddarius: lol
16:19:59 <BMeph> radetsky: The Married kind. :p
16:20:22 <roconnor> Who came up with the crazy idea of having pass in the signature of the writer monad?
16:20:37 <ddarius> roconnor: What?
16:20:45 <roconnor> @src MonadWriter
16:20:46 <lambdabot> Source not found. Do you think like you type?
16:20:46 <ddarius> Oh
16:20:54 <ddarius> having 'pass' in the
16:20:57 <smg> but you know also what's going on with fmap?
16:21:07 <roconnor> pass isn't the the paper cited in the documentation
16:21:13 <roconnor> and pass totally sucks. :)
16:21:31 <roconnor> oh right
16:21:38 <EvilTerran> ... what're you guys talking about?
16:21:40 <BMeph> What's pass, the Dual to fail? ;p
16:21:40 <roconnor> 'pass' totally sucks
16:21:49 <roconnor> @type pass
16:21:50 <lambdabot> forall (m :: * -> *) a w. (MonadWriter w m) => m (a, w -> w) -> m a
16:22:16 <roconnor> pass stops ContT (Writer ...) from being a MonadWriter.
16:22:22 <EvilTerran> ... what does that do?
16:22:31 <roconnor> pass stops ContT (Writer w m) from being a MonadWriter.
16:22:34 <smg> first i will install ghc latest
16:22:37 <roconnor> 'pass' stops ContT (Writer w m) from being a MonadWriter.
16:22:41 <Cale> heh
16:22:50 <ddarius> roconnor: Just ignore it.  No one uses pass anyway.
16:23:01 <EvilTerran> we got you the first time. but what's it meant to be useful for?
16:23:05 <BMeph> pass fails? ;)
16:23:07 <Cale> EvilTerran: pass takes a writer computation which also produces a function of the things written, and applies that function
16:23:09 <EvilTerran> my sleep-addled brain doesn't get it
16:23:10 <roconnor> I know no one uses it, but why is it there to begin with?
16:23:16 <Cale> (to the written items)
16:23:27 <roconnor> Are there 'pass' laws?
16:23:36 <EvilTerran> Cale, ah, thankyou. that makes a little sense.
16:24:14 <Cale> I suppose you could come up with some suitable laws based on that intuition.
16:24:23 <BMeph> smg: Do you understand what 'map' does?
16:24:37 <dons> ddarius: i agree.
16:24:37 <smg> BMeph: sure :)
16:25:07 <EvilTerran> > runWriter $ do tell [1]; pass (do tell [2]; return (3, (*10))); tell [4]; return 5
16:25:08 <lambdabot> Terminated
16:25:12 <EvilTerran> whaaa
16:25:18 <EvilTerran> > runWriter $ do tell [1]; pass (do tell [2]; return (3, (*10))); tell [4]; return 5
16:25:18 <lambdabot> Terminated
16:25:26 <Cale> let ((v,f),w) = execWriter x in (v,f w)  is the same as  execWriter (pass x)
16:25:39 <BMeph> smg: Cool. Well, think of 'map' as a list-specific form of 'fmap'. That is, 'fmap' does what 'map does, just to more types than lists of things.
16:25:59 <EvilTerran> > runWriter $ do tell [1]; pass (do tell [2]; return (3, map (*10))); tell [4]; return 5
16:25:59 <lambdabot> Terminated
16:26:01 <EvilTerran> bah
16:26:04 <Cale> EvilTerran: Sometimes code.haskell.org (the machine lambdabot is running on) is a bit finnicky.
16:26:08 <swidgy> smg: the beauty of fmap is that it works just like map, but for any Functor, of which there are a great deal of stock instances (including many Monads), and you can extend it further
16:26:08 <roconnor> Cale I don't think execWriter is allowed to be part of MonadWriter laws.
16:26:23 <biouser> !topic
16:26:25 <smg> mh
16:26:34 <EvilTerran> Cale, but it's terminating immediately. that's not finnicky, that's broken
16:26:40 <BMeph> I say 'things,' because 'fmap' actually works on Functors, not just Monads.
16:26:51 <Cale> hmm
16:26:54 <smg> so the next question is what's a Functor?
16:27:02 <smg> -is
16:27:07 <swidgy> smg: something which supports 'fmap' ;)
16:27:08 <BMeph> Are there Monads that aren't Functors?
16:27:15 <smg> swidgy: ah okay
16:27:26 <Cale> BMeph: not really, no.
16:27:29 <ddarius> And satisfies: fmap id = id and fmap (f . g) = fmap f . fmap g
16:27:33 <smg> so this things must be instances of Functor and implement fmap?
16:27:38 <smg> those things
16:27:41 <Cale> BMeph: There might be Monad instances which are not instances of Functor
16:27:41 <ddarius> liftM is the proof that all monads are functors
16:27:47 <Cale> BMeph: But this would just be a bug.
16:28:14 <BMeph> Cale: Or sloppy/tired development? ;)
16:28:22 <dibblego> "In category theory, a monad or triple is an (endo-)functor..." http://en.wikipedia.org/wiki/Monad_(category_theory)
16:28:27 <Cale> BMeph: same thing :)
16:28:36 <smg> hehe
16:28:42 <EvilTerran> smg, it's things for which fmap can be implemented in a way that satisfies those laws
16:28:53 <smg> ah okay
16:28:55 <EvilTerran> consider Maybe
16:28:59 <ddarius> We should go back to the original name for a monad:  standard construction
16:29:05 <smg> EvilTerran: and list :)
16:29:10 <smg> yeah i learned that okay
16:29:15 <EvilTerran> oh right, okay
16:29:16 <biouser> http://pastebin.com/m68b79bf6
16:29:17 <swidgy> smg: check out all the pre-defined instances of Functor in the docs.  lists are one, but there are many others
16:29:20 <smg> i will read on about monads and watch the videos of Cale :]
16:29:28 <smg> swidgy: okay hehe
16:29:32 <ddarius> There are videos of Cale?
16:29:36 <BMeph> Cale can has videos? ;p
16:29:44 <EvilTerran> the "fmap id = id" part means that fmap is "structure-preserving" - fmap f doesn't change the "shape" of the structure, only the elements
16:29:49 <roconnor> ddarius: we can just tell everyone who asks what a monad is, that it is a standard construction in Haskell.
16:29:49 <Cale> There are no videos of me.
16:29:57 <smg> ddarius: ah no the TheCatsters's videos
16:29:58 <smg> sorry
16:30:04 <biouser> if someone could send me the topic I could paste somewhere better.  I am trying to define a function based on three different bool states
16:30:13 <EvilTerran> !hpaste
16:30:20 <EvilTerran> ?paste
16:30:20 <lambdabot> Haskell pastebin: http://hpaste.org/new
16:30:26 <ddarius> !paste
16:30:26 <smg> i understand laws of monads and what monads are now, but i need to see what practical use i have of them
16:30:26 <hpaste> Haskell paste bin: http://hpaste.org/
16:30:46 * EvilTerran is tempted to go back to fiddling with his Foldr monad
16:31:00 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/6063
16:31:12 <biouser> http://hpaste.org/6063
16:31:18 <biouser> hehe, nice
16:31:54 <roconnor> smg: you can write a monad that can be used to help process alien DNA: http://www.icfpcontest.org/
16:31:55 <lambdabot> Title: ICFP Programming Contest 2007
16:32:41 <smg> roconnor: nice
16:39:46 <BMeph> smg: I edited your fits and ident functions, because I don't think ident did what you wanted. If I messed up, tell me, please. :)
16:40:22 <BMeph> smg: Oops, I meant biouser. :o
16:42:18 <hpaste>  EvilTerran pasted "the Foldr monad" at http://hpaste.org/6064
16:42:26 <EvilTerran> ... any thoughts?
16:42:48 <smg> BMeph: np :)
16:43:19 <smg> interesting i understand your code EvilTerran :D
16:43:24 <jfredett> "Illegal use of punning in record field, use -frecord-puns to permit this" WTF? GHC doesn't let me make bad puns now?
16:43:36 <faxathisia> lol
16:43:37 <faxathisia> :D
16:43:54 * BMeph thinks that shapr will start chucking some odd-ball type of lambdas at EvilTerran's code...
16:43:56 <EvilTerran> i really don't like the definition of >>= for FoldrT, but i can't think of a better way of doing it
16:44:08 <EvilTerran> @seen shapr
16:44:08 <lambdabot> shapr is in #haskell-blah, #scannedinavian and #haskell. I last heard shapr speak 17m 43s ago.
16:44:22 * shapr throws sick lambdas
16:44:30 <smg> (forall e. (a -> e -> e) -> e -> e)
16:44:35 <smg> that's GHC extension isn't it?
16:44:42 <EvilTerran> i was hoping there'd be something elegant like the one for <*> (FoldrT fs <*> FoldrT xs = FoldrT $ liftA2 (<*>) fs xs), but i couldn't find one
16:44:49 <EvilTerran> smg, yeah, as it says at the top of the file
16:44:53 <EvilTerran> "existential quantification"
16:45:02 <faxathisia> EvilTerran: Wouldn't use it myself but it's neat, I like seeing how it could be put together
16:45:08 <biouser> BMeph, Well, it worked before, and I think that it still works with your changes, not sure how it might be different
16:45:29 <faxathisia> and I think that's a decent >>=, I mean >>= is just flip concatMap in [] right?
16:45:30 <EvilTerran> faxathisia, yeah... i mostly started playing with it because of the broken-ness of the MTL [] monad
16:45:32 <smg> EvilTerran: ah sorry
16:45:44 <faxathisia> ah ok.. not something I've realized
16:45:46 <EvilTerran> smg, don't worry about it, those comments are stealthy buggers :P
16:46:05 <smg> hrhr okay :)
16:46:06 <EvilTerran> faxathisia, yeah, apparently MTL's [] is too strict in the spine or something
16:46:14 <BMeph> biouser: Well, by your original definition, ident was always True.
16:46:21 <smg> but i'm happy to see that i can read foreign (advanced) code after one week of haskell
16:46:54 <biouser> *Concat> ident (0,0,0,0) (5,5,5,5)
16:46:54 <biouser> False
16:46:54 <biouser> *Concat>
16:46:55 <EvilTerran> which seems plausible if you look at the source, as it uses runListT everywhere
16:47:15 <EvilTerran> biouser, sorry to wander late into this conversation, but what're you trying to do there?
16:47:34 * EvilTerran cracks his knuckles and brings up the SYB docs >:]
16:47:38 <biouser> http://hpaste.org/6063
16:48:10 <biouser> trying to define the function at the bottom add_hyper to be different based on the different states of two functions return bool
16:48:26 <EvilTerran> hmm
16:48:34 <faxathisia> if <bool> then <a> else <a> ?
16:48:42 <BMeph> Oh, never mind, it's GE, not LE.
16:49:11 <EvilTerran> you have an interesting mixture of tuples and lists there... and list-as-set functions O.o
16:49:12 <faxathisia> > map (\k -> if k then "This" else "That") [True, False, 6 == 9]
16:49:14 <lambdabot>  ["This","That","That"]
16:49:14 <biouser> BMeph, I think that your works too, just less readable for me at my present state
16:49:23 <smg> one last question for today
16:49:27 <smg> how can i turn off layout?
16:49:41 <BMeph> smg: Don't use it. ;)
16:49:59 <smg> i want! :)
16:50:15 <smg> atm i'm building lambdabot on my box
16:50:24 <BMeph> smg: That is, use explicit '{', ';' and '}' in your code.
16:50:35 <smg> yeah i know can i do it anywhere?
16:51:07 <faxathisia> > { 1 }
16:51:07 <lambdabot>  Parse error at "{" (column 1)
16:51:15 <smg> hehe
16:51:23 <faxathisia> smg: Gonna take a guess and say, only when you use layout
16:51:36 <glen_quagmire> how can I get arity of a function?
16:51:47 <faxathisia> glen_quagmire: 1
16:51:48 <glen_quagmire> if (arity of foo < 3) then ... else ...
16:51:58 <BMeph> glen_quagmire: Simple - it's always one! ;)
16:52:01 <EvilTerran> glen_quagmire, with olegian magicks
16:52:02 <glen_quagmire> oh right
16:52:16 <int-e> what's the arity of  undefined ?
16:52:31 <BMeph> faxathasia: :D
16:52:49 <BMeph> int-e: undefined. ;)
16:52:52 <smg> lol
16:53:16 <smg> is there a possibility to produce a bottom value _|_ ?
16:53:25 <smg> like say ["foo", <here bottom value>] ?
16:53:27 <EvilTerran> {-# LANGUAGE OverlappingInstances #-}; class Arity f where arity :: f -> Int; instance Arity a where arity f = 0; instance Arity (a -> b) where arity f = arity (f undefined) + 1
16:53:29 <faxathisia> glen_quagmire: Doesn't make sense to condition on that, there's probably a simpler way.. details?
16:53:47 <EvilTerran> might work
16:53:57 <faxathisia> oo clever :o
16:54:36 <faxathisia> > let __ = __ in __ -- smg, like this?
16:54:37 <lambdabot>  Exception: <<loop>>
16:54:48 <EvilTerran> but you won't be able to use the arity function anywhere where the return value of the function is polymorphic, as it might turn out at runtime to be another function, thus increasing the arity
16:55:08 <smg> fadec: yeah sure a infinite regress
16:55:10 <smg> an
16:55:27 <EvilTerran> that is, no (arity f) where f :: ... -> <something that could be a function type>
16:55:34 <smg> > let z = [ "foo", let __ = __ in __ ]
16:55:34 <lambdabot>  Parse error at end of input
16:55:38 <faxathisia> biouser: I'm lost..
16:55:46 <EvilTerran> glen_quagmire, you likey?
16:55:51 <faxathisia> biouser: What is it supposed to do
16:55:56 <faxathisia> > let z = [ "foo", let __ = __ in __ ] in z
16:55:56 <lambdabot>  Exception: <<loop>>
16:56:01 <faxathisia> > let z = [ "foo", let __ = __ in __ ] in head z
16:56:02 <lambdabot>  "foo"
16:56:02 <smg> oh man, i need a coffee break :)
16:56:11 <smg> yeah so lists aren't strict
16:56:16 <biouser> faxathisia, you looked at the hpaste?
16:56:21 <faxathisia> yes
16:56:44 <biouser> well, all is fine, but if fits returns false, add_hyper should not proceed...
16:56:45 <EvilTerran> (i think you can do the latter with the IncoherentInstances extension, but then you need to make sure you get the instances in the right order in the file, and incoherent instances are a very bad idea, so don't do that anyway)
16:57:43 <biouser> faxathisia, if fits is true and ident is true... it should return [2*x,y,z,w] not [x,y,z,w] which is what add_hyper will return
16:58:05 <faxathisia> ok so far it's like
16:58:23 <biouser> the only correct case for add_hyper is where fits returns true and ident returns false
16:58:31 <biouser> for that case it spits out the right thing
16:58:35 <faxathisia> if fits <args> && ident <args> then [2*x,y,z,w] else <?>
16:59:00 <faxathisia> but I don't have a full picture of it as you can see
16:59:32 <biouser> right, but, is 'if' even available?
16:59:33 <EvilTerran> glen_quagmire, also see http://okmij.org/ftp/Haskell/typecast.html#is-function-type
16:59:33 <lambdabot> Title: Type improvement constraint
17:00:23 <EvilTerran> faxathisia, re what i was saying earlier about ListT: http://haskell.org/haskellwiki/ListT_done_right
17:02:08 <pgavin> does anyone know if there's a heap or pqueue in one of the libraries somewhere?
17:02:28 <hpaste>  BMeph annotated "(no title)" with "You'll need to change the result type, otherwise..." at http://hpaste.org/6063#a2
17:03:33 <BMeph> pgavin: Edison has priority queues, but I don't know if it's been updated to 6.8.2 yet.
17:03:48 <pgavin> BMeph: hmm, I'll try it out
17:04:48 <BMeph> biouser: 1) 'if' is available in so many ways that it'll make you dizzy.
17:05:08 <biouser> BMeph, is that supposed to run as is with the "Nothing" and the "Just"
17:05:51 <BMeph> 2) It sounds like you're still thinking in an "imperative" mindset. Functions don't "return" values, They ARE values. ;)
17:06:28 <OceanSpray> > 1.0 / 0.0
17:06:32 <BMeph> biouser: Yes, it is. it's supposed to run that way. Whether it does or not is another question, though... ;)
17:06:33 <lambdabot>  Infinity
17:06:46 <faxathisia> > fun "Infinity"
17:06:46 <lambdabot>  Add a type signature
17:06:52 <OceanSpray> :t isInfinity
17:06:53 <lambdabot> Not in scope: `isInfinity'
17:06:56 <OceanSpray> :t isInfinite
17:06:56 <faxathisia> > fun "Infinity" :: Expr
17:06:58 <biouser> Maybe [Int] is a type that can be returned?
17:06:58 <lambdabot>  Infinity
17:06:58 <lambdabot> forall a. (RealFloat a) => a -> Bool
17:07:17 <faxathisia> > Nothing :: Maybe [Int]
17:07:18 <lambdabot>  Nothing
17:08:02 <EvilTerran> pgavin, i tend to use a Set/Map for that kinda thing
17:08:28 <EvilTerran> as they have fairly efficient "extract-min" functions
17:09:02 <dcoutts> EvilTerran: sounds like you really want a heap
17:09:04 <BMeph> biouser: Technically, yes. But, you're likely thinging of a totally different concept of "return" than Haskell users do. :)
17:09:13 <BMeph> s/thinging/thinking/
17:09:20 <faxathisia> :t return
17:09:20 <faxathisia> :P
17:09:21 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
17:09:32 <biouser> otherwise instead of else?
17:09:38 <EvilTerran> dcoutts, well, yeah, but that doesn't come in the stdlib. pgavin was asking for a heap.
17:09:47 <dcoutts> oh right
17:09:49 <EvilTerran> i was suggesting a lazy-man's alternative to installing or writing something :P
17:10:00 <dcoutts> hopefully we'll get one added to the containers package
17:10:04 <dcoutts> along with a trie
17:10:58 <OceanSpray> > inifinity
17:10:59 <lambdabot>   Not in scope: `inifinity'
17:11:02 <OceanSpray> > infinity
17:11:04 <lambdabot>  Exception: stack overflow
17:11:22 <faxathisia> lol
17:11:34 <dons> hey all.
17:11:51 <faxathisia> Hi dons
17:11:53 <cjb> yo dons.
17:11:53 <biouser> BMeph, It work!... Just that Just has to be () with all the other stuff goin on therein
17:12:23 <biouser> not exactly sure about Just
17:12:34 <cjb> dons: we were compiling a list of FP-ish five-letter hostnames earlier, not sure whether you got to play :)
17:12:49 <dons> 5 letter hostnames eh?
17:12:53 <OceanSpray> > a < (1.0 / 0.0)
17:12:54 <lambdabot>  False
17:12:55 <dons> so not purely-functional.org
17:12:58 <OceanSpray> > 1 < (1.0 / 0.0)
17:12:59 <dons> comonad.org either?
17:12:59 <lambdabot>  True
17:13:02 <OceanSpray> > 1 > (1.0 / 0.0)
17:13:03 <lambdabot>  False
17:13:10 <hpaste>  biouser annotated "(no title)" with "extra () around the last Just" at http://hpaste.org/6063#a3
17:13:15 <OceanSpray> > (1.0 / 0.0) > (1.0 / 0.0)
17:13:15 <lambdabot>  False
17:14:21 <faxathisia> > 9.0*9.0^9.0*9.0^9.0*9.0^9.0*9.0
17:14:21 <lambdabot>  Add a type signature
17:14:28 <faxathisia> > 9.0*9.0^9.0*9.0^9.0*9.0^9.0*9.0 :: Float
17:14:28 <lambdabot>  Add a type signature
17:14:47 <BMeph> biouser: Also, if you're dead-set on having some kind of message come back for an invalid use of add_hyper...here, I'll tweak the hpaste. :)
17:16:01 <hpaste>  BMeph annotated "(no title)" with "To support an "error message" without making your program segfault ;)" at http://hpaste.org/6063#a4
17:17:31 <BMeph> biouser: You know how certain functions in C, will give you a -1 value as a sentinel, to show that the function didn't actually come up with an answer?
17:18:25 <BMeph> In Haskell, they came up with a more "honest" version - the Maybe type.
17:18:51 <biouser> are the "Right" and "Left" necessary, I don't quite understand that
17:18:58 <EvilTerran> yes
17:19:02 <biouser> BMeph, oh, I got you, cool
17:19:02 <EvilTerran> ?src Either
17:19:02 <lambdabot> Source not found. The more you drive -- the dumber you get.
17:19:07 <BMeph> That way, if there is no answer, your function says, "I have Nothing for you." - literally! ;)
17:19:08 <EvilTerran> ?src Left
17:19:08 <lambdabot> Source not found. Where did you learn to type?
17:19:10 <EvilTerran> bah
17:19:18 <EvilTerran> data Either a b = Left a | Right b
17:19:45 <smg> > [1,2,3] >>= (\ x -> [1,2,3] >>= (\y -> return (x,y))
17:19:45 <lambdabot> Unbalanced parentheses
17:19:50 <smg> > [1,2,3] >>= (\ x -> [1,2,3] >>= (\y -> return (x,y)))
17:19:54 <EvilTerran> if you want to return an a from an expression of type Either a b, you have to wrap it in a Left to make the type right.
17:19:58 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
17:19:58 <EvilTerran> same for b and Right
17:20:23 <BMeph> Now, for more sophisticated versions, there is the Either type. It lets you give an answer that can be of two completely different types.
17:21:13 <BMeph> That way, it you want to tell your user why the function didn't do what he wanted, instead of using the Maybe type and saying Nothing (wink, wink)...
17:22:02 <BMeph> You use the Either type, and give a (arguably) constructive message, as the error type.
17:22:36 <faxathisia> :t replicateM
17:22:38 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
17:22:57 <faxathisia> :/
17:23:01 <faxathisia> @type replicateM
17:23:02 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
17:23:23 <faxathisia> This :t replicateM does not work in PM
17:23:25 <biouser> cool, I am trying to build on this so that it will be able to sense whether a number of (2,2,5,5) might be cobled together to make a (10,10,10,10) which, in this case I think that it can with 100 of them
17:23:26 <faxathisia> the other one does
17:23:35 <BMeph> It's Haskell convention, that for usable answers in an Either type, that you use the Right form - that way, you know you're getting a "Right" answer, get it? ;)
17:24:05 <biouser> hehehe
17:24:12 <faxathisia> > (\(a,b,c,d)->(a*c,a*d,b*c,b*d)) (2,2,5,5)
17:24:13 <lambdabot>  (10,10,10,10)
17:24:36 <biouser> I'm going afk for a bit, thanks a lot for the help
17:24:46 <biouser> hmm faxathisia not sure if I see what that does
17:25:23 <faxathisia> > (\(a,b,c,d)->(a*c,a*d,b*c,b*d)) (2,2,5,5) :: (Expr,Expr,Expr,Expr)
17:25:23 <lambdabot>  (2 * 5,2 * 5,2 * 5,2 * 5)
17:25:29 <faxathisia> > (\(a,b,c,d)->(a*c,a*d,b*c,b*d)) (8,3,9,4) :: (Expr,Expr,Expr,Expr)
17:25:30 <lambdabot>  (8 * 9,8 * 4,3 * 9,3 * 4)
17:25:40 <mauke> > (\x -> x + 1) 1
17:25:41 <lambdabot>  2
17:25:51 <lekro> just out of curiosity: when I write [x] `mappend` y :: [a] instead of just x : y, will there be a difference in the resulting code, like, does it need the same space?
17:26:08 <EvilTerran> the difference won't be significant
17:26:11 <mauke> only one way to find out
17:26:18 <mauke> look at the generated code
17:26:21 <lekro> EvilTerran: most likely not, yeah
17:27:22 <lekro> mauke: would that be assembler?
17:27:59 <mauke> well, what do you mean by "resulting code"?
17:28:19 <lekro> does it construct another list when I write [x] `mappend` y?
17:29:24 <faxathisia> @src mappend []
17:29:24 <lambdabot> Source not found. You untyped fool!
17:29:29 <faxathisia> @src [] mappend
17:29:29 <lambdabot> Source not found. You untyped fool!
17:29:32 <faxathisia> @src mappend
17:29:32 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
17:29:36 <faxathisia> :(
17:30:02 <EvilTerran> (++)?
17:30:09 <lekro> yes
17:30:26 <EvilTerran> lekro, it's likely to get inlined or deforested or something out of existence
17:30:54 <EvilTerran> mappend will get inlined to (++), and there's probably a RULE for ([x]++) -> (x:)
17:31:34 <ddarius> I doubt they'd need a RULE for that.
17:32:08 <faxathisia> I think.. you can do this kind of agressive optimisition with supercompilation
17:32:20 <smg> mh what time is it for you? :)
17:32:25 <faxathisia> maybe e.g. supero will show you if that's going to happen
17:32:28 <ddarius> @localtime smg
17:32:29 <lambdabot> Local time for smg is Mon Mar  3 02:32:28
17:32:41 <smg> yeah mine :)
17:32:48 <smg> and your's? :]
17:32:56 <smg> you're still very active at this channel really nice
17:33:15 <ddarius> The Haskell community is spread across the globe.
17:33:16 <lekro> I knew that there is Monoid [] and I thought that it'd be worthwhile to have a Monoid a, Monoid b => Monoid (a,b) instance. I looked in the documentation and there it is. fascinating. :)
17:33:42 <ddarius> lekro: Yes, that's the product monoid; a fairly significant instance.
17:33:54 <smg> ddarius: yeah :] but the channel is really the best on freenode imho.
17:33:57 <EvilTerran> faxathisia, yeah, supero will probably do that kinda thing
17:34:22 <lekro> ddarius: thanks, now I've also got a name for it
17:34:26 <faxathisia> I saw something very neat.. using supercompilation for theorem proving
17:34:46 <EvilTerran> but i wouldn't be surprised if there were an optimiser special-case to turn any ([x0,...,xN]++) of statically-known length into ((x0:).(...).(xN:)) at compile-time
17:35:10 <faxathisia> you write some function Stuff -> Bool .. supercompile it until it's obvious that the function always evaluates to True
17:35:40 <EvilTerran> if there is, that's fine. if there isn't, it'll probably've been tried and determined to not make that big a difference, so it's still fine :P
17:35:51 <faxathisia> EvilTerran: I'd hope it could just use the definition of ++
17:35:58 <faxathisia> to get the same result
17:36:04 <EvilTerran> it won't inline ++, though, because it's recursive
17:36:08 <EvilTerran> (IIUC)
17:36:52 <faxathisia> It seem that with supercompilation you can unfold recursive defs but it's making sure to stop unfolding if it gets into a loop
17:36:53 <EvilTerran> if it could detect guarded recursion, i guess it could inline uses of guarded-recursive functions where the parameter is statically known to be finite size
17:37:14 <EvilTerran> er, s/guarded/structurally/
17:37:19 <EvilTerran> wrong one there :P
17:37:45 <smg> @localtime ddarius
17:37:47 <lambdabot> Local time for ddarius is Sun Mar  2 19:37:40
17:38:09 <EvilTerran> @localtime
17:38:09 <lambdabot> Local time for EvilTerran is Mon Mar 03 01:40:00
17:38:14 <EvilTerran> hehe :)
17:38:50 <smg> hehe
17:39:01 <smg> @localtime faxathisia
17:39:01 <lambdabot> Local time for faxathisia is Mon Mar  3 01:39:01
17:39:11 <smg> all people night-active :]
17:39:23 <EvilTerran> ah, another night owl :)
17:40:19 <dcoutts> @seen dons
17:40:19 <lambdabot> dons is in #xmonad, #haskell-soc and #haskell. I last heard dons speak 27m 21s ago.
17:40:34 * dcoutts notes that "cabal list" output is now nice
17:41:04 <smg> hey dcoutts how are you? :)
17:41:22 <dcoutts> good thanks :-)
17:41:29 <pgavin> dcoutts: is there a way to make cabal-install automatically run hscolour and haddock on libraries?
17:42:02 <smg> http://www.xmonad.org/images/screen-triplehead-galois.png <-- I like that screenshot :]
17:42:24 <pgavin> dcoutts: (other than with "cabal hscolour; cabal haddock; cabal install", I mean)
17:42:55 <dcoutts> pgavin: not yet, if you want to work on that see http://hackage.haskell.org/trac/hackage/ticket/206
17:42:56 <lambdabot> Title: #206 (cabal-install should be able to generate haddock docs) - Hackage - Trac
17:43:11 <Japsu> http://japsu.pp.fi/temp/pivotcat_is_pivot.jpg <-- here's mine
17:43:38 <pgavin> dcoutts: ok, I can take a look
17:44:27 <dcoutts> pgavin: we now have a way to add new flags to the cabal 'install' command, independent of the underlying 'configure' flags, eg we use it for --dry-run
17:44:50 <dcoutts> pgavin: so we might want to add a couple more for docs, hscolour etc
17:45:06 <pgavin> dcoutts: ok, like --haddock and --hscolour
17:45:45 <ddarius> EvilTerran: It is guarded recursion too.
17:46:09 <dcoutts> pgavin: right. You may want to wait for mnislaih's patches which allow storing those options in the config file too, so you can save those options and use them every time.
17:46:39 <dcoutts> pgavin: it's also somewhat related to http://hackage.haskell.org/trac/hackage/ticket/225
17:46:40 <lambdabot> Title: #225 (allow installing just specific bits, like just docs) - Hackage - Trac
17:46:44 <dons> dcoutts: ?
17:46:48 <dcoutts> pgavin: so you may want to consider them together
17:47:07 <pgavin> dcoutts: ok, gotcha
17:47:17 <dcoutts> dons: oh, just wanted to show off new "cabal list", and note that cabal doesn't dep on hscolour
17:47:48 <dons> oh good. these creeping GPL things are a bit annoying. they bust up our nice BSD-ish code (hpaste links in hscolour, for example)
17:48:11 <dons> cabal turns a lot of GPL "applications" into libraries, which then messes up things
17:48:15 <dcoutts> dons: in fact we could do with a better hscolour anyway, one that uses a proper parser like haddock and can distinguish types from data constructors
17:48:38 <dcoutts> perhaps just a haddock extension
17:48:43 <EvilTerran> dcoutts, isn't it that structural recursion = recursion proper, and guarded recursion = co-recursion?
17:48:50 <dons> cabal should warn when someone GPL's a library stanza in a .cabal file :)
17:49:06 <dcoutts> dons: what do you mean about turning apps into libs?
17:49:22 <dons> dcoutts: oh, say, hscolour, it starts off as a nice simple GPL'd executable
17:49:25 <dons> you'd not link against it
17:49:26 <dcoutts> dons: heh, we cannot do that :-) GPL is quite legitimate for a lib
17:49:33 <dons> but when cabalised, its easy to library-ify
17:49:45 <dons> but then the license doesn't change -- and suddenly its a bit of infectious code
17:49:57 <EvilTerran> er, s/dcoutts/ddarius
17:49:58 <dcoutts> dons: malcolmw has a deliberate policy of lgpl libs + gpl apps
17:50:26 <dons> ah ok. so we can probably point out the hscolour issue -- it used as a library by hpaste, iirc
17:50:29 <dcoutts> dons: eg with cpphs, the lib is lgpl and the 3 line app is gpl
17:50:37 <dons> oh good
17:50:57 * dons thinks we should do more to encourage BSD-ish stuff
17:51:17 <dcoutts> dons: we can certainly check for gpl propagating, eg a bsd lib depending on a gpl lib
17:51:42 <dcoutts> dons: and note it in the hackage page, the overall effective license
17:51:49 <dons> gpl libs are harmful for haskell adoption commercially, unfortunately :(
17:52:23 <dons> there's a tension between the community goal of sustainable commercial development, having a large library suite, and GPL-ing libs
17:52:48 <dino-> even LGPL?
17:52:54 <dcoutts> dons: that's not entirely clear, gpl lets competing companies develop a common platform without worry of losing advantage by keeping changes secret
17:53:11 <dcoutts> dons: it depends on the app/lib in question really
17:53:16 <ddarius> EvilTerran: You seem to be correct.
17:53:36 * EvilTerran would suspect that inlining co-recursive functions might go horribly wrong
17:53:39 <dons> dcoutts: yeah, if we had competing haskell companies :)
17:53:47 <ddarius> EvilTerran: Actually we're both correct.
17:54:02 <EvilTerran> altho you could do that if you knew from context how big the result had to be, i guess
17:54:30 <EvilTerran> that's nicely dual to inlining recursive-proper functions if you knew from context how big the parameter was :)
17:54:46 <dons> we definitely can't use any GPL'd library at Galois. its frustrating when there's only one Haskell library option for a particular domain, and its GPLd
17:54:56 <dino-> Is there still this tension even with LGPL for libraries?
17:55:04 <dons> hmm, not really.
17:55:25 <dons> but may as well BSD it -- everyone's contributing code back anyway
17:55:35 <pgavin> dons: I like to use LGPL for more "higher up" libraries
17:55:39 <dons> and the core haskell suite is all BSDd
17:55:50 <pgavin> dons: but for something core like mtl or something BSD makes sense
17:55:57 <dino-> I'm not familiar enough with BSD, is LGPL basically BSD in many respects?
17:56:06 <pgavin> dino-: no, not at all
17:56:11 <faxathisia> Where could I get an AST for haskell with a parser and pprinter? just wanting to try something..
17:56:11 <dons> what's the point of LGPLing something? preventing forks?
17:56:20 <pgavin> dino-: LGPL just protects the library, not derived code
17:56:24 <dons> faxathisia: the haskell-src library
17:56:41 <faxathisia> thank you
17:56:41 <dcoutts> dons: you're just asking why LGPL at all, there are good answers to that all over the net
17:56:44 <smg> good night to all. :]
17:56:47 <pgavin> dons: it doesn't protect against forks at all :)
17:57:12 <pgavin> dons: it just keeps people from linking it into a binary and not providing code
17:57:33 <dcoutts> dons: it's really about keeping something open source, same spirit as the GPL
17:58:02 <pgavin> but it's better for libs because then dynamic linking doesn't count as "derived"
17:58:03 <dons> but probably excessively complicated for the kind of code we work on
18:00:45 <ddarius> > @check \xs ys -> xs ++ ys == unfoldr (\l -> case l of ([],[]) -> Nothing; ([],y':ys') -> Just (y',([],ys')); (x':xs',ys') -> Just (x',(xs',ys'))) (xs,ys)
18:00:45 <lambdabot>  Parse error at "@chec..." (column 1)
18:00:46 <mud-rb> pgavin: that's kind of an open question, or at least there's a lot of debate about it
18:00:51 <ddarius> @check \xs ys -> xs ++ ys == unfoldr (\l -> case l of ([],[]) -> Nothing; ([],y':ys') -> Just (y',([],ys')); (x':xs',ys') -> Just (x',(xs',ys'))) (xs,ys)
18:00:53 <lambdabot>  OK, passed 500 tests.
18:00:57 <dino-> I have to go read about these things and how they differe. I was under the impression that the LGPL took away the viralness in some way.
18:01:09 <dino-> And made this workable for closed-source software using the lib.
18:01:14 <dino-> I would easily be very very wrong.
18:01:15 <pgavin> mud-rb: I suppose so
18:01:33 <dino-> s/would/could/
18:01:33 <allbery_b> dino-: LGPL just requires you to provide source for the library nd any modifications to it, not for the entire app
18:02:04 <ddarius> @check \xs ys -> xs ++ ys == foldr (:) ys xs -- much more pleasant
18:02:05 <lambdabot>  OK, passed 500 tests.
18:02:14 <pgavin> the problem is that it might be hard to draw a line between the library and the app
18:02:20 <dons> or a wrapper library
18:02:31 <dino-> mm
18:03:08 <dons> so proprietary stuff can't get added to the LGPLd code. Its still more restrictive
18:03:16 <atp> the lgpl is just the gpl, but with linking expressly considered "not a derivative work"
18:03:17 <dino-> I understand.
18:03:52 <pgavin> atp: *dynamic* linking is ok; static linking is not
18:04:07 <atp> pgavin: yeah, good clarification, thanks.
18:04:21 <pgavin> atp: so currently LGPL might cause problems with GHC on most platforms
18:04:41 <radix> pgavin: plz read lgpl k thx
18:04:53 <dons> yeah, there's no way to dyn link, effectively
18:04:56 <dons> except for C libs
18:05:35 <atp> hm
18:06:09 <atp> this is going to become more of an issue, too, as stuff like supercompilation becomes more mainstream
18:06:25 <dons> oh, interesting.
18:06:29 <faxathisia> supercompilation has what to do with it?
18:06:38 <atp> well, if you use a library,
18:06:38 <dons> what does massive cross module inlining that ghc does , do to license?
18:06:43 <atp> exactly
18:06:48 <atp> hm
18:06:59 <dons> there's no linking border if you distribute .hi files...
18:07:20 * wli usually makes his code available under any license in some list of licenses of the user's choice.
18:07:38 <pgavin> radix: I suppose it depends on who you talk to
18:07:43 <dons> thankfully, almost all haskell libs (85%?) is BSDd
18:07:43 <atp> i sort of wish that all this legal mumbo-jumbo didn't affect us cs folks so much :/
18:08:03 <atp> yeah
18:08:06 <radix> pgavin: no, really, read it
18:08:10 <radix> pgavin: do you want a paragraph reference?
18:08:10 <dons> anyone have a theory on what cross module, static linking does for LGPLd code?
18:08:20 <dons> i.e. all haskell libraries released under LGPL currently
18:08:24 <adu> wli: isn't hat equivalent to having a license filled with "case" ... "of" statements?
18:08:31 <dons> s/cross module inlining/
18:08:34 <wli> (That list includes BSD; mostly it's meant to dodge the German public domain / warranty etc. bullet.)
18:08:52 <wli> adu: No idea.
18:09:05 <mrd> dons: the LGPL is rather C-oriented, sadly
18:09:08 <adu> dons: iirc static linking is ok in LGPL, its NOT ok in GPL
18:09:28 <atp> adu: even dynamic linking might not be ok... hasn't been tested in court, i don't think
18:09:41 <adu> o
18:09:54 <mrd> the lisp folks have it especially tricky with LGPL
18:10:06 <mrd> since everything gets kinda mushed together
18:10:13 <adu> mrd: why is lisp tricky?
18:10:15 <radix> pgavin: in the case of static linking, you just need to provide "object files" of your proprietary parts so that the end user can re-link with other Free software.
18:10:19 <pgavin> radix: ok, fair enough :)
18:10:21 <adu> mrd: oic
18:10:31 <pgavin> radix: I've convinced myself
18:10:39 <mrd> adu: code is all together in an image, can fiddle with parts that were "linked" in, etc
18:10:41 <pgavin> err, well, you've convinced me
18:10:46 <radix> pgavin: I'm not defending the lgpl or the gpl, though, I think they're both ridiculous and they make everything harder.
18:11:19 <radix> but I think more people need to read the licenses they talk about so often :)
18:11:25 <atp> radix: i wouldn't like it if someone took code i'd spent a lot of time producing, improved it substantially, and didn't share the improvements with me though
18:11:33 <radix> atp: ok.
18:11:47 <adu> radix: the GPL and LGPL are not ridiculous, the code-stealing pleagurizing power-hungry software giants are ridiculous!
18:11:53 <radix> adu: ok.
18:11:59 <pgavin> radix: it seems to me the whole open source community wouldn't exist to the extent that it does without the GPL
18:12:03 <radix> ok.
18:12:08 <atp> i'm actually less concerned about the whole "taking things proprietary" issue
18:12:14 <atp> after all, you still have your code
18:12:22 <mrd> I appreciate the idea of the GPL making code open, but it's a PITA sometimes to deal with =)
18:12:35 <atp> it's really, you know, the whole antisocial aspect
18:12:45 <atp> i like how i can make myself smarter by reading, say, dons' code
18:12:56 <pgavin> *lots* of BSD code ends up being closed
18:13:06 <atp> pgavin: the original code is still there
18:13:07 <johnnowak> pgavin: who cares?
18:13:38 <adu> I work for a company that makes around 5 million a year whose primary products are 80% opensource
18:13:44 <atp> the real loss... is if some super smart hacker comes up with something really neat and can't share it because the legal department at his company thinks it might be "valuable IP" in the future
18:13:45 <pgavin> I do, for one
18:14:01 <atp> and then they sit on it forever
18:14:10 <atp> and you and i never have the opportunity to learn from it
18:14:17 <dino-> Reading BSD now. I think it seems reasonable and common-sensical enough to me, not being a legal person.
18:14:21 <atp> that's just really crappy...
18:14:52 <dcoutts> dons: see the new new list output: http://hackage.haskell.org/trac/hackage/ticket/235#comment:1
18:14:53 <lambdabot> Title: #235 (cabal list should also list installed packages) - Hackage - Trac
18:15:08 <jleedev> > ap [id,succ] "hello"
18:15:09 <lambdabot>  "helloifmmp"
18:15:11 <pgavin> I suppose, deep down inside, I'm really just a commie :)
18:15:41 * wli is a commie pinko red on the outside, too.
18:15:50 <pgavin> lol
18:15:50 <dons> dcoutts: oh, awesome.
18:15:55 * johnnowak prefers the ISC license 
18:16:04 <dons> that's really nice, dcoutts
18:16:08 <dons> kolmodin++
18:16:42 <radix> "Ha ha! don't thank me, thank Anarchy!"
18:17:52 <hpaste>  ski annotated "adjunctions" with "adjunction attempt" at http://hpaste.org/6060#a2
18:18:44 <hpaste>  ski annotated "adjunctions" with "(cont.d)" at http://hpaste.org/6060#a3
18:19:43 <ski_> @tell dolio http://hpaste.org/6060#a2 http://hpaste.org/6060#a3
18:19:43 <lambdabot> Consider it noted.
18:23:55 <dolio> ski_: Does that compile without the fundeps on Adjunction? It didn't for my version.
18:24:21 <dolio> Or, at least, not with f -> g, g -> f but without f g -> cat0 cat1.
18:24:21 <ddarius> ski_: "curry" and "yrruc" ?  Aren't those names a bit specific?
18:25:06 <ski_> i couldn't come up with / recall anything i found better, atm
18:25:24 <ddarius> (adjoint) transpose is a common term
18:25:36 <ski_> dolio : `-- untested'
18:25:49 <dolio> Ah. Skimmed past that. :)
18:25:59 <ddarius> Comments are for the weak.
18:26:50 <ski_> ddarius : hm, i suppose those could work .. though i don't like the assymetry in size
18:27:16 <ddarius> ski_: That wasn't two terms.
18:27:23 <faxathisia> @pl ((f =<<) .)
18:27:23 <lambdabot> ((f =<<) .)
18:27:35 <faxathisia> :(
18:27:41 <EvilTerran> @unpl pl ((f =<<) .)
18:27:41 <lambdabot> pl (\ b e -> (b e) >>= f)
18:27:46 <EvilTerran> er. yes, quite.
18:27:59 <faxathisia> @pl (\ b e -> (b e) >>= f)
18:27:59 <lambdabot> flip flip f . ((>>=) .)
18:28:00 <ddarius> faxathisia: It's not going to do anything (well, much) if you don't have any arguments.
18:28:24 <ddarius> @ map f . map g
18:28:27 <ddarius> @pl  map f . map g
18:28:28 <lambdabot> map (f . g)
18:28:56 <faxathisia> Does there not exist some.. @ so that (f @) = ((f =<<) .)
18:29:04 <ski_> ddarius : oh .. so possibly `left vs. right (adjoint) transpose' ?
18:29:26 <dolio> @type ((?f =<<) .)
18:29:27 <lambdabot> forall a (m :: * -> *) b (f :: * -> *). (Functor f, Monad m, ?f::a -> m b) => f (m a) -> f (m b)
18:29:29 <EvilTerran> faxathisia, er... is that <=< ?
18:29:42 <faxathisia> @src (<=<)
18:29:42 <lambdabot> Source not found. That's something I cannot allow to happen.
18:29:47 <faxathisia> :t (<=<)
18:29:48 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
18:29:49 <EvilTerran> (f <=< g) x = f =<< g x
18:30:00 <EvilTerran> likewise for >>=
18:30:04 <EvilTerran> er, and >=>
18:30:12 <faxathisia> @hoogle (<=<)
18:30:13 <lambdabot> Did you mean: (<=<)
18:30:13 <lambdabot> Prelude.undefined :: a
18:30:13 <lambdabot> Control.Monad.State.Class.get :: MonadState s m => m s
18:30:27 <EvilTerran> it's in 6.8's control.monad
18:30:29 <faxathisia> I can just define it!
18:30:33 <faxathisia> thanks :D
18:30:38 <EvilTerran> :)
18:30:42 <ski_> dolio : any comments before i leave ?
18:30:59 <faxathisia> yes that's it
18:31:23 <dolio> ski_: Nah. Yours is significantly pretter than what I was doing. :)
18:31:26 <ddarius> ski_: Usually transpose is used bidirectionally.  left/right adjunct is another term, but I always forget which is which.
18:32:07 <biouser> sort [x,y,z,w]
18:32:45 <ski_> ddarius : yes .. (i think i would possibly prefer `pre vs. post' or somthing of that ilk (not relying directly on syntax order))
18:32:46 <biouser> I want to get this back and then get back [2*#,#,#,#]
18:33:17 <biouser> where now I am getting [2*x,y,z,w]
18:33:22 <faxathisia> biouser: Don't understand your notation, what's #?
18:33:28 <biouser> just an Int
18:33:28 <ski_> (ddarius : well, in this case, `pre-to-post' and `post-to-pre', but shorter ..)
18:33:42 <EvilTerran> ski_, "foreward" and "backward"?
18:33:55 <mauke> > sort [x,y,z,w]
18:33:57 <lambdabot>  [w,x,y,z]
18:34:03 <EvilTerran> err
18:34:24 <biouser> mauke, where we don't know which is smallest
18:34:36 <ski_> EvilTerran : better than `left vs. right' or `upper vs. lower', i suppose
18:34:37 <mauke> what
18:34:53 <EvilTerran> biouser, can't you do to (sort [x,y,z,w]) what you're doing to [x,y,z,w] at the moment?
18:35:16 <ski_> (or `- vs. co-' ..)
18:35:49 <ddarius> left-to-right and right-to-left would work for me, but I'd never actually use them in writing (or left/right adjunct)
18:36:01 <biouser> I want to turn [5,4,3,2] into [4,3,4,5]
18:36:12 <biouser> where the smallest on is doubled
18:36:17 <biouser> *one
18:36:32 <mauke> > (\(x : xs) -> 2*x : xs) (sort [5,4,3,2])
18:36:33 <lambdabot>  [4,3,4,5]
18:36:35 <ddarius> sort it then multiply the first element by two.  What's your problem?
18:37:16 <ski_> (dolio : i was going to add the contravariant dual functor, but realized i couldn't figure out a way to convert from `a ~> b' to `Dual a ~> Dual b', where `newtype Dual a = MkDual {unDual :: a}' ..)
18:37:24 <pgavin> there's no way to provide a "default instance" for a class, is there?
18:37:37 <EvilTerran> > ((:) <$> (*2).head <*> tail) . sort $ [5,4,3,2]
18:37:37 <lambdabot>  [4,3,4,5]
18:37:44 <EvilTerran> pgavin, not without overlapping instances
18:37:54 <dino-> So, what BSD licence should I use? I have by chance the sources to cabal-install and utf8-string on my system right now..
18:37:55 <EvilTerran> possibly even incoherent ones, depending on the situation
18:38:12 <dino-> They have license which look the same at a glance. One says "BSD-like" and the other says "BSD3-style"
18:39:06 <dino-> cabal-install is licensed to a bunch of you guys and the other is licensed to Galois Inc.
18:39:27 <dino-> Er, not to, but you know what I mean
18:39:52 <pgavin> basically what I want is to define a class Eq' a and two instances: instance Eq' a where eq _ _ = False and instance (Eq a) => Eq' a where eq = (==)
18:40:31 <EvilTerran> pgavin, unfortunately, that really doesn't work
18:40:41 <EvilTerran> as the instance heads are the same, they only have different contexts
18:40:42 <biouser> ? paste
18:40:50 <biouser> ?paste
18:40:50 <lambdabot> Haskell pastebin: http://hpaste.org/new
18:41:04 <faxathisia> @pl liftM f . g
18:41:04 <lambdabot> fmap f . g
18:41:13 <tehgeekmeister> working on maybench, i got the current source and an import (import Test.Maybench.Command (Command(..))) isn't working, what do i do to troubleshoot such a problem?
18:41:21 <pgavin> EvilTerran: and there's really no other way to emulate that, either, afaict
18:41:26 <hpaste>  biouser pasted "Within the definition of add_hyper" at http://hpaste.org/6067
18:41:38 <EvilTerran> pgavin, well, ask oleg :P
18:41:44 <tehgeekmeister> (i have the output of ghci -v if that's relevant)
18:41:48 <pgavin> @seen oleg
18:41:48 <lambdabot> I haven't seen oleg.
18:41:55 <mauke> biouser: ew
18:41:59 <EvilTerran> he doesn't come on here, afaik
18:42:00 <faxathisia> @src (.)
18:42:00 <lambdabot> (.) f g x = f (g x)
18:42:06 <pgavin> heh
18:42:12 * ski_ invokes additive unit right introduction on self
18:42:15 <EvilTerran> @where oleg
18:42:15 <lambdabot> http://okmij.org/ftp/
18:43:16 <EvilTerran> pgavin, you might be able to base something on, say, http://okmij.org/ftp/Haskell/types.html#peano-arithm
18:43:16 <lambdabot> Title: Haskell Programming: Types
18:43:22 <mauke> biouser: Right (let hd : tl = sort [x,y,z,w] in hd * 2 : tl)
18:43:41 <tehgeekmeister> the module it's trying to import is in the appropriate place to be loaded by ghc automatically, as far as i can tell, but ghc isn't finding it for some reason.
18:45:11 <pgavin> EvilTerran: how would that help?
18:45:21 <pgavin> EvilTerran: I'm already using type level numbers
18:45:25 <EvilTerran> i thought class-parameterised-classes might be useful
18:45:26 <faxathisia> biouser: What is the ultimate purpose of these operations?
18:45:34 <biouser> sweet, mauke that is exactly what I needed, will take a moment to digest... thank you
18:45:47 <EvilTerran> pgavin, i dunno, really, i'm just throwing ideas out there
18:45:53 <pgavin> EvilTerran: heh, ok :)
18:46:23 <biouser> faxathisia, the ultimate purpose is to build large hypercubes from smaller hyperrectangle base cases
18:46:39 <EvilTerran> crike
18:46:40 <EvilTerran> y
18:46:40 <faxathisia> cool
18:46:48 <faxathisia> Haskell on Hypercubes
18:47:35 <biouser> and eventually to prove that there are knight's tours in all hyper cubes except {conditions where there are no knight's tours}
18:52:10 <biouser> just to make my brain swell in pain C:|
18:52:20 <tehgeekmeister> oh!  they're using cabal now.  i guess i get to learn how to use that now...
18:52:36 <mrd> @seen mjd
18:52:36 <lambdabot> I haven't seen mjd.
18:52:55 <tehgeekmeister> gah, no cabal for osx.  =[
18:53:10 <mrd> does mjd still come by here?
18:53:11 <pgavin> tehgeekmeister: how do you mean?
18:53:18 <EvilTerran> ?seen mjd
18:53:18 <lambdabot> I haven't seen mjd.
18:53:21 <faxathisia> tehgeekmeister: I used cabal and cabal install with mac os x
18:53:23 <pgavin> tehgeekmeister: works fine for me
18:53:27 <mrd> mark dominus
18:53:51 <tehgeekmeister> oh?  then i must not be looking in the right place, i checked darwinports
18:54:13 <tehgeekmeister> i figured it'd be a separate package.  is it not?
18:54:18 <EvilTerran> you may have to install it manually from the darcs repo
18:54:23 <dino-> I see many Haskell things licensed with BSD3, but I'm having a difficult time finding the 'home page' of this license or somewhere that I can get documents I'd need to use it. Is it this: http://www.opensource.org/licenses/bsd-license.php
18:54:24 <lambdabot> Title: Open Source Initiative OSI - The BSD License:Licensing | Open Source Initiative
18:54:25 <EvilTerran> @where cabal
18:54:25 <lambdabot> http://www.haskell.org/cabal
18:54:40 <tehgeekmeister> ah, ghc has it built in
18:54:49 <dino-> Lots of .*BSD3? licenses, but I can't find actual "BSD3"
18:54:50 <EvilTerran> (or the tarball- ah, or that.
18:54:51 <tehgeekmeister> then i just need to learn how to use it.  *reads docs
18:55:08 <dons> dino-: its the 3 clause BSD-like license.
18:55:16 <dons> which looks like this, http://code.haskell.org/xmonad/LICENSE
18:55:21 <ddarius> @seen yrllny
18:55:21 <lambdabot> I haven't seen yrllny.
18:55:25 <ddarius> @seen yrllny_
18:55:25 <lambdabot> I haven't seen yrllny_.
18:55:34 <dino-> 3 as in 3-clause, not 3 as in 3rd in the series
18:56:32 <dino-> dons: thank you
18:56:37 <dons> right. it has no advertising clause (the former 4th clause)
18:57:01 <dino-> I was confused about what the 3 meant, I see how things are referred to like 2-clause, 3-clause...
19:00:03 <biouser> can type newtype = [Int,Int,Int,Int] ?
19:00:13 <biouser> instead of (Int,Int..)
19:01:10 <dons> newtype X = X Int Int Int Int  -- ?
19:01:20 <dons> but no, since there's no list of 4 representation
19:01:25 <dons> just declare a new data structure :)
19:01:36 <dons> data X = X Int Int Int Int
19:02:47 <biouser> while we're on the subject, what is the interpreted difference between [] and ()
19:03:03 <dons> ?src []
19:03:03 <lambdabot> data [] a = [] | a : [a]
19:03:08 <dons> ?src (,,,)
19:03:08 <lambdabot> Source not found. Just what do you think you're doing Dave?
19:03:11 <dons> ?src (,,)
19:03:11 <lambdabot> Source not found. Wrong!  You cheating scum!
19:03:13 <dons> ?src (,)
19:03:13 <lambdabot> Source not found. You untyped fool!
19:03:15 <dons> grr
19:03:16 <faxathisia> > ([],(),[()],([]))
19:03:19 <lambdabot>  ([],(),[()],[])
19:03:36 <dons> one's a list of elements of a particular type, one's a structure containing exactly 4 fields, of possibly varying type
19:04:08 <biouser> [] is list right?
19:04:12 <dons> they're radically differently (lists being recursive, and of arbitrary length, for exapmle)
19:04:16 <dons> yep
19:06:30 <biouser> type newtype = [Int}
19:06:33 <biouser> type newtype = [Int]
19:06:50 <biouser> I see, then it can be of arbitrary length
19:06:55 <faxathisia> biouser, There's really two languages
19:07:09 <faxathisia> biouser, the language of Values and the one of Types
19:07:14 <dons> biouser: lists can be of arbitrary length, yep
19:07:25 <Cale> newtype is a keyword, and type constructors have to start with an uppercase letter, so you might write  type ListOfInt = [Int]
19:08:17 <biouser> at that point [Int] is probably more economical, but I am already set-up to use the new type
19:17:36 <tehgeekmeister> is there some way to use ghci on projects built with cabal, for debugging and whatnot?
19:18:41 <gwern> tehgeekmeister: do you mean how do I load in stuff installed via cabal-install? cauze just a cabalized project can be ghci'd as normal
19:19:11 <gwern> cabal-installed stuff I guess you'd just :m + as normal the desired modukes/libraries
19:20:43 <tehgeekmeister> gwern: i've just built maybench with cabal, after doing some work on it, so i know it builds, but i'm unsure how to load any of the code into ghci.  ghci chokes trying to find the other parts of the project when i just try to run ghci directly on the file i'm wanting to play with.
19:21:47 <gwern> ah. ok, I'd try cding to the top directory of the project, and then load from ghci
19:21:55 <biouser> > xw@[x,y,z,w]
19:21:55 <lambdabot>  Parse error in expression at end of input
19:21:57 <gwern> so if it calles Test.Foo, you'd want to be in ./, so Test.Foo gets turned into Test/Foo,hs
19:23:08 <tehgeekmeister> gwern: exactly what i needed!
19:23:10 <tehgeekmeister> thanks.
19:23:48 <gwern> eh. ghci can be very annoying that way. somtimes it'll staisfy imports from the installed packages, other times it is anal and insists on going by relative path
19:28:00 * gwern wonders if I should kill some time uploading hscurses
19:29:15 <dons> gwern: you could cvs checkout programmatica :)
19:29:34 <dons> http://www.ohloh.net/projects/12465
19:29:35 <lambdabot> Title: Programatica - Ohloh
19:29:50 <gwern> dons: programmatica is scary
19:29:50 <radetsky> gwern: are you on sl4?
19:30:02 <gwern> radetsky: ayup
19:30:13 <dons> gwern: its hard to think of a bigger chunk of possibly viable code
19:30:16 <radetsky> ok
19:30:18 <dons> but the size makes it intimidating
19:30:19 <radetsky> just curious
19:30:24 <dons> what about HaRe ?
19:30:42 <dons> or haskell-all-in-one (?)
19:30:47 <gwern> it's on my list; iirc, it's nontrivial to update
19:30:47 <wy> I guesses the syntax really mattered to the eyes because I found that only more than three consequtive newlines between methods can make Java code more readable, and I also need to put newlines inside blocks occasionally.  Haskell needs less such thing, while Lisp  doesn't seem need any newlines at all.
19:30:54 <gwern> haskell-all-in-one?
19:31:02 <dons> yeah, one of hall daume's projects
19:31:10 <dons> takes a haskell set of modules, and rewrites them into a single module
19:31:15 <dons> for better optimisatoin magics
19:31:24 <gwern> ah http://www.cs.utah.edu/~hal/HAllInOne/index.html
19:31:24 <lambdabot> Title: Haskell All-In-One
19:31:27 <faxathisia> If you write all your code on one line it's totally unreadable...
19:31:30 <dons> ah that's it
19:31:51 <gwern> dons: does it allow for much optimization? I didn't think GHC's cross-module optimization was that much worse than intra-module
19:32:26 <wy> faxathisia: haha that's exagerated. I meant blank lines
19:32:34 <dons> there's definitely some things that don't work across modules
19:32:39 <dons> but less so than when Hal wrote this tool
19:32:43 <dons> probably a lot less so
19:32:56 <gwern> holy cow, it cut NHC times by 2/3rds? wow, maybe incremental compilation isn't worth the performance hit...
19:33:10 <newsham> hey dons
19:33:57 <dons> it'd be interesting to see modern results
19:34:12 <gwern> 'This code is licensed under the Big-Kazooba-Ritual license' <-- ...
19:34:42 <dons> heh
19:34:44 <hpaste>  gwern pasted "license" at http://hpaste.org/6068
19:34:44 <dons> that's right.
19:34:59 <gwern> 'If you ever meet one of the authors of this work you can be asked,
19:34:59 <gwern> and must comply, to perform the ritual as described in section a.
19:35:15 <dons> that's fun
19:35:25 <dons> i've not met the authors yet, afaik
19:35:34 <gwern> this - this actually present a bit of a dilemma. I'm not sure how to put it within the context of the 4 freedoms and the free software definition
19:35:53 <tehgeekmeister> i have a function of type bench :: Maybe (IO a) -> IO b -> Maybe (IO c) -> Int -> IO Benchmark, where i don't care at all about if a, b, and c are all the same or different types (i don't use any of the results of the actions), but it appears that having three separate type variables restricts any two of the actions from having the same type inside -- how do i get past this?
19:35:53 <dons> the freedom not to do silly things?
19:36:15 <gwern> I mean, you have freedom 0, since you can run it for any purpose
19:36:32 <glguy> that wouldn't make it into a debian distro :)
19:36:33 <gwern> freedom 1 and 2, as distribution and moficiation are not limited
19:36:50 <gwern> and freedom 3 as derivatives are allowed to be as free
19:36:52 <EvilTerran> tehgeekmeister, that shouldn't be the case
19:37:09 <gwern> glguy: what would apply?
19:37:13 <tehgeekmeister> EvilTerran: shall i hpaste the exact error, since i seem to be misreading it?
19:37:15 <EvilTerran> (a,a) is a subtype of (a,b)
19:37:19 <EvilTerran> sure, go ahead
19:37:20 <glguy> (and GNU is hardly the authority on freedom)
19:37:45 <tehgeekmeister> EvilTerran: oh, no, i found the problem -- don't know how to solve it tho, hpasting.
19:37:48 <gwern> dons: oh, and I found out what happened to haste. as people suspected, the authors abandoned it after classes. apparently kolmodin's archive was pretty much the last few revisions
19:37:49 <newsham> wait.. it says "free" right in their name!
19:38:23 <gwern> glguy: they may not be the authority, but short of taking a few years to go to law school and study the issues, I'm more than happy to follow whatever they or debian say
19:38:53 <glguy> yikes
19:39:43 <hpaste>  tehgeekmeister pasted "problem with types." at http://hpaste.org/6069
19:40:21 <glguy> tehgeekmeister:
19:40:22 <glguy> :t maybe
19:40:25 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
19:40:37 <glguy> the b's have to match
19:40:49 <glguy> in your case: maybe (return ()) id setup
19:40:49 <tehgeekmeister> glguy: i know that, the issue is how to get around that.
19:40:53 <EvilTerran> tehgeekmeister, try maybe (return ()) (const $ return ())
19:41:08 <EvilTerran> er, rather, maybe (return ()) (>> return ())
19:41:16 <glguy> that looks an awful lot like: just  >> return ()
19:41:18 <tehgeekmeister> EvilTerran: that should do it.  *tries
19:41:21 <faxathisia> is there any haskell function that's bijective from powerset of Q to R?
19:41:25 <glguy> ah
19:42:03 <glguy> :t maybe (return ()) (>> return ())
19:42:04 <lambdabot> forall (m :: * -> *) a. (Monad m) => Maybe (m a) -> m ()
19:42:26 <EvilTerran> faxathisia, er, i think in theory...
19:42:38 <faxathisia> I want to see it
19:42:44 <tehgeekmeister> EvilTerran: that solved it, thanks.
19:42:53 <EvilTerran> okay, well, there's the "simplicity" ordering on Q
19:43:01 <EvilTerran> which lets you put Q in bijection with N
19:43:10 <faxathisia> is that going by diagonals?
19:43:12 <EvilTerran> er... oh, wait, you said bijection
19:43:28 <glguy> tehgeekmeister: make sure you use the suggestion without the const
19:43:30 <EvilTerran> that's independent of the standard numeric axioms, isn't it?
19:43:55 <EvilTerran> whether #P(N) = #R
19:44:30 <faxathisia> EvilTerran, well that's what I'd like to see a proof of, in haskell
19:44:32 <faxathisia> :p
19:44:33 <EvilTerran> well, it's the Continuum hypothesis, if i'm right
19:44:51 <tehgeekmeister> glguy: yeh, the (>> return ()) one is what i used, since it's what i wanted.
19:45:05 <OceanSpray> how do I do inheritance?
19:45:07 <faxathisia> oh I see
19:45:09 <EvilTerran> but you can inject P(Q) into R fairly easily
19:45:27 <OceanSpray> I got spheres and planes and polygons, and they all have reflectivity and color
19:45:31 <faxathisia> the Continuum hypothesis is not known to be true or false
19:45:32 <EvilTerran> you use the bijection i mentioned above to convert your subset of Q into a subset of N
19:45:47 <OceanSpray> would be nice if there was a "super data" to hold those values.
19:46:27 <EvilTerran> then have the product of the primes at those indices in the list of primes. or something.
19:46:49 <faxathisia> I'm confused :S
19:47:08 <EvilTerran> never mind, i think i just injected P(N) into N, which is impossible
19:47:22 <faxathisia> hehehe
19:47:39 <ddarius> gwern: Yeah.  The license on Haskell All-in-one caused issues much earlier.
19:47:58 <ddarius> OceanSpray: Making pictures yet?
19:47:58 <gwern> ddarius: oh really? ln pls
19:48:20 <OceanSpray> ddarius, nah, I had homework to do.
19:48:41 <EvilTerran> ?type Set.fold (+) 0 . Set.map (2^)
19:48:42 <lambdabot> Couldn't find qualified module.
19:48:47 <EvilTerran> ?type S.fold (+) 0 . S.map (2^)
19:48:48 <lambdabot> forall a a1. (Ord a, Integral a1, Num a) => S.Set a1 -> a
19:49:12 <faxathisia> hmmmm..
19:49:15 <EvilTerran> someone explain to me why that doesn't inject from P(N) to N
19:49:33 <EvilTerran> oh, wait, infinite subsets. yeah.
19:50:13 <dolio> Yeah, those'll cause a problem.
19:50:43 <dolio> Incidentally, |P(N)| = |R| isn't the continuum hypothesis.
19:50:46 <faxathisia> I guess the biggest problem with trying to prove this is actually constructing R
19:50:47 <EvilTerran> you can stop panicking guys, i didn't just break maths
19:50:58 <dolio> It's that there's no infinite set with cardinality between N and R.
19:51:04 <EvilTerran> dolio, i was under the impression one implied the other
19:51:53 <faxathisia> I want P(Q) -> R
19:51:57 <faxathisia> I want P(Q) <-> R *
19:52:19 <dolio> I think |P(N)| = |R| is true and uncontroversial (could be wrong).
19:52:29 <EvilTerran> faxathisia, well, P(Q) is the same size as P(N), but i find P(N) slightly easier to comprehend
19:52:49 <faxathisia> There's no proof yet
19:52:52 <EvilTerran> dolio, i know #P(N) <= #P(R), but i wasn't sure if the equality was known
19:53:01 <faxathisia> so .. neither is easier to understand\\\\\
19:53:14 <EvilTerran> faxathisia, eh. there's varying levels of confused. :)
19:53:19 <faxathisia> haha
19:53:21 <dolio> The continuum hypothesis is (somehow) provably independent of the other axioms of set theory.
19:53:32 <dolio> As I recall.
19:53:47 <faxathisia> what about i Type Theory?
19:54:44 <dolio> Don't know. If you're talking about Haskell functions, aren't you going to run into problems with computing all reals?
19:55:02 <faxathisia> I'm not convinced that's a problem
19:55:19 <EvilTerran> get oleg to do it at the type level
19:55:27 <dolio> I seem to recall roconnor having some proof in coq that the computable reals are countable.
19:55:44 <dolio> Or something related to that.
19:55:50 <faxathisia> I can do that in haskell :P
19:56:05 <EvilTerran> you can find a finite encoding (as a program) of anything computable
19:56:06 <faxathisia> 1 ser
19:56:18 <EvilTerran> there's a countable number of finite programs in any programming language
19:56:24 <EvilTerran> and hence a countable number of outputs
19:56:35 <dolio> Although maybe if your function never completes for uncomputable reals, you could say you have a bijection.
20:01:34 <faxathisia> How does P(Q) relate to R?
20:02:04 <dolio> Anyhow, can't you put a real in [0,1) in correspondence with, say P({0-9}xN), which could be viewed as an encoding of its decimal expansion?
20:02:10 <EvilTerran> faxathisia, same way P(N) does
20:02:32 <faxathisia> I think you want split it into 3 sets
20:03:23 <faxathisia> finite monotonic, infinite converging and everything else
20:03:31 <dolio> And then you hand wave and say the cardinality of [0,1) is the same as the cardinality of R.
20:04:15 <faxathisia> dolio, well f(x) = 1/x is bijective
20:04:22 <faxathisia> so you don't need to hand wave there
20:04:45 <dolio> Ah, well, there you go.
20:04:58 <dolio> You have to hand wave if you're like me and don't remember how to do it. :)
20:05:39 <faxathisia> ok but the problem is now, do these decimal expansions biject with R?
20:06:16 <hpaste>  tehgeekmeister pasted "error I'm utterly confused by when attempting to record patch to maybench." at http://hpaste.org/6070
20:07:53 <dolio> Well, suppose you use lists instead...
20:08:30 <faxathisia> > concatMap (flip replicateM "0123456789") [1..]
20:08:31 <lambdabot>  ["0","1","2","3","4","5","6","7","8","9","00","01","02","03","04","05","06",...
20:08:47 <faxathisia> these are all computable.. then again they are all finite
20:08:53 <tehgeekmeister> the error i just hpasted has to do with the cabal file for maybench-core, and while i worked on maybench-core, i didn't touch the cabal file at all, so i'm lost...
20:09:13 <mauke> tehgeekmeister: looks like your cabal is too old
20:09:37 <tehgeekmeister> oh?
20:09:43 <tehgeekmeister> i have ghc 6.8.2
20:09:43 <faxathisia> can you actually write a function that turns "0123456789" into every infinite set of those digits?
20:11:05 <tehgeekmeister> mauke: i actually have two versions of ghc, tho, 6.6 something, and 6.8.2, and i've got ghc aliased to 6.8.2 in my shell, so might it be that darcs is looking at the wrong ghc?
20:11:08 <wagle_home> no
20:11:14 <dolio> I doubt it.
20:11:32 <wagle_home> if you could, you could enumerate the reals
20:11:38 <dolio> At least, not a computable function.
20:11:45 <faxathisia> > map (++ cycle "0") . concatMap (flip replicateM "0123456789") $ [1..]
20:11:48 <lambdabot>  ["00000000000000000000000000000000000000000000000000000000000000000000000000...
20:11:49 <mauke> tehgeekmeister: judging from http://haskell.org/haskellwiki/Xmonad/Frequently_asked_questions#Cabal:_Executable_stanza_starting_with_field_.27flag_small_base_description.27 , yes
20:11:51 <faxathisia> because that aint it..
20:11:51 <lambdabot> http://tinyurl.com/3a2duf
20:14:17 <dolio> But P({0-9}xN) would, essentially, contain such lists.
20:14:59 <dolio> Unless you're doing constructive mathematics, I suppose.
20:16:45 <tehgeekmeister> mauke: so darcs has support for automatically checking if the patch builds before recording it?
20:16:56 <mauke> yes
20:18:09 <gwern> tehgeekmeister: it runs specified shell commands, and only if they exit with 0 records a patch, if thats whatyou mean
20:18:26 <tehgeekmeister> gwern: that's close enough
20:18:53 <tehgeekmeister> what method does one use to submit a patch to a darcs repository at code.haskell.org?
20:19:12 <tehgeekmeister> i tried darcs push and that appears not to work.
20:19:20 <mauke> darcs send?
20:19:36 <mauke> darcs push needs ssh access IIRC
20:19:54 <gwern> tehgeekmeister: darcs push requires special permissions
20:20:02 <gwern> which makes sense, as anything else is a security problem
20:20:10 <tehgeekmeister> right, that's sensible
20:21:24 <glguy>  ?seen dons
20:21:30 <glguy> ?seen dons
20:21:30 <lambdabot> dons is in #xmonad, #haskell-soc and #haskell. I last heard dons speak 45m 37s ago.
20:21:44 <gwern> darcs send just conveniently attaches a patch, so the maintainers can review it and apply it or not. you could do the same thing with a darcs send -o foo.patch, I suppose, if you then emailed the maintainer
20:22:05 <faxathisia> It seems to me like you can encode and reason with things that operate on the Reals, but you cannot actually look at them
20:23:04 <dons> glguy: yo.
20:23:10 <gwern> @hoogle GHC
20:23:11 <lambdabot> Distribution.Simple.GHC :: module
20:23:11 <lambdabot> Distribution.Compiler.GHC :: CompilerFlavor
20:23:11 <lambdabot> Distribution.Simple.GHC.PackageConfig.GHCPackageConfig :: data GHCPackageConfig
20:23:23 * gwern wonders where GlaExts went to http://www.haskell.org/ghc/docs/4.08/set/sec-glaexts.html
20:23:34 <glguy> dons: I was thinking it'd be cool for code.h.o to get a git daemon running at some point to support the git repos
20:23:49 <wagle_home> people do computability theory on the reals (super-turing computation, etc)..  i dont know much more about it though
20:24:15 <glguy> (HTTP access works fine, daemon mode is just even faster)
20:24:38 <glguy> I need to convert utf8-string at some point too
20:24:46 <gwern> @hoogle Dynamic
20:24:47 <lambdabot> Data.Dynamic :: module
20:24:47 <lambdabot> Data.Dynamic.Dynamic :: data Dynamic
20:24:47 <lambdabot> Data.Dynamic.fromDynamic :: Typeable a => Dynamic -> Maybe a
20:25:21 <gwern> IOExts? hallinone really is kinder old
20:25:29 <ddarius> 2003
20:26:03 <ddarius> I can't find the "discussion" about the license.  I think it was on the mailinglist years ago.
20:26:18 <gwern> 5 years? that's forever in haskell years</humor>
20:27:44 <gwern> well, here's an ann: http://www.cse.unsw.edu.au/~dons/haskell-1990-2006/msg14877.html
20:27:45 <lambdabot> Title: Announce: Haskell All-In-One
20:29:10 <ddarius> The context for the license issue was someone wanted to add a debian package for it.
20:30:59 <gwern> what happened?
20:31:21 <gwern> @hoogle cast
20:31:21 <lambdabot> Data.Typeable.cast :: (Typeable a, Typeable b) => a -> Maybe b
20:31:22 <lambdabot> Foreign.StablePtr.castStablePtrToPtr :: StablePtr a -> Ptr ()
20:31:22 <lambdabot> Foreign.StablePtr.castPtrToStablePtr :: Ptr () -> StablePtr a
20:32:35 <FMota> :t maybe
20:32:39 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
20:33:07 <ddarius> The person trying to package it said he couldn't due to its license and asked Hal if he could provide it under a different license.  Hal refused.  An argument developed and it was not packaged, to my knowledge.
20:33:48 <dibblego> > let f = \x -> sum (zipWith (*) (reverse (map (subtract 96 . ord) x)) (map (26 ^) [0..])) in f "aa"
20:33:50 <lambdabot>  27
20:34:00 <gwern> oh dear. in that case, before I waste any more time trying to compile it, I'll email him about the license
20:34:09 * ddarius pokes mauke.
20:35:06 <mauke> wuh?
20:36:07 <ddarius> You weren't that person who tried to package Haskell All In One.  I vaguely remember an 'm' name.
20:36:25 * gwern hadn't even heard of haskell in 2003
20:37:50 * dolio may have.
20:41:55 <dolio> In fact, I think I had.
20:42:15 <dolio> I remember trying to read the gentle introduction during down time in my summer job that year.
20:42:51 <dejones> can a <- be done only inside a do-block?
20:42:58 <faxathisia> I read a book about haskell in '05
20:43:05 <faxathisia> was not impressed :P
20:43:07 <nornagon> dejones: yes
20:43:09 <dolio> Yeah, it's part of do syntax.
20:43:12 <dejones> ok
20:43:21 <nornagon> dejones: however, you can desugar the <- yourself :)
20:43:24 <dolio> Was it the evil bird book?
20:43:32 <faxathisia> I'm not sure
20:43:34 <nornagon> @undo do { a <- action; f a }
20:43:34 <lambdabot> action >>= \ a -> f a
20:43:50 <dolio> Unless you were reading in Japanese, it probably wasn't. :)
20:43:56 <faxathisia> came back and wrote a logo a year or something later and realised how good it is
20:44:17 <dejones> nornagon: thanks.
20:45:03 <dolio> Apparently there's an evil bird book for OCaml, too.
20:45:24 <dolio> Although its bird is somewhat less evil than the Haskell birds.
20:45:40 <wagle_home> whats evil about it?
20:46:25 <dolio> http://tinyurl.com/3d79rc
20:46:36 <dolio> And CommonLisp is an evil stork.
20:46:52 <hpaste>  dejones pasted "Data.Map types issues..." at http://hpaste.org/6071
20:47:04 <dejones> I'm confused; I can't seem to figure out why my types aren't matching.
20:47:05 <faxathisia> :D
20:47:16 <faxathisia> I've seen the caml one
20:47:25 <dejones> I commented some of the code to try to simply the beginning and fix the type issues.
20:48:14 <dejones> if you add "number lines" to the hpaste, the errors do match with the line numbers.
20:48:27 <dejones> please help.  :)
20:48:27 <dejones> hehe
20:49:37 <dejones> Cale: you here?  I'm back with my code converted to Data.Map... still having type issues.  ;)
20:49:42 <dejones> @seen Cale
20:49:42 <lambdabot> Cale is in #haskell-overflow, #haskell and #ghc. I last heard Cale speak 1h 42m 16s ago.
20:50:26 <dolio> Well, at first glance, readFileToMap isn't going to work because it's doing IO, but doesn't have that in the type.
20:51:23 <dejones> dolio: I have to add the IO to the type even though it is not one of the parameters or return from the function?
20:52:19 <mauke> it is the return
20:52:40 <dolio> Well, readFileToMap shouldn't be returning a "Map String [[Double]]", it should be returning an "IO (Map String [[Double]])".
20:53:19 <dolio> To indicate that it's doing IO to get that Map.
20:53:32 <dejones> dolio: Oh.  Good point.
20:55:25 <dejones> dolio: do I need to change insertToMap parameters to IO (Map ...)  ?
20:56:24 <dolio> No, that doesn't appear to be doing IO.
20:56:26 <dolio> However.
20:57:07 <dolio> You're not really using the Maybe monad correctly there.
20:57:22 <dejones> Ok.
20:57:43 <dolio> When you do 'v <- foo :: Maybe a', v has type a.
20:58:26 <dolio> And if foo was a Nothing, that nothing is propogated forward.
20:58:53 <dolio> > do v <- Nothing ; return (v + 1)
20:58:57 <lambdabot>  Nothing
20:59:00 <dolio> > do v <- Just 5 ; return (v + 1)
20:59:05 <lambdabot>  Just 6
20:59:32 <dolio> But you want to return a new map in any case, so you don't want to use the maybe monad.
20:59:46 <ska-fan> @hoogle [(a -> b)] -> [a] -> [b]
20:59:46 <lambdabot> No matches, try a more general search
20:59:57 <dejones> dolio: I thought I had to use the Maybe monad with the Data.Map.lookup
20:59:59 <dolio> ska-fan: ap.
21:00:02 <dejones> :t Data.Map.lookup
21:00:13 <lambdabot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> M.Map k a -> m a
21:00:38 <dolio> dejones: It returns the answer as a Maybe (or arbitrary monad, really), but you don't want to use the failure-propogation of the maybe monad.
21:00:39 <mauke> > M.lookup "hi" M.empty
21:00:39 <lambdabot>   add an instance declaration for (Show (m a))
21:00:40 <faxathisia> > [(+1),(*3)] <*> [1,4]
21:00:41 <lambdabot>  [2,5,3,12]
21:00:45 <faxathisia> > [(+1),(*3)] <$> [1,4]
21:00:46 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `[a1]'
21:00:47 <shachaf> dejones: You have to use a monad, and Maybe is what you use most often.
21:00:55 <faxathisia> > [(+1),(*3)] `ap` [1,4]
21:00:56 <lambdabot>  [2,5,3,12]
21:00:56 <dolio> dejones: You just want to do case analysis on it.
21:00:59 <shachaf> dejones: But you don't have to think of Maybe as a monad for it.
21:01:08 <mauke> > case M.lookup "hi" M.empty of Just x -> x; Nothing -> "No such luck"
21:01:09 <lambdabot>  "No such luck"
21:02:05 <FMota> > maybe "No such luck" id $ M.lookup "hi" M.empty
21:02:06 <lambdabot>  "No such luck"
21:02:13 <andyjgill> Is there anyone here with sysadmin access to code.haskell.org?\
21:03:41 <dejones> hmm.
21:04:27 <dejones> I guess I don't understand why my if/else doesn't work for the Maybe case analysis?
21:04:49 <mauke> if/else doesn't do case analysis
21:04:56 <mauke> well, it does on Bools
21:05:04 <dolio> When you do 'v <- ...' v is no longer a Maybe a.
21:05:05 <dejones> mauke: well, I have the (isNothing v)
21:05:07 <dolio> It's just an a.
21:05:22 <dejones> Oh.
21:07:45 <dejones> But, why don't I have to use the Maybe monad with lookup?  :/  I thought the type required the use of a monad for lookup.
21:08:15 <mauke> Maybe is a monad, so you can use it
21:08:23 <mauke> that doesn't mean you have to use do-notation or <-
21:08:52 <dolio> It returns things in a monad to denote possible failure.
21:09:19 <dolio> (Which should really be MonadPlus (Zero), but that's another matter.)
21:13:41 <ska-fan> Is there a shorter way to write \f l r -> [x y | (x, y) <- zip (map f l) r] ?
21:14:13 <mauke> @undo [x y | (x,y) <- zip a b]
21:14:13 <lambdabot> concatMap (\ (x, y) -> [x y]) zip a b
21:14:31 <mauke> @. pl undo \f l r -> [x y | (x, y) <- zip (map f l) r]
21:14:31 <lambdabot> ((uncurry (flip flip [] . ((:) .)) =<< zip) .) . map
21:14:45 <shachaf> @ty \f l r -> [x y | (x, y) <- zip (map f l) r]
21:14:47 <lambdabot> forall a b t. (a -> b -> t) -> [a] -> [b] -> [t]
21:15:09 <mauke> :t zipWith
21:15:10 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
21:15:28 <ska-fan> zipWith, mhm
21:15:36 <mauke> ska-fan: wow. how did you come up with that version?
21:15:50 <ska-fan> well
21:15:51 <faxathisia> > zipWith (+) [1,2,3] [4,5,6\]
21:15:51 <lambdabot>  Parse error at "\]" (column 27)
21:15:53 <ska-fan> I was reading gentle
21:15:54 <faxathisia> :(
21:16:03 <mauke> I mean, \f l r -> [f x y | (x, y) <- zip l r] is a lot more obvious
21:16:23 <ska-fan> I was playing with (+), (+1) and (1+)
21:16:29 <dolio> @type \f l r -> [ f x y | x <- l | y <- r ]
21:16:31 <lambdabot> forall t t1 t2. (t1 -> t -> t2) -> [t1] -> [t] -> [t2]
21:16:33 <ska-fan> so I at first had f = (+1)
21:16:46 <dolio> Huh, that's a surprise.
21:17:25 <shachaf> dolio: I think Cale enabled more extensions.
21:17:55 <ska-fan> I guess my real question is another:
21:17:56 <dolio> shachaf: I was kind of expecting lambdabot to puke on the extra |, but I guess it doesn't try to parse @types with one of its extra parsers.
21:18:41 <ska-fan> A shorter \f r -> [x y | (x, y) <- zip f r]
21:19:03 <shachaf> dolio: Oh, right, @run doesn't like | |.
21:19:19 <faxathisia> what
21:19:24 <faxathisia> I thought you have to use .
21:19:27 <faxathisia> ,
21:19:45 <ska-fan> So I have a list of functions and a list of values and I want to apply them to each other one by one
21:19:59 <faxathisia> :t map (uncurry ($))
21:20:00 <lambdabot> forall a b. [(a -> b, a)] -> [b]
21:20:10 <shachaf> @ty zipWith ($) -- ?
21:20:11 <lambdabot> forall a b. [a -> b] -> [a] -> [b]
21:20:29 <faxathisia> > map (uncurry ($)) $ zip (repeat f) [a,b,c,x,y,z] :: [Expr]
21:20:31 <dolio> @type \f r -> getZipList $ ZipList f <*> ZipList r
21:20:32 <lambdabot>  [f a,f b,f c,f x,f y,f z]
21:20:32 <lambdabot> forall a a1. [a1 -> a] -> [a1] -> [a]
21:20:37 <shachaf> @ty ap
21:20:38 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
21:20:45 <faxathisia> > map (uncurry ($)) $ zip (map f [a,b,c]) [x,y,z] :: [Expr]
21:20:46 <shachaf> @ty ap :: [a -> b] -> [a] -> [b]
21:20:48 <lambdabot> forall a b. [a -> b] -> [a] -> [b]
21:20:48 <lambdabot>  [f a x,f b y,f c z]
21:21:12 <dolio> Mine isn't shorter, of course.
21:21:54 <shachaf> It would be nice if there was an easy way to use more than one Applicative instance.
21:22:04 <faxathisia> @src zipWith
21:22:04 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
21:22:04 <lambdabot> zipWith _ _      _      = []
21:22:38 <faxathisia> :t map (uncurry (f $)) . zip
21:22:41 <lambdabot>     Couldn't match expected type `[(a, b)]'
21:22:41 <lambdabot>            against inferred type `[b1] -> [(a1, b1)]'
21:22:41 <lambdabot>     Probable cause: `zip' is applied to too few arguments
21:22:48 <hpaste>  dejones annotated "Data.Map types issues..." with "Data.Map types issues...updated, less errors.  ;)" at http://hpaste.org/6071#a1
21:22:52 <faxathisia> :t ((.).(.)) (map (uncurry (f $))) zip
21:22:54 <lambdabot> forall c a b. (SimpleReflect.FromExpr c, Show b, Show a) => [a] -> [b] -> [c]
21:23:13 <faxathisia> :t \f -> ((.).(.)) (map (uncurry (f $))) zip
21:23:14 <lambdabot> forall c a b. (a -> b -> c) -> [a] -> [b] -> [c]
21:23:16 <dejones> dolio: I updated, one error now; but, I'm confused why it is thinking the map is [Double] and not [[Double]]
21:24:38 <Tiruial> is a map a [(Double,Double)]
21:24:40 <Tiruial> ?
21:24:46 <mauke> Tiruial: no
21:24:58 <Tiruial> mauke: thanks
21:24:58 <mauke> dejones: because lookup returns m v, not v
21:25:06 <dolio> dejones: You told it: 'v = lookup ... :: [[Double]]', so it's returning the result in the [] monad, and thinks the values in the map are [Double].
21:25:38 <dejones> lol, I had no clue there was a [] monad.
21:25:55 <mauke> dejones: Maybe is just a list with at most one element
21:25:57 <dejones> should I do :: Maybe [[Double]]  ?
21:26:22 <mauke> why do you need a type annotation?
21:26:25 <dolio> dejones: As a hint, insertToMap shouldn't be a do block.
21:26:32 <dolio> And you shouldn't need to annotate any types.
21:26:33 <BMeph> ska-fan: So, did you get "ap f r" out of all that? ;)
21:26:56 <faxathisia> :t \f xs ys -> take (length xs) $ [f] <*> xs <*> ys
21:26:57 <lambdabot> forall a a1 a2. (a -> a2 -> a1) -> [a] -> [a2] -> [a1]
21:27:16 <dejones> dolio: Yea, now the insertToMap doesn't have to be a do-block, but I'm trying to fix the type error before re-ordering the code.
21:27:43 <BMeph> Or I guess to use more conventional forms, "ap fs xs"
21:27:52 <faxathisia> @src ap
21:27:53 <lambdabot> ap = liftM2 id
21:28:01 <dolio> Well, you won't be able to fix the type error without not using a do block, because insertToMap doesn't return a monadic value.
21:28:03 <dejones> dolio: yay, I got it to compile
21:28:03 <dejones> :)
21:28:09 <dejones> well, interpret with no errors.  ;)
21:28:20 <BMeph> @type zipWith2 id
21:28:21 <lambdabot> Not in scope: `zipWith2'
21:28:29 <BMeph> @type zipWith3 id
21:28:29 <FMota> I <3 ap. ap and const are my world.
21:28:30 <lambdabot> forall b c d. [b -> c -> d] -> [b] -> [c] -> [d]
21:28:39 <faxathisia> :t \f xs ys -> liftM2 f xs ys
21:28:40 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
21:28:49 <mauke> he won't without not? stack overflow
21:28:54 <faxathisia> :t \f (xs :: [a]) ys -> liftM2 f xs ys
21:28:56 <lambdabot>     A pattern type signature cannot bind scoped type variables `a'
21:28:56 <lambdabot>       unless the pattern has a rigid type context
21:28:56 <lambdabot>     In the pattern: xs :: [a]
21:29:09 <faxathisia> :t \f (x:xs) ys -> liftM2 f (x:xs) ys
21:29:10 <lambdabot> forall a1 a2 r. (a1 -> a2 -> r) -> [a1] -> [a2] -> [r]
21:29:15 <dolio> mauke: Too many negatives? :)
21:29:19 <mauke> yeah
21:29:23 <hpaste>  dejones annotated "Data.Map types issues..." with "no errors..." at http://hpaste.org/6071#a2
21:29:24 <BMeph> @ty zipWith3 id . repeat
21:29:25 <lambdabot> forall b c d. (b -> c -> d) -> [b] -> [c] -> [d]
21:29:35 <faxathisia> :D
21:29:54 <dejones> dolio: there's the update with no type errors... is it still wrong though?  will the do-block cause me future problems?
21:30:52 <BMeph> It all makes sense when you think: repeat == zipWith0; map/fmap == zipWith1; fmap == liftM
21:31:01 <dolio> I suspect it'll complain that Map isn't a monad, unless they removed the fact that 'do a' doesn't desugar to 'a'.
21:31:17 <dolio> Or, doesn't desugar to a non-type-constrained a.
21:32:00 <dejones> dolio: Ahh.
21:32:42 <dolio> Your function is effectively just a big 'let ... in if ...'.
21:33:29 <dolio> You don't really need the multiple lets, since you can bind multiple variables in a single let.
21:34:13 <dejones> dolio: Gotcha.  Yea, the function is poorly structured at the moment due to being re-written many times trying to fix the type errors. ;)
21:34:38 <dolio> I'd probably flip it into a where, myself.
21:34:46 <dejones> dolio: Mainly, I want to know, am I using the Maybe monad correctly now?
21:35:00 <dolio> Yeah.
21:35:01 <dejones> dolio: Yep, a where without the do-block was my plan.
21:35:04 <dejones> dolio: thank you.  :)
21:35:12 <dejones> I need to sleep now... early class!
21:35:17 <dejones> dolio: thank you a lot for the help.
21:35:19 <dejones> g'night.
21:35:21 <dolio> No problem.
21:35:32 <gwern> @seen fm
21:35:32 <lambdabot> I haven't seen fm.
21:35:34 <gwern> @seen sm
21:35:34 <lambdabot> I saw sm leaving #haskell and #darcs 1d 10h 1m 42s ago, and .
21:35:52 <dejones> Thank you mauke and shachaf too.
21:35:55 <dejones> G'night everyone.
21:37:58 <BMeph> Rest well, dejones. :)
21:57:21 <roconnor> @go 1 CAD in USD
21:57:21 <lambdabot> 1 Canadian dollar = 1.02145 U.S. dollars
21:58:29 <faxathisia> @go 1 attoparsec in cm
21:58:29 <lambdabot> 1 attoParsec = 3.08568025 centimeters
22:05:10 <BMeph> @go 1 ly in furlong per fortnight
22:05:11 <lambdabot> No Result Found.
22:05:16 <BMeph> Drat.
22:05:57 * dolio looks forward to reminiscing about Canadian dollar jokes being about their low value compared to the US dollar.
22:06:45 <BMeph> @go 1 light-year in furlongs per fortnight
22:06:46 <lambdabot> No Result Found.
22:07:36 <dolio> @go c in furlongs per fortnight
22:07:36 <lambdabot> the speed of light = 1.8026175 x 10^12 furlongs per fortnight
22:09:23 <glguy> dejones: You're killing me with the all the parentheses in your if statements :)
22:10:05 <dolio> :) Yeah, he doesn't trust the parser yet.
22:10:10 <falbani> Hi
22:10:25 <glguy> return (map) -- mind crashes
22:10:46 <falbani> I have a simple question about Binary files & Haskell
22:12:06 <falbani> How simple/difficult is to write a simple tool for duplicating a file (or moving, just like cp and mv) without using external calls to shell (or things like that) ?
22:12:53 <BMeph> dolio: Thanks! :)
22:13:19 <falbani> I am trying to understand "hGetBuf" and "hPutBuf", but I can't figure how to work with the type (Ptr a)...
22:13:49 <dibblego> can I have #!/usr/bin/runhaskell at the top of a source file and have haddock run over it?
22:15:57 <BMeph> I wonder how many Project Euler questions can be solved with the GOogle calculator? ;)
22:16:44 <glguy> BMeph: that answer could probably found in google calculator
22:16:57 <BMeph> glgut: lol
22:18:41 <Riastradh> Suppose I have a class `C a' with a method `x :: a', a type `T' with an instance `C T', and a function `f :: C a => [something involving a's]'.  I want to refer to the `x' appropriate for whatever input I supply to `f'.  However, I cannot, in the body of `f', write `x :: a', because the type variable `a' does not refer to `f's type declaration.
22:19:53 <Eiler> > * 4 5
22:19:55 <lambdabot>   parse error on input `*'
22:20:14 <ddarius> cat = interact id
22:21:14 <Riastradh> If I happen to have an expression of the desirable type `a' within `f', then I can define a dummy function, x' :: C a => a -> a; x' _ = x, and use that in `f'.  This seems awfully clumsy.
22:21:27 <ddarius> Riastradh: You can use the lexically scoped type variables extension, or some variant of asTypeOf
22:23:04 <Riastradh> I had forgotten about `asTypeOf'.  It is equivalent to the introduction of a dummy function, though, and again requires an expression of the desired type `a'.
22:23:18 <Riastradh> Is there no way to accomplish this short of this lexically scoped type variable extension?
22:23:39 <ddarius> You can usually get an expression of type 'a', it doesn't have to be well-defined.
22:24:27 <ddarius> E.g. if you had f :: C a => [a] -> [a]; f ys = [x `asTypeOf` head ys]
22:24:50 <Riastradh> I suppose I can't think of a case off the top of my head where it would be difficult to obtain an expression of the appropriate type, although it does not seem an impossible situation.
22:25:05 <hpaste>  biouser pasted "Knight's Tours in 4d" at http://hpaste.org/6072
22:25:39 <ddarius> It can sometimes get round about.  I'm not sure if there is a case where it's completely impossible without lexically scoped type variables.  I suspect there isn't such a case.
22:25:54 <biouser> I am wondering how I can adapt this code to have finish= knightMoves start
22:26:06 <boyscared> > (*) 4 5
22:26:11 <lambdabot>  20
22:26:41 <ddarius> f :: C a => Int -> a; f _ = result where result = x `asTypeOf` result
22:27:44 <biouser> right now finish must be explicitly defined in the program
22:27:55 <ddarius> Actually I guess that's unnecessary in this case, but there are cases where such conivances are the most obvious solution.
22:28:42 <lispy> I think there are times when lexically scoped type variables are necessary if you have existentials
22:30:43 <wy> any ideas on the yield operator of python? what's the nature of it?
22:31:18 <Riastradh> The nature of it is a limited application of delimited continuations.
22:34:18 <boyscared> foldl (\ x -> (+) x) 0 [1,3,4]
22:34:35 <boyscared> > foldl (\ x -> (+) x) 0 [1,3,4]
22:34:38 <lambdabot>  8
22:34:57 <wli> > foldl (+) 0 [1,3,4]
22:34:57 <lambdabot>  8
22:37:40 <lispy> doesn't knuth have a different name for the concept represented by yield?
22:39:56 <wy> Riastradh: I don't know about delimited continuations. Is it something good?
22:40:19 <dolio> They're great.
22:40:19 <wy> lispy: is it from knuth?
22:41:25 * lispy goes to look it up
22:42:34 <lispy> ah, I'm thinking of coroutines.  May not be exactly the same concept.
22:43:40 <dolio> Similar.
22:44:21 * lispy owns a copy of taocp but is guilty of only skimming some parts
22:45:19 <lispy> I've love to spend a few years really understanding them.
22:45:58 <dolio> Isn't he coming out with a new volume some time soon?
22:46:34 <boyscared> aren't a lot (all?) of the examples in assembly?
22:47:12 <dolio> They're in some custom Knuth pseudocode, aren't they?
22:47:20 <wy> boyscared: yes, they are now in another assembly
22:47:56 <wy> I won't bother reading his books anymore. I believe he is the one who is hiding the truth
22:48:17 <boyscared> wouldn't that make it a bit hard to follow along?
22:48:52 <wy> I noticed that all his programs are littered with global variables etc and he refuse to upgrade to the new generation
22:49:41 <wy> so he needs to have his program "frozen", because he is likely to introduce new bugs in it if he ever add new features
22:49:55 <dolio> I guess it's pseudo assembly, although people have implemented virtual machines, I think.
22:50:15 <lispy> Yes, it's the MIX ar MMIX archtecutres
22:50:19 <dolio> Or were there actually chips?
22:50:34 <wy> I would be still a fan of knuth if I hadn't read sicp
22:50:42 <lispy> dolio: I bet there are geeks with it on FGPA boards, but I could doubt chips.
22:50:52 <boyscared> i'd think that'd be a waste of time trying to decifer what the code was actually doing. plus, you couldn't actually type it in and run it.
22:50:54 <lispy> FPGA*
22:51:18 <lispy> I don't read the books for the code
22:51:27 <dolio> There's a CPAN module for it, it seems.
22:51:36 <lispy> they are great encyclopedias of how algorithms work
22:51:59 <wy> I don't think his book is about that
22:53:26 <wy> most of the things he said is true, but he put them into a format so that nobody could know how they can be derived
22:54:36 <lispy> I admit, since he wanted to avoid using a platform that is a moving or die target, he choose to go from the ground up.  He just didn't build high enoguh before he started giving code.
22:54:37 <faxathisia> like Euler
22:54:38 <faxathisia> wy
22:54:43 <faxathisia> ?
22:55:33 <wy> faxathisia: I didn't know that Euler is such a guy
22:55:44 <wy> but I guess I would like Skolem
22:57:43 <lispy> one thing I meant to do at some point was to port all the psuedo code in his books to haskell.  I completely forgot about that project until just now.
22:59:16 <dolio> You'd best get cracking, then. :)
23:01:30 <falbani> Anyone who log in recently can help me with binary files stuff?
23:04:08 <wy> I guess some knowledge is like in source code, some knowledge is like in compiled assembly. and some authors put compiled knowledge into books and make the impression to people that there are endless stuff to learn
23:04:23 <Cheery> can you tell me, what does it compile so long when I compile the ghc?
23:04:57 <Cheery> is it just the libraries?
23:05:25 <falbani> How simple/difficult is to write a simple tool for duplicating a file (or moving, just like cp and mv) without using external calls to shell (or things like that) ?
23:05:31 <falbani> I am trying to understand "hGetBuf" and "hPutBuf", but I can't figure how to work with the type (Ptr a)...
23:05:39 <roconnor> Cheery: are you doing -O2?
23:05:55 <dolio> falbani: I can take some guesses. What exactly aren't you getting?
23:06:10 <Cheery> actually, right now doing nothing, but just asking what did take so long last time when I compiled
23:06:21 <Cheery> I don't remember doing -O2
23:06:30 <roconnor> hmm, strange
23:06:43 <Cheery> does it today compile fast?
23:06:45 <roconnor> wait, are you compiling with ghc, or compiling ghc itself?
23:07:32 <falbani> dolio: I previously worked with openFile and writeFile for text files, and I was expecting something similar for binary files, but... analog functions have an extra parameter of type (Ptr a) that I don't know how to handle....
23:07:58 <Cheery> roconnor: I've no problems with it
23:08:03 <dolio> falbani: Look for mallocBytes in Foreign.Marshal.Alloc, I'd say.
23:08:42 <falbani> dolio: and after some google searching, I got the idea that this kind of thing are not easy in Haskell... Is that right?
23:08:44 <mrd> falbani: perhaps take a look at Data.ByteString.Char8
23:08:57 <Cheery> before I've been afraid from looking inside because it took so long to compile, and things that take long to compile often are complex enough to bypass my understanding
23:08:59 <dolio> falbani: Haven't tried it myself.
23:09:09 <falbani> dolio, mrd: thanks, i will read that
23:09:13 <mrd> falbani: that will give you an easy interface
23:09:23 <roconnor> Cheery: what are you compiling?
23:09:59 <mrd> @hoogle readFile
23:09:59 <lambdabot> Prelude.readFile :: FilePath -> IO String
23:09:59 <lambdabot> System.IO.readFile :: FilePath -> IO String
23:09:59 <lambdabot> Data.ByteString.readFile :: FilePath -> IO ByteString
23:10:59 <mrd> falbani: mind you, there is also a POSIX interface
23:11:11 <falbani> mrd, does ByteString has something like an official site?
23:11:13 <mrd> that will probably have a rename() somewhere
23:11:15 * RayNbow recently tried compiling GHC/Readline [ http://kayalang.org/download/compiling/windows/readline ], but failed... :p
23:11:15 <lambdabot> Title: Kaya: Haskell Readline library on Windows
23:11:31 <mrd> falbani: well the docs are in the standard spot, haskell.org under standard libs
23:11:48 <mrd> @hoogle rename
23:11:53 <lambdabot> Language.Haskell.TH.Lib.rename :: Pat -> Q ([(Name, Name)], Pat)
23:11:53 <lambdabot> System.Directory.renameDirectory :: FilePath -> FilePath -> IO ()
23:11:53 <lambdabot> System.Directory.renameFile :: FilePath -> FilePath -> IO ()
23:12:16 <falbani> http://www.cse.unsw.edu.au/~dons/fps.html <-- I was looking for this :)
23:12:17 <lambdabot> Title: Data.ByteString
23:12:26 <mrd> yea, but it's part of GHC now
23:12:32 <Cheery> hm. it appears somebody has divided ghc to base libs and extralibs
23:13:05 <roconnor> GHC is quite compicated.
23:13:13 <roconnor> YHC is presumably simpler.
23:13:23 <falbani> mrd: The only thing I known about ByteString is that is a better choice when performance matters... but I did not known it can be used for binary reading...
23:13:40 <mrd> falbani: well it operates on Word8s so, there's no decoding going on
23:13:50 <mrd> falbani: under the hood it's using Ptrs and stuff
23:16:19 <Cheery> if I install ghc as user, does it install into correct location?
23:16:37 <Cheery> eg. ~/bin etc.
23:16:51 <glguy> it installs to wherever you tell it to
23:17:03 <dons> falbani: yeah, use Data.ByteString (or Data.ByteString.Char8), or perhaps look at Data.Binary
23:21:06 <gour> dons: hi, i've problem with mkcabal: ./mkcabal.hs:398:4-26: Non-exhaustive patterns in function pair. pair [x,y]  = (x,y) in queryAuthorNameMail
23:21:34 <gour> it fails after entering Category
23:24:08 <b_jonas> gour: that's just a warning. are you sure it causes a problem?
23:24:39 <gour> b_jonas: yes, the program dies without asking for name & email
23:25:09 <Cheery> hm. has taken already couple ten minutes to compile
23:25:23 <Cheery> Is it just big or complex to compile?
23:25:26 <glguy> Cheery: have you compiled any other compilers before?
23:25:37 <b_jonas> oh, so it's not the warning, but the error when the function's got a patter it's not defined on
23:25:40 <hpaste>  morrow annotated "adjunctions" with "yay categories" at http://hpaste.org/6060#a4
23:25:43 <b_jonas> the classic domain error
23:25:48 <b_jonas> sorry
23:26:05 <Cheery> glguy: not really big ones too often
23:26:16 <Cheery> glguy: does they all take this long to compile? gcc and such?
23:26:48 <roconnor> I would sort of expect ghc to take upto hours to compile.
23:26:51 <b_jonas> yep, gcc takes long to compile
23:27:08 <b_jonas> gcc takes much both because it's large and because it's compiled three times
23:27:14 <glguy> Cheery: all big programs take a while to compile :)
23:27:18 <Cheery> at least most lisp things have taken long to compile, I remember. :)
23:27:19 <b_jonas> ghc takes a lot to compile because it's compiled by ghc which is slow
23:27:29 <roconnor> b_jonas: :)
23:27:37 <roconnor> funny because it is true.
23:27:46 <faxathisia> GHC takes longer than SBCL
23:27:46 <b_jonas> in my experience, gcc takes much more time to compile than a linux kernel
23:27:57 <b_jonas> but there are ones that take even more than gcc
23:28:05 <b_jonas> most notable glibc
23:28:09 <glguy> the 6.8 compilers are noticably faster than 6.6 and 6.4
23:28:18 <b_jonas> glibc takes a lot
23:28:29 <glguy> (due in large part to defaulting to the code generator over gcc)
23:28:52 <Cheery> is it better for me to use 6.6 if it's coming with my distribution?
23:28:59 <b_jonas> glguy: why does that make it faster? gcc is really fast compiling C
23:29:00 <glguy> ubuntu?
23:29:06 <Cheery> debian
23:29:10 <Cheery> (etch)
23:29:24 <RayNbow> protip: compile your compilers when you go to bed :p
23:29:31 <glguy> Cheery: running the stable release of debia nseems like a really good way to always be out of date
23:29:49 <b_jonas> glguy: oh, don't be like that
23:29:54 <b_jonas> it's quite a good system
23:29:59 <glguy> and always out of date
23:30:05 <Cheery> wondering, there were that apt-source for 6.8
23:30:08 <glguy> that's the only claim I made
23:30:17 <Cheery> would it be safe to use that to replace the current 6.6?
23:30:25 <b_jonas> but I found that using it as a base and upgrading only the parts where you really need the leading edge is good
23:30:50 <b_jonas> because you get a stable base system with no problems and only have to install the few things you need so it doesn't even take much time to set up
23:30:53 <glguy> when I want git 1.5.x.x I don't want to have to go out of my way
23:30:57 <glguy> I just want to install it
23:31:09 <Cheery> thought, from just simple curiosity going to compile it anyway
23:31:25 <b_jonas> glguy: yup, but _how many_ packages are there where you care about the version so much?
23:31:39 <glguy> enough that manually tracking them defeats the point
23:31:47 <glguy> of having a package manager to track them
23:31:51 <b_jonas> it's about ten or twenty for me (depeding on sarge or etch)
23:32:01 <glguy> 10/20 is way too much to manually track
23:32:01 <b_jonas> certainly no
23:32:12 <b_jonas> have you tried to install everything without a  package manager?
23:32:18 <glguy> yeah
23:32:34 <b_jonas> I haven't, but I think I have some idea how tedious it would be from when I half did that
23:32:47 <glguy> fortunately other distros eliminate all of the tedium
23:32:52 <b_jonas> it's not really the package manager
23:32:56 <glguy> anyway
23:33:02 <glguy> I'm not trying to convince anyone about debian
23:33:10 <b_jonas> but a stable set of packages that work together
23:33:15 <b_jonas> which counts
23:33:28 <glguy> which isn't to say that the other distros don't have that
23:33:30 <glguy> just that debian does
23:33:44 <b_jonas> glguy: sure, I'm just http://xkcd.com/386/-ing
23:33:57 <Cheery> ghc-6.8.2-src-extralibs  what does this thing contain?
23:34:09 <glguy> b_jonas: I haven't said anything wrong yet :)
23:34:22 <glguy> assuming that's the image I think it is
23:34:26 <b_jonas> Cheery: mtl
23:34:29 <b_jonas> and things like that
23:34:46 <b_jonas> some important libraries from cabal
23:35:00 <b_jonas> but ones that are not considered strictly core nor needed for ghc compilation
23:35:12 <Cheery> do I need them?
23:35:22 <b_jonas> probably, unless you're short on disk space
23:35:27 <b_jonas> you'll need some of them
23:35:28 <glguy> You can install them after the fact
23:35:30 <hpaste>  Cin pasted "r is [] like this, but contains results when I print it out. What's all that about?" at http://hpaste.org/6075
23:35:33 <glguy> when you find out you need one
23:36:00 <b_jonas> yep, you can install any cabal package later when you find out which one you need
23:36:26 <b_jonas> but then it will be like people typing a simple example here and you wondering why you cannot import whatever module it needs :)
23:36:26 <Cheery> so extralibs contain nothing that I couldn't install later..
23:36:38 <cin> glguy: any idea what that's all about?
23:36:54 <b_jonas> Cheery: yep
23:37:01 <b_jonas> you can install mtl and anything else later
23:37:05 <glguy> cin: it isn't quite clear to me what you are asking
23:37:37 <b_jonas> Cheery: here's how to, in fact: http://www.haskell.org/haskellwiki/How_to_install_a_Cabal_package
23:37:37 <lambdabot> Title: Cabal/How to install a Cabal package - HaskellWiki
23:37:46 <Cheery> > reverse "taclol"
23:37:53 <lambdabot>  "lolcat"
23:38:02 <cin> glguy: oh. i'm using sqlite3. with the quickQuery function. i'm show'ing it in my page. it's showing it as empty list [], but when i print it out before hand with putStrLn, it shows as a non-empty list, which is correct
23:38:23 <glguy> what library does quickQuery come from?
23:38:28 <cin> glguy: HDBC
23:38:56 <glguy> cin: maybe it's some weird interaction with laziness
23:39:00 <cin> glguy: i'll try to reproduce it in a simple file
23:39:03 <glguy> could you try to check the length
23:39:09 <cin> glguy: i thought that
23:39:13 <glguy> in place of printing it to screen
23:39:21 <cin> glguy: yeah, okay, one sec
23:39:34 <glguy> since HDBC's fetchAllRows is lazy by default
23:39:46 <glguy> and fetchAllRows' is strict (or something quite similar)
23:40:08 <Cheery> > putStrLn "foobar"
23:40:13 <lambdabot>  <IO ()>
23:40:19 <Cheery> .. :)
23:40:36 <cin> glguy: yeah, it works when i check the length. definitely laziness. but why []? hm. i think perhaps it's being evaluated after i've disconnected -- but i would have expected an exception
23:40:42 <cin> i'll investigate further...
23:40:47 <glguy> cin: use quickQuery'
23:41:11 <cin> glguy: okay. is that what you use?
23:41:21 <glguy> cin: I use the strict versions of all the functions
23:41:31 <glguy> unless there is some special need for the lazy one
23:41:54 <cin> glguy: good point, i guess you want to guarentee order
23:42:08 <hpaste>  dolio pasted "cat" at http://hpaste.org/6076
23:44:18 <Cheery> > let hell = "whee"
23:44:18 <lambdabot>  Parse error at end of input
23:44:54 <Cheery> You know what I'd really like in linux tty console?
23:45:23 <Cheery> a control character that makes it to flash
23:45:46 <glguy> you can configure screen to do that instead of beeping on the bell character
23:46:49 <roconnor> Cheery: http://en.wikipedia.org/wiki/ANSI_escape_code
23:46:49 <lambdabot> Title: ANSI escape code - Wikipedia, the free encyclopedia
23:47:00 <roconnor> Blink: Slow 	less than 150 per minute
23:47:10 <roconnor> Blink: Rapid 	MS-DOS ANSI.SYS; 150 per minute or more
23:50:40 <b_jonas> Cheery: actually, screen can emulate such a visual bell
23:51:17 <b_jonas> but on linux console, you can achieve it by temporarily changing the vga palette
23:51:42 <b_jonas> there's an escape sequence for that, but you have to be careful for 1. it's global on all vtys, and 2. there's no way to _read_ the palette
23:52:11 <b_jonas> (palette is how some games like prince of persia emulate flashing the screen or gradually dimming the screen etc)
23:52:29 <Cheery> hm. It'd be ok to bell each time when it prompts for input
23:52:59 <Cheery> is there prince of persia for linux?
23:53:13 <b_jonas> no, I'm running it in an emulator
23:53:25 <faxathisia> great game...
23:53:38 <b_jonas> great yes
23:53:46 <faxathisia> remember the bit when=
23:53:49 <b_jonas> it was a pioneer at its time, in three ways
23:53:57 <faxathisia> the skeliton comes to life? :D
23:54:10 <b_jonas> realistic animations, new controls, and a game with a back-story
23:54:29 <Cheery> the PC-version seemed a lot better than the one on nes
23:54:44 <b_jonas> though actually only the first and the third counds
23:54:58 <b_jonas> s/counds/counts/
23:55:04 <faxathisia> shadow of the flame or whatever was good too..
23:55:29 <b_jonas> shadow and the flame was too hard for me
23:55:33 <Cheery> wondering what'd be the simplest way to get the working PC -version of that game to my machine
23:55:47 <faxathisia> *g*
23:55:48 <b_jonas> Cheery: get a pc emulator, a dos, and the game
23:56:02 <faxathisia> I have floppy discs with this game
23:56:04 <Cheery> guess could install dosbox but that's simply annoying on linux, because linux has an already good terminal I'd like to use instead of emulating one
23:56:14 <b_jonas> or possibly just a windows if you have one
23:56:49 <b_jonas> some windows versions would run it find
23:56:52 <b_jonas> s/find/fine/
23:56:54 <b_jonas> argh
23:56:59 <b_jonas> can't type today
23:57:22 <b_jonas> why does terminal care if all you want is a graphical game?
23:57:55 <glguy> ?faw
23:57:55 <lambdabot> The answer is: Yes! Haskell can do that.
23:58:14 <cin> lambdabot knows all
23:58:18 <Cheery> because I want to keep it in my games -directory, while running it transparently
23:58:46 <Cheery> running the emulator transparently*
23:59:41 <glguy> Did you have a Haskell question about that game?
