00:39:39 <koninkje> @pl \xs->foldr f cero xs
00:39:39 <lambdabot> foldr f cero
00:39:56 * koninkje ponders why that doesn't work...
00:43:57 <koninkje> @hoogle (Monad m) => (a -> b) -> (m a -> b)
00:43:57 <lambdabot> No matches, try a more general search
00:44:07 * koninkje sighs
00:49:36 <EvilTerran> koninkje, you can't do that, as that'd let you escape from monads
00:50:06 <EvilTerran> if "foo :: (Monad m) => (a -> b) -> m a -> b", then "foo id :: Monad m => m a -> a"
00:50:13 <johnnowak> koninkje: what else did you expect @pl to do?
00:50:30 <koninkje> the monad(s) in question are escapable, but that's not quite what I wanted anyways
00:50:44 * koninkje has been reading too much about comonads lately
00:51:02 <koninkje> johnnowak: Oh I'm working through a typechecking error is all
00:51:10 <johnnowak> ah
00:51:47 * EvilTerran gets to thinking about unsequence :: Monad m => m [a] -> [m a] again
00:52:15 <EvilTerran> the only definition i've encountered so far involves using !! and is ghastly
00:55:01 <EvilTerran> ?type \ms -> map (\i -> (!!i)<$>ms) [0..] -- kinda thing
00:55:06 <lambdabot> forall a (f :: * -> *). (Functor f) => f [a] -> [f a]
00:55:39 <EvilTerran> ... come to think of it, i don't think you could do bounds-checking with a function of that type, as that'd involve getting data out of the monad. never mind.
00:58:10 <EvilTerran> ?type let unsequence ms = (head <$> ms) : (unsequence $ tail <$> ms) in unsequence -- better complexities, should do the same thing as before
00:58:11 <lambdabot> forall (f :: * -> *) a. (Functor f) => f [a] -> [f a]
01:00:05 <EvilTerran> this is all making more sense than the last time i thought about it. i can see why it's impossible, *and* see a better way of not-quite-achieving it. my haskell-fu must be stronger than it was.
01:00:50 <koninkje> (flip)++
01:02:15 <EvilTerran> koninkje, if you're using flip a lot, it can be kinda cool to replace some (flip foo x)s with (`foo` x) - depending on the name of the function and the meanings of its parameters, that can be more intuitive, i find
01:02:44 <koninkje> Data.Map.fold (flip $ foldr f) cero m
01:03:00 <EvilTerran> ok, not in that context.
01:03:11 <EvilTerran> do you know about "import qualified ... as ..."?
01:03:26 <koninkje> yeah
01:03:33 <EvilTerran> "import qualified Data.Map as M; ...; ... M.fold (... ..."
01:04:19 <koninkje> or "import Data.Map hiding (map); import qualified Data.Map (map)" to avoid the particular conflict
01:04:39 <EvilTerran> if you're doing an import qualified, there's no real need to specify what you're importing
01:04:49 <EvilTerran> altho i guess it makes dependencies more explicit
01:05:42 <koninkje> I'm a big fan of explicit dependencies (though they can get rather verbose in Haskell...)
01:06:01 * EvilTerran tends to "import Data.Map (Map, (!)); import qualified Data.Map as Map"
01:06:46 <luke_a> hi ppl, gonna ask this one again after some network issues, I can't get GHC to link against the parsec library. (http://hpaste.org/6582#a1)
01:07:33 <luke_a> strange thing is that this code used to work...
01:08:25 <EvilTerran> looks like your parsec install is munged. have you tried re-installing it? (you can tell i'm a windows user, eh :P)
01:09:33 <cinimod> @hoogle (a -> Bool) -> [a] --> [a]
01:09:34 <lambdabot> Hoogle Error: Parse Error: Unexpected character '--> [a]'
01:09:47 <cinimod> @hoogle (a -> Bool) -> [a] -> [a]
01:09:47 <lambdabot> Prelude.filter :: (a -> Bool) -> [a] -> [a]
01:09:47 <lambdabot> Prelude.takeWhile :: (a -> Bool) -> [a] -> [a]
01:09:47 <lambdabot> Prelude.dropWhile :: (a -> Bool) -> [a] -> [a]
01:09:59 <cinimod> @hoogle [(a -> Bool)] -> [a] -> [a]
01:10:00 <lambdabot> No matches, try a more general search
01:10:16 <cinimod> :t and
01:10:18 <lambdabot> [Bool] -> Bool
01:10:39 <glguy> :t any
01:10:40 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
01:10:42 <glguy> :t all
01:10:43 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
01:10:47 <EvilTerran> ?type \fs xs -> [x | (f,x) <- zip fs xs, f x]
01:10:48 <lambdabot> forall b. [b -> Bool] -> [b] -> [b]
01:11:05 <cinimod> I want a filter on many predicates
01:11:19 <EvilTerran> conjunction? disjunction? zippy?
01:11:34 <glguy> filter (\x -> px && q x)
01:12:09 <glguy> :t filter (all ?ps)
01:12:11 <lambdabot> forall a. (?ps::a -> Bool) => [[a]] -> [[a]]
01:12:14 <glguy> :t filter (any ?ps)
01:12:15 <lambdabot> forall a. (?ps::a -> Bool) => [[a]] -> [[a]]
01:12:26 <cinimod> I can invent my own - I was wondering there was a library function already
01:12:35 <EvilTerran> ?type \ps -> filter (\x -> all ($x) ps)
01:12:38 <lambdabot> forall a. [a -> Bool] -> [a] -> [a]
01:12:51 <EvilTerran> cinimod, what do you want it to do exactly, though?
01:12:55 <cinimod> yes that's what I was thinking
01:13:18 <EvilTerran> ?type filter
01:13:19 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
01:13:25 <cinimod> e.g. filter [\= "a"] . filter [\= "b"]
01:13:39 <glguy> :t filter ( flip all ?ps . flip id)
01:13:40 <cinimod> oops wrong brackets
01:13:40 <lambdabot> forall a. (?ps::[a -> Bool]) => [a] -> [a]
01:13:43 <EvilTerran> ?type flip (foldr filter)
01:13:44 <lambdabot> forall a. [a -> Bool] -> [a] -> [a]
01:14:07 <EvilTerran> that should do the same as \ps -> filter (\x -> all ($x) ps)
01:14:32 <xerox> what about this one
01:14:40 <xerox> > [filter] <*> [(>3),(<5)] <*> return [1..10]
01:14:41 <lambdabot>  [[4,5,6,7,8,9,10],[1,2,3,4]]
01:15:08 <xerox> hm not quite.
01:15:12 <cinimod> nice but not what I want - I'm surprised there's no library function
01:15:44 <glguy> filter (x -> x/='a' && x/='b')
01:15:57 <glguy> no need for another function
01:16:26 <EvilTerran> flip (foldr filter) [p0, p1 ... pN] xs = foldr filter xs [p0, p1 ... pN] = filter p0 (filter p1 ... (filter pN xs)...))
01:16:31 <cinimod> but I have several predicates - anyway foldr filter seems the most straightforward
01:16:41 <glguy> :-/
01:17:14 * EvilTerran would go for the version with all, TBH. it's probably more self-documenting.
01:17:26 <cinimod> TBH?
01:17:29 <glguy> all & any are least surprising
01:17:32 <EvilTerran> "to be honest"
01:17:40 <glguy> the fold version is an irc trick
01:17:48 <EvilTerran> ?type foldM
01:17:48 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
01:18:40 <cinimod> irc?
01:18:54 <glguy> Internet relay chat
01:19:04 <glguy> something fun for #haskell use
01:19:12 <cinimod> how's fold an irc chat trick?
01:19:16 <glguy> like ?pl 'ed code
01:19:30 <glguy> cinimod: making a all out of foldr
01:19:30 <EvilTerran> ?let allA p [] = return True; allA (m:ms) = (&&) <$> p m <*> allA p ms
01:19:30 <lambdabot>  arity mismatch for 'allA'
01:19:35 <glguy> specifically
01:19:35 <EvilTerran> ?let allA p [] = return True; allA p (m:ms) = (&&) <$> p m <*> allA p ms
01:19:35 <lambdabot> Defined.
01:19:38 <EvilTerran> ?type allA
01:19:39 <lambdabot> forall t (m :: * -> *). (Monad m, Applicative m) => (t -> m Bool) -> [t] -> m Bool
01:19:45 <EvilTerran> ups
01:19:47 <EvilTerran> ?undef
01:19:47 <lambdabot> Undefined.
01:19:52 <EvilTerran> ?let allA p [] = pure True; allA p (m:ms) = (&&) <$> p m <*> allA p ms
01:19:52 <lambdabot> Defined.
01:20:13 <EvilTerran> ?type allA
01:20:14 <lambdabot> forall t (f :: * -> *). (Applicative f) => (t -> f Bool) -> [t] -> f Bool
01:20:34 * EvilTerran goes back to trying to work out if this can be used to do something clever in Reader
01:20:48 <MarcWeber> When starting a ghc api based ghc(i) session - is there a simple way exposing an api from the running application so that you can script it from the ghc(i) session
01:20:53 <EvilTerran> ... actually, i might want andA
01:21:08 <EvilTerran> ?let andA [] = pure True; allA (m:ms) = (&&) <$> m <*> andA ms
01:21:09 <lambdabot> <local>:2:21:     Multiple declarations of `L.allA'     Declared at: <local>:...
01:21:22 <glguy> cinimod: in this case the foldr version is less efficient and less clear, but cute -> irc trick
01:21:23 <EvilTerran> ?let andA [] = pure True; andA (m:ms) = (&&) <$> m <*> andA ms -- i'm not at my best, clearly
01:21:23 <lambdabot> Defined.
01:21:31 <EvilTerran> ?type andA
01:21:32 <lambdabot> forall (f :: * -> *). (Applicative f) => [f Bool] -> f Bool
01:23:29 <EvilTerran> ?type filter . andA
01:23:30 <lambdabot> forall a. [a -> Bool] -> [a] -> [a]
01:24:00 <EvilTerran> > (filter . andA) [even, (==0).(`mod`3)] [0..]
01:24:01 <lambdabot>  [0,6,12,18,24,30,36,42,48,54,60,66,72,78,84,90,96,102,108,114,120,126,132,13...
01:24:06 <EvilTerran> ta-dah!
01:24:57 <EvilTerran> i think that's less surprising than the funny abuse of foldr
01:25:11 <EvilTerran> altho it does require you to be happy thinking in terms of the (e ->) functor
01:26:02 <cinimod> Hmm I'm not sure using applicative functors is clearer
01:26:17 <cinimod> nice though
01:27:37 <glguy> the (e ->) functor is also an irc trick :-p
01:28:30 <cinimod> how about sequence - that might be clearer - anyway problem solved (many times) so on to the next problem
01:30:13 <EvilTerran> glguy, well, maybe in that usage of it. but i use, say, join in (e->) fairly frequently
01:30:32 <glguy> not necessarily in real code
01:31:09 <koninkje> @pl \(k,xs)-> sequence xs >>=\xs'-> return (k,xs')
01:31:09 <lambdabot> uncurry (flip ((>>=) . sequence) . (return .) . (,))
01:31:13 <EvilTerran> yeah, i guess so. i'll save myself the extra import statement and define "join :: (a -> a -> b) -> a -> b" locally in production code.
01:31:20 <EvilTerran> eew
01:31:49 <EvilTerran> ?type \(k,xs)-> sequence xs >>=\xs'-> return (k,xs')
01:31:50 <lambdabot> parse error on input `->'
01:31:55 <EvilTerran> ?type \(k,xs)-> sequence xs >>= \xs'-> return (k,xs')
01:31:57 <lambdabot> forall t (m :: * -> *) a. (Monad m) => (t, [m a]) -> m (t, [a])
01:32:12 <glguy> I haven't seen many (any) situations at work where we were that concerned with saving keystrokes in an application
01:32:45 <taruti> glguy: clean, short and modular code makes refactoring and maintaining code easier.
01:33:09 <glguy> taruti: agreed, but that's not what's being discussed here ;)
01:33:25 * koninkje is mostly looking for unexpectedly shorter versions 
01:33:34 <glguy> well "short" sure
01:33:56 <EvilTerran> ?type \(k,xs) -> return . (,) k =<< sequence xs
01:33:57 <lambdabot> forall t (m :: * -> *) a. (Monad m) => (t, [m a]) -> m (t, [a])
01:34:19 <EvilTerran> ?type uncurry$ \k -> return . (,) k <=< sequence
01:34:20 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a, [m a1]) -> m (a, [a1])
01:34:43 <EvilTerran> ?type uncurry$ \k -> (<=< sequence) . (return . (,) .)
01:34:44 <lambdabot> forall a a1 (m :: * -> *) a2 b. (Monad m) => (a, [a1] -> a2) -> [m a1] -> m (b -> (a2, b))
01:34:50 <EvilTerran> ?type uncurry$ (<=< sequence) . (return . (,) .) -- even
01:34:51 <lambdabot> forall a (m :: * -> *) a1 b. (Monad m) => ([a] -> a1, [m a]) -> m (b -> (a1, b))
01:35:08 <EvilTerran> never mind. go back to my first one. :P
01:35:43 <taruti> ?type \(k,xs) -> liftM2 (,) (return k) (sequence xs)
01:35:44 <lambdabot> forall a1 (m :: * -> *) a. (Monad m) => (a1, [m a]) -> m (a1, [a])
01:36:23 <koninkje> I was actually hoping on a way to get rid of the outer lamba prettily (the function's only used in a map)
01:37:47 <EvilTerran> ?type uncurry (liftM2 (,)) . (return *** sequence)
01:37:48 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a, [m a1]) -> m (a, [a1])
01:38:08 <koninkje> heh :)
01:38:23 <EvilTerran> arrows are also an IRC trick :P
01:38:34 <taruti> why simply not defined a mapSndM and use that?
01:38:59 <taruti> -d
01:39:08 <EvilTerran> methinks "secondM" would fit the current nomenclature quite well
01:39:43 <koninkje> because I only need it once...
01:39:47 <EvilTerran> secondM :: Monad m => (b -> m c) -> (a, b) -> m (a, c)
01:39:58 <EvilTerran> ?type second -- or you could try to get arrows involved too
01:39:59 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
01:40:31 <EvilTerran> hm... might it already just be a specialisation of second to kliesli arrows?
01:42:06 <EvilTerran> nah, never mind
01:42:44 <EvilTerran> in order to use the existing second function, you'd have to do something ghastly with explicit Kleisli wrapping (and Reader again)
01:43:01 <EvilTerran> i thikn
01:56:49 <koninkje> @hoogle Bool -> a -> Maybe a
01:56:51 <lambdabot> No matches, try a more general search
01:57:00 * koninkje -> bed
02:01:22 <EvilTerran> ?seen hpaste
02:01:22 <lambdabot> I saw hpaste leaving #haskell 3d 19h 47m 14s ago, and .
02:01:38 <EvilTerran> http://hpaste.org/6583 <- i'm sure someone's had the idea before me, but any thoughts?
02:02:42 <EvilTerran> there's probably a better name for it, mind
02:03:35 <EvilTerran> seems to me that that sort of tack could work quite well for any class where there's a significant number of common types where more than one instance would make sense
02:04:36 <EvilTerran> and you could have stuff like "runSum m = runArbM m (+) 0; runProd m = runArbM (*) 1; ..."
02:04:52 <EvilTerran> er, don't forget the m in the second one there like i did ;)
02:10:18 <Cheery> @where Tree
02:10:18 <lambdabot> I know nothing about tree.
02:11:51 <yuriyp> ?seen RemiTurk
02:11:51 <lambdabot> I haven't seen RemiTurk.
02:12:25 <yuriyp> ?seen lamdabot
02:12:26 <lambdabot> I haven't seen lamdabot.
02:12:37 <yuriyp> ?seen lambdabot
02:12:37 <lambdabot> Yes, I'm here. I'm in #friendly-coders, #gentoo-uy, #rosettacode, #scannedinavian, #gentoo-haskell, ##logic, #xmonad, #unicycling, #perl6, #parrot, #jtiger, #haskell-soc, #haskell-overflow, #haskell-
02:12:37 <lambdabot> blah, #scala, #darcs, #jhc, #ghc and #haskell
02:15:15 <xpika> lambdabot: you sure get around
02:16:17 <EvilTerran> ?vixen you're selective in the company you keep, aren't you?
02:16:17 <lambdabot> what about me?
02:16:32 <EvilTerran> ?vixen you're deaf
02:16:32 <lambdabot> so, what do you think of me?
02:45:45 <xpika> does anyone know how to remove a dependancy of a debian package?
02:46:06 <jaj> @go haskelldb
02:46:07 <lambdabot> http://haskelldb.sourceforge.net/
02:46:07 <lambdabot> Title: HaskellDB
02:47:14 <yitz> xpiks: what do mean by remove?
02:47:26 <yitz> xpika: what do you mean by remove?
03:07:11 <xpika> yitz: either from the local package database or the package itself
03:07:16 <xpika> i tried editing /var/lib/dpkg/status but it reverted back
03:11:13 <yitz> xpika: do you want to override apt-get's conflict resolution? use +/- at the end of the package names in apt-get install.
03:11:26 <yitz> xpika: but you're asking for trouble.
03:14:42 <yitz>  xpika: or you can force a certain version with things like /unstable or =3.2.1 at the end of the package name. Again - trouble ahead. Always use --dry-run first to see what you are getting yourself into.
03:18:28 <xpika> yitz: troubles my middle name
03:18:35 <yitz> he
03:20:42 <yitz> xpika: also, sometimes it works best to use the preferences system instead, so that things won't break next time next time you update some other packages. see man apt_preferences.
03:24:30 <xpika> bryan,john,dons: all i can say is: mowar!
03:43:53 <dozer> morning
03:47:42 <byorgey> hey dozer
03:48:05 <dozer> it isn't a good sign when you've been coding over the whole easter break :)
03:48:53 <syntaks> hello everyone
03:48:56 <byorgey> yeah, probably not... =)
03:49:02 <byorgey> hi syntaks
03:49:10 <syntaks> dozer: this sounds familiar =)
03:49:40 <syntaks> is anyone familiar with HXT (haskell XML toolbox)?
03:49:50 <dozer> somewhat syntaks
03:50:09 <syntaks> dozer: I'm trying to get that thing to emit namespace declarations, but it refuses
03:50:23 <dozer> ah, yeah - I've never got it do do that right
03:50:33 <dozer> one of the things I was going to 'fix' in my personal fork
03:50:34 <syntaks> dozer: do I have to explicitly add xmlns:ns="..." attributes to my tree?
03:51:00 <dozer> I think so - it doesn't understand the difference between the document model and the syntax tree
03:51:35 <SamB> wierd
03:51:43 <SamB> it can PARSE namesaces but not emit them?
03:52:01 <syntaks> I do mkqelem (mkNsName "x:hello" "http://www.example.com") [] [txt "world"]
03:52:17 <syntaks> and what I get is <x:hello>world</x:hello>
03:52:23 <dozer> it can emit them as fully qualified qnames, but can't emit namespace declarations in a clever way
03:52:40 <SamB> "fully qualified"?
03:52:43 <dozer> there are many ways to write out namespace declarations for any given tree of namespace-qualified elements/attributes
03:52:48 <SamB> that isn't ... legal, is it?
03:53:22 <syntaks> Samb: it is legal xml, x:hello is a valid name, but it does not have namespaces
03:53:47 <dozer> fully qualified (as in http://somewhere.com/foo.xsd:bar) is totaly legal
03:53:47 <lambdabot> Title: Hmmm.... Haven't seen that before.
03:53:59 <SamB> dozer: ssince when?
03:54:12 <dozer> since for ever - the xml namespace prefix is just a shorthand for this
03:54:22 <dozer> (may have got the ascii art wrong)
03:54:30 <syntaks> dozer: erm, IIRC the xml namespace spec demands that you use prefixes in order to qualify names
03:54:31 <SamB> my understanding is that that isn't actually allowed
03:54:57 <dozer> the namespace spec says that, the xml spec doesn't address the issue
03:55:06 <syntaks> there is a convention to write {http://example.com}:localPart, put that is not allowed in documents
03:55:11 <SamB> I have heard of a document that explains xml namespaces in terms of a nonstandard syntax involving {}...
03:55:12 <wli> I wonder if anyone knows about numerically solving systems of quadratic equations.
03:55:41 <SamB> systems of quadratic equations?
03:56:02 <syntaks> dozer:  but I'm just paraphrasing from memory there... you may actually be right... I need to look it up
03:56:08 <yitz> wli: you mean two of them?
03:56:25 <yitz> wli: how many variables?
03:57:24 <syntaks> dozer: but on the actual issue, you are saying, there is no way to get HXT to emit any xmlns attributes in a document containing qnames unless I explicitly add them, right?
03:57:40 <dozer> perhaps my brain is fried from 4 hours of sleep, dreaming of topoids and inductive proofs over Monad transformers
03:57:41 <wli> yitz: No, the system has n copies of certain equations coupled with some linear interactions between pairs of adjacent mini-systems.
03:58:06 <dozer> syntaks: I've not found a way - it parses them in correctly, but I haven't got it to write them out in a cotrolled manne
03:58:25 <wli> yitz: The "certain equations" being a smaller system of quadratic equations in a number of variables depending on other things.
03:58:32 <dozer> syntaks: the maintainer is a relaxNG guy, not xsd, so this may have an influence
03:59:11 <syntaks> dozer: I guerss the mainh influence lies in the fact that xml namespaces are a royal pain anyway :)
04:00:43 <yitz> wli: hmm. so your first issue will be looking out for singularites (and near-singualrites) then. there will be many ways that can happen. you won't be able to solve anything until after you settle those down.
04:01:56 <wli> yitz: What's a singularity in this context?
04:02:50 <yitz> wli: any two of your quadratic hypersurfaces could intersect in a point instead of a line, or miss altogether. btw, real, complex?
04:03:20 <wli> yitz: Real.
04:03:23 <yitz> s/line/curve/
04:04:07 <yitz> wli: so if it's really as general as you say, you'll have to do some algebra.
04:06:31 <wli> yitz: What kind of algebra?
04:11:00 <wli> yitz: I've got closed forms for the eigenvalue decomposition of some of the matrices' blocks involved.
04:11:40 <yitz> wli: simple algebraic geometry. i think the quadratic case is well-known even for many variables, but it can get complicated.
04:11:50 <yitz> wli: matrices?
04:13:21 <wli> yitz: I'm not familiar with this algebraic geometry. The matrices are the matrices involved in the representations of the things as x^t A x + b^t x + c
04:14:35 <matthew-_> why can haddock never be non-broken?
04:16:07 <matthew-_> haddock 2 seems to break on type families
04:16:42 <matthew-_> it's like the most recent version of haddock is only ever usable on haskell programs that work with the previous generation of ghc/haskell programmes
04:17:39 <yitz> wli: think of a simple case in 3 variables: x^2+y^2-z is a cone. Intersect it with planes, and you get all the conic sections, lines and points. sometimes more than one component, sometimes nothing. that's already pretty complex. move up to intersections of many thingies in many variables, and it's hard to say anything in general. perhaps your eigenvalue decomp can help, but i don't know.
04:20:26 <wli> yitz: Well, I even know the eigenvalues, which tell me how many ways it's parabolic, hyperbolic, and elliptic.
04:22:01 <yitz> wli: well. of course there are theorems that say things in general. like what is the maximum dimension of your intersections, achieved when there are no singularites.
04:22:40 <syntaks> dozer: it actually works in HXT after all... there is a uniqueNamespacesFromDeclAndQNames function in Text.XML.HXT.Arrow.Namespace
04:23:16 <syntaks> dozer: it needs to be applied to the arrow before the root is constructed though, otherwise it doesn't work
04:23:45 <wli> yitz: Sounds useful. Any good references on this?
04:26:20 <syntaks> dozer: http://hpaste.org/6584
04:28:37 <yitz> wli: just googling. found this with some pictures: http://www.ima.umn.edu/2006-2007/weekly_tutorial/roberts/ima_tutorial.html
04:28:38 <lambdabot> Title: IMA tutorial -- April 26, 2007, http://tinyurl.com/32wvjo
04:30:14 <wli> yitz: Checking it out.
04:34:55 <yitz> wli: just found a book posted online in pdf. is this the kind of stuff you need? http://perso.univ-rennes1.fr/marie-francoise.roy/bpr-posted1-may06.pdf.tar.gz
04:34:57 <lambdabot> http://tinyurl.com/34c3yo
04:35:14 <wli> yitz: Checking that out, too.
04:35:55 <arquebus>  /msg nickserv link <arquebus> <jjjjjj>
04:38:19 <yitz> wli: here's a book: http://www.ec-securehost.com/SIAM/ot85.html
04:38:30 <yitz> wli: this stuff may be too general for you.
04:38:49 <dcoutts_> @seen Saizan
04:38:49 <lambdabot> Saizan is in #haskell, #haskell-overflow, #haskell-blah and #haskell-soc. I last heard Saizan speak 9h 17m 18s ago.
04:38:51 <wli> The generalities will help too, I'm sure.
04:39:07 <dcoutts_> @seen VP
04:39:07 <lambdabot> I saw VP leaving #haskell 10h 36m 48s ago, and .
04:40:20 <wli> yitz: The SIAM book looks exactly like what I need.
04:40:56 <yitz> wli: go google
04:43:04 <unenough> is haskell a category?
04:45:53 <blarz> @users
04:45:53 <lambdabot> Maximum users seen in #haskell: 473, currently: 423 (89.4%), active: 13 (3.1%)
04:48:30 <Baughn> unenough: Haskell the language? I don't see how it could be otherwise; it's pretty easy to map a turing machine on category theory.
04:49:42 <jgrimes_> http://www.alpheccar.org/en/posts/show/74
04:49:44 <lambdabot> Title: Category Theory and the category of Haskell programs : Part 1
04:51:45 <unenough> thanks
04:51:51 <wli> yitz: What's special about the quadratic case vs. higher degrees?
04:52:22 <unenough> Baughn, of course as a turing machine it's a category. i was thinking about a more special one (w.r.t the high-level constructs)
04:52:54 <Baughn> unenough: Then you weren't specific enough. jgrimes_ linked to one, though. :P
04:54:20 <unenough> yes, thanks ;)
04:54:37 <jgrimes_> :D
04:59:44 <yitz> wli: easier :) possibly even solvable in general almost as completely as linear, I don't know. It would be a lot more work though. disclaimer: I haven't worked on this stuff in years, and I see that a lot has been done recently. some simple google searches don't reveal any obvious general solutions.
05:01:06 <wli> yitz: Very nice.
05:03:45 <wli> yitz: What's the concept that makes them almost as easy as linear systems?
05:12:28 <skorpan> @pl \p -> (p, attacked p game)
05:12:28 <lambdabot> ap (,) (flip attacked game)
05:13:39 <hallongrottan> skorpan: how's your project going?
05:13:48 <Jaak> id *** (flip attacked game) ?
05:13:49 <skorpan> @pl \p -> take steps $ moveDir (posAdd now p) p n game
05:13:50 <lambdabot> take steps . flip (flip (moveDir =<< posAdd now) n) game
05:13:54 <skorpan> hallongrottan: making progress
05:13:57 <hallongrottan> nice
05:14:18 <skorpan> hallongrottan: did you fix your bugs?
05:14:28 <hallongrottan> well i'm working on it now
05:14:35 <hallongrottan> needs moar lookahead sort of
05:14:57 <skorpan> i couldn't sleep this night
05:15:55 <hallongrottan> :/
05:24:35 <unenough> jgrimes_ nice page
05:40:53 <skorpan> @pl any snd $ attackedPositions ps game
05:40:54 <lambdabot> any snd (attackedPositions ps game)
05:42:23 <opqdonut> :P
05:42:31 <opqdonut> put some lambdas there
05:43:24 <opqdonut> ?pl \ps game -> any snd $ attackedPositions ps game
05:43:24 <lambdabot> (any snd .) . attackedPositions
05:44:21 <skorpan> opqdonut: i never had any lambdas :)
05:45:06 <opqdonut> well then why are you trying to make it point-free?
05:45:13 <skorpan> i have no idea
05:45:18 <opqdonut> :)
05:49:28 <dozer> @paste
05:49:28 <lambdabot> Haskell pastebin: http://hpaste.org/new
05:49:43 <skorpan> @pl \p -> opponent n `elem` (map (player . snd) (attackers p game))
05:49:43 <lambdabot> (opponent n `elem`) . map (player . snd) . flip attackers game
05:50:05 <hallongrottan> lol
05:50:36 <_andre> hello
05:50:56 <_andre> is the example for Control.Exception.catch in the docs correct?
05:52:14 <_andre> the first argument has type IO Handle and the handler has type IO ()
05:57:10 <Lemmih> _andre: Yeah, that looks like a mistake.
06:02:42 <skorpan> @pl \pos -> player $ snd pos
06:02:42 <lambdabot> player . snd
06:04:29 <matthew-_> it's like the most recent version of haddock is only ever usable on haskell programs that work with the previous generation of ghc/haskell programmes
06:11:25 <_andre> is there anything wrong with [a,b,c] <- getArgs `catch` (\e -> return ["foo","bar","blah"]) ?
06:12:03 <_andre> oh
06:12:13 <_andre> cause the error isn't in getArgs i guess :p
06:12:28 <_andre> is there any idiom to catch this kind of error?
06:12:57 <dcoutts_> case ?
06:13:04 <dcoutts_> args <- getArgs
06:13:08 <dcoutts_> case args of ...
06:14:11 <_andre> yeah, i'm just trying to understand how to do exception handling
06:14:25 <_andre> is it possible to catch pattern matching errors like that?
06:14:33 <Baughn> When it comes to pattern-matching, the proper thing is to avoid having an exception in the first place
06:14:43 <dcoutts_> _andre: you typically do not do exception handling for pattern match failure
06:15:07 <dcoutts_> you just do the pattern matching with an alternative case that matches when the other patterns do not match
06:15:27 <_andre> i see
06:15:29 <dcoutts_> exception handling is more often used for IO errors and that kind of thing
06:19:07 <_andre> i figured it would be kinda repetitive to do "(a:b:c) <- case getArgs of (a:b:c) -> (a:b:c) ..."
06:21:08 <Jedai> _andre: Since you can't do it (getArgs is in IO, you can't use case on it), you have to separate the getArgs and the case, like dcoutts showed
06:22:12 <_andre> Jedai: yeah, my bad
06:22:24 <_andre> but still i have to repeat the pattern 3 times
06:23:30 <Jedai> _andre: No, only one ? do { as <- getArgs; case as of { [a,b,c] -> ... ; _ -> fail "..." }}
06:24:15 <Jedai> _andre: If you really have a complex treatment for the arguments, you probably want to factor it out anyway.
06:24:23 <pejo> Jedai, he wants to use the 3 element list if that is what he's getting from getArgs, otherwise use a default, I think.
06:25:39 <Jedai> pejo: Oh ok, I don't know if there's an elegant method for that
06:27:16 <Jedai> He could factor the rest of it's main in a function that take three arguments
06:28:01 <Jedai> do { as <- getArgs; case as of { [a,b,c] -> rest a b c ; _ -> rest "foo" "bar" "blah" }}
06:32:25 <_andre> Jedai: ended up creating a parseArgs function
06:33:13 <_andre> case args of (a:b:c) -> return args  otherwise -> error "foo"
06:35:06 <ttt--> does (-> Integer) mean: the type of a function that returns an integer?
06:36:32 <AtnNn> ttt--: no, it's for functions that receive an Integer
06:36:38 <ttt--> like "((->) e)"
06:36:42 <ttt--> what does that mean?
06:36:52 <Jedai> ttt--: function that receive e
06:36:52 <ttt--> oh, i see
06:37:12 <dozer> ?pl zipWith (\a -> filter $ (==a))
06:37:12 <lambdabot> zipWith (filter . (==))
06:37:21 <ttt--> so what would be an example of (-> Integer) ?
06:37:25 <Jedai> like for every binary operator, when you put parenthesis, it becomes an ordinary function
06:37:54 <Jedai> (except here it is at type and type constructor level, and section syntax don't work with ->)
06:38:05 <noecksit> hello, what are some good resources where i can learn about the State Monad?
06:38:26 <noecksit> i program i am studying uses them and I have no idea how it works
06:39:02 <Jedai> ttt--: ((->) Integer) ? Any function that can take an Integer as it's first argument, a specialization of abs, or (+) for example
06:39:05 <yitz> ttt--: not exactly. when a applied to a type a, it results in the type of functions from a to Integer
06:39:25 <pejo> @go monad tutorial site:.de
06:39:27 <lambdabot> http://uebb.cs.tu-berlin.de/~magr/pub/Transformers.en.html
06:39:27 <lambdabot> Title: Monad Transformers Step by Step
06:39:42 <yitz> unless you meant what jedai said, which is sort of the oposite.
06:39:56 <pejo> noecksit, that one contains a good example iirc.
06:40:00 <Twey> Hm
06:40:12 <Jedai> yitz: I thought section syntax didn't work with (->) ??
06:40:14 <b_jonas> actually, ((->) Integer) creates a function type that maps _from_ integers to something
06:40:22 <Twey> http://hpaste.org/6585 -- why is this an infinite type?
06:40:33 <b_jonas> and section syntax works with -> only if the extension is enabled I think
06:40:54 <ttt--> i dont understand.. is it a real type signature?
06:41:05 <Jedai> b_jonas: Oh, which extension ?
06:41:07 <noecksit> pejo: ok thanx ill look over it
06:41:12 <yitz> Jedai: right. ttt--- as Jedai says - no, it is not legal.
06:41:35 <yitz> you would write it as a -> Integer
06:41:40 <b_jonas> Jedai: I dunno, but it definitely doesn't work normally
06:41:49 <ttt--> it is just an informal way of saying, "all functions that take an integer as their first argument"?
06:41:51 <b_jonas> (that doesn't stop people here to use it as pseudocode notation)
06:41:53 <Twey> It seems as if it should be valid to me :-\
06:41:53 <Jedai> ttt--: ((->) e) is legal and means functions from e
06:42:24 <yitz> or forall a. a -> Integer
06:42:25 <Jedai> ttt--: you can see it in some instance declaration (the function monad)
06:43:16 <Jedai> ttt--:  but (-> e) don't work
06:43:30 <yitz> Twey: you need parens around x:c
06:43:48 <Twey> yitz: Ohhh
06:43:51 * Twey was silly.
06:43:56 <Twey> Thanks
06:44:12 <yitz> Twey: hey, that's what we're here for.
06:44:55 <yitz> Twey: I'll bet I do that more often than you do. That's why I need a language with a good typechecker like Haskell. :)
06:45:00 <uccus> kowey: is it possible to add one more chapter to the wikibook version of WYSI48H?
06:45:30 <kowey> uccus: I don't see why not
06:45:34 <uccus> kowey: I mean, I can't do it, I don't know enough Haskell, but implementing call/cc would have been really really impressive
06:45:42 <kowey> no wikibook is set in stone
06:45:53 <Twey> yitz: Heh
06:46:10 <ttt--> > typeOf (+) == ((->) Integer)
06:46:10 <lambdabot>  Parse error at "->)" (column 17)
06:47:05 <Jedai> ttt--: You're mixing code and type signature, it don't work
06:47:14 <uccus> kowey: you there? I might give it a try but that would involve you rewriting it from the scratch :p
06:48:05 <kowey> uccus: I think nostrademons might be a better help here, if he's available
06:49:03 <yitz> @type (+ 5)
06:49:07 <lambdabot> forall a. (Num a) => a -> a
06:49:26 <ttt--> > typeOf (typeOf (+))
06:49:28 <lambdabot>  TypeRep
06:49:34 <kowey> uccus: also, it may be good to join #haskell-books (and invite all involved) and the wikibook mailing list
06:49:40 <yitz> @type const (5 :: Integer)
06:49:40 <lambdabot> forall b. b -> Integer
06:49:55 <Jedai> typeOf (+) == typeOf (undefined :: ((->) Integer) (Integer -> Integer))
06:50:10 <uccus> my IRC client doesn't show him online. anyway, I think continuations that can be re-entered are the trickiest, and perhaps ... ok I'll try that once I figure out more clearly what is it that I'm trying to do here. thanks.
06:50:27 <ttt--> > typeOf (+) == typeOf (undefined :: ((->) Integer) (Integer -> Integer))
06:50:28 <lambdabot>  True
06:50:36 <ttt--> cool :)
06:50:42 <yitz> @seen nostrademons
06:50:42 <lambdabot> I saw nostrademons leaving #haskell 2d 9h 58m 11s ago, and .
06:51:06 <yitz> @seen lambdabot
06:51:06 <lambdabot> Yes, I'm here. I'm in #friendly-coders, #gentoo-uy, #rosettacode, #scannedinavian, #gentoo-haskell, ##logic, #xmonad, #unicycling, #perl6, #parrot, #jtiger, #haskell-soc, #haskell-overflow, #haskell-
06:51:06 <lambdabot> blah, #scala, #darcs, #jhc, #ghc and #haskell
06:51:35 <yitz> Not in #haskell-books. hmm.
06:51:59 <yitz> If you want lambdabot there, leave a message for Cale.
06:53:31 <kowey> good idea
06:55:12 <yitz> @tell Cale Could you please have lambdabot join #haskell-books ?
06:55:13 <lambdabot> Consider it noted.
06:55:52 <kowey> oops. now he's got two messages! :-)
06:55:58 <yitz> sorry
06:56:16 <kowey> nono, lack of communication on my part
06:56:26 <yitz> I guess he'll now realize how urgent this is :)
06:56:55 <kowey> with lambdabot, the channel population will be all of 4 users (including ChanServ)
06:57:23 <yitz> plus whatever trolls drop by
07:00:53 <Twey> Why is lambdabot in #scala?
07:01:12 <uccus> why not?
07:01:18 <dolio> There's no scala bot yet?
07:01:35 * Twey shrugs.
07:01:37 <uccus> not that I know of...
07:01:44 <uccus> and lambdabot certainly is cute
07:01:49 <Twey> Yes ^_^
07:01:53 <yitz> @botsnack
07:01:53 <lambdabot> :)
07:02:01 <dolio> @vixen Are you cute?
07:02:01 <lambdabot> i'd like to think i'm pretty
07:02:09 <Twey> :-D
07:04:44 <yitz> @arr Are you cute?
07:04:44 <lambdabot> Avast!
07:04:50 <MarcWeber> Does anyone know what happens to shim?
07:05:05 <dolio> Someone was in here a few days ago saying it works great.
07:07:02 <Saizan> dcoutts_: pong
07:07:25 <MarcWeber> dolio: thanks. I've found the right address now
07:07:40 <cinimod> Buidling haddock gives /usr/lib/gcc/i586-suse-linux/4.2.1/../../../../i586-suse-linux/bin/ld: cannot find -lreadline
07:08:27 <dcoutts_> Saizan: hia
07:08:39 <cinimod> readline is there however /lib/readline.so.4
07:08:52 <yitz> cinimod: haddock from hackage?
07:09:08 <cinimod> yes 2.0.0.0
07:09:29 <cinimod> Ah not from hackage from the haddock page
07:09:38 <dcoutts_> Saizan: cunning quick fix, I was thinking of a rather bigger problem
07:10:01 <dcoutts_> Saizan: but we should go with your fix for this release and file another bug about the rest of the problem
07:11:00 <cinimod> yitz: I can create a link and that will fix it but I feel I shouldn't have to
07:11:29 <yitz> cinimod: right. did you build using cabal?
07:11:43 <Saizan> dcoutts_: i was thinking the same about the fact that preprocessSources ignores non-buildable components when preprocessing
07:11:55 <cinimod> yes the build part fails with the linker error
07:11:58 <dcoutts_> Saizan: oh right
07:12:31 <dcoutts_> Saizan: yes I guess that depends on if we're doing pre-processing for sdist or not
07:14:33 <Saizan> dcoutts_: yes, and it has a froSDist parameter so it could not use withLib/withExe in that case
07:15:24 <dcoutts_> Saizan: there are a couple places where we have this issue of whether to include buildable components or not
07:15:49 <dcoutts_> Saizan: I wonder if we should just change withLib/withExe to take a parameter to say
07:15:58 <cinimod> yitz: ln -s libreadline.so.4 libreadline.so fixes it but now I have a problem with ncurses :-(
07:16:54 <dcoutts_> Saizan: like: withLib OnlyBuildable $ \lib ->
07:17:10 <dcoutts_> Saizan: or perhaps even modify the existing uses to be just:
07:17:18 <Saizan> dcoutts_: that seems best, so even in the future one won't use withLib without thinking about this
07:17:20 <yitz> cinimod: ah. but why does haddock nead to link in readline?
07:17:35 <dcoutts_> withExe $ \exe -> when (buildable exe) $ do ...
07:17:59 <dcoutts_> Saizan: right, if we make it a parameter then you're forced to consider the issue, which is probably a good thing
07:18:09 <cinimod> yitz: dunno and ln -s libncurses.so.5 libncurses.so fixes the other linker problem - I'm now in business
07:18:19 <yitz> cinimod: did you have libreadline.so linked to something else beforehand?
07:18:28 <cinimod> yitz: no
07:18:58 <dcoutts_> Saizan: and we can drop the default value parameter to withLib, I think it's only ever used at type ()
07:18:58 <yitz> cinimod: were you supposed to (i.e., did you do something non-standard on your platform)?
07:19:27 <cinimod> yitz: straight out of the box opensuse 10.3
07:20:36 <Saizan> dcoutts_: and whe could use a predicate as parameter, instead of an ad-hoc datatype, like withLib buildable $ \lib ->  or withLib (const True) $ \lib ->
07:20:58 <yitz> dcoutts_: any reason why cabal should fail to build haddock from hackage on vanilla suse with ld failing to find readline? sounds weird to me.
07:21:31 <dcoutts_> yitz: if readline is not installed on the standard linker path
07:21:43 <dcoutts_> most likely it's just not installed
07:21:53 <dcoutts_> the dev parts, even if the .so might be
07:22:14 <dcoutts_> binary distros often split readine/readline-dev
07:22:17 <yitz> dcoutts_: it's there, in /lib. He had to n -s libncurses.so.5 libncurses.so
07:22:26 <yitz> dcoutts_: it's there, in /lib. He had to ln -s libncurses.so.5 libncurses.so
07:22:29 <cinimod> dcoutts_: I probably haven't installed readline-dev
07:23:03 <dcoutts_> cinimod: rm the symlink you made before installing readline-dev
07:23:14 <dcoutts_> as readline-dev probably makes it itself
07:23:22 <cinimod> dcoutts_: good idea
07:23:59 <dcoutts_> Saizan: but arn't there only two cases?
07:24:07 <yitz> dcoutts_: should cabal give a more intelligent error message in that case?
07:24:34 <dcoutts_> yitz: it should try and find all the required libs at configure time, like autoconf does (sometimes)
07:24:52 <dcoutts_> yitz: it'd then say that readline is not installed
07:24:53 <yitz> yeah, makes sense.
07:25:05 <dcoutts_> which might still be confusing :-)
07:25:10 <dcoutts_> since readline was installed
07:25:29 <yitz> it should know to say "readline-dev" on linux.
07:25:38 <yitz> (most distros)
07:25:52 <dcoutts_> yitz: there's no reliable way to map library names to the packages that own them
07:26:05 <dcoutts_> since it's not the readline package we'd be complaining about
07:26:12 <dcoutts_> but the -lreadline library
07:26:31 <dcoutts_> we have no idea if it belongs to a package, or if it does, which one
07:27:03 <dcoutts_> there's no integration with a system package manager (though perhaps there should be)
07:27:20 <yitz> well, that's what I mean. cabal users can't be required to know about that stuff. an intelligent guess that will often work, or some message that will give them a start where to look for the problem...
07:27:22 <dcoutts_> yitz: do you want to file a specific feature request btw?
07:27:47 <dcoutts_> we mention in passing in another bug that we should look for required header files and libs at configure time
07:27:47 <yitz> yep. not sure yet what the feature should be though :)
07:27:54 <dcoutts_> but really it deserves its own bug
07:28:29 <dcoutts_> yitz: the feature is: cabal should check at configure time for all the C libs and C headers that the package says it requires
07:28:34 <yitz> I'm not even sure why haddock needs readline, it's not mentioned anywhere in the cabal file.
07:28:38 <Saizan> dcoutts_: that's true, and i guess OnlyBuildable and All are more descriptive
07:29:36 <dcoutts_> yitz: it should do the check in the same way that autoconf does its checks for C headers and libs
07:30:06 <yitz> dcoutts_: and give a message that will be intelligible both to those who understand about C libraries and headers and to those that do not.
07:30:15 <dcoutts_> yitz: right
07:30:21 <dcoutts_> yitz: it's probably haddock-2.x right? that depends on the ghc api package which depends on readline
07:30:33 <yitz> dcoutts_: autoconf is designed to be used by C developers. cabal is designed to be used by end users.
07:30:40 <yitz> dcoutts_: ah
07:30:51 <dcoutts_> yitz: well yes, but autoconf also reports errors to end users
07:31:02 <dcoutts_> the error message should be helpful yes
07:32:30 <Saizan> dcoutts_: however, what was the rest of the problem you mentioned earlier?
07:32:50 <yitz> dcoutts_: I actually learned a lot about C development by watching the autoconf messages go by (and later, about m4 :) ) but for Haskell, that's not our job.
07:33:27 <dcoutts_> Saizan: well ideally you could download a .tar.gz package, build it, clean it and build again, but if we put shipped pre-processor output in dist/ in the tarball then it'll get cleaned.
07:33:38 <dcoutts_> yitz: indeed
07:34:28 <dcoutts_> yitz: the whole point of doing the check is to get a better error message that we get currently, and to get it before building rather than during or after
07:34:47 <yitz> @tell yitz file a cabal bug about looking for libs and headers during config
07:34:47 <lambdabot> You can tell yourself!
07:34:56 <yitz> grr
07:34:59 <dcoutts_> :-)
07:35:18 <yitz> got to go. send me a reminder :)
07:35:42 <dcoutts_> @tell yitz file a cabal bug about looking for libs and headers during config
07:35:42 <lambdabot> Consider it noted.
07:37:00 <cinimod> I'm not having a good afternoon: haddock -html -o hdoc Pretty.hs -B /usr/lib/ghc-6.8.2 gives Could not find module `Data.Binary.Strict.BitGet'
07:37:25 <cinimod> I know where the module is though as this works ghci -i../binary-strict-0.3.1/src -fglasgow-exts
07:37:51 <dcoutts_> I dunno if you can pass -i../binary-strict-0.3.1/src to haddock too
07:38:01 <dcoutts_> but just like ghc, it needs to be able to find the modules
07:38:16 <dcoutts_> usually it just consults the registered packages
07:38:24 <cinimod> I just tried but it ../binary-strict-0.3.1/src: openBinaryFile: inappropriate type (is a directory)
07:38:31 <dcoutts_> but you've clearly not got binary-strict-0.3.1 registered
07:38:55 <dcoutts_> haddock 2.x has some flag to pass extra flags to ghc
07:39:02 <dcoutts_> I think
07:39:08 <cinimod> I didn't install it as a package
07:40:19 <cinimod> This works: haddock -html -o hdoc Pretty.hs -B /usr/lib/ghc-6.8.2 --optghc=-i../binary-strict-0.3.1/src
07:40:25 <dcoutts_> great
07:42:01 <cinimod> And now: parse error on input `{-# UNPACK'
07:42:29 <cinimod> Do I need -fglasgow-exts as well?
07:44:00 <Cheery> hey, here's a real problem:
07:44:37 <dcoutts_> cinimod: if you needed it for ghc to be able to parse those modules then you need it for haddock too
07:45:03 <cinimod> dcoutts_: blimey my command line is getting quite congested
07:46:03 <Cheery> is it possible to encode tree structure into an array of integers, with just 2 bits?
07:46:24 <uccus> there was a tool somewhere that would produce a "proof" of a type... given a type it would give you a program corresponding to it... what was its name and how do I use it here?
07:46:26 <uccus> djinn?
07:46:43 <Cheery> well, 2 bits per integer in that array
07:46:45 <dcoutts_> cinimod: why not just install the binary-strict package?
07:46:48 <Saizan> uccus: yes
07:47:08 <uccus> Saizan: how do I use it? can you give me a quick example?
07:47:19 <uccus> on IRC that is
07:47:22 <Saizan> ?djinn a -> a
07:47:22 <lambdabot> f a = a
07:47:34 <cinimod> coutts_: because I was working on it as well - I suppose I could for the time being
07:47:36 <Saizan> ?djinn-env
07:47:36 <lambdabot> data () = ()
07:47:36 <lambdabot> data Either a b = Left a | Right b
07:47:36 <lambdabot> data Maybe a = Nothing | Just a
07:47:36 <lambdabot> data Bool = False | True
07:47:36 <lambdabot> data Void
07:47:38 <lambdabot> type Not x = x -> Void
07:47:40 <lambdabot> class Eq a where (==) :: a -> a -> Bool
07:47:42 <lambdabot> type Cont r a = (a -> r) -> r
07:48:15 <dcoutts_> Cheery: yes, I've done that before for a GtkTreeModel where I only had 96 bits to encode iterators
07:48:34 <Cheery> ie.  a ((b c) d) -> [a (??), b (??), c (??), d (??)] where ? is 0 or 1
07:48:34 <dcoutts_> Cheery: and that was harder because it was a N-ary tree, not a binary tree
07:48:44 <Cheery> dcoutts_: how does it happen?
07:49:11 <dcoutts_> you need enough bits to encode N+1 for each level, where N is the number of children
07:49:22 <skorpan> i have a String which i want to split up into [String] where each element of the list is at most 31 characters long and words are not split up
07:49:36 <skorpan> any ideas?
07:50:03 <Cheery> dcoutts_: explain it in layman terms
07:50:10 <uccus> thanks Saizan
07:50:32 <dcoutts_> Cheery: so you're really trying to encode a path in a binary tree
07:50:37 <scook0> skorpan: splitAt, unfoldr, and a little plumbing?
07:51:15 <dcoutts_> Cheery: right? so you've got type Path = End | Left Path | Right Path
07:51:53 <Cheery> dcoutts_: somewhat like that
07:51:57 <dcoutts_> Cheery: at each level you have three possibilities, it's then end of the path and we're done, or the path can carry on taking the left or right branches
07:52:04 <uccus> slight trouble here... runCont has type (a -> r) -> r [for all a, r, I think... as they appear on the left side of type Cont r a = ...]
07:52:09 <uccus> now djinn says
07:52:14 <dcoutts_> Cheery: so you need two bits to encode those three things
07:52:16 <uccus> ?djinn (a -> r) -> r
07:52:16 <lambdabot> -- f cannot be realized.
07:52:37 <skorpan> http://hpaste.org/6586
07:52:50 <dcoutts_> Cheery: so you just need a function to encode/decode a Path from an integer bit representation using two bits per path element
07:52:58 <Saizan> ?type runCont
07:52:59 <lambdabot> forall r a. Cont r a -> (a -> r) -> r
07:53:24 <dcoutts_> Cheery: is there a limit on the number of bits?
07:54:10 <Saizan> uccus: runCont takes a (Cont r a) which contains a function of type (a -> r) -> r, than it's easy to prove (a -> r) -> r with id
07:54:15 <Cheery> well, I thought about aligning stuff to four bytes, so I have two free bits
07:54:19 <Saizan> s/than/then/
07:54:30 <Cheery> per each item in my tree
07:54:51 <uccus> Saizan: argh. I think I understand.
07:55:03 <dcoutts_> Cheery: you can use a more dense encoding, I think you could fit two tree levels into three bits
07:55:31 <Saizan> uccus: while (a -> r) -> r is not a theorem by itself, once you've (a -> r) you need an a to get r
07:55:50 <uccus> yes but I don't see where that a is coming from!
07:56:27 <uccus> even in the (Cont r a) thing, you've got an (a -> r) -> r function...
07:56:43 <Saizan> uccus: it's stored in the function, so to speak
07:57:09 <Jaak> @type callcc
07:57:10 <lambdabot> Not in scope: `callcc'
07:57:11 <uccus> you mean, you apply runCont to an 'a'?
07:57:13 <Jaak> @type callCC
07:57:15 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
07:57:23 <Saizan> uccus: no
07:57:49 <Saizan> ?type Cont $ \k -> k 'a'
07:57:50 <lambdabot> forall r. Cont r Char
07:58:02 <uccus> :s
07:58:12 <uccus> I meant... something of type a
07:58:27 <Saizan> 'a' is that something of type a, where a = Char here
07:58:44 <uccus> right :)
07:58:59 <scook0> > let peel n xs = let (chunk, rest) = splitAt n xs in if null chunk then Nothing else Just (chunk, rest) in unfoldr (peel 5) "Lorem ipsum dolor sit amet."
07:59:00 <lambdabot>  ["Lorem"," ipsu","m dol","or si","t ame","t."]
07:59:02 <Saizan> instead of returning 'a' directly, you take a function and pass it as a parameter
07:59:43 <uccus> "the rest of the computation"... I think I understand that
08:00:28 <Saizan> yup
08:00:35 <uccus> Cont r a -- here a is what is being passed, and r is what I would get after the continuation is finished?
08:00:47 <Saizan> exact
08:01:19 <uccus> then why does callCC has such a weird type? :s
08:02:39 <Saizan> well because it takes a function which takes as a parameter what's after callCC
08:02:53 <uccus> umm... I can't figure out the type of k here ... in Cont $ \k -> k 'a'... is it (Char -> r)? what's r?
08:03:26 <scook0> @type Cont
08:03:27 <lambdabot> forall a r. ((a -> r) -> r) -> Cont r a
08:03:35 <Saizan> uccus: it's (Char -> r), r is the type you'òò get when you use runCont and pass the final continuation
08:04:50 <uccus> argh everything is upside down... well definitely something to think about with greater enthusiasm... but I have a simpler question though
08:05:28 <uccus> Cont and callCC and runCont... I mean the whole deal... is expressible in terms of combinators, no?
08:05:35 <uccus> the S K I combinators?
08:05:37 <ttt--> @djinn Integer -> Integer
08:05:37 <lambdabot> f a = a
08:05:54 <desegnis> > unfoldr (\s -> let (t,u) = splitAt 10 s; (t1,t2) = break isSpace (reverse t) in if null t2 then Nothing else Just (reverse (tail t2),reverse t1 ++ u)) "one two three four five six seven"
08:05:55 <lambdabot>  ["one two","three","four five","six"]
08:06:00 <Saizan> ?type let callCC f = Cont $ \k -> runCont $ f (\a -> Cont $ \_ -> k a)) k in callCC
08:06:01 <lambdabot> parse error on input `)'
08:06:11 <Saizan> ?type let callCC f = Cont $ \k -> runCont $ f (\a -> Cont $ \_ -> k a) k in callCC
08:06:12 <lambdabot> forall a a1 r a2. ((a -> Cont ((a1 -> r) -> r) a2) -> (a -> (a1 -> r) -> r) -> Cont r a1) -> Cont ((a1 -> r) -> r) a
08:06:17 <ttt--> @djinn [Integer] -> Integer
08:06:17 <lambdabot> -- f cannot be realized.
08:06:52 <uccus> is it the official definition?
08:07:12 <Saizan> uccus: no, i must have screwed something :)
08:07:21 <uccus> :)
08:07:32 <byorgey> ttt--: djinn can't do lists, I think
08:07:37 <Saizan> ?type let callCC f = Cont $ \k -> runCont (f (\a -> Cont $ \_ -> k a)) k in callCC
08:07:38 <lambdabot> forall a r a1. ((a -> Cont r a1) -> Cont r a) -> Cont r a
08:07:38 <uccus> why, didn't the type come out right? [I have no idea]
08:07:50 <desegnis> skorpan: Not horribly efficient, but see above
08:08:10 <Saizan> uccus: no the first time it didn't
08:08:21 <Saizan> ?djinn ((a -> Cont r a1) -> Cont r a) -> Cont r a
08:08:21 <lambdabot> f a b = a (\ c _ -> b c) b
08:08:36 <Saizan> :)
08:08:39 * uccus takes notes
08:08:47 <Saizan> that's without the newtype wrapper ^^^
08:09:14 <Saizan> uccus: however yes, Cont and the functions on it are defined in pure haskell
08:09:24 <uccus> and a newtype wrapper is just a wrapper so I don't really need to worry about those, right?
08:09:53 <uccus> you mean... theoretically, in terms of S K combinators?
08:10:38 <uccus> f a b = a (\c _ -> b c) b -- looks like rather simple lambda expression... but scary since there's an _ in there
08:10:53 <skorpan> desegnis: ouch.
08:11:00 <Saizan> well _ just means you don't care about that parameter
08:11:15 <byorgey> uccus: you could replace the _ by, say, d
08:11:19 <byorgey> the point is that it is not used
08:11:30 <uccus> I understand that... the only thing I'm concerned about is that why would there be an unused parameter here :s
08:11:58 <desegnis> skorpan: Does it hurt so much? :)
08:12:04 <Saizan> uccus: it's the continuation passed to (a -> Cont r b) which is discarded
08:12:22 <Jaak> @type \a b -> a (\c d -> b c) b
08:12:23 <lambdabot> forall t t1 t2 t3. ((t -> t1 -> t2) -> (t -> t2) -> t3) -> (t -> t2) -> t3
08:12:35 <skorpan> desegnis: i decided to go for forcing the user to enter \n where she wants newlines and just do lines/unlines
08:13:04 <Jaak> @type let s = ap; k = const in s k
08:13:05 <lambdabot> forall a b. (a -> b) -> a -> a
08:13:24 * desegnis didn't catch the context
08:13:50 <skorpan> desegnis: of course not, and i forgive you for that
08:14:38 <uccus> Jaak... let s = ap ; k = const in [???] would give me  t t1 t2 t3. ((t -> t1 -> t2) -> (t -> t2) -> t3) -> (t -> t2) -> t3?
08:14:45 <uccus> *forall?
08:15:35 <Saizan> @pl \a b -> a (\c d -> b c) b
08:15:35 <lambdabot> join . (. (const .))
08:18:33 <jaj> Hi! I was wondering if there was a way to compose constructors like you compose functions using .
08:18:33 <uccus> that's practically undecipherable to me
08:18:35 <Jaak> uccus: lambda expressions are quite easy to compile into SKI. will take some time to dig up the translation rules, tho'
08:18:58 <uccus> yeah I reckon it's enough for me that it's doable
08:18:59 <byorgey> jaj: well, constructors are functions too
08:19:16 <jaj> yeah but . doesn't work for some reason
08:19:20 <Saizan> jaj: you can use (.) for constructors too in expressions, but not in patterns
08:19:22 <uccus> I think jaj means something different... he means as a pattern
08:19:52 <byorgey> jaj: can you give an example of what you are trying to do?
08:20:51 <uccus> jaj, try nesting them
08:21:04 <jaj> well I'm still a beginner in haskell and I did the following tho calculate pi: http://hpaste.org/6587
08:22:16 <jaj> and I'd like to write a = map Sq.N tmp
08:22:42 <uccus> try map (Sq . N) tmp
08:22:47 <Saizan> jaj: ooh, you've to use spaces
08:23:00 <Saizan> like uccus says
08:23:01 <jaj> Not in scope: data constructor `Sq.N'
08:23:25 <uccus> yeah, use (Sq . N) -- note the spaces, instead
08:23:28 <scook0> it thinks you're trying to use the N constructor from the Sq module
08:23:35 <Saizan> jaj: if you use Sq.N, Sq is parsed like a module name
08:23:35 <jaj> oh yeah it works now :)
08:23:42 <uccus> :)
08:23:56 <scook0> and bear in mind that the parentheses are necessary too
08:24:02 <byorgey> a rather obscure and ugly corner of Haskell parsing rules, that...
08:24:05 <jaj> thanks a lot!
08:24:15 <scook0> or else you'd end up with (map Sq) . (N tmp)
08:24:16 <byorgey> > [False..]
08:24:16 <lambdabot>  Parse error at "False..." (column 2)
08:24:20 <byorgey> > [False ..]
08:24:21 <lambdabot>  [False,True]
08:24:36 <uccus> yeah, dots everywhere
08:25:23 <uccus> ?type callCC
08:25:24 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
08:25:25 <scook0> it would be nice to get a warning for those
08:26:07 <scook0> e.g. if Sq.N doesn't exist, say "Maybe you meant Sq . N"
08:27:09 <byorgey> scook0: that would be nice indeed.  let's file a GHC feature request!
08:27:15 <uccus> here m is (Cont r)?
08:29:05 <scook0> well, I have to go sleep, but feel free to file one by yourself :)
08:31:35 <fmanners> lambdabot: (1+) <$> (Data.Map.singleton 1 2)
08:31:48 <dozer> I've cleaned the teapot and built a raised bed in the garden - I should probably get back to coding
08:32:30 <vixey> hiya
08:32:51 <dozer> dons?
08:32:55 <vixey> Does anyone have a small narrowing based functional logic language coded in Haskell?
08:34:21 <fmanners> vixey: What would one of those consist of?
08:35:20 <vixey> fmanners: I'm not totally sure but I don't really understand narrowing so I wanted to read some code ..
08:37:41 <matthew_-> ghc-6.8.2: panic! (the 'impossible' happened)
08:37:44 <matthew_-> yay
08:38:39 <kaaaen> beginners question, how do i round (Int / Int) to an Int?
08:38:55 <vixey> :t round
08:38:56 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
08:39:08 <vixey> I think you should use truncate
08:39:23 <vixey> or `div` instead of /
08:39:43 <wolverian> if he wants to round, he should use rounding...
08:39:51 <vixey> :t rounding
08:39:52 <lambdabot> Not in scope: `rounding'
08:40:06 <wolverian> I meant the concept :)
08:40:09 <vixey> @let rounding = truncate . (+0.5)
08:40:09 <lambdabot> Defined.
08:40:11 <vixey> :t rounding
08:40:12 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
08:40:17 <kaaaen> round:
08:40:49 <byorgey> kaaaen: you probably want div.
08:40:54 <byorgey> > 7 `div` 3
08:40:55 <lambdabot>  2
08:40:59 <wolverian> > round (7 / 3)
08:41:00 <lambdabot>  2
08:41:31 <wolverian> > round (8 / 3)
08:41:32 <lambdabot>  3
08:41:37 <wolverian> > 8 `div` 3
08:41:38 <lambdabot>  2
08:42:00 <wolverian> so they are different, and he originally did ask for a rounding function. naturally, he might be wrong about what he needs. :)
08:42:23 <kaaaen> probably :)
08:42:36 <byorgey> kaaaen: what are you trying to accomplish?
08:42:48 <kaaaen> seems to work if I use Integer instead of Int
08:42:49 <vixey> in any case I already suggested all those..
08:43:17 <kaaaen> Well, im a beginner... so I just try to make basic (small) programs with io
08:43:39 <byorgey> kaaaen: do you know the difference between Int and Integer?
08:44:03 <kaaaen> nope
08:44:23 <byorgey> kaaaen: Int is a machine-sized integer value, so it has limits
08:44:27 <byorgey> > maxBound :: Int
08:44:28 <lambdabot>  2147483647
08:44:30 <kaaaen> Well, should probably l2google instead of herassing you :)
08:44:44 <byorgey> kaaaen: whereas Integer represents arbitrary integers
08:44:57 <byorgey> > 2^200 :: Int  -- wrong
08:44:57 <lambdabot>  0
08:45:03 <byorgey> > 2^200 :: Integer -- ok!
08:45:04 <lambdabot>  1606938044258990275541962092341162602522202993782792835301376
08:45:22 <byorgey> kaaaen: you're not harassing anyone =)
08:45:32 <kaaaen> Well, thanks... You'll probably see me later tonight :P
08:46:03 <byorgey> kaaaen: sounds good, we like to help beginners (shocking, isn't it? ;)
08:46:16 <\z> byorgey++
08:46:22 <frwmanners> \window 1
08:46:25 <frwmanners> sorry
08:46:28 <\z> byorgey: nice presentation for fringedc on saturday
08:46:36 <byorgey> \z: thanks! =)
08:46:46 <byorgey> \z: which one were you?  did we meet?
08:47:04 <\z> byorgey: at the end of the talk, I came by to introduce myself.  couldn't make it for mongolian afterward
08:47:20 <phlpp> i think there's a need for a distributed computing programm written in haskell which is supposed to find the first odd, perfect number :>
08:47:21 <byorgey> ah, ok
08:47:58 <vixey> ph1pp: I think people will get there before computers
08:48:15 <phlpp> hehe
08:48:18 <\z> byorgey: you mentioned that monads aren't strictly about ordering operations.
08:48:34 <\z> Did you have any examples in mind aside from choosing one action of many, or possibly MonadCont?
08:49:42 <byorgey> \z: well, I didn't have any particular examples in mind, but just the general fact that sequencing is determined by data dependencies.
08:49:55 <\z> byorgey: ah, ok.
08:50:23 <byorgey> \z: the Monad operations in and of themselves don't impose any particular data dependencies, it depends on the particular implementation of return and >>= for each Monad.
08:50:31 <matthew_-> wow, nomonomorphism restriction can go very wrong and cause ghc to crash
08:50:43 <dozer> I have some patches to monadrandom that I'd like to push
08:51:03 <dozer> where do I push to? I can't find an email address of an owner
08:51:59 <mrd> matthew_-: what?
08:52:13 <dcoutts_> Saizan: btw, if you want another useful bug fix, #187 should be similar to #166, ie another tricky seach path issue.
08:52:18 <matthew_-> mrd: well this might only be in combination with type families
08:52:28 <dcoutts_> Saizan: and those two are the last two defects targeted for Cabal-1.4
08:52:37 <mrd> MR is a syntactic restriction
08:52:48 <mrd> type families though, yea...
08:52:53 <pjd> \z: it's more accurate to say that ordering operations is one particular thing you can do with monads
08:53:06 <pjd> (the IO/State kind of monads, particularly)
08:53:14 <matthew_-> mrd: but basically, I had a function with no type sig which required nomonomorphism restriction. Loading it in ghci caused ghc to crash "the impossible happened". Adding an explicit type sig made it type check correctly
08:53:29 <\z> pjd: most defintions of >>= / return I've seen include some kind of dependency mechanism
08:53:47 <mrd> matthew_-: what function and ghc version?
08:53:50 <\z> pjd: can you think of a monad that doesn't require that kind of ordering / dependency?
08:54:09 <mrd> matthew_-: that's a bug ... ghc from darcs?
08:54:42 <matthew_-> mrd: ghc 6.8.2
08:54:47 <pjd> \z: list?
08:54:54 <pjd> depends how you define "that kind of ordering"
08:54:59 <matthew_-> mrd: and I know type synonynm families aren't supported properly in that
08:55:12 <mrd> so your type involves those?
08:55:20 <matthew_-> well, not really
08:55:36 <matthew_-> but the trace coming out of ghc's crash involved those
08:55:46 <\z> pjd: I saw a few people playing with ((->) r) last week, and I guess that would qualify for something that doesn't enforce ordering
08:55:47 <matthew_-> I mean, they are involved, but existentially
08:55:55 <pjd> \z: right
08:55:58 <matthew_-> they weren't really exposed through the function
08:56:00 <\z> but I can't seem to find the instance definition that makes ((->) r) a monad
08:56:08 <mrd> matthew_-: can you hpaste it
08:56:20 <pjd> @src (->) >>=
08:56:20 <lambdabot> Source not found. :(
08:56:25 <matthew_-> mrd: yeah, it's only about 3000 lines of type buggery
08:56:28 <pjd> @src ((->) r) >>=
08:56:29 <lambdabot> Source not found. Are you on drugs?
08:56:32 <pjd> oh well
08:56:37 <pjd> Control.Monad.Instances
08:56:47 <pjd> and/or Control.Monad.Reader
08:57:25 <mauke> @src (->) (>>=)
08:57:25 <lambdabot> f >>= k = \ r -> k (f r) r
08:57:34 <pjd> doy
08:57:34 <mrd> hmm
08:57:36 <vixey> I thought Haskell would be a real contender for implementation of lazy declarative languages
08:57:39 <\z> Ah, that'll do it.  Control.Monad.Instances handles ((->) r) and a little bit of (,) and Either
08:57:48 <pjd> @src (->) fmap
08:57:48 <lambdabot> fmap = (.)
08:57:50 <pjd> @src (->) join
08:57:51 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
08:57:54 <vixey> seems that people are still compiling to the WAM and such
08:58:00 <vixey> or just writing in C or Java
08:58:33 <daf> vixey: WAM?
08:58:56 <dozer> @src replicateM
08:58:56 <lambdabot> replicateM n x = sequence (replicate n x)
08:59:12 <dozer> @src replicate
08:59:12 <lambdabot> replicate n x = take n (repeat x)
08:59:36 <dozer> @src sequence
08:59:36 <lambdabot> sequence []     = return []
08:59:36 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
08:59:36 <lambdabot> --OR
08:59:36 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
09:00:02 <pjd> nice; when did lambdabot grow the latter bit?
09:00:20 <dozer> ok, so one version of sequence is lazy, and the other (liftM2) is eager?
09:00:31 <dozer> @src liftM2
09:00:31 <vixey> pjd: Cale might know
09:00:31 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
09:00:35 <mauke> dozer: no
09:00:37 <dolio> Cale added it a week or two ago.
09:00:39 <\z> what was the inspiration that led to Monad ((->) r) ?
09:00:41 <dozer> no, ok
09:00:42 <vixey> /have done it
09:00:42 <pjd> dozer: they're equivalent
09:01:12 <pjd> \z: functions naturally form one, i guess
09:01:39 <frwmanners> \z: Functions have to be at least Functors, or else (.) wouldn't work
09:01:40 <\z> pjd: it seems like that
09:02:09 <\z> it looks like it's not built to solve a problem, but express a property of functions
09:02:17 <\z> like MonadState solves a problem, for example
09:02:49 <dolio> (->) r is equivalent to Reader r.
09:03:17 <\z> really?
09:03:24 <mauke> @src Reader
09:03:24 <lambdabot> Source not found. My pet ferret can type better than you!
09:03:29 <mauke> what!
09:03:37 <byorgey> \z: yes, Reader is just a newtype wrapper around ((->) r)
09:03:39 <gbacon> @src Reader (>>=)
09:03:39 <lambdabot> Source not found. I've seen penguins that can type better than that.
09:03:46 <gbacon> @src (>>=) Reader
09:03:46 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
09:03:50 <mauke> newtype Reader e a = Reader (e -> a)
09:03:54 <gbacon> phbbbt :-P'
09:04:07 <\z> then the syntax must be throwing me, because I'm not reading (->) r as half of r -> a
09:04:32 <dolio> (->) r ~ (r ->)
09:04:38 <dolio> If you could section type operators.
09:04:40 <mauke> (->) r a == r -> a
09:04:43 <\z> and looking at the 6.8.2 haddock docs,
09:04:50 <\z> newtype Reader r a = Reader {runReader :: (r -> a)}
09:04:50 <mauke> (+) 1 2 == 1 + 2
09:05:05 <\z> which is equivalent, but doesn't look it at first glance.  ;-)
09:05:21 <byorgey> hehe, indeed =)
09:06:35 <cinimod> I have a haddock quesion: what should I use for --read-interface?
09:07:05 <frwmanners> @src (->) return
09:07:05 <lambdabot> return = const
09:07:34 <\z> I guess I never saw the correspondance, because the discussion of Reader is about environments like [(String, Value)], and the ((->) r) discussion was about environments like 3 :: Int
09:09:16 <cinimod> I don't seem to have any *.haddock files on my installation to point to.
09:16:28 <DRMacIver> Hm. What does one need to do to get Yi working? It cheerfully installs but just seems to result in a bunch of ghc libraries rather than an application I can actually run.
09:18:34 <DRMacIver> Ah. You use the makefile rather than cabal.
09:18:37 <marshmallows> does anyone know Curry?
09:19:52 <mrd> DRMacIver: good luck though, it seems that every example config is broken
09:20:01 <DRMacIver> Marvelous. :-)
09:20:16 <mrd> at least you can get a keymap with --as=emacs or vim
09:20:29 <DRMacIver> I'm not all that dedicated. If it takes more more than another 20-30 minutes I'm probably going to give up. :)
09:21:07 * DRMacIver just hasn't been doing enough Haskell recently and thought playing with some tools that actually use it might inspire him to do so
09:21:32 <DRMacIver> ("I've not been doing enough Haskell recently" has been my litany for far too long)
09:21:40 <ertai> DRMacIver: what version of yi do you try
09:21:52 * DRMacIver is trying the version from darcs
09:22:05 <DRMacIver> As the previous ones have a "Dont' use these with the latest version of ghc" disclaimer
09:22:10 <DuClare> Can Cabal fetch and install packages from the net?
09:22:25 <dcoutts_> yep
09:22:26 <marshmallows> DuClare: cabal-install can
09:22:32 <dcoutts_> @where cabal-install
09:22:32 <lambdabot> http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
09:22:39 * dcoutts_ uses it all the time
09:23:13 <DuClare> I upgraded ghc and cabal but my distro apparently doesn't provide packages like bytestring
09:23:20 <DuClare> The new split base packages. :o
09:23:37 <ertai> DRMacIver: have you followed the "QUICK START with cabal-make" in README?
09:24:07 <dcoutts_> DuClare: are you sure, it's pretty much impossible to build ghc-6.8 without the core packages, they'd have to do something pretty odd to avoid doing so.
09:24:14 <dcoutts_> DuClare: check the output of ghc-pkg list
09:24:45 <DuClare> Oh
09:24:46 <DuClare> Hmm.
09:24:48 <DuClare> It indeed is there.
09:24:54 <dozer> ghci is saying: *** Exception: stack overflow
09:24:56 <DuClare> I wonder why things fail then.
09:25:17 <DuClare> regex-base for example;
09:25:20 <DuClare>     Could not find module `Data.ByteString':
09:25:23 <DuClare>       it is a member of package bytestring-0.9.0.1, which is hidden
09:25:31 <dcoutts_> DuClare: oh, that's different
09:25:32 <dozer> as does the same code when I compile it and run it
09:25:35 <dcoutts_> @where cabal-faq
09:25:35 <lambdabot> http://haskell.org/haskellwiki/Cabal/FAQ
09:25:40 <DRMacIver> ertai: When I follow it I get the install process shouting !!! DEPRECATED !!! at me. :)
09:26:20 <dcoutts_> DuClare: you need to use the regex-base package that comes with ghc-6.8 rather than the older one that came with 6.6, you can get all such versions from hackage
09:26:27 <dozer> do you usually get stack overflows when a program is building very big thunks?
09:26:38 <dcoutts_> DuClare: sorry, not comes with 6.8, but works with 6.8
09:27:28 <ertai> DRMacIver: I try to build a fresh one
09:29:35 <dcoutts_> DRMacIver: there's quite a bit wrong or unpleasent in that cabal-make.inc, I wonder how much is really needed. Perhaps someone can figure out what the missing features in Cabal are and make sure the feature requests have been filed.
09:32:02 <DRMacIver> dcoutts_: I'm certainly in favour of plans that involve not using make. :)
09:32:06 <yuriyp> http://haskell.org/haskellwiki/Cabal/FAQ
09:32:08 <lambdabot> Title: Cabal/FAQ - HaskellWiki
09:32:58 <byorgey> dozer: you often get stack overflows when evaluating very big thunks.
09:33:26 <dcoutts_> DRMacIver: I suspect one of the main ones is darcs integration
09:33:29 <DRMacIver> Hm. It's kinda painful how long cabal install takes to check out from darcs.
09:33:47 <dcoutts_> oh, I should tag it
09:33:52 <byorgey> dozer: http://haskell.org/haskellwiki/Stack_overflow might be helpful
09:33:53 <lambdabot> Title: Stack overflow - HaskellWiki
09:34:04 <dozer> byorgey: yup - the thing is, I don't know where my realy big thunks are comming from - I have no explicit calls to fold*
09:34:24 <dozer> I have quite a few calls to replicateM and mapM though
09:34:48 <byorgey> dozer: hm, that could do it, depending on the monad...
09:35:26 <dozer> byorgey: the monad is probbly RandT g IO a
09:35:29 <ttt--> what does a # mean, like in "import GHC.Base (unsafeCoerce#)" ?
09:36:27 <byorgey> ttt--: it usually indicates a low-level, built-into-GHC primitive operation, or a primitive unboxed type
09:36:28 <Igloo> By convention it means the function is a primitive or deals with primitive types
09:36:55 <ttt--> is it part of the function name?
09:37:04 <ertai> DRMacIver: I've successfully rebuilt it
09:37:24 <ertai> DRMacIver: just copy the config.sample to config.mk and run make install
09:37:42 <byorgey> dozer: hmm, looks like RandT is built using StateT
09:37:51 <ertai> DRMacIver: I've run into an issue about my version of haddock
09:37:54 <dozer> byorgey: yeah
09:37:54 <DRMacIver> ertai: Yeah. I figured that out. :) I'm just sorting out dependencies
09:37:59 <byorgey> dozer: which is not strict in the state, IIRC
09:38:08 <ertai> DRMacIver: then just run ./dist/build/Yi/yi
09:38:13 <ertai> DRMacIver: ok
09:39:00 <byorgey> dozer: I dunno, I'm just throwing out random thoughts =)
09:39:01 <ttt--> oh i see, so i wont find the source of it in haskell-form
09:39:08 <byorgey> dozer: can you paste your code?
09:39:25 <dozer> byorgey: there's quite a lot of it unfortunately
09:39:32 <byorgey> dozer: ah =)
09:39:53 <dozer> give me a mo to get it hosted somewhere
09:40:06 <byorgey> ttt--: nope.  it's usually either implemented in the GHC source, or corresponds to a machine instruction
09:40:20 <ttt--> thanks
09:44:49 <DuClare> Dangit, this'll get messy. :o
09:44:56 <dozer> @paste
09:44:56 <lambdabot> Haskell pastebin: http://hpaste.org/new
09:44:58 <DuClare> Maybe I won't even try to fix it.
09:51:44 <DRMacIver> Hm
09:53:44 <DuClare> If I were to fix the packages, I'd have to edit the cabal files ...  So I'd be better doing it outside my package manager altogether.  But then I guess I should also first get rid of the packages that came from package manager ...  That would also mean getting rid of every haskell package that was made to depend on the previous packages, etc. -_-
09:54:27 <DuClare> So I'd end up blasting every darn haskell package and installing (& taking care of!) them all by hand. :/
09:54:57 <DRMacIver> I'm getting the following error trying to build cabal-install: http://hpaste.org/6592
09:55:00 <DRMacIver> Any idea what's up?
09:55:32 <DRMacIver> My best guess are that either a) The darcs version of cabal and cabal-install have gotten out of synch or b) I've done something stupid
09:55:43 <DRMacIver> Money is on b. :)
09:58:34 <benny99> I wonder how important arrows really are --
09:58:57 <Philippa> it depends entirely on the task at hand
09:59:23 <Philippa> (assuming that we're talking about arrows-that-aren't-monads - you can't get far without the IO monad)
09:59:57 <DRMacIver> Well, even if arrows-that-are-monads are individually useful it doesn't follow that arrows are a useful abstraction.
10:00:14 <DRMacIver> (not saying they aren't. Just that it doesn't follow)
10:00:56 <dozer> byorgey: http://hpaste.org/6590#a4
10:01:09 <Philippa> DRMacIver: it only takes a couple of arrows-that-aren't-monads for the abstraction to start paying off though
10:01:18 <DRMacIver> Sure
10:01:20 <benny99> I'm actually a beginner and reading a paper about them -- it appears as if some functions got some cosmetic changes and that's the whole advantage so far... but you got to know much new stuff
10:01:49 <Philippa> benny99: changes to types're rarely cosmetic
10:02:02 <DRMacIver> I'm not claiming that it's not. I'm just saying - the fact that individual arrows are useful does not inherently mean that arrows are a useful concept.
10:04:10 <frwmanners> If I'm making class interfaces where I'm building bigger components using smaller components, I end up with silly types such as class (Interface1 a, Interface2 b, Interface3 c) => Interface4 a b c
10:04:24 <frwmanners> Which funky new type extension should I be using
10:04:46 <benny99> guess it won't hurt to know about arrows anyway hm ?
10:05:01 <DRMacIver> If nothing else, the error combinators are handy for functions. :)
10:05:32 <Taejo> what does this mean "Warning: Data.HMM: could not find link destinations for: Data.Lognum.Lognum"? I have no module called Data.Lognum.Lognum (it's called Data.Lognum)
10:05:46 <benny99> it'll probably not be discarded in ghc 6.9.1 or become the "haskell-goto" .. hm?
10:06:37 <DRMacIver> I seriously doubt it. :-)
10:07:26 <DRMacIver> It's not part of GHC anyway is it? It's a separate package
10:09:50 <Philippa> the sugar's part of GHC
10:10:04 <DRMacIver> Oh yes. I'd forgotten it had special sugar
10:10:08 <Philippa> benny99: it's unlikely to be discarded, the sugar doesn't use up particularly precious namespace or anything like that
10:10:42 <Philippa> it took long enough to discard linear implicit parameters and there're engineering reasons for ditching them and implicit parameters generally are an ugly hack hardly anyone likes
10:10:51 <benny99> ok, so reading that paper is no waste of time I hope :)
10:10:53 <Philippa> (not least their creator!)
10:11:16 <Philippa> you might be better off coming back to it unless you want to do something you know needs them now
10:11:29 <elaforge> ironically I finally came up with a use for them... dynamically scoped "system contexts" for log msgs
10:11:38 <elaforge> maybe there's a better way though
10:11:55 <Philippa> elaforge: normal way to do that'd be a state monad
10:12:13 <benny99> (yep, completely different topic) elaforge: do you know some 'sweet logger' ?
10:12:23 <DRMacIver> I like implicit parameters. :)
10:12:29 <DRMacIver> But that might be Scala damage speaking.
10:12:33 <elaforge> ya, true I guess.. but then everything has to be wrapped into State.. but I guess it's going to be either in IO or a Writer type thing anyway
10:12:41 <benny99> DRMacIver: implicit parameters?
10:12:57 <elaforge> benny99, no, is that something in particular?
10:12:58 <pejo> Philippa, who was the creator?
10:13:06 <Philippa> pejo: I'd have to look it up
10:13:07 <elaforge> or you just mean "a good logging library"?
10:13:22 <dolio> Oleg has a bit on his website about how implicit parameters aren't actually dynamically scoped.
10:13:24 <Philippa> I think there was a paper or similar you can search for though
10:13:52 <DRMacIver> benny99: GHC feature. Basically function arguments which get pulled out of the enclosing scope rather than being explicitly applied.
10:13:56 <DRMacIver> benny99: Not very popular.
10:15:02 <benny99> elaforge: no, I'm just looking for some functions that allows me to output a log into an html-file for example (i.e. if initWorked then log "Init Worked!" VERBOSE else log "Oh noz...")
10:15:02 <dolio> And he has a paper on making actual dynamically scoped variables using delimited continuations.
10:15:15 <elaforge> why does Monad.State re-export all the Monad.Trans stuff?
10:15:25 <dolio> (and CC-delcont includes a module for those)
10:16:09 <elaforge> benny99, oh dunno then.  there's a complicated one in hackage that looks oriented around IO.  I'm sorta rolling my own oriented around monad transformers
10:16:18 <benny99> elaforge: "a good logger library" <- guess so
10:16:38 <benny99> uh, monad transformers --- I should know about them as well I guess?
10:16:49 <Taejo> when I run "Setup.lhs haddock" I get only a warning, but only index.html (and not the other docs) is produced. Help?
10:16:55 <Philippa> yeah, monad transformers will be far more useful to you than arrows in most cases
10:16:57 <oerjan> logging = MonadWriter, more or less?
10:17:08 <Philippa> oerjan: right up 'til you try spitting it out to disk, anyway
10:17:11 <elaforge> just so that the log function can do IO in IO or it can user a Writer if it's not in IO
10:17:17 <yuriyp> @where literate
10:17:17 <lambdabot> I know nothing about literate.
10:17:28 <elaforge> speaking of which...
10:17:36 <oerjan> Philippa: you could probably make an instance that did that automatically
10:17:40 <elaforge> is there any way to get at whatever magic ghc uses for assert to get the file and line number?
10:17:49 <elaforge> is it some rewrite pragma or something?
10:18:01 <dcoutts_> Taejo: what does the warning say?
10:18:11 <Taejo> Warning: Data.HMM: could not find link destinations for:    Data.Lognum.Lognum
10:18:24 <Taejo> there is no such module as Data.Lognum.Lognum
10:18:40 <benny99> elaforge: ok, I'll roll my own as well then -- got to have some tasks anyway
10:18:42 <DuClare> What is the neatest way to fix the problem with hidden packages?
10:18:45 <dcoutts_> Taejo: that could be a type Lognum from the module Data.Lognum
10:18:55 <benny99> Philippa: thanks, any papers you could recommend ?
10:19:08 <dcoutts_> Taejo: and there are actually some exposed modules in this library?
10:19:11 <elaforge> benny99: you should at least read the docs for the hackage Logging module, maybe it does just what you want
10:19:29 <Taejo> dcoutts_: Data.HMM is exposed, Data.Lognum is not
10:19:32 <benny99> elaforge: thanks, I'll do that :)
10:19:46 <elaforge> but if what you want is simple you can write "log_msg = print and get more complicated later if you need it :)
10:20:07 <dcoutts_> Taejo: so the index.html doesn't have a link to the Data.HMM documentation?
10:20:07 <benny99> elaforge: ok, I'll take a look at that later :)
10:20:09 <Philippa> benny99: tbh, papers aren't the best source for monad transformers. IIRC the old nomaware monad tutorial's got some stuff on them, and you should have a poke around the transformers in Control.Monad.* and try using them
10:20:11 * benny99 is away
10:20:27 <benny99> Philippa: ok, thanks :)
10:20:47 <Taejo> dcoutts_: hang on, something weird seems to be going on... I'll have to investigate
10:20:49 <Philippa> there's a paper on using monad transformers to build interpreters that might be worth reading
10:21:09 <Philippa> haskell.org/papers/modular-interpreters.ps
10:21:13 <benny99> thanks :)
10:21:18 * benny99 is really away now
10:22:23 <Taejo> dcoutts_: it seems like I was looking at old documentation (does the new cabal put haddock output in a different place to the old one?)
10:22:40 <dcoutts_> Taejo: it should say where it puts it
10:23:36 <skorpan> what would you call the mechanism that ErrorT provides? error reporting?
10:23:47 <Taejo> yeah, I was too lazy to read that properly (I was looking in dist/doc/html/, not dist/doc/html/<pkg-name>
10:23:48 <skorpan> currently writing my project report :)
10:23:51 <elaforge> exceptions?
10:23:56 <skorpan> elaforge: true
10:23:58 <skorpan> any other suggestions?
10:24:01 <dozer> still not tracked down this tack overflow - are there any tricks to locating them?
10:24:18 <oerjan> elaforge: you could probably make an instance MonadWriter String IO where tell = putStr; etc. er, actually the listen and pass methods might be awkward
10:24:21 <elaforge> problem is haskell has IO exceptions and monadic exceptions
10:24:46 <oerjan> skorpan: escape actions?
10:25:06 <elaforge> oerjan, yeah, I'd probably make a "subclass" of WriterT that just supports tell
10:25:12 <dcoutts_> elaforge: IO exceptions are monadic exceptions
10:25:17 <dcoutts_> the IO monad is an error monad
10:25:20 <skorpan> what are the datatypes which look like records called? i.e. data A = { b :: B, c :: C }?
10:25:24 <dcoutts_> with fail and catch etc etc
10:25:31 <elaforge> dcoutts_ oh really?  how about async ones coming from pure functions?
10:25:38 <dcoutts_> those are not monaic
10:25:42 <dcoutts_> monadic
10:25:48 <dcoutts_> but H98 IO exceptions certainly are
10:25:53 <elaforge> I guess "async" is what I meant by IO, sorry :)
10:26:16 <byorgey> skorpan: I don't know if they have a special name.  "algebraic data types with record syntax", perhaps
10:26:25 <skorpan> lol okay thanks
10:26:29 <elaforge> I thought they were just called "records"
10:26:44 <byorgey> yes, that would be an entirely reasonable shorthand =)
10:26:46 <dcoutts_> elaforge: those are not really async, they're synchronous. They're also sometimes called imprecise exceptions or just exceptions.
10:26:47 <oerjan> skorpan: it's just thin syntactic sugar that doesn't add any real power
10:26:57 <skorpan> okay
10:27:29 <elaforge> dcoutts_, really?  but doesn't the paper on them call them that?  in addition to "imprecise" of course
10:27:36 <elaforge> e.g. throwTo
10:27:47 <dcoutts_> those are async exceptions, but 'error' is not
10:28:04 <dcoutts_> throwTo is exactly async exceptions, exceptions thrown by pure code are not async
10:28:09 <elaforge> ok, then we have 3 kinds of exceptions :)
10:28:25 <dcoutts_> which can all be stuffed into Control.Exception
10:28:40 <dcoutts_> and Control.Exception.catch can catch them all
10:29:14 <elaforge> right, agreed
10:29:40 <Philippa> dcoutts_: ...within the greater context, exceptions thrown by pure code are very much async
10:30:20 <dcoutts_> they do not need special treatment with block/unblock etc
10:30:21 <Philippa> it's just that if all you have are the pure ones and no threads, the resulting system's still synchronous
10:30:58 <dozer> @src mapM
10:30:58 <lambdabot> mapM f as = sequence (map f as)
10:37:52 <mohbana> is anyone going to do the rss feed project in the google SOC?
10:38:05 <mohbana> how hard is it on like a scale of 1-10
10:39:35 <byorgey> mohbana: which one is that?  can you paste a link to the description?
10:41:04 <mohbana> http://hackage.haskell.org/trac/summer-of-code/ticket/16
10:41:07 <lambdabot> Title: #16 (GTK / GNOME related projects) - Haskell.org Google Summer of Code - Trac
10:42:31 <mohbana> is there a single project that has been accepted?
10:42:50 <byorgey> mohbana: it seems to me that it wouldn't be too hard to get something basic working, but you could put a lot more effort into making it really nice
10:43:07 <byorgey> mohbana: so in some ways that makes it an idea sort of project
10:43:27 <byorgey> mohbana: it looks like wfarr has also indicated interest in that project
10:43:46 <byorgey> mohbana: the application period for students doesn't close until the 31st, IIRC
10:44:29 <byorgey> er, I meant  "ideal sort of project" =)
10:45:09 <mohbana> do you guys use hugs, because we used that's what we used at un
10:45:50 <mohbana> are there any good podcasts for haskell
10:45:53 <byorgey> mohbana: in general ghc/ghci is much more popular than hugs.
10:46:32 <Twey> Why?
10:46:39 <Twey> hugs has a friendlier name.  :<
10:46:53 <Heffalump> ghci is faster and more powerful
10:47:01 <Heffalump> though it loads more slowly
10:47:20 <dons> it also has better error messages
10:47:24 <DuClare> Anybody?  What would be a smart way to fix the problem with hidden packages after upgrading ghc?
10:47:27 <dons> and supports many more libraries
10:48:29 <byorgey> DuClare: sounds like you've run into a package that hasn't been updated for the base package split that happened with ghc 6.8.
10:48:31 <mohbana> what has better error message hugs?
10:48:44 <dcoutts_> DuClare: either upgrade the lib in question to a version that supports ghc-6.8, or fix the package yourself
10:48:46 <byorgey> DuClare: you can either just update the .cabal file
10:48:52 <dcoutts_> @where cabal-faq
10:48:52 <lambdabot> http://haskell.org/haskellwiki/Cabal/FAQ
10:49:00 <rnorris> how do you force an IO operation to be strict? say i want to call getContents and close the file, but not use the results immediately
10:49:09 <dcoutts_> DuClare: that FAQ page describes how ^^
10:49:19 <dons> use System.IO.Strict :)
10:49:31 <dcoutts_> or use evaluate (length content)
10:49:38 <dcoutts_> content <- readFile "foo"
10:49:40 <dcoutts_> evaluate (length content)
10:49:48 <rnorris> great, thanks guys
10:49:56 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/strict
10:50:09 <dons> provides System.IO.Strict
10:50:41 <elaforge> nice, I often had to write my own string readFile
10:50:50 <elaforge> string->strict
10:51:06 <K0MPR3SS0R> Hellow
10:51:08 <dons> yeah, no need. just use the library
10:51:23 <dons> i usually use bytestring for this though, i must admit
10:51:26 <byorgey> hey K0MPR3SS0R
10:51:34 <dons> often when strictness matters, so does performance, so using bytestring makes more sense
10:52:13 <K0MPR3SS0R> i need a little help
10:52:20 <K0MPR3SS0R> ive posted my code
10:52:29 <elaforge> ya true
10:52:33 <K0MPR3SS0R> http://hpaste.org/6594
10:52:55 <K0MPR3SS0R> im trying to compare two binary trees to see if they are equal
10:53:04 <K0MPR3SS0R> doing that with the equ function
10:53:30 <K0MPR3SS0R> is it the proper way im doing it in my function?
10:53:51 <dcoutts_> K0MPR3SS0R: what's wrong with the derived Eq in this case?
10:54:11 <K0MPR3SS0R> well its part of an assignment, basically we have to make our own eq function
10:54:11 <dcoutts_> you've got some kind of equivalence class on your trees?
10:54:33 <K0MPR3SS0R> well I think we have to implement it ourselves
10:54:40 <dcoutts_> so you're basically writing the derived (==) for this type
10:54:46 <K0MPR3SS0R> yes
10:54:46 <dcoutts_> do it completely structurally
10:55:05 <K0MPR3SS0R> in what sense?
10:55:20 <dcoutts_> you've got the first case
10:55:33 <dcoutts_> equ Nil Nil = False, oh except it should be True, right?
10:55:45 <K0MPR3SS0R> yeah thats true technically
10:55:48 <mohbana> are there any good podcasts for haskell
10:55:50 <K0MPR3SS0R> if they are both empty
10:55:58 <mohbana> how about some blog sites
10:56:04 <K0MPR3SS0R> but its the full condition I have trouble with
10:56:17 <elliottt> mohbana: http://planet.haskell.org has a good collection
10:56:17 <lambdabot> Title: Planet Haskell
10:56:28 <elliottt> no podcasts, but good articles
10:56:32 <dcoutts_> K0MPR3SS0R: so how to compare (Node a ta1 ta2) (Node b tb1 tb2)
10:56:35 <K0MPR3SS0R> to call the collapse function, make it recursivelly go through each char and compare with the recursive flow of the other tree when they are being traversed
10:56:47 <dcoutts_> K0MPR3SS0R: why do you want to collapse?
10:57:03 <K0MPR3SS0R> well just a way of reading each character
10:57:27 <dcoutts_> K0MPR3SS0R: so in the above example, a had better equal b right?
10:57:43 <K0MPR3SS0R> yeah
10:57:54 <K0MPR3SS0R> thats it
10:57:58 <dcoutts_> and what about ta1, tb1 and ta2, tb2 ?
10:58:28 <K0MPR3SS0R> no, each level and each tree should be identical
10:58:34 <K0MPR3SS0R> should be the exact same structure
10:58:42 <dcoutts_> right
10:58:49 <K0MPR3SS0R> so if I have a tree alpha, it should be eual to the second tree alpha
10:59:08 <Jedai> dcoutts_: I'm not sure, I mean if a tree is (Node 'b' (Node 'a' Nil Nil) Nil) and another (Node 'a' Nil (Node 'b' Nil Nil)) aren't they equal ?
10:59:10 <K0MPR3SS0R> so thats where im confused
10:59:31 <dcoutts_> Jedai: that's not the impression I got from K0MPR3SS0R
10:59:47 <dcoutts_> K0MPR3SS0R: so what about Jedai's example, are those equal or not?
11:00:07 <dcoutts_> ie different structured trees but the in-order traversal gives the same list of chars
11:00:07 <K0MPR3SS0R> no
11:00:23 <K0MPR3SS0R> first of all the roots are different
11:00:24 <Jedai> dcoutts_: Yeah but KOMPR3SS0R seems confused, so... (Anyway if we do it your way, equ == (==))
11:00:34 <K0MPR3SS0R> second the left and right subtree are different
11:00:41 <dcoutts_> Jedai: yep, exactly it's the derived (==)
11:00:43 <mohbana> is perl6 going to be similiar to haskell? like in terms of syntax?
11:00:51 <dcoutts_> mohbana: nope
11:00:52 <EvilTerran> not really, no
11:01:12 <Jedai> mohbana: No, more like Perl but with annotation and more operators
11:01:20 <mohbana> but its going to be functional?
11:01:22 <EvilTerran> it'll steal some ideas, but re-express them with more curly brackets and less significant whitespace
11:01:25 <Jedai> mohbana: And some other things...
11:01:30 <K0MPR3SS0R> alright so now if I use my code that I posted will it run equality like I want it? or is there something seriously wrong
11:01:36 <dcoutts_> K0MPR3SS0R: so ta1 is going to have to be the same as tb1 and ta2 is going to have to be the same as tb2, right?
11:01:36 <elaforge> I think you can download it right now and try it out
11:01:57 <EvilTerran> it's going to be like that swiss army knife thats got a hundred tools on it
11:01:57 <K0MPR3SS0R> yes dcoutts
11:02:10 <Jedai> mohbana: You can already do functionnal with Perl, Perl6 will make it easier, but the language won't be functional in the sense that Haskell is functional
11:02:12 <dcoutts_> K0MPR3SS0R: so how would you express that fact directly?
11:02:17 <EvilTerran> huge, impressive, but wholly impractical
11:02:22 <EvilTerran> :P
11:02:56 <K0MPR3SS0R> (node x ta1 ta2) == (node n tb1 tb2)??
11:03:28 <K0MPR3SS0R> and when both tree traverse one level
11:03:29 <Jedai> K0MPR3SS0R: Isn't the point to write this (==) yourself ?
11:03:29 <dcoutts_> K0MPR3SS0R: something like that, except that you're trying to define the == function
11:03:32 <K0MPR3SS0R> it should be the same right?
11:03:53 <Jedai> K0MPR3SS0R: From what you say yes, but how do (==) do it ?
11:03:54 <K0MPR3SS0R> sorry I mean equ (node x ta1 ta2) (node n tb1 tb2)
11:04:09 <dcoutts_> equ (Node a ta1 ta2) (node b tb1 tb2) = ???
11:04:12 <dcoutts_> oops
11:04:12 <Taejo> anybody here willing to test-compile my HMM package on GHC 6.8?
11:04:17 <dcoutts_> equ (Node a ta1 ta2) (Node b tb1 tb2) = ???
11:04:31 <dcoutts_> K0MPR3SS0R: Node not node, they're constructors
11:05:03 <Jedai> Taejo: If you want I can try on 6.8.2 on Linux
11:05:07 <K0MPR3SS0R> uhmm...
11:05:13 <K0MPR3SS0R> yes I see
11:05:23 <K0MPR3SS0R> but still confused
11:05:26 <dcoutts_> K0MPR3SS0R: so you said what it needs to be, you just need to check that various of those bits are equal, so the question is what functions to use for checking equality
11:05:28 <benny99> Philippa: http://www.nomaware.com/monads/html/ -- hm :(
11:05:45 <benny99> Philippa: (it's down) -- did 'nomaware' quit ?
11:05:53 <K0MPR3SS0R> I dont know where it is im going to check equality
11:06:07 <dcoutts_> K0MPR3SS0R: you can use == to check Chars right? and what function do you have to check equality of Tree Char ?
11:06:12 <K0MPR3SS0R> yes
11:06:18 <Taejo> Jedai: thanks... http://people.cs.uct.ac.za/~rbkmax001/hmm-0.1.tar.gz ... plain old cabal configure and build
11:06:20 <K0MPR3SS0R> individual chars yes  I think I can use that
11:07:07 <dcoutts_> K0MPR3SS0R: so what about checking equality of Tree Char, since that's what ta1, ta2, tb1, tb2 are right?
11:07:12 <K0MPR3SS0R> so what would be the syntax for that, once my equ function is called, it should traverse by calling collapse function, where a char is read from each tree, and then compared
11:07:28 <dcoutts_> K0MPR3SS0R: what has this got to do with collapse?
11:07:40 <K0MPR3SS0R> well I do have to traverse right?
11:08:02 <Jedai> Taejo: You have an ambiguous reference to "forever" (there's a forever in Control.Monad too)
11:08:09 <K0MPR3SS0R> each tree has to be traversed using something, I just use collapse for reusability in my other program
11:08:35 <dcoutts_> K0MPR3SS0R: it will be a traversal, yes.
11:08:49 <K0MPR3SS0R> and it has to be inorder
11:09:00 <dcoutts_> that does not mean you have to write it by first doing an inorder traversal
11:09:07 <Jedai> Just adding "hiding (forever)" to the import should be enough
11:09:10 <K0MPR3SS0R> so now that I traverse, it should go back to the function equ and check for equality of the other one I think
11:09:24 <Jedai> Taejo: It builds correctly now
11:09:58 <dcoutts_> K0MPR3SS0R: you can write equ in three lines (not including the type sig) and without collapse
11:10:07 <DuClare> dcoutts_, Well that's why I asked about smartness.
11:10:14 <dcoutts_> K0MPR3SS0R: and it'll be much simpler without collapse
11:10:21 <DuClare> dcoutts_, I think I'm going to have to do every haskell package by hand ..
11:10:34 <dcoutts_> DuClare: people have already done that, ghc-6.8 has been out for ages
11:10:37 <Taejo> Jedai: ah yes, I can actually remove that definition of forever
11:10:55 <DuClare> dcoutts_, What is the purpose of a package manager if it won't be used?
11:10:56 <DuClare> :\
11:11:01 <dcoutts_> DuClare: there are now very few packages that have not been updated for ghc 6.8
11:11:03 <dcoutts_> DuClare: huh?
11:11:08 <Jedai> Oh, I didn't check if it was the same...
11:11:53 <DuClare> dcoutts_, Well if I'm going to do things by hand, this means I won't be doing them with the help of my package manager.
11:12:05 <Jedai> Taejo: It is the same, you can effectively get rid of it
11:12:41 <Taejo> Jedai: it's unused anyway
11:12:45 <dcoutts_> DuClare: sounds like you must have upgraded ghc without your package manager too then, if your distro has ghc-6.8 packages then it'll probably have the other haskell packages that are compatible with it
11:13:10 <DuClare> dcoutts_, Na' I upgraded ghc via my package manager.
11:13:18 <Jedai> Taejo: Then you can really get rid of it !! ;-)
11:13:37 <dcoutts_> DuClare: then make sure you've also got the latest versions of the various libs
11:14:13 <K0MPR3SS0R> sorry guys I had ups at my door asking for money
11:14:48 <K0MPR3SS0R> dcoutts can you tell me how I can write equ without the use of collapse?
11:15:26 <DuClare> dcoutts_, The newest available regex-base is 0.91, and is hardmasked because it's claimed to be an experimental release, and "not the best available"
11:15:34 <dcoutts_> K0MPR3SS0R: so we already established that the second line was:
11:15:35 <dcoutts_> equ (Node a ta1 ta2) (Node b tb1 tb2) = ???
11:15:36 <K0MPR3SS0R> ohh I think I know what youre getting at dcoutts
11:16:03 <K0MPR3SS0R> ok leme try soemthing and ill show you and you tell my if im not a complete failure
11:16:05 <dons> DuClare: fwiw, regex-base is up to 0.93.1 on hackage
11:16:09 <K0MPR3SS0R> ;)
11:16:14 <dcoutts_> DuClare: right, you don't want that version, use the latest 0.7x version, it'll be 0.71.0.1 or something like that
11:16:49 <DuClare> dcoutts_, There's at least 0.72
11:17:03 <dons> Igloo: any idea why the popcon stats haven't updated in a week or so?
11:17:07 <DuClare> dcoutts_, But it fails
11:17:17 <dcoutts_> DuClare: it'll be a 0.7x.0.x version number not 0.72
11:17:36 <DuClare>      Available versions:  ~0.71 0.72 ~0.72.0.1 [M]~0.91 {doc profile}
11:17:46 <dcoutts_> there you go
11:17:48 <DuClare> So .72.0.1 would work?
11:17:51 <dcoutts_> yep
11:17:57 <DuClare> Confusing I must say. :o
11:18:45 <dcoutts_> DuClare: you unmasked ghc but not the corresponding libs
11:19:03 <DuClare> dcoutts_, How would I have known what libs run with ghc?
11:19:19 <DuClare> And what versions of each lib. :)
11:19:30 <dcoutts_> DuClare: in all cases it's the latest ~arch version that is not hard masked
11:19:52 <dcoutts_> ~arch ghc goes with ~arch libs, stable ghc goes with stable libs
11:20:12 <dcoutts_> using other mixtures is not supported
11:20:23 <DuClare> Okay, that might help a bit.
11:20:23 <dcoutts_> not by gentoo at least
11:21:00 <Igloo> dons: There were a few days when no data appeared. It should catch up next update
11:26:20 <K0MPR3SS0R> ok dcoutts
11:26:23 <K0MPR3SS0R> 6599
11:26:33 <K0MPR3SS0R> http://hpaste.org/6599
11:26:45 <K0MPR3SS0R> is it better? or am I still a complete failure
11:27:09 <dcoutts_> much closer
11:27:14 <K0MPR3SS0R> heh
11:27:25 <dcoutts_> @hoogle Bool -> Bool -> Bool
11:27:26 <lambdabot> Prelude.(&&) :: Bool -> Bool -> Bool
11:27:26 <lambdabot> Prelude.(||) :: Bool -> Bool -> Bool
11:27:26 <lambdabot> Data.Bool.(&&) :: Bool -> Bool -> Bool
11:28:00 <K0MPR3SS0R> why two bools?
11:28:20 <dcoutts_> it's nearly correct (it doesn't type check yet) and it can be simpler still
11:28:30 <dcoutts_> > True && False
11:28:33 <lambdabot>  False
11:29:07 <mofmog> so what kinds of math should i know before attempting to learn category theory?
11:29:11 <K0MPR3SS0R> right so if theres a false soemwhere and most of the rest of it is true, then it will still be false
11:29:27 <dcoutts_> mofmog: set theory
11:29:28 <mofmog> i hear it's an obscure branch so there aren't any courses on it at my uni so i guess ill try to take the courses that lead up to it...
11:29:39 <dcoutts_> mofmog: logic
11:29:55 <mofmog> would discrete mathematics suffice?
11:29:55 <dcoutts_> if possible, lambda calculus and/or domain theory
11:30:23 <dcoutts_> mofmog: you might want to read a bit about lambda calculus and simple types too
11:30:38 <sethk> mofmog, discrete mathematics is not really close, although it's also valuable to know
11:31:31 <dcoutts_> depends what parts of discrete maths, eg logic and set theory would be fine
11:32:05 <dozer> ok - if I am using mapM ... mapM to generate a 2d list so that the state is threaded in the obvious way, and then call transpose on that, so that the transposed view 'cuts across' the state, could that trigger my stack overflow?
11:32:17 <skorpan> is it possible to export everything in a module AND exporting an imported module, without writing every single item in the export list?
11:32:49 <K0MPR3SS0R> ok I see a problem dcoutts in my thing, if it does find that the roots or subroots match, it doesnt return if its true or not , it just keeps going
11:33:04 <K0MPR3SS0R> until it reaches the end, where they will be both nil and be true
11:33:20 <K0MPR3SS0R> and whats the thing you mentioned, it doesnt type check?
11:33:29 <dcoutts_> skorpan: yes I think so, if you recursively import the module and then export it
11:33:35 <K0MPR3SS0R> I thought Tree Char took care of that
11:33:45 <skorpan> dcoutts_: uh, what?
11:33:56 <dcoutts_> K0MPR3SS0R: (equ t1 p1)(equ t2 p2) does not type check
11:34:15 <DuClare> dcoutts_, Yay, issue resolved.  I appreciate your help. :)
11:34:27 <dcoutts_> skorpan: you can import the module you're defining in that module
11:34:36 <lispy> when I use latex in a .lhs file, am I expected to run pdflatex on the .lhs directly?
11:34:41 <skorpan> dcoutts_: and ghc wouldn't complain?
11:34:51 <Heffalump> lispy: I believe so.
11:34:54 <K0MPR3SS0R> its true, so I have to do (equ t1 char p1 char)(equ t2 char p2 char)?
11:34:57 <dcoutts_> skorpan: module Foo ( module Foo, module Bar ) where; import Foo; import Bar
11:35:04 <pejo> mofmog, if you have taken a course in abstract algebra it might be less intimidating with category theory.
11:35:14 <lispy> Heffalump: ah, you're a good person to help me :)  Do you know how to build just the darcs manual as a pdf?
11:35:26 <skorpan> waddya know dcoutts_ it works
11:35:33 <lispy> Heffalump: my attempts to unravel the mysteries of the makefile have not yeilded much :)
11:35:47 <dcoutts_> K0MPR3SS0R: what do you mean by (equ blah blah)(equ blah blah) ? how are you combinging the values that equ is returning?
11:36:15 <Heffalump> lispy: nope, no idea.
11:36:21 <lispy> Heffalump: okay, thanks
11:36:21 <kowey> lispy: doesn't make doc/manual/darcs.pdf work?
11:36:22 <Heffalump> sorry!
11:36:29 <K0MPR3SS0R> each set will have its own recursion on each leaf node?
11:36:53 <lispy> kowey: no, I get an error from bash I don't quite understand
11:37:18 <dcoutts_> K0MPR3SS0R: what (equ blah blah)(equ blah blah) means is to apply the first as if it were a function to the second, you definately do not mean that, because both those values are Bool
11:37:33 <dcoutts_> K0MPR3SS0R: it's like saying:
11:37:37 <dcoutts_> > True False
11:37:37 <lambdabot>  Couldn't match expected type `Bool -> t'
11:37:51 <dcoutts_> > True && False
11:37:51 <lambdabot>  False
11:37:55 <dcoutts_> does make sense though
11:38:10 <dcoutts_> so think about how you're combining the values
11:38:26 <ertai> how valuable such a function would be http://hpaste.org/6600#a0 ?
11:38:27 <K0MPR3SS0R> ok...
11:38:40 <monochrom> Sounds like Lisp. :)
11:38:54 <bos> ertai: not very
11:39:57 <ertai> bos: you would use head directly or breaking the line to insert a case?
11:40:40 <bos> i would write a safe variant, and use that.
11:41:44 <pejo> bos, is the comment system you guys use for real world haskell available somewhere?
11:41:52 <bos> not yet.
11:42:50 <ertai> bos: what you mean by safe? not using error?
11:43:04 <bos> ertai: right
11:43:42 <K0MPR3SS0R> ok dcoutts
11:43:46 <K0MPR3SS0R> http://hpaste.org/6601
11:43:52 <ertai> bos: but in some cases I properly know that this case should not happen, so I want an error.
11:43:54 <K0MPR3SS0R> I think this might make more sense
11:43:56 <mofmog> is there a list-ref type function in haskell?
11:44:14 <mofmog> let a = [1,2,3]; list-ref 0 a => 1
11:44:32 <mofmog> list-ref 100 a => False
11:45:06 <dcoutts_> K0MPR3SS0R: btw, you can annotate existing pastes rather than creating new ones
11:45:09 <dons> > [1,2,3] !! 0
11:45:10 <lambdabot>  1
11:45:13 <bos> ertai: fair enough.
11:45:43 <lament> mofmog: first of all, 1 and False are different types.
11:45:54 <mofmog> well
11:45:54 <dcoutts_> K0MPR3SS0R: you've not fixed the (equ t1 p1)(equ t2 p2) thing, it does not type check
11:45:56 <mofmog> it could retrun a maybe
11:46:03 <mofmog> > [1,2,3] !! 100
11:46:03 <bos> ertai: it's just worth noting that code like that is very fragile. you'll forget your precondition some time, and a bug will result.
11:46:03 <lambdabot>  Exception: Prelude.(!!): index too large
11:46:21 <skorpan> is there any tool which checks so that modules don't import anything that they never use?
11:46:25 <K0MPR3SS0R> Ok the type checking ill leave for later
11:46:28 <mofmog> wait, actually, i should use a zipper
11:46:46 <K0MPR3SS0R> but right now will it check each char properly granted that there are no type differences
11:47:22 <lament> listRef l i = if (i >= 0 && i < length l) then Just (l !! i) else Nothing
11:48:41 <Heffalump> skorpan: -fwarn-unused-imports
11:49:28 <Jedai> K0MPR3SS0R: If you program does not typecheck, it means there's a profond error, in this case, you don't really seems to get what your function should be doing.
11:49:45 <Jedai> K0MPR3SS0R: What you wrote makes no sense
11:49:50 <K0MPR3SS0R> really?
11:50:26 <Jedai> K0MPR3SS0R: If it does not typecheck it does not make sense (usually).
11:50:38 <K0MPR3SS0R> ok so how to add type checking on that one?
11:51:58 <Heffalump> @seen augustss
11:51:58 <lambdabot> I saw augustss leaving #haskell 4h 40m 29s ago, and .
11:52:13 <dcoutts_> K0MPR3SS0R: see what I said about about (equ blah)(equ blah), about how you need to decide what you mean
11:52:15 <monochrom> Suppose this is the first time you learn English and you finally manage to utter "I you rock".  This is a type error.  Moreover, it is quite impossible to tell you how to fix it, since other people have just as much problem trying to guess what you mean.  I rock you?  You rock me?  I think you rock?  ...
11:52:20 <Jedai> K0MPR3SS0R: You don't "add" type checking on anything in Haskell, it's a statically typed language and it checks the types of your expressions and (equ ...) (equ ...) makes no sense and so don't typecheck
11:52:39 <dozer> KOMPR3SSOR: failure to typecheck is usually an indicatio that a) you are trying to do something mad or b) you are trying to do something in a non-haskell way - there are, of course, exceptions
11:52:53 <skorpan> Heffalump: i did -Wall :)
11:53:08 <Jedai> dozer: And in this case it's (a)
11:53:30 <Peaker> was there any work done for integrating assertions capable of expressing things like the monadic laws into the type system such that Monad classes would, for example, be forced to prove that these assertions are true on their types?
11:53:48 <K0MPR3SS0R> so its the t1 p2 types that arent type checked?
11:53:58 <K0MPR3SS0R> so I have to put t1 char p2 char?
11:54:06 <K0MPR3SS0R> to say that its of type char?
11:54:30 <dcoutts_> no, that's fine
11:54:48 <Peaker> its not nice that you cannot express the monadic laws in the "Monad" class specification
11:54:54 <dcoutts_> K0MPR3SS0R: look at the type of equ, it returns Bool right?
11:54:59 <Jedai> K0MPR3SS0R: You don't get it, when we (equ ...) (equ ...) don't type check, it means that based on the type for equ, this expression makes no sense and the compiler complain
11:55:01 <K0MPR3SS0R> right
11:55:16 <dcoutts_> K0MPR3SS0R: so when you have an expression like (equ ...)(equ ...) it's like saying True False
11:55:25 <dcoutts_> > True False
11:55:25 <lambdabot>  Couldn't match expected type `Bool -> t'
11:55:27 <EvilTerran> Peaker, that would require dependent typing or similar
11:55:33 <Jedai> K0MPR3SS0R: And if it makes no sense to the compiler it's because it makes no sense at all.
11:55:36 <Peaker> EvilTerran, what is dependent typing?
11:55:43 <EvilTerran> types parameterised by values
11:55:56 <EvilTerran> so "IntMod 64" could be a type
11:55:58 <dcoutts_> K0MPR3SS0R: it doesn't make sense to say True False, because what that would mean is apply the function True to the value False, but True is not a function.
11:56:25 <EvilTerran> you could use it (or something like it) to express the monad laws as static checks
11:56:26 <Jedai> K0MPR3SS0R: (equ ...) is a boolean, not a function, you can't apply it to the second (equ ...)
11:56:26 <K0MPR3SS0R> arrghhh...this is so frustrating
11:56:29 <dozer> Peaker: lift (some fragment of) object-language values and expressions into the type-system
11:56:34 <monochrom> "Debug your mind, not your code."
11:56:48 <K0MPR3SS0R> i understand that equ is returning a bool, but I have trouble with the way functions are structured
11:57:04 <K0MPR3SS0R> like how to I make them work if I dont know what goes where
11:57:06 <dozer> KOMPR3SSOR: what are you wanting/expecting it to do?
11:57:08 <monochrom> I think you need more tutorials.  I recommend reading 5.
11:57:14 <dcoutts_> K0MPR3SS0R: your code (equ ...)(equ ...) has the same problem. So you've got two boolean values right? from calling equ. You know the result of the function overall has to be Bool right? So do you want to combine those results to give the overall result?
11:57:28 <K0MPR3SS0R> yeah I know dcoutts what you mean
11:57:33 <K0MPR3SS0R> but I dont know how to fix it
11:57:38 <dcoutts_> there are several options
11:57:50 <K0MPR3SS0R> dozer im just trying to compare two trees to see if they are equal
11:57:56 <dcoutts_> eg you might want the result to be True when both calls are True
11:58:03 <EvilTerran> why not use the derived Eq instance?
11:58:10 <dcoutts_> EvilTerran: that's the exercise
11:58:12 <K0MPR3SS0R> sure
11:58:16 <Jedai> K0MPR3SS0R: First, start by trying to explain in human language how you know that two tree are equal
11:58:22 <EvilTerran> ah. that's the game.
11:58:25 <K0MPR3SS0R> it would make sense that iff both calls are true to return true
11:58:39 <dcoutts_> K0MPR3SS0R: ok, so suppose you want to make the result True when both calls return True and False otherwise, how might you do that?
11:58:53 <EvilTerran> K0MPR3SS0R, so you want a function of two parameters (ie an operator) that returns true if both parameters are true, to combine the results of the two calls
11:58:55 <dozer> ok, what Haskell operator of type Bool -> Bool -> Bool returns true iff both args are true?
11:59:14 <Jedai> @hoogle Bool -> Bool -> Bool
11:59:14 <lambdabot> Prelude.(&&) :: Bool -> Bool -> Bool
11:59:14 <lambdabot> Prelude.(||) :: Bool -> Bool -> Bool
11:59:14 <lambdabot> Data.Bool.(&&) :: Bool -> Bool -> Bool
11:59:23 <K0MPR3SS0R> yes evilterran
11:59:36 <K0MPR3SS0R> ok dcoutts ill think about that
11:59:47 <Jedai> So && (AND), || (OR) are operators with the right type
11:59:47 <skorpan> what is the difference between Prelude.(&&) and Data.(&&)?
11:59:53 <skorpan> Data.Bool.(&&)*
12:00:05 <EvilTerran> the module they're in ;)
12:00:08 <monochrom> Same difference.
12:00:14 <Jedai> @src Data.Bool.(&&)
12:00:14 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
12:00:15 <dcoutts_> skorpan: they're the same, prelude just re-exports
12:00:28 <pjd> skorpan: same as, say, Prelude.foo versuse Data.List.foo
12:00:31 <dozer> haskell does seem to have a lot of these multiply-defined or multiply-exposed symbols :(
12:00:36 <roconnor> skorpan: GHC inplements the Prelude by re-exporting bits and pieces from various differnt modules.
12:00:49 <monochrom> OCaml does that too.
12:00:52 <Twey> @src (&&)
12:00:52 <lambdabot> True  && x = x
12:00:52 <lambdabot> False && _ = False
12:01:09 <Twey> @src nub
12:01:09 <lambdabot> nub = nubBy (==)
12:01:12 <pjd> the Prelude generally contains a subset of what you'll find in the more specific modules
12:01:13 <Twey> @src nubBy
12:01:13 <lambdabot> nubBy eq []             =  []
12:01:13 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
12:01:15 <Jedai> K0MPR3SS0R: Do you understand "boolean logic" ?
12:01:44 <K0MPR3SS0R> yes
12:01:48 <Twey> Hmm
12:02:13 <Jedai> K0MPR3SS0R: Then you know which operator to use, right ?
12:02:21 <K0MPR3SS0R> yes &&
12:03:02 <dozer> ok, so there are only 3 ways of arranging && with your existing line of code, and only one of them type-checks
12:03:10 <dozer> try brute-force :)
12:03:16 <K0MPR3SS0R> lol
12:03:28 <Twey> Hahaha
12:03:32 <Twey> Brute-force programming
12:03:36 <Twey> Don't
12:03:39 <Twey> It might catch on
12:03:50 <dozer> Twey: if it's good enough for the intelligent designer, it's good enough for us
12:04:02 <Twey> :-D
12:04:10 <pjd> Twey: superoptimization!
12:04:33 <K0MPR3SS0R> 	|True && x == n = True && (equ t1 p1)==(equ t2 p2)
12:04:37 <K0MPR3SS0R> does that work?
12:04:49 <Twey> Ych
12:05:02 <monochrom> This is a disaster.
12:05:13 <K0MPR3SS0R> ok...
12:05:34 <Twey> K0MPR3SS0R: Is that = meant to be there?
12:05:57 <dozer> let's try again - you have (equ t1 p1), (equ t2 p2) and &&. Arrange these (and only these) into a legal haskell expression
12:06:32 <K0MPR3SS0R> thats the problem, I have a huge difficulty with haskell syntax and making expressions, seems so counter intuitive to me
12:06:33 <dozer> you are not alowed any other ascii other than whitespace - no equals signs, no True constants and so on
12:07:30 <K0MPR3SS0R> 	|True && x == n && (equ t1 p1)==(equ t2 p2)
12:07:44 <dcoutts_> K0MPR3SS0R: do what dozer said
12:07:52 <K0MPR3SS0R> brute force?
12:07:55 <K0MPR3SS0R> lol
12:08:20 <dcoutts_> K0MPR3SS0R: he said "you have (equ t1 p1), (equ t2 p2) and &&. Arrange these (and only these) into a legal haskell expression. you are not alowed any other ascii other than whitespace - no equals signs, no True constants and so on"
12:08:32 <dcoutts_> do that, it's good advice
12:08:41 <K0MPR3SS0R> okie ;)
12:08:47 <Jedai> K0MPR3SS0R: Don't blame Haskell syntax here... On that point it's exactly the same as the syntax of 99% of the programming languages
12:09:02 <dozer> Jedai: well, not lisp :)
12:09:12 <Twey> Can be if you want it to be.
12:09:21 <byorgey> dozer: well, that's the 1% =)
12:09:39 <Jedai> dozer: The 1% is there for Lisp and Scheme (maybe Forth, Smalltalk and some other too...)
12:09:44 <dozer> I have an irrational hatered of lisp code - not helped by most of my experience with it being emacs macros
12:10:44 <Twey> Jedai: COBOL
12:10:55 <Twey> :-D
12:11:39 <Jedai> Twey: How does it look in COBOL ?
12:12:00 <monochrom> MULTIPLY X BY Y INTO Z  iirc
12:13:43 <Twey> IF (EQU T1 P1) AND (EQU T2 P2) THEN
12:13:51 <Twey> ... END-IF
12:13:54 <K0MPR3SS0R> alright lol, if I fail at this I give up
12:13:55 <K0MPR3SS0R> |(equ t1 p1)&&(equ t2 p2)
12:14:02 <Twey> Yaaaaaaay!
12:14:11 <dozer> give that guy an easter egg
12:14:34 <K0MPR3SS0R> dont I need to check for false? or is it implied by this
12:14:51 <dozer> && returns false if either args are false, true if both are true
12:14:54 <K0MPR3SS0R> yeah
12:15:05 <dozer> no need to check if a boolean is true or not - it is already a boolean
12:15:26 <K0MPR3SS0R> so my final function will look like this
12:15:26 <K0MPR3SS0R> equ :: Tree Char -> Tree Char -> Bool
12:15:26 <K0MPR3SS0R> equ Nil Nil = True
12:15:26 <K0MPR3SS0R> equ (Node x t1 t2) (Node n p1 p2)
12:15:26 <K0MPR3SS0R> 	|(equ t1 p1)&&(equ t2 p2)
12:15:35 <K0MPR3SS0R> oops sorry should posted on hpaste
12:16:11 <EvilTerran> very close. change one character.
12:16:15 <Twey> if (someBool /= (not $ not $ not (false == true)))
12:16:28 <dozer> nearly - now you need to deal with the x and n values
12:16:38 <EvilTerran> you haven't provided a body for the "equ (Node x t1 t2) (Node n p1 p2)" line. it needs to = something, even if there's a guard.
12:17:23 <dozer> I don't think you wanted the | there, probably just a =
12:17:31 <K0MPR3SS0R> yeah
12:17:42 <K0MPR3SS0R> i forgot cause before i had more conditions
12:17:48 <K0MPR3SS0R> but it shouldnt complain if its there right?
12:18:29 <dozer> the guard means something - it means 'only run this function if the guard succeeds' and expects the guard condition to be followed by = funcBody
12:18:58 <K0MPR3SS0R> so I use a guard and thats where ill check n and x?
12:19:10 <mauke> why use a guard?
12:19:37 <K0MPR3SS0R> then where will I check for n and x?
12:19:51 <dozer> you could do it that way, but then you don't have a function that handles the case where n is not equal to x
12:20:07 <mauke> in the function body
12:21:20 <dcoutts_> K0MPR3SS0R: remember that == also returns Bool, so you can use it with other && expressions
12:21:44 <K0MPR3SS0R> equ (Node x t1 t2) (Node n p1 p2) = x == n && (equ t1 p1)&&(equ t2 p2)
12:21:55 <K0MPR3SS0R> yay?
12:22:01 <mauke> aye
12:22:14 <EvilTerran> you can drop those brackets around (equ ...), btw.
12:22:16 <K0MPR3SS0R> i guess thats bad
12:22:25 <K0MPR3SS0R> uhmmk
12:23:01 <EvilTerran> function application always always ALWAYS binds tighter than any infix operator
12:23:10 <K0MPR3SS0R> I thought the brakets would ensure that equ doesnt eat up the wrong things
12:23:15 <K0MPR3SS0R> ok
12:23:18 <K0MPR3SS0R> got it
12:23:27 <dozer> alternatively, put brackets about the (x==n)
12:23:30 <dozer> be consistent, either way
12:23:31 <K0MPR3SS0R> but it makes it more readable maybe?
12:23:35 <K0MPR3SS0R> ok
12:23:39 <EvilTerran> f x ?? g y = (f x) ?? (g y), regardless of what f, x, g, and y are
12:23:42 <K0MPR3SS0R> but right now its should be good
12:23:43 <EvilTerran> and ??
12:24:04 <K0MPR3SS0R> ok
12:24:07 <K0MPR3SS0R> good to know
12:24:11 <dozer> KOMPR3SSOR: try that function out on some trees and see if it works or if it breaks
12:24:20 <K0MPR3SS0R> i shall do that right now
12:24:24 <K0MPR3SS0R> god bless you guys
12:24:37 <K0MPR3SS0R> im struggling in this course
12:25:23 <dozer> programming is a skill, not an exercise
12:25:28 <dozer> you only learn by doing
12:26:15 <K0MPR3SS0R> are you guys teachers in this channel?
12:29:24 <K0MPR3SS0R> alright tested it
12:29:26 <K0MPR3SS0R> works great
12:29:30 <K0MPR3SS0R> cant thank you guys enough
12:30:34 <Peaker> dozer, EvilTerran: Well, lifting requirements that live in the value-world into the type system is one way to look at it - perhaps simple "assertion guards" (Like guards, but must be proven true) can do that?
12:36:35 <Twey> K0MPR3SS0R: You have a course that uses Haskell?
12:37:58 <dozer> Peaker: that kind of assertion/proof/unittest framework would require some kind of proof-carying-code framework to make it fly
12:39:06 <dozer> Peaker: sounds like an awesom project though - you remove things you can prove are satisfied, you raise an error if you can prove it is violated and you carry it about otherwise - possibly run-time checking, or combining it with info later when the symbol is used to remove/fail/carry
12:39:10 <Peaker> dozer, I thought about using normal Haskell code - intermediate assertions - as a means to specify a proof. Let the compiler figure out how the intermediate assertions connect. If it can't - add more intermediate assertions
12:39:32 <Peaker> dozer, Yeah - I thought about having "green" ones (compile-time-verified) and "red ones" (checked in runtime) too
12:40:02 <Peaker> dozer, the intermediate assertions can make the inner ones green and themselves be green (or require further intermediate ones)
12:40:32 <dozer> Peaker: the problem is, that in general the proof that your code is correct is as much work as running your code in all possible situations - only some special cases can be proved cleanly, and type-systems sit squarely within this range of possibilities for obvious reasons
12:40:47 <Peaker> dozer, I think this will be a much better user experience with a specialized Haskell editor than a text-editor->compile->parse-errors->text-editor loop
12:41:18 <Peaker> dozer, I disagree - there are many useful cases not covered by the type system that can be cleanly proven correct.  A sorting algorithm, for example
12:41:42 <dozer> Peaker: but you can't prove sort without defining ordering for example
12:41:56 <dozer> so that would mean explaining ordering to your type system rather than to your program
12:42:15 <Peaker> dozer, You prove that sort returns something that both contains all the input elements and has correct Ord.(>) ordering, and perhaps you prove its stability too
12:42:55 <dozer> right, exactly - so somehow you have to communicate (Ord) to the type system rather than it being just a symbol in the object language
12:44:13 <Peaker> why can't I just "assert" that all head <= (head tail) and let the type system do the rest?
12:44:49 <dozer> well, what does the type-system do with this assertion?
12:45:06 <Peaker> it just figured out, according to the types, which <= is being referred to here
12:45:12 <Peaker> s/figured/figures
12:45:26 <dozer> k, so it resolves <= to a block of code
12:47:34 <Peaker> perhaps - it would need to use your intermediate assertions to prove sort is correct w.r.t assertions for each differing type invocation
12:48:32 <dozer> sort :: (a -> a -> Ordering) as ord -> [a] as unsorted -> [a] as sorted asserting all zipWith (==) sorted (tail sorted)
12:49:06 <Peaker> <=
12:49:14 <dozer> oops :)
12:49:43 <dozer> so what happens next to check this?
12:50:14 <dolio> What happens next is you write it in a dependently typed language. :)
12:50:30 <Peaker> Why not:   sort :: ([input:a] -> [output:a], assert zipWith (<=) output (tail output)) (or a better syntax)
12:50:42 <Peaker> that's not enough, though
12:51:26 <Peaker> Why not:   sort :: ([input:a] -> [output:a], assert zipWith (<=) output (tail output), verify element counts are equal in input and output too)
12:51:59 <Peaker> I am new with Haskell, I am not yet comfortable writing these expressions :)
12:52:06 <Anoob> If you want some extra cash, just click this link and sign up http://www.AWSurveys.com/HomeMain.cfm?RefID=maconga   Just fill out the surveys and you get cash!
12:52:06 <lambdabot> Title: A.W.Surveys The New Survey Experience
12:52:27 --- mode: ChanServ set +o Saizan
12:52:35 <byorgey> Peaker: it sounds to me like you really just want a dependently typed language. =)
12:52:44 <Peaker> byorgey, I don't know what that means, any links?
12:52:48 <Peaker> or examples of such languages?
12:52:57 <mattam> Agda, Epigram, Coq
12:53:06 --- mode: Saizan set -o saiam
12:53:13 --- mode: Saizan set -o Saizan
12:53:29 <byorgey> Peaker: I might recommend looking at Agda, since it's descended from/inspired by Haskell
12:53:52 <byorgey> although I must admit I haven't looked at Epigram
12:54:06 <mattam> Peaker: the let you write things like sort : { f : [a] -> [a] | forall input, zipWith (<=) (f input) (tail (f input)) == all true /\ permutation input (f input) }
12:55:02 <mattam> Agda2 is somehow the descendent of Haskell, Agda and Epigram 1.
12:58:03 <lament> what about isabelle?
12:58:39 <dolio> Epigram is being rewritten with lots of changes, but it's not in working shape yet (as far as I can tell).
12:58:44 <Peaker> mattam, byorgey ok, thanks I'll look into those languages
12:58:48 <mattam> It's based on higher-order logic, which is another logical foundation that systems with dependent types, known as Type Theories.
12:59:18 <lament> epigram is werid because it's non-ascii
12:59:20 <dolio> Plus, Agda (currently) gets a lot closer to looking like Haskell.
12:59:40 <dolio> Epigram has lots of nested cases and stuff.
12:59:44 <mattam> lament: Epigram is ascii still. It's 2-dimensional though.
12:59:52 <lament> it's really really ugly in ascii
12:59:58 <dolio> That is, the way I like to write Haskell. I suppose some may disagree. :)
13:00:13 <lament> and while i haven't written any Epigram, it seems like it would be _extremely_ painful to edit
13:00:21 <lament> due to the 2d nature
13:00:36 <dolio> lament: Editor support makes it less terrible.
13:00:38 <mattam> lament: of course the editor must help much more.
13:05:09 <dolio> The editor for epigram 1 was kind of crazy, though.
13:05:42 <dolio> It was something like, xemacs wired to send all keystrokes to an epigram program, which sent back lisp tell xemacs what to do.
13:06:16 <matthew-_> dolio: yeah, it was quite impressive really ;)
13:06:26 <matthew-_> ...once you got used to it
13:06:41 <matthew-_> the inability to actually do anything useful in epigram was more the issue IMHO
13:07:09 <dolio> Yeah, I didn't play with it much when I actually had it running.
13:07:25 <matthew-_> oh. that was surely the point, no? :p
13:07:38 <dolio> I've had a lot more fun with Agda, for some reason.
13:07:51 <matthew-_> ahh, fair enough. I really want to start using that.
13:08:14 <matthew-_> though tbh, I'm pretty happy abusing Haskell/GHC to the point that I can do all sorts of buggery with the type system
13:08:29 <dolio> They stuff they're brewing for epigram 2 sounds impressive, though. I wish it were done already. :)
13:08:48 <matthew-_> yeah, but I really don't understand what's going on there
13:09:00 <matthew-_> Conor's no longer at Nottingham, or even in academia
13:09:10 <matthew-_> the blog's not been updated for months
13:09:17 <mattam> He will come back
13:09:18 <matthew-_> even Conor says to use Agda
13:09:18 <dolio> I think it already has some niceties that can kind of bug me in agda.
13:09:27 <dolio> For instance, universe polymorphism.
13:09:40 <matthew-_> mattam: is that a guess or do you actually know something there?
13:11:15 <mattam> matthew-_: The were two open positions at Nottingham and he did postulate (I think).
13:11:33 <ptolomy2> I have code that a lot of its time in a StateT ErrorT IO monad, and I am interested in trying to hand-craft the monad instead of using the transformers to see if it ends up being faster.. any hints on where to look for how to do this?
13:11:33 <dolio> Agda just got an ffi, which is nice.
13:11:47 <dolio> You might be able to write real programs in it, even. :)
13:12:19 <matthew-_> right, if real world interaction is currently that extensive then I might just have to stick with violating GHC for the time being ;)
13:13:31 <dozer> ptolomy2: if that is the behaviour you want, then perhaps making it faster by adding inline and lazyness hints to those transformers may be a better bet?
13:14:21 <dozer> although hand-coding it once may give you strong hints about what needs inlining and optimizing out :)
13:14:39 <ptolomy2> dozer: Do you mean by modifying the transformers themselves, or by adding strictness anotations to the types?
13:14:53 <dozer> profile and then have a look at the transformers themselves
13:14:58 * ptolomy2 should probably try to do it anyway, for the purposes of learnding.
13:15:40 <unenough> Does Haskell try to infer types of arguments to a method that is implemented for only one type (type class of one type)
13:15:40 <dozer> you'd hope that a stack of transformers gets compiled down into a fairly flat goopy mess with all the call chaining optimized out, but then ...
13:15:41 <unenough> ?
13:15:57 <dozer> unenough: can you give an example pls?
13:16:11 <ptolomy2> My GHC core output is pretty scary currently..
13:16:12 <unenough> <Peaker> module Main where
13:16:12 <unenough>  <Peaker>     class Noam n where jones :: n -> n
13:16:12 <unenough>  <Peaker>     instance Noam Int where jones x = x*2
13:16:12 <unenough>  <Peaker>     main = putStrLn (show (jones 5::Int))
13:16:24 <unenough> can we write 5 without the ::Int?
13:16:27 <unenough> (no, it fails)
13:16:50 <dozer> what error does it give?
13:17:18 <unenough> <Peaker>     Warning: Defaulting the following constraint(s) to type `Integer'
13:17:18 <unenough>  <Peaker>       `Num t' arising from the literal `5' at test1.hs:2:26
13:17:18 <unenough>  <Peaker>       In the first argument of `show', namely `5'
13:17:18 <unenough>  <Peaker>       In the first argument of `putStrLn', namely `(show 5)'
13:17:18 <unenough>  <Peaker>       In the expression: putStrLn (show 5)
13:17:25 <unenough> (sorry for the flood...)
13:17:29 <Peaker> unenough, no no, that's not from that
13:17:35 <Peaker> its "Ambiguous type variable `t' in the constraints"
13:17:37 <unenough> ah sorry...
13:17:47 <Peaker> `Noam t' arising from use of `jones' at test1.hs:4:27-33,  `Num t' arising from the literal `5' at test1.hs:4:33
13:18:11 <Peaker> its not that there is ambiguity between those types as there is no contradiction
13:20:17 <thoughtpolice> wouldn't it just be easier to do 'instance Num a => Noam a where jones x = x*2' since (*) has a type of Num a => a -> a -> a anyway? or is this just curiosity as opposed to something you need to fix?
13:20:25 <dozer> ok, so there are potentially (countably) infinite concrete types that could be numbers, and a similar number of types that could be Nonames.
13:20:45 <mauke> thoughtpolice: that's not valid H98
13:21:27 <thoughtpolice> mauke: i don't know the standard; what's the extension/extra feature?
13:21:29 <Peaker> thoughtpolice, that's possible, yeah
13:21:34 <dozer> the haskell typesystem is 'open' so the compiler doesn't know that Int is the only type that can possibly satisfy your dual constraint from line 4.
13:21:41 <unenough> thoughtpolice we're interested in this case where there is one type instance
13:22:00 <mauke> incoherent instances? dunno
13:22:00 <unenough> I mean only one type in the class
13:22:07 <dozer> unenough: there is only one instance 'defined', but that doesn't mean that there's only one instance 'possible' and the compiler goes with 'possible'
13:22:26 <Peaker> thoughtpolice, it does not solve the issue though
13:22:28 <Cale> thoughtpolice: In H98, instances have to have a type constructor being applied to some type variables.
13:22:28 <lambdabot> Cale: You have 2 new messages. '/msg lambdabot @messages' to read them.
13:22:41 <Cale> thoughtpolice: anything else (like in this case, just a type variable) is disallowed.
13:22:44 <Peaker> dozer, that clears it up, thanks!
13:23:22 <thoughtpolice> Cale: ah okay
13:24:34 <Cale> thoughtpolice: The reason is that figuring out which instance to use in a given circumstance gets harder and/or undecidable as you relax the conditions.
13:37:27 <kaaaen> hello, I'm back with stupid questions.
13:37:59 <kaaaen> Still can't get basic mathematics to work, this is basically what I want to do: ((Integer + Integer) / Integer) + ((Integer * Float) / Integer)
13:38:05 <mofmog> hey,c an you guys recommend a good book for haskell mostly as reference
13:38:07 <kaaaen> Can't get it to work :(
13:38:08 <mofmog> but not too dry
13:38:16 <mauke> kaaaen: what do you want the result type to be?
13:38:29 <kaaaen> I want it to be a rounded Integer
13:38:30 <solrize> kaaen you can't divide integer by anything, you have to first convert it to a fractional type
13:38:30 <lambdabot> solrize: You have 1 new message. '/msg lambdabot @messages' to read it.
13:38:37 <mofmog> i think i understand most of the theory, i'm just looking for something i can use as a reference/light reading
13:38:37 <kaaaen> (not truncated)
13:38:53 <solrize> mofmog, haskell school of expression
13:38:57 <solrize> by hudak
13:39:04 <mofmog> cool ill go check it out
13:39:06 <solrize> if you want something introductory
13:39:07 <mauke> kaaaen: use fromIntegral to convert the Integers to fractional numbers, then apply round to the result
13:39:18 <solrize> i don't think there's any good "haskell in a nutshell" reference-like books
13:39:21 <solrize> i wish there was
13:39:56 <solrize> mofmog hmm re-reading your question i'm not sure whether haskell school of expression is a good recommendation
13:40:08 <solrize> for what you were asking.  it explains stuff from the beginning, maybe not what you want
13:40:12 <solrize> all i can suggest is the online docs
13:40:18 <solrize> and the wikibook
13:40:23 <solrize> etc.
13:40:26 <mofmog> dang
13:41:23 <Heffalump> you're past the gentle introduction?
13:41:33 <Heffalump> the report is a good reference, in some ways
13:41:48 <solrize> anyone know if parsec3 is good for parsing intricate binary data structures?
13:41:56 <lament> the gentle introduction to gang rape is almost as gentle as its title implies
13:42:39 <Philippa> solrize: there's not been a chance to have a good go at it. It should have some potential
13:42:59 <Heffalump> not quite sure how one would handle offsets and stuff
13:43:41 <Cale> kaaaen: My recommendation is to convert everything to floating point, and then use the round function at the end
13:43:58 <Cale> kaaaen: You'd do that using fromIntegral
13:44:26 <solrize> philippa, thanks.   hmm, it says it uses strict bytestrings.  does that mean if i read from a file it will slurp the whole file?
13:44:48 <solrize> it is full of packets like   (4 byte binary integer N) (N bytes of data...)
13:45:44 <dons> solrize: perhaps use Data.Binary
13:45:48 <dons> its good for intricate binary structures
13:46:08 <dons> if they're really really intricate, you might need your own binary-based parser combinators
13:46:15 <dons> (i.e. if you need backtracking..)
13:47:12 <Philippa> solrize: it does, yes. You can use lazy bytestrings when you were previously working from strict fairly easily though
13:50:10 <solrize> dons i don't think i need real backtracking, i want to parse stuff like pgp messages and x509 certificates
13:50:19 <solrize> data.binary would do it, but parsec is sooooo cool....
13:50:21 <dons> oh, Data.Binary then
13:50:31 <dons> yeah, but Data.Binary will actually work :)
13:50:34 <dons> and run lazily.
13:50:41 <solrize> hehe, ok
13:50:43 <dons> its tested in industry :)
13:50:51 <monochrom> hehe
13:51:13 <solrize> maybe i can write some combinators.  i just thought it would be very clean to write parsec grammars for those N different packet formats
13:51:43 <dons> that would be awesome fun
13:51:43 <solrize> anyway thanks
13:51:47 <solrize> yeah
13:51:52 <dons> monochrom:  you like that? :)
13:51:56 <Peaker> are the Haskell parsing libraries hard-coded to use String types or are they generalized on Eq or such?
13:52:03 <dons> usually they're generalised
13:52:06 <dons> sometimes they're not
13:52:24 <solrize> parsec3 is parametrized on its input stream type, that's how i got the idea of using it on this binary stuff
13:52:26 <lispy> ?check \a -> null a == length a < 1
13:52:32 <monochrom> Yeah, I like "tested in industry".  Silences all doubts. :)
13:52:35 <Philippa> solrize: parsec3 can do it in theory, but is untested in practice
13:52:41 <lambdabot>  thread killed
13:52:52 <Philippa> Data.Binary will work. Many people will be grateful for you having a go with parsec3, but still
13:53:03 <solrize> well i might try parsec3 just for laffs
13:53:11 <lispy> ?check \xs -> null xs == length xs < 1
13:53:14 <lambdabot>      precedence parsing error         cannot mix `(==)' [infix 4] and `(<)' [...
13:53:16 <olsner> is parsec3 on bytestrings insanely fast?
13:53:33 <dc-Ankan> @pl (\x y -> add x y)
13:53:33 <lambdabot> add
13:53:34 <lispy> Cale: I think that's broken by the Expr stuff.
13:53:38 <solrize> olsner i don't see how it can be really insanely fast
13:53:47 <lispy> Cale: my little ?check example above, I mean
13:53:47 <dons> olsner: i think that's unknown
13:53:50 <dc-Ankan> oops, lol
13:54:00 <Philippa> solrize: feel free to prod me about your experiences, I can probably offer the odd bit of advice and/or tell you when there's a genuine design problem
13:54:06 <malebria> Hello, do you know a better language than haskell that I should try to implement mathematical models, just to formalize then?
13:54:07 <solrize> philippa thanks
13:54:11 <Cale> lispy: no it isn't
13:54:19 <solrize> by "insanely fast" i mean compared with compiling the grammar down to harpy
13:54:20 <Cale> lispy: you really must add some parens
13:54:21 <lispy> Cale: then why did lambdabot terminate?
13:54:22 <malebria> I want it to work, but mostly to be read.
13:54:25 <lispy> ?check \a -> null a == length a < 1
13:54:40 <lambdabot>  thread killed
13:54:43 <lispy> oops
13:54:49 <lispy> ?check \a -> ((null a) == (length a < 1))
13:54:53 <Cale> oh, code.h.o must be slow
13:55:00 <solrize> anyway, bbl
13:55:02 <lambdabot>  OK, passed 500 tests.
13:55:04 <lispy> Cale: no, with xs instead of a it gives a parse error
13:55:10 <lispy> ?check \xs -> null xs == length xs < 1
13:55:11 <lambdabot>      precedence parsing error         cannot mix `(==)' [infix 4] and `(<)' [...
13:55:19 <lispy> :t a
13:55:21 <lispy> :t xs
13:55:29 <lambdabot> Expr
13:55:30 <lambdabot> Not in scope: `xs'
13:55:34 <Cale> But a is bound by the lambda
13:55:37 <Cale> it's not an Expr there
13:55:58 <malebria> Maybe Epigram..
13:56:22 <Cale> code.h.o is being randomly flaky
13:56:53 <Cale> cgibbard@haskell:~/darcs/lambdabot$ ./quickcheck
13:56:53 <Cale> \a -> null a == length a < 1
13:56:53 <Cale> <irc>:1:6:
13:56:53 <Cale>     precedence parsing error
13:56:53 <Cale>         cannot mix `(==)' [infix 4] and `(<)' [infix 4] in the same infix expression
13:57:47 <Cale> If code.h.o is doing something, and it makes running quickcheck take too long (even just for a parse error), you end up with thread killed.
13:57:48 <lispy> hmm
13:57:58 <Jedai> malebria: Coq is the most mature language in this category I think ??
13:58:10 <Jedai> Though Agda is pretty nice
13:58:25 <lispy> Cale: well, it's weird that it keep misbehaving the same way but only on 'a' and not on 'xs'
13:58:34 <Cale> ?check \a -> null a == length a < 1
13:58:37 <lambdabot>      precedence parsing error         cannot mix `(==)' [infix 4] and `(<)' [...
13:58:43 <Cale> It's just random.
13:58:57 <Jedai> ?check \a -> null a == (length a < 1)
13:58:59 <lispy> alright
13:59:12 <lambdabot>  thread killed
13:59:17 <Jedai> ?check \a -> null a == (length a < 1)
13:59:18 <lambdabot>  OK, passed 500 tests.
13:59:20 <Philippa> Jedai: there's a strong argument for them not being the same category
14:00:03 <malebria> Jedai: thanks, I'll take a look.
14:00:35 <Jedai> Philippa: To specify a formal mathematical model, Coq would be more adaptated, no ?
14:02:04 <DuClare> Is it easy to use xft with haskell?  (i.e. is there a library / bindings for it?)
14:02:24 <dons> there are bindings, yep
14:02:30 <dons> xmonad contrib uses the Xft stuff
14:05:52 <Philippa> Jedai: not a term I'm familiar with. But one's intended primarily as a programming language and the other primarily for theorem proving. This makes some significant differences in terms of design decisions
14:07:05 <Jedai> Philippa: Yes, that's why it seemed to me Coq would be better in his case (though we lack details).
14:08:24 <solrize> jedai there's a good comparison article http://www.cs.ru.nl/~freek/comparison/
14:08:30 <lambdabot> Title: The Seventeen Provers of the World
14:09:23 <gweiqi> what does the last S in ShowS refer to? state?
14:09:31 <dons> hmm
14:09:33 <dons> good question!
14:09:36 <dons> no, its not state.
14:09:40 <gweiqi> ok
14:09:46 <dons> its a "difference list" structure.
14:09:53 <dons> but hmm, what does the S stand for.
14:10:04 <byorgey> I've always wondered that too =)
14:10:07 <idnar> I thought it was just meant to be a plural
14:10:08 <gweiqi> hehe
14:10:25 <dons> idnar: yeah, but then it wouldn't be capitalised
14:10:39 <idnar> true
14:11:47 <oal> hello there
14:12:24 <oal> which character would you use to distinguish list opertors?
14:12:38 <oal> I mean: I have @+ for zipWith (+)
14:12:50 <dons> hmm?
14:12:59 <allbery_b> someone's been doing too much perl :)
14:13:07 <oal> but that needs to be defined with each operator separatly, (@) is not a valid function
14:13:18 <oal> yeah, that was extra chosen that way
14:13:31 <oal> once I had $/ for skalar division
14:13:38 <Peaker> I would predict most Haskell'ers would possess a strong dislike towards Perl :)
14:13:45 <allbery_b> pugs.  fail
14:13:46 <oal> i.e. map (/)
14:13:49 <dons> i don't understand what the question is.
14:14:02 <oal> it's just some symbolism
14:14:09 <oal>  would
14:14:13 <oal> err
14:14:26 <allbery_b> oal seems to want to visually group operators by leading sigil
14:14:34 <oal> I would like to have some "lift" function for lists
14:14:49 <oal> and I am to lazy to type "zipWith" every time
14:14:56 <matthew-_> so do people think that functions which have 255 line type sigs (of which 249 are class contexts) are unreasonably big?
14:15:29 <allbery_b> Icon uses the convention:  x scalar, xx list/array, xxx set/map.  this unfortunately doesn't scale well
14:15:33 <shachaf> matthew-_: It depends on the people. :-)
14:15:57 <allbery_b> although it has ther advantage that (+) already follows it to some extent (no (+++) for set/map insert though)
14:16:09 <oal> on err... variables I use x for scalars, xs for lists and xss for lists of lists
14:16:46 <oal> but ++ has other meaning as I would like to have in "@+" or something
14:16:46 <oal> and -- makes trouble
14:16:47 <mauke> > S.fromList [1,3]
14:16:52 <lambdabot>  fromList [1,3]
14:17:07 <mauke> > S.fromList [1,3] ++ S.fromList [3,2]
14:17:07 <lambdabot>  fromList [1,2,3]
14:17:28 <oal> and what I would like to have is
14:17:33 <desegnis> @type (++)
14:17:35 <lambdabot> forall m. (Monoid m) => m -> m -> m
14:17:38 <oal> > zipWith (+) [1,2,3] [4,5,6]
14:17:39 <lambdabot>  [5,7,9]
14:17:39 <desegnis> ah
14:18:08 <desegnis> mappend
14:18:09 <shachaf> Since when is (++) for all Monoids?
14:19:46 <dozer> cale - awake?
14:19:49 <matthew-_> shachaf: I like that answer. ;)
14:19:56 <Cale> hello
14:19:57 <shachaf> oal: With the appropriate Applicative instance, you could use idiom brackets.
14:20:07 <Cale> shachaf: since I changed it ;)
14:20:19 <dozer> Cale - do you maintain Control.Monad.Random?
14:20:59 <Cale> dozer: Not that I'm aware of...
14:21:04 <bos> oh, i thought you did.
14:21:08 <allbery_b> dozer: did you check hackage.haskell.org?  I saw a maintainer listed on the entry for MonadRandom
14:21:11 <bos> sorry, dozer
14:21:12 <dozer> then I have been sadly miss-informed :)
14:21:12 <Cale> dozer: I initially wrote a MonadRandom on the Haskell Wiki.
14:21:24 <dozer> ah, that would explain it
14:21:27 <Cale> But if you're looking at something in hackage, that's not mine.
14:21:38 <Cale> (though it might have been copied from mine)
14:22:08 <Cale> Hehe, putting code on the wiki is a great way to not be responsible for maintaining it ;)
14:22:15 <oal> shachaf: thanks, I'll give it a thought
14:22:37 <bos> all the credit, none of the maintenance bother.
14:23:52 <Cale> Is there a maintenance issue?
14:24:01 <allbery_b> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/MonadRandom-0.1.0 says Eric Kidd <haskell@randomhacks.net>
14:24:04 <lambdabot> http://tinyurl.com/28wzxt
14:24:14 <bos> http://reddit.com/info/6d86g/comments/
14:24:18 <mofmog> dang
14:24:19 <dozer> cheers - now I know more about hackage :)
14:24:37 <mofmog> making an interpreter for an imperative language is a lot harder than one for a functional language in haskell
14:24:44 <bos> i wonder if eric is doing any more haskell hacking.
14:24:46 <matthew-_> sessions 2008.3.24 just released. Get it while it's hot.
14:24:48 <allbery_b> in general hackage is the first place to look for stuff like this
14:25:15 <dozer> Cale: I had to patch it to get it to build under ghc-6.8.2
14:25:31 <dozer> Cale: and I added a couple of methods so I could lift old-style random code into the monad
14:25:41 <Cale> dozer: ah
14:25:42 <yuriyp> @hoogle a -> [a]
14:25:42 <lambdabot> Prelude.repeat :: a -> [a]
14:25:42 <lambdabot> Data.List.repeat :: a -> [a]
14:25:42 <lambdabot> Prelude.iterate :: (a -> a) -> a -> [a]
14:26:00 <bos> dozer: if eric doesn't respond, you should think about maintaining it yourself
14:26:24 <dozer> no I shouldn't - I already have (potentially nominal) ownership of a bewildering array of codebases
14:26:53 <bos> then another little tiny nibble won't make any difference!
14:27:06 <dozer> straws break cammel's backs
14:27:23 <Heffalump> mofmog: make the interpreter monadic
14:27:23 <mofmog> So what i want to do is have a simple language with a few commands: add, subtract, multiply, divide, label, goto, jumpIfPositive
14:27:31 <mofmog> Heffalump: it already is >_<
14:27:34 <mofmog> i think i'm doing something wrong
14:27:41 <mofmog> it's not finished but it's ugly
14:28:06 <mofmog> there are no variables, but i do have a set number of registers with which to work with
14:28:14 <Jaak> aah, goto requires Cont monad, no?
14:28:29 <mofmog> the problem is i have to keep track of location, the state of the register and the program itself
14:28:32 <skorpan> @pl \(name, points) -> Player name points
14:28:33 <lambdabot> uncurry Player
14:28:40 <skorpan> what the heck
14:28:47 <Jaak> skorpan: looks very good
14:28:52 <skorpan> cool
14:28:52 <allbery_b> looks right to me
14:28:53 <Jaak> constructors are also functions
14:28:58 <mofmog> so i'm basically passing a 3-tuple around all over the place, and it seems that in every sub routine or function i have to extract the contents again and again
14:29:09 <mofmog> well it's not a 3-tuple, it's a tuple with another tuple inside
14:29:32 <Cale> mofmog: Well, you could use a monad to deal with that passing around, now that you understand how it works :)
14:29:47 <Cale> mofmog: That's essentially what the State monad does.
14:29:55 <mofmog> well i do have a monad passing it around but i have to extract each part of the monad each time it seems
14:30:07 <mofmog> and every time i change a part i have to wrap up the part i changed and put it back in
14:30:07 <Jaak> i'd like to see the goto implementation, if the interpreter is monadic
14:30:12 <Cale> each part of the state, you mean?
14:30:15 <mofmog> yes
14:30:24 <allbery_b> and?  make wrapper functions.  it's ghc's job to optimize it
14:30:26 <Cale> Well, you should write some simple functions
14:30:30 <skorpan> is it possible to export everything but type constructors in a module?
14:30:31 <allbery_b> (hopefully to an unboxed tuple)
14:30:34 <Cale> for getting and setting each part
14:30:47 <mauke> ZipList needs more instances
14:30:56 <mofmog> ah
14:31:15 <allbery_b> although I suspect a tuple of tuples makes that more complicated; I'd just use an N-tuple with custom accessors
14:31:21 <mofmog> mm
14:31:24 <allbery_b> or even a record
14:31:39 <Cale> a record is a nice way to keep things straight anyway
14:31:44 <mofmog> Jaak: I'm dealing with goto in a stupid manner: i just make it change the location
14:31:47 <mofmog> a record?
14:32:01 <Cale> Well, a datatype with named fields
14:32:04 <allbery_b> data MyState a = MyState { foo :: !a; bar :: !a; baz :: !a}
14:32:17 <Cale> something like that
14:32:19 <allbery_b> the ! marks it as strict, which helps with unboxing
14:32:19 <lispy> data List a = Nil | Cons { head :: a, tail :: List a }
14:32:39 <Cale> If you really worry about unboxing and strictness at all.
14:32:50 <allbery_b> (note that if you want laziness you don't want the strictless annotation; but then you can't have optimization either, I think)
14:33:02 <mofmog> mm
14:33:03 <Cale> I would probably wait until performance was an issue before trying such things. :)
14:33:15 <mofmog> thanks!
14:33:51 <Cale> (the strictness annotations will make sure that large expressions don't build up in your state though)
14:34:00 <allbery_b> the MyState I defined above is the same as data MyState a = MyState !a !a !a plus defining your own accessors and mutators for the parts, except you also get some pattern matching syntax (which you can't define yourself)
14:34:26 <mofmog> so how does the pattern matching work
14:34:52 <Cale> f (MyState { foo = x }) = x^2
14:35:05 <Cale> You can match only on some of the labels, for example.
14:35:32 <Cale> There's also a record update syntax which looks like:
14:35:40 <Cale> myrecord { foo = 5 }
14:35:46 <mofmog> 0_0
14:35:53 <mofmog> that feels a bit imperative imho
14:35:57 <allbery_b> ity's nopt
14:36:01 <allbery_b> it's not
14:36:02 <Cale> Which will be a value that's the same as myrecord, but which has 5 in the foo field.
14:36:09 <allbery_b> it returns a copy of myrecord with the foo element set to 5
14:36:09 <mofmog> oh
14:36:11 <mofmog> i see
14:36:15 <allbery_b> it doesn't mutate myrecord in place
14:36:19 <mofmog> ah
14:36:24 <Cale> Of course, the fields are all pointers, so copying is fast.
14:36:24 <mofmog> not exactly a set-car
14:36:37 <mofmog> oh man, this has been a lot of help
14:38:06 <mauke> @src [] mconcat
14:38:06 <lambdabot> Source not found.
14:39:50 <matthew-_> Heffalump: have you thought much about the claims that fundeps and type families are equivalent in terms of power of expression?
14:40:12 <Cale> :t mconcat
14:40:14 <lambdabot> forall a. (Monoid a) => [a] -> a
14:40:28 <Cale> @src [] mappend
14:40:28 <lambdabot> Source not found. That's something I cannot allow to happen.
14:40:31 <Cale> meh
14:42:14 <lispy> :t [] :: [] Int
14:42:15 <lambdabot> [Int]
14:47:24 <matthew-_> Heffalump: it's just there are some problems that I can solve with type families which I can't see how to solve with fundeps. For example, if with fundeps you have an infinite type problem, type families can often hide the recursion existentially and so make the problem go away
14:47:25 <EvilTerran> matthew-_, i thought it'd been shown that neither is a superset of the other
14:47:38 <matthew-_> EvilTerran: yeah, I've read that too.
14:48:03 <matthew-_> In this particular case, I can think of ways around it with fundeps, but they're fugly.
14:48:15 <sjanssen> ooh, I just found a fun little readFile trick
14:49:24 <sjanssen> try something like: "do f <- readFile; fork (print f); print f"
14:50:51 <matthew-_> sjanssen: if this deletes my hard disc...
14:51:06 <sjanssen> then try "do f <- readFile; print f; fork (print f)"
14:51:13 <allbery_b> nasal demons?
14:51:13 <sjanssen> matthew-_: nah, nothing like that :)
14:51:40 <sjanssen> allbery_b: here, it consistently prints in the forked process, but not in the original
14:51:50 <sjanssen> crazy lazy IO
14:52:23 <allbery_b> lazy IO plus a unix scheduling convention perhaps (the child gets scheduled first)
14:52:34 <sjanssen> right
14:52:59 <sjanssen> the second process forces the entire 'f' thunk, which makes GHC close that file descriptor
14:53:55 <allbery_b> hm, right, not OS processes/threads, unix scheduler irrelevant
14:54:02 * allbery_b still a bit woozy, sigh
14:54:21 <sjanssen> making the first process unable to read from it, causing it to return the empty list
14:54:28 <dons> matthew-_: there's a bunch of people here at work keen to see examples of the session types in use. are these expected to appear ? :)
14:54:32 <sjanssen> allbery_b: no, you were right in  the beginning -- I mean unix's fork
14:57:01 <cinema> JaffaCake: ping
14:57:10 <matthew-_> dons: hopefully tonight will see the last major feature go in. Then there's a certain deadline approaching rapidly that will require me to do some typing. But I'm really really wanting to write some decent tutorials on this stuff. I really do think it's actually useful ;)
14:57:17 <JaffaCake> cinema: ?
14:57:48 <cinema> JaffaCake: Hi, I sent you a patch concerning Alex 2 weeks ago. Did you get it ?
14:57:49 <matthew-_> dons: but thanks for the encouragement - it's good to know people are actually following (or interested in trying to) what I'm doing :)
14:57:56 <glen_quagmire> can I make shared library (.so, .dll) using haskell?
14:58:01 <allbery_b> ok, so your description is slightly wrong.  closing the fd in the child doesn't close it in the parent.  *but* the file offset pointer will be shared, so the parent's first read gets EOF
14:58:09 <bos> glen_quagmire: not quite yet
14:58:16 <sjanssen> allbery_b: ah, okay
14:58:35 <glen_quagmire> bos: oh thank you
14:58:44 <JaffaCake> cinema: I think so... but I'm currently off site visiting Galois, and I've put various things on hold for now
14:58:52 <cinema> JaffaCake: I just wanted to now if it'd be better if I submit it via the library proposal process
14:58:56 <bos> glen_quagmire: i think that 6.10 should show some progress there
14:59:16 <JaffaCake> cinema: don't worry, I'll get around to it
14:59:51 * glen_quagmire was wondering python ctypes can interface with haskell
14:59:52 <cinema> JaffaCake: Thanks. There's absolutely no hurry. I just wanted to know if you had got it
15:00:15 <ddarius> glen_quagmire: Sure
15:00:30 <allbery_b> (that dup()ed file descriptors share file table entries, hence fcntl() flags and seek offset, is one of the unix oddities that sometimes trips people up)
15:01:44 <JaffaCake> cinema: yours is the ALEX_MONAD_USER_STATE patch, right?
15:02:05 <solrize> glen_quagmire there is something in the python wiki about doing that under windows... i asked about it here a few days ago and apparently putting the ghc rts into a unix .so doesn't work well at the moment
15:02:13 <solrize> there is a summer of code proposal to make a haskell-python bridge
15:02:20 <solrize> i was just looking at the blurb for that a little while ago
15:02:28 <lament> i've seen somebody do that in a blog comment in about 10 lines
15:02:33 <sjanssen> allbery_b: yeah, I'd expect it when working with a Handle.  But it's very surprising to have normal values evaluate differently :)
15:03:15 <cinema> JaffaCake: exactly
15:08:30 <dons> JaffaCake: people complain that compiling xmonad-contrib takes 10 minutes on a oldish machine, despite very few dependencies between modules
15:08:40 <dons> any ghc --make -N 10 on the horizon :)
15:09:26 <dons> dcoutts_: or can we get cabal to use one-shot, Makefile-style drivers to do the build in parallel..
15:10:00 <dcoutts_> dons: not yet, but eventually Cabal will do dependency style parallel builds
15:10:28 <dons> i'd like to just dump the makefile with -M and have cabal call 'make -j4' :)
15:10:43 <dcoutts_> ghc's build system does that, but don't tell anyone :-)
15:10:59 <dons> xmonad-contrib can almost entirely be built in parallel. 120 modules, only depending on libHSxmonad, not on each other
15:11:29 <dons> could a cheap ghc -M solution be done at the hackathon, do you think?
15:11:39 <dons> there'll be a few dual core laptops to play with
15:11:40 <dcoutts_> it's already done but it's not nice at all
15:11:48 <dcoutts_> like I said, ghc does that
15:11:57 <dons> but having cabal wrap that up ?
15:11:57 <dcoutts_> for building the core libs
15:12:02 <dons> yeah, that's the model
15:12:21 <dcoutts_> it calls Setup.hs makefile to generate a makefile
15:12:31 <sjanssen> dcoutts_: how is that going, btw?  I've not been paying attention lately
15:12:41 <dcoutts_> but the makefile that Cabal generates is highly ghc-specific and not nice
15:12:54 <dons> hmm. cabal already generates the makefile?
15:12:55 <dcoutts_> if we're going to put any effort in, it should be into doing it properly
15:13:13 <dons> does this work as is, you're saying?
15:13:15 <dcoutts_> dons: yes, but like I said, don't tell anyone ;-)
15:13:17 <dons> if we follow ghc's use of cabal?
15:13:23 <dons> hmm
15:13:26 * dcoutts_ does not reccomend it
15:13:28 <dons> sjanssen: did you hear that? :)
15:13:43 <dons> 120 modules, no dependencies. 4 cores.
15:14:05 <dcoutts_> dons: note that support *will* be ripped out with no notice as soon as Cabal's own dependency system is good enough
15:14:25 <dcoutts_> so I would not at all recommend relying on it for anything you care about
15:15:13 <dcoutts_> we only support it to the extent that it can build ghc's core libs in the context of the ghc build system
15:15:26 <dons> well, you won't rip it out till ghc is ready
15:15:28 <dons> which is fair warning
15:15:36 <dcoutts_> well :-)
15:15:38 <dons> we're only talking about devs using this trick
15:15:44 <dcoutts_> the generated makefiles include various ghc-specific includes
15:15:57 <dcoutts_> which you'd need to replicate
15:16:14 <dons> ah hmm
15:16:27 <mofmo1> if i have a data type that is a record
15:16:39 <mofmo1> how do i um... use it
15:16:51 <sjanssen> dcoutts_: how is the dependency branch of Cabal doing?
15:17:09 <ddarius> @google inurl:hawiki "UsingRecords"
15:17:09 <lambdabot> No Result Found.
15:17:10 <dcoutts_> sjanssen: not much recently, we've been working on Cabal-1.4 and cabal-install
15:17:18 <dcoutts_> sjanssen: but I've proposed a SoC project on it
15:17:22 <mofmo1> data T = T {a, b, c} for example, if i had a function that works on data type T called f, how would i use f
15:17:35 <ddarius> @oldwiki UsingRecords
15:17:35 <lambdabot> http://www.haskell.org/hawiki/UsingRecords
15:17:35 <dcoutts_> sjanssen: and I hope we can work on it a bit at the hackathon
15:17:40 <EvilTerran> f T{a = foo, b = bar} = ...
15:17:54 <EvilTerran> where "foo" and "bar" are fully-fledged patterns
15:17:59 <mofmo1> mm
15:18:04 <EvilTerran> and you can mention as many or as few of the fields as you like
15:18:07 <ddarius> http://web.archive.org/web/20061011094943/http://haskell.org/hawiki/UsingRecords
15:18:22 <EvilTerran> right up to just matching on the constructor; "f T{} = ...; f U{} = ..."
15:18:28 <mofmo1> i tried googling "haskell records" and i kept getting proposals about how to chang ehtem...
15:18:40 <Twey> Haha
15:18:53 <EvilTerran> oh, wait, you said use the function, not define it
15:19:02 <EvilTerran> ok, in that case, "foo" and "bar" are expressions
15:19:11 <EvilTerran> and any fields you don't mention are undefineds
15:19:28 <EvilTerran> f T{a = 1, b = 2, c = 3}
15:19:56 <glen_quagmire> solrize: oh http://wiki.python.org/moin/PythonVsHaskell  and http://quux.org:70/devel/missingpy
15:22:23 <mofmo1> what happened to hawiki
15:22:28 <bos> i wish for a moron-free programming.reddit.com
15:23:48 <lament> i'd suggest LTU but it's a) not moron-free and b) not programming.reddit.com
15:24:01 <lispy> *shrug* reddit is a waste of time anyway :)
15:24:13 <ddarius> lament: LtU has a rather low moron content though.
15:24:38 <lament> i'm just preempting arguments :)
15:24:46 <glen_quagmire> you can create subredit and block morons
15:25:25 <mofmo1> is "putLoc newLoc = do { ls <- get; put $ ls { loc = newLoc }; }" legal?
15:25:39 <mofmo1> assuming ls an instance of a record
15:25:49 <mofmo1> and the state monad
15:25:57 <ddarius> It should be.
15:26:03 <glen_quagmire> mofmo1: why not? let me try it and see
15:26:39 <ddarius> Incidentally, putLoc newLoc = modify (\ls -> ls { loc = newLoc })
15:29:35 <Cheery> how senseless and cruel chitchat can feel so good?
15:30:02 <Cheery> even A.L.I.C.E can do that
15:30:28 <Cheery> heckzch! even old demented ladies can do that
15:36:07 <unenough> > concatMap (\x ->[x+3]) [1, 2, 3]
15:39:33 <Peaker> why is lambdabot not responding?
15:40:00 <cjb> sometimes it crashes.
15:40:08 <cjb> that Haskell, it's a totally unreliable language, see.
15:40:32 <ddarius> @bot
15:42:17 <dons> ?bot
15:43:33 <ivanm> what have you done to her, dons? :p
15:43:42 <dons> she's Cale's business now
15:43:52 <ivanm> oh? you've let her go?
15:44:06 <Cale> Is it down?
15:44:14 <Cale> @bot
15:44:16 <glen_quagmire> hpastebot is down
15:45:38 <Cale> hmm
15:47:12 <Cale> strange.
15:47:14 <Saizan> @bot
15:47:19 <lambdabot> :)
15:47:32 <glen_quagmire> instance Show Blah where .. is that where same where in func a b c = blah ..  where blah = .. ?
15:47:48 <Cale> It seems it somehow managed to get disconnected, but without either the server or the client actually noticing.
15:47:56 <glen_quagmire> let show x = ..   in instance Show Blah
15:48:10 <Cale> glen_quagmire: It's similar. It's the same keyword, and a similar idea.
15:48:31 <Saizan> glen_quagmire: you can't use let .. in instead of where there
15:49:41 <glen_quagmire> class Blah: \n\t (==) :: Blah -> Blah -> Bool    python syntax!
15:50:22 <monochrom> \t is evil
15:50:46 <matthew-_> @pl \y x -> if x then Just y else Nothing
15:50:47 <lambdabot> flip flip Nothing . flip if' . Just
15:50:55 <Saizan> glen_quagmire: Blah is not a type :)
15:50:59 <glen_quagmire> evolution proved \t to be useful for internets
15:51:11 * glen_quagmire never written class before
15:58:36 <EvilTerran> matthew-_, you can probably write that nicer with guard
15:59:49 <Saizan> (do guard x; return y) is not so nicer..
16:00:34 <chessguy> @src zip
16:00:34 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
16:00:34 <lambdabot> zip _      _      = []
16:00:58 <chessguy> hrm. zip isn't zipWith (,) ?
16:01:14 <lament> @src zipWith
16:01:14 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
16:01:14 <lambdabot> zipWith _ _      _      = []
16:01:16 <glen_quagmire> > zipWith (,) [1,2,3] "yay"
16:01:19 <lambdabot>  [(1,'y'),(2,'a'),(3,'y')]
16:01:32 <gnuvince_> :t (,)
16:01:34 <lambdabot> forall a b. a -> b -> (a, b)
16:02:22 <glen_quagmire> > (1 2 (,))
16:02:22 <lambdabot>        add an instance declaration for
16:02:22 <lambdabot>       (Num (t -> (a -> b -> (a, b)) ->...
16:02:30 <glen_quagmire> > (1 2 `(,)`)
16:02:30 <lambdabot>  Parse error at "(,)`)" (column 7)
16:02:33 <lament> seems like a pretty obvious refactoring... i'm sure there's some obscure reason for defining zip that way
16:02:42 <Saizan>  @src is mostly demonstrative
16:02:54 <ddarius> @where report
16:02:54 <lambdabot> http://www.haskell.org/onlinereport/
16:02:58 <lament> besides yeah, who knows what ghc actually does when it sees zip
16:03:10 <lament> hopefully, it doesn't follow that definition
16:03:34 <chessguy> someone just put a JS implementation of zip in ##javascript:
16:03:34 <ddarius> The Report definition is zip = zipWith (,)
16:03:36 <chessguy> function zip() { var i, j, r = [], v, iter = 0; for (i = 0; i < arguments.length; ++i) iter = Math.max(arguments[i].length, iter); for (i = 0; i < iter; ++i) { for (j = 0, v = []; j < arguments.length; ++j) v.push(arguments[j][i]); r.push(v); } return r; };
16:03:45 <dons> hehe
16:03:53 <glen_quagmire> javascript?
16:03:53 <chessguy> isn't that so nice!
16:04:02 <dons> ah,no inductive lists?
16:04:03 * RayNbow puts on his safety goggles
16:04:07 <dons> nor pattern matching
16:04:49 <lispy> sometimes I wish we had a standard version of zip that padded the shorter list
16:04:50 <wolverian> you'd do it lazily with coroutines, methinks, at least in js 1.7
16:05:31 <Peaker> I don't like pattern matching.. I like explicit conditionals with fancy syntax (or better yet, schematic tables).  One obvious way to do it is nice
16:05:33 <lispy> ?oldwiki Polynomials
16:05:33 <lambdabot> http://www.haskell.org/hawiki/Polynomials
16:05:35 <wolverian> ..which are called generators, which are wrapped by iterators
16:05:37 <monochrom> They take pride in mutation.
16:05:45 <wolverian> like python, really.
16:05:49 <dons> Peaker: isn't pattern matching explicit conditionals with fancy syntax?
16:06:12 <dons> you look at the data structure's  structure, and then dispatch based on its shape
16:06:19 <dons> that's fancy syntax for conditionals
16:06:22 <monochrom> I see pattern matching as tabulation.
16:06:23 <Peaker> dons, you could say that - if static analysis told you when they weren't exhaustive
16:06:35 <dons> -Wall
16:06:48 <ddarius> It would be nice if C# came with a ZipWith because you have to explicitly mess around with enumerators to write it.
16:06:50 <dons> do you use -Wall to enable exhaustivity warnings?
16:06:52 <Peaker> dons, ok, then that's great, but for "one obvious way", have them be the only way :)
16:07:11 <ddarius> Peaker is a Pythonista.
16:07:23 <dons> i'm not sure what the problem is here :)
16:07:23 <Peaker> dons, I usually do - and I thought I ran a tutorial example with -Wall but appearantly I didn't beacuse it had a buggy non-exhaustive pattern match
16:07:31 <monochrom> But in Haskell the one obvious way is to use Church encoding.
16:07:47 <ddarius> monochrom: That's not even possible in Haskell 98.
16:07:52 <Peaker> ddarius, you are correct - I very much like the Python motto of "one obvious way"
16:07:54 <dons> the P languages are slowly catching on with pattern matching
16:08:05 <dons> these desugaring bindings they're getting incrementally
16:08:11 <ddarius> Peaker: You're not in Kansas anymore.
16:08:14 <dons> so you can roughly pattern match on lists and tuples
16:08:21 <Peaker> ddarius, Kansas? When was I in Kansas?
16:08:31 <dons> but without algebraic data types, data structures are kind of limited in use anyway
16:08:42 <glen_quagmire> > let f ((,) a b) = (+ a b) in f (1,2)
16:08:42 <lambdabot>   add an instance declaration for (Num (t -> a))
16:09:12 <EvilTerran> > let f ((,) a b) = (+) a b in f (1,2)
16:09:13 <lambdabot>  3
16:09:20 <EvilTerran> > uncurry (+) (1,2)
16:09:21 <lambdabot>  3
16:09:24 <glen_quagmire> oh darn (+ 1 2)
16:09:28 <EvilTerran> this is not lisp
16:09:38 <glen_quagmire> This is HAAAAAAAAASKELLLLLLLLLLLL!!!!!!
16:09:44 <Peaker> gigidi gigidi
16:10:03 <monochrom> Anyway, there is no such thing as "one obvious way" in Haskell.  Only a progression of more and more abstract ways.  What is "obvious" depends on your level.
16:10:19 <EvilTerran> arrows, applicatives, and comonads!
16:10:22 <ddarius> @where evolution
16:10:22 <lambdabot> http://www.willamette.edu/~fruehr/haskell/evolution.html
16:10:40 <Peaker> monochrom, Well, there's no way to prevent multiple ways to do it.  But having multiple ways to _express_ the exact same way is not a good thing
16:10:52 <Jaak> brrr
16:10:54 <lament> in haskell, there's only one way to do it, and nobody knows what it is.
16:11:01 <gnuvince_> hahah
16:11:12 <Jaak> i now am afraid of python people
16:11:16 <monochrom> http://www.willamette.edu/~fruehr/haskell/evolution.html
16:11:17 <resiak> so, are comonad tutorials the new black?
16:11:17 <lambdabot> Title: The Evolution of a Haskell Programmer
16:11:25 <Twey> Jaak: Why's that?  :-)
16:11:26 <wolverian> lament, ...and it is unproven that it is possible to know it?
16:11:32 <lament> wolverian: yeah.
16:11:39 <EvilTerran> nah, there's two ways - the normal way (that no-one knows), and the way in the type system (that oleg knows)
16:11:43 <lispy> ah man, I put some code on the hawiki once, and helped move it to the new wiki but I can't find it now
16:11:51 <monochrom> All of them are "the one true obvious way".
16:11:51 <wolverian> EvilTerran, hahaha
16:11:51 <Jaak> Twey: the "one obvious" way scares me
16:11:55 <glen_quagmire> who is oleg?
16:12:05 <EvilTerran> ?where oleg
16:12:05 <lambdabot> http://okmij.org/ftp/
16:12:07 <Jaak> god?
16:12:12 <bd_> glen_quagmire: He is the standard calibrated unit of type-level hackery skill.
16:12:21 <roconnor> god's right hand man.
16:12:46 <monochrom> Anyway I think I'm still greatly misunderstood.
16:12:51 <EvilTerran> pretty much god, yeah. one of the best compsci theorists alive today, from what i can tell
16:12:54 <glen_quagmire> is he a real person or internet persona?
16:13:00 <glen_quagmire> oh i see
16:13:10 <bd_> glen_quagmire: For comparison, implementing Data.Generic requires approximately ten milliolegs.
16:13:12 <wolverian> I've heard someone has actually seen him :)
16:13:16 <EvilTerran> he's real. Oleg Kiselyov.
16:13:19 <ddarius> EvilTerran: He seems about an average computer scientist to me.
16:13:31 <EvilTerran> ddarius, well, one of the most verbose, at least ;)
16:14:08 <EvilTerran> and be careful when you say "average" - there's a lot of shoddy compscis out there to drag the mean down.
16:14:08 <wolverian> so um, does 6.8 have type families?
16:14:10 <EvilTerran> :P
16:14:29 <wolverian> now where'd I put my browser..
16:14:48 <Twey> Jaak: Are you Dutch?
16:14:52 <Jaak> nope
16:14:57 <Twey> Jaak: Then it's meant to
16:14:58 <EvilTerran> http://video.google.com/videoplay?docid=-7990603720514207956 <- i think this is him
16:14:59 <lambdabot> Title: Oleg Kiselyov: Normal-order Syntax-Rules (Dan Friedman&#39;s 60th Birthday)
16:14:59 <bd_> Hm, I should see how well they handled ep 7 's 非通知設定 and etc
16:15:01 <bd_> err
16:15:03 <bd_> wrong window
16:15:06 <Jedai> Pattern matching is the only way to get at most data structures... (then you can add accessors or manipulators)
16:16:49 <glen_quagmire> in java, we use getters instead
16:17:06 <glen_quagmire> f dat = dat.getName ...
16:17:27 <glen_quagmire> python eliminated "get" part...   f dat = dat.name
16:17:38 <shapr> sorear: Hey, what's the command to pack hpaste state?
16:17:44 <shapr> scannedinavian is out of space
16:17:52 <glen_quagmire> in haskell,  f (name ...) = name ...
16:17:53 <sorear> 'rm'
16:18:04 <ddarius> shapr: How much space in hpaste taking?
16:18:06 <shapr> Yeah, but I've forgotten where..
16:18:20 * shapr looks
16:18:44 <Twey> http://tomayko.com/writings/getters-setters-fuxors glen_quagmire
16:18:45 <lambdabot> Title: Getters/Setters/Fuxors
16:19:06 <shapr> ddarius: looks like 2.8 gb
16:19:09 <sorear> shapr: hpaste writes out its state in full to a new file every time a paste is added, and the old states never get deleted, and alexj denies that this is at all bad (and I haven't touched it in months, for all I know it's saner now)
16:19:18 <shapr> It's bad.. very bad.
16:19:35 <shapr> sorear: rm the archive, right?
16:19:41 <sorear> yeah
16:20:26 <shapr> Maybe alexj hasn't used HAppS for long running processes?
16:20:36 <Saizan> newer happs writes the full state (a checkpoint) only when explicitly requested
16:20:37 <shapr> 2.8 gb is waay too much.
16:20:46 <shapr> Ah, hpaste should really upgrade then.
16:20:51 <solrize> there really has to be a way to flush out an old tree, i didn't realize he had nothing for that
16:21:03 <shapr> Saizan: What version?
16:21:27 <Lemmih> shapr: 0.9.2
16:21:31 <shapr> ah
16:21:56 <Lemmih> You can get it from Hackage. Just 'cabal install HAppS-Server'. (:
16:22:14 <shapr> I'm just not sure if hpaste works with 0.9.2
16:22:19 <Saizan> i might upgrade the hpaste code, but glguy was working on a fastcgi implementation
16:22:24 <shapr> Yay, 2.8gb free now!
16:22:24 <Saizan> shapr: no, it won't
16:23:00 <Shimei> I hope someone works on the QtHaskell GSOC idea. I rather like working with Qt but not with C++.
16:23:09 <shapr> I like the idea of language parsers.
16:23:18 <shapr> I could really go for a C# parser and ADT right now.
16:23:27 <dons> Shimei: how would that work?
16:23:43 <dons> Saizan: yeah, the current hpaste on code.haskell.org is pretty much done
16:24:15 <Shimei> The proposal mentioned generating bindings from the C++ headers like gtk2hs.
16:25:02 * shapr boings tiredly
16:25:04 <dcoutts_> Shimei: it uses C headers not C++, parsing C++ headers is much much much harder.
16:25:13 <Saizan> Shimei: there's already a qthaskell however
16:25:41 <Shimei> Oh. Does it work well?
16:25:46 <vincenz> dcoutts_: for big values of much
16:26:13 <Saizan> Shimei: never tried, it's pretty recent
16:26:21 <dcoutts_> vincenz: yeah :-) getting c2hs to parse full GNU C was hard enough :-)
16:26:49 <vincenz> parsing C++ is like trying to ...
16:27:04 <Shimei> Oh, December 2007 release. Yeah, pretty recent. I don't see much on the sf.net site though.
16:27:16 <Zao> Once you've parsed it, you have a half compiled translation unit.
16:27:20 <vincenz> lift a ship with only your teeth
16:27:24 <ddarius> I don't believe C# is particularly difficult to parse.
16:27:26 <dcoutts_> vincenz: hah hah
16:27:28 <vincenz> as you are pulled up by a cable, encirciling your scrotum
16:27:40 * dcoutts_ runs away screaming
16:28:03 <vincenz> only more painful
16:28:27 <Excedrin> why not compile the C# and then parse the bytecode :) (probably easier)
16:29:21 <ddarius> shapr: Are you using C# 3.0>= ?  If so, you should have ExpressionTrees or whatever they are called.
16:30:26 <glguy> Has anyone used lhs2tex that knows how to tell lhs2tex to markup some text as code without it being executable in the .lhs format?
16:30:39 <dons> writing a paper, glguy?
16:30:42 <glguy> a block of code, not just |<inlined text>|
16:30:47 <dcoutts_> glguy: if it's not in the manual then ask kosmikus
16:30:58 <SamB> whoa. I've almost got JHC to the point where it supports constructor classes ;-)
16:31:21 <dcoutts_> SamB: can you get it to the point where it compiles Cabal? :-)
16:31:25 <shapr> ddarius: Yes
16:31:28 * dcoutts_ tried and failed
16:31:35 <glguy> dons: no, but I figured I'd have fewer bugs if I just wrote all my code as comments instead of something that could execute and fail!
16:31:36 <glguy> ;)
16:31:41 <dons> good idea.
16:31:45 <SamB> dcoutts_: well, it was already supposed to support constructor classes... it was some kind of obscure bug...
16:32:22 <dcoutts_> SamB: btw, if you're hacking on jhc then you're more than welcome to send patches for jhc support in Cabal
16:32:23 <dons> glguy: as yav teaches us, there's no technical data to support the use of haskell, so we may as well use latex :)
16:32:39 <dcoutts_> SamB: we keep the jhc code in Cabal compiling but I cannot easily test it
16:32:56 <SamB> you mean there is jhc code in cabal?
16:33:13 <dcoutts_> SamB: in theory Cabal supports jhc
16:33:21 <SamB> ... interesting theory!
16:33:25 * glguy summons yav
16:33:30 <yav> dons!
16:33:35 <dcoutts_> SamB: there is plenty of code for jhc in there but I cannot test it
16:34:07 <SamB> hopefully, it is a better theory than the theory that JHC implements constructor classes ;-)
16:34:14 <dcoutts_> heh
16:34:25 <darrint> Is there a convenient way to adapt read/show to bytestrings?
16:34:43 <dons> darrint: use Data.Binary ?
16:34:46 <dcoutts_> SamB: so if you give it a spin then tell me how it goes, there may be easy things I can fix.
16:34:50 <dons> yav!!
16:35:00 <matthew-_> is there any way of working out where an undefined is coming from?
16:35:03 <yav> dons!!!
16:35:09 <dons> matthew-_: use the ghci debugger
16:35:10 <darrint> dons: I liked that but it appeared I had to do a lot of manual deriving.
16:35:13 <dons> or compile with profiling
16:35:21 <SamB> basically, the kind inference doesn't seem to be using the information from the context on instance heads properly...
16:35:22 <dons> and check the .prof to see what's on the stack
16:35:27 <dons> yav!?!?!
16:35:36 <glguy> this is like the Family Guy episode from last night
16:35:41 <dcoutts_> darrint: if you don't care about perf then just unpack and use read, or use show and pack
16:35:47 <glguy> Oh, it's a yell match you want, Quohog?!
16:35:49 <glguy> WHAAA!
16:36:07 <darrint> meh. I guess I don't care about perf yet. :-)
16:36:46 <SamB> oh, as well as JHC's current ignorance of the identity (->) a b = a -> b...
16:37:27 <julz> hi, I'm a nweb to haskell and dont get a piece of code running, can someone help?
16:37:41 <matthew-_> dons: oops, it's easier than that. I forgot to finish writing the function!
16:37:53 <dons> julz: use hpaste.org
16:38:00 <julz> ok
16:38:01 <dons> then tell us what error you get
16:38:12 <glguy> !paste
16:38:25 <glguy> :-S
16:38:29 <vincenz> @paste
16:38:29 <lambdabot> Haskell pastebin: http://hpaste.org/new
16:38:35 <matthew-_> dons: no no, the do block just had an "undefined" at the end of it...
16:38:54 <julz> ok just a sec ;-)
16:39:53 <matthew-_> woot! it works!
16:40:30 <dons> oops
16:41:24 <Baughn> If I say something like "forever foo >> undefined", is the behaviour of that program in fact defined?
16:41:26 <julz> http://hpaste.org/6608
16:42:15 <julz> the error I get is in line 10:30 Couldn't match expected type
16:42:15 <glguy> for those of you following along at home, you can use '<' to prefix sections that should be formatted as code but not interpreted by ghc
16:43:32 <dolio> Agda's lack of polymorphism is a pain at times.
16:43:49 <Saizan> Baughn: well, it's not like haskell has a formally specified semantic, however yes in common implementations, undefined just throws an exception when it's inspected
16:44:16 <ddarius> Baughn: undefined doesn't mean undefined like in C or some such
16:44:19 <Baughn> Oh, good.
16:44:34 * Baughn has been wondering about the possibilities for ignoring black holes by implementing physics on haskell
16:44:39 <ddarius> dolio: You need to go to that last corner of the lambda cube.
16:44:55 <ddarius> Baughn: Haskell implementation are full of blackholes.
16:45:02 <SamB> Baughn: that means you won't get <<loop>> messages, you realize?
16:45:42 <Baughn> SamB: I can live without time-travel
16:45:45 <lament> i thought black holes were how haskell worked
16:46:06 <dolio> ddarius: Well, I don't think it ever keeps me from doing what I want, just makes me work harder.
16:46:12 <dons> that's how the continuation monad works, lament
16:46:15 <SamB> it might also result in less sharing
16:46:29 <lament> virtual stateless particles slowly evaporating from your code
16:46:32 <dons> also, unsafeInterleaveIO uses uses wormholes
16:46:41 <ddarius> dolio: C's type system never keeps you from doing what you want...
16:47:11 <Baughn> SamB: I've been pondering the evaluation model of the universe. Lots of physicists get nervous about leaving parts of their physics undefined, but lazy evalation wouldn't /mind/...
16:47:14 <byorgey> julz: which is the line that contains the error?  I mean I know you said it's line 10, but which line is that?
16:47:48 <julz> oops sorry its this runIt :: [Char] -> [a]
16:48:11 <julz> but the error says Couldn't match expected type `([Char], a)'
16:48:32 <dolio> ddarius: For instance, I can't do 'data Property {n : Nat} : Vec A n -> Set where prop-nil : Property [] ; prop-cons : ...'
16:48:48 <Baughn> SamB: More to the point, if it's evaluating lazily, it might be possible to mount an attack on the PRNG. Depending on exactly what the prime forcer is forcing.
16:49:14 <dolio> ddarius: Instead I need to have 'data Property : Sigma Nat (Vec A) where ...'
16:49:36 <SamB> Baughn: does your interpretation of quantum mechanics involve unsafeInterleaveIO?
16:50:05 <byorgey> julz: does the error say what the 'inferred type' is?
16:50:19 <Baughn> SamB: I consider it a definite possibility, yes
16:50:26 <julz> yes -> against inferred type `[(String, String)]'
16:50:38 <byorgey> julz: aha
16:50:52 <dolio> Which isn't that bad, but using such dependent sums is more noise than you'd have with, say, a GADT in Haskell.
16:51:00 <byorgey> julz: I suspect that you want result (papply code2 x) instead of result [papply code2 x]
16:51:16 <Baughn> SamB: Still, if we have "main = evaluate foo", I need to know what "foo" is
16:51:54 <julz> hm, mybe, this code is from mod-x.xo.uk (kind of hacker game) and you have to fix the code to run it!
16:52:00 <byorgey> julz: the first directly applies the function 'result' to the expression in parentheses, whereas the second wraps up the expression as a list containing a single element
16:52:05 <julz> so I don't know exactly
16:52:11 <byorgey> julz: oh, hehe =)
16:52:50 <julz> but I already tried abd got: Couldn't match expected type `a' (a rigid variable) 	   against inferred type `Char'
16:53:03 <matthew-_> what is the significance of HW2008 being a "symposium"?
16:53:52 <dons> its more important
16:54:28 <roconnor> ``LISP is a (broken) version of the untyped lambda calculus, whereas the universe is apparently written in a typed linear calculus. So the universe is more likely written in Clean than LISP.
16:54:47 <matthew-_> dons: yeah, it's getting printed proceedings now
16:54:54 <darrint> How do I get from take 4 bytestring to an Int32 ?
16:55:16 <roconnor> darrint: big endian or little endian?
16:55:25 <darrint> Let's say big.
16:55:30 <dcoutts_> darrint: shift and .|.
16:55:49 <solrize> http://www.songworm.com/lyrics/songworm-parody/EternalFlame.html
16:55:49 <lambdabot> Title: Lyrics: The Eternal Flame
16:55:50 <roconnor> darrint: I think there is something in Data.Binary
16:55:58 * monochrom wonders if Data.Binary can do that.
16:56:01 <dcoutts_> generally you have no guarantee of alignment so you cannot use peek/poke
16:56:13 <dolio> ddarius: I don't know if that's polymorphism exactly in that example, since Nats are values, but it seems related to Agda's lack of it.
16:56:13 <dcoutts_> yeah, there's code in Data.Binary
16:56:31 <solrize> http://www.prometheus-music.com/audio/eternalflame.mp3
16:56:37 <roconnor> darrint: Data.Binary.decode
16:56:39 <darrint> dcoutts_: shift and .|.? Data.Bits?
16:56:50 <roconnor> ``Values are always encoded in network order (big endian) form
16:57:02 <dcoutts_> darrint: right, check the code in Data.Binary, iirc that's what it does
16:57:15 <dolio> I could be confused, though.
16:57:24 <darrint> roconnor: Yeah. I'm holding out on Data.Binary for a few irrational fears.
16:57:25 <dcoutts_> roconnor: the lower level modules provide both big and little endian
16:57:26 <dons> darrint: the Data.Binary approach is best, mio
16:57:40 <darrint> dons: You are hurting me man. :-)
16:57:50 <monochrom> dons doesn't bite.
16:57:52 <dcoutts_> darrint: we're pretty confident in Data.Binary
16:57:53 <julz> byorgey: what is pasted is already changed by my here is the original one you have to fix: http://hpaste.org/6610 the code should verfiy one password out of 3500
16:58:05 * darrint submits to the powers.
16:58:11 <dons> like i said early, we have industrial experience with it :)
16:58:24 <dcoutts_> darrint: dons, kolmodin and myself wrote it and we have tests etc
16:58:29 * dons wants some  "Industrial Strength Haskell" tshirts
16:58:40 <dons> with big metal lambdas
16:58:55 <monochrom> Haskell is industrial strength glue.
16:58:56 <sethk> dons, iron?  steel?  chromium?
16:59:03 <solrize> i think they would be made out of mu-metal
16:59:06 <darrint> dons: I'd buy the baseball hat.
16:59:08 <dons> some advanced, lightweigth alloy
16:59:10 <dcoutts_> dons: I've ordered a quad-core amd64 btw, so more motivation for parallel builds in Cabal :-)
16:59:15 <monochrom> titanium
16:59:17 <dons> awesome mega fun
16:59:22 <dcoutts_> @yarr!
16:59:22 <lambdabot> Har de har har!
16:59:27 <dons> ?yarr!
16:59:27 <lambdabot> Yo ho ho, and a bottle of rum!
16:59:52 <dons> dcoutts_: http://tinyurl.com/2ks3h9
16:59:55 <dons> glguy spotted this
17:00:09 <dcoutts_> :-)
17:00:26 <dons> personally, i think we should have some pirate mascot
17:00:30 <dons> who claims to use haskell
17:00:36 <sethk> can't spell "the"
17:00:40 <dons> and calls pythonistas scurvy dogs
17:00:54 <sethk> don't all pirates use haskell?
17:01:00 <dons> i'm pretty sure they do
17:01:18 <dons> we've a long cultural association with the pirate community
17:01:20 <dcoutts_> aye, that they do
17:02:04 <Lemmih> dons: OOI, why do you arrive at Hac4 on the 9th?
17:02:21 <dons> Lemmih: i arrive on the 10th?
17:02:46 <dons> but i have to leave on the 9th west coast time, iirc
17:03:02 <dons> ah, mistake on the wiki :)
17:03:18 <dons> Lemmih: i am staying an extra day
17:03:36 <dons> to enjoy sunny gothenburg
17:04:00 <dcoutts_> dons: oh I should do the same, I've not booked transport just yet
17:04:27 <dons> yeah, so i've the monday free
17:04:29 <oklofok> @die 1d2
17:04:29 <lambdabot> 1d2 => 1
17:04:44 <dcoutts_> dons: we can get kolmodin to take us to the funfair :-)
17:04:47 <dons> yay!
17:04:50 <stevan> sunny? it's snowing here. :-p
17:04:55 <dons> stevan: :)
17:05:00 <dons> so i hear.
17:05:01 <solrize> http://upload.wikimedia.org/wikipedia/commons/7/71/Piratey%2C_vector_version.svg
17:05:03 <lambdabot> http://tinyurl.com/2sm6sp
17:05:13 <matthew-_> dons: ok, I've implemented everything I want. I'll write some articles and examples tomorrow. I need sleep right now...
17:05:21 <dons> matthew-_: woot
17:06:26 <matthew-_> dons: I'm rapidly needing to buy a faster CPU - the GHC type checker needs to go faster!
17:06:36 <dons> mmm
17:06:45 <dons> parallel type checking is an interesting problem
17:07:01 <dons> there's that STM-based chameleon type checker
17:07:05 <ddarius> dons: It should be well-explored in the context of logic programming.
17:07:06 <dons> but that's a constraint solver
17:07:07 <sethk> type checking in parallel, or type checking parallel programs?
17:07:11 <matthew-_> or you could use session types...
17:07:21 <dons> ddarius: yeah, not HM-style though
17:07:29 <dons> sethk: former
17:07:37 <dons> since our type programs need more cores
17:07:45 <sethk> k
17:09:08 <Saizan> type-level `par` annotations would be funny :)
17:09:16 <dons> heh
17:09:25 <dons> specifying unification strategies
17:10:03 <julz> had anyone a look at the original I pasted? http://hpaste.org/6610
17:10:09 <solrize> is there cross module type inference??
17:10:49 <solrize> 		    return 'Suc'
17:10:49 <solrize>    looks syntactically wrong
17:10:51 <glguy> if you need multiple cores to typecheck your Haskell program, that might be a signal that your types are a bit too hairy
17:11:08 <dons> what else are you doing with those cores?
17:11:12 <glguy> youtube
17:11:20 <dons> i'd like more cores for the optimiser
17:11:31 <solrize> moar coar !!
17:11:41 <glguy> just running ghc multiple times
17:11:47 <glguy> with some dependency analysis
17:11:49 <julz> solrize yes at http://hpaste.org/6608 you can see mine which is a bit changed
17:12:03 <glguy> would get you 90% of the gains
17:12:09 <dons> glguy: btw, are you going to pitch in on this py bridge entry?
17:12:19 <glguy> "pitch in"?
17:12:21 <dons> there's been lots of interest.
17:12:27 <dons> comment, suggest, propose mentoring...
17:12:32 <dons> help?
17:12:35 <julz> it's a game to fix the code
17:12:43 <solrize> is there some reason to not use Data.Dynamic for that?
17:12:49 <idnar> py bridge?
17:12:54 <glguy> I'm not an expert, but I can answer initial questions if needed
17:13:02 <solrize> idnar someone has a soc proposal to make a python to haskell ffi bridge
17:13:03 <glguy> for haskellistas?
17:13:11 <idnar> solrize: where?
17:13:14 <julz> hm, as I don't know much about haskell - I don't know
17:13:20 <solrize> i saw it on usenet, dunno where else it is
17:13:24 <dons> http://hackage.haskell.org/trac/summer-of-code/ticket/1547
17:13:26 <lambdabot> Title: #1547 (FFI bridge to Python) - Haskell.org Google Summer of Code - Trac
17:13:38 <dons> i think that's got a good chance of being accepted on the python side, too
17:14:30 <darrint> What are the setup.lhs flags for installing into $home?
17:14:50 <ddarius> dons: But the existence of Haskell means there's more than one way to write a program!
17:14:56 <solrize> there was something else i saw about it
17:15:29 <dons> glguy: maybe we can get yav's feedback on things that we shouldn't try to do
17:15:43 <dons> darrint: --prefix=$HOME --user
17:15:46 <yav> what are you trying to do?
17:15:48 <darrint> thx
17:15:50 <glguy> dons: yeah, he is pretty negative
17:15:53 <dons> yav, python bridge.
17:16:01 <glguy> he could cut the list down
17:16:13 <solrize> bah can't find it now
17:16:35 <yav> but glguy did quite a bit of one already?
17:16:37 <solrize> anyway i'm interested in it and might be able to help a little on the python side, i'm still too lame on the haskell side
17:16:37 <yav> what's the problem
17:16:45 <glguy> "quite a bit" "just enough"
17:16:48 <glguy> "some"
17:16:48 <dons> its a good start.
17:17:00 <glguy> I think there is probably a better more general approach
17:17:06 <glguy> than what I did
17:17:10 <dons> ideally we'd have a c2hs/greencard-ish thing that was generally useful
17:17:33 <dons> and support libraries under Foreign.Python
17:18:34 <solrize> http://tsk.ch.uj.edu.pl/~janeczek/socapp.html
17:18:35 <lambdabot> Title:
17:19:15 <solrize> for some reason it doesn't seem to be on google groups
17:19:58 <solrize> http://hpaste.org/6612  blurb from soc app
17:20:09 <dons> glguy: re. mutable, imperative programming, you could steal some ideas from http://hackage.haskell.org/packages/archive/ArrayRef/0.1.2/doc/html/Data-SyntaxSugar.html
17:20:21 <lambdabot> http://tinyurl.com/36vmkt
17:20:31 <dons> if imperative programming is more of a pain than it needs to be, we can solve that.
17:20:37 <dcoutts_> dons: c2hs needs some love, beyond the C parser bits
17:20:53 <dons> yep
17:20:55 <solrize> did you see augustss's thing about a c-like dsl inside haskell ?
17:20:56 <glguy> dons: I addressed my memoization needs with ST and higher order functions to abstract out a little
17:21:01 <dons> nice
17:21:07 <dons> solrize: yeah, scary
17:21:12 <solrize> haha
17:21:15 <dons> a functional black pearl
17:21:33 <solrize> lol
17:21:39 <sethk> is that something that exists, or just an idea?
17:21:40 <solrize> hadn't heard that expression befoer
17:21:45 <dcoutts_> dons: it could (and imho should) be the standard ffi generator because it is much more featureful and provides cross-language safety guarantees.
17:21:53 <solrize> sethk http://augustss.blogspot.com/2007/08/programming-in-c-ummm-haskell-heres.html
17:21:54 <lambdabot> Title: Things that amuse me, http://tinyurl.com/2948p6
17:22:10 <dons> solrize: i think a "black pearls" would be quite a nice category for these evil programs
17:22:16 <dons> the antithesis of the functional pearl
17:22:18 <solrize> black swan
17:22:31 <dons> do you know of these famous "functional pearls"?
17:22:47 <dons> http://haskell.org/haskellwiki/Research_papers/Functional_pearls
17:22:47 <solrize> i think i've seen some of them.  i remember bentley's book "programming pearls"
17:22:49 <lambdabot> Title: Research papers/Functional pearls - HaskellWiki
17:22:50 <solrize> yeah
17:22:55 <dons> lovely beautiful functional programs
17:23:08 <dons> unlike augustss lovely, evil anti-functional programs :)
17:23:18 <solrize> yeah i think i saw that page a while back, i should look at them again i can probably make more sense of them now
17:23:30 <sethk> every time I get on here I find six months worth of reading I should do.  Unfortunately I have to spend most of the day working ...
17:23:39 <solrize> sethk hehe welcome to the club
17:23:40 <monochrom> The best imperative programs are written with functional programming.
17:23:45 <dons> :)
17:23:55 <monochrom> (There is the coverse, too.)
17:24:50 <glguy> Ah #haskell, home of the objective impartial discussion ;)
17:24:51 <monochrom> (Inspired by Knuth's: The best practice is inspired by theory; The best theory is inspired by practice.)
17:25:05 <sethk> monochrom, you mean the best functional programs are written with imperative programming?
17:25:13 <monochrom> Yes.
17:25:30 <sethk> hmm ...
17:25:43 <sethk> I think I hold off on believing that for a bit
17:26:17 <solrize> someone posted a url here yesterday about dependently typed assembly code
17:26:19 <monochrom> It is easier to calculate lazy timing in imperative programming. (No I/O of course, just state.)
17:26:44 <solrize>  http://sneezy.cs.nott.ac.uk/fplunch/weblog/?p=71#more-71
17:26:45 <lambdabot> Title: FP Lunch  Blog Archive  Proof by Smugness
17:27:05 <dons> glguy: don't lose all hope!
17:27:39 <monochrom> So, suppose you have some haskell lazy code.  Assuming you just use first-order functions, the best way to predict its timing is to translate to imperative programming, then calculate timing there.
17:28:36 <dons> monochrom: you mean, pick an evaluation order?
17:29:19 <monochrom> Not really.
17:30:57 <marshmallows> Hi
17:31:02 <Cale> If you're using lazy evaluation, expressions are just evaluated outermost first.
17:31:18 <Cale> (with sharing, of course)
17:31:34 <marshmallows> I have a question about lazyness in Curry (not Haskell).. is it ok to ask here?
17:31:50 <Cale> marshmallows: sure, possibly someone knows :)
17:31:56 <marshmallows> ok thank you,
17:32:28 <dons> huh, did you know the 'annotated xmonad project' http://code.google.com/p/annotatexmonad/ existed?
17:32:29 <lambdabot> Title: annotatexmonad - Google Code
17:32:32 <Excedrin> what is a "first order imperative program" ?
17:32:35 <dons> "The aim is to thoroughly annotate a recent version of xmonad code, learning Haskell in the process."
17:32:41 <marshmallows> What is the point in lazyness in Curry (functional logic language), since it has to check every unification succeeds it doesn't seem like there is any benefit
17:33:38 <Cale> marshmallows: But how much evaluation does it need to do to check that the unification succeeds?
17:33:52 <sethk> marshmallows, it doesn't evaluate code paths that aren't traversed, for one thing
17:33:52 <dons> outermost constructors?
17:34:10 <dons> i could imagine that pattern matching just has to flow both ways :)
17:35:41 <ddarius> Laziness in Curry supports a test-and-generate style (as opposed to the usual generate-and-test style)
17:35:49 <Cale> marshmallows: If you're unifying something with a variable, you don't need to evaluate it.
17:36:31 <sethk> ddarius, what does that mean?
17:36:44 <Cale> If you're unifying it with a constructor, then you need to check that the constructor matches, just as usual.
17:36:57 <Cale> So that requires an evaluation to WHNF.
17:38:06 <marshmallows> What if I have X = id 1, Y = id 2,  X = Y, but my query does not depend on X or Y
17:38:22 <glguy> lol, my credit card company sent me a notice that I can earn points faster by adding an authorized user to my account and having that person spend money too
17:38:23 <marshmallows> it seems like even though there is a unification failure.. my query could succeed
17:38:34 <glguy> brilliant!
17:38:40 <glguy> who's in?
17:39:00 <glguy> no one? ok, nvm then
17:39:02 <dobblego> not me, I want more points than you!
17:39:03 <drFetch> well the dollar is an at an all time low
17:39:26 <lament> isn't it always
17:39:27 <darrint> Is there an example online showing the Data.Binary get monad?
17:39:36 <marshmallows> did what I just said make sense?
17:39:40 <drFetch> so it would be a good time to go on a shopping spree in america
17:40:01 <glguy> with my devalued american dollars?
17:40:01 <marshmallows> so probably it has to find the WHNF of every unified terms?
17:40:03 <mofmo1> so i have a monad that passes around a record
17:40:07 <sethk> drFetch, if you are coming to New York, we have a number of bridges that are attractively priced
17:40:09 <mofmo1> a state monad
17:40:23 <mofmo1> so i have a function that extracts a part of that record but i dont actually know how to write it
17:40:33 <drFetch> with my revalued euros :D
17:40:40 <mofmo1> getLoc = do { a <- get; ?? }
17:41:17 <drFetch> wait no, not revalued ... it just occured that's not *really* the opposite of devalue because it supposed a devaluation took place first
17:42:03 <sethk> drFetch, nobody should actually be changing money these days.  Much cheaper to use a credit card and let the bank handle it.
17:42:05 <audreyt> mofmo1: a <- gets labelName
17:42:17 <drFetch> true
17:42:33 <mofmo1> ah
17:42:46 <mofmo1> there aren't very many good resources on records =/
17:43:07 <audreyt> or, more verbosely: do { a <- get; return (labelName a) }
17:43:10 <dons> mofmo1: so record labels are the functions that extract part of a record
17:43:14 <drFetch> mofmo1: there aren't very many good resources on anything that's not advanced
17:43:15 <dons> yo, audreyt !
17:43:19 <audreyt> greetings :)
17:43:22 <dons> :D
17:43:25 * dons does happy dance
17:43:48 <dons> audreyt: i saw a couple of flippi releases, do you have a repo somewhere?
17:44:01 <drFetch> mofmo1: i'm guessing that after a while you make the "click" and suddenly you start to understand the documentation and start learning 3000% faster
17:44:27 <audreyt> dons: not atm. what does it take to create a darcs.haskell.org repo for it?
17:44:40 <drFetch> or you give up before that ... i dunno, it hasn't happened here :D just bookmark any example code you can find and have a pet project
17:45:08 <mofmo1> drFetch: my project is writing an interpreter for an imperative language right now
17:45:09 <dons> audreyt: so most projects are now hosted on code.haskell.org
17:45:13 <dcoutts_> audreyt: get one on community.haskell.org
17:45:22 <dons> audreyt: and you create a project account on community.haskell.org, as dcoutts_ says
17:45:26 <drFetch> mofmo1: i'm doing an IRC server :D
17:45:31 <mofmo1> it has the expressive power of asm and none of the actual power ...
17:45:33 <dons> perfect place for flippi
17:45:33 <Cale> mofmo1: You could also just use something like   do x <- get; case x of Foo { labelName = y } -> return y
17:45:44 <dons> audreyt: would love to hear about what you're up to at some point, too :)
17:45:50 <dcoutts_> audreyt: no new accounts or projects on darcs.haskell.org but {community,code}.haskell.org is for everyone
17:45:52 <Cale> mofmo1: or,  do x <- get; return (labelName x)
17:46:09 <audreyt> dons: I'm unfortunately too busy commercializing haskell applications lately :)
17:46:11 <mofmo1> there really needs to be a haskell in a nutshell book stat
17:46:21 <mofmo1> i find i learn better through books rather than online material for some reason
17:46:36 <dcoutts_> audreyt: oh yes, anything you can tell us about?
17:46:50 <audreyt> mofmo1: "Programming in Haskell", then "Real World Haskell"
17:46:55 <marshmallows> mofmoi: There are lots of books about Haskell
17:46:57 <audreyt> (the latter requires a time machine)
17:47:07 <mofmo1> marshmallows: not really many reference books are there?
17:47:11 <mofmo1> audreyt: is RWH out yet?
17:47:16 <mofmo1> ive been waiting for it
17:47:20 <marshmallows> mofmoi: There is at least one
17:47:29 <audreyt> mofmo1: no, but you can sign up for preview chapters
17:47:31 <dcoutts_> mofmo1: not yet, that's what audreyt meant about needing a time machine :-)
17:47:45 <dons> mofmo1: getting closer!
17:47:56 <audreyt> a simple time machine, like "sleep 10000000", will do
17:47:58 <gnuvince_> audreyt!
17:48:02 <dons> :)
17:48:16 <dons> commericalising haskell applications. that's what i like to hear!
17:48:16 <gnuvince_> it's been a long time we've seen you.  Are you recovering OK?
17:48:32 <koninkje> is anyone up for some rank-2 polymorphism / type inference questions?
17:48:36 <sethk> dcoutts_, what does that mean, exactly?  just an early read?
17:48:45 <audreyt> dcoutts_: nothing earth-shattering, half of it revolves around http://svn.openfoundry.org/openafp/
17:48:46 <marshmallows> koninkje: Ye
17:48:47 <marshmallows> s
17:48:47 <lambdabot> Title: Revision 75: /
17:49:03 <audreyt> which is happily Data.Binary/LazyByteString/Mmapified now
17:49:05 <monochrom> sleep 10000000 is about 116 days.
17:49:11 <sethk> dons, I'm working on another commercial app as we speak
17:49:21 <audreyt> which means it's fast. still need to conver the other half to Parsec3
17:49:23 <sethk> dons, last year's has had zero defect reports in nine months
17:49:29 <monochrom> Somehow I don't think 116 days is long enough.
17:49:49 <audreyt> well then just run the time machine again!
17:50:10 <dcoutts_> audreyt: btw, do make sure you report Cabal bugs and limitations in the trac, otherwise we never know you're having problems :-) I discovered several workarounds in pugs for limitations that had never been reported.
17:50:17 <audreyt> gnuvince_: I'm recovering okay, though still merely a shadow of my former self :)
17:50:40 <koninkje> marshmallows: http://hpaste.org/6613
17:50:47 <audreyt> dcoutts_: noted. when I get a round tuit...
17:51:04 <gnuvince_> audreyt: that's good to hear (about the recovery), and the former self will surely come back with time :)
17:51:23 <koninkje> It works fine in Hugs, but GHCi doesn't seem to like the let-in in `runEM`
17:51:34 <drFetch> quick question: in everyday english you would never say that you "Post a Reply" to a discussion, but what would you say?
17:51:43 <audreyt> "reply"
17:51:45 <koninkje> I'm not sure if it's a rank-2 issue, or an inference issue
17:52:08 <dcoutts_> audreyt: eg I note several changes I'd make in OpenAFP.cabal :-)
17:52:43 <drFetch> audreyt: hmmm, but reply with what?
17:52:47 <dons> sethk: wow
17:52:50 <audreyt> dcoutts_: ooh :) patches (or pointers (stables ones preferred)) to audreyt@audreyt.org
17:52:54 <monochrom> "post a reply" is not everyday english?
17:52:56 <dons> sethk: we should really get you along to CUFP this year
17:53:03 <sethk> dons, when is it?
17:53:19 <dons> September.
17:53:23 <dons> cufp.galois.com
17:53:30 <sethk> dons, I should be able to do it this year.
17:53:32 <dons> experience reports are *very* welcome
17:53:34 <dcoutts_> audreyt: easy way is to build & sdist with the latest Cabal, it'll give you several QA warnings
17:53:38 <dons> its in victora, too
17:53:42 <dons> so a bit easier to get to
17:53:51 <drFetch> monochrom: i dunno, i notice i'm being anal about my data constructors tonight
17:54:00 <sethk> dons, I've been doing contracting for years and years, but I finally accepted a permanent, which means I actually have vacations.  Plus they might even pay.
17:54:04 <monochrom> I say "post a reply" in everyday Chinese all the time.  Maybe you need to learn a better everyday language.
17:54:08 <gweiqi> so, how do i make this do what I mean without the ghc extensions?: data Tree m a = Empty | Branch (m a) (m a) deriving (Show, Eq) -- I'm getting the error, No instance for (Show (m a))
17:54:32 <audreyt> dcoutts_: k. I actually have a latest cabal... I'll give it a try after this imminent $demo_of_haskell_app_to_client
17:54:32 <adu> I think I just invented som really cool parser combinators
17:54:38 <audreyt> bbiab # back to Keynote.app
17:55:01 <sethk> dons, I can also talk about resistance to using Haskell and how to (at least sometimes) overcome it.
17:55:08 <glguy> PATA PATA PATA PON!
17:55:10 <dons> yep, that's exactly what is useful
17:55:11 * adu loves demoing things
17:55:11 <Beelsebob> gweiqi: well, yes, in general there's no way to Show a monad
17:55:27 <dcoutts_> audreyt: and I wonder why you put all the standard include and library search paths in the .cabal file, is that due to some other missing Cabal feature? (no need to reply now, tell me later)
17:55:31 <dons> audreyt: let us know if you need help, advice, moral support
17:55:35 <Beelsebob> so how is it going to display your Branch (??? a) (??? a)
17:56:06 <adu> sethk: I think the easiest way to learn Haskell is to learn ML first, then category theory, then Helium, then Haskell
17:56:06 <dons> dcoutts_: want to push through audreyt's ticket for c.h.o?
17:56:08 <gweiqi> Beelsebob: well, I was assuming that the m i would be providing would itself be a polymorphic type deriving Show
17:56:08 <audreyt> dons: I need to procure Chinese translation rights of RWH so I can train more Haskell minions :)
17:56:20 <dons> mmm. now that's an interesting idea.
17:56:46 <adu> Haskell minions?
17:56:47 <koninkje> marshmallows: any thoughts?
17:56:51 <monochrom> I think targetting Africans is more successful.
17:57:08 <marshmallows> I don't know how to sort that, sorry
17:57:14 <Beelsebob> gweiqi: yeh, but the compiler has no way to know that... what you want is something like data Tree m a = ... instance (Show m, Show a) => Show Tree m a where ...
17:57:22 <Beelsebob> I don't think there's a way to derive that
17:57:29 <adu> am I a Haskell minion?
17:57:30 <dons> audreyt: btw, if you're ever in portland, or, drop by galois :)
17:57:52 <gweiqi> Beelsebob: ahh, i see... so are you familiar with why turning on the ghc extensions makes it compile?
17:57:56 <SamB> dons: that looks really funny
17:58:07 <dons> SamB: OR ?
17:58:12 <SamB> because that "or" is indistinguishable from the word or
17:58:14 <Beelsebob> gweiqi: no, I'm afraid I do my best to avoid ghc extensions
17:58:24 * dons practices american conventions some
17:58:30 <adu> SamB: unless its capitalized "OR"
17:58:31 <gweiqi> Beelsebob: me too, that's why i was wondering what magic it's doing
17:58:33 <dcoutts_> dons, audreyt: done. audreyt's community.h.o account created.
17:58:37 <dons> sethk: feel free to add details or our growing http://haskell.org/haskellwiki/Haskell_in_industry
17:58:38 <lambdabot> Title: Haskell in industry - HaskellWiki
17:58:39 <monochrom> I'm speaking as a Chinese purporting to understand Chinese people.  Generally we are more interested in profitability, especially short-term profitability.  If you talk to us about Haskell, we ask, "is it used in industry? I hear python and php and c# make more money."  Then you have an uphill battle to fight.
17:58:40 <dons> dcoutts++ woot
17:59:12 <Beelsebob> gweiqi: fraid I'm not your man then :
17:59:13 <Beelsebob> :(
17:59:19 <SamB> dons: if I didn't know that there was a place called "Portland, OR", I'd still be confused ;-)
17:59:25 <dons> monochrom: interesting. how about, shorter code, faster development times, less defects == less chance of failure?
17:59:34 <sethk> monochrom, indeed, true, but you can make the economic case in terms of total life cycle costs and in some cases prevail
17:59:53 <monochrom> We ask "how many jobs are there".  All else we consider just a lot of hot air.
18:00:24 <dcoutts_> or in terms of working smarter than the competition
18:00:36 <monochrom> Be assured that when Haskell represents more than 30% of the jobs, we'll be all over it.
18:00:36 <dons> do you think that's a fairly risk averse, or conservative, view of investment?
18:00:50 <dons> i wonder how startups begin in a climate like that
18:00:51 <Beelsebob> dons: fewer defects </grammar nazi>
18:00:58 <dons> thank you Beelsebob  :)
18:01:32 <SamB> monochrom: what if it only represents the top 10% of the jobs?
18:01:34 <monochrom> Of course, in very culture, there is about 0.001% of the people who will adopt fringe technologies for venture.
18:01:41 <adu> Haskell == more money
18:01:48 <gweiqi> Beelsebob: I was thinking something like this would help, but it seems to then think that m is applied to too many type arguments: data (Show m) => Tree m a = Empty | Branch (m a) (m a) deriving (Show, Eq)
18:02:00 <dons> managing risk is a key part of encouraging haskell adoption
18:02:14 <dons> we should have a clear narrative of how to go about mitigating risk
18:02:19 <Beelsebob> gweiqi: I don't think sticking the Show m in there is valid syntax
18:02:24 <sethk> dons, I'm working in a startup.  Startups are a good place to expand use of haskell because if you produce something that works well, people think you wrote it in a weird language but they're too busy to care.
18:02:25 <Beelsebob> I would expect it to be though
18:02:39 <dons> sethk: :)
18:02:42 <Beelsebob> sethk: what startup are you working at?
18:02:46 <sethk> dons, the risk that I hear most often is "what if you get hit by a bus?"
18:02:46 <Botje> gweiqi: are you sure you don't mean Branch (Tree m a) (Tree m a) ?
18:02:55 <sethk> Beelsebob, bug labs (buglabs.net)
18:03:10 <Beelsebob> ah, okay
18:03:20 <Beelsebob> I'd wondered if it had happened to be Anygma
18:03:22 <SamB> sethk: you develop ... bugs?
18:03:28 <SamB> that doesn't sound very useful
18:03:45 <Beelsebob> depends on the bug
18:03:45 <sethk> SamB, well, not exactly.  Look at the site.  :)
18:03:45 <Beelsebob> I could do with a decent collectino of them
18:03:45 <sethk> Beelsebob, :)
18:03:45 <gnuvince_> sethk: that sounds like my experience: although not with Haskell, I was able to use a (at the time) unknown technology in my company
18:03:45 <dons> sethk: i'm encouraged by the size of the community
18:03:45 <gweiqi> Botje: I'm actually not interested in trees at all, I just wrote a crappy example to demonstrate my problem
18:03:58 <dons> i think now its getting a lot easier to find competent FP people
18:04:04 <sethk> dons, as am I, and there have been major successes.
18:04:14 <sethk> dons, but it's not widely known.
18:04:28 <dons> sethk: this is exactly the kind of thing we'd like to hear about at CUFP btw
18:04:31 <sethk> dons, that is, the wider availability is not widely known
18:04:32 <dons> yep
18:04:34 <sethk> dons, ok
18:04:38 * Beelsebob goes back to failing to write a PhD
18:04:44 <gweiqi> Botje: it might as well be: data Thing m a = NoThing | Stuff (m a) deriving (Show, Eq)
18:04:55 <dons> sethk: should we add buglabs to the haskell in industry page? ...
18:05:16 <Botje> okay then :)
18:05:27 <jsedgwick> why am i getting a type error here? http://hpaste.org/6614
18:05:29 <sethk> dons, absolutely.
18:05:33 <darrint> When using Data.Binary Couldn't match expected type `B.ByteString' against inferred type `Data.ByteString.Internal.ByteString'
18:05:35 <dons> woot
18:05:51 <dcoutts_> darrint: Data.ByteString.Lazy
18:06:05 <darrint> already have import qualified Data.ByteString.Lazy as B
18:06:15 <Botje> jsedgwick: try print sum ... instead
18:06:23 <roconnor> dons has forgotten about failure at all costs.
18:06:33 <dons> success at all costs!
18:06:34 <monochrom> haha
18:06:36 <Twey> sethk: That's pretty awesome :-D
18:06:39 <dcoutts_> darrint: well check what it is that's using a strict ByteString
18:06:45 <dons> programming doesn't have to suck!
18:06:50 <Jedai> gweiqi: The GHC extension probably relax the rules about the head of an instance
18:07:29 <gweiqi> Jedai: So do you know what I can do to express a similar intent without the extensions?
18:07:47 <gwern> hm. I've been away for a while. Wonder what interesting things have happened in mine absence in haskell-land?
18:07:54 <darrint> Hmm. My only use of that namespace is: contents <- B.hGetContents handle, where handle is the result of "accept".
18:07:55 <Jedai> gweiqi: I mean when you have an instance like instance (Bar a, Foo a, ...) => MyClass a where ..., there's rule on what can be in the parenthesis
18:08:04 <dons> sethk: i added a link to http://haskell.org/haskellwiki/Haskell_in_industry
18:08:05 <lambdabot> Title: Haskell in industry - HaskellWiki
18:08:11 <sethk> dons, thanks
18:08:13 <dons> sethk: if you want to expand on the specifics, that'd be great
18:08:16 <dons> or i can
18:08:18 <jsedgwick> Botje: thanks. that works. may i ask why that's necessary?
18:08:28 * dons is happy to see how that list is growing weekly 
18:08:36 <Jedai> gweiqi: And certain extensions of GHC relax those rules (but the type system may become undecidable in certain cases)
18:09:08 <Cale> jsedgwick: the sum is not an IO action
18:09:16 <Cale> jsedgwick: It's just a number
18:09:17 <Jedai> gweiqi: You can't, to the best of my knowledge (a real case would help)
18:09:21 <gweiqi> Jedai: I see, so due to the relaxation it can figure out how to derive instances for Show?
18:09:39 <Cale> jsedgwick: In a do-block all the lines have to consist of actions in the same monad, in your case, the IO monad.
18:09:59 <Jedai> gweiqi: It is only a guess (but that seems reasonable, the rules are pretty stricts)
18:10:12 <Cale> jsedgwick: So you use the print function which takes something show-able and prints it to the screen.
18:10:24 <jsedgwick> Cale: thanks
18:10:43 <sethk> dons, I'll do it.  After all, I know the specifics  :)
18:10:52 <Cale> (well, really it takes something show-able and produces an action which when run will print it to the screen, but you get the idea :)
18:11:03 <glen_quagmire> how do you debug when you're stuck?
18:11:04 <dons> sethk: cheers!
18:11:12 <Cale> glen_quagmire: stuck?
18:11:46 <glen_quagmire> i'm writing an interpreter..but it seems i'm not handling environment properly
18:11:59 <glen_quagmire> i mean, i can't narrow it down and write a testcase
18:12:01 <Cale> okay
18:12:02 <gweiqi> Jedai: here's the real example: http://hpaste.org/6615
18:12:19 <glen_quagmire> @google haskell step debugger
18:12:20 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-debugger.html
18:12:20 <lambdabot> Title: 3.5. The GHCi Debugger
18:12:23 <dcoutts_> darrint: I'm sure you're not importing and using it yourself directly, just look at where the type error is, it'll be some function that uses a strict ByteString where you were expecting a lazy one
18:12:28 <Cale> glen_quagmire: Well, there's the debugger.
18:12:41 <Cale> (hope you have ghc 6.8)
18:12:52 <Jedai> gweiqi: Now that I think about it, it may be even simpler, it may be just that you can't do instance for type constructors in Haskell98.
18:12:59 <glen_quagmire> yes!
18:13:35 <Jedai> gweiqi: In this case, using this particular extensions shouldn't be a problem, all Haskell compilers implement it
18:13:58 <sethk> I've been asking for a debugger for years, but I haven't even tried it yet.  I guess I developed alternative strategies
18:14:53 <Cale> glen_quagmire: The most common thing is to try and refactor the code into simpler parts which are easier to check the correctness separately. This can be hard, but is great when it can be done.
18:14:53 <gweiqi> Jedai: is there a way to specify this extension in a compiler-independent way?
18:15:07 <darrint> dcoutts_: I almost figured it out. :t hGetContents returns type D.B.Lazy.Internal.ByteString.
18:15:13 <Cale> s/check the correctness/check for correctness/
18:15:20 <aFlag> hello. Is there some library that implements a p2p protocol -- like chord -- for haskell?
18:15:34 <Cale> aFlag: There was a bittorrent client, iirc.
18:15:49 <Jedai> gweiqi: In theory, you could use the LANGUAGE pragma (that should be implemented in all Haskell compiler in the future anyway)
18:16:10 <Jedai> gweiqi: Have you determined which extension is necessary ?
18:16:10 <dons> sethk: we do have a nice debugger now, yes :)
18:16:19 <dons> but not enough bugs to use on it
18:16:31 <sethk> dons, well, I'm pretty good at creating bugs.  :)
18:16:40 <gweiqi> Jedai: not at all, I just slapped {-# OPTIONS -fglasgow-exts #-} at the top of the file like a miracle cure-all
18:16:42 <Excedrin> aFlag: there's this http://sep07.mroot.net/
18:16:43 <lambdabot> Title: Home || Softwareentwicklungspraktikum 2007 – Ad-Hoc-Chatsystem - Gruppe 2
18:16:58 <dons> sethk: that's a special talent :)
18:17:04 <Cale> glen_quagmire: It can also sometimes help to use Debug.Trace, which lets you insert annotations which will be printed when a certain expression gets evaluated.
18:17:18 <gweiqi> jsedgwick: are you a go player?
18:17:32 <aFlag> Excedrin, is there an english version of it?
18:17:33 * Corun heard go mentioned
18:17:39 * Corun plays go, ish...
18:17:42 * Cale plays go.
18:17:44 <Excedrin> aFlag: unsure
18:18:00 <Jedai> gweiqi: The piece of code you hpasted compile without extensions by the way, at least on my ghc
18:18:00 <gweiqi> haha
18:18:04 <dons> Cale, did you know SimonM and John Launchbury are serious Go-heads?
18:18:18 * monochrom plays Chinese Chess.
18:18:21 <gweiqi> Jedai: hmm, i'm using version 6.6.1, i wonder if that makes a diff?
18:18:29 <dons> Cale: the office here has guitar hero and Go. :)
18:18:35 <Cale> dons: I didn't know that, but it doesn't particularly surprise me, since lots of Haskell programmers seem to like it :)
18:18:39 <dons> yeah
18:18:45 <Corun> That's cos it's awesome :-)
18:18:48 <Cale> dons: You should learn :) I'd be happy to give teaching games.
18:18:54 <gweiqi> as in a Go board? I wouldn't normally hear Go associated with guitar hero
18:19:12 <Jedai> gweiqi: Probably (I use 6.8.2), but that means the extension is really small, I'll check if I can find the corresponding LANGUAGE pragma
18:19:23 <dons> i've even got a board. my girlfriend was into it a while ago
18:19:29 <Cale> I much prefer to play in real life, and all my go-playing friends have moved away, so I don't get so many games.
18:19:33 <jsedgwick> gweiqi: nope
18:19:55 <gweiqi> jsedgwick: ahh, that's too bad... your name reminded me of "James Sedgwick" who is a Canadian 6 dan that I know of
18:19:58 * monochrom goes to modify the haskell wiki.  "Haskell is an advanced programming language for Go players. Backed by 20 years of Go playing."
18:19:58 <Cale> Online can be good for teaching though, especially if you play on KGS, since it has a nice game-tree.
18:20:11 <dons> monochrom: :D
18:20:16 <Corun> There's nothing quite like placing a real go stone and then going "oh shit, now I see it, I'm crap at tsumego"
18:20:28 * dons still  likes the new sogan
18:20:28 <jsedgwick> gweiqi: well that's my name, but not me.
18:20:31 <dons> slogan.
18:20:31 <Cale> A programming language whose semantics were defined by the values of go-games would be awesome.
18:20:50 <Cale> You have to solve life-and-death problems to determine the meaning of a bit of code :)
18:20:58 <Corun> Hefty
18:20:58 <gwern> Cale: that'd be a surreal programming language
18:21:30 <Corun> The question is, how many people started playing go having watched hikaru no go :-P
18:21:33 <gweiqi> Cale: yeah, i use kgs
18:21:48 <Cale> Corun: I started watching HnG having played go :)
18:21:52 <gwern> Corun: I did :)
18:22:06 <Corun> I knew it :-)
18:22:09 <Cale> The only other anime that I've really watched is Evangelion.
18:22:21 <Cale> (which I watched after)
18:22:26 <monochrom> Is HnG that one about that kid who met a Go expert ghost?
18:22:31 <Cale> yes
18:22:41 <monochrom> I love it too. :)
18:22:48 <Corun> Hehe.
18:22:56 <gwern> Cale: what an unfortunate pick to watch after a light-hearted game anime
18:23:01 <Cale> The ghost of Honinbo Shusaku
18:23:07 <Corun> I'd suggest watching Death Note, if you were going to watch another anime, Cale.
18:23:23 * gwern sort of hopes Cale didn't watch End of Evangelion as well
18:23:24 <Corun> (But please god watch it with subtitles, the dubbed version is horrific)
18:23:34 <Cale> gwern: I enjoyed it quite a lot, both endings.
18:24:04 <darrint> Ok. Is this a ghc library bug? Data.ByteString.hGetContents :: GHC.IOBase.Handle -> IO Data.ByteString.Internal.ByteString
18:24:14 <gwern> Cale: madness! the two endings are the most polarizing issues in Eva fandom, rihgt up there with rei v asuka
18:24:30 <monochrom> That is not a bug.
18:24:53 <Cale> Corun: Yes, I hate dubs. I understand just a little bit of Japanese anyway and so I prefer to hear it as well.
18:24:55 <dcoutts_> darrint: what makes you suspect it's a bug?
18:25:01 <monochrom> Cale is an intelligent man.  Can like both extremes.
18:25:27 <darrint> dcoutts_: I can't pass the resulting bytestring to other functions like Data.Binary.decode.
18:25:43 <dcoutts_> darrint: that's because they all expect lazy bytestrings
18:25:59 <dcoutts_> darrint: you want to be using lazy bytestring throughout
18:26:11 <darrint> dcoutts_: Ok. But there's no indication in the docs that hGetContents returns anything but a lazy bytestring. It's italicized even.
18:26:31 <dcoutts_> Data.ByteString.Lazy.hGetContents does return a lazy bytestring
18:26:43 <dcoutts_> just as Data.ByteString.hGetContents returns a strict one
18:27:18 <dcoutts_> darrint: are you sure you're importing the right one?
18:27:22 <monochrom> Too many hGetContents's :)
18:27:44 <monochrom> Every function is called "f". :)
18:28:50 <Jedai> gweiqi: Try adding {-# LANGUAGE FlexibleContexts #-} at the start of your file
18:28:51 <darrint> dcoutts_: I've imported both and get slightly similar results. From my limited perspective it looks like the typechecker is trapped on the "Interanal" part of the type.
18:29:01 <darrint> That's Internal.
18:29:14 <dcoutts_> darrint: that's got nothing to do with it, the type checker is correct
18:29:36 <dcoutts_> darrint: it's just that the types are actually defined in the .Internal modules and re-exported through the other modules
18:29:52 <dcoutts_> so that's why the type checker reports a name that includes .Internal
18:30:10 <dcoutts_> darrint: if you look at the type error you'll notice it's saying that you cannot mix strict and lazy bytestring types
18:30:25 <gweiqi> Jedai: cool, that worked
18:30:37 <gweiqi> Jedai: so this is a compiler-independent extension?
18:31:03 <Jedai> gweiqi: That allows you to write instance (Show (v s) => Show (Kinematic v s) where...
18:31:23 <gweiqi> Jedai: btw, this hasn't come up yet, but what's the proper syntax for specifying multiple extensions for a file?
18:31:35 <Jedai> gweiqi: Will be (the committee for Haskell Prime will approve this)
18:31:41 <darrint> dcoutts_: Ok. So it's neither of these. Looks like my use of the magic Data.Binary monad must be what's adding in the strictness.
18:31:58 <Jedai> gweiqi: {-# LANGUAGE FlexibleContexts, NoMonomorphismRestriction #-}
18:32:04 <gweiqi> Jedai: thanks!
18:32:07 <dcoutts_> darrint: Data.Binary's get and put functions use lazy bytestring
18:32:37 <gweiqi> Jedai: i don't suppose the no monomorphism restriction is also going to become standard, btw?
18:32:55 <Jedai> gweiqi: Kinda a bug that ghc 6.8 seems to be able to do it implicitly without the extension (but explicitly not)
18:33:04 <darrint> dcoutts_: Found it! getBytes.
18:33:19 <Jedai> gweiqi: Oh no ! I don't think so, too controversial
18:33:39 <dcoutts_> darrint: well done
18:33:40 <Jedai> gweiqi: But I'm not in the committee ^^
18:33:40 <gweiqi> Jedai: that's what i figured, oh well
18:34:04 <dcoutts_> darrint: presumably it was on the line that the error message suggested?
18:34:24 <darrint> dcoutts_: No. I'm not _quite_ that dumb. :-)
18:34:48 <dcoutts_> darrint: the usual strategy for mysterious type errors is to annotate the type that you think the expression is until you find where you and the compiler disagree
18:34:56 <monochrom> I'm dumber than a computer.
18:35:01 * dcoutts_ too
18:35:25 <roconnor> monochrome fails the Turing test.
18:35:46 <monochrom> Yeah, I'm literally a Chinese Room guy. :)
18:36:09 <darrint> The error message was one line away. Completely acquitting me.
18:36:44 <SamB> was the error mmessage at least on the *previous* line, rather than the next one as is typical?
18:37:08 <darrint> Next line this time.
18:44:27 <darrint> yay for Data.Binary's getLazyByteString :-/
18:47:51 <Cale> I really think the Monomorphism Restriction should be dropped simply because it's the only thing in the Report which is tied to a particular evaluation model of Haskell.
18:48:03 <Cale> The Report is supposed to be evaluation-model agnostic.
18:51:44 <Jedai> Cale: If the optimiser can always found the case where it can drop the polymorphism, it would make sense to do it.
18:51:57 <darrint> And all I really needed to do was call D.B.get. :-D
18:52:32 <Cale> Jedai: Well, really, it should just be a warning message. "Hey, this thing is polymorphic so it might be evaluated more than once."
18:52:35 <Jedai> Cale: Of course for top level definition it can't say (but giving those a type signature is good practice anyways)
18:52:57 <Cale> Not "Your whole program is invalid because it's possible that this polymorphic thing is going to get evaluated twice."
18:53:00 <Twey> @src bracket
18:53:00 <lambdabot> bracket before after thing = block $ do
18:53:00 <lambdabot>     a <- before
18:53:00 <lambdabot>     r <- catch (unblock (thing a)) (\e -> do { after a; throw e })
18:53:00 <lambdabot>     after a
18:53:00 <lambdabot>     return r
18:53:54 <Jedai> Cale: I tend to agree, as long as the optimiser catch the most current (and significant performance-wise) cases where it can be applied
18:55:10 <Cale> Jedai: If it ever became a performance problem, fixing that problem would just mean adding a type signature.
18:55:27 <glen_quagmire> can I change Data.Map 's show so that it uses PrettyPrint ?
18:55:38 <Cale> Jedai: I'm pretty certain that such cases are exceedingly rare though.
18:56:04 <Cale> glen_quagmire: Not without editing that module.
18:56:16 <Jedai> Cale: I don't think so, not for those programmer that use many where clauses
18:56:22 <glen_quagmire> Cale: oh thank you
18:56:55 <allbery_b> class Show a => PrettyShow a where prettyShow = show; instance PrettyShow (Data.Map a) where prettyShow = ... -- ?
18:57:06 <Jedai> Cale: But it should be statically optimised anyway
18:57:10 <Cale> Jedai: with typeclass polymorphic pattern bindings that it's crucial they be evaluated once?
18:57:14 <allbery_b> something like that, I think
18:57:30 <SNJ> hello all
18:57:36 <allbery_b> actually you also need a showList
18:57:44 <allbery_b> rather, prettyShowList = showList
18:57:44 <Cale> hello, SNJ, are you new here?
18:57:45 <solrize> :t (comparing fst)
18:57:47 <lambdabot> forall a b. (Ord a) => (a, b) -> (a, b) -> Ordering
18:57:50 <solrize> ;t (==EQ)
18:57:54 <solrize> :t (==EQ)
18:57:55 <lambdabot> Ordering -> Bool
18:58:00 <SNJ> yes, i came here because i have a question actually
18:58:01 <solrize> :t ((==EQ) . (comparing fst))
18:58:02 <lambdabot>     Couldn't match expected type `Ordering'
18:58:03 <lambdabot>            against inferred type `(a, b) -> Ordering'
18:58:03 <lambdabot>     Probable cause: `comparing' is applied to too few arguments
18:58:10 <Cale> SNJ: cool, go right ahead :)
18:58:30 <SNJ> well im making this program called Mastermind, its just like the game
18:58:56 <SNJ> but now i have to read in a code (like: <1 2 3 4>) and make it a list: [1,2,3,4]
18:59:15 <SNJ> and ive been looking for the definitions of getChar and getLine (in my school book) but i cant find them :S
18:59:33 <sethk> SNJ, check the online docs
18:59:34 <Cale> getChar is typically primitive, and getLine could be implemented in terms of it
18:59:39 <Cale> :t getLine
18:59:39 <lambdabot> IO String
18:59:50 <SNJ> :t getChar
18:59:51 <lambdabot> IO Char
18:59:55 <SNJ> aha..
18:59:57 <Cale> The important thing to know about getLine is that it's an IO action that when executed gives you a string.
19:00:14 <Cale> (it does this by prompting the user of course :)
19:00:17 <SNJ> yeah i think i get how it works
19:00:37 <SNJ> but should i import anything to use getLine?
19:00:44 <Cale> You shouldn't have to
19:00:48 <Cale> It's in the Prelude.
19:00:49 <sethk> Cale, pompting?  It doesn't prompt, does it?  It justs waits
19:00:58 <solrize> @pl \x y-> ((comparing fst) x y) == EQ
19:00:58 <lambdabot> flip flip EQ . ((==) .) . comparing fst
19:01:10 <Cale> sethk: Right, it waits for a line of user input.
19:02:35 <shachaf> solrize: Is there a reason you're using compare instead of (==)?
19:02:44 <SNJ> cale: when i try to make a function with getLine in it
19:02:53 <solrize> hmm
19:03:08 <SNJ> i get "the last statement in a 'do' construct must be an expression"
19:03:18 <SNJ> pak :: IO String
19:03:19 <SNJ> pak = do x <- getLine
19:03:19 <SNJ> 	  	 putStr x
19:03:19 <SNJ> 		 return x
19:03:19 <shachaf> SNJ: Well... It's true. :-)
19:03:21 <solrize> :t (\x y -> fst x == fst y)
19:03:22 <lambdabot> forall b a b1. (Eq a) => (a, b) -> (a, b1) -> Bool
19:03:25 <allbery_b> indentation
19:03:26 <shachaf> SNJ: Oh, that's your indentation.
19:03:29 <SNJ> i belieave u
19:03:29 <Cale> SNJ: Looks like your indentation is off.
19:03:29 <solrize> @pl (\x y -> fst x == fst y)
19:03:29 <lambdabot> (. fst) . (==) . fst
19:03:35 <shachaf> SNJ: Just use spaces, for one; no tabs.
19:03:35 <SNJ> really?
19:03:37 <sethk> catch everyone later
19:03:38 <shachaf> It'll make things simpler.
19:03:41 <SNJ> ok
19:03:55 <Cale> SNJ: the first character in each statement in the do-block should line up.
19:04:07 <Cale> and yeah, make sure your editor is converting tabs to spaces for you
19:04:16 <SNJ> yeah it was my editor
19:04:23 <SNJ> i knew about the lining up things thingy
19:04:36 <SNJ> but i think my code is wrong anyway, cus i still got that error
19:04:43 <shachaf> solrize: (==) `on` fst
19:04:50 <solrize> hmm
19:04:55 <solrize> :t `on`
19:04:55 <Cale> pak = do x <- getLine
19:04:55 <lambdabot> parse error on input ``'
19:05:01 <solrize> :t on
19:05:02 <Cale>          putStr x
19:05:02 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
19:05:03 <shachaf> @paste?
19:05:03 <lambdabot> Haskell pastebin: http://hpaste.org/new
19:05:06 <Cale>          return x
19:05:11 <shachaf> @src on
19:05:11 <lambdabot> (*) `on` f = \x y -> f x * f y
19:05:27 <Cale> Well, that got pretty mangled by other people ;)
19:05:32 <SNJ> haha
19:05:37 <Cale> But that's how it should be indented anyway.
19:05:41 <solrize> @src on
19:05:41 <lambdabot> (*) `on` f = \x y -> f x * f y
19:05:45 <solrize> @hoogle on
19:05:45 <lambdabot> Data.Function.on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
19:05:45 <lambdabot> Text.ParserCombinators.Parsec.Char.oneOf :: [Char] -> CharParser st Char
19:05:45 <lambdabot> Data.Function :: module
19:06:32 <Cale> http://hpaste.org/6616 -- like that
19:06:37 <SNJ> im still getting that error :S
19:06:42 <Cale> hmm
19:07:00 <Cale> Maybe you could use hpaste to paste it?
19:07:02 <SNJ> how hard can it be to read the input from the user as a string ...
19:07:04 <shachaf> SNJ: @paste what you have?
19:07:09 <SNJ> hpaste?
19:07:10 <Cale> @paste
19:07:10 <lambdabot> Haskell pastebin: http://hpaste.org/new
19:07:13 <SNJ> @paste
19:07:13 <lambdabot> Haskell pastebin: http://hpaste.org/new
19:07:16 <SNJ> ok
19:07:51 <SNJ> http://hpaste.org/6617
19:08:06 <Cale> yes, that should be correct
19:08:27 <solrize> shachaf thanks
19:08:36 <SNJ> oh when i deleted everything else in my module, it wored
19:08:36 <shachaf> SNJ: Maybe the error is from somewhere else?
19:08:38 <SNJ> worked*
19:09:07 <Cale> SNJ: perhaps there's something somewhere else which is messed up...
19:09:14 <SNJ> yes ^^
19:09:40 <SNJ> 1 line above it
19:09:42 <SNJ> ok this is good
19:46:43 <glen_quagmire> http://hpaste.org/6618   how can I do this???
19:47:54 <glen_quagmire> I want to search through StateT [Map String Int]  inside monad
19:48:19 <glen_quagmire> i only want to throwError when the list of Map doesn't have it
19:49:47 <Jedai> glen_quagmire: use head . catMaybe . map (lookup key)
19:50:11 <mofmo1> So I'm having trouble integrating records with the state monad apparently
19:50:57 <Jedai> or rather case (catMaybe $ map (lookup key) xs) of { x:_ -> return ... ; [] -> throwError "..." }
19:51:05 <Cale> mofmo1: could you perhaps hpaste the definition of your record type?
19:51:30 <glen_quagmire> mofmo1: http://hpaste.org/6607  i tried this for you before
19:51:44 <glen_quagmire> Jedai: thank you! i'll try
19:52:02 <Jedai> ?ty catMaybes
19:52:04 <lambdabot> forall a. [Maybe a] -> [a]
19:52:56 <glen_quagmire> > catMaybes $ map (lookup "hey") [[("a", 1)], [("a", 2)]]
19:53:04 <lambdabot>  []
19:53:12 <glen_quagmire> nice it doesn't do error!
19:54:37 <mofmo1> Cale: I dunno if i'm doing this right > data Trip = Trip {loc :: Int, registers :: [Int], program :: [Expr]}
19:54:57 <Cale> okay, and so you probably have accessors like:
19:55:25 <Cale> setLoc :: Int -> State Trip ()
19:55:56 <mofmo1> i have some abbreviations that make spit out errors
19:55:57 <mofmo1> getLoc        = gets loc
19:56:00 <mofmo1> for example
19:56:00 <Cale> setLoc x = do s <- get; set (s { loc = x })
19:56:16 <mofmo1> apparently the ones that modify the record is ok
19:56:29 <Cale> and yeah, getLoc would look like that
19:56:49 <mofmo1> i think i have to make the type signature explicit
19:56:51 <mofmo1> let me try that
19:56:53 <Cale> and you may even want modifyLoc to apply a function to the loc field
19:57:06 <mofmo1> putLoc newLoc = modify (\ls -> ls {loc = newLoc})
19:58:02 <mofmo1> " No instance for (MonadState Trip m1)" is the error
19:58:02 <Cale> sure
19:58:12 <Cale> What's the type signature?
19:58:30 <mofmo1> i'm not really sure haha
19:58:36 <Cale> none at all?
19:58:39 <mofmo1> none
19:58:45 <Cale> hmm
19:58:59 <Cale> I'm not sure the problem is really in that code.
19:59:09 <mofmo1> lemme hpaste it
19:59:26 <Cale> Try adding the type signature   putLoc :: (MonadState Trip m) => Int -> m ()
19:59:47 <Cale> which should be the inferred type signature
20:00:06 <mofmo1> http://hpaste.org/6619
20:01:01 <Igloo> dons: popcon graphs have caught up now
20:01:20 <Cale> mofmo1: You're trying to show a State action?
20:01:26 <Cale> You have  show getReg
20:01:28 <mofmo1> uh yeah
20:01:38 <mofmo1> oh no that's a later on problem
20:01:39 <Cale> getReg is an action, it doesn't have an instance of Show
20:01:51 <mofmo1> yeah
20:01:57 <Cale> You're also missing a comma in that list of 0's
20:01:57 <mofmo1> a <- getReg
20:02:12 <mofmo1> hah! i'm missing 2
20:02:23 <mofmo1> i was putting it through ghci to check for errors
20:02:33 <mofmo1> but those werent the ones that i couldnt fix
20:03:07 <Cale> repl  = do x <- getReg
20:03:07 <Cale>            lift $ print x
20:03:14 <mofmo1> yeah
20:03:24 <Cale> and those two are the only things which need fixing
20:03:38 <mofmo1> well i fixed those and apparently ghci still wants a type signature
20:03:43 <Cale> what?
20:04:00 <mofmo1> Possible fix: add an instance declaration for (MonadState Trip m)
20:04:11 <Cale> http://hpaste.org/6619#a1
20:04:17 <Cale> that compiles for me
20:04:36 <mofmo1> hmm
20:04:39 <mofmo1> are you using 6.8.2?
20:04:42 <Cale> yep
20:04:56 <mofmo1> that's odd
20:05:09 <Cale> try copying my paste into a fresh file
20:05:48 <dons> Igloo: oh, great. thanks
20:05:51 <mofmo1> no luck
20:05:52 <mofmo1> hm
20:06:08 <Cale> paste the error?
20:06:20 <Cale> (on hpaste preferably)
20:06:30 <mofmo1> http://hpaste.org/6619#a2
20:06:39 <mofmo1> maybe it's because i'm interpreting?
20:06:47 <Cale> uh
20:06:48 <Cale> oh
20:06:53 <Cale> I can think of one thing
20:07:06 <Cale> {-# LANGUAGE NoMonomorphismRestriction #-}
20:07:12 <Cale> add that to the very top of your file
20:07:14 <mofmo1> 0_0
20:07:27 <ddarius> Cale: In your .ghci or something?
20:07:31 <Cale> yeah, it is
20:07:48 <mofmo1> what, what does it even mean?
20:07:59 <ddarius> It turns off the monomorphism restriction.
20:08:11 <mofmo1> which is...
20:08:21 <Cale> Haskell 98 had the stupid restriction that pattern bound variables (as opposed to function-bound variables) had to be monomorphic
20:08:22 <ddarius> Mostly a pain and not really important
20:08:30 <Cale> Unless they had explicit type signatures.
20:08:36 <newsham> short doc on functional references.  Looking for comments: http://www.thenewsh.com/%7Enewsham/accessor.lhs
20:08:45 <dons> Igloo: so the debian packages are now all stream ahead, right?
20:08:55 <dons> i should expect no problems with users picking them up
20:08:57 <Cale> http://haskell.org/haskellwiki/Monomorphism_restriction
20:08:59 <lambdabot> Title: Monomorphism restriction - HaskellWiki
20:09:46 <Igloo> dons: In unstable, on amd64 and i386 at least, yes
20:12:30 <dons> Igloo: are unstable packages widely used?
20:13:19 <dons> hmm, i see 'awesome' is into testing
20:14:22 <Igloo> dons: I suspect that most testing users would install something from unstable if they wanted it and it wasn't (new enough) in testing
20:16:30 * dons grumbles that its hard to take over the world without packages
20:16:54 <dons> how do we get xmonad into testing?
20:17:02 <darrint> Is is possible to use Data.Binary to create a heterogeneous list?
20:18:16 <ddarius> darrint: What do heterogeneous lists have to do with binary serialization?
20:20:06 <darrint> ddarius: In some other languages I can imagine ways to marshal and unmarshal heterogeneous collections from binary goo.
20:20:47 <mofmo1> oh, xmonad
20:20:49 <darrint> I'd like to do that here but it's not obvious how to get the type checker to agree with me.
20:20:58 <mofmo1> it was great and all but it didn't suit me aesthetically
20:21:01 <lament> or you could write a Python interpreter in Haskell, and then create a heterogenous list in Python, which is easy
20:21:05 <mofmo1> i need wobbly windows and expo
20:21:28 <dons> wobbly windows eh?
20:21:31 <mofmo1> yes
20:21:31 <marshmallows> :t read
20:21:32 <lambdabot> forall a. (Read a) => String -> a
20:21:33 <mofmo1> wobbly windows
20:21:40 <mofmo1> compiz-fusion xmonad HHAHAHA
20:21:41 <marshmallows> darrint: You can use a typeclass to do this, it's bascially read that you are writing, but on binary data instead of a String
20:21:49 <dons> mofmo1: its not as silly as you think
20:22:10 <mofmo1> i'm just not a big fan of tiling
20:22:25 <mofmo1> otherwise xmonad, as you of course know, is surprisingly stable and extensible
20:22:41 <ddarius> darrint: As you do in any language, your heterogeneous collection needs to have a uniform interface, otherwise you won't be able to do anything with what's in it.
20:22:42 <dons> surprisingly!
20:22:48 <mofmo1> in fact, when i told my professor that it was extensible in the language it was written he was surprised.
20:22:55 <ddarius> ...elements of your heterogeneous...
20:23:15 <mofmo1> he had this whole thing one time about how the Xerox Alto or something was awesome because the OS was in SmallTalk and extensible in SmallTalk
20:23:16 <ddarius> xmonad is very unsurprisingly stable.
20:23:19 <mofmo1> same with symbolics
20:23:43 <mofmo1> dons: surprisingly... for 500 lines
20:23:49 <lament> xmonad is proven not to crash, ever.
20:24:02 <darrint> Isn't Aren't Binary or Data or Typeable that interface already?
20:24:06 <mofmo1> xmonad can't crash unless you did something wrong
20:24:08 <lament> via a loophole in godel's argument
20:24:31 <mofmo1> xmonad crashing is something uncomputable.
20:24:39 <mofmo1> i proved it with diagonalization
20:25:17 <darrint> whoa. Bed time. I'll sleep on this. Thanks.
20:25:29 <ddarius> darrint: No.  However, you can package the Typeable stuff with data and you essentially get a Dynamic which you can then analyze at run-time to recover the type and operate on, but that's usually overkil.
20:26:02 <darrint> Dynamic. Might be exactly what I'm looking for. Is that a type class?
20:26:09 <solrize> Data.Dynamic
20:26:31 <solrize> @hoogle data.dynamic
20:26:32 <lambdabot> Did you mean: Data.dynamic
20:26:32 <lambdabot> Prelude.undefined :: a
20:26:32 <lambdabot> Control.Monad.State.Class.get :: MonadState s m => m s
20:26:34 <ddarius> It's a type, but as I said, it's usually overkill.  Your serialized data is unlikely to be any possible Haskell type at all.
20:26:46 <ddarius> More likely it's one of a relatively small set of types.
20:26:50 <dons> Oleg can make xmonad crash
20:27:09 <ddarius> The weak part of xmonad is X.
20:27:15 <darrint> ddarius: I understand what you are saying. Thanks.
20:27:17 <solrize> is that from "Oleg Kiselyov Facts" ?
20:27:48 <SamB> so... any plans to implement a strong window system?
20:27:57 <dons> well, Oleg can make total functions partial
20:28:07 <dons> so xmonad's proofs are unsound in Oleg's presence
20:28:22 <SamB> how can he do that?
20:28:25 <lament> @quote norris
20:28:25 <lambdabot> No quotes match. Your mind just hasn't been the same since the electro-shock, has it?
20:28:29 <lament> @quote chuck
20:28:29 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
20:28:33 <lament> @quote oleg
20:28:33 <ddarius> SamB: unsafeCoerce will do that quite handily.
20:28:33 <lambdabot> Korollary says: an olegweek is a complex entity with an imaginary part
20:28:34 <dons> ?quote oleg
20:28:34 <lambdabot> EvilTerran says: i get quite a lot of odd type errors, actually; probably something to do with my fascination with Olegian type hacks...
20:28:43 <dons> ?quote oleg
20:28:43 <lambdabot> Pseudonym says: What was considered 100 milli-Olegs of type hackery five years ago is standard operating procedure these days
20:30:25 <haksell> How can I make an infinite list of random numbers with newStdGen and randomRs?
20:30:47 <haksell> I'm quite a newb in this and must be overlooking something really simple
20:31:56 <ddarius> :t newStdGen
20:31:57 <lambdabot> IO StdGen
20:31:59 <marshmallows> :t randomRs
20:32:01 <lambdabot> forall a g. (RandomGen g, Random a) => (a, a) -> g -> [a]
20:32:07 <glen_quagmire> how can I call Map.adjust   when I only have (a -> m a)  not (a -> a) ?
20:32:22 <bos> here's my business card for when i found my haskell startup, to quell any fears that it won't be real world enough: http://www.monoscope.com/2008/03/used_cars_land_whiskey_manure.html
20:32:23 <ddarius> newStdGen >>= randomRs (low,high)
20:32:23 <marshmallows> :t newStdGen
20:32:24 <lambdabot> IO StdGen
20:32:28 <lambdabot> Title: USED CARS — LAND — WHISKEY — MANURE — NAILS (Monoscope), http://tinyurl.com/37v37s
20:32:54 <haksell> Thanks a lot
20:33:22 <marshmallows> actually
20:33:51 <marshmallows> I don't see how functional logic programming is any different from logic programming.. apart from expressions are nested
20:34:14 <marshmallows> looks like you could do a purely syntactic transform into Prolog
20:35:49 <mrd> hmm, oleg inflation
20:35:54 <ddarius> The functional parts are deterministic which can be awkward to achieve in Prolog (mostly due to Prolog's yuckiness), and higher order functions are more than a "syntactical" transform into Prolog.
20:35:59 <glen_quagmire> is there a way to make  a -> m a   into a -> a ?
20:36:19 <ddarius> flip const
20:36:30 <marshmallows> you just stick call in some places to do higher order stuff
20:36:33 <sjanssen> glen_quagmire: not forall m
20:36:50 <ddarius> :t flip const :: (a -> m a) -> a -> a
20:36:51 <lambdabot> forall a (m :: * -> *). (a -> m a) -> a -> a
20:37:17 <ddarius> marshmallows: You'd still have to gather up captured variables
20:37:35 <glen_quagmire> > filp const (return) 1
20:37:35 <lambdabot>   Not in scope: `filp'
20:37:58 <marshmallows> I don't think so..
20:38:23 <sjanssen> @djinn (a -> m a) -> (a -> a)
20:38:23 <lambdabot> f _ a = a
20:38:29 <marshmallows> if you have adds(N, ListI, ListO) :- maplist(add(N), ListI, ListO).
20:38:41 <sjanssen> @. pl djinn (a -> m a) -> (a -> a)
20:38:41 <lambdabot> f = const id
20:38:42 <marshmallows> N is bound by the clause
20:39:00 <ddarius> marshmallows: N is not a captured variable.
20:39:42 <ddarius> Prolog doesn't really have much of a notion of nested scope so you'll be hard pressed to make an example in Prolog.
20:41:08 <haksell> ddarius: newStdGen >>= randomRs (low,high) still doesn't do the trick
20:41:52 <marshmallows> I just don't see how function logic programming is any different from logic programming
20:42:02 <marshmallows> it seems like all that is different is the syntax
20:42:56 <glen_quagmire> how can I pattern match Wrap :: E.ErrorT Err (S.StateT EnvStack IO) a -> Wrap a   ?
20:43:20 <glen_quagmire> unpacker (ErrorT Err (StateT EnvStack IO) a) = a
20:43:53 <ddarius> marshmallows: Is functional programming readily a subset of logic programming in your eyes?
20:44:03 <marshmallows> no
20:44:23 <sclv> glen_quagmire: do you mean you want to extract the a?
20:44:31 <sclv> its in the IO monad, so you can't.
20:44:36 <glen_quagmire> sclv: yes. ooops
20:44:47 <sjanssen> glen_quagmire: what is the defn. of Wrap?
20:44:57 <ddarius> marshmallows: Then clearly functional logic programming isn't either.
20:45:09 <marshmallows> It's not clear :|
20:45:13 <glen_quagmire> newtype Wrap a = Wrap {  runWrap :: E.ErrorT Err (S.StateT EnvStack IO) a } deriving (....)
20:45:16 <marshmallows> I mean based on the name .. sure it's different
20:45:25 <newsham> some things are more clear to ddarius than to the rest of us
20:45:29 <glen_quagmire> it does use IO monad
20:45:31 <marshmallows> but actually looking at all these implementations.. it doesn't seem like there's anything new
20:45:52 <glen_quagmire> i just want to update Map String Val   with eval :: Val -> Wrap Val
20:46:13 <SamB> what kind of profile do I do if I want to find out where a particular data constructor is being allocated?
20:46:13 <glen_quagmire> i.e.  apply eval for all elements in the map
20:47:16 <sclv> ?hoogle traverse
20:47:17 <lambdabot> Data.Traversable.traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
20:47:17 <lambdabot> Data.Foldable.traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
20:47:17 <EmptyD> learning haskell, me. running kubuntu. is kate a pretty reasonable editor for haskell?
20:47:30 <EmptyD> and any reason to prefer ghc over hugs for learning?
20:47:36 <ddarius> EmptyD: If you like Kate use it.
20:47:42 <ddarius> EmptyD: Use GHC, ignore Hugs.
20:47:49 <newsham> ghc is a good place to start because if you kep doing haskell you'll probably end up there anyway
20:48:00 <SamB> hugs has one feature and one feature only:
20:48:06 <sclv> traverse is mapM but generalized from list to any functor and from a monad to any applicative.
20:48:11 <SamB> it loads things fast if it loads them at all
20:48:23 <newsham> hugs also does :e which is kinda nice :)
20:48:53 <marshmallows> is there any "functional logic language" that isn't just prolog with new syntax?
20:48:56 <ddarius> You could probably :def a few things to get that.
20:49:06 <EmptyD> good enough.  ghc for now until i understand some of the diffs.  thx all!
20:49:06 <ddarius> marshmallows: If nothing else, all the functional parts.
20:49:07 <SamB> ddarius: how?
20:49:08 <glen_quagmire> sclv: thank you. i will try
20:49:24 <marshmallows> I don't know what you mean
20:49:42 <EmptyD> if someone said (x)emacs was really *excellent* for haskell, then i'd go back to that.  otherwise kate == easy.
20:50:19 <ddarius> marshmallows: You stated that you don't consider functional programming to be a subset logic programming, therefore a language that allows you to use FP -and- LP can't then be a subset (or equal to) LP.
20:51:15 <newsham> i like ddarius because he makes me feel dumb
20:51:24 <marshmallows> ok but actually looking at these implementations they seem to actually be nothing more than prolog with new syntax
20:51:33 <marshmallows> e.g. Curry
20:53:05 <ddarius> Write, f xs = let sumxs = sum xs in \y -> sumxs + y in Prolog.
20:53:55 <ddarius> (I could find a better example, but I need to start getting ready to sleep.)
20:54:31 <marshmallows> f(XS, add(Sum)) :- sum_list(XS, Sum).
20:54:43 <sclv> and where's the lambda?
20:55:00 <glen_quagmire> oh darn there is no ApplicativeT
20:55:25 <glen_quagmire> oh i just instantiate
20:55:35 <sclv> glen_quagmire: if Wrap derives Monad then it can be an instance of applicative easy.
20:55:37 <sclv> right.
20:55:57 <sclv> where pure = return; <*> = ap;
20:56:52 <sclv> traverse with your eval will give you Map String Val -> Wrap (Map String Val).
20:57:07 <sclv> if you really want -> Map String (Wrap Val) you can just use M.map...
20:57:38 <cjb> SamB: So what you're saying is, hugs is the Sun Workstation of the Haskell world?  :)
20:57:40 <sclv> or, erm, fmap
20:57:49 <sclv> @slap sclv
20:57:49 * lambdabot places her fist firmely on sclv's jaw
20:58:21 <SamB> cjb: I was saying that it has a fast compiler
20:58:34 <sclv> it has no compiler.
20:58:39 <SamB> but it has bad error messages, slow bytecode...
20:58:54 <SamB> sclv: how the heck does it generate bytecode then?
20:59:46 <sclv> are you sure you mean hugs?
20:59:51 <cjb> SamB: I was thinking of http://research.microsoft.com/~daniel/preface.html -- scroll down to "pros and cons of Suns"
20:59:52 <lambdabot> Title: Preface to THE UNIX-HATERS HANDBOOK
21:00:09 <ddarius> marshmallows: Your example demonstrates the manually "gathering up" of captured variables that I discussed (you are manually closure-converting your code).  Furthermore, the only way to make use of the result is to use a non-logical feature of Prolog.
21:00:23 <marshmallows> yes
21:00:46 <marshmallows> since Prolog is first order, we use metalogical to fake higher orderness
21:01:18 <ddarius> By that logic, Prolog is a subset of Scheme because I could "syntactically transform" it to Scheme code using call/cc.
21:02:04 <marshmallows> well I guess..
21:02:14 <SamB> cjb: except apparantly hugs also has meta-point
21:02:15 <marshmallows> I mean all turing complete languages are subsets of each other
21:02:26 <marshmallows> it's just the differences are somtimes meaningful
21:02:48 <ddarius> But not all Turing complete languages are "syntactical transforms" of each other in the way I'm using it.
21:02:53 <marshmallows> I feel like I'm not seeing the trees for the forest though, but I just don't see any meaningful difference from Prolog and Curry
21:03:00 <marshmallows> yes, that's true
21:03:13 <SamB> @google on the expressive power of programming languages
21:03:15 <lambdabot> http://www.ccs.neu.edu/scheme/pubs/scp91-felleisen.ps.gz
21:03:28 * SamB wonders if that's the one he wanted
21:03:34 <glen_quagmire> sclv: thanks! it kinda works. but found other problems (for tomorrow)
21:03:42 <ddarius> SamB: Yes.
21:04:01 <allbery_b> sendmail.cf language is turing complete.  not that anyone sane would program in it
21:04:08 <SamB> indeed, it is the one that I wanted
21:04:23 <newsham> cjb: ys, a very intelligent rant that starts "this is my fifth day using a sun"
21:04:24 <allbery_b> and I don't even want to think about how you'd simulate either prolog or haskell in it :)
21:04:37 <newsham> obviously well qualified to pen a treatise on its merits and shortcomings
21:05:09 <SamB> my computer is even worse ;-)
21:05:20 <SamB> when things die, they don't even bother to dump core
21:05:23 <SamB> they just crash!
21:06:44 <newsham> " If I want to edit the code of a function Foo, I have to switch to a shell window and grep for named Foo in various files. Then I have to type in the name of the appropriate file. Then I have to correct my spelling error. Finally I have to search inside the file."
21:06:49 <newsham> obviously a unix power user
21:07:14 <newsham> why not just type 'v regexp' and jump right to the offending line?
21:07:19 <SamB> eh?
21:07:20 <allbery_b> how old is that though?
21:07:31 <SamB> you'd think he'd be able to use the mouse!
21:07:39 <SamB> at the very least
21:07:45 <SamB> or he could have used M-x grep
21:07:50 <newsham> allbery: nix haters book is old
21:07:55 <allbery_b> yep
21:07:59 <SamB> surely they had that back then!
21:08:07 <newsham> but shell scripts to grep files and open editors are older
21:08:34 <allbery_b> my point is that a lot of the stuff people take for granted wasn't around, and part of the "unix haters" mindset is that people shouldn't have to be "tool users"
21:08:39 <newsham> and if he's not clever enough to write one after the 2nd time, then i dont care to read his rant
21:08:49 <allbery_b> which is an exaggeration but has a certain amount of truth to it'
21:08:59 <newsham> if you're not a tool user you shouldnt be a programmer
21:09:11 <SamB> allbery_b: well, they should just throw out their computers then ;-P
21:09:16 <newsham> you can still use a computer, but only if it was made after 1995
21:09:22 <lament> if you're not a tool, you shouldn't be a programmer!
21:09:25 <allbery_b> you're missing the point
21:09:29 * cjb is officially sick of teaching ^R search in bash to his coworkers.
21:09:36 <newsham> if you're not a tool person and its 1988, you shouldnt be using a computer
21:09:40 <allbery_b> *I* shhouldn't have to reinvent the same script everyone else has had to
21:09:45 <solrize> that fellieisen paper formalizes the blub paradox :)
21:09:47 <SamB> a computer *is* a tool
21:10:00 <newsham> allbery: then get it from uunet
21:10:06 <SamB> but no, you shouldn't have to make the same godawful script as everyone else
21:10:06 <lament> why is the blub paradox a paradox?
21:10:20 <allbery_b> the correct answer here is vi+ctags, emacs+etags, cscope+vi, etc.
21:10:29 <SamB> emacs+cscope!
21:10:35 <newsham> but actually you *SHOULD* have to write the shell script
21:10:35 <SamB> but too bad that doesn't work for Haskell code
21:10:42 <newsham> because your situation is not my ituation
21:10:46 <solrize> what i mean is that paper only concentrates on aspects of expressiveness that are in scheme, but really, scheme = blub.
21:10:47 <marshmallows> what seperates Function and Logic programming?
21:10:50 <newsham> and you should be able to make tools for your situation
21:10:54 <SamB> I really wish it did
21:10:58 <solrize> as every haskell user knows ;)
21:10:59 <marshmallows> solrize: For you maybe
21:11:01 <SamB> I would SO use cscope with Haskell code
21:11:10 <allbery_b> but I'm not sure cscope existed outside Bell Labs in 1988
21:11:11 <SamB> solrize: eh?
21:11:17 <allbery_b> SamB: hasktags?
21:11:23 <marshmallows> solrize: But you know what that means.. haskell is your blub
21:11:27 <SamB> that paper defines a partial ordering on expressive power!
21:11:33 <solrize> marshmallows, that could be
21:11:36 <SamB> that partial ordering has NOTHING TO DO WITH SCHEME
21:12:04 * allbery_b wonders if modern cscope is modular enough that haskell support could be easily added
21:12:17 <lament> Scheme = Blub. It's proven now.
21:12:22 <allbery_b> the one that got open sourced was pretty specific to C-like languages
21:12:26 <lament> We should notify PG that blub has been discovered
21:12:48 <solrize> samb that paper only discusses the kinds of computations the language can express about values, not the kinds of stuff it can express about the computations themselves--that's what type systems are for
21:13:01 <SamB> solrize: I'm not seeing that
21:13:11 <marshmallows> It's so frusting .. I understand Functional programming and I understand Logic programming.. just can't see what's new in Functional-Logic :(
21:13:12 <SamB> I'm seeing the definition of macro-expressibility...
21:13:30 <solrize> lemme look at it again
21:13:33 <allbery_b> anyway, my point is that while some tools existed for unix development, they weren't available to ordinary programmers in 1988
21:13:44 <allbery_b> and the ones that did were painful at best
21:13:49 <ddarius> marshmallows: There shouldn't be anything new, it should be a fusion, though some techniques become practical that wouldn't be available in either.
21:13:59 <SamB> perhaps some parts of the paper concentrate on terms rather than types, but types are just a different kind of term at heart anyway...
21:14:01 <marshmallows> hmm ok
21:14:03 <ddarius> s/available/reasonable
21:14:16 <marshmallows> ddarius: Thank you
21:14:17 <allbery_b> and it was left to the programmer to fix them or suffer.  (and 1988 was before open source really started to ramp up; uunet only did so much good)
21:14:29 <marshmallows> (for discussing this all with me, seems to make more sense now)
21:15:34 <allbery_b> hm, ok, have to correct m,yself.  cscope existed, if your unix vendor had licensed the programmers workbench stuff from at&t, and you were willing to pay extra for it
21:16:09 <allbery_b> and if you ran a 4.2BSD derivative you were screwed because it only ecxisted for System III/V
21:16:11 <SamB> hmm, it DOES sound like he tried to use emacs ... and the mouse ...
21:16:22 <SamB> but failed due to circumstances outside his control
21:17:18 <solrize> samb, there's no natural way in scheme to express that two functions with different structure do the same computation.  haskell comes a little closer.  pointy-headed languages that are too big for my brain (e.g. agda) go further still.  i don't know if there's anything after that.
21:17:19 <SamB> (static linking, say)
21:18:15 <SamB> solrize: this paper is talking about how you can say "this extension makes the language more expressive" and things like that
21:18:33 <allbery_b> (complaints about the nonintuitiveness of emacs can be ignored.  IIRC in 1988 the most widely used programmers editor for dos/windows had ^Kd as the exit command)
21:19:02 <SamB> solrize: for instance, typeclasses make Haskell more expressive
21:19:10 <solrize> hmm
21:19:10 <SamB> solrize: as do constructor classes
21:20:01 <SamB> (Haskell with constructor classes, of course, being compared against Haskell with typeclasses)
21:20:14 <ddarius> constructor classes arguably do so in a somewhat different way
21:20:34 <SamB> ddarius: they are a generalization of typeclasses
21:20:47 <SamB> to arbitrary kinds
21:20:53 <ddarius> Type classes can be expressed via dictionary passing, say, in Haskell 98 (- type classes), but the dictionaries for constructor classes can't be typed in Haskell 98.
21:21:06 <solrize> what are constructor classes?
21:21:15 <SamB> solrize: classes like Monad
21:21:17 <dons> hehe, long term impact on reddit, http://www.urbandictionary.com/define.php?term=reddit
21:21:17 <lambdabot> Title: Urban Dictionary: reddit
21:21:21 <solrize> ok
21:21:31 <dons> "Typical reddit postings: 20 reasons why Lisp is better than Haskell; 10 reasons why Arc is better than Lisp ; 15 reasons why Haskell is better than Arc"
21:21:52 <SamB> which are classes of type *constructors*, which have kinds other than *
21:22:03 <marshmallows> o_o arc sucks
21:22:05 <SamB> in Monad's case, the kind is * -> *
21:22:08 <solrize> right i understand that
21:22:13 <solrize> just making sure
21:22:18 <marshmallows> why are people still interested in it? :/
21:22:39 <lament> somebody needs _reasons_ why haskell is better than arc?
21:22:51 <SamB> ddarius: so do you think that typeclasses are macro expressible in Haskell 98?
21:23:12 <solrize> what is arc?  i mean i know what it is, but can someone give a one-sentence lisp hacker description?
21:23:23 <ddarius> SamB: They obviously aren't, but at least they are expressible at all.
21:23:36 <lament> solrize: scheme with shorter names for builtins.
21:23:48 <solrize> lament but i thought it was worse than scheme
21:23:55 <SamB> ddarius: can you formalize the difference?
21:24:00 <ddarius> Arc is Paul Graham's language, that is it's only defining feature.
21:24:01 <lament> right, because it puts emphasis on obfuscation
21:24:12 <mae> is there guide someone can point me to for extracting data from xml with haxml
21:24:25 <Philippa> Arc is what happens if you try to build a lisp that's a DSL
21:24:29 <marshmallows> solrize: "Lisp for kids"
21:24:31 <solrize> yeah i just sort of remember someone describing some crazy stuff in it, but anyway "scheme with shorter names for builtins" will do i guess
21:24:34 <mae> i have been able to generate a cfilter for my xml documenter but i don't know how to turn this into the datatypes i need
21:24:42 <mae> document *
21:24:44 <solrize> but it's paul graham's, so it must have a moby macro system !!!
21:24:44 <marshmallows> solrize: and by kids I mean 8 year olds :P
21:24:46 <ddarius> SamB: The dictionaries for type classes are typeable in Haskell 98, the dictionaries for constructor classes are not.  (However, you may use some other encoding that may allow you to embed constructor classes in Haskell 98)
21:25:16 <Philippa> Haskell 98 doesn't have a separate notion of 'constructor class', mind
21:25:19 <solrize> marshmallows, that's interesting, i hadn't heard that (about being for kids).  someone was just asking whether python was good for 9th graders maybe i should have said something about arc.
21:25:26 <roconnor> HOgg has a demux command.
21:25:30 <ddarius> marshmallows: If that were the case, it would actually be interesting.
21:25:32 <SamB> Philippa: I know that!
21:25:38 <solrize> anyway i seem to remember that the Y combinator can't be expressed in typed lambda calculus
21:25:41 <roconnor> I wonder if it is good we didn't call partitionEithers demux.
21:25:42 <SamB> Philippa: I'm speaking from a historical perspective
21:25:43 <shachaf> solrize: What about Haskell?
21:25:49 <marshmallows> solrize: That's true
21:25:53 <lament> lisp for 8 year olds already exists and is called Logo
21:25:55 <solrize> which makes scheme more, ahem, "expressive" than haskell
21:26:00 <solrize> lament, true
21:26:01 <marshmallows> shachaf: Haskell cannot type the y combinator
21:26:15 <shachaf> marshmallows: I meant the bit about being for kids. :-)
21:26:15 <SamB> Haskell can handle Y just fine
21:26:19 <roconnor> solrize: http://r6.ca/blog/20060919T084800Z.html
21:26:19 <lambdabot> Title: Y Combinator in Haskell
21:26:21 <marshmallows> SamB: No
21:26:31 <marshmallows> that's something else
21:26:34 <SamB> you just need a newtype
21:26:39 <SamB> ;-P
21:26:58 <SamB> to ward off the occurs check
21:27:02 <lament> haskell has a turing-complete type system, it can do _anything_!
21:27:19 <roconnor> It's LISP and scheme that cannot do THE Y combinator.
21:27:28 <ddarius> lament: No it doesn't.  GHC Haskell does, but only when explicitly requested.
21:27:31 <roconnor> because they are strict
21:27:40 <lament> ddarius: yes, i sure hope so :)
21:27:59 <marshmallows> roconnor: one more lambda (to delay evaluation) never hurt a soul :P
21:27:59 <SamB> does GHC support doing IO from the typesystem yet?
21:28:30 <ddarius> > fix (1:)
21:28:31 <lament> * -> /dev/hda
21:28:31 <SamB> marshmallows: what about all of those wasted reductions from repeated evaluation?
21:28:33 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
21:28:41 <roconnor> marshmallows: unit -> a makes baby jesus cry.
21:28:41 <marshmallows> n
21:28:42 <shachaf> SamB: If you include printing errors. :-)
21:28:43 <dons> SamB: well, you can do it prior to type checking
21:29:21 <SamB> dons: TH's Quasi monads are not part of the typesystem, FYI
21:30:16 <dons> i think i already made that clear, didn't I?
21:32:07 <SamB> it doesn't seem to have stopped you from answering innapropriately ;-P
21:32:48 <dons> i think you're taking things too seriously
21:33:21 <SamB> don't I always?
21:36:30 <dobblego> no
21:37:16 <marshmallows> Has there ever been an ISWIM implementation?
21:37:24 <marshmallows> I think Haskell is the closest language isn't it?
21:37:40 <QtPlatypus> expn ISWIN?
21:37:57 <marshmallows> the closest thing that's been actually implemented*
21:38:16 <solrize> Although not implemented, it has proved very influential in the development of programming languages, especially functional programming languages such as SASL, Miranda, ML, Haskell and their successors.
21:38:25 <solrize> http://en.wikipedia.org/wiki/ISWIM
21:38:31 <lambdabot> Title: ISWIM - Wikipedia, the free encyclopedia
21:39:30 <solrize> sounds like scheme
21:39:56 <solrize> anyway what i'm getting at is the paper only seems concerned with dynamic semantics
21:40:42 <roconnor> ``Another line of descent from ISWIM is to strip out the imperative features (assignment and the J operator) leaving a purely functional language. It then becomes possible to switch to lazy evaluation.
21:40:47 <roconnor> ?
21:41:04 <ddarius> The good ole J operator.
21:41:17 <marshmallows> does any language with a J operator exist?
21:41:20 <solrize> J = continuation passing
21:41:32 <solrize> scheme, more or less /
21:41:33 <solrize> ?
21:41:37 <marshmallows> I though J is call-with-current-continuation on steroids
21:41:46 <solrize> hmm
21:41:49 <roconnor> in what way  is ISWIM is to strip out the imperative features (assignment and the J operator) not simply the lambda calculus?
21:41:54 <marshmallows> i.e. not implementable in terms of
21:42:14 <marshmallows> roconnor: Maybe it's got datatypes?
21:42:15 <ddarius> roconnor: In what way is a purely functional language not simply the lambda calculus?
21:42:16 <marshmallows> like haskell
21:42:26 <roconnor> ``A notationally distinctive feature of ISWIM is its use of where clauses.
21:42:27 <solrize> http://www.brics.dk/~hosc/local/HOSC-11-2-pp117-123.pdf
21:42:28 <roconnor> ah
21:42:55 <roconnor> oh and algebraic data types
21:42:56 <roconnor> okay
21:43:50 <solrize> J captures the state of the heap ?
21:44:23 * marshmallows wonders if J alone is TC..
21:44:35 <solrize> tc ?
21:44:50 <marshmallows> able to compute anything a turing machine can compute
21:44:55 <solrize> oh
21:44:56 <solrize> hm
21:45:02 <marshmallows> it probably is
21:45:05 <marshmallows> almost everything is..
21:45:24 <lament> a box of apples and a string...
21:58:34 <EmptyD> hmm.  i thought ubuntu had a xmonad package.  don't see it.
22:04:03 <bd_> EmptyD:
22:04:04 <bd_>      0.6-3 0
22:04:04 <bd_>         990 http://archive.ubuntu.com hardy/universe Packages
22:04:05 <lambdabot> Title: Index of /
22:04:10 <bd_> it's there
22:04:14 <bd_> maybe not in the stable distribution
22:06:36 <EmptyD> bd_: thx! my misunderstanding then. i've already started my compile!  ;)
22:15:01 <dons> EmptyD: it does, http://packages.ubuntu.com/hardy/xmonad
22:15:02 <lambdabot> Title: Ubuntu -- Details of package xmonad in hardy
22:15:06 <dons> so in unstable ?
22:18:49 <EmptyD> dons: thx! i'm scared of breaking my productive kde environ but i've found some good blog tips to make it coexist w/ xmonad.
22:26:28 <jaj> "productive kde environ", isn't that an oxymoron? ;)
22:29:40 <dons> EmptyD: we'd be interested in improving kde app use with xmonad
22:29:47 <dons> so if you've any suggestions, drop by #xmonad
23:32:09 <solrize> "While they have been turned into a tool of intellectual terrorism, the original paper on monads is actually quite easy to understand and fun to read."
23:32:14 <solrize> http://abaababa.blogspot.com/2008/02/monads-are-class-of-hard-drugs.html
23:32:16 <lambdabot> Title: Abaababa: Monads are a class of hard drugs, http://tinyurl.com/2kdlnx
23:35:22 <solrize> "Other than the ST monad (which is unusual because it needs an explicit universal quantifier and so can't be inferred), you really don't have to write explicit type annotations for your monadic code."
23:35:24 <solrize> what does that mean?
23:35:25 <dons> bomb thrower :)
23:36:11 <dons> hmm. ST doesn't need a type annotation
23:36:12 <solrize> it's weird, i saw some other article about parser combinators in python being slow and i went well ok, that's because python is doing no optimization at all on HOF composition etc
23:36:34 <solrize> and then i saw this other thing and thought it was going to say monad composition was hard to compile or osmething like that
23:36:44 <solrize> but it actually seems sort of content free
23:37:14 <solrize> i can't tell whether he is onto anything or not
23:37:36 <solrize> he says haskell programs are slow and blames it on the type system; more commonly i see it blamed on lazy semantics
23:38:04 <marshmallows> type system doesn't affect the runtime behavior of programs
23:38:06 <dons> haskell programs aren't really slow though. there's plent of ones that outperform ocaml
23:38:51 <solrize> well if they're carefully tweaked, it sounds
23:39:18 <dons> like any high performance code
23:39:43 <solrize> i have the impression that spewing code onto the screen in ocaml tends to result in pretty fast code if you're even slightly careful about algorithms
23:40:07 <solrize> while haskell has all these hazards
23:40:52 <solrize> otoh ocaml maybe ends up being just more imperative mutation code
23:42:39 <dons> it tends to be effectful, yes. so apples and oranges.
23:42:55 <dons> also, we don't have much data, so i'd argue impressions are just that
23:43:39 * dons wants to see real examples, rather than impressions :)
23:43:55 <solrize> ghc vs clean/hugs/ocaml
23:43:59 <solrize> darcs vs git
23:44:14 <dons> darcs vs git aren't even remotely comparable!
23:44:28 <solrize> parsec vs borland c++ compiling faster on 100x slower hardware
23:44:49 <dons> apples vs oranges!
23:44:53 <solrize> true :)
23:44:55 <dons> choose *one*
23:45:29 <dons> on the other hand, xmonad is considered a very fast window manager
23:45:40 <dons> let's check that against kde
23:45:48 <dons> ... comparing ...
23:45:50 <dons> wow, haskell rocks!
23:45:51 <dons> :)
23:45:56 <solrize> :)
23:46:10 <solrize> i can't for the life of me understand why there's so much godawful bloat in window systems and toolkits
23:46:16 <solrize> i mean, xmonad vs. the original 128k macintosh...
23:50:26 <dons> software tends to behave as a gas
23:51:43 <solrize> yeah i saw a good nightmarish of the enterprise java development process (exponential bloat due to multiple layers of nested wrapped cruft).  with window systems it seems almost the same
23:51:52 <solrize> nightmarish -> nightmarish description
23:53:47 <solrize> neel k. had a fairly compelling rant claiming erlang's concurrency model (message passing) was better than STM on parallel processors
23:55:31 <dons> STM is just a different tools
23:55:33 <solrize> i really have to wonder just when the O(log n) instead of constant time operations on functional data structures start catching up with you
23:55:37 <solrize> when n is large
23:55:42 <dons> its not like you get to choose just one option
23:55:46 <dons> well, ok, in erlang you do.
23:55:52 <dons> but in haskell, STM is just one of many options
23:55:58 <dons> and its appropriate for some problems
23:56:12 <dons> in other cases, e.g. under high contention, there are bottlenecks
23:56:24 <dons> edwardk: what's all this about ST not being inferrable?
23:56:34 <julz> Hi was here some houres ago and asked about http://hpaste.org/6610 (original) and http://hpaste.org/6608 (made changes) I cant get it running
23:56:45 <edwardk> dons: probably me remembering something from way back that isn't accurate =)
23:57:06 <dons> edwardk: rank-2 is ok. there's even a shootout program that's using inferred ST
23:57:10 <edwardk> ah
23:57:13 <edwardk> my bad
23:57:33 <solrize> what's rank 2?
23:57:39 <dons> when using ST arrays you often needed to annotate the newArray call, to resolve MArray overloading, and pick a numeric element type, but that's a separate issue
23:58:00 <dons> http://www.haskell.org/haskellwiki/Rank-N_types
23:58:01 <lambdabot> Title: Rank-N types - HaskellWiki
23:58:02 <edwardk> speaking of quantification, feel like skimming over http://comonad.com/reader/2008/rotten-bananas/ and letting me know if its coherent? i just put it up
